public static Linux Desktop detect Desktop Session ( ) { Array List < String > command = new Array List < String > ( ) ; command . add ( STRING ) ; command . add ( STRING ) ; command . add ( STRING ) ; Map < String , Object > desktops = new Hash Map < String , Object > ( ) ; desktops . put ( STRING , Linux Desktop . desktop Kde ) ; desktops . put ( STRING , Linux Desktop . desktop Gnome ) ; desktops . put ( STRING , Linux Desktop . desktop Cinnamon ) ; desktops . put ( STRING , Linux Desktop . desktop Xfce ) ; Object desktop = Utils . is Expected Command Output ( command , desktops ) ; if ( desktop != null ) { return ( Linux Desktop ) desktop ; } return Linux Desktop . desktop Unknown ; }
public static Linux Desktop detect Desktop Session ( ) { Array List < String > command = new Array List < String > ( ) ; command . add ( STRING ) ; command . add ( STRING ) ; command . add ( STRING ) ; Map < String , Object > desktops = new Hash Map < String , Object > ( ) ; desktops . put ( STRING , Linux Desktop . desktop Kde ) ; desktops . put ( STRING , Linux Desktop . desktop Gnome ) ; desktops . put ( STRING , Linux Desktop . desktop Cinnamon ) ; desktops . put ( STRING , Linux Desktop . desktop Xfce ) ; Object desktop = Utils . is Expected Command Output ( command , desktops ) ; if ( desktop != null ) { return ( Linux Desktop ) desktop ; } return Linux Desktop . desktop Unknown ; }
public void removed ( java . awt . Container cont ) { }
public void removed ( java . awt . Container cont ) { }
public void removed ( java . awt . Container cont ) { }
public Builder delete User Type ( ) { delete Fields . add ( STRING ) ; return this ; }
public static boolean register Transform ( final String transform URI ) { final boolean added = transforms . add ( transform URI ) ; return added ; }
void increment Schema ( String schema Name ) { if ( schema Name != null ) { Integer count = db Map . get ( schema Name ) ; if ( count == null ) db Map . put ( schema Name , NUM ) ; else db Map . put ( schema Name , count . int Value ( ) + NUM ) ; } last Db = schema Name ; }
static void create Policy Tree ( String config Name , String config Id , Service Config Manager scm , String org ) throws No Permission Exception , Policy Exception , SSO Exception { try { Service Config p Config = scm . get Organization Config ( org , null ) ; if ( p Config == null ) { scm . create Organization Config ( org , null ) ; p Config = scm . get Organization Config ( org , null ) ; } p Config . add Sub Config ( config Name , config Id , NUM , null ) ; } catch ( Service Already Exists Exception se ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + config Name + STRING + config Id + STRING + org ) ; } } catch ( SMS Exception e ) { String [ ] objs = { org } ; if ( e . get Exception Code ( ) == SMS Exception . STATUS NO PERMISSION ) { throw ( new No Permission Exception ( Res Bundle Utils . rb Name , STRING , null ) ) ; } else { throw ( new Policy Exception ( Res Bundle Utils . rb Name , STRING , objs , e ) ) ; } } }
Native Object ( long address ) { this . allocation Address = address ; this . address = address ; }
Native Object ( long address ) { this . allocation Address = address ; this . address = address ; }
Native Object ( long address ) { this . allocation Address = address ; this . address = address ; }
void update Visibility Model ( ) { Component c = get Container ( ) ; if ( c instanceof J Text Field ) { J Text Field field = ( J Text Field ) c ; Bounded Range Model vis = field . get Horizontal Visibility ( ) ; int hspan = ( int ) get Preferred Span ( X AXIS ) ; int extent = vis . get Extent ( ) ; int maximum = Math . max ( hspan , extent ) ; extent = ( extent == NUM ) ? maximum : extent ; int value = maximum - extent ; int old Value = vis . get Value ( ) ; if ( ( old Value + extent ) > maximum ) { old Value = maximum - extent ; } value = Math . max ( NUM , Math . min ( value , old Value ) ) ; vis . set Range Properties ( value , extent , NUM , maximum , BOOL ) ; } }
void update Visibility Model ( ) { Component c = get Container ( ) ; if ( c instanceof J Text Field ) { J Text Field field = ( J Text Field ) c ; Bounded Range Model vis = field . get Horizontal Visibility ( ) ; int hspan = ( int ) get Preferred Span ( X AXIS ) ; int extent = vis . get Extent ( ) ; int maximum = Math . max ( hspan , extent ) ; extent = ( extent == NUM ) ? maximum : extent ; int value = maximum - extent ; int old Value = vis . get Value ( ) ; if ( ( old Value + extent ) > maximum ) { old Value = maximum - extent ; } value = Math . max ( NUM , Math . min ( value , old Value ) ) ; vis . set Range Properties ( value , extent , NUM , maximum , BOOL ) ; } }
void update Visibility Model ( ) { Component c = get Container ( ) ; if ( c instanceof J Text Field ) { J Text Field field = ( J Text Field ) c ; Bounded Range Model vis = field . get Horizontal Visibility ( ) ; int hspan = ( int ) get Preferred Span ( X AXIS ) ; int extent = vis . get Extent ( ) ; int maximum = Math . max ( hspan , extent ) ; extent = ( extent == NUM ) ? maximum : extent ; int value = maximum - extent ; int old Value = vis . get Value ( ) ; if ( ( old Value + extent ) > maximum ) { old Value = maximum - extent ; } value = Math . max ( NUM , Math . min ( value , old Value ) ) ; vis . set Range Properties ( value , extent , NUM , maximum , BOOL ) ; } }
void update Visibility Model ( ) { Component c = get Container ( ) ; if ( c instanceof J Text Field ) { J Text Field field = ( J Text Field ) c ; Bounded Range Model vis = field . get Horizontal Visibility ( ) ; int hspan = ( int ) get Preferred Span ( X AXIS ) ; int extent = vis . get Extent ( ) ; int maximum = Math . max ( hspan , extent ) ; extent = ( extent == NUM ) ? maximum : extent ; int value = maximum - extent ; int old Value = vis . get Value ( ) ; if ( ( old Value + extent ) > maximum ) { old Value = maximum - extent ; } value = Math . max ( NUM , Math . min ( value , old Value ) ) ; vis . set Range Properties ( value , extent , NUM , maximum , BOOL ) ; } }
void update Visibility Model ( ) { Component c = get Container ( ) ; if ( c instanceof J Text Field ) { J Text Field field = ( J Text Field ) c ; Bounded Range Model vis = field . get Horizontal Visibility ( ) ; int hspan = ( int ) get Preferred Span ( X AXIS ) ; int extent = vis . get Extent ( ) ; int maximum = Math . max ( hspan , extent ) ; extent = ( extent == NUM ) ? maximum : extent ; int value = maximum - extent ; int old Value = vis . get Value ( ) ; if ( ( old Value + extent ) > maximum ) { old Value = maximum - extent ; } value = Math . max ( NUM , Math . min ( value , old Value ) ) ; vis . set Range Properties ( value , extent , NUM , maximum , BOOL ) ; } }
void update Visibility Model ( ) { Component c = get Container ( ) ; if ( c instanceof J Text Field ) { J Text Field field = ( J Text Field ) c ; Bounded Range Model vis = field . get Horizontal Visibility ( ) ; int hspan = ( int ) get Preferred Span ( X AXIS ) ; int extent = vis . get Extent ( ) ; int maximum = Math . max ( hspan , extent ) ; extent = ( extent == NUM ) ? maximum : extent ; int value = maximum - extent ; int old Value = vis . get Value ( ) ; if ( ( old Value + extent ) > maximum ) { old Value = maximum - extent ; } value = Math . max ( NUM , Math . min ( value , old Value ) ) ; vis . set Range Properties ( value , extent , NUM , maximum , BOOL ) ; } }
void update Visibility Model ( ) { Component c = get Container ( ) ; if ( c instanceof J Text Field ) { J Text Field field = ( J Text Field ) c ; Bounded Range Model vis = field . get Horizontal Visibility ( ) ; int hspan = ( int ) get Preferred Span ( X AXIS ) ; int extent = vis . get Extent ( ) ; int maximum = Math . max ( hspan , extent ) ; extent = ( extent == NUM ) ? maximum : extent ; int value = maximum - extent ; int old Value = vis . get Value ( ) ; if ( ( old Value + extent ) > maximum ) { old Value = maximum - extent ; } value = Math . max ( NUM , Math . min ( value , old Value ) ) ; vis . set Range Properties ( value , extent , NUM , maximum , BOOL ) ; } }
public static String create Description ( final String description , final String [ ] causes , final String [ ] impacts ) { final String Builder string Builder = new String Builder ( ) ; string Builder . append ( description ) ; string Builder . append ( STRING ) ; if ( causes . length != NUM ) { string Builder . append ( STRING ) ; string Builder . append ( STRING + STRING ) ; for ( final String cause : causes ) { string Builder . append ( STRING ) ; string Builder . append ( cause ) ; string Builder . append ( STRING ) ; } } if ( impacts . length != NUM ) { string Builder . append ( STRING ) ; string Builder . append ( STRING + STRING ) ; for ( final String impact : impacts ) { string Builder . append ( STRING ) ; string Builder . append ( impact ) ; string Builder . append ( STRING ) ; } } return string Builder . to String ( ) ; }
public static String create Description ( final String description , final String [ ] causes , final String [ ] impacts ) { final String Builder string Builder = new String Builder ( ) ; string Builder . append ( description ) ; string Builder . append ( STRING ) ; if ( causes . length != NUM ) { string Builder . append ( STRING ) ; string Builder . append ( STRING + STRING ) ; for ( final String cause : causes ) { string Builder . append ( STRING ) ; string Builder . append ( cause ) ; string Builder . append ( STRING ) ; } } if ( impacts . length != NUM ) { string Builder . append ( STRING ) ; string Builder . append ( STRING + STRING ) ; for ( final String impact : impacts ) { string Builder . append ( STRING ) ; string Builder . append ( impact ) ; string Builder . append ( STRING ) ; } } return string Builder . to String ( ) ; }
protected URI Property Matcher ( String property Name , Mode mode , URI expected Pattern , Function < Issue , URI > get Actual Value ) { super ( property Name ) ; this . mode = mode ; this . expected Pattern = Objects . require Non Null ( expected Pattern ) ; this . get Actual Value = Objects . require Non Null ( get Actual Value ) ; }
public final void add Helper Text Color ( @ Color Int final int color ) { if ( ! helper Text Colors . contains ( color ) ) { helper Text Colors . add ( color ) ; verify Password Strength ( ) ; } }
public final void add Helper Text Color ( @ Color Int final int color ) { if ( ! helper Text Colors . contains ( color ) ) { helper Text Colors . add ( color ) ; verify Password Strength ( ) ; } }
public final void add Helper Text Color ( @ Color Int final int color ) { if ( ! helper Text Colors . contains ( color ) ) { helper Text Colors . add ( color ) ; verify Password Strength ( ) ; } }
public final void add Helper Text Color ( @ Color Int final int color ) { if ( ! helper Text Colors . contains ( color ) ) { helper Text Colors . add ( color ) ; verify Password Strength ( ) ; } }
public final void add Helper Text Color ( @ Color Int final int color ) { if ( ! helper Text Colors . contains ( color ) ) { helper Text Colors . add ( color ) ; verify Password Strength ( ) ; } }
public static int hash ( byte [ ] data , int offset , int length , int seed ) { return hash ( Byte Buffer . wrap ( data , offset , length ) , seed ) ; }
public static int hash ( byte [ ] data , int offset , int length , int seed ) { return hash ( Byte Buffer . wrap ( data , offset , length ) , seed ) ; }
public void add Task ( Join Task task ) { synchronized ( Join Manager . this ) { if ( b Terminated ) return ; } synchronized ( task List ) { if ( b Terminated ) { return ; } task List . add ( task ) ; if ( this . proxy Reg Task == null ) { this . proxy Reg Task = new Proxy Reg Task ( this , task Seq N ++ ) ; synchronized ( task Mgr ) { task Mgr . add ( this . proxy Reg Task ) ; } } } }
public void add Task ( Join Task task ) { synchronized ( Join Manager . this ) { if ( b Terminated ) return ; } synchronized ( task List ) { if ( b Terminated ) { return ; } task List . add ( task ) ; if ( this . proxy Reg Task == null ) { this . proxy Reg Task = new Proxy Reg Task ( this , task Seq N ++ ) ; synchronized ( task Mgr ) { task Mgr . add ( this . proxy Reg Task ) ; } } } }
public String escape LDAP Search Filter ( String filter ) { String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < filter . length ( ) ; i ++ ) { char cur Char = filter . char At ( i ) ; switch ( cur Char ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; default : sb . append ( cur Char ) ; } } return sb . to String ( ) ; }
@ POST @ Consumes ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Produces ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Check Permission ( roles = { Role . TENANT ADMIN } , acls = { ACL . OWN } ) @ Path ( STRING ) public Catalog Service Rest Rep create Catalog Service ( Catalog Service Create Param create Param ) { Storage OS User user = get User From Context ( ) ; Catalog Category parent Catalog Category = catalog Category Manager . get Catalog Category By Id ( create Param . get Catalog Category ( ) ) ; verify Authorized In Tenant Org ( uri ( parent Catalog Category . get Tenant ( ) ) , user ) ; validate Param ( create Param , null ) ; Catalog Service catalog Service = create New Object ( create Param , parent Catalog Category ) ; List < Catalog Service Field > catalog Service Fields = create New Object List ( catalog Service , create Param . get Catalog Service Fields ( ) ) ; catalog Service Manager . create Catalog Service ( catalog Service , catalog Service Fields ) ; audit Op Success ( Operation Type Enum . CREATE CATALOG SERVICE , catalog Service . audit Parameters ( ) ) ; catalog Service = catalog Service Manager . get Catalog Service By Id ( catalog Service . get Id ( ) ) ; catalog Service Fields = catalog Service Manager . get Catalog Service Fields ( catalog Service . get Id ( ) ) ; Service Descriptor service Descriptor = get Service Descriptor ( catalog Service ) ; return map ( catalog Service , service Descriptor , catalog Service Fields ) ; }
@ Override public void build Structure ( Bayes Net bayes Net , Instances instances ) throws Exception { m Bayes Net = bayes Net ; super . build Structure ( bayes Net , instances ) ; }
@ Override public void build Structure ( Bayes Net bayes Net , Instances instances ) throws Exception { m Bayes Net = bayes Net ; super . build Structure ( bayes Net , instances ) ; }
@ Override public void build Structure ( Bayes Net bayes Net , Instances instances ) throws Exception { m Bayes Net = bayes Net ; super . build Structure ( bayes Net , instances ) ; }
public boolean copy Image ( Image img , int dx , int dy , int sx , int sy , int width , int height , Color bgcolor , Image Observer observer ) { try { return imagepipe . copy Image ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( Invalid Pipe Exception e ) { try { revalidate All ( ) ; return imagepipe . copy Image ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( Invalid Pipe Exception e2 ) { return BOOL ; } } finally { surface Data . mark Dirty ( ) ; } }
public boolean copy Image ( Image img , int dx , int dy , int sx , int sy , int width , int height , Color bgcolor , Image Observer observer ) { try { return imagepipe . copy Image ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( Invalid Pipe Exception e ) { try { revalidate All ( ) ; return imagepipe . copy Image ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( Invalid Pipe Exception e2 ) { return BOOL ; } } finally { surface Data . mark Dirty ( ) ; } }
public boolean copy Image ( Image img , int dx , int dy , int sx , int sy , int width , int height , Color bgcolor , Image Observer observer ) { try { return imagepipe . copy Image ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( Invalid Pipe Exception e ) { try { revalidate All ( ) ; return imagepipe . copy Image ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( Invalid Pipe Exception e2 ) { return BOOL ; } } finally { surface Data . mark Dirty ( ) ; } }
public boolean copy Image ( Image img , int dx , int dy , int sx , int sy , int width , int height , Color bgcolor , Image Observer observer ) { try { return imagepipe . copy Image ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( Invalid Pipe Exception e ) { try { revalidate All ( ) ; return imagepipe . copy Image ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( Invalid Pipe Exception e2 ) { return BOOL ; } } finally { surface Data . mark Dirty ( ) ; } }
public boolean copy Image ( Image img , int dx , int dy , int sx , int sy , int width , int height , Color bgcolor , Image Observer observer ) { try { return imagepipe . copy Image ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( Invalid Pipe Exception e ) { try { revalidate All ( ) ; return imagepipe . copy Image ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( Invalid Pipe Exception e2 ) { return BOOL ; } } finally { surface Data . mark Dirty ( ) ; } }
public boolean ends With ( String string ) { if ( string == null ) return BOOL ; int strlen = string . length ( ) ; if ( length < strlen ) return BOOL ; char [ ] buffer = buffer ; int offset = offset + length - strlen ; while ( -- strlen >= NUM ) { if ( buffer [ offset + strlen ] != string . char At ( strlen ) ) return BOOL ; } return BOOL ; }
public int compare To ( Resource Usage o ) { double required = o . limit - o . usage ; double available = limit - usage ; return Double . compare ( available , required ) ; }
public Skeleton ( Print Writer out ) { this . out = out ; }
private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; registrar ID = new Service ID ( in ) ; if ( server == null ) { throw new Invalid Object Exception ( STRING ) ; } else if ( lease ID == null ) { throw new Invalid Object Exception ( STRING ) ; } }
public static void write ( float lt , float ln , Image image , int image width , int image height , Link Properties properties , Data Output Stream dos ) throws IO Exception , Interrupted Exception { int [ ] pixels = new int [ image width * image height ] ; Pixel Grabber pixelgrabber = new Pixel Grabber ( image , NUM , NUM , image width , image height , pixels , NUM , image width ) ; pixelgrabber . grab Pixels ( ) ; Link Raster . write ( lt , ln , image width , image height , pixels , properties , dos ) ; }
public boolean is Null Stroke Fill ( boolean is Rectangle ) { Meta Pen pen = state . get Current Pen ( ) ; Meta Brush brush = state . get Current Brush ( ) ; boolean no Pen = pen . get Style ( ) == Meta Pen . PS NULL ; int style = brush . get Style ( ) ; boolean is Brush = style == Meta Brush . BS SOLID || style == Meta Brush . BS HATCHED && state . get Background Mode ( ) == Meta State . OPAQUE ; boolean result = no Pen && ! is Brush ; if ( ! no Pen ) { if ( is Rectangle ) state . set Line Join Rectangle ( cb ) ; else state . set Line Join Polygon ( cb ) ; } return result ; }
void visit Macro Def ( Macro macro ) { macro To Namespace Lookup . put ( macro , current Namespace ) ; current Namespace . put ( macro . get Name ( ) , macro ) ; }
void visit Macro Def ( Macro macro ) { macro To Namespace Lookup . put ( macro , current Namespace ) ; current Namespace . put ( macro . get Name ( ) , macro ) ; }
protected void await Completion Compute Values And Shutdown ( ) { { final long before = System . current Time Millis ( ) ; run Executor And Await Completion ( ) ; duration Flow Function Construction = System . current Time Millis ( ) - before ; } if ( compute Values ) { final long before = System . current Time Millis ( ) ; compute Values ( ) ; duration Flow Function Application = System . current Time Millis ( ) - before ; } if ( logger . is Debug Enabled ( ) ) print Stats ( ) ; executor . shutdown ( ) ; run Executor And Await Completion ( ) ; }
protected void await Completion Compute Values And Shutdown ( ) { { final long before = System . current Time Millis ( ) ; run Executor And Await Completion ( ) ; duration Flow Function Construction = System . current Time Millis ( ) - before ; } if ( compute Values ) { final long before = System . current Time Millis ( ) ; compute Values ( ) ; duration Flow Function Application = System . current Time Millis ( ) - before ; } if ( logger . is Debug Enabled ( ) ) print Stats ( ) ; executor . shutdown ( ) ; run Executor And Await Completion ( ) ; }
private int calculate Max Character Width Based On Pixel Width ( ) { String test Width String = STRING ; for ( int i = NUM ; i < NUM ; i ++ ) { test Width String = test Width String + STRING ; } Buffered Image temp = new Buffered Image ( NUM , NUM , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D temp G 2 d = temp . create Graphics ( ) ; ; Font Metrics metrics = temp G 2 d . get Font Metrics ( this . label Font ) ; int str Width = metrics . string Width ( test Width String ) ; while ( str Width > this . max Pixel Width ) { test Width String = test Width String . substring ( NUM , test Width String . length ( ) - NUM ) ; str Width = metrics . string Width ( test Width String ) ; } return test Width String . length ( ) ; }
private int calculate Max Character Width Based On Pixel Width ( ) { String test Width String = STRING ; for ( int i = NUM ; i < NUM ; i ++ ) { test Width String = test Width String + STRING ; } Buffered Image temp = new Buffered Image ( NUM , NUM , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D temp G 2 d = temp . create Graphics ( ) ; ; Font Metrics metrics = temp G 2 d . get Font Metrics ( this . label Font ) ; int str Width = metrics . string Width ( test Width String ) ; while ( str Width > this . max Pixel Width ) { test Width String = test Width String . substring ( NUM , test Width String . length ( ) - NUM ) ; str Width = metrics . string Width ( test Width String ) ; } return test Width String . length ( ) ; }
private int calculate Max Character Width Based On Pixel Width ( ) { String test Width String = STRING ; for ( int i = NUM ; i < NUM ; i ++ ) { test Width String = test Width String + STRING ; } Buffered Image temp = new Buffered Image ( NUM , NUM , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D temp G 2 d = temp . create Graphics ( ) ; ; Font Metrics metrics = temp G 2 d . get Font Metrics ( this . label Font ) ; int str Width = metrics . string Width ( test Width String ) ; while ( str Width > this . max Pixel Width ) { test Width String = test Width String . substring ( NUM , test Width String . length ( ) - NUM ) ; str Width = metrics . string Width ( test Width String ) ; } return test Width String . length ( ) ; }
private static int read Length ( @ Non Null Socket Channel socket , @ Non Null byte [ ] buffer ) throws IO Exception { String msg = read ( socket , buffer ) ; if ( msg != null ) { try { return Integer . parse Int ( msg , NUM ) ; } catch ( Number Format Exception nfe ) { } } throw new IO Exception ( STRING ) ; }
public Dock Node ( Node contents , String title ) { this ( contents , title , null ) ; }
private Matching Part create Emo Permission Part ( String part , Part Type part Type ) { part = unescape Separators ( part ) ; switch ( part . char At ( NUM ) ) { case STRING : if ( is Table Resource ( part Type ) && part . starts With ( STRING ) && part . ends With ( STRING ) ) { String rison = part . substring ( NUM , part . length ( ) - NUM ) ; return Rison Helper . from O Rison ( rison , Create Table Part . class ) ; } break ; case STRING : if ( part . starts With ( STRING ) && part . ends With ( STRING ) ) { String condition = part . substring ( NUM , part . length ( ) - NUM ) ; switch ( part Type ) { case SOR TABLE : return new Sor Table Condition Part ( Conditions . from String ( condition ) , data Store ) ; case BLOB TABLE : return new Blob Table Condition Part ( Conditions . from String ( condition ) , blob Store ) ; default : return new Condition Part ( Conditions . from String ( condition ) ) ; } } break ; case STRING : if ( part . length ( ) == NUM ) { return get Any Part ( ) ; } break ; } Condition condition = Conditions . like ( part ) ; if ( condition instanceof Equal Condition ) { return new Emo Constant Part ( part ) ; } return new Condition Part ( condition ) ; }
public static void add Gui Experiment ( final I Experiment Plan experiment ) { }
public Producer Worker ( String topic , String message ) { this . topic = topic ; this . message = message ; }
default Optional < String > tooltip ( ) { return Optional . empty ( ) ; }
public static void add Permission Recursive ( Path path , Posix File Permission permission ) throws IO Exception { change Permissions Recursive ( path , Permission Change . ADD , Collections . singleton ( permission ) ) ; }
public static Document jsoup 2 DOM ( org . jsoup . nodes . Document jsoup Document ) { Document document = null ; try { Document Builder Factory doc Builder Factory = Document Builder Factory . new Instance ( ) ; Document Builder doc Builder = doc Builder Factory . new Document Builder ( ) ; document = doc Builder . new Document ( ) ; Map < String , String > ns Map = new Hash Map < String , String > ( ) ; create DOM ( jsoup Document , document , document , ns Map ) ; } catch ( Parser Configuration Exception pce ) { throw new Runtime Exception ( pce ) ; } return document ; }
public static Document jsoup 2 DOM ( org . jsoup . nodes . Document jsoup Document ) { Document document = null ; try { Document Builder Factory doc Builder Factory = Document Builder Factory . new Instance ( ) ; Document Builder doc Builder = doc Builder Factory . new Document Builder ( ) ; document = doc Builder . new Document ( ) ; Map < String , String > ns Map = new Hash Map < String , String > ( ) ; create DOM ( jsoup Document , document , document , ns Map ) ; } catch ( Parser Configuration Exception pce ) { throw new Runtime Exception ( pce ) ; } return document ; }
@ Override public boolean is Armed ( ) { boolean b = should Act Like Button ( ) || ( pressed When Popup Visible && combo Box . is Popup Visible ( ) ) ; return b ? is Pressed ( ) : super . is Armed ( ) ; }
public static Date date From Header String ( String datstr ) { Simple Date Format fmt = new Simple Date Format ( HTTP FORMAT , Locale . US ) ; Parse Position zero = new Parse Position ( NUM ) ; fmt . set Time Zone ( GMT ZONE ) ; return ( fmt . parse ( datstr , zero ) ) ; }
public static Date date From Header String ( String datstr ) { Simple Date Format fmt = new Simple Date Format ( HTTP FORMAT , Locale . US ) ; Parse Position zero = new Parse Position ( NUM ) ; fmt . set Time Zone ( GMT ZONE ) ; return ( fmt . parse ( datstr , zero ) ) ; }
public static < T extends Char Sequence > T each Match ( T self , Pattern pattern , @ Closure Params ( value = From String . class , options = { STRING , STRING } ) Closure closure ) { each Match ( self . to String ( ) , pattern , closure ) ; return self ; }
public static < T extends Char Sequence > T each Match ( T self , Pattern pattern , @ Closure Params ( value = From String . class , options = { STRING , STRING } ) Closure closure ) { each Match ( self . to String ( ) , pattern , closure ) ; return self ; }
public static < T extends Char Sequence > T each Match ( T self , Pattern pattern , @ Closure Params ( value = From String . class , options = { STRING , STRING } ) Closure closure ) { each Match ( self . to String ( ) , pattern , closure ) ; return self ; }
public static < T extends Char Sequence > T each Match ( T self , Pattern pattern , @ Closure Params ( value = From String . class , options = { STRING , STRING } ) Closure closure ) { each Match ( self . to String ( ) , pattern , closure ) ; return self ; }
private static Point 2 D detect Line ( Point 2 D p1 , Point 2 D p2 , Point 2 D p , Line 2 D line , General Path path ) { if ( line . pt Line Dist Sq ( p ) == NUM ) { p2 . set Location ( p ) ; } else { p1 . set Location ( p2 ) ; p2 . set Location ( p ) ; line . set Line ( p1 , p2 ) ; path . line To ( ( float ) p1 . get X ( ) , ( float ) p1 . get Y ( ) ) ; } return p2 ; }
private static Point 2 D detect Line ( Point 2 D p1 , Point 2 D p2 , Point 2 D p , Line 2 D line , General Path path ) { if ( line . pt Line Dist Sq ( p ) == NUM ) { p2 . set Location ( p ) ; } else { p1 . set Location ( p2 ) ; p2 . set Location ( p ) ; line . set Line ( p1 , p2 ) ; path . line To ( ( float ) p1 . get X ( ) , ( float ) p1 . get Y ( ) ) ; } return p2 ; }
private static Point 2 D detect Line ( Point 2 D p1 , Point 2 D p2 , Point 2 D p , Line 2 D line , General Path path ) { if ( line . pt Line Dist Sq ( p ) == NUM ) { p2 . set Location ( p ) ; } else { p1 . set Location ( p2 ) ; p2 . set Location ( p ) ; line . set Line ( p1 , p2 ) ; path . line To ( ( float ) p1 . get X ( ) , ( float ) p1 . get Y ( ) ) ; } return p2 ; }
public boolean has Listeners ( ) { return listeners != null && listeners . size ( ) > NUM ; }
public boolean has Listeners ( ) { return listeners != null && listeners . size ( ) > NUM ; }
private void flash Selected Property ( Theme Model model , String key ) { }
private void process Worker Exit ( Worker w , boolean completed Abruptly ) { if ( completed Abruptly ) decrement Worker Count ( ) ; final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { completed Task Count += w . completed Tasks ; workers . remove ( w ) ; } finally { main Lock . unlock ( ) ; } try Terminate 2 ( ) ; if ( ! completed Abruptly ) { int min = allow Core Thread Time Out ? NUM : core Pool Size ; if ( min == NUM && ! work Queue . is Empty ( ) ) min = NUM ; int c = ctl . get ( ) ; if ( worker Count Of ( c ) >= min || run State Of ( c ) >= STOP ) return ; } add Worker ( null , BOOL ) ; }
private void process Worker Exit ( Worker w , boolean completed Abruptly ) { if ( completed Abruptly ) decrement Worker Count ( ) ; final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { completed Task Count += w . completed Tasks ; workers . remove ( w ) ; } finally { main Lock . unlock ( ) ; } try Terminate 2 ( ) ; if ( ! completed Abruptly ) { int min = allow Core Thread Time Out ? NUM : core Pool Size ; if ( min == NUM && ! work Queue . is Empty ( ) ) min = NUM ; int c = ctl . get ( ) ; if ( worker Count Of ( c ) >= min || run State Of ( c ) >= STOP ) return ; } add Worker ( null , BOOL ) ; }
private void process Worker Exit ( Worker w , boolean completed Abruptly ) { if ( completed Abruptly ) decrement Worker Count ( ) ; final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { completed Task Count += w . completed Tasks ; workers . remove ( w ) ; } finally { main Lock . unlock ( ) ; } try Terminate 2 ( ) ; if ( ! completed Abruptly ) { int min = allow Core Thread Time Out ? NUM : core Pool Size ; if ( min == NUM && ! work Queue . is Empty ( ) ) min = NUM ; int c = ctl . get ( ) ; if ( worker Count Of ( c ) >= min || run State Of ( c ) >= STOP ) return ; } add Worker ( null , BOOL ) ; }
private void process Worker Exit ( Worker w , boolean completed Abruptly ) { if ( completed Abruptly ) decrement Worker Count ( ) ; final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { completed Task Count += w . completed Tasks ; workers . remove ( w ) ; } finally { main Lock . unlock ( ) ; } try Terminate 2 ( ) ; if ( ! completed Abruptly ) { int min = allow Core Thread Time Out ? NUM : core Pool Size ; if ( min == NUM && ! work Queue . is Empty ( ) ) min = NUM ; int c = ctl . get ( ) ; if ( worker Count Of ( c ) >= min || run State Of ( c ) >= STOP ) return ; } add Worker ( null , BOOL ) ; }
private void process Worker Exit ( Worker w , boolean completed Abruptly ) { if ( completed Abruptly ) decrement Worker Count ( ) ; final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { completed Task Count += w . completed Tasks ; workers . remove ( w ) ; } finally { main Lock . unlock ( ) ; } try Terminate 2 ( ) ; if ( ! completed Abruptly ) { int min = allow Core Thread Time Out ? NUM : core Pool Size ; if ( min == NUM && ! work Queue . is Empty ( ) ) min = NUM ; int c = ctl . get ( ) ; if ( worker Count Of ( c ) >= min || run State Of ( c ) >= STOP ) return ; } add Worker ( null , BOOL ) ; }
private void process Worker Exit ( Worker w , boolean completed Abruptly ) { if ( completed Abruptly ) decrement Worker Count ( ) ; final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { completed Task Count += w . completed Tasks ; workers . remove ( w ) ; } finally { main Lock . unlock ( ) ; } try Terminate 2 ( ) ; if ( ! completed Abruptly ) { int min = allow Core Thread Time Out ? NUM : core Pool Size ; if ( min == NUM && ! work Queue . is Empty ( ) ) min = NUM ; int c = ctl . get ( ) ; if ( worker Count Of ( c ) >= min || run State Of ( c ) >= STOP ) return ; } add Worker ( null , BOOL ) ; }
private void process Worker Exit ( Worker w , boolean completed Abruptly ) { if ( completed Abruptly ) decrement Worker Count ( ) ; final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { completed Task Count += w . completed Tasks ; workers . remove ( w ) ; } finally { main Lock . unlock ( ) ; } try Terminate 2 ( ) ; if ( ! completed Abruptly ) { int min = allow Core Thread Time Out ? NUM : core Pool Size ; if ( min == NUM && ! work Queue . is Empty ( ) ) min = NUM ; int c = ctl . get ( ) ; if ( worker Count Of ( c ) >= min || run State Of ( c ) >= STOP ) return ; } add Worker ( null , BOOL ) ; }
private static Entry [ ] delete ( Entry [ ] attrs , int i ) { int len = attrs . length - NUM ; Entry [ ] nattrs = new Entry [ len ] ; System . arraycopy ( attrs , NUM , nattrs , NUM , i ) ; System . arraycopy ( attrs , i + NUM , nattrs , i , len - i ) ; return nattrs ; }
public Transit create New Transit ( String user Name ) { boolean found = BOOL ; String test Name = STRING ; Transit z ; while ( ! found ) { int next Auto Transit Ref = last Auto Transit Ref + NUM ; test Name = STRING + next Auto Transit Ref ; z = get By System Name ( test Name ) ; if ( z == null ) { found = BOOL ; } last Auto Transit Ref = next Auto Transit Ref ; } return create New Transit ( test Name , user Name ) ; }
public Transit create New Transit ( String user Name ) { boolean found = BOOL ; String test Name = STRING ; Transit z ; while ( ! found ) { int next Auto Transit Ref = last Auto Transit Ref + NUM ; test Name = STRING + next Auto Transit Ref ; z = get By System Name ( test Name ) ; if ( z == null ) { found = BOOL ; } last Auto Transit Ref = next Auto Transit Ref ; } return create New Transit ( test Name , user Name ) ; }
public Transit create New Transit ( String user Name ) { boolean found = BOOL ; String test Name = STRING ; Transit z ; while ( ! found ) { int next Auto Transit Ref = last Auto Transit Ref + NUM ; test Name = STRING + next Auto Transit Ref ; z = get By System Name ( test Name ) ; if ( z == null ) { found = BOOL ; } last Auto Transit Ref = next Auto Transit Ref ; } return create New Transit ( test Name , user Name ) ; }
public Transit create New Transit ( String user Name ) { boolean found = BOOL ; String test Name = STRING ; Transit z ; while ( ! found ) { int next Auto Transit Ref = last Auto Transit Ref + NUM ; test Name = STRING + next Auto Transit Ref ; z = get By System Name ( test Name ) ; if ( z == null ) { found = BOOL ; } last Auto Transit Ref = next Auto Transit Ref ; } return create New Transit ( test Name , user Name ) ; }
public Transit create New Transit ( String user Name ) { boolean found = BOOL ; String test Name = STRING ; Transit z ; while ( ! found ) { int next Auto Transit Ref = last Auto Transit Ref + NUM ; test Name = STRING + next Auto Transit Ref ; z = get By System Name ( test Name ) ; if ( z == null ) { found = BOOL ; } last Auto Transit Ref = next Auto Transit Ref ; } return create New Transit ( test Name , user Name ) ; }
public Transit create New Transit ( String user Name ) { boolean found = BOOL ; String test Name = STRING ; Transit z ; while ( ! found ) { int next Auto Transit Ref = last Auto Transit Ref + NUM ; test Name = STRING + next Auto Transit Ref ; z = get By System Name ( test Name ) ; if ( z == null ) { found = BOOL ; } last Auto Transit Ref = next Auto Transit Ref ; } return create New Transit ( test Name , user Name ) ; }
public Transit create New Transit ( String user Name ) { boolean found = BOOL ; String test Name = STRING ; Transit z ; while ( ! found ) { int next Auto Transit Ref = last Auto Transit Ref + NUM ; test Name = STRING + next Auto Transit Ref ; z = get By System Name ( test Name ) ; if ( z == null ) { found = BOOL ; } last Auto Transit Ref = next Auto Transit Ref ; } return create New Transit ( test Name , user Name ) ; }
public Transit create New Transit ( String user Name ) { boolean found = BOOL ; String test Name = STRING ; Transit z ; while ( ! found ) { int next Auto Transit Ref = last Auto Transit Ref + NUM ; test Name = STRING + next Auto Transit Ref ; z = get By System Name ( test Name ) ; if ( z == null ) { found = BOOL ; } last Auto Transit Ref = next Auto Transit Ref ; } return create New Transit ( test Name , user Name ) ; }
public Transit create New Transit ( String user Name ) { boolean found = BOOL ; String test Name = STRING ; Transit z ; while ( ! found ) { int next Auto Transit Ref = last Auto Transit Ref + NUM ; test Name = STRING + next Auto Transit Ref ; z = get By System Name ( test Name ) ; if ( z == null ) { found = BOOL ; } last Auto Transit Ref = next Auto Transit Ref ; } return create New Transit ( test Name , user Name ) ; }
public Transit create New Transit ( String user Name ) { boolean found = BOOL ; String test Name = STRING ; Transit z ; while ( ! found ) { int next Auto Transit Ref = last Auto Transit Ref + NUM ; test Name = STRING + next Auto Transit Ref ; z = get By System Name ( test Name ) ; if ( z == null ) { found = BOOL ; } last Auto Transit Ref = next Auto Transit Ref ; } return create New Transit ( test Name , user Name ) ; }
private void update Attrs ( Svc Reg reg , Entry Rep entry , Object [ ] values ) { Entry Class eclass = entry . eclass ; for ( int fldidx = values . length ; -- fldidx >= NUM ; ) { Object oval = entry . fields [ fldidx ] ; Object nval = values [ fldidx ] ; if ( nval != null && ! nval . equals ( oval ) ) { eclass = get Defining Class ( eclass , fldidx ) ; Hash Map map = add Attr ( reg , eclass , fldidx , nval ) ; entry . fields [ fldidx ] = nval ; if ( has Attr ( reg , eclass , fldidx , oval ) ) continue ; Array List regs = ( Array List ) map . get ( oval ) ; regs . remove ( regs . index Of ( reg ) ) ; if ( regs . is Empty ( ) ) map . remove ( oval ) ; } } }
public List < Json Value > values ( ) { return Collections . unmodifiable List ( values ) ; }
public List < Json Value > values ( ) { return Collections . unmodifiable List ( values ) ; }
public List < Json Value > values ( ) { return Collections . unmodifiable List ( values ) ; }
public List < Json Value > values ( ) { return Collections . unmodifiable List ( values ) ; }
public static int verify Order ( String input , String [ ] sub Strings ) { int prev = - NUM ; for ( int i = NUM ; i < sub Strings . length ; i ++ ) { int current = input . index Of ( sub Strings [ i ] ) ; if ( current < prev ) { return i ; } else { prev = current ; } } return - NUM ; }
public static int verify Order ( String input , String [ ] sub Strings ) { int prev = - NUM ; for ( int i = NUM ; i < sub Strings . length ; i ++ ) { int current = input . index Of ( sub Strings [ i ] ) ; if ( current < prev ) { return i ; } else { prev = current ; } } return - NUM ; }
protected static int [ ] remove ( int [ ] old , int old Size , int pos ) { int [ ] result ; if ( old . length - old Size < COPY THRESHOLD ) { result = old ; } else { result = new int [ old Size - NUM ] ; System . arraycopy ( old , NUM , result , NUM , Math . min ( old Size - NUM , pos ) ) ; } if ( pos < old Size ) { System . arraycopy ( old , pos + NUM , result , pos , old Size - pos - NUM ) ; } return result ; }
protected static int [ ] remove ( int [ ] old , int old Size , int pos ) { int [ ] result ; if ( old . length - old Size < COPY THRESHOLD ) { result = old ; } else { result = new int [ old Size - NUM ] ; System . arraycopy ( old , NUM , result , NUM , Math . min ( old Size - NUM , pos ) ) ; } if ( pos < old Size ) { System . arraycopy ( old , pos + NUM , result , pos , old Size - pos - NUM ) ; } return result ; }
public Json Node put ( String field Name , Json Node value ) { if ( value == null ) { value = null Node ( ) ; } return put ( field Name , value ) ; }
public Json Node put ( String field Name , Json Node value ) { if ( value == null ) { value = null Node ( ) ; } return put ( field Name , value ) ; }
public void reset ( ) { Iterator iter = m vis . visible Items ( m node Group ) ; while ( iter . has Next ( ) ) { Visual Item item = ( Visual Item ) iter . next ( ) ; Force Item fitem = ( Force Item ) item . get ( FORCEITEM ) ; if ( fitem != null ) { fitem . location [ NUM ] = ( float ) item . get End X ( ) ; fitem . location [ NUM ] = ( float ) item . get End Y ( ) ; fitem . force [ NUM ] = fitem . force [ NUM ] = NUM ; fitem . velocity [ NUM ] = fitem . velocity [ NUM ] = NUM ; } } m lasttime = - NUM ; }
public void delete Persistent Store ( ) { try { close ( ) ; } catch ( IO Exception e ) { } try { delete Log File ( version ) ; } catch ( Log Exception e ) { } try { delete Snapshot ( version ) ; } catch ( Log Exception e ) { } try { delete File ( f Name ( version File ) ) ; } catch ( Log Exception e ) { } try { dir . delete ( ) ; } catch ( Security Exception e ) { } }
public void delete Persistent Store ( ) { try { close ( ) ; } catch ( IO Exception e ) { } try { delete Log File ( version ) ; } catch ( Log Exception e ) { } try { delete Snapshot ( version ) ; } catch ( Log Exception e ) { } try { delete File ( f Name ( version File ) ) ; } catch ( Log Exception e ) { } try { dir . delete ( ) ; } catch ( Security Exception e ) { } }
public void delete Persistent Store ( ) { try { close ( ) ; } catch ( IO Exception e ) { } try { delete Log File ( version ) ; } catch ( Log Exception e ) { } try { delete Snapshot ( version ) ; } catch ( Log Exception e ) { } try { delete File ( f Name ( version File ) ) ; } catch ( Log Exception e ) { } try { dir . delete ( ) ; } catch ( Security Exception e ) { } }
protected void add Filter ( Dimensional Object filter ) { filters . add ( filter ) ; }
public static String to String ( double M [ ] [ ] , int adp ) { String Builder sb = new String Builder ( ) ; for ( int j = NUM ; j < M . length ; j ++ ) { for ( int k = NUM ; k < M [ j ] . length ; k ++ ) { double d = M [ j ] [ k ] ; String num = String . format ( STRING , d ) ; if ( adp == NUM ) num = String . format ( STRING , d ) ; sb . append ( num ) ; } sb . append ( STRING ) ; } return sb . to String ( ) ; }
private int read Argument Index ( final String pattern , final Parse Position pos ) { final int start = pos . get Index ( ) ; seek Non Ws ( pattern , pos ) ; final String Builder result = new String Builder ( ) ; boolean error = BOOL ; for ( ; ! error && pos . get Index ( ) < pattern . length ( ) ; next ( pos ) ) { char c = pattern . char At ( pos . get Index ( ) ) ; if ( Character . is Whitespace ( c ) ) { seek Non Ws ( pattern , pos ) ; c = pattern . char At ( pos . get Index ( ) ) ; if ( c != START FMT && c != END FE ) { error = BOOL ; continue ; } } if ( ( c == START FMT || c == END FE ) && result . length ( ) > NUM ) { try { return Integer . parse Int ( result . to String ( ) ) ; } catch ( final Number Format Exception e ) { } } error = ! Character . is Digit ( c ) ; result . append ( c ) ; } if ( error ) { throw new Illegal Argument Exception ( STRING + start + STRING + pattern . substring ( start , pos . get Index ( ) ) ) ; } throw new Illegal Argument Exception ( STRING + start ) ; }
public void add Tint Resource Id ( int res Id ) { if ( m Custom Tint Drawable Ids == null ) m Custom Tint Drawable Ids = new Array List < Integer > ( ) ; m Custom Tint Drawable Ids . add ( res Id ) ; }
public void add Tint Resource Id ( int res Id ) { if ( m Custom Tint Drawable Ids == null ) m Custom Tint Drawable Ids = new Array List < Integer > ( ) ; m Custom Tint Drawable Ids . add ( res Id ) ; }
public void add All Individuals ( Collection < Example Set Based Individual > new Individuals ) { individuals . add All ( new Individuals ) ; }
public static File find Config In Working Directory ( ) { for ( final String suffix : SUFFIXES ) { final File config File = new File ( System . get Property ( STRING ) , PREFIX + suffix ) ; if ( config File . is File ( ) ) { return config File ; } } return null ; }
private Foreign Key find Corresponding Foreign Key ( Table table , Foreign Key fk ) { for ( int fk Idx = NUM ; fk Idx < table . get Foreign Key Count ( ) ; fk Idx ++ ) { Foreign Key cur Fk = table . get Foreign Key ( fk Idx ) ; if ( ( case Sensitive && fk . equals ( cur Fk ) ) || ( ! case Sensitive && fk . equals Ignore Case ( cur Fk ) ) ) { return cur Fk ; } } return null ; }
private Foreign Key find Corresponding Foreign Key ( Table table , Foreign Key fk ) { for ( int fk Idx = NUM ; fk Idx < table . get Foreign Key Count ( ) ; fk Idx ++ ) { Foreign Key cur Fk = table . get Foreign Key ( fk Idx ) ; if ( ( case Sensitive && fk . equals ( cur Fk ) ) || ( ! case Sensitive && fk . equals Ignore Case ( cur Fk ) ) ) { return cur Fk ; } } return null ; }
private Foreign Key find Corresponding Foreign Key ( Table table , Foreign Key fk ) { for ( int fk Idx = NUM ; fk Idx < table . get Foreign Key Count ( ) ; fk Idx ++ ) { Foreign Key cur Fk = table . get Foreign Key ( fk Idx ) ; if ( ( case Sensitive && fk . equals ( cur Fk ) ) || ( ! case Sensitive && fk . equals Ignore Case ( cur Fk ) ) ) { return cur Fk ; } } return null ; }
private Foreign Key find Corresponding Foreign Key ( Table table , Foreign Key fk ) { for ( int fk Idx = NUM ; fk Idx < table . get Foreign Key Count ( ) ; fk Idx ++ ) { Foreign Key cur Fk = table . get Foreign Key ( fk Idx ) ; if ( ( case Sensitive && fk . equals ( cur Fk ) ) || ( ! case Sensitive && fk . equals Ignore Case ( cur Fk ) ) ) { return cur Fk ; } } return null ; }
private Foreign Key find Corresponding Foreign Key ( Table table , Foreign Key fk ) { for ( int fk Idx = NUM ; fk Idx < table . get Foreign Key Count ( ) ; fk Idx ++ ) { Foreign Key cur Fk = table . get Foreign Key ( fk Idx ) ; if ( ( case Sensitive && fk . equals ( cur Fk ) ) || ( ! case Sensitive && fk . equals Ignore Case ( cur Fk ) ) ) { return cur Fk ; } } return null ; }
public void add String To Table ( byte [ ] old String , byte new String ) { int length = old String . length ; byte [ ] string = new byte [ length + NUM ] ; System . arraycopy ( old String , NUM , string , NUM , length ) ; string [ length ] = new String ; string Table [ table Index ++ ] = string ; if ( table Index == NUM ) { bits To Get = NUM ; } else if ( table Index == NUM ) { bits To Get = NUM ; } else if ( table Index == NUM ) { bits To Get = NUM ; } }
@ Known Failure ( STRING ) public void test Select Right Outer Join ( ) throws SQL Exception { String sql = STRING + Database Creator . CUSTOMERS TABLE + STRING + Database Creator . SALESPEOPLE TABLE + STRING ; Result Set result = statement . execute Query ( sql ) ; Hash Map < Integer , Integer > value = new Hash Map < Integer , Integer > ( ) ; value . put ( NUM , NUM ) ; value . put ( NUM , NUM ) ; value . put ( NUM , NUM ) ; value . put ( NUM , NUM ) ; value . put ( NUM , NUM ) ; value . put ( NUM , null ) ; while ( result . next ( ) ) { int key = result . get Int ( STRING ) ; Object val = result . get Object ( STRING ) ; assert True ( STRING , value . contains Key ( key ) ) ; assert Equals ( STRING , value . get ( key ) , ( Integer ) val ) ; value . remove ( key ) ; } assert True ( STRING , value . is Empty ( ) ) ; result . close ( ) ; }
@ Known Failure ( STRING ) public void test Select Right Outer Join ( ) throws SQL Exception { String sql = STRING + Database Creator . CUSTOMERS TABLE + STRING + Database Creator . SALESPEOPLE TABLE + STRING ; Result Set result = statement . execute Query ( sql ) ; Hash Map < Integer , Integer > value = new Hash Map < Integer , Integer > ( ) ; value . put ( NUM , NUM ) ; value . put ( NUM , NUM ) ; value . put ( NUM , NUM ) ; value . put ( NUM , NUM ) ; value . put ( NUM , NUM ) ; value . put ( NUM , null ) ; while ( result . next ( ) ) { int key = result . get Int ( STRING ) ; Object val = result . get Object ( STRING ) ; assert True ( STRING , value . contains Key ( key ) ) ; assert Equals ( STRING , value . get ( key ) , ( Integer ) val ) ; value . remove ( key ) ; } assert True ( STRING , value . is Empty ( ) ) ; result . close ( ) ; }
public static long now In Nanos ( ) { return System . nano Time ( ) ; }
public void test Correct Build ( ) { Iterator < String > iter = m Trie . iterator ( ) ; Hash Set < String > set = new Hash Set < String > ( ) ; while ( iter . has Next ( ) ) set . add ( iter . next ( ) ) ; assert Equals ( STRING , m Data . length , m Trie . size ( ) ) ; assert Equals ( STRING , m Data . length , set . size ( ) ) ; for ( int i = NUM ; i < m Data . length ; i ++ ) { if ( ! set . contains ( m Data [ i ] ) ) fail ( STRING + m Data [ i ] + STRING ) ; } }
public void test Correct Build ( ) { Iterator < String > iter = m Trie . iterator ( ) ; Hash Set < String > set = new Hash Set < String > ( ) ; while ( iter . has Next ( ) ) set . add ( iter . next ( ) ) ; assert Equals ( STRING , m Data . length , m Trie . size ( ) ) ; assert Equals ( STRING , m Data . length , set . size ( ) ) ; for ( int i = NUM ; i < m Data . length ; i ++ ) { if ( ! set . contains ( m Data [ i ] ) ) fail ( STRING + m Data [ i ] + STRING ) ; } }
public Activity Resolve Info ( Resolve Info resolve Info ) { this . resolve Info = resolve Info ; }
@ Suppress Warnings ( STRING ) public static void translate Point ( Point F point , float offset , float angle ) { float radiant = ( float ) Math . to Radians ( angle ) ; point . x += ( float ) ( Math . cos ( radiant ) * offset ) ; point . y += ( float ) ( Math . sin ( radiant ) * offset ) ; }
@ Suppress Warnings ( STRING ) public static void translate Point ( Point F point , float offset , float angle ) { float radiant = ( float ) Math . to Radians ( angle ) ; point . x += ( float ) ( Math . cos ( radiant ) * offset ) ; point . y += ( float ) ( Math . sin ( radiant ) * offset ) ; }
public I Point next ( ) { if ( stack . empty ( ) ) { throw new java . util . No Such Element Exception ( STRING ) ; } Moment m = stack . peek ( ) ; advance ( ) ; return m . node . point ; }
public I Point next ( ) { if ( stack . empty ( ) ) { throw new java . util . No Such Element Exception ( STRING ) ; } Moment m = stack . peek ( ) ; advance ( ) ; return m . node . point ; }
public static void bind Preference Summary To Value ( Preference preference ) { set And Call Preference Change Listener ( preference , s Bind Preference Summary To Value Listener ) ; }
public static void bind Preference Summary To Value ( Preference preference ) { set And Call Preference Change Listener ( preference , s Bind Preference Summary To Value Listener ) ; }
public static void bind Preference Summary To Value ( Preference preference ) { set And Call Preference Change Listener ( preference , s Bind Preference Summary To Value Listener ) ; }
public static void bind Preference Summary To Value ( Preference preference ) { set And Call Preference Change Listener ( preference , s Bind Preference Summary To Value Listener ) ; }
private double second Partial Derivative ( Fitting Function f , int i , int j , double [ ] p , double delt ) { double [ ] arg = new double [ p . length ] ; System . arraycopy ( p , NUM , arg , NUM , p . length ) ; double center = f . evaluate ( arg ) ; arg [ i ] += delt ; arg [ j ] += delt ; double ff 1 = f . evaluate ( arg ) ; arg [ j ] -= NUM * delt ; double ff 2 = f . evaluate ( arg ) ; arg [ i ] -= NUM * delt ; arg [ j ] += NUM * delt ; double ff 3 = f . evaluate ( arg ) ; arg [ j ] -= NUM * delt ; double ff 4 = f . evaluate ( arg ) ; if ( Double . is Na N ( ff 1 ) ) { ff 1 = center ; } if ( Double . is Na N ( ff 2 ) ) { ff 2 = center ; } if ( Double . is Na N ( ff 3 ) ) { ff 3 = center ; } if ( Double . is Na N ( ff 4 ) ) { ff 4 = center ; } double fs Sum = ff 1 - ff 2 - ff 3 + ff 4 ; return fs Sum / ( NUM * delt * delt ) ; }
private double second Partial Derivative ( Fitting Function f , int i , int j , double [ ] p , double delt ) { double [ ] arg = new double [ p . length ] ; System . arraycopy ( p , NUM , arg , NUM , p . length ) ; double center = f . evaluate ( arg ) ; arg [ i ] += delt ; arg [ j ] += delt ; double ff 1 = f . evaluate ( arg ) ; arg [ j ] -= NUM * delt ; double ff 2 = f . evaluate ( arg ) ; arg [ i ] -= NUM * delt ; arg [ j ] += NUM * delt ; double ff 3 = f . evaluate ( arg ) ; arg [ j ] -= NUM * delt ; double ff 4 = f . evaluate ( arg ) ; if ( Double . is Na N ( ff 1 ) ) { ff 1 = center ; } if ( Double . is Na N ( ff 2 ) ) { ff 2 = center ; } if ( Double . is Na N ( ff 3 ) ) { ff 3 = center ; } if ( Double . is Na N ( ff 4 ) ) { ff 4 = center ; } double fs Sum = ff 1 - ff 2 - ff 3 + ff 4 ; return fs Sum / ( NUM * delt * delt ) ; }
static String internal To Binary Class Name ( String class Name ) { if ( class Name == null ) { return null ; } else { return class Name . replace ( STRING , STRING ) ; } }
static String internal To Binary Class Name ( String class Name ) { if ( class Name == null ) { return null ; } else { return class Name . replace ( STRING , STRING ) ; } }
static String internal To Binary Class Name ( String class Name ) { if ( class Name == null ) { return null ; } else { return class Name . replace ( STRING , STRING ) ; } }
static String internal To Binary Class Name ( String class Name ) { if ( class Name == null ) { return null ; } else { return class Name . replace ( STRING , STRING ) ; } }
public static void copy File ( File src File , File dest File ) throws IO Exception { if ( dest File . exists ( ) && dest File . is Directory ( ) ) { throw new IO Exception ( STRING + dest File + STRING ) ; } File Input Stream input = new File Input Stream ( src File ) ; try { File Output Stream output = new File Output Stream ( dest File ) ; try { copy ( input , output ) ; } finally { close ( output ) ; } } finally { close ( input ) ; } if ( src File . length ( ) != dest File . length ( ) ) { throw new IO Exception ( STRING + src File + STRING + dest File + STRING ) ; } dest File . set Last Modified ( src File . last Modified ( ) ) ; }
public static void copy File ( File src File , File dest File ) throws IO Exception { if ( dest File . exists ( ) && dest File . is Directory ( ) ) { throw new IO Exception ( STRING + dest File + STRING ) ; } File Input Stream input = new File Input Stream ( src File ) ; try { File Output Stream output = new File Output Stream ( dest File ) ; try { copy ( input , output ) ; } finally { close ( output ) ; } } finally { close ( input ) ; } if ( src File . length ( ) != dest File . length ( ) ) { throw new IO Exception ( STRING + src File + STRING + dest File + STRING ) ; } dest File . set Last Modified ( src File . last Modified ( ) ) ; }
public static long bin Coeff ( int n , int k ) { return Math . round ( Math . exp ( log Bin Coeff ( n , k ) ) ) ; }
public static long bin Coeff ( int n , int k ) { return Math . round ( Math . exp ( log Bin Coeff ( n , k ) ) ) ; }
@ Suppress Warnings ( { STRING , STRING } ) private static Method find Apply Method ( ) { try { Class clz = Shared Preferences . Editor . class ; return clz . get Method ( STRING ) ; } catch ( No Such Method Exception e ) { } return null ; }
public Name And Type Constant add Name And Type ( String name , String type ) { Name And Type Constant entry = get Name And Type ( name , type ) ; if ( entry != null ) return entry ; Utf 8 Constant name Entry = add UTF 8 ( name ) ; Utf 8 Constant type Entry = add UTF 8 ( type ) ; entry = new Name And Type Constant ( this , entries . size ( ) , name Entry . get Index ( ) , type Entry . get Index ( ) ) ; add Constant ( entry ) ; return entry ; }
private void place Child ( View child , int gravity ) { Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; int available Width = Math . max ( NUM , m End - m Start - lp . start Margin - lp . end Margin ) ; if ( child . get Measured Width ( ) > available Width || gravity == Gravity . FILL HORIZONTAL ) { measure Child With Fixed Width ( child , available Width ) ; } if ( gravity == Gravity . START || gravity == Gravity . FILL HORIZONTAL ) { lp . start = m Start + lp . start Margin ; m Start = lp . start + child . get Measured Width ( ) + lp . end Margin ; } else { lp . start = m End - lp . end Margin - child . get Measured Width ( ) ; m End = lp . start - lp . start Margin ; } lp . top = m Top + lp . top Margin ; m Bottom = Math . max ( m Bottom , lp . top + child . get Measured Height ( ) + lp . bottom Margin ) ; }
private void place Child ( View child , int gravity ) { Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; int available Width = Math . max ( NUM , m End - m Start - lp . start Margin - lp . end Margin ) ; if ( child . get Measured Width ( ) > available Width || gravity == Gravity . FILL HORIZONTAL ) { measure Child With Fixed Width ( child , available Width ) ; } if ( gravity == Gravity . START || gravity == Gravity . FILL HORIZONTAL ) { lp . start = m Start + lp . start Margin ; m Start = lp . start + child . get Measured Width ( ) + lp . end Margin ; } else { lp . start = m End - lp . end Margin - child . get Measured Width ( ) ; m End = lp . start - lp . start Margin ; } lp . top = m Top + lp . top Margin ; m Bottom = Math . max ( m Bottom , lp . top + child . get Measured Height ( ) + lp . bottom Margin ) ; }
public void terminate ( ) throws IO Exception { try { try { synchronized ( m Jobs ) { while ( m Busy || ! m Jobs . is Empty ( ) ) { m Jobs . wait ( NOT DONE SLEEP TIME ) ; } } } catch ( final Interrupted Exception e ) { Program State . set Abort ( ) ; } finally { shutdown ( ) ; } rethrow ( ) ; } finally { Program State . clear Abort ( ) ; try { synchronized ( m Queue Thread ) { while ( ! m Queue Done ) { m Queue Thread . wait ( NOT DONE SLEEP TIME ) ; } } } catch ( final Interrupted Exception e ) { } } }
public void terminate ( ) throws IO Exception { try { try { synchronized ( m Jobs ) { while ( m Busy || ! m Jobs . is Empty ( ) ) { m Jobs . wait ( NOT DONE SLEEP TIME ) ; } } } catch ( final Interrupted Exception e ) { Program State . set Abort ( ) ; } finally { shutdown ( ) ; } rethrow ( ) ; } finally { Program State . clear Abort ( ) ; try { synchronized ( m Queue Thread ) { while ( ! m Queue Done ) { m Queue Thread . wait ( NOT DONE SLEEP TIME ) ; } } } catch ( final Interrupted Exception e ) { } } }
public void terminate ( ) throws IO Exception { try { try { synchronized ( m Jobs ) { while ( m Busy || ! m Jobs . is Empty ( ) ) { m Jobs . wait ( NOT DONE SLEEP TIME ) ; } } } catch ( final Interrupted Exception e ) { Program State . set Abort ( ) ; } finally { shutdown ( ) ; } rethrow ( ) ; } finally { Program State . clear Abort ( ) ; try { synchronized ( m Queue Thread ) { while ( ! m Queue Done ) { m Queue Thread . wait ( NOT DONE SLEEP TIME ) ; } } } catch ( final Interrupted Exception e ) { } } }
public void terminate ( ) throws IO Exception { try { try { synchronized ( m Jobs ) { while ( m Busy || ! m Jobs . is Empty ( ) ) { m Jobs . wait ( NOT DONE SLEEP TIME ) ; } } } catch ( final Interrupted Exception e ) { Program State . set Abort ( ) ; } finally { shutdown ( ) ; } rethrow ( ) ; } finally { Program State . clear Abort ( ) ; try { synchronized ( m Queue Thread ) { while ( ! m Queue Done ) { m Queue Thread . wait ( NOT DONE SLEEP TIME ) ; } } } catch ( final Interrupted Exception e ) { } } }
public Future < ? > drain Continuously ( ) { return drainer . submit ( new Continuous Drain ( ) ) ; }
public Future < ? > drain Continuously ( ) { return drainer . submit ( new Continuous Drain ( ) ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return HOST ; case NUM : return PORT ; case NUM : return ID ; case NUM : return STATE ; case NUM : return TIMESTAMP ; case NUM : return VERSION ; default : return null ; } }
protected void add To Port Map ( IOF Switch sw , long mac , short vlan , short port Val ) { Map < Mac Vlan Pair , Short > sw Map = mac Vlan To Switch Port Map . get ( sw ) ; if ( vlan == ( short ) NUM ) { vlan = NUM ; } if ( sw Map == null ) { sw Map = Collections . synchronized Map ( new LRU Linked Hash Map < Mac Vlan Pair , Short > ( MAX MACS PER SWITCH ) ) ; mac Vlan To Switch Port Map . put ( sw , sw Map ) ; } sw Map . put ( new Mac Vlan Pair ( mac , vlan ) , port Val ) ; }
@ Override public synchronized boolean take Partition ( String topic , int partition ) { Set < Integer > partition Set = m my Topic Partitions . get ( topic ) ; if ( partition Set == null ) return BOOL ; String owner Path = owner Path ( topic , partition ) ; try { if ( m zk . exists ( owner Path ) ) { return BOOL ; } if ( m zk . create ( owner Path , BOOL ) ) { m zk . write String ( owner Path , m consumer Id ) ; partition Set . add ( partition ) ; return BOOL ; } else return BOOL ; } catch ( Runtime Exception e ) { throw e ; } catch ( Exception e ) { LOGGER . error ( STRING + owner Path , e ) ; return BOOL ; } }
@ Override public synchronized boolean take Partition ( String topic , int partition ) { Set < Integer > partition Set = m my Topic Partitions . get ( topic ) ; if ( partition Set == null ) return BOOL ; String owner Path = owner Path ( topic , partition ) ; try { if ( m zk . exists ( owner Path ) ) { return BOOL ; } if ( m zk . create ( owner Path , BOOL ) ) { m zk . write String ( owner Path , m consumer Id ) ; partition Set . add ( partition ) ; return BOOL ; } else return BOOL ; } catch ( Runtime Exception e ) { throw e ; } catch ( Exception e ) { LOGGER . error ( STRING + owner Path , e ) ; return BOOL ; } }
@ Override public void close ( ) { action Delegates . clear ( ) ; }
public Or Query Builder add ( Query Builder filter Builder ) { filters . add ( filter Builder ) ; return this ; }
@ Override public String first Chunk ( List < String > chunks ) { if ( chunks == null || chunks . size ( ) == NUM ) { return null ; } return chunks . get ( NUM ) ; }
@ Override public String first Chunk ( List < String > chunks ) { if ( chunks == null || chunks . size ( ) == NUM ) { return null ; } return chunks . get ( NUM ) ; }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null && m Service != null ) { try { m Context . unbind Service ( m Service Conn ) ; } catch ( Exception e ) { } } } m Disposed = BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null && m Service != null ) { try { m Context . unbind Service ( m Service Conn ) ; } catch ( Exception e ) { } } } m Disposed = BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null && m Service != null ) { try { m Context . unbind Service ( m Service Conn ) ; } catch ( Exception e ) { } } } m Disposed = BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null && m Service != null ) { try { m Context . unbind Service ( m Service Conn ) ; } catch ( Exception e ) { } } } m Disposed = BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
M meta ( ) ;
private void check To Repaint ( ) { long time Passed = ( System . current Time Millis ( ) - last Repainted ) / NUM ; if ( time Passed > REPAINT DELAY ) { repaint ( ) ; last Repainted = System . current Time Millis ( ) ; } }
public int [ ] to Unsorted Model Indices ( int [ ] sorted Selected Indices ) { int [ ] unsorted Selected Indices = new int [ sorted Selected Indices . length ] ; int x = NUM ; for ( int sorted Index : sorted Selected Indices ) { unsorted Selected Indices [ x ++ ] = to Unsorted Model Index ( sorted Index ) ; } Arrays . sort ( unsorted Selected Indices ) ; return unsorted Selected Indices ; }
public int [ ] to Unsorted Model Indices ( int [ ] sorted Selected Indices ) { int [ ] unsorted Selected Indices = new int [ sorted Selected Indices . length ] ; int x = NUM ; for ( int sorted Index : sorted Selected Indices ) { unsorted Selected Indices [ x ++ ] = to Unsorted Model Index ( sorted Index ) ; } Arrays . sort ( unsorted Selected Indices ) ; return unsorted Selected Indices ; }
public void notify Address Throttle Found ( Dcc Throttle t ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } m Throttle = t ; set Enabled ( BOOL ) ; m Throttle . add Property Change Listener ( this ) ; set Fn Buttons ( ) ; }
public void notify Address Throttle Found ( Dcc Throttle t ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } m Throttle = t ; set Enabled ( BOOL ) ; m Throttle . add Property Change Listener ( this ) ; set Fn Buttons ( ) ; }
public void notify Address Throttle Found ( Dcc Throttle t ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } m Throttle = t ; set Enabled ( BOOL ) ; m Throttle . add Property Change Listener ( this ) ; set Fn Buttons ( ) ; }
@ Response Body @ Request Mapping ( value = STRING , method = Request Method . GET ) public List < Container Unit > list Container ( @ Path Variable String application Name ) throws Service Exception , Check Exception { logger . debug ( STRING + application Name ) ; return application Service . list Containers ( application Name ) ; }
private void write Packet Out For Packet In ( IOF Switch sw , OF Packet In packet In Message , OF Port egress Port ) { OF Message Utils . write Packet Out For Packet In ( sw , packet In Message , egress Port ) ; counter Packet Out . increment ( ) ; }
public < U > Simple React Stream < Long > from ( final Long Stream stream ) { return from ( stream . boxed ( ) ) ; }
private void write Journal ( Parcel File Descriptor new State , Journal journal ) { try { File Output Stream out Stream = new File Output Stream ( new State . get File Descriptor ( ) ) ; final byte [ ] journal Bytes = write Checked Bytes ( journal ) ; out Stream . write ( journal Bytes ) ; if ( VERBOSE ) Log . v ( TAG , STRING + journal Bytes . length + STRING ) ; } catch ( IO Exception e ) { Log . w ( TAG , STRING , e ) ; } }
private void write Journal ( Parcel File Descriptor new State , Journal journal ) { try { File Output Stream out Stream = new File Output Stream ( new State . get File Descriptor ( ) ) ; final byte [ ] journal Bytes = write Checked Bytes ( journal ) ; out Stream . write ( journal Bytes ) ; if ( VERBOSE ) Log . v ( TAG , STRING + journal Bytes . length + STRING ) ; } catch ( IO Exception e ) { Log . w ( TAG , STRING , e ) ; } }
private void write Journal ( Parcel File Descriptor new State , Journal journal ) { try { File Output Stream out Stream = new File Output Stream ( new State . get File Descriptor ( ) ) ; final byte [ ] journal Bytes = write Checked Bytes ( journal ) ; out Stream . write ( journal Bytes ) ; if ( VERBOSE ) Log . v ( TAG , STRING + journal Bytes . length + STRING ) ; } catch ( IO Exception e ) { Log . w ( TAG , STRING , e ) ; } }
protected boolean unsync Enclosed ( ) { try { Offset Grab Point gb 0 = ( Offset Grab Point ) poly Grab Points . get ( NUM ) ; Offset Grab Point ogb = ( Offset Grab Point ) poly Grab Points . get ( poly Grab Points . size ( ) - NUM ) ; if ( gb 0 . get X ( ) == ogb . get X ( ) && gb 0 . get Y ( ) == ogb . get Y ( ) ) { gb 0 . remove Grab Point ( ogb ) ; ogb . remove Grab Point ( gb 0 ) ; return BOOL ; } } catch ( Class Cast Exception cce ) { } catch ( Array Index Out Of Bounds Exception aioobe ) { } return BOOL ; }
protected boolean unsync Enclosed ( ) { try { Offset Grab Point gb 0 = ( Offset Grab Point ) poly Grab Points . get ( NUM ) ; Offset Grab Point ogb = ( Offset Grab Point ) poly Grab Points . get ( poly Grab Points . size ( ) - NUM ) ; if ( gb 0 . get X ( ) == ogb . get X ( ) && gb 0 . get Y ( ) == ogb . get Y ( ) ) { gb 0 . remove Grab Point ( ogb ) ; ogb . remove Grab Point ( gb 0 ) ; return BOOL ; } } catch ( Class Cast Exception cce ) { } catch ( Array Index Out Of Bounds Exception aioobe ) { } return BOOL ; }
Cut ( Constant value , double diff ) { this . value = value ; this . diff = diff ; }
Cut ( Constant value , double diff ) { this . value = value ; this . diff = diff ; }
Cut ( Constant value , double diff ) { this . value = value ; this . diff = diff ; }
Cut ( Constant value , double diff ) { this . value = value ; this . diff = diff ; }
static public void do Rejection Test ( String data , Class exception Class ) { try { MIME Type t = new MIME Type ( data ) ; } catch ( Throwable t ) { if ( exception Class . is Instance ( t ) ) return ; t . print Stack Trace ( System . err ) ; throw new Assertion Failed Error 2 ( STRING + exception Class + STRING + STRING + t . get Class ( ) + STRING + data + STRING , t ) ; } throw new Assertion Failed Error ( STRING + exception Class + STRING + data + STRING ) ; }
static public void do Rejection Test ( String data , Class exception Class ) { try { MIME Type t = new MIME Type ( data ) ; } catch ( Throwable t ) { if ( exception Class . is Instance ( t ) ) return ; t . print Stack Trace ( System . err ) ; throw new Assertion Failed Error 2 ( STRING + exception Class + STRING + STRING + t . get Class ( ) + STRING + data + STRING , t ) ; } throw new Assertion Failed Error ( STRING + exception Class + STRING + data + STRING ) ; }
public boolean delete Project ( File directory ) { Log . i ( TAG , STRING + directory . to String ( ) ) ; if ( directory . is Directory ( ) ) { String [ ] files In Direcory = directory . list ( ) ; for ( int i = NUM ; i < files In Direcory . length ; i ++ ) { boolean success = delete Project ( new File ( directory , files In Direcory [ i ] ) ) ; if ( ! success ) { return BOOL ; } } } return directory . delete ( ) ; }
public void verify Counts And Clear ( int expected Registrations , int expected Unregistrations ) { assert Equals ( expected Registrations , registration Count ) ; assert Equals ( expected Unregistrations , unregistration Count ) ; registration Count = NUM ; unregistration Count = NUM ; }
@ Override public Shard Response take Completed Including Errors ( ) { return take ( BOOL ) ; }
public static boolean match ( String value , String str Pattern ) { if ( is Not Empty ( str Pattern ) ) { if ( is Blank ( value ) ) { return str Pattern . equals ( STRING ) ; } value = value . to Lower Case ( ) ; str Pattern = str Pattern . to Lower Case ( ) ; String Builder buff = new String Builder ( ) ; for ( int i = NUM ; i < str Pattern . length ( ) - NUM ; i ++ ) { char c = str Pattern . char At ( i ) ; if ( c == STRING ) { buff . append ( STRING ) ; } else { buff . append ( c ) ; } } char last Char = str Pattern . char At ( str Pattern . length ( ) - NUM ) ; if ( last Char == STRING ) { buff . append ( STRING ) ; } else { buff . append ( last Char ) ; } return Pattern . matches ( buff . to String ( ) , value ) ; } return BOOL ; }
public int write Proto Id ( Proto Id proto Id ) { int off = data . position ( ) ; write Int ( proto Id . shorty Index ) ; write Int ( proto Id . return Type Index ) ; write Int ( proto Id . parameters Offset ) ; return off ; }
@ Override public synchronized Object execute Task ( Task t ) throws Remote Exception { String task Id = STRING + System . current Time Millis ( ) + STRING ; task Id += t . hash Code ( ) ; add Task To Queue ( t , task Id ) ; return task Id ; }
public static Constraints Parameters load Policy Data ( Input Stream policy Data Stream ) { if ( policy Data Stream != null ) { return load ( policy Data Stream ) ; } if ( ( default Policy Constraints Location != null ) && ! default Policy Constraints Location . is Empty ( ) ) { return load ( default Policy Constraints Location ) ; } return null ; }
private List < Vcs Exception > parse Exception ( final String stderr ) { final List < Vcs Exception > exceptions = new Array List < Vcs Exception > ( ) ; final String [ ] exception Lines = get Lines ( stderr ) ; for ( int i = exception Lines . length / NUM ; i < exception Lines . length ; i ++ ) { if ( String Utils . is Not Empty ( exception Lines [ i ] ) && ! String Utils . contains ( exception Lines [ i ] , CONFLICT MESSAGE ) ) { final Vcs Exception exception = new Vcs Exception ( ( exception Lines [ i ] ) ) ; exception . set Is Warning ( String Utils . starts With ( exception Lines [ i ] , WARNING PREFIX ) ) ; exceptions . add ( exception ) ; } } return exceptions ; }
private List < Vcs Exception > parse Exception ( final String stderr ) { final List < Vcs Exception > exceptions = new Array List < Vcs Exception > ( ) ; final String [ ] exception Lines = get Lines ( stderr ) ; for ( int i = exception Lines . length / NUM ; i < exception Lines . length ; i ++ ) { if ( String Utils . is Not Empty ( exception Lines [ i ] ) && ! String Utils . contains ( exception Lines [ i ] , CONFLICT MESSAGE ) ) { final Vcs Exception exception = new Vcs Exception ( ( exception Lines [ i ] ) ) ; exception . set Is Warning ( String Utils . starts With ( exception Lines [ i ] , WARNING PREFIX ) ) ; exceptions . add ( exception ) ; } } return exceptions ; }
private List < Vcs Exception > parse Exception ( final String stderr ) { final List < Vcs Exception > exceptions = new Array List < Vcs Exception > ( ) ; final String [ ] exception Lines = get Lines ( stderr ) ; for ( int i = exception Lines . length / NUM ; i < exception Lines . length ; i ++ ) { if ( String Utils . is Not Empty ( exception Lines [ i ] ) && ! String Utils . contains ( exception Lines [ i ] , CONFLICT MESSAGE ) ) { final Vcs Exception exception = new Vcs Exception ( ( exception Lines [ i ] ) ) ; exception . set Is Warning ( String Utils . starts With ( exception Lines [ i ] , WARNING PREFIX ) ) ; exceptions . add ( exception ) ; } } return exceptions ; }
private List < Vcs Exception > parse Exception ( final String stderr ) { final List < Vcs Exception > exceptions = new Array List < Vcs Exception > ( ) ; final String [ ] exception Lines = get Lines ( stderr ) ; for ( int i = exception Lines . length / NUM ; i < exception Lines . length ; i ++ ) { if ( String Utils . is Not Empty ( exception Lines [ i ] ) && ! String Utils . contains ( exception Lines [ i ] , CONFLICT MESSAGE ) ) { final Vcs Exception exception = new Vcs Exception ( ( exception Lines [ i ] ) ) ; exception . set Is Warning ( String Utils . starts With ( exception Lines [ i ] , WARNING PREFIX ) ) ; exceptions . add ( exception ) ; } } return exceptions ; }
private List < Vcs Exception > parse Exception ( final String stderr ) { final List < Vcs Exception > exceptions = new Array List < Vcs Exception > ( ) ; final String [ ] exception Lines = get Lines ( stderr ) ; for ( int i = exception Lines . length / NUM ; i < exception Lines . length ; i ++ ) { if ( String Utils . is Not Empty ( exception Lines [ i ] ) && ! String Utils . contains ( exception Lines [ i ] , CONFLICT MESSAGE ) ) { final Vcs Exception exception = new Vcs Exception ( ( exception Lines [ i ] ) ) ; exception . set Is Warning ( String Utils . starts With ( exception Lines [ i ] , WARNING PREFIX ) ) ; exceptions . add ( exception ) ; } } return exceptions ; }
public static int int From Properties ( Properties p , String prop Name , int default Value ) { int ret = default Value ; String int String = p . get Property ( prop Name ) ; if ( int String != null ) { try { ret = Integer . parse Int ( int String . trim ( ) ) ; } catch ( Number Format Exception e ) { ret = default Value ; } } return ret ; }
public static int int From Properties ( Properties p , String prop Name , int default Value ) { int ret = default Value ; String int String = p . get Property ( prop Name ) ; if ( int String != null ) { try { ret = Integer . parse Int ( int String . trim ( ) ) ; } catch ( Number Format Exception e ) { ret = default Value ; } } return ret ; }
protected final void fire Property Change ( Property Change Event event ) { Property Change Support a Change Support = this . change Support ; if ( a Change Support == null ) { return ; } a Change Support . fire Property Change ( event ) ; }
public To Hit Data los Modifiers ( I Game game ) { return los Modifiers ( game , NUM , BOOL ) ; }
public To Hit Data los Modifiers ( I Game game ) { return los Modifiers ( game , NUM , BOOL ) ; }
public void append ( File file , FTP Data Transfer Listener listener ) throws Illegal State Exception , File Not Found Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception , FTP Data Transfer Exception , FTP Aborted Exception { if ( ! file . exists ( ) ) { throw new File Not Found Exception ( file . get Absolute Path ( ) ) ; } Input Stream input Stream = null ; try { input Stream = new File Input Stream ( file ) ; } catch ( IO Exception e ) { throw new FTP Data Transfer Exception ( e ) ; } try { append ( file . get Name ( ) , input Stream , NUM , listener ) ; } catch ( Illegal State Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( FTP Illegal Reply Exception e ) { throw e ; } catch ( FTP Exception e ) { throw e ; } catch ( FTP Data Transfer Exception e ) { throw e ; } catch ( FTP Aborted Exception e ) { throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void append ( File file , FTP Data Transfer Listener listener ) throws Illegal State Exception , File Not Found Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception , FTP Data Transfer Exception , FTP Aborted Exception { if ( ! file . exists ( ) ) { throw new File Not Found Exception ( file . get Absolute Path ( ) ) ; } Input Stream input Stream = null ; try { input Stream = new File Input Stream ( file ) ; } catch ( IO Exception e ) { throw new FTP Data Transfer Exception ( e ) ; } try { append ( file . get Name ( ) , input Stream , NUM , listener ) ; } catch ( Illegal State Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( FTP Illegal Reply Exception e ) { throw e ; } catch ( FTP Exception e ) { throw e ; } catch ( FTP Data Transfer Exception e ) { throw e ; } catch ( FTP Aborted Exception e ) { throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void append ( File file , FTP Data Transfer Listener listener ) throws Illegal State Exception , File Not Found Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception , FTP Data Transfer Exception , FTP Aborted Exception { if ( ! file . exists ( ) ) { throw new File Not Found Exception ( file . get Absolute Path ( ) ) ; } Input Stream input Stream = null ; try { input Stream = new File Input Stream ( file ) ; } catch ( IO Exception e ) { throw new FTP Data Transfer Exception ( e ) ; } try { append ( file . get Name ( ) , input Stream , NUM , listener ) ; } catch ( Illegal State Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( FTP Illegal Reply Exception e ) { throw e ; } catch ( FTP Exception e ) { throw e ; } catch ( FTP Data Transfer Exception e ) { throw e ; } catch ( FTP Aborted Exception e ) { throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void append ( File file , FTP Data Transfer Listener listener ) throws Illegal State Exception , File Not Found Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception , FTP Data Transfer Exception , FTP Aborted Exception { if ( ! file . exists ( ) ) { throw new File Not Found Exception ( file . get Absolute Path ( ) ) ; } Input Stream input Stream = null ; try { input Stream = new File Input Stream ( file ) ; } catch ( IO Exception e ) { throw new FTP Data Transfer Exception ( e ) ; } try { append ( file . get Name ( ) , input Stream , NUM , listener ) ; } catch ( Illegal State Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( FTP Illegal Reply Exception e ) { throw e ; } catch ( FTP Exception e ) { throw e ; } catch ( FTP Data Transfer Exception e ) { throw e ; } catch ( FTP Aborted Exception e ) { throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void append ( File file , FTP Data Transfer Listener listener ) throws Illegal State Exception , File Not Found Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception , FTP Data Transfer Exception , FTP Aborted Exception { if ( ! file . exists ( ) ) { throw new File Not Found Exception ( file . get Absolute Path ( ) ) ; } Input Stream input Stream = null ; try { input Stream = new File Input Stream ( file ) ; } catch ( IO Exception e ) { throw new FTP Data Transfer Exception ( e ) ; } try { append ( file . get Name ( ) , input Stream , NUM , listener ) ; } catch ( Illegal State Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( FTP Illegal Reply Exception e ) { throw e ; } catch ( FTP Exception e ) { throw e ; } catch ( FTP Data Transfer Exception e ) { throw e ; } catch ( FTP Aborted Exception e ) { throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void append ( File file , FTP Data Transfer Listener listener ) throws Illegal State Exception , File Not Found Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception , FTP Data Transfer Exception , FTP Aborted Exception { if ( ! file . exists ( ) ) { throw new File Not Found Exception ( file . get Absolute Path ( ) ) ; } Input Stream input Stream = null ; try { input Stream = new File Input Stream ( file ) ; } catch ( IO Exception e ) { throw new FTP Data Transfer Exception ( e ) ; } try { append ( file . get Name ( ) , input Stream , NUM , listener ) ; } catch ( Illegal State Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( FTP Illegal Reply Exception e ) { throw e ; } catch ( FTP Exception e ) { throw e ; } catch ( FTP Data Transfer Exception e ) { throw e ; } catch ( FTP Aborted Exception e ) { throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void append ( File file , FTP Data Transfer Listener listener ) throws Illegal State Exception , File Not Found Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception , FTP Data Transfer Exception , FTP Aborted Exception { if ( ! file . exists ( ) ) { throw new File Not Found Exception ( file . get Absolute Path ( ) ) ; } Input Stream input Stream = null ; try { input Stream = new File Input Stream ( file ) ; } catch ( IO Exception e ) { throw new FTP Data Transfer Exception ( e ) ; } try { append ( file . get Name ( ) , input Stream , NUM , listener ) ; } catch ( Illegal State Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( FTP Illegal Reply Exception e ) { throw e ; } catch ( FTP Exception e ) { throw e ; } catch ( FTP Data Transfer Exception e ) { throw e ; } catch ( FTP Aborted Exception e ) { throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch ( Throwable t ) { ; } } } }
protected Transferable create Transferable ( J Component c ) { if ( c instanceof J List ) { J List list = ( J List ) c ; Object [ ] values = list . get Selected Values ( ) ; if ( values == null || values . length == NUM ) { return null ; } String Buffer plain Buf = new String Buffer ( ) ; String Buffer html Buf = new String Buffer ( ) ; html Buf . append ( STRING ) ; for ( int i = NUM ; i < values . length ; i ++ ) { Object obj = values [ i ] ; String val = ( ( obj == null ) ? STRING : obj . to String ( ) ) ; plain Buf . append ( val + STRING ) ; html Buf . append ( STRING + val + STRING ) ; } plain Buf . delete Char At ( plain Buf . length ( ) - NUM ) ; html Buf . append ( STRING ) ; return new Basic Transferable ( plain Buf . to String ( ) , html Buf . to String ( ) ) ; } return null ; }
public static void update State Set Trees ( List < Tree < State Set > > trees , Array Parser parser ) { for ( Tree < State Set > tree : trees ) { parser . do Inside Outside Scores ( tree , BOOL , BOOL ) ; } }
public static void update State Set Trees ( List < Tree < State Set > > trees , Array Parser parser ) { for ( Tree < State Set > tree : trees ) { parser . do Inside Outside Scores ( tree , BOOL , BOOL ) ; } }
public static void update State Set Trees ( List < Tree < State Set > > trees , Array Parser parser ) { for ( Tree < State Set > tree : trees ) { parser . do Inside Outside Scores ( tree , BOOL , BOOL ) ; } }
public static void update State Set Trees ( List < Tree < State Set > > trees , Array Parser parser ) { for ( Tree < State Set > tree : trees ) { parser . do Inside Outside Scores ( tree , BOOL , BOOL ) ; } }
public void action Performed ( Action Event ae ) { if ( ae . get Source ( ) == get Timer ( ) ) { change Time By ( time Increment * clock Direction , time Wrap , clock Direction < NUM ? Timer Status . UPDATE : Timer Status . FORWARD ) ; } }
public void action Performed ( Action Event ae ) { if ( ae . get Source ( ) == get Timer ( ) ) { change Time By ( time Increment * clock Direction , time Wrap , clock Direction < NUM ? Timer Status . UPDATE : Timer Status . FORWARD ) ; } }
public static int find Word Start ( String line , int pos , String no Word Sep ) { char ch = line . char At ( pos - NUM ) ; if ( no Word Sep == null ) no Word Sep = STRING ; boolean select No Letter = ( ! Character . is Letter Or Digit ( ch ) && no Word Sep . index Of ( ch ) == - NUM ) ; int word Start = NUM ; for ( int i = pos - NUM ; i >= NUM ; i -- ) { ch = line . char At ( i ) ; if ( select No Letter ^ ( ! Character . is Letter Or Digit ( ch ) && no Word Sep . index Of ( ch ) == - NUM ) ) { word Start = i + NUM ; break ; } } return word Start ; }
public static int find Word Start ( String line , int pos , String no Word Sep ) { char ch = line . char At ( pos - NUM ) ; if ( no Word Sep == null ) no Word Sep = STRING ; boolean select No Letter = ( ! Character . is Letter Or Digit ( ch ) && no Word Sep . index Of ( ch ) == - NUM ) ; int word Start = NUM ; for ( int i = pos - NUM ; i >= NUM ; i -- ) { ch = line . char At ( i ) ; if ( select No Letter ^ ( ! Character . is Letter Or Digit ( ch ) && no Word Sep . index Of ( ch ) == - NUM ) ) { word Start = i + NUM ; break ; } } return word Start ; }
public double adjusted Rand Index ( ) { double d = Math . sqrt ( pairconfuse [ NUM ] + pairconfuse [ NUM ] + pairconfuse [ NUM ] + pairconfuse [ NUM ] ) ; double exp = ( pairconfuse [ NUM ] + pairconfuse [ NUM ] ) / d * ( pairconfuse [ NUM ] + pairconfuse [ NUM ] ) / d ; double opt = pairconfuse [ NUM ] + NUM * ( pairconfuse [ NUM ] + pairconfuse [ NUM ] ) ; return ( pairconfuse [ NUM ] - exp ) / ( opt - exp ) ; }
public int right x value ( int p y ) { int result = Math . min ( oct rx , oct urx - p y ) ; return Math . min ( result , oct lrx + p y ) ; }
public void add Static Field ( Encoded Field field , Constant value ) { if ( field == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( static Values Constant != null ) { throw new Unsupported Operation Exception ( STRING ) ; } static Fields . add ( field ) ; static Values . put ( field , value ) ; }
protected boolean filter Files ( List < File > files ) { if ( task . get No Mtime Check ( ) || is Output Repository URL ( ) ) { return BOOL ; } Iterator < File > iter = files . iterator ( ) ; while ( iter . has Next ( ) ) { File file = iter . next ( ) ; Module module = infer Module ( file ) ; if ( module == null ) { task . log ( STRING + file , Project . MSG VERBOSE ) ; continue ; } if ( module . get Version ( ) == null ) { task . log ( STRING + module . get Name ( ) , Project . MSG VERBOSE ) ; continue ; } long oldest = get Artifact File Time ( module , file ) ; if ( oldest == Long . MAX VALUE ) { File out Module Dir = get Artifact Dir ( module ) ; oldest = oldest Output Artifact ( Long . MAX VALUE , out Module Dir ) ; task . log ( STRING + module + STRING + new Date ( oldest ) , Project . MSG DEBUG ) ; } else { task . log ( STRING + file + STRING + module + STRING + new Date ( oldest ) , Project . MSG DEBUG ) ; } long newest File = file . last Modified ( ) ; task . log ( STRING + file + STRING + new Date ( newest File ) , Project . MSG DEBUG ) ; if ( newest File != Long . MIN VALUE && oldest != Long . MAX VALUE && newest File < oldest ) { task . log ( STRING + file + STRING ) ; iter . remove ( ) ; } } return files . size ( ) == NUM ; }
protected boolean filter Files ( List < File > files ) { if ( task . get No Mtime Check ( ) || is Output Repository URL ( ) ) { return BOOL ; } Iterator < File > iter = files . iterator ( ) ; while ( iter . has Next ( ) ) { File file = iter . next ( ) ; Module module = infer Module ( file ) ; if ( module == null ) { task . log ( STRING + file , Project . MSG VERBOSE ) ; continue ; } if ( module . get Version ( ) == null ) { task . log ( STRING + module . get Name ( ) , Project . MSG VERBOSE ) ; continue ; } long oldest = get Artifact File Time ( module , file ) ; if ( oldest == Long . MAX VALUE ) { File out Module Dir = get Artifact Dir ( module ) ; oldest = oldest Output Artifact ( Long . MAX VALUE , out Module Dir ) ; task . log ( STRING + module + STRING + new Date ( oldest ) , Project . MSG DEBUG ) ; } else { task . log ( STRING + file + STRING + module + STRING + new Date ( oldest ) , Project . MSG DEBUG ) ; } long newest File = file . last Modified ( ) ; task . log ( STRING + file + STRING + new Date ( newest File ) , Project . MSG DEBUG ) ; if ( newest File != Long . MIN VALUE && oldest != Long . MAX VALUE && newest File < oldest ) { task . log ( STRING + file + STRING ) ; iter . remove ( ) ; } } return files . size ( ) == NUM ; }
protected boolean filter Files ( List < File > files ) { if ( task . get No Mtime Check ( ) || is Output Repository URL ( ) ) { return BOOL ; } Iterator < File > iter = files . iterator ( ) ; while ( iter . has Next ( ) ) { File file = iter . next ( ) ; Module module = infer Module ( file ) ; if ( module == null ) { task . log ( STRING + file , Project . MSG VERBOSE ) ; continue ; } if ( module . get Version ( ) == null ) { task . log ( STRING + module . get Name ( ) , Project . MSG VERBOSE ) ; continue ; } long oldest = get Artifact File Time ( module , file ) ; if ( oldest == Long . MAX VALUE ) { File out Module Dir = get Artifact Dir ( module ) ; oldest = oldest Output Artifact ( Long . MAX VALUE , out Module Dir ) ; task . log ( STRING + module + STRING + new Date ( oldest ) , Project . MSG DEBUG ) ; } else { task . log ( STRING + file + STRING + module + STRING + new Date ( oldest ) , Project . MSG DEBUG ) ; } long newest File = file . last Modified ( ) ; task . log ( STRING + file + STRING + new Date ( newest File ) , Project . MSG DEBUG ) ; if ( newest File != Long . MIN VALUE && oldest != Long . MAX VALUE && newest File < oldest ) { task . log ( STRING + file + STRING ) ; iter . remove ( ) ; } } return files . size ( ) == NUM ; }
public void close File ( boolean show Cancel ) { if ( get Current Index ( ) == - NUM ) { return ; } if ( ! save Changes ( show Cancel ) ) { return ; } m Tabbed Pane . remove Tab At ( get Current Index ( ) ) ; update Frame Title ( ) ; System . gc ( ) ; }
public static void unregister Deferral ( Profile Activator pa ) { if ( ! deferring ) { return ; } if ( a Vector == null ) { return ; } a Vector . remove Element ( pa ) ; return ; }
public CAS process ( String text ) { CAS cas = retrieve ( ) ; cas . set Document Text ( text ) ; try { analysis Engine . process ( cas ) ; } catch ( Analysis Engine Process Exception e ) { if ( text != null && ! text . is Empty ( ) ) return process ( text ) ; throw new Runtime Exception ( e ) ; } return cas ; }
public Program Rewriter ( Statement Block Rewrite Rule rewrite ) { dag Rule Set = new Array List < Hop Rewrite Rule > ( ) ; sb Rule Set = new Array List < Statement Block Rewrite Rule > ( ) ; sb Rule Set . add ( rewrite ) ; }
public static String to Sep List ( Iterator string Iter , String sep ) { String Builder sb = new String Builder ( ) ; if ( string Iter . has Next ( ) ) { sb . append ( ( String ) string Iter . next ( ) ) ; } while ( string Iter . has Next ( ) ) { sb . append ( sep ) ; sb . append ( ( String ) string Iter . next ( ) ) ; } return sb . to String ( ) ; }
public static String to Sep List ( Iterator string Iter , String sep ) { String Builder sb = new String Builder ( ) ; if ( string Iter . has Next ( ) ) { sb . append ( ( String ) string Iter . next ( ) ) ; } while ( string Iter . has Next ( ) ) { sb . append ( sep ) ; sb . append ( ( String ) string Iter . next ( ) ) ; } return sb . to String ( ) ; }
public D Netscape Certificate Type ( J Dialog parent , byte [ ] value ) throws IO Exception { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public static I Java Search Scope create Related Projects Scope ( I Java Project project , int include Mask ) throws Core Exception { I Java Project [ ] projects = get Related Projects ( project ) ; return Search Engine . create Java Search Scope ( projects , include Mask ) ; }
public static I Java Search Scope create Related Projects Scope ( I Java Project project , int include Mask ) throws Core Exception { I Java Project [ ] projects = get Related Projects ( project ) ; return Search Engine . create Java Search Scope ( projects , include Mask ) ; }
public static I Java Search Scope create Related Projects Scope ( I Java Project project , int include Mask ) throws Core Exception { I Java Project [ ] projects = get Related Projects ( project ) ; return Search Engine . create Java Search Scope ( projects , include Mask ) ; }
protected void handle Match ( T mapping , String lookup Path , Server Web Exchange exchange ) { }
public void add Foreign Key ( int idx , Foreign Key foreign Key ) { if ( foreign Key != null ) { foreign Keys . add ( idx , foreign Key ) ; } }
public void add Foreign Key ( int idx , Foreign Key foreign Key ) { if ( foreign Key != null ) { foreign Keys . add ( idx , foreign Key ) ; } }
private Node rotate Right ( Node x ) { Node y = x . left ; x . left = y . right ; y . right = x ; y . size = x . size ; x . size = NUM + size ( x . left ) + size ( x . right ) ; x . height = NUM + Math . max ( height ( x . left ) , height ( x . right ) ) ; y . height = NUM + Math . max ( height ( y . left ) , height ( y . right ) ) ; return y ; }
public int compare ( File file 1 , File file 2 ) { String suffix 1 = Filename Utils . get Extension ( file 1 . get Name ( ) ) ; String suffix 2 = Filename Utils . get Extension ( file 2 . get Name ( ) ) ; return case Sensitivity . check Compare To ( suffix 1 , suffix 2 ) ; }
private void compact Criticals ( Mech mech ) { for ( int loc = NUM ; loc < mech . locations ( ) ; loc ++ ) { compact Criticals ( mech , loc ) ; } }
private void compact Criticals ( Mech mech ) { for ( int loc = NUM ; loc < mech . locations ( ) ; loc ++ ) { compact Criticals ( mech , loc ) ; } }
private void compact Criticals ( Mech mech ) { for ( int loc = NUM ; loc < mech . locations ( ) ; loc ++ ) { compact Criticals ( mech , loc ) ; } }
private void compact Criticals ( Mech mech ) { for ( int loc = NUM ; loc < mech . locations ( ) ; loc ++ ) { compact Criticals ( mech , loc ) ; } }
private void compact Criticals ( Mech mech ) { for ( int loc = NUM ; loc < mech . locations ( ) ; loc ++ ) { compact Criticals ( mech , loc ) ; } }
private void compact Criticals ( Mech mech ) { for ( int loc = NUM ; loc < mech . locations ( ) ; loc ++ ) { compact Criticals ( mech , loc ) ; } }
private void compact Criticals ( Mech mech ) { for ( int loc = NUM ; loc < mech . locations ( ) ; loc ++ ) { compact Criticals ( mech , loc ) ; } }
public int number Of Shards With State ( Shard Routing State ... states ) { int count = NUM ; for ( Shard Routing shard Entry : this ) { for ( Shard Routing State state : states ) { if ( shard Entry . state ( ) == state ) { count ++ ; } } } return count ; }
protected boolean is Side Channel Active ( ) { return System . getenv ( SIDECHANNEL AUTH ENV NAME ) != null ; }
protected boolean is Side Channel Active ( ) { return System . getenv ( SIDECHANNEL AUTH ENV NAME ) != null ; }
protected boolean is Side Channel Active ( ) { return System . getenv ( SIDECHANNEL AUTH ENV NAME ) != null ; }
protected boolean is Side Channel Active ( ) { return System . getenv ( SIDECHANNEL AUTH ENV NAME ) != null ; }
protected boolean is Side Channel Active ( ) { return System . getenv ( SIDECHANNEL AUTH ENV NAME ) != null ; }
public void test Serialization ( ) throws IO Exception , Class Not Found Exception { final IHA Write Message msg 1 = new HA Write Message ( UUID . random UUID ( ) , NUM , NUM , NUM , NUM , NUM , Store Type Enum . RW , NUM , NUM , NUM ) ; final byte [ ] ser 1 = serialized ( msg 1 ) ; final IHA Write Message msg 2 = ( IHA Write Message ) Serializer Util . deserialize ( ser 1 ) ; assert True ( msg 1 . equals ( msg 2 ) ) ; final byte [ ] ser 2 = serialized ( msg 2 ) ; assert True ( Bytes Util . bytes Equal ( ser 1 , ser 2 ) ) ; }
public static boolean is Zoning Required ( Db Client db Client , URI varray Uri ) { if ( varray Uri != null ) { Virtual Array nh = db Client . query Object ( Virtual Array . class , varray Uri ) ; if ( nh != null ) { return is Zoning Required ( db Client , nh ) ; } } return BOOL ; }
public static void add Attribute Default Values ( String service Name , String sub Schema Name , String schema Type , String attribute Name , Set default Values ) throws Upgrade Exception { String class Method = STRING ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + STRING ) ; debug . message ( STRING + service Name + STRING + attribute Name ) ; } Service Schema ss = get Service Schema ( service Name , sub Schema Name , schema Type ) ; try { Map attribute Defaults = ss . get Attribute Defaults ( ) ; Set old Attr Values = ( Set ) attribute Defaults . get ( attribute Name ) ; Set new Attr Values = ( ( old Attr Values == null ) || old Attr Values . is Empty ( ) ) ? new Hash Set ( ) : new Hash Set ( old Attr Values ) ; new Attr Values . add All ( default Values ) ; ss . set Attribute Defaults ( attribute Name , new Attr Values ) ; } catch ( SSO Exception ssoe ) { throw new Upgrade Exception ( STRING ) ; } catch ( SMS Exception sme ) { throw new Upgrade Exception ( STRING + STRING ) ; } }
public static String create Resource Name ( String resource , Locale locale , boolean remove Extension ) { String resource Name = resource ; if ( remove Extension ) { if ( resource Name . ends With ( STRING ) ) { resource Name = resource Name . replace ( STRING , STRING ) ; } else if ( resource Name . ends With ( STRING ) ) { resource Name = resource Name . replace ( STRING , STRING ) ; } } if ( locale != null ) { if ( Util Validate . is Not Empty ( locale . to String ( ) ) ) { resource Name = resource Name + STRING + locale ; } } return resource Name ; }
private void remove From My Plan UI ( int position ) { offers . remove ( position ) ; notify Binder Item Removed ( position ) ; notify Binder Item Range Changed ( position , NUM ) ; }
public static Map < String , String > json To Map ( String json String ) { Map < String , String > json Map = new Tree Map < String , String > ( ) ; try { Gf Json Object json Object = new Gf Json Object ( json String ) ; Iterator < String > keys = json Object . keys ( ) ; while ( keys . has Next ( ) ) { String key = keys . next ( ) ; json Map . put ( key , json Object . get String ( key ) ) ; } } catch ( Gf Json Exception e ) { throw new Illegal Argument Exception ( STRING + json String + STRING ) ; } return json Map ; }
public static Map < String , String > json To Map ( String json String ) { Map < String , String > json Map = new Tree Map < String , String > ( ) ; try { Gf Json Object json Object = new Gf Json Object ( json String ) ; Iterator < String > keys = json Object . keys ( ) ; while ( keys . has Next ( ) ) { String key = keys . next ( ) ; json Map . put ( key , json Object . get String ( key ) ) ; } } catch ( Gf Json Exception e ) { throw new Illegal Argument Exception ( STRING + json String + STRING ) ; } return json Map ; }
public static Map < String , String > json To Map ( String json String ) { Map < String , String > json Map = new Tree Map < String , String > ( ) ; try { Gf Json Object json Object = new Gf Json Object ( json String ) ; Iterator < String > keys = json Object . keys ( ) ; while ( keys . has Next ( ) ) { String key = keys . next ( ) ; json Map . put ( key , json Object . get String ( key ) ) ; } } catch ( Gf Json Exception e ) { throw new Illegal Argument Exception ( STRING + json String + STRING ) ; } return json Map ; }
public static Map < String , String > json To Map ( String json String ) { Map < String , String > json Map = new Tree Map < String , String > ( ) ; try { Gf Json Object json Object = new Gf Json Object ( json String ) ; Iterator < String > keys = json Object . keys ( ) ; while ( keys . has Next ( ) ) { String key = keys . next ( ) ; json Map . put ( key , json Object . get String ( key ) ) ; } } catch ( Gf Json Exception e ) { throw new Illegal Argument Exception ( STRING + json String + STRING ) ; } return json Map ; }
public void destroy ( ) { config = null ; }
Big Integer add ( long val ) { if ( val == NUM ) return this ; if ( signum == NUM ) return value Of ( val ) ; if ( Long . signum ( val ) == signum ) return new Big Integer ( add ( mag , Math . abs ( val ) ) , signum ) ; int cmp = compare Magnitude ( val ) ; if ( cmp == NUM ) return ZERO ; int [ ] result Mag = ( cmp > NUM ? subtract ( mag , Math . abs ( val ) ) : subtract ( Math . abs ( val ) , mag ) ) ; result Mag = trusted Strip Leading Zero Ints ( result Mag ) ; return new Big Integer ( result Mag , cmp == signum ? NUM : - NUM ) ; }
Big Integer add ( long val ) { if ( val == NUM ) return this ; if ( signum == NUM ) return value Of ( val ) ; if ( Long . signum ( val ) == signum ) return new Big Integer ( add ( mag , Math . abs ( val ) ) , signum ) ; int cmp = compare Magnitude ( val ) ; if ( cmp == NUM ) return ZERO ; int [ ] result Mag = ( cmp > NUM ? subtract ( mag , Math . abs ( val ) ) : subtract ( Math . abs ( val ) , mag ) ) ; result Mag = trusted Strip Leading Zero Ints ( result Mag ) ; return new Big Integer ( result Mag , cmp == signum ? NUM : - NUM ) ; }
public Data File create Data File ( ) { Data File data File = new Data File ( ) ; data File List . add ( data File ) ; return data File ; }
public static Executor Service create Background Executor ( ) { final Executor Service executor = Executors . new Single Thread Executor ( new Daemon Thread Factory ( DEFAULT BACKGROUND EXECUTOR NAME ) ) ; BACKGROUND EXECUTORS . add ( executor ) ; return executor ; }
public static Executor Service create Background Executor ( ) { final Executor Service executor = Executors . new Single Thread Executor ( new Daemon Thread Factory ( DEFAULT BACKGROUND EXECUTOR NAME ) ) ; BACKGROUND EXECUTORS . add ( executor ) ; return executor ; }
public static Executor Service create Background Executor ( ) { final Executor Service executor = Executors . new Single Thread Executor ( new Daemon Thread Factory ( DEFAULT BACKGROUND EXECUTOR NAME ) ) ; BACKGROUND EXECUTORS . add ( executor ) ; return executor ; }
public Closure Stats assert All ( final Temp Triple Store temp Store ) { return assert All ( temp Store , null ) ; }
public Closure Stats assert All ( final Temp Triple Store temp Store ) { return assert All ( temp Store , null ) ; }
public Closure Stats assert All ( final Temp Triple Store temp Store ) { return assert All ( temp Store , null ) ; }
public Closure Stats assert All ( final Temp Triple Store temp Store ) { return assert All ( temp Store , null ) ; }
public Closure Stats assert All ( final Temp Triple Store temp Store ) { return assert All ( temp Store , null ) ; }
public Log Cursor Manager ( ) throws Replicator Exception { next Timeout Check = last Timeout Check + timeout Millis ; }
protected Visor Cache init History ( Visor Cache c ) { if ( c != null ) { c . name = name ; c . mode = mode ; c . memory Size = memory Size ; c . indexes Size = indexes Size ; c . size = size ; c . near Size = near Size ; c . dht Size = dht Size ; c . primary Size = primary Size ; c . off Heap Allocated Size = off Heap Allocated Size ; c . off Heap Entries Cnt = off Heap Entries Cnt ; c . swap Size = swap Size ; c . swap Keys = swap Keys ; c . partitions = partitions ; c . primary Partitions = Collections . empty List ( ) ; c . backup Partitions = Collections . empty List ( ) ; c . metrics = metrics ; } return c ; }
public final boolean is Supported ( String feature , String version ) { return implementation . has Feature ( feature , version ) ; }
public final boolean is Supported ( String feature , String version ) { return implementation . has Feature ( feature , version ) ; }
public final boolean is Supported ( String feature , String version ) { return implementation . has Feature ( feature , version ) ; }
public void test Constructor Bytes Positive 1 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
public void test Constructor Bytes Positive 1 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
public void test Constructor Bytes Positive 1 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
public boolean is Open ( ) { if ( secure Channel Id == - NUM ) return BOOL ; long expire Time = ( ( long ) ( token Lifetime * NUM ) ) + token Issue Time ; long current Time = System . current Time Millis ( ) ; return expire Time > current Time ; }
static public Source Position find Source Position ( File java File , int line Number , int column Number ) throws IO Exception { String [ ] lines = new String [ NUM ] ; int current Line Number = NUM ; try ( Buffered Reader br = new Buffered Reader ( new File Reader ( java File ) ) ) { for ( String line ; ( line = br . read Line ( ) ) != null ; ) { lines [ NUM ] = lines [ NUM ] ; lines [ NUM ] = lines [ NUM ] ; lines [ NUM ] = line ; if ( line Number == current Line Number ) { break ; } current Line Number ++ ; } } if ( line Number != current Line Number ) { return null ; } Source Position pos 0 = find Source Position In Comment ( lines [ NUM ] ) ; if ( pos 0 != null ) { return pos 0 ; } Source Position pos 1 = find Source Position In Comment ( lines [ NUM ] ) ; return pos 1 ; }
public void forward Reference ( Trace Local trace ) { if ( cleared ) return ; Clock . stop ( ) ; Trace . trace ( Item . REFERENCES , STRING , System . identity Hash Code ( this ) , semantics , Object Model . get String ( ref ) ) ; Clock . start ( ) ; process Reference ( trace ) ; }
public void forward Reference ( Trace Local trace ) { if ( cleared ) return ; Clock . stop ( ) ; Trace . trace ( Item . REFERENCES , STRING , System . identity Hash Code ( this ) , semantics , Object Model . get String ( ref ) ) ; Clock . start ( ) ; process Reference ( trace ) ; }
public void forward Reference ( Trace Local trace ) { if ( cleared ) return ; Clock . stop ( ) ; Trace . trace ( Item . REFERENCES , STRING , System . identity Hash Code ( this ) , semantics , Object Model . get String ( ref ) ) ; Clock . start ( ) ; process Reference ( trace ) ; }
public void forward Reference ( Trace Local trace ) { if ( cleared ) return ; Clock . stop ( ) ; Trace . trace ( Item . REFERENCES , STRING , System . identity Hash Code ( this ) , semantics , Object Model . get String ( ref ) ) ; Clock . start ( ) ; process Reference ( trace ) ; }
public void forward Reference ( Trace Local trace ) { if ( cleared ) return ; Clock . stop ( ) ; Trace . trace ( Item . REFERENCES , STRING , System . identity Hash Code ( this ) , semantics , Object Model . get String ( ref ) ) ; Clock . start ( ) ; process Reference ( trace ) ; }
public static int parse Time ( String input ) { Scanner scanner = new Scanner ( input . trim ( ) ) ; scanner . use Locale ( Locale . ENGLISH ) ; int time ; if ( input . contains ( STRING ) ) { scanner . use Delimiter ( STRING ) ; if ( ! scanner . has Next Long ( ) ) { return NUM ; } long minutes = scanner . next Long ( ) ; if ( minutes < NUM ) { return NUM ; } if ( ! scanner . has Next Double ( ) ) { return NUM ; } double seconds = scanner . next Double ( ) ; if ( seconds < NUM || seconds >= NUM ) { return NUM ; } time = ( int ) ( NUM * minutes + NUM * seconds ) ; } else { if ( ! scanner . has Next Double ( ) ) { return NUM ; } double seconds = scanner . next Double ( ) ; if ( seconds < NUM ) { return NUM ; } time = ( int ) ( NUM * seconds ) ; } return NUM * ( ( time + NUM ) / NUM ) ; }
public static Result failure ( String message Key , Object ... args ) { return new Result ( Type . FAILURE , Collections . singleton ( new Diag Message ( message Key , args ) ) ) ; }
public static List find Dir Edges In Ring ( Polygonize Directed Edge start DE ) { Polygonize Directed Edge de = start DE ; List edges = new Array List ( ) ; do { edges . add ( de ) ; de = de . get Next ( ) ; Assert . is True ( de != null , STRING ) ; Assert . is True ( de == start DE || ! de . is In Ring ( ) , STRING ) ; } while ( de != start DE ) ; return edges ; }
public static List find Dir Edges In Ring ( Polygonize Directed Edge start DE ) { Polygonize Directed Edge de = start DE ; List edges = new Array List ( ) ; do { edges . add ( de ) ; de = de . get Next ( ) ; Assert . is True ( de != null , STRING ) ; Assert . is True ( de == start DE || ! de . is In Ring ( ) , STRING ) ; } while ( de != start DE ) ; return edges ; }
public static Set < J Component > all Components ( J Component parent ) { Set < J Component > result = new Hash Set < > ( ) ; Deque < J Component > queue = new Linked List < > ( ) ; queue . add ( parent ) ; while ( ! queue . is Empty ( ) ) { J Component c = queue . remove First ( ) ; result . add ( c ) ; for ( Component c0 : c . get Components ( ) ) { if ( c0 instanceof J Component ) { queue . add ( ( J Component ) c0 ) ; } } } result . remove ( parent ) ; return result ; }
public static Set < J Component > all Components ( J Component parent ) { Set < J Component > result = new Hash Set < > ( ) ; Deque < J Component > queue = new Linked List < > ( ) ; queue . add ( parent ) ; while ( ! queue . is Empty ( ) ) { J Component c = queue . remove First ( ) ; result . add ( c ) ; for ( Component c0 : c . get Components ( ) ) { if ( c0 instanceof J Component ) { queue . add ( ( J Component ) c0 ) ; } } } result . remove ( parent ) ; return result ; }
public void add Recognized Properties ( String [ ] property Ids ) { int property Ids Count = property Ids != null ? property Ids . length : NUM ; for ( int i = NUM ; i < property Ids Count ; i ++ ) { String property Id = property Ids [ i ] ; if ( ! f Recognized Properties . contains ( property Id ) ) { f Recognized Properties . add ( property Id ) ; } } }
public void add Recognized Properties ( String [ ] property Ids ) { int property Ids Count = property Ids != null ? property Ids . length : NUM ; for ( int i = NUM ; i < property Ids Count ; i ++ ) { String property Id = property Ids [ i ] ; if ( ! f Recognized Properties . contains ( property Id ) ) { f Recognized Properties . add ( property Id ) ; } } }
public void add Recognized Properties ( String [ ] property Ids ) { int property Ids Count = property Ids != null ? property Ids . length : NUM ; for ( int i = NUM ; i < property Ids Count ; i ++ ) { String property Id = property Ids [ i ] ; if ( ! f Recognized Properties . contains ( property Id ) ) { f Recognized Properties . add ( property Id ) ; } } }
public static String trim Leading Tabs And Spaces ( String line ) { int size = line . length ( ) ; int start = size ; for ( int i = NUM ; i < size ; i ++ ) { char c = line . char At ( i ) ; if ( ! Indent Manipulation . is Indent Char ( c ) ) { start = i ; break ; } } if ( start == NUM ) return line ; else if ( start == size ) return STRING ; else return line . substring ( start ) ; }
public Preceding ( int end ) { super ( NUM , end ) ; }
public Preceding ( int end ) { super ( NUM , end ) ; }
public Preceding ( int end ) { super ( NUM , end ) ; }
public void test Is Parity Adjusted ( ) { try { DES Key Spec . is Parity Adjusted ( null , NUM ) ; fail ( STRING + STRING ) ; } catch ( Null Pointer Exception e ) { fail ( STRING ) ; } catch ( Invalid Key Exception e ) { } byte [ ] key = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; try { DES Key Spec . is Parity Adjusted ( key , NUM ) ; fail ( STRING + STRING ) ; } catch ( Null Pointer Exception e ) { fail ( STRING ) ; } catch ( Invalid Key Exception e ) { } byte [ ] key not pa = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; try { assert False ( STRING , DES Key Spec . is Parity Adjusted ( key not pa , NUM ) ) ; } catch ( Null Pointer Exception e ) { fail ( STRING ) ; } catch ( Invalid Key Exception e ) { fail ( STRING ) ; } byte [ ] key pa = { ( byte ) NUM , ( byte ) NUM , ( byte ) NUM , ( byte ) NUM , ( byte ) NUM , ( byte ) NUM , ( byte ) NUM , ( byte ) NUM } ; try { assert True ( STRING , DES Key Spec . is Parity Adjusted ( key pa , NUM ) ) ; } catch ( Null Pointer Exception e ) { fail ( STRING ) ; } catch ( Invalid Key Exception e ) { fail ( STRING ) ; } }
public void test Is Parity Adjusted ( ) { try { DES Key Spec . is Parity Adjusted ( null , NUM ) ; fail ( STRING + STRING ) ; } catch ( Null Pointer Exception e ) { fail ( STRING ) ; } catch ( Invalid Key Exception e ) { } byte [ ] key = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; try { DES Key Spec . is Parity Adjusted ( key , NUM ) ; fail ( STRING + STRING ) ; } catch ( Null Pointer Exception e ) { fail ( STRING ) ; } catch ( Invalid Key Exception e ) { } byte [ ] key not pa = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; try { assert False ( STRING , DES Key Spec . is Parity Adjusted ( key not pa , NUM ) ) ; } catch ( Null Pointer Exception e ) { fail ( STRING ) ; } catch ( Invalid Key Exception e ) { fail ( STRING ) ; } byte [ ] key pa = { ( byte ) NUM , ( byte ) NUM , ( byte ) NUM , ( byte ) NUM , ( byte ) NUM , ( byte ) NUM , ( byte ) NUM , ( byte ) NUM } ; try { assert True ( STRING , DES Key Spec . is Parity Adjusted ( key pa , NUM ) ) ; } catch ( Null Pointer Exception e ) { fail ( STRING ) ; } catch ( Invalid Key Exception e ) { fail ( STRING ) ; } }
public void test Is Parity Adjusted ( ) { try { DES Key Spec . is Parity Adjusted ( null , NUM ) ; fail ( STRING + STRING ) ; } catch ( Null Pointer Exception e ) { fail ( STRING ) ; } catch ( Invalid Key Exception e ) { } byte [ ] key = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; try { DES Key Spec . is Parity Adjusted ( key , NUM ) ; fail ( STRING + STRING ) ; } catch ( Null Pointer Exception e ) { fail ( STRING ) ; } catch ( Invalid Key Exception e ) { } byte [ ] key not pa = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; try { assert False ( STRING , DES Key Spec . is Parity Adjusted ( key not pa , NUM ) ) ; } catch ( Null Pointer Exception e ) { fail ( STRING ) ; } catch ( Invalid Key Exception e ) { fail ( STRING ) ; } byte [ ] key pa = { ( byte ) NUM , ( byte ) NUM , ( byte ) NUM , ( byte ) NUM , ( byte ) NUM , ( byte ) NUM , ( byte ) NUM , ( byte ) NUM } ; try { assert True ( STRING , DES Key Spec . is Parity Adjusted ( key pa , NUM ) ) ; } catch ( Null Pointer Exception e ) { fail ( STRING ) ; } catch ( Invalid Key Exception e ) { fail ( STRING ) ; } }
public Igfs String Delimiter Record Resolver ( String ... delims ) { super ( to Bytes ( Charset . default Charset ( ) , delims ) ) ; }
protected void Create FD Array ( Offset Item fdarray Ref , Offset Item private Ref , int Font ) { Output List . add Last ( new Marker Item ( fdarray Ref ) ) ; Build Index Header ( NUM , NUM , NUM ) ; Offset Item private Index 1 Ref = new Index Offset Item ( NUM ) ; Output List . add Last ( private Index 1 Ref ) ; Index Base Item private Base = new Index Base Item ( ) ; Output List . add Last ( private Base ) ; int New Size = fonts [ Font ] . private Length ; int Org Subrs Offset Size = Calc Subr Offset Size ( fonts [ Font ] . private Offset , fonts [ Font ] . private Length ) ; if ( Org Subrs Offset Size != NUM ) New Size += NUM - Org Subrs Offset Size ; Output List . add Last ( new Dict Number Item ( New Size ) ) ; Output List . add Last ( private Ref ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( new Index Marker Item ( private Index 1 Ref , private Base ) ) ; }
protected void Create FD Array ( Offset Item fdarray Ref , Offset Item private Ref , int Font ) { Output List . add Last ( new Marker Item ( fdarray Ref ) ) ; Build Index Header ( NUM , NUM , NUM ) ; Offset Item private Index 1 Ref = new Index Offset Item ( NUM ) ; Output List . add Last ( private Index 1 Ref ) ; Index Base Item private Base = new Index Base Item ( ) ; Output List . add Last ( private Base ) ; int New Size = fonts [ Font ] . private Length ; int Org Subrs Offset Size = Calc Subr Offset Size ( fonts [ Font ] . private Offset , fonts [ Font ] . private Length ) ; if ( Org Subrs Offset Size != NUM ) New Size += NUM - Org Subrs Offset Size ; Output List . add Last ( new Dict Number Item ( New Size ) ) ; Output List . add Last ( private Ref ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( new Index Marker Item ( private Index 1 Ref , private Base ) ) ; }
protected void Create FD Array ( Offset Item fdarray Ref , Offset Item private Ref , int Font ) { Output List . add Last ( new Marker Item ( fdarray Ref ) ) ; Build Index Header ( NUM , NUM , NUM ) ; Offset Item private Index 1 Ref = new Index Offset Item ( NUM ) ; Output List . add Last ( private Index 1 Ref ) ; Index Base Item private Base = new Index Base Item ( ) ; Output List . add Last ( private Base ) ; int New Size = fonts [ Font ] . private Length ; int Org Subrs Offset Size = Calc Subr Offset Size ( fonts [ Font ] . private Offset , fonts [ Font ] . private Length ) ; if ( Org Subrs Offset Size != NUM ) New Size += NUM - Org Subrs Offset Size ; Output List . add Last ( new Dict Number Item ( New Size ) ) ; Output List . add Last ( private Ref ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( new Index Marker Item ( private Index 1 Ref , private Base ) ) ; }
protected void Create FD Array ( Offset Item fdarray Ref , Offset Item private Ref , int Font ) { Output List . add Last ( new Marker Item ( fdarray Ref ) ) ; Build Index Header ( NUM , NUM , NUM ) ; Offset Item private Index 1 Ref = new Index Offset Item ( NUM ) ; Output List . add Last ( private Index 1 Ref ) ; Index Base Item private Base = new Index Base Item ( ) ; Output List . add Last ( private Base ) ; int New Size = fonts [ Font ] . private Length ; int Org Subrs Offset Size = Calc Subr Offset Size ( fonts [ Font ] . private Offset , fonts [ Font ] . private Length ) ; if ( Org Subrs Offset Size != NUM ) New Size += NUM - Org Subrs Offset Size ; Output List . add Last ( new Dict Number Item ( New Size ) ) ; Output List . add Last ( private Ref ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( new Index Marker Item ( private Index 1 Ref , private Base ) ) ; }
@ Override public void commit ( ) { if ( write Cache != null ) { synchronized ( this ) { flush Write Cache ( ) ; } } super . commit ( ) ; }
@ Override public void commit ( ) { if ( write Cache != null ) { synchronized ( this ) { flush Write Cache ( ) ; } } super . commit ( ) ; }
@ Override public void commit ( ) { if ( write Cache != null ) { synchronized ( this ) { flush Write Cache ( ) ; } } super . commit ( ) ; }
@ Override public void commit ( ) { if ( write Cache != null ) { synchronized ( this ) { flush Write Cache ( ) ; } } super . commit ( ) ; }
@ Override public void commit ( ) { if ( write Cache != null ) { synchronized ( this ) { flush Write Cache ( ) ; } } super . commit ( ) ; }
@ Override public void commit ( ) { if ( write Cache != null ) { synchronized ( this ) { flush Write Cache ( ) ; } } super . commit ( ) ; }
private static J Free Chart create Chart ( ) { XY Series series 1 = new XY Series ( STRING ) ; series 1 . add ( NUM , NUM ) ; series 1 . add ( NUM , NUM ) ; series 1 . add ( NUM , NUM ) ; XY Dataset dataset = new XY Series Collection ( series 1 ) ; return Chart Factory . create Time Series Chart ( STRING , STRING , STRING , dataset , BOOL , BOOL , BOOL ) ; }
@ Nullable public static < R > R wrap Thread Loader ( Class Loader ldr , Ignite Out Closure < R > c ) { Thread cur Thread = Thread . current Thread ( ) ; Class Loader ctx Ldr = cur Thread . get Context Class Loader ( ) ; try { cur Thread . set Context Class Loader ( ldr ) ; return c . apply ( ) ; } finally { cur Thread . set Context Class Loader ( ctx Ldr ) ; } }
@ Nullable public static < R > R wrap Thread Loader ( Class Loader ldr , Ignite Out Closure < R > c ) { Thread cur Thread = Thread . current Thread ( ) ; Class Loader ctx Ldr = cur Thread . get Context Class Loader ( ) ; try { cur Thread . set Context Class Loader ( ldr ) ; return c . apply ( ) ; } finally { cur Thread . set Context Class Loader ( ctx Ldr ) ; } }
public static IP parse From String ( String ip ) { String regex = STRING ; Pattern pattern = Pattern . compile ( regex ) ; Matcher m = pattern . matcher ( ip ) ; check Argument ( m . find ( ) , STRING , regex ) ; int a = Integer . parse Int ( m . group ( NUM ) ) ; int b = Integer . parse Int ( m . group ( NUM ) ) ; int c = Integer . parse Int ( m . group ( NUM ) ) ; int d = Integer . parse Int ( m . group ( NUM ) ) ; return new IP ( a , b , c , d ) ; }
public static IP parse From String ( String ip ) { String regex = STRING ; Pattern pattern = Pattern . compile ( regex ) ; Matcher m = pattern . matcher ( ip ) ; check Argument ( m . find ( ) , STRING , regex ) ; int a = Integer . parse Int ( m . group ( NUM ) ) ; int b = Integer . parse Int ( m . group ( NUM ) ) ; int c = Integer . parse Int ( m . group ( NUM ) ) ; int d = Integer . parse Int ( m . group ( NUM ) ) ; return new IP ( a , b , c , d ) ; }
public static boolean is Table Exists ( String table Name , SQ Lite Database db ) { boolean exist ; try { exist = Base Utility . contains Ignore Cases ( find All Table Names ( db ) , table Name ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; exist = BOOL ; } return exist ; }
public static boolean is Table Exists ( String table Name , SQ Lite Database db ) { boolean exist ; try { exist = Base Utility . contains Ignore Cases ( find All Table Names ( db ) , table Name ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; exist = BOOL ; } return exist ; }
public static boolean is Table Exists ( String table Name , SQ Lite Database db ) { boolean exist ; try { exist = Base Utility . contains Ignore Cases ( find All Table Names ( db ) , table Name ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; exist = BOOL ; } return exist ; }
static int derive ARGB ( Color color 1 , Color color 2 , float mid Point ) { int r = color 1 . get Red ( ) + Math . round ( ( color 2 . get Red ( ) - color 1 . get Red ( ) ) * mid Point ) ; int g = color 1 . get Green ( ) + Math . round ( ( color 2 . get Green ( ) - color 1 . get Green ( ) ) * mid Point ) ; int b = color 1 . get Blue ( ) + Math . round ( ( color 2 . get Blue ( ) - color 1 . get Blue ( ) ) * mid Point ) ; int a = color 1 . get Alpha ( ) + Math . round ( ( color 2 . get Alpha ( ) - color 1 . get Alpha ( ) ) * mid Point ) ; return ( ( a & NUM ) << NUM ) | ( ( r & NUM ) << NUM ) | ( ( g & NUM ) << NUM ) | ( b & NUM ) ; }
public void insert Record ( int id , byte [ ] record ) throws IO Exception { if ( ! database . is Open ( ) ) throw new Illegal State Exception ( STRING ) ; if ( id < committed Next Row Id ) { throw new Illegal State Exception ( STRING + id + STRING + this ) ; } if ( id != last Transaction Insert Id + NUM ) { throw new Illegal State Exception ( STRING + last Transaction Insert Id + STRING + id ) ; } if ( record . length != record Size ) { throw new Illegal State Exception ( STRING + record . length + STRING + this ) ; } synchronized ( this ) { rw Raf . seek ( HEADER SIZE + record Size * id ) ; rw Raf . write ( record ) ; } last Transaction Insert Id = id ; }
public static void remove Logging Behavior ( Logging Behavior behavior ) { synchronized ( logging Behaviors ) { logging Behaviors . remove ( behavior ) ; } }
public static void remove Logging Behavior ( Logging Behavior behavior ) { synchronized ( logging Behaviors ) { logging Behaviors . remove ( behavior ) ; } }
public void deep Fill ( Mary Node spec Tree ) { tree = spec Tree ; number Of Leaves = NUM ; sort Node ( NUM , tree ) ; }
public void deep Fill ( Mary Node spec Tree ) { tree = spec Tree ; number Of Leaves = NUM ; sort Node ( NUM , tree ) ; }
public void replace Line At ( int pos , String new Lines ) throws Bad Location Exception { Element e = get Paragraph Element ( pos ) ; replace ( e . get Start Offset ( ) , get Element Length ( e ) , new Lines , null ) ; }
public void replace Line At ( int pos , String new Lines ) throws Bad Location Exception { Element e = get Paragraph Element ( pos ) ; replace ( e . get Start Offset ( ) , get Element Length ( e ) , new Lines , null ) ; }
public void replace Line At ( int pos , String new Lines ) throws Bad Location Exception { Element e = get Paragraph Element ( pos ) ; replace ( e . get Start Offset ( ) , get Element Length ( e ) , new Lines , null ) ; }
protected void handle Mesos Failure ( String task Id ) { int attempt = Task Utils . get Attempt For Task Id ( task Id ) ; Base Container container = containers Info . get ( Task Utils . get Container Index For Task Id ( task Id ) ) ; boolean has Attempts Left = attempt < container . retries ; if ( has Attempts Left ) { LOG . warning ( String . format ( STRING , container . name , attempt + NUM ) ) ; String new Task Id = Task Utils . get Task Id ( container . name , attempt + NUM ) ; schedule New Task ( new Task Id ) ; } else { LOG . severe ( STRING + attempt ) ; } }
public boolean contains ( String key ) { return my Properties . contains Key ( key ) ; }
public boolean contains ( String key ) { return my Properties . contains Key ( key ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
@ Override public List < byte [ ] > read ( long start Offset ) throws IO Exception { List < Carbon Dictionary Column Meta Chunk > carbon Dictionary Column Meta Chunks = read Dictionary Metadata File ( ) ; Carbon Dictionary Column Meta Chunk carbon Dictionary Column Meta Chunk = carbon Dictionary Column Meta Chunks . get ( carbon Dictionary Column Meta Chunks . size ( ) - NUM ) ; long end Offset = carbon Dictionary Column Meta Chunk . get End offset ( ) ; return read ( carbon Dictionary Column Meta Chunks , start Offset , end Offset ) ; }
@ Override public List < byte [ ] > read ( long start Offset ) throws IO Exception { List < Carbon Dictionary Column Meta Chunk > carbon Dictionary Column Meta Chunks = read Dictionary Metadata File ( ) ; Carbon Dictionary Column Meta Chunk carbon Dictionary Column Meta Chunk = carbon Dictionary Column Meta Chunks . get ( carbon Dictionary Column Meta Chunks . size ( ) - NUM ) ; long end Offset = carbon Dictionary Column Meta Chunk . get End offset ( ) ; return read ( carbon Dictionary Column Meta Chunks , start Offset , end Offset ) ; }
@ Override public List < byte [ ] > read ( long start Offset ) throws IO Exception { List < Carbon Dictionary Column Meta Chunk > carbon Dictionary Column Meta Chunks = read Dictionary Metadata File ( ) ; Carbon Dictionary Column Meta Chunk carbon Dictionary Column Meta Chunk = carbon Dictionary Column Meta Chunks . get ( carbon Dictionary Column Meta Chunks . size ( ) - NUM ) ; long end Offset = carbon Dictionary Column Meta Chunk . get End offset ( ) ; return read ( carbon Dictionary Column Meta Chunks , start Offset , end Offset ) ; }
@ Override public List < byte [ ] > read ( long start Offset ) throws IO Exception { List < Carbon Dictionary Column Meta Chunk > carbon Dictionary Column Meta Chunks = read Dictionary Metadata File ( ) ; Carbon Dictionary Column Meta Chunk carbon Dictionary Column Meta Chunk = carbon Dictionary Column Meta Chunks . get ( carbon Dictionary Column Meta Chunks . size ( ) - NUM ) ; long end Offset = carbon Dictionary Column Meta Chunk . get End offset ( ) ; return read ( carbon Dictionary Column Meta Chunks , start Offset , end Offset ) ; }
@ Override public List < byte [ ] > read ( long start Offset ) throws IO Exception { List < Carbon Dictionary Column Meta Chunk > carbon Dictionary Column Meta Chunks = read Dictionary Metadata File ( ) ; Carbon Dictionary Column Meta Chunk carbon Dictionary Column Meta Chunk = carbon Dictionary Column Meta Chunks . get ( carbon Dictionary Column Meta Chunks . size ( ) - NUM ) ; long end Offset = carbon Dictionary Column Meta Chunk . get End offset ( ) ; return read ( carbon Dictionary Column Meta Chunks , start Offset , end Offset ) ; }
@ Override public List < byte [ ] > read ( long start Offset ) throws IO Exception { List < Carbon Dictionary Column Meta Chunk > carbon Dictionary Column Meta Chunks = read Dictionary Metadata File ( ) ; Carbon Dictionary Column Meta Chunk carbon Dictionary Column Meta Chunk = carbon Dictionary Column Meta Chunks . get ( carbon Dictionary Column Meta Chunks . size ( ) - NUM ) ; long end Offset = carbon Dictionary Column Meta Chunk . get End offset ( ) ; return read ( carbon Dictionary Column Meta Chunks , start Offset , end Offset ) ; }
public void add Source ( ITLAPM Output Source source ) { ITLAPM Output Source existing Source = ( ITLAPM Output Source ) sources . get ( source . get Full Module Path ( ) ) ; if ( existing Source != null ) { ITLAPM Output Source Listener [ ] existing Listeners = existing Source . get Listeners ( ) ; for ( int i = NUM ; i < existing Listeners . length ; i ++ ) { source . add Listener ( existing Listeners [ i ] ) ; existing Source . remove Listener ( existing Listeners [ i ] ) ; } } else { List list = ( List ) listener Lists . get ( source . get Full Module Path ( ) ) ; if ( list != null ) { for ( Iterator it = list . iterator ( ) ; it . has Next ( ) ; ) { source . add Listener ( ( ITLAPM Output Source Listener ) it . next ( ) ) ; it . remove ( ) ; } } } sources . put ( source . get Full Module Path ( ) , source ) ; }
public void add Source ( ITLAPM Output Source source ) { ITLAPM Output Source existing Source = ( ITLAPM Output Source ) sources . get ( source . get Full Module Path ( ) ) ; if ( existing Source != null ) { ITLAPM Output Source Listener [ ] existing Listeners = existing Source . get Listeners ( ) ; for ( int i = NUM ; i < existing Listeners . length ; i ++ ) { source . add Listener ( existing Listeners [ i ] ) ; existing Source . remove Listener ( existing Listeners [ i ] ) ; } } else { List list = ( List ) listener Lists . get ( source . get Full Module Path ( ) ) ; if ( list != null ) { for ( Iterator it = list . iterator ( ) ; it . has Next ( ) ; ) { source . add Listener ( ( ITLAPM Output Source Listener ) it . next ( ) ) ; it . remove ( ) ; } } } sources . put ( source . get Full Module Path ( ) , source ) ; }
public void add Source ( ITLAPM Output Source source ) { ITLAPM Output Source existing Source = ( ITLAPM Output Source ) sources . get ( source . get Full Module Path ( ) ) ; if ( existing Source != null ) { ITLAPM Output Source Listener [ ] existing Listeners = existing Source . get Listeners ( ) ; for ( int i = NUM ; i < existing Listeners . length ; i ++ ) { source . add Listener ( existing Listeners [ i ] ) ; existing Source . remove Listener ( existing Listeners [ i ] ) ; } } else { List list = ( List ) listener Lists . get ( source . get Full Module Path ( ) ) ; if ( list != null ) { for ( Iterator it = list . iterator ( ) ; it . has Next ( ) ; ) { source . add Listener ( ( ITLAPM Output Source Listener ) it . next ( ) ) ; it . remove ( ) ; } } } sources . put ( source . get Full Module Path ( ) , source ) ; }
public M Security Manager ( ) { privileged Threads = new Copy On Write Array Set < > ( ) ; privileged Threads . add ( Thread . current Thread ( ) ) ; default Manager = System . get Security Manager ( ) ; executing Test Case = BOOL ; privileged Thread To Ignore = null ; unrecognized Permissions = new Copy On Write Array Set < > ( ) ; files To Delete = new Copy On Write Array Set < > ( ) ; }
public M Security Manager ( ) { privileged Threads = new Copy On Write Array Set < > ( ) ; privileged Threads . add ( Thread . current Thread ( ) ) ; default Manager = System . get Security Manager ( ) ; executing Test Case = BOOL ; privileged Thread To Ignore = null ; unrecognized Permissions = new Copy On Write Array Set < > ( ) ; files To Delete = new Copy On Write Array Set < > ( ) ; }
public M Security Manager ( ) { privileged Threads = new Copy On Write Array Set < > ( ) ; privileged Threads . add ( Thread . current Thread ( ) ) ; default Manager = System . get Security Manager ( ) ; executing Test Case = BOOL ; privileged Thread To Ignore = null ; unrecognized Permissions = new Copy On Write Array Set < > ( ) ; files To Delete = new Copy On Write Array Set < > ( ) ; }
protected Graphics create Graphics ( Image Formatter formatter , int width , int height ) { java . awt . Graphics graphics = null ; if ( formatter == null ) { logger . warning ( STRING ) ; return null ; } graphics = formatter . get Graphics ( width , height , get Transparent ( ) ) ; if ( graphics == null ) { logger . warning ( STRING ) ; return null ; } if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING ) ; } if ( do Anti Aliasing && graphics instanceof java . awt . Graphics 2 D ) { java . awt . Graphics 2 D g2 d = ( java . awt . Graphics 2 D ) graphics ; g2 d . set Rendering Hint ( Rendering Hints . KEY TEXT ANTIALIASING , Rendering Hints . VALUE TEXT ANTIALIAS ON ) ; g2 d . set Rendering Hint ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; } return graphics ; }
protected Graphics create Graphics ( Image Formatter formatter , int width , int height ) { java . awt . Graphics graphics = null ; if ( formatter == null ) { logger . warning ( STRING ) ; return null ; } graphics = formatter . get Graphics ( width , height , get Transparent ( ) ) ; if ( graphics == null ) { logger . warning ( STRING ) ; return null ; } if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING ) ; } if ( do Anti Aliasing && graphics instanceof java . awt . Graphics 2 D ) { java . awt . Graphics 2 D g2 d = ( java . awt . Graphics 2 D ) graphics ; g2 d . set Rendering Hint ( Rendering Hints . KEY TEXT ANTIALIASING , Rendering Hints . VALUE TEXT ANTIALIAS ON ) ; g2 d . set Rendering Hint ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; } return graphics ; }
public void remove ( T line ) { int idx = list . index Of ( line ) ; if ( idx != - NUM ) remove ( idx ) ; }
public void remove ( T line ) { int idx = list . index Of ( line ) ; if ( idx != - NUM ) remove ( idx ) ; }
public void remove ( T line ) { int idx = list . index Of ( line ) ; if ( idx != - NUM ) remove ( idx ) ; }
public static Object initialize Scalar Header ( Address ptr , TIB tib , int size ) { Object ref = Magic . address As Object ( ptr . plus ( OBJECT REF OFFSET ) ) ; return ref ; }
public static boolean uses Second Operand ( final Integer mnemonic ) { return ! mnemonic . equals ( Reil Helpers . OPCODE NOP ) && ! mnemonic . equals ( Reil Helpers . OPCODE BISZ ) && ! mnemonic . equals ( Reil Helpers . OPCODE STR ) && ! mnemonic . equals ( Reil Helpers . OPCODE STM ) && ! mnemonic . equals ( Reil Helpers . OPCODE LDM ) && ! mnemonic . equals ( Reil Helpers . OPCODE JCC ) ; }
private void add Exposed Types ( Parameterized Type type , Class < ? > cause ) { boolean already Done = done ( type ) ; if ( ! pruned ( type ) ) { visit ( type ) ; record Exposure ( type , cause ) ; } if ( already Done ) { return ; } logger . debug ( STRING , type . get Raw Type ( ) , type ) ; add Exposed Types ( type . get Raw Type ( ) , cause ) ; for ( Type type Arg : type . get Actual Type Arguments ( ) ) { logger . debug ( STRING , type Arg , type ) ; add Exposed Types ( type Arg , cause ) ; } }
private void add Exposed Types ( Parameterized Type type , Class < ? > cause ) { boolean already Done = done ( type ) ; if ( ! pruned ( type ) ) { visit ( type ) ; record Exposure ( type , cause ) ; } if ( already Done ) { return ; } logger . debug ( STRING , type . get Raw Type ( ) , type ) ; add Exposed Types ( type . get Raw Type ( ) , cause ) ; for ( Type type Arg : type . get Actual Type Arguments ( ) ) { logger . debug ( STRING , type Arg , type ) ; add Exposed Types ( type Arg , cause ) ; } }
private void add Exposed Types ( Parameterized Type type , Class < ? > cause ) { boolean already Done = done ( type ) ; if ( ! pruned ( type ) ) { visit ( type ) ; record Exposure ( type , cause ) ; } if ( already Done ) { return ; } logger . debug ( STRING , type . get Raw Type ( ) , type ) ; add Exposed Types ( type . get Raw Type ( ) , cause ) ; for ( Type type Arg : type . get Actual Type Arguments ( ) ) { logger . debug ( STRING , type Arg , type ) ; add Exposed Types ( type Arg , cause ) ; } }
public void add Process To Reboot ( final String process Name ) { processes To Reboot . add ( process Name ) ; }
public void add Process To Reboot ( final String process Name ) { processes To Reboot . add ( process Name ) ; }
public static Class box Type ( Class primitive Type ) { Class c = ( Class ) wrapper Map . get ( primitive Type ) ; if ( c != null ) return c ; throw new Interpreter Error ( STRING + primitive Type ) ; }
public static void increase Time ( Clock clock ) { Calendar c = Calendar . get Instance ( ) ; c . set Time ( clock . get Current Time ( ) ) ; c . add ( Calendar . SECOND , NUM ) ; clock . set Current Time ( c . get Time ( ) ) ; }
public static void increase Time ( Clock clock ) { Calendar c = Calendar . get Instance ( ) ; c . set Time ( clock . get Current Time ( ) ) ; c . add ( Calendar . SECOND , NUM ) ; clock . set Current Time ( c . get Time ( ) ) ; }
@ Override public boolean has Dispatch Function ( ) { return BOOL ; }
@ Override public boolean has Dispatch Function ( ) { return BOOL ; }
@ Override public boolean has Dispatch Function ( ) { return BOOL ; }
public void delete Obligation ( final Obligation obligation , int basic Block Id ) throws Obligation Acquired Or Released In Loop Exception { Map < Obligation Set , State > updated State Map = new Hash Map < Obligation Set , State > ( ) ; for ( Iterator < State > i = state Iterator ( ) ; i . has Next ( ) ; ) { State state = i . next ( ) ; check Circularity ( state , obligation , basic Block Id ) ; Obligation Set obligation Set = state . get Obligation Set ( ) ; obligation Set . remove ( obligation ) ; if ( ! obligation Set . is Empty ( ) ) { updated State Map . put ( obligation Set , state ) ; } } replace Map ( updated State Map ) ; }
private List < String > find Columns To Remove ( ) { String table Name = m Table Model . get Table Name ( ) ; List < String > remove Columns = new Array List < String > ( ) ; List < Column Model > column Model List = m Table Model DB . get Column Models ( ) ; for ( Column Model column Model : column Model List ) { String db Column Name = column Model . get Column Name ( ) ; if ( is Need To Remove ( db Column Name ) ) { remove Columns . add ( db Column Name ) ; } } Log Util . d ( TAG , STRING + table Name + STRING + remove Columns ) ; return remove Columns ; }
private List < String > find Columns To Remove ( ) { String table Name = m Table Model . get Table Name ( ) ; List < String > remove Columns = new Array List < String > ( ) ; List < Column Model > column Model List = m Table Model DB . get Column Models ( ) ; for ( Column Model column Model : column Model List ) { String db Column Name = column Model . get Column Name ( ) ; if ( is Need To Remove ( db Column Name ) ) { remove Columns . add ( db Column Name ) ; } } Log Util . d ( TAG , STRING + table Name + STRING + remove Columns ) ; return remove Columns ; }
private List < String > find Columns To Remove ( ) { String table Name = m Table Model . get Table Name ( ) ; List < String > remove Columns = new Array List < String > ( ) ; List < Column Model > column Model List = m Table Model DB . get Column Models ( ) ; for ( Column Model column Model : column Model List ) { String db Column Name = column Model . get Column Name ( ) ; if ( is Need To Remove ( db Column Name ) ) { remove Columns . add ( db Column Name ) ; } } Log Util . d ( TAG , STRING + table Name + STRING + remove Columns ) ; return remove Columns ; }
private List < String > find Columns To Remove ( ) { String table Name = m Table Model . get Table Name ( ) ; List < String > remove Columns = new Array List < String > ( ) ; List < Column Model > column Model List = m Table Model DB . get Column Models ( ) ; for ( Column Model column Model : column Model List ) { String db Column Name = column Model . get Column Name ( ) ; if ( is Need To Remove ( db Column Name ) ) { remove Columns . add ( db Column Name ) ; } } Log Util . d ( TAG , STRING + table Name + STRING + remove Columns ) ; return remove Columns ; }
private List < String > find Columns To Remove ( ) { String table Name = m Table Model . get Table Name ( ) ; List < String > remove Columns = new Array List < String > ( ) ; List < Column Model > column Model List = m Table Model DB . get Column Models ( ) ; for ( Column Model column Model : column Model List ) { String db Column Name = column Model . get Column Name ( ) ; if ( is Need To Remove ( db Column Name ) ) { remove Columns . add ( db Column Name ) ; } } Log Util . d ( TAG , STRING + table Name + STRING + remove Columns ) ; return remove Columns ; }
private List < String > find Columns To Remove ( ) { String table Name = m Table Model . get Table Name ( ) ; List < String > remove Columns = new Array List < String > ( ) ; List < Column Model > column Model List = m Table Model DB . get Column Models ( ) ; for ( Column Model column Model : column Model List ) { String db Column Name = column Model . get Column Name ( ) ; if ( is Need To Remove ( db Column Name ) ) { remove Columns . add ( db Column Name ) ; } } Log Util . d ( TAG , STRING + table Name + STRING + remove Columns ) ; return remove Columns ; }
private List < String > find Columns To Remove ( ) { String table Name = m Table Model . get Table Name ( ) ; List < String > remove Columns = new Array List < String > ( ) ; List < Column Model > column Model List = m Table Model DB . get Column Models ( ) ; for ( Column Model column Model : column Model List ) { String db Column Name = column Model . get Column Name ( ) ; if ( is Need To Remove ( db Column Name ) ) { remove Columns . add ( db Column Name ) ; } } Log Util . d ( TAG , STRING + table Name + STRING + remove Columns ) ; return remove Columns ; }
private void handle Incoming Inline Query ( Inline Query inline Query ) { String query = inline Query . get Query ( ) ; Bot Logger . debug ( LOGTAG , STRING + query ) ; try { if ( ! query . is Empty ( ) ) { List < Rae Service . Rae Result > results = rae Service . get Results ( query ) ; answer Inline Query ( converte Results To Response ( inline Query , results ) ) ; } else { answer Inline Query ( converte Results To Response ( inline Query , new Array List < > ( ) ) ) ; } } catch ( Telegram Api Exception e ) { Bot Logger . error ( LOGTAG , e ) ; } }
private Platform Target create Platform Cache ( Ignite Cache Proxy cache ) { return new Platform Cache ( platform Ctx , cache , BOOL , cache Exts ) ; }
public double calculate Weight ( int trooper ) { double weight = NUM ; weight += get Weight Structure ( ) ; weight += get Weight Armor ( ) ; weight += get Weight Misc Equip ( trooper ) ; weight += get Weight Weapon ( trooper ) ; weight += get Weight Ammo ( trooper ) ; return Math . round ( weight * NUM ) / NUM ; }
public double calculate Weight ( int trooper ) { double weight = NUM ; weight += get Weight Structure ( ) ; weight += get Weight Armor ( ) ; weight += get Weight Misc Equip ( trooper ) ; weight += get Weight Weapon ( trooper ) ; weight += get Weight Ammo ( trooper ) ; return Math . round ( weight * NUM ) / NUM ; }
public double calculate Weight ( int trooper ) { double weight = NUM ; weight += get Weight Structure ( ) ; weight += get Weight Armor ( ) ; weight += get Weight Misc Equip ( trooper ) ; weight += get Weight Weapon ( trooper ) ; weight += get Weight Ammo ( trooper ) ; return Math . round ( weight * NUM ) / NUM ; }
public void test session Protection ( ) { final Journal store = ( Journal ) get Store ( ) ; try { final RW Strategy bs = ( RW Strategy ) store . get Buffer Strategy ( ) ; final RW Store rw = bs . get Store ( ) ; final byte [ ] buf = new byte [ NUM ] ; r . next Bytes ( buf ) ; final Byte Buffer bb = Byte Buffer . wrap ( buf ) ; long faddr = bs . write ( bb ) ; I Raw Tx tx = rw . new Tx ( ) ; bs . delete ( faddr ) ; bb . position ( NUM ) ; final Byte Buffer rd Buf = bs . read ( faddr ) ; assert Equals ( bb , rd Buf ) ; tx . close ( ) ; store . commit ( ) ; } finally { store . destroy ( ) ; } }
public void test session Protection ( ) { final Journal store = ( Journal ) get Store ( ) ; try { final RW Strategy bs = ( RW Strategy ) store . get Buffer Strategy ( ) ; final RW Store rw = bs . get Store ( ) ; final byte [ ] buf = new byte [ NUM ] ; r . next Bytes ( buf ) ; final Byte Buffer bb = Byte Buffer . wrap ( buf ) ; long faddr = bs . write ( bb ) ; I Raw Tx tx = rw . new Tx ( ) ; bs . delete ( faddr ) ; bb . position ( NUM ) ; final Byte Buffer rd Buf = bs . read ( faddr ) ; assert Equals ( bb , rd Buf ) ; tx . close ( ) ; store . commit ( ) ; } finally { store . destroy ( ) ; } }
public void test session Protection ( ) { final Journal store = ( Journal ) get Store ( ) ; try { final RW Strategy bs = ( RW Strategy ) store . get Buffer Strategy ( ) ; final RW Store rw = bs . get Store ( ) ; final byte [ ] buf = new byte [ NUM ] ; r . next Bytes ( buf ) ; final Byte Buffer bb = Byte Buffer . wrap ( buf ) ; long faddr = bs . write ( bb ) ; I Raw Tx tx = rw . new Tx ( ) ; bs . delete ( faddr ) ; bb . position ( NUM ) ; final Byte Buffer rd Buf = bs . read ( faddr ) ; assert Equals ( bb , rd Buf ) ; tx . close ( ) ; store . commit ( ) ; } finally { store . destroy ( ) ; } }
public void test session Protection ( ) { final Journal store = ( Journal ) get Store ( ) ; try { final RW Strategy bs = ( RW Strategy ) store . get Buffer Strategy ( ) ; final RW Store rw = bs . get Store ( ) ; final byte [ ] buf = new byte [ NUM ] ; r . next Bytes ( buf ) ; final Byte Buffer bb = Byte Buffer . wrap ( buf ) ; long faddr = bs . write ( bb ) ; I Raw Tx tx = rw . new Tx ( ) ; bs . delete ( faddr ) ; bb . position ( NUM ) ; final Byte Buffer rd Buf = bs . read ( faddr ) ; assert Equals ( bb , rd Buf ) ; tx . close ( ) ; store . commit ( ) ; } finally { store . destroy ( ) ; } }
public void test session Protection ( ) { final Journal store = ( Journal ) get Store ( ) ; try { final RW Strategy bs = ( RW Strategy ) store . get Buffer Strategy ( ) ; final RW Store rw = bs . get Store ( ) ; final byte [ ] buf = new byte [ NUM ] ; r . next Bytes ( buf ) ; final Byte Buffer bb = Byte Buffer . wrap ( buf ) ; long faddr = bs . write ( bb ) ; I Raw Tx tx = rw . new Tx ( ) ; bs . delete ( faddr ) ; bb . position ( NUM ) ; final Byte Buffer rd Buf = bs . read ( faddr ) ; assert Equals ( bb , rd Buf ) ; tx . close ( ) ; store . commit ( ) ; } finally { store . destroy ( ) ; } }
@ Override public synchronized void remove Instance Listener ( Instance Listener dsl ) { m listeners . remove ( dsl ) ; }
public void remove Documents ( List < Query > queries ) { Index Writer writer = get Writer ( ) ; for ( Query query : queries ) { try { writer . delete Documents ( query ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; close Writer ( writer ) ; throw new Runtime Exception ( e ) ; } } close Writer ( writer ) ; }
boolean update Value Type ( Object value ) { if ( value Type Finally Set || value == null ) return value Type Finally Set ; Class < ? > type = value . get Class ( ) ; if ( value Type == null ) { synchronized ( this ) { if ( value Type == null ) value Type = type ; } } else if ( value Type != type && ! value Type . is Assignable From ( type ) ) { synchronized ( this ) { value Type = Type Data Index . get Common Super Type ( type , value Type ) ; } } if ( value Type == Object . class ) value Type Finally Set = BOOL ; return value Type Finally Set ; }
boolean update Value Type ( Object value ) { if ( value Type Finally Set || value == null ) return value Type Finally Set ; Class < ? > type = value . get Class ( ) ; if ( value Type == null ) { synchronized ( this ) { if ( value Type == null ) value Type = type ; } } else if ( value Type != type && ! value Type . is Assignable From ( type ) ) { synchronized ( this ) { value Type = Type Data Index . get Common Super Type ( type , value Type ) ; } } if ( value Type == Object . class ) value Type Finally Set = BOOL ; return value Type Finally Set ; }
protected final void serialize ( Object Output Stream oos , Collection coll ) throws IO Exception { int count = NUM ; Object [ ] objects = coll . to Array ( ) ; for ( int i = NUM ; i < objects . length ; i ++ ) { if ( objects [ i ] instanceof Serializable ) count ++ ; else objects [ i ] = null ; } oos . write Int ( count ) ; for ( int i = NUM ; count > NUM ; i ++ ) { Object o = objects [ i ] ; if ( o != null ) { oos . write Object ( o ) ; count -- ; } } }
protected final void serialize ( Object Output Stream oos , Collection coll ) throws IO Exception { int count = NUM ; Object [ ] objects = coll . to Array ( ) ; for ( int i = NUM ; i < objects . length ; i ++ ) { if ( objects [ i ] instanceof Serializable ) count ++ ; else objects [ i ] = null ; } oos . write Int ( count ) ; for ( int i = NUM ; count > NUM ; i ++ ) { Object o = objects [ i ] ; if ( o != null ) { oos . write Object ( o ) ; count -- ; } } }
protected void subscribe Unsubscribe ( String name Value ) throws Throwable { URI observer Uri = URI . create ( observer Service Uri For Unsubscribe ) ; wait For Subscription To Appear ( observer Uri , EXAMPLES SUBSCRIPTIONS ) ; verify Notification ( name Value , observer Uri ) ; Js Executor . execute Synchronously ( null ) ; wait For Subscription To Disappear ( observer Uri , EXAMPLES SUBSCRIPTIONS ) ; }
protected void subscribe Unsubscribe ( String name Value ) throws Throwable { URI observer Uri = URI . create ( observer Service Uri For Unsubscribe ) ; wait For Subscription To Appear ( observer Uri , EXAMPLES SUBSCRIPTIONS ) ; verify Notification ( name Value , observer Uri ) ; Js Executor . execute Synchronously ( null ) ; wait For Subscription To Disappear ( observer Uri , EXAMPLES SUBSCRIPTIONS ) ; }
protected void subscribe Unsubscribe ( String name Value ) throws Throwable { URI observer Uri = URI . create ( observer Service Uri For Unsubscribe ) ; wait For Subscription To Appear ( observer Uri , EXAMPLES SUBSCRIPTIONS ) ; verify Notification ( name Value , observer Uri ) ; Js Executor . execute Synchronously ( null ) ; wait For Subscription To Disappear ( observer Uri , EXAMPLES SUBSCRIPTIONS ) ; }
private int initial Number ( String tform ) { int i ; for ( i = NUM ; i < tform . length ( ) ; i ++ ) { if ( ! Character . is Digit ( tform . char At ( i ) ) ) { break ; } } return Integer . parse Int ( tform . substring ( NUM , i ) ) ; }
private int initial Number ( String tform ) { int i ; for ( i = NUM ; i < tform . length ( ) ; i ++ ) { if ( ! Character . is Digit ( tform . char At ( i ) ) ) { break ; } } return Integer . parse Int ( tform . substring ( NUM , i ) ) ; }
public Console format ( String format , Object ... args ) { Formatter f = new Formatter ( writer ) ; f . format ( format , args ) ; f . flush ( ) ; return this ; }
public Console format ( String format , Object ... args ) { Formatter f = new Formatter ( writer ) ; f . format ( format , args ) ; f . flush ( ) ; return this ; }
protected final void add Exception Handler ( final I Command Exception Handler handler ) { exception Handler List . add ( NUM , handler ) ; }
protected final void add Exception Handler ( final I Command Exception Handler handler ) { exception Handler List . add ( NUM , handler ) ; }
public static void insert Thrift Rename Table Log Entry ( org . apache . hadoop . hive . metastore . api . Table old Table , org . apache . hadoop . hive . metastore . api . Table new Table , Hive Conf hive Conf ) throws Exception { final Metastore Audit Log Listener metastore Audit Log Listener = new Metastore Audit Log Listener ( hive Conf ) ; Alter Table Event event = new Alter Table Event ( old Table , new Table , BOOL , null ) ; metastore Audit Log Listener . on Alter Table ( event ) ; }
public static void insert Thrift Rename Table Log Entry ( org . apache . hadoop . hive . metastore . api . Table old Table , org . apache . hadoop . hive . metastore . api . Table new Table , Hive Conf hive Conf ) throws Exception { final Metastore Audit Log Listener metastore Audit Log Listener = new Metastore Audit Log Listener ( hive Conf ) ; Alter Table Event event = new Alter Table Event ( old Table , new Table , BOOL , null ) ; metastore Audit Log Listener . on Alter Table ( event ) ; }
public static void insert Thrift Rename Table Log Entry ( org . apache . hadoop . hive . metastore . api . Table old Table , org . apache . hadoop . hive . metastore . api . Table new Table , Hive Conf hive Conf ) throws Exception { final Metastore Audit Log Listener metastore Audit Log Listener = new Metastore Audit Log Listener ( hive Conf ) ; Alter Table Event event = new Alter Table Event ( old Table , new Table , BOOL , null ) ; metastore Audit Log Listener . on Alter Table ( event ) ; }
int generate ( byte [ ] output , boolean prediction Resistant ) { if ( R . length == NUM ) { if ( reseed Counter > BLOCK 64 RESEED MAX ) { return - NUM ; } if ( is Too Large ( output , BLOCK 64 MAX BITS REQUEST / NUM ) ) { throw new Illegal Argument Exception ( STRING + BLOCK 64 MAX BITS REQUEST ) ; } } else { if ( reseed Counter > BLOCK 128 RESEED MAX ) { return - NUM ; } if ( is Too Large ( output , BLOCK 128 MAX BITS REQUEST / NUM ) ) { throw new Illegal Argument Exception ( STRING + BLOCK 128 MAX BITS REQUEST ) ; } } if ( prediction Resistant || V == null ) { V = entropy Source . get Entropy ( ) ; } int m = output . length / R . length ; for ( int i = NUM ; i < m ; i ++ ) { engine . process Block ( DT , NUM , I , NUM ) ; process ( R , I , V ) ; process ( V , R , I ) ; System . arraycopy ( R , NUM , output , i * R . length , R . length ) ; increment ( DT ) ; } int bytes To Copy = ( output . length - m * R . length ) ; if ( bytes To Copy > NUM ) { engine . process Block ( DT , NUM , I , NUM ) ; process ( R , I , V ) ; process ( V , R , I ) ; System . arraycopy ( R , NUM , output , m * R . length , bytes To Copy ) ; increment ( DT ) ; } reseed Counter ++ ; return output . length ; }
public void dispose ( ) { if ( ping Labels Map != null ) { ping Labels Map . clear ( ) ; ping Labels Map = null ; } if ( items Managed != null ) { items Managed . clear ( ) ; items Managed = null ; } if ( folders != null ) { folders = null ; } if ( sashes != null ) { sashes = null ; } }
public Writable Raster create Compatible Writable Raster ( int w , int h ) { int [ ] b Offs = { NUM , NUM , NUM } ; return Raster . create Interleaved Raster ( Data Buffer . TYPE BYTE , w , h , w * NUM , NUM , b Offs , null ) ; }
public Writable Raster create Compatible Writable Raster ( int w , int h ) { int [ ] b Offs = { NUM , NUM , NUM } ; return Raster . create Interleaved Raster ( Data Buffer . TYPE BYTE , w , h , w * NUM , NUM , b Offs , null ) ; }
public char abbreviation ( ) { return name . char At ( NUM ) ; }
public char abbreviation ( ) { return name . char At ( NUM ) ; }
public char abbreviation ( ) { return name . char At ( NUM ) ; }
@ Deprecated public static String join ( String delimiter , String ... parts ) { if ( delimiter == null ) { throw new Illegal Argument Exception ( STRING ) ; } String Builder sb = new String Builder ( ) ; for ( String alias : parts ) { if ( sb . length ( ) != NUM ) { sb . append ( delimiter ) ; } sb . append ( alias ) ; } return sb . to String ( ) ; }
@ Deprecated public static String join ( String delimiter , String ... parts ) { if ( delimiter == null ) { throw new Illegal Argument Exception ( STRING ) ; } String Builder sb = new String Builder ( ) ; for ( String alias : parts ) { if ( sb . length ( ) != NUM ) { sb . append ( delimiter ) ; } sb . append ( alias ) ; } return sb . to String ( ) ; }
@ Deprecated public static String join ( String delimiter , String ... parts ) { if ( delimiter == null ) { throw new Illegal Argument Exception ( STRING ) ; } String Builder sb = new String Builder ( ) ; for ( String alias : parts ) { if ( sb . length ( ) != NUM ) { sb . append ( delimiter ) ; } sb . append ( alias ) ; } return sb . to String ( ) ; }
@ Deprecated public static String join ( String delimiter , String ... parts ) { if ( delimiter == null ) { throw new Illegal Argument Exception ( STRING ) ; } String Builder sb = new String Builder ( ) ; for ( String alias : parts ) { if ( sb . length ( ) != NUM ) { sb . append ( delimiter ) ; } sb . append ( alias ) ; } return sb . to String ( ) ; }
public static final void fill Circle From Start To End ( GL 2 gl , double sx , double sy , double ex , double ey ) { double w = Math . abs ( sx - ex ) ; double h = Math . abs ( sy - ey ) ; Render Utilities . fill Circle From Top Left ( gl , sx , sy , w , h ) ; }
public void add Notification ( @ Not Null Notification notification ) { notifications . add ( notification ) ; Notification Container Item item = new Notification Container Item ( notification , resources ) ; item . set Delegate ( this ) ; int index = n Grid . get Row Count ( ) ; n Grid . resize Rows ( index + NUM ) ; n Grid . set Widget ( index , NUM , item ) ; }
public void add Notification ( @ Not Null Notification notification ) { notifications . add ( notification ) ; Notification Container Item item = new Notification Container Item ( notification , resources ) ; item . set Delegate ( this ) ; int index = n Grid . get Row Count ( ) ; n Grid . resize Rows ( index + NUM ) ; n Grid . set Widget ( index , NUM , item ) ; }
private List < File Match > filter Target Matches Without Source Matches ( List < File Match > source Match Candidates , List < File Match > target Match Candidates ) { List < File Match > filtered Target Match Candidates = new Array List < > ( ) ; List < String > source Filenames = get Source Filenames ( source Match Candidates ) ; for ( File Match target Match Candidate : target Match Candidates ) { if ( source Filenames . contains ( target Match Candidate . get Source Path ( ) ) ) { filtered Target Match Candidates . add ( target Match Candidate ) ; } } return filtered Target Match Candidates ; }
private List < File Match > filter Target Matches Without Source Matches ( List < File Match > source Match Candidates , List < File Match > target Match Candidates ) { List < File Match > filtered Target Match Candidates = new Array List < > ( ) ; List < String > source Filenames = get Source Filenames ( source Match Candidates ) ; for ( File Match target Match Candidate : target Match Candidates ) { if ( source Filenames . contains ( target Match Candidate . get Source Path ( ) ) ) { filtered Target Match Candidates . add ( target Match Candidate ) ; } } return filtered Target Match Candidates ; }
public boolean implies ( Permission < ? > that ) { if ( category == null ) return BOOL ; if ( ! category . is Assignable From ( that . category ) ) return BOOL ; if ( action == null ) return BOOL ; if ( ! action . equals ( that . action ) ) return BOOL ; if ( instance == null ) return BOOL ; if ( ! instance . equals ( that . instance ) ) return BOOL ; return BOOL ; }
private FP Tree build FP Tree ( final Relation < Bit Vector > relation , int [ ] iidx , final int items ) { FP Tree tree = new FP Tree ( items ) ; Finite Progress prog = LOG . is Verbose ( ) ? new Finite Progress ( STRING , relation . size ( ) , LOG ) : null ; int [ ] buf = new int [ items ] ; for ( DBID Iter iditer = relation . iter DBI Ds ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { int l = NUM ; Sparse Feature Vector < ? > bv = relation . get ( iditer ) ; for ( int it = bv . iter ( ) ; bv . iter Valid ( it ) ; it = bv . iter Advance ( it ) ) { int i = iidx [ bv . iter Dim ( it ) ] ; if ( i < NUM ) { continue ; } buf [ l ++ ] = i ; } if ( l >= minlength ) { Arrays . sort ( buf , NUM , l ) ; tree . insert ( buf , NUM , l , NUM ) ; } LOG . increment Processed ( prog ) ; } LOG . ensure Completed ( prog ) ; return tree ; }
private void adjust View ( ) { if ( ( dvx == NUM ) && ( dvy == NUM ) ) { return ; } final int sx = convert World X To Scaled Screen ( x ) - get Screen View X ( ) + SIZE UNIT PIXELS / NUM ; final int sy = convert World Y To Scaled Screen ( y ) - get Screen View Y ( ) + SIZE UNIT PIXELS / NUM ; if ( ( sx < NUM ) || ( sx >= sw ) || ( sy < - SIZE UNIT PIXELS ) || ( sy > sh ) ) { center ( ) ; } else { calculate Panning Speed ( ) ; if ( speed != NUM ) { final int scalediv = ( Math . abs ( dvx ) + Math . abs ( dvy ) ) * PAN SCALE ; int dx = speed * dvx / scalediv ; int dy = speed * dvy / scalediv ; if ( dvx < NUM ) { dx = Math Helper . clamp ( dx , dvx , - NUM ) ; } else if ( dvx > NUM ) { dx = Math Helper . clamp ( dx , NUM , dvx ) ; } if ( dvy < NUM ) { dy = Math Helper . clamp ( dy , dvy , - NUM ) ; } else if ( dvy > NUM ) { dy = Math Helper . clamp ( dy , NUM , dvy ) ; } svx += dx ; dvx -= dx ; svy += dy ; dvy -= dy ; } } }
private void adjust View ( ) { if ( ( dvx == NUM ) && ( dvy == NUM ) ) { return ; } final int sx = convert World X To Scaled Screen ( x ) - get Screen View X ( ) + SIZE UNIT PIXELS / NUM ; final int sy = convert World Y To Scaled Screen ( y ) - get Screen View Y ( ) + SIZE UNIT PIXELS / NUM ; if ( ( sx < NUM ) || ( sx >= sw ) || ( sy < - SIZE UNIT PIXELS ) || ( sy > sh ) ) { center ( ) ; } else { calculate Panning Speed ( ) ; if ( speed != NUM ) { final int scalediv = ( Math . abs ( dvx ) + Math . abs ( dvy ) ) * PAN SCALE ; int dx = speed * dvx / scalediv ; int dy = speed * dvy / scalediv ; if ( dvx < NUM ) { dx = Math Helper . clamp ( dx , dvx , - NUM ) ; } else if ( dvx > NUM ) { dx = Math Helper . clamp ( dx , NUM , dvx ) ; } if ( dvy < NUM ) { dy = Math Helper . clamp ( dy , dvy , - NUM ) ; } else if ( dvy > NUM ) { dy = Math Helper . clamp ( dy , NUM , dvy ) ; } svx += dx ; dvx -= dx ; svy += dy ; dvy -= dy ; } } }
public boolean equals ( Object obj ) { if ( this == obj ) return BOOL ; if ( obj instanceof Elliptic Curve ) { Elliptic Curve curve = ( Elliptic Curve ) obj ; if ( ( field . equals ( curve . field ) ) && ( a . equals ( curve . a ) ) && ( b . equals ( curve . b ) ) ) { return BOOL ; } } return BOOL ; }
public synchronized void unweave ( Byte String id ) { if ( woven . contains Key ( id ) ) { removed . add ( woven . remove ( id ) ) ; } }
public static String read String ( Byte Buffer buffer , int str Len ) { String Builder sb = new String Builder ( str Len ) ; for ( int i = NUM ; i < str Len ; i ++ ) { sb . append ( buffer . get Char ( ) ) ; } return sb . to String ( ) ; }
public void remove ( boolean priority , Marker m ) { lock . lock ( ) ; send Empty Message ( BLANK ) ; if ( priority ) { m On Screen Remove Marker Tasks . add ( m ) ; } else { m Remove Marker Tasks . add ( m ) ; } lock . unlock ( ) ; }
public void remove ( boolean priority , Marker m ) { lock . lock ( ) ; send Empty Message ( BLANK ) ; if ( priority ) { m On Screen Remove Marker Tasks . add ( m ) ; } else { m Remove Marker Tasks . add ( m ) ; } lock . unlock ( ) ; }
public static String [ ] sort Copy ( String [ ] objects ) { int len = objects . length ; String [ ] copy = new String [ len ] ; System . arraycopy ( objects , NUM , copy , NUM , len ) ; sort ( copy ) ; return copy ; }
protected Message create Response Message ( ) { return new Message ( NUM , Version . CURRENT ) ; }
protected Message create Response Message ( ) { return new Message ( NUM , Version . CURRENT ) ; }
protected Message create Response Message ( ) { return new Message ( NUM , Version . CURRENT ) ; }
public static < T > Set < T > synchronized Set ( ) { return Collections . synchronized Set ( new Hash Set < T > ( ) ) ; }
private String Text Store ( String text ) { super ( ) ; f Text = text != null ? text : STRING ; f Copy Limit = f Text . length ( ) > SMALL TEXT LIMIT ? f Text . length ( ) / NUM : NUM ; }
public boolean is Primitive ( Type type ) throws Exception { return is Primitive ( type . get Type ( ) ) ; }
public boolean is Primitive ( Type type ) throws Exception { return is Primitive ( type . get Type ( ) ) ; }
public Random ( byte [ ] random Bytes ) { if ( random Bytes == null ) { throw new Null Pointer Exception ( STRING ) ; } else if ( random Bytes . length != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } else { this . random Bytes = Arrays . copy Of ( random Bytes , random Bytes . length ) ; } }
public byte [ ] encrypt ( byte [ ] data , byte [ ] key , byte [ ] ivec , int usage ) throws Krb Crypto Exception { if ( key . length > NUM ) throw new Krb Crypto Exception ( STRING ) ; int new size = data . length + confounder Size ( ) + checksum Size ( ) ; byte [ ] new data ; byte pad ; if ( new size % block Size ( ) == NUM ) { new data = new byte [ new size + block Size ( ) ] ; pad = ( byte ) NUM ; } else { new data = new byte [ new size + block Size ( ) - new size % block Size ( ) ] ; pad = ( byte ) ( block Size ( ) - new size % block Size ( ) ) ; } for ( int i = new size ; i < new data . length ; i ++ ) { new data [ i ] = pad ; } byte [ ] conf = Confounder . bytes ( confounder Size ( ) ) ; System . arraycopy ( conf , NUM , new data , NUM , confounder Size ( ) ) ; System . arraycopy ( data , NUM , new data , start Of Data ( ) , data . length ) ; byte [ ] cksum = calculate Checksum ( new data , new data . length ) ; System . arraycopy ( cksum , NUM , new data , start Of Checksum ( ) , checksum Size ( ) ) ; byte [ ] cipher = new byte [ new data . length ] ; Des . cbc encrypt ( new data , cipher , key , ivec , BOOL ) ; return cipher ; }
private void update State View ( Metrics metrics ) { Platform . run Later ( null ) ; sim Pane Ctrl . wait After Step ( ) ; }
private void update State View ( Metrics metrics ) { Platform . run Later ( null ) ; sim Pane Ctrl . wait After Step ( ) ; }
public Object create Soft Weak Ref ( Object o ) { return new Weak Reference ( o ) ; }
public Object create Soft Weak Ref ( Object o ) { return new Weak Reference ( o ) ; }
public Object create Soft Weak Ref ( Object o ) { return new Weak Reference ( o ) ; }
public Object create Soft Weak Ref ( Object o ) { return new Weak Reference ( o ) ; }
private Set < Cluster Node > replicated Unstable Data Nodes ( Grid Cache Context < ? , ? > cctx ) { assert cctx . is Replicated ( ) : cctx . name ( ) + STRING ; String space = cctx . name ( ) ; Set < Cluster Node > data Nodes = new Hash Set < > ( data Nodes ( space , NONE ) ) ; if ( data Nodes . is Empty ( ) ) throw new Cache Exception ( STRING + space ) ; for ( int p = NUM , parts = cctx . affinity ( ) . partitions ( ) ; p < parts ; p ++ ) { List < Cluster Node > owners = cctx . topology ( ) . owners ( p ) ; if ( F . is Empty ( owners ) ) return null ; data Nodes . retain All ( owners ) ; if ( data Nodes . is Empty ( ) ) return null ; } return data Nodes ; }
private Set < Cluster Node > replicated Unstable Data Nodes ( Grid Cache Context < ? , ? > cctx ) { assert cctx . is Replicated ( ) : cctx . name ( ) + STRING ; String space = cctx . name ( ) ; Set < Cluster Node > data Nodes = new Hash Set < > ( data Nodes ( space , NONE ) ) ; if ( data Nodes . is Empty ( ) ) throw new Cache Exception ( STRING + space ) ; for ( int p = NUM , parts = cctx . affinity ( ) . partitions ( ) ; p < parts ; p ++ ) { List < Cluster Node > owners = cctx . topology ( ) . owners ( p ) ; if ( F . is Empty ( owners ) ) return null ; data Nodes . retain All ( owners ) ; if ( data Nodes . is Empty ( ) ) return null ; } return data Nodes ; }
protected void header To XML ( ) { Element root ; Element node ; Element child ; int i ; root = m Document . get Document Element ( ) ; root . set Attribute ( ATT NAME , valid Content ( m Instances . relation Name ( ) ) ) ; root . set Attribute ( ATT VERSION , Version . VERSION ) ; node = m Document . create Element ( TAG HEADER ) ; root . append Child ( node ) ; child = m Document . create Element ( TAG ATTRIBUTES ) ; node . append Child ( child ) ; for ( i = NUM ; i < m Instances . num Attributes ( ) ; i ++ ) { add Attribute ( child , m Instances . attribute ( i ) ) ; } }
private static long period End ( long now , long period , Local Date Time cal ) { if ( period < NUM ) return Long . MAX VALUE ; else if ( period == NUM ) return now ; if ( period < NUM * DAY ) { long local Time = cal . to Epoch Second ( Zone Offset . UTC ) * NUM ; local Time = local Time + ( period - ( local Time + NUM * DAY ) % period ) ; return cal . to Epoch Second ( Zone Offset . UTC ) * NUM ; } if ( period % ( NUM * DAY ) == NUM ) { int months = ( int ) ( period / ( NUM * DAY ) ) ; long year = cal . get Year ( ) ; int month = cal . get Month Value ( ) ; cal . with Month ( month + months ) ; cal . with Day Of Month ( NUM ) ; return cal . to Epoch Second ( Zone Offset . UTC ) * NUM ; } if ( period % ( NUM * DAY ) == NUM ) { long years = ( period / ( NUM * DAY ) ) ; long year = cal . get Year ( ) ; long new Year = year + ( years - year % years ) ; cal . with Year ( ( int ) new Year ) ; cal . with Month ( NUM ) ; cal . with Day Of Month ( NUM ) ; return cal . to Epoch Second ( Zone Offset . UTC ) * NUM ; } return cal . to Epoch Second ( Zone Offset . UTC ) * NUM ; }
public Video Streaming Session create Live Video Sharing Session ( Contact Id contact , I Video Player player , long timestamp ) throws Core Exception { if ( s Logger . is Activated ( ) ) { s Logger . info ( STRING ) ; } if ( ! is Call Connected With ( contact ) ) { if ( s Logger . is Activated ( ) ) { s Logger . debug ( STRING ) ; } throw new Core Exception ( STRING ) ; } boolean reject Invitation = BOOL ; if ( is Currently Video Sharing Bi Directional ( ) ) { if ( s Logger . is Activated ( ) ) { s Logger . debug ( STRING ) ; } reject Invitation = BOOL ; } else if ( is Currently Video Sharing Uni Directional ( ) ) { Video Streaming Session current Session = get Unidirectional Video Sharing Session ( ) ; if ( is Session Originating ( current Session ) ) { if ( s Logger . is Activated ( ) ) { s Logger . debug ( STRING ) ; } reject Invitation = BOOL ; } else if ( contact == null || ! contact . equals ( current Session . get Remote Contact ( ) ) ) { if ( s Logger . is Activated ( ) ) { s Logger . debug ( STRING ) ; } reject Invitation = BOOL ; } } if ( reject Invitation ) { if ( s Logger . is Activated ( ) ) { s Logger . debug ( STRING ) ; } throw new Core Exception ( STRING ) ; } return new Originating Video Streaming Session ( this , player , Content Manager . create Generic Live Video Content ( ) , contact , m Rcs Settings , timestamp , m Contact Manager , m Capability Service ) ; }
public Iterator < String > iterate Serializers ( ) { return serializers . iterator ( ) ; }
public void add Person ( Id person ) { boarding At Facility . add ( person ) ; if ( rule . gets Seat On Enter ( person , vehicle , sitting Persons . size ( ) , standing Persons . size ( ) ) ) { add Sitting ( person ) ; } else { add Standing ( person ) ; } }
public void add Person ( Id person ) { boarding At Facility . add ( person ) ; if ( rule . gets Seat On Enter ( person , vehicle , sitting Persons . size ( ) , standing Persons . size ( ) ) ) { add Sitting ( person ) ; } else { add Standing ( person ) ; } }
public void add Person ( Id person ) { boarding At Facility . add ( person ) ; if ( rule . gets Seat On Enter ( person , vehicle , sitting Persons . size ( ) , standing Persons . size ( ) ) ) { add Sitting ( person ) ; } else { add Standing ( person ) ; } }
public void add Person ( Id person ) { boarding At Facility . add ( person ) ; if ( rule . gets Seat On Enter ( person , vehicle , sitting Persons . size ( ) , standing Persons . size ( ) ) ) { add Sitting ( person ) ; } else { add Standing ( person ) ; } }
public void add Person ( Id person ) { boarding At Facility . add ( person ) ; if ( rule . gets Seat On Enter ( person , vehicle , sitting Persons . size ( ) , standing Persons . size ( ) ) ) { add Sitting ( person ) ; } else { add Standing ( person ) ; } }
public void add Person ( Id person ) { boarding At Facility . add ( person ) ; if ( rule . gets Seat On Enter ( person , vehicle , sitting Persons . size ( ) , standing Persons . size ( ) ) ) { add Sitting ( person ) ; } else { add Standing ( person ) ; } }
@ Override public final int hash Code ( ) { long secondhash = Double . double To Long Bits ( second ) ; secondhash = secondhash ^ ( secondhash > > NUM ) ; return ( int ) ( first * NUM + secondhash ) ; }
@ Override public final int hash Code ( ) { long secondhash = Double . double To Long Bits ( second ) ; secondhash = secondhash ^ ( secondhash > > NUM ) ; return ( int ) ( first * NUM + secondhash ) ; }
protected void add Custom Panel ( J Panel custom Panel ) { if ( custom Panel List == null ) { custom Panel List = new Array List < Component > ( ) ; } custom Panel List . add ( custom Panel ) ; }
public Parse ACL ( Parse User owner ) { this ( ) ; set Read Access ( owner , BOOL ) ; set Write Access ( owner , BOOL ) ; }
public Parse ACL ( Parse User owner ) { this ( ) ; set Read Access ( owner , BOOL ) ; set Write Access ( owner , BOOL ) ; }
public static void describe Shape Detail ( Shape shape , double flattening ) { Path Iterator pi 2 = shape . get Path Iterator ( null ) ; Flattening Path Iterator pi = new Flattening Path Iterator ( pi 2 , flattening ) ; double [ ] coords = new double [ NUM ] ; int point Count = NUM ; Debug . output ( STRING + flattening + STRING ) ; while ( ! pi . is Done ( ) ) { int type = pi . current Segment ( coords ) ; Debug . output ( STRING + type + STRING + ( point Count ++ ) + STRING + coords [ NUM ] + STRING + coords [ NUM ] ) ; pi . next ( ) ; } Debug . output ( STRING + point Count + STRING ) ; }
public static void describe Shape Detail ( Shape shape , double flattening ) { Path Iterator pi 2 = shape . get Path Iterator ( null ) ; Flattening Path Iterator pi = new Flattening Path Iterator ( pi 2 , flattening ) ; double [ ] coords = new double [ NUM ] ; int point Count = NUM ; Debug . output ( STRING + flattening + STRING ) ; while ( ! pi . is Done ( ) ) { int type = pi . current Segment ( coords ) ; Debug . output ( STRING + type + STRING + ( point Count ++ ) + STRING + coords [ NUM ] + STRING + coords [ NUM ] ) ; pi . next ( ) ; } Debug . output ( STRING + point Count + STRING ) ; }
public void paint Value ( Graphics g , Rectangle box ) { Color old Color = g . get Color ( ) ; Font old Font = g . get Font ( ) ; g . set Color ( Color . blue ) ; g . set Font ( new Font ( old Font . get Font Name ( ) , Font . BOLD , old Font . get Size ( ) ) ) ; g . draw Rect ( box . x - NUM , box . y + NUM , box . width - NUM , box . height - NUM ) ; g . set Color ( Color . white ) ; g . draw String ( STRING , box . x + NUM , box . y + box . height / NUM + NUM ) ; g . set Font ( old Font ) ; g . set Color ( old Color ) ; }
public void paint Value ( Graphics g , Rectangle box ) { Color old Color = g . get Color ( ) ; Font old Font = g . get Font ( ) ; g . set Color ( Color . blue ) ; g . set Font ( new Font ( old Font . get Font Name ( ) , Font . BOLD , old Font . get Size ( ) ) ) ; g . draw Rect ( box . x - NUM , box . y + NUM , box . width - NUM , box . height - NUM ) ; g . set Color ( Color . white ) ; g . draw String ( STRING , box . x + NUM , box . y + box . height / NUM + NUM ) ; g . set Font ( old Font ) ; g . set Color ( old Color ) ; }
public void paint Value ( Graphics g , Rectangle box ) { Color old Color = g . get Color ( ) ; Font old Font = g . get Font ( ) ; g . set Color ( Color . blue ) ; g . set Font ( new Font ( old Font . get Font Name ( ) , Font . BOLD , old Font . get Size ( ) ) ) ; g . draw Rect ( box . x - NUM , box . y + NUM , box . width - NUM , box . height - NUM ) ; g . set Color ( Color . white ) ; g . draw String ( STRING , box . x + NUM , box . y + box . height / NUM + NUM ) ; g . set Font ( old Font ) ; g . set Color ( old Color ) ; }
private boolean is Canonical Equals ( Client Proxy Membership ID that ) { if ( this == that ) { return BOOL ; } if ( this . unique Id != that . unique Id ) { return BOOL ; } return Arrays . equals ( this . identity , that . identity ) ; }
public void add Adapter ( Recycler View . Adapter adapter ) { add Adapter ( adapters . size ( ) , adapter ) ; }
public static String convert New Lines ( String string ) { int index ; String Buffer new String Buffer = new String Buffer ( ) ; while ( ( index = string . index Of ( STRING ) ) != - NUM ) { if ( index > NUM ) { new String Buffer . append ( string . substring ( NUM , index ) ) ; } new String Buffer . append ( STRING ) ; new String Buffer . append ( STRING ) ; if ( ( index + NUM ) < string . length ( ) ) { string = string . substring ( index + NUM ) ; } else { string = STRING ; } } new String Buffer . append ( string ) ; string = new String Buffer . to String ( ) ; new String Buffer = new String Buffer ( ) ; while ( ( index = string . index Of ( STRING ) ) != - NUM ) { if ( index > NUM ) { new String Buffer . append ( string . substring ( NUM , index ) ) ; } new String Buffer . append ( STRING ) ; new String Buffer . append ( STRING ) ; if ( ( index + NUM ) < string . length ( ) ) { string = string . substring ( index + NUM ) ; } else { string = STRING ; } } new String Buffer . append ( string ) ; return new String Buffer . to String ( ) ; }
public char char At ( int index ) { if ( index < NUM || index >= next Fence Post ) return NUM ; return s . char At ( index ) ; }
private void perform Update Operations ( Context context , Request request , Json Value after Value , Json Value before Value ) throws Resource Exception { final String managed Id = get Managed Object Id ( context ) ; activity Logger . log ( context , request , STRING , get Managed Object Path ( context ) , before Value , after Value , Status . SUCCESS ) ; managed Object Set Service . update ( context , new Update Request ( managed Id , after Value ) , managed Id , null , before Value , after Value , new Hash Set < > ( Arrays . as List ( property Ptr ) ) , new Hash Set < > ( Arrays . as List ( property Ptr ) ) ) ; }
private void perform Update Operations ( Context context , Request request , Json Value after Value , Json Value before Value ) throws Resource Exception { final String managed Id = get Managed Object Id ( context ) ; activity Logger . log ( context , request , STRING , get Managed Object Path ( context ) , before Value , after Value , Status . SUCCESS ) ; managed Object Set Service . update ( context , new Update Request ( managed Id , after Value ) , managed Id , null , before Value , after Value , new Hash Set < > ( Arrays . as List ( property Ptr ) ) , new Hash Set < > ( Arrays . as List ( property Ptr ) ) ) ; }
void restore ( ) { System . arraycopy ( r Save , NUM , r , NUM , block Size ) ; }
void restore ( ) { System . arraycopy ( r Save , NUM , r , NUM , block Size ) ; }
public static String dump ( final Interface Descriptor descriptor ) { return String . format ( STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING , descriptor . b Length ( ) , descriptor . b Descriptor Type ( ) , descriptor . b Interface Number ( ) & NUM , descriptor . b Alternate Setting ( ) & NUM , descriptor . b Num Endpoints ( ) & NUM , descriptor . b Interface Class ( ) & NUM , get USB Class Name ( descriptor . b Interface Class ( ) ) , descriptor . b Interface Sub Class ( ) & NUM , descriptor . b Interface Protocol ( ) & NUM , descriptor . i Interface ( ) & NUM ) ; }
public static String quote ( String s ) { s = s . replace All ( STRING , STRING ) ; return STRING + s + STRING ; }
public static String quote ( String s ) { s = s . replace All ( STRING , STRING ) ; return STRING + s + STRING ; }
private void add Replication Factor ( Operation op ) { op . add Request Header ( Operation . REPLICATION QUORUM HEADER , Operation . REPLICATION QUORUM HEADER VALUE ALL ) ; }
private void add Replication Factor ( Operation op ) { op . add Request Header ( Operation . REPLICATION QUORUM HEADER , Operation . REPLICATION QUORUM HEADER VALUE ALL ) ; }
private void add Replication Factor ( Operation op ) { op . add Request Header ( Operation . REPLICATION QUORUM HEADER , Operation . REPLICATION QUORUM HEADER VALUE ALL ) ; }
private void add Replication Factor ( Operation op ) { op . add Request Header ( Operation . REPLICATION QUORUM HEADER , Operation . REPLICATION QUORUM HEADER VALUE ALL ) ; }
private void add Replication Factor ( Operation op ) { op . add Request Header ( Operation . REPLICATION QUORUM HEADER , Operation . REPLICATION QUORUM HEADER VALUE ALL ) ; }
private void add Replication Factor ( Operation op ) { op . add Request Header ( Operation . REPLICATION QUORUM HEADER , Operation . REPLICATION QUORUM HEADER VALUE ALL ) ; }
private void add Replication Factor ( Operation op ) { op . add Request Header ( Operation . REPLICATION QUORUM HEADER , Operation . REPLICATION QUORUM HEADER VALUE ALL ) ; }
private void add Replication Factor ( Operation op ) { op . add Request Header ( Operation . REPLICATION QUORUM HEADER , Operation . REPLICATION QUORUM HEADER VALUE ALL ) ; }
public static String print Line ( String a , int num ) { String Builder builder = new String Builder ( ) ; for ( int i = NUM ; i < num ; i ++ ) { builder . append ( a ) ; } return builder . to String ( ) ; }
public synchronized void remove Consumer ( Image Consumer ic ) { ics . remove Element ( ic ) ; }
public static Tuple max ( Tuple Set tuples , String field , Comparator cmp ) { if ( tuples instanceof Table ) { Table table = ( Table ) tuples ; Column Metadata md = table . get Metadata ( field ) ; return table . get Tuple ( md . get Maximum Row ( ) ) ; } else { return max ( tuples . tuples ( ) , field , cmp ) ; } }
public static void add Startup Listener ( Start Up Listener s ) { s startup Listeners . add ( s ) ; }
public static void add Startup Listener ( Start Up Listener s ) { s startup Listeners . add ( s ) ; }
private Message List View render Conversation ( Conversation Info conv Info , View parent ) { Message List View list = new Message List View ( parent . get Context ( ) ) ; conv Info . view = list ; list . set On Item Click Listener ( Message Click Listener . get Instance ( ) ) ; Message List Adapter adapter = conv Info . adapter ; if ( adapter == null ) { adapter = new Message List Adapter ( conv Info . conv , parent . get Context ( ) ) ; conv Info . adapter = adapter ; } list . set Adapter ( adapter ) ; list . set Selection ( adapter . get Count ( ) - NUM ) ; return list ; }
private Message List View render Conversation ( Conversation Info conv Info , View parent ) { Message List View list = new Message List View ( parent . get Context ( ) ) ; conv Info . view = list ; list . set On Item Click Listener ( Message Click Listener . get Instance ( ) ) ; Message List Adapter adapter = conv Info . adapter ; if ( adapter == null ) { adapter = new Message List Adapter ( conv Info . conv , parent . get Context ( ) ) ; conv Info . adapter = adapter ; } list . set Adapter ( adapter ) ; list . set Selection ( adapter . get Count ( ) - NUM ) ; return list ; }
public void end Element ( String uri , String local Name , String q Name ) throws SAX Exception { if ( ! ( html Mode && ( uri . equals ( STRING ) || uri . equals ( STRING ) ) && ( q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) ) ) ) { write ( STRING ) ; write Name ( uri , local Name , q Name , BOOL ) ; write ( STRING ) ; } if ( element Level == NUM ) { write ( STRING ) ; } cdata Element = BOOL ; super . end Element ( uri , local Name , q Name ) ; ns Support . pop Context ( ) ; element Level -- ; }
public void end Element ( String uri , String local Name , String q Name ) throws SAX Exception { if ( ! ( html Mode && ( uri . equals ( STRING ) || uri . equals ( STRING ) ) && ( q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) ) ) ) { write ( STRING ) ; write Name ( uri , local Name , q Name , BOOL ) ; write ( STRING ) ; } if ( element Level == NUM ) { write ( STRING ) ; } cdata Element = BOOL ; super . end Element ( uri , local Name , q Name ) ; ns Support . pop Context ( ) ; element Level -- ; }
public void end Element ( String uri , String local Name , String q Name ) throws SAX Exception { if ( ! ( html Mode && ( uri . equals ( STRING ) || uri . equals ( STRING ) ) && ( q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) ) ) ) { write ( STRING ) ; write Name ( uri , local Name , q Name , BOOL ) ; write ( STRING ) ; } if ( element Level == NUM ) { write ( STRING ) ; } cdata Element = BOOL ; super . end Element ( uri , local Name , q Name ) ; ns Support . pop Context ( ) ; element Level -- ; }
public void end Element ( String uri , String local Name , String q Name ) throws SAX Exception { if ( ! ( html Mode && ( uri . equals ( STRING ) || uri . equals ( STRING ) ) && ( q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) ) ) ) { write ( STRING ) ; write Name ( uri , local Name , q Name , BOOL ) ; write ( STRING ) ; } if ( element Level == NUM ) { write ( STRING ) ; } cdata Element = BOOL ; super . end Element ( uri , local Name , q Name ) ; ns Support . pop Context ( ) ; element Level -- ; }
@ Override public void close ( ) throws XML Stream Exception { log . log ( Level . FINE , STRING ) ; stream . close ( ) ; }
@ Override public void close ( ) throws XML Stream Exception { log . log ( Level . FINE , STRING ) ; stream . close ( ) ; }
public void disconnect ( final Bluetooth Device device ) { final Ble Manager < Ble Manager Callbacks > manager = m Ble Managers . get ( device ) ; if ( manager != null && manager . is Connected ( ) ) { manager . disconnect ( ) ; } m Managed Devices . remove ( device ) ; }
public void disconnect ( final Bluetooth Device device ) { final Ble Manager < Ble Manager Callbacks > manager = m Ble Managers . get ( device ) ; if ( manager != null && manager . is Connected ( ) ) { manager . disconnect ( ) ; } m Managed Devices . remove ( device ) ; }
public void disconnect ( final Bluetooth Device device ) { final Ble Manager < Ble Manager Callbacks > manager = m Ble Managers . get ( device ) ; if ( manager != null && manager . is Connected ( ) ) { manager . disconnect ( ) ; } m Managed Devices . remove ( device ) ; }
public void disconnect ( final Bluetooth Device device ) { final Ble Manager < Ble Manager Callbacks > manager = m Ble Managers . get ( device ) ; if ( manager != null && manager . is Connected ( ) ) { manager . disconnect ( ) ; } m Managed Devices . remove ( device ) ; }
public void disconnect ( final Bluetooth Device device ) { final Ble Manager < Ble Manager Callbacks > manager = m Ble Managers . get ( device ) ; if ( manager != null && manager . is Connected ( ) ) { manager . disconnect ( ) ; } m Managed Devices . remove ( device ) ; }
public int tpgid ( ) { return Integer . parse Int ( fields [ NUM ] ) ; }
public int tpgid ( ) { return Integer . parse Int ( fields [ NUM ] ) ; }
public static void deinitialize ( ) { INSTANCE . codename One Running = BOOL ; synchronized ( lock ) { lock . notify All ( ) ; } }
public static void deinitialize ( ) { INSTANCE . codename One Running = BOOL ; synchronized ( lock ) { lock . notify All ( ) ; } }
public static void deinitialize ( ) { INSTANCE . codename One Running = BOOL ; synchronized ( lock ) { lock . notify All ( ) ; } }
public static void deinitialize ( ) { INSTANCE . codename One Running = BOOL ; synchronized ( lock ) { lock . notify All ( ) ; } }
public static void deinitialize ( ) { INSTANCE . codename One Running = BOOL ; synchronized ( lock ) { lock . notify All ( ) ; } }
public static void deinitialize ( ) { INSTANCE . codename One Running = BOOL ; synchronized ( lock ) { lock . notify All ( ) ; } }
public static void deinitialize ( ) { INSTANCE . codename One Running = BOOL ; synchronized ( lock ) { lock . notify All ( ) ; } }
@ Visible For Testing protected Process start Executor Process ( int container ) { return Shell Utils . run A Sync Process ( get Executor Command ( container ) , new File ( Local Context . working Directory ( config ) ) , Integer . to String ( container ) ) ; }
public static Time Zone parse XS Time Zone ( String time Zone Str ) throws Date Parse Exception { Matcher m = PATTERN XS TIME ZONE . matcher ( time Zone Str ) ; if ( ! m . matches ( ) ) { throw new Date Parse Exception ( STRING + PATTERN XS TIME ZONE ) ; } return parse Matching Time Zone ( time Zone Str , null ) ; }
public Delegating Resource Loader ( Map < String , Resource Loader > loaders , File cache Directory ) { this . loaders = Collection Utils . is Empty ( loaders ) ? Collections . < String , Resource Loader > empty Map ( ) : Collections . unmodifiable Map ( loaders ) ; this . cache Directory = init Cache Directory ( cache Directory ) ; }
public static String remove Extra Spaces ( String text ) { text = text . replace ( Chinese Language Constants . SPACE [ NUM ] , Chinese Language Constants . SPACE [ NUM ] ) ; text = text . replace All ( STRING , STRING ) ; text = text . replace All ( STRING , STRING ) ; return text ; }
public static String remove Extra Spaces ( String text ) { text = text . replace ( Chinese Language Constants . SPACE [ NUM ] , Chinese Language Constants . SPACE [ NUM ] ) ; text = text . replace All ( STRING , STRING ) ; text = text . replace All ( STRING , STRING ) ; return text ; }
public static String remove Extra Spaces ( String text ) { text = text . replace ( Chinese Language Constants . SPACE [ NUM ] , Chinese Language Constants . SPACE [ NUM ] ) ; text = text . replace All ( STRING , STRING ) ; text = text . replace All ( STRING , STRING ) ; return text ; }
byte [ ] encrypt Content Encryption Key ( byte [ ] content Encryption Key , Public Key public Key ) throws Encrypt Data Exception { try { Cipher rsa Cipher = Cipher . get Instance ( RSA ALGORITHM MODE ) ; rsa Cipher . init ( Cipher . ENCRYPT MODE , public Key ) ; byte [ ] encrypted Data = rsa Cipher . do Final ( content Encryption Key ) ; return encrypted Data ; } catch ( Exception e ) { throw new Encrypt Data Exception ( STRING , e ) ; } }
byte [ ] encrypt Content Encryption Key ( byte [ ] content Encryption Key , Public Key public Key ) throws Encrypt Data Exception { try { Cipher rsa Cipher = Cipher . get Instance ( RSA ALGORITHM MODE ) ; rsa Cipher . init ( Cipher . ENCRYPT MODE , public Key ) ; byte [ ] encrypted Data = rsa Cipher . do Final ( content Encryption Key ) ; return encrypted Data ; } catch ( Exception e ) { throw new Encrypt Data Exception ( STRING , e ) ; } }
byte [ ] encrypt Content Encryption Key ( byte [ ] content Encryption Key , Public Key public Key ) throws Encrypt Data Exception { try { Cipher rsa Cipher = Cipher . get Instance ( RSA ALGORITHM MODE ) ; rsa Cipher . init ( Cipher . ENCRYPT MODE , public Key ) ; byte [ ] encrypted Data = rsa Cipher . do Final ( content Encryption Key ) ; return encrypted Data ; } catch ( Exception e ) { throw new Encrypt Data Exception ( STRING , e ) ; } }
byte [ ] encrypt Content Encryption Key ( byte [ ] content Encryption Key , Public Key public Key ) throws Encrypt Data Exception { try { Cipher rsa Cipher = Cipher . get Instance ( RSA ALGORITHM MODE ) ; rsa Cipher . init ( Cipher . ENCRYPT MODE , public Key ) ; byte [ ] encrypted Data = rsa Cipher . do Final ( content Encryption Key ) ; return encrypted Data ; } catch ( Exception e ) { throw new Encrypt Data Exception ( STRING , e ) ; } }
public void add Arc ( String s Parent , Array List < Integer > nodes ) throws Exception { int n Parent = get Node ( s Parent ) ; if ( m b Needs Undo Action ) { add Undo Action ( new Add Arc Action ( n Parent , nodes ) ) ; } boolean b Needs Undo Action = m b Needs Undo Action ; m b Needs Undo Action = BOOL ; for ( int i Node = NUM ; i Node < nodes . size ( ) ; i Node ++ ) { int n Node = nodes . get ( i Node ) ; add Arc ( n Parent , n Node ) ; } m b Needs Undo Action = b Needs Undo Action ; }
public void add Arc ( String s Parent , Array List < Integer > nodes ) throws Exception { int n Parent = get Node ( s Parent ) ; if ( m b Needs Undo Action ) { add Undo Action ( new Add Arc Action ( n Parent , nodes ) ) ; } boolean b Needs Undo Action = m b Needs Undo Action ; m b Needs Undo Action = BOOL ; for ( int i Node = NUM ; i Node < nodes . size ( ) ; i Node ++ ) { int n Node = nodes . get ( i Node ) ; add Arc ( n Parent , n Node ) ; } m b Needs Undo Action = b Needs Undo Action ; }
public static int num Decodings ( String s ) { if ( s == null || s . length ( ) == NUM ) { return NUM ; } int len = s . length ( ) ; int [ ] ways = new int [ len + NUM ] ; ways [ NUM ] = NUM ; ways [ NUM ] = s . char At ( NUM ) == STRING ? NUM : NUM ; for ( int i = NUM ; i <= len ; i ++ ) { int code 1 = Integer . value Of ( s . substring ( i - NUM , i ) ) ; int code 2 = Integer . value Of ( s . substring ( i - NUM , i ) ) ; ways [ i ] = ( code 1 != NUM ? ways [ i - NUM ] : NUM ) + ( code 2 <= NUM && code 2 > NUM ? ways [ i - NUM ] : NUM ) ; } return ways [ len ] ; }
public static int num Decodings ( String s ) { if ( s == null || s . length ( ) == NUM ) { return NUM ; } int len = s . length ( ) ; int [ ] ways = new int [ len + NUM ] ; ways [ NUM ] = NUM ; ways [ NUM ] = s . char At ( NUM ) == STRING ? NUM : NUM ; for ( int i = NUM ; i <= len ; i ++ ) { int code 1 = Integer . value Of ( s . substring ( i - NUM , i ) ) ; int code 2 = Integer . value Of ( s . substring ( i - NUM , i ) ) ; ways [ i ] = ( code 1 != NUM ? ways [ i - NUM ] : NUM ) + ( code 2 <= NUM && code 2 > NUM ? ways [ i - NUM ] : NUM ) ; } return ways [ len ] ; }
public static int num Decodings ( String s ) { if ( s == null || s . length ( ) == NUM ) { return NUM ; } int len = s . length ( ) ; int [ ] ways = new int [ len + NUM ] ; ways [ NUM ] = NUM ; ways [ NUM ] = s . char At ( NUM ) == STRING ? NUM : NUM ; for ( int i = NUM ; i <= len ; i ++ ) { int code 1 = Integer . value Of ( s . substring ( i - NUM , i ) ) ; int code 2 = Integer . value Of ( s . substring ( i - NUM , i ) ) ; ways [ i ] = ( code 1 != NUM ? ways [ i - NUM ] : NUM ) + ( code 2 <= NUM && code 2 > NUM ? ways [ i - NUM ] : NUM ) ; } return ways [ len ] ; }
public static int num Decodings ( String s ) { if ( s == null || s . length ( ) == NUM ) { return NUM ; } int len = s . length ( ) ; int [ ] ways = new int [ len + NUM ] ; ways [ NUM ] = NUM ; ways [ NUM ] = s . char At ( NUM ) == STRING ? NUM : NUM ; for ( int i = NUM ; i <= len ; i ++ ) { int code 1 = Integer . value Of ( s . substring ( i - NUM , i ) ) ; int code 2 = Integer . value Of ( s . substring ( i - NUM , i ) ) ; ways [ i ] = ( code 1 != NUM ? ways [ i - NUM ] : NUM ) + ( code 2 <= NUM && code 2 > NUM ? ways [ i - NUM ] : NUM ) ; } return ways [ len ] ; }
public static String extract Classname ( String fullname ) { return fullname . replace First ( STRING , STRING ) ; }
public static String extract Classname ( String fullname ) { return fullname . replace First ( STRING , STRING ) ; }
public static int find Method In Reminder List ( Array List < Integer > values , int method ) { int index = values . index Of ( method ) ; if ( index == - NUM ) { index = NUM ; } return index ; }
public static int find Method In Reminder List ( Array List < Integer > values , int method ) { int index = values . index Of ( method ) ; if ( index == - NUM ) { index = NUM ; } return index ; }
public static int find Method In Reminder List ( Array List < Integer > values , int method ) { int index = values . index Of ( method ) ; if ( index == - NUM ) { index = NUM ; } return index ; }
public static int find Method In Reminder List ( Array List < Integer > values , int method ) { int index = values . index Of ( method ) ; if ( index == - NUM ) { index = NUM ; } return index ; }
public static int find Method In Reminder List ( Array List < Integer > values , int method ) { int index = values . index Of ( method ) ; if ( index == - NUM ) { index = NUM ; } return index ; }
public static int find Method In Reminder List ( Array List < Integer > values , int method ) { int index = values . index Of ( method ) ; if ( index == - NUM ) { index = NUM ; } return index ; }
public static int find Method In Reminder List ( Array List < Integer > values , int method ) { int index = values . index Of ( method ) ; if ( index == - NUM ) { index = NUM ; } return index ; }
public static int find Method In Reminder List ( Array List < Integer > values , int method ) { int index = values . index Of ( method ) ; if ( index == - NUM ) { index = NUM ; } return index ; }
public static Date calculate Gregorian Date ( double jd ) { int l = ( int ) jd + NUM ; int n = ( NUM * l ) / NUM ; l = l - ( NUM * n + NUM ) / NUM ; int i = ( NUM * ( l + NUM ) ) / NUM ; l = l - ( NUM * i ) / NUM + NUM ; int j = ( NUM * l ) / NUM ; int d = l - ( NUM * j ) / NUM ; l = j / NUM ; int m = j + NUM - NUM * l ; int y = NUM * ( n - NUM ) + i + l ; double fraction = jd - Math . floor ( jd ) ; double d Hours = fraction * NUM ; int hours = ( int ) d Hours ; double d Minutes = ( d Hours - hours ) * NUM ; int minutes = ( int ) d Minutes ; int seconds = ( int ) ( ( d Minutes - minutes ) * NUM ) ; Calendar cal = Calendar . get Instance ( Time Zone . get Time Zone ( STRING ) ) ; cal . set ( y , m - NUM , d , hours + NUM , minutes , seconds ) ; return cal . get Time ( ) ; }
public static Date calculate Gregorian Date ( double jd ) { int l = ( int ) jd + NUM ; int n = ( NUM * l ) / NUM ; l = l - ( NUM * n + NUM ) / NUM ; int i = ( NUM * ( l + NUM ) ) / NUM ; l = l - ( NUM * i ) / NUM + NUM ; int j = ( NUM * l ) / NUM ; int d = l - ( NUM * j ) / NUM ; l = j / NUM ; int m = j + NUM - NUM * l ; int y = NUM * ( n - NUM ) + i + l ; double fraction = jd - Math . floor ( jd ) ; double d Hours = fraction * NUM ; int hours = ( int ) d Hours ; double d Minutes = ( d Hours - hours ) * NUM ; int minutes = ( int ) d Minutes ; int seconds = ( int ) ( ( d Minutes - minutes ) * NUM ) ; Calendar cal = Calendar . get Instance ( Time Zone . get Time Zone ( STRING ) ) ; cal . set ( y , m - NUM , d , hours + NUM , minutes , seconds ) ; return cal . get Time ( ) ; }
public static Date calculate Gregorian Date ( double jd ) { int l = ( int ) jd + NUM ; int n = ( NUM * l ) / NUM ; l = l - ( NUM * n + NUM ) / NUM ; int i = ( NUM * ( l + NUM ) ) / NUM ; l = l - ( NUM * i ) / NUM + NUM ; int j = ( NUM * l ) / NUM ; int d = l - ( NUM * j ) / NUM ; l = j / NUM ; int m = j + NUM - NUM * l ; int y = NUM * ( n - NUM ) + i + l ; double fraction = jd - Math . floor ( jd ) ; double d Hours = fraction * NUM ; int hours = ( int ) d Hours ; double d Minutes = ( d Hours - hours ) * NUM ; int minutes = ( int ) d Minutes ; int seconds = ( int ) ( ( d Minutes - minutes ) * NUM ) ; Calendar cal = Calendar . get Instance ( Time Zone . get Time Zone ( STRING ) ) ; cal . set ( y , m - NUM , d , hours + NUM , minutes , seconds ) ; return cal . get Time ( ) ; }
public void commit Random ( final Randomizer rand ) { rand . set Pdf ( pdf ) ; if ( pdf == Prob Distribution . NULL ) { return ; } double param 1 = Utils . double Parsable ( tf Param 1 ) ; if ( tf Param 1 . is Enabled ( ) && ! Double . is Na N ( param 1 ) ) { rand . set Param 1 Consistent ( pdf . get Param 1 Name ( ) , param 1 ) ; } double param 2 = Utils . double Parsable ( tf Param 2 ) ; if ( tf Param 2 . is Enabled ( ) && ! Double . is Na N ( param 2 ) ) { rand . set Param 2 Consistent ( pdf . get Param 2 Name ( ) , param 2 ) ; } if ( ! ts Clipping . is Null ( ) ) { rand . set Clipping ( ts Clipping . is Selected ( ) ) ; if ( ts Clipping . is Selected ( ) ) { double upper Bound = Utils . double Parsable ( tf Up Bound ) ; if ( ! Double . is Na N ( upper Bound ) ) { rand . set Upper Bound ( upper Bound ) ; } double lower Bound = Utils . double Parsable ( tf Low Bound ) ; if ( ! Double . is Na N ( lower Bound ) ) { rand . set Lower Bound ( lower Bound ) ; } } } }
public void remove Whitelist URL ( String URL ) { service Whitelist . remove ( URL ) ; }
@ Override public void post Put All Send ( Distributed Put All Operation put All Op , Versioned Object List successful Puts ) { if ( put All Op . put All Data Size > NUM ) { put All Op . distribute ( ) ; } else { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING ) ; } } }
public Server Config XML ( String xml ) throws Exception { Document doc = XML Utils . get XML Document ( new Byte Array Input Stream ( xml . get Bytes ( STRING ) ) ) ; Node root = XML Utils . get Root Node ( doc , DS Config Mgr . ROOT ) ; default Server Group = new Server Group ( XML Utils . get Named Child Node ( root , DS Config Mgr . SERVERGROUP , DS Config Mgr . NAME , DS Config Mgr . DEFAULT ) ) ; sms Server Group = new Server Group ( XML Utils . get Named Child Node ( root , DS Config Mgr . SERVERGROUP , DS Config Mgr . NAME , STRING ) ) ; }
public Server Config XML ( String xml ) throws Exception { Document doc = XML Utils . get XML Document ( new Byte Array Input Stream ( xml . get Bytes ( STRING ) ) ) ; Node root = XML Utils . get Root Node ( doc , DS Config Mgr . ROOT ) ; default Server Group = new Server Group ( XML Utils . get Named Child Node ( root , DS Config Mgr . SERVERGROUP , DS Config Mgr . NAME , DS Config Mgr . DEFAULT ) ) ; sms Server Group = new Server Group ( XML Utils . get Named Child Node ( root , DS Config Mgr . SERVERGROUP , DS Config Mgr . NAME , STRING ) ) ; }
public void hide Column ( Object column Name ) { if ( column Name == null ) { return ; } for ( int i = NUM ; i < column Model . get Column Count ( ) ; i ++ ) { Table Column column = column Model . get Column ( i ) ; if ( column Name . equals ( column . get Header Value ( ) ) ) { hide Column ( column ) ; break ; } } }
private void update ( ) { data Control . set First Row ( NUM ) ; data Control . set Last Row ( Math . min ( data Control . get Max Rows ( ) , get Default Maximum Number ( STRING , data Control . get Max Rows ( ) ) ) ) ; data Control . set First Column ( NUM ) ; data Control . set Last Column ( Math . min ( data Control . get Max Columns ( ) , get Default Maximum Number ( STRING , data Control . get Max Columns ( ) ) ) ) ; data Control . update ( ) ; }
private void update ( ) { data Control . set First Row ( NUM ) ; data Control . set Last Row ( Math . min ( data Control . get Max Rows ( ) , get Default Maximum Number ( STRING , data Control . get Max Rows ( ) ) ) ) ; data Control . set First Column ( NUM ) ; data Control . set Last Column ( Math . min ( data Control . get Max Columns ( ) , get Default Maximum Number ( STRING , data Control . get Max Columns ( ) ) ) ) ; data Control . update ( ) ; }
private void update ( ) { data Control . set First Row ( NUM ) ; data Control . set Last Row ( Math . min ( data Control . get Max Rows ( ) , get Default Maximum Number ( STRING , data Control . get Max Rows ( ) ) ) ) ; data Control . set First Column ( NUM ) ; data Control . set Last Column ( Math . min ( data Control . get Max Columns ( ) , get Default Maximum Number ( STRING , data Control . get Max Columns ( ) ) ) ) ; data Control . update ( ) ; }
protected void do Get Data ( Http Servlet Request request , Http Servlet Response response ) throws Servlet Exception , IO Exception { Properties properties = null ; try { properties = build Properties ( request . get Path Info ( ) , KEY DEVICE ID , KEY DEVICE TYPE ID , KEY MESSAGE TYPE ID , KEY LIMIT ) ; } catch ( Illegal Argument Exception e ) { print Error ( response , e . get Message ( ) ) ; return ; } try { String table Name = properties . get Property ( KEY TABLE NAME ) ; if ( ! is Table Exists ( table Name ) ) { print Error ( response , STRING + table Name + STRING + properties . get Property ( KEY MESSAGE TYPE ID ) + STRING ) ; return ; } } catch ( SQL Exception e ) { print Error ( response , e . get Message ( ) ) ; return ; } String table Data = null ; try { table Data = select Table Data ( properties ) ; } catch ( SQL Exception e ) { print Error ( response , e . get Message ( ) ) ; return ; } print Json ( response , table Data ) ; }
public Augmented Dickey Fuller ( double [ ] ts ) { this . ts = ts ; this . lag = ( int ) Math . floor ( Math . cbrt ( ( ts . length - NUM ) ) ) ; compute ADF Statistics ( ) ; }
public Augmented Dickey Fuller ( double [ ] ts ) { this . ts = ts ; this . lag = ( int ) Math . floor ( Math . cbrt ( ( ts . length - NUM ) ) ) ; compute ADF Statistics ( ) ; }
protected String Builder process Line ( String next Element ) { String Builder sb = new String Builder ( INITIAL STRING SIZE ) ; for ( int j = NUM ; j < next Element . length ( ) ; j ++ ) { char next Char = next Element . char At ( j ) ; process Character ( sb , next Char ) ; } return sb ; }
protected String Builder process Line ( String next Element ) { String Builder sb = new String Builder ( INITIAL STRING SIZE ) ; for ( int j = NUM ; j < next Element . length ( ) ; j ++ ) { char next Char = next Element . char At ( j ) ; process Character ( sb , next Char ) ; } return sb ; }
public static boolean is Newer ( long ts 1 , long size 1 , long ts 2 , long size 2 ) { return ts 1 > ts 2 || ( ts 1 == ts 2 && size 1 < size 2 ) ; }
public static boolean is Newer ( long ts 1 , long size 1 , long ts 2 , long size 2 ) { return ts 1 > ts 2 || ( ts 1 == ts 2 && size 1 < size 2 ) ; }
public static boolean is Newer ( long ts 1 , long size 1 , long ts 2 , long size 2 ) { return ts 1 > ts 2 || ( ts 1 == ts 2 && size 1 < size 2 ) ; }
public static boolean is Newer ( long ts 1 , long size 1 , long ts 2 , long size 2 ) { return ts 1 > ts 2 || ( ts 1 == ts 2 && size 1 < size 2 ) ; }
public static boolean is Newer ( long ts 1 , long size 1 , long ts 2 , long size 2 ) { return ts 1 > ts 2 || ( ts 1 == ts 2 && size 1 < size 2 ) ; }
public static boolean is Newer ( long ts 1 , long size 1 , long ts 2 , long size 2 ) { return ts 1 > ts 2 || ( ts 1 == ts 2 && size 1 < size 2 ) ; }
public static boolean is Newer ( long ts 1 , long size 1 , long ts 2 , long size 2 ) { return ts 1 > ts 2 || ( ts 1 == ts 2 && size 1 < size 2 ) ; }
public static boolean is Newer ( long ts 1 , long size 1 , long ts 2 , long size 2 ) { return ts 1 > ts 2 || ( ts 1 == ts 2 && size 1 < size 2 ) ; }
public static boolean is Newer ( long ts 1 , long size 1 , long ts 2 , long size 2 ) { return ts 1 > ts 2 || ( ts 1 == ts 2 && size 1 < size 2 ) ; }
public static boolean is Newer ( long ts 1 , long size 1 , long ts 2 , long size 2 ) { return ts 1 > ts 2 || ( ts 1 == ts 2 && size 1 < size 2 ) ; }
public static boolean is Newer ( long ts 1 , long size 1 , long ts 2 , long size 2 ) { return ts 1 > ts 2 || ( ts 1 == ts 2 && size 1 < size 2 ) ; }
public static boolean is Newer ( long ts 1 , long size 1 , long ts 2 , long size 2 ) { return ts 1 > ts 2 || ( ts 1 == ts 2 && size 1 < size 2 ) ; }
public static boolean is Newer ( long ts 1 , long size 1 , long ts 2 , long size 2 ) { return ts 1 > ts 2 || ( ts 1 == ts 2 && size 1 < size 2 ) ; }
public static boolean is Newer ( long ts 1 , long size 1 , long ts 2 , long size 2 ) { return ts 1 > ts 2 || ( ts 1 == ts 2 && size 1 < size 2 ) ; }
public static boolean is Newer ( long ts 1 , long size 1 , long ts 2 , long size 2 ) { return ts 1 > ts 2 || ( ts 1 == ts 2 && size 1 < size 2 ) ; }
public static boolean is Newer ( long ts 1 , long size 1 , long ts 2 , long size 2 ) { return ts 1 > ts 2 || ( ts 1 == ts 2 && size 1 < size 2 ) ; }
private static void delete Directory On Exit ( File directory ) throws IO Exception { if ( ! directory . exists ( ) ) { return ; } directory . delete On Exit ( ) ; if ( ! is Symlink ( directory ) ) { clean Directory On Exit ( directory ) ; } }
private static void delete Directory On Exit ( File directory ) throws IO Exception { if ( ! directory . exists ( ) ) { return ; } directory . delete On Exit ( ) ; if ( ! is Symlink ( directory ) ) { clean Directory On Exit ( directory ) ; } }
public void add Unmanaged Source Volume To Update ( Un Managed Volume volume ) { if ( null == unmanaged Source Volumes To Update ) { unmanaged Source Volumes To Update = new Array List < Un Managed Volume > ( ) ; } unmanaged Source Volumes To Update . add ( volume ) ; }
final protected < T > T create ( Class < T > type , Inject Context env ) throws Config Exception { try { T value = type . new Instance ( ) ; inject ( value , env ) ; return value ; } catch ( Runtime Exception e ) { throw e ; } catch ( Exception e ) { throw Config Exception . wrap ( e ) ; } }
public Array ( final Array array ) { this ( array , Enum Set . none Of ( Address . Flags . class ) ) ; }
public static String join ( String separator , List < ? > elements ) { if ( elements == null || elements . size ( ) == NUM ) { return STRING ; } String Builder sb = new String Builder ( elements . size ( ) * NUM ) ; int i = NUM ; for ( Object elem : elements ) { if ( separator . length ( ) > NUM && i ++ > NUM ) { sb . append ( separator ) ; } sb . append ( format ( elem ) ) ; } return sb . to String ( ) ; }
public static String join ( String separator , List < ? > elements ) { if ( elements == null || elements . size ( ) == NUM ) { return STRING ; } String Builder sb = new String Builder ( elements . size ( ) * NUM ) ; int i = NUM ; for ( Object elem : elements ) { if ( separator . length ( ) > NUM && i ++ > NUM ) { sb . append ( separator ) ; } sb . append ( format ( elem ) ) ; } return sb . to String ( ) ; }
private void reserve One Doc ( ) { if ( pending Num Docs . increment And Get ( ) > Index Writer . get Actual Max Docs ( ) ) { pending Num Docs . decrement And Get ( ) ; throw new Illegal Argument Exception ( STRING + Index Writer . get Actual Max Docs ( ) ) ; } }
private void reserve One Doc ( ) { if ( pending Num Docs . increment And Get ( ) > Index Writer . get Actual Max Docs ( ) ) { pending Num Docs . decrement And Get ( ) ; throw new Illegal Argument Exception ( STRING + Index Writer . get Actual Max Docs ( ) ) ; } }
private void reserve One Doc ( ) { if ( pending Num Docs . increment And Get ( ) > Index Writer . get Actual Max Docs ( ) ) { pending Num Docs . decrement And Get ( ) ; throw new Illegal Argument Exception ( STRING + Index Writer . get Actual Max Docs ( ) ) ; } }
private void reserve One Doc ( ) { if ( pending Num Docs . increment And Get ( ) > Index Writer . get Actual Max Docs ( ) ) { pending Num Docs . decrement And Get ( ) ; throw new Illegal Argument Exception ( STRING + Index Writer . get Actual Max Docs ( ) ) ; } }
public void write ( char [ ] cbuf , int off , int len ) throws IO Exception { internal Out . write ( cbuf , off , len ) ; }
@ Override default Completable Future < Optional Long > min Long ( final To Long Function < ? super T > fn ) { return Completable Future . supply Async ( null , get Exec ( ) ) ; }
public void send No Msg To Target With Token ( Object token , Object target ) { send To Target Or Type ( target . get Class ( ) , token ) ; }
public void send No Msg To Target With Token ( Object token , Object target ) { send To Target Or Type ( target . get Class ( ) , token ) ; }
public void init Channel ( ) throws Carbon Data Writer Exception { init File Count ( ) ; if ( this . is In Progress Extrequired ) { this . file Name = Message Format . format ( this . file Name Format , this . file Count ) + Carbon Common Constants . FILE INPROGRESS STATUS ; File Data file Data = new File Data ( this . file Name , this . store Location ) ; file Manager . add ( file Data ) ; } else { this . file Name = Message Format . format ( this . file Name Format , this . file Count ) ; } this . file Count ++ ; try { this . file Data Out Stream = File Factory . get Data Output Stream ( this . file Name , File Factory . get File Type ( this . file Name ) , ( short ) NUM ) ; } catch ( File Not Found Exception file Not Found Exception ) { throw new Carbon Data Writer Exception ( STRING , file Not Found Exception ) ; } catch ( IO Exception e ) { throw new Carbon Data Writer Exception ( STRING , e ) ; } }
public synchronized void update N String ( String column Name , String x ) throws SQL Exception { update N String ( find Column ( column Name ) , x ) ; }
public synchronized void update N String ( String column Name , String x ) throws SQL Exception { update N String ( find Column ( column Name ) , x ) ; }
public synchronized void update N String ( String column Name , String x ) throws SQL Exception { update N String ( find Column ( column Name ) , x ) ; }
public synchronized void update N String ( String column Name , String x ) throws SQL Exception { update N String ( find Column ( column Name ) , x ) ; }
public synchronized void update N String ( String column Name , String x ) throws SQL Exception { update N String ( find Column ( column Name ) , x ) ; }
public synchronized void update N String ( String column Name , String x ) throws SQL Exception { update N String ( find Column ( column Name ) , x ) ; }
public synchronized void update N String ( String column Name , String x ) throws SQL Exception { update N String ( find Column ( column Name ) , x ) ; }
public double migration Event Proposal Density ( int x , int y , double t , double [ ] m ) { if ( x == y ) { return Math . exp ( - t * m [ NUM - x ] ) ; } else { return Math . exp ( - t * m [ NUM - x ] ) * m [ NUM - x ] ; } }
public double migration Event Proposal Density ( int x , int y , double t , double [ ] m ) { if ( x == y ) { return Math . exp ( - t * m [ NUM - x ] ) ; } else { return Math . exp ( - t * m [ NUM - x ] ) * m [ NUM - x ] ; } }
public static < C extends Configuration Client , S extends Configuration > Create Sub Command Handler < C , S > create ( Sub Command Argument Parser parser , Managed Object Path < ? , ? > p , Optional Relation Definition < C , S > r ) throws Argument Exception { return new Create Sub Command Handler < > ( parser , p , r , null , p . child ( r ) ) ; }
public void add Listener ( Failover Tts Listener listener ) { m Listeners . add ( listener ) ; }
private Concurrent Buffered Update ( final Network network ) { this . network = network ; current Available Processors = get Available Consumer Processors ( ) ; executors = Executors . new Fixed Thread Pool ( current Available Processors ) ; for ( Neuron n : network . get Flat Neuron List ( ) ) { neurons . add ( n ) ; } for ( Neuron Group ng : network . get Flat Neuron Group List ( ) ) { neurons . add All ( ng . get Neuron List ( ) ) ; } task Set = new Cyclic Task Queue ( neurons , current Available Processors ) ; }
private Concurrent Buffered Update ( final Network network ) { this . network = network ; current Available Processors = get Available Consumer Processors ( ) ; executors = Executors . new Fixed Thread Pool ( current Available Processors ) ; for ( Neuron n : network . get Flat Neuron List ( ) ) { neurons . add ( n ) ; } for ( Neuron Group ng : network . get Flat Neuron Group List ( ) ) { neurons . add All ( ng . get Neuron List ( ) ) ; } task Set = new Cyclic Task Queue ( neurons , current Available Processors ) ; }
public void add On Complete Call ( Runnable r ) { if ( post == null ) { post = new Array List < Runnable > ( ) ; } post . add ( r ) ; }
public static final String remove Data Folder Path ( String full Path ) { File sd Card = Environment . get External Storage Directory ( ) ; String data Folder Path = sd Card . get Absolute Path ( ) + STRING + Main App . get Data Folder ( ) + STRING ; if ( full Path . index Of ( data Folder Path ) == NUM ) { return full Path . substring ( data Folder Path . length ( ) ) ; } return full Path ; }
public static final String remove Data Folder Path ( String full Path ) { File sd Card = Environment . get External Storage Directory ( ) ; String data Folder Path = sd Card . get Absolute Path ( ) + STRING + Main App . get Data Folder ( ) + STRING ; if ( full Path . index Of ( data Folder Path ) == NUM ) { return full Path . substring ( data Folder Path . length ( ) ) ; } return full Path ; }
public static final String remove Data Folder Path ( String full Path ) { File sd Card = Environment . get External Storage Directory ( ) ; String data Folder Path = sd Card . get Absolute Path ( ) + STRING + Main App . get Data Folder ( ) + STRING ; if ( full Path . index Of ( data Folder Path ) == NUM ) { return full Path . substring ( data Folder Path . length ( ) ) ; } return full Path ; }
public static final String remove Data Folder Path ( String full Path ) { File sd Card = Environment . get External Storage Directory ( ) ; String data Folder Path = sd Card . get Absolute Path ( ) + STRING + Main App . get Data Folder ( ) + STRING ; if ( full Path . index Of ( data Folder Path ) == NUM ) { return full Path . substring ( data Folder Path . length ( ) ) ; } return full Path ; }
public static final String remove Data Folder Path ( String full Path ) { File sd Card = Environment . get External Storage Directory ( ) ; String data Folder Path = sd Card . get Absolute Path ( ) + STRING + Main App . get Data Folder ( ) + STRING ; if ( full Path . index Of ( data Folder Path ) == NUM ) { return full Path . substring ( data Folder Path . length ( ) ) ; } return full Path ; }
public static final String remove Data Folder Path ( String full Path ) { File sd Card = Environment . get External Storage Directory ( ) ; String data Folder Path = sd Card . get Absolute Path ( ) + STRING + Main App . get Data Folder ( ) + STRING ; if ( full Path . index Of ( data Folder Path ) == NUM ) { return full Path . substring ( data Folder Path . length ( ) ) ; } return full Path ; }
public Thread Pool ( String name , int pool Size ) { this . pool Size = pool Size ; this . pool Name = name ; task List = new Linked List < Runnable > ( ) ; threads = new Worker Thread [ pool Size ] ; create Threads ( ) ; }
public static String Playback Runtime From Milliseconds ( long milliseconds ) { long hours = NUM ; long minutes = NUM ; long seconds = NUM ; if ( milliseconds >= ( NUM * NUM * NUM ) ) { hours = milliseconds / ( NUM * NUM * NUM ) ; } if ( milliseconds >= ( NUM * NUM ) ) { minutes = ( milliseconds % ( NUM * NUM * NUM ) ) / ( NUM * NUM ) ; } if ( milliseconds >= NUM ) { seconds = ( ( milliseconds % ( NUM * NUM * NUM ) ) % ( NUM * NUM ) ) / NUM ; } String runtime = STRING ; if ( hours > NUM ) { runtime = String . value Of ( hours ) + STRING ; } if ( minutes > NUM ) { if ( minutes < NUM && hours > NUM ) { runtime += STRING ; } runtime += String . value Of ( minutes ) + STRING ; } else { if ( hours > NUM ) { runtime += STRING ; } } if ( seconds > NUM ) { if ( seconds < NUM ) { runtime += STRING ; } runtime += String . value Of ( seconds ) ; if ( hours < NUM && minutes < NUM ) { runtime = STRING + runtime ; } } else { if ( hours < NUM && minutes < NUM ) { runtime += STRING ; } else { runtime += STRING ; } } return runtime ; }
public static J Class Loader Wrapper create ( Class Loader loader ) { J Class Loader Wrapper j Loader = local Class Loader . get Level ( loader ) ; if ( j Loader == null ) { j Loader = new J Class Loader Wrapper ( loader ) ; local Class Loader . set ( j Loader , loader ) ; } return j Loader ; }
public void remove ( int size ) throws Cache Exception { for ( int i = NUM ; i < size ; i ++ ) { remove ( ) ; } if ( logger . is Trace Enabled ( ) ) { logger . trace ( STRING , this , size ) ; } }
public void remove ( int size ) throws Cache Exception { for ( int i = NUM ; i < size ; i ++ ) { remove ( ) ; } if ( logger . is Trace Enabled ( ) ) { logger . trace ( STRING , this , size ) ; } }
@ Override public void uninitialize ( ) { remove Our U Is ( ) ; reset Default Borders ( ) ; J Frame . set Default Look And Feel Decorated ( BOOL ) ; super . uninitialize ( ) ; }
private String dive ( int depth , int iteration ) { String str 0 ; String str 1 ; String str 2 ; String str 3 ; String str 4 ; String str 5 ; String str 6 ; String str 7 ; String fun Str ; fun Str = STRING ; switch ( iteration % NUM ) { case NUM : fun Str = str 0 = make String ( iteration ) ; break ; case NUM : fun Str = str 1 = make String ( iteration ) ; break ; case NUM : fun Str = str 2 = make String ( iteration ) ; break ; case NUM : fun Str = str 3 = make String ( iteration ) ; break ; case NUM : fun Str = str 4 = make String ( iteration ) ; break ; case NUM : fun Str = str 5 = make String ( iteration ) ; break ; case NUM : fun Str = str 6 = make String ( iteration ) ; break ; case NUM : fun Str = str 7 = make String ( iteration ) ; break ; } strong [ depth ] = fun Str ; weak [ depth ] = new Weak Reference ( fun Str ) ; if ( depth + NUM < MAX DEPTH ) dive ( depth + NUM , iteration + NUM ) ; else Main . sleep ( NUM ) ; return fun Str ; }
private String dive ( int depth , int iteration ) { String str 0 ; String str 1 ; String str 2 ; String str 3 ; String str 4 ; String str 5 ; String str 6 ; String str 7 ; String fun Str ; fun Str = STRING ; switch ( iteration % NUM ) { case NUM : fun Str = str 0 = make String ( iteration ) ; break ; case NUM : fun Str = str 1 = make String ( iteration ) ; break ; case NUM : fun Str = str 2 = make String ( iteration ) ; break ; case NUM : fun Str = str 3 = make String ( iteration ) ; break ; case NUM : fun Str = str 4 = make String ( iteration ) ; break ; case NUM : fun Str = str 5 = make String ( iteration ) ; break ; case NUM : fun Str = str 6 = make String ( iteration ) ; break ; case NUM : fun Str = str 7 = make String ( iteration ) ; break ; } strong [ depth ] = fun Str ; weak [ depth ] = new Weak Reference ( fun Str ) ; if ( depth + NUM < MAX DEPTH ) dive ( depth + NUM , iteration + NUM ) ; else Main . sleep ( NUM ) ; return fun Str ; }
private String dive ( int depth , int iteration ) { String str 0 ; String str 1 ; String str 2 ; String str 3 ; String str 4 ; String str 5 ; String str 6 ; String str 7 ; String fun Str ; fun Str = STRING ; switch ( iteration % NUM ) { case NUM : fun Str = str 0 = make String ( iteration ) ; break ; case NUM : fun Str = str 1 = make String ( iteration ) ; break ; case NUM : fun Str = str 2 = make String ( iteration ) ; break ; case NUM : fun Str = str 3 = make String ( iteration ) ; break ; case NUM : fun Str = str 4 = make String ( iteration ) ; break ; case NUM : fun Str = str 5 = make String ( iteration ) ; break ; case NUM : fun Str = str 6 = make String ( iteration ) ; break ; case NUM : fun Str = str 7 = make String ( iteration ) ; break ; } strong [ depth ] = fun Str ; weak [ depth ] = new Weak Reference ( fun Str ) ; if ( depth + NUM < MAX DEPTH ) dive ( depth + NUM , iteration + NUM ) ; else Main . sleep ( NUM ) ; return fun Str ; }
private String dive ( int depth , int iteration ) { String str 0 ; String str 1 ; String str 2 ; String str 3 ; String str 4 ; String str 5 ; String str 6 ; String str 7 ; String fun Str ; fun Str = STRING ; switch ( iteration % NUM ) { case NUM : fun Str = str 0 = make String ( iteration ) ; break ; case NUM : fun Str = str 1 = make String ( iteration ) ; break ; case NUM : fun Str = str 2 = make String ( iteration ) ; break ; case NUM : fun Str = str 3 = make String ( iteration ) ; break ; case NUM : fun Str = str 4 = make String ( iteration ) ; break ; case NUM : fun Str = str 5 = make String ( iteration ) ; break ; case NUM : fun Str = str 6 = make String ( iteration ) ; break ; case NUM : fun Str = str 7 = make String ( iteration ) ; break ; } strong [ depth ] = fun Str ; weak [ depth ] = new Weak Reference ( fun Str ) ; if ( depth + NUM < MAX DEPTH ) dive ( depth + NUM , iteration + NUM ) ; else Main . sleep ( NUM ) ; return fun Str ; }
public void clear ( ) { m Strings . clear ( ) ; notify Data Set Changed ( ) ; }
private boolean execute ( ) { final String tag = STRING + taskid + STRING ; try { if ( cancelled ) { LOG . finer ( tag + STRING ) ; return BOOL ; } if ( ! notify State Change ( RUNNING , STRING ) ) { LOG . finer ( tag + STRING ) ; return BOOL ; } scan All Directories ( ) ; } catch ( Exception x ) { if ( LOG . is Loggable ( Level . FINEST ) ) { LOG . log ( Level . FINEST , tag + STRING + x , x ) ; } else if ( LOG . is Loggable ( Level . FINE ) ) { LOG . fine ( tag + STRING + x ) ; } } return BOOL ; }
private boolean execute ( ) { final String tag = STRING + taskid + STRING ; try { if ( cancelled ) { LOG . finer ( tag + STRING ) ; return BOOL ; } if ( ! notify State Change ( RUNNING , STRING ) ) { LOG . finer ( tag + STRING ) ; return BOOL ; } scan All Directories ( ) ; } catch ( Exception x ) { if ( LOG . is Loggable ( Level . FINEST ) ) { LOG . log ( Level . FINEST , tag + STRING + x , x ) ; } else if ( LOG . is Loggable ( Level . FINE ) ) { LOG . fine ( tag + STRING + x ) ; } } return BOOL ; }
void checkin Command ( Command command ) { pool . add ( command ) ; }
void checkin Command ( Command command ) { pool . add ( command ) ; }
public Json Array add ( Json Value value ) { if ( value == null ) { throw new Null Pointer Exception ( STRING ) ; } values . add ( value ) ; return this ; }
private void show Selected Nodes ( ) { final Set < Navi Node > selected Nodes = m graph . get Selected Nodes ( ) ; final List < Navi Node > all Nodes = Graph Helpers . get Nodes ( m graph ) ; all Nodes . remove All ( selected Nodes ) ; show Nodes ( selected Nodes , all Nodes ) ; }
private void add To Favorites ( ) { for ( String game : list . get Selected Values List ( ) ) { favorites . add ( game ) ; } save Favorites ( ) ; update ( ) ; }
private void add To Favorites ( ) { for ( String game : list . get Selected Values List ( ) ) { favorites . add ( game ) ; } save Favorites ( ) ; update ( ) ; }
private void fling ( int velocity Y ) { if ( get Child Count ( ) > NUM ) { int scroll Range = get Scroll Range ( ) ; float top Amount = get Current Over Scroll Amount ( BOOL ) ; float bottom Amount = get Current Over Scroll Amount ( BOOL ) ; if ( velocity Y < NUM && top Amount > NUM ) { m Own Scroll Y -= ( int ) top Amount ; m Dont Report Next Over Scroll = BOOL ; set Over Scroll Amount ( NUM , BOOL , BOOL ) ; m Max Over Scroll = Math . abs ( velocity Y ) / NUM * get Rubber Band Factor ( BOOL ) * m Overfling Distance + top Amount ; } else if ( velocity Y > NUM && bottom Amount > NUM ) { m Own Scroll Y += bottom Amount ; set Over Scroll Amount ( NUM , BOOL , BOOL ) ; m Max Over Scroll = Math . abs ( velocity Y ) / NUM * get Rubber Band Factor ( BOOL ) * m Overfling Distance + bottom Amount ; } else { m Max Over Scroll = NUM ; } m Scroller . fling ( get Scroll X ( ) , m Own Scroll Y , NUM , velocity Y , NUM , NUM , NUM , Math . max ( NUM , scroll Range ) , NUM , Integer . MAX VALUE / NUM ) ; post Invalidate On Animation ( ) ; } }
public static synchronized void refresh ( ) throws Krb Exception { singleton = new Config ( ) ; Kdc Comm . init Static ( ) ; E Type . init Static ( ) ; Checksum . init Static ( ) ; }
public static synchronized void refresh ( ) throws Krb Exception { singleton = new Config ( ) ; Kdc Comm . init Static ( ) ; E Type . init Static ( ) ; Checksum . init Static ( ) ; }
public static synchronized void refresh ( ) throws Krb Exception { singleton = new Config ( ) ; Kdc Comm . init Static ( ) ; E Type . init Static ( ) ; Checksum . init Static ( ) ; }
public static synchronized void refresh ( ) throws Krb Exception { singleton = new Config ( ) ; Kdc Comm . init Static ( ) ; E Type . init Static ( ) ; Checksum . init Static ( ) ; }
public static synchronized void refresh ( ) throws Krb Exception { singleton = new Config ( ) ; Kdc Comm . init Static ( ) ; E Type . init Static ( ) ; Checksum . init Static ( ) ; }
public boolean add All Unique ( List < Album > ps ) { boolean did Change = BOOL ; synchronized ( m Albums ) { for ( Album p : ps ) { if ( ! m Albums . contains ( p ) && p . is Loaded ( ) ) { m Albums . add ( p ) ; did Change = BOOL ; } } if ( did Change ) { sort List Locked ( ) ; } } return did Change ; }
public final J Menu Item add Item ( J Menu menu , String key , String label , int mnemonic ) { J Menu Item item = new J Menu Item ( label ) ; if ( mnemonic != - NUM ) { item . set Mnemonic ( mnemonic ) ; } menu Items . put ( key , item ) ; item . set Action Command ( key ) ; menu . add ( item ) ; item . add Action Listener ( action Listener ) ; return item ; }
public static Any M Seq < Integer > from Range ( final int start , final int end ) { return Any M . from Stream ( Reactive Seq . range ( start , end ) ) ; }
public static Any M Seq < Integer > from Range ( final int start , final int end ) { return Any M . from Stream ( Reactive Seq . range ( start , end ) ) ; }
public static Any M Seq < Integer > from Range ( final int start , final int end ) { return Any M . from Stream ( Reactive Seq . range ( start , end ) ) ; }
public static Any M Seq < Integer > from Range ( final int start , final int end ) { return Any M . from Stream ( Reactive Seq . range ( start , end ) ) ; }
public static < T extends Writable > T clone ( T orig , Configuration conf ) { try { @ Suppress Warnings ( STRING ) T new Inst = Reflection Utils . new Instance ( ( Class < T > ) orig . get Class ( ) , conf ) ; Reflection Utils . copy ( conf , orig , new Inst ) ; return new Inst ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING , e ) ; } }
public static String remove Chars ( String str , String oldchars ) { int pos = index Of Chars ( str , oldchars ) ; if ( pos == - NUM ) { return str ; } String Builder buf = new String Builder ( ) ; int start = NUM ; do { buf . append ( str . substring ( start , pos ) ) ; start = pos + NUM ; pos = index Of Chars ( str , oldchars , start ) ; } while ( pos != - NUM ) ; if ( start < str . length ( ) ) { buf . append ( str . substring ( start ) ) ; } return buf . to String ( ) ; }
public void remove Process Listener ( I Nodejs Process Listener listener ) { synchronized ( listeners ) { listeners . remove ( listener ) ; } }
private void balance ( ) { balance Heights ( ) ; }
public static long nanos From Date ( long ms ) { Calendar cal = get Calendar ( ) ; cal . set Time In Millis ( ms ) ; return nanos From Calendar ( cal ) ; }
public static long nanos From Date ( long ms ) { Calendar cal = get Calendar ( ) ; cal . set Time In Millis ( ms ) ; return nanos From Calendar ( cal ) ; }
public static long nanos From Date ( long ms ) { Calendar cal = get Calendar ( ) ; cal . set Time In Millis ( ms ) ; return nanos From Calendar ( cal ) ; }
public void register Table Nodes ( Snmp Mib mib , M Bean Server server ) { table Jvm Thread Instance Table = create Jvm Thread Instance Table Meta Node ( STRING , STRING , mib , server ) ; if ( table Jvm Thread Instance Table != null ) { table Jvm Thread Instance Table . register Entry Node ( mib , server ) ; mib . register Table Meta ( STRING , table Jvm Thread Instance Table ) ; } }
public void copy Resource ( String resource Name , File dest File ) throws IO Exception { copy Resource ( resource Name , dest File . get Path ( ) , default File Handler ) ; }
protected int count Token ( String token , String target ) { int token Index = NUM ; int count = NUM ; while ( token Index != - NUM ) { token Index = target . index Of ( token , token Index ) ; if ( token Index > - NUM ) { token Index ++ ; count ++ ; } } return count ; }
protected int count Token ( String token , String target ) { int token Index = NUM ; int count = NUM ; while ( token Index != - NUM ) { token Index = target . index Of ( token , token Index ) ; if ( token Index > - NUM ) { token Index ++ ; count ++ ; } } return count ; }
protected int count Token ( String token , String target ) { int token Index = NUM ; int count = NUM ; while ( token Index != - NUM ) { token Index = target . index Of ( token , token Index ) ; if ( token Index > - NUM ) { token Index ++ ; count ++ ; } } return count ; }
protected int count Token ( String token , String target ) { int token Index = NUM ; int count = NUM ; while ( token Index != - NUM ) { token Index = target . index Of ( token , token Index ) ; if ( token Index > - NUM ) { token Index ++ ; count ++ ; } } return count ; }
@ Override public void emit Tuple ( Object tuple ) { output Port . emit ( tuple ) ; }
public String List plus ( String ... args ) { String List new List = new String List ( ) ; new List . add All ( this ) ; new List . add All ( Arrays . as List ( args ) ) ; return new List ; }
public void add Dependency ( Db Object obj ) { dependencies . add ( obj ) ; }
public void test Can Handle Zero Or More ( ) throws Exception { Dtd dtd = new Dtd ( STRING ) ; List < Descriptor Tag > element Order = dtd . get Element Order ( STRING ) ; assert Equals ( NUM , element Order . size ( ) ) ; Descriptor Tag tag = element Order . get ( NUM ) ; assert Equals ( STRING , tag . get Tag Name ( ) ) ; assert False ( tag . is Multiple Allowed ( ) ) ; tag = element Order . get ( NUM ) ; assert Equals ( STRING , tag . get Tag Name ( ) ) ; assert False ( tag . is Multiple Allowed ( ) ) ; tag = element Order . get ( NUM ) ; assert Equals ( STRING , tag . get Tag Name ( ) ) ; assert True ( tag . is Multiple Allowed ( ) ) ; tag = element Order . get ( NUM ) ; assert Equals ( STRING , tag . get Tag Name ( ) ) ; assert True ( tag . is Multiple Allowed ( ) ) ; }
private Concurrent Skip List Map . Node < K , V > lo Node ( ) { if ( lo == null ) return m . find First ( ) ; else if ( lo Inclusive ) return m . find Near ( lo , GT | EQ ) ; else return m . find Near ( lo , GT ) ; }
private Concurrent Skip List Map . Node < K , V > lo Node ( ) { if ( lo == null ) return m . find First ( ) ; else if ( lo Inclusive ) return m . find Near ( lo , GT | EQ ) ; else return m . find Near ( lo , GT ) ; }
private Concurrent Skip List Map . Node < K , V > lo Node ( ) { if ( lo == null ) return m . find First ( ) ; else if ( lo Inclusive ) return m . find Near ( lo , GT | EQ ) ; else return m . find Near ( lo , GT ) ; }
public Node ( final char [ ] a , final int offset , final int length , final boolean is Word , final int num Nodes ) { path = new char [ length ] ; System . arraycopy ( a , offset , path , NUM , length ) ; this . is Word = is Word ; this . num Nodes = num Nodes ; }
public Node ( final char [ ] a , final int offset , final int length , final boolean is Word , final int num Nodes ) { path = new char [ length ] ; System . arraycopy ( a , offset , path , NUM , length ) ; this . is Word = is Word ; this . num Nodes = num Nodes ; }
private void abort With Error ( @ Non Null String msg , @ Non Null Element e ) { report Error ( msg , e ) ; throw new Abort Processing Exception ( ) ; }
private void abort With Error ( @ Non Null String msg , @ Non Null Element e ) { report Error ( msg , e ) ; throw new Abort Processing Exception ( ) ; }
private void abort With Error ( @ Non Null String msg , @ Non Null Element e ) { report Error ( msg , e ) ; throw new Abort Processing Exception ( ) ; }
private void draw Map ( final Graphics g ) { g . draw Image ( map Image , NUM , NUM , null ) ; }
boolean contains Arguments ( ) { return ! args . is Empty ( ) ; }
boolean contains Arguments ( ) { return ! args . is Empty ( ) ; }
boolean contains Arguments ( ) { return ! args . is Empty ( ) ; }
private void consume ( ) { cur Char Index ++ ; cur Char = ( cur Char Index == pattern . length ( ) ) ? EOF : pattern . char At ( cur Char Index ) ; }
private void consume ( ) { cur Char Index ++ ; cur Char = ( cur Char Index == pattern . length ( ) ) ? EOF : pattern . char At ( cur Char Index ) ; }
private void consume ( ) { cur Char Index ++ ; cur Char = ( cur Char Index == pattern . length ( ) ) ? EOF : pattern . char At ( cur Char Index ) ; }
public static void write Element ( final XML Stream Writer writer , final String element Name , final String [ ] value ) throws XML Stream Exception { if ( value == null || value . length == NUM ) { return ; } writer . write Start Element ( element Name ) ; for ( int i = NUM ; i < value . length ; i ++ ) { writer . write Start Element ( STRING ) ; writer . write Characters ( value [ i ] ) ; writer . write End Element ( ) ; } writer . write End Element ( ) ; }
private void stretch View Vertically ( View view , int cross Size ) { Layout Params lp = ( Layout Params ) view . get Layout Params ( ) ; int new Height = cross Size - lp . top Margin - lp . bottom Margin ; new Height = Math . max ( new Height , NUM ) ; view . measure ( Measure Spec . make Measure Spec ( view . get Measured Width ( ) , Measure Spec . EXACTLY ) , Measure Spec . make Measure Spec ( new Height , Measure Spec . EXACTLY ) ) ; }
private void stretch View Vertically ( View view , int cross Size ) { Layout Params lp = ( Layout Params ) view . get Layout Params ( ) ; int new Height = cross Size - lp . top Margin - lp . bottom Margin ; new Height = Math . max ( new Height , NUM ) ; view . measure ( Measure Spec . make Measure Spec ( view . get Measured Width ( ) , Measure Spec . EXACTLY ) , Measure Spec . make Measure Spec ( new Height , Measure Spec . EXACTLY ) ) ; }
public void add Point ( Location location ) { points . add ( location ) ; }
public List < Identity Details > search Identity Details ( Crest Query crest Query , Map < String , Set < String > > search Modifiers , SSO Token admin ) throws Resource Exception { try { String realm = STRING ; String object Type = STRING ; if ( search Modifiers != null ) { realm = attract Values ( STRING , search Modifiers , STRING ) ; object Type = attract Values ( STRING , search Modifiers , STRING ) ; } AM Identity Repository repo = get Repo ( admin , realm ) ; Id Type id Type = get Id Type ( object Type ) ; if ( id Type != null ) { List < AM Identity > identities = fetch AM Identities ( id Type , crest Query , BOOL , repo , search Modifiers ) ; List < Identity Details > result = new Array List < > ( ) ; for ( AM Identity identity : identities ) { result . add ( convert To Identity Details ( identity , null ) ) ; } return result ; } debug . error ( STRING + object Type ) ; throw new Bad Request Exception ( STRING + object Type ) ; } catch ( Id Repo Exception e ) { debug . error ( STRING , e ) ; throw new Internal Server Error Exception ( e . get Message ( ) ) ; } catch ( SSO Exception e ) { debug . error ( STRING , e ) ; throw new Internal Server Error Exception ( e . get Message ( ) ) ; } catch ( Object Not Found e ) { debug . error ( STRING , e ) ; throw new Not Found Exception ( e . get Message ( ) ) ; } }
public void event ( String event , String parameter , long duration ) { log Entries . add ( new Event Entry ( event , parameter , duration ) ) ; }
private < T > T perform Without Missing Bundle Pool ( Supplier < T > supplier ) { create Bundle Pool If Necessary ( ) ; return supplier . get ( ) ; }
private < T > T perform Without Missing Bundle Pool ( Supplier < T > supplier ) { create Bundle Pool If Necessary ( ) ; return supplier . get ( ) ; }
private < T > T perform Without Missing Bundle Pool ( Supplier < T > supplier ) { create Bundle Pool If Necessary ( ) ; return supplier . get ( ) ; }
private < T > T perform Without Missing Bundle Pool ( Supplier < T > supplier ) { create Bundle Pool If Necessary ( ) ; return supplier . get ( ) ; }
public Vector ( int capacity , int capacity Increment ) { if ( capacity < NUM ) { throw new Illegal Argument Exception ( ) ; } element Data = new Element Array ( capacity ) ; element Count = NUM ; this . capacity Increment = capacity Increment ; }
public Vector ( int capacity , int capacity Increment ) { if ( capacity < NUM ) { throw new Illegal Argument Exception ( ) ; } element Data = new Element Array ( capacity ) ; element Count = NUM ; this . capacity Increment = capacity Increment ; }
public Vector ( int capacity , int capacity Increment ) { if ( capacity < NUM ) { throw new Illegal Argument Exception ( ) ; } element Data = new Element Array ( capacity ) ; element Count = NUM ; this . capacity Increment = capacity Increment ; }
private synchronized void start Update Thread ( ) { if ( screen Updater == null ) { screen Updater = Access Controller . do Privileged ( ( Privileged Action < Thread > ) null ) ; screen Updater . start ( ) ; } else { wake Up Update Thread ( ) ; } }
public void stop Enumeration ( Enumeration Deletion Context aws ) { aws . compute Enumeration Request . enumeration Action = Enumeration Action . STOP ; handle Enumeration Request For Deletion ( aws ) ; }
public void stop Enumeration ( Enumeration Deletion Context aws ) { aws . compute Enumeration Request . enumeration Action = Enumeration Action . STOP ; handle Enumeration Request For Deletion ( aws ) ; }
public void stop Enumeration ( Enumeration Deletion Context aws ) { aws . compute Enumeration Request . enumeration Action = Enumeration Action . STOP ; handle Enumeration Request For Deletion ( aws ) ; }
public void stop Enumeration ( Enumeration Deletion Context aws ) { aws . compute Enumeration Request . enumeration Action = Enumeration Action . STOP ; handle Enumeration Request For Deletion ( aws ) ; }
public void stop Enumeration ( Enumeration Deletion Context aws ) { aws . compute Enumeration Request . enumeration Action = Enumeration Action . STOP ; handle Enumeration Request For Deletion ( aws ) ; }
public byte [ ] encode To Bitcoin ( ) { try { Byte Array Output Stream bos = der Byte Stream ( ) ; bos . write ( sighash Flags ) ; return bos . to Byte Array ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public byte [ ] encode To Bitcoin ( ) { try { Byte Array Output Stream bos = der Byte Stream ( ) ; bos . write ( sighash Flags ) ; return bos . to Byte Array ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public byte [ ] encode To Bitcoin ( ) { try { Byte Array Output Stream bos = der Byte Stream ( ) ; bos . write ( sighash Flags ) ; return bos . to Byte Array ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public byte [ ] encode To Bitcoin ( ) { try { Byte Array Output Stream bos = der Byte Stream ( ) ; bos . write ( sighash Flags ) ; return bos . to Byte Array ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public byte [ ] encode To Bitcoin ( ) { try { Byte Array Output Stream bos = der Byte Stream ( ) ; bos . write ( sighash Flags ) ; return bos . to Byte Array ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public byte [ ] encode To Bitcoin ( ) { try { Byte Array Output Stream bos = der Byte Stream ( ) ; bos . write ( sighash Flags ) ; return bos . to Byte Array ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
private void load Button Text ( Abstract Button component , String text ) { String Buffer result = new String Buffer ( ) ; boolean have Mnemonic = BOOL ; char mnemonic = STRING ; int mnemonic Index = - NUM ; for ( int i = NUM ; i < text . length ( ) ; i ++ ) { if ( text . char At ( i ) == STRING ) { i ++ ; if ( i == text . length ( ) ) { break ; } if ( ! have Mnemonic && text . char At ( i ) != STRING ) { have Mnemonic = BOOL ; mnemonic = text . char At ( i ) ; mnemonic Index = result . length ( ) ; } } result . append ( text . char At ( i ) ) ; } component . set Text ( result . to String ( ) ) ; if ( have Mnemonic ) { component . set Mnemonic ( mnemonic ) ; component . set Displayed Mnemonic Index ( mnemonic Index ) ; } }
public static void send Response With Status ( Http Servlet Request request , Http Servlet Response response , Print Writer out , String idp Meta Alias , String idp Entity ID , String realm , Authn Request authn Req , String relay State , String sp Entity ID , String firstlevel Status Code Value , String secondlevel Status Code Value ) throws SAML 2 Exception { Response res = SAML 2 Utils . get Error Response ( authn Req , firstlevel Status Code Value , secondlevel Status Code Value , null , idp Entity ID ) ; String Buffer returned Binding = new String Buffer ( ) ; String acs URL = IDPSSO Util . get AC Surl ( sp Entity ID , realm , authn Req , request , returned Binding ) ; String acs Binding = returned Binding . to String ( ) ; send Response ( request , response , out , acs Binding , sp Entity ID , idp Entity ID , idp Meta Alias , realm , relay State , acs URL , res , null ) ; }
public static void send Response With Status ( Http Servlet Request request , Http Servlet Response response , Print Writer out , String idp Meta Alias , String idp Entity ID , String realm , Authn Request authn Req , String relay State , String sp Entity ID , String firstlevel Status Code Value , String secondlevel Status Code Value ) throws SAML 2 Exception { Response res = SAML 2 Utils . get Error Response ( authn Req , firstlevel Status Code Value , secondlevel Status Code Value , null , idp Entity ID ) ; String Buffer returned Binding = new String Buffer ( ) ; String acs URL = IDPSSO Util . get AC Surl ( sp Entity ID , realm , authn Req , request , returned Binding ) ; String acs Binding = returned Binding . to String ( ) ; send Response ( request , response , out , acs Binding , sp Entity ID , idp Entity ID , idp Meta Alias , realm , relay State , acs URL , res , null ) ; }
public static void log Error ( String log Entry ) { }
public static void log Error ( String log Entry ) { }
public static void log Error ( String log Entry ) { }
final int rllong ( Data Input Stream dis ) throws IO Exception { int b1 , b2 , b3 , b4 ; int i = NUM ; i = dis . read Int ( ) ; b1 = ( i & NUM ) << NUM ; b2 = ( i & NUM ) << NUM ; b3 = ( i & NUM ) > > NUM ; b4 = ( i & NUM ) > > > NUM ; i = ( b1 | b2 | b3 | b4 ) ; return i ; }
final int rllong ( Data Input Stream dis ) throws IO Exception { int b1 , b2 , b3 , b4 ; int i = NUM ; i = dis . read Int ( ) ; b1 = ( i & NUM ) << NUM ; b2 = ( i & NUM ) << NUM ; b3 = ( i & NUM ) > > NUM ; b4 = ( i & NUM ) > > > NUM ; i = ( b1 | b2 | b3 | b4 ) ; return i ; }
private static String prepend If Missing ( final String str , final Char Sequence prefix , final boolean ignore Case , final Char Sequence ... prefixes ) { if ( str == null || is Empty ( prefix ) || starts With ( str , prefix , ignore Case ) ) { return str ; } if ( prefixes != null && prefixes . length > NUM ) { for ( final Char Sequence p : prefixes ) { if ( starts With ( str , p , ignore Case ) ) { return str ; } } } return prefix . to String ( ) + str ; }
public Wave Writer ( Audio Format format , Path file , long max Size ) throws IO Exception { assert ( format != null ) ; assert ( file != null ) ; m Audio Format = format ; m File = file ; if ( NUM < max Size && max Size <= MAX WAVE SIZE ) { m Max Size = max Size ; } else { m Max Size = MAX WAVE SIZE ; } open ( ) ; }
public Wave Writer ( Audio Format format , Path file , long max Size ) throws IO Exception { assert ( format != null ) ; assert ( file != null ) ; m Audio Format = format ; m File = file ; if ( NUM < max Size && max Size <= MAX WAVE SIZE ) { m Max Size = max Size ; } else { m Max Size = MAX WAVE SIZE ; } open ( ) ; }
public Wave Writer ( Audio Format format , Path file , long max Size ) throws IO Exception { assert ( format != null ) ; assert ( file != null ) ; m Audio Format = format ; m File = file ; if ( NUM < max Size && max Size <= MAX WAVE SIZE ) { m Max Size = max Size ; } else { m Max Size = MAX WAVE SIZE ; } open ( ) ; }
private void global Accel From Menu ( Menu Element me ) { for ( Menu Element element : me . get Sub Elements ( ) ) { if ( ( element instanceof J Popup Menu ) || ( element instanceof J Menu ) ) { global Accel From Menu ( element ) ; } else if ( element instanceof J Menu Item ) { J Menu Item item = ( J Menu Item ) element ; if ( item . get Accelerator ( ) != null ) { action Listener Map . put ( item . get Accelerator ( ) , item . get Action Listeners ( ) ) ; } } } }
private void global Accel From Menu ( Menu Element me ) { for ( Menu Element element : me . get Sub Elements ( ) ) { if ( ( element instanceof J Popup Menu ) || ( element instanceof J Menu ) ) { global Accel From Menu ( element ) ; } else if ( element instanceof J Menu Item ) { J Menu Item item = ( J Menu Item ) element ; if ( item . get Accelerator ( ) != null ) { action Listener Map . put ( item . get Accelerator ( ) , item . get Action Listeners ( ) ) ; } } } }
private void global Accel From Menu ( Menu Element me ) { for ( Menu Element element : me . get Sub Elements ( ) ) { if ( ( element instanceof J Popup Menu ) || ( element instanceof J Menu ) ) { global Accel From Menu ( element ) ; } else if ( element instanceof J Menu Item ) { J Menu Item item = ( J Menu Item ) element ; if ( item . get Accelerator ( ) != null ) { action Listener Map . put ( item . get Accelerator ( ) , item . get Action Listeners ( ) ) ; } } } }
private void global Accel From Menu ( Menu Element me ) { for ( Menu Element element : me . get Sub Elements ( ) ) { if ( ( element instanceof J Popup Menu ) || ( element instanceof J Menu ) ) { global Accel From Menu ( element ) ; } else if ( element instanceof J Menu Item ) { J Menu Item item = ( J Menu Item ) element ; if ( item . get Accelerator ( ) != null ) { action Listener Map . put ( item . get Accelerator ( ) , item . get Action Listeners ( ) ) ; } } } }
public Data Set ( List < T > y Vals , String label ) { super ( label ) ; this . mY Vals = y Vals ; if ( mY Vals == null ) mY Vals = new Array List < > ( ) ; calc Min Max ( NUM , mY Vals . size ( ) ) ; }
public Data Set ( List < T > y Vals , String label ) { super ( label ) ; this . mY Vals = y Vals ; if ( mY Vals == null ) mY Vals = new Array List < > ( ) ; calc Min Max ( NUM , mY Vals . size ( ) ) ; }
public Data Set ( List < T > y Vals , String label ) { super ( label ) ; this . mY Vals = y Vals ; if ( mY Vals == null ) mY Vals = new Array List < > ( ) ; calc Min Max ( NUM , mY Vals . size ( ) ) ; }
public Data Set ( List < T > y Vals , String label ) { super ( label ) ; this . mY Vals = y Vals ; if ( mY Vals == null ) mY Vals = new Array List < > ( ) ; calc Min Max ( NUM , mY Vals . size ( ) ) ; }
private void compute Closure ( ) { for ( Enumeration < Graph Node > e = enumerate Vertices ( ) ; e . has More Elements ( ) ; ) { Value Graph Vertex v = ( Value Graph Vertex ) e . next Element ( ) ; if ( v . get Name ( ) instanceof Register ) { if ( v . get Label ( ) instanceof Register ) { if ( v . get Name ( ) != v . get Label ( ) ) { Value Graph Vertex v2 = get Vertex ( v . get Label ( ) ) ; if ( VM . Verify Assertions ) { if ( v2 . get Name ( ) instanceof Register && v2 . get Label ( ) instanceof Register && v2 . get Label ( ) != v2 . get Name ( ) ) { VM . assert ( VM . NOT REACHED ) ; } } v . copy Vertex ( v2 ) ; } } } } }
private void compute Closure ( ) { for ( Enumeration < Graph Node > e = enumerate Vertices ( ) ; e . has More Elements ( ) ; ) { Value Graph Vertex v = ( Value Graph Vertex ) e . next Element ( ) ; if ( v . get Name ( ) instanceof Register ) { if ( v . get Label ( ) instanceof Register ) { if ( v . get Name ( ) != v . get Label ( ) ) { Value Graph Vertex v2 = get Vertex ( v . get Label ( ) ) ; if ( VM . Verify Assertions ) { if ( v2 . get Name ( ) instanceof Register && v2 . get Label ( ) instanceof Register && v2 . get Label ( ) != v2 . get Name ( ) ) { VM . assert ( VM . NOT REACHED ) ; } } v . copy Vertex ( v2 ) ; } } } } }
public static void add Search Algorithm ( String name , Search For Actions algo ) { SEARCH NAMES . add ( name ) ; SEARCH ALGOS . add ( algo ) ; }
public void save Data ( File file ) throws IO Exception { synchronized ( accumulators ) { Object Output Stream oos = null ; try { oos = new Object Output Stream ( new File Output Stream ( file ) ) ; oos . write Object ( accumulators ) ; } finally { if ( oos != null ) { oos . close ( ) ; } } } }
public void save Data ( File file ) throws IO Exception { synchronized ( accumulators ) { Object Output Stream oos = null ; try { oos = new Object Output Stream ( new File Output Stream ( file ) ) ; oos . write Object ( accumulators ) ; } finally { if ( oos != null ) { oos . close ( ) ; } } } }
static void put Circle Of Trust ( String realm , String name , Circle Of Trust Descriptor cot Descriptor ) { String class Method = STRING ; String cache Key = build Cache Key ( realm , name ) ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + STRING + cache Key ) ; } cot Cache . put ( cache Key , cot Descriptor ) ; }
protected void write Netscape Ext ( ) throws IO Exception { out . write ( NUM ) ; out . write ( NUM ) ; out . write ( NUM ) ; write String ( STRING + STRING ) ; out . write ( NUM ) ; out . write ( NUM ) ; write Short ( repeat ) ; out . write ( NUM ) ; }
@ Override public int compare To ( Double Int Pair other ) { int fdiff = Double . compare ( this . first , other . first ) ; if ( fdiff != NUM ) { return fdiff ; } return this . second - other . second ; }
public static void add ( Class File Transformer t ) { synchronized ( transformers ) { transformers . add ( t ) ; } }
public void update Viewport ( ) { set To Ortho ( BOOL , virtual Viewport . get Width ( ) , virtual Viewport . get Height ( ) ) ; }
public void update Viewport ( ) { set To Ortho ( BOOL , virtual Viewport . get Width ( ) , virtual Viewport . get Height ( ) ) ; }
public static String extract Requested Domain Name ( final String request URL ) { final int domain Name Start Index = request URL . index Of ( STRING ) + NUM ; String domain Name = request URL . substring ( domain Name Start Index , request URL . index Of ( STRING , domain Name Start Index ) ) ; if ( domain Name . contains ( STRING ) ) domain Name = domain Name . split ( STRING ) [ NUM ] ; return domain Name ; }
public Object load Native Font ( String lookup ) { try { lookup = lookup . split ( STRING ) [ NUM ] ; int typeface = Typeface . NORMAL ; String family Name = lookup . substring ( NUM , lookup . index Of ( STRING ) ) ; String style = lookup . substring ( lookup . index Of ( STRING ) + NUM , lookup . last Index Of ( STRING ) ) ; String size = lookup . substring ( lookup . last Index Of ( STRING ) + NUM , lookup . length ( ) ) ; if ( style . equals ( STRING ) ) { typeface = Typeface . BOLD ITALIC ; } else if ( style . equals ( STRING ) ) { typeface = Typeface . ITALIC ; } else if ( style . equals ( STRING ) ) { typeface = Typeface . BOLD ; } Paint font = new Codename One Text Paint ( Typeface . create ( family Name , typeface ) ) ; font . set Anti Alias ( BOOL ) ; font . set Text Size ( Integer . parse Int ( size ) ) ; return new Native Font ( NUM , NUM , NUM , font ) ; } catch ( Exception err ) { return null ; } }
public Object load Native Font ( String lookup ) { try { lookup = lookup . split ( STRING ) [ NUM ] ; int typeface = Typeface . NORMAL ; String family Name = lookup . substring ( NUM , lookup . index Of ( STRING ) ) ; String style = lookup . substring ( lookup . index Of ( STRING ) + NUM , lookup . last Index Of ( STRING ) ) ; String size = lookup . substring ( lookup . last Index Of ( STRING ) + NUM , lookup . length ( ) ) ; if ( style . equals ( STRING ) ) { typeface = Typeface . BOLD ITALIC ; } else if ( style . equals ( STRING ) ) { typeface = Typeface . ITALIC ; } else if ( style . equals ( STRING ) ) { typeface = Typeface . BOLD ; } Paint font = new Codename One Text Paint ( Typeface . create ( family Name , typeface ) ) ; font . set Anti Alias ( BOOL ) ; font . set Text Size ( Integer . parse Int ( size ) ) ; return new Native Font ( NUM , NUM , NUM , font ) ; } catch ( Exception err ) { return null ; } }
public Object load Native Font ( String lookup ) { try { lookup = lookup . split ( STRING ) [ NUM ] ; int typeface = Typeface . NORMAL ; String family Name = lookup . substring ( NUM , lookup . index Of ( STRING ) ) ; String style = lookup . substring ( lookup . index Of ( STRING ) + NUM , lookup . last Index Of ( STRING ) ) ; String size = lookup . substring ( lookup . last Index Of ( STRING ) + NUM , lookup . length ( ) ) ; if ( style . equals ( STRING ) ) { typeface = Typeface . BOLD ITALIC ; } else if ( style . equals ( STRING ) ) { typeface = Typeface . ITALIC ; } else if ( style . equals ( STRING ) ) { typeface = Typeface . BOLD ; } Paint font = new Codename One Text Paint ( Typeface . create ( family Name , typeface ) ) ; font . set Anti Alias ( BOOL ) ; font . set Text Size ( Integer . parse Int ( size ) ) ; return new Native Font ( NUM , NUM , NUM , font ) ; } catch ( Exception err ) { return null ; } }
public void add Response ( Response response ) { response Vector . add Element ( response ) ; }
static private String calc Threshold ( double score Threshold , double lambda ) { final double log Prob Threshold = Math . log ( NUM - score Threshold / NUM ) ; int max Num = NUM ; if ( calc Log Prob ( max Num , lambda ) > log Prob Threshold ) { return STRING ; } int min Num = NUM ; while ( min Num < max Num ) { final int mid Num = ( max Num + min Num ) / NUM ; final boolean pass Threshold = calc Log Prob ( mid Num , lambda ) <= log Prob Threshold ; if ( pass Threshold ) { max Num = mid Num ; } else { if ( mid Num == min Num ) { break ; } min Num = mid Num ; } } return Integer . to String ( max Num ) ; }
private static String [ ] append Enabled ( final String [ ] options ) { for ( final String option : options ) { if ( option . equals ( STRING ) ) { return options ; } } String [ ] result = new String [ options . length + NUM ] ; result [ NUM ] = STRING ; System . arraycopy ( options , NUM , result , NUM , options . length ) ; return result ; }
private static String [ ] append Enabled ( final String [ ] options ) { for ( final String option : options ) { if ( option . equals ( STRING ) ) { return options ; } } String [ ] result = new String [ options . length + NUM ] ; result [ NUM ] = STRING ; System . arraycopy ( options , NUM , result , NUM , options . length ) ; return result ; }
public static void sign ( File jad File , File jar File , RSA Private Key private Key , X509 Certificate [ ] certificate Chain , int certificate Number ) throws IO Exception , Crypto Exception { File tmp File = File . create Temp File ( STRING , STRING ) ; tmp File . delete On Exit ( ) ; sign ( jad File , tmp File , jar File , private Key , certificate Chain , certificate Number ) ; Copy Util . copy Close ( new File Input Stream ( tmp File ) , new File Output Stream ( jad File ) ) ; tmp File . delete ( ) ; }
public static void sign ( File jad File , File jar File , RSA Private Key private Key , X509 Certificate [ ] certificate Chain , int certificate Number ) throws IO Exception , Crypto Exception { File tmp File = File . create Temp File ( STRING , STRING ) ; tmp File . delete On Exit ( ) ; sign ( jad File , tmp File , jar File , private Key , certificate Chain , certificate Number ) ; Copy Util . copy Close ( new File Input Stream ( tmp File ) , new File Output Stream ( jad File ) ) ; tmp File . delete ( ) ; }
public void store ( Document document , String path To Parent , String element Name ) throws XML Exception { Element parent = ( Element ) Doc Util . eval X Path As Node ( document , path To Parent ) ; Bean Converter converter = new Bean Converter ( this , document ) ; Element elem = converter . create Element ( element Name ) ; parent . append Child ( elem ) ; }
public static void delete ( String path ) { if ( path != null ) delete ( Paths . get ( path ) ) ; }
public static void delete ( String path ) { if ( path != null ) delete ( Paths . get ( path ) ) ; }
public static void delete ( String path ) { if ( path != null ) delete ( Paths . get ( path ) ) ; }
public static void delete ( String path ) { if ( path != null ) delete ( Paths . get ( path ) ) ; }
public static Byte to Byte ( Object o , Byte default Value ) { if ( o instanceof Byte ) return ( Byte ) o ; if ( default Value != null ) return new Byte ( to Byte Value ( o , default Value . byte Value ( ) ) ) ; byte res = to Byte Value ( o , Byte . MIN VALUE ) ; if ( res == Byte . MIN VALUE ) return default Value ; return new Byte ( res ) ; }
public static Byte to Byte ( Object o , Byte default Value ) { if ( o instanceof Byte ) return ( Byte ) o ; if ( default Value != null ) return new Byte ( to Byte Value ( o , default Value . byte Value ( ) ) ) ; byte res = to Byte Value ( o , Byte . MIN VALUE ) ; if ( res == Byte . MIN VALUE ) return default Value ; return new Byte ( res ) ; }
private static Analysis Result check All Appearances ( Register reg , IR ir ) { return new Analysis Result ( ! check If Use Escapes Thread ( reg , ir , null ) , ! check If Use Escapes Method ( reg , ir , null ) ) ; }
private static Analysis Result check All Appearances ( Register reg , IR ir ) { return new Analysis Result ( ! check If Use Escapes Thread ( reg , ir , null ) , ! check If Use Escapes Method ( reg , ir , null ) ) ; }
private void clear Output ( ) { if ( current Output != null ) { out . println ( ) ; } current Output = null ; }
void refresh UI ( String xml , DOM Tree m tree ) { if ( ( xml == null ) || xml . equals ( STRING ) ) { set Error Message ( STRING , STRING ) ; return ; } final Document new Root = get Root ( xml ) ; if ( new Root == null ) { set Error Message ( STRING , STRING ) ; return ; } m tree . set Document ( new Root ) ; }
void refresh UI ( String xml , DOM Tree m tree ) { if ( ( xml == null ) || xml . equals ( STRING ) ) { set Error Message ( STRING , STRING ) ; return ; } final Document new Root = get Root ( xml ) ; if ( new Root == null ) { set Error Message ( STRING , STRING ) ; return ; } m tree . set Document ( new Root ) ; }
public Address ( final long value ) { m value = Big Integer . value Of ( value ) ; }
public Sea Glass Tabbed Pane Mouse Handler ( Mouse Listener original Mouse Listener ) { delegate = original Mouse Listener ; delegate 2 = ( Mouse Motion Listener ) original Mouse Listener ; close Button Hover Index = - NUM ; close Button Armed Index = - NUM ; }
@ Override public Inet Socket Address ip Local ( ) { Socket s = get Socket ( ) ; if ( s != null ) { return ( Inet Socket Address ) s . get Local Socket Address ( ) ; } else { return null ; } }
@ Override public Inet Socket Address ip Local ( ) { Socket s = get Socket ( ) ; if ( s != null ) { return ( Inet Socket Address ) s . get Local Socket Address ( ) ; } else { return null ; } }
@ Suppress Warnings ( STRING ) public static < K > Immutable Array 2 < K > empty ( ) { return ( Immutable Array 2 < K > ) EMPTY ; }
boolean remove Tab ( Tab t ) { if ( t == null ) { return BOOL ; } Tab current = get Current Tab ( ) ; m Tabs . remove ( t ) ; m Tab Count Observable . set ( m Tabs . size ( ) ) ; if ( t . is Private Browsing Enabled ( ) ) { m Num Incognito -= NUM ; if ( m Num Incognito == NUM ) { Geolocation Permissions . on Incognito Tabs Removed ( ) ; Engine . destroy Incognito Profile ( ) ; } } if ( current == t ) { t . put In Background ( ) ; m Current Tab = - NUM ; } else { m Current Tab = get Tab Position ( current ) ; } t . destroy ( ) ; t . remove From Tree ( ) ; m Tab Queue . remove ( t ) ; return BOOL ; }
private static int uarimax Gt ( double value , double [ ] bv , int bvi [ ] , Binary Operator b Op ) throws DML Runtime Exception { int ix Max = bv . length ; if ( value <= bv [ NUM ] || value > bv [ bv . length - NUM ] ) return ix Max ; int ix = Arrays . binary Search ( bv , value ) ; ix = Math . abs ( ix ) - NUM ; ix Max = bvi [ ix - NUM ] + NUM ; return ix Max ; }
public LTR Pulse Shaping Filter ( ) { m Buffer = new Bit Set ( ) ; m Buffer . clear ( ) ; }
public LTR Pulse Shaping Filter ( ) { m Buffer = new Bit Set ( ) ; m Buffer . clear ( ) ; }
public LTR Pulse Shaping Filter ( ) { m Buffer = new Bit Set ( ) ; m Buffer . clear ( ) ; }
public LTR Pulse Shaping Filter ( ) { m Buffer = new Bit Set ( ) ; m Buffer . clear ( ) ; }
@ Suppress Warnings ( STRING ) public static < T > Sequence < T > wrap End ( Sequence < T > sequence , T end Token ) { Object [ ] arr = new Object [ sequence . size ( ) + NUM ] ; System . arraycopy ( sequence . elements ( ) , NUM , arr , NUM , sequence . size ( ) ) ; arr [ sequence . size ( ) ] = end Token ; return new Array Sequence < T > ( BOOL , ( T [ ] ) arr ) ; }
public String replace ( char old Char , char new Char ) { char [ ] buffer = value ; int offset = offset ; int count = count ; int idx = offset ; int last = offset + count ; boolean copied = BOOL ; while ( idx < last ) { if ( buffer [ idx ] == old Char ) { if ( ! copied ) { char [ ] new Buffer = new char [ count ] ; System . arraycopy ( buffer , offset , new Buffer , NUM , count ) ; buffer = new Buffer ; idx -= offset ; last -= offset ; copied = BOOL ; } buffer [ idx ] = new Char ; } idx ++ ; } return copied ? new String ( NUM , count , buffer ) : this ; }
public String replace ( char old Char , char new Char ) { char [ ] buffer = value ; int offset = offset ; int count = count ; int idx = offset ; int last = offset + count ; boolean copied = BOOL ; while ( idx < last ) { if ( buffer [ idx ] == old Char ) { if ( ! copied ) { char [ ] new Buffer = new char [ count ] ; System . arraycopy ( buffer , offset , new Buffer , NUM , count ) ; buffer = new Buffer ; idx -= offset ; last -= offset ; copied = BOOL ; } buffer [ idx ] = new Char ; } idx ++ ; } return copied ? new String ( NUM , count , buffer ) : this ; }
private static Map < String , So Info > find Provided Libraries ( Jar File apk ) { Pattern lib Pattern = Pattern . compile ( STRING ) ; Hash Map < String , So Info > provided Libraries = new Hash Map < > ( ) ; String [ ] supported Abis = Sys Util . get Supported Abis ( ) ; Enumeration < Jar Entry > entries = apk . entries ( ) ; while ( entries . has More Elements ( ) ) { Jar Entry entry = entries . next Element ( ) ; Matcher m = lib Pattern . matcher ( entry . get Name ( ) ) ; if ( m . matches ( ) ) { String library Abi = m . group ( NUM ) ; String so Name = m . group ( NUM ) ; int abi Score = Sys Util . find Abi Score ( supported Abis , library Abi ) ; if ( abi Score >= NUM ) { So Info so = provided Libraries . get ( so Name ) ; if ( so == null || abi Score < so . abi Score ) { provided Libraries . put ( so Name , new So Info ( so Name , entry , abi Score ) ) ; } } } } return provided Libraries ; }
private static Map < String , So Info > find Provided Libraries ( Jar File apk ) { Pattern lib Pattern = Pattern . compile ( STRING ) ; Hash Map < String , So Info > provided Libraries = new Hash Map < > ( ) ; String [ ] supported Abis = Sys Util . get Supported Abis ( ) ; Enumeration < Jar Entry > entries = apk . entries ( ) ; while ( entries . has More Elements ( ) ) { Jar Entry entry = entries . next Element ( ) ; Matcher m = lib Pattern . matcher ( entry . get Name ( ) ) ; if ( m . matches ( ) ) { String library Abi = m . group ( NUM ) ; String so Name = m . group ( NUM ) ; int abi Score = Sys Util . find Abi Score ( supported Abis , library Abi ) ; if ( abi Score >= NUM ) { So Info so = provided Libraries . get ( so Name ) ; if ( so == null || abi Score < so . abi Score ) { provided Libraries . put ( so Name , new So Info ( so Name , entry , abi Score ) ) ; } } } } return provided Libraries ; }
private static Map < String , So Info > find Provided Libraries ( Jar File apk ) { Pattern lib Pattern = Pattern . compile ( STRING ) ; Hash Map < String , So Info > provided Libraries = new Hash Map < > ( ) ; String [ ] supported Abis = Sys Util . get Supported Abis ( ) ; Enumeration < Jar Entry > entries = apk . entries ( ) ; while ( entries . has More Elements ( ) ) { Jar Entry entry = entries . next Element ( ) ; Matcher m = lib Pattern . matcher ( entry . get Name ( ) ) ; if ( m . matches ( ) ) { String library Abi = m . group ( NUM ) ; String so Name = m . group ( NUM ) ; int abi Score = Sys Util . find Abi Score ( supported Abis , library Abi ) ; if ( abi Score >= NUM ) { So Info so = provided Libraries . get ( so Name ) ; if ( so == null || abi Score < so . abi Score ) { provided Libraries . put ( so Name , new So Info ( so Name , entry , abi Score ) ) ; } } } } return provided Libraries ; }
private static Map < String , So Info > find Provided Libraries ( Jar File apk ) { Pattern lib Pattern = Pattern . compile ( STRING ) ; Hash Map < String , So Info > provided Libraries = new Hash Map < > ( ) ; String [ ] supported Abis = Sys Util . get Supported Abis ( ) ; Enumeration < Jar Entry > entries = apk . entries ( ) ; while ( entries . has More Elements ( ) ) { Jar Entry entry = entries . next Element ( ) ; Matcher m = lib Pattern . matcher ( entry . get Name ( ) ) ; if ( m . matches ( ) ) { String library Abi = m . group ( NUM ) ; String so Name = m . group ( NUM ) ; int abi Score = Sys Util . find Abi Score ( supported Abis , library Abi ) ; if ( abi Score >= NUM ) { So Info so = provided Libraries . get ( so Name ) ; if ( so == null || abi Score < so . abi Score ) { provided Libraries . put ( so Name , new So Info ( so Name , entry , abi Score ) ) ; } } } } return provided Libraries ; }
private static Map < String , So Info > find Provided Libraries ( Jar File apk ) { Pattern lib Pattern = Pattern . compile ( STRING ) ; Hash Map < String , So Info > provided Libraries = new Hash Map < > ( ) ; String [ ] supported Abis = Sys Util . get Supported Abis ( ) ; Enumeration < Jar Entry > entries = apk . entries ( ) ; while ( entries . has More Elements ( ) ) { Jar Entry entry = entries . next Element ( ) ; Matcher m = lib Pattern . matcher ( entry . get Name ( ) ) ; if ( m . matches ( ) ) { String library Abi = m . group ( NUM ) ; String so Name = m . group ( NUM ) ; int abi Score = Sys Util . find Abi Score ( supported Abis , library Abi ) ; if ( abi Score >= NUM ) { So Info so = provided Libraries . get ( so Name ) ; if ( so == null || abi Score < so . abi Score ) { provided Libraries . put ( so Name , new So Info ( so Name , entry , abi Score ) ) ; } } } } return provided Libraries ; }
private static Map < String , So Info > find Provided Libraries ( Jar File apk ) { Pattern lib Pattern = Pattern . compile ( STRING ) ; Hash Map < String , So Info > provided Libraries = new Hash Map < > ( ) ; String [ ] supported Abis = Sys Util . get Supported Abis ( ) ; Enumeration < Jar Entry > entries = apk . entries ( ) ; while ( entries . has More Elements ( ) ) { Jar Entry entry = entries . next Element ( ) ; Matcher m = lib Pattern . matcher ( entry . get Name ( ) ) ; if ( m . matches ( ) ) { String library Abi = m . group ( NUM ) ; String so Name = m . group ( NUM ) ; int abi Score = Sys Util . find Abi Score ( supported Abis , library Abi ) ; if ( abi Score >= NUM ) { So Info so = provided Libraries . get ( so Name ) ; if ( so == null || abi Score < so . abi Score ) { provided Libraries . put ( so Name , new So Info ( so Name , entry , abi Score ) ) ; } } } } return provided Libraries ; }
protected void cut Selected Bean ( ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; if ( selected Bean == null || selected Bean Location == null ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selected Bean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selected Bean Location ) ; clear Selection ( ) ; return ; } try { ser Bean = new Byte Array Output Stream ( ) ; Object Output Stream oos = new Object Output Stream ( ser Bean ) ; oos . write Object ( selected Bean ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; clear Selection ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; return ; } cut Bean = selected Bean ; selected Bean Box . show Cut ( selected Bean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; }
protected void cut Selected Bean ( ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; if ( selected Bean == null || selected Bean Location == null ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selected Bean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selected Bean Location ) ; clear Selection ( ) ; return ; } try { ser Bean = new Byte Array Output Stream ( ) ; Object Output Stream oos = new Object Output Stream ( ser Bean ) ; oos . write Object ( selected Bean ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; clear Selection ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; return ; } cut Bean = selected Bean ; selected Bean Box . show Cut ( selected Bean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; }
protected void cut Selected Bean ( ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; if ( selected Bean == null || selected Bean Location == null ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selected Bean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selected Bean Location ) ; clear Selection ( ) ; return ; } try { ser Bean = new Byte Array Output Stream ( ) ; Object Output Stream oos = new Object Output Stream ( ser Bean ) ; oos . write Object ( selected Bean ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; clear Selection ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; return ; } cut Bean = selected Bean ; selected Bean Box . show Cut ( selected Bean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; }
protected void cut Selected Bean ( ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; if ( selected Bean == null || selected Bean Location == null ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selected Bean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selected Bean Location ) ; clear Selection ( ) ; return ; } try { ser Bean = new Byte Array Output Stream ( ) ; Object Output Stream oos = new Object Output Stream ( ser Bean ) ; oos . write Object ( selected Bean ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; clear Selection ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; return ; } cut Bean = selected Bean ; selected Bean Box . show Cut ( selected Bean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; }
protected void cut Selected Bean ( ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; if ( selected Bean == null || selected Bean Location == null ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selected Bean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selected Bean Location ) ; clear Selection ( ) ; return ; } try { ser Bean = new Byte Array Output Stream ( ) ; Object Output Stream oos = new Object Output Stream ( ser Bean ) ; oos . write Object ( selected Bean ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; clear Selection ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; return ; } cut Bean = selected Bean ; selected Bean Box . show Cut ( selected Bean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; }
protected void cut Selected Bean ( ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; if ( selected Bean == null || selected Bean Location == null ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selected Bean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selected Bean Location ) ; clear Selection ( ) ; return ; } try { ser Bean = new Byte Array Output Stream ( ) ; Object Output Stream oos = new Object Output Stream ( ser Bean ) ; oos . write Object ( selected Bean ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; clear Selection ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; return ; } cut Bean = selected Bean ; selected Bean Box . show Cut ( selected Bean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; }
protected void cut Selected Bean ( ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; if ( selected Bean == null || selected Bean Location == null ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selected Bean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selected Bean Location ) ; clear Selection ( ) ; return ; } try { ser Bean = new Byte Array Output Stream ( ) ; Object Output Stream oos = new Object Output Stream ( ser Bean ) ; oos . write Object ( selected Bean ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; clear Selection ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; return ; } cut Bean = selected Bean ; selected Bean Box . show Cut ( selected Bean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; }
public void update Deltas ( int delta X , int delta Y ) { if ( m Left Border Active ) { m Delta X = Math . max ( - m Baseline X , delta X ) ; m Delta X = Math . min ( m Baseline Width - NUM * m Touch Target Width , m Delta X ) ; } else if ( m Right Border Active ) { m Delta X = Math . min ( m Drag Layer . get Width ( ) - ( m Baseline X + m Baseline Width ) , delta X ) ; m Delta X = Math . max ( - m Baseline Width + NUM * m Touch Target Width , m Delta X ) ; } if ( m Top Border Active ) { m Delta Y = Math . max ( - m Baseline Y , delta Y ) ; m Delta Y = Math . min ( m Baseline Height - NUM * m Touch Target Width , m Delta Y ) ; } else if ( m Bottom Border Active ) { m Delta Y = Math . min ( m Drag Layer . get Height ( ) - ( m Baseline Y + m Baseline Height ) , delta Y ) ; m Delta Y = Math . max ( - m Baseline Height + NUM * m Touch Target Width , m Delta Y ) ; } }
public static void dump ( Result Set rs ) throws SQL Exception { Result Set Meta Data md = rs . get Meta Data ( ) ; for ( int i = NUM ; i < md . get Column Count ( ) ; i ++ ) { int index = i + NUM ; String info = md . get Column Label ( index ) ; String name = md . get Column Name ( index ) ; if ( info == null ) info = name ; else if ( name != null && ! name . equals ( info ) ) info += STRING + name + STRING ; info += STRING + rs . get String ( index ) ; info += STRING + md . get Column Type Name ( index ) + STRING + md . get Precision ( index ) ; if ( md . get Scale ( index ) != NUM ) info += STRING + md . get Scale ( index ) ; info += STRING ; log . fine ( info ) ; } }
public final void add ( K key , V value ) { m Items . add ( new Item ( key , value ) ) ; m Sorted = BOOL ; }
public static byte [ ] convert Dsa ASN 1 to XMLDSIG ( byte [ ] asn 1 Bytes , int size ) throws IO Exception { if ( asn 1 Bytes [ NUM ] != NUM || asn 1 Bytes [ NUM ] != asn 1 Bytes . length - NUM || asn 1 Bytes [ NUM ] != NUM ) { throw new IO Exception ( STRING ) ; } byte r Length = asn 1 Bytes [ NUM ] ; int i ; for ( i = r Length ; i > NUM && asn 1 Bytes [ NUM + r Length - i ] == NUM ; i -- ) ; byte s Length = asn 1 Bytes [ NUM + r Length ] ; int j ; for ( j = s Length ; j > NUM && asn 1 Bytes [ NUM + r Length + s Length - j ] == NUM ; j -- ) ; if ( i > size || asn 1 Bytes [ NUM + r Length ] != NUM || j > size ) { throw new IO Exception ( STRING ) ; } else { byte [ ] xmldsig Bytes = new byte [ size * NUM ] ; System . arraycopy ( asn 1 Bytes , NUM + r Length - i , xmldsig Bytes , size - i , i ) ; System . arraycopy ( asn 1 Bytes , NUM + r Length + s Length - j , xmldsig Bytes , size * NUM - j , j ) ; return xmldsig Bytes ; } }
public static byte [ ] convert Dsa ASN 1 to XMLDSIG ( byte [ ] asn 1 Bytes , int size ) throws IO Exception { if ( asn 1 Bytes [ NUM ] != NUM || asn 1 Bytes [ NUM ] != asn 1 Bytes . length - NUM || asn 1 Bytes [ NUM ] != NUM ) { throw new IO Exception ( STRING ) ; } byte r Length = asn 1 Bytes [ NUM ] ; int i ; for ( i = r Length ; i > NUM && asn 1 Bytes [ NUM + r Length - i ] == NUM ; i -- ) ; byte s Length = asn 1 Bytes [ NUM + r Length ] ; int j ; for ( j = s Length ; j > NUM && asn 1 Bytes [ NUM + r Length + s Length - j ] == NUM ; j -- ) ; if ( i > size || asn 1 Bytes [ NUM + r Length ] != NUM || j > size ) { throw new IO Exception ( STRING ) ; } else { byte [ ] xmldsig Bytes = new byte [ size * NUM ] ; System . arraycopy ( asn 1 Bytes , NUM + r Length - i , xmldsig Bytes , size - i , i ) ; System . arraycopy ( asn 1 Bytes , NUM + r Length + s Length - j , xmldsig Bytes , size * NUM - j , j ) ; return xmldsig Bytes ; } }
public static byte [ ] convert Dsa ASN 1 to XMLDSIG ( byte [ ] asn 1 Bytes , int size ) throws IO Exception { if ( asn 1 Bytes [ NUM ] != NUM || asn 1 Bytes [ NUM ] != asn 1 Bytes . length - NUM || asn 1 Bytes [ NUM ] != NUM ) { throw new IO Exception ( STRING ) ; } byte r Length = asn 1 Bytes [ NUM ] ; int i ; for ( i = r Length ; i > NUM && asn 1 Bytes [ NUM + r Length - i ] == NUM ; i -- ) ; byte s Length = asn 1 Bytes [ NUM + r Length ] ; int j ; for ( j = s Length ; j > NUM && asn 1 Bytes [ NUM + r Length + s Length - j ] == NUM ; j -- ) ; if ( i > size || asn 1 Bytes [ NUM + r Length ] != NUM || j > size ) { throw new IO Exception ( STRING ) ; } else { byte [ ] xmldsig Bytes = new byte [ size * NUM ] ; System . arraycopy ( asn 1 Bytes , NUM + r Length - i , xmldsig Bytes , size - i , i ) ; System . arraycopy ( asn 1 Bytes , NUM + r Length + s Length - j , xmldsig Bytes , size * NUM - j , j ) ; return xmldsig Bytes ; } }
public static byte [ ] convert Dsa ASN 1 to XMLDSIG ( byte [ ] asn 1 Bytes , int size ) throws IO Exception { if ( asn 1 Bytes [ NUM ] != NUM || asn 1 Bytes [ NUM ] != asn 1 Bytes . length - NUM || asn 1 Bytes [ NUM ] != NUM ) { throw new IO Exception ( STRING ) ; } byte r Length = asn 1 Bytes [ NUM ] ; int i ; for ( i = r Length ; i > NUM && asn 1 Bytes [ NUM + r Length - i ] == NUM ; i -- ) ; byte s Length = asn 1 Bytes [ NUM + r Length ] ; int j ; for ( j = s Length ; j > NUM && asn 1 Bytes [ NUM + r Length + s Length - j ] == NUM ; j -- ) ; if ( i > size || asn 1 Bytes [ NUM + r Length ] != NUM || j > size ) { throw new IO Exception ( STRING ) ; } else { byte [ ] xmldsig Bytes = new byte [ size * NUM ] ; System . arraycopy ( asn 1 Bytes , NUM + r Length - i , xmldsig Bytes , size - i , i ) ; System . arraycopy ( asn 1 Bytes , NUM + r Length + s Length - j , xmldsig Bytes , size * NUM - j , j ) ; return xmldsig Bytes ; } }
public static byte [ ] convert Dsa ASN 1 to XMLDSIG ( byte [ ] asn 1 Bytes , int size ) throws IO Exception { if ( asn 1 Bytes [ NUM ] != NUM || asn 1 Bytes [ NUM ] != asn 1 Bytes . length - NUM || asn 1 Bytes [ NUM ] != NUM ) { throw new IO Exception ( STRING ) ; } byte r Length = asn 1 Bytes [ NUM ] ; int i ; for ( i = r Length ; i > NUM && asn 1 Bytes [ NUM + r Length - i ] == NUM ; i -- ) ; byte s Length = asn 1 Bytes [ NUM + r Length ] ; int j ; for ( j = s Length ; j > NUM && asn 1 Bytes [ NUM + r Length + s Length - j ] == NUM ; j -- ) ; if ( i > size || asn 1 Bytes [ NUM + r Length ] != NUM || j > size ) { throw new IO Exception ( STRING ) ; } else { byte [ ] xmldsig Bytes = new byte [ size * NUM ] ; System . arraycopy ( asn 1 Bytes , NUM + r Length - i , xmldsig Bytes , size - i , i ) ; System . arraycopy ( asn 1 Bytes , NUM + r Length + s Length - j , xmldsig Bytes , size * NUM - j , j ) ; return xmldsig Bytes ; } }
public void generate Loot Pot ( World world , Random random , Block Pos pos , int min , int max , Resource Location list ) { world . set Block State ( pos , get Random Loot Pot ( random ) , NUM ) ; Tile Entity Loot Pot loot Pot = ( Tile Entity Loot Pot ) world . get Tile Entity ( pos ) ; if ( loot Pot != null ) loot Pot . set Loot Table ( Loot Table Registry . COMMON CHEST LOOT , random . next Long ( ) ) ; }
public void generate Loot Pot ( World world , Random random , Block Pos pos , int min , int max , Resource Location list ) { world . set Block State ( pos , get Random Loot Pot ( random ) , NUM ) ; Tile Entity Loot Pot loot Pot = ( Tile Entity Loot Pot ) world . get Tile Entity ( pos ) ; if ( loot Pot != null ) loot Pot . set Loot Table ( Loot Table Registry . COMMON CHEST LOOT , random . next Long ( ) ) ; }
@ Suppress Warnings ( STRING ) public Selection Builder reset ( ) { m Table = null ; m Selection . set Length ( NUM ) ; m Selection Args . clear ( ) ; return this ; }
public static Object read ( Input Stream stream ) throws Exception { Class < ? > xstream Class ; java . lang . reflect . Constructor < ? > constructor ; Object xstream ; Class < ? > [ ] de Serialize Args Classes = new Class [ NUM ] ; Object [ ] de Serialize Args = new Object [ NUM ] ; java . lang . reflect . Method method De Serialize ; Object result ; xstream Class = Class . for Name ( STRING ) ; constructor = xstream Class . get Constructor ( ) ; xstream = constructor . new Instance ( ) ; de Serialize Args Classes [ NUM ] = Input Stream . class ; de Serialize Args [ NUM ] = stream ; method De Serialize = xstream Class . get Method ( STRING , de Serialize Args Classes ) ; try { result = method De Serialize . invoke ( xstream , de Serialize Args ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; result = null ; } return result ; }
@ Suppress Warnings ( STRING ) public void remove ( Menu Component popup ) { synchronized ( get Tree Lock ( ) ) { if ( popups == null ) { return ; } int index = popups . index Of ( popup ) ; if ( index >= NUM ) { Popup Menu pmenu = ( Popup Menu ) popup ; if ( pmenu . peer != null ) { pmenu . remove Notify ( ) ; } pmenu . parent = null ; popups . remove Element At ( index ) ; if ( popups . size ( ) == NUM ) { popups = null ; } } } }
public static Set < String > put Set Into Map ( String key , Map < String , Set < String > > map , String value ) { Set < String > set = new Hash Set < String > ( ) ; set . add ( value ) ; map . put ( key , set ) ; return set ; }
public static Set < String > put Set Into Map ( String key , Map < String , Set < String > > map , String value ) { Set < String > set = new Hash Set < String > ( ) ; set . add ( value ) ; map . put ( key , set ) ; return set ; }
public static Set < String > put Set Into Map ( String key , Map < String , Set < String > > map , String value ) { Set < String > set = new Hash Set < String > ( ) ; set . add ( value ) ; map . put ( key , set ) ; return set ; }
public static Set < String > put Set Into Map ( String key , Map < String , Set < String > > map , String value ) { Set < String > set = new Hash Set < String > ( ) ; set . add ( value ) ; map . put ( key , set ) ; return set ; }
public static boolean is Header ( Header hdr ) { return hdr . get Boolean Value ( ZIMAGE , BOOL ) ; }
public static boolean is Header ( Header hdr ) { return hdr . get Boolean Value ( ZIMAGE , BOOL ) ; }
protected final void clear Serialization Caches ( ) { try { clear Serialization Cache ( Class . for Name ( STRING ) , STRING ) ; clear Serialization Cache ( Class . for Name ( STRING ) , STRING ) ; clear Serialization Cache ( Class . for Name ( STRING ) , STRING ) ; clear Serialization Cache ( Class . for Name ( STRING ) , STRING ) ; } catch ( Class Not Found Exception e ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + e . get Message ( ) ) ; } catch ( No Such Field Exception e ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + e . get Message ( ) ) ; } catch ( Illegal Access Exception e ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + e . get Message ( ) ) ; } }
protected final void clear Serialization Caches ( ) { try { clear Serialization Cache ( Class . for Name ( STRING ) , STRING ) ; clear Serialization Cache ( Class . for Name ( STRING ) , STRING ) ; clear Serialization Cache ( Class . for Name ( STRING ) , STRING ) ; clear Serialization Cache ( Class . for Name ( STRING ) , STRING ) ; } catch ( Class Not Found Exception e ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + e . get Message ( ) ) ; } catch ( No Such Field Exception e ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + e . get Message ( ) ) ; } catch ( Illegal Access Exception e ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + e . get Message ( ) ) ; } }
private char read Escape Character ( ) throws JSON Exception { char escaped = in . char At ( pos ++ ) ; switch ( escaped ) { case STRING : if ( pos + NUM > in . length ( ) ) { throw syntax Error ( STRING ) ; } String hex = in . substring ( pos , pos + NUM ) ; pos += NUM ; try { return ( char ) Integer . parse Int ( hex , NUM ) ; } catch ( Number Format Exception nfe ) { throw syntax Error ( STRING + hex ) ; } case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private char read Escape Character ( ) throws JSON Exception { char escaped = in . char At ( pos ++ ) ; switch ( escaped ) { case STRING : if ( pos + NUM > in . length ( ) ) { throw syntax Error ( STRING ) ; } String hex = in . substring ( pos , pos + NUM ) ; pos += NUM ; try { return ( char ) Integer . parse Int ( hex , NUM ) ; } catch ( Number Format Exception nfe ) { throw syntax Error ( STRING + hex ) ; } case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private char read Escape Character ( ) throws JSON Exception { char escaped = in . char At ( pos ++ ) ; switch ( escaped ) { case STRING : if ( pos + NUM > in . length ( ) ) { throw syntax Error ( STRING ) ; } String hex = in . substring ( pos , pos + NUM ) ; pos += NUM ; try { return ( char ) Integer . parse Int ( hex , NUM ) ; } catch ( Number Format Exception nfe ) { throw syntax Error ( STRING + hex ) ; } case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private char read Escape Character ( ) throws JSON Exception { char escaped = in . char At ( pos ++ ) ; switch ( escaped ) { case STRING : if ( pos + NUM > in . length ( ) ) { throw syntax Error ( STRING ) ; } String hex = in . substring ( pos , pos + NUM ) ; pos += NUM ; try { return ( char ) Integer . parse Int ( hex , NUM ) ; } catch ( Number Format Exception nfe ) { throw syntax Error ( STRING + hex ) ; } case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private char read Escape Character ( ) throws JSON Exception { char escaped = in . char At ( pos ++ ) ; switch ( escaped ) { case STRING : if ( pos + NUM > in . length ( ) ) { throw syntax Error ( STRING ) ; } String hex = in . substring ( pos , pos + NUM ) ; pos += NUM ; try { return ( char ) Integer . parse Int ( hex , NUM ) ; } catch ( Number Format Exception nfe ) { throw syntax Error ( STRING + hex ) ; } case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private static boolean package Matches ( Resolve Info app , Process Error err ) { final String app Pkg = app . activity Info . package Name ; final String err Pkg = err . info . process Name ; Log . d ( TAG , String . format ( STRING , app Pkg , err Pkg ) ) ; return app Pkg . equals ( err Pkg ) ; }
private void update Range ( double x , double y ) { m Min X = Math . min ( m Min X , x ) ; m Max X = Math . max ( m Max X , x ) ; m Min Y = Math . min ( m Min Y , y ) ; m Max Y = Math . max ( m Max Y , y ) ; }
public static File create Temp Path ( String path ) throws IO Exception { String sep = File . separator ; File temp Dir = new File ( System . get Property ( STRING ) + sep + path ) ; if ( ! temp Dir . exists ( ) ) if ( ! temp Dir . mkdirs ( ) ) { boolean status = temp Dir . delete ( ) ; throw new IO Exception ( STRING + temp Dir + STRING + status ) ; } temp Dir . delete On Exit ( ) ; return temp Dir ; }
public Node text ( final String text ) throws IO Exception { close Head ( ) ; m writer . write ( cdata ( text ) ) ; m text ++ ; return this ; }
public Node text ( final String text ) throws IO Exception { close Head ( ) ; m writer . write ( cdata ( text ) ) ; m text ++ ; return this ; }
public Node text ( final String text ) throws IO Exception { close Head ( ) ; m writer . write ( cdata ( text ) ) ; m text ++ ; return this ; }
public Node text ( final String text ) throws IO Exception { close Head ( ) ; m writer . write ( cdata ( text ) ) ; m text ++ ; return this ; }
public Node text ( final String text ) throws IO Exception { close Head ( ) ; m writer . write ( cdata ( text ) ) ; m text ++ ; return this ; }
public Array Real Vector ( Array Real Vector v1 , Real Vector v2 ) { final int l1 = v1 . data . length ; final int l2 = v2 . get Dimension ( ) ; data = new double [ l1 + l2 ] ; System . arraycopy ( v1 . data , NUM , data , NUM , l1 ) ; for ( int i = NUM ; i < l2 ; ++ i ) { data [ l1 + i ] = v2 . get Entry ( i ) ; } }
public Array Real Vector ( Array Real Vector v1 , Real Vector v2 ) { final int l1 = v1 . data . length ; final int l2 = v2 . get Dimension ( ) ; data = new double [ l1 + l2 ] ; System . arraycopy ( v1 . data , NUM , data , NUM , l1 ) ; for ( int i = NUM ; i < l2 ; ++ i ) { data [ l1 + i ] = v2 . get Entry ( i ) ; } }
public Array Real Vector ( Array Real Vector v1 , Real Vector v2 ) { final int l1 = v1 . data . length ; final int l2 = v2 . get Dimension ( ) ; data = new double [ l1 + l2 ] ; System . arraycopy ( v1 . data , NUM , data , NUM , l1 ) ; for ( int i = NUM ; i < l2 ; ++ i ) { data [ l1 + i ] = v2 . get Entry ( i ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( get Cov Matrix ( ) == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( get Cov Matrix ( ) == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( get Cov Matrix ( ) == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( get Cov Matrix ( ) == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( get Cov Matrix ( ) == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( get Cov Matrix ( ) == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( get Cov Matrix ( ) == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( get Cov Matrix ( ) == null ) { throw new Null Pointer Exception ( ) ; } }
protected Worker Thread ( ) { super ( Control Thread . get Worker Thread Group ( ) , STRING ) ; threadnum = next Thread Num . get And Increment ( ) ; }
public static boolean is Nested Mapping ( String regex ) { return regex . starts With ( NESTED MAPPING STARTS SYMBOL ) && regex . ends With ( NESTED MAPPING ENDS SYMBOL ) ; }
public static boolean is Nested Mapping ( String regex ) { return regex . starts With ( NESTED MAPPING STARTS SYMBOL ) && regex . ends With ( NESTED MAPPING ENDS SYMBOL ) ; }
public Iterator < Method > called Method Iterator ( ) { return called Method Set . iterator ( ) ; }
public Iterator < Method > called Method Iterator ( ) { return called Method Set . iterator ( ) ; }
static String value To String ( Object value ) throws JSON Exception { if ( value == null ) { return STRING ; } if ( value instanceof Number ) { return number To String ( ( Number ) value ) ; } if ( value instanceof Boolean || value instanceof JSON Object || value instanceof JSON Array ) { return value . to String ( ) ; } return quote ( value . to String ( ) ) ; }
static String value To String ( Object value ) throws JSON Exception { if ( value == null ) { return STRING ; } if ( value instanceof Number ) { return number To String ( ( Number ) value ) ; } if ( value instanceof Boolean || value instanceof JSON Object || value instanceof JSON Array ) { return value . to String ( ) ; } return quote ( value . to String ( ) ) ; }
public void draw Glyph Vector ( Glyph Vector g , float x , float y ) { Rectangle 2 D bbox = g . get Logical Bounds ( ) ; add Drawing Rect ( bbox , x , y ) ; m Print Metrics . draw Text ( this ) ; }
public void draw Glyph Vector ( Glyph Vector g , float x , float y ) { Rectangle 2 D bbox = g . get Logical Bounds ( ) ; add Drawing Rect ( bbox , x , y ) ; m Print Metrics . draw Text ( this ) ; }
public void draw Glyph Vector ( Glyph Vector g , float x , float y ) { Rectangle 2 D bbox = g . get Logical Bounds ( ) ; add Drawing Rect ( bbox , x , y ) ; m Print Metrics . draw Text ( this ) ; }
public Out Segment ( Table Kelp table , Page Service Sync table Service , Table Writer Service Impl read Write , Segment Kelp segment ) { Objects . require Non Null ( table ) ; Objects . require Non Null ( table Service ) ; Objects . require Non Null ( read Write ) ; Objects . require Non Null ( segment ) ; table = table ; read Write = read Write ; segment = segment ; if ( ! segment . is Writing ( ) ) { throw new Illegal State Exception ( String . value Of ( segment ) ) ; } index Temp Buf = Temp Buffer . create Large ( ) ; index Buffer = index Temp Buf . buffer ( ) ; index Address = segment . length ( ) - BLOCK SIZE ; fill Header ( ) ; compressor = read Write . compressor ( ) ; s Out = read Write . open Write ( segment . extent ( ) ) ; }
public void append Before ( String Builder sb ) { if ( before != null ) { sb . append ( before ) ; } }
public void append Before ( String Builder sb ) { if ( before != null ) { sb . append ( before ) ; } }
public static boolean is Use String Width ( ) { return use String Width ; }
public static boolean is Use String Width ( ) { return use String Width ; }
public static boolean is Use String Width ( ) { return use String Width ; }
public static boolean is Use String Width ( ) { return use String Width ; }
public static boolean is Use String Width ( ) { return use String Width ; }
public static boolean is Use String Width ( ) { return use String Width ; }
public Message Property Key ( String description , Integer ordinal ) { this . description = description ; this . ordinal = ordinal ; }
List < String > find In Package ( Test test , String package Name ) { List < String > local Clsss Or Pkgs = new Array List < String > ( ) ; package Name = package Name . replace ( STRING , STRING ) ; Enumeration < URL > urls ; try { urls = classloader . get Resources ( package Name ) ; if ( ! urls . has More Elements ( ) ) { log . warn ( STRING + package Name + STRING ) ; } } catch ( IO Exception ioe ) { log . warn ( STRING + package Name ) ; return local Clsss Or Pkgs ; } return find In Package With Urls ( test , package Name , urls ) ; }
List < String > find In Package ( Test test , String package Name ) { List < String > local Clsss Or Pkgs = new Array List < String > ( ) ; package Name = package Name . replace ( STRING , STRING ) ; Enumeration < URL > urls ; try { urls = classloader . get Resources ( package Name ) ; if ( ! urls . has More Elements ( ) ) { log . warn ( STRING + package Name + STRING ) ; } } catch ( IO Exception ioe ) { log . warn ( STRING + package Name ) ; return local Clsss Or Pkgs ; } return find In Package With Urls ( test , package Name , urls ) ; }
List < String > find In Package ( Test test , String package Name ) { List < String > local Clsss Or Pkgs = new Array List < String > ( ) ; package Name = package Name . replace ( STRING , STRING ) ; Enumeration < URL > urls ; try { urls = classloader . get Resources ( package Name ) ; if ( ! urls . has More Elements ( ) ) { log . warn ( STRING + package Name + STRING ) ; } } catch ( IO Exception ioe ) { log . warn ( STRING + package Name ) ; return local Clsss Or Pkgs ; } return find In Package With Urls ( test , package Name , urls ) ; }
public boolean check Pos Constraint ( Sentence s , String pos Constraint , Match Result m , J Cas jcas ) { Pattern pa Constraint = Pattern . compile ( STRING ) ; for ( Match Result mr : Toolbox . find Matches ( pa Constraint , pos Constraint ) ) { int group Number = Integer . parse Int ( mr . group ( NUM ) ) ; int token Begin = s . get Begin ( ) + m . start ( group Number ) ; int token End = s . get Begin ( ) + m . end ( group Number ) ; String pos = mr . group ( NUM ) ; String pos as is = get Pos From Match Result ( token Begin , token End , s , jcas ) ; if ( pos as is . matches ( pos ) ) { Logger . print Detail ( STRING + pos + STRING + pos as is ) ; } else { return BOOL ; } } return BOOL ; }
public void dispose ( ) { set Map Bean ( null ) ; set Layout ( null ) ; remove All ( ) ; }
public void dispose ( ) { set Map Bean ( null ) ; set Layout ( null ) ; remove All ( ) ; }
private Server Pod [ ] build Cluster Servers ( Cluster Heartbeat cluster , int server Count ) { Array List < Server Pod > servers Pod = new Array List < > ( ) ; for ( Server Heartbeat server : cluster . get Servers ( ) ) { Server Pod server Pod = new Server Pod ( servers Pod . size ( ) ) ; servers Pod . add ( server Pod ) ; server Pod . set Server ( server ) ; } while ( servers Pod . size ( ) < server Count ) { servers Pod . add ( new Server Pod ( servers Pod . size ( ) ) ) ; } Server Pod [ ] server Array = new Server Pod [ server Count ] ; for ( int i = NUM ; i < server Count ; i ++ ) { server Array [ i ] = servers Pod . get ( i ) ; } return server Array ; }
private Server Pod [ ] build Cluster Servers ( Cluster Heartbeat cluster , int server Count ) { Array List < Server Pod > servers Pod = new Array List < > ( ) ; for ( Server Heartbeat server : cluster . get Servers ( ) ) { Server Pod server Pod = new Server Pod ( servers Pod . size ( ) ) ; servers Pod . add ( server Pod ) ; server Pod . set Server ( server ) ; } while ( servers Pod . size ( ) < server Count ) { servers Pod . add ( new Server Pod ( servers Pod . size ( ) ) ) ; } Server Pod [ ] server Array = new Server Pod [ server Count ] ; for ( int i = NUM ; i < server Count ; i ++ ) { server Array [ i ] = servers Pod . get ( i ) ; } return server Array ; }
private Server Pod [ ] build Cluster Servers ( Cluster Heartbeat cluster , int server Count ) { Array List < Server Pod > servers Pod = new Array List < > ( ) ; for ( Server Heartbeat server : cluster . get Servers ( ) ) { Server Pod server Pod = new Server Pod ( servers Pod . size ( ) ) ; servers Pod . add ( server Pod ) ; server Pod . set Server ( server ) ; } while ( servers Pod . size ( ) < server Count ) { servers Pod . add ( new Server Pod ( servers Pod . size ( ) ) ) ; } Server Pod [ ] server Array = new Server Pod [ server Count ] ; for ( int i = NUM ; i < server Count ; i ++ ) { server Array [ i ] = servers Pod . get ( i ) ; } return server Array ; }
private Server Pod [ ] build Cluster Servers ( Cluster Heartbeat cluster , int server Count ) { Array List < Server Pod > servers Pod = new Array List < > ( ) ; for ( Server Heartbeat server : cluster . get Servers ( ) ) { Server Pod server Pod = new Server Pod ( servers Pod . size ( ) ) ; servers Pod . add ( server Pod ) ; server Pod . set Server ( server ) ; } while ( servers Pod . size ( ) < server Count ) { servers Pod . add ( new Server Pod ( servers Pod . size ( ) ) ) ; } Server Pod [ ] server Array = new Server Pod [ server Count ] ; for ( int i = NUM ; i < server Count ; i ++ ) { server Array [ i ] = servers Pod . get ( i ) ; } return server Array ; }
private Server Pod [ ] build Cluster Servers ( Cluster Heartbeat cluster , int server Count ) { Array List < Server Pod > servers Pod = new Array List < > ( ) ; for ( Server Heartbeat server : cluster . get Servers ( ) ) { Server Pod server Pod = new Server Pod ( servers Pod . size ( ) ) ; servers Pod . add ( server Pod ) ; server Pod . set Server ( server ) ; } while ( servers Pod . size ( ) < server Count ) { servers Pod . add ( new Server Pod ( servers Pod . size ( ) ) ) ; } Server Pod [ ] server Array = new Server Pod [ server Count ] ; for ( int i = NUM ; i < server Count ; i ++ ) { server Array [ i ] = servers Pod . get ( i ) ; } return server Array ; }
public Rest Controller Processor ( Log log , Swagger swagger , String rest Java Package , String tag Pattern Template , Class < ? > model Error Class ) throws Mojo Execution Exception { this . log = log ; this . swagger = swagger ; this . rest Java Package = rest Java Package ; this . model Error Class = model Error Class ; tag Pattern = Pattern . compile ( tag Pattern Template ) ; find And Process Rest Controllers ( ) ; }
public Rest Controller Processor ( Log log , Swagger swagger , String rest Java Package , String tag Pattern Template , Class < ? > model Error Class ) throws Mojo Execution Exception { this . log = log ; this . swagger = swagger ; this . rest Java Package = rest Java Package ; this . model Error Class = model Error Class ; tag Pattern = Pattern . compile ( tag Pattern Template ) ; find And Process Rest Controllers ( ) ; }
public Rest Controller Processor ( Log log , Swagger swagger , String rest Java Package , String tag Pattern Template , Class < ? > model Error Class ) throws Mojo Execution Exception { this . log = log ; this . swagger = swagger ; this . rest Java Package = rest Java Package ; this . model Error Class = model Error Class ; tag Pattern = Pattern . compile ( tag Pattern Template ) ; find And Process Rest Controllers ( ) ; }
public boolean is Signature Valid ( ) { return EC Key . verify ( Sha 256 Hash . hash Twice ( content ) , signature , params . get Alert Signing Key ( ) ) ; }
public boolean is Signature Valid ( ) { return EC Key . verify ( Sha 256 Hash . hash Twice ( content ) , signature , params . get Alert Signing Key ( ) ) ; }
public boolean is Signature Valid ( ) { return EC Key . verify ( Sha 256 Hash . hash Twice ( content ) , signature , params . get Alert Signing Key ( ) ) ; }
public boolean is Signature Valid ( ) { return EC Key . verify ( Sha 256 Hash . hash Twice ( content ) , signature , params . get Alert Signing Key ( ) ) ; }
public boolean is Signature Valid ( ) { return EC Key . verify ( Sha 256 Hash . hash Twice ( content ) , signature , params . get Alert Signing Key ( ) ) ; }
public boolean is Signature Valid ( ) { return EC Key . verify ( Sha 256 Hash . hash Twice ( content ) , signature , params . get Alert Signing Key ( ) ) ; }
public List < Edx Local Parse Channel > filter For Inactive Courses ( List < Course Entry > course Entry List ) { Set < String > active Course List = new Hash Set < > ( ) ; for ( Course Entry entry : course Entry List ) { active Course List . add ( entry . get Id ( ) ) ; } List < Edx Local Parse Channel > inactive Course List = new Linked List < Edx Local Parse Channel > ( ) ; for ( Edx Local Parse Channel pc : this ) { if ( ! active Course List . contains ( pc . get Course Id ( ) ) ) { inactive Course List . add ( pc ) ; } } return inactive Course List ; }
public void append Cell ( double value ) { append Cell ( String . value Of ( value ) ) ; }
public static < T > T parse ( Input Stream xml , String xml Path , String [ ] xsds , String pkg , Class < T > result Class ) throws Xml Parsing Exception { try { JAXB Context jaxb Context = JAXB Context . new Instance ( pkg ) ; Unmarshaller unmarshaller = jaxb Context . create Unmarshaller ( ) ; Unmarshaller Handler unmarshaller Handler = unmarshaller . get Unmarshaller Handler ( ) ; Xml Parsing Handler content Error Handler = new Xml Parsing Handler Wrapper ( unmarshaller Handler , xml Path ) ; do Parse ( xml , xsds , content Error Handler ) ; Object result = JAXB Introspector . get Value ( unmarshaller Handler . get Result ( ) ) ; if ( ! result Class . is Instance ( result ) ) { throw new Runtime Exception ( String . format ( STRING , xml Path , result Class . get Simple Name ( ) ) ) ; } return ( T ) result ; } catch ( JAXB Exception e ) { throw new Runtime Exception ( e ) ; } }
public static < T > T parse ( Input Stream xml , String xml Path , String [ ] xsds , String pkg , Class < T > result Class ) throws Xml Parsing Exception { try { JAXB Context jaxb Context = JAXB Context . new Instance ( pkg ) ; Unmarshaller unmarshaller = jaxb Context . create Unmarshaller ( ) ; Unmarshaller Handler unmarshaller Handler = unmarshaller . get Unmarshaller Handler ( ) ; Xml Parsing Handler content Error Handler = new Xml Parsing Handler Wrapper ( unmarshaller Handler , xml Path ) ; do Parse ( xml , xsds , content Error Handler ) ; Object result = JAXB Introspector . get Value ( unmarshaller Handler . get Result ( ) ) ; if ( ! result Class . is Instance ( result ) ) { throw new Runtime Exception ( String . format ( STRING , xml Path , result Class . get Simple Name ( ) ) ) ; } return ( T ) result ; } catch ( JAXB Exception e ) { throw new Runtime Exception ( e ) ; } }
@ Deprecated protected void draw Multi Line Text Appearance ( Rectangle rect , Pdf Font font , int font Size , String value , Pdf Form X Object appearance ) { draw Multi Line Text Appearance ( rect , font , ( float ) font Size , value , appearance ) ; }
public C Database Configuration ( final I Database database , final Listener Provider < I Database Listener > listeners , final String description , final String driver , final String host , final String name , final String user , final String password , final String identity , final boolean auto Connect , final boolean save Password ) { m database = Preconditions . check Not Null ( database , STRING ) ; m listeners = Preconditions . check Not Null ( listeners , STRING ) ; m description = Preconditions . check Not Null ( description , STRING ) ; m driver = Preconditions . check Not Null ( driver , STRING ) ; m host = Preconditions . check Not Null ( host , STRING ) ; m name = Preconditions . check Not Null ( name , STRING ) ; m user = Preconditions . check Not Null ( user , STRING ) ; m password = Preconditions . check Not Null ( password , STRING ) ; m identity = Preconditions . check Not Null ( identity , STRING ) ; if ( m identity . is Empty ( ) ) { m identity = STRING ; } m auto Connect = auto Connect ; m save Password = save Password ; }
public boolean has Items ( ) { return items != null && ! items . is Empty ( ) ; }
public boolean has Items ( ) { return items != null && ! items . is Empty ( ) ; }
public void remove Attribute ( int index ) { if ( index >= NUM && index < length ) { if ( index < length - NUM ) { System . arraycopy ( data , ( index + NUM ) * NUM , data , index * NUM , ( length - index - NUM ) * NUM ) ; } index = ( length - NUM ) * NUM ; data [ index ++ ] = null ; data [ index ++ ] = null ; data [ index ++ ] = null ; data [ index ++ ] = null ; data [ index ] = null ; length -- ; } else { bad Index ( index ) ; } }
private static int end Of Tag Match ( String string , int from Index , String tag ) { int pos = string . index Of ( tag , from Index ) ; if ( pos != - NUM ) { while ( pos < string . length ( ) && Character . is Whitespace ( string . char At ( pos ) ) ) pos ++ ; return pos + tag . length ( ) ; } if ( tag . contains ( STRING ) ) { tag = tag . replace All ( STRING , STRING ) ; pos = string . index Of ( tag ) ; if ( pos != - NUM ) { while ( pos < string . length ( ) && Character . is Whitespace ( string . char At ( pos ) ) ) pos ++ ; return pos + tag . length ( ) ; } } return - NUM ; }
private static int end Of Tag Match ( String string , int from Index , String tag ) { int pos = string . index Of ( tag , from Index ) ; if ( pos != - NUM ) { while ( pos < string . length ( ) && Character . is Whitespace ( string . char At ( pos ) ) ) pos ++ ; return pos + tag . length ( ) ; } if ( tag . contains ( STRING ) ) { tag = tag . replace All ( STRING , STRING ) ; pos = string . index Of ( tag ) ; if ( pos != - NUM ) { while ( pos < string . length ( ) && Character . is Whitespace ( string . char At ( pos ) ) ) pos ++ ; return pos + tag . length ( ) ; } } return - NUM ; }
private J Menu create View Menu ( ) { J Menu view Menu = new J Menu ( STRING ) ; view Menu . add ( action Manager . get Property Tab Action ( ) ) ; view Menu . add Separator ( ) ; view Menu . add ( new J Menu Item ( action Manager . get Reposition All Windows Action ( ) ) ) ; return view Menu ; }
public Shape create Scroll Cap ( int x , int y , int w , int h ) { path . reset ( ) ; path . move To ( x , y ) ; path . line To ( x , y + h ) ; path . line To ( x + w , y + h ) ; add Scroll Gap Path ( x , y , w , h , BOOL ) ; path . close Path ( ) ; return path ; }
public Shape create Scroll Cap ( int x , int y , int w , int h ) { path . reset ( ) ; path . move To ( x , y ) ; path . line To ( x , y + h ) ; path . line To ( x + w , y + h ) ; add Scroll Gap Path ( x , y , w , h , BOOL ) ; path . close Path ( ) ; return path ; }
public Shape create Scroll Cap ( int x , int y , int w , int h ) { path . reset ( ) ; path . move To ( x , y ) ; path . line To ( x , y + h ) ; path . line To ( x + w , y + h ) ; add Scroll Gap Path ( x , y , w , h , BOOL ) ; path . close Path ( ) ; return path ; }
public static String quoted String ( String str ) { if ( str == null ) { return null ; } String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) { char ch = str . char At ( i ) ; if ( ( ch == STRING ) || ( ch == STRING ) ) { if ( ( i > NUM ) && ( str . char At ( i - NUM ) != STRING ) ) { sb . append ( STRING ) ; } else if ( i == NUM ) { sb . append ( STRING ) ; } } sb . append ( ch ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
public int current As Target ( ) { return current As Target . get ( ) ; }
private static float fuzz Aspect Ratio ( float aspect Ratio ) { for ( float desired Aspect Ratio : s Desired Aspect Ratios ) { if ( ( Math . abs ( aspect Ratio - desired Aspect Ratio ) ) < ASPECT RATIO TOLERANCE ) { return desired Aspect Ratio ; } } return aspect Ratio ; }
public Key Info to DTO ( ) { return new Key Info ( available , usage , friendly Name , id , public Key , Collections . unmodifiable List ( get Certs As DT Os ( ) ) , Collections . unmodifiable List ( get Cert Requests As DT Os ( ) ) ) ; }
public Key Info to DTO ( ) { return new Key Info ( available , usage , friendly Name , id , public Key , Collections . unmodifiable List ( get Certs As DT Os ( ) ) , Collections . unmodifiable List ( get Cert Requests As DT Os ( ) ) ) ; }
public void add Layers To Bean Context ( List < Layer > layers ) { Bean Context bc = get Bean Context ( ) ; if ( bc == null || layers == null ) { return ; } for ( Layer layer : layers ) { if ( layer . get Add To Bean Context ( ) && layer . get Bean Context ( ) == null ) { bc . add ( layer ) ; } } }
public void add Layers To Bean Context ( List < Layer > layers ) { Bean Context bc = get Bean Context ( ) ; if ( bc == null || layers == null ) { return ; } for ( Layer layer : layers ) { if ( layer . get Add To Bean Context ( ) && layer . get Bean Context ( ) == null ) { bc . add ( layer ) ; } } }
public void add Layers To Bean Context ( List < Layer > layers ) { Bean Context bc = get Bean Context ( ) ; if ( bc == null || layers == null ) { return ; } for ( Layer layer : layers ) { if ( layer . get Add To Bean Context ( ) && layer . get Bean Context ( ) == null ) { bc . add ( layer ) ; } } }
public void add Layers To Bean Context ( List < Layer > layers ) { Bean Context bc = get Bean Context ( ) ; if ( bc == null || layers == null ) { return ; } for ( Layer layer : layers ) { if ( layer . get Add To Bean Context ( ) && layer . get Bean Context ( ) == null ) { bc . add ( layer ) ; } } }
public void add Layers To Bean Context ( List < Layer > layers ) { Bean Context bc = get Bean Context ( ) ; if ( bc == null || layers == null ) { return ; } for ( Layer layer : layers ) { if ( layer . get Add To Bean Context ( ) && layer . get Bean Context ( ) == null ) { bc . add ( layer ) ; } } }
private final long logarithmic Distribution ( long mean , long max ) { final double x = local Random . next Double ( ) ; if ( x == NUM ) { return max ; } return Math . min ( ( long ) ( mean * - Math . log ( x ) ) , max ) ; }
private final long logarithmic Distribution ( long mean , long max ) { final double x = local Random . next Double ( ) ; if ( x == NUM ) { return max ; } return Math . min ( ( long ) ( mean * - Math . log ( x ) ) , max ) ; }
private final long logarithmic Distribution ( long mean , long max ) { final double x = local Random . next Double ( ) ; if ( x == NUM ) { return max ; } return Math . min ( ( long ) ( mean * - Math . log ( x ) ) , max ) ; }
public boolean union ( RW Set other ) { throw new Runtime Exception ( STRING ) ; }
@ Override public Basic Block next Element ( ) { Basic Block result = blocks . get ( current Block ) ; current Block ++ ; return result ; }
@ Override public Basic Block next Element ( ) { Basic Block result = blocks . get ( current Block ) ; current Block ++ ; return result ; }
@ Override public Basic Block next Element ( ) { Basic Block result = blocks . get ( current Block ) ; current Block ++ ; return result ; }
private boolean add State ( long state Number ) { if ( first State < NUM ) { first State = state Number ; } else if ( step Size < NUM ) { step Size = ( int ) ( state Number - first State ) ; } else { int step = ( int ) ( state Number - last State ) ; if ( step != step Size ) { return BOOL ; } } last State = state Number ; return BOOL ; }
private boolean add State ( long state Number ) { if ( first State < NUM ) { first State = state Number ; } else if ( step Size < NUM ) { step Size = ( int ) ( state Number - first State ) ; } else { int step = ( int ) ( state Number - last State ) ; if ( step != step Size ) { return BOOL ; } } last State = state Number ; return BOOL ; }
private void log Exception ( Throwable t , String url ) { log . log ( String . format ( STRING , url ) ) ; String Writer sw = new String Writer ( ) ; t . print Stack Trace ( new Print Writer ( sw ) ) ; log . log ( sw . to String ( ) ) ; log . log ( STRING ) ; }
private void validate Cloumns ( Map < String , Object > column Name To Type Map ) { if ( column Name To Type Map == null ) { throw new Illegal Argument Exception ( STRING ) ; } for ( Map . Entry < String , Object > entry : column Name To Type Map . entry Set ( ) ) { Object obj Value = entry . get Value ( ) ; if ( obj Value == null ) { throw new Illegal Argument Exception ( STRING + entry . get Key ( ) + STRING ) ; } if ( obj Value instanceof Class < ? > ) { continue ; } if ( obj Value instanceof String ) { try { entry . set Value ( Class . for Name ( ( String ) obj Value ) ) ; } catch ( Class Not Found Exception e ) { throw new Illegal Argument Exception ( STRING , e ) ; } } } }
public void add String ( String s , String encoding ) { if ( encoding == null || encoding . equals ( STRING ) ) { add String ( s ) ; return ; } byte [ ] bytes = null ; try { bytes = s . get Bytes ( encoding ) ; } catch ( Unsupported Encoding Exception e ) { add String ( s ) ; return ; } int len = bytes . length ; if ( len + length > capacity ) ensure Capacity ( length + len ) ; for ( int i = NUM ; i < len ; i ++ ) buffer [ length ++ ] = bytes [ i ] ; }
protected void release Block ( O Block block , int idx ) { idx Last Order = idx ; fire Property Change ( STRING , null , block ) ; for ( int i = idx ; i > - NUM ; i -- ) { boolean dealloc = BOOL ; O Block prev Block = get Block At ( i ) ; for ( int j = i + NUM ; j < orders . size ( ) ; j ++ ) { if ( prev Block . equals ( get Block At ( j ) ) ) { dealloc = BOOL ; } } if ( dealloc ) { prev Block . set Value ( null ) ; prev Block . de Allocate ( this ) ; } } }
public void remove Marker ( final Marker MARKER ) { if ( null == MARKER ) return ; markers . remove ( MARKER ) ; Collections . sort ( markers , new Marker Comparator ( ) ) ; fire Update Event ( REDRAW EVENT ) ; }
protected long scale Time ( int req Sample Rate , long target Time In Samples ) { if ( req Sample Rate == sample Rate ) return ( target Time In Samples ) ; return ( Math . round ( ( double ) ( req Sample Rate ) * ( double ) ( target Time In Samples ) / ( sample Rate ) ) ) ; }
protected long scale Time ( int req Sample Rate , long target Time In Samples ) { if ( req Sample Rate == sample Rate ) return ( target Time In Samples ) ; return ( Math . round ( ( double ) ( req Sample Rate ) * ( double ) ( target Time In Samples ) / ( sample Rate ) ) ) ; }
public static < C extends Configuration Client , S extends Configuration > Create Sub Command Handler < C , S > create ( Sub Command Argument Parser parser , Managed Object Path < ? , ? > p , Set Relation Definition < C , S > r ) throws Argument Exception { return new Create Sub Command Handler < > ( parser , p , r , null , p . child ( r ) ) ; }
public List < Method Node > handle Missing Method ( Class Node receiver , String name , Argument List Expression argument List , Class Node [ ] argument Types , Method Call call ) { return Collections . empty List ( ) ; }
public List < Method Node > handle Missing Method ( Class Node receiver , String name , Argument List Expression argument List , Class Node [ ] argument Types , Method Call call ) { return Collections . empty List ( ) ; }
@ Override protected void key Typed ( char par 1 , int par 2 ) { }
public void override Current Time ( long time ) { start Time = System . current Time Millis ( ) ; current Time = NUM ; stored Time = time ; }
private Immutable List < String > save Files On Disk ( Immutable Map < String , String > swagger File Path To Content Map ) { List < String > savedfile Paths = new Array List < > ( ) ; File temp Dir = Files . create Temp Dir ( ) ; String tmp Dir Location = temp Dir . get Absolute Path ( ) ; for ( Entry < String , String > entry : swagger File Path To Content Map . entry Set ( ) ) { String file Path = entry . get Key ( ) ; String file Content = entry . get Value ( ) ; Preconditions . check State ( ! Strings . is Null Or Empty ( file Content ) , STRING ) ; Preconditions . check State ( ! Strings . is Null Or Empty ( file Path ) , STRING ) ; String file Path To Save = File . separator + tmp Dir Location + File . separator + STRING + File . separator + file Path ; try { String saved File Path = save File On Disk ( file Path To Save , file Content ) ; savedfile Paths . add ( saved File Path ) ; } catch ( IO Exception e ) { throw new Illegal State Exception ( String . format ( STRING , file Path To Save ) , e ) ; } } return Immutable List . copy Of ( savedfile Paths ) ; }
private Immutable List < String > save Files On Disk ( Immutable Map < String , String > swagger File Path To Content Map ) { List < String > savedfile Paths = new Array List < > ( ) ; File temp Dir = Files . create Temp Dir ( ) ; String tmp Dir Location = temp Dir . get Absolute Path ( ) ; for ( Entry < String , String > entry : swagger File Path To Content Map . entry Set ( ) ) { String file Path = entry . get Key ( ) ; String file Content = entry . get Value ( ) ; Preconditions . check State ( ! Strings . is Null Or Empty ( file Content ) , STRING ) ; Preconditions . check State ( ! Strings . is Null Or Empty ( file Path ) , STRING ) ; String file Path To Save = File . separator + tmp Dir Location + File . separator + STRING + File . separator + file Path ; try { String saved File Path = save File On Disk ( file Path To Save , file Content ) ; savedfile Paths . add ( saved File Path ) ; } catch ( IO Exception e ) { throw new Illegal State Exception ( String . format ( STRING , file Path To Save ) , e ) ; } } return Immutable List . copy Of ( savedfile Paths ) ; }
public void notify Changed Slot ( Loco Net Slot s ) { if ( s . get Slot ( ) != Ln Constants . FC SLOT ) { return ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + s ) ; } days . set Text ( STRING + s . get Fc Days ( ) ) ; hours . set Text ( STRING + s . get Fc Hours ( ) ) ; minutes . set Text ( STRING + s . get Fc Minutes ( ) ) ; rate . set Text ( STRING + s . get Fc Rate ( ) ) ; frac mins . set Text ( STRING + s . get Fc Frac Mins ( ) ) ; }
public static boolean is Magic ( String path ) { return COMMIT MSG . equals ( path ) || MERGE LIST . equals ( path ) ; }
public static boolean is Magic ( String path ) { return COMMIT MSG . equals ( path ) || MERGE LIST . equals ( path ) ; }
public static boolean is Magic ( String path ) { return COMMIT MSG . equals ( path ) || MERGE LIST . equals ( path ) ; }
public static boolean is Magic ( String path ) { return COMMIT MSG . equals ( path ) || MERGE LIST . equals ( path ) ; }
public static boolean is Magic ( String path ) { return COMMIT MSG . equals ( path ) || MERGE LIST . equals ( path ) ; }
public static void add Combo Box ( final J Panel panel , final J Combo Box < String > combo Box , final String description , final String hint , final String [ ] values , final int selected Option ) { Preconditions . check Not Null ( panel , STRING ) ; Preconditions . check Not Null ( combo Box , STRING ) ; Preconditions . check Not Null ( description , STRING ) ; Preconditions . check Not Null ( values , STRING ) ; for ( final String string : values ) { combo Box . add Item ( string ) ; } combo Box . set Selected Index ( selected Option ) ; combo Box . set Preferred Size ( new Dimension ( PREFERRED WIDTH , PREFERRED HEIGHT ) ) ; add Component ( panel , combo Box , description , hint ) ; }
public static int find End Of String ( String str , int loc , int line ) throws Parse Algorithm Exception { int pos = loc + NUM ; boolean found = BOOL ; while ( ( ! found ) && ( pos < str . length ( ) ) ) { char c = str . char At ( pos ) ; if ( c == STRING ) { found = BOOL ; } else if ( c == STRING && ( pos < str . length ( ) - NUM ) ) { pos ++ ; } pos ++ ; } if ( ! found ) { throw new Parse Algorithm Exception ( STRING + STRING + ( line + NUM ) + STRING + ( loc + NUM ) ) ; } return pos ; }
public static int find End Of String ( String str , int loc , int line ) throws Parse Algorithm Exception { int pos = loc + NUM ; boolean found = BOOL ; while ( ( ! found ) && ( pos < str . length ( ) ) ) { char c = str . char At ( pos ) ; if ( c == STRING ) { found = BOOL ; } else if ( c == STRING && ( pos < str . length ( ) - NUM ) ) { pos ++ ; } pos ++ ; } if ( ! found ) { throw new Parse Algorithm Exception ( STRING + STRING + ( line + NUM ) + STRING + ( loc + NUM ) ) ; } return pos ; }
public static I View Part open View No Focus ( final String view Id ) { return open View No Focus ( view Id , null ) ; }
public static I View Part open View No Focus ( final String view Id ) { return open View No Focus ( view Id , null ) ; }
public static I View Part open View No Focus ( final String view Id ) { return open View No Focus ( view Id , null ) ; }
public static I View Part open View No Focus ( final String view Id ) { return open View No Focus ( view Id , null ) ; }
public static I View Part open View No Focus ( final String view Id ) { return open View No Focus ( view Id , null ) ; }
public static I View Part open View No Focus ( final String view Id ) { return open View No Focus ( view Id , null ) ; }
@ On Message public void on Message ( Byte Buffer buffer ) { if ( message Handler != null ) { message Handler . handle Message ( buffer ) ; } fire WS Heart Bit Monitor Timer ( ) ; }
@ On Message public void on Message ( Byte Buffer buffer ) { if ( message Handler != null ) { message Handler . handle Message ( buffer ) ; } fire WS Heart Bit Monitor Timer ( ) ; }
@ On Message public void on Message ( Byte Buffer buffer ) { if ( message Handler != null ) { message Handler . handle Message ( buffer ) ; } fire WS Heart Bit Monitor Timer ( ) ; }
private Value Range range By Week ( Temporal Accessor temporal , Temporal Field field ) { int dow = localized Day Of Week ( temporal ) ; int offset = start Of Week Offset ( temporal . get ( field ) , dow ) ; Value Range field Range = temporal . range ( field ) ; return Value Range . of ( compute Week ( offset , ( int ) field Range . get Minimum ( ) ) , compute Week ( offset , ( int ) field Range . get Maximum ( ) ) ) ; }
public static String map Module ( String directory ) throws File Not Found Exception , Json Parser Exception { Script Engine engine = Java Script . get Engine ( ) ; if ( engine . get ( STRING ) == null ) engine . put ( STRING , new Hash Map < String , File > ( ) ) ; return map Module ( new File ( directory ) , ( Hash Map < String , File > ) engine . get ( STRING ) ) ; }
public Circular Char Array Buffer ( int max Char ) { buffer = new char [ max Char ] ; if ( DEBUG ) Arrays . fill ( buffer , STRING ) ; }
private static Array List < IV Combination > find IV Intersection ( IV Scan Result poke 1 , IV Scan Result poke 2 ) { Array List < IV Combination > intersection = new Array List < > ( ) ; if ( poke 1 != null && poke 2 != null ) { Array List < IV Combination > p1 I Vs = poke 1 . iV Combinations ; Array List < IV Combination > p2 I Vs = poke 2 . iV Combinations ; for ( IV Combination p1 IV : p1 I Vs ) { for ( IV Combination p2 IV : p2 I Vs ) { if ( p1 IV . equals ( p2 IV ) ) { intersection . add ( p1 IV ) ; } } } } return intersection ; }
private static Array List < IV Combination > find IV Intersection ( IV Scan Result poke 1 , IV Scan Result poke 2 ) { Array List < IV Combination > intersection = new Array List < > ( ) ; if ( poke 1 != null && poke 2 != null ) { Array List < IV Combination > p1 I Vs = poke 1 . iV Combinations ; Array List < IV Combination > p2 I Vs = poke 2 . iV Combinations ; for ( IV Combination p1 IV : p1 I Vs ) { for ( IV Combination p2 IV : p2 I Vs ) { if ( p1 IV . equals ( p2 IV ) ) { intersection . add ( p1 IV ) ; } } } } return intersection ; }
private static Array List < IV Combination > find IV Intersection ( IV Scan Result poke 1 , IV Scan Result poke 2 ) { Array List < IV Combination > intersection = new Array List < > ( ) ; if ( poke 1 != null && poke 2 != null ) { Array List < IV Combination > p1 I Vs = poke 1 . iV Combinations ; Array List < IV Combination > p2 I Vs = poke 2 . iV Combinations ; for ( IV Combination p1 IV : p1 I Vs ) { for ( IV Combination p2 IV : p2 I Vs ) { if ( p1 IV . equals ( p2 IV ) ) { intersection . add ( p1 IV ) ; } } } } return intersection ; }
private static Array List < IV Combination > find IV Intersection ( IV Scan Result poke 1 , IV Scan Result poke 2 ) { Array List < IV Combination > intersection = new Array List < > ( ) ; if ( poke 1 != null && poke 2 != null ) { Array List < IV Combination > p1 I Vs = poke 1 . iV Combinations ; Array List < IV Combination > p2 I Vs = poke 2 . iV Combinations ; for ( IV Combination p1 IV : p1 I Vs ) { for ( IV Combination p2 IV : p2 I Vs ) { if ( p1 IV . equals ( p2 IV ) ) { intersection . add ( p1 IV ) ; } } } } return intersection ; }
private static Array List < IV Combination > find IV Intersection ( IV Scan Result poke 1 , IV Scan Result poke 2 ) { Array List < IV Combination > intersection = new Array List < > ( ) ; if ( poke 1 != null && poke 2 != null ) { Array List < IV Combination > p1 I Vs = poke 1 . iV Combinations ; Array List < IV Combination > p2 I Vs = poke 2 . iV Combinations ; for ( IV Combination p1 IV : p1 I Vs ) { for ( IV Combination p2 IV : p2 I Vs ) { if ( p1 IV . equals ( p2 IV ) ) { intersection . add ( p1 IV ) ; } } } } return intersection ; }
void maybe Add Dependency ( View anchor View , View child View , View Chase Choreography choreography ) { if ( child Choreography . contains Key ( anchor View ) ) { Choreography Chain child = child Choreography . get ( anchor View ) ; child . add Child Dependency ( child View , choreography ) ; return ; } for ( Choreography Chain d : child Choreography . values ( ) ) { d . maybe Add Dependency ( anchor View , child View , choreography ) ; } }
void maybe Add Dependency ( View anchor View , View child View , View Chase Choreography choreography ) { if ( child Choreography . contains Key ( anchor View ) ) { Choreography Chain child = child Choreography . get ( anchor View ) ; child . add Child Dependency ( child View , choreography ) ; return ; } for ( Choreography Chain d : child Choreography . values ( ) ) { d . maybe Add Dependency ( anchor View , child View , choreography ) ; } }
public void parse Signatures File ( Input Stream in , String name ) throws IO Exception , Parse Exception { logger . info ( STRING + name ) ; parse Signatures File ( in , BOOL ) ; }
public void parse Signatures File ( Input Stream in , String name ) throws IO Exception , Parse Exception { logger . info ( STRING + name ) ; parse Signatures File ( in , BOOL ) ; }
public void parse Signatures File ( Input Stream in , String name ) throws IO Exception , Parse Exception { logger . info ( STRING + name ) ; parse Signatures File ( in , BOOL ) ; }
public void call ( String name , Writable json ) throws IO Exception { write Name ( name ) ; verify Value ( ) ; if ( json instanceof G String ) { writer . write ( Json Output . to Json ( json . to String ( ) ) ) ; } else { json . write To ( writer ) ; } }
public void sort ( int from Index , int to Index ) { Arrays . sort ( data , from Index , to Index ) ; }
protected void unpack Element ( Element shared , Element per Node ) { }
public boolean has Freq ( ) { return has Freq ; }
public boolean has Freq ( ) { return has Freq ; }
public Generic Feed retrieve Page Of Mailbox Dump Requests ( Date from Date ) throws Apps For Your Domain Exception , Malformed URL Exception , IO Exception , Service Exception { String url = BASE URL + STRING + domain ; if ( from Date != null ) { url += STRING + DATE FORMAT . format ( from Date ) ; } return get Feed ( new URL ( url ) , Generic Feed . class ) ; }
public void add ( String arg Name , String desc , int expected Number Of Arguments , boolean expect Dashed Arguments ) { Arg new Arg = new Arg ( arg Name , desc , expected Number Of Arguments , expect Dashed Arguments ) ; args . add ( new Arg ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + arg Name ) ; } }
public void add ( String arg Name , String desc , int expected Number Of Arguments , boolean expect Dashed Arguments ) { Arg new Arg = new Arg ( arg Name , desc , expected Number Of Arguments , expect Dashed Arguments ) ; args . add ( new Arg ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + arg Name ) ; } }
public Bottom Navigation Bar add Item ( Bottom Navigation Item item ) { m Bottom Navigation Items . add ( item ) ; return this ; }
private void find Collapses From Existing Vertices ( List collapsed Vertex Indexes ) { for ( int i = NUM ; i < edge . size ( ) - NUM ; i ++ ) { Coordinate p0 = edge . get Coordinate ( i ) ; Coordinate p1 = edge . get Coordinate ( i + NUM ) ; Coordinate p2 = edge . get Coordinate ( i + NUM ) ; if ( p0 . equals 2 D ( p2 ) ) { collapsed Vertex Indexes . add ( new Integer ( i + NUM ) ) ; } } }
private void find Collapses From Existing Vertices ( List collapsed Vertex Indexes ) { for ( int i = NUM ; i < edge . size ( ) - NUM ; i ++ ) { Coordinate p0 = edge . get Coordinate ( i ) ; Coordinate p1 = edge . get Coordinate ( i + NUM ) ; Coordinate p2 = edge . get Coordinate ( i + NUM ) ; if ( p0 . equals 2 D ( p2 ) ) { collapsed Vertex Indexes . add ( new Integer ( i + NUM ) ) ; } } }
private void find Collapses From Existing Vertices ( List collapsed Vertex Indexes ) { for ( int i = NUM ; i < edge . size ( ) - NUM ; i ++ ) { Coordinate p0 = edge . get Coordinate ( i ) ; Coordinate p1 = edge . get Coordinate ( i + NUM ) ; Coordinate p2 = edge . get Coordinate ( i + NUM ) ; if ( p0 . equals 2 D ( p2 ) ) { collapsed Vertex Indexes . add ( new Integer ( i + NUM ) ) ; } } }
private void find Collapses From Existing Vertices ( List collapsed Vertex Indexes ) { for ( int i = NUM ; i < edge . size ( ) - NUM ; i ++ ) { Coordinate p0 = edge . get Coordinate ( i ) ; Coordinate p1 = edge . get Coordinate ( i + NUM ) ; Coordinate p2 = edge . get Coordinate ( i + NUM ) ; if ( p0 . equals 2 D ( p2 ) ) { collapsed Vertex Indexes . add ( new Integer ( i + NUM ) ) ; } } }
public Simple Similarity ( double d Init ) { Simil = Double . value Of ( d Init ) ; }
public void add All Tags Of ( Host h ) { List < Tag > tags = h . get Tags ( ) ; if ( tags . is Empty ( ) ) return ; if ( m Tag List == null ) { m Tag List = new Array List < Tag > ( tags . size ( ) ) ; } m Tag List . add All ( tags ) ; }
protected void stop Spin ( ) { if ( spinning ) { try { spin Limiter . acquire ( ) ; } catch ( Interrupted Exception e ) { throw new Active MQ Interrupted Exception ( e ) ; } spinning = BOOL ; } }
protected void stop Spin ( ) { if ( spinning ) { try { spin Limiter . acquire ( ) ; } catch ( Interrupted Exception e ) { throw new Active MQ Interrupted Exception ( e ) ; } spinning = BOOL ; } }
protected void stop Spin ( ) { if ( spinning ) { try { spin Limiter . acquire ( ) ; } catch ( Interrupted Exception e ) { throw new Active MQ Interrupted Exception ( e ) ; } spinning = BOOL ; } }
public Form show Form ( String resource Name , Command source Command ) { Form f = ( Form ) create Container ( fetch Resource File ( ) , resource Name ) ; show Form ( f , source Command , null ) ; return f ; }
public String extract package ( String fullname ) { return fullname . replace First ( STRING , STRING ) ; }
public String extract package ( String fullname ) { return fullname . replace First ( STRING , STRING ) ; }
private String create Dash Array String ( List < Float > dashes Array ) { String Builder sb = new String Builder ( ) ; if ( dashes Array != null ) { int index = NUM ; for ( Float value : dashes Array ) { String str = Float . to String ( value ) ; if ( str . ends With ( STRING ) ) { sb . append ( value . int Value ( ) ) ; } else { sb . append ( value ) ; } if ( index < dashes Array . size ( ) - NUM ) { sb . append ( STRING ) ; } index ++ ; } } return sb . to String ( ) ; }
public Bitmap pop ( long timeout , Time Unit unit ) throws Interrupted Exception { check Not Main Thread ( ) ; ensure Scheduled ( ) ; return finished . poll ( timeout , unit ) ; }
public Bitmap pop ( long timeout , Time Unit unit ) throws Interrupted Exception { check Not Main Thread ( ) ; ensure Scheduled ( ) ; return finished . poll ( timeout , unit ) ; }
public Bitmap pop ( long timeout , Time Unit unit ) throws Interrupted Exception { check Not Main Thread ( ) ; ensure Scheduled ( ) ; return finished . poll ( timeout , unit ) ; }
public void apply Missing Values Treatment ( double [ ] values ) throws Exception { for ( int i = NUM ; i < m mining Meta . size ( ) ; i ++ ) { Mining Field Meta Info mfi = m mining Meta . get ( i ) ; values [ i ] = mfi . apply Missing Value Treatment ( values [ i ] ) ; } }
Set find Removable Aci List ( Set aci List ) throws AM Exception , SSO Exception { Set result Set = new Hash Set ( ) ; if ( aci List == null ) { return result Set ; } Iterator iter = aci List . iterator ( ) ; while ( iter . has Next ( ) ) { String aci = ( String ) iter . next ( ) ; Set objs = ds Services . search ( token , AM Store Connection . get AM Sdk Base DN ( ) , STRING + AM Search Filter Manager . get Global Search Filter ( AM Object . GROUP ) + STRING + aci + STRING , AM Constants . SCOPE SUB ) ; if ( objs . size ( ) < NUM ) { result Set . add ( aci ) ; } } return result Set ; }
public String evaluate ( Associator associator , Instances data ) throws Exception { long start Time ; long end Time ; start Time = System . current Time Millis ( ) ; associator . build Associations ( data ) ; end Time = System . current Time Millis ( ) ; m Result = new String Buffer ( associator . to String ( ) ) ; m Result . append ( STRING ) ; m Result . append ( STRING + ( ( ( double ) ( end Time - start Time ) ) / NUM ) + STRING ) ; m Result . append ( STRING ) ; return m Result . to String ( ) ; }
public String evaluate ( Associator associator , Instances data ) throws Exception { long start Time ; long end Time ; start Time = System . current Time Millis ( ) ; associator . build Associations ( data ) ; end Time = System . current Time Millis ( ) ; m Result = new String Buffer ( associator . to String ( ) ) ; m Result . append ( STRING ) ; m Result . append ( STRING + ( ( ( double ) ( end Time - start Time ) ) / NUM ) + STRING ) ; m Result . append ( STRING ) ; return m Result . to String ( ) ; }
public String evaluate ( Associator associator , Instances data ) throws Exception { long start Time ; long end Time ; start Time = System . current Time Millis ( ) ; associator . build Associations ( data ) ; end Time = System . current Time Millis ( ) ; m Result = new String Buffer ( associator . to String ( ) ) ; m Result . append ( STRING ) ; m Result . append ( STRING + ( ( ( double ) ( end Time - start Time ) ) / NUM ) + STRING ) ; m Result . append ( STRING ) ; return m Result . to String ( ) ; }
@ Override public void modify Variable Id ( String old Id , String new Id ) { if ( variables . contains ( old Id ) ) { variables . remove ( old Id ) ; variables . add ( new Id ) ; } for ( Assignment a : samples ) { if ( a . contains Var ( old Id ) ) { Value v = a . remove Pair ( old Id ) ; a . add Pair ( new Id , v ) ; } } if ( discrete Cache != null ) { discrete Cache . modify Variable Id ( old Id , new Id ) ; } if ( continuous Cache != null ) { continuous Cache . modify Variable Id ( old Id , new Id ) ; } }
@ Override public void modify Variable Id ( String old Id , String new Id ) { if ( variables . contains ( old Id ) ) { variables . remove ( old Id ) ; variables . add ( new Id ) ; } for ( Assignment a : samples ) { if ( a . contains Var ( old Id ) ) { Value v = a . remove Pair ( old Id ) ; a . add Pair ( new Id , v ) ; } } if ( discrete Cache != null ) { discrete Cache . modify Variable Id ( old Id , new Id ) ; } if ( continuous Cache != null ) { continuous Cache . modify Variable Id ( old Id , new Id ) ; } }
public String to String ( ) { return WKT Writer . to Line String ( new Coordinate Array Sequence ( get Coordinates ( ) ) ) ; }
public static < V > Future < V > submit ( Callable < V > task ) { if ( task == null ) { throw new Null Pointer Exception ( ) ; } Future Task < V > future = new Future Task < V > ( task ) ; execute ( future ) ; return future ; }
public static < V > Future < V > submit ( Callable < V > task ) { if ( task == null ) { throw new Null Pointer Exception ( ) ; } Future Task < V > future = new Future Task < V > ( task ) ; execute ( future ) ; return future ; }
public static < V > Future < V > submit ( Callable < V > task ) { if ( task == null ) { throw new Null Pointer Exception ( ) ; } Future Task < V > future = new Future Task < V > ( task ) ; execute ( future ) ; return future ; }
public static < V > Future < V > submit ( Callable < V > task ) { if ( task == null ) { throw new Null Pointer Exception ( ) ; } Future Task < V > future = new Future Task < V > ( task ) ; execute ( future ) ; return future ; }
public synchronized void sleep Until ( long time To Wake From Phone Boot ) { write Debug ( STRING + new Date ( System . current Time Millis ( ) + time To Wake From Phone Boot - System Clock . elapsed Realtime ( ) ) ) ; if ( wake Lock . is Held ( ) ) { write Debug ( STRING ) ; wake Lock . release ( ) ; } alarm Manager . set ( Alarm Manager . ELAPSED REALTIME WAKEUP , time To Wake From Phone Boot , sender ) ; }
public synchronized void sleep Until ( long time To Wake From Phone Boot ) { write Debug ( STRING + new Date ( System . current Time Millis ( ) + time To Wake From Phone Boot - System Clock . elapsed Realtime ( ) ) ) ; if ( wake Lock . is Held ( ) ) { write Debug ( STRING ) ; wake Lock . release ( ) ; } alarm Manager . set ( Alarm Manager . ELAPSED REALTIME WAKEUP , time To Wake From Phone Boot , sender ) ; }
public synchronized void sleep Until ( long time To Wake From Phone Boot ) { write Debug ( STRING + new Date ( System . current Time Millis ( ) + time To Wake From Phone Boot - System Clock . elapsed Realtime ( ) ) ) ; if ( wake Lock . is Held ( ) ) { write Debug ( STRING ) ; wake Lock . release ( ) ; } alarm Manager . set ( Alarm Manager . ELAPSED REALTIME WAKEUP , time To Wake From Phone Boot , sender ) ; }
public synchronized void sleep Until ( long time To Wake From Phone Boot ) { write Debug ( STRING + new Date ( System . current Time Millis ( ) + time To Wake From Phone Boot - System Clock . elapsed Realtime ( ) ) ) ; if ( wake Lock . is Held ( ) ) { write Debug ( STRING ) ; wake Lock . release ( ) ; } alarm Manager . set ( Alarm Manager . ELAPSED REALTIME WAKEUP , time To Wake From Phone Boot , sender ) ; }
public Tag read ( Random Access File raf ) throws Cannot Read Exception , IO Exception { logger . config ( STRING ) ; byte [ ] raw Vorbis Comment Data = read Raw Packet Data ( raf ) ; Vorbis Comment Tag tag = vorbis Comment Reader . read ( raw Vorbis Comment Data , BOOL ) ; logger . fine ( STRING ) ; return tag ; }
public Tag read ( Random Access File raf ) throws Cannot Read Exception , IO Exception { logger . config ( STRING ) ; byte [ ] raw Vorbis Comment Data = read Raw Packet Data ( raf ) ; Vorbis Comment Tag tag = vorbis Comment Reader . read ( raw Vorbis Comment Data , BOOL ) ; logger . fine ( STRING ) ; return tag ; }
public Tag read ( Random Access File raf ) throws Cannot Read Exception , IO Exception { logger . config ( STRING ) ; byte [ ] raw Vorbis Comment Data = read Raw Packet Data ( raf ) ; Vorbis Comment Tag tag = vorbis Comment Reader . read ( raw Vorbis Comment Data , BOOL ) ; logger . fine ( STRING ) ; return tag ; }
public void find Charge Element ID ( ) { m C Acct Schema ID = Env . get Context As Int ( Env . get Ctx ( ) , STRING ) ; String sql = STRING + STRING + STRING ; try { Prepared Statement pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM , m C Acct Schema ID ) ; Result Set rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { m C Element ID = rs . get Int ( NUM ) ; } rs . close ( ) ; pstmt . close ( ) ; } catch ( SQL Exception exception ) { log . log ( Level . SEVERE , sql , exception ) ; } }
public static byte [ ] pack Byte Buffer Into Single Byte Array ( byte [ ] [ ] byte Buffer Arr ) { if ( null == byte Buffer Arr || byte Buffer Arr . length == NUM ) { return null ; } int no Of Col = byte Buffer Arr . length ; short to Determine Length Of Byte Arr = NUM ; short offset Len = ( short ) ( no Of Col * NUM + to Determine Length Of Byte Arr ) ; int total Bytes = calculate Total Bytes ( byte Buffer Arr ) + offset Len ; Byte Buffer buffer = Byte Buffer . allocate ( total Bytes ) ; buffer . put Short ( ( short ) ( total Bytes - to Determine Length Of Byte Arr ) ) ; buffer . put Short ( offset Len ) ; for ( int index = NUM ; index < byte Buffer Arr . length - NUM ; index ++ ) { int no Of Bytes = byte Buffer Arr [ index ] . length ; buffer . put Short ( ( short ) ( offset Len + no Of Bytes ) ) ; offset Len += no Of Bytes ; } for ( int index = NUM ; index < byte Buffer Arr . length ; index ++ ) { buffer . put ( byte Buffer Arr [ index ] ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }
public static byte [ ] pack Byte Buffer Into Single Byte Array ( byte [ ] [ ] byte Buffer Arr ) { if ( null == byte Buffer Arr || byte Buffer Arr . length == NUM ) { return null ; } int no Of Col = byte Buffer Arr . length ; short to Determine Length Of Byte Arr = NUM ; short offset Len = ( short ) ( no Of Col * NUM + to Determine Length Of Byte Arr ) ; int total Bytes = calculate Total Bytes ( byte Buffer Arr ) + offset Len ; Byte Buffer buffer = Byte Buffer . allocate ( total Bytes ) ; buffer . put Short ( ( short ) ( total Bytes - to Determine Length Of Byte Arr ) ) ; buffer . put Short ( offset Len ) ; for ( int index = NUM ; index < byte Buffer Arr . length - NUM ; index ++ ) { int no Of Bytes = byte Buffer Arr [ index ] . length ; buffer . put Short ( ( short ) ( offset Len + no Of Bytes ) ) ; offset Len += no Of Bytes ; } for ( int index = NUM ; index < byte Buffer Arr . length ; index ++ ) { buffer . put ( byte Buffer Arr [ index ] ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }
public static byte [ ] pack Byte Buffer Into Single Byte Array ( byte [ ] [ ] byte Buffer Arr ) { if ( null == byte Buffer Arr || byte Buffer Arr . length == NUM ) { return null ; } int no Of Col = byte Buffer Arr . length ; short to Determine Length Of Byte Arr = NUM ; short offset Len = ( short ) ( no Of Col * NUM + to Determine Length Of Byte Arr ) ; int total Bytes = calculate Total Bytes ( byte Buffer Arr ) + offset Len ; Byte Buffer buffer = Byte Buffer . allocate ( total Bytes ) ; buffer . put Short ( ( short ) ( total Bytes - to Determine Length Of Byte Arr ) ) ; buffer . put Short ( offset Len ) ; for ( int index = NUM ; index < byte Buffer Arr . length - NUM ; index ++ ) { int no Of Bytes = byte Buffer Arr [ index ] . length ; buffer . put Short ( ( short ) ( offset Len + no Of Bytes ) ) ; offset Len += no Of Bytes ; } for ( int index = NUM ; index < byte Buffer Arr . length ; index ++ ) { buffer . put ( byte Buffer Arr [ index ] ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }
public Suffix File Filter ( String [ ] suffixes , IO Case case Sensitivity ) { if ( suffixes == null ) { throw new Illegal Argument Exception ( STRING ) ; } this . suffixes = new String [ suffixes . length ] ; System . arraycopy ( suffixes , NUM , this . suffixes , NUM , suffixes . length ) ; this . case Sensitivity = case Sensitivity == null ? IO Case . SENSITIVE : case Sensitivity ; }
public Suffix File Filter ( String [ ] suffixes , IO Case case Sensitivity ) { if ( suffixes == null ) { throw new Illegal Argument Exception ( STRING ) ; } this . suffixes = new String [ suffixes . length ] ; System . arraycopy ( suffixes , NUM , this . suffixes , NUM , suffixes . length ) ; this . case Sensitivity = case Sensitivity == null ? IO Case . SENSITIVE : case Sensitivity ; }
public void remove ( ) throws Recurrence Info Exception { List < Recurrence Rule > rules List = new Array List < Recurrence Rule > ( ) ; rules List . add All ( r Rules List ) ; rules List . add All ( e Rules List ) ; try { for ( Recurrence Rule rule : rules List ) rule . remove ( ) ; info . remove ( ) ; } catch ( Recurrence Rule Exception rre ) { throw new Recurrence Info Exception ( rre . get Message ( ) , rre ) ; } catch ( Generic Entity Exception gee ) { throw new Recurrence Info Exception ( gee . get Message ( ) , gee ) ; } }
public static double non Robust Compute Edge Distance ( Coordinate p , Coordinate p1 , Coordinate p2 ) { double dx = p . x - p1 . x ; double dy = p . y - p1 . y ; double dist = Math . sqrt ( dx * dx + dy * dy ) ; Assert . is True ( ! ( dist == NUM && ! p . equals ( p1 ) ) , STRING ) ; return dist ; }
public static double non Robust Compute Edge Distance ( Coordinate p , Coordinate p1 , Coordinate p2 ) { double dx = p . x - p1 . x ; double dy = p . y - p1 . y ; double dist = Math . sqrt ( dx * dx + dy * dy ) ; Assert . is True ( ! ( dist == NUM && ! p . equals ( p1 ) ) , STRING ) ; return dist ; }
public static double non Robust Compute Edge Distance ( Coordinate p , Coordinate p1 , Coordinate p2 ) { double dx = p . x - p1 . x ; double dy = p . y - p1 . y ; double dist = Math . sqrt ( dx * dx + dy * dy ) ; Assert . is True ( ! ( dist == NUM && ! p . equals ( p1 ) ) , STRING ) ; return dist ; }
private Certificate Verify ( Signature And Hash Algorithm signature And Hash Algorithm , byte [ ] signature Bytes , Inet Socket Address peer Address ) { this ( signature And Hash Algorithm , peer Address ) ; this . signature Bytes = Arrays . copy Of ( signature Bytes , signature Bytes . length ) ; }
public synchronized void record Statistics ( Query Statistic statistic ) { query Statistics . add ( statistic ) ; }
public synchronized void record Statistics ( Query Statistic statistic ) { query Statistics . add ( statistic ) ; }
public synchronized void add Action Listener ( Action Listener action Listener ) { if ( action Listeners == null ) action Listeners = new Array List < Action Listener > ( ) ; action Listeners . add ( action Listener ) ; if ( fired ) { action Listener . action Performed ( new Action Event ( this , Action Event . ACTION PERFORMED , STRING ) ) ; } }
public synchronized void add Action Listener ( Action Listener action Listener ) { if ( action Listeners == null ) action Listeners = new Array List < Action Listener > ( ) ; action Listeners . add ( action Listener ) ; if ( fired ) { action Listener . action Performed ( new Action Event ( this , Action Event . ACTION PERFORMED , STRING ) ) ; } }
static void ordered Show Views ( final List < View > views , long animation Duration , int animation Delay ) { if ( views != null ) { for ( int view Index = NUM ; view Index < views . size ( ) ; view Index ++ ) { final View child View = views . get ( view Index ) ; child View . set Visibility ( View . VISIBLE ) ; final Scale Animation scale Animation = new Scale Animation ( NUM , child View . get Scale X ( ) , NUM , child View . get Scale Y ( ) , Animation . RELATIVE TO SELF , NUM , Animation . RELATIVE TO SELF , NUM ) ; scale Animation . set Interpolator ( new Decelerate Interpolator ( ) ) ; scale Animation . set Duration ( animation Duration ) ; scale Animation . set Start Offset ( view Index * animation Delay ) ; child View . start Animation ( scale Animation ) ; } } }
static void ordered Show Views ( final List < View > views , long animation Duration , int animation Delay ) { if ( views != null ) { for ( int view Index = NUM ; view Index < views . size ( ) ; view Index ++ ) { final View child View = views . get ( view Index ) ; child View . set Visibility ( View . VISIBLE ) ; final Scale Animation scale Animation = new Scale Animation ( NUM , child View . get Scale X ( ) , NUM , child View . get Scale Y ( ) , Animation . RELATIVE TO SELF , NUM , Animation . RELATIVE TO SELF , NUM ) ; scale Animation . set Interpolator ( new Decelerate Interpolator ( ) ) ; scale Animation . set Duration ( animation Duration ) ; scale Animation . set Start Offset ( view Index * animation Delay ) ; child View . start Animation ( scale Animation ) ; } } }
private static int create Packed Params ( Sun Graphics 2 D sg 2 d , Glyph List gl ) { return ( ( ( gl . use Positions ( ) ? NUM : NUM ) << OFFSET POSITIONS ) | ( ( gl . is Sub Pix Pos ( ) ? NUM : NUM ) << OFFSET SUBPIXPOS ) | ( ( gl . is RGB Order ( ) ? NUM : NUM ) << OFFSET RGBORDER ) | ( ( sg 2 d . lcd Text Contrast & NUM ) << OFFSET CONTRAST ) ) ; }
private static int create Packed Params ( Sun Graphics 2 D sg 2 d , Glyph List gl ) { return ( ( ( gl . use Positions ( ) ? NUM : NUM ) << OFFSET POSITIONS ) | ( ( gl . is Sub Pix Pos ( ) ? NUM : NUM ) << OFFSET SUBPIXPOS ) | ( ( gl . is RGB Order ( ) ? NUM : NUM ) << OFFSET RGBORDER ) | ( ( sg 2 d . lcd Text Contrast & NUM ) << OFFSET CONTRAST ) ) ; }
private static int create Packed Params ( Sun Graphics 2 D sg 2 d , Glyph List gl ) { return ( ( ( gl . use Positions ( ) ? NUM : NUM ) << OFFSET POSITIONS ) | ( ( gl . is Sub Pix Pos ( ) ? NUM : NUM ) << OFFSET SUBPIXPOS ) | ( ( gl . is RGB Order ( ) ? NUM : NUM ) << OFFSET RGBORDER ) | ( ( sg 2 d . lcd Text Contrast & NUM ) << OFFSET CONTRAST ) ) ; }
private static int create Packed Params ( Sun Graphics 2 D sg 2 d , Glyph List gl ) { return ( ( ( gl . use Positions ( ) ? NUM : NUM ) << OFFSET POSITIONS ) | ( ( gl . is Sub Pix Pos ( ) ? NUM : NUM ) << OFFSET SUBPIXPOS ) | ( ( gl . is RGB Order ( ) ? NUM : NUM ) << OFFSET RGBORDER ) | ( ( sg 2 d . lcd Text Contrast & NUM ) << OFFSET CONTRAST ) ) ; }
private static int create Packed Params ( Sun Graphics 2 D sg 2 d , Glyph List gl ) { return ( ( ( gl . use Positions ( ) ? NUM : NUM ) << OFFSET POSITIONS ) | ( ( gl . is Sub Pix Pos ( ) ? NUM : NUM ) << OFFSET SUBPIXPOS ) | ( ( gl . is RGB Order ( ) ? NUM : NUM ) << OFFSET RGBORDER ) | ( ( sg 2 d . lcd Text Contrast & NUM ) << OFFSET CONTRAST ) ) ; }
private static int create Packed Params ( Sun Graphics 2 D sg 2 d , Glyph List gl ) { return ( ( ( gl . use Positions ( ) ? NUM : NUM ) << OFFSET POSITIONS ) | ( ( gl . is Sub Pix Pos ( ) ? NUM : NUM ) << OFFSET SUBPIXPOS ) | ( ( gl . is RGB Order ( ) ? NUM : NUM ) << OFFSET RGBORDER ) | ( ( sg 2 d . lcd Text Contrast & NUM ) << OFFSET CONTRAST ) ) ; }
private static int create Packed Params ( Sun Graphics 2 D sg 2 d , Glyph List gl ) { return ( ( ( gl . use Positions ( ) ? NUM : NUM ) << OFFSET POSITIONS ) | ( ( gl . is Sub Pix Pos ( ) ? NUM : NUM ) << OFFSET SUBPIXPOS ) | ( ( gl . is RGB Order ( ) ? NUM : NUM ) << OFFSET RGBORDER ) | ( ( sg 2 d . lcd Text Contrast & NUM ) << OFFSET CONTRAST ) ) ; }
private static int create Packed Params ( Sun Graphics 2 D sg 2 d , Glyph List gl ) { return ( ( ( gl . use Positions ( ) ? NUM : NUM ) << OFFSET POSITIONS ) | ( ( gl . is Sub Pix Pos ( ) ? NUM : NUM ) << OFFSET SUBPIXPOS ) | ( ( gl . is RGB Order ( ) ? NUM : NUM ) << OFFSET RGBORDER ) | ( ( sg 2 d . lcd Text Contrast & NUM ) << OFFSET CONTRAST ) ) ; }
protected void update View ( View view ) { try { m Status Text = ( Text View ) view . find View By Id ( R . id . seek Bar Pref Value ) ; m Status Text . set Text ( String . value Of ( m Current Value ) ) ; m Status Text . set Minimum Width ( NUM ) ; m Seek Bar . set Progress ( m Current Value - m Min Value ) ; } catch ( Exception e ) { Log . e ( TAG , STRING , e ) ; } }
public void add Item Bounds Listener ( Item Bounds Listener ibl ) { if ( m bounders == null ) { m bounders = new Copy On Write Array List ( ) ; } m bounders . add ( ibl ) ; }
public void add Item Bounds Listener ( Item Bounds Listener ibl ) { if ( m bounders == null ) { m bounders = new Copy On Write Array List ( ) ; } m bounders . add ( ibl ) ; }
public void add Item Bounds Listener ( Item Bounds Listener ibl ) { if ( m bounders == null ) { m bounders = new Copy On Write Array List ( ) ; } m bounders . add ( ibl ) ; }
public void add Item Bounds Listener ( Item Bounds Listener ibl ) { if ( m bounders == null ) { m bounders = new Copy On Write Array List ( ) ; } m bounders . add ( ibl ) ; }
public static Supply add ( final int divisibility , final Supply s1 , final Supply s2 ) { final Supply sum = Mosaic Utils . try Add ( divisibility , s1 , s2 ) ; if ( null == sum ) { final String message = String . format ( STRING , s1 , s2 , divisibility ) ; throw new Illegal Argument Exception ( message ) ; } return sum ; }
public static Supply add ( final int divisibility , final Supply s1 , final Supply s2 ) { final Supply sum = Mosaic Utils . try Add ( divisibility , s1 , s2 ) ; if ( null == sum ) { final String message = String . format ( STRING , s1 , s2 , divisibility ) ; throw new Illegal Argument Exception ( message ) ; } return sum ; }
public synchronized boolean contains Key ( Cache Key key ) { Preconditions . check Not Null ( key ) ; if ( ! m Map . contains Key ( key ) ) { return BOOL ; } Encoded Image stored Encoded Image = m Map . get ( key ) ; synchronized ( stored Encoded Image ) { if ( ! Encoded Image . is Valid ( stored Encoded Image ) ) { m Map . remove ( key ) ; F Log . w ( TAG , STRING , System . identity Hash Code ( stored Encoded Image ) , key . to String ( ) , System . identity Hash Code ( key ) ) ; return BOOL ; } return BOOL ; } }
public synchronized boolean contains Key ( Cache Key key ) { Preconditions . check Not Null ( key ) ; if ( ! m Map . contains Key ( key ) ) { return BOOL ; } Encoded Image stored Encoded Image = m Map . get ( key ) ; synchronized ( stored Encoded Image ) { if ( ! Encoded Image . is Valid ( stored Encoded Image ) ) { m Map . remove ( key ) ; F Log . w ( TAG , STRING , System . identity Hash Code ( stored Encoded Image ) , key . to String ( ) , System . identity Hash Code ( key ) ) ; return BOOL ; } return BOOL ; } }
public void test Reverse Step By One With Closure ( ) { final List call Log = new Array List ( ) ; final Closure closure = new Recording Closure ( call Log ) ; final Range range = create Range ( NUM , NUM ) ; range . step ( NUM , closure ) ; assert Equals ( STRING , NUM , call Log . size ( ) ) ; final Iterator iter = call Log . iterator ( ) ; for ( int i = NUM ; i >= NUM ; i -- ) { assert Equals ( STRING , create Value ( i ) , iter . next ( ) ) ; } }
public VN Xe Command Result add Luns To Lun Group ( String lun Group Id , List < String > luns ) { Lun Group Modify Param param = new Lun Group Modify Param ( ) ; List < Lun Add Param > lun Adds = new Array List < Lun Add Param > ( ) ; for ( String lun Id : luns ) { VN Xe Base lun = new VN Xe Base ( lun Id ) ; Lun Add Param lun Add = new Lun Add Param ( ) ; lun Add . set Lun ( lun ) ; lun Adds . add ( lun Add ) ; } param . set Lun Add ( lun Adds ) ; Lun Group Requests req = new Lun Group Requests ( kh Client ) ; return req . modify Lun Group Sync ( lun Group Id , param ) ; }
private synchronized void migrate API ( SQ Lite Database db ) { Log . d ( LOGTAG , STRING ) ; String user = prefs . get String ( r . get String ( R . string . config username key ) , STRING ) ; String pass = prefs . get String ( r . get String ( R . string . config password key ) , STRING ) ; String name = STRING ; Log . d ( LOGTAG , STRING + user + STRING ) ; add API ( db , ID DEFAULT , name , API DEFAULT , null , null , user , pass , ID DEFAULT , BOOL , BOOL ) ; Log . d ( LOGTAG , STRING ) ; add API ( db , ID DEFAULT NO HTTPS , STRING , API DEFAULT NO HTTPS , null , null , STRING , STRING , ID DEFAULT NO HTTPS , BOOL , BOOL ) ; Log . d ( LOGTAG , STRING ) ; select API ( db , ID DEFAULT ) ; Log . d ( LOGTAG , STRING ) ; Editor editor = prefs . edit ( ) ; editor . remove ( r . get String ( R . string . config username key ) ) ; editor . remove ( r . get String ( R . string . config password key ) ) ; editor . commit ( ) ; Log . d ( LOGTAG , STRING ) ; }
private synchronized void migrate API ( SQ Lite Database db ) { Log . d ( LOGTAG , STRING ) ; String user = prefs . get String ( r . get String ( R . string . config username key ) , STRING ) ; String pass = prefs . get String ( r . get String ( R . string . config password key ) , STRING ) ; String name = STRING ; Log . d ( LOGTAG , STRING + user + STRING ) ; add API ( db , ID DEFAULT , name , API DEFAULT , null , null , user , pass , ID DEFAULT , BOOL , BOOL ) ; Log . d ( LOGTAG , STRING ) ; add API ( db , ID DEFAULT NO HTTPS , STRING , API DEFAULT NO HTTPS , null , null , STRING , STRING , ID DEFAULT NO HTTPS , BOOL , BOOL ) ; Log . d ( LOGTAG , STRING ) ; select API ( db , ID DEFAULT ) ; Log . d ( LOGTAG , STRING ) ; Editor editor = prefs . edit ( ) ; editor . remove ( r . get String ( R . string . config username key ) ) ; editor . remove ( r . get String ( R . string . config password key ) ) ; editor . commit ( ) ; Log . d ( LOGTAG , STRING ) ; }
public static Annotation find First Qualifier In Annotations ( Field field ) { return find First Qualifier In Annotations ( field . get Annotations ( ) ) ; }
public Source Model source For Class ( Reference Type ref Type ) { Source Model sm = class To Source . get ( ref Type ) ; if ( sm != null ) { return sm ; } try { String filename = ref Type . source Name ( ) ; String ref Name = ref Type . name ( ) ; int i Dot = ref Name . last Index Of ( STRING ) ; String pkg Name = ( i Dot >= NUM ) ? ref Name . substring ( NUM , i Dot + NUM ) : STRING ; String full = pkg Name . replace ( STRING , File . separator Char ) + filename ; File path = source Path . resolve ( full ) ; if ( path != null ) { sm = source For File ( path ) ; class To Source . put ( ref Type , sm ) ; return sm ; } return null ; } catch ( Absent Information Exception e ) { return null ; } }
protected Abstract Protocol Descriptor ( int version , int architecture , int minimum Type , int maximum Type , int weight ) { this . version = version ; this . architecture = architecture ; this . minimum Type = minimum Type ; this . maximum Type = maximum Type ; this . weight = weight ; hash Code = Objects . hash ( version , architecture , minimum Type , maximum Type , weight ) ; }
public Chat Builder add Email ( String email ) { emails . add ( email ) ; return this ; }
public Chat Builder add Email ( String email ) { emails . add ( email ) ; return this ; }
public static String encrypt With Asymmetric Key ( String data , String encryption Algorithm , int encryption Strength , Key enc Key ) throws Exception { try { Key Generator keygen = Key Generator . get Instance ( encryption Algorithm ) ; if ( encryption Strength != NUM ) { keygen . init ( encryption Strength ) ; } Secret Key s Key = keygen . generate Key ( ) ; Cipher cipher = Cipher . get Instance ( encryption Algorithm ) ; cipher . init ( Cipher . ENCRYPT MODE , s Key ) ; byte [ ] enc Data = cipher . do Final ( data . get Bytes ( STRING ) ) ; cipher = Cipher . get Instance ( enc Key . get Algorithm ( ) ) ; cipher . init ( Cipher . WRAP MODE , enc Key ) ; byte [ ] key Wrap = cipher . wrap ( s Key ) ; byte [ ] enc Data Pad = wrap Key With Encrypted Data ( enc Data , key Wrap ) ; return Base 64 . encode ( enc Data Pad ) ; } catch ( No Such Algorithm Exception nse ) { throw new Exception ( nse . get Message ( ) ) ; } catch ( No Such Padding Exception npe ) { throw new Exception ( npe . get Message ( ) ) ; } catch ( Invalid Key Exception ike ) { throw new Exception ( ike . get Message ( ) ) ; } catch ( Unsupported Encoding Exception uae ) { throw new Exception ( uae . get Message ( ) ) ; } }
public static String encrypt With Asymmetric Key ( String data , String encryption Algorithm , int encryption Strength , Key enc Key ) throws Exception { try { Key Generator keygen = Key Generator . get Instance ( encryption Algorithm ) ; if ( encryption Strength != NUM ) { keygen . init ( encryption Strength ) ; } Secret Key s Key = keygen . generate Key ( ) ; Cipher cipher = Cipher . get Instance ( encryption Algorithm ) ; cipher . init ( Cipher . ENCRYPT MODE , s Key ) ; byte [ ] enc Data = cipher . do Final ( data . get Bytes ( STRING ) ) ; cipher = Cipher . get Instance ( enc Key . get Algorithm ( ) ) ; cipher . init ( Cipher . WRAP MODE , enc Key ) ; byte [ ] key Wrap = cipher . wrap ( s Key ) ; byte [ ] enc Data Pad = wrap Key With Encrypted Data ( enc Data , key Wrap ) ; return Base 64 . encode ( enc Data Pad ) ; } catch ( No Such Algorithm Exception nse ) { throw new Exception ( nse . get Message ( ) ) ; } catch ( No Such Padding Exception npe ) { throw new Exception ( npe . get Message ( ) ) ; } catch ( Invalid Key Exception ike ) { throw new Exception ( ike . get Message ( ) ) ; } catch ( Unsupported Encoding Exception uae ) { throw new Exception ( uae . get Message ( ) ) ; } }
public static String encrypt With Asymmetric Key ( String data , String encryption Algorithm , int encryption Strength , Key enc Key ) throws Exception { try { Key Generator keygen = Key Generator . get Instance ( encryption Algorithm ) ; if ( encryption Strength != NUM ) { keygen . init ( encryption Strength ) ; } Secret Key s Key = keygen . generate Key ( ) ; Cipher cipher = Cipher . get Instance ( encryption Algorithm ) ; cipher . init ( Cipher . ENCRYPT MODE , s Key ) ; byte [ ] enc Data = cipher . do Final ( data . get Bytes ( STRING ) ) ; cipher = Cipher . get Instance ( enc Key . get Algorithm ( ) ) ; cipher . init ( Cipher . WRAP MODE , enc Key ) ; byte [ ] key Wrap = cipher . wrap ( s Key ) ; byte [ ] enc Data Pad = wrap Key With Encrypted Data ( enc Data , key Wrap ) ; return Base 64 . encode ( enc Data Pad ) ; } catch ( No Such Algorithm Exception nse ) { throw new Exception ( nse . get Message ( ) ) ; } catch ( No Such Padding Exception npe ) { throw new Exception ( npe . get Message ( ) ) ; } catch ( Invalid Key Exception ike ) { throw new Exception ( ike . get Message ( ) ) ; } catch ( Unsupported Encoding Exception uae ) { throw new Exception ( uae . get Message ( ) ) ; } }
public static String encrypt With Asymmetric Key ( String data , String encryption Algorithm , int encryption Strength , Key enc Key ) throws Exception { try { Key Generator keygen = Key Generator . get Instance ( encryption Algorithm ) ; if ( encryption Strength != NUM ) { keygen . init ( encryption Strength ) ; } Secret Key s Key = keygen . generate Key ( ) ; Cipher cipher = Cipher . get Instance ( encryption Algorithm ) ; cipher . init ( Cipher . ENCRYPT MODE , s Key ) ; byte [ ] enc Data = cipher . do Final ( data . get Bytes ( STRING ) ) ; cipher = Cipher . get Instance ( enc Key . get Algorithm ( ) ) ; cipher . init ( Cipher . WRAP MODE , enc Key ) ; byte [ ] key Wrap = cipher . wrap ( s Key ) ; byte [ ] enc Data Pad = wrap Key With Encrypted Data ( enc Data , key Wrap ) ; return Base 64 . encode ( enc Data Pad ) ; } catch ( No Such Algorithm Exception nse ) { throw new Exception ( nse . get Message ( ) ) ; } catch ( No Such Padding Exception npe ) { throw new Exception ( npe . get Message ( ) ) ; } catch ( Invalid Key Exception ike ) { throw new Exception ( ike . get Message ( ) ) ; } catch ( Unsupported Encoding Exception uae ) { throw new Exception ( uae . get Message ( ) ) ; } }
public static String encrypt With Asymmetric Key ( String data , String encryption Algorithm , int encryption Strength , Key enc Key ) throws Exception { try { Key Generator keygen = Key Generator . get Instance ( encryption Algorithm ) ; if ( encryption Strength != NUM ) { keygen . init ( encryption Strength ) ; } Secret Key s Key = keygen . generate Key ( ) ; Cipher cipher = Cipher . get Instance ( encryption Algorithm ) ; cipher . init ( Cipher . ENCRYPT MODE , s Key ) ; byte [ ] enc Data = cipher . do Final ( data . get Bytes ( STRING ) ) ; cipher = Cipher . get Instance ( enc Key . get Algorithm ( ) ) ; cipher . init ( Cipher . WRAP MODE , enc Key ) ; byte [ ] key Wrap = cipher . wrap ( s Key ) ; byte [ ] enc Data Pad = wrap Key With Encrypted Data ( enc Data , key Wrap ) ; return Base 64 . encode ( enc Data Pad ) ; } catch ( No Such Algorithm Exception nse ) { throw new Exception ( nse . get Message ( ) ) ; } catch ( No Such Padding Exception npe ) { throw new Exception ( npe . get Message ( ) ) ; } catch ( Invalid Key Exception ike ) { throw new Exception ( ike . get Message ( ) ) ; } catch ( Unsupported Encoding Exception uae ) { throw new Exception ( uae . get Message ( ) ) ; } }
public static String encrypt With Asymmetric Key ( String data , String encryption Algorithm , int encryption Strength , Key enc Key ) throws Exception { try { Key Generator keygen = Key Generator . get Instance ( encryption Algorithm ) ; if ( encryption Strength != NUM ) { keygen . init ( encryption Strength ) ; } Secret Key s Key = keygen . generate Key ( ) ; Cipher cipher = Cipher . get Instance ( encryption Algorithm ) ; cipher . init ( Cipher . ENCRYPT MODE , s Key ) ; byte [ ] enc Data = cipher . do Final ( data . get Bytes ( STRING ) ) ; cipher = Cipher . get Instance ( enc Key . get Algorithm ( ) ) ; cipher . init ( Cipher . WRAP MODE , enc Key ) ; byte [ ] key Wrap = cipher . wrap ( s Key ) ; byte [ ] enc Data Pad = wrap Key With Encrypted Data ( enc Data , key Wrap ) ; return Base 64 . encode ( enc Data Pad ) ; } catch ( No Such Algorithm Exception nse ) { throw new Exception ( nse . get Message ( ) ) ; } catch ( No Such Padding Exception npe ) { throw new Exception ( npe . get Message ( ) ) ; } catch ( Invalid Key Exception ike ) { throw new Exception ( ike . get Message ( ) ) ; } catch ( Unsupported Encoding Exception uae ) { throw new Exception ( uae . get Message ( ) ) ; } }
private void init Panel ( ) { if ( effector Type . get Selected Item ( ) == STRING ) { cleareffector Panel ( ) ; set Title ( STRING ) ; current Effector Panel = new Straight Effector Panel ( rotating Entity ) ; main Panel . add ( current Effector Panel ) ; } else if ( effector Type . get Selected Item ( ) == STRING ) { cleareffector Panel ( ) ; set Title ( STRING ) ; current Effector Panel = new Turning Effector Panel ( rotating Entity ) ; main Panel . add ( current Effector Panel ) ; } else if ( effector Type . get Selected Item ( ) == STRING ) { cleareffector Panel ( ) ; set Title ( STRING ) ; current Effector Panel = new Speech Effector Panel ( rotating Entity ) ; main Panel . add ( current Effector Panel ) ; } pack ( ) ; set Location Relative To ( null ) ; }
private void init Panel ( ) { if ( effector Type . get Selected Item ( ) == STRING ) { cleareffector Panel ( ) ; set Title ( STRING ) ; current Effector Panel = new Straight Effector Panel ( rotating Entity ) ; main Panel . add ( current Effector Panel ) ; } else if ( effector Type . get Selected Item ( ) == STRING ) { cleareffector Panel ( ) ; set Title ( STRING ) ; current Effector Panel = new Turning Effector Panel ( rotating Entity ) ; main Panel . add ( current Effector Panel ) ; } else if ( effector Type . get Selected Item ( ) == STRING ) { cleareffector Panel ( ) ; set Title ( STRING ) ; current Effector Panel = new Speech Effector Panel ( rotating Entity ) ; main Panel . add ( current Effector Panel ) ; } pack ( ) ; set Location Relative To ( null ) ; }
static public String random Positive Whole ( int length ) { if ( length == NUM ) { return STRING ; } String Builder output = new String Builder ( length ) ; output . append ( rnd . next Int ( NUM ) + NUM ) ; for ( int i = NUM ; i < length - NUM ; i ++ ) { output . append ( rnd . next Int ( NUM ) ) ; } return output . to String ( ) ; }
public VN Xe Command Result add Luns To Consistency Group ( String cg Id , List < String > luns ) { Lun Group Modify Param param = new Lun Group Modify Param ( ) ; List < Lun Add Param > lun Adds = new Array List < Lun Add Param > ( ) ; for ( String lun Id : luns ) { VN Xe Base lun = new VN Xe Base ( lun Id ) ; Lun Add Param lun Add = new Lun Add Param ( ) ; lun Add . set Lun ( lun ) ; lun Adds . add ( lun Add ) ; } param . set Lun Add ( lun Adds ) ; Consistency Group Requests req = new Consistency Group Requests ( kh Client ) ; return req . modify Consistency Group Sync ( cg Id , param ) ; }
public void add State ( int [ ] specs , Animator animation , Animator . Animator Listener listener ) { Tuple tuple = new Tuple ( specs , animation , listener ) ; animation . add Listener ( m Animation Listener ) ; m Tuples . add ( tuple ) ; }
public void add State ( int [ ] specs , Animator animation , Animator . Animator Listener listener ) { Tuple tuple = new Tuple ( specs , animation , listener ) ; animation . add Listener ( m Animation Listener ) ; m Tuples . add ( tuple ) ; }
public void add State ( int [ ] specs , Animator animation , Animator . Animator Listener listener ) { Tuple tuple = new Tuple ( specs , animation , listener ) ; animation . add Listener ( m Animation Listener ) ; m Tuples . add ( tuple ) ; }
void update ( long time Nanos , int rows ) { count ++ ; execution Time Min Nanos = Math . min ( time Nanos , execution Time Min Nanos ) ; execution Time Max Nanos = Math . max ( time Nanos , execution Time Max Nanos ) ; row Count Min = Math . min ( rows , row Count Min ) ; row Count Max = Math . max ( rows , row Count Max ) ; double row Delta = rows - row Count Mean ; row Count Mean += row Delta / count ; row Count M 2 += row Delta * ( rows - row Count Mean ) ; double time Delta = time Nanos - execution Time Mean Nanos ; execution Time Mean Nanos += time Delta / count ; execution Time M 2 Nanos += time Delta * ( time Nanos - execution Time Mean Nanos ) ; execution Time Cumulative Nanos += time Nanos ; row Count Cumulative += rows ; last Update Time = System . current Time Millis ( ) ; }
public List < Source Record > ddl Records For Database ( String db Name ) { return ddl Records By Db Name . get ( db Name ) ; }
public String make Literal SQ ( Object object ) { String Builder sb = new String Builder ( ) ; make Literal ( sb , object , BOOL ) ; return sb . to String ( ) ; }
public static void startup Delay ( ) { sleep ( NUM ) ; }
private static boolean date By Ordinal ( Date Time Formatter Builder bld , Collection < Date Time Field Type > fields , boolean extended , boolean strict ISO ) { boolean reduced Prec = BOOL ; if ( fields . remove ( Date Time Field Type . year ( ) ) ) { bld . append ( year Element ( ) ) ; if ( fields . remove ( Date Time Field Type . day Of Year ( ) ) ) { append Separator ( bld , extended ) ; bld . append Day Of Year ( NUM ) ; } else { reduced Prec = BOOL ; } } else if ( fields . remove ( Date Time Field Type . day Of Year ( ) ) ) { bld . append Literal ( STRING ) ; bld . append Day Of Year ( NUM ) ; } return reduced Prec ; }
private static boolean date By Ordinal ( Date Time Formatter Builder bld , Collection < Date Time Field Type > fields , boolean extended , boolean strict ISO ) { boolean reduced Prec = BOOL ; if ( fields . remove ( Date Time Field Type . year ( ) ) ) { bld . append ( year Element ( ) ) ; if ( fields . remove ( Date Time Field Type . day Of Year ( ) ) ) { append Separator ( bld , extended ) ; bld . append Day Of Year ( NUM ) ; } else { reduced Prec = BOOL ; } } else if ( fields . remove ( Date Time Field Type . day Of Year ( ) ) ) { bld . append Literal ( STRING ) ; bld . append Day Of Year ( NUM ) ; } return reduced Prec ; }
private static boolean date By Ordinal ( Date Time Formatter Builder bld , Collection < Date Time Field Type > fields , boolean extended , boolean strict ISO ) { boolean reduced Prec = BOOL ; if ( fields . remove ( Date Time Field Type . year ( ) ) ) { bld . append ( year Element ( ) ) ; if ( fields . remove ( Date Time Field Type . day Of Year ( ) ) ) { append Separator ( bld , extended ) ; bld . append Day Of Year ( NUM ) ; } else { reduced Prec = BOOL ; } } else if ( fields . remove ( Date Time Field Type . day Of Year ( ) ) ) { bld . append Literal ( STRING ) ; bld . append Day Of Year ( NUM ) ; } return reduced Prec ; }
public static Collection < Content Stream > to Content Streams ( final String str , final String content Type ) { if ( str == null ) return null ; Array List < Content Stream > streams = new Array List < > ( NUM ) ; Content Stream Base ccc = new Content Stream Base . String Stream ( str ) ; ccc . set Content Type ( content Type ) ; streams . add ( ccc ) ; return streams ; }
public static Collection < Content Stream > to Content Streams ( final String str , final String content Type ) { if ( str == null ) return null ; Array List < Content Stream > streams = new Array List < > ( NUM ) ; Content Stream Base ccc = new Content Stream Base . String Stream ( str ) ; ccc . set Content Type ( content Type ) ; streams . add ( ccc ) ; return streams ; }
public void flush ( ) throws IO Exception { Wsp Util . write Uint 8 ( os , NUM ) ; write Public Identifier ( os , public ID ) ; Wsp Util . write Uintvar ( os , Wap Constants . MIB ENUM UTF 8 ) ; write String Table ( os ) ; wbxml Body . close ( ) ; wbxml Body . write To ( os ) ; os . flush ( ) ; }
public static X Path 2 Filter Container 04 new Instance Intersect ( Document doc , String xpath 2 filter ) { return new X Path 2 Filter Container 04 ( doc , xpath 2 filter , X Path 2 Filter Container 04 . ATT FILTER VALUE INTERSECT ) ; }
public static X Path 2 Filter Container 04 new Instance Intersect ( Document doc , String xpath 2 filter ) { return new X Path 2 Filter Container 04 ( doc , xpath 2 filter , X Path 2 Filter Container 04 . ATT FILTER VALUE INTERSECT ) ; }
public void release Proxy Mouse Mode ( ) { Map Mouse Mode pmmm = get Proxy Mouse Mode ( ) ; OM Drawing Tool dt = get Drawing Tool ( ) ; if ( pmmm != null && dt != null ) { if ( pmmm . is Proxy For ( dt . get Mouse Mode ( ) ) ) { if ( DTL DEBUG ) { Debug . output ( STRING + pmmm . get ID ( ) ) ; } pmmm . release Proxy ( ) ; set Proxy Mouse Mode ( null ) ; fire Request Info Line ( STRING ) ; } if ( dt . is Activated ( ) ) { dt . deactivate ( ) ; } } }
public void release Proxy Mouse Mode ( ) { Map Mouse Mode pmmm = get Proxy Mouse Mode ( ) ; OM Drawing Tool dt = get Drawing Tool ( ) ; if ( pmmm != null && dt != null ) { if ( pmmm . is Proxy For ( dt . get Mouse Mode ( ) ) ) { if ( DTL DEBUG ) { Debug . output ( STRING + pmmm . get ID ( ) ) ; } pmmm . release Proxy ( ) ; set Proxy Mouse Mode ( null ) ; fire Request Info Line ( STRING ) ; } if ( dt . is Activated ( ) ) { dt . deactivate ( ) ; } } }
@ Suppress Warnings ( STRING ) public static < Value T > Value T to Object ( Byte Buffer bf ) throws IO Exception , Class Not Found Exception { Object obj = null ; Input Stream is = null ; Object Input Stream ois = null ; try { is = new Byte Buffer Backed Input Stream ( bf ) ; ois = new Object Input Stream ( is ) ; obj = ois . read Object ( ) ; } finally { if ( is != null ) { is . close ( ) ; } if ( ois != null ) { ois . close ( ) ; } } return ( Value T ) obj ; }
@ Suppress Warnings ( STRING ) public static < Value T > Value T to Object ( Byte Buffer bf ) throws IO Exception , Class Not Found Exception { Object obj = null ; Input Stream is = null ; Object Input Stream ois = null ; try { is = new Byte Buffer Backed Input Stream ( bf ) ; ois = new Object Input Stream ( is ) ; obj = ois . read Object ( ) ; } finally { if ( is != null ) { is . close ( ) ; } if ( ois != null ) { ois . close ( ) ; } } return ( Value T ) obj ; }
public Boolean consume Boolean Constant Attribute ( String name ) throws Unable To Complete Exception { String value = consume Raw Attribute ( name ) ; if ( value == null ) { return null ; } if ( value . equals ( STRING ) || value . equals ( STRING ) ) { return Boolean . value Of ( value ) ; } logger . die ( this , STRING , name ) ; return null ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = enum To Vector ( super . list Options ( ) ) ; result . add Element ( new Option ( STRING + default Num Attributes ( ) + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = enum To Vector ( super . list Options ( ) ) ; result . add Element ( new Option ( STRING + default Num Attributes ( ) + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
public void evaluate Rotation Angle ( Projection proj ) { render Rotation Angle = null ; double proj Rotation = proj . get Rotation Angle ( ) ; Object no Rotation Att = get Attribute ( OM Graphic Constants . NO ROTATE ) ; boolean compensate For Proj Rot = no Rotation Att != null && ! no Rotation Att . equals ( Boolean . FALSE ) ; if ( compensate For Proj Rot ) { render Rotation Angle = rotation Angle - proj Rotation ; } else if ( rotation Angle != DEFAULT ROTATIONANGLE ) { render Rotation Angle = rotation Angle ; } }
public void evaluate Rotation Angle ( Projection proj ) { render Rotation Angle = null ; double proj Rotation = proj . get Rotation Angle ( ) ; Object no Rotation Att = get Attribute ( OM Graphic Constants . NO ROTATE ) ; boolean compensate For Proj Rot = no Rotation Att != null && ! no Rotation Att . equals ( Boolean . FALSE ) ; if ( compensate For Proj Rot ) { render Rotation Angle = rotation Angle - proj Rotation ; } else if ( rotation Angle != DEFAULT ROTATIONANGLE ) { render Rotation Angle = rotation Angle ; } }
public boolean refresh Needed ( ) { return this . soft Ttl < System . current Time Millis ( ) ; }
public boolean refresh Needed ( ) { return this . soft Ttl < System . current Time Millis ( ) ; }
@ Override public Range find Range Bounds ( XY Dataset dataset ) { Param Checks . null Not Permitted ( dataset , STRING ) ; double minimum = Double . POSITIVE INFINITY ; double maximum = Double . NEGATIVE INFINITY ; int series Count = dataset . get Series Count ( ) ; double lvalue ; double uvalue ; if ( dataset instanceof Vector XY Dataset ) { Vector XY Dataset vdataset = ( Vector XY Dataset ) dataset ; for ( int series = NUM ; series < series Count ; series ++ ) { int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM ; item < item Count ; item ++ ) { double delta = vdataset . get Vector Y Value ( series , item ) ; if ( delta < NUM ) { uvalue = vdataset . get Y Value ( series , item ) ; lvalue = uvalue + delta ; } else { lvalue = vdataset . get Y Value ( series , item ) ; uvalue = lvalue + delta ; } minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } else { for ( int series = NUM ; series < series Count ; series ++ ) { int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM ; item < item Count ; item ++ ) { lvalue = dataset . get Y Value ( series , item ) ; uvalue = lvalue ; minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } if ( minimum > maximum ) { return null ; } else { return new Range ( minimum , maximum ) ; } }
@ Override public Range find Range Bounds ( XY Dataset dataset ) { Param Checks . null Not Permitted ( dataset , STRING ) ; double minimum = Double . POSITIVE INFINITY ; double maximum = Double . NEGATIVE INFINITY ; int series Count = dataset . get Series Count ( ) ; double lvalue ; double uvalue ; if ( dataset instanceof Vector XY Dataset ) { Vector XY Dataset vdataset = ( Vector XY Dataset ) dataset ; for ( int series = NUM ; series < series Count ; series ++ ) { int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM ; item < item Count ; item ++ ) { double delta = vdataset . get Vector Y Value ( series , item ) ; if ( delta < NUM ) { uvalue = vdataset . get Y Value ( series , item ) ; lvalue = uvalue + delta ; } else { lvalue = vdataset . get Y Value ( series , item ) ; uvalue = lvalue + delta ; } minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } else { for ( int series = NUM ; series < series Count ; series ++ ) { int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM ; item < item Count ; item ++ ) { lvalue = dataset . get Y Value ( series , item ) ; uvalue = lvalue ; minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } if ( minimum > maximum ) { return null ; } else { return new Range ( minimum , maximum ) ; } }
@ Override public Range find Range Bounds ( XY Dataset dataset ) { Param Checks . null Not Permitted ( dataset , STRING ) ; double minimum = Double . POSITIVE INFINITY ; double maximum = Double . NEGATIVE INFINITY ; int series Count = dataset . get Series Count ( ) ; double lvalue ; double uvalue ; if ( dataset instanceof Vector XY Dataset ) { Vector XY Dataset vdataset = ( Vector XY Dataset ) dataset ; for ( int series = NUM ; series < series Count ; series ++ ) { int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM ; item < item Count ; item ++ ) { double delta = vdataset . get Vector Y Value ( series , item ) ; if ( delta < NUM ) { uvalue = vdataset . get Y Value ( series , item ) ; lvalue = uvalue + delta ; } else { lvalue = vdataset . get Y Value ( series , item ) ; uvalue = lvalue + delta ; } minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } else { for ( int series = NUM ; series < series Count ; series ++ ) { int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM ; item < item Count ; item ++ ) { lvalue = dataset . get Y Value ( series , item ) ; uvalue = lvalue ; minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } if ( minimum > maximum ) { return null ; } else { return new Range ( minimum , maximum ) ; } }
protected void open Button ( ) { if ( loco Box . get Selected Roster Entries ( ) . length != NUM ) { open Known Loco ( ) ; } else if ( is Decoder Selected ( ) ) { open New Loco ( ) ; } else { log . error ( STRING ) ; } }
protected void open Button ( ) { if ( loco Box . get Selected Roster Entries ( ) . length != NUM ) { open Known Loco ( ) ; } else if ( is Decoder Selected ( ) ) { open New Loco ( ) ; } else { log . error ( STRING ) ; } }
public void add Targeted By Swarm ( int entity Id , int weapon Id ) { hit By Swarms Entity . add Element ( new Integer ( entity Id ) ) ; hit By Swarms Weapon . add Element ( new Integer ( weapon Id ) ) ; }
public void add Native Child At ( React Shadow Node child , int native Index ) { Assertions . assert Condition ( ! m Is Layout Only ) ; Assertions . assert Condition ( ! child . m Is Layout Only ) ; if ( m Native Children == null ) { m Native Children = new Array List < > ( NUM ) ; } m Native Children . add ( native Index , child ) ; child . m Native Parent = this ; }
public void add Native Child At ( React Shadow Node child , int native Index ) { Assertions . assert Condition ( ! m Is Layout Only ) ; Assertions . assert Condition ( ! child . m Is Layout Only ) ; if ( m Native Children == null ) { m Native Children = new Array List < > ( NUM ) ; } m Native Children . add ( native Index , child ) ; child . m Native Parent = this ; }
public void add Native Child At ( React Shadow Node child , int native Index ) { Assertions . assert Condition ( ! m Is Layout Only ) ; Assertions . assert Condition ( ! child . m Is Layout Only ) ; if ( m Native Children == null ) { m Native Children = new Array List < > ( NUM ) ; } m Native Children . add ( native Index , child ) ; child . m Native Parent = this ; }
private void read Download Apps ( Xml Pull Parser parser , Set < Download App Info > apps ) throws Xml Pull Parser Exception , IO Exception { while ( parser . next ( ) != Xml Pull Parser . END TAG ) { if ( parser . get Event Type ( ) != Xml Pull Parser . START TAG ) { continue ; } String name = parser . get Name ( ) ; if ( TAG APP . equals ( name ) ) { String package Name = parser . get Attribute Value ( null , ATTRIBUTE PACKAGE NAME ) ; String download Location = parser . get Attribute Value ( null , ATTRIBUTE DOWNLOAD LOCATION ) ; if ( package Name != null && download Location != null ) { apps . add ( new Download App Info ( package Name , download Location ) ) ; } skip Current Tag ( parser ) ; } } }
public static void reindex ( Connection conn ) throws SQL Exception { init ( conn ) ; remove All Triggers ( conn , TRIGGER PREFIX ) ; remove Index Files ( conn ) ; Statement stat = conn . create Statement ( ) ; Result Set rs = stat . execute Query ( STRING + SCHEMA + STRING ) ; while ( rs . next ( ) ) { String schema = rs . get String ( STRING ) ; String table = rs . get String ( STRING ) ; create Trigger ( conn , schema , table ) ; index Existing Rows ( conn , schema , table ) ; } }
public static void reindex ( Connection conn ) throws SQL Exception { init ( conn ) ; remove All Triggers ( conn , TRIGGER PREFIX ) ; remove Index Files ( conn ) ; Statement stat = conn . create Statement ( ) ; Result Set rs = stat . execute Query ( STRING + SCHEMA + STRING ) ; while ( rs . next ( ) ) { String schema = rs . get String ( STRING ) ; String table = rs . get String ( STRING ) ; create Trigger ( conn , schema , table ) ; index Existing Rows ( conn , schema , table ) ; } }
private Array DBI Ds compute M current ( DBI Ds m , DBI Ds m best , DBI Ds m bad , Random random ) { Array Modifiable DBI Ds m list = DBID Util . new Array ( m ) ; m list . remove DBI Ds ( m best ) ; DBID Array M Iter it = m list . iter ( ) ; Array Modifiable DBI Ds m current = DBID Util . new Array ( ) ; for ( DBID Iter iter = m best . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { if ( m bad . contains ( iter ) ) { int current Size = m current . size ( ) ; while ( m current . size ( ) == current Size ) { m current . add ( it . seek ( random . next Int ( m list . size ( ) ) ) ) ; it . remove ( ) ; } } else { m current . add ( iter ) ; } } return m current ; }
private List < Integer > convert To List ( int [ ] data ) { Integer [ ] wrapper Type = Array Utils . to Object ( data ) ; return Arrays . as List ( wrapper Type ) ; }
private List < Integer > convert To List ( int [ ] data ) { Integer [ ] wrapper Type = Array Utils . to Object ( data ) ; return Arrays . as List ( wrapper Type ) ; }
public void add Listener ( I Frequency Change Processor processor ) { if ( ! m Processors . contains ( processor ) ) { m Processors . add ( processor ) ; } }
public void add Listener ( I Frequency Change Processor processor ) { if ( ! m Processors . contains ( processor ) ) { m Processors . add ( processor ) ; } }
public void add Listener ( I Frequency Change Processor processor ) { if ( ! m Processors . contains ( processor ) ) { m Processors . add ( processor ) ; } }
public void wait For Current Operations ( long timeout ) { long start Time = System . current Time Millis ( ) ; long warn Time = start Time + timeout ; long quit Time = warn Time + timeout - NUM ; boolean warned = BOOL ; final boolean is Debug Enabled STATE FLUSH OP = logger . is Trace Enabled ( Log Marker . STATE FLUSH OP ) ; while ( BOOL ) { long op Count ; synchronized ( this . op Count Lock ) { op Count = this . previous Version Op Count ; } if ( op Count <= NUM ) { break ; } if ( is Debug Enabled STATE FLUSH OP ) { logger . trace ( Log Marker . STATE FLUSH OP , STRING , op Count ) ; } try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { throw new Gem Fire IO Exception ( STRING ) ; } long now = System . current Time Millis ( ) ; if ( ( ! warned ) && System . current Time Millis ( ) >= warn Time ) { warned = BOOL ; logger . warn ( Localized Message . create ( Localized Strings . Distribution Advisor 0 SEC HAVE ELAPSED WHILE WAITING FOR CURRENT OPERATIONS TO DISTRIBUTE , Long . to String ( ( warn Time - start Time ) / NUM ) ) ) ; } else if ( warned && ( now >= quit Time ) ) { throw new Gem Fire IO Exception ( STRING + ( now - start Time ) + STRING ) ; } } if ( this . membership Closed ) { if ( is Debug Enabled STATE FLUSH OP ) { logger . trace ( Log Marker . STATE FLUSH OP , STRING ) ; } } }
private static String do Get Full Path ( String filename , boolean include Separator ) { if ( filename == null ) { return null ; } int prefix = get Prefix Length ( filename ) ; if ( prefix < NUM ) { return null ; } if ( prefix >= filename . length ( ) ) { if ( include Separator ) { return get Prefix ( filename ) ; } else { return filename ; } } int index = index Of Last Separator ( filename ) ; if ( index < NUM ) { return filename . substring ( NUM , prefix ) ; } int end = index + ( include Separator ? NUM : NUM ) ; if ( end == NUM ) { end ++ ; } return filename . substring ( NUM , end ) ; }
public static AM Identity create A Test User ( SSO Token admin Token , String username , String realm ) throws Id Repo Exception , SSO Exception { AM Identity Repository amir = new AM Identity Repository ( admin Token , realm ) ; Map < String , Set < String > > attr Values = new Hash Map < String , Set < String > > ( ) ; Set < String > set = new Hash Set < String > ( ) ; set . add ( username ) ; attr Values . put ( STRING , set ) ; attr Values . put ( STRING , set ) ; attr Values . put ( STRING , set ) ; attr Values . put ( STRING , set ) ; return amir . create Identity ( Id Type . USER , username , attr Values ) ; }
public static AM Identity create A Test User ( SSO Token admin Token , String username , String realm ) throws Id Repo Exception , SSO Exception { AM Identity Repository amir = new AM Identity Repository ( admin Token , realm ) ; Map < String , Set < String > > attr Values = new Hash Map < String , Set < String > > ( ) ; Set < String > set = new Hash Set < String > ( ) ; set . add ( username ) ; attr Values . put ( STRING , set ) ; attr Values . put ( STRING , set ) ; attr Values . put ( STRING , set ) ; attr Values . put ( STRING , set ) ; return amir . create Identity ( Id Type . USER , username , attr Values ) ; }
public boolean contains Value ( Object value ) { return contains ( value ) ; }
public boolean contains Value ( Object value ) { return contains ( value ) ; }
public Player Level Up Rewards ( final Status status ) { this . status = status ; this . rewards = Collections . empty List ( ) ; this . unlocked Items = Collections . empty List ( ) ; }
private Resource pack Icon ( int dpi , Bitmap icon ) { Resource res = new Resource ( ) ; res . dpi = dpi ; Byte Array Output Stream os = new Byte Array Output Stream ( ) ; if ( icon . compress ( IMAGE FORMAT , IMAGE COMPRESSION QUALITY , os ) ) { res . data = os . to Byte Array ( ) ; } return res ; }
public boolean is Folder ( ) { return m Mime Type != null && m Mime Type . equals ( STRING ) ; }
public boolean is Folder ( ) { return m Mime Type != null && m Mime Type . equals ( STRING ) ; }
private void reposition ( int start Index ) { for ( int j = start Index ; j < icon Managers . size ( ) ; j ++ ) { Abstract Status Icon Manager follower = icon Managers . get ( j ) ; if ( shares Position ( follower ) ) { follower . set Visible ( BOOL ) ; follower . position ( ) ; follower . set Visible ( BOOL ) ; break ; } } }
public Writable Raster create Compatible Writable Raster ( int w , int h ) { if ( w <= NUM || h <= NUM ) { throw new Raster Format Exception ( STRING + ( ( w <= NUM ) ? STRING : STRING ) ) ; } Sample Model sm = sample Model . create Compatible Sample Model ( w , h ) ; return new Byte Packed Raster ( sm , new Point ( NUM , NUM ) ) ; }
public void remove Key Listener ( Global Key Listener listener ) { listeners . remove ( listener ) ; }
@ Suppress Warnings ( STRING ) public void add Entry ( Entry e ) { if ( e == null ) return ; float val = e . get Val ( ) ; if ( mY Vals == null ) { mY Vals = new Array List < T > ( ) ; } if ( mY Vals . size ( ) == NUM ) { mY Max = val ; mY Min = val ; } else { if ( mY Max < val ) mY Max = val ; if ( mY Min > val ) mY Min = val ; } mY Value Sum += val ; mY Vals . add ( ( T ) e ) ; }
@ Suppress Warnings ( STRING ) public void add Entry ( Entry e ) { if ( e == null ) return ; float val = e . get Val ( ) ; if ( mY Vals == null ) { mY Vals = new Array List < T > ( ) ; } if ( mY Vals . size ( ) == NUM ) { mY Max = val ; mY Min = val ; } else { if ( mY Max < val ) mY Max = val ; if ( mY Min > val ) mY Min = val ; } mY Value Sum += val ; mY Vals . add ( ( T ) e ) ; }
public static < E extends Enum < E > > Enum Set < E > of ( E e ) { Enum Set < E > result = none Of ( e . get Declaring Class ( ) ) ; result . add ( e ) ; return result ; }
public static < E extends Enum < E > > Enum Set < E > of ( E e ) { Enum Set < E > result = none Of ( e . get Declaring Class ( ) ) ; result . add ( e ) ; return result ; }
public static < E extends Enum < E > > Enum Set < E > of ( E e ) { Enum Set < E > result = none Of ( e . get Declaring Class ( ) ) ; result . add ( e ) ; return result ; }
public static < E extends Enum < E > > Enum Set < E > of ( E e ) { Enum Set < E > result = none Of ( e . get Declaring Class ( ) ) ; result . add ( e ) ; return result ; }
public static < E extends Enum < E > > Enum Set < E > of ( E e ) { Enum Set < E > result = none Of ( e . get Declaring Class ( ) ) ; result . add ( e ) ; return result ; }
public static < E extends Enum < E > > Enum Set < E > of ( E e ) { Enum Set < E > result = none Of ( e . get Declaring Class ( ) ) ; result . add ( e ) ; return result ; }
public static < E extends Enum < E > > Enum Set < E > of ( E e ) { Enum Set < E > result = none Of ( e . get Declaring Class ( ) ) ; result . add ( e ) ; return result ; }
public static < E extends Enum < E > > Enum Set < E > of ( E e ) { Enum Set < E > result = none Of ( e . get Declaring Class ( ) ) ; result . add ( e ) ; return result ; }
public Object lookup ( Faces Context faces Context , String name ) { Object object = null ; try { Initial Context context = new Initial Context ( ) ; object = context . lookup ( name ) ; } catch ( Naming Exception ne ) { if ( LOGGER . is Loggable ( Level . WARNING ) ) { LOGGER . log ( Level . WARNING , STRING + name , ne ) ; } if ( faces Context . is Project Stage ( Project Stage . Development ) ) { faces Context . add Message ( null , new Faces Message ( STRING + name , STRING + name ) ) ; } } return object ; }
public Object lookup ( Faces Context faces Context , String name ) { Object object = null ; try { Initial Context context = new Initial Context ( ) ; object = context . lookup ( name ) ; } catch ( Naming Exception ne ) { if ( LOGGER . is Loggable ( Level . WARNING ) ) { LOGGER . log ( Level . WARNING , STRING + name , ne ) ; } if ( faces Context . is Project Stage ( Project Stage . Development ) ) { faces Context . add Message ( null , new Faces Message ( STRING + name , STRING + name ) ) ; } } return object ; }
private void signal Control Op End ( ) { control Operation Executing . set ( BOOL ) ; Lock Support . unpark ( control Waiters . peek ( ) ) ; if ( control Waiters . size ( ) == NUM ) { Thread t = eval Waiters . poll ( ) ; while ( t != null ) { Lock Support . unpark ( t ) ; t = eval Waiters . poll ( ) ; } } }
private void signal Control Op End ( ) { control Operation Executing . set ( BOOL ) ; Lock Support . unpark ( control Waiters . peek ( ) ) ; if ( control Waiters . size ( ) == NUM ) { Thread t = eval Waiters . poll ( ) ; while ( t != null ) { Lock Support . unpark ( t ) ; t = eval Waiters . poll ( ) ; } } }
private void signal Control Op End ( ) { control Operation Executing . set ( BOOL ) ; Lock Support . unpark ( control Waiters . peek ( ) ) ; if ( control Waiters . size ( ) == NUM ) { Thread t = eval Waiters . poll ( ) ; while ( t != null ) { Lock Support . unpark ( t ) ; t = eval Waiters . poll ( ) ; } } }
private void signal Control Op End ( ) { control Operation Executing . set ( BOOL ) ; Lock Support . unpark ( control Waiters . peek ( ) ) ; if ( control Waiters . size ( ) == NUM ) { Thread t = eval Waiters . poll ( ) ; while ( t != null ) { Lock Support . unpark ( t ) ; t = eval Waiters . poll ( ) ; } } }
private void signal Control Op End ( ) { control Operation Executing . set ( BOOL ) ; Lock Support . unpark ( control Waiters . peek ( ) ) ; if ( control Waiters . size ( ) == NUM ) { Thread t = eval Waiters . poll ( ) ; while ( t != null ) { Lock Support . unpark ( t ) ; t = eval Waiters . poll ( ) ; } } }
private void signal Control Op End ( ) { control Operation Executing . set ( BOOL ) ; Lock Support . unpark ( control Waiters . peek ( ) ) ; if ( control Waiters . size ( ) == NUM ) { Thread t = eval Waiters . poll ( ) ; while ( t != null ) { Lock Support . unpark ( t ) ; t = eval Waiters . poll ( ) ; } } }
private void signal Control Op End ( ) { control Operation Executing . set ( BOOL ) ; Lock Support . unpark ( control Waiters . peek ( ) ) ; if ( control Waiters . size ( ) == NUM ) { Thread t = eval Waiters . poll ( ) ; while ( t != null ) { Lock Support . unpark ( t ) ; t = eval Waiters . poll ( ) ; } } }
private void signal Control Op End ( ) { control Operation Executing . set ( BOOL ) ; Lock Support . unpark ( control Waiters . peek ( ) ) ; if ( control Waiters . size ( ) == NUM ) { Thread t = eval Waiters . poll ( ) ; while ( t != null ) { Lock Support . unpark ( t ) ; t = eval Waiters . poll ( ) ; } } }
private void signal Control Op End ( ) { control Operation Executing . set ( BOOL ) ; Lock Support . unpark ( control Waiters . peek ( ) ) ; if ( control Waiters . size ( ) == NUM ) { Thread t = eval Waiters . poll ( ) ; while ( t != null ) { Lock Support . unpark ( t ) ; t = eval Waiters . poll ( ) ; } } }
private void signal Control Op End ( ) { control Operation Executing . set ( BOOL ) ; Lock Support . unpark ( control Waiters . peek ( ) ) ; if ( control Waiters . size ( ) == NUM ) { Thread t = eval Waiters . poll ( ) ; while ( t != null ) { Lock Support . unpark ( t ) ; t = eval Waiters . poll ( ) ; } } }
public static Object [ ] assert Thread Id To Sequence Id Map Has Entry Ids ( ) { Event ID [ ] evids = new Event ID [ NUM ] ; Map map = pool . get Thread Id To Sequence Id Map ( ) ; assert Not Null ( map ) ; evids [ NUM ] = put Allevent Id 1 ; evids [ NUM ] = put Allevent Id 2 ; evids [ NUM ] = put Allevent Id 3 ; evids [ NUM ] = put Allevent Id 4 ; evids [ NUM ] = put Allevent Id 5 ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; return evids ; }
public static Object [ ] assert Thread Id To Sequence Id Map Has Entry Ids ( ) { Event ID [ ] evids = new Event ID [ NUM ] ; Map map = pool . get Thread Id To Sequence Id Map ( ) ; assert Not Null ( map ) ; evids [ NUM ] = put Allevent Id 1 ; evids [ NUM ] = put Allevent Id 2 ; evids [ NUM ] = put Allevent Id 3 ; evids [ NUM ] = put Allevent Id 4 ; evids [ NUM ] = put Allevent Id 5 ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; return evids ; }
public static Object [ ] assert Thread Id To Sequence Id Map Has Entry Ids ( ) { Event ID [ ] evids = new Event ID [ NUM ] ; Map map = pool . get Thread Id To Sequence Id Map ( ) ; assert Not Null ( map ) ; evids [ NUM ] = put Allevent Id 1 ; evids [ NUM ] = put Allevent Id 2 ; evids [ NUM ] = put Allevent Id 3 ; evids [ NUM ] = put Allevent Id 4 ; evids [ NUM ] = put Allevent Id 5 ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; return evids ; }
@ Override public int locations ( ) { return NUM ; }
public void clear ( ) { selected Tasks . clear ( ) ; fire Selection Changed ( ) ; }
public static String id ( Object ... ss ) { String Builder sb = new String Builder ( ) ; for ( Object s : ss ) { if ( sb . length ( ) > NUM ) sb . append ( STRING ) ; sb . append ( s ) ; } return id ( hash ( sb . to String ( ) ) ) ; }
public KC Response ( String status , String mime Type , String txt ) { this . status = status ; this . mime Type = mime Type ; try { this . data = new Byte Array Input Stream ( txt . get Bytes ( STRING ) ) ; } catch ( java . io . Unsupported Encoding Exception uee ) { KC Log . e ( uee ) ; } }
public KC Response ( String status , String mime Type , String txt ) { this . status = status ; this . mime Type = mime Type ; try { this . data = new Byte Array Input Stream ( txt . get Bytes ( STRING ) ) ; } catch ( java . io . Unsupported Encoding Exception uee ) { KC Log . e ( uee ) ; } }
public void add ( URI uri , Http Cookie cookie ) { if ( cookie == null ) { throw new Null Pointer Exception ( STRING ) ; } lock . lock ( ) ; try { cookie Jar . remove ( cookie ) ; if ( cookie . get Max Age ( ) != NUM ) { cookie Jar . add ( cookie ) ; if ( cookie . get Domain ( ) != null ) { add Index ( domain Index , cookie . get Domain ( ) , cookie ) ; } if ( uri != null ) { add Index ( uri Index , get Effective URI ( uri ) , cookie ) ; } } } finally { lock . unlock ( ) ; } }
public static byte [ ] write To Array ( NS Object root ) throws IO Exception { Byte Array Output Stream bout = new Byte Array Output Stream ( ) ; write ( bout , root ) ; return bout . to Byte Array ( ) ; }
public void write Byte ( final byte octet ) { if ( remaining ( ) < NUM ) { if ( index == blocks . size ( ) - NUM ) { allocate New Block ( ) ; } index ++ ; current = blocks . get ( index ) ; } final Block block = current ; block . data [ block . limit ] = octet ; block . limit ++ ; }
public void remove Result Listener ( Result Listener listener ) { listener List . remove ( listener ) ; }
private static J Free Chart create Chart ( ) { XY Series series 1 = new XY Series ( STRING ) ; series 1 . add ( NUM , NUM ) ; series 1 . add ( NUM , NUM ) ; series 1 . add ( NUM , NUM ) ; XY Dataset dataset = new XY Series Collection ( series 1 ) ; return Chart Factory . create XY Step Area Chart ( STRING , STRING , STRING , dataset ) ; }
public void release Shared ( ) { shared . unlock ( ) ; }
void show ( ) { if ( m Is Visible ) return ; m Is Visible = BOOL ; m Height Px = Math . round ( m Default Height Px ) ; invalidate ( ) ; }
void show ( ) { if ( m Is Visible ) return ; m Is Visible = BOOL ; m Height Px = Math . round ( m Default Height Px ) ; invalidate ( ) ; }
void show ( ) { if ( m Is Visible ) return ; m Is Visible = BOOL ; m Height Px = Math . round ( m Default Height Px ) ; invalidate ( ) ; }
void show ( ) { if ( m Is Visible ) return ; m Is Visible = BOOL ; m Height Px = Math . round ( m Default Height Px ) ; invalidate ( ) ; }
public static void close Quiet ( @ Nullable Selection Key rsrc ) { if ( rsrc != null ) close Quiet ( rsrc . channel ( ) ) ; }
private void sort List Locked ( ) { Collections . sort ( m Albums , m Comparator ) ; }
private byte [ ] windows Absolute Path ( ) { Byte Array Output Stream bstream = new Byte Array Output Stream ( ) ; bstream . write ( WINDOWS ROOT PATH , NUM , WINDOWS ROOT PATH . length - NUM ) ; String Tokenizer tokenizer = new String Tokenizer ( absolute Path ( ) , STRING ) ; while ( tokenizer . has More Tokens ( ) ) { bstream . write ( ( byte ) STRING ) ; String next Name = tokenizer . next Token ( ) ; byte [ ] windows Next Name = to Windows Name ( next Name ) ; bstream . write ( windows Next Name , NUM , windows Next Name . length - NUM ) ; } bstream . write ( NUM ) ; return bstream . to Byte Array ( ) ; }
public static String transform Class Name ( String class Name ) { int last Dot = class Name . last Index Of ( STRING ) ; if ( last Dot >= NUM ) { String pkg = class Name . substring ( NUM , last Dot ) ; if ( ! is Unlikely To Be Renamed ( pkg ) ) { class Name = class Name . substring ( last Dot + NUM ) ; } } return class Name ; }
@ Deprecated public void write XML ( Writer out , String indent , boolean hide Default ) throws IO Exception { write XML ( out , hide Default ) ; }
public void start ( ) { if ( set State ( Enum Set . of ( Task State . INITIAL , Task State . QUEUED ) , Task State . RUNNING ) ) { DHT . log Debug ( STRING + to String ( ) ) ; start Time = System . current Time Millis ( ) ; try { serialized Update . run ( ) ; } catch ( Exception e ) { DHT . log ( e , Log Level . Error ) ; } } }
public int match ( byte [ ] search , int offset , int length ) { int ret = - NUM ; int search Length = search . length ; if ( search Length > NUM ) { int limit = Math . min ( offset + length , buffer . size ( ) ) - search Length - offset ; byte byte 0 = search [ NUM ] ; for ( int start = offset ; start <= limit ; ++ start ) { if ( buffer . get Byte ( start ) == byte 0 ) { int i = NUM ; for ( ; i < search Length ; ++ i ) { if ( search [ i ] != buffer . get Byte ( start + i ) ) { break ; } } if ( i == search Length ) { ret = start ; break ; } } } } return ret ; }
protected void add ( Instance inst ) { for ( int i = NUM ; i < m Specifiers . size ( ) ; i ++ ) { Instance specifier = m Specifiers . get ( i ) ; boolean found = BOOL ; for ( int m Dataset Key Column : m Dataset Key Columns ) { if ( inst . value ( m Dataset Key Column ) != specifier . value ( m Dataset Key Column ) ) { found = BOOL ; } } if ( found ) { return ; } } m Specifiers . add ( inst ) ; }
public boolean draw Image ( Image img , Affine Transform xform , Image Observer obs ) { if ( img == null ) { return BOOL ; } boolean result ; int src Width = img . get Width ( null ) ; int src Height = img . get Height ( null ) ; if ( src Width < NUM || src Height < NUM ) { result = BOOL ; } else { result = draw Image To Platform ( img , xform , null , NUM , NUM , src Width , src Height , BOOL ) ; } return result ; }
public boolean draw Image ( Image img , Affine Transform xform , Image Observer obs ) { if ( img == null ) { return BOOL ; } boolean result ; int src Width = img . get Width ( null ) ; int src Height = img . get Height ( null ) ; if ( src Width < NUM || src Height < NUM ) { result = BOOL ; } else { result = draw Image To Platform ( img , xform , null , NUM , NUM , src Width , src Height , BOOL ) ; } return result ; }
public boolean draw Image ( Image img , Affine Transform xform , Image Observer obs ) { if ( img == null ) { return BOOL ; } boolean result ; int src Width = img . get Width ( null ) ; int src Height = img . get Height ( null ) ; if ( src Width < NUM || src Height < NUM ) { result = BOOL ; } else { result = draw Image To Platform ( img , xform , null , NUM , NUM , src Width , src Height , BOOL ) ; } return result ; }
public static boolean is Control Or Meta Down ( Mouse Event e ) { if ( ! IS MAC ) { return e . is Control Down ( ) ; } else { return e . is Meta Down ( ) ; } }
public static boolean is Control Or Meta Down ( Mouse Event e ) { if ( ! IS MAC ) { return e . is Control Down ( ) ; } else { return e . is Meta Down ( ) ; } }
public void certificate Created ( long start Time Ms , long finish Time Ms ) { certificates Generated . increment And Get ( ) ; certificate Generation Time Ms . add And Get ( finish Time Ms - start Time Ms ) ; first Certificate Generated Timestamp . compare And Set ( NUM , System . current Time Millis ( ) ) ; }
public void certificate Created ( long start Time Ms , long finish Time Ms ) { certificates Generated . increment And Get ( ) ; certificate Generation Time Ms . add And Get ( finish Time Ms - start Time Ms ) ; first Certificate Generated Timestamp . compare And Set ( NUM , System . current Time Millis ( ) ) ; }
private String glob To Regex ( String glob ) { if ( glob . char At ( NUM ) == STRING || glob . contains ( STRING ) || glob . contains ( STRING ) ) { throw new Illegal Argument Exception ( STRING ) ; } glob = glob . replace ( STRING , STRING ) ; glob = glob . replace ( STRING , STRING ) ; glob = glob . replace ( STRING , STRING ) ; return glob ; }
private void update Bounds For Added Item ( Time Series Data Item item ) { Number yN = item . get Value ( ) ; if ( item . get Value ( ) != null ) { double y = yN . double Value ( ) ; this . min Y = min Ignore Na N ( this . min Y , y ) ; this . max Y = max Ignore Na N ( this . max Y , y ) ; } }
public static void encode ( Appendable out , int value ) throws IO Exception { value = to VLQ Signed ( value ) ; do { int digit = value & VLQ BASE MASK ; value >>>= VLQ BASE SHIFT ; if ( value > NUM ) { digit |= VLQ CONTINUATION BIT ; } out . append ( Base 64 . to Base 64 ( digit ) ) ; } while ( value > NUM ) ; }
public boolean remove Message ( String message ) { SQ Lite Database db = get Writable Database ( ) ; if ( db != null && message != null ) { db . exec SQL ( STRING + TABLE + STRING + COL DELETED + STRING + TRUE + STRING + COL MESSAGE + STRING + message + STRING ) ; return BOOL ; } log . debug ( STRING + message + STRING ) ; return BOOL ; }
public static String compute Simpson Reciprocal ( Viewer Base viewer , Progress Listener progress Listener ) throws IO Exception , Canceled Exception { if ( viewer instanceof Main Viewer ) return to String ( compute Simpson Reciprocal ( ( Main Viewer ) viewer , progress Listener ) ) ; else if ( viewer instanceof Classification Viewer ) return to String ( compute Simpson Reciprocal ( ( Classification Viewer ) viewer , progress Listener ) ) ; else return null ; }
public static String compute Simpson Reciprocal ( Viewer Base viewer , Progress Listener progress Listener ) throws IO Exception , Canceled Exception { if ( viewer instanceof Main Viewer ) return to String ( compute Simpson Reciprocal ( ( Main Viewer ) viewer , progress Listener ) ) ; else if ( viewer instanceof Classification Viewer ) return to String ( compute Simpson Reciprocal ( ( Classification Viewer ) viewer , progress Listener ) ) ; else return null ; }
public void read ( Data Input Stream in ) throws IO Exception { if ( in . read Int ( ) != FILE VERSION ) { } String [ ] names = new String [ in . read Short ( ) ] ; for ( int i = NUM ; i < names . length ; i ++ ) { names [ i ] = in . read UTF ( ) ; } int num = in . read Short ( ) ; for ( int i = NUM ; i < num ; i ++ ) { short name Id = in . read Short ( ) ; int type = in . read Byte ( ) ; String name = in . read UTF ( ) ; def Entity ( names [ name Id ] , type | GENERAL , name ) ; } num = in . read Short ( ) ; for ( int i = NUM ; i < num ; i ++ ) { short name Id = in . read Short ( ) ; int type = in . read Byte ( ) ; byte flags = in . read Byte ( ) ; Content Model m = read Content Model ( in , names ) ; String [ ] exclusions = read Name Array ( in , names ) ; String [ ] inclusions = read Name Array ( in , names ) ; Attribute List atts = read Attribute List ( in , names ) ; def Element ( names [ name Id ] , type , ( ( flags & NUM ) != NUM ) , ( ( flags & NUM ) != NUM ) , m , exclusions , inclusions , atts ) ; } }
default < T > void for Each Matching Field Name With Integer ( String regex , int group Number , Bi Consumer < String , Integer > function ) { for Each Matching Field Name With Integer ( Pattern . compile ( regex ) , group Number , function ) ; }
protected Abstract Region Painter ( ) { focus Insets = UI Manager . get Insets ( STRING ) ; }
public boolean is Mine ( Wallet wallet ) { try { Script script = get Script Pub Key ( ) ; if ( script . is Sent To Raw Pub Key ( ) ) { byte [ ] pubkey = script . get Pub Key ( ) ; return wallet . is Pub Key Mine ( pubkey ) ; } else { byte [ ] pubkey Hash = script . get Pub Key Hash ( ) ; return wallet . is Pub Key Hash Mine ( pubkey Hash ) ; } } catch ( Script Exception e ) { log . debug ( STRING , e . to String ( ) ) ; return BOOL ; } }
public void remove Morph Listener ( Morph Listener listener ) { m Morph Listeners . remove ( listener ) ; }
public void remove Morph Listener ( Morph Listener listener ) { m Morph Listeners . remove ( listener ) ; }
private String Builder make Description ( Collection < Relation < ? > > relations , DBID Ref id ) { String Builder buf = new String Builder ( ) ; for ( Relation < ? > rel : relations ) { Object o = rel . get ( id ) ; if ( o == null ) { continue ; } String s = o . to String ( ) ; if ( s != null ) { if ( buf . length ( ) > NUM ) { buf . append ( STRING ) ; } buf . append ( s ) ; } } return buf ; }
public void rotate ( double theta ) { current Transform . rotate ( theta ) ; try { write Transform ( new Affine Transform ( Math . cos ( theta ) , Math . sin ( theta ) , - Math . sin ( theta ) , Math . cos ( theta ) , NUM , NUM ) ) ; } catch ( IO Exception e ) { handle Exception ( e ) ; } }
public void rotate ( double theta ) { current Transform . rotate ( theta ) ; try { write Transform ( new Affine Transform ( Math . cos ( theta ) , Math . sin ( theta ) , - Math . sin ( theta ) , Math . cos ( theta ) , NUM , NUM ) ) ; } catch ( IO Exception e ) { handle Exception ( e ) ; } }
public void rotate ( double theta ) { current Transform . rotate ( theta ) ; try { write Transform ( new Affine Transform ( Math . cos ( theta ) , Math . sin ( theta ) , - Math . sin ( theta ) , Math . cos ( theta ) , NUM , NUM ) ) ; } catch ( IO Exception e ) { handle Exception ( e ) ; } }
public int read ( ) throws IO Exception { int b0 = f Input Stream . read ( ) & NUM ; if ( b0 == NUM ) return - NUM ; int b1 = f Input Stream . read ( ) & NUM ; if ( b1 == NUM ) return - NUM ; if ( f Encoding >= NUM ) { int b2 = f Input Stream . read ( ) & NUM ; if ( b2 == NUM ) return - NUM ; int b3 = f Input Stream . read ( ) & NUM ; if ( b3 == NUM ) return - NUM ; if ( log . is Loggable ( Level . FINE ) ) log . fine ( STRING + ( b0 & NUM ) + STRING + ( b1 & NUM ) + STRING + ( b2 & NUM ) + STRING + ( b3 & NUM ) ) ; if ( f Encoding == UCS 4 BE ) return ( b0 << NUM ) + ( b1 << NUM ) + ( b2 << NUM ) + b3 ; else return ( b3 << NUM ) + ( b2 << NUM ) + ( b1 << NUM ) + b0 ; } else { if ( f Encoding == UCS 2 BE ) return ( b0 << NUM ) + b1 ; else return ( b1 << NUM ) + b0 ; } }
public int read ( ) throws IO Exception { int b0 = f Input Stream . read ( ) & NUM ; if ( b0 == NUM ) return - NUM ; int b1 = f Input Stream . read ( ) & NUM ; if ( b1 == NUM ) return - NUM ; if ( f Encoding >= NUM ) { int b2 = f Input Stream . read ( ) & NUM ; if ( b2 == NUM ) return - NUM ; int b3 = f Input Stream . read ( ) & NUM ; if ( b3 == NUM ) return - NUM ; if ( log . is Loggable ( Level . FINE ) ) log . fine ( STRING + ( b0 & NUM ) + STRING + ( b1 & NUM ) + STRING + ( b2 & NUM ) + STRING + ( b3 & NUM ) ) ; if ( f Encoding == UCS 4 BE ) return ( b0 << NUM ) + ( b1 << NUM ) + ( b2 << NUM ) + b3 ; else return ( b3 << NUM ) + ( b2 << NUM ) + ( b1 << NUM ) + b0 ; } else { if ( f Encoding == UCS 2 BE ) return ( b0 << NUM ) + b1 ; else return ( b1 << NUM ) + b0 ; } }
public int read ( ) throws IO Exception { int b0 = f Input Stream . read ( ) & NUM ; if ( b0 == NUM ) return - NUM ; int b1 = f Input Stream . read ( ) & NUM ; if ( b1 == NUM ) return - NUM ; if ( f Encoding >= NUM ) { int b2 = f Input Stream . read ( ) & NUM ; if ( b2 == NUM ) return - NUM ; int b3 = f Input Stream . read ( ) & NUM ; if ( b3 == NUM ) return - NUM ; if ( log . is Loggable ( Level . FINE ) ) log . fine ( STRING + ( b0 & NUM ) + STRING + ( b1 & NUM ) + STRING + ( b2 & NUM ) + STRING + ( b3 & NUM ) ) ; if ( f Encoding == UCS 4 BE ) return ( b0 << NUM ) + ( b1 << NUM ) + ( b2 << NUM ) + b3 ; else return ( b3 << NUM ) + ( b2 << NUM ) + ( b1 << NUM ) + b0 ; } else { if ( f Encoding == UCS 2 BE ) return ( b0 << NUM ) + b1 ; else return ( b1 << NUM ) + b0 ; } }
public int read ( ) throws IO Exception { int b0 = f Input Stream . read ( ) & NUM ; if ( b0 == NUM ) return - NUM ; int b1 = f Input Stream . read ( ) & NUM ; if ( b1 == NUM ) return - NUM ; if ( f Encoding >= NUM ) { int b2 = f Input Stream . read ( ) & NUM ; if ( b2 == NUM ) return - NUM ; int b3 = f Input Stream . read ( ) & NUM ; if ( b3 == NUM ) return - NUM ; if ( log . is Loggable ( Level . FINE ) ) log . fine ( STRING + ( b0 & NUM ) + STRING + ( b1 & NUM ) + STRING + ( b2 & NUM ) + STRING + ( b3 & NUM ) ) ; if ( f Encoding == UCS 4 BE ) return ( b0 << NUM ) + ( b1 << NUM ) + ( b2 << NUM ) + b3 ; else return ( b3 << NUM ) + ( b2 << NUM ) + ( b1 << NUM ) + b0 ; } else { if ( f Encoding == UCS 2 BE ) return ( b0 << NUM ) + b1 ; else return ( b1 << NUM ) + b0 ; } }
public int read ( ) throws IO Exception { int b0 = f Input Stream . read ( ) & NUM ; if ( b0 == NUM ) return - NUM ; int b1 = f Input Stream . read ( ) & NUM ; if ( b1 == NUM ) return - NUM ; if ( f Encoding >= NUM ) { int b2 = f Input Stream . read ( ) & NUM ; if ( b2 == NUM ) return - NUM ; int b3 = f Input Stream . read ( ) & NUM ; if ( b3 == NUM ) return - NUM ; if ( log . is Loggable ( Level . FINE ) ) log . fine ( STRING + ( b0 & NUM ) + STRING + ( b1 & NUM ) + STRING + ( b2 & NUM ) + STRING + ( b3 & NUM ) ) ; if ( f Encoding == UCS 4 BE ) return ( b0 << NUM ) + ( b1 << NUM ) + ( b2 << NUM ) + b3 ; else return ( b3 << NUM ) + ( b2 << NUM ) + ( b1 << NUM ) + b0 ; } else { if ( f Encoding == UCS 2 BE ) return ( b0 << NUM ) + b1 ; else return ( b1 << NUM ) + b0 ; } }
static void handle Reopen ( ) { if ( allow Visible ) { if ( ! visible Once ) restore View ( ) ; set App Visible ( BOOL ) ; } }
static void handle Reopen ( ) { if ( allow Visible ) { if ( ! visible Once ) restore View ( ) ; set App Visible ( BOOL ) ; } }
static void handle Reopen ( ) { if ( allow Visible ) { if ( ! visible Once ) restore View ( ) ; set App Visible ( BOOL ) ; } }
static void handle Reopen ( ) { if ( allow Visible ) { if ( ! visible Once ) restore View ( ) ; set App Visible ( BOOL ) ; } }
public static Output Stream output Stream ( String out ) throws IO Exception { if ( out . equals ( STRING ) ) { return Forbidden Ok . system Dot Out ( ) ; } Files . create Parent Dirs ( new File ( out ) ) ; Output Stream stream = new Buffered Output Stream ( new File Output Stream ( out ) ) ; if ( out . ends With ( STRING ) ) { stream = new GZIP Output Stream ( stream ) ; } return stream ; }
public static Output Stream output Stream ( String out ) throws IO Exception { if ( out . equals ( STRING ) ) { return Forbidden Ok . system Dot Out ( ) ; } Files . create Parent Dirs ( new File ( out ) ) ; Output Stream stream = new Buffered Output Stream ( new File Output Stream ( out ) ) ; if ( out . ends With ( STRING ) ) { stream = new GZIP Output Stream ( stream ) ; } return stream ; }
public static Output Stream output Stream ( String out ) throws IO Exception { if ( out . equals ( STRING ) ) { return Forbidden Ok . system Dot Out ( ) ; } Files . create Parent Dirs ( new File ( out ) ) ; Output Stream stream = new Buffered Output Stream ( new File Output Stream ( out ) ) ; if ( out . ends With ( STRING ) ) { stream = new GZIP Output Stream ( stream ) ; } return stream ; }
public static List to Edges ( Collection dir Edges ) { List edges = new Array List ( ) ; for ( Iterator i = dir Edges . iterator ( ) ; i . has Next ( ) ; ) { edges . add ( ( ( Directed Edge ) i . next ( ) ) . parent Edge ) ; } return edges ; }
protected Key Pair generate Key Pair ( ) { Key Pair key Pair = null ; DH Parameter Spec key Spec = new DH Parameter Spec ( DH MODULUS , DH BASE ) ; try { Key Pair Generator key Gen = Key Pair Generator . get Instance ( STRING ) ; key Gen . initialize ( key Spec ) ; key Pair = key Gen . generate Key Pair ( ) ; key Agreement = Key Agreement . get Instance ( STRING ) ; key Agreement . init ( key Pair . get Private ( ) ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; } return key Pair ; }
public long insert Entry ( Array List < String > key , Array List < String > value ) { Content Values content Values = new Content Values ( ) ; for ( int i = NUM ; key . size ( ) > i ; i ++ ) { content Values . put ( key . get ( i ) , value . get ( i ) ) ; } Log . v ( STRING , content Values . to String ( ) ) ; return db . insert ( m Default Table , null , content Values ) ; }
private static Comparable < ? > cast To Comparable ( Object obj ) { try { return ( Comparable < ? > ) obj ; } catch ( Class Cast Exception cce ) { throw new Illegal Argument Exception ( STRING + obj . get Class ( ) + STRING + Storage Type . OBJECT + STRING , cce ) ; } }
private static Comparable < ? > cast To Comparable ( Object obj ) { try { return ( Comparable < ? > ) obj ; } catch ( Class Cast Exception cce ) { throw new Illegal Argument Exception ( STRING + obj . get Class ( ) + STRING + Storage Type . OBJECT + STRING , cce ) ; } }
public List < String > make URL List ( String shard ) { List < String > urls = Str Utils . split Smart ( shard , STRING , BOOL ) ; for ( int i = NUM ; i < urls . size ( ) ; i ++ ) { urls . set ( i , build Url ( urls . get ( i ) ) ) ; } if ( urls . size ( ) > NUM ) Collections . shuffle ( urls , r ) ; return urls ; }
@ Override public boolean input ( Instance instance ) { if ( get Input Format ( ) == null ) { throw new Illegal State Exception ( STRING ) ; } if ( m New Batch ) { reset Queue ( ) ; m New Batch = BOOL ; } if ( is First Batch Done ( ) && m dont Filter After First Batch ) { push ( ( Instance ) instance . copy ( ) ) ; return BOOL ; } if ( instance . is Missing ( m Att Index . get Index ( ) ) ) { if ( ! get Match Missing Values ( ) ) { push ( ( Instance ) instance . copy ( ) ) ; return BOOL ; } else { return BOOL ; } } if ( is Numeric ( ) ) { if ( ! m Values . get Invert ( ) ) { if ( instance . value ( m Att Index . get Index ( ) ) < m Value ) { push ( ( Instance ) instance . copy ( ) ) ; return BOOL ; } } else { if ( instance . value ( m Att Index . get Index ( ) ) >= m Value ) { push ( ( Instance ) instance . copy ( ) ) ; return BOOL ; } } } if ( is Nominal ( ) ) { if ( m Values . is In Range ( ( int ) instance . value ( m Att Index . get Index ( ) ) ) ) { Instance temp = ( Instance ) instance . copy ( ) ; if ( get Modify Header ( ) ) { temp . set Value ( m Att Index . get Index ( ) , m Nominal Mapping [ ( int ) instance . value ( m Att Index . get Index ( ) ) ] ) ; } push ( temp ) ; return BOOL ; } } return BOOL ; }
@ Override public boolean input ( Instance instance ) { if ( get Input Format ( ) == null ) { throw new Illegal State Exception ( STRING ) ; } if ( m New Batch ) { reset Queue ( ) ; m New Batch = BOOL ; } if ( is First Batch Done ( ) && m dont Filter After First Batch ) { push ( ( Instance ) instance . copy ( ) ) ; return BOOL ; } if ( instance . is Missing ( m Att Index . get Index ( ) ) ) { if ( ! get Match Missing Values ( ) ) { push ( ( Instance ) instance . copy ( ) ) ; return BOOL ; } else { return BOOL ; } } if ( is Numeric ( ) ) { if ( ! m Values . get Invert ( ) ) { if ( instance . value ( m Att Index . get Index ( ) ) < m Value ) { push ( ( Instance ) instance . copy ( ) ) ; return BOOL ; } } else { if ( instance . value ( m Att Index . get Index ( ) ) >= m Value ) { push ( ( Instance ) instance . copy ( ) ) ; return BOOL ; } } } if ( is Nominal ( ) ) { if ( m Values . is In Range ( ( int ) instance . value ( m Att Index . get Index ( ) ) ) ) { Instance temp = ( Instance ) instance . copy ( ) ; if ( get Modify Header ( ) ) { temp . set Value ( m Att Index . get Index ( ) , m Nominal Mapping [ ( int ) instance . value ( m Att Index . get Index ( ) ) ] ) ; } push ( temp ) ; return BOOL ; } } return BOOL ; }
@ Override public boolean input ( Instance instance ) { if ( get Input Format ( ) == null ) { throw new Illegal State Exception ( STRING ) ; } if ( m New Batch ) { reset Queue ( ) ; m New Batch = BOOL ; } if ( is First Batch Done ( ) && m dont Filter After First Batch ) { push ( ( Instance ) instance . copy ( ) ) ; return BOOL ; } if ( instance . is Missing ( m Att Index . get Index ( ) ) ) { if ( ! get Match Missing Values ( ) ) { push ( ( Instance ) instance . copy ( ) ) ; return BOOL ; } else { return BOOL ; } } if ( is Numeric ( ) ) { if ( ! m Values . get Invert ( ) ) { if ( instance . value ( m Att Index . get Index ( ) ) < m Value ) { push ( ( Instance ) instance . copy ( ) ) ; return BOOL ; } } else { if ( instance . value ( m Att Index . get Index ( ) ) >= m Value ) { push ( ( Instance ) instance . copy ( ) ) ; return BOOL ; } } } if ( is Nominal ( ) ) { if ( m Values . is In Range ( ( int ) instance . value ( m Att Index . get Index ( ) ) ) ) { Instance temp = ( Instance ) instance . copy ( ) ; if ( get Modify Header ( ) ) { temp . set Value ( m Att Index . get Index ( ) , m Nominal Mapping [ ( int ) instance . value ( m Att Index . get Index ( ) ) ] ) ; } push ( temp ) ; return BOOL ; } } return BOOL ; }
public boolean contains ( lalr item itm ) { return all . contains Key ( itm ) ; }
public boolean contains ( lalr item itm ) { return all . contains Key ( itm ) ; }
public static Index Writer Config new Index Writer Config ( ) { return new Index Writer Config ( new Mock Analyzer ( random ( ) ) ) ; }
protected Sprog Slot find Free ( ) { for ( Sprog Slot s : slots ) { if ( s . is Free ( ) ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + s . get Slot Number ( ) ) ; } return s ; } } return ( null ) ; }
private void write ( final String str ) { try { if ( writer == null ) { writer = new Output Stream Writer ( System . out ) ; } writer . write ( str ) ; } catch ( IO Exception ioe ) { logger . error ( STRING , ioe ) ; System . exit ( NUM ) ; } }
public static void instrument ( Instrumentation inst ) throws Class Not Found Exception , Unmodifiable Class Exception , IO Exception { inst . redefine Classes ( new Class Definition [ ] { get Redefined Class ( Object . class ) } ) ; }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null && m Service != null ) { try { m Context . unbind Service ( m Service Conn ) ; } catch ( Exception e ) { log Error ( e . get Message ( ) ) ; } } } m Disposed = BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null && m Service != null ) { try { m Context . unbind Service ( m Service Conn ) ; } catch ( Exception e ) { log Error ( e . get Message ( ) ) ; } } } m Disposed = BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null && m Service != null ) { try { m Context . unbind Service ( m Service Conn ) ; } catch ( Exception e ) { log Error ( e . get Message ( ) ) ; } } } m Disposed = BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null && m Service != null ) { try { m Context . unbind Service ( m Service Conn ) ; } catch ( Exception e ) { log Error ( e . get Message ( ) ) ; } } } m Disposed = BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
public Float Array resize ( Float Array array , long size ) { if ( array instanceof Big Float Array ) { return resize In Place ( ( Big Float Array ) array , size ) ; } else { Abstract Array arr = ( Abstract Array ) array ; final Float Array new Array = new Float Array ( size , arr . clear On Resize ) ; for ( long i = NUM , end = Math . min ( size , array . size ( ) ) ; i < end ; ++ i ) { new Array . set ( i , array . get ( i ) ) ; } arr . close ( ) ; return new Array ; } }
public static boolean equal Population ( final Population s1 , final Population s2 ) { try { @ Suppress Warnings ( STRING ) Input Stream input Stream 1 = null ; @ Suppress Warnings ( STRING ) Input Stream input Stream 2 = null ; try { input Stream 1 = open Population Input Stream ( s1 ) ; input Stream 2 = open Population Input Stream ( s2 ) ; return IO Utils . is Equal ( input Stream 1 , input Stream 2 ) ; } finally { if ( input Stream 1 != null ) input Stream 1 . close ( ) ; if ( input Stream 2 != null ) input Stream 2 . close ( ) ; } } catch ( IO Exception e ) { throw new Unchecked IO Exception ( e ) ; } }
public static boolean equal Population ( final Population s1 , final Population s2 ) { try { @ Suppress Warnings ( STRING ) Input Stream input Stream 1 = null ; @ Suppress Warnings ( STRING ) Input Stream input Stream 2 = null ; try { input Stream 1 = open Population Input Stream ( s1 ) ; input Stream 2 = open Population Input Stream ( s2 ) ; return IO Utils . is Equal ( input Stream 1 , input Stream 2 ) ; } finally { if ( input Stream 1 != null ) input Stream 1 . close ( ) ; if ( input Stream 2 != null ) input Stream 2 . close ( ) ; } } catch ( IO Exception e ) { throw new Unchecked IO Exception ( e ) ; } }
public static boolean equal Population ( final Population s1 , final Population s2 ) { try { @ Suppress Warnings ( STRING ) Input Stream input Stream 1 = null ; @ Suppress Warnings ( STRING ) Input Stream input Stream 2 = null ; try { input Stream 1 = open Population Input Stream ( s1 ) ; input Stream 2 = open Population Input Stream ( s2 ) ; return IO Utils . is Equal ( input Stream 1 , input Stream 2 ) ; } finally { if ( input Stream 1 != null ) input Stream 1 . close ( ) ; if ( input Stream 2 != null ) input Stream 2 . close ( ) ; } } catch ( IO Exception e ) { throw new Unchecked IO Exception ( e ) ; } }
public static boolean equal Population ( final Population s1 , final Population s2 ) { try { @ Suppress Warnings ( STRING ) Input Stream input Stream 1 = null ; @ Suppress Warnings ( STRING ) Input Stream input Stream 2 = null ; try { input Stream 1 = open Population Input Stream ( s1 ) ; input Stream 2 = open Population Input Stream ( s2 ) ; return IO Utils . is Equal ( input Stream 1 , input Stream 2 ) ; } finally { if ( input Stream 1 != null ) input Stream 1 . close ( ) ; if ( input Stream 2 != null ) input Stream 2 . close ( ) ; } } catch ( IO Exception e ) { throw new Unchecked IO Exception ( e ) ; } }
public static boolean equal Population ( final Population s1 , final Population s2 ) { try { @ Suppress Warnings ( STRING ) Input Stream input Stream 1 = null ; @ Suppress Warnings ( STRING ) Input Stream input Stream 2 = null ; try { input Stream 1 = open Population Input Stream ( s1 ) ; input Stream 2 = open Population Input Stream ( s2 ) ; return IO Utils . is Equal ( input Stream 1 , input Stream 2 ) ; } finally { if ( input Stream 1 != null ) input Stream 1 . close ( ) ; if ( input Stream 2 != null ) input Stream 2 . close ( ) ; } } catch ( IO Exception e ) { throw new Unchecked IO Exception ( e ) ; } }
public static boolean equal Population ( final Population s1 , final Population s2 ) { try { @ Suppress Warnings ( STRING ) Input Stream input Stream 1 = null ; @ Suppress Warnings ( STRING ) Input Stream input Stream 2 = null ; try { input Stream 1 = open Population Input Stream ( s1 ) ; input Stream 2 = open Population Input Stream ( s2 ) ; return IO Utils . is Equal ( input Stream 1 , input Stream 2 ) ; } finally { if ( input Stream 1 != null ) input Stream 1 . close ( ) ; if ( input Stream 2 != null ) input Stream 2 . close ( ) ; } } catch ( IO Exception e ) { throw new Unchecked IO Exception ( e ) ; } }
public static boolean equal Population ( final Population s1 , final Population s2 ) { try { @ Suppress Warnings ( STRING ) Input Stream input Stream 1 = null ; @ Suppress Warnings ( STRING ) Input Stream input Stream 2 = null ; try { input Stream 1 = open Population Input Stream ( s1 ) ; input Stream 2 = open Population Input Stream ( s2 ) ; return IO Utils . is Equal ( input Stream 1 , input Stream 2 ) ; } finally { if ( input Stream 1 != null ) input Stream 1 . close ( ) ; if ( input Stream 2 != null ) input Stream 2 . close ( ) ; } } catch ( IO Exception e ) { throw new Unchecked IO Exception ( e ) ; } }
public static boolean equal Population ( final Population s1 , final Population s2 ) { try { @ Suppress Warnings ( STRING ) Input Stream input Stream 1 = null ; @ Suppress Warnings ( STRING ) Input Stream input Stream 2 = null ; try { input Stream 1 = open Population Input Stream ( s1 ) ; input Stream 2 = open Population Input Stream ( s2 ) ; return IO Utils . is Equal ( input Stream 1 , input Stream 2 ) ; } finally { if ( input Stream 1 != null ) input Stream 1 . close ( ) ; if ( input Stream 2 != null ) input Stream 2 . close ( ) ; } } catch ( IO Exception e ) { throw new Unchecked IO Exception ( e ) ; } }
public static boolean equal Population ( final Population s1 , final Population s2 ) { try { @ Suppress Warnings ( STRING ) Input Stream input Stream 1 = null ; @ Suppress Warnings ( STRING ) Input Stream input Stream 2 = null ; try { input Stream 1 = open Population Input Stream ( s1 ) ; input Stream 2 = open Population Input Stream ( s2 ) ; return IO Utils . is Equal ( input Stream 1 , input Stream 2 ) ; } finally { if ( input Stream 1 != null ) input Stream 1 . close ( ) ; if ( input Stream 2 != null ) input Stream 2 . close ( ) ; } } catch ( IO Exception e ) { throw new Unchecked IO Exception ( e ) ; } }
public String to Encoded String ( ) { String Builder buf = new String Builder ( ) ; buf . append ( get Min Priority ( ) ) ; buf . append ( FIELD DELIMITER ) ; for ( Iterator < String > i = active Bug Category Set . iterator ( ) ; i . has Next ( ) ; ) { buf . append ( i . next ( ) ) ; if ( i . has Next ( ) ) { buf . append ( LISTITEM DELIMITER ) ; } } buf . append ( FIELD DELIMITER ) ; buf . append ( display False Warnings ? STRING : STRING ) ; buf . append ( FIELD DELIMITER ) ; buf . append ( get Min Rank ( ) ) ; return buf . to String ( ) ; }
public String to Encoded String ( ) { String Builder buf = new String Builder ( ) ; buf . append ( get Min Priority ( ) ) ; buf . append ( FIELD DELIMITER ) ; for ( Iterator < String > i = active Bug Category Set . iterator ( ) ; i . has Next ( ) ; ) { buf . append ( i . next ( ) ) ; if ( i . has Next ( ) ) { buf . append ( LISTITEM DELIMITER ) ; } } buf . append ( FIELD DELIMITER ) ; buf . append ( display False Warnings ? STRING : STRING ) ; buf . append ( FIELD DELIMITER ) ; buf . append ( get Min Rank ( ) ) ; return buf . to String ( ) ; }
static private String SHORT Min ( ) { short temp Value = Short . MIN VALUE ; return String . value Of ( temp Value ) ; }
public Selection Builder reset ( ) { m Table = null ; m Selection . set Length ( NUM ) ; m Selection Args . clear ( ) ; return this ; }
private void remove ( final I Progress Operation operation ) { m progress Panel . remove ( operation . get Progress Panel ( ) ) ; if ( m progress Panel . get Component Count ( ) == NUM ) { set Visible ( BOOL ) ; } }
private void remove ( final I Progress Operation operation ) { m progress Panel . remove ( operation . get Progress Panel ( ) ) ; if ( m progress Panel . get Component Count ( ) == NUM ) { set Visible ( BOOL ) ; } }
private long try Inc Reader Overflow ( long s ) { if ( ( s & ABITS ) == RFULL ) { if ( U . compare And Swap Long ( this , STATE , s , s | RBITS ) ) { ++ reader Overflow ; U . put Long Volatile ( this , STATE , s ) ; return s ; } } else if ( ( next Secondary Seed ( ) & OVERFLOW YIELD RATE ) == NUM ) Thread . yield ( ) ; return NUM ; }
private long try Inc Reader Overflow ( long s ) { if ( ( s & ABITS ) == RFULL ) { if ( U . compare And Swap Long ( this , STATE , s , s | RBITS ) ) { ++ reader Overflow ; U . put Long Volatile ( this , STATE , s ) ; return s ; } } else if ( ( next Secondary Seed ( ) & OVERFLOW YIELD RATE ) == NUM ) Thread . yield ( ) ; return NUM ; }
private void init Compute Program ( ) { gl Use Program ( compute Program ) ; Int Buffer work Group Size = Buffer Utils . create Int Buffer ( NUM ) ; gl Get Programiv ( compute Program , GL COMPUTE WORK GROUP SIZE , work Group Size ) ; work Group Size X = work Group Size . get ( NUM ) ; work Group Size Y = work Group Size . get ( NUM ) ; time Uniform = gl Get Uniform Location ( compute Program , STRING ) ; blend Factor Uniform = gl Get Uniform Location ( compute Program , STRING ) ; bounce Count Uniform = gl Get Uniform Location ( compute Program , STRING ) ; Int Buffer params = Buffer Utils . create Int Buffer ( NUM ) ; int loc = gl Get Uniform Location ( compute Program , STRING ) ; gl Get Uniformiv ( compute Program , loc , params ) ; framebuffer Image Binding = params . get ( NUM ) ; loc = gl Get Uniform Location ( compute Program , STRING ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Position Image Binding = params . get ( NUM ) ; loc = gl Get Uniform Location ( compute Program , STRING ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Normal Image Binding = params . get ( NUM ) ; gl Use Program ( NUM ) ; }
public static void write To File ( String file Name , String content ) { String class Method = STRING ; File Writer fout = null ; try { fout = new File Writer ( file Name ) ; fout . write ( content ) ; } catch ( IO Exception e ) { debug . error ( class Method + STRING + file Name ) ; } finally { if ( fout != null ) { try { fout . close ( ) ; } catch ( Exception ex ) { } } } }
public Recognition Request add Custom Operation ( String custom Operation ) { operations . add ( custom Operation ) ; return this ; }
static public String to String ( Array List value ) { String str = STRING ; for ( int i = NUM ; i < value . size ( ) ; i ++ ) { if ( i > NUM ) str += STRING ; str += ( String ) value . get ( i ) ; } return str ; }
static public String to String ( Array List value ) { String str = STRING ; for ( int i = NUM ; i < value . size ( ) ; i ++ ) { if ( i > NUM ) str += STRING ; str += ( String ) value . get ( i ) ; } return str ; }
private Component create Separator ( ) { J Separator sep = new J Separator ( Swing Constants . VERTICAL ) ; sep . set Preferred Size ( new Dimension ( NUM , NUM ) ) ; sep . set Minimum Size ( new Dimension ( NUM , NUM ) ) ; return sep ; }
static double fd ( double x ) { return x * Math . cos ( x ) + NUM * Math . sin ( x ) - NUM ; }
static double fd ( double x ) { return x * Math . cos ( x ) + NUM * Math . sin ( x ) - NUM ; }
public Requestor ( String [ ] groups , int port , boolean delay Flag ) throws IO Exception { super ( STRING ) ; set Daemon ( BOOL ) ; sock = new Multicast Socket ( Constants . get Discovery Port ( ) ) ; sock . set Time To Live ( multicast Request Constraints . get Multicast Time To Live ( Constants . get Ttl ( ) ) ) ; response Port = port ; this . groups = groups == null ? new String [ NUM ] : groups ; this . delay Flag = delay Flag ; }
public static Script create Multi Sig Input Script ( List < Transaction Signature > signatures ) { List < byte [ ] > sigs = new Array List < byte [ ] > ( signatures . size ( ) ) ; for ( Transaction Signature signature : signatures ) sigs . add ( signature . encode To Bitcoin ( ) ) ; return create Multi Sig Input Script Bytes ( sigs ) ; }
public static Script create Multi Sig Input Script ( List < Transaction Signature > signatures ) { List < byte [ ] > sigs = new Array List < byte [ ] > ( signatures . size ( ) ) ; for ( Transaction Signature signature : signatures ) sigs . add ( signature . encode To Bitcoin ( ) ) ; return create Multi Sig Input Script Bytes ( sigs ) ; }
public static Script create Multi Sig Input Script ( List < Transaction Signature > signatures ) { List < byte [ ] > sigs = new Array List < byte [ ] > ( signatures . size ( ) ) ; for ( Transaction Signature signature : signatures ) sigs . add ( signature . encode To Bitcoin ( ) ) ; return create Multi Sig Input Script Bytes ( sigs ) ; }
public static List < M Relation Type > retrieve Types ( final PO po , final int window Id ) { if ( po . get Key Columns ( ) . length != NUM ) { logger . severe ( po + STRING + po . get Key Columns ( ) . length + STRING ) ; PO Relation Exception . throw Wrong Key Column Count ( po ) ; } final String key Column = po . get Key Columns ( ) [ NUM ] ; final int col Id = M Column . get Column ID ( po . get Table Name ( ) , key Column ) ; final Prepared Statement pstmt = DB . prepare Statement ( SQL , po . get Trx Name ( ) ) ; Result Set rs = null ; try { pstmt . set Int ( NUM , po . get Table ID ( ) ) ; pstmt . set Int ( NUM , col Id ) ; rs = pstmt . execute Query ( ) ; final List < M Relation Type > result = eval Result Set ( po , window Id , rs ) ; logger . info ( STRING + result . size ( ) + STRING + po ) ; return result ; } catch ( SQL Exception e ) { logger . severe ( e . get Message ( ) ) ; throw new Adempiere Exception ( e ) ; } finally { DB . close ( rs , pstmt ) ; } }
public static List < M Relation Type > retrieve Types ( final PO po , final int window Id ) { if ( po . get Key Columns ( ) . length != NUM ) { logger . severe ( po + STRING + po . get Key Columns ( ) . length + STRING ) ; PO Relation Exception . throw Wrong Key Column Count ( po ) ; } final String key Column = po . get Key Columns ( ) [ NUM ] ; final int col Id = M Column . get Column ID ( po . get Table Name ( ) , key Column ) ; final Prepared Statement pstmt = DB . prepare Statement ( SQL , po . get Trx Name ( ) ) ; Result Set rs = null ; try { pstmt . set Int ( NUM , po . get Table ID ( ) ) ; pstmt . set Int ( NUM , col Id ) ; rs = pstmt . execute Query ( ) ; final List < M Relation Type > result = eval Result Set ( po , window Id , rs ) ; logger . info ( STRING + result . size ( ) + STRING + po ) ; return result ; } catch ( SQL Exception e ) { logger . severe ( e . get Message ( ) ) ; throw new Adempiere Exception ( e ) ; } finally { DB . close ( rs , pstmt ) ; } }
public static List < M Relation Type > retrieve Types ( final PO po , final int window Id ) { if ( po . get Key Columns ( ) . length != NUM ) { logger . severe ( po + STRING + po . get Key Columns ( ) . length + STRING ) ; PO Relation Exception . throw Wrong Key Column Count ( po ) ; } final String key Column = po . get Key Columns ( ) [ NUM ] ; final int col Id = M Column . get Column ID ( po . get Table Name ( ) , key Column ) ; final Prepared Statement pstmt = DB . prepare Statement ( SQL , po . get Trx Name ( ) ) ; Result Set rs = null ; try { pstmt . set Int ( NUM , po . get Table ID ( ) ) ; pstmt . set Int ( NUM , col Id ) ; rs = pstmt . execute Query ( ) ; final List < M Relation Type > result = eval Result Set ( po , window Id , rs ) ; logger . info ( STRING + result . size ( ) + STRING + po ) ; return result ; } catch ( SQL Exception e ) { logger . severe ( e . get Message ( ) ) ; throw new Adempiere Exception ( e ) ; } finally { DB . close ( rs , pstmt ) ; } }
public static List < M Relation Type > retrieve Types ( final PO po , final int window Id ) { if ( po . get Key Columns ( ) . length != NUM ) { logger . severe ( po + STRING + po . get Key Columns ( ) . length + STRING ) ; PO Relation Exception . throw Wrong Key Column Count ( po ) ; } final String key Column = po . get Key Columns ( ) [ NUM ] ; final int col Id = M Column . get Column ID ( po . get Table Name ( ) , key Column ) ; final Prepared Statement pstmt = DB . prepare Statement ( SQL , po . get Trx Name ( ) ) ; Result Set rs = null ; try { pstmt . set Int ( NUM , po . get Table ID ( ) ) ; pstmt . set Int ( NUM , col Id ) ; rs = pstmt . execute Query ( ) ; final List < M Relation Type > result = eval Result Set ( po , window Id , rs ) ; logger . info ( STRING + result . size ( ) + STRING + po ) ; return result ; } catch ( SQL Exception e ) { logger . severe ( e . get Message ( ) ) ; throw new Adempiere Exception ( e ) ; } finally { DB . close ( rs , pstmt ) ; } }
public boolean can Edit ( Class omgc ) { Iterator iterator ; if ( possible Editable Classes == null ) { Set keys = loaders . key Set ( ) ; possible Editable Classes = new Vector ( keys . size ( ) ) ; iterator = keys . iterator ( ) ; while ( iterator . has Next ( ) ) { String key = ( String ) iterator . next ( ) ; try { possible Editable Classes . add ( Class . for Name ( key ) ) ; } catch ( Class Not Found Exception cnfe ) { } } } iterator = possible Editable Classes . iterator ( ) ; while ( iterator . has Next ( ) ) { Class kc = ( Class ) iterator . next ( ) ; if ( kc == omgc || kc . is Assignable From ( omgc ) ) { return BOOL ; } } return BOOL ; }
public boolean can Edit ( Class omgc ) { Iterator iterator ; if ( possible Editable Classes == null ) { Set keys = loaders . key Set ( ) ; possible Editable Classes = new Vector ( keys . size ( ) ) ; iterator = keys . iterator ( ) ; while ( iterator . has Next ( ) ) { String key = ( String ) iterator . next ( ) ; try { possible Editable Classes . add ( Class . for Name ( key ) ) ; } catch ( Class Not Found Exception cnfe ) { } } } iterator = possible Editable Classes . iterator ( ) ; while ( iterator . has Next ( ) ) { Class kc = ( Class ) iterator . next ( ) ; if ( kc == omgc || kc . is Assignable From ( omgc ) ) { return BOOL ; } } return BOOL ; }
private Binlog Position find Heartbeat ( Maxwell Replicator r ) throws Exception { r . start Replicator ( ) ; for ( Row Map row = r . get Row ( ) ; row != null ; row = r . get Row ( ) ) { if ( Objects . equals ( r . get Last Heartbeat Read ( ) , recovery Info . heartbeat ) ) return row . get Position ( ) ; } return null ; }
private Binlog Position find Heartbeat ( Maxwell Replicator r ) throws Exception { r . start Replicator ( ) ; for ( Row Map row = r . get Row ( ) ; row != null ; row = r . get Row ( ) ) { if ( Objects . equals ( r . get Last Heartbeat Read ( ) , recovery Info . heartbeat ) ) return row . get Position ( ) ; } return null ; }
private void discard ( ) { if ( m Review Id == NUM ) { delete Draft ( ) ; } discard Review ( BOOL ) ; }
Cors Service Builder ( final String ... origins ) { final Set < String > origins Copy = new Linked Hash Set < > ( ) ; for ( String o : origins ) { origins Copy . add ( o . to Lower Case ( Locale . ENGLISH ) ) ; } this . origins = Collections . unmodifiable Set ( origins Copy ) ; any Origin Supported = BOOL ; }
public static int eliminate Zero Mass Points ( int [ ] density Points , double [ ] density Values ) { int positive Mass Count = NUM ; for ( int i = NUM ; i < density Values . length ; i ++ ) { if ( density Values [ i ] > NUM ) { positive Mass Count ++ ; } } if ( positive Mass Count < density Values . length ) { int [ ] new Points = new int [ positive Mass Count ] ; double [ ] new Values = new double [ positive Mass Count ] ; int j = NUM ; for ( int i = NUM ; i < density Values . length ; i ++ ) { if ( density Values [ i ] > NUM ) { new Points [ j ] = density Points [ i ] ; new Values [ j ] = density Values [ i ] ; j ++ ; } } System . arraycopy ( new Points , NUM , density Points , NUM , positive Mass Count ) ; System . arraycopy ( new Values , NUM , density Values , NUM , positive Mass Count ) ; } return positive Mass Count ; }
public static int eliminate Zero Mass Points ( int [ ] density Points , double [ ] density Values ) { int positive Mass Count = NUM ; for ( int i = NUM ; i < density Values . length ; i ++ ) { if ( density Values [ i ] > NUM ) { positive Mass Count ++ ; } } if ( positive Mass Count < density Values . length ) { int [ ] new Points = new int [ positive Mass Count ] ; double [ ] new Values = new double [ positive Mass Count ] ; int j = NUM ; for ( int i = NUM ; i < density Values . length ; i ++ ) { if ( density Values [ i ] > NUM ) { new Points [ j ] = density Points [ i ] ; new Values [ j ] = density Values [ i ] ; j ++ ; } } System . arraycopy ( new Points , NUM , density Points , NUM , positive Mass Count ) ; System . arraycopy ( new Values , NUM , density Values , NUM , positive Mass Count ) ; } return positive Mass Count ; }
public static int eliminate Zero Mass Points ( int [ ] density Points , double [ ] density Values ) { int positive Mass Count = NUM ; for ( int i = NUM ; i < density Values . length ; i ++ ) { if ( density Values [ i ] > NUM ) { positive Mass Count ++ ; } } if ( positive Mass Count < density Values . length ) { int [ ] new Points = new int [ positive Mass Count ] ; double [ ] new Values = new double [ positive Mass Count ] ; int j = NUM ; for ( int i = NUM ; i < density Values . length ; i ++ ) { if ( density Values [ i ] > NUM ) { new Points [ j ] = density Points [ i ] ; new Values [ j ] = density Values [ i ] ; j ++ ; } } System . arraycopy ( new Points , NUM , density Points , NUM , positive Mass Count ) ; System . arraycopy ( new Values , NUM , density Values , NUM , positive Mass Count ) ; } return positive Mass Count ; }
@ Safe Varargs public static < E extends Enum < E > > Enum Set < E > of ( E start , E ... others ) { Enum Set < E > set = of ( start ) ; for ( E e : others ) { set . add ( e ) ; } return set ; }
@ Safe Varargs public static < E extends Enum < E > > Enum Set < E > of ( E start , E ... others ) { Enum Set < E > set = of ( start ) ; for ( E e : others ) { set . add ( e ) ; } return set ; }
@ Safe Varargs public static < E extends Enum < E > > Enum Set < E > of ( E start , E ... others ) { Enum Set < E > set = of ( start ) ; for ( E e : others ) { set . add ( e ) ; } return set ; }
@ Safe Varargs public static < E extends Enum < E > > Enum Set < E > of ( E start , E ... others ) { Enum Set < E > set = of ( start ) ; for ( E e : others ) { set . add ( e ) ; } return set ; }
@ Safe Varargs public static < E extends Enum < E > > Enum Set < E > of ( E start , E ... others ) { Enum Set < E > set = of ( start ) ; for ( E e : others ) { set . add ( e ) ; } return set ; }
@ Safe Varargs public static < E extends Enum < E > > Enum Set < E > of ( E start , E ... others ) { Enum Set < E > set = of ( start ) ; for ( E e : others ) { set . add ( e ) ; } return set ; }
@ Safe Varargs public static < E extends Enum < E > > Enum Set < E > of ( E start , E ... others ) { Enum Set < E > set = of ( start ) ; for ( E e : others ) { set . add ( e ) ; } return set ; }
@ Override public Value concatenate ( Value value ) { if ( ! ( value instanceof Relational Val ) ) { throw new Runtime Exception ( STRING + this + STRING + value ) ; } return new Relational Val ( to String ( ) + value . to String ( ) ) ; }
Class Introspector ( Class Introspector Builder pa , Object shared Lock ) { this ( pa , shared Lock , BOOL , BOOL ) ; }
public Builder histogram Quantiles ( double ... quantiles ) { histogram Percentiles = new Hash Set < > ( ) ; for ( double q : quantiles ) { histogram Percentiles . add ( new Percentile ( q ) ) ; } return this ; }
public Builder histogram Quantiles ( double ... quantiles ) { histogram Percentiles = new Hash Set < > ( ) ; for ( double q : quantiles ) { histogram Percentiles . add ( new Percentile ( q ) ) ; } return this ; }
private List < Item > move Items From Slot To List ( RP Slot slot ) { List < Item > items = new Linked List < Item > ( ) ; for ( RP Object item : slot ) { if ( item instanceof Item ) { items . add ( ( Item ) item ) ; } } slot . clear ( ) ; return items ; }
public static void check Proxy Package Access ( Class < ? > clazz ) { Security Manager s = System . get Security Manager ( ) ; if ( s != null ) { if ( Proxy . is Proxy Class ( clazz ) ) { for ( Class < ? > intf : clazz . get Interfaces ( ) ) { check Package Access ( intf ) ; } } } }
public Object create Soft Weak Ref ( Object o ) { return new Soft Reference ( o ) ; }
public Object create Soft Weak Ref ( Object o ) { return new Soft Reference ( o ) ; }
public Object create Soft Weak Ref ( Object o ) { return new Soft Reference ( o ) ; }
public Object create Soft Weak Ref ( Object o ) { return new Soft Reference ( o ) ; }
public void call ( String name , Json Output . Json Unescaped json ) throws IO Exception { if ( generator . is Excluding Fields Named ( name ) ) { return ; } write Name ( name ) ; verify Value ( ) ; writer . write ( json . to String ( ) ) ; }
public synchronized void remove OF Channel Handler ( OF Channel Handler h ) { connected Channel Handlers . remove ( h ) ; }
public synchronized void remove OF Channel Handler ( OF Channel Handler h ) { connected Channel Handlers . remove ( h ) ; }
private String gaps ( int n ) { String Builder buf = new String Builder ( ) ; for ( ; n > NUM ; n -- ) { buf . append ( STRING ) ; } return buf . to String ( ) ; }
public void delete All ( ) { Integer old Size = Integer . value Of ( hash Table . size ( ) ) ; Enumeration < String > en = hash Table . keys ( ) ; while ( en . has More Elements ( ) ) { Rolling Stock rs = get By Id ( en . next Element ( ) ) ; rs . dispose ( ) ; hash Table . remove ( rs . get Id ( ) ) ; } fire Property Change ( LISTLENGTH CHANGED PROPERTY , old Size , Integer . value Of ( hash Table . size ( ) ) ) ; }
private Node < K , V > put If Absent ( Node < K , V > node ) { Node < K , V > old = data . put If Absent ( node . get Key ( ) , node ) ; if ( old == null ) { length . increment And Get ( ) ; node . append To Tail ( ) ; evict ( ) ; } else { policy . on Access ( this , old ) ; } return old ; }
private Node < K , V > put If Absent ( Node < K , V > node ) { Node < K , V > old = data . put If Absent ( node . get Key ( ) , node ) ; if ( old == null ) { length . increment And Get ( ) ; node . append To Tail ( ) ; evict ( ) ; } else { policy . on Access ( this , old ) ; } return old ; }
public String to String ( ) { String Buffer buf = new String Buffer ( NUM ) ; buf . append ( STRING ) ; Object Identifier oid ; PKCS 9 Attribute value ; boolean first = BOOL ; for ( int i = NUM ; i < PKCS 9 Attribute . PKCS 9 OIDS . length ; i ++ ) { value = get Attribute ( PKCS 9 Attribute . PKCS 9 OIDS [ i ] ) ; if ( value == null ) continue ; if ( first ) first = BOOL ; else buf . append ( STRING ) ; buf . append ( value . to String ( ) ) ; } buf . append ( STRING ) ; return buf . to String ( ) ; }
public synchronized void add New Mention ( int server Id , Conversation conversation , String msg , boolean vibrate , boolean sound , boolean light ) { if ( conversation == null ) { return ; } conversation . add New Mention ( ) ; ++ new Mentions ; String conv Id = get Conversation Id ( server Id , conversation . get Name ( ) ) ; if ( ! mentions . contains Key ( conv Id ) ) { mentions . put ( conv Id , conversation ) ; } if ( new Mentions == NUM ) { update Notification ( msg , msg , vibrate , sound , light ) ; } else { update Notification ( msg , null , vibrate , sound , light ) ; } }
public Encrypted Editor put Boolean ( String key , boolean value ) { put Value ( key , String . value Of ( value ) ) ; return this ; }
@ Override public double java 2 D To Value ( double java 2 D Value , Rectangle 2 D area , Rectangle Edge edge ) { double result = NUM ; if ( this . display Start < this . display End ) { result = super . java 2 D To Value ( java 2 D Value , area , edge ) ; } else { } return result ; }
public static boolean exists ( final String url ) { return X Ad ES 132 . equals ( url ) || X Ad ES 111 . equals ( url ) || X Ad ES 122 . equals ( url ) || X Ad ES . equals ( url ) ; }
public static boolean exists ( final String url ) { return X Ad ES 132 . equals ( url ) || X Ad ES 111 . equals ( url ) || X Ad ES 122 . equals ( url ) || X Ad ES . equals ( url ) ; }
public static void close Input Stream ( Input Stream stream , String tag ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( IO Exception e ) { Log . e ( tag , STRING , e ) ; } } }
public int last Index Of ( String sub String , int start ) { int count = length ( ) ; int sub Count = sub String . length ( ) ; if ( sub Count <= count && start >= NUM ) { if ( sub Count > NUM ) { if ( start > count - sub Count ) { start = count - sub Count ; } char [ ] target = sub String . to Char Array ( ) ; int sub Offset = NUM ; char first Char = target [ sub Offset ] ; int end = sub Offset + sub Count ; while ( BOOL ) { int i = last Index Of ( first Char , start ) ; if ( i == - NUM ) { return - NUM ; } int o1 = i , o2 = sub Offset ; while ( ++ o2 < end && char At ( ++ o1 ) == target [ o2 ] ) { } if ( o2 == end ) { return i ; } start = i - NUM ; } } return start < count ? start : count ; } return - NUM ; }
public int last Index Of ( String sub String , int start ) { int count = length ( ) ; int sub Count = sub String . length ( ) ; if ( sub Count <= count && start >= NUM ) { if ( sub Count > NUM ) { if ( start > count - sub Count ) { start = count - sub Count ; } char [ ] target = sub String . to Char Array ( ) ; int sub Offset = NUM ; char first Char = target [ sub Offset ] ; int end = sub Offset + sub Count ; while ( BOOL ) { int i = last Index Of ( first Char , start ) ; if ( i == - NUM ) { return - NUM ; } int o1 = i , o2 = sub Offset ; while ( ++ o2 < end && char At ( ++ o1 ) == target [ o2 ] ) { } if ( o2 == end ) { return i ; } start = i - NUM ; } } return start < count ? start : count ; } return - NUM ; }
protected void remove Cycles ( ) { int visited [ ] = new int [ m nodes . size ( ) ] ; for ( int i = NUM ; i < graph Matrix . length ; i ++ ) { if ( visited [ i ] == NUM ) { remove Cycles 2 ( i , visited ) ; visited [ i ] = NUM ; } } }
protected void remove Cycles ( ) { int visited [ ] = new int [ m nodes . size ( ) ] ; for ( int i = NUM ; i < graph Matrix . length ; i ++ ) { if ( visited [ i ] == NUM ) { remove Cycles 2 ( i , visited ) ; visited [ i ] = NUM ; } } }
public String create Query String ( Projection p ) { if ( query Header == null ) { return null ; } String Buffer buf = new String Buffer ( query Header ) ; buf . append ( REQUEST + STRING + MAP + STRING ) ; if ( p != null ) { Point 2 D center = p . get Center ( ) ; buf . append ( PROJTYPE + STRING + p . get Name ( ) + STRING + SCALE + STRING + p . get Scale ( ) + STRING + LAT + STRING + center . get Y ( ) + STRING + LON + STRING + center . get X ( ) + STRING + HEIGHT + STRING + p . get Height ( ) + STRING + WIDTH + STRING + p . get Width ( ) ) ; } else { buf . append ( PROJTYPE + STRING + SCALE + STRING + LAT + STRING + LON + STRING + HEIGHT + STRING + WIDTH + STRING ) ; } if ( image Format != null ) { buf . append ( STRING + FORMAT + STRING + image Format ) ; } if ( transparent ) { buf . append ( STRING + TRANSPARENT + STRING ) ; } if ( background Color != null ) { buf . append ( STRING + BGCOLOR + STRING + background Color ) ; } String layers = get Layer Markers ( ) ; if ( layers != null ) { buf . append ( STRING + layers ) ; } return buf . to String ( ) ; }
public String create Query String ( Projection p ) { if ( query Header == null ) { return null ; } String Buffer buf = new String Buffer ( query Header ) ; buf . append ( REQUEST + STRING + MAP + STRING ) ; if ( p != null ) { Point 2 D center = p . get Center ( ) ; buf . append ( PROJTYPE + STRING + p . get Name ( ) + STRING + SCALE + STRING + p . get Scale ( ) + STRING + LAT + STRING + center . get Y ( ) + STRING + LON + STRING + center . get X ( ) + STRING + HEIGHT + STRING + p . get Height ( ) + STRING + WIDTH + STRING + p . get Width ( ) ) ; } else { buf . append ( PROJTYPE + STRING + SCALE + STRING + LAT + STRING + LON + STRING + HEIGHT + STRING + WIDTH + STRING ) ; } if ( image Format != null ) { buf . append ( STRING + FORMAT + STRING + image Format ) ; } if ( transparent ) { buf . append ( STRING + TRANSPARENT + STRING ) ; } if ( background Color != null ) { buf . append ( STRING + BGCOLOR + STRING + background Color ) ; } String layers = get Layer Markers ( ) ; if ( layers != null ) { buf . append ( STRING + layers ) ; } return buf . to String ( ) ; }
public String read Line ( String fmt , Object ... args ) { String line = null ; synchronized ( write Lock ) { synchronized ( read Lock ) { if ( fmt . length ( ) != NUM ) pw . format ( fmt , args ) ; try { char [ ] ca = readline ( BOOL ) ; if ( ca != null ) line = new String ( ca ) ; } catch ( IO Exception x ) { throw new IO Error ( x ) ; } } } return line ; }
private static String [ ] match ( String value ) { if ( value == null ) { return null ; } Matcher matcher = IPV 4 PATTERN . matcher ( value ) ; if ( matcher . matches ( ) ) { int count = matcher . group Count ( ) ; String [ ] groups = new String [ count ] ; for ( int j = NUM ; j < count ; j ++ ) { groups [ j ] = matcher . group ( j + NUM ) ; } return groups ; } return null ; }
private static String [ ] match ( String value ) { if ( value == null ) { return null ; } Matcher matcher = IPV 4 PATTERN . matcher ( value ) ; if ( matcher . matches ( ) ) { int count = matcher . group Count ( ) ; String [ ] groups = new String [ count ] ; for ( int j = NUM ; j < count ; j ++ ) { groups [ j ] = matcher . group ( j + NUM ) ; } return groups ; } return null ; }
public void write Int ( int v ) throws IO Exception { data Output . write Int ( v ) ; offset += NUM ; }
void append Where ( Char Sequence in Where ) { }
private static void delete Stack Trace ( Weak Reference < Context > weak Context , String filename ) { Context context = null ; Artisan Log Util . debug Log ( STRING + filename ) ; if ( weak Context != null ) { context = weak Context . get ( ) ; if ( context != null ) { File file = new File ( filename ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } }
@ Override public void action Performed ( Action Event event ) { String command = event . get Action Command ( ) ; if ( command . equals ( STRING ) ) { attempt Font Selection ( ) ; } else if ( command . equals ( STRING ) ) { attempt Paint Selection ( ) ; } else if ( command . equals ( STRING ) ) { attempt Modify Show Title ( ) ; } }
public void ignore Att Keys ( String [ ] att Keys , boolean ignore Path Keys ) { ignored Att Keys . clear ( ) ; for ( String key : att Keys ) ignored Att Keys . add ( key ) ; this . ignore Path Keys = ignore Path Keys ; }
public void ignore Att Keys ( String [ ] att Keys , boolean ignore Path Keys ) { ignored Att Keys . clear ( ) ; for ( String key : att Keys ) ignored Att Keys . add ( key ) ; this . ignore Path Keys = ignore Path Keys ; }
public void ignore Att Keys ( String [ ] att Keys , boolean ignore Path Keys ) { ignored Att Keys . clear ( ) ; for ( String key : att Keys ) ignored Att Keys . add ( key ) ; this . ignore Path Keys = ignore Path Keys ; }
public static final boolean validate Group Name ( String s Group Name ) { if ( s Group Name . length ( ) == NUM ) { return BOOL ; } return s Group Name . matches ( STRING ) ; }
@ Suppress Warnings ( STRING ) public List < String > remove Initiator Details ( URI initiator Id ) { List < String > result = Lists . new Array List ( ) ; Initiator initiator = db Client . query Object ( Initiator . class , initiator Id ) ; if ( initiator != null ) { result . add ( Compute System Dialog Properties . get Message ( STRING , initiator . get Initiator Port ( ) ) ) ; List < Export Group > export Groups = Compute System Controller Impl . get Export Groups ( db Client , initiator . get Id ( ) , Lists . new Array List ( initiator ) ) ; for ( Export Group export : export Groups ) { List < URI > updated Initiators = String Set Util . string Set To Uri List ( export . get Initiators ( ) ) ; if ( updated Initiators . remove ( initiator Id ) ) { List < Block Object Details > volume Details = get Block Object Details ( initiator . get Host ( ) , export . get Volumes ( ) ) ; result . add All ( get Volume Initiator Details ( volume Details , BOOL ) ) ; } } } return result ; }
public DSS Document generate X Ad ES Content Timestamp As DSS Document ( final DSS Document to Sign Document , final X Ad ES Signature Parameters external Parameters , final Timestamp Type timestamp Type ) { final Timestamp Token timestamp Token = generate X Ad ES Content Timestamp As Timestamp Token ( to Sign Document , external Parameters , timestamp Type ) ; return new In Memory Document ( timestamp Token . get Encoded ( ) ) ; }
public DSS Document generate X Ad ES Content Timestamp As DSS Document ( final DSS Document to Sign Document , final X Ad ES Signature Parameters external Parameters , final Timestamp Type timestamp Type ) { final Timestamp Token timestamp Token = generate X Ad ES Content Timestamp As Timestamp Token ( to Sign Document , external Parameters , timestamp Type ) ; return new In Memory Document ( timestamp Token . get Encoded ( ) ) ; }
public Date Time to Date Time ( double days ) { long utc = Math . round ( days * DAY MILLIS ) ; utc -= CF UNIX OFFSET ; utc -= get Local Time Zone Offset ( utc ) ; return new Date Time Impl ( utc , BOOL ) ; }
private void add To Queue ( Serial Message serial Message ) { if ( serial Message == null ) { return ; } if ( ! msg Queue . contains ( serial Message ) && msg Queue . remaining Capacity ( ) > NUM ) { msg Queue . add ( serial Message ) ; } send Message ( ) ; }
public void store Last PVP Action Time ( ) { put ( STRING , System . current Time Millis ( ) ) ; }
public static boolean is Anonymous ( String class Name ) { int i = class Name . last Index Of ( STRING ) ; if ( i >= NUM && ++ i < class Name . length ( ) ) { while ( i < class Name . length ( ) ) { if ( ! Character . is Digit ( class Name . char At ( i ) ) ) { return BOOL ; } i ++ ; } return BOOL ; } return BOOL ; }
public static boolean is Anonymous ( String class Name ) { int i = class Name . last Index Of ( STRING ) ; if ( i >= NUM && ++ i < class Name . length ( ) ) { while ( i < class Name . length ( ) ) { if ( ! Character . is Digit ( class Name . char At ( i ) ) ) { return BOOL ; } i ++ ; } return BOOL ; } return BOOL ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return ERROR CODE ; case NUM : return MESSAGE ; default : return null ; } }
protected void run Full Import ( String data Config , Map < String , String > extra Params ) throws Exception { Hash Map < String , String > params = new Hash Map < > ( ) ; params . put ( STRING , STRING ) ; params . put ( STRING , STRING ) ; params . put ( STRING , data Config ) ; params . put ( STRING , STRING ) ; params . put ( STRING , STRING ) ; params . put All ( extra Params ) ; Named List l = new Named List ( ) ; for ( Map . Entry < String , String > e : params . entry Set ( ) ) { l . add ( e . get Key ( ) , e . get Value ( ) ) ; } Local Solr Query Request request = new Local Solr Query Request ( h . get Core ( ) , l ) ; h . query ( STRING , request ) ; }
protected void run Full Import ( String data Config , Map < String , String > extra Params ) throws Exception { Hash Map < String , String > params = new Hash Map < > ( ) ; params . put ( STRING , STRING ) ; params . put ( STRING , STRING ) ; params . put ( STRING , data Config ) ; params . put ( STRING , STRING ) ; params . put ( STRING , STRING ) ; params . put All ( extra Params ) ; Named List l = new Named List ( ) ; for ( Map . Entry < String , String > e : params . entry Set ( ) ) { l . add ( e . get Key ( ) , e . get Value ( ) ) ; } Local Solr Query Request request = new Local Solr Query Request ( h . get Core ( ) , l ) ; h . query ( STRING , request ) ; }
protected void help Set Default Value Edit Text ( String default Text ) { m Edit Text For List . set Text ( default Text ) ; m Edit Text For List . set Selection ( default Text . length ( ) ) ; }
protected void help Set Default Value Edit Text ( String default Text ) { m Edit Text For List . set Text ( default Text ) ; m Edit Text For List . set Selection ( default Text . length ( ) ) ; }
protected void help Set Default Value Edit Text ( String default Text ) { m Edit Text For List . set Text ( default Text ) ; m Edit Text For List . set Selection ( default Text . length ( ) ) ; }
private void filter By Context Tenant ( List < Virtual Array Rest Rep > input Arrays , List < Virtual Array Rest Rep > virtual Arrays By Tenant ) { Iterator < Virtual Array Rest Rep > iterator = input Arrays . iterator ( ) ; while ( iterator . has Next ( ) ) { Virtual Array Rest Rep rep = iterator . next ( ) ; if ( ! contains ( rep . get Id ( ) , virtual Arrays By Tenant ) ) { iterator . remove ( ) ; } } }
private void filter By Context Tenant ( List < Virtual Array Rest Rep > input Arrays , List < Virtual Array Rest Rep > virtual Arrays By Tenant ) { Iterator < Virtual Array Rest Rep > iterator = input Arrays . iterator ( ) ; while ( iterator . has Next ( ) ) { Virtual Array Rest Rep rep = iterator . next ( ) ; if ( ! contains ( rep . get Id ( ) , virtual Arrays By Tenant ) ) { iterator . remove ( ) ; } } }
private void hamming ( int size ) { int start = ( window Function . length - size ) / NUM ; int stop = ( window Function . length + size ) / NUM ; double scale = NUM / ( double ) size / NUM ; double factor = two PI / ( double ) size ; for ( int i = NUM ; start < stop ; start ++ , i ++ ) window Function [ i ] = scale * ( NUM / NUM - NUM / NUM * Math . cos ( factor * i ) ) ; }
@ Override public boolean add Edge ( Number edge , Pair < ? extends Integer > endpoints , Edge Type edge Type ) { if ( endpoints == null ) throw new Illegal Argument Exception ( STRING ) ; Integer v1 = endpoints . get First ( ) ; Integer v2 = endpoints . get Second ( ) ; if ( v1 . equals ( v2 ) ) throw new Illegal Argument Exception ( STRING ) ; else return super . add Edge ( edge , endpoints , edge Type ) ; }
@ Override public boolean add Edge ( Number edge , Pair < ? extends Integer > endpoints , Edge Type edge Type ) { if ( endpoints == null ) throw new Illegal Argument Exception ( STRING ) ; Integer v1 = endpoints . get First ( ) ; Integer v2 = endpoints . get Second ( ) ; if ( v1 . equals ( v2 ) ) throw new Illegal Argument Exception ( STRING ) ; else return super . add Edge ( edge , endpoints , edge Type ) ; }
private void process Volume Sample List ( List < Sample > sample List , Map < String , Object > key Map , Map < String , String > vol File Map , List < Stat > stats List ) { Iterator < Sample > item Itr = sample List . iterator ( ) ; while ( item Itr . has Next ( ) ) { Sample vol Sample = item Itr . next ( ) ; List < Item > vol Items = vol Sample . get Item ( ) ; Iterator < Item > vol Items Itr = vol Items . iterator ( ) ; while ( vol Items Itr . has Next ( ) ) { Item vol Item = vol Items Itr . next ( ) ; if ( vol File Map . contains Key ( vol Item . get Volume ( ) ) ) { String file System = vol File Map . get ( vol Item . get Volume ( ) ) ; if ( null != file System ) { inject BW In Out ( file System , key Map , vol Item , stats List ) ; } } } } }
static long make Id ( Snmp Oid oid ) { long id = NUM ; long [ ] arcs = oid . long Value ( BOOL ) ; id |= arcs [ NUM ] << NUM ; id |= arcs [ NUM ] << NUM ; id |= arcs [ NUM ] << NUM ; id |= arcs [ NUM ] << NUM ; id |= arcs [ NUM ] << NUM ; id |= arcs [ NUM ] << NUM ; id |= arcs [ NUM ] << NUM ; id |= arcs [ NUM ] ; return id ; }
public static void rotate M ( float [ ] m , int m Offset , float a , float x , float y , float z ) { synchronized ( TEMP MATRIX ARRAY ) { set Rotate M ( TEMP MATRIX ARRAY , NUM , a , x , y , z ) ; multiply MM ( TEMP MATRIX ARRAY , NUM , m , m Offset , TEMP MATRIX ARRAY , NUM ) ; System . arraycopy ( TEMP MATRIX ARRAY , NUM , m , m Offset , NUM ) ; } }
public static void rotate M ( float [ ] m , int m Offset , float a , float x , float y , float z ) { synchronized ( TEMP MATRIX ARRAY ) { set Rotate M ( TEMP MATRIX ARRAY , NUM , a , x , y , z ) ; multiply MM ( TEMP MATRIX ARRAY , NUM , m , m Offset , TEMP MATRIX ARRAY , NUM ) ; System . arraycopy ( TEMP MATRIX ARRAY , NUM , m , m Offset , NUM ) ; } }
public static void rotate M ( float [ ] m , int m Offset , float a , float x , float y , float z ) { synchronized ( TEMP MATRIX ARRAY ) { set Rotate M ( TEMP MATRIX ARRAY , NUM , a , x , y , z ) ; multiply MM ( TEMP MATRIX ARRAY , NUM , m , m Offset , TEMP MATRIX ARRAY , NUM ) ; System . arraycopy ( TEMP MATRIX ARRAY , NUM , m , m Offset , NUM ) ; } }
public void put All ( Map < ? extends K , ? extends V > m ) { for ( Map . Entry < ? extends K , ? extends V > e : m . entry Set ( ) ) put ( e . get Key ( ) , e . get Value ( ) ) ; }
public void put All ( Map < ? extends K , ? extends V > m ) { for ( Map . Entry < ? extends K , ? extends V > e : m . entry Set ( ) ) put ( e . get Key ( ) , e . get Value ( ) ) ; }
private void send Broadcast Download Finished ( Download File Operation download , Remote Operation Result download Result , String unlinked From Remote Path ) { Intent end = new Intent ( get Download Finish Message ( ) ) ; end . put Extra ( EXTRA DOWNLOAD RESULT , download Result . is Success ( ) ) ; end . put Extra ( ACCOUNT NAME , download . get Account ( ) . name ) ; end . put Extra ( EXTRA REMOTE PATH , download . get Remote Path ( ) ) ; end . put Extra ( EXTRA FILE PATH , download . get Save Path ( ) ) ; if ( unlinked From Remote Path != null ) { end . put Extra ( EXTRA LINKED TO PATH , unlinked From Remote Path ) ; } send Sticky Broadcast ( end ) ; }
private void send Broadcast Download Finished ( Download File Operation download , Remote Operation Result download Result , String unlinked From Remote Path ) { Intent end = new Intent ( get Download Finish Message ( ) ) ; end . put Extra ( EXTRA DOWNLOAD RESULT , download Result . is Success ( ) ) ; end . put Extra ( ACCOUNT NAME , download . get Account ( ) . name ) ; end . put Extra ( EXTRA REMOTE PATH , download . get Remote Path ( ) ) ; end . put Extra ( EXTRA FILE PATH , download . get Save Path ( ) ) ; if ( unlinked From Remote Path != null ) { end . put Extra ( EXTRA LINKED TO PATH , unlinked From Remote Path ) ; } send Sticky Broadcast ( end ) ; }
private void send Broadcast Download Finished ( Download File Operation download , Remote Operation Result download Result , String unlinked From Remote Path ) { Intent end = new Intent ( get Download Finish Message ( ) ) ; end . put Extra ( EXTRA DOWNLOAD RESULT , download Result . is Success ( ) ) ; end . put Extra ( ACCOUNT NAME , download . get Account ( ) . name ) ; end . put Extra ( EXTRA REMOTE PATH , download . get Remote Path ( ) ) ; end . put Extra ( EXTRA FILE PATH , download . get Save Path ( ) ) ; if ( unlinked From Remote Path != null ) { end . put Extra ( EXTRA LINKED TO PATH , unlinked From Remote Path ) ; } send Sticky Broadcast ( end ) ; }
private void send Broadcast Download Finished ( Download File Operation download , Remote Operation Result download Result , String unlinked From Remote Path ) { Intent end = new Intent ( get Download Finish Message ( ) ) ; end . put Extra ( EXTRA DOWNLOAD RESULT , download Result . is Success ( ) ) ; end . put Extra ( ACCOUNT NAME , download . get Account ( ) . name ) ; end . put Extra ( EXTRA REMOTE PATH , download . get Remote Path ( ) ) ; end . put Extra ( EXTRA FILE PATH , download . get Save Path ( ) ) ; if ( unlinked From Remote Path != null ) { end . put Extra ( EXTRA LINKED TO PATH , unlinked From Remote Path ) ; } send Sticky Broadcast ( end ) ; }
public Point 2 D inverse Transform ( Point 2 D view Point ) { Point 2 D view Center = get View Center ( ) ; double view Radius = get View Radius ( ) ; double ratio = get Ratio ( ) ; double dx = view Point . get X ( ) - view Center . get X ( ) ; double dy = view Point . get Y ( ) - view Center . get Y ( ) ; dx *= ratio ; Point 2 D point From Center = new Point 2 D . Double ( dx , dy ) ; Polar Point polar = Polar Point . cartesian To Polar ( point From Center ) ; double radius = polar . get Radius ( ) ; if ( radius > view Radius ) return delegate . inverse Transform ( view Point ) ; double mag = magnification ; radius /= mag ; polar . set Radius ( radius ) ; Point 2 D projected Point = Polar Point . polar To Cartesian ( polar ) ; projected Point . set Location ( projected Point . get X ( ) / ratio , projected Point . get Y ( ) ) ; Point 2 D translated Back = new Point 2 D . Double ( projected Point . get X ( ) + view Center . get X ( ) , projected Point . get Y ( ) + view Center . get Y ( ) ) ; return delegate . inverse Transform ( translated Back ) ; }
public Bit Array resize ( long size ) { bytes . resize ( Math . max ( size / NUM + NUM , NUM ) ) ; this . size = size ; return this ; }
public static File to File ( File parent , String path ) { return new File ( parent , path . replace ( FILE ANTI SEPERATOR , FILE SEPERATOR ) ) ; }
public static int parse Int ( java . lang . String s ) throws java . lang . Number Format Exception { return parse Int ( s , NUM ) ; }
long cleanup ( long now ) { int in Use Connection Count = NUM ; int idle Connection Count = NUM ; Real Connection longest Idle Connection = null ; long longest Idle Duration Ns = Long . MIN VALUE ; synchronized ( this ) { for ( Iterator < Real Connection > i = connections . iterator ( ) ; i . has Next ( ) ; ) { Real Connection connection = i . next ( ) ; if ( prune And Get Allocation Count ( connection , now ) > NUM ) { in Use Connection Count ++ ; continue ; } idle Connection Count ++ ; long idle Duration Ns = now - connection . idle At Nanos ; if ( idle Duration Ns > longest Idle Duration Ns ) { longest Idle Duration Ns = idle Duration Ns ; longest Idle Connection = connection ; } } if ( longest Idle Duration Ns >= this . keep Alive Duration Ns || idle Connection Count > this . max Idle Connections ) { connections . remove ( longest Idle Connection ) ; } else if ( idle Connection Count > NUM ) { return keep Alive Duration Ns - longest Idle Duration Ns ; } else if ( in Use Connection Count > NUM ) { return keep Alive Duration Ns ; } else { cleanup Running = BOOL ; return - NUM ; } } close Quietly ( longest Idle Connection . socket ( ) ) ; return NUM ; }
long cleanup ( long now ) { int in Use Connection Count = NUM ; int idle Connection Count = NUM ; Real Connection longest Idle Connection = null ; long longest Idle Duration Ns = Long . MIN VALUE ; synchronized ( this ) { for ( Iterator < Real Connection > i = connections . iterator ( ) ; i . has Next ( ) ; ) { Real Connection connection = i . next ( ) ; if ( prune And Get Allocation Count ( connection , now ) > NUM ) { in Use Connection Count ++ ; continue ; } idle Connection Count ++ ; long idle Duration Ns = now - connection . idle At Nanos ; if ( idle Duration Ns > longest Idle Duration Ns ) { longest Idle Duration Ns = idle Duration Ns ; longest Idle Connection = connection ; } } if ( longest Idle Duration Ns >= this . keep Alive Duration Ns || idle Connection Count > this . max Idle Connections ) { connections . remove ( longest Idle Connection ) ; } else if ( idle Connection Count > NUM ) { return keep Alive Duration Ns - longest Idle Duration Ns ; } else if ( in Use Connection Count > NUM ) { return keep Alive Duration Ns ; } else { cleanup Running = BOOL ; return - NUM ; } } close Quietly ( longest Idle Connection . socket ( ) ) ; return NUM ; }
private Region find Region ( int size , Packing packing ) { validate ( ! VALIDATING || Integer . bit Count ( size ) == NUM ) ; Node < Region > current Node = get Root ( ) ; Region current Region = current Node . get Payload ( ) ; if ( current Region == null || ( current Region . available ( ) & size ) == NUM ) { return null ; } else { while ( BOOL ) { Node < Region > prefered = packing . prefered ( current Node ) ; Region prefered Region = prefered . get Payload ( ) ; if ( prefered Region != null && ( prefered Region . available ( ) & size ) != NUM ) { current Node = prefered ; current Region = prefered Region ; } else if ( ( current Region . available Here ( ) & size ) != NUM ) { return packing . slice ( current Region , size ) ; } else { Node < Region > fallback = packing . fallback ( current Node ) ; Region fallback Region = fallback . get Payload ( ) ; if ( fallback Region != null && ( fallback Region . available ( ) & size ) != NUM ) { current Node = fallback ; current Region = fallback Region ; } else { throw new Assertion Error ( ) ; } } } } }
public static Type Instance Dialog instantiate Create Type Instance Dialog ( final J Frame owner , final Type Manager type Manager , final Section section , final Long offset ) { return new Type Instance Dialog ( owner , STRING , new Type List Model ( type Manager . get Types ( ) , new Type List Model . Prototypes Filter ( ) ) , null , section , offset ) ; }
public static Type Instance Dialog instantiate Create Type Instance Dialog ( final J Frame owner , final Type Manager type Manager , final Section section , final Long offset ) { return new Type Instance Dialog ( owner , STRING , new Type List Model ( type Manager . get Types ( ) , new Type List Model . Prototypes Filter ( ) ) , null , section , offset ) ; }
public static Type Instance Dialog instantiate Create Type Instance Dialog ( final J Frame owner , final Type Manager type Manager , final Section section , final Long offset ) { return new Type Instance Dialog ( owner , STRING , new Type List Model ( type Manager . get Types ( ) , new Type List Model . Prototypes Filter ( ) ) , null , section , offset ) ; }
public static Type Instance Dialog instantiate Create Type Instance Dialog ( final J Frame owner , final Type Manager type Manager , final Section section , final Long offset ) { return new Type Instance Dialog ( owner , STRING , new Type List Model ( type Manager . get Types ( ) , new Type List Model . Prototypes Filter ( ) ) , null , section , offset ) ; }
public static Type Instance Dialog instantiate Create Type Instance Dialog ( final J Frame owner , final Type Manager type Manager , final Section section , final Long offset ) { return new Type Instance Dialog ( owner , STRING , new Type List Model ( type Manager . get Types ( ) , new Type List Model . Prototypes Filter ( ) ) , null , section , offset ) ; }
public void add Compare Col ( int sort Col , Comparator comparator ) { sort Cols . add ( new Array Element Comparator ( sort Col , comparator ) ) ; }
@ Request Mapping ( value = STRING , method = Request Method . POST , produces = Media Type . APPLICATION JSON VALUE ) @ Timed public Response Entity < ? > change Password ( @ Request Body Password Change DTO password Change ) { if ( String Utils . is Empty ( password Change . get New Password ( ) ) || String Utils . is Empty ( password Change . get Old Password ( ) ) ) { return new Response Entity < > ( Http Status . FORBIDDEN ) ; } if ( user Service . check Password ( password Change . get Old Password ( ) ) ) { user Service . change Password ( password Change . get New Password ( ) ) ; return new Response Entity < > ( Http Status . OK ) ; } else { return new Response Entity < > ( Http Status . FORBIDDEN ) ; } }
public static void close Global ( ) { Array List < Env Loader Listener > listeners ; listeners = new Array List < > ( ) ; listeners . add All ( global Loader Listeners ) ; global Loader Listeners . clear ( ) ; for ( int i = NUM ; i < listeners . size ( ) ; i ++ ) { Env Loader Listener listener = listeners . get ( i ) ; listener . class Loader Destroy ( null ) ; } }
@ Override protected void tear Down ( ) { m Classifier = null ; m Option Tester = null ; File file = new File ( MODEL FILENAME ) ; if ( file . exists ( ) ) { file . delete ( ) ; } }
private String generate Port Name ( ) { String Buffer port Name = new String Buffer ( STRING ) ; int port Count = all Storage Ports List . size ( ) ; port Name = port Name . append ( String . value Of ( port Count - NUM ) ) ; return port Name . to String ( ) ; }
private String generate Port Name ( ) { String Buffer port Name = new String Buffer ( STRING ) ; int port Count = all Storage Ports List . size ( ) ; port Name = port Name . append ( String . value Of ( port Count - NUM ) ) ; return port Name . to String ( ) ; }
public String ( byte [ ] bytes , int off , int len ) { this ( bytes To Chars ( bytes , off , len , STRING ) ) ; }
public String ( byte [ ] bytes , int off , int len ) { this ( bytes To Chars ( bytes , off , len , STRING ) ) ; }
public String ( byte [ ] bytes , int off , int len ) { this ( bytes To Chars ( bytes , off , len , STRING ) ) ; }
public abstract Servlet Request do Before ( final Servlet Request servlet Request , final Servlet Response servlet Response ) throws IO Exception , Servlet Exception ;
public abstract Servlet Request do Before ( final Servlet Request servlet Request , final Servlet Response servlet Response ) throws IO Exception , Servlet Exception ;
@ Override public void flush ( ) throws IO Exception { flush Bytes ( BOOL ) ; }
@ Override public void flush ( ) throws IO Exception { flush Bytes ( BOOL ) ; }
@ Override public void flush ( ) throws IO Exception { flush Bytes ( BOOL ) ; }
public static void add Recent File ( File file ) { add Recent File ( file . get Path ( ) ) ; }
public static int generar Marcas ( int [ ] bits Activos ) { int result = NUM ; for ( int i = NUM ; i < bits Activos . length ; i ++ ) { result += ( int ) Math . pow ( NUM , bits Activos [ i ] ) ; } return result ; }
private static State next ( final Input Stream stream , final State state , final Byte Array Output Stream line ) throws IO Exception { final int next = stream . read ( ) ; if ( next == - NUM ) { throw new IO Exception ( STRING ) ; } final State result ; switch ( state ) { case NORMAL : result = next Normal ( state , line , next ) ; break ; case R : if ( next == STRING ) { result = State . END ; } else { throw new IO Exception ( String . format ( STRING , STRING , STRING ) ) ; } break ; case QUOTED STRING : result = next Quoted ( stream , state , line , next ) ; break ; default : throw new Illegal State Exception ( STRING ) ; } return result ; }
public boolean write ( byte [ ] audio Data ) { return write ( audio Data , NUM , audio Data . length ) ; }
public static Stored Cell Probs Obs serializable Instance ( ) { return new Stored Cell Probs Obs ( new Array List < Node > ( ) ) ; }
public static Stored Cell Probs Obs serializable Instance ( ) { return new Stored Cell Probs Obs ( new Array List < Node > ( ) ) ; }
@ Override public boolean has More Elements ( ) { return ( ( instruction Operands . has More Elements ( ) ) || ( ( heap Operands != null ) && ( cur Heap Operand < heap Operands . length ) ) || ( ( implicit Defs != null ) && ( implicit Defs . has More Elements ( ) ) ) ) ; }
public long round Trip Time ( ) throws Interrupted Exception { latch . await ( ) ; return received - sent ; }
public long round Trip Time ( ) throws Interrupted Exception { latch . await ( ) ; return received - sent ; }
public void state Changed ( Change Event e ) { if ( e == null ) { return ; } if ( my Bar != null ) { Object new Model Value = my Bar . get Value ( ) ; fire Property Change ( ACCESSIBLE VALUE PROPERTY , old Model Value , new Model Value ) ; old Model Value = new Model Value ; } }
public void state Changed ( Change Event e ) { if ( e == null ) { return ; } if ( my Bar != null ) { Object new Model Value = my Bar . get Value ( ) ; fire Property Change ( ACCESSIBLE VALUE PROPERTY , old Model Value , new Model Value ) ; old Model Value = new Model Value ; } }
public void state Changed ( Change Event e ) { if ( e == null ) { return ; } if ( my Bar != null ) { Object new Model Value = my Bar . get Value ( ) ; fire Property Change ( ACCESSIBLE VALUE PROPERTY , old Model Value , new Model Value ) ; old Model Value = new Model Value ; } }
@ Override public List < Proxy > select ( URI uri ) { Array List < Proxy > proxies = new Array List < Proxy > ( ) ; proxies . add ( Proxy . NO PROXY ) ; return proxies ; }
private void clear Answer ( Question Widget qw ) { if ( qw . get Answer ( ) != null ) { qw . clear Answer ( ) ; } }
private void clear Answer ( Question Widget qw ) { if ( qw . get Answer ( ) != null ) { qw . clear Answer ( ) ; } }
public static byte [ ] pack Header ( byte cmd , long pkg len , byte errno ) throws Unsupported Encoding Exception { byte [ ] header ; byte [ ] hex len ; header = new byte [ FDFS PROTO PKG LEN SIZE + NUM ] ; Arrays . fill ( header , ( byte ) NUM ) ; hex len = Proto Common . long 2 buff ( pkg len ) ; System . arraycopy ( hex len , NUM , header , NUM , hex len . length ) ; header [ PROTO HEADER CMD INDEX ] = cmd ; header [ PROTO HEADER STATUS INDEX ] = errno ; return header ; }
public static void insert Empty Data ( Byte Buffer buffer , int len ) { byte [ ] buf = buffer . array ( ) ; int pos = buffer . position ( ) ; int limit = buffer . limit ( ) ; System . arraycopy ( buf , pos , buf , pos + len , limit - pos ) ; Arrays . fill ( buf , pos , pos + len , ( byte ) NUM ) ; buffer . limit ( limit + len ) ; }
public static void insert Empty Data ( Byte Buffer buffer , int len ) { byte [ ] buf = buffer . array ( ) ; int pos = buffer . position ( ) ; int limit = buffer . limit ( ) ; System . arraycopy ( buf , pos , buf , pos + len , limit - pos ) ; Arrays . fill ( buf , pos , pos + len , ( byte ) NUM ) ; buffer . limit ( limit + len ) ; }
public void remove Change Listener ( Change Listener cl ) { m listeners . remove ( cl ) ; }
private void clean Static ( Method Node method ) { }
protected abstract Guacamole Tunnel create Tunnel ( Session session , Endpoint Config config ) throws Guacamole Exception ;
protected abstract Guacamole Tunnel create Tunnel ( Session session , Endpoint Config config ) throws Guacamole Exception ;
private void check Required Fields ( Simple Object simple Object , String [ ] required Fields ) { List < String > missing Fields = new Array List < > ( ) ; for ( String required Field : required Fields ) { if ( ! simple Object . contains Key ( required Field ) ) { missing Fields . add ( required Field ) ; } } if ( ! missing Fields . is Empty ( ) ) { throw new Invalid Object Data Exception ( STRING + String Utils . join ( missing Fields , STRING ) ) ; } }
private void check Required Fields ( Simple Object simple Object , String [ ] required Fields ) { List < String > missing Fields = new Array List < > ( ) ; for ( String required Field : required Fields ) { if ( ! simple Object . contains Key ( required Field ) ) { missing Fields . add ( required Field ) ; } } if ( ! missing Fields . is Empty ( ) ) { throw new Invalid Object Data Exception ( STRING + String Utils . join ( missing Fields , STRING ) ) ; } }
public void reset ( ) { tech Tree . check Sub Tree ( tech Tree . get Path For Row ( NUM ) , BOOL ) ; }
public boolean write ( Type type , Object value , Node Map node ) { Class actual = value . get Class ( ) ; Class expect = type . get Type ( ) ; Class real = actual ; if ( actual . is Array ( ) ) { real = write Array ( actual , value , node ) ; } if ( actual != expect ) { node . put ( label , real . get Name ( ) ) ; } return write Reference ( value , node ) ; }
public boolean write ( Type type , Object value , Node Map node ) { Class actual = value . get Class ( ) ; Class expect = type . get Type ( ) ; Class real = actual ; if ( actual . is Array ( ) ) { real = write Array ( actual , value , node ) ; } if ( actual != expect ) { node . put ( label , real . get Name ( ) ) ; } return write Reference ( value , node ) ; }
public boolean write ( Type type , Object value , Node Map node ) { Class actual = value . get Class ( ) ; Class expect = type . get Type ( ) ; Class real = actual ; if ( actual . is Array ( ) ) { real = write Array ( actual , value , node ) ; } if ( actual != expect ) { node . put ( label , real . get Name ( ) ) ; } return write Reference ( value , node ) ; }
public boolean write ( Type type , Object value , Node Map node ) { Class actual = value . get Class ( ) ; Class expect = type . get Type ( ) ; Class real = actual ; if ( actual . is Array ( ) ) { real = write Array ( actual , value , node ) ; } if ( actual != expect ) { node . put ( label , real . get Name ( ) ) ; } return write Reference ( value , node ) ; }
public static < T , U extends Closeable > T with Closeable ( U self , @ Closure Params ( value = First Param . class ) Closure < T > action ) throws IO Exception { try { T result = action . call ( self ) ; Closeable temp = self ; self = null ; temp . close ( ) ; return result ; } finally { Default Groovy Methods Support . close With Warning ( self ) ; } }
public static < T , U extends Closeable > T with Closeable ( U self , @ Closure Params ( value = First Param . class ) Closure < T > action ) throws IO Exception { try { T result = action . call ( self ) ; Closeable temp = self ; self = null ; temp . close ( ) ; return result ; } finally { Default Groovy Methods Support . close With Warning ( self ) ; } }
public static void validate Composite Data ( Composite Data cd ) { if ( cd == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ! is Type Matched ( get Base Gc Info Composite Type ( ) , cd . get Composite Type ( ) ) ) { throw new Illegal Argument Exception ( STRING ) ; } }
public static void validate Composite Data ( Composite Data cd ) { if ( cd == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ! is Type Matched ( get Base Gc Info Composite Type ( ) , cd . get Composite Type ( ) ) ) { throw new Illegal Argument Exception ( STRING ) ; } }
public static void validate Composite Data ( Composite Data cd ) { if ( cd == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ! is Type Matched ( get Base Gc Info Composite Type ( ) , cd . get Composite Type ( ) ) ) { throw new Illegal Argument Exception ( STRING ) ; } }
public static void validate Composite Data ( Composite Data cd ) { if ( cd == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ! is Type Matched ( get Base Gc Info Composite Type ( ) , cd . get Composite Type ( ) ) ) { throw new Illegal Argument Exception ( STRING ) ; } }
protected void do Add User ( User user ) throws Users Repository Exception { Connection conn = null ; Prepared Statement add User Statement = null ; try { conn = open Connection ( ) ; add User Statement = conn . prepare Statement ( m insert User Sql ) ; set User For Insert Statement ( user , add User Statement ) ; add User Statement . execute ( ) ; } catch ( SQL Exception sql Exc ) { sql Exc . print Stack Trace ( ) ; throw new Users Repository Exception ( STRING , sql Exc ) ; } finally { the JDBC Util . close JDBC Statement ( add User Statement ) ; the JDBC Util . close JDBC Connection ( conn ) ; } }
public void visit ( Bnf Visitor visitor , String s ) { this . syntax = s ; tokens = tokenize ( ) ; index = NUM ; Rule rule = parse Rule ( ) ; rule . set Links ( rule Map ) ; rule . accept ( visitor ) ; }
public void visit ( Bnf Visitor visitor , String s ) { this . syntax = s ; tokens = tokenize ( ) ; index = NUM ; Rule rule = parse Rule ( ) ; rule . set Links ( rule Map ) ; rule . accept ( visitor ) ; }
public void visit ( Bnf Visitor visitor , String s ) { this . syntax = s ; tokens = tokenize ( ) ; index = NUM ; Rule rule = parse Rule ( ) ; rule . set Links ( rule Map ) ; rule . accept ( visitor ) ; }
public static < T > Set < T > to Set ( T obj 1 , T obj 2 , T obj 3 ) { Set < T > the Set = new Linked Hash Set < T > ( ) ; the Set . add ( obj 1 ) ; the Set . add ( obj 2 ) ; the Set . add ( obj 3 ) ; return the Set ; }
public void clear ( ) { final Object [ ] items = this . items ; final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { int k = count ; if ( k > NUM ) { final int put Index = this . put Index ; int i = take Index ; do { items [ i ] = null ; } while ( ( i = inc ( i ) ) != put Index ) ; take Index = put Index ; count = NUM ; if ( itrs != null ) itrs . queue Is Empty ( ) ; for ( ; k > NUM && lock . has Waiters ( not Full ) ; k -- ) not Full . signal ( ) ; } } finally { lock . unlock ( ) ; } }
public void clear ( ) { final Object [ ] items = this . items ; final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { int k = count ; if ( k > NUM ) { final int put Index = this . put Index ; int i = take Index ; do { items [ i ] = null ; } while ( ( i = inc ( i ) ) != put Index ) ; take Index = put Index ; count = NUM ; if ( itrs != null ) itrs . queue Is Empty ( ) ; for ( ; k > NUM && lock . has Waiters ( not Full ) ; k -- ) not Full . signal ( ) ; } } finally { lock . unlock ( ) ; } }
protected void run DBSCAN ( Relation < O > relation , Range Query < O > range Query ) { final int size = relation . size ( ) ; Finite Progress objprog = LOG . is Verbose ( ) ? new Finite Progress ( STRING , size , LOG ) : null ; Indefinite Progress clusprog = LOG . is Verbose ( ) ? new Indefinite Progress ( STRING , LOG ) : null ; processed I Ds = DBID Util . new Hash Set ( size ) ; Array Modifiable DBI Ds seeds = DBID Util . new Array ( ) ; for ( DBID Iter iditer = relation . iter DBI Ds ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { if ( ! processed I Ds . contains ( iditer ) ) { expand Cluster ( relation , range Query , iditer , seeds , objprog , clusprog ) ; } if ( objprog != null && clusprog != null ) { objprog . set Processed ( processed I Ds . size ( ) , LOG ) ; clusprog . set Processed ( result List . size ( ) , LOG ) ; } if ( processed I Ds . size ( ) == size ) { break ; } } LOG . ensure Completed ( objprog ) ; LOG . set Completed ( clusprog ) ; }
public void do Search ( ) { do Refresh ( ) ; }
public void do Search ( ) { do Refresh ( ) ; }
public void test Compute Z Na N ( ) { Geometry linear Geom = read ( STRING ) ; Length Indexed Line indexed Line = new Length Indexed Line ( linear Geom ) ; double proj Index = indexed Line . project ( new Coordinate ( NUM , NUM ) ) ; Coordinate proj Pt = indexed Line . extract Point ( proj Index ) ; assert True ( Double . is Na N ( proj Pt . z ) ) ; }
public static String normalize ( String value ) { if ( value == null ) return value ; value = value . trim ( ) ; if ( value . index Of ( STRING ) == - NUM ) return value ; boolean space = BOOL ; int len = value . length ( ) ; String Buffer b = new String Buffer ( len ) ; for ( int i = NUM ; i < len ; i ++ ) { char v = value . char At ( i ) ; if ( v == STRING ) { if ( ! space ) b . append ( v ) ; space = BOOL ; } else { b . append ( v ) ; space = BOOL ; } } return b . to String ( ) ; }
public static String normalize ( String value ) { if ( value == null ) return value ; value = value . trim ( ) ; if ( value . index Of ( STRING ) == - NUM ) return value ; boolean space = BOOL ; int len = value . length ( ) ; String Buffer b = new String Buffer ( len ) ; for ( int i = NUM ; i < len ; i ++ ) { char v = value . char At ( i ) ; if ( v == STRING ) { if ( ! space ) b . append ( v ) ; space = BOOL ; } else { b . append ( v ) ; space = BOOL ; } } return b . to String ( ) ; }
@ Override String debug Decode Sort Key Bytes ( byte [ ] bytes , int index , int length ) { String Builder sb = new String Builder ( ) ; Util . bytes To Hex ( sb , bytes , index , length ) ; return sb . to String ( ) ; }
public void export As KML ( XML Stream Writer xml Writer ) throws IO Exception , XML Stream Exception { }
Auto Detect Data Type switch Type ( Object obj ) { int type Id = get Type Id ( obj ) ; Auto Detect Data Type l = last ; if ( type Id != l . type Id ) { last = l = new Type ( type Id ) ; } return l ; }
public Cache Loader With Declarables ( ) { this . props = new Properties ( ) ; props . put ( STRING , STRING ) ; props . put ( STRING , new Test Declarable ( ) ) ; }
public Cache Loader With Declarables ( ) { this . props = new Properties ( ) ; props . put ( STRING , STRING ) ; props . put ( STRING , new Test Declarable ( ) ) ; }
public void reload Roster File ( ) { list . clear ( ) ; try { instance . read File ( default Nce Consist Roster Filename ( ) ) ; } catch ( Exception e ) { log . error ( STRING + e ) ; } }
public void reload Roster File ( ) { list . clear ( ) ; try { instance . read File ( default Nce Consist Roster Filename ( ) ) ; } catch ( Exception e ) { log . error ( STRING + e ) ; } }
public void reload Roster File ( ) { list . clear ( ) ; try { instance . read File ( default Nce Consist Roster Filename ( ) ) ; } catch ( Exception e ) { log . error ( STRING + e ) ; } }
public void reload Roster File ( ) { list . clear ( ) ; try { instance . read File ( default Nce Consist Roster Filename ( ) ) ; } catch ( Exception e ) { log . error ( STRING + e ) ; } }
private boolean has Wrapped Methods For Class ( Soot Class parent Class , boolean new Taints , boolean kill Taints , boolean exclude Taints ) { if ( new Taints && class List . contains Key ( parent Class . get Name ( ) ) ) return BOOL ; if ( exclude Taints && exclude List . contains Key ( parent Class . get Name ( ) ) ) return BOOL ; if ( kill Taints && kill List . contains Key ( parent Class . get Name ( ) ) ) return BOOL ; return BOOL ; }
private boolean has Wrapped Methods For Class ( Soot Class parent Class , boolean new Taints , boolean kill Taints , boolean exclude Taints ) { if ( new Taints && class List . contains Key ( parent Class . get Name ( ) ) ) return BOOL ; if ( exclude Taints && exclude List . contains Key ( parent Class . get Name ( ) ) ) return BOOL ; if ( kill Taints && kill List . contains Key ( parent Class . get Name ( ) ) ) return BOOL ; return BOOL ; }
@ Bean public Default Jms Listener Container Factory jms Listener Container Factory ( Connection Factory jms Connection Factory ) { Default Jms Listener Container Factory factory = new Default Jms Listener Container Factory ( ) ; factory . set Connection Factory ( jms Connection Factory ) ; factory . set Destination Resolver ( herd Destination Resolver ) ; factory . set Concurrency ( configuration Helper . get Property ( Configuration Value . JMS LISTENER POOL CONCURRENCY LIMITS ) ) ; return factory ; }
@ Bean public Default Jms Listener Container Factory jms Listener Container Factory ( Connection Factory jms Connection Factory ) { Default Jms Listener Container Factory factory = new Default Jms Listener Container Factory ( ) ; factory . set Connection Factory ( jms Connection Factory ) ; factory . set Destination Resolver ( herd Destination Resolver ) ; factory . set Concurrency ( configuration Helper . get Property ( Configuration Value . JMS LISTENER POOL CONCURRENCY LIMITS ) ) ; return factory ; }
@ Bean public Default Jms Listener Container Factory jms Listener Container Factory ( Connection Factory jms Connection Factory ) { Default Jms Listener Container Factory factory = new Default Jms Listener Container Factory ( ) ; factory . set Connection Factory ( jms Connection Factory ) ; factory . set Destination Resolver ( herd Destination Resolver ) ; factory . set Concurrency ( configuration Helper . get Property ( Configuration Value . JMS LISTENER POOL CONCURRENCY LIMITS ) ) ; return factory ; }
public void button Clicked ( Action Event e ) ;
public D View Certificate Fingerprint ( J Frame parent , byte [ ] encoded Certificate , Digest Type fingerprint Alg ) { super ( parent , Dialog . Modality Type . DOCUMENT MODAL ) ; this . encoded Certificate = encoded Certificate ; this . fingerprint Alg = fingerprint Alg ; init Components ( ) ; }
public static int convert Sp To Px ( int sp Size ) { return Math . round ( ( float ) sp Size / get Display Density 4 Fonts ( ) ) ; }
public static int convert Sp To Px ( int sp Size ) { return Math . round ( ( float ) sp Size / get Display Density 4 Fonts ( ) ) ; }
public static int convert Sp To Px ( int sp Size ) { return Math . round ( ( float ) sp Size / get Display Density 4 Fonts ( ) ) ; }
public static int convert Sp To Px ( int sp Size ) { return Math . round ( ( float ) sp Size / get Display Density 4 Fonts ( ) ) ; }
private static String extract Top Item ( String search String , String schema , int start Idx ) { String extracted = null ; int prop Idx = schema . index Of ( STRING , start Idx ) ; if ( prop Idx == - NUM ) { prop Idx = Integer . MAX VALUE ; } int id Idx = schema . index Of ( STRING + search String + STRING , start Idx ) ; int second Id Idx = schema . index Of ( STRING + search String + STRING , id Idx + NUM ) ; if ( second Id Idx != - NUM && prop Idx > second Id Idx ) { id Idx = second Id Idx ; } if ( id Idx != - NUM && prop Idx > id Idx ) { int value Start Idx = schema . index Of ( STRING , id Idx + ( search String . length ( ) + NUM ) ) ; int value End Idx = schema . index Of ( STRING , value Start Idx + NUM ) ; extracted = schema . substring ( value Start Idx + NUM , value End Idx ) ; } return extracted ; }
public int read ( char ch [ ] , int offset , int length ) throws IO Exception { if ( length > f Buffer . length ) { length = f Buffer . length ; } int count = f Input Stream . read ( f Buffer , NUM , length ) ; for ( int i = NUM ; i < count ; i ++ ) { int b0 = f Buffer [ i ] ; if ( b0 < NUM ) { throw new IO Exception ( Localizer . get Message ( STRING , Integer . to String ( b0 ) ) ) ; } ch [ offset + i ] = ( char ) b0 ; } return count ; }
public int read ( char ch [ ] , int offset , int length ) throws IO Exception { if ( length > f Buffer . length ) { length = f Buffer . length ; } int count = f Input Stream . read ( f Buffer , NUM , length ) ; for ( int i = NUM ; i < count ; i ++ ) { int b0 = f Buffer [ i ] ; if ( b0 < NUM ) { throw new IO Exception ( Localizer . get Message ( STRING , Integer . to String ( b0 ) ) ) ; } ch [ offset + i ] = ( char ) b0 ; } return count ; }
public boolean remove Argument ( String arg ) { return arguments . remove ( arg ) ; }
private static String replace Chars ( String str ) { String Buffer buf = new String Buffer ( str ) ; int length = buf . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char current Char = buf . char At ( i ) ; if ( current Char == STRING ) { buf . set Char At ( i , STRING ) ; buf . insert ( i + NUM , STRING ) ; length = length + NUM ; i = i + NUM ; } else if ( current Char == STRING ) { buf . set Char At ( i , STRING ) ; } } return buf . to String ( ) ; }
private static String replace Chars ( String str ) { String Buffer buf = new String Buffer ( str ) ; int length = buf . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char current Char = buf . char At ( i ) ; if ( current Char == STRING ) { buf . set Char At ( i , STRING ) ; buf . insert ( i + NUM , STRING ) ; length = length + NUM ; i = i + NUM ; } else if ( current Char == STRING ) { buf . set Char At ( i , STRING ) ; } } return buf . to String ( ) ; }
private static String replace Chars ( String str ) { String Buffer buf = new String Buffer ( str ) ; int length = buf . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char current Char = buf . char At ( i ) ; if ( current Char == STRING ) { buf . set Char At ( i , STRING ) ; buf . insert ( i + NUM , STRING ) ; length = length + NUM ; i = i + NUM ; } else if ( current Char == STRING ) { buf . set Char At ( i , STRING ) ; } } return buf . to String ( ) ; }
public boolean add Mouse Listener ( final Map Mouse Listener listener ) { if ( listener == null ) { throw new Illegal Argument Exception ( STRING ) ; } return listeners . add ( listener ) ; }
private static int find Closest ( int desired Factor , Set < Integer > factors ) { int best Factor = NUM ; int best Delta = desired Factor ; for ( Integer factor : factors ) { int test Delta = Math . abs ( desired Factor - factor ) ; if ( test Delta < best Delta ) { best Delta = test Delta ; best Factor = factor ; } } return best Factor ; }
public int last Index Of ( String string ) { return last Index Of ( string , length ( ) ) ; }
public int last Index Of ( String string ) { return last Index Of ( string , length ( ) ) ; }
public Stroke Cell Renderer ( ) { panel = new J Panel ( ) ; panel . set Opaque ( BOOL ) ; }
public boolean are On Equivalent Host ( Internal Distributed Member member 1 , Internal Distributed Member member 2 ) { Set < Inet Address > equivalents 1 = get Equivalents ( member 1 . get Inet Address ( ) ) ; return equivalents 1 . contains ( member 2 . get Inet Address ( ) ) ; }
@ Override @ Deprecated public Condition duplicate ( ) { return this ; }
@ Override @ Deprecated public Condition duplicate ( ) { return this ; }
public void init Unit Turn ( Entity unit , I Game game ) { }
public void init Unit Turn ( Entity unit , I Game game ) { }
public void init Unit Turn ( Entity unit , I Game game ) { }
public void init Unit Turn ( Entity unit , I Game game ) { }
public void init Unit Turn ( Entity unit , I Game game ) { }
@ Not Null private Flutter Daemon Controller controller For ( String project Dir , String device Id ) { synchronized ( my Lock ) { Flutter Daemon Controller new Controller = new Flutter Daemon Controller ( project Dir ) ; my Controllers . add ( new Controller ) ; new Controller . add Listener ( my Listener ) ; return new Controller ; } }
@ Not Null private Flutter Daemon Controller controller For ( String project Dir , String device Id ) { synchronized ( my Lock ) { Flutter Daemon Controller new Controller = new Flutter Daemon Controller ( project Dir ) ; my Controllers . add ( new Controller ) ; new Controller . add Listener ( my Listener ) ; return new Controller ; } }
@ Not Null private Flutter Daemon Controller controller For ( String project Dir , String device Id ) { synchronized ( my Lock ) { Flutter Daemon Controller new Controller = new Flutter Daemon Controller ( project Dir ) ; my Controllers . add ( new Controller ) ; new Controller . add Listener ( my Listener ) ; return new Controller ; } }
@ Not Null private Flutter Daemon Controller controller For ( String project Dir , String device Id ) { synchronized ( my Lock ) { Flutter Daemon Controller new Controller = new Flutter Daemon Controller ( project Dir ) ; my Controllers . add ( new Controller ) ; new Controller . add Listener ( my Listener ) ; return new Controller ; } }
@ Not Null private Flutter Daemon Controller controller For ( String project Dir , String device Id ) { synchronized ( my Lock ) { Flutter Daemon Controller new Controller = new Flutter Daemon Controller ( project Dir ) ; my Controllers . add ( new Controller ) ; new Controller . add Listener ( my Listener ) ; return new Controller ; } }
public byte byte At ( int index ) { bb . position ( index ) ; return bb . get ( ) ; }
public static Output Stream encrypt ( Output Stream unencrypted Output Stream , char [ ] password ) throws Encryption Exception , IO Exception { Output Stream encrypted Output Stream = null ; PBE Key Spec pbe Key Spec = new PBE Key Spec ( password ) ; PBE Parameter Spec pbe Parameter Spec = new PBE Parameter Spec ( SALT , ITERATION COUNT ) ; try { Secret Key Factory secret Key Factory = Secret Key Factory . get Instance ( ENCRYPTION ALGORITHM , CRYPTOPROVIDER ) ; Secret Key pbe Key = secret Key Factory . generate Secret ( pbe Key Spec ) ; Cipher cipher = Cipher . get Instance ( ENCRYPTION ALGORITHM , CRYPTOPROVIDER ) ; cipher . init ( Cipher . ENCRYPT MODE , pbe Key , pbe Parameter Spec ) ; encrypted Output Stream = new Cipher Output Stream ( unencrypted Output Stream , cipher ) ; } catch ( General Security Exception e ) { throw new Encryption Exception ( STRING , e ) ; } return encrypted Output Stream ; }
public String service ( String service Spec , String service Cmd ) throws Exception { return execute Extension ( Resource Type . SERVICE , service Spec , KEY COMMAND , service Cmd , null ) ; }
public String service ( String service Spec , String service Cmd ) throws Exception { return execute Extension ( Resource Type . SERVICE , service Spec , KEY COMMAND , service Cmd , null ) ; }
public String service ( String service Spec , String service Cmd ) throws Exception { return execute Extension ( Resource Type . SERVICE , service Spec , KEY COMMAND , service Cmd , null ) ; }
public void fire State Changed ( ) { Change Event e = new Change Event ( this ) ; for ( Change Listener listener : listeners ) { listener . state Changed ( e ) ; } }
@ Override public void close ( ) throws IO Exception { synchronized ( lock ) { buf = null ; in . close ( ) ; } }
@ Override public void close ( ) throws IO Exception { synchronized ( lock ) { buf = null ; in . close ( ) ; } }
@ Override public void close ( ) throws IO Exception { synchronized ( lock ) { buf = null ; in . close ( ) ; } }
public void make Immutable ( ) { if ( is Mutable ) { if ( subject Confirmations != null ) { int length = subject Confirmations . size ( ) ; for ( int i = NUM ; i < length ; i ++ ) { Subject Confirmation subject Confirmation = ( Subject Confirmation ) subject Confirmations . get ( i ) ; subject Confirmation . make Immutable ( ) ; } subject Confirmations = Collections . unmodifiable List ( subject Confirmations ) ; } if ( base Id != null ) { base Id . make Immutable ( ) ; } if ( name Id != null ) { name Id . make Immutable ( ) ; } is Mutable = BOOL ; } }
public static void add Filter Init Param ( Web Xml web Xml , String name , String param Name , String param Value ) { Web Xml Element element = ( Web Xml Element ) web Xml . get Tag By Identifier ( Web Xml Type . FILTER , name ) ; add Tag Init Param ( element , param Name , param Value ) ; }
public int size ( ) { return values . size ( ) ; }
public int size ( ) { return values . size ( ) ; }
public void check ( ) throws Erlang Version Exception { String erlang Version ; try { erlang Version = erlang Shell . get Erlang Version ( ) ; LOGGER . debug ( STRING , erlang Version ) ; } catch ( Erlang Shell Exception e ) { throw new Erlang Version Exception ( STRING , e ) ; } if ( min Erlang Version == null ) { LOGGER . debug ( STRING ) ; return ; } else { LOGGER . debug ( STRING , min Erlang Version ) ; } double expected ; double actual ; try { expected = parse ( min Erlang Version ) ; actual = parse ( erlang Version ) ; } catch ( Runtime Exception e ) { LOGGER . warn ( STRING + min Erlang Version + STRING + erlang Version + STRING ) ; return ; } if ( actual < expected ) { throw new Erlang Version Exception ( String . format ( STRING , min Erlang Version , erlang Version ) ) ; } }
public void check ( ) throws Erlang Version Exception { String erlang Version ; try { erlang Version = erlang Shell . get Erlang Version ( ) ; LOGGER . debug ( STRING , erlang Version ) ; } catch ( Erlang Shell Exception e ) { throw new Erlang Version Exception ( STRING , e ) ; } if ( min Erlang Version == null ) { LOGGER . debug ( STRING ) ; return ; } else { LOGGER . debug ( STRING , min Erlang Version ) ; } double expected ; double actual ; try { expected = parse ( min Erlang Version ) ; actual = parse ( erlang Version ) ; } catch ( Runtime Exception e ) { LOGGER . warn ( STRING + min Erlang Version + STRING + erlang Version + STRING ) ; return ; } if ( actual < expected ) { throw new Erlang Version Exception ( String . format ( STRING , min Erlang Version , erlang Version ) ) ; } }
public void check ( ) throws Erlang Version Exception { String erlang Version ; try { erlang Version = erlang Shell . get Erlang Version ( ) ; LOGGER . debug ( STRING , erlang Version ) ; } catch ( Erlang Shell Exception e ) { throw new Erlang Version Exception ( STRING , e ) ; } if ( min Erlang Version == null ) { LOGGER . debug ( STRING ) ; return ; } else { LOGGER . debug ( STRING , min Erlang Version ) ; } double expected ; double actual ; try { expected = parse ( min Erlang Version ) ; actual = parse ( erlang Version ) ; } catch ( Runtime Exception e ) { LOGGER . warn ( STRING + min Erlang Version + STRING + erlang Version + STRING ) ; return ; } if ( actual < expected ) { throw new Erlang Version Exception ( String . format ( STRING , min Erlang Version , erlang Version ) ) ; } }
public void check ( ) throws Erlang Version Exception { String erlang Version ; try { erlang Version = erlang Shell . get Erlang Version ( ) ; LOGGER . debug ( STRING , erlang Version ) ; } catch ( Erlang Shell Exception e ) { throw new Erlang Version Exception ( STRING , e ) ; } if ( min Erlang Version == null ) { LOGGER . debug ( STRING ) ; return ; } else { LOGGER . debug ( STRING , min Erlang Version ) ; } double expected ; double actual ; try { expected = parse ( min Erlang Version ) ; actual = parse ( erlang Version ) ; } catch ( Runtime Exception e ) { LOGGER . warn ( STRING + min Erlang Version + STRING + erlang Version + STRING ) ; return ; } if ( actual < expected ) { throw new Erlang Version Exception ( String . format ( STRING , min Erlang Version , erlang Version ) ) ; } }
public void check ( ) throws Erlang Version Exception { String erlang Version ; try { erlang Version = erlang Shell . get Erlang Version ( ) ; LOGGER . debug ( STRING , erlang Version ) ; } catch ( Erlang Shell Exception e ) { throw new Erlang Version Exception ( STRING , e ) ; } if ( min Erlang Version == null ) { LOGGER . debug ( STRING ) ; return ; } else { LOGGER . debug ( STRING , min Erlang Version ) ; } double expected ; double actual ; try { expected = parse ( min Erlang Version ) ; actual = parse ( erlang Version ) ; } catch ( Runtime Exception e ) { LOGGER . warn ( STRING + min Erlang Version + STRING + erlang Version + STRING ) ; return ; } if ( actual < expected ) { throw new Erlang Version Exception ( String . format ( STRING , min Erlang Version , erlang Version ) ) ; } }
static Thread create Thread ( final Runnable runnable , final String thread Name , final boolean is Daemon , final int priority , final boolean do Start ) { Thread thread = new Thread ( runnable ) ; if ( thread Name != null ) { thread . set Name ( thread Name ) ; } thread . set Daemon ( is Daemon ) ; if ( priority >= NUM ) { thread . set Priority ( priority ) ; } if ( do Start ) { thread . start ( ) ; } return thread ; }
static Thread create Thread ( final Runnable runnable , final String thread Name , final boolean is Daemon , final int priority , final boolean do Start ) { Thread thread = new Thread ( runnable ) ; if ( thread Name != null ) { thread . set Name ( thread Name ) ; } thread . set Daemon ( is Daemon ) ; if ( priority >= NUM ) { thread . set Priority ( priority ) ; } if ( do Start ) { thread . start ( ) ; } return thread ; }
protected void begin Path ( ) { prep Drawing ( ) ; mPS Stream . println ( NEWPATH STR ) ; m Pen X = NUM ; m Pen Y = NUM ; }
protected void begin Path ( ) { prep Drawing ( ) ; mPS Stream . println ( NEWPATH STR ) ; m Pen X = NUM ; m Pen Y = NUM ; }
@ Override @ Suppress Warnings ( STRING ) public synchronized < T > T [ ] to Array ( T [ ] contents ) { if ( element Count > contents . length ) { throw new Runtime Exception ( STRING ) ; } System . arraycopy ( element Data , NUM , contents , NUM , element Count ) ; if ( element Count < contents . length ) { contents [ element Count ] = null ; } return contents ; }
@ Override @ Suppress Warnings ( STRING ) public synchronized < T > T [ ] to Array ( T [ ] contents ) { if ( element Count > contents . length ) { throw new Runtime Exception ( STRING ) ; } System . arraycopy ( element Data , NUM , contents , NUM , element Count ) ; if ( element Count < contents . length ) { contents [ element Count ] = null ; } return contents ; }
@ Override @ Suppress Warnings ( STRING ) public synchronized < T > T [ ] to Array ( T [ ] contents ) { if ( element Count > contents . length ) { throw new Runtime Exception ( STRING ) ; } System . arraycopy ( element Data , NUM , contents , NUM , element Count ) ; if ( element Count < contents . length ) { contents [ element Count ] = null ; } return contents ; }
@ Override @ Suppress Warnings ( STRING ) public synchronized < T > T [ ] to Array ( T [ ] contents ) { if ( element Count > contents . length ) { throw new Runtime Exception ( STRING ) ; } System . arraycopy ( element Data , NUM , contents , NUM , element Count ) ; if ( element Count < contents . length ) { contents [ element Count ] = null ; } return contents ; }
@ Override @ Suppress Warnings ( STRING ) public synchronized < T > T [ ] to Array ( T [ ] contents ) { if ( element Count > contents . length ) { throw new Runtime Exception ( STRING ) ; } System . arraycopy ( element Data , NUM , contents , NUM , element Count ) ; if ( element Count < contents . length ) { contents [ element Count ] = null ; } return contents ; }
@ Override @ Suppress Warnings ( STRING ) public synchronized < T > T [ ] to Array ( T [ ] contents ) { if ( element Count > contents . length ) { throw new Runtime Exception ( STRING ) ; } System . arraycopy ( element Data , NUM , contents , NUM , element Count ) ; if ( element Count < contents . length ) { contents [ element Count ] = null ; } return contents ; }
@ Override @ Suppress Warnings ( STRING ) public synchronized < T > T [ ] to Array ( T [ ] contents ) { if ( element Count > contents . length ) { throw new Runtime Exception ( STRING ) ; } System . arraycopy ( element Data , NUM , contents , NUM , element Count ) ; if ( element Count < contents . length ) { contents [ element Count ] = null ; } return contents ; }
@ Override @ Suppress Warnings ( STRING ) public synchronized < T > T [ ] to Array ( T [ ] contents ) { if ( element Count > contents . length ) { throw new Runtime Exception ( STRING ) ; } System . arraycopy ( element Data , NUM , contents , NUM , element Count ) ; if ( element Count < contents . length ) { contents [ element Count ] = null ; } return contents ; }
public Bigdata Sail Repository Connection cxn ( ) { return tl Tx . get ( ) ; }
public Bigdata Sail Repository Connection cxn ( ) { return tl Tx . get ( ) ; }
@ Visible For Testing public static boolean is Text File ( @ Non Null File file ) { String name = file . get Name ( ) ; return name . ends With ( DOT JAVA ) || name . ends With ( DOT XML ) || name . ends With ( DOT AIDL ) || name . ends With ( DOT FS ) || name . ends With ( DOT RS ) || name . ends With ( DOT RSH ) || name . ends With ( DOT RSH ) || name . ends With ( DOT TXT ) || name . ends With ( DOT GRADLE ) || name . ends With ( DOT PROPERTIES ) || name . ends With ( STRING ) || name . ends With ( STRING ) || name . ends With ( STRING ) || name . ends With ( STRING ) || name . ends With ( STRING ) ; }
@ Visible For Testing public static boolean is Text File ( @ Non Null File file ) { String name = file . get Name ( ) ; return name . ends With ( DOT JAVA ) || name . ends With ( DOT XML ) || name . ends With ( DOT AIDL ) || name . ends With ( DOT FS ) || name . ends With ( DOT RS ) || name . ends With ( DOT RSH ) || name . ends With ( DOT RSH ) || name . ends With ( DOT TXT ) || name . ends With ( DOT GRADLE ) || name . ends With ( DOT PROPERTIES ) || name . ends With ( STRING ) || name . ends With ( STRING ) || name . ends With ( STRING ) || name . ends With ( STRING ) || name . ends With ( STRING ) ; }
private void collect Compatible Exceptions ( Class Doc [ ] froms , Class Doc [ ] withs , List < Class Doc > list ) { for ( Class Doc from : froms ) { if ( ! list . contains ( from ) ) { for ( Class Doc with : withs ) { if ( from . subclass Of ( with ) ) { list . add ( from ) ; break ; } } } } }
void send Bit 5 Baud ( boolean bit Value ) throws IO Exception { Serial Ext . set Break ( bit Value ? NUM : NUM ) ; try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { log . error ( null , e ) ; } }
public static URL [ ] path To UR Ls ( String path ) { String Tokenizer st = new String Tokenizer ( path , File . path Separator ) ; URL [ ] urls = new URL [ st . count Tokens ( ) ] ; int count = NUM ; while ( st . has More Tokens ( ) ) { File f = new File ( st . next Token ( ) ) ; try { f = new File ( f . get Canonical Path ( ) ) ; } catch ( IO Exception x ) { } try { urls [ count ++ ] = Parse Util . file To Encoded URL ( f ) ; } catch ( IO Exception x ) { } } if ( urls . length != count ) { URL [ ] tmp = new URL [ count ] ; System . arraycopy ( urls , NUM , tmp , NUM , count ) ; urls = tmp ; } return urls ; }
public static URL [ ] path To UR Ls ( String path ) { String Tokenizer st = new String Tokenizer ( path , File . path Separator ) ; URL [ ] urls = new URL [ st . count Tokens ( ) ] ; int count = NUM ; while ( st . has More Tokens ( ) ) { File f = new File ( st . next Token ( ) ) ; try { f = new File ( f . get Canonical Path ( ) ) ; } catch ( IO Exception x ) { } try { urls [ count ++ ] = Parse Util . file To Encoded URL ( f ) ; } catch ( IO Exception x ) { } } if ( urls . length != count ) { URL [ ] tmp = new URL [ count ] ; System . arraycopy ( urls , NUM , tmp , NUM , count ) ; urls = tmp ; } return urls ; }
public static URL [ ] path To UR Ls ( String path ) { String Tokenizer st = new String Tokenizer ( path , File . path Separator ) ; URL [ ] urls = new URL [ st . count Tokens ( ) ] ; int count = NUM ; while ( st . has More Tokens ( ) ) { File f = new File ( st . next Token ( ) ) ; try { f = new File ( f . get Canonical Path ( ) ) ; } catch ( IO Exception x ) { } try { urls [ count ++ ] = Parse Util . file To Encoded URL ( f ) ; } catch ( IO Exception x ) { } } if ( urls . length != count ) { URL [ ] tmp = new URL [ count ] ; System . arraycopy ( urls , NUM , tmp , NUM , count ) ; urls = tmp ; } return urls ; }
public static URL [ ] path To UR Ls ( String path ) { String Tokenizer st = new String Tokenizer ( path , File . path Separator ) ; URL [ ] urls = new URL [ st . count Tokens ( ) ] ; int count = NUM ; while ( st . has More Tokens ( ) ) { File f = new File ( st . next Token ( ) ) ; try { f = new File ( f . get Canonical Path ( ) ) ; } catch ( IO Exception x ) { } try { urls [ count ++ ] = Parse Util . file To Encoded URL ( f ) ; } catch ( IO Exception x ) { } } if ( urls . length != count ) { URL [ ] tmp = new URL [ count ] ; System . arraycopy ( urls , NUM , tmp , NUM , count ) ; urls = tmp ; } return urls ; }
public static URL [ ] path To UR Ls ( String path ) { String Tokenizer st = new String Tokenizer ( path , File . path Separator ) ; URL [ ] urls = new URL [ st . count Tokens ( ) ] ; int count = NUM ; while ( st . has More Tokens ( ) ) { File f = new File ( st . next Token ( ) ) ; try { f = new File ( f . get Canonical Path ( ) ) ; } catch ( IO Exception x ) { } try { urls [ count ++ ] = Parse Util . file To Encoded URL ( f ) ; } catch ( IO Exception x ) { } } if ( urls . length != count ) { URL [ ] tmp = new URL [ count ] ; System . arraycopy ( urls , NUM , tmp , NUM , count ) ; urls = tmp ; } return urls ; }
void add Transaction ( Transaction t , boolean run Sanity Checks ) { un Cache Transactions ( ) ; if ( transactions == null ) { transactions = new Array List < Transaction > ( ) ; } t . set Parent ( this ) ; if ( run Sanity Checks && transactions . size ( ) == NUM && ! t . is Coin Base ( ) ) throw new Runtime Exception ( STRING + t ) ; else if ( run Sanity Checks && transactions . size ( ) > NUM && t . is Coin Base ( ) ) throw new Runtime Exception ( STRING + t ) ; transactions . add ( t ) ; adjust Length ( transactions . size ( ) , t . length ) ; merkle Root = null ; hash = null ; }
public void add Return Attribute ( Core Token Field field ) { Reject . if Null ( field ) ; return Fields . add ( field ) ; }
public void add Return Attribute ( Core Token Field field ) { Reject . if Null ( field ) ; return Fields . add ( field ) ; }
public void add Return Attribute ( Core Token Field field ) { Reject . if Null ( field ) ; return Fields . add ( field ) ; }
public void delete Entity Config ( String realm , String entity Id ) throws SAML 2 Meta Exception { if ( entity Id == null ) { return ; } if ( realm == null ) { realm = STRING ; } String [ ] objs = { entity Id , realm } ; try { Map old Attrs = config Inst . get Configuration ( realm , entity Id ) ; Set old Values = ( Set ) old Attrs . get ( ATTR ENTITY CONFIG ) ; if ( old Values == null || old Values . is Empty ( ) ) { Log Util . error ( Level . INFO , Log Util . NO ENTITY DESCRIPTOR DELETE ENTITY CONFIG , objs , null ) ; throw new SAML 2 Meta Exception ( STRING , objs ) ; } remove From Circle Of Trust ( realm , entity Id ) ; Set attr = new Hash Set ( ) ; attr . add ( ATTR ENTITY CONFIG ) ; config Inst . delete Configuration ( realm , entity Id , attr ) ; Log Util . access ( Level . INFO , Log Util . ENTITY CONFIG DELETED , objs , null ) ; SAML 2 Meta Cache . put Entity Config ( realm , entity Id , null ) ; } catch ( Configuration Exception e ) { debug . error ( STRING , e ) ; String [ ] data = { e . get Message ( ) , entity Id , realm } ; Log Util . error ( Level . INFO , Log Util . CONFIG ERROR DELETE ENTITY CONFIG , data , null ) ; throw new SAML 2 Meta Exception ( e ) ; } }
public int interpolate Out Of Bounds Scroll ( Recycler View recycler View , int view Size , int view Size Out Of Bounds , int total Size , long ms Since Start Scroll ) { final int max Scroll = get Max Drag Scroll ( recycler View ) ; final int abs Out Of Bounds = Math . abs ( view Size Out Of Bounds ) ; final int direction = ( int ) Math . signum ( view Size Out Of Bounds ) ; float out Of Bounds Ratio = Math . min ( NUM , NUM * abs Out Of Bounds / view Size ) ; final int capped Scroll = ( int ) ( direction * max Scroll * s Drag View Scroll Cap Interpolator . get Interpolation ( out Of Bounds Ratio ) ) ; final float time Ratio ; if ( ms Since Start Scroll > DRAG SCROLL ACCELERATION LIMIT TIME MS ) { time Ratio = NUM ; } else { time Ratio = ( float ) ms Since Start Scroll / DRAG SCROLL ACCELERATION LIMIT TIME MS ; } final int value = ( int ) ( capped Scroll * s Drag Scroll Interpolator . get Interpolation ( time Ratio ) ) ; if ( value == NUM ) { return view Size Out Of Bounds > NUM ? NUM : - NUM ; } return value ; }
public int interpolate Out Of Bounds Scroll ( Recycler View recycler View , int view Size , int view Size Out Of Bounds , int total Size , long ms Since Start Scroll ) { final int max Scroll = get Max Drag Scroll ( recycler View ) ; final int abs Out Of Bounds = Math . abs ( view Size Out Of Bounds ) ; final int direction = ( int ) Math . signum ( view Size Out Of Bounds ) ; float out Of Bounds Ratio = Math . min ( NUM , NUM * abs Out Of Bounds / view Size ) ; final int capped Scroll = ( int ) ( direction * max Scroll * s Drag View Scroll Cap Interpolator . get Interpolation ( out Of Bounds Ratio ) ) ; final float time Ratio ; if ( ms Since Start Scroll > DRAG SCROLL ACCELERATION LIMIT TIME MS ) { time Ratio = NUM ; } else { time Ratio = ( float ) ms Since Start Scroll / DRAG SCROLL ACCELERATION LIMIT TIME MS ; } final int value = ( int ) ( capped Scroll * s Drag Scroll Interpolator . get Interpolation ( time Ratio ) ) ; if ( value == NUM ) { return view Size Out Of Bounds > NUM ? NUM : - NUM ; } return value ; }
public int interpolate Out Of Bounds Scroll ( Recycler View recycler View , int view Size , int view Size Out Of Bounds , int total Size , long ms Since Start Scroll ) { final int max Scroll = get Max Drag Scroll ( recycler View ) ; final int abs Out Of Bounds = Math . abs ( view Size Out Of Bounds ) ; final int direction = ( int ) Math . signum ( view Size Out Of Bounds ) ; float out Of Bounds Ratio = Math . min ( NUM , NUM * abs Out Of Bounds / view Size ) ; final int capped Scroll = ( int ) ( direction * max Scroll * s Drag View Scroll Cap Interpolator . get Interpolation ( out Of Bounds Ratio ) ) ; final float time Ratio ; if ( ms Since Start Scroll > DRAG SCROLL ACCELERATION LIMIT TIME MS ) { time Ratio = NUM ; } else { time Ratio = ( float ) ms Since Start Scroll / DRAG SCROLL ACCELERATION LIMIT TIME MS ; } final int value = ( int ) ( capped Scroll * s Drag Scroll Interpolator . get Interpolation ( time Ratio ) ) ; if ( value == NUM ) { return view Size Out Of Bounds > NUM ? NUM : - NUM ; } return value ; }
public int interpolate Out Of Bounds Scroll ( Recycler View recycler View , int view Size , int view Size Out Of Bounds , int total Size , long ms Since Start Scroll ) { final int max Scroll = get Max Drag Scroll ( recycler View ) ; final int abs Out Of Bounds = Math . abs ( view Size Out Of Bounds ) ; final int direction = ( int ) Math . signum ( view Size Out Of Bounds ) ; float out Of Bounds Ratio = Math . min ( NUM , NUM * abs Out Of Bounds / view Size ) ; final int capped Scroll = ( int ) ( direction * max Scroll * s Drag View Scroll Cap Interpolator . get Interpolation ( out Of Bounds Ratio ) ) ; final float time Ratio ; if ( ms Since Start Scroll > DRAG SCROLL ACCELERATION LIMIT TIME MS ) { time Ratio = NUM ; } else { time Ratio = ( float ) ms Since Start Scroll / DRAG SCROLL ACCELERATION LIMIT TIME MS ; } final int value = ( int ) ( capped Scroll * s Drag Scroll Interpolator . get Interpolation ( time Ratio ) ) ; if ( value == NUM ) { return view Size Out Of Bounds > NUM ? NUM : - NUM ; } return value ; }
public int interpolate Out Of Bounds Scroll ( Recycler View recycler View , int view Size , int view Size Out Of Bounds , int total Size , long ms Since Start Scroll ) { final int max Scroll = get Max Drag Scroll ( recycler View ) ; final int abs Out Of Bounds = Math . abs ( view Size Out Of Bounds ) ; final int direction = ( int ) Math . signum ( view Size Out Of Bounds ) ; float out Of Bounds Ratio = Math . min ( NUM , NUM * abs Out Of Bounds / view Size ) ; final int capped Scroll = ( int ) ( direction * max Scroll * s Drag View Scroll Cap Interpolator . get Interpolation ( out Of Bounds Ratio ) ) ; final float time Ratio ; if ( ms Since Start Scroll > DRAG SCROLL ACCELERATION LIMIT TIME MS ) { time Ratio = NUM ; } else { time Ratio = ( float ) ms Since Start Scroll / DRAG SCROLL ACCELERATION LIMIT TIME MS ; } final int value = ( int ) ( capped Scroll * s Drag Scroll Interpolator . get Interpolation ( time Ratio ) ) ; if ( value == NUM ) { return view Size Out Of Bounds > NUM ? NUM : - NUM ; } return value ; }
public int interpolate Out Of Bounds Scroll ( Recycler View recycler View , int view Size , int view Size Out Of Bounds , int total Size , long ms Since Start Scroll ) { final int max Scroll = get Max Drag Scroll ( recycler View ) ; final int abs Out Of Bounds = Math . abs ( view Size Out Of Bounds ) ; final int direction = ( int ) Math . signum ( view Size Out Of Bounds ) ; float out Of Bounds Ratio = Math . min ( NUM , NUM * abs Out Of Bounds / view Size ) ; final int capped Scroll = ( int ) ( direction * max Scroll * s Drag View Scroll Cap Interpolator . get Interpolation ( out Of Bounds Ratio ) ) ; final float time Ratio ; if ( ms Since Start Scroll > DRAG SCROLL ACCELERATION LIMIT TIME MS ) { time Ratio = NUM ; } else { time Ratio = ( float ) ms Since Start Scroll / DRAG SCROLL ACCELERATION LIMIT TIME MS ; } final int value = ( int ) ( capped Scroll * s Drag Scroll Interpolator . get Interpolation ( time Ratio ) ) ; if ( value == NUM ) { return view Size Out Of Bounds > NUM ? NUM : - NUM ; } return value ; }
public int interpolate Out Of Bounds Scroll ( Recycler View recycler View , int view Size , int view Size Out Of Bounds , int total Size , long ms Since Start Scroll ) { final int max Scroll = get Max Drag Scroll ( recycler View ) ; final int abs Out Of Bounds = Math . abs ( view Size Out Of Bounds ) ; final int direction = ( int ) Math . signum ( view Size Out Of Bounds ) ; float out Of Bounds Ratio = Math . min ( NUM , NUM * abs Out Of Bounds / view Size ) ; final int capped Scroll = ( int ) ( direction * max Scroll * s Drag View Scroll Cap Interpolator . get Interpolation ( out Of Bounds Ratio ) ) ; final float time Ratio ; if ( ms Since Start Scroll > DRAG SCROLL ACCELERATION LIMIT TIME MS ) { time Ratio = NUM ; } else { time Ratio = ( float ) ms Since Start Scroll / DRAG SCROLL ACCELERATION LIMIT TIME MS ; } final int value = ( int ) ( capped Scroll * s Drag Scroll Interpolator . get Interpolation ( time Ratio ) ) ; if ( value == NUM ) { return view Size Out Of Bounds > NUM ? NUM : - NUM ; } return value ; }
public int interpolate Out Of Bounds Scroll ( Recycler View recycler View , int view Size , int view Size Out Of Bounds , int total Size , long ms Since Start Scroll ) { final int max Scroll = get Max Drag Scroll ( recycler View ) ; final int abs Out Of Bounds = Math . abs ( view Size Out Of Bounds ) ; final int direction = ( int ) Math . signum ( view Size Out Of Bounds ) ; float out Of Bounds Ratio = Math . min ( NUM , NUM * abs Out Of Bounds / view Size ) ; final int capped Scroll = ( int ) ( direction * max Scroll * s Drag View Scroll Cap Interpolator . get Interpolation ( out Of Bounds Ratio ) ) ; final float time Ratio ; if ( ms Since Start Scroll > DRAG SCROLL ACCELERATION LIMIT TIME MS ) { time Ratio = NUM ; } else { time Ratio = ( float ) ms Since Start Scroll / DRAG SCROLL ACCELERATION LIMIT TIME MS ; } final int value = ( int ) ( capped Scroll * s Drag Scroll Interpolator . get Interpolation ( time Ratio ) ) ; if ( value == NUM ) { return view Size Out Of Bounds > NUM ? NUM : - NUM ; } return value ; }
public int interpolate Out Of Bounds Scroll ( Recycler View recycler View , int view Size , int view Size Out Of Bounds , int total Size , long ms Since Start Scroll ) { final int max Scroll = get Max Drag Scroll ( recycler View ) ; final int abs Out Of Bounds = Math . abs ( view Size Out Of Bounds ) ; final int direction = ( int ) Math . signum ( view Size Out Of Bounds ) ; float out Of Bounds Ratio = Math . min ( NUM , NUM * abs Out Of Bounds / view Size ) ; final int capped Scroll = ( int ) ( direction * max Scroll * s Drag View Scroll Cap Interpolator . get Interpolation ( out Of Bounds Ratio ) ) ; final float time Ratio ; if ( ms Since Start Scroll > DRAG SCROLL ACCELERATION LIMIT TIME MS ) { time Ratio = NUM ; } else { time Ratio = ( float ) ms Since Start Scroll / DRAG SCROLL ACCELERATION LIMIT TIME MS ; } final int value = ( int ) ( capped Scroll * s Drag Scroll Interpolator . get Interpolation ( time Ratio ) ) ; if ( value == NUM ) { return view Size Out Of Bounds > NUM ? NUM : - NUM ; } return value ; }
public int interpolate Out Of Bounds Scroll ( Recycler View recycler View , int view Size , int view Size Out Of Bounds , int total Size , long ms Since Start Scroll ) { final int max Scroll = get Max Drag Scroll ( recycler View ) ; final int abs Out Of Bounds = Math . abs ( view Size Out Of Bounds ) ; final int direction = ( int ) Math . signum ( view Size Out Of Bounds ) ; float out Of Bounds Ratio = Math . min ( NUM , NUM * abs Out Of Bounds / view Size ) ; final int capped Scroll = ( int ) ( direction * max Scroll * s Drag View Scroll Cap Interpolator . get Interpolation ( out Of Bounds Ratio ) ) ; final float time Ratio ; if ( ms Since Start Scroll > DRAG SCROLL ACCELERATION LIMIT TIME MS ) { time Ratio = NUM ; } else { time Ratio = ( float ) ms Since Start Scroll / DRAG SCROLL ACCELERATION LIMIT TIME MS ; } final int value = ( int ) ( capped Scroll * s Drag Scroll Interpolator . get Interpolation ( time Ratio ) ) ; if ( value == NUM ) { return view Size Out Of Bounds > NUM ? NUM : - NUM ; } return value ; }
public String decode ( String encoded ) { Json Object object = new Json Object ( encoded ) ; Json Array headers = object . get Json Array ( STRING ) ; for ( Object header Obj : headers ) { Json Array header = ( Json Array ) header Obj ; String key = header . get String ( NUM ) ; String value = header . get String ( NUM ) ; if ( key . equals Ignore Case ( CONTENT TYPE ) && ( value . contains ( STRING ) || value . contains ( APPLICATION JSON ) ) ) { try { object . put ( STRING , new Json Object ( new String ( object . get Binary ( PAYLOAD ) , Charset . for Name ( UTF 8 ) ) ) ) ; } catch ( Decode Exception e ) { object . put ( STRING , new String ( object . get Binary ( PAYLOAD ) , Charset . for Name ( UTF 8 ) ) ) ; } object . remove ( PAYLOAD ) ; break ; } } return object . to String ( ) ; }
public static boolean substract Trading Fee ( Player player , int price ) { Big Decimal fee = calculate Fee ( player , price ) ; return player . drop ( STRING , fee . int Value ( ) ) ; }
String capitalise ( final String s ) { if ( s . length ( ) == NUM ) { return s ; } final String Buffer s1 = new String Buffer ( s ) ; if ( Character . is Lower Case ( s1 . char At ( NUM ) ) ) { s1 . set Char At ( NUM , Character . to Upper Case ( s1 . char At ( NUM ) ) ) ; } for ( int j = NUM ; j < s1 . length ( ) ; j ++ ) { if ( Character . is Upper Case ( s1 . char At ( j ) ) ) { s1 . set Char At ( j , Character . to Lower Case ( s1 . char At ( j ) ) ) ; } } return s1 . to String ( ) ; }
public void connect ( Socket Address endpoint , int timeout ) throws IO Exception { if ( endpoint == null ) throw new Illegal Argument Exception ( STRING ) ; if ( timeout < NUM ) throw new Illegal Argument Exception ( STRING ) ; if ( is Closed ( ) ) throw new Socket Exception ( STRING ) ; if ( ! old Impl && is Connected ( ) ) throw new Socket Exception ( STRING ) ; if ( ! ( endpoint instanceof Inet Socket Address ) ) throw new Illegal Argument Exception ( STRING ) ; Inet Socket Address epoint = ( Inet Socket Address ) endpoint ; Inet Address addr = epoint . get Address ( ) ; int port = epoint . get Port ( ) ; check Address ( addr , STRING ) ; Security Manager security = System . get Security Manager ( ) ; if ( security != null ) { if ( epoint . is Unresolved ( ) ) security . check Connect ( epoint . get Host Name ( ) , port ) ; else security . check Connect ( addr . get Host Address ( ) , port ) ; } if ( ! created ) create Impl ( BOOL ) ; if ( ! old Impl ) impl . connect ( epoint , timeout ) ; else if ( timeout == NUM ) { if ( epoint . is Unresolved ( ) ) impl . connect ( addr . get Host Name ( ) , port ) ; else impl . connect ( addr , port ) ; } else throw new Unsupported Operation Exception ( STRING ) ; connected = BOOL ; bound = BOOL ; }
Class < ? > load Class ( String class Name , URL [ ] urls ) throws Class Not Found Exception { URL Class Loader cl = new URL Class Loader ( urls ) ; Class < ? > test Class = cl . load Class ( class Name ) ; return test Class ; }
public void add Row ( final Member Table Row Data row Data ) { model . add ( row Data ) ; valid Rows . add ( BOOL ) ; fire Table Rows Inserted ( model . size ( ) - NUM , model . size ( ) - NUM ) ; }
private static void verify Conf Path Correctness ( ) { Global Conf . get Instance Identifier ( ) ; }
private static void verify Conf Path Correctness ( ) { Global Conf . get Instance Identifier ( ) ; }
boolean on Item Move ( final int from Pos , final int to Pos ) { if ( m Swapped Item == null ) { m Start Drag Pos = from Pos ; m Swapped Item = m Data . get ( from Pos ) ; } m Stop Drag Pos = to Pos ; final int jump Size = Math . abs ( to Pos - from Pos ) ; if ( jump Size > NUM ) { final int sign = Integer . signum ( to Pos - from Pos ) ; int start Pos = from Pos ; for ( int i = NUM ; i < jump Size ; i ++ ) { final int end Pos = start Pos + sign ; Collections . swap ( m Data , start Pos , end Pos ) ; start Pos += sign ; } } else { Collections . swap ( m Data , from Pos , to Pos ) ; } notify Item Moved ( from Pos , to Pos ) ; return BOOL ; }
public boolean has Periods ( ) { List < Dimensional Item Object > dim Opts = get Dimension Options ( PERIOD DIM ID ) ; List < Dimensional Item Object > filter Opts = get Filter Options ( PERIOD DIM ID ) ; return ! dim Opts . is Empty ( ) || ! filter Opts . is Empty ( ) ; }
public File Image Recorder ( File base path , int starting seq , String prefix , Recording Success Callback callback ) { super ( base path , starting seq , prefix , callback ) ; this . activated = BOOL ; executor = Executors . new Fixed Thread Pool ( MAX SAVING THREADS ) ; }
public List < Nce Consist Roster Entry > matching List ( String road Name , String road Number , String consist Number , String eng 1 Address , String eng 2 Address , String eng 3 Address , String eng 4 Address , String eng 5 Address , String eng 6 Address , String id ) { List < Nce Consist Roster Entry > l = new Array List < Nce Consist Roster Entry > ( ) ; for ( int i = NUM ; i < num Entries ( ) ; i ++ ) { if ( check Entry ( i , road Name , road Number , consist Number , eng 1 Address , eng 2 Address , eng 3 Address , eng 4 Address , eng 5 Address , eng 6 Address , id ) ) { l . add ( list . get ( i ) ) ; } } return l ; }
public List < Nce Consist Roster Entry > matching List ( String road Name , String road Number , String consist Number , String eng 1 Address , String eng 2 Address , String eng 3 Address , String eng 4 Address , String eng 5 Address , String eng 6 Address , String id ) { List < Nce Consist Roster Entry > l = new Array List < Nce Consist Roster Entry > ( ) ; for ( int i = NUM ; i < num Entries ( ) ; i ++ ) { if ( check Entry ( i , road Name , road Number , consist Number , eng 1 Address , eng 2 Address , eng 3 Address , eng 4 Address , eng 5 Address , eng 6 Address , id ) ) { l . add ( list . get ( i ) ) ; } } return l ; }
@ Override public boolean is Valid ( ) { return valid ; }
public static Blob to Blob ( Connection conn , Object value ) throws Page Exception , SQL Exception { if ( value instanceof Blob ) return ( Blob ) value ; if ( System Util . JAVA VERSION >= System Util . JAVA VERSION 1 6 ) { try { Blob blob = conn . create Blob ( ) ; blob . set Bytes ( NUM , Caster . to Binary ( value ) ) ; return blob ; } catch ( Throwable t ) { return Blob Impl . to Blob ( value ) ; } } if ( is Oracle ( conn ) ) { Blob blob = Oracle Blob . create Blob ( conn , Caster . to Binary ( value ) , null ) ; if ( blob != null ) return blob ; } return Blob Impl . to Blob ( value ) ; }
public static String convert Brackets To PTB Format ( String sentence ) { sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; return sentence ; }
public static String convert Brackets To PTB Format ( String sentence ) { sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; return sentence ; }
public static String convert Brackets To PTB Format ( String sentence ) { sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; return sentence ; }
public static String convert Brackets To PTB Format ( String sentence ) { sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; sentence = sentence . replace All ( STRING , STRING ) ; return sentence ; }
public void read Nodes ( final int [ ] columns Indices , final Buffered Reader reader ) throws IO Exception { String line = reader . read Line ( ) ; while ( line != null && line . length ( ) > NUM ) { final String [ ] parts = line . split ( STRING ) ; Node node = Network Utils . create Node ( Id . create Node Id ( parts [ columns Indices [ NUM ] ] ) ) ; node . set Coord ( new Coord ( Double . parse Double ( parts [ columns Indices [ NUM ] ] ) , Double . parse Double ( parts [ columns Indices [ NUM ] ] ) ) ) ; network . add Node ( node ) ; line = reader . read Line ( ) ; } }
private static String [ ] split Consolidated ( String s ) { if ( ( s . length ( ) % NUM ) != NUM ) { throw new Illegal Argument Exception ( STRING + s ) ; } int index = s . length ( ) / NUM ; return new String [ ] { s . substring ( NUM , index ) , s . substring ( index ) } ; }
private String diff lines To Chars Munge ( String text , List < String > line Array , Map < String , Integer > line Hash ) { int line Start = NUM ; int line End = - NUM ; String line ; String Builder chars = new String Builder ( ) ; while ( line End < text . length ( ) - NUM ) { line End = text . index Of ( STRING , line Start ) ; if ( line End == - NUM ) { line End = text . length ( ) - NUM ; } line = text . substring ( line Start , line End + NUM ) ; line Start = line End + NUM ; if ( line Hash . contains Key ( line ) ) { chars . append ( String . value Of ( ( char ) ( int ) line Hash . get ( line ) ) ) ; } else { line Array . add ( line ) ; line Hash . put ( line , line Array . size ( ) - NUM ) ; chars . append ( String . value Of ( ( char ) ( line Array . size ( ) - NUM ) ) ) ; } } return chars . to String ( ) ; }
private String diff lines To Chars Munge ( String text , List < String > line Array , Map < String , Integer > line Hash ) { int line Start = NUM ; int line End = - NUM ; String line ; String Builder chars = new String Builder ( ) ; while ( line End < text . length ( ) - NUM ) { line End = text . index Of ( STRING , line Start ) ; if ( line End == - NUM ) { line End = text . length ( ) - NUM ; } line = text . substring ( line Start , line End + NUM ) ; line Start = line End + NUM ; if ( line Hash . contains Key ( line ) ) { chars . append ( String . value Of ( ( char ) ( int ) line Hash . get ( line ) ) ) ; } else { line Array . add ( line ) ; line Hash . put ( line , line Array . size ( ) - NUM ) ; chars . append ( String . value Of ( ( char ) ( line Array . size ( ) - NUM ) ) ) ; } } return chars . to String ( ) ; }
private String diff lines To Chars Munge ( String text , List < String > line Array , Map < String , Integer > line Hash ) { int line Start = NUM ; int line End = - NUM ; String line ; String Builder chars = new String Builder ( ) ; while ( line End < text . length ( ) - NUM ) { line End = text . index Of ( STRING , line Start ) ; if ( line End == - NUM ) { line End = text . length ( ) - NUM ; } line = text . substring ( line Start , line End + NUM ) ; line Start = line End + NUM ; if ( line Hash . contains Key ( line ) ) { chars . append ( String . value Of ( ( char ) ( int ) line Hash . get ( line ) ) ) ; } else { line Array . add ( line ) ; line Hash . put ( line , line Array . size ( ) - NUM ) ; chars . append ( String . value Of ( ( char ) ( line Array . size ( ) - NUM ) ) ) ; } } return chars . to String ( ) ; }
protected void filter Members ( Collection < Internal Distributed Member > mbrs , Set < Internal Distributed Member > matching Members , short request Type ) { Set < Internal Distributed Member > requests = get Pending Request I Ds ( request Type ) ; if ( ! requests . is Empty ( ) ) { logger . debug ( STRING + requests . size ( ) + STRING + request Type ) ; Iterator < Internal Distributed Member > itr = requests . iterator ( ) ; while ( itr . has Next ( ) ) { Internal Distributed Member member ID = itr . next ( ) ; if ( mbrs . contains ( member ID ) ) { test Flag For Removal Request = BOOL ; matching Members . add ( member ID ) ; } } } }
protected void filter Members ( Collection < Internal Distributed Member > mbrs , Set < Internal Distributed Member > matching Members , short request Type ) { Set < Internal Distributed Member > requests = get Pending Request I Ds ( request Type ) ; if ( ! requests . is Empty ( ) ) { logger . debug ( STRING + requests . size ( ) + STRING + request Type ) ; Iterator < Internal Distributed Member > itr = requests . iterator ( ) ; while ( itr . has Next ( ) ) { Internal Distributed Member member ID = itr . next ( ) ; if ( mbrs . contains ( member ID ) ) { test Flag For Removal Request = BOOL ; matching Members . add ( member ID ) ; } } } }
private Set < Storage Port > reduce Storage Port Map ( Map < String , Set < Storage Port > > map ) { Set < Storage Port > set = new Hash Set < Storage Port > ( ) ; for ( Set < Storage Port > a Set : map . values ( ) ) { set . add All ( a Set ) ; } return set ; }
private Set < Storage Port > reduce Storage Port Map ( Map < String , Set < Storage Port > > map ) { Set < Storage Port > set = new Hash Set < Storage Port > ( ) ; for ( Set < Storage Port > a Set : map . values ( ) ) { set . add All ( a Set ) ; } return set ; }
private Set < Storage Port > reduce Storage Port Map ( Map < String , Set < Storage Port > > map ) { Set < Storage Port > set = new Hash Set < Storage Port > ( ) ; for ( Set < Storage Port > a Set : map . values ( ) ) { set . add All ( a Set ) ; } return set ; }
public void add Set ( String name , Tuple Set set ) { if ( has Set ( name ) ) { throw new Illegal Argument Exception ( STRING + name ) ; } m map . put ( name , set ) ; m sets . add ( set ) ; m count += set . get Tuple Count ( ) ; if ( m lstnr != null ) set . add Tuple Set Listener ( m lstnr ) ; }
public double percentage ( Constant v ) { if ( pcts . contains Key ( v ) ) return pcts . get ( v ) ; Sorted Set < Constant > sorted = values ( ) ; if ( v . compare To ( sorted . first ( ) ) < NUM ) return NUM ; Constant prev = null ; for ( Constant pct : sorted ) { if ( prev != null && v . compare To ( prev ) >= NUM && v . compare To ( pct ) < NUM ) return pcts . get ( prev ) ; prev = pct ; } return pcts . get ( sorted . last ( ) ) ; }
private String create License Key ( final String license Key ) { if ( validate License Key ( license Key ) ) { String Builder sb = new String Builder ( ) ; for ( int i : LICENSE CHARS ) { sb . append ( license Key . char At ( i ) ) ; } return sb . to String ( ) ; } return STRING ; }
protected void read Optional Measure ( Byte Buffer buffer ) { if ( buffer . has Remaining ( ) && ( buffer . limit ( ) - buffer . position ( ) ) >= NUM ) { double [ ] m Array = Shapefile Utils . read Double Array ( buffer , NUM ) ; this . m = m Array [ NUM ] ; } }
public final boolean check trace ( Polyline p polyline , int p half width , int p layer , Net Nos List p net no arr , int p clearance class no , int p max recursion depth , int p max via recursion depth , int p max spring over recursion depth ) { Awtree Shape Search search tree = search tree manager . get default tree ( ) ; int compensated half width = p half width + search tree . get clearance compensation ( p clearance class no , p layer ) ; Array List < Shape Tile > trace shapes = p polyline . offset shapes ( compensated half width , NUM , p polyline . corner count ( ) ) ; for ( int index = NUM ; index < trace shapes . size ( ) ; ++ index ) { Shape Tile curr trace shape = trace shapes . get ( index ) ; Brd From Side from side = new Brd From Side ( p polyline , index + NUM , curr trace shape ) ; boolean check shove ok = shove trace algo . shove trace check ( curr trace shape , from side , null , p layer , p net no arr , p clearance class no , p max recursion depth , p max via recursion depth , p max spring over recursion depth , null ) ; if ( ! check shove ok ) return BOOL ; } return BOOL ; }
public void add Method ( Method Info minfo ) throws Duplicate Member Exception { test Existing Method ( minfo ) ; methods . add ( minfo ) ; }
public int read ( byte [ ] b , int off , int len ) throws IO Exception { if ( closed ) { throw new IO Exception ( STRING ) ; } if ( eof ) { return - NUM ; } if ( pos >= chunk Size ) { next Chunk ( ) ; if ( eof ) { return - NUM ; } } len = Math . min ( len , chunk Size - pos ) ; int count = in . read ( b , off , len ) ; pos += count ; return count ; }
public static Annotation Mirror build Anno Mirror With No Prefix ( final Processing Environment env , final Class < ? extends Annotation > anno Class ) { if ( env == null || anno Class == null ) { return null ; } return Annotation Utils . from Class ( env . get Element Utils ( ) , anno Class ) ; }
public static Annotation Mirror build Anno Mirror With No Prefix ( final Processing Environment env , final Class < ? extends Annotation > anno Class ) { if ( env == null || anno Class == null ) { return null ; } return Annotation Utils . from Class ( env . get Element Utils ( ) , anno Class ) ; }
@ Override public void logout ( Http Servlet Request request , Http Servlet Response response , Authentication authentication ) { String remember Me Cookie = extract Remember Me Cookie ( request ) ; if ( remember Me Cookie != null && remember Me Cookie . length ( ) != NUM ) { try { String [ ] cookie Tokens = decode Cookie ( remember Me Cookie ) ; if ( cookie Tokens . length != NUM ) { throw new Invalid Cookie Exception ( STRING + NUM + STRING + Arrays . as List ( cookie Tokens ) + STRING ) ; } persistent Token Repository . delete By Id ( cookie Tokens [ NUM ] ) ; } catch ( Invalid Cookie Exception ice ) { log . info ( STRING ) ; } catch ( Remember Me Authentication Exception rmae ) { log . debug ( STRING ) ; } } super . logout ( request , response , authentication ) ; }
@ Override public void logout ( Http Servlet Request request , Http Servlet Response response , Authentication authentication ) { String remember Me Cookie = extract Remember Me Cookie ( request ) ; if ( remember Me Cookie != null && remember Me Cookie . length ( ) != NUM ) { try { String [ ] cookie Tokens = decode Cookie ( remember Me Cookie ) ; if ( cookie Tokens . length != NUM ) { throw new Invalid Cookie Exception ( STRING + NUM + STRING + Arrays . as List ( cookie Tokens ) + STRING ) ; } persistent Token Repository . delete By Id ( cookie Tokens [ NUM ] ) ; } catch ( Invalid Cookie Exception ice ) { log . info ( STRING ) ; } catch ( Remember Me Authentication Exception rmae ) { log . debug ( STRING ) ; } } super . logout ( request , response , authentication ) ; }
@ Override public void logout ( Http Servlet Request request , Http Servlet Response response , Authentication authentication ) { String remember Me Cookie = extract Remember Me Cookie ( request ) ; if ( remember Me Cookie != null && remember Me Cookie . length ( ) != NUM ) { try { String [ ] cookie Tokens = decode Cookie ( remember Me Cookie ) ; if ( cookie Tokens . length != NUM ) { throw new Invalid Cookie Exception ( STRING + NUM + STRING + Arrays . as List ( cookie Tokens ) + STRING ) ; } persistent Token Repository . delete By Id ( cookie Tokens [ NUM ] ) ; } catch ( Invalid Cookie Exception ice ) { log . info ( STRING ) ; } catch ( Remember Me Authentication Exception rmae ) { log . debug ( STRING ) ; } } super . logout ( request , response , authentication ) ; }
@ Override public void logout ( Http Servlet Request request , Http Servlet Response response , Authentication authentication ) { String remember Me Cookie = extract Remember Me Cookie ( request ) ; if ( remember Me Cookie != null && remember Me Cookie . length ( ) != NUM ) { try { String [ ] cookie Tokens = decode Cookie ( remember Me Cookie ) ; if ( cookie Tokens . length != NUM ) { throw new Invalid Cookie Exception ( STRING + NUM + STRING + Arrays . as List ( cookie Tokens ) + STRING ) ; } persistent Token Repository . delete By Id ( cookie Tokens [ NUM ] ) ; } catch ( Invalid Cookie Exception ice ) { log . info ( STRING ) ; } catch ( Remember Me Authentication Exception rmae ) { log . debug ( STRING ) ; } } super . logout ( request , response , authentication ) ; }
public Set < String > key Names ( String prefix ) { Set < String > keys = key Names ( ) ; Hash Set < String > subset = new Hash Set < String > ( ) ; for ( String key : keys ) { if ( key != null && key . starts With ( prefix ) ) subset . add ( key ) ; } return subset ; }
public Set < String > key Names ( String prefix ) { Set < String > keys = key Names ( ) ; Hash Set < String > subset = new Hash Set < String > ( ) ; for ( String key : keys ) { if ( key != null && key . starts With ( prefix ) ) subset . add ( key ) ; } return subset ; }
public boolean kill Job ( String job Id File ) { List < String > job Id File Content = read From File ( job Id File ) ; if ( job Id File Content . size ( ) > NUM ) { String [ ] slurm Cmd = new String [ ] { STRING , job Id File Content . get ( NUM ) } ; return run Process ( null , slurm Cmd , new String Builder ( ) , new String Builder ( ) ) ; } else { LOG . log ( Level . SEVERE , STRING , job Id File ) ; return BOOL ; } }
public boolean kill Job ( String job Id File ) { List < String > job Id File Content = read From File ( job Id File ) ; if ( job Id File Content . size ( ) > NUM ) { String [ ] slurm Cmd = new String [ ] { STRING , job Id File Content . get ( NUM ) } ; return run Process ( null , slurm Cmd , new String Builder ( ) , new String Builder ( ) ) ; } else { LOG . log ( Level . SEVERE , STRING , job Id File ) ; return BOOL ; } }
public boolean kill Job ( String job Id File ) { List < String > job Id File Content = read From File ( job Id File ) ; if ( job Id File Content . size ( ) > NUM ) { String [ ] slurm Cmd = new String [ ] { STRING , job Id File Content . get ( NUM ) } ; return run Process ( null , slurm Cmd , new String Builder ( ) , new String Builder ( ) ) ; } else { LOG . log ( Level . SEVERE , STRING , job Id File ) ; return BOOL ; } }
public boolean kill Job ( String job Id File ) { List < String > job Id File Content = read From File ( job Id File ) ; if ( job Id File Content . size ( ) > NUM ) { String [ ] slurm Cmd = new String [ ] { STRING , job Id File Content . get ( NUM ) } ; return run Process ( null , slurm Cmd , new String Builder ( ) , new String Builder ( ) ) ; } else { LOG . log ( Level . SEVERE , STRING , job Id File ) ; return BOOL ; } }
public boolean kill Job ( String job Id File ) { List < String > job Id File Content = read From File ( job Id File ) ; if ( job Id File Content . size ( ) > NUM ) { String [ ] slurm Cmd = new String [ ] { STRING , job Id File Content . get ( NUM ) } ; return run Process ( null , slurm Cmd , new String Builder ( ) , new String Builder ( ) ) ; } else { LOG . log ( Level . SEVERE , STRING , job Id File ) ; return BOOL ; } }
public boolean kill Job ( String job Id File ) { List < String > job Id File Content = read From File ( job Id File ) ; if ( job Id File Content . size ( ) > NUM ) { String [ ] slurm Cmd = new String [ ] { STRING , job Id File Content . get ( NUM ) } ; return run Process ( null , slurm Cmd , new String Builder ( ) , new String Builder ( ) ) ; } else { LOG . log ( Level . SEVERE , STRING , job Id File ) ; return BOOL ; } }
protected static void check Get And Destroy ( ) { assert Null ( TX Lock Service . get DTLS ( ) ) ; TX Lock Service dtls = TX Lock Service . create DTLS ( ) ; assert Not Null ( dtls ) ; assert Equals ( BOOL , dtls == TX Lock Service . get DTLS ( ) ) ; assert Equals ( BOOL , dtls . is Destroyed ( ) ) ; TX Lock Service . destroy Services ( ) ; assert Equals ( BOOL , dtls . is Destroyed ( ) ) ; assert Null ( TX Lock Service . get DTLS ( ) ) ; dtls = TX Lock Service . create DTLS ( ) ; assert Not Null ( dtls ) ; assert Equals ( BOOL , dtls == TX Lock Service . get DTLS ( ) ) ; assert Equals ( BOOL , dtls . is Destroyed ( ) ) ; }
public boolean matches ( Grid Cache Version ver , UUID node Id , long thread Id ) { return ver . equals ( this . ver ) || ( node Id . equals ( this . node Id ) && thread Id == this . thread Id ) ; }
public boolean matches ( Grid Cache Version ver , UUID node Id , long thread Id ) { return ver . equals ( this . ver ) || ( node Id . equals ( this . node Id ) && thread Id == this . thread Id ) ; }
boolean is Local Authentication Valid ( ) { if ( local Private Key != null ) { try { local Private Key . get Algorithm ( ) ; } catch ( Exception e ) { invalidate ( ) ; return BOOL ; } } return BOOL ; }
boolean is Local Authentication Valid ( ) { if ( local Private Key != null ) { try { local Private Key . get Algorithm ( ) ; } catch ( Exception e ) { invalidate ( ) ; return BOOL ; } } return BOOL ; }
public File suffixed File ( String suffix , boolean gzip ) { return new File ( m Base File . get Parent File ( ) , m Base File . get Name ( ) + suffix + m Extension + ( gzip ? File Utils . GZ SUFFIX : STRING ) ) ; }
public File suffixed File ( String suffix , boolean gzip ) { return new File ( m Base File . get Parent File ( ) , m Base File . get Name ( ) + suffix + m Extension + ( gzip ? File Utils . GZ SUFFIX : STRING ) ) ; }
public static Timestamp to Timestamp ( String string ) { if ( string == null ) return null ; else try { return Timestamp . value Of ( string ) ; } catch ( Throwable t ) { return null ; } }
public void flush Disk Cache ( ) { synchronized ( m Disk Cache Lock ) { long now = System . current Time Millis ( ) ; if ( now - NUM < m Last Flush Time ) { return ; } m Last Flush Time = now ; if ( m Disk Lru Cache != null ) { try { m Disk Lru Cache . flush ( ) ; if ( DEBUG ) { Log . d ( TAG , STRING ) ; } } catch ( IO Exception e ) { Log . e ( TAG , STRING + e ) ; } } } }
public boolean add ( Accessible Relation relation ) { if ( relations == null ) { relations = new Vector ( ) ; } Accessible Relation existing Relation = get ( relation . get Key ( ) ) ; if ( existing Relation == null ) { relations . add Element ( relation ) ; return BOOL ; } else { Object [ ] existing Target = existing Relation . get Target ( ) ; Object [ ] new Target = relation . get Target ( ) ; int merged Length = existing Target . length + new Target . length ; Object [ ] merged Target = new Object [ merged Length ] ; for ( int i = NUM ; i < existing Target . length ; i ++ ) { merged Target [ i ] = existing Target [ i ] ; } for ( int i = existing Target . length , j = NUM ; i < merged Length ; i ++ , j ++ ) { merged Target [ i ] = new Target [ j ] ; } existing Relation . set Target ( merged Target ) ; } return BOOL ; }
private void update User ( User user , boolean refresh Avatar ) { this . user = user ; if ( avatar == null ) { return ; } if ( avatar . get Drawable ( ) == null || refresh Avatar ) { load Avatar ( ! refresh Avatar ) ; } if ( user . get Points ( ) != null ) { long points = user . get Points ( ) ; Level level = new Level ( points ) ; level Text . set Text ( String . value Of ( level . get Level ( ) ) ) ; } follow View . set User ( user , user Handler , client ) ; decide Edit Links ( ) ; }
public static Future < ? > submit ( Runnable task ) { return THREAD POOL . submit ( task ) ; }
public static Future < ? > submit ( Runnable task ) { return THREAD POOL . submit ( task ) ; }
public void remove Immunity ( Status Type status Type ) { RP Entity entity = entity Ref . get ( ) ; if ( entity == null ) { return ; } immunities . remove ( status Type ) ; entity . send Private Text ( STRING + status Type . get Name ( ) + STRING ) ; }
private boolean region Dialing From Matches Number ( Phone Number number , String region Dialing From ) { List < String > region Codes = get Region Codes For Country Code ( number . get Country Code ( ) ) ; return region Codes . contains ( region Dialing From ) ; }
private boolean region Dialing From Matches Number ( Phone Number number , String region Dialing From ) { List < String > region Codes = get Region Codes For Country Code ( number . get Country Code ( ) ) ; return region Codes . contains ( region Dialing From ) ; }
private boolean region Dialing From Matches Number ( Phone Number number , String region Dialing From ) { List < String > region Codes = get Region Codes For Country Code ( number . get Country Code ( ) ) ; return region Codes . contains ( region Dialing From ) ; }
@ Override public void make Immutable ( ) { if ( is Mutable ) { if ( authn Statements != null ) { int length = authn Statements . size ( ) ; for ( int i = NUM ; i < length ; i ++ ) { Authn Statement authn = ( Authn Statement ) authn Statements . get ( i ) ; authn . make Immutable ( ) ; } authn Statements = Collections . unmodifiable List ( authn Statements ) ; } if ( authz Decision Statements != null ) { int length = authz Decision Statements . size ( ) ; for ( int i = NUM ; i < length ; i ++ ) { Authz Decision Statement authz = ( Authz Decision Statement ) authz Decision Statements . get ( i ) ; authz . make Immutable ( ) ; } authz Decision Statements = Collections . unmodifiable List ( authz Decision Statements ) ; } if ( attribute Statements != null ) { int length = attribute Statements . size ( ) ; for ( int i = NUM ; i < length ; i ++ ) { Attribute Statement attr = ( Attribute Statement ) attribute Statements . get ( i ) ; attr . make Immutable ( ) ; } attribute Statements = Collections . unmodifiable List ( attribute Statements ) ; } if ( statements != null ) { statements = Collections . unmodifiable List ( statements ) ; } if ( conditions != null ) { conditions . make Immutable ( ) ; } if ( issuer != null ) { issuer . make Immutable ( ) ; } if ( subject != null ) { subject . make Immutable ( ) ; } if ( advice != null ) { advice . make Immutable ( ) ; } is Mutable = BOOL ; } }
void render Shadow Map ( ) { gl Use Program ( shadow Program ) ; gl Uniform Matrix 4 fv ( shadow Program VP Uniform , BOOL , light . get ( matrix Buffer ) ) ; gl Bind Framebuffer ( GL FRAMEBUFFER , fbo ) ; gl Viewport ( NUM , NUM , shadow Map Size , shadow Map Size ) ; gl Clear ( GL DEPTH BUFFER BIT ) ; gl Bind Vertex Array ( vao ) ; gl Draw Arrays ( GL TRIANGLES , NUM , NUM * NUM * boxes . length ) ; gl Bind Vertex Array ( NUM ) ; gl Bind Framebuffer ( GL FRAMEBUFFER , NUM ) ; gl Use Program ( NUM ) ; }
protected void remove Columns ( Collection < String > remove Column Names , String table Name ) { if ( remove Column Names != null && ! remove Column Names . is Empty ( ) ) { execute ( get Remove Column SQ Ls ( remove Column Names , table Name ) , m Db ) ; } }
protected void remove Columns ( Collection < String > remove Column Names , String table Name ) { if ( remove Column Names != null && ! remove Column Names . is Empty ( ) ) { execute ( get Remove Column SQ Ls ( remove Column Names , table Name ) , m Db ) ; } }
protected void remove Columns ( Collection < String > remove Column Names , String table Name ) { if ( remove Column Names != null && ! remove Column Names . is Empty ( ) ) { execute ( get Remove Column SQ Ls ( remove Column Names , table Name ) , m Db ) ; } }
protected void remove Columns ( Collection < String > remove Column Names , String table Name ) { if ( remove Column Names != null && ! remove Column Names . is Empty ( ) ) { execute ( get Remove Column SQ Ls ( remove Column Names , table Name ) , m Db ) ; } }
protected void remove Columns ( Collection < String > remove Column Names , String table Name ) { if ( remove Column Names != null && ! remove Column Names . is Empty ( ) ) { execute ( get Remove Column SQ Ls ( remove Column Names , table Name ) , m Db ) ; } }
public void update Kernel Combo Box ( J Combo Box < String > box ) { box . remove All Items ( ) ; box . add Item ( NONE ) ; for ( String kernel Name : get Kernel Name List ( ) ) { box . add Item ( kernel Name ) ; } }
@ Override public < U extends Comparable < ? super U > > Completable Future < Optional < T > > max By ( final Function < ? super T , ? extends U > function ) { return Completable Future . supply Async ( null ) ; }
@ Override public < U extends Comparable < ? super U > > Completable Future < Optional < T > > max By ( final Function < ? super T , ? extends U > function ) { return Completable Future . supply Async ( null ) ; }
@ Override public < U extends Comparable < ? super U > > Completable Future < Optional < T > > max By ( final Function < ? super T , ? extends U > function ) { return Completable Future . supply Async ( null ) ; }
public void output ( Print Writer out ) { Element element = null ; Enumeration < Element > data = ec . elements ( ) ; while ( data . has More Elements ( ) ) { element = data . next Element ( ) ; element . output ( out ) ; } }
@ Data Provider ( name = STRING ) public Object [ ] [ ] class Provider ( ) { return TESTING CLASSES ; }
public final int [ ] hash Signature ( final int [ ] signature ) { int [ ] hash = new int [ stages ] ; int rows = signature . length / stages ; for ( int i = NUM ; i < signature . length ; i ++ ) { int stage = Math . min ( i / rows , stages - NUM ) ; hash [ stage ] = ( int ) ( ( hash [ stage ] + ( long ) signature [ i ] * LARGE PRIME ) % buckets ) ; } return hash ; }
public String make String Literal SQ ( String value ) { if ( value == null ) { return this . literal SQ String Default ; } else if ( value . is Empty ( ) ) { return STRING ; } else if ( ! value . contains ( STRING ) ) { return STRING + value + STRING ; } else { return STRING + make String Value SQ ( value ) + STRING ; } }
public void write ( char [ ] buf ) throws IO Exception { if ( writer != null ) { writer . write ( buf ) ; } else { write ( buf , NUM , buf . length ) ; } }
public void write ( char [ ] buf ) throws IO Exception { if ( writer != null ) { writer . write ( buf ) ; } else { write ( buf , NUM , buf . length ) ; } }
public void write ( char [ ] buf ) throws IO Exception { if ( writer != null ) { writer . write ( buf ) ; } else { write ( buf , NUM , buf . length ) ; } }
public void add Metadata ( String name , String value ) { if ( ( name != null ) && ( value != null ) ) { Metadata m = new Metadata ( name , value ) ; metadata . add ( m ) ; } }
public String client App Id ( ) { return ( String ) http Request . get Attribute ( Authentication Filter . Authenticated Role Attribute Name ) ; }
public void test multiple Writes ( ) { final I Raw Store store = get Store ( ) ; try { final int limit = NUM ; final long [ ] addrs = new long [ limit ] ; final byte [ ] [ ] records = new byte [ limit ] [ ] ; for ( int i = NUM ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( NUM ) + NUM ] ; r . next Bytes ( expected ) ; final Byte Buffer tmp = Byte Buffer . wrap ( expected ) ; final long addr = store . write ( tmp ) ; assert Equals ( expected . length , tmp . position ( ) ) ; assert Equals ( tmp . position ( ) , tmp . limit ( ) ) ; assert Equals ( expected , store . read ( addr ) ) ; addrs [ i ] = addr ; records [ i ] = expected ; } final int [ ] order = get Random Order ( limit ) ; for ( int i = NUM ; i < limit ; i ++ ) { final long addr = addrs [ order [ i ] ] ; final byte [ ] expected = records [ order [ i ] ] ; assert Equals ( expected , store . read ( addr ) ) ; } } finally { store . destroy ( ) ; } }
public void test multiple Writes ( ) { final I Raw Store store = get Store ( ) ; try { final int limit = NUM ; final long [ ] addrs = new long [ limit ] ; final byte [ ] [ ] records = new byte [ limit ] [ ] ; for ( int i = NUM ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( NUM ) + NUM ] ; r . next Bytes ( expected ) ; final Byte Buffer tmp = Byte Buffer . wrap ( expected ) ; final long addr = store . write ( tmp ) ; assert Equals ( expected . length , tmp . position ( ) ) ; assert Equals ( tmp . position ( ) , tmp . limit ( ) ) ; assert Equals ( expected , store . read ( addr ) ) ; addrs [ i ] = addr ; records [ i ] = expected ; } final int [ ] order = get Random Order ( limit ) ; for ( int i = NUM ; i < limit ; i ++ ) { final long addr = addrs [ order [ i ] ] ; final byte [ ] expected = records [ order [ i ] ] ; assert Equals ( expected , store . read ( addr ) ) ; } } finally { store . destroy ( ) ; } }
public void test multiple Writes ( ) { final I Raw Store store = get Store ( ) ; try { final int limit = NUM ; final long [ ] addrs = new long [ limit ] ; final byte [ ] [ ] records = new byte [ limit ] [ ] ; for ( int i = NUM ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( NUM ) + NUM ] ; r . next Bytes ( expected ) ; final Byte Buffer tmp = Byte Buffer . wrap ( expected ) ; final long addr = store . write ( tmp ) ; assert Equals ( expected . length , tmp . position ( ) ) ; assert Equals ( tmp . position ( ) , tmp . limit ( ) ) ; assert Equals ( expected , store . read ( addr ) ) ; addrs [ i ] = addr ; records [ i ] = expected ; } final int [ ] order = get Random Order ( limit ) ; for ( int i = NUM ; i < limit ; i ++ ) { final long addr = addrs [ order [ i ] ] ; final byte [ ] expected = records [ order [ i ] ] ; assert Equals ( expected , store . read ( addr ) ) ; } } finally { store . destroy ( ) ; } }
public void test multiple Writes ( ) { final I Raw Store store = get Store ( ) ; try { final int limit = NUM ; final long [ ] addrs = new long [ limit ] ; final byte [ ] [ ] records = new byte [ limit ] [ ] ; for ( int i = NUM ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( NUM ) + NUM ] ; r . next Bytes ( expected ) ; final Byte Buffer tmp = Byte Buffer . wrap ( expected ) ; final long addr = store . write ( tmp ) ; assert Equals ( expected . length , tmp . position ( ) ) ; assert Equals ( tmp . position ( ) , tmp . limit ( ) ) ; assert Equals ( expected , store . read ( addr ) ) ; addrs [ i ] = addr ; records [ i ] = expected ; } final int [ ] order = get Random Order ( limit ) ; for ( int i = NUM ; i < limit ; i ++ ) { final long addr = addrs [ order [ i ] ] ; final byte [ ] expected = records [ order [ i ] ] ; assert Equals ( expected , store . read ( addr ) ) ; } } finally { store . destroy ( ) ; } }
public void test multiple Writes ( ) { final I Raw Store store = get Store ( ) ; try { final int limit = NUM ; final long [ ] addrs = new long [ limit ] ; final byte [ ] [ ] records = new byte [ limit ] [ ] ; for ( int i = NUM ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( NUM ) + NUM ] ; r . next Bytes ( expected ) ; final Byte Buffer tmp = Byte Buffer . wrap ( expected ) ; final long addr = store . write ( tmp ) ; assert Equals ( expected . length , tmp . position ( ) ) ; assert Equals ( tmp . position ( ) , tmp . limit ( ) ) ; assert Equals ( expected , store . read ( addr ) ) ; addrs [ i ] = addr ; records [ i ] = expected ; } final int [ ] order = get Random Order ( limit ) ; for ( int i = NUM ; i < limit ; i ++ ) { final long addr = addrs [ order [ i ] ] ; final byte [ ] expected = records [ order [ i ] ] ; assert Equals ( expected , store . read ( addr ) ) ; } } finally { store . destroy ( ) ; } }
public void test multiple Writes ( ) { final I Raw Store store = get Store ( ) ; try { final int limit = NUM ; final long [ ] addrs = new long [ limit ] ; final byte [ ] [ ] records = new byte [ limit ] [ ] ; for ( int i = NUM ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( NUM ) + NUM ] ; r . next Bytes ( expected ) ; final Byte Buffer tmp = Byte Buffer . wrap ( expected ) ; final long addr = store . write ( tmp ) ; assert Equals ( expected . length , tmp . position ( ) ) ; assert Equals ( tmp . position ( ) , tmp . limit ( ) ) ; assert Equals ( expected , store . read ( addr ) ) ; addrs [ i ] = addr ; records [ i ] = expected ; } final int [ ] order = get Random Order ( limit ) ; for ( int i = NUM ; i < limit ; i ++ ) { final long addr = addrs [ order [ i ] ] ; final byte [ ] expected = records [ order [ i ] ] ; assert Equals ( expected , store . read ( addr ) ) ; } } finally { store . destroy ( ) ; } }
public void add Comment ( Comment comment ) { assert Not Null ( comment ) ; if ( comments == null ) { comments = new Tree Set < Comment > ( new Ast Node . Position Comparator ( ) ) ; } comments . add ( comment ) ; comment . set Parent ( this ) ; }
synchronized public Event end ( ) { if ( complete ) { throw new Illegal State Exception ( ) ; } complete = BOOL ; end Time = System . current Time Millis ( ) ; if ( start Time == NUM ) { start Time = end Time ; } try { send Event ( ) ; } catch ( Throwable t ) { log . warn ( t ) ; } return this ; }
public void add ( XMP Path Segment segment ) { segments . add ( segment ) ; }
protected void init ( ) { if ( ! is Init ) { Terminal [ ] terminals = Reflection . get Terminals ( ) ; Non Terminal [ ] non Terminals = Reflection . get Non Terminals ( ) ; symbol Value Classes = Reflection . get Symbol Value Classes ( terminals , non Terminals ) ; is Init = BOOL ; } }
public void enable Input Methods ( boolean enable ) { if ( enable ) { if ( ( event Mask & AWT Event . INPUT METHODS ENABLED MASK ) != NUM ) return ; if ( is Focus Owner ( ) ) { Input Context input Context = get Input Context ( ) ; if ( input Context != null ) { Focus Event focus Gained Event = new Focus Event ( this , Focus Event . FOCUS GAINED ) ; input Context . dispatch Event ( focus Gained Event ) ; } } event Mask |= AWT Event . INPUT METHODS ENABLED MASK ; } else { if ( ( event Mask & AWT Event . INPUT METHODS ENABLED MASK ) != NUM ) { Input Context input Context = get Input Context ( ) ; if ( input Context != null ) { input Context . end Composition ( ) ; input Context . remove Notify ( this ) ; } } event Mask &= ~ AWT Event . INPUT METHODS ENABLED MASK ; } }
private void execute Move ( @ Non Null Deco Event event ) { if ( ( event . get Event Type ( ) != Deco Event . Event Type . EVENT MOVE ) && ( event . get Event Type ( ) != Deco Event . Event Type . EVENT COLOR CHANGE ) ) { return ; } if ( m Chart Series != null ) { if ( m Chart Series . size ( ) <= event . get Index Position ( ) ) { throw new Illegal Argument Exception ( STRING + event . get Index Position ( ) + STRING + m Chart Series . size ( ) + STRING ) ; } final int index = event . get Index Position ( ) ; if ( index >= NUM && index < m Chart Series . size ( ) ) { Chart Series item = m Chart Series . get ( event . get Index Position ( ) ) ; if ( event . get Event Type ( ) == Deco Event . Event Type . EVENT COLOR CHANGE ) { item . start Animate Color Change ( event ) ; } else { item . start Animate Move ( event ) ; } } else { Log . e ( TAG , STRING + index + STRING + m Chart Series . size ( ) ) ; } } }
public static String read Line ( Input Stream in , String charset ) throws IO Exception { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; while ( BOOL ) { int b = in . read ( ) ; if ( b == - NUM ) { if ( baos . size ( ) == NUM ) { return null ; } else { break ; } } if ( b == STRING ) { break ; } if ( b != STRING ) { baos . write ( b ) ; continue ; } int b2 = in . read ( ) ; if ( b2 == - NUM ) { baos . write ( b ) ; break ; } if ( b2 == STRING ) { break ; } baos . write ( b ) ; baos . write ( b2 ) ; } return baos . to String ( charset ) ; }
@ Rpc Method public void copy Image ( String image Id , String source , String destination , Async Method Callback < Host . Async Client . copy image call > handler ) throws Rpc Exception { ensure Client ( ) ; Copy Image Request copy Image Request = new Copy Image Request ( ) ; copy Image Request . set Source ( Util . construct Image ( source , image Id ) ) ; copy Image Request . set Destination ( Util . construct Image ( destination , image Id ) ) ; logger . info ( STRING , get Host Ip ( ) , copy Image Request ) ; try { client Proxy . copy image ( copy Image Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Rpc Method public void copy Image ( String image Id , String source , String destination , Async Method Callback < Host . Async Client . copy image call > handler ) throws Rpc Exception { ensure Client ( ) ; Copy Image Request copy Image Request = new Copy Image Request ( ) ; copy Image Request . set Source ( Util . construct Image ( source , image Id ) ) ; copy Image Request . set Destination ( Util . construct Image ( destination , image Id ) ) ; logger . info ( STRING , get Host Ip ( ) , copy Image Request ) ; try { client Proxy . copy image ( copy Image Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Rpc Method public void copy Image ( String image Id , String source , String destination , Async Method Callback < Host . Async Client . copy image call > handler ) throws Rpc Exception { ensure Client ( ) ; Copy Image Request copy Image Request = new Copy Image Request ( ) ; copy Image Request . set Source ( Util . construct Image ( source , image Id ) ) ; copy Image Request . set Destination ( Util . construct Image ( destination , image Id ) ) ; logger . info ( STRING , get Host Ip ( ) , copy Image Request ) ; try { client Proxy . copy image ( copy Image Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Rpc Method public void copy Image ( String image Id , String source , String destination , Async Method Callback < Host . Async Client . copy image call > handler ) throws Rpc Exception { ensure Client ( ) ; Copy Image Request copy Image Request = new Copy Image Request ( ) ; copy Image Request . set Source ( Util . construct Image ( source , image Id ) ) ; copy Image Request . set Destination ( Util . construct Image ( destination , image Id ) ) ; logger . info ( STRING , get Host Ip ( ) , copy Image Request ) ; try { client Proxy . copy image ( copy Image Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
public I Resource [ ] prompt For Multiple ( ) throws Interrupted Exception { List target Resources = new Array List ( ) ; for ( int i = NUM ; i < resources . length ; i ++ ) { I Resource resource = resources [ i ] ; if ( condition . needs Prompt ( resource ) && confirm Overwrite ) { if ( confirm Overwrite ( condition . prompt Message ( resource ) ) ) { target Resources . add ( resource ) ; } } else { target Resources . add ( resource ) ; } } return ( I Resource [ ] ) target Resources . to Array ( new I Resource [ target Resources . size ( ) ] ) ; }
public I Resource [ ] prompt For Multiple ( ) throws Interrupted Exception { List target Resources = new Array List ( ) ; for ( int i = NUM ; i < resources . length ; i ++ ) { I Resource resource = resources [ i ] ; if ( condition . needs Prompt ( resource ) && confirm Overwrite ) { if ( confirm Overwrite ( condition . prompt Message ( resource ) ) ) { target Resources . add ( resource ) ; } } else { target Resources . add ( resource ) ; } } return ( I Resource [ ] ) target Resources . to Array ( new I Resource [ target Resources . size ( ) ] ) ; }
public void send Message ( String type , String key , String value ) { if ( type . equals ( SET CONFIG TYPE ) ) { send Set Config Message ( key , value ) ; } else { throw new Illegal Argument Exception ( STRING + SET CONFIG TYPE + STRING ) ; } }
public void send Message ( String type , String key , String value ) { if ( type . equals ( SET CONFIG TYPE ) ) { send Set Config Message ( key , value ) ; } else { throw new Illegal Argument Exception ( STRING + SET CONFIG TYPE + STRING ) ; } }
public void send Message ( String type , String key , String value ) { if ( type . equals ( SET CONFIG TYPE ) ) { send Set Config Message ( key , value ) ; } else { throw new Illegal Argument Exception ( STRING + SET CONFIG TYPE + STRING ) ; } }
public void send Message ( String type , String key , String value ) { if ( type . equals ( SET CONFIG TYPE ) ) { send Set Config Message ( key , value ) ; } else { throw new Illegal Argument Exception ( STRING + SET CONFIG TYPE + STRING ) ; } }
@ Override public String create Emr Cluster ( String cluster Name , Emr Cluster Definition emr Cluster Definition , Aws Params Dto aws Params ) { return emr Operations . run Emr Job Flow ( get Emr Client ( aws Params ) , get Run Job Flow Request ( cluster Name , emr Cluster Definition ) ) ; }
public void write Raw Little Endian 64 ( final long value ) throws IO Exception { if ( buffer . remaining ( ) < NUM ) { throw new Out Of Space Exception ( buffer . position ( ) , buffer . limit ( ) ) ; } buffer . put Long ( value ) ; }
@ Nullable public byte [ ] find Class Definition ( @ Not Null String name , @ Not Null App Resource Repository app Repo ) { int index = name . last Index Of ( STRING ) ; if ( index != - NUM && name . char At ( index + NUM ) == STRING && ( index == name . length ( ) - NUM || name . char At ( index + NUM ) == STRING ) && index > NUM ) { String pkg = name . substring ( NUM , index ) ; if ( my Packages != null && my Packages . contains ( pkg ) ) { Aar Resource Class Generator generator = my Generator Map . get ( app Repo ) ; if ( generator != null ) { return generator . generate ( name ) ; } } } return null ; }
public void init ( Cipher Parameters params ) throws Illegal Argument Exception { if ( params instanceof Parameters With IV ) { Parameters With IV iv Param = ( Parameters With IV ) params ; byte [ ] iv = iv Param . get IV ( ) ; if ( iv . length < IV . length ) { System . arraycopy ( iv , NUM , IV , IV . length - iv . length , iv . length ) ; } else { System . arraycopy ( iv , NUM , IV , NUM , IV . length ) ; } reset ( ) ; cipher . init ( BOOL , iv Param . get Parameters ( ) ) ; } else { reset ( ) ; cipher . init ( BOOL , params ) ; } }
public void init ( Cipher Parameters params ) throws Illegal Argument Exception { if ( params instanceof Parameters With IV ) { Parameters With IV iv Param = ( Parameters With IV ) params ; byte [ ] iv = iv Param . get IV ( ) ; if ( iv . length < IV . length ) { System . arraycopy ( iv , NUM , IV , IV . length - iv . length , iv . length ) ; } else { System . arraycopy ( iv , NUM , IV , NUM , IV . length ) ; } reset ( ) ; cipher . init ( BOOL , iv Param . get Parameters ( ) ) ; } else { reset ( ) ; cipher . init ( BOOL , params ) ; } }
public boolean accepts Owner Name ( String owner ) { if ( owner Option . equals ( ALL OWNERS ) ) { return BOOL ; } if ( owner Option . equals ( INCLUDE OWNERS ) ) { return owner List . contains ( owner ) ; } return ! owner List . contains ( owner ) ; }
@ Layoutlib Delegate static long current Thread Time Micro ( ) { return System . current Time Millis ( ) * NUM ; }
public static int count Nnz ( String [ ] cols , int pos , int len ) { int lnnz = NUM ; for ( int i = pos ; i < pos + len ; i ++ ) { String col = cols [ i ] ; lnnz += ( ! col . is Empty ( ) && ! col . equals ( STRING ) && ! col . equals ( STRING ) ) ? NUM : NUM ; } return lnnz ; }
public static int count Nnz ( String [ ] cols , int pos , int len ) { int lnnz = NUM ; for ( int i = pos ; i < pos + len ; i ++ ) { String col = cols [ i ] ; lnnz += ( ! col . is Empty ( ) && ! col . equals ( STRING ) && ! col . equals ( STRING ) ) ? NUM : NUM ; } return lnnz ; }
public Jar File Lister ( Zip File zip File , Dependencies Listener builder , Class File Reader reader , Progress Listener progress ) { this . zip File = zip File ; this . builder = builder ; this . reader = reader ; this . progress = progress ; }
public Jar File Lister ( Zip File zip File , Dependencies Listener builder , Class File Reader reader , Progress Listener progress ) { this . zip File = zip File ; this . builder = builder ; this . reader = reader ; this . progress = progress ; }
public Jar File Lister ( Zip File zip File , Dependencies Listener builder , Class File Reader reader , Progress Listener progress ) { this . zip File = zip File ; this . builder = builder ; this . reader = reader ; this . progress = progress ; }
public Jar File Lister ( Zip File zip File , Dependencies Listener builder , Class File Reader reader , Progress Listener progress ) { this . zip File = zip File ; this . builder = builder ; this . reader = reader ; this . progress = progress ; }
protected void process Special Attributes ( Node node ) { process State Attributes ( node , component ) ; }
protected void process Special Attributes ( Node node ) { process State Attributes ( node , component ) ; }
protected void process Special Attributes ( Node node ) { process State Attributes ( node , component ) ; }
private void create Text Field ( J Panel parent Panel , String label , J Text Field text Field , int field Width ) { J Panel panel = new J Panel ( ) ; panel . set Layout ( null ) ; parent Panel . add ( panel ) ; J Label lbl Name = new J Label ( label ) ; lbl Name . set Horizontal Alignment ( Swing Constants . TRAILING ) ; lbl Name . set Bounds ( LABEL X START , NUM , LABEL WIDTH , FIELD HEIGHT ) ; panel . add ( lbl Name ) ; text Field . set Bounds ( LABEL X START + LABEL WIDTH + FIELD X OFFSET , NUM , field Width , FIELD HEIGHT ) ; text Field . set Columns ( NUM ) ; panel . add ( text Field ) ; }
public void put Icon ( String extension , Icon icon ) { icons . put ( extension , icon ) ; }
private void run ( ) { try { Thread current = Thread . current Thread ( ) ; byte [ ] buf = new byte [ NUM ] ; for ( int len = in . read ( buf ) ; len != - NUM ; len = in . read ( buf ) ) { buffer . write ( buf , NUM , len ) ; if ( current != thread ) { break ; } } buffer . flush ( ) ; buffer . close ( ) ; } catch ( IO Exception e ) { log . error ( e . get Message ( ) , e ) ; } }
@ Override protected void do Before ( ) { file Prefs . add ( new Application Preference ( STRING ) ) ; file Prefs . add ( new Application Preference ( STRING ) ) ; persisted Prefs . add ( new Application Preference ( PERSISTED APP PREF 1 ) ) ; persisted Prefs . add ( new Application Preference ( PERSISTED APP PREF 2 ) ) ; }
public static double angle ( Coordinate p0 , Coordinate p1 ) { double dx = p1 . x - p0 . x ; double dy = p1 . y - p0 . y ; return Math . atan 2 ( dy , dx ) ; }
public static double angle ( Coordinate p0 , Coordinate p1 ) { double dx = p1 . x - p0 . x ; double dy = p1 . y - p0 . y ; return Math . atan 2 ( dy , dx ) ; }
@ Override public int hash Code ( ) { int result = NUM ; result = NUM * result + type ; result = NUM * result + Arrays . hash Code ( encoded ) ; return result ; }
@ Override public void paint Text ( Synth Context ss , Graphics g , String text , int x , int y , int mnemonic Index ) { Graphics 2 D g2 = ( Graphics 2 D ) g ; if ( desktop Hints == null ) { Toolkit toolkit = Toolkit . get Default Toolkit ( ) ; desktop Hints = ( Map < ? , ? > ) ( toolkit . get Desktop Property ( STRING ) ) ; } Object old AA = null ; Rendering Hints old Hints = null ; if ( desktop Hints != null ) { old Hints = get Rendering Hints ( g2 , desktop Hints , null ) ; g2 . add Rendering Hints ( desktop Hints ) ; } else { old AA = g2 . get Rendering Hint ( Rendering Hints . KEY TEXT ANTIALIASING ) ; g2 . set Rendering Hint ( Rendering Hints . KEY TEXT ANTIALIASING , Rendering Hints . VALUE TEXT ANTIALIAS ON ) ; } super . paint Text ( ss , g , text , x , y , mnemonic Index ) ; if ( old Hints != null ) g2 . add Rendering Hints ( old Hints ) ; else if ( old AA != null ) g2 . set Rendering Hint ( Rendering Hints . KEY TEXT ANTIALIASING , old AA ) ; }
@ Override public void paint Text ( Synth Context ss , Graphics g , String text , int x , int y , int mnemonic Index ) { Graphics 2 D g2 = ( Graphics 2 D ) g ; if ( desktop Hints == null ) { Toolkit toolkit = Toolkit . get Default Toolkit ( ) ; desktop Hints = ( Map < ? , ? > ) ( toolkit . get Desktop Property ( STRING ) ) ; } Object old AA = null ; Rendering Hints old Hints = null ; if ( desktop Hints != null ) { old Hints = get Rendering Hints ( g2 , desktop Hints , null ) ; g2 . add Rendering Hints ( desktop Hints ) ; } else { old AA = g2 . get Rendering Hint ( Rendering Hints . KEY TEXT ANTIALIASING ) ; g2 . set Rendering Hint ( Rendering Hints . KEY TEXT ANTIALIASING , Rendering Hints . VALUE TEXT ANTIALIAS ON ) ; } super . paint Text ( ss , g , text , x , y , mnemonic Index ) ; if ( old Hints != null ) g2 . add Rendering Hints ( old Hints ) ; else if ( old AA != null ) g2 . set Rendering Hint ( Rendering Hints . KEY TEXT ANTIALIASING , old AA ) ; }
int put Data ( Object data ) throws Fits Exception { long lsize = Array Funcs . compute L Size ( data ) ; if ( lsize > Integer . MAX VALUE ) { throw new Fits Exception ( STRING ) ; } int size = ( int ) lsize ; expand Heap ( size ) ; Byte Array Output Stream bo = new Byte Array Output Stream ( size ) ; try { Buffered Data Output Stream o = new Buffered Data Output Stream ( bo ) ; o . write Array ( data ) ; o . flush ( ) ; o . close ( ) ; } catch ( IO Exception e ) { throw new Fits Exception ( STRING , e ) ; } System . arraycopy ( bo . to Byte Array ( ) , NUM , this . heap , this . heap Size , size ) ; int old Offset = this . heap Size ; this . heap Size += size ; return old Offset ; }
private void populate Available Data Stores ( ) { Data Access Factory fac ; logger . debug ( STRING ) ; Iterator < Data Store Factory Spi > iterator = Data Store Finder . get Available Data Stores ( ) ; while ( iterator . has Next ( ) ) { fac = ( Data Access Factory ) iterator . next ( ) ; logger . debug ( STRING + fac . get Display Name ( ) ) ; available Data Store List . add ( fac . get Display Name ( ) ) ; } }
private void handle Command ( int id , String command , String params ) { String origin Command = command Id . get ( id ) ; if ( origin Command == null ) { origin Command = STRING ; } handler . handle Command ( id , command , params , origin Command ) ; if ( command . equals ( STRING ) ) { LOGGER . warning ( STRING + params ) ; } }
public static double mad ( final double [ ] data ) { double mad = NUM ; if ( data . length > NUM ) { double median = median ( data ) ; double [ ] deviation Sum = new double [ data . length ] ; for ( int i = NUM ; i < data . length ; i ++ ) { deviation Sum [ i ] = Math . abs ( median - data [ i ] ) ; } mad = median ( deviation Sum ) ; } return mad ; }
public boolean equals ( Object o ) { return ( o != null ) && ( o . get Class ( ) == Instruction . class ) && equals ( ( Instruction ) o ) ; }
public boolean equals ( Object o ) { return ( o != null ) && ( o . get Class ( ) == Instruction . class ) && equals ( ( Instruction ) o ) ; }
static boolean is Package Access ( final int modifiers ) { return ( modifiers & Member Utils . ACCESS TEST ) == NUM ; }
static boolean is Package Access ( final int modifiers ) { return ( modifiers & Member Utils . ACCESS TEST ) == NUM ; }
public static Time Of Day hour And Minute From Date ( Date date Time , Time Zone tz ) { if ( date Time == null ) return null ; Calendar cal = Calendar . get Instance ( ) ; cal . set Time ( date Time ) ; if ( tz != null ) cal . set Time Zone ( tz ) ; return new Time Of Day ( cal . get ( Calendar . HOUR OF DAY ) , cal . get ( Calendar . MINUTE ) ) ; }
public static Time Of Day hour And Minute From Date ( Date date Time , Time Zone tz ) { if ( date Time == null ) return null ; Calendar cal = Calendar . get Instance ( ) ; cal . set Time ( date Time ) ; if ( tz != null ) cal . set Time Zone ( tz ) ; return new Time Of Day ( cal . get ( Calendar . HOUR OF DAY ) , cal . get ( Calendar . MINUTE ) ) ; }
public static Time Of Day hour And Minute From Date ( Date date Time , Time Zone tz ) { if ( date Time == null ) return null ; Calendar cal = Calendar . get Instance ( ) ; cal . set Time ( date Time ) ; if ( tz != null ) cal . set Time Zone ( tz ) ; return new Time Of Day ( cal . get ( Calendar . HOUR OF DAY ) , cal . get ( Calendar . MINUTE ) ) ; }
private String extract Signature Id ( Use Key Type use Key , Security Header Type header ) { assert header != null ; String signature Id = null ; if ( use Key != null ) { signature Id = use Key . get Sig ( ) ; if ( header . get Signature ( ) == null || ! signature Id . equals Ignore Case ( header . get Signature ( ) . get Id ( ) ) ) { throw new Invalid Security Header Exception ( STRING ) ; } } return signature Id ; }
private String extract Signature Id ( Use Key Type use Key , Security Header Type header ) { assert header != null ; String signature Id = null ; if ( use Key != null ) { signature Id = use Key . get Sig ( ) ; if ( header . get Signature ( ) == null || ! signature Id . equals Ignore Case ( header . get Signature ( ) . get Id ( ) ) ) { throw new Invalid Security Header Exception ( STRING ) ; } } return signature Id ; }
private void move To ( float x , float y ) { m Path . move To ( m Last X = x , m Last Y = y ) ; }
private char string Char ( ) throws Json Parser Exception { int c = advance Char ( ) ; if ( c == - NUM ) throw create Parse Exception ( null , STRING , BOOL ) ; if ( c < NUM ) throw create Parse Exception ( null , STRING + Integer . to String ( c , NUM ) , BOOL ) ; return ( char ) c ; }
public int interp Elevation At ( float lat , float lon ) { if ( frame is valid == BOOL ) { if ( lat >= dsi . sw lat && lat <= dsi . ne lat && lon >= dsi . sw lon && lon <= dsi . ne lon ) { float lat index = ( lat - dsi . sw lat ) * NUM / uhl . lat post interval ; float lon index = ( lon - dsi . sw lon ) * NUM / uhl . lon post interval ; int lflon index = ( int ) Math . floor ( lon index ) ; int lclon index = ( int ) Math . ceil ( lon index ) ; int lclat index = ( int ) Math . ceil ( lat index ) ; if ( elevations [ lflon index ] == null ) read Data Record ( lflon index ) ; if ( elevations [ lclon index ] == null ) read Data Record ( lclon index ) ; int ul = elevations [ lflon index ] [ lclat index ] ; int ur = elevations [ lclon index ] [ lclat index ] ; int ll = elevations [ lflon index ] [ lclat index ] ; int lr = elevations [ lclon index ] [ lclat index ] ; float answer = resolve Four Points ( ul , ur , lr , ll , lat index , lon index ) ; return Math . round ( answer ) ; } } return - NUM ; }
protected void report Metrics If Needed ( ) { if ( get Gather Performance Metrics ( ) ) { if ( ( System . current Time Millis ( ) - this . metrics Last Reported Ms ) > get Report Metrics Interval Millis ( ) ) { report Metrics ( ) ; } } }
public void wait For Schema Agreement ( String target Schema Version , int node Count ) { long start = System . current Time Millis ( ) ; Map < String , List < String > > versions = null ; while ( System . current Time Millis ( ) - start < MAX SCHEMA WAIT MS ) { log . info ( STRING , target Schema Version , node Count ) ; versions = get Schema Versions ( ) ; if ( versions . size ( ) == NUM ) { if ( ! versions . contains Key ( target Schema Version ) ) { log . warn ( STRING , versions , target Schema Version ) ; return ; } if ( node Count != - NUM ) { List < String > hosts = null ; for ( Entry < String , List < String > > entry : versions . entry Set ( ) ) { hosts = entry . get Value ( ) ; } if ( hosts != null && hosts . size ( ) == node Count ) { log . info ( STRING , target Schema Version , node Count ) ; return ; } } else { log . info ( STRING , target Schema Version ) ; return ; } } log . info ( STRING ) ; try { Thread . sleep ( SCHEMA RETRY SLEEP MILLIS ) ; } catch ( Interrupted Exception ex ) { } } log . warn ( STRING , versions ) ; }
public void wait For Schema Agreement ( String target Schema Version , int node Count ) { long start = System . current Time Millis ( ) ; Map < String , List < String > > versions = null ; while ( System . current Time Millis ( ) - start < MAX SCHEMA WAIT MS ) { log . info ( STRING , target Schema Version , node Count ) ; versions = get Schema Versions ( ) ; if ( versions . size ( ) == NUM ) { if ( ! versions . contains Key ( target Schema Version ) ) { log . warn ( STRING , versions , target Schema Version ) ; return ; } if ( node Count != - NUM ) { List < String > hosts = null ; for ( Entry < String , List < String > > entry : versions . entry Set ( ) ) { hosts = entry . get Value ( ) ; } if ( hosts != null && hosts . size ( ) == node Count ) { log . info ( STRING , target Schema Version , node Count ) ; return ; } } else { log . info ( STRING , target Schema Version ) ; return ; } } log . info ( STRING ) ; try { Thread . sleep ( SCHEMA RETRY SLEEP MILLIS ) ; } catch ( Interrupted Exception ex ) { } } log . warn ( STRING , versions ) ; }
private void load Org Access Add ( Array List < Org Access > list , Org Access oa ) { if ( list . contains ( oa ) ) return ; list . add ( oa ) ; if ( get AD Tree Org ID ( ) == NUM ) return ; M Org org = M Org . get ( get Ctx ( ) , oa . AD Org ID ) ; if ( ! org . is Summary ( ) ) return ; M Tree Base tree = M Tree Base . get ( get Ctx ( ) , get AD Tree Org ID ( ) , get Trx Name ( ) ) ; String sql = STRING + STRING + tree . get Node Table Name ( ) + STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , get Trx Name ( ) ) ; pstmt . set Int ( NUM , tree . get AD Tree ID ( ) ) ; pstmt . set Int ( NUM , org . get AD Org ID ( ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { int AD Client ID = rs . get Int ( NUM ) ; int AD Org ID = rs . get Int ( NUM ) ; load Org Access Add ( list , new Org Access ( AD Client ID , AD Org ID , oa . read Only ) ) ; } } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } }
private void load Org Access Add ( Array List < Org Access > list , Org Access oa ) { if ( list . contains ( oa ) ) return ; list . add ( oa ) ; if ( get AD Tree Org ID ( ) == NUM ) return ; M Org org = M Org . get ( get Ctx ( ) , oa . AD Org ID ) ; if ( ! org . is Summary ( ) ) return ; M Tree Base tree = M Tree Base . get ( get Ctx ( ) , get AD Tree Org ID ( ) , get Trx Name ( ) ) ; String sql = STRING + STRING + tree . get Node Table Name ( ) + STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , get Trx Name ( ) ) ; pstmt . set Int ( NUM , tree . get AD Tree ID ( ) ) ; pstmt . set Int ( NUM , org . get AD Org ID ( ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { int AD Client ID = rs . get Int ( NUM ) ; int AD Org ID = rs . get Int ( NUM ) ; load Org Access Add ( list , new Org Access ( AD Client ID , AD Org ID , oa . read Only ) ) ; } } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } }
private List < Statistics > remove Succeeded ( List < Statistics > statistics ) { List < Statistics > result = new Array List < > ( ) ; for ( Statistics statistic : statistics ) { if ( ! statistic . get Succeeded ( ) ) result . add ( statistic ) ; } return result ; }
private List < Statistics > remove Succeeded ( List < Statistics > statistics ) { List < Statistics > result = new Array List < > ( ) ; for ( Statistics statistic : statistics ) { if ( ! statistic . get Succeeded ( ) ) result . add ( statistic ) ; } return result ; }
public void do Edit Chart Properties ( ) { Chart Editor editor = Chart Editor Manager . get Chart Editor ( this . chart ) ; int result = J Option Pane . show Confirm Dialog ( this , editor , localization Resources . get String ( STRING ) , J Option Pane . OK CANCEL OPTION , J Option Pane . PLAIN MESSAGE ) ; if ( result == J Option Pane . OK OPTION ) { editor . update Chart ( this . chart ) ; } }
public void do Edit Chart Properties ( ) { Chart Editor editor = Chart Editor Manager . get Chart Editor ( this . chart ) ; int result = J Option Pane . show Confirm Dialog ( this , editor , localization Resources . get String ( STRING ) , J Option Pane . OK CANCEL OPTION , J Option Pane . PLAIN MESSAGE ) ; if ( result == J Option Pane . OK OPTION ) { editor . update Chart ( this . chart ) ; } }
public void do Edit Chart Properties ( ) { Chart Editor editor = Chart Editor Manager . get Chart Editor ( this . chart ) ; int result = J Option Pane . show Confirm Dialog ( this , editor , localization Resources . get String ( STRING ) , J Option Pane . OK CANCEL OPTION , J Option Pane . PLAIN MESSAGE ) ; if ( result == J Option Pane . OK OPTION ) { editor . update Chart ( this . chart ) ; } }
public void do Edit Chart Properties ( ) { Chart Editor editor = Chart Editor Manager . get Chart Editor ( this . chart ) ; int result = J Option Pane . show Confirm Dialog ( this , editor , localization Resources . get String ( STRING ) , J Option Pane . OK CANCEL OPTION , J Option Pane . PLAIN MESSAGE ) ; if ( result == J Option Pane . OK OPTION ) { editor . update Chart ( this . chart ) ; } }
public void release ( ) { Reentrant Lock lock = Bridge . get Lock ( ) ; if ( lock . is Held By Current Thread ( ) ) { tear Down ( ) ; lock . unlock ( ) ; } }
public Status Component ( ) { STEPPING = BOOL ; NF = null ; LABEL = new J Label ( ) ; BAR = new J Progress Bar ( ) ; set Layout ( new Box Layout ( this , Box Layout . Y AXIS ) ) ; construct ( ) ; GUI Utils . set Opaque ( BOOL , this ) ; if ( BAR != null && ! OS Utils . is Mac OSX ( ) ) { BAR . set Opaque ( BOOL ) ; } BAR . set Indeterminate ( BOOL ) ; }
private String build Virtual Volume Name ( List < String > native Volume Names ) { s logger . info ( STRING ) ; String Builder name Builder = new String Builder ( ) ; if ( native Volume Names . size ( ) == NUM ) { name Builder . append ( V Plex Api Constants . DEVICE PREFIX ) ; name Builder . append ( native Volume Names . get ( NUM ) ) ; name Builder . append ( V Plex Api Constants . VIRTUAL VOLUME SUFFIX ) ; } else { name Builder . append ( V Plex Api Constants . DIST DEVICE PREFIX ) ; for ( String native Volume Name : native Volume Names ) { name Builder . append ( V Plex Api Constants . DIST DEVICE NAME DELIM ) ; name Builder . append ( native Volume Name ) ; } name Builder . append ( V Plex Api Constants . VIRTUAL VOLUME SUFFIX ) ; } s logger . info ( STRING , name Builder . to String ( ) ) ; return name Builder . to String ( ) ; }
private String build Virtual Volume Name ( List < String > native Volume Names ) { s logger . info ( STRING ) ; String Builder name Builder = new String Builder ( ) ; if ( native Volume Names . size ( ) == NUM ) { name Builder . append ( V Plex Api Constants . DEVICE PREFIX ) ; name Builder . append ( native Volume Names . get ( NUM ) ) ; name Builder . append ( V Plex Api Constants . VIRTUAL VOLUME SUFFIX ) ; } else { name Builder . append ( V Plex Api Constants . DIST DEVICE PREFIX ) ; for ( String native Volume Name : native Volume Names ) { name Builder . append ( V Plex Api Constants . DIST DEVICE NAME DELIM ) ; name Builder . append ( native Volume Name ) ; } name Builder . append ( V Plex Api Constants . VIRTUAL VOLUME SUFFIX ) ; } s logger . info ( STRING , name Builder . to String ( ) ) ; return name Builder . to String ( ) ; }
public static boolean is Valid Vector ( Vector 2 f vector ) { if ( vector == null ) return BOOL ; if ( Float . is Na N ( vector . x ) || Float . is Na N ( vector . y ) ) return BOOL ; if ( Float . is Infinite ( vector . x ) || Float . is Infinite ( vector . y ) ) return BOOL ; return BOOL ; }
public boolean must Refresh ( ) { try { if ( current Snapshot == null || source File . count Files ( ) != current Snapshot . size ( ) ) return BOOL ; if ( current Open File != null ) { if ( ! Files . exists ( current Open File . get Path ( ) ) ) { LOGGER . debug ( STRING , current Open File . get Path ( ) ) ; return BOOL ; } Basic File Attributes new Attr = Files . read Attributes ( current Open File . get Path ( ) , Basic File Attributes . class ) ; File Id new Id = File Id . get ( new Attr ) ; if ( ! new Id . equals ( current Open File . get Id ( ) ) ) { LOGGER . debug ( STRING , current Open File . get Path ( ) , current Open File . get Id ( ) , new Id ) ; return BOOL ; } if ( new Attr . size ( ) < current Open File . get Size ( ) ) { LOGGER . debug ( STRING , current Open File . get Path ( ) , current Open File . get Size ( ) , new Attr . size ( ) ) ; return BOOL ; } } } catch ( IO Exception e ) { LOGGER . error ( STRING , e ) ; return BOOL ; } return BOOL ; }
public boolean must Refresh ( ) { try { if ( current Snapshot == null || source File . count Files ( ) != current Snapshot . size ( ) ) return BOOL ; if ( current Open File != null ) { if ( ! Files . exists ( current Open File . get Path ( ) ) ) { LOGGER . debug ( STRING , current Open File . get Path ( ) ) ; return BOOL ; } Basic File Attributes new Attr = Files . read Attributes ( current Open File . get Path ( ) , Basic File Attributes . class ) ; File Id new Id = File Id . get ( new Attr ) ; if ( ! new Id . equals ( current Open File . get Id ( ) ) ) { LOGGER . debug ( STRING , current Open File . get Path ( ) , current Open File . get Id ( ) , new Id ) ; return BOOL ; } if ( new Attr . size ( ) < current Open File . get Size ( ) ) { LOGGER . debug ( STRING , current Open File . get Path ( ) , current Open File . get Size ( ) , new Attr . size ( ) ) ; return BOOL ; } } } catch ( IO Exception e ) { LOGGER . error ( STRING , e ) ; return BOOL ; } return BOOL ; }
public boolean must Refresh ( ) { try { if ( current Snapshot == null || source File . count Files ( ) != current Snapshot . size ( ) ) return BOOL ; if ( current Open File != null ) { if ( ! Files . exists ( current Open File . get Path ( ) ) ) { LOGGER . debug ( STRING , current Open File . get Path ( ) ) ; return BOOL ; } Basic File Attributes new Attr = Files . read Attributes ( current Open File . get Path ( ) , Basic File Attributes . class ) ; File Id new Id = File Id . get ( new Attr ) ; if ( ! new Id . equals ( current Open File . get Id ( ) ) ) { LOGGER . debug ( STRING , current Open File . get Path ( ) , current Open File . get Id ( ) , new Id ) ; return BOOL ; } if ( new Attr . size ( ) < current Open File . get Size ( ) ) { LOGGER . debug ( STRING , current Open File . get Path ( ) , current Open File . get Size ( ) , new Attr . size ( ) ) ; return BOOL ; } } } catch ( IO Exception e ) { LOGGER . error ( STRING , e ) ; return BOOL ; } return BOOL ; }
public static byte [ ] to Byte Array ( String spaced Hex ) { int idx = NUM ; final int len = spaced Hex . length ( ) ; final String Builder sb = new String Builder ( ) ; final Byte Array Output Stream bytes = new Byte Array Output Stream ( ) ; while ( idx < len ) { final char chr = spaced Hex . char At ( idx ++ ) ; if ( chr != STRING ) { sb . set Length ( NUM ) ; sb . append ( chr ) ; sb . append ( spaced Hex . char At ( idx ++ ) ) ; final int i = Integer . parse Int ( sb . to String ( ) , NUM ) ; final byte b = ( ( byte ) i ) ; bytes . write ( b ) ; } } return bytes . to Byte Array ( ) ; }
public static boolean rename File ( final File from File , final File to File ) { File to File 2 = to File ; if ( from File . rename To ( to File ) ) { return BOOL ; } if ( ! from File . exists ( ) ) { return BOOL ; } if ( ! from File . can Read ( ) ) { return BOOL ; } if ( to File . is Directory ( ) ) { to File 2 = new File ( to File , from File . get Name ( ) ) ; } if ( to File 2 . exists ( ) ) { return BOOL ; } String parent = to File 2 . get Parent ( ) ; if ( parent == null ) parent = System . get Property ( STRING ) ; File dir = new File ( parent ) ; if ( ! dir . exists ( ) ) { return BOOL ; } if ( ! dir . can Write ( ) ) { return BOOL ; } try { copy File ( from File , to File 2 ) ; } catch ( Unchecked IO Exception e ) { if ( to File 2 . exists ( ) ) to File 2 . delete ( ) ; return BOOL ; } from File . delete ( ) ; return BOOL ; }
public static boolean rename File ( final File from File , final File to File ) { File to File 2 = to File ; if ( from File . rename To ( to File ) ) { return BOOL ; } if ( ! from File . exists ( ) ) { return BOOL ; } if ( ! from File . can Read ( ) ) { return BOOL ; } if ( to File . is Directory ( ) ) { to File 2 = new File ( to File , from File . get Name ( ) ) ; } if ( to File 2 . exists ( ) ) { return BOOL ; } String parent = to File 2 . get Parent ( ) ; if ( parent == null ) parent = System . get Property ( STRING ) ; File dir = new File ( parent ) ; if ( ! dir . exists ( ) ) { return BOOL ; } if ( ! dir . can Write ( ) ) { return BOOL ; } try { copy File ( from File , to File 2 ) ; } catch ( Unchecked IO Exception e ) { if ( to File 2 . exists ( ) ) to File 2 . delete ( ) ; return BOOL ; } from File . delete ( ) ; return BOOL ; }
public static boolean rename File ( final File from File , final File to File ) { File to File 2 = to File ; if ( from File . rename To ( to File ) ) { return BOOL ; } if ( ! from File . exists ( ) ) { return BOOL ; } if ( ! from File . can Read ( ) ) { return BOOL ; } if ( to File . is Directory ( ) ) { to File 2 = new File ( to File , from File . get Name ( ) ) ; } if ( to File 2 . exists ( ) ) { return BOOL ; } String parent = to File 2 . get Parent ( ) ; if ( parent == null ) parent = System . get Property ( STRING ) ; File dir = new File ( parent ) ; if ( ! dir . exists ( ) ) { return BOOL ; } if ( ! dir . can Write ( ) ) { return BOOL ; } try { copy File ( from File , to File 2 ) ; } catch ( Unchecked IO Exception e ) { if ( to File 2 . exists ( ) ) to File 2 . delete ( ) ; return BOOL ; } from File . delete ( ) ; return BOOL ; }
public static boolean rename File ( final File from File , final File to File ) { File to File 2 = to File ; if ( from File . rename To ( to File ) ) { return BOOL ; } if ( ! from File . exists ( ) ) { return BOOL ; } if ( ! from File . can Read ( ) ) { return BOOL ; } if ( to File . is Directory ( ) ) { to File 2 = new File ( to File , from File . get Name ( ) ) ; } if ( to File 2 . exists ( ) ) { return BOOL ; } String parent = to File 2 . get Parent ( ) ; if ( parent == null ) parent = System . get Property ( STRING ) ; File dir = new File ( parent ) ; if ( ! dir . exists ( ) ) { return BOOL ; } if ( ! dir . can Write ( ) ) { return BOOL ; } try { copy File ( from File , to File 2 ) ; } catch ( Unchecked IO Exception e ) { if ( to File 2 . exists ( ) ) to File 2 . delete ( ) ; return BOOL ; } from File . delete ( ) ; return BOOL ; }
public static boolean rename File ( final File from File , final File to File ) { File to File 2 = to File ; if ( from File . rename To ( to File ) ) { return BOOL ; } if ( ! from File . exists ( ) ) { return BOOL ; } if ( ! from File . can Read ( ) ) { return BOOL ; } if ( to File . is Directory ( ) ) { to File 2 = new File ( to File , from File . get Name ( ) ) ; } if ( to File 2 . exists ( ) ) { return BOOL ; } String parent = to File 2 . get Parent ( ) ; if ( parent == null ) parent = System . get Property ( STRING ) ; File dir = new File ( parent ) ; if ( ! dir . exists ( ) ) { return BOOL ; } if ( ! dir . can Write ( ) ) { return BOOL ; } try { copy File ( from File , to File 2 ) ; } catch ( Unchecked IO Exception e ) { if ( to File 2 . exists ( ) ) to File 2 . delete ( ) ; return BOOL ; } from File . delete ( ) ; return BOOL ; }
public static boolean rename File ( final File from File , final File to File ) { File to File 2 = to File ; if ( from File . rename To ( to File ) ) { return BOOL ; } if ( ! from File . exists ( ) ) { return BOOL ; } if ( ! from File . can Read ( ) ) { return BOOL ; } if ( to File . is Directory ( ) ) { to File 2 = new File ( to File , from File . get Name ( ) ) ; } if ( to File 2 . exists ( ) ) { return BOOL ; } String parent = to File 2 . get Parent ( ) ; if ( parent == null ) parent = System . get Property ( STRING ) ; File dir = new File ( parent ) ; if ( ! dir . exists ( ) ) { return BOOL ; } if ( ! dir . can Write ( ) ) { return BOOL ; } try { copy File ( from File , to File 2 ) ; } catch ( Unchecked IO Exception e ) { if ( to File 2 . exists ( ) ) to File 2 . delete ( ) ; return BOOL ; } from File . delete ( ) ; return BOOL ; }
public Media Config create Channel Image Attachment ( String file , Media Config config ) { config . add Credentials ( this ) ; String xml = POSTIMAGE ( this . url + STRING , file , config . name , config . to XML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { Media Config media = new Media Config ( ) ; media . parse XML ( root ) ; return media ; } catch ( Exception exception ) { this . exception = SDK Exception . parse Failure ( exception ) ; throw this . exception ; } }
private boolean is Upload Size And Frequency Allowed ( ) { if ( m File To Upload . length ( ) > LOG SIZE LIMIT BYTES ) return BOOL ; if ( m Shared Preferences . get Int ( PREF LAST UPLOAD DAY , NUM ) != get Current Day ( ) ) return BOOL ; return m Shared Preferences . get Int ( PREF UPLOAD COUNT , NUM ) < LOG UPLOAD LIMIT PER DAY ; }
private boolean is Upload Size And Frequency Allowed ( ) { if ( m File To Upload . length ( ) > LOG SIZE LIMIT BYTES ) return BOOL ; if ( m Shared Preferences . get Int ( PREF LAST UPLOAD DAY , NUM ) != get Current Day ( ) ) return BOOL ; return m Shared Preferences . get Int ( PREF UPLOAD COUNT , NUM ) < LOG UPLOAD LIMIT PER DAY ; }
private void remove Useless Task ( Proxy Reg reg ) { List pending Tasks = cache Task Mgr . get Pending ( ) ; for ( int i = NUM ; i < pending Tasks . size ( ) ; i ++ ) { Cache Task t = ( Cache Task ) pending Tasks . get ( i ) ; if ( t . is From Proxy ( reg ) ) cache Task Mgr . remove ( t ) ; } }
public static String fake Signature ( String qualified Name ) { String cname = qualified Name . substring ( NUM , qualified Name . last Index Of ( STRING ) ) ; String mname = qualified Name . substring ( qualified Name . last Index Of ( STRING ) + NUM , qualified Name . length ( ) ) ; return STRING + cname + STRING + mname + STRING ; }
private void values Tester ( final int tree Size , final Collection < String > values ) { int counter = NUM ; for ( String value : values ) { counter ++ ; } assert Equals ( tree Size , counter ) ; assert Equals ( tree Size , values . size ( ) ) ; }
private void values Tester ( final int tree Size , final Collection < String > values ) { int counter = NUM ; for ( String value : values ) { counter ++ ; } assert Equals ( tree Size , counter ) ; assert Equals ( tree Size , values . size ( ) ) ; }
public static void append Escaped SQL String ( String Builder sb , String sql String ) { sb . append ( STRING ) ; if ( sql String . index Of ( STRING ) != - NUM ) { int length = sql String . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = sql String . char At ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sql String ) ; } sb . append ( STRING ) ; }
public static void append Escaped SQL String ( String Builder sb , String sql String ) { sb . append ( STRING ) ; if ( sql String . index Of ( STRING ) != - NUM ) { int length = sql String . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = sql String . char At ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sql String ) ; } sb . append ( STRING ) ; }
public static void append Escaped SQL String ( String Builder sb , String sql String ) { sb . append ( STRING ) ; if ( sql String . index Of ( STRING ) != - NUM ) { int length = sql String . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = sql String . char At ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sql String ) ; } sb . append ( STRING ) ; }
public static void append Escaped SQL String ( String Builder sb , String sql String ) { sb . append ( STRING ) ; if ( sql String . index Of ( STRING ) != - NUM ) { int length = sql String . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = sql String . char At ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sql String ) ; } sb . append ( STRING ) ; }
public static void append Escaped SQL String ( String Builder sb , String sql String ) { sb . append ( STRING ) ; if ( sql String . index Of ( STRING ) != - NUM ) { int length = sql String . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = sql String . char At ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sql String ) ; } sb . append ( STRING ) ; }
public static void append Escaped SQL String ( String Builder sb , String sql String ) { sb . append ( STRING ) ; if ( sql String . index Of ( STRING ) != - NUM ) { int length = sql String . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = sql String . char At ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sql String ) ; } sb . append ( STRING ) ; }
public static void append Escaped SQL String ( String Builder sb , String sql String ) { sb . append ( STRING ) ; if ( sql String . index Of ( STRING ) != - NUM ) { int length = sql String . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = sql String . char At ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sql String ) ; } sb . append ( STRING ) ; }
public static void append Escaped SQL String ( String Builder sb , String sql String ) { sb . append ( STRING ) ; if ( sql String . index Of ( STRING ) != - NUM ) { int length = sql String . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = sql String . char At ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sql String ) ; } sb . append ( STRING ) ; }
public static void append Escaped SQL String ( String Builder sb , String sql String ) { sb . append ( STRING ) ; if ( sql String . index Of ( STRING ) != - NUM ) { int length = sql String . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = sql String . char At ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sql String ) ; } sb . append ( STRING ) ; }
public static void append Escaped SQL String ( String Builder sb , String sql String ) { sb . append ( STRING ) ; if ( sql String . index Of ( STRING ) != - NUM ) { int length = sql String . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = sql String . char At ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sql String ) ; } sb . append ( STRING ) ; }
public static void append Escaped SQL String ( String Builder sb , String sql String ) { sb . append ( STRING ) ; if ( sql String . index Of ( STRING ) != - NUM ) { int length = sql String . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = sql String . char At ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sql String ) ; } sb . append ( STRING ) ; }
public static void append Escaped SQL String ( String Builder sb , String sql String ) { sb . append ( STRING ) ; if ( sql String . index Of ( STRING ) != - NUM ) { int length = sql String . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = sql String . char At ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sql String ) ; } sb . append ( STRING ) ; }
public static void append Escaped SQL String ( String Builder sb , String sql String ) { sb . append ( STRING ) ; if ( sql String . index Of ( STRING ) != - NUM ) { int length = sql String . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = sql String . char At ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sql String ) ; } sb . append ( STRING ) ; }
private String is Volume Ingestable ( CIM Instance volume Instance , String is Bound , String usage Prop , String un Managed Volume Native Guid , Map < String , Set < String > > duplicate Sync Aspect Element Name Map ) { String usage = get CIM Property Value ( volume Instance , usage Prop ) ; if ( ! Boolean . value Of ( is Bound ) ) { return STRING ; } if ( ! ( TWO . equals Ignore Case ( usage ) || NINE . equals Ignore Case ( usage ) || SEVEN . equals Ignore Case ( usage ) || ELEVEN . equals Ignore Case ( usage ) || USAGE LOCAL REPLICA TARGET . equals Ignore Case ( usage ) || USAGE DELTA REPLICA TARGET . equals Ignore Case ( usage ) || USGAE LOCAL REPLICA SOURCE . equals Ignore Case ( usage ) || USAGE LOCAL REPLICA SOURCE OR TARGET . equals Ignore Case ( usage ) ) ) { return STRING ; } boolean has Unsupported Snapshot Sessions = BOOL ; if ( duplicate Sync Aspect Element Name Map . contains Key ( un Managed Volume Native Guid ) ) { Set < String > duplicate Sync Aspect Element Names = duplicate Sync Aspect Element Name Map . get ( un Managed Volume Native Guid ) ; if ( ( duplicate Sync Aspect Element Names != null ) && ( ! duplicate Sync Aspect Element Names . is Empty ( ) ) ) { has Unsupported Snapshot Sessions = BOOL ; } } if ( has Unsupported Snapshot Sessions ) { return STRING + STRING + STRING ; } return null ; }
private String is Volume Ingestable ( CIM Instance volume Instance , String is Bound , String usage Prop , String un Managed Volume Native Guid , Map < String , Set < String > > duplicate Sync Aspect Element Name Map ) { String usage = get CIM Property Value ( volume Instance , usage Prop ) ; if ( ! Boolean . value Of ( is Bound ) ) { return STRING ; } if ( ! ( TWO . equals Ignore Case ( usage ) || NINE . equals Ignore Case ( usage ) || SEVEN . equals Ignore Case ( usage ) || ELEVEN . equals Ignore Case ( usage ) || USAGE LOCAL REPLICA TARGET . equals Ignore Case ( usage ) || USAGE DELTA REPLICA TARGET . equals Ignore Case ( usage ) || USGAE LOCAL REPLICA SOURCE . equals Ignore Case ( usage ) || USAGE LOCAL REPLICA SOURCE OR TARGET . equals Ignore Case ( usage ) ) ) { return STRING ; } boolean has Unsupported Snapshot Sessions = BOOL ; if ( duplicate Sync Aspect Element Name Map . contains Key ( un Managed Volume Native Guid ) ) { Set < String > duplicate Sync Aspect Element Names = duplicate Sync Aspect Element Name Map . get ( un Managed Volume Native Guid ) ; if ( ( duplicate Sync Aspect Element Names != null ) && ( ! duplicate Sync Aspect Element Names . is Empty ( ) ) ) { has Unsupported Snapshot Sessions = BOOL ; } } if ( has Unsupported Snapshot Sessions ) { return STRING + STRING + STRING ; } return null ; }
private String is Volume Ingestable ( CIM Instance volume Instance , String is Bound , String usage Prop , String un Managed Volume Native Guid , Map < String , Set < String > > duplicate Sync Aspect Element Name Map ) { String usage = get CIM Property Value ( volume Instance , usage Prop ) ; if ( ! Boolean . value Of ( is Bound ) ) { return STRING ; } if ( ! ( TWO . equals Ignore Case ( usage ) || NINE . equals Ignore Case ( usage ) || SEVEN . equals Ignore Case ( usage ) || ELEVEN . equals Ignore Case ( usage ) || USAGE LOCAL REPLICA TARGET . equals Ignore Case ( usage ) || USAGE DELTA REPLICA TARGET . equals Ignore Case ( usage ) || USGAE LOCAL REPLICA SOURCE . equals Ignore Case ( usage ) || USAGE LOCAL REPLICA SOURCE OR TARGET . equals Ignore Case ( usage ) ) ) { return STRING ; } boolean has Unsupported Snapshot Sessions = BOOL ; if ( duplicate Sync Aspect Element Name Map . contains Key ( un Managed Volume Native Guid ) ) { Set < String > duplicate Sync Aspect Element Names = duplicate Sync Aspect Element Name Map . get ( un Managed Volume Native Guid ) ; if ( ( duplicate Sync Aspect Element Names != null ) && ( ! duplicate Sync Aspect Element Names . is Empty ( ) ) ) { has Unsupported Snapshot Sessions = BOOL ; } } if ( has Unsupported Snapshot Sessions ) { return STRING + STRING + STRING ; } return null ; }
Compilation Unit Completion ( I Compilation Unit unit ) { reset ( unit ) ; set Ignored ( Completion Proposal . ANONYMOUS CLASS DECLARATION , BOOL ) ; set Ignored ( Completion Proposal . ANONYMOUS CLASS CONSTRUCTOR INVOCATION , BOOL ) ; set Ignored ( Completion Proposal . KEYWORD , BOOL ) ; set Ignored ( Completion Proposal . LABEL REF , BOOL ) ; set Ignored ( Completion Proposal . METHOD DECLARATION , BOOL ) ; set Ignored ( Completion Proposal . METHOD NAME REFERENCE , BOOL ) ; set Ignored ( Completion Proposal . METHOD REF , BOOL ) ; set Ignored ( Completion Proposal . CONSTRUCTOR INVOCATION , BOOL ) ; set Ignored ( Completion Proposal . METHOD REF WITH CASTED RECEIVER , BOOL ) ; set Ignored ( Completion Proposal . PACKAGE REF , BOOL ) ; set Ignored ( Completion Proposal . POTENTIAL METHOD DECLARATION , BOOL ) ; set Ignored ( Completion Proposal . VARIABLE DECLARATION , BOOL ) ; set Ignored ( Completion Proposal . TYPE REF , BOOL ) ; }
public static Bartender System create And Add System ( Bartender Builder builder ) { Bartender System Full system Bartender = new Bartender System Full ( builder ) ; System Manager system = pre Create ( Bartender System . class ) ; system . add System ( Bartender System . class , system Bartender ) ; return system Bartender ; }
protected final void check Name Present ( ) { if ( ! name . is Present ( ) ) { throw new Illegal State Exception ( STRING ) ; } }
private static String convert Calendar To String ( Calendar calendar ) { if ( calendar != null ) { Simple Date Format sdf = new Simple Date Format ( License Constants . MM DD YYYY FORMAT ) ; return sdf . format ( calendar . get Time ( ) ) ; } else { return null ; } }
private static String convert Calendar To String ( Calendar calendar ) { if ( calendar != null ) { Simple Date Format sdf = new Simple Date Format ( License Constants . MM DD YYYY FORMAT ) ; return sdf . format ( calendar . get Time ( ) ) ; } else { return null ; } }
public void test To Engineering String Zero Pos Exponent ( ) { String a = STRING ; Big Decimal a Number = new Big Decimal ( a ) ; String result = STRING ; assert Equals ( STRING , result , a Number . to Engineering String ( ) ) ; }
@ Constraints ( no Null Inputs = BOOL , not Mutable = BOOL , no Direct Insertion = BOOL ) public static < T > void validate Bean ( @ Bound Input Variable ( initializer = BOOL , at Most Once With Same Parameters = BOOL ) T instance , Class < ? > clazz ) throws False Positive Exception , Illegal Argument Exception { Inputs . check Null ( instance , clazz ) ; for ( Field f : get All Fields To Inject ( clazz ) ) { f . set Accessible ( BOOL ) ; try { Object obj = f . get ( instance ) ; if ( obj == null ) { throw new False Positive Exception ( STRING + f . get Name ( ) + STRING + clazz . get Name ( ) ) ; } } catch ( Illegal Access Exception e ) { logger . warn ( e . to String ( ) ) ; } } Class < ? > parent = clazz . get Superclass ( ) ; if ( parent != null && ! parent . equals ( Object . class ) ) { validate Bean ( instance , parent ) ; } }
@ Constraints ( no Null Inputs = BOOL , not Mutable = BOOL , no Direct Insertion = BOOL ) public static < T > void validate Bean ( @ Bound Input Variable ( initializer = BOOL , at Most Once With Same Parameters = BOOL ) T instance , Class < ? > clazz ) throws False Positive Exception , Illegal Argument Exception { Inputs . check Null ( instance , clazz ) ; for ( Field f : get All Fields To Inject ( clazz ) ) { f . set Accessible ( BOOL ) ; try { Object obj = f . get ( instance ) ; if ( obj == null ) { throw new False Positive Exception ( STRING + f . get Name ( ) + STRING + clazz . get Name ( ) ) ; } } catch ( Illegal Access Exception e ) { logger . warn ( e . to String ( ) ) ; } } Class < ? > parent = clazz . get Superclass ( ) ; if ( parent != null && ! parent . equals ( Object . class ) ) { validate Bean ( instance , parent ) ; } }
@ Constraints ( no Null Inputs = BOOL , not Mutable = BOOL , no Direct Insertion = BOOL ) public static < T > void validate Bean ( @ Bound Input Variable ( initializer = BOOL , at Most Once With Same Parameters = BOOL ) T instance , Class < ? > clazz ) throws False Positive Exception , Illegal Argument Exception { Inputs . check Null ( instance , clazz ) ; for ( Field f : get All Fields To Inject ( clazz ) ) { f . set Accessible ( BOOL ) ; try { Object obj = f . get ( instance ) ; if ( obj == null ) { throw new False Positive Exception ( STRING + f . get Name ( ) + STRING + clazz . get Name ( ) ) ; } } catch ( Illegal Access Exception e ) { logger . warn ( e . to String ( ) ) ; } } Class < ? > parent = clazz . get Superclass ( ) ; if ( parent != null && ! parent . equals ( Object . class ) ) { validate Bean ( instance , parent ) ; } }
public boolean write Header ( Output Stream os ) { try { write Int ( os , CACHE MAGIC ) ; write String ( os , key ) ; write String ( os , etag == null ? STRING : etag ) ; write Long ( os , server Date ) ; write Long ( os , ttl ) ; write String String Map ( response Headers , os ) ; os . flush ( ) ; return BOOL ; } catch ( IO Exception e ) { Loger . debug ( String . format ( STRING , e . to String ( ) ) ) ; return BOOL ; } }
public static Endpoint Description select Endpoint ( Endpoint Description [ ] endpoints ) { if ( endpoints == null ) throw new Illegal Argument Exception ( STRING ) ; endpoints = Endpoint Util . select By Protocol ( endpoints , STRING ) ; endpoints = Endpoint Util . select By Message Security Mode ( endpoints , Message Security Mode . Sign And Encrypt ) ; if ( endpoints . length == NUM ) return null ; endpoints = Endpoint Util . sort By Security Level ( endpoints ) ; Endpoint Util . reverse ( endpoints ) ; return endpoints [ NUM ] ; }
public static Endpoint Description select Endpoint ( Endpoint Description [ ] endpoints ) { if ( endpoints == null ) throw new Illegal Argument Exception ( STRING ) ; endpoints = Endpoint Util . select By Protocol ( endpoints , STRING ) ; endpoints = Endpoint Util . select By Message Security Mode ( endpoints , Message Security Mode . Sign And Encrypt ) ; if ( endpoints . length == NUM ) return null ; endpoints = Endpoint Util . sort By Security Level ( endpoints ) ; Endpoint Util . reverse ( endpoints ) ; return endpoints [ NUM ] ; }
public static Endpoint Description select Endpoint ( Endpoint Description [ ] endpoints ) { if ( endpoints == null ) throw new Illegal Argument Exception ( STRING ) ; endpoints = Endpoint Util . select By Protocol ( endpoints , STRING ) ; endpoints = Endpoint Util . select By Message Security Mode ( endpoints , Message Security Mode . Sign And Encrypt ) ; if ( endpoints . length == NUM ) return null ; endpoints = Endpoint Util . sort By Security Level ( endpoints ) ; Endpoint Util . reverse ( endpoints ) ; return endpoints [ NUM ] ; }
public static Endpoint Description select Endpoint ( Endpoint Description [ ] endpoints ) { if ( endpoints == null ) throw new Illegal Argument Exception ( STRING ) ; endpoints = Endpoint Util . select By Protocol ( endpoints , STRING ) ; endpoints = Endpoint Util . select By Message Security Mode ( endpoints , Message Security Mode . Sign And Encrypt ) ; if ( endpoints . length == NUM ) return null ; endpoints = Endpoint Util . sort By Security Level ( endpoints ) ; Endpoint Util . reverse ( endpoints ) ; return endpoints [ NUM ] ; }
private void draw Text ( final Graphics 2 D g2 d ) { g2 d . translate ( - get Screen View X ( ) , - get Screen View Y ( ) ) ; synchronized ( texts ) { Iterator < Removable Sprite > it = texts . iterator ( ) ; while ( it . has Next ( ) ) { Removable Sprite text = it . next ( ) ; if ( ! text . should Be Removed ( ) ) { text . draw ( g2 d ) ; } else { it . remove ( ) ; } } } g2 d . translate ( get Screen View X ( ) , get Screen View Y ( ) ) ; synchronized ( static Sprites ) { Iterator < Removable Sprite > it = static Sprites . iterator ( ) ; while ( it . has Next ( ) ) { Removable Sprite text = it . next ( ) ; if ( ! text . should Be Removed ( ) ) { text . draw ( g2 d ) ; } else { it . remove ( ) ; } } } }
public void render ( Graphics graphics ) { if ( get Need To Regenerate ( ) || get Need To Reposition ( ) || ! is Visible ( ) ) { return ; } boolean small World = bitmap != null && corners != null && corners . size ( ) >= NUM ; if ( small World ) { float [ ] xs = corners . get ( NUM ) ; float [ ] ys = corners . get ( NUM ) ; Point point 1 = new Point ( ) ; point 1 . set Location ( ( double ) xs [ NUM ] , ( double ) ys [ NUM ] ) ; Point point 2 = new Point ( ) ; point 2 . set Location ( ( double ) xs [ NUM ] , ( double ) ys [ NUM ] ) ; Graphics g = graphics . create ( ) ; if ( g instanceof Graphics 2 D && render Rotation Angle != null ) { rotate ( ( Graphics 2 D ) g ) ; } render Image ( g , bitmap , point 1 ) ; } super . render ( graphics ) ; }
public Input Stream execute Download ( String url , String cookie ) throws IO Exception { String [ ] [ ] header Params = new String [ ] [ ] { { STRING , cookie } , { STRING , STRING } } ; Http Entity http Entity = execute Get ( url , null , header Params ) ; return http Entity . get Content ( ) ; }
public Input Stream execute Download ( String url , String cookie ) throws IO Exception { String [ ] [ ] header Params = new String [ ] [ ] { { STRING , cookie } , { STRING , STRING } } ; Http Entity http Entity = execute Get ( url , null , header Params ) ; return http Entity . get Content ( ) ; }
@ After Class public static void after Class Base Test ( ) throws SQL Exception { if ( test Single Host ) { if ( ! shared Connection . is Closed ( ) ) { if ( ! temp View List . is Empty ( ) ) { Statement stmt = shared Connection . create Statement ( ) ; String view Name ; while ( ( view Name = temp View List . poll ( ) ) != null ) { try { stmt . execute ( STRING + view Name ) ; } catch ( SQL Exception e ) { } } } if ( ! temp Table List . is Empty ( ) ) { Statement stmt = shared Connection . create Statement ( ) ; String table Name ; while ( ( table Name = temp Table List . poll ( ) ) != null ) { try { stmt . execute ( STRING + table Name ) ; } catch ( SQL Exception e ) { } } } if ( ! temp Procedure List . is Empty ( ) ) { Statement stmt = shared Connection . create Statement ( ) ; String procedure Name ; while ( ( procedure Name = temp Procedure List . poll ( ) ) != null ) { try { stmt . execute ( STRING + procedure Name ) ; } catch ( SQL Exception e ) { } } } if ( ! temp Function List . is Empty ( ) ) { Statement stmt = shared Connection . create Statement ( ) ; String function Name ; while ( ( function Name = temp Function List . poll ( ) ) != null ) { try { stmt . execute ( STRING + function Name ) ; } catch ( SQL Exception e ) { } } } } try { shared Connection . close ( ) ; } catch ( SQL Exception e ) { e . print Stack Trace ( ) ; } } }
private void update Header Row ( ) { int header Row = ( int ) header Row Spinner . get Value ( ) ; configuration . set Header Row ( header Row - NUM ) ; preview Table . repaint ( ) ; }
protected String indent ( String content , int count , String indent Str ) { String result ; String Tokenizer tok ; int i ; tok = new String Tokenizer ( content , STRING , BOOL ) ; result = STRING ; while ( tok . has More Tokens ( ) ) { if ( result . ends With ( STRING ) || ( result . length ( ) == NUM ) ) { for ( i = NUM ; i < count ; i ++ ) { result += indent Str ; } } result += tok . next Token ( ) ; } return result ; }
public Multiplex Manager ( Data Store ... data Stores ) { this . data Stores = Arrays . as List ( data Stores ) ; }
public Multiplex Manager ( Data Store ... data Stores ) { this . data Stores = Arrays . as List ( data Stores ) ; }
public Multiplex Manager ( Data Store ... data Stores ) { this . data Stores = Arrays . as List ( data Stores ) ; }
public void remove Attribute Defaults ( Set attrs ) throws SMS Exception , SSO Exception { SMS Entry . validate Token ( ssm . get SSO Token ( ) ) ; Iterator it = attrs . iterator ( ) ; while ( it . has Next ( ) ) { String as Name = ( String ) it . next ( ) ; Attribute Schema as = get Attribute Schema ( as Name ) ; if ( as == null ) { throw ( new Invalid Attribute Name Exception ( IUMS Constants . UMS BUNDLE NAME , IUMS Constants . services validator invalid attr name , null ) ) ; } as . remove Default Values ( ) ; } }
public I Prepared Graph Query prepare Graph Query ( final String query ) throws Exception { return prepare Graph Query ( query , UUID . random UUID ( ) ) ; }
private Rectangle 2 D [ ] split Horizontal Bar ( Rectangular Shape bar , double a , double b , double c ) { Rectangle 2 D [ ] result = new Rectangle 2 D [ NUM ] ; double y0 = bar . get Min Y ( ) ; double y1 = Math . rint ( y0 + ( bar . get Height ( ) * a ) ) ; double y2 = Math . rint ( y0 + ( bar . get Height ( ) * b ) ) ; double y3 = Math . rint ( y0 + ( bar . get Height ( ) * c ) ) ; result [ NUM ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , bar . get Min Y ( ) , bar . get Width ( ) , y1 - y0 ) ; result [ NUM ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , y1 , bar . get Width ( ) , y2 - y1 ) ; result [ NUM ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , y2 , bar . get Width ( ) , y3 - y2 ) ; result [ NUM ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , y3 , bar . get Width ( ) , bar . get Max Y ( ) - y3 ) ; return result ; }
private Rectangle 2 D [ ] split Horizontal Bar ( Rectangular Shape bar , double a , double b , double c ) { Rectangle 2 D [ ] result = new Rectangle 2 D [ NUM ] ; double y0 = bar . get Min Y ( ) ; double y1 = Math . rint ( y0 + ( bar . get Height ( ) * a ) ) ; double y2 = Math . rint ( y0 + ( bar . get Height ( ) * b ) ) ; double y3 = Math . rint ( y0 + ( bar . get Height ( ) * c ) ) ; result [ NUM ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , bar . get Min Y ( ) , bar . get Width ( ) , y1 - y0 ) ; result [ NUM ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , y1 , bar . get Width ( ) , y2 - y1 ) ; result [ NUM ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , y2 , bar . get Width ( ) , y3 - y2 ) ; result [ NUM ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , y3 , bar . get Width ( ) , bar . get Max Y ( ) - y3 ) ; return result ; }
private Rectangle 2 D [ ] split Horizontal Bar ( Rectangular Shape bar , double a , double b , double c ) { Rectangle 2 D [ ] result = new Rectangle 2 D [ NUM ] ; double y0 = bar . get Min Y ( ) ; double y1 = Math . rint ( y0 + ( bar . get Height ( ) * a ) ) ; double y2 = Math . rint ( y0 + ( bar . get Height ( ) * b ) ) ; double y3 = Math . rint ( y0 + ( bar . get Height ( ) * c ) ) ; result [ NUM ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , bar . get Min Y ( ) , bar . get Width ( ) , y1 - y0 ) ; result [ NUM ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , y1 , bar . get Width ( ) , y2 - y1 ) ; result [ NUM ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , y2 , bar . get Width ( ) , y3 - y2 ) ; result [ NUM ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , y3 , bar . get Width ( ) , bar . get Max Y ( ) - y3 ) ; return result ; }
public boolean equals ( int ignore Own Element , Sequence sequence , int ignore Its Element ) { int own Index = NUM ; int its Index = NUM ; Iterator < Item > own Iterator = item Iterator ( ) ; Iterator < Item > its Iterator = sequence . item Iterator ( ) ; while ( BOOL ) { if ( ignore Own Element == own Index ) { own Iterator . next ( ) ; own Index ++ ; } if ( ignore Its Element == its Index ) { its Iterator . next ( ) ; its Index ++ ; } if ( ! own Iterator . has Next ( ) || ! its Iterator . has Next ( ) ) { if ( ! own Iterator . has Next ( ) && ! its Iterator . has Next ( ) ) { return BOOL ; } return BOOL ; } Item own Item = own Iterator . next ( ) ; Item its Item = its Iterator . next ( ) ; own Index ++ ; its Index ++ ; if ( ! own Item . equals ( its Item ) ) { return BOOL ; } } }
public static String each Match ( String self , Pattern pattern , @ Closure Params ( value = From String . class , options = { STRING , STRING } ) Closure closure ) { Matcher m = pattern . matcher ( self ) ; each ( m , closure ) ; return self ; }
public static String each Match ( String self , Pattern pattern , @ Closure Params ( value = From String . class , options = { STRING , STRING } ) Closure closure ) { Matcher m = pattern . matcher ( self ) ; each ( m , closure ) ; return self ; }
public static String each Match ( String self , Pattern pattern , @ Closure Params ( value = From String . class , options = { STRING , STRING } ) Closure closure ) { Matcher m = pattern . matcher ( self ) ; each ( m , closure ) ; return self ; }
public static String each Match ( String self , Pattern pattern , @ Closure Params ( value = From String . class , options = { STRING , STRING } ) Closure closure ) { Matcher m = pattern . matcher ( self ) ; each ( m , closure ) ; return self ; }
public void del Item ( int index ) { synchronized ( get Menu Tree Lock ( ) ) { if ( selected Index == index ) { select Item ( null , BOOL ) ; } else if ( selected Index > index ) { selected Index -- ; } if ( index < items . size ( ) ) { items . remove ( index ) ; } else { if ( log . is Loggable ( Platform Logger . Level . FINE ) ) { log . fine ( STRING + index + STRING + items . size ( ) ) ; } } } update Size ( ) ; }
protected Socket open Passive Data Connection ( int command , String arg ) throws IO Exception , Ftp Exception Can Not Have Data Connection { Socket socket ; if ( pasv ( ) != FTP Reply . ENTERING PASSIVE MODE ) throw new Ftp Exception Can Not Have Data Connection ( STRING + get Reply String ( ) ) ; try { parse Passive Mode Reply ( get Reply Strings ( ) [ NUM ] ) ; } catch ( Malformed Server Reply Exception e ) { throw new Ftp Exception Can Not Have Data Connection ( e . get Message ( ) ) ; } socket = socket Factory . create Socket ( passive Host , passive Port ) ; if ( ! FTP Reply . is Positive Preliminary ( send Command ( command , arg ) ) ) { socket . close ( ) ; return null ; } if ( remote Verification Enabled && ! verify Remote ( socket ) ) { Inet Address host 1 , host 2 ; host 1 = socket . get Inet Address ( ) ; host 2 = get Remote Address ( ) ; socket . close ( ) ; throw new Ftp Exception Can Not Have Data Connection ( STRING + host 1 . get Host Address ( ) + STRING + host 2 . get Host Address ( ) + STRING ) ; } if ( data Timeout >= NUM ) socket . set So Timeout ( data Timeout ) ; return socket ; }
protected long release Memory ( ) { long memory Freed = NUM ; while ( ! windows For Free Memory . is Empty ( ) ) { long window Id = windows For Free Memory . poll ( ) ; long origin Size = key Stream . size ( ) + value Stream . size ( ) ; key Stream . complete Window ( window Id ) ; value Stream . complete Window ( window Id ) ; memory Freed += origin Size - ( key Stream . size ( ) + value Stream . size ( ) ) ; } if ( memory Freed > NUM ) { LOG . debug ( STRING , memory Freed ) ; size In Bytes . get And Add ( - memory Freed ) ; } return memory Freed ; }
static Unix Stream < String > cat ( final String file Path ) throws IO Exception { Objects . require Non Null ( file Path , STRING ) ; return new Unix Stream Impl < > ( lines ( Paths . get ( file Path ) ) ) ; }
public static String read And Close Quietly ( Input Stream input Stream ) throws IO Exception { try { return read Stream ( input Stream ) ; } catch ( IO Exception e ) { LOG . error ( e . get Localized Message ( ) , e ) ; throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch ( IO Exception e ) { LOG . error ( e . get Localized Message ( ) , e ) ; } } } }
public AM Service Profile Model Impl ( Http Servlet Request req , String service Name , Map map ) throws AM Console Exception { super ( req , map ) ; this . service Name = service Name ; try { xml Builder = new Property XML Builder ( service Name , get Display Schema Types ( ) , this ) ; if ( service Name . equals ( ADMIN CONSOLE SERVICE ) && Service Manager . is Realm Enabled ( ) ) { AM View Config config = AM View Config . get Instance ( ) ; xml Builder . discard Attribute ( config . get Realm Enable Hidden Console Attr Names ( ) ) ; } } catch ( SMS Exception e ) { throw new AM Console Exception ( get Error String ( e ) ) ; } catch ( SSO Exception e ) { throw new AM Console Exception ( get Error String ( e ) ) ; } }
public AM Service Profile Model Impl ( Http Servlet Request req , String service Name , Map map ) throws AM Console Exception { super ( req , map ) ; this . service Name = service Name ; try { xml Builder = new Property XML Builder ( service Name , get Display Schema Types ( ) , this ) ; if ( service Name . equals ( ADMIN CONSOLE SERVICE ) && Service Manager . is Realm Enabled ( ) ) { AM View Config config = AM View Config . get Instance ( ) ; xml Builder . discard Attribute ( config . get Realm Enable Hidden Console Attr Names ( ) ) ; } } catch ( SMS Exception e ) { throw new AM Console Exception ( get Error String ( e ) ) ; } catch ( SSO Exception e ) { throw new AM Console Exception ( get Error String ( e ) ) ; } }
public AM Service Profile Model Impl ( Http Servlet Request req , String service Name , Map map ) throws AM Console Exception { super ( req , map ) ; this . service Name = service Name ; try { xml Builder = new Property XML Builder ( service Name , get Display Schema Types ( ) , this ) ; if ( service Name . equals ( ADMIN CONSOLE SERVICE ) && Service Manager . is Realm Enabled ( ) ) { AM View Config config = AM View Config . get Instance ( ) ; xml Builder . discard Attribute ( config . get Realm Enable Hidden Console Attr Names ( ) ) ; } } catch ( SMS Exception e ) { throw new AM Console Exception ( get Error String ( e ) ) ; } catch ( SSO Exception e ) { throw new AM Console Exception ( get Error String ( e ) ) ; } }
public Web View Local Server ( Context context ) { this ( new Android Protocol Handler ( context . get Application Context ( ) ) ) ; }
private boolean is Noun ( String word ) { if ( nouns == null ) return BOOL ; return nouns . contains ( word . to Lower Case ( ) ) ; }
private boolean is Noun ( String word ) { if ( nouns == null ) return BOOL ; return nouns . contains ( word . to Lower Case ( ) ) ; }
public void part Channel ( String channel ) { if ( ! channel . starts With ( STRING ) ) { channel = STRING + channel ; } send ( STRING + channel ) ; }
public void part Channel ( String channel ) { if ( ! channel . starts With ( STRING ) ) { channel = STRING + channel ; } send ( STRING + channel ) ; }
public Date random Date ( ) { if ( random . next Int ( NUM ) == NUM ) { return null ; } String Builder buff = new String Builder ( ) ; buff . append ( get Int ( NUM ) + NUM ) ; buff . append ( STRING ) ; int month = get Int ( NUM ) + NUM ; if ( month < NUM ) { buff . append ( STRING ) ; } buff . append ( month ) ; buff . append ( STRING ) ; int day = get Int ( NUM ) + NUM ; if ( day < NUM ) { buff . append ( STRING ) ; } buff . append ( day ) ; return Date . value Of ( buff . to String ( ) ) ; }
public void register Fm Radio Listener ( Fm Radio Listener callback ) { synchronized ( m Records ) { Record record = null ; int hash Code = callback . hash Code ( ) ; final int n = m Records . size ( ) ; for ( int i = NUM ; i < n ; i ++ ) { record = m Records . get ( i ) ; if ( hash Code == record . m Hash Code ) { return ; } } record = new Record ( ) ; record . m Hash Code = hash Code ; record . m Callback = callback ; m Records . add ( record ) ; } }
public void register Fm Radio Listener ( Fm Radio Listener callback ) { synchronized ( m Records ) { Record record = null ; int hash Code = callback . hash Code ( ) ; final int n = m Records . size ( ) ; for ( int i = NUM ; i < n ; i ++ ) { record = m Records . get ( i ) ; if ( hash Code == record . m Hash Code ) { return ; } } record = new Record ( ) ; record . m Hash Code = hash Code ; record . m Callback = callback ; m Records . add ( record ) ; } }
public void make Immutable ( ) { if ( is Mutable ) { is Mutable = BOOL ; } }
private int cross Check Get Columns And Result Set Meta Data ( Result Set rs , boolean partial ) throws SQL Exception { Statement s = conn . create Statement ( ) ; while ( rs . next ( ) ) { String schema = rs . get String ( STRING ) ; String table = rs . get String ( STRING ) ; Result Set rst = s . execute Query ( STRING + schema + STRING + table ) ; Result Set Meta Data rsmdt = rst . get Meta Data ( ) ; for ( int col = NUM ; col <= rsmdt . get Column Count ( ) ; col ++ ) { if ( ! partial ) { if ( col != NUM ) assert True ( rs . next ( ) ) ; assert Equals ( STRING , col , rs . get Int ( STRING ) ) ; } assert Equals ( STRING , STRING , rs . get String ( STRING ) ) ; assert Equals ( STRING , schema , rs . get String ( STRING ) ) ; assert Equals ( STRING , table , rs . get String ( STRING ) ) ; cross Check Get Column Row And Result Set Meta Data ( rs , rsmdt ) ; if ( partial ) break ; } rst . close ( ) ; } int count = rs . get Row ( ) ; rs . close ( ) ; s . close ( ) ; return count ; }
private int cross Check Get Columns And Result Set Meta Data ( Result Set rs , boolean partial ) throws SQL Exception { Statement s = conn . create Statement ( ) ; while ( rs . next ( ) ) { String schema = rs . get String ( STRING ) ; String table = rs . get String ( STRING ) ; Result Set rst = s . execute Query ( STRING + schema + STRING + table ) ; Result Set Meta Data rsmdt = rst . get Meta Data ( ) ; for ( int col = NUM ; col <= rsmdt . get Column Count ( ) ; col ++ ) { if ( ! partial ) { if ( col != NUM ) assert True ( rs . next ( ) ) ; assert Equals ( STRING , col , rs . get Int ( STRING ) ) ; } assert Equals ( STRING , STRING , rs . get String ( STRING ) ) ; assert Equals ( STRING , schema , rs . get String ( STRING ) ) ; assert Equals ( STRING , table , rs . get String ( STRING ) ) ; cross Check Get Column Row And Result Set Meta Data ( rs , rsmdt ) ; if ( partial ) break ; } rst . close ( ) ; } int count = rs . get Row ( ) ; rs . close ( ) ; s . close ( ) ; return count ; }
public synchronized void incubate ( T o ) { if ( o == null ) throw new Illegal Argument Exception ( STRING ) ; if ( hatch Map . contains Key ( o ) ) throw new Illegal Argument Exception ( o + STRING ) ; hatch Map . put ( o , o ) ; order List . add Last ( o ) ; notify All ( ) ; }
public void execute ( ) { final R Timer timer = new R Timer ( ) ; if ( DATA MODE FILES . equals ( mode ) && args . length > NUM ) { do Files Mode ( ) ; } else if ( DATA MODE ARGS . equals ( mode ) && args . length > NUM ) { do Args Mode ( ) ; } else if ( DATA MODE WEB . equals ( mode ) && args . length > NUM ) { do Web Mode ( ) ; } else if ( DATA MODE STDIN . equals ( mode ) ) { do Stdin Mode ( ) ; } else { usage Short ( ) ; return ; } if ( commit ) commit ( ) ; if ( optimize ) optimize ( ) ; display Timing ( ( long ) timer . get Time ( ) ) ; }
protected Cmap Table ( ) { super ( True Type Table . CMAP TABLE ) ; set Version ( ( short ) NUM ) ; subtables = Collections . synchronized Sorted Map ( new Tree Map < Cmap Subtable , C Map > ( ) ) ; }
private static Pair < String , String > generate Sign Mask ( final I Translation Environment environment , long offset , final String value , final Operand Size size , final List < Reil Instruction > instructions ) { final String msb Mask = String . value Of ( Translation Helpers . get Msb Mask ( size ) ) ; final String shift Value = String . value Of ( Translation Helpers . get Shift Msb Lsb Mask ( size ) ) ; final String masked Msb = environment . get Next Variable String ( ) ; final String msb In Lsb = environment . get Next Variable String ( ) ; final String sign Mask = environment . get Next Variable String ( ) ; instructions . add ( Reil Helpers . create And ( offset ++ , size , value , size , msb Mask , size , masked Msb ) ) ; instructions . add ( Reil Helpers . create Bsh ( offset ++ , size , masked Msb , size , shift Value , size , msb In Lsb ) ) ; instructions . add ( Reil Helpers . create Sub ( offset ++ , size , STRING , size , msb In Lsb , size , sign Mask ) ) ; return new Pair < String , String > ( msb In Lsb , sign Mask ) ; }
private static Pair < String , String > generate Sign Mask ( final I Translation Environment environment , long offset , final String value , final Operand Size size , final List < Reil Instruction > instructions ) { final String msb Mask = String . value Of ( Translation Helpers . get Msb Mask ( size ) ) ; final String shift Value = String . value Of ( Translation Helpers . get Shift Msb Lsb Mask ( size ) ) ; final String masked Msb = environment . get Next Variable String ( ) ; final String msb In Lsb = environment . get Next Variable String ( ) ; final String sign Mask = environment . get Next Variable String ( ) ; instructions . add ( Reil Helpers . create And ( offset ++ , size , value , size , msb Mask , size , masked Msb ) ) ; instructions . add ( Reil Helpers . create Bsh ( offset ++ , size , masked Msb , size , shift Value , size , msb In Lsb ) ) ; instructions . add ( Reil Helpers . create Sub ( offset ++ , size , STRING , size , msb In Lsb , size , sign Mask ) ) ; return new Pair < String , String > ( msb In Lsb , sign Mask ) ; }
public double sigmoid ( double z ) { double answer = NUM ; if ( z >= max Exponent ) return NUM ; else if ( z <= - max Exponent ) return NUM ; else { double index = table Size * Math . abs ( z ) / ( double ) max Exponent ; answer = sigmoid Table [ ( int ) index ] ; if ( z < NUM ) answer = NUM - answer ; } return answer ; }
public static Left Regular Bipartite Graph Segment build Random Left Regular Bipartite Graph ( int left Size , int right Size , int left Degree , Random random ) { Left Regular Bipartite Graph Segment left Regular Bipartite Graph Segment = new Left Regular Bipartite Graph Segment ( left Size / NUM , left Degree , right Size / NUM , left Size / NUM , NUM , Integer . MAX VALUE , new Identity Edge Type Mask ( ) , new Null Stats Receiver ( ) ) ; Long Set added Ids = new Long Open Hash Set ( left Degree ) ; for ( int i = NUM ; i < left Size ; i ++ ) { added Ids . clear ( ) ; for ( int j = NUM ; j < left Degree ; j ++ ) { long id To Add ; do { id To Add = random . next Int ( right Size ) ; } while ( added Ids . contains ( id To Add ) ) ; added Ids . add ( id To Add ) ; left Regular Bipartite Graph Segment . add Edge ( i , id To Add , ( byte ) NUM ) ; } } return left Regular Bipartite Graph Segment ; }
private void send Trap Pdu ( Inet Address addr , Snmp Pdu Packet pdu ) throws Snmp Status Exception , IO Exception { Snmp Message msg = null ; try { msg = ( Snmp Message ) pdu Factory . encode Snmp Pdu ( pdu , buffer Size ) ; if ( msg == null ) { throw new Snmp Status Exception ( Snmp Definitions . snmp Rsp Authorization Error ) ; } } catch ( Snmp Too Big Exception x ) { if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINEST ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINEST , dbg Tag , STRING , STRING + STRING ) ; } throw new Snmp Status Exception ( Snmp Definitions . snmp Rsp Too Big ) ; } open Trap Socket If Needed ( ) ; if ( addr != null ) { msg . address = addr ; try { send Trap Message ( msg ) ; } catch ( Snmp Too Big Exception x ) { if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINEST ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINEST , dbg Tag , STRING , STRING + STRING + msg . address ) ; } } } close Trap Socket If Needed ( ) ; }
@ POST @ Consumes ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Produces ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Check Permission ( roles = { Role . TENANT ADMIN } ) @ Path ( STRING ) public Ip Interface Rest Rep create Ip Interface ( @ Path Param ( STRING ) URI id , Ip Interface Create Param create Param ) throws Database Exception { Host host = query Object ( Host . class , id , BOOL ) ; validate Ip Interface Data ( create Param , null ) ; Ip Interface ip Interface = new Ip Interface ( ) ; ip Interface . set Host ( host . get Id ( ) ) ; ip Interface . set Id ( URI Util . create Id ( Ip Interface . class ) ) ; populate Ip Interface ( create Param , ip Interface ) ; db Client . create Object ( ip Interface ) ; audit Op ( Operation Type Enum . CREATE HOST IPINTERFACE , BOOL , null , ip Interface . audit Parameters ( ) ) ; return map ( ip Interface ) ; }
public static Symbol Variant symbol Variant ( Char Sequence symbol ) { int length = symbol . length ( ) ; if ( length == NUM ) { throw new Empty Symbol Exception ( ) ; } if ( is Identifier Keyword ( symbol ) ) { return Symbol Variant . QUOTED ; } char c = symbol . char At ( NUM ) ; if ( is Identifier Start ( c ) ) { for ( int ii = NUM ; ii < length ; ii ++ ) { c = symbol . char At ( ii ) ; if ( ( c == STRING || c < NUM || c > NUM ) || ! is Identifier Part ( c ) ) { return Symbol Variant . QUOTED ; } } return Symbol Variant . IDENTIFIER ; } if ( is Operator Part ( c ) ) { for ( int ii = NUM ; ii < length ; ii ++ ) { c = symbol . char At ( ii ) ; if ( ! is Operator Part ( c ) ) { return Symbol Variant . QUOTED ; } } return Symbol Variant . OPERATOR ; } return Symbol Variant . QUOTED ; }
private void add Object Permissions ( Map < String , Set < Object Permission . Type > > permissions , Object Permission Set perm Set ) throws Guacamole Exception { for ( Object Permission permission : perm Set . get Permissions ( ) ) { String identifier = permission . get Object Identifier ( ) ; Set < Object Permission . Type > object Permissions = permissions . get ( identifier ) ; if ( object Permissions == null ) permissions . put ( identifier , Enum Set . of ( permission . get Type ( ) ) ) ; else object Permissions . add ( permission . get Type ( ) ) ; } }
public Live Ref ( Obj ID obj ID , int port ) { this ( obj ID , TCP Endpoint . get Local Endpoint ( port ) , BOOL ) ; }
public Live Ref ( Obj ID obj ID , int port ) { this ( obj ID , TCP Endpoint . get Local Endpoint ( port ) , BOOL ) ; }
public static void throw Exception ( Throwable t ) { if ( UNSAFE != null ) { UNSAFE . throw Exception ( t ) ; } else { J Unsafe . < Runtime Exception > throw Exception 0 ( t ) ; } }
public static void throw Exception ( Throwable t ) { if ( UNSAFE != null ) { UNSAFE . throw Exception ( t ) ; } else { J Unsafe . < Runtime Exception > throw Exception 0 ( t ) ; } }
public List < Save Result > check Results ( Bulk Connection bulk Connection , Job Info job , List < Batch Info > batch Info List ) throws Async Api Exception , IO Exception { LOG . debug ( STRING ) ; List < Save Result > save Results = new Array List < Save Result > ( ) ; for ( Batch Info batch Info : batch Info List ) { CSV Reader csv Reader For Batch Result Stream = new CSV Reader ( bulk Connection . get Batch Result Stream ( job . get Id ( ) , batch Info . get Id ( ) ) ) ; List < String > result Header = csv Reader For Batch Result Stream . next Record ( ) ; int result Cols = result Header . size ( ) ; List < String > batch Result Stream = null ; while ( ( batch Result Stream = csv Reader For Batch Result Stream . next Record ( ) ) != null ) { Map < String , String > result Info = new Hash Map < String , String > ( ) ; for ( int i = NUM ; i < result Cols ; i ++ ) { result Info . put ( result Header . get ( i ) , batch Result Stream . get ( i ) ) ; } Save Result sr = new Save Result ( ) ; sr . set Id ( result Info . get ( STRING ) ) ; boolean success = Boolean . value Of ( result Info . get ( STRING ) ) ; sr . set Success ( success ) ; if ( ! success ) { if ( result Info . get ( STRING ) != null && String Utils . is Not Empty ( result Info . get ( STRING ) ) ) { Apex Unit Utils . shut Down With Err Msg ( STRING + result Info . get ( STRING ) ) ; } } save Results . add ( sr ) ; } } return save Results ; }
public static double euclidean Distance ( double [ ] p , double [ ] q ) { double ret = NUM ; for ( int i = NUM ; i < p . length ; i ++ ) { double diff = ( q [ i ] - p [ i ] ) ; double sq = Math . pow ( diff , NUM ) ; ret += sq ; } return ret ; }
public static double calculate P Value ( double t , int v ) { return NUM * ( NUM - Students T Distribution . cdf ( Math . abs ( t ) , v ) ) ; }
public void do Layout ( ) { for ( int i = NUM ; i < get Component Count ( ) ; i ++ ) { Marker m = ( Marker ) get Component ( i ) ; m . update Location ( ) ; } listener . caret Update ( null ) ; }
public void do Layout ( ) { for ( int i = NUM ; i < get Component Count ( ) ; i ++ ) { Marker m = ( Marker ) get Component ( i ) ; m . update Location ( ) ; } listener . caret Update ( null ) ; }
public void do Layout ( ) { for ( int i = NUM ; i < get Component Count ( ) ; i ++ ) { Marker m = ( Marker ) get Component ( i ) ; m . update Location ( ) ; } listener . caret Update ( null ) ; }
public void do Layout ( ) { for ( int i = NUM ; i < get Component Count ( ) ; i ++ ) { Marker m = ( Marker ) get Component ( i ) ; m . update Location ( ) ; } listener . caret Update ( null ) ; }
public static Map parse Command Line Arguments ( String [ ] args ) { Map < String , String > result = new Hash Map < String , String > ( ) ; String key , value ; for ( int i = NUM ; i < args . length ; i ++ ) { key = args [ i ] ; if ( key . char At ( NUM ) == STRING ) { if ( i + NUM < args . length ) { value = args [ i + NUM ] ; if ( value . char At ( NUM ) != STRING ) { result . put ( key , value ) ; i ++ ; } else { result . put ( key , null ) ; } } else { result . put ( key , null ) ; } } } return result ; }
protected void add Line ( Print Writer file , String string ) { log . debug ( string ) ; if ( file != null ) { file . println ( string ) ; } }
int read Int ( ) throws IO Exception { m Dex File . read Fully ( tmp Buf , NUM , NUM ) ; if ( is Big Endian ) { return ( tmp Buf [ NUM ] & NUM ) | ( ( tmp Buf [ NUM ] & NUM ) << NUM ) | ( ( tmp Buf [ NUM ] & NUM ) << NUM ) | ( ( tmp Buf [ NUM ] & NUM ) << NUM ) ; } else { return ( tmp Buf [ NUM ] & NUM ) | ( ( tmp Buf [ NUM ] & NUM ) << NUM ) | ( ( tmp Buf [ NUM ] & NUM ) << NUM ) | ( ( tmp Buf [ NUM ] & NUM ) << NUM ) ; } }
public int read ( ) throws IO Exception { int ch 1 = is . read ( ) ; switch ( ch 1 ) { case NUM : return STRING ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return NUM ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return NUM ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return STRING ; case NUM : case NUM : return STRING ; case NUM : case NUM : return STRING ; case NUM : return STRING ; case NUM : case NUM : return STRING ; case NUM : return STRING ; case NUM : return NUM ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return STRING ; default : return ch 1 ; } }
public int read ( ) throws IO Exception { int ch 1 = is . read ( ) ; switch ( ch 1 ) { case NUM : return STRING ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return NUM ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return NUM ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return STRING ; case NUM : case NUM : return STRING ; case NUM : case NUM : return STRING ; case NUM : return STRING ; case NUM : case NUM : return STRING ; case NUM : return STRING ; case NUM : return NUM ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return STRING ; default : return ch 1 ; } }
public int read ( ) throws IO Exception { int ch 1 = is . read ( ) ; switch ( ch 1 ) { case NUM : return STRING ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return NUM ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return NUM ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return STRING ; case NUM : case NUM : return STRING ; case NUM : case NUM : return STRING ; case NUM : return STRING ; case NUM : case NUM : return STRING ; case NUM : return STRING ; case NUM : return NUM ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return STRING ; case NUM : return STRING ; default : return ch 1 ; } }
public static String sort Key ( String key ) { if ( key != null ) { String [ ] ids = key . split ( DIMENSION SEP ) ; Collections . sort ( Arrays . as List ( ids ) ) ; key = String Utils . join ( ids , DIMENSION SEP ) ; } return key ; }
private static List < Cookie > remove Local Load Balancing Cookie ( final List < Cookie > cookies ) { final String lbl Cookie Name = getlb Cookie Name ( ) ; final String lbl Cookie Value = getlb Cookie Value ( ) ; final List < Cookie > filtered Cookies = new Array List < > ( ) ; for ( final Cookie cookie : cookies ) { if ( ! Objects . equals ( cookie . get Name ( ) , lbl Cookie Name ) && ! Objects . equals ( cookie . get Value ( ) , lbl Cookie Value ) ) { filtered Cookies . add ( cookie ) ; } } return filtered Cookies ; }
private static List < Cookie > remove Local Load Balancing Cookie ( final List < Cookie > cookies ) { final String lbl Cookie Name = getlb Cookie Name ( ) ; final String lbl Cookie Value = getlb Cookie Value ( ) ; final List < Cookie > filtered Cookies = new Array List < > ( ) ; for ( final Cookie cookie : cookies ) { if ( ! Objects . equals ( cookie . get Name ( ) , lbl Cookie Name ) && ! Objects . equals ( cookie . get Value ( ) , lbl Cookie Value ) ) { filtered Cookies . add ( cookie ) ; } } return filtered Cookies ; }
private static List < Cookie > remove Local Load Balancing Cookie ( final List < Cookie > cookies ) { final String lbl Cookie Name = getlb Cookie Name ( ) ; final String lbl Cookie Value = getlb Cookie Value ( ) ; final List < Cookie > filtered Cookies = new Array List < > ( ) ; for ( final Cookie cookie : cookies ) { if ( ! Objects . equals ( cookie . get Name ( ) , lbl Cookie Name ) && ! Objects . equals ( cookie . get Value ( ) , lbl Cookie Value ) ) { filtered Cookies . add ( cookie ) ; } } return filtered Cookies ; }
public void close ( ) throws IO Exception { rafile . close ( ) ; }
public void purge And Notify Removed Layers ( ) { Array List < Layer > r Layers = new Array List < Layer > ( removed Layers ) ; removed Layers . clear ( ) ; if ( r Layers . is Empty ( ) ) { return ; } for ( Layer layer : r Layers ) { layer . removed ( this ) ; } if ( Debug . debugging ( STRING ) ) { System . gc ( ) ; } }
public void purge And Notify Removed Layers ( ) { Array List < Layer > r Layers = new Array List < Layer > ( removed Layers ) ; removed Layers . clear ( ) ; if ( r Layers . is Empty ( ) ) { return ; } for ( Layer layer : r Layers ) { layer . removed ( this ) ; } if ( Debug . debugging ( STRING ) ) { System . gc ( ) ; } }
public void purge And Notify Removed Layers ( ) { Array List < Layer > r Layers = new Array List < Layer > ( removed Layers ) ; removed Layers . clear ( ) ; if ( r Layers . is Empty ( ) ) { return ; } for ( Layer layer : r Layers ) { layer . removed ( this ) ; } if ( Debug . debugging ( STRING ) ) { System . gc ( ) ; } }
public void purge And Notify Removed Layers ( ) { Array List < Layer > r Layers = new Array List < Layer > ( removed Layers ) ; removed Layers . clear ( ) ; if ( r Layers . is Empty ( ) ) { return ; } for ( Layer layer : r Layers ) { layer . removed ( this ) ; } if ( Debug . debugging ( STRING ) ) { System . gc ( ) ; } }
private Spannable highlight User Handles ( Spannable text ) { if ( text == null ) { return null ; } final Matcher matcher = PATTERN USER HANDLES . matcher ( text ) ; while ( matcher . find ( ) ) { final int start = matcher . start ( NUM ) ; final int end = matcher . end ( NUM ) ; text . set Span ( new Foreground Color Span ( m Highlight Color ) , start , end , Spanned . SPAN EXCLUSIVE EXCLUSIVE ) ; text . set Span ( new Style Span ( android . graphics . Typeface . BOLD ) , start , end , Spanned . SPAN EXCLUSIVE EXCLUSIVE ) ; } return text ; }
private void init Auth Service Global Settings ( ) throws Exception { Service Schema Manager scm = new Service Schema Manager ( IS Auth Constants . AUTH SERVICE NAME , sso Auth Session ) ; update Auth Service Globals ( scm ) ; new Auth Config Monitor ( scm ) ; }
public static String escape Regex ( final String regex ) { Matcher match = REGEX CHARS . matcher ( regex ) ; return match . replace All ( STRING ) ; }
public static String escape Regex ( final String regex ) { Matcher match = REGEX CHARS . matcher ( regex ) ; return match . replace All ( STRING ) ; }
public static String escape Regex ( final String regex ) { Matcher match = REGEX CHARS . matcher ( regex ) ; return match . replace All ( STRING ) ; }
public static String escape Regex ( final String regex ) { Matcher match = REGEX CHARS . matcher ( regex ) ; return match . replace All ( STRING ) ; }
public static String escape Regex ( final String regex ) { Matcher match = REGEX CHARS . matcher ( regex ) ; return match . replace All ( STRING ) ; }
public static String escape Regex ( final String regex ) { Matcher match = REGEX CHARS . matcher ( regex ) ; return match . replace All ( STRING ) ; }
public void write ( String s ) throws IO Exception { write ( s , NUM , ( s != null ) ? s . length ( ) : NUM ) ; }
public void write ( String s ) throws IO Exception { write ( s , NUM , ( s != null ) ? s . length ( ) : NUM ) ; }
public void write ( String s ) throws IO Exception { write ( s , NUM , ( s != null ) ? s . length ( ) : NUM ) ; }
protected void merge Children Impl ( mx I Cell from , mx I Cell to , boolean clone All Edges , Hashtable < Object , Object > mapping ) throws Clone Not Supported Exception { begin Update ( ) ; try { int child Count = from . get Child Count ( ) ; for ( int i = NUM ; i < child Count ; i ++ ) { Object child = from . get Child At ( i ) ; if ( child instanceof mx I Cell ) { mx I Cell cell = ( mx I Cell ) child ; String id = cell . get Id ( ) ; mx I Cell target = ( mx I Cell ) ( ( id != null && ( ! is Edge ( cell ) || ! clone All Edges ) ) ? get Cell ( id ) : null ) ; if ( target == null ) { mx Cell clone = ( mx Cell ) cell . clone ( ) ; clone . set Id ( id ) ; target = ( mx I Cell ) to . insert ( clone ) ; cell Added ( target ) ; } mapping . put ( cell , target ) ; merge Children Impl ( cell , target , clone All Edges , mapping ) ; } } } finally { end Update ( ) ; } }
public int count examples ( ) { return train size ; }
private Workflow . Method create Rollback Forget Volumes Method ( URI vplex System URI , List < URI > volume UR Is ) { return new Workflow . Method ( RB FORGET VOLUMES METHOD NAME , vplex System URI , volume UR Is ) ; }
protected final Statement create Statement ( int result Set Type , int result Set Concurrency ) throws SQL Exception { return add And Return Statement ( created Statements , connection . create Statement ( result Set Type , result Set Concurrency ) ) ; }
public void parent Explotion ( int PP Product BOM ID ) throws Exception { Prepared Statement stmt = null ; Result Set rs = null ; String sql = STRING + STRING ; try { stmt = DB . prepare Statement ( sql , get Trx Name ( ) ) ; stmt . set Int ( NUM , PP Product BOM ID ) ; rs = stmt . execute Query ( ) ; while ( rs . next ( ) ) { Seq No += NUM ; X T BOM Line tboml = new X T BOM Line ( ctx , NUM , null ) ; tboml . set PP Product BOM ID ( PP Product BOM ID ) ; tboml . set PP Product BOM Line ID ( rs . get Int ( NUM ) ) ; tboml . set M Product ID ( rs . get Int ( NUM ) ) ; tboml . set Level No ( Level No ) ; tboml . set Levels ( levels . substring ( NUM , Level No ) + Level No ) ; tboml . set Seq No ( Seq No ) ; tboml . set AD P Instance ID ( AD P Instance ID ) ; tboml . set Sel Product ID ( p M Product ID ) ; tboml . set Implosion ( p implosion ) ; tboml . save ( ) ; component ( rs . get Int ( NUM ) ) ; } } catch ( SQL Exception e ) { log . log ( Level . SEVERE , e . get Localized Message ( ) + sql , e ) ; throw new Exception ( STRING + e . get Localized Message ( ) ) ; } finally { DB . close ( rs , stmt ) ; rs = null ; stmt = null ; } }
public final void walk Graph ( Hashtable h ) { }
public Extended Key Usage Extension ( Boolean critical , Vector < Object Identifier > key Usages ) throws IO Exception { this . key Usages = key Usages ; this . extension Id = PKIX Extensions . Extended Key Usage Id ; this . critical = critical . boolean Value ( ) ; encode This ( ) ; }
public void add Point ( Polygon Point p ) { p . set Previous ( last ) ; p . set Next ( last . get Next ( ) ) ; last . set Next ( p ) ; points . add ( p ) ; }
public void rotate Left ( int places , int start Index , int end Index ) { for ( int x = NUM ; x < places ; x ++ ) { rotate Left ( start Index , end Index ) ; } }
public void rotate Left ( int places , int start Index , int end Index ) { for ( int x = NUM ; x < places ; x ++ ) { rotate Left ( start Index , end Index ) ; } }
GL create GL ( ) { return m Egl Context . get GL ( ) ; }
private void adjust Day Of Week ( Calendar start Time ) { int days Diff = get Day Of Week ( ) - get Day Of Week ( start Time ) ; start Time . add ( Calendar . DAY OF WEEK , days Diff ) ; }
public Object 2 Double Open Hash Map < int [ ] > support Map ( int support Threshold ) { List < Item Set > item Sets = learn ( ) ; Object 2 Double Open Hash Map < int [ ] > support Map = new Object 2 Double Open Hash Map < > ( item Sets . size ( ) ) ; for ( Item Set item Set : item Sets ) { if ( item Set . support >= support Threshold ) { support Map . put ( item Set . items , item Set . support ) ; } } return support Map ; }
public Builder ( String host , int port ) { this . host = host ; this . port = Integer . to String ( port ) ; }
public boolean verify Matches ( Matches matches ) { int len Limit = Math . min ( get Avail ( ) , match Len Max ) ; for ( int i = NUM ; i < matches . count ; ++ i ) if ( get Match Len ( matches . dist [ i ] , len Limit ) != matches . len [ i ] ) return BOOL ; return BOOL ; }
private void show Message ( String message , boolean error ) { lbl Error . set Foreground ( error ? Color . RED : Color . BLACK ) ; lbl Error . set Text ( message ) ; }
protected Conversation Parser ( final Sentence Implementation sentence ) { String text = sentence . get Original Text ( ) ; if ( text == null ) { text = STRING ; } else if ( text . starts With ( STRING ) ) { text = STRING ; } final String text Without Punctation = detect Sentence Type ( text , sentence ) ; tokenizer = new String Tokenizer ( text Without Punctation ) ; }
public static String normalize Url ( String request Url ) throws O Auth Exception { if ( ( request Url == null ) || ( request Url . length ( ) == NUM ) ) { throw new O Auth Exception ( STRING ) ; } URI uri ; try { uri = new URI ( request Url ) ; } catch ( URI Syntax Exception e ) { throw new O Auth Exception ( e ) ; } String authority = uri . get Authority ( ) ; String scheme = uri . get Scheme ( ) ; if ( authority == null || scheme == null ) { throw new O Auth Exception ( STRING ) ; } authority = authority . to Lower Case ( ) ; scheme = scheme . to Lower Case ( ) ; if ( ( scheme . equals ( STRING ) && uri . get Port ( ) == NUM ) || ( scheme . equals ( STRING ) && uri . get Port ( ) == NUM ) ) { int index = authority . last Index Of ( STRING ) ; if ( index >= NUM ) { authority = authority . substring ( NUM , index ) ; } } return scheme + STRING + authority + uri . get Raw Path ( ) ; }
public static String normalize Url ( String request Url ) throws O Auth Exception { if ( ( request Url == null ) || ( request Url . length ( ) == NUM ) ) { throw new O Auth Exception ( STRING ) ; } URI uri ; try { uri = new URI ( request Url ) ; } catch ( URI Syntax Exception e ) { throw new O Auth Exception ( e ) ; } String authority = uri . get Authority ( ) ; String scheme = uri . get Scheme ( ) ; if ( authority == null || scheme == null ) { throw new O Auth Exception ( STRING ) ; } authority = authority . to Lower Case ( ) ; scheme = scheme . to Lower Case ( ) ; if ( ( scheme . equals ( STRING ) && uri . get Port ( ) == NUM ) || ( scheme . equals ( STRING ) && uri . get Port ( ) == NUM ) ) { int index = authority . last Index Of ( STRING ) ; if ( index >= NUM ) { authority = authority . substring ( NUM , index ) ; } } return scheme + STRING + authority + uri . get Raw Path ( ) ; }
public static String normalize Url ( String request Url ) throws O Auth Exception { if ( ( request Url == null ) || ( request Url . length ( ) == NUM ) ) { throw new O Auth Exception ( STRING ) ; } URI uri ; try { uri = new URI ( request Url ) ; } catch ( URI Syntax Exception e ) { throw new O Auth Exception ( e ) ; } String authority = uri . get Authority ( ) ; String scheme = uri . get Scheme ( ) ; if ( authority == null || scheme == null ) { throw new O Auth Exception ( STRING ) ; } authority = authority . to Lower Case ( ) ; scheme = scheme . to Lower Case ( ) ; if ( ( scheme . equals ( STRING ) && uri . get Port ( ) == NUM ) || ( scheme . equals ( STRING ) && uri . get Port ( ) == NUM ) ) { int index = authority . last Index Of ( STRING ) ; if ( index >= NUM ) { authority = authority . substring ( NUM , index ) ; } } return scheme + STRING + authority + uri . get Raw Path ( ) ; }
public static String normalize Url ( String request Url ) throws O Auth Exception { if ( ( request Url == null ) || ( request Url . length ( ) == NUM ) ) { throw new O Auth Exception ( STRING ) ; } URI uri ; try { uri = new URI ( request Url ) ; } catch ( URI Syntax Exception e ) { throw new O Auth Exception ( e ) ; } String authority = uri . get Authority ( ) ; String scheme = uri . get Scheme ( ) ; if ( authority == null || scheme == null ) { throw new O Auth Exception ( STRING ) ; } authority = authority . to Lower Case ( ) ; scheme = scheme . to Lower Case ( ) ; if ( ( scheme . equals ( STRING ) && uri . get Port ( ) == NUM ) || ( scheme . equals ( STRING ) && uri . get Port ( ) == NUM ) ) { int index = authority . last Index Of ( STRING ) ; if ( index >= NUM ) { authority = authority . substring ( NUM , index ) ; } } return scheme + STRING + authority + uri . get Raw Path ( ) ; }
protected String build Create Schema Statement ( ) throws Replicator Exception { return null ; }
protected String build Create Schema Statement ( ) throws Replicator Exception { return null ; }
private void handle End Of Stream ( State state , Inner State inner State ) throws Stop Request { m Info . m Current Bytes = inner State . m Bytes So Far ; mDB . update Download ( m Info ) ; boolean length Mismatched = ( inner State . m Header Content Length != null ) && ( inner State . m Bytes So Far != Integer . parse Int ( inner State . m Header Content Length ) ) ; if ( length Mismatched ) { if ( cannot Resume ( inner State ) ) { throw new Stop Request ( Downloader Service . STATUS CANNOT RESUME , STRING ) ; } else { throw new Stop Request ( get Final Status For Http Error ( state ) , STRING ) ; } } }
private void handle End Of Stream ( State state , Inner State inner State ) throws Stop Request { m Info . m Current Bytes = inner State . m Bytes So Far ; mDB . update Download ( m Info ) ; boolean length Mismatched = ( inner State . m Header Content Length != null ) && ( inner State . m Bytes So Far != Integer . parse Int ( inner State . m Header Content Length ) ) ; if ( length Mismatched ) { if ( cannot Resume ( inner State ) ) { throw new Stop Request ( Downloader Service . STATUS CANNOT RESUME , STRING ) ; } else { throw new Stop Request ( get Final Status For Http Error ( state ) , STRING ) ; } } }
private void handle End Of Stream ( State state , Inner State inner State ) throws Stop Request { m Info . m Current Bytes = inner State . m Bytes So Far ; mDB . update Download ( m Info ) ; boolean length Mismatched = ( inner State . m Header Content Length != null ) && ( inner State . m Bytes So Far != Integer . parse Int ( inner State . m Header Content Length ) ) ; if ( length Mismatched ) { if ( cannot Resume ( inner State ) ) { throw new Stop Request ( Downloader Service . STATUS CANNOT RESUME , STRING ) ; } else { throw new Stop Request ( get Final Status For Http Error ( state ) , STRING ) ; } } }
private void handle End Of Stream ( State state , Inner State inner State ) throws Stop Request { m Info . m Current Bytes = inner State . m Bytes So Far ; mDB . update Download ( m Info ) ; boolean length Mismatched = ( inner State . m Header Content Length != null ) && ( inner State . m Bytes So Far != Integer . parse Int ( inner State . m Header Content Length ) ) ; if ( length Mismatched ) { if ( cannot Resume ( inner State ) ) { throw new Stop Request ( Downloader Service . STATUS CANNOT RESUME , STRING ) ; } else { throw new Stop Request ( get Final Status For Http Error ( state ) , STRING ) ; } } }
public static URL [ ] parse Class Path ( ) { return parse Class Path ( System . get Property ( STRING ) ) ; }
private void init Select Position ( int position ) { if ( m Select Mode == I Selectable . SELECT MODE SINGLE ) { if ( m Selected Position == I Selectable . INVALID POSITION ) { m Selected Position = position ; } } else if ( m Select Mode == I Selectable . SELECT MODE MULTI ) { if ( ! m Selected Positions . contains ( position ) ) m Selected Positions . add ( position ) ; } else { throw new Runtime Exception ( ) ; } }
private void reset ( ) { serial Interface . if Present ( null ) ; serial Interface = Optional . empty ( ) ; cancel Read ( ) ; cancel Write ( ) ; }
private byte [ ] [ ] read Subrs ( byte [ ] d ) { return read Array ( d , STRING , STRING ) ; }
void read Bytes ( byte [ ] buffer ) throws IO Exception { m Dex File . read Fully ( buffer ) ; }
void read Bytes ( byte [ ] buffer ) throws IO Exception { m Dex File . read Fully ( buffer ) ; }
protected void apply Gradient To Paint ( ) { if ( Color . alpha ( m Series Item . get Secondary Color ( ) ) != NUM ) { int color One = m Series Item . get Spin Clockwise ( ) ? m Series Item . get Color ( ) : m Series Item . get Secondary Color ( ) ; int color Two = m Series Item . get Spin Clockwise ( ) ? m Series Item . get Secondary Color ( ) : m Series Item . get Color ( ) ; Linear Gradient gradient = new Linear Gradient ( m Bounds . left , m Bounds . top , m Bounds . right , m Bounds . bottom , color One , color Two , Shader . Tile Mode . CLAMP ) ; m Paint . set Shader ( gradient ) ; } }
protected void apply Gradient To Paint ( ) { if ( Color . alpha ( m Series Item . get Secondary Color ( ) ) != NUM ) { int color One = m Series Item . get Spin Clockwise ( ) ? m Series Item . get Color ( ) : m Series Item . get Secondary Color ( ) ; int color Two = m Series Item . get Spin Clockwise ( ) ? m Series Item . get Secondary Color ( ) : m Series Item . get Color ( ) ; Linear Gradient gradient = new Linear Gradient ( m Bounds . left , m Bounds . top , m Bounds . right , m Bounds . bottom , color One , color Two , Shader . Tile Mode . CLAMP ) ; m Paint . set Shader ( gradient ) ; } }
public Motif Split Pane Divider ( Basic Split Pane UI ui ) { super ( ui ) ; highlight Color = UI Manager . get Color ( STRING ) ; shadow Color = UI Manager . get Color ( STRING ) ; focused Color = UI Manager . get Color ( STRING ) ; set Divider Size ( h Thumb Width + pad ) ; }
@ edu . umd . cs . findbugs . annotations . Suppress FB Warnings ( value = STRING , justification = STRING ) public void change Loco Speed ( Dcc Throttle t , Section sec , float speed ) { if ( sec == referenced && speed == desired Speed Step ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } return ; } float section Length = sec . get Actual Length ( ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + sec . get Display Name ( ) ) ; } if ( sec == referenced ) { distance Remaining = distance Remaining - get Distance Travelled ( throttle . get Is Forward ( ) , throttle . get Speed Setting ( ) , ( ( float ) ( System . nano Time ( ) - last Time Timer Started ) / NUM ) ) ; section Length = distance Remaining ; } else { referenced = sec ; } change Loco Speed ( t , section Length , speed ) ; }
@ edu . umd . cs . findbugs . annotations . Suppress FB Warnings ( value = STRING , justification = STRING ) public void change Loco Speed ( Dcc Throttle t , Section sec , float speed ) { if ( sec == referenced && speed == desired Speed Step ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } return ; } float section Length = sec . get Actual Length ( ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + sec . get Display Name ( ) ) ; } if ( sec == referenced ) { distance Remaining = distance Remaining - get Distance Travelled ( throttle . get Is Forward ( ) , throttle . get Speed Setting ( ) , ( ( float ) ( System . nano Time ( ) - last Time Timer Started ) / NUM ) ) ; section Length = distance Remaining ; } else { referenced = sec ; } change Loco Speed ( t , section Length , speed ) ; }
@ edu . umd . cs . findbugs . annotations . Suppress FB Warnings ( value = STRING , justification = STRING ) public void change Loco Speed ( Dcc Throttle t , Section sec , float speed ) { if ( sec == referenced && speed == desired Speed Step ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } return ; } float section Length = sec . get Actual Length ( ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + sec . get Display Name ( ) ) ; } if ( sec == referenced ) { distance Remaining = distance Remaining - get Distance Travelled ( throttle . get Is Forward ( ) , throttle . get Speed Setting ( ) , ( ( float ) ( System . nano Time ( ) - last Time Timer Started ) / NUM ) ) ; section Length = distance Remaining ; } else { referenced = sec ; } change Loco Speed ( t , section Length , speed ) ; }
public Object before Encode ( mx Codec enc , Object obj , Node node ) { return obj ; }
public Object before Encode ( mx Codec enc , Object obj , Node node ) { return obj ; }
public Object before Encode ( mx Codec enc , Object obj , Node node ) { return obj ; }
public Object before Encode ( mx Codec enc , Object obj , Node node ) { return obj ; }
public Object before Encode ( mx Codec enc , Object obj , Node node ) { return obj ; }
protected boolean starting Multi Line Comment ( String content , int start Offset , int end Offset ) throws Bad Location Exception { if ( ! get Multi Line Comment ( ) ) { return BOOL ; } int index = index Of ( content , get Multi Line Comment Start ( ) , start Offset ) ; if ( ( index < NUM ) || ( index > end Offset ) ) { return BOOL ; } else { set Inside Multi Line Comment ( BOOL ) ; return BOOL ; } }
public void remove Events ( ) { scene . set On Key Pressed ( null ) ; scene . set On Key Released ( null ) ; up = down = left = right = sprint = jump = shoot Fireball = BOOL ; }
public TX State Proxy masquerade As ( Transaction Message msg ) throws Interrupted Exception { if ( msg . get TX Uniq Id ( ) == NOTX || ! msg . can Participate In Transaction ( ) ) { return null ; } TX Id key = new TX Id ( msg . get Member To Masquerade As ( ) , msg . get TX Uniq Id ( ) ) ; TX State Proxy val = get Or Set Hosted TX State ( key , msg ) ; if ( val != null ) { boolean success = get Lock ( val , key ) ; while ( ! success ) { val = get Or Set Hosted TX State ( key , msg ) ; if ( val != null ) { success = get Lock ( val , key ) ; } else { break ; } } } set TX State ( val ) ; return val ; }
public TX State Proxy masquerade As ( Transaction Message msg ) throws Interrupted Exception { if ( msg . get TX Uniq Id ( ) == NOTX || ! msg . can Participate In Transaction ( ) ) { return null ; } TX Id key = new TX Id ( msg . get Member To Masquerade As ( ) , msg . get TX Uniq Id ( ) ) ; TX State Proxy val = get Or Set Hosted TX State ( key , msg ) ; if ( val != null ) { boolean success = get Lock ( val , key ) ; while ( ! success ) { val = get Or Set Hosted TX State ( key , msg ) ; if ( val != null ) { success = get Lock ( val , key ) ; } else { break ; } } } set TX State ( val ) ; return val ; }
public TX State Proxy masquerade As ( Transaction Message msg ) throws Interrupted Exception { if ( msg . get TX Uniq Id ( ) == NOTX || ! msg . can Participate In Transaction ( ) ) { return null ; } TX Id key = new TX Id ( msg . get Member To Masquerade As ( ) , msg . get TX Uniq Id ( ) ) ; TX State Proxy val = get Or Set Hosted TX State ( key , msg ) ; if ( val != null ) { boolean success = get Lock ( val , key ) ; while ( ! success ) { val = get Or Set Hosted TX State ( key , msg ) ; if ( val != null ) { success = get Lock ( val , key ) ; } else { break ; } } } set TX State ( val ) ; return val ; }
public TX State Proxy masquerade As ( Transaction Message msg ) throws Interrupted Exception { if ( msg . get TX Uniq Id ( ) == NOTX || ! msg . can Participate In Transaction ( ) ) { return null ; } TX Id key = new TX Id ( msg . get Member To Masquerade As ( ) , msg . get TX Uniq Id ( ) ) ; TX State Proxy val = get Or Set Hosted TX State ( key , msg ) ; if ( val != null ) { boolean success = get Lock ( val , key ) ; while ( ! success ) { val = get Or Set Hosted TX State ( key , msg ) ; if ( val != null ) { success = get Lock ( val , key ) ; } else { break ; } } } set TX State ( val ) ; return val ; }
public TX State Proxy masquerade As ( Transaction Message msg ) throws Interrupted Exception { if ( msg . get TX Uniq Id ( ) == NOTX || ! msg . can Participate In Transaction ( ) ) { return null ; } TX Id key = new TX Id ( msg . get Member To Masquerade As ( ) , msg . get TX Uniq Id ( ) ) ; TX State Proxy val = get Or Set Hosted TX State ( key , msg ) ; if ( val != null ) { boolean success = get Lock ( val , key ) ; while ( ! success ) { val = get Or Set Hosted TX State ( key , msg ) ; if ( val != null ) { success = get Lock ( val , key ) ; } else { break ; } } } set TX State ( val ) ; return val ; }
public TX State Proxy masquerade As ( Transaction Message msg ) throws Interrupted Exception { if ( msg . get TX Uniq Id ( ) == NOTX || ! msg . can Participate In Transaction ( ) ) { return null ; } TX Id key = new TX Id ( msg . get Member To Masquerade As ( ) , msg . get TX Uniq Id ( ) ) ; TX State Proxy val = get Or Set Hosted TX State ( key , msg ) ; if ( val != null ) { boolean success = get Lock ( val , key ) ; while ( ! success ) { val = get Or Set Hosted TX State ( key , msg ) ; if ( val != null ) { success = get Lock ( val , key ) ; } else { break ; } } } set TX State ( val ) ; return val ; }
public TX State Proxy masquerade As ( Transaction Message msg ) throws Interrupted Exception { if ( msg . get TX Uniq Id ( ) == NOTX || ! msg . can Participate In Transaction ( ) ) { return null ; } TX Id key = new TX Id ( msg . get Member To Masquerade As ( ) , msg . get TX Uniq Id ( ) ) ; TX State Proxy val = get Or Set Hosted TX State ( key , msg ) ; if ( val != null ) { boolean success = get Lock ( val , key ) ; while ( ! success ) { val = get Or Set Hosted TX State ( key , msg ) ; if ( val != null ) { success = get Lock ( val , key ) ; } else { break ; } } } set TX State ( val ) ; return val ; }
public TX State Proxy masquerade As ( Transaction Message msg ) throws Interrupted Exception { if ( msg . get TX Uniq Id ( ) == NOTX || ! msg . can Participate In Transaction ( ) ) { return null ; } TX Id key = new TX Id ( msg . get Member To Masquerade As ( ) , msg . get TX Uniq Id ( ) ) ; TX State Proxy val = get Or Set Hosted TX State ( key , msg ) ; if ( val != null ) { boolean success = get Lock ( val , key ) ; while ( ! success ) { val = get Or Set Hosted TX State ( key , msg ) ; if ( val != null ) { success = get Lock ( val , key ) ; } else { break ; } } } set TX State ( val ) ; return val ; }
private void r Probe And Add Hops To Candidate Set ( Hop hop , Hash Set < Hop > probe Set , Hash Set < Pair < Hop , Hop > > cand Set ) { if ( hop . get Visited ( ) == Visit Status . DONE ) return ; if ( hop . get Input ( ) != null ) for ( Hop c : hop . get Input ( ) ) { if ( ! probe Set . contains ( c ) ) r Probe And Add Hops To Candidate Set ( c , probe Set , cand Set ) ; else { cand Set . add ( new Pair < Hop , Hop > ( hop , c ) ) ; } } hop . set Visited ( Visit Status . DONE ) ; }
private void r Probe And Add Hops To Candidate Set ( Hop hop , Hash Set < Hop > probe Set , Hash Set < Pair < Hop , Hop > > cand Set ) { if ( hop . get Visited ( ) == Visit Status . DONE ) return ; if ( hop . get Input ( ) != null ) for ( Hop c : hop . get Input ( ) ) { if ( ! probe Set . contains ( c ) ) r Probe And Add Hops To Candidate Set ( c , probe Set , cand Set ) ; else { cand Set . add ( new Pair < Hop , Hop > ( hop , c ) ) ; } } hop . set Visited ( Visit Status . DONE ) ; }
default boolean if String ( Consumer < String > consumer ) { if ( is String ( ) ) { consumer . accept ( as String ( ) ) ; return BOOL ; } return BOOL ; }
private static void populate Blocks ( Set < Distributable > unique Blocks , int no Of Blocks Per Node , List < Distributable > block Lst ) { Iterator < Distributable > blocks = unique Blocks . iterator ( ) ; if ( block Lst . size ( ) == no Of Blocks Per Node ) { return ; } while ( blocks . has Next ( ) ) { Distributable block = blocks . next ( ) ; block Lst . add ( block ) ; blocks . remove ( ) ; if ( block Lst . size ( ) >= no Of Blocks Per Node ) { break ; } } }
public void append ( byte [ ] bytes , int offset , int length ) { while ( length > NUM ) { int free Space In End Chunk = m Chunks . size ( ) * m Chunk Size - m Size ; int position In End Chunk = m Chunk Size - free Space In End Chunk ; if ( free Space In End Chunk == NUM ) { m Chunks . add ( new byte [ m Chunk Size ] ) ; free Space In End Chunk = m Chunk Size ; position In End Chunk = NUM ; } byte [ ] end Chunk = m Chunks . get ( m Chunks . size ( ) - NUM ) ; if ( length > free Space In End Chunk ) { System . arraycopy ( bytes , offset , end Chunk , position In End Chunk , free Space In End Chunk ) ; m Size += free Space In End Chunk ; offset += free Space In End Chunk ; length -= free Space In End Chunk ; } else { System . arraycopy ( bytes , offset , end Chunk , position In End Chunk , length ) ; m Size += length ; offset += length ; length = NUM ; } } }
@ Override public void add New Subscription ( final Subscription new Subscription ) { final String client ID = new Subscription . get Client Id ( ) ; List < Client Topic Couple > client Subscriptions = subscriptions . get ( client ID ) ; if ( client Subscriptions == null ) { client Subscriptions = new Array List < > ( ) ; subscriptions . put ( client ID , client Subscriptions ) ; } client Subscriptions . add ( new Subscription . as Client Topic Couple ( ) ) ; }
@ Override protected void create Menus ( J Menu Bar menu Bar , Window Interface wi ) { super . create Menus ( menu Bar , wi ) ; development Menu ( menu Bar , wi ) ; menu Bar . add ( new jmri . jmris . Server Menu ( ) ) ; }
protected void add Multipart ( Nokia Item Type the Item Type , byte [ ] data ) { parts . add ( new Nokia Part ( the Item Type , data ) ) ; }
public int matches Recommended ( Map < String , String > tag Set ) { if ( name . equals ( STRING ) ) { Log . d ( DEBUG TAG , STRING ) ; } int matches = NUM ; for ( Entry < String , String With Description [ ] > tag : recommended Tags . entry Set ( ) ) { String key = tag . get Key ( ) ; if ( tag Set . contains Key ( key ) ) { if ( get Match Type ( key ) == Match Type . NONE ) { break ; } if ( get Match Type ( key ) == Match Type . KEY ) { matches ++ ; break ; } String other Tag Value = tag Set . get ( key ) ; for ( String With Description v : tag . get Value ( ) ) { if ( v . equals ( other Tag Value ) ) { matches ++ ; break ; } } } } return matches ; }
@ Target Api ( Build . VERSION CODES . LOLLIPOP ) public Option Scan Node build Tree From Window List ( List < Switch Access Window Info > window List , Option Scan Node context Menu Tree ) { context Menu Tree = ( context Menu Tree == null ) ? new Clear Focus Node ( ) : context Menu Tree ; if ( window List == null || window List . size ( ) == NUM ) { return context Menu Tree ; } List < Option Scan Node > tree Nodes = new Array List < > ( ) ; for ( Switch Access Window Info window : window List ) { Switch Access Node Compat window Root = window . get Root ( ) ; if ( window Root != null ) { tree Nodes . add All ( get Node List From Node Tree ( window Root ) ) ; window Root . recycle ( ) ; } } return build Tree From Node List ( tree Nodes , OPTION SCAN SELECTION NODE , context Menu Tree ) ; }
public static String trim ( final String value ) { return ( value == null ? null : value . trim ( ) ) ; }
final void revalidate ( ) { for ( Document doc : documents ) { if ( doc . get Length ( ) == NUM ) { component . set Enabled ( BOOL ) ; return ; } } component . set Enabled ( BOOL ) ; }
final void revalidate ( ) { for ( Document doc : documents ) { if ( doc . get Length ( ) == NUM ) { component . set Enabled ( BOOL ) ; return ; } } component . set Enabled ( BOOL ) ; }
public void keep Predictions ( boolean keep Predictions ) { this . keep Predictions = keep Predictions ; }
public void keep Predictions ( boolean keep Predictions ) { this . keep Predictions = keep Predictions ; }
public void keep Predictions ( boolean keep Predictions ) { this . keep Predictions = keep Predictions ; }
public void keep Predictions ( boolean keep Predictions ) { this . keep Predictions = keep Predictions ; }
public static int find Optimal Root ( int [ ] msg ) { final int size = ( msg . length > > NUM ) + NUM ; int [ ] depth = new int [ size ] ; int [ ] missing = new int [ size ] ; int root = - NUM ; for ( int i = NUM ; i < size ; i ++ ) { boolean active = BOOL ; for ( int e = NUM ; e < msg . length ; e += NUM ) { if ( depth [ msg [ e ] ] == NUM ) { missing [ msg [ e + NUM ] ] ++ ; } if ( depth [ msg [ e + NUM ] ] == NUM ) { missing [ msg [ e ] ] ++ ; } } for ( int n = NUM ; n < size ; n ++ ) { if ( depth [ n ] == NUM && missing [ n ] <= NUM ) { depth [ n ] = i ; root = n ; active = BOOL ; } } if ( ! active ) { break ; } Arrays . fill ( missing , NUM ) ; } return root ; }
public static int find Optimal Root ( int [ ] msg ) { final int size = ( msg . length > > NUM ) + NUM ; int [ ] depth = new int [ size ] ; int [ ] missing = new int [ size ] ; int root = - NUM ; for ( int i = NUM ; i < size ; i ++ ) { boolean active = BOOL ; for ( int e = NUM ; e < msg . length ; e += NUM ) { if ( depth [ msg [ e ] ] == NUM ) { missing [ msg [ e + NUM ] ] ++ ; } if ( depth [ msg [ e + NUM ] ] == NUM ) { missing [ msg [ e ] ] ++ ; } } for ( int n = NUM ; n < size ; n ++ ) { if ( depth [ n ] == NUM && missing [ n ] <= NUM ) { depth [ n ] = i ; root = n ; active = BOOL ; } } if ( ! active ) { break ; } Arrays . fill ( missing , NUM ) ; } return root ; }
public static int find Optimal Root ( int [ ] msg ) { final int size = ( msg . length > > NUM ) + NUM ; int [ ] depth = new int [ size ] ; int [ ] missing = new int [ size ] ; int root = - NUM ; for ( int i = NUM ; i < size ; i ++ ) { boolean active = BOOL ; for ( int e = NUM ; e < msg . length ; e += NUM ) { if ( depth [ msg [ e ] ] == NUM ) { missing [ msg [ e + NUM ] ] ++ ; } if ( depth [ msg [ e + NUM ] ] == NUM ) { missing [ msg [ e ] ] ++ ; } } for ( int n = NUM ; n < size ; n ++ ) { if ( depth [ n ] == NUM && missing [ n ] <= NUM ) { depth [ n ] = i ; root = n ; active = BOOL ; } } if ( ! active ) { break ; } Arrays . fill ( missing , NUM ) ; } return root ; }
public static int find Optimal Root ( int [ ] msg ) { final int size = ( msg . length > > NUM ) + NUM ; int [ ] depth = new int [ size ] ; int [ ] missing = new int [ size ] ; int root = - NUM ; for ( int i = NUM ; i < size ; i ++ ) { boolean active = BOOL ; for ( int e = NUM ; e < msg . length ; e += NUM ) { if ( depth [ msg [ e ] ] == NUM ) { missing [ msg [ e + NUM ] ] ++ ; } if ( depth [ msg [ e + NUM ] ] == NUM ) { missing [ msg [ e ] ] ++ ; } } for ( int n = NUM ; n < size ; n ++ ) { if ( depth [ n ] == NUM && missing [ n ] <= NUM ) { depth [ n ] = i ; root = n ; active = BOOL ; } } if ( ! active ) { break ; } Arrays . fill ( missing , NUM ) ; } return root ; }
public static int find Optimal Root ( int [ ] msg ) { final int size = ( msg . length > > NUM ) + NUM ; int [ ] depth = new int [ size ] ; int [ ] missing = new int [ size ] ; int root = - NUM ; for ( int i = NUM ; i < size ; i ++ ) { boolean active = BOOL ; for ( int e = NUM ; e < msg . length ; e += NUM ) { if ( depth [ msg [ e ] ] == NUM ) { missing [ msg [ e + NUM ] ] ++ ; } if ( depth [ msg [ e + NUM ] ] == NUM ) { missing [ msg [ e ] ] ++ ; } } for ( int n = NUM ; n < size ; n ++ ) { if ( depth [ n ] == NUM && missing [ n ] <= NUM ) { depth [ n ] = i ; root = n ; active = BOOL ; } } if ( ! active ) { break ; } Arrays . fill ( missing , NUM ) ; } return root ; }
public static int find Optimal Root ( int [ ] msg ) { final int size = ( msg . length > > NUM ) + NUM ; int [ ] depth = new int [ size ] ; int [ ] missing = new int [ size ] ; int root = - NUM ; for ( int i = NUM ; i < size ; i ++ ) { boolean active = BOOL ; for ( int e = NUM ; e < msg . length ; e += NUM ) { if ( depth [ msg [ e ] ] == NUM ) { missing [ msg [ e + NUM ] ] ++ ; } if ( depth [ msg [ e + NUM ] ] == NUM ) { missing [ msg [ e ] ] ++ ; } } for ( int n = NUM ; n < size ; n ++ ) { if ( depth [ n ] == NUM && missing [ n ] <= NUM ) { depth [ n ] = i ; root = n ; active = BOOL ; } } if ( ! active ) { break ; } Arrays . fill ( missing , NUM ) ; } return root ; }
public static int find Optimal Root ( int [ ] msg ) { final int size = ( msg . length > > NUM ) + NUM ; int [ ] depth = new int [ size ] ; int [ ] missing = new int [ size ] ; int root = - NUM ; for ( int i = NUM ; i < size ; i ++ ) { boolean active = BOOL ; for ( int e = NUM ; e < msg . length ; e += NUM ) { if ( depth [ msg [ e ] ] == NUM ) { missing [ msg [ e + NUM ] ] ++ ; } if ( depth [ msg [ e + NUM ] ] == NUM ) { missing [ msg [ e ] ] ++ ; } } for ( int n = NUM ; n < size ; n ++ ) { if ( depth [ n ] == NUM && missing [ n ] <= NUM ) { depth [ n ] = i ; root = n ; active = BOOL ; } } if ( ! active ) { break ; } Arrays . fill ( missing , NUM ) ; } return root ; }
public static int find Optimal Root ( int [ ] msg ) { final int size = ( msg . length > > NUM ) + NUM ; int [ ] depth = new int [ size ] ; int [ ] missing = new int [ size ] ; int root = - NUM ; for ( int i = NUM ; i < size ; i ++ ) { boolean active = BOOL ; for ( int e = NUM ; e < msg . length ; e += NUM ) { if ( depth [ msg [ e ] ] == NUM ) { missing [ msg [ e + NUM ] ] ++ ; } if ( depth [ msg [ e + NUM ] ] == NUM ) { missing [ msg [ e ] ] ++ ; } } for ( int n = NUM ; n < size ; n ++ ) { if ( depth [ n ] == NUM && missing [ n ] <= NUM ) { depth [ n ] = i ; root = n ; active = BOOL ; } } if ( ! active ) { break ; } Arrays . fill ( missing , NUM ) ; } return root ; }
public void guard ( final Runnable r ) { inc Thread ( ) ; try { r . run ( ) ; } finally { dec Thread ( ) ; } }
public void guard ( final Runnable r ) { inc Thread ( ) ; try { r . run ( ) ; } finally { dec Thread ( ) ; } }
public void guard ( final Runnable r ) { inc Thread ( ) ; try { r . run ( ) ; } finally { dec Thread ( ) ; } }
private void init Circle Crop Window ( @ Non Null Rect F bitmap Rect ) { m Offset = NUM * Math . min ( bitmap Rect . width ( ) , bitmap Rect . height ( ) ) ; m Drawable Width = bitmap Rect . width ( ) ; m Drawable Height = bitmap Rect . height ( ) ; m Center Point X = m Drawable Width / NUM ; m Center Point Y = m Drawable Height / NUM ; m Radius = ( Math . min ( m Drawable Width , m Drawable Height ) - m Offset ) / NUM ; }
private void init Circle Crop Window ( @ Non Null Rect F bitmap Rect ) { m Offset = NUM * Math . min ( bitmap Rect . width ( ) , bitmap Rect . height ( ) ) ; m Drawable Width = bitmap Rect . width ( ) ; m Drawable Height = bitmap Rect . height ( ) ; m Center Point X = m Drawable Width / NUM ; m Center Point Y = m Drawable Height / NUM ; m Radius = ( Math . min ( m Drawable Width , m Drawable Height ) - m Offset ) / NUM ; }
private void init Circle Crop Window ( @ Non Null Rect F bitmap Rect ) { m Offset = NUM * Math . min ( bitmap Rect . width ( ) , bitmap Rect . height ( ) ) ; m Drawable Width = bitmap Rect . width ( ) ; m Drawable Height = bitmap Rect . height ( ) ; m Center Point X = m Drawable Width / NUM ; m Center Point Y = m Drawable Height / NUM ; m Radius = ( Math . min ( m Drawable Width , m Drawable Height ) - m Offset ) / NUM ; }
Color next Color ( ) { int red = Math . min ( NUM , ( ( measurement Color > > NUM ) & NUM ) * NUM / NUM ) ; int green = Math . min ( NUM , ( ( measurement Color > > NUM ) & NUM ) * NUM / NUM ) ; int blue = Math . min ( NUM , ( ( measurement Color > > NUM ) & NUM ) * NUM / NUM ) ; measurement Color ++ ; return new Color ( red , green , blue ) ; }
void add Wait Statement ( ) { if ( is Recording ( ) ) { long t = System . current Time Millis ( ) ; long d = t - wait Timer ; generated Code += STRING + d + STRING ; wait Timer = t ; } }
void add Wait Statement ( ) { if ( is Recording ( ) ) { long t = System . current Time Millis ( ) ; long d = t - wait Timer ; generated Code += STRING + d + STRING ; wait Timer = t ; } }
void add Wait Statement ( ) { if ( is Recording ( ) ) { long t = System . current Time Millis ( ) ; long d = t - wait Timer ; generated Code += STRING + d + STRING ; wait Timer = t ; } }
long offer ( int part , long addr , int hash ) throws Grid Off Heap Out Of Memory Exception { lock . lock ( ) ; try { long q Addr = mem . allocate System ( NODE , BOOL ) ; if ( head == NUM ) head = q Addr ; long prev = tail ; tail = q Addr ; if ( prev != NUM ) next ( prev , q Addr ) ; order ( q Addr ) ; partition ( q Addr , part ) ; polling ( q Addr , BOOL ) ; hash ( q Addr , hash ) ; entry ( q Addr , addr ) ; previous ( q Addr , prev ) ; next ( q Addr , NUM ) ; size ++ ; return q Addr ; } finally { lock . unlock ( ) ; } }
long offer ( int part , long addr , int hash ) throws Grid Off Heap Out Of Memory Exception { lock . lock ( ) ; try { long q Addr = mem . allocate System ( NODE , BOOL ) ; if ( head == NUM ) head = q Addr ; long prev = tail ; tail = q Addr ; if ( prev != NUM ) next ( prev , q Addr ) ; order ( q Addr ) ; partition ( q Addr , part ) ; polling ( q Addr , BOOL ) ; hash ( q Addr , hash ) ; entry ( q Addr , addr ) ; previous ( q Addr , prev ) ; next ( q Addr , NUM ) ; size ++ ; return q Addr ; } finally { lock . unlock ( ) ; } }
private static float Call Static Float Method V ( JNI Environment env , int class JREF , int method ID , Address arg Address ) throws Exception { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { Object return Obj = JNI Helpers . invoke With Var Arg ( method ID , arg Address , Type Reference . Float ) ; return Reflection . unwrap Float ( return Obj ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
private static float Call Static Float Method V ( JNI Environment env , int class JREF , int method ID , Address arg Address ) throws Exception { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { Object return Obj = JNI Helpers . invoke With Var Arg ( method ID , arg Address , Type Reference . Float ) ; return Reflection . unwrap Float ( return Obj ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
@ Override public synchronized void add Instance Listener ( Instance Listener dsl ) { m instance Listeners . add Element ( dsl ) ; if ( m format != null ) { Instance Event e = new Instance Event ( this , m format ) ; dsl . accept Instance ( e ) ; } }
public boolean contains Base Type Only ( ) { return members . is Empty ( ) ; }
public static void append Escaped Text To Builder ( String Builder out , String item , char separator ) { for ( int i = NUM ; i < item . length ( ) ; i ++ ) { char ch = item . char At ( i ) ; if ( ch == STRING || ch == separator ) { out . append ( STRING ) ; } out . append ( ch ) ; } }
public static void join ( Detached Baggage other Baggage ) { if ( other Baggage == null || other Baggage . impl == null ) { return ; } Baggage Impl impl = current . get ( ) ; if ( impl == null ) { current . set ( other Baggage . impl ) ; } else { impl . merge ( other Baggage . impl ) ; } other Baggage . impl = null ; }
public static void join ( Detached Baggage other Baggage ) { if ( other Baggage == null || other Baggage . impl == null ) { return ; } Baggage Impl impl = current . get ( ) ; if ( impl == null ) { current . set ( other Baggage . impl ) ; } else { impl . merge ( other Baggage . impl ) ; } other Baggage . impl = null ; }
public static void join ( Detached Baggage other Baggage ) { if ( other Baggage == null || other Baggage . impl == null ) { return ; } Baggage Impl impl = current . get ( ) ; if ( impl == null ) { current . set ( other Baggage . impl ) ; } else { impl . merge ( other Baggage . impl ) ; } other Baggage . impl = null ; }
public static void join ( Detached Baggage other Baggage ) { if ( other Baggage == null || other Baggage . impl == null ) { return ; } Baggage Impl impl = current . get ( ) ; if ( impl == null ) { current . set ( other Baggage . impl ) ; } else { impl . merge ( other Baggage . impl ) ; } other Baggage . impl = null ; }
public static void join ( Detached Baggage other Baggage ) { if ( other Baggage == null || other Baggage . impl == null ) { return ; } Baggage Impl impl = current . get ( ) ; if ( impl == null ) { current . set ( other Baggage . impl ) ; } else { impl . merge ( other Baggage . impl ) ; } other Baggage . impl = null ; }
private static void log Os Info ( ) { Logger . append Log ( STRING + Cfg . get Os ( ) ) ; Logger . append Log ( STRING + Os . get Os Name ( ) ) ; Logger . append Log ( STRING + Os . platform ( ) ) ; Logger . append Log ( STRING + System . get Property ( STRING ) ) ; Logger . append Log ( STRING + Host Info . available Cpus ( ) ) ; Logger . append Log ( STRING + Host Info . get Max Memory ( ) + STRING ) ; }
public static void start Server ( ) { start Server ( Charset . default Charset ( ) , null ) ; }
boolean is Socket Scheme ( String scheme ) { for ( String p : URI Helper . SOCKET SCHEMES ) { if ( p . equals ( scheme ) ) { return BOOL ; } } return BOOL ; }
boolean is Socket Scheme ( String scheme ) { for ( String p : URI Helper . SOCKET SCHEMES ) { if ( p . equals ( scheme ) ) { return BOOL ; } } return BOOL ; }
public byte [ ] handle Request ( String request ) throws IO Exception , Map Request Format Exception { Properties request Properties = convert Request To Props ( request ) ; String request Type = request Properties . get Property ( REQUEST ) ; if ( request Type != null ) { if ( request Type . equals Ignore Case ( MAP ) ) { Debug . message ( STRING , STRING ) ; return handle Map Request ( request Properties ) ; } else { throw new Map Request Format Exception ( STRING + request Type ) ; } } else { throw new Map Request Format Exception ( STRING + request ) ; } }
public byte [ ] handle Request ( String request ) throws IO Exception , Map Request Format Exception { Properties request Properties = convert Request To Props ( request ) ; String request Type = request Properties . get Property ( REQUEST ) ; if ( request Type != null ) { if ( request Type . equals Ignore Case ( MAP ) ) { Debug . message ( STRING , STRING ) ; return handle Map Request ( request Properties ) ; } else { throw new Map Request Format Exception ( STRING + request Type ) ; } } else { throw new Map Request Format Exception ( STRING + request ) ; } }
public Composer transform ( float x , float y , int alpha , float scale X , float scale Y , float rotation ) { if ( m Tween Parameter List . size ( ) > NUM ) { to ( NUM , x , y , alpha , scale X , scale Y , rotation , Ease . NONE ) ; } else { m Initial Param = new Anim Parameter ( x , y , alpha , scale X , scale Y , rotation ) ; } return this ; }
public Composer transform ( float x , float y , int alpha , float scale X , float scale Y , float rotation ) { if ( m Tween Parameter List . size ( ) > NUM ) { to ( NUM , x , y , alpha , scale X , scale Y , rotation , Ease . NONE ) ; } else { m Initial Param = new Anim Parameter ( x , y , alpha , scale X , scale Y , rotation ) ; } return this ; }
public Composer transform ( float x , float y , int alpha , float scale X , float scale Y , float rotation ) { if ( m Tween Parameter List . size ( ) > NUM ) { to ( NUM , x , y , alpha , scale X , scale Y , rotation , Ease . NONE ) ; } else { m Initial Param = new Anim Parameter ( x , y , alpha , scale X , scale Y , rotation ) ; } return this ; }
private void determine Function Candidates NNZ Propagation ( Map < String , Function Op > fcand Hops , Map < String , Set < Long > > fcand Safe NNZ ) { for ( Entry < String , Function Op > e : fcand Hops . entry Set ( ) ) { String f Key = e . get Key ( ) ; Function Op fop = e . get Value ( ) ; Hash Set < Long > tmp = new Hash Set < Long > ( ) ; for ( Hop input : fop . get Input ( ) ) { if ( input . get Nnz ( ) >= NUM ) tmp . add ( input . get Hop ID ( ) ) ; } fcand Safe NNZ . put ( f Key , tmp ) ; } }
private void determine Function Candidates NNZ Propagation ( Map < String , Function Op > fcand Hops , Map < String , Set < Long > > fcand Safe NNZ ) { for ( Entry < String , Function Op > e : fcand Hops . entry Set ( ) ) { String f Key = e . get Key ( ) ; Function Op fop = e . get Value ( ) ; Hash Set < Long > tmp = new Hash Set < Long > ( ) ; for ( Hop input : fop . get Input ( ) ) { if ( input . get Nnz ( ) >= NUM ) tmp . add ( input . get Hop ID ( ) ) ; } fcand Safe NNZ . put ( f Key , tmp ) ; } }
private void determine Function Candidates NNZ Propagation ( Map < String , Function Op > fcand Hops , Map < String , Set < Long > > fcand Safe NNZ ) { for ( Entry < String , Function Op > e : fcand Hops . entry Set ( ) ) { String f Key = e . get Key ( ) ; Function Op fop = e . get Value ( ) ; Hash Set < Long > tmp = new Hash Set < Long > ( ) ; for ( Hop input : fop . get Input ( ) ) { if ( input . get Nnz ( ) >= NUM ) tmp . add ( input . get Hop ID ( ) ) ; } fcand Safe NNZ . put ( f Key , tmp ) ; } }
@ Override public int stored MB ( ) { long bytes = NUM ; final File [ ] files = cache Directory . list Files ( ) ; if ( files == null ) return NUM ; for ( File file : files ) { bytes += file . length ( ) ; } double megabytes = Math . ceil ( ( double ) bytes / NUM / NUM ) ; return ( int ) megabytes ; }
public void calculate scores ( ) { score = NUM ; if ( contents . length == NUM ) { API api = API . v ( ) ; Set < Info Kind > source = api . get Source Info Kinds ( method ) ; Set < Info Kind > sink = api . get Sink Info Kinds ( method ) ; if ( is system ( method ) ) { if ( api . is Safe Method ( method ) ) score = NUM ; else if ( api . is Spec Method ( method ) ) score = NUM ; else if ( api . is Banned Method ( method ) ) score = NUM ; if ( ! source . is Empty ( ) ) score += NUM ; else if ( ! sink . is Empty ( ) ) score += NUM ; } return ; } for ( Source Call Chain Info cci : contents ) { cci . calculate scores ( ) ; calls += cci . calls ; syscalls += cci . syscalls ; if ( cci . score > score ) score = cci . score ; } }
protected static Span find Root Or Server Span ( String tenant Id , Span span , Span Cache span Cache ) { while ( span != null && ! span . server Span ( ) && ! span . top Level Span ( ) ) { span = span Cache . get ( tenant Id , span . get Parent Id ( ) ) ; } return span ; }
protected static Span find Root Or Server Span ( String tenant Id , Span span , Span Cache span Cache ) { while ( span != null && ! span . server Span ( ) && ! span . top Level Span ( ) ) { span = span Cache . get ( tenant Id , span . get Parent Id ( ) ) ; } return span ; }
protected static Span find Root Or Server Span ( String tenant Id , Span span , Span Cache span Cache ) { while ( span != null && ! span . server Span ( ) && ! span . top Level Span ( ) ) { span = span Cache . get ( tenant Id , span . get Parent Id ( ) ) ; } return span ; }
public void toggle ( JFX Drawer drawer ) { if ( ! drawers . contains ( drawer ) ) add Drawer ( drawer ) ; if ( drawer . is Shown ( ) || drawer . is Showing ( ) ) drawer . close ( ) ; else { update Drawer Position ( drawer ) ; drawer . open ( ) ; } }
public static long seconds Since Millis ( long time In Millis ) { return ( System . current Time Millis ( ) - time In Millis ) / NUM ; }
public static long seconds Since Millis ( long time In Millis ) { return ( System . current Time Millis ( ) - time In Millis ) / NUM ; }
public Field Storage Scheme Impl ( int digest Size , String algorithm ) throws Exception { this . message Digest = Message Digest . get Instance ( algorithm ) ; this . digest Lock = new Object ( ) ; this . random = new Secure Random ( ) ; this . digest Size = digest Size ; }
public synchronized Type Instance create Instance ( final String name , final String comment , final Base Type base Type , final Section section , final long section Offset ) throws Couldnt Save Data Exception , Couldnt Load Data Exception { Preconditions . check Not Null ( name , STRING ) ; Preconditions . check Argument ( comment == null || ! comment . is Empty ( ) , STRING ) ; Preconditions . check Not Null ( base Type , STRING ) ; Preconditions . check Not Null ( section , STRING ) ; Preconditions . check Argument ( section Offset >= NUM , STRING ) ; Preconditions . check Argument ( ! instances By Address . contains Key ( new Type Instance Address ( section . get Start Address ( ) , section Offset ) ) ) ; final Type Instance instance = backend . create Type Instance ( name , comment , base Type , section , section Offset ) ; instances By Address . put ( instance . get Address ( ) , instance ) ; instances . add ( instance ) ; notify Instance Added ( instance ) ; return instance ; }
public Speech Data ( byte [ ] data ) { Audio Input Stream stream = Audio Utils . get Audio Stream ( data ) ; format = stream . get Format ( ) ; this . data = data ; is Final = BOOL ; }
protected Class Node infer Return Type Generics ( Class Node receiver , Method Node method , Expression arguments ) { return infer Return Type Generics ( receiver , method , arguments , null ) ; }
protected Class Node infer Return Type Generics ( Class Node receiver , Method Node method , Expression arguments ) { return infer Return Type Generics ( receiver , method , arguments , null ) ; }
protected Class Node infer Return Type Generics ( Class Node receiver , Method Node method , Expression arguments ) { return infer Return Type Generics ( receiver , method , arguments , null ) ; }
protected Class Node infer Return Type Generics ( Class Node receiver , Method Node method , Expression arguments ) { return infer Return Type Generics ( receiver , method , arguments , null ) ; }
public Dead Lock Detector ( int sleep Time , byte do When DL ) { super ( STRING ) ; this . sleep Time = sleep Time * NUM ; this . tmx = Management Factory . get Thread MX Bean ( ) ; this . do When DL = do When DL ; }
public static Date convert ISO 8601 to Date ( String date String ) throws Parse Exception { Date Format date Format = new Simple Date Format ( STRING ) ; Date date = date Format . parse ( date String ) ; return date ; }
public synchronized String generate Call Identifier ( String address ) { String date = Long . to String ( System . current Time Millis ( ) + call ID Counter ++ + rand . next Long ( ) ) ; byte cid [ ] = digester . digest ( date . get Bytes ( ) ) ; String cid String = Utils . to Hex String ( cid ) ; return cid String + STRING + address ; }
public synchronized String generate Call Identifier ( String address ) { String date = Long . to String ( System . current Time Millis ( ) + call ID Counter ++ + rand . next Long ( ) ) ; byte cid [ ] = digester . digest ( date . get Bytes ( ) ) ; String cid String = Utils . to Hex String ( cid ) ; return cid String + STRING + address ; }
public synchronized String generate Call Identifier ( String address ) { String date = Long . to String ( System . current Time Millis ( ) + call ID Counter ++ + rand . next Long ( ) ) ; byte cid [ ] = digester . digest ( date . get Bytes ( ) ) ; String cid String = Utils . to Hex String ( cid ) ; return cid String + STRING + address ; }
public synchronized String generate Call Identifier ( String address ) { String date = Long . to String ( System . current Time Millis ( ) + call ID Counter ++ + rand . next Long ( ) ) ; byte cid [ ] = digester . digest ( date . get Bytes ( ) ) ; String cid String = Utils . to Hex String ( cid ) ; return cid String + STRING + address ; }
public boolean consume Encumbrance Budget ( final Map < String , Object > details Map ) { if ( details Map == null ) throw new Validation Exception ( Arrays . as List ( new Validation Error ( STRING , STRING ) ) ) ; details Map . put ( Constants . CONSUMEORRELEASE , BOOL ) ; final Big Decimal bd = get Details ( details Map ) ; return bd . int Value ( ) == NUM ; }
public boolean consume Encumbrance Budget ( final Map < String , Object > details Map ) { if ( details Map == null ) throw new Validation Exception ( Arrays . as List ( new Validation Error ( STRING , STRING ) ) ) ; details Map . put ( Constants . CONSUMEORRELEASE , BOOL ) ; final Big Decimal bd = get Details ( details Map ) ; return bd . int Value ( ) == NUM ; }
public boolean consume Encumbrance Budget ( final Map < String , Object > details Map ) { if ( details Map == null ) throw new Validation Exception ( Arrays . as List ( new Validation Error ( STRING , STRING ) ) ) ; details Map . put ( Constants . CONSUMEORRELEASE , BOOL ) ; final Big Decimal bd = get Details ( details Map ) ; return bd . int Value ( ) == NUM ; }
public boolean consume Encumbrance Budget ( final Map < String , Object > details Map ) { if ( details Map == null ) throw new Validation Exception ( Arrays . as List ( new Validation Error ( STRING , STRING ) ) ) ; details Map . put ( Constants . CONSUMEORRELEASE , BOOL ) ; final Big Decimal bd = get Details ( details Map ) ; return bd . int Value ( ) == NUM ; }
public boolean consume Encumbrance Budget ( final Map < String , Object > details Map ) { if ( details Map == null ) throw new Validation Exception ( Arrays . as List ( new Validation Error ( STRING , STRING ) ) ) ; details Map . put ( Constants . CONSUMEORRELEASE , BOOL ) ; final Big Decimal bd = get Details ( details Map ) ; return bd . int Value ( ) == NUM ; }
public boolean consume Encumbrance Budget ( final Map < String , Object > details Map ) { if ( details Map == null ) throw new Validation Exception ( Arrays . as List ( new Validation Error ( STRING , STRING ) ) ) ; details Map . put ( Constants . CONSUMEORRELEASE , BOOL ) ; final Big Decimal bd = get Details ( details Map ) ; return bd . int Value ( ) == NUM ; }
public boolean consume Encumbrance Budget ( final Map < String , Object > details Map ) { if ( details Map == null ) throw new Validation Exception ( Arrays . as List ( new Validation Error ( STRING , STRING ) ) ) ; details Map . put ( Constants . CONSUMEORRELEASE , BOOL ) ; final Big Decimal bd = get Details ( details Map ) ; return bd . int Value ( ) == NUM ; }
public boolean consume Encumbrance Budget ( final Map < String , Object > details Map ) { if ( details Map == null ) throw new Validation Exception ( Arrays . as List ( new Validation Error ( STRING , STRING ) ) ) ; details Map . put ( Constants . CONSUMEORRELEASE , BOOL ) ; final Big Decimal bd = get Details ( details Map ) ; return bd . int Value ( ) == NUM ; }
public boolean consume Encumbrance Budget ( final Map < String , Object > details Map ) { if ( details Map == null ) throw new Validation Exception ( Arrays . as List ( new Validation Error ( STRING , STRING ) ) ) ; details Map . put ( Constants . CONSUMEORRELEASE , BOOL ) ; final Big Decimal bd = get Details ( details Map ) ; return bd . int Value ( ) == NUM ; }
public boolean consume Encumbrance Budget ( final Map < String , Object > details Map ) { if ( details Map == null ) throw new Validation Exception ( Arrays . as List ( new Validation Error ( STRING , STRING ) ) ) ; details Map . put ( Constants . CONSUMEORRELEASE , BOOL ) ; final Big Decimal bd = get Details ( details Map ) ; return bd . int Value ( ) == NUM ; }
public boolean consume Encumbrance Budget ( final Map < String , Object > details Map ) { if ( details Map == null ) throw new Validation Exception ( Arrays . as List ( new Validation Error ( STRING , STRING ) ) ) ; details Map . put ( Constants . CONSUMEORRELEASE , BOOL ) ; final Big Decimal bd = get Details ( details Map ) ; return bd . int Value ( ) == NUM ; }
public boolean consume Encumbrance Budget ( final Map < String , Object > details Map ) { if ( details Map == null ) throw new Validation Exception ( Arrays . as List ( new Validation Error ( STRING , STRING ) ) ) ; details Map . put ( Constants . CONSUMEORRELEASE , BOOL ) ; final Big Decimal bd = get Details ( details Map ) ; return bd . int Value ( ) == NUM ; }
public boolean consume Encumbrance Budget ( final Map < String , Object > details Map ) { if ( details Map == null ) throw new Validation Exception ( Arrays . as List ( new Validation Error ( STRING , STRING ) ) ) ; details Map . put ( Constants . CONSUMEORRELEASE , BOOL ) ; final Big Decimal bd = get Details ( details Map ) ; return bd . int Value ( ) == NUM ; }
public boolean consume Encumbrance Budget ( final Map < String , Object > details Map ) { if ( details Map == null ) throw new Validation Exception ( Arrays . as List ( new Validation Error ( STRING , STRING ) ) ) ; details Map . put ( Constants . CONSUMEORRELEASE , BOOL ) ; final Big Decimal bd = get Details ( details Map ) ; return bd . int Value ( ) == NUM ; }
public boolean has Forward ( ) { if ( index + NUM < history . size ( ) && index >= NUM ) { return BOOL ; } else { return BOOL ; } }
public boolean remove Telegram Listener ( Telegram Listener rem Listener ) { return ( Telegram Listeners . remove ( rem Listener ) ) ; }
public boolean remove Telegram Listener ( Telegram Listener rem Listener ) { return ( Telegram Listeners . remove ( rem Listener ) ) ; }
public static final Array List read List Xml ( Input Stream in ) throws Xml Pull Parser Exception , java . io . IO Exception { Xml Pull Parser parser = Xml . new Pull Parser ( ) ; parser . set Input ( in , null ) ; return ( Array List ) read Value Xml ( parser , new String [ NUM ] ) ; }
public static final Array List read List Xml ( Input Stream in ) throws Xml Pull Parser Exception , java . io . IO Exception { Xml Pull Parser parser = Xml . new Pull Parser ( ) ; parser . set Input ( in , null ) ; return ( Array List ) read Value Xml ( parser , new String [ NUM ] ) ; }
public static final Array List read List Xml ( Input Stream in ) throws Xml Pull Parser Exception , java . io . IO Exception { Xml Pull Parser parser = Xml . new Pull Parser ( ) ; parser . set Input ( in , null ) ; return ( Array List ) read Value Xml ( parser , new String [ NUM ] ) ; }
public static final Array List read List Xml ( Input Stream in ) throws Xml Pull Parser Exception , java . io . IO Exception { Xml Pull Parser parser = Xml . new Pull Parser ( ) ; parser . set Input ( in , null ) ; return ( Array List ) read Value Xml ( parser , new String [ NUM ] ) ; }
public static final Array List read List Xml ( Input Stream in ) throws Xml Pull Parser Exception , java . io . IO Exception { Xml Pull Parser parser = Xml . new Pull Parser ( ) ; parser . set Input ( in , null ) ; return ( Array List ) read Value Xml ( parser , new String [ NUM ] ) ; }
public static final Array List read List Xml ( Input Stream in ) throws Xml Pull Parser Exception , java . io . IO Exception { Xml Pull Parser parser = Xml . new Pull Parser ( ) ; parser . set Input ( in , null ) ; return ( Array List ) read Value Xml ( parser , new String [ NUM ] ) ; }
protected void init Result Matrix ( ) { m Result Matrix . set Size ( get Num Resultsets ( ) , get Num Datasets ( ) ) ; m Result Matrix . set Show Std Dev ( m Show Std Devs ) ; for ( int i = NUM ; i < get Num Datasets ( ) ; i ++ ) { m Result Matrix . set Row Name ( i , template String ( m Dataset Specifiers . specifier ( i ) ) ) ; } for ( int j = NUM ; j < get Num Resultsets ( ) ; j ++ ) { m Result Matrix . set Col Name ( j , get Resultset Name ( j ) ) ; m Result Matrix . set Col Hidden ( j , ! display Resultset ( j ) ) ; } }
protected void init Result Matrix ( ) { m Result Matrix . set Size ( get Num Resultsets ( ) , get Num Datasets ( ) ) ; m Result Matrix . set Show Std Dev ( m Show Std Devs ) ; for ( int i = NUM ; i < get Num Datasets ( ) ; i ++ ) { m Result Matrix . set Row Name ( i , template String ( m Dataset Specifiers . specifier ( i ) ) ) ; } for ( int j = NUM ; j < get Num Resultsets ( ) ; j ++ ) { m Result Matrix . set Col Name ( j , get Resultset Name ( j ) ) ; m Result Matrix . set Col Hidden ( j , ! display Resultset ( j ) ) ; } }
public static void enter Method ( int global Method Id ) { final Thread ct = Thread . current Thread ( ) ; if ( ct == Agent . server || Thread . holds Lock ( rl ) || Thread . holds Lock ( global Lock ) || ct . get Thread Group ( ) == system Thread Group || ct == Transformer . transformer Thread ) { return ; } if ( ! enabled ) { return ; } synchronized ( global Lock ) { int session Id Of Method = global Method Id > > NUM ; if ( session Id Of Method != session Id ) { return ; } int mid = global Method Id & NUM ; Thread Profiler ti = null ; synchronized ( rl ) { ti = global Thread Infos . get ( ct ) ; if ( ti == null ) { ti = new Thread Profiler ( ) ; global Thread Infos . put ( ct , ti ) ; } } ti . enter 0 ( global Methods [ mid ] ) ; } }
@ Override public int read ( final char [ ] array , final int offset , final int length ) { if ( idx >= char Sequence . length ( ) ) { return EOF ; } if ( array == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( length < NUM || offset < NUM || offset + length > array . length ) { throw new Index Out Of Bounds Exception ( STRING + array . length + STRING + offset + STRING + length ) ; } int count = NUM ; for ( int i = NUM ; i < length ; i ++ ) { final int c = read ( ) ; if ( c == EOF ) { return count ; } array [ offset + i ] = ( char ) c ; count ++ ; } return count ; }
public void accept ( final Annotation Visitor av ) { if ( av != null ) { if ( values != null ) { for ( int i = NUM ; i < values . size ( ) ; i += NUM ) { String name = ( String ) values . get ( i ) ; Object value = values . get ( i + NUM ) ; accept ( av , name , value ) ; } } av . visit End ( ) ; } }
public void resume ( ) { if ( ! is Paused ) return ; set Animation Interval ( old Animation Interval ) ; last Update = System . current Time Millis ( ) ; is Paused = BOOL ; dt = NUM ; }
public void resume ( ) { if ( ! is Paused ) return ; set Animation Interval ( old Animation Interval ) ; last Update = System . current Time Millis ( ) ; is Paused = BOOL ; dt = NUM ; }
protected void flush Cache ( ) throws IO Exception { if ( cache Position > NUM ) { final byte chunk Header [ ] = Encoding Util . get Ascii Bytes ( Integer . to Hex String ( cache Position ) + STRING ) ; stream . write ( chunk Header , NUM , chunk Header . length ) ; stream . write ( cache , NUM , cache Position ) ; stream . write ( ENDCHUNK , NUM , ENDCHUNK . length ) ; cache Position = NUM ; } }
protected void flush Cache ( ) throws IO Exception { if ( cache Position > NUM ) { final byte chunk Header [ ] = Encoding Util . get Ascii Bytes ( Integer . to Hex String ( cache Position ) + STRING ) ; stream . write ( chunk Header , NUM , chunk Header . length ) ; stream . write ( cache , NUM , cache Position ) ; stream . write ( ENDCHUNK , NUM , ENDCHUNK . length ) ; cache Position = NUM ; } }
public boolean dump VM Namespace ( String namespace ) { return vm Manager . dump Namespace ( namespace ) ; }
public boolean dump VM Namespace ( String namespace ) { return vm Manager . dump Namespace ( namespace ) ; }
private void update Group Chat View Title ( String subject ) { if ( ! Text Utils . is Empty ( subject ) ) { set Title ( get String ( R . string . title group chat ) + STRING + m Subject + STRING ) ; } }
protected void write Header ( ) throws IO Exception { header = new byte [ SHAPE FILE HEADER LENGTH ] ; write BE Int ( header , NUM , SHAPE FILE CODE ) ; write BE Int ( header , NUM , NUM ) ; write LE Int ( header , NUM , SHAPE FILE VERSION ) ; write LE Int ( header , NUM , SHAPE TYPE NULL ) ; write LE Double ( header , NUM , NUM ) ; write LE Double ( header , NUM , NUM ) ; write LE Double ( header , NUM , NUM ) ; write LE Double ( header , NUM , NUM ) ; raf . seek ( NUM ) ; raf . write ( header , NUM , SHAPE FILE HEADER LENGTH ) ; }
@ Override public boolean equals ( Object other ) { return this == other || ( other instanceof User && hash Code ( ) == other . hash Code ( ) ) ; }
private void create Distributed Sub Region ( List vm List , boolean first Creation Flag ) { Iterator node Iterator = vm List . iterator ( ) ; while ( node Iterator . has Next ( ) ) { VM vm = ( VM ) node Iterator . next ( ) ; vm . invoke ( create Sub Region ( first Creation Flag , DISTRIBUTED REGION ) ) ; } }
public static boolean is SQL 99 Non Reserved Keyword ( String identifier ) { if ( identifier == null ) { throw new Null Pointer Exception ( STRING ) ; } return Arrays . binary Search ( SQL 99 NON RESERVED , identifier . to Upper Case ( ) ) >= NUM ; }
public int add Item To End ( Shopping Cart Item item ) throws Cart Item Modify Exception { return add Item ( cart Lines . size ( ) , item ) ; }
private boolean process Notification ( Notification notification , Big Integer history Id , Metric metric , Alert alert , Entity Manager em ) { if ( ! should Evaluate Notification ( notification , history Id ) ) { return BOOL ; } String log Message = null ; if ( notification . is Active ( ) && notification . get Fired Trigger ( ) != null ) { Long trigger Fired Time = get Trigger Fired Datapoint Time ( notification . get Fired Trigger ( ) , metric ) ; if ( trigger Fired Time == null ) { clear Notification ( notification . get Fired Trigger ( ) , metric , history Id , notification , em , alert ) ; } } try { if ( ! notification . on Cooldown ( ) ) { for ( Trigger trigger : notification . get Triggers ( ) ) { boolean trigger Fired = evaluate Trigger ( trigger , metric , history Id , notification , em , alert ) ; if ( trigger Fired ) { break ; } } } else { log Message = Message Format . format ( STRING , notification . get Name ( ) , get Date MMDDYYYY ( notification . get Cooldown Expiration ( ) ) ) ; logger . info ( log Message ) ; append Message N Update History ( history Id , log Message , null , NUM , NUM ) ; } } catch ( Exception ex ) { log Message = Message Format . format ( STRING , notification . get Name ( ) , ex . to String ( ) ) ; logger . warn ( STRING , notification , ex . to String ( ) ) ; append Message N Update History ( history Id , log Message , null , NUM , NUM ) ; return BOOL ; } return BOOL ; }
private boolean process Notification ( Notification notification , Big Integer history Id , Metric metric , Alert alert , Entity Manager em ) { if ( ! should Evaluate Notification ( notification , history Id ) ) { return BOOL ; } String log Message = null ; if ( notification . is Active ( ) && notification . get Fired Trigger ( ) != null ) { Long trigger Fired Time = get Trigger Fired Datapoint Time ( notification . get Fired Trigger ( ) , metric ) ; if ( trigger Fired Time == null ) { clear Notification ( notification . get Fired Trigger ( ) , metric , history Id , notification , em , alert ) ; } } try { if ( ! notification . on Cooldown ( ) ) { for ( Trigger trigger : notification . get Triggers ( ) ) { boolean trigger Fired = evaluate Trigger ( trigger , metric , history Id , notification , em , alert ) ; if ( trigger Fired ) { break ; } } } else { log Message = Message Format . format ( STRING , notification . get Name ( ) , get Date MMDDYYYY ( notification . get Cooldown Expiration ( ) ) ) ; logger . info ( log Message ) ; append Message N Update History ( history Id , log Message , null , NUM , NUM ) ; } } catch ( Exception ex ) { log Message = Message Format . format ( STRING , notification . get Name ( ) , ex . to String ( ) ) ; logger . warn ( STRING , notification , ex . to String ( ) ) ; append Message N Update History ( history Id , log Message , null , NUM , NUM ) ; return BOOL ; } return BOOL ; }
public Engine Output ( List < String > o Std , List < String > o Err ) { std = Collections . unmodifiable List ( o Std ) ; err = Collections . unmodifiable List ( o Err ) ; }
public void validate Sub Partition Values ( List < String > sub Partition Values ) throws Illegal Argument Exception { int sub Partition Values Count = Collection Utils . size ( sub Partition Values ) ; Assert . is True ( sub Partition Values Count <= Business Object Data Entity . MAX SUBPARTITIONS , String . format ( STRING , Business Object Data Entity . MAX SUBPARTITIONS ) ) ; for ( int i = NUM ; i < sub Partition Values Count ; i ++ ) { sub Partition Values . set ( i , alternate Key Helper . validate String Parameter ( STRING , sub Partition Values . get ( i ) ) ) ; } }
protected void draw Center Text ( Canvas c ) { String center Text = m Chart . get Center Text ( ) ; if ( m Chart . is Draw Center Text Enabled ( ) && center Text != null ) { Point F center = m Chart . get Center Circle Box ( ) ; String [ ] lines = center Text . split ( STRING ) ; float maxlineheight = NUM ; for ( String line : lines ) { float cur Height = Utils . calc Text Height ( m Center Text Paint , line ) ; if ( cur Height > maxlineheight ) maxlineheight = cur Height ; } float linespacing = maxlineheight * NUM ; float totalheight = maxlineheight * lines . length - linespacing * ( lines . length - NUM ) ; int cnt = lines . length ; float y = center . y ; for ( int i = NUM ; i < lines . length ; i ++ ) { String line = lines [ lines . length - i - NUM ] ; c . draw Text ( line , center . x , y + maxlineheight * cnt - totalheight / NUM , m Center Text Paint ) ; cnt -- ; y -= linespacing ; } } }
protected void draw Center Text ( Canvas c ) { String center Text = m Chart . get Center Text ( ) ; if ( m Chart . is Draw Center Text Enabled ( ) && center Text != null ) { Point F center = m Chart . get Center Circle Box ( ) ; String [ ] lines = center Text . split ( STRING ) ; float maxlineheight = NUM ; for ( String line : lines ) { float cur Height = Utils . calc Text Height ( m Center Text Paint , line ) ; if ( cur Height > maxlineheight ) maxlineheight = cur Height ; } float linespacing = maxlineheight * NUM ; float totalheight = maxlineheight * lines . length - linespacing * ( lines . length - NUM ) ; int cnt = lines . length ; float y = center . y ; for ( int i = NUM ; i < lines . length ; i ++ ) { String line = lines [ lines . length - i - NUM ] ; c . draw Text ( line , center . x , y + maxlineheight * cnt - totalheight / NUM , m Center Text Paint ) ; cnt -- ; y -= linespacing ; } } }
public Polyline ( Pla Point Int p from corner , Pla Point Int p to corner ) { if ( p from corner . equals ( p to corner ) ) throw new Illegal Argument Exception ( classname + STRING ) ; lines list = new Array List < Pla Line Int > ( NUM ) ; Pla Direction dir = new Pla Direction ( p from corner , p to corner ) ; lines list . add ( new Pla Line Int ( p from corner , dir . rotate 45 deg ( NUM ) ) ) ; lines list . add ( new Pla Line Int ( p from corner , p to corner ) ) ; lines list . add ( new Pla Line Int ( p to corner , dir . rotate 45 deg ( NUM ) ) ) ; corners allocate ( corner count ( ) ) ; precalculated corners [ NUM ] = p from corner ; precalculated corners [ NUM ] = p to corner ; }
public List < Diff Row > generate Diff Rows ( List < String > original , List < String > revised ) { return generate Diff Rows ( original , revised , Diff Utils . diff ( original , revised , equalizer ) ) ; }
public List < Diff Row > generate Diff Rows ( List < String > original , List < String > revised ) { return generate Diff Rows ( original , revised , Diff Utils . diff ( original , revised , equalizer ) ) ; }
public List < Diff Row > generate Diff Rows ( List < String > original , List < String > revised ) { return generate Diff Rows ( original , revised , Diff Utils . diff ( original , revised , equalizer ) ) ; }
public List < Diff Row > generate Diff Rows ( List < String > original , List < String > revised ) { return generate Diff Rows ( original , revised , Diff Utils . diff ( original , revised , equalizer ) ) ; }
private T [ ] ensure Capacity ( int min Capacity ) { if ( tmp . length < min Capacity ) { int new Size = min Capacity ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size ++ ; if ( new Size < NUM ) new Size = min Capacity ; else new Size = Math . min ( new Size , a . length > > > NUM ) ; T [ ] new Array = ( T [ ] ) new Object [ new Size ] ; tmp = new Array ; } return tmp ; }
private T [ ] ensure Capacity ( int min Capacity ) { if ( tmp . length < min Capacity ) { int new Size = min Capacity ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size ++ ; if ( new Size < NUM ) new Size = min Capacity ; else new Size = Math . min ( new Size , a . length > > > NUM ) ; T [ ] new Array = ( T [ ] ) new Object [ new Size ] ; tmp = new Array ; } return tmp ; }
private T [ ] ensure Capacity ( int min Capacity ) { if ( tmp . length < min Capacity ) { int new Size = min Capacity ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size ++ ; if ( new Size < NUM ) new Size = min Capacity ; else new Size = Math . min ( new Size , a . length > > > NUM ) ; T [ ] new Array = ( T [ ] ) new Object [ new Size ] ; tmp = new Array ; } return tmp ; }
private T [ ] ensure Capacity ( int min Capacity ) { if ( tmp . length < min Capacity ) { int new Size = min Capacity ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size ++ ; if ( new Size < NUM ) new Size = min Capacity ; else new Size = Math . min ( new Size , a . length > > > NUM ) ; T [ ] new Array = ( T [ ] ) new Object [ new Size ] ; tmp = new Array ; } return tmp ; }
public void sort From To ( int from , int to ) { final int width Threshold = NUM ; if ( size == NUM ) return ; check Range From To ( from , to , size ) ; long min = elements [ from ] ; long max = elements [ from ] ; long [ ] the Elements = elements ; for ( int i = from + NUM ; i <= to ; ) { long elem = the Elements [ i ++ ] ; if ( elem > max ) max = elem ; else if ( elem < min ) min = elem ; } double N = ( double ) to - ( double ) from + NUM ; double quick Sort Estimate = N * Math . log ( N ) / NUM ; double width = ( double ) max - ( double ) min + NUM ; double count Sort Estimate = Math . max ( width , N ) ; if ( width < width Threshold && count Sort Estimate < quick Sort Estimate ) { count Sort From To ( from , to , min , max ) ; } else { quick Sort From To ( from , to ) ; } }
public void sort From To ( int from , int to ) { final int width Threshold = NUM ; if ( size == NUM ) return ; check Range From To ( from , to , size ) ; long min = elements [ from ] ; long max = elements [ from ] ; long [ ] the Elements = elements ; for ( int i = from + NUM ; i <= to ; ) { long elem = the Elements [ i ++ ] ; if ( elem > max ) max = elem ; else if ( elem < min ) min = elem ; } double N = ( double ) to - ( double ) from + NUM ; double quick Sort Estimate = N * Math . log ( N ) / NUM ; double width = ( double ) max - ( double ) min + NUM ; double count Sort Estimate = Math . max ( width , N ) ; if ( width < width Threshold && count Sort Estimate < quick Sort Estimate ) { count Sort From To ( from , to , min , max ) ; } else { quick Sort From To ( from , to ) ; } }
public void sort From To ( int from , int to ) { final int width Threshold = NUM ; if ( size == NUM ) return ; check Range From To ( from , to , size ) ; long min = elements [ from ] ; long max = elements [ from ] ; long [ ] the Elements = elements ; for ( int i = from + NUM ; i <= to ; ) { long elem = the Elements [ i ++ ] ; if ( elem > max ) max = elem ; else if ( elem < min ) min = elem ; } double N = ( double ) to - ( double ) from + NUM ; double quick Sort Estimate = N * Math . log ( N ) / NUM ; double width = ( double ) max - ( double ) min + NUM ; double count Sort Estimate = Math . max ( width , N ) ; if ( width < width Threshold && count Sort Estimate < quick Sort Estimate ) { count Sort From To ( from , to , min , max ) ; } else { quick Sort From To ( from , to ) ; } }
public void sort From To ( int from , int to ) { final int width Threshold = NUM ; if ( size == NUM ) return ; check Range From To ( from , to , size ) ; long min = elements [ from ] ; long max = elements [ from ] ; long [ ] the Elements = elements ; for ( int i = from + NUM ; i <= to ; ) { long elem = the Elements [ i ++ ] ; if ( elem > max ) max = elem ; else if ( elem < min ) min = elem ; } double N = ( double ) to - ( double ) from + NUM ; double quick Sort Estimate = N * Math . log ( N ) / NUM ; double width = ( double ) max - ( double ) min + NUM ; double count Sort Estimate = Math . max ( width , N ) ; if ( width < width Threshold && count Sort Estimate < quick Sort Estimate ) { count Sort From To ( from , to , min , max ) ; } else { quick Sort From To ( from , to ) ; } }
public void sort From To ( int from , int to ) { final int width Threshold = NUM ; if ( size == NUM ) return ; check Range From To ( from , to , size ) ; long min = elements [ from ] ; long max = elements [ from ] ; long [ ] the Elements = elements ; for ( int i = from + NUM ; i <= to ; ) { long elem = the Elements [ i ++ ] ; if ( elem > max ) max = elem ; else if ( elem < min ) min = elem ; } double N = ( double ) to - ( double ) from + NUM ; double quick Sort Estimate = N * Math . log ( N ) / NUM ; double width = ( double ) max - ( double ) min + NUM ; double count Sort Estimate = Math . max ( width , N ) ; if ( width < width Threshold && count Sort Estimate < quick Sort Estimate ) { count Sort From To ( from , to , min , max ) ; } else { quick Sort From To ( from , to ) ; } }
public static String parse Disk String ( String input ) { String delims = STRING ; String [ ] tokens = input . split ( delims ) ; return tokens [ NUM ] ; }
public boolean add User ( @ Not Null User user ) { int updated Rows = NUM ; try { final Prepared Statement prepared Statement = connetion . get Prepared Statement ( STRING + STRING ) ; prepared Statement . set Int ( NUM , user . get User Id ( ) ) ; if ( ( user . get User Hash ( ) == null ) || ( user . get User Hash ( ) == NUM ) ) { prepared Statement . set Null ( NUM , Types . NUMERIC ) ; } else { prepared Statement . set Long ( NUM , user . get User Hash ( ) ) ; } updated Rows = prepared Statement . execute Update ( ) ; } catch ( SQL Exception e ) { Bot Logger . error ( LOGTAG , e ) ; } return updated Rows > NUM ; }
public void offset ( float dx , float dy , Path Delegate dst ) { General Path new Path = new General Path ( ) ; Path Iterator iterator = m Path . get Path Iterator ( new Affine Transform ( NUM , NUM , dx , NUM , NUM , dy ) ) ; new Path . append ( iterator , BOOL ) ; if ( dst != null ) { dst . m Path = new Path ; } else { m Path = new Path ; } }
public static Js Date to Js ( Date java ) { return java == null ? null : create ( java . get Time ( ) ) ; }
public static Js Date to Js ( Date java ) { return java == null ? null : create ( java . get Time ( ) ) ; }
private static String attribute Values String ( Instance instance , Range att Range ) { String Buffer text = new String Buffer ( ) ; if ( att Range != null ) { boolean first Output = BOOL ; att Range . set Upper ( instance . num Attributes ( ) - NUM ) ; for ( int i = NUM ; i < instance . num Attributes ( ) ; i ++ ) { if ( att Range . is In Range ( i ) ) { if ( first Output ) { text . append ( STRING ) ; } else { text . append ( STRING ) ; } text . append ( instance . to String ( i ) ) ; first Output = BOOL ; } } if ( ! first Output ) { text . append ( STRING ) ; } } return text . to String ( ) ; }
private static String attribute Values String ( Instance instance , Range att Range ) { String Buffer text = new String Buffer ( ) ; if ( att Range != null ) { boolean first Output = BOOL ; att Range . set Upper ( instance . num Attributes ( ) - NUM ) ; for ( int i = NUM ; i < instance . num Attributes ( ) ; i ++ ) { if ( att Range . is In Range ( i ) ) { if ( first Output ) { text . append ( STRING ) ; } else { text . append ( STRING ) ; } text . append ( instance . to String ( i ) ) ; first Output = BOOL ; } } if ( ! first Output ) { text . append ( STRING ) ; } } return text . to String ( ) ; }
protected abstract boolean is End Of Chunk ( char curr Prefix , String curr Label , char next Prefix , String next Label ) ;
protected abstract boolean is End Of Chunk ( char curr Prefix , String curr Label , char next Prefix , String next Label ) ;
public < T > List < T > test Two Threads One Item ( T a , T b ) { Trace . trace ( Item . SCHEDULER , STRING ) ; List < T > results = Collections . synchronized List ( new Array List < T > ( NUM ) ) ; Scheduler . schedule Mutator ( new Test Mutator < T > ( results , a ) ) ; Scheduler . schedule Mutator ( new Test Mutator < T > ( results , b ) ) ; Scheduler . schedule ( ) ; Trace . trace ( Item . SCHEDULER , STRING ) ; return results ; }
public < T > List < T > test Two Threads One Item ( T a , T b ) { Trace . trace ( Item . SCHEDULER , STRING ) ; List < T > results = Collections . synchronized List ( new Array List < T > ( NUM ) ) ; Scheduler . schedule Mutator ( new Test Mutator < T > ( results , a ) ) ; Scheduler . schedule Mutator ( new Test Mutator < T > ( results , b ) ) ; Scheduler . schedule ( ) ; Trace . trace ( Item . SCHEDULER , STRING ) ; return results ; }
public < T > List < T > test Two Threads One Item ( T a , T b ) { Trace . trace ( Item . SCHEDULER , STRING ) ; List < T > results = Collections . synchronized List ( new Array List < T > ( NUM ) ) ; Scheduler . schedule Mutator ( new Test Mutator < T > ( results , a ) ) ; Scheduler . schedule Mutator ( new Test Mutator < T > ( results , b ) ) ; Scheduler . schedule ( ) ; Trace . trace ( Item . SCHEDULER , STRING ) ; return results ; }
public < T > List < T > test Two Threads One Item ( T a , T b ) { Trace . trace ( Item . SCHEDULER , STRING ) ; List < T > results = Collections . synchronized List ( new Array List < T > ( NUM ) ) ; Scheduler . schedule Mutator ( new Test Mutator < T > ( results , a ) ) ; Scheduler . schedule Mutator ( new Test Mutator < T > ( results , b ) ) ; Scheduler . schedule ( ) ; Trace . trace ( Item . SCHEDULER , STRING ) ; return results ; }
public static Graph < String , Number > create Directed Acyclic Graph ( int layers , int max Nodes Per Layer , double linkprob ) { Directed Graph < String , Number > dag = new Directed Sparse Multigraph < String , Number > ( ) ; Set < String > previous Layers = new Hash Set < String > ( ) ; Set < String > in This Layer = new Hash Set < String > ( ) ; for ( int i = NUM ; i < layers ; i ++ ) { int nodes This Layer = ( int ) ( Math . random ( ) * max Nodes Per Layer ) + NUM ; for ( int j = NUM ; j < nodes This Layer ; j ++ ) { String v = i + STRING + j ; dag . add Vertex ( v ) ; in This Layer . add ( v ) ; for ( String v2 : previous Layers ) { if ( Math . random ( ) < linkprob ) { Double de = new Double ( Math . random ( ) ) ; dag . add Edge ( de , v , v2 ) ; } } } previous Layers . add All ( in This Layer ) ; in This Layer . clear ( ) ; } return dag ; }
public static Graph < String , Number > create Directed Acyclic Graph ( int layers , int max Nodes Per Layer , double linkprob ) { Directed Graph < String , Number > dag = new Directed Sparse Multigraph < String , Number > ( ) ; Set < String > previous Layers = new Hash Set < String > ( ) ; Set < String > in This Layer = new Hash Set < String > ( ) ; for ( int i = NUM ; i < layers ; i ++ ) { int nodes This Layer = ( int ) ( Math . random ( ) * max Nodes Per Layer ) + NUM ; for ( int j = NUM ; j < nodes This Layer ; j ++ ) { String v = i + STRING + j ; dag . add Vertex ( v ) ; in This Layer . add ( v ) ; for ( String v2 : previous Layers ) { if ( Math . random ( ) < linkprob ) { Double de = new Double ( Math . random ( ) ) ; dag . add Edge ( de , v , v2 ) ; } } } previous Layers . add All ( in This Layer ) ; in This Layer . clear ( ) ; } return dag ; }
public static Graph < String , Number > create Directed Acyclic Graph ( int layers , int max Nodes Per Layer , double linkprob ) { Directed Graph < String , Number > dag = new Directed Sparse Multigraph < String , Number > ( ) ; Set < String > previous Layers = new Hash Set < String > ( ) ; Set < String > in This Layer = new Hash Set < String > ( ) ; for ( int i = NUM ; i < layers ; i ++ ) { int nodes This Layer = ( int ) ( Math . random ( ) * max Nodes Per Layer ) + NUM ; for ( int j = NUM ; j < nodes This Layer ; j ++ ) { String v = i + STRING + j ; dag . add Vertex ( v ) ; in This Layer . add ( v ) ; for ( String v2 : previous Layers ) { if ( Math . random ( ) < linkprob ) { Double de = new Double ( Math . random ( ) ) ; dag . add Edge ( de , v , v2 ) ; } } } previous Layers . add All ( in This Layer ) ; in This Layer . clear ( ) ; } return dag ; }
public static Graph < String , Number > create Directed Acyclic Graph ( int layers , int max Nodes Per Layer , double linkprob ) { Directed Graph < String , Number > dag = new Directed Sparse Multigraph < String , Number > ( ) ; Set < String > previous Layers = new Hash Set < String > ( ) ; Set < String > in This Layer = new Hash Set < String > ( ) ; for ( int i = NUM ; i < layers ; i ++ ) { int nodes This Layer = ( int ) ( Math . random ( ) * max Nodes Per Layer ) + NUM ; for ( int j = NUM ; j < nodes This Layer ; j ++ ) { String v = i + STRING + j ; dag . add Vertex ( v ) ; in This Layer . add ( v ) ; for ( String v2 : previous Layers ) { if ( Math . random ( ) < linkprob ) { Double de = new Double ( Math . random ( ) ) ; dag . add Edge ( de , v , v2 ) ; } } } previous Layers . add All ( in This Layer ) ; in This Layer . clear ( ) ; } return dag ; }
public static Graph < String , Number > create Directed Acyclic Graph ( int layers , int max Nodes Per Layer , double linkprob ) { Directed Graph < String , Number > dag = new Directed Sparse Multigraph < String , Number > ( ) ; Set < String > previous Layers = new Hash Set < String > ( ) ; Set < String > in This Layer = new Hash Set < String > ( ) ; for ( int i = NUM ; i < layers ; i ++ ) { int nodes This Layer = ( int ) ( Math . random ( ) * max Nodes Per Layer ) + NUM ; for ( int j = NUM ; j < nodes This Layer ; j ++ ) { String v = i + STRING + j ; dag . add Vertex ( v ) ; in This Layer . add ( v ) ; for ( String v2 : previous Layers ) { if ( Math . random ( ) < linkprob ) { Double de = new Double ( Math . random ( ) ) ; dag . add Edge ( de , v , v2 ) ; } } } previous Layers . add All ( in This Layer ) ; in This Layer . clear ( ) ; } return dag ; }
public Map < String , String > parse ( final String str , char [ ] separators ) { if ( separators == null || separators . length == NUM ) { return new Hash Map < String , String > ( ) ; } char separator = separators [ NUM ] ; if ( str != null ) { int idx = str . length ( ) ; for ( int i = NUM ; i < separators . length ; i ++ ) { int tmp = str . index Of ( separators [ i ] ) ; if ( tmp != - NUM ) { if ( tmp < idx ) { idx = tmp ; separator = separators [ i ] ; } } } } return parse ( str , separator ) ; }
public Map < String , String > parse ( final String str , char [ ] separators ) { if ( separators == null || separators . length == NUM ) { return new Hash Map < String , String > ( ) ; } char separator = separators [ NUM ] ; if ( str != null ) { int idx = str . length ( ) ; for ( int i = NUM ; i < separators . length ; i ++ ) { int tmp = str . index Of ( separators [ i ] ) ; if ( tmp != - NUM ) { if ( tmp < idx ) { idx = tmp ; separator = separators [ i ] ; } } } } return parse ( str , separator ) ; }
public Map < String , String > parse ( final String str , char [ ] separators ) { if ( separators == null || separators . length == NUM ) { return new Hash Map < String , String > ( ) ; } char separator = separators [ NUM ] ; if ( str != null ) { int idx = str . length ( ) ; for ( int i = NUM ; i < separators . length ; i ++ ) { int tmp = str . index Of ( separators [ i ] ) ; if ( tmp != - NUM ) { if ( tmp < idx ) { idx = tmp ; separator = separators [ i ] ; } } } } return parse ( str , separator ) ; }
private void draw Fill ( Graphics g , int x , int y , int w , int h ) { g . set Color ( Color . BLACK ) ; g . draw Rect ( x , y , w , h ) ; g . set Color ( Color . LIGHT GRAY ) ; g . fill Rect ( x , y , w , h ) ; }
@ Override public void write Start Document ( String encoding , String version ) throws XML Stream Exception { log . log ( Level . FINE , STRING , new Object [ ] { encoding , version } ) ; if ( encoding == null ) { encoding = this . encoding ; } doc = new Wb Xml Document ( Wb Xml Version . VERSION 1 3 , Iana Charset . get Iana Charset ( encoding ) ) ; if ( def != null ) { log . log ( Level . FINE , STRING , def . get Name ( ) ) ; doc . set Definition ( def ) ; } }
@ Override public void write Start Document ( String encoding , String version ) throws XML Stream Exception { log . log ( Level . FINE , STRING , new Object [ ] { encoding , version } ) ; if ( encoding == null ) { encoding = this . encoding ; } doc = new Wb Xml Document ( Wb Xml Version . VERSION 1 3 , Iana Charset . get Iana Charset ( encoding ) ) ; if ( def != null ) { log . log ( Level . FINE , STRING , def . get Name ( ) ) ; doc . set Definition ( def ) ; } }
@ Override public void write Start Document ( String encoding , String version ) throws XML Stream Exception { log . log ( Level . FINE , STRING , new Object [ ] { encoding , version } ) ; if ( encoding == null ) { encoding = this . encoding ; } doc = new Wb Xml Document ( Wb Xml Version . VERSION 1 3 , Iana Charset . get Iana Charset ( encoding ) ) ; if ( def != null ) { log . log ( Level . FINE , STRING , def . get Name ( ) ) ; doc . set Definition ( def ) ; } }
@ Override public void write Start Document ( String encoding , String version ) throws XML Stream Exception { log . log ( Level . FINE , STRING , new Object [ ] { encoding , version } ) ; if ( encoding == null ) { encoding = this . encoding ; } doc = new Wb Xml Document ( Wb Xml Version . VERSION 1 3 , Iana Charset . get Iana Charset ( encoding ) ) ; if ( def != null ) { log . log ( Level . FINE , STRING , def . get Name ( ) ) ; doc . set Definition ( def ) ; } }
private void update Poly Line ( Lat Lng lat Lng ) { List < Lat Lng > points = poly Line . get Points ( ) ; points . add ( lat Lng ) ; poly Line . set Points ( points ) ; }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . PUT ) @ Response Body public Rest Wrapper insert ( @ Model Attribute ( STRING ) @ Valid Workflow Type workflow Type , Binding Result binding Result , Principal principal ) { Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) { Binding Result Error binding Result Error = new Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { com . wipro . ats . bdre . md . dao . jpa . Workflow Type jpa Workflow Type = new com . wipro . ats . bdre . md . dao . jpa . Workflow Type ( ) ; jpa Workflow Type . set Workflow Id ( workflow Type . get Workflow Id ( ) ) ; jpa Workflow Type . set Workflow Type Name ( workflow Type . get Workflow Type Name ( ) ) ; workflow Type DAO . insert ( jpa Workflow Type ) ; rest Wrapper = new Rest Wrapper ( workflow Type , Rest Wrapper . OK ) ; LOGGER . info ( STRING + workflow Type . get Workflow Id ( ) + STRING + principal . get Name ( ) + workflow Type ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . PUT ) @ Response Body public Rest Wrapper insert ( @ Model Attribute ( STRING ) @ Valid Workflow Type workflow Type , Binding Result binding Result , Principal principal ) { Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) { Binding Result Error binding Result Error = new Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { com . wipro . ats . bdre . md . dao . jpa . Workflow Type jpa Workflow Type = new com . wipro . ats . bdre . md . dao . jpa . Workflow Type ( ) ; jpa Workflow Type . set Workflow Id ( workflow Type . get Workflow Id ( ) ) ; jpa Workflow Type . set Workflow Type Name ( workflow Type . get Workflow Type Name ( ) ) ; workflow Type DAO . insert ( jpa Workflow Type ) ; rest Wrapper = new Rest Wrapper ( workflow Type , Rest Wrapper . OK ) ; LOGGER . info ( STRING + workflow Type . get Workflow Id ( ) + STRING + principal . get Name ( ) + workflow Type ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
public Rel Node convert Select ( Sql Select select , boolean top ) { final Sql Validator Scope select Scope = validator . get Where Scope ( select ) ; final Blackboard bb = create Blackboard ( select Scope , null , top ) ; convert Select Impl ( bb , select ) ; return bb . root ; }
public static String [ ] split Without Escaped ( String str , char separator Char , boolean retain Empty ) { int len = str . length ( ) ; if ( len == NUM ) { return new String [ NUM ] ; } List < String > list = new Array List < String > ( ) ; int i = NUM ; int start = NUM ; boolean match = BOOL ; while ( i < len ) { if ( str . char At ( i ) == STRING ) { match = BOOL ; i += NUM ; } else if ( str . char At ( i ) == separator Char ) { if ( retain Empty || match ) { list . add ( str . substring ( start , i ) ) ; match = BOOL ; } start = ++ i ; } else { match = BOOL ; i ++ ; } } if ( retain Empty || match ) { list . add ( str . substring ( start , i ) ) ; } return list . to Array ( new String [ list . size ( ) ] ) ; }
public static String [ ] split Without Escaped ( String str , char separator Char , boolean retain Empty ) { int len = str . length ( ) ; if ( len == NUM ) { return new String [ NUM ] ; } List < String > list = new Array List < String > ( ) ; int i = NUM ; int start = NUM ; boolean match = BOOL ; while ( i < len ) { if ( str . char At ( i ) == STRING ) { match = BOOL ; i += NUM ; } else if ( str . char At ( i ) == separator Char ) { if ( retain Empty || match ) { list . add ( str . substring ( start , i ) ) ; match = BOOL ; } start = ++ i ; } else { match = BOOL ; i ++ ; } } if ( retain Empty || match ) { list . add ( str . substring ( start , i ) ) ; } return list . to Array ( new String [ list . size ( ) ] ) ; }
public void reset Network State ( ) { m State Depository . clear ( ) ; m Transition Direction = State Transition Direction . DO NOTHING ; m Transition Target = State . UNKNOWN ; }
public String to Hex String ( final int start , final int length ) { final int rounded Start = ( start / LOG BYTES PER ROW ) * LOG BYTES PER ROW ; final String Builder sb = new String Builder ( STRING ) ; int index = rounded Start ; for ( int n Logged = NUM ; n Logged < length ; n Logged += LOG BYTES PER ROW ) { sb . append ( String . format ( STRING , index , index + LOG BYTES PER ROW - NUM ) ) ; for ( int i = NUM ; i < LOG BYTES PER ROW ; ++ i ) { try { final byte b = get Byte ( index ++ ) ; sb . append ( String . format ( STRING , b ) ) ; } catch ( Index Out Of Bounds Exception ioob ) { sb . append ( STRING ) ; } } sb . append ( STRING ) ; } return sb . to String ( ) ; }
private void reverse Children ( ) { List < View > children = new Array List < View > ( ) ; for ( int i = get Child Count ( ) - NUM ; i >= NUM ; i -- ) { children . add ( get Child At ( i ) ) ; } for ( View v : children ) { bring Child To Front ( v ) ; } }
private void reverse Children ( ) { List < View > children = new Array List < View > ( ) ; for ( int i = get Child Count ( ) - NUM ; i >= NUM ; i -- ) { children . add ( get Child At ( i ) ) ; } for ( View v : children ) { bring Child To Front ( v ) ; } }
private void reverse Children ( ) { List < View > children = new Array List < View > ( ) ; for ( int i = get Child Count ( ) - NUM ; i >= NUM ; i -- ) { children . add ( get Child At ( i ) ) ; } for ( View v : children ) { bring Child To Front ( v ) ; } }
public String tree To File Position String ( Tree tree , Compilation Unit Tree current Root , Processing Environment processing Env ) { if ( tree == null ) { return null ; } Source Positions source Positions = trees . get Source Positions ( ) ; long start = source Positions . get Start Position ( current Root , tree ) ; long end = source Positions . get End Position ( current Root , tree ) ; return STRING + start + STRING + end + STRING ; }
public String tree To File Position String ( Tree tree , Compilation Unit Tree current Root , Processing Environment processing Env ) { if ( tree == null ) { return null ; } Source Positions source Positions = trees . get Source Positions ( ) ; long start = source Positions . get Start Position ( current Root , tree ) ; long end = source Positions . get End Position ( current Root , tree ) ; return STRING + start + STRING + end + STRING ; }
public String tree To File Position String ( Tree tree , Compilation Unit Tree current Root , Processing Environment processing Env ) { if ( tree == null ) { return null ; } Source Positions source Positions = trees . get Source Positions ( ) ; long start = source Positions . get Start Position ( current Root , tree ) ; long end = source Positions . get End Position ( current Root , tree ) ; return STRING + start + STRING + end + STRING ; }
public static String right Pad ( String original , int length , char pad Char ) { if ( original . length ( ) >= length ) { return original ; } return original + string Of Char ( pad Char , length - original . length ( ) ) ; }
public static String right Pad ( String original , int length , char pad Char ) { if ( original . length ( ) >= length ) { return original ; } return original + string Of Char ( pad Char , length - original . length ( ) ) ; }
public void add ( Leaf Atom atom ) { leaf Children . add ( atom ) ; }
public String to String ( ) { return Byte . to String ( get Value ( ) ) ; }
public static String format Millis To GMT ( long milliseconds ) { Date date = new Date ( milliseconds ) ; Simple Date Format simple Date Format = new Simple Date Format ( FORMAT HTTP DATA , Locale . US ) ; simple Date Format . set Time Zone ( GMT TIME ZONE ) ; return simple Date Format . format ( date ) ; }
public static String format Millis To GMT ( long milliseconds ) { Date date = new Date ( milliseconds ) ; Simple Date Format simple Date Format = new Simple Date Format ( FORMAT HTTP DATA , Locale . US ) ; simple Date Format . set Time Zone ( GMT TIME ZONE ) ; return simple Date Format . format ( date ) ; }
public Map < String , String > environment ( ) { String base 64 = to String Base 64 ( ) ; if ( base 64 == null || base 64 . length ( ) == NUM ) { return Collections . empty Map ( ) ; } Map < String , String > environment = Maps . new Hash Map ( ) ; environment . put ( Baggage Utils . BAGGAGE ENVIRONMENT VARIABLE , base 64 ) ; return environment ; }
private Rectangle 2 D view To Frame ( Rectangle 2 D view ) { double width = view . get Width ( ) / this . view W ; double height = view . get Height ( ) / this . view H ; double x = view . get X ( ) - ( width * this . view X ) ; double y = view . get Y ( ) - ( height * this . view Y ) ; return new Rectangle 2 D . Double ( x , y , width , height ) ; }
private Rectangle 2 D view To Frame ( Rectangle 2 D view ) { double width = view . get Width ( ) / this . view W ; double height = view . get Height ( ) / this . view H ; double x = view . get X ( ) - ( width * this . view X ) ; double y = view . get Y ( ) - ( height * this . view Y ) ; return new Rectangle 2 D . Double ( x , y , width , height ) ; }
public void add Listener ( U type , T listener ) { List < T > newlisteners = new Array List < T > ( ) ; if ( listeners != null ) newlisteners . add All ( listeners ) ; newlisteners . add ( listener ) ; List < T > terminals = new Array List < T > ( ) ; for ( T i : newlisteners ) { boolean isterm = BOOL ; for ( T j : newlisteners ) { if ( ispre ( type , i , j ) ) { isterm = BOOL ; break ; } } if ( isterm ) { terminals . add ( i ) ; } } if ( terminals . size ( ) == NUM ) { logger . error ( STRING + STRING ) ; listeners = newlisteners ; return ; } Hash Set < T > visited = new Hash Set < T > ( ) ; List < T > ordering = new Array List < T > ( ) ; for ( T term : terminals ) { visit ( newlisteners , type , visited , ordering , term ) ; } listeners = ordering ; }
public void truncate ( final long size ) throws File Not Found Exception , IO Exception { file Channel . truncate ( Math . max ( size , write Position ) ) ; }
static Set < String > parse Path Parameters ( String path ) { Matcher m = PARAM URL REGEX . matcher ( path ) ; Set < String > patterns = new Linked Hash Set < String > ( ) ; while ( m . find ( ) ) { patterns . add ( m . group ( NUM ) ) ; } return patterns ; }
static Set < String > parse Path Parameters ( String path ) { Matcher m = PARAM URL REGEX . matcher ( path ) ; Set < String > patterns = new Linked Hash Set < String > ( ) ; while ( m . find ( ) ) { patterns . add ( m . group ( NUM ) ) ; } return patterns ; }
static Set < String > parse Path Parameters ( String path ) { Matcher m = PARAM URL REGEX . matcher ( path ) ; Set < String > patterns = new Linked Hash Set < String > ( ) ; while ( m . find ( ) ) { patterns . add ( m . group ( NUM ) ) ; } return patterns ; }
static Set < String > parse Path Parameters ( String path ) { Matcher m = PARAM URL REGEX . matcher ( path ) ; Set < String > patterns = new Linked Hash Set < String > ( ) ; while ( m . find ( ) ) { patterns . add ( m . group ( NUM ) ) ; } return patterns ; }
static Set < String > parse Path Parameters ( String path ) { Matcher m = PARAM URL REGEX . matcher ( path ) ; Set < String > patterns = new Linked Hash Set < String > ( ) ; while ( m . find ( ) ) { patterns . add ( m . group ( NUM ) ) ; } return patterns ; }
static Set < String > parse Path Parameters ( String path ) { Matcher m = PARAM URL REGEX . matcher ( path ) ; Set < String > patterns = new Linked Hash Set < String > ( ) ; while ( m . find ( ) ) { patterns . add ( m . group ( NUM ) ) ; } return patterns ; }
public Ordered Thread Pool Executor ( int maximum Pool Size ) { this ( DEFAULT INITIAL THREAD POOL SIZE , maximum Pool Size , DEFAULT KEEP ALIVE , Time Unit . SECONDS , Executors . default Thread Factory ( ) , null ) ; }
public static void remove Forward ( Inet Socket Address adb Sock Addr , Device device , String local Port Spec , String remote Port Spec ) throws Timeout Exception , Adb Command Rejected Exception , IO Exception { try ( Socket Channel adb Chan = Socket Channel . open ( adb Sock Addr ) ) { adb Chan . configure Blocking ( BOOL ) ; byte [ ] request = form Adb Request ( String . format ( STRING , device . get Serial Number ( ) , local Port Spec ) ) ; write ( adb Chan , request ) ; Adb Response resp = read Adb Response ( adb Chan , BOOL ) ; if ( ! resp . okay ) { Log . w ( STRING , STRING + resp . message ) ; throw new Adb Command Rejected Exception ( resp . message ) ; } } }
@ Override public void write ( Data Output out ) throws IO Exception { if ( USE HADOOP TEXT ) Text . write String ( out , term ) ; else out . write UTF ( term ) ; Writable Utils . write V Int ( out , splitno ) ; Writable Utils . write V Int ( out , flushno ) ; }
public int type Index From Class Def Index ( int class Def Index ) { check Bounds ( class Def Index , table Of Contents . class Defs . size ) ; int position = table Of Contents . class Defs . off + ( Size Of . CLASS DEF ITEM * class Def Index ) ; return data . get Int ( position ) ; }
public final static Header Element parse Header Element ( final String value , Header Value Parser parser ) throws Parse Exception { if ( value == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( parser == null ) parser = Basic Header Value Parser . DEFAULT ; Char Array Buffer buffer = new Char Array Buffer ( value . length ( ) ) ; buffer . append ( value ) ; Parser Cursor cursor = new Parser Cursor ( NUM , value . length ( ) ) ; return parser . parse Header Element ( buffer , cursor ) ; }
public void write ( final int c ) throws IO Exception { if ( m writer != null ) m writer . write ( c ) ; if ( count >= buf length ) flush Buffer ( ) ; if ( c < NUM ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < NUM ) { buf [ count ++ ] = ( byte ) ( NUM + ( c > > NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( c & NUM ) ) ; } else { buf [ count ++ ] = ( byte ) ( NUM + ( c > > NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( ( c > > NUM ) & NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( c & NUM ) ) ; } }
public void write ( final int c ) throws IO Exception { if ( m writer != null ) m writer . write ( c ) ; if ( count >= buf length ) flush Buffer ( ) ; if ( c < NUM ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < NUM ) { buf [ count ++ ] = ( byte ) ( NUM + ( c > > NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( c & NUM ) ) ; } else { buf [ count ++ ] = ( byte ) ( NUM + ( c > > NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( ( c > > NUM ) & NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( c & NUM ) ) ; } }
public void write ( final int c ) throws IO Exception { if ( m writer != null ) m writer . write ( c ) ; if ( count >= buf length ) flush Buffer ( ) ; if ( c < NUM ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < NUM ) { buf [ count ++ ] = ( byte ) ( NUM + ( c > > NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( c & NUM ) ) ; } else { buf [ count ++ ] = ( byte ) ( NUM + ( c > > NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( ( c > > NUM ) & NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( c & NUM ) ) ; } }
public void write ( final int c ) throws IO Exception { if ( m writer != null ) m writer . write ( c ) ; if ( count >= buf length ) flush Buffer ( ) ; if ( c < NUM ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < NUM ) { buf [ count ++ ] = ( byte ) ( NUM + ( c > > NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( c & NUM ) ) ; } else { buf [ count ++ ] = ( byte ) ( NUM + ( c > > NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( ( c > > NUM ) & NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( c & NUM ) ) ; } }
public void write ( final int c ) throws IO Exception { if ( m writer != null ) m writer . write ( c ) ; if ( count >= buf length ) flush Buffer ( ) ; if ( c < NUM ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < NUM ) { buf [ count ++ ] = ( byte ) ( NUM + ( c > > NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( c & NUM ) ) ; } else { buf [ count ++ ] = ( byte ) ( NUM + ( c > > NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( ( c > > NUM ) & NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( c & NUM ) ) ; } }
public void discoverable ( Bluetooth Adapter adapter ) { int mask = Bluetooth Receiver . SCAN MODE CONNECTABLE DISCOVERABLE FLAG ; if ( ! adapter . is Enabled ( ) ) { fail ( STRING ) ; } int scan Mode = adapter . get Scan Mode ( ) ; if ( scan Mode == Bluetooth Adapter . SCAN MODE CONNECTABLE DISCOVERABLE ) { return ; } Bluetooth Receiver receiver = get Bluetooth Receiver ( mask ) ; assert Equals ( Bluetooth Adapter . SCAN MODE CONNECTABLE , scan Mode ) ; long start = System . current Time Millis ( ) ; assert True ( adapter . set Scan Mode ( Bluetooth Adapter . SCAN MODE CONNECTABLE DISCOVERABLE ) ) ; while ( System . current Time Millis ( ) - start < DISCOVERABLE UNDISCOVERABLE TIMEOUT ) { scan Mode = adapter . get Scan Mode ( ) ; if ( scan Mode == Bluetooth Adapter . SCAN MODE CONNECTABLE DISCOVERABLE && ( receiver . get Fired Flags ( ) & mask ) == mask ) { write Output ( String . format ( STRING , ( receiver . get Completed Time ( ) - start ) ) ) ; remove Receiver ( receiver ) ; return ; } sleep ( POLL TIME ) ; } int fired Flags = receiver . get Fired Flags ( ) ; remove Receiver ( receiver ) ; fail ( String . format ( STRING + STRING , scan Mode , Bluetooth Adapter . SCAN MODE CONNECTABLE DISCOVERABLE , fired Flags , mask ) ) ; }
public final static boolean is Class File Name ( String name ) { int name Length = name == null ? NUM : name . length ( ) ; int suffix Length = SUFFIX CLASS . length ; if ( name Length < suffix Length ) return BOOL ; for ( int i = NUM ; i < suffix Length ; i ++ ) { char c = name . char At ( name Length - i - NUM ) ; int suffix Index = suffix Length - i - NUM ; if ( c != SUFFIX class [ suffix Index ] && c != SUFFIX CLASS [ suffix Index ] ) return BOOL ; } return BOOL ; }
public void on Back Pressed ( ) { if ( ! m Fragments . pop Back Stack Immediate ( ) ) { finish ( ) ; } }
public void on Back Pressed ( ) { if ( ! m Fragments . pop Back Stack Immediate ( ) ) { finish ( ) ; } }
public static Doc append ( Doc ... docs ) { return append ( Arrays . as List ( docs ) ) ; }
public void switch Item ( @ Nullable Recycler View recycler View , final int selected View Position ) { if ( is Deselect Animation In Process || is Select Animation In Process || is View Collapsing || is Waiting To Deselect Animation || is Waiting To Select Animation || is Selected Item Straightened ) { return ; } if ( recycler View != null ) { if ( this . selected Item Position != Recycler View . NO POSITION && this . selected Item Position != selected View Position ) { deselect Item ( recycler View , this . selected Item Position , selected View Position , NUM ) ; return ; } smooth Scroll To Position ( recycler View , null , selected View Position ) ; } }
public void component Hidden ( final Component Event e ) { final Object source = e . get Source ( ) ; if ( ! ( source instanceof J Menu Item ) ) return ; set Child Visible ( ( J Menu Item ) source , BOOL ) ; }
public void component Hidden ( final Component Event e ) { final Object source = e . get Source ( ) ; if ( ! ( source instanceof J Menu Item ) ) return ; set Child Visible ( ( J Menu Item ) source , BOOL ) ; }
private boolean is Project Using Default Sdk ( T project Sdk ) { if ( ! is Default Sdk ( project Sdk ) ) { return BOOL ; } try { I Classpath Entry entry = Classpath Utilities . find Classpath Entry Container ( java Project . get Raw Classpath ( ) , do Get Container Id ( ) ) ; if ( entry != null ) { if ( Sdk Classpath Container . is Default Container Path ( do Get Container Id ( ) , entry . get Path ( ) ) ) { return BOOL ; } } } catch ( Core Exception ce ) { Core Plugin Log . log Error ( ce ) ; } return BOOL ; }
private boolean is Project Using Default Sdk ( T project Sdk ) { if ( ! is Default Sdk ( project Sdk ) ) { return BOOL ; } try { I Classpath Entry entry = Classpath Utilities . find Classpath Entry Container ( java Project . get Raw Classpath ( ) , do Get Container Id ( ) ) ; if ( entry != null ) { if ( Sdk Classpath Container . is Default Container Path ( do Get Container Id ( ) , entry . get Path ( ) ) ) { return BOOL ; } } } catch ( Core Exception ce ) { Core Plugin Log . log Error ( ce ) ; } return BOOL ; }
private boolean is Project Using Default Sdk ( T project Sdk ) { if ( ! is Default Sdk ( project Sdk ) ) { return BOOL ; } try { I Classpath Entry entry = Classpath Utilities . find Classpath Entry Container ( java Project . get Raw Classpath ( ) , do Get Container Id ( ) ) ; if ( entry != null ) { if ( Sdk Classpath Container . is Default Container Path ( do Get Container Id ( ) , entry . get Path ( ) ) ) { return BOOL ; } } } catch ( Core Exception ce ) { Core Plugin Log . log Error ( ce ) ; } return BOOL ; }
private boolean is Project Using Default Sdk ( T project Sdk ) { if ( ! is Default Sdk ( project Sdk ) ) { return BOOL ; } try { I Classpath Entry entry = Classpath Utilities . find Classpath Entry Container ( java Project . get Raw Classpath ( ) , do Get Container Id ( ) ) ; if ( entry != null ) { if ( Sdk Classpath Container . is Default Container Path ( do Get Container Id ( ) , entry . get Path ( ) ) ) { return BOOL ; } } } catch ( Core Exception ce ) { Core Plugin Log . log Error ( ce ) ; } return BOOL ; }
private boolean is Project Using Default Sdk ( T project Sdk ) { if ( ! is Default Sdk ( project Sdk ) ) { return BOOL ; } try { I Classpath Entry entry = Classpath Utilities . find Classpath Entry Container ( java Project . get Raw Classpath ( ) , do Get Container Id ( ) ) ; if ( entry != null ) { if ( Sdk Classpath Container . is Default Container Path ( do Get Container Id ( ) , entry . get Path ( ) ) ) { return BOOL ; } } } catch ( Core Exception ce ) { Core Plugin Log . log Error ( ce ) ; } return BOOL ; }
public void add Cert Chain Listener ( Cert Chain Listener listener ) { cert Chain Listeners . add ( listener ) ; }
private static String Builder dump ( String Builder lbuffer , long value ) { for ( int j = NUM ; j < NUM ; j ++ ) { lbuffer . append ( CHARS [ ( int ) ( value > > SHIFTS [ j ] ) & NUM ] ) ; } return lbuffer ; }
protected Set < String > allowed Duplicate Error Codes ( ) { return Collections . empty Set ( ) ; }
protected Set < String > allowed Duplicate Error Codes ( ) { return Collections . empty Set ( ) ; }
protected Set < String > allowed Duplicate Error Codes ( ) { return Collections . empty Set ( ) ; }
protected Set < String > allowed Duplicate Error Codes ( ) { return Collections . empty Set ( ) ; }
protected Set < String > allowed Duplicate Error Codes ( ) { return Collections . empty Set ( ) ; }
public synchronized byte [ ] to Byte Array ( ) { int remaining = count ; if ( remaining == NUM ) { return EMPTY BYTE ARRAY ; } byte [ ] newbuf = new byte [ remaining ] ; int pos = NUM ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; System . arraycopy ( buf , NUM , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == NUM ) { break ; } } return newbuf ; }
void updated Text Field ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } Cv Value cv = cv Map . get ( get Cv Num ( ) ) ; int old Cv = cv . get Value ( ) ; int new Val ; try { new Val = text To Value ( value . get Text ( ) ) ; } catch ( java . lang . Number Format Exception ex ) { new Val = NUM ; } int new Cv = new Value ( old Cv , new Val , get Mask ( ) ) ; if ( old Cv != new Cv ) { cv . set Value ( new Cv ) ; } }
void updated Text Field ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } Cv Value cv = cv Map . get ( get Cv Num ( ) ) ; int old Cv = cv . get Value ( ) ; int new Val ; try { new Val = text To Value ( value . get Text ( ) ) ; } catch ( java . lang . Number Format Exception ex ) { new Val = NUM ; } int new Cv = new Value ( old Cv , new Val , get Mask ( ) ) ; if ( old Cv != new Cv ) { cv . set Value ( new Cv ) ; } }
void updated Text Field ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } Cv Value cv = cv Map . get ( get Cv Num ( ) ) ; int old Cv = cv . get Value ( ) ; int new Val ; try { new Val = text To Value ( value . get Text ( ) ) ; } catch ( java . lang . Number Format Exception ex ) { new Val = NUM ; } int new Cv = new Value ( old Cv , new Val , get Mask ( ) ) ; if ( old Cv != new Cv ) { cv . set Value ( new Cv ) ; } }
void updated Text Field ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } Cv Value cv = cv Map . get ( get Cv Num ( ) ) ; int old Cv = cv . get Value ( ) ; int new Val ; try { new Val = text To Value ( value . get Text ( ) ) ; } catch ( java . lang . Number Format Exception ex ) { new Val = NUM ; } int new Cv = new Value ( old Cv , new Val , get Mask ( ) ) ; if ( old Cv != new Cv ) { cv . set Value ( new Cv ) ; } }
void updated Text Field ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } Cv Value cv = cv Map . get ( get Cv Num ( ) ) ; int old Cv = cv . get Value ( ) ; int new Val ; try { new Val = text To Value ( value . get Text ( ) ) ; } catch ( java . lang . Number Format Exception ex ) { new Val = NUM ; } int new Cv = new Value ( old Cv , new Val , get Mask ( ) ) ; if ( old Cv != new Cv ) { cv . set Value ( new Cv ) ; } }
void updated Text Field ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } Cv Value cv = cv Map . get ( get Cv Num ( ) ) ; int old Cv = cv . get Value ( ) ; int new Val ; try { new Val = text To Value ( value . get Text ( ) ) ; } catch ( java . lang . Number Format Exception ex ) { new Val = NUM ; } int new Cv = new Value ( old Cv , new Val , get Mask ( ) ) ; if ( old Cv != new Cv ) { cv . set Value ( new Cv ) ; } }
void updated Text Field ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } Cv Value cv = cv Map . get ( get Cv Num ( ) ) ; int old Cv = cv . get Value ( ) ; int new Val ; try { new Val = text To Value ( value . get Text ( ) ) ; } catch ( java . lang . Number Format Exception ex ) { new Val = NUM ; } int new Cv = new Value ( old Cv , new Val , get Mask ( ) ) ; if ( old Cv != new Cv ) { cv . set Value ( new Cv ) ; } }
void updated Text Field ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } Cv Value cv = cv Map . get ( get Cv Num ( ) ) ; int old Cv = cv . get Value ( ) ; int new Val ; try { new Val = text To Value ( value . get Text ( ) ) ; } catch ( java . lang . Number Format Exception ex ) { new Val = NUM ; } int new Cv = new Value ( old Cv , new Val , get Mask ( ) ) ; if ( old Cv != new Cv ) { cv . set Value ( new Cv ) ; } }
void updated Text Field ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } Cv Value cv = cv Map . get ( get Cv Num ( ) ) ; int old Cv = cv . get Value ( ) ; int new Val ; try { new Val = text To Value ( value . get Text ( ) ) ; } catch ( java . lang . Number Format Exception ex ) { new Val = NUM ; } int new Cv = new Value ( old Cv , new Val , get Mask ( ) ) ; if ( old Cv != new Cv ) { cv . set Value ( new Cv ) ; } }
void updated Text Field ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } Cv Value cv = cv Map . get ( get Cv Num ( ) ) ; int old Cv = cv . get Value ( ) ; int new Val ; try { new Val = text To Value ( value . get Text ( ) ) ; } catch ( java . lang . Number Format Exception ex ) { new Val = NUM ; } int new Cv = new Value ( old Cv , new Val , get Mask ( ) ) ; if ( old Cv != new Cv ) { cv . set Value ( new Cv ) ; } }
void update Styles Listening To ( ) { synchronized ( listening Styles ) { Style Context styles = ( Style Context ) get Attribute Context ( ) ; if ( style Change Listener == null ) { style Change Listener = create Style Change Listener ( ) ; } if ( style Change Listener != null && styles != null ) { Enumeration style Names = styles . get Style Names ( ) ; Vector v = ( Vector ) listening Styles . clone ( ) ; listening Styles . remove All Elements ( ) ; List < Change Listener > stale Listeners = Abstract Change Handler . get Stale Listeners ( style Change Listener ) ; while ( style Names . has More Elements ( ) ) { String name = ( String ) style Names . next Element ( ) ; Style a Style = styles . get Style ( name ) ; int index = v . index Of ( a Style ) ; listening Styles . add Element ( a Style ) ; if ( index == - NUM ) { for ( Change Listener l : stale Listeners ) { a Style . remove Change Listener ( l ) ; } a Style . add Change Listener ( style Change Listener ) ; } else { v . remove Element At ( index ) ; } } for ( int counter = v . size ( ) - NUM ; counter >= NUM ; counter -- ) { Style a Style = ( Style ) v . element At ( counter ) ; a Style . remove Change Listener ( style Change Listener ) ; } if ( listening Styles . size ( ) == NUM ) { style Change Listener = null ; } } } }
protected Dimension compute Lengths ( String anno Text ) { String [ ] lines = Util . split Lines ( anno Text ) ; int line Length = NUM ; for ( String line : lines ) { if ( line . length ( ) > line Length ) line Length = line . length ( ) ; } return new Dimension ( line Length + NUM , lines . length + NUM ) ; }
public boolean uses Default Property Access ( ) { return m default Access . equals ( JPA ACCESS PROPERTY ) ; }
public V put ( final K k , final V v ) { final Weak Reference < V > ref = new Weak Ref ( k , v , reference Queue ) ; final Weak Reference < V > old Ref = map . put ( k , ref ) ; final V old Val = old Ref == null ? null : old Ref . get ( ) ; if ( queue . add ( v ) && DEBUG ) { log . debug ( STRING + k + STRING + v ) ; } did Update ( k , ref , old Ref ) ; return old Val ; }
private void parse ( ) { if ( lexer == null ) { tokens = null ; return ; } List < Token > toks = new Array List < Token > ( get Length ( ) / NUM ) ; long ts = System . nano Time ( ) ; int len = get Length ( ) ; try { Segment seg = new Segment ( ) ; get Text ( NUM , get Length ( ) , seg ) ; Char Array Reader reader = new Char Array Reader ( seg . array , seg . offset , seg . count ) ; lexer . yyreset ( reader ) ; Token token ; while ( ( token = lexer . yylex ( ) ) != null ) { toks . add ( token ) ; } } catch ( Bad Location Exception ex ) { log . log ( Level . SEVERE , null , ex ) ; } catch ( IO Exception ex ) { log . log ( Level . SEVERE , null , ex ) ; } finally { if ( log . is Loggable ( Level . FINEST ) ) { log . finest ( String . format ( STRING , len , ( System . nano Time ( ) - ts ) / NUM , toks . size ( ) ) ) ; } tokens = toks ; } }
private void parse ( ) { if ( lexer == null ) { tokens = null ; return ; } List < Token > toks = new Array List < Token > ( get Length ( ) / NUM ) ; long ts = System . nano Time ( ) ; int len = get Length ( ) ; try { Segment seg = new Segment ( ) ; get Text ( NUM , get Length ( ) , seg ) ; Char Array Reader reader = new Char Array Reader ( seg . array , seg . offset , seg . count ) ; lexer . yyreset ( reader ) ; Token token ; while ( ( token = lexer . yylex ( ) ) != null ) { toks . add ( token ) ; } } catch ( Bad Location Exception ex ) { log . log ( Level . SEVERE , null , ex ) ; } catch ( IO Exception ex ) { log . log ( Level . SEVERE , null , ex ) ; } finally { if ( log . is Loggable ( Level . FINEST ) ) { log . finest ( String . format ( STRING , len , ( System . nano Time ( ) - ts ) / NUM , toks . size ( ) ) ) ; } tokens = toks ; } }
private void parse ( ) { if ( lexer == null ) { tokens = null ; return ; } List < Token > toks = new Array List < Token > ( get Length ( ) / NUM ) ; long ts = System . nano Time ( ) ; int len = get Length ( ) ; try { Segment seg = new Segment ( ) ; get Text ( NUM , get Length ( ) , seg ) ; Char Array Reader reader = new Char Array Reader ( seg . array , seg . offset , seg . count ) ; lexer . yyreset ( reader ) ; Token token ; while ( ( token = lexer . yylex ( ) ) != null ) { toks . add ( token ) ; } } catch ( Bad Location Exception ex ) { log . log ( Level . SEVERE , null , ex ) ; } catch ( IO Exception ex ) { log . log ( Level . SEVERE , null , ex ) ; } finally { if ( log . is Loggable ( Level . FINEST ) ) { log . finest ( String . format ( STRING , len , ( System . nano Time ( ) - ts ) / NUM , toks . size ( ) ) ) ; } tokens = toks ; } }
private void parse ( ) { if ( lexer == null ) { tokens = null ; return ; } List < Token > toks = new Array List < Token > ( get Length ( ) / NUM ) ; long ts = System . nano Time ( ) ; int len = get Length ( ) ; try { Segment seg = new Segment ( ) ; get Text ( NUM , get Length ( ) , seg ) ; Char Array Reader reader = new Char Array Reader ( seg . array , seg . offset , seg . count ) ; lexer . yyreset ( reader ) ; Token token ; while ( ( token = lexer . yylex ( ) ) != null ) { toks . add ( token ) ; } } catch ( Bad Location Exception ex ) { log . log ( Level . SEVERE , null , ex ) ; } catch ( IO Exception ex ) { log . log ( Level . SEVERE , null , ex ) ; } finally { if ( log . is Loggable ( Level . FINEST ) ) { log . finest ( String . format ( STRING , len , ( System . nano Time ( ) - ts ) / NUM , toks . size ( ) ) ) ; } tokens = toks ; } }
private void parse ( ) { if ( lexer == null ) { tokens = null ; return ; } List < Token > toks = new Array List < Token > ( get Length ( ) / NUM ) ; long ts = System . nano Time ( ) ; int len = get Length ( ) ; try { Segment seg = new Segment ( ) ; get Text ( NUM , get Length ( ) , seg ) ; Char Array Reader reader = new Char Array Reader ( seg . array , seg . offset , seg . count ) ; lexer . yyreset ( reader ) ; Token token ; while ( ( token = lexer . yylex ( ) ) != null ) { toks . add ( token ) ; } } catch ( Bad Location Exception ex ) { log . log ( Level . SEVERE , null , ex ) ; } catch ( IO Exception ex ) { log . log ( Level . SEVERE , null , ex ) ; } finally { if ( log . is Loggable ( Level . FINEST ) ) { log . finest ( String . format ( STRING , len , ( System . nano Time ( ) - ts ) / NUM , toks . size ( ) ) ) ; } tokens = toks ; } }
private void add Implied Version ( Version v ) { if ( ! implied Versions . contains ( v ) ) { implied Versions . add ( v ) ; for ( Version implied Version : v . get Implied Versions ( ) ) { add Implied Version ( implied Version ) ; } } }
private void add Name Dates Panel ( final String headline , final I Field Description < String > name , final I Field Description < Date > creation Date , final I Field Description < Date > modification Date ) { final J Panel name Dates Panel = new J Panel ( new Grid Layout ( NUM , NUM , NUM , NUM ) ) ; name Dates Panel . set Border ( new Titled Border ( headline ) ) ; name Dates Panel . add ( new C Labeled Component ( STRING + STRING , name . get Help ( ) , m name Text Field ) ) ; name Dates Panel . add ( new C Labeled Component ( STRING + STRING , creation Date . get Help ( ) , m creation Date Value Label ) ) ; name Dates Panel . add ( new C Labeled Component ( STRING + STRING , modification Date . get Help ( ) , m modification Date Value Label ) ) ; add ( name Dates Panel , Border Layout . NORTH ) ; }
private void add Name Dates Panel ( final String headline , final I Field Description < String > name , final I Field Description < Date > creation Date , final I Field Description < Date > modification Date ) { final J Panel name Dates Panel = new J Panel ( new Grid Layout ( NUM , NUM , NUM , NUM ) ) ; name Dates Panel . set Border ( new Titled Border ( headline ) ) ; name Dates Panel . add ( new C Labeled Component ( STRING + STRING , name . get Help ( ) , m name Text Field ) ) ; name Dates Panel . add ( new C Labeled Component ( STRING + STRING , creation Date . get Help ( ) , m creation Date Value Label ) ) ; name Dates Panel . add ( new C Labeled Component ( STRING + STRING , modification Date . get Help ( ) , m modification Date Value Label ) ) ; add ( name Dates Panel , Border Layout . NORTH ) ; }
private void add Name Dates Panel ( final String headline , final I Field Description < String > name , final I Field Description < Date > creation Date , final I Field Description < Date > modification Date ) { final J Panel name Dates Panel = new J Panel ( new Grid Layout ( NUM , NUM , NUM , NUM ) ) ; name Dates Panel . set Border ( new Titled Border ( headline ) ) ; name Dates Panel . add ( new C Labeled Component ( STRING + STRING , name . get Help ( ) , m name Text Field ) ) ; name Dates Panel . add ( new C Labeled Component ( STRING + STRING , creation Date . get Help ( ) , m creation Date Value Label ) ) ; name Dates Panel . add ( new C Labeled Component ( STRING + STRING , modification Date . get Help ( ) , m modification Date Value Label ) ) ; add ( name Dates Panel , Border Layout . NORTH ) ; }
public static File create Tmp File ( String path To File ) throws IO Exception { File file = new File ( path To File ) ; if ( file . exists ( ) ) { file . delete ( ) ; } if ( ! file . create New File ( ) ) { LOGGER . warn ( STRING + file . get Absolute Path ( ) + STRING ) ; } return file ; }
public static File create Tmp File ( String path To File ) throws IO Exception { File file = new File ( path To File ) ; if ( file . exists ( ) ) { file . delete ( ) ; } if ( ! file . create New File ( ) ) { LOGGER . warn ( STRING + file . get Absolute Path ( ) + STRING ) ; } return file ; }
public static void copy Stream ( Input Stream input Stream , Output Stream output Stream ) { if ( input Stream != null && output Stream != null ) { try { int length = - NUM ; byte [ ] buffer = new byte [ Constant . Capacity . BYTES PER MB ] ; while ( ( length = input Stream . read ( buffer , NUM , buffer . length ) ) != - NUM ) { output Stream . write ( buffer , NUM , length ) ; output Stream . flush ( ) ; } } catch ( Exception e ) { throw new File Util Exception ( e ) ; } } }
public synchronized void remove ( String k ) { if ( k == null ) { for ( int i = NUM ; i < nkeys ; i ++ ) { while ( keys [ i ] == null && i < nkeys ) { for ( int j = i ; j < nkeys - NUM ; j ++ ) { keys [ j ] = keys [ j + NUM ] ; values [ j ] = values [ j + NUM ] ; } nkeys -- ; } } } else { for ( int i = NUM ; i < nkeys ; i ++ ) { while ( k . equals Ignore Case ( keys [ i ] ) && i < nkeys ) { for ( int j = i ; j < nkeys - NUM ; j ++ ) { keys [ j ] = keys [ j + NUM ] ; values [ j ] = values [ j + NUM ] ; } nkeys -- ; } } } }
public synchronized void remove ( String k ) { if ( k == null ) { for ( int i = NUM ; i < nkeys ; i ++ ) { while ( keys [ i ] == null && i < nkeys ) { for ( int j = i ; j < nkeys - NUM ; j ++ ) { keys [ j ] = keys [ j + NUM ] ; values [ j ] = values [ j + NUM ] ; } nkeys -- ; } } } else { for ( int i = NUM ; i < nkeys ; i ++ ) { while ( k . equals Ignore Case ( keys [ i ] ) && i < nkeys ) { for ( int j = i ; j < nkeys - NUM ; j ++ ) { keys [ j ] = keys [ j + NUM ] ; values [ j ] = values [ j + NUM ] ; } nkeys -- ; } } } }
public static Thread consume Process Error Stream ( Process self , Appendable error ) { Thread thread = new Thread ( new Text Dumper ( self . get Error Stream ( ) , error ) ) ; thread . start ( ) ; return thread ; }
public static Thread consume Process Error Stream ( Process self , Appendable error ) { Thread thread = new Thread ( new Text Dumper ( self . get Error Stream ( ) , error ) ) ; thread . start ( ) ; return thread ; }
public static Thread consume Process Error Stream ( Process self , Appendable error ) { Thread thread = new Thread ( new Text Dumper ( self . get Error Stream ( ) , error ) ) ; thread . start ( ) ; return thread ; }
public static Thread consume Process Error Stream ( Process self , Appendable error ) { Thread thread = new Thread ( new Text Dumper ( self . get Error Stream ( ) , error ) ) ; thread . start ( ) ; return thread ; }
public static Thread consume Process Error Stream ( Process self , Appendable error ) { Thread thread = new Thread ( new Text Dumper ( self . get Error Stream ( ) , error ) ) ; thread . start ( ) ; return thread ; }
public Extension Query ( String plugin Id , String extension Point Name , String attribute Name ) { this . plugin Id = extension Point Name . contains ( STRING ) ? null : plugin Id ; this . extension Point Name = extension Point Name ; this . attribute Name = attribute Name ; }
private static void add Digest ( Message Digest digest , int v ) { digest . update ( ( byte ) ( v > > NUM ) ) ; digest . update ( ( byte ) ( v > > NUM ) ) ; digest . update ( ( byte ) ( v > > NUM ) ) ; digest . update ( ( byte ) v ) ; }
public static byte [ ] convert JWS Concatenated To DER Encoded Signature ( final byte [ ] concatenated Signature Value ) throws IO Exception { final byte [ ] r = new byte [ NUM ] ; final byte [ ] s = new byte [ NUM ] ; System . arraycopy ( concatenated Signature Value , NUM , r , NUM , NUM ) ; System . arraycopy ( concatenated Signature Value , NUM , s , NUM , NUM ) ; final Big Integer r Big Integer = new Big Integer ( r ) ; final Big Integer s Big Integer = new Big Integer ( s ) ; final Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; final DER Sequence Generator seq Gen = new DER Sequence Generator ( bos ) ; seq Gen . add Object ( new ASN 1 Integer ( r Big Integer . to Byte Array ( ) ) ) ; seq Gen . add Object ( new ASN 1 Integer ( s Big Integer . to Byte Array ( ) ) ) ; seq Gen . close ( ) ; bos . close ( ) ; final byte [ ] der Encoded Signature Value = bos . to Byte Array ( ) ; return der Encoded Signature Value ; }
public static byte [ ] convert JWS Concatenated To DER Encoded Signature ( final byte [ ] concatenated Signature Value ) throws IO Exception { final byte [ ] r = new byte [ NUM ] ; final byte [ ] s = new byte [ NUM ] ; System . arraycopy ( concatenated Signature Value , NUM , r , NUM , NUM ) ; System . arraycopy ( concatenated Signature Value , NUM , s , NUM , NUM ) ; final Big Integer r Big Integer = new Big Integer ( r ) ; final Big Integer s Big Integer = new Big Integer ( s ) ; final Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; final DER Sequence Generator seq Gen = new DER Sequence Generator ( bos ) ; seq Gen . add Object ( new ASN 1 Integer ( r Big Integer . to Byte Array ( ) ) ) ; seq Gen . add Object ( new ASN 1 Integer ( s Big Integer . to Byte Array ( ) ) ) ; seq Gen . close ( ) ; bos . close ( ) ; final byte [ ] der Encoded Signature Value = bos . to Byte Array ( ) ; return der Encoded Signature Value ; }
public Term ( String fld , Bytes Ref bytes ) { field = fld ; this . bytes = bytes == null ? null : Bytes Ref . deep Copy Of ( bytes ) ; }
public Term ( String fld , Bytes Ref bytes ) { field = fld ; this . bytes = bytes == null ? null : Bytes Ref . deep Copy Of ( bytes ) ; }
public Term ( String fld , Bytes Ref bytes ) { field = fld ; this . bytes = bytes == null ? null : Bytes Ref . deep Copy Of ( bytes ) ; }
public Term ( String fld , Bytes Ref bytes ) { field = fld ; this . bytes = bytes == null ? null : Bytes Ref . deep Copy Of ( bytes ) ; }
public Private Key Usage Extension ( Boolean critical , Object value ) throws Certificate Exception , IO Exception { this . extension Id = PKIX Extensions . Private Key Usage Id ; this . critical = critical . boolean Value ( ) ; this . extension Value = ( byte [ ] ) value ; Der Input Stream str = new Der Input Stream ( this . extension Value ) ; Der Value [ ] seq = str . get Sequence ( NUM ) ; for ( int i = NUM ; i < seq . length ; i ++ ) { Der Value opt = seq [ i ] ; if ( opt . is Context Specific ( TAG BEFORE ) && ! opt . is Constructed ( ) ) { if ( not Before != null ) { throw new Certificate Parsing Exception ( STRING ) ; } opt . reset Tag ( Der Value . tag Generalized Time ) ; str = new Der Input Stream ( opt . to Byte Array ( ) ) ; not Before = str . get Generalized Time ( ) ; } else if ( opt . is Context Specific ( TAG AFTER ) && ! opt . is Constructed ( ) ) { if ( not After != null ) { throw new Certificate Parsing Exception ( STRING ) ; } opt . reset Tag ( Der Value . tag Generalized Time ) ; str = new Der Input Stream ( opt . to Byte Array ( ) ) ; not After = str . get Generalized Time ( ) ; } else throw new IO Exception ( STRING + STRING ) ; } }
private void add Method ( Mapped Class clazz , String [ ] parts ) { String original = STRING ; String new Name = STRING ; String desc = STRING ; if ( parts . length == NUM ) { original = parts [ NUM ] ; new Name = parts [ NUM ] ; desc = parts [ NUM ] ; } else if ( parts . length == NUM ) { original = parts [ NUM ] ; new Name = parts [ NUM ] ; desc = parts [ NUM ] ; } else { return ; } if ( desc . contains ( STRING ) ) { desc = desc . replace ( STRING , STRING ) ; } Mapped Member mm = new Mapped Member ( clazz , find Method ( clazz . get Node ( ) , original , desc ) , - NUM , desc , original ) ; mm . set New Name ( new Name ) ; clazz . add Method ( mm ) ; }
public Abstract Tree Printer remove Last Indent ( ) { remove Last Chars ( indent * INDENT . length ( ) ) ; return this ; }
@ Override public void on View Position Changed ( View changed View , int left , int top , int dx , int dy ) { super . on View Position Changed ( changed View , left , top , dx , dy ) ; m Drag Offset = Math . abs ( top ) ; float fraction Screen = ( float ) m Drag Offset / m Config View . get Vertical Drag Range ( ) ; m Config View . on View Position Changed ( fraction Screen >= NUM ? NUM : fraction Screen ) ; }
@ Override public void on View Position Changed ( View changed View , int left , int top , int dx , int dy ) { super . on View Position Changed ( changed View , left , top , dx , dy ) ; m Drag Offset = Math . abs ( top ) ; float fraction Screen = ( float ) m Drag Offset / m Config View . get Vertical Drag Range ( ) ; m Config View . on View Position Changed ( fraction Screen >= NUM ? NUM : fraction Screen ) ; }
public Summary Panel ( final Neuron Group ng , boolean editable ) { set Group ( ng ) ; this . editable = editable ; incoming Group Label . set Text ( STRING ) ; outgoing Group Label . set Text ( STRING ) ; fill Field Values ( ) ; initialize Layout ( ) ; }
public Int Column ( int nrows , int capacity , int default Value ) { super ( int . class , new Integer ( default Value ) ) ; if ( capacity < nrows ) { throw new Illegal Argument Exception ( STRING ) ; } m values = new int [ capacity ] ; Arrays . fill ( m values , default Value ) ; m size = nrows ; }
public boolean equals ( Initiative Roll other ) { if ( size ( ) != other . size ( ) ) { return BOOL ; } for ( int i = NUM ; i < size ( ) ; i ++ ) { if ( get Roll ( i ) != other . get Roll ( i ) ) { return BOOL ; } } return BOOL ; }
public static Integer to Ref ( int i ) { return Integer . value Of ( i ) ; }
public void modify Variable Id ( String old Node Id , String new Node Id ) { B Node node = nodes . remove ( old Node Id ) ; chance Nodes . remove ( old Node Id ) ; utility Nodes . remove ( old Node Id ) ; action Nodes . remove ( old Node Id ) ; if ( node != null ) { add Node ( node ) ; } else { log . warning ( STRING + old Node Id + STRING ) ; } }
public void modify Variable Id ( String old Node Id , String new Node Id ) { B Node node = nodes . remove ( old Node Id ) ; chance Nodes . remove ( old Node Id ) ; utility Nodes . remove ( old Node Id ) ; action Nodes . remove ( old Node Id ) ; if ( node != null ) { add Node ( node ) ; } else { log . warning ( STRING + old Node Id + STRING ) ; } }
protected void append ( int value ) { m Message . write ( value ) ; m Position ++ ; }
@ Bean public Client Details Service client Details Service ( ) throws Exception { return combined Service ; }
protected org . codehaus . cargo . container . deployable . Deployable create Auto Deploy Deployable ( org . codehaus . cargo . container . Container container ) throws Mojo Execution Exception { Deployable deployable Element = new Deployable ( ) ; return deployable Element . create Deployable ( container . get Id ( ) , get Cargo Project ( ) ) ; }
public static int next Message ID ( ) { int next ID = next Message ID . get And Increment ( ) ; if ( next ID == Integer . MAX VALUE ) { next Message ID . set ( NUM ) ; } return next ID ; }
public I Blocking Buffer < E > new Instance ( ) { lock . lock ( ) ; try { if ( ! is Open ( ) ) throw new Buffer Closed Exception ( ) ; final I Blocking Buffer < E > n = new Inner Blocking Buffer ( ) ; if ( ! set . add ( n ) ) throw new Assertion Error ( ) ; counter ++ ; return n ; } finally { lock . unlock ( ) ; } }
public I Blocking Buffer < E > new Instance ( ) { lock . lock ( ) ; try { if ( ! is Open ( ) ) throw new Buffer Closed Exception ( ) ; final I Blocking Buffer < E > n = new Inner Blocking Buffer ( ) ; if ( ! set . add ( n ) ) throw new Assertion Error ( ) ; counter ++ ; return n ; } finally { lock . unlock ( ) ; } }
protected String meta Option ( ) { return STRING + STRING ; }
protected boolean contains URL ( URL url ) { if ( urls != null ) { for ( URL test URL : urls ) { if ( url . equals ( test URL ) ) return BOOL ; } } Class Loader parent = get Parent ( ) ; if ( parent instanceof Dynamic Class Loader ) { Dynamic Class Loader dyn Parent = ( Dynamic Class Loader ) parent ; if ( dyn Parent . contains URL ( url ) ) { return BOOL ; } } for ( Dynamic Class Loader loader Import : import Loaders ) { if ( loader Import . contains URL ( url ) ) { return BOOL ; } } return BOOL ; }
protected boolean contains URL ( URL url ) { if ( urls != null ) { for ( URL test URL : urls ) { if ( url . equals ( test URL ) ) return BOOL ; } } Class Loader parent = get Parent ( ) ; if ( parent instanceof Dynamic Class Loader ) { Dynamic Class Loader dyn Parent = ( Dynamic Class Loader ) parent ; if ( dyn Parent . contains URL ( url ) ) { return BOOL ; } } for ( Dynamic Class Loader loader Import : import Loaders ) { if ( loader Import . contains URL ( url ) ) { return BOOL ; } } return BOOL ; }
private void build Subgraphs ( List subgraph List , Polygon Builder poly Builder ) { List processed Graphs = new Array List ( ) ; for ( Iterator i = subgraph List . iterator ( ) ; i . has Next ( ) ; ) { Buffer Subgraph subgraph = ( Buffer Subgraph ) i . next ( ) ; Coordinate p = subgraph . get Rightmost Coordinate ( ) ; Subgraph Depth Locater locater = new Subgraph Depth Locater ( processed Graphs ) ; int outside Depth = locater . get Depth ( p ) ; subgraph . compute Depth ( outside Depth ) ; subgraph . find Result Edges ( ) ; processed Graphs . add ( subgraph ) ; poly Builder . add ( subgraph . get Directed Edges ( ) , subgraph . get Nodes ( ) ) ; } }
private void build Subgraphs ( List subgraph List , Polygon Builder poly Builder ) { List processed Graphs = new Array List ( ) ; for ( Iterator i = subgraph List . iterator ( ) ; i . has Next ( ) ; ) { Buffer Subgraph subgraph = ( Buffer Subgraph ) i . next ( ) ; Coordinate p = subgraph . get Rightmost Coordinate ( ) ; Subgraph Depth Locater locater = new Subgraph Depth Locater ( processed Graphs ) ; int outside Depth = locater . get Depth ( p ) ; subgraph . compute Depth ( outside Depth ) ; subgraph . find Result Edges ( ) ; processed Graphs . add ( subgraph ) ; poly Builder . add ( subgraph . get Directed Edges ( ) , subgraph . get Nodes ( ) ) ; } }
private void build Subgraphs ( List subgraph List , Polygon Builder poly Builder ) { List processed Graphs = new Array List ( ) ; for ( Iterator i = subgraph List . iterator ( ) ; i . has Next ( ) ; ) { Buffer Subgraph subgraph = ( Buffer Subgraph ) i . next ( ) ; Coordinate p = subgraph . get Rightmost Coordinate ( ) ; Subgraph Depth Locater locater = new Subgraph Depth Locater ( processed Graphs ) ; int outside Depth = locater . get Depth ( p ) ; subgraph . compute Depth ( outside Depth ) ; subgraph . find Result Edges ( ) ; processed Graphs . add ( subgraph ) ; poly Builder . add ( subgraph . get Directed Edges ( ) , subgraph . get Nodes ( ) ) ; } }
public static boolean clear Dir ( File dir ) { if ( ! dir . is Directory ( ) ) return BOOL ; File [ ] files = dir . list Files ( ) ; if ( files == null || files . length == NUM ) return BOOL ; boolean cleared = BOOL ; for ( File sub : files ) { cleared &= delete ( sub ) ; } return cleared ; }
public static boolean clear Dir ( File dir ) { if ( ! dir . is Directory ( ) ) return BOOL ; File [ ] files = dir . list Files ( ) ; if ( files == null || files . length == NUM ) return BOOL ; boolean cleared = BOOL ; for ( File sub : files ) { cleared &= delete ( sub ) ; } return cleared ; }
@ Suppress Warnings ( STRING ) public static < T , P extends Predicate < T > > P find ( Predicate < T > p , Class < P > clazz ) { if ( clazz . is Assignable From ( p . get Class ( ) ) ) { return ( P ) p ; } for ( Predicate < T > c : p . get Children ( ) ) { P r = find ( c , clazz ) ; if ( r != null ) { return r ; } } return null ; }
private void toggle Underlay Image ( ) { if ( enable Bg Image . is Selected ( ) ) { String img File = null ; int [ ] offsets ; double scale , rotate ; Buffered Image image ; try { Settings settings = new Settings ( UNDERLAY NS ) ; img File = settings . get Setting ( STRING ) ; offsets = settings . get Csv Ints ( STRING , NUM ) ; scale = settings . get Double ( STRING ) ; rotate = settings . get Double ( STRING ) ; image = Image IO . read ( new File ( img File ) ) ; } catch ( IO Exception ex ) { warn ( STRING + img File + STRING + ex . get Message ( ) ) ; enable Bg Image . set Selected ( BOOL ) ; return ; } catch ( Settings Error er ) { warn ( STRING + er . get Message ( ) ) ; return ; } field . set Underlay Image ( image , offsets [ NUM ] , offsets [ NUM ] , scale , rotate ) ; } else { field . set Underlay Image ( null , NUM , NUM , NUM , NUM ) ; } }
private void toggle Underlay Image ( ) { if ( enable Bg Image . is Selected ( ) ) { String img File = null ; int [ ] offsets ; double scale , rotate ; Buffered Image image ; try { Settings settings = new Settings ( UNDERLAY NS ) ; img File = settings . get Setting ( STRING ) ; offsets = settings . get Csv Ints ( STRING , NUM ) ; scale = settings . get Double ( STRING ) ; rotate = settings . get Double ( STRING ) ; image = Image IO . read ( new File ( img File ) ) ; } catch ( IO Exception ex ) { warn ( STRING + img File + STRING + ex . get Message ( ) ) ; enable Bg Image . set Selected ( BOOL ) ; return ; } catch ( Settings Error er ) { warn ( STRING + er . get Message ( ) ) ; return ; } field . set Underlay Image ( image , offsets [ NUM ] , offsets [ NUM ] , scale , rotate ) ; } else { field . set Underlay Image ( null , NUM , NUM , NUM , NUM ) ; } }
private void toggle Underlay Image ( ) { if ( enable Bg Image . is Selected ( ) ) { String img File = null ; int [ ] offsets ; double scale , rotate ; Buffered Image image ; try { Settings settings = new Settings ( UNDERLAY NS ) ; img File = settings . get Setting ( STRING ) ; offsets = settings . get Csv Ints ( STRING , NUM ) ; scale = settings . get Double ( STRING ) ; rotate = settings . get Double ( STRING ) ; image = Image IO . read ( new File ( img File ) ) ; } catch ( IO Exception ex ) { warn ( STRING + img File + STRING + ex . get Message ( ) ) ; enable Bg Image . set Selected ( BOOL ) ; return ; } catch ( Settings Error er ) { warn ( STRING + er . get Message ( ) ) ; return ; } field . set Underlay Image ( image , offsets [ NUM ] , offsets [ NUM ] , scale , rotate ) ; } else { field . set Underlay Image ( null , NUM , NUM , NUM , NUM ) ; } }
private void toggle Underlay Image ( ) { if ( enable Bg Image . is Selected ( ) ) { String img File = null ; int [ ] offsets ; double scale , rotate ; Buffered Image image ; try { Settings settings = new Settings ( UNDERLAY NS ) ; img File = settings . get Setting ( STRING ) ; offsets = settings . get Csv Ints ( STRING , NUM ) ; scale = settings . get Double ( STRING ) ; rotate = settings . get Double ( STRING ) ; image = Image IO . read ( new File ( img File ) ) ; } catch ( IO Exception ex ) { warn ( STRING + img File + STRING + ex . get Message ( ) ) ; enable Bg Image . set Selected ( BOOL ) ; return ; } catch ( Settings Error er ) { warn ( STRING + er . get Message ( ) ) ; return ; } field . set Underlay Image ( image , offsets [ NUM ] , offsets [ NUM ] , scale , rotate ) ; } else { field . set Underlay Image ( null , NUM , NUM , NUM , NUM ) ; } }
public boolean inserts Are Detected ( int type ) throws SQL Exception { return BOOL ; }
protected void add Module ( Map < Class < ? extends I Floodlight Service > , I Floodlight Module > module Map , Collection < I Floodlight Module > module Set , I Floodlight Module module ) { if ( ! module Set . contains ( module ) ) { Collection < Class < ? extends I Floodlight Service > > servs = module Service Map . get ( module ) ; if ( servs != null ) { for ( Class < ? extends I Floodlight Service > c : servs ) module Map . put ( c , module ) ; } module Set . add ( module ) ; } }
protected void add Module ( Map < Class < ? extends I Floodlight Service > , I Floodlight Module > module Map , Collection < I Floodlight Module > module Set , I Floodlight Module module ) { if ( ! module Set . contains ( module ) ) { Collection < Class < ? extends I Floodlight Service > > servs = module Service Map . get ( module ) ; if ( servs != null ) { for ( Class < ? extends I Floodlight Service > c : servs ) module Map . put ( c , module ) ; } module Set . add ( module ) ; } }
protected void render Menu Full ( Appendable writer , Map < String , Object > context , Model Menu menu , String Buffer sb ) throws IO Exception { try { execute Macro ( writer , sb . to String ( ) ) ; } catch ( Template Exception e ) { throw new IO Exception ( e ) ; } }
protected void render Menu Full ( Appendable writer , Map < String , Object > context , Model Menu menu , String Buffer sb ) throws IO Exception { try { execute Macro ( writer , sb . to String ( ) ) ; } catch ( Template Exception e ) { throw new IO Exception ( e ) ; } }
protected void render Menu Full ( Appendable writer , Map < String , Object > context , Model Menu menu , String Buffer sb ) throws IO Exception { try { execute Macro ( writer , sb . to String ( ) ) ; } catch ( Template Exception e ) { throw new IO Exception ( e ) ; } }
private void parse Unit ( Element unit Node , Vector < Entity > list ) { Node List nl = unit Node . get Child Nodes ( ) ; for ( int i = NUM ; i < nl . get Length ( ) ; i ++ ) { Node curr Node = nl . item ( i ) ; if ( curr Node . get Parent Node ( ) != unit Node ) { continue ; } int node Type = curr Node . get Node Type ( ) ; if ( node Type == Node . ELEMENT NODE ) { String node Name = curr Node . get Node Name ( ) ; if ( node Name . equals Ignore Case ( ENTITY ) ) { parse Entity ( ( Element ) curr Node , list ) ; } else if ( node Name . equals Ignore Case ( PILOT ) ) { parse Pilot ( ( Element ) curr Node ) ; } } else { continue ; } } }
protected int indexed Term Prefix Length ( final Bytes Ref prior Term , final Bytes Ref indexed Term ) { final int idx Term Offset = indexed Term . offset ; final int prior Term Offset = prior Term . offset ; final int limit = Math . min ( prior Term . length , indexed Term . length ) ; for ( int byte Idx = NUM ; byte Idx < limit ; byte Idx ++ ) { if ( prior Term . bytes [ prior Term Offset + byte Idx ] != indexed Term . bytes [ idx Term Offset + byte Idx ] ) { return byte Idx + NUM ; } } return Math . min ( NUM + prior Term . length , indexed Term . length ) ; }
protected int indexed Term Prefix Length ( final Bytes Ref prior Term , final Bytes Ref indexed Term ) { final int idx Term Offset = indexed Term . offset ; final int prior Term Offset = prior Term . offset ; final int limit = Math . min ( prior Term . length , indexed Term . length ) ; for ( int byte Idx = NUM ; byte Idx < limit ; byte Idx ++ ) { if ( prior Term . bytes [ prior Term Offset + byte Idx ] != indexed Term . bytes [ idx Term Offset + byte Idx ] ) { return byte Idx + NUM ; } } return Math . min ( NUM + prior Term . length , indexed Term . length ) ; }
protected int indexed Term Prefix Length ( final Bytes Ref prior Term , final Bytes Ref indexed Term ) { final int idx Term Offset = indexed Term . offset ; final int prior Term Offset = prior Term . offset ; final int limit = Math . min ( prior Term . length , indexed Term . length ) ; for ( int byte Idx = NUM ; byte Idx < limit ; byte Idx ++ ) { if ( prior Term . bytes [ prior Term Offset + byte Idx ] != indexed Term . bytes [ idx Term Offset + byte Idx ] ) { return byte Idx + NUM ; } } return Math . min ( NUM + prior Term . length , indexed Term . length ) ; }
protected int indexed Term Prefix Length ( final Bytes Ref prior Term , final Bytes Ref indexed Term ) { final int idx Term Offset = indexed Term . offset ; final int prior Term Offset = prior Term . offset ; final int limit = Math . min ( prior Term . length , indexed Term . length ) ; for ( int byte Idx = NUM ; byte Idx < limit ; byte Idx ++ ) { if ( prior Term . bytes [ prior Term Offset + byte Idx ] != indexed Term . bytes [ idx Term Offset + byte Idx ] ) { return byte Idx + NUM ; } } return Math . min ( NUM + prior Term . length , indexed Term . length ) ; }
protected int indexed Term Prefix Length ( final Bytes Ref prior Term , final Bytes Ref indexed Term ) { final int idx Term Offset = indexed Term . offset ; final int prior Term Offset = prior Term . offset ; final int limit = Math . min ( prior Term . length , indexed Term . length ) ; for ( int byte Idx = NUM ; byte Idx < limit ; byte Idx ++ ) { if ( prior Term . bytes [ prior Term Offset + byte Idx ] != indexed Term . bytes [ idx Term Offset + byte Idx ] ) { return byte Idx + NUM ; } } return Math . min ( NUM + prior Term . length , indexed Term . length ) ; }
@ Override public void run ( ) { try { audio Line . open ( ) ; audio Line . start ( ) ; audio Line . flush ( ) ; Audio Format format = audio Line . get Format ( ) ; byte [ ] buffer = new byte [ NUM ] ; while ( audio Line . is Open ( ) ) { boolean system Turn Before Read = output Speech != null ; int num Bytes Read = audio Line . read ( buffer , NUM , buffer . length ) ; if ( system Turn Before Read && output Speech == null ) { audio Line . drain ( ) ; continue ; } else if ( output Speech != null || num Bytes Read == NUM || ( ! voice Activity Detection && input Speech == null ) ) { if ( speech Panel != null ) { speech Panel . clear Volume ( ) ; } continue ; } double rms = Audio Utils . get RMS ( buffer , format ) ; current Volume = ( current Volume + rms ) / NUM ; if ( rms < background Volume ) { background Volume = rms ; } else { background Volume += ( rms - background Volume ) * NUM ; } if ( speech Panel != null ) { speech Panel . update Volume ( ( int ) current Volume ) ; } double difference = current Volume - background Volume ; if ( voice Activity Detection && input Speech == null && difference > VOLUME THRESHOLD ) { start Recording ( ) ; } if ( input Speech != null && ! input Speech . is Final ( ) ) { input Speech . write ( buffer ) ; if ( voice Activity Detection && difference < VOLUME THRESHOLD / NUM ) { stop Recording ( ) ; } } } } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
@ Override public void run ( ) { try { audio Line . open ( ) ; audio Line . start ( ) ; audio Line . flush ( ) ; Audio Format format = audio Line . get Format ( ) ; byte [ ] buffer = new byte [ NUM ] ; while ( audio Line . is Open ( ) ) { boolean system Turn Before Read = output Speech != null ; int num Bytes Read = audio Line . read ( buffer , NUM , buffer . length ) ; if ( system Turn Before Read && output Speech == null ) { audio Line . drain ( ) ; continue ; } else if ( output Speech != null || num Bytes Read == NUM || ( ! voice Activity Detection && input Speech == null ) ) { if ( speech Panel != null ) { speech Panel . clear Volume ( ) ; } continue ; } double rms = Audio Utils . get RMS ( buffer , format ) ; current Volume = ( current Volume + rms ) / NUM ; if ( rms < background Volume ) { background Volume = rms ; } else { background Volume += ( rms - background Volume ) * NUM ; } if ( speech Panel != null ) { speech Panel . update Volume ( ( int ) current Volume ) ; } double difference = current Volume - background Volume ; if ( voice Activity Detection && input Speech == null && difference > VOLUME THRESHOLD ) { start Recording ( ) ; } if ( input Speech != null && ! input Speech . is Final ( ) ) { input Speech . write ( buffer ) ; if ( voice Activity Detection && difference < VOLUME THRESHOLD / NUM ) { stop Recording ( ) ; } } } } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
@ Override public void write JSON String ( Writer out ) throws IO Exception { write JSON String ( this , out ) ; }
@ Override public void write JSON String ( Writer out ) throws IO Exception { write JSON String ( this , out ) ; }
static public Resource State replicator State To Resource State ( String state ) { if ( state . starts With ( REPLICATOR STATE ONLINE ) ) return Resource State . ONLINE ; else if ( state . starts With ( REPLICATOR STATE STOPPED ) ) { return Resource State . STOPPED ; } else if ( state . starts With ( REPLICATOR STATE OFFLINE ) ) { if ( state . equals ( REPLICATOR STATE ERROR ) ) { return Resource State . SUSPECT ; } else if ( state . equals ( REPLICATOR STATE BACKUP ) ) { return Resource State . BACKUP ; } else if ( state . equals ( REPLICATOR STATE RESTORING ) ) { return Resource State . RESTORING ; } else { return Resource State . OFFLINE ; } } else if ( state . contains ( REPLICATOR STATE SYNCHRONIZING ) ) return Resource State . SYNCHRONIZING ; else return Resource State . UNKNOWN ; }
static public Resource State replicator State To Resource State ( String state ) { if ( state . starts With ( REPLICATOR STATE ONLINE ) ) return Resource State . ONLINE ; else if ( state . starts With ( REPLICATOR STATE STOPPED ) ) { return Resource State . STOPPED ; } else if ( state . starts With ( REPLICATOR STATE OFFLINE ) ) { if ( state . equals ( REPLICATOR STATE ERROR ) ) { return Resource State . SUSPECT ; } else if ( state . equals ( REPLICATOR STATE BACKUP ) ) { return Resource State . BACKUP ; } else if ( state . equals ( REPLICATOR STATE RESTORING ) ) { return Resource State . RESTORING ; } else { return Resource State . OFFLINE ; } } else if ( state . contains ( REPLICATOR STATE SYNCHRONIZING ) ) return Resource State . SYNCHRONIZING ; else return Resource State . UNKNOWN ; }
@ GET @ Path ( STRING ) @ Produces ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Check Permission ( roles = { Role . SECURITY ADMIN } ) public OS Tenant List Rest Rep list Coprhd Os Tenants ( ) { log . debug ( STRING ) ; List < OS Tenant > tenants = get Os Tenants From Coprhd Db ( ) ; return map ( tenants ) ; }
public static < R , A , B > Completion Stage < R > combine ( Completion Stage < A > a , Completion Stage < B > b , Bi Function < A , B , R > function ) { return a . then Combine ( b , function ) ; }
public Class Node transform ( ) { process Fields ( ) ; process Methods ( ) ; clear Intermediate Results ( ) ; if ( class Name . equals ( Properties . TARGET CLASS ) || class Name . starts With ( Properties . TARGET CLASS + STRING ) ) Transformation Statistics . write Statistics ( class Name ) ; return cn ; }
abstract boolean contains Key ( T container , String key ) ;
abstract boolean contains Key ( T container , String key ) ;
abstract boolean contains Key ( T container , String key ) ;
abstract boolean contains Key ( T container , String key ) ;
protected void add Options ( Map < String , String > moreopts ) { Map < String , String > active Opts = new Hash Map < String , String > ( get Options ( ) ) ; active Opts . put All ( moreopts ) ; active Options = Collections . unmodifiable Map ( active Opts ) ; }
protected void add Options ( Map < String , String > moreopts ) { Map < String , String > active Opts = new Hash Map < String , String > ( get Options ( ) ) ; active Opts . put All ( moreopts ) ; active Options = Collections . unmodifiable Map ( active Opts ) ; }
protected void add Options ( Map < String , String > moreopts ) { Map < String , String > active Opts = new Hash Map < String , String > ( get Options ( ) ) ; active Opts . put All ( moreopts ) ; active Options = Collections . unmodifiable Map ( active Opts ) ; }
protected void add Options ( Map < String , String > moreopts ) { Map < String , String > active Opts = new Hash Map < String , String > ( get Options ( ) ) ; active Opts . put All ( moreopts ) ; active Options = Collections . unmodifiable Map ( active Opts ) ; }
public void paint ( Graphics g ) { g . set Color ( Color . white ) ; g . fill Rect ( NUM , NUM , get Width ( ) , get Height ( ) ) ; g . set Color ( Color . BLACK ) ; for ( int stripe X = NUM ; stripe X < get Width ( ) ; stripe X += CHECKER SIZE ) { for ( int y = NUM , row = NUM ; y < get Height ( ) ; y += CHECKER SIZE / NUM , ++ row ) { int x = ( row % NUM == NUM ) ? stripe X : ( stripe X + CHECKER SIZE / NUM ) ; g . fill Rect ( x , y , CHECKER SIZE / NUM , CHECKER SIZE / NUM ) ; } } g . translate ( NUM , translate Y ) ; super . paint ( g ) ; }
public void paint ( Graphics g ) { g . set Color ( Color . white ) ; g . fill Rect ( NUM , NUM , get Width ( ) , get Height ( ) ) ; g . set Color ( Color . BLACK ) ; for ( int stripe X = NUM ; stripe X < get Width ( ) ; stripe X += CHECKER SIZE ) { for ( int y = NUM , row = NUM ; y < get Height ( ) ; y += CHECKER SIZE / NUM , ++ row ) { int x = ( row % NUM == NUM ) ? stripe X : ( stripe X + CHECKER SIZE / NUM ) ; g . fill Rect ( x , y , CHECKER SIZE / NUM , CHECKER SIZE / NUM ) ; } } g . translate ( NUM , translate Y ) ; super . paint ( g ) ; }
public Service Host start Factory ( Supplier < Factory Service > factory Creator , String service Path ) { Operation post = Operation . create Post ( Uri Utils . build Uri ( this , service Path ) ) ; Factory Service factory Service = factory Creator . get ( ) ; return start Service ( post , factory Service ) ; }
public Service Host start Factory ( Supplier < Factory Service > factory Creator , String service Path ) { Operation post = Operation . create Post ( Uri Utils . build Uri ( this , service Path ) ) ; Factory Service factory Service = factory Creator . get ( ) ; return start Service ( post , factory Service ) ; }
public Service Host start Factory ( Supplier < Factory Service > factory Creator , String service Path ) { Operation post = Operation . create Post ( Uri Utils . build Uri ( this , service Path ) ) ; Factory Service factory Service = factory Creator . get ( ) ; return start Service ( post , factory Service ) ; }
public Service Host start Factory ( Supplier < Factory Service > factory Creator , String service Path ) { Operation post = Operation . create Post ( Uri Utils . build Uri ( this , service Path ) ) ; Factory Service factory Service = factory Creator . get ( ) ; return start Service ( post , factory Service ) ; }
void write Bytes ( Channel Handler Context ctx , Byte Buf bytes ) ;
void write Bytes ( Channel Handler Context ctx , Byte Buf bytes ) ;
void write Bytes ( Channel Handler Context ctx , Byte Buf bytes ) ;
void write Bytes ( Channel Handler Context ctx , Byte Buf bytes ) ;
public boolean wait Until Empty ( long timeout ) throws Interrupted Exception { if ( ! notify Lock . try Lock ( timeout , Time Unit . MILLISECONDS ) ) { return BOOL ; } try { return pending . is Empty ( ) || notify Condition . await ( timeout , Time Unit . MILLISECONDS ) ; } finally { notify Lock . unlock ( ) ; } }
public static void report ( ) { if ( License . is Developer ( ) ) { for ( final Object obj : SPIES ) { Diagnostic . developer Log ( obj . to String ( ) ) ; } } }
private void add Internal Listeners ( ) { cb Distribution . add Item Listener ( cb Item Listener ) ; }
private void add Internal Listeners ( ) { cb Distribution . add Item Listener ( cb Item Listener ) ; }
private void update Property To Value 2 ( ) throws Exception { properties . put ( TEST KEY , TEST VALUE 2 ) ; update Properties File ( ) ; }
protected String Buffer parse String ( String Buffer sbuf ) throws IO Exception { int ch ; while ( ( ch = read Char ( ) ) >= NUM ) sbuf . append ( ( char ) ch ) ; return sbuf ; }
public Text Editor replace All ( Pattern pattern , Replacement replacement ) { Matcher m = pattern . matcher ( text ) ; int last Index = NUM ; String Buffer sb = new String Buffer ( ) ; while ( m . find ( ) ) { sb . append ( text . sub Sequence ( last Index , m . start ( ) ) ) ; sb . append ( replacement . replacement ( m ) ) ; last Index = m . end ( ) ; } sb . append ( text . sub Sequence ( last Index , text . length ( ) ) ) ; text = sb ; return this ; }
public Text Editor replace All ( Pattern pattern , Replacement replacement ) { Matcher m = pattern . matcher ( text ) ; int last Index = NUM ; String Buffer sb = new String Buffer ( ) ; while ( m . find ( ) ) { sb . append ( text . sub Sequence ( last Index , m . start ( ) ) ) ; sb . append ( replacement . replacement ( m ) ) ; last Index = m . end ( ) ; } sb . append ( text . sub Sequence ( last Index , text . length ( ) ) ) ; text = sb ; return this ; }
public Text Editor replace All ( Pattern pattern , Replacement replacement ) { Matcher m = pattern . matcher ( text ) ; int last Index = NUM ; String Buffer sb = new String Buffer ( ) ; while ( m . find ( ) ) { sb . append ( text . sub Sequence ( last Index , m . start ( ) ) ) ; sb . append ( replacement . replacement ( m ) ) ; last Index = m . end ( ) ; } sb . append ( text . sub Sequence ( last Index , text . length ( ) ) ) ; text = sb ; return this ; }
public Text Editor replace All ( Pattern pattern , Replacement replacement ) { Matcher m = pattern . matcher ( text ) ; int last Index = NUM ; String Buffer sb = new String Buffer ( ) ; while ( m . find ( ) ) { sb . append ( text . sub Sequence ( last Index , m . start ( ) ) ) ; sb . append ( replacement . replacement ( m ) ) ; last Index = m . end ( ) ; } sb . append ( text . sub Sequence ( last Index , text . length ( ) ) ) ; text = sb ; return this ; }
public Set < String > add Content ( String variable , double value ) { if ( ! paused ) { cur State . add To State ( new Assignment ( variable , value ) ) ; return update ( ) ; } else { log . info ( STRING + variable + STRING + value ) ; return Collections . empty Set ( ) ; } }
public Set < String > add Content ( String variable , double value ) { if ( ! paused ) { cur State . add To State ( new Assignment ( variable , value ) ) ; return update ( ) ; } else { log . info ( STRING + variable + STRING + value ) ; return Collections . empty Set ( ) ; } }
public Set < String > add Content ( String variable , double value ) { if ( ! paused ) { cur State . add To State ( new Assignment ( variable , value ) ) ; return update ( ) ; } else { log . info ( STRING + variable + STRING + value ) ; return Collections . empty Set ( ) ; } }
private void create Input List ( ) { input List . clear ( ) ; List < Cmr Repository Definition > repositories = cmr Repository Manager . get Cmr Repository Definitions ( ) ; for ( Cmr Repository Definition cmr Repository Definition : repositories ) { input List . add ( new Deferred Agents Composite ( cmr Repository Definition , show Old Agents ) ) ; Online Status online Status = cmr Repository Definition . get Online Status ( ) ; if ( ( online Status == Online Status . ONLINE ) || ( online Status == Online Status . OFFLINE ) ) { cached Status Map . put ( cmr Repository Definition , online Status ) ; } } }
public static String to String ( final byte [ ] bytes ) { String Builder hexed = new String Builder ( ) ; for ( int i = NUM ; i < bytes . length ; i ++ ) { hexed . append ( to String ( bytes [ i ] ) ) ; hexed . append ( STRING ) ; } return hexed . substring ( NUM , hexed . length ( ) - NUM ) ; }
public Issuer Alternative Name Extension ( Boolean critical , Object value ) throws IO Exception { this . extension Id = PKIX Extensions . Issuer Alternative Name Id ; this . critical = critical . boolean Value ( ) ; this . extension Value = ( byte [ ] ) value ; Der Value val = new Der Value ( this . extension Value ) ; if ( val . data == null ) { names = new General Names ( ) ; return ; } names = new General Names ( val ) ; }
protected < T extends Abstract Option Value < ? , ? > > Abstract Options ( Function < T , T > value Filter , Abstract Options base Options , Iterable < T > values ) { require Non Null ( base Options , STRING ) ; require Non Null ( value Filter , STRING ) ; require Non Null ( values , STRING ) ; value Map = new Identity Hash Map < > ( base Options . value Map ) ; put All ( value Filter , Stream Support . stream ( values . spliterator ( ) , BOOL ) ) ; }
public default Utility Table query Util ( B Network network , String query Var , Assignment evidence ) { return query Util ( new Query . Util Query ( network , Arrays . as List ( query Var ) , evidence ) ) ; }
public Create Custom Metric ( Monitoring monitoring Service , String project Resource ) { this . monitoring Service = monitoring Service ; this . project Resource = project Resource ; this . metric Type = CUSTOM METRIC DOMAIN + STRING + DEFAULT METRIC TYPE ; this . metric Name = project Resource + STRING + metric Type ; }
public void init ( My Perf Context ctx ) { logger . info ( STRING ) ; configured = BOOL ; File cfg File = null ; myperf Config Path = System . get Property ( MYPERF CONFIG PATH PROP NAME ) ; if ( myperf Config Path == null || myperf Config Path . is Empty ( ) ) { File cfg Dir = new File ( new File ( ROOTPATH ) , STORAGE DIR ) ; if ( ! cfg Dir . exists ( ) ) cfg Dir . mkdirs ( ) ; cfg File = new File ( cfg Dir , MYPERF CONFIG FILE NAME ) ; myperf Config Path = cfg File . get Absolute Path ( ) ; } else cfg File = new File ( myperf Config Path ) ; if ( ! cfg File . exists ( ) ) { logger . info ( STRING + cfg File . get Absolute Path ( ) + STRING ) ; return ; } logger . info ( STRING + cfg File . get Absolute Path ( ) ) ; if ( read Config ( cfg File , ctx ) ) { configured = BOOL ; } logger . info ( STRING + cfg File . get Absolute Path ( ) + STRING + configured ) ; }
public static Resource Group State create Default Resource Group ( Verification Host host , String project Id ) throws Throwable { Resource Group State resource Group = new Resource Group State ( ) ; resource Group . name = project Id ; return Test Utils . do Post ( host , resource Group , Resource Group State . class , Uri Utils . build Uri ( host , Resource Group Service . FACTORY LINK ) ) ; }
public Object put ( String key , Object value ) { Object old Value = context . get Attribute ( key , ENGINE SCOPE ) ; context . set Attribute ( key , value , ENGINE SCOPE ) ; return old Value ; }
private static boolean is Gnome ( ) { return System . getenv ( STRING ) != null ; }
private static boolean is Gnome ( ) { return System . getenv ( STRING ) != null ; }
public boolean is Remove Unsupported Encodings ( ) { return remove Unsupported Encodings ; }
public void restore Topology ( Iterable < Tcp Discovery Node > nodes , long top Ver ) { assert ! F . is Empty ( nodes ) ; assert top Ver > NUM ; rw Lock . write Lock ( ) . lock ( ) ; try { loc Node . internal Order ( top Ver ) ; clear ( ) ; boolean first Add = BOOL ; for ( Tcp Discovery Node node : nodes ) { if ( nodes Map . contains Key ( node . id ( ) ) ) continue ; nodes Map . put ( node . id ( ) , node ) ; if ( first Add ) { this . nodes = new Tree Set < > ( this . nodes ) ; first Add = BOOL ; } node . last Update Time ( U . current Time Millis ( ) ) ; this . nodes . add ( node ) ; } node Order = top Ver ; initialize Minimum Version ( ) ; } finally { rw Lock . write Lock ( ) . unlock ( ) ; } }
public void restore Topology ( Iterable < Tcp Discovery Node > nodes , long top Ver ) { assert ! F . is Empty ( nodes ) ; assert top Ver > NUM ; rw Lock . write Lock ( ) . lock ( ) ; try { loc Node . internal Order ( top Ver ) ; clear ( ) ; boolean first Add = BOOL ; for ( Tcp Discovery Node node : nodes ) { if ( nodes Map . contains Key ( node . id ( ) ) ) continue ; nodes Map . put ( node . id ( ) , node ) ; if ( first Add ) { this . nodes = new Tree Set < > ( this . nodes ) ; first Add = BOOL ; } node . last Update Time ( U . current Time Millis ( ) ) ; this . nodes . add ( node ) ; } node Order = top Ver ; initialize Minimum Version ( ) ; } finally { rw Lock . write Lock ( ) . unlock ( ) ; } }
public void restore Topology ( Iterable < Tcp Discovery Node > nodes , long top Ver ) { assert ! F . is Empty ( nodes ) ; assert top Ver > NUM ; rw Lock . write Lock ( ) . lock ( ) ; try { loc Node . internal Order ( top Ver ) ; clear ( ) ; boolean first Add = BOOL ; for ( Tcp Discovery Node node : nodes ) { if ( nodes Map . contains Key ( node . id ( ) ) ) continue ; nodes Map . put ( node . id ( ) , node ) ; if ( first Add ) { this . nodes = new Tree Set < > ( this . nodes ) ; first Add = BOOL ; } node . last Update Time ( U . current Time Millis ( ) ) ; this . nodes . add ( node ) ; } node Order = top Ver ; initialize Minimum Version ( ) ; } finally { rw Lock . write Lock ( ) . unlock ( ) ; } }
public void restore Topology ( Iterable < Tcp Discovery Node > nodes , long top Ver ) { assert ! F . is Empty ( nodes ) ; assert top Ver > NUM ; rw Lock . write Lock ( ) . lock ( ) ; try { loc Node . internal Order ( top Ver ) ; clear ( ) ; boolean first Add = BOOL ; for ( Tcp Discovery Node node : nodes ) { if ( nodes Map . contains Key ( node . id ( ) ) ) continue ; nodes Map . put ( node . id ( ) , node ) ; if ( first Add ) { this . nodes = new Tree Set < > ( this . nodes ) ; first Add = BOOL ; } node . last Update Time ( U . current Time Millis ( ) ) ; this . nodes . add ( node ) ; } node Order = top Ver ; initialize Minimum Version ( ) ; } finally { rw Lock . write Lock ( ) . unlock ( ) ; } }
public Encrypted Editor put Long ( String key , long value ) { put Value ( key , String . value Of ( value ) ) ; return this ; }
public void await ( ) throws Interrupted Exception { await Semaphore . acquire ( ) ; await Semaphore . release ( ) ; }
public int available ( ) throws IO Exception { int bytes Available = in . available ( ) ; if ( bytes Available > bytes Left ) bytes Available = bytes Left ; return bytes Available ; }
public int available ( ) throws IO Exception { int bytes Available = in . available ( ) ; if ( bytes Available > bytes Left ) bytes Available = bytes Left ; return bytes Available ; }
public int available ( ) throws IO Exception { int bytes Available = in . available ( ) ; if ( bytes Available > bytes Left ) bytes Available = bytes Left ; return bytes Available ; }
public int available ( ) throws IO Exception { int bytes Available = in . available ( ) ; if ( bytes Available > bytes Left ) bytes Available = bytes Left ; return bytes Available ; }
public int available ( ) throws IO Exception { int bytes Available = in . available ( ) ; if ( bytes Available > bytes Left ) bytes Available = bytes Left ; return bytes Available ; }
public int available ( ) throws IO Exception { int bytes Available = in . available ( ) ; if ( bytes Available > bytes Left ) bytes Available = bytes Left ; return bytes Available ; }
public int available ( ) throws IO Exception { int bytes Available = in . available ( ) ; if ( bytes Available > bytes Left ) bytes Available = bytes Left ; return bytes Available ; }
@ Override public final void read Fully ( byte ba [ ] ) throws IO Exception { dis . read Fully ( ba , NUM , ba . length ) ; }
public int read ( ) throws IO Exception { return is . read ( ) ; }
private static double distance Sq ( Color a , Color b ) { double r Mean = ( a . get Red ( ) + b . get Red ( ) ) / NUM / NUM ; double dr = ( a . get Red ( ) - b . get Red ( ) ) / NUM ; double dg = ( a . get Green ( ) - b . get Green ( ) ) / NUM ; double db = ( a . get Blue ( ) - b . get Blue ( ) ) / NUM ; double d = ( NUM + r Mean ) * dr * dr + NUM * dg * dg + ( NUM + NUM - r Mean ) * db * db ; return d / NUM ; }
public Iterator < Detector Factory > iterator ( ) { return ordered Factory List . iterator ( ) ; }
public Iterator < Detector Factory > iterator ( ) { return ordered Factory List . iterator ( ) ; }
public void test Many Connections Using Many Threads ( ) { int num Tasks = get Connection Num ( ) ; Thread Pool thread Pool = new Thread Pool ( num Tasks ) ; for ( int i = NUM ; i < num Tasks ; i ++ ) { thread Pool . run Task ( create Task ( i ) ) ; } thread Pool . join ( ) ; assert Equals ( STRING , num Tasks , vc . size ( ) ) ; if ( num Tasks != Support SQL . sql Max Connections ) { try { Connection c = Support SQL . get Connection ( ) ; c . close ( ) ; fail ( STRING + num Tasks + STRING ) ; } catch ( SQL Exception sql ) { } } }
public String basic Type Name Boxed ( Field field ) { return java Common . boxed Type Name ( basic Type Name ( field ) ) ; }
public String basic Type Name Boxed ( Field field ) { return java Common . boxed Type Name ( basic Type Name ( field ) ) ; }
public static int hash ( double [ ] value ) { return Arrays . hash Code ( value ) ; }
public static int hash ( double [ ] value ) { return Arrays . hash Code ( value ) ; }
private char read Escape Character ( ) throws IO Exception { if ( pos == limit && ! fill Buffer ( NUM ) ) { throw syntax Error ( STRING ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case STRING : if ( pos + NUM > limit && ! fill Buffer ( NUM ) ) { throw syntax Error ( STRING ) ; } String hex = string Pool . get ( buffer , pos , NUM ) ; pos += NUM ; return ( char ) Integer . parse Int ( hex , NUM ) ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private char read Escape Character ( ) throws IO Exception { if ( pos == limit && ! fill Buffer ( NUM ) ) { throw syntax Error ( STRING ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case STRING : if ( pos + NUM > limit && ! fill Buffer ( NUM ) ) { throw syntax Error ( STRING ) ; } String hex = string Pool . get ( buffer , pos , NUM ) ; pos += NUM ; return ( char ) Integer . parse Int ( hex , NUM ) ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private char read Escape Character ( ) throws IO Exception { if ( pos == limit && ! fill Buffer ( NUM ) ) { throw syntax Error ( STRING ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case STRING : if ( pos + NUM > limit && ! fill Buffer ( NUM ) ) { throw syntax Error ( STRING ) ; } String hex = string Pool . get ( buffer , pos , NUM ) ; pos += NUM ; return ( char ) Integer . parse Int ( hex , NUM ) ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private char read Escape Character ( ) throws IO Exception { if ( pos == limit && ! fill Buffer ( NUM ) ) { throw syntax Error ( STRING ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case STRING : if ( pos + NUM > limit && ! fill Buffer ( NUM ) ) { throw syntax Error ( STRING ) ; } String hex = string Pool . get ( buffer , pos , NUM ) ; pos += NUM ; return ( char ) Integer . parse Int ( hex , NUM ) ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private char read Escape Character ( ) throws IO Exception { if ( pos == limit && ! fill Buffer ( NUM ) ) { throw syntax Error ( STRING ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case STRING : if ( pos + NUM > limit && ! fill Buffer ( NUM ) ) { throw syntax Error ( STRING ) ; } String hex = string Pool . get ( buffer , pos , NUM ) ; pos += NUM ; return ( char ) Integer . parse Int ( hex , NUM ) ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private String strip Code Value Sentences ( String string ) { return string . replace All ( STRING , STRING ) ; }
private void map ( Collection < Key Cache Object > keys , boolean remap , boolean top Locked ) { try { map 0 ( keys , remap , top Locked ) ; } catch ( Ignite Checked Exception ex ) { on Done ( BOOL , ex ) ; } }
private void map ( Collection < Key Cache Object > keys , boolean remap , boolean top Locked ) { try { map 0 ( keys , remap , top Locked ) ; } catch ( Ignite Checked Exception ex ) { on Done ( BOOL , ex ) ; } }
private void map ( Collection < Key Cache Object > keys , boolean remap , boolean top Locked ) { try { map 0 ( keys , remap , top Locked ) ; } catch ( Ignite Checked Exception ex ) { on Done ( BOOL , ex ) ; } }
private void map ( Collection < Key Cache Object > keys , boolean remap , boolean top Locked ) { try { map 0 ( keys , remap , top Locked ) ; } catch ( Ignite Checked Exception ex ) { on Done ( BOOL , ex ) ; } }
private void map ( Collection < Key Cache Object > keys , boolean remap , boolean top Locked ) { try { map 0 ( keys , remap , top Locked ) ; } catch ( Ignite Checked Exception ex ) { on Done ( BOOL , ex ) ; } }
public static byte random Byte ( int max ) { return ( byte ) random . next Int ( max + NUM ) ; }
protected boolean strict Parse Boolean ( String s ) { if ( s == null || s . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( s . equals Ignore Case ( STRING ) ) { return BOOL ; } if ( s . equals Ignore Case ( STRING ) ) { return BOOL ; } throw new Illegal Argument Exception ( STRING + s ) ; }
protected boolean strict Parse Boolean ( String s ) { if ( s == null || s . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( s . equals Ignore Case ( STRING ) ) { return BOOL ; } if ( s . equals Ignore Case ( STRING ) ) { return BOOL ; } throw new Illegal Argument Exception ( STRING + s ) ; }
protected boolean strict Parse Boolean ( String s ) { if ( s == null || s . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( s . equals Ignore Case ( STRING ) ) { return BOOL ; } if ( s . equals Ignore Case ( STRING ) ) { return BOOL ; } throw new Illegal Argument Exception ( STRING + s ) ; }
protected boolean strict Parse Boolean ( String s ) { if ( s == null || s . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( s . equals Ignore Case ( STRING ) ) { return BOOL ; } if ( s . equals Ignore Case ( STRING ) ) { return BOOL ; } throw new Illegal Argument Exception ( STRING + s ) ; }
protected boolean strict Parse Boolean ( String s ) { if ( s == null || s . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( s . equals Ignore Case ( STRING ) ) { return BOOL ; } if ( s . equals Ignore Case ( STRING ) ) { return BOOL ; } throw new Illegal Argument Exception ( STRING + s ) ; }
private void step ( ) { casings . for Each ( null ) ; casings . for Each ( null ) ; casings . for Each ( null ) ; step Pipes ( ) ; step Forwarders ( ) ; }
public static Element add Child Element NS Element ( Element element , String child Element Name , Document document , String name Space Url ) { Element new Element = document . create Element NS ( name Space Url , child Element Name ) ; element . append Child ( new Element ) ; return element ; }
public static Element add Child Element NS Element ( Element element , String child Element Name , Document document , String name Space Url ) { Element new Element = document . create Element NS ( name Space Url , child Element Name ) ; element . append Child ( new Element ) ; return element ; }
public boolean delete Road Name ( String road ) { if ( ! road List . contains ( road ) ) { return BOOL ; } road List . remove ( road ) ; log . debug ( STRING + get Name ( ) + STRING + road ) ; set Dirty And Fire Property Change ( ROADS CHANGED PROPERTY , road List . size ( ) + NUM , road List . size ( ) ) ; return BOOL ; }
public void retrieve File ( String path , Output Stream os , int limit ) throws IO Exception , Ftp Exception Can Not Have Data Connection , Ftp Exception Unknown Forced Data Close , Ftp Exception Control Closed By Forced Data Close { Socket socket = open Passive Data Connection ( FTP Command . RETR , path ) ; if ( socket == null ) throw new Ftp Exception Can Not Have Data Connection ( STRING + ( ( path == null ) ? STRING : path ) ) ; Input Stream input = socket . get Input Stream ( ) ; int len ; int count = NUM ; byte [ ] buf = new byte [ org . apache . commons . net . io . Util . DEFAULT COPY BUFFER SIZE ] ; while ( ( len = input . read ( buf , NUM , buf . length ) ) != - NUM ) { count += len ; if ( limit >= NUM && count > limit ) { os . write ( buf , NUM , len - ( count - limit ) ) ; break ; } os . write ( buf , NUM , len ) ; os . flush ( ) ; } socket . close ( ) ; try { int reply = get Reply ( ) ; if ( ! not Bad Reply ( reply ) ) throw new Ftp Exception Unknown Forced Data Close ( get Reply String ( ) ) ; } catch ( FTP Connection Closed Exception e ) { throw new Ftp Exception Control Closed By Forced Data Close ( e . get Message ( ) ) ; } }
public Abstract Ddl Builder ( String database Name ) { this . database Name = database Name ; add Escaped Char Sequence ( STRING , STRING ) ; }
private Map < Plugin Util . Checker Prop , Object > make Props ( ) { final String source Path = String Utils . join ( compile Source Roots . iterator ( ) , File . path Separator ) ; final List < String > misc Options = new Array List < String > ( ) ; misc Options . add ( STRING ) ; misc Options . add ( source Path ) ; if ( ! String Utils . is Empty ( java Params ) ) { misc Options . add All ( Plugin Util . to Java Opts ( Arrays . as List ( java Params . split ( STRING ) ) ) ) ; } if ( ! String Utils . is Empty ( javac Params ) ) { misc Options . add All ( Arrays . as List ( javac Params . split ( STRING ) ) ) ; } final Map < Plugin Util . Checker Prop , Object > props = new Hash Map < Plugin Util . Checker Prop , Object > ( ) ; props . put ( Plugin Util . Checker Prop . MISC COMPILER , misc Options ) ; return props ; }
private Map < Plugin Util . Checker Prop , Object > make Props ( ) { final String source Path = String Utils . join ( compile Source Roots . iterator ( ) , File . path Separator ) ; final List < String > misc Options = new Array List < String > ( ) ; misc Options . add ( STRING ) ; misc Options . add ( source Path ) ; if ( ! String Utils . is Empty ( java Params ) ) { misc Options . add All ( Plugin Util . to Java Opts ( Arrays . as List ( java Params . split ( STRING ) ) ) ) ; } if ( ! String Utils . is Empty ( javac Params ) ) { misc Options . add All ( Arrays . as List ( javac Params . split ( STRING ) ) ) ; } final Map < Plugin Util . Checker Prop , Object > props = new Hash Map < Plugin Util . Checker Prop , Object > ( ) ; props . put ( Plugin Util . Checker Prop . MISC COMPILER , misc Options ) ; return props ; }
private Map < Plugin Util . Checker Prop , Object > make Props ( ) { final String source Path = String Utils . join ( compile Source Roots . iterator ( ) , File . path Separator ) ; final List < String > misc Options = new Array List < String > ( ) ; misc Options . add ( STRING ) ; misc Options . add ( source Path ) ; if ( ! String Utils . is Empty ( java Params ) ) { misc Options . add All ( Plugin Util . to Java Opts ( Arrays . as List ( java Params . split ( STRING ) ) ) ) ; } if ( ! String Utils . is Empty ( javac Params ) ) { misc Options . add All ( Arrays . as List ( javac Params . split ( STRING ) ) ) ; } final Map < Plugin Util . Checker Prop , Object > props = new Hash Map < Plugin Util . Checker Prop , Object > ( ) ; props . put ( Plugin Util . Checker Prop . MISC COMPILER , misc Options ) ; return props ; }
public void close ( ) throws java . io . IO Exception { internal . close ( ) ; cbuffer Off = - NUM ; }
public void close ( ) throws java . io . IO Exception { internal . close ( ) ; cbuffer Off = - NUM ; }
public void close ( ) throws java . io . IO Exception { internal . close ( ) ; cbuffer Off = - NUM ; }
public static void UF 10 ( double [ ] x , double [ ] f , int nx ) { int count 1 = NUM ; int count 2 = NUM ; int count 3 = NUM ; double sum 1 = NUM ; double sum 2 = NUM ; double sum 3 = NUM ; double yj ; double hj ; for ( int j = NUM ; j <= nx ; j ++ ) { yj = x [ j - NUM ] - NUM * x [ NUM ] * Math . sin ( NUM * PI * x [ NUM ] + j * PI / nx ) ; hj = NUM * yj * yj - Math . cos ( NUM * PI * yj ) + NUM ; if ( j % NUM == NUM ) { sum 1 += hj ; count 1 ++ ; } else if ( j % NUM == NUM ) { sum 2 += hj ; count 2 ++ ; } else { sum 3 += hj ; count 3 ++ ; } } f [ NUM ] = Math . cos ( NUM * PI * x [ NUM ] ) * Math . cos ( NUM * PI * x [ NUM ] ) + NUM * sum 1 / ( double ) count 1 ; f [ NUM ] = Math . cos ( NUM * PI * x [ NUM ] ) * Math . sin ( NUM * PI * x [ NUM ] ) + NUM * sum 2 / ( double ) count 2 ; f [ NUM ] = Math . sin ( NUM * PI * x [ NUM ] ) + NUM * sum 3 / ( double ) count 3 ; }
public long to Seconds ( ) { return time Unit . to Seconds ( length ) ; }
protected void handle Or Defer Message ( Distribution Message msg ) { synchronized ( startup Lock ) { if ( being Sick || playing Dead ) { if ( msg . contains Region Content Change ( ) || msg instanceof Partition Message With Direct Reply ) { startup Messages . add ( new Startup Event ( msg ) ) ; return ; } } if ( ! processing Events ) { startup Messages . add ( new Startup Event ( msg ) ) ; return ; } } dispatch Message ( msg ) ; }
public static List < Long > z Score Test ( Geo Time Serie gts , boolean use Median , double d ) throws Warp Script Exception { double Check ( gts ) ; List < Long > anomalous ticks = new Array List < Long > ( ) ; double [ ] musigma = madsigma ( gts , use Median ) ; double m = musigma [ NUM ] ; double std = musigma [ NUM ] ; if ( NUM == std ) { return anomalous ticks ; } for ( int i = NUM ; i < gts . values ; i ++ ) { double z = ( gts . double Values [ i ] - m ) / std ; if ( Math . abs ( z ) >= d ) { anomalous ticks . add ( gts . ticks [ i ] ) ; } } return anomalous ticks ; }
public static boolean is Email Registered ( String email ) { Persistence Manager pm = pmf . get Persistence Manager ( ) ; try { User Record user = find User By Email ( pm , email ) ; return user != null ; } finally { pm . close ( ) ; } }
public static boolean is Email Registered ( String email ) { Persistence Manager pm = pmf . get Persistence Manager ( ) ; try { User Record user = find User By Email ( pm , email ) ; return user != null ; } finally { pm . close ( ) ; } }
private File Log Accessor resolve Stdout Log Destination ( String file Name ) { File stdout = new File ( System . get Property ( STRING ) , STRING + file Name ) ; if ( stdout . exists ( ) ) { File Log Accessor fla = new File Log Accessor ( ) ; fla . set Name ( file Name ) ; fla . set File ( stdout ) ; return fla ; } return null ; }
private File Log Accessor resolve Stdout Log Destination ( String file Name ) { File stdout = new File ( System . get Property ( STRING ) , STRING + file Name ) ; if ( stdout . exists ( ) ) { File Log Accessor fla = new File Log Accessor ( ) ; fla . set Name ( file Name ) ; fla . set File ( stdout ) ; return fla ; } return null ; }
public boolean has Logical Mapping ( String logical Name ) { return logical To Physical Column Names . contains Key ( logical Name ) ; }
public boolean has Logical Mapping ( String logical Name ) { return logical To Physical Column Names . contains Key ( logical Name ) ; }
public void add Hold And Release View ( @ Id Res int hold And Release View Id ) { hold And Release Views . add ( new Hold And Release View ( peek View . find View By Id ( hold And Release View Id ) ) ) ; }
public void add Hold And Release View ( @ Id Res int hold And Release View Id ) { hold And Release Views . add ( new Hold And Release View ( peek View . find View By Id ( hold And Release View Id ) ) ) ; }
public void add Hold And Release View ( @ Id Res int hold And Release View Id ) { hold And Release Views . add ( new Hold And Release View ( peek View . find View By Id ( hold And Release View Id ) ) ) ; }
public void add Hold And Release View ( @ Id Res int hold And Release View Id ) { hold And Release Views . add ( new Hold And Release View ( peek View . find View By Id ( hold And Release View Id ) ) ) ; }
public void add Hold And Release View ( @ Id Res int hold And Release View Id ) { hold And Release Views . add ( new Hold And Release View ( peek View . find View By Id ( hold And Release View Id ) ) ) ; }
public void add Hold And Release View ( @ Id Res int hold And Release View Id ) { hold And Release Views . add ( new Hold And Release View ( peek View . find View By Id ( hold And Release View Id ) ) ) ; }
public boolean import Pvk ( ) { return jrb Pvk . is Selected ( ) ; }
public Node add Node ( Coordinate coord ) { Node node = ( Node ) node Map . get ( coord ) ; if ( node == null ) { node = node Fact . create Node ( coord ) ; node Map . put ( coord , node ) ; } return node ; }
public Node add Node ( Coordinate coord ) { Node node = ( Node ) node Map . get ( coord ) ; if ( node == null ) { node = node Fact . create Node ( coord ) ; node Map . put ( coord , node ) ; } return node ; }
public Node add Node ( Coordinate coord ) { Node node = ( Node ) node Map . get ( coord ) ; if ( node == null ) { node = node Fact . create Node ( coord ) ; node Map . put ( coord , node ) ; } return node ; }
private void ensure Capacity ( int words Required ) { if ( words . length < words Required ) { int request = Math . max ( NUM * words . length , words Required ) ; words = Arrays . copy Of ( words , request ) ; size Is Sticky = BOOL ; } }
private void ensure Capacity ( int words Required ) { if ( words . length < words Required ) { int request = Math . max ( NUM * words . length , words Required ) ; words = Arrays . copy Of ( words , request ) ; size Is Sticky = BOOL ; } }
protected Logger ( String name , String resource Bundle Name ) { super ( name , resource Bundle Name ) ; }
protected Logger ( String name , String resource Bundle Name ) { super ( name , resource Bundle Name ) ; }
protected void send End Of Header ( final Output Stream out ) throws IO Exception { LOG . trace ( STRING ) ; out . write ( CRLF BYTES ) ; out . write ( CRLF BYTES ) ; }
public static int height ( final Segment document , final int max Width , final Font Renderer renderer ) { int current X = NUM ; int current Y = NUM ; Segment segment = document ; while ( segment != null ) { current Y += segment . next Y ( current X , max Width , renderer ) ; current X = segment . next X ( current X , max Width , renderer ) ; segment = segment . next ( ) ; } return current Y ; }
public static int height ( final Segment document , final int max Width , final Font Renderer renderer ) { int current X = NUM ; int current Y = NUM ; Segment segment = document ; while ( segment != null ) { current Y += segment . next Y ( current X , max Width , renderer ) ; current X = segment . next X ( current X , max Width , renderer ) ; segment = segment . next ( ) ; } return current Y ; }
private synchronized static Datastore create Datastore ( ) { if ( data Store == null ) { Morphia m = new Morphia ( ) ; String mongo Name = Kraken Config . get Property ( STRING ) ; data Store = m . create Datastore ( get Mongo ( mongo Name ) , mongo Name ) ; m . map ( Customer . class ) ; m . map ( Project . class ) ; m . map ( Attribute . class ) ; m . map ( Dimension . class ) ; m . map ( Domain . class ) ; m . map ( Project Facet Job . class ) ; m . map ( Metric . class ) ; m . map ( Client . class ) ; m . map ( User . class ) ; m . map ( User Group . class ) ; m . map ( Project Analysis Job . class ) ; m . map ( Access Token . class ) ; m . map ( Relation . class ) ; m . map ( Annotation . class ) ; m . map ( Project User . class ) ; m . map ( State . class ) ; m . map ( Shortcut . class ) ; try { data Store . ensure Indexes ( ) ; } catch ( Exception e ) { throw new Runtime Exception ( e . get Message ( ) , e ) ; } } return data Store ; }
public final void add Category ( String category ) { if ( m Categories == null ) m Categories = new Array List < String > ( ) ; if ( ! m Categories . contains ( category ) ) { m Categories . add ( category . intern ( ) ) ; } }
public final void add Category ( String category ) { if ( m Categories == null ) m Categories = new Array List < String > ( ) ; if ( ! m Categories . contains ( category ) ) { m Categories . add ( category . intern ( ) ) ; } }
public final void add Category ( String category ) { if ( m Categories == null ) m Categories = new Array List < String > ( ) ; if ( ! m Categories . contains ( category ) ) { m Categories . add ( category . intern ( ) ) ; } }
public final void add Category ( String category ) { if ( m Categories == null ) m Categories = new Array List < String > ( ) ; if ( ! m Categories . contains ( category ) ) { m Categories . add ( category . intern ( ) ) ; } }
public final void add Category ( String category ) { if ( m Categories == null ) m Categories = new Array List < String > ( ) ; if ( ! m Categories . contains ( category ) ) { m Categories . add ( category . intern ( ) ) ; } }
public final void add Category ( String category ) { if ( m Categories == null ) m Categories = new Array List < String > ( ) ; if ( ! m Categories . contains ( category ) ) { m Categories . add ( category . intern ( ) ) ; } }
public static long parse Memory Size ( String arg ) { if ( arg . ends With ( STRING ) || arg . ends With ( STRING ) ) return Long . parse Long ( arg . substring ( NUM , arg . length ( ) - NUM ) ) * NUM * NUM * NUM ; else if ( arg . ends With ( STRING ) || arg . ends With ( STRING ) ) return Long . parse Long ( arg . substring ( NUM , arg . length ( ) - NUM ) ) * NUM * NUM ; else if ( arg . ends With ( STRING ) || arg . ends With ( STRING ) ) return Long . parse Long ( arg . substring ( NUM , arg . length ( ) - NUM ) ) * NUM ; else return Long . parse Long ( arg . substring ( NUM , arg . length ( ) ) ) ; }
public void add Type Name ( String type ) { if ( type == null || type List . contains ( type ) ) { return ; } type List . add ( NUM , type ) ; log . debug ( STRING , get Name ( ) , type ) ; set Dirty And Fire Property Change ( TYPES CHANGED PROPERTY , type List . size ( ) - NUM , type List . size ( ) ) ; }
private void update Expand Info Label ( ) { if ( model . is Enlarged ( ) ) { label Stats Exp . set Icon ( Meta Data Statistics Viewer . ICON ARROW UP ) ; } else { label Stats Exp . set Icon ( Meta Data Statistics Viewer . ICON ARROW DOWN ) ; } }
public void read F Num ( ) { float f = NUM ; boolean neg = BOOL ; int exp = NUM ; int eval = NUM ; float mul = NUM ; byte work = data [ pos ++ ] ; while ( BOOL ) { if ( work == ( byte ) NUM ) { work = data [ pos ++ ] ; } int nyb = ( work > > NUM ) & NUM ; work = ( byte ) ( ( work << NUM ) | NUM ) ; if ( nyb < NUM ) { if ( exp != NUM ) { eval = eval * NUM + nyb ; } else if ( mul == NUM ) { f = f * NUM + nyb ; } else { f += nyb * mul ; mul /= NUM ; } } else if ( nyb == NUM ) { mul = NUM ; } else if ( nyb == NUM ) { exp = NUM ; } else if ( nyb == NUM ) { exp = - NUM ; } else if ( nyb == NUM ) { neg = BOOL ; } else { break ; } } fnum = ( neg ? - NUM : NUM ) * f * ( float ) Math . pow ( NUM , eval * exp ) ; }
private String Builder create Indent ( ) { String Builder one Indent = new String Builder ( ) ; one Indent . append ( STRING ) ; return one Indent ; }
private String Builder create Indent ( ) { String Builder one Indent = new String Builder ( ) ; one Indent . append ( STRING ) ; return one Indent ; }
private String Builder create Indent ( ) { String Builder one Indent = new String Builder ( ) ; one Indent . append ( STRING ) ; return one Indent ; }
public static void write Fix Int 32 ( final Output Stream output , final int val ) throws IO Exception { output . write ( ( val > > > NUM ) & NUM ) ; output . write ( ( val > > > NUM ) & NUM ) ; output . write ( ( val > > > NUM ) & NUM ) ; output . write ( val & NUM ) ; }
private static boolean verify String Param ( String str , int max Length , String acceptable Characters ) { return ! ( str == null || str . length ( ) == NUM || str . length ( ) > max Length || ! Pattern . matches ( acceptable Characters , str ) ) ; }
private static boolean verify String Param ( String str , int max Length , String acceptable Characters ) { return ! ( str == null || str . length ( ) == NUM || str . length ( ) > max Length || ! Pattern . matches ( acceptable Characters , str ) ) ; }
protected void create y axis ( int i ) { Log . e ( STRING , i + STRING ) ; float ver height = ( ( graphheight / label size ) * i ) + border ; if ( i == largest value set . size ( ) - NUM ) canvas . draw Line ( horstart , ver height , width - ( border ) , ver height , paint ) ; else canvas . draw Line ( horstart , ver height , border , ver height , paint ) ; paint . set Color ( Color . BLACK ) ; int Y labels = ( int ) size - NUM - i ; String y labels = String . format ( STRING , Y labels * y axis ratio ) ; paint . set Text Align ( Paint . Align . RIGHT ) ; canvas . draw Text ( y labels , horstart - NUM , ver height - NUM , paint ) ; paint . set Text Align ( Paint . Align . LEFT ) ; }
protected void create y axis ( int i ) { Log . e ( STRING , i + STRING ) ; float ver height = ( ( graphheight / label size ) * i ) + border ; if ( i == largest value set . size ( ) - NUM ) canvas . draw Line ( horstart , ver height , width - ( border ) , ver height , paint ) ; else canvas . draw Line ( horstart , ver height , border , ver height , paint ) ; paint . set Color ( Color . BLACK ) ; int Y labels = ( int ) size - NUM - i ; String y labels = String . format ( STRING , Y labels * y axis ratio ) ; paint . set Text Align ( Paint . Align . RIGHT ) ; canvas . draw Text ( y labels , horstart - NUM , ver height - NUM , paint ) ; paint . set Text Align ( Paint . Align . LEFT ) ; }
protected void create y axis ( int i ) { Log . e ( STRING , i + STRING ) ; float ver height = ( ( graphheight / label size ) * i ) + border ; if ( i == largest value set . size ( ) - NUM ) canvas . draw Line ( horstart , ver height , width - ( border ) , ver height , paint ) ; else canvas . draw Line ( horstart , ver height , border , ver height , paint ) ; paint . set Color ( Color . BLACK ) ; int Y labels = ( int ) size - NUM - i ; String y labels = String . format ( STRING , Y labels * y axis ratio ) ; paint . set Text Align ( Paint . Align . RIGHT ) ; canvas . draw Text ( y labels , horstart - NUM , ver height - NUM , paint ) ; paint . set Text Align ( Paint . Align . LEFT ) ; }
public View Ref Render ( View Render < T > view ) { Objects . require Non Null ( view ) ; view = view ; type = type Of ( view ) ; priority = priority Of ( view ) ; }
public View Ref Render ( View Render < T > view ) { Objects . require Non Null ( view ) ; view = view ; type = type Of ( view ) ; priority = priority Of ( view ) ; }
protected void delete Project ( String project Id ) throws IO Exception { File wsp = new File ( TARGET , WSP ) ; File project = new File ( wsp , project Id ) ; File Deleter . delete ( project . to Path ( ) ) ; }
protected void delete Project ( String project Id ) throws IO Exception { File wsp = new File ( TARGET , WSP ) ; File project = new File ( wsp , project Id ) ; File Deleter . delete ( project . to Path ( ) ) ; }
protected void delete Project ( String project Id ) throws IO Exception { File wsp = new File ( TARGET , WSP ) ; File project = new File ( wsp , project Id ) ; File Deleter . delete ( project . to Path ( ) ) ; }
protected void delete Project ( String project Id ) throws IO Exception { File wsp = new File ( TARGET , WSP ) ; File project = new File ( wsp , project Id ) ; File Deleter . delete ( project . to Path ( ) ) ; }
protected void delete Project ( String project Id ) throws IO Exception { File wsp = new File ( TARGET , WSP ) ; File project = new File ( wsp , project Id ) ; File Deleter . delete ( project . to Path ( ) ) ; }
protected void delete Project ( String project Id ) throws IO Exception { File wsp = new File ( TARGET , WSP ) ; File project = new File ( wsp , project Id ) ; File Deleter . delete ( project . to Path ( ) ) ; }
@ Override public void print Stack Trace ( ) { super . print Stack Trace ( ) ; if ( nested != null ) { nested . print Stack Trace ( ) ; } }
public int hash Code ( ) { return last Path Component . hash Code ( ) ; }
public int hash Code ( ) { return last Path Component . hash Code ( ) ; }
public boolean should Reverse ( String token ) { int pos Q = token . index Of ( STRING ) ; int pos A = token . index Of ( STRING ) ; if ( pos Q == - NUM && pos A == - NUM ) { return BOOL ; } int pos ; int last Pos ; int len = token . length ( ) ; last Pos = token . last Index Of ( STRING ) ; pos = token . last Index Of ( STRING ) ; if ( pos > last Pos ) last Pos = pos ; if ( pos Q != - NUM ) { pos = pos Q ; if ( pos A != - NUM ) { pos = Math . min ( pos Q , pos A ) ; } } else { pos = pos A ; } if ( len - last Pos < min Trailing ) { return BOOL ; } if ( pos Q != - NUM && pos Q < max Pos Question ) { return BOOL ; } if ( pos A != - NUM && pos A < max Pos Asterisk ) { return BOOL ; } if ( max Fraction Asterisk > NUM && pos < ( float ) token . length ( ) * max Fraction Asterisk ) { return BOOL ; } return BOOL ; }
public boolean should Reverse ( String token ) { int pos Q = token . index Of ( STRING ) ; int pos A = token . index Of ( STRING ) ; if ( pos Q == - NUM && pos A == - NUM ) { return BOOL ; } int pos ; int last Pos ; int len = token . length ( ) ; last Pos = token . last Index Of ( STRING ) ; pos = token . last Index Of ( STRING ) ; if ( pos > last Pos ) last Pos = pos ; if ( pos Q != - NUM ) { pos = pos Q ; if ( pos A != - NUM ) { pos = Math . min ( pos Q , pos A ) ; } } else { pos = pos A ; } if ( len - last Pos < min Trailing ) { return BOOL ; } if ( pos Q != - NUM && pos Q < max Pos Question ) { return BOOL ; } if ( pos A != - NUM && pos A < max Pos Asterisk ) { return BOOL ; } if ( max Fraction Asterisk > NUM && pos < ( float ) token . length ( ) * max Fraction Asterisk ) { return BOOL ; } return BOOL ; }
public boolean should Reverse ( String token ) { int pos Q = token . index Of ( STRING ) ; int pos A = token . index Of ( STRING ) ; if ( pos Q == - NUM && pos A == - NUM ) { return BOOL ; } int pos ; int last Pos ; int len = token . length ( ) ; last Pos = token . last Index Of ( STRING ) ; pos = token . last Index Of ( STRING ) ; if ( pos > last Pos ) last Pos = pos ; if ( pos Q != - NUM ) { pos = pos Q ; if ( pos A != - NUM ) { pos = Math . min ( pos Q , pos A ) ; } } else { pos = pos A ; } if ( len - last Pos < min Trailing ) { return BOOL ; } if ( pos Q != - NUM && pos Q < max Pos Question ) { return BOOL ; } if ( pos A != - NUM && pos A < max Pos Asterisk ) { return BOOL ; } if ( max Fraction Asterisk > NUM && pos < ( float ) token . length ( ) * max Fraction Asterisk ) { return BOOL ; } return BOOL ; }
public boolean should Reverse ( String token ) { int pos Q = token . index Of ( STRING ) ; int pos A = token . index Of ( STRING ) ; if ( pos Q == - NUM && pos A == - NUM ) { return BOOL ; } int pos ; int last Pos ; int len = token . length ( ) ; last Pos = token . last Index Of ( STRING ) ; pos = token . last Index Of ( STRING ) ; if ( pos > last Pos ) last Pos = pos ; if ( pos Q != - NUM ) { pos = pos Q ; if ( pos A != - NUM ) { pos = Math . min ( pos Q , pos A ) ; } } else { pos = pos A ; } if ( len - last Pos < min Trailing ) { return BOOL ; } if ( pos Q != - NUM && pos Q < max Pos Question ) { return BOOL ; } if ( pos A != - NUM && pos A < max Pos Asterisk ) { return BOOL ; } if ( max Fraction Asterisk > NUM && pos < ( float ) token . length ( ) * max Fraction Asterisk ) { return BOOL ; } return BOOL ; }
public boolean should Reverse ( String token ) { int pos Q = token . index Of ( STRING ) ; int pos A = token . index Of ( STRING ) ; if ( pos Q == - NUM && pos A == - NUM ) { return BOOL ; } int pos ; int last Pos ; int len = token . length ( ) ; last Pos = token . last Index Of ( STRING ) ; pos = token . last Index Of ( STRING ) ; if ( pos > last Pos ) last Pos = pos ; if ( pos Q != - NUM ) { pos = pos Q ; if ( pos A != - NUM ) { pos = Math . min ( pos Q , pos A ) ; } } else { pos = pos A ; } if ( len - last Pos < min Trailing ) { return BOOL ; } if ( pos Q != - NUM && pos Q < max Pos Question ) { return BOOL ; } if ( pos A != - NUM && pos A < max Pos Asterisk ) { return BOOL ; } if ( max Fraction Asterisk > NUM && pos < ( float ) token . length ( ) * max Fraction Asterisk ) { return BOOL ; } return BOOL ; }
public boolean should Reverse ( String token ) { int pos Q = token . index Of ( STRING ) ; int pos A = token . index Of ( STRING ) ; if ( pos Q == - NUM && pos A == - NUM ) { return BOOL ; } int pos ; int last Pos ; int len = token . length ( ) ; last Pos = token . last Index Of ( STRING ) ; pos = token . last Index Of ( STRING ) ; if ( pos > last Pos ) last Pos = pos ; if ( pos Q != - NUM ) { pos = pos Q ; if ( pos A != - NUM ) { pos = Math . min ( pos Q , pos A ) ; } } else { pos = pos A ; } if ( len - last Pos < min Trailing ) { return BOOL ; } if ( pos Q != - NUM && pos Q < max Pos Question ) { return BOOL ; } if ( pos A != - NUM && pos A < max Pos Asterisk ) { return BOOL ; } if ( max Fraction Asterisk > NUM && pos < ( float ) token . length ( ) * max Fraction Asterisk ) { return BOOL ; } return BOOL ; }
synchronized void redo ( RT Edit Text editor ) { Stack < Operation > redo Stack = get Redo Stack ( editor ) ; if ( ! redo Stack . empty ( ) ) { Stack < Operation > undo Stack = get Undo Stack ( editor ) ; Operation op = redo Stack . pop ( ) ; push ( op , undo Stack ) ; op . redo ( editor ) ; while ( ! redo Stack . empty ( ) && op . can Merge ( redo Stack . peek ( ) ) ) { op = redo Stack . pop ( ) ; push ( op , undo Stack ) ; op . redo ( editor ) ; } } }
protected void update Annotations ( Annotation existing Annotation , Position new Pos , Map additions , List modifications , List deletions ) { if ( existing Annotation instanceof Folding Annotation ) { Folding Annotation folding Annotation = ( Folding Annotation ) existing Annotation ; if ( new Pos != null && new Pos . length > NUM && projection Annotation Model != null ) { Position old Pos = projection Annotation Model . get Position ( folding Annotation ) ; if ( ! new Pos . equals ( old Pos ) ) { old Pos . set Offset ( new Pos . offset ) ; old Pos . set Length ( new Pos . length ) ; modifications . add ( folding Annotation ) ; } } else { deletions . add ( folding Annotation ) ; } } }
protected void update Annotations ( Annotation existing Annotation , Position new Pos , Map additions , List modifications , List deletions ) { if ( existing Annotation instanceof Folding Annotation ) { Folding Annotation folding Annotation = ( Folding Annotation ) existing Annotation ; if ( new Pos != null && new Pos . length > NUM && projection Annotation Model != null ) { Position old Pos = projection Annotation Model . get Position ( folding Annotation ) ; if ( ! new Pos . equals ( old Pos ) ) { old Pos . set Offset ( new Pos . offset ) ; old Pos . set Length ( new Pos . length ) ; modifications . add ( folding Annotation ) ; } } else { deletions . add ( folding Annotation ) ; } } }
public Text Editor replace All ( String regex , String replacement ) { if ( text . length ( ) > NUM ) { final String r = replacement ; Pattern p = Pattern . compile ( regex , Pattern . MULTILINE ) ; Matcher m = p . matcher ( text ) ; String Buffer sb = new String Buffer ( ) ; while ( m . find ( ) ) { m . append Replacement ( sb , r ) ; } m . append Tail ( sb ) ; text = sb ; } return this ; }
public Text Editor replace All ( String regex , String replacement ) { if ( text . length ( ) > NUM ) { final String r = replacement ; Pattern p = Pattern . compile ( regex , Pattern . MULTILINE ) ; Matcher m = p . matcher ( text ) ; String Buffer sb = new String Buffer ( ) ; while ( m . find ( ) ) { m . append Replacement ( sb , r ) ; } m . append Tail ( sb ) ; text = sb ; } return this ; }
@ Suppress Warnings ( STRING ) public static < K > Immutable Array < K > empty ( ) { return ( Immutable Array < K > ) EMPTY ; }
private static Ade Exception ade Exception Of ( Throwable t ) { if ( t instanceof Ade Exception ) { return ( Ade Exception ) t ; } else { return new Ade Internal Exception ( STRING + t . get Message ( ) + STRING , t ) ; } }
private static Ade Exception ade Exception Of ( Throwable t ) { if ( t instanceof Ade Exception ) { return ( Ade Exception ) t ; } else { return new Ade Internal Exception ( STRING + t . get Message ( ) + STRING , t ) ; } }
private static Ade Exception ade Exception Of ( Throwable t ) { if ( t instanceof Ade Exception ) { return ( Ade Exception ) t ; } else { return new Ade Internal Exception ( STRING + t . get Message ( ) + STRING , t ) ; } }
private static Ade Exception ade Exception Of ( Throwable t ) { if ( t instanceof Ade Exception ) { return ( Ade Exception ) t ; } else { return new Ade Internal Exception ( STRING + t . get Message ( ) + STRING , t ) ; } }
@ Override public int compare ( final Long o1 , final Long o2 ) { if ( o1 . long Value ( ) < o2 . long Value ( ) ) return NUM ; if ( o1 . long Value ( ) > o2 . long Value ( ) ) return - NUM ; return NUM ; }
@ Override public int compare ( final Long o1 , final Long o2 ) { if ( o1 . long Value ( ) < o2 . long Value ( ) ) return NUM ; if ( o1 . long Value ( ) > o2 . long Value ( ) ) return - NUM ; return NUM ; }
@ Override public int compare ( final Long o1 , final Long o2 ) { if ( o1 . long Value ( ) < o2 . long Value ( ) ) return NUM ; if ( o1 . long Value ( ) > o2 . long Value ( ) ) return - NUM ; return NUM ; }
public static void add Item Stack To List ( Item Stack stack ) { if ( ! has Items ( stack ) ) { stacks . add ( stack ) ; } }
public static double ceil ( double f , Ceil type ) { return Math . ceil ( f * type . mult ) / type . mult ; }
public static double ceil ( double f , Ceil type ) { return Math . ceil ( f * type . mult ) / type . mult ; }
public void pre Allocate Synapses ( int expected Num Synapses ) throws Illegal State Exception { if ( ! ex Synapse Set . is Empty ( ) || ! in Synapse Set . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING + STRING + STRING + STRING + STRING ) ; } ex Synapse Set = new Hash Set < Synapse > ( ( int ) ( expected Num Synapses * excitatory Ratio / NUM ) ) ; in Synapse Set = new Hash Set < Synapse > ( ( int ) ( expected Num Synapses * ( NUM - excitatory Ratio ) / NUM ) ) ; }
public void pre Allocate Synapses ( int expected Num Synapses ) throws Illegal State Exception { if ( ! ex Synapse Set . is Empty ( ) || ! in Synapse Set . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING + STRING + STRING + STRING + STRING ) ; } ex Synapse Set = new Hash Set < Synapse > ( ( int ) ( expected Num Synapses * excitatory Ratio / NUM ) ) ; in Synapse Set = new Hash Set < Synapse > ( ( int ) ( expected Num Synapses * ( NUM - excitatory Ratio ) / NUM ) ) ; }
public void pre Allocate Synapses ( int expected Num Synapses ) throws Illegal State Exception { if ( ! ex Synapse Set . is Empty ( ) || ! in Synapse Set . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING + STRING + STRING + STRING + STRING ) ; } ex Synapse Set = new Hash Set < Synapse > ( ( int ) ( expected Num Synapses * excitatory Ratio / NUM ) ) ; in Synapse Set = new Hash Set < Synapse > ( ( int ) ( expected Num Synapses * ( NUM - excitatory Ratio ) / NUM ) ) ; }
public void pre Allocate Synapses ( int expected Num Synapses ) throws Illegal State Exception { if ( ! ex Synapse Set . is Empty ( ) || ! in Synapse Set . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING + STRING + STRING + STRING + STRING ) ; } ex Synapse Set = new Hash Set < Synapse > ( ( int ) ( expected Num Synapses * excitatory Ratio / NUM ) ) ; in Synapse Set = new Hash Set < Synapse > ( ( int ) ( expected Num Synapses * ( NUM - excitatory Ratio ) / NUM ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
public Default Console Panel ( ) { set Layout ( new Border Layout ( NUM , NUM ) ) ; text Pane = new J Text Area ( ) ; text Pane . set Rows ( NUM ) ; text Pane . set Editable ( BOOL ) ; J Scroll Pane jp = new J Scroll Pane ( text Pane ) ; add ( jp , Border Layout . CENTER ) ; }
private void trace ( ) { gl Use Program ( compute Program ) ; gl Disable ( GL DEPTH TEST ) ; long this Time = System . nano Time ( ) ; float elapsed Seconds = ( this Time - first Time ) / NUM ; gl Uniform 1 f ( time Uniform , elapsed Seconds ) ; float blend Factor = frame Number / ( frame Number + NUM ) ; gl Uniform 1 f ( blend Factor Uniform , blend Factor ) ; gl Uniform 1 i ( bounce Count Uniform , bounce Count ) ; gl Bind Image Texture ( framebuffer Image Binding , raytrace Texture , NUM , BOOL , NUM , GL READ WRITE , GL RGBA 32 F ) ; gl Bind Image Texture ( world Position Image Binding , position Texture , NUM , BOOL , NUM , GL READ ONLY , GL RGBA 32 F ) ; gl Bind Image Texture ( world Normal Image Binding , normal Texture , NUM , BOOL , NUM , GL READ ONLY , GL RGBA 16 F ) ; int worksize X = math Round Po T ( width ) ; int worksize Y = math Round Po T ( height ) ; gl Dispatch Compute ( worksize X / work Group Size X , worksize Y / work Group Size Y , NUM ) ; gl Memory Barrier ( GL SHADER IMAGE ACCESS BARRIER BIT ) ; gl Bind Image Texture ( framebuffer Image Binding , NUM , NUM , BOOL , NUM , GL READ WRITE , GL RGBA 32 F ) ; gl Bind Image Texture ( world Position Image Binding , NUM , NUM , BOOL , NUM , GL READ ONLY , GL RGBA 32 F ) ; gl Bind Image Texture ( world Normal Image Binding , NUM , NUM , BOOL , NUM , GL READ ONLY , GL RGBA 16 F ) ; gl Use Program ( NUM ) ; frame Number ++ ; }
private void trace ( ) { gl Use Program ( compute Program ) ; gl Disable ( GL DEPTH TEST ) ; long this Time = System . nano Time ( ) ; float elapsed Seconds = ( this Time - first Time ) / NUM ; gl Uniform 1 f ( time Uniform , elapsed Seconds ) ; float blend Factor = frame Number / ( frame Number + NUM ) ; gl Uniform 1 f ( blend Factor Uniform , blend Factor ) ; gl Uniform 1 i ( bounce Count Uniform , bounce Count ) ; gl Bind Image Texture ( framebuffer Image Binding , raytrace Texture , NUM , BOOL , NUM , GL READ WRITE , GL RGBA 32 F ) ; gl Bind Image Texture ( world Position Image Binding , position Texture , NUM , BOOL , NUM , GL READ ONLY , GL RGBA 32 F ) ; gl Bind Image Texture ( world Normal Image Binding , normal Texture , NUM , BOOL , NUM , GL READ ONLY , GL RGBA 16 F ) ; int worksize X = math Round Po T ( width ) ; int worksize Y = math Round Po T ( height ) ; gl Dispatch Compute ( worksize X / work Group Size X , worksize Y / work Group Size Y , NUM ) ; gl Memory Barrier ( GL SHADER IMAGE ACCESS BARRIER BIT ) ; gl Bind Image Texture ( framebuffer Image Binding , NUM , NUM , BOOL , NUM , GL READ WRITE , GL RGBA 32 F ) ; gl Bind Image Texture ( world Position Image Binding , NUM , NUM , BOOL , NUM , GL READ ONLY , GL RGBA 32 F ) ; gl Bind Image Texture ( world Normal Image Binding , NUM , NUM , BOOL , NUM , GL READ ONLY , GL RGBA 16 F ) ; gl Use Program ( NUM ) ; frame Number ++ ; }
protected Signature ( String algorithm ) { this . algorithm = algorithm ; }
public static Process run Command ( String command , Consumer < String > stdout Consumer , Runnable error Handler , String ... args ) { return run Command ( command , null , BOOL , stdout Consumer , null , error Handler , args ) ; }
private boolean is Need To Remove ( String column Name ) { return is Removed From Class ( column Name ) && ! is Id Column ( column Name ) && ! is Foreign Key Column ( m Table Model , column Name ) ; }
private boolean is Need To Remove ( String column Name ) { return is Removed From Class ( column Name ) && ! is Id Column ( column Name ) && ! is Foreign Key Column ( m Table Model , column Name ) ; }
private boolean is Need To Remove ( String column Name ) { return is Removed From Class ( column Name ) && ! is Id Column ( column Name ) && ! is Foreign Key Column ( m Table Model , column Name ) ; }
private boolean is Need To Remove ( String column Name ) { return is Removed From Class ( column Name ) && ! is Id Column ( column Name ) && ! is Foreign Key Column ( m Table Model , column Name ) ; }
private static String remove File Name Extension ( String file Name ) { if ( file Name . last Index Of ( STRING ) == - NUM ) return file Name ; return file Name . substring ( NUM , file Name . last Index Of ( STRING ) ) ; }
private static String remove File Name Extension ( String file Name ) { if ( file Name . last Index Of ( STRING ) == - NUM ) return file Name ; return file Name . substring ( NUM , file Name . last Index Of ( STRING ) ) ; }
public Str Builder delete First ( final String str ) { final int len = ( str == null ? NUM : str . length ( ) ) ; if ( len > NUM ) { final int index = index Of ( str , NUM ) ; if ( index >= NUM ) { delete Impl ( index , index + len , len ) ; } } return this ; }
public Str Builder delete First ( final String str ) { final int len = ( str == null ? NUM : str . length ( ) ) ; if ( len > NUM ) { final int index = index Of ( str , NUM ) ; if ( index >= NUM ) { delete Impl ( index , index + len , len ) ; } } return this ; }
public Str Builder delete First ( final String str ) { final int len = ( str == null ? NUM : str . length ( ) ) ; if ( len > NUM ) { final int index = index Of ( str , NUM ) ; if ( index >= NUM ) { delete Impl ( index , index + len , len ) ; } } return this ; }
public static void write ( Id parcel ID , double free Speed Accessibility , double car Accessibility , double bike Accessibility , double walk Accessibility ) { try { assert ( Urban Sim Parcel CSV Writer . parcel Writer != null ) ; parcel Writer . write ( parcel ID + STRING + free Speed Accessibility + STRING + car Accessibility + STRING + bike Accessibility + STRING + walk Accessibility ) ; parcel Writer . new Line ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
public static Document parse ( Reader reader , boolean validating , boolean namespace Aware , boolean allow Doc Type Declaration ) throws SAX Exception , IO Exception , Parser Configuration Exception { Document Builder Factory factory = Factory Support . create Document Builder Factory ( ) ; factory . set Namespace Aware ( namespace Aware ) ; factory . set Validating ( validating ) ; set Quietly ( factory , XML Constants . FEATURE SECURE PROCESSING , BOOL ) ; set Quietly ( factory , STRING , ! allow Doc Type Declaration ) ; Document Builder document Builder = factory . new Document Builder ( ) ; return document Builder . parse ( new Input Source ( reader ) ) ; }
public static Document parse ( Reader reader , boolean validating , boolean namespace Aware , boolean allow Doc Type Declaration ) throws SAX Exception , IO Exception , Parser Configuration Exception { Document Builder Factory factory = Factory Support . create Document Builder Factory ( ) ; factory . set Namespace Aware ( namespace Aware ) ; factory . set Validating ( validating ) ; set Quietly ( factory , XML Constants . FEATURE SECURE PROCESSING , BOOL ) ; set Quietly ( factory , STRING , ! allow Doc Type Declaration ) ; Document Builder document Builder = factory . new Document Builder ( ) ; return document Builder . parse ( new Input Source ( reader ) ) ; }
public static Document parse ( Reader reader , boolean validating , boolean namespace Aware , boolean allow Doc Type Declaration ) throws SAX Exception , IO Exception , Parser Configuration Exception { Document Builder Factory factory = Factory Support . create Document Builder Factory ( ) ; factory . set Namespace Aware ( namespace Aware ) ; factory . set Validating ( validating ) ; set Quietly ( factory , XML Constants . FEATURE SECURE PROCESSING , BOOL ) ; set Quietly ( factory , STRING , ! allow Doc Type Declaration ) ; Document Builder document Builder = factory . new Document Builder ( ) ; return document Builder . parse ( new Input Source ( reader ) ) ; }
static public void add Query Params ( final String Builder url String , final Map < String , String [ ] > request Params ) throws Unsupported Encoding Exception { if ( request Params == null ) return ; boolean first = BOOL ; for ( Map . Entry < String , String [ ] > e : request Params . entry Set ( ) ) { final String name = e . get Key ( ) ; final String [ ] vals = e . get Value ( ) ; if ( vals == null ) { url String . append ( first ? STRING : STRING ) ; first = BOOL ; url String . append ( URL Encoder . encode ( name , Remote Repository . UTF 8 ) ) ; } else { for ( String val : vals ) { url String . append ( first ? STRING : STRING ) ; first = BOOL ; url String . append ( URL Encoder . encode ( name , Remote Repository . UTF 8 ) ) ; url String . append ( STRING ) ; if ( val != null ) url String . append ( URL Encoder . encode ( val , Remote Repository . UTF 8 ) ) ; } } } }
static public void add Query Params ( final String Builder url String , final Map < String , String [ ] > request Params ) throws Unsupported Encoding Exception { if ( request Params == null ) return ; boolean first = BOOL ; for ( Map . Entry < String , String [ ] > e : request Params . entry Set ( ) ) { final String name = e . get Key ( ) ; final String [ ] vals = e . get Value ( ) ; if ( vals == null ) { url String . append ( first ? STRING : STRING ) ; first = BOOL ; url String . append ( URL Encoder . encode ( name , Remote Repository . UTF 8 ) ) ; } else { for ( String val : vals ) { url String . append ( first ? STRING : STRING ) ; first = BOOL ; url String . append ( URL Encoder . encode ( name , Remote Repository . UTF 8 ) ) ; url String . append ( STRING ) ; if ( val != null ) url String . append ( URL Encoder . encode ( val , Remote Repository . UTF 8 ) ) ; } } } }
public E remove ( int index ) { range Check ( index ) ; mod Count ++ ; E old Value = element Data ( index ) ; int num Moved = size - index - NUM ; if ( num Moved > NUM ) System . arraycopy ( element Data , index + NUM , element Data , index , num Moved ) ; element Data [ -- size ] = null ; return old Value ; }
public E remove ( int index ) { range Check ( index ) ; mod Count ++ ; E old Value = element Data ( index ) ; int num Moved = size - index - NUM ; if ( num Moved > NUM ) System . arraycopy ( element Data , index + NUM , element Data , index , num Moved ) ; element Data [ -- size ] = null ; return old Value ; }
public E remove ( int index ) { range Check ( index ) ; mod Count ++ ; E old Value = element Data ( index ) ; int num Moved = size - index - NUM ; if ( num Moved > NUM ) System . arraycopy ( element Data , index + NUM , element Data , index , num Moved ) ; element Data [ -- size ] = null ; return old Value ; }
void add Option ( Option opt ) { options . add ( opt ) ; }
protected static void add Volume ( List < Block Object Rest Rep > block Objects , Volume Rest Rep volume , List < Block Snapshot Rest Rep > snapshots ) { block Objects . add ( volume ) ; if ( Collection Utils . is Not Empty ( snapshots ) ) { Iterator < Block Snapshot Rest Rep > snapshot Iter = snapshots . iterator ( ) ; while ( snapshot Iter . has Next ( ) ) { Block Snapshot Rest Rep snap = snapshot Iter . next ( ) ; if ( Resource Utils . id Equals ( snap . get Parent ( ) , volume ) ) { block Objects . add ( snap ) ; snapshot Iter . remove ( ) ; } } } }
protected static void add Volume ( List < Block Object Rest Rep > block Objects , Volume Rest Rep volume , List < Block Snapshot Rest Rep > snapshots ) { block Objects . add ( volume ) ; if ( Collection Utils . is Not Empty ( snapshots ) ) { Iterator < Block Snapshot Rest Rep > snapshot Iter = snapshots . iterator ( ) ; while ( snapshot Iter . has Next ( ) ) { Block Snapshot Rest Rep snap = snapshot Iter . next ( ) ; if ( Resource Utils . id Equals ( snap . get Parent ( ) , volume ) ) { block Objects . add ( snap ) ; snapshot Iter . remove ( ) ; } } } }
private static void cache Factory ( Class Loader class Loader , Log Factory factory ) { if ( factory != null ) { if ( class Loader == null ) { null Class Loader Factory = factory ; } else { factories . put ( class Loader , factory ) ; } } }
private static void cache Factory ( Class Loader class Loader , Log Factory factory ) { if ( factory != null ) { if ( class Loader == null ) { null Class Loader Factory = factory ; } else { factories . put ( class Loader , factory ) ; } } }
private static void cache Factory ( Class Loader class Loader , Log Factory factory ) { if ( factory != null ) { if ( class Loader == null ) { null Class Loader Factory = factory ; } else { factories . put ( class Loader , factory ) ; } } }
private static void cache Factory ( Class Loader class Loader , Log Factory factory ) { if ( factory != null ) { if ( class Loader == null ) { null Class Loader Factory = factory ; } else { factories . put ( class Loader , factory ) ; } } }
private static void cache Factory ( Class Loader class Loader , Log Factory factory ) { if ( factory != null ) { if ( class Loader == null ) { null Class Loader Factory = factory ; } else { factories . put ( class Loader , factory ) ; } } }
public static boolean serialize Spec To File ( Security Spec Model spec , String android Project Root Path ) { boolean saved = BOOL ; String file Name = android Project Root Path + File . separator + Project . OUTPUT DIR + File . separator + SECURITY SPEC SERIAL FILE NAME ; try { Object Output Stream oos = new Object Output Stream ( new Buffered Output Stream ( new File Output Stream ( file Name ) ) ) ; try { oos . write Object ( spec ) ; saved = BOOL ; } finally { oos . close ( ) ; } } catch ( Exception ex ) { ex . print Stack Trace ( ) ; } return saved ; }
public void manage ( Subscription subscription ) { m Subscriptions . add ( subscription ) ; }
public void print Last Seen Info ( String message ID ) { if ( m verbose ) { logger . info ( message ID + STRING + m deltas In Seconds . to String ( ) ) ; } }
private void add To Scene ( final Node items ) { collection . add ( items ) ; }
private void add To Scene ( final Node items ) { collection . add ( items ) ; }
public static Graph Request new Upload Video Request ( Access Token access Token , File file , Callback callback ) throws File Not Found Exception { Parcel File Descriptor descriptor = Parcel File Descriptor . open ( file , Parcel File Descriptor . MODE READ ONLY ) ; Bundle parameters = new Bundle ( NUM ) ; parameters . put Parcelable ( file . get Name ( ) , descriptor ) ; return new Graph Request ( access Token , MY VIDEOS , parameters , Http Method . POST , callback ) ; }
public static Graph Request new Upload Video Request ( Access Token access Token , File file , Callback callback ) throws File Not Found Exception { Parcel File Descriptor descriptor = Parcel File Descriptor . open ( file , Parcel File Descriptor . MODE READ ONLY ) ; Bundle parameters = new Bundle ( NUM ) ; parameters . put Parcelable ( file . get Name ( ) , descriptor ) ; return new Graph Request ( access Token , MY VIDEOS , parameters , Http Method . POST , callback ) ; }
public static Graph Request new Upload Video Request ( Access Token access Token , File file , Callback callback ) throws File Not Found Exception { Parcel File Descriptor descriptor = Parcel File Descriptor . open ( file , Parcel File Descriptor . MODE READ ONLY ) ; Bundle parameters = new Bundle ( NUM ) ; parameters . put Parcelable ( file . get Name ( ) , descriptor ) ; return new Graph Request ( access Token , MY VIDEOS , parameters , Http Method . POST , callback ) ; }
public static Graph Request new Upload Video Request ( Access Token access Token , File file , Callback callback ) throws File Not Found Exception { Parcel File Descriptor descriptor = Parcel File Descriptor . open ( file , Parcel File Descriptor . MODE READ ONLY ) ; Bundle parameters = new Bundle ( NUM ) ; parameters . put Parcelable ( file . get Name ( ) , descriptor ) ; return new Graph Request ( access Token , MY VIDEOS , parameters , Http Method . POST , callback ) ; }
public static Graph Request new Upload Video Request ( Access Token access Token , File file , Callback callback ) throws File Not Found Exception { Parcel File Descriptor descriptor = Parcel File Descriptor . open ( file , Parcel File Descriptor . MODE READ ONLY ) ; Bundle parameters = new Bundle ( NUM ) ; parameters . put Parcelable ( file . get Name ( ) , descriptor ) ; return new Graph Request ( access Token , MY VIDEOS , parameters , Http Method . POST , callback ) ; }
public static Graph Request new Upload Video Request ( Access Token access Token , File file , Callback callback ) throws File Not Found Exception { Parcel File Descriptor descriptor = Parcel File Descriptor . open ( file , Parcel File Descriptor . MODE READ ONLY ) ; Bundle parameters = new Bundle ( NUM ) ; parameters . put Parcelable ( file . get Name ( ) , descriptor ) ; return new Graph Request ( access Token , MY VIDEOS , parameters , Http Method . POST , callback ) ; }
private Map < String , Integer > find Language Fallbacks ( final Service Params params ) { List < Term Node > param Nodes = params . get ( LANGUAGE PARAM ) ; if ( param Nodes . size ( ) < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } Map < String , Integer > fallbacks Map = new Hash Map < > ( ) ; int cnt = NUM ; for ( Term Node term : param Nodes ) { if ( term . is Variable ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } final Value v = term . get Value ( ) ; if ( ! ( v instanceof Literal ) ) { throw new Illegal Argument Exception ( STRING ) ; } final String s = v . string Value ( ) ; if ( s . contains ( STRING ) ) { for ( String ls : s . split ( STRING ) ) { fallbacks Map . put ( ls . trim ( ) , cnt ) ; ++ cnt ; } } else { fallbacks Map . put ( s . trim ( ) , cnt ) ; } ++ cnt ; } return fallbacks Map ; }
private Map < String , Integer > find Language Fallbacks ( final Service Params params ) { List < Term Node > param Nodes = params . get ( LANGUAGE PARAM ) ; if ( param Nodes . size ( ) < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } Map < String , Integer > fallbacks Map = new Hash Map < > ( ) ; int cnt = NUM ; for ( Term Node term : param Nodes ) { if ( term . is Variable ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } final Value v = term . get Value ( ) ; if ( ! ( v instanceof Literal ) ) { throw new Illegal Argument Exception ( STRING ) ; } final String s = v . string Value ( ) ; if ( s . contains ( STRING ) ) { for ( String ls : s . split ( STRING ) ) { fallbacks Map . put ( ls . trim ( ) , cnt ) ; ++ cnt ; } } else { fallbacks Map . put ( s . trim ( ) , cnt ) ; } ++ cnt ; } return fallbacks Map ; }
private Map < String , Integer > find Language Fallbacks ( final Service Params params ) { List < Term Node > param Nodes = params . get ( LANGUAGE PARAM ) ; if ( param Nodes . size ( ) < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } Map < String , Integer > fallbacks Map = new Hash Map < > ( ) ; int cnt = NUM ; for ( Term Node term : param Nodes ) { if ( term . is Variable ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } final Value v = term . get Value ( ) ; if ( ! ( v instanceof Literal ) ) { throw new Illegal Argument Exception ( STRING ) ; } final String s = v . string Value ( ) ; if ( s . contains ( STRING ) ) { for ( String ls : s . split ( STRING ) ) { fallbacks Map . put ( ls . trim ( ) , cnt ) ; ++ cnt ; } } else { fallbacks Map . put ( s . trim ( ) , cnt ) ; } ++ cnt ; } return fallbacks Map ; }
private void recompute Seperation ( double [ ] [ ] means , double [ ] sep ) { final int k = means . length ; assert ( sep . length == k ) ; boolean issquared = ( distance Function instanceof Squared Euclidean Distance Function ) ; Arrays . fill ( sep , Double . POSITIVE INFINITY ) ; for ( int i = NUM ; i < k ; i ++ ) { Double Vector m1 = Double Vector . wrap ( means [ i ] ) ; for ( int j = NUM ; j < i ; j ++ ) { double d = distance Function . distance ( m1 , Double Vector . wrap ( means [ j ] ) ) ; sep [ i ] = ( d < sep [ i ] ) ? d : sep [ i ] ; sep [ j ] = ( d < sep [ j ] ) ? d : sep [ j ] ; } } for ( int i = NUM ; i < k ; i ++ ) { sep [ i ] = issquared ? Math . sqrt ( sep [ i ] ) : sep [ i ] ; sep [ i ] *= NUM ; } }
protected final void add Impl ( Component comp , Object constraints , int index ) { synchronized ( get Tree Lock ( ) ) { if ( get Component Count ( ) > NUM ) { remove ( NUM ) ; } if ( index > NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( ! Sun Toolkit . is Lightweight Or Unknown ( comp ) ) { super . add Impl ( comp , constraints , index ) ; } else { add To Panel ( comp , constraints , index ) ; } } }
protected final void add Impl ( Component comp , Object constraints , int index ) { synchronized ( get Tree Lock ( ) ) { if ( get Component Count ( ) > NUM ) { remove ( NUM ) ; } if ( index > NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( ! Sun Toolkit . is Lightweight Or Unknown ( comp ) ) { super . add Impl ( comp , constraints , index ) ; } else { add To Panel ( comp , constraints , index ) ; } } }
protected final void add Impl ( Component comp , Object constraints , int index ) { synchronized ( get Tree Lock ( ) ) { if ( get Component Count ( ) > NUM ) { remove ( NUM ) ; } if ( index > NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( ! Sun Toolkit . is Lightweight Or Unknown ( comp ) ) { super . add Impl ( comp , constraints , index ) ; } else { add To Panel ( comp , constraints , index ) ; } } }
public X Trace Report put ( Object key , Object value ) { if ( key != null ) { builder . add Key ( key . to String ( ) ) ; builder . add Value ( value == null ? STRING : value . to String ( ) ) ; } return this ; }
public static Text Line standard Create Text Line ( Font Render Context frc , Attributed Character Iterator text , char [ ] chars , float [ ] baseline Offsets ) { Styled Paragraph styled Paragraph = new Styled Paragraph ( text , chars ) ; Bidi bidi = new Bidi ( text ) ; if ( bidi . is Left To Right ( ) ) { bidi = null ; } int layout Flags = NUM ; Text Label Factory factory = new Text Label Factory ( frc , chars , bidi , layout Flags ) ; boolean is Direction LTR = BOOL ; if ( bidi != null ) { is Direction LTR = bidi . base Is Left To Right ( ) ; } return create Line From Text ( chars , styled Paragraph , factory , is Direction LTR , baseline Offsets ) ; }
public static double calculate Analytical Log Likelihood ( Interval List intervals ) { if ( ! intervals . is Coalescent Only ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } final double lambda = get Lambda ( intervals ) ; final int n = intervals . get Sample Count ( ) ; return ( NUM - n ) * Math . log ( lambda ) ; }
public static double calculate Analytical Log Likelihood ( Interval List intervals ) { if ( ! intervals . is Coalescent Only ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } final double lambda = get Lambda ( intervals ) ; final int n = intervals . get Sample Count ( ) ; return ( NUM - n ) * Math . log ( lambda ) ; }
public static double calculate Analytical Log Likelihood ( Interval List intervals ) { if ( ! intervals . is Coalescent Only ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } final double lambda = get Lambda ( intervals ) ; final int n = intervals . get Sample Count ( ) ; return ( NUM - n ) * Math . log ( lambda ) ; }
public boolean add via padstack ( Lib Padstack p padstack ) { if ( p padstack == null ) return BOOL ; if ( get via padstack ( p padstack . pads name ) != null ) return BOOL ; via padstacks . add ( p padstack ) ; return BOOL ; }
public byte [ ] encode Frame ( ) { int length = this . payload . length + frame Length Overhead ; if ( this . payload . length > NUM ) { length += NUM ; } else if ( this . payload . length >= NUM ) { length += NUM ; } Byte Buffer buffer = Byte Buffer . allocate ( length ) ; append Fin And Op Code ( buffer , this . opcode , this . fin ) ; byte mask [ ] = generate Masking Key ( ) ; append Length And Mask ( buffer , this . payload . length , mask ) ; for ( int i = NUM ; i < this . payload . length ; i ++ ) { buffer . put ( ( byte ) ( this . payload [ i ] ^= mask [ i % NUM ] ) ) ; } buffer . flip ( ) ; return buffer . array ( ) ; }
private Type Constraint combine ( Type Bound bound I , Type Bound bound J ) { switch ( bound I . variance ) { case INV : switch ( bound J . variance ) { case INV : return combine Inv Inv ( bound I , bound J ) ; case CO : case CONTRA : return combine Inv Var ( bound I , bound J ) ; } break ; case CO : switch ( bound J . variance ) { case INV : return combine Inv Var ( bound J , bound I ) ; case CONTRA : return combine Contra Co ( bound J , bound I ) ; case CO : return combine Both Co Or Both Contra ( bound I , bound J ) ; } break ; case CONTRA : switch ( bound J . variance ) { case INV : return combine Inv Var ( bound J , bound I ) ; case CO : return combine Contra Co ( bound I , bound J ) ; case CONTRA : return combine Both Co Or Both Contra ( bound I , bound J ) ; } } throw new Illegal State Exception ( STRING ) ; }
private Type Constraint combine ( Type Bound bound I , Type Bound bound J ) { switch ( bound I . variance ) { case INV : switch ( bound J . variance ) { case INV : return combine Inv Inv ( bound I , bound J ) ; case CO : case CONTRA : return combine Inv Var ( bound I , bound J ) ; } break ; case CO : switch ( bound J . variance ) { case INV : return combine Inv Var ( bound J , bound I ) ; case CONTRA : return combine Contra Co ( bound J , bound I ) ; case CO : return combine Both Co Or Both Contra ( bound I , bound J ) ; } break ; case CONTRA : switch ( bound J . variance ) { case INV : return combine Inv Var ( bound J , bound I ) ; case CO : return combine Contra Co ( bound I , bound J ) ; case CONTRA : return combine Both Co Or Both Contra ( bound I , bound J ) ; } } throw new Illegal State Exception ( STRING ) ; }
public void shutdown ( ) { Executor Service executor = Executors . new Scheduled Thread Pool ( NUM ) ; executor . submit ( create Shutdown ( NUM ) ) ; }
protected void handle Bouncing ( Mail mail ) throws Messaging Exception { mail . set State ( Mail . ERROR ) ; set Message Deleted ( ) ; mail . set Error Message ( STRING + get Fetch Task Name ( ) + STRING ) ; log Status Error ( STRING ) ; }
protected void handle Bouncing ( Mail mail ) throws Messaging Exception { mail . set State ( Mail . ERROR ) ; set Message Deleted ( ) ; mail . set Error Message ( STRING + get Fetch Task Name ( ) + STRING ) ; log Status Error ( STRING ) ; }
public void remove Column ( Column column ) { if ( column != null ) { columns . remove ( column ) ; } }
public static void init Keys ( Key Store keystore , Properties props ) { if ( props . contains Key ( Configuration . WEBCALL KAFKA AES ) ) { byte [ ] key = keystore . decode Key ( props . get Property ( Configuration . WEBCALL KAFKA AES ) ) ; Preconditions . check Argument ( ( NUM == key . length || NUM == key . length || NUM == key . length ) , Configuration . WEBCALL KAFKA AES + STRING ) ; keystore . set Key ( Key Store . AES KAFKA WEBCALL , key ) ; aes Key = key ; } if ( props . contains Key ( Configuration . WEBCALL KAFKA MAC ) ) { byte [ ] key = keystore . decode Key ( props . get Property ( Configuration . WEBCALL KAFKA MAC ) ) ; Preconditions . check Argument ( ( NUM == key . length ) , Configuration . WEBCALL KAFKA MAC + STRING ) ; keystore . set Key ( Key Store . SIPHASH KAFKA WEBCALL , key ) ; siphash Key = key ; } }
private int assert Pivot Counts Are Correct ( String pivot Name , Solr Params base Params , Pivot Field constraint ) throws Solr Server Exception { Solr Params p = Solr Params . wrap Appended ( base Params , params ( STRING , build Filter ( constraint ) ) ) ; List < Pivot Field > sub Pivots = null ; try { assert Num Found ( pivot Name , constraint . get Count ( ) , p ) ; sub Pivots = constraint . get Pivot ( ) ; } catch ( Exception e ) { throw new Runtime Exception ( pivot Name + STRING + p + STRING + e . get Message ( ) , e ) ; } int depth = NUM ; if ( null != sub Pivots ) { assert Trace Ok ( pivot Name , base Params , sub Pivots ) ; for ( Pivot Field sub Pivot : sub Pivots ) { depth = assert Pivot Counts Are Correct ( pivot Name , p , sub Pivot ) ; } } return depth + NUM ; }
private int assert Pivot Counts Are Correct ( String pivot Name , Solr Params base Params , Pivot Field constraint ) throws Solr Server Exception { Solr Params p = Solr Params . wrap Appended ( base Params , params ( STRING , build Filter ( constraint ) ) ) ; List < Pivot Field > sub Pivots = null ; try { assert Num Found ( pivot Name , constraint . get Count ( ) , p ) ; sub Pivots = constraint . get Pivot ( ) ; } catch ( Exception e ) { throw new Runtime Exception ( pivot Name + STRING + p + STRING + e . get Message ( ) , e ) ; } int depth = NUM ; if ( null != sub Pivots ) { assert Trace Ok ( pivot Name , base Params , sub Pivots ) ; for ( Pivot Field sub Pivot : sub Pivots ) { depth = assert Pivot Counts Are Correct ( pivot Name , p , sub Pivot ) ; } } return depth + NUM ; }
private int assert Pivot Counts Are Correct ( String pivot Name , Solr Params base Params , Pivot Field constraint ) throws Solr Server Exception { Solr Params p = Solr Params . wrap Appended ( base Params , params ( STRING , build Filter ( constraint ) ) ) ; List < Pivot Field > sub Pivots = null ; try { assert Num Found ( pivot Name , constraint . get Count ( ) , p ) ; sub Pivots = constraint . get Pivot ( ) ; } catch ( Exception e ) { throw new Runtime Exception ( pivot Name + STRING + p + STRING + e . get Message ( ) , e ) ; } int depth = NUM ; if ( null != sub Pivots ) { assert Trace Ok ( pivot Name , base Params , sub Pivots ) ; for ( Pivot Field sub Pivot : sub Pivots ) { depth = assert Pivot Counts Are Correct ( pivot Name , p , sub Pivot ) ; } } return depth + NUM ; }
private double calculate Bar Thickness ( Rectangle 2 D plot Area , Rectangle Edge edge ) { double result ; if ( Rectangle Edge . is Left Or Right ( edge ) ) { result = plot Area . get Width ( ) * this . color Bar Thickness Percent ; } else { result = plot Area . get Height ( ) * this . color Bar Thickness Percent ; } return result ; }
public static Plane construct Normalized Z Plane ( final double x , final double y ) { if ( Math . abs ( x ) < MINIMUM RESOLUTION && Math . abs ( y ) < MINIMUM RESOLUTION ) return null ; final double denom = NUM / Math . sqrt ( x * x + y * y ) ; return new Plane ( y * denom , - x * denom , NUM , NUM ) ; }
public synchronized void notify Disconnected ( String title ) { connected Server Titles . remove ( title ) ; update Notification ( get String ( R . string . notification disconnected , title ) , null , BOOL , BOOL , BOOL ) ; }
public synchronized void notify Disconnected ( String title ) { connected Server Titles . remove ( title ) ; update Notification ( get String ( R . string . notification disconnected , title ) , null , BOOL , BOOL , BOOL ) ; }
private void append Buffer ( String Builder buffer , String name , String value ) { if ( buffer . length ( ) > NUM ) { buffer . append ( STRING ) ; } String encoded Name = URL Encoder . encode ( name ) ; buffer . append ( encoded Name ) ; buffer . append ( STRING ) ; String encoded Value = URL Encoder . encode ( value ) ; buffer . append ( encoded Value ) ; }
private void append Buffer ( String Builder buffer , String name , String value ) { if ( buffer . length ( ) > NUM ) { buffer . append ( STRING ) ; } String encoded Name = URL Encoder . encode ( name ) ; buffer . append ( encoded Name ) ; buffer . append ( STRING ) ; String encoded Value = URL Encoder . encode ( value ) ; buffer . append ( encoded Value ) ; }
public static JSON Object read JSON Object ( final JSON Object json Object , final String key , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return json Object . get JSON Object ( key ) ; } if ( not Null && json Object . is Null ( key ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT OBJECT , key ) ) ; } JSON Object value = null ; if ( ! json Object . is Null ( key ) ) { value = json Object . get JSON Object ( key ) ; } return value ; }
public void obtain ( ) throws IO Exception { if ( file Lock != null && file Lock . is Valid ( ) ) { return ; } file Lock = file To Lock . lock ( ) ; }
public void dump stack ( ) { if ( stack == null ) { debug message ( STRING ) ; return ; } debug message ( STRING ) ; for ( int i = NUM ; i < stack . size ( ) ; i ++ ) { debug message ( STRING + ( ( Symbol ) stack . element At ( i ) ) . sym + STRING + ( ( Symbol ) stack . element At ( i ) ) . parse state ) ; } debug message ( STRING ) ; }
public void dump stack ( ) { if ( stack == null ) { debug message ( STRING ) ; return ; } debug message ( STRING ) ; for ( int i = NUM ; i < stack . size ( ) ; i ++ ) { debug message ( STRING + ( ( Symbol ) stack . element At ( i ) ) . sym + STRING + ( ( Symbol ) stack . element At ( i ) ) . parse state ) ; } debug message ( STRING ) ; }
public void add Default Value ( String value ) throws SMS Exception , SSO Exception { Set default Values = get Default Values ( ) ; if ( default Values != Collections . EMPTY SET ) { default Values . add ( value ) ; } else { default Values = new Hash Set ( ) ; default Values . add ( value ) ; } update Default Values ( default Values ) ; }
public void expand To Object And Select ( Object element Or Tree Path , int level ) { if ( check Busy ( ) ) { return ; } Object parent = get Parent Element ( element Or Tree Path ) ; if ( ( ( parent != null ) && get Expanded State ( parent ) ) || is Root Element ( element Or Tree Path ) ) { Widget w = internal Get Widget To Select ( element Or Tree Path ) ; if ( null != w ) { List < Object > selection List = new Array List < > ( ) ; selection List . add ( w ) ; set Selection ( selection List ) ; object To Select . set ( null ) ; } else { object To Select . set ( element Or Tree Path ) ; } } else { object To Select . set ( element Or Tree Path ) ; List < Object > objects To Expand = create Object List ( parent , new Array List < > ( ) ) ; if ( ! objects To Expand . is Empty ( ) ) { objects To Be Expanded . add All ( objects To Expand ) ; Widget w = internal Expand ( element Or Tree Path , BOOL ) ; if ( w != null ) { internal Expand To Level ( w , level ) ; } } else { Widget w = internal Get Widget To Select ( element Or Tree Path ) ; if ( null != w ) { List < Object > selection List = new Array List < > ( ) ; selection List . add ( w ) ; set Selection ( selection List ) ; object To Select . set ( null ) ; } } } }
public void expand To Object And Select ( Object element Or Tree Path , int level ) { if ( check Busy ( ) ) { return ; } Object parent = get Parent Element ( element Or Tree Path ) ; if ( ( ( parent != null ) && get Expanded State ( parent ) ) || is Root Element ( element Or Tree Path ) ) { Widget w = internal Get Widget To Select ( element Or Tree Path ) ; if ( null != w ) { List < Object > selection List = new Array List < > ( ) ; selection List . add ( w ) ; set Selection ( selection List ) ; object To Select . set ( null ) ; } else { object To Select . set ( element Or Tree Path ) ; } } else { object To Select . set ( element Or Tree Path ) ; List < Object > objects To Expand = create Object List ( parent , new Array List < > ( ) ) ; if ( ! objects To Expand . is Empty ( ) ) { objects To Be Expanded . add All ( objects To Expand ) ; Widget w = internal Expand ( element Or Tree Path , BOOL ) ; if ( w != null ) { internal Expand To Level ( w , level ) ; } } else { Widget w = internal Get Widget To Select ( element Or Tree Path ) ; if ( null != w ) { List < Object > selection List = new Array List < > ( ) ; selection List . add ( w ) ; set Selection ( selection List ) ; object To Select . set ( null ) ; } } } }
public void expand To Object And Select ( Object element Or Tree Path , int level ) { if ( check Busy ( ) ) { return ; } Object parent = get Parent Element ( element Or Tree Path ) ; if ( ( ( parent != null ) && get Expanded State ( parent ) ) || is Root Element ( element Or Tree Path ) ) { Widget w = internal Get Widget To Select ( element Or Tree Path ) ; if ( null != w ) { List < Object > selection List = new Array List < > ( ) ; selection List . add ( w ) ; set Selection ( selection List ) ; object To Select . set ( null ) ; } else { object To Select . set ( element Or Tree Path ) ; } } else { object To Select . set ( element Or Tree Path ) ; List < Object > objects To Expand = create Object List ( parent , new Array List < > ( ) ) ; if ( ! objects To Expand . is Empty ( ) ) { objects To Be Expanded . add All ( objects To Expand ) ; Widget w = internal Expand ( element Or Tree Path , BOOL ) ; if ( w != null ) { internal Expand To Level ( w , level ) ; } } else { Widget w = internal Get Widget To Select ( element Or Tree Path ) ; if ( null != w ) { List < Object > selection List = new Array List < > ( ) ; selection List . add ( w ) ; set Selection ( selection List ) ; object To Select . set ( null ) ; } } } }
public void expand To Object And Select ( Object element Or Tree Path , int level ) { if ( check Busy ( ) ) { return ; } Object parent = get Parent Element ( element Or Tree Path ) ; if ( ( ( parent != null ) && get Expanded State ( parent ) ) || is Root Element ( element Or Tree Path ) ) { Widget w = internal Get Widget To Select ( element Or Tree Path ) ; if ( null != w ) { List < Object > selection List = new Array List < > ( ) ; selection List . add ( w ) ; set Selection ( selection List ) ; object To Select . set ( null ) ; } else { object To Select . set ( element Or Tree Path ) ; } } else { object To Select . set ( element Or Tree Path ) ; List < Object > objects To Expand = create Object List ( parent , new Array List < > ( ) ) ; if ( ! objects To Expand . is Empty ( ) ) { objects To Be Expanded . add All ( objects To Expand ) ; Widget w = internal Expand ( element Or Tree Path , BOOL ) ; if ( w != null ) { internal Expand To Level ( w , level ) ; } } else { Widget w = internal Get Widget To Select ( element Or Tree Path ) ; if ( null != w ) { List < Object > selection List = new Array List < > ( ) ; selection List . add ( w ) ; set Selection ( selection List ) ; object To Select . set ( null ) ; } } } }
public void expand To Object And Select ( Object element Or Tree Path , int level ) { if ( check Busy ( ) ) { return ; } Object parent = get Parent Element ( element Or Tree Path ) ; if ( ( ( parent != null ) && get Expanded State ( parent ) ) || is Root Element ( element Or Tree Path ) ) { Widget w = internal Get Widget To Select ( element Or Tree Path ) ; if ( null != w ) { List < Object > selection List = new Array List < > ( ) ; selection List . add ( w ) ; set Selection ( selection List ) ; object To Select . set ( null ) ; } else { object To Select . set ( element Or Tree Path ) ; } } else { object To Select . set ( element Or Tree Path ) ; List < Object > objects To Expand = create Object List ( parent , new Array List < > ( ) ) ; if ( ! objects To Expand . is Empty ( ) ) { objects To Be Expanded . add All ( objects To Expand ) ; Widget w = internal Expand ( element Or Tree Path , BOOL ) ; if ( w != null ) { internal Expand To Level ( w , level ) ; } } else { Widget w = internal Get Widget To Select ( element Or Tree Path ) ; if ( null != w ) { List < Object > selection List = new Array List < > ( ) ; selection List . add ( w ) ; set Selection ( selection List ) ; object To Select . set ( null ) ; } } } }
private void interrupt Idle Workers ( boolean only One ) { final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { for ( Worker w : workers ) { Thread t = w . thread ; if ( ! t . is Interrupted ( ) && w . try Lock ( ) ) { try { t . interrupt ( ) ; } catch ( Security Exception ignore ) { } finally { w . unlock ( ) ; } } if ( only One ) break ; } } finally { main Lock . unlock ( ) ; } }
private void interrupt Idle Workers ( boolean only One ) { final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { for ( Worker w : workers ) { Thread t = w . thread ; if ( ! t . is Interrupted ( ) && w . try Lock ( ) ) { try { t . interrupt ( ) ; } catch ( Security Exception ignore ) { } finally { w . unlock ( ) ; } } if ( only One ) break ; } } finally { main Lock . unlock ( ) ; } }
public Search Source Builder field Data Field ( String name ) { if ( field Data Fields == null ) { field Data Fields = new Array List < > ( ) ; } field Data Fields . add ( name ) ; return this ; }
public Search Source Builder field Data Field ( String name ) { if ( field Data Fields == null ) { field Data Fields = new Array List < > ( ) ; } field Data Fields . add ( name ) ; return this ; }
private void remove Ignore ( RP Object ignore Obj ) { for ( String attr : ignore Obj ) { if ( attr . char At ( NUM ) == STRING ) { ignore . remove ( attr . substring ( NUM ) ) ; } } }
private void remove Ignore ( RP Object ignore Obj ) { for ( String attr : ignore Obj ) { if ( attr . char At ( NUM ) == STRING ) { ignore . remove ( attr . substring ( NUM ) ) ; } } }
public static Kernel create Kernel ( int kernel Type ) { switch ( kernel Type ) { case KERNEL RADIAL : return new Kernel Radial ( ) ; case KERNEL POLYNOMIAL : return new Kernel Polynomial ( ) ; case KERNEL NEURAL : return new Kernel Neural ( ) ; default : return new Kernel Dot ( ) ; } }
public boolean loopback ( ) { try { return my Multicast Socket . get Loopback Mode ( ) ; } catch ( Socket Exception se ) { Logger . print Error ( STRING , STRING + se ) ; } return BOOL ; }
private void oops ( String what , int lineno , int override , Throwable t ) throws Configuration Exception { Error Descriptor error = new Error Descriptor ( lineno , override , what , location , t ) ; throw Configuration Exception ( new Configuration Exception ( error . to String ( ) , t ) , Collections . singleton List ( error ) ) ; throw new Assertion Error ( STRING + STRING ) ; }
private void adjust For Top Fading Edge ( View child In Selected Row , int top Selection Pixel , int bottom Selection Pixel ) { if ( child In Selected Row . get Top ( ) < top Selection Pixel ) { int space Above = top Selection Pixel - child In Selected Row . get Top ( ) ; int space Below = bottom Selection Pixel - child In Selected Row . get Bottom ( ) ; int offset = Math . min ( space Above , space Below ) ; offset Children Top And Bottom ( offset ) ; } }
private void adjust For Top Fading Edge ( View child In Selected Row , int top Selection Pixel , int bottom Selection Pixel ) { if ( child In Selected Row . get Top ( ) < top Selection Pixel ) { int space Above = top Selection Pixel - child In Selected Row . get Top ( ) ; int space Below = bottom Selection Pixel - child In Selected Row . get Bottom ( ) ; int offset = Math . min ( space Above , space Below ) ; offset Children Top And Bottom ( offset ) ; } }
private void adjust For Top Fading Edge ( View child In Selected Row , int top Selection Pixel , int bottom Selection Pixel ) { if ( child In Selected Row . get Top ( ) < top Selection Pixel ) { int space Above = top Selection Pixel - child In Selected Row . get Top ( ) ; int space Below = bottom Selection Pixel - child In Selected Row . get Bottom ( ) ; int offset = Math . min ( space Above , space Below ) ; offset Children Top And Bottom ( offset ) ; } }
private void adjust For Top Fading Edge ( View child In Selected Row , int top Selection Pixel , int bottom Selection Pixel ) { if ( child In Selected Row . get Top ( ) < top Selection Pixel ) { int space Above = top Selection Pixel - child In Selected Row . get Top ( ) ; int space Below = bottom Selection Pixel - child In Selected Row . get Bottom ( ) ; int offset = Math . min ( space Above , space Below ) ; offset Children Top And Bottom ( offset ) ; } }
private void adjust For Top Fading Edge ( View child In Selected Row , int top Selection Pixel , int bottom Selection Pixel ) { if ( child In Selected Row . get Top ( ) < top Selection Pixel ) { int space Above = top Selection Pixel - child In Selected Row . get Top ( ) ; int space Below = bottom Selection Pixel - child In Selected Row . get Bottom ( ) ; int offset = Math . min ( space Above , space Below ) ; offset Children Top And Bottom ( offset ) ; } }
private void adjust For Top Fading Edge ( View child In Selected Row , int top Selection Pixel , int bottom Selection Pixel ) { if ( child In Selected Row . get Top ( ) < top Selection Pixel ) { int space Above = top Selection Pixel - child In Selected Row . get Top ( ) ; int space Below = bottom Selection Pixel - child In Selected Row . get Bottom ( ) ; int offset = Math . min ( space Above , space Below ) ; offset Children Top And Bottom ( offset ) ; } }
public boolean is Opaque Cube ( I Block State state ) { return BOOL ; }
public boolean is Opaque Cube ( I Block State state ) { return BOOL ; }
private final void populate Name List ( final Argument arg , final List < Object > name List ) { List < Object > value Obj List = ( List < Object > ) arg . get Value ( ) ; for ( Object valargobj : value Obj List ) { Argument valarg = ( Argument ) valargobj ; name List . add ( valarg . get Name ( ) ) ; } }
private final void populate Name List ( final Argument arg , final List < Object > name List ) { List < Object > value Obj List = ( List < Object > ) arg . get Value ( ) ; for ( Object valargobj : value Obj List ) { Argument valarg = ( Argument ) valargobj ; name List . add ( valarg . get Name ( ) ) ; } }
Collation Equality Matching Rule Impl ( Locale locale ) { super ( locale ) ; }
public void test Write Read Empty ( ) throws Exception { Byte Array Output Stream out = new Byte Array Output Stream ( NUM ) ; Object Output Stream os = new Object Output Stream ( out ) ; os . write Object ( empty ) ; Object Input Stream is = new Object Input Stream ( new Byte Array Input Stream ( out . to Byte Array ( ) ) ) ; Fail Over Policy . Fail Over Policy Description copy = ( Fail Over Policy . Fail Over Policy Description ) is . read Object ( ) ; is . close ( ) ; os . close ( ) ; assert Null ( copy . m Backup Member Names ) ; assert Null ( copy . m Backup Only ) ; assert Equals ( - NUM , copy . m Policy Type ) ; }
public static void delete File ( final File file , final boolean delete Dir ) { if ( file . is Directory ( ) ) { for ( final File sub File : file . list Files ( ) ) { delete File ( sub File , BOOL ) ; } if ( delete Dir ) { file . delete ( ) ; } } else { file . delete ( ) ; } }
@ Override public Shape Tile [ ] split to convex ( ) { if ( precalculated convex pieces != null ) return precalculated convex pieces ; random generator . set Seed ( seed ) ; Collection < Shape Polygon > convex pieces = split to convex recu ( ) ; if ( convex pieces == null ) { return null ; } precalculated convex pieces = new Shape Tile [ convex pieces . size ( ) ] ; Iterator < Shape Polygon > it = convex pieces . iterator ( ) ; for ( int i = NUM ; i < precalculated convex pieces . length ; ++ i ) { Shape Polygon curr piece = it . next ( ) ; precalculated convex pieces [ i ] = Shape Tile . get instance ( curr piece . corners ) ; } return precalculated convex pieces ; }
@ Override public Shape Tile [ ] split to convex ( ) { if ( precalculated convex pieces != null ) return precalculated convex pieces ; random generator . set Seed ( seed ) ; Collection < Shape Polygon > convex pieces = split to convex recu ( ) ; if ( convex pieces == null ) { return null ; } precalculated convex pieces = new Shape Tile [ convex pieces . size ( ) ] ; Iterator < Shape Polygon > it = convex pieces . iterator ( ) ; for ( int i = NUM ; i < precalculated convex pieces . length ; ++ i ) { Shape Polygon curr piece = it . next ( ) ; precalculated convex pieces [ i ] = Shape Tile . get instance ( curr piece . corners ) ; } return precalculated convex pieces ; }
@ Override public Shape Tile [ ] split to convex ( ) { if ( precalculated convex pieces != null ) return precalculated convex pieces ; random generator . set Seed ( seed ) ; Collection < Shape Polygon > convex pieces = split to convex recu ( ) ; if ( convex pieces == null ) { return null ; } precalculated convex pieces = new Shape Tile [ convex pieces . size ( ) ] ; Iterator < Shape Polygon > it = convex pieces . iterator ( ) ; for ( int i = NUM ; i < precalculated convex pieces . length ; ++ i ) { Shape Polygon curr piece = it . next ( ) ; precalculated convex pieces [ i ] = Shape Tile . get instance ( curr piece . corners ) ; } return precalculated convex pieces ; }
@ Override public Shape Tile [ ] split to convex ( ) { if ( precalculated convex pieces != null ) return precalculated convex pieces ; random generator . set Seed ( seed ) ; Collection < Shape Polygon > convex pieces = split to convex recu ( ) ; if ( convex pieces == null ) { return null ; } precalculated convex pieces = new Shape Tile [ convex pieces . size ( ) ] ; Iterator < Shape Polygon > it = convex pieces . iterator ( ) ; for ( int i = NUM ; i < precalculated convex pieces . length ; ++ i ) { Shape Polygon curr piece = it . next ( ) ; precalculated convex pieces [ i ] = Shape Tile . get instance ( curr piece . corners ) ; } return precalculated convex pieces ; }
public static boolean implements Zero Arg Method ( Class Node class Node , String method Name ) { return implements Method ( class Node , method Name , new Class [ NUM ] ) ; }
public static boolean implements Zero Arg Method ( Class Node class Node , String method Name ) { return implements Method ( class Node , method Name , new Class [ NUM ] ) ; }
private void index CRL ( X509 CRL crl ) { X500 Principal issuer = crl . get Issuer X 500 Principal ( ) ; Object old Entry = crl Issuers . put ( issuer , crl ) ; if ( old Entry != null ) { if ( old Entry instanceof X509 CRL ) { if ( crl . equals ( old Entry ) ) { return ; } List < X509 CRL > list = new Array List < > ( NUM ) ; list . add ( crl ) ; list . add ( ( X509 CRL ) old Entry ) ; crl Issuers . put ( issuer , list ) ; } else { @ Suppress Warnings ( STRING ) List < X509 CRL > list = ( List < X509 CRL > ) old Entry ; if ( list . contains ( crl ) == BOOL ) { list . add ( crl ) ; } crl Issuers . put ( issuer , list ) ; } } }
public Builder add Sub Button ( Drawable drawable , int [ ] two Colors ) { if ( drawables == null ) drawables = new Array List < > ( ) ; drawables . add ( drawable ) ; if ( colors == null ) colors = new Array List < > ( ) ; colors . add ( two Colors ) ; return this ; }
public boolean next Line ( ) throws IO Exception { while ( reader . read Line ( buf . delete ( NUM , buf . length ( ) ) ) ) { ++ line Number ; if ( length Without Linefeed ( buf ) > NUM ) { return BOOL ; } } return BOOL ; }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m io Thread . is Alive ( ) && m state != IDLE ) { wait ( ) ; } } catch ( Interrupted Exception ex ) { } } else { notify All ( ) ; } }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m io Thread . is Alive ( ) && m state != IDLE ) { wait ( ) ; } } catch ( Interrupted Exception ex ) { } } else { notify All ( ) ; } }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m io Thread . is Alive ( ) && m state != IDLE ) { wait ( ) ; } } catch ( Interrupted Exception ex ) { } } else { notify All ( ) ; } }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m io Thread . is Alive ( ) && m state != IDLE ) { wait ( ) ; } } catch ( Interrupted Exception ex ) { } } else { notify All ( ) ; } }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m io Thread . is Alive ( ) && m state != IDLE ) { wait ( ) ; } } catch ( Interrupted Exception ex ) { } } else { notify All ( ) ; } }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m io Thread . is Alive ( ) && m state != IDLE ) { wait ( ) ; } } catch ( Interrupted Exception ex ) { } } else { notify All ( ) ; } }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m io Thread . is Alive ( ) && m state != IDLE ) { wait ( ) ; } } catch ( Interrupted Exception ex ) { } } else { notify All ( ) ; } }
public byte read Byte LE ( ) throws IO Exception { return input Stream . read Byte ( ) ; }
public byte read Byte LE ( ) throws IO Exception { return input Stream . read Byte ( ) ; }
public byte read Byte LE ( ) throws IO Exception { return input Stream . read Byte ( ) ; }
private void compute Areas ( Node Item root ) { int leaf Count = NUM ; Graph g = ( Graph ) m vis . get Group ( m group ) ; Tuple Set nodes = g . get Nodes ( ) ; nodes . add Columns ( AREA SCHEMA ) ; Iterator iter = new Tree Node Iterator ( root ) ; while ( iter . has Next ( ) ) { Node Item n = ( Node Item ) iter . next ( ) ; n . set Double ( AREA , NUM ) ; } iter = new Tree Node Iterator ( root , BOOL ) ; while ( iter . has Next ( ) ) { Node Item n = ( Node Item ) iter . next ( ) ; double area = NUM ; if ( n . get Child Count ( ) == NUM ) { area = n . get Size ( ) ; ++ leaf Count ; } else if ( n . is Expanded ( ) ) { Node Item c = ( Node Item ) n . get First Child ( ) ; for ( ; c != null ; c = ( Node Item ) c . get Next Sibling ( ) ) { area += c . get Double ( AREA ) ; ++ leaf Count ; } } n . set Double ( AREA , area ) ; } Rectangle 2 D b = get Layout Bounds ( ) ; double area = ( b . get Width ( ) - NUM ) * ( b . get Height ( ) - NUM ) ; double scale = area / root . get Double ( AREA ) ; iter = new Tree Node Iterator ( root ) ; while ( iter . has Next ( ) ) { Node Item n = ( Node Item ) iter . next ( ) ; n . set Double ( AREA , n . get Double ( AREA ) * scale ) ; } }
public int update ( String table , Content Values values , String where Clause , String [ ] where Args ) { verify Db Is Open ( ) ; if ( values == null || values . size ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } String Builder sql = new String Builder ( NUM ) ; sql . append ( STRING ) ; sql . append ( table ) ; sql . append ( STRING ) ; int set Values Size = values . size ( ) ; int bind Args Size = ( where Args == null ) ? set Values Size : ( set Values Size + where Args . length ) ; Object [ ] bind Args = new Object [ bind Args Size ] ; int i = NUM ; for ( String col Name : values . key Set ( ) ) { sql . append ( ( i > NUM ) ? STRING : STRING ) ; sql . append ( col Name ) ; bind Args [ i ++ ] = values . get ( col Name ) ; sql . append ( STRING ) ; } if ( where Args != null ) { for ( i = set Values Size ; i < bind Args Size ; i ++ ) { bind Args [ i ] = where Args [ i - set Values Size ] ; } } if ( ! String Utils . is Empty ( where Clause ) ) { sql . append ( STRING ) ; sql . append ( where Clause ) ; } return execute Sql ( sql . to String ( ) , bind Args ) ; }
public int update ( String table , Content Values values , String where Clause , String [ ] where Args ) { verify Db Is Open ( ) ; if ( values == null || values . size ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } String Builder sql = new String Builder ( NUM ) ; sql . append ( STRING ) ; sql . append ( table ) ; sql . append ( STRING ) ; int set Values Size = values . size ( ) ; int bind Args Size = ( where Args == null ) ? set Values Size : ( set Values Size + where Args . length ) ; Object [ ] bind Args = new Object [ bind Args Size ] ; int i = NUM ; for ( String col Name : values . key Set ( ) ) { sql . append ( ( i > NUM ) ? STRING : STRING ) ; sql . append ( col Name ) ; bind Args [ i ++ ] = values . get ( col Name ) ; sql . append ( STRING ) ; } if ( where Args != null ) { for ( i = set Values Size ; i < bind Args Size ; i ++ ) { bind Args [ i ] = where Args [ i - set Values Size ] ; } } if ( ! String Utils . is Empty ( where Clause ) ) { sql . append ( STRING ) ; sql . append ( where Clause ) ; } return execute Sql ( sql . to String ( ) , bind Args ) ; }
public Vector 2 round ( ) { return new Vector 2 ( Math . round ( x ) , Math . round ( z ) ) ; }
private Server Pod [ ] build Servers ( int server Count ) { Array List < Server Pod > servers Pod = new Array List < > ( ) ; for ( int i = NUM ; i < server Count ; i ++ ) { if ( i < server List . size ( ) ) { servers Pod . add ( server List . get ( i ) ) ; } else { servers Pod . add ( new Server Pod ( i ) ) ; } } Server Pod [ ] server Array = new Server Pod [ server Count ] ; for ( int i = NUM ; i < server Count ; i ++ ) { server Array [ i ] = servers Pod . get ( i ) ; } return server Array ; }
private Server Pod [ ] build Servers ( int server Count ) { Array List < Server Pod > servers Pod = new Array List < > ( ) ; for ( int i = NUM ; i < server Count ; i ++ ) { if ( i < server List . size ( ) ) { servers Pod . add ( server List . get ( i ) ) ; } else { servers Pod . add ( new Server Pod ( i ) ) ; } } Server Pod [ ] server Array = new Server Pod [ server Count ] ; for ( int i = NUM ; i < server Count ; i ++ ) { server Array [ i ] = servers Pod . get ( i ) ; } return server Array ; }
private Server Pod [ ] build Servers ( int server Count ) { Array List < Server Pod > servers Pod = new Array List < > ( ) ; for ( int i = NUM ; i < server Count ; i ++ ) { if ( i < server List . size ( ) ) { servers Pod . add ( server List . get ( i ) ) ; } else { servers Pod . add ( new Server Pod ( i ) ) ; } } Server Pod [ ] server Array = new Server Pod [ server Count ] ; for ( int i = NUM ; i < server Count ; i ++ ) { server Array [ i ] = servers Pod . get ( i ) ; } return server Array ; }
private Server Pod [ ] build Servers ( int server Count ) { Array List < Server Pod > servers Pod = new Array List < > ( ) ; for ( int i = NUM ; i < server Count ; i ++ ) { if ( i < server List . size ( ) ) { servers Pod . add ( server List . get ( i ) ) ; } else { servers Pod . add ( new Server Pod ( i ) ) ; } } Server Pod [ ] server Array = new Server Pod [ server Count ] ; for ( int i = NUM ; i < server Count ; i ++ ) { server Array [ i ] = servers Pod . get ( i ) ; } return server Array ; }
private Server Pod [ ] build Servers ( int server Count ) { Array List < Server Pod > servers Pod = new Array List < > ( ) ; for ( int i = NUM ; i < server Count ; i ++ ) { if ( i < server List . size ( ) ) { servers Pod . add ( server List . get ( i ) ) ; } else { servers Pod . add ( new Server Pod ( i ) ) ; } } Server Pod [ ] server Array = new Server Pod [ server Count ] ; for ( int i = NUM ; i < server Count ; i ++ ) { server Array [ i ] = servers Pod . get ( i ) ; } return server Array ; }
public Bounding Box unify With ( Bounding Box bb ) { lat Min = Math . min ( lat Min , bb . lat Min ) ; lon Min = Math . min ( lon Min , bb . lon Min ) ; lat Max = Math . max ( lat Max , bb . lat Max ) ; lon Max = Math . max ( lon Max , bb . lon Max ) ; return this ; }
public Bounding Box unify With ( Bounding Box bb ) { lat Min = Math . min ( lat Min , bb . lat Min ) ; lon Min = Math . min ( lon Min , bb . lon Min ) ; lat Max = Math . max ( lat Max , bb . lat Max ) ; lon Max = Math . max ( lon Max , bb . lon Max ) ; return this ; }
public Receive File Transfer accept File Transfer ( Incoming File Transfer Event event , File destination ) throws IO Exception { check Not Null ( event , STRING ) ; check Not Null ( destination , STRING ) ; return accept File Transfer ( event , destination , NUM ) ; }
public static void install Response Cache ( String base URL , File cache Dir , boolean check For Updates ) { Response Cache . set Default ( new Local Response Cache ( base URL , cache Dir , check For Updates ) ) ; }
public One To One Chat Session create One To One Chat Session ( Contact Id contact , Chat Message first Msg ) { if ( s Logger . is Activated ( ) ) { s Logger . info ( STRING + contact + STRING ) ; } long timestamp = first Msg . get Timestamp ( ) ; return new Originating One To One Chat Session ( this , contact , first Msg , m Rcs Settings , m Messaging Log , timestamp , m Contact Manager ) ; }
private static float saturate ( float f ) { return Math . max ( NUM , Math . min ( NUM , f ) ) ; }
static String plurals ( final String s , final Integer i ) { return i == null ? UNKNOWN + STRING + s + STRING : i . int Value ( ) != NUM ? i + STRING + s + STRING : STRING + s ; }
static String plurals ( final String s , final Integer i ) { return i == null ? UNKNOWN + STRING + s + STRING : i . int Value ( ) != NUM ? i + STRING + s + STRING : STRING + s ; }
static String plurals ( final String s , final Integer i ) { return i == null ? UNKNOWN + STRING + s + STRING : i . int Value ( ) != NUM ? i + STRING + s + STRING : STRING + s ; }
static String plurals ( final String s , final Integer i ) { return i == null ? UNKNOWN + STRING + s + STRING : i . int Value ( ) != NUM ? i + STRING + s + STRING : STRING + s ; }
private String line Printer ( List < Text Read > text Reads , boolean bs , boolean no Format , boolean with Read Name ) throws IO Exception { String Builder sb = new String Builder ( ) ; int cur Pos = NUM ; for ( Text Read tr : text Reads ) { sb . append ( String Utils . repeat ( STRING , ( tr . get Text Start ( ) - NUM ) - cur Pos ) ) ; String printable Read = tr . get Printable Text Read ( bs , no Format , with Read Name ) ; sb . append ( printable Read ) ; cur Pos = tr . get Text End ( ) ; } return sb . to String ( ) ; }
public void create Timer ( ) { Timer t = new Timer ( update Interval , null ) ; t . set Initial Delay ( initial Delay ) ; set Timer ( t ) ; }
private XML Stream Reader new XML Stream Reader ( ) { try { return XML INPUT FACTORY . create XML Stream Reader ( new Byte Array Input Stream ( xml ) , STRING ) ; } catch ( Exception xml Ex ) { throw XML Tree Exception . wrap ( xml Ex ) ; } }
public void remove ( final int start , final int end ) { check Widget ( ) ; if ( start > end ) { SWT . error ( SWT . ERROR INVALID ARGUMENT ) ; } for ( int index = start ; index < end ; index ++ ) { if ( index < NUM || index >= items . size ( ) ) { SWT . error ( SWT . ERROR INVALID ARGUMENT ) ; } items . remove ( index ) ; } redraw Tables ( ) ; }
public void add Active Handler ( Content Handler handler , Mode Usage attribute Mode Usage ) { active Handlers . add Element ( handler ) ; active Handlers Attribute Mode Usage . add Element ( attribute Mode Usage ) ; attribute Processing = Math . max ( attribute Processing , attribute Mode Usage . get Attribute Processing ( ) ) ; if ( attribute Mode Usage . is Context Dependent ( ) ) context Dependent = BOOL ; }
public synchronized Site Node add Path ( History Reference ref ) { if ( Constant . is Low Memory Option Set ( ) ) { throw new Invalid Parameter Exception ( STRING ) ; } Http Message msg = null ; try { msg = ref . get Http Message ( ) ; } catch ( Exception e ) { log . error ( e . get Message ( ) , e ) ; return null ; } return add Path ( ref , msg ) ; }
public Array Real Vector ( int size , double preset ) { data = new double [ size ] ; Arrays . fill ( data , preset ) ; }
public static boolean is You Tube Url ( String url ) { if ( Text Utils . is Empty ( url ) ) { return BOOL ; } Uri uri = Uri . parse ( url ) ; String authority = uri . get Authority ( ) ; if ( ! Text Utils . is Empty ( authority ) && authority . contains ( STRING ) ) { return BOOL ; } else { return BOOL ; } }
public static boolean is You Tube Url ( String url ) { if ( Text Utils . is Empty ( url ) ) { return BOOL ; } Uri uri = Uri . parse ( url ) ; String authority = uri . get Authority ( ) ; if ( ! Text Utils . is Empty ( authority ) && authority . contains ( STRING ) ) { return BOOL ; } else { return BOOL ; } }
@ Override public void agg ( Object new Val ) { value Set . add ( new Val instanceof Big Decimal ? ( Big Decimal ) new Val : new Big Decimal ( new Val . to String ( ) ) ) ; first Time = BOOL ; }
@ Override public void agg ( Object new Val ) { value Set . add ( new Val instanceof Big Decimal ? ( Big Decimal ) new Val : new Big Decimal ( new Val . to String ( ) ) ) ; first Time = BOOL ; }
private static void write Setting ( final C Connection connection , final int container Id , final String key , final String value , final String table ) throws Couldnt Save Data Exception { String id column = STRING ; if ( table . equals Ignore Case ( C Table Names . MODULE SETTINGS TABLE ) ) { id column = STRING ; } else { id column = STRING ; } final String delete Query = STRING + table + STRING + id column + STRING + container Id + STRING + key + STRING ; final String insert Query = STRING + table + STRING + container Id + STRING + key + STRING + value + STRING ; try { Postgre SQL Helpers . begin Transaction ( connection ) ; connection . execute Update ( delete Query , BOOL ) ; connection . execute Update ( insert Query , BOOL ) ; Postgre SQL Helpers . end Transaction ( connection ) ; } catch ( final SQL Exception exception ) { throw new Couldnt Save Data Exception ( STRING + table ) ; } }
protected void Create Keys ( Offset Item fdarray Ref , Offset Item fdselect Ref , Offset Item charset Ref , Offset Item charstrings Ref ) { Output List . add Last ( fdarray Ref ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( fdselect Ref ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( charset Ref ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( charstrings Ref ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; }
protected void Create Keys ( Offset Item fdarray Ref , Offset Item fdselect Ref , Offset Item charset Ref , Offset Item charstrings Ref ) { Output List . add Last ( fdarray Ref ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( fdselect Ref ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( charset Ref ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( charstrings Ref ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; }
@ Method Desc ( description = STRING , usage = STRING ) public Map < String , String > replicator Status ( @ Param Desc ( name = STRING , description = STRING ) String name ) throws Exception { Open Replicator Manager M Bean mgr = replicators . get ( name ) ; if ( mgr == null ) { throw new Exception ( String . format ( STRING , name ) ) ; } return mgr . status ( ) ; }
@ Method Desc ( description = STRING , usage = STRING ) public Map < String , String > replicator Status ( @ Param Desc ( name = STRING , description = STRING ) String name ) throws Exception { Open Replicator Manager M Bean mgr = replicators . get ( name ) ; if ( mgr == null ) { throw new Exception ( String . format ( STRING , name ) ) ; } return mgr . status ( ) ; }
protected int calculate Time For Scrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * MILLISECONDS PER PX ) ; }
protected int calculate Time For Scrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * MILLISECONDS PER PX ) ; }
public PW Reset Exception ( Throwable t ) { super ( t ) ; err List = new Array List ( NUM ) ; err List . add ( t . get Message ( ) ) ; }
public static void sort ( int [ ] a ) { do Sort ( a , NUM , a . length - NUM ) ; }
public static String encode ( Serializable o ) { Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; try { Object Output Stream oos = new Object Output Stream ( bos ) ; try { oos . write Object ( o ) ; oos . flush ( ) ; } finally { oos . close ( ) ; } return Base 64 . encode Bytes ( bos . to Byte Array ( ) ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
@ Override public boolean increment Token ( ) throws IO Exception { if ( saved State != null ) { restore State ( saved State ) ; saved State = null ; save Term Buffer ( ) ; return BOOL ; } else if ( ! input . increment Token ( ) ) { return BOOL ; } if ( last Was Common || ( is Common ( ) && buffer . length ( ) > NUM ) ) { saved State = capture State ( ) ; gram Token ( ) ; return BOOL ; } save Term Buffer ( ) ; return BOOL ; }
@ Override public boolean increment Token ( ) throws IO Exception { if ( saved State != null ) { restore State ( saved State ) ; saved State = null ; save Term Buffer ( ) ; return BOOL ; } else if ( ! input . increment Token ( ) ) { return BOOL ; } if ( last Was Common || ( is Common ( ) && buffer . length ( ) > NUM ) ) { saved State = capture State ( ) ; gram Token ( ) ; return BOOL ; } save Term Buffer ( ) ; return BOOL ; }
@ Override public boolean increment Token ( ) throws IO Exception { if ( saved State != null ) { restore State ( saved State ) ; saved State = null ; save Term Buffer ( ) ; return BOOL ; } else if ( ! input . increment Token ( ) ) { return BOOL ; } if ( last Was Common || ( is Common ( ) && buffer . length ( ) > NUM ) ) { saved State = capture State ( ) ; gram Token ( ) ; return BOOL ; } save Term Buffer ( ) ; return BOOL ; }
@ Override public boolean increment Token ( ) throws IO Exception { if ( saved State != null ) { restore State ( saved State ) ; saved State = null ; save Term Buffer ( ) ; return BOOL ; } else if ( ! input . increment Token ( ) ) { return BOOL ; } if ( last Was Common || ( is Common ( ) && buffer . length ( ) > NUM ) ) { saved State = capture State ( ) ; gram Token ( ) ; return BOOL ; } save Term Buffer ( ) ; return BOOL ; }
@ Override public boolean increment Token ( ) throws IO Exception { if ( saved State != null ) { restore State ( saved State ) ; saved State = null ; save Term Buffer ( ) ; return BOOL ; } else if ( ! input . increment Token ( ) ) { return BOOL ; } if ( last Was Common || ( is Common ( ) && buffer . length ( ) > NUM ) ) { saved State = capture State ( ) ; gram Token ( ) ; return BOOL ; } save Term Buffer ( ) ; return BOOL ; }
@ Override public boolean increment Token ( ) throws IO Exception { if ( saved State != null ) { restore State ( saved State ) ; saved State = null ; save Term Buffer ( ) ; return BOOL ; } else if ( ! input . increment Token ( ) ) { return BOOL ; } if ( last Was Common || ( is Common ( ) && buffer . length ( ) > NUM ) ) { saved State = capture State ( ) ; gram Token ( ) ; return BOOL ; } save Term Buffer ( ) ; return BOOL ; }
@ Override public boolean increment Token ( ) throws IO Exception { if ( saved State != null ) { restore State ( saved State ) ; saved State = null ; save Term Buffer ( ) ; return BOOL ; } else if ( ! input . increment Token ( ) ) { return BOOL ; } if ( last Was Common || ( is Common ( ) && buffer . length ( ) > NUM ) ) { saved State = capture State ( ) ; gram Token ( ) ; return BOOL ; } save Term Buffer ( ) ; return BOOL ; }
@ Override public boolean increment Token ( ) throws IO Exception { if ( saved State != null ) { restore State ( saved State ) ; saved State = null ; save Term Buffer ( ) ; return BOOL ; } else if ( ! input . increment Token ( ) ) { return BOOL ; } if ( last Was Common || ( is Common ( ) && buffer . length ( ) > NUM ) ) { saved State = capture State ( ) ; gram Token ( ) ; return BOOL ; } save Term Buffer ( ) ; return BOOL ; }
@ Override public boolean increment Token ( ) throws IO Exception { if ( saved State != null ) { restore State ( saved State ) ; saved State = null ; save Term Buffer ( ) ; return BOOL ; } else if ( ! input . increment Token ( ) ) { return BOOL ; } if ( last Was Common || ( is Common ( ) && buffer . length ( ) > NUM ) ) { saved State = capture State ( ) ; gram Token ( ) ; return BOOL ; } save Term Buffer ( ) ; return BOOL ; }
public void rebuild Event List ( boolean reset Selected ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING ) ; } all Events = null ; active Events = null ; hide Details ( ) ; init Interface ( get Active Events ( ) , reset Selected ) ; highlight Current Event ( current Time ) ; fire Property Change ( Active Events Property , null , get Active Events ( ) ) ; }
public synchronized void insert Text ( String inputtype , String outputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , String outputtext ) throws SQL Exception { if ( inputtype == null || outputtype == null || locale == null || voice == null || inputtext == null || outputtext == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( lookup Text ( inputtype , outputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + outputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; Prepared Statement st = connection . prepare Statement ( query ) ; st . set String ( NUM , inputtext ) ; st . set String ( NUM , outputtext ) ; st . execute Update ( ) ; st . close ( ) ; }
public synchronized void insert Text ( String inputtype , String outputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , String outputtext ) throws SQL Exception { if ( inputtype == null || outputtype == null || locale == null || voice == null || inputtext == null || outputtext == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( lookup Text ( inputtype , outputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + outputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; Prepared Statement st = connection . prepare Statement ( query ) ; st . set String ( NUM , inputtext ) ; st . set String ( NUM , outputtext ) ; st . execute Update ( ) ; st . close ( ) ; }
public synchronized void insert Text ( String inputtype , String outputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , String outputtext ) throws SQL Exception { if ( inputtype == null || outputtype == null || locale == null || voice == null || inputtext == null || outputtext == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( lookup Text ( inputtype , outputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + outputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; Prepared Statement st = connection . prepare Statement ( query ) ; st . set String ( NUM , inputtext ) ; st . set String ( NUM , outputtext ) ; st . execute Update ( ) ; st . close ( ) ; }
public synchronized void insert Text ( String inputtype , String outputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , String outputtext ) throws SQL Exception { if ( inputtype == null || outputtype == null || locale == null || voice == null || inputtext == null || outputtext == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( lookup Text ( inputtype , outputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + outputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; Prepared Statement st = connection . prepare Statement ( query ) ; st . set String ( NUM , inputtext ) ; st . set String ( NUM , outputtext ) ; st . execute Update ( ) ; st . close ( ) ; }
public synchronized void insert Text ( String inputtype , String outputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , String outputtext ) throws SQL Exception { if ( inputtype == null || outputtype == null || locale == null || voice == null || inputtext == null || outputtext == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( lookup Text ( inputtype , outputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + outputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; Prepared Statement st = connection . prepare Statement ( query ) ; st . set String ( NUM , inputtext ) ; st . set String ( NUM , outputtext ) ; st . execute Update ( ) ; st . close ( ) ; }
public synchronized void insert Text ( String inputtype , String outputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , String outputtext ) throws SQL Exception { if ( inputtype == null || outputtype == null || locale == null || voice == null || inputtext == null || outputtext == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( lookup Text ( inputtype , outputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + outputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; Prepared Statement st = connection . prepare Statement ( query ) ; st . set String ( NUM , inputtext ) ; st . set String ( NUM , outputtext ) ; st . execute Update ( ) ; st . close ( ) ; }
void update Object Id ( Parse Object object , String old Object Id , String new Object Id ) { if ( old Object Id != null ) { if ( old Object Id . equals ( new Object Id ) ) { return ; } throw new Runtime Exception ( STRING ) ; } String class Name = object . get Class Name ( ) ; Pair < String , String > class Name And New Object Id = Pair . create ( class Name , new Object Id ) ; synchronized ( lock ) { Parse Object existing = class Name And Object Id To Object Map . get ( class Name And New Object Id ) ; if ( existing != null && existing != object ) { throw new Runtime Exception ( STRING + STRING ) ; } class Name And Object Id To Object Map . put ( class Name And New Object Id , object ) ; } }
void update Object Id ( Parse Object object , String old Object Id , String new Object Id ) { if ( old Object Id != null ) { if ( old Object Id . equals ( new Object Id ) ) { return ; } throw new Runtime Exception ( STRING ) ; } String class Name = object . get Class Name ( ) ; Pair < String , String > class Name And New Object Id = Pair . create ( class Name , new Object Id ) ; synchronized ( lock ) { Parse Object existing = class Name And Object Id To Object Map . get ( class Name And New Object Id ) ; if ( existing != null && existing != object ) { throw new Runtime Exception ( STRING + STRING ) ; } class Name And Object Id To Object Map . put ( class Name And New Object Id , object ) ; } }
private void send Broadcast Uploads Added ( ) { Intent start = new Intent ( get Uploads Added Message ( ) ) ; send Sticky Broadcast ( start ) ; }
private void send Broadcast Uploads Added ( ) { Intent start = new Intent ( get Uploads Added Message ( ) ) ; send Sticky Broadcast ( start ) ; }
private void send Broadcast Uploads Added ( ) { Intent start = new Intent ( get Uploads Added Message ( ) ) ; send Sticky Broadcast ( start ) ; }
private void send Broadcast Uploads Added ( ) { Intent start = new Intent ( get Uploads Added Message ( ) ) ; send Sticky Broadcast ( start ) ; }
public void add Argument ( Ast Node arg ) { assert Not Null ( arg ) ; if ( arguments == null ) { arguments = new Array List < Ast Node > ( ) ; } arguments . add ( arg ) ; arg . set Parent ( this ) ; }
public void add Argument ( Ast Node arg ) { assert Not Null ( arg ) ; if ( arguments == null ) { arguments = new Array List < Ast Node > ( ) ; } arguments . add ( arg ) ; arg . set Parent ( this ) ; }
public static boolean is Font Embedded ( Pdf Object pdf Object ) { final int font Type = pdf Object . get Parameter Constant ( Pdf Dictionary . Subtype ) ; if ( font Type == Standard Fonts . TYPE 0 ) { pdf Object = pdf Object . get Dictionary ( Pdf Dictionary . Descendant Fonts ) ; } final Pdf Object desc Font Obj = pdf Object . get Dictionary ( Pdf Dictionary . Font Descriptor ) ; if ( desc Font Obj == null ) { return BOOL ; } else { return desc Font Obj . has Stream ( ) ; } }
@ Override public void write ( int b ) throws IO Exception { if ( stack . size ( ) == NUM || standalone Markers . contains ( stack . peek ( ) . marker ) ) { write Stuffed ( b ) ; } else { write Nonstuffed ( b ) ; } }
public void mouse Dragged ( Mouse Event e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( get ID ( ) + STRING ) ; } super . mouse Dragged ( e ) ; Object obj = e . get Source ( ) ; if ( obj instanceof Map Bean && the Map == null ) { the Map = ( Map Bean ) obj ; the Map . add Paint Listener ( this ) ; } Map Bean map = this . the Map ; Point first Point = this . point 1 ; if ( map != null ) { if ( ! auto Zoom ) { return ; } point 2 = get Ratio Point ( map , first Point , e . get Point ( ) ) ; map . repaint ( ) ; } }
public void mouse Dragged ( Mouse Event e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( get ID ( ) + STRING ) ; } super . mouse Dragged ( e ) ; Object obj = e . get Source ( ) ; if ( obj instanceof Map Bean && the Map == null ) { the Map = ( Map Bean ) obj ; the Map . add Paint Listener ( this ) ; } Map Bean map = this . the Map ; Point first Point = this . point 1 ; if ( map != null ) { if ( ! auto Zoom ) { return ; } point 2 = get Ratio Point ( map , first Point , e . get Point ( ) ) ; map . repaint ( ) ; } }
public static String pad Right ( String s , int len , char pad ch ) { if ( s . length ( ) >= len ) { return s ; } else { String Builder sb = new String Builder ( ) ; int n = len - s . length ( ) ; sb . append ( s ) ; for ( int i = NUM ; i < n ; i ++ ) { sb . append ( pad ch ) ; } return sb . to String ( ) ; } }
public static < S extends Declaration , S2 extends S > Symbol Reference < S > solved ( S2 symbol Declaration ) { return new Symbol Reference ( Optional . of ( symbol Declaration ) ) ; }
public static double ud ( ) { return R . next Double ( ) ; }
public boolean is Empty ( ) { if ( ! built ) return item Boundables . is Empty ( ) ; return root . is Empty ( ) ; }
public boolean is Empty ( ) { if ( ! built ) return item Boundables . is Empty ( ) ; return root . is Empty ( ) ; }
public boolean is Empty ( ) { if ( ! built ) return item Boundables . is Empty ( ) ; return root . is Empty ( ) ; }
public boolean is Empty ( ) { if ( ! built ) return item Boundables . is Empty ( ) ; return root . is Empty ( ) ; }
public final Input Stream as Input Stream ( ) throws Unknown Resource Exception { return to Input Stream ( ) ; }
public final Input Stream as Input Stream ( ) throws Unknown Resource Exception { return to Input Stream ( ) ; }
protected J Panel make Params Panel ( ) { J Panel panel = super . make Params Panel ( ) ; J Panel p = new J Panel ( ) ; p . set Layout ( new Box Layout ( p , Box Layout . Y AXIS ) ) ; p . add ( new J Label ( Bundle . get Message ( STRING ) ) ) ; J Panel pp = new J Panel ( ) ; radius Text = new J Text Field ( NUM ) ; radius Text . set Text ( Integer . to String ( radius ) ) ; radius Text . set Horizontal Alignment ( J Text Field . RIGHT ) ; pp . add ( radius Text ) ; pp . add ( new J Label ( Bundle . get Message ( STRING ) ) ) ; p . add ( pp ) ; panel . add ( p ) ; panel . add ( Box . create Vertical Strut ( STRUT SIZE ) ) ; return panel ; }
private static boolean test ( O Database Document Pool pool , String db URL , String user , String password , boolean final Try ) { O Database Document Tx db = null ; try { logger . info ( STRING ) ; db = pool . acquire ( db URL , user , password ) ; Iterator < O Document > iter = db . browse Class ( STRING ) ; if ( iter . has Next ( ) ) { iter . next ( ) ; } } catch ( O Exception ex ) { if ( final Try ) { logger . info ( STRING , ex ) ; } else { logger . debug ( STRING , ex ) ; } return BOOL ; } finally { if ( db != null ) { db . close ( ) ; } } return BOOL ; }
private static boolean test ( O Database Document Pool pool , String db URL , String user , String password , boolean final Try ) { O Database Document Tx db = null ; try { logger . info ( STRING ) ; db = pool . acquire ( db URL , user , password ) ; Iterator < O Document > iter = db . browse Class ( STRING ) ; if ( iter . has Next ( ) ) { iter . next ( ) ; } } catch ( O Exception ex ) { if ( final Try ) { logger . info ( STRING , ex ) ; } else { logger . debug ( STRING , ex ) ; } return BOOL ; } finally { if ( db != null ) { db . close ( ) ; } } return BOOL ; }
public String product Name ( ) { return properties . get Property ( STRING ) ; }
public Extended Message Format ( final String pattern , final Map < String , ? extends Format Factory > registry ) { this ( pattern , Locale . get Default ( ) , registry ) ; }
private void add Class Loader ( Class Loader loader , final Object Name logical Name ) { final Modifiable Class Loader Repository clr = get Instantiator CLR ( ) ; if ( clr == null ) { final Runtime Exception wrapped = new Illegal Argument Exception ( STRING + STRING ) ; throw new Runtime Operations Exception ( wrapped , STRING + STRING ) ; } clr . add Class Loader ( logical Name , loader ) ; }
Content Tile ( int row , int column ) { this . row = row ; this . column = column ; }
private void add ( Session ID session ID ) { remote Session Set . add ( session ID ) ; }
protected void print Attribute Summary ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance ) { String str = STRING ; if ( numeric Predictor ) { str += STRING ; } if ( nominal Predictor ) { if ( str . length ( ) > NUM ) { str += STRING ; } str += STRING ; } if ( string Predictor ) { if ( str . length ( ) > NUM ) { str += STRING ; } str += STRING ; } if ( date Predictor ) { if ( str . length ( ) > NUM ) { str += STRING ; } str += STRING ; } if ( relational Predictor ) { if ( str . length ( ) > NUM ) { str += STRING ; } str += STRING ; } str = STRING + str + STRING ; print ( str ) ; }
public boolean is Service Selected ( ) { return tabbed Pane != null && tabbed Pane . get Selected Component ( ) != null && tabbed Pane . get Selected Component ( ) instanceof Service Panel ; }
private void unregister ( ) { Grid Dht Local Partition [ ] arr = parts . get ( ) ; if ( ! F . is Empty ( arr ) && parts . compare And Set ( arr , EMPTY ) ) { for ( int i = arr . length - NUM ; i >= NUM ; i -- ) { Grid Dht Local Partition part = arr [ i ] ; part . remove Reservation ( this ) ; try Evict ( part ) ; } } CI 1 < Grid Dht Partitions Reservation > u = unpublish . get ( ) ; if ( u != null && u != NO OP && unpublish . compare And Set ( u , NO OP ) ) u . apply ( this ) ; }
public Adapter Path Segment first Segment ( ) { return ( ! m Segments . is Empty ( ) ) ? ( m Segments . get ( NUM ) ) : null ; }
public Byte Packed Raster ( Sample Model sample Model , Data Buffer data Buffer , Point origin ) { this ( sample Model , data Buffer , new Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
public Point translate Java 2 D To Screen ( Point 2 D java 2 D Point ) { Insets insets = get Insets ( ) ; int x = ( int ) ( java 2 D Point . get X ( ) * this . scale X + insets . left ) ; int y = ( int ) ( java 2 D Point . get Y ( ) * this . scale Y + insets . top ) ; return new Point ( x , y ) ; }
@ Override public void suite Start ( ) { throw new Unsupported Operation Exception ( ) ; }
@ Override public void suite Start ( ) { throw new Unsupported Operation Exception ( ) ; }
public Activity current Activity ( ) { if ( m Activity Stack == null ) return null ; return m Activity Stack . last Element ( ) ; }
public Activity current Activity ( ) { if ( m Activity Stack == null ) return null ; return m Activity Stack . last Element ( ) ; }
private void populate Completed Activiti Steps ( Job job , List < Historic Activity Instance > historic Activiti Tasks ) { List < Workflow Step > completed Workflow Steps = new Array List < > ( ) ; for ( Historic Activity Instance historic Activity Instance : historic Activiti Tasks ) { completed Workflow Steps . add ( new Workflow Step ( historic Activity Instance . get Activity Id ( ) , historic Activity Instance . get Activity Name ( ) , Herd Date Utils . get XML Gregorian Calendar Value ( historic Activity Instance . get Start Time ( ) ) , Herd Date Utils . get XML Gregorian Calendar Value ( historic Activity Instance . get End Time ( ) ) ) ) ; } job . set Completed Workflow Steps ( completed Workflow Steps ) ; }
public static float update Value ( float current , float target , float factor ) { float times = ( System . current Time Millis ( ) - Client Utils . last Update ) / NUM ; float off = ( off = target - current ) > NUM || off < - NUM ? off * ( float ) Math . pow ( factor , times ) : NUM ; return target - off ; }
public static float update Value ( float current , float target , float factor ) { float times = ( System . current Time Millis ( ) - Client Utils . last Update ) / NUM ; float off = ( off = target - current ) > NUM || off < - NUM ? off * ( float ) Math . pow ( factor , times ) : NUM ; return target - off ; }
public static float update Value ( float current , float target , float factor ) { float times = ( System . current Time Millis ( ) - Client Utils . last Update ) / NUM ; float off = ( off = target - current ) > NUM || off < - NUM ? off * ( float ) Math . pow ( factor , times ) : NUM ; return target - off ; }
public static Model create Includes Model ( Model model , String graph URI ) { Set < Graph > graphs = new Hash Set < Graph > ( ) ; Graph base Graph = model . get Graph ( ) ; add Includes ( base Graph , graph URI , graphs , new Hash Set < String > ( ) ) ; if ( graphs . size ( ) == NUM ) { return model ; } else { Multi Union union = new Multi Union ( graphs . iterator ( ) ) ; union . set Base Graph ( base Graph ) ; return Model Factory . create Model For Graph ( union ) ; } }
public static void close ( @ Check For Null Input Stream input Stream ) { if ( input Stream == null ) { return ; } try { input Stream . close ( ) ; } catch ( IO Exception e ) { } }
public void test Case 23 ( ) { byte r Bytes [ ] = { NUM } ; Big Integer a Number = Big Integer . ZERO ; Big Integer b Number = Big Integer . ZERO ; Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( NUM , result . signum ( ) ) ; }
public void test Case 23 ( ) { byte r Bytes [ ] = { NUM } ; Big Integer a Number = Big Integer . ZERO ; Big Integer b Number = Big Integer . ZERO ; Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( NUM , result . signum ( ) ) ; }
private void reduce Scroll Speed ( double speed , int header Visible ) { m Recycler View . stop Scroll ( ) ; int dist To Stop = min Distance To Scroll Back ; m Scroller . set Scroll Vector ( get Decel Vector ( header Visible ) ) ; m Scroller . set Target Position ( get Decel Target Pos ( header Visible ) ) ; m Scroller . set Distance To Stop ( dist To Stop ) ; m Scroller . set Initial Speed ( ( float ) Math . abs ( speed ) ) ; m Layout Manager . start Smooth Scroll ( m Scroller ) ; }
private void reduce Scroll Speed ( double speed , int header Visible ) { m Recycler View . stop Scroll ( ) ; int dist To Stop = min Distance To Scroll Back ; m Scroller . set Scroll Vector ( get Decel Vector ( header Visible ) ) ; m Scroller . set Target Position ( get Decel Target Pos ( header Visible ) ) ; m Scroller . set Distance To Stop ( dist To Stop ) ; m Scroller . set Initial Speed ( ( float ) Math . abs ( speed ) ) ; m Layout Manager . start Smooth Scroll ( m Scroller ) ; }
public void start ( ) { event Log Thread . start ( ) ; LOGGER . info ( STRING + event Log Thread . get Name ( ) + STRING + event Log Thread . get Id ( ) + STRING ) ; }
private void on Stop Attack ( ) { attacking = null ; }
private void on Stop Attack ( ) { attacking = null ; }
public void print String ( String v ) throws IO Exception { print String ( v , NUM , v . length ( ) ) ; }
public void print String ( String v ) throws IO Exception { print String ( v , NUM , v . length ( ) ) ; }
public static boolean remove Table ( Table t ) { try { table List . remove ( t ) ; } catch ( Exception e ) { return BOOL ; } return BOOL ; }
public static String format Date ( Date d ) { try { synchronized ( time Formatter ) { return time Formatter . format ( d ) ; } } catch ( Exception e1 ) { try { return d . to String ( ) ; } catch ( Exception e2 ) { try { return Long . to String ( d . get Time ( ) ) ; } catch ( Exception e3 ) { return STRING ; } } } }
private void assert Serialize And Des Date Time ( String date Time String ) throws Rya Type Resolver Exception { assert Serialize And Des Date Time ( date Time String , date Time String ) ; }
void collect Types ( ) { for ( Resource type : known Types . key Set ( ) ) { collect ( known Types . get ( type ) ) ; } }
void collect Types ( ) { for ( Resource type : known Types . key Set ( ) ) { collect ( known Types . get ( type ) ) ; } }
static Aggregated Http Message of ( Http Headers headers , Http Data content , Http Headers trailing Headers ) { return of ( Collections . empty List ( ) , headers , content , trailing Headers ) ; }
public void handle Notification ( Notification notification , Object handback ) { String notify Type = notification . get Type ( ) ; if ( notify Type . equals ( Garbage Collection Notification Info . GARBAGE COLLECTION NOTIFICATION ) ) { Composite Data cd = ( Composite Data ) notification . get User Data ( ) ; Garbage Collection Notification Info gc Notify Info = Garbage Collection Notification Info . from ( cd ) ; monitor ( gc Notify Info ) ; if ( ! gc Names . contains ( gc Notify Info . get Gc Name ( ) ) ) { register Dependent Gc Mbeans ( gc Notify Info . get Gc Name ( ) ) ; } } }
public void handle Notification ( Notification notification , Object handback ) { String notify Type = notification . get Type ( ) ; if ( notify Type . equals ( Garbage Collection Notification Info . GARBAGE COLLECTION NOTIFICATION ) ) { Composite Data cd = ( Composite Data ) notification . get User Data ( ) ; Garbage Collection Notification Info gc Notify Info = Garbage Collection Notification Info . from ( cd ) ; monitor ( gc Notify Info ) ; if ( ! gc Names . contains ( gc Notify Info . get Gc Name ( ) ) ) { register Dependent Gc Mbeans ( gc Notify Info . get Gc Name ( ) ) ; } } }
public double calculate Local Swap Total Capacity ( int hostcount , int hostlocalswapsize ) { double d = ( double ) ( hostcount * hostlocalswapsize ) / NUM ; d *= - NUM ; d = ( double ) Math . round ( d * NUM ) / NUM ; return d ; }
public double calculate Local Swap Total Capacity ( int hostcount , int hostlocalswapsize ) { double d = ( double ) ( hostcount * hostlocalswapsize ) / NUM ; d *= - NUM ; d = ( double ) Math . round ( d * NUM ) / NUM ; return d ; }
public double calculate Local Swap Total Capacity ( int hostcount , int hostlocalswapsize ) { double d = ( double ) ( hostcount * hostlocalswapsize ) / NUM ; d *= - NUM ; d = ( double ) Math . round ( d * NUM ) / NUM ; return d ; }
static List < File > tidy Database List ( List < File > database Files ) { List < File > tidied List = new Array List < > ( ) ; for ( File database File : database Files ) { tidied List . add ( database File ) ; } return tidied List ; }
static List < File > tidy Database List ( List < File > database Files ) { List < File > tidied List = new Array List < > ( ) ; for ( File database File : database Files ) { tidied List . add ( database File ) ; } return tidied List ; }
static List < File > tidy Database List ( List < File > database Files ) { List < File > tidied List = new Array List < > ( ) ; for ( File database File : database Files ) { tidied List . add ( database File ) ; } return tidied List ; }
static List < File > tidy Database List ( List < File > database Files ) { List < File > tidied List = new Array List < > ( ) ; for ( File database File : database Files ) { tidied List . add ( database File ) ; } return tidied List ; }
static List < File > tidy Database List ( List < File > database Files ) { List < File > tidied List = new Array List < > ( ) ; for ( File database File : database Files ) { tidied List . add ( database File ) ; } return tidied List ; }
private void enable Maintenance Mode ( ) { synchronized ( maintenance Enabled ) { if ( ! maintenance Enabled . get And Set ( BOOL ) ) { maintenance Filter . enable Maintenance Mode ( ) ; } } }
private void enable Maintenance Mode ( ) { synchronized ( maintenance Enabled ) { if ( ! maintenance Enabled . get And Set ( BOOL ) ) { maintenance Filter . enable Maintenance Mode ( ) ; } } }
private void enable Maintenance Mode ( ) { synchronized ( maintenance Enabled ) { if ( ! maintenance Enabled . get And Set ( BOOL ) ) { maintenance Filter . enable Maintenance Mode ( ) ; } } }
private void enable Maintenance Mode ( ) { synchronized ( maintenance Enabled ) { if ( ! maintenance Enabled . get And Set ( BOOL ) ) { maintenance Filter . enable Maintenance Mode ( ) ; } } }
public void create ( String [ ] rpf File Paths , String output File ) throws Make Toc Exception { create ( rpf File Paths , output File , BOOL ) ; }
public void create ( String [ ] rpf File Paths , String output File ) throws Make Toc Exception { create ( rpf File Paths , output File , BOOL ) ; }
public static void restore Previous Out And Err Stream ( ) { if ( ! already Muted ) { return ; } System . set Out ( latest Out ) ; System . set Err ( latest Err ) ; already Muted = BOOL ; }
public static void restore Previous Out And Err Stream ( ) { if ( ! already Muted ) { return ; } System . set Out ( latest Out ) ; System . set Err ( latest Err ) ; already Muted = BOOL ; }
void update WS Fed Entity Config ( String realm , String cot Name , Set trusted Providers ) throws COT Exception { String class Method = STRING ; String entity Id = null ; WS Federation COT Utils wsfed Cot Utils = new WS Federation COT Utils ( caller Session ) ; if ( trusted Providers != null && ! trusted Providers . is Empty ( ) ) { for ( Iterator iter = trusted Providers . iterator ( ) ; iter . has Next ( ) ; ) { entity Id = ( String ) iter . next ( ) ; try { wsfed Cot Utils . update Entity Config ( realm , cot Name , entity Id ) ; } catch ( WS Federation Meta Exception sme ) { throw new COT Exception ( sme ) ; } catch ( JAXB Exception e ) { debug . error ( class Method , e ) ; String [ ] data = { e . get Message ( ) , cot Name , entity Id , realm } ; Log Util . error ( Level . INFO , Log Util . CONFIG ERROR CREATE COT DESCRIPTOR , data ) ; throw new COT Exception ( e ) ; } } } }
@ Suppress Warnings ( STRING ) public static < T > Sequence < T > wrap Start ( Sequence < T > sequence , T start Token ) { Object [ ] arr = new Object [ sequence . size ( ) + NUM ] ; arr [ NUM ] = start Token ; System . arraycopy ( sequence . elements ( ) , NUM , arr , NUM , sequence . size ( ) ) ; return new Array Sequence < T > ( BOOL , ( T [ ] ) arr ) ; }
@ Override public void run ( ) { am I Active = BOOL ; panel = new Coordinate Transform Dialog ( my Host ) ; if ( my Host instanceof J Frame ) { J Dialog dialog = new J Dialog ( ( J Frame ) my Host , STRING , BOOL ) ; Container content Pane = dialog . get Content Pane ( ) ; content Pane . add ( panel , Border Layout . CENTER ) ; dialog . set Default Close Operation ( J Frame . DISPOSE ON CLOSE ) ; dialog . pack ( ) ; dialog . set Location Relative To ( null ) ; dialog . set Visible ( BOOL ) ; } else { J Frame frame = new J Frame ( STRING ) ; Container content Pane = frame . get Content Pane ( ) ; content Pane . add ( panel , Border Layout . CENTER ) ; frame . set Default Close Operation ( J Frame . DISPOSE ON CLOSE ) ; frame . pack ( ) ; frame . set Location Relative To ( null ) ; frame . set Visible ( BOOL ) ; } }
public static boolean equals ( byte [ ] [ ] field 1 , byte [ ] [ ] field 2 ) { int index 1 = NUM ; int length 1 = field 1 == null ? NUM : field 1 . length ; int index 2 = NUM ; int length 2 = field 2 == null ? NUM : field 2 . length ; while ( BOOL ) { while ( index 1 < length 1 && field 1 [ index 1 ] == null ) { index 1 ++ ; } while ( index 2 < length 2 && field 2 [ index 2 ] == null ) { index 2 ++ ; } boolean at End Of 1 = index 1 >= length 1 ; boolean at End Of 2 = index 2 >= length 2 ; if ( at End Of 1 && at End Of 2 ) { return BOOL ; } else if ( at End Of 1 != at End Of 2 ) { return BOOL ; } else if ( ! Arrays . equals ( field 1 [ index 1 ] , field 2 [ index 2 ] ) ) { return BOOL ; } index 1 ++ ; index 2 ++ ; } }
public static boolean equals ( byte [ ] [ ] field 1 , byte [ ] [ ] field 2 ) { int index 1 = NUM ; int length 1 = field 1 == null ? NUM : field 1 . length ; int index 2 = NUM ; int length 2 = field 2 == null ? NUM : field 2 . length ; while ( BOOL ) { while ( index 1 < length 1 && field 1 [ index 1 ] == null ) { index 1 ++ ; } while ( index 2 < length 2 && field 2 [ index 2 ] == null ) { index 2 ++ ; } boolean at End Of 1 = index 1 >= length 1 ; boolean at End Of 2 = index 2 >= length 2 ; if ( at End Of 1 && at End Of 2 ) { return BOOL ; } else if ( at End Of 1 != at End Of 2 ) { return BOOL ; } else if ( ! Arrays . equals ( field 1 [ index 1 ] , field 2 [ index 2 ] ) ) { return BOOL ; } index 1 ++ ; index 2 ++ ; } }
protected void draw Rhombus ( int x , int y , int w , int h , Color fill Color , Paint fill Paint , Color pen Color , boolean shadow ) { int half Width = w / NUM ; int half Height = h / NUM ; Polygon rhombus = new Polygon ( ) ; rhombus . add Point ( x + half Width , y ) ; rhombus . add Point ( x + w , y + half Height ) ; rhombus . add Point ( x + half Width , y + h ) ; rhombus . add Point ( x , y + half Height ) ; draw Polygon ( rhombus , fill Color , fill Paint , pen Color , shadow ) ; }
private void algorithm Douglas Peucker ( Array List < Entry > entries , double epsilon , int start , int end ) { if ( end <= start + NUM ) { return ; } int max Dist Index = NUM ; double dist Max = NUM ; Entry first Entry = entries . get ( start ) ; Entry last Entry = entries . get ( end ) ; for ( int i = start + NUM ; i < end ; i ++ ) { double dist = point To Line Distance ( first Entry , last Entry , entries . get ( i ) ) ; if ( dist > dist Max ) { dist Max = dist ; max Dist Index = i ; } } if ( dist Max > epsilon ) { keep [ max Dist Index ] = BOOL ; algorithm Douglas Peucker ( entries , epsilon , start , max Dist Index ) ; algorithm Douglas Peucker ( entries , epsilon , max Dist Index , end ) ; } }
public static boolean is Synchronized ( int mod ) { return Modifier . is Synchronized ( mod ) ; }
public static boolean is Synchronized ( int mod ) { return Modifier . is Synchronized ( mod ) ; }
public void characters ( org . w3 c . dom . Node node ) throws org . xml . sax . SAX Exception { flush Pending ( ) ; String data = node . get Node Value ( ) ; if ( data != null ) { final int length = data . length ( ) ; if ( length > m chars Buff . length ) { m chars Buff = new char [ length * NUM + NUM ] ; } data . get Chars ( NUM , length , m chars Buff , NUM ) ; characters ( m chars Buff , NUM , length ) ; } }
public void characters ( org . w3 c . dom . Node node ) throws org . xml . sax . SAX Exception { flush Pending ( ) ; String data = node . get Node Value ( ) ; if ( data != null ) { final int length = data . length ( ) ; if ( length > m chars Buff . length ) { m chars Buff = new char [ length * NUM + NUM ] ; } data . get Chars ( NUM , length , m chars Buff , NUM ) ; characters ( m chars Buff , NUM , length ) ; } }
public void characters ( org . w3 c . dom . Node node ) throws org . xml . sax . SAX Exception { flush Pending ( ) ; String data = node . get Node Value ( ) ; if ( data != null ) { final int length = data . length ( ) ; if ( length > m chars Buff . length ) { m chars Buff = new char [ length * NUM + NUM ] ; } data . get Chars ( NUM , length , m chars Buff , NUM ) ; characters ( m chars Buff , NUM , length ) ; } }
public void write Line ( double [ ] column ) { String str = Double . to String ( column [ NUM ] ) ; for ( int i = NUM ; i < column . length ; ++ i ) { str += STRING + column [ i ] ; } writer . println ( str ) ; }
private static int hash ( Object x ) { int h = x . hash Code ( ) ; return ( ( h << NUM ) - h + ( h > > > NUM ) + ( h > > > NUM ) ) ; }
private static int hash ( Object x ) { int h = x . hash Code ( ) ; return ( ( h << NUM ) - h + ( h > > > NUM ) + ( h > > > NUM ) ) ; }
private static int hash ( Object x ) { int h = x . hash Code ( ) ; return ( ( h << NUM ) - h + ( h > > > NUM ) + ( h > > > NUM ) ) ; }
private Un Managed Volume create Un Managed Volume ( String un Managed Volume Native Guid , Logical Unit logical Unit , Storage System system , Storage Pool pool , Db Client db Client ) { Un Managed Volume new Un Managed Volume = new Un Managed Volume ( ) ; new Un Managed Volume . set Id ( URI Util . create Id ( Un Managed Volume . class ) ) ; new Un Managed Volume . set Native Guid ( un Managed Volume Native Guid ) ; new Un Managed Volume . set Storage System Uri ( system . get Id ( ) ) ; new Un Managed Volume . set Storage Pool Uri ( pool . get Id ( ) ) ; update Un Managed Volume Info ( logical Unit , system , pool , new Un Managed Volume , db Client ) ; return new Un Managed Volume ; }
private static File create Temp File ( String temp Subdirectory Name , String name ) throws IO Exception { String temp Dir Name = System . get Property ( STRING ) ; File temp Sub Directory = new File ( temp Dir Name + File . separator + temp Subdirectory Name ) ; if ( ! temp Sub Directory . exists ( ) ) { boolean created Directory = temp Sub Directory . mkdirs ( ) ; if ( ! created Directory ) { throw new IO Exception ( STRING + temp Sub Directory ) ; } } String temp File Name = temp Sub Directory + File . separator + name ; File temp File = new File ( temp File Name ) ; return temp File ; }
private static File create Temp File ( String temp Subdirectory Name , String name ) throws IO Exception { String temp Dir Name = System . get Property ( STRING ) ; File temp Sub Directory = new File ( temp Dir Name + File . separator + temp Subdirectory Name ) ; if ( ! temp Sub Directory . exists ( ) ) { boolean created Directory = temp Sub Directory . mkdirs ( ) ; if ( ! created Directory ) { throw new IO Exception ( STRING + temp Sub Directory ) ; } } String temp File Name = temp Sub Directory + File . separator + name ; File temp File = new File ( temp File Name ) ; return temp File ; }
private void paint Zoom Indicator ( Graphics 2 D graphics ) { if ( m Zoom != NUM ) { int width = get Width ( ) / NUM ; int x = ( get Width ( ) / NUM ) - ( width / NUM ) ; graphics . draw Rect ( x , get Height ( ) - NUM , width , NUM ) ; int zoom Width = width / get Zoom Multiplier ( ) ; int window Offset = NUM ; if ( mDFT Zoom Window Offset != NUM ) { window Offset = ( int ) ( ( ( double ) mDFT Zoom Window Offset / ( double ) mDFT Size ) * width ) ; } graphics . fill Rect ( x + window Offset , get Height ( ) - NUM , zoom Width , NUM ) ; graphics . draw String ( STRING + get Zoom Multiplier ( ) + STRING , x + width + NUM , get Height ( ) - NUM ) ; } }
private void paint Zoom Indicator ( Graphics 2 D graphics ) { if ( m Zoom != NUM ) { int width = get Width ( ) / NUM ; int x = ( get Width ( ) / NUM ) - ( width / NUM ) ; graphics . draw Rect ( x , get Height ( ) - NUM , width , NUM ) ; int zoom Width = width / get Zoom Multiplier ( ) ; int window Offset = NUM ; if ( mDFT Zoom Window Offset != NUM ) { window Offset = ( int ) ( ( ( double ) mDFT Zoom Window Offset / ( double ) mDFT Size ) * width ) ; } graphics . fill Rect ( x + window Offset , get Height ( ) - NUM , zoom Width , NUM ) ; graphics . draw String ( STRING + get Zoom Multiplier ( ) + STRING , x + width + NUM , get Height ( ) - NUM ) ; } }
private void paint Zoom Indicator ( Graphics 2 D graphics ) { if ( m Zoom != NUM ) { int width = get Width ( ) / NUM ; int x = ( get Width ( ) / NUM ) - ( width / NUM ) ; graphics . draw Rect ( x , get Height ( ) - NUM , width , NUM ) ; int zoom Width = width / get Zoom Multiplier ( ) ; int window Offset = NUM ; if ( mDFT Zoom Window Offset != NUM ) { window Offset = ( int ) ( ( ( double ) mDFT Zoom Window Offset / ( double ) mDFT Size ) * width ) ; } graphics . fill Rect ( x + window Offset , get Height ( ) - NUM , zoom Width , NUM ) ; graphics . draw String ( STRING + get Zoom Multiplier ( ) + STRING , x + width + NUM , get Height ( ) - NUM ) ; } }
private void paint Zoom Indicator ( Graphics 2 D graphics ) { if ( m Zoom != NUM ) { int width = get Width ( ) / NUM ; int x = ( get Width ( ) / NUM ) - ( width / NUM ) ; graphics . draw Rect ( x , get Height ( ) - NUM , width , NUM ) ; int zoom Width = width / get Zoom Multiplier ( ) ; int window Offset = NUM ; if ( mDFT Zoom Window Offset != NUM ) { window Offset = ( int ) ( ( ( double ) mDFT Zoom Window Offset / ( double ) mDFT Size ) * width ) ; } graphics . fill Rect ( x + window Offset , get Height ( ) - NUM , zoom Width , NUM ) ; graphics . draw String ( STRING + get Zoom Multiplier ( ) + STRING , x + width + NUM , get Height ( ) - NUM ) ; } }
private void paint Zoom Indicator ( Graphics 2 D graphics ) { if ( m Zoom != NUM ) { int width = get Width ( ) / NUM ; int x = ( get Width ( ) / NUM ) - ( width / NUM ) ; graphics . draw Rect ( x , get Height ( ) - NUM , width , NUM ) ; int zoom Width = width / get Zoom Multiplier ( ) ; int window Offset = NUM ; if ( mDFT Zoom Window Offset != NUM ) { window Offset = ( int ) ( ( ( double ) mDFT Zoom Window Offset / ( double ) mDFT Size ) * width ) ; } graphics . fill Rect ( x + window Offset , get Height ( ) - NUM , zoom Width , NUM ) ; graphics . draw String ( STRING + get Zoom Multiplier ( ) + STRING , x + width + NUM , get Height ( ) - NUM ) ; } }
public void process Attributes ( java . io . Writer writer , int n Attrs ) throws IO Exception , SAX Exception { String encoding = get Encoding ( ) ; for ( int i = NUM ; i < n Attrs ; i ++ ) { final String name = m attributes . get Q Name ( i ) ; final String value = m attributes . get Value ( i ) ; writer . write ( STRING ) ; writer . write ( name ) ; writer . write ( STRING ) ; write Attr String ( writer , value , encoding ) ; writer . write ( STRING ) ; } }
public void process Attributes ( java . io . Writer writer , int n Attrs ) throws IO Exception , SAX Exception { String encoding = get Encoding ( ) ; for ( int i = NUM ; i < n Attrs ; i ++ ) { final String name = m attributes . get Q Name ( i ) ; final String value = m attributes . get Value ( i ) ; writer . write ( STRING ) ; writer . write ( name ) ; writer . write ( STRING ) ; write Attr String ( writer , value , encoding ) ; writer . write ( STRING ) ; } }
public void process Attributes ( java . io . Writer writer , int n Attrs ) throws IO Exception , SAX Exception { String encoding = get Encoding ( ) ; for ( int i = NUM ; i < n Attrs ; i ++ ) { final String name = m attributes . get Q Name ( i ) ; final String value = m attributes . get Value ( i ) ; writer . write ( STRING ) ; writer . write ( name ) ; writer . write ( STRING ) ; write Attr String ( writer , value , encoding ) ; writer . write ( STRING ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
@ Suppress Warnings ( STRING ) public void check Delivery Time ( Message message ) throws JMS Exception { long creation = message . get JMS Timestamp ( ) ; long min = System . current Time Millis ( ) - ( offline . max + online . min ) * ( BROKER RESTART > NUM ? NUM : NUM ) ; if ( BOOL && min > creation ) { Simple Date Format df = new Simple Date Format ( STRING ) ; exit ( STRING + this + STRING + df . format ( new Date ( creation ) ) + STRING + df . format ( new Date ( min ) ) + STRING + message ) ; } }
public synchronized void add ( Class t , Event Listener l ) { if ( ! t . is Instance ( l ) ) { throw new Illegal Argument Exception ( STRING + l + STRING + t ) ; } if ( l == null ) { throw new Illegal Argument Exception ( STRING + l + STRING ) ; } if ( listener List == NULL ARRAY ) { listener List = new Object [ ] { t , l } ; } else { int i = listener List . length ; Object [ ] tmp = new Object [ i + NUM ] ; System . arraycopy ( listener List , NUM , tmp , NUM , i ) ; tmp [ i ] = t ; tmp [ i + NUM ] = l ; listener List = tmp ; } }
public static Array List < Object > delete Item Sets ( Array List < Object > item Sets , int min Support , int max Support ) { Array List < Object > new Vector = new Array List < Object > ( item Sets . size ( ) ) ; for ( int i = NUM ; i < item Sets . size ( ) ; i ++ ) { Item Set current = ( Item Set ) item Sets . get ( i ) ; if ( ( current . m counter >= min Support ) && ( current . m counter <= max Support ) ) { new Vector . add ( current ) ; } } return new Vector ; }
public static Array List < Object > delete Item Sets ( Array List < Object > item Sets , int min Support , int max Support ) { Array List < Object > new Vector = new Array List < Object > ( item Sets . size ( ) ) ; for ( int i = NUM ; i < item Sets . size ( ) ; i ++ ) { Item Set current = ( Item Set ) item Sets . get ( i ) ; if ( ( current . m counter >= min Support ) && ( current . m counter <= max Support ) ) { new Vector . add ( current ) ; } } return new Vector ; }
public static boolean is Processing ( ) { return is Processing ; }
public static boolean is Processing ( ) { return is Processing ; }
public static boolean is Processing ( ) { return is Processing ; }
public static boolean is Processing ( ) { return is Processing ; }
public static boolean is Processing ( ) { return is Processing ; }
public void on Consume Finished ( Purchase purchase , Iab Result result ) ;
@ Not Null public static Validation Result validate Android Ndk ( @ Nullable File ndk Path , boolean include Path In Message ) { if ( ndk Path != null ) { Wizard Utils . Validation Result wizard Validation Result = Wizard Utils . validate Location ( ndk Path . get Absolute Path ( ) , STRING , BOOL , Writable Check Mode . DO NOT CHECK ) ; if ( ! wizard Validation Result . is Ok ( ) ) { return Validation Result . error ( wizard Validation Result . get Formatted Message ( ) ) ; } } Validation Result validation Result = validated Sdk Path ( ndk Path , STRING , BOOL , include Path In Message ) ; if ( validation Result . success && ndk Path != null ) { File toolchains Dir Path = new File ( ndk Path , STRING ) ; if ( ! toolchains Dir Path . is Directory ( ) ) { String message ; if ( include Path In Message ) { message = String . format ( STRING , ndk Path . get Path ( ) ) ; } else { message = STRING ; } return Validation Result . error ( message ) ; } } return validation Result ; }
public Update Clause add Assignment ( Expression expression ) { assignments . add ( new Assignment ( expression ) ) ; return this ; }
@ Override public double transform ( double value ) { if ( value <= NUM ) { throw new Illegal Argument Exception ( STRING ) ; } return Math . log 10 ( value ) ; }
public void straight ( double x , double y ) { double dx = x - pen . x ; double dy = y - pen . y ; if ( convert To Twips ) { dx *= Swf Constants . TWIPS PER PIXEL ; dy *= Swf Constants . TWIPS PER PIXEL ; } if ( dx == NUM && dy == NUM ) { return ; } else { int intdx = ( int ) Math . rint ( dx ) ; int intdy = ( int ) Math . rint ( dy ) ; add Line Subdivide Aware ( intdx , intdy ) ; pen . x = x ; pen . y = y ; dx Sum Twips += intdx ; dy Sum Twips += intdy ; } }
public void straight ( double x , double y ) { double dx = x - pen . x ; double dy = y - pen . y ; if ( convert To Twips ) { dx *= Swf Constants . TWIPS PER PIXEL ; dy *= Swf Constants . TWIPS PER PIXEL ; } if ( dx == NUM && dy == NUM ) { return ; } else { int intdx = ( int ) Math . rint ( dx ) ; int intdy = ( int ) Math . rint ( dy ) ; add Line Subdivide Aware ( intdx , intdy ) ; pen . x = x ; pen . y = y ; dx Sum Twips += intdx ; dy Sum Twips += intdy ; } }
public void straight ( double x , double y ) { double dx = x - pen . x ; double dy = y - pen . y ; if ( convert To Twips ) { dx *= Swf Constants . TWIPS PER PIXEL ; dy *= Swf Constants . TWIPS PER PIXEL ; } if ( dx == NUM && dy == NUM ) { return ; } else { int intdx = ( int ) Math . rint ( dx ) ; int intdy = ( int ) Math . rint ( dy ) ; add Line Subdivide Aware ( intdx , intdy ) ; pen . x = x ; pen . y = y ; dx Sum Twips += intdx ; dy Sum Twips += intdy ; } }
public void straight ( double x , double y ) { double dx = x - pen . x ; double dy = y - pen . y ; if ( convert To Twips ) { dx *= Swf Constants . TWIPS PER PIXEL ; dy *= Swf Constants . TWIPS PER PIXEL ; } if ( dx == NUM && dy == NUM ) { return ; } else { int intdx = ( int ) Math . rint ( dx ) ; int intdy = ( int ) Math . rint ( dy ) ; add Line Subdivide Aware ( intdx , intdy ) ; pen . x = x ; pen . y = y ; dx Sum Twips += intdx ; dy Sum Twips += intdy ; } }
public void straight ( double x , double y ) { double dx = x - pen . x ; double dy = y - pen . y ; if ( convert To Twips ) { dx *= Swf Constants . TWIPS PER PIXEL ; dy *= Swf Constants . TWIPS PER PIXEL ; } if ( dx == NUM && dy == NUM ) { return ; } else { int intdx = ( int ) Math . rint ( dx ) ; int intdy = ( int ) Math . rint ( dy ) ; add Line Subdivide Aware ( intdx , intdy ) ; pen . x = x ; pen . y = y ; dx Sum Twips += intdx ; dy Sum Twips += intdy ; } }
public void add Exception Context ( Exception Context exception Context ) { Exception Message most Recent ; most Recent = m exception Messages . last Element ( ) ; if ( null != most Recent ) { most Recent . add Exception Context ( exception Context ) ; } else { m exception Contexts . add Element ( exception Context ) ; } if ( null != m nested Exception ) { Enumeration < ? > enumeration ; enumeration = m nested Exception . get All Exception Messages ( ) ; Exception Message exception Message ; while ( enumeration . has More Elements ( ) ) { exception Message = ( Exception Message ) enumeration . next Element ( ) ; exception Message . add Exception Context ( exception Context ) ; } } }
public void add Exception Context ( Exception Context exception Context ) { Exception Message most Recent ; most Recent = m exception Messages . last Element ( ) ; if ( null != most Recent ) { most Recent . add Exception Context ( exception Context ) ; } else { m exception Contexts . add Element ( exception Context ) ; } if ( null != m nested Exception ) { Enumeration < ? > enumeration ; enumeration = m nested Exception . get All Exception Messages ( ) ; Exception Message exception Message ; while ( enumeration . has More Elements ( ) ) { exception Message = ( Exception Message ) enumeration . next Element ( ) ; exception Message . add Exception Context ( exception Context ) ; } } }
public void add Exception Context ( Exception Context exception Context ) { Exception Message most Recent ; most Recent = m exception Messages . last Element ( ) ; if ( null != most Recent ) { most Recent . add Exception Context ( exception Context ) ; } else { m exception Contexts . add Element ( exception Context ) ; } if ( null != m nested Exception ) { Enumeration < ? > enumeration ; enumeration = m nested Exception . get All Exception Messages ( ) ; Exception Message exception Message ; while ( enumeration . has More Elements ( ) ) { exception Message = ( Exception Message ) enumeration . next Element ( ) ; exception Message . add Exception Context ( exception Context ) ; } } }
private Boolean should Connect ( final I Project project ) { Check . not Null ( project , STRING ) ; if ( ! project . is Open ( ) ) { log . debug ( Message Format . format ( STRING , project . get Name ( ) ) ) ; return null ; } String provider Name ; try { provider Name = project . get Persistent Property ( Team Utils . PROVIDER PROP KEY ) ; } catch ( final Core Exception e ) { log . warn ( Message Format . format ( STRING , project . get Name ( ) ) , e ) ; return null ; } if ( provider Name == null || ! provider Name . equals ( TFS Repository Provider . PROVIDER ID ) ) { return null ; } String repository Status = null ; try { repository Status = project . get Persistent Property ( REPOSITORY STATUS KEY ) ; } catch ( final Core Exception e ) { log . warn ( Message Format . format ( STRING , project . get Name ( ) ) , e ) ; } if ( REPOSITORY STATUS OFFLINE VALUE . equals ( repository Status ) ) { return Boolean . FALSE ; } return Boolean . TRUE ; }
private Boolean should Connect ( final I Project project ) { Check . not Null ( project , STRING ) ; if ( ! project . is Open ( ) ) { log . debug ( Message Format . format ( STRING , project . get Name ( ) ) ) ; return null ; } String provider Name ; try { provider Name = project . get Persistent Property ( Team Utils . PROVIDER PROP KEY ) ; } catch ( final Core Exception e ) { log . warn ( Message Format . format ( STRING , project . get Name ( ) ) , e ) ; return null ; } if ( provider Name == null || ! provider Name . equals ( TFS Repository Provider . PROVIDER ID ) ) { return null ; } String repository Status = null ; try { repository Status = project . get Persistent Property ( REPOSITORY STATUS KEY ) ; } catch ( final Core Exception e ) { log . warn ( Message Format . format ( STRING , project . get Name ( ) ) , e ) ; } if ( REPOSITORY STATUS OFFLINE VALUE . equals ( repository Status ) ) { return Boolean . FALSE ; } return Boolean . TRUE ; }
public boolean is Null Or Empty ( String section , String key ) { String value = get Key Value EL ( section , key ) ; return ( value == null || value . length ( ) == NUM ) ; }
@ Flaky Test ( tolerance = NUM ) public void test Popup No Selection ( ) throws Exception { Auto Complete Text View Simple the Activity = get Activity ( ) ; Auto Complete Text View text View = the Activity . get Text View ( ) ; final Instrumentation instrumentation = get Instrumentation ( ) ; text View . request Focus ( ) ; instrumentation . wait For Idle Sync ( ) ; send Keys ( STRING ) ; instrumentation . wait For Idle Sync ( ) ; Thread . sleep ( WAIT TIME ) ; assert False ( STRING , the Activity . m Item Click Called ) ; assert False ( STRING , the Activity . m Item Selected Called ) ; }
@ Flaky Test ( tolerance = NUM ) public void test Popup No Selection ( ) throws Exception { Auto Complete Text View Simple the Activity = get Activity ( ) ; Auto Complete Text View text View = the Activity . get Text View ( ) ; final Instrumentation instrumentation = get Instrumentation ( ) ; text View . request Focus ( ) ; instrumentation . wait For Idle Sync ( ) ; send Keys ( STRING ) ; instrumentation . wait For Idle Sync ( ) ; Thread . sleep ( WAIT TIME ) ; assert False ( STRING , the Activity . m Item Click Called ) ; assert False ( STRING , the Activity . m Item Selected Called ) ; }
@ Flaky Test ( tolerance = NUM ) public void test Popup No Selection ( ) throws Exception { Auto Complete Text View Simple the Activity = get Activity ( ) ; Auto Complete Text View text View = the Activity . get Text View ( ) ; final Instrumentation instrumentation = get Instrumentation ( ) ; text View . request Focus ( ) ; instrumentation . wait For Idle Sync ( ) ; send Keys ( STRING ) ; instrumentation . wait For Idle Sync ( ) ; Thread . sleep ( WAIT TIME ) ; assert False ( STRING , the Activity . m Item Click Called ) ; assert False ( STRING , the Activity . m Item Selected Called ) ; }
public static XML Input Source resolve Document ( XSD Description desc , Hashtable location Pairs , XML Entity Resolver entity Resolver ) throws IO Exception { String loc = null ; if ( desc . get Context Type ( ) == XSD Description . CONTEXT IMPORT || desc . from Instance ( ) ) { String namespace = desc . get Target Namespace ( ) ; String ns = namespace == null ? XML Symbols . EMPTY STRING : namespace ; Location Array temp LA = ( Location Array ) location Pairs . get ( ns ) ; if ( temp LA != null ) loc = temp LA . get First Location ( ) ; } if ( loc == null ) { String [ ] hints = desc . get Location Hints ( ) ; if ( hints != null && hints . length > NUM ) loc = hints [ NUM ] ; } String expanded Loc = XML Entity Manager . expand System Id ( loc , desc . get Base System Id ( ) , BOOL ) ; desc . set Literal System Id ( loc ) ; desc . set Expanded System Id ( expanded Loc ) ; return entity Resolver . resolve Entity ( desc ) ; }
public static XML Input Source resolve Document ( XSD Description desc , Hashtable location Pairs , XML Entity Resolver entity Resolver ) throws IO Exception { String loc = null ; if ( desc . get Context Type ( ) == XSD Description . CONTEXT IMPORT || desc . from Instance ( ) ) { String namespace = desc . get Target Namespace ( ) ; String ns = namespace == null ? XML Symbols . EMPTY STRING : namespace ; Location Array temp LA = ( Location Array ) location Pairs . get ( ns ) ; if ( temp LA != null ) loc = temp LA . get First Location ( ) ; } if ( loc == null ) { String [ ] hints = desc . get Location Hints ( ) ; if ( hints != null && hints . length > NUM ) loc = hints [ NUM ] ; } String expanded Loc = XML Entity Manager . expand System Id ( loc , desc . get Base System Id ( ) , BOOL ) ; desc . set Literal System Id ( loc ) ; desc . set Expanded System Id ( expanded Loc ) ; return entity Resolver . resolve Entity ( desc ) ; }
public static XML Input Source resolve Document ( XSD Description desc , Hashtable location Pairs , XML Entity Resolver entity Resolver ) throws IO Exception { String loc = null ; if ( desc . get Context Type ( ) == XSD Description . CONTEXT IMPORT || desc . from Instance ( ) ) { String namespace = desc . get Target Namespace ( ) ; String ns = namespace == null ? XML Symbols . EMPTY STRING : namespace ; Location Array temp LA = ( Location Array ) location Pairs . get ( ns ) ; if ( temp LA != null ) loc = temp LA . get First Location ( ) ; } if ( loc == null ) { String [ ] hints = desc . get Location Hints ( ) ; if ( hints != null && hints . length > NUM ) loc = hints [ NUM ] ; } String expanded Loc = XML Entity Manager . expand System Id ( loc , desc . get Base System Id ( ) , BOOL ) ; desc . set Literal System Id ( loc ) ; desc . set Expanded System Id ( expanded Loc ) ; return entity Resolver . resolve Entity ( desc ) ; }
public static XML Input Source resolve Document ( XSD Description desc , Hashtable location Pairs , XML Entity Resolver entity Resolver ) throws IO Exception { String loc = null ; if ( desc . get Context Type ( ) == XSD Description . CONTEXT IMPORT || desc . from Instance ( ) ) { String namespace = desc . get Target Namespace ( ) ; String ns = namespace == null ? XML Symbols . EMPTY STRING : namespace ; Location Array temp LA = ( Location Array ) location Pairs . get ( ns ) ; if ( temp LA != null ) loc = temp LA . get First Location ( ) ; } if ( loc == null ) { String [ ] hints = desc . get Location Hints ( ) ; if ( hints != null && hints . length > NUM ) loc = hints [ NUM ] ; } String expanded Loc = XML Entity Manager . expand System Id ( loc , desc . get Base System Id ( ) , BOOL ) ; desc . set Literal System Id ( loc ) ; desc . set Expanded System Id ( expanded Loc ) ; return entity Resolver . resolve Entity ( desc ) ; }
public static XML Input Source resolve Document ( XSD Description desc , Hashtable location Pairs , XML Entity Resolver entity Resolver ) throws IO Exception { String loc = null ; if ( desc . get Context Type ( ) == XSD Description . CONTEXT IMPORT || desc . from Instance ( ) ) { String namespace = desc . get Target Namespace ( ) ; String ns = namespace == null ? XML Symbols . EMPTY STRING : namespace ; Location Array temp LA = ( Location Array ) location Pairs . get ( ns ) ; if ( temp LA != null ) loc = temp LA . get First Location ( ) ; } if ( loc == null ) { String [ ] hints = desc . get Location Hints ( ) ; if ( hints != null && hints . length > NUM ) loc = hints [ NUM ] ; } String expanded Loc = XML Entity Manager . expand System Id ( loc , desc . get Base System Id ( ) , BOOL ) ; desc . set Literal System Id ( loc ) ; desc . set Expanded System Id ( expanded Loc ) ; return entity Resolver . resolve Entity ( desc ) ; }
public void test Add Servlet With Name And Jsp File ( ) throws Exception { String xml = WEBAPP TEST HEADER + STRING + STRING ; Web Xml web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( xml . get Bytes ( STRING ) ) , get Entity Resolver ( ) ) ; Web Xml Utils . add Jsp File ( web Xml , STRING , STRING ) ; assert True ( Web Xml Utils . has Servlet ( web Xml , STRING ) ) ; }
public void test Add Servlet With Name And Jsp File ( ) throws Exception { String xml = WEBAPP TEST HEADER + STRING + STRING ; Web Xml web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( xml . get Bytes ( STRING ) ) , get Entity Resolver ( ) ) ; Web Xml Utils . add Jsp File ( web Xml , STRING , STRING ) ; assert True ( Web Xml Utils . has Servlet ( web Xml , STRING ) ) ; }
static void stop Refresh Timer ( ) { try { if ( refresh Timer != null && mbean Server != null ) { mbean Server . unregister M Bean ( refresh Timer Object Name ) ; refresh Timer . stop ( ) ; } } catch ( JM Exception e ) { log Stack Trace ( Level . WARN , e ) ; } catch ( JM Runtime Exception e ) { log Stack Trace ( Level . WARN , e ) ; } catch ( Exception e ) { log Stack Trace ( Level . DEBUG , e , STRING ) ; } }
void expand Capacity ( int minimum Capacity ) { int new Capacity = ( value . length + NUM ) * NUM ; if ( new Capacity < NUM ) { new Capacity = Integer . MAX VALUE ; } else if ( minimum Capacity > new Capacity ) { new Capacity = minimum Capacity ; } value = Arrays . copy Of ( value , new Capacity ) ; }
void expand Capacity ( int minimum Capacity ) { int new Capacity = ( value . length + NUM ) * NUM ; if ( new Capacity < NUM ) { new Capacity = Integer . MAX VALUE ; } else if ( minimum Capacity > new Capacity ) { new Capacity = minimum Capacity ; } value = Arrays . copy Of ( value , new Capacity ) ; }
void expand Capacity ( int minimum Capacity ) { int new Capacity = ( value . length + NUM ) * NUM ; if ( new Capacity < NUM ) { new Capacity = Integer . MAX VALUE ; } else if ( minimum Capacity > new Capacity ) { new Capacity = minimum Capacity ; } value = Arrays . copy Of ( value , new Capacity ) ; }
private static String extract Error Summary ( Throwable e ) { String Builder error Message Builder = new String Builder ( ) ; Throwable cause = e ; error Message Builder . append ( cause . get Localized Message ( ) ) ; while ( cause != null ) { Stack Trace Element [ ] stack Trace Elements = cause . get Stack Trace ( ) ; error Message Builder . append ( stack Trace Elements . length > NUM ? STRING + stack Trace Elements [ NUM ] : STRING ) ; cause = cause . get Cause ( ) ; } return error Message Builder . to String ( ) ; }
static void validate ( ) { String sql = STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , null ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { validate ( rs . get Int ( NUM ) , rs . get String ( NUM ) ) ; } } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } }
public double local Score ( int i , int [ ] parents ) { double sum = NUM ; for ( B Deu Score score : scores ) { sum += score . local Score ( i , parents ) ; } return sum / scores . size ( ) ; }
public double local Score ( int i , int [ ] parents ) { double sum = NUM ; for ( B Deu Score score : scores ) { sum += score . local Score ( i , parents ) ; } return sum / scores . size ( ) ; }
public double local Score ( int i , int [ ] parents ) { double sum = NUM ; for ( B Deu Score score : scores ) { sum += score . local Score ( i , parents ) ; } return sum / scores . size ( ) ; }
public double local Score ( int i , int [ ] parents ) { double sum = NUM ; for ( B Deu Score score : scores ) { sum += score . local Score ( i , parents ) ; } return sum / scores . size ( ) ; }
public void add Near Evicted ( Key Cache Object key ) { if ( near Evicted == null ) near Evicted = new Array List < > ( ) ; near Evicted . add ( key ) ; }
public static void check Export Group For Cleanup ( Export Group export Group , Db Client db Client ) { if ( export Group != null && db Client != null ) { if ( ( export Group . check Internal Flags ( Flag . INTERNAL OBJECT ) ) && ( Collection Utils . is Empty ( export Group . get Volumes ( ) ) || Collection Utils . is Empty ( Export Mask Utils . get Export Masks ( db Client , export Group ) ) ) ) { log . info ( String . format ( STRING , export Group . get Label ( ) , export Group . get Id ( ) ) ) ; db Client . mark For Deletion ( export Group ) ; } } }
public static void check Export Group For Cleanup ( Export Group export Group , Db Client db Client ) { if ( export Group != null && db Client != null ) { if ( ( export Group . check Internal Flags ( Flag . INTERNAL OBJECT ) ) && ( Collection Utils . is Empty ( export Group . get Volumes ( ) ) || Collection Utils . is Empty ( Export Mask Utils . get Export Masks ( db Client , export Group ) ) ) ) { log . info ( String . format ( STRING , export Group . get Label ( ) , export Group . get Id ( ) ) ) ; db Client . mark For Deletion ( export Group ) ; } } }
protected boolean [ ] incremental Estimator ( ) { boolean [ ] result = new boolean [ NUM ] ; print ( STRING ) ; if ( m Estimator instanceof Incremental Estimator ) { println ( STRING ) ; result [ NUM ] = BOOL ; } else { println ( STRING ) ; result [ NUM ] = BOOL ; } return result ; }
protected boolean [ ] incremental Estimator ( ) { boolean [ ] result = new boolean [ NUM ] ; print ( STRING ) ; if ( m Estimator instanceof Incremental Estimator ) { println ( STRING ) ; result [ NUM ] = BOOL ; } else { println ( STRING ) ; result [ NUM ] = BOOL ; } return result ; }
protected boolean [ ] incremental Estimator ( ) { boolean [ ] result = new boolean [ NUM ] ; print ( STRING ) ; if ( m Estimator instanceof Incremental Estimator ) { println ( STRING ) ; result [ NUM ] = BOOL ; } else { println ( STRING ) ; result [ NUM ] = BOOL ; } return result ; }
private final String msg Stack To String ( Parse Exception e ) { String Buffer msg ; msg = new String Buffer ( STRING ) ; if ( ! expecting . equals ( empty String ) ) { msg . append ( STRING ) ; msg . append ( expecting ) ; msg . append ( STRING ) ; } msg . append ( e . get Short Message ( ) ) ; msg . append ( STRING ) ; int last = msg Stack Current Size - NUM ; if ( last < NUM ) last = NUM ; for ( int lvi = msg Stack Current Size ; lvi > last ; lvi -= NUM ) { msg . append ( ( String ) msg Stack [ lvi - NUM ] ) ; msg . append ( STRING ) ; Token t = ( Token ) msg Stack [ lvi - NUM ] ; msg . append ( t . begin Line ) ; msg . append ( STRING ) ; msg . append ( t . begin Column ) ; msg . append ( STRING ) ; } return msg . to String ( ) ; }
private final String msg Stack To String ( Parse Exception e ) { String Buffer msg ; msg = new String Buffer ( STRING ) ; if ( ! expecting . equals ( empty String ) ) { msg . append ( STRING ) ; msg . append ( expecting ) ; msg . append ( STRING ) ; } msg . append ( e . get Short Message ( ) ) ; msg . append ( STRING ) ; int last = msg Stack Current Size - NUM ; if ( last < NUM ) last = NUM ; for ( int lvi = msg Stack Current Size ; lvi > last ; lvi -= NUM ) { msg . append ( ( String ) msg Stack [ lvi - NUM ] ) ; msg . append ( STRING ) ; Token t = ( Token ) msg Stack [ lvi - NUM ] ; msg . append ( t . begin Line ) ; msg . append ( STRING ) ; msg . append ( t . begin Column ) ; msg . append ( STRING ) ; } return msg . to String ( ) ; }
private final String msg Stack To String ( Parse Exception e ) { String Buffer msg ; msg = new String Buffer ( STRING ) ; if ( ! expecting . equals ( empty String ) ) { msg . append ( STRING ) ; msg . append ( expecting ) ; msg . append ( STRING ) ; } msg . append ( e . get Short Message ( ) ) ; msg . append ( STRING ) ; int last = msg Stack Current Size - NUM ; if ( last < NUM ) last = NUM ; for ( int lvi = msg Stack Current Size ; lvi > last ; lvi -= NUM ) { msg . append ( ( String ) msg Stack [ lvi - NUM ] ) ; msg . append ( STRING ) ; Token t = ( Token ) msg Stack [ lvi - NUM ] ; msg . append ( t . begin Line ) ; msg . append ( STRING ) ; msg . append ( t . begin Column ) ; msg . append ( STRING ) ; } return msg . to String ( ) ; }
private final String msg Stack To String ( Parse Exception e ) { String Buffer msg ; msg = new String Buffer ( STRING ) ; if ( ! expecting . equals ( empty String ) ) { msg . append ( STRING ) ; msg . append ( expecting ) ; msg . append ( STRING ) ; } msg . append ( e . get Short Message ( ) ) ; msg . append ( STRING ) ; int last = msg Stack Current Size - NUM ; if ( last < NUM ) last = NUM ; for ( int lvi = msg Stack Current Size ; lvi > last ; lvi -= NUM ) { msg . append ( ( String ) msg Stack [ lvi - NUM ] ) ; msg . append ( STRING ) ; Token t = ( Token ) msg Stack [ lvi - NUM ] ; msg . append ( t . begin Line ) ; msg . append ( STRING ) ; msg . append ( t . begin Column ) ; msg . append ( STRING ) ; } return msg . to String ( ) ; }
public void delete ( ) throws IO Exception { close ( ) ; Util . delete Contents ( directory ) ; }
public void delete ( ) throws IO Exception { close ( ) ; Util . delete Contents ( directory ) ; }
public void delete ( ) throws IO Exception { close ( ) ; Util . delete Contents ( directory ) ; }
public void delete ( ) throws IO Exception { close ( ) ; Util . delete Contents ( directory ) ; }
protected void send Function Group 1 ( ) { String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; sb . append ( address . get Number ( ) ) ; sb . append ( STRING ) ; sb . append ( STRING ) ; sb . append ( ( f0 ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( STRING ) ; sb . append ( ( f1 ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( ( f2 ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( ( f3 ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( ( f4 ? STRING : STRING ) ) ; Tams Message tm = new Tams Message ( sb . to String ( ) ) ; tm . set Binary ( BOOL ) ; tm . set Reply Type ( STRING ) ; tc . send Tams Message ( tm , this ) ; tmq . add ( tm ) ; }
protected void send Function Group 1 ( ) { String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; sb . append ( address . get Number ( ) ) ; sb . append ( STRING ) ; sb . append ( STRING ) ; sb . append ( ( f0 ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( STRING ) ; sb . append ( ( f1 ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( ( f2 ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( ( f3 ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( ( f4 ? STRING : STRING ) ) ; Tams Message tm = new Tams Message ( sb . to String ( ) ) ; tm . set Binary ( BOOL ) ; tm . set Reply Type ( STRING ) ; tc . send Tams Message ( tm , this ) ; tmq . add ( tm ) ; }
protected void calculate Destination ( I File uxf , I Compilation Unit referencing Compilation Unit , Destination dest ) throws Core Exception { I File uxf Dest = calculate Img Destination ( uxf , referencing Compilation Unit ) ; if ( uxf Dest != null ) { dest . img File Destination = uxf Dest ; } }
protected void calculate Destination ( I File uxf , I Compilation Unit referencing Compilation Unit , Destination dest ) throws Core Exception { I File uxf Dest = calculate Img Destination ( uxf , referencing Compilation Unit ) ; if ( uxf Dest != null ) { dest . img File Destination = uxf Dest ; } }
protected void calculate Destination ( I File uxf , I Compilation Unit referencing Compilation Unit , Destination dest ) throws Core Exception { I File uxf Dest = calculate Img Destination ( uxf , referencing Compilation Unit ) ; if ( uxf Dest != null ) { dest . img File Destination = uxf Dest ; } }
protected void calculate Destination ( I File uxf , I Compilation Unit referencing Compilation Unit , Destination dest ) throws Core Exception { I File uxf Dest = calculate Img Destination ( uxf , referencing Compilation Unit ) ; if ( uxf Dest != null ) { dest . img File Destination = uxf Dest ; } }
public void add Undo Event ( Undo Interface event ) { if ( should Process Undo Redo Action ( ) ) { boolean at End Of List = ( current Index >= undo List . size ( ) ) ; if ( ! at End Of List ) { while ( undo List . size ( ) > current Index ) { int last Index = undo List . size ( ) - NUM ; undo List . remove ( last Index ) ; } } undo List . add ( event ) ; current Index = undo List . size ( ) ; update Menu Items ( ) ; logger . debug ( event . get String Representation ( ) ) ; } }
void remove Callback ( JS Object source , String method , boolean async ) { String key = source . to JS Pointer ( ) + STRING + method ; callbacks . remove ( key ) ; String js = STRING + source . to JS Pointer ( ) + STRING + method ; exec ( js , async ) ; }
public Queue Timeout Exception ( Task task ) { super ( Message Format . format ( STRING + STRING , task ) ) ; }
public Queue Timeout Exception ( Task task ) { super ( Message Format . format ( STRING + STRING , task ) ) ; }
public Queue Timeout Exception ( Task task ) { super ( Message Format . format ( STRING + STRING , task ) ) ; }
public void remove Protocols ( final Set < String > protocols ) { if ( protocols != null && protocols != null ) { Hash Set < String > remove Protocols = new Hash Set < String > ( ) ; remove Protocols . add All ( protocols ) ; protocols . remove All ( remove Protocols ) ; } }
public Session Property Op View Bean Base ( String name ) { super ( name ) ; create Page Title Model ( ) ; create Property Model ( ) ; register Children ( ) ; }
public < T > T as Class ( Class < T > clazz , T default Value ) { if ( value == null ) return default Value ; try { return clazz . cast ( value ) ; } catch ( Class Cast Exception e ) { return default Value ; } }
static boolean should Output ( Configuration conf ) { return conf . get Boolean ( OUTPUT FLAG , BOOL ) ; }
public void add Menu Item ( Floating Action Button item ) { m Menu Items . add ( item ) ; m Menu Item Animators . add ( new Item Animator ( item ) ) ; Text View button = new Text View ( get Context ( ) ) ; Layout Params params = new Layout Params ( Layout Params . WRAP CONTENT , Layout Params . WRAP CONTENT ) ; button . set Layout Params ( params ) ; button . set Background Resource ( R . drawable . rounded corners ) ; button . set Text Color ( Color . WHITE ) ; button . set Text ( item . get Content Description ( ) ) ; Integer padding Size = ( int ) button . get Text Size ( ) / NUM ; button . set Padding ( padding Size , padding Size , padding Size , padding Size ) ; add View ( button ) ; m Menu Item Labels . add ( button ) ; item . set Tag ( button ) ; item . set On Click Listener ( m On Item Click Listener ) ; button . set On Click Listener ( m On Item Click Listener ) ; }
private Object [ ] ensure Capacity ( int min Capacity ) { if ( tmp . length < min Capacity ) { int new Size = min Capacity ; { new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size ++ ; if ( new Size < NUM ) new Size = min Capacity ; else new Size = Math . min ( new Size , a . length > > > NUM ) ; } Object [ ] new Array = ( Object [ ] ) new Object [ new Size ] ; tmp = new Array ; } return tmp ; }
private Object [ ] ensure Capacity ( int min Capacity ) { if ( tmp . length < min Capacity ) { int new Size = min Capacity ; { new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size ++ ; if ( new Size < NUM ) new Size = min Capacity ; else new Size = Math . min ( new Size , a . length > > > NUM ) ; } Object [ ] new Array = ( Object [ ] ) new Object [ new Size ] ; tmp = new Array ; } return tmp ; }
private Object [ ] ensure Capacity ( int min Capacity ) { if ( tmp . length < min Capacity ) { int new Size = min Capacity ; { new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size ++ ; if ( new Size < NUM ) new Size = min Capacity ; else new Size = Math . min ( new Size , a . length > > > NUM ) ; } Object [ ] new Array = ( Object [ ] ) new Object [ new Size ] ; tmp = new Array ; } return tmp ; }
private Object [ ] ensure Capacity ( int min Capacity ) { if ( tmp . length < min Capacity ) { int new Size = min Capacity ; { new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size ++ ; if ( new Size < NUM ) new Size = min Capacity ; else new Size = Math . min ( new Size , a . length > > > NUM ) ; } Object [ ] new Array = ( Object [ ] ) new Object [ new Size ] ; tmp = new Array ; } return tmp ; }
public static WGL Window Surface Data create Data ( W Component Peer peer ) { if ( ! peer . is Accel Capable ( ) || ! Sun Toolkit . is Containing Top Level Opaque ( ( Component ) peer . get Target ( ) ) ) { return null ; } WGL Graphics Config gc = get GC ( peer ) ; return new WGL Window Surface Data ( peer , gc ) ; }
public static WGL Window Surface Data create Data ( W Component Peer peer ) { if ( ! peer . is Accel Capable ( ) || ! Sun Toolkit . is Containing Top Level Opaque ( ( Component ) peer . get Target ( ) ) ) { return null ; } WGL Graphics Config gc = get GC ( peer ) ; return new WGL Window Surface Data ( peer , gc ) ; }
public static WGL Window Surface Data create Data ( W Component Peer peer ) { if ( ! peer . is Accel Capable ( ) || ! Sun Toolkit . is Containing Top Level Opaque ( ( Component ) peer . get Target ( ) ) ) { return null ; } WGL Graphics Config gc = get GC ( peer ) ; return new WGL Window Surface Data ( peer , gc ) ; }
public D Distinguished Name Chooser ( J Frame parent , String title , X500 Name distinguished Name , boolean editable ) { super ( parent , title , Dialog . Modality Type . DOCUMENT MODAL ) ; this . distinguished Name = distinguished Name ; this . editable = editable ; init Components ( ) ; }
protected char [ ] preprocess ( String text ) { return text . to Char Array ( ) ; }
protected char [ ] preprocess ( String text ) { return text . to Char Array ( ) ; }
protected char [ ] preprocess ( String text ) { return text . to Char Array ( ) ; }
protected char [ ] preprocess ( String text ) { return text . to Char Array ( ) ; }
protected char [ ] preprocess ( String text ) { return text . to Char Array ( ) ; }
protected char [ ] preprocess ( String text ) { return text . to Char Array ( ) ; }
protected char [ ] preprocess ( String text ) { return text . to Char Array ( ) ; }
protected char [ ] preprocess ( String text ) { return text . to Char Array ( ) ; }
protected char [ ] preprocess ( String text ) { return text . to Char Array ( ) ; }
public static DBI Ds random Sample ( DBI Ds ids , double rate , Random random ) { if ( rate <= NUM ) { return ids ; } if ( rate < NUM ) { int size = Math . min ( ( int ) ( rate * ids . size ( ) ) , ids . size ( ) ) ; return random Sample ( ids , size , random ) ; } int size = Math . min ( ( int ) rate , ids . size ( ) ) ; return random Sample ( ids , size , random ) ; }
protected void renumber Columns ( ) { Iterator iter = m names . iterator ( ) ; for ( int idx = NUM ; iter . has Next ( ) ; ++ idx ) { String name = ( String ) iter . next ( ) ; Column Entry e = ( Column Entry ) m entries . get ( name ) ; e . colnum = idx ; } }
protected void renumber Columns ( ) { Iterator iter = m names . iterator ( ) ; for ( int idx = NUM ; iter . has Next ( ) ; ++ idx ) { String name = ( String ) iter . next ( ) ; Column Entry e = ( Column Entry ) m entries . get ( name ) ; e . colnum = idx ; } }
protected void renumber Columns ( ) { Iterator iter = m names . iterator ( ) ; for ( int idx = NUM ; iter . has Next ( ) ; ++ idx ) { String name = ( String ) iter . next ( ) ; Column Entry e = ( Column Entry ) m entries . get ( name ) ; e . colnum = idx ; } }
void mark Internal Classes ( ) { for ( int i = m Class Defs . length - NUM ; i >= NUM ; i -- ) { m Type Ids [ m Class Defs [ i ] . class Idx ] . internal = BOOL ; } for ( int i = NUM ; i < m Type Ids . length ; i ++ ) { String class Name = m Strings [ m Type Ids [ i ] . descriptor Idx ] ; if ( class Name . length ( ) == NUM ) { m Type Ids [ i ] . internal = BOOL ; } else if ( class Name . char At ( NUM ) == STRING ) { m Type Ids [ i ] . internal = BOOL ; } } }
void mark Internal Classes ( ) { for ( int i = m Class Defs . length - NUM ; i >= NUM ; i -- ) { m Type Ids [ m Class Defs [ i ] . class Idx ] . internal = BOOL ; } for ( int i = NUM ; i < m Type Ids . length ; i ++ ) { String class Name = m Strings [ m Type Ids [ i ] . descriptor Idx ] ; if ( class Name . length ( ) == NUM ) { m Type Ids [ i ] . internal = BOOL ; } else if ( class Name . char At ( NUM ) == STRING ) { m Type Ids [ i ] . internal = BOOL ; } } }
void mark Internal Classes ( ) { for ( int i = m Class Defs . length - NUM ; i >= NUM ; i -- ) { m Type Ids [ m Class Defs [ i ] . class Idx ] . internal = BOOL ; } for ( int i = NUM ; i < m Type Ids . length ; i ++ ) { String class Name = m Strings [ m Type Ids [ i ] . descriptor Idx ] ; if ( class Name . length ( ) == NUM ) { m Type Ids [ i ] . internal = BOOL ; } else if ( class Name . char At ( NUM ) == STRING ) { m Type Ids [ i ] . internal = BOOL ; } } }
private long calculate Millis For ( MPP Order Node node , long common Base ) { final Big Decimal qty = node . get Qty To Deliver ( ) ; long total Duration = + node . get Queuing Time ( ) + node . get Setup Time Required ( ) + node . get Moving Time ( ) + node . get Waiting Time ( ) ; final Big Decimal working Time = routing Service . estimate Working Time ( node , qty ) ; total Duration += working Time . double Value ( ) ; return ( long ) ( total Duration * common Base * NUM ) ; }
private long calculate Millis For ( MPP Order Node node , long common Base ) { final Big Decimal qty = node . get Qty To Deliver ( ) ; long total Duration = + node . get Queuing Time ( ) + node . get Setup Time Required ( ) + node . get Moving Time ( ) + node . get Waiting Time ( ) ; final Big Decimal working Time = routing Service . estimate Working Time ( node , qty ) ; total Duration += working Time . double Value ( ) ; return ( long ) ( total Duration * common Base * NUM ) ; }
public static Plane construct Normalized Y Plane ( final double x , final double z , final double D Value ) { if ( Math . abs ( x ) < MINIMUM RESOLUTION && Math . abs ( z ) < MINIMUM RESOLUTION ) return null ; final double denom = NUM / Math . sqrt ( x * x + z * z ) ; return new Plane ( z * denom , NUM , - x * denom , D Value ) ; }
public List < String > tokenize ( String input File Name , Print Writer writer ) { Java RDD < String > input = read Text File ( input File Name ) ; Java RDD < String > output = tokenize ( input ) ; List < String > lines = output . collect ( ) ; for ( String line : lines ) { writer . write ( line ) ; writer . write ( STRING ) ; } writer . flush ( ) ; return lines ; }
public List < String > tokenize ( String input File Name , Print Writer writer ) { Java RDD < String > input = read Text File ( input File Name ) ; Java RDD < String > output = tokenize ( input ) ; List < String > lines = output . collect ( ) ; for ( String line : lines ) { writer . write ( line ) ; writer . write ( STRING ) ; } writer . flush ( ) ; return lines ; }
private Call Location Model ( String clz , int line , Edge edge ) { super ( clz , line ) ; Soot Method target Method = edge . tgt ( ) ; String sig = target Method . get Signature ( ) ; target Method Sig = sig . substring ( NUM , sig . length ( ) - NUM ) ; }
private Call Location Model ( String clz , int line , Edge edge ) { super ( clz , line ) ; Soot Method target Method = edge . tgt ( ) ; String sig = target Method . get Signature ( ) ; target Method Sig = sig . substring ( NUM , sig . length ( ) - NUM ) ; }
public void rewind ( ) { synchronized ( used ) { for ( Parameter Pair pair : used ) { current . add Parameter ( pair . option , pair . value ) ; } used . clear ( ) ; } }
public static void save As Gnu Step ASCII ( NS Array root , File out ) throws IO Exception { File parent = out . get Parent File ( ) ; if ( ! parent . exists ( ) && ! parent . mkdirs ( ) ) { throw new IO Exception ( STRING ) ; } Output Stream Writer w = new Output Stream Writer ( new File Output Stream ( out ) , STRING ) ; w . write ( root . to Gnu Step ASCII Property List ( ) ) ; w . close ( ) ; }
public static Persistent Search Request Control new Control ( final boolean is Critical , final boolean changes Only , final boolean return E Cs , final Collection < Persistent Search Change Type > change Types ) { Reject . if Null ( change Types ) ; final Set < Persistent Search Change Type > copy Of Change Types = Enum Set . none Of ( Persistent Search Change Type . class ) ; copy Of Change Types . add All ( change Types ) ; return new Persistent Search Request Control ( is Critical , changes Only , return E Cs , Collections . unmodifiable Set ( copy Of Change Types ) ) ; }
@ Override public double prev Cumulative Quantity ( final Long wo Activity Id , Long mb Header Id ) { if ( mb Header Id == null ) mb Header Id = - NUM ; final Object [ ] params = new Object [ ] { mb Header Id , mb Header Id , Works Constants . CANCELLED STATUS , wo Activity Id } ; final Double p Quant = ( Double ) generic Service . find By Named Query ( STRING , params ) ; if ( p Quant == null ) return NUM ; else return p Quant . double Value ( ) ; }
@ Override public double prev Cumulative Quantity ( final Long wo Activity Id , Long mb Header Id ) { if ( mb Header Id == null ) mb Header Id = - NUM ; final Object [ ] params = new Object [ ] { mb Header Id , mb Header Id , Works Constants . CANCELLED STATUS , wo Activity Id } ; final Double p Quant = ( Double ) generic Service . find By Named Query ( STRING , params ) ; if ( p Quant == null ) return NUM ; else return p Quant . double Value ( ) ; }
@ Override public double prev Cumulative Quantity ( final Long wo Activity Id , Long mb Header Id ) { if ( mb Header Id == null ) mb Header Id = - NUM ; final Object [ ] params = new Object [ ] { mb Header Id , mb Header Id , Works Constants . CANCELLED STATUS , wo Activity Id } ; final Double p Quant = ( Double ) generic Service . find By Named Query ( STRING , params ) ; if ( p Quant == null ) return NUM ; else return p Quant . double Value ( ) ; }
@ Override public double prev Cumulative Quantity ( final Long wo Activity Id , Long mb Header Id ) { if ( mb Header Id == null ) mb Header Id = - NUM ; final Object [ ] params = new Object [ ] { mb Header Id , mb Header Id , Works Constants . CANCELLED STATUS , wo Activity Id } ; final Double p Quant = ( Double ) generic Service . find By Named Query ( STRING , params ) ; if ( p Quant == null ) return NUM ; else return p Quant . double Value ( ) ; }
public boolean check All Queried Messages ( boolean check , String query ) { if ( query == null || query . length ( ) == NUM ) { return check All Messages ( check , BOOL ) ; } SQ Lite Database db = get Writable Database ( ) ; if ( db != null ) { String parent Only = STRING + COL BIGPARENT + STRING + COL BIGPARENT + STRING + COL MESSAGE ID + STRING + TABLE + STRING + COL DELETED + STRING + FALSE + STRING + COL PARENT + STRING + COL MESSAGE ID + STRING + TABLE + STRING + COL DELETED + STRING + FALSE + STRING ; db . exec SQL ( STRING + TABLE + STRING + COL CHECKED + STRING + ( check ? TRUE : FALSE ) + STRING + COL DELETED + STRING + FALSE + STRING + query + parent Only + STRING ) ; return BOOL ; } return BOOL ; }
public void add Event First ( Sim Event new Event ) { new Event . set Serial ( NUM ) ; sorted Set . add ( new Event ) ; }
private boolean is Hardcoded Filename String ( String string ) { if ( string == null ) { return BOOL ; } if ( string . index Of ( ( int ) STRING ) == - NUM && string . index Of ( ( int ) STRING ) == - NUM ) { return BOOL ; } final char start Char = string . char At ( NUM ) ; if ( Character . is Letter ( start Char ) && string . char At ( NUM ) == STRING ) { return BOOL ; } if ( is XML String ( string ) ) { return BOOL ; } if ( is Date Format String ( string ) ) { return BOOL ; } if ( is URL String ( string ) ) { return BOOL ; } if ( is Media Type String ( string ) ) { return BOOL ; } return ! is Time Zone Id String ( string ) ; }
private boolean is Hardcoded Filename String ( String string ) { if ( string == null ) { return BOOL ; } if ( string . index Of ( ( int ) STRING ) == - NUM && string . index Of ( ( int ) STRING ) == - NUM ) { return BOOL ; } final char start Char = string . char At ( NUM ) ; if ( Character . is Letter ( start Char ) && string . char At ( NUM ) == STRING ) { return BOOL ; } if ( is XML String ( string ) ) { return BOOL ; } if ( is Date Format String ( string ) ) { return BOOL ; } if ( is URL String ( string ) ) { return BOOL ; } if ( is Media Type String ( string ) ) { return BOOL ; } return ! is Time Zone Id String ( string ) ; }
private boolean is Hardcoded Filename String ( String string ) { if ( string == null ) { return BOOL ; } if ( string . index Of ( ( int ) STRING ) == - NUM && string . index Of ( ( int ) STRING ) == - NUM ) { return BOOL ; } final char start Char = string . char At ( NUM ) ; if ( Character . is Letter ( start Char ) && string . char At ( NUM ) == STRING ) { return BOOL ; } if ( is XML String ( string ) ) { return BOOL ; } if ( is Date Format String ( string ) ) { return BOOL ; } if ( is URL String ( string ) ) { return BOOL ; } if ( is Media Type String ( string ) ) { return BOOL ; } return ! is Time Zone Id String ( string ) ; }
private boolean is Hardcoded Filename String ( String string ) { if ( string == null ) { return BOOL ; } if ( string . index Of ( ( int ) STRING ) == - NUM && string . index Of ( ( int ) STRING ) == - NUM ) { return BOOL ; } final char start Char = string . char At ( NUM ) ; if ( Character . is Letter ( start Char ) && string . char At ( NUM ) == STRING ) { return BOOL ; } if ( is XML String ( string ) ) { return BOOL ; } if ( is Date Format String ( string ) ) { return BOOL ; } if ( is URL String ( string ) ) { return BOOL ; } if ( is Media Type String ( string ) ) { return BOOL ; } return ! is Time Zone Id String ( string ) ; }
private boolean is Hardcoded Filename String ( String string ) { if ( string == null ) { return BOOL ; } if ( string . index Of ( ( int ) STRING ) == - NUM && string . index Of ( ( int ) STRING ) == - NUM ) { return BOOL ; } final char start Char = string . char At ( NUM ) ; if ( Character . is Letter ( start Char ) && string . char At ( NUM ) == STRING ) { return BOOL ; } if ( is XML String ( string ) ) { return BOOL ; } if ( is Date Format String ( string ) ) { return BOOL ; } if ( is URL String ( string ) ) { return BOOL ; } if ( is Media Type String ( string ) ) { return BOOL ; } return ! is Time Zone Id String ( string ) ; }
private String stringify IP ( byte [ ] ip ) { String temp = STRING ; for ( int i = NUM ; i < ip . length / NUM ; i ++ ) { temp += Integer . to String ( ip [ i ] & NUM ) + STRING ; } temp = temp . substring ( NUM , temp . length ( ) - NUM ) ; temp += STRING ; for ( int i = ip . length / NUM ; i < ip . length ; i ++ ) { temp += Integer . to String ( ip [ i ] & NUM ) + STRING ; } temp = temp . substring ( NUM , temp . length ( ) - NUM ) ; return temp ; }
public Result Set execute Query ( String sql ) throws Database Exception { Statement stmt = null ; try { stmt = connection . create Statement ( ) ; return stmt . execute Query ( sql ) ; } catch ( SQL Exception e ) { throw ( new Database Exception ( e ) ) ; } finally { try { if ( stmt != null ) { stmt . close ( ) ; } } catch ( SQL Exception e ) { } } }
public Result Set execute Query ( String sql ) throws Database Exception { Statement stmt = null ; try { stmt = connection . create Statement ( ) ; return stmt . execute Query ( sql ) ; } catch ( SQL Exception e ) { throw ( new Database Exception ( e ) ) ; } finally { try { if ( stmt != null ) { stmt . close ( ) ; } } catch ( SQL Exception e ) { } } }
@ Override public void process ( String tuple ) { if ( ! valid Tuple ( tuple ) ) { return ; } begin Process Tokens ( ) ; process Tokens ( tuple . split ( split By ) ) ; end Process Tokens ( ) ; }
@ Override public void process ( String tuple ) { if ( ! valid Tuple ( tuple ) ) { return ; } begin Process Tokens ( ) ; process Tokens ( tuple . split ( split By ) ) ; end Process Tokens ( ) ; }
protected void compute Links ( Element e ) throws Bad Location Exception { int caret Pos = get Caret Position ( ) ; try { if ( is Link ( e ) ) correct Link ( e ) ; else create Link ( e ) ; } catch ( IO Exception ex ) { ex . print Stack Trace ( ) ; } set Caret Position ( Math . min ( caret Pos , get Length ( ) ) ) ; }
public static void submit Graph Optimizer Job ( Optimizable Bipartite Graph graph , Optimizable Bipartite Graph Segment segment ) { OPTIMIZER SERVICE . submit ( new Graph Optimizer Job ( graph , segment ) ) ; }
public static void submit Graph Optimizer Job ( Optimizable Bipartite Graph graph , Optimizable Bipartite Graph Segment segment ) { OPTIMIZER SERVICE . submit ( new Graph Optimizer Job ( graph , segment ) ) ; }
public final double do Operation ( ) { final int dim = parameter . get Dimension ( ) ; double sum = NUM ; if ( uses Prior On Sum ) { for ( int i = NUM ; i < dim ; i ++ ) { sum += Math . abs ( parameter . get Parameter Value ( i ) ) ; } } final int pos = Math Utils . next Int ( dim ) ; final int value = ( int ) parameter . get Parameter Value ( pos ) ; double logq = NUM ; if ( value == NUM ) { logq = bit Flip Helper . flip Zero ( pos , dim , sum ) ; } else if ( value == NUM ) { logq = bit Flip Helper . flip One ( pos , dim , sum ) ; } else if ( value == - NUM ) { logq = bit Flip Helper . flip Neg One ( pos , dim , sum ) ; } else { throw new Runtime Exception ( STRING ) ; } if ( ! uses Prior On Sum ) { logq = NUM ; } return logq ; }
public final double do Operation ( ) { final int dim = parameter . get Dimension ( ) ; double sum = NUM ; if ( uses Prior On Sum ) { for ( int i = NUM ; i < dim ; i ++ ) { sum += Math . abs ( parameter . get Parameter Value ( i ) ) ; } } final int pos = Math Utils . next Int ( dim ) ; final int value = ( int ) parameter . get Parameter Value ( pos ) ; double logq = NUM ; if ( value == NUM ) { logq = bit Flip Helper . flip Zero ( pos , dim , sum ) ; } else if ( value == NUM ) { logq = bit Flip Helper . flip One ( pos , dim , sum ) ; } else if ( value == - NUM ) { logq = bit Flip Helper . flip Neg One ( pos , dim , sum ) ; } else { throw new Runtime Exception ( STRING ) ; } if ( ! uses Prior On Sum ) { logq = NUM ; } return logq ; }
public final double do Operation ( ) { final int dim = parameter . get Dimension ( ) ; double sum = NUM ; if ( uses Prior On Sum ) { for ( int i = NUM ; i < dim ; i ++ ) { sum += Math . abs ( parameter . get Parameter Value ( i ) ) ; } } final int pos = Math Utils . next Int ( dim ) ; final int value = ( int ) parameter . get Parameter Value ( pos ) ; double logq = NUM ; if ( value == NUM ) { logq = bit Flip Helper . flip Zero ( pos , dim , sum ) ; } else if ( value == NUM ) { logq = bit Flip Helper . flip One ( pos , dim , sum ) ; } else if ( value == - NUM ) { logq = bit Flip Helper . flip Neg One ( pos , dim , sum ) ; } else { throw new Runtime Exception ( STRING ) ; } if ( ! uses Prior On Sum ) { logq = NUM ; } return logq ; }
@ Not Null public static String capitalize ( @ Not Null String s ) { return s . is Empty ( ) ? s : ( to Upper Case ( s . char At ( NUM ) ) + s . substring ( NUM ) ) ; }
private boolean can Map Regs ( Array List < Register Spec > specs , int rop Reg ) { for ( Register Spec spec : specs ) { if ( ssa Regs Mapped . get ( spec . get Reg ( ) ) ) continue ; if ( ! can Map Reg ( spec , rop Reg ) ) return BOOL ; } return BOOL ; }
private boolean can Map Regs ( Array List < Register Spec > specs , int rop Reg ) { for ( Register Spec spec : specs ) { if ( ssa Regs Mapped . get ( spec . get Reg ( ) ) ) continue ; if ( ! can Map Reg ( spec , rop Reg ) ) return BOOL ; } return BOOL ; }
private boolean can Map Regs ( Array List < Register Spec > specs , int rop Reg ) { for ( Register Spec spec : specs ) { if ( ssa Regs Mapped . get ( spec . get Reg ( ) ) ) continue ; if ( ! can Map Reg ( spec , rop Reg ) ) return BOOL ; } return BOOL ; }
private boolean can Map Regs ( Array List < Register Spec > specs , int rop Reg ) { for ( Register Spec spec : specs ) { if ( ssa Regs Mapped . get ( spec . get Reg ( ) ) ) continue ; if ( ! can Map Reg ( spec , rop Reg ) ) return BOOL ; } return BOOL ; }
private boolean can Map Regs ( Array List < Register Spec > specs , int rop Reg ) { for ( Register Spec spec : specs ) { if ( ssa Regs Mapped . get ( spec . get Reg ( ) ) ) continue ; if ( ! can Map Reg ( spec , rop Reg ) ) return BOOL ; } return BOOL ; }
private boolean can Map Regs ( Array List < Register Spec > specs , int rop Reg ) { for ( Register Spec spec : specs ) { if ( ssa Regs Mapped . get ( spec . get Reg ( ) ) ) continue ; if ( ! can Map Reg ( spec , rop Reg ) ) return BOOL ; } return BOOL ; }
private double allowable Error ( int rank ) { int size = samples . size ( ) ; final double error = calculate Error ( rank , size ) ; final double min Error = size + NUM ; if ( error < min Error ) { return error ; } return min Error ; }
public void add Column ( Column previous Column , Column column ) { if ( column != null ) { if ( previous Column == null ) { columns . add ( NUM , column ) ; } else { columns . add ( columns . index Of ( previous Column ) , column ) ; } } }
public static Shape 3 D create Shape 3 D ( double [ ] data , int real Data Index , int [ ] strip Count , Color color , boolean filled ) { try { double [ ] new Data = new double [ real Data Index ] ; System . arraycopy ( data , NUM , new Data , NUM , real Data Index ) ; if ( filled ) { return create Filled ( new Data , strip Count , color ) ; } else { return create Edges ( new Data , color ) ; } } catch ( java . lang . Illegal Argument Exception iae ) { Debug . error ( STRING + iae . to String ( ) ) ; String Buffer sb = new String Buffer ( ) ; for ( int i = NUM ; i < strip Count . length ; i ++ ) { sb . append ( STRING + strip Count [ i ] + STRING ) ; } Debug . output ( STRING + ( filled ? STRING : STRING ) + STRING + data . length + STRING + data . length / NUM + STRING + strip Count . length + STRING + sb . to String ( ) ) ; } return null ; }
public static Shape 3 D create Shape 3 D ( double [ ] data , int real Data Index , int [ ] strip Count , Color color , boolean filled ) { try { double [ ] new Data = new double [ real Data Index ] ; System . arraycopy ( data , NUM , new Data , NUM , real Data Index ) ; if ( filled ) { return create Filled ( new Data , strip Count , color ) ; } else { return create Edges ( new Data , color ) ; } } catch ( java . lang . Illegal Argument Exception iae ) { Debug . error ( STRING + iae . to String ( ) ) ; String Buffer sb = new String Buffer ( ) ; for ( int i = NUM ; i < strip Count . length ; i ++ ) { sb . append ( STRING + strip Count [ i ] + STRING ) ; } Debug . output ( STRING + ( filled ? STRING : STRING ) + STRING + data . length + STRING + data . length / NUM + STRING + strip Count . length + STRING + sb . to String ( ) ) ; } return null ; }
@ Override protected void on Size Changed ( int w , int h , int oldw , int oldh ) { if ( ready Sent ) { set Scale And Center ( get Scale ( ) , get Center ( ) ) ; } }
private void register Default Validator Ids ( Application application , Linked Hash Set < String > default Validator Ids ) { if ( default Validator Ids == null ) { default Validator Ids = new Linked Hash Set < > ( ) ; if ( is Bean Validator Available ( ) ) { Web Configuration web Config = Web Configuration . get Instance ( ) ; if ( ! web Config . is Option Enabled ( Web Configuration . Boolean Web Context Init Parameter . Disable Default Bean Validator ) ) { default Validator Ids . add ( Bean Validator . VALIDATOR ID ) ; } } } for ( String validator Id : default Validator Ids ) { if ( LOGGER . is Loggable ( Level . FINE ) ) { LOGGER . log ( Level . FINE , Message Format . format ( STRING , validator Id ) ) ; } application . add Default Validator Id ( validator Id ) ; } }
private void register Default Validator Ids ( Application application , Linked Hash Set < String > default Validator Ids ) { if ( default Validator Ids == null ) { default Validator Ids = new Linked Hash Set < > ( ) ; if ( is Bean Validator Available ( ) ) { Web Configuration web Config = Web Configuration . get Instance ( ) ; if ( ! web Config . is Option Enabled ( Web Configuration . Boolean Web Context Init Parameter . Disable Default Bean Validator ) ) { default Validator Ids . add ( Bean Validator . VALIDATOR ID ) ; } } } for ( String validator Id : default Validator Ids ) { if ( LOGGER . is Loggable ( Level . FINE ) ) { LOGGER . log ( Level . FINE , Message Format . format ( STRING , validator Id ) ) ; } application . add Default Validator Id ( validator Id ) ; } }
private void register Default Validator Ids ( Application application , Linked Hash Set < String > default Validator Ids ) { if ( default Validator Ids == null ) { default Validator Ids = new Linked Hash Set < > ( ) ; if ( is Bean Validator Available ( ) ) { Web Configuration web Config = Web Configuration . get Instance ( ) ; if ( ! web Config . is Option Enabled ( Web Configuration . Boolean Web Context Init Parameter . Disable Default Bean Validator ) ) { default Validator Ids . add ( Bean Validator . VALIDATOR ID ) ; } } } for ( String validator Id : default Validator Ids ) { if ( LOGGER . is Loggable ( Level . FINE ) ) { LOGGER . log ( Level . FINE , Message Format . format ( STRING , validator Id ) ) ; } application . add Default Validator Id ( validator Id ) ; } }
public Connection Acceptor ( TCP Transport transport ) { this . transport = transport ; }
public Connection Acceptor ( TCP Transport transport ) { this . transport = transport ; }
public Connection Acceptor ( TCP Transport transport ) { this . transport = transport ; }
@ Override public boolean add ( I Message message ) { return add ( message , BOOL ) ; }
@ Override public boolean add ( I Message message ) { return add ( message , BOOL ) ; }
@ Override public String to String ( ) { String Builder string Builder = new String Builder ( STRING ) ; for ( Node Collection parent : parents ) { string Builder . append ( parent . get Id ( ) + STRING ) ; } string Builder . append ( STRING ) ; for ( Node Collection child : children ) { string Builder . append ( child . get Id ( ) + STRING ) ; } string Builder . append ( STRING ) ; return string Builder . to String ( ) ; }
@ Override public String to String ( ) { String Builder string Builder = new String Builder ( STRING ) ; for ( Node Collection parent : parents ) { string Builder . append ( parent . get Id ( ) + STRING ) ; } string Builder . append ( STRING ) ; for ( Node Collection child : children ) { string Builder . append ( child . get Id ( ) + STRING ) ; } string Builder . append ( STRING ) ; return string Builder . to String ( ) ; }
@ Override public String to String ( ) { String Builder string Builder = new String Builder ( STRING ) ; for ( Node Collection parent : parents ) { string Builder . append ( parent . get Id ( ) + STRING ) ; } string Builder . append ( STRING ) ; for ( Node Collection child : children ) { string Builder . append ( child . get Id ( ) + STRING ) ; } string Builder . append ( STRING ) ; return string Builder . to String ( ) ; }
@ Override public String to String ( ) { String Builder string Builder = new String Builder ( STRING ) ; for ( Node Collection parent : parents ) { string Builder . append ( parent . get Id ( ) + STRING ) ; } string Builder . append ( STRING ) ; for ( Node Collection child : children ) { string Builder . append ( child . get Id ( ) + STRING ) ; } string Builder . append ( STRING ) ; return string Builder . to String ( ) ; }
@ Override public String to String ( ) { String Builder string Builder = new String Builder ( STRING ) ; for ( Node Collection parent : parents ) { string Builder . append ( parent . get Id ( ) + STRING ) ; } string Builder . append ( STRING ) ; for ( Node Collection child : children ) { string Builder . append ( child . get Id ( ) + STRING ) ; } string Builder . append ( STRING ) ; return string Builder . to String ( ) ; }
public void test Create Attribute NS 2 ( ) throws Throwable { Document doc ; Attr attribute 1 ; Attr attribute 2 ; String name ; String node Name ; String node Value ; String prefix ; String namespace URI ; doc = ( Document ) load ( STRING , builder ) ; attribute 1 = doc . create Attribute NS ( STRING , STRING ) ; name = attribute 1 . get Name ( ) ; node Name = attribute 1 . get Node Name ( ) ; node Value = attribute 1 . get Node Value ( ) ; prefix = attribute 1 . get Prefix ( ) ; namespace URI = attribute 1 . get Namespace URI ( ) ; assert Equals ( STRING , STRING , name ) ; assert Equals ( STRING , STRING , node Name ) ; assert Equals ( STRING , STRING , node Value ) ; assert Equals ( STRING , STRING , prefix ) ; assert Equals ( STRING , STRING , namespace URI ) ; attribute 2 = doc . create Attribute NS ( STRING , STRING ) ; name = attribute 2 . get Name ( ) ; node Name = attribute 2 . get Node Name ( ) ; node Value = attribute 2 . get Node Value ( ) ; prefix = attribute 2 . get Prefix ( ) ; namespace URI = attribute 2 . get Namespace URI ( ) ; assert Equals ( STRING , STRING , name ) ; assert Equals ( STRING , STRING , node Name ) ; assert Equals ( STRING , STRING , node Value ) ; assert Equals ( STRING , STRING , namespace URI ) ; }
public int checksum ts ( ) { return calculate Checksum ( compile checksum . to String ( ) + compile checksum ts . to String ( ) ) ; }
public int checksum ts ( ) { return calculate Checksum ( compile checksum . to String ( ) + compile checksum ts . to String ( ) ) ; }
private General Name create General Name ( String t , String v ) throws Exception { General Name Interface gn ; int p = one Of ( t , STRING , STRING , STRING , STRING , STRING ) ; if ( p < NUM ) { throw new Exception ( rb . get String ( STRING ) + t ) ; } switch ( p ) { case NUM : gn = new RFC 822 Name ( v ) ; break ; case NUM : gn = new URI Name ( v ) ; break ; case NUM : gn = new DNS Name ( v ) ; break ; case NUM : gn = new IP Address Name ( v ) ; break ; default : gn = new OID Name ( v ) ; break ; } return new General Name ( gn ) ; }
@ Override public void modify Member Ship ( SSO Token token , Id Type type , String name , Set < String > members , Id Type members Type , int operation ) throws Id Repo Exception { if ( DEBUG . message Enabled ( ) ) { DEBUG . message ( STRING ) ; } if ( members == null || members . is Empty ( ) ) { throw new Id Repo Exception ( Id Repo Error Code . ILLEGAL ARGUMENTS ) ; } if ( type . equals ( Id Type . USER ) ) { throw new Id Repo Exception ( Id Repo Error Code . MEMBERSHIP TO USERS AND AGENTS NOT ALLOWED ) ; } if ( ! members Type . equals ( Id Type . USER ) ) { throw new Id Repo Exception ( Id Repo Error Code . MEMBERSHIPS FOR NOT USERS NOT ALLOWED , CLASS NAME ) ; } String dn = get DN ( type , name ) ; Set < String > member D Ns = new Hash Set < > ( members . size ( ) ) ; for ( String member : members ) { member D Ns . add ( get DN ( members Type , member ) ) ; } if ( type . equals ( Id Type . GROUP ) ) { modify Group Membership ( dn , member D Ns , operation ) ; } else if ( type . equals ( Id Type . ROLE ) ) { modify Role Membership ( dn , member D Ns , operation ) ; } else { throw new Id Repo Exception ( Id Repo Error Code . MEMBERSHIP CANNOT BE MODIFIED , CLASS NAME , type . get Name ( ) ) ; } }
private Template Value template Value ( String value ) { Template Value template Val = new Template File . Template Value ( null ) ; template Val . append ( value ) ; return template Val ; }
private boolean annotation Property Set ( Annotation annotation , String attribute Name ) { Object default Value = Annotation Utils . get Default Value ( annotation , attribute Name ) ; Object current Value = Annotation Utils . get Value ( annotation , attribute Name ) ; return ! current Value . equals ( default Value ) ; }
public static void add Activity Listener ( Activity Listener listener ) { if ( listener != null ) { start Tracking ( ) ; listeners . add ( listener ) ; } }
public static void add Activity Listener ( Activity Listener listener ) { if ( listener != null ) { start Tracking ( ) ; listeners . add ( listener ) ; } }
public void parse Element ( String tag Name , Map < String , Object > attrs ) { if ( canvas == null && tag Name . equals Ignore Case ( STRING ) ) { scale = mx Utils . get Double ( attrs , STRING , NUM ) ; canvas = create Canvas ( attrs ) ; if ( canvas != null ) { canvas . set Scale ( scale ) ; } } else if ( canvas != null ) { boolean draw Label = BOOL ; if ( tag Name . equals Ignore Case ( STRING ) || tag Name . equals Ignore Case ( STRING ) ) { draw Vertex ( attrs ) ; draw Label = BOOL ; } else if ( tag Name . equals Ignore Case ( STRING ) ) { draw Edge ( attrs ) ; draw Label = BOOL ; } if ( draw Label ) { draw Label ( tag Name . equals Ignore Case ( STRING ) , attrs ) ; } } }
public String make Literal ( Object object , boolean single Quote ) { String Builder sb = new String Builder ( ) ; make Literal ( sb , object , single Quote ) ; return sb . to String ( ) ; }
public static Point 2 D intersect Param ( Point 2 D u0 , Point 2 D v0 , Point 2 D u1 , Point 2 D v1 ) { double det = determinant 2 by 2 ( v1 , v0 ) ; if ( Double . is Na N ( det ) || det == NUM ) { return null ; } double x00 = u0 . get X ( ) ; double y00 = u0 . get Y ( ) ; double x10 = u1 . get X ( ) ; double y10 = u1 . get Y ( ) ; double x01 = v0 . get X ( ) ; double y01 = v0 . get Y ( ) ; double x11 = v1 . get X ( ) ; double y11 = v1 . get Y ( ) ; double s = ( NUM / det ) * ( ( x00 - x10 ) * y01 - ( y00 - y10 ) * x01 ) ; double t = ( NUM / det ) * - ( - ( x00 - x10 ) * y11 + ( y00 - y10 ) * x11 ) ; return new java . awt . geom . Point 2 D . Double ( t , s ) ; }
public static Private Key private Key From Pkcs 8 ( String private Key Pem ) throws IO Exception { String Reader reader = new String Reader ( private Key Pem ) ; Section section = Pem Reader . read First Section And Close ( reader , PRIVATE KEY ) ; if ( section == null ) { throw new IO Exception ( STRING ) ; } try { byte [ ] decoded Key = section . get Base 64 Decoded Bytes ( ) ; PKCS 8 Encoded Key Spec key Spec = new PKCS 8 Encoded Key Spec ( decoded Key ) ; Key Factory key Factory = Security Utils . get Rsa Key Factory ( ) ; return key Factory . generate Private ( key Spec ) ; } catch ( Exception e ) { throw new IO Exception ( STRING , e ) ; } }
public static Private Key private Key From Pkcs 8 ( String private Key Pem ) throws IO Exception { String Reader reader = new String Reader ( private Key Pem ) ; Section section = Pem Reader . read First Section And Close ( reader , PRIVATE KEY ) ; if ( section == null ) { throw new IO Exception ( STRING ) ; } try { byte [ ] decoded Key = section . get Base 64 Decoded Bytes ( ) ; PKCS 8 Encoded Key Spec key Spec = new PKCS 8 Encoded Key Spec ( decoded Key ) ; Key Factory key Factory = Security Utils . get Rsa Key Factory ( ) ; return key Factory . generate Private ( key Spec ) ; } catch ( Exception e ) { throw new IO Exception ( STRING , e ) ; } }
protected void create Renderers ( Combined Chart chart , Chart Animator animator , View Port Handler view Port Handler ) { m Renderers = new Array List < Data Renderer > ( ) ; Draw Order [ ] orders = chart . get Draw Order ( ) ; for ( Draw Order order : orders ) { switch ( order ) { case BAR : if ( chart . get Bar Data ( ) != null ) m Renderers . add ( new Bar Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case LINE : if ( chart . get Line Data ( ) != null ) m Renderers . add ( new Line Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case CANDLE : if ( chart . get Candle Data ( ) != null ) m Renderers . add ( new Candle Stick Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case SCATTER : if ( chart . get Scatter Data ( ) != null ) m Renderers . add ( new Scatter Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; } } }
protected void create Renderers ( Combined Chart chart , Chart Animator animator , View Port Handler view Port Handler ) { m Renderers = new Array List < Data Renderer > ( ) ; Draw Order [ ] orders = chart . get Draw Order ( ) ; for ( Draw Order order : orders ) { switch ( order ) { case BAR : if ( chart . get Bar Data ( ) != null ) m Renderers . add ( new Bar Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case LINE : if ( chart . get Line Data ( ) != null ) m Renderers . add ( new Line Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case CANDLE : if ( chart . get Candle Data ( ) != null ) m Renderers . add ( new Candle Stick Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case SCATTER : if ( chart . get Scatter Data ( ) != null ) m Renderers . add ( new Scatter Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; } } }
public static boolean cancel Potential Work ( Object data , Image View image View ) { final Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final Object bitmap Data = bitmap Worker Task . m Data ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( BOOL ) ; Log . d ( TAG , STRING + data ) ; } else { return BOOL ; } } return BOOL ; }
public static boolean cancel Potential Work ( Object data , Image View image View ) { final Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final Object bitmap Data = bitmap Worker Task . m Data ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( BOOL ) ; Log . d ( TAG , STRING + data ) ; } else { return BOOL ; } } return BOOL ; }
public static boolean cancel Potential Work ( Object data , Image View image View ) { final Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final Object bitmap Data = bitmap Worker Task . m Data ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( BOOL ) ; Log . d ( TAG , STRING + data ) ; } else { return BOOL ; } } return BOOL ; }
public Instance Process exec ( String workspace Id , String machine Id , Command command , @ Nullable String output Channel ) throws Not Found Exception , Machine Exception , Bad Request Exception { required Not Null ( machine Id , STRING ) ; required Not Null ( command , STRING ) ; required Not Null ( command . get Command Line ( ) , STRING ) ; required Not Null ( command . get Name ( ) , STRING ) ; required Not Null ( command . get Type ( ) , STRING ) ; final Instance machine = environment Engine . get Machine ( workspace Id , machine Id ) ; final Instance Process instance Process = machine . create Process ( command , output Channel ) ; final int pid = instance Process . get Pid ( ) ; final Line Consumer process Logger = get Process Logger ( machine Id , pid , output Channel ) ; executor . execute ( Thread Local Propagate Context . wrap ( null ) ) ; return instance Process ; }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . POST ) @ Response Body public Rest Wrapper update ( @ Model Attribute ( STRING ) @ Valid App Deployment Queue Status adq Status , Binding Result binding Result , Principal principal ) { LOGGER . debug ( STRING ) ; Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) { Binding Result Error binding Result Error = new Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { com . wipro . ats . bdre . md . dao . jpa . App Deployment Queue Status jpa Adq Status = new com . wipro . ats . bdre . md . dao . jpa . App Deployment Queue Status ( ) ; jpa Adq Status . set Description ( adq Status . get Description ( ) ) ; app Deployment Queue Status DAO . update ( jpa Adq Status ) ; LOGGER . debug ( STRING + jpa Adq Status . get App Deployment Status Id ( ) ) ; LOGGER . debug ( STRING ) ; rest Wrapper = new Rest Wrapper ( adq Status , Rest Wrapper . OK ) ; LOGGER . info ( RECORDWITHID + adq Status . get App Deployment Status Id ( ) + STRING + principal . get Name ( ) + adq Status ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; return new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . POST ) @ Response Body public Rest Wrapper update ( @ Model Attribute ( STRING ) @ Valid App Deployment Queue Status adq Status , Binding Result binding Result , Principal principal ) { LOGGER . debug ( STRING ) ; Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) { Binding Result Error binding Result Error = new Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { com . wipro . ats . bdre . md . dao . jpa . App Deployment Queue Status jpa Adq Status = new com . wipro . ats . bdre . md . dao . jpa . App Deployment Queue Status ( ) ; jpa Adq Status . set Description ( adq Status . get Description ( ) ) ; app Deployment Queue Status DAO . update ( jpa Adq Status ) ; LOGGER . debug ( STRING + jpa Adq Status . get App Deployment Status Id ( ) ) ; LOGGER . debug ( STRING ) ; rest Wrapper = new Rest Wrapper ( adq Status , Rest Wrapper . OK ) ; LOGGER . info ( RECORDWITHID + adq Status . get App Deployment Status Id ( ) + STRING + principal . get Name ( ) + adq Status ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; return new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
public void send User Delete Notification ( Map attributes ) { try { if ( delete Notify List != null && ! delete Notify List . is Empty ( ) ) { send Email ( delete Notify List , attributes , STRING , STRING , STRING ) ; } } catch ( Messaging Exception e ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STRING + STRING + STRING + entry DN , e ) ; } } }
public final void hack Gravity ( double rsize , Node root ) { Math Vector pos 0 = ( Math Vector ) pos . clone ( ) ; HG hg = new HG ( this , pos ) ; hg = root . walk Sub Tree ( rsize * rsize , hg ) ; phi = hg . phi 0 ; new Acc = hg . acc 0 ; }
public final void hack Gravity ( double rsize , Node root ) { Math Vector pos 0 = ( Math Vector ) pos . clone ( ) ; HG hg = new HG ( this , pos ) ; hg = root . walk Sub Tree ( rsize * rsize , hg ) ; phi = hg . phi 0 ; new Acc = hg . acc 0 ; }
public final void hack Gravity ( double rsize , Node root ) { Math Vector pos 0 = ( Math Vector ) pos . clone ( ) ; HG hg = new HG ( this , pos ) ; hg = root . walk Sub Tree ( rsize * rsize , hg ) ; phi = hg . phi 0 ; new Acc = hg . acc 0 ; }
@ Override public void read External ( Object Input in ) throws IO Exception { b = new double [ in . read Int ( ) ] ; for ( int p = NUM ; p < b . length ; p ++ ) { b [ p ] = in . read Double ( ) ; } }
@ Override public void read External ( Object Input in ) throws IO Exception { b = new double [ in . read Int ( ) ] ; for ( int p = NUM ; p < b . length ; p ++ ) { b [ p ] = in . read Double ( ) ; } }
@ Override public void read External ( Object Input in ) throws IO Exception { b = new double [ in . read Int ( ) ] ; for ( int p = NUM ; p < b . length ; p ++ ) { b [ p ] = in . read Double ( ) ; } }
@ Override public void read External ( Object Input in ) throws IO Exception { b = new double [ in . read Int ( ) ] ; for ( int p = NUM ; p < b . length ; p ++ ) { b [ p ] = in . read Double ( ) ; } }
@ Override public void read External ( Object Input in ) throws IO Exception { b = new double [ in . read Int ( ) ] ; for ( int p = NUM ; p < b . length ; p ++ ) { b [ p ] = in . read Double ( ) ; } }
@ Override public void read External ( Object Input in ) throws IO Exception { b = new double [ in . read Int ( ) ] ; for ( int p = NUM ; p < b . length ; p ++ ) { b [ p ] = in . read Double ( ) ; } }
public void randomize Incoming Weights ( ) { for ( Neuron n : get Neuron List ( ) ) { for ( Synapse s : n . get Fan In ( ) ) { s . set Lower Bound ( NUM ) ; s . set Strength ( s . get Upper Bound ( ) * Math . random ( ) ) ; } } }
public void randomize Incoming Weights ( ) { for ( Neuron n : get Neuron List ( ) ) { for ( Synapse s : n . get Fan In ( ) ) { s . set Lower Bound ( NUM ) ; s . set Strength ( s . get Upper Bound ( ) * Math . random ( ) ) ; } } }
private static List < String [ ] > read Sentence ( Buffered Reader a Reader ) throws IO Exception { List < String [ ] > words = new Array List < String [ ] > ( ) ; String line ; while ( ( line = a Reader . read Line ( ) ) != null ) { if ( String Utils . is Blank ( line ) ) { break ; } if ( line . starts With ( STRING ) ) { continue ; } String [ ] fields = line . split ( STRING ) ; if ( fields . length != NUM ) { throw new IO Exception ( STRING ) ; } words . add ( fields ) ; } if ( line == null && words . is Empty ( ) ) { return null ; } else { return words ; } }
public void write Gpx File ( String track Name , D Btracking Points db , File gpx File ) throws IO Exception { String METADATA = STRING + STRING + STRING + STRING + STRING + DF . format ( System . current Time Millis ( ) ) + STRING + STRING ; if ( ! gpx File . exists ( ) ) { gpx File . create New File ( ) ; } File Writer fw = new File Writer ( gpx File ) ; fw . write ( XML HEADER + STRING ) ; fw . write ( TAG GPX + STRING ) ; fw . write ( METADATA + STRING ) ; write Track Points ( track Name , fw , db ) ; fw . write ( STRING ) ; fw . close ( ) ; }
private void two Way Merge Internal ( final Reservoir Items Sketch < T > sketch In , final boolean is Modifiable ) { if ( sketch In . get N ( ) <= sketch In . get K ( ) ) { two Way Merge Internal Standard ( sketch In ) ; } else if ( gadget . get N ( ) < gadget . get K ( ) ) { final Reservoir Items Sketch < T > tmp Sketch = gadget ; gadget = ( is Modifiable ? sketch In : sketch In . copy ( ) ) ; two Way Merge Internal Standard ( tmp Sketch ) ; } else if ( sketch In . get Implicit Sample Weight ( ) < gadget . get N ( ) / ( ( double ) ( gadget . get K ( ) - NUM ) ) ) { two Way Merge Internal Weighted ( sketch In ) ; } else { final Reservoir Items Sketch < T > tmp Sketch = gadget ; gadget = ( is Modifiable ? sketch In : sketch In . copy ( ) ) ; two Way Merge Internal Weighted ( tmp Sketch ) ; } }
private void two Way Merge Internal ( final Reservoir Items Sketch < T > sketch In , final boolean is Modifiable ) { if ( sketch In . get N ( ) <= sketch In . get K ( ) ) { two Way Merge Internal Standard ( sketch In ) ; } else if ( gadget . get N ( ) < gadget . get K ( ) ) { final Reservoir Items Sketch < T > tmp Sketch = gadget ; gadget = ( is Modifiable ? sketch In : sketch In . copy ( ) ) ; two Way Merge Internal Standard ( tmp Sketch ) ; } else if ( sketch In . get Implicit Sample Weight ( ) < gadget . get N ( ) / ( ( double ) ( gadget . get K ( ) - NUM ) ) ) { two Way Merge Internal Weighted ( sketch In ) ; } else { final Reservoir Items Sketch < T > tmp Sketch = gadget ; gadget = ( is Modifiable ? sketch In : sketch In . copy ( ) ) ; two Way Merge Internal Weighted ( tmp Sketch ) ; } }
public double continue To Margin ( double [ ] origin , double [ ] delta ) { assert ( delta . length == NUM && origin . length == NUM ) ; double factor = Double . POSITIVE INFINITY ; if ( delta [ NUM ] > NUM ) { factor = Math . min ( factor , ( maxx - origin [ NUM ] ) / delta [ NUM ] ) ; } else if ( delta [ NUM ] < NUM ) { factor = Math . min ( factor , ( origin [ NUM ] - minx ) / - delta [ NUM ] ) ; } if ( delta [ NUM ] > NUM ) { factor = Math . min ( factor , ( maxy - origin [ NUM ] ) / delta [ NUM ] ) ; } else if ( delta [ NUM ] < NUM ) { factor = Math . min ( factor , ( origin [ NUM ] - miny ) / - delta [ NUM ] ) ; } return factor ; }
@ Nullable public static Pair < String , String > split Jar Url ( @ Not Null String url ) { int pivot = url . index Of ( JAR SEPARATOR ) ; if ( pivot < NUM ) return null ; String resource Path = url . substring ( pivot + NUM ) ; String jar Path = url . substring ( NUM , pivot ) ; if ( String Util . starts With Concatenation ( jar Path , JAR PROTOCOL , STRING ) ) { jar Path = jar Path . substring ( JAR PROTOCOL . length ( ) + NUM ) ; } if ( jar Path . starts With ( FILE PROTOCOL ) ) { jar Path = jar Path . substring ( FILE PROTOCOL . length ( ) ) ; if ( jar Path . starts With ( SCHEME SEPARATOR ) ) { jar Path = jar Path . substring ( SCHEME SEPARATOR . length ( ) ) ; } else if ( String Util . starts With Char ( jar Path , STRING ) ) { jar Path = jar Path . substring ( NUM ) ; } } return Pair . create ( jar Path , resource Path ) ; }
@ Nullable public static Pair < String , String > split Jar Url ( @ Not Null String url ) { int pivot = url . index Of ( JAR SEPARATOR ) ; if ( pivot < NUM ) return null ; String resource Path = url . substring ( pivot + NUM ) ; String jar Path = url . substring ( NUM , pivot ) ; if ( String Util . starts With Concatenation ( jar Path , JAR PROTOCOL , STRING ) ) { jar Path = jar Path . substring ( JAR PROTOCOL . length ( ) + NUM ) ; } if ( jar Path . starts With ( FILE PROTOCOL ) ) { jar Path = jar Path . substring ( FILE PROTOCOL . length ( ) ) ; if ( jar Path . starts With ( SCHEME SEPARATOR ) ) { jar Path = jar Path . substring ( SCHEME SEPARATOR . length ( ) ) ; } else if ( String Util . starts With Char ( jar Path , STRING ) ) { jar Path = jar Path . substring ( NUM ) ; } } return Pair . create ( jar Path , resource Path ) ; }
@ Nullable public static Pair < String , String > split Jar Url ( @ Not Null String url ) { int pivot = url . index Of ( JAR SEPARATOR ) ; if ( pivot < NUM ) return null ; String resource Path = url . substring ( pivot + NUM ) ; String jar Path = url . substring ( NUM , pivot ) ; if ( String Util . starts With Concatenation ( jar Path , JAR PROTOCOL , STRING ) ) { jar Path = jar Path . substring ( JAR PROTOCOL . length ( ) + NUM ) ; } if ( jar Path . starts With ( FILE PROTOCOL ) ) { jar Path = jar Path . substring ( FILE PROTOCOL . length ( ) ) ; if ( jar Path . starts With ( SCHEME SEPARATOR ) ) { jar Path = jar Path . substring ( SCHEME SEPARATOR . length ( ) ) ; } else if ( String Util . starts With Char ( jar Path , STRING ) ) { jar Path = jar Path . substring ( NUM ) ; } } return Pair . create ( jar Path , resource Path ) ; }
public static void write Properties ( Properties props , Output Stream out , boolean include Defaults ) throws IO Exception { if ( include Defaults ) { Properties all = new Properties ( ) ; Enumeration < ? > prop Names = props . property Names ( ) ; while ( prop Names . has More Elements ( ) ) { String prop Name = ( String ) prop Names . next Element ( ) ; String prop Value = props . get Property ( prop Name ) ; all . put ( prop Name , prop Value ) ; } props = all ; } try { props . store ( out , null ) ; } finally { out . close ( ) ; } }
public synchronized void ensure Capacity ( int minimum Capacity ) { if ( element Data . length < minimum Capacity ) { int next = ( capacity Increment <= NUM ? element Data . length : capacity Increment ) + element Data . length ; grow ( minimum Capacity > next ? minimum Capacity : next ) ; } }
public synchronized void ensure Capacity ( int minimum Capacity ) { if ( element Data . length < minimum Capacity ) { int next = ( capacity Increment <= NUM ? element Data . length : capacity Increment ) + element Data . length ; grow ( minimum Capacity > next ? minimum Capacity : next ) ; } }
public static int compare ( String left , boolean right ) { if ( Decision . is Boolean ( left ) ) return compare ( Caster . to Boolean Value ( left , BOOL ) , right ) ; if ( Decision . is Number ( left ) ) return compare ( Caster . to Double Value ( left , Double . Na N ) , right ? NUM : NUM ) ; if ( left . length ( ) == NUM ) return - NUM ; char left First = left . char At ( NUM ) ; if ( left First >= STRING && left First <= STRING ) return left . compare To Ignore Case ( Caster . to String ( right ? NUM : NUM ) ) ; return left First - STRING ; }
public static Buffered Input Stream new Input Stream ( URL url ) throws Malformed URL Exception , IO Exception { return new Buffered Input Stream ( configured Input Stream ( null , url ) ) ; }
public final Tree Set < Awtree Object > find overlap objects ( Shape Convex p shape , int p layer , Net Nos List p ignore net nos ) { Tree Set < Awtree Object > risul = new Tree Set < Awtree Object > ( ) ; Collection < Awtree Find Entry > tree entries = find overlap tree entries ( p shape , p layer , p ignore net nos ) ; for ( Awtree Find Entry curr entry : tree entries ) risul . add ( curr entry . object ) ; return risul ; }
public S Graph Item Provider Adapter Factory ( ) { supported Types . add ( I Editing Domain Item Provider . class ) ; supported Types . add ( I Structured Item Content Provider . class ) ; supported Types . add ( I Tree Item Content Provider . class ) ; supported Types . add ( I Item Label Provider . class ) ; supported Types . add ( I Item Property Source . class ) ; }
public S Graph Item Provider Adapter Factory ( ) { supported Types . add ( I Editing Domain Item Provider . class ) ; supported Types . add ( I Structured Item Content Provider . class ) ; supported Types . add ( I Tree Item Content Provider . class ) ; supported Types . add ( I Item Label Provider . class ) ; supported Types . add ( I Item Property Source . class ) ; }
public char char At ( int index ) { return internal . char At ( index ) ; }
@ Suppress Warnings ( STRING ) public < T extends PO > T first Only ( ) throws DB Exception { T po = null ; String sql = build SQL ( null , BOOL ) ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , trx Name ) ; rs = create Result Set ( pstmt ) ; if ( rs . next ( ) ) { po = ( T ) table . get PO ( rs , trx Name ) ; } if ( rs . next ( ) ) { throw new DB Exception ( STRING ) ; } } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; throw new DB Exception ( e , sql ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return po ; }
private void add Term ( String term ) { Integer index = term To Index . get ( term ) ; if ( index == null ) { synchronized ( this ) { index = term To Index . get ( term ) ; if ( index == null ) { index = Integer . value Of ( term Index Counter . get And Increment ( ) ) ; term To Index . put ( term , index ) ; } } } }
private void add Term ( String term ) { Integer index = term To Index . get ( term ) ; if ( index == null ) { synchronized ( this ) { index = term To Index . get ( term ) ; if ( index == null ) { index = Integer . value Of ( term Index Counter . get And Increment ( ) ) ; term To Index . put ( term , index ) ; } } } }
private void add Term ( String term ) { Integer index = term To Index . get ( term ) ; if ( index == null ) { synchronized ( this ) { index = term To Index . get ( term ) ; if ( index == null ) { index = Integer . value Of ( term Index Counter . get And Increment ( ) ) ; term To Index . put ( term , index ) ; } } } }
private void add Term ( String term ) { Integer index = term To Index . get ( term ) ; if ( index == null ) { synchronized ( this ) { index = term To Index . get ( term ) ; if ( index == null ) { index = Integer . value Of ( term Index Counter . get And Increment ( ) ) ; term To Index . put ( term , index ) ; } } } }
private Mime Message find Message ( String key ) { Mime Message found Message ; found Message = select Message ( key ) ; if ( found Message == null ) { m List = null ; load Keys ( ) ; found Message = select Message ( key ) ; } return found Message ; }
private Mime Message find Message ( String key ) { Mime Message found Message ; found Message = select Message ( key ) ; if ( found Message == null ) { m List = null ; load Keys ( ) ; found Message = select Message ( key ) ; } return found Message ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = enum To Vector ( super . list Options ( ) ) ; result . add Element ( new Option ( STRING + default Num Clusters ( ) + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + default Min Inst Num ( ) + STRING + default Max Inst Num ( ) + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + default Min Radius ( ) + STRING + default Max Radius ( ) + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + default Dist Mult ( ) + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + default Num Cycles ( ) + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + default Noise Rate ( ) + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = enum To Vector ( super . list Options ( ) ) ; result . add Element ( new Option ( STRING + default Num Clusters ( ) + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + default Min Inst Num ( ) + STRING + default Max Inst Num ( ) + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + default Min Radius ( ) + STRING + default Max Radius ( ) + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + default Dist Mult ( ) + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + default Num Cycles ( ) + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + default Noise Rate ( ) + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
public static synchronized void add Resource ( Recoverable Resource resource ) throws Illegal State Exception { purge Resources ( ) ; if ( resources . contains Key ( resource . get Name ( ) ) ) throw new Illegal State Exception ( STRING + STRING + resource . get Name ( ) ) ; resource . set Recovery Service ( recovery Service ) ; resources . put ( resource . get Name ( ) , resource ) ; resource List . add ( resource ) ; }
public static synchronized void add Resource ( Recoverable Resource resource ) throws Illegal State Exception { purge Resources ( ) ; if ( resources . contains Key ( resource . get Name ( ) ) ) throw new Illegal State Exception ( STRING + STRING + resource . get Name ( ) ) ; resource . set Recovery Service ( recovery Service ) ; resources . put ( resource . get Name ( ) , resource ) ; resource List . add ( resource ) ; }
public static synchronized void add Resource ( Recoverable Resource resource ) throws Illegal State Exception { purge Resources ( ) ; if ( resources . contains Key ( resource . get Name ( ) ) ) throw new Illegal State Exception ( STRING + STRING + resource . get Name ( ) ) ; resource . set Recovery Service ( recovery Service ) ; resources . put ( resource . get Name ( ) , resource ) ; resource List . add ( resource ) ; }
public static synchronized void add Resource ( Recoverable Resource resource ) throws Illegal State Exception { purge Resources ( ) ; if ( resources . contains Key ( resource . get Name ( ) ) ) throw new Illegal State Exception ( STRING + STRING + resource . get Name ( ) ) ; resource . set Recovery Service ( recovery Service ) ; resources . put ( resource . get Name ( ) , resource ) ; resource List . add ( resource ) ; }
public static synchronized void add Resource ( Recoverable Resource resource ) throws Illegal State Exception { purge Resources ( ) ; if ( resources . contains Key ( resource . get Name ( ) ) ) throw new Illegal State Exception ( STRING + STRING + resource . get Name ( ) ) ; resource . set Recovery Service ( recovery Service ) ; resources . put ( resource . get Name ( ) , resource ) ; resource List . add ( resource ) ; }
public static synchronized void add Resource ( Recoverable Resource resource ) throws Illegal State Exception { purge Resources ( ) ; if ( resources . contains Key ( resource . get Name ( ) ) ) throw new Illegal State Exception ( STRING + STRING + resource . get Name ( ) ) ; resource . set Recovery Service ( recovery Service ) ; resources . put ( resource . get Name ( ) , resource ) ; resource List . add ( resource ) ; }
public static synchronized void add Resource ( Recoverable Resource resource ) throws Illegal State Exception { purge Resources ( ) ; if ( resources . contains Key ( resource . get Name ( ) ) ) throw new Illegal State Exception ( STRING + STRING + resource . get Name ( ) ) ; resource . set Recovery Service ( recovery Service ) ; resources . put ( resource . get Name ( ) , resource ) ; resource List . add ( resource ) ; }
public static synchronized void add Resource ( Recoverable Resource resource ) throws Illegal State Exception { purge Resources ( ) ; if ( resources . contains Key ( resource . get Name ( ) ) ) throw new Illegal State Exception ( STRING + STRING + resource . get Name ( ) ) ; resource . set Recovery Service ( recovery Service ) ; resources . put ( resource . get Name ( ) , resource ) ; resource List . add ( resource ) ; }
private static < T extends Abstract Block Base < T > > void enqueue Successors ( T block , Priority Queue < T > worklist , Bit Set visited Blocks ) { for ( T successor : block . get Successors ( ) ) { if ( ! visited Blocks . get ( successor . get Id ( ) ) ) { visited Blocks . set ( successor . get Id ( ) ) ; worklist . add ( successor ) ; } } }
public static boolean has Permission ( Security security , Generic Value user Login , Generic Value order Header ) { if ( user Login == null || order Header == null ) return BOOL ; if ( security . has Entity Permission ( STRING , STRING , user Login ) ) { return BOOL ; } else if ( security . has Entity Permission ( STRING , STRING , user Login ) ) { List < Generic Value > order Roles = null ; try { order Roles = order Header . get Related ( STRING , Util Misc . to Map ( STRING , user Login . get String ( STRING ) ) , null , BOOL ) ; } catch ( Generic Entity Exception e ) { Debug . log Error ( e , STRING , module ) ; } if ( Util Validate . is Not Empty ( order Roles ) ) { return BOOL ; } } return BOOL ; }
public static boolean has Permission ( Security security , Generic Value user Login , Generic Value order Header ) { if ( user Login == null || order Header == null ) return BOOL ; if ( security . has Entity Permission ( STRING , STRING , user Login ) ) { return BOOL ; } else if ( security . has Entity Permission ( STRING , STRING , user Login ) ) { List < Generic Value > order Roles = null ; try { order Roles = order Header . get Related ( STRING , Util Misc . to Map ( STRING , user Login . get String ( STRING ) ) , null , BOOL ) ; } catch ( Generic Entity Exception e ) { Debug . log Error ( e , STRING , module ) ; } if ( Util Validate . is Not Empty ( order Roles ) ) { return BOOL ; } } return BOOL ; }
public void update Component Data Member Default Access ( String str Access ) throws Security Exception , Application Exception { check Write Access ( ) ; boolean has Access = Config Web Util . has Access ( config , Security Manager . TYPE SETTING ) ; if ( ! has Access ) throw new Security Exception ( STRING ) ; Element scope = get Root Element ( STRING ) ; if ( String Util . is Empty ( str Access ) ) { scope . set Attribute ( STRING , STRING ) ; } else { scope . set Attribute ( STRING , Component Util . to String Access ( Component Util . to Int Access ( str Access ) ) ) ; } }
public static final void clear ( final double [ ] v1 ) { Arrays . fill ( v1 , NUM ) ; }
public static void copy All ( File root , File dest ) throws IO Exception { if ( root . is Directory ( ) ) { for ( File child : root . list Files ( ) ) { File child Dest = new File ( dest , child . get Name ( ) ) ; if ( child . is Directory ( ) ) { if ( ! child Dest . exists ( ) && ! mkdirs ( child Dest ) ) throw new IO Exception ( STRING + child Dest . get Path ( ) ) ; copy All ( child , child Dest ) ; } else { Files . copy ( child . to Path ( ) , child Dest . to Path ( ) , Standard Copy Option . COPY ATTRIBUTES ) ; } } } else { File child Dest = new File ( dest , root . get Name ( ) ) ; if ( ! dest . exists ( ) && ! mkdirs ( dest ) ) throw new IO Exception ( STRING + dest . get Path ( ) ) ; Files . copy ( root . to Path ( ) , child Dest . to Path ( ) , Standard Copy Option . COPY ATTRIBUTES ) ; } }
public static List < String > extract Outcome Labels From Predictions ( File predictions File , Bidi Map labels To Integers Mapping ) throws IO Exception { List < String > result = new Array List < > ( ) ; for ( String line : File Utils . read Lines ( predictions File ) ) { Integer int Label = Integer . value Of ( line ) ; String outcome Label = ( String ) labels To Integers Mapping . get Key ( int Label ) ; result . add ( outcome Label ) ; } return result ; }
public static List < String > extract Outcome Labels From Predictions ( File predictions File , Bidi Map labels To Integers Mapping ) throws IO Exception { List < String > result = new Array List < > ( ) ; for ( String line : File Utils . read Lines ( predictions File ) ) { Integer int Label = Integer . value Of ( line ) ; String outcome Label = ( String ) labels To Integers Mapping . get Key ( int Label ) ; result . add ( outcome Label ) ; } return result ; }
public String to String Tree ( ) { String Builder b = new String Builder ( ) ; to String Tree ( b , STRING ) ; return b . to String ( ) ; }
public static Object parse UI File ( String resource String , String schema Resource , Class < ? > class To Parse ) { return parse File ( UI RESOURCE FOLDER , resource String , schema Resource , class To Parse ) ; }
public static void substitute Properties ( Node node , Properties properties ) { Node child ; Node next = node . get First Child ( ) ; while ( ( child = next ) != null ) { next = child . get Next Sibling ( ) ; if ( child . get Node Type ( ) == Node . TEXT NODE ) { child . set Node Value ( Properties Util . substitute Property ( child . get Node Value ( ) , properties ) ) ; } else if ( child . get Node Type ( ) == Node . ELEMENT NODE ) { Named Node Map attributes = child . get Attributes ( ) ; for ( int i = NUM ; i < attributes . get Length ( ) ; i ++ ) { Node attribute = attributes . item ( i ) ; attribute . set Node Value ( Properties Util . substitute Property ( attribute . get Node Value ( ) , properties ) ) ; } substitute Properties ( child , properties ) ; } } }
public static void substitute Properties ( Node node , Properties properties ) { Node child ; Node next = node . get First Child ( ) ; while ( ( child = next ) != null ) { next = child . get Next Sibling ( ) ; if ( child . get Node Type ( ) == Node . TEXT NODE ) { child . set Node Value ( Properties Util . substitute Property ( child . get Node Value ( ) , properties ) ) ; } else if ( child . get Node Type ( ) == Node . ELEMENT NODE ) { Named Node Map attributes = child . get Attributes ( ) ; for ( int i = NUM ; i < attributes . get Length ( ) ; i ++ ) { Node attribute = attributes . item ( i ) ; attribute . set Node Value ( Properties Util . substitute Property ( attribute . get Node Value ( ) , properties ) ) ; } substitute Properties ( child , properties ) ; } } }
public static void substitute Properties ( Node node , Properties properties ) { Node child ; Node next = node . get First Child ( ) ; while ( ( child = next ) != null ) { next = child . get Next Sibling ( ) ; if ( child . get Node Type ( ) == Node . TEXT NODE ) { child . set Node Value ( Properties Util . substitute Property ( child . get Node Value ( ) , properties ) ) ; } else if ( child . get Node Type ( ) == Node . ELEMENT NODE ) { Named Node Map attributes = child . get Attributes ( ) ; for ( int i = NUM ; i < attributes . get Length ( ) ; i ++ ) { Node attribute = attributes . item ( i ) ; attribute . set Node Value ( Properties Util . substitute Property ( attribute . get Node Value ( ) , properties ) ) ; } substitute Properties ( child , properties ) ; } } }
public String backup Now ( String backup File Prefix ) throws Mc Exception , IO Exception { logger . debug ( STRING ) ; return Backup . backup ( backup File Prefix ) ; }
protected void draw Y Legend ( ) { float [ ] positions = new float [ mY Legend . length * NUM ] ; for ( int i = NUM ; i < positions . length ; i += NUM ) { positions [ i ] = NUM ; positions [ i + NUM ] = mY Legend [ i / NUM ] ; } transform Point Array No Touch ( positions ) ; float [ ] xy ; String y Lengend ; float x , y ; for ( int i = NUM ; i < positions . length ; i += NUM ) { if ( mY Legend [ i / NUM ] != null ) { if ( m Draw Unit In Legend ) { y Lengend = m Format Y Legend . format ( mY Legend [ i / NUM ] ) + m Unit ; } else { y Lengend = m Format Y Legend . format ( mY Legend [ i / NUM ] ) ; } xy = measure Text Dimension ( mY Legend Paint , y Lengend ) ; x = positions [ i ] - xy [ NUM ] - NUM ; y = positions [ i + NUM ] + xy [ NUM ] / NUM ; if ( ! m Draw Top Y Legend Entry && i >= positions . length - NUM ) return ; m Draw Canvas . draw Text ( y Lengend , x , y , mY Legend Paint ) ; } } }
public static boolean check Chroot Path ( String zk Host , boolean create ) throws Keeper Exception , Interrupted Exception { if ( ! contains Chroot ( zk Host ) ) { return BOOL ; } log . info ( STRING ) ; String chroot Path = zk Host . substring ( zk Host . index Of ( STRING ) , zk Host . length ( ) ) ; Solr Zk Client tmp Client = new Solr Zk Client ( zk Host . substring ( NUM , zk Host . index Of ( STRING ) ) , NUM * NUM ) ; boolean exists = tmp Client . exists ( chroot Path , BOOL ) ; if ( ! exists && create ) { tmp Client . make Path ( chroot Path , BOOL , BOOL ) ; exists = BOOL ; } tmp Client . close ( ) ; return exists ; }
public static boolean check Chroot Path ( String zk Host , boolean create ) throws Keeper Exception , Interrupted Exception { if ( ! contains Chroot ( zk Host ) ) { return BOOL ; } log . info ( STRING ) ; String chroot Path = zk Host . substring ( zk Host . index Of ( STRING ) , zk Host . length ( ) ) ; Solr Zk Client tmp Client = new Solr Zk Client ( zk Host . substring ( NUM , zk Host . index Of ( STRING ) ) , NUM * NUM ) ; boolean exists = tmp Client . exists ( chroot Path , BOOL ) ; if ( ! exists && create ) { tmp Client . make Path ( chroot Path , BOOL , BOOL ) ; exists = BOOL ; } tmp Client . close ( ) ; return exists ; }
public static boolean check Chroot Path ( String zk Host , boolean create ) throws Keeper Exception , Interrupted Exception { if ( ! contains Chroot ( zk Host ) ) { return BOOL ; } log . info ( STRING ) ; String chroot Path = zk Host . substring ( zk Host . index Of ( STRING ) , zk Host . length ( ) ) ; Solr Zk Client tmp Client = new Solr Zk Client ( zk Host . substring ( NUM , zk Host . index Of ( STRING ) ) , NUM * NUM ) ; boolean exists = tmp Client . exists ( chroot Path , BOOL ) ; if ( ! exists && create ) { tmp Client . make Path ( chroot Path , BOOL , BOOL ) ; exists = BOOL ; } tmp Client . close ( ) ; return exists ; }
public void generate Header ( Writer out ) throws java . io . IO Exception { out . write ( STRING ) ; if ( title != null ) { out . write ( STRING ) ; out . write ( title ) ; out . write ( STRING ) ; } if ( base != null ) { out . write ( STRING + STRING ) ; } out . write ( STRING ) ; }
void lightweight Paint ( Graphics g ) { paint ( g ) ; }
void lightweight Paint ( Graphics g ) { paint ( g ) ; }
void invalidate ( ) { for ( int i = NUM ; i < m Cursors . size ( ) ; i ++ ) { swap Cursor ( i , null , null ) ; } }
public static Pagination Context from Context ( Routing Context context ) { Http Server Request request = context . request ( ) ; String page Str = request . get Param ( Pagination Context . CURRENT PAGE QUERY PARAM ) ; String per Page Str = request . get Param ( Pagination Context . PER PAGE QUERY PARAM ) ; Integer page = null ; Integer per Page = null ; try { if ( page Str != null ) { page = Integer . parse Int ( page Str ) ; } if ( per Page Str != null ) { per Page = Integer . parse Int ( per Page Str ) ; } } catch ( Number Format Exception e ) { Default Error Handler . bad Request ( context , STRING ) ; } if ( per Page != null && per Page > Pagination Context . MAX PER PAGE ) { Default Error Handler . bad Request ( context , STRING + Pagination Context . PER PAGE QUERY PARAM + STRING + Pagination Context . MAX PER PAGE ) ; } return new Pagination Context ( page , per Page ) ; }
static void redistribute Buckets ( Array List < Notification Info > high Priority Events , Array List < Notification Info > medium Priority Events , Array List < Notification Info > low Priority Events , int max Notifications ) { if ( high Priority Events . size ( ) > max Notifications ) { low Priority Events . add All ( NUM , medium Priority Events ) ; List < Notification Info > items To Move Sublist = high Priority Events . sub List ( NUM , high Priority Events . size ( ) - max Notifications ) ; low Priority Events . add All ( NUM , items To Move Sublist ) ; if ( DEBUG ) { log Event Ids Bumped ( medium Priority Events , items To Move Sublist ) ; } medium Priority Events . clear ( ) ; items To Move Sublist . clear ( ) ; } if ( medium Priority Events . size ( ) + high Priority Events . size ( ) > max Notifications ) { int space Remaining = max Notifications - high Priority Events . size ( ) ; List < Notification Info > items To Move Sublist = medium Priority Events . sub List ( space Remaining , medium Priority Events . size ( ) ) ; low Priority Events . add All ( NUM , items To Move Sublist ) ; if ( DEBUG ) { log Event Ids Bumped ( items To Move Sublist , null ) ; } items To Move Sublist . clear ( ) ; } }
protected void finish Grid Row ( ) { Grid Bag Constraints constraints = new Grid Bag Constraints ( ) ; constraints . gridwidth = Grid Bag Constraints . REMAINDER ; constraints . weightx = NUM ; final J Label icon ; if ( param . is Optional ( ) ) { if ( param . is Defined ( ) && param . took Default Value ( ) && ! ( param instanceof Flag ) ) { icon = new J Label ( Stock Icon . get Stock Icon ( Stock Icon . DIALOG INFORMATION ) ) ; icon . set Tool Tip Text ( STRING + param . get Default Value As String ( ) ) ; } else { icon = new J Label ( ) ; icon . set Minimum Size ( new Dimension ( NUM , NUM ) ) ; } } else { if ( ! param . is Defined ( ) ) { icon = new J Label ( Stock Icon . get Stock Icon ( Stock Icon . DIALOG ERROR ) ) ; icon . set Tool Tip Text ( STRING ) ; } else { icon = new J Label ( ) ; icon . set Minimum Size ( new Dimension ( NUM , NUM ) ) ; } } parent . add ( icon , constraints ) ; }
protected void finish Grid Row ( ) { Grid Bag Constraints constraints = new Grid Bag Constraints ( ) ; constraints . gridwidth = Grid Bag Constraints . REMAINDER ; constraints . weightx = NUM ; final J Label icon ; if ( param . is Optional ( ) ) { if ( param . is Defined ( ) && param . took Default Value ( ) && ! ( param instanceof Flag ) ) { icon = new J Label ( Stock Icon . get Stock Icon ( Stock Icon . DIALOG INFORMATION ) ) ; icon . set Tool Tip Text ( STRING + param . get Default Value As String ( ) ) ; } else { icon = new J Label ( ) ; icon . set Minimum Size ( new Dimension ( NUM , NUM ) ) ; } } else { if ( ! param . is Defined ( ) ) { icon = new J Label ( Stock Icon . get Stock Icon ( Stock Icon . DIALOG ERROR ) ) ; icon . set Tool Tip Text ( STRING ) ; } else { icon = new J Label ( ) ; icon . set Minimum Size ( new Dimension ( NUM , NUM ) ) ; } } parent . add ( icon , constraints ) ; }
protected void finish Grid Row ( ) { Grid Bag Constraints constraints = new Grid Bag Constraints ( ) ; constraints . gridwidth = Grid Bag Constraints . REMAINDER ; constraints . weightx = NUM ; final J Label icon ; if ( param . is Optional ( ) ) { if ( param . is Defined ( ) && param . took Default Value ( ) && ! ( param instanceof Flag ) ) { icon = new J Label ( Stock Icon . get Stock Icon ( Stock Icon . DIALOG INFORMATION ) ) ; icon . set Tool Tip Text ( STRING + param . get Default Value As String ( ) ) ; } else { icon = new J Label ( ) ; icon . set Minimum Size ( new Dimension ( NUM , NUM ) ) ; } } else { if ( ! param . is Defined ( ) ) { icon = new J Label ( Stock Icon . get Stock Icon ( Stock Icon . DIALOG ERROR ) ) ; icon . set Tool Tip Text ( STRING ) ; } else { icon = new J Label ( ) ; icon . set Minimum Size ( new Dimension ( NUM , NUM ) ) ; } } parent . add ( icon , constraints ) ; }
public Font Hints ( ) { Toolkit tk = Toolkit . get Default Toolkit ( ) ; desktop Hints = ( Map ) ( tk . get Desktop Property ( STRING ) ) ; }
protected int hash ( Object key 1 , Object key 2 , Object key 3 , Object key 4 ) { int h = NUM ; if ( key 1 != null ) { h ^= key 1 . hash Code ( ) ; } if ( key 2 != null ) { h ^= key 2 . hash Code ( ) ; } if ( key 3 != null ) { h ^= key 3 . hash Code ( ) ; } if ( key 4 != null ) { h ^= key 4 . hash Code ( ) ; } h += ~ ( h << NUM ) ; h ^= ( h > > > NUM ) ; h += ( h << NUM ) ; h ^= ( h > > > NUM ) ; return h ; }
private String [ ] split Space Delemit Name Value Pair ( String str ) { if ( str == null || str . is Empty ( ) ) return null ; String str 2 = str . trim ( ) ; int idx = str 2 . last Index Of ( STRING ) ; if ( idx <= NUM ) return null ; String name = str 2 . substring ( NUM , idx ) ; String val = str 2 . substring ( idx + NUM ) ; if ( name . is Empty ( ) || val . is Empty ( ) ) return null ; name = name . trim ( ) ; try { Big Decimal bdecimal = new Big Decimal ( val ) ; if ( bdecimal != null ) { String [ ] res = new String [ NUM ] ; res [ NUM ] = name ; res [ NUM ] = val ; return res ; } } catch ( Exception ex ) { } return null ; }
private String [ ] split Space Delemit Name Value Pair ( String str ) { if ( str == null || str . is Empty ( ) ) return null ; String str 2 = str . trim ( ) ; int idx = str 2 . last Index Of ( STRING ) ; if ( idx <= NUM ) return null ; String name = str 2 . substring ( NUM , idx ) ; String val = str 2 . substring ( idx + NUM ) ; if ( name . is Empty ( ) || val . is Empty ( ) ) return null ; name = name . trim ( ) ; try { Big Decimal bdecimal = new Big Decimal ( val ) ; if ( bdecimal != null ) { String [ ] res = new String [ NUM ] ; res [ NUM ] = name ; res [ NUM ] = val ; return res ; } } catch ( Exception ex ) { } return null ; }
private String [ ] split Space Delemit Name Value Pair ( String str ) { if ( str == null || str . is Empty ( ) ) return null ; String str 2 = str . trim ( ) ; int idx = str 2 . last Index Of ( STRING ) ; if ( idx <= NUM ) return null ; String name = str 2 . substring ( NUM , idx ) ; String val = str 2 . substring ( idx + NUM ) ; if ( name . is Empty ( ) || val . is Empty ( ) ) return null ; name = name . trim ( ) ; try { Big Decimal bdecimal = new Big Decimal ( val ) ; if ( bdecimal != null ) { String [ ] res = new String [ NUM ] ; res [ NUM ] = name ; res [ NUM ] = val ; return res ; } } catch ( Exception ex ) { } return null ; }
private String [ ] split Space Delemit Name Value Pair ( String str ) { if ( str == null || str . is Empty ( ) ) return null ; String str 2 = str . trim ( ) ; int idx = str 2 . last Index Of ( STRING ) ; if ( idx <= NUM ) return null ; String name = str 2 . substring ( NUM , idx ) ; String val = str 2 . substring ( idx + NUM ) ; if ( name . is Empty ( ) || val . is Empty ( ) ) return null ; name = name . trim ( ) ; try { Big Decimal bdecimal = new Big Decimal ( val ) ; if ( bdecimal != null ) { String [ ] res = new String [ NUM ] ; res [ NUM ] = name ; res [ NUM ] = val ; return res ; } } catch ( Exception ex ) { } return null ; }
private void eliminate Backfill States ( int base State ) { if ( states To Backfill . contains ( new Integer ( base State ) ) ) { states To Backfill . remove Element ( new Integer ( base State ) ) ; short [ ] state = temp State Table . element At ( base State ) ; for ( int i = NUM ; i < num Categories ; i ++ ) { if ( state [ i ] != NUM ) { eliminate Backfill States ( state [ i ] ) ; } } } }
private void eliminate Backfill States ( int base State ) { if ( states To Backfill . contains ( new Integer ( base State ) ) ) { states To Backfill . remove Element ( new Integer ( base State ) ) ; short [ ] state = temp State Table . element At ( base State ) ; for ( int i = NUM ; i < num Categories ; i ++ ) { if ( state [ i ] != NUM ) { eliminate Backfill States ( state [ i ] ) ; } } } }
private void eliminate Backfill States ( int base State ) { if ( states To Backfill . contains ( new Integer ( base State ) ) ) { states To Backfill . remove Element ( new Integer ( base State ) ) ; short [ ] state = temp State Table . element At ( base State ) ; for ( int i = NUM ; i < num Categories ; i ++ ) { if ( state [ i ] != NUM ) { eliminate Backfill States ( state [ i ] ) ; } } } }
@ Override public void end Of Stream ( ) throws Ade Exception { if ( m in Period ) { close Period ( ) ; } }
@ Override public boolean equals ( Object other Rules ) { if ( this == other Rules ) { return BOOL ; } if ( other Rules instanceof Zone Rules ) { Zone Rules other = ( Zone Rules ) other Rules ; return Arrays . equals ( standard Transitions , other . standard Transitions ) && Arrays . equals ( standard Offsets , other . standard Offsets ) && Arrays . equals ( savings Instant Transitions , other . savings Instant Transitions ) && Arrays . equals ( wall Offsets , other . wall Offsets ) && Arrays . equals ( last Rules , other . last Rules ) ; } return BOOL ; }
@ Override public boolean equals ( Object other Rules ) { if ( this == other Rules ) { return BOOL ; } if ( other Rules instanceof Zone Rules ) { Zone Rules other = ( Zone Rules ) other Rules ; return Arrays . equals ( standard Transitions , other . standard Transitions ) && Arrays . equals ( standard Offsets , other . standard Offsets ) && Arrays . equals ( savings Instant Transitions , other . savings Instant Transitions ) && Arrays . equals ( wall Offsets , other . wall Offsets ) && Arrays . equals ( last Rules , other . last Rules ) ; } return BOOL ; }
@ Override public boolean equals ( Object other Rules ) { if ( this == other Rules ) { return BOOL ; } if ( other Rules instanceof Zone Rules ) { Zone Rules other = ( Zone Rules ) other Rules ; return Arrays . equals ( standard Transitions , other . standard Transitions ) && Arrays . equals ( standard Offsets , other . standard Offsets ) && Arrays . equals ( savings Instant Transitions , other . savings Instant Transitions ) && Arrays . equals ( wall Offsets , other . wall Offsets ) && Arrays . equals ( last Rules , other . last Rules ) ; } return BOOL ; }
protected void beat ( ) { send UDP String ( get Beat Signal ( ) , this . address , this . port ) ; this . time Of Last Beat = System . current Time Millis ( ) ; }
protected void beat ( ) { send UDP String ( get Beat Signal ( ) , this . address , this . port ) ; this . time Of Last Beat = System . current Time Millis ( ) ; }
public static String to N Triples String ( Literal lit , boolean xsd String To Plain Literal ) { try { String Builder sb = new String Builder ( ) ; append ( lit , sb , xsd String To Plain Literal ) ; return sb . to String ( ) ; } catch ( IO Exception e ) { throw new Assertion Error ( ) ; } }
public void reset ( ) { m Codes . clear ( ) ; m Is First Char Capitalized = BOOL ; m Preferred Word = null ; m Typed Word . set Length ( NUM ) ; m Caps Count = NUM ; }
private List < File Match > filter Source Matches That Are Target Matches ( List < File Match > source Match Candidates , List < File Match > target Match Candidates ) { List < File Match > filtered Source Match Candidates = new Array List < > ( ) ; List < Path > target Paths = get Paths ( target Match Candidates ) ; for ( File Match source Match Candidate : source Match Candidates ) { if ( ! target Paths . contains ( source Match Candidate . get Path ( ) ) ) { filtered Source Match Candidates . add ( source Match Candidate ) ; } } return filtered Source Match Candidates ; }
private List < File Match > filter Source Matches That Are Target Matches ( List < File Match > source Match Candidates , List < File Match > target Match Candidates ) { List < File Match > filtered Source Match Candidates = new Array List < > ( ) ; List < Path > target Paths = get Paths ( target Match Candidates ) ; for ( File Match source Match Candidate : source Match Candidates ) { if ( ! target Paths . contains ( source Match Candidate . get Path ( ) ) ) { filtered Source Match Candidates . add ( source Match Candidate ) ; } } return filtered Source Match Candidates ; }
private List < File Match > filter Source Matches That Are Target Matches ( List < File Match > source Match Candidates , List < File Match > target Match Candidates ) { List < File Match > filtered Source Match Candidates = new Array List < > ( ) ; List < Path > target Paths = get Paths ( target Match Candidates ) ; for ( File Match source Match Candidate : source Match Candidates ) { if ( ! target Paths . contains ( source Match Candidate . get Path ( ) ) ) { filtered Source Match Candidates . add ( source Match Candidate ) ; } } return filtered Source Match Candidates ; }
private List < File Match > filter Source Matches That Are Target Matches ( List < File Match > source Match Candidates , List < File Match > target Match Candidates ) { List < File Match > filtered Source Match Candidates = new Array List < > ( ) ; List < Path > target Paths = get Paths ( target Match Candidates ) ; for ( File Match source Match Candidate : source Match Candidates ) { if ( ! target Paths . contains ( source Match Candidate . get Path ( ) ) ) { filtered Source Match Candidates . add ( source Match Candidate ) ; } } return filtered Source Match Candidates ; }
private List < File Match > filter Source Matches That Are Target Matches ( List < File Match > source Match Candidates , List < File Match > target Match Candidates ) { List < File Match > filtered Source Match Candidates = new Array List < > ( ) ; List < Path > target Paths = get Paths ( target Match Candidates ) ; for ( File Match source Match Candidate : source Match Candidates ) { if ( ! target Paths . contains ( source Match Candidate . get Path ( ) ) ) { filtered Source Match Candidates . add ( source Match Candidate ) ; } } return filtered Source Match Candidates ; }
public void add Last ( Statement Sequence statements ) { if ( statements != null ) { sequence . add All ( statements . sequence ) ; } }
public void add Last ( Statement Sequence statements ) { if ( statements != null ) { sequence . add All ( statements . sequence ) ; } }
public void add Last ( Statement Sequence statements ) { if ( statements != null ) { sequence . add All ( statements . sequence ) ; } }
public static Factory Image create Image ( Input Stream is , String media Type , String name ) throws Bad Request Exception , Server Exception { try { final Byte Array Output Stream out = new Byte Array Output Stream ( ) ; final byte [ ] buffer = new byte [ NUM ] ; int read ; while ( ( read = is . read ( buffer , NUM , buffer . length ) ) != - NUM ) { out . write ( buffer , NUM , read ) ; if ( out . size ( ) > NUM * NUM ) { throw new Bad Request Exception ( STRING ) ; } } if ( out . size ( ) == NUM ) { return new Factory Image ( ) ; } out . flush ( ) ; return new Factory Image ( out . to Byte Array ( ) , media Type , name ) ; } catch ( IO Exception io Ex ) { throw new Server Exception ( io Ex . get Localized Message ( ) ) ; } }
public static Factory Image create Image ( Input Stream is , String media Type , String name ) throws Bad Request Exception , Server Exception { try { final Byte Array Output Stream out = new Byte Array Output Stream ( ) ; final byte [ ] buffer = new byte [ NUM ] ; int read ; while ( ( read = is . read ( buffer , NUM , buffer . length ) ) != - NUM ) { out . write ( buffer , NUM , read ) ; if ( out . size ( ) > NUM * NUM ) { throw new Bad Request Exception ( STRING ) ; } } if ( out . size ( ) == NUM ) { return new Factory Image ( ) ; } out . flush ( ) ; return new Factory Image ( out . to Byte Array ( ) , media Type , name ) ; } catch ( IO Exception io Ex ) { throw new Server Exception ( io Ex . get Localized Message ( ) ) ; } }
public Bottom Navigation Bar remove Item ( Bottom Navigation Item item ) { m Bottom Navigation Items . remove ( item ) ; return this ; }
public Bottom Navigation Bar remove Item ( Bottom Navigation Item item ) { m Bottom Navigation Items . remove ( item ) ; return this ; }
public Bottom Navigation Bar remove Item ( Bottom Navigation Item item ) { m Bottom Navigation Items . remove ( item ) ; return this ; }
public Bottom Navigation Bar remove Item ( Bottom Navigation Item item ) { m Bottom Navigation Items . remove ( item ) ; return this ; }
public String primary Occupation Name ( ) { String primary Occupation = null ; if ( professional Experience != null && professional Experience . primary Company ( ) != null ) { Company company = professional Experience . primary Company ( ) ; primary Occupation = company . title ( ) ; } if ( primary Occupation == null || primary Occupation . is Empty ( ) ) { if ( education Background != null && education Background . primary School ( ) != null ) { School primary School = education Background . primary School ( ) ; primary Occupation = primary School . degree ( ) ; } } return primary Occupation ; }
private Element create Key Value ( ) throws Exception { Element key Value Ele = null ; Private Key key = idm Client . get Tenant Private Key ( tenant Name ) ; if ( key != null ) { RSA Private Key rsa Key = ( RSA Private Key ) key ; Element rsa Key Ele = create RSA Key Value ( rsa Key ) ; if ( rsa Key Ele != null ) { key Value Ele = doc . create Element ( SAML Names . DS KEYVALUE ) ; key Value Ele . append Child ( rsa Key Ele ) ; } } return key Value Ele ; }
private Element create Key Value ( ) throws Exception { Element key Value Ele = null ; Private Key key = idm Client . get Tenant Private Key ( tenant Name ) ; if ( key != null ) { RSA Private Key rsa Key = ( RSA Private Key ) key ; Element rsa Key Ele = create RSA Key Value ( rsa Key ) ; if ( rsa Key Ele != null ) { key Value Ele = doc . create Element ( SAML Names . DS KEYVALUE ) ; key Value Ele . append Child ( rsa Key Ele ) ; } } return key Value Ele ; }
private I Java Element find Source Folder Element ( I Folder module Folder ) { I Folder folder Source Package = find Source Package ( module Folder , STRING ) ; if ( folder Source Package == null ) { return null ; } I Java Project java Project = Java Core . create ( folder Source Package . get Project ( ) ) ; if ( java Project == null ) { return null ; } try { I Package Fragment client Package = java Project . find Package Fragment ( folder Source Package . get Full Path ( ) ) ; return client Package ; } catch ( Java Model Exception e ) { e . print Stack Trace ( ) ; } return null ; }
private I Java Element find Source Folder Element ( I Folder module Folder ) { I Folder folder Source Package = find Source Package ( module Folder , STRING ) ; if ( folder Source Package == null ) { return null ; } I Java Project java Project = Java Core . create ( folder Source Package . get Project ( ) ) ; if ( java Project == null ) { return null ; } try { I Package Fragment client Package = java Project . find Package Fragment ( folder Source Package . get Full Path ( ) ) ; return client Package ; } catch ( Java Model Exception e ) { e . print Stack Trace ( ) ; } return null ; }
void cross Over ( Bayes Net Representation other ) { boolean [ ] bits = new boolean [ m bits . length ] ; for ( int i = NUM ; i < m bits . length ; i ++ ) { bits [ i ] = m bits [ i ] ; } int i Cross Over Point = m bits . length ; do { for ( int i = i Cross Over Point ; i < m bits . length ; i ++ ) { m bits [ i ] = bits [ i ] ; } i Cross Over Point = m random . next Int ( m bits . length ) ; for ( int i = i Cross Over Point ; i < m bits . length ; i ++ ) { m bits [ i ] = other . m bits [ i ] ; } } while ( has Cycles ( ) ) ; calc Global Score ( ) ; }
void clear ( ) ;
void clear ( ) ;
void clear ( ) ;
public static void register Default Prefixes ( ) throws XML Security Exception { set Default Prefix ( STRING , STRING ) ; set Default Prefix ( STRING , STRING ) ; set Default Prefix ( STRING , STRING ) ; set Default Prefix ( STRING , STRING ) ; set Default Prefix ( STRING , STRING ) ; set Default Prefix ( STRING , STRING ) ; set Default Prefix ( STRING , STRING ) ; set Default Prefix ( STRING , STRING ) ; }
public static String derive Path ( String base Dir , String file Name ) { Logger logger = Logger . get Logger ( COMPONENT ) ; if ( logger . is Loggable ( Level . FINE ) ) logger . log ( Level . FINE , STRING + file Name + STRING + base Dir ) ; if ( base Dir == null ) throw new Null Pointer Exception ( STRING ) ; if ( file Name == null ) throw new Null Pointer Exception ( STRING ) ; if ( base Dir . starts With ( STRING ) ) { String sys Prop = base Dir . substring ( NUM ) ; base Dir = System . get Property ( sys Prop ) ; if ( base Dir == null ) throw new Illegal Argument Exception ( STRING + sys Prop + STRING + STRING + STRING ) ; } File base = new File ( base Dir ) ; if ( ! base . exists ( ) ) throw new Illegal Argument Exception ( base Dir + STRING ) ; if ( ! base . is Directory ( ) ) throw new Illegal Argument Exception ( base Dir + STRING ) ; if ( ! base . can Read ( ) ) throw new Illegal Argument Exception ( STRING + base Dir ) ; String path = locate ( base , file Name ) ; if ( path != null ) { File check Dir = new File ( path ) ; if ( check Dir . is Directory ( ) ) path = check Dir Format ( path ) ; } return ( path ) ; }
void remove At ( final int remove Index ) { final Object [ ] items = this . items ; if ( remove Index == take Index ) { items [ take Index ] = null ; if ( ++ take Index == items . length ) take Index = NUM ; count -- ; if ( itrs != null ) itrs . element Dequeued ( ) ; } else { final int put Index = this . put Index ; for ( int i = remove Index ; ; ) { int next = i + NUM ; if ( next == items . length ) next = NUM ; if ( next != put Index ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . put Index = i ; break ; } } count -- ; if ( itrs != null ) itrs . removed At ( remove Index ) ; } not Full . signal ( ) ; }
void remove At ( final int remove Index ) { final Object [ ] items = this . items ; if ( remove Index == take Index ) { items [ take Index ] = null ; if ( ++ take Index == items . length ) take Index = NUM ; count -- ; if ( itrs != null ) itrs . element Dequeued ( ) ; } else { final int put Index = this . put Index ; for ( int i = remove Index ; ; ) { int next = i + NUM ; if ( next == items . length ) next = NUM ; if ( next != put Index ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . put Index = i ; break ; } } count -- ; if ( itrs != null ) itrs . removed At ( remove Index ) ; } not Full . signal ( ) ; }
void remove At ( final int remove Index ) { final Object [ ] items = this . items ; if ( remove Index == take Index ) { items [ take Index ] = null ; if ( ++ take Index == items . length ) take Index = NUM ; count -- ; if ( itrs != null ) itrs . element Dequeued ( ) ; } else { final int put Index = this . put Index ; for ( int i = remove Index ; ; ) { int next = i + NUM ; if ( next == items . length ) next = NUM ; if ( next != put Index ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . put Index = i ; break ; } } count -- ; if ( itrs != null ) itrs . removed At ( remove Index ) ; } not Full . signal ( ) ; }
public static float [ ] join ( float [ ] array A , float ... array B ) { if ( ( array B == null ) || ( array B . length == NUM ) ) { return array A ; } if ( ( array A == null ) || ( array A . length == NUM ) ) { return array B ; } float [ ] array = new float [ array A . length + array B . length ] ; System . arraycopy ( array A , NUM , array , NUM , array A . length ) ; System . arraycopy ( array B , NUM , array , array A . length , array B . length ) ; return array ; }
public static float [ ] join ( float [ ] array A , float ... array B ) { if ( ( array B == null ) || ( array B . length == NUM ) ) { return array A ; } if ( ( array A == null ) || ( array A . length == NUM ) ) { return array B ; } float [ ] array = new float [ array A . length + array B . length ] ; System . arraycopy ( array A , NUM , array , NUM , array A . length ) ; System . arraycopy ( array B , NUM , array , array A . length , array B . length ) ; return array ; }
Date Time Parse Context ( Date Time Formatter formatter ) { super ( ) ; this . formatter = formatter ; parsed . add ( new Parsed ( ) ) ; }
public static void rand Shuffle K ( Array List < Integer > inds , int k , Random rand ) { for ( int i = NUM ; i < k ; i ++ ) { Collections . swap ( inds , i , rand . next Int ( inds . size ( ) ) ) ; } }
public static void rand Shuffle K ( Array List < Integer > inds , int k , Random rand ) { for ( int i = NUM ; i < k ; i ++ ) { Collections . swap ( inds , i , rand . next Int ( inds . size ( ) ) ) ; } }
public static void rand Shuffle K ( Array List < Integer > inds , int k , Random rand ) { for ( int i = NUM ; i < k ; i ++ ) { Collections . swap ( inds , i , rand . next Int ( inds . size ( ) ) ) ; } }
public String to String ( ) { return String . format ( STRING , this . number Of Elements , this . size Of Element ) ; }
public String to String ( ) { return String . format ( STRING , this . number Of Elements , this . size Of Element ) ; }
public boolean remove ( Sim Event event ) { return sorted Set . remove ( event ) ; }
@ Override public void handle Click ( int x , int y , Plot Rendering Info info ) { Rectangle 2 D data Area = info . get Data Area ( ) ; if ( data Area . contains ( x , y ) ) { Value Axis xaxis = get Domain Axis ( ) ; if ( xaxis != null ) { double hvalue = xaxis . java 2 D To Value ( x , info . get Data Area ( ) , get Domain Axis Edge ( ) ) ; set Domain Crosshair Value ( hvalue ) ; } Value Axis yaxis = get Range Axis ( ) ; if ( yaxis != null ) { double vvalue = yaxis . java 2 D To Value ( y , info . get Data Area ( ) , get Range Axis Edge ( ) ) ; set Range Crosshair Value ( vvalue ) ; } } }
@ Override public void handle Click ( int x , int y , Plot Rendering Info info ) { Rectangle 2 D data Area = info . get Data Area ( ) ; if ( data Area . contains ( x , y ) ) { Value Axis xaxis = get Domain Axis ( ) ; if ( xaxis != null ) { double hvalue = xaxis . java 2 D To Value ( x , info . get Data Area ( ) , get Domain Axis Edge ( ) ) ; set Domain Crosshair Value ( hvalue ) ; } Value Axis yaxis = get Range Axis ( ) ; if ( yaxis != null ) { double vvalue = yaxis . java 2 D To Value ( y , info . get Data Area ( ) , get Range Axis Edge ( ) ) ; set Range Crosshair Value ( vvalue ) ; } } }
public float angle ( Vector other ) { double dot = dot ( other ) / ( length ( ) * other . length ( ) ) ; return ( float ) Math . acos ( dot ) ; }
public static boolean should Run ( String entry ) { return Cron . should Run ( entry , new Date ( ) ) ; }
public final boolean has Media ( ) { return media Components != null && media Components . size ( ) > NUM ; }
public final boolean has Media ( ) { return media Components != null && media Components . size ( ) > NUM ; }
public final boolean has Media ( ) { return media Components != null && media Components . size ( ) > NUM ; }
public void start ( boolean show ) { if ( show ) { set Visible ( BOOL ) ; } timer . start ( ) ; }
public void start ( boolean show ) { if ( show ) { set Visible ( BOOL ) ; } timer . start ( ) ; }
public void start ( boolean show ) { if ( show ) { set Visible ( BOOL ) ; } timer . start ( ) ; }
public void add Root ( Proto Element root ) { roots . add ( root ) ; }
public void add Root ( Proto Element root ) { roots . add ( root ) ; }
public void add Root ( Proto Element root ) { roots . add ( root ) ; }
public void add Root ( Proto Element root ) { roots . add ( root ) ; }
public boolean can Get Int ( ) { return can Get ( int . class ) ; }
@ Suppress Lint ( STRING ) @ Nullable public static Drawable inflate ( boolean force System Handling When Possible , @ Non Null Resources resources , @ Drawable Res int id ) { boolean system Handling = is System Handling ( force System Handling When Possible ) ; Log . d ( LOG TAG , String . format ( STRING , Integer . to Hex String ( id ) , system Handling ) ) ; if ( system Handling ) { return resources . get Drawable ( id , null ) ; } try { return Vector Drawable . create ( resources , id ) ; } catch ( Resources . Not Found Exception e ) { return null ; } }
private void serialize List ( Page Context pc , Set test , List list , String Builder sb , boolean serialize Query By Columns , Set < Object > done ) throws Converter Exception { sb . append ( go In ( ) ) ; sb . append ( STRING ) ; boolean do It = BOOL ; List Iterator it = list . list Iterator ( ) ; while ( it . has Next ( ) ) { if ( do It ) sb . append ( STRING ) ; do It = BOOL ; serialize ( pc , test , it . next ( ) , sb , serialize Query By Columns , done ) ; } sb . append ( STRING ) ; }
private void add Reachable ( Node start Node , Subgraph subgraph ) { Stack node Stack = new Stack ( ) ; node Stack . add ( start Node ) ; while ( ! node Stack . empty ( ) ) { Node node = ( Node ) node Stack . pop ( ) ; add Edges ( node , node Stack , subgraph ) ; } }
private void add Reachable ( Node start Node , Subgraph subgraph ) { Stack node Stack = new Stack ( ) ; node Stack . add ( start Node ) ; while ( ! node Stack . empty ( ) ) { Node node = ( Node ) node Stack . pop ( ) ; add Edges ( node , node Stack , subgraph ) ; } }
private void add Reachable ( Node start Node , Subgraph subgraph ) { Stack node Stack = new Stack ( ) ; node Stack . add ( start Node ) ; while ( ! node Stack . empty ( ) ) { Node node = ( Node ) node Stack . pop ( ) ; add Edges ( node , node Stack , subgraph ) ; } }
public String hash ( String key ) { try { Message Digest md = Message Digest . get Instance ( algorithm ) ; byte [ ] key Bytes = key . get Bytes ( STRING ) ; md . update ( key Bytes , NUM , key Bytes . length ) ; byte [ ] binaryhash = md . digest ( ) ; return Base 64 . encode ( binaryhash ) ; } catch ( Exception e ) { LOG . warn ( STRING , key , e ) ; return key ; } }
public static void document ( Class Doc c , Print Writer pw ) throws IO Exception { pw . println ( c . qualified Name ( ) ) ; { String comment = c . comment Text ( ) ; if ( comment != null && ! comment . equals ( STRING ) ) { pw . println ( STRING ) ; indent ( comment , NUM , pw ) ; pw . println ( STRING ) ; } } Method Doc [ ] methods = get Test Methods ( c ) ; for ( int i = NUM ; i < methods . length ; i ++ ) { Method Doc method = methods [ i ] ; pw . print ( STRING ) ; pw . println ( method . name ( ) ) ; String comment = method . comment Text ( ) ; if ( comment != null && ! comment . equals ( STRING ) ) { pw . println ( STRING ) ; indent ( comment , NUM , pw ) ; pw . println ( STRING ) ; } } pw . println ( STRING ) ; }
protected final String Builder write ( String Builder sb , final Object ... objects ) { for ( Object string : objects ) sb . append ( string ) ; return sb ; }
public void push ( Namespace namespace ) { namespace Stack . add ( namespace ) ; namespace Cache List . add ( null ) ; current Namespace Cache = null ; String prefix = namespace . get Prefix ( ) ; if ( ( prefix == null ) || ( prefix . length ( ) == NUM ) ) { default Namespace = namespace ; } }
private void append Managed Object Path Element ( Relation Definition < ? , ? > r ) { DN dn = DN . value Of ( profile . get Relation RDN Sequence ( r ) ) ; List < RDN > rdns Of Dn = get Rdns In Big Endian Order ( dn ) ; rdns . add All ( rdns Of Dn ) ; }
private void append Managed Object Path Element ( Relation Definition < ? , ? > r ) { DN dn = DN . value Of ( profile . get Relation RDN Sequence ( r ) ) ; List < RDN > rdns Of Dn = get Rdns In Big Endian Order ( dn ) ; rdns . add All ( rdns Of Dn ) ; }
private void append Managed Object Path Element ( Relation Definition < ? , ? > r ) { DN dn = DN . value Of ( profile . get Relation RDN Sequence ( r ) ) ; List < RDN > rdns Of Dn = get Rdns In Big Endian Order ( dn ) ; rdns . add All ( rdns Of Dn ) ; }
private static void find Outer Shells ( List shell List ) { for ( Iterator i = shell List . iterator ( ) ; i . has Next ( ) ; ) { Edge Ring er = ( Edge Ring ) i . next ( ) ; Edge Ring outer Hole ER = er . get Outer Hole ( ) ; if ( outer Hole ER != null && ! outer Hole ER . is Processed ( ) ) { er . set Included ( BOOL ) ; outer Hole ER . set Processed ( BOOL ) ; } } }
private static void find Outer Shells ( List shell List ) { for ( Iterator i = shell List . iterator ( ) ; i . has Next ( ) ; ) { Edge Ring er = ( Edge Ring ) i . next ( ) ; Edge Ring outer Hole ER = er . get Outer Hole ( ) ; if ( outer Hole ER != null && ! outer Hole ER . is Processed ( ) ) { er . set Included ( BOOL ) ; outer Hole ER . set Processed ( BOOL ) ; } } }
Net Class append ( Brd Layer Structure p layer structure , Clearance Matrix p clearance matrix , Itera Board itera board ) { Gui Resources resources = itera board . new Gui Resources ( STRING ) ; String name front = resources . get String ( STRING ) ; String new name = null ; Integer index = NUM ; for ( ; ; ) { ++ index ; new name = name front + index . to String ( ) ; if ( get ( new name ) == null ) break ; } return append ( new name , p layer structure , p clearance matrix ) ; }
Net Class append ( Brd Layer Structure p layer structure , Clearance Matrix p clearance matrix , Itera Board itera board ) { Gui Resources resources = itera board . new Gui Resources ( STRING ) ; String name front = resources . get String ( STRING ) ; String new name = null ; Integer index = NUM ; for ( ; ; ) { ++ index ; new name = name front + index . to String ( ) ; if ( get ( new name ) == null ) break ; } return append ( new name , p layer structure , p clearance matrix ) ; }
public void start ( ) { running Thread = new Thread ( this ) ; running Thread . set Name ( STRING ) ; running Thread . start ( ) ; }
public int write ( Connection conn , String output File Name , String sql , String charset ) throws SQL Exception { Statement stat = conn . create Statement ( ) ; Result Set rs = stat . execute Query ( sql ) ; int rows = write ( output File Name , rs , charset ) ; stat . close ( ) ; return rows ; }
public Version Naming Configuration ( String search Version Regex , String replace Version Regex , Branching Policy ... policies ) { this . branch Policies = new Linked List < > ( Arrays . as List ( policies ) ) ; this . search Pattern = Pattern . compile ( search Version Regex ) ; this . replace Version Regex = replace Version Regex ; }
public boolean compile ( String [ ] args ) { long start Time = System . current Time Millis ( ) ; long batch ID ; synchronized ( batch Count Lock ) { batch ID = batch Count ++ ; } Batch batch = parse Args ( args ) ; if ( batch == null ) { return BOOL ; } boolean status ; try { batch Table . put ( batch ID , batch ) ; status = invoke Javadoc ( batch , batch ID ) ; } finally { batch Table . remove ( batch ID ) ; } if ( batch . verbose ) { long delta Time = System . current Time Millis ( ) - start Time ; output ( Resources . get Text ( STRING , Long . to String ( delta Time ) ) ) ; } return status ; }
public Metric Instance with Maker ( Metric Maker maker ) { return new Metric Instance ( metric Name , maker , dependency Metric Names . to Array ( new String [ dependency Metric Names . size ( ) ] ) ) ; }
private void validate And Load Default Properties ( ) { if ( null == carbon Properties . get Property ( Carbon Common Constants . STORE LOCATION ) ) { carbon Properties . set Property ( Carbon Common Constants . STORE LOCATION , Carbon Common Constants . STORE LOCATION DEFAULT VAL ) ; } validate Blocklet Size ( ) ; validate Max File Size ( ) ; validate Num Cores ( ) ; validate Num Cores Block Sort ( ) ; validate Sort Size ( ) ; validate Bad Records Location ( ) ; validate High Cardinality Identify ( ) ; validate High Cardinality Threshold ( ) ; validate High Cardinality In Row Count Percentage ( ) ; }
private void validate And Load Default Properties ( ) { if ( null == carbon Properties . get Property ( Carbon Common Constants . STORE LOCATION ) ) { carbon Properties . set Property ( Carbon Common Constants . STORE LOCATION , Carbon Common Constants . STORE LOCATION DEFAULT VAL ) ; } validate Blocklet Size ( ) ; validate Max File Size ( ) ; validate Num Cores ( ) ; validate Num Cores Block Sort ( ) ; validate Sort Size ( ) ; validate Bad Records Location ( ) ; validate High Cardinality Identify ( ) ; validate High Cardinality Threshold ( ) ; validate High Cardinality In Row Count Percentage ( ) ; }
private void validate And Load Default Properties ( ) { if ( null == carbon Properties . get Property ( Carbon Common Constants . STORE LOCATION ) ) { carbon Properties . set Property ( Carbon Common Constants . STORE LOCATION , Carbon Common Constants . STORE LOCATION DEFAULT VAL ) ; } validate Blocklet Size ( ) ; validate Max File Size ( ) ; validate Num Cores ( ) ; validate Num Cores Block Sort ( ) ; validate Sort Size ( ) ; validate Bad Records Location ( ) ; validate High Cardinality Identify ( ) ; validate High Cardinality Threshold ( ) ; validate High Cardinality In Row Count Percentage ( ) ; }
@ Override public void check ( Certificate cert , Collection < String > unres Crit Exts ) throws Cert Path Validator Exception { X509 Certificate curr Cert = ( X509 Certificate ) cert ; i ++ ; check Basic Constraints ( curr Cert ) ; verify Name Constraints ( curr Cert ) ; if ( unres Crit Exts != null && ! unres Crit Exts . is Empty ( ) ) { unres Crit Exts . remove ( Basic Constraints Id . to String ( ) ) ; unres Crit Exts . remove ( Name Constraints Id . to String ( ) ) ; } }
@ Override public void check ( Certificate cert , Collection < String > unres Crit Exts ) throws Cert Path Validator Exception { X509 Certificate curr Cert = ( X509 Certificate ) cert ; i ++ ; check Basic Constraints ( curr Cert ) ; verify Name Constraints ( curr Cert ) ; if ( unres Crit Exts != null && ! unres Crit Exts . is Empty ( ) ) { unres Crit Exts . remove ( Basic Constraints Id . to String ( ) ) ; unres Crit Exts . remove ( Name Constraints Id . to String ( ) ) ; } }
@ Override public void check ( Certificate cert , Collection < String > unres Crit Exts ) throws Cert Path Validator Exception { X509 Certificate curr Cert = ( X509 Certificate ) cert ; i ++ ; check Basic Constraints ( curr Cert ) ; verify Name Constraints ( curr Cert ) ; if ( unres Crit Exts != null && ! unres Crit Exts . is Empty ( ) ) { unres Crit Exts . remove ( Basic Constraints Id . to String ( ) ) ; unres Crit Exts . remove ( Name Constraints Id . to String ( ) ) ; } }
synchronized void attach ( Closeable c ) { if ( parent == null ) { parent = c ; } else if ( other Parents == null ) { other Parents = new Array List < > ( ) ; other Parents . add ( parent ) ; other Parents . add ( c ) ; } else { other Parents . add ( c ) ; } }
synchronized void attach ( Closeable c ) { if ( parent == null ) { parent = c ; } else if ( other Parents == null ) { other Parents = new Array List < > ( ) ; other Parents . add ( parent ) ; other Parents . add ( c ) ; } else { other Parents . add ( c ) ; } }
synchronized void attach ( Closeable c ) { if ( parent == null ) { parent = c ; } else if ( other Parents == null ) { other Parents = new Array List < > ( ) ; other Parents . add ( parent ) ; other Parents . add ( c ) ; } else { other Parents . add ( c ) ; } }
synchronized void attach ( Closeable c ) { if ( parent == null ) { parent = c ; } else if ( other Parents == null ) { other Parents = new Array List < > ( ) ; other Parents . add ( parent ) ; other Parents . add ( c ) ; } else { other Parents . add ( c ) ; } }
public static void register Context Menu Action ( Class < ? > associated Class , Selection Dependent Action action ) { List < Selection Dependent Action > actions = context Menu Actions . get ( associated Class ) ; if ( actions == null ) { actions = new Linked List < Selection Dependent Action > ( ) ; context Menu Actions . put ( associated Class , actions ) ; } actions . add ( action ) ; }
public static void register Context Menu Action ( Class < ? > associated Class , Selection Dependent Action action ) { List < Selection Dependent Action > actions = context Menu Actions . get ( associated Class ) ; if ( actions == null ) { actions = new Linked List < Selection Dependent Action > ( ) ; context Menu Actions . put ( associated Class , actions ) ; } actions . add ( action ) ; }
public static void register Context Menu Action ( Class < ? > associated Class , Selection Dependent Action action ) { List < Selection Dependent Action > actions = context Menu Actions . get ( associated Class ) ; if ( actions == null ) { actions = new Linked List < Selection Dependent Action > ( ) ; context Menu Actions . put ( associated Class , actions ) ; } actions . add ( action ) ; }
public static void register Context Menu Action ( Class < ? > associated Class , Selection Dependent Action action ) { List < Selection Dependent Action > actions = context Menu Actions . get ( associated Class ) ; if ( actions == null ) { actions = new Linked List < Selection Dependent Action > ( ) ; context Menu Actions . put ( associated Class , actions ) ; } actions . add ( action ) ; }
Danger Indicator ( int max Skulls ) { set Layout ( new S Box Layout ( S Box Layout . HORIZONTAL ) ) ; indicators = new J Component [ max Skulls ] ; for ( int i = NUM ; i < max Skulls ; i ++ ) { J Label indicator = new J Label ( skull Icon ) ; indicator . set Visible ( BOOL ) ; add ( indicator ) ; indicators [ i ] = indicator ; } }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
private void cmd delete Selection ( ) { m frame . set Cursor ( Cursor . get Predefined Cursor ( Cursor . WAIT CURSOR ) ) ; if ( A Dialog . ask ( get Window No ( ) , m frame , STRING ) ) { int records = delete Selection ( ) ; set Status Line ( Msg . get Msg ( Env . get Ctx ( ) , STRING ) + records , BOOL ) ; } m frame . set Cursor ( Cursor . get Default Cursor ( ) ) ; b Delete . set Selected ( BOOL ) ; execute Query ( ) ; ; }
static String to S ( float [ ] a ) { String s = STRING ; if ( a == null ) { return STRING ; } for ( int i = NUM ; i < a . length ; i ++ ) { if ( i != NUM ) { s += STRING ; } String t = df . format ( a [ i ] ) + STRING ; s += t . substring ( NUM , NUM ) ; } s += STRING ; return s ; }
public Month Date Format ( Time Zone zone , int chars ) { this ( zone , Locale . get Default ( ) , chars , BOOL , BOOL ) ; }
public static Resource create Resource ( Resource res , short level , short type ) { boolean as Dir = type == TYPE DIR ; if ( level >= LEVEL FILE && res . exists ( ) && ( ( res . is Directory ( ) && as Dir ) || ( res . is File ( ) && ! as Dir ) ) ) { return get Canonical Resource EL ( res ) ; } Resource parent = res . get Parent Resource ( ) ; if ( level >= LEVEL PARENT FILE && parent != null && parent . exists ( ) && can RW ( parent ) ) { if ( as Dir ) { if ( res . mkdirs ( ) ) return get Canonical Resource EL ( res ) ; } else { if ( create New Resource EL ( res ) ) return get Canonical Resource EL ( res ) ; } return get Canonical Resource EL ( res ) ; } if ( level >= LEVEL GRAND PARENT FILE && parent != null ) { Resource gparent = parent . get Parent Resource ( ) ; if ( gparent != null && gparent . exists ( ) && can RW ( gparent ) ) { if ( as Dir ) { if ( res . mkdirs ( ) ) return get Canonical Resource EL ( res ) ; } else { if ( parent . mkdirs ( ) && create New Resource EL ( res ) ) return get Canonical Resource EL ( res ) ; } } } return null ; }
public static Resource create Resource ( Resource res , short level , short type ) { boolean as Dir = type == TYPE DIR ; if ( level >= LEVEL FILE && res . exists ( ) && ( ( res . is Directory ( ) && as Dir ) || ( res . is File ( ) && ! as Dir ) ) ) { return get Canonical Resource EL ( res ) ; } Resource parent = res . get Parent Resource ( ) ; if ( level >= LEVEL PARENT FILE && parent != null && parent . exists ( ) && can RW ( parent ) ) { if ( as Dir ) { if ( res . mkdirs ( ) ) return get Canonical Resource EL ( res ) ; } else { if ( create New Resource EL ( res ) ) return get Canonical Resource EL ( res ) ; } return get Canonical Resource EL ( res ) ; } if ( level >= LEVEL GRAND PARENT FILE && parent != null ) { Resource gparent = parent . get Parent Resource ( ) ; if ( gparent != null && gparent . exists ( ) && can RW ( gparent ) ) { if ( as Dir ) { if ( res . mkdirs ( ) ) return get Canonical Resource EL ( res ) ; } else { if ( parent . mkdirs ( ) && create New Resource EL ( res ) ) return get Canonical Resource EL ( res ) ; } } } return null ; }
public V put ( K key , V value ) { final int hash ; int index ; if ( key == null ) { hash = NUM ; index = index Of Null ( ) ; } else { hash = key . hash Code ( ) ; index = index Of ( key , hash ) ; } if ( index >= NUM ) { index = ( index << NUM ) + NUM ; final V old = ( V ) m Array [ index ] ; m Array [ index ] = value ; return old ; } index = ~ index ; if ( m Size >= m Hashes . length ) { final int n = m Size >= ( BASE SIZE * NUM ) ? ( m Size + ( m Size > > NUM ) ) : ( m Size >= BASE SIZE ? ( BASE SIZE * NUM ) : BASE SIZE ) ; final int [ ] ohashes = m Hashes ; final Object [ ] oarray = m Array ; alloc Arrays ( n ) ; if ( m Hashes . length > NUM ) { System . arraycopy ( ohashes , NUM , m Hashes , NUM , ohashes . length ) ; System . arraycopy ( oarray , NUM , m Array , NUM , oarray . length ) ; } free Arrays ( ohashes , oarray , m Size ) ; } if ( index < m Size ) { System . arraycopy ( m Hashes , index , m Hashes , index + NUM , m Size - index ) ; System . arraycopy ( m Array , index << NUM , m Array , ( index + NUM ) << NUM , ( m Size - index ) << NUM ) ; } m Hashes [ index ] = hash ; m Array [ index << NUM ] = key ; m Array [ ( index << NUM ) + NUM ] = value ; m Size ++ ; return null ; }
public static String relative Path ( File file , File dir ) { check Argument ( file . is File ( ) || file . is Directory ( ) , STRING , file . get Path ( ) ) ; check Argument ( dir . is Directory ( ) , STRING , dir . get Path ( ) ) ; return relative Possibly Non Existing Path ( file , dir ) ; }
public static String relative Path ( File file , File dir ) { check Argument ( file . is File ( ) || file . is Directory ( ) , STRING , file . get Path ( ) ) ; check Argument ( dir . is Directory ( ) , STRING , dir . get Path ( ) ) ; return relative Possibly Non Existing Path ( file , dir ) ; }
public void remove ( Example Set Based Individual individual ) { individuals . remove ( individual ) ; }
public void ensure Capacity ( int minimum Capacity ) { if ( minimum Capacity <= capacity ) return ; if ( minimum Capacity > NUM ) { capacity = ( minimum Capacity + NUM ) & ~ NUM ; } else { while ( capacity < minimum Capacity ) { capacity += capacity ; } } byte [ ] bytes = new byte [ capacity ] ; System . arraycopy ( buffer , NUM , bytes , NUM , length ) ; buffer = bytes ; }
public void ensure Capacity ( int minimum Capacity ) { if ( minimum Capacity <= capacity ) return ; if ( minimum Capacity > NUM ) { capacity = ( minimum Capacity + NUM ) & ~ NUM ; } else { while ( capacity < minimum Capacity ) { capacity += capacity ; } } byte [ ] bytes = new byte [ capacity ] ; System . arraycopy ( buffer , NUM , bytes , NUM , length ) ; buffer = bytes ; }
public String to String ( ) { String Buffer sb = new String Buffer ( ) ; sb . append ( super . to String ( ) + STRING ) ; if ( full Name != null ) { sb . append ( STRING + full Name + STRING ) ; } if ( relative Name != null ) { sb . append ( STRING + relative Name + STRING ) ; } sb . append ( STRING + only Contains User Certs + STRING ) ; sb . append ( STRING + only Contains CA Certs + STRING ) ; if ( reason Flags != null ) { sb . append ( STRING ) ; for ( int i = NUM ; i < reason Flags . length ; i ++ ) { if ( reason Flags [ i ] ) { sb . append ( STRING + reason To String ( i ) + STRING ) ; } } } sb . append ( STRING + indirect CRL + STRING ) ; return sb . to String ( ) ; }
public void add Dimension Key Name ( String key ) { dimension Key Names . add ( key ) ; }
private Movie Chooser Model ( ) { set Name ( BUNDLE . get String ( STRING ) ) ; combined Name = name ; }
public static void queue Column Load ( I Cubic World world , Cube IO loader , int x , int z , Consumer < Column > runnable ) { Queued Column key = new Queued Column ( x , z , world ) ; Async Column IO Provider task = column Tasks . get ( key ) ; if ( task == null ) { task = new Async Column IO Provider ( key , loader ) ; task . add Callback ( runnable ) ; column Tasks . put ( key , task ) ; pool . execute ( task ) ; } else { task . add Callback ( runnable ) ; } }
public static void edit Node Comments ( final C Graph Model model , final I Navi View Node node , final Initial Tab initial Tab ) { Preconditions . check Not Null ( node , STRING ) ; final J Dialog dialog = get Comment Dialog ( model , node , initial Tab ) ; Gui Helper . center Child To Parent ( model . get Parent ( ) , dialog , BOOL ) ; dialog . set Visible ( BOOL ) ; }
public static void edit Node Comments ( final C Graph Model model , final I Navi View Node node , final Initial Tab initial Tab ) { Preconditions . check Not Null ( node , STRING ) ; final J Dialog dialog = get Comment Dialog ( model , node , initial Tab ) ; Gui Helper . center Child To Parent ( model . get Parent ( ) , dialog , BOOL ) ; dialog . set Visible ( BOOL ) ; }
public static void edit Node Comments ( final C Graph Model model , final I Navi View Node node , final Initial Tab initial Tab ) { Preconditions . check Not Null ( node , STRING ) ; final J Dialog dialog = get Comment Dialog ( model , node , initial Tab ) ; Gui Helper . center Child To Parent ( model . get Parent ( ) , dialog , BOOL ) ; dialog . set Visible ( BOOL ) ; }
public RT Html < RT Image , RT Audio , RT Video > convert ( final Spanned text , RT Format . Html rt Format ) { m Text = text ; mRT Format = rt Format ; m Out = new String Builder ( ) ; m Images = new Array List < > ( ) ; m Paragraph Styles . clear ( ) ; convert Paragraphs ( ) ; return new RT Html < > ( rt Format , m Out . to String ( ) , m Images ) ; }
public RT Html < RT Image , RT Audio , RT Video > convert ( final Spanned text , RT Format . Html rt Format ) { m Text = text ; mRT Format = rt Format ; m Out = new String Builder ( ) ; m Images = new Array List < > ( ) ; m Paragraph Styles . clear ( ) ; convert Paragraphs ( ) ; return new RT Html < > ( rt Format , m Out . to String ( ) , m Images ) ; }
protected void assert Same Scores ( Query q1 , Query q2 ) throws Exception { assert Same Set ( q1 , q2 ) ; assert Same Scores ( q1 , q2 , null ) ; int num Filters = TEST NIGHTLY ? at Least ( NUM ) : at Least ( NUM ) ; for ( int i = NUM ; i < num Filters ; i ++ ) { Query filter = random Filter ( ) ; assert Same Scores ( q1 , q2 , filter ) ; assert Same Scores ( filtered Query ( q1 , filter ) , filtered Query ( q2 , filter ) , null ) ; } }
protected void assert Same Scores ( Query q1 , Query q2 ) throws Exception { assert Same Set ( q1 , q2 ) ; assert Same Scores ( q1 , q2 , null ) ; int num Filters = TEST NIGHTLY ? at Least ( NUM ) : at Least ( NUM ) ; for ( int i = NUM ; i < num Filters ; i ++ ) { Query filter = random Filter ( ) ; assert Same Scores ( q1 , q2 , filter ) ; assert Same Scores ( filtered Query ( q1 , filter ) , filtered Query ( q2 , filter ) , null ) ; } }
protected void assert Same Scores ( Query q1 , Query q2 ) throws Exception { assert Same Set ( q1 , q2 ) ; assert Same Scores ( q1 , q2 , null ) ; int num Filters = TEST NIGHTLY ? at Least ( NUM ) : at Least ( NUM ) ; for ( int i = NUM ; i < num Filters ; i ++ ) { Query filter = random Filter ( ) ; assert Same Scores ( q1 , q2 , filter ) ; assert Same Scores ( filtered Query ( q1 , filter ) , filtered Query ( q2 , filter ) , null ) ; } }
@ Override public String to String ( String pad , int recursion Level ) { String Buffer result = new String Buffer ( ) ; result . append ( pad ) ; result . append ( STRING ) ; for ( FP Tree Node node : m children . values ( ) ) { result . append ( node . to String ( pad + STRING , recursion Level ) ) ; } return result . to String ( ) ; }
private String f Name ( String name ) { return dir . get Path ( ) + File . separator + name ; }
public static String format Number ( final Big Decimal number , final int fraction Digits , final boolean use Grouping ) { final Number Format number Format = Number Format . get Instance ( ) ; number Format . set Minimum Fraction Digits ( fraction Digits ) ; number Format . set Maximum Fraction Digits ( fraction Digits ) ; number Format . set Grouping Used ( use Grouping ) ; return number Format . format ( number . double Value ( ) ) ; }
public Encoder Test Suite Builder encoded ( int min , int max ) { encoded . set ( min , max + NUM ) ; valid . clear ( min , max + NUM ) ; invalid . clear ( min , max + NUM ) ; return this ; }
public Encoder Test Suite Builder encoded ( int min , int max ) { encoded . set ( min , max + NUM ) ; valid . clear ( min , max + NUM ) ; invalid . clear ( min , max + NUM ) ; return this ; }
public void add Document ( Document d ) { if ( ! m read Mode ) { try { writer . add Document ( d ) ; m hit Count Cache . clear ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } else { throw new Illegal State Exception ( STRING + STRING ) ; } }
public void dup 2 X 2 ( ) { mv . visit Insn ( Opcodes . DUP 2 X2 ) ; }
public static Builder create Builder ( Header header , Writable Font Data data ) { return new Builder ( header , data ) ; }
public static Builder create Builder ( Header header , Writable Font Data data ) { return new Builder ( header , data ) ; }
public static Builder create Builder ( Header header , Writable Font Data data ) { return new Builder ( header , data ) ; }
public boolean verify ( ) throws No Such Algorithm Exception , No Such Provider Exception , Invalid Key Exception , Signature Exception { return verify ( Bouncy Castle Provider . PROVIDER NAME ) ; }
public boolean verify ( ) throws No Such Algorithm Exception , No Such Provider Exception , Invalid Key Exception , Signature Exception { return verify ( Bouncy Castle Provider . PROVIDER NAME ) ; }
public static String [ ] split ( String search In , String splitter ) { String [ ] results = new String [ count ( search In , splitter ) + NUM ] ; int position = NUM ; int i = NUM ; while ( search In . index Of ( splitter , position ) >= NUM ) { results [ i ] = search In . substring ( position , search In . index Of ( splitter , position + NUM ) ) ; position = search In . index Of ( splitter , position ) + NUM ; i ++ ; } results [ ( results . length - NUM ) ] = search In . substring ( position ) ; return results ; }
public static double parse Double ( byte [ ] bytes , int start Index , int end Index ) { if ( end Index - start Index == NUM ) { return Double . long Bits To Double ( parse Long ( bytes , start Index , end Index ) ) ; } else if ( end Index - start Index == NUM ) { return Float . int Bits To Float ( ( int ) parse Long ( bytes , start Index , end Index ) ) ; } else { throw new Illegal Argument Exception ( STRING + end Index + STRING + start Index + STRING ) ; } }
public static double parse Double ( byte [ ] bytes , int start Index , int end Index ) { if ( end Index - start Index == NUM ) { return Double . long Bits To Double ( parse Long ( bytes , start Index , end Index ) ) ; } else if ( end Index - start Index == NUM ) { return Float . int Bits To Float ( ( int ) parse Long ( bytes , start Index , end Index ) ) ; } else { throw new Illegal Argument Exception ( STRING + end Index + STRING + start Index + STRING ) ; } }
public File Reader Source ( File file , Compiler Configuration configuration ) { super ( configuration ) ; this . file = file ; }
public void remove Bookmark ( final C Bookmark bookmark ) { Preconditions . check Not Null ( bookmark , STRING ) ; Preconditions . check Argument ( m bookmarks . remove ( bookmark ) , STRING ) ; for ( final I Bookmark Manager Listener listener : m listeners ) { try { listener . removed Bookmark ( this , bookmark ) ; } catch ( final Exception exception ) { C Utility Functions . log Exception ( exception ) ; } } }
public void remove Bookmark ( final C Bookmark bookmark ) { Preconditions . check Not Null ( bookmark , STRING ) ; Preconditions . check Argument ( m bookmarks . remove ( bookmark ) , STRING ) ; for ( final I Bookmark Manager Listener listener : m listeners ) { try { listener . removed Bookmark ( this , bookmark ) ; } catch ( final Exception exception ) { C Utility Functions . log Exception ( exception ) ; } } }
public Picture ( File file ) { try { image = Image IO . read ( file ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; throw new Runtime Exception ( STRING + file ) ; } if ( image == null ) { throw new Runtime Exception ( STRING + file ) ; } width = image . get Width ( null ) ; height = image . get Height ( null ) ; filename = file . get Name ( ) ; }
public Picture ( File file ) { try { image = Image IO . read ( file ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; throw new Runtime Exception ( STRING + file ) ; } if ( image == null ) { throw new Runtime Exception ( STRING + file ) ; } width = image . get Width ( null ) ; height = image . get Height ( null ) ; filename = file . get Name ( ) ; }
abstract protected void process Command ( String line ) throws Exception ;
void seek ( int position ) throws IO Exception { m Dex File . seek ( position ) ; }
void seek ( int position ) throws IO Exception { m Dex File . seek ( position ) ; }
public static String convert Crl To PEM ( final X509 CRL crl ) throws DSS Exception { try { final byte [ ] der Crl = crl . get Encoded ( ) ; String pem Crl Pre = Base 64 . encode Base 64 String ( der Crl ) ; final String pem Crl = CRL BEGIN + NEW LINE + pem Crl Pre + NEW LINE + CRL END ; return pem Crl ; } catch ( CRL Exception e ) { throw new DSS Exception ( STRING + e . get Message ( ) ) ; } }
public String process ( String to process ) { if ( to process == null || to process . length ( ) == NUM ) return STRING ; String tmp = STRING ; String Tokenizer st = new String Tokenizer ( to process , STRING , BOOL ) ; String Buffer new Value = new String Buffer ( to process . length ( ) + NUM ) ; while ( st . has More Tokens ( ) ) { tmp = st . next Token ( ) ; if ( has Attribute ( tmp ) ) new Value . append ( ( String ) get ( tmp ) ) ; else new Value . append ( tmp ) ; } return new Value . to String ( ) ; }
public static Document string To Dom ( String xml String , boolean use Namespaces ) throws SAX Exception { Document Builder Factory factory = Document Builder Factory . new Instance ( ) ; factory . set Namespace Aware ( use Namespaces ) ; String Reader reader = new String Reader ( xml String ) ; Input Source input = new Input Source ( reader ) ; Document Builder builder ; try { builder = factory . new Document Builder ( ) ; } catch ( Parser Configuration Exception e ) { log . fatal ( STRING + e . get Message ( ) ) ; return null ; } Document dom ; try { dom = builder . parse ( input ) ; } catch ( IO Exception e ) { log . fatal ( STRING + e . get Message ( ) ) ; return null ; } return dom ; }
public static Document string To Dom ( String xml String , boolean use Namespaces ) throws SAX Exception { Document Builder Factory factory = Document Builder Factory . new Instance ( ) ; factory . set Namespace Aware ( use Namespaces ) ; String Reader reader = new String Reader ( xml String ) ; Input Source input = new Input Source ( reader ) ; Document Builder builder ; try { builder = factory . new Document Builder ( ) ; } catch ( Parser Configuration Exception e ) { log . fatal ( STRING + e . get Message ( ) ) ; return null ; } Document dom ; try { dom = builder . parse ( input ) ; } catch ( IO Exception e ) { log . fatal ( STRING + e . get Message ( ) ) ; return null ; } return dom ; }
public void write Field ( String name , String value ) throws IO Exception { if ( name == null ) { throw new Illegal Argument Exception ( STRING ) ; } out . write Bytes ( PREFIX ) ; out . write Bytes ( boundary ) ; out . write Bytes ( NEWLINE ) ; out . write Bytes ( STRING + name + STRING ) ; out . write Bytes ( NEWLINE ) ; out . write Bytes ( NEWLINE ) ; if ( value != null ) { out . write Bytes ( value ) ; } out . write Bytes ( NEWLINE ) ; out . flush ( ) ; }
public Server Configuration kill Bookie ( int index ) throws Exception { if ( index >= bs . size ( ) ) { throw new IO Exception ( STRING ) ; } Bookie Server server = bs . get ( index ) ; server . shutdown ( ) ; stop Auto Recovery Service ( server ) ; bs . remove ( server ) ; return bs Confs . remove ( index ) ; }
public static boolean remove Bean Or Folder ( String path ) { return remove Path ( path . split ( PATH SEPARATOR ) , s directory , NUM ) > NUM ; }
public void close ( Result Set rs ) { try { Statement statement = rs . get Statement ( ) ; rs . close ( ) ; statement . close ( ) ; statement = null ; rs = null ; } catch ( Exception e ) { } }
public void close ( Result Set rs ) { try { Statement statement = rs . get Statement ( ) ; rs . close ( ) ; statement . close ( ) ; statement = null ; rs = null ; } catch ( Exception e ) { } }
public D Netscape Base Url ( J Dialog parent , byte [ ] value ) throws IO Exception { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
protected double compute ( String value ) { if ( value != null ) { try { return Double . parse Double ( value ) ; } catch ( Number Format Exception e ) { if ( POSITIVE INFINITY STRING . equals ( value ) ) { return Double . POSITIVE INFINITY ; } else if ( NEGATIVE INFINITY STRING . equals ( value ) ) { return Double . NEGATIVE INFINITY ; } return Double . Na N ; } } return Double . Na N ; }
public void force Put ( E e ) throws Interrupted Exception { if ( e == null ) throw new Null Pointer Exception ( ) ; int c = - NUM ; final Reentrant Lock put Lock = this . put Lock ; final Atomic Integer count = this . count ; put Lock . lock Interruptibly ( ) ; try { enqueue ( e ) ; c = count . get And Increment ( ) ; if ( c + NUM < capacity ) not Full . signal ( ) ; } finally { put Lock . unlock ( ) ; } if ( c == NUM ) signal Not Empty ( ) ; }
public void force Put ( E e ) throws Interrupted Exception { if ( e == null ) throw new Null Pointer Exception ( ) ; int c = - NUM ; final Reentrant Lock put Lock = this . put Lock ; final Atomic Integer count = this . count ; put Lock . lock Interruptibly ( ) ; try { enqueue ( e ) ; c = count . get And Increment ( ) ; if ( c + NUM < capacity ) not Full . signal ( ) ; } finally { put Lock . unlock ( ) ; } if ( c == NUM ) signal Not Empty ( ) ; }
public void force Put ( E e ) throws Interrupted Exception { if ( e == null ) throw new Null Pointer Exception ( ) ; int c = - NUM ; final Reentrant Lock put Lock = this . put Lock ; final Atomic Integer count = this . count ; put Lock . lock Interruptibly ( ) ; try { enqueue ( e ) ; c = count . get And Increment ( ) ; if ( c + NUM < capacity ) not Full . signal ( ) ; } finally { put Lock . unlock ( ) ; } if ( c == NUM ) signal Not Empty ( ) ; }
public static J Cas run Test ( String a Document Id , Analysis Engine a Engine , String a Language , String a Document ) throws UIMA Exception { if ( offline ) { System . set Property ( Resource Object Provider Base . PROP REPO OFFLINE , STRING ) ; } offline = BOOL ; J Cas jcas = a Engine . new J Cas ( ) ; if ( a Document Id != null ) { Document Meta Data meta = Document Meta Data . create ( jcas ) ; meta . set Document Id ( a Document Id ) ; } jcas . set Document Language ( a Language ) ; Token Builder < Token , Sentence > tb = new Token Builder < Token , Sentence > ( Token . class , Sentence . class ) ; tb . build Tokens ( jcas , a Document ) ; a Engine . process ( jcas ) ; Assert Annotations . assert Valid ( jcas ) ; return jcas ; }
public static J Cas run Test ( String a Document Id , Analysis Engine a Engine , String a Language , String a Document ) throws UIMA Exception { if ( offline ) { System . set Property ( Resource Object Provider Base . PROP REPO OFFLINE , STRING ) ; } offline = BOOL ; J Cas jcas = a Engine . new J Cas ( ) ; if ( a Document Id != null ) { Document Meta Data meta = Document Meta Data . create ( jcas ) ; meta . set Document Id ( a Document Id ) ; } jcas . set Document Language ( a Language ) ; Token Builder < Token , Sentence > tb = new Token Builder < Token , Sentence > ( Token . class , Sentence . class ) ; tb . build Tokens ( jcas , a Document ) ; a Engine . process ( jcas ) ; Assert Annotations . assert Valid ( jcas ) ; return jcas ; }
public void add Update Callback ( I Local Callback cb ) { synchronized ( m Update Callbacks ) { m Update Callbacks . add ( cb ) ; } }
public static byte [ ] hex String To Bytes ( String hex ) { int l = ( hex . length ( ) + NUM ) / NUM ; byte [ ] r = new byte [ l ] ; int i = NUM ; int j = NUM ; if ( hex . length ( ) % NUM == NUM ) { r [ NUM ] = hex Digit To Byte ( hex . char At ( NUM ) ) ; i = j = NUM ; } while ( i < l ) r [ i ++ ] = ( byte ) ( ( hex Digit To Byte ( hex . char At ( j ++ ) ) << NUM ) | hex Digit To Byte ( hex . char At ( j ++ ) ) ) ; return r ; }
protected boolean is Always Non Null ( Value v ) { return BOOL ; }
protected boolean is Always Non Null ( Value v ) { return BOOL ; }
private final double read Datum ( final Data Input in , final Column Type column Type ) throws IO Exception { switch ( column Type ) { case DOUBLE : return in . read Double ( ) ; case INTEGER : int i Value = in . read Int ( ) ; if ( i Value == Integer . MIN VALUE + NUM ) { boolean is Missing = in . read Boolean ( ) ; if ( is Missing ) { return Double . Na N ; } else { return i Value ; } } else { return i Value ; } case NOMINAL BYTE : byte b Value = in . read Byte ( ) ; if ( b Value == - NUM ) { return Double . Na N ; } else { return b Value ; } case NOMINAL INTEGER : i Value = in . read Int ( ) ; if ( i Value == - NUM ) { return Double . Na N ; } else { return i Value ; } case NOMINAL SHORT : short s Value = in . read Short ( ) ; if ( s Value == - NUM ) { return Double . Na N ; } else { return s Value ; } default : throw new Runtime Exception ( STRING + column Type ) ; } }
private final double read Datum ( final Data Input in , final Column Type column Type ) throws IO Exception { switch ( column Type ) { case DOUBLE : return in . read Double ( ) ; case INTEGER : int i Value = in . read Int ( ) ; if ( i Value == Integer . MIN VALUE + NUM ) { boolean is Missing = in . read Boolean ( ) ; if ( is Missing ) { return Double . Na N ; } else { return i Value ; } } else { return i Value ; } case NOMINAL BYTE : byte b Value = in . read Byte ( ) ; if ( b Value == - NUM ) { return Double . Na N ; } else { return b Value ; } case NOMINAL INTEGER : i Value = in . read Int ( ) ; if ( i Value == - NUM ) { return Double . Na N ; } else { return i Value ; } case NOMINAL SHORT : short s Value = in . read Short ( ) ; if ( s Value == - NUM ) { return Double . Na N ; } else { return s Value ; } default : throw new Runtime Exception ( STRING + column Type ) ; } }
private void process New Port ( Datapath Id sw , OF Port p ) { if ( is Link Discovery Suppressed ( sw , p ) ) { return ; } IOF Switch iof Switch = switch Service . get Switch ( sw ) ; if ( iof Switch == null ) { return ; } Node Port Tuple npt = new Node Port Tuple ( sw , p ) ; discover ( sw , p ) ; add To Quarantine Queue ( npt ) ; }
private void process New Port ( Datapath Id sw , OF Port p ) { if ( is Link Discovery Suppressed ( sw , p ) ) { return ; } IOF Switch iof Switch = switch Service . get Switch ( sw ) ; if ( iof Switch == null ) { return ; } Node Port Tuple npt = new Node Port Tuple ( sw , p ) ; discover ( sw , p ) ; add To Quarantine Queue ( npt ) ; }
protected void show Popup ( Iterator < String > iter ) { get Popup Component ( ) ; boolean different = BOOL ; Vector < String > v = new Vector < String > ( ) ; List Model < String > model = entry List . get Model ( ) ; for ( int i = NUM ; iter . has Next ( ) ; i ++ ) { String next = iter . next ( ) ; v . add ( next ) ; if ( ! different && i < model . get Size ( ) ) different |= ! next . equals ( model . get Element At ( i ) ) ; } different |= model . get Size ( ) != v . size ( ) ; if ( different ) { entry List . set List Data ( v ) ; entry List . clear Selection ( ) ; } entry List . set Current Text ( get Text ( ) ) ; show Popup ( ) ; }
public static byte [ ] decode ( String data ) throws Coder Exception { byte [ ] array = new byte [ data . length ( ) * NUM / NUM ] ; char [ ] block = new char [ NUM ] ; int length = NUM ; data = data . trim ( ) ; final int len = data . length ( ) ; if ( len == NUM ) return new byte [ NUM ] ; if ( len % NUM != NUM || len < NUM ) throw new Coder Exception ( STRING + print String ( data ) + STRING ) ; for ( int position = NUM ; position < len ; ) { int p ; for ( p = NUM ; p < NUM && position < data . length ( ) ; position ++ ) { char c = data . char At ( position ) ; if ( ! Character . is Whitespace ( c ) ) { block [ p ] = c ; p ++ ; } } if ( p == NUM ) break ; int l = decode Group ( block , array , length ) ; length += l ; if ( l < NUM ) break ; } return Arrays . copy Of ( array , length ) ; }
public String to HTML ( ) { String Builder builder = new String Builder ( ) ; int num Classes = classes . size ( ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( String . format ( STRING , num Classes + NUM ) ) ; builder . append ( STRING ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( predicted ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( STRING ) ; String first Column Label = String . format ( STRING , num Classes + NUM ) ; for ( T actual : classes ) { builder . append ( first Column Label ) ; first Column Label = STRING ; builder . append ( String . format ( STRING , actual ) ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( get Count ( actual , predicted ) ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( get Actual Total ( actual ) ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( get Predicted Total ( predicted ) ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; return builder . to String ( ) ; }
public String to HTML ( ) { String Builder builder = new String Builder ( ) ; int num Classes = classes . size ( ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( String . format ( STRING , num Classes + NUM ) ) ; builder . append ( STRING ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( predicted ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( STRING ) ; String first Column Label = String . format ( STRING , num Classes + NUM ) ; for ( T actual : classes ) { builder . append ( first Column Label ) ; first Column Label = STRING ; builder . append ( String . format ( STRING , actual ) ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( get Count ( actual , predicted ) ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( get Actual Total ( actual ) ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( get Predicted Total ( predicted ) ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; return builder . to String ( ) ; }
public String to HTML ( ) { String Builder builder = new String Builder ( ) ; int num Classes = classes . size ( ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( String . format ( STRING , num Classes + NUM ) ) ; builder . append ( STRING ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( predicted ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( STRING ) ; String first Column Label = String . format ( STRING , num Classes + NUM ) ; for ( T actual : classes ) { builder . append ( first Column Label ) ; first Column Label = STRING ; builder . append ( String . format ( STRING , actual ) ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( get Count ( actual , predicted ) ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( get Actual Total ( actual ) ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( get Predicted Total ( predicted ) ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; return builder . to String ( ) ; }
void close ( ) throws IO Exception ;
void close ( ) throws IO Exception ;
void close ( ) throws IO Exception ;
void close ( ) throws IO Exception ;
@ Override public void destroy ( ) { Thread thread = Thread . current Thread ( ) ; Class Loader old Loader = thread . get Context Class Loader ( ) ; try { thread . set Context Class Loader ( this ) ; Weak Stop Listener stop Listener = stop Listener ; stop Listener = null ; super . destroy ( ) ; thread . set Context Class Loader ( old Loader ) ; Class Loader parent = get Parent ( ) ; for ( ; parent != null ; parent = parent . get Parent ( ) ) { if ( parent instanceof Environment Class Loader ) { Environment Class Loader loader = ( Environment Class Loader ) parent ; loader . remove Listener ( stop Listener ) ; } } } finally { thread . set Context Class Loader ( old Loader ) ; attributes = null ; listeners = null ; } }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return AFTER ID ; case NUM : return MAX JOBS ; default : return null ; } }
public Default Terminal Factory ( ) { this ( DEFAULT OUTPUT STREAM , DEFAULT INPUT STREAM , DEFAULT CHARSET ) ; }
static private String LONG Min ( ) { long temp Value = Long . MIN VALUE ; return String . value Of ( temp Value ) ; }
static private String LONG Min ( ) { long temp Value = Long . MIN VALUE ; return String . value Of ( temp Value ) ; }
public static String implode ( Collection < String > items , String delimiter ) { Parameters . not Null ( STRING , items ) ; Parameters . not Null ( STRING , delimiter ) ; if ( items . is Empty ( ) ) { return STRING ; } String Builder buffer = new String Builder ( NUM ) ; boolean first = BOOL ; for ( String s : items ) { if ( ! first ) { buffer . append ( delimiter ) ; } buffer . append ( s ) ; first = BOOL ; } return buffer . to String ( ) ; }
public void init ( ) throws Space Components Initialize Exception { components Handlers = space . get Space Component Handlers ( ) ; try { Space Initialization Indicator . set Initializer ( ) ; for ( Iterator < I Space Components Handler > iterator = components Handlers . iterator ( ) ; iterator . has Next ( ) ; ) { I Space Components Handler handler = iterator . next ( ) ; if ( handler . is Recovery Supported ( ) ) handler . init Components ( BOOL ) ; } } finally { Space Initialization Indicator . unset Initializer ( ) ; } space . add Internal Space Mode Listener ( this ) ; }
public void init ( ) throws Space Components Initialize Exception { components Handlers = space . get Space Component Handlers ( ) ; try { Space Initialization Indicator . set Initializer ( ) ; for ( Iterator < I Space Components Handler > iterator = components Handlers . iterator ( ) ; iterator . has Next ( ) ; ) { I Space Components Handler handler = iterator . next ( ) ; if ( handler . is Recovery Supported ( ) ) handler . init Components ( BOOL ) ; } } finally { Space Initialization Indicator . unset Initializer ( ) ; } space . add Internal Space Mode Listener ( this ) ; }
public void init ( ) throws Space Components Initialize Exception { components Handlers = space . get Space Component Handlers ( ) ; try { Space Initialization Indicator . set Initializer ( ) ; for ( Iterator < I Space Components Handler > iterator = components Handlers . iterator ( ) ; iterator . has Next ( ) ; ) { I Space Components Handler handler = iterator . next ( ) ; if ( handler . is Recovery Supported ( ) ) handler . init Components ( BOOL ) ; } } finally { Space Initialization Indicator . unset Initializer ( ) ; } space . add Internal Space Mode Listener ( this ) ; }
public static boolean write ( Writer writer , Object to Serialize ) throws Exception { Class < ? > xstream Class ; java . lang . reflect . Constructor < ? > constructor ; Object xstream ; Class < ? > [ ] serialize Args Classes = new Class [ NUM ] ; Object [ ] serialize Args = new Object [ NUM ] ; java . lang . reflect . Method method Serialize ; boolean result = BOOL ; xstream Class = Class . for Name ( STRING ) ; constructor = xstream Class . get Constructor ( ) ; xstream = constructor . new Instance ( ) ; serialize Args Classes [ NUM ] = Object . class ; serialize Args Classes [ NUM ] = Writer . class ; serialize Args [ NUM ] = to Serialize ; serialize Args [ NUM ] = writer ; method Serialize = xstream Class . get Method ( STRING , serialize Args Classes ) ; try { method Serialize . invoke ( xstream , serialize Args ) ; result = BOOL ; } catch ( Exception ex ) { result = BOOL ; } return result ; }
public Printf Format ( final String fmt Arg ) throws Illegal Argument Exception { this ( Locale . get Default ( ) , fmt Arg ) ; }
public Printf Format ( final String fmt Arg ) throws Illegal Argument Exception { this ( Locale . get Default ( ) , fmt Arg ) ; }
public static long now ( ) { return System . current Time Millis ( ) ; }
public static long now ( ) { return System . current Time Millis ( ) ; }
protected void profile Created ( Profile profile ) { }
private void add Tv Show Season ( Tv Show Season season , Tv Show tv Show ) { if ( node Map . get ( season ) != null ) { return ; } Tv Show Tree Node parent = ( Tv Show Tree Node ) node Map . get ( tv Show ) ; Tv Show Season Tree Node child = new Tv Show Season Tree Node ( season ) ; if ( parent != null ) { parent . add ( child ) ; node Map . put ( season , child ) ; int index = get Index Of Child ( parent , child ) ; if ( index > - NUM ) { Tree Model Event event = new Tree Model Event ( this , parent . get Path ( ) , new int [ ] { index } , new Object [ ] { child } ) ; for ( Tree Model Listener listener : listeners ) { try { listener . tree Nodes Inserted ( event ) ; } catch ( Null Pointer Exception | Array Index Out Of Bounds Exception ignored ) { } } } Tree Model Event event = new Tree Model Event ( this , root . get Path ( ) , null , null ) ; for ( Tree Model Listener listener : listeners ) { try { listener . tree Nodes Changed ( event ) ; } catch ( Null Pointer Exception | Array Index Out Of Bounds Exception ignored ) { } } } }
private void update Center Panel ( ) { long now = System . current Time Millis ( ) ; if ( next Update Time > now ) return ; next Update Time = now + NUM * NUM ; center Panel . remove All ( ) ; center Component = new J Label ( ) ; Grid Bag Constraints gbc = new Grid Bag Constraints ( ) ; gbc . gridx = NUM ; gbc . gridy = NUM ; gbc . weightx = NUM ; gbc . fill = Grid Bag Constraints . NONE ; gbc . anchor = Grid Bag Constraints . CENTER ; center Panel . add ( center Component , gbc ) ; refresh ( ) ; }
private void update Center Panel ( ) { long now = System . current Time Millis ( ) ; if ( next Update Time > now ) return ; next Update Time = now + NUM * NUM ; center Panel . remove All ( ) ; center Component = new J Label ( ) ; Grid Bag Constraints gbc = new Grid Bag Constraints ( ) ; gbc . gridx = NUM ; gbc . gridy = NUM ; gbc . weightx = NUM ; gbc . fill = Grid Bag Constraints . NONE ; gbc . anchor = Grid Bag Constraints . CENTER ; center Panel . add ( center Component , gbc ) ; refresh ( ) ; }
private void update Center Panel ( ) { long now = System . current Time Millis ( ) ; if ( next Update Time > now ) return ; next Update Time = now + NUM * NUM ; center Panel . remove All ( ) ; center Component = new J Label ( ) ; Grid Bag Constraints gbc = new Grid Bag Constraints ( ) ; gbc . gridx = NUM ; gbc . gridy = NUM ; gbc . weightx = NUM ; gbc . fill = Grid Bag Constraints . NONE ; gbc . anchor = Grid Bag Constraints . CENTER ; center Panel . add ( center Component , gbc ) ; refresh ( ) ; }
public void add Close Client Listener ( Close Client Listener l ) { close Client Listeners . add Element ( l ) ; }
public void add Close Client Listener ( Close Client Listener l ) { close Client Listeners . add Element ( l ) ; }
public void add Close Client Listener ( Close Client Listener l ) { close Client Listeners . add Element ( l ) ; }
public void add Close Client Listener ( Close Client Listener l ) { close Client Listeners . add Element ( l ) ; }
protected void init Pool ( ) { running = BOOL ; for ( int i = size ; -- i >= NUM ; ) { Pool Thread thread = new Pool Thread ( ) ; thread Pool . add ( thread ) ; thread . start ( ) ; } }
private static Future < ? > direct Execute ( Runnable runnable , long delay ) { Future < ? > future = null ; if ( delay > NUM ) { if ( ! ( executor instanceof Scheduled Executor Service ) ) { throw new Illegal Argument Exception ( STRING ) ; } Scheduled Executor Service scheduled Executor Service = ( Scheduled Executor Service ) executor ; future = scheduled Executor Service . schedule ( runnable , delay , Time Unit . MILLISECONDS ) ; } else { if ( executor instanceof Executor Service ) { Executor Service executor Service = ( Executor Service ) executor ; future = executor Service . submit ( runnable ) ; } else { executor . execute ( runnable ) ; } } return future ; }
private static Future < ? > direct Execute ( Runnable runnable , long delay ) { Future < ? > future = null ; if ( delay > NUM ) { if ( ! ( executor instanceof Scheduled Executor Service ) ) { throw new Illegal Argument Exception ( STRING ) ; } Scheduled Executor Service scheduled Executor Service = ( Scheduled Executor Service ) executor ; future = scheduled Executor Service . schedule ( runnable , delay , Time Unit . MILLISECONDS ) ; } else { if ( executor instanceof Executor Service ) { Executor Service executor Service = ( Executor Service ) executor ; future = executor Service . submit ( runnable ) ; } else { executor . execute ( runnable ) ; } } return future ; }
private String build Auth Header String ( String https URL , String request Method , O Auth Parameters params ) { generate And Sign Signature ( https URL , request Method , params ) ; String Buffer buffer = new String Buffer ( ) ; buffer . append ( OAUTH START STRING ) ; Map < String , Sorted Set < String > > param Map = params . get Base Parameters ( ) ; buffer = parse Parameters ( buffer , param Map ) ; this . auth Header = buffer . to String ( ) ; return buffer . to String ( ) ; }
private String build Auth Header String ( String https URL , String request Method , O Auth Parameters params ) { generate And Sign Signature ( https URL , request Method , params ) ; String Buffer buffer = new String Buffer ( ) ; buffer . append ( OAUTH START STRING ) ; Map < String , Sorted Set < String > > param Map = params . get Base Parameters ( ) ; buffer = parse Parameters ( buffer , param Map ) ; this . auth Header = buffer . to String ( ) ; return buffer . to String ( ) ; }
synchronized void unregister To Notifications ( ) throws JMS Exception { if ( event Session == null ) { return ; } if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , to String 2 ( ) + STRING ) ; } try { event Session . close ( ) ; } catch ( IO Exception e ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , to String 2 ( ) + STRING + e ) ; } JMS Exception e1 = new JMS Exception ( STRING ) ; e1 . set Linked Exception ( e ) ; throw e1 ; } catch ( Unknown Lease Exception e ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , to String 2 ( ) + STRING + e ) ; } JMS Exception e1 = new JMS Exception ( STRING ) ; e1 . set Linked Exception ( e ) ; throw e1 ; } catch ( Exception e ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , to String 2 ( ) + STRING + e ) ; } JMS Exception e1 = new JMS Exception ( STRING ) ; e1 . set Linked Exception ( e ) ; throw e1 ; } finally { event Session = null ; } }
public Element select Element Matching X Path ( String xpath , Element to Search ) { List < Element > results = select Elements Matching X Path ( xpath , to Search ) ; if ( results . is Empty ( ) ) { throw new Element Not Found Exception ( xpath , to Search ) ; } Element match = results . get ( NUM ) ; return match ; }
public boolean check Error ( ) { try { out . flush ( ) ; } catch ( IO Exception e ) { had Error = BOOL ; } return had Error ; }
public boolean check Error ( ) { try { out . flush ( ) ; } catch ( IO Exception e ) { had Error = BOOL ; } return had Error ; }
public static String extract Actual Instance Type ( String instance Type ) { String [ ] split = instance Type . split ( STRING ) ; return split [ split . length - NUM ] ; }
public boolean is Cloud Message Fail Silently ( ) { return cloud Message Fail Silently ; }
public boolean is Cloud Message Fail Silently ( ) { return cloud Message Fail Silently ; }
private static int convert To Int ( String value , int default Value ) { String trim = value . trim ( ) ; if ( trim . length ( ) == NUM ) { return default Value ; } return Integer . parse Int ( trim ) ; }
private T Input create Input ( String type , String name , String value ) { String out Val = value ; if ( value . contains ( STRING ) || value . contains ( STRING ) ) { if ( unique Sources . contains Key ( value ) && value . contains ( STRING ) ) { out Val = STRING + unique Sources . get ( value ) ; } else { int s = num Sources ; num Sources ++ ; unique Sources . put ( value , s ) ; out Val = STRING + s ; } } else if ( value . contains ( STRING ) ) { out Val = STRING ; } return new T Input ( type , name , out Val ) ; }
public Iterator < String > iterate Controllers ( ) { return controllers . iterator ( ) ; }
public String resolve Path ( String path Info ) { if ( ( path Info == null ) || ( path Info . index Of ( STRING ) != - NUM ) ) { return null ; } int lib Start = path Info . index Of ( STRING ) + NUM ; int lib End = path Info . index Of ( STRING , lib Start ) ; if ( lib End == - NUM ) { lib End = path Info . length ( ) ; } String libname = path Info . substring ( lib Start , lib End ) ; String subpath = path Info . substring ( lib End ) ; String lib home = get Path ( libname ) ; if ( lib home == null ) { return null ; } return lib home + STRING + subpath ; }
public String resolve Path ( String path Info ) { if ( ( path Info == null ) || ( path Info . index Of ( STRING ) != - NUM ) ) { return null ; } int lib Start = path Info . index Of ( STRING ) + NUM ; int lib End = path Info . index Of ( STRING , lib Start ) ; if ( lib End == - NUM ) { lib End = path Info . length ( ) ; } String libname = path Info . substring ( lib Start , lib End ) ; String subpath = path Info . substring ( lib End ) ; String lib home = get Path ( libname ) ; if ( lib home == null ) { return null ; } return lib home + STRING + subpath ; }
public String resolve Path ( String path Info ) { if ( ( path Info == null ) || ( path Info . index Of ( STRING ) != - NUM ) ) { return null ; } int lib Start = path Info . index Of ( STRING ) + NUM ; int lib End = path Info . index Of ( STRING , lib Start ) ; if ( lib End == - NUM ) { lib End = path Info . length ( ) ; } String libname = path Info . substring ( lib Start , lib End ) ; String subpath = path Info . substring ( lib End ) ; String lib home = get Path ( libname ) ; if ( lib home == null ) { return null ; } return lib home + STRING + subpath ; }
public String resolve Path ( String path Info ) { if ( ( path Info == null ) || ( path Info . index Of ( STRING ) != - NUM ) ) { return null ; } int lib Start = path Info . index Of ( STRING ) + NUM ; int lib End = path Info . index Of ( STRING , lib Start ) ; if ( lib End == - NUM ) { lib End = path Info . length ( ) ; } String libname = path Info . substring ( lib Start , lib End ) ; String subpath = path Info . substring ( lib End ) ; String lib home = get Path ( libname ) ; if ( lib home == null ) { return null ; } return lib home + STRING + subpath ; }
public String resolve Path ( String path Info ) { if ( ( path Info == null ) || ( path Info . index Of ( STRING ) != - NUM ) ) { return null ; } int lib Start = path Info . index Of ( STRING ) + NUM ; int lib End = path Info . index Of ( STRING , lib Start ) ; if ( lib End == - NUM ) { lib End = path Info . length ( ) ; } String libname = path Info . substring ( lib Start , lib End ) ; String subpath = path Info . substring ( lib End ) ; String lib home = get Path ( libname ) ; if ( lib home == null ) { return null ; } return lib home + STRING + subpath ; }
public byte [ ] read Raw Bytes ( final int size ) throws IO Exception { if ( size < NUM ) { throw Invalid Protocol Buffer Nano Exception . negative Size ( ) ; } if ( buffer Pos + size > current Limit ) { skip Raw Bytes ( current Limit - buffer Pos ) ; throw Invalid Protocol Buffer Nano Exception . truncated Message ( ) ; } if ( size <= buffer Size - buffer Pos ) { final byte [ ] bytes = new byte [ size ] ; System . arraycopy ( buffer , buffer Pos , bytes , NUM , size ) ; buffer Pos += size ; return bytes ; } else { throw Invalid Protocol Buffer Nano Exception . truncated Message ( ) ; } }
public Deferred Subscription Subscriber ( Subscriber < ? super O > subscriber ) { this . subscriber = Objects . require Non Null ( subscriber , STRING ) ; }
static void compute Caller Map ( Json Element json Elt , boolean top Level , Map < String , Map < String , Set < Json Element > > > caller Map ) { Json Array children Array = Utils . get Children Array ( json Elt ) ; String sig = Utils . get Field Value As String ( json Elt , STRING ) ; if ( children Array != null ) { for ( int i = NUM ; i < children Array . size ( ) ; i ++ ) { Json Element child = children Array . get ( i ) ; if ( child . is Json Object ( ) && ! Utils . is Empty Json Object ( child ) ) { Json Object child Obj = child . get As Json Object ( ) ; String child Sig = Utils . get Field Value As String ( child Obj , STRING ) ; if ( ! top Level ) { Map < String , Set < Json Element > > callers = caller Map . get ( child Sig ) ; if ( callers == null ) { callers = new Hash Map < String , Set < Json Element > > ( ) ; caller Map . put ( child Sig , callers ) ; } Set < Json Element > calls = callers . get ( sig ) ; if ( calls == null ) { calls = new Hash Set < Json Element > ( ) ; callers . put ( sig , calls ) ; } calls . add ( json Elt ) ; } compute Caller Map ( child Obj , BOOL , caller Map ) ; } } } }
static void compute Caller Map ( Json Element json Elt , boolean top Level , Map < String , Map < String , Set < Json Element > > > caller Map ) { Json Array children Array = Utils . get Children Array ( json Elt ) ; String sig = Utils . get Field Value As String ( json Elt , STRING ) ; if ( children Array != null ) { for ( int i = NUM ; i < children Array . size ( ) ; i ++ ) { Json Element child = children Array . get ( i ) ; if ( child . is Json Object ( ) && ! Utils . is Empty Json Object ( child ) ) { Json Object child Obj = child . get As Json Object ( ) ; String child Sig = Utils . get Field Value As String ( child Obj , STRING ) ; if ( ! top Level ) { Map < String , Set < Json Element > > callers = caller Map . get ( child Sig ) ; if ( callers == null ) { callers = new Hash Map < String , Set < Json Element > > ( ) ; caller Map . put ( child Sig , callers ) ; } Set < Json Element > calls = callers . get ( sig ) ; if ( calls == null ) { calls = new Hash Set < Json Element > ( ) ; callers . put ( sig , calls ) ; } calls . add ( json Elt ) ; } compute Caller Map ( child Obj , BOOL , caller Map ) ; } } } }
static void compute Caller Map ( Json Element json Elt , boolean top Level , Map < String , Map < String , Set < Json Element > > > caller Map ) { Json Array children Array = Utils . get Children Array ( json Elt ) ; String sig = Utils . get Field Value As String ( json Elt , STRING ) ; if ( children Array != null ) { for ( int i = NUM ; i < children Array . size ( ) ; i ++ ) { Json Element child = children Array . get ( i ) ; if ( child . is Json Object ( ) && ! Utils . is Empty Json Object ( child ) ) { Json Object child Obj = child . get As Json Object ( ) ; String child Sig = Utils . get Field Value As String ( child Obj , STRING ) ; if ( ! top Level ) { Map < String , Set < Json Element > > callers = caller Map . get ( child Sig ) ; if ( callers == null ) { callers = new Hash Map < String , Set < Json Element > > ( ) ; caller Map . put ( child Sig , callers ) ; } Set < Json Element > calls = callers . get ( sig ) ; if ( calls == null ) { calls = new Hash Set < Json Element > ( ) ; callers . put ( sig , calls ) ; } calls . add ( json Elt ) ; } compute Caller Map ( child Obj , BOOL , caller Map ) ; } } } }
static void compute Caller Map ( Json Element json Elt , boolean top Level , Map < String , Map < String , Set < Json Element > > > caller Map ) { Json Array children Array = Utils . get Children Array ( json Elt ) ; String sig = Utils . get Field Value As String ( json Elt , STRING ) ; if ( children Array != null ) { for ( int i = NUM ; i < children Array . size ( ) ; i ++ ) { Json Element child = children Array . get ( i ) ; if ( child . is Json Object ( ) && ! Utils . is Empty Json Object ( child ) ) { Json Object child Obj = child . get As Json Object ( ) ; String child Sig = Utils . get Field Value As String ( child Obj , STRING ) ; if ( ! top Level ) { Map < String , Set < Json Element > > callers = caller Map . get ( child Sig ) ; if ( callers == null ) { callers = new Hash Map < String , Set < Json Element > > ( ) ; caller Map . put ( child Sig , callers ) ; } Set < Json Element > calls = callers . get ( sig ) ; if ( calls == null ) { calls = new Hash Set < Json Element > ( ) ; callers . put ( sig , calls ) ; } calls . add ( json Elt ) ; } compute Caller Map ( child Obj , BOOL , caller Map ) ; } } } }
private static String do Get Full Path ( String filename , boolean include Separator ) { if ( filename == null ) return null ; int prefix = get Prefix Length ( filename ) ; if ( prefix < NUM ) return null ; if ( prefix >= filename . length ( ) ) { if ( include Separator ) return get Prefix ( filename ) ; else return filename ; } int index = index Of Last Separator ( filename ) ; if ( index < NUM ) return filename . substring ( NUM , prefix ) ; int end = index + ( include Separator ? NUM : NUM ) ; if ( end == NUM ) end ++ ; return filename . substring ( NUM , end ) ; }
public void start ( ) { running = BOOL ; start Time Millis = System . current Time Millis ( ) ; thread = new Thread ( this , THREAD NAME PREFIX + get Port ( ) ) ; thread . start ( ) ; }
public void start ( ) { running = BOOL ; start Time Millis = System . current Time Millis ( ) ; thread = new Thread ( this , THREAD NAME PREFIX + get Port ( ) ) ; thread . start ( ) ; }
public void start ( ) { running = BOOL ; start Time Millis = System . current Time Millis ( ) ; thread = new Thread ( this , THREAD NAME PREFIX + get Port ( ) ) ; thread . start ( ) ; }
public void start ( ) { running = BOOL ; start Time Millis = System . current Time Millis ( ) ; thread = new Thread ( this , THREAD NAME PREFIX + get Port ( ) ) ; thread . start ( ) ; }
public void start ( ) { running = BOOL ; start Time Millis = System . current Time Millis ( ) ; thread = new Thread ( this , THREAD NAME PREFIX + get Port ( ) ) ; thread . start ( ) ; }
public void start ( ) { running = BOOL ; start Time Millis = System . current Time Millis ( ) ; thread = new Thread ( this , THREAD NAME PREFIX + get Port ( ) ) ; thread . start ( ) ; }
public void start ( ) { running = BOOL ; start Time Millis = System . current Time Millis ( ) ; thread = new Thread ( this , THREAD NAME PREFIX + get Port ( ) ) ; thread . start ( ) ; }
private int add Filtered Sub Items ( List < T > values , T item ) { if ( is Expandable ( item ) ) { I Expandable expandable = ( I Expandable ) item ; if ( has Sub Items ( expandable ) ) { List < T > filtered Sub Items = new Array List < > ( ) ; List < T > sub Items = expandable . get Sub Items ( ) ; for ( T sub Item : sub Items ) { if ( ! sub Item . is Hidden ( ) ) filtered Sub Items . add ( sub Item ) ; } values . add All ( filtered Sub Items ) ; return filtered Sub Items . size ( ) ; } } return NUM ; }
private String list To String ( List role Names ) { String Buffer sb = new String Buffer ( ) ; for ( Iterator i = role Names . iterator ( ) ; i . has Next ( ) ; ) { String role = ( String ) i . next ( ) ; if ( sb . length ( ) > NUM ) { sb . append ( STRING ) ; } sb . append ( get Localized String ( role + STRING ) ) ; } return sb . to String ( ) ; }
private String list To String ( List role Names ) { String Buffer sb = new String Buffer ( ) ; for ( Iterator i = role Names . iterator ( ) ; i . has Next ( ) ; ) { String role = ( String ) i . next ( ) ; if ( sb . length ( ) > NUM ) { sb . append ( STRING ) ; } sb . append ( get Localized String ( role + STRING ) ) ; } return sb . to String ( ) ; }
public < T > Json Array < T > create List Dto From Json ( Reader json , Class < T > dto Interface ) throws IO Exception { final Dto Provider < T > dto Provider = get Dto Provider ( dto Interface ) ; final List < Json Element > list ; try { list = gson . from Json ( json , list Type Cache . get ( Json Element . class ) ) ; } catch ( Json Syntax Exception e ) { final Throwable cause = e . get Cause ( ) ; if ( cause instanceof IO Exception ) { throw ( IO Exception ) cause ; } throw e ; } final List < T > result = new Array List < > ( list . size ( ) ) ; for ( Json Element e : list ) { result . add ( dto Provider . from Json ( e ) ) ; } return new Json Array Impl < > ( result ) ; }
public < T > Json Array < T > create List Dto From Json ( Reader json , Class < T > dto Interface ) throws IO Exception { final Dto Provider < T > dto Provider = get Dto Provider ( dto Interface ) ; final List < Json Element > list ; try { list = gson . from Json ( json , list Type Cache . get ( Json Element . class ) ) ; } catch ( Json Syntax Exception e ) { final Throwable cause = e . get Cause ( ) ; if ( cause instanceof IO Exception ) { throw ( IO Exception ) cause ; } throw e ; } final List < T > result = new Array List < > ( list . size ( ) ) ; for ( Json Element e : list ) { result . add ( dto Provider . from Json ( e ) ) ; } return new Json Array Impl < > ( result ) ; }
public void reclaim Views ( List < View > views ) { int child Count = get Child Count ( ) ; Recycler Listener listener = m Recycler . m Recycler Listener ; for ( int i = NUM ; i < child Count ; i ++ ) { View child = get Child At ( i ) ; PLA Abs List View . Layout Params lp = ( PLA Abs List View . Layout Params ) child . get Layout Params ( ) ; if ( lp != null && m Recycler . should Recycle View Type ( lp . view Type ) ) { views . add ( child ) ; if ( listener != null ) { listener . on Moved To Scrap Heap ( child ) ; } } } m Recycler . reclaim Scrap Views ( views ) ; remove All Views In Layout ( ) ; }
public void reclaim Views ( List < View > views ) { int child Count = get Child Count ( ) ; Recycler Listener listener = m Recycler . m Recycler Listener ; for ( int i = NUM ; i < child Count ; i ++ ) { View child = get Child At ( i ) ; PLA Abs List View . Layout Params lp = ( PLA Abs List View . Layout Params ) child . get Layout Params ( ) ; if ( lp != null && m Recycler . should Recycle View Type ( lp . view Type ) ) { views . add ( child ) ; if ( listener != null ) { listener . on Moved To Scrap Heap ( child ) ; } } } m Recycler . reclaim Scrap Views ( views ) ; remove All Views In Layout ( ) ; }
public void reclaim Views ( List < View > views ) { int child Count = get Child Count ( ) ; Recycler Listener listener = m Recycler . m Recycler Listener ; for ( int i = NUM ; i < child Count ; i ++ ) { View child = get Child At ( i ) ; PLA Abs List View . Layout Params lp = ( PLA Abs List View . Layout Params ) child . get Layout Params ( ) ; if ( lp != null && m Recycler . should Recycle View Type ( lp . view Type ) ) { views . add ( child ) ; if ( listener != null ) { listener . on Moved To Scrap Heap ( child ) ; } } } m Recycler . reclaim Scrap Views ( views ) ; remove All Views In Layout ( ) ; }
public static int find Next Consistency Id ( Database conn , Table ct ) throws Exception { int id = NUM ; try { Statement st ; st = conn . create Statement ( ) ; Result Set rs = st . execute Query ( STRING + Consistency Table . id Column Name + STRING + ct . get Schema ( ) + STRING + ct . get Name ( ) ) ; if ( rs . next ( ) ) { id = rs . get Int ( NUM ) + NUM ; } rs . close ( ) ; st . close ( ) ; } catch ( Exception e ) { logger . error ( STRING + e . get Message ( ) ) ; throw e ; } return id ; }
public static int find Next Consistency Id ( Database conn , Table ct ) throws Exception { int id = NUM ; try { Statement st ; st = conn . create Statement ( ) ; Result Set rs = st . execute Query ( STRING + Consistency Table . id Column Name + STRING + ct . get Schema ( ) + STRING + ct . get Name ( ) ) ; if ( rs . next ( ) ) { id = rs . get Int ( NUM ) + NUM ; } rs . close ( ) ; st . close ( ) ; } catch ( Exception e ) { logger . error ( STRING + e . get Message ( ) ) ; throw e ; } return id ; }
public Session ( ) { long uptime = System . current Time Millis ( ) ; Handler Thread thread = new Handler Thread ( STRING ) ; thread . start ( ) ; m Handler = new Handler ( thread . get Looper ( ) ) ; m Main Handler = new Handler ( Looper . get Main Looper ( ) ) ; m Timestamp = ( uptime / NUM ) << NUM & ( ( ( uptime - ( ( uptime / NUM ) * NUM ) ) > > NUM ) / NUM ) ; m Origin = STRING ; }
public Session ( ) { long uptime = System . current Time Millis ( ) ; Handler Thread thread = new Handler Thread ( STRING ) ; thread . start ( ) ; m Handler = new Handler ( thread . get Looper ( ) ) ; m Main Handler = new Handler ( Looper . get Main Looper ( ) ) ; m Timestamp = ( uptime / NUM ) << NUM & ( ( ( uptime - ( ( uptime / NUM ) * NUM ) ) > > NUM ) / NUM ) ; m Origin = STRING ; }
public synchronized void remove Threshold Data Listener ( Threshold Data Listener cl ) { m threshold Listeners . remove ( cl ) ; }
public Distributed Log Configuration ( ) { super ( ) ; add Configuration ( new System Configuration ( ) ) ; }
public java . lang . String Builder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STRING ; } int min = string . length ( ) ; if ( min != NUM ) { move ( min , index ) ; string . get Chars ( NUM , min , value , index ) ; count += min ; } return this ; }
public java . lang . String Builder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STRING ; } int min = string . length ( ) ; if ( min != NUM ) { move ( min , index ) ; string . get Chars ( NUM , min , value , index ) ; count += min ; } return this ; }
public java . lang . String Builder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STRING ; } int min = string . length ( ) ; if ( min != NUM ) { move ( min , index ) ; string . get Chars ( NUM , min , value , index ) ; count += min ; } return this ; }
public java . lang . String Builder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STRING ; } int min = string . length ( ) ; if ( min != NUM ) { move ( min , index ) ; string . get Chars ( NUM , min , value , index ) ; count += min ; } return this ; }
public java . lang . String Builder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STRING ; } int min = string . length ( ) ; if ( min != NUM ) { move ( min , index ) ; string . get Chars ( NUM , min , value , index ) ; count += min ; } return this ; }
public java . lang . String Builder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STRING ; } int min = string . length ( ) ; if ( min != NUM ) { move ( min , index ) ; string . get Chars ( NUM , min , value , index ) ; count += min ; } return this ; }
public java . lang . String Builder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STRING ; } int min = string . length ( ) ; if ( min != NUM ) { move ( min , index ) ; string . get Chars ( NUM , min , value , index ) ; count += min ; } return this ; }
public java . lang . String Builder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STRING ; } int min = string . length ( ) ; if ( min != NUM ) { move ( min , index ) ; string . get Chars ( NUM , min , value , index ) ; count += min ; } return this ; }
public void combine ( Stats o ) { max = Math . max ( max , o . max ) ; min = Math . min ( min , o . min ) ; m = m * ( n / ( double ) ( n + o . n ) ) + o . m * ( o . n / ( double ) ( n + o . n ) ) ; s = Double . Na N ; n += o . n ; }
public void combine ( Stats o ) { max = Math . max ( max , o . max ) ; min = Math . min ( min , o . min ) ; m = m * ( n / ( double ) ( n + o . n ) ) + o . m * ( o . n / ( double ) ( n + o . n ) ) ; s = Double . Na N ; n += o . n ; }
public void combine ( Stats o ) { max = Math . max ( max , o . max ) ; min = Math . min ( min , o . min ) ; m = m * ( n / ( double ) ( n + o . n ) ) + o . m * ( o . n / ( double ) ( n + o . n ) ) ; s = Double . Na N ; n += o . n ; }
public void combine ( Stats o ) { max = Math . max ( max , o . max ) ; min = Math . min ( min , o . min ) ; m = m * ( n / ( double ) ( n + o . n ) ) + o . m * ( o . n / ( double ) ( n + o . n ) ) ; s = Double . Na N ; n += o . n ; }
public static String dump ( final Byte Buffer bytes ) { bytes . rewind ( ) ; final int columns = NUM ; final String Builder builder = new String Builder ( ) ; int i = NUM ; while ( bytes . has Remaining ( ) ) { if ( ( i % columns ) != NUM ) { builder . append ( STRING ) ; } else if ( i >= columns ) { builder . append ( String . format ( STRING ) ) ; } builder . append ( String . format ( STRING , bytes . get ( ) ) ) ; i ++ ; } return builder . to String ( ) ; }
public Voice ( ) { utterance Processors = Collections . synchronized List ( new Array List ( ) ) ; features = new Feature Set Impl ( ) ; feature Processors = new Hash Map ( ) ; try { nominal Rate = Float . parse Float ( Utilities . get Property ( PROP PREFIX + STRING , STRING ) ) ; pitch = Float . parse Float ( Utilities . get Property ( PROP PREFIX + STRING , STRING ) ) ; range = Float . parse Float ( Utilities . get Property ( PROP PREFIX + STRING , STRING ) ) ; volume = Float . parse Float ( Utilities . get Property ( PROP PREFIX + STRING , STRING ) ) ; } catch ( Security Exception se ) { } output Queue = null ; audio Player = null ; default Audio Player = null ; }
public Voice ( ) { utterance Processors = Collections . synchronized List ( new Array List ( ) ) ; features = new Feature Set Impl ( ) ; feature Processors = new Hash Map ( ) ; try { nominal Rate = Float . parse Float ( Utilities . get Property ( PROP PREFIX + STRING , STRING ) ) ; pitch = Float . parse Float ( Utilities . get Property ( PROP PREFIX + STRING , STRING ) ) ; range = Float . parse Float ( Utilities . get Property ( PROP PREFIX + STRING , STRING ) ) ; volume = Float . parse Float ( Utilities . get Property ( PROP PREFIX + STRING , STRING ) ) ; } catch ( Security Exception se ) { } output Queue = null ; audio Player = null ; default Audio Player = null ; }
public Voice ( ) { utterance Processors = Collections . synchronized List ( new Array List ( ) ) ; features = new Feature Set Impl ( ) ; feature Processors = new Hash Map ( ) ; try { nominal Rate = Float . parse Float ( Utilities . get Property ( PROP PREFIX + STRING , STRING ) ) ; pitch = Float . parse Float ( Utilities . get Property ( PROP PREFIX + STRING , STRING ) ) ; range = Float . parse Float ( Utilities . get Property ( PROP PREFIX + STRING , STRING ) ) ; volume = Float . parse Float ( Utilities . get Property ( PROP PREFIX + STRING , STRING ) ) ; } catch ( Security Exception se ) { } output Queue = null ; audio Player = null ; default Audio Player = null ; }
public Voice ( ) { utterance Processors = Collections . synchronized List ( new Array List ( ) ) ; features = new Feature Set Impl ( ) ; feature Processors = new Hash Map ( ) ; try { nominal Rate = Float . parse Float ( Utilities . get Property ( PROP PREFIX + STRING , STRING ) ) ; pitch = Float . parse Float ( Utilities . get Property ( PROP PREFIX + STRING , STRING ) ) ; range = Float . parse Float ( Utilities . get Property ( PROP PREFIX + STRING , STRING ) ) ; volume = Float . parse Float ( Utilities . get Property ( PROP PREFIX + STRING , STRING ) ) ; } catch ( Security Exception se ) { } output Queue = null ; audio Player = null ; default Audio Player = null ; }
private static int annotated Fields Number ( Class < ? > a Class ) { int count = NUM ; for ( Field it : a Class . get Declared Fields ( ) ) if ( it . get Annotation ( J Map . class ) != null ) count ++ ; return count ; }
private static int annotated Fields Number ( Class < ? > a Class ) { int count = NUM ; for ( Field it : a Class . get Declared Fields ( ) ) if ( it . get Annotation ( J Map . class ) != null ) count ++ ; return count ; }
public double entropy NMI Min ( ) { return ( entropy Mutual Information ( ) / Math . min ( entropy First ( ) , entropy Second ( ) ) ) ; }
public Word Definition ( String s Word ) { Word = new String ( s Word . to Lower Case ( ) ) ; Hash = hash Word ( s Word ) ; }
Sentence Filtered Grammar ( Abstract Grammar base Grammar , Sentence sentence ) { super ( Owner Map . get Owner ( base Grammar . get Owner ( ) ) , base Grammar . joshua Configuration , base Grammar . get Span Limit ( ) ) ; this . base Grammar = base Grammar ; this . sentence = sentence ; this . tokens = sentence . get Word I Ds ( ) ; int orig Count = get Num Rules ( base Grammar . get Trie Root ( ) ) ; long start Time = System . current Time Millis ( ) ; this . filtered Trie = filter ( base Grammar . get Trie Root ( ) ) ; int filtered Count = get Num Rules ( ) ; float seconds = ( System . current Time Millis ( ) - start Time ) / NUM ; LOG . debug ( STRING , sentence . id ( ) , orig Count , filtered Count , seconds ) ; }
Sentence Filtered Grammar ( Abstract Grammar base Grammar , Sentence sentence ) { super ( Owner Map . get Owner ( base Grammar . get Owner ( ) ) , base Grammar . joshua Configuration , base Grammar . get Span Limit ( ) ) ; this . base Grammar = base Grammar ; this . sentence = sentence ; this . tokens = sentence . get Word I Ds ( ) ; int orig Count = get Num Rules ( base Grammar . get Trie Root ( ) ) ; long start Time = System . current Time Millis ( ) ; this . filtered Trie = filter ( base Grammar . get Trie Root ( ) ) ; int filtered Count = get Num Rules ( ) ; float seconds = ( System . current Time Millis ( ) - start Time ) / NUM ; LOG . debug ( STRING , sentence . id ( ) , orig Count , filtered Count , seconds ) ; }
Sentence Filtered Grammar ( Abstract Grammar base Grammar , Sentence sentence ) { super ( Owner Map . get Owner ( base Grammar . get Owner ( ) ) , base Grammar . joshua Configuration , base Grammar . get Span Limit ( ) ) ; this . base Grammar = base Grammar ; this . sentence = sentence ; this . tokens = sentence . get Word I Ds ( ) ; int orig Count = get Num Rules ( base Grammar . get Trie Root ( ) ) ; long start Time = System . current Time Millis ( ) ; this . filtered Trie = filter ( base Grammar . get Trie Root ( ) ) ; int filtered Count = get Num Rules ( ) ; float seconds = ( System . current Time Millis ( ) - start Time ) / NUM ; LOG . debug ( STRING , sentence . id ( ) , orig Count , filtered Count , seconds ) ; }
Sentence Filtered Grammar ( Abstract Grammar base Grammar , Sentence sentence ) { super ( Owner Map . get Owner ( base Grammar . get Owner ( ) ) , base Grammar . joshua Configuration , base Grammar . get Span Limit ( ) ) ; this . base Grammar = base Grammar ; this . sentence = sentence ; this . tokens = sentence . get Word I Ds ( ) ; int orig Count = get Num Rules ( base Grammar . get Trie Root ( ) ) ; long start Time = System . current Time Millis ( ) ; this . filtered Trie = filter ( base Grammar . get Trie Root ( ) ) ; int filtered Count = get Num Rules ( ) ; float seconds = ( System . current Time Millis ( ) - start Time ) / NUM ; LOG . debug ( STRING , sentence . id ( ) , orig Count , filtered Count , seconds ) ; }
@ Override public Task List create File Systems ( File System Param param , Project project , Virtual Array varray , Virtual Pool vpool , Tenant Org tenant Org , Data Object . Flag [ ] flags , List < Recommendation > recommendations , Task List task List , String task Id , Virtual Pool Capability Values Wrapper vpool Capabilities ) throws Internal Exception { List < File Share > file List = null ; List < File Share > file Shares = new Array List < File Share > ( ) ; file List = prepare File Systems ( param , task Id , task List , project , tenant Org , flags , varray , vpool , recommendations , vpool Capabilities , BOOL ) ; file Shares . add All ( file List ) ; String suggested Native Fs Id = param . get Fs Id ( ) == null ? STRING : param . get Fs Id ( ) ; final List < File Descriptor > file Descriptors = prepare File Descriptors ( file Shares , vpool Capabilities , suggested Native Fs Id ) ; final File Orchestration Controller controller = get Controller ( File Orchestration Controller . class , File Orchestration Controller . FILE ORCHESTRATION DEVICE ) ; try { controller . create File Systems ( file Descriptors , task Id ) ; } catch ( Internal Exception e ) { log . error ( STRING , e ) ; fail File Share Create Request ( task Id , task List , file Shares , e . get Message ( ) ) ; throw e ; } catch ( Exception e ) { log . error ( STRING , e ) ; fail File Share Create Request ( task Id , task List , file Shares , e . get Message ( ) ) ; throw e ; } return task List ; }
@ Override public Task List create File Systems ( File System Param param , Project project , Virtual Array varray , Virtual Pool vpool , Tenant Org tenant Org , Data Object . Flag [ ] flags , List < Recommendation > recommendations , Task List task List , String task Id , Virtual Pool Capability Values Wrapper vpool Capabilities ) throws Internal Exception { List < File Share > file List = null ; List < File Share > file Shares = new Array List < File Share > ( ) ; file List = prepare File Systems ( param , task Id , task List , project , tenant Org , flags , varray , vpool , recommendations , vpool Capabilities , BOOL ) ; file Shares . add All ( file List ) ; String suggested Native Fs Id = param . get Fs Id ( ) == null ? STRING : param . get Fs Id ( ) ; final List < File Descriptor > file Descriptors = prepare File Descriptors ( file Shares , vpool Capabilities , suggested Native Fs Id ) ; final File Orchestration Controller controller = get Controller ( File Orchestration Controller . class , File Orchestration Controller . FILE ORCHESTRATION DEVICE ) ; try { controller . create File Systems ( file Descriptors , task Id ) ; } catch ( Internal Exception e ) { log . error ( STRING , e ) ; fail File Share Create Request ( task Id , task List , file Shares , e . get Message ( ) ) ; throw e ; } catch ( Exception e ) { log . error ( STRING , e ) ; fail File Share Create Request ( task Id , task List , file Shares , e . get Message ( ) ) ; throw e ; } return task List ; }
private void start Authentication Activity ( ) { Intent intent = new Intent ( Server Details . this , Authentication Activity . class ) ; intent . set Flags ( Intent . FLAG ACTIVITY CLEAR TOP ) ; start Activity ( intent ) ; }
public static long string 2 long ( String s ) { s = s . trim ( ) ; final int lastpos = s . length ( ) - NUM ; final char lastchar = s . char At ( lastpos ) ; if ( Character . is Digit ( lastchar ) ) return Long . parse Long ( s ) ; else { long prefix = Traditional Binary Prefix . value Of ( lastchar ) . value ; long num = Long . parse Long ( s . substring ( NUM , lastpos ) ) ; if ( num > ( Long . MAX VALUE / prefix ) || num < ( Long . MIN VALUE / prefix ) ) { throw new Illegal Argument Exception ( s + STRING ) ; } return num * prefix ; } }
public static long string 2 long ( String s ) { s = s . trim ( ) ; final int lastpos = s . length ( ) - NUM ; final char lastchar = s . char At ( lastpos ) ; if ( Character . is Digit ( lastchar ) ) return Long . parse Long ( s ) ; else { long prefix = Traditional Binary Prefix . value Of ( lastchar ) . value ; long num = Long . parse Long ( s . substring ( NUM , lastpos ) ) ; if ( num > ( Long . MAX VALUE / prefix ) || num < ( Long . MIN VALUE / prefix ) ) { throw new Illegal Argument Exception ( s + STRING ) ; } return num * prefix ; } }
public static long string 2 long ( String s ) { s = s . trim ( ) ; final int lastpos = s . length ( ) - NUM ; final char lastchar = s . char At ( lastpos ) ; if ( Character . is Digit ( lastchar ) ) return Long . parse Long ( s ) ; else { long prefix = Traditional Binary Prefix . value Of ( lastchar ) . value ; long num = Long . parse Long ( s . substring ( NUM , lastpos ) ) ; if ( num > ( Long . MAX VALUE / prefix ) || num < ( Long . MIN VALUE / prefix ) ) { throw new Illegal Argument Exception ( s + STRING ) ; } return num * prefix ; } }
protected void internal Frame ( Dock Wrapper wrapper ) { free Wrapper ( wrapper ) ; internal Frame Wrappers . add ( wrapper ) ; wrapper . make Internal Frame ( ) ; }
public static Public Key generate Public Key ( String encoded Public Key ) { try { byte [ ] decoded Key = Base 64 . decode ( encoded Public Key , Base 64 . DEFAULT ) ; Key Factory key Factory = Key Factory . get Instance ( KEY FACTORY ALGORITHM ) ; return key Factory . generate Public ( new X509 Encoded Key Spec ( decoded Key ) ) ; } catch ( No Such Algorithm Exception e ) { throw new Runtime Exception ( e ) ; } catch ( Invalid Key Spec Exception e ) { Log . e ( TAG , STRING ) ; throw new Illegal Argument Exception ( e ) ; } catch ( Illegal Argument Exception e ) { Log . e ( TAG , STRING ) ; throw e ; } }
public static Public Key generate Public Key ( String encoded Public Key ) { try { byte [ ] decoded Key = Base 64 . decode ( encoded Public Key , Base 64 . DEFAULT ) ; Key Factory key Factory = Key Factory . get Instance ( KEY FACTORY ALGORITHM ) ; return key Factory . generate Public ( new X509 Encoded Key Spec ( decoded Key ) ) ; } catch ( No Such Algorithm Exception e ) { throw new Runtime Exception ( e ) ; } catch ( Invalid Key Spec Exception e ) { Log . e ( TAG , STRING ) ; throw new Illegal Argument Exception ( e ) ; } catch ( Illegal Argument Exception e ) { Log . e ( TAG , STRING ) ; throw e ; } }
public static Public Key generate Public Key ( String encoded Public Key ) { try { byte [ ] decoded Key = Base 64 . decode ( encoded Public Key , Base 64 . DEFAULT ) ; Key Factory key Factory = Key Factory . get Instance ( KEY FACTORY ALGORITHM ) ; return key Factory . generate Public ( new X509 Encoded Key Spec ( decoded Key ) ) ; } catch ( No Such Algorithm Exception e ) { throw new Runtime Exception ( e ) ; } catch ( Invalid Key Spec Exception e ) { Log . e ( TAG , STRING ) ; throw new Illegal Argument Exception ( e ) ; } catch ( Illegal Argument Exception e ) { Log . e ( TAG , STRING ) ; throw e ; } }
private void emit Implicit Conversion ( Basic Type ptype , Class < ? > pclass , Object arg ) { assert ( basic Type ( pclass ) == ptype ) ; if ( pclass == ptype . basic Type Class ( ) && ptype != L TYPE ) return ; switch ( ptype ) { case L TYPE : if ( Verify Type . is Null Conversion ( Object . class , pclass , BOOL ) ) { if ( PROFILE LEVEL > NUM ) emit Reference Cast ( Object . class , arg ) ; return ; } emit Reference Cast ( pclass , arg ) ; return ; case I TYPE : if ( ! Verify Type . is Null Conversion ( int . class , pclass , BOOL ) ) emit Prim Cast ( ptype . basic Type Wrapper ( ) , Wrapper . for Primitive Type ( pclass ) ) ; return ; } throw new Internal Error ( STRING + ptype + STRING + pclass ) ; }
public void add Argument ( final Argument argument ) { if ( ! args . contains ( argument ) ) { args . add ( argument ) ; } }
public Map < String , String > load Installed Codenvy Properties ( Install Type install Type ) throws IO Exception { Map < String , String > properties = new Hash Map < > ( ) ; Iterator < Path > properties Files = get Codenvy Properties Files ( install Type ) ; while ( properties Files . has Next ( ) ) { Path file = properties Files . next ( ) ; try { properties . put All ( do Load Installed Codenvy Properties ( file ) ) ; } catch ( IO Exception e ) { throw new Config Exception ( format ( STRING , e . get Message ( ) ) , e ) ; } } return properties ; }
public Map < String , String > load Installed Codenvy Properties ( Install Type install Type ) throws IO Exception { Map < String , String > properties = new Hash Map < > ( ) ; Iterator < Path > properties Files = get Codenvy Properties Files ( install Type ) ; while ( properties Files . has Next ( ) ) { Path file = properties Files . next ( ) ; try { properties . put All ( do Load Installed Codenvy Properties ( file ) ) ; } catch ( IO Exception e ) { throw new Config Exception ( format ( STRING , e . get Message ( ) ) , e ) ; } } return properties ; }
public Map < String , String > load Installed Codenvy Properties ( Install Type install Type ) throws IO Exception { Map < String , String > properties = new Hash Map < > ( ) ; Iterator < Path > properties Files = get Codenvy Properties Files ( install Type ) ; while ( properties Files . has Next ( ) ) { Path file = properties Files . next ( ) ; try { properties . put All ( do Load Installed Codenvy Properties ( file ) ) ; } catch ( IO Exception e ) { throw new Config Exception ( format ( STRING , e . get Message ( ) ) , e ) ; } } return properties ; }
public Map < String , String > load Installed Codenvy Properties ( Install Type install Type ) throws IO Exception { Map < String , String > properties = new Hash Map < > ( ) ; Iterator < Path > properties Files = get Codenvy Properties Files ( install Type ) ; while ( properties Files . has Next ( ) ) { Path file = properties Files . next ( ) ; try { properties . put All ( do Load Installed Codenvy Properties ( file ) ) ; } catch ( IO Exception e ) { throw new Config Exception ( format ( STRING , e . get Message ( ) ) , e ) ; } } return properties ; }
public void disconnect From Bean Context ( ) throws Property Veto Exception { Bean Context bc = get Bean Context ( ) ; if ( bc != null ) { bc . remove Bean Context Membership Listener ( this ) ; bean Context Child Support . set Bean Context ( null ) ; } }
public void disconnect From Bean Context ( ) throws Property Veto Exception { Bean Context bc = get Bean Context ( ) ; if ( bc != null ) { bc . remove Bean Context Membership Listener ( this ) ; bean Context Child Support . set Bean Context ( null ) ; } }
public static Text Node value Of ( String v ) { if ( v == null ) { return null ; } if ( v . length ( ) == NUM ) { return EMPTY STRING NODE ; } return new Text Node ( v ) ; }
public static Text Node value Of ( String v ) { if ( v == null ) { return null ; } if ( v . length ( ) == NUM ) { return EMPTY STRING NODE ; } return new Text Node ( v ) ; }
public Iterator iterator ( ) { sort Edges ( ) ; return out Edges . iterator ( ) ; }
public Iterator iterator ( ) { sort Edges ( ) ; return out Edges . iterator ( ) ; }
public Iterator iterator ( ) { sort Edges ( ) ; return out Edges . iterator ( ) ; }
public String mutate Lang Model ( final String input ) { if ( input . length ( ) == NUM ) { return input ; } int start Point = ( int ) ( Randomness . next Double ( ) * ( input . length ( ) ) ) ; int remaining Length = ( int ) Math . round ( Randomness . next Double ( ) * ( input . length ( ) - start Point ) ) ; if ( remaining Length == NUM ) { return input ; } String output = input . substring ( NUM , start Point ) ; String replacement Chunk = generate Random String From Model With Exact Length ( remaining Length , STRING + input . char At ( start Point ) ) ; output += replacement Chunk ; output += input . substring ( start Point + remaining Length , input . length ( ) ) ; return output ; }
public String mutate Lang Model ( final String input ) { if ( input . length ( ) == NUM ) { return input ; } int start Point = ( int ) ( Randomness . next Double ( ) * ( input . length ( ) ) ) ; int remaining Length = ( int ) Math . round ( Randomness . next Double ( ) * ( input . length ( ) - start Point ) ) ; if ( remaining Length == NUM ) { return input ; } String output = input . substring ( NUM , start Point ) ; String replacement Chunk = generate Random String From Model With Exact Length ( remaining Length , STRING + input . char At ( start Point ) ) ; output += replacement Chunk ; output += input . substring ( start Point + remaining Length , input . length ( ) ) ; return output ; }
public String mutate Lang Model ( final String input ) { if ( input . length ( ) == NUM ) { return input ; } int start Point = ( int ) ( Randomness . next Double ( ) * ( input . length ( ) ) ) ; int remaining Length = ( int ) Math . round ( Randomness . next Double ( ) * ( input . length ( ) - start Point ) ) ; if ( remaining Length == NUM ) { return input ; } String output = input . substring ( NUM , start Point ) ; String replacement Chunk = generate Random String From Model With Exact Length ( remaining Length , STRING + input . char At ( start Point ) ) ; output += replacement Chunk ; output += input . substring ( start Point + remaining Length , input . length ( ) ) ; return output ; }
public String mutate Lang Model ( final String input ) { if ( input . length ( ) == NUM ) { return input ; } int start Point = ( int ) ( Randomness . next Double ( ) * ( input . length ( ) ) ) ; int remaining Length = ( int ) Math . round ( Randomness . next Double ( ) * ( input . length ( ) - start Point ) ) ; if ( remaining Length == NUM ) { return input ; } String output = input . substring ( NUM , start Point ) ; String replacement Chunk = generate Random String From Model With Exact Length ( remaining Length , STRING + input . char At ( start Point ) ) ; output += replacement Chunk ; output += input . substring ( start Point + remaining Length , input . length ( ) ) ; return output ; }
public String mutate Lang Model ( final String input ) { if ( input . length ( ) == NUM ) { return input ; } int start Point = ( int ) ( Randomness . next Double ( ) * ( input . length ( ) ) ) ; int remaining Length = ( int ) Math . round ( Randomness . next Double ( ) * ( input . length ( ) - start Point ) ) ; if ( remaining Length == NUM ) { return input ; } String output = input . substring ( NUM , start Point ) ; String replacement Chunk = generate Random String From Model With Exact Length ( remaining Length , STRING + input . char At ( start Point ) ) ; output += replacement Chunk ; output += input . substring ( start Point + remaining Length , input . length ( ) ) ; return output ; }
public String mutate Lang Model ( final String input ) { if ( input . length ( ) == NUM ) { return input ; } int start Point = ( int ) ( Randomness . next Double ( ) * ( input . length ( ) ) ) ; int remaining Length = ( int ) Math . round ( Randomness . next Double ( ) * ( input . length ( ) - start Point ) ) ; if ( remaining Length == NUM ) { return input ; } String output = input . substring ( NUM , start Point ) ; String replacement Chunk = generate Random String From Model With Exact Length ( remaining Length , STRING + input . char At ( start Point ) ) ; output += replacement Chunk ; output += input . substring ( start Point + remaining Length , input . length ( ) ) ; return output ; }
protected Object fetch ( Object key ) { synchronized ( lock ) { Thread current Thread = Thread . current Thread ( ) ; if ( busy Thread == current Thread ) { throw new Illegal State Exception ( STRING ) ; } while ( busy Thread != null ) { try { lock . wait ( ) ; } catch ( Interrupted Exception e ) { } } busy Thread = current Thread ; } try { return fetch Serial ( key ) ; } finally { synchronized ( lock ) { busy Thread = null ; lock . notify ( ) ; } } }
protected Object fetch ( Object key ) { synchronized ( lock ) { Thread current Thread = Thread . current Thread ( ) ; if ( busy Thread == current Thread ) { throw new Illegal State Exception ( STRING ) ; } while ( busy Thread != null ) { try { lock . wait ( ) ; } catch ( Interrupted Exception e ) { } } busy Thread = current Thread ; } try { return fetch Serial ( key ) ; } finally { synchronized ( lock ) { busy Thread = null ; lock . notify ( ) ; } } }
protected Object fetch ( Object key ) { synchronized ( lock ) { Thread current Thread = Thread . current Thread ( ) ; if ( busy Thread == current Thread ) { throw new Illegal State Exception ( STRING ) ; } while ( busy Thread != null ) { try { lock . wait ( ) ; } catch ( Interrupted Exception e ) { } } busy Thread = current Thread ; } try { return fetch Serial ( key ) ; } finally { synchronized ( lock ) { busy Thread = null ; lock . notify ( ) ; } } }
private Instance State check In ( ) { final Instance State state ; try { logger . debug ( STRING , instance Id ) ; state = get Instance State ( instance Id ) ; } catch ( Resource Exception e ) { logger . info ( STRING , instance Id ) ; return null ; } try { if ( first Checkin ) { state . update Startup ( ) ; state . clear Shutdown ( ) ; first Checkin = BOOL ; } switch ( state . get State ( ) ) { case Instance State . STATE RUNNING : state . update Timestamp ( ) ; break ; case Instance State . STATE DOWN : state . set State ( Instance State . STATE RUNNING ) ; logger . debug ( STRING , instance Id , Instance State . STATE DOWN , Instance State . STATE RUNNING ) ; state . update Timestamp ( ) ; break ; case Instance State . STATE PROCESSING DOWN : logger . debug ( STRING , instance Id , state . get State ( ) ) ; return state ; } update Instance State ( instance Id , state ) ; logger . debug ( STRING , instance Id ) ; } catch ( Resource Exception e ) { if ( e . get Code ( ) != Resource Exception . CONFLICT ) { logger . warn ( STRING , e ) ; } else { logger . info ( STRING , state . get State ( ) ) ; return null ; } } return state ; }
public String read ( final int length ) { if ( length > this . length || pos + length > this . length ) { throw new String Index Out Of Bounds Exception ( ) ; } final String substring = source . substring ( pos , pos + length ) ; pos += length ; return substring ; }
public String read ( final int length ) { if ( length > this . length || pos + length > this . length ) { throw new String Index Out Of Bounds Exception ( ) ; } final String substring = source . substring ( pos , pos + length ) ; pos += length ; return substring ; }
public String read ( final int length ) { if ( length > this . length || pos + length > this . length ) { throw new String Index Out Of Bounds Exception ( ) ; } final String substring = source . substring ( pos , pos + length ) ; pos += length ; return substring ; }
public String read ( final int length ) { if ( length > this . length || pos + length > this . length ) { throw new String Index Out Of Bounds Exception ( ) ; } final String substring = source . substring ( pos , pos + length ) ; pos += length ; return substring ; }
public String read ( final int length ) { if ( length > this . length || pos + length > this . length ) { throw new String Index Out Of Bounds Exception ( ) ; } final String substring = source . substring ( pos , pos + length ) ; pos += length ; return substring ; }
public String read ( final int length ) { if ( length > this . length || pos + length > this . length ) { throw new String Index Out Of Bounds Exception ( ) ; } final String substring = source . substring ( pos , pos + length ) ; pos += length ; return substring ; }
public String read ( final int length ) { if ( length > this . length || pos + length > this . length ) { throw new String Index Out Of Bounds Exception ( ) ; } final String substring = source . substring ( pos , pos + length ) ; pos += length ; return substring ; }
@ Override public int show Dialog ( Component parent , String approve Button Text ) { if ( m Dialog Type == UNHANDLED DIALOG ) throw new Illegal State Exception ( STRING ) ; else return super . show Dialog ( parent , approve Button Text ) ; }
public void write Logln ( String logdata ) { write Log ( logdata + System . get Property ( STRING ) ) ; }
private static String strip Apple Span From Markup ( String markup ) { String Builder stripped = new String Builder ( markup ) ; int prefix Beg Idx = stripped . index Of ( APPLE SPAN PREFIX ) ; while ( prefix Beg Idx >= NUM ) { int prefix End Idx = stripped . index Of ( STRING , prefix Beg Idx ) + NUM ; stripped . replace ( prefix Beg Idx , prefix End Idx , STRING ) ; int suffix Beg Idx = stripped . last Index Of ( APPLE SPAN SUFFIX ) ; int suffix End Idx = suffix Beg Idx + APPLE SPAN SUFFIX . length ( ) ; stripped . replace ( suffix Beg Idx , suffix End Idx , STRING ) ; prefix Beg Idx = stripped . index Of ( APPLE SPAN PREFIX ) ; } return stripped . to String ( ) ; }
@ Override public long skip ( long bytes ) throws IO Exception { if ( closed ) { throw new File Upload Exception ( Item Skipped Exception ) ; } int av = available ( ) ; if ( av == NUM ) { av = make Available ( ) ; if ( av == NUM ) { return NUM ; } } long res = Math . min ( av , bytes ) ; head += res ; return res ; }
protected < T > Response Entity < T > send ( final Client Http Request request , final Class < T > response Type ) { return send ( request , response Type , Collections . < String , Object > empty Map ( ) ) ; }
protected < T > Response Entity < T > send ( final Client Http Request request , final Class < T > response Type ) { return send ( request , response Type , Collections . < String , Object > empty Map ( ) ) ; }
@ Override public void end RDF ( ) throws RDF Handler Exception { logger . info ( STRING ) ; try { statement Cache . put ( DONE ) ; } catch ( Interrupted Exception e ) { throw new RDF Handler Exception ( STRING , e ) ; } }
@ Override public void end RDF ( ) throws RDF Handler Exception { logger . info ( STRING ) ; try { statement Cache . put ( DONE ) ; } catch ( Interrupted Exception e ) { throw new RDF Handler Exception ( STRING , e ) ; } }
@ Override public void end RDF ( ) throws RDF Handler Exception { logger . info ( STRING ) ; try { statement Cache . put ( DONE ) ; } catch ( Interrupted Exception e ) { throw new RDF Handler Exception ( STRING , e ) ; } }
public Date build ( ) { Calendar cal ; if ( tz != null && lc != null ) cal = Calendar . get Instance ( tz , lc ) ; else if ( tz != null ) cal = Calendar . get Instance ( tz ) ; else if ( lc != null ) cal = Calendar . get Instance ( lc ) ; else cal = Calendar . get Instance ( ) ; cal . set ( Calendar . YEAR , year ) ; cal . set ( Calendar . MONTH , month - NUM ) ; cal . set ( Calendar . DAY OF MONTH , day ) ; cal . set ( Calendar . HOUR OF DAY , hour ) ; cal . set ( Calendar . MINUTE , minute ) ; cal . set ( Calendar . SECOND , second ) ; cal . set ( Calendar . MILLISECOND , NUM ) ; return cal . get Time ( ) ; }
private String build Provisioning Address ( ) { String mnc = String . format ( Locale . US , STRING , m Rcs Settings . get Mobile Network Code ( ) ) ; String mcc = String . format ( Locale . US , STRING , m Rcs Settings . get Mobile Country Code ( ) ) ; return STRING + mnc + STRING + mcc + STRING ; }
public static void print ( byte b , Print Stream out ) { out . print ( hex ( b ) ) ; }
protected all Threads Data read Values ( all Threads Data values ) { synchronized ( workers ) { int count = workers . size ( ) ; if ( values == null ) { values = new all Threads Data ( ) ; values . set Size ( count ) ; } else if ( values . get Size ( ) != count ) { values . set Size ( count ) ; } int i = NUM ; final Iterator < Worker Thread > iter = workers . iterator ( ) ; while ( iter . has Next ( ) && i < values . get Size ( ) ) { Worker Thread worker = ( Worker Thread ) iter . next ( ) ; int index = i ++ ; values . set Iteration Value ( index , worker . get Iterations ( ) ) ; values . set Total Response Times Value ( index , worker . reset Total Time ( ) ) ; } } return values ; }
void put ( int field Number , Field Data data ) { int i = binary Search ( field Number ) ; if ( i >= NUM ) { m Data [ i ] = data ; } else { i = ~ i ; if ( i < m Size && m Data [ i ] == DELETED ) { m Field Numbers [ i ] = field Number ; m Data [ i ] = data ; return ; } if ( m Garbage && m Size >= m Field Numbers . length ) { gc ( ) ; i = ~ binary Search ( field Number ) ; } if ( m Size >= m Field Numbers . length ) { int n = ideal Int Array Size ( m Size + NUM ) ; int [ ] nkeys = new int [ n ] ; Field Data [ ] nvalues = new Field Data [ n ] ; System . arraycopy ( m Field Numbers , NUM , nkeys , NUM , m Field Numbers . length ) ; System . arraycopy ( m Data , NUM , nvalues , NUM , m Data . length ) ; m Field Numbers = nkeys ; m Data = nvalues ; } if ( m Size - i != NUM ) { System . arraycopy ( m Field Numbers , i , m Field Numbers , i + NUM , m Size - i ) ; System . arraycopy ( m Data , i , m Data , i + NUM , m Size - i ) ; } m Field Numbers [ i ] = field Number ; m Data [ i ] = data ; m Size ++ ; } }
void put ( int field Number , Field Data data ) { int i = binary Search ( field Number ) ; if ( i >= NUM ) { m Data [ i ] = data ; } else { i = ~ i ; if ( i < m Size && m Data [ i ] == DELETED ) { m Field Numbers [ i ] = field Number ; m Data [ i ] = data ; return ; } if ( m Garbage && m Size >= m Field Numbers . length ) { gc ( ) ; i = ~ binary Search ( field Number ) ; } if ( m Size >= m Field Numbers . length ) { int n = ideal Int Array Size ( m Size + NUM ) ; int [ ] nkeys = new int [ n ] ; Field Data [ ] nvalues = new Field Data [ n ] ; System . arraycopy ( m Field Numbers , NUM , nkeys , NUM , m Field Numbers . length ) ; System . arraycopy ( m Data , NUM , nvalues , NUM , m Data . length ) ; m Field Numbers = nkeys ; m Data = nvalues ; } if ( m Size - i != NUM ) { System . arraycopy ( m Field Numbers , i , m Field Numbers , i + NUM , m Size - i ) ; System . arraycopy ( m Data , i , m Data , i + NUM , m Size - i ) ; } m Field Numbers [ i ] = field Number ; m Data [ i ] = data ; m Size ++ ; } }
public void ensure Row Visible ( int row ) { if ( row != - NUM ) { Rectangle cell Rect = get Cell Rect ( row , NUM , BOOL ) ; Rectangle visible Rect = get Visible Rect ( ) ; if ( ! visible Rect . intersects ( cell Rect ) ) scroll Rect To Visible ( cell Rect ) ; } }
private boolean check Requested Key Age ( String key Entry ) throws Number Format Exception { long requested Token Key TS = Long . parse Long ( key Entry ) ; long now = System . current Time Millis ( ) ; long diff = now - requested Token Key TS ; if ( diff > ( NUM * key Rotation Interval In Msecs ) ) { log . debug ( STRING , key Entry ) ; return BOOL ; } long youngest Key = Long . parse Long ( cached Token Keys Bundle . get Current Key Entry ( ) ) ; if ( youngest Key < Long . parse Long ( key Entry ) ) { log . debug ( STRING , key Entry ) ; return BOOL ; } return BOOL ; }
private boolean check Requested Key Age ( String key Entry ) throws Number Format Exception { long requested Token Key TS = Long . parse Long ( key Entry ) ; long now = System . current Time Millis ( ) ; long diff = now - requested Token Key TS ; if ( diff > ( NUM * key Rotation Interval In Msecs ) ) { log . debug ( STRING , key Entry ) ; return BOOL ; } long youngest Key = Long . parse Long ( cached Token Keys Bundle . get Current Key Entry ( ) ) ; if ( youngest Key < Long . parse Long ( key Entry ) ) { log . debug ( STRING , key Entry ) ; return BOOL ; } return BOOL ; }
private boolean check Requested Key Age ( String key Entry ) throws Number Format Exception { long requested Token Key TS = Long . parse Long ( key Entry ) ; long now = System . current Time Millis ( ) ; long diff = now - requested Token Key TS ; if ( diff > ( NUM * key Rotation Interval In Msecs ) ) { log . debug ( STRING , key Entry ) ; return BOOL ; } long youngest Key = Long . parse Long ( cached Token Keys Bundle . get Current Key Entry ( ) ) ; if ( youngest Key < Long . parse Long ( key Entry ) ) { log . debug ( STRING , key Entry ) ; return BOOL ; } return BOOL ; }
private boolean check Requested Key Age ( String key Entry ) throws Number Format Exception { long requested Token Key TS = Long . parse Long ( key Entry ) ; long now = System . current Time Millis ( ) ; long diff = now - requested Token Key TS ; if ( diff > ( NUM * key Rotation Interval In Msecs ) ) { log . debug ( STRING , key Entry ) ; return BOOL ; } long youngest Key = Long . parse Long ( cached Token Keys Bundle . get Current Key Entry ( ) ) ; if ( youngest Key < Long . parse Long ( key Entry ) ) { log . debug ( STRING , key Entry ) ; return BOOL ; } return BOOL ; }
private void populate Result List View ( List < Bookmark Match > ids ) { if ( ids . is Empty ( ) ) { set UI State ( UI State . EMPTY ) ; } else { set UI State ( UI State . RESULT ) ; m Result List . set Adapter ( new Result List Adapter ( ids , m Delegate ) ) ; } }
private void populate Result List View ( List < Bookmark Match > ids ) { if ( ids . is Empty ( ) ) { set UI State ( UI State . EMPTY ) ; } else { set UI State ( UI State . RESULT ) ; m Result List . set Adapter ( new Result List Adapter ( ids , m Delegate ) ) ; } }
@ Override public final void add Bezier Curve Y ( final float x , final float y , final float x3 , final float y3 ) { elements . add ( new Quad Curve To ( x , y , x3 , y3 ) ) ; current Pos [ NUM ] = x3 ; current Pos [ NUM ] = y3 ; }
public String html tooltip ( String short txt , String popup txt ) { String out = STRING ; if ( jquery ) { out = String . format ( STRING , popup txt , short txt ) ; } else if ( jquery Mobile ) { String popup = String . format ( STRING + STRING + STRING , popup Id , popup txt ) ; String txt = String . format ( STRING , popup Id ++ , short txt ) ; out = popup + txt ; } return out ; }
public void add FXGL Listener ( FXGL Listener listener ) { system Listeners . add ( listener ) ; }
public Tasker add Task ( Task task ) { tasks . add ( task ) ; last Added Task = task ; return this ; }
public void compute Ring ( ) { if ( ring != null ) return ; Coordinate [ ] coord = new Coordinate [ pts . size ( ) ] ; for ( int i = NUM ; i < pts . size ( ) ; i ++ ) { coord [ i ] = ( Coordinate ) pts . get ( i ) ; } ring = geometry Factory . create Linear Ring ( coord ) ; is Hole = CG Algorithms . is CCW ( ring . get Coordinates ( ) ) ; }
public boolean validate Mutation Fee ( String assessment No , Big Decimal payment Amount ) { boolean valid Fee = BOOL ; Property Mutation property Mutation = get Latest Property Mutation By Assesment No ( assessment No ) ; if ( property Mutation != null ) { if ( payment Amount . compare To ( property Mutation . get Mutation Fee ( ) ) > NUM ) { valid Fee = BOOL ; } } else { valid Fee = BOOL ; } return valid Fee ; }
public void update Configuration ( @ Not Null Configuration configuration ) { my Configuration = configuration ; invalidate Graphics Renderer ( ) ; }
public void update Configuration ( @ Not Null Configuration configuration ) { my Configuration = configuration ; invalidate Graphics Renderer ( ) ; }
public void update Configuration ( @ Not Null Configuration configuration ) { my Configuration = configuration ; invalidate Graphics Renderer ( ) ; }
private static void expand 2 Digit Number ( String number String , Word Relation word Relation , Item token Item ) { if ( number String . char At ( NUM ) == STRING ) { if ( number String . char At ( NUM ) == STRING ) { } else { String number = digit 2 num [ number String . char At ( NUM ) - STRING ] ; word Relation . add Word ( token Item , number ) ; } } else if ( number String . char At ( NUM ) == STRING ) { String number = digit 2 enty [ number String . char At ( NUM ) - STRING ] ; word Relation . add Word ( token Item , number ) ; } else if ( number String . char At ( NUM ) == STRING ) { String number = digit 2 teen [ number String . char At ( NUM ) - STRING ] ; word Relation . add Word ( token Item , number ) ; } else { String enty = digit 2 enty [ number String . char At ( NUM ) - STRING ] ; word Relation . add Word ( token Item , enty ) ; expand Digits ( number String . substring ( NUM , number String . length ( ) ) , word Relation , token Item ) ; } }
private void compress ( Basic Block block ) { if ( get Ancestor ( get Ancestor ( block ) ) != null ) { compress ( get Ancestor ( block ) ) ; LT Dominator Info block Info = LT Dominator Info . get Info ( block , ir ) ; if ( get Semi ( get Label ( get Ancestor ( block ) ) ) < get Semi ( get Label ( block ) ) ) { block Info . set Label ( get Label ( get Ancestor ( block ) ) ) ; } block Info . set Ancestor ( get Ancestor ( get Ancestor ( block ) ) ) ; } }
private void compress ( Basic Block block ) { if ( get Ancestor ( get Ancestor ( block ) ) != null ) { compress ( get Ancestor ( block ) ) ; LT Dominator Info block Info = LT Dominator Info . get Info ( block , ir ) ; if ( get Semi ( get Label ( get Ancestor ( block ) ) ) < get Semi ( get Label ( block ) ) ) { block Info . set Label ( get Label ( get Ancestor ( block ) ) ) ; } block Info . set Ancestor ( get Ancestor ( get Ancestor ( block ) ) ) ; } }
public Jaas Configuration ( String principal , File keytab , String app Name ) { this ( principal , keytab , null , null ) ; client App Name = app Name ; server App Name = null ; }
public Jaas Configuration ( String principal , File keytab , String app Name ) { this ( principal , keytab , null , null ) ; client App Name = app Name ; server App Name = null ; }
static String plurals ( final String s , final Atomic Integer i ) { return i == null ? UNKNOWN + STRING + s + STRING : i . int Value ( ) != NUM ? i + STRING + s + STRING : STRING + s ; }
static String plurals ( final String s , final Atomic Integer i ) { return i == null ? UNKNOWN + STRING + s + STRING : i . int Value ( ) != NUM ? i + STRING + s + STRING : STRING + s ; }
static String plurals ( final String s , final Atomic Integer i ) { return i == null ? UNKNOWN + STRING + s + STRING : i . int Value ( ) != NUM ? i + STRING + s + STRING : STRING + s ; }
static String plurals ( final String s , final Atomic Integer i ) { return i == null ? UNKNOWN + STRING + s + STRING : i . int Value ( ) != NUM ? i + STRING + s + STRING : STRING + s ; }
public Signal Barrier ( ) { owner = null ; }
private void to Wagon Format ( Int And Float Array Leaf Node node , Data Output Stream out , String extension , Print Writer pw ) throws IO Exception { String Builder sb = new String Builder ( ) ; int data [ ] = node . get Int Data ( ) ; float floats [ ] = node . get Float Data ( ) ; sb . append ( STRING ) ; for ( int i = NUM ; i < data . length ; i ++ ) { sb . append ( STRING + data [ i ] + STRING + floats [ i ] + STRING ) ; if ( i + NUM != data . length ) { sb . append ( STRING ) ; } } sb . append ( STRING + extension ) ; if ( out != null ) { write String To Output ( sb . to String ( ) , out ) ; } else { } if ( pw != null ) { pw . println ( sb . to String ( ) ) ; } }
private void to Wagon Format ( Int And Float Array Leaf Node node , Data Output Stream out , String extension , Print Writer pw ) throws IO Exception { String Builder sb = new String Builder ( ) ; int data [ ] = node . get Int Data ( ) ; float floats [ ] = node . get Float Data ( ) ; sb . append ( STRING ) ; for ( int i = NUM ; i < data . length ; i ++ ) { sb . append ( STRING + data [ i ] + STRING + floats [ i ] + STRING ) ; if ( i + NUM != data . length ) { sb . append ( STRING ) ; } } sb . append ( STRING + extension ) ; if ( out != null ) { write String To Output ( sb . to String ( ) , out ) ; } else { } if ( pw != null ) { pw . println ( sb . to String ( ) ) ; } }
public static boolean delete Files ( final File target Dir ) { if ( target Dir == null || ! target Dir . is Directory ( ) ) { Log . e ( File Utils . class , STRING ) ; return BOOL ; } boolean is Deleted = BOOL ; final File [ ] files List = target Dir . list Files ( ) ; for ( File file 2 Delete : files List ) if ( file 2 Delete . is File ( ) ) is Deleted &= file 2 Delete . delete ( ) ; return is Deleted ; }
public static boolean delete Files ( final File target Dir ) { if ( target Dir == null || ! target Dir . is Directory ( ) ) { Log . e ( File Utils . class , STRING ) ; return BOOL ; } boolean is Deleted = BOOL ; final File [ ] files List = target Dir . list Files ( ) ; for ( File file 2 Delete : files List ) if ( file 2 Delete . is File ( ) ) is Deleted &= file 2 Delete . delete ( ) ; return is Deleted ; }
void advance Commit Index ( ) throws Interrupted Exception { Map < Integer , Peer > peers = this . peers ; Arrays . fill ( match Indices , NUM ) ; final int [ ] ix = { NUM } ; peers . for Each ( null ) ; for ( int i = NUM ; i < match Indices . length ; i ++ ) { for ( int j = NUM ; j < match Indices . length - i ; j ++ ) { if ( match Indices [ j - NUM ] < match Indices [ j ] ) { int temp = match Indices [ j - NUM ] ; match Indices [ j - NUM ] = match Indices [ j ] ; match Indices [ j ] = temp ; } } } save Queue . get Latest ( saved Rid ) ; int new Commit Index = Math . min ( saved Rid . index , match Indices [ match Indices . length - majority ] ) ; if ( new Commit Index > commit Index ) { commit Index = new Commit Index ; } }
void advance Commit Index ( ) throws Interrupted Exception { Map < Integer , Peer > peers = this . peers ; Arrays . fill ( match Indices , NUM ) ; final int [ ] ix = { NUM } ; peers . for Each ( null ) ; for ( int i = NUM ; i < match Indices . length ; i ++ ) { for ( int j = NUM ; j < match Indices . length - i ; j ++ ) { if ( match Indices [ j - NUM ] < match Indices [ j ] ) { int temp = match Indices [ j - NUM ] ; match Indices [ j - NUM ] = match Indices [ j ] ; match Indices [ j ] = temp ; } } } save Queue . get Latest ( saved Rid ) ; int new Commit Index = Math . min ( saved Rid . index , match Indices [ match Indices . length - majority ] ) ; if ( new Commit Index > commit Index ) { commit Index = new Commit Index ; } }
void advance Commit Index ( ) throws Interrupted Exception { Map < Integer , Peer > peers = this . peers ; Arrays . fill ( match Indices , NUM ) ; final int [ ] ix = { NUM } ; peers . for Each ( null ) ; for ( int i = NUM ; i < match Indices . length ; i ++ ) { for ( int j = NUM ; j < match Indices . length - i ; j ++ ) { if ( match Indices [ j - NUM ] < match Indices [ j ] ) { int temp = match Indices [ j - NUM ] ; match Indices [ j - NUM ] = match Indices [ j ] ; match Indices [ j ] = temp ; } } } save Queue . get Latest ( saved Rid ) ; int new Commit Index = Math . min ( saved Rid . index , match Indices [ match Indices . length - majority ] ) ; if ( new Commit Index > commit Index ) { commit Index = new Commit Index ; } }
synchronized Set < Long > key Set ( ) { Hash Set < Long > set = new Hash Set < Long > ( ) ; for ( Entry < V > e = stack . stack Next ; e != stack ; e = e . stack Next ) { set . add ( e . key ) ; } for ( Entry < V > e = queue . queue Next ; e != queue ; e = e . queue Next ) { set . add ( e . key ) ; } return set ; }
SSL Session to Session ( byte [ ] data , String host , int port ) { Byte Array Input Stream bais = new Byte Array Input Stream ( data ) ; Data Input Stream dais = new Data Input Stream ( bais ) ; try { int type = dais . read Int ( ) ; if ( type != OPEN SSL ) { log ( new Assertion Error ( STRING + type ) ) ; return null ; } int length = dais . read Int ( ) ; byte [ ] session Data = new byte [ length ] ; dais . read Fully ( session Data ) ; int count = dais . read Int ( ) ; X509 Certificate [ ] certs = new X509 Certificate [ count ] ; for ( int i = NUM ; i < count ; i ++ ) { length = dais . read Int ( ) ; byte [ ] cert Data = new byte [ length ] ; dais . read Fully ( cert Data ) ; certs [ i ] = Open SSLX 509 Certificate . from X 509 Der ( cert Data ) ; } return new Open SSL Session Impl ( session Data , host , port , certs , this ) ; } catch ( IO Exception e ) { log ( e ) ; return null ; } }
public Basic I 18 n ( ) { this ( Locale . get Default ( ) ) ; }
V Plex Distributed Device Info find Distributed Device ( String device Name ) throws V Plex Api Exception { return find Distributed Device ( device Name , BOOL ) ; }
@ Override public boolean connection Allowed ( String event Name ) { if ( ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) ) { return BOOL ; } if ( m listenee Types . size ( ) == NUM ) { return BOOL ; } if ( m listenee Types . contains ( STRING ) && ! event Name . equals ( STRING ) ) { return BOOL ; } if ( ! m listenee Types . contains ( STRING ) && event Name . equals ( STRING ) ) { return BOOL ; } return BOOL ; }
@ Override public boolean connection Allowed ( String event Name ) { if ( ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) ) { return BOOL ; } if ( m listenee Types . size ( ) == NUM ) { return BOOL ; } if ( m listenee Types . contains ( STRING ) && ! event Name . equals ( STRING ) ) { return BOOL ; } if ( ! m listenee Types . contains ( STRING ) && event Name . equals ( STRING ) ) { return BOOL ; } return BOOL ; }
@ Override public boolean connection Allowed ( String event Name ) { if ( ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) ) { return BOOL ; } if ( m listenee Types . size ( ) == NUM ) { return BOOL ; } if ( m listenee Types . contains ( STRING ) && ! event Name . equals ( STRING ) ) { return BOOL ; } if ( ! m listenee Types . contains ( STRING ) && event Name . equals ( STRING ) ) { return BOOL ; } return BOOL ; }
@ Override public boolean connection Allowed ( String event Name ) { if ( ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) ) { return BOOL ; } if ( m listenee Types . size ( ) == NUM ) { return BOOL ; } if ( m listenee Types . contains ( STRING ) && ! event Name . equals ( STRING ) ) { return BOOL ; } if ( ! m listenee Types . contains ( STRING ) && event Name . equals ( STRING ) ) { return BOOL ; } return BOOL ; }
protected double apply Operator ( double first , double second ) { switch ( m operator ) { case STRING : return ( first + second ) ; case STRING : return ( first - second ) ; case STRING : return ( first * second ) ; case STRING : return ( first / second ) ; case STRING : return Math . pow ( first , second ) ; } return Double . Na N ; }
public static String [ ] [ ] read ( String logname , String logtype , String time Stamp , Log Query log Query , Object user Crdential ) throws IO Exception , No Such Field Exception , Illegal Argument Exception , Runtime Exception , Exception { String main File Name = new String ( ) ; set Logger Name ( logname , logtype ) ; main File Name = logger Name ; if ( time Stamp != null ) { if ( main File Name . length ( ) == NUM ) { return null ; } main File Name += STRING + time Stamp ; } query Result = read ( main File Name , log Query , user Crdential ) ; return query Result ; }
public static String [ ] [ ] read ( String logname , String logtype , String time Stamp , Log Query log Query , Object user Crdential ) throws IO Exception , No Such Field Exception , Illegal Argument Exception , Runtime Exception , Exception { String main File Name = new String ( ) ; set Logger Name ( logname , logtype ) ; main File Name = logger Name ; if ( time Stamp != null ) { if ( main File Name . length ( ) == NUM ) { return null ; } main File Name += STRING + time Stamp ; } query Result = read ( main File Name , log Query , user Crdential ) ; return query Result ; }
public static String [ ] [ ] read ( String logname , String logtype , String time Stamp , Log Query log Query , Object user Crdential ) throws IO Exception , No Such Field Exception , Illegal Argument Exception , Runtime Exception , Exception { String main File Name = new String ( ) ; set Logger Name ( logname , logtype ) ; main File Name = logger Name ; if ( time Stamp != null ) { if ( main File Name . length ( ) == NUM ) { return null ; } main File Name += STRING + time Stamp ; } query Result = read ( main File Name , log Query , user Crdential ) ; return query Result ; }
public static String [ ] [ ] read ( String logname , String logtype , String time Stamp , Log Query log Query , Object user Crdential ) throws IO Exception , No Such Field Exception , Illegal Argument Exception , Runtime Exception , Exception { String main File Name = new String ( ) ; set Logger Name ( logname , logtype ) ; main File Name = logger Name ; if ( time Stamp != null ) { if ( main File Name . length ( ) == NUM ) { return null ; } main File Name += STRING + time Stamp ; } query Result = read ( main File Name , log Query , user Crdential ) ; return query Result ; }
public static String [ ] [ ] read ( String logname , String logtype , String time Stamp , Log Query log Query , Object user Crdential ) throws IO Exception , No Such Field Exception , Illegal Argument Exception , Runtime Exception , Exception { String main File Name = new String ( ) ; set Logger Name ( logname , logtype ) ; main File Name = logger Name ; if ( time Stamp != null ) { if ( main File Name . length ( ) == NUM ) { return null ; } main File Name += STRING + time Stamp ; } query Result = read ( main File Name , log Query , user Crdential ) ; return query Result ; }
public static String [ ] [ ] read ( String logname , String logtype , String time Stamp , Log Query log Query , Object user Crdential ) throws IO Exception , No Such Field Exception , Illegal Argument Exception , Runtime Exception , Exception { String main File Name = new String ( ) ; set Logger Name ( logname , logtype ) ; main File Name = logger Name ; if ( time Stamp != null ) { if ( main File Name . length ( ) == NUM ) { return null ; } main File Name += STRING + time Stamp ; } query Result = read ( main File Name , log Query , user Crdential ) ; return query Result ; }
private void reset Labels ( ) { m From . set Text ( STRING ) ; update Alias ( m From Alias , null ) ; m To . set Text ( STRING ) ; update Alias ( m To Alias , null ) ; m Configured = BOOL ; }
private void reset Labels ( ) { m From . set Text ( STRING ) ; update Alias ( m From Alias , null ) ; m To . set Text ( STRING ) ; update Alias ( m To Alias , null ) ; m Configured = BOOL ; }
private void reset Labels ( ) { m From . set Text ( STRING ) ; update Alias ( m From Alias , null ) ; m To . set Text ( STRING ) ; update Alias ( m To Alias , null ) ; m Configured = BOOL ; }
private static boolean has Specialized Handler Intents ( Context context , Intent intent ) { try { Package Manager pm = context . get Package Manager ( ) ; List < Resolve Info > handlers = pm . query Intent Activities ( intent , Package Manager . GET RESOLVED FILTER ) ; if ( handlers == null || handlers . is Empty ( ) ) { return BOOL ; } for ( Resolve Info resolve Info : handlers ) { Intent Filter filter = resolve Info . filter ; if ( filter == null ) continue ; if ( filter . count Data Authorities ( ) == NUM || filter . count Data Paths ( ) == NUM ) continue ; if ( resolve Info . activity Info == null ) continue ; return BOOL ; } } catch ( Runtime Exception e ) { Log . e ( TAG , STRING ) ; } return BOOL ; }
public static String build String ( Consumer < String Printer > printer ) { String Builder builder = new String Builder ( ) ; printer . accept ( new String Printer ( null ) ) ; return builder . to String ( ) ; }
public final void search Pattern ( I Progress Monitor monitor ) throws Java Model Exception { Assert . is Not Null ( f Pattern ) ; if ( monitor == null ) monitor = new Null Progress Monitor ( ) ; try { monitor . begin Task ( STRING , NUM ) ; monitor . set Task Name ( Refactoring Core Messages . Refactoring Search Engine searching occurrences ) ; try { Search Engine engine = null ; if ( f Owner != null ) engine = new Search Engine ( f Owner ) ; else engine = new Search Engine ( f Working Copies ) ; engine . search ( f Pattern , Search Utils . get Default Search Participants ( ) , f Scope , get Collector ( ) , new Sub Progress Monitor ( monitor , NUM , Sub Progress Monitor . SUPPRESS SUBTASK LABEL ) ) ; } catch ( Core Exception exception ) { throw new Java Model Exception ( exception ) ; } } finally { monitor . done ( ) ; } }
public void add Notice ( Parser Notice notice ) { notices . add ( notice ) ; }
private Iterable < String > distinct Names ( Iterable < Inet Socket Address > addresses ) { Set < String > result = new Hash Set < > ( ) ; for ( Inet Socket Address address : addresses ) { result . add ( name ( address ) ) ; } return result ; }
public boolean send Via Data Socket ( String string ) { try { byte [ ] bytes = string . get Bytes ( encoding ) ; Log . d ( TAG , STRING + encoding ) ; return send Via Data Socket ( bytes , bytes . length ) ; } catch ( Unsupported Encoding Exception e ) { Log . e ( TAG , STRING ) ; return BOOL ; } }
public boolean send Via Data Socket ( String string ) { try { byte [ ] bytes = string . get Bytes ( encoding ) ; Log . d ( TAG , STRING + encoding ) ; return send Via Data Socket ( bytes , bytes . length ) ; } catch ( Unsupported Encoding Exception e ) { Log . e ( TAG , STRING ) ; return BOOL ; } }
public boolean send Via Data Socket ( String string ) { try { byte [ ] bytes = string . get Bytes ( encoding ) ; Log . d ( TAG , STRING + encoding ) ; return send Via Data Socket ( bytes , bytes . length ) ; } catch ( Unsupported Encoding Exception e ) { Log . e ( TAG , STRING ) ; return BOOL ; } }
protected Array List < Integer > calculate Heights For Animation Parts ( int title View Height , int content View Height , int additional Flips Count ) { Array List < Integer > part Heights = new Array List < > ( ) ; int additional Parts Total Height = content View Height - title View Height * NUM ; if ( additional Parts Total Height < NUM ) throw new Illegal State Exception ( STRING ) ; part Heights . add ( title View Height ) ; part Heights . add ( title View Height ) ; if ( additional Parts Total Height == NUM ) return part Heights ; if ( additional Flips Count != NUM ) { int additional Part Height = additional Parts Total Height / additional Flips Count ; int remaining Height = additional Parts Total Height % additional Flips Count ; if ( additional Part Height + remaining Height > title View Height ) throw new Illegal State Exception ( STRING ) ; for ( int i = NUM ; i < additional Flips Count ; i ++ ) part Heights . add ( additional Part Height + ( i == NUM ? remaining Height : NUM ) ) ; } else { int parts Count = additional Parts Total Height / title View Height ; int rest Part Height = additional Parts Total Height % title View Height ; for ( int i = NUM ; i < parts Count ; i ++ ) part Heights . add ( title View Height ) ; if ( rest Part Height > NUM ) part Heights . add ( rest Part Height ) ; } return part Heights ; }
private void apply Query Hints ( final AST 2 B Op Context context , final Query Root query Root , final Query Hint Scope scope , final AST Base t , final Properties query Hints ) { @ Suppress Warnings ( STRING ) final Enumeration e = query Hints . property Names ( ) ; while ( e . has More Elements ( ) ) { final String name = ( String ) e . next Element ( ) ; final String value = query Hints . get Property ( name ) ; apply Query Hint ( context , query Root , scope , t , name , value ) ; } }
@ Override protected void auto Adjust Range ( ) { Plot plot = get Plot ( ) ; if ( plot == null ) { return ; } if ( plot instanceof Value Axis Plot ) { Value Axis Plot vap = ( Value Axis Plot ) plot ; Range r = vap . get Data Range ( this ) ; if ( r == null ) { r = get Default Auto Range ( ) ; } long upper = Math . round ( r . get Upper Bound ( ) ) ; long lower = Math . round ( r . get Lower Bound ( ) ) ; this . first = create Instance ( this . auto Range Time Period Class , new Date ( lower ) , this . time Zone , this . locale ) ; this . last = create Instance ( this . auto Range Time Period Class , new Date ( upper ) , this . time Zone , this . locale ) ; set Range ( r , BOOL , BOOL ) ; } }
@ Override protected void auto Adjust Range ( ) { Plot plot = get Plot ( ) ; if ( plot == null ) { return ; } if ( plot instanceof Value Axis Plot ) { Value Axis Plot vap = ( Value Axis Plot ) plot ; Range r = vap . get Data Range ( this ) ; if ( r == null ) { r = get Default Auto Range ( ) ; } long upper = Math . round ( r . get Upper Bound ( ) ) ; long lower = Math . round ( r . get Lower Bound ( ) ) ; this . first = create Instance ( this . auto Range Time Period Class , new Date ( lower ) , this . time Zone , this . locale ) ; this . last = create Instance ( this . auto Range Time Period Class , new Date ( upper ) , this . time Zone , this . locale ) ; set Range ( r , BOOL , BOOL ) ; } }
public void send Request ( Slo Request Settings request Settings , Http Servlet Response response ) throws IO Exception { Validate . not Null ( request Settings , STRING ) ; Validate . not Null ( response , STRING ) ; Validate . not Null ( get Message Store ( ) , STRING ) ; Validate . not Null ( get Metadata Settings ( ) , STRING ) ; String redirect Url = get Request Url ( request Settings ) ; if ( redirect Url != null ) { response . send Redirect ( redirect Url ) ; } else { if ( Saml Utils . is Idp Support SLO ( get Metadata Settings ( ) , request Settings ) ) { logger . error ( STRING ) ; } else { logger . warn ( String . format ( STRING , request Settings . get IDP Alias ( ) ) ) ; } } }
public void load Settings ( File file ) { if ( ! file . can Read ( ) ) return ; File Input Stream input = null ; try { input = new File Input Stream ( file ) ; values . load ( input ) ; } catch ( IO Exception e ) { } finally { if ( input != null ) { try { input . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } } }
public void load Settings ( File file ) { if ( ! file . can Read ( ) ) return ; File Input Stream input = null ; try { input = new File Input Stream ( file ) ; values . load ( input ) ; } catch ( IO Exception e ) { } finally { if ( input != null ) { try { input . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } } }
private void increment Submitted Job Count ( ) { count Lock . lock ( ) ; try { submitted Job Count ++ ; } finally { count Lock . unlock ( ) ; } }
private void increment Submitted Job Count ( ) { count Lock . lock ( ) ; try { submitted Job Count ++ ; } finally { count Lock . unlock ( ) ; } }
private static SSL Socket Factory trust All Hosts ( Https URL Connection connection ) { SSL Socket Factory old Factory = connection . get SSL Socket Factory ( ) ; try { SSL Context sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trust All Certs , new java . security . Secure Random ( ) ) ; SSL Socket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSL Socket Factory ( new Factory ) ; } catch ( Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return old Factory ; }
private static SSL Socket Factory trust All Hosts ( Https URL Connection connection ) { SSL Socket Factory old Factory = connection . get SSL Socket Factory ( ) ; try { SSL Context sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trust All Certs , new java . security . Secure Random ( ) ) ; SSL Socket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSL Socket Factory ( new Factory ) ; } catch ( Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return old Factory ; }
private static SSL Socket Factory trust All Hosts ( Https URL Connection connection ) { SSL Socket Factory old Factory = connection . get SSL Socket Factory ( ) ; try { SSL Context sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trust All Certs , new java . security . Secure Random ( ) ) ; SSL Socket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSL Socket Factory ( new Factory ) ; } catch ( Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return old Factory ; }
private static SSL Socket Factory trust All Hosts ( Https URL Connection connection ) { SSL Socket Factory old Factory = connection . get SSL Socket Factory ( ) ; try { SSL Context sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trust All Certs , new java . security . Secure Random ( ) ) ; SSL Socket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSL Socket Factory ( new Factory ) ; } catch ( Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return old Factory ; }
private static SSL Socket Factory trust All Hosts ( Https URL Connection connection ) { SSL Socket Factory old Factory = connection . get SSL Socket Factory ( ) ; try { SSL Context sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trust All Certs , new java . security . Secure Random ( ) ) ; SSL Socket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSL Socket Factory ( new Factory ) ; } catch ( Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return old Factory ; }
private static SSL Socket Factory trust All Hosts ( Https URL Connection connection ) { SSL Socket Factory old Factory = connection . get SSL Socket Factory ( ) ; try { SSL Context sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trust All Certs , new java . security . Secure Random ( ) ) ; SSL Socket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSL Socket Factory ( new Factory ) ; } catch ( Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return old Factory ; }
private static SSL Socket Factory trust All Hosts ( Https URL Connection connection ) { SSL Socket Factory old Factory = connection . get SSL Socket Factory ( ) ; try { SSL Context sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trust All Certs , new java . security . Secure Random ( ) ) ; SSL Socket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSL Socket Factory ( new Factory ) ; } catch ( Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return old Factory ; }
private static SSL Socket Factory trust All Hosts ( Https URL Connection connection ) { SSL Socket Factory old Factory = connection . get SSL Socket Factory ( ) ; try { SSL Context sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trust All Certs , new java . security . Secure Random ( ) ) ; SSL Socket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSL Socket Factory ( new Factory ) ; } catch ( Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return old Factory ; }
private static SSL Socket Factory trust All Hosts ( Https URL Connection connection ) { SSL Socket Factory old Factory = connection . get SSL Socket Factory ( ) ; try { SSL Context sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trust All Certs , new java . security . Secure Random ( ) ) ; SSL Socket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSL Socket Factory ( new Factory ) ; } catch ( Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return old Factory ; }
private static SSL Socket Factory trust All Hosts ( Https URL Connection connection ) { SSL Socket Factory old Factory = connection . get SSL Socket Factory ( ) ; try { SSL Context sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trust All Certs , new java . security . Secure Random ( ) ) ; SSL Socket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSL Socket Factory ( new Factory ) ; } catch ( Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return old Factory ; }
private static SSL Socket Factory trust All Hosts ( Https URL Connection connection ) { SSL Socket Factory old Factory = connection . get SSL Socket Factory ( ) ; try { SSL Context sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trust All Certs , new java . security . Secure Random ( ) ) ; SSL Socket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSL Socket Factory ( new Factory ) ; } catch ( Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return old Factory ; }
private static SSL Socket Factory trust All Hosts ( Https URL Connection connection ) { SSL Socket Factory old Factory = connection . get SSL Socket Factory ( ) ; try { SSL Context sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trust All Certs , new java . security . Secure Random ( ) ) ; SSL Socket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSL Socket Factory ( new Factory ) ; } catch ( Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return old Factory ; }
private static SSL Socket Factory trust All Hosts ( Https URL Connection connection ) { SSL Socket Factory old Factory = connection . get SSL Socket Factory ( ) ; try { SSL Context sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trust All Certs , new java . security . Secure Random ( ) ) ; SSL Socket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSL Socket Factory ( new Factory ) ; } catch ( Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return old Factory ; }
private static SSL Socket Factory trust All Hosts ( Https URL Connection connection ) { SSL Socket Factory old Factory = connection . get SSL Socket Factory ( ) ; try { SSL Context sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trust All Certs , new java . security . Secure Random ( ) ) ; SSL Socket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSL Socket Factory ( new Factory ) ; } catch ( Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return old Factory ; }
private static SSL Socket Factory trust All Hosts ( Https URL Connection connection ) { SSL Socket Factory old Factory = connection . get SSL Socket Factory ( ) ; try { SSL Context sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trust All Certs , new java . security . Secure Random ( ) ) ; SSL Socket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSL Socket Factory ( new Factory ) ; } catch ( Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return old Factory ; }
@ Override public void around Write To ( Writer Interceptor Context writer Interceptor Context ) throws IO Exception { Length Of Output Stream stream = ( Length Of Output Stream ) writer Interceptor Context . get Property ( PROPERTY OUTPUT STREAM ) ; try { writer Interceptor Context . proceed ( ) ; if ( stream != null ) { emit Success ( stream ) ; } } catch ( EOF Exception e ) { if ( stream != null ) { emit Error ( stream , e ) ; } LOG . warn ( STRING , e ) ; } catch ( Error | Runtime Exception | IO Exception e ) { if ( stream != null ) { emit Error ( stream , e ) ; } LOG . error ( STRING , e ) ; throw e ; } finally { try { Request Log . stop Timing ( this ) ; Request Log . stop Timing ( TOTAL TIMER ) ; Request Log . log ( ) ; } catch ( Exception e ) { LOG . error ( STRING , e ) ; } } }
@ Override public void around Write To ( Writer Interceptor Context writer Interceptor Context ) throws IO Exception { Length Of Output Stream stream = ( Length Of Output Stream ) writer Interceptor Context . get Property ( PROPERTY OUTPUT STREAM ) ; try { writer Interceptor Context . proceed ( ) ; if ( stream != null ) { emit Success ( stream ) ; } } catch ( EOF Exception e ) { if ( stream != null ) { emit Error ( stream , e ) ; } LOG . warn ( STRING , e ) ; } catch ( Error | Runtime Exception | IO Exception e ) { if ( stream != null ) { emit Error ( stream , e ) ; } LOG . error ( STRING , e ) ; throw e ; } finally { try { Request Log . stop Timing ( this ) ; Request Log . stop Timing ( TOTAL TIMER ) ; Request Log . log ( ) ; } catch ( Exception e ) { LOG . error ( STRING , e ) ; } } }
@ Override public void around Write To ( Writer Interceptor Context writer Interceptor Context ) throws IO Exception { Length Of Output Stream stream = ( Length Of Output Stream ) writer Interceptor Context . get Property ( PROPERTY OUTPUT STREAM ) ; try { writer Interceptor Context . proceed ( ) ; if ( stream != null ) { emit Success ( stream ) ; } } catch ( EOF Exception e ) { if ( stream != null ) { emit Error ( stream , e ) ; } LOG . warn ( STRING , e ) ; } catch ( Error | Runtime Exception | IO Exception e ) { if ( stream != null ) { emit Error ( stream , e ) ; } LOG . error ( STRING , e ) ; throw e ; } finally { try { Request Log . stop Timing ( this ) ; Request Log . stop Timing ( TOTAL TIMER ) ; Request Log . log ( ) ; } catch ( Exception e ) { LOG . error ( STRING , e ) ; } } }
private int [ ] parse Skill Up Values ( String ... skills ) { int [ ] ret = new int [ ] { DEFAULT INT , DEFAULT INT , DEFAULT INT , DEFAULT INT } ; try { for ( int i = NUM ; i <= NUM && i < skills . length ; i ++ ) { String skill = skills [ i ] ; if ( skill == null || skill . is Empty ( ) ) { continue ; } else { ret [ i ] = Integer . parse Int ( skill . trim ( ) ) ; } } } catch ( Number Format Exception nfe ) { nfe . print Stack Trace ( ) ; } return ret ; }
private int [ ] parse Skill Up Values ( String ... skills ) { int [ ] ret = new int [ ] { DEFAULT INT , DEFAULT INT , DEFAULT INT , DEFAULT INT } ; try { for ( int i = NUM ; i <= NUM && i < skills . length ; i ++ ) { String skill = skills [ i ] ; if ( skill == null || skill . is Empty ( ) ) { continue ; } else { ret [ i ] = Integer . parse Int ( skill . trim ( ) ) ; } } } catch ( Number Format Exception nfe ) { nfe . print Stack Trace ( ) ; } return ret ; }
private Image Data awt To Swt ( final Buffered Image buffered Image , final int width , final int height ) { final int [ ] awt Pixels = new int [ width * height ] ; final Image Data swt Image Data = new Image Data ( width , height , NUM , PALETTE DATA ) ; swt Image Data . transparent Pixel = TRANSPARENT COLOR ; final int step = swt Image Data . depth / NUM ; final byte [ ] data = swt Image Data . data ; buffered Image . get RGB ( NUM , NUM , width , height , awt Pixels , NUM , width ) ; for ( int i = NUM ; i < height ; i ++ ) { int idx = ( NUM + i ) * swt Image Data . bytes Per Line + NUM * step ; for ( int j = NUM ; j < width ; j ++ ) { final int rgb = awt Pixels [ j + i * width ] ; for ( int k = swt Image Data . depth - NUM ; k >= NUM ; k -= NUM ) { data [ idx ++ ] = ( byte ) ( rgb > > k & NUM ) ; } } } return swt Image Data ; }
public J Component create Property GUI ( Property Consumer pc ) { this . property Consumer = pc ; Properties props = new Properties ( ) ; props = pc . get Properties ( props ) ; Properties info = new Properties ( ) ; info = pc . get Property Info ( info ) ; String prefix = pc . get Property Prefix ( ) ; return create Property GUI ( prefix , props , info ) ; }
public IEEE 802154 Message ( byte [ ] a , int l ) { super ( String . value Of ( a ) ) ; set Response Length ( l ) ; set Binary ( BOOL ) ; set Timeout ( NUM ) ; }
public IEEE 802154 Message ( byte [ ] a , int l ) { super ( String . value Of ( a ) ) ; set Response Length ( l ) ; set Binary ( BOOL ) ; set Timeout ( NUM ) ; }
public Runnable increment As Runnable ( ) { return m Increment Runnable ; }
public double clamp ( double value ) { return Math . min ( Math . max ( get Min ( ) , value ) , get Max ( ) ) ; }
public static String abbreviate Name ( String str , Font Metrics fm , int width ) { if ( fm . string Width ( str ) > width ) str = abbreviate Name ( str , BOOL ) ; if ( fm . string Width ( str ) > width ) str = abbreviate Name ( str , BOOL ) ; return str ; }
@ Request Mapping ( value = STRING , method = POST , produces = APPLICATION JSON VALUE ) public Response Entity < Page Response < Author DTO > > find All ( @ Request Body Page Request By Example < Author DTO > prbe ) throws URI Syntax Exception { Page Response < Author DTO > page Response = author DTO Service . find All ( prbe ) ; return new Response Entity < > ( page Response , new Http Headers ( ) , Http Status . OK ) ; }
@ Request Mapping ( value = STRING , method = POST , produces = APPLICATION JSON VALUE ) public Response Entity < Page Response < Author DTO > > find All ( @ Request Body Page Request By Example < Author DTO > prbe ) throws URI Syntax Exception { Page Response < Author DTO > page Response = author DTO Service . find All ( prbe ) ; return new Response Entity < > ( page Response , new Http Headers ( ) , Http Status . OK ) ; }
public DB Data Collector ( ) { super ( ) ; properties File Name = DEFAULT CONFIG FILE NAME ; final String user Defined Properties File Name = System . get Property ( CONFIG PROPERTY FILE NAME ) ; if ( user Defined Properties File Name != null ) { properties File Name = user Defined Properties File Name ; } }
@ Visible For Testing static boolean should Open After Download ( Download Info download Info ) { String type = download Info . get Mime Type ( ) ; return download Info . has User Gesture ( ) && ! is Attachment ( download Info . get Content Disposition ( ) ) && MIME TYPES TO OPEN . contains ( type ) ; }
public void on Location Changed ( Location location ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + location ) ; } synchronized ( listeners ) { got Valid Position = BOOL ; for ( GPS Location Listener listener : listeners ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + listener ) ; } listener . on Location Changed ( location ) ; } listeners . clear ( ) ; } }
protected final void parse Args ( String [ ] args ) throws Ade Exception { final Array List < String > ade Args = parse Ade Ext Args ( args ) ; super . parse Args ( ade Args . to Array ( new String [ ade Args . size ( ) ] ) ) ; }
public static void save Image ( final Bitmap bitmap , final File save To File ) { if ( save To File . exists ( ) ) { save To File . delete ( ) ; } try { final File Output Stream out = new File Output Stream ( save To File ) ; bitmap . compress ( Bitmap . Compress Format . PNG , NUM , out ) ; out . flush ( ) ; out . close ( ) ; } catch ( final Exception e ) { e . print Stack Trace ( ) ; } }
public static void save Image ( final Bitmap bitmap , final File save To File ) { if ( save To File . exists ( ) ) { save To File . delete ( ) ; } try { final File Output Stream out = new File Output Stream ( save To File ) ; bitmap . compress ( Bitmap . Compress Format . PNG , NUM , out ) ; out . flush ( ) ; out . close ( ) ; } catch ( final Exception e ) { e . print Stack Trace ( ) ; } }
public static void save Image ( final Bitmap bitmap , final File save To File ) { if ( save To File . exists ( ) ) { save To File . delete ( ) ; } try { final File Output Stream out = new File Output Stream ( save To File ) ; bitmap . compress ( Bitmap . Compress Format . PNG , NUM , out ) ; out . flush ( ) ; out . close ( ) ; } catch ( final Exception e ) { e . print Stack Trace ( ) ; } }
public static void save Image ( final Bitmap bitmap , final File save To File ) { if ( save To File . exists ( ) ) { save To File . delete ( ) ; } try { final File Output Stream out = new File Output Stream ( save To File ) ; bitmap . compress ( Bitmap . Compress Format . PNG , NUM , out ) ; out . flush ( ) ; out . close ( ) ; } catch ( final Exception e ) { e . print Stack Trace ( ) ; } }
public static void save Image ( final Bitmap bitmap , final File save To File ) { if ( save To File . exists ( ) ) { save To File . delete ( ) ; } try { final File Output Stream out = new File Output Stream ( save To File ) ; bitmap . compress ( Bitmap . Compress Format . PNG , NUM , out ) ; out . flush ( ) ; out . close ( ) ; } catch ( final Exception e ) { e . print Stack Trace ( ) ; } }
public void property Change ( Property Change Event evt ) { repaint ( ) ; }
public D Authority Information Access ( J Dialog parent , byte [ ] value ) throws IO Exception { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
@ Override public String to String ( ) { String Builder s = new String Builder ( NUM ) ; final int number Of Leading Zeros = Long . number Of Leading Zeros ( term ) ; for ( int i = NUM ; i < number Of Leading Zeros ; i ++ ) { s . append ( STRING ) ; } if ( term != NUM ) s . append ( Long . to Binary String ( term ) ) ; return s . to String ( ) ; }
public Map < String , String > parse ( final String str , char [ ] separators ) { if ( separators == null || separators . length == NUM ) { return new Hash Map < > ( ) ; } char separator = separators [ NUM ] ; if ( str != null ) { int idx = str . length ( ) ; for ( char separator 2 : separators ) { int tmp = str . index Of ( separator 2 ) ; if ( tmp != - NUM && tmp < idx ) { idx = tmp ; separator = separator 2 ; } } } return parse ( str , separator ) ; }
public Map < String , String > parse ( final String str , char [ ] separators ) { if ( separators == null || separators . length == NUM ) { return new Hash Map < > ( ) ; } char separator = separators [ NUM ] ; if ( str != null ) { int idx = str . length ( ) ; for ( char separator 2 : separators ) { int tmp = str . index Of ( separator 2 ) ; if ( tmp != - NUM && tmp < idx ) { idx = tmp ; separator = separator 2 ; } } } return parse ( str , separator ) ; }
public Map < String , String > parse ( final String str , char [ ] separators ) { if ( separators == null || separators . length == NUM ) { return new Hash Map < > ( ) ; } char separator = separators [ NUM ] ; if ( str != null ) { int idx = str . length ( ) ; for ( char separator 2 : separators ) { int tmp = str . index Of ( separator 2 ) ; if ( tmp != - NUM && tmp < idx ) { idx = tmp ; separator = separator 2 ; } } } return parse ( str , separator ) ; }
private void reduce ( Css Token Type type ) { String Builder sb = new String Builder ( ) ; for ( Token < Css Token Type > t : pending ) { sb . append ( t . text ) ; } File Position fp = File Position . span ( pending . get First ( ) . pos , pending . get Last ( ) . pos ) ; pending . clear ( ) ; pending . add ( Token . instance ( sb . to String ( ) , type , fp ) ) ; }
private void reduce ( Css Token Type type ) { String Builder sb = new String Builder ( ) ; for ( Token < Css Token Type > t : pending ) { sb . append ( t . text ) ; } File Position fp = File Position . span ( pending . get First ( ) . pos , pending . get Last ( ) . pos ) ; pending . clear ( ) ; pending . add ( Token . instance ( sb . to String ( ) , type , fp ) ) ; }
private void reduce ( Css Token Type type ) { String Builder sb = new String Builder ( ) ; for ( Token < Css Token Type > t : pending ) { sb . append ( t . text ) ; } File Position fp = File Position . span ( pending . get First ( ) . pos , pending . get Last ( ) . pos ) ; pending . clear ( ) ; pending . add ( Token . instance ( sb . to String ( ) , type , fp ) ) ; }
public static String normalize Dir ( String path ) { return ( path != null && ( ! ( path . ends With ( STRING ) || path . ends With ( STRING ) ) ) ) ? path + File . separator : path ; }
public static String normalize Dir ( String path ) { return ( path != null && ( ! ( path . ends With ( STRING ) || path . ends With ( STRING ) ) ) ) ? path + File . separator : path ; }
public boolean greater Than ( FXG Version version ) { return ( compare To ( version ) > NUM ) ; }
protected void handle Unexamine On Send Message ( String message ) { if ( String Utils . is Blank ( message ) ) { return ; } String first Word = message . split ( STRING ) [ NUM ] ; if ( String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) ) { Game [ ] games = game Service . get All Active Games ( ) ; Game examined Game = null ; for ( Game game : games ) { if ( game . is In State ( Game . EXAMINING STATE ) || game . is In State ( Game . SETUP STATE ) ) { examined Game = game ; break ; } } if ( examined Game != null ) { on Unexamine ( examined Game ) ; } } }
protected void handle Unexamine On Send Message ( String message ) { if ( String Utils . is Blank ( message ) ) { return ; } String first Word = message . split ( STRING ) [ NUM ] ; if ( String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) ) { Game [ ] games = game Service . get All Active Games ( ) ; Game examined Game = null ; for ( Game game : games ) { if ( game . is In State ( Game . EXAMINING STATE ) || game . is In State ( Game . SETUP STATE ) ) { examined Game = game ; break ; } } if ( examined Game != null ) { on Unexamine ( examined Game ) ; } } }
protected void handle Unexamine On Send Message ( String message ) { if ( String Utils . is Blank ( message ) ) { return ; } String first Word = message . split ( STRING ) [ NUM ] ; if ( String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) || String Utils . equals Ignore Case ( first Word , STRING ) ) { Game [ ] games = game Service . get All Active Games ( ) ; Game examined Game = null ; for ( Game game : games ) { if ( game . is In State ( Game . EXAMINING STATE ) || game . is In State ( Game . SETUP STATE ) ) { examined Game = game ; break ; } } if ( examined Game != null ) { on Unexamine ( examined Game ) ; } } }
public final void add Reference ( Object ref ) { ref Set . add ( ref ) ; }
public void clear ( ) { if ( m Original Values != null ) { synchronized ( m Lock ) { m Original Values . clear ( ) ; } } else { m Objects . clear ( ) ; } if ( m Notify On Change ) notify Data Set Changed ( ) ; }
public Repeated Field Builder < M Type , B Type , I Type > add Message ( int index , M Type message ) { if ( message == null ) { throw new Null Pointer Exception ( ) ; } ensure Mutable Message List ( ) ; messages . add ( index , message ) ; if ( builders != null ) { builders . add ( index , null ) ; } on Changed ( ) ; increment Mod Counts ( ) ; return this ; }
public Repeated Field Builder < M Type , B Type , I Type > add Message ( int index , M Type message ) { if ( message == null ) { throw new Null Pointer Exception ( ) ; } ensure Mutable Message List ( ) ; messages . add ( index , message ) ; if ( builders != null ) { builders . add ( index , null ) ; } on Changed ( ) ; increment Mod Counts ( ) ; return this ; }
private static boolean is Invoice Type Recurse ( Generic Value invoice Type , String input Type Id ) throws Generic Entity Exception { String invoice Type Id = invoice Type . get String ( STRING ) ; String parent Type Id = invoice Type . get String ( STRING ) ; if ( parent Type Id == null || invoice Type Id . equals ( parent Type Id ) ) { return BOOL ; } if ( parent Type Id . equals ( input Type Id ) ) { return BOOL ; } return is Invoice Type Recurse ( invoice Type . get Related One ( STRING , BOOL ) , input Type Id ) ; }
private static boolean is Invoice Type Recurse ( Generic Value invoice Type , String input Type Id ) throws Generic Entity Exception { String invoice Type Id = invoice Type . get String ( STRING ) ; String parent Type Id = invoice Type . get String ( STRING ) ; if ( parent Type Id == null || invoice Type Id . equals ( parent Type Id ) ) { return BOOL ; } if ( parent Type Id . equals ( input Type Id ) ) { return BOOL ; } return is Invoice Type Recurse ( invoice Type . get Related One ( STRING , BOOL ) , input Type Id ) ; }
public Named Column Projection ( String name , boolean include ) { m names = new Hash Set ( ) ; m names . add ( name ) ; m include = include ; }
protected void process Nodes After Add Instance ( Ball Node node ) { node . m Start ++ ; node . m End ++ ; if ( node . m Left != null && node . m Right != null ) { process Nodes After Add Instance ( node . m Left ) ; process Nodes After Add Instance ( node . m Right ) ; } }
protected void process Nodes After Add Instance ( Ball Node node ) { node . m Start ++ ; node . m End ++ ; if ( node . m Left != null && node . m Right != null ) { process Nodes After Add Instance ( node . m Left ) ; process Nodes After Add Instance ( node . m Right ) ; } }
protected void process Nodes After Add Instance ( Ball Node node ) { node . m Start ++ ; node . m End ++ ; if ( node . m Left != null && node . m Right != null ) { process Nodes After Add Instance ( node . m Left ) ; process Nodes After Add Instance ( node . m Right ) ; } }
@ Override public boolean can Undo ( ) { return ! m Undo List . is Empty ( ) ; }
public void remove Index Keyspace ( final String index ) throws IO Exception { try { Query Processor . process ( String . format ( STRING , index ) , Consistency Level . LOCAL ONE ) ; } catch ( Throwable e ) { throw new IO Exception ( e . get Message ( ) , e ) ; } }
public void remove Index Keyspace ( final String index ) throws IO Exception { try { Query Processor . process ( String . format ( STRING , index ) , Consistency Level . LOCAL ONE ) ; } catch ( Throwable e ) { throw new IO Exception ( e . get Message ( ) , e ) ; } }
public void remove Index Keyspace ( final String index ) throws IO Exception { try { Query Processor . process ( String . format ( STRING , index ) , Consistency Level . LOCAL ONE ) ; } catch ( Throwable e ) { throw new IO Exception ( e . get Message ( ) , e ) ; } }
public boolean remove On Item Click Listener ( On Item Click Listener item Click Listener ) { return click Listeners . remove ( item Click Listener ) ; }
public boolean to Boolean ( Element el , String attribute Name ) { return Caster . to Boolean Value ( el . get Attribute ( attribute Name ) , BOOL ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; Enumeration < Option > enm = super . list Options ( ) ; while ( enm . has More Elements ( ) ) result . add ( enm . next Element ( ) ) ; result . add Element ( new Option ( STRING + stopwords Tip Text ( ) + STRING + STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; Enumeration < Option > enm = super . list Options ( ) ; while ( enm . has More Elements ( ) ) result . add ( enm . next Element ( ) ) ; result . add Element ( new Option ( STRING + stopwords Tip Text ( ) + STRING + STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
public final int data Offset ( ) { return this . bound Offset ; }
public final int data Offset ( ) { return this . bound Offset ; }
public static Number minus ( Character left , Character right ) { return minus ( Integer . value Of ( left ) , right ) ; }
public static Number minus ( Character left , Character right ) { return minus ( Integer . value Of ( left ) , right ) ; }
public static Number minus ( Character left , Character right ) { return minus ( Integer . value Of ( left ) , right ) ; }
public void draw Connection ( View Transform transform , Graphics 2 D g , Color Set color Set , boolean is Selected , Point target ) { Connection Drawing drawing = new Connection Drawing ( ) ; add Path Connection ( transform , g , is Selected , BOOL , drawing , color Set , ( int ) target . get X ( ) , ( int ) target . get Y ( ) , BOOL , BOOL ) ; boolean draw Shadow = is Selected && m Anchor . get Connection Creator ( ) != Constraint Anchor . AUTO CONSTRAINT CREATOR ; if ( draw Shadow ) { Color pre = g . get Color ( ) ; Stroke s = g . get Stroke ( ) ; g . set Color ( s Shadow Color ) ; g . set Stroke ( s Shadow Stroke ) ; drawing . draw ( g ) ; g . set Color ( pre ) ; g . set Stroke ( s ) ; } drawing . draw ( g ) ; }
public App Config Base ( ) { }
@ Override public Surface Data create Surface Data ( W Component Peer peer , int num Back Buffers ) { Surface Data sd = WGL Surface Data . create Data ( peer ) ; if ( sd == null ) { sd = GDI Window Surface Data . create Data ( peer ) ; } return sd ; }
public void register Share Key ( String share Key ) { share Keys . add ( share Key ) ; }
public void register Share Key ( String share Key ) { share Keys . add ( share Key ) ; }
public double value At ( double x ) { return constant * Math . pow ( NUM - x * x , outside Exp ) ; }
public double value At ( double x ) { return constant * Math . pow ( NUM - x * x , outside Exp ) ; }
public void start ( ) { try { heart = new Heart ( ) ; int threads = Integer . parse Int ( properties . get Property ( STRING , STRING ) ) ; for ( int i = NUM ; i < threads ; i ++ ) { Worker worker = new Worker ( this , i ) ; workers . add ( worker ) ; } client = new Async ( this , async timeout , BOOL ) ; client . start ( threads ) ; alive = BOOL ; Thread thread = new Thread ( this , STRING ) ; id = thread . get Id ( ) ; thread . start ( ) ; } catch ( Exception e ) { e . print Stack Trace ( out ) ; } }
private static Server Socket random ( ) throws IO Exception { final Server Socket skt = new Server Socket ( NUM ) ; skt . set Reuse Address ( BOOL ) ; return skt ; }
public static boolean contains Ignore Cases ( Collection < String > collection , String string ) { if ( collection == null ) { return BOOL ; } if ( string == null ) { return collection . contains ( null ) ; } boolean contains = BOOL ; for ( String element : collection ) { if ( string . equals Ignore Case ( element ) ) { contains = BOOL ; break ; } } return contains ; }
public static boolean contains Ignore Cases ( Collection < String > collection , String string ) { if ( collection == null ) { return BOOL ; } if ( string == null ) { return collection . contains ( null ) ; } boolean contains = BOOL ; for ( String element : collection ) { if ( string . equals Ignore Case ( element ) ) { contains = BOOL ; break ; } } return contains ; }
public static boolean contains Ignore Cases ( Collection < String > collection , String string ) { if ( collection == null ) { return BOOL ; } if ( string == null ) { return collection . contains ( null ) ; } boolean contains = BOOL ; for ( String element : collection ) { if ( string . equals Ignore Case ( element ) ) { contains = BOOL ; break ; } } return contains ; }
public static boolean contains Ignore Cases ( Collection < String > collection , String string ) { if ( collection == null ) { return BOOL ; } if ( string == null ) { return collection . contains ( null ) ; } boolean contains = BOOL ; for ( String element : collection ) { if ( string . equals Ignore Case ( element ) ) { contains = BOOL ; break ; } } return contains ; }
public static boolean contains Ignore Cases ( Collection < String > collection , String string ) { if ( collection == null ) { return BOOL ; } if ( string == null ) { return collection . contains ( null ) ; } boolean contains = BOOL ; for ( String element : collection ) { if ( string . equals Ignore Case ( element ) ) { contains = BOOL ; break ; } } return contains ; }
public boolean intersects ( Polygon 2 D polygon ) { for ( Point 2 D p : polygon . points ) if ( contains ( p ) ) return BOOL ; for ( Point 2 D p : points ) if ( polygon . contains ( p ) ) return BOOL ; return BOOL ; }
public boolean intersects ( Polygon 2 D polygon ) { for ( Point 2 D p : polygon . points ) if ( contains ( p ) ) return BOOL ; for ( Point 2 D p : points ) if ( polygon . contains ( p ) ) return BOOL ; return BOOL ; }
@ Override public void on View Position Changed ( View changed View , int left , int top , int dx , int dy ) { super . on View Position Changed ( changed View , left , top , dx , dy ) ; float fraction Screen ; switch ( dragger View . get Drag Position ( ) ) { case TOP : case BOTTOM : drag Offset = Math . abs ( top ) ; fraction Screen = ( float ) drag Offset / dragger Listener . drag Vertical Drag Range ( ) ; break ; case LEFT : case RIGHT : default : drag Offset = Math . abs ( left ) ; fraction Screen = ( float ) drag Offset / dragger Listener . drag Horizontal Drag Range ( ) ; break ; } if ( dragger Listener != null ) { dragger Listener . on View Position Changed ( fraction Screen >= NUM ? NUM : fraction Screen ) ; } }
@ Override public void on View Position Changed ( View changed View , int left , int top , int dx , int dy ) { super . on View Position Changed ( changed View , left , top , dx , dy ) ; float fraction Screen ; switch ( dragger View . get Drag Position ( ) ) { case TOP : case BOTTOM : drag Offset = Math . abs ( top ) ; fraction Screen = ( float ) drag Offset / dragger Listener . drag Vertical Drag Range ( ) ; break ; case LEFT : case RIGHT : default : drag Offset = Math . abs ( left ) ; fraction Screen = ( float ) drag Offset / dragger Listener . drag Horizontal Drag Range ( ) ; break ; } if ( dragger Listener != null ) { dragger Listener . on View Position Changed ( fraction Screen >= NUM ? NUM : fraction Screen ) ; } }
private String generate Fitting Text ( Method Usage method , Rectangle 2 D rect , Font Metrics font Metrics ) { if ( rect . get Width ( ) < font Metrics . string Width ( STRING ) ) { return STRING ; } String fully Qualified = method . get Name Space ( ) + STRING + method . get Name ( ) ; if ( font Metrics . string Width ( fully Qualified ) < rect . get Width ( ) ) { return fully Qualified ; } String abbrev Package = get Short Package Name ( method . get Name Space ( ) ) + STRING + method . get Name ( ) ; if ( font Metrics . string Width ( abbrev Package ) < rect . get Width ( ) ) { return abbrev Package ; } if ( font Metrics . string Width ( method . get Name ( ) ) < rect . get Width ( ) ) { return method . get Name ( ) ; } return STRING ; }
void materialize ( ) { if ( cachefill < NUM ) { return ; } double min = Double . MAX VALUE , max = Double . MIN VALUE ; for ( int i = NUM ; i < cachefill ; i ++ ) { min = Math . min ( min , cachec [ i ] ) ; max = Math . max ( max , cachec [ i ] ) ; } Linear Scale scale = new Linear Scale ( min , max ) ; min = scale . get Min ( ) ; max = scale . get Max ( ) ; this . base = min ; this . max = max ; this . binsize = ( max - min ) / this . destsize ; this . data = new double [ this . destsize << NUM ] ; size = destsize ; final int end = cachefill ; cachefill = - NUM ; for ( int i = NUM ; i < end ; i ++ ) { increment ( cachec [ i ] , cachev [ i ] ) ; } cachec = null ; cachev = null ; }
private int load Table ( long uuid ) throws IO Exception { int buffer Index = - NUM ; Set < Long > uuids = null ; int block Index = blocks . size ( ) - NUM ; Table Block last Block = blocks . get ( block Index ) ; while ( buffer Index == - NUM ) { Pair < Integer , Set < Long > > buffer Index And Uuuids = last Block . write Table ( uuid ) ; buffer Index = buffer Index And Uuuids . left ; if ( buffer Index == - NUM ) { block Index ++ ; last Block = new Table Block ( block Index * block Size ) ; blocks . add ( last Block ) ; } else { uuids = buffer Index And Uuuids . right ; } } int index = to Index ( block Index , buffer Index ) ; for ( Long table Uuid : uuids ) { file Index By Uuid . put ( table Uuid , index ) ; } return index ; }
private int load Table ( long uuid ) throws IO Exception { int buffer Index = - NUM ; Set < Long > uuids = null ; int block Index = blocks . size ( ) - NUM ; Table Block last Block = blocks . get ( block Index ) ; while ( buffer Index == - NUM ) { Pair < Integer , Set < Long > > buffer Index And Uuuids = last Block . write Table ( uuid ) ; buffer Index = buffer Index And Uuuids . left ; if ( buffer Index == - NUM ) { block Index ++ ; last Block = new Table Block ( block Index * block Size ) ; blocks . add ( last Block ) ; } else { uuids = buffer Index And Uuuids . right ; } } int index = to Index ( block Index , buffer Index ) ; for ( Long table Uuid : uuids ) { file Index By Uuid . put ( table Uuid , index ) ; } return index ; }
public double power Request ( ) { update ( ) ; return Math . min ( max Energy Received , max Energy Stored - energy Stored ) ; }
public static Reply Processor 21 send ( Set recipients , DM dm , int pr Id , int bucket Id , Bucket Profile bp , boolean require Ack ) { if ( recipients . is Empty ( ) ) { return null ; } Reply Processor 21 rp = null ; int proc Id = NUM ; if ( require Ack ) { rp = new Reply Processor 21 ( dm , recipients ) ; proc Id = rp . get Processor Id ( ) ; } Bucket Profile Update Message m = new Bucket Profile Update Message ( recipients , pr Id , proc Id , bucket Id , bp ) ; dm . put Outgoing ( m ) ; return rp ; }
@ Override public void mouse Dragged ( Mouse Event evt ) { int x Trans = NUM ; int y Trans = NUM ; if ( slider . get Snap To Ticks ( ) ) { int pos = get Location For Value ( get Snapped Value ( evt ) ) ; if ( pos > - NUM ) { if ( slider . get Orientation ( ) == J Slider . HORIZONTAL ) { x Trans = pos - evt . get X ( ) + offset ; evt . translate Point ( x Trans , NUM ) ; } else { y Trans = pos - evt . get Y ( ) + offset ; evt . translate Point ( NUM , y Trans ) ; } } } delegate . mouse Dragged ( evt ) ; evt . translate Point ( x Trans , y Trans ) ; }
@ Override public void mouse Dragged ( Mouse Event evt ) { int x Trans = NUM ; int y Trans = NUM ; if ( slider . get Snap To Ticks ( ) ) { int pos = get Location For Value ( get Snapped Value ( evt ) ) ; if ( pos > - NUM ) { if ( slider . get Orientation ( ) == J Slider . HORIZONTAL ) { x Trans = pos - evt . get X ( ) + offset ; evt . translate Point ( x Trans , NUM ) ; } else { y Trans = pos - evt . get Y ( ) + offset ; evt . translate Point ( NUM , y Trans ) ; } } } delegate . mouse Dragged ( evt ) ; evt . translate Point ( x Trans , y Trans ) ; }
public static < T > List < T > splice ( List < T > list , int index , int delete Count ) { return splice Impl ( list , index , delete Count , BOOL , null ) ; }
public static < T > List < T > splice ( List < T > list , int index , int delete Count ) { return splice Impl ( list , index , delete Count , BOOL , null ) ; }
public static boolean contains File ( @ Not Null Source Provider provider , @ Not Null File file ) { Collection < File > src Directories = get All Source Folders ( provider ) ; if ( files Equal ( provider . get Manifest File ( ) , file ) ) { return BOOL ; } for ( File container : src Directories ) { File parent = container . get Parent File ( ) ; if ( parent != null && parent . is Directory ( ) && files Equal ( parent , file ) ) { return BOOL ; } if ( ! container . exists ( ) ) { continue ; } if ( is Ancestor ( container , file , BOOL ) ) { return BOOL ; } } return BOOL ; }
private void parse Text ( ) { String Builder buf = new String Builder ( ) ; int start = next Char ; do { char ch = text . char At ( next Char ++ ) ; switch ( ch ) { case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; default : buf . append ( ch ) ; break ; } } while ( ! is Word Break ( next Char ) ) ; add Token ( new Html ( text . substring ( start , next Char ) , buf . to String ( ) ) ) ; }
private void parse Text ( ) { String Builder buf = new String Builder ( ) ; int start = next Char ; do { char ch = text . char At ( next Char ++ ) ; switch ( ch ) { case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; default : buf . append ( ch ) ; break ; } } while ( ! is Word Break ( next Char ) ) ; add Token ( new Html ( text . substring ( start , next Char ) , buf . to String ( ) ) ) ; }
private void terminate Task Mgr ( ) { if ( discovery Wakeup Mgr != null ) { discovery Wakeup Mgr . stop ( ) ; discovery Wakeup Mgr . cancel All ( ) ; } if ( discovery Task Mgr != null ) { List pending Tasks = discovery Task Mgr . get Pending ( ) ; for ( int i = NUM ; i < pending Tasks . size ( ) ; i ++ ) { Retry Task pending Task = ( Retry Task ) pending Tasks . get ( i ) ; pending Task . cancel ( ) ; discovery Task Mgr . remove ( pending Task ) ; } discovery Task Mgr . terminate ( ) ; discovery Task Mgr = null ; discovery Wakeup Mgr = null ; } }
@ Override public Category Item Renderer State initialise ( Graphics 2 D g2 , Rectangle 2 D data Area , Category Plot plot , int renderer Index , Plot Rendering Info info ) { set Plot ( plot ) ; Category Dataset data = plot . get Dataset ( renderer Index ) ; if ( data != null ) { this . row Count = data . get Row Count ( ) ; this . column Count = data . get Column Count ( ) ; } else { this . row Count = NUM ; this . column Count = NUM ; } Category Item Renderer State state = create State ( info ) ; state . set Element Hinting ( plot . fetch Element Hinting Flag ( ) ) ; int [ ] visible Series Temp = new int [ this . row Count ] ; int visible Series Count = NUM ; for ( int row = NUM ; row < this . row Count ; row ++ ) { if ( is Series Visible ( row ) ) { visible Series Temp [ visible Series Count ] = row ; visible Series Count ++ ; } } int [ ] visible Series = new int [ visible Series Count ] ; System . arraycopy ( visible Series Temp , NUM , visible Series , NUM , visible Series Count ) ; state . set Visible Series Array ( visible Series ) ; return state ; }
@ Override public Category Item Renderer State initialise ( Graphics 2 D g2 , Rectangle 2 D data Area , Category Plot plot , int renderer Index , Plot Rendering Info info ) { set Plot ( plot ) ; Category Dataset data = plot . get Dataset ( renderer Index ) ; if ( data != null ) { this . row Count = data . get Row Count ( ) ; this . column Count = data . get Column Count ( ) ; } else { this . row Count = NUM ; this . column Count = NUM ; } Category Item Renderer State state = create State ( info ) ; state . set Element Hinting ( plot . fetch Element Hinting Flag ( ) ) ; int [ ] visible Series Temp = new int [ this . row Count ] ; int visible Series Count = NUM ; for ( int row = NUM ; row < this . row Count ; row ++ ) { if ( is Series Visible ( row ) ) { visible Series Temp [ visible Series Count ] = row ; visible Series Count ++ ; } } int [ ] visible Series = new int [ visible Series Count ] ; System . arraycopy ( visible Series Temp , NUM , visible Series , NUM , visible Series Count ) ; state . set Visible Series Array ( visible Series ) ; return state ; }
protected void seed Line ( String uri ) { if ( ! uri . matches ( STRING ) ) { uri = STRING + uri ; } try { UURI uuri = UURI Factory . get Instance ( uri ) ; Crawl URI curi = new Crawl URI ( uuri ) ; curi . set Seed ( BOOL ) ; curi . set Scheduling Directive ( Scheduling Constants . MEDIUM ) ; if ( get Source Tag Seeds ( ) ) { curi . set Source Tag ( curi . to String ( ) ) ; } publish Added Seed ( curi ) ; } catch ( URI Exception e ) { nonseed Line ( uri ) ; } }
public void discharge Item ( Item Stack a Stack ) { increase Stored Energy Units ( GT Mod Handler . discharge Electric Item ( a Stack , ( int ) Math . min ( Integer . MAX VALUE , get EU Capacity ( ) - get Stored EU ( ) ) , ( int ) Math . min ( Integer . MAX VALUE , m Meta Tile Entity . get Input Tier ( ) ) , BOOL , BOOL , BOOL ) , BOOL ) ; }
public Str Builder insert ( final int index , final char chars [ ] ) { validate Index ( index ) ; if ( chars == null ) { return insert ( index , null Text ) ; } final int len = chars . length ; if ( len > NUM ) { ensure Capacity ( size + len ) ; System . arraycopy ( buffer , index , buffer , index + len , size - index ) ; System . arraycopy ( chars , NUM , buffer , index , len ) ; size += len ; } return this ; }
@ Namespace Permission ( fields = STRING , permissions = Namespace Permission Enum . EXECUTE ) @ Override @ Transactional ( propagation = Propagation . REQUIRES NEW ) public Emr Cluster create Cluster ( Emr Cluster Create Request request ) throws Exception { return create Cluster Impl ( request ) ; }
public static List < Volume > query Volumes By Iterative Query ( Db Client db Client , List < URI > volume UR Is ) { List < Volume > volumes = new Array List < Volume > ( ) ; @ Suppress Warnings ( STRING ) Iterator < Volume > volume Iterator = db Client . query Iterative Objects ( Volume . class , volume UR Is ) ; while ( volume Iterator . has Next ( ) ) { volumes . add ( volume Iterator . next ( ) ) ; } return volumes ; }
public Commafier ( final String initial ) { m separator = DEFAULT SEPARATOR ; sb . append ( initial ) ; }
public void add Connection Listener ( Connection Listener listener ) { connection Listeners . add Element ( listener ) ; }
public void add Connection Listener ( Connection Listener listener ) { connection Listeners . add Element ( listener ) ; }
public void add Connection Listener ( Connection Listener listener ) { connection Listeners . add Element ( listener ) ; }
public int index Of ( String arg ) { return arguments . index Of ( arg ) ; }
private void end Data Source Tag ( ) { buffer . append ( STRING ) ; }
public static Connection Factory configure Connection Factory ( final Json Value configuration , final String name , final Trust Manager trust Manager , final X509 Key Manager key Manager , final Class Loader provider Class Loader ) { final Json Value normalized Configuration = normalize Connection Factory ( configuration , name , NUM ) ; return configure Connection Factory ( normalized Configuration , trust Manager , key Manager , provider Class Loader ) ; }
public static Connection Factory configure Connection Factory ( final Json Value configuration , final String name , final Trust Manager trust Manager , final X509 Key Manager key Manager , final Class Loader provider Class Loader ) { final Json Value normalized Configuration = normalize Connection Factory ( configuration , name , NUM ) ; return configure Connection Factory ( normalized Configuration , trust Manager , key Manager , provider Class Loader ) ; }
public static Connection Factory configure Connection Factory ( final Json Value configuration , final String name , final Trust Manager trust Manager , final X509 Key Manager key Manager , final Class Loader provider Class Loader ) { final Json Value normalized Configuration = normalize Connection Factory ( configuration , name , NUM ) ; return configure Connection Factory ( normalized Configuration , trust Manager , key Manager , provider Class Loader ) ; }
public static String trim ( final String string ) { String result = null ; if ( string == null ) { result = BLANK ; } else { result = string . trim ( ) ; } return result ; }
public static String trim ( final String string ) { String result = null ; if ( string == null ) { result = BLANK ; } else { result = string . trim ( ) ; } return result ; }
public static String trim ( final String string ) { String result = null ; if ( string == null ) { result = BLANK ; } else { result = string . trim ( ) ; } return result ; }
public static String trim ( final String string ) { String result = null ; if ( string == null ) { result = BLANK ; } else { result = string . trim ( ) ; } return result ; }
public static String remove Illegal Character ( final String text ) { final String Builder r Val = new String Builder ( ) ; for ( int i = NUM ; i < text . length ( ) ; ++ i ) { if ( ! is Illegal File Name Char ( text . char At ( i ) ) ) { r Val . append ( text . char At ( i ) ) ; } } return r Val . to String ( ) ; }
@ Override public Array List < String > report Dense Features ( int index ) { dense Feature Index = index ; Array List < String > names = new Array List < > ( ) ; for ( int i = NUM ; i < phrase weights . length ; i ++ ) names . add ( String . format ( STRING , owner , i ) ) ; return names ; }
public static Set < String > compute Hash Index ( long doc Hash ) { int band Index = NUM ; Bit Set bit Range = new Bit Set ( BAND WIDTH ) ; int bits Width Counter = NUM ; Set < String > band Bitset = new Hash Set < > ( ) ; for ( int i = NUM ; i < HASH LENGTH ; ++ i ) { bit Range . set ( bits Width Counter , ( ( doc Hash > > i ) & NUM ) == NUM ) ; if ( bits Width Counter ++ == BAND WIDTH ) { band Bitset . add ( band Index + STRING + bit Range . to String ( ) ) ; bits Width Counter = NUM ; bit Range = new Bit Set ( BAND WIDTH ) ; band Index ++ ; } } return band Bitset ; }
public static Set < String > compute Hash Index ( long doc Hash ) { int band Index = NUM ; Bit Set bit Range = new Bit Set ( BAND WIDTH ) ; int bits Width Counter = NUM ; Set < String > band Bitset = new Hash Set < > ( ) ; for ( int i = NUM ; i < HASH LENGTH ; ++ i ) { bit Range . set ( bits Width Counter , ( ( doc Hash > > i ) & NUM ) == NUM ) ; if ( bits Width Counter ++ == BAND WIDTH ) { band Bitset . add ( band Index + STRING + bit Range . to String ( ) ) ; bits Width Counter = NUM ; bit Range = new Bit Set ( BAND WIDTH ) ; band Index ++ ; } } return band Bitset ; }
@ Override public String to String ( ) { if ( markers == null ) { return String . format ( STRING , DECIMAL FORMAT . format ( last Observation ) , DECIMAL FORMAT . format ( p Value ) ) ; } else { return String . format ( STRING , DECIMAL FORMAT . format ( last Observation ) , markers . to String ( ) ) ; } }
private static boolean is Corba Url ( String url ) { return url . starts With ( STRING ) || url . starts With ( STRING ) || url . starts With ( STRING ) ; }
private static boolean is Corba Url ( String url ) { return url . starts With ( STRING ) || url . starts With ( STRING ) || url . starts With ( STRING ) ; }
private static boolean is Corba Url ( String url ) { return url . starts With ( STRING ) || url . starts With ( STRING ) || url . starts With ( STRING ) ; }
public Object create ( String url ) throws Malformed URL Exception , Class Not Found Exception { Hessian Meta Info API meta Info ; meta Info = ( Hessian Meta Info API ) create ( Hessian Meta Info API . class , url ) ; String api Class Name = ( String ) meta Info . hessian get Attribute ( STRING ) ; if ( api Class Name == null ) throw new Hessian Runtime Exception ( url + STRING ) ; Class < ? > api Class = Class . for Name ( api Class Name , BOOL , loader ) ; return create ( api Class , url ) ; }
private boolean check Database ( ) { SQ Lite Database check DB = null ; try { String path = DB PATH + DB NAME ; check DB = SQ Lite Database . open Database ( path , null , SQ Lite Database . OPEN READONLY ) ; } catch ( SQL Exception e ) { e . print Stack Trace ( ) ; Log . e ( STRING , STRING ) ; } if ( check DB != null ) check DB . close ( ) ; return check DB != null ? BOOL : BOOL ; }
private boolean check Database ( ) { SQ Lite Database check DB = null ; try { String path = DB PATH + DB NAME ; check DB = SQ Lite Database . open Database ( path , null , SQ Lite Database . OPEN READONLY ) ; } catch ( SQL Exception e ) { e . print Stack Trace ( ) ; Log . e ( STRING , STRING ) ; } if ( check DB != null ) check DB . close ( ) ; return check DB != null ? BOOL : BOOL ; }
public synchronized Gcm Helper add On Message Received Callback ( @ Non Null Gcm Message Listener message Received Listener ) { if ( null == message Received Callbacks ) { message Received Callbacks = new Concurrent Linked Queue < > ( ) ; } message Received Callbacks . add ( message Received Listener ) ; return this ; }
public synchronized Gcm Helper add On Message Received Callback ( @ Non Null Gcm Message Listener message Received Listener ) { if ( null == message Received Callbacks ) { message Received Callbacks = new Concurrent Linked Queue < > ( ) ; } message Received Callbacks . add ( message Received Listener ) ; return this ; }
public void append ( int key , E value ) { if ( m Size != NUM && key <= m Keys [ m Size - NUM ] ) { put ( key , value ) ; return ; } if ( m Garbage && m Size >= m Keys . length ) { gc ( ) ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n = ideal Int Array Size ( pos + NUM ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( m Keys , NUM , nkeys , NUM , m Keys . length ) ; System . arraycopy ( m Values , NUM , nvalues , NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = value ; m Size = pos + NUM ; }
public void append ( int key , E value ) { if ( m Size != NUM && key <= m Keys [ m Size - NUM ] ) { put ( key , value ) ; return ; } if ( m Garbage && m Size >= m Keys . length ) { gc ( ) ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n = ideal Int Array Size ( pos + NUM ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( m Keys , NUM , nkeys , NUM , m Keys . length ) ; System . arraycopy ( m Values , NUM , nvalues , NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = value ; m Size = pos + NUM ; }
public void append ( int key , E value ) { if ( m Size != NUM && key <= m Keys [ m Size - NUM ] ) { put ( key , value ) ; return ; } if ( m Garbage && m Size >= m Keys . length ) { gc ( ) ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n = ideal Int Array Size ( pos + NUM ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( m Keys , NUM , nkeys , NUM , m Keys . length ) ; System . arraycopy ( m Values , NUM , nvalues , NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = value ; m Size = pos + NUM ; }
public int compare To ( Object obj ) { int diff = - NUM ; if ( obj instanceof Parser Notice ) { Parser Notice p2 = ( Parser Notice ) obj ; diff = level - p2 . get Level ( ) ; if ( diff == NUM ) { diff = line - p2 . get Line ( ) ; if ( diff == NUM ) { diff = message . compare To ( p2 . get Message ( ) ) ; } } } return diff ; }
public void deregister ( Location location ) { if ( location == null ) { return ; } location . dispose ( ) ; Integer old Size = Integer . value Of ( location Hash Table . size ( ) ) ; location Hash Table . remove ( location . get Id ( ) ) ; set Dirty And Fire Property Change ( LISTLENGTH CHANGED PROPERTY , old Size , Integer . value Of ( location Hash Table . size ( ) ) ) ; }
public void deregister ( Location location ) { if ( location == null ) { return ; } location . dispose ( ) ; Integer old Size = Integer . value Of ( location Hash Table . size ( ) ) ; location Hash Table . remove ( location . get Id ( ) ) ; set Dirty And Fire Property Change ( LISTLENGTH CHANGED PROPERTY , old Size , Integer . value Of ( location Hash Table . size ( ) ) ) ; }
public void deregister ( Location location ) { if ( location == null ) { return ; } location . dispose ( ) ; Integer old Size = Integer . value Of ( location Hash Table . size ( ) ) ; location Hash Table . remove ( location . get Id ( ) ) ; set Dirty And Fire Property Change ( LISTLENGTH CHANGED PROPERTY , old Size , Integer . value Of ( location Hash Table . size ( ) ) ) ; }
public void add Core Command Tag Changer ( final Long equipment Id , final I Core Command Tag Changer command Tag Changer ) { List < I Core Command Tag Changer > changers = core Command Tag Changers . get ( equipment Id ) ; if ( changers == null ) { changers = new Array List < > ( ) ; core Command Tag Changers . put ( equipment Id , changers ) ; } changers . add ( command Tag Changer ) ; }
public void on Update From Peek To Expand ( float percentage ) { if ( ! is Visible ( ) ) return ; m Height Px = Math . round ( Math Utils . interpolate ( m Default Height Px , NUM , percentage ) ) ; m Text Opacity = Math Utils . interpolate ( NUM , NUM , percentage ) ; }
public void on Update From Peek To Expand ( float percentage ) { if ( ! is Visible ( ) ) return ; m Height Px = Math . round ( Math Utils . interpolate ( m Default Height Px , NUM , percentage ) ) ; m Text Opacity = Math Utils . interpolate ( NUM , NUM , percentage ) ; }
public static byte [ ] generate Random Bytes ( final int num Bytes ) { final Secure Random rand = new Secure Random ( ) ; final byte [ ] input = new byte [ num Bytes ] ; rand . next Bytes ( input ) ; return input ; }
public static byte [ ] generate Random Bytes ( final int num Bytes ) { final Secure Random rand = new Secure Random ( ) ; final byte [ ] input = new byte [ num Bytes ] ; rand . next Bytes ( input ) ; return input ; }
private static void shrink Heap ( Tree Set < Double DBID Pair > hotset , int k ) { Modifiable DBI Ds seenids = DBID Util . new Hash Set ( NUM * k ) ; int cnt = NUM ; for ( Iterator < Double DBID Pair > i = hotset . iterator ( ) ; i . has Next ( ) ; ) { Double DBID Pair p = i . next ( ) ; if ( cnt > k || seenids . contains ( p ) ) { i . remove ( ) ; } else { seenids . add ( p ) ; cnt ++ ; } } }
protected void process Connection Event ( Connection Event event ) { for ( Enumeration < Connection Listener > e = connection Listeners . elements ( ) ; e . has More Elements ( ) ; ) { Connection Listener l = e . next Element ( ) ; switch ( event . get Type ( ) ) { case Connection Event . CONNECTED : l . connected ( ( Connected Event ) event ) ; break ; case Connection Event . DISCONNECTED : l . disconnected ( ( Disconnected Event ) event ) ; break ; case Connection Event . PACKET RECEIVED : l . packet Received ( ( Packet Received Event ) event ) ; break ; } } }
protected void process Connection Event ( Connection Event event ) { for ( Enumeration < Connection Listener > e = connection Listeners . elements ( ) ; e . has More Elements ( ) ; ) { Connection Listener l = e . next Element ( ) ; switch ( event . get Type ( ) ) { case Connection Event . CONNECTED : l . connected ( ( Connected Event ) event ) ; break ; case Connection Event . DISCONNECTED : l . disconnected ( ( Disconnected Event ) event ) ; break ; case Connection Event . PACKET RECEIVED : l . packet Received ( ( Packet Received Event ) event ) ; break ; } } }
protected void process Connection Event ( Connection Event event ) { for ( Enumeration < Connection Listener > e = connection Listeners . elements ( ) ; e . has More Elements ( ) ; ) { Connection Listener l = e . next Element ( ) ; switch ( event . get Type ( ) ) { case Connection Event . CONNECTED : l . connected ( ( Connected Event ) event ) ; break ; case Connection Event . DISCONNECTED : l . disconnected ( ( Disconnected Event ) event ) ; break ; case Connection Event . PACKET RECEIVED : l . packet Received ( ( Packet Received Event ) event ) ; break ; } } }
void log Memory ( Bench bench , String action ) { log ( bench . get Name ( ) + STRING + action , STRING , Test Base . get Memory Used ( ) ) ; }
protected void a process Junction nns ( String name , Continuation cont ) throws Naming Exception { if ( name . equals ( STRING ) ) { Name Not Found Exception e = new Name Not Found Exception ( ) ; cont . set Error NNS ( this , name ) ; throw cont . fill In Exception ( e ) ; } try { Object target = a lookup ( name , cont ) ; if ( cont . is Continue ( ) ) cont . append Remaining Component ( STRING ) ; else { cont . set Continue NNS ( target , name , this ) ; } } catch ( Naming Exception e ) { e . append Remaining Component ( STRING ) ; throw e ; } }
protected void a process Junction nns ( String name , Continuation cont ) throws Naming Exception { if ( name . equals ( STRING ) ) { Name Not Found Exception e = new Name Not Found Exception ( ) ; cont . set Error NNS ( this , name ) ; throw cont . fill In Exception ( e ) ; } try { Object target = a lookup ( name , cont ) ; if ( cont . is Continue ( ) ) cont . append Remaining Component ( STRING ) ; else { cont . set Continue NNS ( target , name , this ) ; } } catch ( Naming Exception e ) { e . append Remaining Component ( STRING ) ; throw e ; } }
protected void a process Junction nns ( String name , Continuation cont ) throws Naming Exception { if ( name . equals ( STRING ) ) { Name Not Found Exception e = new Name Not Found Exception ( ) ; cont . set Error NNS ( this , name ) ; throw cont . fill In Exception ( e ) ; } try { Object target = a lookup ( name , cont ) ; if ( cont . is Continue ( ) ) cont . append Remaining Component ( STRING ) ; else { cont . set Continue NNS ( target , name , this ) ; } } catch ( Naming Exception e ) { e . append Remaining Component ( STRING ) ; throw e ; } }
protected void a process Junction nns ( String name , Continuation cont ) throws Naming Exception { if ( name . equals ( STRING ) ) { Name Not Found Exception e = new Name Not Found Exception ( ) ; cont . set Error NNS ( this , name ) ; throw cont . fill In Exception ( e ) ; } try { Object target = a lookup ( name , cont ) ; if ( cont . is Continue ( ) ) cont . append Remaining Component ( STRING ) ; else { cont . set Continue NNS ( target , name , this ) ; } } catch ( Naming Exception e ) { e . append Remaining Component ( STRING ) ; throw e ; } }
protected void a process Junction nns ( String name , Continuation cont ) throws Naming Exception { if ( name . equals ( STRING ) ) { Name Not Found Exception e = new Name Not Found Exception ( ) ; cont . set Error NNS ( this , name ) ; throw cont . fill In Exception ( e ) ; } try { Object target = a lookup ( name , cont ) ; if ( cont . is Continue ( ) ) cont . append Remaining Component ( STRING ) ; else { cont . set Continue NNS ( target , name , this ) ; } } catch ( Naming Exception e ) { e . append Remaining Component ( STRING ) ; throw e ; } }
protected void a process Junction nns ( String name , Continuation cont ) throws Naming Exception { if ( name . equals ( STRING ) ) { Name Not Found Exception e = new Name Not Found Exception ( ) ; cont . set Error NNS ( this , name ) ; throw cont . fill In Exception ( e ) ; } try { Object target = a lookup ( name , cont ) ; if ( cont . is Continue ( ) ) cont . append Remaining Component ( STRING ) ; else { cont . set Continue NNS ( target , name , this ) ; } } catch ( Naming Exception e ) { e . append Remaining Component ( STRING ) ; throw e ; } }
protected void a process Junction nns ( String name , Continuation cont ) throws Naming Exception { if ( name . equals ( STRING ) ) { Name Not Found Exception e = new Name Not Found Exception ( ) ; cont . set Error NNS ( this , name ) ; throw cont . fill In Exception ( e ) ; } try { Object target = a lookup ( name , cont ) ; if ( cont . is Continue ( ) ) cont . append Remaining Component ( STRING ) ; else { cont . set Continue NNS ( target , name , this ) ; } } catch ( Naming Exception e ) { e . append Remaining Component ( STRING ) ; throw e ; } }
protected void a process Junction nns ( String name , Continuation cont ) throws Naming Exception { if ( name . equals ( STRING ) ) { Name Not Found Exception e = new Name Not Found Exception ( ) ; cont . set Error NNS ( this , name ) ; throw cont . fill In Exception ( e ) ; } try { Object target = a lookup ( name , cont ) ; if ( cont . is Continue ( ) ) cont . append Remaining Component ( STRING ) ; else { cont . set Continue NNS ( target , name , this ) ; } } catch ( Naming Exception e ) { e . append Remaining Component ( STRING ) ; throw e ; } }
protected void a process Junction nns ( String name , Continuation cont ) throws Naming Exception { if ( name . equals ( STRING ) ) { Name Not Found Exception e = new Name Not Found Exception ( ) ; cont . set Error NNS ( this , name ) ; throw cont . fill In Exception ( e ) ; } try { Object target = a lookup ( name , cont ) ; if ( cont . is Continue ( ) ) cont . append Remaining Component ( STRING ) ; else { cont . set Continue NNS ( target , name , this ) ; } } catch ( Naming Exception e ) { e . append Remaining Component ( STRING ) ; throw e ; } }
protected void a process Junction nns ( String name , Continuation cont ) throws Naming Exception { if ( name . equals ( STRING ) ) { Name Not Found Exception e = new Name Not Found Exception ( ) ; cont . set Error NNS ( this , name ) ; throw cont . fill In Exception ( e ) ; } try { Object target = a lookup ( name , cont ) ; if ( cont . is Continue ( ) ) cont . append Remaining Component ( STRING ) ; else { cont . set Continue NNS ( target , name , this ) ; } } catch ( Naming Exception e ) { e . append Remaining Component ( STRING ) ; throw e ; } }
protected void a process Junction nns ( String name , Continuation cont ) throws Naming Exception { if ( name . equals ( STRING ) ) { Name Not Found Exception e = new Name Not Found Exception ( ) ; cont . set Error NNS ( this , name ) ; throw cont . fill In Exception ( e ) ; } try { Object target = a lookup ( name , cont ) ; if ( cont . is Continue ( ) ) cont . append Remaining Component ( STRING ) ; else { cont . set Continue NNS ( target , name , this ) ; } } catch ( Naming Exception e ) { e . append Remaining Component ( STRING ) ; throw e ; } }
protected void a process Junction nns ( String name , Continuation cont ) throws Naming Exception { if ( name . equals ( STRING ) ) { Name Not Found Exception e = new Name Not Found Exception ( ) ; cont . set Error NNS ( this , name ) ; throw cont . fill In Exception ( e ) ; } try { Object target = a lookup ( name , cont ) ; if ( cont . is Continue ( ) ) cont . append Remaining Component ( STRING ) ; else { cont . set Continue NNS ( target , name , this ) ; } } catch ( Naming Exception e ) { e . append Remaining Component ( STRING ) ; throw e ; } }
protected void a process Junction nns ( String name , Continuation cont ) throws Naming Exception { if ( name . equals ( STRING ) ) { Name Not Found Exception e = new Name Not Found Exception ( ) ; cont . set Error NNS ( this , name ) ; throw cont . fill In Exception ( e ) ; } try { Object target = a lookup ( name , cont ) ; if ( cont . is Continue ( ) ) cont . append Remaining Component ( STRING ) ; else { cont . set Continue NNS ( target , name , this ) ; } } catch ( Naming Exception e ) { e . append Remaining Component ( STRING ) ; throw e ; } }
protected void a process Junction nns ( String name , Continuation cont ) throws Naming Exception { if ( name . equals ( STRING ) ) { Name Not Found Exception e = new Name Not Found Exception ( ) ; cont . set Error NNS ( this , name ) ; throw cont . fill In Exception ( e ) ; } try { Object target = a lookup ( name , cont ) ; if ( cont . is Continue ( ) ) cont . append Remaining Component ( STRING ) ; else { cont . set Continue NNS ( target , name , this ) ; } } catch ( Naming Exception e ) { e . append Remaining Component ( STRING ) ; throw e ; } }
private static List < Comment > order Comments ( List < Comment > comments ) { Map < String , List < Comment > > parent Map = new Hash Map < > ( ) ; List < Comment > root Comments = new Array List < > ( ) ; for ( Comment c : comments ) { String parent Uuid = c . parent Uuid ; List < Comment > l = parent Map . get ( parent Uuid ) ; if ( l == null ) { l = new Array List < > ( ) ; parent Map . put ( parent Uuid , l ) ; } l . add ( c ) ; if ( parent Uuid == null ) { root Comments . add ( c ) ; } } List < Comment > result = new Array List < > ( ) ; add Children ( parent Map , root Comments , result ) ; return result ; }
private static List < Comment > order Comments ( List < Comment > comments ) { Map < String , List < Comment > > parent Map = new Hash Map < > ( ) ; List < Comment > root Comments = new Array List < > ( ) ; for ( Comment c : comments ) { String parent Uuid = c . parent Uuid ; List < Comment > l = parent Map . get ( parent Uuid ) ; if ( l == null ) { l = new Array List < > ( ) ; parent Map . put ( parent Uuid , l ) ; } l . add ( c ) ; if ( parent Uuid == null ) { root Comments . add ( c ) ; } } List < Comment > result = new Array List < > ( ) ; add Children ( parent Map , root Comments , result ) ; return result ; }
private static List < Comment > order Comments ( List < Comment > comments ) { Map < String , List < Comment > > parent Map = new Hash Map < > ( ) ; List < Comment > root Comments = new Array List < > ( ) ; for ( Comment c : comments ) { String parent Uuid = c . parent Uuid ; List < Comment > l = parent Map . get ( parent Uuid ) ; if ( l == null ) { l = new Array List < > ( ) ; parent Map . put ( parent Uuid , l ) ; } l . add ( c ) ; if ( parent Uuid == null ) { root Comments . add ( c ) ; } } List < Comment > result = new Array List < > ( ) ; add Children ( parent Map , root Comments , result ) ; return result ; }
private static List < Comment > order Comments ( List < Comment > comments ) { Map < String , List < Comment > > parent Map = new Hash Map < > ( ) ; List < Comment > root Comments = new Array List < > ( ) ; for ( Comment c : comments ) { String parent Uuid = c . parent Uuid ; List < Comment > l = parent Map . get ( parent Uuid ) ; if ( l == null ) { l = new Array List < > ( ) ; parent Map . put ( parent Uuid , l ) ; } l . add ( c ) ; if ( parent Uuid == null ) { root Comments . add ( c ) ; } } List < Comment > result = new Array List < > ( ) ; add Children ( parent Map , root Comments , result ) ; return result ; }
public void replace Attribute Value ( String attr Name , String old Value , String new Value ) throws SMS Exception , SSO Exception { validate Service Config Impl ( ) ; Map attributes = get Attributes ( ) ; Set current Values = ( Set ) attributes . get ( attr Name ) ; if ( current Values != null && ! current Values . contains ( old Value ) ) { throw ( new SMS Exception ( STRING , STRING ) ) ; } Set new Vals = new Hash Set ( ) ; Set old Vals = ( Set ) attributes . get ( attr Name ) ; if ( old Vals != null ) { new Vals . add All ( old Vals ) ; new Vals . remove ( old Value ) ; } new Vals . add ( new Value ) ; ss . validate Attr Values ( token , attr Name , new Vals , BOOL , sc . get Organization Name ( ) ) ; SMS Entry e = sc . get SMS Entry ( ) ; SMS Utils . replace Attribute Value ( e , attr Name , old Value , new Value , ss . get Searchable Attribute Names ( ) ) ; save SMS Entry ( e ) ; }
public void replace Attribute Value ( String attr Name , String old Value , String new Value ) throws SMS Exception , SSO Exception { validate Service Config Impl ( ) ; Map attributes = get Attributes ( ) ; Set current Values = ( Set ) attributes . get ( attr Name ) ; if ( current Values != null && ! current Values . contains ( old Value ) ) { throw ( new SMS Exception ( STRING , STRING ) ) ; } Set new Vals = new Hash Set ( ) ; Set old Vals = ( Set ) attributes . get ( attr Name ) ; if ( old Vals != null ) { new Vals . add All ( old Vals ) ; new Vals . remove ( old Value ) ; } new Vals . add ( new Value ) ; ss . validate Attr Values ( token , attr Name , new Vals , BOOL , sc . get Organization Name ( ) ) ; SMS Entry e = sc . get SMS Entry ( ) ; SMS Utils . replace Attribute Value ( e , attr Name , old Value , new Value , ss . get Searchable Attribute Names ( ) ) ; save SMS Entry ( e ) ; }
public static String [ ] array Split ( String s , char separator Char , boolean trim ) { if ( s == null ) { return null ; } int length = s . length ( ) ; if ( length == NUM ) { return new String [ NUM ] ; } Array List < String > list = New . array List ( ) ; String Builder buff = new String Builder ( length ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = s . char At ( i ) ; if ( c == separator Char ) { String e = buff . to String ( ) ; list . add ( trim ? e . trim ( ) : e ) ; buff . set Length ( NUM ) ; } else if ( c == STRING && i < length - NUM ) { buff . append ( s . char At ( ++ i ) ) ; } else { buff . append ( c ) ; } } String e = buff . to String ( ) ; list . add ( trim ? e . trim ( ) : e ) ; String [ ] array = new String [ list . size ( ) ] ; list . to Array ( array ) ; return array ; }
public static String [ ] array Split ( String s , char separator Char , boolean trim ) { if ( s == null ) { return null ; } int length = s . length ( ) ; if ( length == NUM ) { return new String [ NUM ] ; } Array List < String > list = New . array List ( ) ; String Builder buff = new String Builder ( length ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = s . char At ( i ) ; if ( c == separator Char ) { String e = buff . to String ( ) ; list . add ( trim ? e . trim ( ) : e ) ; buff . set Length ( NUM ) ; } else if ( c == STRING && i < length - NUM ) { buff . append ( s . char At ( ++ i ) ) ; } else { buff . append ( c ) ; } } String e = buff . to String ( ) ; list . add ( trim ? e . trim ( ) : e ) ; String [ ] array = new String [ list . size ( ) ] ; list . to Array ( array ) ; return array ; }
public static String [ ] array Split ( String s , char separator Char , boolean trim ) { if ( s == null ) { return null ; } int length = s . length ( ) ; if ( length == NUM ) { return new String [ NUM ] ; } Array List < String > list = New . array List ( ) ; String Builder buff = new String Builder ( length ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = s . char At ( i ) ; if ( c == separator Char ) { String e = buff . to String ( ) ; list . add ( trim ? e . trim ( ) : e ) ; buff . set Length ( NUM ) ; } else if ( c == STRING && i < length - NUM ) { buff . append ( s . char At ( ++ i ) ) ; } else { buff . append ( c ) ; } } String e = buff . to String ( ) ; list . add ( trim ? e . trim ( ) : e ) ; String [ ] array = new String [ list . size ( ) ] ; list . to Array ( array ) ; return array ; }
private int determine Final Horizontal Location ( ) { if ( m Gesture State == GESTURE FLINGING ) { float ms Required = calculate Ms Required To Fling Off Screen ( ) ; if ( ms Required > MS DISMISS FLING THRESHOLD ) return DRAGGED CANCEL ; } else if ( m Gesture State == GESTURE SCROLLING ) { float dismiss Percentage = DISMISS SWIPE THRESHOLD ; float dismiss Threshold = get Width ( ) * dismiss Percentage ; if ( Math . abs ( get Translation X ( ) ) < dismiss Threshold ) return DRAGGED CANCEL ; } return m Drag Direction ; }
private int determine Final Horizontal Location ( ) { if ( m Gesture State == GESTURE FLINGING ) { float ms Required = calculate Ms Required To Fling Off Screen ( ) ; if ( ms Required > MS DISMISS FLING THRESHOLD ) return DRAGGED CANCEL ; } else if ( m Gesture State == GESTURE SCROLLING ) { float dismiss Percentage = DISMISS SWIPE THRESHOLD ; float dismiss Threshold = get Width ( ) * dismiss Percentage ; if ( Math . abs ( get Translation X ( ) ) < dismiss Threshold ) return DRAGGED CANCEL ; } return m Drag Direction ; }
private int determine Final Horizontal Location ( ) { if ( m Gesture State == GESTURE FLINGING ) { float ms Required = calculate Ms Required To Fling Off Screen ( ) ; if ( ms Required > MS DISMISS FLING THRESHOLD ) return DRAGGED CANCEL ; } else if ( m Gesture State == GESTURE SCROLLING ) { float dismiss Percentage = DISMISS SWIPE THRESHOLD ; float dismiss Threshold = get Width ( ) * dismiss Percentage ; if ( Math . abs ( get Translation X ( ) ) < dismiss Threshold ) return DRAGGED CANCEL ; } return m Drag Direction ; }
private int determine Final Horizontal Location ( ) { if ( m Gesture State == GESTURE FLINGING ) { float ms Required = calculate Ms Required To Fling Off Screen ( ) ; if ( ms Required > MS DISMISS FLING THRESHOLD ) return DRAGGED CANCEL ; } else if ( m Gesture State == GESTURE SCROLLING ) { float dismiss Percentage = DISMISS SWIPE THRESHOLD ; float dismiss Threshold = get Width ( ) * dismiss Percentage ; if ( Math . abs ( get Translation X ( ) ) < dismiss Threshold ) return DRAGGED CANCEL ; } return m Drag Direction ; }
private int determine Final Horizontal Location ( ) { if ( m Gesture State == GESTURE FLINGING ) { float ms Required = calculate Ms Required To Fling Off Screen ( ) ; if ( ms Required > MS DISMISS FLING THRESHOLD ) return DRAGGED CANCEL ; } else if ( m Gesture State == GESTURE SCROLLING ) { float dismiss Percentage = DISMISS SWIPE THRESHOLD ; float dismiss Threshold = get Width ( ) * dismiss Percentage ; if ( Math . abs ( get Translation X ( ) ) < dismiss Threshold ) return DRAGGED CANCEL ; } return m Drag Direction ; }
private int determine Final Horizontal Location ( ) { if ( m Gesture State == GESTURE FLINGING ) { float ms Required = calculate Ms Required To Fling Off Screen ( ) ; if ( ms Required > MS DISMISS FLING THRESHOLD ) return DRAGGED CANCEL ; } else if ( m Gesture State == GESTURE SCROLLING ) { float dismiss Percentage = DISMISS SWIPE THRESHOLD ; float dismiss Threshold = get Width ( ) * dismiss Percentage ; if ( Math . abs ( get Translation X ( ) ) < dismiss Threshold ) return DRAGGED CANCEL ; } return m Drag Direction ; }
private int determine Final Horizontal Location ( ) { if ( m Gesture State == GESTURE FLINGING ) { float ms Required = calculate Ms Required To Fling Off Screen ( ) ; if ( ms Required > MS DISMISS FLING THRESHOLD ) return DRAGGED CANCEL ; } else if ( m Gesture State == GESTURE SCROLLING ) { float dismiss Percentage = DISMISS SWIPE THRESHOLD ; float dismiss Threshold = get Width ( ) * dismiss Percentage ; if ( Math . abs ( get Translation X ( ) ) < dismiss Threshold ) return DRAGGED CANCEL ; } return m Drag Direction ; }
@ Override public int previous ( ) { Character Iterator text = get Text ( ) ; if ( current ( ) == text . get Begin Index ( ) ) { return Break Iterator . DONE ; } int start = current ( ) ; int last Result = cached Last Known Break ; if ( last Result >= start || last Result <= Break Iterator . DONE ) { get Previous ( ) ; last Result = handle Previous ( ) ; } else { text . set Index ( last Result ) ; } int result = last Result ; while ( result != Break Iterator . DONE && result < start ) { last Result = result ; result = handle Next ( ) ; } text . set Index ( last Result ) ; cached Last Known Break = last Result ; return last Result ; }
@ Override public int previous ( ) { Character Iterator text = get Text ( ) ; if ( current ( ) == text . get Begin Index ( ) ) { return Break Iterator . DONE ; } int start = current ( ) ; int last Result = cached Last Known Break ; if ( last Result >= start || last Result <= Break Iterator . DONE ) { get Previous ( ) ; last Result = handle Previous ( ) ; } else { text . set Index ( last Result ) ; } int result = last Result ; while ( result != Break Iterator . DONE && result < start ) { last Result = result ; result = handle Next ( ) ; } text . set Index ( last Result ) ; cached Last Known Break = last Result ; return last Result ; }
@ Override public int previous ( ) { Character Iterator text = get Text ( ) ; if ( current ( ) == text . get Begin Index ( ) ) { return Break Iterator . DONE ; } int start = current ( ) ; int last Result = cached Last Known Break ; if ( last Result >= start || last Result <= Break Iterator . DONE ) { get Previous ( ) ; last Result = handle Previous ( ) ; } else { text . set Index ( last Result ) ; } int result = last Result ; while ( result != Break Iterator . DONE && result < start ) { last Result = result ; result = handle Next ( ) ; } text . set Index ( last Result ) ; cached Last Known Break = last Result ; return last Result ; }
@ Suppress Warnings ( STRING ) public T read ( File file ) { Preconditions . check Not Null ( file ) ; try ( Input Stream stream = new File Input Stream ( file ) ) { return ( T ) yaml Parser . load ( stream ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING + file . get Name ( ) , e ) ; } }
public static void put Float LE ( long addr , float val ) { int int Val = Float . float To Int Bits ( val ) ; if ( UNALIGNED ) UNSAFE . put Int ( addr , Integer . reverse Bytes ( int Val ) ) ; else put Int By Byte ( addr , int Val , BOOL ) ; }
public static void put Float LE ( long addr , float val ) { int int Val = Float . float To Int Bits ( val ) ; if ( UNALIGNED ) UNSAFE . put Int ( addr , Integer . reverse Bytes ( int Val ) ) ; else put Int By Byte ( addr , int Val , BOOL ) ; }
public static void put Float LE ( long addr , float val ) { int int Val = Float . float To Int Bits ( val ) ; if ( UNALIGNED ) UNSAFE . put Int ( addr , Integer . reverse Bytes ( int Val ) ) ; else put Int By Byte ( addr , int Val , BOOL ) ; }
public boolean spans ( String other ) { return spans ( other , BOOL ) ; }
public boolean spans ( String other ) { return spans ( other , BOOL ) ; }
@ Suppress Warnings ( STRING ) public static < T > Type Serializer < T > deserialize ( byte [ ] bytes ) throws IO Exception { Byte Array Input Stream bis = new Byte Array Input Stream ( bytes ) ; Object Input in = null ; try { in = new Object Input Stream ( bis ) ; return ( Type Serializer < T > ) in . read Object ( ) ; } catch ( Class Not Found Exception e ) { throw new IO Exception ( STRING ) ; } finally { try { bis . close ( ) ; } catch ( IO Exception ex ) { } try { if ( in != null ) { in . close ( ) ; } } catch ( IO Exception ex ) { } } }
public String generate Short Upgrade Report ( SSO Token admin Token , boolean html ) { String delimiter = html ? HTML BR : TXT LF ; String Builder report = new String Builder ( ) ; for ( Upgrade Step upgrade Step : upgrade Steps ) { report . append ( upgrade Step . get Short Report ( delimiter ) ) ; } return report . to String ( ) ; }
@ Override public void apply ( Nexus Stream Parser np ) throws Exception { np . match Ignore Case ( STRING ) ; String shape Name = np . get Word Matches Ignoring Case ( STRING ) ; np . match Ignore Case ( STRING ) ; byte shape ; if ( shape Name . equals Ignore Case ( STRING ) ) shape = Edge View . ARC LINE EDGE ; else if ( shape Name . equals Ignore Case ( STRING ) ) shape = Edge View . STRAIGHT EDGE ; else if ( shape Name . equals Ignore Case ( STRING ) ) shape = Edge View . QUAD EDGE ; else shape = NUM ; if ( get Viewer ( ) instanceof Graph View ) { boolean changed = BOOL ; Graph View viewer = ( Graph View ) get Viewer ( ) ; for ( Edge e : viewer . get Selected Edges ( ) ) { viewer . set Shape ( e , shape ) ; changed = BOOL ; } if ( changed ) { viewer . repaint ( ) ; } } }
@ Override synchronized public final boolean is Registered ( ) { return ! key List . is Empty ( ) ; }
public static double calculate Test Statistic ( double [ ] sample 1 , double [ ] sample 2 ) { double maximum = NUM ; int index 1 = NUM , index 2 = NUM ; double cdf 1 = NUM , cdf 2 = NUM ; while ( index 1 < sample 1 . length && index 2 < sample 2 . length ) { final double x1 = sample 1 [ index 1 ] , x2 = sample 2 [ index 2 ] ; if ( x1 <= x2 ) { index 1 ++ ; while ( index 1 < sample 1 . length && sample 1 [ index 1 ] == x1 ) { index 1 ++ ; } cdf 1 = ( ( double ) index 1 + NUM ) / ( sample 1 . length + NUM ) ; } if ( x1 >= x2 ) { index 2 ++ ; while ( index 2 < sample 2 . length && sample 2 [ index 2 ] == x2 ) { index 2 ++ ; } cdf 2 = ( ( double ) index 2 + NUM ) / ( sample 2 . length + NUM ) ; } maximum = Math . max ( maximum , Math . abs ( cdf 1 - cdf 2 ) ) ; } return maximum ; }
@ Override public void add Test Set Listener ( Test Set Listener tsl ) { m test Set Listeners . add Element ( tsl ) ; if ( m format != null ) { Test Set Event e = new Test Set Event ( this , m format ) ; tsl . accept Test Set ( e ) ; } }
public synchronized I Audio Provider remove ( int index ) { return providers . remove ( index ) ; }
public synchronized I Audio Provider remove ( int index ) { return providers . remove ( index ) ; }
public int size ( ) { return attrs . size ( ) ; }
void reset ( ) { System . arraycopy ( iv , NUM , register , NUM , block Size ) ; }
void reset ( ) { System . arraycopy ( iv , NUM , register , NUM , block Size ) ; }
void reset ( ) { System . arraycopy ( iv , NUM , register , NUM , block Size ) ; }
public static Endpoint Entry lookup ( Endpoint ep ) { synchronized ( endpoint Table ) { Endpoint Entry entry = endpoint Table . get ( ep ) ; if ( entry == null ) { entry = new Endpoint Entry ( ep ) ; endpoint Table . put ( ep , entry ) ; if ( gc Latency Request == null ) { gc Latency Request = GC . request Latency ( gc Interval ) ; } } return entry ; } }
@ Suppress Warnings ( STRING ) public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
@ Suppress Warnings ( STRING ) public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
@ Suppress Warnings ( STRING ) public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
@ Suppress Warnings ( STRING ) public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
@ Suppress Warnings ( STRING ) public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
@ Suppress Warnings ( STRING ) public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
public Spatial Index ( String shp Filename ) throws IO Exception { this . shp File Name = shp Filename ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + shp Filename + STRING ) ; } }
public static long to Address ( Object obj ) { Object [ ] array = new Object [ ] { obj } ; long base Offset = unsafe . array Base Offset ( Object [ ] . class ) ; return normalize ( unsafe . get Int ( array , base Offset ) ) ; }
public static long to Address ( Object obj ) { Object [ ] array = new Object [ ] { obj } ; long base Offset = unsafe . array Base Offset ( Object [ ] . class ) ; return normalize ( unsafe . get Int ( array , base Offset ) ) ; }
protected void process Updates ( Queue < Device Update > updates ) { if ( updates == null ) return ; Device Update update = null ; while ( null != ( update = updates . poll ( ) ) ) { if ( logger . is Trace Enabled ( ) ) { logger . trace ( STRING , update ) ; } if ( update . change == Device Update . Change . DELETE ) device Sync Manager . remove Device ( update . device ) ; else device Sync Manager . store Device ( update . device ) ; List < I Device Listener > listeners = device Listeners . get Ordered Listeners ( ) ; notify Listeners ( listeners , update ) ; } }
public static final void remove Selection ( Spannable text ) { text . remove Span ( SELECTION START ) ; text . remove Span ( SELECTION END ) ; }
public Search Source Builder query ( String query String ) { return query ( query String . get Bytes ( Charsets . UTF 8 ) ) ; }
public void insert ( int elem ) { heap = Arrays . copy Of ( heap , size + NUM ) ; int i = size ; int parent Index = ( int ) Math . floor ( ( i - NUM ) / NUM ) ; while ( i > NUM && elem > heap [ parent Index ] ) { heap [ i ] = heap [ parent Index ] ; i = parent Index ; parent Index = ( int ) Math . floor ( ( i - NUM ) / NUM ) ; } heap [ i ] = elem ; size ++ ; }
private void add Connections ( Collection < Connection > connections ) throws Guacamole Exception { for ( Connection connection : connections ) { API Connection Group parent = retrieved Groups . get ( connection . get Parent Identifier ( ) ) ; if ( parent != null ) { Collection < API Connection > children = parent . get Child Connections ( ) ; if ( children == null ) { children = new Array List < API Connection > ( ) ; parent . set Child Connections ( children ) ; } API Connection api Connection = new API Connection ( connection ) ; retrieved Connections . put ( connection . get Identifier ( ) , api Connection ) ; children . add ( api Connection ) ; } else logger . debug ( STRING , connection . get Identifier ( ) , connection . get Parent Identifier ( ) ) ; } }
public void select Object ( Object element ) { if ( control Shown ) { int index = objects In Combo . index Of ( element ) ; if ( index != - NUM ) { object Selection . select ( index ) ; } } }
protected static boolean has Encoded Tag Value ( Object obj , int tag Value ) { return ( obj instanceof byte [ ] ) && ( ( byte [ ] ) obj ) [ NUM ] == tag Value ; }
protected static boolean has Encoded Tag Value ( Object obj , int tag Value ) { return ( obj instanceof byte [ ] ) && ( ( byte [ ] ) obj ) [ NUM ] == tag Value ; }
private boolean search Page ( final int page , final int current Key , final Observable List < String > result List Model ) throws Exception { final Pdf Page Data current Page Data = decode pdf . get Pdf Page Data ( ) ; final int x1 = current Page Data . get Media Box X ( page ) ; final int x2 = current Page Data . get Media Box Width ( page ) + x1 ; final int y2 = current Page Data . get Media Box Y ( page ) ; final int y1 = current Page Data . get Media Box Height ( page ) + y2 ; return search Page ( page , x1 , y1 , x2 , y2 , current Key , result List Model ) ; }
public void test multiple Resource Locking resources 3 locktries 3 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . set Property ( Test Options . NTHREADS , STRING ) ; properties . set Property ( Test Options . NTASKS , STRING ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCK TRIES , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; do Comparison Test ( properties ) ; }
public void test multiple Resource Locking resources 3 locktries 3 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . set Property ( Test Options . NTHREADS , STRING ) ; properties . set Property ( Test Options . NTASKS , STRING ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCK TRIES , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; do Comparison Test ( properties ) ; }
public void test multiple Resource Locking resources 3 locktries 3 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . set Property ( Test Options . NTHREADS , STRING ) ; properties . set Property ( Test Options . NTASKS , STRING ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCK TRIES , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; do Comparison Test ( properties ) ; }
public void test multiple Resource Locking resources 3 locktries 3 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . set Property ( Test Options . NTHREADS , STRING ) ; properties . set Property ( Test Options . NTASKS , STRING ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCK TRIES , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; do Comparison Test ( properties ) ; }
public void test multiple Resource Locking resources 3 locktries 3 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . set Property ( Test Options . NTHREADS , STRING ) ; properties . set Property ( Test Options . NTASKS , STRING ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCK TRIES , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; do Comparison Test ( properties ) ; }
public boolean is Signature Valid ( String signature , String data ) { if ( ! signature . is Empty ( ) ) { RSA Tool tool = RSA Tool Factory . get RSA Tool ( ) ; RSA Key the Public Key = new RSA Key Impl ( the Certificate . get Public Key ( ) ) ; try { String hash = Digest Utils . sha 256 Hex ( data ) ; return tool . verify With Key ( String Utils . get Bytes Utf 8 ( hash ) , Base 64 . decode ( signature ) , the Public Key ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; } } return BOOL ; }
public Sort ( ) { this ( new String [ NUM ] , new boolean [ NUM ] ) ; }
public final void add Pane ( final Options Pane pane ) { MAIN PANEL . add ( pane . get Container ( ) , pane . get Name ( ) ) ; OPTIONS PANE LIST . add ( pane ) ; }
private boolean match Atom ( Content Type accepted Content Type ) { String atom Type = get Attribute ( STRING ) ; String accepted Atom Type = accepted Content Type . get Attribute ( STRING ) ; return atom Type == null || accepted Atom Type == null || atom Type . equals ( accepted Atom Type ) ; }
private boolean match Atom ( Content Type accepted Content Type ) { String atom Type = get Attribute ( STRING ) ; String accepted Atom Type = accepted Content Type . get Attribute ( STRING ) ; return atom Type == null || accepted Atom Type == null || atom Type . equals ( accepted Atom Type ) ; }
private boolean match Atom ( Content Type accepted Content Type ) { String atom Type = get Attribute ( STRING ) ; String accepted Atom Type = accepted Content Type . get Attribute ( STRING ) ; return atom Type == null || accepted Atom Type == null || atom Type . equals ( accepted Atom Type ) ; }
public Composer arc ( long anim Duration , float x , float y , float angle , Ease ease ) { Anim Parameter before Param = m Tween Parameter List . size ( ) > NUM ? m Tween Parameter List . get ( m Tween Parameter List . size ( ) - NUM ) : m Initial Param ; if ( angle < NUM && angle > - NUM ) { return to ( anim Duration , x , y , before Param . alpha , before Param . scale X , before Param . scale Y , before Param . rotation , ease ) ; } return arc ( anim Duration , x , y , angle , before Param . alpha , before Param . scale X , before Param . scale Y , before Param . rotation , ease ) ; }
public Composer arc ( long anim Duration , float x , float y , float angle , Ease ease ) { Anim Parameter before Param = m Tween Parameter List . size ( ) > NUM ? m Tween Parameter List . get ( m Tween Parameter List . size ( ) - NUM ) : m Initial Param ; if ( angle < NUM && angle > - NUM ) { return to ( anim Duration , x , y , before Param . alpha , before Param . scale X , before Param . scale Y , before Param . rotation , ease ) ; } return arc ( anim Duration , x , y , angle , before Param . alpha , before Param . scale X , before Param . scale Y , before Param . rotation , ease ) ; }
public static XML Gregorian Calendar parse Calendar ( String s ) { return dt Factory . new XML Gregorian Calendar ( s ) ; }
public static XML Gregorian Calendar parse Calendar ( String s ) { return dt Factory . new XML Gregorian Calendar ( s ) ; }
@ Deprecated public static Attribute Description create ( final String attribute Name , final Attribute Type attribute Type , final String ... options ) { Reject . if Null ( options ) ; return create ( attribute Name , attribute Type , Arrays . as List ( options ) ) ; }
public void annotation Added ( Annotation annotation ) { added Annotations . add ( annotation ) ; }
public void annotation Added ( Annotation annotation ) { added Annotations . add ( annotation ) ; }
public void annotation Added ( Annotation annotation ) { added Annotations . add ( annotation ) ; }
long resize Lun ( long size , boolean force ) { Na Element elem = new Na Element ( STRING ) ; elem . add New Child ( STRING , Boolean . to String ( force ) ) ; elem . add New Child ( STRING , path ) ; elem . add New Child ( STRING , Long . to String ( size ) ) ; Na Element result = null ; try { result = server . invoke Elem ( elem ) ; return result . get Child Long Value ( STRING , - NUM ) ; } catch ( Exception e ) { String msg = STRING + path ; log . error ( msg , e ) ; throw new Net App Exception ( msg , e ) ; } }
private boolean is Ready To Be Executed Locked ( Job Status job ) { final boolean job Ready = job . is Ready ( ) ; final boolean job Pending = m Pending Jobs . contains ( job ) ; final boolean job Active = is Currently Active Locked ( job ) ; final boolean user Running = m Started Users . contains ( job . get User Id ( ) ) ; return user Running && job Ready && ! job Pending && ! job Active ; }
private boolean is Ready To Be Executed Locked ( Job Status job ) { final boolean job Ready = job . is Ready ( ) ; final boolean job Pending = m Pending Jobs . contains ( job ) ; final boolean job Active = is Currently Active Locked ( job ) ; final boolean user Running = m Started Users . contains ( job . get User Id ( ) ) ; return user Running && job Ready && ! job Pending && ! job Active ; }
private boolean is Ready To Be Executed Locked ( Job Status job ) { final boolean job Ready = job . is Ready ( ) ; final boolean job Pending = m Pending Jobs . contains ( job ) ; final boolean job Active = is Currently Active Locked ( job ) ; final boolean user Running = m Started Users . contains ( job . get User Id ( ) ) ; return user Running && job Ready && ! job Pending && ! job Active ; }
private boolean is Ready To Be Executed Locked ( Job Status job ) { final boolean job Ready = job . is Ready ( ) ; final boolean job Pending = m Pending Jobs . contains ( job ) ; final boolean job Active = is Currently Active Locked ( job ) ; final boolean user Running = m Started Users . contains ( job . get User Id ( ) ) ; return user Running && job Ready && ! job Pending && ! job Active ; }
private boolean is Ready To Be Executed Locked ( Job Status job ) { final boolean job Ready = job . is Ready ( ) ; final boolean job Pending = m Pending Jobs . contains ( job ) ; final boolean job Active = is Currently Active Locked ( job ) ; final boolean user Running = m Started Users . contains ( job . get User Id ( ) ) ; return user Running && job Ready && ! job Pending && ! job Active ; }
public void enqueue ( Terminating Runnable r ) { synchronized ( queue ) { queue . add ( r ) ; queue . notify All ( ) ; } }
public static double mean ( final List < Double > list ) { double sum = NUM ; for ( Double number : list ) { sum += number ; } return sum / list . size ( ) ; }
private Poi save Poi No Transaction ( Poi poi ) { List < Poi Tag > poi Tags To Remove = poi Tag Dao . query By Poi Id ( poi . get Id ( ) ) ; poi Tags To Remove . remove All ( poi . get Tags ( ) ) ; for ( Poi Tag poi Tag : poi Tags To Remove ) { poi Tag Dao . delete ( poi Tag ) ; } List < Poi Node Ref > poi Node Refs To Remove = poi Node Ref Dao . query By Poi Id ( poi . get Id ( ) ) ; poi Node Refs To Remove . remove All ( poi . get Node Refs ( ) ) ; for ( Poi Node Ref poi Node Ref : poi Node Refs To Remove ) { poi Node Ref Dao . delete ( poi Node Ref ) ; } poi Dao . create Or Update ( poi ) ; if ( poi . get Tags ( ) != null ) { for ( Poi Tag poi Tag : poi . get Tags ( ) ) { poi Tag . set Poi ( poi ) ; poi Tag Dao . create Or Update ( poi Tag ) ; } } if ( poi . get Node Refs ( ) != null ) { for ( Poi Node Ref poi Node Ref : poi . get Node Refs ( ) ) { poi Node Ref . set Poi ( poi ) ; poi Node Ref Dao . create Or Update ( poi Node Ref ) ; } } return poi ; }
private Poi save Poi No Transaction ( Poi poi ) { List < Poi Tag > poi Tags To Remove = poi Tag Dao . query By Poi Id ( poi . get Id ( ) ) ; poi Tags To Remove . remove All ( poi . get Tags ( ) ) ; for ( Poi Tag poi Tag : poi Tags To Remove ) { poi Tag Dao . delete ( poi Tag ) ; } List < Poi Node Ref > poi Node Refs To Remove = poi Node Ref Dao . query By Poi Id ( poi . get Id ( ) ) ; poi Node Refs To Remove . remove All ( poi . get Node Refs ( ) ) ; for ( Poi Node Ref poi Node Ref : poi Node Refs To Remove ) { poi Node Ref Dao . delete ( poi Node Ref ) ; } poi Dao . create Or Update ( poi ) ; if ( poi . get Tags ( ) != null ) { for ( Poi Tag poi Tag : poi . get Tags ( ) ) { poi Tag . set Poi ( poi ) ; poi Tag Dao . create Or Update ( poi Tag ) ; } } if ( poi . get Node Refs ( ) != null ) { for ( Poi Node Ref poi Node Ref : poi . get Node Refs ( ) ) { poi Node Ref . set Poi ( poi ) ; poi Node Ref Dao . create Or Update ( poi Node Ref ) ; } } return poi ; }
private Poi save Poi No Transaction ( Poi poi ) { List < Poi Tag > poi Tags To Remove = poi Tag Dao . query By Poi Id ( poi . get Id ( ) ) ; poi Tags To Remove . remove All ( poi . get Tags ( ) ) ; for ( Poi Tag poi Tag : poi Tags To Remove ) { poi Tag Dao . delete ( poi Tag ) ; } List < Poi Node Ref > poi Node Refs To Remove = poi Node Ref Dao . query By Poi Id ( poi . get Id ( ) ) ; poi Node Refs To Remove . remove All ( poi . get Node Refs ( ) ) ; for ( Poi Node Ref poi Node Ref : poi Node Refs To Remove ) { poi Node Ref Dao . delete ( poi Node Ref ) ; } poi Dao . create Or Update ( poi ) ; if ( poi . get Tags ( ) != null ) { for ( Poi Tag poi Tag : poi . get Tags ( ) ) { poi Tag . set Poi ( poi ) ; poi Tag Dao . create Or Update ( poi Tag ) ; } } if ( poi . get Node Refs ( ) != null ) { for ( Poi Node Ref poi Node Ref : poi . get Node Refs ( ) ) { poi Node Ref . set Poi ( poi ) ; poi Node Ref Dao . create Or Update ( poi Node Ref ) ; } } return poi ; }
private Poi save Poi No Transaction ( Poi poi ) { List < Poi Tag > poi Tags To Remove = poi Tag Dao . query By Poi Id ( poi . get Id ( ) ) ; poi Tags To Remove . remove All ( poi . get Tags ( ) ) ; for ( Poi Tag poi Tag : poi Tags To Remove ) { poi Tag Dao . delete ( poi Tag ) ; } List < Poi Node Ref > poi Node Refs To Remove = poi Node Ref Dao . query By Poi Id ( poi . get Id ( ) ) ; poi Node Refs To Remove . remove All ( poi . get Node Refs ( ) ) ; for ( Poi Node Ref poi Node Ref : poi Node Refs To Remove ) { poi Node Ref Dao . delete ( poi Node Ref ) ; } poi Dao . create Or Update ( poi ) ; if ( poi . get Tags ( ) != null ) { for ( Poi Tag poi Tag : poi . get Tags ( ) ) { poi Tag . set Poi ( poi ) ; poi Tag Dao . create Or Update ( poi Tag ) ; } } if ( poi . get Node Refs ( ) != null ) { for ( Poi Node Ref poi Node Ref : poi . get Node Refs ( ) ) { poi Node Ref . set Poi ( poi ) ; poi Node Ref Dao . create Or Update ( poi Node Ref ) ; } } return poi ; }
private Poi save Poi No Transaction ( Poi poi ) { List < Poi Tag > poi Tags To Remove = poi Tag Dao . query By Poi Id ( poi . get Id ( ) ) ; poi Tags To Remove . remove All ( poi . get Tags ( ) ) ; for ( Poi Tag poi Tag : poi Tags To Remove ) { poi Tag Dao . delete ( poi Tag ) ; } List < Poi Node Ref > poi Node Refs To Remove = poi Node Ref Dao . query By Poi Id ( poi . get Id ( ) ) ; poi Node Refs To Remove . remove All ( poi . get Node Refs ( ) ) ; for ( Poi Node Ref poi Node Ref : poi Node Refs To Remove ) { poi Node Ref Dao . delete ( poi Node Ref ) ; } poi Dao . create Or Update ( poi ) ; if ( poi . get Tags ( ) != null ) { for ( Poi Tag poi Tag : poi . get Tags ( ) ) { poi Tag . set Poi ( poi ) ; poi Tag Dao . create Or Update ( poi Tag ) ; } } if ( poi . get Node Refs ( ) != null ) { for ( Poi Node Ref poi Node Ref : poi . get Node Refs ( ) ) { poi Node Ref . set Poi ( poi ) ; poi Node Ref Dao . create Or Update ( poi Node Ref ) ; } } return poi ; }
private Poi save Poi No Transaction ( Poi poi ) { List < Poi Tag > poi Tags To Remove = poi Tag Dao . query By Poi Id ( poi . get Id ( ) ) ; poi Tags To Remove . remove All ( poi . get Tags ( ) ) ; for ( Poi Tag poi Tag : poi Tags To Remove ) { poi Tag Dao . delete ( poi Tag ) ; } List < Poi Node Ref > poi Node Refs To Remove = poi Node Ref Dao . query By Poi Id ( poi . get Id ( ) ) ; poi Node Refs To Remove . remove All ( poi . get Node Refs ( ) ) ; for ( Poi Node Ref poi Node Ref : poi Node Refs To Remove ) { poi Node Ref Dao . delete ( poi Node Ref ) ; } poi Dao . create Or Update ( poi ) ; if ( poi . get Tags ( ) != null ) { for ( Poi Tag poi Tag : poi . get Tags ( ) ) { poi Tag . set Poi ( poi ) ; poi Tag Dao . create Or Update ( poi Tag ) ; } } if ( poi . get Node Refs ( ) != null ) { for ( Poi Node Ref poi Node Ref : poi . get Node Refs ( ) ) { poi Node Ref . set Poi ( poi ) ; poi Node Ref Dao . create Or Update ( poi Node Ref ) ; } } return poi ; }
public String create Table ( Table table ) { String Builder ddl = new String Builder ( ) ; create Table ( table , ddl , BOOL , BOOL ) ; return ddl . to String ( ) ; }
public D Netscape Base Url ( J Dialog parent ) { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; }
public static String trim ( String str , Character Predicate predicate ) { int len = str . length ( ) ; if ( len == NUM ) return str ; int st = NUM ; while ( ( st < len ) && predicate . test ( str . char At ( st ) ) ) { st ++ ; } while ( ( st < len ) && predicate . test ( str . char At ( len - NUM ) ) ) { len -- ; } return ( ( st > NUM ) || ( len < str . length ( ) ) ) ? str . substring ( st , len ) : str ; }
public static String trim ( String str , Character Predicate predicate ) { int len = str . length ( ) ; if ( len == NUM ) return str ; int st = NUM ; while ( ( st < len ) && predicate . test ( str . char At ( st ) ) ) { st ++ ; } while ( ( st < len ) && predicate . test ( str . char At ( len - NUM ) ) ) { len -- ; } return ( ( st > NUM ) || ( len < str . length ( ) ) ) ? str . substring ( st , len ) : str ; }
public static String trim ( String str , Character Predicate predicate ) { int len = str . length ( ) ; if ( len == NUM ) return str ; int st = NUM ; while ( ( st < len ) && predicate . test ( str . char At ( st ) ) ) { st ++ ; } while ( ( st < len ) && predicate . test ( str . char At ( len - NUM ) ) ) { len -- ; } return ( ( st > NUM ) || ( len < str . length ( ) ) ) ? str . substring ( st , len ) : str ; }
public Xintro Activity Builder add Fragment ( Intro Fragment Model intro Fragment Model ) { intro Fragment Model List . add ( intro Fragment Model ) ; return this ; }
public void write One ( int opsw Index ) { try { set Address ( NUM ) ; } catch ( Exception e ) { if ( log . is Debug Enabled ( ) ) { log . debug ( rb . get String ( STRING ) + STRING + e ) ; } read All Button . set Selected ( BOOL ) ; write All Button . set Selected ( BOOL ) ; status . set Text ( STRING ) ; return ; } copy To Opsw ( ) ; read = BOOL ; state = opsw Index ; only One Operation = BOOL ; next Request ( ) ; }
public static void add Servers To Site ( SSO Token sso Token , String site Name , Collection server Instance Names ) throws SMS Exception , SSO Exception , Configuration Exception { String site Id = get Site Id ( sso Token , site Name ) ; if ( site Id != null ) { for ( Iterator i = server Instance Names . iterator ( ) ; i . has Next ( ) ; ) { String svr = ( String ) i . next ( ) ; Server Configuration . add To Site ( sso Token , svr , site Name ) ; } } }
public void remove Column ( final String column Name ) { if ( column Name == null ) { return ; } final List < String > cols = Arrays . as List ( get Info ( ) . headers ) ; final int col Index = cols . index Of ( column Name ) ; remove Column ( col Index ) ; }
public void remove Column ( final String column Name ) { if ( column Name == null ) { return ; } final List < String > cols = Arrays . as List ( get Info ( ) . headers ) ; final int col Index = cols . index Of ( column Name ) ; remove Column ( col Index ) ; }
public void add Callback ( Callback callback ) { if ( ! m Callbacks . contains ( callback ) ) { m Callbacks . add ( callback ) ; } }
Index Entry ( Byte Provider byte Provider ) throws IO Exception { MXF Property Populator . populate Field ( byte Provider , this , STRING ) ; MXF Property Populator . populate Field ( byte Provider , this , STRING ) ; MXF Property Populator . populate Field ( byte Provider , this , STRING ) ; MXF Property Populator . populate Field ( byte Provider , this , STRING ) ; }
protected void process BDDP Lists ( ) { int count = NUM ; Set < Node Port Tuple > npt List = new Hash Set < Node Port Tuple > ( ) ; while ( count < BDDP TASK SIZE && quarantine Queue . peek ( ) != null ) { Node Port Tuple npt ; npt = quarantine Queue . remove ( ) ; send Discovery Message ( npt . get Node Id ( ) , npt . get Port Id ( ) , BOOL , BOOL ) ; npt List . add ( npt ) ; count ++ ; } count = NUM ; while ( count < BDDP TASK SIZE && maintenance Queue . peek ( ) != null ) { Node Port Tuple npt ; npt = maintenance Queue . remove ( ) ; send Discovery Message ( npt . get Node Id ( ) , npt . get Port Id ( ) , BOOL , BOOL ) ; count ++ ; } for ( Node Port Tuple npt : npt List ) { generate Switch Port Status Update ( npt . get Node Id ( ) , npt . get Port Id ( ) ) ; } }
protected void process BDDP Lists ( ) { int count = NUM ; Set < Node Port Tuple > npt List = new Hash Set < Node Port Tuple > ( ) ; while ( count < BDDP TASK SIZE && quarantine Queue . peek ( ) != null ) { Node Port Tuple npt ; npt = quarantine Queue . remove ( ) ; send Discovery Message ( npt . get Node Id ( ) , npt . get Port Id ( ) , BOOL , BOOL ) ; npt List . add ( npt ) ; count ++ ; } count = NUM ; while ( count < BDDP TASK SIZE && maintenance Queue . peek ( ) != null ) { Node Port Tuple npt ; npt = maintenance Queue . remove ( ) ; send Discovery Message ( npt . get Node Id ( ) , npt . get Port Id ( ) , BOOL , BOOL ) ; count ++ ; } for ( Node Port Tuple npt : npt List ) { generate Switch Port Status Update ( npt . get Node Id ( ) , npt . get Port Id ( ) ) ; } }
protected void process BDDP Lists ( ) { int count = NUM ; Set < Node Port Tuple > npt List = new Hash Set < Node Port Tuple > ( ) ; while ( count < BDDP TASK SIZE && quarantine Queue . peek ( ) != null ) { Node Port Tuple npt ; npt = quarantine Queue . remove ( ) ; send Discovery Message ( npt . get Node Id ( ) , npt . get Port Id ( ) , BOOL , BOOL ) ; npt List . add ( npt ) ; count ++ ; } count = NUM ; while ( count < BDDP TASK SIZE && maintenance Queue . peek ( ) != null ) { Node Port Tuple npt ; npt = maintenance Queue . remove ( ) ; send Discovery Message ( npt . get Node Id ( ) , npt . get Port Id ( ) , BOOL , BOOL ) ; count ++ ; } for ( Node Port Tuple npt : npt List ) { generate Switch Port Status Update ( npt . get Node Id ( ) , npt . get Port Id ( ) ) ; } }
protected void process BDDP Lists ( ) { int count = NUM ; Set < Node Port Tuple > npt List = new Hash Set < Node Port Tuple > ( ) ; while ( count < BDDP TASK SIZE && quarantine Queue . peek ( ) != null ) { Node Port Tuple npt ; npt = quarantine Queue . remove ( ) ; send Discovery Message ( npt . get Node Id ( ) , npt . get Port Id ( ) , BOOL , BOOL ) ; npt List . add ( npt ) ; count ++ ; } count = NUM ; while ( count < BDDP TASK SIZE && maintenance Queue . peek ( ) != null ) { Node Port Tuple npt ; npt = maintenance Queue . remove ( ) ; send Discovery Message ( npt . get Node Id ( ) , npt . get Port Id ( ) , BOOL , BOOL ) ; count ++ ; } for ( Node Port Tuple npt : npt List ) { generate Switch Port Status Update ( npt . get Node Id ( ) , npt . get Port Id ( ) ) ; } }
protected void process BDDP Lists ( ) { int count = NUM ; Set < Node Port Tuple > npt List = new Hash Set < Node Port Tuple > ( ) ; while ( count < BDDP TASK SIZE && quarantine Queue . peek ( ) != null ) { Node Port Tuple npt ; npt = quarantine Queue . remove ( ) ; send Discovery Message ( npt . get Node Id ( ) , npt . get Port Id ( ) , BOOL , BOOL ) ; npt List . add ( npt ) ; count ++ ; } count = NUM ; while ( count < BDDP TASK SIZE && maintenance Queue . peek ( ) != null ) { Node Port Tuple npt ; npt = maintenance Queue . remove ( ) ; send Discovery Message ( npt . get Node Id ( ) , npt . get Port Id ( ) , BOOL , BOOL ) ; count ++ ; } for ( Node Port Tuple npt : npt List ) { generate Switch Port Status Update ( npt . get Node Id ( ) , npt . get Port Id ( ) ) ; } }
public Consul Topology Fraction ( ) { this . url = DEFAULT URL ; }
public static String generate Native Guid ( Protection System device , String unique Id , String type ) { String type Str = STRING ; if ( OBJECT TYPE SET . contains ( type ) ) { type Str = type ; } return String . format ( STRING , device Type Map . get ( device . get System Type ( ) ) , device . get Installation Id ( ) , type Str , unique Id ) ; }
public void clear Drop Item List ( ) { drops Items = new Array List < Drop Item > ( ) ; drop Item Instances . clear ( ) ; }
public void clear Drop Item List ( ) { drops Items = new Array List < Drop Item > ( ) ; drop Item Instances . clear ( ) ; }
@ Deprecated static public Serial Sensor Manager instance ( ) { return null ; }
@ Deprecated static public Serial Sensor Manager instance ( ) { return null ; }
@ Deprecated static public Serial Sensor Manager instance ( ) { return null ; }
public Per Test Class Loader Runner ( Class < ? > klass ) throws Initialization Error { super ( klass ) ; }
private float multilinear Interpolate ( float [ ] encoded , int od ) { float [ ] dists = new float [ encoded . length ] ; for ( int i = NUM ; i < dists . length ; i ++ ) { dists [ i ] = ( float ) ( encoded [ i ] - Math . floor ( encoded [ i ] ) ) ; } int map = NUM ; float val = get Sample ( encoded , map , od ) ; float prev = val ; for ( int i = NUM ; i < dists . length ; i ++ ) { int idx = NUM ; float largest = - NUM ; for ( int c = NUM ; c < dists . length ; c ++ ) { if ( dists [ c ] > largest ) { largest = dists [ c ] ; idx = c ; } } map |= ( NUM << idx ) ; float cur = get Sample ( encoded , map , od ) ; val += dists [ idx ] * ( cur - prev ) ; prev = val ; dists [ idx ] = - NUM ; } return val ; }
private float multilinear Interpolate ( float [ ] encoded , int od ) { float [ ] dists = new float [ encoded . length ] ; for ( int i = NUM ; i < dists . length ; i ++ ) { dists [ i ] = ( float ) ( encoded [ i ] - Math . floor ( encoded [ i ] ) ) ; } int map = NUM ; float val = get Sample ( encoded , map , od ) ; float prev = val ; for ( int i = NUM ; i < dists . length ; i ++ ) { int idx = NUM ; float largest = - NUM ; for ( int c = NUM ; c < dists . length ; c ++ ) { if ( dists [ c ] > largest ) { largest = dists [ c ] ; idx = c ; } } map |= ( NUM << idx ) ; float cur = get Sample ( encoded , map , od ) ; val += dists [ idx ] * ( cur - prev ) ; prev = val ; dists [ idx ] = - NUM ; } return val ; }
private float multilinear Interpolate ( float [ ] encoded , int od ) { float [ ] dists = new float [ encoded . length ] ; for ( int i = NUM ; i < dists . length ; i ++ ) { dists [ i ] = ( float ) ( encoded [ i ] - Math . floor ( encoded [ i ] ) ) ; } int map = NUM ; float val = get Sample ( encoded , map , od ) ; float prev = val ; for ( int i = NUM ; i < dists . length ; i ++ ) { int idx = NUM ; float largest = - NUM ; for ( int c = NUM ; c < dists . length ; c ++ ) { if ( dists [ c ] > largest ) { largest = dists [ c ] ; idx = c ; } } map |= ( NUM << idx ) ; float cur = get Sample ( encoded , map , od ) ; val += dists [ idx ] * ( cur - prev ) ; prev = val ; dists [ idx ] = - NUM ; } return val ; }
private float multilinear Interpolate ( float [ ] encoded , int od ) { float [ ] dists = new float [ encoded . length ] ; for ( int i = NUM ; i < dists . length ; i ++ ) { dists [ i ] = ( float ) ( encoded [ i ] - Math . floor ( encoded [ i ] ) ) ; } int map = NUM ; float val = get Sample ( encoded , map , od ) ; float prev = val ; for ( int i = NUM ; i < dists . length ; i ++ ) { int idx = NUM ; float largest = - NUM ; for ( int c = NUM ; c < dists . length ; c ++ ) { if ( dists [ c ] > largest ) { largest = dists [ c ] ; idx = c ; } } map |= ( NUM << idx ) ; float cur = get Sample ( encoded , map , od ) ; val += dists [ idx ] * ( cur - prev ) ; prev = val ; dists [ idx ] = - NUM ; } return val ; }
private boolean have Previous Digest Authorization And Should Abort ( Request request , String nonce , boolean is Stale ) { final String previous Authorization Header = request . header ( STRING ) ; if ( previous Authorization Header != null && previous Authorization Header . starts With ( STRING ) ) { return ! is Stale ; } return BOOL ; }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m split Thread . is Alive ( ) ) { wait ( ) ; } } catch ( Interrupted Exception ex ) { } } else { notify All ( ) ; } }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m split Thread . is Alive ( ) ) { wait ( ) ; } } catch ( Interrupted Exception ex ) { } } else { notify All ( ) ; } }
public void validate Session ( Internal Session internal Session , Session ID sid ) throws Session Exception { if ( ! sid . equals ( internal Session . get ID ( ) ) && internal Session . get Restriction For Token ( sid ) == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( internal Session . get State ( ) != Session State . VALID ) { if ( internal Session . is Timed Out ( ) ) { throw new Session Timed Out Exception ( Message Format . format ( ERROR FORMAT , Session Bundle . get String ( SESSION TIMED OUT ) , sid ) ) ; } else { throw new Session Exception ( Message Format . format ( ERROR FORMAT , Session Bundle . get String ( INVALID SESSION STATE ) , sid ) ) ; } } }
public void validate Session ( Internal Session internal Session , Session ID sid ) throws Session Exception { if ( ! sid . equals ( internal Session . get ID ( ) ) && internal Session . get Restriction For Token ( sid ) == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( internal Session . get State ( ) != Session State . VALID ) { if ( internal Session . is Timed Out ( ) ) { throw new Session Timed Out Exception ( Message Format . format ( ERROR FORMAT , Session Bundle . get String ( SESSION TIMED OUT ) , sid ) ) ; } else { throw new Session Exception ( Message Format . format ( ERROR FORMAT , Session Bundle . get String ( INVALID SESSION STATE ) , sid ) ) ; } } }
public void validate Session ( Internal Session internal Session , Session ID sid ) throws Session Exception { if ( ! sid . equals ( internal Session . get ID ( ) ) && internal Session . get Restriction For Token ( sid ) == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( internal Session . get State ( ) != Session State . VALID ) { if ( internal Session . is Timed Out ( ) ) { throw new Session Timed Out Exception ( Message Format . format ( ERROR FORMAT , Session Bundle . get String ( SESSION TIMED OUT ) , sid ) ) ; } else { throw new Session Exception ( Message Format . format ( ERROR FORMAT , Session Bundle . get String ( INVALID SESSION STATE ) , sid ) ) ; } } }
protected void delete Session Variables ( String session Id , String ... var Names ) { if ( session Id . equals ( STRING ) ) { return ; } Key key = key Factory . new Key ( session Id ) ; Transaction transaction = datastore . new Transaction ( ) ; try { Entity state Entity = transaction . get ( key ) ; Entity . Builder builder = Entity . builder ( state Entity ) ; String Builder del Names = new String Builder ( ) ; for ( String var Name : var Names ) { del Names . append ( var Name + STRING ) ; builder = builder . remove ( var Name ) ; } datastore . update ( builder . build ( ) ) ; } catch ( Null Pointer Exception e ) { } finally { if ( transaction . active ( ) ) { transaction . rollback ( ) ; } } }
protected void delete Session Variables ( String session Id , String ... var Names ) { if ( session Id . equals ( STRING ) ) { return ; } Key key = key Factory . new Key ( session Id ) ; Transaction transaction = datastore . new Transaction ( ) ; try { Entity state Entity = transaction . get ( key ) ; Entity . Builder builder = Entity . builder ( state Entity ) ; String Builder del Names = new String Builder ( ) ; for ( String var Name : var Names ) { del Names . append ( var Name + STRING ) ; builder = builder . remove ( var Name ) ; } datastore . update ( builder . build ( ) ) ; } catch ( Null Pointer Exception e ) { } finally { if ( transaction . active ( ) ) { transaction . rollback ( ) ; } } }
protected void delete Session Variables ( String session Id , String ... var Names ) { if ( session Id . equals ( STRING ) ) { return ; } Key key = key Factory . new Key ( session Id ) ; Transaction transaction = datastore . new Transaction ( ) ; try { Entity state Entity = transaction . get ( key ) ; Entity . Builder builder = Entity . builder ( state Entity ) ; String Builder del Names = new String Builder ( ) ; for ( String var Name : var Names ) { del Names . append ( var Name + STRING ) ; builder = builder . remove ( var Name ) ; } datastore . update ( builder . build ( ) ) ; } catch ( Null Pointer Exception e ) { } finally { if ( transaction . active ( ) ) { transaction . rollback ( ) ; } } }
private static void deserialize Header ( Kdb Header kdb Header , Data Input data Input ) throws IO Exception { kdb Header . set Flags ( data Input . read Int ( ) ) ; kdb Header . set Version ( data Input . read Int ( ) ) ; byte [ ] buffer = new byte [ NUM ] ; data Input . read Fully ( buffer ) ; kdb Header . set Master Seed ( buffer ) ; buffer = new byte [ NUM ] ; data Input . read Fully ( buffer ) ; kdb Header . set Encryption Iv ( buffer ) ; kdb Header . set Group Count ( data Input . read Int ( ) ) ; kdb Header . set Entry Count ( data Input . read Int ( ) ) ; byte [ ] buffer 32 = new byte [ NUM ] ; data Input . read Fully ( buffer 32 ) ; kdb Header . set Content Hash ( buffer 32 ) ; buffer 32 = new byte [ NUM ] ; data Input . read Fully ( buffer 32 ) ; kdb Header . set Transform Seed ( buffer 32 ) ; kdb Header . set Transform Rounds ( data Input . read Int ( ) ) ; }
private static void deserialize Header ( Kdb Header kdb Header , Data Input data Input ) throws IO Exception { kdb Header . set Flags ( data Input . read Int ( ) ) ; kdb Header . set Version ( data Input . read Int ( ) ) ; byte [ ] buffer = new byte [ NUM ] ; data Input . read Fully ( buffer ) ; kdb Header . set Master Seed ( buffer ) ; buffer = new byte [ NUM ] ; data Input . read Fully ( buffer ) ; kdb Header . set Encryption Iv ( buffer ) ; kdb Header . set Group Count ( data Input . read Int ( ) ) ; kdb Header . set Entry Count ( data Input . read Int ( ) ) ; byte [ ] buffer 32 = new byte [ NUM ] ; data Input . read Fully ( buffer 32 ) ; kdb Header . set Content Hash ( buffer 32 ) ; buffer 32 = new byte [ NUM ] ; data Input . read Fully ( buffer 32 ) ; kdb Header . set Transform Seed ( buffer 32 ) ; kdb Header . set Transform Rounds ( data Input . read Int ( ) ) ; }
private E dequeue ( ) { final Object [ ] items = this . items ; @ Suppress Warnings ( STRING ) E x = ( E ) items [ take Index ] ; items [ take Index ] = null ; take Index = inc ( take Index ) ; count -- ; if ( itrs != null ) itrs . element Dequeued ( ) ; not Full . signal ( ) ; return x ; }
public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
static public void add All ( List < String > list , String [ ] array ) { for ( String item : array ) list . add ( item ) ; }
public boolean contains ( ) { int next = NUM ; final int size = f Values . size ( ) ; LOOP : for ( int i = NUM ; i < size ; i = next ) { next = i + f Field Count ; for ( int j = NUM ; j < f Field Count ; j ++ ) { Object value 1 = f Local Values [ j ] ; Object value 2 = f Values . element At ( i ) ; short value Type 1 = f Local Value Types [ j ] ; short value Type 2 = get Value Type At ( i ) ; if ( value 1 == null || value 2 == null || value Type 1 != value Type 2 || ! ( value 1 . equals ( value 2 ) ) ) { continue LOOP ; } else if ( value Type 1 == XS Constants . LIST DT || value Type 1 == XS Constants . LISTOFUNION DT ) { Short List list 1 = f Local Item Value Types [ j ] ; Short List list 2 = get Item Value Type At ( i ) ; if ( list 1 == null || list 2 == null || ! list 1 . equals ( list 2 ) ) continue LOOP ; } i ++ ; } return BOOL ; } return BOOL ; }
public boolean contains ( ) { int next = NUM ; final int size = f Values . size ( ) ; LOOP : for ( int i = NUM ; i < size ; i = next ) { next = i + f Field Count ; for ( int j = NUM ; j < f Field Count ; j ++ ) { Object value 1 = f Local Values [ j ] ; Object value 2 = f Values . element At ( i ) ; short value Type 1 = f Local Value Types [ j ] ; short value Type 2 = get Value Type At ( i ) ; if ( value 1 == null || value 2 == null || value Type 1 != value Type 2 || ! ( value 1 . equals ( value 2 ) ) ) { continue LOOP ; } else if ( value Type 1 == XS Constants . LIST DT || value Type 1 == XS Constants . LISTOFUNION DT ) { Short List list 1 = f Local Item Value Types [ j ] ; Short List list 2 = get Item Value Type At ( i ) ; if ( list 1 == null || list 2 == null || ! list 1 . equals ( list 2 ) ) continue LOOP ; } i ++ ; } return BOOL ; } return BOOL ; }
public void do Window Open ( ) { }
static public P Vector from Angle ( float angle , P Vector target ) { if ( target == null ) { target = new P Vector ( ( float ) Math . cos ( angle ) , ( float ) Math . sin ( angle ) , NUM ) ; } else { target . set ( ( float ) Math . cos ( angle ) , ( float ) Math . sin ( angle ) , NUM ) ; } return target ; }
private void send Next Message Over Network ( ) throws Exception { Raw Data raw = outgoing . take ( ) ; if ( raw == null ) throw new Null Pointer Exception ( ) ; send Next ( raw ) ; }
protected Long encode Range Shift ( final Long val , final Long min Value ) { if ( min Value == null ) { return val ; } if ( val < min Value ) { throw new Runtime Exception ( STRING ) ; } return Long . MIN VALUE + ( val - min Value ) ; }
protected Long encode Range Shift ( final Long val , final Long min Value ) { if ( min Value == null ) { return val ; } if ( val < min Value ) { throw new Runtime Exception ( STRING ) ; } return Long . MIN VALUE + ( val - min Value ) ; }
private boolean is Menu Touched ( int ix , int iy , Bitmap b , int site Offset ) { int angle = get Offset History ( ) + site Offset ; double x0 = RADIU * Math . cos ( Math . to Radians ( angle ) ) + circle Point . get X ( ) ; double y0 = RADIU * Math . sin ( Math . to Radians ( angle ) ) + circle Point . get Y ( ) ; return ( ( x0 - ix ) * ( x0 - ix ) + ( y0 - iy ) * ( y0 - iy ) ) <= get Min Circle Radius ( b ) * get Min Circle Radius ( b ) ; }
private boolean is Menu Touched ( int ix , int iy , Bitmap b , int site Offset ) { int angle = get Offset History ( ) + site Offset ; double x0 = RADIU * Math . cos ( Math . to Radians ( angle ) ) + circle Point . get X ( ) ; double y0 = RADIU * Math . sin ( Math . to Radians ( angle ) ) + circle Point . get Y ( ) ; return ( ( x0 - ix ) * ( x0 - ix ) + ( y0 - iy ) * ( y0 - iy ) ) <= get Min Circle Radius ( b ) * get Min Circle Radius ( b ) ; }
private boolean is Menu Touched ( int ix , int iy , Bitmap b , int site Offset ) { int angle = get Offset History ( ) + site Offset ; double x0 = RADIU * Math . cos ( Math . to Radians ( angle ) ) + circle Point . get X ( ) ; double y0 = RADIU * Math . sin ( Math . to Radians ( angle ) ) + circle Point . get Y ( ) ; return ( ( x0 - ix ) * ( x0 - ix ) + ( y0 - iy ) * ( y0 - iy ) ) <= get Min Circle Radius ( b ) * get Min Circle Radius ( b ) ; }
public void delete Meta Object ( int index ) { Meta Objects . set ( index , null ) ; }
public void delete Meta Object ( int index ) { Meta Objects . set ( index , null ) ; }
public static boolean delete Photo ( Uri file Uri ) { try { File media Storage Dir = get Media Storage Dir ( ) ; if ( ! media Storage Dir . exists ( ) ) return BOOL ; File photo To Delete = new File ( file Uri . get Path ( ) ) ; return photo To Delete . delete ( ) ; } catch ( Exception e ) { Log . e ( TAG , STRING ) ; Log . e ( TAG , e . get Localized Message ( ) ) ; return BOOL ; } }
public void test Add All 3 ( ) { try { Linked Blocking Queue q = new Linked Blocking Queue ( SIZE ) ; Integer [ ] ints = new Integer [ SIZE ] ; for ( int i = NUM ; i < SIZE - NUM ; ++ i ) ints [ i ] = new Integer ( i ) ; q . add All ( Arrays . as List ( ints ) ) ; should Throw ( ) ; } catch ( Null Pointer Exception success ) { } }
@ Check Return Value @ Nonnull @ Deprecated static public String [ ] split ( @ Nonnull String input , @ Nonnull String divider ) { int size = NUM ; String temp = input ; while ( temp . length ( ) > NUM ) { size ++ ; int index = temp . index Of ( divider ) ; if ( index < NUM ) { break ; } temp = temp . substring ( index + divider . length ( ) ) ; if ( temp . length ( ) == NUM ) { size ++ ; break ; } } String [ ] result = new String [ size ] ; temp = input ; size = NUM ; while ( temp . length ( ) > NUM ) { int index = temp . index Of ( divider ) ; if ( index < NUM ) { break ; } result [ size ] = temp . substring ( NUM , index ) ; temp = temp . substring ( index + divider . length ( ) ) ; size ++ ; } result [ size ] = temp ; return result ; }
@ Check Return Value @ Nonnull @ Deprecated static public String [ ] split ( @ Nonnull String input , @ Nonnull String divider ) { int size = NUM ; String temp = input ; while ( temp . length ( ) > NUM ) { size ++ ; int index = temp . index Of ( divider ) ; if ( index < NUM ) { break ; } temp = temp . substring ( index + divider . length ( ) ) ; if ( temp . length ( ) == NUM ) { size ++ ; break ; } } String [ ] result = new String [ size ] ; temp = input ; size = NUM ; while ( temp . length ( ) > NUM ) { int index = temp . index Of ( divider ) ; if ( index < NUM ) { break ; } result [ size ] = temp . substring ( NUM , index ) ; temp = temp . substring ( index + divider . length ( ) ) ; size ++ ; } result [ size ] = temp ; return result ; }
@ Check Return Value @ Nonnull @ Deprecated static public String [ ] split ( @ Nonnull String input , @ Nonnull String divider ) { int size = NUM ; String temp = input ; while ( temp . length ( ) > NUM ) { size ++ ; int index = temp . index Of ( divider ) ; if ( index < NUM ) { break ; } temp = temp . substring ( index + divider . length ( ) ) ; if ( temp . length ( ) == NUM ) { size ++ ; break ; } } String [ ] result = new String [ size ] ; temp = input ; size = NUM ; while ( temp . length ( ) > NUM ) { int index = temp . index Of ( divider ) ; if ( index < NUM ) { break ; } result [ size ] = temp . substring ( NUM , index ) ; temp = temp . substring ( index + divider . length ( ) ) ; size ++ ; } result [ size ] = temp ; return result ; }
@ Check Return Value @ Nonnull @ Deprecated static public String [ ] split ( @ Nonnull String input , @ Nonnull String divider ) { int size = NUM ; String temp = input ; while ( temp . length ( ) > NUM ) { size ++ ; int index = temp . index Of ( divider ) ; if ( index < NUM ) { break ; } temp = temp . substring ( index + divider . length ( ) ) ; if ( temp . length ( ) == NUM ) { size ++ ; break ; } } String [ ] result = new String [ size ] ; temp = input ; size = NUM ; while ( temp . length ( ) > NUM ) { int index = temp . index Of ( divider ) ; if ( index < NUM ) { break ; } result [ size ] = temp . substring ( NUM , index ) ; temp = temp . substring ( index + divider . length ( ) ) ; size ++ ; } result [ size ] = temp ; return result ; }
@ Check Return Value @ Nonnull @ Deprecated static public String [ ] split ( @ Nonnull String input , @ Nonnull String divider ) { int size = NUM ; String temp = input ; while ( temp . length ( ) > NUM ) { size ++ ; int index = temp . index Of ( divider ) ; if ( index < NUM ) { break ; } temp = temp . substring ( index + divider . length ( ) ) ; if ( temp . length ( ) == NUM ) { size ++ ; break ; } } String [ ] result = new String [ size ] ; temp = input ; size = NUM ; while ( temp . length ( ) > NUM ) { int index = temp . index Of ( divider ) ; if ( index < NUM ) { break ; } result [ size ] = temp . substring ( NUM , index ) ; temp = temp . substring ( index + divider . length ( ) ) ; size ++ ; } result [ size ] = temp ; return result ; }
@ Check Return Value @ Nonnull @ Deprecated static public String [ ] split ( @ Nonnull String input , @ Nonnull String divider ) { int size = NUM ; String temp = input ; while ( temp . length ( ) > NUM ) { size ++ ; int index = temp . index Of ( divider ) ; if ( index < NUM ) { break ; } temp = temp . substring ( index + divider . length ( ) ) ; if ( temp . length ( ) == NUM ) { size ++ ; break ; } } String [ ] result = new String [ size ] ; temp = input ; size = NUM ; while ( temp . length ( ) > NUM ) { int index = temp . index Of ( divider ) ; if ( index < NUM ) { break ; } result [ size ] = temp . substring ( NUM , index ) ; temp = temp . substring ( index + divider . length ( ) ) ; size ++ ; } result [ size ] = temp ; return result ; }
protected void add ( Directed Edge dir Edge ) { dir Edges . add ( dir Edge ) ; }
protected void add ( Directed Edge dir Edge ) { dir Edges . add ( dir Edge ) ; }
protected void add ( Directed Edge dir Edge ) { dir Edges . add ( dir Edge ) ; }
protected void add ( Directed Edge dir Edge ) { dir Edges . add ( dir Edge ) ; }
Builder add Lenient ( String name , String value ) { names And Values . add ( name ) ; names And Values . add ( value . trim ( ) ) ; return this ; }
Builder add Lenient ( String name , String value ) { names And Values . add ( name ) ; names And Values . add ( value . trim ( ) ) ; return this ; }
public static void draw Arrow ( Graphics 2 D g , Polygon arrow , int x , int y ) { arrow . translate ( x , y ) ; g . draw ( arrow ) ; g . fill ( arrow ) ; arrow . translate ( - x , - y ) ; }
public void remove Communication Listener ( FTP Communication Listener listener ) { synchronized ( lock ) { communication Listeners . remove ( listener ) ; if ( communication != null ) { communication . remove Communication Listener ( listener ) ; } } }
public void remove Communication Listener ( FTP Communication Listener listener ) { synchronized ( lock ) { communication Listeners . remove ( listener ) ; if ( communication != null ) { communication . remove Communication Listener ( listener ) ; } } }
private boolean is Implicit Import ( String name ) { Boolean yes = implicit Imports . get ( name ) ; if ( yes != null ) { return yes ; } try { Class . for Name ( STRING + name ) ; yes = BOOL ; } catch ( Exception e ) { yes = BOOL ; } implicit Imports . put ( name , yes ) ; return yes ; }
private void validate Table Meta Data Single Row ( String table Name Pattern , String [ ] types , Map < Table Meta Data , Object > validation Rules ) throws Exception { check Validation Rules Complete ( validation Rules ) ; try ( Result Set tables = dbmd . get Tables ( null , null , table Name Pattern , types ) ) { assert True ( STRING , tables . next ( ) ) ; validate Row Values ( tables , validation Rules ) ; assert False ( STRING , tables . next ( ) ) ; } }
private void validate Table Meta Data Single Row ( String table Name Pattern , String [ ] types , Map < Table Meta Data , Object > validation Rules ) throws Exception { check Validation Rules Complete ( validation Rules ) ; try ( Result Set tables = dbmd . get Tables ( null , null , table Name Pattern , types ) ) { assert True ( STRING , tables . next ( ) ) ; validate Row Values ( tables , validation Rules ) ; assert False ( STRING , tables . next ( ) ) ; } }
private static int [ ] validate Coordinates ( int x1 , int y1 , int x2 , int y2 ) { if ( ( x1 > x2 ) | ( y1 < y2 ) ) { if ( x1 > x2 ) { final int temp = x1 ; x1 = x2 ; x2 = temp ; Log Writer . write Log ( STRING ) ; } if ( y1 < y2 ) { final int temp = y1 ; y1 = y2 ; y2 = temp ; Log Writer . write Log ( STRING ) ; } } return new int [ ] { x1 , y1 , x2 , y2 } ; }
private static int [ ] validate Coordinates ( int x1 , int y1 , int x2 , int y2 ) { if ( ( x1 > x2 ) | ( y1 < y2 ) ) { if ( x1 > x2 ) { final int temp = x1 ; x1 = x2 ; x2 = temp ; Log Writer . write Log ( STRING ) ; } if ( y1 < y2 ) { final int temp = y1 ; y1 = y2 ; y2 = temp ; Log Writer . write Log ( STRING ) ; } } return new int [ ] { x1 , y1 , x2 , y2 } ; }
@ Suppress Warnings ( STRING ) private Method find Matching Method ( J Diff Method method ) { Method [ ] methods = m Class . get Declared Methods ( ) ; for ( Method m : methods ) { if ( matches ( method , m ) ) { return m ; } } return null ; }
@ Override public int compare To ( Value o ) { if ( o instanceof String Val ) { return str . compare To ( ( ( String Val ) o ) . str ) ; } else { return NUM ; } }
private void add License ( Paragraph p , Eml eml ) throws Document Exception { String license Title = eml . parse License Title ( ) ; String license Url = eml . parse License Url ( ) ; if ( ! Strings . is Null Or Empty ( license Title ) && ! Strings . is Null Or Empty ( license Url ) ) { p . add ( new Phrase ( get Text ( STRING ) + STRING , font Title ) ) ; Anchor license Link = new Anchor ( eml . parse License Title ( ) , font Link ) ; license Link . set Reference ( eml . parse License Url ( ) ) ; p . add ( license Link ) ; p . add ( Chunk . NEWLINE ) ; } }
public Partitioned Region Rebalance Op ( Partitioned Region region , boolean simulate , Rebalance Director director , boolean replace Offline Data , boolean is Rebalance ) { this ( region , simulate , director , replace Offline Data , is Rebalance , new Atomic Boolean ( ) , null ) ; }
public Partitioned Region Rebalance Op ( Partitioned Region region , boolean simulate , Rebalance Director director , boolean replace Offline Data , boolean is Rebalance ) { this ( region , simulate , director , replace Offline Data , is Rebalance , new Atomic Boolean ( ) , null ) ; }
public Path Impl lookup Impl ( String user Path , Map < String , Object > new Attributes , boolean is Allow Root ) { if ( user Path == null ) { return lookup Impl ( get Path ( ) , new Attributes , is Allow Root ) ; } if ( ! is Allow Root ) { return scheme Walk ( user Path , new Attributes , user Path , NUM ) ; } String scheme = scan Scheme ( user Path ) ; if ( scheme == null ) { return scheme Walk ( user Path , new Attributes , user Path , NUM ) ; } Path Impl path ; Scheme Map scheme Map = scheme Map ; if ( is Windows ( ) ) { int length = scheme . length ( ) ; char ch ; if ( length == NUM && ( STRING <= ( ch = scheme . char At ( NUM ) ) && ch <= STRING || STRING <= ch && ch <= STRING ) ) { user Path = Character . to Lower Case ( ch ) + user Path . substring ( NUM ) ; if ( is Test Windows ) return scheme Walk ( user Path , new Attributes , STRING + user Path , NUM ) ; path = scheme Map . get ( STRING ) ; if ( path != null ) return path . scheme Walk ( user Path , new Attributes , STRING + user Path , NUM ) ; else return scheme Walk ( user Path , new Attributes , STRING + user Path , NUM ) ; } } path = scheme Map . get ( scheme ) ; if ( path == null ) { return scheme Walk ( user Path , new Attributes , user Path , NUM ) ; } else { return path . scheme Walk ( user Path , new Attributes , user Path , scheme . length ( ) + NUM ) ; } }
public Path Impl lookup Impl ( String user Path , Map < String , Object > new Attributes , boolean is Allow Root ) { if ( user Path == null ) { return lookup Impl ( get Path ( ) , new Attributes , is Allow Root ) ; } if ( ! is Allow Root ) { return scheme Walk ( user Path , new Attributes , user Path , NUM ) ; } String scheme = scan Scheme ( user Path ) ; if ( scheme == null ) { return scheme Walk ( user Path , new Attributes , user Path , NUM ) ; } Path Impl path ; Scheme Map scheme Map = scheme Map ; if ( is Windows ( ) ) { int length = scheme . length ( ) ; char ch ; if ( length == NUM && ( STRING <= ( ch = scheme . char At ( NUM ) ) && ch <= STRING || STRING <= ch && ch <= STRING ) ) { user Path = Character . to Lower Case ( ch ) + user Path . substring ( NUM ) ; if ( is Test Windows ) return scheme Walk ( user Path , new Attributes , STRING + user Path , NUM ) ; path = scheme Map . get ( STRING ) ; if ( path != null ) return path . scheme Walk ( user Path , new Attributes , STRING + user Path , NUM ) ; else return scheme Walk ( user Path , new Attributes , STRING + user Path , NUM ) ; } } path = scheme Map . get ( scheme ) ; if ( path == null ) { return scheme Walk ( user Path , new Attributes , user Path , NUM ) ; } else { return path . scheme Walk ( user Path , new Attributes , user Path , scheme . length ( ) + NUM ) ; } }
public static void copy File ( File in , File out ) throws IO Exception { File Input Stream fis = new File Input Stream ( in ) ; File Output Stream fos = new File Output Stream ( out ) ; try { copy Stream ( fis , fos ) ; } finally { fis . close ( ) ; fos . close ( ) ; } }
public Thread Interrupter ( ) { this ( Thread . current Thread ( ) ) ; }
default Document put All ( Map < ? extends Char Sequence , Object > fields ) { if ( fields != null ) { for ( Map . Entry < ? extends Char Sequence , Object > entry : fields . entry Set ( ) ) { set ( entry . get Key ( ) , entry . get Value ( ) ) ; } } return this ; }
public void test Create Element NS 1 ( ) throws Throwable { String namespace URI = STRING ; String malformed Name = STRING ; Document doc ; doc = ( Document ) load ( STRING , builder ) ; { boolean success = BOOL ; try { doc . create Element NS ( namespace URI , malformed Name ) ; } catch ( DOM Exception ex ) { success = ( ex . code == DOM Exception . NAMESPACE ERR ) ; } assert True ( STRING , success ) ; } }
private static int compare Locales ( Locale primary , Locale other ) { final String lang = primary . get Language ( ) ; if ( ( lang == null ) || ! lang . equals ( other . get Language ( ) ) ) { return NUM ; } final String country = primary . get Country ( ) ; if ( ( country == null ) || ! country . equals ( other . get Country ( ) ) ) { return NUM ; } final String variant = primary . get Variant ( ) ; if ( ( variant == null ) || ! variant . equals ( other . get Variant ( ) ) ) { return NUM ; } return NUM ; }
private static int compare Locales ( Locale primary , Locale other ) { final String lang = primary . get Language ( ) ; if ( ( lang == null ) || ! lang . equals ( other . get Language ( ) ) ) { return NUM ; } final String country = primary . get Country ( ) ; if ( ( country == null ) || ! country . equals ( other . get Country ( ) ) ) { return NUM ; } final String variant = primary . get Variant ( ) ; if ( ( variant == null ) || ! variant . equals ( other . get Variant ( ) ) ) { return NUM ; } return NUM ; }
private static int compare Locales ( Locale primary , Locale other ) { final String lang = primary . get Language ( ) ; if ( ( lang == null ) || ! lang . equals ( other . get Language ( ) ) ) { return NUM ; } final String country = primary . get Country ( ) ; if ( ( country == null ) || ! country . equals ( other . get Country ( ) ) ) { return NUM ; } final String variant = primary . get Variant ( ) ; if ( ( variant == null ) || ! variant . equals ( other . get Variant ( ) ) ) { return NUM ; } return NUM ; }
private static int compare Locales ( Locale primary , Locale other ) { final String lang = primary . get Language ( ) ; if ( ( lang == null ) || ! lang . equals ( other . get Language ( ) ) ) { return NUM ; } final String country = primary . get Country ( ) ; if ( ( country == null ) || ! country . equals ( other . get Country ( ) ) ) { return NUM ; } final String variant = primary . get Variant ( ) ; if ( ( variant == null ) || ! variant . equals ( other . get Variant ( ) ) ) { return NUM ; } return NUM ; }
public void on Save Instance State ( Bundle out State ) { Log . d ( TAG , STRING + nesting ) ; check Not Null ( out State , STRING ) ; Page page = peek ( ) ; save Page State ( page ) ; out State . put Serializable ( STACK TAG , ( Stack ) m Factory Stack . clone ( ) ) ; out State . put Bundle ( STATE TAG , ( Bundle ) m Page States . clone ( ) ) ; }
public void on Save Instance State ( Bundle out State ) { Log . d ( TAG , STRING + nesting ) ; check Not Null ( out State , STRING ) ; Page page = peek ( ) ; save Page State ( page ) ; out State . put Serializable ( STACK TAG , ( Stack ) m Factory Stack . clone ( ) ) ; out State . put Bundle ( STATE TAG , ( Bundle ) m Page States . clone ( ) ) ; }
private String read Fully ( Http URL Connection connection ) throws IO Exception { String response Body = STRING ; if ( connection . get Content Length ( ) != NUM ) { try { Input Stream in = connection . get Input Stream ( ) ; if ( in != null ) { response Body = read Stream Data ( in ) ; } } catch ( IO Exception e ) { Input Stream in = connection . get Error Stream ( ) ; if ( in != null ) { response Body = read Stream Data ( in ) ; } else { throw e ; } } } return response Body ; }
private String read Fully ( Http URL Connection connection ) throws IO Exception { String response Body = STRING ; if ( connection . get Content Length ( ) != NUM ) { try { Input Stream in = connection . get Input Stream ( ) ; if ( in != null ) { response Body = read Stream Data ( in ) ; } } catch ( IO Exception e ) { Input Stream in = connection . get Error Stream ( ) ; if ( in != null ) { response Body = read Stream Data ( in ) ; } else { throw e ; } } } return response Body ; }
public static Mosaic Definition create Mosaic Definition ( final Account creator ) { return create Mosaic Definition ( creator , Utils . create Mosaic Id ( STRING , STRING ) , create Mosaic Properties ( ) ) ; }
public Chunk Scan ( Table Info ti , long start Blk Num , long end Blk Num , Transaction tx ) { pages = new Array List < Record Page > ( ) ; this . start Blk Num = start Blk Num ; this . end Blk Num = end Blk Num ; this . schema = ti . schema ( ) ; this . file Name = ti . file Name ( ) ; for ( long i = start Blk Num ; i <= end Blk Num ; i ++ ) { Block Id blk = new Block Id ( file Name , i ) ; pages . add ( new Record Page ( blk , ti , tx , BOOL ) ) ; } before First ( ) ; }
public void test Split And Join Multiple Properties On Dot ( ) { Properties inner = Property Utils . split Properties On Delimiter ( ONE DOT TWO , STRING ) ; assert Equals ( STRING , inner . get Property ( STRING ) ) ; assert Equals ( STRING , inner . get Property ( STRING ) ) ; assert Equals ( NUM , inner . size ( ) ) ; try { assert Equals ( ONE DOT TWO , Property Utils . join On Delimiter ( Property Utils . to Map ( inner ) , STRING ) ) ; } catch ( Comparison Failure e ) { assert Equals ( TWO DOT ONE , Property Utils . join On Delimiter ( Property Utils . to Map ( inner ) , STRING ) ) ; } }
public void update Position ( Node node , double latitude , double longitude ) { node Positions . put ( node . get Id ( ) , new Position ( latitude , longitude ) ) ; refresh Single Layer ( node ) ; }
public static boolean replication Group Has No Other Snapshot ( Db Client db Client , String rg Name , Collection < URI > snapshots , URI storage ) { List < Block Snapshot > snapshots In RG = get Snapshots Part Of Replication Group ( rg Name , storage , db Client ) ; List < URI > snapshot U Rs In RG = new Array List ( transform ( snapshots In RG , fctn Data Object To ID ( ) ) ) ; s logger . info ( STRING , snapshots In RG . size ( ) , snapshots . size ( ) ) ; snapshot U Rs In RG . remove All ( snapshots ) ; return snapshot U Rs In RG . is Empty ( ) ; }
public static boolean replication Group Has No Other Snapshot ( Db Client db Client , String rg Name , Collection < URI > snapshots , URI storage ) { List < Block Snapshot > snapshots In RG = get Snapshots Part Of Replication Group ( rg Name , storage , db Client ) ; List < URI > snapshot U Rs In RG = new Array List ( transform ( snapshots In RG , fctn Data Object To ID ( ) ) ) ; s logger . info ( STRING , snapshots In RG . size ( ) , snapshots . size ( ) ) ; snapshot U Rs In RG . remove All ( snapshots ) ; return snapshot U Rs In RG . is Empty ( ) ; }
public Address mul ( final Object rhs ) { return new Address ( m value . multiply ( get Big Integer ( rhs ) ) ) ; }
public Address mul ( final Object rhs ) { return new Address ( m value . multiply ( get Big Integer ( rhs ) ) ) ; }
public Address mul ( final Object rhs ) { return new Address ( m value . multiply ( get Big Integer ( rhs ) ) ) ; }
@ Override public boolean equals ( Object other ) { if ( ! ( other instanceof Matrix ) ) { return BOOL ; } for ( int r = NUM ; r < rows ; r ++ ) { if ( ! Arrays . equals ( data [ r ] , ( ( Matrix ) other ) . data [ r ] ) ) { return BOOL ; } } return BOOL ; }
public static int color ARGB ( int color , double alpha ) { int rgb = color & NUM ; int a = ( int ) Strict Math . rint ( alpha * NUM ) ; int argb = rgb | ( a << NUM ) ; return argb ; }
public static int color ARGB ( int color , double alpha ) { int rgb = color & NUM ; int a = ( int ) Strict Math . rint ( alpha * NUM ) ; int argb = rgb | ( a << NUM ) ; return argb ; }
public static int color ARGB ( int color , double alpha ) { int rgb = color & NUM ; int a = ( int ) Strict Math . rint ( alpha * NUM ) ; int argb = rgb | ( a << NUM ) ; return argb ; }
public void add Popup Listener ( final Popup Listener listener ) { if ( ! popup Listeners . contains ( listener ) ) { popup Listeners . add ( listener ) ; } }
public void add Popup Listener ( final Popup Listener listener ) { if ( ! popup Listeners . contains ( listener ) ) { popup Listeners . add ( listener ) ; } }
public static double erf ( double x ) { return ( igamma ( NUM , Math . pow ( x , NUM ) ) ) ; }
static Cipher Suite value Of ( int id 1 , int id 2 ) { id 1 &= NUM ; id 2 &= NUM ; int id = ( id 1 << NUM ) | id 2 ; Cipher Suite c = id Map . get ( id ) ; if ( c == null ) { String h1 = Integer . to String ( id 1 , NUM ) ; String h2 = Integer . to String ( id 2 , NUM ) ; c = new Cipher Suite ( STRING + h1 + STRING + h2 , id ) ; } return c ; }
static Cipher Suite value Of ( int id 1 , int id 2 ) { id 1 &= NUM ; id 2 &= NUM ; int id = ( id 1 << NUM ) | id 2 ; Cipher Suite c = id Map . get ( id ) ; if ( c == null ) { String h1 = Integer . to String ( id 1 , NUM ) ; String h2 = Integer . to String ( id 2 , NUM ) ; c = new Cipher Suite ( STRING + h1 + STRING + h2 , id ) ; } return c ; }
static Cipher Suite value Of ( int id 1 , int id 2 ) { id 1 &= NUM ; id 2 &= NUM ; int id = ( id 1 << NUM ) | id 2 ; Cipher Suite c = id Map . get ( id ) ; if ( c == null ) { String h1 = Integer . to String ( id 1 , NUM ) ; String h2 = Integer . to String ( id 2 , NUM ) ; c = new Cipher Suite ( STRING + h1 + STRING + h2 , id ) ; } return c ; }
private void save Nested Variables ( ) { if ( nested Vars != null ) { Iterator < String > iter = nested Vars . iterator ( ) ; while ( iter . has Next ( ) ) { String var Name = iter . next ( ) ; var Name = find Alias ( var Name ) ; Object obj = invoking Jsp Ctxt . get Attribute ( var Name ) ; if ( obj != null ) { original Nested Vars . put ( var Name , obj ) ; } } } }
private void save Nested Variables ( ) { if ( nested Vars != null ) { Iterator < String > iter = nested Vars . iterator ( ) ; while ( iter . has Next ( ) ) { String var Name = iter . next ( ) ; var Name = find Alias ( var Name ) ; Object obj = invoking Jsp Ctxt . get Attribute ( var Name ) ; if ( obj != null ) { original Nested Vars . put ( var Name , obj ) ; } } } }
private void save Nested Variables ( ) { if ( nested Vars != null ) { Iterator < String > iter = nested Vars . iterator ( ) ; while ( iter . has Next ( ) ) { String var Name = iter . next ( ) ; var Name = find Alias ( var Name ) ; Object obj = invoking Jsp Ctxt . get Attribute ( var Name ) ; if ( obj != null ) { original Nested Vars . put ( var Name , obj ) ; } } } }
public Pla Point Int round ( ) { if ( is Na N ( ) ) return new Pla Point Int ( ) ; return new Pla Point Int ( Math . round ( v x ) , Math . round ( v y ) ) ; }
private double calc BIC ( Centroid Cluster Model best Model ) { double loglike = NUM ; int num Centers = best Model . get Number Of Clusters ( ) ; int num Dimensions = best Model . get Centroid Coordinates ( NUM ) . length ; int num Parameters = num Centers - NUM + num Centers * num Dimensions + num Centers ; for ( Cluster c : best Model . get Clusters ( ) ) { int current id = c . get Cluster Id ( ) ; loglike += log Likelihood Estimate ( c , best Model . get Centroid Coordinates ( current id ) , best Model . get Cluster Assignments ( example Set ) , num Centers ) ; } loglike -= num Parameters / NUM * Math . log ( examplesize ) ; return loglike ; }
private double calc BIC ( Centroid Cluster Model best Model ) { double loglike = NUM ; int num Centers = best Model . get Number Of Clusters ( ) ; int num Dimensions = best Model . get Centroid Coordinates ( NUM ) . length ; int num Parameters = num Centers - NUM + num Centers * num Dimensions + num Centers ; for ( Cluster c : best Model . get Clusters ( ) ) { int current id = c . get Cluster Id ( ) ; loglike += log Likelihood Estimate ( c , best Model . get Centroid Coordinates ( current id ) , best Model . get Cluster Assignments ( example Set ) , num Centers ) ; } loglike -= num Parameters / NUM * Math . log ( examplesize ) ; return loglike ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return MESSAGE ; default : return null ; } }
public void add Fileset ( File Set arg ) { file Sets . add ( arg ) ; }
public void add Fileset ( File Set arg ) { file Sets . add ( arg ) ; }
public void add Fileset ( File Set arg ) { file Sets . add ( arg ) ; }
public void add Fileset ( File Set arg ) { file Sets . add ( arg ) ; }
public static String to Channel ( String chan ) { if ( chan == null ) { return null ; } if ( ! validate Channel ( chan ) ) { return String Util . to Lower Case ( chan ) ; } if ( ! chan . starts With ( STRING ) ) { chan = STRING + chan ; } return String Util . to Lower Case ( chan ) ; }
public static String to Channel ( String chan ) { if ( chan == null ) { return null ; } if ( ! validate Channel ( chan ) ) { return String Util . to Lower Case ( chan ) ; } if ( ! chan . starts With ( STRING ) ) { chan = STRING + chan ; } return String Util . to Lower Case ( chan ) ; }
public String undo ( ) { if ( ! can Undo ( ) ) { return STRING ; } Undo Action undo Action = m undo Stack . get ( m n Current Edit Action ) ; m b Needs Undo Action = BOOL ; undo Action . undo ( ) ; m b Needs Undo Action = BOOL ; m n Current Edit Action -- ; return undo Action . get Undo Msg ( ) ; }
public String undo ( ) { if ( ! can Undo ( ) ) { return STRING ; } Undo Action undo Action = m undo Stack . get ( m n Current Edit Action ) ; m b Needs Undo Action = BOOL ; undo Action . undo ( ) ; m b Needs Undo Action = BOOL ; m n Current Edit Action -- ; return undo Action . get Undo Msg ( ) ; }
public String undo ( ) { if ( ! can Undo ( ) ) { return STRING ; } Undo Action undo Action = m undo Stack . get ( m n Current Edit Action ) ; m b Needs Undo Action = BOOL ; undo Action . undo ( ) ; m b Needs Undo Action = BOOL ; m n Current Edit Action -- ; return undo Action . get Undo Msg ( ) ; }
public String undo ( ) { if ( ! can Undo ( ) ) { return STRING ; } Undo Action undo Action = m undo Stack . get ( m n Current Edit Action ) ; m b Needs Undo Action = BOOL ; undo Action . undo ( ) ; m b Needs Undo Action = BOOL ; m n Current Edit Action -- ; return undo Action . get Undo Msg ( ) ; }
@ Safe Varargs public final Item Adapter < Item > add ( int position , Item ... items ) { return add ( position , as List ( items ) ) ; }
@ Safe Varargs public final Item Adapter < Item > add ( int position , Item ... items ) { return add ( position , as List ( items ) ) ; }
public synchronized void run Task ( Runnable task ) { if ( ! is Alive ) { throw new Illegal State Exception ( ) ; } if ( task != null ) { task Queue . add ( task ) ; notify ( ) ; } }
public synchronized void run Task ( Runnable task ) { if ( ! is Alive ) { throw new Illegal State Exception ( ) ; } if ( task != null ) { task Queue . add ( task ) ; notify ( ) ; } }
public static double distance ( Lat Lng point A , Lat Lng point B ) { double lat = Math . to Radians ( point A . latitude ) ; double lat 2 = Math . to Radians ( point B . latitude ) ; double dif Lat = Math . to Radians ( point B . latitude - point A . latitude ) ; double dif Long = Math . to Radians ( point B . longitude - point A . longitude ) ; double a = ( Math . pow ( Math . sin ( dif Lat / NUM ) , NUM ) ) + ( Math . cos ( lat ) * Math . cos ( lat 2 ) * Math . pow ( Math . sin ( dif Long / NUM ) , NUM ) ) ; double c = NUM * Math . atan 2 ( Math . sqrt ( a ) , Math . sqrt ( NUM - a ) ) ; return EARTH * c ; }
public void add ( int what , Download Request download Request , Download Listener download Listener ) { if ( download Request . in Queue ( ) ) Logger . w ( STRING ) ; else { download Request . set Queue ( m Un Finish Queue ) ; download Request . on Pre Response ( what , download Listener ) ; download Request . set Sequence ( m Integer . increment And Get ( ) ) ; m Un Finish Queue . add ( download Request ) ; m Download Queue . add ( download Request ) ; } }
public void add ( int what , Download Request download Request , Download Listener download Listener ) { if ( download Request . in Queue ( ) ) Logger . w ( STRING ) ; else { download Request . set Queue ( m Un Finish Queue ) ; download Request . on Pre Response ( what , download Listener ) ; download Request . set Sequence ( m Integer . increment And Get ( ) ) ; m Un Finish Queue . add ( download Request ) ; m Download Queue . add ( download Request ) ; } }
protected List < Map Node [ ] > subdivide Problem ( List < Map Node > markers , Osm Map map , Map Way Filter way Filter ) { List < Map Node [ ] > result = new Array List < Map Node [ ] > ( ) ; Map Node from Node = map . get Nearest Way Node ( new Position ( markers . get ( NUM ) ) , way Filter ) ; for ( int i = NUM ; i < markers . size ( ) ; i ++ ) { Map Node to Node = map . get Nearest Way Node ( new Position ( markers . get ( i ) ) , way Filter ) ; result . add ( new Map Node [ ] { from Node , to Node } ) ; from Node = to Node ; } return result ; }
protected List < Map Node [ ] > subdivide Problem ( List < Map Node > markers , Osm Map map , Map Way Filter way Filter ) { List < Map Node [ ] > result = new Array List < Map Node [ ] > ( ) ; Map Node from Node = map . get Nearest Way Node ( new Position ( markers . get ( NUM ) ) , way Filter ) ; for ( int i = NUM ; i < markers . size ( ) ; i ++ ) { Map Node to Node = map . get Nearest Way Node ( new Position ( markers . get ( i ) ) , way Filter ) ; result . add ( new Map Node [ ] { from Node , to Node } ) ; from Node = to Node ; } return result ; }
protected List < Map Node [ ] > subdivide Problem ( List < Map Node > markers , Osm Map map , Map Way Filter way Filter ) { List < Map Node [ ] > result = new Array List < Map Node [ ] > ( ) ; Map Node from Node = map . get Nearest Way Node ( new Position ( markers . get ( NUM ) ) , way Filter ) ; for ( int i = NUM ; i < markers . size ( ) ; i ++ ) { Map Node to Node = map . get Nearest Way Node ( new Position ( markers . get ( i ) ) , way Filter ) ; result . add ( new Map Node [ ] { from Node , to Node } ) ; from Node = to Node ; } return result ; }
public D Get New Password ( J Frame parent , Dialog . Modality Type modality , Password Quality Config password Quality Config ) { super ( parent , res . get String ( STRING ) , modality ) ; this . password Quality Config = password Quality Config ; init Components ( ) ; }
public D Get New Password ( J Frame parent , Dialog . Modality Type modality , Password Quality Config password Quality Config ) { super ( parent , res . get String ( STRING ) , modality ) ; this . password Quality Config = password Quality Config ; init Components ( ) ; }
public D Get New Password ( J Frame parent , Dialog . Modality Type modality , Password Quality Config password Quality Config ) { super ( parent , res . get String ( STRING ) , modality ) ; this . password Quality Config = password Quality Config ; init Components ( ) ; }
public static java . sql . Timestamp now Timestamp ( ) { return get Timestamp ( System . current Time Millis ( ) ) ; }
public < U > Mono Then Ignore < U > shift ( Mono < U > new Last ) { Objects . require Non Null ( new Last , STRING ) ; Mono < ? > [ ] a = ignore ; int n = a . length ; Mono < ? > [ ] b = new Mono [ n + NUM ] ; System . arraycopy ( a , NUM , b , NUM , n ) ; b [ n ] = last ; return new Mono Then Ignore < > ( b , new Last ) ; }
public < U > Mono Then Ignore < U > shift ( Mono < U > new Last ) { Objects . require Non Null ( new Last , STRING ) ; Mono < ? > [ ] a = ignore ; int n = a . length ; Mono < ? > [ ] b = new Mono [ n + NUM ] ; System . arraycopy ( a , NUM , b , NUM , n ) ; b [ n ] = last ; return new Mono Then Ignore < > ( b , new Last ) ; }
@ Safe Varargs protected < T extends Abstract Option Value < ? , ? > > Abstract Options ( Function < T , T > value Filter , Abstract Options base Options , T ... values ) { require Non Null ( base Options , STRING ) ; require Non Null ( value Filter , STRING ) ; require Non Null ( values , STRING ) ; value Map = new Identity Hash Map < > ( base Options . value Map ) ; put All ( value Filter , Stream . of ( values ) ) ; }
public static Jpa Module new Client Module ( String resource Search Package ) { return new Jpa Module ( resource Search Package ) ; }
private static Object compress Uuid ( String uuid ) { Matcher matcher = COMPRESSIBLE UUID . matcher ( uuid ) ; if ( uuid . length ( ) == NUM && matcher . matches ( ) ) { return Integer . value Of ( matcher . group ( NUM ) ) ; } return uuid ; }
private static Object compress Uuid ( String uuid ) { Matcher matcher = COMPRESSIBLE UUID . matcher ( uuid ) ; if ( uuid . length ( ) == NUM && matcher . matches ( ) ) { return Integer . value Of ( matcher . group ( NUM ) ) ; } return uuid ; }
private static Object compress Uuid ( String uuid ) { Matcher matcher = COMPRESSIBLE UUID . matcher ( uuid ) ; if ( uuid . length ( ) == NUM && matcher . matches ( ) ) { return Integer . value Of ( matcher . group ( NUM ) ) ; } return uuid ; }
public static void check HTTP Request Length ( Http Servlet Request request ) throws Servlet Exception { int max Content Length = SAML Utils . get Max Content Length ( ) ; if ( max Content Length != NUM ) { int length = request . get Content Length ( ) ; if ( length == - NUM ) { throw new Servlet Exception ( bundle . get String ( STRING ) ) ; } if ( length > max Content Length ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + length ) ; } throw new Servlet Exception ( bundle . get String ( STRING ) ) ; } } }
public static void check HTTP Request Length ( Http Servlet Request request ) throws Servlet Exception { int max Content Length = SAML Utils . get Max Content Length ( ) ; if ( max Content Length != NUM ) { int length = request . get Content Length ( ) ; if ( length == - NUM ) { throw new Servlet Exception ( bundle . get String ( STRING ) ) ; } if ( length > max Content Length ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + length ) ; } throw new Servlet Exception ( bundle . get String ( STRING ) ) ; } } }
public static void check HTTP Request Length ( Http Servlet Request request ) throws Servlet Exception { int max Content Length = SAML Utils . get Max Content Length ( ) ; if ( max Content Length != NUM ) { int length = request . get Content Length ( ) ; if ( length == - NUM ) { throw new Servlet Exception ( bundle . get String ( STRING ) ) ; } if ( length > max Content Length ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + length ) ; } throw new Servlet Exception ( bundle . get String ( STRING ) ) ; } } }
public static void check HTTP Request Length ( Http Servlet Request request ) throws Servlet Exception { int max Content Length = SAML Utils . get Max Content Length ( ) ; if ( max Content Length != NUM ) { int length = request . get Content Length ( ) ; if ( length == - NUM ) { throw new Servlet Exception ( bundle . get String ( STRING ) ) ; } if ( length > max Content Length ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + length ) ; } throw new Servlet Exception ( bundle . get String ( STRING ) ) ; } } }
public static void check HTTP Request Length ( Http Servlet Request request ) throws Servlet Exception { int max Content Length = SAML Utils . get Max Content Length ( ) ; if ( max Content Length != NUM ) { int length = request . get Content Length ( ) ; if ( length == - NUM ) { throw new Servlet Exception ( bundle . get String ( STRING ) ) ; } if ( length > max Content Length ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + length ) ; } throw new Servlet Exception ( bundle . get String ( STRING ) ) ; } } }
public static void check HTTP Request Length ( Http Servlet Request request ) throws Servlet Exception { int max Content Length = SAML Utils . get Max Content Length ( ) ; if ( max Content Length != NUM ) { int length = request . get Content Length ( ) ; if ( length == - NUM ) { throw new Servlet Exception ( bundle . get String ( STRING ) ) ; } if ( length > max Content Length ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + length ) ; } throw new Servlet Exception ( bundle . get String ( STRING ) ) ; } } }
public static void check HTTP Request Length ( Http Servlet Request request ) throws Servlet Exception { int max Content Length = SAML Utils . get Max Content Length ( ) ; if ( max Content Length != NUM ) { int length = request . get Content Length ( ) ; if ( length == - NUM ) { throw new Servlet Exception ( bundle . get String ( STRING ) ) ; } if ( length > max Content Length ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + length ) ; } throw new Servlet Exception ( bundle . get String ( STRING ) ) ; } } }
public void update Terminal Points ( mx Cell State state , Object source , Object target ) { if ( target != null ) { update Terminal Point ( state , target , source , BOOL ) ; } if ( source != null ) { update Terminal Point ( state , source , target , BOOL ) ; } }
private static void generate Graph File ( Trans Meta trans Meta , String graph File ) throws Graph Generator Exception { Data Output Stream dos = null ; try { String xml = trans Meta . get XML ( ) ; dos = new Data Output Stream ( new File Output Stream ( new File ( graph File ) ) ) ; dos . write ( xml . get Bytes ( Carbon Common Constants . DEFAULT CHARSET ) ) ; } catch ( Kettle Exception kettel Exception ) { throw new Graph Generator Exception ( STRING , kettel Exception ) ; } catch ( File Not Found Exception e ) { throw new Graph Generator Exception ( STRING , e ) ; } catch ( Unsupported Encoding Exception ue ) { throw new Graph Generator Exception ( STRING , ue ) ; } catch ( IO Exception ioe ) { throw new Graph Generator Exception ( STRING , ioe ) ; } finally { if ( dos != null ) { try { dos . close ( ) ; } catch ( IO Exception e ) { e . get Message ( ) ; } } } }
public static List < ? extends Import Module > perform Import ( @ Non Null Gradle Import importer , @ Non Null Collection < Eclipse Project > projects ) { List < Eclipse Import Module > modules = Lists . new Array List ( ) ; List < Eclipse Import Module > replaced By Dependencies = Lists . new Array List ( ) ; for ( Eclipse Project project : projects ) { Eclipse Import Module module = new Eclipse Import Module ( importer , project ) ; module . initialize ( ) ; if ( module . is Replaced With Dependency ( ) ) { replaced By Dependencies . add ( module ) ; } else { modules . add ( module ) ; } } for ( Eclipse Import Module replaced : replaced By Dependencies ) { assert replaced . get Replace With Dependencies ( ) != null ; Eclipse Project project = replaced . get Project ( ) ; for ( Eclipse Import Module module : modules ) { if ( module . get Project ( ) . get All Libraries ( ) . contains ( project ) ) { module . add Dependencies ( replaced . get Replace With Dependencies ( ) ) ; } } } for ( Eclipse Import Module module : modules ) { module . remove Jar Dependencies ( ) ; } Collections . sort ( modules ) ; return modules ; }
public static File write J Unit Test File ( String junit Output Dir , String package Name , Executable Sequence es , String class Name ) { Junit File Writer writer = new Junit File Writer ( junit Output Dir , package Name , STRING ) ; writer . create Output Dir ( ) ; return writer . write Test Class ( Collections . singleton List ( es ) , class Name ) ; }
public static File write J Unit Test File ( String junit Output Dir , String package Name , Executable Sequence es , String class Name ) { Junit File Writer writer = new Junit File Writer ( junit Output Dir , package Name , STRING ) ; writer . create Output Dir ( ) ; return writer . write Test Class ( Collections . singleton List ( es ) , class Name ) ; }
public static void compute Polygon Normal ( Float Buffer vertex Buffer , Float Buffer normal Buffer , boolean z Pos ) { int n = vertex Buffer . limit ( ) ; double count = NUM ; Vector 3 mean Normal = new Vector 3 ( ) ; Vector 3 vec 0 = new Vector 3 ( ) ; Vector 3 vec 1 = new Vector 3 ( ) ; Vector 3 vec 2 = new Vector 3 ( ) ; mean Normal . set ( NUM , NUM , NUM ) ; for ( int i = NUM ; i < n ; i += NUM ) { vec 0 . set ( vertex Buffer . get ( i ) , vertex Buffer . get ( i + NUM ) , vertex Buffer . get ( i + NUM ) ) ; vec 1 . set ( vertex Buffer . get ( i + NUM ) , vertex Buffer . get ( i + NUM ) , vertex Buffer . get ( i + NUM ) ) ; vec 2 . set ( vertex Buffer . get ( i + NUM ) , vertex Buffer . get ( i + NUM ) , vertex Buffer . get ( i + NUM ) ) ; vec 0 . subtract Local ( vec 1 ) ; vec 1 . subtract Local ( vec 2 ) ; vec 0 . cross Local ( vec 1 ) ; if ( z Pos && ( vec 0 . get Z ( ) < NUM ) ) { vec 0 . negate Local ( ) ; } mean Normal . add Local ( vec 0 ) ; count ++ ; } mean Normal . multiply Local ( NUM / count ) ; mean Normal . normalize Local ( ) ; for ( int i = NUM ; i < vertex Buffer . limit ( ) ; i += NUM ) { normal Buffer . put ( mean Normal . get Xf ( ) ) ; normal Buffer . put ( mean Normal . get Yf ( ) ) ; normal Buffer . put ( mean Normal . get Zf ( ) ) ; } normal Buffer . flip ( ) ; }
public static void add Combo Box ( final J Panel panel , final J Combo Box < String > combo Box , final String description , final String hint , final boolean value ) { Preconditions . check Not Null ( panel , STRING ) ; Preconditions . check Not Null ( combo Box , STRING ) ; Preconditions . check Not Null ( description , STRING ) ; combo Box . add Item ( STRING ) ; combo Box . add Item ( STRING ) ; combo Box . set Selected Item ( value ? STRING : STRING ) ; combo Box . set Preferred Size ( new Dimension ( PREFERRED WIDTH , PREFERRED HEIGHT ) ) ; add Component ( panel , combo Box , description , hint ) ; }
private Reader create UTF 8 Reader ( Input Stream stream ) { return new UTF 8 Reader ( stream , f Temp String . ch . length , f Error Reporter . get Message Formatter ( XML Message Formatter . XML DOMAIN ) , f Error Reporter . get Locale ( ) ) ; }
public void add Permitted Domain ( String domain Name ) { if ( String Utils . is Empty ( domain Name ) ) { return ; } if ( permitted Domains == null ) { permitted Domains = new Array List < > ( ) ; } permitted Domains . add ( domain Name ) ; }
private void add Combine Menu ( final J Frame parent , final I Trace List Provider trace Provider , final int [ ] selected Rows ) { add Separator ( ) ; final J Menu combine Menu = new J Menu ( STRING ) ; final List < Trace List > traces = get Traces ( trace Provider , selected Rows ) ; combine Menu . add ( C Action Proxy . proxy ( new C Action Combine Traces ( parent , trace Provider , traces ) ) ) ; combine Menu . add ( C Action Proxy . proxy ( new C Action Intersect Traces ( parent , trace Provider , traces ) ) ) ; if ( traces . size ( ) == NUM ) { combine Menu . add Separator ( ) ; combine Menu . add ( C Action Proxy . proxy ( new C Action Difference Traces ( parent , trace Provider , traces . get ( NUM ) , traces . get ( NUM ) ) ) ) ; combine Menu . add ( C Action Proxy . proxy ( new C Action Difference Traces ( parent , trace Provider , traces . get ( NUM ) , traces . get ( NUM ) ) ) ) ; } add ( combine Menu ) ; }
private void add Combine Menu ( final J Frame parent , final I Trace List Provider trace Provider , final int [ ] selected Rows ) { add Separator ( ) ; final J Menu combine Menu = new J Menu ( STRING ) ; final List < Trace List > traces = get Traces ( trace Provider , selected Rows ) ; combine Menu . add ( C Action Proxy . proxy ( new C Action Combine Traces ( parent , trace Provider , traces ) ) ) ; combine Menu . add ( C Action Proxy . proxy ( new C Action Intersect Traces ( parent , trace Provider , traces ) ) ) ; if ( traces . size ( ) == NUM ) { combine Menu . add Separator ( ) ; combine Menu . add ( C Action Proxy . proxy ( new C Action Difference Traces ( parent , trace Provider , traces . get ( NUM ) , traces . get ( NUM ) ) ) ) ; combine Menu . add ( C Action Proxy . proxy ( new C Action Difference Traces ( parent , trace Provider , traces . get ( NUM ) , traces . get ( NUM ) ) ) ) ; } add ( combine Menu ) ; }
private void add Combine Menu ( final J Frame parent , final I Trace List Provider trace Provider , final int [ ] selected Rows ) { add Separator ( ) ; final J Menu combine Menu = new J Menu ( STRING ) ; final List < Trace List > traces = get Traces ( trace Provider , selected Rows ) ; combine Menu . add ( C Action Proxy . proxy ( new C Action Combine Traces ( parent , trace Provider , traces ) ) ) ; combine Menu . add ( C Action Proxy . proxy ( new C Action Intersect Traces ( parent , trace Provider , traces ) ) ) ; if ( traces . size ( ) == NUM ) { combine Menu . add Separator ( ) ; combine Menu . add ( C Action Proxy . proxy ( new C Action Difference Traces ( parent , trace Provider , traces . get ( NUM ) , traces . get ( NUM ) ) ) ) ; combine Menu . add ( C Action Proxy . proxy ( new C Action Difference Traces ( parent , trace Provider , traces . get ( NUM ) , traces . get ( NUM ) ) ) ) ; } add ( combine Menu ) ; }
public void cancel Requests By TAG ( Object TAG , boolean may Interrupt If Running ) { if ( TAG == null ) { return ; } for ( List < Request Handle > request List : request Map . values ( ) ) { if ( request List != null ) { for ( Request Handle request Handle : request List ) { if ( TAG . equals ( request Handle . get Tag ( ) ) ) request Handle . cancel ( may Interrupt If Running ) ; } } } }
public void cancel Requests By TAG ( Object TAG , boolean may Interrupt If Running ) { if ( TAG == null ) { return ; } for ( List < Request Handle > request List : request Map . values ( ) ) { if ( request List != null ) { for ( Request Handle request Handle : request List ) { if ( TAG . equals ( request Handle . get Tag ( ) ) ) request Handle . cancel ( may Interrupt If Running ) ; } } } }
public void cancel Requests By TAG ( Object TAG , boolean may Interrupt If Running ) { if ( TAG == null ) { return ; } for ( List < Request Handle > request List : request Map . values ( ) ) { if ( request List != null ) { for ( Request Handle request Handle : request List ) { if ( TAG . equals ( request Handle . get Tag ( ) ) ) request Handle . cancel ( may Interrupt If Running ) ; } } } }
public void cancel Requests By TAG ( Object TAG , boolean may Interrupt If Running ) { if ( TAG == null ) { return ; } for ( List < Request Handle > request List : request Map . values ( ) ) { if ( request List != null ) { for ( Request Handle request Handle : request List ) { if ( TAG . equals ( request Handle . get Tag ( ) ) ) request Handle . cancel ( may Interrupt If Running ) ; } } } }
private static Access Control Context create Privileged Context ( Class caller , Access Control Context acc ) { Domain Combiner comb = acc . get Domain Combiner ( ) ; Protection Domain pd = caller . get Protection Domain ( ) ; Protection Domain [ ] pds = ( pd != null ) ? new Protection Domain [ ] { pd } : null ; if ( comb != null ) { pds = comb . combine ( pds , null ) ; } if ( pds == null ) { pds = new Protection Domain [ NUM ] ; } return new Access Control Context ( new Access Control Context ( pds ) , comb ) ; }
private static Access Control Context create Privileged Context ( Class caller , Access Control Context acc ) { Domain Combiner comb = acc . get Domain Combiner ( ) ; Protection Domain pd = caller . get Protection Domain ( ) ; Protection Domain [ ] pds = ( pd != null ) ? new Protection Domain [ ] { pd } : null ; if ( comb != null ) { pds = comb . combine ( pds , null ) ; } if ( pds == null ) { pds = new Protection Domain [ NUM ] ; } return new Access Control Context ( new Access Control Context ( pds ) , comb ) ; }
private static Access Control Context create Privileged Context ( Class caller , Access Control Context acc ) { Domain Combiner comb = acc . get Domain Combiner ( ) ; Protection Domain pd = caller . get Protection Domain ( ) ; Protection Domain [ ] pds = ( pd != null ) ? new Protection Domain [ ] { pd } : null ; if ( comb != null ) { pds = comb . combine ( pds , null ) ; } if ( pds == null ) { pds = new Protection Domain [ NUM ] ; } return new Access Control Context ( new Access Control Context ( pds ) , comb ) ; }
private static Access Control Context create Privileged Context ( Class caller , Access Control Context acc ) { Domain Combiner comb = acc . get Domain Combiner ( ) ; Protection Domain pd = caller . get Protection Domain ( ) ; Protection Domain [ ] pds = ( pd != null ) ? new Protection Domain [ ] { pd } : null ; if ( comb != null ) { pds = comb . combine ( pds , null ) ; } if ( pds == null ) { pds = new Protection Domain [ NUM ] ; } return new Access Control Context ( new Access Control Context ( pds ) , comb ) ; }
private static Access Control Context create Privileged Context ( Class caller , Access Control Context acc ) { Domain Combiner comb = acc . get Domain Combiner ( ) ; Protection Domain pd = caller . get Protection Domain ( ) ; Protection Domain [ ] pds = ( pd != null ) ? new Protection Domain [ ] { pd } : null ; if ( comb != null ) { pds = comb . combine ( pds , null ) ; } if ( pds == null ) { pds = new Protection Domain [ NUM ] ; } return new Access Control Context ( new Access Control Context ( pds ) , comb ) ; }
private void send Committed Text ( ) { Attributed String as = new Attributed String ( buffer . to String ( ) ) ; context . dispatch Input Method Event ( Input Method Event . INPUT METHOD TEXT CHANGED , as . get Iterator ( ) , buffer . length ( ) , Text Hit Info . leading ( insertion Point ) , null ) ; buffer . set Length ( NUM ) ; insertion Point = NUM ; format = UNSET ; }
public double snap ( double value ) { if ( grid Enabled ) { value = Math . round ( value / grid Size ) * grid Size ; } return value ; }
public Key Pair generate Key Pair ( ) throws Key Store Exception { Key Pair key Pair ; try { Key Pair Generator generator = Key Pair Generator . get Instance ( STRING ) ; generator . initialize ( NUM ) ; key Pair = generator . generate Key Pair ( ) ; } catch ( No Such Algorithm Exception e ) { throw new Key Store Exception ( STRING , e ) ; } return key Pair ; }
public final static boolean in Long Range ( char [ ] digit Chars , int offset , int len , boolean negative ) { String cmp Str = negative ? MIN LONG STR NO SIGN : MAX LONG STR ; int cmp Len = cmp Str . length ( ) ; if ( len < cmp Len ) return BOOL ; if ( len > cmp Len ) return BOOL ; for ( int i = NUM ; i < cmp Len ; ++ i ) { if ( digit Chars [ offset + i ] > cmp Str . char At ( i ) ) { return BOOL ; } } return BOOL ; }
public final static boolean in Long Range ( char [ ] digit Chars , int offset , int len , boolean negative ) { String cmp Str = negative ? MIN LONG STR NO SIGN : MAX LONG STR ; int cmp Len = cmp Str . length ( ) ; if ( len < cmp Len ) return BOOL ; if ( len > cmp Len ) return BOOL ; for ( int i = NUM ; i < cmp Len ; ++ i ) { if ( digit Chars [ offset + i ] > cmp Str . char At ( i ) ) { return BOOL ; } } return BOOL ; }
public final static boolean in Long Range ( char [ ] digit Chars , int offset , int len , boolean negative ) { String cmp Str = negative ? MIN LONG STR NO SIGN : MAX LONG STR ; int cmp Len = cmp Str . length ( ) ; if ( len < cmp Len ) return BOOL ; if ( len > cmp Len ) return BOOL ; for ( int i = NUM ; i < cmp Len ; ++ i ) { if ( digit Chars [ offset + i ] > cmp Str . char At ( i ) ) { return BOOL ; } } return BOOL ; }
public final static boolean in Long Range ( char [ ] digit Chars , int offset , int len , boolean negative ) { String cmp Str = negative ? MIN LONG STR NO SIGN : MAX LONG STR ; int cmp Len = cmp Str . length ( ) ; if ( len < cmp Len ) return BOOL ; if ( len > cmp Len ) return BOOL ; for ( int i = NUM ; i < cmp Len ; ++ i ) { if ( digit Chars [ offset + i ] > cmp Str . char At ( i ) ) { return BOOL ; } } return BOOL ; }
public final static boolean in Long Range ( char [ ] digit Chars , int offset , int len , boolean negative ) { String cmp Str = negative ? MIN LONG STR NO SIGN : MAX LONG STR ; int cmp Len = cmp Str . length ( ) ; if ( len < cmp Len ) return BOOL ; if ( len > cmp Len ) return BOOL ; for ( int i = NUM ; i < cmp Len ; ++ i ) { if ( digit Chars [ offset + i ] > cmp Str . char At ( i ) ) { return BOOL ; } } return BOOL ; }
public final static boolean in Long Range ( char [ ] digit Chars , int offset , int len , boolean negative ) { String cmp Str = negative ? MIN LONG STR NO SIGN : MAX LONG STR ; int cmp Len = cmp Str . length ( ) ; if ( len < cmp Len ) return BOOL ; if ( len > cmp Len ) return BOOL ; for ( int i = NUM ; i < cmp Len ; ++ i ) { if ( digit Chars [ offset + i ] > cmp Str . char At ( i ) ) { return BOOL ; } } return BOOL ; }
public static String extract From Code 128 ( String code ) { if ( code . length ( ) < NUM ) { return null ; } if ( code . starts With ( STRING ) || code . starts With ( STRING ) ) { return code . substring ( NUM , NUM ) ; } return null ; }
private void update Status Label ( ) { String text = STRING ; if ( search Result != null ) { switch ( search Result . size ( ) ) { case NUM : text = STRING ; break ; case NUM : text = STRING ; break ; default : text = STRING + ( search Result Index + NUM ) + STRING + search Result . size ( ) + STRING ; } } status Text . set Text ( text ) ; }
private void update Status Label ( ) { String text = STRING ; if ( search Result != null ) { switch ( search Result . size ( ) ) { case NUM : text = STRING ; break ; case NUM : text = STRING ; break ; default : text = STRING + ( search Result Index + NUM ) + STRING + search Result . size ( ) + STRING ; } } status Text . set Text ( text ) ; }
public final synchronized Offset find Or Create Jtoc Offset ( ) { if ( VM . Verify Assertions ) VM . assert ( ! is Static ( ) && ! is Object Initializer ( ) ) ; Offset jtoc Offset = get Jtoc Offset ( ) ; ; if ( jtoc Offset . EQ ( Offset . zero ( ) ) ) { jtoc Offset = Statics . allocate Reference Slot ( BOOL ) ; Statics . set Slot Contents ( jtoc Offset , get Current Entry Code Array ( ) ) ; synchronized ( jtoc Offsets ) { jtoc Offsets . put ( this , Integer . value Of ( jtoc Offset . to Int ( ) ) ) ; } } return jtoc Offset ; }
public Update Response remove ( long id ) throws IO Exception , Solr Server Exception { Update Response res = solr Client . delete By Id ( String . value Of ( id ) ) ; solr Client . commit ( BOOL , BOOL , BOOL ) ; return res ; }
void STAR encoding diag 1 ( ) { int i , j , stripe , k ; char [ ] [ ] tmp ; tmp = new char [ block nbr + NUM ] [ block size ] ; for ( stripe = NUM ; stripe < block nbr + NUM ; stripe ++ ) { for ( i = NUM ; i < data disk nbr ; i ++ ) { for ( j = NUM ; j < block size ; j ++ ) { k = ( stripe - i + p ) % p ; if ( k < block nbr ) { tmp [ stripe ] [ j ] ^= check data [ i ] [ ( stripe - i + p ) % p * block size + j ] ; } } } } for ( i = NUM ; i < block nbr ; i ++ ) { for ( j = NUM ; j < block size ; j ++ ) { tmp [ i ] [ j ] = ( char ) ( tmp [ i ] [ j ] ^ tmp [ block nbr ] [ j ] ) ; } } for ( i = NUM ; i < block nbr ; i ++ ) { System . arraycopy ( tmp [ i ] , NUM , check data [ data disk nbr + NUM ] , i * block size , block size ) ; } }
void STAR encoding diag 1 ( ) { int i , j , stripe , k ; char [ ] [ ] tmp ; tmp = new char [ block nbr + NUM ] [ block size ] ; for ( stripe = NUM ; stripe < block nbr + NUM ; stripe ++ ) { for ( i = NUM ; i < data disk nbr ; i ++ ) { for ( j = NUM ; j < block size ; j ++ ) { k = ( stripe - i + p ) % p ; if ( k < block nbr ) { tmp [ stripe ] [ j ] ^= check data [ i ] [ ( stripe - i + p ) % p * block size + j ] ; } } } } for ( i = NUM ; i < block nbr ; i ++ ) { for ( j = NUM ; j < block size ; j ++ ) { tmp [ i ] [ j ] = ( char ) ( tmp [ i ] [ j ] ^ tmp [ block nbr ] [ j ] ) ; } } for ( i = NUM ; i < block nbr ; i ++ ) { System . arraycopy ( tmp [ i ] , NUM , check data [ data disk nbr + NUM ] , i * block size , block size ) ; } }
@ Override public String to String ( ) { String Builder result = new String Builder ( ) ; result . append ( type . to String ( ) ) ; result . append ( STRING ) ; result . append ( name ) ; result . append ( STRING ) ; if ( fields Data != null ) { result . append ( fields Data ) ; } result . append ( STRING ) ; return result . to String ( ) ; }
public void run Test ( ) throws Throwable { Document doc ; Entity Reference ent Ref ; Character Data ent Text ; doc = ( Document ) load ( STRING , BOOL ) ; ent Ref = doc . create Entity Reference ( STRING ) ; assert Not Null ( STRING , ent Ref ) ; ent Text = ( Character Data ) ent Ref . get First Child ( ) ; assert Not Null ( STRING , ent Text ) ; { boolean success = BOOL ; try { ent Text . set Node Value ( STRING ) ; } catch ( DOM Exception ex ) { success = ( ex . code == DOM Exception . NO MODIFICATION ALLOWED ERR ) ; } assert True ( STRING , success ) ; } }
protected Mutable Coord calculate Point On Line ( Mutable Coord P1 , Mutable Coord P2 , Mutable Coord P3 ) { double rel = calculate Relation ( P1 , P2 , P3 ) ; double dx = Math . abs ( P1 . get X ( ) - P2 . get X ( ) ) , dy = Math . abs ( P1 . get Y ( ) - P2 . get Y ( ) ) ; double nx = P1 . get X ( ) + dx * rel , ny = P1 . get Y ( ) + dy * rel ; if ( P1 . get X ( ) > P2 . get X ( ) ) nx = P1 . get X ( ) - dx * rel ; if ( P1 . get Y ( ) > P2 . get Y ( ) ) ny = P1 . get Y ( ) - dy * rel ; Mutable Coord result = new Mutable Coord ( nx , ny ) ; return result ; }
public static void check Convergence From Any Host ( Service Host host , Node Group State ngs , Operation parent Op ) { check Convergence Across Peers ( host , ngs , parent Op ) ; }
public static void check Convergence From Any Host ( Service Host host , Node Group State ngs , Operation parent Op ) { check Convergence Across Peers ( host , ngs , parent Op ) ; }
public static void check Convergence From Any Host ( Service Host host , Node Group State ngs , Operation parent Op ) { check Convergence Across Peers ( host , ngs , parent Op ) ; }
public static void check Convergence From Any Host ( Service Host host , Node Group State ngs , Operation parent Op ) { check Convergence Across Peers ( host , ngs , parent Op ) ; }
public void cache Resolved Method ( Class clas , Class [ ] types , Method method ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + clas + STRING + method ) ; Signature Key sk = new Signature Key ( clas , method . get Name ( ) , types ) ; if ( Modifier . is Static ( method . get Modifiers ( ) ) ) resolved Static Methods . put ( sk , method ) ; else resolved Object Methods . put ( sk , method ) ; }
public void cache Resolved Method ( Class clas , Class [ ] types , Method method ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + clas + STRING + method ) ; Signature Key sk = new Signature Key ( clas , method . get Name ( ) , types ) ; if ( Modifier . is Static ( method . get Modifiers ( ) ) ) resolved Static Methods . put ( sk , method ) ; else resolved Object Methods . put ( sk , method ) ; }
public void cache Resolved Method ( Class clas , Class [ ] types , Method method ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + clas + STRING + method ) ; Signature Key sk = new Signature Key ( clas , method . get Name ( ) , types ) ; if ( Modifier . is Static ( method . get Modifiers ( ) ) ) resolved Static Methods . put ( sk , method ) ; else resolved Object Methods . put ( sk , method ) ; }
public void cache Resolved Method ( Class clas , Class [ ] types , Method method ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + clas + STRING + method ) ; Signature Key sk = new Signature Key ( clas , method . get Name ( ) , types ) ; if ( Modifier . is Static ( method . get Modifiers ( ) ) ) resolved Static Methods . put ( sk , method ) ; else resolved Object Methods . put ( sk , method ) ; }
public void cache Resolved Method ( Class clas , Class [ ] types , Method method ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + clas + STRING + method ) ; Signature Key sk = new Signature Key ( clas , method . get Name ( ) , types ) ; if ( Modifier . is Static ( method . get Modifiers ( ) ) ) resolved Static Methods . put ( sk , method ) ; else resolved Object Methods . put ( sk , method ) ; }
public void cache Resolved Method ( Class clas , Class [ ] types , Method method ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + clas + STRING + method ) ; Signature Key sk = new Signature Key ( clas , method . get Name ( ) , types ) ; if ( Modifier . is Static ( method . get Modifiers ( ) ) ) resolved Static Methods . put ( sk , method ) ; else resolved Object Methods . put ( sk , method ) ; }
public Java 2 Type Script Translator ( Transpilation Handler log Handler , J Sweet Context context , JC Compilation Unit compilation Unit , boolean preserve Source Line Numbers ) { super ( log Handler , context , compilation Unit , new Java 2 Type Script Adapter ( context ) , preserve Source Line Numbers ) ; }
private I Preference Store create Combined Preference Store ( I Editor Input input ) { List stores = new Array List ( ) ; add Preference Stores ( stores , input ) ; return new Chained Preference Store ( ( I Preference Store [ ] ) stores . to Array ( new I Preference Store [ stores . size ( ) ] ) ) ; }
public void remove Element At ( int index ) { if ( get Element At ( index ) == m selected Object ) { if ( index == NUM ) set Selected Item ( get Size ( ) == NUM ? null : get Element At ( index + NUM ) ) ; else set Selected Item ( get Element At ( index - NUM ) ) ; } p data . remove ( index ) ; fire Interval Removed ( this , index , index ) ; }
public void remove Element At ( int index ) { if ( get Element At ( index ) == m selected Object ) { if ( index == NUM ) set Selected Item ( get Size ( ) == NUM ? null : get Element At ( index + NUM ) ) ; else set Selected Item ( get Element At ( index - NUM ) ) ; } p data . remove ( index ) ; fire Interval Removed ( this , index , index ) ; }
@ Zap Api Ignore public boolean is Confirm Remove Proxy Excluded Domain ( ) { return this . confirm Remove Proxy Exclude Domain ; }
public static final XPATH Error Resources load Resource Bundle ( String class Name ) throws Missing Resource Exception { Locale locale = Locale . get Default ( ) ; String suffix = get Resource Suffix ( locale ) ; try { return ( XPATH Error Resources ) Resource Bundle . get Bundle ( class Name + suffix , locale ) ; } catch ( Missing Resource Exception e ) { try { return ( XPATH Error Resources ) Resource Bundle . get Bundle ( class Name , new Locale ( STRING , STRING ) ) ; } catch ( Missing Resource Exception e2 ) { throw new Missing Resource Exception ( STRING , class Name , STRING ) ; } } }
public void add ( int start , int end , int handler , int type ) { if ( start < end ) entries . add ( new Exception Table Entry ( start , end , handler , type ) ) ; }
public void add ( int start , int end , int handler , int type ) { if ( start < end ) entries . add ( new Exception Table Entry ( start , end , handler , type ) ) ; }
protected void check Result By Text ( @ Non Nls @ Not Null String file Text ) { check Result By Text ( null , file Text , BOOL , null ) ; }
@ Override public boolean equals ( Object o ) { if ( this == o ) return BOOL ; if ( o == null || get Class ( ) != o . get Class ( ) ) return BOOL ; Abstract User Notification that = ( Abstract User Notification ) o ; return ! ( notification Configuration != null ? ! notification Configuration . equals ( that . notification Configuration ) : that . notification Configuration != null ) ; }
void on Update ( Data data ) ;
public static void write Var Int ( Output Stream out , int x ) throws IO Exception { while ( ( x & ~ NUM ) != NUM ) { out . write ( ( byte ) ( NUM | ( x & NUM ) ) ) ; x >>>= NUM ; } out . write ( ( byte ) x ) ; }
public static Buffered Image convert To ARGB ( Buffered Image image ) { if ( image . get Type ( ) != Buffered Image . TYPE INT ARGB ) { try { final Buffered Image raw image = image ; image = new Buffered Image ( raw image . get Width ( ) , raw image . get Height ( ) , Buffered Image . TYPE INT ARGB ) ; final Color Convert Op xform Op = new Color Convert Op ( null ) ; xform Op . filter ( raw image , image ) ; } catch ( final Exception e ) { Log Writer . write Log ( STRING + e + STRING ) ; } } is Using ARGB = BOOL ; return image ; }
public static Buffered Image convert To ARGB ( Buffered Image image ) { if ( image . get Type ( ) != Buffered Image . TYPE INT ARGB ) { try { final Buffered Image raw image = image ; image = new Buffered Image ( raw image . get Width ( ) , raw image . get Height ( ) , Buffered Image . TYPE INT ARGB ) ; final Color Convert Op xform Op = new Color Convert Op ( null ) ; xform Op . filter ( raw image , image ) ; } catch ( final Exception e ) { Log Writer . write Log ( STRING + e + STRING ) ; } } is Using ARGB = BOOL ; return image ; }
public static Buffered Image convert To ARGB ( Buffered Image image ) { if ( image . get Type ( ) != Buffered Image . TYPE INT ARGB ) { try { final Buffered Image raw image = image ; image = new Buffered Image ( raw image . get Width ( ) , raw image . get Height ( ) , Buffered Image . TYPE INT ARGB ) ; final Color Convert Op xform Op = new Color Convert Op ( null ) ; xform Op . filter ( raw image , image ) ; } catch ( final Exception e ) { Log Writer . write Log ( STRING + e + STRING ) ; } } is Using ARGB = BOOL ; return image ; }
public static Buffered Image convert To ARGB ( Buffered Image image ) { if ( image . get Type ( ) != Buffered Image . TYPE INT ARGB ) { try { final Buffered Image raw image = image ; image = new Buffered Image ( raw image . get Width ( ) , raw image . get Height ( ) , Buffered Image . TYPE INT ARGB ) ; final Color Convert Op xform Op = new Color Convert Op ( null ) ; xform Op . filter ( raw image , image ) ; } catch ( final Exception e ) { Log Writer . write Log ( STRING + e + STRING ) ; } } is Using ARGB = BOOL ; return image ; }
public static int calculate RMS Level ( short [ ] audio Data , int numframes ) { long l Sum = NUM ; int numread = NUM ; for ( short s : audio Data ) { l Sum = l Sum + s ; numread ++ ; if ( numread == numframes ) break ; } double d Avg = l Sum / numframes ; double sum Mean Square = NUM ; numread = NUM ; for ( short an Audio Data : audio Data ) { sum Mean Square = sum Mean Square + Math . pow ( an Audio Data - d Avg , NUM ) ; numread ++ ; if ( numread == numframes ) break ; } double average Mean Square = sum Mean Square / numframes ; return ( int ) ( Math . pow ( average Mean Square , NUM ) + NUM ) ; }
private void calculate D ( double [ ] b ) { int length = m Extremal Indices . size ( ) - NUM ; mD = new double [ length ] ; for ( int k = NUM ; k < length ; k ++ ) { mD [ k ] = b [ k ] * ( m Grid . get Cosine Frequency Grid ( ) [ m Extremal Indices . get ( k ) ] - m Grid . get Cosine Frequency Grid ( ) [ m Extremal Indices . get ( length ) ] ) ; } }
public void add Attribute Panel Listener ( Attribute Panel Listener a ) { m Listeners . add ( a ) ; }
private static String capital First ( @ Nullable String str ) { return str == null ? null : str . is Empty ( ) ? STRING : Character . to Upper Case ( str . char At ( NUM ) ) + str . substring ( NUM ) ; }
public void store Step Data ( URI workflow URI , String key , String step Id , Object data ) { Workflow Step Data data Record = get Workflow Step Data ( workflow URI , step Id , key ) ; boolean created = BOOL ; if ( data Record == null ) { data Record = new Workflow Step Data ( ) ; data Record . set Id ( URI Util . create Id ( Workflow Step Data . class ) ) ; data Record . set Workflow Id ( workflow URI ) ; data Record . set Step Id ( step Id ) ; data Record . set Label ( key ) ; created = BOOL ; } data Record . set Data ( Generic Serializer . serialize ( data ) ) ; if ( created ) { db Client . create Object ( data Record ) ; log . info ( String . format ( STRING , workflow URI , step Id , key ) ) ; } else { db Client . update Object ( data Record ) ; log . info ( String . format ( STRING , workflow URI , step Id , key ) ) ; } }
public void store Step Data ( URI workflow URI , String key , String step Id , Object data ) { Workflow Step Data data Record = get Workflow Step Data ( workflow URI , step Id , key ) ; boolean created = BOOL ; if ( data Record == null ) { data Record = new Workflow Step Data ( ) ; data Record . set Id ( URI Util . create Id ( Workflow Step Data . class ) ) ; data Record . set Workflow Id ( workflow URI ) ; data Record . set Step Id ( step Id ) ; data Record . set Label ( key ) ; created = BOOL ; } data Record . set Data ( Generic Serializer . serialize ( data ) ) ; if ( created ) { db Client . create Object ( data Record ) ; log . info ( String . format ( STRING , workflow URI , step Id , key ) ) ; } else { db Client . update Object ( data Record ) ; log . info ( String . format ( STRING , workflow URI , step Id , key ) ) ; } }
public void append Local Variable Label ( I Local Variable local Variable , long flags ) { if ( get Flag ( flags , Java Element Labels . F PRE TYPE SIGNATURE ) ) { append Type Signature Label ( local Variable , local Variable . get Type Signature ( ) , flags ) ; f Buffer . append ( STRING ) ; } if ( get Flag ( flags , Java Element Labels . F FULLY QUALIFIED ) ) { append Element Label ( local Variable . get Declaring Member ( ) , Java Element Labels . M PARAMETER TYPES | Java Element Labels . M FULLY QUALIFIED | Java Element Labels . T FULLY QUALIFIED | ( flags & QUALIFIER FLAGS ) ) ; f Buffer . append ( STRING ) ; } f Buffer . append ( get Element Name ( local Variable ) ) ; if ( get Flag ( flags , Java Element Labels . F APP TYPE SIGNATURE ) ) { int offset = f Buffer . length ( ) ; f Buffer . append ( Java Element Labels . DECL STRING ) ; append Type Signature Label ( local Variable , local Variable . get Type Signature ( ) , flags ) ; if ( get Flag ( flags , Java Element Labels . COLORIZE ) ) { } } if ( get Flag ( flags , Java Element Labels . F POST QUALIFIED ) ) { f Buffer . append ( Java Element Labels . CONCAT STRING ) ; append Element Label ( local Variable . get Declaring Member ( ) , Java Element Labels . M PARAMETER TYPES | Java Element Labels . M FULLY QUALIFIED | Java Element Labels . T FULLY QUALIFIED | ( flags & QUALIFIER FLAGS ) ) ; } }
public void message ( Map headers , String body ) { transmit ( Command . MESSAGE , headers , body ) ; }
public void remove Stat ( String key ) throws Ade Internal Exception { if ( ! m all Keys . remove ( key ) ) { throw new Ade Internal Exception ( STRING + key ) ; } if ( m double Stats . remove ( key ) == null && m string Stats . remove ( key ) == null ) { throw new Ade Internal Exception ( STRING ) ; } }
private double sin ( double angle ) { while ( angle >= NUM ) { angle -= NUM ; } double value = angle / NUM * Math . PI ; return Math . sin ( value ) ; }
public static String add To List ( String new Item , String semicolon Sep List , int max Items ) { String Builder sb = new String Builder ( new Item ) ; String [ ] items = semicolon Sep List . split ( STRING ) ; for ( int i = NUM ; i < items . length && i < max Items ; i ++ ) { String port = items [ i ] ; if ( port . equals ( new Item ) ) { continue ; } sb . append ( STRING ) ; sb . append ( port ) ; } return sb . to String ( ) ; }
public void add Marker ( ) { Cluster Order order = get Cluster Order ( ) ; DBID Selection sel Context = context . get Selection ( ) ; if ( sel Context != null ) { DBI Ds selection = DBID Util . ensure Set ( sel Context . get Selected Ids ( ) ) ; final double width = plotwidth / order . size ( ) ; int begin = - NUM , j = NUM ; for ( DBID Iter it = order . iter ( ) ; it . valid ( ) ; it . advance ( ) , j ++ ) { if ( selection . contains ( it ) ) { if ( begin == - NUM ) { begin = j ; } } else { if ( begin != - NUM ) { Element marker = add Marker Rect ( begin * width , ( j - begin ) * width ) ; SVG Util . add CSS Class ( marker , CSS MARKER ) ; mtag . append Child ( marker ) ; begin = - NUM ; } } } if ( begin != - NUM ) { Element marker = add Marker Rect ( begin * width , ( order . size ( ) - begin ) * width ) ; SVG Util . add CSS Class ( marker , CSS MARKER ) ; mtag . append Child ( marker ) ; } } }
public void add Marker ( ) { Cluster Order order = get Cluster Order ( ) ; DBID Selection sel Context = context . get Selection ( ) ; if ( sel Context != null ) { DBI Ds selection = DBID Util . ensure Set ( sel Context . get Selected Ids ( ) ) ; final double width = plotwidth / order . size ( ) ; int begin = - NUM , j = NUM ; for ( DBID Iter it = order . iter ( ) ; it . valid ( ) ; it . advance ( ) , j ++ ) { if ( selection . contains ( it ) ) { if ( begin == - NUM ) { begin = j ; } } else { if ( begin != - NUM ) { Element marker = add Marker Rect ( begin * width , ( j - begin ) * width ) ; SVG Util . add CSS Class ( marker , CSS MARKER ) ; mtag . append Child ( marker ) ; begin = - NUM ; } } } if ( begin != - NUM ) { Element marker = add Marker Rect ( begin * width , ( order . size ( ) - begin ) * width ) ; SVG Util . add CSS Class ( marker , CSS MARKER ) ; mtag . append Child ( marker ) ; } } }
static void add Temporal Level Constraint To Constants ( Hash Set params , Set Of Level Constraints constrs ) { Iterator iter = params . iterator ( ) ; while ( iter . has Next ( ) ) { Level Node node = ( Level Node ) iter . next ( ) ; if ( node . get Kind ( ) == Constant Decl Kind ) { constrs . put ( node , Levels [ Action Level ] ) ; } ; } }
static void add Temporal Level Constraint To Constants ( Hash Set params , Set Of Level Constraints constrs ) { Iterator iter = params . iterator ( ) ; while ( iter . has Next ( ) ) { Level Node node = ( Level Node ) iter . next ( ) ; if ( node . get Kind ( ) == Constant Decl Kind ) { constrs . put ( node , Levels [ Action Level ] ) ; } ; } }
public String to String By Value ( ) { Long Array List the Keys = new Long Array List ( ) ; keys Sorted By Value ( the Keys ) ; String Buffer buf = new String Buffer ( ) ; buf . append ( STRING ) ; int max Index = the Keys . size ( ) - NUM ; for ( int i = NUM ; i <= max Index ; i ++ ) { long key = the Keys . get ( i ) ; buf . append ( String . value Of ( key ) ) ; buf . append ( STRING ) ; buf . append ( String . value Of ( get ( key ) ) ) ; if ( i < max Index ) buf . append ( STRING ) ; } buf . append ( STRING ) ; return buf . to String ( ) ; }
public String to String By Value ( ) { Long Array List the Keys = new Long Array List ( ) ; keys Sorted By Value ( the Keys ) ; String Buffer buf = new String Buffer ( ) ; buf . append ( STRING ) ; int max Index = the Keys . size ( ) - NUM ; for ( int i = NUM ; i <= max Index ; i ++ ) { long key = the Keys . get ( i ) ; buf . append ( String . value Of ( key ) ) ; buf . append ( STRING ) ; buf . append ( String . value Of ( get ( key ) ) ) ; if ( i < max Index ) buf . append ( STRING ) ; } buf . append ( STRING ) ; return buf . to String ( ) ; }
public String to String By Value ( ) { Long Array List the Keys = new Long Array List ( ) ; keys Sorted By Value ( the Keys ) ; String Buffer buf = new String Buffer ( ) ; buf . append ( STRING ) ; int max Index = the Keys . size ( ) - NUM ; for ( int i = NUM ; i <= max Index ; i ++ ) { long key = the Keys . get ( i ) ; buf . append ( String . value Of ( key ) ) ; buf . append ( STRING ) ; buf . append ( String . value Of ( get ( key ) ) ) ; if ( i < max Index ) buf . append ( STRING ) ; } buf . append ( STRING ) ; return buf . to String ( ) ; }
boolean remove Entry ( Policy Entry pe ) { parser . remove ( pe . get Grant Entry ( ) ) ; modified = BOOL ; return ( policy Entries . remove Element ( pe ) ) ; }
static private String INT Min ( ) { int temp Value = Integer . MIN VALUE ; return String . value Of ( temp Value ) ; }
public void update Visible Ids ( List < Integer > priority ) { if ( m Native Tab Content Manager != NUM ) { int ids Size = Math . min ( m Full Res Thumbnails Max Size , priority . size ( ) ) ; if ( ids Size != m Priority Tab Ids . length ) { m Priority Tab Ids = new int [ ids Size ] ; } for ( int i = NUM ; i < ids Size ; i ++ ) { m Priority Tab Ids [ i ] = priority . get ( i ) ; } native Update Visible Ids ( m Native Tab Content Manager , m Priority Tab Ids ) ; } }
private Segment create Disk Segment ( Segment Descriptor descriptor ) { File segment File = Segment File . create Segment File ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ; Buffer buffer = File Buffer . allocate ( segment File , Math . min ( DEFAULT BUFFER SIZE , descriptor . max Segment Size ( ) ) , Integer . MAX VALUE ) ; descriptor . copy To ( buffer ) ; Segment segment = new Segment ( new Segment File ( segment File ) , buffer . slice ( ) , descriptor , create Index ( descriptor ) , new Offset Predicate ( ) , serializer . clone ( ) , this ) ; LOGGER . debug ( STRING , segment ) ; return segment ; }
private void grestore ( ) { int count = mG State Stack . size ( ) ; mG State Stack . remove ( count - NUM ) ; mPS Stream . println ( GRESTORE STR ) ; }
private void grestore ( ) { int count = mG State Stack . size ( ) ; mG State Stack . remove ( count - NUM ) ; mPS Stream . println ( GRESTORE STR ) ; }
public void handle Cache Removal ( Cache cache ) throws Management Exception { if ( ! is Service Initialised ( STRING ) ) { return ; } this . service Initialised = BOOL ; try { clean Up Monitors ( ) ; clean Bridge Resources ( ) ; } catch ( Exception e ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( e . get Message ( ) , e ) ; } } try { service . close ( ) ; } catch ( Exception e ) { logger . warn ( e . get Message ( ) , e ) ; } finally { this . cache Impl = null ; this . service = null ; this . member M Bean Bridge = null ; this . member Bean = null ; this . member Level Notif Emitter = null ; } }
public void handle Cache Removal ( Cache cache ) throws Management Exception { if ( ! is Service Initialised ( STRING ) ) { return ; } this . service Initialised = BOOL ; try { clean Up Monitors ( ) ; clean Bridge Resources ( ) ; } catch ( Exception e ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( e . get Message ( ) , e ) ; } } try { service . close ( ) ; } catch ( Exception e ) { logger . warn ( e . get Message ( ) , e ) ; } finally { this . cache Impl = null ; this . service = null ; this . member M Bean Bridge = null ; this . member Bean = null ; this . member Level Notif Emitter = null ; } }
static void send Raw Line ( Pirc Bot bot , Buffered Writer bwriter , String line ) { if ( line . length ( ) > bot . get Max Line Length ( ) - NUM ) { line = line . substring ( NUM , bot . get Max Line Length ( ) - NUM ) ; } synchronized ( bwriter ) { try { bwriter . write ( line + STRING ) ; bwriter . flush ( ) ; } catch ( Exception e ) { } } }
public synchronized void add Property Change Listener ( Property Change Listener listener ) { if ( listener List == null ) { listener List = new Vector < Property Change Listener > ( ) ; } listener List . add ( listener ) ; }
public synchronized void add Property Change Listener ( Property Change Listener listener ) { if ( listener List == null ) { listener List = new Vector < Property Change Listener > ( ) ; } listener List . add ( listener ) ; }
public synchronized void add Property Change Listener ( Property Change Listener listener ) { if ( listener List == null ) { listener List = new Vector < Property Change Listener > ( ) ; } listener List . add ( listener ) ; }
public int read Int ( ) throws IO Exception { int v = data Input . read Int ( ) ; offset += NUM ; available -= NUM ; return v ; }
public boolean is Loaded ( String name ) { Plugin Holder < T > result = registry . get ( name ) ; if ( result == null ) return BOOL ; return result . is Loaded ( ) ; }
protected Varargs execute ( String command ) { return varargs Of ( NIL , value Of ( STRING ) , ONE ) ; }
public Script Executor Task Status call ( ) throws Exception { Script Method Request request ; while ( ( request = requests . poll ( ) ) != null ) { Script Method Response response = null ; try { String method = request . get Method ( ) ; Object argument = request . get Argument ( ) ; Object value = executor . execute ( method , argument ) ; response = new Script Method Response ( request , value , null , BOOL ) ; } catch ( Throwable t ) { response = new Script Method Response ( request , null , t , BOOL ) ; String msg = format Error Message ( request ) ; logger . error ( msg , response . get Throwable ( ) ) ; Script Executor Task Status status = new Script Executor Task Status ( count . get ( ) , BOOL , response ) ; return status ; } finally { responses . add ( response ) ; } count . increment And Get ( ) ; } return new Script Executor Task Status ( count . get ( ) , BOOL , null ) ; }
public Table Builder add Column ( Column Builder column ) { if ( escape Identifiers ) { column . escape Name ( ) ; } columns . add ( column ) ; return this ; }
protected void clear Cache ( ) { if ( cache != null ) { cache . clear ( ) ; cache = null ; } }
private void validate User Namespace Authorization Create Request ( User Namespace Authorization Create Request request ) { Assert . not Null ( request , STRING ) ; validate User Namespace Authorization Key ( request . get User Namespace Authorization Key ( ) ) ; validate Namespace Permissions ( request . get Namespace Permissions ( ) ) ; }
private void validate User Namespace Authorization Create Request ( User Namespace Authorization Create Request request ) { Assert . not Null ( request , STRING ) ; validate User Namespace Authorization Key ( request . get User Namespace Authorization Key ( ) ) ; validate Namespace Permissions ( request . get Namespace Permissions ( ) ) ; }
public synchronized void connected ( Bluetooth Socket socket , Bluetooth Device device , final String socket Type ) { log . debug ( STRING + socket Type ) ; if ( m Bt Connect Thread != null ) { m Bt Connect Thread . cancel ( ) ; m Bt Connect Thread = null ; } if ( m Bt Worker Thread != null ) { m Bt Worker Thread . cancel ( ) ; m Bt Worker Thread = null ; } connection Established ( device . get Name ( ) ) ; m Bt Worker Thread = new Bt Worker Thread ( socket , socket Type ) ; m Bt Worker Thread . start ( ) ; }
public synchronized void connected ( Bluetooth Socket socket , Bluetooth Device device , final String socket Type ) { log . debug ( STRING + socket Type ) ; if ( m Bt Connect Thread != null ) { m Bt Connect Thread . cancel ( ) ; m Bt Connect Thread = null ; } if ( m Bt Worker Thread != null ) { m Bt Worker Thread . cancel ( ) ; m Bt Worker Thread = null ; } connection Established ( device . get Name ( ) ) ; m Bt Worker Thread = new Bt Worker Thread ( socket , socket Type ) ; m Bt Worker Thread . start ( ) ; }
private void describe Danger ( int danger Level ) { glass Pane . set Tool Tip Text ( danger Level Strings [ danger Level ] ) ; }
private void describe Danger ( int danger Level ) { glass Pane . set Tool Tip Text ( danger Level Strings [ danger Level ] ) ; }
private void describe Danger ( int danger Level ) { glass Pane . set Tool Tip Text ( danger Level Strings [ danger Level ] ) ; }
static public void assert Top Aligned ( View first , View second , int margin ) { int [ ] xy = new int [ NUM ] ; first . get Location On Screen ( xy ) ; int first Top = xy [ NUM ] ; second . get Location On Screen ( xy ) ; int second Top = xy [ NUM ] ; assert Equals ( STRING , Math . abs ( first Top - second Top ) , margin ) ; }
public static void view Mms Message Attachment ( Activity activity , Uri msg Uri , Slideshow Model slideshow , Async Dialog async Dialog ) { view Mms Message Attachment ( activity , msg Uri , slideshow , NUM , async Dialog ) ; }
public static void view Mms Message Attachment ( Activity activity , Uri msg Uri , Slideshow Model slideshow , Async Dialog async Dialog ) { view Mms Message Attachment ( activity , msg Uri , slideshow , NUM , async Dialog ) ; }
public static void view Mms Message Attachment ( Activity activity , Uri msg Uri , Slideshow Model slideshow , Async Dialog async Dialog ) { view Mms Message Attachment ( activity , msg Uri , slideshow , NUM , async Dialog ) ; }
public static void view Mms Message Attachment ( Activity activity , Uri msg Uri , Slideshow Model slideshow , Async Dialog async Dialog ) { view Mms Message Attachment ( activity , msg Uri , slideshow , NUM , async Dialog ) ; }
public static void view Mms Message Attachment ( Activity activity , Uri msg Uri , Slideshow Model slideshow , Async Dialog async Dialog ) { view Mms Message Attachment ( activity , msg Uri , slideshow , NUM , async Dialog ) ; }
public static void view Mms Message Attachment ( Activity activity , Uri msg Uri , Slideshow Model slideshow , Async Dialog async Dialog ) { view Mms Message Attachment ( activity , msg Uri , slideshow , NUM , async Dialog ) ; }
public static void view Mms Message Attachment ( Activity activity , Uri msg Uri , Slideshow Model slideshow , Async Dialog async Dialog ) { view Mms Message Attachment ( activity , msg Uri , slideshow , NUM , async Dialog ) ; }
public static void view Mms Message Attachment ( Activity activity , Uri msg Uri , Slideshow Model slideshow , Async Dialog async Dialog ) { view Mms Message Attachment ( activity , msg Uri , slideshow , NUM , async Dialog ) ; }
public static void view Mms Message Attachment ( Activity activity , Uri msg Uri , Slideshow Model slideshow , Async Dialog async Dialog ) { view Mms Message Attachment ( activity , msg Uri , slideshow , NUM , async Dialog ) ; }
public static void view Mms Message Attachment ( Activity activity , Uri msg Uri , Slideshow Model slideshow , Async Dialog async Dialog ) { view Mms Message Attachment ( activity , msg Uri , slideshow , NUM , async Dialog ) ; }
private Collection < Var > migrate Columns ( SQL Table current Table ) { List < Var > vars = new Array List < > ( ) ; String table Type = current Table . get Entity Type ( ) ; Map < String , Resource Type . Data Type > columns = current Table . get Columns ( ) ; Map < String , String > foreign Columns = current Table . get Foreign Key Columns ( ) ; for ( String column : columns . key Set ( ) ) { Resource Type . Data Type column Type = columns . get ( column ) ; if ( foreign Columns . contains Key ( column ) ) { vars . add All ( migrate As Relation ( table Type , column , foreign Columns . get ( column ) ) ) ; } else { vars . add All ( migrate As Resource ( table Type , column Type , column ) ) ; } } return vars ; }
public static void add Minutes To List ( Context context , Array List < Integer > values , Array List < String > labels , int minutes ) { int index = values . index Of ( minutes ) ; if ( index != - NUM ) { return ; } String label = construct Reminder Label ( context , minutes , BOOL ) ; int len = values . size ( ) ; for ( int i = NUM ; i < len ; i ++ ) { if ( minutes < values . get ( i ) ) { values . add ( i , minutes ) ; labels . add ( i , label ) ; return ; } } values . add ( minutes ) ; labels . add ( len , label ) ; }
public static void add Minutes To List ( Context context , Array List < Integer > values , Array List < String > labels , int minutes ) { int index = values . index Of ( minutes ) ; if ( index != - NUM ) { return ; } String label = construct Reminder Label ( context , minutes , BOOL ) ; int len = values . size ( ) ; for ( int i = NUM ; i < len ; i ++ ) { if ( minutes < values . get ( i ) ) { values . add ( i , minutes ) ; labels . add ( i , label ) ; return ; } } values . add ( minutes ) ; labels . add ( len , label ) ; }
private void read From Properties ( final Properties props , final boolean default Minimized , final int default X , final int default Y , final boolean default Visible ) { minimized = Boolean . parse Boolean ( props . get Property ( STRING + name + STRING , Boolean . to String ( default Minimized ) ) ) ; visible = Boolean . parse Boolean ( props . get Property ( STRING + name + STRING , Boolean . to String ( default Visible ) ) ) ; x = Integer . parse Int ( props . get Property ( STRING + name + STRING , Integer . to String ( default X ) ) ) ; y = Integer . parse Int ( props . get Property ( STRING + name + STRING , Integer . to String ( default Y ) ) ) ; }
public Class Location create Class ( ) { Class Location cl = new Class Location ( ) ; class Locations . add ( cl ) ; return cl ; }
public final void write Double ( double val ) throws IO Exception { write Long ( Double . double To Long Bits ( val ) ) ; }
synchronized void update Auth Config Globals ( Service Schema Manager scm ) throws SMS Exception { Service Schema schema = scm . get Organization Schema ( ) ; schema = schema . get Sub Schema ( STRING ) ; schema = schema . get Sub Schema ( STRING ) ; Map attrs = schema . get Attribute Defaults ( ) ; if ( attrs != null ) { default Service Success URL Set = ( Set ) attrs . get ( IS Auth Constants . LOGIN SUCCESS URL ) ; default Service Failure URL Set = ( Set ) attrs . get ( IS Auth Constants . LOGIN FAILURE URL ) ; } if ( debug . message Enabled ( ) ) { debug . message ( STRING + default Service Success URL Set ) ; debug . message ( STRING + default Service Failure URL Set ) ; } }
public Integer read ( String value ) { return Integer . value Of ( value ) ; }
public Integer read ( String value ) { return Integer . value Of ( value ) ; }
public Integer read ( String value ) { return Integer . value Of ( value ) ; }
@ Known Failure ( STRING ) public void test Update 6 ( ) throws SQL Exception { Database Creator . fill FK Cascade Table ( conn ) ; try { statement . execute Update ( STRING + Database Creator . FKCASCADE TABLE + STRING ) ; fail ( STRING ) ; } catch ( SQL Exception ex ) { } }
@ Known Failure ( STRING ) public void test Update 6 ( ) throws SQL Exception { Database Creator . fill FK Cascade Table ( conn ) ; try { statement . execute Update ( STRING + Database Creator . FKCASCADE TABLE + STRING ) ; fail ( STRING ) ; } catch ( SQL Exception ex ) { } }
public synchronized void trim To Size ( ) { if ( element Data . length != element Count ) { grow ( element Count ) ; } }
public synchronized void trim To Size ( ) { if ( element Data . length != element Count ) { grow ( element Count ) ; } }
public void register On Shared Preference Change Listener ( On Shared Preference Change Listener listener ) { if ( listener != null ) { register Listener ( listener ) ; } }
protected abstract M new Map Instance ( ) ;
public void clear Directory ( File directory ) { if ( directory . exists ( ) ) { for ( File file : directory . list Files ( ) ) { file . delete ( ) ; } } }
public void clear Directory ( File directory ) { if ( directory . exists ( ) ) { for ( File file : directory . list Files ( ) ) { file . delete ( ) ; } } }
public void remove ( int amount ) { int size = stack . size ( ) ; for ( int i = size - NUM ; i > size - NUM - amount ; i -- ) { pop With Message ( i ) ; } }
public void remove ( int amount ) { int size = stack . size ( ) ; for ( int i = size - NUM ; i > size - NUM - amount ; i -- ) { pop With Message ( i ) ; } }
public void remove ( int amount ) { int size = stack . size ( ) ; for ( int i = size - NUM ; i > size - NUM - amount ; i -- ) { pop With Message ( i ) ; } }
public void compactify ( ) { m Instances . trim To Size ( ) ; }
public void compactify ( ) { m Instances . trim To Size ( ) ; }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String child Value ; int child Length ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; child . append Data ( STRING ) ; child Value = child . get Data ( ) ; child Length = child Value . length ( ) ; assert Equals ( STRING , NUM , child Length ) ; }
public void add Option To Select ( String option ) { if ( options To Select == null ) { options To Select = new Linked List < > ( ) ; } options To Select . add ( option ) ; }
public static Public Key read X 509 Public Key ( byte [ ] encoded ) throws Exception { X509 Encoded Key Spec x509 Encoded Public Key = new X509 Encoded Key Spec ( encoded ) ; return KEY FACTORY . generate Public ( x509 Encoded Public Key ) ; }
protected boolean is Completely Suppressed ( Node Spec node Spec ) { if ( node Spec . get Suppression ( ) == null ) { return BOOL ; } switch ( node Spec . get Suppression ( ) ) { case ENTITY CONFIGURATION : return BOOL ; case GENERATED CODE : return BOOL ; case GENERATED CODE SETTER : return BOOL ; default : throw new Illegal State Exception ( STRING + node Spec . get Suppression ( ) ) ; } }
private boolean allow Upload Crash Dump ( ) { if ( is Cellular Experiment Enabled ( ) ) return is Usage And Crash Reporting Enabled ( ) ; if ( is Mobile Network Capable ( ) ) { String option = m Shared Preferences . get String ( PREF CRASH DUMP UPLOAD , m Crash Dump Never Upload ) ; return option . equals ( m Crash Dump Always Upload ) || ( option . equals ( m Crash Dump Wifi Only Upload ) && is Wi Fi Or Ethernet Network ( ) ) ; } return m Shared Preferences . get Boolean ( PREF CRASH DUMP UPLOAD NO CELLULAR , BOOL ) ; }
private boolean allow Upload Crash Dump ( ) { if ( is Cellular Experiment Enabled ( ) ) return is Usage And Crash Reporting Enabled ( ) ; if ( is Mobile Network Capable ( ) ) { String option = m Shared Preferences . get String ( PREF CRASH DUMP UPLOAD , m Crash Dump Never Upload ) ; return option . equals ( m Crash Dump Always Upload ) || ( option . equals ( m Crash Dump Wifi Only Upload ) && is Wi Fi Or Ethernet Network ( ) ) ; } return m Shared Preferences . get Boolean ( PREF CRASH DUMP UPLOAD NO CELLULAR , BOOL ) ; }
@ Override protected String translate ( final String name ) { return STRING + name + STRING ; }
@ Override protected String translate ( final String name ) { return STRING + name + STRING ; }
public void init ( Cipher Parameters param ) { if ( param instanceof Parameters With Random ) { Parameters With Random r Param = ( Parameters With Random ) param ; key = ( RSA Key Parameters ) r Param . get Parameters ( ) ; random = r Param . get Random ( ) ; } else { key = ( RSA Key Parameters ) param ; random = new Secure Random ( ) ; } if ( key instanceof RSA Private Crt Key Parameters ) { throw new Illegal Argument Exception ( STRING ) ; } }
public boolean expired ( long expire ) { long mod = time . get Time ( ) ; long now = System . current Time Millis ( ) ; long diff = now - mod ; if ( diff > expire && get Source ( ) != NETWORK ) { return BOOL ; } return BOOL ; }
@ Suppress Warnings ( STRING ) private static int find ( Object [ ] arr , java . lang . Comparable val , int bnd , int l , int r ) { if ( Number Comparator . is Number ( val ) ) { return find ( arr , val , bnd , l , r , Number Comparator . create Comparator ( val . get Class ( ) ) ) ; } int m = l ; int d = NUM ; while ( m <= r ) { if ( val . compare To ( arr [ m ] ) > bnd ) { l = m + NUM ; } else { r = m - NUM ; break ; } m += d ; d <<= NUM ; } while ( l <= r ) { m = ( l + r ) > > > NUM ; if ( val . compare To ( arr [ m ] ) > bnd ) { l = m + NUM ; } else { r = m - NUM ; } } return l - NUM ; }
@ Suppress Warnings ( STRING ) private static int find ( Object [ ] arr , java . lang . Comparable val , int bnd , int l , int r ) { if ( Number Comparator . is Number ( val ) ) { return find ( arr , val , bnd , l , r , Number Comparator . create Comparator ( val . get Class ( ) ) ) ; } int m = l ; int d = NUM ; while ( m <= r ) { if ( val . compare To ( arr [ m ] ) > bnd ) { l = m + NUM ; } else { r = m - NUM ; break ; } m += d ; d <<= NUM ; } while ( l <= r ) { m = ( l + r ) > > > NUM ; if ( val . compare To ( arr [ m ] ) > bnd ) { l = m + NUM ; } else { r = m - NUM ; } } return l - NUM ; }
public void evaluate ( final Multivariate Function evaluation Function , final Comparator < Point Value Pair > comparator ) { for ( int i = NUM ; i < simplex . length ; i ++ ) { final Point Value Pair vertex = simplex [ i ] ; final double [ ] point = vertex . get Point Ref ( ) ; if ( Double . is Na N ( vertex . get Value ( ) ) ) { simplex [ i ] = new Point Value Pair ( point , evaluation Function . value ( point ) , BOOL ) ; } } Arrays . sort ( simplex , comparator ) ; }
public Command Iterator ( final List commands , final Command command , final boolean forward ) { if ( commands == null || command == null ) throw new Illegal Argument Exception ( ) ; f Iterator = forward ? commands . iterator ( ) : new Reverse List Iterator ( commands . list Iterator ( commands . size ( ) ) ) ; f Command = command ; f Forward = forward ; }
public Transaction seen ( Transaction tx , Peer Address by Peer ) { lock . lock ( ) ; try { final Transaction interned = intern ( tx ) ; mark Broadcast ( by Peer , interned ) ; return interned ; } finally { lock . unlock ( ) ; } }
public Transaction seen ( Transaction tx , Peer Address by Peer ) { lock . lock ( ) ; try { final Transaction interned = intern ( tx ) ; mark Broadcast ( by Peer , interned ) ; return interned ; } finally { lock . unlock ( ) ; } }
public Transaction seen ( Transaction tx , Peer Address by Peer ) { lock . lock ( ) ; try { final Transaction interned = intern ( tx ) ; mark Broadcast ( by Peer , interned ) ; return interned ; } finally { lock . unlock ( ) ; } }
public Transaction seen ( Transaction tx , Peer Address by Peer ) { lock . lock ( ) ; try { final Transaction interned = intern ( tx ) ; mark Broadcast ( by Peer , interned ) ; return interned ; } finally { lock . unlock ( ) ; } }
public Transaction seen ( Transaction tx , Peer Address by Peer ) { lock . lock ( ) ; try { final Transaction interned = intern ( tx ) ; mark Broadcast ( by Peer , interned ) ; return interned ; } finally { lock . unlock ( ) ; } }
@ Suppress Warnings ( STRING ) public Jdbc Data ( Connection connection , String table , boolean buffered ) { this . connection = connection ; this . table = table ; set Buffered ( buffered ) ; try { set Column Types ( get Jdbc Column Types ( ) ) ; } catch ( SQL Exception e ) { e . print Stack Trace ( ) ; } }
@ Suppress Warnings ( STRING ) public Jdbc Data ( Connection connection , String table , boolean buffered ) { this . connection = connection ; this . table = table ; set Buffered ( buffered ) ; try { set Column Types ( get Jdbc Column Types ( ) ) ; } catch ( SQL Exception e ) { e . print Stack Trace ( ) ; } }
@ Suppress Warnings ( STRING ) public Jdbc Data ( Connection connection , String table , boolean buffered ) { this . connection = connection ; this . table = table ; set Buffered ( buffered ) ; try { set Column Types ( get Jdbc Column Types ( ) ) ; } catch ( SQL Exception e ) { e . print Stack Trace ( ) ; } }
protected Stack < Throwable > unfold Exceptions ( Throwable exception ) { Stack < Throwable > throwables = new Stack < > ( ) ; Throwable current = exception ; while ( current != null ) { throwables . push ( current ) ; current = current . get Cause ( ) ; } return throwables ; }
@ Override public final void write Long ( long v ) throws IO Exception { work [ NUM ] = ( byte ) v ; work [ NUM ] = ( byte ) ( v > > NUM ) ; work [ NUM ] = ( byte ) ( v > > NUM ) ; work [ NUM ] = ( byte ) ( v > > NUM ) ; work [ NUM ] = ( byte ) ( v > > NUM ) ; work [ NUM ] = ( byte ) ( v > > NUM ) ; work [ NUM ] = ( byte ) ( v > > NUM ) ; work [ NUM ] = ( byte ) ( v > > NUM ) ; dis . write ( work , NUM , NUM ) ; }
public static void write Token File ( File token File , String value ) throws IO Exception { write Token ( token File . get Parent File ( ) , token File . get Name ( ) , value ) ; }
public static void write Token File ( File token File , String value ) throws IO Exception { write Token ( token File . get Parent File ( ) , token File . get Name ( ) , value ) ; }
public static void write Token File ( File token File , String value ) throws IO Exception { write Token ( token File . get Parent File ( ) , token File . get Name ( ) , value ) ; }
public Lexer Node create Lexer Node ( ) { return new Lexer Node ( BOOL ) ; }
protected void add Font To Platform Font Path ( String platform Font Name ) { }
protected void add Font To Platform Font Path ( String platform Font Name ) { }
protected void add Font To Platform Font Path ( String platform Font Name ) { }
protected void add Font To Platform Font Path ( String platform Font Name ) { }
public void failover Copy Test ( RP Copy Request Params copy To Failover To ) throws Recover Point Exception { String bookmark Name = copy To Failover To . get Bookmark Name ( ) ; Date apit Time = copy To Failover To . get Apit Time ( ) ; if ( bookmark Name != null ) { logger . info ( STRING + bookmark Name ) ; } else if ( apit Time != null ) { logger . info ( STRING + apit Time . to String ( ) ) ; } else { logger . info ( STRING ) ; } Recover Point Image Management Utils image Manager = new Recover Point Image Management Utils ( ) ; image Manager . enable Copy Image ( functional API , copy To Failover To , BOOL ) ; Recover Point Volume Protection Info failover Copy Info = copy To Failover To . get Copy Volume Info ( ) ; pause Transfer ( failover Copy Info ) ; }
public void test Create Consumer ( ) throws Exception { Message msg = super . create Message ( ) ; producer . send ( msg ) ; synchronized ( lock ) { while ( test Consumer == null ) { lock . wait ( NUM ) ; } } assert True ( test Consumer != null ) ; }
private Listing make Listing ( int number ) { int mod = number % NUM ; int resource ; if ( mod == NUM ) { resource = R . drawable . house 1 ; } else if ( mod == NUM ) { resource = R . drawable . house 2 ; } else { resource = R . drawable . house 3 ; } return new Listing ( String . format ( STRING , number ) , STRING , STRING , STRING , resource ) ; }
private void update Font ( ) { String font Name = font List . get Value ( ) ; Integer font Size = FALLBACK FONT SIZE ; try { font Size = Integer . parse Int ( font Size List . get Value ( ) ) ; } catch ( Number Format Exception ex ) { } font = new Font ( font Name , Font . PLAIN , font Size ) ; preview . set Font ( font ) ; }
public void write ( String str ) throws IO Exception { write ( str , NUM , str . length ( ) ) ; }
public void write ( String str ) throws IO Exception { write ( str , NUM , str . length ( ) ) ; }
protected T prepare Error Fragment ( Throwable Failure Event event , boolean finish After Dialog , Bundle arguments For Error Dialog ) { if ( event . is Suppress Error Ui ( ) ) { return null ; } Bundle bundle ; if ( arguments For Error Dialog != null ) { bundle = ( Bundle ) arguments For Error Dialog . clone ( ) ; } else { bundle = new Bundle ( ) ; } if ( ! bundle . contains Key ( Error Dialog Manager . KEY TITLE ) ) { String title = get Title For ( event , bundle ) ; bundle . put String ( Error Dialog Manager . KEY TITLE , title ) ; } if ( ! bundle . contains Key ( Error Dialog Manager . KEY MESSAGE ) ) { String message = get Message For ( event , bundle ) ; bundle . put String ( Error Dialog Manager . KEY MESSAGE , message ) ; } if ( ! bundle . contains Key ( Error Dialog Manager . KEY FINISH AFTER DIALOG ) ) { bundle . put Boolean ( Error Dialog Manager . KEY FINISH AFTER DIALOG , finish After Dialog ) ; } if ( ! bundle . contains Key ( Error Dialog Manager . KEY EVENT TYPE ON CLOSE ) && config . default Event Type On Dialog Closed != null ) { bundle . put Serializable ( Error Dialog Manager . KEY EVENT TYPE ON CLOSE , config . default Event Type On Dialog Closed ) ; } if ( ! bundle . contains Key ( Error Dialog Manager . KEY ICON ID ) && config . default Dialog Icon Id != NUM ) { bundle . put Int ( Error Dialog Manager . KEY ICON ID , config . default Dialog Icon Id ) ; } return create Error Fragment ( event , bundle ) ; }
protected T prepare Error Fragment ( Throwable Failure Event event , boolean finish After Dialog , Bundle arguments For Error Dialog ) { if ( event . is Suppress Error Ui ( ) ) { return null ; } Bundle bundle ; if ( arguments For Error Dialog != null ) { bundle = ( Bundle ) arguments For Error Dialog . clone ( ) ; } else { bundle = new Bundle ( ) ; } if ( ! bundle . contains Key ( Error Dialog Manager . KEY TITLE ) ) { String title = get Title For ( event , bundle ) ; bundle . put String ( Error Dialog Manager . KEY TITLE , title ) ; } if ( ! bundle . contains Key ( Error Dialog Manager . KEY MESSAGE ) ) { String message = get Message For ( event , bundle ) ; bundle . put String ( Error Dialog Manager . KEY MESSAGE , message ) ; } if ( ! bundle . contains Key ( Error Dialog Manager . KEY FINISH AFTER DIALOG ) ) { bundle . put Boolean ( Error Dialog Manager . KEY FINISH AFTER DIALOG , finish After Dialog ) ; } if ( ! bundle . contains Key ( Error Dialog Manager . KEY EVENT TYPE ON CLOSE ) && config . default Event Type On Dialog Closed != null ) { bundle . put Serializable ( Error Dialog Manager . KEY EVENT TYPE ON CLOSE , config . default Event Type On Dialog Closed ) ; } if ( ! bundle . contains Key ( Error Dialog Manager . KEY ICON ID ) && config . default Dialog Icon Id != NUM ) { bundle . put Int ( Error Dialog Manager . KEY ICON ID , config . default Dialog Icon Id ) ; } return create Error Fragment ( event , bundle ) ; }
public void add Extension Filter ( String extension ) { if ( ext == null ) { ext = new Vector ( ) ; } ext . add Element ( extension ) ; }
public String decrypt ( String value ) { if ( value == null || value . length ( ) == NUM ) return value ; boolean is Encrypted = value . starts With ( ENCRYPTEDVALUE START ) && value . ends With ( ENCRYPTEDVALUE END ) ; if ( is Encrypted ) value = value . substring ( ENCRYPTEDVALUE START . length ( ) , value . length ( ) - ENCRYPTEDVALUE END . length ( ) ) ; byte [ ] data = convert Hex String ( value ) ; if ( data == null ) { if ( is Encrypted ) { log . info ( STRING ) ; return null ; } return value ; } if ( m cipher == null ) init Cipher ( ) ; if ( m cipher != null && value != null && value . length ( ) > NUM ) { try { Algorithm Parameters ap = m cipher . get Parameters ( ) ; m cipher . init ( Cipher . DECRYPT MODE , m key , ap ) ; byte [ ] out = m cipher . do Final ( data ) ; String ret Value = new String ( out , STRING ) ; return ret Value ; } catch ( Exception ex ) { log . info ( STRING + ex . to String ( ) ) ; } } return null ; }
public void guard ( final Guard r ) throws Interrupted Exception { inc Thread ( ) ; try { r . run ( ) ; } catch ( Interrupted Exception e ) { throw e ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } finally { dec Thread ( ) ; } }
public void guard ( final Guard r ) throws Interrupted Exception { inc Thread ( ) ; try { r . run ( ) ; } catch ( Interrupted Exception e ) { throw e ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } finally { dec Thread ( ) ; } }
public void guard ( final Guard r ) throws Interrupted Exception { inc Thread ( ) ; try { r . run ( ) ; } catch ( Interrupted Exception e ) { throw e ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } finally { dec Thread ( ) ; } }
public Short Banded Raster ( Sample Model sample Model , Point origin ) { this ( sample Model , sample Model . create Data Buffer ( ) , new Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
public Short Banded Raster ( Sample Model sample Model , Point origin ) { this ( sample Model , sample Model . create Data Buffer ( ) , new Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
private void init Client Token ( ) { client Token = kerberos Ticket Service . get Client Token ( ) ; }
final void try Terminate 2 ( ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = run State Of ( c ) ; if ( rs < SHUTDOWN || rs == TERMINATED || ( rs == SHUTDOWN && ! work Queue . is Empty ( ) ) ) return ; if ( worker Count Of ( c ) != NUM ) { interrupt Idle Workers ( ONLY ONE ) ; return ; } if ( ctl . compare And Set ( c , ctl Of ( TERMINATED , NUM ) ) ) { main Lock . lock ( ) ; try { termination . signal All ( ) ; } finally { main Lock . unlock ( ) ; } terminated ( ) ; return ; } } }
final void try Terminate 2 ( ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = run State Of ( c ) ; if ( rs < SHUTDOWN || rs == TERMINATED || ( rs == SHUTDOWN && ! work Queue . is Empty ( ) ) ) return ; if ( worker Count Of ( c ) != NUM ) { interrupt Idle Workers ( ONLY ONE ) ; return ; } if ( ctl . compare And Set ( c , ctl Of ( TERMINATED , NUM ) ) ) { main Lock . lock ( ) ; try { termination . signal All ( ) ; } finally { main Lock . unlock ( ) ; } terminated ( ) ; return ; } } }
final void try Terminate 2 ( ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = run State Of ( c ) ; if ( rs < SHUTDOWN || rs == TERMINATED || ( rs == SHUTDOWN && ! work Queue . is Empty ( ) ) ) return ; if ( worker Count Of ( c ) != NUM ) { interrupt Idle Workers ( ONLY ONE ) ; return ; } if ( ctl . compare And Set ( c , ctl Of ( TERMINATED , NUM ) ) ) { main Lock . lock ( ) ; try { termination . signal All ( ) ; } finally { main Lock . unlock ( ) ; } terminated ( ) ; return ; } } }
final void try Terminate 2 ( ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = run State Of ( c ) ; if ( rs < SHUTDOWN || rs == TERMINATED || ( rs == SHUTDOWN && ! work Queue . is Empty ( ) ) ) return ; if ( worker Count Of ( c ) != NUM ) { interrupt Idle Workers ( ONLY ONE ) ; return ; } if ( ctl . compare And Set ( c , ctl Of ( TERMINATED , NUM ) ) ) { main Lock . lock ( ) ; try { termination . signal All ( ) ; } finally { main Lock . unlock ( ) ; } terminated ( ) ; return ; } } }
final void try Terminate 2 ( ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = run State Of ( c ) ; if ( rs < SHUTDOWN || rs == TERMINATED || ( rs == SHUTDOWN && ! work Queue . is Empty ( ) ) ) return ; if ( worker Count Of ( c ) != NUM ) { interrupt Idle Workers ( ONLY ONE ) ; return ; } if ( ctl . compare And Set ( c , ctl Of ( TERMINATED , NUM ) ) ) { main Lock . lock ( ) ; try { termination . signal All ( ) ; } finally { main Lock . unlock ( ) ; } terminated ( ) ; return ; } } }
final void try Terminate 2 ( ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = run State Of ( c ) ; if ( rs < SHUTDOWN || rs == TERMINATED || ( rs == SHUTDOWN && ! work Queue . is Empty ( ) ) ) return ; if ( worker Count Of ( c ) != NUM ) { interrupt Idle Workers ( ONLY ONE ) ; return ; } if ( ctl . compare And Set ( c , ctl Of ( TERMINATED , NUM ) ) ) { main Lock . lock ( ) ; try { termination . signal All ( ) ; } finally { main Lock . unlock ( ) ; } terminated ( ) ; return ; } } }
final void try Terminate 2 ( ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = run State Of ( c ) ; if ( rs < SHUTDOWN || rs == TERMINATED || ( rs == SHUTDOWN && ! work Queue . is Empty ( ) ) ) return ; if ( worker Count Of ( c ) != NUM ) { interrupt Idle Workers ( ONLY ONE ) ; return ; } if ( ctl . compare And Set ( c , ctl Of ( TERMINATED , NUM ) ) ) { main Lock . lock ( ) ; try { termination . signal All ( ) ; } finally { main Lock . unlock ( ) ; } terminated ( ) ; return ; } } }
public Virtual Stack Slot make Lock Slot ( int lock Depth ) { if ( locks == EMPTY ) { locks = new Allocatable Value [ lock Depth + NUM ] ; } else if ( locks . length < lock Depth + NUM ) { locks = Arrays . copy Of ( locks , lock Depth + NUM ) ; } if ( locks [ lock Depth ] == null ) { locks [ lock Depth ] = frame Map Builder . allocate Spill Slot ( slot Kind ) ; } return ( Virtual Stack Slot ) locks [ lock Depth ] ; }
public Virtual Stack Slot make Lock Slot ( int lock Depth ) { if ( locks == EMPTY ) { locks = new Allocatable Value [ lock Depth + NUM ] ; } else if ( locks . length < lock Depth + NUM ) { locks = Arrays . copy Of ( locks , lock Depth + NUM ) ; } if ( locks [ lock Depth ] == null ) { locks [ lock Depth ] = frame Map Builder . allocate Spill Slot ( slot Kind ) ; } return ( Virtual Stack Slot ) locks [ lock Depth ] ; }
protected void display Get Summary ( final Get Status status ) { if ( ! should Display Summary ( status ) ) { return ; } display Get Status ( status ) ; for ( final Get Event e : get Warning List ) { display Get Event ( e , e . get Target Local Item ( ) ) ; } display Errors ( ) ; }
protected String instance To Matlab ( Instance inst ) { String Buffer result ; int i ; result = new String Buffer ( ) ; for ( i = NUM ; i < inst . num Attributes ( ) ; i ++ ) { if ( i > NUM ) { result . append ( ( m Use Tabs ? STRING : STRING ) ) ; } result . append ( m Format . format ( inst . value ( i ) ) ) ; } return result . to String ( ) ; }
public static Collection < Content Stream > to Content Streams ( final String str , final String content Type ) { Array List < Content Stream > streams = new Array List < > ( ) ; Content Stream Base stream = new Content Stream Base . String Stream ( str ) ; if ( content Type != null ) stream . set Content Type ( content Type ) ; streams . add ( stream ) ; return streams ; }
public static Collection < Content Stream > to Content Streams ( final String str , final String content Type ) { Array List < Content Stream > streams = new Array List < > ( ) ; Content Stream Base stream = new Content Stream Base . String Stream ( str ) ; if ( content Type != null ) stream . set Content Type ( content Type ) ; streams . add ( stream ) ; return streams ; }
@ Parameterized . Parameters ( name = STRING ) public static Collection < Payment Channel Client . Version Selector > data ( ) { return Arrays . as List ( Payment Channel Client . Version Selector . VERSION 1 , Payment Channel Client . Version Selector . VERSION 2 ALLOW 1 , Payment Channel Client . Version Selector . VERSION 2 ) ; }
@ Parameterized . Parameters ( name = STRING ) public static Collection < Payment Channel Client . Version Selector > data ( ) { return Arrays . as List ( Payment Channel Client . Version Selector . VERSION 1 , Payment Channel Client . Version Selector . VERSION 2 ALLOW 1 , Payment Channel Client . Version Selector . VERSION 2 ) ; }
@ Parameterized . Parameters ( name = STRING ) public static Collection < Payment Channel Client . Version Selector > data ( ) { return Arrays . as List ( Payment Channel Client . Version Selector . VERSION 1 , Payment Channel Client . Version Selector . VERSION 2 ALLOW 1 , Payment Channel Client . Version Selector . VERSION 2 ) ; }
public Job Definition Create Request create Job Definition Create Request ( String namespace Cd , String job Name , String job Description , String activiti Xml , List < Parameter > parameters ) { Job Definition Create Request request = new Job Definition Create Request ( ) ; request . set Namespace ( namespace Cd ) ; request . set Job Name ( job Name ) ; request . set Description ( job Description ) ; request . set Activiti Job Xml ( activiti Xml ) ; request . set Parameters ( parameters ) ; return request ; }
private void send Update ( JSON Object obj , boolean keep Callback ) { send Update ( obj , keep Callback , Plugin Result . Status . OK ) ; }
public void build ( String code , JSON Object data ) { try { result . put ( resources . get String ( R . string . intent extra status ) , resources . get String ( R . string . shared pref default status ) ) ; result . put ( resources . get String ( R . string . intent extra code ) , code ) ; if ( data != null ) { result . put ( resources . get String ( R . string . intent extra data ) , data ) ; } operation List Result . put ( result ) ; } catch ( JSON Exception e ) { Log . e ( TAG , STRING + e . to String ( ) ) ; } }
public void add ( String dn , String attributes , String delimiter , String seperator ) throws Naming Exception , Page Exception { Dir Context ctx = new Initial Dir Context ( env ) ; ctx . create Subcontext ( dn , to Attributes ( attributes , delimiter , seperator ) ) ; ctx . close ( ) ; }
private static List < Agent > prepare Contributors From Eml Agents ( List < Agent > contacts , List < Agent > metadata Providers , List < Agent > associated Parties ) { List < Agent > ls = Lists . new Array List ( ) ; for ( Agent contact : contacts ) { contact . set Role ( CONTACT ROLE ) ; } ls . add All ( contacts ) ; for ( Agent metadata Provider : metadata Providers ) { metadata Provider . set Role ( METADATA PROVIDER ROLE ) ; } ls . add All ( metadata Providers ) ; ls . add All ( associated Parties ) ; return ls ; }
private static List < Agent > prepare Contributors From Eml Agents ( List < Agent > contacts , List < Agent > metadata Providers , List < Agent > associated Parties ) { List < Agent > ls = Lists . new Array List ( ) ; for ( Agent contact : contacts ) { contact . set Role ( CONTACT ROLE ) ; } ls . add All ( contacts ) ; for ( Agent metadata Provider : metadata Providers ) { metadata Provider . set Role ( METADATA PROVIDER ROLE ) ; } ls . add All ( metadata Providers ) ; ls . add All ( associated Parties ) ; return ls ; }
private static List < Agent > prepare Contributors From Eml Agents ( List < Agent > contacts , List < Agent > metadata Providers , List < Agent > associated Parties ) { List < Agent > ls = Lists . new Array List ( ) ; for ( Agent contact : contacts ) { contact . set Role ( CONTACT ROLE ) ; } ls . add All ( contacts ) ; for ( Agent metadata Provider : metadata Providers ) { metadata Provider . set Role ( METADATA PROVIDER ROLE ) ; } ls . add All ( metadata Providers ) ; ls . add All ( associated Parties ) ; return ls ; }
private static List < Agent > prepare Contributors From Eml Agents ( List < Agent > contacts , List < Agent > metadata Providers , List < Agent > associated Parties ) { List < Agent > ls = Lists . new Array List ( ) ; for ( Agent contact : contacts ) { contact . set Role ( CONTACT ROLE ) ; } ls . add All ( contacts ) ; for ( Agent metadata Provider : metadata Providers ) { metadata Provider . set Role ( METADATA PROVIDER ROLE ) ; } ls . add All ( metadata Providers ) ; ls . add All ( associated Parties ) ; return ls ; }
private static List < Agent > prepare Contributors From Eml Agents ( List < Agent > contacts , List < Agent > metadata Providers , List < Agent > associated Parties ) { List < Agent > ls = Lists . new Array List ( ) ; for ( Agent contact : contacts ) { contact . set Role ( CONTACT ROLE ) ; } ls . add All ( contacts ) ; for ( Agent metadata Provider : metadata Providers ) { metadata Provider . set Role ( METADATA PROVIDER ROLE ) ; } ls . add All ( metadata Providers ) ; ls . add All ( associated Parties ) ; return ls ; }
public static File absolute File ( File file ) { if ( file != null ) { try { file = file . get Canonical File ( ) ; } catch ( IO Exception e ) { file = file . get Absolute File ( ) ; } } return file ; }
@ Suppress Warnings ( STRING ) public Composite File Comparator ( Comparator < File > ... delegates ) { if ( delegates == null ) { this . delegates = ( Comparator < File > [ ] ) NO COMPARATORS ; } else { this . delegates = ( Comparator < File > [ ] ) new Comparator < ? > [ delegates . length ] ; System . arraycopy ( delegates , NUM , this . delegates , NUM , delegates . length ) ; } }
private Value Geometry ( byte [ ] bytes , Geometry geometry ) { this . bytes = bytes ; this . geometry = geometry ; this . hash Code = Arrays . hash Code ( bytes ) ; }
public void add Load More ( ) { if ( load More Item != null || footer Item != null ) { return ; } load More Item = new Object ( ) ; notify Data Set Changed ( ) ; }
boolean should Animate Search Provider Icon ( Selection Type selection Type , boolean is Showing ) { if ( is Showing || Contextual Search Field Trial . are Extra Search Bar Animations Disabled ( ) ) { return BOOL ; } if ( selection Type == Selection Type . TAP ) { long current Time Millis = System . current Time Millis ( ) ; long last Animated Time Millis = m Preference Manager . get Contextual Search Last Animation Time ( ) ; if ( Math . abs ( current Time Millis - last Animated Time Millis ) > ONE DAY IN MILLIS ) { m Preference Manager . set Contextual Search Last Animation Time ( current Time Millis ) ; return BOOL ; } else { return BOOL ; } } else if ( selection Type == Selection Type . LONG PRESS ) { return get Promo Open Count ( ) == NUM ; } return BOOL ; }
boolean should Animate Search Provider Icon ( Selection Type selection Type , boolean is Showing ) { if ( is Showing || Contextual Search Field Trial . are Extra Search Bar Animations Disabled ( ) ) { return BOOL ; } if ( selection Type == Selection Type . TAP ) { long current Time Millis = System . current Time Millis ( ) ; long last Animated Time Millis = m Preference Manager . get Contextual Search Last Animation Time ( ) ; if ( Math . abs ( current Time Millis - last Animated Time Millis ) > ONE DAY IN MILLIS ) { m Preference Manager . set Contextual Search Last Animation Time ( current Time Millis ) ; return BOOL ; } else { return BOOL ; } } else if ( selection Type == Selection Type . LONG PRESS ) { return get Promo Open Count ( ) == NUM ; } return BOOL ; }
boolean should Animate Search Provider Icon ( Selection Type selection Type , boolean is Showing ) { if ( is Showing || Contextual Search Field Trial . are Extra Search Bar Animations Disabled ( ) ) { return BOOL ; } if ( selection Type == Selection Type . TAP ) { long current Time Millis = System . current Time Millis ( ) ; long last Animated Time Millis = m Preference Manager . get Contextual Search Last Animation Time ( ) ; if ( Math . abs ( current Time Millis - last Animated Time Millis ) > ONE DAY IN MILLIS ) { m Preference Manager . set Contextual Search Last Animation Time ( current Time Millis ) ; return BOOL ; } else { return BOOL ; } } else if ( selection Type == Selection Type . LONG PRESS ) { return get Promo Open Count ( ) == NUM ; } return BOOL ; }
boolean should Animate Search Provider Icon ( Selection Type selection Type , boolean is Showing ) { if ( is Showing || Contextual Search Field Trial . are Extra Search Bar Animations Disabled ( ) ) { return BOOL ; } if ( selection Type == Selection Type . TAP ) { long current Time Millis = System . current Time Millis ( ) ; long last Animated Time Millis = m Preference Manager . get Contextual Search Last Animation Time ( ) ; if ( Math . abs ( current Time Millis - last Animated Time Millis ) > ONE DAY IN MILLIS ) { m Preference Manager . set Contextual Search Last Animation Time ( current Time Millis ) ; return BOOL ; } else { return BOOL ; } } else if ( selection Type == Selection Type . LONG PRESS ) { return get Promo Open Count ( ) == NUM ; } return BOOL ; }
boolean should Animate Search Provider Icon ( Selection Type selection Type , boolean is Showing ) { if ( is Showing || Contextual Search Field Trial . are Extra Search Bar Animations Disabled ( ) ) { return BOOL ; } if ( selection Type == Selection Type . TAP ) { long current Time Millis = System . current Time Millis ( ) ; long last Animated Time Millis = m Preference Manager . get Contextual Search Last Animation Time ( ) ; if ( Math . abs ( current Time Millis - last Animated Time Millis ) > ONE DAY IN MILLIS ) { m Preference Manager . set Contextual Search Last Animation Time ( current Time Millis ) ; return BOOL ; } else { return BOOL ; } } else if ( selection Type == Selection Type . LONG PRESS ) { return get Promo Open Count ( ) == NUM ; } return BOOL ; }
boolean should Animate Search Provider Icon ( Selection Type selection Type , boolean is Showing ) { if ( is Showing || Contextual Search Field Trial . are Extra Search Bar Animations Disabled ( ) ) { return BOOL ; } if ( selection Type == Selection Type . TAP ) { long current Time Millis = System . current Time Millis ( ) ; long last Animated Time Millis = m Preference Manager . get Contextual Search Last Animation Time ( ) ; if ( Math . abs ( current Time Millis - last Animated Time Millis ) > ONE DAY IN MILLIS ) { m Preference Manager . set Contextual Search Last Animation Time ( current Time Millis ) ; return BOOL ; } else { return BOOL ; } } else if ( selection Type == Selection Type . LONG PRESS ) { return get Promo Open Count ( ) == NUM ; } return BOOL ; }
boolean should Animate Search Provider Icon ( Selection Type selection Type , boolean is Showing ) { if ( is Showing || Contextual Search Field Trial . are Extra Search Bar Animations Disabled ( ) ) { return BOOL ; } if ( selection Type == Selection Type . TAP ) { long current Time Millis = System . current Time Millis ( ) ; long last Animated Time Millis = m Preference Manager . get Contextual Search Last Animation Time ( ) ; if ( Math . abs ( current Time Millis - last Animated Time Millis ) > ONE DAY IN MILLIS ) { m Preference Manager . set Contextual Search Last Animation Time ( current Time Millis ) ; return BOOL ; } else { return BOOL ; } } else if ( selection Type == Selection Type . LONG PRESS ) { return get Promo Open Count ( ) == NUM ; } return BOOL ; }
public Composite Predicate ( Predicate p1 , Predicate p2 ) { m clauses . add ( p1 ) ; m clauses . add ( p2 ) ; }
public boolean write Header ( Output Stream os ) { try { write Int ( os , CACHE MAGIC ) ; write String ( os , key ) ; write String ( os , etag == null ? STRING : etag ) ; write Long ( os , server Date ) ; write Long ( os , last Modified ) ; write Long ( os , ttl ) ; write Long ( os , soft Ttl ) ; write String String Map ( response Headers , os ) ; os . flush ( ) ; return BOOL ; } catch ( IO Exception e ) { Volley Log . d ( STRING , e . to String ( ) ) ; return BOOL ; } }
public static void println ( ) { out . println ( ) ; }
public static void println ( ) { out . println ( ) ; }
public static void println ( ) { out . println ( ) ; }
public Quad Edge connect ( Quad Edge a , Quad Edge b ) { Quad Edge q = Quad Edge . connect ( a , b ) ; quad Edges . add ( q ) ; return q ; }
public Quad Edge connect ( Quad Edge a , Quad Edge b ) { Quad Edge q = Quad Edge . connect ( a , b ) ; quad Edges . add ( q ) ; return q ; }
public Quad Edge connect ( Quad Edge a , Quad Edge b ) { Quad Edge q = Quad Edge . connect ( a , b ) ; quad Edges . add ( q ) ; return q ; }
public Quad Edge connect ( Quad Edge a , Quad Edge b ) { Quad Edge q = Quad Edge . connect ( a , b ) ; quad Edges . add ( q ) ; return q ; }
public Quad Edge connect ( Quad Edge a , Quad Edge b ) { Quad Edge q = Quad Edge . connect ( a , b ) ; quad Edges . add ( q ) ; return q ; }
public Quad Edge connect ( Quad Edge a , Quad Edge b ) { Quad Edge q = Quad Edge . connect ( a , b ) ; quad Edges . add ( q ) ; return q ; }
public void engine Delete Entry ( String alias ) throws Key Store Exception { permission Check ( ) ; synchronized ( entries ) { Object entry = entries . remove ( alias . to Lower Case ( ) ) ; deleted Entries . put ( alias . to Lower Case ( ) , entry ) ; } }
@ Override public void dispatch ( Remote Event Bus Packet packet ) { try { packet . execute ( this ) ; } catch ( Exception ex ) { if ( logger . is Loggable ( Level . SEVERE ) ) logger . log ( Level . SEVERE , ex . to String ( ) , ex ) ; } finally { data Event Manager . notify Returned ( packet . get Status ( ) , ( I Template Holder ) packet . get Entry Holder ( ) ) ; } }
@ Override public void dispatch ( Remote Event Bus Packet packet ) { try { packet . execute ( this ) ; } catch ( Exception ex ) { if ( logger . is Loggable ( Level . SEVERE ) ) logger . log ( Level . SEVERE , ex . to String ( ) , ex ) ; } finally { data Event Manager . notify Returned ( packet . get Status ( ) , ( I Template Holder ) packet . get Entry Holder ( ) ) ; } }
@ Override public void dispatch ( Remote Event Bus Packet packet ) { try { packet . execute ( this ) ; } catch ( Exception ex ) { if ( logger . is Loggable ( Level . SEVERE ) ) logger . log ( Level . SEVERE , ex . to String ( ) , ex ) ; } finally { data Event Manager . notify Returned ( packet . get Status ( ) , ( I Template Holder ) packet . get Entry Holder ( ) ) ; } }
@ Override public void dispatch ( Remote Event Bus Packet packet ) { try { packet . execute ( this ) ; } catch ( Exception ex ) { if ( logger . is Loggable ( Level . SEVERE ) ) logger . log ( Level . SEVERE , ex . to String ( ) , ex ) ; } finally { data Event Manager . notify Returned ( packet . get Status ( ) , ( I Template Holder ) packet . get Entry Holder ( ) ) ; } }
@ Override public Fraction multiply ( Fraction fraction ) { Math Utils . check Not Null ( fraction , Localized Core Formats . FRACTION ) ; if ( numerator == NUM || fraction . numerator == NUM ) { return ZERO ; } int d1 = Arithmetic Utils . gcd ( numerator , fraction . denominator ) ; int d2 = Arithmetic Utils . gcd ( fraction . numerator , denominator ) ; return get Reduced Fraction ( Arithmetic Utils . mul And Check ( numerator / d1 , fraction . numerator / d2 ) , Arithmetic Utils . mul And Check ( denominator / d2 , fraction . denominator / d1 ) ) ; }
@ Override void inserted Text ( Character Data Impl node , int offset , int count ) { if ( ranges != null ) { notify Ranges Inserted Text ( node , offset , count ) ; } }
public void add Attribute ( Object name , Object value ) { table . put ( name , value ) ; }
public void forward ( Http Server Request request ) { forward ( request , null ) ; }
private void update Ones ( Statement stmt , String [ ] ones updated , short [ ] twos ) throws SQL Exception { for ( int i = NUM ; i < ones updated . length ; i ++ ) { stmt . execute ( STRING + ones updated [ i ] + STRING + twos [ i ] ) ; } }
public boolean hit ( Rectangle rect , Shape s , boolean on Stroke ) { if ( on Stroke ) { s = stroke . create Stroked Shape ( s ) ; } s = transform Shape ( s ) ; if ( ( constrain X | constrain Y ) != NUM ) { rect = new Rectangle ( rect ) ; rect . translate ( constrain X , constrain Y ) ; } return s . intersects ( rect ) ; }
public Sort Clause ( String item , String order ) { this ( item , ORDER . value Of ( order ) ) ; }
@ Override public void read NBT ( NBT Tag Compound compound ) { super . read NBT ( compound ) ; if ( compound . has Key ( STRING ) ) { this . exhaustion Timer = compound . get Integer ( STRING ) ; } if ( ! compound . has Key ( STRING ) ) { set Food Level ( get Food Level ( ) * NUM ) ; set Saturation ( NUM ) ; } if ( get Food Level ( ) > NUM ) set Food Level ( NUM ) ; if ( get Saturation Level ( ) > NUM ) set Saturation ( NUM ) ; }
@ Override public int maximum Size ( Container container , List components , Form Layout . Measure min Measure , Form Layout . Measure pref Measure , Form Layout . Measure default Measure ) { Form Layout . Measure measure = this == MINIMUM ? min Measure : ( this == PREFERRED ? pref Measure : default Measure ) ; int maximum = NUM ; for ( Iterator i = components . iterator ( ) ; i . has Next ( ) ; ) { Component c = ( Component ) i . next ( ) ; maximum = Math . max ( maximum , measure . size Of ( c ) ) ; } return maximum ; }
@ Override public int maximum Size ( Container container , List components , Form Layout . Measure min Measure , Form Layout . Measure pref Measure , Form Layout . Measure default Measure ) { Form Layout . Measure measure = this == MINIMUM ? min Measure : ( this == PREFERRED ? pref Measure : default Measure ) ; int maximum = NUM ; for ( Iterator i = components . iterator ( ) ; i . has Next ( ) ; ) { Component c = ( Component ) i . next ( ) ; maximum = Math . max ( maximum , measure . size Of ( c ) ) ; } return maximum ; }
@ Override public int maximum Size ( Container container , List components , Form Layout . Measure min Measure , Form Layout . Measure pref Measure , Form Layout . Measure default Measure ) { Form Layout . Measure measure = this == MINIMUM ? min Measure : ( this == PREFERRED ? pref Measure : default Measure ) ; int maximum = NUM ; for ( Iterator i = components . iterator ( ) ; i . has Next ( ) ; ) { Component c = ( Component ) i . next ( ) ; maximum = Math . max ( maximum , measure . size Of ( c ) ) ; } return maximum ; }
@ Override public int maximum Size ( Container container , List components , Form Layout . Measure min Measure , Form Layout . Measure pref Measure , Form Layout . Measure default Measure ) { Form Layout . Measure measure = this == MINIMUM ? min Measure : ( this == PREFERRED ? pref Measure : default Measure ) ; int maximum = NUM ; for ( Iterator i = components . iterator ( ) ; i . has Next ( ) ; ) { Component c = ( Component ) i . next ( ) ; maximum = Math . max ( maximum , measure . size Of ( c ) ) ; } return maximum ; }
@ Override public int maximum Size ( Container container , List components , Form Layout . Measure min Measure , Form Layout . Measure pref Measure , Form Layout . Measure default Measure ) { Form Layout . Measure measure = this == MINIMUM ? min Measure : ( this == PREFERRED ? pref Measure : default Measure ) ; int maximum = NUM ; for ( Iterator i = components . iterator ( ) ; i . has Next ( ) ; ) { Component c = ( Component ) i . next ( ) ; maximum = Math . max ( maximum , measure . size Of ( c ) ) ; } return maximum ; }
public static Time Series Data serializable Instance ( ) { List < String > var Names = new Array List < > ( ) ; var Names . add ( STRING ) ; var Names . add ( STRING ) ; return new Time Series Data ( new Tetrad Matrix ( NUM , NUM ) , var Names ) ; }
public static Time Series Data serializable Instance ( ) { List < String > var Names = new Array List < > ( ) ; var Names . add ( STRING ) ; var Names . add ( STRING ) ; return new Time Series Data ( new Tetrad Matrix ( NUM , NUM ) , var Names ) ; }
public double sax Min Dist ( char [ ] a , char [ ] b , double [ ] [ ] distance Matrix , int n , int w ) throws SAX Exception { if ( a . length == b . length ) { double dist = NUM ; for ( int i = NUM ; i < a . length ; i ++ ) { if ( Character . is Letter ( a [ i ] ) && Character . is Letter ( b [ i ] ) ) { int num A = Character . get Numeric Value ( a [ i ] ) - NUM ; int num B = Character . get Numeric Value ( b [ i ] ) - NUM ; int max Idx = distance Matrix [ NUM ] . length ; if ( num A > ( max Idx - NUM ) || num A < NUM || num B > ( max Idx - NUM ) || num B < NUM ) { throw new SAX Exception ( STRING + max Idx + STRING ) ; } double local Dist = distance Matrix [ num A ] [ num B ] ; dist = dist + local Dist * local Dist ; } else { throw new SAX Exception ( STRING ) ; } } return Math . sqrt ( ( double ) n / ( double ) w ) * Math . sqrt ( dist ) ; } else { throw new SAX Exception ( STRING ) ; } }
public double sax Min Dist ( char [ ] a , char [ ] b , double [ ] [ ] distance Matrix , int n , int w ) throws SAX Exception { if ( a . length == b . length ) { double dist = NUM ; for ( int i = NUM ; i < a . length ; i ++ ) { if ( Character . is Letter ( a [ i ] ) && Character . is Letter ( b [ i ] ) ) { int num A = Character . get Numeric Value ( a [ i ] ) - NUM ; int num B = Character . get Numeric Value ( b [ i ] ) - NUM ; int max Idx = distance Matrix [ NUM ] . length ; if ( num A > ( max Idx - NUM ) || num A < NUM || num B > ( max Idx - NUM ) || num B < NUM ) { throw new SAX Exception ( STRING + max Idx + STRING ) ; } double local Dist = distance Matrix [ num A ] [ num B ] ; dist = dist + local Dist * local Dist ; } else { throw new SAX Exception ( STRING ) ; } } return Math . sqrt ( ( double ) n / ( double ) w ) * Math . sqrt ( dist ) ; } else { throw new SAX Exception ( STRING ) ; } }
public double sax Min Dist ( char [ ] a , char [ ] b , double [ ] [ ] distance Matrix , int n , int w ) throws SAX Exception { if ( a . length == b . length ) { double dist = NUM ; for ( int i = NUM ; i < a . length ; i ++ ) { if ( Character . is Letter ( a [ i ] ) && Character . is Letter ( b [ i ] ) ) { int num A = Character . get Numeric Value ( a [ i ] ) - NUM ; int num B = Character . get Numeric Value ( b [ i ] ) - NUM ; int max Idx = distance Matrix [ NUM ] . length ; if ( num A > ( max Idx - NUM ) || num A < NUM || num B > ( max Idx - NUM ) || num B < NUM ) { throw new SAX Exception ( STRING + max Idx + STRING ) ; } double local Dist = distance Matrix [ num A ] [ num B ] ; dist = dist + local Dist * local Dist ; } else { throw new SAX Exception ( STRING ) ; } } return Math . sqrt ( ( double ) n / ( double ) w ) * Math . sqrt ( dist ) ; } else { throw new SAX Exception ( STRING ) ; } }
public boolean valid System Name Format ( String system Name ) { return ( get Bit From System Name ( system Name ) != NUM ) ; }
public boolean valid System Name Format ( String system Name ) { return ( get Bit From System Name ( system Name ) != NUM ) ; }
public byte [ ] to Bytecode ( ) throws IO Exception , Cannot Compile Exception { Byte Array Output Stream barray = new Byte Array Output Stream ( ) ; Data Output Stream out = new Data Output Stream ( barray ) ; try { to Bytecode ( out ) ; } finally { out . close ( ) ; } return barray . to Byte Array ( ) ; }
public byte [ ] to Bytecode ( ) throws IO Exception , Cannot Compile Exception { Byte Array Output Stream barray = new Byte Array Output Stream ( ) ; Data Output Stream out = new Data Output Stream ( barray ) ; try { to Bytecode ( out ) ; } finally { out . close ( ) ; } return barray . to Byte Array ( ) ; }
public byte [ ] to Bytecode ( ) throws IO Exception , Cannot Compile Exception { Byte Array Output Stream barray = new Byte Array Output Stream ( ) ; Data Output Stream out = new Data Output Stream ( barray ) ; try { to Bytecode ( out ) ; } finally { out . close ( ) ; } return barray . to Byte Array ( ) ; }
public static Http URL Connection to Http Connection ( Request Batch requests ) { for ( Request request : requests ) { request . validate ( ) ; } URL url = null ; try { if ( requests . size ( ) == NUM ) { Request request = requests . get ( NUM ) ; url = new URL ( request . get Url For Single Request ( ) ) ; } else { url = new URL ( Server Protocol . get Graph Url Base ( ) ) ; } } catch ( Malformed URL Exception e ) { throw new Facebook Exception ( STRING , e ) ; } Http URL Connection connection ; try { connection = create Connection ( url ) ; serialize To Url Connection ( requests , connection ) ; } catch ( IO Exception e ) { throw new Facebook Exception ( STRING , e ) ; } catch ( JSON Exception e ) { throw new Facebook Exception ( STRING , e ) ; } return connection ; }
public static Http URL Connection to Http Connection ( Request Batch requests ) { for ( Request request : requests ) { request . validate ( ) ; } URL url = null ; try { if ( requests . size ( ) == NUM ) { Request request = requests . get ( NUM ) ; url = new URL ( request . get Url For Single Request ( ) ) ; } else { url = new URL ( Server Protocol . get Graph Url Base ( ) ) ; } } catch ( Malformed URL Exception e ) { throw new Facebook Exception ( STRING , e ) ; } Http URL Connection connection ; try { connection = create Connection ( url ) ; serialize To Url Connection ( requests , connection ) ; } catch ( IO Exception e ) { throw new Facebook Exception ( STRING , e ) ; } catch ( JSON Exception e ) { throw new Facebook Exception ( STRING , e ) ; } return connection ; }
public static Http URL Connection to Http Connection ( Request Batch requests ) { for ( Request request : requests ) { request . validate ( ) ; } URL url = null ; try { if ( requests . size ( ) == NUM ) { Request request = requests . get ( NUM ) ; url = new URL ( request . get Url For Single Request ( ) ) ; } else { url = new URL ( Server Protocol . get Graph Url Base ( ) ) ; } } catch ( Malformed URL Exception e ) { throw new Facebook Exception ( STRING , e ) ; } Http URL Connection connection ; try { connection = create Connection ( url ) ; serialize To Url Connection ( requests , connection ) ; } catch ( IO Exception e ) { throw new Facebook Exception ( STRING , e ) ; } catch ( JSON Exception e ) { throw new Facebook Exception ( STRING , e ) ; } return connection ; }
public void remove Locators ( Lookup Locator [ ] locators ) { test Set For Null ( locators ) ; synchronized ( this ) { if ( terminated ) { throw new Illegal State Exception ( STRING ) ; } Hash Map groups Map = new Hash Map ( NUM ) ; for ( int i = NUM ; i < locators . length ; i ++ ) { Locator Reg reg = remove Discovered Locator ( locators [ i ] ) ; if ( reg != null ) { groups Map . put ( reg . proxy , reg . member Groups ) ; continue ; } reg = find Reg ( locators [ i ] ) ; if ( reg != null ) { undiscovered Locators . remove ( reg ) ; } } if ( ! groups Map . is Empty ( ) && ! listeners . is Empty ( ) ) { add Notify ( ( Array List ) listeners . clone ( ) , groups Map , BOOL ) ; } } }
public void remove Locators ( Lookup Locator [ ] locators ) { test Set For Null ( locators ) ; synchronized ( this ) { if ( terminated ) { throw new Illegal State Exception ( STRING ) ; } Hash Map groups Map = new Hash Map ( NUM ) ; for ( int i = NUM ; i < locators . length ; i ++ ) { Locator Reg reg = remove Discovered Locator ( locators [ i ] ) ; if ( reg != null ) { groups Map . put ( reg . proxy , reg . member Groups ) ; continue ; } reg = find Reg ( locators [ i ] ) ; if ( reg != null ) { undiscovered Locators . remove ( reg ) ; } } if ( ! groups Map . is Empty ( ) && ! listeners . is Empty ( ) ) { add Notify ( ( Array List ) listeners . clone ( ) , groups Map , BOOL ) ; } } }
public void remove Locators ( Lookup Locator [ ] locators ) { test Set For Null ( locators ) ; synchronized ( this ) { if ( terminated ) { throw new Illegal State Exception ( STRING ) ; } Hash Map groups Map = new Hash Map ( NUM ) ; for ( int i = NUM ; i < locators . length ; i ++ ) { Locator Reg reg = remove Discovered Locator ( locators [ i ] ) ; if ( reg != null ) { groups Map . put ( reg . proxy , reg . member Groups ) ; continue ; } reg = find Reg ( locators [ i ] ) ; if ( reg != null ) { undiscovered Locators . remove ( reg ) ; } } if ( ! groups Map . is Empty ( ) && ! listeners . is Empty ( ) ) { add Notify ( ( Array List ) listeners . clone ( ) , groups Map , BOOL ) ; } } }
public static void compute Positions ( Node node , int depth , double aoff , double awid , int maxdepth ) { double r = depth / ( maxdepth - NUM ) ; node . x = Math . sin ( aoff + awid * NUM ) * r ; node . y = Math . cos ( aoff + awid * NUM ) * r ; double cpos = aoff ; double cwid = awid / node . weight ; for ( Node c : node . children ) { compute Positions ( c , depth + NUM , cpos , cwid * c . weight , maxdepth ) ; cpos += cwid * c . weight ; } }
private static double three Points Angle ( Point vertex , Point A , Point B ) { double b = points Distance ( vertex , A ) ; double c = points Distance ( A , B ) ; double a = points Distance ( B , vertex ) ; return Math . to Degrees ( Math . acos ( ( a * a + b * b - c * c ) / ( NUM * a * b ) ) ) ; }
public void delete String Attributes ( ) { delete Attribute Type ( Attribute . STRING ) ; }
public void step System ( int nstep ) { root = null ; make Tree ( nstep ) ; for ( Enumeration < Body > e = body Tab Rev . elements Rev ( ) ; e . has More Elements ( ) ; ) { Body b = e . next Element ( ) ; b . hack Gravity ( rsize , root ) ; } vp ( body Tab Rev , nstep ) ; }
public void step System ( int nstep ) { root = null ; make Tree ( nstep ) ; for ( Enumeration < Body > e = body Tab Rev . elements Rev ( ) ; e . has More Elements ( ) ; ) { Body b = e . next Element ( ) ; b . hack Gravity ( rsize , root ) ; } vp ( body Tab Rev , nstep ) ; }
public final void test ROUNDTRIP Get Key Spec Key Provider 01 ( ) { boolean performed = BOOL ; for ( int i = NUM ; i < alg Name . length ; i ++ ) { for ( int l = NUM ; l < provider . length ; l ++ ) { if ( provider [ l ] == null ) { continue ; } Test Data Generator g ; try { g = new Test Data Generator ( alg Name [ i ] [ NUM ] , alg Name [ i ] [ NUM ] , private Key Info , provider [ l ] ) ; } catch ( Test Data Generator . Allowed Failure allowed Failure ) { continue ; } try { Encrypted Private Key Info epki ; if ( g . ap ( ) == null ) { epki = new Encrypted Private Key Info ( alg Name [ i ] [ NUM ] , g . ct ( ) ) ; } else { epki = new Encrypted Private Key Info ( g . ap ( ) , g . ct ( ) ) ; } try { PKCS 8 Encoded Key Spec eks = epki . get Key Spec ( g . pub K ( ) == null ? g . k ( ) : g . pub K ( ) , provider [ l ] ) ; if ( ! Arrays . equals ( private Key Info , eks . get Encoded ( ) ) ) { fail ( alg Name [ i ] [ NUM ] + STRING + alg Name [ i ] [ NUM ] ) ; } } catch ( Invalid Key Exception e ) { fail ( alg Name [ i ] [ NUM ] + STRING + alg Name [ i ] [ NUM ] + STRING + e ) ; } performed = BOOL ; } catch ( No Such Algorithm Exception allowed Failure ) { } } } assert True ( STRING , performed ) ; }
public final void test ROUNDTRIP Get Key Spec Key Provider 01 ( ) { boolean performed = BOOL ; for ( int i = NUM ; i < alg Name . length ; i ++ ) { for ( int l = NUM ; l < provider . length ; l ++ ) { if ( provider [ l ] == null ) { continue ; } Test Data Generator g ; try { g = new Test Data Generator ( alg Name [ i ] [ NUM ] , alg Name [ i ] [ NUM ] , private Key Info , provider [ l ] ) ; } catch ( Test Data Generator . Allowed Failure allowed Failure ) { continue ; } try { Encrypted Private Key Info epki ; if ( g . ap ( ) == null ) { epki = new Encrypted Private Key Info ( alg Name [ i ] [ NUM ] , g . ct ( ) ) ; } else { epki = new Encrypted Private Key Info ( g . ap ( ) , g . ct ( ) ) ; } try { PKCS 8 Encoded Key Spec eks = epki . get Key Spec ( g . pub K ( ) == null ? g . k ( ) : g . pub K ( ) , provider [ l ] ) ; if ( ! Arrays . equals ( private Key Info , eks . get Encoded ( ) ) ) { fail ( alg Name [ i ] [ NUM ] + STRING + alg Name [ i ] [ NUM ] ) ; } } catch ( Invalid Key Exception e ) { fail ( alg Name [ i ] [ NUM ] + STRING + alg Name [ i ] [ NUM ] + STRING + e ) ; } performed = BOOL ; } catch ( No Such Algorithm Exception allowed Failure ) { } } } assert True ( STRING , performed ) ; }
public Multi Search Request add ( Search Request Builder request ) { requests . add ( request . request ( ) ) ; return this ; }
public Multi Search Request add ( Search Request Builder request ) { requests . add ( request . request ( ) ) ; return this ; }
private String check All Dependencies ( Hash Map < String , Module Descriptor > modlist ) { for ( Module Descriptor md : modlist . values ( ) ) { String res = check Dependencies ( md , modlist ) ; if ( ! res . is Empty ( ) ) { return res ; } } return STRING ; }
public boolean add Node ( Service Node node ) { try { return nodes . add ( node ) ; } catch ( Exception e ) { return BOOL ; } }
private void handle Crawl Delay ( Parse State state , Robot Token token ) { if ( state . is Skip Agents ( ) ) { return ; } state . set Finished Agent Fields ( BOOL ) ; if ( ! state . is Adding Rules ( ) ) { return ; } String delay String = token . get Data ( ) ; if ( delay String . length ( ) > NUM ) { try { if ( delay String . index Of ( STRING ) != - NUM ) { double delay Value = Double . parse Double ( delay String ) * NUM ; state . set Crawl Delay ( Math . round ( delay Value ) ) ; } else { long delay Value = Integer . parse Int ( delay String ) * NUM ; state . set Crawl Delay ( delay Value ) ; } } catch ( Exception e ) { report Warning ( STRING + delay String , state . get Url ( ) ) ; } } }
public Object [ ] to Array ( ) { Object [ ] rv = new Object [ delegate . size ( ) ] ; delegate . copy Into ( rv ) ; return rv ; }
public Object [ ] to Array ( ) { Object [ ] rv = new Object [ delegate . size ( ) ] ; delegate . copy Into ( rv ) ; return rv ; }
public Object [ ] to Array ( ) { Object [ ] rv = new Object [ delegate . size ( ) ] ; delegate . copy Into ( rv ) ; return rv ; }
public Event Listener Support ( final Class < L > listener Interface , final Class Loader class Loader ) { this ( ) ; Validate . not Null ( listener Interface , STRING ) ; Validate . not Null ( class Loader , STRING ) ; Validate . is True ( listener Interface . is Interface ( ) , STRING , listener Interface . get Name ( ) ) ; initialize Transient Fields ( listener Interface , class Loader ) ; }
public Event Listener Support ( final Class < L > listener Interface , final Class Loader class Loader ) { this ( ) ; Validate . not Null ( listener Interface , STRING ) ; Validate . not Null ( class Loader , STRING ) ; Validate . is True ( listener Interface . is Interface ( ) , STRING , listener Interface . get Name ( ) ) ; initialize Transient Fields ( listener Interface , class Loader ) ; }
public Event Listener Support ( final Class < L > listener Interface , final Class Loader class Loader ) { this ( ) ; Validate . not Null ( listener Interface , STRING ) ; Validate . not Null ( class Loader , STRING ) ; Validate . is True ( listener Interface . is Interface ( ) , STRING , listener Interface . get Name ( ) ) ; initialize Transient Fields ( listener Interface , class Loader ) ; }
public Event Listener Support ( final Class < L > listener Interface , final Class Loader class Loader ) { this ( ) ; Validate . not Null ( listener Interface , STRING ) ; Validate . not Null ( class Loader , STRING ) ; Validate . is True ( listener Interface . is Interface ( ) , STRING , listener Interface . get Name ( ) ) ; initialize Transient Fields ( listener Interface , class Loader ) ; }
public Event Listener Support ( final Class < L > listener Interface , final Class Loader class Loader ) { this ( ) ; Validate . not Null ( listener Interface , STRING ) ; Validate . not Null ( class Loader , STRING ) ; Validate . is True ( listener Interface . is Interface ( ) , STRING , listener Interface . get Name ( ) ) ; initialize Transient Fields ( listener Interface , class Loader ) ; }
public void remove User Lockout Entry ( String user DN ) { pw Reset Fail Hash . remove ( user DN ) ; user Warning Count = NUM ; }
private void code Wrap Argument ( Class < ? > type , int slot , Data Output Stream out ) throws IO Exception { if ( type . is Primitive ( ) ) { Primitive Type Info prim = Primitive Type Info . get ( type ) ; if ( type == int . class || type == boolean . class || type == byte . class || type == char . class || type == short . class ) { code iload ( slot , out ) ; } else if ( type == long . class ) { code lload ( slot , out ) ; } else if ( type == float . class ) { code fload ( slot , out ) ; } else if ( type == double . class ) { code dload ( slot , out ) ; } else { throw new Assertion Error ( ) ; } out . write Byte ( opc invokestatic ) ; out . write Short ( cp . get Method Ref ( prim . wrapper Class Name , STRING , prim . wrapper Value Of Desc ) ) ; } else { code aload ( slot , out ) ; } }
private void code Wrap Argument ( Class < ? > type , int slot , Data Output Stream out ) throws IO Exception { if ( type . is Primitive ( ) ) { Primitive Type Info prim = Primitive Type Info . get ( type ) ; if ( type == int . class || type == boolean . class || type == byte . class || type == char . class || type == short . class ) { code iload ( slot , out ) ; } else if ( type == long . class ) { code lload ( slot , out ) ; } else if ( type == float . class ) { code fload ( slot , out ) ; } else if ( type == double . class ) { code dload ( slot , out ) ; } else { throw new Assertion Error ( ) ; } out . write Byte ( opc invokestatic ) ; out . write Short ( cp . get Method Ref ( prim . wrapper Class Name , STRING , prim . wrapper Value Of Desc ) ) ; } else { code aload ( slot , out ) ; } }
private void draw X Axis Marker ( Canvas canvas , double value , Number Format number Format , int spacing ) { String marker = chart By Distance ? number Format . format ( value ) : String Utils . format Elapsed Time ( ( long ) value ) ; Rect rect = get Rect ( x Axis Marker Paint , marker ) ; canvas . draw Text ( marker , get X ( value ) , top Border + effective Height + spacing + rect . height ( ) , x Axis Marker Paint ) ; }
@ Override public void do after propagation ( ) { for ( Pt Ins Interval Manager pim : pt objs . values ( ) ) { pim . flush ( ) ; } new pts = new Hash Map < Alloc Node , Pt Ins Interval Manager > ( ) ; }
private static int [ ] flatten ( Set < Integer > [ ] algn ) { int [ ] flat Arr = new int [ algn . length ] ; for ( int i = NUM ; i < flat Arr . length ; ++ i ) { if ( algn [ i ] == null ) continue ; List < Integer > points = new Array List < > ( algn [ i ] ) ; int al = NUM ; for ( int j = NUM , sz = Math . min ( MAX FERTILITY , points . size ( ) ) ; j < sz ; ++ j ) { int pos = ( points . get ( j ) + NUM ) << ( j * NUM ) ; al |= pos ; } flat Arr [ i ] = al ; } return flat Arr ; }
private static int [ ] flatten ( Set < Integer > [ ] algn ) { int [ ] flat Arr = new int [ algn . length ] ; for ( int i = NUM ; i < flat Arr . length ; ++ i ) { if ( algn [ i ] == null ) continue ; List < Integer > points = new Array List < > ( algn [ i ] ) ; int al = NUM ; for ( int j = NUM , sz = Math . min ( MAX FERTILITY , points . size ( ) ) ; j < sz ; ++ j ) { int pos = ( points . get ( j ) + NUM ) << ( j * NUM ) ; al |= pos ; } flat Arr [ i ] = al ; } return flat Arr ; }
protected final void deserialize ( Object Input Stream ois , Collection coll ) throws IO Exception , Class Not Found Exception { int count = NUM ; count = ois . read Int ( ) ; while ( count -- > NUM ) { coll . add ( ois . read Object ( ) ) ; } }
protected final void deserialize ( Object Input Stream ois , Collection coll ) throws IO Exception , Class Not Found Exception { int count = NUM ; count = ois . read Int ( ) ; while ( count -- > NUM ) { coll . add ( ois . read Object ( ) ) ; } }
public boolean splits Taxa ( Bit Set taxa ) { return A . intersects ( taxa ) && B . intersects ( taxa ) ; }
public boolean splits Taxa ( Bit Set taxa ) { return A . intersects ( taxa ) && B . intersects ( taxa ) ; }
public static void to Do ( @ Scope int scope , String tag ) { List < Long > tag Seen List = tag Last Seen Map . get ( tag ) ; if ( tag Seen List . is Empty ( ) ) { to Do Set . put ( tag ) ; return ; } Long tag Last Seen = tag Seen List . get ( tag Seen List . size ( ) - NUM ) ; if ( scope == THIS APP VERSION && tag Last Seen <= last App Updated Time ) { to Do Set . put ( tag ) ; } }
public static void to Do ( @ Scope int scope , String tag ) { List < Long > tag Seen List = tag Last Seen Map . get ( tag ) ; if ( tag Seen List . is Empty ( ) ) { to Do Set . put ( tag ) ; return ; } Long tag Last Seen = tag Seen List . get ( tag Seen List . size ( ) - NUM ) ; if ( scope == THIS APP VERSION && tag Last Seen <= last App Updated Time ) { to Do Set . put ( tag ) ; } }
public static void clear ( String realm Name ) { boolean is Default = is Default Org ( realm Name ) ; if ( ( auth Ctx Obj Hash != null ) && ( ! auth Ctx Obj Hash . is Empty ( ) ) ) { Enumeration keys = auth Ctx Obj Hash . keys ( ) ; while ( keys . has More Elements ( ) ) { String key = ( String ) keys . next Element ( ) ; if ( key . index Of ( STRING + realm Name ) != - NUM ) { auth Ctx Obj Hash . remove ( key ) ; } if ( is Default && key . ends With ( STRING ) ) { auth Ctx Obj Hash . remove ( key ) ; } } } if ( ( auth Context Hash != null ) && ( ! auth Context Hash . is Empty ( ) ) ) { Enumeration keys = auth Context Hash . keys ( ) ; while ( keys . has More Elements ( ) ) { String key = ( String ) keys . next Element ( ) ; if ( key . index Of ( STRING + realm Name ) != - NUM ) { auth Context Hash . remove ( key ) ; } if ( is Default && key . ends With ( STRING ) ) { auth Ctx Obj Hash . remove ( key ) ; } } } }
protected final void fire Vetoable Change ( String property Name , float old Value , float new Value ) throws Property Veto Exception { fire Vetoable Change ( property Name , Float . value Of ( old Value ) , Float . value Of ( new Value ) ) ; }
protected final void fire Vetoable Change ( String property Name , float old Value , float new Value ) throws Property Veto Exception { fire Vetoable Change ( property Name , Float . value Of ( old Value ) , Float . value Of ( new Value ) ) ; }
private void write Int ( Data Output out , int val ) throws IO Exception { int Buf [ NUM ] = ( byte ) ( val > > NUM ) ; int Buf [ NUM ] = ( byte ) ( val > > NUM ) ; int Buf [ NUM ] = ( byte ) ( val > > NUM ) ; int Buf [ NUM ] = ( byte ) val ; out . write ( int Buf ) ; }
private void write Int ( Data Output out , int val ) throws IO Exception { int Buf [ NUM ] = ( byte ) ( val > > NUM ) ; int Buf [ NUM ] = ( byte ) ( val > > NUM ) ; int Buf [ NUM ] = ( byte ) ( val > > NUM ) ; int Buf [ NUM ] = ( byte ) val ; out . write ( int Buf ) ; }
private boolean is Mech Factory Property ( String prop ) { return ( prop . starts With ( PROV PROP PREFIX ) || prop . region Matches ( BOOL , NUM , PROV PROP PREFIX , NUM , PROV PROP PREFIX LEN ) ) ; }
private boolean is Mech Factory Property ( String prop ) { return ( prop . starts With ( PROV PROP PREFIX ) || prop . region Matches ( BOOL , NUM , PROV PROP PREFIX , NUM , PROV PROP PREFIX LEN ) ) ; }
@ Request Mapping ( value = STRING , method = Request Method . DELETE ) @ Response Body public Rest Wrapper delete ( @ Path Variable ( STRING ) Long queue Id , Principal principal ) { Rest Wrapper rest Wrapper = null ; try { batch Consump Queue DAO . delete ( queue Id ) ; rest Wrapper = new Rest Wrapper ( null , Rest Wrapper . OK ) ; LOGGER . info ( RECORDWITHID + queue Id + STRING + principal . get Name ( ) ) ; } catch ( Metadata Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
private static void skip Member Value ( int tag , Byte Buffer buf ) { switch ( tag ) { case STRING : buf . get Int ( ) ; break ; case STRING : skip Annotation ( buf , BOOL ) ; break ; case STRING : skip Array ( buf ) ; break ; default : buf . get Short ( ) ; } }
private static void skip Member Value ( int tag , Byte Buffer buf ) { switch ( tag ) { case STRING : buf . get Int ( ) ; break ; case STRING : skip Annotation ( buf , BOOL ) ; break ; case STRING : skip Array ( buf ) ; break ; default : buf . get Short ( ) ; } }
private static void skip Member Value ( int tag , Byte Buffer buf ) { switch ( tag ) { case STRING : buf . get Int ( ) ; break ; case STRING : skip Annotation ( buf , BOOL ) ; break ; case STRING : skip Array ( buf ) ; break ; default : buf . get Short ( ) ; } }
private static void skip Member Value ( int tag , Byte Buffer buf ) { switch ( tag ) { case STRING : buf . get Int ( ) ; break ; case STRING : skip Annotation ( buf , BOOL ) ; break ; case STRING : skip Array ( buf ) ; break ; default : buf . get Short ( ) ; } }
private static void skip Member Value ( int tag , Byte Buffer buf ) { switch ( tag ) { case STRING : buf . get Int ( ) ; break ; case STRING : skip Annotation ( buf , BOOL ) ; break ; case STRING : skip Array ( buf ) ; break ; default : buf . get Short ( ) ; } }
public static void add Event Callback ( I Event Callback callback ) { s Event Callback . add ( callback ) ; }
public static void add Event Callback ( I Event Callback callback ) { s Event Callback . add ( callback ) ; }
private Map < URI , Storage System > build Array Map ( List < Volume Descriptor > descriptors , Volume Descriptor . Type type ) { Map < URI , Storage System > array Map = new Hash Map < URI , Storage System > ( ) ; if ( type != null ) { descriptors = Volume Descriptor . filter By Type ( descriptors , new Volume Descriptor . Type [ ] { type } , new Volume Descriptor . Type [ ] { } ) ; } for ( Volume Descriptor desc : descriptors ) { if ( array Map . contains Key ( desc . get Device URI ( ) ) == BOOL ) { Storage System array = get Data Object ( Storage System . class , desc . get Device URI ( ) , db Client ) ; array Map . put ( desc . get Device URI ( ) , array ) ; } } return array Map ; }
public void run Test On Method ( Media Player Method Under Test test Method ) { m Method Under Test = test Method ; if ( m Method Under Test != null ) { initialize Message Looper ( ) ; synchronized ( lock ) { try { lock . wait ( WAIT FOR COMMAND TO COMPLETE ) ; } catch ( Exception e ) { Log . v ( TAG , STRING ) ; } } assert True ( m Initialized ) ; check Method Under Test In All Possible States ( ) ; terminate Message Looper ( ) ; assert True ( m On Completion Has Been Called ) ; m Method Under Test . check State Errors ( m State Errors ) ; clean Up ( ) ; } }
public Sc Copy Mirror Migrate create Mirror ( String ssn , String src Id , String dst Id ) throws Storage Center API Exception { Parameters params = new Parameters ( ) ; params . add ( STRING , ssn ) ; params . add ( STRING , src Id ) ; params . add ( STRING , dst Id ) ; params . add ( STRING , BOOL ) ; Rest Result rr = rest Client . post ( STRING , params . to Json ( ) ) ; if ( ! check Results ( rr ) ) { String msg = String . format ( STRING , src Id , dst Id , rr . get Error Msg ( ) ) ; LOG . warn ( msg ) ; throw new Storage Center API Exception ( msg ) ; } return gson . from Json ( rr . get Result ( ) , Sc Copy Mirror Migrate . class ) ; }
public Sc Copy Mirror Migrate create Mirror ( String ssn , String src Id , String dst Id ) throws Storage Center API Exception { Parameters params = new Parameters ( ) ; params . add ( STRING , ssn ) ; params . add ( STRING , src Id ) ; params . add ( STRING , dst Id ) ; params . add ( STRING , BOOL ) ; Rest Result rr = rest Client . post ( STRING , params . to Json ( ) ) ; if ( ! check Results ( rr ) ) { String msg = String . format ( STRING , src Id , dst Id , rr . get Error Msg ( ) ) ; LOG . warn ( msg ) ; throw new Storage Center API Exception ( msg ) ; } return gson . from Json ( rr . get Result ( ) , Sc Copy Mirror Migrate . class ) ; }
public boolean is No Text Mode ( ) { return no Text Mode ; }
public boolean is No Text Mode ( ) { return no Text Mode ; }
public boolean is No Text Mode ( ) { return no Text Mode ; }
static final void cancel Ignoring Exceptions ( Fork Join Task < ? > t ) { if ( t != null && t . status >= NUM ) { try { t . cancel ( BOOL ) ; } catch ( Throwable ignore ) { } } }
static final void cancel Ignoring Exceptions ( Fork Join Task < ? > t ) { if ( t != null && t . status >= NUM ) { try { t . cancel ( BOOL ) ; } catch ( Throwable ignore ) { } } }
static final void cancel Ignoring Exceptions ( Fork Join Task < ? > t ) { if ( t != null && t . status >= NUM ) { try { t . cancel ( BOOL ) ; } catch ( Throwable ignore ) { } } }
protected void check JAXP Version ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; final Class no Args [ ] = new Class [ NUM ] ; Class clazz = null ; try { final String JAXP 1 CLASS = STRING ; final String JAXP 11 METHOD = STRING ; clazz = Object Factory . find Provider Class ( JAXP 1 CLASS , Object Factory . find Class Loader ( ) , BOOL ) ; Method method = clazz . get Method ( JAXP 11 METHOD , no Args ) ; h . put ( VERSION + STRING , STRING ) ; } catch ( Exception e ) { if ( null != clazz ) { h . put ( ERROR + VERSION + STRING , STRING ) ; h . put ( ERROR , ERROR FOUND ) ; } else { h . put ( ERROR + VERSION + STRING , CLASS NOTPRESENT ) ; h . put ( ERROR , ERROR FOUND ) ; } } }
public final void test Add All Helper Texts From Array ( ) { Char Sequence helper Text 1 = STRING ; Char Sequence helper Text 2 = STRING ; Char Sequence [ ] helper Texts 1 = new Char Sequence [ NUM ] ; helper Texts 1 [ NUM ] = helper Text 1 ; helper Texts 1 [ NUM ] = helper Text 2 ; Password Edit Text password Edit Text = new Password Edit Text ( get Context ( ) ) ; password Edit Text . add All Helper Texts ( helper Texts 1 ) ; password Edit Text . add All Helper Texts ( helper Texts 1 ) ; Collection < Char Sequence > helper Texts 2 = password Edit Text . get Helper Texts ( ) ; assert Equals ( helper Texts 1 . length , helper Texts 2 . size ( ) ) ; Iterator < Char Sequence > iterator = helper Texts 2 . iterator ( ) ; assert Equals ( helper Text 1 , iterator . next ( ) ) ; assert Equals ( helper Text 2 , iterator . next ( ) ) ; }
public final void test Add All Helper Texts From Array ( ) { Char Sequence helper Text 1 = STRING ; Char Sequence helper Text 2 = STRING ; Char Sequence [ ] helper Texts 1 = new Char Sequence [ NUM ] ; helper Texts 1 [ NUM ] = helper Text 1 ; helper Texts 1 [ NUM ] = helper Text 2 ; Password Edit Text password Edit Text = new Password Edit Text ( get Context ( ) ) ; password Edit Text . add All Helper Texts ( helper Texts 1 ) ; password Edit Text . add All Helper Texts ( helper Texts 1 ) ; Collection < Char Sequence > helper Texts 2 = password Edit Text . get Helper Texts ( ) ; assert Equals ( helper Texts 1 . length , helper Texts 2 . size ( ) ) ; Iterator < Char Sequence > iterator = helper Texts 2 . iterator ( ) ; assert Equals ( helper Text 1 , iterator . next ( ) ) ; assert Equals ( helper Text 2 , iterator . next ( ) ) ; }
void add Nodes ( List < Node > new Nodes , boolean at Beginning ) { if ( at Beginning ) { if ( ( nodes . size ( ) > NUM ) && nodes . get ( NUM ) == new Nodes . get ( new Nodes . size ( ) - NUM ) ) { Log . i ( DEBUG TAG , STRING ) ; if ( new Nodes . size ( ) > NUM ) { Log . i ( DEBUG TAG , STRING ) ; new Nodes . remove ( new Nodes . size ( ) - NUM ) ; add Nodes ( new Nodes , at Beginning ) ; } return ; } nodes . add All ( NUM , new Nodes ) ; } else { if ( ( nodes . size ( ) > NUM ) && new Nodes . get ( NUM ) == nodes . get ( nodes . size ( ) - NUM ) ) { Log . i ( DEBUG TAG , STRING ) ; if ( new Nodes . size ( ) > NUM ) { Log . i ( DEBUG TAG , STRING ) ; new Nodes . remove ( NUM ) ; add Nodes ( new Nodes , at Beginning ) ; } return ; } nodes . add All ( new Nodes ) ; } }
void add Nodes ( List < Node > new Nodes , boolean at Beginning ) { if ( at Beginning ) { if ( ( nodes . size ( ) > NUM ) && nodes . get ( NUM ) == new Nodes . get ( new Nodes . size ( ) - NUM ) ) { Log . i ( DEBUG TAG , STRING ) ; if ( new Nodes . size ( ) > NUM ) { Log . i ( DEBUG TAG , STRING ) ; new Nodes . remove ( new Nodes . size ( ) - NUM ) ; add Nodes ( new Nodes , at Beginning ) ; } return ; } nodes . add All ( NUM , new Nodes ) ; } else { if ( ( nodes . size ( ) > NUM ) && new Nodes . get ( NUM ) == nodes . get ( nodes . size ( ) - NUM ) ) { Log . i ( DEBUG TAG , STRING ) ; if ( new Nodes . size ( ) > NUM ) { Log . i ( DEBUG TAG , STRING ) ; new Nodes . remove ( NUM ) ; add Nodes ( new Nodes , at Beginning ) ; } return ; } nodes . add All ( new Nodes ) ; } }
void add Nodes ( List < Node > new Nodes , boolean at Beginning ) { if ( at Beginning ) { if ( ( nodes . size ( ) > NUM ) && nodes . get ( NUM ) == new Nodes . get ( new Nodes . size ( ) - NUM ) ) { Log . i ( DEBUG TAG , STRING ) ; if ( new Nodes . size ( ) > NUM ) { Log . i ( DEBUG TAG , STRING ) ; new Nodes . remove ( new Nodes . size ( ) - NUM ) ; add Nodes ( new Nodes , at Beginning ) ; } return ; } nodes . add All ( NUM , new Nodes ) ; } else { if ( ( nodes . size ( ) > NUM ) && new Nodes . get ( NUM ) == nodes . get ( nodes . size ( ) - NUM ) ) { Log . i ( DEBUG TAG , STRING ) ; if ( new Nodes . size ( ) > NUM ) { Log . i ( DEBUG TAG , STRING ) ; new Nodes . remove ( NUM ) ; add Nodes ( new Nodes , at Beginning ) ; } return ; } nodes . add All ( new Nodes ) ; } }
public static Example Formatter compile ( String format String , Example Set example Set , int fraction Digits , boolean quote Whitespace ) throws Formatter Exception { List < Format Command > command List = new Linked List < Format Command > ( ) ; compile ( format String , example Set , command List , fraction Digits , quote Whitespace ) ; Format Command [ ] commands = new Format Command [ command List . size ( ) ] ; command List . to Array ( commands ) ; return new Example Formatter ( commands ) ; }
public static Example Formatter compile ( String format String , Example Set example Set , int fraction Digits , boolean quote Whitespace ) throws Formatter Exception { List < Format Command > command List = new Linked List < Format Command > ( ) ; compile ( format String , example Set , command List , fraction Digits , quote Whitespace ) ; Format Command [ ] commands = new Format Command [ command List . size ( ) ] ; command List . to Array ( commands ) ; return new Example Formatter ( commands ) ; }
public void add All ( I Vector v ) { expand For ( size + v . size - NUM , NUM ) ; System . arraycopy ( v . vector , NUM , vector , size - v . size , v . size ) ; }
public void add All ( I Vector v ) { expand For ( size + v . size - NUM , NUM ) ; System . arraycopy ( v . vector , NUM , vector , size - v . size , v . size ) ; }
public void add All ( I Vector v ) { expand For ( size + v . size - NUM , NUM ) ; System . arraycopy ( v . vector , NUM , vector , size - v . size , v . size ) ; }
public void add Op Auths ( final Class < ? extends Operation > op Class , final String ... auths ) { Set < String > op Auths = op Auths Map . get ( op Class ) ; if ( null == op Auths ) { op Auths = new Hash Set < > ( ) ; op Auths Map . put ( op Class , op Auths ) ; } Collections . add All ( op Auths , auths ) ; Collections . add All ( all Op Auths , auths ) ; }
public void add Op Auths ( final Class < ? extends Operation > op Class , final String ... auths ) { Set < String > op Auths = op Auths Map . get ( op Class ) ; if ( null == op Auths ) { op Auths = new Hash Set < > ( ) ; op Auths Map . put ( op Class , op Auths ) ; } Collections . add All ( op Auths , auths ) ; Collections . add All ( all Op Auths , auths ) ; }
public void add Op Auths ( final Class < ? extends Operation > op Class , final String ... auths ) { Set < String > op Auths = op Auths Map . get ( op Class ) ; if ( null == op Auths ) { op Auths = new Hash Set < > ( ) ; op Auths Map . put ( op Class , op Auths ) ; } Collections . add All ( op Auths , auths ) ; Collections . add All ( all Op Auths , auths ) ; }
private List < Column Model > find Columns To Add ( ) { List < Column Model > columns To Add = new Array List < Column Model > ( ) ; for ( Column Model column Model : m Table Model . get Column Models ( ) ) { String column Name = column Model . get Column Name ( ) ; if ( ! m Table Model DB . contains Column ( column Name ) ) { columns To Add . add ( column Model ) ; } } return columns To Add ; }
private List < Column Model > find Columns To Add ( ) { List < Column Model > columns To Add = new Array List < Column Model > ( ) ; for ( Column Model column Model : m Table Model . get Column Models ( ) ) { String column Name = column Model . get Column Name ( ) ; if ( ! m Table Model DB . contains Column ( column Name ) ) { columns To Add . add ( column Model ) ; } } return columns To Add ; }
private List < Column Model > find Columns To Add ( ) { List < Column Model > columns To Add = new Array List < Column Model > ( ) ; for ( Column Model column Model : m Table Model . get Column Models ( ) ) { String column Name = column Model . get Column Name ( ) ; if ( ! m Table Model DB . contains Column ( column Name ) ) { columns To Add . add ( column Model ) ; } } return columns To Add ; }
protected void initialize Data Extends ( Relation < Number Vector > relation , int dim , double [ ] min , double [ ] extend ) { assert ( min . length == dim && extend . length == dim ) ; if ( minima == null || maxima == null || minima . length == NUM || maxima . length == NUM ) { double [ ] [ ] minmax = Relation Util . compute Min Max ( relation ) ; final double [ ] dmin = minmax [ NUM ] , dmax = minmax [ NUM ] ; for ( int d = NUM ; d < dim ; d ++ ) { min [ d ] = dmin [ d ] ; extend [ d ] = dmax [ d ] - dmin [ d ] ; } return ; } if ( minima . length == dim ) { System . arraycopy ( minima , NUM , min , NUM , dim ) ; } else if ( minima . length == NUM ) { Arrays . fill ( min , minima [ NUM ] ) ; } else { throw new Abort Exception ( STRING + dim + STRING + minima . length ) ; } if ( maxima . length == dim ) { for ( int d = NUM ; d < dim ; d ++ ) { extend [ d ] = maxima [ d ] - min [ d ] ; } return ; } else if ( maxima . length == NUM ) { for ( int d = NUM ; d < dim ; d ++ ) { extend [ d ] = maxima [ NUM ] - min [ d ] ; } return ; } else { throw new Abort Exception ( STRING + dim + STRING + maxima . length ) ; } }
public void encode ( Output Stream out ) throws IO Exception { Der Output Stream tmp = new Der Output Stream ( ) ; if ( this . extension Value == null ) { this . extension Id = PKIX Extensions . Invalidity Date Id ; this . critical = BOOL ; encode This ( ) ; } super . encode ( tmp ) ; out . write ( tmp . to Byte Array ( ) ) ; }
public static void delete By Column Value ( final C Connection connection , final String table Name , final String column Name , final int column Value ) throws Couldnt Delete Exception { Preconditions . check Not Null ( connection , STRING ) ; Preconditions . check Not Null ( table Name , STRING ) ; Preconditions . check Not Null ( column Name , STRING ) ; Preconditions . check Argument ( column Value >= NUM , STRING ) ; try { connection . execute Update ( String . format ( STRING , table Name , column Name , column Value ) , BOOL ) ; } catch ( final SQL Exception exception ) { throw new Couldnt Delete Exception ( exception ) ; } }
public static void delete By Column Value ( final C Connection connection , final String table Name , final String column Name , final int column Value ) throws Couldnt Delete Exception { Preconditions . check Not Null ( connection , STRING ) ; Preconditions . check Not Null ( table Name , STRING ) ; Preconditions . check Not Null ( column Name , STRING ) ; Preconditions . check Argument ( column Value >= NUM , STRING ) ; try { connection . execute Update ( String . format ( STRING , table Name , column Name , column Value ) , BOOL ) ; } catch ( final SQL Exception exception ) { throw new Couldnt Delete Exception ( exception ) ; } }
private void add Generated JS Resource ( Faces Context context , String resource Name , String library , UI View Root view ) { add Generated Resource ( context , resource Name , STRING , library , view ) ; }
public S2 Cap complement ( ) { double c Height = is Full ( ) ? - NUM : NUM - Math . max ( height , NUM ) ; return S2 Cap . from Axis Height ( S2 Point . neg ( axis ) , c Height ) ; }
public S2 Cap complement ( ) { double c Height = is Full ( ) ? - NUM : NUM - Math . max ( height , NUM ) ; return S2 Cap . from Axis Height ( S2 Point . neg ( axis ) , c Height ) ; }
public S2 Cap complement ( ) { double c Height = is Full ( ) ? - NUM : NUM - Math . max ( height , NUM ) ; return S2 Cap . from Axis Height ( S2 Point . neg ( axis ) , c Height ) ; }
public S2 Cap complement ( ) { double c Height = is Full ( ) ? - NUM : NUM - Math . max ( height , NUM ) ; return S2 Cap . from Axis Height ( S2 Point . neg ( axis ) , c Height ) ; }
public S2 Cap complement ( ) { double c Height = is Full ( ) ? - NUM : NUM - Math . max ( height , NUM ) ; return S2 Cap . from Axis Height ( S2 Point . neg ( axis ) , c Height ) ; }
public static boolean is Extension ( String filename , String extension ) { if ( filename == null ) return BOOL ; if ( extension == null || extension . length ( ) == NUM ) return index Of Extension ( filename ) == - NUM ; String file Ext = get Extension ( filename ) ; return file Ext . equals ( extension ) ; }
public static boolean is Extension ( String filename , String extension ) { if ( filename == null ) return BOOL ; if ( extension == null || extension . length ( ) == NUM ) return index Of Extension ( filename ) == - NUM ; String file Ext = get Extension ( filename ) ; return file Ext . equals ( extension ) ; }
public static boolean is Extension ( String filename , String extension ) { if ( filename == null ) return BOOL ; if ( extension == null || extension . length ( ) == NUM ) return index Of Extension ( filename ) == - NUM ; String file Ext = get Extension ( filename ) ; return file Ext . equals ( extension ) ; }
public static boolean is Extension ( String filename , String extension ) { if ( filename == null ) return BOOL ; if ( extension == null || extension . length ( ) == NUM ) return index Of Extension ( filename ) == - NUM ; String file Ext = get Extension ( filename ) ; return file Ext . equals ( extension ) ; }
public static boolean is Extension ( String filename , String extension ) { if ( filename == null ) return BOOL ; if ( extension == null || extension . length ( ) == NUM ) return index Of Extension ( filename ) == - NUM ; String file Ext = get Extension ( filename ) ; return file Ext . equals ( extension ) ; }
public Cloudlet ( final int cloudlet Id , final long cloudlet Length , final int pes Number , final long cloudlet File Size , final long cloudlet Output Size , final Utilization Model utilization Model Cpu , final Utilization Model utilization Model Ram , final Utilization Model utilization Model Bw , final boolean record ) { user Id = - NUM ; status = CREATED ; this . cloudlet Id = cloudlet Id ; number Of Pes = pes Number ; exec Start Time = NUM ; finish Time = - NUM ; class Type = NUM ; net To S = NUM ; this . cloudlet Length = Math . max ( NUM , cloudlet Length ) ; this . cloudlet File Size = Math . max ( NUM , cloudlet File Size ) ; this . cloudlet Output Size = Math . max ( NUM , cloudlet Output Size ) ; res List = new Array List < Resource > ( NUM ) ; index = - NUM ; this . record = record ; vm Id = - NUM ; accumulated Bw Cost = NUM ; cost Per Bw = NUM ; required Files = new Linked List < String > ( ) ; set Utilization Model Cpu ( utilization Model Cpu ) ; set Utilization Model Ram ( utilization Model Ram ) ; set Utilization Model Bw ( utilization Model Bw ) ; }
private void apply Use Schema ( String schema ) throws SQL Exception { boolean schema Set = BOOL ; if ( schema != null && schema . length ( ) > NUM && ! schema . equals ( this . current Schema ) ) { current Schema = schema ; if ( conn . supports Use Default Schema ( ) ) { String use Query = conn . get Use Schema Query ( schema ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + use Query ) ; } statement . add Batch ( use Query ) ; schema Set = BOOL ; } } if ( ! schema Set ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + schema + STRING + current Schema ) ; } } }
private void apply Use Schema ( String schema ) throws SQL Exception { boolean schema Set = BOOL ; if ( schema != null && schema . length ( ) > NUM && ! schema . equals ( this . current Schema ) ) { current Schema = schema ; if ( conn . supports Use Default Schema ( ) ) { String use Query = conn . get Use Schema Query ( schema ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + use Query ) ; } statement . add Batch ( use Query ) ; schema Set = BOOL ; } } if ( ! schema Set ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + schema + STRING + current Schema ) ; } } }
private void apply Use Schema ( String schema ) throws SQL Exception { boolean schema Set = BOOL ; if ( schema != null && schema . length ( ) > NUM && ! schema . equals ( this . current Schema ) ) { current Schema = schema ; if ( conn . supports Use Default Schema ( ) ) { String use Query = conn . get Use Schema Query ( schema ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + use Query ) ; } statement . add Batch ( use Query ) ; schema Set = BOOL ; } } if ( ! schema Set ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + schema + STRING + current Schema ) ; } } }
private void apply Use Schema ( String schema ) throws SQL Exception { boolean schema Set = BOOL ; if ( schema != null && schema . length ( ) > NUM && ! schema . equals ( this . current Schema ) ) { current Schema = schema ; if ( conn . supports Use Default Schema ( ) ) { String use Query = conn . get Use Schema Query ( schema ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + use Query ) ; } statement . add Batch ( use Query ) ; schema Set = BOOL ; } } if ( ! schema Set ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + schema + STRING + current Schema ) ; } } }
private void apply Use Schema ( String schema ) throws SQL Exception { boolean schema Set = BOOL ; if ( schema != null && schema . length ( ) > NUM && ! schema . equals ( this . current Schema ) ) { current Schema = schema ; if ( conn . supports Use Default Schema ( ) ) { String use Query = conn . get Use Schema Query ( schema ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + use Query ) ; } statement . add Batch ( use Query ) ; schema Set = BOOL ; } } if ( ! schema Set ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + schema + STRING + current Schema ) ; } } }
public Drop Down Popup Button Builder add ( J Menu Item item ) { popup Menu . add ( item ) ; return this ; }
public Drop Down Popup Button Builder add ( J Menu Item item ) { popup Menu . add ( item ) ; return this ; }
public Builder delete Nick Name ( ) { delete Fields . add ( STRING ) ; return this ; }
public static Query Task wait For Query ( Service Host host , String referrer , Query Task query , Predicate < Query Task > predicate , long wait Iteration Count , long wait Iteration Sleep ) throws Throwable { for ( int i = NUM ; i < wait Iteration Count ; i ++ ) { Query Task result = send Query And Wait ( host , referrer , query ) ; if ( predicate . test ( result ) ) { return result ; } Thread . sleep ( wait Iteration Sleep ) ; } throw new Runtime Exception ( STRING ) ; }
public static Query Task wait For Query ( Service Host host , String referrer , Query Task query , Predicate < Query Task > predicate , long wait Iteration Count , long wait Iteration Sleep ) throws Throwable { for ( int i = NUM ; i < wait Iteration Count ; i ++ ) { Query Task result = send Query And Wait ( host , referrer , query ) ; if ( predicate . test ( result ) ) { return result ; } Thread . sleep ( wait Iteration Sleep ) ; } throw new Runtime Exception ( STRING ) ; }
boolean is Valid Scheme ( String scheme ) { for ( int i = NUM ; i < scheme . length ( ) ; i ++ ) { char ch = scheme . char At ( i ) ; if ( URI Helper . is Alpha ( ch ) || URI Helper . is Numeric ( ch ) || ch == STRING ) { continue ; } return BOOL ; } return BOOL ; }
boolean is Valid Scheme ( String scheme ) { for ( int i = NUM ; i < scheme . length ( ) ; i ++ ) { char ch = scheme . char At ( i ) ; if ( URI Helper . is Alpha ( ch ) || URI Helper . is Numeric ( ch ) || ch == STRING ) { continue ; } return BOOL ; } return BOOL ; }
boolean is Valid Scheme ( String scheme ) { for ( int i = NUM ; i < scheme . length ( ) ; i ++ ) { char ch = scheme . char At ( i ) ; if ( URI Helper . is Alpha ( ch ) || URI Helper . is Numeric ( ch ) || ch == STRING ) { continue ; } return BOOL ; } return BOOL ; }
private void digits To Words ( Word Relation word Relation , Item token Item , String token Val ) { Feature Set feature Set = token Item . get Features ( ) ; String nsw = STRING ; if ( feature Set . is Present ( STRING ) ) { nsw = feature Set . get String ( STRING ) ; } if ( nsw . equals ( STRING ) ) { Number Expander . expand ID ( token Val , word Relation , token Item ) ; } else { String r Name = feature Set . get String ( STRING ) ; String digits Type = null ; if ( token Val . equals ( r Name ) ) { digits Type = ( String ) cart . interpret ( token Item ) ; } else { feature Set . set String ( STRING , token Val ) ; digits Type = ( String ) cart . interpret ( token Item ) ; feature Set . set String ( STRING , r Name ) ; } if ( digits Type . equals ( STRING ) ) { Number Expander . expand Ordinal ( token Val , word Relation , token Item ) ; } else if ( digits Type . equals ( STRING ) ) { Number Expander . expand Digits ( token Val , word Relation , token Item ) ; } else if ( digits Type . equals ( STRING ) ) { Number Expander . expand ID ( token Val , word Relation , token Item ) ; } else { Number Expander . expand Number ( token Val , word Relation , token Item ) ; } } }
public static Print Writer new Print Writer ( Path self ) throws IO Exception { return new Groovy Print Writer ( new Writer ( self ) ) ; }
private void destroy Internal Session ( Session ID session ID ) { Internal Session sess = session Access Manager . remove Internal Session ( session ID ) ; if ( sess != null && sess . get State ( ) != INVALID ) { signal Remove ( sess , Session Event Type . DESTROY ) ; session Auditor . audit Activity ( sess . to Session Info ( ) , AM SESSION DESTROYED ) ; } session Access Manager . remove Session Id ( session ID ) ; }
public Set < Resource > find Same As ( Resource value , Resource ... contxts ) throws Inference Engine Exception { Set < Resource > same As = new Hash Set < Resource > ( ) ; same As . add ( value ) ; find Same As Chaining ( value , same As , contxts ) ; return same As ; }
public Set < Resource > find Same As ( Resource value , Resource ... contxts ) throws Inference Engine Exception { Set < Resource > same As = new Hash Set < Resource > ( ) ; same As . add ( value ) ; find Same As Chaining ( value , same As , contxts ) ; return same As ; }
public Set < Resource > find Same As ( Resource value , Resource ... contxts ) throws Inference Engine Exception { Set < Resource > same As = new Hash Set < Resource > ( ) ; same As . add ( value ) ; find Same As Chaining ( value , same As , contxts ) ; return same As ; }
public Set < Resource > find Same As ( Resource value , Resource ... contxts ) throws Inference Engine Exception { Set < Resource > same As = new Hash Set < Resource > ( ) ; same As . add ( value ) ; find Same As Chaining ( value , same As , contxts ) ; return same As ; }
public Set < Resource > find Same As ( Resource value , Resource ... contxts ) throws Inference Engine Exception { Set < Resource > same As = new Hash Set < Resource > ( ) ; same As . add ( value ) ; find Same As Chaining ( value , same As , contxts ) ; return same As ; }
public Set < Resource > find Same As ( Resource value , Resource ... contxts ) throws Inference Engine Exception { Set < Resource > same As = new Hash Set < Resource > ( ) ; same As . add ( value ) ; find Same As Chaining ( value , same As , contxts ) ; return same As ; }
public Set < Resource > find Same As ( Resource value , Resource ... contxts ) throws Inference Engine Exception { Set < Resource > same As = new Hash Set < Resource > ( ) ; same As . add ( value ) ; find Same As Chaining ( value , same As , contxts ) ; return same As ; }
public Hashed Block Output Stream ( Output Stream output Stream ) { this ( output Stream , BOOL ) ; }
public int read ( ) throws java . io . IO Exception { synchronized ( lock ) { char char Array [ ] = new char [ NUM ] ; if ( read ( char Array , NUM , NUM ) != - NUM ) { return char Array [ NUM ] ; } return - NUM ; } }
public int read ( ) throws java . io . IO Exception { synchronized ( lock ) { char char Array [ ] = new char [ NUM ] ; if ( read ( char Array , NUM , NUM ) != - NUM ) { return char Array [ NUM ] ; } return - NUM ; } }
public int read ( ) throws java . io . IO Exception { synchronized ( lock ) { char char Array [ ] = new char [ NUM ] ; if ( read ( char Array , NUM , NUM ) != - NUM ) { return char Array [ NUM ] ; } return - NUM ; } }
public int read ( ) throws java . io . IO Exception { synchronized ( lock ) { char char Array [ ] = new char [ NUM ] ; if ( read ( char Array , NUM , NUM ) != - NUM ) { return char Array [ NUM ] ; } return - NUM ; } }
public int read ( ) throws java . io . IO Exception { synchronized ( lock ) { char char Array [ ] = new char [ NUM ] ; if ( read ( char Array , NUM , NUM ) != - NUM ) { return char Array [ NUM ] ; } return - NUM ; } }
public void connection Open ( ) { lock . lock ( ) ; try { log . info ( STRING ) ; connection Open = BOOL ; } finally { lock . unlock ( ) ; } }
public void connection Open ( ) { lock . lock ( ) ; try { log . info ( STRING ) ; connection Open = BOOL ; } finally { lock . unlock ( ) ; } }
private static int check Numeric Zone ( String s ) throws Unknown Host Exception { int percent = s . index Of ( STRING ) ; int slen = s . length ( ) ; int digit , zone = NUM ; if ( percent == - NUM ) { return - NUM ; } for ( int i = percent + NUM ; i < slen ; i ++ ) { char c = s . char At ( i ) ; if ( c == STRING ) { if ( i == percent + NUM ) { return - NUM ; } break ; } if ( ( digit = Character . digit ( c , NUM ) ) < NUM ) { return - NUM ; } zone = ( zone * NUM ) + digit ; } return zone ; }
private static int check Numeric Zone ( String s ) throws Unknown Host Exception { int percent = s . index Of ( STRING ) ; int slen = s . length ( ) ; int digit , zone = NUM ; if ( percent == - NUM ) { return - NUM ; } for ( int i = percent + NUM ; i < slen ; i ++ ) { char c = s . char At ( i ) ; if ( c == STRING ) { if ( i == percent + NUM ) { return - NUM ; } break ; } if ( ( digit = Character . digit ( c , NUM ) ) < NUM ) { return - NUM ; } zone = ( zone * NUM ) + digit ; } return zone ; }
private static int check Numeric Zone ( String s ) throws Unknown Host Exception { int percent = s . index Of ( STRING ) ; int slen = s . length ( ) ; int digit , zone = NUM ; if ( percent == - NUM ) { return - NUM ; } for ( int i = percent + NUM ; i < slen ; i ++ ) { char c = s . char At ( i ) ; if ( c == STRING ) { if ( i == percent + NUM ) { return - NUM ; } break ; } if ( ( digit = Character . digit ( c , NUM ) ) < NUM ) { return - NUM ; } zone = ( zone * NUM ) + digit ; } return zone ; }
private static int check Numeric Zone ( String s ) throws Unknown Host Exception { int percent = s . index Of ( STRING ) ; int slen = s . length ( ) ; int digit , zone = NUM ; if ( percent == - NUM ) { return - NUM ; } for ( int i = percent + NUM ; i < slen ; i ++ ) { char c = s . char At ( i ) ; if ( c == STRING ) { if ( i == percent + NUM ) { return - NUM ; } break ; } if ( ( digit = Character . digit ( c , NUM ) ) < NUM ) { return - NUM ; } zone = ( zone * NUM ) + digit ; } return zone ; }
public void update Team Talent Ratings ( ) { for ( Team t : team List ) { t . update Talent Ratings ( ) ; } }
public Vacuum Environment ( ) { Random r = new Random ( ) ; env State = new Vacuum Environment State ( NUM == r . next Int ( NUM ) ? Location State . Clean : Location State . Dirty , NUM == r . next Int ( NUM ) ? Location State . Clean : Location State . Dirty ) ; }
public Vacuum Environment ( ) { Random r = new Random ( ) ; env State = new Vacuum Environment State ( NUM == r . next Int ( NUM ) ? Location State . Clean : Location State . Dirty , NUM == r . next Int ( NUM ) ? Location State . Clean : Location State . Dirty ) ; }
public Jrmp Generator ( ) { }
public Text Unit create Text Unit ( Long id , String name , String source , String note , String target , String target Bcp 47 Tag , Xliff State state ) { Text Unit text Unit = new Text Unit ( id . to String ( ) , source ) ; text Unit . set Name ( name ) ; if ( note != null ) { text Unit . set Source Property ( new Property ( Property . NOTE , note ) ) ; } if ( target != null && target Bcp 47 Tag != null ) { Locale Id locale Id = Locale Id . from BCP 47 ( target Bcp 47 Tag ) ; text Unit . set Target ( locale Id , new Text Container ( target ) ) ; if ( state != null ) { text Unit . set Property ( new Property ( STRING , state . to String ( ) ) ) ; } } return text Unit ; }
public Text Unit create Text Unit ( Long id , String name , String source , String note , String target , String target Bcp 47 Tag , Xliff State state ) { Text Unit text Unit = new Text Unit ( id . to String ( ) , source ) ; text Unit . set Name ( name ) ; if ( note != null ) { text Unit . set Source Property ( new Property ( Property . NOTE , note ) ) ; } if ( target != null && target Bcp 47 Tag != null ) { Locale Id locale Id = Locale Id . from BCP 47 ( target Bcp 47 Tag ) ; text Unit . set Target ( locale Id , new Text Container ( target ) ) ; if ( state != null ) { text Unit . set Property ( new Property ( STRING , state . to String ( ) ) ) ; } } return text Unit ; }
public Text Unit create Text Unit ( Long id , String name , String source , String note , String target , String target Bcp 47 Tag , Xliff State state ) { Text Unit text Unit = new Text Unit ( id . to String ( ) , source ) ; text Unit . set Name ( name ) ; if ( note != null ) { text Unit . set Source Property ( new Property ( Property . NOTE , note ) ) ; } if ( target != null && target Bcp 47 Tag != null ) { Locale Id locale Id = Locale Id . from BCP 47 ( target Bcp 47 Tag ) ; text Unit . set Target ( locale Id , new Text Container ( target ) ) ; if ( state != null ) { text Unit . set Property ( new Property ( STRING , state . to String ( ) ) ) ; } } return text Unit ; }
public Text Unit create Text Unit ( Long id , String name , String source , String note , String target , String target Bcp 47 Tag , Xliff State state ) { Text Unit text Unit = new Text Unit ( id . to String ( ) , source ) ; text Unit . set Name ( name ) ; if ( note != null ) { text Unit . set Source Property ( new Property ( Property . NOTE , note ) ) ; } if ( target != null && target Bcp 47 Tag != null ) { Locale Id locale Id = Locale Id . from BCP 47 ( target Bcp 47 Tag ) ; text Unit . set Target ( locale Id , new Text Container ( target ) ) ; if ( state != null ) { text Unit . set Property ( new Property ( STRING , state . to String ( ) ) ) ; } } return text Unit ; }
private void write Newline On Debug ( XML Stream Writer out ) throws XML Stream Exception { if ( LOG . is Debugging ( ) ) { out . write Characters ( STRING ) ; } }
public void message ( Loco Net Message m ) { if ( m . get Num Data Elements ( ) != NUM ) { return ; } int b1 = m . get Element ( NUM ) & NUM ; int b2 = m . get Element ( NUM ) & NUM ; int b3 = m . get Element ( NUM ) & NUM ; int b4 = m . get Element ( NUM ) & NUM ; if ( ( b1 == NUM ) && ( ( b2 == NUM ) || ( b2 == NUM ) || ( b2 == NUM ) ) && ( b3 == NUM ) ) { id Box . set Selected Index ( b4 + NUM ) ; } }
public void message ( Loco Net Message m ) { if ( m . get Num Data Elements ( ) != NUM ) { return ; } int b1 = m . get Element ( NUM ) & NUM ; int b2 = m . get Element ( NUM ) & NUM ; int b3 = m . get Element ( NUM ) & NUM ; int b4 = m . get Element ( NUM ) & NUM ; if ( ( b1 == NUM ) && ( ( b2 == NUM ) || ( b2 == NUM ) || ( b2 == NUM ) ) && ( b3 == NUM ) ) { id Box . set Selected Index ( b4 + NUM ) ; } }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) return BOOL ; if ( obj == null ) return BOOL ; if ( get Class ( ) != obj . get Class ( ) ) return BOOL ; Attachment Point other = ( Attachment Point ) obj ; if ( port != other . port ) return BOOL ; if ( sw != other . sw ) return BOOL ; return BOOL ; }
public void clear ( ) { info Queue . clear ( ) ; while ( ! data Queue . is Empty ( ) ) { allocator . release ( data Queue . remove ( ) ) ; } total Bytes Dropped = NUM ; total Bytes Written = NUM ; last Allocation = null ; last Allocation Offset = allocation Length ; }
public void clear ( ) { info Queue . clear ( ) ; while ( ! data Queue . is Empty ( ) ) { allocator . release ( data Queue . remove ( ) ) ; } total Bytes Dropped = NUM ; total Bytes Written = NUM ; last Allocation = null ; last Allocation Offset = allocation Length ; }
public static String un Hide ( final String key ) { return is Hidden ( key ) ? key . substring ( HIDDEN PREFIX LENGTH ) : key ; }
public void test Create Document Type 1 ( ) throws Throwable { Document doc ; DOM Implementation dom Impl ; Document Type new Doc Type ; Document owner Document ; String qualified Name = STRING ; String public Id ; String system Id ; List < String > public Ids = new Array List < String > ( ) ; public Ids . add ( STRING ) ; public Ids . add ( STRING ) ; List < String > system Ids = new Array List < String > ( ) ; system Ids . add ( STRING ) ; system Ids . add ( STRING ) ; doc = ( Document ) load ( STRING , builder ) ; dom Impl = doc . get Implementation ( ) ; for ( int index N 1005 D = NUM ; index N 1005 D < public Ids . size ( ) ; index N 1005 D ++ ) { public Id = ( String ) public Ids . get ( index N 1005 D ) ; for ( int index N 10061 = NUM ; index N 10061 < system Ids . size ( ) ; index N 10061 ++ ) { system Id = ( String ) system Ids . get ( index N 10061 ) ; new Doc Type = dom Impl . create Document Type ( qualified Name , public Id , system Id ) ; assert Not Null ( STRING , new Doc Type ) ; owner Document = new Doc Type . get Owner Document ( ) ; assert Null ( STRING , owner Document ) ; } } }
private Class Vertex resolve Class Vertex ( Class Descriptor class Descriptor ) throws Class Not Found Exception { Class Vertex type Vertex = optionally Resolve Class Vertex ( class Descriptor ) ; if ( ! type Vertex . is Resolved ( ) ) { Class Descriptor . throw Class Not Found Exception ( class Descriptor ) ; } assert type Vertex . is Resolved ( ) ; return type Vertex ; }
protected void paint Content Border Bottom Edge ( Graphics g , int x , int y , int w , int h , boolean draw Broken , Rectangle sel Rect , boolean is Content Border Painted ) { if ( is Content Border Painted ) { g . set Color ( dark Shadow ) ; g . fill Rect ( x , y + h - NUM , w - NUM , NUM ) ; } }
public static String sha 1 ( final String string ) throws No Such Algorithm Exception { final Message Digest digest = Message Digest . get Instance ( STRING ) ; digest . reset ( ) ; final byte [ ] data = digest . digest ( string . get Bytes ( ) ) ; return String . format ( STRING + ( data . length * NUM ) + STRING , new Big Integer ( NUM , data ) ) ; }
void construct Node ( String node Name , String prefix , String node Namespace , Transformer Impl transformer ) throws Transformer Exception { boolean should Add Attrs ; try { Serialization Handler rhandler = transformer . get Result Tree Handler ( ) ; if ( null == node Name ) { should Add Attrs = BOOL ; } else { if ( null != prefix ) { rhandler . start Prefix Mapping ( prefix , node Namespace , BOOL ) ; } rhandler . start Element ( node Namespace , Q Name . get Local Part ( node Name ) , node Name ) ; super . execute ( transformer ) ; should Add Attrs = BOOL ; } transformer . execute Child Templates ( this , should Add Attrs ) ; if ( null != node Name ) { rhandler . end Element ( node Namespace , Q Name . get Local Part ( node Name ) , node Name ) ; if ( null != prefix ) { rhandler . end Prefix Mapping ( prefix ) ; } } } catch ( SAX Exception se ) { throw new Transformer Exception ( se ) ; } }
void construct Node ( String node Name , String prefix , String node Namespace , Transformer Impl transformer ) throws Transformer Exception { boolean should Add Attrs ; try { Serialization Handler rhandler = transformer . get Result Tree Handler ( ) ; if ( null == node Name ) { should Add Attrs = BOOL ; } else { if ( null != prefix ) { rhandler . start Prefix Mapping ( prefix , node Namespace , BOOL ) ; } rhandler . start Element ( node Namespace , Q Name . get Local Part ( node Name ) , node Name ) ; super . execute ( transformer ) ; should Add Attrs = BOOL ; } transformer . execute Child Templates ( this , should Add Attrs ) ; if ( null != node Name ) { rhandler . end Element ( node Namespace , Q Name . get Local Part ( node Name ) , node Name ) ; if ( null != prefix ) { rhandler . end Prefix Mapping ( prefix ) ; } } } catch ( SAX Exception se ) { throw new Transformer Exception ( se ) ; } }
void construct Node ( String node Name , String prefix , String node Namespace , Transformer Impl transformer ) throws Transformer Exception { boolean should Add Attrs ; try { Serialization Handler rhandler = transformer . get Result Tree Handler ( ) ; if ( null == node Name ) { should Add Attrs = BOOL ; } else { if ( null != prefix ) { rhandler . start Prefix Mapping ( prefix , node Namespace , BOOL ) ; } rhandler . start Element ( node Namespace , Q Name . get Local Part ( node Name ) , node Name ) ; super . execute ( transformer ) ; should Add Attrs = BOOL ; } transformer . execute Child Templates ( this , should Add Attrs ) ; if ( null != node Name ) { rhandler . end Element ( node Namespace , Q Name . get Local Part ( node Name ) , node Name ) ; if ( null != prefix ) { rhandler . end Prefix Mapping ( prefix ) ; } } } catch ( SAX Exception se ) { throw new Transformer Exception ( se ) ; } }
void construct Node ( String node Name , String prefix , String node Namespace , Transformer Impl transformer ) throws Transformer Exception { boolean should Add Attrs ; try { Serialization Handler rhandler = transformer . get Result Tree Handler ( ) ; if ( null == node Name ) { should Add Attrs = BOOL ; } else { if ( null != prefix ) { rhandler . start Prefix Mapping ( prefix , node Namespace , BOOL ) ; } rhandler . start Element ( node Namespace , Q Name . get Local Part ( node Name ) , node Name ) ; super . execute ( transformer ) ; should Add Attrs = BOOL ; } transformer . execute Child Templates ( this , should Add Attrs ) ; if ( null != node Name ) { rhandler . end Element ( node Namespace , Q Name . get Local Part ( node Name ) , node Name ) ; if ( null != prefix ) { rhandler . end Prefix Mapping ( prefix ) ; } } } catch ( SAX Exception se ) { throw new Transformer Exception ( se ) ; } }
void construct Node ( String node Name , String prefix , String node Namespace , Transformer Impl transformer ) throws Transformer Exception { boolean should Add Attrs ; try { Serialization Handler rhandler = transformer . get Result Tree Handler ( ) ; if ( null == node Name ) { should Add Attrs = BOOL ; } else { if ( null != prefix ) { rhandler . start Prefix Mapping ( prefix , node Namespace , BOOL ) ; } rhandler . start Element ( node Namespace , Q Name . get Local Part ( node Name ) , node Name ) ; super . execute ( transformer ) ; should Add Attrs = BOOL ; } transformer . execute Child Templates ( this , should Add Attrs ) ; if ( null != node Name ) { rhandler . end Element ( node Namespace , Q Name . get Local Part ( node Name ) , node Name ) ; if ( null != prefix ) { rhandler . end Prefix Mapping ( prefix ) ; } } } catch ( SAX Exception se ) { throw new Transformer Exception ( se ) ; } }
void construct Node ( String node Name , String prefix , String node Namespace , Transformer Impl transformer ) throws Transformer Exception { boolean should Add Attrs ; try { Serialization Handler rhandler = transformer . get Result Tree Handler ( ) ; if ( null == node Name ) { should Add Attrs = BOOL ; } else { if ( null != prefix ) { rhandler . start Prefix Mapping ( prefix , node Namespace , BOOL ) ; } rhandler . start Element ( node Namespace , Q Name . get Local Part ( node Name ) , node Name ) ; super . execute ( transformer ) ; should Add Attrs = BOOL ; } transformer . execute Child Templates ( this , should Add Attrs ) ; if ( null != node Name ) { rhandler . end Element ( node Namespace , Q Name . get Local Part ( node Name ) , node Name ) ; if ( null != prefix ) { rhandler . end Prefix Mapping ( prefix ) ; } } } catch ( SAX Exception se ) { throw new Transformer Exception ( se ) ; } }
public Extended Error Dialog ( Window owner , String key , String error Message , Object ... arguments ) { super ( owner , STRING + key , Modality Type . APPLICATION MODAL , arguments ) ; boolean has Error = error Message != null && ! error Message . is Empty ( ) ; J Scroll Pane detailed Pane = has Error ? create Detail Panel ( error Message ) : null ; layout Default ( main Component , SIZE , get Buttons ( has Error , BOOL , detailed Pane , null ) ) ; }
public static short parse Short ( java . lang . String s ) throws java . lang . Number Format Exception { return ( short ) Integer . parse Int ( s ) ; }
public static short parse Short ( java . lang . String s ) throws java . lang . Number Format Exception { return ( short ) Integer . parse Int ( s ) ; }
public static short parse Short ( java . lang . String s ) throws java . lang . Number Format Exception { return ( short ) Integer . parse Int ( s ) ; }
public static short parse Short ( java . lang . String s ) throws java . lang . Number Format Exception { return ( short ) Integer . parse Int ( s ) ; }
public void add Child Frame ( Container c ) { m Child Frames . add ( c ) ; }
protected double [ ] rhumb Project Double ( Point 2 D from , Point 2 D to , boolean include last , int nsegs ) { if ( nsegs < NUM ) { nsegs = Draw Util . pixel distance ( ( int ) from . get X ( ) , ( int ) from . get Y ( ) , ( int ) to . get X ( ) , ( int ) to . get Y ( ) ) > > NUM ; if ( nsegs == NUM ) nsegs = NUM ; else if ( nsegs > MAX RHUMB SEGS ) nsegs = MAX RHUMB SEGS ; } Lat Lon Point llp = new Lat Lon Point . Double ( ) ; int [ ] xypts = Draw Util . line Segments ( ( int ) from . get X ( ) , ( int ) from . get Y ( ) , ( int ) to . get X ( ) , ( int ) to . get Y ( ) , nsegs , include last , new int [ nsegs << NUM ] ) ; double [ ] llpts = new double [ xypts . length ] ; for ( int i = NUM ; i < llpts . length ; i += NUM ) { inverse ( xypts [ i ] , xypts [ i + NUM ] , llp ) ; llpts [ i ] = llp . get Rad Lat ( ) ; llpts [ i + NUM ] = llp . get Rad Lon ( ) ; } return llpts ; }
protected double [ ] rhumb Project Double ( Point 2 D from , Point 2 D to , boolean include last , int nsegs ) { if ( nsegs < NUM ) { nsegs = Draw Util . pixel distance ( ( int ) from . get X ( ) , ( int ) from . get Y ( ) , ( int ) to . get X ( ) , ( int ) to . get Y ( ) ) > > NUM ; if ( nsegs == NUM ) nsegs = NUM ; else if ( nsegs > MAX RHUMB SEGS ) nsegs = MAX RHUMB SEGS ; } Lat Lon Point llp = new Lat Lon Point . Double ( ) ; int [ ] xypts = Draw Util . line Segments ( ( int ) from . get X ( ) , ( int ) from . get Y ( ) , ( int ) to . get X ( ) , ( int ) to . get Y ( ) , nsegs , include last , new int [ nsegs << NUM ] ) ; double [ ] llpts = new double [ xypts . length ] ; for ( int i = NUM ; i < llpts . length ; i += NUM ) { inverse ( xypts [ i ] , xypts [ i + NUM ] , llp ) ; llpts [ i ] = llp . get Rad Lat ( ) ; llpts [ i + NUM ] = llp . get Rad Lon ( ) ; } return llpts ; }
protected String format Date ( Date d ) { try { synchronized ( time Formatter ) { return time Formatter . format ( d ) ; } } catch ( Exception e1 ) { try { return d . to String ( ) ; } catch ( Exception e2 ) { try { return Long . to String ( d . get Time ( ) ) ; } catch ( Exception e3 ) { return STRING ; } } } }
public void close ( ) throws IO Exception { m Output Stream . close ( ) ; }
private void $$$setup UI$$$ ( ) { content Pane = new J Panel ( ) ; content Pane . set Layout ( new Border Layout ( NUM , NUM ) ) ; split Pane = new J Split Pane ( ) ; content Pane . add ( split Pane , Border Layout . CENTER ) ; final J Scroll Pane scroll Pane 1 = new J Scroll Pane ( ) ; split Pane . set Left Component ( scroll Pane 1 ) ; method List = new J List ( ) ; scroll Pane 1 . set Viewport View ( method List ) ; final J Scroll Pane scroll Pane 2 = new J Scroll Pane ( ) ; split Pane . set Right Component ( scroll Pane 2 ) ; method Detail Table = new J Table ( ) ; scroll Pane 2 . set Viewport View ( method Detail Table ) ; }
private double [ ] extend ( double [ ] array , double value ) { double [ ] result = null ; if ( array == null ) { result = new double [ NUM ] ; } else { result = Arrays . copy Of ( array , array . length + NUM ) ; } result [ result . length - NUM ] = value ; return result ; }
private double [ ] extend ( double [ ] array , double value ) { double [ ] result = null ; if ( array == null ) { result = new double [ NUM ] ; } else { result = Arrays . copy Of ( array , array . length + NUM ) ; } result [ result . length - NUM ] = value ; return result ; }
private static Metric Value number to metric value ( Number elem ) { if ( elem == null ) return Metric Value . EMPTY ; final String num = elem . to String ( ) ; try { return Metric Value . from Int Value ( Long . parse Long ( num ) ) ; } catch ( Number Format Exception ex ) { } try { return Metric Value . from Dbl Value ( Double . parse Double ( num ) ) ; } catch ( Number Format Exception ex ) { } return Metric Value . from Str Value ( num ) ; }
public byte [ ] create Image ( Projection proj , int scaled Width , int scaled Height , int included Layer Mask ) { return create Image ( proj , scaled Width , scaled Height , included Layer Mask , get Background ( ) ) ; }
public byte [ ] create Image ( Projection proj , int scaled Width , int scaled Height , int included Layer Mask ) { return create Image ( proj , scaled Width , scaled Height , included Layer Mask , get Background ( ) ) ; }
public byte [ ] create Image ( Projection proj , int scaled Width , int scaled Height , int included Layer Mask ) { return create Image ( proj , scaled Width , scaled Height , included Layer Mask , get Background ( ) ) ; }
public byte [ ] create Image ( Projection proj , int scaled Width , int scaled Height , int included Layer Mask ) { return create Image ( proj , scaled Width , scaled Height , included Layer Mask , get Background ( ) ) ; }
public byte [ ] create Image ( Projection proj , int scaled Width , int scaled Height , int included Layer Mask ) { return create Image ( proj , scaled Width , scaled Height , included Layer Mask , get Background ( ) ) ; }
public byte [ ] create Image ( Projection proj , int scaled Width , int scaled Height , int included Layer Mask ) { return create Image ( proj , scaled Width , scaled Height , included Layer Mask , get Background ( ) ) ; }
public byte [ ] create Image ( Projection proj , int scaled Width , int scaled Height , int included Layer Mask ) { return create Image ( proj , scaled Width , scaled Height , included Layer Mask , get Background ( ) ) ; }
public static String concatenate Realm Path ( String parent Realm , String subrealm ) { String realm ; if ( subrealm == null ) { realm = parent Realm ; } else { subrealm = clean Realm ( subrealm ) ; if ( parent Realm == null || parent Realm . equals ( STRING ) ) { realm = subrealm ; } else { realm = parent Realm + subrealm ; } } return clean Realm ( realm ) ; }
public static String concatenate Realm Path ( String parent Realm , String subrealm ) { String realm ; if ( subrealm == null ) { realm = parent Realm ; } else { subrealm = clean Realm ( subrealm ) ; if ( parent Realm == null || parent Realm . equals ( STRING ) ) { realm = subrealm ; } else { realm = parent Realm + subrealm ; } } return clean Realm ( realm ) ; }
public boolean add All ( Named List < T > nl ) { nv Pairs . add All ( nl . nv Pairs ) ; return nl . size ( ) > NUM ; }
@ Safe Varargs public static < V > Set < V > create Set ( V ... values ) { Set < V > set = new Linked Hash Set < V > ( ) ; for ( V v : values ) { set . add ( v ) ; } return set ; }
public static void append Hex Java Script Representation ( String Builder sb , char c ) { sb . append ( STRING ) ; String val = Integer . to Hex String ( c ) ; for ( int j = val . length ( ) ; j < NUM ; j ++ ) { sb . append ( STRING ) ; } sb . append ( val ) ; }
void error ( String key , String arg 1 , String arg 2 ) throws SAX Exception { had Error = BOOL ; if ( eh == null ) return ; eh . error ( new SAX Parse Exception ( localizer . message ( key , arg 1 , arg 2 ) , locator ) ) ; }
public void add Listener ( @ Not Null Selection Change Listener listener ) { listeners . add ( listener ) ; }
private void write Object ( Object Output Stream out ) throws IO Exception { out . default Write Object ( ) ; service ID . write Bytes ( out ) ; }
private void write Object ( Object Output Stream out ) throws IO Exception { out . default Write Object ( ) ; service ID . write Bytes ( out ) ; }
public double find Minimum ( Univariate Function f , int frac Digits ) { double tol = Math . pow ( NUM , - NUM - frac Digits ) ; final double optx = optimize ( f , tol ) ; return optx ; }
public Sequence Element parse ( Input Stream stream ) throws IO Exception , SAX Exception , Parser Configuration Exception { return parse ( stream , STRING ) ; }
public Sequence Element parse ( Input Stream stream ) throws IO Exception , SAX Exception , Parser Configuration Exception { return parse ( stream , STRING ) ; }
private void ensure Capacity ( int units Required ) { if ( bits . length < units Required ) { int request = Math . max ( NUM * bits . length , units Required ) ; long [ ] new Bits = new long [ request ] ; System . arraycopy ( bits , NUM , new Bits , NUM , units In Use ) ; bits = new Bits ; } }
private void ensure Capacity ( int units Required ) { if ( bits . length < units Required ) { int request = Math . max ( NUM * bits . length , units Required ) ; long [ ] new Bits = new long [ request ] ; System . arraycopy ( bits , NUM , new Bits , NUM , units In Use ) ; bits = new Bits ; } }
public void fit Canvas ( ) { if ( source Image == null ) return ; Rectangle image Bound = source Image . get Bounds ( ) ; Rectangle dest Rect = get Client Area ( ) ; double sx = ( double ) dest Rect . width / ( double ) image Bound . width ; double sy = ( double ) dest Rect . height / ( double ) image Bound . height ; double s = Math . min ( sx , sy ) ; double dx = NUM * dest Rect . width ; double dy = NUM * dest Rect . height ; center Zoom ( dx , dy , s , new Affine Transform ( ) ) ; }
public boolean add ( int value ) { int index = value % this . num Buckets ; Bucket bucket = this . buckets [ index ] ; if ( bucket == null ) { bucket = this . buckets [ index ] = new Bucket ( this . bucket Initial Capacity ) ; } else { for ( int i = NUM ; i < bucket . length ; i ++ ) { if ( bucket . values [ i ] == value ) return BOOL ; } } if ( bucket . values . length <= bucket . length ) { int [ ] tmp = new int [ NUM * bucket . values . length ] ; System . arraycopy ( bucket . values , NUM , tmp , NUM , bucket . values . length ) ; bucket . values = tmp ; } bucket . values [ bucket . length ++ ] = value ; this . size ++ ; return BOOL ; }
public boolean add ( int value ) { int index = value % this . num Buckets ; Bucket bucket = this . buckets [ index ] ; if ( bucket == null ) { bucket = this . buckets [ index ] = new Bucket ( this . bucket Initial Capacity ) ; } else { for ( int i = NUM ; i < bucket . length ; i ++ ) { if ( bucket . values [ i ] == value ) return BOOL ; } } if ( bucket . values . length <= bucket . length ) { int [ ] tmp = new int [ NUM * bucket . values . length ] ; System . arraycopy ( bucket . values , NUM , tmp , NUM , bucket . values . length ) ; bucket . values = tmp ; } bucket . values [ bucket . length ++ ] = value ; this . size ++ ; return BOOL ; }
public boolean add ( int value ) { int index = value % this . num Buckets ; Bucket bucket = this . buckets [ index ] ; if ( bucket == null ) { bucket = this . buckets [ index ] = new Bucket ( this . bucket Initial Capacity ) ; } else { for ( int i = NUM ; i < bucket . length ; i ++ ) { if ( bucket . values [ i ] == value ) return BOOL ; } } if ( bucket . values . length <= bucket . length ) { int [ ] tmp = new int [ NUM * bucket . values . length ] ; System . arraycopy ( bucket . values , NUM , tmp , NUM , bucket . values . length ) ; bucket . values = tmp ; } bucket . values [ bucket . length ++ ] = value ; this . size ++ ; return BOOL ; }
public boolean add ( int value ) { int index = value % this . num Buckets ; Bucket bucket = this . buckets [ index ] ; if ( bucket == null ) { bucket = this . buckets [ index ] = new Bucket ( this . bucket Initial Capacity ) ; } else { for ( int i = NUM ; i < bucket . length ; i ++ ) { if ( bucket . values [ i ] == value ) return BOOL ; } } if ( bucket . values . length <= bucket . length ) { int [ ] tmp = new int [ NUM * bucket . values . length ] ; System . arraycopy ( bucket . values , NUM , tmp , NUM , bucket . values . length ) ; bucket . values = tmp ; } bucket . values [ bucket . length ++ ] = value ; this . size ++ ; return BOOL ; }
@ Suppress Warnings ( STRING ) private void apply To Group And Sub Groups ( final AST 2 B Op Context context , final Query Root query Root , final Query Hint Scope scope , final Graph Pattern Group < I Group Member Node > group , final String name , final String value ) { for ( I Group Member Node child : group ) { apply Query Hint ( context , query Root , scope , ( AST Base ) child , name , value ) ; if ( child instanceof Graph Pattern Group < ? > ) { apply To Group And Sub Groups ( context , query Root , scope , ( Graph Pattern Group < I Group Member Node > ) child , name , value ) ; } } apply Query Hint ( context , query Root , scope , ( AST Base ) group , name , value ) ; }
protected int add Child Node ( Node Builder child ) { synchronized ( nodes ) { nodes . add ( child ) ; return nodes . size ( ) - NUM ; } }
public void init GL ( ) { m Egl Core = new Egl Core ( null , Egl Core . FLAG RECORDABLE | Egl Core . FLAG TRY GLES 3 ) ; m Window Surface = new Window Surface ( m Egl Core , m Surface Texture ) ; m Window Surface . make Current ( ) ; m Record Surface = new Window Surface ( m Egl Core , m Media Recorder . get Surface ( ) , BOOL ) ; init GL Components ( ) ; }
public void init GL ( ) { m Egl Core = new Egl Core ( null , Egl Core . FLAG RECORDABLE | Egl Core . FLAG TRY GLES 3 ) ; m Window Surface = new Window Surface ( m Egl Core , m Surface Texture ) ; m Window Surface . make Current ( ) ; m Record Surface = new Window Surface ( m Egl Core , m Media Recorder . get Surface ( ) , BOOL ) ; init GL Components ( ) ; }
public void init GL ( ) { m Egl Core = new Egl Core ( null , Egl Core . FLAG RECORDABLE | Egl Core . FLAG TRY GLES 3 ) ; m Window Surface = new Window Surface ( m Egl Core , m Surface Texture ) ; m Window Surface . make Current ( ) ; m Record Surface = new Window Surface ( m Egl Core , m Media Recorder . get Surface ( ) , BOOL ) ; init GL Components ( ) ; }
public void add House Numbers ( List < House Number > House Numbers ) { if ( House Numbers != null ) { for ( House Number house Number : House Numbers ) { add House Number ( house Number ) ; } } }
public void add House Numbers ( List < House Number > House Numbers ) { if ( House Numbers != null ) { for ( House Number house Number : House Numbers ) { add House Number ( house Number ) ; } } }
public void add House Numbers ( List < House Number > House Numbers ) { if ( House Numbers != null ) { for ( House Number house Number : House Numbers ) { add House Number ( house Number ) ; } } }
public void add House Numbers ( List < House Number > House Numbers ) { if ( House Numbers != null ) { for ( House Number house Number : House Numbers ) { add House Number ( house Number ) ; } } }
private void fill Scratch Buffer ( int bytes To Read ) throws IO Exception { assert ( bytes To Read <= scratch Buffer . capacity ( ) ) ; scratch Buffer . clear ( ) ; scratch Buffer . limit ( bytes To Read ) ; read ( scratch Buffer ) ; scratch Buffer . flip ( ) ; }
private void fill Scratch Buffer ( int bytes To Read ) throws IO Exception { assert ( bytes To Read <= scratch Buffer . capacity ( ) ) ; scratch Buffer . clear ( ) ; scratch Buffer . limit ( bytes To Read ) ; read ( scratch Buffer ) ; scratch Buffer . flip ( ) ; }
private void fill Scratch Buffer ( int bytes To Read ) throws IO Exception { assert ( bytes To Read <= scratch Buffer . capacity ( ) ) ; scratch Buffer . clear ( ) ; scratch Buffer . limit ( bytes To Read ) ; read ( scratch Buffer ) ; scratch Buffer . flip ( ) ; }
private void fill Scratch Buffer ( int bytes To Read ) throws IO Exception { assert ( bytes To Read <= scratch Buffer . capacity ( ) ) ; scratch Buffer . clear ( ) ; scratch Buffer . limit ( bytes To Read ) ; read ( scratch Buffer ) ; scratch Buffer . flip ( ) ; }
public Interval 1 D ( double min , double max ) { if ( Double . is Infinite ( min ) || Double . is Infinite ( max ) ) throw new Illegal Argument Exception ( STRING ) ; if ( Double . is Na N ( min ) || Double . is Na N ( max ) ) throw new Illegal Argument Exception ( STRING ) ; if ( min == NUM ) min = NUM ; if ( max == NUM ) max = NUM ; if ( min <= max ) { this . min = min ; this . max = max ; } else throw new Illegal Argument Exception ( STRING ) ; }
public void remove Identifier ( String id Name ) { if ( needs Sync Data ( ) ) { synchronize Data ( ) ; } if ( identifiers == null ) { return ; } identifiers . remove ( id Name ) ; }
public void remove Identifier ( String id Name ) { if ( needs Sync Data ( ) ) { synchronize Data ( ) ; } if ( identifiers == null ) { return ; } identifiers . remove ( id Name ) ; }
public static boolean is SSH ( String uri ) { return uri != null && uri . starts With ( STRING ) ; }
protected void clean Up ( ) { if ( is Release References ( ) ) { clean Up On Ack ( ) ; if ( logger . is Logging Enabled ( Log Writer . TRACE DEBUG ) ) { logger . log Debug ( STRING + get Dialog Id ( ) ) ; } if ( event Listeners != null ) { event Listeners . clear ( ) ; } timer Task Lock = null ; ack Sem = null ; contact Header = null ; event Header = null ; first Transaction Id = null ; first Transaction Method = null ; last Response Dialog Id = null ; last Response Method = null ; last Response Top Most Via = null ; if ( original Request Record Route Headers != null ) { original Request Record Route Headers . clear ( ) ; original Request Record Route Headers = null ; original Request Record Route Headers String = null ; } if ( route List != null ) { route List . clear ( ) ; route List = null ; } responses Received In Forking Case . clear ( ) ; } }
public void post ( Object event ) { List < Object > event Queue = current Thread Event Queue . get ( ) ; event Queue . add ( event ) ; Boolean Wrapper is Posting = current Thread Is Posting . get ( ) ; if ( is Posting . value ) { return ; } else { boolean is Main Thread = Looper . get Main Looper ( ) == Looper . my Looper ( ) ; is Posting . value = BOOL ; try { while ( ! event Queue . is Empty ( ) ) { post Single Event ( event Queue . remove ( NUM ) , is Main Thread ) ; } } finally { is Posting . value = BOOL ; } } }
protected Slim Exception ( final boolean talkback , final Throwable t , final Error Type type , final String ... args ) { super ( t != null ? t . to String ( ) : args . length > NUM ? args [ NUM ] : STRING , t ) ; m Talkback = talkback ; m Error Type = type ; m Error Arguments = args . clone ( ) ; }
protected Slim Exception ( final boolean talkback , final Throwable t , final Error Type type , final String ... args ) { super ( t != null ? t . to String ( ) : args . length > NUM ? args [ NUM ] : STRING , t ) ; m Talkback = talkback ; m Error Type = type ; m Error Arguments = args . clone ( ) ; }
protected Slim Exception ( final boolean talkback , final Throwable t , final Error Type type , final String ... args ) { super ( t != null ? t . to String ( ) : args . length > NUM ? args [ NUM ] : STRING , t ) ; m Talkback = talkback ; m Error Type = type ; m Error Arguments = args . clone ( ) ; }
protected Slim Exception ( final boolean talkback , final Throwable t , final Error Type type , final String ... args ) { super ( t != null ? t . to String ( ) : args . length > NUM ? args [ NUM ] : STRING , t ) ; m Talkback = talkback ; m Error Type = type ; m Error Arguments = args . clone ( ) ; }
protected Slim Exception ( final boolean talkback , final Throwable t , final Error Type type , final String ... args ) { super ( t != null ? t . to String ( ) : args . length > NUM ? args [ NUM ] : STRING , t ) ; m Talkback = talkback ; m Error Type = type ; m Error Arguments = args . clone ( ) ; }
private static String dir Name ( String node Name ) { for ( int i = NUM , n = node Name . length ( ) ; i < n ; i ++ ) if ( ! is Dir Char ( node Name . char At ( i ) ) ) return STRING + Base 64 . byte Array To Alt Base 64 ( byte Array ( node Name ) ) ; return node Name ; }
private static String dir Name ( String node Name ) { for ( int i = NUM , n = node Name . length ( ) ; i < n ; i ++ ) if ( ! is Dir Char ( node Name . char At ( i ) ) ) return STRING + Base 64 . byte Array To Alt Base 64 ( byte Array ( node Name ) ) ; return node Name ; }
private void build Address Selection Pop Up ( ) { final C Address Selection Dialog dlg = new C Address Selection Dialog ( m parent , m modules ) ; dlg . set Visible ( BOOL ) ; final I Navi Module result = dlg . get Selection Result ( ) ; final I Address address = new C Address ( Long . parse Long ( get Text ( ) , NUM ) ) ; Zy Zoom Helpers . zoom To Address ( m graph , address , result , BOOL ) ; }
private void build Address Selection Pop Up ( ) { final C Address Selection Dialog dlg = new C Address Selection Dialog ( m parent , m modules ) ; dlg . set Visible ( BOOL ) ; final I Navi Module result = dlg . get Selection Result ( ) ; final I Address address = new C Address ( Long . parse Long ( get Text ( ) , NUM ) ) ; Zy Zoom Helpers . zoom To Address ( m graph , address , result , BOOL ) ; }
private void build Address Selection Pop Up ( ) { final C Address Selection Dialog dlg = new C Address Selection Dialog ( m parent , m modules ) ; dlg . set Visible ( BOOL ) ; final I Navi Module result = dlg . get Selection Result ( ) ; final I Address address = new C Address ( Long . parse Long ( get Text ( ) , NUM ) ) ; Zy Zoom Helpers . zoom To Address ( m graph , address , result , BOOL ) ; }
private void write ( String s ) throws SAX Exception { try { output . write ( s ) ; } catch ( IO Exception e ) { throw new SAX Exception ( e ) ; } }
public boolean epsilon Equals ( Vector 3 obj , float epsilon ) { if ( obj == null ) return BOOL ; if ( Math . abs ( obj . x - x ) > epsilon ) return BOOL ; if ( Math . abs ( obj . y - y ) > epsilon ) return BOOL ; if ( Math . abs ( obj . z - z ) > epsilon ) return BOOL ; return BOOL ; }
@ Override public Promise < Void , Authentication Exception > clean Subject ( Message Info Context message Info , Subject client Subject ) { return auth Module . clean Subject ( message Info , client Subject ) ; }
private void update ( ) { Layout < String , Integer > layout = get Graph Layout ( current State , tab . show Parameters ( ) ) ; set Graph Layout ( layout ) ; update Distribs ( ) ; }
private X Net Reply load Chars ( java . io . Buffered Reader istream ) throws java . io . IO Exception { String s = STRING ; s = istream . read Line ( ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + s ) ; } if ( s == null ) { return null ; } else { return new X Net Reply ( s ) ; } }
@ Not Null public static List < String > complete Relative Path ( @ Not Null String base Dir , @ Not Null String shown Base Dir , @ Not Null String relative Path ) { List < String > result = Lists . new Linked List ( ) ; String bash Base Dir = OS Util . to Bash Compatible ( base Dir ) ; for ( String path : complete Absolute Path ( base Dir + File . separator + relative Path , Predicates . < File > always True ( ) ) ) { if ( path . starts With ( bash Base Dir ) ) { result . add ( shown Base Dir + path . substring ( bash Base Dir . length ( ) ) ) ; } } return result ; }
@ Not Null public static List < String > complete Relative Path ( @ Not Null String base Dir , @ Not Null String shown Base Dir , @ Not Null String relative Path ) { List < String > result = Lists . new Linked List ( ) ; String bash Base Dir = OS Util . to Bash Compatible ( base Dir ) ; for ( String path : complete Absolute Path ( base Dir + File . separator + relative Path , Predicates . < File > always True ( ) ) ) { if ( path . starts With ( bash Base Dir ) ) { result . add ( shown Base Dir + path . substring ( bash Base Dir . length ( ) ) ) ; } } return result ; }
protected void put 100 Int ( ) { for ( int i = NUM ; i < NUM ; i ++ ) { region . put ( new Integer ( i ) , new Integer ( i ) ) ; } }
public static void log JVM Info ( ) { Runtime MX Bean runtime = Management Factory . get Runtime MX Bean ( ) ; if ( runtime != null ) { LOG . info ( STRING + runtime . get Vm Name ( ) + STRING + runtime . get Vm Vendor ( ) + STRING + runtime . get Vm Version ( ) ) ; LOG . info ( STRING + runtime . get Input Arguments ( ) ) ; } }
private static void write To Console ( LDIF Entry Writer writer , Entry entry ) throws IO Exception { writer . write Entry ( entry ) ; writer . flush ( ) ; }
public static Scrollable Container create Scrollable Container ( J Component contents ) { Scrollable Container container = new Scrollable Container ( contents , J Scroll Pane . VERTICAL SCROLLBAR AS NEEDED , J Scroll Pane . HORIZONTAL SCROLLBAR NEVER ) ; container . set Viewport Border ( Border Factory . create Empty Border ( NUM , NUM , NUM , NUM ) ) ; container . set Border ( Border Factory . create Empty Border ( NUM , NUM , NUM , NUM ) ) ; return container ; }
public static Scrollable Container create Scrollable Container ( J Component contents ) { Scrollable Container container = new Scrollable Container ( contents , J Scroll Pane . VERTICAL SCROLLBAR AS NEEDED , J Scroll Pane . HORIZONTAL SCROLLBAR NEVER ) ; container . set Viewport Border ( Border Factory . create Empty Border ( NUM , NUM , NUM , NUM ) ) ; container . set Border ( Border Factory . create Empty Border ( NUM , NUM , NUM , NUM ) ) ; return container ; }
public static Scrollable Container create Scrollable Container ( J Component contents ) { Scrollable Container container = new Scrollable Container ( contents , J Scroll Pane . VERTICAL SCROLLBAR AS NEEDED , J Scroll Pane . HORIZONTAL SCROLLBAR NEVER ) ; container . set Viewport Border ( Border Factory . create Empty Border ( NUM , NUM , NUM , NUM ) ) ; container . set Border ( Border Factory . create Empty Border ( NUM , NUM , NUM , NUM ) ) ; return container ; }
public final Bean Event Type create Bean Type ( String name , Class clazz , boolean is Preconfigured Static , boolean is Preconfigured , boolean is Configured ) { if ( clazz == null ) { throw new Illegal Argument Exception ( STRING ) ; } Bean Event Type event Type = null ; types Per Java Bean Lock . lock ( ) ; try { event Type = types Per Java Bean . get ( clazz ) ; if ( event Type != null ) { event Type Id Generator . assigned Type ( name , event Type ) ; return event Type ; } Configuration Event Type Legacy legacy Def = class To Legacy Configs . get ( clazz . get Name ( ) ) ; if ( ( legacy Def == null ) && ( default Accessor Style != Configuration Event Type Legacy . Accessor Style . JAVABEAN ) ) { legacy Def = new Configuration Event Type Legacy ( ) ; legacy Def . set Accessor Style ( default Accessor Style ) ; } int type Id = event Type Id Generator . get Type Id ( name ) ; Event Type Metadata metadata = Event Type Metadata . create Bean Type ( name , clazz , is Preconfigured Static , is Preconfigured , is Configured , Event Type Metadata . Type Class . APPLICATION ) ; event Type = new Bean Event Type ( metadata , type Id , clazz , event Adapter Service , legacy Def ) ; types Per Java Bean . put ( clazz , event Type ) ; } catch ( Runtime Exception ex ) { throw ex ; } finally { types Per Java Bean Lock . unlock ( ) ; } return event Type ; }
public final Bean Event Type create Bean Type ( String name , Class clazz , boolean is Preconfigured Static , boolean is Preconfigured , boolean is Configured ) { if ( clazz == null ) { throw new Illegal Argument Exception ( STRING ) ; } Bean Event Type event Type = null ; types Per Java Bean Lock . lock ( ) ; try { event Type = types Per Java Bean . get ( clazz ) ; if ( event Type != null ) { event Type Id Generator . assigned Type ( name , event Type ) ; return event Type ; } Configuration Event Type Legacy legacy Def = class To Legacy Configs . get ( clazz . get Name ( ) ) ; if ( ( legacy Def == null ) && ( default Accessor Style != Configuration Event Type Legacy . Accessor Style . JAVABEAN ) ) { legacy Def = new Configuration Event Type Legacy ( ) ; legacy Def . set Accessor Style ( default Accessor Style ) ; } int type Id = event Type Id Generator . get Type Id ( name ) ; Event Type Metadata metadata = Event Type Metadata . create Bean Type ( name , clazz , is Preconfigured Static , is Preconfigured , is Configured , Event Type Metadata . Type Class . APPLICATION ) ; event Type = new Bean Event Type ( metadata , type Id , clazz , event Adapter Service , legacy Def ) ; types Per Java Bean . put ( clazz , event Type ) ; } catch ( Runtime Exception ex ) { throw ex ; } finally { types Per Java Bean Lock . unlock ( ) ; } return event Type ; }
public final Bean Event Type create Bean Type ( String name , Class clazz , boolean is Preconfigured Static , boolean is Preconfigured , boolean is Configured ) { if ( clazz == null ) { throw new Illegal Argument Exception ( STRING ) ; } Bean Event Type event Type = null ; types Per Java Bean Lock . lock ( ) ; try { event Type = types Per Java Bean . get ( clazz ) ; if ( event Type != null ) { event Type Id Generator . assigned Type ( name , event Type ) ; return event Type ; } Configuration Event Type Legacy legacy Def = class To Legacy Configs . get ( clazz . get Name ( ) ) ; if ( ( legacy Def == null ) && ( default Accessor Style != Configuration Event Type Legacy . Accessor Style . JAVABEAN ) ) { legacy Def = new Configuration Event Type Legacy ( ) ; legacy Def . set Accessor Style ( default Accessor Style ) ; } int type Id = event Type Id Generator . get Type Id ( name ) ; Event Type Metadata metadata = Event Type Metadata . create Bean Type ( name , clazz , is Preconfigured Static , is Preconfigured , is Configured , Event Type Metadata . Type Class . APPLICATION ) ; event Type = new Bean Event Type ( metadata , type Id , clazz , event Adapter Service , legacy Def ) ; types Per Java Bean . put ( clazz , event Type ) ; } catch ( Runtime Exception ex ) { throw ex ; } finally { types Per Java Bean Lock . unlock ( ) ; } return event Type ; }
public final Bean Event Type create Bean Type ( String name , Class clazz , boolean is Preconfigured Static , boolean is Preconfigured , boolean is Configured ) { if ( clazz == null ) { throw new Illegal Argument Exception ( STRING ) ; } Bean Event Type event Type = null ; types Per Java Bean Lock . lock ( ) ; try { event Type = types Per Java Bean . get ( clazz ) ; if ( event Type != null ) { event Type Id Generator . assigned Type ( name , event Type ) ; return event Type ; } Configuration Event Type Legacy legacy Def = class To Legacy Configs . get ( clazz . get Name ( ) ) ; if ( ( legacy Def == null ) && ( default Accessor Style != Configuration Event Type Legacy . Accessor Style . JAVABEAN ) ) { legacy Def = new Configuration Event Type Legacy ( ) ; legacy Def . set Accessor Style ( default Accessor Style ) ; } int type Id = event Type Id Generator . get Type Id ( name ) ; Event Type Metadata metadata = Event Type Metadata . create Bean Type ( name , clazz , is Preconfigured Static , is Preconfigured , is Configured , Event Type Metadata . Type Class . APPLICATION ) ; event Type = new Bean Event Type ( metadata , type Id , clazz , event Adapter Service , legacy Def ) ; types Per Java Bean . put ( clazz , event Type ) ; } catch ( Runtime Exception ex ) { throw ex ; } finally { types Per Java Bean Lock . unlock ( ) ; } return event Type ; }
public final Bean Event Type create Bean Type ( String name , Class clazz , boolean is Preconfigured Static , boolean is Preconfigured , boolean is Configured ) { if ( clazz == null ) { throw new Illegal Argument Exception ( STRING ) ; } Bean Event Type event Type = null ; types Per Java Bean Lock . lock ( ) ; try { event Type = types Per Java Bean . get ( clazz ) ; if ( event Type != null ) { event Type Id Generator . assigned Type ( name , event Type ) ; return event Type ; } Configuration Event Type Legacy legacy Def = class To Legacy Configs . get ( clazz . get Name ( ) ) ; if ( ( legacy Def == null ) && ( default Accessor Style != Configuration Event Type Legacy . Accessor Style . JAVABEAN ) ) { legacy Def = new Configuration Event Type Legacy ( ) ; legacy Def . set Accessor Style ( default Accessor Style ) ; } int type Id = event Type Id Generator . get Type Id ( name ) ; Event Type Metadata metadata = Event Type Metadata . create Bean Type ( name , clazz , is Preconfigured Static , is Preconfigured , is Configured , Event Type Metadata . Type Class . APPLICATION ) ; event Type = new Bean Event Type ( metadata , type Id , clazz , event Adapter Service , legacy Def ) ; types Per Java Bean . put ( clazz , event Type ) ; } catch ( Runtime Exception ex ) { throw ex ; } finally { types Per Java Bean Lock . unlock ( ) ; } return event Type ; }
public boolean is Running ( ) { return ( m Script Thread != null ) ; }
@ Exception Handler ( value = { Jpa System Exception . class , Persistence Exception . class } ) @ Response Body public Error Information handle Persistence Exception ( Exception exception , Http Servlet Response response ) { Throwable throwable = get Root Cause ( exception ) ; if ( is Data Truncation Exception ( throwable ) ) { return get Error Information And Set Status ( Http Status . BAD REQUEST , throwable , response ) ; } else if ( is Caused By Constraint Violation Exception ( exception ) ) { return get Error Information And Set Status ( Http Status . BAD REQUEST , new Exception ( STRING + throwable . get Message ( ) ) , response ) ; } else { log Error ( STRING , exception ) ; return get Error Information And Set Status ( Http Status . INTERNAL SERVER ERROR , throwable == null ? new Exception ( STRING ) : throwable , response ) ; } }
@ Exception Handler ( value = { Jpa System Exception . class , Persistence Exception . class } ) @ Response Body public Error Information handle Persistence Exception ( Exception exception , Http Servlet Response response ) { Throwable throwable = get Root Cause ( exception ) ; if ( is Data Truncation Exception ( throwable ) ) { return get Error Information And Set Status ( Http Status . BAD REQUEST , throwable , response ) ; } else if ( is Caused By Constraint Violation Exception ( exception ) ) { return get Error Information And Set Status ( Http Status . BAD REQUEST , new Exception ( STRING + throwable . get Message ( ) ) , response ) ; } else { log Error ( STRING , exception ) ; return get Error Information And Set Status ( Http Status . INTERNAL SERVER ERROR , throwable == null ? new Exception ( STRING ) : throwable , response ) ; } }
@ Exception Handler ( value = { Jpa System Exception . class , Persistence Exception . class } ) @ Response Body public Error Information handle Persistence Exception ( Exception exception , Http Servlet Response response ) { Throwable throwable = get Root Cause ( exception ) ; if ( is Data Truncation Exception ( throwable ) ) { return get Error Information And Set Status ( Http Status . BAD REQUEST , throwable , response ) ; } else if ( is Caused By Constraint Violation Exception ( exception ) ) { return get Error Information And Set Status ( Http Status . BAD REQUEST , new Exception ( STRING + throwable . get Message ( ) ) , response ) ; } else { log Error ( STRING , exception ) ; return get Error Information And Set Status ( Http Status . INTERNAL SERVER ERROR , throwable == null ? new Exception ( STRING ) : throwable , response ) ; } }
public void remove Property Change Listener ( Property Change Listener listener ) { property Change Support . remove Property Change Listener ( listener ) ; }
public static int calculate EAN Parity ( String code ) { int mul = NUM ; int total = NUM ; for ( int k = code . length ( ) - NUM ; k >= NUM ; -- k ) { int n = code . char At ( k ) - STRING ; total += mul * n ; mul ^= NUM ; } return ( NUM - ( total % NUM ) ) % NUM ; }
public X509 Trust Chain Key Selector ( X509 Certificate ... trusted Roots ) { log = Logger Factory . get Logger ( X509 Trust Chain Key Selector . class ) ; check Ctor Args Not Null ( trusted Roots ) ; trust Anchors = new Hash Set < Trust Anchor > ( ) ; for ( X509 Certificate cert : trusted Roots ) { trust Anchors . add ( new Trust Anchor ( cert , null ) ) ; } }
public X509 Trust Chain Key Selector ( X509 Certificate ... trusted Roots ) { log = Logger Factory . get Logger ( X509 Trust Chain Key Selector . class ) ; check Ctor Args Not Null ( trusted Roots ) ; trust Anchors = new Hash Set < Trust Anchor > ( ) ; for ( X509 Certificate cert : trusted Roots ) { trust Anchors . add ( new Trust Anchor ( cert , null ) ) ; } }
public X509 Trust Chain Key Selector ( X509 Certificate ... trusted Roots ) { log = Logger Factory . get Logger ( X509 Trust Chain Key Selector . class ) ; check Ctor Args Not Null ( trusted Roots ) ; trust Anchors = new Hash Set < Trust Anchor > ( ) ; for ( X509 Certificate cert : trusted Roots ) { trust Anchors . add ( new Trust Anchor ( cert , null ) ) ; } }
public Shape create Point ( Point 2 D point ) { Rectangle 2 D . Double point Marker = new Rectangle 2 D . Double ( NUM , NUM , size , size ) ; point Marker . x = ( double ) ( point . get X ( ) - ( size / NUM ) ) ; point Marker . y = ( double ) ( point . get Y ( ) - ( size / NUM ) ) ; return point Marker ; }
public Shape create Point ( Point 2 D point ) { Rectangle 2 D . Double point Marker = new Rectangle 2 D . Double ( NUM , NUM , size , size ) ; point Marker . x = ( double ) ( point . get X ( ) - ( size / NUM ) ) ; point Marker . y = ( double ) ( point . get Y ( ) - ( size / NUM ) ) ; return point Marker ; }
public Shape create Point ( Point 2 D point ) { Rectangle 2 D . Double point Marker = new Rectangle 2 D . Double ( NUM , NUM , size , size ) ; point Marker . x = ( double ) ( point . get X ( ) - ( size / NUM ) ) ; point Marker . y = ( double ) ( point . get Y ( ) - ( size / NUM ) ) ; return point Marker ; }
private void post Init View Pager ( ) { try { Class < ? > viewpager = View Pager . class ; Field scroller = viewpager . get Declared Field ( STRING ) ; scroller . set Accessible ( BOOL ) ; Field interpolator = viewpager . get Declared Field ( STRING ) ; interpolator . set Accessible ( BOOL ) ; m Scroller = new Custom Duration Scroller ( get Context ( ) , ( Interpolator ) interpolator . get ( null ) ) ; double duration = NUM ; m Scroller . set Scroll Duration Factor ( duration ) ; scroller . set ( this , m Scroller ) ; } catch ( No Such Field Exception e ) { } catch ( Illegal Argument Exception e ) { } catch ( Illegal Access Exception e ) { } }
private void post Init View Pager ( ) { try { Class < ? > viewpager = View Pager . class ; Field scroller = viewpager . get Declared Field ( STRING ) ; scroller . set Accessible ( BOOL ) ; Field interpolator = viewpager . get Declared Field ( STRING ) ; interpolator . set Accessible ( BOOL ) ; m Scroller = new Custom Duration Scroller ( get Context ( ) , ( Interpolator ) interpolator . get ( null ) ) ; double duration = NUM ; m Scroller . set Scroll Duration Factor ( duration ) ; scroller . set ( this , m Scroller ) ; } catch ( No Such Field Exception e ) { } catch ( Illegal Argument Exception e ) { } catch ( Illegal Access Exception e ) { } }
private static void draw Circle Endpoint ( Point from , Point to , Graphics g ) { final int diameter = NUM ; double a = to . x - from . x ; double b = from . y - to . y ; double theta = Math . atan 2 ( b , a ) ; int xminus = ( int ) ( Math . cos ( theta ) * diameter / NUM ) ; int yplus = ( int ) ( Math . sin ( theta ) * diameter / NUM ) ; g . fill Oval ( to . x - xminus - diameter / NUM , to . y + yplus - diameter / NUM , diameter , diameter ) ; Color c = g . get Color ( ) ; g . set Color ( Color . white ) ; g . fill Oval ( to . x - xminus - diameter / NUM - NUM , to . y + yplus - diameter / NUM - NUM , ( int ) ( diameter / NUM ) , ( int ) ( diameter / NUM ) ) ; g . set Color ( c ) ; }
private static void draw Circle Endpoint ( Point from , Point to , Graphics g ) { final int diameter = NUM ; double a = to . x - from . x ; double b = from . y - to . y ; double theta = Math . atan 2 ( b , a ) ; int xminus = ( int ) ( Math . cos ( theta ) * diameter / NUM ) ; int yplus = ( int ) ( Math . sin ( theta ) * diameter / NUM ) ; g . fill Oval ( to . x - xminus - diameter / NUM , to . y + yplus - diameter / NUM , diameter , diameter ) ; Color c = g . get Color ( ) ; g . set Color ( Color . white ) ; g . fill Oval ( to . x - xminus - diameter / NUM - NUM , to . y + yplus - diameter / NUM - NUM , ( int ) ( diameter / NUM ) , ( int ) ( diameter / NUM ) ) ; g . set Color ( c ) ; }
private static void draw Circle Endpoint ( Point from , Point to , Graphics g ) { final int diameter = NUM ; double a = to . x - from . x ; double b = from . y - to . y ; double theta = Math . atan 2 ( b , a ) ; int xminus = ( int ) ( Math . cos ( theta ) * diameter / NUM ) ; int yplus = ( int ) ( Math . sin ( theta ) * diameter / NUM ) ; g . fill Oval ( to . x - xminus - diameter / NUM , to . y + yplus - diameter / NUM , diameter , diameter ) ; Color c = g . get Color ( ) ; g . set Color ( Color . white ) ; g . fill Oval ( to . x - xminus - diameter / NUM - NUM , to . y + yplus - diameter / NUM - NUM , ( int ) ( diameter / NUM ) , ( int ) ( diameter / NUM ) ) ; g . set Color ( c ) ; }
public Candidate extend Hypothesis ( ) { if ( ranks [ NUM ] < hypotheses . size ( ) - NUM ) { return new Candidate ( feature Functions , sentence , hypotheses , phrases , future delta , new int [ ] { ranks [ NUM ] + NUM , ranks [ NUM ] } ) ; } return null ; }
@ Override public int compare To ( final Memory Chunk chunk ) { return Long . compare ( m address , chunk . m address ) ; }
@ Override public int compare To ( final Memory Chunk chunk ) { return Long . compare ( m address , chunk . m address ) ; }
private Replicator Runtime Conf ( String service Name ) { replicator Home Dir = locate Replicator Home Dir ( ) ; replicator Log Dir = locate Replicator Log Dir ( ) ; replicator Conf Dir = locate Replicator Conf Dir ( ) ; replicator Properties = new File ( locate Replicator Conf Dir ( ) , STRING + service Name + STRING ) ; if ( ! replicator Properties . is File ( ) || ! replicator Properties . can Read ( ) ) { throw new Server Runtime Exception ( STRING + replicator Properties ) ; } replicator Dynamic Properties = new File ( replicator Conf Dir , STRING + service Name + STRING ) ; replicator Dynamic Role = new File ( replicator Conf Dir , STRING + service Name + STRING ) ; this . clear Dynamic Properties = Boolean . parse Boolean ( System . get Property ( CLEAR DYNAMIC PROPERTIES ) ) ; }
private void expect ( char expected Symbol ) throws Parse Exception { if ( ! accept ( expected Symbol ) ) throw new Parse Exception ( STRING + expected Symbol + STRING + ( char ) data [ index ] + STRING , index ) ; }
private void expect ( char expected Symbol ) throws Parse Exception { if ( ! accept ( expected Symbol ) ) throw new Parse Exception ( STRING + expected Symbol + STRING + ( char ) data [ index ] + STRING , index ) ; }
private void expect ( char expected Symbol ) throws Parse Exception { if ( ! accept ( expected Symbol ) ) throw new Parse Exception ( STRING + expected Symbol + STRING + ( char ) data [ index ] + STRING , index ) ; }
private void expect ( char expected Symbol ) throws Parse Exception { if ( ! accept ( expected Symbol ) ) throw new Parse Exception ( STRING + expected Symbol + STRING + ( char ) data [ index ] + STRING , index ) ; }
public static final < A > Collection X < A > to Lazy Collection ( final Stream < A > stream ) { return Seq Utils . to Lazy Collection ( stream . iterator ( ) ) ; }
private static List < String > rewrite Term Brute Force ( String term ) { List < String > terms List = rewrite Brute ( term ) ; if ( term == STRING || ! term . equals ( terms List . get ( terms List . size ( ) - NUM ) ) ) terms List . add ( term ) ; return terms List ; }
private static List < String > rewrite Term Brute Force ( String term ) { List < String > terms List = rewrite Brute ( term ) ; if ( term == STRING || ! term . equals ( terms List . get ( terms List . size ( ) - NUM ) ) ) terms List . add ( term ) ; return terms List ; }
private static boolean create Constraint On Postgres ( Connection Source connection Source , String constraint Name , String constraint Statement ) throws SQL Exception { Preconditions . check Argument ( is Unquoted Sql Identifier ( constraint Name ) , STRING , constraint Name ) ; if ( ! ( connection Source . get Database Type ( ) instanceof Postgres Database Type ) ) { logger . warn ( STRING , constraint Name ) ; return BOOL ; } String query String = STRING + constraint Name + STRING ; long constraint Count = connection Source . get Read Only Connection ( ) . query For Long ( query String ) ; if ( constraint Count != NUM ) { assert constraint Count == NUM ; return BOOL ; } logger . info ( STRING , constraint Name ) ; connection Source . get Read Write Connection ( ) . execute Statement ( constraint Statement , Database Connection . DEFAULT RESULT FLAGS ) ; assert connection Source . get Read Only Connection ( ) . query For Long ( query String ) == NUM ; return BOOL ; }
public void validate Derived PK Class Id ( String attribute Name , String expected Type , String reference Class Name ) { if ( m pk Class I Ds . contains Key ( attribute Name ) ) { String actual Type = m pk Class I Ds . get ( attribute Name ) ; if ( actual Type . equals ( expected Type ) ) { m pk Class I Ds . remove ( attribute Name ) ; } else { throw Validation Exception . invalid Derived Composite PK Attribute ( reference Class Name , get PK Class Name ( ) , attribute Name , expected Type , actual Type ) ; } } }
public void validate Derived PK Class Id ( String attribute Name , String expected Type , String reference Class Name ) { if ( m pk Class I Ds . contains Key ( attribute Name ) ) { String actual Type = m pk Class I Ds . get ( attribute Name ) ; if ( actual Type . equals ( expected Type ) ) { m pk Class I Ds . remove ( attribute Name ) ; } else { throw Validation Exception . invalid Derived Composite PK Attribute ( reference Class Name , get PK Class Name ( ) , attribute Name , expected Type , actual Type ) ; } } }
public void validate Derived PK Class Id ( String attribute Name , String expected Type , String reference Class Name ) { if ( m pk Class I Ds . contains Key ( attribute Name ) ) { String actual Type = m pk Class I Ds . get ( attribute Name ) ; if ( actual Type . equals ( expected Type ) ) { m pk Class I Ds . remove ( attribute Name ) ; } else { throw Validation Exception . invalid Derived Composite PK Attribute ( reference Class Name , get PK Class Name ( ) , attribute Name , expected Type , actual Type ) ; } } }
public void validate Derived PK Class Id ( String attribute Name , String expected Type , String reference Class Name ) { if ( m pk Class I Ds . contains Key ( attribute Name ) ) { String actual Type = m pk Class I Ds . get ( attribute Name ) ; if ( actual Type . equals ( expected Type ) ) { m pk Class I Ds . remove ( attribute Name ) ; } else { throw Validation Exception . invalid Derived Composite PK Attribute ( reference Class Name , get PK Class Name ( ) , attribute Name , expected Type , actual Type ) ; } } }
public void validate Derived PK Class Id ( String attribute Name , String expected Type , String reference Class Name ) { if ( m pk Class I Ds . contains Key ( attribute Name ) ) { String actual Type = m pk Class I Ds . get ( attribute Name ) ; if ( actual Type . equals ( expected Type ) ) { m pk Class I Ds . remove ( attribute Name ) ; } else { throw Validation Exception . invalid Derived Composite PK Attribute ( reference Class Name , get PK Class Name ( ) , attribute Name , expected Type , actual Type ) ; } } }
public Mim Search Editor 2 ( Mim Build Runner runner ) { this ( runner , STRING ) ; }
public Mim Search Editor 2 ( Mim Build Runner runner ) { this ( runner , STRING ) ; }
public Mim Search Editor 2 ( Mim Build Runner runner ) { this ( runner , STRING ) ; }
public static String read String Fixed Size ( final Data Input in , int size ) throws IO Exception { byte [ ] b = new byte [ size ] ; in . read Fully ( b ) ; int n = b . length ; while ( n > NUM && b [ n - NUM ] == NUM ) -- n ; return to String ( b , NUM , n ) ; }
public int size ( ) { return items . size ( ) ; }
private String make Delete All Url ( ) throws Unsupported Encoding Exception { Http Solr Client client = ( Http Solr Client ) get Solr Client ( ) ; String delete Query = STRING ; return client . get Base URL ( ) + STRING + URL Encoder . encode ( delete Query , STRING ) ; }
private String make Delete All Url ( ) throws Unsupported Encoding Exception { Http Solr Client client = ( Http Solr Client ) get Solr Client ( ) ; String delete Query = STRING ; return client . get Base URL ( ) + STRING + URL Encoder . encode ( delete Query , STRING ) ; }
public void push ( Notification notification , Notification Response Listener listener ) { final String notification Topic = notification . get Topic ( ) ; final String topic = notification Topic == null ? default Topic : notification Topic ; Request req = Utils . build Request ( client , topic , notification , gateway ) ; semaphore . acquire Uninterruptibly ( ) ; req . send ( new Response Listener ( semaphore , notification , listener ) ) ; }
public void test File File With Config Option ( ) throws Exception { Properties properties = load Properties ( STRING ) ; assert Equals ( STRING , properties . get Property ( STRING ) ) ; }
protected void remove Member ( final Relation Member member ) { while ( members . remove ( member ) ) { } }
public void make Immutable ( ) { if ( is Mutable ) { if ( conditions != null ) { int length = conditions . size ( ) ; for ( int i = NUM ; i < length ; i ++ ) { Condition condition = ( Condition ) conditions . get ( i ) ; condition . make Immutable ( ) ; } conditions = Collections . unmodifiable List ( conditions ) ; } if ( audience Restrictions != null ) { int length = audience Restrictions . size ( ) ; for ( int i = NUM ; i < length ; i ++ ) { Audience Restriction ar = ( Audience Restriction ) audience Restrictions . get ( i ) ; ar . make Immutable ( ) ; } audience Restrictions = Collections . unmodifiable List ( audience Restrictions ) ; } if ( one Time Uses != null ) { int length = one Time Uses . size ( ) ; for ( int i = NUM ; i < length ; i ++ ) { One Time Use one Time Use = ( One Time Use ) one Time Uses . get ( i ) ; one Time Use . make Immutable ( ) ; } one Time Uses = Collections . unmodifiable List ( one Time Uses ) ; } if ( proxy Restrictions != null ) { int length = proxy Restrictions . size ( ) ; for ( int i = NUM ; i < length ; i ++ ) { Proxy Restriction pr = ( Proxy Restriction ) proxy Restrictions . get ( i ) ; pr . make Immutable ( ) ; } proxy Restrictions = Collections . unmodifiable List ( proxy Restrictions ) ; } is Mutable = BOOL ; } }
public void destroy Scene ( ) { clear Animations ( ) ; clear Cameras ( ) ; clear Lights ( ) ; clear Plugins ( ) ; clear Children ( ) ; clear Frame Callbacks ( ) ; }
public void destroy Scene ( ) { clear Animations ( ) ; clear Cameras ( ) ; clear Lights ( ) ; clear Plugins ( ) ; clear Children ( ) ; clear Frame Callbacks ( ) ; }
public void destroy Scene ( ) { clear Animations ( ) ; clear Cameras ( ) ; clear Lights ( ) ; clear Plugins ( ) ; clear Children ( ) ; clear Frame Callbacks ( ) ; }
public void add Script Finished Listener ( Script Execution Listener l ) { m Finished Listeners . add ( l ) ; }
public boolean verify ( Public Key key , String sig Provider ) throws No Such Algorithm Exception , No Such Provider Exception , CMS Exception { return verify ( key , CMS Utils . get Provider ( sig Provider ) ) ; }
public boolean verify ( Public Key key , String sig Provider ) throws No Such Algorithm Exception , No Such Provider Exception , CMS Exception { return verify ( key , CMS Utils . get Provider ( sig Provider ) ) ; }
public boolean verify ( Public Key key , String sig Provider ) throws No Such Algorithm Exception , No Such Provider Exception , CMS Exception { return verify ( key , CMS Utils . get Provider ( sig Provider ) ) ; }
private static List < Block Node > clean Block List ( List < Block Node > list ) { List < Block Node > ret = new Array List < Block Node > ( list . size ( ) ) ; for ( Block Node block : list ) { if ( ! is Block Must Be Cleared ( block ) ) { ret . add ( block ) ; } } return ret ; }
protected void log Diagnostic ( String msg ) { if ( is Diagnostics Enabled ( ) ) { log Raw Diagnostic ( diagnostic Prefix + msg ) ; } }
protected void log Diagnostic ( String msg ) { if ( is Diagnostics Enabled ( ) ) { log Raw Diagnostic ( diagnostic Prefix + msg ) ; } }
public Translating Graph Mouse Plugin ( int modifiers ) { super ( modifiers ) ; this . cursor = Cursor . get Predefined Cursor ( Cursor . MOVE CURSOR ) ; }
private void resize Panel ( ) { if ( parent Frame != null ) { int additional Parent Height = ( parent Frame . get Bounds ( ) . height - scroller . get Height ( ) ) ; scroller . resize ( ) ; int new Height = scroller . get Preferred Size ( ) . height + additional Parent Height ; if ( new Height > NUM ) { parent Frame . pack ( ) ; parent Frame . set Location Relative To ( null ) ; } } }
Fixed Allocator ( final RW Store store , final int size ) { m disk Addr = NUM ; m store = store ; m size = size ; m bit Size = calc Bit Size ( BOOL , size , c Min Allocation , c Mod Allocation ) ; alloc Block Range = NUM * m bit Size ; final int num Blocks = NUM / ( m bit Size + NUM ) ; m alloc Blocks = new Array List < Alloc Block > ( num Blocks ) ; for ( int i = NUM ; i < num Blocks ; i ++ ) { m alloc Blocks . add ( new Alloc Block ( NUM , m bit Size , this ) ) ; } m free Transients = NUM ; m free Bits = NUM * m bit Size * num Blocks ; }
Fixed Allocator ( final RW Store store , final int size ) { m disk Addr = NUM ; m store = store ; m size = size ; m bit Size = calc Bit Size ( BOOL , size , c Min Allocation , c Mod Allocation ) ; alloc Block Range = NUM * m bit Size ; final int num Blocks = NUM / ( m bit Size + NUM ) ; m alloc Blocks = new Array List < Alloc Block > ( num Blocks ) ; for ( int i = NUM ; i < num Blocks ; i ++ ) { m alloc Blocks . add ( new Alloc Block ( NUM , m bit Size , this ) ) ; } m free Transients = NUM ; m free Bits = NUM * m bit Size * num Blocks ; }
Fixed Allocator ( final RW Store store , final int size ) { m disk Addr = NUM ; m store = store ; m size = size ; m bit Size = calc Bit Size ( BOOL , size , c Min Allocation , c Mod Allocation ) ; alloc Block Range = NUM * m bit Size ; final int num Blocks = NUM / ( m bit Size + NUM ) ; m alloc Blocks = new Array List < Alloc Block > ( num Blocks ) ; for ( int i = NUM ; i < num Blocks ; i ++ ) { m alloc Blocks . add ( new Alloc Block ( NUM , m bit Size , this ) ) ; } m free Transients = NUM ; m free Bits = NUM * m bit Size * num Blocks ; }
Fixed Allocator ( final RW Store store , final int size ) { m disk Addr = NUM ; m store = store ; m size = size ; m bit Size = calc Bit Size ( BOOL , size , c Min Allocation , c Mod Allocation ) ; alloc Block Range = NUM * m bit Size ; final int num Blocks = NUM / ( m bit Size + NUM ) ; m alloc Blocks = new Array List < Alloc Block > ( num Blocks ) ; for ( int i = NUM ; i < num Blocks ; i ++ ) { m alloc Blocks . add ( new Alloc Block ( NUM , m bit Size , this ) ) ; } m free Transients = NUM ; m free Bits = NUM * m bit Size * num Blocks ; }
Fixed Allocator ( final RW Store store , final int size ) { m disk Addr = NUM ; m store = store ; m size = size ; m bit Size = calc Bit Size ( BOOL , size , c Min Allocation , c Mod Allocation ) ; alloc Block Range = NUM * m bit Size ; final int num Blocks = NUM / ( m bit Size + NUM ) ; m alloc Blocks = new Array List < Alloc Block > ( num Blocks ) ; for ( int i = NUM ; i < num Blocks ; i ++ ) { m alloc Blocks . add ( new Alloc Block ( NUM , m bit Size , this ) ) ; } m free Transients = NUM ; m free Bits = NUM * m bit Size * num Blocks ; }
public static UUID from UUID As URN String To UUID ( String UUI Das URN ) { if ( ! UUI Das URN . starts With ( UUID Helper . UUID as a URN PREFIX ) ) { IMF Error Logger imf Error Logger = new IMF Error Logger Impl ( ) ; imf Error Logger . add Error ( IMF Error Logger . IMF Errors . Error Codes . UUID ERROR , IMF Error Logger . IMF Errors . Error Levels . FATAL , String . format ( STRING + STRING , UUI Das URN , UUID Helper . UUID as a URN PREFIX ) ) ; throw new IMF Exception ( String . format ( STRING , UUI Das URN , UUID Helper . UUID as a URN PREFIX ) , imf Error Logger ) ; } return UUID . from String ( UUI Das URN . split ( UUID Helper . UUID as a URN PREFIX ) [ NUM ] ) ; }
External Problem ( Process process ) { this ( process . get Input Stream ( ) , process . get Output Stream ( ) ) ; Redirect Stream . redirect ( process . get Error Stream ( ) , System . err ) ; }
External Problem ( Process process ) { this ( process . get Input Stream ( ) , process . get Output Stream ( ) ) ; Redirect Stream . redirect ( process . get Error Stream ( ) , System . err ) ; }
External Problem ( Process process ) { this ( process . get Input Stream ( ) , process . get Output Stream ( ) ) ; Redirect Stream . redirect ( process . get Error Stream ( ) , System . err ) ; }
private static int uarimax Le ( double value , double [ ] bv , int [ ] bvi , Binary Operator b Op ) throws DML Runtime Exception { int ix Max = bv . length ; if ( value <= bv [ NUM ] || value > bv [ bv . length - NUM ] ) return ix Max ; int ix = Arrays . binary Search ( bv , value ) ; if ( ix < NUM ) ix = Math . abs ( ix ) - NUM ; ix Max = bvi [ ix ] + NUM ; return ix Max ; }
private static String capitalize ( String input ) { final char [ ] buffer = input . to Char Array ( ) ; buffer [ NUM ] = Character . to Title Case ( buffer [ NUM ] ) ; return new String ( buffer ) ; }
protected Abstract Regex Annotator ( String pattern , boolean case Sensitive , double confidence ) { this ( Pattern . compile ( pattern , case Sensitive ? NUM : Pattern . CASE INSENSITIVE ) , NUM , confidence ) ; }
public CART Impl ( Buffered Reader reader , int nodes ) throws IO Exception { this ( nodes ) ; String line ; for ( int i = NUM ; i < nodes ; i ++ ) { line = reader . read Line ( ) ; if ( ! line . starts With ( STRING ) ) { parse And Add ( line ) ; } } }
public CART Impl ( Buffered Reader reader , int nodes ) throws IO Exception { this ( nodes ) ; String line ; for ( int i = NUM ; i < nodes ; i ++ ) { line = reader . read Line ( ) ; if ( ! line . starts With ( STRING ) ) { parse And Add ( line ) ; } } }
public CART Impl ( Buffered Reader reader , int nodes ) throws IO Exception { this ( nodes ) ; String line ; for ( int i = NUM ; i < nodes ; i ++ ) { line = reader . read Line ( ) ; if ( ! line . starts With ( STRING ) ) { parse And Add ( line ) ; } } }
void add Non Expiring Session ( Internal Session session ) { if ( session . will Expire ( ) ) { throw new Illegal State Exception ( STRING ) ; } session . set Max Session Time ( NON EXPIRING SESSION LENGTH MINUTES ) ; session . set Max Idle Time ( refresh Period In Minutes * NUM ) ; update Session ( session ) ; non Expiring Sessions . add ( session . get ID ( ) ) ; }
private void exit ( ) { log . info ( STRING ) ; Object result = do It ( START , STRING , null ) ; Process Info pi = new Process Info ( STRING , NUM ) ; pi . set Class Name ( REMOTE ) ; pi . set Serializable Object ( m replication Start ) ; try { m server Remote . process ( new Properties ( ) , pi ) ; } catch ( Exception ex ) { } }
synchronized boolean release ( ) { d ( STRING ) ; if ( state == BUSY ) { state = IDLE ; idle Since = System . current Time Millis ( ) ; return BOOL ; } else { return BOOL ; } }
synchronized boolean release ( ) { d ( STRING ) ; if ( state == BUSY ) { state = IDLE ; idle Since = System . current Time Millis ( ) ; return BOOL ; } else { return BOOL ; } }
synchronized boolean release ( ) { d ( STRING ) ; if ( state == BUSY ) { state = IDLE ; idle Since = System . current Time Millis ( ) ; return BOOL ; } else { return BOOL ; } }
public void remove All ( ) { m Parts . clear ( ) ; }
public static void read Lines ( Input Stream stream , Consumer < String > line Processor ) throws IO Exception { try ( Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( stream ) ) ) { String line = null ; while ( ( line = reader . read Line ( ) ) != null ) { line Processor . accept ( line ) ; } } }
public static void read Lines ( Input Stream stream , Consumer < String > line Processor ) throws IO Exception { try ( Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( stream ) ) ) { String line = null ; while ( ( line = reader . read Line ( ) ) != null ) { line Processor . accept ( line ) ; } } }
public static void read Lines ( Input Stream stream , Consumer < String > line Processor ) throws IO Exception { try ( Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( stream ) ) ) { String line = null ; while ( ( line = reader . read Line ( ) ) != null ) { line Processor . accept ( line ) ; } } }
public static String append Path ( String path To , String path From ) { if ( path To == null || path To . length ( ) == NUM ) { return path From ; } else if ( path From == null || path From . length ( ) == NUM ) { return path To ; } else { return path To + File . path Separator + path From ; } }
public static String append Path ( String path To , String path From ) { if ( path To == null || path To . length ( ) == NUM ) { return path From ; } else if ( path From == null || path From . length ( ) == NUM ) { return path To ; } else { return path To + File . path Separator + path From ; } }
public boolean equals ( Object o ) { if ( o instanceof AM Identity Subject ) { AM Identity Subject subject = ( AM Identity Subject ) o ; return ( subject Values . equals ( subject . subject Values ) ) ; } return ( BOOL ) ; }
private void reseed ( ) throws Random Data Generation Exception { if ( n Bytes Generated < RESEEDING LIMIT ) { return ; } else { try { set Seed ( wrapped Randomness Generator . generate Seed ( NUM ) ) ; } catch ( Exception e ) { throw new Random Data Generation Exception ( STRING ) ; } } }
private void reseed ( ) throws Random Data Generation Exception { if ( n Bytes Generated < RESEEDING LIMIT ) { return ; } else { try { set Seed ( wrapped Randomness Generator . generate Seed ( NUM ) ) ; } catch ( Exception e ) { throw new Random Data Generation Exception ( STRING ) ; } } }
private void reseed ( ) throws Random Data Generation Exception { if ( n Bytes Generated < RESEEDING LIMIT ) { return ; } else { try { set Seed ( wrapped Randomness Generator . generate Seed ( NUM ) ) ; } catch ( Exception e ) { throw new Random Data Generation Exception ( STRING ) ; } } }
private void reseed ( ) throws Random Data Generation Exception { if ( n Bytes Generated < RESEEDING LIMIT ) { return ; } else { try { set Seed ( wrapped Randomness Generator . generate Seed ( NUM ) ) ; } catch ( Exception e ) { throw new Random Data Generation Exception ( STRING ) ; } } }
@ Override public void passivate ( ) { cleanup User Transaction ( ) ; super . passivate ( ) ; }
@ Override public void passivate ( ) { cleanup User Transaction ( ) ; super . passivate ( ) ; }
public String to String ( int digits , boolean trailing ) { if ( is Empty ( ) ) return STRING ; String Buffer text = new String Buffer ( ) ; Flexible Decimal Format nf = new Flexible Decimal Format ( digits , trailing ) ; nf . grouping ( BOOL ) ; for ( int i = NUM ; i < size ( ) ; i ++ ) nf . update ( get ( i ) ) ; int count = NUM ; int width = NUM ; String number ; for ( int i = NUM ; i < size ( ) ; i ++ ) { number = nf . format ( get ( i ) ) ; count += NUM + number . length ( ) ; if ( count > width - NUM ) { text . append ( STRING ) ; count = NUM + number . length ( ) ; } text . append ( STRING + number ) ; } return text . to String ( ) ; }
public void test Constructor Sign Bytes Zero 1 ( ) { byte a Bytes [ ] = { - NUM , NUM , + NUM , NUM , NUM , NUM , NUM } ; int a Sign = - NUM ; byte r Bytes [ ] = { NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
public void paint Text ( Synth Context ss , Graphics g , String text , int x , int y , int mnemonic Index ) { if ( text != null ) { Graphics 2 D g2 d = ( Graphics 2 D ) g . create ( ) ; g2 d . set Rendering Hint ( Rendering Hints . KEY TEXT ANTIALIASING , Rendering Hints . VALUE TEXT ANTIALIAS ON ) ; J Component c = ss . get Component ( ) ; Font Metrics fm = Swing Utilities 2 . get Font Metrics ( c , g2 d ) ; y += fm . get Ascent ( ) ; Swing Utilities 2 . draw String ( c , g2 d , text , x , y ) ; if ( mnemonic Index >= NUM && mnemonic Index < text . length ( ) ) { int underline X = x + Swing Utilities 2 . string Width ( c , fm , text . substring ( NUM , mnemonic Index ) ) ; int underline Y = y ; int underline Width = fm . char Width ( text . char At ( mnemonic Index ) ) ; int underline Height = NUM ; g2 d . fill Rect ( underline X , underline Y + fm . get Descent ( ) - NUM , underline Width , underline Height ) ; } } }
public void paint Text ( Synth Context ss , Graphics g , String text , int x , int y , int mnemonic Index ) { if ( text != null ) { Graphics 2 D g2 d = ( Graphics 2 D ) g . create ( ) ; g2 d . set Rendering Hint ( Rendering Hints . KEY TEXT ANTIALIASING , Rendering Hints . VALUE TEXT ANTIALIAS ON ) ; J Component c = ss . get Component ( ) ; Font Metrics fm = Swing Utilities 2 . get Font Metrics ( c , g2 d ) ; y += fm . get Ascent ( ) ; Swing Utilities 2 . draw String ( c , g2 d , text , x , y ) ; if ( mnemonic Index >= NUM && mnemonic Index < text . length ( ) ) { int underline X = x + Swing Utilities 2 . string Width ( c , fm , text . substring ( NUM , mnemonic Index ) ) ; int underline Y = y ; int underline Width = fm . char Width ( text . char At ( mnemonic Index ) ) ; int underline Height = NUM ; g2 d . fill Rect ( underline X , underline Y + fm . get Descent ( ) - NUM , underline Width , underline Height ) ; } } }
public void paint Text ( Synth Context ss , Graphics g , String text , int x , int y , int mnemonic Index ) { if ( text != null ) { Graphics 2 D g2 d = ( Graphics 2 D ) g . create ( ) ; g2 d . set Rendering Hint ( Rendering Hints . KEY TEXT ANTIALIASING , Rendering Hints . VALUE TEXT ANTIALIAS ON ) ; J Component c = ss . get Component ( ) ; Font Metrics fm = Swing Utilities 2 . get Font Metrics ( c , g2 d ) ; y += fm . get Ascent ( ) ; Swing Utilities 2 . draw String ( c , g2 d , text , x , y ) ; if ( mnemonic Index >= NUM && mnemonic Index < text . length ( ) ) { int underline X = x + Swing Utilities 2 . string Width ( c , fm , text . substring ( NUM , mnemonic Index ) ) ; int underline Y = y ; int underline Width = fm . char Width ( text . char At ( mnemonic Index ) ) ; int underline Height = NUM ; g2 d . fill Rect ( underline X , underline Y + fm . get Descent ( ) - NUM , underline Width , underline Height ) ; } } }
public void paint Text ( Synth Context ss , Graphics g , String text , int x , int y , int mnemonic Index ) { if ( text != null ) { Graphics 2 D g2 d = ( Graphics 2 D ) g . create ( ) ; g2 d . set Rendering Hint ( Rendering Hints . KEY TEXT ANTIALIASING , Rendering Hints . VALUE TEXT ANTIALIAS ON ) ; J Component c = ss . get Component ( ) ; Font Metrics fm = Swing Utilities 2 . get Font Metrics ( c , g2 d ) ; y += fm . get Ascent ( ) ; Swing Utilities 2 . draw String ( c , g2 d , text , x , y ) ; if ( mnemonic Index >= NUM && mnemonic Index < text . length ( ) ) { int underline X = x + Swing Utilities 2 . string Width ( c , fm , text . substring ( NUM , mnemonic Index ) ) ; int underline Y = y ; int underline Width = fm . char Width ( text . char At ( mnemonic Index ) ) ; int underline Height = NUM ; g2 d . fill Rect ( underline X , underline Y + fm . get Descent ( ) - NUM , underline Width , underline Height ) ; } } }
public void paint Text ( Synth Context ss , Graphics g , String text , int x , int y , int mnemonic Index ) { if ( text != null ) { Graphics 2 D g2 d = ( Graphics 2 D ) g . create ( ) ; g2 d . set Rendering Hint ( Rendering Hints . KEY TEXT ANTIALIASING , Rendering Hints . VALUE TEXT ANTIALIAS ON ) ; J Component c = ss . get Component ( ) ; Font Metrics fm = Swing Utilities 2 . get Font Metrics ( c , g2 d ) ; y += fm . get Ascent ( ) ; Swing Utilities 2 . draw String ( c , g2 d , text , x , y ) ; if ( mnemonic Index >= NUM && mnemonic Index < text . length ( ) ) { int underline X = x + Swing Utilities 2 . string Width ( c , fm , text . substring ( NUM , mnemonic Index ) ) ; int underline Y = y ; int underline Width = fm . char Width ( text . char At ( mnemonic Index ) ) ; int underline Height = NUM ; g2 d . fill Rect ( underline X , underline Y + fm . get Descent ( ) - NUM , underline Width , underline Height ) ; } } }
public void run ( G graph ) { List < Tagged Vertex > recruits = init ( graph ) ; while ( ! recruits . is Empty ( ) ) { logger . info ( String . format ( STRING , iteration ) ) ; List < Tagged Vertex > new Recruits = new Linked List < Tagged Vertex > ( ) ; Collections . shuffle ( recruits , random ) ; for ( Tagged Vertex vertex : recruits ) { if ( ! listener . before Sampling ( this , vertex . get Projection ( ) ) ) return ; if ( vertex . is Responsive ( ) ) { expand ( vertex , new Recruits ) ; } if ( ! listener . after Sampling ( this , vertex . get Projection ( ) ) ) return ; } recruits = new Recruits ; iteration ++ ; } listener . end Sampling ( this ) ; logger . info ( STRING ) ; }
public void run ( G graph ) { List < Tagged Vertex > recruits = init ( graph ) ; while ( ! recruits . is Empty ( ) ) { logger . info ( String . format ( STRING , iteration ) ) ; List < Tagged Vertex > new Recruits = new Linked List < Tagged Vertex > ( ) ; Collections . shuffle ( recruits , random ) ; for ( Tagged Vertex vertex : recruits ) { if ( ! listener . before Sampling ( this , vertex . get Projection ( ) ) ) return ; if ( vertex . is Responsive ( ) ) { expand ( vertex , new Recruits ) ; } if ( ! listener . after Sampling ( this , vertex . get Projection ( ) ) ) return ; } recruits = new Recruits ; iteration ++ ; } listener . end Sampling ( this ) ; logger . info ( STRING ) ; }
public void run ( G graph ) { List < Tagged Vertex > recruits = init ( graph ) ; while ( ! recruits . is Empty ( ) ) { logger . info ( String . format ( STRING , iteration ) ) ; List < Tagged Vertex > new Recruits = new Linked List < Tagged Vertex > ( ) ; Collections . shuffle ( recruits , random ) ; for ( Tagged Vertex vertex : recruits ) { if ( ! listener . before Sampling ( this , vertex . get Projection ( ) ) ) return ; if ( vertex . is Responsive ( ) ) { expand ( vertex , new Recruits ) ; } if ( ! listener . after Sampling ( this , vertex . get Projection ( ) ) ) return ; } recruits = new Recruits ; iteration ++ ; } listener . end Sampling ( this ) ; logger . info ( STRING ) ; }
public void run ( G graph ) { List < Tagged Vertex > recruits = init ( graph ) ; while ( ! recruits . is Empty ( ) ) { logger . info ( String . format ( STRING , iteration ) ) ; List < Tagged Vertex > new Recruits = new Linked List < Tagged Vertex > ( ) ; Collections . shuffle ( recruits , random ) ; for ( Tagged Vertex vertex : recruits ) { if ( ! listener . before Sampling ( this , vertex . get Projection ( ) ) ) return ; if ( vertex . is Responsive ( ) ) { expand ( vertex , new Recruits ) ; } if ( ! listener . after Sampling ( this , vertex . get Projection ( ) ) ) return ; } recruits = new Recruits ; iteration ++ ; } listener . end Sampling ( this ) ; logger . info ( STRING ) ; }
public void run ( G graph ) { List < Tagged Vertex > recruits = init ( graph ) ; while ( ! recruits . is Empty ( ) ) { logger . info ( String . format ( STRING , iteration ) ) ; List < Tagged Vertex > new Recruits = new Linked List < Tagged Vertex > ( ) ; Collections . shuffle ( recruits , random ) ; for ( Tagged Vertex vertex : recruits ) { if ( ! listener . before Sampling ( this , vertex . get Projection ( ) ) ) return ; if ( vertex . is Responsive ( ) ) { expand ( vertex , new Recruits ) ; } if ( ! listener . after Sampling ( this , vertex . get Projection ( ) ) ) return ; } recruits = new Recruits ; iteration ++ ; } listener . end Sampling ( this ) ; logger . info ( STRING ) ; }
public void run ( G graph ) { List < Tagged Vertex > recruits = init ( graph ) ; while ( ! recruits . is Empty ( ) ) { logger . info ( String . format ( STRING , iteration ) ) ; List < Tagged Vertex > new Recruits = new Linked List < Tagged Vertex > ( ) ; Collections . shuffle ( recruits , random ) ; for ( Tagged Vertex vertex : recruits ) { if ( ! listener . before Sampling ( this , vertex . get Projection ( ) ) ) return ; if ( vertex . is Responsive ( ) ) { expand ( vertex , new Recruits ) ; } if ( ! listener . after Sampling ( this , vertex . get Projection ( ) ) ) return ; } recruits = new Recruits ; iteration ++ ; } listener . end Sampling ( this ) ; logger . info ( STRING ) ; }
public void draw Glyph Vector ( Glyph Vector gv , float x , float y ) { Shape text Outline = gv . get Outline ( x , y ) ; fill ( text Outline ) ; }
public void draw Glyph Vector ( Glyph Vector gv , float x , float y ) { Shape text Outline = gv . get Outline ( x , y ) ; fill ( text Outline ) ; }
public void draw Glyph Vector ( Glyph Vector gv , float x , float y ) { Shape text Outline = gv . get Outline ( x , y ) ; fill ( text Outline ) ; }
public void add Entity ( final Odor World Entity entity ) { entity . set Id ( entity ID Generator . get Id ( ) ) ; entity List . add ( entity ) ; fire Entity Added ( entity ) ; recompute Max Stimulus Length ( ) ; }
double scale ( final int pixels , final int total ) { double distance = Math . max ( upper - lower , NUM ) ; double fraction = ( ( double ) pixels ) / total ; LOGGER . debug ( STRING + pixels + STRING + total + STRING + fraction * distance ) ; return fraction * distance ; }
double scale ( final int pixels , final int total ) { double distance = Math . max ( upper - lower , NUM ) ; double fraction = ( ( double ) pixels ) / total ; LOGGER . debug ( STRING + pixels + STRING + total + STRING + fraction * distance ) ; return fraction * distance ; }
double scale ( final int pixels , final int total ) { double distance = Math . max ( upper - lower , NUM ) ; double fraction = ( ( double ) pixels ) / total ; LOGGER . debug ( STRING + pixels + STRING + total + STRING + fraction * distance ) ; return fraction * distance ; }
private Injector create Injector For ( final Class < ? > [ ] classes ) throws Initialization Error { final List < Module > modules = new Array List < > ( ) ; if ( classes != null ) { for ( final Class < ? > module : Arrays . as List ( classes ) ) { try { modules . add ( ( Module ) module . new Instance ( ) ) ; } catch ( final Reflective Operation Exception exception ) { throw new Initialization Error ( exception ) ; } } } return Guice . create Injector ( modules ) ; }
private Injector create Injector For ( final Class < ? > [ ] classes ) throws Initialization Error { final List < Module > modules = new Array List < > ( ) ; if ( classes != null ) { for ( final Class < ? > module : Arrays . as List ( classes ) ) { try { modules . add ( ( Module ) module . new Instance ( ) ) ; } catch ( final Reflective Operation Exception exception ) { throw new Initialization Error ( exception ) ; } } } return Guice . create Injector ( modules ) ; }
public void Add Column ( Column column ) { columns . add ( column ) ; }
public static final Index create Test Index UUID Field ( ) { Index index = new Index ( STRING ) ; index . set Table ( DB , STRING ) ; Array List < Index Field > fields = new Array List < > ( ) ; fields . add ( new Index Field ( STRING , Field Data Type . UUID ) ) ; index . set Fields ( fields ) ; index . is Unique ( BOOL ) ; return index ; }
public static File stream 2 file ( Input Stream in ) throws IO Exception { final File temp File = File . create Temp File ( PREFIX , SUFFIX ) ; try ( File Output Stream out = new File Output Stream ( temp File ) ) { IO Utils . copy ( in , out ) ; } String new Font = get Font For OS ( ) ; if ( new Font . compare To Ignore Case ( DEFAULT FONT ) != NUM ) { Buffered Reader br = new Buffered Reader ( new File Reader ( temp File ) ) ; try { String Builder sb = new String Builder ( ) ; String line = br . read Line ( ) ; while ( line != null ) { sb . append ( line . replace ( DEFAULT FONT , new Font ) ) ; sb . append ( STRING ) ; line = br . read Line ( ) ; } try { File Writer file Writer = new File Writer ( temp File ) ; file Writer . write ( sb . to String ( ) ) ; file Writer . flush ( ) ; file Writer . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } finally { br . close ( ) ; } } return temp File ; }
@ Override public < T > Service Builder Amp new Service ( Class < T > type ) { Objects . require Non Null ( type ) ; return new Service Builder Impl < > ( this , type ) ; }
@ Override public < T > Service Builder Amp new Service ( Class < T > type ) { Objects . require Non Null ( type ) ; return new Service Builder Impl < > ( this , type ) ; }
@ Suppress Warnings ( { STRING , STRING } ) private static Object as Simple Binding ( Object obj To Clean ) { if ( obj To Clean instanceof O Document ) { logger . trace ( STRING , obj To Clean ) ; return Document Util . to Map ( ( O Document ) obj To Clean , BOOL ) ; } else if ( obj To Clean instanceof List ) { logger . trace ( STRING , obj To Clean ) ; return to Simple Model ( ( List ) obj To Clean ) ; } else if ( obj To Clean instanceof Set ) { logger . trace ( STRING , obj To Clean ) ; return to Simple Model ( ( Set ) obj To Clean ) ; } else if ( obj To Clean instanceof Map ) { logger . trace ( STRING , obj To Clean ) ; return to Simple Model ( ( Map ) obj To Clean ) ; } else if ( obj To Clean instanceof com . orientechnologies . orient . core . id . ORID ) { logger . warn ( STRING , obj To Clean ) ; return obj To Clean . to String ( ) ; } else { return obj To Clean ; } }
@ Suppress Warnings ( { STRING , STRING } ) private static Object as Simple Binding ( Object obj To Clean ) { if ( obj To Clean instanceof O Document ) { logger . trace ( STRING , obj To Clean ) ; return Document Util . to Map ( ( O Document ) obj To Clean , BOOL ) ; } else if ( obj To Clean instanceof List ) { logger . trace ( STRING , obj To Clean ) ; return to Simple Model ( ( List ) obj To Clean ) ; } else if ( obj To Clean instanceof Set ) { logger . trace ( STRING , obj To Clean ) ; return to Simple Model ( ( Set ) obj To Clean ) ; } else if ( obj To Clean instanceof Map ) { logger . trace ( STRING , obj To Clean ) ; return to Simple Model ( ( Map ) obj To Clean ) ; } else if ( obj To Clean instanceof com . orientechnologies . orient . core . id . ORID ) { logger . warn ( STRING , obj To Clean ) ; return obj To Clean . to String ( ) ; } else { return obj To Clean ; } }
public static byte [ ] to Byte Array ( Sms Udh Element [ ] udh Elements ) { Byte Array Output Stream baos = new Byte Array Output Stream ( NUM ) ; if ( udh Elements == null ) { return new byte [ NUM ] ; } baos . write ( ( byte ) Sms Udh Util . get Total Size ( udh Elements ) ) ; try { for ( Sms Udh Element udh Element : udh Elements ) { udh Element . write To ( baos ) ; } } catch ( IO Exception ioe ) { throw new Runtime Exception ( ioe ) ; } return baos . to Byte Array ( ) ; }
private void init draw graphics ( Graphics 2 D p graphics , Color p color , float p width ) { Basic Stroke bs = new Basic Stroke ( Math . max ( p width , NUM ) , Basic Stroke . CAP ROUND , Basic Stroke . JOIN ROUND ) ; p graphics . set Stroke ( bs ) ; p graphics . set Color ( p color ) ; p graphics . set Rendering Hint ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; }
private void init draw graphics ( Graphics 2 D p graphics , Color p color , float p width ) { Basic Stroke bs = new Basic Stroke ( Math . max ( p width , NUM ) , Basic Stroke . CAP ROUND , Basic Stroke . JOIN ROUND ) ; p graphics . set Stroke ( bs ) ; p graphics . set Color ( p color ) ; p graphics . set Rendering Hint ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; }
@ Override public void ignorable Whitespace ( XML String text , Augmentations augs ) throws XNI Exception { if ( ! f Include Ignorable Whitespace || f Filter Reject ) { return ; } if ( ! f Defer Node Expansion ) { Node child = f Current Node . get Last Child ( ) ; if ( child != null && child . get Node Type ( ) == Node . TEXT NODE ) { Text text Node = ( Text ) child ; text Node . append Data ( text . to String ( ) ) ; } else { Text text Node = f Document . create Text Node ( text . to String ( ) ) ; if ( f Document Impl != null ) { Text Impl text Node Impl = ( Text Impl ) text Node ; text Node Impl . set Ignorable Whitespace ( BOOL ) ; } f Current Node . append Child ( text Node ) ; } } else { int txt = f Deferred Document Impl . create Deferred Text Node ( text . to String ( ) , BOOL ) ; f Deferred Document Impl . append Child ( f Current Node Index , txt ) ; } }
@ Override public void ignorable Whitespace ( XML String text , Augmentations augs ) throws XNI Exception { if ( ! f Include Ignorable Whitespace || f Filter Reject ) { return ; } if ( ! f Defer Node Expansion ) { Node child = f Current Node . get Last Child ( ) ; if ( child != null && child . get Node Type ( ) == Node . TEXT NODE ) { Text text Node = ( Text ) child ; text Node . append Data ( text . to String ( ) ) ; } else { Text text Node = f Document . create Text Node ( text . to String ( ) ) ; if ( f Document Impl != null ) { Text Impl text Node Impl = ( Text Impl ) text Node ; text Node Impl . set Ignorable Whitespace ( BOOL ) ; } f Current Node . append Child ( text Node ) ; } } else { int txt = f Deferred Document Impl . create Deferred Text Node ( text . to String ( ) , BOOL ) ; f Deferred Document Impl . append Child ( f Current Node Index , txt ) ; } }
@ Override public void ignorable Whitespace ( XML String text , Augmentations augs ) throws XNI Exception { if ( ! f Include Ignorable Whitespace || f Filter Reject ) { return ; } if ( ! f Defer Node Expansion ) { Node child = f Current Node . get Last Child ( ) ; if ( child != null && child . get Node Type ( ) == Node . TEXT NODE ) { Text text Node = ( Text ) child ; text Node . append Data ( text . to String ( ) ) ; } else { Text text Node = f Document . create Text Node ( text . to String ( ) ) ; if ( f Document Impl != null ) { Text Impl text Node Impl = ( Text Impl ) text Node ; text Node Impl . set Ignorable Whitespace ( BOOL ) ; } f Current Node . append Child ( text Node ) ; } } else { int txt = f Deferred Document Impl . create Deferred Text Node ( text . to String ( ) , BOOL ) ; f Deferred Document Impl . append Child ( f Current Node Index , txt ) ; } }
@ Override public void ignorable Whitespace ( XML String text , Augmentations augs ) throws XNI Exception { if ( ! f Include Ignorable Whitespace || f Filter Reject ) { return ; } if ( ! f Defer Node Expansion ) { Node child = f Current Node . get Last Child ( ) ; if ( child != null && child . get Node Type ( ) == Node . TEXT NODE ) { Text text Node = ( Text ) child ; text Node . append Data ( text . to String ( ) ) ; } else { Text text Node = f Document . create Text Node ( text . to String ( ) ) ; if ( f Document Impl != null ) { Text Impl text Node Impl = ( Text Impl ) text Node ; text Node Impl . set Ignorable Whitespace ( BOOL ) ; } f Current Node . append Child ( text Node ) ; } } else { int txt = f Deferred Document Impl . create Deferred Text Node ( text . to String ( ) , BOOL ) ; f Deferred Document Impl . append Child ( f Current Node Index , txt ) ; } }
private static void write Properties ( Properties props , String key Prefix , Map < String , Boolean > filters ) { int counter = NUM ; Set < Entry < String , Boolean > > entry Set = filters . entry Set ( ) ; for ( Entry < String , Boolean > entry : entry Set ) { props . set Property ( key Prefix + counter , entry . get Key ( ) + BOOL SEPARATOR + entry . get Value ( ) ) ; counter ++ ; } boolean key Found = BOOL ; while ( key Found ) { String key = key Prefix + counter ; String property = props . get Property ( key ) ; if ( property == null ) { key Found = BOOL ; } else { props . remove ( key ) ; } } }
public boolean [ ] test To String ( ) { return super . test To String ( ) ; }
public void stop ( ) { is Alive . set ( BOOL ) ; for ( Kafka Consumer < byte [ ] , byte [ ] > c : consumers . values ( ) ) { c . wakeup ( ) ; } kafka Consumer Executor . shutdown Now ( ) ; holding Buffer . clear ( ) ; IO Utils . close Quietly ( this ) ; }
public static Big Integer calculate Key ( Digest digest , Big Integer N , Big Integer S ) { int pad Length = ( N . bit Length ( ) + NUM ) / NUM ; byte [ ] S = get Padded ( S , pad Length ) ; digest . update ( S , NUM , S . length ) ; byte [ ] output = new byte [ digest . get Digest Size ( ) ] ; digest . do Final ( output , NUM ) ; return new Big Integer ( NUM , output ) ; }
public static Big Integer calculate Key ( Digest digest , Big Integer N , Big Integer S ) { int pad Length = ( N . bit Length ( ) + NUM ) / NUM ; byte [ ] S = get Padded ( S , pad Length ) ; digest . update ( S , NUM , S . length ) ; byte [ ] output = new byte [ digest . get Digest Size ( ) ] ; digest . do Final ( output , NUM ) ; return new Big Integer ( NUM , output ) ; }
long total Memory ( ) ;
long total Memory ( ) ;
long total Memory ( ) ;
@ React Method public void find Subview In ( final int react Tag , final Readable Array point , final Callback callback ) { m Operations Queue . enqueue Find Target For Touch ( react Tag , Math . round ( Pixel Util . to Pixel From DIP ( point . get Double ( NUM ) ) ) , Math . round ( Pixel Util . to Pixel From DIP ( point . get Double ( NUM ) ) ) , callback ) ; }
@ React Method public void find Subview In ( final int react Tag , final Readable Array point , final Callback callback ) { m Operations Queue . enqueue Find Target For Touch ( react Tag , Math . round ( Pixel Util . to Pixel From DIP ( point . get Double ( NUM ) ) ) , Math . round ( Pixel Util . to Pixel From DIP ( point . get Double ( NUM ) ) ) , callback ) ; }
@ React Method public void find Subview In ( final int react Tag , final Readable Array point , final Callback callback ) { m Operations Queue . enqueue Find Target For Touch ( react Tag , Math . round ( Pixel Util . to Pixel From DIP ( point . get Double ( NUM ) ) ) , Math . round ( Pixel Util . to Pixel From DIP ( point . get Double ( NUM ) ) ) , callback ) ; }
public void expand Path ( Object ... path ) { expand Path ( is Initialized ( ) , path ) ; }
public static Plain Text plain ( short text ) { return plain ( Integer . to String ( text ) ) ; }
@ Suppress Warnings ( STRING ) private void create Data Regions ( ) { Host host = Host . get Host ( NUM ) ; int number Of Vms = host . get VM Count ( ) ; for ( int i = NUM ; i < number Of Vms ; ++ i ) { open Cache ( host . get VM ( i ) ) ; } }
public Power Model Cubic ( double max Power , double static Power Percent ) { set Max Power ( max Power ) ; set Static Power ( static Power Percent * max Power ) ; set Constant ( ( max Power - get Static Power ( ) ) / Math . pow ( NUM , NUM ) ) ; }
public void force Leader ( int timeout ) { long start = System . current Time Millis ( ) ; while ( ! cmember . is Leader ( ) ) { try { cmember . force Leader ( ) ; if ( timeout >= NUM && System . current Time Millis ( ) - start > timeout ) { break ; } Thread . sleep ( NUM ) ; } catch ( Exception e ) { logger . error ( e . get Message ( ) , e ) ; } } }
public void force Leader ( int timeout ) { long start = System . current Time Millis ( ) ; while ( ! cmember . is Leader ( ) ) { try { cmember . force Leader ( ) ; if ( timeout >= NUM && System . current Time Millis ( ) - start > timeout ) { break ; } Thread . sleep ( NUM ) ; } catch ( Exception e ) { logger . error ( e . get Message ( ) , e ) ; } } }
private int word Back ( int offset ) { int x = word BI . preceding ( offset ) ; if ( x < offset - NUM ) { x = offset ; } if ( x < NUM ) { x = NUM ; } return x ; }
@ Override public void warning ( String domain , String key , XML Parse Exception exception ) throws XNI Exception { if ( f Error Handler != null ) { SAX Parse Exception sax Exception = create SAX Parse Exception ( exception ) ; try { f Error Handler . warning ( sax Exception ) ; } catch ( SAX Parse Exception e ) { throw create XML Parse Exception ( e ) ; } catch ( SAX Exception e ) { throw create XNI Exception ( e ) ; } } }
private static S2 Cell Id from Face IJ Wrap ( int face , int i , int j ) { i = Math . max ( - NUM , Math . min ( MAX SIZE , i ) ) ; j = Math . max ( - NUM , Math . min ( MAX SIZE , j ) ) ; final double k Scale = NUM / MAX SIZE ; double s = k Scale * ( ( i << NUM ) + NUM - MAX SIZE ) ; double t = k Scale * ( ( j << NUM ) + NUM - MAX SIZE ) ; S2 Point p = S2 Projections . face Uv To Xyz ( face , s , t ) ; face = S2 Projections . xyz To Face ( p ) ; R2 Vector st = S2 Projections . valid Face Xyz To Uv ( face , p ) ; return from Face IJ ( face , st To IJ ( st . x ( ) ) , st To IJ ( st . y ( ) ) ) ; }
private static S2 Cell Id from Face IJ Wrap ( int face , int i , int j ) { i = Math . max ( - NUM , Math . min ( MAX SIZE , i ) ) ; j = Math . max ( - NUM , Math . min ( MAX SIZE , j ) ) ; final double k Scale = NUM / MAX SIZE ; double s = k Scale * ( ( i << NUM ) + NUM - MAX SIZE ) ; double t = k Scale * ( ( j << NUM ) + NUM - MAX SIZE ) ; S2 Point p = S2 Projections . face Uv To Xyz ( face , s , t ) ; face = S2 Projections . xyz To Face ( p ) ; R2 Vector st = S2 Projections . valid Face Xyz To Uv ( face , p ) ; return from Face IJ ( face , st To IJ ( st . x ( ) ) , st To IJ ( st . y ( ) ) ) ; }
private static S2 Cell Id from Face IJ Wrap ( int face , int i , int j ) { i = Math . max ( - NUM , Math . min ( MAX SIZE , i ) ) ; j = Math . max ( - NUM , Math . min ( MAX SIZE , j ) ) ; final double k Scale = NUM / MAX SIZE ; double s = k Scale * ( ( i << NUM ) + NUM - MAX SIZE ) ; double t = k Scale * ( ( j << NUM ) + NUM - MAX SIZE ) ; S2 Point p = S2 Projections . face Uv To Xyz ( face , s , t ) ; face = S2 Projections . xyz To Face ( p ) ; R2 Vector st = S2 Projections . valid Face Xyz To Uv ( face , p ) ; return from Face IJ ( face , st To IJ ( st . x ( ) ) , st To IJ ( st . y ( ) ) ) ; }
private static String string Of Char ( char ch , int len ) { String Buffer buf = new String Buffer ( ) ; for ( int i = NUM ; i < len ; i ++ ) { buf . append ( ch ) ; } return buf . to String ( ) ; }
public void release Proxy ( ) { Map Mouse Mode mmm = mouse Support . get Proxied ( ) ; if ( mmm != null ) { mouse Support . release Proxy ( ) ; property Change Support . fire Property Change ( Mouse Delegator . Proxy Mouse Mode Property , mmm , null ) ; } }
public static int execute Update ( Connection connection , String raw Sql Query , Object ... parameters ) throws SQL Exception { Prepared Statement stmt = null ; try { stmt = connection . prepare Statement ( raw Sql Query ) ; for ( int index = NUM ; index < parameters . length ; index ++ ) { Jdbc Utils . bind Parameter ( stmt , index + NUM , parameters [ index ] ) ; } return stmt . execute Update ( ) ; } finally { Jdbc Utils . close Statement ( stmt ) ; } }
private String fix Wildcard ( String value ) { if ( value . contains ( STRING ) && ! value . contains ( STRING ) ) { return value . replace ( STRING , STRING ) ; } return value ; }
private String fix Wildcard ( String value ) { if ( value . contains ( STRING ) && ! value . contains ( STRING ) ) { return value . replace ( STRING , STRING ) ; } return value ; }
public void engine Update ( byte [ ] input , int offset , int len ) { if ( offset < NUM || len < NUM || ( long ) offset + len > input . length ) throw new Array Index Out Of Bounds Exception ( ) ; int buffer Ndx = ( int ) ( count % BLOCK LENGTH ) ; count += len ; int part Len = BLOCK LENGTH - buffer Ndx ; int i = NUM ; if ( len >= part Len ) { System . arraycopy ( input , offset , buffer , buffer Ndx , part Len ) ; transform ( buffer , NUM ) ; for ( i = part Len ; i + BLOCK LENGTH - NUM < len ; i += BLOCK LENGTH ) transform ( input , offset + i ) ; buffer Ndx = NUM ; } if ( i < len ) System . arraycopy ( input , offset + i , buffer , buffer Ndx , len - i ) ; }
public static void mark Text ( J Text Component pane , int start , int end , Simple Marker marker ) { try { Highlighter hiliter = pane . get Highlighter ( ) ; int sel Start = pane . get Selection Start ( ) ; int sel End = pane . get Selection End ( ) ; if ( sel Start == sel End || end < sel Start || start > sel Start ) { hiliter . add Highlight ( start , end , marker ) ; return ; } if ( sel Start > start && sel Start < end ) { hiliter . add Highlight ( start , sel Start , marker ) ; } if ( sel End > start && sel End < end ) { hiliter . add Highlight ( sel End , end , marker ) ; } } catch ( Bad Location Exception ex ) { LOG . log ( Level . SEVERE , null , ex ) ; } }
public static byte [ ] read All Limited ( Input Stream in Str , int limit ) throws IO Exception { Byte Array Output Stream buf = new Byte Array Output Stream ( ) ; pipe All Limited ( in Str , limit , buf ) ; return buf . to Byte Array ( ) ; }
public void move To Next Date ( ) { if ( disable Auto Date Selection && user Selected Item == null ) return ; if ( selected Date Item != null ) { Calendar cal = Calendar . get Instance ( ) ; cal . set ( selected Date Item . get Year ( ) , selected Date Item . get Month ( ) , selected Date Item . get Day ( ) ) ; cal . add ( Calendar . DATE , NUM ) ; if ( selected Date Item . get Month ( ) != cal . get ( Calendar . MONTH ) ) { move To Next Month ( ) ; } else { selected Date Item . set Day ( cal . get ( Calendar . DAY OF MONTH ) ) ; selected Date Item . set Month ( cal . get ( Calendar . MONTH ) ) ; selected Date Item . set Year ( cal . get ( Calendar . YEAR ) ) ; month View Pager Adapter . set Selected Item ( selected Date Item ) ; } } }
public void add Transaction ( SIP Server Transaction server Transaction ) throws IO Exception { if ( logger . is Logging Enabled ( Log Writer . TRACE DEBUG ) ) logger . log Debug ( STRING + server Transaction ) ; server Transaction . map ( ) ; add Transaction Hash ( server Transaction ) ; }
public void add Transaction ( SIP Server Transaction server Transaction ) throws IO Exception { if ( logger . is Logging Enabled ( Log Writer . TRACE DEBUG ) ) logger . log Debug ( STRING + server Transaction ) ; server Transaction . map ( ) ; add Transaction Hash ( server Transaction ) ; }
public void add Transaction ( SIP Server Transaction server Transaction ) throws IO Exception { if ( logger . is Logging Enabled ( Log Writer . TRACE DEBUG ) ) logger . log Debug ( STRING + server Transaction ) ; server Transaction . map ( ) ; add Transaction Hash ( server Transaction ) ; }
public void add Transaction ( SIP Server Transaction server Transaction ) throws IO Exception { if ( logger . is Logging Enabled ( Log Writer . TRACE DEBUG ) ) logger . log Debug ( STRING + server Transaction ) ; server Transaction . map ( ) ; add Transaction Hash ( server Transaction ) ; }
public void add Transaction ( SIP Server Transaction server Transaction ) throws IO Exception { if ( logger . is Logging Enabled ( Log Writer . TRACE DEBUG ) ) logger . log Debug ( STRING + server Transaction ) ; server Transaction . map ( ) ; add Transaction Hash ( server Transaction ) ; }
private void init ( ) { System Properties props = System Properties . get Instance ( ) ; Path settings Folder = props . get Application Folder ( STRING ) ; String default Settings File = props . get ( STRING , STRING ) ; String settings File = props . get ( STRING , default Settings File ) ; load ( settings Folder . resolve ( settings File ) ) ; refresh Icons ( ) ; }
@ Override public byte [ ] unwrap ( final byte [ ] incoming , final int offset , final int len ) throws Ldap Exception { final byte [ ] copy = new byte [ len ] ; System . arraycopy ( incoming , offset , copy , NUM , len ) ; return copy ; }
@ Override public byte [ ] unwrap ( final byte [ ] incoming , final int offset , final int len ) throws Ldap Exception { final byte [ ] copy = new byte [ len ] ; System . arraycopy ( incoming , offset , copy , NUM , len ) ; return copy ; }
public static void load Profile ( List < String > json profiles ) throws Lang Detect Exception { int index = NUM ; int langsize = json profiles . size ( ) ; if ( langsize < NUM ) throw new Lang Detect Exception ( Error Code . Need Load Profile Error , STRING ) ; for ( String json : json profiles ) { try { Lang Profile profile = JSON . decode ( json , Lang Profile . class ) ; add Profile ( profile , index , langsize ) ; ++ index ; } catch ( JSON Exception e ) { throw new Lang Detect Exception ( Error Code . Format Error , STRING ) ; } } }
public static Object [ ] put All ( ) { Region region = cache . get Region ( Region . SEPARATOR + REGION NAME ) ; assert Not Null ( region ) ; try { Map map = new Linked Hash Map ( ) ; map . put ( PUTALL KEY 1 , PUTALL VALUE 1 ) ; map . put ( PUTALL KEY 2 , PUTALL VALUE 2 ) ; map . put ( PUTALL KEY 3 , PUTALL VALUE 3 ) ; map . put ( PUTALL KEY 4 , PUTALL VALUE 4 ) ; map . put ( PUTALL KEY 5 , PUTALL VALUE 5 ) ; region . put All ( map , STRING ) ; Event ID [ ] evids = new Event ID [ NUM ] ; evids [ NUM ] = put Allevent Id 1 ; evids [ NUM ] = put Allevent Id 2 ; evids [ NUM ] = put Allevent Id 3 ; evids [ NUM ] = put Allevent Id 4 ; evids [ NUM ] = put Allevent Id 5 ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; return evids ; } catch ( Exception e ) { fail ( STRING + e ) ; } return null ; }
public static Object [ ] put All ( ) { Region region = cache . get Region ( Region . SEPARATOR + REGION NAME ) ; assert Not Null ( region ) ; try { Map map = new Linked Hash Map ( ) ; map . put ( PUTALL KEY 1 , PUTALL VALUE 1 ) ; map . put ( PUTALL KEY 2 , PUTALL VALUE 2 ) ; map . put ( PUTALL KEY 3 , PUTALL VALUE 3 ) ; map . put ( PUTALL KEY 4 , PUTALL VALUE 4 ) ; map . put ( PUTALL KEY 5 , PUTALL VALUE 5 ) ; region . put All ( map , STRING ) ; Event ID [ ] evids = new Event ID [ NUM ] ; evids [ NUM ] = put Allevent Id 1 ; evids [ NUM ] = put Allevent Id 2 ; evids [ NUM ] = put Allevent Id 3 ; evids [ NUM ] = put Allevent Id 4 ; evids [ NUM ] = put Allevent Id 5 ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; return evids ; } catch ( Exception e ) { fail ( STRING + e ) ; } return null ; }
@ Override public void remove Test Set Listener ( Test Set Listener tsl ) { m test Set Listeners . remove Element ( tsl ) ; }
public static String clean Non Terminal ( String nt ) { if ( is Nonterminal ( nt ) ) { if ( is Indexed Non Terminal ( nt ) ) { return nt . substring ( NUM , nt . index Of ( INDEX SEPARATOR ) ) ; } return nt . substring ( NUM , nt . length ( ) - NUM ) ; } return nt ; }
public static String clean Non Terminal ( String nt ) { if ( is Nonterminal ( nt ) ) { if ( is Indexed Non Terminal ( nt ) ) { return nt . substring ( NUM , nt . index Of ( INDEX SEPARATOR ) ) ; } return nt . substring ( NUM , nt . length ( ) - NUM ) ; } return nt ; }
public static String clean Non Terminal ( String nt ) { if ( is Nonterminal ( nt ) ) { if ( is Indexed Non Terminal ( nt ) ) { return nt . substring ( NUM , nt . index Of ( INDEX SEPARATOR ) ) ; } return nt . substring ( NUM , nt . length ( ) - NUM ) ; } return nt ; }
public Env Var Model ( Environment Manager Interface env Mgr ) { this . env Mgr = env Mgr ; if ( columns . is Empty ( ) ) { columns . add ( Localisation . get String ( Env Var Dlg . class , STRING ) ) ; columns . add ( Localisation . get String ( Env Var Dlg . class , STRING ) ) ; columns . add ( Localisation . get String ( Env Var Dlg . class , STRING ) ) ; } }
public int compare To ( Char Buffer other Buffer ) { int compare Remaining = ( remaining ( ) < other Buffer . remaining ( ) ) ? remaining ( ) : other Buffer . remaining ( ) ; int this Pos = position ; int other Pos = other Buffer . position ; char this Byte , other Byte ; while ( compare Remaining > NUM ) { this Byte = get ( this Pos ) ; other Byte = other Buffer . get ( other Pos ) ; if ( this Byte != other Byte ) { return this Byte < other Byte ? - NUM : NUM ; } this Pos ++ ; other Pos ++ ; compare Remaining -- ; } return remaining ( ) - other Buffer . remaining ( ) ; }
public static boolean clear If Not Modified ( Http Servlet Request request , Http Servlet Response response , Collection < ? extends Identifiable Object > objects ) { String tag = QUOTE + Identifiable Object Utils . get Last Updated Tag ( objects ) + QUOTE ; response . set Header ( HEADER ETAG , tag ) ; String input Tag = request . get Header ( HEADER IF NONE MATCH ) ; if ( objects != null && input Tag != null && input Tag . equals ( tag ) ) { response . set Status ( Http Servlet Response . SC NOT MODIFIED ) ; objects . clear ( ) ; return BOOL ; } return BOOL ; }
public static boolean clear If Not Modified ( Http Servlet Request request , Http Servlet Response response , Collection < ? extends Identifiable Object > objects ) { String tag = QUOTE + Identifiable Object Utils . get Last Updated Tag ( objects ) + QUOTE ; response . set Header ( HEADER ETAG , tag ) ; String input Tag = request . get Header ( HEADER IF NONE MATCH ) ; if ( objects != null && input Tag != null && input Tag . equals ( tag ) ) { response . set Status ( Http Servlet Response . SC NOT MODIFIED ) ; objects . clear ( ) ; return BOOL ; } return BOOL ; }
public static boolean clear If Not Modified ( Http Servlet Request request , Http Servlet Response response , Collection < ? extends Identifiable Object > objects ) { String tag = QUOTE + Identifiable Object Utils . get Last Updated Tag ( objects ) + QUOTE ; response . set Header ( HEADER ETAG , tag ) ; String input Tag = request . get Header ( HEADER IF NONE MATCH ) ; if ( objects != null && input Tag != null && input Tag . equals ( tag ) ) { response . set Status ( Http Servlet Response . SC NOT MODIFIED ) ; objects . clear ( ) ; return BOOL ; } return BOOL ; }
public static boolean clear If Not Modified ( Http Servlet Request request , Http Servlet Response response , Collection < ? extends Identifiable Object > objects ) { String tag = QUOTE + Identifiable Object Utils . get Last Updated Tag ( objects ) + QUOTE ; response . set Header ( HEADER ETAG , tag ) ; String input Tag = request . get Header ( HEADER IF NONE MATCH ) ; if ( objects != null && input Tag != null && input Tag . equals ( tag ) ) { response . set Status ( Http Servlet Response . SC NOT MODIFIED ) ; objects . clear ( ) ; return BOOL ; } return BOOL ; }
public static boolean clear If Not Modified ( Http Servlet Request request , Http Servlet Response response , Collection < ? extends Identifiable Object > objects ) { String tag = QUOTE + Identifiable Object Utils . get Last Updated Tag ( objects ) + QUOTE ; response . set Header ( HEADER ETAG , tag ) ; String input Tag = request . get Header ( HEADER IF NONE MATCH ) ; if ( objects != null && input Tag != null && input Tag . equals ( tag ) ) { response . set Status ( Http Servlet Response . SC NOT MODIFIED ) ; objects . clear ( ) ; return BOOL ; } return BOOL ; }
public static boolean clear If Not Modified ( Http Servlet Request request , Http Servlet Response response , Collection < ? extends Identifiable Object > objects ) { String tag = QUOTE + Identifiable Object Utils . get Last Updated Tag ( objects ) + QUOTE ; response . set Header ( HEADER ETAG , tag ) ; String input Tag = request . get Header ( HEADER IF NONE MATCH ) ; if ( objects != null && input Tag != null && input Tag . equals ( tag ) ) { response . set Status ( Http Servlet Response . SC NOT MODIFIED ) ; objects . clear ( ) ; return BOOL ; } return BOOL ; }
public static boolean clear If Not Modified ( Http Servlet Request request , Http Servlet Response response , Collection < ? extends Identifiable Object > objects ) { String tag = QUOTE + Identifiable Object Utils . get Last Updated Tag ( objects ) + QUOTE ; response . set Header ( HEADER ETAG , tag ) ; String input Tag = request . get Header ( HEADER IF NONE MATCH ) ; if ( objects != null && input Tag != null && input Tag . equals ( tag ) ) { response . set Status ( Http Servlet Response . SC NOT MODIFIED ) ; objects . clear ( ) ; return BOOL ; } return BOOL ; }
public static boolean clear If Not Modified ( Http Servlet Request request , Http Servlet Response response , Collection < ? extends Identifiable Object > objects ) { String tag = QUOTE + Identifiable Object Utils . get Last Updated Tag ( objects ) + QUOTE ; response . set Header ( HEADER ETAG , tag ) ; String input Tag = request . get Header ( HEADER IF NONE MATCH ) ; if ( objects != null && input Tag != null && input Tag . equals ( tag ) ) { response . set Status ( Http Servlet Response . SC NOT MODIFIED ) ; objects . clear ( ) ; return BOOL ; } return BOOL ; }
public static boolean clear If Not Modified ( Http Servlet Request request , Http Servlet Response response , Collection < ? extends Identifiable Object > objects ) { String tag = QUOTE + Identifiable Object Utils . get Last Updated Tag ( objects ) + QUOTE ; response . set Header ( HEADER ETAG , tag ) ; String input Tag = request . get Header ( HEADER IF NONE MATCH ) ; if ( objects != null && input Tag != null && input Tag . equals ( tag ) ) { response . set Status ( Http Servlet Response . SC NOT MODIFIED ) ; objects . clear ( ) ; return BOOL ; } return BOOL ; }
public static boolean clear If Not Modified ( Http Servlet Request request , Http Servlet Response response , Collection < ? extends Identifiable Object > objects ) { String tag = QUOTE + Identifiable Object Utils . get Last Updated Tag ( objects ) + QUOTE ; response . set Header ( HEADER ETAG , tag ) ; String input Tag = request . get Header ( HEADER IF NONE MATCH ) ; if ( objects != null && input Tag != null && input Tag . equals ( tag ) ) { response . set Status ( Http Servlet Response . SC NOT MODIFIED ) ; objects . clear ( ) ; return BOOL ; } return BOOL ; }
public static boolean clear If Not Modified ( Http Servlet Request request , Http Servlet Response response , Collection < ? extends Identifiable Object > objects ) { String tag = QUOTE + Identifiable Object Utils . get Last Updated Tag ( objects ) + QUOTE ; response . set Header ( HEADER ETAG , tag ) ; String input Tag = request . get Header ( HEADER IF NONE MATCH ) ; if ( objects != null && input Tag != null && input Tag . equals ( tag ) ) { response . set Status ( Http Servlet Response . SC NOT MODIFIED ) ; objects . clear ( ) ; return BOOL ; } return BOOL ; }
public static boolean clear If Not Modified ( Http Servlet Request request , Http Servlet Response response , Collection < ? extends Identifiable Object > objects ) { String tag = QUOTE + Identifiable Object Utils . get Last Updated Tag ( objects ) + QUOTE ; response . set Header ( HEADER ETAG , tag ) ; String input Tag = request . get Header ( HEADER IF NONE MATCH ) ; if ( objects != null && input Tag != null && input Tag . equals ( tag ) ) { response . set Status ( Http Servlet Response . SC NOT MODIFIED ) ; objects . clear ( ) ; return BOOL ; } return BOOL ; }
public static void check Directory Is Writeable ( @ Not Null File directory ) throws IO Exception { while ( ! directory . exists ( ) || ! directory . is Directory ( ) ) { directory = directory . get Parent File ( ) ; } if ( ! directory . can Write ( ) ) { throw new IO Exception ( STRING + directory . get Absolute Path ( ) ) ; } }
private Byte Buffer write String ( Charset Encoder encoder , String next , int i , int no Of Values ) throws Character Coding Exception { Byte Buffer bb ; if ( ( i + NUM ) == no Of Values ) { bb = encoder . encode ( Char Buffer . wrap ( next ) ) ; } else { bb = encoder . encode ( Char Buffer . wrap ( next + STRING ) ) ; } bb . rewind ( ) ; return bb ; }
private Byte Buffer write String ( Charset Encoder encoder , String next , int i , int no Of Values ) throws Character Coding Exception { Byte Buffer bb ; if ( ( i + NUM ) == no Of Values ) { bb = encoder . encode ( Char Buffer . wrap ( next ) ) ; } else { bb = encoder . encode ( Char Buffer . wrap ( next + STRING ) ) ; } bb . rewind ( ) ; return bb ; }
private Byte Buffer write String ( Charset Encoder encoder , String next , int i , int no Of Values ) throws Character Coding Exception { Byte Buffer bb ; if ( ( i + NUM ) == no Of Values ) { bb = encoder . encode ( Char Buffer . wrap ( next ) ) ; } else { bb = encoder . encode ( Char Buffer . wrap ( next + STRING ) ) ; } bb . rewind ( ) ; return bb ; }
private Byte Buffer write String ( Charset Encoder encoder , String next , int i , int no Of Values ) throws Character Coding Exception { Byte Buffer bb ; if ( ( i + NUM ) == no Of Values ) { bb = encoder . encode ( Char Buffer . wrap ( next ) ) ; } else { bb = encoder . encode ( Char Buffer . wrap ( next + STRING ) ) ; } bb . rewind ( ) ; return bb ; }
public void remove Group Properties Listener ( Group Properties Listener group Properties Listener ) { group Properties Listeners . remove ( group Properties Listener ) ; }
protected void reopen ( ) throws IO Exception { if ( input Stream != null ) { Debug . message ( STRING , STRING ) ; input Stream . close ( ) ; } input Stream Count = NUM ; }
protected void reopen ( ) throws IO Exception { if ( input Stream != null ) { Debug . message ( STRING , STRING ) ; input Stream . close ( ) ; } input Stream Count = NUM ; }
protected void reopen ( ) throws IO Exception { if ( input Stream != null ) { Debug . message ( STRING , STRING ) ; input Stream . close ( ) ; } input Stream Count = NUM ; }
protected void reopen ( ) throws IO Exception { if ( input Stream != null ) { Debug . message ( STRING , STRING ) ; input Stream . close ( ) ; } input Stream Count = NUM ; }
public abstract void init Parameters ( int [ ] a Circuit Data , I Redstone Circuit Block a Redstone Circuit Block ) ;
public abstract void init Parameters ( int [ ] a Circuit Data , I Redstone Circuit Block a Redstone Circuit Block ) ;
protected void handle Element Deleted ( I Editor Input file Editor Input ) { fire Element Deleted ( file Editor Input ) ; }
public Vector 3 round ( ) { x = Math . round ( x ) ; y = Math . round ( y ) ; z = Math . round ( z ) ; return this ; }
@ Override public boolean on Options Item Selected ( Menu Item item ) { switch ( item . get Item Id ( ) ) { case MENU SETTINGS ID : start Activity ( new Intent ( this , Activity Settings . class ) ) ; return BOOL ; case MENU ABOUT ID : show About ( ) ; return BOOL ; } return super . on Options Item Selected ( item ) ; }
public int compare To ( Association Rule other ) { return - Double . compare ( get Primary Metric Value ( ) , other . get Primary Metric Value ( ) ) ; }
public int compare To ( Association Rule other ) { return - Double . compare ( get Primary Metric Value ( ) , other . get Primary Metric Value ( ) ) ; }
private Set < String > find Resource Names ( String path , String prefix , String suffix ) throws IO Exception { Set < String > resource Names = find Resource Names From File System ( path , new File ( path ) ) ; return filter Resource Names ( resource Names , prefix , suffix ) ; }
public Network Selection Event ( final Network Panel source , final Set < P Node > old Selection , final Set < P Node > selection ) { super ( source ) ; this . old Selection = Collections . unmodifiable Set ( old Selection ) ; this . selection = Collections . unmodifiable Set ( selection ) ; }
public Network Selection Event ( final Network Panel source , final Set < P Node > old Selection , final Set < P Node > selection ) { super ( source ) ; this . old Selection = Collections . unmodifiable Set ( old Selection ) ; this . selection = Collections . unmodifiable Set ( selection ) ; }
private static LDAP Filter create AND Filter ( Filter Set filter Set ) throws LDAP Exception , IO Exception { List < JAXB Element < ? > > list = filter Set . get Filter Group ( ) ; Array List < Raw Filter > filters = new Array List < > ( list . size ( ) ) ; for ( JAXB Element < ? > filter : list ) { filters . add ( create Filter ( filter ) ) ; } return LDAP Filter . create AND Filter ( filters ) ; }
public static boolean is Module Polyfill ( Qualified Name name ) { if ( name == null || name . get Segment Count ( ) < NUM ) return BOOL ; return MODULE POLYFILL SEGMENT . equals ( name . get Segment ( NUM ) ) ; }
public static boolean is Module Polyfill ( Qualified Name name ) { if ( name == null || name . get Segment Count ( ) < NUM ) return BOOL ; return MODULE POLYFILL SEGMENT . equals ( name . get Segment ( NUM ) ) ; }
void init ( List < Column Meta Data > column Meta Data ) { this . column Meta Data = column Meta Data ; column Roles . clear ( ) ; column Names . clear ( ) ; int column Index = NUM ; for ( Column Meta Data column : column Meta Data ) { add Column To Columns Maps ( column Index , column ) ; if ( ! column . is Removed ( ) ) { selected Columns . add ( column Index ) ; } column Index ++ ; } check For Duplicates ( ) ; }
void init ( List < Column Meta Data > column Meta Data ) { this . column Meta Data = column Meta Data ; column Roles . clear ( ) ; column Names . clear ( ) ; int column Index = NUM ; for ( Column Meta Data column : column Meta Data ) { add Column To Columns Maps ( column Index , column ) ; if ( ! column . is Removed ( ) ) { selected Columns . add ( column Index ) ; } column Index ++ ; } check For Duplicates ( ) ; }
public void add Graph ( Graph g ) { graphs . add ( g ) ; }
private static String [ ] split Type Arguments ( final String nested Types ) { String Builder string = new String Builder ( nested Types . replace All ( STRING , STRING ) ) ; List < String > arguments = new Array List < String > ( ) ; while ( string . length ( ) > NUM ) { int next Comma = string . index Of ( STRING ) ; int next Open = string . index Of ( STRING ) ; if ( next Comma == - NUM ) { arguments . add ( string . to String ( ) ) ; string . set Length ( NUM ) ; } else if ( next Open == - NUM || next Comma < next Open ) { arguments . add ( string . substring ( NUM , next Comma ) ) ; string . replace ( NUM , next Comma + NUM , STRING ) ; } else { int depth = NUM ; int index = next Open ; while ( depth > NUM && index < string . length ( ) - NUM ) { char next Char = string . char At ( ++ index ) ; if ( STRING == next Char ) { ++ depth ; } else if ( STRING == next Char ) { -- depth ; } } arguments . add ( string . substring ( NUM , index + NUM ) ) ; string . replace ( NUM , index + NUM , STRING ) ; } } return arguments . to Array ( new String [ arguments . size ( ) ] ) ; }
public static void copy String ( Reader source , Output Stream target ) throws IO Exception { char [ ] buff = new char [ Constants . IO BUFFER SIZE ] ; Data d = new Data ( null , new byte [ NUM * Constants . IO BUFFER SIZE ] ) ; while ( BOOL ) { int l = source . read ( buff ) ; if ( l < NUM ) { break ; } d . write String Without Length ( buff , l ) ; target . write ( d . data , NUM , d . pos ) ; d . reset ( ) ; } }
protected Slice read Next ( File System WAL . File System WAL Reader reader ) { try { return reader . next ( ) ; } catch ( IO Exception ex ) { try { reader . close ( ) ; } catch ( IO Exception ioe ) { } return null ; } }
protected Slice read Next ( File System WAL . File System WAL Reader reader ) { try { return reader . next ( ) ; } catch ( IO Exception ex ) { try { reader . close ( ) ; } catch ( IO Exception ioe ) { } return null ; } }
Scheduled Future Task ( Runnable r , V result , long ns ) { super ( r , result ) ; this . time = ns ; this . period = NUM ; this . sequence Number = sequencer . get And Increment ( ) ; }
Scheduled Future Task ( Runnable r , V result , long ns ) { super ( r , result ) ; this . time = ns ; this . period = NUM ; this . sequence Number = sequencer . get And Increment ( ) ; }
public void remove Child At ( int index ) { if ( ( index < NUM ) || ( children == null ) || ( index >= children . size ( ) ) ) { throw new Array Index Out Of Bounds Exception ( ) ; } Element child = ( Element ) children . get ( index ) ; child . set Parent ( null ) ; children . remove ( index ) ; }
public static int parse RGB ( FXG Node node , String value , String name ) { Matcher m ; m = rgb Pattern . matcher ( value ) ; if ( ! m . matches ( ) ) { throw new FXG Exception ( node . get Start Line ( ) , node . get Start Column ( ) , STRING , name , value ) ; } value = value . substring ( NUM ) ; int a = NUM ; int r = Integer . parse Int ( value . substring ( NUM , NUM ) , NUM ) & NUM ; int g = Integer . parse Int ( value . substring ( NUM , NUM ) , NUM ) & NUM ; int b = Integer . parse Int ( value . substring ( NUM , NUM ) , NUM ) & NUM ; return ( a << NUM ) | ( r << NUM ) | ( g << NUM ) | b ; }
public Inference Context ( N4 JS Type System ts , Type System Helper tsh , Cancel Indicator cancel Indicator , Rule Environment G , Inference Variable ... inference Variables ) { Objects . require Non Null ( ts ) ; Objects . require Non Null ( tsh ) ; Objects . require Non Null ( cancel Indicator ) ; Objects . require Non Null ( G ) ; this . ts = ts ; this . tsh = tsh ; this . cancel Indicator = cancel Indicator ; this . G = G ; add Inference Variables ( BOOL , inference Variables ) ; this . reducer = new Reducer ( this , G , ts , tsh ) ; this . current Bounds = new Bound Set ( this , G , ts ) ; }
private void offer ( Blocking Queue < Task > queue , Task task ) throws Queue Timeout Exception { try { debug ( STRING , task . to String ( ) ) ; if ( ! queue . offer ( wrap ( task ) , configuration . get Queue Timeout ( ) , Time Unit . SECONDS ) ) { throw new Queue Timeout Exception ( task ) ; } } catch ( Interrupted Exception e ) { throw new Queue Timeout Exception ( task , e ) ; } }
public Simple Cache ( String id , String file , long expire Time ) { this . id = id ; this . file = Paths . get ( file ) ; this . expire Time = expire Time ; }
private E create Using Static Create Method ( ) throws Checked Analysis Exception { Method create Method ; try { create Method = database Class . get Method ( STRING , new Class [ NUM ] ) ; } catch ( No Such Method Exception e ) { return null ; } if ( ! Modifier . is Static ( create Method . get Modifiers ( ) ) ) { return null ; } if ( create Method . get Return Type ( ) != database Class ) { return null ; } try { return database Class . cast ( create Method . invoke ( null , new Object [ NUM ] ) ) ; } catch ( Invocation Target Exception e ) { throw new Checked Analysis Exception ( STRING + database Class . get Name ( ) , e ) ; } catch ( Illegal Access Exception e ) { throw new Checked Analysis Exception ( STRING + database Class . get Name ( ) , e ) ; } }
private E create Using Static Create Method ( ) throws Checked Analysis Exception { Method create Method ; try { create Method = database Class . get Method ( STRING , new Class [ NUM ] ) ; } catch ( No Such Method Exception e ) { return null ; } if ( ! Modifier . is Static ( create Method . get Modifiers ( ) ) ) { return null ; } if ( create Method . get Return Type ( ) != database Class ) { return null ; } try { return database Class . cast ( create Method . invoke ( null , new Object [ NUM ] ) ) ; } catch ( Invocation Target Exception e ) { throw new Checked Analysis Exception ( STRING + database Class . get Name ( ) , e ) ; } catch ( Illegal Access Exception e ) { throw new Checked Analysis Exception ( STRING + database Class . get Name ( ) , e ) ; } }
private E create Using Static Create Method ( ) throws Checked Analysis Exception { Method create Method ; try { create Method = database Class . get Method ( STRING , new Class [ NUM ] ) ; } catch ( No Such Method Exception e ) { return null ; } if ( ! Modifier . is Static ( create Method . get Modifiers ( ) ) ) { return null ; } if ( create Method . get Return Type ( ) != database Class ) { return null ; } try { return database Class . cast ( create Method . invoke ( null , new Object [ NUM ] ) ) ; } catch ( Invocation Target Exception e ) { throw new Checked Analysis Exception ( STRING + database Class . get Name ( ) , e ) ; } catch ( Illegal Access Exception e ) { throw new Checked Analysis Exception ( STRING + database Class . get Name ( ) , e ) ; } }
public Chat Activity Builder add Email ( String email ) { emails . add ( email ) ; return this ; }
public Chat Activity Builder add Email ( String email ) { emails . add ( email ) ; return this ; }
public void notify Data Changed ( ) { init ( m Data Sets ) ; }
public void notify Data Changed ( ) { init ( m Data Sets ) ; }
public void notify Data Changed ( ) { init ( m Data Sets ) ; }
private void parse Quoted Spans ( Span Manager sm , Span s , List < Span > quoted Spans , String quotation ) { final int qlen = quotation . length ( ) ; int start = sm . index Of ( quotation , s . get Start ( ) , s . get End ( ) ) ; while ( start != - NUM ) { int end = sm . index Of ( quotation , start + qlen , s . get End ( ) ) ; if ( end == - NUM ) { break ; } Span qs = new Span ( start , end ) ; quoted Spans . add ( qs ) ; if ( calculate Src Spans ) { qs . set Src Span ( new Src Span ( sm . get Src Pos ( start ) , sm . get Src Pos ( end + qlen - NUM ) + NUM ) ) ; } sm . delete ( end , end + qlen ) ; sm . delete ( start , start + qlen ) ; start = sm . index Of ( quotation , qs . get End ( ) , s . get End ( ) ) ; } }
@ Override public synchronized void add Data Source Listener ( Data Source Listener dsl ) { m data Listeners . add Element ( dsl ) ; }
public void skip ( ) { signature = signature . substring ( NUM ) ; }
String capitalise ( String s ) { if ( s . length ( ) == NUM ) { return s ; } String Buffer s1 = new String Buffer ( s ) ; if ( Character . is Lower Case ( s1 . char At ( NUM ) ) ) { s1 . set Char At ( NUM , Character . to Upper Case ( s1 . char At ( NUM ) ) ) ; } for ( int j = NUM ; j < s1 . length ( ) ; j ++ ) { if ( Character . is Upper Case ( s1 . char At ( j ) ) ) { s1 . set Char At ( j , Character . to Lower Case ( s1 . char At ( j ) ) ) ; } } return s1 . to String ( ) ; }
public static void save As Gnu Step ASCII ( NS Dictionary root , File out ) throws IO Exception { File parent = out . get Parent File ( ) ; if ( ! parent . exists ( ) ) if ( ! parent . mkdirs ( ) ) throw new IO Exception ( STRING ) ; Output Stream Writer w = new Output Stream Writer ( new File Output Stream ( out ) , STRING ) ; w . write ( root . to Gnu Step ASCII Property List ( ) ) ; w . close ( ) ; }
protected boolean remove Positionable Point ( Positionable Point o ) { if ( o . get Connect 1 ( ) != null || o . get Connect 2 ( ) != null ) { if ( ! no Warn Positionable Point ) { int selected Value = J Option Pane . show Option Dialog ( this , rb . get String ( STRING ) , Bundle . get Message ( STRING ) , J Option Pane . YES NO CANCEL OPTION , J Option Pane . QUESTION MESSAGE , null , new Object [ ] { Bundle . get Message ( STRING ) , Bundle . get Message ( STRING ) , rb . get String ( STRING ) } , Bundle . get Message ( STRING ) ) ; if ( selected Value == NUM ) { return ( BOOL ) ; } if ( selected Value == NUM ) { no Warn Positionable Point = BOOL ; } } if ( selected Object == o ) { selected Object = null ; } if ( prev Selected Object == o ) { prev Selected Object = null ; } Track Segment t = o . get Connect 1 ( ) ; if ( t != null ) { remove Track Segment ( t ) ; } t = o . get Connect 2 ( ) ; if ( t != null ) { remove Track Segment ( t ) ; } } for ( int i = NUM ; i < point List . size ( ) ; i ++ ) { Positionable Point p = point List . get ( i ) ; if ( p == o ) { point List . remove ( i ) ; set Dirty ( BOOL ) ; repaint ( ) ; return ( BOOL ) ; } } return ( BOOL ) ; }
public Geo Point create Surface Point ( final double x , final double y , final double z ) { final double t = Math . sqrt ( NUM / ( x * x * inverse Ab Squared + y * y * inverse Ab Squared + z * z * inverse C Squared ) ) ; return new Geo Point ( t * x , t * y , t * z ) ; }
protected float calculate Defense ( final RP Entity entity ) { float potential ; float min ; float score ; final float armor = entity . get Item Def ( ) + NUM ; final int def = entity . get Def ( ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + def + STRING + armor ) ; } potential = ( ( float ) Level . get Wisdom ( def ) ) * NUM * armor ; min = ( float ) Level . get Wisdom ( entity . get Level ( ) ) * NUM ; score = ( ( rand . next Float ( ) * ( NUM - min ) ) + min ) * potential ; score += ( ( float ) entity . use Karma ( NUM ) * potential ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + potential + STRING + score ) ; } return score ; }
public Section read Next Section ( String title To Look For ) throws IO Exception { String title = null ; String Builder key Builder = null ; while ( BOOL ) { String line = reader . read Line ( ) ; if ( line == null ) { Preconditions . check Argument ( title == null , STRING , title ) ; return null ; } if ( key Builder == null ) { Matcher m = BEGIN PATTERN . matcher ( line ) ; if ( m . matches ( ) ) { String cur Title = m . group ( NUM ) ; if ( title To Look For == null || cur Title . equals ( title To Look For ) ) { key Builder = new String Builder ( ) ; title = cur Title ; } } } else { Matcher m = END PATTERN . matcher ( line ) ; if ( m . matches ( ) ) { String end Title = m . group ( NUM ) ; Preconditions . check Argument ( end Title . equals ( title ) , STRING , end Title , title ) ; return new Section ( title , Base 64 . decode Base 64 ( key Builder . to String ( ) ) ) ; } key Builder . append ( line ) ; } } }
public Section read Next Section ( String title To Look For ) throws IO Exception { String title = null ; String Builder key Builder = null ; while ( BOOL ) { String line = reader . read Line ( ) ; if ( line == null ) { Preconditions . check Argument ( title == null , STRING , title ) ; return null ; } if ( key Builder == null ) { Matcher m = BEGIN PATTERN . matcher ( line ) ; if ( m . matches ( ) ) { String cur Title = m . group ( NUM ) ; if ( title To Look For == null || cur Title . equals ( title To Look For ) ) { key Builder = new String Builder ( ) ; title = cur Title ; } } } else { Matcher m = END PATTERN . matcher ( line ) ; if ( m . matches ( ) ) { String end Title = m . group ( NUM ) ; Preconditions . check Argument ( end Title . equals ( title ) , STRING , end Title , title ) ; return new Section ( title , Base 64 . decode Base 64 ( key Builder . to String ( ) ) ) ; } key Builder . append ( line ) ; } } }
private List < Entry > reduce With Douglas Peuker ( List < Entry > entries , double epsilon ) { if ( epsilon <= NUM || entries . size ( ) < NUM ) { return entries ; } keep [ NUM ] = BOOL ; keep [ entries . size ( ) - NUM ] = BOOL ; algorithm Douglas Peucker ( entries , epsilon , NUM , entries . size ( ) - NUM ) ; List < Entry > reduced Entries = new Array List < Entry > ( ) ; for ( int i = NUM ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { Entry cur Entry = entries . get ( i ) ; reduced Entries . add ( new Entry ( cur Entry . get Val ( ) , cur Entry . get X Index ( ) ) ) ; } } return reduced Entries ; }
private List < Entry > reduce With Douglas Peuker ( List < Entry > entries , double epsilon ) { if ( epsilon <= NUM || entries . size ( ) < NUM ) { return entries ; } keep [ NUM ] = BOOL ; keep [ entries . size ( ) - NUM ] = BOOL ; algorithm Douglas Peucker ( entries , epsilon , NUM , entries . size ( ) - NUM ) ; List < Entry > reduced Entries = new Array List < Entry > ( ) ; for ( int i = NUM ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { Entry cur Entry = entries . get ( i ) ; reduced Entries . add ( new Entry ( cur Entry . get Val ( ) , cur Entry . get X Index ( ) ) ) ; } } return reduced Entries ; }
public static synchronized void inject Pools ( Executor Service global Thread Pool , Scheduled Executor Service scheduled Thread Pool ) { if ( global Thread Pool == null || scheduled Thread Pool == null ) throw new Illegal Argument Exception ( STRING ) ; clear Thread Pools ( ) ; Active MQ Client . global Thread Pool = global Thread Pool ; Active MQ Client . global Scheduled Thread Pool = scheduled Thread Pool ; injected Pools = BOOL ; }
public static synchronized void inject Pools ( Executor Service global Thread Pool , Scheduled Executor Service scheduled Thread Pool ) { if ( global Thread Pool == null || scheduled Thread Pool == null ) throw new Illegal Argument Exception ( STRING ) ; clear Thread Pools ( ) ; Active MQ Client . global Thread Pool = global Thread Pool ; Active MQ Client . global Scheduled Thread Pool = scheduled Thread Pool ; injected Pools = BOOL ; }
public static synchronized void inject Pools ( Executor Service global Thread Pool , Scheduled Executor Service scheduled Thread Pool ) { if ( global Thread Pool == null || scheduled Thread Pool == null ) throw new Illegal Argument Exception ( STRING ) ; clear Thread Pools ( ) ; Active MQ Client . global Thread Pool = global Thread Pool ; Active MQ Client . global Scheduled Thread Pool = scheduled Thread Pool ; injected Pools = BOOL ; }
public Angel Font Visual Panel 1 ( ) { init Components ( ) ; Graphics Environment ge = Graphics Environment . get Local Graphics Environment ( ) ; String [ ] font Names = ge . get Available Font Family Names ( ) ; j List 1 . set List Data ( font Names ) ; }
public static String block ( Stream < String > rows ) { return block ( rows . collect ( joining ( nl ( ) ) ) ) ; }
void apply CSS ( HTML Element document , HTML Component html C , Vector external CSS , Vector embedded CSS ) { int external Size = NUM ; int embedded Size = NUM ; if ( external CSS != null ) { external Size = external CSS . size ( ) ; } if ( embedded CSS != null ) { embedded Size = embedded CSS . size ( ) ; } if ( external Size + embedded Size == NUM ) { apply Style Attribute Recursive ( document , html C ) ; } else { CSS Element [ ] css = new CSS Element [ external Size + embedded Size ] ; for ( int i = NUM ; i < external Size ; i ++ ) { css [ i ] = ( CSS Element ) external CSS . element At ( i ) ; } for ( int i = NUM ; i < embedded Size ; i ++ ) { css [ i + external Size ] = ( CSS Element ) embedded CSS . element At ( i ) ; } css = sort Selectors By Specificity ( css ) ; apply CSS ( document , html C , css , null , null ) ; } }
void apply CSS ( HTML Element document , HTML Component html C , Vector external CSS , Vector embedded CSS ) { int external Size = NUM ; int embedded Size = NUM ; if ( external CSS != null ) { external Size = external CSS . size ( ) ; } if ( embedded CSS != null ) { embedded Size = embedded CSS . size ( ) ; } if ( external Size + embedded Size == NUM ) { apply Style Attribute Recursive ( document , html C ) ; } else { CSS Element [ ] css = new CSS Element [ external Size + embedded Size ] ; for ( int i = NUM ; i < external Size ; i ++ ) { css [ i ] = ( CSS Element ) external CSS . element At ( i ) ; } for ( int i = NUM ; i < embedded Size ; i ++ ) { css [ i + external Size ] = ( CSS Element ) embedded CSS . element At ( i ) ; } css = sort Selectors By Specificity ( css ) ; apply CSS ( document , html C , css , null , null ) ; } }
void apply CSS ( HTML Element document , HTML Component html C , Vector external CSS , Vector embedded CSS ) { int external Size = NUM ; int embedded Size = NUM ; if ( external CSS != null ) { external Size = external CSS . size ( ) ; } if ( embedded CSS != null ) { embedded Size = embedded CSS . size ( ) ; } if ( external Size + embedded Size == NUM ) { apply Style Attribute Recursive ( document , html C ) ; } else { CSS Element [ ] css = new CSS Element [ external Size + embedded Size ] ; for ( int i = NUM ; i < external Size ; i ++ ) { css [ i ] = ( CSS Element ) external CSS . element At ( i ) ; } for ( int i = NUM ; i < embedded Size ; i ++ ) { css [ i + external Size ] = ( CSS Element ) embedded CSS . element At ( i ) ; } css = sort Selectors By Specificity ( css ) ; apply CSS ( document , html C , css , null , null ) ; } }
public void close ( ) throws IO Exception { Datagram Socket s = s ; s = null ; Output Stream os = os ; os = null ; Input Stream is = is ; is = null ; try { if ( os != null ) os . close ( ) ; if ( is != null ) is . close ( ) ; } finally { if ( s != null ) s . close ( ) ; } }
public JC Diagnostic mandatory Warning ( Lint Category lc , Diagnostic Source source , Diagnostic Position pos , String key , Object ... args ) { return create ( WARNING , lc , Enum Set . of ( Diagnostic Flag . MANDATORY ) , source , pos , key , args ) ; }
public Executor with Checkpoint File ( File checkpoint File ) { this . checkpoint File = checkpoint File ; return this ; }
public Executor with Checkpoint File ( File checkpoint File ) { this . checkpoint File = checkpoint File ; return this ; }
public Executor with Checkpoint File ( File checkpoint File ) { this . checkpoint File = checkpoint File ; return this ; }
public void start ( ) { start = System . current Time Millis ( ) ; }
public Solr Query add Sort ( Sort Clause sort Clause ) { if ( sort Clauses == null ) sort Clauses = new Array List < > ( ) ; sort Clauses . add ( sort Clause ) ; serialize Sorts ( ) ; return this ; }
public void send Message ( String body , String formatted Body , String format ) { if ( ! Text Utils . is Empty ( body ) ) { if ( ! Slash Comands Parser . manage Splash Command ( this , m Session , m Room , body , formatted Body , format ) ) { cancel Selection Mode ( ) ; m Vector Message List Fragment . send Text Message ( body , formatted Body , format ) ; } } }
public boolean contains Attr Value ( String attr Name , String attr Value ) { if ( attr Set != null ) { Set attr = ( Set ) attr Set . get ( attr Name ) ; if ( attr != null ) { return ( attr . contains ( attr Value ) ) ; } } return ( BOOL ) ; }
public boolean contains Attr Value ( String attr Name , String attr Value ) { if ( attr Set != null ) { Set attr = ( Set ) attr Set . get ( attr Name ) ; if ( attr != null ) { return ( attr . contains ( attr Value ) ) ; } } return ( BOOL ) ; }
@ Override public void update State ( X509 Certificate cert ) throws Certificate Exception , IO Exception , Cert Path Validator Exception { if ( cert == null ) return ; X509 Cert Impl icert = X509 Cert Impl . to Impl ( cert ) ; if ( PKIX . is DSA Public Key Without Params ( icert . get Public Key ( ) ) ) { key Params Needed Flag = BOOL ; } this . cert = icert ; issuer DN = cert . get Issuer X 500 Principal ( ) ; if ( ! X509 Cert Impl . is Self Issued ( cert ) ) { if ( ! init && cert . get Basic Constraints ( ) != - NUM ) { traversed CA Certs ++ ; } } if ( init || ! X509 Cert Impl . is Self Issued ( cert ) ) { X500 Principal subj Name = cert . get Subject X 500 Principal ( ) ; subject Names Traversed . add ( X500 Name . as X 500 Name ( subj Name ) ) ; try { Subject Alternative Name Extension subj Alt Name Ext = icert . get Subject Alternative Name Extension ( ) ; if ( subj Alt Name Ext != null ) { General Names g Names = subj Alt Name Ext . get ( Subject Alternative Name Extension . SUBJECT NAME ) ; for ( General Name g Name : g Names . names ( ) ) { subject Names Traversed . add ( g Name . get Name ( ) ) ; } } } catch ( IO Exception e ) { if ( debug != null ) { debug . println ( STRING + STRING ) ; e . print Stack Trace ( ) ; } throw new Cert Path Validator Exception ( e ) ; } } init = BOOL ; }
public static Parameter Type make File Parameter Type ( Parameter Handler parameter Handler , String parameter Name , String description , Port Provider port Provider , String ... file Extensions ) { return make File Parameter Type ( parameter Handler , parameter Name , description , port Provider , BOOL , file Extensions ) ; }
public void test Timed Invoke All 1 ( ) throws Throwable { Executor Service e = new Fork Join Pool ( NUM ) ; Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; try { e . invoke All ( null , MEDIUM DELAY MS , MILLISECONDS ) ; should Throw ( ) ; } catch ( Null Pointer Exception success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public void test Timed Invoke All 1 ( ) throws Throwable { Executor Service e = new Fork Join Pool ( NUM ) ; Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; try { e . invoke All ( null , MEDIUM DELAY MS , MILLISECONDS ) ; should Throw ( ) ; } catch ( Null Pointer Exception success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
private void validate Sql Statement ( String sql , int jdbc Statement Index ) { Assert . is True ( String Utils . is Not Blank ( sql ) , STRING + jdbc Statement Index + STRING ) ; }
private void validate Sql Statement ( String sql , int jdbc Statement Index ) { Assert . is True ( String Utils . is Not Blank ( sql ) , STRING + jdbc Statement Index + STRING ) ; }
private void validate Sql Statement ( String sql , int jdbc Statement Index ) { Assert . is True ( String Utils . is Not Blank ( sql ) , STRING + jdbc Statement Index + STRING ) ; }
private void validate Sql Statement ( String sql , int jdbc Statement Index ) { Assert . is True ( String Utils . is Not Blank ( sql ) , STRING + jdbc Statement Index + STRING ) ; }
private void validate Sql Statement ( String sql , int jdbc Statement Index ) { Assert . is True ( String Utils . is Not Blank ( sql ) , STRING + jdbc Statement Index + STRING ) ; }
@ Visible For Testing public static boolean is Plaintext ( Buffer buffer ) throws EOF Exception { try { Buffer prefix = new Buffer ( ) ; long byte Count = buffer . size ( ) < NUM ? buffer . size ( ) : NUM ; buffer . copy To ( prefix , NUM , byte Count ) ; for ( int i = NUM ; i < NUM ; i ++ ) { if ( prefix . exhausted ( ) ) { break ; } int code Point = prefix . read Utf 8 Code Point ( ) ; if ( Character . is ISO Control ( code Point ) && ! Character . is Whitespace ( code Point ) ) { return BOOL ; } } return BOOL ; } catch ( EOF Exception e ) { return BOOL ; } }
@ Visible For Testing public static boolean is Plaintext ( Buffer buffer ) throws EOF Exception { try { Buffer prefix = new Buffer ( ) ; long byte Count = buffer . size ( ) < NUM ? buffer . size ( ) : NUM ; buffer . copy To ( prefix , NUM , byte Count ) ; for ( int i = NUM ; i < NUM ; i ++ ) { if ( prefix . exhausted ( ) ) { break ; } int code Point = prefix . read Utf 8 Code Point ( ) ; if ( Character . is ISO Control ( code Point ) && ! Character . is Whitespace ( code Point ) ) { return BOOL ; } } return BOOL ; } catch ( EOF Exception e ) { return BOOL ; } }
@ Visible For Testing public static boolean is Plaintext ( Buffer buffer ) throws EOF Exception { try { Buffer prefix = new Buffer ( ) ; long byte Count = buffer . size ( ) < NUM ? buffer . size ( ) : NUM ; buffer . copy To ( prefix , NUM , byte Count ) ; for ( int i = NUM ; i < NUM ; i ++ ) { if ( prefix . exhausted ( ) ) { break ; } int code Point = prefix . read Utf 8 Code Point ( ) ; if ( Character . is ISO Control ( code Point ) && ! Character . is Whitespace ( code Point ) ) { return BOOL ; } } return BOOL ; } catch ( EOF Exception e ) { return BOOL ; } }
@ Visible For Testing public static boolean is Plaintext ( Buffer buffer ) throws EOF Exception { try { Buffer prefix = new Buffer ( ) ; long byte Count = buffer . size ( ) < NUM ? buffer . size ( ) : NUM ; buffer . copy To ( prefix , NUM , byte Count ) ; for ( int i = NUM ; i < NUM ; i ++ ) { if ( prefix . exhausted ( ) ) { break ; } int code Point = prefix . read Utf 8 Code Point ( ) ; if ( Character . is ISO Control ( code Point ) && ! Character . is Whitespace ( code Point ) ) { return BOOL ; } } return BOOL ; } catch ( EOF Exception e ) { return BOOL ; } }
public JSON Array opt JSON Array ( String key ) { Object o = opt ( key ) ; return o instanceof JSON Array ? ( JSON Array ) o : null ; }
public static Ignite Logger logger ( Grid Kernal Context ctx , Atomic Reference < Ignite Logger > log Ref , Object obj ) { Ignite Logger log = log Ref . get ( ) ; if ( log == null ) { log Ref . compare And Set ( null , ctx . log ( obj . get Class ( ) ) ) ; log = log Ref . get ( ) ; } return log ; }
public static String format Map Old ( String name , Map < String , String > props , String header , boolean was Modified ) { String indent = STRING ; String Builder builder = new String Builder ( ) ; builder . append ( header ) ; builder . append ( String . format ( STRING , name , modified Sign ( was Modified ) ) ) ; builder . append ( STRING ) ; for ( String key : props . key Set ( ) ) { builder . append ( String . format ( STRING , indent , key , props . get ( key ) ) ) ; } builder . append ( String . format ( STRING ) ) ; return builder . to String ( ) ; }
Md Input Stream ( URL url , Input Stream in , Message Digest message Digest , byte [ ] expected Digest ) { if ( url == null || in == null || message Digest == null ) { throw new Null Pointer Exception ( ) ; } this . url = url ; this . in = in ; this . message Digest = message Digest ; this . expected Digest = expected Digest . clone ( ) ; }
Md Input Stream ( URL url , Input Stream in , Message Digest message Digest , byte [ ] expected Digest ) { if ( url == null || in == null || message Digest == null ) { throw new Null Pointer Exception ( ) ; } this . url = url ; this . in = in ; this . message Digest = message Digest ; this . expected Digest = expected Digest . clone ( ) ; }
Md Input Stream ( URL url , Input Stream in , Message Digest message Digest , byte [ ] expected Digest ) { if ( url == null || in == null || message Digest == null ) { throw new Null Pointer Exception ( ) ; } this . url = url ; this . in = in ; this . message Digest = message Digest ; this . expected Digest = expected Digest . clone ( ) ; }
Md Input Stream ( URL url , Input Stream in , Message Digest message Digest , byte [ ] expected Digest ) { if ( url == null || in == null || message Digest == null ) { throw new Null Pointer Exception ( ) ; } this . url = url ; this . in = in ; this . message Digest = message Digest ; this . expected Digest = expected Digest . clone ( ) ; }
Md Input Stream ( URL url , Input Stream in , Message Digest message Digest , byte [ ] expected Digest ) { if ( url == null || in == null || message Digest == null ) { throw new Null Pointer Exception ( ) ; } this . url = url ; this . in = in ; this . message Digest = message Digest ; this . expected Digest = expected Digest . clone ( ) ; }
Md Input Stream ( URL url , Input Stream in , Message Digest message Digest , byte [ ] expected Digest ) { if ( url == null || in == null || message Digest == null ) { throw new Null Pointer Exception ( ) ; } this . url = url ; this . in = in ; this . message Digest = message Digest ; this . expected Digest = expected Digest . clone ( ) ; }
Md Input Stream ( URL url , Input Stream in , Message Digest message Digest , byte [ ] expected Digest ) { if ( url == null || in == null || message Digest == null ) { throw new Null Pointer Exception ( ) ; } this . url = url ; this . in = in ; this . message Digest = message Digest ; this . expected Digest = expected Digest . clone ( ) ; }
public Array List < Phone > add Alias By Name ( String alias Name , String name ) { if ( alias Name . contains ( STRING ) ) return null ; Array List < Phone > res ; res = Contacts Manager . get Mobile Phones ( ctx , name ) ; if ( res . size ( ) == NUM ) { Phone p = res . get ( NUM ) ; add Or Update ( alias Name , p . get Clean Number ( ) , p . get Contact Name ( ) ) ; } return res ; }
public void add Functional Instrumentation ( Special Instrumentation Point functional Instrumentation ) { if ( null == functional Instrumentations ) { functional Instrumentations = new Hash Set < Special Instrumentation Point > ( NUM ) ; } functional Instrumentations . add ( functional Instrumentation ) ; }
private static URI fix Uri ( URI uri 0 , Configuration cfg ) { if ( uri 0 == null ) return File System . get Default Uri ( cfg ) ; String scheme = uri 0 . get Scheme ( ) ; String authority = uri 0 . get Authority ( ) ; if ( authority == null ) { URI dflt Uri = File System . get Default Uri ( cfg ) ; if ( scheme == null || ( scheme . equals ( dflt Uri . get Scheme ( ) ) && dflt Uri . get Authority ( ) != null ) ) return dflt Uri ; } return uri 0 ; }
private static URI fix Uri ( URI uri 0 , Configuration cfg ) { if ( uri 0 == null ) return File System . get Default Uri ( cfg ) ; String scheme = uri 0 . get Scheme ( ) ; String authority = uri 0 . get Authority ( ) ; if ( authority == null ) { URI dflt Uri = File System . get Default Uri ( cfg ) ; if ( scheme == null || ( scheme . equals ( dflt Uri . get Scheme ( ) ) && dflt Uri . get Authority ( ) != null ) ) return dflt Uri ; } return uri 0 ; }
void allow Offer ( boolean allow ) { offer Button . set Enabled ( allow ) ; }
void allow Offer ( boolean allow ) { offer Button . set Enabled ( allow ) ; }
private void add Token ( Token token ) { tokens . add ( token ) ; }
public static String tidy String ( String string ) { if ( string . matches ( STRING ) ) { return string ; } else { return string . replace All ( STRING , STRING ) ; } }
public static Writer left Shift ( Process self , Object value ) throws IO Exception { return IO Groovy Methods . left Shift ( self . get Output Stream ( ) , value ) ; }
public void create Connection Dialog ( ) { user Name Label = new J Label ( STRING , J Label . RIGHT ) ; user Name Field = new J Text Field ( STRING ) ; password Label = new J Label ( STRING , J Label . RIGHT ) ; password Field = new J Text Field ( STRING ) ; server Label = new J Label ( STRING , J Label . RIGHT ) ; server Field = new J Text Field ( STRING ) ; driver Label = new J Label ( STRING , J Label . RIGHT ) ; driver Field = new J Text Field ( STRING ) ; connection Panel = new J Panel ( BOOL ) ; connection Panel . set Layout ( new Box Layout ( connection Panel , Box Layout . X AXIS ) ) ; J Panel name Panel = new J Panel ( BOOL ) ; name Panel . set Layout ( new Grid Layout ( NUM , NUM ) ) ; name Panel . add ( user Name Label ) ; name Panel . add ( password Label ) ; name Panel . add ( server Label ) ; name Panel . add ( driver Label ) ; J Panel field Panel = new J Panel ( BOOL ) ; field Panel . set Layout ( new Grid Layout ( NUM , NUM ) ) ; field Panel . add ( user Name Field ) ; field Panel . add ( password Field ) ; field Panel . add ( server Field ) ; field Panel . add ( driver Field ) ; connection Panel . add ( name Panel ) ; connection Panel . add ( field Panel ) ; }
public void create Connection Dialog ( ) { user Name Label = new J Label ( STRING , J Label . RIGHT ) ; user Name Field = new J Text Field ( STRING ) ; password Label = new J Label ( STRING , J Label . RIGHT ) ; password Field = new J Text Field ( STRING ) ; server Label = new J Label ( STRING , J Label . RIGHT ) ; server Field = new J Text Field ( STRING ) ; driver Label = new J Label ( STRING , J Label . RIGHT ) ; driver Field = new J Text Field ( STRING ) ; connection Panel = new J Panel ( BOOL ) ; connection Panel . set Layout ( new Box Layout ( connection Panel , Box Layout . X AXIS ) ) ; J Panel name Panel = new J Panel ( BOOL ) ; name Panel . set Layout ( new Grid Layout ( NUM , NUM ) ) ; name Panel . add ( user Name Label ) ; name Panel . add ( password Label ) ; name Panel . add ( server Label ) ; name Panel . add ( driver Label ) ; J Panel field Panel = new J Panel ( BOOL ) ; field Panel . set Layout ( new Grid Layout ( NUM , NUM ) ) ; field Panel . add ( user Name Field ) ; field Panel . add ( password Field ) ; field Panel . add ( server Field ) ; field Panel . add ( driver Field ) ; connection Panel . add ( name Panel ) ; connection Panel . add ( field Panel ) ; }
public void create Connection Dialog ( ) { user Name Label = new J Label ( STRING , J Label . RIGHT ) ; user Name Field = new J Text Field ( STRING ) ; password Label = new J Label ( STRING , J Label . RIGHT ) ; password Field = new J Text Field ( STRING ) ; server Label = new J Label ( STRING , J Label . RIGHT ) ; server Field = new J Text Field ( STRING ) ; driver Label = new J Label ( STRING , J Label . RIGHT ) ; driver Field = new J Text Field ( STRING ) ; connection Panel = new J Panel ( BOOL ) ; connection Panel . set Layout ( new Box Layout ( connection Panel , Box Layout . X AXIS ) ) ; J Panel name Panel = new J Panel ( BOOL ) ; name Panel . set Layout ( new Grid Layout ( NUM , NUM ) ) ; name Panel . add ( user Name Label ) ; name Panel . add ( password Label ) ; name Panel . add ( server Label ) ; name Panel . add ( driver Label ) ; J Panel field Panel = new J Panel ( BOOL ) ; field Panel . set Layout ( new Grid Layout ( NUM , NUM ) ) ; field Panel . add ( user Name Field ) ; field Panel . add ( password Field ) ; field Panel . add ( server Field ) ; field Panel . add ( driver Field ) ; connection Panel . add ( name Panel ) ; connection Panel . add ( field Panel ) ; }
public static Collection < Communication Summary Statistics > build Communication Summary Tree ( Collection < Communication Summary Statistics > nodes , Set < String > endpoints ) { Map < String , Communication Summary Statistics > node Map = new Hash Map < String , Communication Summary Statistics > ( ) ; for ( Communication Summary Statistics css : nodes ) { node Map . put ( css . get Id ( ) , css ) ; } List < Communication Summary Statistics > ret = new Array List < > ( ) ; for ( String endpoint : endpoints ) { Communication Summary Statistics n = node Map . get ( Endpoint Util . encode Client URI ( endpoint ) ) ; if ( n == null ) { n = node Map . get ( endpoint ) ; } if ( n != null ) { Communication Summary Statistics root Node = new Communication Summary Statistics ( n ) ; init Communication Summary Tree Node ( root Node , node Map , new Hash Set < > ( Collections . singleton ( root Node . get Id ( ) ) ) ) ; ret . add ( root Node ) ; } } return ret ; }
@ Deprecated protected boolean has Input ( Class < ? extends IO Object > cls ) { try { get Input ( cls ) ; return BOOL ; } catch ( Missing IO Object Exception e ) { return BOOL ; } }
@ Deprecated protected boolean has Input ( Class < ? extends IO Object > cls ) { try { get Input ( cls ) ; return BOOL ; } catch ( Missing IO Object Exception e ) { return BOOL ; } }
public static byte [ ] new Bytes ( int len ) { if ( len == NUM ) { return EMPTY BYTES ; } try { return new byte [ len ] ; } catch ( Out Of Memory Error e ) { Error e2 = new Out Of Memory Error ( STRING + len ) ; e2 . init Cause ( e ) ; throw e2 ; } }
public static byte [ ] new Bytes ( int len ) { if ( len == NUM ) { return EMPTY BYTES ; } try { return new byte [ len ] ; } catch ( Out Of Memory Error e ) { Error e2 = new Out Of Memory Error ( STRING + len ) ; e2 . init Cause ( e ) ; throw e2 ; } }
public static byte [ ] new Bytes ( int len ) { if ( len == NUM ) { return EMPTY BYTES ; } try { return new byte [ len ] ; } catch ( Out Of Memory Error e ) { Error e2 = new Out Of Memory Error ( STRING + len ) ; e2 . init Cause ( e ) ; throw e2 ; } }
public static byte [ ] new Bytes ( int len ) { if ( len == NUM ) { return EMPTY BYTES ; } try { return new byte [ len ] ; } catch ( Out Of Memory Error e ) { Error e2 = new Out Of Memory Error ( STRING + len ) ; e2 . init Cause ( e ) ; throw e2 ; } }
public static byte [ ] new Bytes ( int len ) { if ( len == NUM ) { return EMPTY BYTES ; } try { return new byte [ len ] ; } catch ( Out Of Memory Error e ) { Error e2 = new Out Of Memory Error ( STRING + len ) ; e2 . init Cause ( e ) ; throw e2 ; } }
private void update Monitor ( ) { m Monitor Label . set Text ( STRING + m Active Tasks ) ; if ( m Active Tasks > NUM && ! m animating ) { m Monitor Label . set Icon ( m icon Animated ) ; m animating = BOOL ; } if ( m Active Tasks == NUM && m animating ) { m Monitor Label . set Icon ( m icon Stationary ) ; m animating = BOOL ; } }
private IV Generator ( ) { }
public static String [ ] split ( String line , String delim ) { List list = new Array List ( ) ; String Tokenizer t = new String Tokenizer ( line , delim ) ; while ( t . has More Tokens ( ) ) { list . add ( t . next Token ( ) ) ; } return ( String [ ] ) list . to Array ( new String [ list . size ( ) ] ) ; }
public R1 Interval union ( R1 Interval y ) { if ( is Empty ( ) ) { return y ; } if ( y . is Empty ( ) ) { return this ; } return new R1 Interval ( Math . min ( lo ( ) , y . lo ( ) ) , Math . max ( hi ( ) , y . hi ( ) ) ) ; }
public R1 Interval union ( R1 Interval y ) { if ( is Empty ( ) ) { return y ; } if ( y . is Empty ( ) ) { return this ; } return new R1 Interval ( Math . min ( lo ( ) , y . lo ( ) ) , Math . max ( hi ( ) , y . hi ( ) ) ) ; }
public static void init Urban Sim Person Writer ( Urban Sim Parameter Config Module V 3 module ) { try { log . info ( STRING ) ; person Writer = IO Utils . get Buffered Writer ( module . get MAT Sim 4 Opus Temp ( ) + FILE NAME ) ; log . info ( STRING + module . get MAT Sim 4 Opus Temp ( ) + FILE NAME + STRING ) ; person Writer . write ( Internal Constants . PERSON ID + STRING + STRING + STRING + STRING + STRING + STRING ) ; person Writer . new Line ( ) ; log . info ( STRING ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
public static String add Quotation Marks If Needed ( String str ) { if ( ! str . starts With ( STRING ) && ! str . is Empty ( ) ) return STRING + str + STRING ; return str ; }
public static String add Quotation Marks If Needed ( String str ) { if ( ! str . starts With ( STRING ) && ! str . is Empty ( ) ) return STRING + str + STRING ; return str ; }
public final Test Subscriber assert Not Complete ( ) { String prefix = STRING ; boolean passed = BOOL ; if ( done . get Count ( ) != NUM ) { prefix = STRING ; } long c = completions ; if ( c == NUM ) { fail ( prefix , STRING , errors ) ; fail ( STRING ) ; passed = BOOL ; } else if ( c > NUM ) { fail ( prefix , STRING + c , errors ) ; fail ( STRING ) ; passed = BOOL ; } pass ( STRING , passed ) ; return this ; }
public final Test Subscriber assert Not Complete ( ) { String prefix = STRING ; boolean passed = BOOL ; if ( done . get Count ( ) != NUM ) { prefix = STRING ; } long c = completions ; if ( c == NUM ) { fail ( prefix , STRING , errors ) ; fail ( STRING ) ; passed = BOOL ; } else if ( c > NUM ) { fail ( prefix , STRING + c , errors ) ; fail ( STRING ) ; passed = BOOL ; } pass ( STRING , passed ) ; return this ; }
public final Test Subscriber assert Not Complete ( ) { String prefix = STRING ; boolean passed = BOOL ; if ( done . get Count ( ) != NUM ) { prefix = STRING ; } long c = completions ; if ( c == NUM ) { fail ( prefix , STRING , errors ) ; fail ( STRING ) ; passed = BOOL ; } else if ( c > NUM ) { fail ( prefix , STRING + c , errors ) ; fail ( STRING ) ; passed = BOOL ; } pass ( STRING , passed ) ; return this ; }
private double gamma Ratio ( int n , int k ) { double top = ( n - k + NUM ) / NUM ; double bottom = ( n - k ) / NUM ; double lngamma = Prob Utils . lngamma ( top ) - Prob Utils . lngamma ( bottom ) ; return Math . exp ( lngamma ) ; }
protected abstract int read Skip Data ( int level , Index Input skip Stream ) throws IO Exception ;
protected abstract int read Skip Data ( int level , Index Input skip Stream ) throws IO Exception ;
public Vector 2 ceil ( ) { return new Vector 2 ( Math . ceil ( x ) , Math . ceil ( z ) ) ; }
public Vector 2 ceil ( ) { return new Vector 2 ( Math . ceil ( x ) , Math . ceil ( z ) ) ; }
public void add Page ( int position , @ Non Null List < MODEL > items ) { set Auto Notify Data Set Changed ( BOOL ) ; add All ( position , items ) ; set Auto Notify Data Set Changed ( BOOL ) ; on New Items Added ( items . size ( ) ) ; notify Item Range Inserted If Need ( size ( ) - ( items . size ( ) + get Headers Count ( ) ) , items . size ( ) ) ; }
public void add Page ( int position , @ Non Null List < MODEL > items ) { set Auto Notify Data Set Changed ( BOOL ) ; add All ( position , items ) ; set Auto Notify Data Set Changed ( BOOL ) ; on New Items Added ( items . size ( ) ) ; notify Item Range Inserted If Need ( size ( ) - ( items . size ( ) + get Headers Count ( ) ) , items . size ( ) ) ; }
public void add Page ( int position , @ Non Null List < MODEL > items ) { set Auto Notify Data Set Changed ( BOOL ) ; add All ( position , items ) ; set Auto Notify Data Set Changed ( BOOL ) ; on New Items Added ( items . size ( ) ) ; notify Item Range Inserted If Need ( size ( ) - ( items . size ( ) + get Headers Count ( ) ) , items . size ( ) ) ; }
public void add Page ( int position , @ Non Null List < MODEL > items ) { set Auto Notify Data Set Changed ( BOOL ) ; add All ( position , items ) ; set Auto Notify Data Set Changed ( BOOL ) ; on New Items Added ( items . size ( ) ) ; notify Item Range Inserted If Need ( size ( ) - ( items . size ( ) + get Headers Count ( ) ) , items . size ( ) ) ; }
public void add Page ( int position , @ Non Null List < MODEL > items ) { set Auto Notify Data Set Changed ( BOOL ) ; add All ( position , items ) ; set Auto Notify Data Set Changed ( BOOL ) ; on New Items Added ( items . size ( ) ) ; notify Item Range Inserted If Need ( size ( ) - ( items . size ( ) + get Headers Count ( ) ) , items . size ( ) ) ; }
private static Set < String > create Categories Set ( Set < String > categories ) { Set < String > result = new Hash Set < > ( ) ; for ( String cat : categories ) { result . add ( String Util . to Lower Case ( cat ) ) ; } return result ; }
private static Set < String > create Categories Set ( Set < String > categories ) { Set < String > result = new Hash Set < > ( ) ; for ( String cat : categories ) { result . add ( String Util . to Lower Case ( cat ) ) ; } return result ; }
public static Map < Unit , Unit > map Transports Already Loaded ( final Collection < Unit > units , final Collection < Unit > transports ) { final Collection < Unit > can Be Transported = Match . get Matches ( units , Matches . Unit Can Be Transported ) ; final Collection < Unit > can Transport = Match . get Matches ( transports , Matches . Unit Can Transport ) ; final Map < Unit , Unit > mapping = new Hash Map < > ( ) ; for ( final Unit current Transported : can Be Transported ) { final Unit transport = Transport Tracker . transported By ( current Transported ) ; if ( transport == null || ! can Transport . contains ( transport ) ) { continue ; } mapping . put ( current Transported , transport ) ; } return mapping ; }
public static Map < Unit , Unit > map Transports Already Loaded ( final Collection < Unit > units , final Collection < Unit > transports ) { final Collection < Unit > can Be Transported = Match . get Matches ( units , Matches . Unit Can Be Transported ) ; final Collection < Unit > can Transport = Match . get Matches ( transports , Matches . Unit Can Transport ) ; final Map < Unit , Unit > mapping = new Hash Map < > ( ) ; for ( final Unit current Transported : can Be Transported ) { final Unit transport = Transport Tracker . transported By ( current Transported ) ; if ( transport == null || ! can Transport . contains ( transport ) ) { continue ; } mapping . put ( current Transported , transport ) ; } return mapping ; }
@ Override public void presentation ( String program Name , String program Editor , String editor URL , String scriptor Name , String prefix Name ) throws Cancel Exception { final String text To Show = String . format ( translate ( STRING + STRING + STRING + STRING + STRING ) , program Name , program Editor , editor URL , scriptor Name , prefix Name ) ; presentation ( text To Show ) ; }
public boolean on Owner Changed ( Grid Cache Entry Ex entry , Grid Cache Mvcc Candidate owner ) { if ( owner != null ) { Ignite Tx Adapter tx = tx ( owner . version ( ) ) ; if ( tx == null ) tx = near Tx ( owner . version ( ) ) ; if ( tx != null ) { if ( ! tx . local ( ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + owner + STRING + entry + STRING + tx + STRING ) ; tx . on Owner Changed ( entry , owner ) ; return BOOL ; } else if ( log . is Debug Enabled ( ) ) log . debug ( STRING + tx ) ; } else if ( log . is Debug Enabled ( ) ) log . debug ( STRING + owner + STRING + entry + STRING ) ; } return BOOL ; }
public boolean on Owner Changed ( Grid Cache Entry Ex entry , Grid Cache Mvcc Candidate owner ) { if ( owner != null ) { Ignite Tx Adapter tx = tx ( owner . version ( ) ) ; if ( tx == null ) tx = near Tx ( owner . version ( ) ) ; if ( tx != null ) { if ( ! tx . local ( ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + owner + STRING + entry + STRING + tx + STRING ) ; tx . on Owner Changed ( entry , owner ) ; return BOOL ; } else if ( log . is Debug Enabled ( ) ) log . debug ( STRING + tx ) ; } else if ( log . is Debug Enabled ( ) ) log . debug ( STRING + owner + STRING + entry + STRING ) ; } return BOOL ; }
public boolean on Owner Changed ( Grid Cache Entry Ex entry , Grid Cache Mvcc Candidate owner ) { if ( owner != null ) { Ignite Tx Adapter tx = tx ( owner . version ( ) ) ; if ( tx == null ) tx = near Tx ( owner . version ( ) ) ; if ( tx != null ) { if ( ! tx . local ( ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + owner + STRING + entry + STRING + tx + STRING ) ; tx . on Owner Changed ( entry , owner ) ; return BOOL ; } else if ( log . is Debug Enabled ( ) ) log . debug ( STRING + tx ) ; } else if ( log . is Debug Enabled ( ) ) log . debug ( STRING + owner + STRING + entry + STRING ) ; } return BOOL ; }
public boolean on Owner Changed ( Grid Cache Entry Ex entry , Grid Cache Mvcc Candidate owner ) { if ( owner != null ) { Ignite Tx Adapter tx = tx ( owner . version ( ) ) ; if ( tx == null ) tx = near Tx ( owner . version ( ) ) ; if ( tx != null ) { if ( ! tx . local ( ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + owner + STRING + entry + STRING + tx + STRING ) ; tx . on Owner Changed ( entry , owner ) ; return BOOL ; } else if ( log . is Debug Enabled ( ) ) log . debug ( STRING + tx ) ; } else if ( log . is Debug Enabled ( ) ) log . debug ( STRING + owner + STRING + entry + STRING ) ; } return BOOL ; }
public String to String ( Charset encoding ) { String Builder out = new String Builder ( ) ; append To ( out , encoding ) ; return out . to String ( ) ; }
public void if Null ( final Label label ) { mv . visit Jump Insn ( Opcodes . IFNULL , label ) ; }
public boolean is Dirty ( ) { return dirty . get ( ) ; }
public boolean is Dirty ( ) { return dirty . get ( ) ; }
public boolean is Dirty ( ) { return dirty . get ( ) ; }
public boolean is Dirty ( ) { return dirty . get ( ) ; }
public boolean is Dirty ( ) { return dirty . get ( ) ; }
public void test Constructor Bytes Negative 1 ( ) { byte a Bytes [ ] = { - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , a Number . signum ( ) ) ; }
public void test Constructor Bytes Negative 1 ( ) { byte a Bytes [ ] = { - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , a Number . signum ( ) ) ; }
public void test Constructor Bytes Negative 1 ( ) { byte a Bytes [ ] = { - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , a Number . signum ( ) ) ; }
private void reallocate ( final int row ) { final int size = this . cols [ row ] . length ; final int [ ] new Cols = new int [ size * NUM ] ; final double [ ] new Values = new double [ size * NUM ] ; System . arraycopy ( this . cols [ row ] , NUM , new Cols , NUM , size ) ; System . arraycopy ( this . values [ row ] , NUM , new Values , NUM , size ) ; this . cols [ row ] = new Cols ; this . values [ row ] = new Values ; }
public Core Descriptor ( Core Container container , String name , Path instance Dir ) { this ( container , name , instance Dir , Collections . empty Map ( ) ) ; }
protected void fill Toolbar ( ) { Tool Bar Manager tool Bar Manager = get Tool Bar Manager ( ) ; if ( tool Bar Manager == null ) return ; f Input . fill Tool Bar ( tool Bar Manager , this ) ; tool Bar Manager . update ( BOOL ) ; }
public Chat Completion Helper ( final Chat Text Controller chat Text Controller , final Set < String > name List , final Set < String > commands ) { chat Controller = chat Text Controller ; playersonline = name List ; slash Commands = new Hash Set < String > ( commands . size ( ) ) ; for ( String s : commands ) { slash Commands . add ( STRING + s ) ; } }
private String partially Escape Assertion Value ( String assertion Value ) { String Builder sb = new String Builder ( assertion Value . length ( ) ) ; for ( int j = NUM ; j < assertion Value . length ( ) ; j ++ ) { char c = assertion Value . char At ( j ) ; if ( c == STRING ) { sb . append ( c ) ; } else { sb . append ( Filter . escape Assertion Value ( String . value Of ( c ) ) ) ; } } return sb . to String ( ) ; }
private String partially Escape Assertion Value ( String assertion Value ) { String Builder sb = new String Builder ( assertion Value . length ( ) ) ; for ( int j = NUM ; j < assertion Value . length ( ) ; j ++ ) { char c = assertion Value . char At ( j ) ; if ( c == STRING ) { sb . append ( c ) ; } else { sb . append ( Filter . escape Assertion Value ( String . value Of ( c ) ) ) ; } } return sb . to String ( ) ; }
private String partially Escape Assertion Value ( String assertion Value ) { String Builder sb = new String Builder ( assertion Value . length ( ) ) ; for ( int j = NUM ; j < assertion Value . length ( ) ; j ++ ) { char c = assertion Value . char At ( j ) ; if ( c == STRING ) { sb . append ( c ) ; } else { sb . append ( Filter . escape Assertion Value ( String . value Of ( c ) ) ) ; } } return sb . to String ( ) ; }
private String partially Escape Assertion Value ( String assertion Value ) { String Builder sb = new String Builder ( assertion Value . length ( ) ) ; for ( int j = NUM ; j < assertion Value . length ( ) ; j ++ ) { char c = assertion Value . char At ( j ) ; if ( c == STRING ) { sb . append ( c ) ; } else { sb . append ( Filter . escape Assertion Value ( String . value Of ( c ) ) ) ; } } return sb . to String ( ) ; }
private String partially Escape Assertion Value ( String assertion Value ) { String Builder sb = new String Builder ( assertion Value . length ( ) ) ; for ( int j = NUM ; j < assertion Value . length ( ) ; j ++ ) { char c = assertion Value . char At ( j ) ; if ( c == STRING ) { sb . append ( c ) ; } else { sb . append ( Filter . escape Assertion Value ( String . value Of ( c ) ) ) ; } } return sb . to String ( ) ; }
private String partially Escape Assertion Value ( String assertion Value ) { String Builder sb = new String Builder ( assertion Value . length ( ) ) ; for ( int j = NUM ; j < assertion Value . length ( ) ; j ++ ) { char c = assertion Value . char At ( j ) ; if ( c == STRING ) { sb . append ( c ) ; } else { sb . append ( Filter . escape Assertion Value ( String . value Of ( c ) ) ) ; } } return sb . to String ( ) ; }
private String partially Escape Assertion Value ( String assertion Value ) { String Builder sb = new String Builder ( assertion Value . length ( ) ) ; for ( int j = NUM ; j < assertion Value . length ( ) ; j ++ ) { char c = assertion Value . char At ( j ) ; if ( c == STRING ) { sb . append ( c ) ; } else { sb . append ( Filter . escape Assertion Value ( String . value Of ( c ) ) ) ; } } return sb . to String ( ) ; }
private String partially Escape Assertion Value ( String assertion Value ) { String Builder sb = new String Builder ( assertion Value . length ( ) ) ; for ( int j = NUM ; j < assertion Value . length ( ) ; j ++ ) { char c = assertion Value . char At ( j ) ; if ( c == STRING ) { sb . append ( c ) ; } else { sb . append ( Filter . escape Assertion Value ( String . value Of ( c ) ) ) ; } } return sb . to String ( ) ; }
protected boolean check List ( String current Val , String token Value ) { if ( current Val == null || token Value == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ! current Val . starts With ( STRING ) && ! current Val . starts With ( STRING ) ) { throw new Illegal Argument Exception ( STRING ) ; } boolean negation = current Val . starts With ( STRING ) ; String list Name = current Val . substring ( current Val . index Of ( STRING ) + NUM ) ; Object list Obj = list Map . get ( list Name ) ; if ( list Obj == null ) return BOOL ; boolean contains ; if ( list Obj instanceof Set ) { Set < String > set = ( Set ) list Obj ; contains = set . contains ( token Value ) ; } else { throw new Illegal Argument Exception ( STRING + list Obj ) ; } return ! ( contains && negation || ! contains && ! negation ) ; }
protected boolean check List ( String current Val , String token Value ) { if ( current Val == null || token Value == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ! current Val . starts With ( STRING ) && ! current Val . starts With ( STRING ) ) { throw new Illegal Argument Exception ( STRING ) ; } boolean negation = current Val . starts With ( STRING ) ; String list Name = current Val . substring ( current Val . index Of ( STRING ) + NUM ) ; Object list Obj = list Map . get ( list Name ) ; if ( list Obj == null ) return BOOL ; boolean contains ; if ( list Obj instanceof Set ) { Set < String > set = ( Set ) list Obj ; contains = set . contains ( token Value ) ; } else { throw new Illegal Argument Exception ( STRING + list Obj ) ; } return ! ( contains && negation || ! contains && ! negation ) ; }
public abstract int compare ( String source , String target ) ;
public abstract int compare ( String source , String target ) ;
public abstract int compare ( String source , String target ) ;
public abstract int compare ( String source , String target ) ;
public abstract int compare ( String source , String target ) ;
public abstract int compare ( String source , String target ) ;
public abstract int compare ( String source , String target ) ;
public static void init ( Context context , boolean is top ) { camera Manager = new Camera Manager ( context , is top ) ; }
public static void init ( Context context , boolean is top ) { camera Manager = new Camera Manager ( context , is top ) ; }
protected static Long convert Uuid To Long ( UUID uuid ) { if ( uuid == null ) { return null ; } Long converted Uuid ; if ( uuid . version ( ) == NUM ) { converted Uuid = uuid . timestamp ( ) ; } else { converted Uuid = uuid . get Most Significant Bits ( ) ; } return converted Uuid ; }
static File Time to File Time ( long time ) { time /= NUM ; time += WINDOWS EPOCH IN MICROSECONDS ; return File Time . from ( time , Time Unit . MICROSECONDS ) ; }
static File Time to File Time ( long time ) { time /= NUM ; time += WINDOWS EPOCH IN MICROSECONDS ; return File Time . from ( time , Time Unit . MICROSECONDS ) ; }
static File Time to File Time ( long time ) { time /= NUM ; time += WINDOWS EPOCH IN MICROSECONDS ; return File Time . from ( time , Time Unit . MICROSECONDS ) ; }
public String resolve Parent Relation Name ( String parent Name , Object parent , String child Name , Object child ) { return parent Name ; }
public Surround With Line Selection ( ) { super ( org . eclipse . jface . text . templates . Global Template Variables . Line Selection . NAME , Java Template Messages . Compilation Unit Context Type variable description line selection ) ; }
public static short [ ] join ( short [ ] array A , short ... array B ) { if ( ( array B == null ) || ( array B . length == NUM ) ) { return array A ; } if ( ( array A == null ) || ( array A . length == NUM ) ) { return array B ; } short [ ] array = new short [ array A . length + array B . length ] ; System . arraycopy ( array A , NUM , array , NUM , array A . length ) ; System . arraycopy ( array B , NUM , array , array A . length , array B . length ) ; return array ; }
public static short [ ] join ( short [ ] array A , short ... array B ) { if ( ( array B == null ) || ( array B . length == NUM ) ) { return array A ; } if ( ( array A == null ) || ( array A . length == NUM ) ) { return array B ; } short [ ] array = new short [ array A . length + array B . length ] ; System . arraycopy ( array A , NUM , array , NUM , array A . length ) ; System . arraycopy ( array B , NUM , array , array A . length , array B . length ) ; return array ; }
public void add Field ( Mapped Member mm ) { fields . add ( mm ) ; }
public void add Field ( Mapped Member mm ) { fields . add ( mm ) ; }
public int read Int ( ) throws IO Exception { return ( ( is . read ( ) << NUM ) | ( is . read ( ) << NUM ) | ( is . read ( ) << NUM ) | ( is . read ( ) ) ) ; }
public Mp 4 Box Header ( String id ) { if ( id . length ( ) != IDENTIFIER LENGTH ) { throw new Runtime Exception ( STRING ) ; } data Buffer = Byte Buffer . allocate ( HEADER LENGTH ) ; try { this . id = id ; data Buffer . put ( NUM , id . get Bytes ( STRING ) [ NUM ] ) ; data Buffer . put ( NUM , id . get Bytes ( STRING ) [ NUM ] ) ; data Buffer . put ( NUM , id . get Bytes ( STRING ) [ NUM ] ) ; data Buffer . put ( NUM , id . get Bytes ( STRING ) [ NUM ] ) ; } catch ( Unsupported Encoding Exception uee ) { throw new Runtime Exception ( uee ) ; } }
public static void register Protocol ( final String id , final Protocol protocol ) { if ( id == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( protocol == null ) { throw new Illegal Argument Exception ( STRING ) ; } PROTOCOLS . put ( id , protocol ) ; }
public static void register Protocol ( final String id , final Protocol protocol ) { if ( id == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( protocol == null ) { throw new Illegal Argument Exception ( STRING ) ; } PROTOCOLS . put ( id , protocol ) ; }
public static void register Protocol ( final String id , final Protocol protocol ) { if ( id == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( protocol == null ) { throw new Illegal Argument Exception ( STRING ) ; } PROTOCOLS . put ( id , protocol ) ; }
protected void assert Same Hits ( final I Hit [ ] hits , final Iterator < ? extends I Hit > itr ) { final int nhits = hits . length ; for ( int i = NUM ; i < nhits ; i ++ ) { assert True ( STRING + ( i ) + STRING + nhits , itr . has Next ( ) ) ; final I Hit expected = hits [ i ] ; final I Hit actual = itr . next ( ) ; if ( log . is Info Enabled ( ) ) log . info ( STRING + ( i + NUM ) + STRING + expected + STRING + actual ) ; assert Equals ( STRING + ( i + NUM ) , expected . get Doc Id ( ) , actual . get Doc Id ( ) ) ; final double expected Cosine = expected . get Cosine ( ) ; final double actual Cosine = actual . get Cosine ( ) ; if ( actual Cosine < expected Cosine - NUM || actual Cosine > expected Cosine + NUM ) { assert Equals ( STRING + ( i + NUM ) , expected . get Cosine ( ) , actual . get Cosine ( ) ) ; } } assert False ( STRING + nhits + STRING , itr . has Next ( ) ) ; }
protected void assert Same Hits ( final I Hit [ ] hits , final Iterator < ? extends I Hit > itr ) { final int nhits = hits . length ; for ( int i = NUM ; i < nhits ; i ++ ) { assert True ( STRING + ( i ) + STRING + nhits , itr . has Next ( ) ) ; final I Hit expected = hits [ i ] ; final I Hit actual = itr . next ( ) ; if ( log . is Info Enabled ( ) ) log . info ( STRING + ( i + NUM ) + STRING + expected + STRING + actual ) ; assert Equals ( STRING + ( i + NUM ) , expected . get Doc Id ( ) , actual . get Doc Id ( ) ) ; final double expected Cosine = expected . get Cosine ( ) ; final double actual Cosine = actual . get Cosine ( ) ; if ( actual Cosine < expected Cosine - NUM || actual Cosine > expected Cosine + NUM ) { assert Equals ( STRING + ( i + NUM ) , expected . get Cosine ( ) , actual . get Cosine ( ) ) ; } } assert False ( STRING + nhits + STRING , itr . has Next ( ) ) ; }
protected void assert Same Hits ( final I Hit [ ] hits , final Iterator < ? extends I Hit > itr ) { final int nhits = hits . length ; for ( int i = NUM ; i < nhits ; i ++ ) { assert True ( STRING + ( i ) + STRING + nhits , itr . has Next ( ) ) ; final I Hit expected = hits [ i ] ; final I Hit actual = itr . next ( ) ; if ( log . is Info Enabled ( ) ) log . info ( STRING + ( i + NUM ) + STRING + expected + STRING + actual ) ; assert Equals ( STRING + ( i + NUM ) , expected . get Doc Id ( ) , actual . get Doc Id ( ) ) ; final double expected Cosine = expected . get Cosine ( ) ; final double actual Cosine = actual . get Cosine ( ) ; if ( actual Cosine < expected Cosine - NUM || actual Cosine > expected Cosine + NUM ) { assert Equals ( STRING + ( i + NUM ) , expected . get Cosine ( ) , actual . get Cosine ( ) ) ; } } assert False ( STRING + nhits + STRING , itr . has Next ( ) ) ; }
public static void is Valid Path ( String matsim Confi File ) { if ( matsim Confi File == null || matsim Confi File . length ( ) <= NUM || ! path Exsits ( matsim Confi File ) ) throw new Runtime Exception ( matsim Confi File + STRING ) ; }
public static void is Valid Path ( String matsim Confi File ) { if ( matsim Confi File == null || matsim Confi File . length ( ) <= NUM || ! path Exsits ( matsim Confi File ) ) throw new Runtime Exception ( matsim Confi File + STRING ) ; }
public boolean is Granted ( final T tx ) { if ( tx == null ) { throw new Illegal Argument Exception ( ) ; } return queue . peek ( ) == tx ; }
public boolean is Granted ( final T tx ) { if ( tx == null ) { throw new Illegal Argument Exception ( ) ; } return queue . peek ( ) == tx ; }
public boolean is Granted ( final T tx ) { if ( tx == null ) { throw new Illegal Argument Exception ( ) ; } return queue . peek ( ) == tx ; }
@ Override public String leave DTD ( ) { if ( writer == dtd Writer ) { line . append ( text ) ; text = new String Buffer ( NUM ) ; flush Line ( BOOL ) ; writer = doc Writer ; return dtd Writer . to String ( ) ; } return null ; }
@ Override public String leave DTD ( ) { if ( writer == dtd Writer ) { line . append ( text ) ; text = new String Buffer ( NUM ) ; flush Line ( BOOL ) ; writer = doc Writer ; return dtd Writer . to String ( ) ; } return null ; }
@ Override public String leave DTD ( ) { if ( writer == dtd Writer ) { line . append ( text ) ; text = new String Buffer ( NUM ) ; flush Line ( BOOL ) ; writer = doc Writer ; return dtd Writer . to String ( ) ; } return null ; }
@ Override public String leave DTD ( ) { if ( writer == dtd Writer ) { line . append ( text ) ; text = new String Buffer ( NUM ) ; flush Line ( BOOL ) ; writer = doc Writer ; return dtd Writer . to String ( ) ; } return null ; }
@ Override public String leave DTD ( ) { if ( writer == dtd Writer ) { line . append ( text ) ; text = new String Buffer ( NUM ) ; flush Line ( BOOL ) ; writer = doc Writer ; return dtd Writer . to String ( ) ; } return null ; }
public Event Source Impl ( ) { LOG . entering ( CLASS NAME , STRING ) ; }
public Event Source Impl ( ) { LOG . entering ( CLASS NAME , STRING ) ; }
void clear ( ) { buffer . set Length ( NUM ) ; start Offset = end Offset = type = subword Count = NUM ; }
public void add ( int index , Pdf Object element ) { list . add ( index , element ) ; }
public void append And Clear Pending ( String s ) { output . append ( s ) ; complete = current ; }
protected static void write Quoted String Value ( Byte Array Output Stream out , byte [ ] buf ) { int len = buf . length ; byte ch ; for ( int i = NUM ; i < len ; i ++ ) { ch = buf [ i ] ; if ( need Escape ( ( char ) ch ) ) { out . write ( STRING ) ; } out . write ( ch ) ; } }
protected static void write Quoted String Value ( Byte Array Output Stream out , byte [ ] buf ) { int len = buf . length ; byte ch ; for ( int i = NUM ; i < len ; i ++ ) { ch = buf [ i ] ; if ( need Escape ( ( char ) ch ) ) { out . write ( STRING ) ; } out . write ( ch ) ; } }
public Feature Vector read Feature Vector ( int current Unit Index , Byte Buffer bb ) throws IO Exception { byte [ ] bytes = new byte [ num Byte Features ] ; bb . get ( bytes ) ; short [ ] shorts = new short [ num Short Features ] ; for ( int i = NUM ; i < shorts . length ; i ++ ) { shorts [ i ] = bb . get Short ( ) ; } float [ ] floats = new float [ num Continuous Features ] ; for ( int i = NUM ; i < floats . length ; i ++ ) { floats [ i ] = bb . get Float ( ) ; } return new Feature Vector ( bytes , shorts , floats , current Unit Index ) ; }
public Feature Vector read Feature Vector ( int current Unit Index , Byte Buffer bb ) throws IO Exception { byte [ ] bytes = new byte [ num Byte Features ] ; bb . get ( bytes ) ; short [ ] shorts = new short [ num Short Features ] ; for ( int i = NUM ; i < shorts . length ; i ++ ) { shorts [ i ] = bb . get Short ( ) ; } float [ ] floats = new float [ num Continuous Features ] ; for ( int i = NUM ; i < floats . length ; i ++ ) { floats [ i ] = bb . get Float ( ) ; } return new Feature Vector ( bytes , shorts , floats , current Unit Index ) ; }
public Status Bar ( boolean show Memory ) { super ( new Border Layout ( ) ) ; add ( create Info Panel ( ) , Border Layout . WEST ) ; if ( show Memory ) { add ( create Memory Status ( ) , Border Layout . CENTER ) ; J Panel icon Panel = new J Panel ( new Border Layout ( ) ) ; icon Panel . add ( new J Label ( new Angled Lines Windows Corner Icon ( ) ) , Border Layout . SOUTH ) ; add ( icon Panel , Border Layout . EAST ) ; } else { set Background ( Color . WHITE ) ; } }
private void update Sliding ( float new Position Normalized ) { current Slide = new Position Normalized ; state = current Slide == NUM ? EXPANDED : current Slide == NUM ? COLLAPSED : SLIDING ; float slide Y = Math . abs ( ( current Slide * max Slide ) - max Slide ) ; slidable View . set Y ( slide Y ) ; invalidate ( ) ; notify Listeners ( current Slide ) ; }
public Okapi BM 25 ( double k1 , double b ) { if ( Double . is Na N ( k1 ) || Double . is Infinite ( k1 ) || k1 < NUM ) throw new Illegal Argument Exception ( STRING + k1 ) ; this . k1 = k1 ; if ( Double . is Na N ( b ) || b < NUM || b > NUM ) throw new Illegal Argument Exception ( STRING + b ) ; this . b = b ; }
private void delete Angle ( ) { if ( angles == null ) return ; if ( angles . length == NUM ) { angles = null ; jTF Change Angle . set Text ( STRING ) ; angle Model . remove Value At ( NUM ) ; jL Angle Count . set Text ( JL NUMBER OF ANGLES TEXT + STRING ) ; btn Delete Angle . set Enabled ( BOOL ) ; } else { double [ ] tmp Angles = new double [ angles . length - NUM ] ; for ( int i = NUM ; i < angles . length - NUM ; i ++ ) { if ( i >= selected Angle Index ) { tmp Angles [ i ] = angles [ i + NUM ] ; } else { tmp Angles [ i ] = angles [ i ] ; } } angles = tmp Angles ; angle Model . remove Value At ( selected Angle Index ) ; selected Angle Index = NUM ; jTF Change Angle . set Text ( angles [ selected Angle Index ] + STRING ) ; jL Angle Count . set Text ( STRING + angles . length ) ; } repaint ( ) ; }
private void update Placements ( Resource Pool Service . Resource Pool State resource Pool State ) { Query Task query Task = Query Util . build Property Query ( Group Resource Placement Service . Group Resource Placement State . class , Group Resource Placement Service . Group Resource Placement State . FIELD NAME RESOURCE POOL LINK , resource Pool State . document Self Link ) ; Query Util . add Expand Option ( query Task ) ; Service Document Query < Group Resource Placement State > query = new Service Document Query < > ( get Host ( ) , Group Resource Placement State . class ) ; List < Group Resource Placement State > placements = new Array List < > ( ) ; query . query ( query Task , null ) ; }
private void update Placements ( Resource Pool Service . Resource Pool State resource Pool State ) { Query Task query Task = Query Util . build Property Query ( Group Resource Placement Service . Group Resource Placement State . class , Group Resource Placement Service . Group Resource Placement State . FIELD NAME RESOURCE POOL LINK , resource Pool State . document Self Link ) ; Query Util . add Expand Option ( query Task ) ; Service Document Query < Group Resource Placement State > query = new Service Document Query < > ( get Host ( ) , Group Resource Placement State . class ) ; List < Group Resource Placement State > placements = new Array List < > ( ) ; query . query ( query Task , null ) ; }
private void update Placements ( Resource Pool Service . Resource Pool State resource Pool State ) { Query Task query Task = Query Util . build Property Query ( Group Resource Placement Service . Group Resource Placement State . class , Group Resource Placement Service . Group Resource Placement State . FIELD NAME RESOURCE POOL LINK , resource Pool State . document Self Link ) ; Query Util . add Expand Option ( query Task ) ; Service Document Query < Group Resource Placement State > query = new Service Document Query < > ( get Host ( ) , Group Resource Placement State . class ) ; List < Group Resource Placement State > placements = new Array List < > ( ) ; query . query ( query Task , null ) ; }
public void force Full Scan ( ) throws IO Exception { final Set < Workspace Watcher > watchers = new Hash Set < Workspace Watcher > ( ) ; for ( final TFS Repository Path Watcher watcher : get Path Watchers ( ) ) { watchers . add ( watcher . get Watcher ( ) ) ; } for ( final Workspace Watcher watcher : watchers ) { watcher . force Full Scan ( ) ; } }
public void force Full Scan ( ) throws IO Exception { final Set < Workspace Watcher > watchers = new Hash Set < Workspace Watcher > ( ) ; for ( final TFS Repository Path Watcher watcher : get Path Watchers ( ) ) { watchers . add ( watcher . get Watcher ( ) ) ; } for ( final Workspace Watcher watcher : watchers ) { watcher . force Full Scan ( ) ; } }
public void force Full Scan ( ) throws IO Exception { final Set < Workspace Watcher > watchers = new Hash Set < Workspace Watcher > ( ) ; for ( final TFS Repository Path Watcher watcher : get Path Watchers ( ) ) { watchers . add ( watcher . get Watcher ( ) ) ; } for ( final Workspace Watcher watcher : watchers ) { watcher . force Full Scan ( ) ; } }
public void force Full Scan ( ) throws IO Exception { final Set < Workspace Watcher > watchers = new Hash Set < Workspace Watcher > ( ) ; for ( final TFS Repository Path Watcher watcher : get Path Watchers ( ) ) { watchers . add ( watcher . get Watcher ( ) ) ; } for ( final Workspace Watcher watcher : watchers ) { watcher . force Full Scan ( ) ; } }
public void force Full Scan ( ) throws IO Exception { final Set < Workspace Watcher > watchers = new Hash Set < Workspace Watcher > ( ) ; for ( final TFS Repository Path Watcher watcher : get Path Watchers ( ) ) { watchers . add ( watcher . get Watcher ( ) ) ; } for ( final Workspace Watcher watcher : watchers ) { watcher . force Full Scan ( ) ; } }
@ Override public int read ( ) throws IO Exception { while ( in != null ) { int result = in . read ( ) ; if ( result >= NUM ) { return result ; } next Stream ( ) ; } return - NUM ; }
@ Override public int read ( ) throws IO Exception { while ( in != null ) { int result = in . read ( ) ; if ( result >= NUM ) { return result ; } next Stream ( ) ; } return - NUM ; }
@ Override public int read ( ) throws IO Exception { while ( in != null ) { int result = in . read ( ) ; if ( result >= NUM ) { return result ; } next Stream ( ) ; } return - NUM ; }
@ Override public int read ( ) throws IO Exception { while ( in != null ) { int result = in . read ( ) ; if ( result >= NUM ) { return result ; } next Stream ( ) ; } return - NUM ; }
private double box Radius ( int i , int a , int b ) { final int level ; if ( a < NUM ) { if ( b >= pf . length ) { return Double . POSITIVE INFINITY ; } level = max Reg Level ( i , b ) ; } else if ( b >= pf . length ) { level = max Reg Level ( i , a ) ; } else { level = Math . max ( max Reg Level ( i , a ) , max Reg Level ( i , b ) ) ; } return min Dist Level ( pf [ i ] . id , level ) ; }
private double box Radius ( int i , int a , int b ) { final int level ; if ( a < NUM ) { if ( b >= pf . length ) { return Double . POSITIVE INFINITY ; } level = max Reg Level ( i , b ) ; } else if ( b >= pf . length ) { level = max Reg Level ( i , a ) ; } else { level = Math . max ( max Reg Level ( i , a ) , max Reg Level ( i , b ) ) ; } return min Dist Level ( pf [ i ] . id , level ) ; }
@ Timed @ Exception Metered @ Path ( STRING ) @ GET @ Produces ( APPLICATION JSON ) public Iterable < Sanitized Secret > secret Listing V 2 ( @ Auth Automation Client automation Client , @ Query Param ( STRING ) Integer idx , @ Query Param ( STRING ) Integer num , @ Default Value ( STRING ) @ Query Param ( STRING ) boolean newest First ) { if ( idx != null && num != null ) { if ( idx < NUM || num < NUM ) { throw new Bad Request Exception ( STRING ) ; } return secret Controller . get Secrets Batched ( idx , num , newest First ) ; } return secret Controller . get Sanitized Secrets ( null , null ) ; }
@ Timed @ Exception Metered @ Path ( STRING ) @ GET @ Produces ( APPLICATION JSON ) public Iterable < Sanitized Secret > secret Listing V 2 ( @ Auth Automation Client automation Client , @ Query Param ( STRING ) Integer idx , @ Query Param ( STRING ) Integer num , @ Default Value ( STRING ) @ Query Param ( STRING ) boolean newest First ) { if ( idx != null && num != null ) { if ( idx < NUM || num < NUM ) { throw new Bad Request Exception ( STRING ) ; } return secret Controller . get Secrets Batched ( idx , num , newest First ) ; } return secret Controller . get Sanitized Secrets ( null , null ) ; }
@ Timed @ Exception Metered @ Path ( STRING ) @ GET @ Produces ( APPLICATION JSON ) public Iterable < Sanitized Secret > secret Listing V 2 ( @ Auth Automation Client automation Client , @ Query Param ( STRING ) Integer idx , @ Query Param ( STRING ) Integer num , @ Default Value ( STRING ) @ Query Param ( STRING ) boolean newest First ) { if ( idx != null && num != null ) { if ( idx < NUM || num < NUM ) { throw new Bad Request Exception ( STRING ) ; } return secret Controller . get Secrets Batched ( idx , num , newest First ) ; } return secret Controller . get Sanitized Secrets ( null , null ) ; }
public static boolean double Array Equals ( double [ ] x , double [ ] y , double tol ) { for ( int i = NUM ; i < x . length ; i += NUM ) { if ( x [ i ] == NUM ) { return y [ i ] == NUM ; } if ( Math . abs ( ( y [ i ] - x [ i ] ) / x [ i ] ) > tol ) { return BOOL ; } } return BOOL ; }
public static String md 5 ( String key ) { String cache Key ; try { final Message Digest m Digest = Message Digest . get Instance ( STRING ) ; m Digest . update ( key . get Bytes ( ) ) ; cache Key = bytes To Hex String ( m Digest . digest ( ) ) ; } catch ( No Such Algorithm Exception e ) { cache Key = String . value Of ( key . hash Code ( ) ) ; } return cache Key ; }
public static String md 5 ( String key ) { String cache Key ; try { final Message Digest m Digest = Message Digest . get Instance ( STRING ) ; m Digest . update ( key . get Bytes ( ) ) ; cache Key = bytes To Hex String ( m Digest . digest ( ) ) ; } catch ( No Such Algorithm Exception e ) { cache Key = String . value Of ( key . hash Code ( ) ) ; } return cache Key ; }
private void startup Acceptor ( ) throws Interrupted Exception { if ( ! selectable ) { register Queue . clear ( ) ; cancel Queue . clear ( ) ; flushing Sessions . clear ( ) ; } lock . acquire ( ) ; if ( acceptor == null ) { acceptor = new Acceptor ( ) ; execute Worker ( acceptor ) ; } else { lock . release ( ) ; } }
public void collect ( Thread thread ) { final Stack Trace Element [ ] stack Trace = thread . get Stack Trace ( ) ; collect By Key ( GLOBAL , stack Trace ) ; }
public void collect ( Thread thread ) { final Stack Trace Element [ ] stack Trace = thread . get Stack Trace ( ) ; collect By Key ( GLOBAL , stack Trace ) ; }
public void collect ( Thread thread ) { final Stack Trace Element [ ] stack Trace = thread . get Stack Trace ( ) ; collect By Key ( GLOBAL , stack Trace ) ; }
public void collect ( Thread thread ) { final Stack Trace Element [ ] stack Trace = thread . get Stack Trace ( ) ; collect By Key ( GLOBAL , stack Trace ) ; }
public void collect ( Thread thread ) { final Stack Trace Element [ ] stack Trace = thread . get Stack Trace ( ) ; collect By Key ( GLOBAL , stack Trace ) ; }
public void collect ( Thread thread ) { final Stack Trace Element [ ] stack Trace = thread . get Stack Trace ( ) ; collect By Key ( GLOBAL , stack Trace ) ; }
public void collect ( Thread thread ) { final Stack Trace Element [ ] stack Trace = thread . get Stack Trace ( ) ; collect By Key ( GLOBAL , stack Trace ) ; }
void add Term ( Map Builder Term Type type , J Class jclass , String alias ) { Map Builder Term new Term = new Map Builder Term ( ) ; new Term . type = type ; new Term . jclass = jclass ; new Term . alias = alias ; terms . add ( new Term ) ; }
private synchronized void update Effective Level ( Class Loader loader ) { if ( loader == null ) loader = system Class Loader ; int old Effective Level = get Effective Level ( loader ) ; Level new Effective Level = calculate Effective Level ( loader ) ; if ( old Effective Level == new Effective Level . int Value ( ) && loader != system Class Loader ) return ; finest Effective Level = new Effective Level ; has Local Effective Level = BOOL ; update Effective Level Part ( system Class Loader ) ; update Effective Level Part ( loader ) ; for ( int i = NUM ; i < loaders . size ( ) ; i ++ ) { Weak Reference < Class Loader > loader Ref = loaders . get ( i ) ; Class Loader class Loader = loader Ref . get ( ) ; if ( class Loader != null ) update Effective Level Part ( class Loader ) ; } super . set Level ( finest Effective Level ) ; finest Effective Level Value = finest Effective Level . int Value ( ) ; update Children ( ) ; }
private int find Word End ( String text , int pos ) { int end = - NUM ; Matcher m = WORD . matcher ( text ) ; if ( pos > NUM ) { pos -- ; } if ( m . find ( pos ) ) { end = m . end ( ) ; } if ( text . length ( ) == pos ) { end = text . length ( ) ; } if ( end == - NUM ) { end = text . length ( ) ; } return end ; }
private int find Word End ( String text , int pos ) { int end = - NUM ; Matcher m = WORD . matcher ( text ) ; if ( pos > NUM ) { pos -- ; } if ( m . find ( pos ) ) { end = m . end ( ) ; } if ( text . length ( ) == pos ) { end = text . length ( ) ; } if ( end == - NUM ) { end = text . length ( ) ; } return end ; }
private void add Programmer Box ( ) { J Panel pane 3 a = new J Panel ( ) ; pane 3 a . set Layout ( new Box Layout ( pane 3 a , Box Layout . X AXIS ) ) ; pane 3 a . add ( new J Label ( Bundle . get Message ( STRING ) ) ) ; programmer Box = new J Combo Box < String > ( Prog Default . find List Of Prog Files ( ) ) ; programmer Box . set Selected Index ( NUM ) ; if ( Prog Default . get Default Prog File ( ) != null ) { programmer Box . set Selected Item ( Prog Default . get Default Prog File ( ) ) ; } pane 3 a . add ( programmer Box ) ; add ( pane 3 a ) ; }
private void add Programmer Box ( ) { J Panel pane 3 a = new J Panel ( ) ; pane 3 a . set Layout ( new Box Layout ( pane 3 a , Box Layout . X AXIS ) ) ; pane 3 a . add ( new J Label ( Bundle . get Message ( STRING ) ) ) ; programmer Box = new J Combo Box < String > ( Prog Default . find List Of Prog Files ( ) ) ; programmer Box . set Selected Index ( NUM ) ; if ( Prog Default . get Default Prog File ( ) != null ) { programmer Box . set Selected Item ( Prog Default . get Default Prog File ( ) ) ; } pane 3 a . add ( programmer Box ) ; add ( pane 3 a ) ; }
public void create And Send Move To Action ( final Point 2 D point , boolean double Click ) { final RP Action action = new RP Action ( ) ; action . put ( STRING , STRING ) ; action . put ( STRING , ( int ) point . get X ( ) ) ; action . put ( STRING , ( int ) point . get Y ( ) ) ; if ( double Click ) { action . put ( STRING , STRING ) ; } Direction dir = calculate Zone Change Direction ( point ) ; if ( dir != null ) { action . put ( STRING , dir . ordinal ( ) ) ; } client . send ( action ) ; }
private String generate S 3 Path ( String path Prefix Parent , String topology Name , String filename ) { List < String > path Parts = new Array List < > ( Arrays . as List ( path Prefix Parent . split ( STRING ) ) ) ; path Parts . add ( topology Name ) ; path Parts . add ( filename ) ; return String . join ( STRING , path Parts ) ; }
public boolean supports ( @ Magic Constant ( flags From Class = Features . class ) int capability ) { I Android Target target = get Target ( ) ; if ( target != null ) { return Render Service . supports Capability ( get Module ( ) , target , capability ) ; } return BOOL ; }
public boolean supports ( @ Magic Constant ( flags From Class = Features . class ) int capability ) { I Android Target target = get Target ( ) ; if ( target != null ) { return Render Service . supports Capability ( get Module ( ) , target , capability ) ; } return BOOL ; }
public void add Primary ( int part , int heap , long offheap , long swap ) { primary . add ( new Visor Cache Partition ( part , heap , offheap , swap ) ) ; }
private static String listify ( final Collection < String > registers ) { final List < String > register List = new Array List < String > ( registers ) ; Collections . sort ( register List ) ; return Commafier . commafy ( register List ) ; }
private static String listify ( final Collection < String > registers ) { final List < String > register List = new Array List < String > ( registers ) ; Collections . sort ( register List ) ; return Commafier . commafy ( register List ) ; }
private static String listify ( final Collection < String > registers ) { final List < String > register List = new Array List < String > ( registers ) ; Collections . sort ( register List ) ; return Commafier . commafy ( register List ) ; }
private static String listify ( final Collection < String > registers ) { final List < String > register List = new Array List < String > ( registers ) ; Collections . sort ( register List ) ; return Commafier . commafy ( register List ) ; }
public void remove ( symbol sym ) throws internal error { not null ( sym ) ; all . remove ( sym . name ( ) ) ; }
public void start ( ) throws Exception { if ( dbsvc != null ) { return ; } Data Object Scanner data Object Scanner = new Data Object Scanner ( ) ; data Object Scanner . set Packages ( model Packages . to Array ( new String [ NUM ] ) ) ; data Object Scanner . init ( ) ; Service Impl dummy DB Service = new Service Impl ( ) ; dummy DB Service . set Name ( STRING ) ; dummy DB Service . set Version ( STRING ) ; dummy DB Service . set Endpoint ( URI . create ( STRING ) ) ; dummy DB Service . set Id ( STRING ) ; Schema Util schema Util = new Schema Util ( ) ; schema Util . set Keyspace Name ( STRING ) ; schema Util . set Service ( dummy DB Service ) ; schema Util . set Coordinator ( coordinator Client ) ; schema Util . set Data Object Scanner ( data Object Scanner ) ; String config = create Config ( data Dir . get Absolute Path ( ) ) ; dbsvc = new Db Service Impl ( ) ; dbsvc . set Config ( config ) ; dbsvc . set Schema Util ( schema Util ) ; dbsvc . set Coordinator ( coordinator Client ) ; dbsvc . set Service ( dummy DB Service ) ; dbsvc . start ( ) ; }
public void start ( ) throws Exception { if ( dbsvc != null ) { return ; } Data Object Scanner data Object Scanner = new Data Object Scanner ( ) ; data Object Scanner . set Packages ( model Packages . to Array ( new String [ NUM ] ) ) ; data Object Scanner . init ( ) ; Service Impl dummy DB Service = new Service Impl ( ) ; dummy DB Service . set Name ( STRING ) ; dummy DB Service . set Version ( STRING ) ; dummy DB Service . set Endpoint ( URI . create ( STRING ) ) ; dummy DB Service . set Id ( STRING ) ; Schema Util schema Util = new Schema Util ( ) ; schema Util . set Keyspace Name ( STRING ) ; schema Util . set Service ( dummy DB Service ) ; schema Util . set Coordinator ( coordinator Client ) ; schema Util . set Data Object Scanner ( data Object Scanner ) ; String config = create Config ( data Dir . get Absolute Path ( ) ) ; dbsvc = new Db Service Impl ( ) ; dbsvc . set Config ( config ) ; dbsvc . set Schema Util ( schema Util ) ; dbsvc . set Coordinator ( coordinator Client ) ; dbsvc . set Service ( dummy DB Service ) ; dbsvc . start ( ) ; }
public void initialize ( int initial Pool Size ) { candidates . clear ( ) ; add Random Candidates ( initial Pool Size ) ; }
public void initialize ( int initial Pool Size ) { candidates . clear ( ) ; add Random Candidates ( initial Pool Size ) ; }
public void initialize ( int initial Pool Size ) { candidates . clear ( ) ; add Random Candidates ( initial Pool Size ) ; }
public void initialize ( int initial Pool Size ) { candidates . clear ( ) ; add Random Candidates ( initial Pool Size ) ; }
public void initialize ( int initial Pool Size ) { candidates . clear ( ) ; add Random Candidates ( initial Pool Size ) ; }
public String construct Train Number Of Cars ( String train Name ) throws IO Exception { Train train = tm . get Train By Name ( train Name ) ; if ( train != null ) { return String . value Of ( train . get Number Cars In Train ( ) ) ; } send Error Status ( STRING + train Name ) ; return null ; }
public String construct Train Number Of Cars ( String train Name ) throws IO Exception { Train train = tm . get Train By Name ( train Name ) ; if ( train != null ) { return String . value Of ( train . get Number Cars In Train ( ) ) ; } send Error Status ( STRING + train Name ) ; return null ; }
public Memorizing Trust Manager ( Context m , X509 Trust Manager default Trust Manager ) { init ( m ) ; this . app Trust Manager = get Trust Manager ( app Key Store ) ; this . default Trust Manager = default Trust Manager ; }
public abstract void internal Prepare ( Output Collector collector , I Metadata Change Notify Service metadata Manager , Config config , Topology Context context ) ;
public abstract void internal Prepare ( Output Collector collector , I Metadata Change Notify Service metadata Manager , Config config , Topology Context context ) ;
private void force Kill Application ( Application Id app Id ) throws Yarn Exception , IO Exception { yarn Client . kill Application ( app Id ) ; }
private void force Kill Application ( Application Id app Id ) throws Yarn Exception , IO Exception { yarn Client . kill Application ( app Id ) ; }
static public Analysis Context current Analysis Context ( ) { return current Analysis Context . get ( ) ; }
public void open Popup ( ) { if ( settings == null ) { return ; } if ( ! is Enabled ( ) ) { return ; } if ( ! date Text Field . has Focus ( ) ) { date Text Field . request Focus In Window ( ) ; } Local Date selected Date For Calendar = last Valid Date ; Date Picker this Date Picker = this ; calendar Panel = new Calendar Panel ( this Date Picker ) ; if ( selected Date For Calendar != null ) { calendar Panel . set Selected Date ( selected Date For Calendar ) ; } popup = new Custom Popup ( calendar Panel , Swing Utilities . get Window Ancestor ( this ) , this , settings . get Border Calendar Popup ( ) ) ; int default X = toggle Calendar Button . get Location On Screen ( ) . x + toggle Calendar Button . get Bounds ( ) . width - popup . get Bounds ( ) . width - NUM ; int default Y = toggle Calendar Button . get Location On Screen ( ) . y + toggle Calendar Button . get Bounds ( ) . height + NUM ; z Set Popup Location ( popup , default X , default Y , this , date Text Field , NUM , NUM ) ; popup . show ( ) ; calendar Panel . request Focus ( ) ; }
public void open Popup ( ) { if ( settings == null ) { return ; } if ( ! is Enabled ( ) ) { return ; } if ( ! date Text Field . has Focus ( ) ) { date Text Field . request Focus In Window ( ) ; } Local Date selected Date For Calendar = last Valid Date ; Date Picker this Date Picker = this ; calendar Panel = new Calendar Panel ( this Date Picker ) ; if ( selected Date For Calendar != null ) { calendar Panel . set Selected Date ( selected Date For Calendar ) ; } popup = new Custom Popup ( calendar Panel , Swing Utilities . get Window Ancestor ( this ) , this , settings . get Border Calendar Popup ( ) ) ; int default X = toggle Calendar Button . get Location On Screen ( ) . x + toggle Calendar Button . get Bounds ( ) . width - popup . get Bounds ( ) . width - NUM ; int default Y = toggle Calendar Button . get Location On Screen ( ) . y + toggle Calendar Button . get Bounds ( ) . height + NUM ; z Set Popup Location ( popup , default X , default Y , this , date Text Field , NUM , NUM ) ; popup . show ( ) ; calendar Panel . request Focus ( ) ; }
public void open Popup ( ) { if ( settings == null ) { return ; } if ( ! is Enabled ( ) ) { return ; } if ( ! date Text Field . has Focus ( ) ) { date Text Field . request Focus In Window ( ) ; } Local Date selected Date For Calendar = last Valid Date ; Date Picker this Date Picker = this ; calendar Panel = new Calendar Panel ( this Date Picker ) ; if ( selected Date For Calendar != null ) { calendar Panel . set Selected Date ( selected Date For Calendar ) ; } popup = new Custom Popup ( calendar Panel , Swing Utilities . get Window Ancestor ( this ) , this , settings . get Border Calendar Popup ( ) ) ; int default X = toggle Calendar Button . get Location On Screen ( ) . x + toggle Calendar Button . get Bounds ( ) . width - popup . get Bounds ( ) . width - NUM ; int default Y = toggle Calendar Button . get Location On Screen ( ) . y + toggle Calendar Button . get Bounds ( ) . height + NUM ; z Set Popup Location ( popup , default X , default Y , this , date Text Field , NUM , NUM ) ; popup . show ( ) ; calendar Panel . request Focus ( ) ; }
public void open Popup ( ) { if ( settings == null ) { return ; } if ( ! is Enabled ( ) ) { return ; } if ( ! date Text Field . has Focus ( ) ) { date Text Field . request Focus In Window ( ) ; } Local Date selected Date For Calendar = last Valid Date ; Date Picker this Date Picker = this ; calendar Panel = new Calendar Panel ( this Date Picker ) ; if ( selected Date For Calendar != null ) { calendar Panel . set Selected Date ( selected Date For Calendar ) ; } popup = new Custom Popup ( calendar Panel , Swing Utilities . get Window Ancestor ( this ) , this , settings . get Border Calendar Popup ( ) ) ; int default X = toggle Calendar Button . get Location On Screen ( ) . x + toggle Calendar Button . get Bounds ( ) . width - popup . get Bounds ( ) . width - NUM ; int default Y = toggle Calendar Button . get Location On Screen ( ) . y + toggle Calendar Button . get Bounds ( ) . height + NUM ; z Set Popup Location ( popup , default X , default Y , this , date Text Field , NUM , NUM ) ; popup . show ( ) ; calendar Panel . request Focus ( ) ; }
public static void remove Connection List ( Integer tab ) { TABBED CONNECTIONS . remove ( tab . int Value ( ) ) ; }
public static int to Chars ( int [ ] src , int src Off , int src Len , char [ ] dest , int dest Off ) { if ( src Len < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } int written = NUM ; for ( int i = NUM ; i < src Len ; ++ i ) { written += Character . to Chars ( src [ src Off + i ] , dest , dest Off + written ) ; } return written ; }
public static int to Chars ( int [ ] src , int src Off , int src Len , char [ ] dest , int dest Off ) { if ( src Len < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } int written = NUM ; for ( int i = NUM ; i < src Len ; ++ i ) { written += Character . to Chars ( src [ src Off + i ] , dest , dest Off + written ) ; } return written ; }
protected boolean try Again ( ) { if ( ! is Cancelled ( ) ) { try { value = request . request ( ) ; time For Next Request = - NUM ; is Done = BOOL ; } catch ( Rate Limit Exception e ) { time For Next Request = System . current Time Millis ( ) + e . get Retry Delay ( ) ; bucket = e . get Method ( ) ; } } return is Done ( ) || is Cancelled ( ) ; }
public static < T > Set < T > empty Set ( final Set < T > set ) { return ( set != null ? set : Collections . < T > empty Set ( ) ) ; }
public static < T > Set < T > empty Set ( final Set < T > set ) { return ( set != null ? set : Collections . < T > empty Set ( ) ) ; }
public void fill Default Values ( ) { tf Learning Rate . set Text ( Double . to String ( Hebbian CPCA Rule . DEFAULT LEARNING RATE ) ) ; tf M . set Text ( Double . to String ( Hebbian CPCA Rule . DEFAULT M ) ) ; tf Theta . set Text ( Double . to String ( Hebbian CPCA Rule . DEFAULT THETA ) ) ; tf Lambda . set Text ( Double . to String ( Hebbian CPCA Rule . DEFAULT LAMBDA ) ) ; }
public void fill Default Values ( ) { tf Learning Rate . set Text ( Double . to String ( Hebbian CPCA Rule . DEFAULT LEARNING RATE ) ) ; tf M . set Text ( Double . to String ( Hebbian CPCA Rule . DEFAULT M ) ) ; tf Theta . set Text ( Double . to String ( Hebbian CPCA Rule . DEFAULT THETA ) ) ; tf Lambda . set Text ( Double . to String ( Hebbian CPCA Rule . DEFAULT LAMBDA ) ) ; }
public String sql select ( String vendor Name , String catalog Name , String schema Name , String table Name , String condition ) { Array List < String > column Names = null ; Array List < String > alias Names = null ; Array List < String > conditions = null ; Array List < String > sort Columns = null ; if ( condition != null && condition . length ( ) > NUM ) { conditions = new Array List < String > ( ) ; conditions . add ( condition ) ; } return sql select ( vendor Name , catalog Name , schema Name , table Name , null , column Names , alias Names , conditions , sort Columns , BOOL ) ; }
protected int align ( int e ) { int lostdigit = NUM ; boolean inexact = BOOL ; int diff = exp - e ; int adiff = diff ; if ( adiff < NUM ) { adiff = - adiff ; } if ( diff == NUM ) { return NUM ; } if ( adiff > ( mant . length + NUM ) ) { Arrays . fill ( mant , NUM ) ; exp = e ; field . set IEEE Flags Bits ( Dfp Field . FLAG INEXACT ) ; dotrap ( Dfp Field . FLAG INEXACT , ALIGN TRAP , this , this ) ; return NUM ; } for ( int i = NUM ; i < adiff ; i ++ ) { if ( diff < NUM ) { if ( lostdigit != NUM ) { inexact = BOOL ; } lostdigit = mant [ NUM ] ; shift Right ( ) ; } else { shift Left ( ) ; } } if ( inexact ) { field . set IEEE Flags Bits ( Dfp Field . FLAG INEXACT ) ; dotrap ( Dfp Field . FLAG INEXACT , ALIGN TRAP , this , this ) ; } return lostdigit ; }
protected int align ( int e ) { int lostdigit = NUM ; boolean inexact = BOOL ; int diff = exp - e ; int adiff = diff ; if ( adiff < NUM ) { adiff = - adiff ; } if ( diff == NUM ) { return NUM ; } if ( adiff > ( mant . length + NUM ) ) { Arrays . fill ( mant , NUM ) ; exp = e ; field . set IEEE Flags Bits ( Dfp Field . FLAG INEXACT ) ; dotrap ( Dfp Field . FLAG INEXACT , ALIGN TRAP , this , this ) ; return NUM ; } for ( int i = NUM ; i < adiff ; i ++ ) { if ( diff < NUM ) { if ( lostdigit != NUM ) { inexact = BOOL ; } lostdigit = mant [ NUM ] ; shift Right ( ) ; } else { shift Left ( ) ; } } if ( inexact ) { field . set IEEE Flags Bits ( Dfp Field . FLAG INEXACT ) ; dotrap ( Dfp Field . FLAG INEXACT , ALIGN TRAP , this , this ) ; } return lostdigit ; }
protected int align ( int e ) { int lostdigit = NUM ; boolean inexact = BOOL ; int diff = exp - e ; int adiff = diff ; if ( adiff < NUM ) { adiff = - adiff ; } if ( diff == NUM ) { return NUM ; } if ( adiff > ( mant . length + NUM ) ) { Arrays . fill ( mant , NUM ) ; exp = e ; field . set IEEE Flags Bits ( Dfp Field . FLAG INEXACT ) ; dotrap ( Dfp Field . FLAG INEXACT , ALIGN TRAP , this , this ) ; return NUM ; } for ( int i = NUM ; i < adiff ; i ++ ) { if ( diff < NUM ) { if ( lostdigit != NUM ) { inexact = BOOL ; } lostdigit = mant [ NUM ] ; shift Right ( ) ; } else { shift Left ( ) ; } } if ( inexact ) { field . set IEEE Flags Bits ( Dfp Field . FLAG INEXACT ) ; dotrap ( Dfp Field . FLAG INEXACT , ALIGN TRAP , this , this ) ; } return lostdigit ; }
protected int align ( int e ) { int lostdigit = NUM ; boolean inexact = BOOL ; int diff = exp - e ; int adiff = diff ; if ( adiff < NUM ) { adiff = - adiff ; } if ( diff == NUM ) { return NUM ; } if ( adiff > ( mant . length + NUM ) ) { Arrays . fill ( mant , NUM ) ; exp = e ; field . set IEEE Flags Bits ( Dfp Field . FLAG INEXACT ) ; dotrap ( Dfp Field . FLAG INEXACT , ALIGN TRAP , this , this ) ; return NUM ; } for ( int i = NUM ; i < adiff ; i ++ ) { if ( diff < NUM ) { if ( lostdigit != NUM ) { inexact = BOOL ; } lostdigit = mant [ NUM ] ; shift Right ( ) ; } else { shift Left ( ) ; } } if ( inexact ) { field . set IEEE Flags Bits ( Dfp Field . FLAG INEXACT ) ; dotrap ( Dfp Field . FLAG INEXACT , ALIGN TRAP , this , this ) ; } return lostdigit ; }
protected int align ( int e ) { int lostdigit = NUM ; boolean inexact = BOOL ; int diff = exp - e ; int adiff = diff ; if ( adiff < NUM ) { adiff = - adiff ; } if ( diff == NUM ) { return NUM ; } if ( adiff > ( mant . length + NUM ) ) { Arrays . fill ( mant , NUM ) ; exp = e ; field . set IEEE Flags Bits ( Dfp Field . FLAG INEXACT ) ; dotrap ( Dfp Field . FLAG INEXACT , ALIGN TRAP , this , this ) ; return NUM ; } for ( int i = NUM ; i < adiff ; i ++ ) { if ( diff < NUM ) { if ( lostdigit != NUM ) { inexact = BOOL ; } lostdigit = mant [ NUM ] ; shift Right ( ) ; } else { shift Left ( ) ; } } if ( inexact ) { field . set IEEE Flags Bits ( Dfp Field . FLAG INEXACT ) ; dotrap ( Dfp Field . FLAG INEXACT , ALIGN TRAP , this , this ) ; } return lostdigit ; }
protected int align ( int e ) { int lostdigit = NUM ; boolean inexact = BOOL ; int diff = exp - e ; int adiff = diff ; if ( adiff < NUM ) { adiff = - adiff ; } if ( diff == NUM ) { return NUM ; } if ( adiff > ( mant . length + NUM ) ) { Arrays . fill ( mant , NUM ) ; exp = e ; field . set IEEE Flags Bits ( Dfp Field . FLAG INEXACT ) ; dotrap ( Dfp Field . FLAG INEXACT , ALIGN TRAP , this , this ) ; return NUM ; } for ( int i = NUM ; i < adiff ; i ++ ) { if ( diff < NUM ) { if ( lostdigit != NUM ) { inexact = BOOL ; } lostdigit = mant [ NUM ] ; shift Right ( ) ; } else { shift Left ( ) ; } } if ( inexact ) { field . set IEEE Flags Bits ( Dfp Field . FLAG INEXACT ) ; dotrap ( Dfp Field . FLAG INEXACT , ALIGN TRAP , this , this ) ; } return lostdigit ; }
protected int align ( int e ) { int lostdigit = NUM ; boolean inexact = BOOL ; int diff = exp - e ; int adiff = diff ; if ( adiff < NUM ) { adiff = - adiff ; } if ( diff == NUM ) { return NUM ; } if ( adiff > ( mant . length + NUM ) ) { Arrays . fill ( mant , NUM ) ; exp = e ; field . set IEEE Flags Bits ( Dfp Field . FLAG INEXACT ) ; dotrap ( Dfp Field . FLAG INEXACT , ALIGN TRAP , this , this ) ; return NUM ; } for ( int i = NUM ; i < adiff ; i ++ ) { if ( diff < NUM ) { if ( lostdigit != NUM ) { inexact = BOOL ; } lostdigit = mant [ NUM ] ; shift Right ( ) ; } else { shift Left ( ) ; } } if ( inexact ) { field . set IEEE Flags Bits ( Dfp Field . FLAG INEXACT ) ; dotrap ( Dfp Field . FLAG INEXACT , ALIGN TRAP , this , this ) ; } return lostdigit ; }
protected int align ( int e ) { int lostdigit = NUM ; boolean inexact = BOOL ; int diff = exp - e ; int adiff = diff ; if ( adiff < NUM ) { adiff = - adiff ; } if ( diff == NUM ) { return NUM ; } if ( adiff > ( mant . length + NUM ) ) { Arrays . fill ( mant , NUM ) ; exp = e ; field . set IEEE Flags Bits ( Dfp Field . FLAG INEXACT ) ; dotrap ( Dfp Field . FLAG INEXACT , ALIGN TRAP , this , this ) ; return NUM ; } for ( int i = NUM ; i < adiff ; i ++ ) { if ( diff < NUM ) { if ( lostdigit != NUM ) { inexact = BOOL ; } lostdigit = mant [ NUM ] ; shift Right ( ) ; } else { shift Left ( ) ; } } if ( inexact ) { field . set IEEE Flags Bits ( Dfp Field . FLAG INEXACT ) ; dotrap ( Dfp Field . FLAG INEXACT , ALIGN TRAP , this , this ) ; } return lostdigit ; }
static public B Tree do Insert Random Sparse Key Sequence Test ( final B Tree btree , final int ninserts , final int trace ) { final int keys [ ] = new int [ ninserts ] ; final Simple Entry entries [ ] = new Simple Entry [ ninserts ] ; final Random r = new Random ( ) ; int last Key = NUM ; for ( int i = NUM ; i < ninserts ; i ++ ) { final int key = r . next Int ( NUM ) + last Key + NUM ; keys [ i ] = key ; entries [ i ] = new Simple Entry ( ) ; last Key = key ; } return do Insert Random Key Sequence Test ( btree , keys , entries , trace ) ; }
static public B Tree do Insert Random Sparse Key Sequence Test ( final B Tree btree , final int ninserts , final int trace ) { final int keys [ ] = new int [ ninserts ] ; final Simple Entry entries [ ] = new Simple Entry [ ninserts ] ; final Random r = new Random ( ) ; int last Key = NUM ; for ( int i = NUM ; i < ninserts ; i ++ ) { final int key = r . next Int ( NUM ) + last Key + NUM ; keys [ i ] = key ; entries [ i ] = new Simple Entry ( ) ; last Key = key ; } return do Insert Random Key Sequence Test ( btree , keys , entries , trace ) ; }
static public B Tree do Insert Random Sparse Key Sequence Test ( final B Tree btree , final int ninserts , final int trace ) { final int keys [ ] = new int [ ninserts ] ; final Simple Entry entries [ ] = new Simple Entry [ ninserts ] ; final Random r = new Random ( ) ; int last Key = NUM ; for ( int i = NUM ; i < ninserts ; i ++ ) { final int key = r . next Int ( NUM ) + last Key + NUM ; keys [ i ] = key ; entries [ i ] = new Simple Entry ( ) ; last Key = key ; } return do Insert Random Key Sequence Test ( btree , keys , entries , trace ) ; }
static public B Tree do Insert Random Sparse Key Sequence Test ( final B Tree btree , final int ninserts , final int trace ) { final int keys [ ] = new int [ ninserts ] ; final Simple Entry entries [ ] = new Simple Entry [ ninserts ] ; final Random r = new Random ( ) ; int last Key = NUM ; for ( int i = NUM ; i < ninserts ; i ++ ) { final int key = r . next Int ( NUM ) + last Key + NUM ; keys [ i ] = key ; entries [ i ] = new Simple Entry ( ) ; last Key = key ; } return do Insert Random Key Sequence Test ( btree , keys , entries , trace ) ; }
static public B Tree do Insert Random Sparse Key Sequence Test ( final B Tree btree , final int ninserts , final int trace ) { final int keys [ ] = new int [ ninserts ] ; final Simple Entry entries [ ] = new Simple Entry [ ninserts ] ; final Random r = new Random ( ) ; int last Key = NUM ; for ( int i = NUM ; i < ninserts ; i ++ ) { final int key = r . next Int ( NUM ) + last Key + NUM ; keys [ i ] = key ; entries [ i ] = new Simple Entry ( ) ; last Key = key ; } return do Insert Random Key Sequence Test ( btree , keys , entries , trace ) ; }
private void read Class File ( Class Symbol c ) throws IO Exception { int magic = next Int ( ) ; if ( magic != JAVA MAGIC ) throw bad Class File ( STRING ) ; minor Version = next Char ( ) ; major Version = next Char ( ) ; int max Major = Target . MAX ( ) . major Version ; int max Minor = Target . MAX ( ) . minor Version ; if ( major Version > max Major || major Version * NUM + minor Version < Target . MIN ( ) . major Version * NUM + Target . MIN ( ) . minor Version ) { if ( major Version == ( max Major + NUM ) ) log . warning ( STRING , current Class File , major Version , max Major ) ; else throw bad Class File ( STRING , Integer . to String ( major Version ) , Integer . to String ( minor Version ) , Integer . to String ( max Major ) , Integer . to String ( max Minor ) ) ; } else if ( check Class File && major Version == max Major && minor Version > max Minor ) { print CCF ( STRING , Integer . to String ( minor Version ) ) ; } index Pool ( ) ; if ( signature Buffer . length < bp ) { int ns = Integer . highest One Bit ( bp ) << NUM ; signature Buffer = new byte [ ns ] ; } read Class ( c ) ; }
public void clear Cache ( ) { clear Memory Cache ( ) ; clear Disk Cache ( ) ; }
public void clear Cache ( ) { clear Memory Cache ( ) ; clear Disk Cache ( ) ; }
public void clear Cache ( ) { clear Memory Cache ( ) ; clear Disk Cache ( ) ; }
public void clear Cache ( ) { clear Memory Cache ( ) ; clear Disk Cache ( ) ; }
protected int select Item ( Int Sorted Set remaining I , List < Tuple 2 od < I > > list ) { double [ ] max = new double [ ] { Double . NEGATIVE INFINITY } ; int [ ] best I = new int [ ] { remaining I . first Int ( ) } ; remaining I . for Each ( null ) ; return best I [ NUM ] ; }
protected int select Item ( Int Sorted Set remaining I , List < Tuple 2 od < I > > list ) { double [ ] max = new double [ ] { Double . NEGATIVE INFINITY } ; int [ ] best I = new int [ ] { remaining I . first Int ( ) } ; remaining I . for Each ( null ) ; return best I [ NUM ] ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static String Builder append Quoted String ( String Builder target , String key ) { target . append ( STRING ) ; for ( int i = NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . char At ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
private Vbri Frame ( Byte Buffer header ) { this . header = header ; header . rewind ( ) ; header . position ( NUM ) ; set Audio Size ( ) ; set Frame Count ( ) ; }
protected void wait For Shutdown Signal ( ) throws Interrupted Exception { if ( mutex Waiting == null ) { mutex Waiting = new Object ( ) ; } try { synchronized ( mutex Waiting ) { mutex Waiting . wait ( ) ; } } catch ( Interrupted Exception e ) { if ( ! shutdown ) { throw e ; } } }
protected void wait For Shutdown Signal ( ) throws Interrupted Exception { if ( mutex Waiting == null ) { mutex Waiting = new Object ( ) ; } try { synchronized ( mutex Waiting ) { mutex Waiting . wait ( ) ; } } catch ( Interrupted Exception e ) { if ( ! shutdown ) { throw e ; } } }
protected void wait For Shutdown Signal ( ) throws Interrupted Exception { if ( mutex Waiting == null ) { mutex Waiting = new Object ( ) ; } try { synchronized ( mutex Waiting ) { mutex Waiting . wait ( ) ; } } catch ( Interrupted Exception e ) { if ( ! shutdown ) { throw e ; } } }
protected void wait For Shutdown Signal ( ) throws Interrupted Exception { if ( mutex Waiting == null ) { mutex Waiting = new Object ( ) ; } try { synchronized ( mutex Waiting ) { mutex Waiting . wait ( ) ; } } catch ( Interrupted Exception e ) { if ( ! shutdown ) { throw e ; } } }
protected void wait For Shutdown Signal ( ) throws Interrupted Exception { if ( mutex Waiting == null ) { mutex Waiting = new Object ( ) ; } try { synchronized ( mutex Waiting ) { mutex Waiting . wait ( ) ; } } catch ( Interrupted Exception e ) { if ( ! shutdown ) { throw e ; } } }
protected void wait For Shutdown Signal ( ) throws Interrupted Exception { if ( mutex Waiting == null ) { mutex Waiting = new Object ( ) ; } try { synchronized ( mutex Waiting ) { mutex Waiting . wait ( ) ; } } catch ( Interrupted Exception e ) { if ( ! shutdown ) { throw e ; } } }
public Array List < Value > keys ( ) { Array List < Value > list = New . array List ( size ) ; for ( Value k : keys ) { if ( k != null && k != Value Null . DELETED ) { list . add ( k ) ; } } return list ; }
public synchronized void add Pan Listener ( Pan Listener listener ) { m Pan Listeners . add ( listener ) ; }
private static Big Integer value Of ( int val [ ] ) { return ( val [ NUM ] > NUM ? new Big Integer ( val , NUM ) : new Big Integer ( val ) ) ; }
private static Big Integer value Of ( int val [ ] ) { return ( val [ NUM ] > NUM ? new Big Integer ( val , NUM ) : new Big Integer ( val ) ) ; }
public boolean show ( Container c , int x , int y , int w , int h ) { synchronized ( this ) { if ( painting ) { return BOOL ; } showing = BOOL ; } try { Buffer Info info = get Buffer Info ( c ) ; Buffer Strategy buffer Strategy ; if ( info != null && info . is In Sync ( ) && ( buffer Strategy = info . get Buffer Strategy ( BOOL ) ) != null ) { Sub Region Showable bs Sub Region = ( Sub Region Showable ) buffer Strategy ; boolean paint All On Expose = info . get Paint All On Expose ( ) ; info . set Paint All On Expose ( BOOL ) ; if ( bs Sub Region . show If Not Lost ( x , y , ( x + w ) , ( y + h ) ) ) { return ! paint All On Expose ; } buffer Info . set Contents Lost During Expose ( BOOL ) ; } } finally { synchronized ( this ) { showing = BOOL ; notify All ( ) ; } } return BOOL ; }
public boolean show ( Container c , int x , int y , int w , int h ) { synchronized ( this ) { if ( painting ) { return BOOL ; } showing = BOOL ; } try { Buffer Info info = get Buffer Info ( c ) ; Buffer Strategy buffer Strategy ; if ( info != null && info . is In Sync ( ) && ( buffer Strategy = info . get Buffer Strategy ( BOOL ) ) != null ) { Sub Region Showable bs Sub Region = ( Sub Region Showable ) buffer Strategy ; boolean paint All On Expose = info . get Paint All On Expose ( ) ; info . set Paint All On Expose ( BOOL ) ; if ( bs Sub Region . show If Not Lost ( x , y , ( x + w ) , ( y + h ) ) ) { return ! paint All On Expose ; } buffer Info . set Contents Lost During Expose ( BOOL ) ; } } finally { synchronized ( this ) { showing = BOOL ; notify All ( ) ; } } return BOOL ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
private int calculate Stroke Weight ( ) { int stroke Weight = ( int ) ( get Stroke Width ( ) * NUM ) ; LOGGER . trace ( STRING , stroke Width ) ; return stroke Weight ; }
@ Suppress Warnings ( STRING ) public static float value Range Limit ( float value , float start Value , float end Value ) { if ( value < Math . min ( start Value , end Value ) ) return Math . min ( start Value , end Value ) ; if ( value > Math . max ( start Value , end Value ) ) return Math . max ( start Value , end Value ) ; return value ; }
@ Suppress Warnings ( STRING ) public static float value Range Limit ( float value , float start Value , float end Value ) { if ( value < Math . min ( start Value , end Value ) ) return Math . min ( start Value , end Value ) ; if ( value > Math . max ( start Value , end Value ) ) return Math . max ( start Value , end Value ) ; return value ; }
@ Nullable private List < String > to Array ( @ Nullable String s , @ Not Null String separators , @ Nullable List < Boolean > markers ) { if ( s == null ) return null ; s = s . trim ( ) ; if ( s . is Empty ( ) ) return null ; boolean p2 nl = markers != null && my Settings . JD P AT EMPTY LINES ; List < String > list = new Array List < String > ( ) ; String Tokenizer st = new String Tokenizer ( s , separators , BOOL ) ; boolean first = BOOL ; int pre Count = NUM ; int cur Pos = NUM ; while ( st . has More Tokens ( ) ) { String token = st . next Token ( ) ; cur Pos += token . length ( ) ; if ( separators . contains ( token ) ) { if ( ! first ) { list . add ( STRING ) ; if ( markers != null ) markers . add ( Boolean . value Of ( pre Count > NUM ) ) ; } first = BOOL ; } else { first = BOOL ; if ( p2 nl ) { if ( is Para Tag ( token ) && s . index Of ( P END TAG , cur Pos ) < NUM ) { list . add ( STRING ) ; markers . add ( Boolean . value Of ( pre Count > NUM ) ) ; continue ; } } if ( pre Count == NUM ) token = token . trim ( ) ; list . add ( token ) ; if ( markers != null ) { if ( token . contains ( PRE TAG START ) ) pre Count ++ ; markers . add ( Boolean . value Of ( pre Count > NUM ) ) ; if ( token . contains ( PRE TAG END ) ) pre Count -- ; } } } return list ; }
@ Nullable private List < String > to Array ( @ Nullable String s , @ Not Null String separators , @ Nullable List < Boolean > markers ) { if ( s == null ) return null ; s = s . trim ( ) ; if ( s . is Empty ( ) ) return null ; boolean p2 nl = markers != null && my Settings . JD P AT EMPTY LINES ; List < String > list = new Array List < String > ( ) ; String Tokenizer st = new String Tokenizer ( s , separators , BOOL ) ; boolean first = BOOL ; int pre Count = NUM ; int cur Pos = NUM ; while ( st . has More Tokens ( ) ) { String token = st . next Token ( ) ; cur Pos += token . length ( ) ; if ( separators . contains ( token ) ) { if ( ! first ) { list . add ( STRING ) ; if ( markers != null ) markers . add ( Boolean . value Of ( pre Count > NUM ) ) ; } first = BOOL ; } else { first = BOOL ; if ( p2 nl ) { if ( is Para Tag ( token ) && s . index Of ( P END TAG , cur Pos ) < NUM ) { list . add ( STRING ) ; markers . add ( Boolean . value Of ( pre Count > NUM ) ) ; continue ; } } if ( pre Count == NUM ) token = token . trim ( ) ; list . add ( token ) ; if ( markers != null ) { if ( token . contains ( PRE TAG START ) ) pre Count ++ ; markers . add ( Boolean . value Of ( pre Count > NUM ) ) ; if ( token . contains ( PRE TAG END ) ) pre Count -- ; } } } return list ; }
public void remove User Message Listener ( User Message Listener user Message Listener ) { user Message Listeners . remove ( user Message Listener ) ; }
@ Override public void create Control ( Composite parent ) { initialize Dialog Units ( parent ) ; Composite composite = new Composite ( parent , SWT . NULL ) ; composite . set Layout ( new Grid Layout ( ) ) ; composite . set Layout Data ( new Grid Data ( Grid Data . VERTICAL ALIGN FILL | Grid Data . HORIZONTAL ALIGN FILL ) ) ; composite . set Font ( parent . get Font ( ) ) ; create Export Goups ( composite ) ; restore Widget Values ( ) ; if ( initial Resource Selection != null ) { setup Based On Initial Selections ( ) ; } update Widget Enablements ( ) ; set Page Complete ( determine Page Completion ( ) ) ; set Error Message ( null ) ; set Control ( composite ) ; give Focus To Destination ( ) ; }
@ Override public void create Control ( Composite parent ) { initialize Dialog Units ( parent ) ; Composite composite = new Composite ( parent , SWT . NULL ) ; composite . set Layout ( new Grid Layout ( ) ) ; composite . set Layout Data ( new Grid Data ( Grid Data . VERTICAL ALIGN FILL | Grid Data . HORIZONTAL ALIGN FILL ) ) ; composite . set Font ( parent . get Font ( ) ) ; create Export Goups ( composite ) ; restore Widget Values ( ) ; if ( initial Resource Selection != null ) { setup Based On Initial Selections ( ) ; } update Widget Enablements ( ) ; set Page Complete ( determine Page Completion ( ) ) ; set Error Message ( null ) ; set Control ( composite ) ; give Focus To Destination ( ) ; }
public void delete ( @ Nonnull Integer id ) throws Hibernate Exception { Entity Manager em = get Entity Manager ( ) ; try { begin ( ) ; T ENTITY entity = em . find ( entity Class , id ) ; if ( entity != null ) { LOG . debug ( STRING + entity . to String ( ) ) ; em . remove ( entity ) ; } commit ( ) ; } catch ( Exception e ) { rollback ( ) ; e . print Stack Trace ( ) ; throw new Runtime Exception ( e ) ; } finally { cleanup ( ) ; } }
public void remove Activity ( Activity activity ) { if ( activity Stack == null ) { activity Stack = new Stack < Activity > ( ) ; } activity Stack . remove ( activity ) ; }
public String list ( String dir ) throws IO Exception { passive ( ) ; send ( STRING + dir ) ; read Code ( NUM ) ; Byte Array Output Stream out = new Byte Array Output Stream ( ) ; IO Utils . copy And Close ( in Data , out ) ; read Code ( NUM ) ; byte [ ] data = out . to Byte Array ( ) ; return new String ( data ) ; }
private synchronized I Mqtt Token remove Mqtt Token ( Bundle data ) { String activity Token = data . get String ( Mqtt Service Constants . CALLBACK ACTIVITY TOKEN ) ; if ( activity Token != null ) { int token Number = Integer . parse Int ( activity Token ) ; I Mqtt Token token = token Map . get ( token Number ) ; token Map . delete ( token Number ) ; return token ; } return null ; }
private void enable Device Capabilities Area ( boolean enabled ) { m Disable Camera Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Widgets Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Secure Camera Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Notification Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Unredacted Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Trust Agent Checkbox . set Enabled ( enabled ) ; m Trust Agent Component . set Enabled ( enabled ) ; m Trust Agent Features . set Enabled ( enabled ) ; }
private void enable Device Capabilities Area ( boolean enabled ) { m Disable Camera Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Widgets Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Secure Camera Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Notification Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Unredacted Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Trust Agent Checkbox . set Enabled ( enabled ) ; m Trust Agent Component . set Enabled ( enabled ) ; m Trust Agent Features . set Enabled ( enabled ) ; }
public synchronized void stop Recording ( ) { if ( is Recording On ( ) ) { if ( null != stop Recording Future ) { if ( ! stop Recording Future . is Done ( ) && ! stop Recording Future . is Cancelled ( ) ) { stop Recording Future . cancel ( BOOL ) ; } stop Recording Future = null ; } Collection < Abstract Data Processor > recording Data Processors = recording Properties . get Recording Data Processors ( ) ; if ( null != recording Data Processors ) { for ( Abstract Data Processor abstract Data Processor : recording Data Processors ) { abstract Data Processor . flush ( ) ; } } if ( ! involved Agents Set . is Empty ( ) ) { List < System Information Data > to Record = storage Data Dao . get System Information Data ( involved Agents Set ) ; for ( System Information Data default Data : to Record ) { record ( default Data ) ; } } involved Agents Set . clear ( ) ; if ( log . is Debug Enabled ( ) ) { log . info ( STRING + get Storage Data ( ) ) ; } } else if ( is Recording Scheduled ( ) ) { if ( null != start Recording Future ) { if ( ! start Recording Future . is Done ( ) && ! start Recording Future . is Cancelled ( ) ) { start Recording Future . cancel ( BOOL ) ; } start Recording Future = null ; } } storage Writer = null ; recording Properties = null ; recording State = Recording State . OFF ; }
private boolean is Empty ( String value ) { if ( value != null ) { return value . length ( ) == NUM ; } return BOOL ; }
private Carbon Dictionary Writer Impl prepare Writer ( ) throws IO Exception { init Dictionary Dir Paths ( ) ; return new Carbon Dictionary Writer Impl ( this . carbon Store Path , carbon Table Identifier , column Identifier ) ; }
protected void update Throttle ( ) { long now = Current Time . get Current Time Actual ( ) ; if ( throttle Timestamp + throttle Period < now ) { throttle Timestamp = now ; throttle Count = NUM ; is Throttle = BOOL ; return ; } throttle Count ++ ; if ( throttle Count < throttle Limit ) { return ; } if ( ! is Throttle ) { is Throttle = BOOL ; if ( throttle Sleep > NUM || log . is Loggable ( Level . FINE ) ) { String msg = ( this + STRING + throttle Count + STRING + throttle Period + STRING + STRING + throttle Sleep + STRING ) ; on Throttle ( msg ) ; } } if ( throttle Sleep > NUM ) { try { Thread . sleep ( throttle Sleep ) ; } catch ( Exception e ) { } } }
private static List < Field > filter Field List ( List < Field > fields , Class < ? > filter Class ) { List < Field > filtered Fields = new Linked List < > ( ) ; for ( Field f : fields ) { if ( ( filter Class == null ) || filter Class . is Assignable From ( f . get Type ( ) ) ) { filtered Fields . add ( f ) ; } } return filtered Fields ; }
public void remove ( String key ) throws Mqtt Persistence Exception { check Is Open ( ) ; File file = new File ( client Dir , key + MESSAGE FILE EXTENSION ) ; if ( file . exists ( ) ) { file . delete ( ) ; } }
public void remove ( String key ) throws Mqtt Persistence Exception { check Is Open ( ) ; File file = new File ( client Dir , key + MESSAGE FILE EXTENSION ) ; if ( file . exists ( ) ) { file . delete ( ) ; } }
public void remove ( String key ) throws Mqtt Persistence Exception { check Is Open ( ) ; File file = new File ( client Dir , key + MESSAGE FILE EXTENSION ) ; if ( file . exists ( ) ) { file . delete ( ) ; } }
public String to Matlab ( ) { String Buffer result ; int i ; int n ; result = new String Buffer ( ) ; result . append ( STRING ) ; for ( i = NUM ; i < get Row Dimension ( ) ; i ++ ) { if ( i > NUM ) { result . append ( STRING ) ; } for ( n = NUM ; n < get Column Dimension ( ) ; n ++ ) { if ( n > NUM ) { result . append ( STRING ) ; } result . append ( Double . to String ( get ( i , n ) ) ) ; } } result . append ( STRING ) ; return result . to String ( ) ; }
public NTLM Authentication ( boolean is Proxy , URL url , Password Authentication pw ) { super ( is Proxy ? PROXY AUTHENTICATION : SERVER AUTHENTICATION , Auth Scheme . NTLM , url , STRING ) ; init ( pw ) ; }
URL Class Loader new Loader ( URL base ) { return new URL Class Loader ( new URL [ ] { base } ) ; }
public Set < Property > all Properties ( ) { Set < Property > properties = new Hash Set < Property > ( ) ; for ( Node n : nodes ) { n . include Properties ( properties ) ; } return Collections . unmodifiable Set ( properties ) ; }
public Set < Property > all Properties ( ) { Set < Property > properties = new Hash Set < Property > ( ) ; for ( Node n : nodes ) { n . include Properties ( properties ) ; } return Collections . unmodifiable Set ( properties ) ; }
public Set < Property > all Properties ( ) { Set < Property > properties = new Hash Set < Property > ( ) ; for ( Node n : nodes ) { n . include Properties ( properties ) ; } return Collections . unmodifiable Set ( properties ) ; }
private void put Parameter Into S 3 ( String s3 Bucket Name , String s3 Object Key , Parameter parameter ) { String content = parameter . get Name ( ) + STRING + parameter . get Value ( ) ; byte [ ] bytes = content . get Bytes ( ) ; Byte Array Input Stream input Stream = new Byte Array Input Stream ( bytes ) ; Object Metadata metadata = new Object Metadata ( ) ; metadata . set Content Length ( content . length ( ) ) ; Put Object Request put Object Request = new Put Object Request ( s3 Bucket Name , s3 Object Key , input Stream , metadata ) ; s3 Operations . put Object ( put Object Request , null ) ; }
private void put Parameter Into S 3 ( String s3 Bucket Name , String s3 Object Key , Parameter parameter ) { String content = parameter . get Name ( ) + STRING + parameter . get Value ( ) ; byte [ ] bytes = content . get Bytes ( ) ; Byte Array Input Stream input Stream = new Byte Array Input Stream ( bytes ) ; Object Metadata metadata = new Object Metadata ( ) ; metadata . set Content Length ( content . length ( ) ) ; Put Object Request put Object Request = new Put Object Request ( s3 Bucket Name , s3 Object Key , input Stream , metadata ) ; s3 Operations . put Object ( put Object Request , null ) ; }
public String wait For Config Change ( ) throws Interrupted Exception { logger . message ( STRING ) ; String msg = null ; try { msg = config Changed Queue . take ( ) ; } catch ( final Interrupted Exception e ) { logger . warning ( STRING ) ; throw e ; } logger . message ( STRING + msg ) ; return msg ; }
private String aggregate Wildcard ( String target Token ) { int len = NUM ; if ( target Token == null || ( len = target Token . length ( ) ) == NUM ) { return target Token ; } char [ ] oldchars = target Token . to Char Array ( ) ; char [ ] newchars = new char [ len ] ; int i = NUM ; int j = NUM ; int k = NUM ; boolean found Wildcard = BOOL ; while ( i < len ) { if ( target Token . starts With ( one Level Wildcard , i ) ) { if ( ! found Wildcard ) { k = i ; while ( i < k + one Level Wildcard Length ) { newchars [ j ++ ] = oldchars [ i ++ ] ; } found Wildcard = BOOL ; } else { i = i + one Level Wildcard Length ; } } else { found Wildcard = BOOL ; newchars [ j ++ ] = oldchars [ i ++ ] ; } } return String . value Of ( newchars , NUM , j ) ; }
public static int extract Reference ( String text ) { int lparenth Index = text . index Of ( STRING ) ; int space Index = text . index Of ( STRING ) ; if ( space Index < NUM ) { space Index = text . length ( ) ; } if ( lparenth Index < NUM ) { return space Index ; } else { if ( space Index < lparenth Index ) { return space Index ; } int rparenth Index = text . index Of ( STRING , lparenth Index ) ; if ( rparenth Index < NUM ) { rparenth Index = text . length ( ) - NUM ; } return rparenth Index + NUM ; } }
public Xml Pull Parser new Pull Parser ( ) throws Xml Pull Parser Exception { if ( parser Classes == null ) throw new Xml Pull Parser Exception ( STRING + class Names Location ) ; if ( parser Classes . size ( ) == NUM ) throw new Xml Pull Parser Exception ( STRING + class Names Location ) ; final String Buffer issues = new String Buffer ( ) ; for ( int i = NUM ; i < parser Classes . size ( ) ; i ++ ) { final Class pp Class = ( Class ) parser Classes . element At ( i ) ; try { final Xml Pull Parser pp = ( Xml Pull Parser ) pp Class . new Instance ( ) ; for ( Enumeration e = features . keys ( ) ; e . has More Elements ( ) ; ) { final String key = ( String ) e . next Element ( ) ; final Boolean value = ( Boolean ) features . get ( key ) ; if ( value != null && value . boolean Value ( ) ) { pp . set Feature ( key , BOOL ) ; } } return pp ; } catch ( Exception ex ) { issues . append ( pp Class . get Name ( ) + STRING + ex . to String ( ) + STRING ) ; } } throw new Xml Pull Parser Exception ( STRING + issues ) ; }
public Xml Pull Parser new Pull Parser ( ) throws Xml Pull Parser Exception { if ( parser Classes == null ) throw new Xml Pull Parser Exception ( STRING + class Names Location ) ; if ( parser Classes . size ( ) == NUM ) throw new Xml Pull Parser Exception ( STRING + class Names Location ) ; final String Buffer issues = new String Buffer ( ) ; for ( int i = NUM ; i < parser Classes . size ( ) ; i ++ ) { final Class pp Class = ( Class ) parser Classes . element At ( i ) ; try { final Xml Pull Parser pp = ( Xml Pull Parser ) pp Class . new Instance ( ) ; for ( Enumeration e = features . keys ( ) ; e . has More Elements ( ) ; ) { final String key = ( String ) e . next Element ( ) ; final Boolean value = ( Boolean ) features . get ( key ) ; if ( value != null && value . boolean Value ( ) ) { pp . set Feature ( key , BOOL ) ; } } return pp ; } catch ( Exception ex ) { issues . append ( pp Class . get Name ( ) + STRING + ex . to String ( ) + STRING ) ; } } throw new Xml Pull Parser Exception ( STRING + issues ) ; }
public Xml Pull Parser new Pull Parser ( ) throws Xml Pull Parser Exception { if ( parser Classes == null ) throw new Xml Pull Parser Exception ( STRING + class Names Location ) ; if ( parser Classes . size ( ) == NUM ) throw new Xml Pull Parser Exception ( STRING + class Names Location ) ; final String Buffer issues = new String Buffer ( ) ; for ( int i = NUM ; i < parser Classes . size ( ) ; i ++ ) { final Class pp Class = ( Class ) parser Classes . element At ( i ) ; try { final Xml Pull Parser pp = ( Xml Pull Parser ) pp Class . new Instance ( ) ; for ( Enumeration e = features . keys ( ) ; e . has More Elements ( ) ; ) { final String key = ( String ) e . next Element ( ) ; final Boolean value = ( Boolean ) features . get ( key ) ; if ( value != null && value . boolean Value ( ) ) { pp . set Feature ( key , BOOL ) ; } } return pp ; } catch ( Exception ex ) { issues . append ( pp Class . get Name ( ) + STRING + ex . to String ( ) + STRING ) ; } } throw new Xml Pull Parser Exception ( STRING + issues ) ; }
public Xml Pull Parser new Pull Parser ( ) throws Xml Pull Parser Exception { if ( parser Classes == null ) throw new Xml Pull Parser Exception ( STRING + class Names Location ) ; if ( parser Classes . size ( ) == NUM ) throw new Xml Pull Parser Exception ( STRING + class Names Location ) ; final String Buffer issues = new String Buffer ( ) ; for ( int i = NUM ; i < parser Classes . size ( ) ; i ++ ) { final Class pp Class = ( Class ) parser Classes . element At ( i ) ; try { final Xml Pull Parser pp = ( Xml Pull Parser ) pp Class . new Instance ( ) ; for ( Enumeration e = features . keys ( ) ; e . has More Elements ( ) ; ) { final String key = ( String ) e . next Element ( ) ; final Boolean value = ( Boolean ) features . get ( key ) ; if ( value != null && value . boolean Value ( ) ) { pp . set Feature ( key , BOOL ) ; } } return pp ; } catch ( Exception ex ) { issues . append ( pp Class . get Name ( ) + STRING + ex . to String ( ) + STRING ) ; } } throw new Xml Pull Parser Exception ( STRING + issues ) ; }
public void remove Thread ( final Target Process Thread thread ) { active Process Threads . remove ( thread ) ; for ( final Process Manager Listener listener : listeners ) { try { listener . removed Thread ( thread ) ; } catch ( final Exception exception ) { C Utility Functions . log Exception ( exception ) ; } } }
public boolean compare ( Object expected , Object current ) { if ( current != null ) { equal = current . equals ( expected ) ; } else if ( expected != null ) { equal = expected . equals ( NUM ) ; } return equal ; }
public boolean compare ( Object expected , Object current ) { if ( current != null ) { equal = current . equals ( expected ) ; } else if ( expected != null ) { equal = expected . equals ( NUM ) ; } return equal ; }
public boolean compare ( Object expected , Object current ) { if ( current != null ) { equal = current . equals ( expected ) ; } else if ( expected != null ) { equal = expected . equals ( NUM ) ; } return equal ; }
public boolean compare ( Object expected , Object current ) { if ( current != null ) { equal = current . equals ( expected ) ; } else if ( expected != null ) { equal = expected . equals ( NUM ) ; } return equal ; }
public boolean compare ( Object expected , Object current ) { if ( current != null ) { equal = current . equals ( expected ) ; } else if ( expected != null ) { equal = expected . equals ( NUM ) ; } return equal ; }
public Money add ( Money money ) { assert Defined ( ) ; if ( null == m value ) { if ( null == money . get Big Decimal Value ( ) ) { return new Money ( ) ; } else { return new Money ( money . get Big Decimal Value ( ) ) ; } } Big Decimal value = m value . add ( money . get Big Decimal Value ( ) ) ; return new Money ( value ) ; }
public static Detalle Estado BD Bean obtener Estado BD ( Integer id Estado , String entidad ) throws Sgm Exception { Estados Datos estado = new Estados Datos ( ) ; Detalle Estado BD Bean salida = new Detalle Estado BD Bean ( ) ; try { estado . set Id ( id Estado . to String ( ) ) ; estado . load ( entidad ) ; salida . set Id ( estado . get Id ( ) ) ; salida . set Id Sisnot ( estado . get Id Sisnot ( ) ) ; salida . set Descripcion ( estado . get Descripcion ( ) ) ; } catch ( Exception ex ) { logger . debug ( STRING + ex . get Message ( ) ) ; throw new Servicio Web Excepcion ( Servicio Web Error Codigos . EC UNKNOW ERROR , ex ) ; } return salida ; }
public static Detalle Estado BD Bean obtener Estado BD ( Integer id Estado , String entidad ) throws Sgm Exception { Estados Datos estado = new Estados Datos ( ) ; Detalle Estado BD Bean salida = new Detalle Estado BD Bean ( ) ; try { estado . set Id ( id Estado . to String ( ) ) ; estado . load ( entidad ) ; salida . set Id ( estado . get Id ( ) ) ; salida . set Id Sisnot ( estado . get Id Sisnot ( ) ) ; salida . set Descripcion ( estado . get Descripcion ( ) ) ; } catch ( Exception ex ) { logger . debug ( STRING + ex . get Message ( ) ) ; throw new Servicio Web Excepcion ( Servicio Web Error Codigos . EC UNKNOW ERROR , ex ) ; } return salida ; }
private Object execute In ( Page Context pc , SQL sql , Query qr , Z Expression expression , int row ) throws Page Exception { int len = expression . nb Operands ( ) ; Object left = execute Exp ( pc , sql , qr , expression . get Operand ( NUM ) , row ) ; for ( int i = NUM ; i < len ; i ++ ) { if ( Operator . compare ( left , execute Exp ( pc , sql , qr , expression . get Operand ( i ) , row ) ) == NUM ) return Boolean . TRUE ; } return Boolean . FALSE ; }
void dump Unsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + m Connection Id + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . to Hex String ( System . identity Hash Code ( m Connection Ptr ) ) ) ; } printer . println ( STRING + m Is Primary Connection ) ; printer . println ( STRING + m Only Allow Read Only Operations ) ; m Recent Operations . dump ( printer , verbose ) ; if ( verbose ) { m Prepared Statement Cache . dump ( printer ) ; } }
void dump Unsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + m Connection Id + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . to Hex String ( System . identity Hash Code ( m Connection Ptr ) ) ) ; } printer . println ( STRING + m Is Primary Connection ) ; printer . println ( STRING + m Only Allow Read Only Operations ) ; m Recent Operations . dump ( printer , verbose ) ; if ( verbose ) { m Prepared Statement Cache . dump ( printer ) ; } }
void dump Unsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + m Connection Id + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . to Hex String ( System . identity Hash Code ( m Connection Ptr ) ) ) ; } printer . println ( STRING + m Is Primary Connection ) ; printer . println ( STRING + m Only Allow Read Only Operations ) ; m Recent Operations . dump ( printer , verbose ) ; if ( verbose ) { m Prepared Statement Cache . dump ( printer ) ; } }
void dump Unsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + m Connection Id + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . to Hex String ( System . identity Hash Code ( m Connection Ptr ) ) ) ; } printer . println ( STRING + m Is Primary Connection ) ; printer . println ( STRING + m Only Allow Read Only Operations ) ; m Recent Operations . dump ( printer , verbose ) ; if ( verbose ) { m Prepared Statement Cache . dump ( printer ) ; } }
void dump Unsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + m Connection Id + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . to Hex String ( System . identity Hash Code ( m Connection Ptr ) ) ) ; } printer . println ( STRING + m Is Primary Connection ) ; printer . println ( STRING + m Only Allow Read Only Operations ) ; m Recent Operations . dump ( printer , verbose ) ; if ( verbose ) { m Prepared Statement Cache . dump ( printer ) ; } }
void dump Unsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + m Connection Id + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . to Hex String ( System . identity Hash Code ( m Connection Ptr ) ) ) ; } printer . println ( STRING + m Is Primary Connection ) ; printer . println ( STRING + m Only Allow Read Only Operations ) ; m Recent Operations . dump ( printer , verbose ) ; if ( verbose ) { m Prepared Statement Cache . dump ( printer ) ; } }
void dump Unsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + m Connection Id + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . to Hex String ( System . identity Hash Code ( m Connection Ptr ) ) ) ; } printer . println ( STRING + m Is Primary Connection ) ; printer . println ( STRING + m Only Allow Read Only Operations ) ; m Recent Operations . dump ( printer , verbose ) ; if ( verbose ) { m Prepared Statement Cache . dump ( printer ) ; } }
void dump Unsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + m Connection Id + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . to Hex String ( System . identity Hash Code ( m Connection Ptr ) ) ) ; } printer . println ( STRING + m Is Primary Connection ) ; printer . println ( STRING + m Only Allow Read Only Operations ) ; m Recent Operations . dump ( printer , verbose ) ; if ( verbose ) { m Prepared Statement Cache . dump ( printer ) ; } }
void dump Unsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + m Connection Id + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . to Hex String ( System . identity Hash Code ( m Connection Ptr ) ) ) ; } printer . println ( STRING + m Is Primary Connection ) ; printer . println ( STRING + m Only Allow Read Only Operations ) ; m Recent Operations . dump ( printer , verbose ) ; if ( verbose ) { m Prepared Statement Cache . dump ( printer ) ; } }
void dump Unsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + m Connection Id + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . to Hex String ( System . identity Hash Code ( m Connection Ptr ) ) ) ; } printer . println ( STRING + m Is Primary Connection ) ; printer . println ( STRING + m Only Allow Read Only Operations ) ; m Recent Operations . dump ( printer , verbose ) ; if ( verbose ) { m Prepared Statement Cache . dump ( printer ) ; } }
public boolean is Database Integrity Ok ( ) { acquire Reference ( ) ; try { List < Pair < String , String > > attached Dbs = null ; try { attached Dbs = get Attached Dbs ( ) ; if ( attached Dbs == null ) { throw new Illegal State Exception ( STRING + get Path ( ) + STRING + STRING ) ; } } catch ( SQ Lite Exception e ) { attached Dbs = new Array List < Pair < String , String > > ( ) ; attached Dbs . add ( new Pair < String , String > ( STRING , get Path ( ) ) ) ; } for ( int i = NUM ; i < attached Dbs . size ( ) ; i ++ ) { Pair < String , String > p = attached Dbs . get ( i ) ; SQ Lite Statement prog = null ; try { prog = compile Statement ( STRING + p . first + STRING ) ; String rslt = prog . simple Query For String ( ) ; if ( ! rslt . equals Ignore Case ( STRING ) ) { Log . e ( TAG , STRING + p . second + STRING + rslt ) ; return BOOL ; } } finally { if ( prog != null ) prog . close ( ) ; } } } finally { release Reference ( ) ; } return BOOL ; }
public boolean is Database Integrity Ok ( ) { acquire Reference ( ) ; try { List < Pair < String , String > > attached Dbs = null ; try { attached Dbs = get Attached Dbs ( ) ; if ( attached Dbs == null ) { throw new Illegal State Exception ( STRING + get Path ( ) + STRING + STRING ) ; } } catch ( SQ Lite Exception e ) { attached Dbs = new Array List < Pair < String , String > > ( ) ; attached Dbs . add ( new Pair < String , String > ( STRING , get Path ( ) ) ) ; } for ( int i = NUM ; i < attached Dbs . size ( ) ; i ++ ) { Pair < String , String > p = attached Dbs . get ( i ) ; SQ Lite Statement prog = null ; try { prog = compile Statement ( STRING + p . first + STRING ) ; String rslt = prog . simple Query For String ( ) ; if ( ! rslt . equals Ignore Case ( STRING ) ) { Log . e ( TAG , STRING + p . second + STRING + rslt ) ; return BOOL ; } } finally { if ( prog != null ) prog . close ( ) ; } } } finally { release Reference ( ) ; } return BOOL ; }
public boolean is Database Integrity Ok ( ) { acquire Reference ( ) ; try { List < Pair < String , String > > attached Dbs = null ; try { attached Dbs = get Attached Dbs ( ) ; if ( attached Dbs == null ) { throw new Illegal State Exception ( STRING + get Path ( ) + STRING + STRING ) ; } } catch ( SQ Lite Exception e ) { attached Dbs = new Array List < Pair < String , String > > ( ) ; attached Dbs . add ( new Pair < String , String > ( STRING , get Path ( ) ) ) ; } for ( int i = NUM ; i < attached Dbs . size ( ) ; i ++ ) { Pair < String , String > p = attached Dbs . get ( i ) ; SQ Lite Statement prog = null ; try { prog = compile Statement ( STRING + p . first + STRING ) ; String rslt = prog . simple Query For String ( ) ; if ( ! rslt . equals Ignore Case ( STRING ) ) { Log . e ( TAG , STRING + p . second + STRING + rslt ) ; return BOOL ; } } finally { if ( prog != null ) prog . close ( ) ; } } } finally { release Reference ( ) ; } return BOOL ; }
public boolean is Database Integrity Ok ( ) { acquire Reference ( ) ; try { List < Pair < String , String > > attached Dbs = null ; try { attached Dbs = get Attached Dbs ( ) ; if ( attached Dbs == null ) { throw new Illegal State Exception ( STRING + get Path ( ) + STRING + STRING ) ; } } catch ( SQ Lite Exception e ) { attached Dbs = new Array List < Pair < String , String > > ( ) ; attached Dbs . add ( new Pair < String , String > ( STRING , get Path ( ) ) ) ; } for ( int i = NUM ; i < attached Dbs . size ( ) ; i ++ ) { Pair < String , String > p = attached Dbs . get ( i ) ; SQ Lite Statement prog = null ; try { prog = compile Statement ( STRING + p . first + STRING ) ; String rslt = prog . simple Query For String ( ) ; if ( ! rslt . equals Ignore Case ( STRING ) ) { Log . e ( TAG , STRING + p . second + STRING + rslt ) ; return BOOL ; } } finally { if ( prog != null ) prog . close ( ) ; } } } finally { release Reference ( ) ; } return BOOL ; }
public boolean is Database Integrity Ok ( ) { acquire Reference ( ) ; try { List < Pair < String , String > > attached Dbs = null ; try { attached Dbs = get Attached Dbs ( ) ; if ( attached Dbs == null ) { throw new Illegal State Exception ( STRING + get Path ( ) + STRING + STRING ) ; } } catch ( SQ Lite Exception e ) { attached Dbs = new Array List < Pair < String , String > > ( ) ; attached Dbs . add ( new Pair < String , String > ( STRING , get Path ( ) ) ) ; } for ( int i = NUM ; i < attached Dbs . size ( ) ; i ++ ) { Pair < String , String > p = attached Dbs . get ( i ) ; SQ Lite Statement prog = null ; try { prog = compile Statement ( STRING + p . first + STRING ) ; String rslt = prog . simple Query For String ( ) ; if ( ! rslt . equals Ignore Case ( STRING ) ) { Log . e ( TAG , STRING + p . second + STRING + rslt ) ; return BOOL ; } } finally { if ( prog != null ) prog . close ( ) ; } } } finally { release Reference ( ) ; } return BOOL ; }
public static boolean is Local File Uri ( Uri uri ) { final String scheme = get Scheme Or Null ( uri ) ; return LOCAL FILE SCHEME . equals ( scheme ) ; }
public static boolean is Local File Uri ( Uri uri ) { final String scheme = get Scheme Or Null ( uri ) ; return LOCAL FILE SCHEME . equals ( scheme ) ; }
public Debug Input Bit Stream ( final Input Bit Stream ibs , final Print Stream pw ) { this . ibs = ibs ; this . pw = pw ; pw . print ( STRING ) ; }
public Debug Input Bit Stream ( final Input Bit Stream ibs , final Print Stream pw ) { this . ibs = ibs ; this . pw = pw ; pw . print ( STRING ) ; }
public Debug Input Bit Stream ( final Input Bit Stream ibs , final Print Stream pw ) { this . ibs = ibs ; this . pw = pw ; pw . print ( STRING ) ; }
void update Insets ( ) { short top = ( short ) painter . get Inset ( TOP , this ) ; short bottom = ( short ) painter . get Inset ( BOTTOM , this ) ; if ( caption Index != - NUM ) { View caption = get View ( caption Index ) ; short h = ( short ) caption . get Preferred Span ( Y AXIS ) ; Attribute Set a = caption . get Attributes ( ) ; Object align = a . get Attribute ( CSS . Attribute . CAPTION SIDE ) ; if ( ( align != null ) && ( align . equals ( STRING ) ) ) { bottom += h ; } else { top += h ; } } set Insets ( top , ( short ) painter . get Inset ( LEFT , this ) , bottom , ( short ) painter . get Inset ( RIGHT , this ) ) ; }
void update Insets ( ) { short top = ( short ) painter . get Inset ( TOP , this ) ; short bottom = ( short ) painter . get Inset ( BOTTOM , this ) ; if ( caption Index != - NUM ) { View caption = get View ( caption Index ) ; short h = ( short ) caption . get Preferred Span ( Y AXIS ) ; Attribute Set a = caption . get Attributes ( ) ; Object align = a . get Attribute ( CSS . Attribute . CAPTION SIDE ) ; if ( ( align != null ) && ( align . equals ( STRING ) ) ) { bottom += h ; } else { top += h ; } } set Insets ( top , ( short ) painter . get Inset ( LEFT , this ) , bottom , ( short ) painter . get Inset ( RIGHT , this ) ) ; }
void update Insets ( ) { short top = ( short ) painter . get Inset ( TOP , this ) ; short bottom = ( short ) painter . get Inset ( BOTTOM , this ) ; if ( caption Index != - NUM ) { View caption = get View ( caption Index ) ; short h = ( short ) caption . get Preferred Span ( Y AXIS ) ; Attribute Set a = caption . get Attributes ( ) ; Object align = a . get Attribute ( CSS . Attribute . CAPTION SIDE ) ; if ( ( align != null ) && ( align . equals ( STRING ) ) ) { bottom += h ; } else { top += h ; } } set Insets ( top , ( short ) painter . get Inset ( LEFT , this ) , bottom , ( short ) painter . get Inset ( RIGHT , this ) ) ; }
public int index Of ( int ch ) { return index Of ( ch , NUM ) ; }
public int index Of ( int ch ) { return index Of ( ch , NUM ) ; }
public int index Of ( int ch ) { return index Of ( ch , NUM ) ; }
public int index Of ( int ch ) { return index Of ( ch , NUM ) ; }
private static void create Fixed Partition List ( int primary Index ) { fpa List . clear ( ) ; if ( primary Index == NUM ) { fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STRING , BOOL , NUM ) ) ; fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STRING , NUM ) ) ; fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STRING , NUM ) ) ; } if ( primary Index == NUM ) { fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STRING , NUM ) ) ; fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STRING , BOOL , NUM ) ) ; fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STRING , NUM ) ) ; } if ( primary Index == NUM ) { fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STRING , NUM ) ) ; fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STRING , NUM ) ) ; fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STRING , BOOL , NUM ) ) ; } }
@ Override public void drop Database Schema ( Abstract Session session , Writer writer ) throws Eclipse Link Exception { build Database Schema Deletion Writer ( session , writer ) ; }
private void draw ( final Execution Unit process , final Graphics 2 D g2 , final Process Renderer Model renderer Model , final boolean printing ) { Process Background Image image = renderer Model . get Background Image ( process ) ; if ( image != null ) { Graphics 2 D g2 D = ( Graphics 2 D ) g2 . create ( ) ; int x = image . get X ( ) ; int y = image . get Y ( ) ; int w = image . get Width ( ) ; int h = image . get Height ( ) ; if ( x == - NUM ) { double process Width = renderer Model . get Process Width ( process ) ; x = ( int ) ( ( process Width - w ) / NUM ) ; } if ( y == - NUM ) { double process Height = renderer Model . get Process Height ( process ) ; y = ( int ) ( ( process Height - h ) / NUM ) ; } if ( renderer Model . get Zoom Factor ( ) > NUM ) { float alpha = Math . max ( MIN OPACITY , NUM - ( float ) renderer Model . get Zoom Factor ( ) ) ; Alpha Composite ac = Alpha Composite . get Instance ( Alpha Composite . SRC OVER , alpha ) ; g2 D . set Composite ( ac ) ; } g2 D . set Rendering Hint ( Rendering Hints . KEY INTERPOLATION , Rendering Hints . VALUE INTERPOLATION BILINEAR ) ; g2 D . draw Image ( image . get Image ( load Listener ) , x , y , w , h , null ) ; g2 D . dispose ( ) ; } }
protected void smooth Scroll By Offset ( int position ) { int index = - NUM ; if ( position < NUM ) { index = get First Visible Position ( ) ; } else if ( position > NUM ) { index = get Last Visible Position ( ) ; } if ( index > - NUM ) { View child = get Child At ( index - get First Visible Position ( ) ) ; if ( child != null ) { Rect visible Rect = new Rect ( ) ; if ( child . get Global Visible Rect ( visible Rect ) ) { int child Rect Area = child . get Width ( ) * child . get Height ( ) ; int visible Rect Area = visible Rect . width ( ) * visible Rect . height ( ) ; float visible Area = ( visible Rect Area / ( float ) child Rect Area ) ; final float visible Threshold = NUM ; if ( ( position < NUM ) && ( visible Area < visible Threshold ) ) { ++ index ; } else if ( ( position > NUM ) && ( visible Area < visible Threshold ) ) { -- index ; } } smooth Scroll To Position ( Math . max ( NUM , Math . min ( get Count ( ) , index + position ) ) ) ; } } }
public void window Closing ( java . awt . event . Window Event e ) { done Button Action Performed ( ) ; }
public void window Closing ( java . awt . event . Window Event e ) { done Button Action Performed ( ) ; }
public static boolean is In Process Mode ( Project System Id external System Id ) { return Registry . is ( external System Id . get Id ( ) + External System Constants . USE IN PROCESS COMMUNICATION REGISTRY KEY SUFFIX , BOOL ) ; }
public static boolean is In Process Mode ( Project System Id external System Id ) { return Registry . is ( external System Id . get Id ( ) + External System Constants . USE IN PROCESS COMMUNICATION REGISTRY KEY SUFFIX , BOOL ) ; }
public static boolean is In Process Mode ( Project System Id external System Id ) { return Registry . is ( external System Id . get Id ( ) + External System Constants . USE IN PROCESS COMMUNICATION REGISTRY KEY SUFFIX , BOOL ) ; }
public static boolean is In Process Mode ( Project System Id external System Id ) { return Registry . is ( external System Id . get Id ( ) + External System Constants . USE IN PROCESS COMMUNICATION REGISTRY KEY SUFFIX , BOOL ) ; }
public static boolean is In Process Mode ( Project System Id external System Id ) { return Registry . is ( external System Id . get Id ( ) + External System Constants . USE IN PROCESS COMMUNICATION REGISTRY KEY SUFFIX , BOOL ) ; }
public static boolean is In Process Mode ( Project System Id external System Id ) { return Registry . is ( external System Id . get Id ( ) + External System Constants . USE IN PROCESS COMMUNICATION REGISTRY KEY SUFFIX , BOOL ) ; }
public static boolean is In Process Mode ( Project System Id external System Id ) { return Registry . is ( external System Id . get Id ( ) + External System Constants . USE IN PROCESS COMMUNICATION REGISTRY KEY SUFFIX , BOOL ) ; }
public static boolean is In Process Mode ( Project System Id external System Id ) { return Registry . is ( external System Id . get Id ( ) + External System Constants . USE IN PROCESS COMMUNICATION REGISTRY KEY SUFFIX , BOOL ) ; }
public static boolean is In Process Mode ( Project System Id external System Id ) { return Registry . is ( external System Id . get Id ( ) + External System Constants . USE IN PROCESS COMMUNICATION REGISTRY KEY SUFFIX , BOOL ) ; }
public static boolean is In Process Mode ( Project System Id external System Id ) { return Registry . is ( external System Id . get Id ( ) + External System Constants . USE IN PROCESS COMMUNICATION REGISTRY KEY SUFFIX , BOOL ) ; }
public static boolean is In Process Mode ( Project System Id external System Id ) { return Registry . is ( external System Id . get Id ( ) + External System Constants . USE IN PROCESS COMMUNICATION REGISTRY KEY SUFFIX , BOOL ) ; }
public static boolean is In Process Mode ( Project System Id external System Id ) { return Registry . is ( external System Id . get Id ( ) + External System Constants . USE IN PROCESS COMMUNICATION REGISTRY KEY SUFFIX , BOOL ) ; }
public static boolean is In Process Mode ( Project System Id external System Id ) { return Registry . is ( external System Id . get Id ( ) + External System Constants . USE IN PROCESS COMMUNICATION REGISTRY KEY SUFFIX , BOOL ) ; }
public short [ ] read Short Array ( final int items , final JBBP Byte Order byte Order ) throws IO Exception { int pos = NUM ; if ( items < NUM ) { short [ ] buffer = new short [ INITIAL ARRAY BUFFER SIZE ] ; while ( has Available Data ( ) ) { final int next = read Unsigned Short ( byte Order ) ; if ( buffer . length == pos ) { final short [ ] newbuffer = new short [ buffer . length << NUM ] ; System . arraycopy ( buffer , NUM , newbuffer , NUM , buffer . length ) ; buffer = newbuffer ; } buffer [ pos ++ ] = ( short ) next ; } if ( buffer . length == pos ) { return buffer ; } final short [ ] result = new short [ pos ] ; System . arraycopy ( buffer , NUM , result , NUM , pos ) ; return result ; } else { final short [ ] buffer = new short [ items ] ; for ( int i = NUM ; i < items ; i ++ ) { buffer [ i ] = ( short ) read Unsigned Short ( byte Order ) ; } return buffer ; } }
@ POST @ Path ( STRING ) @ Consumes ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Produces ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) public Response validate User Password For Change ( @ Context Http Servlet Request http Request , Password Change Param password Param ) { String client IP = inv Login Manager . get Client IP ( http Request ) ; is Client IP Blocked ( client IP ) ; Response response = password Utils . change Password ( password Param , BOOL ) ; return response ; }
@ Override public URI to Vertex URI ( final Object key ) { return to URI ( key . to String ( ) ) ; }
public void rearrange Children ( int item Count ) { Array List < View > views = get Items In Reading Order ( ) ; m Content . arrange Children ( views , Math . max ( item Count , views . size ( ) ) ) ; m Items Invalidated = BOOL ; }
public void rearrange Children ( int item Count ) { Array List < View > views = get Items In Reading Order ( ) ; m Content . arrange Children ( views , Math . max ( item Count , views . size ( ) ) ) ; m Items Invalidated = BOOL ; }
public Filterable Triple Handler ( String Buffer osw , List < String > negative Filter Namespaces , List < String > positiv Filter Namespaces ) { this . writer = osw ; this . negative Filter Namespaces = negative Filter Namespaces ; this . positive Filter Namespaces = positiv Filter Namespaces ; for ( String ex : EXTRACTORS ) { triples Per Extractor . put ( ex , new Long ( NUM ) ) ; } }
public Filterable Triple Handler ( String Buffer osw , List < String > negative Filter Namespaces , List < String > positiv Filter Namespaces ) { this . writer = osw ; this . negative Filter Namespaces = negative Filter Namespaces ; this . positive Filter Namespaces = positiv Filter Namespaces ; for ( String ex : EXTRACTORS ) { triples Per Extractor . put ( ex , new Long ( NUM ) ) ; } }
public Filterable Triple Handler ( String Buffer osw , List < String > negative Filter Namespaces , List < String > positiv Filter Namespaces ) { this . writer = osw ; this . negative Filter Namespaces = negative Filter Namespaces ; this . positive Filter Namespaces = positiv Filter Namespaces ; for ( String ex : EXTRACTORS ) { triples Per Extractor . put ( ex , new Long ( NUM ) ) ; } }
protected Wire Format ( String name ) { this . name = name ; }
@ Suppress Warnings ( { STRING , STRING } ) public static Comparable < ? > max ( Comparable < ? > [ ] ar ) { Comparable ret = ar [ NUM ] ; for ( int i = NUM ; i < ar . length ; i ++ ) { if ( ret . compare To ( ar [ i ] ) < NUM ) { ret = ar [ i ] ; } } return ret ; }
public void run ( ) { closed = BOOL ; thread = Thread . current Thread ( ) ; do { try { byte [ ] message = send Queue . take ( ) ; Datagram Packet req = requests . remove ( Modbus Util . registers To Int ( message ) ) ; if ( req != null ) { Datagram Packet res = new Datagram Packet ( message , message . length , req . get Address ( ) , req . get Port ( ) ) ; socket . send ( res ) ; logger . debug ( STRING ) ; } } catch ( Exception ex ) { if ( running ) { logger . error ( STRING , ex ) ; } } } while ( running ) ; closed = BOOL ; }
public void run ( ) { closed = BOOL ; thread = Thread . current Thread ( ) ; do { try { byte [ ] message = send Queue . take ( ) ; Datagram Packet req = requests . remove ( Modbus Util . registers To Int ( message ) ) ; if ( req != null ) { Datagram Packet res = new Datagram Packet ( message , message . length , req . get Address ( ) , req . get Port ( ) ) ; socket . send ( res ) ; logger . debug ( STRING ) ; } } catch ( Exception ex ) { if ( running ) { logger . error ( STRING , ex ) ; } } } while ( running ) ; closed = BOOL ; }
Date delayed Date ( long delay Millis ) { return new Date ( System . current Time Millis ( ) + delay Millis + NUM ) ; }
Date delayed Date ( long delay Millis ) { return new Date ( System . current Time Millis ( ) + delay Millis + NUM ) ; }
Date delayed Date ( long delay Millis ) { return new Date ( System . current Time Millis ( ) + delay Millis + NUM ) ; }
public void serialize ( Managed Object Path Serializer serializer ) { for ( Element < ? , ? > element : elements ) { element . serialize ( serializer ) ; } }
public void serialize ( Managed Object Path Serializer serializer ) { for ( Element < ? , ? > element : elements ) { element . serialize ( serializer ) ; } }
public void add ( Select Clause Element Raw element ) { select Clause Elements . add ( element ) ; }
@ Override public double [ ] make Inverse Cumulative Test Values ( ) { double [ ] points = make Cumulative Test Points ( ) ; double [ ] points 2 = new double [ points . length - NUM ] ; System . arraycopy ( points , NUM , points 2 , NUM , points . length - NUM ) ; return points 2 ; }
public String line ( ) throws IO Exception { String Builder buffer = new String Builder ( ) ; while ( BOOL ) { if ( buffer . length ( ) > Hash . MAX ) { throw new IO Exception ( STRING ) ; } int a = real ( ) ; if ( a == STRING ) { return buffer . to String ( ) ; } if ( a == STRING ) { int b = real ( ) ; if ( b == STRING ) { return buffer . to String ( ) ; } else if ( b > - NUM ) { buffer . append ( ( char ) a ) ; buffer . append ( ( char ) b ) ; } } else if ( a > - NUM ) { buffer . append ( ( char ) a ) ; } } }
public static String with First ( String input , Function < Character , String > callback ) { if ( input == null ) { return null ; } else if ( input . length ( ) == NUM ) { return STRING ; } else { return String . join ( STRING , callback . apply ( input . char At ( NUM ) ) , input . sub Sequence ( NUM , input . length ( ) ) ) ; } }
@ Override protected void fire Insert Update ( Document Event evt ) { if ( token Marker != null ) { Document Event . Element Change ch = evt . get Change ( get Default Root Element ( ) ) ; if ( ch != null ) { token Marker . insert Lines ( ch . get Index ( ) + NUM , ch . get Children Added ( ) . length - ch . get Children Removed ( ) . length ) ; } } super . fire Insert Update ( evt ) ; }
@ Override protected void fire Insert Update ( Document Event evt ) { if ( token Marker != null ) { Document Event . Element Change ch = evt . get Change ( get Default Root Element ( ) ) ; if ( ch != null ) { token Marker . insert Lines ( ch . get Index ( ) + NUM , ch . get Children Added ( ) . length - ch . get Children Removed ( ) . length ) ; } } super . fire Insert Update ( evt ) ; }
@ Override protected void fire Insert Update ( Document Event evt ) { if ( token Marker != null ) { Document Event . Element Change ch = evt . get Change ( get Default Root Element ( ) ) ; if ( ch != null ) { token Marker . insert Lines ( ch . get Index ( ) + NUM , ch . get Children Added ( ) . length - ch . get Children Removed ( ) . length ) ; } } super . fire Insert Update ( evt ) ; }
@ Override protected void fire Insert Update ( Document Event evt ) { if ( token Marker != null ) { Document Event . Element Change ch = evt . get Change ( get Default Root Element ( ) ) ; if ( ch != null ) { token Marker . insert Lines ( ch . get Index ( ) + NUM , ch . get Children Added ( ) . length - ch . get Children Removed ( ) . length ) ; } } super . fire Insert Update ( evt ) ; }
@ Override protected void fire Insert Update ( Document Event evt ) { if ( token Marker != null ) { Document Event . Element Change ch = evt . get Change ( get Default Root Element ( ) ) ; if ( ch != null ) { token Marker . insert Lines ( ch . get Index ( ) + NUM , ch . get Children Added ( ) . length - ch . get Children Removed ( ) . length ) ; } } super . fire Insert Update ( evt ) ; }
@ Override protected void fire Insert Update ( Document Event evt ) { if ( token Marker != null ) { Document Event . Element Change ch = evt . get Change ( get Default Root Element ( ) ) ; if ( ch != null ) { token Marker . insert Lines ( ch . get Index ( ) + NUM , ch . get Children Added ( ) . length - ch . get Children Removed ( ) . length ) ; } } super . fire Insert Update ( evt ) ; }
private static boolean is Temp Path Secure ( ) { if ( ! was Temp Path Checked ) { synchronized ( Windows Attach Provider . class ) { if ( ! was Temp Path Checked ) { String temp = temp Path ( ) ; if ( ( temp != null ) && ( temp . length ( ) >= NUM ) && ( temp . char At ( NUM ) == STRING ) && ( temp . char At ( NUM ) == STRING ) ) { long flags = volume Flags ( temp . substring ( NUM , NUM ) ) ; is Temp Path Secure = ( ( flags & FS PERSISTENT ACLS ) != NUM ) ; } was Temp Path Checked = BOOL ; } } } return is Temp Path Secure ; }
private static boolean is Temp Path Secure ( ) { if ( ! was Temp Path Checked ) { synchronized ( Windows Attach Provider . class ) { if ( ! was Temp Path Checked ) { String temp = temp Path ( ) ; if ( ( temp != null ) && ( temp . length ( ) >= NUM ) && ( temp . char At ( NUM ) == STRING ) && ( temp . char At ( NUM ) == STRING ) ) { long flags = volume Flags ( temp . substring ( NUM , NUM ) ) ; is Temp Path Secure = ( ( flags & FS PERSISTENT ACLS ) != NUM ) ; } was Temp Path Checked = BOOL ; } } } return is Temp Path Secure ; }
public static String quote String SQL ( String s ) { if ( s == null ) { return STRING ; } int length = s . length ( ) ; String Builder buff = new String Builder ( length + NUM ) ; buff . append ( STRING ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = s . char At ( i ) ; if ( c == STRING ) { buff . append ( c ) ; } else if ( c < STRING || c > NUM ) { return STRING + quote String SQL ( java Encode ( s ) ) + STRING ; } buff . append ( c ) ; } buff . append ( STRING ) ; return buff . to String ( ) ; }
private void add Index ( Index < K , V > idx , Head Index < K , V > h , int index Level ) { int insertion Level = index Level ; Comparable < ? super K > key = comparable ( idx . node . key ) ; if ( key == null ) throw new Null Pointer Exception ( ) ; for ( ; ; ) { int j = h . level ; Index < K , V > q = h ; Index < K , V > r = q . right ; Index < K , V > t = idx ; for ( ; ; ) { if ( r != null ) { Node < K , V > n = r . node ; int c = key . compare To ( n . key ) ; if ( n . value == null ) { if ( ! q . unlink ( r ) ) break ; r = q . right ; continue ; } if ( c > NUM ) { q = r ; r = r . right ; continue ; } } if ( j == insertion Level ) { if ( t . indexes Deleted Node ( ) ) { find Node ( key ) ; return ; } if ( ! q . link ( r , t ) ) break ; if ( -- insertion Level == NUM ) { if ( t . indexes Deleted Node ( ) ) find Node ( key ) ; return ; } } if ( -- j >= insertion Level && j < index Level ) t = t . down ; q = q . down ; r = q . right ; } } }
public static Date parse ( String time String ) throws Parse Exception { if ( time String == null || time String . is Empty ( ) ) return null ; Date Format time Format = new Simple Date Format ( Time Field . FORMAT ) ; return time Format . parse ( time String ) ; }
public static Date parse ( String time String ) throws Parse Exception { if ( time String == null || time String . is Empty ( ) ) return null ; Date Format time Format = new Simple Date Format ( Time Field . FORMAT ) ; return time Format . parse ( time String ) ; }
public void component Shown ( Component Event e ) { Layer layer = get Layer ( ) ; if ( layer != null ) { if ( e . get Component ( ) == layer ) { if ( get State ( ) != BOOL && menu Type == LAYERS ON OFF ) { set State ( BOOL ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + layer . get Name ( ) + STRING ) ; } } } else if ( e . get Component ( ) == layer . get Palette ( ) && menu Type == PALETTES ON OFF ) { set State ( BOOL ) ; } } }
public static String hash Map To String ( Hash Map < ? , ? > map , int dp ) { String Builder sb = new String Builder ( ) ; for ( Object k : map . key Set ( ) ) { sb . append ( Utils . pad Right ( k . to String ( ) , NUM ) ) ; Object obj = map . get ( k ) ; if ( obj instanceof Double ) { sb . append ( Utils . double To String ( ( Double ) obj , NUM , dp ) ) ; } else if ( obj instanceof double [ ] ) { sb . append ( A . to String ( ( double [ ] ) obj , dp ) ) ; } else if ( obj instanceof int [ ] ) { sb . append ( A . to String ( ( int [ ] ) obj , dp + NUM ) ) ; } else if ( obj instanceof String ) { String s = ( String ) obj ; if ( s . contains ( STRING ) ) sb . append ( STRING ) ; sb . append ( obj ) ; if ( s . contains ( STRING ) ) sb . append ( STRING ) ; } else { } sb . append ( STRING ) ; } return sb . to String ( ) ; }
public void launch ( ) { if ( Text Utils . is Empty ( app Name ) ) { throw new Runtime Exception ( STRING ) ; } if ( permissions . is Empty ( ) ) { throw new Runtime Exception ( STRING ) ; } List < Permission > permission List = permissions Denied ( permissions ) ; if ( permission List == null || permission List . is Empty ( ) ) { return ; } permissions Activity = this ; Intent permission Activity = new Intent ( launch Context , Permissions Flow Activity . class ) ; permission Activity . put Extra ( APP NAME , app Name ) ; permission Activity . put Extra ( PERMISSIONS , permission List . to Array ( new Permission [ permission List . size ( ) ] ) ) ; permission Activity . put Extra ( BG COLOR , bg Color ) ; permission Activity . put Extra ( BAR COLOR , bar Color ) ; permission Activity . put Extra ( MAIN TEXT COLOR , main Text Color ) ; permission Activity . put Extra ( MAIN TEXT COLOR SECONDARY , main Text Color Secondary ) ; permission Activity . put Extra ( BAR TEXT COLOR , bar Text Color ) ; permission Activity . put Extra ( STATUS BAR COLOR , status Bar Color ) ; permission Activity . put Extra ( NAVIGATION BAR COLOR , nav Bar Color ) ; permission Activity . put Extra ( LIGHT STATUS BAR , light Status Bar ) ; permission Activity . put Extra ( ICON COLOR , icon Color ) ; permission Activity . add Flags ( Intent . FLAG ACTIVITY NEW TASK ) ; launch Context . start Activity ( permission Activity ) ; }
public boolean in Test Set ( String source Side ) { if ( ! source Side . equals ( last Source Side ) ) { last Source Side = source Side ; accepted Last Source Side = filter . permits ( source Side ) ; } else { cached ++ ; } return accepted Last Source Side ; }
public boolean in Test Set ( String source Side ) { if ( ! source Side . equals ( last Source Side ) ) { last Source Side = source Side ; accepted Last Source Side = filter . permits ( source Side ) ; } else { cached ++ ; } return accepted Last Source Side ; }
public boolean in Test Set ( String source Side ) { if ( ! source Side . equals ( last Source Side ) ) { last Source Side = source Side ; accepted Last Source Side = filter . permits ( source Side ) ; } else { cached ++ ; } return accepted Last Source Side ; }
Thread Pool ( Thread Group thread Group ) { this . thread Group = thread Group ; }
Thread Pool ( Thread Group thread Group ) { this . thread Group = thread Group ; }
Thread Pool ( Thread Group thread Group ) { this . thread Group = thread Group ; }
Thread Pool ( Thread Group thread Group ) { this . thread Group = thread Group ; }
@ Category ( Flaky Test . class ) @ Test public void test Missing Member Redundancy 1 ( ) { Host host = Host . get Host ( NUM ) ; VM vm 0 = host . get VM ( NUM ) ; VM vm 1 = host . get VM ( NUM ) ; VM vm 2 = host . get VM ( NUM ) ; create PR ( vm 0 , NUM ) ; create PR ( vm 1 , NUM ) ; create Data ( vm 0 , NUM , NUM BUCKETS , STRING ) ; Set < Integer > vm 0 Buckets = get Bucket List ( vm 0 ) ; Set < Integer > vm 1 Buckets = get Bucket List ( vm 1 ) ; close Cache ( vm 1 ) ; check Data ( vm 0 , NUM , NUM BUCKETS , STRING ) ; remove Data ( vm 0 , NUM , NUM BUCKETS / NUM ) ; create Data ( vm 0 , NUM BUCKETS / NUM , NUM BUCKETS , STRING ) ; create PR ( vm 2 , NUM ) ; Set < Integer > vm 2 Buckets = get Bucket List ( vm 2 ) ; assert Equals ( Collections . empty Set ( ) , vm 2 Buckets ) ; create PR ( vm 1 , NUM ) ; check Data ( vm 1 , NUM , NUM BUCKETS / NUM , null ) ; check Data ( vm 1 , NUM BUCKETS / NUM , NUM BUCKETS , STRING ) ; assert Equals ( vm 0 Buckets , get Bucket List ( vm 0 ) ) ; assert Equals ( vm 1 Buckets , get Bucket List ( vm 1 ) ) ; assert Equals ( Collections . empty Set ( ) , get Bucket List ( vm 2 ) ) ; }
@ Category ( Flaky Test . class ) @ Test public void test Missing Member Redundancy 1 ( ) { Host host = Host . get Host ( NUM ) ; VM vm 0 = host . get VM ( NUM ) ; VM vm 1 = host . get VM ( NUM ) ; VM vm 2 = host . get VM ( NUM ) ; create PR ( vm 0 , NUM ) ; create PR ( vm 1 , NUM ) ; create Data ( vm 0 , NUM , NUM BUCKETS , STRING ) ; Set < Integer > vm 0 Buckets = get Bucket List ( vm 0 ) ; Set < Integer > vm 1 Buckets = get Bucket List ( vm 1 ) ; close Cache ( vm 1 ) ; check Data ( vm 0 , NUM , NUM BUCKETS , STRING ) ; remove Data ( vm 0 , NUM , NUM BUCKETS / NUM ) ; create Data ( vm 0 , NUM BUCKETS / NUM , NUM BUCKETS , STRING ) ; create PR ( vm 2 , NUM ) ; Set < Integer > vm 2 Buckets = get Bucket List ( vm 2 ) ; assert Equals ( Collections . empty Set ( ) , vm 2 Buckets ) ; create PR ( vm 1 , NUM ) ; check Data ( vm 1 , NUM , NUM BUCKETS / NUM , null ) ; check Data ( vm 1 , NUM BUCKETS / NUM , NUM BUCKETS , STRING ) ; assert Equals ( vm 0 Buckets , get Bucket List ( vm 0 ) ) ; assert Equals ( vm 1 Buckets , get Bucket List ( vm 1 ) ) ; assert Equals ( Collections . empty Set ( ) , get Bucket List ( vm 2 ) ) ; }
public Message ( String type , double value ) { if ( ! VALID TYPES . contains ( type ) ) { throw new Illegal Argument Exception ( type + STRING + STRING ) ; } this . type = type ; this . value = value ; }
public static boolean is Input Stream GZIP Compressed ( final Pushback Input Stream input Stream ) throws IO Exception { if ( input Stream == null ) return BOOL ; byte [ ] signature = new byte [ NUM ] ; int read Status = input Stream . read ( signature ) ; input Stream . unread ( signature ) ; int stream Header = ( ( int ) signature [ NUM ] & NUM ) | ( ( signature [ NUM ] << NUM ) & NUM ) ; return read Status == NUM && GZIP Input Stream . GZIP MAGIC == stream Header ; }
public static String format Url For Security Display ( URI uri , boolean show Scheme ) { return format Url For Security Display ( uri . to String ( ) , show Scheme ) ; }
boolean has Min Feature Count ( String feature ) { if ( min Feature Count == NUM ) return BOOL ; Set < Integer > ids = clipped Feature Index . get ( feature ) ; if ( ids == null ) return BOOL ; return ids . size ( ) >= min Feature Count ; }
boolean has Min Feature Count ( String feature ) { if ( min Feature Count == NUM ) return BOOL ; Set < Integer > ids = clipped Feature Index . get ( feature ) ; if ( ids == null ) return BOOL ; return ids . size ( ) >= min Feature Count ; }
boolean has Min Feature Count ( String feature ) { if ( min Feature Count == NUM ) return BOOL ; Set < Integer > ids = clipped Feature Index . get ( feature ) ; if ( ids == null ) return BOOL ; return ids . size ( ) >= min Feature Count ; }
public int y ( double lat ) { return ( int ) Math . round ( dots Per Deg * ( origin Lat - lat ) ) ; }
public int y ( double lat ) { return ( int ) Math . round ( dots Per Deg * ( origin Lat - lat ) ) ; }
public static Temp Path create Directory ( Path dir ) throws IO Exception { return wrap ( Files . create Temp Directory ( dir , PREFIX ) ) ; }
public static Temp Path create Directory ( Path dir ) throws IO Exception { return wrap ( Files . create Temp Directory ( dir , PREFIX ) ) ; }
public String pick Image ( ) { String path = null ; try { path = pick ( ) ; } catch ( Picker Exception e ) { e . print Stack Trace ( ) ; if ( callback != null ) { callback . on Error ( e . get Message ( ) ) ; } } return path ; }
protected void reject Drop ( ) { Drop Target Context Peer peer = get Drop Target Context Peer ( ) ; if ( peer != null ) { peer . reject Drop ( ) ; } }
protected void fill Parameter ( Prepared Statement stmt , int idx , Jdbc Type Field field , @ Nullable Object field Val ) throws Cache Exception { try { if ( field Val != null ) { if ( field . get Java Field Type ( ) == UUID . class ) { switch ( field . get Database Field Type ( ) ) { case Types . BINARY : field Val = U . uuid To Bytes ( ( UUID ) field Val ) ; break ; case Types . CHAR : case Types . VARCHAR : field Val = field Val . to String ( ) ; break ; } } stmt . set Object ( idx , field Val ) ; } else stmt . set Null ( idx , field . get Database Field Type ( ) ) ; } catch ( SQL Exception e ) { throw new Cache Exception ( STRING + field . get Database Field Name ( ) , e ) ; } }
protected void put Child ( String name , Field Vector vector ) { put Vector ( name , vector ) ; }
protected void put Child ( String name , Field Vector vector ) { put Vector ( name , vector ) ; }
int priority Value ( int state ) { int value = NUM ; switch ( state ) { case Abstract Value . UNKNOWN : value ++ ; case Abstract Value . DIFF : value ++ ; case Abstract Value . EDITED : value ++ ; case Abstract Value . FROMFILE : value ++ ; default : return value ; } }
private static void generate Reservation Token Attribute ( Reservation Token Attribute token , int nb ) { long left = System . current Time Millis ( ) ; long right = random . next Long ( ) ; int b = nb / NUM ; for ( int i = NUM ; i < b ; i ++ ) { token . reservation Token [ i ] = ( byte ) ( ( left > > ( i * NUM ) ) & NUM ) ; token . reservation Token [ i + b ] = ( byte ) ( ( right > > ( i * NUM ) ) & NUM ) ; } token . hash Code = ( token . reservation Token [ NUM ] << NUM & NUM ) | ( token . reservation Token [ NUM ] << NUM & NUM ) | ( token . reservation Token [ NUM ] << NUM & NUM ) | ( token . reservation Token [ NUM ] & NUM ) ; }
@ Suppress Warnings ( STRING ) void add Adapter ( int position , Universal Adapter adapter ) { int count = get Count ( ) ; List Piece piece = new List Piece ( adapter , this ) ; list Pieces . add ( position , piece ) ; piece . set Start Position ( count ) ; piece . initialize Item View Types ( ) ; }
public Storage ( File directory , String properties File ) { if ( directory == null ) throw new Null Pointer Exception ( STRING ) ; if ( directory . is File ( ) ) throw new Illegal Argument Exception ( STRING + directory ) ; this . directory = directory ; this . properties File = properties File != null ? new File ( directory , properties File ) : null ; }
public String create Message ( Sso Runtime Exception e ) { return create Message ( e . get Message Key ( ) , e . get Message Details ( ) , e . get Message ( ) ) ; }
public boolean draw ( Canvas canvas ) { update ( ) ; final float center X = m Bounds . center X ( ) ; final float center Y = m Bounds . height ( ) - m Radius ; canvas . scale ( NUM , Math . min ( m Glow Scale Y , NUM ) * m Base Glow Scale , center X , NUM ) ; final float displacement = Math . max ( NUM , Math . min ( m Displacement , NUM ) ) - NUM ; float translate X = m Bounds . width ( ) * displacement / NUM ; m Paint . set Alpha ( ( int ) ( NUM * m Glow Alpha ) ) ; canvas . draw Circle ( center X + translate X , center Y , m Radius , m Paint ) ; boolean one Last Frame = BOOL ; if ( m State == STATE RECEDE && m Glow Scale Y == NUM ) { m State = STATE IDLE ; one Last Frame = BOOL ; } return m State != STATE IDLE || one Last Frame ; }
public boolean draw ( Canvas canvas ) { update ( ) ; final float center X = m Bounds . center X ( ) ; final float center Y = m Bounds . height ( ) - m Radius ; canvas . scale ( NUM , Math . min ( m Glow Scale Y , NUM ) * m Base Glow Scale , center X , NUM ) ; final float displacement = Math . max ( NUM , Math . min ( m Displacement , NUM ) ) - NUM ; float translate X = m Bounds . width ( ) * displacement / NUM ; m Paint . set Alpha ( ( int ) ( NUM * m Glow Alpha ) ) ; canvas . draw Circle ( center X + translate X , center Y , m Radius , m Paint ) ; boolean one Last Frame = BOOL ; if ( m State == STATE RECEDE && m Glow Scale Y == NUM ) { m State = STATE IDLE ; one Last Frame = BOOL ; } return m State != STATE IDLE || one Last Frame ; }
public boolean draw ( Canvas canvas ) { update ( ) ; final float center X = m Bounds . center X ( ) ; final float center Y = m Bounds . height ( ) - m Radius ; canvas . scale ( NUM , Math . min ( m Glow Scale Y , NUM ) * m Base Glow Scale , center X , NUM ) ; final float displacement = Math . max ( NUM , Math . min ( m Displacement , NUM ) ) - NUM ; float translate X = m Bounds . width ( ) * displacement / NUM ; m Paint . set Alpha ( ( int ) ( NUM * m Glow Alpha ) ) ; canvas . draw Circle ( center X + translate X , center Y , m Radius , m Paint ) ; boolean one Last Frame = BOOL ; if ( m State == STATE RECEDE && m Glow Scale Y == NUM ) { m State = STATE IDLE ; one Last Frame = BOOL ; } return m State != STATE IDLE || one Last Frame ; }
public Vcs Revision Number original Revision ( int line Number ) { return get Line Revision Number ( line Number ) ; }
public void test create 01 ( ) throws Exception { final String namespace 2 = STRING + UUID . random UUID ( ) ; do Test Create ( namespace 2 ) ; }
public void test create 01 ( ) throws Exception { final String namespace 2 = STRING + UUID . random UUID ( ) ; do Test Create ( namespace 2 ) ; }
public void test create 01 ( ) throws Exception { final String namespace 2 = STRING + UUID . random UUID ( ) ; do Test Create ( namespace 2 ) ; }
public Int Array List ( int [ ] data ) { array = new int [ ( int ) ( data . length * NUM ) + NUM ] ; size = data . length ; System . arraycopy ( data , NUM , array , NUM , size ) ; }
public Int Array List ( int [ ] data ) { array = new int [ ( int ) ( data . length * NUM ) + NUM ] ; size = data . length ; System . arraycopy ( data , NUM , array , NUM , size ) ; }
public Int Array List ( int [ ] data ) { array = new int [ ( int ) ( data . length * NUM ) + NUM ] ; size = data . length ; System . arraycopy ( data , NUM , array , NUM , size ) ; }
public boolean add Marker ( String label , int value , int text Offset X , int text Offset Y , On Marker Click Listener on Marker Click Listener ) { if ( value > m Max || value < NUM ) { return BOOL ; } Marker marker = new Marker ( ) ; String lb = label ; if ( label != null && label . length ( ) > NUM ) { lb = label . substring ( NUM , NUM ) ; } marker . label = lb ; marker . value = value ; marker . offset X = text Offset X ; marker . offset Y = text Offset Y ; marker . progress Sweep = ( float ) value / m Max * m Sweep Angle ; marker . on Marker Click Listener = on Marker Click Listener ; if ( m Markers == null ) { m Markers = new Array List < > ( ) ; } m Markers . add ( marker ) ; request Layout ( ) ; post Invalidate ( ) ; return BOOL ; }
public boolean add Marker ( String label , int value , int text Offset X , int text Offset Y , On Marker Click Listener on Marker Click Listener ) { if ( value > m Max || value < NUM ) { return BOOL ; } Marker marker = new Marker ( ) ; String lb = label ; if ( label != null && label . length ( ) > NUM ) { lb = label . substring ( NUM , NUM ) ; } marker . label = lb ; marker . value = value ; marker . offset X = text Offset X ; marker . offset Y = text Offset Y ; marker . progress Sweep = ( float ) value / m Max * m Sweep Angle ; marker . on Marker Click Listener = on Marker Click Listener ; if ( m Markers == null ) { m Markers = new Array List < > ( ) ; } m Markers . add ( marker ) ; request Layout ( ) ; post Invalidate ( ) ; return BOOL ; }
public boolean add Marker ( String label , int value , int text Offset X , int text Offset Y , On Marker Click Listener on Marker Click Listener ) { if ( value > m Max || value < NUM ) { return BOOL ; } Marker marker = new Marker ( ) ; String lb = label ; if ( label != null && label . length ( ) > NUM ) { lb = label . substring ( NUM , NUM ) ; } marker . label = lb ; marker . value = value ; marker . offset X = text Offset X ; marker . offset Y = text Offset Y ; marker . progress Sweep = ( float ) value / m Max * m Sweep Angle ; marker . on Marker Click Listener = on Marker Click Listener ; if ( m Markers == null ) { m Markers = new Array List < > ( ) ; } m Markers . add ( marker ) ; request Layout ( ) ; post Invalidate ( ) ; return BOOL ; }
public static void clear Cell ( final Cell < ? > table Cell ) { if ( table Cell != null ) { table Cell . clear Actor ( ) ; table Cell . reset ( ) ; } }
public static void clear Cell ( final Cell < ? > table Cell ) { if ( table Cell != null ) { table Cell . clear Actor ( ) ; table Cell . reset ( ) ; } }
public static void validate Mac Tag ( String participant Id , String partner Participant Id , Big Integer gx 1 , Big Integer gx 2 , Big Integer gx 3 , Big Integer gx 4 , Big Integer keying Material , Digest digest , Big Integer partner Mac Tag ) throws Crypto Exception { Big Integer expected Mac Tag = calculate Mac Tag ( partner Participant Id , participant Id , gx 3 , gx 4 , gx 1 , gx 2 , keying Material , digest ) ; if ( ! expected Mac Tag . equals ( partner Mac Tag ) ) { throw new Crypto Exception ( STRING + STRING ) ; } }
public void add ( double weight , double x , double y ) { observations . add ( new Weighted Observed Point ( weight , x , y ) ) ; }
private void finalize Additions ( boolean add Home Screen Shortcuts ) { finalize Work Folder ( ) ; if ( add Home Screen Shortcuts && ! m Homescreen Apps . is Empty ( ) ) { m Model . add And Bind Added Workspace Items ( m Context , m Homescreen Apps ) ; } }
private void finalize Additions ( boolean add Home Screen Shortcuts ) { finalize Work Folder ( ) ; if ( add Home Screen Shortcuts && ! m Homescreen Apps . is Empty ( ) ) { m Model . add And Bind Added Workspace Items ( m Context , m Homescreen Apps ) ; } }
private String email To String ( String subject , String msg , String ... to ) { return STRING + msg + STRING + Arrays . as List ( to ) + STRING + subject + STRING ; }
private String email To String ( String subject , String msg , String ... to ) { return STRING + msg + STRING + Arrays . as List ( to ) + STRING + subject + STRING ; }
private static Tree Map < Integer , Long > load Workspace Screens Db ( Context context ) { final Content Resolver content Resolver = context . get Content Resolver ( ) ; final Uri screens Uri = Launcher Settings . Workspace Screens . CONTENT URI ; final Cursor sc = content Resolver . query ( screens Uri , null , null , null , null ) ; Tree Map < Integer , Long > ordered Screens = new Tree Map < Integer , Long > ( ) ; try { final int id Index = sc . get Column Index Or Throw ( Launcher Settings . Workspace Screens . ID ) ; final int rank Index = sc . get Column Index Or Throw ( Launcher Settings . Workspace Screens . SCREEN RANK ) ; while ( sc . move To Next ( ) ) { try { long screen Id = sc . get Long ( id Index ) ; int rank = sc . get Int ( rank Index ) ; ordered Screens . put ( rank , screen Id ) ; } catch ( Exception e ) { Launcher . add Dump Log ( TAG , STRING + e , BOOL ) ; } } } finally { sc . close ( ) ; } Launcher . add Dump Log ( TAG , STRING , BOOL ) ; Array List < String > ordered Screens Pairs = new Array List < String > ( ) ; for ( Integer i : ordered Screens . key Set ( ) ) { ordered Screens Pairs . add ( STRING + i + STRING + ordered Screens . get ( i ) + STRING ) ; } Launcher . add Dump Log ( TAG , STRING + Text Utils . join ( STRING , ordered Screens Pairs ) , BOOL ) ; return ordered Screens ; }
@ Rpc Method public void transfer Image ( String image Id , String source , String destination , Server Address destination Host , Async Method Callback < Host . Async Client . copy image call > handler ) throws Rpc Exception { ensure Client ( ) ; Transfer Image Request transfer Image Request = new Transfer Image Request ( ) ; transfer Image Request . set Destination datastore id ( destination ) ; transfer Image Request . set Destination host ( destination Host ) ; transfer Image Request . set Source datastore id ( source ) ; transfer Image Request . set Source image id ( image Id ) ; client Proxy . set Timeout ( TRANSFER IMAGE TIMEOUT MS ) ; logger . info ( STRING , get Host Ip ( ) , transfer Image Request ) ; try { client Proxy . transfer image ( transfer Image Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Rpc Method public void transfer Image ( String image Id , String source , String destination , Server Address destination Host , Async Method Callback < Host . Async Client . copy image call > handler ) throws Rpc Exception { ensure Client ( ) ; Transfer Image Request transfer Image Request = new Transfer Image Request ( ) ; transfer Image Request . set Destination datastore id ( destination ) ; transfer Image Request . set Destination host ( destination Host ) ; transfer Image Request . set Source datastore id ( source ) ; transfer Image Request . set Source image id ( image Id ) ; client Proxy . set Timeout ( TRANSFER IMAGE TIMEOUT MS ) ; logger . info ( STRING , get Host Ip ( ) , transfer Image Request ) ; try { client Proxy . transfer image ( transfer Image Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Rpc Method public void transfer Image ( String image Id , String source , String destination , Server Address destination Host , Async Method Callback < Host . Async Client . copy image call > handler ) throws Rpc Exception { ensure Client ( ) ; Transfer Image Request transfer Image Request = new Transfer Image Request ( ) ; transfer Image Request . set Destination datastore id ( destination ) ; transfer Image Request . set Destination host ( destination Host ) ; transfer Image Request . set Source datastore id ( source ) ; transfer Image Request . set Source image id ( image Id ) ; client Proxy . set Timeout ( TRANSFER IMAGE TIMEOUT MS ) ; logger . info ( STRING , get Host Ip ( ) , transfer Image Request ) ; try { client Proxy . transfer image ( transfer Image Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
public void swap Elements ( final int index 1 , final int index 2 ) { Collections . swap ( action List , index 1 , index 2 ) ; for ( Update Manager Listener listener : listeners ) { listener . action Order Changed ( ) ; } }
public void swap Elements ( final int index 1 , final int index 2 ) { Collections . swap ( action List , index 1 , index 2 ) ; for ( Update Manager Listener listener : listeners ) { listener . action Order Changed ( ) ; } }
Internal Window ( String title ) { set Layout ( new Border Layout ( ) ) ; title Bar = new Title Bar ( ) ; add ( title Bar , Border Layout . NORTH ) ; title Bar . set Layout ( new S Box Layout ( S Box Layout . HORIZONTAL , TITLEBAR PADDING ) ) ; title Label = new J Label ( ) ; set Title ( title ) ; title Label . set Minimum Size ( new Dimension ( NUM , NUM ) ) ; title Bar . add ( title Label ) ; S Box Layout . add Spring ( title Bar ) ; minimize Button = new J Button ( minimize Icon ) ; minimize Button . set Margin ( new Insets ( NUM , NUM , NUM , NUM ) ) ; minimize Button . set Border ( Border Factory . create Empty Border ( ) ) ; minimize Button . set Focusable ( BOOL ) ; minimize Button . add Action Listener ( new Minimize Listener ( ) ) ; title Bar . add ( minimize Button ) ; close Button = new J Button ( close Icon ) ; close Button . set Margin ( new Insets ( NUM , NUM , NUM , NUM ) ) ; close Button . set Border ( Border Factory . create Empty Border ( ) ) ; close Button . set Focusable ( BOOL ) ; close Button . add Action Listener ( new Close Action Listener ( ) ) ; title Bar . add ( close Button ) ; cache = new Component Paint Cache ( this ) ; }
public void remove Storage ( ) throws Backup Exception { logger . debug ( STRING + data Dir Spec . get Absolute Path ( ) ) ; process Helper . exec ( STRING , rm Cmd ) ; }
public synchronized int add ( I Audio Provider provider ) { providers . add ( provider ) ; return providers . index Of ( provider ) ; }
public void add Attribute Listener ( final Attribute Listener listener ) { attribute Listeners . add ( listener ) ; }
public final void write Long ( final long l ) { baos . write ( ( byte ) ( l & NUM ) ) ; baos . write ( ( byte ) ( ( l > > > NUM ) & NUM ) ) ; baos . write ( ( byte ) ( ( l > > > NUM ) & NUM ) ) ; baos . write ( ( byte ) ( ( l > > > NUM ) & NUM ) ) ; baos . write ( ( byte ) ( ( l > > > NUM ) & NUM ) ) ; baos . write ( ( byte ) ( ( l > > > NUM ) & NUM ) ) ; baos . write ( ( byte ) ( ( l > > > NUM ) & NUM ) ) ; baos . write ( ( byte ) ( ( l > > > NUM ) & NUM ) ) ; }
public static String transform Method Signature ( String signature ) { String Builder buf = new String Builder ( ) ; buf . append ( STRING ) ; Signature Parser parser = new Signature Parser ( signature ) ; for ( Iterator < String > i = parser . parameter Signature Iterator ( ) ; i . has Next ( ) ; ) { String param = i . next ( ) ; param = transform Signature ( param ) ; buf . append ( param ) ; } buf . append ( STRING ) ; return buf . to String ( ) ; }
public Math Vector rotate ( double angle ) { double rad = angle * TO RADIANS ; double cos = Math . cos ( rad ) ; double sin = Math . sin ( rad ) ; double new X = this . x * cos - this . y * sin ; double new Y = this . x * sin + this . y * cos ; this . x = new X ; this . y = new Y ; return this ; }
public Math Vector rotate ( double angle ) { double rad = angle * TO RADIANS ; double cos = Math . cos ( rad ) ; double sin = Math . sin ( rad ) ; double new X = this . x * cos - this . y * sin ; double new Y = this . x * sin + this . y * cos ; this . x = new X ; this . y = new Y ; return this ; }
private void start Distributed System ( Filter Config config ) { final String cache Type = config . get Init Parameter ( INIT PARAM CACHE TYPE ) ; if ( CACHE TYPE CLIENT SERVER . equals ( cache Type ) ) { distributed Cache = Client Server Cache . get Instance ( ) ; } else if ( CACHE TYPE PEER TO PEER . equals ( cache Type ) ) { distributed Cache = Peer To Peer Cache . get Instance ( ) ; } else { LOG . error ( STRING + STRING ) ; return ; } if ( ! distributed Cache . is Started ( ) ) { for ( Enumeration < String > e = config . get Init Parameter Names ( ) ; e . has More Elements ( ) ; ) { String param = e . next Element ( ) ; if ( ! param . starts With ( GEMFIRE PROPERTY ) ) { continue ; } String gemfire Property = param . substring ( GEMFIRE PROPERTY . length ( ) ) ; LOG . info ( STRING , gemfire Property , config . get Init Parameter ( param ) ) ; distributed Cache . set Property ( gemfire Property , config . get Init Parameter ( param ) ) ; } distributed Cache . lifecycle Event ( Lifecycle Type Adapter . START ) ; } }
public Tristate has Permission ( Node node , boolean t ) { for ( Node n : t ? get Transient Nodes ( ) : get Nodes ( ) ) { if ( n . almost Equals ( node ) ) { return n . get Tristate ( ) ; } } return Tristate . UNDEFINED ; }
protected void log Layout ( Visual Table labels ) { Rectangle 2 D b = get Layout Bounds ( ) ; double breadth = get Breadth ( b ) ; labels . clear ( ) ; double llo = Math Lib . safe Log 10 ( m lo ) ; double lhi = Math Lib . safe Log 10 ( m hi ) ; double lspan = lhi - llo ; double d = Math Lib . log 10 ( lhi - llo ) ; int e = ( int ) Math . floor ( d ) ; int ilo = ( int ) Math . floor ( llo ) ; int ihi = ( int ) Math . ceil ( lhi ) ; double start = Math . pow ( NUM , ilo ) ; double end = Math . pow ( NUM , ihi ) ; double step = start * Math . pow ( NUM , e ) ; for ( double val , v = start , i = NUM ; v <= end ; v += step , ++ i ) { val = Math Lib . safe Log 10 ( v ) ; if ( i != NUM && Math . abs ( val - Math . round ( val ) ) < NUM ) { i = NUM ; step = NUM * step ; } val = ( ( val - llo ) / lspan ) * breadth ; if ( val < - NUM ) continue ; Visual Item item = labels . add Item ( ) ; set ( item , val , b ) ; String label = i == NUM ? m nf . format ( v ) : null ; item . set ( LABEL , label ) ; item . set Double ( VALUE , v ) ; } }
protected void log Layout ( Visual Table labels ) { Rectangle 2 D b = get Layout Bounds ( ) ; double breadth = get Breadth ( b ) ; labels . clear ( ) ; double llo = Math Lib . safe Log 10 ( m lo ) ; double lhi = Math Lib . safe Log 10 ( m hi ) ; double lspan = lhi - llo ; double d = Math Lib . log 10 ( lhi - llo ) ; int e = ( int ) Math . floor ( d ) ; int ilo = ( int ) Math . floor ( llo ) ; int ihi = ( int ) Math . ceil ( lhi ) ; double start = Math . pow ( NUM , ilo ) ; double end = Math . pow ( NUM , ihi ) ; double step = start * Math . pow ( NUM , e ) ; for ( double val , v = start , i = NUM ; v <= end ; v += step , ++ i ) { val = Math Lib . safe Log 10 ( v ) ; if ( i != NUM && Math . abs ( val - Math . round ( val ) ) < NUM ) { i = NUM ; step = NUM * step ; } val = ( ( val - llo ) / lspan ) * breadth ; if ( val < - NUM ) continue ; Visual Item item = labels . add Item ( ) ; set ( item , val , b ) ; String label = i == NUM ? m nf . format ( v ) : null ; item . set ( LABEL , label ) ; item . set Double ( VALUE , v ) ; } }
protected void log Layout ( Visual Table labels ) { Rectangle 2 D b = get Layout Bounds ( ) ; double breadth = get Breadth ( b ) ; labels . clear ( ) ; double llo = Math Lib . safe Log 10 ( m lo ) ; double lhi = Math Lib . safe Log 10 ( m hi ) ; double lspan = lhi - llo ; double d = Math Lib . log 10 ( lhi - llo ) ; int e = ( int ) Math . floor ( d ) ; int ilo = ( int ) Math . floor ( llo ) ; int ihi = ( int ) Math . ceil ( lhi ) ; double start = Math . pow ( NUM , ilo ) ; double end = Math . pow ( NUM , ihi ) ; double step = start * Math . pow ( NUM , e ) ; for ( double val , v = start , i = NUM ; v <= end ; v += step , ++ i ) { val = Math Lib . safe Log 10 ( v ) ; if ( i != NUM && Math . abs ( val - Math . round ( val ) ) < NUM ) { i = NUM ; step = NUM * step ; } val = ( ( val - llo ) / lspan ) * breadth ; if ( val < - NUM ) continue ; Visual Item item = labels . add Item ( ) ; set ( item , val , b ) ; String label = i == NUM ? m nf . format ( v ) : null ; item . set ( LABEL , label ) ; item . set Double ( VALUE , v ) ; } }
protected void log Layout ( Visual Table labels ) { Rectangle 2 D b = get Layout Bounds ( ) ; double breadth = get Breadth ( b ) ; labels . clear ( ) ; double llo = Math Lib . safe Log 10 ( m lo ) ; double lhi = Math Lib . safe Log 10 ( m hi ) ; double lspan = lhi - llo ; double d = Math Lib . log 10 ( lhi - llo ) ; int e = ( int ) Math . floor ( d ) ; int ilo = ( int ) Math . floor ( llo ) ; int ihi = ( int ) Math . ceil ( lhi ) ; double start = Math . pow ( NUM , ilo ) ; double end = Math . pow ( NUM , ihi ) ; double step = start * Math . pow ( NUM , e ) ; for ( double val , v = start , i = NUM ; v <= end ; v += step , ++ i ) { val = Math Lib . safe Log 10 ( v ) ; if ( i != NUM && Math . abs ( val - Math . round ( val ) ) < NUM ) { i = NUM ; step = NUM * step ; } val = ( ( val - llo ) / lspan ) * breadth ; if ( val < - NUM ) continue ; Visual Item item = labels . add Item ( ) ; set ( item , val , b ) ; String label = i == NUM ? m nf . format ( v ) : null ; item . set ( LABEL , label ) ; item . set Double ( VALUE , v ) ; } }
public int estimate Cell V Span ( int height ) { int avail Height = height - ( get Padding Top ( ) + get Padding Bottom ( ) ) ; int n = Math . max ( NUM , ( avail Height + m Height Gap ) / ( m Cell Height + m Height Gap ) ) ; return n ; }
public static long copy Stream ( Input Stream in , Output Stream out ) throws IO Exception { Reject . if Null ( in , out ) ; final byte [ ] buffer = new byte [ BUFFER SIZE ] ; long bytes Copied = NUM ; for ( int bytes Read = in . read ( buffer ) ; bytes Read != - NUM ; bytes Read = in . read ( buffer ) ) { out . write ( buffer , NUM , bytes Read ) ; bytes Copied += bytes Read ; } return bytes Copied ; }
public synchronized boolean on Delta Received ( UUID node Id , long time Delta ) { Delta Average avg = pending Deltas . get ( node Id ) ; if ( avg != null ) { avg . on Value ( time Delta ) ; if ( avg . ready ( ) ) { pending Deltas . remove ( node Id ) ; deltas . put ( node Id , avg . average ( ) ) ; if ( ready ( ) ) notify All ( ) ; return BOOL ; } return BOOL ; } return BOOL ; }
public List < Correlation Identifier > find Correlation Ids ( Scope ... scope ) { List < Correlation Identifier > ret = null ; for ( int i = NUM ; i < correlation Ids . size ( ) ; i ++ ) { Correlation Identifier cid = correlation Ids . get ( i ) ; for ( int j = NUM ; j < scope . length ; j ++ ) { if ( cid . get Scope ( ) == scope [ j ] ) { if ( ret == null ) { ret = new Array List < Correlation Identifier > ( ) ; } if ( ! ret . contains ( cid ) ) { ret . add ( cid ) ; } } } } return ret == null ? Collections . empty List ( ) : ret ; }
public List < Correlation Identifier > find Correlation Ids ( Scope ... scope ) { List < Correlation Identifier > ret = null ; for ( int i = NUM ; i < correlation Ids . size ( ) ; i ++ ) { Correlation Identifier cid = correlation Ids . get ( i ) ; for ( int j = NUM ; j < scope . length ; j ++ ) { if ( cid . get Scope ( ) == scope [ j ] ) { if ( ret == null ) { ret = new Array List < Correlation Identifier > ( ) ; } if ( ! ret . contains ( cid ) ) { ret . add ( cid ) ; } } } } return ret == null ? Collections . empty List ( ) : ret ; }
public List < Correlation Identifier > find Correlation Ids ( Scope ... scope ) { List < Correlation Identifier > ret = null ; for ( int i = NUM ; i < correlation Ids . size ( ) ; i ++ ) { Correlation Identifier cid = correlation Ids . get ( i ) ; for ( int j = NUM ; j < scope . length ; j ++ ) { if ( cid . get Scope ( ) == scope [ j ] ) { if ( ret == null ) { ret = new Array List < Correlation Identifier > ( ) ; } if ( ! ret . contains ( cid ) ) { ret . add ( cid ) ; } } } } return ret == null ? Collections . empty List ( ) : ret ; }
public List < Correlation Identifier > find Correlation Ids ( Scope ... scope ) { List < Correlation Identifier > ret = null ; for ( int i = NUM ; i < correlation Ids . size ( ) ; i ++ ) { Correlation Identifier cid = correlation Ids . get ( i ) ; for ( int j = NUM ; j < scope . length ; j ++ ) { if ( cid . get Scope ( ) == scope [ j ] ) { if ( ret == null ) { ret = new Array List < Correlation Identifier > ( ) ; } if ( ! ret . contains ( cid ) ) { ret . add ( cid ) ; } } } } return ret == null ? Collections . empty List ( ) : ret ; }
public List < Correlation Identifier > find Correlation Ids ( Scope ... scope ) { List < Correlation Identifier > ret = null ; for ( int i = NUM ; i < correlation Ids . size ( ) ; i ++ ) { Correlation Identifier cid = correlation Ids . get ( i ) ; for ( int j = NUM ; j < scope . length ; j ++ ) { if ( cid . get Scope ( ) == scope [ j ] ) { if ( ret == null ) { ret = new Array List < Correlation Identifier > ( ) ; } if ( ! ret . contains ( cid ) ) { ret . add ( cid ) ; } } } } return ret == null ? Collections . empty List ( ) : ret ; }
public List < Correlation Identifier > find Correlation Ids ( Scope ... scope ) { List < Correlation Identifier > ret = null ; for ( int i = NUM ; i < correlation Ids . size ( ) ; i ++ ) { Correlation Identifier cid = correlation Ids . get ( i ) ; for ( int j = NUM ; j < scope . length ; j ++ ) { if ( cid . get Scope ( ) == scope [ j ] ) { if ( ret == null ) { ret = new Array List < Correlation Identifier > ( ) ; } if ( ! ret . contains ( cid ) ) { ret . add ( cid ) ; } } } } return ret == null ? Collections . empty List ( ) : ret ; }
public static String display Inputs ( String name , Map < String , Object > map , Local Variable Map symbol Table ) { String Builder sb = new String Builder ( ) ; sb . append ( name ) ; sb . append ( STRING ) ; Set < String > keys = map . key Set ( ) ; if ( keys . is Empty ( ) ) { sb . append ( STRING ) ; } else { int count = NUM ; for ( String key : keys ) { Object object = map . get ( key ) ; @ Suppress Warnings ( STRING ) Class clazz = object . get Class ( ) ; String type = clazz . get Simple Name ( ) ; if ( object instanceof Java RDD < ? > ) { type = STRING ; } else if ( object instanceof RDD < ? > ) { type = STRING ; } sb . append ( STRING ) ; sb . append ( ++ count ) ; sb . append ( STRING ) ; sb . append ( STRING ) ; sb . append ( type ) ; if ( does Symbol Table Contain Matrix Object ( symbol Table , key ) ) { sb . append ( STRING ) ; } else if ( does Symbol Table Contain Frame Object ( symbol Table , key ) ) { sb . append ( STRING ) ; } sb . append ( STRING ) ; sb . append ( key ) ; sb . append ( STRING ) ; String str = object . to String ( ) ; str = String Utils . abbreviate ( str , NUM ) ; sb . append ( str ) ; sb . append ( STRING ) ; } } return sb . to String ( ) ; }
private String as Reg Pattern ( String string ) { String Buffer out = new String Buffer ( string . length ( ) ) ; for ( int i = NUM , length = string . length ( ) ; i < length ; i ++ ) { char ch = string . char At ( i ) ; if ( ch == STRING ) { out . append ( STRING ) ; } else if ( ch == STRING ) { out . append ( STRING ) ; } else { out . append ( ch ) ; } } return out . to String ( ) ; }
private String as Reg Pattern ( String string ) { String Buffer out = new String Buffer ( string . length ( ) ) ; for ( int i = NUM , length = string . length ( ) ; i < length ; i ++ ) { char ch = string . char At ( i ) ; if ( ch == STRING ) { out . append ( STRING ) ; } else if ( ch == STRING ) { out . append ( STRING ) ; } else { out . append ( ch ) ; } } return out . to String ( ) ; }
private String as Reg Pattern ( String string ) { String Buffer out = new String Buffer ( string . length ( ) ) ; for ( int i = NUM , length = string . length ( ) ; i < length ; i ++ ) { char ch = string . char At ( i ) ; if ( ch == STRING ) { out . append ( STRING ) ; } else if ( ch == STRING ) { out . append ( STRING ) ; } else { out . append ( ch ) ; } } return out . to String ( ) ; }
protected String const Name ( ) { return STRING + name . to Upper Case ( ) ; }
protected String const Name ( ) { return STRING + name . to Upper Case ( ) ; }
@ Override public void write ( byte [ ] buffer , int offset , int length ) { if ( is Closed ( ) || is Head ( ) ) { return ; } int byte Length = offset ; while ( BOOL ) { int sublen = Math . min ( length , SIZE - byte Length ) ; System . arraycopy ( buffer , offset , buffer , byte Length , sublen ) ; offset += sublen ; length -= sublen ; byte Length += sublen ; if ( length <= NUM ) { break ; } offset = byte Length ; flush Byte Buffer ( ) ; byte Length = offset ; } offset = byte Length ; }
private void disable Maintenance Mode ( ) { synchronized ( maintenance Enabled ) { if ( maintenance Enabled . get And Set ( BOOL ) ) { maintenance Filter . disable Maintenance Mode ( ) ; } } }
private void disable Maintenance Mode ( ) { synchronized ( maintenance Enabled ) { if ( maintenance Enabled . get And Set ( BOOL ) ) { maintenance Filter . disable Maintenance Mode ( ) ; } } }
private static Hashtable update Naming Table ( boolean for Client ) throws SMS Exception { Hashtable nametable = null ; try { Service Schema sc = ssm Naming . get Global Schema ( ) ; Map naming Attrs = sc . get Attribute Defaults ( ) ; sc = ssm Platform . get Global Schema ( ) ; Map platform Attrs = sc . get Attribute Defaults ( ) ; Set sites = get Sites ( platform Attrs ) ; Set servers = get Servers ( platform Attrs , sites ) ; Set site Names And I Ds = get Site Names And I Ds ( ) ; store Site Names ( site Names And I Ds , naming Attrs ) ; if ( ( sites != null ) && ! sites . is Empty ( ) ) { if ( ! for Client ) { regist FQDN Mapping ( sites ) ; } sites . add All ( servers ) ; } else { sites = servers ; } if ( for Client ) { store Server List For Client ( sites , naming Attrs ) ; } else { store Server List ( sites , naming Attrs ) ; } nametable = convert To Hash ( naming Attrs ) ; if ( for Client && ( naming Table != null ) ) { String site List = ( String ) naming Table . get ( Constants . SITE ID LIST ) ; nametable . put ( Constants . SITE ID LIST , site List ) ; } insert LB Cookie Values ( nametable ) ; } catch ( Exception ex ) { String error Msg = STRING ; naming Debug . error ( error Msg , ex ) ; if ( ex . get Message ( ) != null ) { error Msg = ex . get Message ( ) ; } throw new SMS Exception ( error Msg ) ; } return nametable ; }
public final void translate ( Char Sequence input , Writer out ) throws IO Exception { if ( out == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( input == null ) { return ; } int pos = NUM ; int len = input . length ( ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed == NUM ) { char [ ] c = Character . to Chars ( Character . code Point At ( input , pos ) ) ; out . write ( c ) ; pos += c . length ; continue ; } for ( int pt = NUM ; pt < consumed ; pt ++ ) { pos += Character . char Count ( Character . code Point At ( input , pos ) ) ; } } }
public final void translate ( Char Sequence input , Writer out ) throws IO Exception { if ( out == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( input == null ) { return ; } int pos = NUM ; int len = input . length ( ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed == NUM ) { char [ ] c = Character . to Chars ( Character . code Point At ( input , pos ) ) ; out . write ( c ) ; pos += c . length ; continue ; } for ( int pt = NUM ; pt < consumed ; pt ++ ) { pos += Character . char Count ( Character . code Point At ( input , pos ) ) ; } } }
public final void translate ( Char Sequence input , Writer out ) throws IO Exception { if ( out == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( input == null ) { return ; } int pos = NUM ; int len = input . length ( ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed == NUM ) { char [ ] c = Character . to Chars ( Character . code Point At ( input , pos ) ) ; out . write ( c ) ; pos += c . length ; continue ; } for ( int pt = NUM ; pt < consumed ; pt ++ ) { pos += Character . char Count ( Character . code Point At ( input , pos ) ) ; } } }
@ Override public void on Success ( DLSN value ) { if ( value . get Log Segment Sequence No ( ) != current Log Segment Seq No ) { LOG . error ( STRING , value . get Log Segment Sequence No ( ) , current Log Segment Seq No ) ; errors Found . set ( BOOL ) ; } if ( verify Entry Id && value . get Entry Id ( ) != current Entry Id ) { LOG . error ( STRING , value . get Entry Id ( ) , current Entry Id ) ; errors Found . set ( BOOL ) ; } sync Latch . count Down ( ) ; }
public void test Constructor Sign Bytes Positive 7 ( ) { byte a Bytes [ ] = { - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , - NUM } ; int a Sign = NUM ; byte r Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
void write ( Image Output Stream ios ) throws IO Exception { length = NUM + ( ( data != null ) ? data . length : NUM ) ; write Tag ( ios ) ; if ( data != null ) { ios . write ( data ) ; } }
private static < T > void assert Collection Equals No Order ( Collection < T > expected , Collection < T > actual ) { String msg = String . format ( STRING , expected . to String ( ) , actual . to String ( ) ) ; assert Equals ( msg , expected . size ( ) , actual . size ( ) ) ; for ( T e : expected ) { if ( ! actual . contains ( e ) ) { msg = String . format ( STRING + STRING , e , expected , actual ) ; fail ( msg ) ; } } }
private static < T > void assert Collection Equals No Order ( Collection < T > expected , Collection < T > actual ) { String msg = String . format ( STRING , expected . to String ( ) , actual . to String ( ) ) ; assert Equals ( msg , expected . size ( ) , actual . size ( ) ) ; for ( T e : expected ) { if ( ! actual . contains ( e ) ) { msg = String . format ( STRING + STRING , e , expected , actual ) ; fail ( msg ) ; } } }
private static < T > void assert Collection Equals No Order ( Collection < T > expected , Collection < T > actual ) { String msg = String . format ( STRING , expected . to String ( ) , actual . to String ( ) ) ; assert Equals ( msg , expected . size ( ) , actual . size ( ) ) ; for ( T e : expected ) { if ( ! actual . contains ( e ) ) { msg = String . format ( STRING + STRING , e , expected , actual ) ; fail ( msg ) ; } } }
private static < T > void assert Collection Equals No Order ( Collection < T > expected , Collection < T > actual ) { String msg = String . format ( STRING , expected . to String ( ) , actual . to String ( ) ) ; assert Equals ( msg , expected . size ( ) , actual . size ( ) ) ; for ( T e : expected ) { if ( ! actual . contains ( e ) ) { msg = String . format ( STRING + STRING , e , expected , actual ) ; fail ( msg ) ; } } }
private static byte [ ] hmac sha ( String crypto , byte [ ] key Bytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . get Instance ( crypto ) ; Secret Key Spec mac Key = new Secret Key Spec ( key Bytes , STRING ) ; hmac . init ( mac Key ) ; return hmac . do Final ( text ) ; } catch ( General Security Exception gse ) { throw new Undeclared Throwable Exception ( gse ) ; } }
private static byte [ ] hmac sha ( String crypto , byte [ ] key Bytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . get Instance ( crypto ) ; Secret Key Spec mac Key = new Secret Key Spec ( key Bytes , STRING ) ; hmac . init ( mac Key ) ; return hmac . do Final ( text ) ; } catch ( General Security Exception gse ) { throw new Undeclared Throwable Exception ( gse ) ; } }
public void write Comments ( Writer writer ) throws IO Exception { for ( String s : key Val Comments ) { writer . write ( s ) ; } }
public void write Comments ( Writer writer ) throws IO Exception { for ( String s : key Val Comments ) { writer . write ( s ) ; } }
public void write Comments ( Writer writer ) throws IO Exception { for ( String s : key Val Comments ) { writer . write ( s ) ; } }
public static < E extends Enum < E > > Enum Set < E > of ( E e ) { Enum Set < E > set = Enum Set . none Of ( e . get Declaring Class ( ) ) ; set . add ( e ) ; return set ; }
public static < E extends Enum < E > > Enum Set < E > of ( E e ) { Enum Set < E > set = Enum Set . none Of ( e . get Declaring Class ( ) ) ; set . add ( e ) ; return set ; }
public static < E extends Enum < E > > Enum Set < E > of ( E e ) { Enum Set < E > set = Enum Set . none Of ( e . get Declaring Class ( ) ) ; set . add ( e ) ; return set ; }
public static < E extends Enum < E > > Enum Set < E > of ( E e ) { Enum Set < E > set = Enum Set . none Of ( e . get Declaring Class ( ) ) ; set . add ( e ) ; return set ; }
public static < E extends Enum < E > > Enum Set < E > of ( E e ) { Enum Set < E > set = Enum Set . none Of ( e . get Declaring Class ( ) ) ; set . add ( e ) ; return set ; }
public static < E extends Enum < E > > Enum Set < E > of ( E e ) { Enum Set < E > set = Enum Set . none Of ( e . get Declaring Class ( ) ) ; set . add ( e ) ; return set ; }
public static < E extends Enum < E > > Enum Set < E > of ( E e ) { Enum Set < E > set = Enum Set . none Of ( e . get Declaring Class ( ) ) ; set . add ( e ) ; return set ; }
public static < E extends Enum < E > > Enum Set < E > of ( E e ) { Enum Set < E > set = Enum Set . none Of ( e . get Declaring Class ( ) ) ; set . add ( e ) ; return set ; }
public Id Query ( Class < T > type , Object id , Object routing , int version ) { this ( type . get Name ( ) , id , routing , Query Result Type . DEFAULT , version ) ; }
public Id Query ( Class < T > type , Object id , Object routing , int version ) { this ( type . get Name ( ) , id , routing , Query Result Type . DEFAULT , version ) ; }
public Id Query ( Class < T > type , Object id , Object routing , int version ) { this ( type . get Name ( ) , id , routing , Query Result Type . DEFAULT , version ) ; }
private String strip Off CR ( String str ) { String [ ] arr = str . split ( STRING ) ; String Builder buf = new String Builder ( ) ; for ( String s : arr ) { if ( s . ends With ( STRING ) ) { buf . append ( s . substring ( NUM , s . length ( ) - NUM ) ) ; } else { buf . append ( s ) ; } buf . append ( STRING ) ; } return buf . to String ( ) ; }
private String strip Off CR ( String str ) { String [ ] arr = str . split ( STRING ) ; String Builder buf = new String Builder ( ) ; for ( String s : arr ) { if ( s . ends With ( STRING ) ) { buf . append ( s . substring ( NUM , s . length ( ) - NUM ) ) ; } else { buf . append ( s ) ; } buf . append ( STRING ) ; } return buf . to String ( ) ; }
@ Override public int hash Code ( ) { int hc = hash Code Value ; if ( hc == NUM ) { hc = base Locale . hash Code ( ) ; if ( locale Extensions != null ) { hc ^= locale Extensions . hash Code ( ) ; } hash Code Value = hc ; } return hc ; }
@ Override public int hash Code ( ) { int hc = hash Code Value ; if ( hc == NUM ) { hc = base Locale . hash Code ( ) ; if ( locale Extensions != null ) { hc ^= locale Extensions . hash Code ( ) ; } hash Code Value = hc ; } return hc ; }
@ Override public int hash Code ( ) { int hc = hash Code Value ; if ( hc == NUM ) { hc = base Locale . hash Code ( ) ; if ( locale Extensions != null ) { hc ^= locale Extensions . hash Code ( ) ; } hash Code Value = hc ; } return hc ; }
public static void update Port Associations ( Network Lite network , List < Storage Port > ports , Db Client db Client ) { Set < String > varray Set = new Hash Set < String > ( network . get Assigned Virtual Arrays ( ) ) ; for ( Storage Port port : ports ) { port . set Network ( network . get Id ( ) ) ; port . replace Connected Virtual Array ( varray Set ) ; log . info ( STRING , port . get Port Network Id ( ) , varray Set ) ; } db Client . update And Reindex Object ( ports ) ; }
public Socket accept ( ) throws IO Exception { synchronized ( init Lock ) { try { while ( ! init Done ) { init Lock . wait ( ) ; } } catch ( Interrupted Exception ignore ) { throw new Assertion Error ( ignore ) ; } } return server Socket . accept ( ) ; }
public static boolean reachable ( Network Interface itf , Inet Address addr , int reach Timeout ) { try { return addr . is Reachable ( itf , NUM , reach Timeout ) ; } catch ( IO Exception ignore ) { return BOOL ; } }
public Permuter ( int n ) { if ( n < NUM ) { throw new Illegal Argument Exception ( ) ; } modulus = n ; if ( n == NUM ) { return ; } multiplier = ( int ) Math . sqrt ( n ) ; while ( gcd ( multiplier , n ) != NUM ) { if ( ++ multiplier == n ) { multiplier = NUM ; } } }
public static boolean move File ( Context context , @ Non Null final File source , @ Non Null final File target Dir ) { File target = new File ( target Dir , source . get Name ( ) ) ; boolean success = source . rename To ( target ) ; if ( ! success ) { success = copy File ( context , source , target Dir ) ; if ( success ) { success = delete File ( context , source ) ; } } return success ; }
public void test Delete 5 ( ) throws SQL Exception { statement . execute ( STRING + Database Creator . PARENT TABLE + STRING ) ; Result Set r = statement . execute Query ( STRING + Database Creator . FKCASCADE TABLE + STRING ) ; r . next ( ) ; assert Equals ( STRING , NUM , r . get Int ( NUM ) ) ; r . close ( ) ; }
public synchronized void shutdown ( boolean immediate ) { logger . info ( STRING + name ) ; for ( Stage stage : stages ) stage . shutdown ( immediate ) ; shutdown Task Exec . shutdown Now ( ) ; }
public synchronized void shutdown ( boolean immediate ) { logger . info ( STRING + name ) ; for ( Stage stage : stages ) stage . shutdown ( immediate ) ; shutdown Task Exec . shutdown Now ( ) ; }
public synchronized void shutdown ( boolean immediate ) { logger . info ( STRING + name ) ; for ( Stage stage : stages ) stage . shutdown ( immediate ) ; shutdown Task Exec . shutdown Now ( ) ; }
public boolean check For Type ( Types type ) { if ( types == null ) { return BOOL ; } else { return types . contains ( type . to String ( ) ) ; } }
@ Override public void process Headless Events ( List < Event Object > headless ) { if ( ! Graphics Environment . is Headless ( ) ) { m processing Headless Events = BOOL ; for ( Event Object e : headless ) { if ( e instanceof Threshold Data Event ) { accept Data Set ( ( Threshold Data Event ) e ) ; } else if ( e instanceof Visualizable Error Event ) { accept Data Set ( ( Visualizable Error Event ) e ) ; } } } m processing Headless Events = BOOL ; }
@ Override public void process Headless Events ( List < Event Object > headless ) { if ( ! Graphics Environment . is Headless ( ) ) { m processing Headless Events = BOOL ; for ( Event Object e : headless ) { if ( e instanceof Threshold Data Event ) { accept Data Set ( ( Threshold Data Event ) e ) ; } else if ( e instanceof Visualizable Error Event ) { accept Data Set ( ( Visualizable Error Event ) e ) ; } } } m processing Headless Events = BOOL ; }
@ Override public void process Headless Events ( List < Event Object > headless ) { if ( ! Graphics Environment . is Headless ( ) ) { m processing Headless Events = BOOL ; for ( Event Object e : headless ) { if ( e instanceof Threshold Data Event ) { accept Data Set ( ( Threshold Data Event ) e ) ; } else if ( e instanceof Visualizable Error Event ) { accept Data Set ( ( Visualizable Error Event ) e ) ; } } } m processing Headless Events = BOOL ; }
@ Override public void process Headless Events ( List < Event Object > headless ) { if ( ! Graphics Environment . is Headless ( ) ) { m processing Headless Events = BOOL ; for ( Event Object e : headless ) { if ( e instanceof Threshold Data Event ) { accept Data Set ( ( Threshold Data Event ) e ) ; } else if ( e instanceof Visualizable Error Event ) { accept Data Set ( ( Visualizable Error Event ) e ) ; } } } m processing Headless Events = BOOL ; }
public synchronized void decrement ( int weight ) { if ( weight == NUM ) return ; minimum += weight ; int logfloor = ( int ) ( Math . floor ( Math . log ( weight ) / Math . log ( NUM ) ) ) ; if ( logfloor < voting Record . size ( ) - NUM ) { while ( logfloor > NUM ) { selected Decrement ( logfloor ) ; weight = weight - ( int ) Math . pow ( NUM , logfloor ) ; logfloor = ( int ) ( Math . floor ( Math . log ( weight ) / Math . log ( NUM ) ) ) ; } } for ( int x = NUM ; x < weight ; x ++ ) { decrement ( ) ; } }
public synchronized void decrement ( int weight ) { if ( weight == NUM ) return ; minimum += weight ; int logfloor = ( int ) ( Math . floor ( Math . log ( weight ) / Math . log ( NUM ) ) ) ; if ( logfloor < voting Record . size ( ) - NUM ) { while ( logfloor > NUM ) { selected Decrement ( logfloor ) ; weight = weight - ( int ) Math . pow ( NUM , logfloor ) ; logfloor = ( int ) ( Math . floor ( Math . log ( weight ) / Math . log ( NUM ) ) ) ; } } for ( int x = NUM ; x < weight ; x ++ ) { decrement ( ) ; } }
public synchronized void decrement ( int weight ) { if ( weight == NUM ) return ; minimum += weight ; int logfloor = ( int ) ( Math . floor ( Math . log ( weight ) / Math . log ( NUM ) ) ) ; if ( logfloor < voting Record . size ( ) - NUM ) { while ( logfloor > NUM ) { selected Decrement ( logfloor ) ; weight = weight - ( int ) Math . pow ( NUM , logfloor ) ; logfloor = ( int ) ( Math . floor ( Math . log ( weight ) / Math . log ( NUM ) ) ) ; } } for ( int x = NUM ; x < weight ; x ++ ) { decrement ( ) ; } }
public synchronized void cancel If Killed ( Future < ? > f ) { clean Futures To Kill ( ) ; if ( is Killed ( ) ) { f . cancel ( BOOL ) ; } future To Cancel . add ( new Weak Reference < > ( f ) ) ; }
private static Class < ? > find Class ( Class Loader loader , Class < ? > clazz ) { final String name = clazz . get Name ( ) ; if ( name . starts With ( STRING ) || name . starts With ( STRING ) ) return null ; String generated Class Name = generate Retainer Class Name ( name ) ; try { if ( Akatsuki . logging Level == Akatsuki Config . Logging Level . VERBOSE ) Log . i ( Akatsuki . TAG , STRING + clazz ) ; return Class . for Name ( generated Class Name , BOOL , loader ) ; } catch ( Class Not Found Exception e ) { return find Class ( loader , clazz . get Superclass ( ) ) ; } }
private static Class < ? > find Class ( Class Loader loader , Class < ? > clazz ) { final String name = clazz . get Name ( ) ; if ( name . starts With ( STRING ) || name . starts With ( STRING ) ) return null ; String generated Class Name = generate Retainer Class Name ( name ) ; try { if ( Akatsuki . logging Level == Akatsuki Config . Logging Level . VERBOSE ) Log . i ( Akatsuki . TAG , STRING + clazz ) ; return Class . for Name ( generated Class Name , BOOL , loader ) ; } catch ( Class Not Found Exception e ) { return find Class ( loader , clazz . get Superclass ( ) ) ; } }
public Parse filter ( String url , Web Page page , Parse parse , HTML Meta Tags meta Tags , Document Fragment doc ) { for ( Parse Filter parse Filter : parse Filters ) { parse = parse Filter . filter ( url , page , parse , meta Tags , doc ) ; if ( ! Parse Status Utils . is Success ( parse . get Parse Status ( ) ) ) { return parse ; } } return parse ; }
private void display Popup Menu ( final Mouse Event event ) { final int selected Index = m table . row At Point ( event . get Point ( ) ) ; if ( selected Index != - NUM ) { final C Cross Reference reference = m cross References . get ( selected Index ) ; final C Cross References Table Menu popup Menu = new C Cross References Table Menu ( m parent , m view Container , reference . get Calling Function ( ) ) ; popup Menu . show ( m table , event . get X ( ) , event . get Y ( ) ) ; } }
public void test Compute Classpath For Jre ( ) throws Core Exception { assert Equals ( NUM , java Project A . get Raw Classpath ( ) . length ) ; List < File > actual Cp = get List Of Files ( GWT Compile Runner . compute Classpath ( java Project A ) ) ; assert Equals ( NUM , actual Cp . size ( ) ) ; }
public void test Compute Classpath For Jre ( ) throws Core Exception { assert Equals ( NUM , java Project A . get Raw Classpath ( ) . length ) ; List < File > actual Cp = get List Of Files ( GWT Compile Runner . compute Classpath ( java Project A ) ) ; assert Equals ( NUM , actual Cp . size ( ) ) ; }
public void test Compute Classpath For Jre ( ) throws Core Exception { assert Equals ( NUM , java Project A . get Raw Classpath ( ) . length ) ; List < File > actual Cp = get List Of Files ( GWT Compile Runner . compute Classpath ( java Project A ) ) ; assert Equals ( NUM , actual Cp . size ( ) ) ; }
static boolean copy To ( Byte Buffer in Buffer , Char Buffer out Buffer , Charset Decoder decoder ) { final Coder Result result = decoder . decode ( in Buffer , out Buffer , BOOL ) ; decoder . flush ( out Buffer ) ; return ! result . is Error ( ) && ! result . is Overflow ( ) ; }
private void visit From Cached ( Document document , Stored Field Visitor visitor ) throws IO Exception { for ( Indexable Field f : document ) { Field Info info = field Infos . field Info ( f . name ( ) ) ; switch ( visitor . needs Field ( info ) ) { case YES : if ( f . binary Value ( ) != null ) { Bytes Ref binary Value = f . binary Value ( ) ; byte copy [ ] = new byte [ binary Value . length ] ; System . arraycopy ( binary Value . bytes , binary Value . offset , copy , NUM , copy . length ) ; visitor . binary Field ( info , copy ) ; } else if ( f . numeric Value ( ) != null ) { Number numeric Value = f . numeric Value ( ) ; if ( numeric Value instanceof Double ) { visitor . double Field ( info , numeric Value . double Value ( ) ) ; } else if ( numeric Value instanceof Integer ) { visitor . int Field ( info , numeric Value . int Value ( ) ) ; } else if ( numeric Value instanceof Float ) { visitor . float Field ( info , numeric Value . float Value ( ) ) ; } else if ( numeric Value instanceof Long ) { visitor . long Field ( info , numeric Value . long Value ( ) ) ; } else { throw new Assertion Error ( ) ; } } else { visitor . string Field ( info , f . string Value ( ) ) ; } break ; case NO : break ; case STOP : return ; } } }
private void visit From Cached ( Document document , Stored Field Visitor visitor ) throws IO Exception { for ( Indexable Field f : document ) { Field Info info = field Infos . field Info ( f . name ( ) ) ; switch ( visitor . needs Field ( info ) ) { case YES : if ( f . binary Value ( ) != null ) { Bytes Ref binary Value = f . binary Value ( ) ; byte copy [ ] = new byte [ binary Value . length ] ; System . arraycopy ( binary Value . bytes , binary Value . offset , copy , NUM , copy . length ) ; visitor . binary Field ( info , copy ) ; } else if ( f . numeric Value ( ) != null ) { Number numeric Value = f . numeric Value ( ) ; if ( numeric Value instanceof Double ) { visitor . double Field ( info , numeric Value . double Value ( ) ) ; } else if ( numeric Value instanceof Integer ) { visitor . int Field ( info , numeric Value . int Value ( ) ) ; } else if ( numeric Value instanceof Float ) { visitor . float Field ( info , numeric Value . float Value ( ) ) ; } else if ( numeric Value instanceof Long ) { visitor . long Field ( info , numeric Value . long Value ( ) ) ; } else { throw new Assertion Error ( ) ; } } else { visitor . string Field ( info , f . string Value ( ) ) ; } break ; case NO : break ; case STOP : return ; } } }
protected void move Randomly ( OM Point point , double factor , Projection proj ) { double hor = Math . random ( ) - NUM ; double vert = Math . random ( ) - NUM ; Point 2 D map Point = proj . forward ( point . get Lat ( ) , point . get Lon ( ) ) ; map Point . set Location ( map Point . get X ( ) + ( hor * factor ) , map Point . get Y ( ) + ( vert * factor ) ) ; Point 2 D llp = proj . inverse ( map Point ) ; point . set Lat ( llp . get Y ( ) ) ; point . set Lon ( llp . get X ( ) ) ; }
private void create Partition Region ( List vm List , int start Index For Region , int end Index For Region , int local Max Memory , int redundancy , boolean first Creation Flag , boolean multiple VM Flag ) { Iterator node Iterator = vm List . iterator ( ) ; while ( node Iterator . has Next ( ) ) { VM vm = ( VM ) node Iterator . next ( ) ; vm . invoke ( create Multiple Partition Region ( pr Prefix , start Index For Region , end Index For Region , redundancy , local Max Memory , first Creation Flag , multiple VM Flag ) ) ; } }
private void create Partition Region ( List vm List , int start Index For Region , int end Index For Region , int local Max Memory , int redundancy , boolean first Creation Flag , boolean multiple VM Flag ) { Iterator node Iterator = vm List . iterator ( ) ; while ( node Iterator . has Next ( ) ) { VM vm = ( VM ) node Iterator . next ( ) ; vm . invoke ( create Multiple Partition Region ( pr Prefix , start Index For Region , end Index For Region , redundancy , local Max Memory , first Creation Flag , multiple VM Flag ) ) ; } }
private void create Partition Region ( List vm List , int start Index For Region , int end Index For Region , int local Max Memory , int redundancy , boolean first Creation Flag , boolean multiple VM Flag ) { Iterator node Iterator = vm List . iterator ( ) ; while ( node Iterator . has Next ( ) ) { VM vm = ( VM ) node Iterator . next ( ) ; vm . invoke ( create Multiple Partition Region ( pr Prefix , start Index For Region , end Index For Region , redundancy , local Max Memory , first Creation Flag , multiple VM Flag ) ) ; } }
private void create Partition Region ( List vm List , int start Index For Region , int end Index For Region , int local Max Memory , int redundancy , boolean first Creation Flag , boolean multiple VM Flag ) { Iterator node Iterator = vm List . iterator ( ) ; while ( node Iterator . has Next ( ) ) { VM vm = ( VM ) node Iterator . next ( ) ; vm . invoke ( create Multiple Partition Region ( pr Prefix , start Index For Region , end Index For Region , redundancy , local Max Memory , first Creation Flag , multiple VM Flag ) ) ; } }
private boolean validate New Password ( Request And Response request And Response , final User edited User , final boolean current Is Edited User , final String new Password , final String new Password 2 ) throws IO Exception { boolean has Errors = BOOL ; if ( new Password == null || new Password . is Empty ( ) ) { add Error Message ( request And Response , servlet Text . error First Password Must Be Set ( current Is Edited User , edited User . get User Name ( ) ) ) ; has Errors = BOOL ; } if ( new Password 2 == null || new Password 2 . is Empty ( ) ) { add Error Message ( request And Response , servlet Text . error Second Password Must Be Set ( current Is Edited User , edited User . get User Name ( ) ) ) ; has Errors = BOOL ; } if ( ! has Errors && new Password != null && new Password 2 != null && ! new Password 2 . equals ( new Password ) ) { add Error Message ( request And Response , servlet Text . error Passwords Must Match ( ) ) ; has Errors = BOOL ; } if ( ! has Errors && ! Account Attribute Validator . is Password Valid ( new Password ) ) { add Error Message ( request And Response , servlet Text . error Password Is Not Valid ( ) ) ; has Errors = BOOL ; } return has Errors ; }
private void add Match ( String n ) { if ( names == null ) names = new Array List < > ( ) ; if ( ! names . contains ( n ) ) { names . add ( n ) ; } }
public int last Index Of ( String sub String , int start ) { int sub Count = sub String . length ( ) ; if ( sub Count <= count && start >= NUM ) { if ( sub Count > NUM ) { if ( start > count - sub Count ) { start = count - sub Count ; } char first Char = sub String . char At ( NUM ) ; while ( BOOL ) { int i = start ; boolean found = BOOL ; for ( ; i >= NUM ; -- i ) { if ( value [ i ] == first Char ) { found = BOOL ; break ; } } if ( ! found ) { return - NUM ; } int o1 = i , o2 = NUM ; while ( ++ o2 < sub Count && value [ ++ o1 ] == sub String . char At ( o2 ) ) { } if ( o2 == sub Count ) { return i ; } start = i - NUM ; } } return start < count ? start : count ; } return - NUM ; }
public int last Index Of ( String sub String , int start ) { int sub Count = sub String . length ( ) ; if ( sub Count <= count && start >= NUM ) { if ( sub Count > NUM ) { if ( start > count - sub Count ) { start = count - sub Count ; } char first Char = sub String . char At ( NUM ) ; while ( BOOL ) { int i = start ; boolean found = BOOL ; for ( ; i >= NUM ; -- i ) { if ( value [ i ] == first Char ) { found = BOOL ; break ; } } if ( ! found ) { return - NUM ; } int o1 = i , o2 = NUM ; while ( ++ o2 < sub Count && value [ ++ o1 ] == sub String . char At ( o2 ) ) { } if ( o2 == sub Count ) { return i ; } start = i - NUM ; } } return start < count ? start : count ; } return - NUM ; }
public Key Value Table View ( List < Pair < K , V > > items , List < K > skip Keys ) { this ( FX Collections . observable Array List ( items ) , FX Collections . observable Array List ( skip Keys ) , null , null ) ; }
public Object put ( Object key , Object value ) { Object old Value = null ; synchronized ( map ) { old Value = map . put ( key , value ) ; if ( old Value != null ) { remove Element ( key ) ; } add Element ( key ) ; } return old Value ; }
@ Override public Long call ( ) throws Exception { final boolean TRACE = log . is Trace Enabled ( ) ; if ( push Down Apply ( ) ) { program . apply ( gas State , u , null ) ; } if ( ! program . is Changed ( gas State , u ) ) { return NUM ; } long nedges = NUM ; final IGAS Scheduler sch = scheduler ( ) ; final Iterator < Statement > eitr = graph Accessor . get Edges ( GAS Context . this , u , get Edges Enum ( ) ) ; try { while ( eitr . has Next ( ) ) { final Statement e = eitr . next ( ) ; nedges ++ ; if ( TRACE ) log . trace ( STRING + gas State . to String ( e ) ) ; program . scatter ( gas State , sch , u , e ) ; } } finally { } return nedges ; }
void collect Unresponsive Members ( Set s ) { if ( still Waiting ( ) ) { Internal Distributed Member [ ] member List = get Members ( ) ; synchronized ( member List ) { for ( int i = NUM ; i < member List . length ; i ++ ) { Internal Distributed Member m = member List [ i ] ; if ( m != null ) { s . add ( m ) ; } } } } }
private void update Stats ( ) { if ( last Valid Info != null ) { stats . set Text ( STRING + Stats . make Full Stats ( last Valid Info ) ) ; } else { stats . set Text ( STRING ) ; } }
protected I Object Info < T > store impl ( Segment < T > segment , Object Info < T > oi ) { if ( invalid ) return null ; size . increment And Get ( ) ; segment . increment Size ( ) ; Object Info < T > tail = segment . get Tail ( ) ; tail . set Forward Ref ( oi ) ; oi . set Backward Ref ( tail ) ; segment . set Tail ( oi ) ; return oi ; }
public Qo S Handler ( final Vertx vertx , final Resource Storage storage , final String qos Settings Path , final Map < String , Object > properties , String prefix ) { this . vertx = vertx ; this . storage = storage ; this . qos Settings Uri = qos Settings Path ; this . properties = properties ; this . prefix = prefix ; qos Rules = new Array List < > ( ) ; set M Bean Server ( Management Factory . get Platform M Bean Server ( ) ) ; load Qo S Settings ( ) ; register Update Handler ( ) ; }
public Position create Position ( int offset ) throws Bad Location Exception { while ( queue . poll ( ) != null ) { unused Marks ++ ; } if ( unused Marks > Math . max ( NUM , ( marks . size ( ) / NUM ) ) ) { remove Unused Marks ( ) ; } int g0 = get Gap Start ( ) ; int g1 = get Gap End ( ) ; int index = ( offset < g0 ) ? offset : offset + ( g1 - g0 ) ; search . index = index ; int sort Index = find Sort Index ( search ) ; Mark Data m ; Sticky Position position ; if ( sort Index < marks . size ( ) && ( m = marks . element At ( sort Index ) ) . index == index && ( position = m . get Position ( ) ) != null ) { } else { position = new Sticky Position ( ) ; m = new Mark Data ( index , position , queue ) ; position . set Mark ( m ) ; marks . insert Element At ( m , sort Index ) ; } return position ; }
public Position create Position ( int offset ) throws Bad Location Exception { while ( queue . poll ( ) != null ) { unused Marks ++ ; } if ( unused Marks > Math . max ( NUM , ( marks . size ( ) / NUM ) ) ) { remove Unused Marks ( ) ; } int g0 = get Gap Start ( ) ; int g1 = get Gap End ( ) ; int index = ( offset < g0 ) ? offset : offset + ( g1 - g0 ) ; search . index = index ; int sort Index = find Sort Index ( search ) ; Mark Data m ; Sticky Position position ; if ( sort Index < marks . size ( ) && ( m = marks . element At ( sort Index ) ) . index == index && ( position = m . get Position ( ) ) != null ) { } else { position = new Sticky Position ( ) ; m = new Mark Data ( index , position , queue ) ; position . set Mark ( m ) ; marks . insert Element At ( m , sort Index ) ; } return position ; }
public Position create Position ( int offset ) throws Bad Location Exception { while ( queue . poll ( ) != null ) { unused Marks ++ ; } if ( unused Marks > Math . max ( NUM , ( marks . size ( ) / NUM ) ) ) { remove Unused Marks ( ) ; } int g0 = get Gap Start ( ) ; int g1 = get Gap End ( ) ; int index = ( offset < g0 ) ? offset : offset + ( g1 - g0 ) ; search . index = index ; int sort Index = find Sort Index ( search ) ; Mark Data m ; Sticky Position position ; if ( sort Index < marks . size ( ) && ( m = marks . element At ( sort Index ) ) . index == index && ( position = m . get Position ( ) ) != null ) { } else { position = new Sticky Position ( ) ; m = new Mark Data ( index , position , queue ) ; position . set Mark ( m ) ; marks . insert Element At ( m , sort Index ) ; } return position ; }
public Position create Position ( int offset ) throws Bad Location Exception { while ( queue . poll ( ) != null ) { unused Marks ++ ; } if ( unused Marks > Math . max ( NUM , ( marks . size ( ) / NUM ) ) ) { remove Unused Marks ( ) ; } int g0 = get Gap Start ( ) ; int g1 = get Gap End ( ) ; int index = ( offset < g0 ) ? offset : offset + ( g1 - g0 ) ; search . index = index ; int sort Index = find Sort Index ( search ) ; Mark Data m ; Sticky Position position ; if ( sort Index < marks . size ( ) && ( m = marks . element At ( sort Index ) ) . index == index && ( position = m . get Position ( ) ) != null ) { } else { position = new Sticky Position ( ) ; m = new Mark Data ( index , position , queue ) ; position . set Mark ( m ) ; marks . insert Element At ( m , sort Index ) ; } return position ; }
public void test To String ( ) { Linked Blocking Deque q = populated Deque ( SIZE ) ; String s = q . to String ( ) ; for ( int i = NUM ; i < SIZE ; ++ i ) { assert True ( s . index Of ( String . value Of ( i ) ) >= NUM ) ; } }
public void test To String ( ) { Linked Blocking Deque q = populated Deque ( SIZE ) ; String s = q . to String ( ) ; for ( int i = NUM ; i < SIZE ; ++ i ) { assert True ( s . index Of ( String . value Of ( i ) ) >= NUM ) ; } }
private final void draw Isometric Sprites ( Graphics g , Collection < Isometric Sprite > sprite Array List ) { Rectangle view = g . get Clip Bounds ( ) ; for ( Isometric Sprite sprite : sprite Array List ) { Rectangle sprite Bounds = sprite . get Bounds ( ) ; if ( view . intersects ( sprite Bounds ) && ! sprite . is Hidden ( ) ) { if ( ! sprite . is Ready ( ) ) { sprite . prepare ( ) ; } sprite . draw Onto ( g , sprite Bounds . x , sprite Bounds . y , this , BOOL ) ; } } }
private final void draw Isometric Sprites ( Graphics g , Collection < Isometric Sprite > sprite Array List ) { Rectangle view = g . get Clip Bounds ( ) ; for ( Isometric Sprite sprite : sprite Array List ) { Rectangle sprite Bounds = sprite . get Bounds ( ) ; if ( view . intersects ( sprite Bounds ) && ! sprite . is Hidden ( ) ) { if ( ! sprite . is Ready ( ) ) { sprite . prepare ( ) ; } sprite . draw Onto ( g , sprite Bounds . x , sprite Bounds . y , this , BOOL ) ; } } }
private final void draw Isometric Sprites ( Graphics g , Collection < Isometric Sprite > sprite Array List ) { Rectangle view = g . get Clip Bounds ( ) ; for ( Isometric Sprite sprite : sprite Array List ) { Rectangle sprite Bounds = sprite . get Bounds ( ) ; if ( view . intersects ( sprite Bounds ) && ! sprite . is Hidden ( ) ) { if ( ! sprite . is Ready ( ) ) { sprite . prepare ( ) ; } sprite . draw Onto ( g , sprite Bounds . x , sprite Bounds . y , this , BOOL ) ; } } }
private final void draw Isometric Sprites ( Graphics g , Collection < Isometric Sprite > sprite Array List ) { Rectangle view = g . get Clip Bounds ( ) ; for ( Isometric Sprite sprite : sprite Array List ) { Rectangle sprite Bounds = sprite . get Bounds ( ) ; if ( view . intersects ( sprite Bounds ) && ! sprite . is Hidden ( ) ) { if ( ! sprite . is Ready ( ) ) { sprite . prepare ( ) ; } sprite . draw Onto ( g , sprite Bounds . x , sprite Bounds . y , this , BOOL ) ; } } }
private final void draw Isometric Sprites ( Graphics g , Collection < Isometric Sprite > sprite Array List ) { Rectangle view = g . get Clip Bounds ( ) ; for ( Isometric Sprite sprite : sprite Array List ) { Rectangle sprite Bounds = sprite . get Bounds ( ) ; if ( view . intersects ( sprite Bounds ) && ! sprite . is Hidden ( ) ) { if ( ! sprite . is Ready ( ) ) { sprite . prepare ( ) ; } sprite . draw Onto ( g , sprite Bounds . x , sprite Bounds . y , this , BOOL ) ; } } }
private final void draw Isometric Sprites ( Graphics g , Collection < Isometric Sprite > sprite Array List ) { Rectangle view = g . get Clip Bounds ( ) ; for ( Isometric Sprite sprite : sprite Array List ) { Rectangle sprite Bounds = sprite . get Bounds ( ) ; if ( view . intersects ( sprite Bounds ) && ! sprite . is Hidden ( ) ) { if ( ! sprite . is Ready ( ) ) { sprite . prepare ( ) ; } sprite . draw Onto ( g , sprite Bounds . x , sprite Bounds . y , this , BOOL ) ; } } }
private final void draw Isometric Sprites ( Graphics g , Collection < Isometric Sprite > sprite Array List ) { Rectangle view = g . get Clip Bounds ( ) ; for ( Isometric Sprite sprite : sprite Array List ) { Rectangle sprite Bounds = sprite . get Bounds ( ) ; if ( view . intersects ( sprite Bounds ) && ! sprite . is Hidden ( ) ) { if ( ! sprite . is Ready ( ) ) { sprite . prepare ( ) ; } sprite . draw Onto ( g , sprite Bounds . x , sprite Bounds . y , this , BOOL ) ; } } }
private final void draw Isometric Sprites ( Graphics g , Collection < Isometric Sprite > sprite Array List ) { Rectangle view = g . get Clip Bounds ( ) ; for ( Isometric Sprite sprite : sprite Array List ) { Rectangle sprite Bounds = sprite . get Bounds ( ) ; if ( view . intersects ( sprite Bounds ) && ! sprite . is Hidden ( ) ) { if ( ! sprite . is Ready ( ) ) { sprite . prepare ( ) ; } sprite . draw Onto ( g , sprite Bounds . x , sprite Bounds . y , this , BOOL ) ; } } }
private final void draw Isometric Sprites ( Graphics g , Collection < Isometric Sprite > sprite Array List ) { Rectangle view = g . get Clip Bounds ( ) ; for ( Isometric Sprite sprite : sprite Array List ) { Rectangle sprite Bounds = sprite . get Bounds ( ) ; if ( view . intersects ( sprite Bounds ) && ! sprite . is Hidden ( ) ) { if ( ! sprite . is Ready ( ) ) { sprite . prepare ( ) ; } sprite . draw Onto ( g , sprite Bounds . x , sprite Bounds . y , this , BOOL ) ; } } }
static String cleanup ( String s ) { for ( ; ; ) { s = s . trim ( ) ; if ( s . starts With ( STRING ) || s . starts With ( STRING ) || s . starts With ( STRING ) || s . starts With ( STRING ) ) { s = s . substring ( NUM ) ; } else { return s ; } } }
static String cleanup ( String s ) { for ( ; ; ) { s = s . trim ( ) ; if ( s . starts With ( STRING ) || s . starts With ( STRING ) || s . starts With ( STRING ) || s . starts With ( STRING ) ) { s = s . substring ( NUM ) ; } else { return s ; } } }
public static void append Path ( String Buffer sb , Resource path ) { if ( path . is URI Resource ( ) ) { sb . append ( Fmt Utils . string For Node ( path . as Node ( ) , path . get Model ( ) ) ) ; } else { append Path Blank Node ( sb , path , SEQUENCE PATH SEPARATOR ) ; } }
public static Text value Of ( char [ ] chars , int offset , int length ) { if ( ( offset < NUM ) || ( length < NUM ) || ( ( offset + length ) > chars . length ) ) throw new Index Out Of Bounds Exception ( ) ; if ( length <= BLOCK SIZE ) { Text text = Text . new Primitive ( length ) ; System . arraycopy ( chars , offset , text . data , NUM , length ) ; return text ; } else { int half = ( ( length + BLOCK SIZE ) > > NUM ) & BLOCK MASK ; return Text . new Composite ( Text . value Of ( chars , offset , half ) , Text . value Of ( chars , offset + half , length - half ) ) ; } }
public static Text value Of ( char [ ] chars , int offset , int length ) { if ( ( offset < NUM ) || ( length < NUM ) || ( ( offset + length ) > chars . length ) ) throw new Index Out Of Bounds Exception ( ) ; if ( length <= BLOCK SIZE ) { Text text = Text . new Primitive ( length ) ; System . arraycopy ( chars , offset , text . data , NUM , length ) ; return text ; } else { int half = ( ( length + BLOCK SIZE ) > > NUM ) & BLOCK MASK ; return Text . new Composite ( Text . value Of ( chars , offset , half ) , Text . value Of ( chars , offset + half , length - half ) ) ; } }
public void test Constructor Bytes Positive ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , - NUM } ; byte r Bytes [ ] = { NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
public Mim Search Editor ( Mim Build Runner runner ) { this ( runner , STRING ) ; }
public Mim Search Editor ( Mim Build Runner runner ) { this ( runner , STRING ) ; }
public Mim Search Editor ( Mim Build Runner runner ) { this ( runner , STRING ) ; }
public void add Child Frame ( Container c ) { m Child Frames . add ( c ) ; window List Changed ( ) ; }
public static int find Index Of ( String str , char search ) { return find Index Of ( str , search , search ) ; }
public static int find Index Of ( String str , char search ) { return find Index Of ( str , search , search ) ; }
public static int find Index Of ( String str , char search ) { return find Index Of ( str , search , search ) ; }
public static int find Index Of ( String str , char search ) { return find Index Of ( str , search , search ) ; }
public Jdbc Connection execute ( Operations operations ) throws SQL Exception { Connection conn = connection ( ) ; try ( Statement statement = conn . create Statement ( ) ) { operations . apply ( statement ) ; if ( ! conn . get Auto Commit ( ) ) conn . commit ( ) ; } return this ; }
@ Override public Alarm Event evaluate ( Alarm Point alarm , String trigger ) { if ( trigger . equals ( Alarm Point . TRIGGER ACTIVATE ) ) { return activation ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER DEACTIVATE ) ) { return deactivation ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER ACKNOWLEDGE ) ) { return acknowledge ( alarm ) ; } else { throw new Illegal Argument Exception ( STRING + trigger + STRING ) ; } }
@ Override public Alarm Event evaluate ( Alarm Point alarm , String trigger ) { if ( trigger . equals ( Alarm Point . TRIGGER ACTIVATE ) ) { return activation ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER DEACTIVATE ) ) { return deactivation ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER ACKNOWLEDGE ) ) { return acknowledge ( alarm ) ; } else { throw new Illegal Argument Exception ( STRING + trigger + STRING ) ; } }
private static long Call Long Method V ( JNI Environment env , int obj JREF , int method ID , Address arg Address ) throws Exception { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { Object obj = env . get JNI Ref ( obj JREF ) ; Object return Obj = JNI Helpers . invoke With Var Arg ( obj , method ID , arg Address , Type Reference . Long , BOOL ) ; return Reflection . unwrap Long ( return Obj ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
private static long Call Long Method V ( JNI Environment env , int obj JREF , int method ID , Address arg Address ) throws Exception { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { Object obj = env . get JNI Ref ( obj JREF ) ; Object return Obj = JNI Helpers . invoke With Var Arg ( obj , method ID , arg Address , Type Reference . Long , BOOL ) ; return Reflection . unwrap Long ( return Obj ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
public static List < Apn > query ( Context context ) { String [ ] sim Codes = get Sim Operator Codes ( context ) ; String [ ] network Codes = get Network Operator Codes ( context ) ; Set < Apn > result Set = new Hash Set < > ( ) ; result Set . add All ( query ( context , sim Codes [ NUM ] , sim Codes [ NUM ] ) ) ; result Set . add All ( query ( context , network Codes [ NUM ] , network Codes [ NUM ] ) ) ; List < Apn > result = new Array List < > ( result Set . size ( ) ) ; result . add All ( result Set ) ; return result ; }
public static List < Apn > query ( Context context ) { String [ ] sim Codes = get Sim Operator Codes ( context ) ; String [ ] network Codes = get Network Operator Codes ( context ) ; Set < Apn > result Set = new Hash Set < > ( ) ; result Set . add All ( query ( context , sim Codes [ NUM ] , sim Codes [ NUM ] ) ) ; result Set . add All ( query ( context , network Codes [ NUM ] , network Codes [ NUM ] ) ) ; List < Apn > result = new Array List < > ( result Set . size ( ) ) ; result . add All ( result Set ) ; return result ; }
public Subject Alternative Name Extension ( Boolean critical , Object value ) throws IO Exception { this . extension Id = PKIX Extensions . Subject Alternative Name Id ; this . critical = critical . boolean Value ( ) ; this . extension Value = ( byte [ ] ) value ; Der Value val = new Der Value ( this . extension Value ) ; if ( val . data == null ) { names = new General Names ( ) ; return ; } names = new General Names ( val ) ; }
private static void adjust Pool Size ( int players ) { pool . set Core Pool Size ( Math . max ( BASE THREADS , players / PLAYERS PER THREAD ) ) ; }
private static void adjust Pool Size ( int players ) { pool . set Core Pool Size ( Math . max ( BASE THREADS , players / PLAYERS PER THREAD ) ) ; }
@ Override public synchronized void put ( String key , Entry entry ) { prune If Needed ( entry . data . length ) ; File file = get File For Key ( key ) ; try { Buffered Output Stream fos = new Buffered Output Stream ( new File Output Stream ( file ) ) ; Cache Header e = new Cache Header ( key , entry ) ; boolean success = e . write Header ( fos ) ; if ( ! success ) { fos . close ( ) ; Volley Log . d ( STRING , file . get Absolute Path ( ) ) ; throw new IO Exception ( ) ; } fos . write ( entry . data ) ; fos . close ( ) ; put Entry ( key , e ) ; return ; } catch ( IO Exception e ) { } boolean deleted = file . delete ( ) ; if ( ! deleted ) { Volley Log . d ( STRING , file . get Absolute Path ( ) ) ; } }
public void write Population And Attributes ( String input Folder , String province Name ) throws IO Exception { String path = input Folder . ends With ( STRING ) ? STRING : STRING ; File output Folder = new File ( input Folder + path + province Name + path ) ; if ( output Folder . exists ( ) ) { throw new IO Exception ( STRING + output Folder . get Absolute Path ( ) ) ; } else { output Folder . mkdirs ( ) ; } write Households ( output Folder . get Absolute Path ( ) ) ; write Population ( output Folder . get Absolute Path ( ) ) ; }
public void write Population And Attributes ( String input Folder , String province Name ) throws IO Exception { String path = input Folder . ends With ( STRING ) ? STRING : STRING ; File output Folder = new File ( input Folder + path + province Name + path ) ; if ( output Folder . exists ( ) ) { throw new IO Exception ( STRING + output Folder . get Absolute Path ( ) ) ; } else { output Folder . mkdirs ( ) ; } write Households ( output Folder . get Absolute Path ( ) ) ; write Population ( output Folder . get Absolute Path ( ) ) ; }
public void write Population And Attributes ( String input Folder , String province Name ) throws IO Exception { String path = input Folder . ends With ( STRING ) ? STRING : STRING ; File output Folder = new File ( input Folder + path + province Name + path ) ; if ( output Folder . exists ( ) ) { throw new IO Exception ( STRING + output Folder . get Absolute Path ( ) ) ; } else { output Folder . mkdirs ( ) ; } write Households ( output Folder . get Absolute Path ( ) ) ; write Population ( output Folder . get Absolute Path ( ) ) ; }
public void write Population And Attributes ( String input Folder , String province Name ) throws IO Exception { String path = input Folder . ends With ( STRING ) ? STRING : STRING ; File output Folder = new File ( input Folder + path + province Name + path ) ; if ( output Folder . exists ( ) ) { throw new IO Exception ( STRING + output Folder . get Absolute Path ( ) ) ; } else { output Folder . mkdirs ( ) ; } write Households ( output Folder . get Absolute Path ( ) ) ; write Population ( output Folder . get Absolute Path ( ) ) ; }
public void write Population And Attributes ( String input Folder , String province Name ) throws IO Exception { String path = input Folder . ends With ( STRING ) ? STRING : STRING ; File output Folder = new File ( input Folder + path + province Name + path ) ; if ( output Folder . exists ( ) ) { throw new IO Exception ( STRING + output Folder . get Absolute Path ( ) ) ; } else { output Folder . mkdirs ( ) ; } write Households ( output Folder . get Absolute Path ( ) ) ; write Population ( output Folder . get Absolute Path ( ) ) ; }
public void add Tag ( final String key , final Preset Key Type type , String value , String text ) { if ( key == null ) throw new Null Pointer Exception ( STRING ) ; if ( value == null ) value = STRING ; if ( text != null && po != null ) { text = po . t ( text ) ; } fixed Tags . put ( key , new String With Description ( value , text ) ) ; if ( ! chunk ) { tag Items . add ( key + STRING + value , this ) ; } key Type . put ( key , type ) ; if ( applies To ( Element Type . NODE ) ) autosuggest Nodes . add ( key , value . length ( ) > NUM ? new String With Description ( value , text ) : null ) ; if ( applies To ( Element Type . WAY ) ) autosuggest Ways . add ( key , value . length ( ) > NUM ? new String With Description ( value , text ) : null ) ; if ( applies To ( Element Type . CLOSEDWAY ) ) autosuggest Closedways . add ( key , value . length ( ) > NUM ? new String With Description ( value , text ) : null ) ; if ( applies To ( Element Type . RELATION ) ) autosuggest Relations . add ( key , value . length ( ) > NUM ? new String With Description ( value , text ) : null ) ; if ( applies To ( Element Type . AREA ) ) autosuggest Areas . add ( key , value . length ( ) > NUM ? new String With Description ( value , text ) : null ) ; }
public void add Tag ( final String key , final Preset Key Type type , String value , String text ) { if ( key == null ) throw new Null Pointer Exception ( STRING ) ; if ( value == null ) value = STRING ; if ( text != null && po != null ) { text = po . t ( text ) ; } fixed Tags . put ( key , new String With Description ( value , text ) ) ; if ( ! chunk ) { tag Items . add ( key + STRING + value , this ) ; } key Type . put ( key , type ) ; if ( applies To ( Element Type . NODE ) ) autosuggest Nodes . add ( key , value . length ( ) > NUM ? new String With Description ( value , text ) : null ) ; if ( applies To ( Element Type . WAY ) ) autosuggest Ways . add ( key , value . length ( ) > NUM ? new String With Description ( value , text ) : null ) ; if ( applies To ( Element Type . CLOSEDWAY ) ) autosuggest Closedways . add ( key , value . length ( ) > NUM ? new String With Description ( value , text ) : null ) ; if ( applies To ( Element Type . RELATION ) ) autosuggest Relations . add ( key , value . length ( ) > NUM ? new String With Description ( value , text ) : null ) ; if ( applies To ( Element Type . AREA ) ) autosuggest Areas . add ( key , value . length ( ) > NUM ? new String With Description ( value , text ) : null ) ; }
public void add Method ( Soot Method m ) { check Level ( SIGNATURES ) ; if ( m . is Declared ( ) ) throw new Runtime Exception ( STRING + m . get Name ( ) ) ; if ( sub Sig To Methods . get ( m . get Numbered Sub Signature ( ) ) != null ) { throw new Runtime Exception ( STRING + m . get Sub Signature ( ) + STRING + this + STRING ) ; } sub Sig To Methods . put ( m . get Numbered Sub Signature ( ) , m ) ; method List . add ( m ) ; m . set Declared ( BOOL ) ; m . set Declaring Class ( this ) ; }
public Concurrent Skip List Map ( Sorted Map < K , ? extends V > m ) { this . comparator = m . comparator ( ) ; initialize ( ) ; build From Sorted ( m ) ; }
public Concurrent Skip List Map ( Sorted Map < K , ? extends V > m ) { this . comparator = m . comparator ( ) ; initialize ( ) ; build From Sorted ( m ) ; }
public void remove Event Listener ( SIP Transaction Event Listener old Listener ) { event Listeners . remove ( old Listener ) ; }
public static int [ ] sub Array ( final int [ ] input , final int start , final int end ) { int [ ] result = new int [ end - start ] ; System . arraycopy ( input , start , result , NUM , end - start ) ; return result ; }
public void add URL ( String url ) { Action Union ret = new Action Union ( ) ; ret . url ( url ) ; current Gesture Action List . add Element ( ret ) ; }
public void add URL ( String url ) { Action Union ret = new Action Union ( ) ; ret . url ( url ) ; current Gesture Action List . add Element ( ret ) ; }
protected void next Table ( ) throws Replicator Exception , SQL Exception { while ( import Tables . next ( ) ) { if ( include Import Table ( ) == BOOL ) { current Table Position = NUM ; extract Create Table Statement = this . include Structure ; prepare Import Table ( ) ; break ; } } }
protected void next Table ( ) throws Replicator Exception , SQL Exception { while ( import Tables . next ( ) ) { if ( include Import Table ( ) == BOOL ) { current Table Position = NUM ; extract Create Table Statement = this . include Structure ; prepare Import Table ( ) ; break ; } } }
private static int apply Precision ( int dec Exp , char [ ] digits , int n Digits , int prec ) { if ( prec >= n Digits || prec < NUM ) { return dec Exp ; } if ( prec == NUM ) { if ( digits [ NUM ] >= STRING ) { digits [ NUM ] = STRING ; Arrays . fill ( digits , NUM , n Digits , STRING ) ; return dec Exp + NUM ; } else { Arrays . fill ( digits , NUM , n Digits , STRING ) ; return dec Exp ; } } int q = digits [ prec ] ; if ( q >= STRING ) { int i = prec ; q = digits [ -- i ] ; if ( q == STRING ) { while ( q == STRING && i > NUM ) { q = digits [ -- i ] ; } if ( q == STRING ) { digits [ NUM ] = STRING ; Arrays . fill ( digits , NUM , n Digits , STRING ) ; return dec Exp + NUM ; } } digits [ i ] = ( char ) ( q + NUM ) ; Arrays . fill ( digits , i + NUM , n Digits , STRING ) ; } else { Arrays . fill ( digits , prec , n Digits , STRING ) ; } return dec Exp ; }
@ Nullable public File resolve Parent Directory ( @ Nullable Label label ) { return label != null ? resolve Parent Directory ( label . blaze Package ( ) , label . rule Name ( ) ) : null ; }
public void add Notify Task ( Runnable run ) { if ( run != null ) { tasks . add ( run ) ; } }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . next Double ( ) <= insert Rate ) { for ( int i = NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; vals [ i ] = new byte [ NUM ] ; r . next Bytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( NUM , nops , keys , vals , Batch Insert Constructor . RETURN NO VALUES , null ) ; if ( ground Truth != null ) { ground Truth . submit ( NUM , nops , keys , vals , Batch Insert Constructor . RETURN NO VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; } lock . lock ( ) ; try { ndx . submit ( NUM , nops , keys , null , Batch Remove Constructor . RETURN MUTATION COUNT , null ) ; if ( ground Truth != null ) { ground Truth . submit ( NUM , nops , keys , null , Batch Remove Constructor . RETURN MUTATION COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . next Double ( ) <= insert Rate ) { for ( int i = NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; vals [ i ] = new byte [ NUM ] ; r . next Bytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( NUM , nops , keys , vals , Batch Insert Constructor . RETURN NO VALUES , null ) ; if ( ground Truth != null ) { ground Truth . submit ( NUM , nops , keys , vals , Batch Insert Constructor . RETURN NO VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; } lock . lock ( ) ; try { ndx . submit ( NUM , nops , keys , null , Batch Remove Constructor . RETURN MUTATION COUNT , null ) ; if ( ground Truth != null ) { ground Truth . submit ( NUM , nops , keys , null , Batch Remove Constructor . RETURN MUTATION COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . next Double ( ) <= insert Rate ) { for ( int i = NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; vals [ i ] = new byte [ NUM ] ; r . next Bytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( NUM , nops , keys , vals , Batch Insert Constructor . RETURN NO VALUES , null ) ; if ( ground Truth != null ) { ground Truth . submit ( NUM , nops , keys , vals , Batch Insert Constructor . RETURN NO VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; } lock . lock ( ) ; try { ndx . submit ( NUM , nops , keys , null , Batch Remove Constructor . RETURN MUTATION COUNT , null ) ; if ( ground Truth != null ) { ground Truth . submit ( NUM , nops , keys , null , Batch Remove Constructor . RETURN MUTATION COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . next Double ( ) <= insert Rate ) { for ( int i = NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; vals [ i ] = new byte [ NUM ] ; r . next Bytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( NUM , nops , keys , vals , Batch Insert Constructor . RETURN NO VALUES , null ) ; if ( ground Truth != null ) { ground Truth . submit ( NUM , nops , keys , vals , Batch Insert Constructor . RETURN NO VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; } lock . lock ( ) ; try { ndx . submit ( NUM , nops , keys , null , Batch Remove Constructor . RETURN MUTATION COUNT , null ) ; if ( ground Truth != null ) { ground Truth . submit ( NUM , nops , keys , null , Batch Remove Constructor . RETURN MUTATION COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . next Double ( ) <= insert Rate ) { for ( int i = NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; vals [ i ] = new byte [ NUM ] ; r . next Bytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( NUM , nops , keys , vals , Batch Insert Constructor . RETURN NO VALUES , null ) ; if ( ground Truth != null ) { ground Truth . submit ( NUM , nops , keys , vals , Batch Insert Constructor . RETURN NO VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; } lock . lock ( ) ; try { ndx . submit ( NUM , nops , keys , null , Batch Remove Constructor . RETURN MUTATION COUNT , null ) ; if ( ground Truth != null ) { ground Truth . submit ( NUM , nops , keys , null , Batch Remove Constructor . RETURN MUTATION COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . next Double ( ) <= insert Rate ) { for ( int i = NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; vals [ i ] = new byte [ NUM ] ; r . next Bytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( NUM , nops , keys , vals , Batch Insert Constructor . RETURN NO VALUES , null ) ; if ( ground Truth != null ) { ground Truth . submit ( NUM , nops , keys , vals , Batch Insert Constructor . RETURN NO VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; } lock . lock ( ) ; try { ndx . submit ( NUM , nops , keys , null , Batch Remove Constructor . RETURN MUTATION COUNT , null ) ; if ( ground Truth != null ) { ground Truth . submit ( NUM , nops , keys , null , Batch Remove Constructor . RETURN MUTATION COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . next Double ( ) <= insert Rate ) { for ( int i = NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; vals [ i ] = new byte [ NUM ] ; r . next Bytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( NUM , nops , keys , vals , Batch Insert Constructor . RETURN NO VALUES , null ) ; if ( ground Truth != null ) { ground Truth . submit ( NUM , nops , keys , vals , Batch Insert Constructor . RETURN NO VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; } lock . lock ( ) ; try { ndx . submit ( NUM , nops , keys , null , Batch Remove Constructor . RETURN MUTATION COUNT , null ) ; if ( ground Truth != null ) { ground Truth . submit ( NUM , nops , keys , null , Batch Remove Constructor . RETURN MUTATION COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . next Double ( ) <= insert Rate ) { for ( int i = NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; vals [ i ] = new byte [ NUM ] ; r . next Bytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( NUM , nops , keys , vals , Batch Insert Constructor . RETURN NO VALUES , null ) ; if ( ground Truth != null ) { ground Truth . submit ( NUM , nops , keys , vals , Batch Insert Constructor . RETURN NO VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; } lock . lock ( ) ; try { ndx . submit ( NUM , nops , keys , null , Batch Remove Constructor . RETURN MUTATION COUNT , null ) ; if ( ground Truth != null ) { ground Truth . submit ( NUM , nops , keys , null , Batch Remove Constructor . RETURN MUTATION COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public static List < String > ref Names ( Collection < ? extends Named Related Resource Rep > refs ) { List < String > names = new Array List < String > ( ) ; if ( refs != null ) { for ( Named Related Resource Rep ref : refs ) { names . add ( ref . get Name ( ) ) ; } } return names ; }
protected double angle Between ( Point 2 D v1 , Point 2 D v2 ) { double x1 = v1 . get X ( ) ; double y1 = v1 . get Y ( ) ; double x2 = v2 . get X ( ) ; double y2 = v2 . get Y ( ) ; double cross = x1 * y2 - x2 * y1 ; int cw = NUM ; if ( cross > NUM ) { cw = - NUM ; } double angle = cw * Math . acos ( ( x1 * x2 + y1 * y2 ) / ( Math . sqrt ( x1 * x1 + y1 * y1 ) * Math . sqrt ( x2 * x2 + y2 * y2 ) ) ) ; if ( Double . is Na N ( angle ) ) { angle = NUM ; } return angle ; }
public void write ( int c ) throws java . io . IO Exception { synchronized ( lock ) { char one Char Array [ ] = new char [ NUM ] ; one Char Array [ NUM ] = ( char ) c ; write ( one Char Array ) ; } }
public void write ( int c ) throws java . io . IO Exception { synchronized ( lock ) { char one Char Array [ ] = new char [ NUM ] ; one Char Array [ NUM ] = ( char ) c ; write ( one Char Array ) ; } }
public void write ( int c ) throws java . io . IO Exception { synchronized ( lock ) { char one Char Array [ ] = new char [ NUM ] ; one Char Array [ NUM ] = ( char ) c ; write ( one Char Array ) ; } }
public void write ( int c ) throws java . io . IO Exception { synchronized ( lock ) { char one Char Array [ ] = new char [ NUM ] ; one Char Array [ NUM ] = ( char ) c ; write ( one Char Array ) ; } }
public void write ( int c ) throws java . io . IO Exception { synchronized ( lock ) { char one Char Array [ ] = new char [ NUM ] ; one Char Array [ NUM ] = ( char ) c ; write ( one Char Array ) ; } }
private String list To String ( List < String > string List ) { String Builder concat = new String Builder ( ) ; for ( String str : string List ) { concat . append ( str ) ; concat . append ( System . get Property ( STRING ) ) ; } return concat . to String ( ) ; }
private Environment Logger build Parent Tree ( String child Name ) { if ( child Name == null || child Name . equals ( STRING ) ) return null ; int p = child Name . last Index Of ( STRING ) ; String parent Name ; if ( p > NUM ) parent Name = child Name . substring ( NUM , p ) ; else parent Name = STRING ; Environment Logger parent = null ; Soft Reference < Environment Logger > parent Ref = env Loggers . get ( parent Name ) ; if ( parent Ref != null ) parent = parent Ref . get ( ) ; if ( parent != null ) return parent ; else { parent = new Environment Logger ( parent Name , null ) ; env Loggers . put ( parent Name , new Soft Reference < Environment Logger > ( parent ) ) ; Environment Logger grandparent = build Parent Tree ( parent Name ) ; if ( grandparent != null ) parent . set Parent ( grandparent ) ; return parent ; } }
public final void build Signed Directory ( ) throws Exception { try ( Byte Array Output Stream mime Content = new Byte Array Output Stream ( ) ) { build ( mime Content ) ; log . debug ( STRING , mime Content . to String ( ) ) ; byte [ ] content Bytes = mime Content . to Byte Array ( ) ; mime Content . reset ( ) ; sign ( content Bytes , mime Content ) ; Files . write ( temp Conf Path , mime Content . to Byte Array ( ) ) ; log . debug ( STRING , temp Conf Path ) ; } }
public final void build Signed Directory ( ) throws Exception { try ( Byte Array Output Stream mime Content = new Byte Array Output Stream ( ) ) { build ( mime Content ) ; log . debug ( STRING , mime Content . to String ( ) ) ; byte [ ] content Bytes = mime Content . to Byte Array ( ) ; mime Content . reset ( ) ; sign ( content Bytes , mime Content ) ; Files . write ( temp Conf Path , mime Content . to Byte Array ( ) ) ; log . debug ( STRING , temp Conf Path ) ; } }
public void add Biomes ( List < Biome Gen Base > biomes ) { allowed Biomes . add All ( get Biomes Entries ( biomes ) ) ; }
protected int draw Unselected Text ( Graphics g , int x , int y , int p0 , int p1 ) throws Bad Location Exception { g . set Color ( unselected ) ; Document doc = get Document ( ) ; Segment s = Segment Cache . get Shared Segment ( ) ; doc . get Text ( p0 , p1 - p0 , s ) ; int ret = Utilities . draw Tabbed Text ( this , s , x , y , g , this , p0 ) ; Segment Cache . release Shared Segment ( s ) ; return ret ; }
protected int draw Unselected Text ( Graphics g , int x , int y , int p0 , int p1 ) throws Bad Location Exception { g . set Color ( unselected ) ; Document doc = get Document ( ) ; Segment s = Segment Cache . get Shared Segment ( ) ; doc . get Text ( p0 , p1 - p0 , s ) ; int ret = Utilities . draw Tabbed Text ( this , s , x , y , g , this , p0 ) ; Segment Cache . release Shared Segment ( s ) ; return ret ; }
public Test Client Abstract ( String test Name , boolean verbose , boolean synchronous ) { if ( test Name == null || test Name . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . test Name = test Name ; this . verbose = verbose ; this . sync = synchronous ; }
public Date Time Formatter Builder parse Defaulting ( Temporal Field field , long value ) { Objects . require Non Null ( field , STRING ) ; append Internal ( new Default Value Parser ( field , value ) ) ; return this ; }
public Date Time Formatter Builder parse Defaulting ( Temporal Field field , long value ) { Objects . require Non Null ( field , STRING ) ; append Internal ( new Default Value Parser ( field , value ) ) ; return this ; }
public Date Time Formatter Builder parse Defaulting ( Temporal Field field , long value ) { Objects . require Non Null ( field , STRING ) ; append Internal ( new Default Value Parser ( field , value ) ) ; return this ; }
public Date Time Formatter Builder parse Defaulting ( Temporal Field field , long value ) { Objects . require Non Null ( field , STRING ) ; append Internal ( new Default Value Parser ( field , value ) ) ; return this ; }
@ Override protected E Class find Instantiable Compatible ( E Class e Type ) { if ( ! is Instantiatable Sub Type ( e Type , e Type ) ) { throw new Illegal State Exception ( String . value Of ( e Type ) ) ; } return e Type ; }
@ Visible For Testing protected Map < String , String > calculate Modified Server Defaults ( Map < String , String > new Defaults , Map < String , String > existing Defaults , Set < String > attr To Modify ) { Map < String , String > modified Values = new Hash Map < String , String > ( ) ; for ( String attr Name : attr To Modify ) { String new Attr = new Defaults . get ( attr Name ) ; String existing Attr = existing Defaults . get ( attr Name ) ; if ( new Attr != null && existing Attr != null && ! new Attr . equals ( existing Attr ) ) { modified Values . put ( attr Name , new Attr ) ; } } return modified Values ; }
public static List < SOAP Element > input Needed ( SOAP Element ele ) { List < SOAP Element > l = new Array List < SOAP Element > ( ) ; log . trace ( STRING + ele . get Node Name ( ) ) ; input Needed ( ele , l ) ; log . trace ( STRING + l ) ; return l ; }
public static List < SOAP Element > input Needed ( SOAP Element ele ) { List < SOAP Element > l = new Array List < SOAP Element > ( ) ; log . trace ( STRING + ele . get Node Name ( ) ) ; input Needed ( ele , l ) ; log . trace ( STRING + l ) ; return l ; }
public static List < SOAP Element > input Needed ( SOAP Element ele ) { List < SOAP Element > l = new Array List < SOAP Element > ( ) ; log . trace ( STRING + ele . get Node Name ( ) ) ; input Needed ( ele , l ) ; log . trace ( STRING + l ) ; return l ; }
public static Color blend ( Color color 1 , Color color 2 , double weight ) { double w2 = Math Utils . limit ( weight , NUM , NUM ) ; double w1 = NUM - w2 ; int r = ( int ) Math . round ( w1 * color 1 . get Red ( ) + w2 * color 2 . get Red ( ) ) ; int g = ( int ) Math . round ( w1 * color 1 . get Green ( ) + w2 * color 2 . get Green ( ) ) ; int b = ( int ) Math . round ( w1 * color 1 . get Blue ( ) + w2 * color 2 . get Blue ( ) ) ; int a = ( int ) Math . round ( w1 * color 1 . get Alpha ( ) + w2 * color 2 . get Alpha ( ) ) ; return new Color ( r , g , b , a ) ; }
@ Override public void on Item Click ( Adapter View < ? > parent , View view , int position , long id ) { set Selection ( position ) ; }
@ Override public void on Item Click ( Adapter View < ? > parent , View view , int position , long id ) { set Selection ( position ) ; }
public static int count Occurrences ( String full String , String pattern ) { int last Index = NUM ; int count = NUM ; while ( last Index != - NUM ) { last Index = full String . index Of ( pattern , last Index ) ; if ( last Index != - NUM ) { count ++ ; last Index += pattern . length ( ) ; } } return count ; }
private void pending Event ( Event Reg reg , Service ID sid , Item item , int transition , boolean copy Item ) { if ( item != null && copy Item ) item = copy Item ( item ) ; new Notifies . add ( new Event Task ( reg , sid , item , transition ) ) ; }
@ Override protected void paint Tab Background ( Graphics g , int tab Placement , int tab Index , int x , int y , int w , int h , boolean is Selected ) { if ( is Selected ) { if ( tab Placement == TOP ) { g . set Color ( Color . white ) ; g . fill Round Rect ( x , y , w , h + R + R , R , R ) ; } } else { } }
@ Override protected void paint Tab Background ( Graphics g , int tab Placement , int tab Index , int x , int y , int w , int h , boolean is Selected ) { if ( is Selected ) { if ( tab Placement == TOP ) { g . set Color ( Color . white ) ; g . fill Round Rect ( x , y , w , h + R + R , R , R ) ; } } else { } }
@ Override public String stem ( String word ) { String result ; Object [ ] args ; if ( m Stemmer == null ) { result = new String ( word ) ; } else { if ( m Set Current Method == null ) { set Stemmer ( get Stemmer ( ) ) ; } try { args = new Object [ NUM ] ; args [ NUM ] = word ; m Set Current Method . invoke ( m Stemmer , args ) ; args = new Object [ NUM ] ; m Stem Method . invoke ( m Stemmer , args ) ; args = new Object [ NUM ] ; result = ( String ) m Get Current Method . invoke ( m Stemmer , args ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; result = word ; } } return result ; }
public String to String ( ) { return STRING + val . replace ( STRING , STRING ) + STRING ; }
public String to String ( ) { return STRING + val . replace ( STRING , STRING ) + STRING ; }
int find Sync Position ( ) { int count = m Item Count ; if ( count == NUM ) { return INVALID POSITION ; } long id To Match = m Sync Row Id ; int seed = m Sync Position ; if ( id To Match == INVALID ROW ID ) { return INVALID POSITION ; } seed = Math . max ( NUM , seed ) ; seed = Math . min ( count - NUM , seed ) ; long end Time = System Clock . uptime Millis ( ) + SYNC MAX DURATION MILLIS ; long row Id ; int first = seed ; int last = seed ; boolean next = BOOL ; boolean hit First ; boolean hit Last ; T adapter = get Adapter ( ) ; if ( adapter == null ) { return INVALID POSITION ; } while ( System Clock . uptime Millis ( ) <= end Time ) { row Id = adapter . get Item Id ( seed ) ; if ( row Id == id To Match ) { return seed ; } hit Last = last == count - NUM ; hit First = first == NUM ; if ( hit Last && hit First ) { break ; } if ( hit First || ( next && ! hit Last ) ) { last ++ ; seed = last ; next = BOOL ; } else if ( hit Last ) { first -- ; seed = first ; next = BOOL ; } } return INVALID POSITION ; }
int find Sync Position ( ) { int count = m Item Count ; if ( count == NUM ) { return INVALID POSITION ; } long id To Match = m Sync Row Id ; int seed = m Sync Position ; if ( id To Match == INVALID ROW ID ) { return INVALID POSITION ; } seed = Math . max ( NUM , seed ) ; seed = Math . min ( count - NUM , seed ) ; long end Time = System Clock . uptime Millis ( ) + SYNC MAX DURATION MILLIS ; long row Id ; int first = seed ; int last = seed ; boolean next = BOOL ; boolean hit First ; boolean hit Last ; T adapter = get Adapter ( ) ; if ( adapter == null ) { return INVALID POSITION ; } while ( System Clock . uptime Millis ( ) <= end Time ) { row Id = adapter . get Item Id ( seed ) ; if ( row Id == id To Match ) { return seed ; } hit Last = last == count - NUM ; hit First = first == NUM ; if ( hit Last && hit First ) { break ; } if ( hit First || ( next && ! hit Last ) ) { last ++ ; seed = last ; next = BOOL ; } else if ( hit Last ) { first -- ; seed = first ; next = BOOL ; } } return INVALID POSITION ; }
int find Sync Position ( ) { int count = m Item Count ; if ( count == NUM ) { return INVALID POSITION ; } long id To Match = m Sync Row Id ; int seed = m Sync Position ; if ( id To Match == INVALID ROW ID ) { return INVALID POSITION ; } seed = Math . max ( NUM , seed ) ; seed = Math . min ( count - NUM , seed ) ; long end Time = System Clock . uptime Millis ( ) + SYNC MAX DURATION MILLIS ; long row Id ; int first = seed ; int last = seed ; boolean next = BOOL ; boolean hit First ; boolean hit Last ; T adapter = get Adapter ( ) ; if ( adapter == null ) { return INVALID POSITION ; } while ( System Clock . uptime Millis ( ) <= end Time ) { row Id = adapter . get Item Id ( seed ) ; if ( row Id == id To Match ) { return seed ; } hit Last = last == count - NUM ; hit First = first == NUM ; if ( hit Last && hit First ) { break ; } if ( hit First || ( next && ! hit Last ) ) { last ++ ; seed = last ; next = BOOL ; } else if ( hit Last ) { first -- ; seed = first ; next = BOOL ; } } return INVALID POSITION ; }
int find Sync Position ( ) { int count = m Item Count ; if ( count == NUM ) { return INVALID POSITION ; } long id To Match = m Sync Row Id ; int seed = m Sync Position ; if ( id To Match == INVALID ROW ID ) { return INVALID POSITION ; } seed = Math . max ( NUM , seed ) ; seed = Math . min ( count - NUM , seed ) ; long end Time = System Clock . uptime Millis ( ) + SYNC MAX DURATION MILLIS ; long row Id ; int first = seed ; int last = seed ; boolean next = BOOL ; boolean hit First ; boolean hit Last ; T adapter = get Adapter ( ) ; if ( adapter == null ) { return INVALID POSITION ; } while ( System Clock . uptime Millis ( ) <= end Time ) { row Id = adapter . get Item Id ( seed ) ; if ( row Id == id To Match ) { return seed ; } hit Last = last == count - NUM ; hit First = first == NUM ; if ( hit Last && hit First ) { break ; } if ( hit First || ( next && ! hit Last ) ) { last ++ ; seed = last ; next = BOOL ; } else if ( hit Last ) { first -- ; seed = first ; next = BOOL ; } } return INVALID POSITION ; }
public Modeled Authenticated User ( Authenticated User authenticated User , Authentication Provider model Authentication Provider , Modeled User user ) { super ( authenticated User . get Authentication Provider ( ) , authenticated User . get Credentials ( ) ) ; this . model Authentication Provider = model Authentication Provider ; this . user = user ; }
public Modeled Authenticated User ( Authenticated User authenticated User , Authentication Provider model Authentication Provider , Modeled User user ) { super ( authenticated User . get Authentication Provider ( ) , authenticated User . get Credentials ( ) ) ; this . model Authentication Provider = model Authentication Provider ; this . user = user ; }
public Modeled Authenticated User ( Authenticated User authenticated User , Authentication Provider model Authentication Provider , Modeled User user ) { super ( authenticated User . get Authentication Provider ( ) , authenticated User . get Credentials ( ) ) ; this . model Authentication Provider = model Authentication Provider ; this . user = user ; }
public Modeled Authenticated User ( Authenticated User authenticated User , Authentication Provider model Authentication Provider , Modeled User user ) { super ( authenticated User . get Authentication Provider ( ) , authenticated User . get Credentials ( ) ) ; this . model Authentication Provider = model Authentication Provider ; this . user = user ; }
public Modeled Authenticated User ( Authenticated User authenticated User , Authentication Provider model Authentication Provider , Modeled User user ) { super ( authenticated User . get Authentication Provider ( ) , authenticated User . get Credentials ( ) ) ; this . model Authentication Provider = model Authentication Provider ; this . user = user ; }
void add ( Super Card Toast super Card Toast ) { m List . add ( super Card Toast ) ; }
public Auth Configuration Model Impl ( Http Servlet Request req , Map map ) { super ( req , map ) ; current Realm = ( String ) map . get ( AM Admin Constants . CURRENT REALM ) ; }
public Time random Time ( ) { if ( random . next Int ( NUM ) == NUM ) { return null ; } String Builder buff = new String Builder ( ) ; buff . append ( get Int ( NUM ) ) ; buff . append ( STRING ) ; buff . append ( get Int ( NUM ) ) ; buff . append ( STRING ) ; buff . append ( get Int ( NUM ) ) ; return Time . value Of ( buff . to String ( ) ) ; }
public void delete Unused ( ) { while ( queue != null ) { Reference < ? extends Object > ref = queue . poll ( ) ; if ( ref == null ) { break ; } delete File ( ref , null ) ; } }
public void delete Unused ( ) { while ( queue != null ) { Reference < ? extends Object > ref = queue . poll ( ) ; if ( ref == null ) { break ; } delete File ( ref , null ) ; } }
public static X500 Name x500 Principal To X 500 Name ( X500 Principal principal ) { return X500 Name . get Instance ( Kse X 500 Name Style . INSTANCE , principal . get Encoded ( ) ) ; }
public Timmy Table add Timmy Table ( String filename , int record Size ) throws Sync Failed Exception , IO Exception { if ( is Open ) throw new Illegal State Exception ( STRING ) ; Timmy Table tt = new Timmy Table ( filename , record Size , this ) ; tables . add ( tt ) ; return tt ; }
@ Override public String to String ( ) { return buf . to String ( ) ; }
public void write ( byte [ ] buffer , int offset , int length ) throws IO Exception { file . write ( buffer , offset , length ) ; }
protected void update Range ( ) { if ( m type == int . class ) { set Range ( m lo . int Value ( ) , m hi . int Value ( ) - m lo . int Value ( ) , m min . int Value ( ) , m max . int Value ( ) ) ; } else if ( m type == long . class ) { long range = m max . long Value ( ) - m min . long Value ( ) ; if ( range == NUM ) { set Range ( NUM , NUM , NUM , NUM ) ; } else { long lo = m lo . long Value ( ) - m min . long Value ( ) ; long hi = m hi . long Value ( ) - m min . long Value ( ) ; int v = ( int ) ( NUM * lo / range ) ; int e = ( int ) ( NUM * hi / range ) - v ; set Range ( v , e , NUM , NUM ) ; } } else { double range = m max . double Value ( ) - m min . double Value ( ) ; if ( range == NUM ) { set Range ( NUM , NUM , NUM , NUM ) ; } else { double lo = m lo . double Value ( ) - m min . double Value ( ) ; double hi = m hi . double Value ( ) - m min . double Value ( ) ; int v = ( int ) ( NUM * lo / range ) ; int e = ( int ) ( NUM * hi / range ) - v ; set Range ( v , e , NUM , NUM ) ; } } }
public int pixel For ( int rgb ) { return surface Type . pixel For ( rgb , color Model ) ; }
protected double distance ( Instance first , Instance second ) { double distance = NUM ; int first I , second I ; for ( int p1 = NUM , p2 = NUM ; p1 < first . num Values ( ) || p2 < second . num Values ( ) ; ) { if ( p1 >= first . num Values ( ) ) { first I = m instances . num Attributes ( ) ; } else { first I = first . index ( p1 ) ; } if ( p2 >= second . num Values ( ) ) { second I = m instances . num Attributes ( ) ; } else { second I = second . index ( p2 ) ; } if ( first I == m instances . class Index ( ) ) { p1 ++ ; continue ; } if ( second I == m instances . class Index ( ) ) { p2 ++ ; continue ; } double diff ; if ( first I == second I ) { diff = difference ( first I , first . value Sparse ( p1 ) , second . value Sparse ( p2 ) ) ; p1 ++ ; p2 ++ ; } else if ( first I > second I ) { diff = difference ( second I , NUM , second . value Sparse ( p2 ) ) ; p2 ++ ; } else { diff = difference ( first I , first . value Sparse ( p1 ) , NUM ) ; p1 ++ ; } distance += diff * diff ; } return Math . sqrt ( distance / m instances . num Attributes ( ) ) ; }
public static Example Set create Example Set ( double [ ] [ ] data , double [ ] labels ) { if ( data . length == NUM ) { throw new Runtime Exception ( STRING ) ; } int number Of Attributes = data [ NUM ] . length ; List < Attribute > attribute List = new Array List < Attribute > ( number Of Attributes + ( labels != null ? NUM : NUM ) ) ; for ( int a = NUM ; a < number Of Attributes ; a ++ ) { attribute List . add ( Attribute Factory . create Attribute ( STRING + ( a + NUM ) , Ontology . NUMERICAL ) ) ; } Attribute label Attribute = null ; if ( labels != null ) { label Attribute = Attribute Factory . create Attribute ( STRING , Ontology . NUMERICAL ) ; attribute List . add ( label Attribute ) ; } Memory Example Table table = new Memory Example Table ( attribute List ) ; for ( int e = NUM ; e < data . length ; e ++ ) { double [ ] data Row = data [ e ] ; if ( label Attribute != null ) { data Row = new double [ number Of Attributes + NUM ] ; System . arraycopy ( data [ e ] , NUM , data Row , NUM , data [ e ] . length ) ; data Row [ data Row . length - NUM ] = labels [ e ] ; } table . add Data Row ( new Double Array Data Row ( data Row ) ) ; } return table . create Example Set ( label Attribute ) ; }
public Publisher Amb < T > amb Additional Source ( Publisher < ? extends T > source ) { if ( array != null ) { int n = array . length ; @ Suppress Warnings ( STRING ) Publisher < ? extends T > [ ] new Array = new Publisher [ n + NUM ] ; System . arraycopy ( array , NUM , new Array , NUM , n ) ; new Array [ n ] = source ; return new Publisher Amb < > ( new Array ) ; } return null ; }
public Publisher Amb < T > amb Additional Source ( Publisher < ? extends T > source ) { if ( array != null ) { int n = array . length ; @ Suppress Warnings ( STRING ) Publisher < ? extends T > [ ] new Array = new Publisher [ n + NUM ] ; System . arraycopy ( array , NUM , new Array , NUM , n ) ; new Array [ n ] = source ; return new Publisher Amb < > ( new Array ) ; } return null ; }
public Publisher Amb < T > amb Additional Source ( Publisher < ? extends T > source ) { if ( array != null ) { int n = array . length ; @ Suppress Warnings ( STRING ) Publisher < ? extends T > [ ] new Array = new Publisher [ n + NUM ] ; System . arraycopy ( array , NUM , new Array , NUM , n ) ; new Array [ n ] = source ; return new Publisher Amb < > ( new Array ) ; } return null ; }
public Publisher Amb < T > amb Additional Source ( Publisher < ? extends T > source ) { if ( array != null ) { int n = array . length ; @ Suppress Warnings ( STRING ) Publisher < ? extends T > [ ] new Array = new Publisher [ n + NUM ] ; System . arraycopy ( array , NUM , new Array , NUM , n ) ; new Array [ n ] = source ; return new Publisher Amb < > ( new Array ) ; } return null ; }
@ Override public void run ( ) { if ( ! running . compare And Set ( BOOL , BOOL ) ) { throw new Illegal State Exception ( STRING ) ; } sequence Barrier . clear Alert ( ) ; notify Start ( ) ; boolean processed Sequence = BOOL ; long cached Available Sequence = Long . MIN VALUE ; long next Sequence = sequence . get ( ) ; T event = null ; while ( BOOL ) { try { if ( processed Sequence ) { processed Sequence = BOOL ; do { next Sequence = work Sequence . get ( ) + NUM ; sequence . set ( next Sequence - NUM ) ; } while ( ! work Sequence . compare And Set ( next Sequence - NUM , next Sequence ) ) ; } if ( cached Available Sequence >= next Sequence ) { event = ring Buffer . get ( next Sequence ) ; work Handler . on Event ( event ) ; processed Sequence = BOOL ; } else { cached Available Sequence = sequence Barrier . wait For ( next Sequence ) ; } } catch ( final Alert Exception ex ) { if ( ! running . get ( ) ) { break ; } } catch ( final Throwable ex ) { exception Handler . handle Event Exception ( ex , next Sequence , event ) ; processed Sequence = BOOL ; } } notify Shutdown ( ) ; running . set ( BOOL ) ; }
public void add Cert Request ( Cert Request cert Req ) { cert Requests . add ( cert Req ) ; }
public void close ( ) throws IO Exception { input Stream . close ( ) ; }
@ Suppress Warnings ( STRING ) private static final Pipeline Op add Known In Conditional ( Pipeline Op left , final Filter Node filter , final AST 2 B Op Context ctx ) { final In B Op bop = ( In B Op ) filter . get Value Expression ( ) ; final I Constant < IV > [ ] set = bop . get Set ( ) ; final Linked Hash Set < IV > ivs = new Linked Hash Set < IV > ( ) ; for ( I Constant < IV > iv : set ) { ivs . add ( iv . get ( ) ) ; } final I Variable var = ( I Variable ) bop . get Value Expression ( ) ; left = new Data Set Join ( left Or Empty ( left ) , NV . as Map ( new NV [ ] { new NV ( Data Set Join . Annotations . VAR , var ) , new NV ( Data Set Join . Annotations . BOP ID , ctx . next Id ( ) ) , new NV ( Data Set Join . Annotations . GRAPHS , ivs ) } ) ) ; return left ; }
@ Suppress Warnings ( STRING ) private static final Pipeline Op add Known In Conditional ( Pipeline Op left , final Filter Node filter , final AST 2 B Op Context ctx ) { final In B Op bop = ( In B Op ) filter . get Value Expression ( ) ; final I Constant < IV > [ ] set = bop . get Set ( ) ; final Linked Hash Set < IV > ivs = new Linked Hash Set < IV > ( ) ; for ( I Constant < IV > iv : set ) { ivs . add ( iv . get ( ) ) ; } final I Variable var = ( I Variable ) bop . get Value Expression ( ) ; left = new Data Set Join ( left Or Empty ( left ) , NV . as Map ( new NV [ ] { new NV ( Data Set Join . Annotations . VAR , var ) , new NV ( Data Set Join . Annotations . BOP ID , ctx . next Id ( ) ) , new NV ( Data Set Join . Annotations . GRAPHS , ivs ) } ) ) ; return left ; }
@ Override public void on Place Selected ( Place place ) { Log . i ( TAG , STRING + place . get Name ( ) ) ; m Place Details Text . set Text ( format Place Details ( get Resources ( ) , place . get Name ( ) , place . get Id ( ) , place . get Address ( ) , place . get Phone Number ( ) , place . get Website Uri ( ) ) ) ; Char Sequence attributions = place . get Attributions ( ) ; if ( ! Text Utils . is Empty ( attributions ) ) { m Place Attribution . set Text ( Html . from Html ( attributions . to String ( ) ) ) ; } else { m Place Attribution . set Text ( STRING ) ; } }
public static boolean check Thick Pool Candidacy ( Storage Pool pool , long required Capacity In KB , Coordinator Client coordinator ) { return ( NUM - get Thick Pool Free Capacity Percentage ( pool , required Capacity In KB ) ) <= get Max Pool Utilization Percentage ( pool , coordinator ) ; }
public static boolean check Thick Pool Candidacy ( Storage Pool pool , long required Capacity In KB , Coordinator Client coordinator ) { return ( NUM - get Thick Pool Free Capacity Percentage ( pool , required Capacity In KB ) ) <= get Max Pool Utilization Percentage ( pool , coordinator ) ; }
public static boolean check Thick Pool Candidacy ( Storage Pool pool , long required Capacity In KB , Coordinator Client coordinator ) { return ( NUM - get Thick Pool Free Capacity Percentage ( pool , required Capacity In KB ) ) <= get Max Pool Utilization Percentage ( pool , coordinator ) ; }
public byte [ ] calculate Checksum ( byte [ ] data , int size ) throws Krb Crypto Exception { Message Digest md 5 ; byte [ ] result = null ; try { md 5 = Message Digest . get Instance ( STRING ) ; } catch ( Exception e ) { throw new Krb Crypto Exception ( STRING + e . get Message ( ) ) ; } try { md 5 . update ( data ) ; result = md 5 . digest ( ) ; } catch ( Exception e ) { throw new Krb Crypto Exception ( e . get Message ( ) ) ; } return result ; }
public Pair < String , String > parse ( String entry ) { if ( entry . length ( ) > NUM ) { Matcher m = pattern . matcher ( entry ) ; if ( m . matches ( ) ) { String name = m . group ( NUM ) ; String value = m . group ( NUM ) ; if ( name != null ) { name = name . trim ( ) ; if ( value == null ) { value = STRING ; } else { value = value . trim ( ) ; } return Pair . of ( name , value ) ; } } } return null ; }
public Pair < String , String > parse ( String entry ) { if ( entry . length ( ) > NUM ) { Matcher m = pattern . matcher ( entry ) ; if ( m . matches ( ) ) { String name = m . group ( NUM ) ; String value = m . group ( NUM ) ; if ( name != null ) { name = name . trim ( ) ; if ( value == null ) { value = STRING ; } else { value = value . trim ( ) ; } return Pair . of ( name , value ) ; } } } return null ; }
public Pair < String , String > parse ( String entry ) { if ( entry . length ( ) > NUM ) { Matcher m = pattern . matcher ( entry ) ; if ( m . matches ( ) ) { String name = m . group ( NUM ) ; String value = m . group ( NUM ) ; if ( name != null ) { name = name . trim ( ) ; if ( value == null ) { value = STRING ; } else { value = value . trim ( ) ; } return Pair . of ( name , value ) ; } } } return null ; }
public Pair < String , String > parse ( String entry ) { if ( entry . length ( ) > NUM ) { Matcher m = pattern . matcher ( entry ) ; if ( m . matches ( ) ) { String name = m . group ( NUM ) ; String value = m . group ( NUM ) ; if ( name != null ) { name = name . trim ( ) ; if ( value == null ) { value = STRING ; } else { value = value . trim ( ) ; } return Pair . of ( name , value ) ; } } } return null ; }
public void reopen Read Write ( ) { synchronized ( m Lock ) { throw If Not Open Locked ( ) ; if ( ! is Read Only Locked ( ) ) { return ; } final int old Open Flags = m Configuration Locked . open Flags ; m Configuration Locked . open Flags = ( m Configuration Locked . open Flags & ~ OPEN READ MASK ) | OPEN READWRITE ; try { m Connection Pool Locked . reconfigure ( m Configuration Locked ) ; } catch ( Runtime Exception ex ) { m Configuration Locked . open Flags = old Open Flags ; throw ex ; } } }
public void reopen Read Write ( ) { synchronized ( m Lock ) { throw If Not Open Locked ( ) ; if ( ! is Read Only Locked ( ) ) { return ; } final int old Open Flags = m Configuration Locked . open Flags ; m Configuration Locked . open Flags = ( m Configuration Locked . open Flags & ~ OPEN READ MASK ) | OPEN READWRITE ; try { m Connection Pool Locked . reconfigure ( m Configuration Locked ) ; } catch ( Runtime Exception ex ) { m Configuration Locked . open Flags = old Open Flags ; throw ex ; } } }
public void reopen Read Write ( ) { synchronized ( m Lock ) { throw If Not Open Locked ( ) ; if ( ! is Read Only Locked ( ) ) { return ; } final int old Open Flags = m Configuration Locked . open Flags ; m Configuration Locked . open Flags = ( m Configuration Locked . open Flags & ~ OPEN READ MASK ) | OPEN READWRITE ; try { m Connection Pool Locked . reconfigure ( m Configuration Locked ) ; } catch ( Runtime Exception ex ) { m Configuration Locked . open Flags = old Open Flags ; throw ex ; } } }
public void reopen Read Write ( ) { synchronized ( m Lock ) { throw If Not Open Locked ( ) ; if ( ! is Read Only Locked ( ) ) { return ; } final int old Open Flags = m Configuration Locked . open Flags ; m Configuration Locked . open Flags = ( m Configuration Locked . open Flags & ~ OPEN READ MASK ) | OPEN READWRITE ; try { m Connection Pool Locked . reconfigure ( m Configuration Locked ) ; } catch ( Runtime Exception ex ) { m Configuration Locked . open Flags = old Open Flags ; throw ex ; } } }
public void reset Stats ( ) { if ( lock . try Lock ( ) ) { try { ensure Initialized ( ) ; update Stats ( ) ; } finally { lock . unlock ( ) ; } } }
public void reset Stats ( ) { if ( lock . try Lock ( ) ) { try { ensure Initialized ( ) ; update Stats ( ) ; } finally { lock . unlock ( ) ; } } }
public void reset Stats ( ) { if ( lock . try Lock ( ) ) { try { ensure Initialized ( ) ; update Stats ( ) ; } finally { lock . unlock ( ) ; } } }
public void reset Stats ( ) { if ( lock . try Lock ( ) ) { try { ensure Initialized ( ) ; update Stats ( ) ; } finally { lock . unlock ( ) ; } } }
public void reset Stats ( ) { if ( lock . try Lock ( ) ) { try { ensure Initialized ( ) ; update Stats ( ) ; } finally { lock . unlock ( ) ; } } }
public void reset Stats ( ) { if ( lock . try Lock ( ) ) { try { ensure Initialized ( ) ; update Stats ( ) ; } finally { lock . unlock ( ) ; } } }
@ Override public < T extends Service Document > List < String > query Documents For Links ( Class < T > document Type , Immutable Map < String , String > terms ) throws Bad Request Exception , Document Not Found Exception , Timeout Exception , Interrupted Exception { check Not Null ( document Type , STRING ) ; Query Task . Query Specification spec = Query Task Utils . build Query Spec ( document Type , terms ) ; Operation result = post To Broadcast Query Service ( spec ) ; Set < String > document Links = Query Task Utils . get Broadcast Query Document Links ( result ) ; if ( document Links . size ( ) <= NUM ) { return Immutable List . of ( ) ; } return Immutable List . copy Of ( document Links ) ; }
@ Override public < T extends Service Document > List < String > query Documents For Links ( Class < T > document Type , Immutable Map < String , String > terms ) throws Bad Request Exception , Document Not Found Exception , Timeout Exception , Interrupted Exception { check Not Null ( document Type , STRING ) ; Query Task . Query Specification spec = Query Task Utils . build Query Spec ( document Type , terms ) ; Operation result = post To Broadcast Query Service ( spec ) ; Set < String > document Links = Query Task Utils . get Broadcast Query Document Links ( result ) ; if ( document Links . size ( ) <= NUM ) { return Immutable List . of ( ) ; } return Immutable List . copy Of ( document Links ) ; }
@ Override public < T extends Service Document > List < String > query Documents For Links ( Class < T > document Type , Immutable Map < String , String > terms ) throws Bad Request Exception , Document Not Found Exception , Timeout Exception , Interrupted Exception { check Not Null ( document Type , STRING ) ; Query Task . Query Specification spec = Query Task Utils . build Query Spec ( document Type , terms ) ; Operation result = post To Broadcast Query Service ( spec ) ; Set < String > document Links = Query Task Utils . get Broadcast Query Document Links ( result ) ; if ( document Links . size ( ) <= NUM ) { return Immutable List . of ( ) ; } return Immutable List . copy Of ( document Links ) ; }
@ Override public < T extends Service Document > List < String > query Documents For Links ( Class < T > document Type , Immutable Map < String , String > terms ) throws Bad Request Exception , Document Not Found Exception , Timeout Exception , Interrupted Exception { check Not Null ( document Type , STRING ) ; Query Task . Query Specification spec = Query Task Utils . build Query Spec ( document Type , terms ) ; Operation result = post To Broadcast Query Service ( spec ) ; Set < String > document Links = Query Task Utils . get Broadcast Query Document Links ( result ) ; if ( document Links . size ( ) <= NUM ) { return Immutable List . of ( ) ; } return Immutable List . copy Of ( document Links ) ; }
@ Override public < T extends Service Document > List < String > query Documents For Links ( Class < T > document Type , Immutable Map < String , String > terms ) throws Bad Request Exception , Document Not Found Exception , Timeout Exception , Interrupted Exception { check Not Null ( document Type , STRING ) ; Query Task . Query Specification spec = Query Task Utils . build Query Spec ( document Type , terms ) ; Operation result = post To Broadcast Query Service ( spec ) ; Set < String > document Links = Query Task Utils . get Broadcast Query Document Links ( result ) ; if ( document Links . size ( ) <= NUM ) { return Immutable List . of ( ) ; } return Immutable List . copy Of ( document Links ) ; }
public C Process List Panel ( final Process List process List ) { super ( new Border Layout ( ) ) ; m process List = process List ; final C Process List Model model = new C Process List Model ( process List ) ; m sorter = new Table Row Sorter < C Process List Model > ( model ) ; m table = new J Table ( model ) ; m table . set Selection Mode ( List Selection Model . SINGLE SELECTION ) ; m table . set Row Sorter ( m sorter ) ; final J Scroll Pane scroll Pane = new J Scroll Pane ( m table ) ; scroll Pane . set Border ( new Titled Border ( STRING ) ) ; add ( scroll Pane ) ; set Preferred Size ( new Dimension ( NUM , NUM ) ) ; }
public boolean offer ( E e , long timeout , Time Unit unit ) throws Interrupted Exception { if ( e == null ) throw new Null Pointer Exception ( ) ; long nanos = unit . to Nanos ( timeout ) ; int c = - NUM ; final Reentrant Lock put Lock = this . put Lock ; final Atomic Integer count = this . count ; put Lock . lock Interruptibly ( ) ; try { while ( count . get ( ) == capacity ) { if ( nanos <= NUM ) return BOOL ; nanos = not Full . await Nanos ( nanos ) ; } enqueue ( new Node < E > ( e ) ) ; c = count . get And Increment ( ) ; if ( c + NUM < capacity ) not Full . signal ( ) ; } finally { put Lock . unlock ( ) ; } if ( c == NUM ) signal Not Empty ( ) ; return BOOL ; }
public boolean offer ( E e , long timeout , Time Unit unit ) throws Interrupted Exception { if ( e == null ) throw new Null Pointer Exception ( ) ; long nanos = unit . to Nanos ( timeout ) ; int c = - NUM ; final Reentrant Lock put Lock = this . put Lock ; final Atomic Integer count = this . count ; put Lock . lock Interruptibly ( ) ; try { while ( count . get ( ) == capacity ) { if ( nanos <= NUM ) return BOOL ; nanos = not Full . await Nanos ( nanos ) ; } enqueue ( new Node < E > ( e ) ) ; c = count . get And Increment ( ) ; if ( c + NUM < capacity ) not Full . signal ( ) ; } finally { put Lock . unlock ( ) ; } if ( c == NUM ) signal Not Empty ( ) ; return BOOL ; }
public void update Component Tree UI ( ) { Swing Utilities . update Component Tree UI ( dialog ) ; }
public void init ( ) { M Bean Server mbs = Management Factory . get Platform M Bean Server ( ) ; try { mbs . register M Bean ( this , new Object Name ( MBEAN NAME ) ) ; } catch ( JM Exception e ) { throw new Runtime Exception ( e ) ; } }
public void init ( ) { M Bean Server mbs = Management Factory . get Platform M Bean Server ( ) ; try { mbs . register M Bean ( this , new Object Name ( MBEAN NAME ) ) ; } catch ( JM Exception e ) { throw new Runtime Exception ( e ) ; } }
public void init ( ) { M Bean Server mbs = Management Factory . get Platform M Bean Server ( ) ; try { mbs . register M Bean ( this , new Object Name ( MBEAN NAME ) ) ; } catch ( JM Exception e ) { throw new Runtime Exception ( e ) ; } }
public Ignite Spi Multi Exception ( String msg , @ Nullable Throwable cause , @ Nullable Collection < Throwable > nested Causes ) { super ( msg , cause ) ; if ( nested Causes != null ) causes . add All ( nested Causes ) ; }
private void save S Psoap Mni ( String mnisoap Location , String mniresp Loaction , List manage Name Id List , com . sun . identity . saml 2 . jaxb . metadata . Object Factory obj Fact ) throws JAXB Exception { if ( mnisoap Location != null && mnisoap Location . length ( ) > NUM ) { Manage Name ID Service Element sls Elem Soap = obj Fact . create Manage Name ID Service Element ( ) ; sls Elem Soap . set Binding ( soap Binding ) ; sls Elem Soap . set Location ( mnisoap Location ) ; sls Elem Soap . set Response Location ( mniresp Loaction ) ; manage Name Id List . add ( sls Elem Soap ) ; } }
private static void add Default Profile ( Spring Application app , Simple Command Line Property Source source ) { if ( ! source . contains Property ( STRING ) ) { app . set Additional Profiles ( Constants . SPRING PROFILE DEVELOPMENT ) ; } }
@ Override public void accept Data Point ( Chart Event e ) { if ( e . get Reset ( ) ) { m x Count = NUM ; m max = NUM ; m min = NUM ; } if ( m output Frame != null ) { boolean refresh = BOOL ; if ( e . get Legend Text ( ) != null & e . get Legend Text ( ) != m legend Text ) { m legend Text = e . get Legend Text ( ) ; refresh = BOOL ; } if ( e . get Min ( ) != m min || e . get Max ( ) != m max ) { m old Max = m max ; m old Min = m min ; m max = e . get Max ( ) ; m min = e . get Min ( ) ; refresh = BOOL ; m y Scale Update = BOOL ; } if ( refresh ) { m legend Panel . repaint ( ) ; m scale Panel . repaint ( ) ; } accept Data Point ( e . get Data Point ( ) ) ; } m x Count ++ ; }
public void add Edge Connector ( ) { num Edge Connectors ++ ; String name = STRING ; boolean duplicate = BOOL ; while ( duplicate ) { name = STRING + num Edge Connectors ; if ( finder . find Positionable Point By Name ( name ) == null ) { duplicate = BOOL ; } if ( duplicate ) { num Edge Connectors ++ ; } } Positionable Point o = new Positionable Point ( name , Positionable Point . EDGE CONNECTOR , current Point , this ) ; point List . add ( o ) ; set Dirty ( BOOL ) ; }
private static String word Shape Chris 2 ( String s , boolean omit If In Boundary , Collection < String > known LC Words ) { int len = s . length ( ) ; if ( len <= BOUNDARY SIZE * NUM ) { return word Shape Chris 2 Short ( s , len , known LC Words ) ; } else { return word Shape Chris 2 Long ( s , omit If In Boundary , len , known LC Words ) ; } }
private static String word Shape Chris 2 ( String s , boolean omit If In Boundary , Collection < String > known LC Words ) { int len = s . length ( ) ; if ( len <= BOUNDARY SIZE * NUM ) { return word Shape Chris 2 Short ( s , len , known LC Words ) ; } else { return word Shape Chris 2 Long ( s , omit If In Boundary , len , known LC Words ) ; } }
private static String word Shape Chris 2 ( String s , boolean omit If In Boundary , Collection < String > known LC Words ) { int len = s . length ( ) ; if ( len <= BOUNDARY SIZE * NUM ) { return word Shape Chris 2 Short ( s , len , known LC Words ) ; } else { return word Shape Chris 2 Long ( s , omit If In Boundary , len , known LC Words ) ; } }
private static String word Shape Chris 2 ( String s , boolean omit If In Boundary , Collection < String > known LC Words ) { int len = s . length ( ) ; if ( len <= BOUNDARY SIZE * NUM ) { return word Shape Chris 2 Short ( s , len , known LC Words ) ; } else { return word Shape Chris 2 Long ( s , omit If In Boundary , len , known LC Words ) ; } }
private static String word Shape Chris 2 ( String s , boolean omit If In Boundary , Collection < String > known LC Words ) { int len = s . length ( ) ; if ( len <= BOUNDARY SIZE * NUM ) { return word Shape Chris 2 Short ( s , len , known LC Words ) ; } else { return word Shape Chris 2 Long ( s , omit If In Boundary , len , known LC Words ) ; } }
protected void log Assign Node ( Graph Node node , int level , int offset ) { logger . info ( STRING + level + STRING + offset + STRING + node ) ; }
protected void log Assign Node ( Graph Node node , int level , int offset ) { logger . info ( STRING + level + STRING + offset + STRING + node ) ; }
@ Deprecated public static void run Finalizers On Exit ( boolean run ) { finalize On Exit = run ; }
@ Deprecated public static void run Finalizers On Exit ( boolean run ) { finalize On Exit = run ; }
@ Deprecated public static void run Finalizers On Exit ( boolean run ) { finalize On Exit = run ; }
@ Deprecated public static void run Finalizers On Exit ( boolean run ) { finalize On Exit = run ; }
@ Deprecated public static void run Finalizers On Exit ( boolean run ) { finalize On Exit = run ; }
public boolean remove ( Predicate p ) { if ( m clauses . remove ( p ) ) { fire Expression Change ( ) ; return BOOL ; } else { return BOOL ; } }
public Double Array resize ( Double Array array , long size ) { if ( array instanceof Big Double Array ) { return resize In Place ( ( Big Double Array ) array , size ) ; } else { Abstract Array arr = ( Abstract Array ) array ; final Double Array new Array = new Double Array ( size , arr . clear On Resize ) ; for ( long i = NUM , end = Math . min ( size , array . size ( ) ) ; i < end ; ++ i ) { new Array . set ( i , array . get ( i ) ) ; } array . close ( ) ; return new Array ; } }
public static List < User > from ( Cursor c ) { List < User > users = null ; int count = c . get Count ( ) ; if ( count > NUM ) { users = new Array List < > ( count ) ; while ( c . move To Next ( ) ) { User user = new User ( ) ; Syncing . from ( c , user ) ; int col = c . get Column Index ( EMAIL HASH ) ; if ( col >= NUM ) { user . email Hash = c . get String ( col ) ; } col = c . get Column Index ( FOLLOWING ) ; if ( col >= NUM ) { user . is Following = c . get Int ( col ) == NUM ; } users . add ( user ) ; } } c . close ( ) ; return users ; }
public void update Yaw And Pitch ( ) { long time Now = System . current Time Millis ( ) ; long delta Time = time Now - this . last Angular Update Time ; this . last Angular Update Time = time Now ; double overclock Scale = NUM / ( double ) Time Helper . server Tick Length ; double delta Yaw = this . yaw Scale * overclock Scale * this . max Angular Velocity Degrees Per Second * ( delta Time / NUM ) ; double delta Pitch = this . pitch Scale * overclock Scale * this . max Angular Velocity Degrees Per Second * ( delta Time / NUM ) ; m Yaw += delta Yaw ; m Camera Pitch += delta Pitch ; m Camera Pitch = ( m Camera Pitch < - NUM ) ? - NUM : ( m Camera Pitch > NUM ? NUM : m Camera Pitch ) ; }
private static void draw Left Tab ( int x , int y , int w , int h , Graphics 2 D g2 , Color UI Resource color ) { double r Top = Rapid Look And Feel . CORNER TAB RADIUS * NUM ; g2 . set Color ( color ) ; g2 . fill ( create Left Tab Shape ( x + NUM , y + NUM , w - NUM , h , r Top , BOOL ) ) ; g2 . set Color ( Colors . TAB BORDER ) ; g2 . draw ( create Left Tab Shape ( x , y , w - NUM , h , r Top , BOOL ) ) ; }
private static void draw Left Tab ( int x , int y , int w , int h , Graphics 2 D g2 , Color UI Resource color ) { double r Top = Rapid Look And Feel . CORNER TAB RADIUS * NUM ; g2 . set Color ( color ) ; g2 . fill ( create Left Tab Shape ( x + NUM , y + NUM , w - NUM , h , r Top , BOOL ) ) ; g2 . set Color ( Colors . TAB BORDER ) ; g2 . draw ( create Left Tab Shape ( x , y , w - NUM , h , r Top , BOOL ) ) ; }
private static void draw Left Tab ( int x , int y , int w , int h , Graphics 2 D g2 , Color UI Resource color ) { double r Top = Rapid Look And Feel . CORNER TAB RADIUS * NUM ; g2 . set Color ( color ) ; g2 . fill ( create Left Tab Shape ( x + NUM , y + NUM , w - NUM , h , r Top , BOOL ) ) ; g2 . set Color ( Colors . TAB BORDER ) ; g2 . draw ( create Left Tab Shape ( x , y , w - NUM , h , r Top , BOOL ) ) ; }
public void add Slide ( @ Non Null Fragment fragment ) { fragments . add ( fragment ) ; if ( is Wizard Mode ) { set Off Screen Page Limit ( fragments . size ( ) ) ; } m Pager Adapter . notify Data Set Changed ( ) ; }
@ Override public void write External ( Object Output out ) throws IO Exception { super . write External ( out ) ; int k max = knn Distances . length ; out . write Int ( k max ) ; for ( int i = NUM ; i < k max ; i ++ ) { out . write Double ( knn Distances [ i ] ) ; } }
@ Override public void write External ( Object Output out ) throws IO Exception { super . write External ( out ) ; int k max = knn Distances . length ; out . write Int ( k max ) ; for ( int i = NUM ; i < k max ; i ++ ) { out . write Double ( knn Distances [ i ] ) ; } }
@ Override public int length ( ) { return data . length / ( format . get Frame Size ( ) * NUM ) ; }
public static Boolean Glass Function serializable Instance ( ) { return new Boolean Glass Function ( Basic Lag Graph . serializable Instance ( ) ) ; }
public static Boolean Glass Function serializable Instance ( ) { return new Boolean Glass Function ( Basic Lag Graph . serializable Instance ( ) ) ; }
@ No Warning ( STRING ) int fp 1 ( int level ) { Object x = null ; if ( level > NUM ) x = new Object ( ) ; if ( level > NUM ) return x . hash Code ( ) ; return NUM ; }
public boolean memory Is Low ( ) { m Memory Usage = m Memory MX Bean . get Heap Memory Usage ( ) ; if ( is Enabled ( ) ) { long low Threshold = ( long ) ( NUM * m Memory Usage . get Max ( ) ) ; if ( low Threshold < LOW MEMORY MINIMUM ) { low Threshold = LOW MEMORY MINIMUM ; } long avail = m Memory Usage . get Max ( ) - m Memory Usage . get Used ( ) ; return ( avail < low Threshold ) ; } else { return BOOL ; } }
public static void object String Non Recursive ( @ Unretained Object obj , String Builder sb ) { if ( obj instanceof Object [ ] ) { sb . append ( STRING ) ; boolean first = BOOL ; for ( Object o : ( Object [ ] ) obj ) { if ( ! first ) { sb . append ( STRING ) ; sb . append ( o ) ; } else { first = BOOL ; object String With Bytes ( o , sb ) ; } } sb . append ( STRING ) ; } else { object String With Bytes ( obj , sb ) ; } }
public int processor ( ) { return Integer . parse Int ( fields [ NUM ] ) ; }
public int processor ( ) { return Integer . parse Int ( fields [ NUM ] ) ; }
private final String std To Local ( String name ) { return name . replace ( STRING , java . io . File . separator Char ) ; }
public boolean mouse Moved ( Mouse Event e ) { Esri Graphic List list = get Esri Graphic List ( ) ; boolean ret = BOOL ; if ( list != null ) { OM Graphic omg = list . find Closest ( e . get X ( ) , e . get Y ( ) , NUM ) ; if ( omg != null ) { int index ; Integer I = ( ( Integer ) omg . get Attribute ( SHAPE INDEX ATTRIBUTE ) ) ; if ( I != null ) { index = I . int Value ( ) ; } else { index = list . index Of ( omg ) ; } if ( parent Layer == null ) { Component comp = get Component ( ) ; if ( comp instanceof Layer ) { parent Layer = ( Layer ) comp ; } } if ( parent Layer != null ) { parent Layer . fire Request Tool Tip ( get Description ( index ) ) ; } ret = BOOL ; } else if ( parent Layer != null ) { parent Layer . fire Hide Tool Tip ( ) ; } } return ret ; }
public static void append ( Path self , Object text , String charset ) throws IO Exception { append ( self , text , charset , BOOL ) ; }
public static void append ( Path self , Object text , String charset ) throws IO Exception { append ( self , text , charset , BOOL ) ; }
void stop Task ( String process Name ) { trace ( STRING + process Name ) ; Process p = tasks . remove ( process Name ) ; if ( p == null ) { return ; } p . destroy ( ) ; }
private void draw Unit ( final Graphics 2 D graphics , final Image image , final Point placement Point 2 , final Rectangle bounds ) { graphics . draw Image ( image , placement Point . x - bounds . x , placement Point . y - bounds . y , null ) ; }
private void draw Unit ( final Graphics 2 D graphics , final Image image , final Point placement Point 2 , final Rectangle bounds ) { graphics . draw Image ( image , placement Point . x - bounds . x , placement Point . y - bounds . y , null ) ; }
public void trim To Size ( ) { if ( size < array . length ) { int [ ] olddata = array ; array = new int [ size ] ; System . arraycopy ( olddata , NUM , array , NUM , size ) ; } }
public void trim To Size ( ) { if ( size < array . length ) { int [ ] olddata = array ; array = new int [ size ] ; System . arraycopy ( olddata , NUM , array , NUM , size ) ; } }
public void trim To Size ( ) { if ( size < array . length ) { int [ ] olddata = array ; array = new int [ size ] ; System . arraycopy ( olddata , NUM , array , NUM , size ) ; } }
public void trim To Size ( ) { if ( size < array . length ) { int [ ] olddata = array ; array = new int [ size ] ; System . arraycopy ( olddata , NUM , array , NUM , size ) ; } }
public void trim To Size ( ) { if ( size < array . length ) { int [ ] olddata = array ; array = new int [ size ] ; System . arraycopy ( olddata , NUM , array , NUM , size ) ; } }
public void trim To Size ( ) { if ( size < array . length ) { int [ ] olddata = array ; array = new int [ size ] ; System . arraycopy ( olddata , NUM , array , NUM , size ) ; } }
public static String compute Digest ( URL url , String algorithm ) throws IO Exception , No Such Algorithm Exception { return compute Digest ( url . open Stream ( ) , algorithm ) ; }
public Scale IO Snapshot Volume Response snapshot Volume ( String vol Id , String snapshot Name , String system Id ) throws Exception { String uri = Scale IO Constants . get Snapshot Volumes URI ( system Id ) ; Scale IO Snapshot Volumes sp Vol = new Scale IO Snapshot Volumes ( ) ; sp Vol . add Snapshot ( vol Id , snapshot Name ) ; Client Response response = post ( URI . create ( uri ) , get Json For Entity ( sp Vol ) ) ; return get Response Object ( Scale IO Snapshot Volume Response . class , response ) ; }
public static Enum cast To Enum ( Object object , Class < ? extends Enum > type ) { if ( object == null ) return null ; if ( type . is Instance ( object ) ) return ( Enum ) object ; if ( object instanceof String || object instanceof G String ) { return Enum . value Of ( type , object . to String ( ) ) ; } throw new Groovy Cast Exception ( object , type ) ; }
public static Enum cast To Enum ( Object object , Class < ? extends Enum > type ) { if ( object == null ) return null ; if ( type . is Instance ( object ) ) return ( Enum ) object ; if ( object instanceof String || object instanceof G String ) { return Enum . value Of ( type , object . to String ( ) ) ; } throw new Groovy Cast Exception ( object , type ) ; }
public static Enum cast To Enum ( Object object , Class < ? extends Enum > type ) { if ( object == null ) return null ; if ( type . is Instance ( object ) ) return ( Enum ) object ; if ( object instanceof String || object instanceof G String ) { return Enum . value Of ( type , object . to String ( ) ) ; } throw new Groovy Cast Exception ( object , type ) ; }
protected String make Suffix ( String path , String content Type ) { String suffix = content Type != null ? WWIO . make Suffix For Mime Type ( content Type ) : null ; String existing Suffix = WWIO . get Suffix ( path ) ; if ( existing Suffix != null && existing Suffix . equals Ignore Case ( STRING ) ) existing Suffix = STRING ; if ( suffix != null && ( existing Suffix == null || ! existing Suffix . equals Ignore Case ( suffix . substring ( NUM ) ) ) ) return suffix ; else return null ; }
protected String make Suffix ( String path , String content Type ) { String suffix = content Type != null ? WWIO . make Suffix For Mime Type ( content Type ) : null ; String existing Suffix = WWIO . get Suffix ( path ) ; if ( existing Suffix != null && existing Suffix . equals Ignore Case ( STRING ) ) existing Suffix = STRING ; if ( suffix != null && ( existing Suffix == null || ! existing Suffix . equals Ignore Case ( suffix . substring ( NUM ) ) ) ) return suffix ; else return null ; }
protected String make Suffix ( String path , String content Type ) { String suffix = content Type != null ? WWIO . make Suffix For Mime Type ( content Type ) : null ; String existing Suffix = WWIO . get Suffix ( path ) ; if ( existing Suffix != null && existing Suffix . equals Ignore Case ( STRING ) ) existing Suffix = STRING ; if ( suffix != null && ( existing Suffix == null || ! existing Suffix . equals Ignore Case ( suffix . substring ( NUM ) ) ) ) return suffix ; else return null ; }
protected String make Suffix ( String path , String content Type ) { String suffix = content Type != null ? WWIO . make Suffix For Mime Type ( content Type ) : null ; String existing Suffix = WWIO . get Suffix ( path ) ; if ( existing Suffix != null && existing Suffix . equals Ignore Case ( STRING ) ) existing Suffix = STRING ; if ( suffix != null && ( existing Suffix == null || ! existing Suffix . equals Ignore Case ( suffix . substring ( NUM ) ) ) ) return suffix ; else return null ; }
@ Request Mapping ( value = STRING , method = { Request Method . GET } ) @ Response Body private static List < String > show Hive Databases ( ) throws IO Exception { I Hive Client hive Client = Hive Client Factory . get Hive Client ( ) ; List < String > results = null ; try { results = hive Client . get Hive Db Names ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; throw new IO Exception ( e ) ; } return results ; }
@ Override public void remove Alarm ( final Long alarm Id , final Configuration Element Report alarm Report ) { try { Alarm Cache Object alarm = ( Alarm Cache Object ) alarm Cache . get Copy ( alarm Id ) ; alarm Config Transacted . do Remove Alarm ( alarm Id , alarm Report ) ; alarm Cache . remove ( alarm Id ) ; alarm . set State ( Alarm Condition . TERMINATE ) ; alarm . set Info ( STRING ) ; alarm . set Timestamp ( new Timestamp ( System . current Time Millis ( ) ) ) ; alarm Cache . notify Listeners Of Update ( alarm ) ; } catch ( Cache Element Not Found Exception e ) { alarm Report . set Warning ( STRING + alarm Id + STRING ) ; } }
@ Override public void remove Alarm ( final Long alarm Id , final Configuration Element Report alarm Report ) { try { Alarm Cache Object alarm = ( Alarm Cache Object ) alarm Cache . get Copy ( alarm Id ) ; alarm Config Transacted . do Remove Alarm ( alarm Id , alarm Report ) ; alarm Cache . remove ( alarm Id ) ; alarm . set State ( Alarm Condition . TERMINATE ) ; alarm . set Info ( STRING ) ; alarm . set Timestamp ( new Timestamp ( System . current Time Millis ( ) ) ) ; alarm Cache . notify Listeners Of Update ( alarm ) ; } catch ( Cache Element Not Found Exception e ) { alarm Report . set Warning ( STRING + alarm Id + STRING ) ; } }
@ Override public void remove Alarm ( final Long alarm Id , final Configuration Element Report alarm Report ) { try { Alarm Cache Object alarm = ( Alarm Cache Object ) alarm Cache . get Copy ( alarm Id ) ; alarm Config Transacted . do Remove Alarm ( alarm Id , alarm Report ) ; alarm Cache . remove ( alarm Id ) ; alarm . set State ( Alarm Condition . TERMINATE ) ; alarm . set Info ( STRING ) ; alarm . set Timestamp ( new Timestamp ( System . current Time Millis ( ) ) ) ; alarm Cache . notify Listeners Of Update ( alarm ) ; } catch ( Cache Element Not Found Exception e ) { alarm Report . set Warning ( STRING + alarm Id + STRING ) ; } }
@ Override public void remove Alarm ( final Long alarm Id , final Configuration Element Report alarm Report ) { try { Alarm Cache Object alarm = ( Alarm Cache Object ) alarm Cache . get Copy ( alarm Id ) ; alarm Config Transacted . do Remove Alarm ( alarm Id , alarm Report ) ; alarm Cache . remove ( alarm Id ) ; alarm . set State ( Alarm Condition . TERMINATE ) ; alarm . set Info ( STRING ) ; alarm . set Timestamp ( new Timestamp ( System . current Time Millis ( ) ) ) ; alarm Cache . notify Listeners Of Update ( alarm ) ; } catch ( Cache Element Not Found Exception e ) { alarm Report . set Warning ( STRING + alarm Id + STRING ) ; } }
@ Override public void remove Alarm ( final Long alarm Id , final Configuration Element Report alarm Report ) { try { Alarm Cache Object alarm = ( Alarm Cache Object ) alarm Cache . get Copy ( alarm Id ) ; alarm Config Transacted . do Remove Alarm ( alarm Id , alarm Report ) ; alarm Cache . remove ( alarm Id ) ; alarm . set State ( Alarm Condition . TERMINATE ) ; alarm . set Info ( STRING ) ; alarm . set Timestamp ( new Timestamp ( System . current Time Millis ( ) ) ) ; alarm Cache . notify Listeners Of Update ( alarm ) ; } catch ( Cache Element Not Found Exception e ) { alarm Report . set Warning ( STRING + alarm Id + STRING ) ; } }
@ Override public void remove Alarm ( final Long alarm Id , final Configuration Element Report alarm Report ) { try { Alarm Cache Object alarm = ( Alarm Cache Object ) alarm Cache . get Copy ( alarm Id ) ; alarm Config Transacted . do Remove Alarm ( alarm Id , alarm Report ) ; alarm Cache . remove ( alarm Id ) ; alarm . set State ( Alarm Condition . TERMINATE ) ; alarm . set Info ( STRING ) ; alarm . set Timestamp ( new Timestamp ( System . current Time Millis ( ) ) ) ; alarm Cache . notify Listeners Of Update ( alarm ) ; } catch ( Cache Element Not Found Exception e ) { alarm Report . set Warning ( STRING + alarm Id + STRING ) ; } }
@ Override public void remove Alarm ( final Long alarm Id , final Configuration Element Report alarm Report ) { try { Alarm Cache Object alarm = ( Alarm Cache Object ) alarm Cache . get Copy ( alarm Id ) ; alarm Config Transacted . do Remove Alarm ( alarm Id , alarm Report ) ; alarm Cache . remove ( alarm Id ) ; alarm . set State ( Alarm Condition . TERMINATE ) ; alarm . set Info ( STRING ) ; alarm . set Timestamp ( new Timestamp ( System . current Time Millis ( ) ) ) ; alarm Cache . notify Listeners Of Update ( alarm ) ; } catch ( Cache Element Not Found Exception e ) { alarm Report . set Warning ( STRING + alarm Id + STRING ) ; } }
public boolean has File ( Input File input File ) { return patch Position Mapping By File . contains Key ( get Path ( input File ) ) ; }
public Segment ( short start Code , short end Code , boolean has Map ) { this . end Code = ( NUM & end Code ) ; this . start Code = ( NUM & start Code ) ; this . has Map = has Map ; }
public static Task Builder start ( Base Plugin diorite Plugin , Runnable runnable ) { return new Task Builder ( diorite Plugin , runnable ) ; }
public static Map append Map To Map ( Map map To Add , Map to Map ) { if ( ( map To Add != null ) && ( to Map != null ) ) { Set key Set = map To Add . key Set ( ) ; Iterator key Iter = key Set . iterator ( ) ; while ( key Iter . has Next ( ) ) { String key = ( String ) key Iter . next ( ) ; Set values = ( Set ) map To Add . get ( key ) ; append Element To Map ( key , values , to Map ) ; } } return to Map ; }
private static int level ( long position ) { return NUM + Long . number Of Trailing Zeros ( position ) ; }
private static int level ( long position ) { return NUM + Long . number Of Trailing Zeros ( position ) ; }
public static void cancel ( ) { if ( fetch Exe != null ) { fetch Exe . shutdown Now ( ) ; fetch Exe = null ; } Bitmap Ajax Callback . clear Tasks ( ) ; }
public boolean required ( ) { return parameter Metadata . contains ( Metadata . REQUIRED ) ; }
protected void prepare Data Set ( ) { data Set 1 = Arrays . as List ( new String [ ] { STRING , STRING , STRING } ) ; data Set 2 = Arrays . as List ( new String [ ] { STRING , STRING , STRING } ) ; data Set 3 = Arrays . as List ( new String [ ] { STRING , STRING , STRING , STRING } ) ; }
public void sort ( Comparator < Fragment Data > comparator ) { check Transaction ( ) ; save Old Order ( ) ; if ( comparator == null ) { Collections . sort ( m Fragment Datas ) ; } else { Collections . sort ( this . m Fragment Datas , comparator ) ; } check Position Change ( ) ; }
public Arithmetic Condition ( String cond ) { String value ; int multiplier = NUM ; if ( cond . length ( ) < NUM ) { throw new Settings Error ( STRING + cond + STRING ) ; } operator = cond . char At ( NUM ) ; value = cond . substring ( NUM ) ; if ( value . ends With ( STRING ) ) { multiplier = NUM ; } else if ( value . ends With ( STRING ) ) { multiplier = NUM ; } if ( multiplier > NUM ) { value = value . substring ( NUM , value . length ( ) - NUM ) ; } if ( VALID OPERATORS . index Of ( operator ) == - NUM ) { throw new Settings Error ( STRING + cond + STRING + VALID OPERATORS ) ; } try { number = Double . parse Double ( value ) ; } catch ( Number Format Exception e ) { throw new Settings Error ( STRING + cond + STRING ) ; } number *= multiplier ; }
private long retrieve Row Count ( Database conn , Table table ) throws SQL Exception { return retrieve Row Count ( conn , table , - NUM , - NUM ) ; }
private List < Entry > reduce With Douglas Peuker ( List < Entry > entries , double epsilon ) { if ( epsilon <= NUM || entries . size ( ) < NUM ) { return entries ; } keep [ NUM ] = BOOL ; keep [ entries . size ( ) - NUM ] = BOOL ; algorithm Douglas Peucker ( entries , epsilon , NUM , entries . size ( ) - NUM ) ; List < Entry > reduced Entries = new Array List < > ( ) ; for ( int i = NUM ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { Entry cur Entry = entries . get ( i ) ; reduced Entries . add ( new Entry ( cur Entry . get Val ( ) , cur Entry . get X Index ( ) ) ) ; } } return reduced Entries ; }
private List < Entry > reduce With Douglas Peuker ( List < Entry > entries , double epsilon ) { if ( epsilon <= NUM || entries . size ( ) < NUM ) { return entries ; } keep [ NUM ] = BOOL ; keep [ entries . size ( ) - NUM ] = BOOL ; algorithm Douglas Peucker ( entries , epsilon , NUM , entries . size ( ) - NUM ) ; List < Entry > reduced Entries = new Array List < > ( ) ; for ( int i = NUM ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { Entry cur Entry = entries . get ( i ) ; reduced Entries . add ( new Entry ( cur Entry . get Val ( ) , cur Entry . get X Index ( ) ) ) ; } } return reduced Entries ; }
private void add Lenient ( String field Name , String value ) { names And Values . add ( field Name ) ; names And Values . add ( value . trim ( ) ) ; }
private void add Lenient ( String field Name , String value ) { names And Values . add ( field Name ) ; names And Values . add ( value . trim ( ) ) ; }
private void render Texture ( Texture texture , double center X , double center Y ) { Texture Coords tc = texture . get Image Tex Coords ( ) ; float tx 1 = tc . left ( ) ; float ty 1 = tc . top ( ) ; float tx 2 = tc . right ( ) ; float ty 2 = tc . bottom ( ) ; float half Width = quarter Value ( texture . get Width ( ) ) ; float half Height = quarter Value ( texture . get Height ( ) ) ; GL 2 gl = scene . gl ; texture . bind ( gl ) ; texture . enable ( gl ) ; Color foreground = scene . get Foreground Color ( ) ; gl . gl Color 4 f ( foreground . get Red ( ) / NUM , foreground . get Green ( ) / NUM , foreground . get Blue ( ) / NUM , foreground . get Alpha ( ) / NUM ) ; gl . gl Push Matrix ( ) ; float [ ] translate = GL Scene . P ( ( float ) center X , ( float ) center Y ) ; gl . gl Translatef ( translate [ NUM ] , translate [ NUM ] , translate [ NUM ] ) ; gl . gl Begin ( GL 2 . GL QUADS ) ; gl . gl Tex Coord 2 f ( tx 1 , ty 1 ) ; GL Scene . V ( gl , - half Width , half Height ) ; gl . gl Tex Coord 2 f ( tx 2 , ty 1 ) ; GL Scene . V ( gl , half Width , half Height ) ; gl . gl Tex Coord 2 f ( tx 2 , ty 2 ) ; GL Scene . V ( gl , half Width , - half Height ) ; gl . gl Tex Coord 2 f ( tx 1 , ty 2 ) ; GL Scene . V ( gl , - half Width , - half Height ) ; gl . gl End ( ) ; gl . gl Pop Matrix ( ) ; texture . disable ( gl ) ; }
public static Short to Short ( String str ) throws Page Exception { return Short . value Of ( to Short Value ( str ) ) ; }
public static Short to Short ( String str ) throws Page Exception { return Short . value Of ( to Short Value ( str ) ) ; }
public void select ( OM Graphic List list ) { if ( list != null && ! list . is Empty ( ) ) { OM Graphic omg = list . get OM Graphic At ( NUM ) ; Drawing Tool dt = get Drawing Tool ( ) ; if ( dt != null && dt . can Edit ( omg . get Class ( ) ) ) { dt . set Behavior Mask ( OM Drawing Tool . QUICK CHANGE BEHAVIOR MASK ) ; if ( dt . edit ( omg , this ) == null ) { fire Request Info Line ( STRING ) ; } } } }
public void select ( OM Graphic List list ) { if ( list != null && ! list . is Empty ( ) ) { OM Graphic omg = list . get OM Graphic At ( NUM ) ; Drawing Tool dt = get Drawing Tool ( ) ; if ( dt != null && dt . can Edit ( omg . get Class ( ) ) ) { dt . set Behavior Mask ( OM Drawing Tool . QUICK CHANGE BEHAVIOR MASK ) ; if ( dt . edit ( omg , this ) == null ) { fire Request Info Line ( STRING ) ; } } } }
@ Override protected void add Event Listener ( Node Impl node , String type , Event Listener listener , boolean use Capture ) { if ( type == null || type . length ( ) == NUM || listener == null ) return ; remove Event Listener ( node , type , listener , use Capture ) ; Vector node Listeners = get Event Listeners ( node ) ; if ( node Listeners == null ) { node Listeners = new Vector ( ) ; set Event Listeners ( node , node Listeners ) ; } node Listeners . add Element ( new L Entry ( type , listener , use Capture ) ) ; L Count lc = L Count . lookup ( type ) ; if ( use Capture ) { ++ lc . captures ; ++ lc . total ; } else { ++ lc . bubbles ; ++ lc . total ; } }
void reset ( ) { if ( version != - NUM ) { throw new Runtime Exception ( STRING ) ; } data . reset ( ) ; }
void reset ( ) { if ( version != - NUM ) { throw new Runtime Exception ( STRING ) ; } data . reset ( ) ; }
void reset ( ) { if ( version != - NUM ) { throw new Runtime Exception ( STRING ) ; } data . reset ( ) ; }
void reset ( ) { if ( version != - NUM ) { throw new Runtime Exception ( STRING ) ; } data . reset ( ) ; }
void reset ( ) { if ( version != - NUM ) { throw new Runtime Exception ( STRING ) ; } data . reset ( ) ; }
public String mailbox UTF 7 ( ) throws Decoding Exception { String mailbox = astring ( ) ; if ( mailbox . equals Ignore Case ( Imap Constants . INBOX NAME ) ) { return Imap Constants . INBOX NAME ; } else { return mailbox ; } }
public String mailbox UTF 7 ( ) throws Decoding Exception { String mailbox = astring ( ) ; if ( mailbox . equals Ignore Case ( Imap Constants . INBOX NAME ) ) { return Imap Constants . INBOX NAME ; } else { return mailbox ; } }
public String mailbox UTF 7 ( ) throws Decoding Exception { String mailbox = astring ( ) ; if ( mailbox . equals Ignore Case ( Imap Constants . INBOX NAME ) ) { return Imap Constants . INBOX NAME ; } else { return mailbox ; } }
public String mailbox UTF 7 ( ) throws Decoding Exception { String mailbox = astring ( ) ; if ( mailbox . equals Ignore Case ( Imap Constants . INBOX NAME ) ) { return Imap Constants . INBOX NAME ; } else { return mailbox ; } }
public String mailbox UTF 7 ( ) throws Decoding Exception { String mailbox = astring ( ) ; if ( mailbox . equals Ignore Case ( Imap Constants . INBOX NAME ) ) { return Imap Constants . INBOX NAME ; } else { return mailbox ; } }
public String mailbox UTF 7 ( ) throws Decoding Exception { String mailbox = astring ( ) ; if ( mailbox . equals Ignore Case ( Imap Constants . INBOX NAME ) ) { return Imap Constants . INBOX NAME ; } else { return mailbox ; } }
public String mailbox UTF 7 ( ) throws Decoding Exception { String mailbox = astring ( ) ; if ( mailbox . equals Ignore Case ( Imap Constants . INBOX NAME ) ) { return Imap Constants . INBOX NAME ; } else { return mailbox ; } }
@ Override public void key Released ( Key Event e ) { synchronized ( key Lock ) { keys Down . remove ( e . get Key Code ( ) ) ; } for ( Draw Listener listener : listeners ) listener . key Pressed ( e . get Key Code ( ) ) ; }
private void create Default Managed Object ( Managed Object Definition < ? , ? > d , Managed Object < ? > child , Default Managed Object < ? , ? > dmo ) { for ( Property Definition < ? > pd : d . get All Property Definitions ( ) ) { set Property Values ( child , pd , dmo ) ; } try { child . commit ( ) ; } catch ( Managed Object Already Exists Exception e ) { moaee = e ; } catch ( Missing Mandatory Properties Exception e ) { mmpe = e ; } catch ( Concurrent Modification Exception e ) { cme = e ; } catch ( Operation Rejected Exception e ) { ore = e ; } catch ( Ldap Exception e ) { ere = e ; } }
public static String replace ( String a , String b , String c ) { String Buffer result = new String Buffer ( c . length ( ) ) ; int i = NUM ; int j = c . index Of ( a ) ; while ( j >= i ) { result . append ( c . substring ( i , j ) ) ; result . append ( b ) ; i = j + a . length ( ) ; j = c . index Of ( a , i ) ; } result . append ( c . substring ( i , c . length ( ) ) ) ; return result . to String ( ) ; }
public void stop ( ) { for ( Gondola g : gondolas ) { boolean status = g . stop ( ) ; if ( ! status ) { logger . warn ( STRING + g . get Host Id ( ) ) ; } } extras . clear ( ) ; members . clear ( ) ; }
public void stop ( ) { for ( Gondola g : gondolas ) { boolean status = g . stop ( ) ; if ( ! status ) { logger . warn ( STRING + g . get Host Id ( ) ) ; } } extras . clear ( ) ; members . clear ( ) ; }
public Postgres Full Pruned Block Store ( Network Parameters params , int full Store Depth , String hostname , String db Name , String username , String password ) throws Block Store Exception { this . params = params ; this . full Store Depth = full Store Depth ; connection URL = STRING + hostname + STRING + db Name ; this . username = username ; this . password = password ; conn = new Thread Local < Connection > ( ) ; all Connections = new Linked List < Connection > ( ) ; try { Class . for Name ( driver ) ; log . info ( driver + STRING ) ; } catch ( java . lang . Class Not Found Exception e ) { log . error ( STRING , e ) ; } maybe Connect ( ) ; try { if ( ! table Exists ( STRING ) ) create Tables ( ) ; init From Database ( ) ; } catch ( SQL Exception e ) { throw new Block Store Exception ( e ) ; } }
@ Suppress Warnings ( STRING ) protected void write To Terminal ( byte ... bytes ) throws IO Exception { synchronized ( terminal Output ) { terminal Output . write ( bytes ) ; } }
@ Suppress Warnings ( STRING ) protected void write To Terminal ( byte ... bytes ) throws IO Exception { synchronized ( terminal Output ) { terminal Output . write ( bytes ) ; } }
public void disconnect ( ) { connected = BOOL ; synchronized ( conn Lost Wait ) { conn Lost Wait . notify ( ) ; } if ( mqtt != null ) { try { mqtt . disconnect ( ) ; } catch ( Exception ex ) { set Title Text ( STRING ) ; ex . print Stack Trace ( ) ; System . exit ( NUM ) ; } } if ( led . is Flashing ( ) ) { led . set Flash ( ) ; } led . set Red ( ) ; set Connected ( BOOL ) ; synchronized ( this ) { write Logln ( STRING ) ; } }
protected void mark First Time ( Element elem ) { String elem Name = elem . get Name ( ) ; if ( elem Name . equals ( STRING ) ) { seen Html = BOOL ; } else if ( elem Name . equals ( STRING ) ) { seen Head = BOOL ; } else if ( elem Name . equals ( STRING ) ) { if ( buf . length == NUM ) { char [ ] new Buf = new char [ NUM ] ; new Buf [ NUM ] = buf [ NUM ] ; buf = new Buf ; } seen Body = BOOL ; } }
protected void mark First Time ( Element elem ) { String elem Name = elem . get Name ( ) ; if ( elem Name . equals ( STRING ) ) { seen Html = BOOL ; } else if ( elem Name . equals ( STRING ) ) { seen Head = BOOL ; } else if ( elem Name . equals ( STRING ) ) { if ( buf . length == NUM ) { char [ ] new Buf = new char [ NUM ] ; new Buf [ NUM ] = buf [ NUM ] ; buf = new Buf ; } seen Body = BOOL ; } }
private static void flip Coordinates ( final Phylo Tree View tree View , final SIDE root Side ) { final Phylo Tree tree = tree View . get Phylo Tree ( ) ; for ( Node v = tree . get First Node ( ) ; v != null ; v = tree . get Next Node ( v ) ) { final Point 2 D loc = tree View . get Location ( v ) ; switch ( root Side ) { case TOP : tree View . set Location ( v , loc . get Y ( ) , loc . get X ( ) ) ; break ; case BOTTOM : tree View . set Location ( v , loc . get Y ( ) , - loc . get X ( ) ) ; break ; case RIGHT : tree View . set Location ( v , - loc . get X ( ) , loc . get Y ( ) ) ; break ; default : case LEFT : break ; } } }
private void map Old Frames To New ( int isolate Id ) { Array List < D Stack Context > previous Frames = null ; Array List < D Stack Context > frames = null ; Map < Long , D Value > previous Values = null ; previous Frames = get Isolate State ( isolate Id ) . m previous Frames ; frames = get Isolate State ( isolate Id ) . m frames ; previous Values = get Isolate State ( isolate Id ) . m previous Values ; int old Size = previous Frames . size ( ) ; int new Size = frames . size ( ) ; D Value [ ] old Frames = new D Value [ old Size ] ; for ( int depth = NUM ; depth < old Size ; depth ++ ) { old Frames [ depth ] = ( D Value ) previous Values . remove ( Value . BASE ID - depth ) ; } int old Depth = old Size - NUM ; int new Depth = new Size - NUM ; while ( old Depth >= NUM && new Depth >= NUM ) { D Stack Context old Frame = previous Frames . get ( old Depth ) ; D Stack Context new Frame = frames . get ( new Depth ) ; if ( old Frame != null && new Frame != null ) { if ( strings Equal ( old Frame . get Call Signature ( ) , new Frame . get Call Signature ( ) ) ) { D Value frame = old Frames [ old Depth ] ; if ( frame != null ) previous Values . put ( Value . BASE ID - new Depth , frame ) ; } } old Depth -- ; new Depth -- ; } }
private void map Old Frames To New ( int isolate Id ) { Array List < D Stack Context > previous Frames = null ; Array List < D Stack Context > frames = null ; Map < Long , D Value > previous Values = null ; previous Frames = get Isolate State ( isolate Id ) . m previous Frames ; frames = get Isolate State ( isolate Id ) . m frames ; previous Values = get Isolate State ( isolate Id ) . m previous Values ; int old Size = previous Frames . size ( ) ; int new Size = frames . size ( ) ; D Value [ ] old Frames = new D Value [ old Size ] ; for ( int depth = NUM ; depth < old Size ; depth ++ ) { old Frames [ depth ] = ( D Value ) previous Values . remove ( Value . BASE ID - depth ) ; } int old Depth = old Size - NUM ; int new Depth = new Size - NUM ; while ( old Depth >= NUM && new Depth >= NUM ) { D Stack Context old Frame = previous Frames . get ( old Depth ) ; D Stack Context new Frame = frames . get ( new Depth ) ; if ( old Frame != null && new Frame != null ) { if ( strings Equal ( old Frame . get Call Signature ( ) , new Frame . get Call Signature ( ) ) ) { D Value frame = old Frames [ old Depth ] ; if ( frame != null ) previous Values . put ( Value . BASE ID - new Depth , frame ) ; } } old Depth -- ; new Depth -- ; } }
private void map Old Frames To New ( int isolate Id ) { Array List < D Stack Context > previous Frames = null ; Array List < D Stack Context > frames = null ; Map < Long , D Value > previous Values = null ; previous Frames = get Isolate State ( isolate Id ) . m previous Frames ; frames = get Isolate State ( isolate Id ) . m frames ; previous Values = get Isolate State ( isolate Id ) . m previous Values ; int old Size = previous Frames . size ( ) ; int new Size = frames . size ( ) ; D Value [ ] old Frames = new D Value [ old Size ] ; for ( int depth = NUM ; depth < old Size ; depth ++ ) { old Frames [ depth ] = ( D Value ) previous Values . remove ( Value . BASE ID - depth ) ; } int old Depth = old Size - NUM ; int new Depth = new Size - NUM ; while ( old Depth >= NUM && new Depth >= NUM ) { D Stack Context old Frame = previous Frames . get ( old Depth ) ; D Stack Context new Frame = frames . get ( new Depth ) ; if ( old Frame != null && new Frame != null ) { if ( strings Equal ( old Frame . get Call Signature ( ) , new Frame . get Call Signature ( ) ) ) { D Value frame = old Frames [ old Depth ] ; if ( frame != null ) previous Values . put ( Value . BASE ID - new Depth , frame ) ; } } old Depth -- ; new Depth -- ; } }
private void map Old Frames To New ( int isolate Id ) { Array List < D Stack Context > previous Frames = null ; Array List < D Stack Context > frames = null ; Map < Long , D Value > previous Values = null ; previous Frames = get Isolate State ( isolate Id ) . m previous Frames ; frames = get Isolate State ( isolate Id ) . m frames ; previous Values = get Isolate State ( isolate Id ) . m previous Values ; int old Size = previous Frames . size ( ) ; int new Size = frames . size ( ) ; D Value [ ] old Frames = new D Value [ old Size ] ; for ( int depth = NUM ; depth < old Size ; depth ++ ) { old Frames [ depth ] = ( D Value ) previous Values . remove ( Value . BASE ID - depth ) ; } int old Depth = old Size - NUM ; int new Depth = new Size - NUM ; while ( old Depth >= NUM && new Depth >= NUM ) { D Stack Context old Frame = previous Frames . get ( old Depth ) ; D Stack Context new Frame = frames . get ( new Depth ) ; if ( old Frame != null && new Frame != null ) { if ( strings Equal ( old Frame . get Call Signature ( ) , new Frame . get Call Signature ( ) ) ) { D Value frame = old Frames [ old Depth ] ; if ( frame != null ) previous Values . put ( Value . BASE ID - new Depth , frame ) ; } } old Depth -- ; new Depth -- ; } }
private void map Old Frames To New ( int isolate Id ) { Array List < D Stack Context > previous Frames = null ; Array List < D Stack Context > frames = null ; Map < Long , D Value > previous Values = null ; previous Frames = get Isolate State ( isolate Id ) . m previous Frames ; frames = get Isolate State ( isolate Id ) . m frames ; previous Values = get Isolate State ( isolate Id ) . m previous Values ; int old Size = previous Frames . size ( ) ; int new Size = frames . size ( ) ; D Value [ ] old Frames = new D Value [ old Size ] ; for ( int depth = NUM ; depth < old Size ; depth ++ ) { old Frames [ depth ] = ( D Value ) previous Values . remove ( Value . BASE ID - depth ) ; } int old Depth = old Size - NUM ; int new Depth = new Size - NUM ; while ( old Depth >= NUM && new Depth >= NUM ) { D Stack Context old Frame = previous Frames . get ( old Depth ) ; D Stack Context new Frame = frames . get ( new Depth ) ; if ( old Frame != null && new Frame != null ) { if ( strings Equal ( old Frame . get Call Signature ( ) , new Frame . get Call Signature ( ) ) ) { D Value frame = old Frames [ old Depth ] ; if ( frame != null ) previous Values . put ( Value . BASE ID - new Depth , frame ) ; } } old Depth -- ; new Depth -- ; } }
private void map Old Frames To New ( int isolate Id ) { Array List < D Stack Context > previous Frames = null ; Array List < D Stack Context > frames = null ; Map < Long , D Value > previous Values = null ; previous Frames = get Isolate State ( isolate Id ) . m previous Frames ; frames = get Isolate State ( isolate Id ) . m frames ; previous Values = get Isolate State ( isolate Id ) . m previous Values ; int old Size = previous Frames . size ( ) ; int new Size = frames . size ( ) ; D Value [ ] old Frames = new D Value [ old Size ] ; for ( int depth = NUM ; depth < old Size ; depth ++ ) { old Frames [ depth ] = ( D Value ) previous Values . remove ( Value . BASE ID - depth ) ; } int old Depth = old Size - NUM ; int new Depth = new Size - NUM ; while ( old Depth >= NUM && new Depth >= NUM ) { D Stack Context old Frame = previous Frames . get ( old Depth ) ; D Stack Context new Frame = frames . get ( new Depth ) ; if ( old Frame != null && new Frame != null ) { if ( strings Equal ( old Frame . get Call Signature ( ) , new Frame . get Call Signature ( ) ) ) { D Value frame = old Frames [ old Depth ] ; if ( frame != null ) previous Values . put ( Value . BASE ID - new Depth , frame ) ; } } old Depth -- ; new Depth -- ; } }
protected void add To GUI ( J Panel gui , Abstract Button b , String cmd ) { b . set Action Command ( cmd ) ; b . add Action Listener ( this ) ; gui . add ( b ) ; }
private void internal Add Head ( final Message Reference ref ) { queue Memory Size . add And Get ( ref . get Message Memory Estimate ( ) ) ; ref Added ( ref ) ; int priority = get Priority ( ref ) ; message References . add Head ( ref , priority ) ; }
private void internal Add Head ( final Message Reference ref ) { queue Memory Size . add And Get ( ref . get Message Memory Estimate ( ) ) ; ref Added ( ref ) ; int priority = get Priority ( ref ) ; message References . add Head ( ref , priority ) ; }
private void internal Add Head ( final Message Reference ref ) { queue Memory Size . add And Get ( ref . get Message Memory Estimate ( ) ) ; ref Added ( ref ) ; int priority = get Priority ( ref ) ; message References . add Head ( ref , priority ) ; }
private void internal Add Head ( final Message Reference ref ) { queue Memory Size . add And Get ( ref . get Message Memory Estimate ( ) ) ; ref Added ( ref ) ; int priority = get Priority ( ref ) ; message References . add Head ( ref , priority ) ; }
private void internal Add Head ( final Message Reference ref ) { queue Memory Size . add And Get ( ref . get Message Memory Estimate ( ) ) ; ref Added ( ref ) ; int priority = get Priority ( ref ) ; message References . add Head ( ref , priority ) ; }
@ Suppress Warnings ( STRING ) public List < Product > read ( List < Long > ids ) { if ( ( ids == null ) || ids . is Empty ( ) ) return Immutable List . of ( ) ; String facet = STRING ; String logic op = STRING ; for ( Long id : ids ) { facet += STRING + logic op + STRING + id ; logic op = STRING ; } return ( List < Product > ) find ( STRING + entity Class . get Name ( ) + STRING + facet ) ; }
@ Suppress Warnings ( STRING ) public List < Product > read ( List < Long > ids ) { if ( ( ids == null ) || ids . is Empty ( ) ) return Immutable List . of ( ) ; String facet = STRING ; String logic op = STRING ; for ( Long id : ids ) { facet += STRING + logic op + STRING + id ; logic op = STRING ; } return ( List < Product > ) find ( STRING + entity Class . get Name ( ) + STRING + facet ) ; }
public Dexlib Wrapper ( File input Dex File ) { this . input Dex File = input Dex File ; }
public Dexlib Wrapper ( File input Dex File ) { this . input Dex File = input Dex File ; }
public Object remove Property ( final URI uri , final String prop ) { return remove Property ( uri , factory . to Property URI ( prop ) ) ; }
public D Subject Alternative Name ( J Dialog parent , byte [ ] value ) throws IO Exception { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
protected abstract void perform Deployer Action On Single Deployable ( org . codehaus . cargo . container . deployer . Deployer deployer , org . codehaus . cargo . container . deployable . Deployable deployable , org . codehaus . cargo . container . deployer . Deployable Monitor monitor ) ;
protected abstract void perform Deployer Action On Single Deployable ( org . codehaus . cargo . container . deployer . Deployer deployer , org . codehaus . cargo . container . deployable . Deployable deployable , org . codehaus . cargo . container . deployer . Deployable Monitor monitor ) ;
public void lock Row Add ( Array List < Row > rows ) { if ( state == FOUND ) { rows . add ( get ( ) ) ; } }
public void draw Calendar ( ) { draw Calendar ( displayed Year Month ) ; }
public void draw Calendar ( ) { draw Calendar ( displayed Year Month ) ; }
public void draw Calendar ( ) { draw Calendar ( displayed Year Month ) ; }
public void draw Calendar ( ) { draw Calendar ( displayed Year Month ) ; }
public void draw Calendar ( ) { draw Calendar ( displayed Year Month ) ; }
public void draw Calendar ( ) { draw Calendar ( displayed Year Month ) ; }
public void draw Calendar ( ) { draw Calendar ( displayed Year Month ) ; }
public void draw Calendar ( ) { draw Calendar ( displayed Year Month ) ; }
public void draw Calendar ( ) { draw Calendar ( displayed Year Month ) ; }
public void remove Layer ( int index ) { List < Layer > current Layers = get Layer List ( ) ; try { current Layers . remove ( index ) ; set Layer List ( current Layers ) ; } catch ( Index Out Of Bounds Exception ioobe ) { } }
protected Route Calculator create Route Calculator ( ) { return new Route Calculator ( ) ; }
protected Route Calculator create Route Calculator ( ) { return new Route Calculator ( ) ; }
public static void init ( ) { init ( System . get Properties ( ) ) ; }
public static void init ( ) { init ( System . get Properties ( ) ) ; }
protected void request Update ( boolean force ) { if ( Log Configuration . logging Is Enabled ( ) ) { logger . log ( Level . INFO , STRING ) ; } if ( force ) { Screen . reload ( ) ; } else { ui Handler . confirm Reload Page ( ) ; } }
protected void request Update ( boolean force ) { if ( Log Configuration . logging Is Enabled ( ) ) { logger . log ( Level . INFO , STRING ) ; } if ( force ) { Screen . reload ( ) ; } else { ui Handler . confirm Reload Page ( ) ; } }
protected void request Update ( boolean force ) { if ( Log Configuration . logging Is Enabled ( ) ) { logger . log ( Level . INFO , STRING ) ; } if ( force ) { Screen . reload ( ) ; } else { ui Handler . confirm Reload Page ( ) ; } }
protected void request Update ( boolean force ) { if ( Log Configuration . logging Is Enabled ( ) ) { logger . log ( Level . INFO , STRING ) ; } if ( force ) { Screen . reload ( ) ; } else { ui Handler . confirm Reload Page ( ) ; } }
public static String current Default Formatted Time Stamp ( ) { try { Simple Date Format sdf = new Simple Date Format ( DEFAULT TIME STAMP FORMAT ) ; final String formatted Time Stamp = sdf . format ( new Date ( ) ) ; return formatted Time Stamp ; } catch ( Illegal Argument Exception e ) { Simple Date Format sdf = new Simple Date Format ( SAFE TIME STAMP FORMAT ) ; final String formatted Time Stamp = sdf . format ( new Date ( ) ) ; return formatted Time Stamp ; } }
public static String current Default Formatted Time Stamp ( ) { try { Simple Date Format sdf = new Simple Date Format ( DEFAULT TIME STAMP FORMAT ) ; final String formatted Time Stamp = sdf . format ( new Date ( ) ) ; return formatted Time Stamp ; } catch ( Illegal Argument Exception e ) { Simple Date Format sdf = new Simple Date Format ( SAFE TIME STAMP FORMAT ) ; final String formatted Time Stamp = sdf . format ( new Date ( ) ) ; return formatted Time Stamp ; } }
public static String current Default Formatted Time Stamp ( ) { try { Simple Date Format sdf = new Simple Date Format ( DEFAULT TIME STAMP FORMAT ) ; final String formatted Time Stamp = sdf . format ( new Date ( ) ) ; return formatted Time Stamp ; } catch ( Illegal Argument Exception e ) { Simple Date Format sdf = new Simple Date Format ( SAFE TIME STAMP FORMAT ) ; final String formatted Time Stamp = sdf . format ( new Date ( ) ) ; return formatted Time Stamp ; } }
protected Flashing Icon ( Icon icon ) { this . icon = icon ; Dimension d = new Dimension ( icon . get Icon Width ( ) , icon . get Icon Height ( ) ) ; set Minimum Size ( d ) ; set Maximum Size ( d ) ; set Preferred Size ( d ) ; set Visible ( BOOL ) ; add Mouse Listener ( this ) ; }
public String to String ( ) { String Builder buf = new String Builder ( ) ; buf . append ( STRING ) ; Collection < String > factors = connectivity . key Set ( ) ; for ( String factor : factors ) { buf . append ( STRING ) ; buf . append ( factor ) ; buf . append ( STRING ) ; Collection < Lagged Factor > edges = connectivity . get ( factor ) ; for ( Lagged Factor edge : edges ) { buf . append ( STRING ) ; buf . append ( edge ) ; } } buf . append ( STRING ) ; return buf . to String ( ) ; }
public static String exception Stack Trace To String ( Exception ex ) { String Writer errors = new String Writer ( ) ; ex . print Stack Trace ( new Print Writer ( errors ) ) ; return errors . to String ( ) ; }
protected void write Raw ( Char Sequence seq , Char Buf buffer ) { if ( seq != null ) { buffer . add ( seq . to String ( ) ) ; } }
protected void write Raw ( Char Sequence seq , Char Buf buffer ) { if ( seq != null ) { buffer . add ( seq . to String ( ) ) ; } }
protected void write Raw ( Char Sequence seq , Char Buf buffer ) { if ( seq != null ) { buffer . add ( seq . to String ( ) ) ; } }
public T image ( File file , boolean mem Cache , int target Width , Bitmap Ajax Callback callback ) { if ( callback == null ) callback = new Bitmap Ajax Callback ( ) ; callback . file ( file ) ; String url = null ; if ( file != null ) url = file . get Absolute Path ( ) ; return image ( url , mem Cache , BOOL , target Width , NUM , callback ) ; }
public T image ( File file , boolean mem Cache , int target Width , Bitmap Ajax Callback callback ) { if ( callback == null ) callback = new Bitmap Ajax Callback ( ) ; callback . file ( file ) ; String url = null ; if ( file != null ) url = file . get Absolute Path ( ) ; return image ( url , mem Cache , BOOL , target Width , NUM , callback ) ; }
public static Api Method process Method ( Api Service api Service , Method Doc method , String base URL , boolean is Data Service ) { try { Api Method api Method Desc = new Api Method ( ) ; api Method Desc . java Method Name = method . name ( ) ; api Method Desc . api Service = api Service ; api Method Desc . is Data Service = is Data Service ; add Path ( method , api Method Desc , base URL ) ; add Http Method ( method , api Method Desc ) ; add Description ( method , api Method Desc ) ; add Brief Description ( method , api Method Desc ) ; add Response Description ( method , api Method Desc ) ; add Prerequisites ( method , api Method Desc ) ; add Security ( method , api Method Desc ) ; if ( is Data Service ) { add Data Service Information ( method , api Method Desc ) ; } else { add Inputs ( method , api Method Desc ) ; } add Output ( method , api Method Desc ) ; add Query Parameters ( method , api Method Desc ) ; add Path Parameters ( method , api Method Desc ) ; add Examples ( api Method Desc ) ; add Deprecated ( method , api Method Desc ) ; return api Method Desc ; } catch ( Exception e ) { throw new Runtime Exception ( STRING + api Service . get Fq Java Class Name ( ) + STRING + method . name ( ) , e ) ; } }
private void stretch View Horizontally ( View view , int cross Size ) { Layout Params lp = ( Layout Params ) view . get Layout Params ( ) ; int new Width = cross Size - lp . left Margin - lp . right Margin ; new Width = Math . max ( new Width , NUM ) ; view . measure ( Measure Spec . make Measure Spec ( new Width , Measure Spec . EXACTLY ) , Measure Spec . make Measure Spec ( view . get Measured Height ( ) , Measure Spec . EXACTLY ) ) ; }
private void stretch View Horizontally ( View view , int cross Size ) { Layout Params lp = ( Layout Params ) view . get Layout Params ( ) ; int new Width = cross Size - lp . left Margin - lp . right Margin ; new Width = Math . max ( new Width , NUM ) ; view . measure ( Measure Spec . make Measure Spec ( new Width , Measure Spec . EXACTLY ) , Measure Spec . make Measure Spec ( view . get Measured Height ( ) , Measure Spec . EXACTLY ) ) ; }
@ Visible For Testing static String escape Sql String ( String string ) { return string . replace All ( STRING , STRING ) ; }
public static Output Stream left Shift ( Process self , byte [ ] value ) throws IO Exception { return IO Groovy Methods . left Shift ( self . get Output Stream ( ) , value ) ; }
Https Client ( SSL Socket Factory sf , URL url , String proxy Host , int proxy Port , int connect Timeout ) throws IO Exception { this ( sf , url , ( proxy Host == null ? null : Http Client . new Http Proxy ( proxy Host , proxy Port , STRING ) ) , connect Timeout ) ; }
public Economy Concurrent Hash Map ( Map < ? extends K , ? extends V > m , I Hash Entry Handler < K , V > handler ) { this ( Math . max ( ( int ) ( m . size ( ) / DEFAULT LOAD FACTOR ) + NUM , DEFAULT INITIAL CAPACITY ) , DEFAULT LOAD FACTOR , DEFAULT CONCURRENCY LEVEL , handler ) ; put All ( m ) ; }
@ Override public synchronized void remove Instance Listener ( Instance Listener tsl ) { m instance Listeners . remove ( tsl ) ; }
public static < T > List < T > to List ( T obj 1 , T obj 2 , T obj 3 , T obj 4 , T obj 5 , T obj 6 ) { List < T > list = new Linked List < T > ( ) ; list . add ( obj 1 ) ; list . add ( obj 2 ) ; list . add ( obj 3 ) ; list . add ( obj 4 ) ; list . add ( obj 5 ) ; list . add ( obj 6 ) ; return list ; }
public Kernel Density Function ( Collection < double [ ] > points ) { this ( points . to Array ( new double [ points . size ( ) ] [ ] ) ) ; }
@ Deprecated public boolean is Tool Effective ( String type , int level ) { String t = get Harvest Tool ( ) ; return ( t == null && type == null ) || type . equals ( t ) ; }
private void digits To Words ( String token Val ) { Feature Set feature Set = token Item . get Features ( ) ; String nsw = STRING ; if ( feature Set . is Present ( STRING ) ) { nsw = feature Set . get String ( STRING ) ; } if ( nsw . equals ( STRING ) ) { Number Expander . expand ID ( token Val , word Relation ) ; } else { String r Name = feature Set . get String ( STRING ) ; String digits Type = null ; if ( token Val . equals ( r Name ) ) { digits Type = ( String ) cart . interpret ( token Item ) ; } else { feature Set . set String ( STRING , token Val ) ; digits Type = ( String ) cart . interpret ( token Item ) ; feature Set . set String ( STRING , r Name ) ; } if ( digits Type . equals ( STRING ) ) { Number Expander . expand Ordinal ( token Val , word Relation ) ; } else if ( digits Type . equals ( STRING ) ) { Number Expander . expand Digits ( token Val , word Relation ) ; } else if ( digits Type . equals ( STRING ) ) { Number Expander . expand ID ( token Val , word Relation ) ; } else { Number Expander . expand Number ( token Val , word Relation ) ; } } }
public static Font create Bitmap Font ( String name , Image bitmap , int [ ] cut Offsets , int [ ] char Width , String charsets ) { Font f = create Bitmap Font ( bitmap , cut Offsets , char Width , charsets ) ; bitmap Cache . put ( name , f ) ; return f ; }
public static Font create Bitmap Font ( String name , Image bitmap , int [ ] cut Offsets , int [ ] char Width , String charsets ) { Font f = create Bitmap Font ( bitmap , cut Offsets , char Width , charsets ) ; bitmap Cache . put ( name , f ) ; return f ; }
public static Font create Bitmap Font ( String name , Image bitmap , int [ ] cut Offsets , int [ ] char Width , String charsets ) { Font f = create Bitmap Font ( bitmap , cut Offsets , char Width , charsets ) ; bitmap Cache . put ( name , f ) ; return f ; }
public static synchronized String generate Segment Name ( ) { try { Thread . sleep ( NUM ) ; } catch ( Throwable t ) { } return sdf . format ( new Date ( System . current Time Millis ( ) ) ) ; }
public Element sign XML ( Document doc , String cert Alias , String algorithm , String id Attr Name , String id , boolean include Cert , String xpath ) throws XML Signature Exception { return sign XML Using Key Pass ( doc , cert Alias , null , algorithm , id Attr Name , id , include Cert , xpath ) ; }
public Storage ( ) { this ( new File ( get Temporary Storage Directory String ( ) ) ) ; }
public Object touch ( int row ) throws Page Exception { Object o = query . get At ( column Name , row , Null Support Helper . NULL ( ) ) ; if ( o != Null Support Helper . NULL ( ) ) return o ; return query . set At ( column Name , row , new Struct Impl ( ) ) ; }
public int compare Swapped To ( Double Int Pair other ) { int fdiff = this . second - other . second ; if ( fdiff != NUM ) { return fdiff ; } return Double . compare ( this . second , other . second ) ; }
private void align Labels ( ) { final int height = m selector Label . get Preferred Size ( ) . height ; int width = m selector Label . get Preferred Size ( ) . width ; if ( m editor != null ) { final int label Width = m editor . get Label Width ( ) ; if ( width < label Width ) { width = label Width ; } else { m editor . set Label Width ( width ) ; } } final Dimension dimension = new Dimension ( width , height ) ; m selector Label . set Preferred Size ( dimension ) ; m selector Label . set Size ( dimension ) ; }
private void align Labels ( ) { final int height = m selector Label . get Preferred Size ( ) . height ; int width = m selector Label . get Preferred Size ( ) . width ; if ( m editor != null ) { final int label Width = m editor . get Label Width ( ) ; if ( width < label Width ) { width = label Width ; } else { m editor . set Label Width ( width ) ; } } final Dimension dimension = new Dimension ( width , height ) ; m selector Label . set Preferred Size ( dimension ) ; m selector Label . set Size ( dimension ) ; }
private int reverse Align For Bidi ( Component c , int align ) { if ( c . is RTL ( ) ) { switch ( align ) { case Component . RIGHT : return Component . LEFT ; case Component . LEFT : return Component . RIGHT ; } } return align ; }
private int reverse Align For Bidi ( Component c , int align ) { if ( c . is RTL ( ) ) { switch ( align ) { case Component . RIGHT : return Component . LEFT ; case Component . LEFT : return Component . RIGHT ; } } return align ; }
public static Collection < String > node Id 8 s ( @ Nullable Collection < ? extends Cluster Node > nodes ) { if ( nodes == null || nodes . is Empty ( ) ) return Collections . empty List ( ) ; return F . view Read Only ( nodes , NODE 2 ID 8 ) ; }
public static Collection < String > node Id 8 s ( @ Nullable Collection < ? extends Cluster Node > nodes ) { if ( nodes == null || nodes . is Empty ( ) ) return Collections . empty List ( ) ; return F . view Read Only ( nodes , NODE 2 ID 8 ) ; }
public static Collection < String > node Id 8 s ( @ Nullable Collection < ? extends Cluster Node > nodes ) { if ( nodes == null || nodes . is Empty ( ) ) return Collections . empty List ( ) ; return F . view Read Only ( nodes , NODE 2 ID 8 ) ; }
public static Collection < String > node Id 8 s ( @ Nullable Collection < ? extends Cluster Node > nodes ) { if ( nodes == null || nodes . is Empty ( ) ) return Collections . empty List ( ) ; return F . view Read Only ( nodes , NODE 2 ID 8 ) ; }
public static Collection < String > node Id 8 s ( @ Nullable Collection < ? extends Cluster Node > nodes ) { if ( nodes == null || nodes . is Empty ( ) ) return Collections . empty List ( ) ; return F . view Read Only ( nodes , NODE 2 ID 8 ) ; }
public static void write UINT 32 ( long number , Output Stream out ) throws IO Exception { if ( number < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } byte [ ] to Write = new byte [ NUM ] ; for ( int i = NUM ; i <= NUM ; i += NUM ) { to Write [ i / NUM ] = ( byte ) ( ( number > > i ) & NUM ) ; } out . write ( to Write ) ; }
public void run ( ) { Cluster Resource Notification notification ; int warning Count = NUM ; do { try { notification = notifications . take ( ) ; notify Listeners ( notification ) ; } catch ( Interrupted Exception i ) { logger . warn ( STRING ) ; warning Count ++ ; } catch ( Resource Notification Exception r ) { logger . warn ( STRING + r ) ; warning Count ++ ; } } while ( warning Count < MAX WARNINGS ) ; logger . fatal ( STRING ) ; System . exit ( NUM ) ; }
public void run ( ) { Cluster Resource Notification notification ; int warning Count = NUM ; do { try { notification = notifications . take ( ) ; notify Listeners ( notification ) ; } catch ( Interrupted Exception i ) { logger . warn ( STRING ) ; warning Count ++ ; } catch ( Resource Notification Exception r ) { logger . warn ( STRING + r ) ; warning Count ++ ; } } while ( warning Count < MAX WARNINGS ) ; logger . fatal ( STRING ) ; System . exit ( NUM ) ; }
public void run ( ) { Cluster Resource Notification notification ; int warning Count = NUM ; do { try { notification = notifications . take ( ) ; notify Listeners ( notification ) ; } catch ( Interrupted Exception i ) { logger . warn ( STRING ) ; warning Count ++ ; } catch ( Resource Notification Exception r ) { logger . warn ( STRING + r ) ; warning Count ++ ; } } while ( warning Count < MAX WARNINGS ) ; logger . fatal ( STRING ) ; System . exit ( NUM ) ; }
public void run ( ) { Cluster Resource Notification notification ; int warning Count = NUM ; do { try { notification = notifications . take ( ) ; notify Listeners ( notification ) ; } catch ( Interrupted Exception i ) { logger . warn ( STRING ) ; warning Count ++ ; } catch ( Resource Notification Exception r ) { logger . warn ( STRING + r ) ; warning Count ++ ; } } while ( warning Count < MAX WARNINGS ) ; logger . fatal ( STRING ) ; System . exit ( NUM ) ; }
public void run ( ) { Cluster Resource Notification notification ; int warning Count = NUM ; do { try { notification = notifications . take ( ) ; notify Listeners ( notification ) ; } catch ( Interrupted Exception i ) { logger . warn ( STRING ) ; warning Count ++ ; } catch ( Resource Notification Exception r ) { logger . warn ( STRING + r ) ; warning Count ++ ; } } while ( warning Count < MAX WARNINGS ) ; logger . fatal ( STRING ) ; System . exit ( NUM ) ; }
public String serialize ( Object object ) throws Converter Exception { deep = NUM ; String Builder sb = new String Builder ( ) ; serialize ( object , sb , new Hash Set < Object > ( ) ) ; return sb . to String ( ) ; }
public void compile All Projects ( List < File > p Project Roots , Issue Acceptor issue Acceptor ) throws N4 JS Compile Exception { List < File > abs Project Roots = Headless Helper . to Absolute File List ( p Project Roots ) ; Array List < File > p Dir = Headless Helper . collect All Project Paths ( abs Project Roots ) ; compile Projects ( p Project Roots , p Dir , Collections . empty List ( ) , issue Acceptor ) ; }
public void compile All Projects ( List < File > p Project Roots , Issue Acceptor issue Acceptor ) throws N4 JS Compile Exception { List < File > abs Project Roots = Headless Helper . to Absolute File List ( p Project Roots ) ; Array List < File > p Dir = Headless Helper . collect All Project Paths ( abs Project Roots ) ; compile Projects ( p Project Roots , p Dir , Collections . empty List ( ) , issue Acceptor ) ; }
public void compile All Projects ( List < File > p Project Roots , Issue Acceptor issue Acceptor ) throws N4 JS Compile Exception { List < File > abs Project Roots = Headless Helper . to Absolute File List ( p Project Roots ) ; Array List < File > p Dir = Headless Helper . collect All Project Paths ( abs Project Roots ) ; compile Projects ( p Project Roots , p Dir , Collections . empty List ( ) , issue Acceptor ) ; }
public void remove Qualifiers ( ) { Property Options opts = get Options ( ) ; opts . set Has Qualifiers ( BOOL ) ; opts . set Has Language ( BOOL ) ; opts . set Has Type ( BOOL ) ; qualifier = null ; }
public void remove Qualifiers ( ) { Property Options opts = get Options ( ) ; opts . set Has Qualifiers ( BOOL ) ; opts . set Has Language ( BOOL ) ; opts . set Has Type ( BOOL ) ; qualifier = null ; }
private static byte [ ] create Req ( byte [ ] command , int value ) { byte [ ] array = new byte [ NUM ] ; System . arraycopy ( command , NUM , array , NUM , NUM ) ; Array Helper . swap 32 bits To Array ( value , array , NUM ) ; return array ; }
protected static Boolean try To Lock ( String service Name ) { Distributed Lock Service service = Distributed Lock Service . get Service Named ( service Name ) ; boolean locked = service . lock ( STRING , NUM , - NUM ) ; if ( locked ) { service . unlock ( STRING ) ; } return Boolean . value Of ( locked ) ; }
public void clear Row ( int node Index , int row Index ) { for ( int col Index = NUM ; col Index < get Num Columns ( node Index ) ; col Index ++ ) { set Probability ( node Index , row Index , col Index , Double . Na N ) ; } }
public void clear Row ( int node Index , int row Index ) { for ( int col Index = NUM ; col Index < get Num Columns ( node Index ) ; col Index ++ ) { set Probability ( node Index , row Index , col Index , Double . Na N ) ; } }
@ Override public void unindent ( ) { next Indent -= format . get Indent ( ) ; if ( next Indent < NUM ) next Indent = NUM ; if ( ( line . length ( ) + spaces + text . length ( ) ) == NUM ) this Indent = next Indent ; }
public void move ( int from , int to , int count ) { if ( ! valid ( ) ) { return ; } invalidate Line Map After ( Math . min ( from , to ) ) ; Point [ ] items To Move = new Point [ count ] ; for ( int i = from ; i < from + count ; i ++ ) { items To Move [ i - from ] = size Map . get ( i ) ; } boolean moving Forward = from - to > NUM ; int items To Shift = Math . abs ( from - to ) ; if ( ! moving Forward ) { items To Shift -= count ; } int shift Index = moving Forward ? from - NUM : from + count ; int shift Index Step = moving Forward ? - NUM : NUM ; int shifted = NUM ; while ( shifted < items To Shift ) { size Map . put ( shift Index - ( shift Index Step ) * count , size Map . get ( shift Index ) ) ; shift Index += shift Index Step ; shifted ++ ; } int set Index = to ; if ( ! moving Forward ) { set Index = from + items To Shift ; } for ( Point item : items To Move ) { size Map . put ( set Index ++ , item ) ; } refresh Line Map ( ) ; }
public void hide All Budges ( ) { for ( Relative Layout badge : badge List ) { if ( badge . get Visibility ( ) == VISIBLE ) Badge Helper . hide Badge ( badge ) ; } badge Save Instance Hash Map . clear ( ) ; }
public static Server Socket create Server Socket ( int port , Inet Address bind Address ) throws IO Exception { Server Socket socket = null ; if ( Sys Properties . ENABLE ANONYMOUS TLS ) { remove Anon From Legacy Algorithms ( ) ; } set Keystore ( ) ; Server Socket Factory f = SSL Server Socket Factory . get Default ( ) ; SSL Server Socket secure Socket ; if ( bind Address == null ) { secure Socket = ( SSL Server Socket ) f . create Server Socket ( port ) ; } else { secure Socket = ( SSL Server Socket ) f . create Server Socket ( port , NUM , bind Address ) ; } secure Socket . set Enabled Protocols ( disable SSL ( secure Socket . get Enabled Protocols ( ) ) ) ; if ( Sys Properties . ENABLE ANONYMOUS TLS ) { String [ ] list = enable Anonymous ( secure Socket . get Enabled Cipher Suites ( ) , secure Socket . get Supported Cipher Suites ( ) ) ; secure Socket . set Enabled Cipher Suites ( list ) ; } socket = secure Socket ; return socket ; }
public static Server Socket create Server Socket ( int port , Inet Address bind Address ) throws IO Exception { Server Socket socket = null ; if ( Sys Properties . ENABLE ANONYMOUS TLS ) { remove Anon From Legacy Algorithms ( ) ; } set Keystore ( ) ; Server Socket Factory f = SSL Server Socket Factory . get Default ( ) ; SSL Server Socket secure Socket ; if ( bind Address == null ) { secure Socket = ( SSL Server Socket ) f . create Server Socket ( port ) ; } else { secure Socket = ( SSL Server Socket ) f . create Server Socket ( port , NUM , bind Address ) ; } secure Socket . set Enabled Protocols ( disable SSL ( secure Socket . get Enabled Protocols ( ) ) ) ; if ( Sys Properties . ENABLE ANONYMOUS TLS ) { String [ ] list = enable Anonymous ( secure Socket . get Enabled Cipher Suites ( ) , secure Socket . get Supported Cipher Suites ( ) ) ; secure Socket . set Enabled Cipher Suites ( list ) ; } socket = secure Socket ; return socket ; }
public static Server Socket create Server Socket ( int port , Inet Address bind Address ) throws IO Exception { Server Socket socket = null ; if ( Sys Properties . ENABLE ANONYMOUS TLS ) { remove Anon From Legacy Algorithms ( ) ; } set Keystore ( ) ; Server Socket Factory f = SSL Server Socket Factory . get Default ( ) ; SSL Server Socket secure Socket ; if ( bind Address == null ) { secure Socket = ( SSL Server Socket ) f . create Server Socket ( port ) ; } else { secure Socket = ( SSL Server Socket ) f . create Server Socket ( port , NUM , bind Address ) ; } secure Socket . set Enabled Protocols ( disable SSL ( secure Socket . get Enabled Protocols ( ) ) ) ; if ( Sys Properties . ENABLE ANONYMOUS TLS ) { String [ ] list = enable Anonymous ( secure Socket . get Enabled Cipher Suites ( ) , secure Socket . get Supported Cipher Suites ( ) ) ; secure Socket . set Enabled Cipher Suites ( list ) ; } socket = secure Socket ; return socket ; }
static Rectangle translate Coordinates ( long src , long dst , Rectangle r ) { Point translated Loc = translate Coordinates ( src , dst , r . get Location ( ) ) ; if ( translated Loc == null ) { return null ; } else { return new Rectangle ( translated Loc , r . get Size ( ) ) ; } }
public int [ ] time 2 LMST ( long time ) { int [ ] result = new int [ NUM ] ; long mars Time = Math . round ( ( time - epoch ) / NUM / to Earth ) ; result [ NUM ] = ( int ) ( mars Time / ( seconds In A Day ) ) ; mars Time = ( int ) ( mars Time % seconds In A Day ) ; result [ NUM ] = Math . abs ( ( int ) ( mars Time / seconds In An Hr ) ) ; mars Time = ( int ) ( mars Time % seconds In An Hr ) ; result [ NUM ] = Math . abs ( ( int ) ( mars Time / seconds In A Min ) ) ; result [ NUM ] = Math . abs ( ( int ) ( mars Time % seconds In A Min ) ) ; return ( result ) ; }
public int [ ] time 2 LMST ( long time ) { int [ ] result = new int [ NUM ] ; long mars Time = Math . round ( ( time - epoch ) / NUM / to Earth ) ; result [ NUM ] = ( int ) ( mars Time / ( seconds In A Day ) ) ; mars Time = ( int ) ( mars Time % seconds In A Day ) ; result [ NUM ] = Math . abs ( ( int ) ( mars Time / seconds In An Hr ) ) ; mars Time = ( int ) ( mars Time % seconds In An Hr ) ; result [ NUM ] = Math . abs ( ( int ) ( mars Time / seconds In A Min ) ) ; result [ NUM ] = Math . abs ( ( int ) ( mars Time % seconds In A Min ) ) ; return ( result ) ; }
public void test File File ( ) throws Exception { Properties properties = load Properties ( STRING ) ; assert Equals ( STRING , properties . get Property ( STRING ) ) ; }
public void find And Undo ( Object some Obj ) { if ( some Obj == get Information Delegator ( ) ) { if ( dtmm != null && dtmm . get Info Delegator ( ) == ( Information Delegator ) some Obj ) { dtmm . set Info Delegator ( null ) ; } set Information Delegator ( null ) ; } if ( some Obj == get Mouse Delegator ( ) ) { set Mouse Delegator ( null ) ; } if ( some Obj == get Canvas ( ) ) { set Canvas ( null ) ; } if ( some Obj instanceof Edit Tool Loader ) { remove Loader ( ( Edit Tool Loader ) some Obj ) ; } }
public void find And Undo ( Object some Obj ) { if ( some Obj == get Information Delegator ( ) ) { if ( dtmm != null && dtmm . get Info Delegator ( ) == ( Information Delegator ) some Obj ) { dtmm . set Info Delegator ( null ) ; } set Information Delegator ( null ) ; } if ( some Obj == get Mouse Delegator ( ) ) { set Mouse Delegator ( null ) ; } if ( some Obj == get Canvas ( ) ) { set Canvas ( null ) ; } if ( some Obj instanceof Edit Tool Loader ) { remove Loader ( ( Edit Tool Loader ) some Obj ) ; } }
@ Override protected Instances process ( Instances instances ) throws Exception { if ( ! is First Batch Done ( ) ) { Hash Set < Decision Table Hash Key > hs = new Hash Set < Decision Table Hash Key > ( ) ; Instances new Instances = new Instances ( instances , instances . num Instances ( ) ) ; for ( Instance inst : instances ) { Decision Table Hash Key key = new Decision Table Hash Key ( inst , instances . num Attributes ( ) , BOOL ) ; if ( hs . add ( key ) ) { new Instances . add ( inst ) ; } } new Instances . compactify ( ) ; return new Instances ; } throw new Exception ( STRING ) ; }
@ Override protected Instances process ( Instances instances ) throws Exception { if ( ! is First Batch Done ( ) ) { Hash Set < Decision Table Hash Key > hs = new Hash Set < Decision Table Hash Key > ( ) ; Instances new Instances = new Instances ( instances , instances . num Instances ( ) ) ; for ( Instance inst : instances ) { Decision Table Hash Key key = new Decision Table Hash Key ( inst , instances . num Attributes ( ) , BOOL ) ; if ( hs . add ( key ) ) { new Instances . add ( inst ) ; } } new Instances . compactify ( ) ; return new Instances ; } throw new Exception ( STRING ) ; }
@ Override protected Instances process ( Instances instances ) throws Exception { if ( ! is First Batch Done ( ) ) { Hash Set < Decision Table Hash Key > hs = new Hash Set < Decision Table Hash Key > ( ) ; Instances new Instances = new Instances ( instances , instances . num Instances ( ) ) ; for ( Instance inst : instances ) { Decision Table Hash Key key = new Decision Table Hash Key ( inst , instances . num Attributes ( ) , BOOL ) ; if ( hs . add ( key ) ) { new Instances . add ( inst ) ; } } new Instances . compactify ( ) ; return new Instances ; } throw new Exception ( STRING ) ; }
@ Override protected Instances process ( Instances instances ) throws Exception { if ( ! is First Batch Done ( ) ) { Hash Set < Decision Table Hash Key > hs = new Hash Set < Decision Table Hash Key > ( ) ; Instances new Instances = new Instances ( instances , instances . num Instances ( ) ) ; for ( Instance inst : instances ) { Decision Table Hash Key key = new Decision Table Hash Key ( inst , instances . num Attributes ( ) , BOOL ) ; if ( hs . add ( key ) ) { new Instances . add ( inst ) ; } } new Instances . compactify ( ) ; return new Instances ; } throw new Exception ( STRING ) ; }
protected void append Query Params ( Non Sync String Buffer buffer ) throws Jsp Exception { String nv Pairs = get Query Params ( ) ; if ( ( nv Pairs != null ) && ( nv Pairs . length ( ) > NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nv Pairs ) ; } }
protected void append Query Params ( Non Sync String Buffer buffer ) throws Jsp Exception { String nv Pairs = get Query Params ( ) ; if ( ( nv Pairs != null ) && ( nv Pairs . length ( ) > NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nv Pairs ) ; } }
protected void append Query Params ( Non Sync String Buffer buffer ) throws Jsp Exception { String nv Pairs = get Query Params ( ) ; if ( ( nv Pairs != null ) && ( nv Pairs . length ( ) > NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nv Pairs ) ; } }
protected void append Query Params ( Non Sync String Buffer buffer ) throws Jsp Exception { String nv Pairs = get Query Params ( ) ; if ( ( nv Pairs != null ) && ( nv Pairs . length ( ) > NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nv Pairs ) ; } }
protected void append Query Params ( Non Sync String Buffer buffer ) throws Jsp Exception { String nv Pairs = get Query Params ( ) ; if ( ( nv Pairs != null ) && ( nv Pairs . length ( ) > NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nv Pairs ) ; } }
protected void append Query Params ( Non Sync String Buffer buffer ) throws Jsp Exception { String nv Pairs = get Query Params ( ) ; if ( ( nv Pairs != null ) && ( nv Pairs . length ( ) > NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nv Pairs ) ; } }
protected void append Query Params ( Non Sync String Buffer buffer ) throws Jsp Exception { String nv Pairs = get Query Params ( ) ; if ( ( nv Pairs != null ) && ( nv Pairs . length ( ) > NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nv Pairs ) ; } }
protected void append Query Params ( Non Sync String Buffer buffer ) throws Jsp Exception { String nv Pairs = get Query Params ( ) ; if ( ( nv Pairs != null ) && ( nv Pairs . length ( ) > NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nv Pairs ) ; } }
protected void append Query Params ( Non Sync String Buffer buffer ) throws Jsp Exception { String nv Pairs = get Query Params ( ) ; if ( ( nv Pairs != null ) && ( nv Pairs . length ( ) > NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nv Pairs ) ; } }
protected void append Query Params ( Non Sync String Buffer buffer ) throws Jsp Exception { String nv Pairs = get Query Params ( ) ; if ( ( nv Pairs != null ) && ( nv Pairs . length ( ) > NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nv Pairs ) ; } }
protected void append Query Params ( Non Sync String Buffer buffer ) throws Jsp Exception { String nv Pairs = get Query Params ( ) ; if ( ( nv Pairs != null ) && ( nv Pairs . length ( ) > NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nv Pairs ) ; } }
protected int read ( Speech Record recorder , byte [ ] buffer ) { int len = buffer . length ; int num Of Bytes = recorder . read ( buffer , NUM , len ) ; int status = get Status ( num Of Bytes , len ) ; if ( status == NUM && num Of Bytes >= NUM ) { System . arraycopy ( buffer , NUM , m Recording , m Recorded Length , num Of Bytes ) ; m Recorded Length += len ; } return status ; }
public void remove Entry Indexed Field ( I Entry Holder eh , Object field Value , Template Cache Info p Template , I Object Info oi ) { remove Non Unique Indexed Field ( eh , field Value , p Template , oi ) ; size . decrement And Get ( ) ; }
public void move To Top ( Pinger pinger ) { m Pingers . remove ( pinger ) ; m Pingers . add ( NUM , pinger ) ; notify Data Set Changed ( ) ; }
private Platform create Platform ( ) { Platform platform ; try { String os Name = System . get Property ( STRING ) ; if ( os Name != null ) { os Name = os Name . to Lower Case ( ) ; logger . debug ( STRING , os Name ) ; if ( os Name . contains ( STRING ) ) { logger . debug ( STRING ) ; platform = new Windows Platform ( ) ; } else if ( os Name . contains ( STRING ) || os Name . contains ( STRING ) || os Name . contains ( STRING ) || os Name . contains ( STRING ) ) { if ( is Gnome ( ) ) { logger . debug ( STRING ) ; platform = new Posix Gnome Platform ( ) ; } else if ( is KDE ( ) ) { logger . debug ( STRING ) ; platform = new Posix KDE Platform ( ) ; } else { logger . debug ( STRING ) ; platform = new Posix Platform ( ) ; } } else if ( os Name . contains ( STRING ) || os Name . contains ( STRING ) || os Name . contains ( STRING ) || System . get Property ( STRING ) != null ) { logger . debug ( STRING ) ; platform = new Mac OSX Platform ( ) ; } else { logger . warn ( STRING , os Name ) ; platform = new Default Platform ( ) ; } } else { logger . warn ( STRING ) ; platform = new Default Platform ( ) ; } } catch ( Security Exception e ) { logger . warn ( STRING , e ) ; platform = new Default Platform ( ) ; } return platform ; }
@ Override protected void after Execute ( Runnable r , Throwable t ) { super . after Execute ( r , t ) ; synchronized ( this ) { tasks In Process . decrement And Get ( ) ; if ( tasks In Process . int Value ( ) == NUM ) { synchronizer . signal All ( ) ; } } }
public static File create Temp Dir ( File parent ) { File temp = new File ( parent , Integer . to String ( Math . abs ( UNSEEDED RANDOM . next Int ( ) ) % NUM ) ) ; temp . delete ( ) ; temp . mkdir ( ) ; temp . delete On Exit ( ) ; return temp ; }
char case Fold ( char c ) { if ( alternate Casing ) { if ( c == STRING ) { return STRING ; } else if ( c == STRING ) { return STRING ; } else { return Character . to Lower Case ( c ) ; } } else { return Character . to Lower Case ( c ) ; } }
public void clear Tick Mark Sections ( ) { tick Mark Sections . clear ( ) ; fire Update Event ( REDRAW EVENT ) ; }
public Map < Long , Poi Type > load Poi Types ( ) { List < Poi Type > poi Types = poi Type Dao . query For All ( ) ; Map < Long , Poi Type > result = new Hash Map < > ( ) ; for ( Poi Type poi Type : poi Types ) { result . put ( poi Type . get Id ( ) , poi Type ) ; } return result ; }
@ Objective C Name ( STRING ) Connection ( final String url , final Deepstream Config options , Deepstream Client client , Endpoint endpoint ) { this . client = client ; this . connect State Listeners = new Array List < > ( ) ; this . original Url = url ; this . url = url ; this . connection State = Connection State . CLOSED ; this . message Buffer = new String Builder ( ) ; this . too Many Auth Attempts = BOOL ; this . challenge Denied = BOOL ; this . deliberate Close = BOOL ; this . redirecting = BOOL ; this . reconnect Timeout = null ; this . reconnection Attempt = NUM ; this . options = options ; this . endpoint = endpoint ; this . record Thread = Executors . new Single Thread Executor ( ) ; this . event Thread = Executors . new Single Thread Executor ( ) ; this . rpc Thread = Executors . new Single Thread Executor ( ) ; }
protected static void append Decorations ( int base Pos , String source Code , Create Simple Lexer lang Handler , List < Object > out ) { if ( source Code == null ) { throw new Null Pointer Exception ( STRING ) ; } Job job = new Job ( ) ; job . set Source Code ( source Code ) ; job . set Base Pos ( base Pos ) ; lang Handler . decorate ( job ) ; out . add All ( job . get Decorations ( ) ) ; }
protected static void append Decorations ( int base Pos , String source Code , Create Simple Lexer lang Handler , List < Object > out ) { if ( source Code == null ) { throw new Null Pointer Exception ( STRING ) ; } Job job = new Job ( ) ; job . set Source Code ( source Code ) ; job . set Base Pos ( base Pos ) ; lang Handler . decorate ( job ) ; out . add All ( job . get Decorations ( ) ) ; }
protected static void append Decorations ( int base Pos , String source Code , Create Simple Lexer lang Handler , List < Object > out ) { if ( source Code == null ) { throw new Null Pointer Exception ( STRING ) ; } Job job = new Job ( ) ; job . set Source Code ( source Code ) ; job . set Base Pos ( base Pos ) ; lang Handler . decorate ( job ) ; out . add All ( job . get Decorations ( ) ) ; }
private static String print Offset ( int offset ) { String Buffer buf = new String Buffer ( ) ; if ( offset >= NUM ) { buf . append ( STRING ) ; } else { buf . append ( STRING ) ; offset = - offset ; } int hours = offset / Date Time Constants . MILLIS PER HOUR ; Format Utils . append Padded Integer ( buf , hours , NUM ) ; offset -= hours * ( int ) Date Time Constants . MILLIS PER HOUR ; int minutes = offset / Date Time Constants . MILLIS PER MINUTE ; buf . append ( STRING ) ; Format Utils . append Padded Integer ( buf , minutes , NUM ) ; offset -= minutes * Date Time Constants . MILLIS PER MINUTE ; if ( offset == NUM ) { return buf . to String ( ) ; } int seconds = offset / Date Time Constants . MILLIS PER SECOND ; buf . append ( STRING ) ; Format Utils . append Padded Integer ( buf , seconds , NUM ) ; offset -= seconds * Date Time Constants . MILLIS PER SECOND ; if ( offset == NUM ) { return buf . to String ( ) ; } buf . append ( STRING ) ; Format Utils . append Padded Integer ( buf , offset , NUM ) ; return buf . to String ( ) ; }
public static void send E Mail ( final Context context , final String dialog Title , final String to , final String subject , final String body ) { final Intent send = new Intent ( Intent . ACTION SENDTO ) ; final String uri Text = STRING + Uri . encode ( to ) + STRING + Uri . encode ( subject ) + STRING + Uri . encode ( body ) ; send . set Data ( Uri . parse ( uri Text ) ) ; context . start Activity ( Intent . create Chooser ( send , dialog Title ) ) ; }
public static void send E Mail ( final Context context , final String dialog Title , final String to , final String subject , final String body ) { final Intent send = new Intent ( Intent . ACTION SENDTO ) ; final String uri Text = STRING + Uri . encode ( to ) + STRING + Uri . encode ( subject ) + STRING + Uri . encode ( body ) ; send . set Data ( Uri . parse ( uri Text ) ) ; context . start Activity ( Intent . create Chooser ( send , dialog Title ) ) ; }
public double calculate Log ( double value ) { return Math . log ( value ) / this . base Log ; }
public double calculate Log ( double value ) { return Math . log ( value ) / this . base Log ; }
public String to String ( ) { String Builder buf = new String Builder ( ) ; buf . append ( STRING ) ; for ( int i = NUM ; i < get Num Factors ( ) ; i ++ ) { String factor = get Factor ( i ) ; buf . append ( STRING ) ; buf . append ( factor ) ; buf . append ( STRING ) ; for ( int j = NUM ; j < get Num Parents ( i ) ; j ++ ) { Indexed Parent parent = get Parent ( i , j ) ; buf . append ( STRING ) ; buf . append ( get Factor ( parent . get Index ( ) ) ) ; buf . append ( STRING ) ; buf . append ( parent . get Lag ( ) ) ; } } buf . append ( STRING ) ; return buf . to String ( ) ; }
public static String format Integer If Possible ( double value , int number Of Digits , boolean grouping Character ) { if ( Double . is Na N ( value ) ) { return STRING ; } if ( Double . is Infinite ( value ) ) { if ( value < NUM ) { return STRING + FORMAT SYMBOLS . get Infinity ( ) ; } else { return FORMAT SYMBOLS . get Infinity ( ) ; } } long long Value = Math . round ( value ) ; if ( Math . abs ( long Value - value ) < epsilon Display Value ) { INTEGER FORMAT . set Grouping Used ( grouping Character ) ; return INTEGER FORMAT . format ( value ) ; } return format Number ( value , number Of Digits , grouping Character ) ; }
public static Inet Address find Inet Address ( ) throws Socket Exception , Unknown Host Exception { final Enumeration < Network Interface > enum 1 = Network Interface . get Network Interfaces ( ) ; if ( enum 1 == null ) { final Inet Address ip 1 = Inet Address . get Local Host ( ) ; return ip 1 ; } final List < Inet Address > all But Loopback = new Array List < > ( ) ; while ( enum 1 . has More Elements ( ) ) { final Network Interface netface = enum 1 . next Element ( ) ; final Enumeration < Inet Address > enum 2 = netface . get Inet Addresses ( ) ; while ( enum 2 . has More Elements ( ) ) { final Inet Address ip 2 = enum 2 . next Element ( ) ; if ( ! ip 2 . is Loopback Address ( ) ) { all But Loopback . add ( ip 2 ) ; } } } for ( final Inet Address address : all But Loopback ) { if ( address . get Address ( ) . length == NUM && ! is Private Network Address ( address ) ) { return address ; } } for ( final Inet Address address : all But Loopback ) { if ( ! is Private Network Address ( address ) ) { return address ; } } for ( final Inet Address address : all But Loopback ) { if ( ! address . is Link Local Address ( ) ) { return address ; } } return Inet Address . get Local Host ( ) ; }
public static Inet Address find Inet Address ( ) throws Socket Exception , Unknown Host Exception { final Enumeration < Network Interface > enum 1 = Network Interface . get Network Interfaces ( ) ; if ( enum 1 == null ) { final Inet Address ip 1 = Inet Address . get Local Host ( ) ; return ip 1 ; } final List < Inet Address > all But Loopback = new Array List < > ( ) ; while ( enum 1 . has More Elements ( ) ) { final Network Interface netface = enum 1 . next Element ( ) ; final Enumeration < Inet Address > enum 2 = netface . get Inet Addresses ( ) ; while ( enum 2 . has More Elements ( ) ) { final Inet Address ip 2 = enum 2 . next Element ( ) ; if ( ! ip 2 . is Loopback Address ( ) ) { all But Loopback . add ( ip 2 ) ; } } } for ( final Inet Address address : all But Loopback ) { if ( address . get Address ( ) . length == NUM && ! is Private Network Address ( address ) ) { return address ; } } for ( final Inet Address address : all But Loopback ) { if ( ! is Private Network Address ( address ) ) { return address ; } } for ( final Inet Address address : all But Loopback ) { if ( ! address . is Link Local Address ( ) ) { return address ; } } return Inet Address . get Local Host ( ) ; }
public static Inet Address find Inet Address ( ) throws Socket Exception , Unknown Host Exception { final Enumeration < Network Interface > enum 1 = Network Interface . get Network Interfaces ( ) ; if ( enum 1 == null ) { final Inet Address ip 1 = Inet Address . get Local Host ( ) ; return ip 1 ; } final List < Inet Address > all But Loopback = new Array List < > ( ) ; while ( enum 1 . has More Elements ( ) ) { final Network Interface netface = enum 1 . next Element ( ) ; final Enumeration < Inet Address > enum 2 = netface . get Inet Addresses ( ) ; while ( enum 2 . has More Elements ( ) ) { final Inet Address ip 2 = enum 2 . next Element ( ) ; if ( ! ip 2 . is Loopback Address ( ) ) { all But Loopback . add ( ip 2 ) ; } } } for ( final Inet Address address : all But Loopback ) { if ( address . get Address ( ) . length == NUM && ! is Private Network Address ( address ) ) { return address ; } } for ( final Inet Address address : all But Loopback ) { if ( ! is Private Network Address ( address ) ) { return address ; } } for ( final Inet Address address : all But Loopback ) { if ( ! address . is Link Local Address ( ) ) { return address ; } } return Inet Address . get Local Host ( ) ; }
public static Inet Address find Inet Address ( ) throws Socket Exception , Unknown Host Exception { final Enumeration < Network Interface > enum 1 = Network Interface . get Network Interfaces ( ) ; if ( enum 1 == null ) { final Inet Address ip 1 = Inet Address . get Local Host ( ) ; return ip 1 ; } final List < Inet Address > all But Loopback = new Array List < > ( ) ; while ( enum 1 . has More Elements ( ) ) { final Network Interface netface = enum 1 . next Element ( ) ; final Enumeration < Inet Address > enum 2 = netface . get Inet Addresses ( ) ; while ( enum 2 . has More Elements ( ) ) { final Inet Address ip 2 = enum 2 . next Element ( ) ; if ( ! ip 2 . is Loopback Address ( ) ) { all But Loopback . add ( ip 2 ) ; } } } for ( final Inet Address address : all But Loopback ) { if ( address . get Address ( ) . length == NUM && ! is Private Network Address ( address ) ) { return address ; } } for ( final Inet Address address : all But Loopback ) { if ( ! is Private Network Address ( address ) ) { return address ; } } for ( final Inet Address address : all But Loopback ) { if ( ! address . is Link Local Address ( ) ) { return address ; } } return Inet Address . get Local Host ( ) ; }
public static Inet Address find Inet Address ( ) throws Socket Exception , Unknown Host Exception { final Enumeration < Network Interface > enum 1 = Network Interface . get Network Interfaces ( ) ; if ( enum 1 == null ) { final Inet Address ip 1 = Inet Address . get Local Host ( ) ; return ip 1 ; } final List < Inet Address > all But Loopback = new Array List < > ( ) ; while ( enum 1 . has More Elements ( ) ) { final Network Interface netface = enum 1 . next Element ( ) ; final Enumeration < Inet Address > enum 2 = netface . get Inet Addresses ( ) ; while ( enum 2 . has More Elements ( ) ) { final Inet Address ip 2 = enum 2 . next Element ( ) ; if ( ! ip 2 . is Loopback Address ( ) ) { all But Loopback . add ( ip 2 ) ; } } } for ( final Inet Address address : all But Loopback ) { if ( address . get Address ( ) . length == NUM && ! is Private Network Address ( address ) ) { return address ; } } for ( final Inet Address address : all But Loopback ) { if ( ! is Private Network Address ( address ) ) { return address ; } } for ( final Inet Address address : all But Loopback ) { if ( ! address . is Link Local Address ( ) ) { return address ; } } return Inet Address . get Local Host ( ) ; }
@ Override public void write External ( Object Output out ) throws IO Exception { super . write External ( out ) ; out . write Object ( knn Distance ) ; }
@ Override public void write External ( Object Output out ) throws IO Exception { super . write External ( out ) ; out . write Object ( knn Distance ) ; }
public void save ( ) { do Save ( ) ; messages . info ( STRING + project . get Name ( ) + STRING ) ; }
public void save ( ) { do Save ( ) ; messages . info ( STRING + project . get Name ( ) + STRING ) ; }
public boolean offer ( E e , long timeout , Time Unit unit ) throws Interrupted Exception { if ( e == null ) throw new Null Pointer Exception ( ) ; long nanos = unit . to Nanos ( timeout ) ; int c = - NUM ; final Reentrant Lock put Lock = this . put Lock ; final Atomic Integer count = this . count ; put Lock . lock Interruptibly ( ) ; try { while ( count . get ( ) >= capacity ) { if ( nanos <= NUM ) return BOOL ; nanos = not Full . await Nanos ( nanos ) ; } enqueue ( e ) ; c = count . get And Increment ( ) ; if ( c + NUM < capacity ) not Full . signal ( ) ; } finally { put Lock . unlock ( ) ; } if ( c == NUM ) signal Not Empty ( ) ; return BOOL ; }
public boolean offer ( E e , long timeout , Time Unit unit ) throws Interrupted Exception { if ( e == null ) throw new Null Pointer Exception ( ) ; long nanos = unit . to Nanos ( timeout ) ; int c = - NUM ; final Reentrant Lock put Lock = this . put Lock ; final Atomic Integer count = this . count ; put Lock . lock Interruptibly ( ) ; try { while ( count . get ( ) >= capacity ) { if ( nanos <= NUM ) return BOOL ; nanos = not Full . await Nanos ( nanos ) ; } enqueue ( e ) ; c = count . get And Increment ( ) ; if ( c + NUM < capacity ) not Full . signal ( ) ; } finally { put Lock . unlock ( ) ; } if ( c == NUM ) signal Not Empty ( ) ; return BOOL ; }
protected static Die die ( String why ) { return new Die ( why ) ; }
protected static Die die ( String why ) { return new Die ( why ) ; }
public int eval ( I Node state ) { Tiny Puzzle tp = ( Tiny Puzzle ) state ; if ( tp . s [ NUM ] > target [ NUM ] ) return Integer . MAX VALUE ; if ( tp . s [ NUM ] > target [ NUM ] ) return Integer . MAX VALUE ; return Math . abs ( target [ NUM ] - tp . s [ NUM ] ) + Math . abs ( target [ NUM ] - tp . s [ NUM ] ) ; }
public Image add Image ( String location , Image image ) { if ( m max Image Width > - NUM || m max Image Height > - NUM ) { image = get Scaled Image ( image ) ; image . get Width ( null ) ; } image Cache . put ( location , image ) ; return image ; }
public void stop Auto Fail Thread ( ) { if ( is Auto Fail ( ) && auto Fail Thread != null && auto Fail Thread . is Alive ( ) ) { is Test Success . set ( BOOL ) ; if ( verbose ) { LOG . info ( STRING ) ; } LOG . info ( STRING ) ; auto Fail Thread . interrupt ( ) ; } }
public void write Request ( ) { Object lock = new Object ( ) ; synchronized ( lock ) { synchronized ( this ) { boolean go Ahead With Write = writer Locks . size ( ) == NUM && current Readers == NUM && current Writers == NUM ; if ( go Ahead With Write ) { ++ current Writers ; return ; } writer Locks . add Last ( lock ) ; } try { lock . wait ( ) ; } catch ( Interrupted Exception e ) { } } }
public void write Request ( ) { Object lock = new Object ( ) ; synchronized ( lock ) { synchronized ( this ) { boolean go Ahead With Write = writer Locks . size ( ) == NUM && current Readers == NUM && current Writers == NUM ; if ( go Ahead With Write ) { ++ current Writers ; return ; } writer Locks . add Last ( lock ) ; } try { lock . wait ( ) ; } catch ( Interrupted Exception e ) { } } }
public void write Request ( ) { Object lock = new Object ( ) ; synchronized ( lock ) { synchronized ( this ) { boolean go Ahead With Write = writer Locks . size ( ) == NUM && current Readers == NUM && current Writers == NUM ; if ( go Ahead With Write ) { ++ current Writers ; return ; } writer Locks . add Last ( lock ) ; } try { lock . wait ( ) ; } catch ( Interrupted Exception e ) { } } }
public void write Request ( ) { Object lock = new Object ( ) ; synchronized ( lock ) { synchronized ( this ) { boolean go Ahead With Write = writer Locks . size ( ) == NUM && current Readers == NUM && current Writers == NUM ; if ( go Ahead With Write ) { ++ current Writers ; return ; } writer Locks . add Last ( lock ) ; } try { lock . wait ( ) ; } catch ( Interrupted Exception e ) { } } }
public void write Request ( ) { Object lock = new Object ( ) ; synchronized ( lock ) { synchronized ( this ) { boolean go Ahead With Write = writer Locks . size ( ) == NUM && current Readers == NUM && current Writers == NUM ; if ( go Ahead With Write ) { ++ current Writers ; return ; } writer Locks . add Last ( lock ) ; } try { lock . wait ( ) ; } catch ( Interrupted Exception e ) { } } }
@ Override public synchronized void reset ( ) throws IO Exception { try { buffer . reset ( ) ; } catch ( Invalid Mark Exception e ) { throw new IO Exception ( STRING ) ; } }
public static void silent Close Output Stream ( Output Stream os ) { try { if ( os != null ) { os . close ( ) ; } } catch ( IO Exception e ) { log . w ( LOG TAG , STRING , e ) ; } }
public static void silent Close Output Stream ( Output Stream os ) { try { if ( os != null ) { os . close ( ) ; } } catch ( IO Exception e ) { log . w ( LOG TAG , STRING , e ) ; } }
public static void silent Close Output Stream ( Output Stream os ) { try { if ( os != null ) { os . close ( ) ; } } catch ( IO Exception e ) { log . w ( LOG TAG , STRING , e ) ; } }
public VN Xe Command Job create Luns In Consistency Group ( List < String > names , String pool Id , Long size , boolean is Thin , String tiering Policy , String cg Id ) { logger . info ( STRING , cg Id ) ; Lun Group Modify Param param = new Lun Group Modify Param ( ) ; List < Lun Create Param > lun Creates = new Array List < Lun Create Param > ( ) ; boolean is Policy On = BOOL ; Fast VP Param fast VP = new Fast VP Param ( ) ; if ( tiering Policy != null && ! tiering Policy . is Empty ( ) ) { Tiering Policy Enum tier Value = Tiering Policy Enum . value Of ( tiering Policy ) ; if ( tier Value != null ) { fast VP . set Tiering Policy ( tier Value . get Value ( ) ) ; is Policy On = BOOL ; } } for ( String lun Name : names ) { Lun Param lun Param = new Lun Param ( ) ; lun Param . set Is Thin Enabled ( is Thin ) ; lun Param . set Size ( size ) ; lun Param . set Pool ( new VN Xe Base ( pool Id ) ) ; Lun Create Param create Param = new Lun Create Param ( ) ; create Param . set Name ( lun Name ) ; create Param . set Lun Parameters ( lun Param ) ; if ( is Policy On ) { lun Param . set Fast VP Parameters ( fast VP ) ; } lun Creates . add ( create Param ) ; } param . set Lun Create ( lun Creates ) ; Consistency Group Requests req = new Consistency Group Requests ( kh Client ) ; return req . modify Consistency Group Async ( cg Id , param ) ; }
public VN Xe Command Job create Luns In Consistency Group ( List < String > names , String pool Id , Long size , boolean is Thin , String tiering Policy , String cg Id ) { logger . info ( STRING , cg Id ) ; Lun Group Modify Param param = new Lun Group Modify Param ( ) ; List < Lun Create Param > lun Creates = new Array List < Lun Create Param > ( ) ; boolean is Policy On = BOOL ; Fast VP Param fast VP = new Fast VP Param ( ) ; if ( tiering Policy != null && ! tiering Policy . is Empty ( ) ) { Tiering Policy Enum tier Value = Tiering Policy Enum . value Of ( tiering Policy ) ; if ( tier Value != null ) { fast VP . set Tiering Policy ( tier Value . get Value ( ) ) ; is Policy On = BOOL ; } } for ( String lun Name : names ) { Lun Param lun Param = new Lun Param ( ) ; lun Param . set Is Thin Enabled ( is Thin ) ; lun Param . set Size ( size ) ; lun Param . set Pool ( new VN Xe Base ( pool Id ) ) ; Lun Create Param create Param = new Lun Create Param ( ) ; create Param . set Name ( lun Name ) ; create Param . set Lun Parameters ( lun Param ) ; if ( is Policy On ) { lun Param . set Fast VP Parameters ( fast VP ) ; } lun Creates . add ( create Param ) ; } param . set Lun Create ( lun Creates ) ; Consistency Group Requests req = new Consistency Group Requests ( kh Client ) ; return req . modify Consistency Group Async ( cg Id , param ) ; }
void make ( Bulk Test bulk ) { Class c = bulk . get Class ( ) ; Method [ ] all = c . get Methods ( ) ; for ( int i = NUM ; i < all . length ; i ++ ) { if ( is Test ( all [ i ] ) ) add Test ( bulk , all [ i ] ) ; if ( is Bulk ( all [ i ] ) ) add Bulk ( bulk , all [ i ] ) ; } }
void make ( Bulk Test bulk ) { Class c = bulk . get Class ( ) ; Method [ ] all = c . get Methods ( ) ; for ( int i = NUM ; i < all . length ; i ++ ) { if ( is Test ( all [ i ] ) ) add Test ( bulk , all [ i ] ) ; if ( is Bulk ( all [ i ] ) ) add Bulk ( bulk , all [ i ] ) ; } }
private Date Time Zone load Zone Data ( String id ) { Input Stream in = null ; try { in = open Resource ( id ) ; Date Time Zone tz = Date Time Zone Builder . read From ( in , id ) ; i Zone Info Map . put ( id , new Soft Reference < Date Time Zone > ( tz ) ) ; return tz ; } catch ( IO Exception ex ) { uncaught Exception ( ex ) ; i Zone Info Map . remove ( id ) ; return null ; } finally { try { if ( in != null ) { in . close ( ) ; } } catch ( IO Exception ex ) { } } }
public void simulate Method ( Soot Method method , Reference Variable this Var , Reference Variable return Var , Reference Variable params [ ] ) { String sub Signature = method . get Sub Signature ( ) ; if ( sub Signature . equals ( STRING ) ) { java util Resource Bundle get Class Context ( method , this Var , return Var , params ) ; return ; } else { default Method ( method , this Var , return Var , params ) ; return ; } }
public void simulate Method ( Soot Method method , Reference Variable this Var , Reference Variable return Var , Reference Variable params [ ] ) { String sub Signature = method . get Sub Signature ( ) ; if ( sub Signature . equals ( STRING ) ) { java util Resource Bundle get Class Context ( method , this Var , return Var , params ) ; return ; } else { default Method ( method , this Var , return Var , params ) ; return ; } }
public final void put ( String key , int value ) { if ( ( m first Free + NUM ) >= m map Size ) { m map Size += m blocksize ; String new Map [ ] = new String [ m map Size ] ; System . arraycopy ( m map , NUM , new Map , NUM , m first Free + NUM ) ; m map = new Map ; int new Values [ ] = new int [ m map Size ] ; System . arraycopy ( m values , NUM , new Values , NUM , m first Free + NUM ) ; m values = new Values ; } m map [ m first Free ] = key ; m values [ m first Free ] = value ; m first Free ++ ; }
public Synapse ( Neuron source , Neuron target ) { set Source And Target ( source , target ) ; init Spike Responder ( ) ; if ( source != null ) { parent Network = source . get Network ( ) ; } is Template = source == null ; }
public Synapse ( Neuron source , Neuron target ) { set Source And Target ( source , target ) ; init Spike Responder ( ) ; if ( source != null ) { parent Network = source . get Network ( ) ; } is Template = source == null ; }
public Synapse ( Neuron source , Neuron target ) { set Source And Target ( source , target ) ; init Spike Responder ( ) ; if ( source != null ) { parent Network = source . get Network ( ) ; } is Template = source == null ; }
public void update Hold ( @ Nullable Object key , Instant new Hold ) { remove Hold ( key ) ; Keyed Hold new Keyed Hold = Keyed Hold . of ( key , new Hold ) ; keyed Holds . put ( key , new Keyed Hold ) ; all Holds . offer ( new Keyed Hold ) ; }
public static Alert Dialog Helper new Instance ( final Fragment container , final int id , final int title , final int message , final String args , final boolean neutral Only ) { final Alert Dialog Helper frag = new Alert Dialog Helper ( ) ; frag . set Target Fragment ( container , id ) ; final Bundle bundle = new Bundle ( ) ; bundle . put Int ( STRING , id ) ; bundle . put Int ( STRING , title ) ; bundle . put Int ( STRING , message ) ; bundle . put String ( STRING , args ) ; bundle . put Boolean ( STRING , neutral Only ) ; frag . set Arguments ( bundle ) ; return frag ; }
private Token create Vm Args Token ( ) { String Builder jvm Args = new String Builder ( ) ; File hot Fix Jar = new File ( jrun Container . get Home ( ) + STRING ) ; if ( hot Fix Jar . exists ( ) ) { jvm Args . append ( STRING ) ; } jvm Args . append ( STRING ) ; jvm Args . append ( STRING ) ; jvm Args . append ( STRING ) ; jvm Args . append ( STRING ) ; Replace Tokens . Token token Vm Args = new Replace Tokens . Token ( ) ; token Vm Args . set Key ( STRING ) ; token Vm Args . set Value ( jvm Args . to String ( ) ) ; return token Vm Args ; }
public D Import Key Pair Open Ssl ( J Frame parent ) { super ( parent , Dialog . Modality Type . DOCUMENT MODAL ) ; init Components ( ) ; }
public static Server Side Sort Request Control new Control ( final boolean is Critical , final Collection < Sort Key > keys ) { Reject . if Null ( keys ) ; Reject . if False ( ! keys . is Empty ( ) , STRING ) ; return new Server Side Sort Request Control ( is Critical , Collections . unmodifiable List ( new Array List < Sort Key > ( keys ) ) ) ; }
static void append Vm Ergo Message ( boolean is Server Class , String vm ) { out Buf = out Buf . append ( get Localized Message ( STRING , vm ) ) ; out Buf = ( is Server Class ) ? out Buf . append ( STRING + get Localized Message ( STRING ) + STRING ) : out Buf . append ( STRING ) ; }
public long count ( ) { return cnt . get ( ) ; }
public static String find Code Base In Class Path ( Pattern code Base Name Pattern , String class Path ) { if ( class Path == null ) { return null ; } String Tokenizer tok = new String Tokenizer ( class Path , File . path Separator ) ; while ( tok . has More Tokens ( ) ) { String t = tok . next Token ( ) ; File f = new File ( t ) ; Matcher m = code Base Name Pattern . matcher ( f . get Name ( ) ) ; if ( m . matches ( ) ) { return t ; } } return null ; }
public static String find Code Base In Class Path ( Pattern code Base Name Pattern , String class Path ) { if ( class Path == null ) { return null ; } String Tokenizer tok = new String Tokenizer ( class Path , File . path Separator ) ; while ( tok . has More Tokens ( ) ) { String t = tok . next Token ( ) ; File f = new File ( t ) ; Matcher m = code Base Name Pattern . matcher ( f . get Name ( ) ) ; if ( m . matches ( ) ) { return t ; } } return null ; }
public synchronized void add Selection Listener ( Selection Listener listener ) { if ( listeners == null ) { listeners = new Vector < Selection Listener > ( ) ; } listeners . add Element ( listener ) ; }
public static void store Location ( Context context , Lat Lng location ) { Shared Preferences prefs = Preference Manager . get Default Shared Preferences ( context ) ; Shared Preferences . Editor editor = prefs . edit ( ) ; editor . put Long ( PREFERENCES LAT , Double . double To Raw Long Bits ( location . latitude ) ) ; editor . put Long ( PREFERENCES LNG , Double . double To Raw Long Bits ( location . longitude ) ) ; editor . apply ( ) ; }
public static void store Location ( Context context , Lat Lng location ) { Shared Preferences prefs = Preference Manager . get Default Shared Preferences ( context ) ; Shared Preferences . Editor editor = prefs . edit ( ) ; editor . put Long ( PREFERENCES LAT , Double . double To Raw Long Bits ( location . latitude ) ) ; editor . put Long ( PREFERENCES LNG , Double . double To Raw Long Bits ( location . longitude ) ) ; editor . apply ( ) ; }
public Object Instance ( Object Name object Name , String class Name ) { if ( object Name . is Pattern ( ) ) { final Illegal Argument Exception iae = new Illegal Argument Exception ( STRING + object Name . to String ( ) ) ; throw new Runtime Operations Exception ( iae ) ; } this . name = object Name ; this . class Name = class Name ; }
protected Resource create Resource ( final Element resource Element ) { final String uri = resource Element . get Text Content ( ) ; final String minimize As String = resource Element . get Attribute ( ATTR MINIMIZE ) ; final boolean minimize = String Utils . is Empty ( minimize As String ) || Boolean . value Of ( minimize As String ) ; final Resource resource = Resource . create ( uri , get Resource Type ( resource Element ) ) ; resource . set Minimize ( minimize ) ; return resource ; }
protected Resource create Resource ( final Element resource Element ) { final String uri = resource Element . get Text Content ( ) ; final String minimize As String = resource Element . get Attribute ( ATTR MINIMIZE ) ; final boolean minimize = String Utils . is Empty ( minimize As String ) || Boolean . value Of ( minimize As String ) ; final Resource resource = Resource . create ( uri , get Resource Type ( resource Element ) ) ; resource . set Minimize ( minimize ) ; return resource ; }
protected Resource create Resource ( final Element resource Element ) { final String uri = resource Element . get Text Content ( ) ; final String minimize As String = resource Element . get Attribute ( ATTR MINIMIZE ) ; final boolean minimize = String Utils . is Empty ( minimize As String ) || Boolean . value Of ( minimize As String ) ; final Resource resource = Resource . create ( uri , get Resource Type ( resource Element ) ) ; resource . set Minimize ( minimize ) ; return resource ; }
public static Object Output Stream new Object Output Stream ( Path self ) throws IO Exception { return new Object Output Stream ( Files . new Output Stream ( self ) ) ; }
public boolean has Payload ( ) { return ( payload == null ) ? BOOL : payload . has Payload ( ) ; }
public boolean has Payload ( ) { return ( payload == null ) ? BOOL : payload . has Payload ( ) ; }
void compose Templates ( Elem Template Element templ ) throws Transformer Exception { templ . compose ( this ) ; for ( Elem Template Element child = templ . get First Child Elem ( ) ; child != null ; child = child . get Next Sibling Elem ( ) ) { compose Templates ( child ) ; } templ . end Compose ( this ) ; }
protected void send Function Group 1 ( ) { send Update ( ) ; }
public void resolve ( Class type , String value ) throws Exception { String name = type . get Name ( ) ; read . put ( value , name ) ; write . put ( name , value ) ; }
public void resolve ( Class type , String value ) throws Exception { String name = type . get Name ( ) ; read . put ( value , name ) ; write . put ( name , value ) ; }
public void resolve ( Class type , String value ) throws Exception { String name = type . get Name ( ) ; read . put ( value , name ) ; write . put ( name , value ) ; }
public void resolve ( Class type , String value ) throws Exception { String name = type . get Name ( ) ; read . put ( value , name ) ; write . put ( name , value ) ; }
public void resolve ( Class type , String value ) throws Exception { String name = type . get Name ( ) ; read . put ( value , name ) ; write . put ( name , value ) ; }
public void resolve ( Class type , String value ) throws Exception { String name = type . get Name ( ) ; read . put ( value , name ) ; write . put ( name , value ) ; }
public int capacity ( ) { return internal . capacity ( ) ; }
public int capacity ( ) { return internal . capacity ( ) ; }
public static String extract ( String s ) { String result ; result = s ; result = result . replace All ( STRING , STRING ) ; result = result . replace All ( STRING , STRING ) ; result = result . replace All ( STRING , STRING ) ; return result ; }
private void enable Device Capabilities Area ( boolean enabled ) { m Disable Camera Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Widgets Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Secure Camera Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Notification Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Unredacted Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Trust Agent Checkbox . set Enabled ( enabled ) ; }
private void enable Device Capabilities Area ( boolean enabled ) { m Disable Camera Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Widgets Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Secure Camera Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Notification Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Unredacted Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Trust Agent Checkbox . set Enabled ( enabled ) ; }
private void abort Loading ( ) { if ( thread == null ) return ; if ( thread . is Alive ( ) ) { thread . interrupt ( ) ; try { thread . join ( ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } } }
private void abort Loading ( ) { if ( thread == null ) return ; if ( thread . is Alive ( ) ) { thread . interrupt ( ) ; try { thread . join ( ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } } }
private String parse Time From Ping ( String ping ) { String time = STRING ; if ( ping . contains ( TIME PING ) ) { int index = ping . index Of ( TIME PING ) ; time = ping . substring ( index + NUM ) ; index = time . index Of ( STRING ) ; time = time . substring ( NUM , index ) ; } return time ; }
private void restore Icon ( Backup Protos . Key key , byte [ ] buffer , int data Size ) throws IO Exception { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base 64 . encode To String ( buffer , NUM , data Size , Base 64 . NO WRAP ) ) ; Backup Protos . Resource res = unpack Proto ( new Backup Protos . Resource ( ) , buffer , data Size ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = Bitmap Factory . decode Byte Array ( res . data , NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } else { if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; m Icon Cache . preload Icon ( Component Name . unflatten From String ( key . name ) , icon , res . dpi , STRING , m User Serial , m Idp ) ; } }
private void restore Icon ( Backup Protos . Key key , byte [ ] buffer , int data Size ) throws IO Exception { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base 64 . encode To String ( buffer , NUM , data Size , Base 64 . NO WRAP ) ) ; Backup Protos . Resource res = unpack Proto ( new Backup Protos . Resource ( ) , buffer , data Size ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = Bitmap Factory . decode Byte Array ( res . data , NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } else { if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; m Icon Cache . preload Icon ( Component Name . unflatten From String ( key . name ) , icon , res . dpi , STRING , m User Serial , m Idp ) ; } }
private void restore Icon ( Backup Protos . Key key , byte [ ] buffer , int data Size ) throws IO Exception { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base 64 . encode To String ( buffer , NUM , data Size , Base 64 . NO WRAP ) ) ; Backup Protos . Resource res = unpack Proto ( new Backup Protos . Resource ( ) , buffer , data Size ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = Bitmap Factory . decode Byte Array ( res . data , NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } else { if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; m Icon Cache . preload Icon ( Component Name . unflatten From String ( key . name ) , icon , res . dpi , STRING , m User Serial , m Idp ) ; } }
private void restore Icon ( Backup Protos . Key key , byte [ ] buffer , int data Size ) throws IO Exception { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base 64 . encode To String ( buffer , NUM , data Size , Base 64 . NO WRAP ) ) ; Backup Protos . Resource res = unpack Proto ( new Backup Protos . Resource ( ) , buffer , data Size ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = Bitmap Factory . decode Byte Array ( res . data , NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } else { if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; m Icon Cache . preload Icon ( Component Name . unflatten From String ( key . name ) , icon , res . dpi , STRING , m User Serial , m Idp ) ; } }
private void restore Icon ( Backup Protos . Key key , byte [ ] buffer , int data Size ) throws IO Exception { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base 64 . encode To String ( buffer , NUM , data Size , Base 64 . NO WRAP ) ) ; Backup Protos . Resource res = unpack Proto ( new Backup Protos . Resource ( ) , buffer , data Size ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = Bitmap Factory . decode Byte Array ( res . data , NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } else { if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; m Icon Cache . preload Icon ( Component Name . unflatten From String ( key . name ) , icon , res . dpi , STRING , m User Serial , m Idp ) ; } }
protected void update Menu ( ) { boolean present ; boolean initializing ; boolean running ; boolean stopping ; boolean active ; if ( m Menu Bar == null ) return ; present = ( m Experiment != null ) ; initializing = present && m Experiment . is Initializing ( ) ; running = present && m Experiment . is Running ( ) ; stopping = present && m Experiment . is Stopping ( ) ; active = initializing || running || stopping ; m Menu Item File New . set Enabled ( ! active ) ; m Menu Item File Open . set Enabled ( ! active ) ; m Menu Item File Save . set Enabled ( present && ( get Current File ( ) != null ) ) ; m Menu Item File Save As . set Enabled ( present ) ; m Menu Item File Close . set Enabled ( ! active ) ; m Menu Item Execution Start . set Enabled ( present && ! active ) ; m Menu Item Execution Stop . set Enabled ( present && running ) ; for ( Abstract Experimenter Menu Item item : m Additional Menu Items . key Set ( ) ) item . update ( this , m Additional Menu Items . get ( item ) ) ; }
public Shared Iterator Space Data Source Decorator ( Space Data Source space Data Source , long time To Live ) { space Data Source = space Data Source ; time To Live = time To Live ; query To Sources = new Concurrent Hash Map < Data Source SQL Query , Shared Data Iterator Source < Object > > ( ) ; sources To Query = new Concurrent Hash Map < Shared Data Iterator Source < Object > , Data Source SQL Query > ( ) ; }
public static String convert Date To ISO 8601 ( Date date ) { Date Format date Format = new Simple Date Format ( STRING ) ; return date Format . format ( date ) ; }
public static String convert Date To ISO 8601 ( Date date ) { Date Format date Format = new Simple Date Format ( STRING ) ; return date Format . format ( date ) ; }
public void add To Associated ( Message as Message ) { associated Messages . add ( as Message ) ; }
public boolean add Owner ( Principal caller , Principal owner ) throws Not Owner Exception { if ( ! owner List . contains ( caller ) ) throw new Not Owner Exception ( ) ; if ( owner List . contains ( owner ) ) { return BOOL ; } else { owner List . add Element ( owner ) ; return BOOL ; } }
public boolean add Owner ( Principal caller , Principal owner ) throws Not Owner Exception { if ( ! owner List . contains ( caller ) ) throw new Not Owner Exception ( ) ; if ( owner List . contains ( owner ) ) { return BOOL ; } else { owner List . add Element ( owner ) ; return BOOL ; } }
public boolean add Owner ( Principal caller , Principal owner ) throws Not Owner Exception { if ( ! owner List . contains ( caller ) ) throw new Not Owner Exception ( ) ; if ( owner List . contains ( owner ) ) { return BOOL ; } else { owner List . add Element ( owner ) ; return BOOL ; } }
public boolean add Owner ( Principal caller , Principal owner ) throws Not Owner Exception { if ( ! owner List . contains ( caller ) ) throw new Not Owner Exception ( ) ; if ( owner List . contains ( owner ) ) { return BOOL ; } else { owner List . add Element ( owner ) ; return BOOL ; } }
public boolean add Owner ( Principal caller , Principal owner ) throws Not Owner Exception { if ( ! owner List . contains ( caller ) ) throw new Not Owner Exception ( ) ; if ( owner List . contains ( owner ) ) { return BOOL ; } else { owner List . add Element ( owner ) ; return BOOL ; } }
public boolean add Owner ( Principal caller , Principal owner ) throws Not Owner Exception { if ( ! owner List . contains ( caller ) ) throw new Not Owner Exception ( ) ; if ( owner List . contains ( owner ) ) { return BOOL ; } else { owner List . add Element ( owner ) ; return BOOL ; } }
public boolean add Owner ( Principal caller , Principal owner ) throws Not Owner Exception { if ( ! owner List . contains ( caller ) ) throw new Not Owner Exception ( ) ; if ( owner List . contains ( owner ) ) { return BOOL ; } else { owner List . add Element ( owner ) ; return BOOL ; } }
public void wait For Active Locks ( ) throws Interrupted Exception { long now = - NUM ; while ( BOOL ) { boolean nochange ; Set < Weak Lock Reference > before ; synchronized ( active Locks ) { if ( active Locks . is Empty ( ) ) return ; before = new Hash Set < Weak Lock Reference > ( active Locks ) ; if ( now < NUM ) { now = System . current Time Millis ( ) ; } active Locks . wait ( wait To Collect ) ; if ( active Locks . is Empty ( ) ) return ; nochange = before . equals ( active Locks ) ; } if ( nochange && System . current Time Millis ( ) - now >= wait To Collect / NUM ) { release Abandoned ( ) ; now = - NUM ; } } }
public void wait For Active Locks ( ) throws Interrupted Exception { long now = - NUM ; while ( BOOL ) { boolean nochange ; Set < Weak Lock Reference > before ; synchronized ( active Locks ) { if ( active Locks . is Empty ( ) ) return ; before = new Hash Set < Weak Lock Reference > ( active Locks ) ; if ( now < NUM ) { now = System . current Time Millis ( ) ; } active Locks . wait ( wait To Collect ) ; if ( active Locks . is Empty ( ) ) return ; nochange = before . equals ( active Locks ) ; } if ( nochange && System . current Time Millis ( ) - now >= wait To Collect / NUM ) { release Abandoned ( ) ; now = - NUM ; } } }
public void wait For Active Locks ( ) throws Interrupted Exception { long now = - NUM ; while ( BOOL ) { boolean nochange ; Set < Weak Lock Reference > before ; synchronized ( active Locks ) { if ( active Locks . is Empty ( ) ) return ; before = new Hash Set < Weak Lock Reference > ( active Locks ) ; if ( now < NUM ) { now = System . current Time Millis ( ) ; } active Locks . wait ( wait To Collect ) ; if ( active Locks . is Empty ( ) ) return ; nochange = before . equals ( active Locks ) ; } if ( nochange && System . current Time Millis ( ) - now >= wait To Collect / NUM ) { release Abandoned ( ) ; now = - NUM ; } } }
public static boolean date Is Valid ( String date String ) { return date String . matches ( DEFAULT DATE REGEX ) ; }
protected void draw Tick Marks Vertical ( Graphics 2 D g2 , Axis State state , Rectangle 2 D data Area , Rectangle Edge edge ) { }
protected void draw Tick Marks Vertical ( Graphics 2 D g2 , Axis State state , Rectangle 2 D data Area , Rectangle Edge edge ) { }
protected double kernel LP ( int n , char [ ] s , int end Index S , char [ ] t , int end Index T , int remaining Match Length ) { if ( Math . min ( end Index S + NUM , end Index T + NUM ) < n ) { return get Return Value ( n ) ; } if ( remaining Match Length == NUM ) { return get Return Value ( n ) ; } double result = NUM ; for ( int iS = end Index S ; iS > n - NUM ; iS -- ) { double buf = NUM ; char x = s [ iS ] ; for ( int j = NUM ; j <= end Index T ; j ++ ) { if ( t [ j ] == x ) { buf += kernel Helper LP ( n - NUM , s , iS - NUM , t , j - NUM , remaining Match Length - NUM ) ; } } result += buf * m powers Oflambda [ NUM ] ; } return result ; }
protected double kernel LP ( int n , char [ ] s , int end Index S , char [ ] t , int end Index T , int remaining Match Length ) { if ( Math . min ( end Index S + NUM , end Index T + NUM ) < n ) { return get Return Value ( n ) ; } if ( remaining Match Length == NUM ) { return get Return Value ( n ) ; } double result = NUM ; for ( int iS = end Index S ; iS > n - NUM ; iS -- ) { double buf = NUM ; char x = s [ iS ] ; for ( int j = NUM ; j <= end Index T ; j ++ ) { if ( t [ j ] == x ) { buf += kernel Helper LP ( n - NUM , s , iS - NUM , t , j - NUM , remaining Match Length - NUM ) ; } } result += buf * m powers Oflambda [ NUM ] ; } return result ; }
protected double kernel LP ( int n , char [ ] s , int end Index S , char [ ] t , int end Index T , int remaining Match Length ) { if ( Math . min ( end Index S + NUM , end Index T + NUM ) < n ) { return get Return Value ( n ) ; } if ( remaining Match Length == NUM ) { return get Return Value ( n ) ; } double result = NUM ; for ( int iS = end Index S ; iS > n - NUM ; iS -- ) { double buf = NUM ; char x = s [ iS ] ; for ( int j = NUM ; j <= end Index T ; j ++ ) { if ( t [ j ] == x ) { buf += kernel Helper LP ( n - NUM , s , iS - NUM , t , j - NUM , remaining Match Length - NUM ) ; } } result += buf * m powers Oflambda [ NUM ] ; } return result ; }
protected double kernel LP ( int n , char [ ] s , int end Index S , char [ ] t , int end Index T , int remaining Match Length ) { if ( Math . min ( end Index S + NUM , end Index T + NUM ) < n ) { return get Return Value ( n ) ; } if ( remaining Match Length == NUM ) { return get Return Value ( n ) ; } double result = NUM ; for ( int iS = end Index S ; iS > n - NUM ; iS -- ) { double buf = NUM ; char x = s [ iS ] ; for ( int j = NUM ; j <= end Index T ; j ++ ) { if ( t [ j ] == x ) { buf += kernel Helper LP ( n - NUM , s , iS - NUM , t , j - NUM , remaining Match Length - NUM ) ; } } result += buf * m powers Oflambda [ NUM ] ; } return result ; }
private void remove ( Poll Controller conn ) { if ( conn == null ) { return ; } Jni Socket Impl socket = ( Jni Socket Impl ) conn . get Socket ( ) ; int native Fd = socket . get Native Fd ( ) ; if ( lifecycle . is Destroyed ( ) ) { return ; } active Count . increment And Get ( ) ; if ( native Fd > NUM ) { try { remove Native ( fd , native Fd ) ; } catch ( Throwable e ) { log . log ( Level . WARNING , e . to String ( ) , e ) ; lifecycle . to Error ( ) ; } } conn . to Keepalive Close ( ) ; if ( active Count . decrement And Get ( ) == NUM && lifecycle . is Destroyed ( ) ) { destroy ( ) ; } }
public static final String repeat String ( String s Str , int i Times ) { String Buffer sb = new String Buffer ( ) ; for ( int i Cnt = NUM ; i Cnt < i Times ; i Cnt ++ ) sb . append ( s Str ) ; return sb . to String ( ) ; }
public void add ( int position , Product product ) { related Products . add ( position , product ) ; notify Item Inserted ( position ) ; }
public final void on Before Start ( ) { if ( ! started Flag . compare And Set ( BOOL , BOOL ) ) throw new Illegal State Exception ( STRING + STRING + STRING + this + STRING ) ; }
static int next Power Of Two ( int val ) { int highest Bit = Integer . highest One Bit ( val ) ; if ( highest Bit == val ) { return val ; } else { return highest Bit << NUM ; } }
static int next Power Of Two ( int val ) { int highest Bit = Integer . highest One Bit ( val ) ; if ( highest Bit == val ) { return val ; } else { return highest Bit << NUM ; } }
@ edu . umd . cs . findbugs . annotations . Suppress FB Warnings ( value = STRING , justification = STRING ) public void change Loco Speed ( Dcc Throttle t , Block blk , float speed ) { if ( blk == referenced && speed == desired Speed Step ) { return ; } float block Length = blk . get Length Mm ( ) ; if ( blk == referenced ) { distance Remaining = distance Remaining - get Distance Travelled ( throttle . get Is Forward ( ) , throttle . get Speed Setting ( ) , ( ( float ) ( System . nano Time ( ) - last Time Timer Started ) / NUM ) ) ; block Length = distance Remaining ; log . debug ( STRING ) ; } else { referenced = blk ; } change Loco Speed ( t , block Length , speed ) ; }
@ edu . umd . cs . findbugs . annotations . Suppress FB Warnings ( value = STRING , justification = STRING ) public void change Loco Speed ( Dcc Throttle t , Block blk , float speed ) { if ( blk == referenced && speed == desired Speed Step ) { return ; } float block Length = blk . get Length Mm ( ) ; if ( blk == referenced ) { distance Remaining = distance Remaining - get Distance Travelled ( throttle . get Is Forward ( ) , throttle . get Speed Setting ( ) , ( ( float ) ( System . nano Time ( ) - last Time Timer Started ) / NUM ) ) ; block Length = distance Remaining ; log . debug ( STRING ) ; } else { referenced = blk ; } change Loco Speed ( t , block Length , speed ) ; }
@ edu . umd . cs . findbugs . annotations . Suppress FB Warnings ( value = STRING , justification = STRING ) public void change Loco Speed ( Dcc Throttle t , Block blk , float speed ) { if ( blk == referenced && speed == desired Speed Step ) { return ; } float block Length = blk . get Length Mm ( ) ; if ( blk == referenced ) { distance Remaining = distance Remaining - get Distance Travelled ( throttle . get Is Forward ( ) , throttle . get Speed Setting ( ) , ( ( float ) ( System . nano Time ( ) - last Time Timer Started ) / NUM ) ) ; block Length = distance Remaining ; log . debug ( STRING ) ; } else { referenced = blk ; } change Loco Speed ( t , block Length , speed ) ; }
public synchronized void add ( final I Progress Operation operation ) { m operations . add ( operation ) ; for ( final I Global Progress Manager Listener listener : m listeners ) { try { listener . added ( operation ) ; } catch ( final Exception exception ) { C Utility Functions . log Exception ( exception ) ; } } }
public static Map < String , Object > perform Find List ( Dispatch Context dctx , Map < String , Object > context ) { Integer view Size = ( Integer ) context . get ( STRING ) ; if ( view Size == null ) view Size = Integer . value Of ( NUM ) ; context . put ( STRING , view Size ) ; Integer view Index = ( Integer ) context . get ( STRING ) ; if ( view Index == null ) view Index = Integer . value Of ( NUM ) ; context . put ( STRING , view Index ) ; Map < String , Object > result = perform Find ( dctx , context ) ; int start = view Index . int Value ( ) * view Size . int Value ( ) ; List < Generic Value > list = null ; Integer list Size = null ; try { Entity List Iterator it = ( Entity List Iterator ) result . get ( STRING ) ; list = it . get Partial List ( start + NUM , view Size ) ; list Size = it . get Results Size After Partial List ( ) ; it . close ( ) ; } catch ( Exception e ) { Debug . log Info ( STRING + e , module ) ; } result . put ( STRING , list Size ) ; result . put ( STRING , list ) ; result . remove ( STRING ) ; return result ; }
public void write To ( final Packet Output Stream os ) { os . write ( Parameter Writer . QUOTE ) ; os . write ( date To Bytes ( ) ) ; Parameter Writer . format Microseconds ( os , ( int ) ( time . get Time ( ) % NUM ) * NUM , fractional Seconds ) ; os . write ( Parameter Writer . QUOTE ) ; }
public void write To ( final Packet Output Stream os ) { os . write ( Parameter Writer . QUOTE ) ; os . write ( date To Bytes ( ) ) ; Parameter Writer . format Microseconds ( os , ( int ) ( time . get Time ( ) % NUM ) * NUM , fractional Seconds ) ; os . write ( Parameter Writer . QUOTE ) ; }
public static Experiment create Experiment With Rule ( ) { Experiment experiment = Experiment Factory . create Experiment ( ) ; experiment . rule = STRING ; return experiment ; }
public static void remove All Users ( ) { Preferences prefs = get Prefs ( ) ; prefs . remove ( USERS ) ; prefs . remove ( ACTIVE USER ) ; flush Prefs ( prefs ) ; }
public static void remove All Users ( ) { Preferences prefs = get Prefs ( ) ; prefs . remove ( USERS ) ; prefs . remove ( ACTIVE USER ) ; flush Prefs ( prefs ) ; }
public synchronized void search ( String search String , boolean regexp ) { int i ; Search Parameters params ; m Reg Exp Search = regexp ; m Search String = search String ; params = new Search Parameters ( m Search String , m Reg Exp Search ) ; if ( m Search String == null ) { m Display Indices = null ; } else { m Display Indices = new T Int Array List ( ) ; for ( i = NUM ; i < get Actual Row Count ( ) ; i ++ ) { if ( is Search Match ( params , m Sorted Indices [ i ] ) ) m Display Indices . add ( i ) ; } } fire Table Data Changed ( ) ; }
public synchronized void search ( String search String , boolean regexp ) { int i ; Search Parameters params ; m Reg Exp Search = regexp ; m Search String = search String ; params = new Search Parameters ( m Search String , m Reg Exp Search ) ; if ( m Search String == null ) { m Display Indices = null ; } else { m Display Indices = new T Int Array List ( ) ; for ( i = NUM ; i < get Actual Row Count ( ) ; i ++ ) { if ( is Search Match ( params , m Sorted Indices [ i ] ) ) m Display Indices . add ( i ) ; } } fire Table Data Changed ( ) ; }
private double round ( double value , int places ) { if ( places < NUM ) throw new Illegal Argument Exception ( ) ; long factor = ( long ) Math . pow ( NUM , places ) ; value = value * factor ; long tmp = Math . round ( value ) ; return ( double ) tmp / factor ; }
private double round ( double value , int places ) { if ( places < NUM ) throw new Illegal Argument Exception ( ) ; long factor = ( long ) Math . pow ( NUM , places ) ; value = value * factor ; long tmp = Math . round ( value ) ; return ( double ) tmp / factor ; }
public static float compute Discard Alpha ( float amount , float range ) { if ( Math . abs ( amount ) < NUM ) return NUM ; float t = amount / range ; t = Math Utils . clamp ( t , - NUM , NUM ) ; return NUM - Math . abs ( t ) ; }
public static void front End Initialize ( Spec Obj spec , Print Stream syserr ) throws Init Exception { String file Name = spec . get File Name ( ) ; Errors init Errors = spec . init Errors ; try { Configuration . Re Init ( ) ; Context . re Init ( ) ; Configuration . load ( init Errors ) ; Built In Level . load ( ) ; if ( ! init Errors . is Success ( ) ) { syserr . println ( STRING ) ; syserr . print ( init Errors ) ; spec . error Level = NUM ; throw new Init Exception ( ) ; } } catch ( Exception e ) { syserr . println ( STRING + file Name + STRING + e ) ; syserr . println ( STRING + STRING ) ; syserr . print ( init Errors ) ; spec . error Level = NUM ; throw new Init Exception ( ) ; } return ; }
public static void front End Initialize ( Spec Obj spec , Print Stream syserr ) throws Init Exception { String file Name = spec . get File Name ( ) ; Errors init Errors = spec . init Errors ; try { Configuration . Re Init ( ) ; Context . re Init ( ) ; Configuration . load ( init Errors ) ; Built In Level . load ( ) ; if ( ! init Errors . is Success ( ) ) { syserr . println ( STRING ) ; syserr . print ( init Errors ) ; spec . error Level = NUM ; throw new Init Exception ( ) ; } } catch ( Exception e ) { syserr . println ( STRING + file Name + STRING + e ) ; syserr . println ( STRING + STRING ) ; syserr . print ( init Errors ) ; spec . error Level = NUM ; throw new Init Exception ( ) ; } return ; }
public static void front End Initialize ( Spec Obj spec , Print Stream syserr ) throws Init Exception { String file Name = spec . get File Name ( ) ; Errors init Errors = spec . init Errors ; try { Configuration . Re Init ( ) ; Context . re Init ( ) ; Configuration . load ( init Errors ) ; Built In Level . load ( ) ; if ( ! init Errors . is Success ( ) ) { syserr . println ( STRING ) ; syserr . print ( init Errors ) ; spec . error Level = NUM ; throw new Init Exception ( ) ; } } catch ( Exception e ) { syserr . println ( STRING + file Name + STRING + e ) ; syserr . println ( STRING + STRING ) ; syserr . print ( init Errors ) ; spec . error Level = NUM ; throw new Init Exception ( ) ; } return ; }
public void unregister Receiver ( Context context ) { m Handler . remove Callbacks ( m Service Runnable ) ; if ( m Is Registered . get And Set ( BOOL ) ) { context . unregister Receiver ( this ) ; m Need To Run Actions . set ( BOOL ) ; } }
public void unregister Receiver ( Context context ) { m Handler . remove Callbacks ( m Service Runnable ) ; if ( m Is Registered . get And Set ( BOOL ) ) { context . unregister Receiver ( this ) ; m Need To Run Actions . set ( BOOL ) ; } }
public void unregister Receiver ( Context context ) { m Handler . remove Callbacks ( m Service Runnable ) ; if ( m Is Registered . get And Set ( BOOL ) ) { context . unregister Receiver ( this ) ; m Need To Run Actions . set ( BOOL ) ; } }
public void unregister Receiver ( Context context ) { m Handler . remove Callbacks ( m Service Runnable ) ; if ( m Is Registered . get And Set ( BOOL ) ) { context . unregister Receiver ( this ) ; m Need To Run Actions . set ( BOOL ) ; } }
void fix Compatibility ( View root ) { Queue < View > queue = new Linked List < View > ( ) ; queue . add ( root ) ; View view = null ; while ( ( view = queue . poll ( ) ) != null ) { if ( view instanceof View Group ) { View Group group = ( View Group ) view ; for ( int i = NUM ; i < group . get Child Count ( ) ; i ++ ) { queue . add ( group . get Child At ( i ) ) ; } } } }
void fix Compatibility ( View root ) { Queue < View > queue = new Linked List < View > ( ) ; queue . add ( root ) ; View view = null ; while ( ( view = queue . poll ( ) ) != null ) { if ( view instanceof View Group ) { View Group group = ( View Group ) view ; for ( int i = NUM ; i < group . get Child Count ( ) ; i ++ ) { queue . add ( group . get Child At ( i ) ) ; } } } }
void fix Compatibility ( View root ) { Queue < View > queue = new Linked List < View > ( ) ; queue . add ( root ) ; View view = null ; while ( ( view = queue . poll ( ) ) != null ) { if ( view instanceof View Group ) { View Group group = ( View Group ) view ; for ( int i = NUM ; i < group . get Child Count ( ) ; i ++ ) { queue . add ( group . get Child At ( i ) ) ; } } } }
void fix Compatibility ( View root ) { Queue < View > queue = new Linked List < View > ( ) ; queue . add ( root ) ; View view = null ; while ( ( view = queue . poll ( ) ) != null ) { if ( view instanceof View Group ) { View Group group = ( View Group ) view ; for ( int i = NUM ; i < group . get Child Count ( ) ; i ++ ) { queue . add ( group . get Child At ( i ) ) ; } } } }
public static String strip Meta From Name ( String file Name ) { int end = file Name . index Of ( STRING ) ; if ( end == - NUM ) end = file Name . index Of ( STRING ) ; if ( end == - NUM ) return file Name ; return file Name . substring ( NUM , end ) ; }
public static String strip Meta From Name ( String file Name ) { int end = file Name . index Of ( STRING ) ; if ( end == - NUM ) end = file Name . index Of ( STRING ) ; if ( end == - NUM ) return file Name ; return file Name . substring ( NUM , end ) ; }
public DOM 4 J Test Document Builder Factory ( Document Builder Setting [ ] settings ) throws DOM Test Incompatible Exception { super ( settings ) ; try { Class Loader class Loader = Class Loader . get System Class Loader ( ) ; Class dom Factory Class = class Loader . load Class ( STRING ) ; Method get Instance = dom Factory Class . get Method ( STRING , new Class [ ] { } ) ; dom Factory = get Instance . invoke ( null , new Object [ ] { } ) ; dom Impl = ( DOM Implementation ) dom Factory ; Class sax Reader Class = class Loader . load Class ( STRING ) ; Constructor sax Reader Constructor = sax Reader Class . get Constructor ( new Class [ ] { class Loader . load Class ( STRING ) } ) ; sax Reader = sax Reader Constructor . new Instance ( new Object [ ] { dom Factory } ) ; Method get Reader Method = sax Reader Class . get Method ( STRING , new Class [ ] { } ) ; xml Reader = ( XML Reader ) get Reader Method . invoke ( sax Reader , new Object [ NUM ] ) ; read Method = sax Reader Class . get Method ( STRING , new Class [ ] { java . net . URL . class } ) ; } catch ( Invocation Target Exception ex ) { throw new DOM Test Incompatible Exception ( ex . get Target Exception ( ) , null ) ; } catch ( Exception ex ) { throw new DOM Test Incompatible Exception ( ex , null ) ; } }
@ Override public boolean is Account Non Expired ( ) { return BOOL ; }
@ Override public boolean is Account Non Expired ( ) { return BOOL ; }
private Bitmap add Thumbnail To Cache ( String image Key , Bitmap bitmap , String path , int px ) { Bitmap thumbnail = Thumbnail Utils . extract Thumbnail ( bitmap , px , px ) ; thumbnail = Bitmap Utils . rotate Image ( thumbnail , path ) ; add Bitmap To Cache ( image Key , thumbnail ) ; return thumbnail ; }
@ Override public String graph ( ) throws Exception { String Buffer text = new String Buffer ( ) ; text . append ( STRING ) ; if ( m is Leaf ) { text . append ( STRING + m id + STRING + STRING + STRING + STRING ) ; if ( m train != null && m train . num Instances ( ) > NUM ) { text . append ( STRING + m train + STRING ) ; text . append ( STRING ) ; } text . append ( STRING ) ; } else { text . append ( STRING + m id + STRING + Utils . back Quote Chars ( m local Model . left Side ( m train ) ) + STRING ) ; if ( m train != null && m train . num Instances ( ) > NUM ) { text . append ( STRING + m train + STRING ) ; text . append ( STRING ) ; } text . append ( STRING ) ; graph Tree ( text ) ; } return text . to String ( ) + STRING ; }
@ Override public String graph ( ) throws Exception { String Buffer text = new String Buffer ( ) ; text . append ( STRING ) ; if ( m is Leaf ) { text . append ( STRING + m id + STRING + STRING + STRING + STRING ) ; if ( m train != null && m train . num Instances ( ) > NUM ) { text . append ( STRING + m train + STRING ) ; text . append ( STRING ) ; } text . append ( STRING ) ; } else { text . append ( STRING + m id + STRING + Utils . back Quote Chars ( m local Model . left Side ( m train ) ) + STRING ) ; if ( m train != null && m train . num Instances ( ) > NUM ) { text . append ( STRING + m train + STRING ) ; text . append ( STRING ) ; } text . append ( STRING ) ; graph Tree ( text ) ; } return text . to String ( ) + STRING ; }
private File find Settings File ( String context ) { File user Dir = new File ( Platform Util . get User Home Dir ( ) ) ; String Builder path = new String Builder ( ) ; String [ ] parts = context . split ( STRING ) ; for ( String part : parts ) { path . append ( part ) ; path . append ( File . separator ) ; } File settings File = new File ( user Dir , STRING + File . separator + path . to String ( ) + STRING ) ; if ( ! settings File . exists ( ) ) { Logger . log ( get Class ( ) , Log Level . WARNING , STRING , settings File ) ; return null ; } return settings File ; }
@ Not Null public Message Builder type ( @ Not Null Message Type type ) { types . add ( type ) ; return this ; }
@ Not Null public Message Builder type ( @ Not Null Message Type type ) { types . add ( type ) ; return this ; }
@ Not Null public Message Builder type ( @ Not Null Message Type type ) { types . add ( type ) ; return this ; }
@ Not Null public Message Builder type ( @ Not Null Message Type type ) { types . add ( type ) ; return this ; }
@ Not Null public Message Builder type ( @ Not Null Message Type type ) { types . add ( type ) ; return this ; }
@ Not Null public Message Builder type ( @ Not Null Message Type type ) { types . add ( type ) ; return this ; }
public Timestamp random Timestamp ( ) { if ( random . next Int ( NUM ) == NUM ) { return null ; } String Builder buff = new String Builder ( ) ; buff . append ( get Int ( NUM ) + NUM ) ; buff . append ( STRING ) ; int month = get Int ( NUM ) + NUM ; if ( month < NUM ) { buff . append ( STRING ) ; } buff . append ( month ) ; buff . append ( STRING ) ; int day = get Int ( NUM ) + NUM ; if ( day < NUM ) { buff . append ( STRING ) ; } buff . append ( day ) ; buff . append ( STRING ) ; int hour = get Int ( NUM ) ; if ( hour < NUM ) { buff . append ( STRING ) ; } buff . append ( hour ) ; buff . append ( STRING ) ; int minute = get Int ( NUM ) ; if ( minute < NUM ) { buff . append ( STRING ) ; } buff . append ( minute ) ; buff . append ( STRING ) ; int second = get Int ( NUM ) ; if ( second < NUM ) { buff . append ( STRING ) ; } buff . append ( second ) ; return Timestamp . value Of ( buff . to String ( ) ) ; }
public void put ( int key , int value ) { int i = binary Search ( m Keys , NUM , m Size , key ) ; if ( i >= NUM ) { m Values [ i ] = value ; } else { i = ~ i ; if ( m Size >= m Keys . length ) { int n = Math . max ( m Size + NUM , m Keys . length * NUM ) ; int [ ] nkeys = new int [ n ] ; int [ ] nvalues = new int [ n ] ; System . arraycopy ( m Keys , NUM , nkeys , NUM , m Keys . length ) ; System . arraycopy ( m Values , NUM , nvalues , NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } if ( m Size - i != NUM ) { System . arraycopy ( m Keys , i , m Keys , i + NUM , m Size - i ) ; System . arraycopy ( m Values , i , m Values , i + NUM , m Size - i ) ; } m Keys [ i ] = key ; m Values [ i ] = value ; m Size ++ ; } }
private void internal Remove ( final Object [ ] elements ) { Object input = get Input ( ) ; for ( int i = NUM ; i < elements . length ; ++ i ) { if ( equals ( elements [ i ] , input ) ) { set Input ( null ) ; return ; } int ix = get Element Index ( elements [ i ] ) ; if ( ix >= NUM ) { Check Item item = list Remove ( ix ) ; list Map . remove ( ix ) ; unmap Element ( elements [ i ] , item . get Control ( ) ) ; } } }
public static < T > T show Dialog ( Window Based Text GUI text GUI , String title , String description , int list Box Height , T ... items ) { int width = NUM ; for ( T item : items ) { width = Math . max ( width , Terminal Text Utils . get Column Width ( item . to String ( ) ) ) ; } width += NUM ; return show Dialog ( text GUI , title , description , new Terminal Size ( width , list Box Height ) , items ) ; }
public Gamma Inv Fitness Function ( int genome Length , double alpha , double beta , double p Inv , int state Size , boolean random Fittest ) { Gamma Distribution gamma = new Gamma Distribution ( beta , alpha ) ; fitness = new double [ genome Length ] [ state Size ] ; fittest = new byte [ genome Length ] ; int fitpos = NUM ; for ( int i = NUM ; i < genome Length ; i ++ ) { if ( random Fittest ) { fitpos = Math Utils . next Int ( state Size ) ; } fitness [ i ] [ fitpos ] = NUM ; fittest [ i ] = ( byte ) fitpos ; for ( int j = NUM ; j < state Size ; j ++ ) { if ( j != fitpos ) { if ( Math Utils . next Double ( ) > p Inv ) { double prob = Math . round ( Math Utils . next Double ( ) * NUM ) / NUM ; while ( ( prob <= NUM ) || ( prob >= NUM ) ) { prob = Math . round ( Math Utils . next Double ( ) * NUM ) / NUM ; } fitness [ i ] [ j ] = Math . max ( NUM , NUM - gamma . quantile ( prob ) ) ; } else { fitness [ i ] [ j ] = NUM ; } } } } }
private void grow Spine ( ) { int size = ( spine . length << NUM ) + NUM ; spine = new int [ size ] ; spine Empty = new int [ size ] ; threshold = ( int ) ( spine . length * load Factor ) ; Arrays . fill ( spine Empty , - NUM ) ; Grid Unsafe . copy Memory ( spine Empty , INT ARR OFF , spine , INT ARR OFF , spine Empty . length << NUM ) ; for ( int i = NUM ; i < this . size ; i ++ ) { Object obj = objs [ i ] ; int idx = hash ( obj ) % spine . length ; insert ( objs [ i ] , i , idx ) ; } }
public static < T > Database Table Config < T > from Class ( Connection Source connection Source , Class < T > clazz ) throws SQL Exception { Database Type database Type = connection Source . get Database Type ( ) ; String table Name = Database Table Config . extract Table Name ( clazz ) ; List < Database Field Config > field Configs = new Array List < Database Field Config > ( ) ; for ( Class < ? > class Walk = clazz ; class Walk != null ; class Walk = class Walk . get Superclass ( ) ) { for ( Field field : class Walk . get Declared Fields ( ) ) { Database Field Config config = config From Field ( database Type , table Name , field ) ; if ( config != null && config . is Persisted ( ) ) { field Configs . add ( config ) ; } } } if ( field Configs . size ( ) == NUM ) { return null ; } else { return new Database Table Config < T > ( clazz , table Name , field Configs ) ; } }
public String to String ( ) { String Builder result = new String Builder ( ) ; result . append ( STRING ) ; result . append ( klazz . get Name ( ) ) ; result . append ( STRING ) ; for ( int i = NUM ; i < elements . length ; ++ i ) { if ( i != NUM ) { result . append ( STRING ) ; } result . append ( elements [ i ] ) ; } result . append ( STRING ) ; return result . to String ( ) ; }
private boolean check For Double Spend Against Pending ( Transaction tx , boolean take Action ) { check State ( lock . is Held By Current Thread ( ) ) ; Hash Set < Transaction Out Point > outpoints = new Hash Set < Transaction Out Point > ( ) ; for ( Transaction Input input : tx . get Inputs ( ) ) { outpoints . add ( input . get Outpoint ( ) ) ; } Linked List < Transaction > double Spent Txns = Lists . new Linked List ( ) ; for ( Transaction p : pending . values ( ) ) { for ( Transaction Input input : p . get Inputs ( ) ) { Transaction Out Point outpoint = input . get Outpoint ( ) ; if ( outpoints . contains ( outpoint ) ) { if ( ! double Spent Txns . is Empty ( ) && double Spent Txns . get Last ( ) == p ) continue ; double Spent Txns . add ( p ) ; } } } if ( take Action && ! double Spent Txns . is Empty ( ) ) { kill Tx ( tx , double Spent Txns ) ; } return ! double Spent Txns . is Empty ( ) ; }
private boolean check For Double Spend Against Pending ( Transaction tx , boolean take Action ) { check State ( lock . is Held By Current Thread ( ) ) ; Hash Set < Transaction Out Point > outpoints = new Hash Set < Transaction Out Point > ( ) ; for ( Transaction Input input : tx . get Inputs ( ) ) { outpoints . add ( input . get Outpoint ( ) ) ; } Linked List < Transaction > double Spent Txns = Lists . new Linked List ( ) ; for ( Transaction p : pending . values ( ) ) { for ( Transaction Input input : p . get Inputs ( ) ) { Transaction Out Point outpoint = input . get Outpoint ( ) ; if ( outpoints . contains ( outpoint ) ) { if ( ! double Spent Txns . is Empty ( ) && double Spent Txns . get Last ( ) == p ) continue ; double Spent Txns . add ( p ) ; } } } if ( take Action && ! double Spent Txns . is Empty ( ) ) { kill Tx ( tx , double Spent Txns ) ; } return ! double Spent Txns . is Empty ( ) ; }
private boolean check For Double Spend Against Pending ( Transaction tx , boolean take Action ) { check State ( lock . is Held By Current Thread ( ) ) ; Hash Set < Transaction Out Point > outpoints = new Hash Set < Transaction Out Point > ( ) ; for ( Transaction Input input : tx . get Inputs ( ) ) { outpoints . add ( input . get Outpoint ( ) ) ; } Linked List < Transaction > double Spent Txns = Lists . new Linked List ( ) ; for ( Transaction p : pending . values ( ) ) { for ( Transaction Input input : p . get Inputs ( ) ) { Transaction Out Point outpoint = input . get Outpoint ( ) ; if ( outpoints . contains ( outpoint ) ) { if ( ! double Spent Txns . is Empty ( ) && double Spent Txns . get Last ( ) == p ) continue ; double Spent Txns . add ( p ) ; } } } if ( take Action && ! double Spent Txns . is Empty ( ) ) { kill Tx ( tx , double Spent Txns ) ; } return ! double Spent Txns . is Empty ( ) ; }
public void array Length ( ) { mv . visit Insn ( Opcodes . ARRAYLENGTH ) ; }
protected void process ( List < String > messages ) { set Status Bar Message ( messages . get ( messages . size ( ) - NUM ) , Base Panel . INFORMATION ) ; }
private void push Stack ( int new Top ) { if ( stack Size == stack . length ) { int [ ] new Stack = new int [ stack Size * NUM ] ; int [ ] new Path Indices = new int [ stack Size * NUM ] ; String [ ] new Path Names = new String [ stack Size * NUM ] ; System . arraycopy ( stack , NUM , new Stack , NUM , stack Size ) ; System . arraycopy ( path Indices , NUM , new Path Indices , NUM , stack Size ) ; System . arraycopy ( path Names , NUM , new Path Names , NUM , stack Size ) ; stack = new Stack ; path Indices = new Path Indices ; path Names = new Path Names ; } stack [ stack Size ++ ] = new Top ; }
Computing Impl ( Computing Strategy < K , V , E > strategy , Builder builder , Function < ? super K , ? extends V > computer ) { super ( strategy , builder ) ; this . computing Strategy = strategy ; this . computer = computer ; }
@ Override public boolean on Options Item Selected ( Menu Item item ) { switch ( item . get Item Id ( ) ) { case android . R . id . home : finish ( ) ; return BOOL ; default : return super . on Options Item Selected ( item ) ; } }
public final Test Subscriber assert Value ( Tuple < String , String > value ) { String prefix = STRING ; boolean passed = BOOL ; if ( done . get Count ( ) != NUM ) { prefix = STRING ; } int s = values . size ( ) ; if ( s != NUM ) { fail ( prefix , STRING + value + STRING + values , errors ) ; fail ( STRING ) ; passed = BOOL ; } Tuple < String , String > v = values . get ( NUM ) ; if ( ! Objects . equals ( value , v ) ) { fail ( prefix , STRING + value And Class ( value ) + STRING + value And Class ( v ) , errors ) ; fail ( STRING ) ; passed = BOOL ; } pass ( STRING , passed ) ; return this ; }
public final Test Subscriber assert Value ( Tuple < String , String > value ) { String prefix = STRING ; boolean passed = BOOL ; if ( done . get Count ( ) != NUM ) { prefix = STRING ; } int s = values . size ( ) ; if ( s != NUM ) { fail ( prefix , STRING + value + STRING + values , errors ) ; fail ( STRING ) ; passed = BOOL ; } Tuple < String , String > v = values . get ( NUM ) ; if ( ! Objects . equals ( value , v ) ) { fail ( prefix , STRING + value And Class ( value ) + STRING + value And Class ( v ) , errors ) ; fail ( STRING ) ; passed = BOOL ; } pass ( STRING , passed ) ; return this ; }
@ Override public String update ( String xml ) { try { return query ( STRING + URL Encoder . encode ( xml , STRING ) ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
@ Override public String update ( String xml ) { try { return query ( STRING + URL Encoder . encode ( xml , STRING ) ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
@ Override public String update ( String xml ) { try { return query ( STRING + URL Encoder . encode ( xml , STRING ) ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
private static boolean trust Get Context Class Loader ( Thread t ) { Class cl = t . get Class ( ) ; if ( cl == Thread . class ) { return BOOL ; } Boolean b ; synchronized ( trust Get CCL ) { b = ( Boolean ) trust Get CCL . get ( cl ) ; } if ( b == null ) { b = trust Get Context Class Loader 0 ( cl ) ; synchronized ( trust Get CCL ) { trust Get CCL . put ( cl , b ) ; } } return b . boolean Value ( ) ; }
private static boolean trust Get Context Class Loader ( Thread t ) { Class cl = t . get Class ( ) ; if ( cl == Thread . class ) { return BOOL ; } Boolean b ; synchronized ( trust Get CCL ) { b = ( Boolean ) trust Get CCL . get ( cl ) ; } if ( b == null ) { b = trust Get Context Class Loader 0 ( cl ) ; synchronized ( trust Get CCL ) { trust Get CCL . put ( cl , b ) ; } } return b . boolean Value ( ) ; }
private static boolean trust Get Context Class Loader ( Thread t ) { Class cl = t . get Class ( ) ; if ( cl == Thread . class ) { return BOOL ; } Boolean b ; synchronized ( trust Get CCL ) { b = ( Boolean ) trust Get CCL . get ( cl ) ; } if ( b == null ) { b = trust Get Context Class Loader 0 ( cl ) ; synchronized ( trust Get CCL ) { trust Get CCL . put ( cl , b ) ; } } return b . boolean Value ( ) ; }
protected boolean shard Available ( @ Nullable Index Shard shard ) { return shard != null && shard . can Index ( ) && CAN UPDATE INDEX BUFFER STATES . contains ( shard . state ( ) ) ; }
private void validate Expected Partition Values Create Request ( Expected Partition Values Create Request expected Partition Values Create Request ) { partition Key Group Helper . validate Partition Key Group Key ( expected Partition Values Create Request . get Partition Key Group Key ( ) ) ; expected Partition Values Create Request . set Expected Partition Values ( validate Expected Partition Values ( expected Partition Values Create Request . get Expected Partition Values ( ) ) ) ; }
public boolean has Attribute ( final Attribute Type attribute Type ) { return attributes . contains ( attribute Type ) ; }
public void member Joined ( Client Membership Event event ) { Notification notification = new Notification ( JMX Notification Type . CLIENT JOINED , server Source , Sequence Number . next ( ) , System . current Time Millis ( ) , Management Constants . CLIENT JOINED PREFIX + event . get Member Id ( ) ) ; server Level Notif Emitter . send Notification ( notification ) ; member Level Notif Emitter . send Notification ( notification ) ; }
public static String escape String ( final String string ) { if ( string . index Of ( DELIMITER COMPONENT ) < NUM ) { final int length = string . length ( ) ; final String Buffer buffer = new String Buffer ( length + NUM ) ; for ( int index = NUM ; index < length ; index ++ ) { final char character = string . char At ( index ) ; if ( DELIMITER COMPONENT == character ) buffer . append ( DELIMITER COMPONENT ) ; buffer . append ( character ) ; } return buffer . to String ( ) ; } return string ; }
private void check No More Atts ( Atts atts ) throws RDF Parse Exception { if ( atts . size ( ) > NUM ) { Iterator < Att > iter = atts . iterator ( ) ; while ( iter . has Next ( ) ) { Att att = iter . next ( ) ; report Error ( STRING + att . get Q Name ( ) + STRING , XML Parser Settings . FAIL ON NON STANDARD ATTRIBUTES ) ; iter . remove ( ) ; } } }
public static String pad And Truncate String ( String s , int field Size ) { return pad And Truncate String ( s , field Size , Setup . is Tab Enabled ( ) ) ; }
public static String pad And Truncate String ( String s , int field Size ) { return pad And Truncate String ( s , field Size , Setup . is Tab Enabled ( ) ) ; }
public static String pad And Truncate String ( String s , int field Size ) { return pad And Truncate String ( s , field Size , Setup . is Tab Enabled ( ) ) ; }
public boolean is Rsl Url Signed ( String url ) { if ( url == null ) { return BOOL ; } return url . ends With ( SIGNED RSL URL DOT EXTENSION ) ; }
public boolean is Rsl Url Signed ( String url ) { if ( url == null ) { return BOOL ; } return url . ends With ( SIGNED RSL URL DOT EXTENSION ) ; }
@ Override public boolean done ( ) { if ( stopping Increments && increments Left == NUM ) return BOOL ; else return BOOL ; }
public Projection Stack ( ) { }
@ Suppress Warnings ( { STRING } ) public File generate ( ) throws IO Exception { File script Path = File Util . create Temp File ( my Prefix , SCRIPT EXT ) ; script Path . delete On Exit ( ) ; Print Writer out = new Print Writer ( new File Writer ( script Path ) ) ; try { if ( System Info . is Windows ) { out . println ( STRING ) ; } else { out . println ( STRING ) ; } String line = command Line ( ) ; if ( System Info . is Windows ) { line += STRING ; } else { line += STRING ; } out . println ( line ) ; } finally { out . close ( ) ; } File Util . set Executable Attribute ( script Path . get Path ( ) , BOOL ) ; return script Path ; }
public void for Each Block Depth First ( boolean reverse , Ssa Basic Block . Visitor v ) { Bit Set visited = new Bit Set ( blocks . size ( ) ) ; Stack < Ssa Basic Block > stack = new Stack < Ssa Basic Block > ( ) ; Ssa Basic Block root Block = reverse ? get Exit Block ( ) : get Entry Block ( ) ; if ( root Block == null ) { return ; } stack . add ( null ) ; stack . add ( root Block ) ; while ( stack . size ( ) > NUM ) { Ssa Basic Block cur = stack . pop ( ) ; Ssa Basic Block parent = stack . pop ( ) ; if ( ! visited . get ( cur . get Index ( ) ) ) { Bit Set children = reverse ? cur . get Predecessors ( ) : cur . get Successors ( ) ; for ( int i = children . next Set Bit ( NUM ) ; i >= NUM ; i = children . next Set Bit ( i + NUM ) ) { stack . add ( cur ) ; stack . add ( blocks . get ( i ) ) ; } visited . set ( cur . get Index ( ) ) ; v . visit Block ( cur , parent ) ; } } }
private byte [ ] create Haystack ( byte [ ] needle , int position , int size ) { byte [ ] haystack = new byte [ size ] ; for ( int i = position , j = NUM ; i < size && j < needle . length ; i ++ , j ++ ) { haystack [ i ] = needle [ j ] ; } return haystack ; }
private byte [ ] create Haystack ( byte [ ] needle , int position , int size ) { byte [ ] haystack = new byte [ size ] ; for ( int i = position , j = NUM ; i < size && j < needle . length ; i ++ , j ++ ) { haystack [ i ] = needle [ j ] ; } return haystack ; }
private byte [ ] create Haystack ( byte [ ] needle , int position , int size ) { byte [ ] haystack = new byte [ size ] ; for ( int i = position , j = NUM ; i < size && j < needle . length ; i ++ , j ++ ) { haystack [ i ] = needle [ j ] ; } return haystack ; }
private byte [ ] create Haystack ( byte [ ] needle , int position , int size ) { byte [ ] haystack = new byte [ size ] ; for ( int i = position , j = NUM ; i < size && j < needle . length ; i ++ , j ++ ) { haystack [ i ] = needle [ j ] ; } return haystack ; }
public Interval reverse This ( ) { return Interval . from To By ( this . to , this . from , - this . step ) ; }
public static < T > T [ ] copy From ( T [ ] array , int new Length ) { T [ ] copy = create With Same Component Type ( new Length , array ) ; System . arraycopy ( array , NUM , copy , NUM , Math . min ( array . length , new Length ) ) ; return copy ; }
public int create Binomial ( final int n , final double p ) { double value = p ; final String Builder bits = new String Builder ( NUM ) ; double bit Value = NUM ; while ( value > NUM ) { if ( value >= bit Value ) { bits . append ( STRING ) ; value -= bit Value ; } else { bits . append ( STRING ) ; } bit Value /= NUM ; } final Bit String p Bits = new Bit String ( bits . to String ( ) ) ; int trials = n ; int total Successes = NUM ; int p Index = p Bits . get Length ( ) - NUM ; while ( trials > NUM && p Index >= NUM ) { final Bit String bs = new Bit String ( trials , generator ) ; final int successes = bs . count Set Bits ( ) ; trials -= successes ; if ( p Bits . get Bit ( p Index ) ) { total Successes += successes ; } -- p Index ; } return total Successes ; }
public static boolean is Snapshot Full Copy Supported ( URI block Snap URI , Db Client db Client ) { Block Snapshot block Obj = db Client . query Object ( Block Snapshot . class , block Snap URI ) ; Storage System storage = db Client . query Object ( Storage System . class , block Obj . get Storage Controller ( ) ) ; return ( storage != null && ( storage . device Is Type ( Type . openstack ) || storage . device Is Type ( Type . vnxblock ) || storage . device Is Type ( Type . ibmxiv ) || storage . device Is Type ( Type . vmax ) ) ) ; }
public static boolean is Snapshot Full Copy Supported ( URI block Snap URI , Db Client db Client ) { Block Snapshot block Obj = db Client . query Object ( Block Snapshot . class , block Snap URI ) ; Storage System storage = db Client . query Object ( Storage System . class , block Obj . get Storage Controller ( ) ) ; return ( storage != null && ( storage . device Is Type ( Type . openstack ) || storage . device Is Type ( Type . vnxblock ) || storage . device Is Type ( Type . ibmxiv ) || storage . device Is Type ( Type . vmax ) ) ) ; }
@ Override public boolean ready ( ) throws IO Exception { synchronized ( lock ) { check Not Closed ( ) ; return ( ( end - pos ) > NUM ) || in . ready ( ) ; } }
@ Override public boolean ready ( ) throws IO Exception { synchronized ( lock ) { check Not Closed ( ) ; return ( ( end - pos ) > NUM ) || in . ready ( ) ; } }
public double [ ] distribution For Instance ( Instance instance ) throws Exception { double [ ] prob Of Class Given Doc = new double [ m num Classes ] ; double [ ] log Doc Given Class = new double [ m num Classes ] ; for ( int h = NUM ; h < m num Classes ; h ++ ) log Doc Given Class [ h ] = prob Of Doc Given Class ( instance , h ) ; double max = log Doc Given Class [ Utils . max Index ( log Doc Given Class ) ] ; double prob Of Doc = NUM ; for ( int i = NUM ; i < m num Classes ; i ++ ) { prob Of Class Given Doc [ i ] = Math . exp ( log Doc Given Class [ i ] - max ) * m prob Of Class [ i ] ; prob Of Doc += prob Of Class Given Doc [ i ] ; } Utils . normalize ( prob Of Class Given Doc , prob Of Doc ) ; return prob Of Class Given Doc ; }
@ Override public Request < List < Runner Status > > processes ( Project Reference project Reference ) { List < Dummy Runner Status > current = current Runner Statuses . get ( project Reference . name ( ) ) ; List < Runner Status > update = new Array List < > ( ) ; if ( current != null ) { for ( Dummy Runner Status dummy Runner Status : current ) { update . add ( dummy Runner Status ) ; } } return new Dummy Request < > ( update ) ; }
public static String to JSON String ( Map map ) { final String Writer writer = new String Writer ( ) ; try { write JSON String ( map , writer ) ; return writer . to String ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public static String to JSON String ( Map map ) { final String Writer writer = new String Writer ( ) ; try { write JSON String ( map , writer ) ; return writer . to String ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public static String to JSON String ( Map map ) { final String Writer writer = new String Writer ( ) ; try { write JSON String ( map , writer ) ; return writer . to String ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
protected String translate Column Name ( String column Name ) { return column Name . replace All ( STRING , STRING ) ; }
protected String translate Column Name ( String column Name ) { return column Name . replace All ( STRING , STRING ) ; }
protected String translate Column Name ( String column Name ) { return column Name . replace All ( STRING , STRING ) ; }
protected String translate Column Name ( String column Name ) { return column Name . replace All ( STRING , STRING ) ; }
public void action Performed ( Action Event e ) { J Text Pane pane ; Document Printing doc ; pane = new Code Pane ( ) ; pane . set Text ( m Text Code . get Text ( ) ) ; doc = new Document Printing ( ) ; doc . print ( pane ) ; }
public static void sort Methods ( Method Binding [ ] sorted Methods , int left , int right ) { Arrays . sort ( sorted Methods , left , right , METHOD COMPARATOR ) ; }
public static void sort Methods ( Method Binding [ ] sorted Methods , int left , int right ) { Arrays . sort ( sorted Methods , left , right , METHOD COMPARATOR ) ; }
public static void sort Methods ( Method Binding [ ] sorted Methods , int left , int right ) { Arrays . sort ( sorted Methods , left , right , METHOD COMPARATOR ) ; }
public void add Revision ( int revnumber , String date , String authorinitials , String revremark ) { Revision r = new Revision ( ) ; r . revnumber = revnumber ; r . date = date ; r . authorinitials = authorinitials ; r . revremark = revremark ; list . add ( r ) ; }
public Workflow . Method verify Datastore Method ( URI export Group , URI vcenter , URI vcenter Datacenter ) { return new Workflow . Method ( STRING , export Group , vcenter , vcenter Datacenter ) ; }
public Workflow . Method verify Datastore Method ( URI export Group , URI vcenter , URI vcenter Datacenter ) { return new Workflow . Method ( STRING , export Group , vcenter , vcenter Datacenter ) ; }
public Workflow . Method verify Datastore Method ( URI export Group , URI vcenter , URI vcenter Datacenter ) { return new Workflow . Method ( STRING , export Group , vcenter , vcenter Datacenter ) ; }
public Workflow . Method verify Datastore Method ( URI export Group , URI vcenter , URI vcenter Datacenter ) { return new Workflow . Method ( STRING , export Group , vcenter , vcenter Datacenter ) ; }
public void remove Item ( int position ) { m Datas . remove ( position ) ; notify Item Removed ( position ) ; }
public Message Formatter remove Message Formatter ( String domain ) { return ( Message Formatter ) f Message Formatters . remove ( domain ) ; }
public Message Formatter remove Message Formatter ( String domain ) { return ( Message Formatter ) f Message Formatters . remove ( domain ) ; }
private static void insert Value Using If Not Empty ( final Map < String , List < String > > params Map , final String param Val , final String parameter Name ) { if ( String Utils . is Not Empty ( param Val ) ) { List < String > list = new Array List < > ( ) ; list . add ( param Val ) ; params Map . put ( parameter Name , list ) ; } }
public void key Pressed ( final Key Event k ) { if ( k . get Key Code ( ) == Key Event . VK SPACE ) { } if ( k . get Key Code ( ) != Key Event . VK SPACE ) { } repaint ( ) ; }
private Point calculate Location ( int position , Rectangle bounds , Dimension size , int offset ) { Point location = new Point ( ) ; location . x = bounds . x - horizontal Move Direction * HORIZONTAL MARGIN ; location . y = bounds . y ; if ( position == NUM || position == NUM ) { location . x += ( bounds . width - size . width ) ; } if ( position == NUM || position == NUM ) { location . y += ( bounds . height - size . height ) ; offset = - offset ; } location . y += offset ; return location ; }
public static void put PW Stat ( long id , Stat type , double s ) { if ( disabled ) return ; if ( ! pwstats . contains Key ( id ) ) pwstats . put ( id , new Hash Map < Stat , Linked List < Double > > ( ) ) ; Hash Map < Stat , Linked List < Double > > allstats = pwstats . get ( id ) ; if ( ! allstats . contains Key ( type ) ) allstats . put ( type , new Linked List < Double > ( ) ) ; Linked List < Double > stats = allstats . get ( type ) ; stats . add Last ( s ) ; }
protected void send Intensity ( double intensity ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING + STRING + last Output Step + STRING + max Dim Step ) ; } int new Step = ( int ) Math . round ( intensity * max Dim Step ) ; if ( ( new Step < NUM ) || ( new Step > max Dim Step ) ) { log . error ( STRING + new Step + STRING + intensity ) ; } if ( new Step == last Output Step ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING ) ; } return ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity ) ; } Insteon Sequence out = new Insteon Sequence ( ) ; out . add Function ( idhighbyte , idmiddlebyte , idlowbyte , Constants . FUNCTION REQ STD , Constants . FLAG STD , Constants . CMD LIGHT CHG , new Step ) ; tc . send Insteon Sequence ( out , null ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING + idhighbyte + idmiddlebyte + idlowbyte + STRING + new Step ) ; } last Output Step = new Step ; }
protected void send Intensity ( double intensity ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING + STRING + last Output Step + STRING + max Dim Step ) ; } int new Step = ( int ) Math . round ( intensity * max Dim Step ) ; if ( ( new Step < NUM ) || ( new Step > max Dim Step ) ) { log . error ( STRING + new Step + STRING + intensity ) ; } if ( new Step == last Output Step ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING ) ; } return ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity ) ; } Insteon Sequence out = new Insteon Sequence ( ) ; out . add Function ( idhighbyte , idmiddlebyte , idlowbyte , Constants . FUNCTION REQ STD , Constants . FLAG STD , Constants . CMD LIGHT CHG , new Step ) ; tc . send Insteon Sequence ( out , null ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING + idhighbyte + idmiddlebyte + idlowbyte + STRING + new Step ) ; } last Output Step = new Step ; }
protected void send Intensity ( double intensity ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING + STRING + last Output Step + STRING + max Dim Step ) ; } int new Step = ( int ) Math . round ( intensity * max Dim Step ) ; if ( ( new Step < NUM ) || ( new Step > max Dim Step ) ) { log . error ( STRING + new Step + STRING + intensity ) ; } if ( new Step == last Output Step ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING ) ; } return ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity ) ; } Insteon Sequence out = new Insteon Sequence ( ) ; out . add Function ( idhighbyte , idmiddlebyte , idlowbyte , Constants . FUNCTION REQ STD , Constants . FLAG STD , Constants . CMD LIGHT CHG , new Step ) ; tc . send Insteon Sequence ( out , null ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING + idhighbyte + idmiddlebyte + idlowbyte + STRING + new Step ) ; } last Output Step = new Step ; }
protected void send Intensity ( double intensity ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING + STRING + last Output Step + STRING + max Dim Step ) ; } int new Step = ( int ) Math . round ( intensity * max Dim Step ) ; if ( ( new Step < NUM ) || ( new Step > max Dim Step ) ) { log . error ( STRING + new Step + STRING + intensity ) ; } if ( new Step == last Output Step ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING ) ; } return ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity ) ; } Insteon Sequence out = new Insteon Sequence ( ) ; out . add Function ( idhighbyte , idmiddlebyte , idlowbyte , Constants . FUNCTION REQ STD , Constants . FLAG STD , Constants . CMD LIGHT CHG , new Step ) ; tc . send Insteon Sequence ( out , null ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING + idhighbyte + idmiddlebyte + idlowbyte + STRING + new Step ) ; } last Output Step = new Step ; }
protected void send Intensity ( double intensity ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING + STRING + last Output Step + STRING + max Dim Step ) ; } int new Step = ( int ) Math . round ( intensity * max Dim Step ) ; if ( ( new Step < NUM ) || ( new Step > max Dim Step ) ) { log . error ( STRING + new Step + STRING + intensity ) ; } if ( new Step == last Output Step ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING ) ; } return ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity ) ; } Insteon Sequence out = new Insteon Sequence ( ) ; out . add Function ( idhighbyte , idmiddlebyte , idlowbyte , Constants . FUNCTION REQ STD , Constants . FLAG STD , Constants . CMD LIGHT CHG , new Step ) ; tc . send Insteon Sequence ( out , null ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING + idhighbyte + idmiddlebyte + idlowbyte + STRING + new Step ) ; } last Output Step = new Step ; }
protected void send Intensity ( double intensity ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING + STRING + last Output Step + STRING + max Dim Step ) ; } int new Step = ( int ) Math . round ( intensity * max Dim Step ) ; if ( ( new Step < NUM ) || ( new Step > max Dim Step ) ) { log . error ( STRING + new Step + STRING + intensity ) ; } if ( new Step == last Output Step ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING ) ; } return ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity ) ; } Insteon Sequence out = new Insteon Sequence ( ) ; out . add Function ( idhighbyte , idmiddlebyte , idlowbyte , Constants . FUNCTION REQ STD , Constants . FLAG STD , Constants . CMD LIGHT CHG , new Step ) ; tc . send Insteon Sequence ( out , null ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING + idhighbyte + idmiddlebyte + idlowbyte + STRING + new Step ) ; } last Output Step = new Step ; }
protected void send Intensity ( double intensity ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING + STRING + last Output Step + STRING + max Dim Step ) ; } int new Step = ( int ) Math . round ( intensity * max Dim Step ) ; if ( ( new Step < NUM ) || ( new Step > max Dim Step ) ) { log . error ( STRING + new Step + STRING + intensity ) ; } if ( new Step == last Output Step ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING ) ; } return ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity ) ; } Insteon Sequence out = new Insteon Sequence ( ) ; out . add Function ( idhighbyte , idmiddlebyte , idlowbyte , Constants . FUNCTION REQ STD , Constants . FLAG STD , Constants . CMD LIGHT CHG , new Step ) ; tc . send Insteon Sequence ( out , null ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING + idhighbyte + idmiddlebyte + idlowbyte + STRING + new Step ) ; } last Output Step = new Step ; }
private void read Object ( Object Input Stream s ) throws Class Not Found Exception , IO Exception , Headless Exception { Graphics Environment . check Headless ( ) ; Object Input Stream . Get Field f = s . read Fields ( ) ; scrollbar Display Policy = f . get ( STRING , SCROLLBARS AS NEEDED ) ; h Adjustable = ( Scroll Pane Adjustable ) f . get ( STRING , null ) ; v Adjustable = ( Scroll Pane Adjustable ) f . get ( STRING , null ) ; wheel Scrolling Enabled = f . get ( STRING , default Wheel Scroll ) ; }
public Auto Mix Bucket create Bucket ( String name , String [ ] styles , String [ ] moods , boolean taste , float adventurous , String [ ] song Types , float speechiness , float energy , float familiar ) { Auto Mix Bucket bucket = new Auto Mix Bucket ( name , styles , moods , taste , adventurous , song Types , speechiness , energy , familiar ) ; bucket . create Playlist Session ( ) ; m Buckets . add ( bucket ) ; save Bucket ( bucket ) ; return bucket ; }
public synchronized void remove Listener ( final T listener ) { listeners . remove ( listener ) ; }
public int write Graph To File ( byte [ ] img , File to ) { try { File Output Stream fos = new File Output Stream ( to ) ; fos . write ( img ) ; fos . close ( ) ; } catch ( java . io . IO Exception ioe ) { return - NUM ; } return NUM ; }
public int write Graph To File ( byte [ ] img , File to ) { try { File Output Stream fos = new File Output Stream ( to ) ; fos . write ( img ) ; fos . close ( ) ; } catch ( java . io . IO Exception ioe ) { return - NUM ; } return NUM ; }
public void post Commit ( boolean job Successful , Configuration conf ) throws Retry Exception , Unrecoverable Exception { if ( job Successful ) { Jdbc Output Format . finalize Output ( conf ) ; } else { Jdbc Output Format . rollback ( conf ) ; } }
public void post Commit ( boolean job Successful , Configuration conf ) throws Retry Exception , Unrecoverable Exception { if ( job Successful ) { Jdbc Output Format . finalize Output ( conf ) ; } else { Jdbc Output Format . rollback ( conf ) ; } }
public void post Commit ( boolean job Successful , Configuration conf ) throws Retry Exception , Unrecoverable Exception { if ( job Successful ) { Jdbc Output Format . finalize Output ( conf ) ; } else { Jdbc Output Format . rollback ( conf ) ; } }
@ Target Api ( Build . VERSION CODES . M ) public boolean ensure Storage Permission Granted ( ) { if ( Build . VERSION . SDK INT >= Build . VERSION CODES . M ) { if ( check Self Permission ( Manifest . permission . WRITE EXTERNAL STORAGE ) == Package Manager . PERMISSION GRANTED ) { return BOOL ; } else { request Permissions ( new String [ ] { Manifest . permission . WRITE EXTERNAL STORAGE } , REQUESTCODE PERMISSION STORAGE ) ; return BOOL ; } } else { return BOOL ; } }
@ Target Api ( Build . VERSION CODES . M ) public boolean ensure Storage Permission Granted ( ) { if ( Build . VERSION . SDK INT >= Build . VERSION CODES . M ) { if ( check Self Permission ( Manifest . permission . WRITE EXTERNAL STORAGE ) == Package Manager . PERMISSION GRANTED ) { return BOOL ; } else { request Permissions ( new String [ ] { Manifest . permission . WRITE EXTERNAL STORAGE } , REQUESTCODE PERMISSION STORAGE ) ; return BOOL ; } } else { return BOOL ; } }
private void copy Vdc Object ( Virtual Data Center src , Virtual Data Center dest ) { log . info ( STRING , dest . get Id ( ) ) ; dest . set Short Id ( src . get Short Id ( ) ) ; dest . set Version ( src . get Version ( ) ) ; dest . set Api Endpoint ( src . get Api Endpoint ( ) ) ; dest . set Connection Status ( src . get Connection Status ( ) ) ; dest . set Local ( src . get Local ( ) ) ; dest . set Host Count ( src . get Host Count ( ) ) ; dest . set Host I Pv 4 Addresses Map ( src . get Host I Pv 4 Addresses Map ( ) ) ; dest . set Host I Pv 6 Addresses Map ( src . get Host I Pv 6 Addresses Map ( ) ) ; Assert . assert Not Null ( src . get Host I Pv 4 Addresses Map ( ) ) ; }
private void update Calendar View ( ) { m Calendar View . set Date ( m Current Date . get Time In Millis ( ) , BOOL , BOOL ) ; }
private void update Calendar View ( ) { m Calendar View . set Date ( m Current Date . get Time In Millis ( ) , BOOL , BOOL ) ; }
public void add ( ESRI Record r ) throws IO Exception { if ( r . get Shape Type ( ) == file Shape Type ) { verify Record Buffer ( r . get Binary Store Size ( ) ) ; int n Bytes = r . write ( rec Buf , NUM ) ; raf . seek ( raf . length ( ) ) ; raf . write ( rec Buf , NUM , n Bytes ) ; } else { Debug . error ( STRING + r . get Shape Type ( ) + STRING + file Shape Type ) ; } }
public void add ( ESRI Record r ) throws IO Exception { if ( r . get Shape Type ( ) == file Shape Type ) { verify Record Buffer ( r . get Binary Store Size ( ) ) ; int n Bytes = r . write ( rec Buf , NUM ) ; raf . seek ( raf . length ( ) ) ; raf . write ( rec Buf , NUM , n Bytes ) ; } else { Debug . error ( STRING + r . get Shape Type ( ) + STRING + file Shape Type ) ; } }
public Sdp Exception ( String message , Throwable root Cause ) { super ( root Cause . get Message ( ) + Separators . SEMICOLON + message ) ; }
public Sdp Exception ( String message , Throwable root Cause ) { super ( root Cause . get Message ( ) + Separators . SEMICOLON + message ) ; }
public static Switch Date Time Dialog Fragment new Instance ( String label , String positive Button , String negative Button ) { Switch Date Time Dialog Fragment switch Date Time Dialog Fragment = new Switch Date Time Dialog Fragment ( ) ; Bundle args = new Bundle ( ) ; args . put String ( TAG LABEL , label ) ; args . put String ( TAG POSITIVE BUTTON , positive Button ) ; args . put String ( TAG NEGATIVE BUTTON , negative Button ) ; switch Date Time Dialog Fragment . set Arguments ( args ) ; return switch Date Time Dialog Fragment ; }
@ Not Null public static Map < Rad Component , List < Rad Component > > group Siblings ( @ Not Null List < ? extends Rad Component > components ) { Map < Rad Component , List < Rad Component > > sibling Lists = new Hash Map < Rad Component , List < Rad Component > > ( ) ; if ( components . is Empty ( ) ) { return sibling Lists ; } if ( components . size ( ) == NUM ) { Rad Component component = components . get ( NUM ) ; sibling Lists . put ( component . get Parent ( ) , Collections . singleton List ( component ) ) ; return sibling Lists ; } for ( Rad Component component : components ) { Rad Component parent = component . get Parent ( ) ; List < Rad Component > children = sibling Lists . get ( parent ) ; if ( children == null ) { children = new Array List < Rad Component > ( ) ; sibling Lists . put ( parent , children ) ; } children . add ( component ) ; } return sibling Lists ; }
@ Not Null public static Map < Rad Component , List < Rad Component > > group Siblings ( @ Not Null List < ? extends Rad Component > components ) { Map < Rad Component , List < Rad Component > > sibling Lists = new Hash Map < Rad Component , List < Rad Component > > ( ) ; if ( components . is Empty ( ) ) { return sibling Lists ; } if ( components . size ( ) == NUM ) { Rad Component component = components . get ( NUM ) ; sibling Lists . put ( component . get Parent ( ) , Collections . singleton List ( component ) ) ; return sibling Lists ; } for ( Rad Component component : components ) { Rad Component parent = component . get Parent ( ) ; List < Rad Component > children = sibling Lists . get ( parent ) ; if ( children == null ) { children = new Array List < Rad Component > ( ) ; sibling Lists . put ( parent , children ) ; } children . add ( component ) ; } return sibling Lists ; }
@ Not Null public static Map < Rad Component , List < Rad Component > > group Siblings ( @ Not Null List < ? extends Rad Component > components ) { Map < Rad Component , List < Rad Component > > sibling Lists = new Hash Map < Rad Component , List < Rad Component > > ( ) ; if ( components . is Empty ( ) ) { return sibling Lists ; } if ( components . size ( ) == NUM ) { Rad Component component = components . get ( NUM ) ; sibling Lists . put ( component . get Parent ( ) , Collections . singleton List ( component ) ) ; return sibling Lists ; } for ( Rad Component component : components ) { Rad Component parent = component . get Parent ( ) ; List < Rad Component > children = sibling Lists . get ( parent ) ; if ( children == null ) { children = new Array List < Rad Component > ( ) ; sibling Lists . put ( parent , children ) ; } children . add ( component ) ; } return sibling Lists ; }
@ Not Null public static Map < Rad Component , List < Rad Component > > group Siblings ( @ Not Null List < ? extends Rad Component > components ) { Map < Rad Component , List < Rad Component > > sibling Lists = new Hash Map < Rad Component , List < Rad Component > > ( ) ; if ( components . is Empty ( ) ) { return sibling Lists ; } if ( components . size ( ) == NUM ) { Rad Component component = components . get ( NUM ) ; sibling Lists . put ( component . get Parent ( ) , Collections . singleton List ( component ) ) ; return sibling Lists ; } for ( Rad Component component : components ) { Rad Component parent = component . get Parent ( ) ; List < Rad Component > children = sibling Lists . get ( parent ) ; if ( children == null ) { children = new Array List < Rad Component > ( ) ; sibling Lists . put ( parent , children ) ; } children . add ( component ) ; } return sibling Lists ; }
@ Not Null public static Map < Rad Component , List < Rad Component > > group Siblings ( @ Not Null List < ? extends Rad Component > components ) { Map < Rad Component , List < Rad Component > > sibling Lists = new Hash Map < Rad Component , List < Rad Component > > ( ) ; if ( components . is Empty ( ) ) { return sibling Lists ; } if ( components . size ( ) == NUM ) { Rad Component component = components . get ( NUM ) ; sibling Lists . put ( component . get Parent ( ) , Collections . singleton List ( component ) ) ; return sibling Lists ; } for ( Rad Component component : components ) { Rad Component parent = component . get Parent ( ) ; List < Rad Component > children = sibling Lists . get ( parent ) ; if ( children == null ) { children = new Array List < Rad Component > ( ) ; sibling Lists . put ( parent , children ) ; } children . add ( component ) ; } return sibling Lists ; }
@ Not Null public static Map < Rad Component , List < Rad Component > > group Siblings ( @ Not Null List < ? extends Rad Component > components ) { Map < Rad Component , List < Rad Component > > sibling Lists = new Hash Map < Rad Component , List < Rad Component > > ( ) ; if ( components . is Empty ( ) ) { return sibling Lists ; } if ( components . size ( ) == NUM ) { Rad Component component = components . get ( NUM ) ; sibling Lists . put ( component . get Parent ( ) , Collections . singleton List ( component ) ) ; return sibling Lists ; } for ( Rad Component component : components ) { Rad Component parent = component . get Parent ( ) ; List < Rad Component > children = sibling Lists . get ( parent ) ; if ( children == null ) { children = new Array List < Rad Component > ( ) ; sibling Lists . put ( parent , children ) ; } children . add ( component ) ; } return sibling Lists ; }
public static void copy Streams ( Input Stream in , Output Stream out ) throws IO Exception { if ( in == null || out == null ) { throw new Illegal Argument Exception ( ) ; } final byte [ ] buffer = new byte [ NUM ] ; int len ; while ( - NUM != ( len = in . read ( buffer , NUM , buffer . length ) ) ) { out . write ( buffer , NUM , len ) ; } }
void init Proxy ( Class < ? > cl , Class Not Found Exception resolve Ex , Object Stream Class super Desc ) throws Invalid Class Exception { Object Stream Class osc = null ; if ( cl != null ) { osc = lookup ( cl , BOOL ) ; if ( ! osc . is Proxy ) { throw new Invalid Class Exception ( STRING ) ; } } this . cl = cl ; this . resolve Ex = resolve Ex ; this . super Desc = super Desc ; is Proxy = BOOL ; serializable = BOOL ; suid = Long . value Of ( NUM ) ; fields = NO FIELDS ; if ( osc != null ) { local Desc = osc ; name = local Desc . name ; externalizable = local Desc . externalizable ; write Replace Method = local Desc . write Replace Method ; read Resolve Method = local Desc . read Resolve Method ; deserialize Ex = local Desc . deserialize Ex ; cons = local Desc . cons ; } field Refl = get Reflector ( fields , local Desc ) ; initialized = BOOL ; }
void init Proxy ( Class < ? > cl , Class Not Found Exception resolve Ex , Object Stream Class super Desc ) throws Invalid Class Exception { Object Stream Class osc = null ; if ( cl != null ) { osc = lookup ( cl , BOOL ) ; if ( ! osc . is Proxy ) { throw new Invalid Class Exception ( STRING ) ; } } this . cl = cl ; this . resolve Ex = resolve Ex ; this . super Desc = super Desc ; is Proxy = BOOL ; serializable = BOOL ; suid = Long . value Of ( NUM ) ; fields = NO FIELDS ; if ( osc != null ) { local Desc = osc ; name = local Desc . name ; externalizable = local Desc . externalizable ; write Replace Method = local Desc . write Replace Method ; read Resolve Method = local Desc . read Resolve Method ; deserialize Ex = local Desc . deserialize Ex ; cons = local Desc . cons ; } field Refl = get Reflector ( fields , local Desc ) ; initialized = BOOL ; }
@ Override public Storage create Storage ( Storage Create Request storage Create Request ) { validate Storage Create Request ( storage Create Request ) ; Storage Platform Entity storage Platform Entity = storage Platform Helper . get Storage Platform Entity ( storage Create Request . get Storage Platform Name ( ) ) ; Storage Entity storage Entity = storage Dao . get Storage By Name ( storage Create Request . get Name ( ) ) ; if ( storage Entity != null ) { throw new Already Exists Exception ( String . format ( STRING , storage Create Request . get Name ( ) ) ) ; } storage Entity = new Storage Entity ( ) ; storage Entity . set Name ( storage Create Request . get Name ( ) ) ; storage Entity . set Storage Platform ( storage Platform Entity ) ; if ( ! Collection Utils . is Empty ( storage Create Request . get Attributes ( ) ) ) { List < Storage Attribute Entity > attribute Entities = new Array List < > ( ) ; storage Entity . set Attributes ( attribute Entities ) ; for ( Attribute attribute : storage Create Request . get Attributes ( ) ) { Storage Attribute Entity attribute Entity = new Storage Attribute Entity ( ) ; attribute Entities . add ( attribute Entity ) ; attribute Entity . set Storage ( storage Entity ) ; attribute Entity . set Name ( attribute . get Name ( ) ) ; attribute Entity . set Value ( attribute . get Value ( ) ) ; } } storage Entity = storage Dao . save And Refresh ( storage Entity ) ; return create Storage From Entity ( storage Entity ) ; }
public FPS Texture View add Child ( @ Non Null Display Base Display Object ) { Display Object . set Up ( m Fps ) ; m Display List . add ( Display Object ) ; return this ; }
@ Suppress Warnings ( STRING ) private boolean scan Version Line ( String line ) { if ( line != null ) { Matcher matcher = s Adb Version . matcher ( line ) ; if ( matcher . matches ( ) ) { int major Version = Integer . parse Int ( matcher . group ( NUM ) ) ; int minor Version = Integer . parse Int ( matcher . group ( NUM ) ) ; int micro Version = Integer . parse Int ( matcher . group ( NUM ) ) ; if ( micro Version < ADB VERSION MICRO MIN ) { String message = String . format ( STRING + STRING , major Version , minor Version , ADB VERSION MICRO MIN , micro Version ) ; Log . log And Display ( Log Level . ERROR , ADB , message ) ; } else if ( ADB VERSION MICRO MAX != - NUM && micro Version > ADB VERSION MICRO MAX ) { String message = String . format ( STRING + STRING , major Version , minor Version , ADB VERSION MICRO MAX , micro Version ) ; Log . log And Display ( Log Level . ERROR , ADB , message ) ; } else { m Version Check = BOOL ; } return BOOL ; } } return BOOL ; }
@ Suppress Warnings ( STRING ) private boolean scan Version Line ( String line ) { if ( line != null ) { Matcher matcher = s Adb Version . matcher ( line ) ; if ( matcher . matches ( ) ) { int major Version = Integer . parse Int ( matcher . group ( NUM ) ) ; int minor Version = Integer . parse Int ( matcher . group ( NUM ) ) ; int micro Version = Integer . parse Int ( matcher . group ( NUM ) ) ; if ( micro Version < ADB VERSION MICRO MIN ) { String message = String . format ( STRING + STRING , major Version , minor Version , ADB VERSION MICRO MIN , micro Version ) ; Log . log And Display ( Log Level . ERROR , ADB , message ) ; } else if ( ADB VERSION MICRO MAX != - NUM && micro Version > ADB VERSION MICRO MAX ) { String message = String . format ( STRING + STRING , major Version , minor Version , ADB VERSION MICRO MAX , micro Version ) ; Log . log And Display ( Log Level . ERROR , ADB , message ) ; } else { m Version Check = BOOL ; } return BOOL ; } } return BOOL ; }
@ Suppress Warnings ( STRING ) private boolean scan Version Line ( String line ) { if ( line != null ) { Matcher matcher = s Adb Version . matcher ( line ) ; if ( matcher . matches ( ) ) { int major Version = Integer . parse Int ( matcher . group ( NUM ) ) ; int minor Version = Integer . parse Int ( matcher . group ( NUM ) ) ; int micro Version = Integer . parse Int ( matcher . group ( NUM ) ) ; if ( micro Version < ADB VERSION MICRO MIN ) { String message = String . format ( STRING + STRING , major Version , minor Version , ADB VERSION MICRO MIN , micro Version ) ; Log . log And Display ( Log Level . ERROR , ADB , message ) ; } else if ( ADB VERSION MICRO MAX != - NUM && micro Version > ADB VERSION MICRO MAX ) { String message = String . format ( STRING + STRING , major Version , minor Version , ADB VERSION MICRO MAX , micro Version ) ; Log . log And Display ( Log Level . ERROR , ADB , message ) ; } else { m Version Check = BOOL ; } return BOOL ; } } return BOOL ; }
@ Suppress Warnings ( STRING ) private boolean scan Version Line ( String line ) { if ( line != null ) { Matcher matcher = s Adb Version . matcher ( line ) ; if ( matcher . matches ( ) ) { int major Version = Integer . parse Int ( matcher . group ( NUM ) ) ; int minor Version = Integer . parse Int ( matcher . group ( NUM ) ) ; int micro Version = Integer . parse Int ( matcher . group ( NUM ) ) ; if ( micro Version < ADB VERSION MICRO MIN ) { String message = String . format ( STRING + STRING , major Version , minor Version , ADB VERSION MICRO MIN , micro Version ) ; Log . log And Display ( Log Level . ERROR , ADB , message ) ; } else if ( ADB VERSION MICRO MAX != - NUM && micro Version > ADB VERSION MICRO MAX ) { String message = String . format ( STRING + STRING , major Version , minor Version , ADB VERSION MICRO MAX , micro Version ) ; Log . log And Display ( Log Level . ERROR , ADB , message ) ; } else { m Version Check = BOOL ; } return BOOL ; } } return BOOL ; }
@ Suppress Warnings ( STRING ) private boolean scan Version Line ( String line ) { if ( line != null ) { Matcher matcher = s Adb Version . matcher ( line ) ; if ( matcher . matches ( ) ) { int major Version = Integer . parse Int ( matcher . group ( NUM ) ) ; int minor Version = Integer . parse Int ( matcher . group ( NUM ) ) ; int micro Version = Integer . parse Int ( matcher . group ( NUM ) ) ; if ( micro Version < ADB VERSION MICRO MIN ) { String message = String . format ( STRING + STRING , major Version , minor Version , ADB VERSION MICRO MIN , micro Version ) ; Log . log And Display ( Log Level . ERROR , ADB , message ) ; } else if ( ADB VERSION MICRO MAX != - NUM && micro Version > ADB VERSION MICRO MAX ) { String message = String . format ( STRING + STRING , major Version , minor Version , ADB VERSION MICRO MAX , micro Version ) ; Log . log And Display ( Log Level . ERROR , ADB , message ) ; } else { m Version Check = BOOL ; } return BOOL ; } } return BOOL ; }
public Page Format validate Page ( Page Format page ) { Page Format new Page = ( Page Format ) page . clone ( ) ; Paper new Paper = new Paper ( ) ; validate Paper ( new Page . get Paper ( ) , new Paper ) ; new Page . set Paper ( new Paper ) ; return new Page ; }
public Page Format validate Page ( Page Format page ) { Page Format new Page = ( Page Format ) page . clone ( ) ; Paper new Paper = new Paper ( ) ; validate Paper ( new Page . get Paper ( ) , new Paper ) ; new Page . set Paper ( new Paper ) ; return new Page ; }
default B with ( String key , Object value ) { return with ( key , value != null ? value . to String ( ) : null ) ; }
default B with ( String key , Object value ) { return with ( key , value != null ? value . to String ( ) : null ) ; }
public void add Item ( int position , Object o ) { if ( ! is Data List Empty ( ) && position >= NUM && position <= m Data List . size ( ) ) { m Data List . add ( position , o ) ; notify Item Inserted ( position ) ; } }
public void add Item ( int position , Object o ) { if ( ! is Data List Empty ( ) && position >= NUM && position <= m Data List . size ( ) ) { m Data List . add ( position , o ) ; notify Item Inserted ( position ) ; } }
public void reset Data ( ) { data . clear ( ) ; data Names . clear ( ) ; data Set . reset Data ( data Names , data , bins ) ; }
public void reset Data ( ) { data . clear ( ) ; data Names . clear ( ) ; data Set . reset Data ( data Names , data , bins ) ; }
public void reset Data ( ) { data . clear ( ) ; data Names . clear ( ) ; data Set . reset Data ( data Names , data , bins ) ; }
public static void write Element List ( XML Output xml Output , String tag Name , Iterator < String > list Value Iterator ) throws IO Exception { while ( list Value Iterator . has Next ( ) ) { xml Output . open Tag ( tag Name ) ; xml Output . write Text ( list Value Iterator . next ( ) ) ; xml Output . close Tag ( tag Name ) ; } }
public void start Heartbeat ( Database database , String name ) throws SQL Exception { Array List < Column > where Clause = new Array List < Column > ( ) ; Array List < Column > values = new Array List < Column > ( ) ; Timestamp now = new Timestamp ( System . current Time Millis ( ) ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + name + STRING + now ) ; hb Id . set Value ( KEY ) ; where Clause . add ( hb Id ) ; hb Source Tstamp . set Value ( now ) ; hb Salt . set Value ( salt Value . get And Increment ( ) ) ; hb Name . set Value ( name ) ; values . add ( hb Source Tstamp ) ; values . add ( hb Salt ) ; values . add ( hb Name ) ; database . update ( hb Table , where Clause , values ) ; }
public void start Heartbeat ( Database database , String name ) throws SQL Exception { Array List < Column > where Clause = new Array List < Column > ( ) ; Array List < Column > values = new Array List < Column > ( ) ; Timestamp now = new Timestamp ( System . current Time Millis ( ) ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + name + STRING + now ) ; hb Id . set Value ( KEY ) ; where Clause . add ( hb Id ) ; hb Source Tstamp . set Value ( now ) ; hb Salt . set Value ( salt Value . get And Increment ( ) ) ; hb Name . set Value ( name ) ; values . add ( hb Source Tstamp ) ; values . add ( hb Salt ) ; values . add ( hb Name ) ; database . update ( hb Table , where Clause , values ) ; }
public boolean is Valid ( World world ) { return BOOL ; }
public boolean is Valid ( World world ) { return BOOL ; }
public boolean is Valid ( World world ) { return BOOL ; }
public boolean is Valid ( World world ) { return BOOL ; }
public boolean is Valid ( World world ) { return BOOL ; }
public boolean is Valid ( World world ) { return BOOL ; }
public boolean is Valid ( World world ) { return BOOL ; }
protected String color To RGB ( final Color color ) { return String . format ( STRING , color . get Red ( ) , color . get Green ( ) , color . get Blue ( ) ) ; }
public String normalize Uri ( String uri ) { if ( uri != null && ! uri . ends With ( STRING ) ) { uri += STRING ; } return uri ; }
public String normalize Uri ( String uri ) { if ( uri != null && ! uri . ends With ( STRING ) ) { uri += STRING ; } return uri ; }
private Generator ( boolean full , File build Dir , String package Name Prefix , String laf Name , Synth Model model ) { this . full = full ; if ( package Name Prefix == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( build Dir == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( model == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( laf Name == null ) { throw new Illegal Argument Exception ( STRING ) ; } variables = new Hash Map < String , String > ( ) ; variables . put ( STRING , package Name Prefix ) ; variables . put ( STRING , laf Name ) ; build Package Root = new File ( build Dir , package Name Prefix . replace All ( STRING , STRING ) ) ; build Package Root . mkdirs ( ) ; this . package Name Prefix = package Name Prefix ; this . laf Name = laf Name ; this . model = model ; }
private Generator ( boolean full , File build Dir , String package Name Prefix , String laf Name , Synth Model model ) { this . full = full ; if ( package Name Prefix == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( build Dir == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( model == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( laf Name == null ) { throw new Illegal Argument Exception ( STRING ) ; } variables = new Hash Map < String , String > ( ) ; variables . put ( STRING , package Name Prefix ) ; variables . put ( STRING , laf Name ) ; build Package Root = new File ( build Dir , package Name Prefix . replace All ( STRING , STRING ) ) ; build Package Root . mkdirs ( ) ; this . package Name Prefix = package Name Prefix ; this . laf Name = laf Name ; this . model = model ; }
private Generator ( boolean full , File build Dir , String package Name Prefix , String laf Name , Synth Model model ) { this . full = full ; if ( package Name Prefix == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( build Dir == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( model == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( laf Name == null ) { throw new Illegal Argument Exception ( STRING ) ; } variables = new Hash Map < String , String > ( ) ; variables . put ( STRING , package Name Prefix ) ; variables . put ( STRING , laf Name ) ; build Package Root = new File ( build Dir , package Name Prefix . replace All ( STRING , STRING ) ) ; build Package Root . mkdirs ( ) ; this . package Name Prefix = package Name Prefix ; this . laf Name = laf Name ; this . model = model ; }
private Generator ( boolean full , File build Dir , String package Name Prefix , String laf Name , Synth Model model ) { this . full = full ; if ( package Name Prefix == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( build Dir == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( model == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( laf Name == null ) { throw new Illegal Argument Exception ( STRING ) ; } variables = new Hash Map < String , String > ( ) ; variables . put ( STRING , package Name Prefix ) ; variables . put ( STRING , laf Name ) ; build Package Root = new File ( build Dir , package Name Prefix . replace All ( STRING , STRING ) ) ; build Package Root . mkdirs ( ) ; this . package Name Prefix = package Name Prefix ; this . laf Name = laf Name ; this . model = model ; }
public void render Validation Messages ( Payment Item payment Item ) { field Ids Of Error Messages Showing . clear ( ) ; for ( Validation Error Message validation Result : validation Messages ) { render Validation Message On Screen ( validation Result , payment Item ) ; } }
public void render Validation Messages ( Payment Item payment Item ) { field Ids Of Error Messages Showing . clear ( ) ; for ( Validation Error Message validation Result : validation Messages ) { render Validation Message On Screen ( validation Result , payment Item ) ; } }
public void add All ( final Collection < ? extends T > collection ) { synchronized ( m Lock ) { m List . add All ( collection ) ; } notify Data Set Changed ( ) ; }
public void add All ( final Collection < ? extends T > collection ) { synchronized ( m Lock ) { m List . add All ( collection ) ; } notify Data Set Changed ( ) ; }
public void add Test Data Source ( Class < ? > class Context , String test Data Dir ) { class Contexts . add ( class Context ) ; test Data Dirs . add ( test Data Dir ) ; }
void remove ( final Blaze Vertex vertex ) { final String query Str = sparql . remove Vertex ( vertex ) ; update ( query Str ) ; }
private static String fill String ( String in , int len ) { String out = new String ( in ) ; while ( out . length ( ) < len ) { out = STRING + out ; } return ( out ) ; }
private static String fill String ( String in , int len ) { String out = new String ( in ) ; while ( out . length ( ) < len ) { out = STRING + out ; } return ( out ) ; }
private Phrase Positions [ ] repeating P Ps ( Hash Map < Term , Integer > rpt Terms ) { Array List < Phrase Positions > rp = new Array List < > ( ) ; for ( Phrase Positions pp : phrase Positions ) { for ( Term t : pp . terms ) { if ( rpt Terms . contains Key ( t ) ) { rp . add ( pp ) ; has Multi Term Rpts |= ( pp . terms . length > NUM ) ; break ; } } } return rp . to Array ( new Phrase Positions [ NUM ] ) ; }
public String byte String No Semicolon ( ) { String Builder retval = new String Builder ( ) ; try { while ( BOOL ) { char next = look Ahead ( NUM ) ; if ( next == STRING || next == STRING || next == STRING || next == STRING ) { break ; } else { consume ( NUM ) ; retval . append ( next ) ; } } } catch ( Parse Exception ex ) { return retval . to String ( ) ; } return retval . to String ( ) ; }
public String byte String No Semicolon ( ) { String Builder retval = new String Builder ( ) ; try { while ( BOOL ) { char next = look Ahead ( NUM ) ; if ( next == STRING || next == STRING || next == STRING || next == STRING ) { break ; } else { consume ( NUM ) ; retval . append ( next ) ; } } } catch ( Parse Exception ex ) { return retval . to String ( ) ; } return retval . to String ( ) ; }
public String to HTML ( ) { List < Test Case > failed = get Failed Test Cases ( ) ; List < Test Case > passed = get Passed Test Cases ( ) ; List < Test Case > skipped = get Skipped Test Cases ( ) ; String Buffer buff = new String Buffer ( ) ; for ( Test Case tc : failed ) { buff . append ( tc . to HTML ( ) ) ; } for ( Test Case tc : passed ) { buff . append ( tc . to HTML ( ) ) ; } for ( Test Case tc : skipped ) { buff . append ( tc . to HTML ( ) ) ; } Object [ ] params = { name , buff . to String ( ) } ; return Message Format . format ( HTML Constants . TEST TABLE , params ) ; }
private boolean match Filter ( String string , String pattern ) { if ( pattern . equals ( STRING ) || pattern . equals ( string ) ) { return BOOL ; } int length = pattern . length ( ) ; int wild Card Index = pattern . index Of ( STRING ) ; if ( wild Card Index >= NUM ) { String pattern Sub Str = pattern . substring ( NUM , wild Card Index ) ; if ( ! string . starts With ( pattern Sub Str , NUM ) ) { return BOOL ; } int begin Index = pattern Sub Str . length ( ) + NUM ; int string Index = NUM ; if ( wild Card Index > NUM ) { string Index = begin Index ; } String sub = pattern . substring ( begin Index , length ) ; while ( ( wild Card Index = pattern . index Of ( STRING , begin Index ) ) != - NUM ) { pattern Sub Str = pattern . substring ( begin Index , wild Card Index ) ; if ( string . index Of ( pattern Sub Str , string Index ) == - NUM ) { return BOOL ; } begin Index = wild Card Index + NUM ; string Index = string Index + pattern Sub Str . length ( ) + NUM ; sub = pattern . substring ( begin Index , length ) ; } if ( string . ends With ( sub ) ) { return BOOL ; } } return BOOL ; }
private boolean match Filter ( String string , String pattern ) { if ( pattern . equals ( STRING ) || pattern . equals ( string ) ) { return BOOL ; } int length = pattern . length ( ) ; int wild Card Index = pattern . index Of ( STRING ) ; if ( wild Card Index >= NUM ) { String pattern Sub Str = pattern . substring ( NUM , wild Card Index ) ; if ( ! string . starts With ( pattern Sub Str , NUM ) ) { return BOOL ; } int begin Index = pattern Sub Str . length ( ) + NUM ; int string Index = NUM ; if ( wild Card Index > NUM ) { string Index = begin Index ; } String sub = pattern . substring ( begin Index , length ) ; while ( ( wild Card Index = pattern . index Of ( STRING , begin Index ) ) != - NUM ) { pattern Sub Str = pattern . substring ( begin Index , wild Card Index ) ; if ( string . index Of ( pattern Sub Str , string Index ) == - NUM ) { return BOOL ; } begin Index = wild Card Index + NUM ; string Index = string Index + pattern Sub Str . length ( ) + NUM ; sub = pattern . substring ( begin Index , length ) ; } if ( string . ends With ( sub ) ) { return BOOL ; } } return BOOL ; }
public int [ ] to Array ( ) { int [ ] value = new int [ size ] ; System . arraycopy ( data , NUM , value , NUM , size ) ; return value ; }
@ Override public void run ( ) { log . info ( STRING ) ; try { if ( ! call Home Event Manager . can Send Event ( ) ) { return ; } int total Sleep = NUM ; while ( BOOL ) { if ( license Manager . get Target Info Lock ( ) ) { try { perform Send Events ( ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; break ; } finally { license Manager . release Target Version Lock ( ) ; } break ; } else { log . info ( STRING ) ; if ( total Sleep >= Call Home Constants . MAX LOCK WAIT TIME MS ) { log . warn ( STRING , Call Home Constants . MAX LOCK WAIT TIME MS ) ; break ; } Thread . sleep ( Call Home Constants . LOCK WAIT TIME MS ) ; total Sleep += Call Home Constants . LOCK WAIT TIME MS ; } } } catch ( API Exception i ) { log . info ( STRING ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; } log . info ( STRING ) ; }
@ Override public void run ( ) { log . info ( STRING ) ; try { if ( ! call Home Event Manager . can Send Event ( ) ) { return ; } int total Sleep = NUM ; while ( BOOL ) { if ( license Manager . get Target Info Lock ( ) ) { try { perform Send Events ( ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; break ; } finally { license Manager . release Target Version Lock ( ) ; } break ; } else { log . info ( STRING ) ; if ( total Sleep >= Call Home Constants . MAX LOCK WAIT TIME MS ) { log . warn ( STRING , Call Home Constants . MAX LOCK WAIT TIME MS ) ; break ; } Thread . sleep ( Call Home Constants . LOCK WAIT TIME MS ) ; total Sleep += Call Home Constants . LOCK WAIT TIME MS ; } } } catch ( API Exception i ) { log . info ( STRING ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; } log . info ( STRING ) ; }
public void simulate Method ( Soot Method method , Reference Variable this Var , Reference Variable return Var , Reference Variable params [ ] ) { String sub Signature = method . get Sub Signature ( ) ; if ( sub Signature . equals ( STRING ) ) { java net Inet Address Impl get Local Host Name ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java net Inet Address Impl get Host By Addr ( method , this Var , return Var , params ) ; return ; } else { default Method ( method , this Var , return Var , params ) ; return ; } }
public void simulate Method ( Soot Method method , Reference Variable this Var , Reference Variable return Var , Reference Variable params [ ] ) { String sub Signature = method . get Sub Signature ( ) ; if ( sub Signature . equals ( STRING ) ) { java net Inet Address Impl get Local Host Name ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java net Inet Address Impl get Host By Addr ( method , this Var , return Var , params ) ; return ; } else { default Method ( method , this Var , return Var , params ) ; return ; } }
public static String transform Tool Tip Text ( final String description , final boolean add HTML Tags , final int line Length , final boolean escape Slashes , final boolean escape HTML ) { String complete Text = description . trim ( ) ; if ( escape HTML ) { complete Text = Tools . escape HTML ( complete Text ) ; } if ( escape Slashes ) { complete Text = complete Text . replace All ( STRING , STRING ) ; } String Buffer result = new String Buffer ( ) ; if ( add HTML Tags ) { result . append ( STRING ) ; } complete Text = Tools . transform All Line Separators ( complete Text ) ; String [ ] lines = complete Text . split ( STRING ) ; for ( String text : lines ) { boolean first = BOOL ; while ( text . length ( ) > line Length ) { int space Index = text . index Of ( STRING , line Length ) ; if ( ! first ) { result . append ( STRING ) ; } first = BOOL ; if ( space Index >= NUM ) { result . append ( text . substring ( NUM , space Index ) ) ; text = text . substring ( space Index + NUM ) ; } else { result . append ( text ) ; text = STRING ; } } if ( ! first && text . length ( ) > NUM ) { result . append ( STRING ) ; } result . append ( text ) ; result . append ( STRING ) ; } if ( add HTML Tags ) { result . append ( STRING ) ; } return result . to String ( ) ; }
public static String transform Tool Tip Text ( final String description , final boolean add HTML Tags , final int line Length , final boolean escape Slashes , final boolean escape HTML ) { String complete Text = description . trim ( ) ; if ( escape HTML ) { complete Text = Tools . escape HTML ( complete Text ) ; } if ( escape Slashes ) { complete Text = complete Text . replace All ( STRING , STRING ) ; } String Buffer result = new String Buffer ( ) ; if ( add HTML Tags ) { result . append ( STRING ) ; } complete Text = Tools . transform All Line Separators ( complete Text ) ; String [ ] lines = complete Text . split ( STRING ) ; for ( String text : lines ) { boolean first = BOOL ; while ( text . length ( ) > line Length ) { int space Index = text . index Of ( STRING , line Length ) ; if ( ! first ) { result . append ( STRING ) ; } first = BOOL ; if ( space Index >= NUM ) { result . append ( text . substring ( NUM , space Index ) ) ; text = text . substring ( space Index + NUM ) ; } else { result . append ( text ) ; text = STRING ; } } if ( ! first && text . length ( ) > NUM ) { result . append ( STRING ) ; } result . append ( text ) ; result . append ( STRING ) ; } if ( add HTML Tags ) { result . append ( STRING ) ; } return result . to String ( ) ; }
public static String transform Tool Tip Text ( final String description , final boolean add HTML Tags , final int line Length , final boolean escape Slashes , final boolean escape HTML ) { String complete Text = description . trim ( ) ; if ( escape HTML ) { complete Text = Tools . escape HTML ( complete Text ) ; } if ( escape Slashes ) { complete Text = complete Text . replace All ( STRING , STRING ) ; } String Buffer result = new String Buffer ( ) ; if ( add HTML Tags ) { result . append ( STRING ) ; } complete Text = Tools . transform All Line Separators ( complete Text ) ; String [ ] lines = complete Text . split ( STRING ) ; for ( String text : lines ) { boolean first = BOOL ; while ( text . length ( ) > line Length ) { int space Index = text . index Of ( STRING , line Length ) ; if ( ! first ) { result . append ( STRING ) ; } first = BOOL ; if ( space Index >= NUM ) { result . append ( text . substring ( NUM , space Index ) ) ; text = text . substring ( space Index + NUM ) ; } else { result . append ( text ) ; text = STRING ; } } if ( ! first && text . length ( ) > NUM ) { result . append ( STRING ) ; } result . append ( text ) ; result . append ( STRING ) ; } if ( add HTML Tags ) { result . append ( STRING ) ; } return result . to String ( ) ; }
protected static void print Exception Stack ( Throwable th , Print Writer out , int depth ) { boolean print Stack Depth = depth > NUM ; Throwable wrapped Exception = Exception Util . wrapped Exception ( th ) ; if ( wrapped Exception != null ) { print Stack Depth = BOOL ; print Exception Stack ( wrapped Exception , out , depth + NUM ) ; } if ( print Stack Depth ) { out . write ( STRING + depth + STRING ) ; } th . print Stack Trace ( out ) ; }
public short read Short LE ( ) throws IO Exception { input Stream . read Fully ( work Space , NUM , NUM ) ; return ( short ) ( ( ( work Space [ NUM ] & NUM ) << NUM ) | ( work Space [ NUM ] & NUM ) ) ; }
public short read Short LE ( ) throws IO Exception { input Stream . read Fully ( work Space , NUM , NUM ) ; return ( short ) ( ( ( work Space [ NUM ] & NUM ) << NUM ) | ( work Space [ NUM ] & NUM ) ) ; }
private List < Lat Lng > create Rectangle ( Lat Lng center , double half Width , double half Height ) { return Arrays . as List ( new Lat Lng ( center . latitude - half Height , center . longitude - half Width ) , new Lat Lng ( center . latitude - half Height , center . longitude + half Width ) , new Lat Lng ( center . latitude + half Height , center . longitude + half Width ) , new Lat Lng ( center . latitude + half Height , center . longitude - half Width ) , new Lat Lng ( center . latitude - half Height , center . longitude - half Width ) ) ; }
private List < Lat Lng > create Rectangle ( Lat Lng center , double half Width , double half Height ) { return Arrays . as List ( new Lat Lng ( center . latitude - half Height , center . longitude - half Width ) , new Lat Lng ( center . latitude - half Height , center . longitude + half Width ) , new Lat Lng ( center . latitude + half Height , center . longitude + half Width ) , new Lat Lng ( center . latitude + half Height , center . longitude - half Width ) , new Lat Lng ( center . latitude - half Height , center . longitude - half Width ) ) ; }
private List < Lat Lng > create Rectangle ( Lat Lng center , double half Width , double half Height ) { return Arrays . as List ( new Lat Lng ( center . latitude - half Height , center . longitude - half Width ) , new Lat Lng ( center . latitude - half Height , center . longitude + half Width ) , new Lat Lng ( center . latitude + half Height , center . longitude + half Width ) , new Lat Lng ( center . latitude + half Height , center . longitude - half Width ) , new Lat Lng ( center . latitude - half Height , center . longitude - half Width ) ) ; }
@ Override public final boolean process ( Set < ? extends Type Element > annotations , Round Environment round Env ) { for ( Type Element elem : Element Filter . types In ( round Env . get Root Elements ( ) ) ) { elements . add ( elem . get Qualified Name ( ) ) ; } return BOOL ; }
@ Override public final boolean process ( Set < ? extends Type Element > annotations , Round Environment round Env ) { for ( Type Element elem : Element Filter . types In ( round Env . get Root Elements ( ) ) ) { elements . add ( elem . get Qualified Name ( ) ) ; } return BOOL ; }
@ Override public final boolean process ( Set < ? extends Type Element > annotations , Round Environment round Env ) { for ( Type Element elem : Element Filter . types In ( round Env . get Root Elements ( ) ) ) { elements . add ( elem . get Qualified Name ( ) ) ; } return BOOL ; }
@ Override public final boolean process ( Set < ? extends Type Element > annotations , Round Environment round Env ) { for ( Type Element elem : Element Filter . types In ( round Env . get Root Elements ( ) ) ) { elements . add ( elem . get Qualified Name ( ) ) ; } return BOOL ; }
public DB Instance Info retrieve DB Info ( String db Group Name , String host Name ) { Connection conn = null ; try { conn = create Connection ( BOOL ) ; return retrieve DB Info ( conn , db Group Name , host Name ) ; } catch ( Exception ex ) { logger . log ( Level . SEVERE , STRING , ex ) ; } finally { DB Utils . close ( conn ) ; } return null ; }
@ Override protected void initialize Bounds ( ) { super . initialize Bounds ( ) ; final Shell dialog Shell = get Shell ( ) ; if ( enforce Minimum Size ) { final Point computed Size = default Compute Minimum Size ( ) ; final Rectangle constrained Bounds = get Constrained Shell Bounds ( new Rectangle ( NUM , NUM , computed Size . x , computed Size . y ) ) ; minimum Size Enforcer = new Shell Minimum Size Enforcer ( dialog Shell , constrained Bounds . width , constrained Bounds . height ) ; final String message Format = STRING ; final String message = Message Format . format ( message Format , Integer . to String ( constrained Bounds . width ) , Integer . to String ( constrained Bounds . height ) ) ; log . trace ( message ) ; } if ( resizable Directions != ( SWT . HORIZONTAL | SWT . VERTICAL ) ) { resize Enforcer = new Shell Resize Enforcer ( dialog Shell , resizable Directions ) ; } }
@ Override protected void initialize Bounds ( ) { super . initialize Bounds ( ) ; final Shell dialog Shell = get Shell ( ) ; if ( enforce Minimum Size ) { final Point computed Size = default Compute Minimum Size ( ) ; final Rectangle constrained Bounds = get Constrained Shell Bounds ( new Rectangle ( NUM , NUM , computed Size . x , computed Size . y ) ) ; minimum Size Enforcer = new Shell Minimum Size Enforcer ( dialog Shell , constrained Bounds . width , constrained Bounds . height ) ; final String message Format = STRING ; final String message = Message Format . format ( message Format , Integer . to String ( constrained Bounds . width ) , Integer . to String ( constrained Bounds . height ) ) ; log . trace ( message ) ; } if ( resizable Directions != ( SWT . HORIZONTAL | SWT . VERTICAL ) ) { resize Enforcer = new Shell Resize Enforcer ( dialog Shell , resizable Directions ) ; } }
@ Override protected void initialize Bounds ( ) { super . initialize Bounds ( ) ; final Shell dialog Shell = get Shell ( ) ; if ( enforce Minimum Size ) { final Point computed Size = default Compute Minimum Size ( ) ; final Rectangle constrained Bounds = get Constrained Shell Bounds ( new Rectangle ( NUM , NUM , computed Size . x , computed Size . y ) ) ; minimum Size Enforcer = new Shell Minimum Size Enforcer ( dialog Shell , constrained Bounds . width , constrained Bounds . height ) ; final String message Format = STRING ; final String message = Message Format . format ( message Format , Integer . to String ( constrained Bounds . width ) , Integer . to String ( constrained Bounds . height ) ) ; log . trace ( message ) ; } if ( resizable Directions != ( SWT . HORIZONTAL | SWT . VERTICAL ) ) { resize Enforcer = new Shell Resize Enforcer ( dialog Shell , resizable Directions ) ; } }
@ Override protected void initialize Bounds ( ) { super . initialize Bounds ( ) ; final Shell dialog Shell = get Shell ( ) ; if ( enforce Minimum Size ) { final Point computed Size = default Compute Minimum Size ( ) ; final Rectangle constrained Bounds = get Constrained Shell Bounds ( new Rectangle ( NUM , NUM , computed Size . x , computed Size . y ) ) ; minimum Size Enforcer = new Shell Minimum Size Enforcer ( dialog Shell , constrained Bounds . width , constrained Bounds . height ) ; final String message Format = STRING ; final String message = Message Format . format ( message Format , Integer . to String ( constrained Bounds . width ) , Integer . to String ( constrained Bounds . height ) ) ; log . trace ( message ) ; } if ( resizable Directions != ( SWT . HORIZONTAL | SWT . VERTICAL ) ) { resize Enforcer = new Shell Resize Enforcer ( dialog Shell , resizable Directions ) ; } }
@ Override protected void initialize Bounds ( ) { super . initialize Bounds ( ) ; final Shell dialog Shell = get Shell ( ) ; if ( enforce Minimum Size ) { final Point computed Size = default Compute Minimum Size ( ) ; final Rectangle constrained Bounds = get Constrained Shell Bounds ( new Rectangle ( NUM , NUM , computed Size . x , computed Size . y ) ) ; minimum Size Enforcer = new Shell Minimum Size Enforcer ( dialog Shell , constrained Bounds . width , constrained Bounds . height ) ; final String message Format = STRING ; final String message = Message Format . format ( message Format , Integer . to String ( constrained Bounds . width ) , Integer . to String ( constrained Bounds . height ) ) ; log . trace ( message ) ; } if ( resizable Directions != ( SWT . HORIZONTAL | SWT . VERTICAL ) ) { resize Enforcer = new Shell Resize Enforcer ( dialog Shell , resizable Directions ) ; } }
@ Override protected void initialize Bounds ( ) { super . initialize Bounds ( ) ; final Shell dialog Shell = get Shell ( ) ; if ( enforce Minimum Size ) { final Point computed Size = default Compute Minimum Size ( ) ; final Rectangle constrained Bounds = get Constrained Shell Bounds ( new Rectangle ( NUM , NUM , computed Size . x , computed Size . y ) ) ; minimum Size Enforcer = new Shell Minimum Size Enforcer ( dialog Shell , constrained Bounds . width , constrained Bounds . height ) ; final String message Format = STRING ; final String message = Message Format . format ( message Format , Integer . to String ( constrained Bounds . width ) , Integer . to String ( constrained Bounds . height ) ) ; log . trace ( message ) ; } if ( resizable Directions != ( SWT . HORIZONTAL | SWT . VERTICAL ) ) { resize Enforcer = new Shell Resize Enforcer ( dialog Shell , resizable Directions ) ; } }
private static String to String ( Serializable o ) throws IO Exception { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; Object Output Stream oos = new Object Output Stream ( baos ) ; oos . write Object ( o ) ; oos . close ( ) ; return new String ( Base 64 . encode ( baos . to Byte Array ( ) , Base 64 . DEFAULT ) ) ; }
private Token scan Flow Scalar ( char style ) { boolean double ; if ( style == STRING ) { double = BOOL ; } else { double = BOOL ; } String Builder chunks = new String Builder ( ) ; Mark start Mark = reader . get Mark ( ) ; char quote = reader . peek ( ) ; reader . forward ( ) ; chunks . append ( scan Flow Scalar Non Spaces ( double , start Mark ) ) ; while ( reader . peek ( ) != quote ) { chunks . append ( scan Flow Scalar Spaces ( start Mark ) ) ; chunks . append ( scan Flow Scalar Non Spaces ( double , start Mark ) ) ; } reader . forward ( ) ; Mark end Mark = reader . get Mark ( ) ; return new Scalar Token ( chunks . to String ( ) , BOOL , start Mark , end Mark , style ) ; }
public void reset ( ) { initialize ( ) ; }
protected Node binary Numeric Promotion ( Node node , Type Mirror expr Type ) { node = unbox ( node ) ; if ( ! types . is Same Type ( node . get Type ( ) , expr Type ) ) { Node widened = new Widening Conversion Node ( node . get Tree ( ) , node , expr Type ) ; add To Converted Lookup Map ( widened ) ; insert Node After ( widened , node ) ; return widened ; } else { return node ; } }
protected Node binary Numeric Promotion ( Node node , Type Mirror expr Type ) { node = unbox ( node ) ; if ( ! types . is Same Type ( node . get Type ( ) , expr Type ) ) { Node widened = new Widening Conversion Node ( node . get Tree ( ) , node , expr Type ) ; add To Converted Lookup Map ( widened ) ; insert Node After ( widened , node ) ; return widened ; } else { return node ; } }
protected Node binary Numeric Promotion ( Node node , Type Mirror expr Type ) { node = unbox ( node ) ; if ( ! types . is Same Type ( node . get Type ( ) , expr Type ) ) { Node widened = new Widening Conversion Node ( node . get Tree ( ) , node , expr Type ) ; add To Converted Lookup Map ( widened ) ; insert Node After ( widened , node ) ; return widened ; } else { return node ; } }
public String encode ( ) { String Buffer sb = new String Buffer ( ) ; encode ( sb ) ; return sb . to String ( ) ; }
public String encode ( ) { String Buffer sb = new String Buffer ( ) ; encode ( sb ) ; return sb . to String ( ) ; }
String read Literal ( String source , int ofs , String token ) { return read Substring ( source , ofs , ofs + token . length ( ) ) ; }
public void skip ( int n ) throws IO Exception { dis . skip ( n ) ; }
public long time ( int i ) { long offset = NUM ; for ( int j = indices . length - NUM ; j >= NUM ; j -- ) { if ( i >= indices [ j ] ) { offset = offsets [ j ] ; break ; } } return offset + rtimes [ i ] ; }
protected Raml Response extract Response From Method ( Method method , String response Comment ) { Raml Model Factory raml Model Factory = Raml Model Factory Of Factories . create Raml Model Factory ( ) ; Raml Response response = raml Model Factory . create Raml Response ( ) ; String mime = extract Mime Type From Method ( method ) ; Raml Mime Type json Type = raml Model Factory . create Raml Mime Type With Mime ( mime ) ; Class < ? > return Type = method . get Return Type ( ) ; Type generic Return Type = method . get Generic Return Type ( ) ; Type infer Generic Type = Type Helper . infer Generic Type ( generic Return Type ) ; if ( return Type != null && ( return Type . equals ( Deferred Result . class ) || return Type . equals ( Response Entity . class ) ) ) { if ( infer Generic Type == null ) { infer Generic Type = Object . class ; } if ( infer Generic Type instanceof Class ) { return Type = ( Class < ? > ) infer Generic Type ; } generic Return Type = infer Generic Type ; } json Type . set Schema ( Schema Helper . convert Class To Json Schema ( generic Return Type , response Comment , java Docs . get Java Doc ( return Type ) ) ) ; Linked Hash Map < String , Raml Mime Type > body = new Linked Hash Map < > ( ) ; body . put ( mime , json Type ) ; response . set Body ( body ) ; if ( String Utils . has Text ( response Comment ) ) { response . set Description ( response Comment ) ; } else { response . set Description ( STRING ) ; } return response ; }
protected Hash Entry create Entry ( Hash Entry next , int hash Code , Object key , Object value ) { return new Reference Entry ( this , next , hash Code , key , value ) ; }
public Result < Object [ ] > evaluate ( Class < ? > ... concepts ) throws Query Evaluation Exception { Tuple Query Result tuple = query . evaluate ( ) ; List < String > bindings = tuple . get Binding Names ( ) ; bindings = bindings . sub List ( NUM , concepts . length ) ; return new Result Impl ( new Object Array Cursor ( manager , tuple , bindings ) ) ; }
public Result < Object [ ] > evaluate ( Class < ? > ... concepts ) throws Query Evaluation Exception { Tuple Query Result tuple = query . evaluate ( ) ; List < String > bindings = tuple . get Binding Names ( ) ; bindings = bindings . sub List ( NUM , concepts . length ) ; return new Result Impl ( new Object Array Cursor ( manager , tuple , bindings ) ) ; }
public Result < Object [ ] > evaluate ( Class < ? > ... concepts ) throws Query Evaluation Exception { Tuple Query Result tuple = query . evaluate ( ) ; List < String > bindings = tuple . get Binding Names ( ) ; bindings = bindings . sub List ( NUM , concepts . length ) ; return new Result Impl ( new Object Array Cursor ( manager , tuple , bindings ) ) ; }
private Ease overlap ( int l ) { Ease a = new Ease ( ) ; for ( int noa = l ; noa < m level Num ; noa ++ ) { for ( int nob = m levels [ noa ] . m start ; nob < m levels [ noa ] . m end ; nob ++ ) { a . m amount = m groups [ nob ] . m right - m groups [ nob + NUM ] . m left + NUM ; if ( a . m amount >= NUM ) { a . m amount ++ ; a . m lev = noa ; a . m place = nob ; return a ; } } } return null ; }
private Ease overlap ( int l ) { Ease a = new Ease ( ) ; for ( int noa = l ; noa < m level Num ; noa ++ ) { for ( int nob = m levels [ noa ] . m start ; nob < m levels [ noa ] . m end ; nob ++ ) { a . m amount = m groups [ nob ] . m right - m groups [ nob + NUM ] . m left + NUM ; if ( a . m amount >= NUM ) { a . m amount ++ ; a . m lev = noa ; a . m place = nob ; return a ; } } } return null ; }
private Ease overlap ( int l ) { Ease a = new Ease ( ) ; for ( int noa = l ; noa < m level Num ; noa ++ ) { for ( int nob = m levels [ noa ] . m start ; nob < m levels [ noa ] . m end ; nob ++ ) { a . m amount = m groups [ nob ] . m right - m groups [ nob + NUM ] . m left + NUM ; if ( a . m amount >= NUM ) { a . m amount ++ ; a . m lev = noa ; a . m place = nob ; return a ; } } } return null ; }
private void write Journal ( Parcel File Descriptor new State , Backup Protos . Journal journal ) { File Output Stream out Stream = null ; try { out Stream = new File Output Stream ( new State . get File Descriptor ( ) ) ; final byte [ ] journal Bytes = write Checked Bytes ( journal ) ; out Stream . write ( journal Bytes ) ; out Stream . close ( ) ; if ( VERBOSE ) Log . v ( TAG , STRING + journal Bytes . length + STRING ) ; } catch ( IO Exception e ) { Log . w ( TAG , STRING , e ) ; } }
private void write Journal ( Parcel File Descriptor new State , Backup Protos . Journal journal ) { File Output Stream out Stream = null ; try { out Stream = new File Output Stream ( new State . get File Descriptor ( ) ) ; final byte [ ] journal Bytes = write Checked Bytes ( journal ) ; out Stream . write ( journal Bytes ) ; out Stream . close ( ) ; if ( VERBOSE ) Log . v ( TAG , STRING + journal Bytes . length + STRING ) ; } catch ( IO Exception e ) { Log . w ( TAG , STRING , e ) ; } }
private void write Journal ( Parcel File Descriptor new State , Backup Protos . Journal journal ) { File Output Stream out Stream = null ; try { out Stream = new File Output Stream ( new State . get File Descriptor ( ) ) ; final byte [ ] journal Bytes = write Checked Bytes ( journal ) ; out Stream . write ( journal Bytes ) ; out Stream . close ( ) ; if ( VERBOSE ) Log . v ( TAG , STRING + journal Bytes . length + STRING ) ; } catch ( IO Exception e ) { Log . w ( TAG , STRING , e ) ; } }
public void add Step ( final I Step step ) { if ( step == null ) throw new Illegal Argument Exception ( ) ; if ( step == this ) throw new Illegal Argument Exception ( ) ; steps . add ( step ) ; }
public static String build Failure Output ( Throwable cause ) { String message = get Message From Cause ( cause ) ; return STRING + message ; }
@ Override public boolean should Create Database Schema ( Set < String > created Database Schemas ) { return has Database Schema ( ) && ! created Database Schemas . contains ( get Database Schema ( ) ) ; }
@ Override public boolean should Create Database Schema ( Set < String > created Database Schemas ) { return has Database Schema ( ) && ! created Database Schemas . contains ( get Database Schema ( ) ) ; }
protected void validate Hole ( Base Line String Builder shell , Base Line String Builder hole ) { Hash Set exterior = Sets . new Hash Set ( shell . points ) ; Hash Set interior = Sets . new Hash Set ( hole . points ) ; exterior . retain All ( interior ) ; if ( exterior . size ( ) >= NUM ) { throw new Invalid Shape Exception ( STRING ) ; } }
protected void validate Hole ( Base Line String Builder shell , Base Line String Builder hole ) { Hash Set exterior = Sets . new Hash Set ( shell . points ) ; Hash Set interior = Sets . new Hash Set ( hole . points ) ; exterior . retain All ( interior ) ; if ( exterior . size ( ) >= NUM ) { throw new Invalid Shape Exception ( STRING ) ; } }
public void remove ( Rule rule ) { rules . remove ( rule ) ; }
public static String construct Queue Names Redis Key ( String shard Name ) { return String . format ( STRING , PINLATER QUEUE NAMES KEY PREFIX , shard Name ) ; }
public static String construct Queue Names Redis Key ( String shard Name ) { return String . format ( STRING , PINLATER QUEUE NAMES KEY PREFIX , shard Name ) ; }
private byte [ ] create Preview Buffer ( Size preview Size ) { int bits Per Pixel = Image Format . get Bits Per Pixel ( Image Format . NV 21 ) ; long size In Bits = preview Size . get Height ( ) * preview Size . get Width ( ) * bits Per Pixel ; int buffer Size = ( int ) Math . ceil ( size In Bits / NUM ) + NUM ; byte [ ] byte Array = new byte [ buffer Size ] ; Byte Buffer buffer = Byte Buffer . wrap ( byte Array ) ; if ( ! buffer . has Array ( ) || ( buffer . array ( ) != byte Array ) ) { throw new Illegal State Exception ( STRING ) ; } m Bytes To Byte Buffer . put ( byte Array , buffer ) ; return byte Array ; }
public void stop ( ) { synchronized ( private Instance Lock ) { if ( connection Accept Thread == null ) { return ; } } is Stopped . set ( BOOL ) ; try { connection Accept Thread . interrupt ( ) ; connection Accept Thread . join ( ) ; } catch ( Interrupted Exception e ) { } try { server Socket . close ( ) ; } catch ( IO Exception e ) { } }
public void start New Acceptor ( ) { Thread t = Access Controller . do Privileged ( new New Thread Action ( Connection Acceptor . this , STRING + ++ thread Num , BOOL ) ) ; t . start ( ) ; }
public void finish Painting ( boolean use Cache ) { Data Buffer Int data Buffer = new Data Buffer Int ( w0 * h0 ) ; int transparency = native Finish Painting ( Sun Writable Raster . steal Data ( data Buffer , NUM ) , w0 , h0 ) ; Sun Writable Raster . mark Dirty ( data Buffer ) ; int [ ] bands = BAND OFFSETS [ transparency - NUM ] ; Writable Raster raster = Raster . create Packed Raster ( data Buffer , w0 , h0 , w0 , bands , null ) ; Color Model cm = COLOR MODELS [ transparency - NUM ] ; Image img = new Buffered Image ( cm , raster , BOOL , null ) ; if ( use Cache ) { cache . set Image ( get Class ( ) , null , w0 , h0 , cache Args , img ) ; } graphics . draw Image ( img , x0 , y0 , null ) ; }
public void finish Painting ( boolean use Cache ) { Data Buffer Int data Buffer = new Data Buffer Int ( w0 * h0 ) ; int transparency = native Finish Painting ( Sun Writable Raster . steal Data ( data Buffer , NUM ) , w0 , h0 ) ; Sun Writable Raster . mark Dirty ( data Buffer ) ; int [ ] bands = BAND OFFSETS [ transparency - NUM ] ; Writable Raster raster = Raster . create Packed Raster ( data Buffer , w0 , h0 , w0 , bands , null ) ; Color Model cm = COLOR MODELS [ transparency - NUM ] ; Image img = new Buffered Image ( cm , raster , BOOL , null ) ; if ( use Cache ) { cache . set Image ( get Class ( ) , null , w0 , h0 , cache Args , img ) ; } graphics . draw Image ( img , x0 , y0 , null ) ; }
public void delete Environment ( Environment environment ) throws IO Exception { String id = environment . get Id ( ) ; Environment local = existing Environments . remove ( id ) ; if ( null != local ) { Files . delete If Exists ( path Resolver . get Environment File Path ( local ) ) ; Agent Mappings agent Mappings = agent Mappings Reference . get ( ) ; if ( check Environments ( agent Mappings ) ) { try { save Agent Mappings ( agent Mappings , BOOL ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; } } } }
private final boolean handle Blocked Write ( Byte Buffer buffer , Distribution Message msg ) throws Connection Exception { if ( ! add To Queue ( buffer , msg , BOOL ) ) { return BOOL ; } else { start Nio Pusher ( ) ; return BOOL ; } }
private void on Pause ( ) { m Subscription . unsubscribe ( ) ; m Dispatched Observables History . clear ( ) ; }
@ Override public void warn ( String msg ) { if ( logger . is Loggable ( Level . WARNING ) ) { log ( SELF , Level . WARNING , msg , null ) ; } }
public static String to String ( URI uri , Charset encoding ) throws IO Exception { return to String ( uri . to URL ( ) , Charsets . to Charset ( encoding ) ) ; }
public static String to String ( URI uri , Charset encoding ) throws IO Exception { return to String ( uri . to URL ( ) , Charsets . to Charset ( encoding ) ) ; }
public Set < Emoticon > find Matching Emoticons ( String emote Code ) { Set < Emoticon > found = new Hash Set < > ( ) ; found . add All ( find Matching Emoticons ( emote Code , emoticons By Emoteset . values ( ) ) ) ; found . add All ( find Matching Emoticons ( emote Code , stream Emoticons . values ( ) ) ) ; return found ; }
public Set < Emoticon > find Matching Emoticons ( String emote Code ) { Set < Emoticon > found = new Hash Set < > ( ) ; found . add All ( find Matching Emoticons ( emote Code , emoticons By Emoteset . values ( ) ) ) ; found . add All ( find Matching Emoticons ( emote Code , stream Emoticons . values ( ) ) ) ; return found ; }
public String Attribute Rule ( String name , String description , Enum [ ] valid , boolean optional ) { this ( name , description , null , optional , NUM , Integer . MAX VALUE ) ; valid Values = new Array List < String > ( ) ; for ( Enum a Valid : valid ) { valid Values . add ( a Valid . name ( ) ) ; } this . example = null ; }
public Download Task ( String url , Path to File ) { this ( url , to File , null , null ) ; }
public Download Task ( String url , Path to File ) { this ( url , to File , null , null ) ; }
public void after If Present ( T id ) { after . add ( id ) ; }
public void after If Present ( T id ) { after . add ( id ) ; }
Field find Field ( String name , int lineno , int override ) throws Configuration Exception { int dot = name . last Index Of ( STRING ) ; if ( dot < NUM ) { oops ( STRING + name , lineno , override ) ; } String class Name = name . substring ( NUM , dot ) ; Class c = find Class ( class Name , lineno , override , BOOL ) ; if ( c == null ) { oops ( STRING + name , lineno , override ) ; } String field Name = name . substring ( dot + NUM ) ; check Package Access ( c ) ; try { Field field = c . get Field ( field Name ) ; if ( ! Modifier . is Static ( field . get Modifiers ( ) ) ) { oops ( field Name + STRING + class Name , lineno , override ) ; } return field ; } catch ( No Such Field Exception e ) { oops ( field Name + STRING + class Name , lineno , override ) ; return null ; } }
public static boolean is Agree ( Feature Structure a Merge Fs , Map < String , List < Feature Structure > > a Annos Per User ) { for ( String usr : a Annos Per User . key Set ( ) ) { boolean agree = BOOL ; for ( Feature Structure usr Fs : a Annos Per User . get ( usr ) ) { if ( is Same Anno ( a Merge Fs , usr Fs ) ) { if ( ! agree ) { agree = BOOL ; } else if ( agree ) { return BOOL ; } } } if ( ! agree ) { return BOOL ; } } return BOOL ; }
protected boolean is Output Line Expected ( final String line , final String [ ] expected Prefixes , final boolean file Paths Are Expected ) { final String trimmed = line != null ? line . trim ( ) : null ; if ( String Utils . is Not Empty ( trimmed ) ) { if ( file Paths Are Expected && is File Path ( line ) ) { return BOOL ; } if ( expected Prefixes != null ) { for ( final String prefix : expected Prefixes ) { if ( String Utils . starts With Ignore Case ( line , prefix ) ) { return BOOL ; } } } return BOOL ; } return BOOL ; }
protected boolean is Output Line Expected ( final String line , final String [ ] expected Prefixes , final boolean file Paths Are Expected ) { final String trimmed = line != null ? line . trim ( ) : null ; if ( String Utils . is Not Empty ( trimmed ) ) { if ( file Paths Are Expected && is File Path ( line ) ) { return BOOL ; } if ( expected Prefixes != null ) { for ( final String prefix : expected Prefixes ) { if ( String Utils . starts With Ignore Case ( line , prefix ) ) { return BOOL ; } } } return BOOL ; } return BOOL ; }
protected boolean is Output Line Expected ( final String line , final String [ ] expected Prefixes , final boolean file Paths Are Expected ) { final String trimmed = line != null ? line . trim ( ) : null ; if ( String Utils . is Not Empty ( trimmed ) ) { if ( file Paths Are Expected && is File Path ( line ) ) { return BOOL ; } if ( expected Prefixes != null ) { for ( final String prefix : expected Prefixes ) { if ( String Utils . starts With Ignore Case ( line , prefix ) ) { return BOOL ; } } } return BOOL ; } return BOOL ; }
@ Override protected boolean handle Movement ( final RP Entity entity ) { if ( rand . next Double ( ) < probability ) { do Damage ( entity ) ; } return BOOL ; }
@ Override protected boolean handle Movement ( final RP Entity entity ) { if ( rand . next Double ( ) < probability ) { do Damage ( entity ) ; } return BOOL ; }
private Crumb create Filtered Navigation Crumb ( final Page Parameters base , final String key , final String value , final String display Value , final String locale , final Page Parameters page Parameters , final String brand Prefix , final String price Prefix , final String query Prefix , final String tag Prefix , final Map < String , I18 N Model > attribute Code Name ) { final Page Parameters without Current = wicket Util . get Filtered Request Parameters ( page Parameters , key , value ) ; String link Name = get Link Name Prefix ( key , locale , brand Prefix , price Prefix , query Prefix , tag Prefix , attribute Code Name ) ; if ( String Utils . is Not Blank ( link Name ) ) { link Name += STRING + get Link Name ( key , value , display Value ) ; } else { link Name = get Link Name ( key , value , display Value ) ; } base . add ( key , value ) ; return new Crumb ( key , link Name , null , new Page Parameters ( base ) , without Current ) ; }
private Crumb create Filtered Navigation Crumb ( final Page Parameters base , final String key , final String value , final String display Value , final String locale , final Page Parameters page Parameters , final String brand Prefix , final String price Prefix , final String query Prefix , final String tag Prefix , final Map < String , I18 N Model > attribute Code Name ) { final Page Parameters without Current = wicket Util . get Filtered Request Parameters ( page Parameters , key , value ) ; String link Name = get Link Name Prefix ( key , locale , brand Prefix , price Prefix , query Prefix , tag Prefix , attribute Code Name ) ; if ( String Utils . is Not Blank ( link Name ) ) { link Name += STRING + get Link Name ( key , value , display Value ) ; } else { link Name = get Link Name ( key , value , display Value ) ; } base . add ( key , value ) ; return new Crumb ( key , link Name , null , new Page Parameters ( base ) , without Current ) ; }
private Crumb create Filtered Navigation Crumb ( final Page Parameters base , final String key , final String value , final String display Value , final String locale , final Page Parameters page Parameters , final String brand Prefix , final String price Prefix , final String query Prefix , final String tag Prefix , final Map < String , I18 N Model > attribute Code Name ) { final Page Parameters without Current = wicket Util . get Filtered Request Parameters ( page Parameters , key , value ) ; String link Name = get Link Name Prefix ( key , locale , brand Prefix , price Prefix , query Prefix , tag Prefix , attribute Code Name ) ; if ( String Utils . is Not Blank ( link Name ) ) { link Name += STRING + get Link Name ( key , value , display Value ) ; } else { link Name = get Link Name ( key , value , display Value ) ; } base . add ( key , value ) ; return new Crumb ( key , link Name , null , new Page Parameters ( base ) , without Current ) ; }
public void dump ( Writer out ) throws IO Exception { out . write ( root Element . get Canonical Form ( ) ) ; }
public void dump ( Writer out ) throws IO Exception { out . write ( root Element . get Canonical Form ( ) ) ; }
public void wrap ( final int stream Id , final Frame Type type , final Byte Buffer data ) { POOL . release ( this . direct Buffer ) ; this . direct Buffer = POOL . acquire Mutable Direct Buffer ( Frame Header Flyweight . compute Frame Header Length ( type , NUM , data . remaining ( ) ) ) ; this . length = Frame Header Flyweight . encode ( this . direct Buffer , offset , stream Id , NUM , type , NULL BYTEBUFFER , data ) ; }
public boolean is Default ( String scope , String key ) { synchronized ( m Lock ) { String default Value = get String Default ( key ) ; String value = get String ( scope , key ) ; return value == null ? BOOL : value . equals ( default Value ) ; } }
public PT Property add Property ( final PT Property property ) { if ( properties . contains ( property ) ) { throw new Illegal Argument Exception ( STRING + property . get Name ( ) + STRING ) ; } properties . add ( property ) ; property . set Parent Table ( this ) ; return property ; }
@ Override public Task Bulk Rep query Bulk Resource Reps ( List < URI > ids ) { Iterator < Task > db Iterator = db Client . query Iterative Objects ( get Resource Class ( ) , ids ) ; return new Task Bulk Rep ( Bulk List . wrapping ( db Iterator , Map Task . get Instance ( ) ) ) ; }
@ Override public Task Bulk Rep query Bulk Resource Reps ( List < URI > ids ) { Iterator < Task > db Iterator = db Client . query Iterative Objects ( get Resource Class ( ) , ids ) ; return new Task Bulk Rep ( Bulk List . wrapping ( db Iterator , Map Task . get Instance ( ) ) ) ; }
public double clip Gradients ( ) { double gscale = NUM ; if ( clipping Enabled ) { double gg = model . gradient L 2 norm ( ) ; if ( Double . is Na N ( gg ) || Double . is Infinite ( gg ) ) { throw new Runtime Exception ( STRING + gg ) ; } if ( gg > clip Threshold ) { ++ clips ; gscale = clip Threshold / gg ; } } return gscale ; }
public double clip Gradients ( ) { double gscale = NUM ; if ( clipping Enabled ) { double gg = model . gradient L 2 norm ( ) ; if ( Double . is Na N ( gg ) || Double . is Infinite ( gg ) ) { throw new Runtime Exception ( STRING + gg ) ; } if ( gg > clip Threshold ) { ++ clips ; gscale = clip Threshold / gg ; } } return gscale ; }
public void write UI 16 ( int value ) throws IO Exception { flush Bits ( ) ; out . write ( value & NUM ) ; out . write ( value > > NUM ) ; bytes Written += NUM ; }
public Feature Definition subset ( String [ ] feature Names To Drop ) { List < Integer > feature Indices To Drop = new Array List < Integer > ( ) ; for ( String feature Name : feature Names To Drop ) { int feature Index ; try { feature Index = get Feature Index ( feature Name ) ; feature Indices To Drop . add ( feature Index ) ; } catch ( Illegal Argument Exception e ) { System . err . println ( STRING + feature Name + STRING ) ; } } Feature Definition sub Definition = null ; try { Byte Array Output Stream to Memory = new Byte Array Output Stream ( ) ; Data Output output = new Data Output Stream ( to Memory ) ; write Binary To ( output , feature Indices To Drop ) ; byte [ ] memory = to Memory . to Byte Array ( ) ; Byte Array Input Stream from Memory = new Byte Array Input Stream ( memory ) ; Data Input input = new Data Input Stream ( from Memory ) ; sub Definition = new Feature Definition ( input ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } assert this . contains ( sub Definition ) ; return sub Definition ; }
public License ( final String filename , final String text ) { if ( filename == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( filename . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . filename = filename ; if ( text == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( text . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . text = text ; }
public License ( final String filename , final String text ) { if ( filename == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( filename . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . filename = filename ; if ( text == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( text . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . text = text ; }
public String left Str ( String str , int length ) { return str . substring ( NUM , Math . min ( str . length ( ) , length ) ) ; }
public boolean is Container Class ( String clz ) { return droid Safe Container Classes . contains ( clz ) ; }
public boolean is Container Class ( String clz ) { return droid Safe Container Classes . contains ( clz ) ; }
public boolean is Container Class ( String clz ) { return droid Safe Container Classes . contains ( clz ) ; }
public boolean remove Shutdown Hook ( Thread hook ) { if ( hook == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( shutting Down ) { throw new Illegal State Exception ( STRING ) ; } synchronized ( shutdown Hooks ) { return shutdown Hooks . remove ( hook ) ; } }
public Cors Service Builder allow Request Methods ( final Http Method ... methods ) { require Non Null ( methods , STRING ) ; for ( int i = NUM ; i < methods . length ; i ++ ) { if ( methods [ i ] == null ) { throw new Null Pointer Exception ( STRING + i + STRING ) ; } } Collections . add All ( allowed Request Methods , methods ) ; return this ; }
public Cors Service Builder allow Request Methods ( final Http Method ... methods ) { require Non Null ( methods , STRING ) ; for ( int i = NUM ; i < methods . length ; i ++ ) { if ( methods [ i ] == null ) { throw new Null Pointer Exception ( STRING + i + STRING ) ; } } Collections . add All ( allowed Request Methods , methods ) ; return this ; }
public static Double evaluate To Double ( String expression , Map < String , Object > vars ) { Object result = evaluate ( expression , vars ) ; if ( result == null ) { throw new Illegal State Exception ( STRING ) ; } if ( ! is Numeric ( String . value Of ( result ) ) ) { throw new Illegal State Exception ( STRING + result + STRING + result . get Class ( ) ) ; } return Double . value Of ( String . value Of ( result ) ) ; }
public void remove Listeners ( ) { if ( global Listener != null ) { try { Invoker Helper . invoke Method ( current Object , STRING , global Listener ) ; } catch ( Exception e ) { } global Listener = null ; } if ( local Listener != null ) { try { Invoker Helper . invoke Method ( current Object , STRING , new Object [ ] { property Name , local Listener } ) ; } catch ( Exception e ) { } local Listener = null ; } if ( synthetic Full Binding != null ) { synthetic Full Binding . unbind ( ) ; } }
private Http Request Base build Request ( Method method , URI uri ) { switch ( method ) { case GET : return new Http Get ( uri ) ; default : throw new Unsupported Operation Exception ( STRING + method ) ; } }
public static boolean v Pool Specifies Snapshots ( final Virtual Pool virtual Pool ) { if ( virtual Pool . get Max Native Snapshots ( ) == null ) { return BOOL ; } return virtual Pool . get Max Native Snapshots ( ) != MAX DISABLED ; }
public static boolean v Pool Specifies Snapshots ( final Virtual Pool virtual Pool ) { if ( virtual Pool . get Max Native Snapshots ( ) == null ) { return BOOL ; } return virtual Pool . get Max Native Snapshots ( ) != MAX DISABLED ; }
@ Nullable public EC Key find Oldest Key After ( long time Secs ) { lock . lock ( ) ; try { EC Key oldest = null ; for ( EC Key key : hash To Keys . values ( ) ) { final long key Time = key . get Creation Time Seconds ( ) ; if ( key Time > time Secs ) { if ( oldest == null || oldest . get Creation Time Seconds ( ) > key Time ) oldest = key ; } } return oldest ; } finally { lock . unlock ( ) ; } }
public Mutable String ( final char [ ] a ) { make Compact Mutable String ( a . length ) ; System . arraycopy ( a , NUM , array , NUM , array . length ) ; }
public Mutable String ( final char [ ] a ) { make Compact Mutable String ( a . length ) ; System . arraycopy ( a , NUM , array , NUM , array . length ) ; }
public Color Difference ( ) { Timer timer = new Timer ( NUM , this ) ; timer . start ( ) ; set Preferred Size ( new Dimension ( NUM , NUM ) ) ; }
@ Rpc Method public void detach Disks ( String vm Id , List < String > disk Ids , Async Method Callback < Host . Async Client . detach disks call > handler ) throws Rpc Exception { ensure Client ( ) ; Vm Disks Detach Request vm Disks Detach Request = new Vm Disks Detach Request ( vm Id , disk Ids ) ; client Proxy . set Timeout ( DETACH DISKS TIMEOUT MS ) ; logger . info ( STRING , vm Id , disk Ids , get Host Ip ( ) , vm Disks Detach Request ) ; try { client Proxy . detach disks ( vm Disks Detach Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Rpc Method public void detach Disks ( String vm Id , List < String > disk Ids , Async Method Callback < Host . Async Client . detach disks call > handler ) throws Rpc Exception { ensure Client ( ) ; Vm Disks Detach Request vm Disks Detach Request = new Vm Disks Detach Request ( vm Id , disk Ids ) ; client Proxy . set Timeout ( DETACH DISKS TIMEOUT MS ) ; logger . info ( STRING , vm Id , disk Ids , get Host Ip ( ) , vm Disks Detach Request ) ; try { client Proxy . detach disks ( vm Disks Detach Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public void add ( final Sensor sensor ) { Set < Sensor > old Selection = new Hash Set < Sensor > ( selection ) ; boolean rv = selection . add ( sensor ) ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } }
public void cancel Task No Exception ( Task task ) { try { cancel Task ( task ) ; } catch ( Exception e ) { log . error ( STRING ) ; } }
public void close ( ) { try { stream . close ( ) ; } catch ( IO Exception e ) { throw new Form Upload Exception ( STRING , e ) ; } }
public Activity current Activity ( ) { Activity activity = activity Stack . last Element ( ) ; return activity ; }
public static synchronized Collection < String > all Local Ips ( ) { List < String > ips = new Array List < > ( NUM ) ; try { Enumeration < Network Interface > itfs = Network Interface . get Network Interfaces ( ) ; if ( itfs != null ) { for ( Network Interface itf : as Iterable ( itfs ) ) { if ( ! itf . is Loopback ( ) ) { Enumeration < Inet Address > addrs = itf . get Inet Addresses ( ) ; for ( Inet Address addr : as Iterable ( addrs ) ) { String host Addr = addr . get Host Address ( ) ; if ( ! addr . is Loopback Address ( ) && ! ips . contains ( host Addr ) ) ips . add ( host Addr ) ; } } } } } catch ( Socket Exception ignore ) { return Collections . empty List ( ) ; } Collections . sort ( ips ) ; return ips ; }
public static List < String > as String List ( Collection < ? extends Object > objects ) { List < String > list = new Array List < > ( ) ; for ( Object object : objects ) { list . add ( String . value Of ( object ) ) ; } return list ; }
public static List < String > as String List ( Collection < ? extends Object > objects ) { List < String > list = new Array List < > ( ) ; for ( Object object : objects ) { list . add ( String . value Of ( object ) ) ; } return list ; }
public static List < String > as String List ( Collection < ? extends Object > objects ) { List < String > list = new Array List < > ( ) ; for ( Object object : objects ) { list . add ( String . value Of ( object ) ) ; } return list ; }
public static List < String > as String List ( Collection < ? extends Object > objects ) { List < String > list = new Array List < > ( ) ; for ( Object object : objects ) { list . add ( String . value Of ( object ) ) ; } return list ; }
@ Override protected void on Draw ( Canvas canvas ) { super . on Draw ( canvas ) ; if ( m Bitmap Cover Image != null ) canvas . draw Bitmap ( m Bitmap Cover Image , NUM , NUM , m Paint Cover Image ) ; canvas . draw Rect ( NUM , NUM , m Width , m Height , m Paint Cover Mask ) ; m Drawable Bottom Shadow . draw ( canvas ) ; canvas . draw Rect ( rect F Empty Progress , m Paint Empty Progress ) ; canvas . draw Rect ( NUM , m Height - m Progress Height , m Current Progress Position , m Height , m Paint Loaded Progress ) ; canvas . draw Rect ( NUM , NUM , m Current Progress Position , m Height , m Paint Progress Mask ) ; m Text Passed Duration = seconds To Time ( m Current Seconds ) ; m Paint Text Duration . get Text Bounds ( m Text Passed Duration , NUM , m Text Passed Duration . length ( ) , rect F Text Duration ) ; canvas . draw Text ( m Text Passed Duration , m Width / NUM , m Height - m Width / NUM - rect F Text Duration . height ( ) , m Paint Text Duration ) ; m Text Left Duration = seconds To Time ( m Max Seconds - m Current Seconds ) ; m Paint Text Duration . get Text Bounds ( m Text Left Duration , NUM , m Text Left Duration . length ( ) , rect F Text Duration ) ; canvas . draw Text ( m Text Left Duration , ( NUM * m Width / NUM ) - rect F Text Duration . width ( ) , m Height - m Width / NUM - rect F Text Duration . height ( ) , m Paint Text Duration ) ; }
public void test Has Attribute NS 1 ( ) throws Throwable { Document doc ; Element element ; boolean state ; Node List element List ; doc = ( Document ) load ( STRING , builder ) ; element List = doc . get Elements By Tag Name NS ( STRING , STRING ) ; element = ( Element ) element List . item ( NUM ) ; state = element . has Attribute NS ( STRING , STRING ) ; assert True ( STRING , state ) ; }
private boolean is Pending ( Block Mirror mirror ) { return ! is Inactive ( mirror ) && is Null Or Empty ( mirror . get Synchronized Instance ( ) ) ; }
public static String read ( final String filename ) { try { return as String ( new File Input Stream ( new File ( filename ) ) , Charset . default Charset ( ) ) ; } catch ( IO Exception e ) { logger . warn ( STRING , filename , e ) ; return null ; } }
public final void clear ( ) throws IO Exception { clear Internal ( ) ; record Count . set ( NUM ) ; }
public final void clear ( ) throws IO Exception { clear Internal ( ) ; record Count . set ( NUM ) ; }
public boolean has Next ( ) { return iterator . has Next ( ) ; }
public boolean has Next ( ) { return iterator . has Next ( ) ; }
public boolean has Next ( ) { return iterator . has Next ( ) ; }
public boolean has Next ( ) { return iterator . has Next ( ) ; }
public void deploy ( String route Id , String route Name , Json Value route Config ) throws Router Handler Exception { Reject . if Null ( route Name ) ; write . lock ( ) ; try { load ( route Id , route Name , route Config . copy ( ) ) ; directory Monitor . store ( route Id , route Config ) ; logger . info ( STRING , route Id , route Name ) ; } catch ( IO Exception e ) { throw new Router Handler Exception ( format ( STRING , route Id ) , e ) ; } finally { write . unlock ( ) ; } }
public void deploy ( String route Id , String route Name , Json Value route Config ) throws Router Handler Exception { Reject . if Null ( route Name ) ; write . lock ( ) ; try { load ( route Id , route Name , route Config . copy ( ) ) ; directory Monitor . store ( route Id , route Config ) ; logger . info ( STRING , route Id , route Name ) ; } catch ( IO Exception e ) { throw new Router Handler Exception ( format ( STRING , route Id ) , e ) ; } finally { write . unlock ( ) ; } }
private boolean is Remote Download Allowed ( ) { return try Repo Cnt <= MAX REPO RETRIES || System . current Time Millis ( ) >= expire Time ; }
private boolean is Remote Download Allowed ( ) { return try Repo Cnt <= MAX REPO RETRIES || System . current Time Millis ( ) >= expire Time ; }
private boolean is Remote Download Allowed ( ) { return try Repo Cnt <= MAX REPO RETRIES || System . current Time Millis ( ) >= expire Time ; }
private boolean is Remote Download Allowed ( ) { return try Repo Cnt <= MAX REPO RETRIES || System . current Time Millis ( ) >= expire Time ; }
private boolean is Remote Download Allowed ( ) { return try Repo Cnt <= MAX REPO RETRIES || System . current Time Millis ( ) >= expire Time ; }
public void test Close 1 ( ) { try { target . close ( ) ; target . next ( ) ; fail ( STRING ) ; } catch ( SQL Exception e ) { } }
public void test Close 1 ( ) { try { target . close ( ) ; target . next ( ) ; fail ( STRING ) ; } catch ( SQL Exception e ) { } }
public void test Close 1 ( ) { try { target . close ( ) ; target . next ( ) ; fail ( STRING ) ; } catch ( SQL Exception e ) { } }
public void test Close 1 ( ) { try { target . close ( ) ; target . next ( ) ; fail ( STRING ) ; } catch ( SQL Exception e ) { } }
public void test Close 1 ( ) { try { target . close ( ) ; target . next ( ) ; fail ( STRING ) ; } catch ( SQL Exception e ) { } }
public void send ( String name , String value , long timestamp ) throws IO Exception { metrics . add ( new Metric Tuple ( sanitize ( name ) , timestamp , sanitize ( value ) ) ) ; if ( metrics . size ( ) >= batch Size ) { write Metrics ( ) ; } }
public void send ( String name , String value , long timestamp ) throws IO Exception { metrics . add ( new Metric Tuple ( sanitize ( name ) , timestamp , sanitize ( value ) ) ) ; if ( metrics . size ( ) >= batch Size ) { write Metrics ( ) ; } }
public Dot Node ( int i , int j , Trie trie Node , Array List < Super Node > ant Super Nodes , Source Path src Path ) { this . i = i ; this . j = j ; this . trie Node = trie Node ; this . ant Super Nodes = ant Super Nodes ; this . src Path = src Path ; }
public MGRS Point ( ) { DEBUG = logger . is Loggable ( Level . FINE ) ; }
public MGRS Point ( ) { DEBUG = logger . is Loggable ( Level . FINE ) ; }
public MGRS Point ( ) { DEBUG = logger . is Loggable ( Level . FINE ) ; }
public static int [ ] create MSB Mask ( int bits ) { int m = NUM , orig = NUM - bits ; while ( bits -- > NUM ) { m |= NUM ; m <<= NUM ; } while ( -- orig > NUM ) { m <<= NUM ; } return new int [ ] { ( m > > NUM ) & NUM , ( m > > NUM ) & NUM , ( m > > NUM ) & NUM , m & NUM } ; }
public static String byte Array To Hex String ( byte in [ ] , int offset ) { if ( in == null || in . length <= NUM || offset >= in . length ) return null ; String Buffer out = new String Buffer ( in . length * NUM ) ; for ( int i = offset ; i < in . length ; i ++ ) { out . append ( byte To Hex String ( in [ i ] ) ) ; out . append ( STRING ) ; } return out . to String ( ) ; }
@ Override public int compare To ( Db Entry another ) { if ( item Type == Launcher Settings . Favorites . ITEM TYPE APPWIDGET ) { if ( another . item Type == Launcher Settings . Favorites . ITEM TYPE APPWIDGET ) { return another . span Y * another . span X - span X * span Y ; } else { return - NUM ; } } else if ( another . item Type == Launcher Settings . Favorites . ITEM TYPE APPWIDGET ) { return NUM ; } else { return Float . compare ( another . weight , weight ) ; } }
public void fill Field Values ( ) { if ( ! is Creation Dialog ) { tf Synapse Group Label . set Text ( synapse Group . get Label ( ) ) ; } else { tf Synapse Group Label . set Text ( STRING ) ; } }
@ Deprecated public static Source Data Tag Quality from XML ( Element dom Element ) { Node List fields = dom Element . get Child Nodes ( ) ; int fields Count = fields . get Length ( ) ; String field Name ; String field Value String ; Node field Node ; Source Data Tag Quality result = new Source Data Tag Quality ( ) ; for ( int i = NUM ; i != fields Count ; i ++ ) { field Node = fields . item ( i ) ; if ( field Node . get Node Type ( ) == Node . ELEMENT NODE ) { field Name = field Node . get Node Name ( ) ; Node field Value Node = field Node . get First Child ( ) ; if ( field Value Node != null ) { field Value String = field Value Node . get Node Value ( ) ; } else { field Value String = STRING ; } if ( field Name . equals ( XML ELEMENT QUALITY CODE ) ) { short code = Short . parse Short ( field Value String ) ; result . quality Code = Source Data Tag Quality Code . get Enum ( code ) ; } else if ( field Name . equals ( XML ELEMENT QUALITY DESC ) ) { result . description = field Value String ; } } } return result ; }
private void reflect Member Variables In Final Button ( ) { final boolean last Page Reached = ( view Pager . get Current Item ( ) + NUM ) == pages . size ( ) ; final boolean button Should Be Invisible = ! last Page Reached || final Button Disabled ; final boolean button Is Currently Invisible = final Button . get Visibility ( ) == View . INVISIBLE ; final boolean should Update Button = button Should Be Invisible != button Is Currently Invisible ; if ( should Update Button ) { final Animator button Animator = button Should Be Invisible ? button Animator Factory . new Final Button Disappear Animator ( final Button ) : button Animator Factory . new Final Button Appear Animator ( final Button ) ; if ( button Should Be Invisible ) { disable Button ( button Animator , final Button ) ; } else { enable Button ( button Animator , final Button ) ; } } }
public void add File ( String path ) throws IO Exception { File new File = new File ( path ) ; if ( ! new File . exists ( ) ) { throw new IO Exception ( STRING + new File . get Absolute Path ( ) ) ; } if ( Delphi Utils . accept File ( new File . get Absolute Path ( ) ) ) { files . add ( new File ) ; } }
protected double regression Prediction ( Instance transformed Instance , boolean [ ] selected Attributes , double [ ] coefficients ) throws Exception { double result = NUM ; int column = NUM ; for ( int j = NUM ; j < transformed Instance . num Attributes ( ) ; j ++ ) { if ( ( m Class Index != j ) && ( selected Attributes [ j ] ) ) { result += coefficients [ column ] * transformed Instance . value ( j ) ; column ++ ; } } result += coefficients [ column ] ; return result ; }
void process Add On Changes ( Window caller , Add On Dependency Checker . Add On Changes Result changes ) { if ( addons Dialog != null ) { addons Dialog . set Downloading Updates ( ) ; } if ( get View ( ) != null ) { Set < Add On > add Ons = new Hash Set < > ( changes . get Uninstalls ( ) ) ; add Ons . add All ( changes . get Old Versions ( ) ) ; Set < Extension > extensions = new Hash Set < > ( ) ; extensions . add All ( changes . get Unload Extensions ( ) ) ; extensions . add All ( changes . get Soft Unload Extensions ( ) ) ; if ( ! warn Unsaved Resources Or Active Actions ( caller , add Ons , extensions , BOOL ) ) { return ; } } uninstall Add Ons ( caller , changes . get Uninstalls ( ) , BOOL ) ; Set < Add On > all Addons = new Hash Set < > ( changes . get New Versions ( ) ) ; all Addons . add All ( changes . get Installs ( ) ) ; for ( Add On add On : all Addons ) { if ( addons Dialog != null ) { addons Dialog . notify Add On Downloading ( add On ) ; } download Add On ( add On ) ; } }
public void deregister ( UUID transaction Id ) throws Repository Exception { synchronized ( primary Cache ) { Cache Entry entry = primary Cache . get If Present ( transaction Id ) ; if ( entry == null ) { throw new Repository Exception ( STRING + transaction Id . to String ( ) + STRING ) ; } else { primary Cache . invalidate ( transaction Id ) ; secondary Cache . invalidate ( transaction Id ) ; logger . debug ( STRING , transaction Id ) ; } } }
public Buffered Image render ( I18 n Format format ) { int image Width = LEGEND TOTAL WIDTH ; int image Height = calculate Image Height ( ) ; Buffered Image image = new Buffered Image ( image Width , image Height , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D graphics = ( Graphics 2 D ) image . get Graphics ( ) ; graphics . set Rendering Hint ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; graphics . translate ( LEGEND MARGIN LEFT , NUM ) ; for ( Legend legend : legends ) { legend . draw ( graphics , format ) ; graphics . translate ( NUM , LEGEND MARGIN BOTTOM ) ; } return image ; }
public Buffered Image render ( I18 n Format format ) { int image Width = LEGEND TOTAL WIDTH ; int image Height = calculate Image Height ( ) ; Buffered Image image = new Buffered Image ( image Width , image Height , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D graphics = ( Graphics 2 D ) image . get Graphics ( ) ; graphics . set Rendering Hint ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; graphics . translate ( LEGEND MARGIN LEFT , NUM ) ; for ( Legend legend : legends ) { legend . draw ( graphics , format ) ; graphics . translate ( NUM , LEGEND MARGIN BOTTOM ) ; } return image ; }
public static boolean is File Exist ( String file Path ) { if ( Handler String . is Blank ( file Path ) ) { return BOOL ; } File file = new File ( file Path ) ; return ( file . exists ( ) && file . is File ( ) ) ; }
public static boolean is File Exist ( String file Path ) { if ( Handler String . is Blank ( file Path ) ) { return BOOL ; } File file = new File ( file Path ) ; return ( file . exists ( ) && file . is File ( ) ) ; }
public void add Turntable ( Point 2 D pt ) { num Layout Turntables ++ ; String name = STRING ; boolean duplicate = BOOL ; while ( duplicate ) { name = STRING + num Layout Turntables ; if ( finder . find Layout Turntable By Name ( name ) == null ) { duplicate = BOOL ; } if ( duplicate ) { num Layout Turntables ++ ; } } Layout Turntable x = new Layout Turntable ( name , pt , this ) ; turntable List . add ( x ) ; set Dirty ( BOOL ) ; x . add Ray ( NUM ) ; x . add Ray ( NUM ) ; x . add Ray ( NUM ) ; x . add Ray ( NUM ) ; }
public void add Turntable ( Point 2 D pt ) { num Layout Turntables ++ ; String name = STRING ; boolean duplicate = BOOL ; while ( duplicate ) { name = STRING + num Layout Turntables ; if ( finder . find Layout Turntable By Name ( name ) == null ) { duplicate = BOOL ; } if ( duplicate ) { num Layout Turntables ++ ; } } Layout Turntable x = new Layout Turntable ( name , pt , this ) ; turntable List . add ( x ) ; set Dirty ( BOOL ) ; x . add Ray ( NUM ) ; x . add Ray ( NUM ) ; x . add Ray ( NUM ) ; x . add Ray ( NUM ) ; }
void z Apply Allow Empty Dates ( ) { if ( ! has Parent ( ) ) { return ; } Local Date selected Date = z Get Parent Selected Date ( ) ; if ( ( ! allow Empty Dates ) && ( selected Date == null ) ) { Local Date today = Local Date . now ( ) ; if ( Internal Utilities . is Date Vetoed ( veto Policy , today ) ) { throw new Runtime Exception ( STRING + STRING + STRING + STRING ) ; } z Set Parent Selected Date ( today ) ; } }
void z Apply Allow Empty Dates ( ) { if ( ! has Parent ( ) ) { return ; } Local Date selected Date = z Get Parent Selected Date ( ) ; if ( ( ! allow Empty Dates ) && ( selected Date == null ) ) { Local Date today = Local Date . now ( ) ; if ( Internal Utilities . is Date Vetoed ( veto Policy , today ) ) { throw new Runtime Exception ( STRING + STRING + STRING + STRING ) ; } z Set Parent Selected Date ( today ) ; } }
void z Apply Allow Empty Dates ( ) { if ( ! has Parent ( ) ) { return ; } Local Date selected Date = z Get Parent Selected Date ( ) ; if ( ( ! allow Empty Dates ) && ( selected Date == null ) ) { Local Date today = Local Date . now ( ) ; if ( Internal Utilities . is Date Vetoed ( veto Policy , today ) ) { throw new Runtime Exception ( STRING + STRING + STRING + STRING ) ; } z Set Parent Selected Date ( today ) ; } }
void z Apply Allow Empty Dates ( ) { if ( ! has Parent ( ) ) { return ; } Local Date selected Date = z Get Parent Selected Date ( ) ; if ( ( ! allow Empty Dates ) && ( selected Date == null ) ) { Local Date today = Local Date . now ( ) ; if ( Internal Utilities . is Date Vetoed ( veto Policy , today ) ) { throw new Runtime Exception ( STRING + STRING + STRING + STRING ) ; } z Set Parent Selected Date ( today ) ; } }
public final static String create Hex Fingerprint ( String keytype , byte [ ] publickey ) { byte [ ] raw = raw Finger Print ( STRING , keytype , publickey ) ; return raw To Hex Fingerprint ( raw ) ; }
@ Suppress Lint ( STRING ) public static String replace Unicode Digits ( String number ) { String Builder normalized Digits = new String Builder ( number . length ( ) ) ; for ( char c : number . to Char Array ( ) ) { int digit = Character . digit ( c , NUM ) ; if ( digit != - NUM ) { normalized Digits . append ( digit ) ; } else { normalized Digits . append ( c ) ; } } return normalized Digits . to String ( ) ; }
public static String Builder left Shift ( String Builder self , Object value ) { self . append ( value ) ; return self ; }
public void add Listener ( final ISPARQL Update Listener l ) { if ( is Read Only ( ) ) throw new Unsupported Operation Exception ( ) ; if ( l == null ) throw new Illegal Argument Exception ( ) ; listeners . add ( l ) ; }
private void read Button Action Performed ( ) { if ( num Ur 92 == NUM ) { scan Button Action Performed ( ) ; return ; } swing Name Value Field . set Foreground ( COLOR OK ) ; swing Channel Value Field . set Foreground ( COLOR OK ) ; swing Password Value Field . set Foreground ( COLOR OK ) ; swing Id Value Field . set Foreground ( COLOR OK ) ; swing Name Value Field . set Text ( rb . get String ( STRING ) ) ; swing Channel Value Field . set Text ( rb . get String ( STRING ) ) ; swing Password Value Field . set Text ( rb . get String ( STRING ) ) ; swing Id Value Field . set Text ( rb . get String ( STRING ) ) ; update Status Line Message ( STRING , COLOR STATUS OK ) ; duplex Group Implementation . query Duplex Group Identity ( ) ; update Status Line Message ( STRING , COLOR STATUS OK ) ; }
private void read Button Action Performed ( ) { if ( num Ur 92 == NUM ) { scan Button Action Performed ( ) ; return ; } swing Name Value Field . set Foreground ( COLOR OK ) ; swing Channel Value Field . set Foreground ( COLOR OK ) ; swing Password Value Field . set Foreground ( COLOR OK ) ; swing Id Value Field . set Foreground ( COLOR OK ) ; swing Name Value Field . set Text ( rb . get String ( STRING ) ) ; swing Channel Value Field . set Text ( rb . get String ( STRING ) ) ; swing Password Value Field . set Text ( rb . get String ( STRING ) ) ; swing Id Value Field . set Text ( rb . get String ( STRING ) ) ; update Status Line Message ( STRING , COLOR STATUS OK ) ; duplex Group Implementation . query Duplex Group Identity ( ) ; update Status Line Message ( STRING , COLOR STATUS OK ) ; }
public static String hypen To Camel Notation ( String str ) { if ( is Empty ( str ) ) return str ; String Builder sb = new String Builder ( ) ; int len = str . length ( ) ; char c ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) { c = str . char At ( i ) ; if ( c == STRING ) { if ( len > ++ i ) sb . append ( Character . to Upper Case ( str . char At ( i ) ) ) ; } else sb . append ( c ) ; } return sb . to String ( ) ; }
public void do Print Setup ( ) { do Print ( ) ; }
public void do Print Setup ( ) { do Print ( ) ; }
public void do Print Setup ( ) { do Print ( ) ; }
public Auth Request authenticate ( List discoveries , String return To Url ) throws Consumer Exception , Message Exception { return authenticate ( discoveries , return To Url , return To Url ) ; }
public Auth Request authenticate ( List discoveries , String return To Url ) throws Consumer Exception , Message Exception { return authenticate ( discoveries , return To Url , return To Url ) ; }
public Auth Request authenticate ( List discoveries , String return To Url ) throws Consumer Exception , Message Exception { return authenticate ( discoveries , return To Url , return To Url ) ; }
public Auth Request authenticate ( List discoveries , String return To Url ) throws Consumer Exception , Message Exception { return authenticate ( discoveries , return To Url , return To Url ) ; }
public Auth Request authenticate ( List discoveries , String return To Url ) throws Consumer Exception , Message Exception { return authenticate ( discoveries , return To Url , return To Url ) ; }
public Utf 8 Constant ( Constant Pool pool , int index , String value ) { super ( pool , index ) ; value = value ; }
public synchronized boolean read Request Immediate ( ) { if ( current Writers == NUM && writer Locks . size ( ) == NUM ) { ++ current Readers ; return BOOL ; } return BOOL ; }
public synchronized boolean read Request Immediate ( ) { if ( current Writers == NUM && writer Locks . size ( ) == NUM ) { ++ current Readers ; return BOOL ; } return BOOL ; }
public synchronized boolean read Request Immediate ( ) { if ( current Writers == NUM && writer Locks . size ( ) == NUM ) { ++ current Readers ; return BOOL ; } return BOOL ; }
public synchronized boolean read Request Immediate ( ) { if ( current Writers == NUM && writer Locks . size ( ) == NUM ) { ++ current Readers ; return BOOL ; } return BOOL ; }
public synchronized boolean read Request Immediate ( ) { if ( current Writers == NUM && writer Locks . size ( ) == NUM ) { ++ current Readers ; return BOOL ; } return BOOL ; }
public synchronized boolean read Request Immediate ( ) { if ( current Writers == NUM && writer Locks . size ( ) == NUM ) { ++ current Readers ; return BOOL ; } return BOOL ; }
public synchronized boolean read Request Immediate ( ) { if ( current Writers == NUM && writer Locks . size ( ) == NUM ) { ++ current Readers ; return BOOL ; } return BOOL ; }
public synchronized boolean read Request Immediate ( ) { if ( current Writers == NUM && writer Locks . size ( ) == NUM ) { ++ current Readers ; return BOOL ; } return BOOL ; }
String header To String ( ) { String p String = principals To String ( ) ; if ( p String . length ( ) == NUM ) { return codebase To String ( ) ; } else { return codebase To String ( ) + STRING + p String ; } }
private void load Binary ( Input Stream is ) throws IO Exception { if ( use New IO && is instanceof File Input Stream ) { File Input Stream fis = ( File Input Stream ) is ; if ( use Indexing ) { load Binary Index ( new URL ( index Name ) ) ; map Database ( fis ) ; } else { load Mapped Binary ( fis ) ; } } else { Data Input Stream dis = new Data Input Stream ( new Buffered Input Stream ( is ) ) ; load Binary ( dis ) ; } }
private void load Binary ( Input Stream is ) throws IO Exception { if ( use New IO && is instanceof File Input Stream ) { File Input Stream fis = ( File Input Stream ) is ; if ( use Indexing ) { load Binary Index ( new URL ( index Name ) ) ; map Database ( fis ) ; } else { load Mapped Binary ( fis ) ; } } else { Data Input Stream dis = new Data Input Stream ( new Buffered Input Stream ( is ) ) ; load Binary ( dis ) ; } }
private void load Binary ( Input Stream is ) throws IO Exception { if ( use New IO && is instanceof File Input Stream ) { File Input Stream fis = ( File Input Stream ) is ; if ( use Indexing ) { load Binary Index ( new URL ( index Name ) ) ; map Database ( fis ) ; } else { load Mapped Binary ( fis ) ; } } else { Data Input Stream dis = new Data Input Stream ( new Buffered Input Stream ( is ) ) ; load Binary ( dis ) ; } }
public static License read ( final String license ) { final String trimmed License = license . trim ( ) ; if ( s Licenses . contains Key ( trimmed License ) ) { return s Licenses . get ( trimmed License ) ; } else { throw new Illegal State Exception ( String . format ( STRING , trimmed License ) ) ; } }
public static License read ( final String license ) { final String trimmed License = license . trim ( ) ; if ( s Licenses . contains Key ( trimmed License ) ) { return s Licenses . get ( trimmed License ) ; } else { throw new Illegal State Exception ( String . format ( STRING , trimmed License ) ) ; } }
public boolean is Allow Create ( ) { if ( allow Create == null ) { return BOOL ; } return allow Create . boolean Value ( ) ; }
public synchronized void add ( double x , double y , double value ) { super . add ( x , y ) ; m Value . add ( value ) ; update Range ( value ) ; }
public void column Added ( Table Column Model Event e ) { Lime Table Column added Column = get To Column ( e ) ; Lime Table Column ltc = added Column ; set Visibility ( ltc , BOOL ) ; Table Column Model tcm = table . get Column Model ( ) ; int order = get Order ( ltc ) ; int current = tcm . get Column Index ( ltc . get Id ( ) ) ; int max = tcm . get Column Count ( ) ; if ( order != current ) { stop Listening ( ) ; order = Math . min ( order , max - NUM ) ; tcm . move Column ( current , order ) ; for ( current = order + NUM ; current < max ; current ++ ) { ltc = ( Lime Table Column ) tcm . get Column ( current ) ; set Order ( ltc , current ) ; } for ( Iterator < Lime Table Column > i = table . get Hidden Columns ( ) ; i . has Next ( ) ; ) { ltc = i . next ( ) ; current = get Order ( ltc ) ; if ( current > order ) set Order ( ltc , current + NUM ) ; } start Listening ( ) ; } if ( listener != null ) listener . column Added ( added Column , table ) ; save ( ) ; }
boolean check Camera Size ( Camera Options camera Id ) { boolean size Available = BOOL ; Camera camera = null ; Method method = get Camera Open Method ( ) ; if ( method != null ) { try { camera = ( Camera ) method . invoke ( camera , new Object [ ] { camera Id . get Value ( ) } ) ; } catch ( Exception e ) { camera = Camera . open ( ) ; } } else { camera = Camera . open ( ) ; } if ( camera == null ) { return BOOL ; } Parameters param = camera . get Parameters ( ) ; List < Camera . Size > sizes = param . get Supported Preview Sizes ( ) ; for ( Camera . Size size : sizes ) { if ( ( size . width == H264 Config . QVGA WIDTH && size . height == H264 Config . QVGA HEIGHT ) || ( size . width == H264 Config . CIF WIDTH && size . height == H264 Config . CIF HEIGHT ) || ( size . width == H264 Config . VGA WIDTH && size . height == H264 Config . VGA HEIGHT ) ) { size Available = BOOL ; break ; } } camera . release ( ) ; return size Available ; }
public List < Vector 2 > find Path Between ( Vector 2 from , Vector 2 to ) throws Exception { reset Search Algorithm ( ) ; if ( ! quad Tree . is Filled ( from ) || ! quad Tree . is Filled ( to ) ) { throw new Exception ( STRING ) ; } from = quad Tree . rasterize ( from ) ; to = quad Tree . rasterize ( to ) ; goal = new Node ( to ) ; open List . add ( new Node ( from ) ) ; do { Node current Node = get Closest Node ( ) ; if ( current Node . equals ( goal ) ) { while ( current Node . parent != null ) { path . add ( new Vector 2 ( current Node . x , current Node . y ) ) ; current Node = current Node . parent ; } return path ; } open List . remove ( current Node ) ; closed List . add ( current Node ) ; expand Node ( current Node ) ; } while ( ! open List . is Empty ( ) ) ; throw new Exception ( STRING ) ; }
public List < Vector 2 > find Path Between ( Vector 2 from , Vector 2 to ) throws Exception { reset Search Algorithm ( ) ; if ( ! quad Tree . is Filled ( from ) || ! quad Tree . is Filled ( to ) ) { throw new Exception ( STRING ) ; } from = quad Tree . rasterize ( from ) ; to = quad Tree . rasterize ( to ) ; goal = new Node ( to ) ; open List . add ( new Node ( from ) ) ; do { Node current Node = get Closest Node ( ) ; if ( current Node . equals ( goal ) ) { while ( current Node . parent != null ) { path . add ( new Vector 2 ( current Node . x , current Node . y ) ) ; current Node = current Node . parent ; } return path ; } open List . remove ( current Node ) ; closed List . add ( current Node ) ; expand Node ( current Node ) ; } while ( ! open List . is Empty ( ) ) ; throw new Exception ( STRING ) ; }
public Annotation Member ( String name , Object val , Class type , Method m ) { this ( name , val ) ; defining Method = m ; if ( type == int . class ) { element Type = Integer . class ; } else if ( type == boolean . class ) { element Type = Boolean . class ; } else if ( type == char . class ) { element Type = Character . class ; } else if ( type == float . class ) { element Type = Float . class ; } else if ( type == double . class ) { element Type = Double . class ; } else if ( type == long . class ) { element Type = Long . class ; } else if ( type == short . class ) { element Type = Short . class ; } else if ( type == byte . class ) { element Type = Byte . class ; } else { element Type = type ; } }
public Annotation Member ( String name , Object val , Class type , Method m ) { this ( name , val ) ; defining Method = m ; if ( type == int . class ) { element Type = Integer . class ; } else if ( type == boolean . class ) { element Type = Boolean . class ; } else if ( type == char . class ) { element Type = Character . class ; } else if ( type == float . class ) { element Type = Float . class ; } else if ( type == double . class ) { element Type = Double . class ; } else if ( type == long . class ) { element Type = Long . class ; } else if ( type == short . class ) { element Type = Short . class ; } else if ( type == byte . class ) { element Type = Byte . class ; } else { element Type = type ; } }
public int value ( ) { return get Element ( NUM ) & NUM ; }
public int value ( ) { return get Element ( NUM ) & NUM ; }
public int value ( ) { return get Element ( NUM ) & NUM ; }
public void test BSBM Q1 no Solutions ( ) throws Exception { final Test Helper helper = new Test Helper ( STRING , STRING , new String [ ] { } , STRING ) ; assert Same Join Order ( new int [ ] { NUM , NUM , NUM , NUM , NUM } , helper ) ; }
public void test BSBM Q1 no Solutions ( ) throws Exception { final Test Helper helper = new Test Helper ( STRING , STRING , new String [ ] { } , STRING ) ; assert Same Join Order ( new int [ ] { NUM , NUM , NUM , NUM , NUM } , helper ) ; }
public static void fail ( String message ) { throw new Illegal State Exception ( message == null ? STRING : message ) ; }
public boolean add Entry ( File file ) { if ( file == null ) { log . warning ( STRING ) ; return BOOL ; } if ( ! file . exists ( ) || file . is Directory ( ) || ! file . can Read ( ) ) { log . warning ( STRING + file + STRING + file . exists ( ) + STRING + file . is Directory ( ) ) ; return BOOL ; } log . fine ( STRING + file ) ; String name = file . get Name ( ) ; byte [ ] data = null ; File Input Stream fis = null ; Byte Array Output Stream os = null ; try { fis = new File Input Stream ( file ) ; os = new Byte Array Output Stream ( ) ; byte [ ] buffer = new byte [ NUM * NUM ] ; int length = - NUM ; while ( ( length = fis . read ( buffer ) ) != - NUM ) os . write ( buffer , NUM , length ) ; data = os . to Byte Array ( ) ; } catch ( IO Exception ioe ) { log . log ( Level . SEVERE , STRING , ioe ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IO Exception ex ) { log . log ( Level . SEVERE , STRING , ex ) ; } ; } if ( os != null ) { try { os . close ( ) ; } catch ( IO Exception ex ) { log . log ( Level . SEVERE , STRING , ex ) ; } ; } } return add Entry ( name , data ) ; }
public void call ( String name , List < Object > list ) throws IO Exception { if ( generator . is Excluding Fields Named ( name ) ) { return ; } write Name ( name ) ; write Array ( list ) ; }
public void error ( X Path Context xctxt , String msg , Object [ ] args ) throws javax . xml . transform . Transformer Exception { java . lang . String fmsg = XSL Messages . create XPATH Message ( msg , args ) ; if ( null != xctxt ) { Error Listener eh = xctxt . get Error Listener ( ) ; Transformer Exception te = new Transformer Exception ( fmsg , this ) ; eh . fatal Error ( te ) ; } }
public void error ( X Path Context xctxt , String msg , Object [ ] args ) throws javax . xml . transform . Transformer Exception { java . lang . String fmsg = XSL Messages . create XPATH Message ( msg , args ) ; if ( null != xctxt ) { Error Listener eh = xctxt . get Error Listener ( ) ; Transformer Exception te = new Transformer Exception ( fmsg , this ) ; eh . fatal Error ( te ) ; } }
public synchronized void flush ( ) throws IO Exception { if ( closed ) { return ; } flush Buffer ( ) ; out . flush ( ) ; last Activity Time = System . current Time Millis ( ) ; }
public synchronized void flush ( ) throws IO Exception { if ( closed ) { return ; } flush Buffer ( ) ; out . flush ( ) ; last Activity Time = System . current Time Millis ( ) ; }
public synchronized void flush ( ) throws IO Exception { if ( closed ) { return ; } flush Buffer ( ) ; out . flush ( ) ; last Activity Time = System . current Time Millis ( ) ; }
private String read File ( String path , Charset encoding ) throws IO Exception { byte [ ] encoded = Files . read All Bytes ( Paths . get ( path ) ) ; return new String ( encoded , encoding ) ; }
@ Non Null protected static String sortable Title ( @ Nullable String title ) { if ( title == null ) { return STRING ; } title = title . to Lower Case ( ) ; if ( title . starts With ( STRING ) ) { return title . substring ( NUM ) ; } else if ( title . starts With ( STRING ) ) { return title . substring ( NUM ) ; } else { return title ; } }
@ Non Null protected static String sortable Title ( @ Nullable String title ) { if ( title == null ) { return STRING ; } title = title . to Lower Case ( ) ; if ( title . starts With ( STRING ) ) { return title . substring ( NUM ) ; } else if ( title . starts With ( STRING ) ) { return title . substring ( NUM ) ; } else { return title ; } }
@ Non Null protected static String sortable Title ( @ Nullable String title ) { if ( title == null ) { return STRING ; } title = title . to Lower Case ( ) ; if ( title . starts With ( STRING ) ) { return title . substring ( NUM ) ; } else if ( title . starts With ( STRING ) ) { return title . substring ( NUM ) ; } else { return title ; } }
@ Override public void warn ( String msg , Throwable t ) { if ( logger . is Loggable ( Level . WARNING ) ) { log ( SELF , Level . WARNING , msg , t ) ; } }
public void write ( final I Raw Store store ) { if ( addr Metadata != NUM ) { throw new Illegal State Exception ( STRING ) ; } if ( index UUID == null ) { throw new Illegal State Exception ( STRING ) ; } this . addr Metadata = store . write ( Byte Buffer . wrap ( Serializer Util . serialize ( this ) ) ) ; }
public void write ( final I Raw Store store ) { if ( addr Metadata != NUM ) { throw new Illegal State Exception ( STRING ) ; } if ( index UUID == null ) { throw new Illegal State Exception ( STRING ) ; } this . addr Metadata = store . write ( Byte Buffer . wrap ( Serializer Util . serialize ( this ) ) ) ; }
@ Override public void write ( int b ) { int newcount = count + NUM ; if ( newcount > buf . length ) { buf = Utils . copy Of ( buf , Math . max ( buf . length << NUM , newcount ) ) ; } buf [ count ] = ( byte ) b ; count = newcount ; }
public int hash Code ( ) { return pattern . hash Code ( ) ; }
Schema Future install Handlers ( XML Reader in , Schema Receiver Impl sr ) { Handler h = new Handler ( sr ) ; in . set Content Handler ( h ) ; return h ; }
public Task Stack Builder add Parent Stack ( Component Name source Activity Name ) { final int insert At = m Intents . size ( ) ; try { Intent parent = Nav Utils . get Parent Activity Intent ( m Source Context , source Activity Name ) ; while ( parent != null ) { m Intents . add ( insert At , parent ) ; parent = Nav Utils . get Parent Activity Intent ( m Source Context , parent . get Component ( ) ) ; } } catch ( Name Not Found Exception e ) { Log . e ( TAG , STRING ) ; throw new Illegal Argument Exception ( e ) ; } return this ; }
public Task Stack Builder add Parent Stack ( Component Name source Activity Name ) { final int insert At = m Intents . size ( ) ; try { Intent parent = Nav Utils . get Parent Activity Intent ( m Source Context , source Activity Name ) ; while ( parent != null ) { m Intents . add ( insert At , parent ) ; parent = Nav Utils . get Parent Activity Intent ( m Source Context , parent . get Component ( ) ) ; } } catch ( Name Not Found Exception e ) { Log . e ( TAG , STRING ) ; throw new Illegal Argument Exception ( e ) ; } return this ; }
Block Id append ( String file Name , Io Buffer buffer ) { try { Io Channel file Channel = get File Channel ( file Name ) ; buffer . rewind ( ) ; long new Size = file Channel . append ( buffer ) ; return new Block Id ( file Name , new Size / BLOCK SIZE - NUM ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; return null ; } }
public void write To ( Output Stream os ) throws IO Exception { Data Output Stream dos = new Data Output Stream ( os ) ; dos . write Int ( N ) ; dos . write Int ( q ) ; dos . write Int ( df ) ; dos . write Int ( df 1 ) ; dos . write Int ( df 2 ) ; dos . write Int ( df 3 ) ; dos . write Int ( db ) ; dos . write Int ( dm 0 ) ; dos . write Int ( c ) ; dos . write Int ( min Calls R ) ; dos . write Int ( min Calls Mask ) ; dos . write Boolean ( hash Seed ) ; dos . write ( oid ) ; dos . write Boolean ( sparse ) ; dos . write Boolean ( fast Fp ) ; dos . write ( poly Type ) ; dos . write UTF ( hash Alg . get Algorithm Name ( ) ) ; }
@ HLE Function ( nid = NUM , version = NUM ) public int sce Net Apctl Add Handler ( T Pointer handler , int handler Arg ) { int uid = Sce Uid Manager . get New Uid ( uid Purpose ) ; Apctl Handler apctl Handler = new Apctl Handler ( uid , handler . get Address ( ) , handler Arg ) ; apctl Handlers . put ( uid , apctl Handler ) ; return uid ; }
@ Override public void execute ( String ... parameters ) throws IO Exception { if ( parameters . length < NUM ) { cio . writeln ( Print Help . FEDERATE ) ; } else { Linked List < String > plist = new Linked List < String > ( Arrays . as List ( parameters ) ) ; plist . remove ( ) ; boolean distinct = get Optional Param Value ( plist , STRING , BOOL ) ; boolean readonly = get Optional Param Value ( plist , STRING , BOOL ) ; if ( distinct Values ( plist ) ) { String fed ID = plist . pop ( ) ; federate ( distinct , readonly , fed ID , plist ) ; } else { cio . write Error ( STRING ) ; } } }
public IMF Error Logger Impl ( ) { this . error Objects = Collections . synchronized Set ( new Hash Set < Error Logger . Error Object > ( ) ) ; }
public IMF Error Logger Impl ( ) { this . error Objects = Collections . synchronized Set ( new Hash Set < Error Logger . Error Object > ( ) ) ; }
public IMF Error Logger Impl ( ) { this . error Objects = Collections . synchronized Set ( new Hash Set < Error Logger . Error Object > ( ) ) ; }
public Linked List < Diff > diff main ( String text 1 , String text 2 ) { return diff main ( text 1 , text 2 , BOOL ) ; }
public Linked List < Diff > diff main ( String text 1 , String text 2 ) { return diff main ( text 1 , text 2 , BOOL ) ; }
public static Element add Child Element ( Element element , String child Element Name , Document document ) { Element new Element = document . create Element ( child Element Name ) ; element . append Child ( new Element ) ; return new Element ; }
public static Element add Child Element ( Element element , String child Element Name , Document document ) { Element new Element = document . create Element ( child Element Name ) ; element . append Child ( new Element ) ; return new Element ; }
public Byte Pointer ( String s , String charset Name ) throws Unsupported Encoding Exception { this ( s . get Bytes ( charset Name ) . length + NUM ) ; put String ( s , charset Name ) ; }
public Byte Pointer ( String s , String charset Name ) throws Unsupported Encoding Exception { this ( s . get Bytes ( charset Name ) . length + NUM ) ; put String ( s , charset Name ) ; }
public Compute Task Cancelled Exception ( Throwable cause ) { this ( cause . get Message ( ) , cause ) ; }
public static Connection enlist Connection ( XA Connection xacon ) throws Generic Transaction Exception { if ( xacon == null ) { return null ; } try { XA Resource resource = xacon . get XA Resource ( ) ; Transaction Util . enlist Resource ( resource ) ; return xacon . get Connection ( ) ; } catch ( SQL Exception e ) { throw new Generic Transaction Exception ( STRING , e ) ; } }
public static Connection enlist Connection ( XA Connection xacon ) throws Generic Transaction Exception { if ( xacon == null ) { return null ; } try { XA Resource resource = xacon . get XA Resource ( ) ; Transaction Util . enlist Resource ( resource ) ; return xacon . get Connection ( ) ; } catch ( SQL Exception e ) { throw new Generic Transaction Exception ( STRING , e ) ; } }
public static Connection enlist Connection ( XA Connection xacon ) throws Generic Transaction Exception { if ( xacon == null ) { return null ; } try { XA Resource resource = xacon . get XA Resource ( ) ; Transaction Util . enlist Resource ( resource ) ; return xacon . get Connection ( ) ; } catch ( SQL Exception e ) { throw new Generic Transaction Exception ( STRING , e ) ; } }
public static Connection enlist Connection ( XA Connection xacon ) throws Generic Transaction Exception { if ( xacon == null ) { return null ; } try { XA Resource resource = xacon . get XA Resource ( ) ; Transaction Util . enlist Resource ( resource ) ; return xacon . get Connection ( ) ; } catch ( SQL Exception e ) { throw new Generic Transaction Exception ( STRING , e ) ; } }
private void update Associated Table With FK ( Data Support base Obj ) { Map < String , Set < Long > > associated Model Map = base Obj . get Associated Models Map With FK ( ) ; Content Values values = new Content Values ( ) ; for ( String associated Table Name : associated Model Map . key Set ( ) ) { values . clear ( ) ; String fk Name = get Foreign Key Column Name ( base Obj . get Table Name ( ) ) ; values . put ( fk Name , base Obj . get Base Obj Id ( ) ) ; Set < Long > ids = associated Model Map . get ( associated Table Name ) ; if ( ids != null && ! ids . is Empty ( ) ) { m Database . update ( associated Table Name , values , get Where Of Ids With Or ( ids ) , null ) ; } } }
public java . lang . String Builder insert ( int offset , int i ) { return insert ( offset , Integer . to String ( i ) ) ; }
public java . lang . String Builder insert ( int offset , int i ) { return insert ( offset , Integer . to String ( i ) ) ; }
public java . lang . String Builder insert ( int offset , int i ) { return insert ( offset , Integer . to String ( i ) ) ; }
public void remove Property Change Listener ( String property Name , Property Change Listener listener ) { if ( listener != null ) { synchronized ( this ) { if ( change Support != null ) { change Support . remove Property Change Listener ( property Name , listener ) ; } } } }
public void remove Property Change Listener ( String property Name , Property Change Listener listener ) { if ( listener != null ) { synchronized ( this ) { if ( change Support != null ) { change Support . remove Property Change Listener ( property Name , listener ) ; } } } }
public void remove Property Change Listener ( String property Name , Property Change Listener listener ) { if ( listener != null ) { synchronized ( this ) { if ( change Support != null ) { change Support . remove Property Change Listener ( property Name , listener ) ; } } } }
public static long copy ( Input Stream in , Output Stream out , long length ) throws IO Exception { try { long copied = NUM ; int len = ( int ) Math . min ( length , Constants . IO BUFFER SIZE ) ; byte [ ] buffer = new byte [ len ] ; while ( length > NUM ) { len = in . read ( buffer , NUM , len ) ; if ( len < NUM ) { break ; } if ( out != null ) { out . write ( buffer , NUM , len ) ; } copied += len ; length -= len ; len = ( int ) Math . min ( length , Constants . IO BUFFER SIZE ) ; } return copied ; } catch ( Exception e ) { throw Db Exception . convert To IO Exception ( e ) ; } }
public void characters Raw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAX Exception { if ( is Outside Doc Elem ( ) && XML Character Recognizer . is White Space ( ch , start , length ) ) return ; String s = new String ( ch , start , length ) ; append ( m doc . create Processing Instruction ( STRING , STRING ) ) ; append ( m doc . create Text Node ( s ) ) ; }
public void characters Raw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAX Exception { if ( is Outside Doc Elem ( ) && XML Character Recognizer . is White Space ( ch , start , length ) ) return ; String s = new String ( ch , start , length ) ; append ( m doc . create Processing Instruction ( STRING , STRING ) ) ; append ( m doc . create Text Node ( s ) ) ; }
protected Map < String , Raml Mime Type > extract Request Body From Method ( Raml Action Type api Action , Method method , Map < String , String > parameter Comments ) { if ( ! ( does Action Type Support Request Body ( api Action ) ) || method . get Parameter Count ( ) == NUM ) { return Collections . empty Map ( ) ; } String comment = null ; List < Api Parameter Metadata > api Parameters = get Api Parameters ( method , BOOL , BOOL ) ; if ( api Parameters . size ( ) == NUM ) { return Collections . empty Map ( ) ; } Pair < String , Raml Mime Type > schema And Mime = extract Request Body ( method , parameter Comments , comment , api Parameters ) ; return Collections . singleton Map ( schema And Mime . get First ( ) , schema And Mime . get Second ( ) ) ; }
protected Map < String , Raml Mime Type > extract Request Body From Method ( Raml Action Type api Action , Method method , Map < String , String > parameter Comments ) { if ( ! ( does Action Type Support Request Body ( api Action ) ) || method . get Parameter Count ( ) == NUM ) { return Collections . empty Map ( ) ; } String comment = null ; List < Api Parameter Metadata > api Parameters = get Api Parameters ( method , BOOL , BOOL ) ; if ( api Parameters . size ( ) == NUM ) { return Collections . empty Map ( ) ; } Pair < String , Raml Mime Type > schema And Mime = extract Request Body ( method , parameter Comments , comment , api Parameters ) ; return Collections . singleton Map ( schema And Mime . get First ( ) , schema And Mime . get Second ( ) ) ; }
public XML Grammar Preparser ( Symbol Table symbol Table ) { f Symbol Table = symbol Table ; f Loaders = new Hashtable ( ) ; f Error Reporter = new XML Error Reporter ( ) ; set Locale ( Locale . get Default ( ) ) ; f Entity Resolver = new XML Entity Manager ( ) ; }
public XML Grammar Preparser ( Symbol Table symbol Table ) { f Symbol Table = symbol Table ; f Loaders = new Hashtable ( ) ; f Error Reporter = new XML Error Reporter ( ) ; set Locale ( Locale . get Default ( ) ) ; f Entity Resolver = new XML Entity Manager ( ) ; }
public XML Grammar Preparser ( Symbol Table symbol Table ) { f Symbol Table = symbol Table ; f Loaders = new Hashtable ( ) ; f Error Reporter = new XML Error Reporter ( ) ; set Locale ( Locale . get Default ( ) ) ; f Entity Resolver = new XML Entity Manager ( ) ; }
@ Override public void mk Dir ( @ Not Null File at ) { try { my IO . mk Dir ( get Target File ( at ) ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
@ Override public void mk Dir ( @ Not Null File at ) { try { my IO . mk Dir ( get Target File ( at ) ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . DELETE ) @ Response Body public Rest Wrapper delete ( @ Path Variable ( STRING ) String config Group , @ Path Variable ( STRING ) String key , Principal principal ) { Rest Wrapper rest Wrapper = null ; try { General Config general Config = new General Config ( ) ; general Config . set Config Group ( config Group ) ; general Config . set Key ( key ) ; General Config Id jpa General Config Id = new General Config Id ( ) ; jpa General Config Id . set Config Group ( general Config . get Config Group ( ) ) ; jpa General Config Id . set Gc Key ( general Config . get Key ( ) ) ; general Config DAO . delete ( jpa General Config Id ) ; rest Wrapper = new Rest Wrapper ( null , Rest Wrapper . OK ) ; LOGGER . info ( STRING + key + STRING + principal . get Name ( ) ) ; } catch ( Metadata Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
protected int hash ( Object key 1 , Object key 2 ) { int h = NUM ; if ( key 1 != null ) { h ^= key 1 . hash Code ( ) ; } if ( key 2 != null ) { h ^= key 2 . hash Code ( ) ; } h += ~ ( h << NUM ) ; h ^= ( h > > > NUM ) ; h += ( h << NUM ) ; h ^= ( h > > > NUM ) ; return h ; }
public boolean has Long Column Info ( ) { return this . has Long Column Info ; }
public void define Property ( String property Name , Object value , int attributes ) { check Not Sealed ( property Name , NUM ) ; put ( property Name , this , value ) ; set Attributes ( property Name , attributes ) ; }
public void define Property ( String property Name , Object value , int attributes ) { check Not Sealed ( property Name , NUM ) ; put ( property Name , this , value ) ; set Attributes ( property Name , attributes ) ; }
private static String normalize Helper ( String number , Map < Character , Character > normalization Replacements , boolean remove Non Matches ) { String Builder normalized Number = new String Builder ( number . length ( ) ) ; for ( int i = NUM ; i < number . length ( ) ; i ++ ) { char character = number . char At ( i ) ; Character new Digit = normalization Replacements . get ( Character . to Upper Case ( character ) ) ; if ( new Digit != null ) { normalized Number . append ( new Digit ) ; } else if ( ! remove Non Matches ) { normalized Number . append ( character ) ; } } return normalized Number . to String ( ) ; }
private static String normalize Helper ( String number , Map < Character , Character > normalization Replacements , boolean remove Non Matches ) { String Builder normalized Number = new String Builder ( number . length ( ) ) ; for ( int i = NUM ; i < number . length ( ) ; i ++ ) { char character = number . char At ( i ) ; Character new Digit = normalization Replacements . get ( Character . to Upper Case ( character ) ) ; if ( new Digit != null ) { normalized Number . append ( new Digit ) ; } else if ( ! remove Non Matches ) { normalized Number . append ( character ) ; } } return normalized Number . to String ( ) ; }
private static String normalize Helper ( String number , Map < Character , Character > normalization Replacements , boolean remove Non Matches ) { String Builder normalized Number = new String Builder ( number . length ( ) ) ; for ( int i = NUM ; i < number . length ( ) ; i ++ ) { char character = number . char At ( i ) ; Character new Digit = normalization Replacements . get ( Character . to Upper Case ( character ) ) ; if ( new Digit != null ) { normalized Number . append ( new Digit ) ; } else if ( ! remove Non Matches ) { normalized Number . append ( character ) ; } } return normalized Number . to String ( ) ; }
private static String normalize Helper ( String number , Map < Character , Character > normalization Replacements , boolean remove Non Matches ) { String Builder normalized Number = new String Builder ( number . length ( ) ) ; for ( int i = NUM ; i < number . length ( ) ; i ++ ) { char character = number . char At ( i ) ; Character new Digit = normalization Replacements . get ( Character . to Upper Case ( character ) ) ; if ( new Digit != null ) { normalized Number . append ( new Digit ) ; } else if ( ! remove Non Matches ) { normalized Number . append ( character ) ; } } return normalized Number . to String ( ) ; }
private static String normalize Helper ( String number , Map < Character , Character > normalization Replacements , boolean remove Non Matches ) { String Builder normalized Number = new String Builder ( number . length ( ) ) ; for ( int i = NUM ; i < number . length ( ) ; i ++ ) { char character = number . char At ( i ) ; Character new Digit = normalization Replacements . get ( Character . to Upper Case ( character ) ) ; if ( new Digit != null ) { normalized Number . append ( new Digit ) ; } else if ( ! remove Non Matches ) { normalized Number . append ( character ) ; } } return normalized Number . to String ( ) ; }
synchronized void receive ( int c ) throws IO Exception { if ( ! connected ) { throw new IO Exception ( STRING ) ; } else if ( closed By Writer || closed By Reader ) { throw new IO Exception ( STRING ) ; } else if ( read Side != null && ! read Side . is Alive ( ) ) { throw new IO Exception ( STRING ) ; } write Side = Thread . current Thread ( ) ; while ( in == out ) { if ( ( read Side != null ) && ! read Side . is Alive ( ) ) { throw new IO Exception ( STRING ) ; } notify All ( ) ; try { wait ( NUM ) ; } catch ( Interrupted Exception ex ) { throw new java . io . Interrupted IO Exception ( ) ; } } if ( in < NUM ) { in = NUM ; out = NUM ; } buffer [ in ++ ] = ( char ) c ; if ( in >= buffer . length ) { in = NUM ; } }
public void add Listener ( final I Memory Listener listener ) { m listeners . add ( listener ) ; }
private void sched ( Timer Task task , long time , long period ) { if ( time < NUM ) throw new Illegal Argument Exception ( STRING ) ; if ( Math . abs ( period ) > ( Long . MAX VALUE > > NUM ) ) period >>= NUM ; synchronized ( queue ) { if ( ! thread . new Tasks May Be Scheduled ) throw new Illegal State Exception ( STRING ) ; synchronized ( task . lock ) { if ( task . state != Timer Task . VIRGIN ) throw new Illegal State Exception ( STRING ) ; task . next Execution Time = time ; task . period = period ; task . state = Timer Task . SCHEDULED ; } queue . add ( task ) ; if ( queue . get Min ( ) == task ) queue . notify ( ) ; } }
@ Override public Template Druid Query with Aggregations ( Collection < Aggregation > new Aggregations ) { return new Template Druid Query ( new Aggregations , post Aggregations , nested Query , time Grain ) ; }
public static Distribution Config Impl produce ( Properties props ) { if ( props != null ) { Object o = props . get ( DS CONFIG NAME ) ; if ( o instanceof Distribution Config Impl ) { return ( Distribution Config Impl ) o ; } } return new Distribution Config Impl ( props , BOOL , BOOL ) ; }
public void add ( byte [ ] bytes ) { int [ ] hashes = create Hashes ( bytes , k , get New Digest Function ( ) ) ; for ( int hash : hashes ) bitset . set ( Math . abs ( hash % bit Set Size ) , BOOL ) ; number Of Added Elements ++ ; }
public static void show Finished Notification ( String content , int time , boolean error , Context context , Intent intent ) { if ( context == null ) return ; Notification Manager m Not Man = ( Notification Manager ) context . get System Service ( Context . NOTIFICATION SERVICE ) ; int icon = R . drawable . icon ; Char Sequence title = String . format ( ( String ) context . get Text ( R . string . Utils Download Finished Title ) , time ) ; Char Sequence ticker = context . get Text ( R . string . Utils Download Finished Ticker ) ; Char Sequence text = content ; if ( content == null ) text = context . get Text ( R . string . Utils Download Finished Text ) ; if ( error ) { icon = R . drawable . icon ; title = context . get Text ( R . string . Utils Download Error Title ) ; ticker = context . get Text ( R . string . Utils Download Error Ticker ) ; } Notification notification = build Notification ( context , icon , ticker , title , text , BOOL , intent ) ; m Not Man . notify ( ID FINISHED , notification ) ; }
DH Crypt ( Big Integer modulus , Big Integer base , Secure Random random ) { this ( modulus . bit Length ( ) , new DH Parameter Spec ( modulus , base ) , random ) ; }
public void test Probability Values From The Paper ( ) { List < Integer > nodes = new Array List < Integer > ( ) ; nodes . add ( NUM ) ; nodes . add ( NUM ) ; nodes . add ( NUM ) ; nodes . add ( NUM ) ; double unknown Prob = NUM / nodes . size ( ) ; Meeting Probability Set mps = new Meeting Probability Set ( NUM , nodes ) ; assert Equals ( unknown Prob , mps . get Prob For ( NUM ) ) ; assert Equals ( unknown Prob , mps . get Prob For ( NUM ) ) ; mps . update Meeting Prob For ( NUM ) ; assert Equals ( NUM , mps . get Prob For ( NUM ) ) ; assert Equals ( NUM , mps . get Prob For ( NUM ) ) ; }
public void test Probability Values From The Paper ( ) { List < Integer > nodes = new Array List < Integer > ( ) ; nodes . add ( NUM ) ; nodes . add ( NUM ) ; nodes . add ( NUM ) ; nodes . add ( NUM ) ; double unknown Prob = NUM / nodes . size ( ) ; Meeting Probability Set mps = new Meeting Probability Set ( NUM , nodes ) ; assert Equals ( unknown Prob , mps . get Prob For ( NUM ) ) ; assert Equals ( unknown Prob , mps . get Prob For ( NUM ) ) ; mps . update Meeting Prob For ( NUM ) ; assert Equals ( NUM , mps . get Prob For ( NUM ) ) ; assert Equals ( NUM , mps . get Prob For ( NUM ) ) ; }
public void test Probability Values From The Paper ( ) { List < Integer > nodes = new Array List < Integer > ( ) ; nodes . add ( NUM ) ; nodes . add ( NUM ) ; nodes . add ( NUM ) ; nodes . add ( NUM ) ; double unknown Prob = NUM / nodes . size ( ) ; Meeting Probability Set mps = new Meeting Probability Set ( NUM , nodes ) ; assert Equals ( unknown Prob , mps . get Prob For ( NUM ) ) ; assert Equals ( unknown Prob , mps . get Prob For ( NUM ) ) ; mps . update Meeting Prob For ( NUM ) ; assert Equals ( NUM , mps . get Prob For ( NUM ) ) ; assert Equals ( NUM , mps . get Prob For ( NUM ) ) ; }
public Element simulate ( final List < Instruction > instructions ) { lock . lock ( ) ; try { return Element = null ; return simulate Internal ( instructions ) ; } finally { lock . unlock ( ) ; } }
public Element simulate ( final List < Instruction > instructions ) { lock . lock ( ) ; try { return Element = null ; return simulate Internal ( instructions ) ; } finally { lock . unlock ( ) ; } }
public void action Performed ( Action Event e ) { File next Page = ( File ) J Option Pane . show Input Dialog ( eeze Frame , STRING , STRING , J Option Pane . PLAIN MESSAGE , null , test Files . to Array ( ) , current Displayed ) ; try { switch Page ( next Page , BOOL ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; } }
public synchronized void add Class ( Identifier Token t ) { singles . add Element ( t ) ; }
public static void assert Throws Completion Exception ( final Consumer < Void > consumer , final Class < ? > exception Class ) { try { consumer . accept ( null ) ; } catch ( final Completion Exception completion Ex ) { final Throwable ex = completion Ex . get Cause ( ) ; if ( ex . get Class ( ) == exception Class ) { return ; } Assert . fail ( String . format ( STRING , ex . get Class ( ) ) ) ; } Assert . fail ( String . format ( STRING , exception Class ) ) ; }
public static void assert Throws Completion Exception ( final Consumer < Void > consumer , final Class < ? > exception Class ) { try { consumer . accept ( null ) ; } catch ( final Completion Exception completion Ex ) { final Throwable ex = completion Ex . get Cause ( ) ; if ( ex . get Class ( ) == exception Class ) { return ; } Assert . fail ( String . format ( STRING , ex . get Class ( ) ) ) ; } Assert . fail ( String . format ( STRING , exception Class ) ) ; }
private void put With Validation ( String key , Object value ) throws Bitcoin URI Parse Exception { if ( parameter Map . contains Key ( key ) ) { throw new Bitcoin URI Parse Exception ( String . format ( Locale . US , STRING , key ) ) ; } else { parameter Map . put ( key , value ) ; } }
private static void add Single Unique ( Field Type field Type , List < String > additional Args ) { String Builder alter Sb = new String Builder ( ) ; alter Sb . append ( STRING ) ; append Escaped Entity Name ( alter Sb , field Type . get Column Name ( ) ) ; alter Sb . append ( STRING ) ; additional Args . add ( alter Sb . to String ( ) ) ; }
private static void add Single Unique ( Field Type field Type , List < String > additional Args ) { String Builder alter Sb = new String Builder ( ) ; alter Sb . append ( STRING ) ; append Escaped Entity Name ( alter Sb , field Type . get Column Name ( ) ) ; alter Sb . append ( STRING ) ; additional Args . add ( alter Sb . to String ( ) ) ; }
private static Value Lob create Blob ( Input Stream in , long length , Data Handler handler ) { try { if ( handler == null ) { byte [ ] data = IO Utils . read Bytes And Close ( in , ( int ) length ) ; return create Small Lob ( Value . BLOB , data ) ; } long remaining = Long . MAX VALUE ; boolean compress = handler . get Lob Compression Algorithm ( Value . BLOB ) != null ; if ( length >= NUM && length < remaining ) { remaining = length ; } int len = get Buffer Size ( handler , compress , remaining ) ; byte [ ] buff ; if ( len >= Integer . MAX VALUE ) { buff = IO Utils . read Bytes And Close ( in , - NUM ) ; len = buff . length ; } else { buff = Data Utils . new Bytes ( len ) ; len = IO Utils . read Fully ( in , buff , len ) ; } if ( len <= handler . get Max Length Inplace Lob ( ) ) { byte [ ] small = Data Utils . new Bytes ( len ) ; System . arraycopy ( buff , NUM , small , NUM , len ) ; return Value Lob . create Small Lob ( Value . BLOB , small ) ; } Value Lob lob = new Value Lob ( Value . BLOB , null ) ; lob . create From Stream ( buff , len , in , remaining , handler ) ; return lob ; } catch ( IO Exception e ) { throw Db Exception . convert IO Exception ( e , null ) ; } }
public boolean has On Disk ( final String key ) { synchronized ( m Entries ) { return m Entries . contains ( sanitize Key ( key ) ) ; } }
@ Parameterized . Parameters ( name = STRING ) public static Collection < Integer > data ( ) { return Arrays . as List ( NUM , NUM ) ; }
@ Parameterized . Parameters ( name = STRING ) public static Collection < Integer > data ( ) { return Arrays . as List ( NUM , NUM ) ; }
@ Parameterized . Parameters ( name = STRING ) public static Collection < Integer > data ( ) { return Arrays . as List ( NUM , NUM ) ; }
public static void log ( Throwable error , String message , Object ... args ) { if ( logging Enabled ) { Log . d ( TAG , args . length == NUM ? message : String . format ( message , args ) , error ) ; } }
public Service Call < Void > reset Customization ( String customization Id ) { Validator . not Null ( customization Id , STRING ) ; Request Builder request Builder = Request Builder . post ( String . format ( PATH RESET , customization Id ) ) ; return create Service Call ( request Builder . build ( ) , Response Converter Utils . get Void ( ) ) ; }
public Service Call < Void > reset Customization ( String customization Id ) { Validator . not Null ( customization Id , STRING ) ; Request Builder request Builder = Request Builder . post ( String . format ( PATH RESET , customization Id ) ) ; return create Service Call ( request Builder . build ( ) , Response Converter Utils . get Void ( ) ) ; }
public Service Call < Void > reset Customization ( String customization Id ) { Validator . not Null ( customization Id , STRING ) ; Request Builder request Builder = Request Builder . post ( String . format ( PATH RESET , customization Id ) ) ; return create Service Call ( request Builder . build ( ) , Response Converter Utils . get Void ( ) ) ; }
@ Override public void execute ( Metric Time Series time Series , Function Value Map function Value Map ) { if ( time Series . size ( ) <= NUM ) { function Value Map . add ( this , Double . Na N ) ; return ; } time Series . sort ( ) ; double first Value = time Series . get Value ( NUM ) ; double last Value = time Series . get Value ( time Series . size ( ) - NUM ) ; function Value Map . add ( this , Math . abs ( first Value - last Value ) ) ; }
List < Integer > segment Sizes ( ) { if ( head == null ) return Collections . empty List ( ) ; List < Integer > result = new Array List < > ( ) ; result . add ( head . limit - head . pos ) ; for ( Segment s = head . next ; s != head ; s = s . next ) { result . add ( s . limit - s . pos ) ; } return result ; }
public List < JSON Value > values ( ) { return Collections . unmodifiable List ( values ) ; }
public List < JSON Value > values ( ) { return Collections . unmodifiable List ( values ) ; }
public List < JSON Value > values ( ) { return Collections . unmodifiable List ( values ) ; }
public List < JSON Value > values ( ) { return Collections . unmodifiable List ( values ) ; }
private static String big Integer To Ascii String ( final Big Integer big Integer ) { final byte [ ] byte Array = big Integer . to Byte Array ( ) ; String Buffer string Buffer = new String Buffer ( ) ; for ( int i = NUM ; i < byte Array . length ; i ++ ) { final char value = ( char ) ( byte Array [ i ] & NUM ) ; if ( i == NUM && value == NUM ) { continue ; } string Buffer . append ( value ) ; } return string Buffer . to String ( ) ; }
private static String big Integer To Ascii String ( final Big Integer big Integer ) { final byte [ ] byte Array = big Integer . to Byte Array ( ) ; String Buffer string Buffer = new String Buffer ( ) ; for ( int i = NUM ; i < byte Array . length ; i ++ ) { final char value = ( char ) ( byte Array [ i ] & NUM ) ; if ( i == NUM && value == NUM ) { continue ; } string Buffer . append ( value ) ; } return string Buffer . to String ( ) ; }
private static String big Integer To Ascii String ( final Big Integer big Integer ) { final byte [ ] byte Array = big Integer . to Byte Array ( ) ; String Buffer string Buffer = new String Buffer ( ) ; for ( int i = NUM ; i < byte Array . length ; i ++ ) { final char value = ( char ) ( byte Array [ i ] & NUM ) ; if ( i == NUM && value == NUM ) { continue ; } string Buffer . append ( value ) ; } return string Buffer . to String ( ) ; }
@ Override public synchronized void close ( ) throws SQL Exception { try { debug Code Call ( STRING ) ; if ( session == null ) { return ; } Close Watcher . unregister ( watcher ) ; session . cancel ( ) ; if ( executing Statement != null ) { try { executing Statement . cancel ( ) ; } catch ( Null Pointer Exception e ) { } } synchronized ( session ) { try { if ( ! session . is Closed ( ) ) { try { if ( session . has Pending Transaction ( ) ) { if ( ! session . is Reconnect Needed ( BOOL ) ) { try { rollback Internal ( ) ; } catch ( Db Exception e ) { if ( e . get Error Code ( ) != Error Code . CONNECTION BROKEN 1 ) { throw e ; } } } session . after Writing ( ) ; } close Prepared Commands ( ) ; } finally { session . close ( ) ; } } } finally { session = null ; } } } catch ( Exception e ) { throw log And Convert ( e ) ; } }
@ Override public synchronized void close ( ) throws SQL Exception { try { debug Code Call ( STRING ) ; if ( session == null ) { return ; } Close Watcher . unregister ( watcher ) ; session . cancel ( ) ; if ( executing Statement != null ) { try { executing Statement . cancel ( ) ; } catch ( Null Pointer Exception e ) { } } synchronized ( session ) { try { if ( ! session . is Closed ( ) ) { try { if ( session . has Pending Transaction ( ) ) { if ( ! session . is Reconnect Needed ( BOOL ) ) { try { rollback Internal ( ) ; } catch ( Db Exception e ) { if ( e . get Error Code ( ) != Error Code . CONNECTION BROKEN 1 ) { throw e ; } } } session . after Writing ( ) ; } close Prepared Commands ( ) ; } finally { session . close ( ) ; } } } finally { session = null ; } } } catch ( Exception e ) { throw log And Convert ( e ) ; } }
protected void disconnect ( ) { try { trace Operation ( STRING ) ; conn . close ( ) ; } catch ( Exception e ) { trace Operation ( STRING , e ) ; } }
private static boolean is An Argument ( final String arg ) { return ( arg . starts With ( STRING ) && ( arg . length ( ) > NUM ) && ! Character . is Digit ( arg . char At ( NUM ) ) ) ; }
private static boolean is An Argument ( final String arg ) { return ( arg . starts With ( STRING ) && ( arg . length ( ) > NUM ) && ! Character . is Digit ( arg . char At ( NUM ) ) ) ; }
public static void delete Tab State ( File directory , int tab Id , boolean encrypted ) { File file = get Tab State File ( directory , tab Id , encrypted ) ; if ( file . exists ( ) && ! file . delete ( ) ) Log . e ( TAG , STRING + file ) ; }
private Object [ ] resolve Parameters ( Executable executable , Optional < Object > target , Object outer Instance , Extension Context extension Context , Extension Registry extension Registry ) { Preconditions . not Null ( target , STRING ) ; Parameter [ ] parameters = executable . get Parameters ( ) ; Object [ ] values = new Object [ parameters . length ] ; int start = NUM ; if ( outer Instance != null ) { values [ NUM ] = outer Instance ; start = NUM ; } for ( int i = start ; i < parameters . length ; i ++ ) { Parameter Context parameter Context = new Default Parameter Context ( parameters [ i ] , i , target ) ; values [ i ] = resolve Parameter ( parameter Context , executable , extension Context , extension Registry ) ; } return values ; }
public Vector 3 ceil ( ) { x = ( float ) Math . ceil ( x ) ; y = ( float ) Math . ceil ( y ) ; z = ( float ) Math . ceil ( z ) ; return this ; }
public void add Column To Drop ( Column column ) { if ( ! columns To Drop . contains ( column ) ) { columns To Drop . add ( column ) ; } }
@ Suppress Warnings ( STRING ) public static < R > R call Static Method ( Class < ? > clazz , String method Name , Class Parameter < ? > ... class Parameters ) { try { Class < ? > [ ] classes = Class Parameter . get Classes ( class Parameters ) ; Object [ ] values = Class Parameter . get Values ( class Parameters ) ; Method method = clazz . get Declared Method ( method Name , classes ) ; method . set Accessible ( BOOL ) ; return ( R ) method . invoke ( null , values ) ; } catch ( Invocation Target Exception e ) { if ( e . get Target Exception ( ) instanceof Runtime Exception ) { throw ( Runtime Exception ) e . get Target Exception ( ) ; } if ( e . get Target Exception ( ) instanceof Error ) { throw ( Error ) e . get Target Exception ( ) ; } throw new Runtime Exception ( e . get Target Exception ( ) ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
public Web Socket Impl ( Web Socket Listener listener , List < Draft > drafts ) { this ( listener , ( Draft ) null ) ; this . role = Role . SERVER ; if ( drafts == null || drafts . is Empty ( ) ) { known Drafts = defaultdraftlist ; } else { known Drafts = drafts ; } }
@ Override public void write ( Data Output out ) throws IO Exception { out . write Long ( duration ) ; out . write Int ( get Length ( ) ) ; for ( int i = NUM ; i < coeffs . length ; i ++ ) { out . write Float ( coeffs [ i ] ) ; } }
public double distance Sq ( Vector other ) { return Math . pow ( other . x - x , NUM ) + Math . pow ( other . y - y , NUM ) + Math . pow ( other . z - z , NUM ) ; }
public double linear Distance ( final Vector v ) { return Math . sqrt ( linear Distance Squared ( v ) ) ; }
@ Override public synchronized void put ( String key , Entry entry ) { prune If Needed ( entry . data . length ) ; File file = get File For Key ( key ) ; try { File Output Stream fos = new File Output Stream ( file ) ; Cache Header e = new Cache Header ( key , entry ) ; boolean success = e . write Header ( fos ) ; if ( ! success ) { fos . close ( ) ; Volley Log . d ( STRING , file . get Absolute Path ( ) ) ; throw new IO Exception ( ) ; } fos . write ( entry . data ) ; fos . close ( ) ; put Entry ( key , e ) ; return ; } catch ( IO Exception e ) { } boolean deleted = file . delete ( ) ; if ( ! deleted ) { Volley Log . d ( STRING , file . get Absolute Path ( ) ) ; } }
public boolean is Component Part Of Current Menu ( Component c ) { if ( selection . size ( ) > NUM ) { Menu Element me = selection . element At ( NUM ) ; return is Component Part Of Current Menu ( me , c ) ; } else return BOOL ; }
public Node pop Node ( Class < ? extends Node > cls , String uri ) { synchronized ( node Stack ) { if ( suppress ) { if ( ! suppressed Node Stack . is Empty ( ) ) { Node suppressed = pop Node ( suppressed Node Stack , cls , uri ) ; if ( suppressed != null ) { return suppressed ; } } else { suppress = BOOL ; } } return pop Node ( node Stack , cls , uri ) ; } }
@ Override public int read ( ) throws IO Exception { return f Input Stream . read ( ) ; }
@ Override public int read ( ) throws IO Exception { return f Input Stream . read ( ) ; }
@ Override public int read ( ) throws IO Exception { return f Input Stream . read ( ) ; }
@ Override public int read ( ) throws IO Exception { return f Input Stream . read ( ) ; }
@ Override public int read ( ) throws IO Exception { return f Input Stream . read ( ) ; }
public void test transfer To could Delete ( ) throws Exception { write Data To File ( file Of Read Only File Channel ) ; write Data To File ( file Of Write Only File Channel ) ; read Only File Channel . transfer To ( NUM , NUM , write Only File Channel ) ; read Only File Channel . close ( ) ; write Only File Channel . close ( ) ; boolean r Del = file Of Read Only File Channel . delete ( ) ; boolean w Del = file Of Write Only File Channel . delete ( ) ; assert True ( STRING + read Only File Channel + STRING , r Del ) ; assert True ( STRING + write Only File Channel + STRING , w Del ) ; }
public void test transfer To could Delete ( ) throws Exception { write Data To File ( file Of Read Only File Channel ) ; write Data To File ( file Of Write Only File Channel ) ; read Only File Channel . transfer To ( NUM , NUM , write Only File Channel ) ; read Only File Channel . close ( ) ; write Only File Channel . close ( ) ; boolean r Del = file Of Read Only File Channel . delete ( ) ; boolean w Del = file Of Write Only File Channel . delete ( ) ; assert True ( STRING + read Only File Channel + STRING , r Del ) ; assert True ( STRING + write Only File Channel + STRING , w Del ) ; }
public String render ( String resource Name , String screen Name , boolean as String ) throws General Exception , IO Exception , SAX Exception , Parser Configuration Exception { Model Screen model Screen = Screen Factory . get Screen From Location ( resource Name , screen Name ) ; if ( model Screen . get Use Cache ( ) ) { Widget Context Cache Key wcck = new Widget Context Cache Key ( context ) ; String screen Combined Name = resource Name + STRING + screen Name ; Screen Cache screen Cache = new Screen Cache ( ) ; Generic Widget Output gwo = screen Cache . get ( screen Combined Name , wcck ) ; if ( gwo == null ) { Writer sw = new String Writer ( ) ; model Screen . render Screen String ( sw , context , screen String Renderer ) ; gwo = new Generic Widget Output ( sw . to String ( ) ) ; screen Cache . put ( screen Combined Name , wcck , gwo ) ; if ( as String ) { return gwo . to String ( ) ; } else { writer . append ( gwo . to String ( ) ) ; } } else { if ( as String ) { return gwo . to String ( ) ; } else { writer . append ( gwo . to String ( ) ) ; } } } else { context . put ( STRING , String . value Of ( render Form Seq Number ) ) ; if ( as String ) { Writer sw = new String Writer ( ) ; model Screen . render Screen String ( sw , context , screen String Renderer ) ; return sw . to String ( ) ; } else { model Screen . render Screen String ( writer , context , screen String Renderer ) ; } } return STRING ; }
public void add Sip Event Listener ( Sip Event Listener listener ) { m Listeners . add ( listener ) ; }
public boolean element 2 Locator ( Element e , Simple Locator l ) { if ( l == null ) return BOOL ; if ( e instanceof Element Impl ) { Element Impl ele = ( Element Impl ) e ; Document doc = ele . get Owner Document ( ) ; String sid = ( String ) f Doc 2 System Id . get ( DOM Util . get Root ( doc ) ) ; int line = ele . get Line Number ( ) ; int column = ele . get Column Number ( ) ; l . set Values ( sid , sid , line , column , ele . get Character Offset ( ) ) ; return BOOL ; } return BOOL ; }
public boolean element 2 Locator ( Element e , Simple Locator l ) { if ( l == null ) return BOOL ; if ( e instanceof Element Impl ) { Element Impl ele = ( Element Impl ) e ; Document doc = ele . get Owner Document ( ) ; String sid = ( String ) f Doc 2 System Id . get ( DOM Util . get Root ( doc ) ) ; int line = ele . get Line Number ( ) ; int column = ele . get Column Number ( ) ; l . set Values ( sid , sid , line , column , ele . get Character Offset ( ) ) ; return BOOL ; } return BOOL ; }
public Forum Post Config create ( Forum Post Config config ) { config . add Credentials ( this ) ; String xml = POST ( this . url + STRING , config . to XML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { Forum Post Config post = new Forum Post Config ( ) ; post . parse XML ( root ) ; return post ; } catch ( Exception exception ) { this . exception = SDK Exception . parse Failure ( exception ) ; throw this . exception ; } }
public Forum Post Config create ( Forum Post Config config ) { config . add Credentials ( this ) ; String xml = POST ( this . url + STRING , config . to XML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { Forum Post Config post = new Forum Post Config ( ) ; post . parse XML ( root ) ; return post ; } catch ( Exception exception ) { this . exception = SDK Exception . parse Failure ( exception ) ; throw this . exception ; } }
public Forum Post Config create ( Forum Post Config config ) { config . add Credentials ( this ) ; String xml = POST ( this . url + STRING , config . to XML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { Forum Post Config post = new Forum Post Config ( ) ; post . parse XML ( root ) ; return post ; } catch ( Exception exception ) { this . exception = SDK Exception . parse Failure ( exception ) ; throw this . exception ; } }
private void savehttp Red Logout ( String lohttp Location , String lohttp Resp Location , List log List , com . sun . identity . saml 2 . jaxb . metadata . Object Factory obj Fact ) throws JAXB Exception { if ( lohttp Location != null && lohttp Location . length ( ) > NUM ) { Single Logout Service Element sls Elem Red = obj Fact . create Single Logout Service Element ( ) ; sls Elem Red . set Binding ( http Redirect Binding ) ; sls Elem Red . set Location ( lohttp Location ) ; sls Elem Red . set Response Location ( lohttp Resp Location ) ; log List . add ( sls Elem Red ) ; } }
@ Override public void add Training Set Listener ( Training Set Listener tsl ) { m training Set Listeners . add Element ( tsl ) ; if ( m format != null ) { Training Set Event e = new Training Set Event ( this , m format ) ; tsl . accept Training Set ( e ) ; } }
private static void compute Regions ( Rectangle source Bounds , Dimension dest Size , Image Write Param p ) { Image Write Param param ; int period X = NUM ; int period Y = NUM ; if ( p != null ) { int [ ] source Bands = p . get Source Bands ( ) ; if ( source Bands != null && ( source Bands . length != NUM || source Bands [ NUM ] != NUM ) ) { throw new Illegal Argument Exception ( STRING ) ; } Rectangle source Region = p . get Source Region ( ) ; if ( source Region != null ) { source Region = source Region . intersection ( source Bounds ) ; source Bounds . set Bounds ( source Region ) ; } int grid X = p . get Subsampling X Offset ( ) ; int grid Y = p . get Subsampling Y Offset ( ) ; source Bounds . x += grid X ; source Bounds . y += grid Y ; source Bounds . width -= grid X ; source Bounds . height -= grid Y ; period X = p . get Source X Subsampling ( ) ; period Y = p . get Source Y Subsampling ( ) ; } dest Size . set Size ( ( source Bounds . width + period X - NUM ) / period X , ( source Bounds . height + period Y - NUM ) / period Y ) ; if ( dest Size . width <= NUM || dest Size . height <= NUM ) { throw new Illegal Argument Exception ( STRING ) ; } }
private static void compute Regions ( Rectangle source Bounds , Dimension dest Size , Image Write Param p ) { Image Write Param param ; int period X = NUM ; int period Y = NUM ; if ( p != null ) { int [ ] source Bands = p . get Source Bands ( ) ; if ( source Bands != null && ( source Bands . length != NUM || source Bands [ NUM ] != NUM ) ) { throw new Illegal Argument Exception ( STRING ) ; } Rectangle source Region = p . get Source Region ( ) ; if ( source Region != null ) { source Region = source Region . intersection ( source Bounds ) ; source Bounds . set Bounds ( source Region ) ; } int grid X = p . get Subsampling X Offset ( ) ; int grid Y = p . get Subsampling Y Offset ( ) ; source Bounds . x += grid X ; source Bounds . y += grid Y ; source Bounds . width -= grid X ; source Bounds . height -= grid Y ; period X = p . get Source X Subsampling ( ) ; period Y = p . get Source Y Subsampling ( ) ; } dest Size . set Size ( ( source Bounds . width + period X - NUM ) / period X , ( source Bounds . height + period Y - NUM ) / period Y ) ; if ( dest Size . width <= NUM || dest Size . height <= NUM ) { throw new Illegal Argument Exception ( STRING ) ; } }
public final void test ROUNDTRIP Get Key Spec Key Provider 02 ( ) { boolean performed = BOOL ; for ( int i = NUM ; i < alg Name . length ; i ++ ) { for ( int l = NUM ; l < provider . length ; l ++ ) { if ( provider [ l ] == null ) { continue ; } Test Data Generator g ; try { g = new Test Data Generator ( alg Name [ i ] [ NUM ] , alg Name [ i ] [ NUM ] , private Key Info Damaged , provider [ l ] ) ; } catch ( Test Data Generator . Allowed Failure allowed Failure ) { continue ; } try { Encrypted Private Key Info epki ; if ( g . ap ( ) == null ) { epki = new Encrypted Private Key Info ( alg Name [ i ] [ NUM ] , g . ct ( ) ) ; } else { epki = new Encrypted Private Key Info ( g . ap ( ) , g . ct ( ) ) ; } try { epki . get Key Spec ( g . pub K ( ) == null ? g . k ( ) : g . pub K ( ) , provider [ l ] ) ; fail ( alg Name [ i ] [ NUM ] + STRING + alg Name [ i ] [ NUM ] ) ; } catch ( Invalid Key Exception e ) { } performed = BOOL ; } catch ( No Such Algorithm Exception allowed Failure ) { } } } assert True ( STRING , performed ) ; }
public final void test ROUNDTRIP Get Key Spec Key Provider 02 ( ) { boolean performed = BOOL ; for ( int i = NUM ; i < alg Name . length ; i ++ ) { for ( int l = NUM ; l < provider . length ; l ++ ) { if ( provider [ l ] == null ) { continue ; } Test Data Generator g ; try { g = new Test Data Generator ( alg Name [ i ] [ NUM ] , alg Name [ i ] [ NUM ] , private Key Info Damaged , provider [ l ] ) ; } catch ( Test Data Generator . Allowed Failure allowed Failure ) { continue ; } try { Encrypted Private Key Info epki ; if ( g . ap ( ) == null ) { epki = new Encrypted Private Key Info ( alg Name [ i ] [ NUM ] , g . ct ( ) ) ; } else { epki = new Encrypted Private Key Info ( g . ap ( ) , g . ct ( ) ) ; } try { epki . get Key Spec ( g . pub K ( ) == null ? g . k ( ) : g . pub K ( ) , provider [ l ] ) ; fail ( alg Name [ i ] [ NUM ] + STRING + alg Name [ i ] [ NUM ] ) ; } catch ( Invalid Key Exception e ) { } performed = BOOL ; } catch ( No Such Algorithm Exception allowed Failure ) { } } } assert True ( STRING , performed ) ; }
private boolean remove Expired Attachment Points ( List < Attachment Point > ap List ) { List < Attachment Point > expired A Ps = new Array List < Attachment Point > ( ) ; if ( ap List == null ) return BOOL ; for ( Attachment Point ap : ap List ) { if ( ap . get Last Seen ( ) + Attachment Point . INACTIVITY INTERVAL < System . current Time Millis ( ) ) expired A Ps . add ( ap ) ; } if ( expired A Ps . size ( ) > NUM ) { ap List . remove All ( expired A Ps ) ; return BOOL ; } else return BOOL ; }
private void remove Possible Simple Key ( ) { Simple Key key = possible Simple Keys . remove ( flow Level ) ; if ( key != null && key . is Required ( ) ) { throw new Scanner Exception ( STRING , key . get Mark ( ) , STRING , reader . get Mark ( ) ) ; } }
private void remove Possible Simple Key ( ) { Simple Key key = possible Simple Keys . remove ( flow Level ) ; if ( key != null && key . is Required ( ) ) { throw new Scanner Exception ( STRING , key . get Mark ( ) , STRING , reader . get Mark ( ) ) ; } }
public static Exception establish Cache If Needed ( Print Stream ... progress ) { if ( m offline ) { return null ; } if ( REP MIRROR == null ) { establish Mirror ( ) ; } Exception problem = null ; if ( INITIAL CACHE BUILD NEEDED ) { for ( Print Stream p : progress ) { p . println ( STRING ) ; } problem = refresh Cache ( progress ) ; INITIAL CACHE BUILD NEEDED = BOOL ; } return problem ; }
public void append ( char [ ] other Chars , int other Offset , int other Length ) { int new Len = ref . length + other Length ; grow ( new Len ) ; System . arraycopy ( other Chars , other Offset , ref . chars , ref . length , other Length ) ; ref . length = new Len ; }
public static byte [ ] hash ( String input ) { if ( ! Text Utils . is Empty ( input ) ) { try { byte [ ] input Bytes = input . get Bytes ( STRING ) ; return hash ( input Bytes ) ; } catch ( Unsupported Encoding Exception e ) { Log . e ( TAG , STRING + input + STRING + e . get Message ( ) , e ) ; } } return null ; }
public Array Field Vector ( T [ ] v1 , Field Vector < T > v2 ) throws Null Argument Exception { Math Utils . check Not Null ( v1 ) ; Math Utils . check Not Null ( v2 ) ; field = v2 . get Field ( ) ; final T [ ] v2 Data = ( v2 instanceof Array Field Vector ) ? ( ( Array Field Vector < T > ) v2 ) . data : v2 . to Array ( ) ; data = Math Arrays . build Array ( field , v1 . length + v2 Data . length ) ; System . arraycopy ( v1 , NUM , data , NUM , v1 . length ) ; System . arraycopy ( v2 Data , NUM , data , v1 . length , v2 Data . length ) ; }
public Array Field Vector ( T [ ] v1 , Field Vector < T > v2 ) throws Null Argument Exception { Math Utils . check Not Null ( v1 ) ; Math Utils . check Not Null ( v2 ) ; field = v2 . get Field ( ) ; final T [ ] v2 Data = ( v2 instanceof Array Field Vector ) ? ( ( Array Field Vector < T > ) v2 ) . data : v2 . to Array ( ) ; data = Math Arrays . build Array ( field , v1 . length + v2 Data . length ) ; System . arraycopy ( v1 , NUM , data , NUM , v1 . length ) ; System . arraycopy ( v2 Data , NUM , data , v1 . length , v2 Data . length ) ; }
public Array Field Vector ( T [ ] v1 , Field Vector < T > v2 ) throws Null Argument Exception { Math Utils . check Not Null ( v1 ) ; Math Utils . check Not Null ( v2 ) ; field = v2 . get Field ( ) ; final T [ ] v2 Data = ( v2 instanceof Array Field Vector ) ? ( ( Array Field Vector < T > ) v2 ) . data : v2 . to Array ( ) ; data = Math Arrays . build Array ( field , v1 . length + v2 Data . length ) ; System . arraycopy ( v1 , NUM , data , NUM , v1 . length ) ; System . arraycopy ( v2 Data , NUM , data , v1 . length , v2 Data . length ) ; }
public D Sign Csr ( J Frame parent , Spkac spkac Csr , File csr File , Private Key sign Private Key , Key Pair Type sign Key Pair Type , X509 Certificate verification Certificate , Provider provider ) throws Crypto Exception { super ( parent , Dialog . Modality Type . DOCUMENT MODAL ) ; this . spkac Csr = spkac Csr ; this . csr File = csr File ; this . sign Private Key = sign Private Key ; this . sign Key Pair Type = sign Key Pair Type ; this . verification Certificate = verification Certificate ; this . provider = provider ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; }
public boolean has Any Capability ( String ... capabilities ) { for ( String capability : capabilities ) { if ( has Capability ( capability ) ) return BOOL ; } return BOOL ; }
public boolean has Any Capability ( String ... capabilities ) { for ( String capability : capabilities ) { if ( has Capability ( capability ) ) return BOOL ; } return BOOL ; }
public void invoke ( Input Stream is , Output Stream os , Serializer Factory serializer Factory ) throws Exception { boolean is Debug = BOOL ; if ( is Debug Invoke ( ) ) { is Debug = BOOL ; Print Writer dbg = create Debug Print Writer ( ) ; Hessian Debug Input Stream d Is = new Hessian Debug Input Stream ( is , dbg ) ; d Is . start Top 2 ( ) ; is = d Is ; Hessian Debug Output Stream d Os = new Hessian Debug Output Stream ( os , dbg ) ; d Os . start Top 2 ( ) ; os = d Os ; } Hessian Input Factory . Header Type header = input Factory . read Header ( is ) ; Abstract Hessian Input in ; Abstract Hessian Output out ; switch ( header ) { case CALL 1 REPLY 1 : in = hessian Factory . create Hessian Input ( is ) ; out = hessian Factory . create Hessian Output ( os ) ; break ; case CALL 1 REPLY 2 : in = hessian Factory . create Hessian Input ( is ) ; out = hessian Factory . create Hessian 2 Output ( os ) ; break ; case HESSIAN 2 : in = hessian Factory . create Hessian 2 Input ( is ) ; in . read Call ( ) ; out = hessian Factory . create Hessian 2 Output ( os ) ; break ; default : throw new Illegal State Exception ( header + STRING ) ; } if ( serializer Factory != null ) { in . set Serializer Factory ( serializer Factory ) ; out . set Serializer Factory ( serializer Factory ) ; } try { invoke ( service , in , out ) ; } finally { in . close ( ) ; out . close ( ) ; if ( is Debug ) os . close ( ) ; } }
public void invoke ( Input Stream is , Output Stream os , Serializer Factory serializer Factory ) throws Exception { boolean is Debug = BOOL ; if ( is Debug Invoke ( ) ) { is Debug = BOOL ; Print Writer dbg = create Debug Print Writer ( ) ; Hessian Debug Input Stream d Is = new Hessian Debug Input Stream ( is , dbg ) ; d Is . start Top 2 ( ) ; is = d Is ; Hessian Debug Output Stream d Os = new Hessian Debug Output Stream ( os , dbg ) ; d Os . start Top 2 ( ) ; os = d Os ; } Hessian Input Factory . Header Type header = input Factory . read Header ( is ) ; Abstract Hessian Input in ; Abstract Hessian Output out ; switch ( header ) { case CALL 1 REPLY 1 : in = hessian Factory . create Hessian Input ( is ) ; out = hessian Factory . create Hessian Output ( os ) ; break ; case CALL 1 REPLY 2 : in = hessian Factory . create Hessian Input ( is ) ; out = hessian Factory . create Hessian 2 Output ( os ) ; break ; case HESSIAN 2 : in = hessian Factory . create Hessian 2 Input ( is ) ; in . read Call ( ) ; out = hessian Factory . create Hessian 2 Output ( os ) ; break ; default : throw new Illegal State Exception ( header + STRING ) ; } if ( serializer Factory != null ) { in . set Serializer Factory ( serializer Factory ) ; out . set Serializer Factory ( serializer Factory ) ; } try { invoke ( service , in , out ) ; } finally { in . close ( ) ; out . close ( ) ; if ( is Debug ) os . close ( ) ; } }
private void flush Right ( ) throws IO Exception { append Newline If Necessary ( right Buf , right Column ) ; while ( right Buf . length ( ) != NUM ) { left Column . write ( STRING ) ; output Full Lines ( ) ; } }
private void flush Right ( ) throws IO Exception { append Newline If Necessary ( right Buf , right Column ) ; while ( right Buf . length ( ) != NUM ) { left Column . write ( STRING ) ; output Full Lines ( ) ; } }
private void flush Right ( ) throws IO Exception { append Newline If Necessary ( right Buf , right Column ) ; while ( right Buf . length ( ) != NUM ) { left Column . write ( STRING ) ; output Full Lines ( ) ; } }
private static void learn ( ) { int list Size = learning Queue . size ( ) ; for ( int i = NUM ; i < list Size ; i ++ ) { Instance inst = learning Queue . poll ( ) ; if ( inst != null ) learner . train On Instance ( inst ) ; } }
public void expire Lease ( String lease Id ) throws Illegal State Exception { assignable V Ms . expire Lease ( lease Id ) ; }
public void expire Lease ( String lease Id ) throws Illegal State Exception { assignable V Ms . expire Lease ( lease Id ) ; }
public void expire Lease ( String lease Id ) throws Illegal State Exception { assignable V Ms . expire Lease ( lease Id ) ; }
public Event Expire Thread ( ) { super ( STRING ) ; set Daemon ( BOOL ) ; }
public static double compute MAD ( double [ ] x , double median ) { for ( int i = NUM ; i < x . length ; i ++ ) { x [ i ] = Math . abs ( x [ i ] - median ) ; } double mad = Quick Select . median ( x ) ; if ( ! ( mad > NUM ) ) { double min = Double . POSITIVE INFINITY ; for ( double xi : x ) { if ( xi > NUM && xi < min ) { min = xi ; } } if ( min < Double . POSITIVE INFINITY ) { mad = min ; } else { mad = NUM ; } } return mad ; }
public String consume Content ( boolean required ) throws Parse Exception { return consume ( null , required ) ; }
private void annotate ( Statement Data sdata , String schema , String table , String operation ) { sdata . set Option ( Repl Option Params . SCHEMA NAME , schema ) ; if ( table != null ) sdata . set Option ( Repl Option Params . TABLE NAME , table ) ; sdata . set Option ( Repl Option Params . OPERATION NAME , operation ) ; }
public Builder server ( String server ) { if ( server . ends With ( STRING ) == BOOL ) { server = server + STRING ; } this . server = server ; return this ; }
public Builder server ( String server ) { if ( server . ends With ( STRING ) == BOOL ) { server = server + STRING ; } this . server = server ; return this ; }
public Builder server ( String server ) { if ( server . ends With ( STRING ) == BOOL ) { server = server + STRING ; } this . server = server ; return this ; }
public Builder server ( String server ) { if ( server . ends With ( STRING ) == BOOL ) { server = server + STRING ; } this . server = server ; return this ; }
public int index Of ( final Artist a ) { synchronized ( m Artists ) { return m Artists . index Of ( a ) ; } }
private boolean before ( long a , long b ) { return a < b ^ a - b > ( MAXIMUM KEY / NUM ) ; }
public Dock Node Event Handler ( Node node ) { this . node = node ; }
public Dock Node Event Handler ( Node node ) { this . node = node ; }
public Dock Node Event Handler ( Node node ) { this . node = node ; }
public Dock Node Event Handler ( Node node ) { this . node = node ; }
public Dock Node Event Handler ( Node node ) { this . node = node ; }
public int count ( ) { return incomplete list . size ( ) ; }
protected char [ ] qname ( boolean ns ) throws Exception { m Buff Idx = - NUM ; bname ( ns ) ; char chars [ ] = new char [ m Buff Idx + NUM ] ; System . arraycopy ( m Buff , NUM , chars , NUM , m Buff Idx + NUM ) ; return chars ; }
protected char [ ] qname ( boolean ns ) throws Exception { m Buff Idx = - NUM ; bname ( ns ) ; char chars [ ] = new char [ m Buff Idx + NUM ] ; System . arraycopy ( m Buff , NUM , chars , NUM , m Buff Idx + NUM ) ; return chars ; }
protected char [ ] qname ( boolean ns ) throws Exception { m Buff Idx = - NUM ; bname ( ns ) ; char chars [ ] = new char [ m Buff Idx + NUM ] ; System . arraycopy ( m Buff , NUM , chars , NUM , m Buff Idx + NUM ) ; return chars ; }
protected char [ ] qname ( boolean ns ) throws Exception { m Buff Idx = - NUM ; bname ( ns ) ; char chars [ ] = new char [ m Buff Idx + NUM ] ; System . arraycopy ( m Buff , NUM , chars , NUM , m Buff Idx + NUM ) ; return chars ; }
protected char [ ] qname ( boolean ns ) throws Exception { m Buff Idx = - NUM ; bname ( ns ) ; char chars [ ] = new char [ m Buff Idx + NUM ] ; System . arraycopy ( m Buff , NUM , chars , NUM , m Buff Idx + NUM ) ; return chars ; }
protected char [ ] qname ( boolean ns ) throws Exception { m Buff Idx = - NUM ; bname ( ns ) ; char chars [ ] = new char [ m Buff Idx + NUM ] ; System . arraycopy ( m Buff , NUM , chars , NUM , m Buff Idx + NUM ) ; return chars ; }
protected char [ ] qname ( boolean ns ) throws Exception { m Buff Idx = - NUM ; bname ( ns ) ; char chars [ ] = new char [ m Buff Idx + NUM ] ; System . arraycopy ( m Buff , NUM , chars , NUM , m Buff Idx + NUM ) ; return chars ; }
protected char [ ] qname ( boolean ns ) throws Exception { m Buff Idx = - NUM ; bname ( ns ) ; char chars [ ] = new char [ m Buff Idx + NUM ] ; System . arraycopy ( m Buff , NUM , chars , NUM , m Buff Idx + NUM ) ; return chars ; }
@ Override public int hash Code ( ) { final int prime = NUM ; int result = super . hash Code ( ) ; result = prime * result + ( tenant == null ? NUM : tenant . hash Code ( ) ) ; return result ; }
@ Override public int hash Code ( ) { final int prime = NUM ; int result = super . hash Code ( ) ; result = prime * result + ( tenant == null ? NUM : tenant . hash Code ( ) ) ; return result ; }
@ Override public int hash Code ( ) { final int prime = NUM ; int result = super . hash Code ( ) ; result = prime * result + ( tenant == null ? NUM : tenant . hash Code ( ) ) ; return result ; }
@ Override public int hash Code ( ) { final int prime = NUM ; int result = super . hash Code ( ) ; result = prime * result + ( tenant == null ? NUM : tenant . hash Code ( ) ) ; return result ; }
@ Override public int hash Code ( ) { final int prime = NUM ; int result = super . hash Code ( ) ; result = prime * result + ( tenant == null ? NUM : tenant . hash Code ( ) ) ; return result ; }
@ Override public int hash Code ( ) { final int prime = NUM ; int result = super . hash Code ( ) ; result = prime * result + ( tenant == null ? NUM : tenant . hash Code ( ) ) ; return result ; }
private void keep Alive ( ) { Thread current = Thread . current Thread ( ) ; try { heart Beat ( ) ; while ( current == keep Alive Thread ) { Thread . sleep ( HEART BEAT ) ; heart Beat ( ) ; } } catch ( Interrupted Exception e ) { log . warn ( STRING , e ) ; } }
private void keep Alive ( ) { Thread current = Thread . current Thread ( ) ; try { heart Beat ( ) ; while ( current == keep Alive Thread ) { Thread . sleep ( HEART BEAT ) ; heart Beat ( ) ; } } catch ( Interrupted Exception e ) { log . warn ( STRING , e ) ; } }
private void keep Alive ( ) { Thread current = Thread . current Thread ( ) ; try { heart Beat ( ) ; while ( current == keep Alive Thread ) { Thread . sleep ( HEART BEAT ) ; heart Beat ( ) ; } } catch ( Interrupted Exception e ) { log . warn ( STRING , e ) ; } }
public boolean is Quest Completed ( final String name ) { final String info = get Quest ( name , NUM ) ; if ( info == null ) { return BOOL ; } return info . equals ( STRING ) ; }
public boolean is Quest Completed ( final String name ) { final String info = get Quest ( name , NUM ) ; if ( info == null ) { return BOOL ; } return info . equals ( STRING ) ; }
@ Nullable public V remove First ( ) { return vals . is Empty ( ) ? null : vals . remove First ( ) ; }
public String write ( ) { String Builder result = new String Builder ( ) ; for ( Text t : this . components ) { result . append ( t ) ; } return result . to String ( ) ; }
public synchronized Boolean update AV Client By Stream Id ( String stream Id , Room Client rcm ) { try { Room Client rcl Usual = get Client By Public SID ( rcm . get Public SID ( ) , BOOL ) ; if ( rcl Usual != null ) { rcl Usual . set Broad Cast ID ( rcm . get Broad Cast ID ( ) ) ; rcl Usual . set Avsettings ( rcm . get Avsettings ( ) ) ; rcl Usual . set V Height ( rcm . get V Height ( ) ) ; rcl Usual . set V Width ( rcm . get V Width ( ) ) ; rcl Usual . set VX ( rcm . get VX ( ) ) ; rcl Usual . set VY ( rcm . get VY ( ) ) ; if ( client List . contains Key ( rcl Usual . get Streamid ( ) ) ) { client List . put ( rcl Usual . get Streamid ( ) , rcl Usual ) ; } else { log . debug ( STRING + rcl Usual . get Streamid ( ) ) ; } } update Client By Stream Id ( stream Id , rcm ) ; } catch ( Exception err ) { log . error ( STRING , err ) ; } return null ; }
public synchronized Boolean update AV Client By Stream Id ( String stream Id , Room Client rcm ) { try { Room Client rcl Usual = get Client By Public SID ( rcm . get Public SID ( ) , BOOL ) ; if ( rcl Usual != null ) { rcl Usual . set Broad Cast ID ( rcm . get Broad Cast ID ( ) ) ; rcl Usual . set Avsettings ( rcm . get Avsettings ( ) ) ; rcl Usual . set V Height ( rcm . get V Height ( ) ) ; rcl Usual . set V Width ( rcm . get V Width ( ) ) ; rcl Usual . set VX ( rcm . get VX ( ) ) ; rcl Usual . set VY ( rcm . get VY ( ) ) ; if ( client List . contains Key ( rcl Usual . get Streamid ( ) ) ) { client List . put ( rcl Usual . get Streamid ( ) , rcl Usual ) ; } else { log . debug ( STRING + rcl Usual . get Streamid ( ) ) ; } } update Client By Stream Id ( stream Id , rcm ) ; } catch ( Exception err ) { log . error ( STRING , err ) ; } return null ; }
public synchronized Boolean update AV Client By Stream Id ( String stream Id , Room Client rcm ) { try { Room Client rcl Usual = get Client By Public SID ( rcm . get Public SID ( ) , BOOL ) ; if ( rcl Usual != null ) { rcl Usual . set Broad Cast ID ( rcm . get Broad Cast ID ( ) ) ; rcl Usual . set Avsettings ( rcm . get Avsettings ( ) ) ; rcl Usual . set V Height ( rcm . get V Height ( ) ) ; rcl Usual . set V Width ( rcm . get V Width ( ) ) ; rcl Usual . set VX ( rcm . get VX ( ) ) ; rcl Usual . set VY ( rcm . get VY ( ) ) ; if ( client List . contains Key ( rcl Usual . get Streamid ( ) ) ) { client List . put ( rcl Usual . get Streamid ( ) , rcl Usual ) ; } else { log . debug ( STRING + rcl Usual . get Streamid ( ) ) ; } } update Client By Stream Id ( stream Id , rcm ) ; } catch ( Exception err ) { log . error ( STRING , err ) ; } return null ; }
public synchronized Boolean update AV Client By Stream Id ( String stream Id , Room Client rcm ) { try { Room Client rcl Usual = get Client By Public SID ( rcm . get Public SID ( ) , BOOL ) ; if ( rcl Usual != null ) { rcl Usual . set Broad Cast ID ( rcm . get Broad Cast ID ( ) ) ; rcl Usual . set Avsettings ( rcm . get Avsettings ( ) ) ; rcl Usual . set V Height ( rcm . get V Height ( ) ) ; rcl Usual . set V Width ( rcm . get V Width ( ) ) ; rcl Usual . set VX ( rcm . get VX ( ) ) ; rcl Usual . set VY ( rcm . get VY ( ) ) ; if ( client List . contains Key ( rcl Usual . get Streamid ( ) ) ) { client List . put ( rcl Usual . get Streamid ( ) , rcl Usual ) ; } else { log . debug ( STRING + rcl Usual . get Streamid ( ) ) ; } } update Client By Stream Id ( stream Id , rcm ) ; } catch ( Exception err ) { log . error ( STRING , err ) ; } return null ; }
@ Override public void handle Click ( int x , int y , Plot Rendering Info info ) { }
@ Override public void handle Click ( int x , int y , Plot Rendering Info info ) { }
public void add Block Order ( Block Order order ) { saved Orders . add ( order ) ; }
protected void write Qualified Name ( String ns Alias , String name ) throws IO Exception { if ( ns Alias != null && ns Alias . length ( ) > NUM ) { writer . write ( ns Alias ) ; writer . write ( STRING ) ; } writer . write ( name ) ; }
public static Date Time to Date Simple ( String str , Time Zone time Zone ) throws Page Exception { Date Time dt = to Date Simple ( str , CONVERTING TYPE OFFSET , BOOL , time Zone , null ) ; if ( dt == null ) throw new Expression Exception ( STRING + str + STRING ) ; return dt ; }
public static Date Time to Date Simple ( String str , Time Zone time Zone ) throws Page Exception { Date Time dt = to Date Simple ( str , CONVERTING TYPE OFFSET , BOOL , time Zone , null ) ; if ( dt == null ) throw new Expression Exception ( STRING + str + STRING ) ; return dt ; }
public void add Invoice Fact ( M Fact Acct fact ) { m facts . add ( fact ) ; }
void remove Session ( GS Session Impl child Session ) { synchronized ( this ) { sessions . remove ( child Session ) ; child Session = null ; } }
protected List < Item > to Items ( List < Model > models ) { if ( models == null ) { return Collections . empty List ( ) ; } int size = models . size ( ) ; List < Item > items = new Array List < > ( size ) ; for ( int i = NUM ; i < size ; i ++ ) { items . add ( to Item ( models . get ( i ) ) ) ; } return items ; }
protected List < Item > to Items ( List < Model > models ) { if ( models == null ) { return Collections . empty List ( ) ; } int size = models . size ( ) ; List < Item > items = new Array List < > ( size ) ; for ( int i = NUM ; i < size ; i ++ ) { items . add ( to Item ( models . get ( i ) ) ) ; } return items ; }
public boolean is Empty ( ) { return get Item Count ( ) == NUM ; }
public static void generate List Of Modules ( String Builder builder ) { Iterator < String > entry Iterator = EXTENSIONS FQN . iterator ( ) ; while ( entry Iterator . has Next ( ) ) { String gin Module FQN = entry Iterator . next ( ) ; String has Comma = entry Iterator . has Next ( ) ? STRING : STRING ; builder . append ( Generator Utils . TAB + gin Module FQN + STRING + has Comma + STRING ) ; } }
public static boolean different ( Generic Record first , Generic Record second , List < String > value Field Names ) { for ( String value Field Name : value Field Names ) { Object first Value = first . get ( value Field Name ) ; Object second Value = second . get ( value Field Name ) ; if ( first Value != null && second Value != null && ! first Value . equals ( second Value ) ) { return BOOL ; } if ( ( first Value != null && second Value == null ) || ( first Value == null && second Value != null ) ) { return BOOL ; } } return BOOL ; }
public static boolean different ( Generic Record first , Generic Record second , List < String > value Field Names ) { for ( String value Field Name : value Field Names ) { Object first Value = first . get ( value Field Name ) ; Object second Value = second . get ( value Field Name ) ; if ( first Value != null && second Value != null && ! first Value . equals ( second Value ) ) { return BOOL ; } if ( ( first Value != null && second Value == null ) || ( first Value == null && second Value != null ) ) { return BOOL ; } } return BOOL ; }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null && m Is Bound ) { m Context . unbind Service ( m Service Conn ) ; } } m Disposed = BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null && m Is Bound ) { m Context . unbind Service ( m Service Conn ) ; } } m Disposed = BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null && m Is Bound ) { m Context . unbind Service ( m Service Conn ) ; } } m Disposed = BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null && m Is Bound ) { m Context . unbind Service ( m Service Conn ) ; } } m Disposed = BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
public Key Usage Extension ( ) { extension Id = PKIX Extensions . Key Usage Id ; critical = BOOL ; bit String = new boolean [ NUM ] ; }
@ Override protected void ensure Number Of Columns ( int number Of Columns ) { if ( data . length >= number Of Columns ) { return ; } int [ ] new Data = new int [ number Of Columns ] ; System . arraycopy ( data , NUM , new Data , NUM , data . length ) ; data = new Data ; }
@ Override protected void ensure Number Of Columns ( int number Of Columns ) { if ( data . length >= number Of Columns ) { return ; } int [ ] new Data = new int [ number Of Columns ] ; System . arraycopy ( data , NUM , new Data , NUM , data . length ) ; data = new Data ; }
public Lib Usb Exception ( final String message , final int error Code ) { super ( String . format ( STRING , - error Code , message , Lib Usb . str Error ( error Code ) ) ) ; this . error Code = error Code ; }
public Lib Usb Exception ( final String message , final int error Code ) { super ( String . format ( STRING , - error Code , message , Lib Usb . str Error ( error Code ) ) ) ; this . error Code = error Code ; }
public Lib Usb Exception ( final String message , final int error Code ) { super ( String . format ( STRING , - error Code , message , Lib Usb . str Error ( error Code ) ) ) ; this . error Code = error Code ; }
protected Object read Object Override ( ) throws Optional Data Exception , Class Not Found Exception , IO Exception { if ( input == null ) { return null ; } throw new IO Exception ( ) ; }
private static Input Stream null Input Stream ( ) throws Null Pointer Exception { if ( current Time Millis ( ) > NUM ) { return null ; } throw new Null Pointer Exception ( ) ; }
private static Input Stream null Input Stream ( ) throws Null Pointer Exception { if ( current Time Millis ( ) > NUM ) { return null ; } throw new Null Pointer Exception ( ) ; }
@ Side Effect Free protected void print Bound ( final String key Word , final Annotated Type Mirror field , final Set < Annotated Type Mirror > visiting , final String Builder sb ) { if ( ! current Print Verbose Generics && ( field == null || field . get Kind ( ) == Type Kind . NULL ) ) { return ; } sb . append ( STRING ) ; sb . append ( key Word ) ; sb . append ( STRING ) ; if ( field == null ) { sb . append ( STRING ) ; } else if ( field . get Kind ( ) != Type Kind . NULL ) { sb . append ( visit ( field , visiting ) ) ; } else { sb . append ( anno Formatter . format Annotation String ( field . get Annotations ( ) , current Print Invisible Setting ) ) ; sb . append ( STRING ) ; } }
@ Side Effect Free protected void print Bound ( final String key Word , final Annotated Type Mirror field , final Set < Annotated Type Mirror > visiting , final String Builder sb ) { if ( ! current Print Verbose Generics && ( field == null || field . get Kind ( ) == Type Kind . NULL ) ) { return ; } sb . append ( STRING ) ; sb . append ( key Word ) ; sb . append ( STRING ) ; if ( field == null ) { sb . append ( STRING ) ; } else if ( field . get Kind ( ) != Type Kind . NULL ) { sb . append ( visit ( field , visiting ) ) ; } else { sb . append ( anno Formatter . format Annotation String ( field . get Annotations ( ) , current Print Invisible Setting ) ) ; sb . append ( STRING ) ; } }
public void notify Failed ( Throwable exception ) throws Runtime Exception { exec . shutdown Now ( ) ; LOGGER . error ( exception ) ; throw new Runtime Exception ( exception ) ; }
public void load Args ( final int arg , final int count ) { int index = get Arg Index ( arg ) ; for ( int i = NUM ; i < count ; ++ i ) { Type t = argument Types [ arg + i ] ; load Insn ( t , index ) ; index += t . get Size ( ) ; } }
public void load Args ( final int arg , final int count ) { int index = get Arg Index ( arg ) ; for ( int i = NUM ; i < count ; ++ i ) { Type t = argument Types [ arg + i ] ; load Insn ( t , index ) ; index += t . get Size ( ) ; } }
public void load Args ( final int arg , final int count ) { int index = get Arg Index ( arg ) ; for ( int i = NUM ; i < count ; ++ i ) { Type t = argument Types [ arg + i ] ; load Insn ( t , index ) ; index += t . get Size ( ) ; } }
public boolean equals ( Object object ) { if ( this == object ) { return BOOL ; } else if ( object == null || get Class ( ) != object . get Class ( ) ) { return BOOL ; } return SSO Session ID . equals ( object ) ; }
public boolean equals ( Object object ) { if ( this == object ) { return BOOL ; } else if ( object == null || get Class ( ) != object . get Class ( ) ) { return BOOL ; } return SSO Session ID . equals ( object ) ; }
public boolean equals ( Object object ) { if ( this == object ) { return BOOL ; } else if ( object == null || get Class ( ) != object . get Class ( ) ) { return BOOL ; } return SSO Session ID . equals ( object ) ; }
protected void encode Atom ( Output Stream out Stream , byte data [ ] , int offset , int len ) throws IO Exception { byte a , b = NUM , c = NUM ; int c1 , c2 , c3 , c4 ; a = data [ offset ] ; if ( len > NUM ) { b = data [ offset + NUM ] ; } if ( len > NUM ) { c = data [ offset + NUM ] ; } c1 = ( a > > > NUM ) & NUM ; c2 = ( ( a << NUM ) & NUM ) | ( ( b > > > NUM ) & NUM ) ; c3 = ( ( b << NUM ) & NUM ) | ( ( c > > > NUM ) & NUM ) ; c4 = c & NUM ; out Stream . write ( c1 + STRING ) ; out Stream . write ( c2 + STRING ) ; out Stream . write ( c3 + STRING ) ; out Stream . write ( c4 + STRING ) ; return ; }
private List < Facet Result > facets With Search ( ) throws IO Exception { Directory Reader index Reader = Directory Reader . open ( index Dir ) ; Index Searcher searcher = new Index Searcher ( index Reader ) ; Taxonomy Reader taxo Reader = new Directory Taxonomy Reader ( taxo Dir ) ; Facets Collector fc = new Facets Collector ( ) ; Facets Collector . search ( searcher , new Match All Docs Query ( ) , NUM , fc ) ; List < Facet Result > results = new Array List < > ( ) ; Facets facets = new Fast Taxonomy Facet Counts ( taxo Reader , config , fc ) ; results . add ( facets . get Top Children ( NUM , STRING ) ) ; results . add ( facets . get Top Children ( NUM , STRING ) ) ; index Reader . close ( ) ; taxo Reader . close ( ) ; return results ; }
private List < Facet Result > facets With Search ( ) throws IO Exception { Directory Reader index Reader = Directory Reader . open ( index Dir ) ; Index Searcher searcher = new Index Searcher ( index Reader ) ; Taxonomy Reader taxo Reader = new Directory Taxonomy Reader ( taxo Dir ) ; Facets Collector fc = new Facets Collector ( ) ; Facets Collector . search ( searcher , new Match All Docs Query ( ) , NUM , fc ) ; List < Facet Result > results = new Array List < > ( ) ; Facets facets = new Fast Taxonomy Facet Counts ( taxo Reader , config , fc ) ; results . add ( facets . get Top Children ( NUM , STRING ) ) ; results . add ( facets . get Top Children ( NUM , STRING ) ) ; index Reader . close ( ) ; taxo Reader . close ( ) ; return results ; }
private static void serialize ( Data Output Stream out , Method Group [ ] methods ) throws IO Exception { out . write Int ( SNAPSHOT MAGIC ) ; out . write Int ( SNAPSHOT PROTOCOL VERSION ) ; out . write Int ( SNAPSHOT TYPE CALLTRACE ) ; out . write Int ( session Id ) ; out . write Long ( System . current Time Millis ( ) ) ; int n = NUM ; for ( Method Group m : methods ) { if ( m . hits > NUM ) { n ++ ; } } Log . print ( NUM , STRING + n + STRING ) ; out . write Int ( n ) ; for ( Method Group m : methods ) { if ( m . hits == NUM ) { continue ; } out . write Int ( m . global Id & NUM ) ; out . write UTF ( m . name ) ; out . write Int ( m . hits ) ; out . write Long ( m . net Time ) ; out . write Long ( m . self Time ) ; out . write Int ( m . child Count ) ; for ( int i = NUM ; i < m . child Count ; i ++ ) { out . write Int ( m . children [ i ] . global Id & NUM ) ; out . write Long ( m . children Times [ i ] ) ; } } }
public Connection Manager Service ( ) { this ( new Connection Info ( ) ) ; }
public synchronized void load ( ) throws Exception { load ( get Conf File Name ( ) ) ; }
private static void write String To Output ( String str , Data Output out ) throws IO Exception { out . write Int ( str . length ( ) ) ; out . write Chars ( str ) ; }
public static int index Of ( @ Not Null Char Sequence buffer , @ Not Null Char Sequence pattern , int from Index , final int to Index ) { final int pattern Length = pattern . length ( ) ; int limit = to Index - pattern Length + NUM ; if ( from Index < NUM ) { from Index = NUM ; } Search Loop : for ( int i = from Index ; i < limit ; i ++ ) { for ( int j = NUM ; j < pattern Length ; j ++ ) { if ( pattern . char At ( j ) != buffer . char At ( i + j ) ) continue Search Loop ; } return i ; } return - NUM ; }
public static int index Of ( @ Not Null Char Sequence buffer , @ Not Null Char Sequence pattern , int from Index , final int to Index ) { final int pattern Length = pattern . length ( ) ; int limit = to Index - pattern Length + NUM ; if ( from Index < NUM ) { from Index = NUM ; } Search Loop : for ( int i = from Index ; i < limit ; i ++ ) { for ( int j = NUM ; j < pattern Length ; j ++ ) { if ( pattern . char At ( j ) != buffer . char At ( i + j ) ) continue Search Loop ; } return i ; } return - NUM ; }
void commit ( ) { for ( My Property < ? > p : properties . values ( ) ) { p . commit ( ) ; } }
protected final Permit Status permit Status ( ) { if ( permits . get ( ) > NUM ) return Permit Status . MAYBE MORE ; else return unlimited ? Permit Status . UNLIMITED : Permit Status . NO MORE ; }
public static Inet Address long To Ip ( long ip ) { try { return Inet Address . get By Address ( long To Network Byte Order Array ( ip ) ) ; } catch ( Unknown Host Exception e ) { throw new Illegal Argument Exception ( STRING + ip ) ; } }
public static Inet Address long To Ip ( long ip ) { try { return Inet Address . get By Address ( long To Network Byte Order Array ( ip ) ) ; } catch ( Unknown Host Exception e ) { throw new Illegal Argument Exception ( STRING + ip ) ; } }
public static Inet Address long To Ip ( long ip ) { try { return Inet Address . get By Address ( long To Network Byte Order Array ( ip ) ) ; } catch ( Unknown Host Exception e ) { throw new Illegal Argument Exception ( STRING + ip ) ; } }
public void expand ( int level ) { Array List < S2 Cell Id > output = new Array List < S2 Cell Id > ( ) ; long level Lsb = S2 Cell Id . lowest On Bit For Level ( level ) ; int i = size ( ) - NUM ; do { S2 Cell Id id = cell Id ( i ) ; if ( id . lowest On Bit ( ) < level Lsb ) { id = id . parent ( level ) ; while ( i > NUM && id . contains ( cell Id ( i - NUM ) ) ) { -- i ; } } output . add ( id ) ; id . get All Neighbors ( level , output ) ; } while ( -- i >= NUM ) ; init Swap ( output ) ; }
public void expand ( int level ) { Array List < S2 Cell Id > output = new Array List < S2 Cell Id > ( ) ; long level Lsb = S2 Cell Id . lowest On Bit For Level ( level ) ; int i = size ( ) - NUM ; do { S2 Cell Id id = cell Id ( i ) ; if ( id . lowest On Bit ( ) < level Lsb ) { id = id . parent ( level ) ; while ( i > NUM && id . contains ( cell Id ( i - NUM ) ) ) { -- i ; } } output . add ( id ) ; id . get All Neighbors ( level , output ) ; } while ( -- i >= NUM ) ; init Swap ( output ) ; }
public void expand ( int level ) { Array List < S2 Cell Id > output = new Array List < S2 Cell Id > ( ) ; long level Lsb = S2 Cell Id . lowest On Bit For Level ( level ) ; int i = size ( ) - NUM ; do { S2 Cell Id id = cell Id ( i ) ; if ( id . lowest On Bit ( ) < level Lsb ) { id = id . parent ( level ) ; while ( i > NUM && id . contains ( cell Id ( i - NUM ) ) ) { -- i ; } } output . add ( id ) ; id . get All Neighbors ( level , output ) ; } while ( -- i >= NUM ) ; init Swap ( output ) ; }
public void expand ( int level ) { Array List < S2 Cell Id > output = new Array List < S2 Cell Id > ( ) ; long level Lsb = S2 Cell Id . lowest On Bit For Level ( level ) ; int i = size ( ) - NUM ; do { S2 Cell Id id = cell Id ( i ) ; if ( id . lowest On Bit ( ) < level Lsb ) { id = id . parent ( level ) ; while ( i > NUM && id . contains ( cell Id ( i - NUM ) ) ) { -- i ; } } output . add ( id ) ; id . get All Neighbors ( level , output ) ; } while ( -- i >= NUM ) ; init Swap ( output ) ; }
public void expand ( int level ) { Array List < S2 Cell Id > output = new Array List < S2 Cell Id > ( ) ; long level Lsb = S2 Cell Id . lowest On Bit For Level ( level ) ; int i = size ( ) - NUM ; do { S2 Cell Id id = cell Id ( i ) ; if ( id . lowest On Bit ( ) < level Lsb ) { id = id . parent ( level ) ; while ( i > NUM && id . contains ( cell Id ( i - NUM ) ) ) { -- i ; } } output . add ( id ) ; id . get All Neighbors ( level , output ) ; } while ( -- i >= NUM ) ; init Swap ( output ) ; }
public void expand ( int level ) { Array List < S2 Cell Id > output = new Array List < S2 Cell Id > ( ) ; long level Lsb = S2 Cell Id . lowest On Bit For Level ( level ) ; int i = size ( ) - NUM ; do { S2 Cell Id id = cell Id ( i ) ; if ( id . lowest On Bit ( ) < level Lsb ) { id = id . parent ( level ) ; while ( i > NUM && id . contains ( cell Id ( i - NUM ) ) ) { -- i ; } } output . add ( id ) ; id . get All Neighbors ( level , output ) ; } while ( -- i >= NUM ) ; init Swap ( output ) ; }
public void expand ( int level ) { Array List < S2 Cell Id > output = new Array List < S2 Cell Id > ( ) ; long level Lsb = S2 Cell Id . lowest On Bit For Level ( level ) ; int i = size ( ) - NUM ; do { S2 Cell Id id = cell Id ( i ) ; if ( id . lowest On Bit ( ) < level Lsb ) { id = id . parent ( level ) ; while ( i > NUM && id . contains ( cell Id ( i - NUM ) ) ) { -- i ; } } output . add ( id ) ; id . get All Neighbors ( level , output ) ; } while ( -- i >= NUM ) ; init Swap ( output ) ; }
public void expand ( int level ) { Array List < S2 Cell Id > output = new Array List < S2 Cell Id > ( ) ; long level Lsb = S2 Cell Id . lowest On Bit For Level ( level ) ; int i = size ( ) - NUM ; do { S2 Cell Id id = cell Id ( i ) ; if ( id . lowest On Bit ( ) < level Lsb ) { id = id . parent ( level ) ; while ( i > NUM && id . contains ( cell Id ( i - NUM ) ) ) { -- i ; } } output . add ( id ) ; id . get All Neighbors ( level , output ) ; } while ( -- i >= NUM ) ; init Swap ( output ) ; }
public void expand ( int level ) { Array List < S2 Cell Id > output = new Array List < S2 Cell Id > ( ) ; long level Lsb = S2 Cell Id . lowest On Bit For Level ( level ) ; int i = size ( ) - NUM ; do { S2 Cell Id id = cell Id ( i ) ; if ( id . lowest On Bit ( ) < level Lsb ) { id = id . parent ( level ) ; while ( i > NUM && id . contains ( cell Id ( i - NUM ) ) ) { -- i ; } } output . add ( id ) ; id . get All Neighbors ( level , output ) ; } while ( -- i >= NUM ) ; init Swap ( output ) ; }
public void expand ( int level ) { Array List < S2 Cell Id > output = new Array List < S2 Cell Id > ( ) ; long level Lsb = S2 Cell Id . lowest On Bit For Level ( level ) ; int i = size ( ) - NUM ; do { S2 Cell Id id = cell Id ( i ) ; if ( id . lowest On Bit ( ) < level Lsb ) { id = id . parent ( level ) ; while ( i > NUM && id . contains ( cell Id ( i - NUM ) ) ) { -- i ; } } output . add ( id ) ; id . get All Neighbors ( level , output ) ; } while ( -- i >= NUM ) ; init Swap ( output ) ; }
public void expand ( int level ) { Array List < S2 Cell Id > output = new Array List < S2 Cell Id > ( ) ; long level Lsb = S2 Cell Id . lowest On Bit For Level ( level ) ; int i = size ( ) - NUM ; do { S2 Cell Id id = cell Id ( i ) ; if ( id . lowest On Bit ( ) < level Lsb ) { id = id . parent ( level ) ; while ( i > NUM && id . contains ( cell Id ( i - NUM ) ) ) { -- i ; } } output . add ( id ) ; id . get All Neighbors ( level , output ) ; } while ( -- i >= NUM ) ; init Swap ( output ) ; }
public void expand ( int level ) { Array List < S2 Cell Id > output = new Array List < S2 Cell Id > ( ) ; long level Lsb = S2 Cell Id . lowest On Bit For Level ( level ) ; int i = size ( ) - NUM ; do { S2 Cell Id id = cell Id ( i ) ; if ( id . lowest On Bit ( ) < level Lsb ) { id = id . parent ( level ) ; while ( i > NUM && id . contains ( cell Id ( i - NUM ) ) ) { -- i ; } } output . add ( id ) ; id . get All Neighbors ( level , output ) ; } while ( -- i >= NUM ) ; init Swap ( output ) ; }
public void expand ( int level ) { Array List < S2 Cell Id > output = new Array List < S2 Cell Id > ( ) ; long level Lsb = S2 Cell Id . lowest On Bit For Level ( level ) ; int i = size ( ) - NUM ; do { S2 Cell Id id = cell Id ( i ) ; if ( id . lowest On Bit ( ) < level Lsb ) { id = id . parent ( level ) ; while ( i > NUM && id . contains ( cell Id ( i - NUM ) ) ) { -- i ; } } output . add ( id ) ; id . get All Neighbors ( level , output ) ; } while ( -- i >= NUM ) ; init Swap ( output ) ; }
public void expand ( int level ) { Array List < S2 Cell Id > output = new Array List < S2 Cell Id > ( ) ; long level Lsb = S2 Cell Id . lowest On Bit For Level ( level ) ; int i = size ( ) - NUM ; do { S2 Cell Id id = cell Id ( i ) ; if ( id . lowest On Bit ( ) < level Lsb ) { id = id . parent ( level ) ; while ( i > NUM && id . contains ( cell Id ( i - NUM ) ) ) { -- i ; } } output . add ( id ) ; id . get All Neighbors ( level , output ) ; } while ( -- i >= NUM ) ; init Swap ( output ) ; }
private String exclude Destination Statement ( String text ) { int idx = - NUM ; if ( ( idx = text . index Of ( STRING ) ) != - NUM ) { text = text . substring ( NUM , idx ) ; } return text ; }
private String exclude Destination Statement ( String text ) { int idx = - NUM ; if ( ( idx = text . index Of ( STRING ) ) != - NUM ) { text = text . substring ( NUM , idx ) ; } return text ; }
private String exclude Destination Statement ( String text ) { int idx = - NUM ; if ( ( idx = text . index Of ( STRING ) ) != - NUM ) { text = text . substring ( NUM , idx ) ; } return text ; }
private String exclude Destination Statement ( String text ) { int idx = - NUM ; if ( ( idx = text . index Of ( STRING ) ) != - NUM ) { text = text . substring ( NUM , idx ) ; } return text ; }
private String exclude Destination Statement ( String text ) { int idx = - NUM ; if ( ( idx = text . index Of ( STRING ) ) != - NUM ) { text = text . substring ( NUM , idx ) ; } return text ; }
private String exclude Destination Statement ( String text ) { int idx = - NUM ; if ( ( idx = text . index Of ( STRING ) ) != - NUM ) { text = text . substring ( NUM , idx ) ; } return text ; }
private String exclude Destination Statement ( String text ) { int idx = - NUM ; if ( ( idx = text . index Of ( STRING ) ) != - NUM ) { text = text . substring ( NUM , idx ) ; } return text ; }
private String exclude Destination Statement ( String text ) { int idx = - NUM ; if ( ( idx = text . index Of ( STRING ) ) != - NUM ) { text = text . substring ( NUM , idx ) ; } return text ; }
private String exclude Destination Statement ( String text ) { int idx = - NUM ; if ( ( idx = text . index Of ( STRING ) ) != - NUM ) { text = text . substring ( NUM , idx ) ; } return text ; }
private String exclude Destination Statement ( String text ) { int idx = - NUM ; if ( ( idx = text . index Of ( STRING ) ) != - NUM ) { text = text . substring ( NUM , idx ) ; } return text ; }
private String exclude Destination Statement ( String text ) { int idx = - NUM ; if ( ( idx = text . index Of ( STRING ) ) != - NUM ) { text = text . substring ( NUM , idx ) ; } return text ; }
private String exclude Destination Statement ( String text ) { int idx = - NUM ; if ( ( idx = text . index Of ( STRING ) ) != - NUM ) { text = text . substring ( NUM , idx ) ; } return text ; }
private String exclude Destination Statement ( String text ) { int idx = - NUM ; if ( ( idx = text . index Of ( STRING ) ) != - NUM ) { text = text . substring ( NUM , idx ) ; } return text ; }
private String exclude Destination Statement ( String text ) { int idx = - NUM ; if ( ( idx = text . index Of ( STRING ) ) != - NUM ) { text = text . substring ( NUM , idx ) ; } return text ; }
private String exclude Destination Statement ( String text ) { int idx = - NUM ; if ( ( idx = text . index Of ( STRING ) ) != - NUM ) { text = text . substring ( NUM , idx ) ; } return text ; }
private String append National Number ( String national Number ) { int prefix Before National Number Length = prefix Before National Number . length ( ) ; if ( should Add Space After National Prefix && prefix Before National Number Length > NUM && prefix Before National Number . char At ( prefix Before National Number Length - NUM ) != SEPARATOR BEFORE NATIONAL NUMBER ) { return new String ( prefix Before National Number ) + SEPARATOR BEFORE NATIONAL NUMBER + national Number ; } else { return prefix Before National Number + national Number ; } }
private String append National Number ( String national Number ) { int prefix Before National Number Length = prefix Before National Number . length ( ) ; if ( should Add Space After National Prefix && prefix Before National Number Length > NUM && prefix Before National Number . char At ( prefix Before National Number Length - NUM ) != SEPARATOR BEFORE NATIONAL NUMBER ) { return new String ( prefix Before National Number ) + SEPARATOR BEFORE NATIONAL NUMBER + national Number ; } else { return prefix Before National Number + national Number ; } }
private void create Locale Entry ( String val ) { String Tokenizer tok 1 = new String Tokenizer ( val , STRING ) ; String locale Value = null ; Linked List charset List = null ; while ( tok 1 . has More Elements ( ) ) { String element = tok 1 . next Token ( ) ; String Tokenizer pair Tok = new String Tokenizer ( element , STRING ) ; if ( pair Tok . count Tokens ( ) == NUM ) { String key = pair Tok . next Token ( ) ; key = key . trim ( ) ; String value = pair Tok . next Token ( ) ; if ( key . equals Ignore Case ( STRING ) ) { locale Value = value . to Lower Case ( ) ; } int charset Count = NUM ; if ( key . equals Ignore Case ( STRING ) ) { charset List = new Linked List ( ) ; String Tokenizer charset Tokenizer = new String Tokenizer ( value , STRING ) ; while ( charset Tokenizer . has More Elements ( ) ) { String charset Val = charset Tokenizer . next Token ( ) ; charset List . add ( charset Val ) ; charset Count ++ ; } } } } if ( charset List != null && locale Value != null ) { locale Charset . put ( locale Value , charset List ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + locale Value + STRING + charset List ) ; } } }
private void create Locale Entry ( String val ) { String Tokenizer tok 1 = new String Tokenizer ( val , STRING ) ; String locale Value = null ; Linked List charset List = null ; while ( tok 1 . has More Elements ( ) ) { String element = tok 1 . next Token ( ) ; String Tokenizer pair Tok = new String Tokenizer ( element , STRING ) ; if ( pair Tok . count Tokens ( ) == NUM ) { String key = pair Tok . next Token ( ) ; key = key . trim ( ) ; String value = pair Tok . next Token ( ) ; if ( key . equals Ignore Case ( STRING ) ) { locale Value = value . to Lower Case ( ) ; } int charset Count = NUM ; if ( key . equals Ignore Case ( STRING ) ) { charset List = new Linked List ( ) ; String Tokenizer charset Tokenizer = new String Tokenizer ( value , STRING ) ; while ( charset Tokenizer . has More Elements ( ) ) { String charset Val = charset Tokenizer . next Token ( ) ; charset List . add ( charset Val ) ; charset Count ++ ; } } } } if ( charset List != null && locale Value != null ) { locale Charset . put ( locale Value , charset List ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + locale Value + STRING + charset List ) ; } } }
private void create Locale Entry ( String val ) { String Tokenizer tok 1 = new String Tokenizer ( val , STRING ) ; String locale Value = null ; Linked List charset List = null ; while ( tok 1 . has More Elements ( ) ) { String element = tok 1 . next Token ( ) ; String Tokenizer pair Tok = new String Tokenizer ( element , STRING ) ; if ( pair Tok . count Tokens ( ) == NUM ) { String key = pair Tok . next Token ( ) ; key = key . trim ( ) ; String value = pair Tok . next Token ( ) ; if ( key . equals Ignore Case ( STRING ) ) { locale Value = value . to Lower Case ( ) ; } int charset Count = NUM ; if ( key . equals Ignore Case ( STRING ) ) { charset List = new Linked List ( ) ; String Tokenizer charset Tokenizer = new String Tokenizer ( value , STRING ) ; while ( charset Tokenizer . has More Elements ( ) ) { String charset Val = charset Tokenizer . next Token ( ) ; charset List . add ( charset Val ) ; charset Count ++ ; } } } } if ( charset List != null && locale Value != null ) { locale Charset . put ( locale Value , charset List ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + locale Value + STRING + charset List ) ; } } }
private void create Locale Entry ( String val ) { String Tokenizer tok 1 = new String Tokenizer ( val , STRING ) ; String locale Value = null ; Linked List charset List = null ; while ( tok 1 . has More Elements ( ) ) { String element = tok 1 . next Token ( ) ; String Tokenizer pair Tok = new String Tokenizer ( element , STRING ) ; if ( pair Tok . count Tokens ( ) == NUM ) { String key = pair Tok . next Token ( ) ; key = key . trim ( ) ; String value = pair Tok . next Token ( ) ; if ( key . equals Ignore Case ( STRING ) ) { locale Value = value . to Lower Case ( ) ; } int charset Count = NUM ; if ( key . equals Ignore Case ( STRING ) ) { charset List = new Linked List ( ) ; String Tokenizer charset Tokenizer = new String Tokenizer ( value , STRING ) ; while ( charset Tokenizer . has More Elements ( ) ) { String charset Val = charset Tokenizer . next Token ( ) ; charset List . add ( charset Val ) ; charset Count ++ ; } } } } if ( charset List != null && locale Value != null ) { locale Charset . put ( locale Value , charset List ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + locale Value + STRING + charset List ) ; } } }
private void validate Business Object Format Ddl Collection Request ( Business Object Format Ddl Collection Request business Object Format Ddl Collection Request ) { Assert . not Null ( business Object Format Ddl Collection Request , STRING ) ; Assert . is True ( ! Collection Utils . is Empty ( business Object Format Ddl Collection Request . get Business Object Format Ddl Requests ( ) ) , STRING ) ; for ( Business Object Format Ddl Request request : business Object Format Ddl Collection Request . get Business Object Format Ddl Requests ( ) ) { validate Business Object Format Ddl Request ( request ) ; } }
private void validate Business Object Format Ddl Collection Request ( Business Object Format Ddl Collection Request business Object Format Ddl Collection Request ) { Assert . not Null ( business Object Format Ddl Collection Request , STRING ) ; Assert . is True ( ! Collection Utils . is Empty ( business Object Format Ddl Collection Request . get Business Object Format Ddl Requests ( ) ) , STRING ) ; for ( Business Object Format Ddl Request request : business Object Format Ddl Collection Request . get Business Object Format Ddl Requests ( ) ) { validate Business Object Format Ddl Request ( request ) ; } }
public boolean is Return Block ( Basic Block block ) { return return Block Set . get ( block . get Label ( ) ) ; }
@ Override public boolean connection Allowed ( String event Name ) { return event Name . equals ( STRING ) || event Name . equals ( STRING ) ; }
@ Override public boolean connection Allowed ( String event Name ) { return event Name . equals ( STRING ) || event Name . equals ( STRING ) ; }
@ Override public boolean connection Allowed ( String event Name ) { return event Name . equals ( STRING ) || event Name . equals ( STRING ) ; }
@ Override public boolean connection Allowed ( String event Name ) { return event Name . equals ( STRING ) || event Name . equals ( STRING ) ; }
public void close ( ) throws IO Exception { writer . close ( ) ; }
protected Button create Open Button ( ) { Button ob = new Button ( ) ; ob . set UIID ( STRING ) ; UI Manager uim = parent . get UI Manager ( ) ; Image i = ( Image ) uim . get Theme Image Constant ( STRING ) ; if ( i != null ) { ob . set Icon ( i ) ; } else { float size = NUM ; try { size = Float . parse Float ( uim . get Theme Constant ( STRING , STRING ) ) ; } catch ( Throwable t ) { t . print Stack Trace ( ) ; } Font Image . set Material Icon ( ob , Font Image . MATERIAL MENU , size ) ; } Image p = ( Image ) uim . get Theme Image Constant ( STRING ) ; if ( p != null ) { ob . set Pressed Icon ( p ) ; } return ob ; }
private Class < ? > read New Proxy Class Desc ( ) throws Class Not Found Exception , IO Exception { int count = input . read Int ( ) ; String [ ] interface Names = new String [ count ] ; for ( int i = NUM ; i < count ; i ++ ) { interface Names [ i ] = input . read UTF ( ) ; } Class < ? > proxy = resolve Proxy Class ( interface Names ) ; discard Data ( ) ; return proxy ; }
public static boolean is Crafting Skill ( int skill Id ) { Iterator < Integer > it = crafting Skill Ids . iterator ( ) ; while ( it . has Next ( ) ) { if ( it . next ( ) == skill Id ) { return BOOL ; } } return BOOL ; }
public static boolean is Crafting Skill ( int skill Id ) { Iterator < Integer > it = crafting Skill Ids . iterator ( ) ; while ( it . has Next ( ) ) { if ( it . next ( ) == skill Id ) { return BOOL ; } } return BOOL ; }
protected void merge ( Properties from , Properties to , String what , String where ) { if ( ! from . is Empty ( ) ) { if ( to == null ) { to = get Properties ( ) ; } Prop Utils . copy Properties ( from , to ) ; } else { if ( what != null && DEBUG ) { logger . fine ( STRING + what + STRING + ( where == null ? STRING : ( STRING + where ) ) ) ; } } }
protected void merge ( Properties from , Properties to , String what , String where ) { if ( ! from . is Empty ( ) ) { if ( to == null ) { to = get Properties ( ) ; } Prop Utils . copy Properties ( from , to ) ; } else { if ( what != null && DEBUG ) { logger . fine ( STRING + what + STRING + ( where == null ? STRING : ( STRING + where ) ) ) ; } } }
protected void merge ( Properties from , Properties to , String what , String where ) { if ( ! from . is Empty ( ) ) { if ( to == null ) { to = get Properties ( ) ; } Prop Utils . copy Properties ( from , to ) ; } else { if ( what != null && DEBUG ) { logger . fine ( STRING + what + STRING + ( where == null ? STRING : ( STRING + where ) ) ) ; } } }
protected void merge ( Properties from , Properties to , String what , String where ) { if ( ! from . is Empty ( ) ) { if ( to == null ) { to = get Properties ( ) ; } Prop Utils . copy Properties ( from , to ) ; } else { if ( what != null && DEBUG ) { logger . fine ( STRING + what + STRING + ( where == null ? STRING : ( STRING + where ) ) ) ; } } }
protected void merge ( Properties from , Properties to , String what , String where ) { if ( ! from . is Empty ( ) ) { if ( to == null ) { to = get Properties ( ) ; } Prop Utils . copy Properties ( from , to ) ; } else { if ( what != null && DEBUG ) { logger . fine ( STRING + what + STRING + ( where == null ? STRING : ( STRING + where ) ) ) ; } } }
protected void merge ( Properties from , Properties to , String what , String where ) { if ( ! from . is Empty ( ) ) { if ( to == null ) { to = get Properties ( ) ; } Prop Utils . copy Properties ( from , to ) ; } else { if ( what != null && DEBUG ) { logger . fine ( STRING + what + STRING + ( where == null ? STRING : ( STRING + where ) ) ) ; } } }
protected void merge ( Properties from , Properties to , String what , String where ) { if ( ! from . is Empty ( ) ) { if ( to == null ) { to = get Properties ( ) ; } Prop Utils . copy Properties ( from , to ) ; } else { if ( what != null && DEBUG ) { logger . fine ( STRING + what + STRING + ( where == null ? STRING : ( STRING + where ) ) ) ; } } }
public final int length ( ) { return remaining ( ) ; }
public void test Config File Directory ( ) throws Exception { Properties properties = load Properties ( STRING ) ; assert Equals ( STRING , properties . get Property ( STRING ) ) ; }
static String escape String For ASCII ( String s ) { String out = STRING ; char [ ] c Array = s . to Char Array ( ) ; for ( int i = NUM ; i < c Array . length ; i ++ ) { char c = c Array [ i ] ; if ( c > NUM ) { out += STRING ; String hex = Integer . to Hex String ( c ) ; while ( hex . length ( ) < NUM ) hex = STRING + hex ; out += hex ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else { out += c ; } } return out ; }
static String escape String For ASCII ( String s ) { String out = STRING ; char [ ] c Array = s . to Char Array ( ) ; for ( int i = NUM ; i < c Array . length ; i ++ ) { char c = c Array [ i ] ; if ( c > NUM ) { out += STRING ; String hex = Integer . to Hex String ( c ) ; while ( hex . length ( ) < NUM ) hex = STRING + hex ; out += hex ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else { out += c ; } } return out ; }
public void done ( Remote Call call ) throws Remote Exception { client Ref Log . log ( Log . BRIEF , STRING ) ; free ( call , BOOL ) ; try { call . done ( ) ; } catch ( IO Exception e ) { } }
public void done ( Remote Call call ) throws Remote Exception { client Ref Log . log ( Log . BRIEF , STRING ) ; free ( call , BOOL ) ; try { call . done ( ) ; } catch ( IO Exception e ) { } }
public void done ( Remote Call call ) throws Remote Exception { client Ref Log . log ( Log . BRIEF , STRING ) ; free ( call , BOOL ) ; try { call . done ( ) ; } catch ( IO Exception e ) { } }
public static Snippet Set parse ( final File file ) throws Parse Exception { return parse ( file Input Supplier ( file . get Parent File ( ) ) , file . get Name ( ) ) ; }
public static Snippet Set parse ( final File file ) throws Parse Exception { return parse ( file Input Supplier ( file . get Parent File ( ) ) , file . get Name ( ) ) ; }
public static Input Stream try Gzip Input ( Input Stream in ) throws IO Exception { if ( ! in . mark Supported ( ) ) { Pushback Input Stream pb = new Pushback Input Stream ( in , NUM ) ; in = pb ; byte [ ] magic = { NUM , NUM } ; pb . read ( magic ) ; pb . unread ( magic ) ; if ( magic [ NUM ] == NUM && magic [ NUM ] == - NUM ) { return new GZIP Input Stream ( pb ) ; } return in ; } in . mark ( NUM ) ; boolean isgzip = ( in . read ( ) == NUM && in . read ( ) == - NUM ) ; in . reset ( ) ; if ( isgzip ) { in = new GZIP Input Stream ( in ) ; } return in ; }
private void load Tile ( String image Path , int x , int y , int zoom Level , Projection proj , OM Graphic List list ) { Cache Object ret = load ( image Path , x , y , zoom Level , proj ) ; if ( ret == null ) { ret = get Empty Tile ( image Path , x , y , zoom Level , proj ) ; } if ( ret != null ) { replace Least Used ( ret ) ; OM Graphic raster = ( OM Graphic ) ret . obj ; if ( raster != null ) { raster . generate ( proj ) ; list . add ( raster ) ; if ( logger . is Loggable ( Level . FINE ) ) { raster . put Attribute ( OM Graphic . TOOLTIP , image Path ) ; } } } }
private void load Tile ( String image Path , int x , int y , int zoom Level , Projection proj , OM Graphic List list ) { Cache Object ret = load ( image Path , x , y , zoom Level , proj ) ; if ( ret == null ) { ret = get Empty Tile ( image Path , x , y , zoom Level , proj ) ; } if ( ret != null ) { replace Least Used ( ret ) ; OM Graphic raster = ( OM Graphic ) ret . obj ; if ( raster != null ) { raster . generate ( proj ) ; list . add ( raster ) ; if ( logger . is Loggable ( Level . FINE ) ) { raster . put Attribute ( OM Graphic . TOOLTIP , image Path ) ; } } } }
public static void assume Currency Support ( String ... codes ) { try { for ( String code : codes ) { Currency obj = Currency . get Instance ( code ) ; assert Not Null ( code , obj ) ; } } catch ( Illegal Argument Exception e ) { Assume . assume No Exception ( e ) ; } }
public static void assume Currency Support ( String ... codes ) { try { for ( String code : codes ) { Currency obj = Currency . get Instance ( code ) ; assert Not Null ( code , obj ) ; } } catch ( Illegal Argument Exception e ) { Assume . assume No Exception ( e ) ; } }
static Field find Field ( Object instance , String name ) throws No Such Field Exception { for ( Class < ? > clazz = instance . get Class ( ) ; clazz != null ; clazz = clazz . get Superclass ( ) ) { try { Field field = clazz . get Declared Field ( name ) ; if ( ! field . is Accessible ( ) ) { field . set Accessible ( BOOL ) ; } return field ; } catch ( No Such Field Exception e ) { } } throw new No Such Field Exception ( STRING + name + STRING + instance . get Class ( ) ) ; }
static Field find Field ( Object instance , String name ) throws No Such Field Exception { for ( Class < ? > clazz = instance . get Class ( ) ; clazz != null ; clazz = clazz . get Superclass ( ) ) { try { Field field = clazz . get Declared Field ( name ) ; if ( ! field . is Accessible ( ) ) { field . set Accessible ( BOOL ) ; } return field ; } catch ( No Such Field Exception e ) { } } throw new No Such Field Exception ( STRING + name + STRING + instance . get Class ( ) ) ; }
private void check Permissions ( ) { Security Manager sm = System . get Security Manager ( ) ; if ( sm != null ) { Enumeration < Permission > enum = permissions . elements ( ) ; while ( enum . has More Elements ( ) ) { sm . check Permission ( enum . next Element ( ) ) ; } } }
private void save AIS Change ( Session session , Akiban Information Schema new AIS , Collection < String > schemas ) { save AIS Change ( session , new AIS , schemas , Collections . < Integer > empty List ( ) ) ; }
private void save AIS Change ( Session session , Akiban Information Schema new AIS , Collection < String > schemas ) { save AIS Change ( session , new AIS , schemas , Collections . < Integer > empty List ( ) ) ; }
private void save AIS Change ( Session session , Akiban Information Schema new AIS , Collection < String > schemas ) { save AIS Change ( session , new AIS , schemas , Collections . < Integer > empty List ( ) ) ; }
private void save AIS Change ( Session session , Akiban Information Schema new AIS , Collection < String > schemas ) { save AIS Change ( session , new AIS , schemas , Collections . < Integer > empty List ( ) ) ; }
private void save AIS Change ( Session session , Akiban Information Schema new AIS , Collection < String > schemas ) { save AIS Change ( session , new AIS , schemas , Collections . < Integer > empty List ( ) ) ; }
private int determine Max Level ( Phylo Tree tree ) { return determine Max Level Rec ( NUM , tree . get Root ( ) ) ; }
private Pair < Inference Result , Inference Result > infer From Arguments ( final Annotated Type Factory type Factory , final Set < AF Constraint > af Argument Constraints , final Set < Type Variable > targets ) { Set < TU Constraint > tu Arg Constraints = af To Tu Constraints ( af Argument Constraints , targets ) ; add Constraints Between Targets ( tu Arg Constraints , targets , BOOL , type Factory ) ; Constraint Map arg Constraints = constraint Map Builder . build ( targets , tu Arg Constraints , type Factory ) ; Inference Result inferred From Arg Equalities = equalities Solver . solve Equalities ( targets , arg Constraints , type Factory ) ; Set < Type Variable > remaining Targets = inferred From Arg Equalities . get Remaining Targets ( targets , BOOL ) ; Inference Result from Supertypes = supertypes Solver . solve From Supertypes ( remaining Targets , arg Constraints , type Factory ) ; Inference Result from Subtypes = subtypes Solver . solve From Subtypes ( remaining Targets , arg Constraints , type Factory ) ; from Supertypes . merge Subordinate ( from Subtypes ) ; return Pair . of ( inferred From Arg Equalities , from Supertypes ) ; }
private Pair < Inference Result , Inference Result > infer From Arguments ( final Annotated Type Factory type Factory , final Set < AF Constraint > af Argument Constraints , final Set < Type Variable > targets ) { Set < TU Constraint > tu Arg Constraints = af To Tu Constraints ( af Argument Constraints , targets ) ; add Constraints Between Targets ( tu Arg Constraints , targets , BOOL , type Factory ) ; Constraint Map arg Constraints = constraint Map Builder . build ( targets , tu Arg Constraints , type Factory ) ; Inference Result inferred From Arg Equalities = equalities Solver . solve Equalities ( targets , arg Constraints , type Factory ) ; Set < Type Variable > remaining Targets = inferred From Arg Equalities . get Remaining Targets ( targets , BOOL ) ; Inference Result from Supertypes = supertypes Solver . solve From Supertypes ( remaining Targets , arg Constraints , type Factory ) ; Inference Result from Subtypes = subtypes Solver . solve From Subtypes ( remaining Targets , arg Constraints , type Factory ) ; from Supertypes . merge Subordinate ( from Subtypes ) ; return Pair . of ( inferred From Arg Equalities , from Supertypes ) ; }
public void test copy Stream full Block ( ) throws IO Exception { final String id = STRING ; final int version = NUM ; Random r = new Random ( ) ; final byte [ ] expected = new byte [ BLOCK SIZE ] ; r . next Bytes ( expected ) ; assert Equals ( STRING , expected . length , repo . copy Stream ( id , version , new Byte Array Input Stream ( expected ) ) ) ; assert Equals ( STRING , NUM , repo . get Block Count ( id , version ) ) ; assert Same Iterator ( STRING , new Long [ ] { NUM } , repo . blocks ( id , version ) ) ; assert Equals ( STRING , expected , read ( repo . input Stream ( id , version ) ) ) ; }
public void test copy Stream full Block ( ) throws IO Exception { final String id = STRING ; final int version = NUM ; Random r = new Random ( ) ; final byte [ ] expected = new byte [ BLOCK SIZE ] ; r . next Bytes ( expected ) ; assert Equals ( STRING , expected . length , repo . copy Stream ( id , version , new Byte Array Input Stream ( expected ) ) ) ; assert Equals ( STRING , NUM , repo . get Block Count ( id , version ) ) ; assert Same Iterator ( STRING , new Long [ ] { NUM } , repo . blocks ( id , version ) ) ; assert Equals ( STRING , expected , read ( repo . input Stream ( id , version ) ) ) ; }
private void visualize R Tree Entry ( SVG Plot svgp , Element layer , Projection 2 D proj , Abstract R Star Tree < ? extends N , E , ? > rtree , E entry , int depth ) { Spatial Comparable mbr = entry ; if ( settings . fill ) { Element r = SVG Hyper Cube . draw Filled ( svgp , INDEX + depth , proj , mbr ) ; layer . append Child ( r ) ; } else { Element r = SVG Hyper Cube . draw Frame ( svgp , proj , mbr ) ; SVG Util . set CSS Class ( r , INDEX + depth ) ; layer . append Child ( r ) ; } if ( ! entry . is Leaf Entry ( ) ) { N node = rtree . get Node ( entry ) ; for ( int i = NUM ; i < node . get Num Entries ( ) ; i ++ ) { E child = node . get Entry ( i ) ; if ( ! child . is Leaf Entry ( ) ) { visualize R Tree Entry ( svgp , layer , proj , rtree , child , depth + NUM ) ; } } } }
public boolean has Rerolled ( ) { return rerolled ; }
public String add Highlight ( String channel , String comment ) { if ( channel == null || channel . is Empty ( ) || ! Helper . is Regular Channel ( channel ) ) { return STRING ; } Stream Info stream Info = api . get Stream Info ( Helper . to Stream ( channel ) , null ) ; String stream Time = STRING ; if ( stream Info . is Valid ( ) && stream Info . get Online ( ) ) { stream Time = Date Time . ago ( stream Info . get Time Started ( ) ) ; } if ( comment == null ) { comment = STRING ; } String line = String . format ( STRING , Date Time . full Date Time ( ) , channel , stream Time , comment ) ; synchronized ( this ) { if ( stream Info . get Time Started ( ) != last Stream Start Written ) { add To File ( STRING ) ; } boolean success = add To File ( line ) ; if ( success ) { last Stream Start Written = stream Info . get Time Started ( ) ; String short Comment = STRING ; if ( ! comment . is Empty ( ) ) { short Comment = STRING + String Util . shorten To ( comment , NUM ) + STRING ; } return STRING + channel + STRING + stream Time + STRING + short Comment ; } return STRING ; } }
public static long memory Usage Of ( Instrumentation inst , final Object obj ) { return inst . get Object Size ( obj ) ; }
public static long memory Usage Of ( Instrumentation inst , final Object obj ) { return inst . get Object Size ( obj ) ; }
public static long memory Usage Of ( Instrumentation inst , final Object obj ) { return inst . get Object Size ( obj ) ; }
protected void parse And Add Map Tile Set ( URL tile Set Properties ) throws IO Exception , Malformed URL Exception { Properties desc Props = new Properties ( ) ; Logger logger = get Logger ( ) ; logger . info ( STRING ) ; Input Stream desc URL Stream = tile Set Properties . open Stream ( ) ; desc Props . load ( desc URL Stream ) ; logger . info ( STRING + tile Set Properties . to String ( ) + STRING + desc Props . to String ( ) ) ; Map Tile Set mts = create Map Tile Set From Properties ( desc Props ) ; if ( mts != null && mts . all Good ( ) ) { String mts Name = mts . get Name ( ) ; map Tile Sets . put ( mts . get Name ( ) , mts ) ; logger . info ( STRING + mts Name + STRING ) ; } desc URL Stream . close ( ) ; }
public void add Table Value Change Listener ( Table Value Change Listener listener ) { if ( listener == null ) { return ; } m listeners . add ( listener ) ; }
public G Zip Output Stream Random Access ( Output Stream out , int size ) throws IO Exception { super ( out , new Deflater ( Deflater . DEFAULT COMPRESSION , BOOL ) , size , BOOL ) ; write Header ( ) ; crc . reset ( ) ; }
public void start ( long interval , Time Unit unit ) { if ( ! is Valid ( ) ) { return ; } long period = unit . to Millis ( interval ) ; if ( period < NUM ) { return ; } profile Task . stop ( ) ; profile Task . set Period ( period ) ; profile Task . start ( ) ; state = State Profile . ACTIVE ; }
public static String hex ( float f ) { return Integer . to Hex String ( Float . float To Int Bits ( f ) ) ; }
public static String hex ( float f ) { return Integer . to Hex String ( Float . float To Int Bits ( f ) ) ; }
@ Override public synchronized void process Connect ( Web Socket Channel channel , WSURI uri , String [ ] protocols ) { LOG . entering ( CLASS NAME , STRING , new Object [ ] { uri , protocols } ) ; try { Web Socket Native Channel native Channel = ( Web Socket Native Channel ) channel ; if ( native Channel . get Proxy ( ) != null ) { throw new Illegal State Exception ( STRING ) ; } Proxy proxy = Bridge Util . create Proxy ( uri . get URI ( ) , this ) ; proxy . set Peer ( channel ) ; native Channel . set Proxy ( proxy ) ; String [ ] params ; if ( protocols != null ) { String s = STRING ; for ( int i = NUM ; i < protocols . length ; i ++ ) { if ( i > NUM ) { s += STRING ; } s += protocols [ i ] ; } params = new String [ ] { STRING , uri . to String ( ) , s , STRING } ; } else { params = new String [ ] { STRING , uri . to String ( ) } ; } proxy . process Event ( Xoa Event Kind . CREATE , params ) ; } catch ( Exception e ) { LOG . log ( Level . FINE , STRING + e . get Message ( ) , e ) ; listener . connection Failed ( channel , e ) ; } }
private void schedule ( Activity a , long start Time ) { if ( a . is Scheduled ( ) ) { try { notify All ( ) ; } catch ( Exception e ) { } return ; } a . set Start Time ( start Time ) ; synchronized ( this ) { m activities . add ( a ) ; a . set Scheduled ( BOOL ) ; if ( start Time < m next Time ) { m next Time = start Time ; notify ( ) ; } } }
@ Override protected boolean use Teleport Scroll ( final Player player ) { String target Zone Name = null ; int target X = NUM ; int target Y = NUM ; int time In Turns = NUM ; final String info String = get Info String ( ) ; if ( info String != null ) { final String Tokenizer st = new String Tokenizer ( info String ) ; if ( st . count Tokens ( ) == NUM ) { target Zone Name = st . next Token ( ) ; target X = Integer . parse Int ( st . next Token ( ) ) ; target Y = Integer . parse Int ( st . next Token ( ) ) ; time In Turns = Integer . parse Int ( st . next Token ( ) ) ; } else { throw new Illegal Argument Exception ( STRING ) ; } } return use Teleport Scroll ( player , target Zone Name , target X , target Y , time In Turns ) ; }
protected void free Wrapper ( Dock Wrapper w ) { if ( external Frame Wrappers . remove ( w ) ) { w . free Wrapper ( ) ; return ; } if ( internal Frame Wrappers . remove ( w ) ) { w . free Wrapper ( ) ; return ; } if ( north . free Wrapper ( w ) ) { return ; } if ( south . free Wrapper ( w ) ) { return ; } if ( east . free Wrapper ( w ) ) { return ; } if ( west . free Wrapper ( w ) ) { return ; } }
protected void free Wrapper ( Dock Wrapper w ) { if ( external Frame Wrappers . remove ( w ) ) { w . free Wrapper ( ) ; return ; } if ( internal Frame Wrappers . remove ( w ) ) { w . free Wrapper ( ) ; return ; } if ( north . free Wrapper ( w ) ) { return ; } if ( south . free Wrapper ( w ) ) { return ; } if ( east . free Wrapper ( w ) ) { return ; } if ( west . free Wrapper ( w ) ) { return ; } }
public static List < File > walk ( String path ) { Linked List < File > output = new Linked List < File > ( ) ; File root = new File ( path ) ; File [ ] list = root . list Files ( ) ; if ( list == null ) { return output ; } for ( File f : list ) { if ( f . is Directory ( ) ) { output . add All ( walk ( f . get Absolute Path ( ) ) ) ; } else { output . add Last ( f ) ; } } return output ; }
public double distance ( Pla Point Int p to point ) { return Math . sqrt ( distance square ( p to point ) ) ; }
public boolean is Instance Of Followed By Branch ( ) { return instance Of Followed By Branch ; }
public boolean is Instance Of Followed By Branch ( ) { return instance Of Followed By Branch ; }
public boolean is Instance Of Followed By Branch ( ) { return instance Of Followed By Branch ; }
public boolean is Instance Of Followed By Branch ( ) { return instance Of Followed By Branch ; }
public boolean is Instance Of Followed By Branch ( ) { return instance Of Followed By Branch ; }
public void test Encoding Decoding Fullness ( ) { for ( Grid Client Cache Flag f : Grid Client Cache Flag . values ( ) ) { if ( f == KEEP BINARIES ) continue ; int bits = Grid Client Connection . encode Cache Flags ( Collections . singleton ( f ) ) ; assert True ( bits != NUM ) ; boolean out = Grid Cache Command Handler . parse Cache Flags ( bits ) ; assert Equals ( out , BOOL ) ; } }
public void test Encoding Decoding Fullness ( ) { for ( Grid Client Cache Flag f : Grid Client Cache Flag . values ( ) ) { if ( f == KEEP BINARIES ) continue ; int bits = Grid Client Connection . encode Cache Flags ( Collections . singleton ( f ) ) ; assert True ( bits != NUM ) ; boolean out = Grid Cache Command Handler . parse Cache Flags ( bits ) ; assert Equals ( out , BOOL ) ; } }
public boolean is Acquired ( ) { return acquire Count . get ( ) > NUM ; }
String read Startup Command File ( String dir , String fname , String canon Path ) { File dot Init File = new File ( dir , fname ) ; if ( ! dot Init File . exists ( ) ) { return null ; } String my Canon File ; try { my Canon File = dot Init File . get Canonical Path ( ) ; } catch ( IO Exception ee ) { Message Output . println ( STRING , dot Init File . get Path ( ) ) ; return null ; } if ( canon Path == null || ! canon Path . equals ( my Canon File ) ) { if ( ! read Command File ( dot Init File ) ) { Message Output . println ( STRING , dot Init File . get Path ( ) ) ; } } return my Canon File ; }
public Array List < byte [ ] > encode Blinded Items ( ) { Array List < byte [ ] > r = new Array List < byte [ ] > ( blinded Items . size ( ) ) ; for ( Big Integer i : blinded Items ) { r . add ( i . to Byte Array ( ) ) ; } return r ; }
public void pause ( ) { pause Time = System . current Time Millis ( ) ; }
public final void close Fallback Output Stream ( ) throws Data Fallback Exception { if ( output != null ) { if ( LOG . is Debug Enabled ( ) ) LOG . debug ( STRING + data File . get Name ( ) ) ; try { output . close ( ) ; } catch ( IO Exception e ) { throw new Data Fallback Exception ( e . get Message ( ) ) ; } finally { output = null ; } } }
protected void delete Control Action ( int row ) { control List . remove ( row ) ; light Control Table Model . fire Table Data Changed ( ) ; light Control Changed = BOOL ; }
protected void delete Control Action ( int row ) { control List . remove ( row ) ; light Control Table Model . fire Table Data Changed ( ) ; light Control Changed = BOOL ; }
protected abstract Shard Operation Result read Shard Result ( Stream Input in ) throws IO Exception ;
private void merge DRI Node ( Node node ) throws IIO Invalid Tree Exception { DRI Marker Segment dri = ( DRI Marker Segment ) find Marker Segment ( DRI Marker Segment . class , BOOL ) ; if ( dri != null ) { dri . update From Native Node ( node , BOOL ) ; } else { DRI Marker Segment new Guy = new DRI Marker Segment ( node ) ; int first SOF = find Marker Segment Position ( SOF Marker Segment . class , BOOL ) ; int first SOS = find Marker Segment Position ( SOS Marker Segment . class , BOOL ) ; if ( first SOF != - NUM ) { marker Sequence . add ( first SOF , new Guy ) ; } else if ( first SOS != - NUM ) { marker Sequence . add ( first SOS , new Guy ) ; } else { marker Sequence . add ( new Guy ) ; } } }
private void merge DRI Node ( Node node ) throws IIO Invalid Tree Exception { DRI Marker Segment dri = ( DRI Marker Segment ) find Marker Segment ( DRI Marker Segment . class , BOOL ) ; if ( dri != null ) { dri . update From Native Node ( node , BOOL ) ; } else { DRI Marker Segment new Guy = new DRI Marker Segment ( node ) ; int first SOF = find Marker Segment Position ( SOF Marker Segment . class , BOOL ) ; int first SOS = find Marker Segment Position ( SOS Marker Segment . class , BOOL ) ; if ( first SOF != - NUM ) { marker Sequence . add ( first SOF , new Guy ) ; } else if ( first SOS != - NUM ) { marker Sequence . add ( first SOS , new Guy ) ; } else { marker Sequence . add ( new Guy ) ; } } }
private void merge DRI Node ( Node node ) throws IIO Invalid Tree Exception { DRI Marker Segment dri = ( DRI Marker Segment ) find Marker Segment ( DRI Marker Segment . class , BOOL ) ; if ( dri != null ) { dri . update From Native Node ( node , BOOL ) ; } else { DRI Marker Segment new Guy = new DRI Marker Segment ( node ) ; int first SOF = find Marker Segment Position ( SOF Marker Segment . class , BOOL ) ; int first SOS = find Marker Segment Position ( SOS Marker Segment . class , BOOL ) ; if ( first SOF != - NUM ) { marker Sequence . add ( first SOF , new Guy ) ; } else if ( first SOS != - NUM ) { marker Sequence . add ( first SOS , new Guy ) ; } else { marker Sequence . add ( new Guy ) ; } } }
void after Write ( Runnable task ) { write Buffer . add ( task ) ; drain Status . lazy Set ( REQUIRED ) ; try To Drain Buffers ( ) ; notify Listener ( ) ; }
public void render ( Graphics graphics ) { if ( get Need To Regenerate ( ) || get Need To Reposition ( ) || ! is Visible ( ) ) { if ( DEBUG ) { logger . fine ( STRING ) ; } return ; } Graphics g = graphics . create ( ) ; if ( color Model == COLORMODEL IMAGEICON && ( get Width ( ) == - NUM ) ) { logger . fine ( STRING ) ; } if ( g instanceof Graphics 2 D && render Rotation Angle != null ) { rotate ( ( Graphics 2 D ) g ) ; } render Image ( g , bitmap , point 1 ) ; if ( is Selected ( ) || logger . is Loggable ( Level . FINER ) ) { render Shape ( g ) ; } render Label ( graphics ) ; }
public void test When Complete source Completed Normally Action Failed ( ) { for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) for ( Execution Mode m : Execution Mode . values ( ) ) for ( Integer v1 : new Integer [ ] { NUM , null } ) { final Atomic Integer a = new Atomic Integer ( NUM ) ; final CF Exception ex = new CF Exception ( ) ; final Completable Future < Integer > f = new Completable Future < > ( ) ; if ( ! create Incomplete ) assert True ( f . complete ( v1 ) ) ; final Completable Future < Integer > g = m . when Complete ( f , null ) ; if ( create Incomplete ) assert True ( f . complete ( v1 ) ) ; check Completed With Wrapped Exception ( g , ex ) ; check Completed Normally ( f , v1 ) ; assert Equals ( NUM , a . get ( ) ) ; } }
public void test When Complete source Completed Normally Action Failed ( ) { for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) for ( Execution Mode m : Execution Mode . values ( ) ) for ( Integer v1 : new Integer [ ] { NUM , null } ) { final Atomic Integer a = new Atomic Integer ( NUM ) ; final CF Exception ex = new CF Exception ( ) ; final Completable Future < Integer > f = new Completable Future < > ( ) ; if ( ! create Incomplete ) assert True ( f . complete ( v1 ) ) ; final Completable Future < Integer > g = m . when Complete ( f , null ) ; if ( create Incomplete ) assert True ( f . complete ( v1 ) ) ; check Completed With Wrapped Exception ( g , ex ) ; check Completed Normally ( f , v1 ) ; assert Equals ( NUM , a . get ( ) ) ; } }
public void test When Complete source Completed Normally Action Failed ( ) { for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) for ( Execution Mode m : Execution Mode . values ( ) ) for ( Integer v1 : new Integer [ ] { NUM , null } ) { final Atomic Integer a = new Atomic Integer ( NUM ) ; final CF Exception ex = new CF Exception ( ) ; final Completable Future < Integer > f = new Completable Future < > ( ) ; if ( ! create Incomplete ) assert True ( f . complete ( v1 ) ) ; final Completable Future < Integer > g = m . when Complete ( f , null ) ; if ( create Incomplete ) assert True ( f . complete ( v1 ) ) ; check Completed With Wrapped Exception ( g , ex ) ; check Completed Normally ( f , v1 ) ; assert Equals ( NUM , a . get ( ) ) ; } }
public void test When Complete source Completed Normally Action Failed ( ) { for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) for ( Execution Mode m : Execution Mode . values ( ) ) for ( Integer v1 : new Integer [ ] { NUM , null } ) { final Atomic Integer a = new Atomic Integer ( NUM ) ; final CF Exception ex = new CF Exception ( ) ; final Completable Future < Integer > f = new Completable Future < > ( ) ; if ( ! create Incomplete ) assert True ( f . complete ( v1 ) ) ; final Completable Future < Integer > g = m . when Complete ( f , null ) ; if ( create Incomplete ) assert True ( f . complete ( v1 ) ) ; check Completed With Wrapped Exception ( g , ex ) ; check Completed Normally ( f , v1 ) ; assert Equals ( NUM , a . get ( ) ) ; } }
public void show Empty ( Drawable empty Image Drawable , String empty Text Title , String empty Text Content ) { switch State ( EMPTY , empty Image Drawable , empty Text Title , empty Text Content , null , null , Collections . < Integer > empty List ( ) ) ; }
private boolean remove Task ( Task t , int min ) { for ( int i = tasks . size ( ) ; -- i >= min ; ) { if ( tasks . get ( i ) == t ) { tasks . remove ( i ) ; if ( i < first Pending ) { first Pending -- ; for ( int j = threads . size ( ) ; -- j >= NUM ; ) { Task Thread thread = threads . get ( j ) ; if ( thread . task == t ) { if ( thread != Thread . current Thread ( ) ) thread . interrupt ( ) ; break ; } } } return BOOL ; } } return BOOL ; }
private boolean remove Task ( Task t , int min ) { for ( int i = tasks . size ( ) ; -- i >= min ; ) { if ( tasks . get ( i ) == t ) { tasks . remove ( i ) ; if ( i < first Pending ) { first Pending -- ; for ( int j = threads . size ( ) ; -- j >= NUM ; ) { Task Thread thread = threads . get ( j ) ; if ( thread . task == t ) { if ( thread != Thread . current Thread ( ) ) thread . interrupt ( ) ; break ; } } } return BOOL ; } } return BOOL ; }
private void read Object ( final java . io . Object Input Stream in ) throws IO Exception , Class Not Found Exception { time Stamp = in . read Long ( ) ; duration = in . read Long ( ) ; }
public static Snmp Engine Id create Engine Id ( int port , int iana ) throws Unknown Host Exception { Inet Address address = null ; address = Inet Address . get Local Host ( ) ; return create Engine Id ( address , port , iana ) ; }
public static Snmp Engine Id create Engine Id ( int port , int iana ) throws Unknown Host Exception { Inet Address address = null ; address = Inet Address . get Local Host ( ) ; return create Engine Id ( address , port , iana ) ; }
public static Snmp Engine Id create Engine Id ( int port , int iana ) throws Unknown Host Exception { Inet Address address = null ; address = Inet Address . get Local Host ( ) ; return create Engine Id ( address , port , iana ) ; }
public static byte [ ] hash ( byte [ ] data ) { try { Message Digest md = Message Digest . get Instance ( STRING ) ; md . update ( data ) ; return md . digest ( ) ; } catch ( Exception e ) { throw new Runtime Exception ( STRING + e . get Message ( ) , e ) ; } }
public Properties to Properties ( ) { Properties properties = new Properties ( ) ; properties . set Property ( STRING , rack ) ; properties . set Property ( STRING , data Center ) ; return properties ; }
public Properties to Properties ( ) { Properties properties = new Properties ( ) ; properties . set Property ( STRING , rack ) ; properties . set Property ( STRING , data Center ) ; return properties ; }
public Properties to Properties ( ) { Properties properties = new Properties ( ) ; properties . set Property ( STRING , rack ) ; properties . set Property ( STRING , data Center ) ; return properties ; }
private void save Properties ( ) { if ( is Data Valid ( ) ) { control . set Track Slider ( track Box . is Selected ( ) ) ; control . set Switch Slider Function ( function Switch Slider . get Text ( ) ) ; control . set Speed Controller ( display Slider ) ; finish Edit ( ) ; } }
public static String to Full Class Name ( String symbolic Name ) { if ( uri To Class Name Map . contains Key ( symbolic Name ) ) return uri To Class Name Map . get ( symbolic Name ) ; return symbolic Name . replace ( STRING , STRING ) ; }
public static String to Full Class Name ( String symbolic Name ) { if ( uri To Class Name Map . contains Key ( symbolic Name ) ) return uri To Class Name Map . get ( symbolic Name ) ; return symbolic Name . replace ( STRING , STRING ) ; }
private < S , T > Set < T > extract ( final Collection < S > collection , final Extractor < S , T > extractor ) { final Set < T > values = new Hash Set < T > ( collection . size ( ) ) ; for ( final S instance : collection ) { values . add ( extractor . get Value ( instance ) ) ; } return values ; }
private < S , T > Set < T > extract ( final Collection < S > collection , final Extractor < S , T > extractor ) { final Set < T > values = new Hash Set < T > ( collection . size ( ) ) ; for ( final S instance : collection ) { values . add ( extractor . get Value ( instance ) ) ; } return values ; }
abstract void start Poll ( int fd , int events ) ;
abstract void start Poll ( int fd , int events ) ;
abstract void start Poll ( int fd , int events ) ;
abstract void start Poll ( int fd , int events ) ;
abstract void start Poll ( int fd , int events ) ;
private Signed Requests Helper ( ) { }
private Signed Requests Helper ( ) { }
public void clear ( ) { fully Lock ( ) ; try { for ( Node < E > p , h = head ; ( p = h . next ) != null ; h = p ) { h . next = h ; p . item = null ; } head = last ; if ( count . get And Set ( NUM ) >= capacity ) not Full . signal ( ) ; } finally { fully Unlock ( ) ; } }
public void clear ( ) { fully Lock ( ) ; try { for ( Node < E > p , h = head ; ( p = h . next ) != null ; h = p ) { h . next = h ; p . item = null ; } head = last ; if ( count . get And Set ( NUM ) >= capacity ) not Full . signal ( ) ; } finally { fully Unlock ( ) ; } }
public static My SQL Packet read Packet ( Input Stream in ) { return read Packet ( in , NUM ) ; }
public static My SQL Packet read Packet ( Input Stream in ) { return read Packet ( in , NUM ) ; }
void enter Field ( ) { old Contents = val . get Text ( ) ; }
public static OM Grid read ( Data Input Stream dis ) throws IO Exception { return read ( dis , null ) ; }
public static OM Grid read ( Data Input Stream dis ) throws IO Exception { return read ( dis , null ) ; }
public static OM Grid read ( Data Input Stream dis ) throws IO Exception { return read ( dis , null ) ; }
public final void test Set Seedbyte Array 02 ( ) throws No Such Field Exception , Security Exception , Illegal Access Exception { byte [ ] seed = new byte [ LENGTH ] ; byte [ ] bytes 1 = new byte [ LENGTH ] ; byte [ ] bytes 2 = new byte [ LENGTH ] ; boolean b ; for ( int i = NUM ; i < seed . length ; i ++ ) { seed [ i ] = ( byte ) i ; } sr . set Seed ( seed ) ; sr . set Seed ( seed ) ; sr 2 . set Seed ( seed ) ; sr . next Bytes ( bytes 1 ) ; sr 2 . next Bytes ( bytes 2 ) ; b = BOOL ; for ( int j = NUM ; j < bytes 1 . length ; j ++ ) { b &= bytes 1 [ j ] == bytes 2 [ j ] ; } assert False ( STRING , b ) ; }
public final void test Set Seedbyte Array 02 ( ) throws No Such Field Exception , Security Exception , Illegal Access Exception { byte [ ] seed = new byte [ LENGTH ] ; byte [ ] bytes 1 = new byte [ LENGTH ] ; byte [ ] bytes 2 = new byte [ LENGTH ] ; boolean b ; for ( int i = NUM ; i < seed . length ; i ++ ) { seed [ i ] = ( byte ) i ; } sr . set Seed ( seed ) ; sr . set Seed ( seed ) ; sr 2 . set Seed ( seed ) ; sr . next Bytes ( bytes 1 ) ; sr 2 . next Bytes ( bytes 2 ) ; b = BOOL ; for ( int j = NUM ; j < bytes 1 . length ; j ++ ) { b &= bytes 1 [ j ] == bytes 2 [ j ] ; } assert False ( STRING , b ) ; }
public final void test Set Seedbyte Array 02 ( ) throws No Such Field Exception , Security Exception , Illegal Access Exception { byte [ ] seed = new byte [ LENGTH ] ; byte [ ] bytes 1 = new byte [ LENGTH ] ; byte [ ] bytes 2 = new byte [ LENGTH ] ; boolean b ; for ( int i = NUM ; i < seed . length ; i ++ ) { seed [ i ] = ( byte ) i ; } sr . set Seed ( seed ) ; sr . set Seed ( seed ) ; sr 2 . set Seed ( seed ) ; sr . next Bytes ( bytes 1 ) ; sr 2 . next Bytes ( bytes 2 ) ; b = BOOL ; for ( int j = NUM ; j < bytes 1 . length ; j ++ ) { b &= bytes 1 [ j ] == bytes 2 [ j ] ; } assert False ( STRING , b ) ; }
public final void test Set Seedbyte Array 02 ( ) throws No Such Field Exception , Security Exception , Illegal Access Exception { byte [ ] seed = new byte [ LENGTH ] ; byte [ ] bytes 1 = new byte [ LENGTH ] ; byte [ ] bytes 2 = new byte [ LENGTH ] ; boolean b ; for ( int i = NUM ; i < seed . length ; i ++ ) { seed [ i ] = ( byte ) i ; } sr . set Seed ( seed ) ; sr . set Seed ( seed ) ; sr 2 . set Seed ( seed ) ; sr . next Bytes ( bytes 1 ) ; sr 2 . next Bytes ( bytes 2 ) ; b = BOOL ; for ( int j = NUM ; j < bytes 1 . length ; j ++ ) { b &= bytes 1 [ j ] == bytes 2 [ j ] ; } assert False ( STRING , b ) ; }
private String contact ( Context context , Easy Cursor c ) { String contact = c . get String ( aliased ( Syncs Join All . CONTACT NAME ) ) ; if ( contact == null ) { contact = context . get String ( R . string . non contact ) ; } return contact ; }
public boolean is Trivial ( Integer complexity ) { int len = payload . length ; if ( ( null == complexity ) || ( len < NUM ) ) { return BOOL ; } else if ( ( complexity . int Value ( ) > NUM ) && ( len > NUM ) ) { Set < Character > seen = new Tree Set < Character > ( ) ; for ( int i = NUM ; i < len ; i ++ ) { Character c = Character . value Of ( this . payload [ i ] ) ; if ( seen . contains ( c ) ) { continue ; } else { seen . add ( c ) ; } } if ( complexity . int Value ( ) <= seen . size ( ) ) { return BOOL ; } } return BOOL ; }
@ Override public void process ( Number tuple ) { num List . add ( tuple ) ; }
public void register ( String key , Remote value ) throws Registry Exception { try { registry . rebind ( key , value ) ; } catch ( Exception e ) { throw new Registry Exception ( STRING + key + STRING , e ) ; } }
public static String print Code Point As String ( int code Point ) { String Builder builder = new String Builder ( NUM ) ; builder . append ( STRING ) ; try { print String Code Point ( builder , code Point ) ; } catch ( IO Exception e ) { throw new Error ( e ) ; } builder . append ( STRING ) ; return builder . to String ( ) ; }
public static String print Code Point As String ( int code Point ) { String Builder builder = new String Builder ( NUM ) ; builder . append ( STRING ) ; try { print String Code Point ( builder , code Point ) ; } catch ( IO Exception e ) { throw new Error ( e ) ; } builder . append ( STRING ) ; return builder . to String ( ) ; }
public static String print Code Point As String ( int code Point ) { String Builder builder = new String Builder ( NUM ) ; builder . append ( STRING ) ; try { print String Code Point ( builder , code Point ) ; } catch ( IO Exception e ) { throw new Error ( e ) ; } builder . append ( STRING ) ; return builder . to String ( ) ; }
@ Override protected void delete Behind ( final int n , final Iterator < byte [ ] > keys ) { final Lock lock = write Lock ( ) ; lock . lock ( ) ; try { super . delete Behind ( n , keys ) ; } finally { unlock ( lock ) ; } }
@ Override protected void delete Behind ( final int n , final Iterator < byte [ ] > keys ) { final Lock lock = write Lock ( ) ; lock . lock ( ) ; try { super . delete Behind ( n , keys ) ; } finally { unlock ( lock ) ; } }
private static boolean check Name ( Editable Resources r , String name ) { for ( String n : r . get Resource Names ( ) ) { if ( n . equals ( name ) ) { return BOOL ; } } return BOOL ; }
private static boolean check Name ( Editable Resources r , String name ) { for ( String n : r . get Resource Names ( ) ) { if ( n . equals ( name ) ) { return BOOL ; } } return BOOL ; }
private static boolean check Name ( Editable Resources r , String name ) { for ( String n : r . get Resource Names ( ) ) { if ( n . equals ( name ) ) { return BOOL ; } } return BOOL ; }
public Bloom Filter ( byte [ ] data , int entries , double error ) throws Runtime Exception { if ( entries < NUM || ( ( NUM <= error ) || ( error <= error Precision ) ) ) { throw new Runtime Exception ( STRING ) ; } this . entries = entries ; this . error = error ; bpe = - ( Math . log ( error ) / denom ) ; bits = ( int ) ( ( double ) entries * bpe ) ; bytes = ( bits / NUM ) + ( bits % NUM != NUM ? NUM : NUM ) ; if ( data != null ) { if ( bytes != data . length ) { throw new Runtime Exception ( String . format ( STRING , bytes , data . length ) ) ; } bf = data ; } else { bf = new byte [ bytes ] ; ; } hashes = ( int ) Math . ceil ( NUM * bpe ) ; }
public Bloom Filter ( byte [ ] data , int entries , double error ) throws Runtime Exception { if ( entries < NUM || ( ( NUM <= error ) || ( error <= error Precision ) ) ) { throw new Runtime Exception ( STRING ) ; } this . entries = entries ; this . error = error ; bpe = - ( Math . log ( error ) / denom ) ; bits = ( int ) ( ( double ) entries * bpe ) ; bytes = ( bits / NUM ) + ( bits % NUM != NUM ? NUM : NUM ) ; if ( data != null ) { if ( bytes != data . length ) { throw new Runtime Exception ( String . format ( STRING , bytes , data . length ) ) ; } bf = data ; } else { bf = new byte [ bytes ] ; ; } hashes = ( int ) Math . ceil ( NUM * bpe ) ; }
public Bloom Filter ( byte [ ] data , int entries , double error ) throws Runtime Exception { if ( entries < NUM || ( ( NUM <= error ) || ( error <= error Precision ) ) ) { throw new Runtime Exception ( STRING ) ; } this . entries = entries ; this . error = error ; bpe = - ( Math . log ( error ) / denom ) ; bits = ( int ) ( ( double ) entries * bpe ) ; bytes = ( bits / NUM ) + ( bits % NUM != NUM ? NUM : NUM ) ; if ( data != null ) { if ( bytes != data . length ) { throw new Runtime Exception ( String . format ( STRING , bytes , data . length ) ) ; } bf = data ; } else { bf = new byte [ bytes ] ; ; } hashes = ( int ) Math . ceil ( NUM * bpe ) ; }
public Bloom Filter ( byte [ ] data , int entries , double error ) throws Runtime Exception { if ( entries < NUM || ( ( NUM <= error ) || ( error <= error Precision ) ) ) { throw new Runtime Exception ( STRING ) ; } this . entries = entries ; this . error = error ; bpe = - ( Math . log ( error ) / denom ) ; bits = ( int ) ( ( double ) entries * bpe ) ; bytes = ( bits / NUM ) + ( bits % NUM != NUM ? NUM : NUM ) ; if ( data != null ) { if ( bytes != data . length ) { throw new Runtime Exception ( String . format ( STRING , bytes , data . length ) ) ; } bf = data ; } else { bf = new byte [ bytes ] ; ; } hashes = ( int ) Math . ceil ( NUM * bpe ) ; }
public Bloom Filter ( byte [ ] data , int entries , double error ) throws Runtime Exception { if ( entries < NUM || ( ( NUM <= error ) || ( error <= error Precision ) ) ) { throw new Runtime Exception ( STRING ) ; } this . entries = entries ; this . error = error ; bpe = - ( Math . log ( error ) / denom ) ; bits = ( int ) ( ( double ) entries * bpe ) ; bytes = ( bits / NUM ) + ( bits % NUM != NUM ? NUM : NUM ) ; if ( data != null ) { if ( bytes != data . length ) { throw new Runtime Exception ( String . format ( STRING , bytes , data . length ) ) ; } bf = data ; } else { bf = new byte [ bytes ] ; ; } hashes = ( int ) Math . ceil ( NUM * bpe ) ; }
private Jar Service Provider ( ) { }
private Jar Service Provider ( ) { }
public void add Child ( Accessibility Node Info child ) { if ( m Children == null ) { m Children = new Linked List < > ( ) ; } m Children . add ( child ) ; ( ( Shadow Accessibility Node Info ) Shadow Extractor . extract ( child ) ) . m Parent = m Real Accessibility Node Info ; }
protected void print Indent ( String Builder ddl ) { ddl . append ( get Indent ( ) ) ; }
protected void print Indent ( String Builder ddl ) { ddl . append ( get Indent ( ) ) ; }
private Map < String , Object > parse ( Json json ) { return json . as Map ( ) ; }
public void add Load Constant ( int k ) { switch ( k ) { case NUM : add ( Byte Code . ICONST 0 ) ; break ; case NUM : add ( Byte Code . ICONST 1 ) ; break ; case NUM : add ( Byte Code . ICONST 2 ) ; break ; case NUM : add ( Byte Code . ICONST 3 ) ; break ; case NUM : add ( Byte Code . ICONST 4 ) ; break ; case NUM : add ( Byte Code . ICONST 5 ) ; break ; default : add ( Byte Code . LDC , its Constant Pool . add Constant ( k ) ) ; break ; } }
private boolean should Append Charset Param ( String ... property Value List ) { if ( ! m Should Append Charset Param ) { return BOOL ; } for ( String property Value : property Value List ) { if ( ! V Card Utils . contains Only Printable Ascii ( property Value ) ) { return BOOL ; } } return BOOL ; }
private boolean should Append Charset Param ( String ... property Value List ) { if ( ! m Should Append Charset Param ) { return BOOL ; } for ( String property Value : property Value List ) { if ( ! V Card Utils . contains Only Printable Ascii ( property Value ) ) { return BOOL ; } } return BOOL ; }
private boolean should Append Charset Param ( String ... property Value List ) { if ( ! m Should Append Charset Param ) { return BOOL ; } for ( String property Value : property Value List ) { if ( ! V Card Utils . contains Only Printable Ascii ( property Value ) ) { return BOOL ; } } return BOOL ; }
private boolean should Append Charset Param ( String ... property Value List ) { if ( ! m Should Append Charset Param ) { return BOOL ; } for ( String property Value : property Value List ) { if ( ! V Card Utils . contains Only Printable Ascii ( property Value ) ) { return BOOL ; } } return BOOL ; }
private boolean should Append Charset Param ( String ... property Value List ) { if ( ! m Should Append Charset Param ) { return BOOL ; } for ( String property Value : property Value List ) { if ( ! V Card Utils . contains Only Printable Ascii ( property Value ) ) { return BOOL ; } } return BOOL ; }
private boolean should Append Charset Param ( String ... property Value List ) { if ( ! m Should Append Charset Param ) { return BOOL ; } for ( String property Value : property Value List ) { if ( ! V Card Utils . contains Only Printable Ascii ( property Value ) ) { return BOOL ; } } return BOOL ; }
private boolean should Append Charset Param ( String ... property Value List ) { if ( ! m Should Append Charset Param ) { return BOOL ; } for ( String property Value : property Value List ) { if ( ! V Card Utils . contains Only Printable Ascii ( property Value ) ) { return BOOL ; } } return BOOL ; }
private boolean should Append Charset Param ( String ... property Value List ) { if ( ! m Should Append Charset Param ) { return BOOL ; } for ( String property Value : property Value List ) { if ( ! V Card Utils . contains Only Printable Ascii ( property Value ) ) { return BOOL ; } } return BOOL ; }
private boolean should Append Charset Param ( String ... property Value List ) { if ( ! m Should Append Charset Param ) { return BOOL ; } for ( String property Value : property Value List ) { if ( ! V Card Utils . contains Only Printable Ascii ( property Value ) ) { return BOOL ; } } return BOOL ; }
private boolean should Append Charset Param ( String ... property Value List ) { if ( ! m Should Append Charset Param ) { return BOOL ; } for ( String property Value : property Value List ) { if ( ! V Card Utils . contains Only Printable Ascii ( property Value ) ) { return BOOL ; } } return BOOL ; }
private boolean should Append Charset Param ( String ... property Value List ) { if ( ! m Should Append Charset Param ) { return BOOL ; } for ( String property Value : property Value List ) { if ( ! V Card Utils . contains Only Printable Ascii ( property Value ) ) { return BOOL ; } } return BOOL ; }
private boolean should Append Charset Param ( String ... property Value List ) { if ( ! m Should Append Charset Param ) { return BOOL ; } for ( String property Value : property Value List ) { if ( ! V Card Utils . contains Only Printable Ascii ( property Value ) ) { return BOOL ; } } return BOOL ; }
private boolean should Append Charset Param ( String ... property Value List ) { if ( ! m Should Append Charset Param ) { return BOOL ; } for ( String property Value : property Value List ) { if ( ! V Card Utils . contains Only Printable Ascii ( property Value ) ) { return BOOL ; } } return BOOL ; }
public void encode ( Der Output Stream out ) throws IO Exception { if ( extension Id == null ) throw new IO Exception ( STRING ) ; if ( extension Value == null ) throw new IO Exception ( STRING ) ; Der Output Stream dos = new Der Output Stream ( ) ; dos . put OID ( extension Id ) ; if ( critical ) dos . put Boolean ( critical ) ; dos . put Octet String ( extension Value ) ; out . write ( Der Value . tag Sequence , dos ) ; }
private static Map < String , String > extract Key Value Pairs ( String props , Object Name mbean ) { Map < String , String > map = new Linked Hash Map < String , String > ( ) ; int eq = props . index Of ( STRING ) ; while ( eq != - NUM ) { String key = props . substring ( NUM , eq ) ; String value = mbean . get Key Property ( key ) ; map . put ( key , value ) ; props = props . substring ( key . length ( ) + NUM + value . length ( ) ) ; if ( props . starts With ( STRING ) ) { props = props . substring ( NUM ) ; } eq = props . index Of ( STRING ) ; } return map ; }
private static Map < String , String > extract Key Value Pairs ( String props , Object Name mbean ) { Map < String , String > map = new Linked Hash Map < String , String > ( ) ; int eq = props . index Of ( STRING ) ; while ( eq != - NUM ) { String key = props . substring ( NUM , eq ) ; String value = mbean . get Key Property ( key ) ; map . put ( key , value ) ; props = props . substring ( key . length ( ) + NUM + value . length ( ) ) ; if ( props . starts With ( STRING ) ) { props = props . substring ( NUM ) ; } eq = props . index Of ( STRING ) ; } return map ; }
public void add Split Edges ( List edge List ) { add Endpoints ( ) ; Iterator it = iterator ( ) ; Edge Intersection ei Prev = ( Edge Intersection ) it . next ( ) ; while ( it . has Next ( ) ) { Edge Intersection ei = ( Edge Intersection ) it . next ( ) ; Edge new Edge = create Split Edge ( ei Prev , ei ) ; edge List . add ( new Edge ) ; ei Prev = ei ; } }
public void add Split Edges ( List edge List ) { add Endpoints ( ) ; Iterator it = iterator ( ) ; Edge Intersection ei Prev = ( Edge Intersection ) it . next ( ) ; while ( it . has Next ( ) ) { Edge Intersection ei = ( Edge Intersection ) it . next ( ) ; Edge new Edge = create Split Edge ( ei Prev , ei ) ; edge List . add ( new Edge ) ; ei Prev = ei ; } }
public void add Split Edges ( List edge List ) { add Endpoints ( ) ; Iterator it = iterator ( ) ; Edge Intersection ei Prev = ( Edge Intersection ) it . next ( ) ; while ( it . has Next ( ) ) { Edge Intersection ei = ( Edge Intersection ) it . next ( ) ; Edge new Edge = create Split Edge ( ei Prev , ei ) ; edge List . add ( new Edge ) ; ei Prev = ei ; } }
public void add Split Edges ( List edge List ) { add Endpoints ( ) ; Iterator it = iterator ( ) ; Edge Intersection ei Prev = ( Edge Intersection ) it . next ( ) ; while ( it . has Next ( ) ) { Edge Intersection ei = ( Edge Intersection ) it . next ( ) ; Edge new Edge = create Split Edge ( ei Prev , ei ) ; edge List . add ( new Edge ) ; ei Prev = ei ; } }
public void add Split Edges ( List edge List ) { add Endpoints ( ) ; Iterator it = iterator ( ) ; Edge Intersection ei Prev = ( Edge Intersection ) it . next ( ) ; while ( it . has Next ( ) ) { Edge Intersection ei = ( Edge Intersection ) it . next ( ) ; Edge new Edge = create Split Edge ( ei Prev , ei ) ; edge List . add ( new Edge ) ; ei Prev = ei ; } }
public void add Split Edges ( List edge List ) { add Endpoints ( ) ; Iterator it = iterator ( ) ; Edge Intersection ei Prev = ( Edge Intersection ) it . next ( ) ; while ( it . has Next ( ) ) { Edge Intersection ei = ( Edge Intersection ) it . next ( ) ; Edge new Edge = create Split Edge ( ei Prev , ei ) ; edge List . add ( new Edge ) ; ei Prev = ei ; } }
public static boolean save Bitmap To File ( Bitmap bitmap , String path ) { File file = new File ( path ) ; File Output Stream f Out ; try { f Out = new File Output Stream ( file ) ; bitmap . compress ( Bitmap . Compress Format . JPEG , NUM , f Out ) ; f Out . flush ( ) ; f Out . close ( ) ; return BOOL ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } return BOOL ; }
public static boolean save Bitmap To File ( Bitmap bitmap , String path ) { File file = new File ( path ) ; File Output Stream f Out ; try { f Out = new File Output Stream ( file ) ; bitmap . compress ( Bitmap . Compress Format . JPEG , NUM , f Out ) ; f Out . flush ( ) ; f Out . close ( ) ; return BOOL ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } return BOOL ; }
public static String to String ( Collection < ? > collection , String separator ) { boolean first = BOOL ; String Builder b = new String Builder ( ) ; for ( Object o : collection ) { if ( first ) { first = BOOL ; } else { b . append ( separator ) ; } b . append ( o ) ; } return b . to String ( ) ; }
void new Equation ( DF Lattice Cell lhs , DF Operator operator , DF Lattice Cell op 1 , DF Lattice Cell op 2 , DF Lattice Cell op 3 ) { DF Equation eq = new DF Equation ( lhs , operator , op 1 , op 2 , op 3 ) ; equations . add Graph Node ( eq ) ; equations . add Graph Node ( lhs ) ; equations . add Graph Node ( op 1 ) ; equations . add Graph Node ( op 2 ) ; equations . add Graph Node ( op 3 ) ; new Equations . add ( eq ) ; op 1 . add Use ( eq ) ; op 2 . add Use ( eq ) ; op 3 . add Use ( eq ) ; lhs . add Def ( eq ) ; if ( EAGER && eq . evaluate ( ) ) changed Cell ( lhs ) ; }
static public Iso 639 find ( String lang ) { Iso 639 rslt = ( Iso 639 ) all . get ( lang ) ; if ( rslt == null ) { if ( lang != null && lang . compare To ( STRING ) >= NUM && lang . compare To ( STRING ) <= NUM && lang . length ( ) == NUM ) { return new Iso 639 ( STRING , null , lang , lang , LT LOCAL USE ) ; } } return rslt ; }
private double calc Util 4 Performing ( final double typ Duration , final double actual Duration ) { return NUM * marginal Util Performing Sec + marginal Util Performing Sec * typ Duration * Math . log ( actual Duration / typ Duration ) ; }
private double calc Util 4 Performing ( final double typ Duration , final double actual Duration ) { return NUM * marginal Util Performing Sec + marginal Util Performing Sec * typ Duration * Math . log ( actual Duration / typ Duration ) ; }
protected boolean is Transaction In Advance Of Installment ( final int current Installment Index , final List < Loan Repayment Schedule Installment > installments , final Local Date transaction Date , @ Suppress Warnings ( STRING ) final Money transaction Amount ) { final Loan Repayment Schedule Installment current Installment = installments . get ( current Installment Index ) ; return transaction Date . is Before ( current Installment . get Due Date ( ) ) ; }
public void insert Sleep Time ( ) { Script Step sleep Time Script Step = Script Step Factory . create Sleep Time ( get Sleep Time ( ) ) ; steps . add ( get Insert Index ( ) , sleep Time Script Step ) ; sleep Time = STRING ; reindex Script Steps ( ) ; }
public int size ( ) { return children . size ( ) ; }
Saml Federation Handler ( Map < String , String > attribute Mapping , String subject Mapping , String authn Context Delimiter , String authn Context , String session Index Mapping , String redirect URI , String logout URI , String assertion Consumer Endpoint , String s Pinitiated SSO Endpoint , String single Logout Endpoint , String single Logout Endpoint Soap , String s Pinitiated SLO Endpoint ) { this . attribute Mapping = Collections . unmodifiable Map ( attribute Mapping ) ; this . subject Mapping = subject Mapping ; this . authn Context Delimiter = authn Context Delimiter ; this . authn Context = authn Context ; this . session Index Mapping = session Index Mapping ; this . redirect URI = redirect URI ; this . logout URI = logout URI ; this . assertion Consumer Endpoint = assertion Consumer Endpoint ; this . s Pinitiated SSO Endpoint = s Pinitiated SSO Endpoint ; this . single Logout Endpoint = single Logout Endpoint ; this . single Logout Endpoint Soap = single Logout Endpoint Soap ; this . s Pinitiated SLO Endpoint = s Pinitiated SLO Endpoint ; }
@ Override public void incoming Object ( I Analyzed Interval analyzed Interval ) throws Ade Exception { if ( ! m percentiles With Empty Intervals && analyzed Interval . get Num Unique Message Ids ( ) == NUM ) { return ; } final double raw Score = calc Raw Score ( analyzed Interval ) ; if ( ! Seen Huge Log Prob ( analyzed Interval ) ) { m raw Scores . add ( raw Score ) ; ++ m interval Count ; } }
@ Override public void incoming Object ( I Analyzed Interval analyzed Interval ) throws Ade Exception { if ( ! m percentiles With Empty Intervals && analyzed Interval . get Num Unique Message Ids ( ) == NUM ) { return ; } final double raw Score = calc Raw Score ( analyzed Interval ) ; if ( ! Seen Huge Log Prob ( analyzed Interval ) ) { m raw Scores . add ( raw Score ) ; ++ m interval Count ; } }
@ Override public void incoming Object ( I Analyzed Interval analyzed Interval ) throws Ade Exception { if ( ! m percentiles With Empty Intervals && analyzed Interval . get Num Unique Message Ids ( ) == NUM ) { return ; } final double raw Score = calc Raw Score ( analyzed Interval ) ; if ( ! Seen Huge Log Prob ( analyzed Interval ) ) { m raw Scores . add ( raw Score ) ; ++ m interval Count ; } }
@ Override public void incoming Object ( I Analyzed Interval analyzed Interval ) throws Ade Exception { if ( ! m percentiles With Empty Intervals && analyzed Interval . get Num Unique Message Ids ( ) == NUM ) { return ; } final double raw Score = calc Raw Score ( analyzed Interval ) ; if ( ! Seen Huge Log Prob ( analyzed Interval ) ) { m raw Scores . add ( raw Score ) ; ++ m interval Count ; } }
@ Override public void incoming Object ( I Analyzed Interval analyzed Interval ) throws Ade Exception { if ( ! m percentiles With Empty Intervals && analyzed Interval . get Num Unique Message Ids ( ) == NUM ) { return ; } final double raw Score = calc Raw Score ( analyzed Interval ) ; if ( ! Seen Huge Log Prob ( analyzed Interval ) ) { m raw Scores . add ( raw Score ) ; ++ m interval Count ; } }
private void fill XML Attribute ( Attributes att , int index ) { fill Q Name ( f Attribute Q Name , att . get URI ( index ) , att . get Local Name ( index ) , att . get Q Name ( index ) ) ; String type = att . get Type ( index ) ; f Attributes . add Attribute NS ( f Attribute Q Name , ( type != null ) ? type : XML Symbols . fCDATA Symbol , att . get Value ( index ) ) ; }
public void close ( ) throws IO Exception { Server Socket Channel ss = ss ; ss = ss ; if ( ss != null ) { try { ss . close ( ) ; } catch ( Exception e ) { } } }
public void ivr Zoneset Name ( String zoneset Name , boolean activate ) throws Network Device Controller Exception { ivr Zone Name ( BOOL , zoneset Name , activate , BOOL ) ; }
public void ivr Zoneset Name ( String zoneset Name , boolean activate ) throws Network Device Controller Exception { ivr Zone Name ( BOOL , zoneset Name , activate , BOOL ) ; }
public static Volume Group Rest Rep map ( Volume Group from ) { if ( from == null ) { return null ; } Volume Group Rest Rep rep = new Volume Group Rest Rep ( ) ; map Data Object Fields ( from , rep ) ; rep . set Description ( from . get Description ( ) ) ; rep . set Roles ( from . get Roles ( ) ) ; rep . set Parent ( to Related Resource ( Resource Type Enum . VOLUME GROUP , from . get Parent ( ) ) ) ; rep . set Migration Group By ( from . get Migration Group By ( ) ) ; rep . set Migration Type ( from . get Migration Type ( ) ) ; return rep ; }
public static Volume Group Rest Rep map ( Volume Group from ) { if ( from == null ) { return null ; } Volume Group Rest Rep rep = new Volume Group Rest Rep ( ) ; map Data Object Fields ( from , rep ) ; rep . set Description ( from . get Description ( ) ) ; rep . set Roles ( from . get Roles ( ) ) ; rep . set Parent ( to Related Resource ( Resource Type Enum . VOLUME GROUP , from . get Parent ( ) ) ) ; rep . set Migration Group By ( from . get Migration Group By ( ) ) ; rep . set Migration Type ( from . get Migration Type ( ) ) ; return rep ; }
public static byte [ ] copy Range ( byte [ ] orig , int from , int to ) { int length = to - from ; byte [ ] result = new byte [ length ] ; int how Much To Copy = orig . length - from < length ? orig . length - from : length ; System . arraycopy ( orig , from , result , NUM , how Much To Copy ) ; return result ; }
@ Suppress Warnings ( STRING ) public Uniform Generator ( Vector < String > values ) { values = ( Vector < String > ) values . clone ( ) ; laststring = null ; gen = new Uniform Integer Generator ( NUM , values . size ( ) - NUM ) ; }
@ Suppress Warnings ( STRING ) public Uniform Generator ( Vector < String > values ) { values = ( Vector < String > ) values . clone ( ) ; laststring = null ; gen = new Uniform Integer Generator ( NUM , values . size ( ) - NUM ) ; }
@ Suppress Warnings ( STRING ) public Uniform Generator ( Vector < String > values ) { values = ( Vector < String > ) values . clone ( ) ; laststring = null ; gen = new Uniform Integer Generator ( NUM , values . size ( ) - NUM ) ; }
@ Suppress Warnings ( STRING ) public Uniform Generator ( Vector < String > values ) { values = ( Vector < String > ) values . clone ( ) ; laststring = null ; gen = new Uniform Integer Generator ( NUM , values . size ( ) - NUM ) ; }
public void terminate Server ( ) { process . destroy ( ) ; }
protected double adjust ( double v ) { switch ( m scale ) { case Constants . LOG SCALE : return Math . pow ( NUM , v ) ; case Constants . SQRT SCALE : return v * v ; case Constants . LINEAR SCALE : default : return v ; } }
public static Object [ ] merge And Extract Params ( Map < String , ? extends Object > global Config , Map < String , ? extends Object > local Params , Collection < String > ignore Params , Map < String , External Resource Description > resources ) { Set < String > unique Params = new Hash Set < > ( ) ; unique Params . add All ( local Params . key Set ( ) ) ; unique Params . add All ( global Config . key Set ( ) ) ; if ( ignore Params != null ) { unique Params . remove All ( ignore Params ) ; } Object [ ] params = new Object [ resources . size ( ) * NUM + unique Params . size ( ) * NUM ] ; int i = NUM ; for ( Entry < String , External Resource Description > entry : resources . entry Set ( ) ) { params [ i ++ ] = entry . get Key ( ) ; params [ i ++ ] = entry . get Value ( ) ; } for ( String key : unique Params ) { params [ i ++ ] = key ; if ( local Params . contains Key ( key ) ) { params [ i ++ ] = Cpe Builder Utils . convert To Parameter Value ( local Params . get ( key ) ) ; } else { params [ i ++ ] = Cpe Builder Utils . convert To Parameter Value ( global Config . get ( key ) ) ; } } return params ; }
public static Object [ ] merge And Extract Params ( Map < String , ? extends Object > global Config , Map < String , ? extends Object > local Params , Collection < String > ignore Params , Map < String , External Resource Description > resources ) { Set < String > unique Params = new Hash Set < > ( ) ; unique Params . add All ( local Params . key Set ( ) ) ; unique Params . add All ( global Config . key Set ( ) ) ; if ( ignore Params != null ) { unique Params . remove All ( ignore Params ) ; } Object [ ] params = new Object [ resources . size ( ) * NUM + unique Params . size ( ) * NUM ] ; int i = NUM ; for ( Entry < String , External Resource Description > entry : resources . entry Set ( ) ) { params [ i ++ ] = entry . get Key ( ) ; params [ i ++ ] = entry . get Value ( ) ; } for ( String key : unique Params ) { params [ i ++ ] = key ; if ( local Params . contains Key ( key ) ) { params [ i ++ ] = Cpe Builder Utils . convert To Parameter Value ( local Params . get ( key ) ) ; } else { params [ i ++ ] = Cpe Builder Utils . convert To Parameter Value ( global Config . get ( key ) ) ; } } return params ; }
public static Object [ ] merge And Extract Params ( Map < String , ? extends Object > global Config , Map < String , ? extends Object > local Params , Collection < String > ignore Params , Map < String , External Resource Description > resources ) { Set < String > unique Params = new Hash Set < > ( ) ; unique Params . add All ( local Params . key Set ( ) ) ; unique Params . add All ( global Config . key Set ( ) ) ; if ( ignore Params != null ) { unique Params . remove All ( ignore Params ) ; } Object [ ] params = new Object [ resources . size ( ) * NUM + unique Params . size ( ) * NUM ] ; int i = NUM ; for ( Entry < String , External Resource Description > entry : resources . entry Set ( ) ) { params [ i ++ ] = entry . get Key ( ) ; params [ i ++ ] = entry . get Value ( ) ; } for ( String key : unique Params ) { params [ i ++ ] = key ; if ( local Params . contains Key ( key ) ) { params [ i ++ ] = Cpe Builder Utils . convert To Parameter Value ( local Params . get ( key ) ) ; } else { params [ i ++ ] = Cpe Builder Utils . convert To Parameter Value ( global Config . get ( key ) ) ; } } return params ; }
public static Object [ ] merge And Extract Params ( Map < String , ? extends Object > global Config , Map < String , ? extends Object > local Params , Collection < String > ignore Params , Map < String , External Resource Description > resources ) { Set < String > unique Params = new Hash Set < > ( ) ; unique Params . add All ( local Params . key Set ( ) ) ; unique Params . add All ( global Config . key Set ( ) ) ; if ( ignore Params != null ) { unique Params . remove All ( ignore Params ) ; } Object [ ] params = new Object [ resources . size ( ) * NUM + unique Params . size ( ) * NUM ] ; int i = NUM ; for ( Entry < String , External Resource Description > entry : resources . entry Set ( ) ) { params [ i ++ ] = entry . get Key ( ) ; params [ i ++ ] = entry . get Value ( ) ; } for ( String key : unique Params ) { params [ i ++ ] = key ; if ( local Params . contains Key ( key ) ) { params [ i ++ ] = Cpe Builder Utils . convert To Parameter Value ( local Params . get ( key ) ) ; } else { params [ i ++ ] = Cpe Builder Utils . convert To Parameter Value ( global Config . get ( key ) ) ; } } return params ; }
public static Object [ ] merge And Extract Params ( Map < String , ? extends Object > global Config , Map < String , ? extends Object > local Params , Collection < String > ignore Params , Map < String , External Resource Description > resources ) { Set < String > unique Params = new Hash Set < > ( ) ; unique Params . add All ( local Params . key Set ( ) ) ; unique Params . add All ( global Config . key Set ( ) ) ; if ( ignore Params != null ) { unique Params . remove All ( ignore Params ) ; } Object [ ] params = new Object [ resources . size ( ) * NUM + unique Params . size ( ) * NUM ] ; int i = NUM ; for ( Entry < String , External Resource Description > entry : resources . entry Set ( ) ) { params [ i ++ ] = entry . get Key ( ) ; params [ i ++ ] = entry . get Value ( ) ; } for ( String key : unique Params ) { params [ i ++ ] = key ; if ( local Params . contains Key ( key ) ) { params [ i ++ ] = Cpe Builder Utils . convert To Parameter Value ( local Params . get ( key ) ) ; } else { params [ i ++ ] = Cpe Builder Utils . convert To Parameter Value ( global Config . get ( key ) ) ; } } return params ; }
public static Object [ ] merge And Extract Params ( Map < String , ? extends Object > global Config , Map < String , ? extends Object > local Params , Collection < String > ignore Params , Map < String , External Resource Description > resources ) { Set < String > unique Params = new Hash Set < > ( ) ; unique Params . add All ( local Params . key Set ( ) ) ; unique Params . add All ( global Config . key Set ( ) ) ; if ( ignore Params != null ) { unique Params . remove All ( ignore Params ) ; } Object [ ] params = new Object [ resources . size ( ) * NUM + unique Params . size ( ) * NUM ] ; int i = NUM ; for ( Entry < String , External Resource Description > entry : resources . entry Set ( ) ) { params [ i ++ ] = entry . get Key ( ) ; params [ i ++ ] = entry . get Value ( ) ; } for ( String key : unique Params ) { params [ i ++ ] = key ; if ( local Params . contains Key ( key ) ) { params [ i ++ ] = Cpe Builder Utils . convert To Parameter Value ( local Params . get ( key ) ) ; } else { params [ i ++ ] = Cpe Builder Utils . convert To Parameter Value ( global Config . get ( key ) ) ; } } return params ; }
private static String create Bcrypt String ( byte [ ] password , byte [ ] salt , int cost ) { String Buffer sb = new String Buffer ( NUM ) ; sb . append ( STRING ) ; sb . append ( version ) ; sb . append ( STRING ) ; sb . append ( cost < NUM ? ( STRING + cost ) : Integer . to String ( cost ) ) ; sb . append ( STRING ) ; sb . append ( encode Data ( salt ) ) ; byte [ ] key = B Crypt . generate ( password , salt , cost ) ; sb . append ( encode Data ( key ) ) ; return sb . to String ( ) ; }
@ Request Mapping ( value = STRING , method = { Request Method . GET , Request Method . POST } ) public void sso SSL Dummy ( Locale locale , Model model , @ Path Variable ( value = STRING ) String tenant , Http Servlet Request request , Http Servlet Response response ) throws IO Exception { logger . info ( STRING + tenant ) ; try { Relying Party rp = validate Relying Party ( request , tenant ) ; if ( rp != null ) { logger . info ( STRING + rp . get Url ( ) ) ; URL rp Url = new URL ( rp . get Url ( ) ) ; URL redirect Url = new URL ( rp Url . get Protocol ( ) , rp Url . get Host ( ) , rp Url . get Port ( ) , STRING ) ; String redirect Url Str = redirect Url . to String ( ) + STRING + sso SSL Dummy Query String ( request ) ; response . send Redirect ( redirect Url Str ) ; } else { logger . error ( STRING + tenant + STRING ) ; send Error ( locale , response , STRING ) ; } } catch ( Exception e ) { logger . error ( STRING , e ) ; send Error ( locale , response , e . get Localized Message ( ) ) ; } }
@ Request Mapping ( value = STRING , method = { Request Method . GET , Request Method . POST } ) public void sso SSL Dummy ( Locale locale , Model model , @ Path Variable ( value = STRING ) String tenant , Http Servlet Request request , Http Servlet Response response ) throws IO Exception { logger . info ( STRING + tenant ) ; try { Relying Party rp = validate Relying Party ( request , tenant ) ; if ( rp != null ) { logger . info ( STRING + rp . get Url ( ) ) ; URL rp Url = new URL ( rp . get Url ( ) ) ; URL redirect Url = new URL ( rp Url . get Protocol ( ) , rp Url . get Host ( ) , rp Url . get Port ( ) , STRING ) ; String redirect Url Str = redirect Url . to String ( ) + STRING + sso SSL Dummy Query String ( request ) ; response . send Redirect ( redirect Url Str ) ; } else { logger . error ( STRING + tenant + STRING ) ; send Error ( locale , response , STRING ) ; } } catch ( Exception e ) { logger . error ( STRING , e ) ; send Error ( locale , response , e . get Localized Message ( ) ) ; } }
@ Request Mapping ( value = STRING , method = { Request Method . GET , Request Method . POST } ) public void sso SSL Dummy ( Locale locale , Model model , @ Path Variable ( value = STRING ) String tenant , Http Servlet Request request , Http Servlet Response response ) throws IO Exception { logger . info ( STRING + tenant ) ; try { Relying Party rp = validate Relying Party ( request , tenant ) ; if ( rp != null ) { logger . info ( STRING + rp . get Url ( ) ) ; URL rp Url = new URL ( rp . get Url ( ) ) ; URL redirect Url = new URL ( rp Url . get Protocol ( ) , rp Url . get Host ( ) , rp Url . get Port ( ) , STRING ) ; String redirect Url Str = redirect Url . to String ( ) + STRING + sso SSL Dummy Query String ( request ) ; response . send Redirect ( redirect Url Str ) ; } else { logger . error ( STRING + tenant + STRING ) ; send Error ( locale , response , STRING ) ; } } catch ( Exception e ) { logger . error ( STRING , e ) ; send Error ( locale , response , e . get Localized Message ( ) ) ; } }
@ Request Mapping ( value = STRING , method = { Request Method . GET , Request Method . POST } ) public void sso SSL Dummy ( Locale locale , Model model , @ Path Variable ( value = STRING ) String tenant , Http Servlet Request request , Http Servlet Response response ) throws IO Exception { logger . info ( STRING + tenant ) ; try { Relying Party rp = validate Relying Party ( request , tenant ) ; if ( rp != null ) { logger . info ( STRING + rp . get Url ( ) ) ; URL rp Url = new URL ( rp . get Url ( ) ) ; URL redirect Url = new URL ( rp Url . get Protocol ( ) , rp Url . get Host ( ) , rp Url . get Port ( ) , STRING ) ; String redirect Url Str = redirect Url . to String ( ) + STRING + sso SSL Dummy Query String ( request ) ; response . send Redirect ( redirect Url Str ) ; } else { logger . error ( STRING + tenant + STRING ) ; send Error ( locale , response , STRING ) ; } } catch ( Exception e ) { logger . error ( STRING , e ) ; send Error ( locale , response , e . get Localized Message ( ) ) ; } }
@ Request Mapping ( value = STRING , method = { Request Method . GET , Request Method . POST } ) public void sso SSL Dummy ( Locale locale , Model model , @ Path Variable ( value = STRING ) String tenant , Http Servlet Request request , Http Servlet Response response ) throws IO Exception { logger . info ( STRING + tenant ) ; try { Relying Party rp = validate Relying Party ( request , tenant ) ; if ( rp != null ) { logger . info ( STRING + rp . get Url ( ) ) ; URL rp Url = new URL ( rp . get Url ( ) ) ; URL redirect Url = new URL ( rp Url . get Protocol ( ) , rp Url . get Host ( ) , rp Url . get Port ( ) , STRING ) ; String redirect Url Str = redirect Url . to String ( ) + STRING + sso SSL Dummy Query String ( request ) ; response . send Redirect ( redirect Url Str ) ; } else { logger . error ( STRING + tenant + STRING ) ; send Error ( locale , response , STRING ) ; } } catch ( Exception e ) { logger . error ( STRING , e ) ; send Error ( locale , response , e . get Localized Message ( ) ) ; } }
@ Request Mapping ( value = STRING , method = { Request Method . GET , Request Method . POST } ) public void sso SSL Dummy ( Locale locale , Model model , @ Path Variable ( value = STRING ) String tenant , Http Servlet Request request , Http Servlet Response response ) throws IO Exception { logger . info ( STRING + tenant ) ; try { Relying Party rp = validate Relying Party ( request , tenant ) ; if ( rp != null ) { logger . info ( STRING + rp . get Url ( ) ) ; URL rp Url = new URL ( rp . get Url ( ) ) ; URL redirect Url = new URL ( rp Url . get Protocol ( ) , rp Url . get Host ( ) , rp Url . get Port ( ) , STRING ) ; String redirect Url Str = redirect Url . to String ( ) + STRING + sso SSL Dummy Query String ( request ) ; response . send Redirect ( redirect Url Str ) ; } else { logger . error ( STRING + tenant + STRING ) ; send Error ( locale , response , STRING ) ; } } catch ( Exception e ) { logger . error ( STRING , e ) ; send Error ( locale , response , e . get Localized Message ( ) ) ; } }
private Applied Migration create Applied Schema Migration ( ) { return new Applied Migration ( NUM , NUM , Migration Version . from Version ( Integer . to String ( NUM ) ) , STRING , Migration Type . SCHEMA , STRING , null , new Date ( ) , STRING , NUM , BOOL ) ; }
private Applied Migration create Applied Schema Migration ( ) { return new Applied Migration ( NUM , NUM , Migration Version . from Version ( Integer . to String ( NUM ) ) , STRING , Migration Type . SCHEMA , STRING , null , new Date ( ) , STRING , NUM , BOOL ) ; }
private void select Superseded Forms ( ) { List View ls = get List View ( ) ; for ( int idx = NUM ; idx < m Form List . size ( ) ; idx ++ ) { Hash Map < String , String > item = m Form List . get ( idx ) ; if ( is Local Form Superseded ( item . get ( FORM ID KEY ) , item . get ( FORM VERSION KEY ) ) ) { ls . set Item Checked ( idx , BOOL ) ; } } }
private void select Superseded Forms ( ) { List View ls = get List View ( ) ; for ( int idx = NUM ; idx < m Form List . size ( ) ; idx ++ ) { Hash Map < String , String > item = m Form List . get ( idx ) ; if ( is Local Form Superseded ( item . get ( FORM ID KEY ) , item . get ( FORM VERSION KEY ) ) ) { ls . set Item Checked ( idx , BOOL ) ; } } }
private void select Superseded Forms ( ) { List View ls = get List View ( ) ; for ( int idx = NUM ; idx < m Form List . size ( ) ; idx ++ ) { Hash Map < String , String > item = m Form List . get ( idx ) ; if ( is Local Form Superseded ( item . get ( FORM ID KEY ) , item . get ( FORM VERSION KEY ) ) ) { ls . set Item Checked ( idx , BOOL ) ; } } }
private void select Superseded Forms ( ) { List View ls = get List View ( ) ; for ( int idx = NUM ; idx < m Form List . size ( ) ; idx ++ ) { Hash Map < String , String > item = m Form List . get ( idx ) ; if ( is Local Form Superseded ( item . get ( FORM ID KEY ) , item . get ( FORM VERSION KEY ) ) ) { ls . set Item Checked ( idx , BOOL ) ; } } }
private void select Superseded Forms ( ) { List View ls = get List View ( ) ; for ( int idx = NUM ; idx < m Form List . size ( ) ; idx ++ ) { Hash Map < String , String > item = m Form List . get ( idx ) ; if ( is Local Form Superseded ( item . get ( FORM ID KEY ) , item . get ( FORM VERSION KEY ) ) ) { ls . set Item Checked ( idx , BOOL ) ; } } }
private void select Superseded Forms ( ) { List View ls = get List View ( ) ; for ( int idx = NUM ; idx < m Form List . size ( ) ; idx ++ ) { Hash Map < String , String > item = m Form List . get ( idx ) ; if ( is Local Form Superseded ( item . get ( FORM ID KEY ) , item . get ( FORM VERSION KEY ) ) ) { ls . set Item Checked ( idx , BOOL ) ; } } }
public void remove ( final Channel channel ) { synchronized ( channels ) { for ( final Iterator chan Iter = channels . iterator ( ) ; chan Iter . has Next ( ) ; ) { if ( chan Iter . next ( ) == channel ) { chan Iter . remove ( ) ; break ; } } } }
public void remove Channel Map ( Channel Map channel Map ) { if ( m Channel Maps . contains ( channel Map ) ) { int index = m Channel Maps . index Of ( channel Map ) ; m Channel Maps . remove ( channel Map ) ; fire Interval Removed ( this , index , index ) ; broadcast ( new Channel Map Event ( channel Map , Event . DELETE ) ) ; } }
public Phone Durations Impl ( URL url ) throws IO Exception { Buffered Reader reader ; String line ; phone Durations = new Hash Map ( ) ; reader = new Buffered Reader ( new Input Stream Reader ( url . open Stream ( ) ) ) ; line = reader . read Line ( ) ; while ( line != null ) { if ( ! line . starts With ( STRING ) ) { parse And Add ( line ) ; } line = reader . read Line ( ) ; } reader . close ( ) ; }
public Phone Durations Impl ( URL url ) throws IO Exception { Buffered Reader reader ; String line ; phone Durations = new Hash Map ( ) ; reader = new Buffered Reader ( new Input Stream Reader ( url . open Stream ( ) ) ) ; line = reader . read Line ( ) ; while ( line != null ) { if ( ! line . starts With ( STRING ) ) { parse And Add ( line ) ; } line = reader . read Line ( ) ; } reader . close ( ) ; }
private static Supported Group negotiate Named Curve ( Client Hello client Hello ) { Supported Group result = null ; List < Supported Group > preferred Groups = Supported Group . get Preferred Groups ( ) ; Supported Elliptic Curves Extension extension = client Hello . get Supported Elliptic Curves Extension ( ) ; if ( extension == null ) { if ( ! preferred Groups . is Empty ( ) ) { result = preferred Groups . get ( NUM ) ; } } else { for ( Integer preferred Group Id : extension . get Supported Group Ids ( ) ) { Supported Group group = Supported Group . from Id ( preferred Group Id ) ; if ( group != null && group . is Usable ( ) && preferred Groups . contains ( group ) ) { result = group ; break ; } } } return result ; }
public Cannot Find Method Exception ( Soot Class clz , Soot Method Ref method ) { super ( String . format ( STRING , method , clz ) ) ; }
public static String generate String From Template ( File template File , Map < String , Object > parameters ) { try { Template template = get Template ( template File ) ; Writable finished Template = template . make ( parameters ) ; return finished Template . to String ( ) ; } catch ( Exception e ) { Doc Reporter . print Error ( STRING + template File ) ; Doc Reporter . print Error ( e . get Message ( ) ) ; throw new Runtime Exception ( e ) ; } }
public static String generate String From Template ( File template File , Map < String , Object > parameters ) { try { Template template = get Template ( template File ) ; Writable finished Template = template . make ( parameters ) ; return finished Template . to String ( ) ; } catch ( Exception e ) { Doc Reporter . print Error ( STRING + template File ) ; Doc Reporter . print Error ( e . get Message ( ) ) ; throw new Runtime Exception ( e ) ; } }
public Object extract Hard Ref ( Object o ) { Soft Reference w = ( Soft Reference ) o ; if ( w != null ) { return w . get ( ) ; } return null ; }
public void clean ( Obj ID [ ] ids , long sequence Num , VMID vmid , boolean strong ) { for ( Obj ID id : ids ) { if ( dgc Log . is Loggable ( Log . VERBOSE ) ) { dgc Log . log ( Log . VERBOSE , STRING + id + STRING + vmid + STRING + strong ) ; } Object Table . unreferenced ( id , sequence Num , vmid , strong ) ; } }
public void clean ( Obj ID [ ] ids , long sequence Num , VMID vmid , boolean strong ) { for ( Obj ID id : ids ) { if ( dgc Log . is Loggable ( Log . VERBOSE ) ) { dgc Log . log ( Log . VERBOSE , STRING + id + STRING + vmid + STRING + strong ) ; } Object Table . unreferenced ( id , sequence Num , vmid , strong ) ; } }
public void clean ( Obj ID [ ] ids , long sequence Num , VMID vmid , boolean strong ) { for ( Obj ID id : ids ) { if ( dgc Log . is Loggable ( Log . VERBOSE ) ) { dgc Log . log ( Log . VERBOSE , STRING + id + STRING + vmid + STRING + strong ) ; } Object Table . unreferenced ( id , sequence Num , vmid , strong ) ; } }
public void clean ( Obj ID [ ] ids , long sequence Num , VMID vmid , boolean strong ) { for ( Obj ID id : ids ) { if ( dgc Log . is Loggable ( Log . VERBOSE ) ) { dgc Log . log ( Log . VERBOSE , STRING + id + STRING + vmid + STRING + strong ) ; } Object Table . unreferenced ( id , sequence Num , vmid , strong ) ; } }
public void clean ( Obj ID [ ] ids , long sequence Num , VMID vmid , boolean strong ) { for ( Obj ID id : ids ) { if ( dgc Log . is Loggable ( Log . VERBOSE ) ) { dgc Log . log ( Log . VERBOSE , STRING + id + STRING + vmid + STRING + strong ) ; } Object Table . unreferenced ( id , sequence Num , vmid , strong ) ; } }
public void clean ( Obj ID [ ] ids , long sequence Num , VMID vmid , boolean strong ) { for ( Obj ID id : ids ) { if ( dgc Log . is Loggable ( Log . VERBOSE ) ) { dgc Log . log ( Log . VERBOSE , STRING + id + STRING + vmid + STRING + strong ) ; } Object Table . unreferenced ( id , sequence Num , vmid , strong ) ; } }
public void clean ( Obj ID [ ] ids , long sequence Num , VMID vmid , boolean strong ) { for ( Obj ID id : ids ) { if ( dgc Log . is Loggable ( Log . VERBOSE ) ) { dgc Log . log ( Log . VERBOSE , STRING + id + STRING + vmid + STRING + strong ) ; } Object Table . unreferenced ( id , sequence Num , vmid , strong ) ; } }
public boolean equals Ignore Case ( String string ) { if ( string == this ) { return BOOL ; } if ( string == null || count != string . count ) { return BOOL ; } int o1 = offset , o2 = string . offset ; int end = offset + count ; char c1 , c2 ; char [ ] target = string . value ; while ( o1 < end ) { if ( ( c1 = value [ o1 ++ ] ) != ( c2 = target [ o2 ++ ] ) && Character . to Upper Case ( c1 ) != Character . to Upper Case ( c2 ) && Character . to Lower Case ( c1 ) != Character . to Lower Case ( c2 ) ) { return BOOL ; } } return BOOL ; }
public static void unregister Field Prefix ( final String prefix ) { field Prefixes . remove ( prefix ) ; }
public synchronized void insert Chunk Auth Tag ( int chunk Idx , byte [ ] chunk Auth Tag ) throws File Encryption Exception { if ( chunk Idx < NUM || chunk Auth Tag == null || chunk Auth Tag . length != CHUNK AUTH TAG LENGTH ) { throw new File Encryption Exception ( STRING ) ; } else { if ( atag List . size ( ) <= chunk Idx ) { atag List . ensure Capacity ( chunk Idx + NUM ) ; pad To ( atag List , chunk Idx ) ; atag List . add ( chunk Idx , Arrays . copy Of ( chunk Auth Tag , CHUNK AUTH TAG LENGTH ) ) ; } else { atag List . set ( chunk Idx , Arrays . copy Of ( chunk Auth Tag , CHUNK AUTH TAG LENGTH ) ) ; } } }
public synchronized void insert Chunk Auth Tag ( int chunk Idx , byte [ ] chunk Auth Tag ) throws File Encryption Exception { if ( chunk Idx < NUM || chunk Auth Tag == null || chunk Auth Tag . length != CHUNK AUTH TAG LENGTH ) { throw new File Encryption Exception ( STRING ) ; } else { if ( atag List . size ( ) <= chunk Idx ) { atag List . ensure Capacity ( chunk Idx + NUM ) ; pad To ( atag List , chunk Idx ) ; atag List . add ( chunk Idx , Arrays . copy Of ( chunk Auth Tag , CHUNK AUTH TAG LENGTH ) ) ; } else { atag List . set ( chunk Idx , Arrays . copy Of ( chunk Auth Tag , CHUNK AUTH TAG LENGTH ) ) ; } } }
public synchronized void insert Chunk Auth Tag ( int chunk Idx , byte [ ] chunk Auth Tag ) throws File Encryption Exception { if ( chunk Idx < NUM || chunk Auth Tag == null || chunk Auth Tag . length != CHUNK AUTH TAG LENGTH ) { throw new File Encryption Exception ( STRING ) ; } else { if ( atag List . size ( ) <= chunk Idx ) { atag List . ensure Capacity ( chunk Idx + NUM ) ; pad To ( atag List , chunk Idx ) ; atag List . add ( chunk Idx , Arrays . copy Of ( chunk Auth Tag , CHUNK AUTH TAG LENGTH ) ) ; } else { atag List . set ( chunk Idx , Arrays . copy Of ( chunk Auth Tag , CHUNK AUTH TAG LENGTH ) ) ; } } }
public synchronized void insert Chunk Auth Tag ( int chunk Idx , byte [ ] chunk Auth Tag ) throws File Encryption Exception { if ( chunk Idx < NUM || chunk Auth Tag == null || chunk Auth Tag . length != CHUNK AUTH TAG LENGTH ) { throw new File Encryption Exception ( STRING ) ; } else { if ( atag List . size ( ) <= chunk Idx ) { atag List . ensure Capacity ( chunk Idx + NUM ) ; pad To ( atag List , chunk Idx ) ; atag List . add ( chunk Idx , Arrays . copy Of ( chunk Auth Tag , CHUNK AUTH TAG LENGTH ) ) ; } else { atag List . set ( chunk Idx , Arrays . copy Of ( chunk Auth Tag , CHUNK AUTH TAG LENGTH ) ) ; } } }
public synchronized void insert Chunk Auth Tag ( int chunk Idx , byte [ ] chunk Auth Tag ) throws File Encryption Exception { if ( chunk Idx < NUM || chunk Auth Tag == null || chunk Auth Tag . length != CHUNK AUTH TAG LENGTH ) { throw new File Encryption Exception ( STRING ) ; } else { if ( atag List . size ( ) <= chunk Idx ) { atag List . ensure Capacity ( chunk Idx + NUM ) ; pad To ( atag List , chunk Idx ) ; atag List . add ( chunk Idx , Arrays . copy Of ( chunk Auth Tag , CHUNK AUTH TAG LENGTH ) ) ; } else { atag List . set ( chunk Idx , Arrays . copy Of ( chunk Auth Tag , CHUNK AUTH TAG LENGTH ) ) ; } } }
public void handle Client Command ( String type , String [ ] params , Server server , Conversation conversation , IRC Service service ) { Base Handler command = null ; if ( commands . contains Key ( type . to Lower Case ( ) ) ) { command = commands . get ( type . to Lower Case ( ) ) ; } else if ( aliases . contains Key ( type . to Lower Case ( ) ) ) { String command In Commands = aliases . get ( type . to Lower Case ( ) ) ; command = commands . get ( command In Commands ) ; } try { command . execute ( params , server , conversation , service ) ; } catch ( Command Exception e ) { if ( conversation != null ) { Message error Message = new Message ( type + STRING + e . get Message ( ) ) ; error Message . set Color ( Message . COLOR RED ) ; conversation . add Message ( error Message ) ; Message usage Message = new Message ( STRING + command . get Usage ( ) ) ; conversation . add Message ( usage Message ) ; Intent intent = Broadcast . create Conversation Intent ( Broadcast . CONVERSATION MESSAGE , server . get Id ( ) , conversation . get Name ( ) ) ; service . send Broadcast ( intent ) ; } } }
protected void encode Line Suffix ( Output Stream a Stream ) throws IO Exception { p Stream . println ( ) ; }
protected void encode Line Suffix ( Output Stream a Stream ) throws IO Exception { p Stream . println ( ) ; }
protected void encode Line Suffix ( Output Stream a Stream ) throws IO Exception { p Stream . println ( ) ; }
protected void encode Line Suffix ( Output Stream a Stream ) throws IO Exception { p Stream . println ( ) ; }
protected void encode Line Suffix ( Output Stream a Stream ) throws IO Exception { p Stream . println ( ) ; }
@ Exception Handler ( Object Not Found Exception . class ) @ Response Status ( value = Http Status . NOT FOUND ) public @ Response Body Error Response resolve Document Not Found Exception ( Object Not Found Exception e ) throws IO Exception { if ( logger . is Loggable ( Level . FINE ) ) logger . fine ( STRING + e . get Message ( ) ) ; return new Error Response ( new Error Message ( e . get Message ( ) ) ) ; }
@ Exception Handler ( Object Not Found Exception . class ) @ Response Status ( value = Http Status . NOT FOUND ) public @ Response Body Error Response resolve Document Not Found Exception ( Object Not Found Exception e ) throws IO Exception { if ( logger . is Loggable ( Level . FINE ) ) logger . fine ( STRING + e . get Message ( ) ) ; return new Error Response ( new Error Message ( e . get Message ( ) ) ) ; }
private void report Exception Throw ( Element element , Throwable t ) { if ( element != null ) { log Message ( STRING , element ) ; } log Exception ( t ) ; error Message ( element , STRING , t , Arrays . to String ( Arrays . copy Of ( t . get Stack Trace ( ) , NUM ) ) ) ; }
private void report Exception Throw ( Element element , Throwable t ) { if ( element != null ) { log Message ( STRING , element ) ; } log Exception ( t ) ; error Message ( element , STRING , t , Arrays . to String ( Arrays . copy Of ( t . get Stack Trace ( ) , NUM ) ) ) ; }
private void report Exception Throw ( Element element , Throwable t ) { if ( element != null ) { log Message ( STRING , element ) ; } log Exception ( t ) ; error Message ( element , STRING , t , Arrays . to String ( Arrays . copy Of ( t . get Stack Trace ( ) , NUM ) ) ) ; }
private void report Exception Throw ( Element element , Throwable t ) { if ( element != null ) { log Message ( STRING , element ) ; } log Exception ( t ) ; error Message ( element , STRING , t , Arrays . to String ( Arrays . copy Of ( t . get Stack Trace ( ) , NUM ) ) ) ; }
public double local Score ( int i ) { double sum = NUM ; int count = NUM ; for ( Sem Bic Score score : sem Bic Scores ) { double score = score . local Score ( i ) ; if ( ! Double . is Na N ( score ) ) { sum += score ; count ++ ; } } return sum / count ; }
public double local Score ( int i ) { double sum = NUM ; int count = NUM ; for ( Sem Bic Score score : sem Bic Scores ) { double score = score . local Score ( i ) ; if ( ! Double . is Na N ( score ) ) { sum += score ; count ++ ; } } return sum / count ; }
public double local Score ( int i ) { double sum = NUM ; int count = NUM ; for ( Sem Bic Score score : sem Bic Scores ) { double score = score . local Score ( i ) ; if ( ! Double . is Na N ( score ) ) { sum += score ; count ++ ; } } return sum / count ; }
public double local Score ( int i ) { double sum = NUM ; int count = NUM ; for ( Sem Bic Score score : sem Bic Scores ) { double score = score . local Score ( i ) ; if ( ! Double . is Na N ( score ) ) { sum += score ; count ++ ; } } return sum / count ; }
public void test Constructor Bytes Zero ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , + NUM , NUM , - NUM } ; byte r Bytes [ ] = { NUM } ; Big Integer a Number = new Big Integer ( a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
public static Kindred Snippets [ ] to Array ( Array List < Kindred Snippets > snippets ) { if ( snippets == null || snippets . is Empty ( ) ) { return Empty ; } return snippets . to Array ( new Kindred Snippets [ snippets . size ( ) ] ) ; }
public static Kindred Snippets [ ] to Array ( Array List < Kindred Snippets > snippets ) { if ( snippets == null || snippets . is Empty ( ) ) { return Empty ; } return snippets . to Array ( new Kindred Snippets [ snippets . size ( ) ] ) ; }
public static Kindred Snippets [ ] to Array ( Array List < Kindred Snippets > snippets ) { if ( snippets == null || snippets . is Empty ( ) ) { return Empty ; } return snippets . to Array ( new Kindred Snippets [ snippets . size ( ) ] ) ; }
public static void do Random Sleep On Failed Login Attempt ( Authentication Info authentication Info ) { try { if ( authentication Info == null ) { authentication Info = Security Helper . load Authentication Information ( ) ; } int min = authentication Info . get Min Wait On Failed Login ( ) ; int max = authentication Info . get Max Wait On Failed Login ( ) ; int increment = authentication Info . get Increment Step Wait On Failed Login ( ) ; int random Num = Security Helper . get Random Int ( min , max , increment ) ; logger . info ( Message Format . format ( STRING , random Num ) ) ; if ( random Num > NUM ) Thread . sleep ( random Num ) ; } catch ( Interrupted Exception e ) { logger . error ( Message Format . format ( STRING , e ) ) ; } catch ( Configuration Exception e ) { logger . error ( Message Format . format ( STRING , e ) ) ; } }
public static void do Random Sleep On Failed Login Attempt ( Authentication Info authentication Info ) { try { if ( authentication Info == null ) { authentication Info = Security Helper . load Authentication Information ( ) ; } int min = authentication Info . get Min Wait On Failed Login ( ) ; int max = authentication Info . get Max Wait On Failed Login ( ) ; int increment = authentication Info . get Increment Step Wait On Failed Login ( ) ; int random Num = Security Helper . get Random Int ( min , max , increment ) ; logger . info ( Message Format . format ( STRING , random Num ) ) ; if ( random Num > NUM ) Thread . sleep ( random Num ) ; } catch ( Interrupted Exception e ) { logger . error ( Message Format . format ( STRING , e ) ) ; } catch ( Configuration Exception e ) { logger . error ( Message Format . format ( STRING , e ) ) ; } }
public static void do Random Sleep On Failed Login Attempt ( Authentication Info authentication Info ) { try { if ( authentication Info == null ) { authentication Info = Security Helper . load Authentication Information ( ) ; } int min = authentication Info . get Min Wait On Failed Login ( ) ; int max = authentication Info . get Max Wait On Failed Login ( ) ; int increment = authentication Info . get Increment Step Wait On Failed Login ( ) ; int random Num = Security Helper . get Random Int ( min , max , increment ) ; logger . info ( Message Format . format ( STRING , random Num ) ) ; if ( random Num > NUM ) Thread . sleep ( random Num ) ; } catch ( Interrupted Exception e ) { logger . error ( Message Format . format ( STRING , e ) ) ; } catch ( Configuration Exception e ) { logger . error ( Message Format . format ( STRING , e ) ) ; } }
private static void expunge Stale Exceptions ( ) { for ( Object x ; ( x = exception Table Ref Queue . poll ( ) ) != null ; ) { if ( x instanceof Exception Node ) { int hash Code = ( ( Exception Node ) x ) . hash Code ; Exception Node [ ] t = exception Table ; int i = hash Code & ( t . length - NUM ) ; Exception Node e = t [ i ] ; Exception Node pred = null ; while ( e != null ) { Exception Node next = e . next ; if ( e == x ) { if ( pred == null ) t [ i ] = next ; else pred . next = next ; break ; } pred = e ; e = next ; } } } }
static private String BYTE Min ( ) { byte temp Value = Byte . MIN VALUE ; return String . value Of ( temp Value ) ; }
protected boolean check Relations ( Cn A Tree Element tree Element ) { return BOOL ; }
protected boolean check Relations ( Cn A Tree Element tree Element ) { return BOOL ; }
protected boolean check Relations ( Cn A Tree Element tree Element ) { return BOOL ; }
protected boolean check Relations ( Cn A Tree Element tree Element ) { return BOOL ; }
protected boolean check Relations ( Cn A Tree Element tree Element ) { return BOOL ; }
protected boolean check Relations ( Cn A Tree Element tree Element ) { return BOOL ; }
public boolean download Directory Exists ( ) { File file = new File ( get Absolute Directory Path ( ) ) ; return file . exists ( ) ; }
public boolean seek ( Byte Buffer byte Buffer ) { byte [ ] buffer = new byte [ FIELD TAGID LENGTH ] ; byte Buffer . get ( buffer , NUM , FIELD TAGID LENGTH ) ; if ( ! ( Arrays . equals ( buffer , TAG ID ) ) ) { return BOOL ; } byte Buffer . position ( FIELD TRACK INDICATOR POS ) ; if ( byte Buffer . get ( ) != END OF FIELD ) { return BOOL ; } return byte Buffer . get ( ) != END OF FIELD ; }
public boolean seek ( Byte Buffer byte Buffer ) { byte [ ] buffer = new byte [ FIELD TAGID LENGTH ] ; byte Buffer . get ( buffer , NUM , FIELD TAGID LENGTH ) ; if ( ! ( Arrays . equals ( buffer , TAG ID ) ) ) { return BOOL ; } byte Buffer . position ( FIELD TRACK INDICATOR POS ) ; if ( byte Buffer . get ( ) != END OF FIELD ) { return BOOL ; } return byte Buffer . get ( ) != END OF FIELD ; }
public boolean seek ( Byte Buffer byte Buffer ) { byte [ ] buffer = new byte [ FIELD TAGID LENGTH ] ; byte Buffer . get ( buffer , NUM , FIELD TAGID LENGTH ) ; if ( ! ( Arrays . equals ( buffer , TAG ID ) ) ) { return BOOL ; } byte Buffer . position ( FIELD TRACK INDICATOR POS ) ; if ( byte Buffer . get ( ) != END OF FIELD ) { return BOOL ; } return byte Buffer . get ( ) != END OF FIELD ; }
public boolean seek ( Byte Buffer byte Buffer ) { byte [ ] buffer = new byte [ FIELD TAGID LENGTH ] ; byte Buffer . get ( buffer , NUM , FIELD TAGID LENGTH ) ; if ( ! ( Arrays . equals ( buffer , TAG ID ) ) ) { return BOOL ; } byte Buffer . position ( FIELD TRACK INDICATOR POS ) ; if ( byte Buffer . get ( ) != END OF FIELD ) { return BOOL ; } return byte Buffer . get ( ) != END OF FIELD ; }
public void write ( char text [ ] , int offset , int length ) { if ( ( offset < NUM ) || ( offset > text . length ) || ( length < NUM ) || ( ( offset + length ) > text . length ) || ( ( offset + length ) < NUM ) ) { throw new Index Out Of Bounds Exception ( ) ; } else if ( length == NUM ) { return ; } buffer . append ( text , offset , length ) ; }
public static void release ( ) { pc Thread Local . set ( null ) ; }
public String create Random File ( String location ) { Random random Generator = new Random ( ) ; Simple Date Format date Format = new Simple Date Format ( STRING ) ; Date date = new Date ( ) ; final String file Path = location + date Format . format ( date ) + random Generator . next Int ( NUM ) ; Log . i ( TAG , STRING + location + STRING + file Path ) ; return file Path ; }
public void update UI ( ) { if ( is Accept All File Filter Used ( ) ) { remove Choosable File Filter ( get Accept All File Filter ( ) ) ; } File Chooser UI ui = ( ( File Chooser UI ) UI Manager . get UI ( this ) ) ; if ( file System View == null ) { set File System View ( File System View . get File System View ( ) ) ; } set UI ( ui ) ; if ( is Accept All File Filter Used ( ) ) { add Choosable File Filter ( get Accept All File Filter ( ) ) ; } }
public void update UI ( ) { if ( is Accept All File Filter Used ( ) ) { remove Choosable File Filter ( get Accept All File Filter ( ) ) ; } File Chooser UI ui = ( ( File Chooser UI ) UI Manager . get UI ( this ) ) ; if ( file System View == null ) { set File System View ( File System View . get File System View ( ) ) ; } set UI ( ui ) ; if ( is Accept All File Filter Used ( ) ) { add Choosable File Filter ( get Accept All File Filter ( ) ) ; } }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return ARG ; default : return null ; } }
public static void fix Tab Keys ( final J Component component ) { final Set < AWT Key Stroke > forward = new Hash Set < AWT Key Stroke > ( component . get Focus Traversal Keys ( Keyboard Focus Manager . FORWARD TRAVERSAL KEYS ) ) ; forward . add ( Key Stroke . get Key Stroke ( STRING ) ) ; component . set Focus Traversal Keys ( Keyboard Focus Manager . FORWARD TRAVERSAL KEYS , forward ) ; final Set < AWT Key Stroke > backward = new Hash Set < AWT Key Stroke > ( component . get Focus Traversal Keys ( Keyboard Focus Manager . BACKWARD TRAVERSAL KEYS ) ) ; backward . add ( Key Stroke . get Key Stroke ( STRING ) ) ; component . set Focus Traversal Keys ( Keyboard Focus Manager . BACKWARD TRAVERSAL KEYS , backward ) ; }
public static void fix Tab Keys ( final J Component component ) { final Set < AWT Key Stroke > forward = new Hash Set < AWT Key Stroke > ( component . get Focus Traversal Keys ( Keyboard Focus Manager . FORWARD TRAVERSAL KEYS ) ) ; forward . add ( Key Stroke . get Key Stroke ( STRING ) ) ; component . set Focus Traversal Keys ( Keyboard Focus Manager . FORWARD TRAVERSAL KEYS , forward ) ; final Set < AWT Key Stroke > backward = new Hash Set < AWT Key Stroke > ( component . get Focus Traversal Keys ( Keyboard Focus Manager . BACKWARD TRAVERSAL KEYS ) ) ; backward . add ( Key Stroke . get Key Stroke ( STRING ) ) ; component . set Focus Traversal Keys ( Keyboard Focus Manager . BACKWARD TRAVERSAL KEYS , backward ) ; }
public static void fix Tab Keys ( final J Component component ) { final Set < AWT Key Stroke > forward = new Hash Set < AWT Key Stroke > ( component . get Focus Traversal Keys ( Keyboard Focus Manager . FORWARD TRAVERSAL KEYS ) ) ; forward . add ( Key Stroke . get Key Stroke ( STRING ) ) ; component . set Focus Traversal Keys ( Keyboard Focus Manager . FORWARD TRAVERSAL KEYS , forward ) ; final Set < AWT Key Stroke > backward = new Hash Set < AWT Key Stroke > ( component . get Focus Traversal Keys ( Keyboard Focus Manager . BACKWARD TRAVERSAL KEYS ) ) ; backward . add ( Key Stroke . get Key Stroke ( STRING ) ) ; component . set Focus Traversal Keys ( Keyboard Focus Manager . BACKWARD TRAVERSAL KEYS , backward ) ; }
public static void fix Tab Keys ( final J Component component ) { final Set < AWT Key Stroke > forward = new Hash Set < AWT Key Stroke > ( component . get Focus Traversal Keys ( Keyboard Focus Manager . FORWARD TRAVERSAL KEYS ) ) ; forward . add ( Key Stroke . get Key Stroke ( STRING ) ) ; component . set Focus Traversal Keys ( Keyboard Focus Manager . FORWARD TRAVERSAL KEYS , forward ) ; final Set < AWT Key Stroke > backward = new Hash Set < AWT Key Stroke > ( component . get Focus Traversal Keys ( Keyboard Focus Manager . BACKWARD TRAVERSAL KEYS ) ) ; backward . add ( Key Stroke . get Key Stroke ( STRING ) ) ; component . set Focus Traversal Keys ( Keyboard Focus Manager . BACKWARD TRAVERSAL KEYS , backward ) ; }
public static void fix Tab Keys ( final J Component component ) { final Set < AWT Key Stroke > forward = new Hash Set < AWT Key Stroke > ( component . get Focus Traversal Keys ( Keyboard Focus Manager . FORWARD TRAVERSAL KEYS ) ) ; forward . add ( Key Stroke . get Key Stroke ( STRING ) ) ; component . set Focus Traversal Keys ( Keyboard Focus Manager . FORWARD TRAVERSAL KEYS , forward ) ; final Set < AWT Key Stroke > backward = new Hash Set < AWT Key Stroke > ( component . get Focus Traversal Keys ( Keyboard Focus Manager . BACKWARD TRAVERSAL KEYS ) ) ; backward . add ( Key Stroke . get Key Stroke ( STRING ) ) ; component . set Focus Traversal Keys ( Keyboard Focus Manager . BACKWARD TRAVERSAL KEYS , backward ) ; }
public static < T > long add And Get ( Atomic Long Field Updater < T > updater , T instance , long n ) { for ( ; ; ) { long r = updater . get ( instance ) ; if ( r == Long . MAX VALUE ) { return Long . MAX VALUE ; } long u = add Cap ( r , n ) ; if ( updater . compare And Set ( instance , r , u ) ) { return r ; } } }
public void add Column ( Column Info info ) { W Table Column table Column ; table Column = new W Table Column ( ) ; table Column . set Header Value ( Util . clean Amp ( info . get Col Header ( ) ) ) ; set Column Visibility ( table Column , info . get Visibility ( ) ) ; m table Columns . add ( table Column ) ; return ; }
public void add Column ( Column Info info ) { W Table Column table Column ; table Column = new W Table Column ( ) ; table Column . set Header Value ( Util . clean Amp ( info . get Col Header ( ) ) ) ; set Column Visibility ( table Column , info . get Visibility ( ) ) ; m table Columns . add ( table Column ) ; return ; }
public void add Column ( Column Info info ) { W Table Column table Column ; table Column = new W Table Column ( ) ; table Column . set Header Value ( Util . clean Amp ( info . get Col Header ( ) ) ) ; set Column Visibility ( table Column , info . get Visibility ( ) ) ; m table Columns . add ( table Column ) ; return ; }
public void add Column ( Column Info info ) { W Table Column table Column ; table Column = new W Table Column ( ) ; table Column . set Header Value ( Util . clean Amp ( info . get Col Header ( ) ) ) ; set Column Visibility ( table Column , info . get Visibility ( ) ) ; m table Columns . add ( table Column ) ; return ; }
public Str Builder ensure Capacity ( int capacity ) { if ( capacity > buffer . length ) { char [ ] old = buffer ; buffer = new char [ capacity * NUM ] ; System . arraycopy ( old , NUM , buffer , NUM , size ) ; } return this ; }
public Log Stream printf ( String format , Object ... args ) { if ( ps != null ) { print ( String . format ( format , args ) ) ; } return this ; }
List create Polys ( int n Items , double size , int n Pts ) { double overlap Pct = NUM ; int n Cells = ( int ) Math . sqrt ( n Items ) ; List geoms = new Array List ( ) ; double width = n Cells * ( NUM - overlap Pct ) * size ; double height = n Cells * NUM * size ; double x Inc = width / n Cells ; double y Inc = height / n Cells ; for ( int i = NUM ; i < n Cells ; i ++ ) { for ( int j = NUM ; j < n Cells ; j ++ ) { Coordinate base = new Coordinate ( i * x Inc , j * y Inc ) ; Geometry poly = create Poly ( base , size , n Pts ) ; geoms . add ( poly ) ; } } return geoms ; }
public Image flip Image Vertically ( Image image , boolean maintain Opacity ) { int [ ] rgb = image . get RGB ( ) ; int [ ] new RGB = new int [ rgb . length ] ; int width = image . get Width ( ) ; int height = image . get Height ( ) ; for ( int y = NUM ; y < height ; y ++ ) { for ( int x = NUM ; x < width ; x ++ ) { new RGB [ x + ( height - y - NUM ) * width ] = rgb [ x + y * width ] ; } } return Encoded Image . create From RGB ( new RGB , width , height , ! maintain Opacity ) ; }
public Image flip Image Vertically ( Image image , boolean maintain Opacity ) { int [ ] rgb = image . get RGB ( ) ; int [ ] new RGB = new int [ rgb . length ] ; int width = image . get Width ( ) ; int height = image . get Height ( ) ; for ( int y = NUM ; y < height ; y ++ ) { for ( int x = NUM ; x < width ; x ++ ) { new RGB [ x + ( height - y - NUM ) * width ] = rgb [ x + y * width ] ; } } return Encoded Image . create From RGB ( new RGB , width , height , ! maintain Opacity ) ; }
public Diagnostic with User ( User user ) { this . user = user ; return this ; }
public Diagnostic with User ( User user ) { this . user = user ; return this ; }
public void add Item At Index ( T item , int index ) { if ( index <= items . size ( ) ) { items . add ( index , item ) ; fire Data Changed Event ( Data Changed Listener . ADDED , index ) ; } }
static public Sdf Macro decode Instruction ( Sdf Buffer buff ) { Sdf Macro m ; if ( ( m = Channel Start . match ( buff ) ) != null ) { return m ; } else if ( ( m = Sdl Version . match ( buff ) ) != null ) { return m ; } else if ( ( m = Skeme Start . match ( buff ) ) != null ) { return m ; } else if ( ( m = Generate Trigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = End Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Delay Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Skip On Trigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = Initiate Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Mask Compare . match ( buff ) ) != null ) { return m ; } else if ( ( m = Load Modifier . match ( buff ) ) != null ) { return m ; } else if ( ( m = Branch To . match ( buff ) ) != null ) { return m ; } else if ( ( m = Play . match ( buff ) ) != null ) { return m ; } else if ( ( m = Four Byte Macro . match ( buff ) ) != null ) { return m ; } else if ( ( m = Two Byte Macro . match ( buff ) ) != null ) { return m ; } log . warn ( STRING ) ; return null ; }
static public Sdf Macro decode Instruction ( Sdf Buffer buff ) { Sdf Macro m ; if ( ( m = Channel Start . match ( buff ) ) != null ) { return m ; } else if ( ( m = Sdl Version . match ( buff ) ) != null ) { return m ; } else if ( ( m = Skeme Start . match ( buff ) ) != null ) { return m ; } else if ( ( m = Generate Trigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = End Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Delay Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Skip On Trigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = Initiate Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Mask Compare . match ( buff ) ) != null ) { return m ; } else if ( ( m = Load Modifier . match ( buff ) ) != null ) { return m ; } else if ( ( m = Branch To . match ( buff ) ) != null ) { return m ; } else if ( ( m = Play . match ( buff ) ) != null ) { return m ; } else if ( ( m = Four Byte Macro . match ( buff ) ) != null ) { return m ; } else if ( ( m = Two Byte Macro . match ( buff ) ) != null ) { return m ; } log . warn ( STRING ) ; return null ; }
static public Sdf Macro decode Instruction ( Sdf Buffer buff ) { Sdf Macro m ; if ( ( m = Channel Start . match ( buff ) ) != null ) { return m ; } else if ( ( m = Sdl Version . match ( buff ) ) != null ) { return m ; } else if ( ( m = Skeme Start . match ( buff ) ) != null ) { return m ; } else if ( ( m = Generate Trigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = End Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Delay Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Skip On Trigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = Initiate Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Mask Compare . match ( buff ) ) != null ) { return m ; } else if ( ( m = Load Modifier . match ( buff ) ) != null ) { return m ; } else if ( ( m = Branch To . match ( buff ) ) != null ) { return m ; } else if ( ( m = Play . match ( buff ) ) != null ) { return m ; } else if ( ( m = Four Byte Macro . match ( buff ) ) != null ) { return m ; } else if ( ( m = Two Byte Macro . match ( buff ) ) != null ) { return m ; } log . warn ( STRING ) ; return null ; }
static public Sdf Macro decode Instruction ( Sdf Buffer buff ) { Sdf Macro m ; if ( ( m = Channel Start . match ( buff ) ) != null ) { return m ; } else if ( ( m = Sdl Version . match ( buff ) ) != null ) { return m ; } else if ( ( m = Skeme Start . match ( buff ) ) != null ) { return m ; } else if ( ( m = Generate Trigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = End Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Delay Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Skip On Trigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = Initiate Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Mask Compare . match ( buff ) ) != null ) { return m ; } else if ( ( m = Load Modifier . match ( buff ) ) != null ) { return m ; } else if ( ( m = Branch To . match ( buff ) ) != null ) { return m ; } else if ( ( m = Play . match ( buff ) ) != null ) { return m ; } else if ( ( m = Four Byte Macro . match ( buff ) ) != null ) { return m ; } else if ( ( m = Two Byte Macro . match ( buff ) ) != null ) { return m ; } log . warn ( STRING ) ; return null ; }
static public Sdf Macro decode Instruction ( Sdf Buffer buff ) { Sdf Macro m ; if ( ( m = Channel Start . match ( buff ) ) != null ) { return m ; } else if ( ( m = Sdl Version . match ( buff ) ) != null ) { return m ; } else if ( ( m = Skeme Start . match ( buff ) ) != null ) { return m ; } else if ( ( m = Generate Trigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = End Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Delay Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Skip On Trigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = Initiate Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Mask Compare . match ( buff ) ) != null ) { return m ; } else if ( ( m = Load Modifier . match ( buff ) ) != null ) { return m ; } else if ( ( m = Branch To . match ( buff ) ) != null ) { return m ; } else if ( ( m = Play . match ( buff ) ) != null ) { return m ; } else if ( ( m = Four Byte Macro . match ( buff ) ) != null ) { return m ; } else if ( ( m = Two Byte Macro . match ( buff ) ) != null ) { return m ; } log . warn ( STRING ) ; return null ; }
static public Sdf Macro decode Instruction ( Sdf Buffer buff ) { Sdf Macro m ; if ( ( m = Channel Start . match ( buff ) ) != null ) { return m ; } else if ( ( m = Sdl Version . match ( buff ) ) != null ) { return m ; } else if ( ( m = Skeme Start . match ( buff ) ) != null ) { return m ; } else if ( ( m = Generate Trigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = End Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Delay Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Skip On Trigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = Initiate Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Mask Compare . match ( buff ) ) != null ) { return m ; } else if ( ( m = Load Modifier . match ( buff ) ) != null ) { return m ; } else if ( ( m = Branch To . match ( buff ) ) != null ) { return m ; } else if ( ( m = Play . match ( buff ) ) != null ) { return m ; } else if ( ( m = Four Byte Macro . match ( buff ) ) != null ) { return m ; } else if ( ( m = Two Byte Macro . match ( buff ) ) != null ) { return m ; } log . warn ( STRING ) ; return null ; }
public Event Client ( Inet Address host Address , int host Port , String device Name , byte icon Type , byte [ ] icon Data ) throws IO Exception { has Icon = BOOL ; start Client ( host Address , host Port , device Name , icon Type , icon Data ) ; }
private void update Work Amount ( double work Time ) { if ( work Time <= NUM ) { current Work Amount *= NUM ; } else { total Time Taken += work Time ; completed Work Amount += current Work Amount ; current Work Amount = ( int ) Math . ceil ( target Execution Ms * completed Work Amount / total Time Taken ) ; } }
private void update Work Amount ( double work Time ) { if ( work Time <= NUM ) { current Work Amount *= NUM ; } else { total Time Taken += work Time ; completed Work Amount += current Work Amount ; current Work Amount = ( int ) Math . ceil ( target Execution Ms * completed Work Amount / total Time Taken ) ; } }
private void update Work Amount ( double work Time ) { if ( work Time <= NUM ) { current Work Amount *= NUM ; } else { total Time Taken += work Time ; completed Work Amount += current Work Amount ; current Work Amount = ( int ) Math . ceil ( target Execution Ms * completed Work Amount / total Time Taken ) ; } }
private void update Work Amount ( double work Time ) { if ( work Time <= NUM ) { current Work Amount *= NUM ; } else { total Time Taken += work Time ; completed Work Amount += current Work Amount ; current Work Amount = ( int ) Math . ceil ( target Execution Ms * completed Work Amount / total Time Taken ) ; } }
private void append Type ( Type generic Type , final String Builder builder ) { builder . append ( get Impl Name ( generic Type , BOOL ) ) ; }
private void append Type ( Type generic Type , final String Builder builder ) { builder . append ( get Impl Name ( generic Type , BOOL ) ) ; }
private void append Type ( Type generic Type , final String Builder builder ) { builder . append ( get Impl Name ( generic Type , BOOL ) ) ; }
public boolean bound Scroll ( ) { float cur Scroll = get Stack Scroll ( ) ; float new Scroll = get Bounded Stack Scroll ( cur Scroll ) ; if ( Float . compare ( new Scroll , cur Scroll ) != NUM ) { set Stack Scroll ( new Scroll ) ; return BOOL ; } return BOOL ; }
protected void draw Mark ( Graphics 2 D g2 , float x , float y , Color color ) { Rectangle 2 D bounds = mark . get Bounds 2 D ( ) ; float w = ( float ) bounds . get Width ( ) ; float h = ( float ) bounds . get Height ( ) ; x = x - ( w / NUM ) ; y = y - ( h / NUM ) ; g2 . translate ( x , y ) ; if ( color == null ) { if ( mark Fill Paint != null ) { g2 . set Paint ( mark Fill Paint ) ; g2 . fill ( mark ) ; } } else { g2 . set Paint ( color ) ; g2 . fill ( mark ) ; } g2 . set Paint ( mark Paint ) ; g2 . set Stroke ( mark Stroke ) ; g2 . draw ( mark ) ; g2 . translate ( - x , - y ) ; Rectangle 2 D rect = new Rectangle 2 D . Float ( x , y , w , h ) ; mark Bounds . add ( rect ) ; }
protected void draw Mark ( Graphics 2 D g2 , float x , float y , Color color ) { Rectangle 2 D bounds = mark . get Bounds 2 D ( ) ; float w = ( float ) bounds . get Width ( ) ; float h = ( float ) bounds . get Height ( ) ; x = x - ( w / NUM ) ; y = y - ( h / NUM ) ; g2 . translate ( x , y ) ; if ( color == null ) { if ( mark Fill Paint != null ) { g2 . set Paint ( mark Fill Paint ) ; g2 . fill ( mark ) ; } } else { g2 . set Paint ( color ) ; g2 . fill ( mark ) ; } g2 . set Paint ( mark Paint ) ; g2 . set Stroke ( mark Stroke ) ; g2 . draw ( mark ) ; g2 . translate ( - x , - y ) ; Rectangle 2 D rect = new Rectangle 2 D . Float ( x , y , w , h ) ; mark Bounds . add ( rect ) ; }
public static void report ( ) { if ( ! reported . compare And Set ( BOOL , BOOL ) ) { return ; } if ( USE EPOLL ) { logger . info ( STRING + ( Epoll . is Available ( ) ? STRING : STRING + filter Cause ( Epoll . unavailability Cause ( ) ) + STRING ) ) ; } else { logger . info ( STRING ) ; } if ( USE OPENSSL ) { logger . info ( STRING + ( Open Ssl . is Available ( ) ? STRING + Open Ssl . version String ( ) + STRING + Open Ssl . version ( ) + STRING : STRING + filter Cause ( Open Ssl . unavailability Cause ( ) ) + STRING ) ) ; } else { logger . info ( STRING ) ; } }
public static void report ( ) { if ( ! reported . compare And Set ( BOOL , BOOL ) ) { return ; } if ( USE EPOLL ) { logger . info ( STRING + ( Epoll . is Available ( ) ? STRING : STRING + filter Cause ( Epoll . unavailability Cause ( ) ) + STRING ) ) ; } else { logger . info ( STRING ) ; } if ( USE OPENSSL ) { logger . info ( STRING + ( Open Ssl . is Available ( ) ? STRING + Open Ssl . version String ( ) + STRING + Open Ssl . version ( ) + STRING : STRING + filter Cause ( Open Ssl . unavailability Cause ( ) ) + STRING ) ) ; } else { logger . info ( STRING ) ; } }
private static Decorator Map concat ( Decorator Map ... d maps ) { return null ; }
private static Decorator Map concat ( Decorator Map ... d maps ) { return null ; }
public static String commit ( String ... args ) { return simple Tag ( STRING , args ) ; }
public static String commit ( String ... args ) { return simple Tag ( STRING , args ) ; }
public static String commit ( String ... args ) { return simple Tag ( STRING , args ) ; }
public final Test Subscriber assert Value Count ( int count ) { String prefix = STRING ; boolean passed = BOOL ; if ( done . get Count ( ) != NUM ) { prefix = STRING ; } int s = values . size ( ) ; if ( s != count ) { fail ( prefix , STRING + count + STRING + s , errors ) ; fail ( STRING + count + STRING + s ) ; passed = BOOL ; } pass ( STRING + count + STRING , passed ) ; return this ; }
public final Test Subscriber assert Value Count ( int count ) { String prefix = STRING ; boolean passed = BOOL ; if ( done . get Count ( ) != NUM ) { prefix = STRING ; } int s = values . size ( ) ; if ( s != count ) { fail ( prefix , STRING + count + STRING + s , errors ) ; fail ( STRING + count + STRING + s ) ; passed = BOOL ; } pass ( STRING + count + STRING , passed ) ; return this ; }
public Unicast Thread ( Inet Address host , int port ) throws IO Exception { super ( STRING ) ; set Daemon ( BOOL ) ; int backlog = Integer . get Integer ( System Properties . LRMI ACCEPT BACKLOG , System Properties . LRMI ACCEPT BACKLOG DEFUALT ) ; this . host = host ; if ( port == NUM ) { try { listen = new Server Socket ( Constants . get Discovery Port ( ) , backlog , host ) ; } catch ( IO Exception e ) { logger . log ( Levels . HANDLED , STRING , e ) ; } } if ( listen == null ) { listen = new Server Socket ( port , backlog , host ) ; } this . port = listen . get Local Port ( ) ; }
public Unicast Thread ( Inet Address host , int port ) throws IO Exception { super ( STRING ) ; set Daemon ( BOOL ) ; int backlog = Integer . get Integer ( System Properties . LRMI ACCEPT BACKLOG , System Properties . LRMI ACCEPT BACKLOG DEFUALT ) ; this . host = host ; if ( port == NUM ) { try { listen = new Server Socket ( Constants . get Discovery Port ( ) , backlog , host ) ; } catch ( IO Exception e ) { logger . log ( Levels . HANDLED , STRING , e ) ; } } if ( listen == null ) { listen = new Server Socket ( port , backlog , host ) ; } this . port = listen . get Local Port ( ) ; }
public Unicast Thread ( Inet Address host , int port ) throws IO Exception { super ( STRING ) ; set Daemon ( BOOL ) ; int backlog = Integer . get Integer ( System Properties . LRMI ACCEPT BACKLOG , System Properties . LRMI ACCEPT BACKLOG DEFUALT ) ; this . host = host ; if ( port == NUM ) { try { listen = new Server Socket ( Constants . get Discovery Port ( ) , backlog , host ) ; } catch ( IO Exception e ) { logger . log ( Levels . HANDLED , STRING , e ) ; } } if ( listen == null ) { listen = new Server Socket ( port , backlog , host ) ; } this . port = listen . get Local Port ( ) ; }
public Unicast Thread ( Inet Address host , int port ) throws IO Exception { super ( STRING ) ; set Daemon ( BOOL ) ; int backlog = Integer . get Integer ( System Properties . LRMI ACCEPT BACKLOG , System Properties . LRMI ACCEPT BACKLOG DEFUALT ) ; this . host = host ; if ( port == NUM ) { try { listen = new Server Socket ( Constants . get Discovery Port ( ) , backlog , host ) ; } catch ( IO Exception e ) { logger . log ( Levels . HANDLED , STRING , e ) ; } } if ( listen == null ) { listen = new Server Socket ( port , backlog , host ) ; } this . port = listen . get Local Port ( ) ; }
public void add Data ( T data ) { m Data . add ( data ) ; notify Item Inserted ( m Data . size ( ) ) ; }
@ Override public void put All ( Map < ? extends K , ? extends V > map ) { ensure Capacity ( map . size ( ) ) ; super . put All ( map ) ; }
@ Override public void put All ( Map < ? extends K , ? extends V > map ) { ensure Capacity ( map . size ( ) ) ; super . put All ( map ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return NAME ; case NUM : return VALUE ; default : return null ; } }
public static J Button create Button ( final String button Text , final int mnemonic ) { final J Button new Button = new J Button ( button Text ) ; new Button . set Mnemonic ( mnemonic ) ; new Button . set Font ( default Map XML Creator Font ) ; new Button . set Margin ( new Insets ( NUM , NUM , NUM , NUM ) ) ; return new Button ; }
public Alignment Action ( String nm , int a ) { super ( nm ) ; this . a = a ; }
@ Request Mapping ( value = STRING , method = POST , produces = APPLICATION JSON VALUE ) public Response Entity < Page Response < Role DTO > > find All ( @ Request Body Page Request By Example < Role DTO > prbe ) throws URI Syntax Exception { Page Response < Role DTO > page Response = role DTO Service . find All ( prbe ) ; return new Response Entity < > ( page Response , new Http Headers ( ) , Http Status . OK ) ; }
private void add Global Attributes To Intent ( Intent intent ) { if ( ! intent . has Extra ( Event . ATTRIBUTE TIME ) ) { insert Time Stamp ( intent ) ; } if ( ! intent . has Extra ( Event . ATTRIBUTE LOCATION ) ) { insert Location Data ( intent ) ; } }
public static byte [ ] base 64 To Bytes ( String base 64 ) throws Illegal Argument Exception { if ( base 64 == null ) { return null ; } try { return Base 64 . decode ( base 64 , Base 64 . NO WRAP ) ; } catch ( Illegal Argument Exception e ) { log . error ( STRING + base 64 ) ; return null ; } }
public static byte [ ] base 64 To Bytes ( String base 64 ) throws Illegal Argument Exception { if ( base 64 == null ) { return null ; } try { return Base 64 . decode ( base 64 , Base 64 . NO WRAP ) ; } catch ( Illegal Argument Exception e ) { log . error ( STRING + base 64 ) ; return null ; } }
public void add Data ( int position , List < T > data ) { if ( NUM <= position && position < m Data . size ( ) ) { m Data . add All ( position , data ) ; notify Item Inserted ( position ) ; notify Item Range Changed ( position , m Data . size ( ) - position - data . size ( ) ) ; } else { throw new Array Index Out Of Bounds Exception ( STRING ) ; } }
public void add Data ( int position , List < T > data ) { if ( NUM <= position && position < m Data . size ( ) ) { m Data . add All ( position , data ) ; notify Item Inserted ( position ) ; notify Item Range Changed ( position , m Data . size ( ) - position - data . size ( ) ) ; } else { throw new Array Index Out Of Bounds Exception ( STRING ) ; } }
public final void register View System ( View System view System ) { view Systems . add ( view System ) ; }
@ Override public < R , A > Completable Future < R > collect ( final Collector < ? super T , A , R > collector ) { return Completable Future . supply Async ( null ) ; }
public void process Utterance ( Utterance utterance ) throws Process Exception { if ( utterance . get Relation ( Relation . SEGMENT ) == null ) { throw new Illegal State Exception ( STRING ) ; } utterance . set Object ( Sample Info . UTT NAME , diphone Database . get Sample Info ( ) ) ; create Unit Relation ( utterance ) ; }
public Bounds window View ( Bounds range Bounds ) { Bounds new Bounds = new Bounds ( this . start - range Bounds . start , this . end - range Bounds . start ) ; if ( ( new Bounds . start >= range Bounds . size ( ) ) || ( new Bounds . end <= NUM ) ) { return null ; } new Bounds . start = Math . max ( new Bounds . start , NUM ) ; new Bounds . end = Math . min ( new Bounds . end , range Bounds . size ( ) ) ; return new Bounds ; }
public Bounds window View ( Bounds range Bounds ) { Bounds new Bounds = new Bounds ( this . start - range Bounds . start , this . end - range Bounds . start ) ; if ( ( new Bounds . start >= range Bounds . size ( ) ) || ( new Bounds . end <= NUM ) ) { return null ; } new Bounds . start = Math . max ( new Bounds . start , NUM ) ; new Bounds . end = Math . min ( new Bounds . end , range Bounds . size ( ) ) ; return new Bounds ; }
public Bounds window View ( Bounds range Bounds ) { Bounds new Bounds = new Bounds ( this . start - range Bounds . start , this . end - range Bounds . start ) ; if ( ( new Bounds . start >= range Bounds . size ( ) ) || ( new Bounds . end <= NUM ) ) { return null ; } new Bounds . start = Math . max ( new Bounds . start , NUM ) ; new Bounds . end = Math . min ( new Bounds . end , range Bounds . size ( ) ) ; return new Bounds ; }
public static void register ( String model Name , I Wind Model model , int awesomeness ) { models . put ( model Name , model ) ; if ( model Name . equals Ignore Case ( user Model Choice ) ) { awesomeness = Integer . MAX VALUE ; } if ( awesomeness > best ) { best = awesomeness ; active Model = model ; } }
private List < Match < T > > sort ( final Map < String , Match < T > > possible Matches ) { List < String > keys = new Array List < > ( possible Matches . key Set ( ) ) ; Collections . sort ( keys , match Comparator ) ; List < Match < T > > matches 1 = new Array List < > ( possible Matches . size ( ) ) ; for ( String key : keys ) { matches 1 . add ( possible Matches . get ( key ) ) ; } return matches 1 ; }
private void create Proxy ( final Class < L > listener Interface , final Class Loader class Loader ) { proxy = listener Interface . cast ( Proxy . new Proxy Instance ( class Loader , new Class [ ] { listener Interface } , create Invocation Handler ( ) ) ) ; }
@ On Web Socket Connect public void on Connect ( Session session ) { this . websocket Session = session ; send Update ( this . websocket Session , this . o Auth Token , this . stream Type , this . stream Query , this . stream Version , this . schema Version ) ; }
public void stop ( ) { end time = System . nano Time ( ) ; total time = end time - start time ; }
public static String [ ] parse Words ( String tag Value ) { Stream Tokenizer tokenizer = make Tokenizer ( tag Value ) ; List < String > word List = new Array List < String > ( ) ; try { while ( tokenizer . next Token ( ) != Stream Tokenizer . TT EOF ) { if ( tokenizer . sval == null ) { word List . add ( Character . to String ( ( char ) tokenizer . ttype ) ) ; } else { word List . add ( tokenizer . sval ) ; } } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; throw new Runtime Exception ( STRING ) ; } return word List . to Array ( new String [ NUM ] ) ; }
public Amqp Sender ( Amqp Session session , String address , String sender Id ) { if ( address != null && address . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . session = session ; this . address = address ; this . sender Id = sender Id ; this . user Specified Target = null ; }
protected void delay For Nfs ( ) { if ( nfs Delay Milliseconds > NUM ) { try { Thread . sleep ( nfs Delay Milliseconds ) ; } catch ( Interrupted Exception e ) { throw new Illegal State Exception ( STRING , e ) ; } } }
protected void delay For Nfs ( ) { if ( nfs Delay Milliseconds > NUM ) { try { Thread . sleep ( nfs Delay Milliseconds ) ; } catch ( Interrupted Exception e ) { throw new Illegal State Exception ( STRING , e ) ; } } }
protected void delay For Nfs ( ) { if ( nfs Delay Milliseconds > NUM ) { try { Thread . sleep ( nfs Delay Milliseconds ) ; } catch ( Interrupted Exception e ) { throw new Illegal State Exception ( STRING , e ) ; } } }
public static void sin And Cos ( double angle , Double Wrapper sine , Double Wrapper cosine ) { if ( USE JDK MATH ) { sine . value = STRICT MATH ? Strict Math . sin ( angle ) : Math . sin ( angle ) ; cosine . value = STRICT MATH ? Strict Math . cos ( angle ) : Math . cos ( angle ) ; return ; } boolean negate Result ; if ( angle < NUM ) { angle = - angle ; negate Result = BOOL ; } else { negate Result = BOOL ; } if ( angle > SIN COS MAX VALUE FOR INT MODULO ) { angle = remainder Two Pi ( angle ) ; if ( angle < NUM ) { angle += NUM * Math . PI ; } } int index = ( int ) ( angle * SIN COS INDEXER + NUM ) ; double delta = ( angle - index * SIN COS DELTA HI ) - index * SIN COS DELTA LO ; index &= ( SIN COS TABS SIZE - NUM ) ; double index Sin = sin Tab [ index ] ; double index Cos = cos Tab [ index ] ; double result = index Sin + delta * ( index Cos + delta * ( - index Sin * ONE DIV F2 + delta * ( - index Cos * ONE DIV F3 + delta * index Sin * ONE DIV F4 ) ) ) ; sine . value = negate Result ? - result : result ; cosine . value = index Cos + delta * ( - index Sin + delta * ( - index Cos * ONE DIV F2 + delta * ( index Sin * ONE DIV F3 + delta * index Cos * ONE DIV F4 ) ) ) ; }
@ Suppress Warnings ( STRING ) public static < T extends Dimensional Item Object > List < T > as Typed List ( Collection < Dimensional Item Object > collection ) { List < T > list = new Array List < > ( ) ; if ( collection != null ) { for ( Dimensional Item Object object : collection ) { list . add ( ( T ) object ) ; } } return list ; }
@ Suppress Warnings ( STRING ) public static < T extends Dimensional Item Object > List < T > as Typed List ( Collection < Dimensional Item Object > collection ) { List < T > list = new Array List < > ( ) ; if ( collection != null ) { for ( Dimensional Item Object object : collection ) { list . add ( ( T ) object ) ; } } return list ; }
@ Suppress Warnings ( STRING ) public static < T extends Dimensional Item Object > List < T > as Typed List ( Collection < Dimensional Item Object > collection ) { List < T > list = new Array List < > ( ) ; if ( collection != null ) { for ( Dimensional Item Object object : collection ) { list . add ( ( T ) object ) ; } } return list ; }
public DB Exception ( Exception e , String sql , Object [ ] params ) { this ( e ) ; m sql = sql ; if ( params != null ) m params = Arrays . copy Of ( params , params . length ) ; }
private < T > Unary Operator < T > compose ( Unary Operator < T > before , Unary Operator < T > after ) { return null ; }
public boolean is Pdf Attachment ( ) { if ( get PO ( ) == null ) return BOOL ; return m po . is Pdf Attachment ( ) ; }
public boolean is Pdf Attachment ( ) { if ( get PO ( ) == null ) return BOOL ; return m po . is Pdf Attachment ( ) ; }
private void initialize Sparse Slider ( ) { sparsity Slider . set Major Tick Spacing ( NUM ) ; sparsity Slider . set Minor Tick Spacing ( NUM ) ; sparsity Slider . set Paint Ticks ( BOOL ) ; Hashtable < Integer , J Label > label Table 2 = new Hashtable < Integer , J Label > ( ) ; label Table 2 . put ( new Integer ( NUM ) , new J Label ( STRING ) ) ; label Table 2 . put ( new Integer ( NUM ) , new J Label ( STRING ) ) ; sparsity Slider . set Label Table ( label Table 2 ) ; sparsity Slider . set Paint Labels ( BOOL ) ; }
public void push Stream ( char [ ] in Stream , int in Fileid , String name , String in Base Dir , String in Encoding ) { include Stack . push ( new Include State ( cursor , line , col , fileid , file Name , base Dir , encoding , stream ) ) ; cursor = NUM ; line = NUM ; col = NUM ; fileid = in Fileid ; file Name = name ; base Dir = in Base Dir ; encoding = in Encoding ; stream = in Stream ; }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; { boolean success = BOOL ; try { child . insert Data ( - NUM , STRING ) ; } catch ( DOM Exception ex ) { success = ( ex . code == DOM Exception . INDEX SIZE ERR ) ; } assert True ( STRING , success ) ; } }
public Builder with System Security Manager ( ) { return with Security Manager ( System . get Security Manager ( ) ) ; }
public Builder with System Security Manager ( ) { return with Security Manager ( System . get Security Manager ( ) ) ; }
public Builder with System Security Manager ( ) { return with Security Manager ( System . get Security Manager ( ) ) ; }
boolean parameters Are Viewable As ( Method Type new Type , boolean keep Interfaces ) { if ( form == new Type . form && form . erased Type == this ) return BOOL ; if ( ptypes == new Type . ptypes ) return BOOL ; int argc = parameter Count ( ) ; if ( argc != new Type . parameter Count ( ) ) return BOOL ; for ( int i = NUM ; i < argc ; i ++ ) { if ( ! Verify Type . is Null Conversion ( new Type . parameter Type ( i ) , parameter Type ( i ) , keep Interfaces ) ) return BOOL ; } return BOOL ; }
private Http Response send Request ( State state , Android Http Client client , Http Get request ) throws Stop Request { try { return client . execute ( request ) ; } catch ( Illegal Argument Exception ex ) { throw new Stop Request ( Downloader Service . STATUS HTTP DATA ERROR , STRING + ex . to String ( ) , ex ) ; } catch ( IO Exception ex ) { log Network State ( ) ; throw new Stop Request ( get Final Status For Http Error ( state ) , STRING + ex . to String ( ) , ex ) ; } }
private Http Response send Request ( State state , Android Http Client client , Http Get request ) throws Stop Request { try { return client . execute ( request ) ; } catch ( Illegal Argument Exception ex ) { throw new Stop Request ( Downloader Service . STATUS HTTP DATA ERROR , STRING + ex . to String ( ) , ex ) ; } catch ( IO Exception ex ) { log Network State ( ) ; throw new Stop Request ( get Final Status For Http Error ( state ) , STRING + ex . to String ( ) , ex ) ; } }
public void test Case 17 ( ) { byte a Bytes [ ] = { NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
private Resolved Migration create Available Migration ( int version ) { Resolved Migration migration = new Resolved Migration ( ) ; migration . set Version ( Migration Version . from Version ( Integer . to String ( version ) ) ) ; migration . set Description ( STRING ) ; migration . set Script ( STRING ) ; migration . set Type ( Migration Type . CQL ) ; return migration ; }
public void tree Expanded ( Tree Expansion Event event ) { inspector Window . update View ( Director . ALL ) ; }
public void tree Expanded ( Tree Expansion Event event ) { inspector Window . update View ( Director . ALL ) ; }
public void write ( Output Stream o Stream ) throws IO Exception { byte [ ] array = to Byte Array ( ) ; o Stream . write ( array ) ; }
void init Program ( ) { gl Use Program ( this . program ) ; view Proj Matrix Uniform = gl Get Uniform Location ( this . program , STRING ) ; gl Use Program ( NUM ) ; }
public ISAAC Random ( ) { set Seed ( System . current Time Millis ( ) + System . identity Hash Code ( this ) ) ; }
public ISAAC Random ( ) { set Seed ( System . current Time Millis ( ) + System . identity Hash Code ( this ) ) ; }
public < V > Object [ ] all Meta ( ) { Object [ ] cp ; synchronized ( this ) { cp = Arrays . copy Of ( data , data . length ) ; } return cp ; }
public < V > Object [ ] all Meta ( ) { Object [ ] cp ; synchronized ( this ) { cp = Arrays . copy Of ( data , data . length ) ; } return cp ; }
private void ensure Visibility ( ) { if ( ! is Visible ( ) ) { return ; } set Location ( get Final Location ( ) ) ; }
private void ensure Visibility ( ) { if ( ! is Visible ( ) ) { return ; } set Location ( get Final Location ( ) ) ; }
protected static String read From File ( final File file ) throws IO Exception { final Line Number Reader r = new Line Number Reader ( new File Reader ( file ) ) ; try { final String Builder sb = new String Builder ( ) ; String s ; while ( ( s = r . read Line ( ) ) != null ) { if ( r . get Line Number ( ) > NUM ) sb . append ( STRING ) ; sb . append ( s ) ; } return sb . to String ( ) ; } finally { r . close ( ) ; } }
private void internal Group Snap Copy To Target ( Storage System storage , Block Snapshot snapshot , List < URI > snapshot List ) throws Exception { String snap Group Name = snapshot . get Replication Group Instance ( ) ; CIM Object Path target Group = cim Path . get Replication Group Path ( storage , snap Group Name ) ; CIM Object Path settings State = helper . get Settings Define State For Source Group ( storage , snapshot . get Settings Group Instance ( ) ) ; CIM Argument [ ] in Args = helper . get VNX Copy To Target Group Input Arguments ( settings State , target Group ) ; CIM Argument [ ] out Args = new CIM Argument [ NUM ] ; helper . call Modify Settings Define State ( storage , in Args , out Args ) ; List < Block Snapshot > snapshots = db Client . query Object ( Block Snapshot . class , snapshot List ) ; for ( Block Snapshot it : snapshots ) { it . set Needs Copy To Target ( BOOL ) ; } db Client . persist Object ( snapshots ) ; }
private void internal Group Snap Copy To Target ( Storage System storage , Block Snapshot snapshot , List < URI > snapshot List ) throws Exception { String snap Group Name = snapshot . get Replication Group Instance ( ) ; CIM Object Path target Group = cim Path . get Replication Group Path ( storage , snap Group Name ) ; CIM Object Path settings State = helper . get Settings Define State For Source Group ( storage , snapshot . get Settings Group Instance ( ) ) ; CIM Argument [ ] in Args = helper . get VNX Copy To Target Group Input Arguments ( settings State , target Group ) ; CIM Argument [ ] out Args = new CIM Argument [ NUM ] ; helper . call Modify Settings Define State ( storage , in Args , out Args ) ; List < Block Snapshot > snapshots = db Client . query Object ( Block Snapshot . class , snapshot List ) ; for ( Block Snapshot it : snapshots ) { it . set Needs Copy To Target ( BOOL ) ; } db Client . persist Object ( snapshots ) ; }
protected void visit Node ( final Node n , final Dijkstra Node Data data , final Pseudo Remove Priority Queue < Node > pending Nodes , final double time , final double cost , final Link out Link ) { data . visit ( out Link , cost , time , get Iteration Id ( ) ) ; pending Nodes . add ( n , get Priority ( data ) ) ; }
protected void visit Node ( final Node n , final Dijkstra Node Data data , final Pseudo Remove Priority Queue < Node > pending Nodes , final double time , final double cost , final Link out Link ) { data . visit ( out Link , cost , time , get Iteration Id ( ) ) ; pending Nodes . add ( n , get Priority ( data ) ) ; }
private static Tileset Group Animation Map create Animation Map ( ) { final Tileset Group Animation Map map = new Tileset Group Animation Map ( ) ; final URL url = Data Loader . get Resource ( base Folder + STRING ) ; if ( url != null ) { try { final Input Stream in = url . open Stream ( ) ; try { map . load ( in ) ; } finally { in . close ( ) ; } } catch ( final IO Exception ex ) { logger . error ( STRING , ex ) ; } } return map ; }
public Task < Void > unpin In Background ( String name ) { return unpin All In Background ( name , Arrays . as List ( this ) ) ; }
public Task < Void > unpin In Background ( String name ) { return unpin All In Background ( name , Arrays . as List ( this ) ) ; }
public Task < Void > unpin In Background ( String name ) { return unpin All In Background ( name , Arrays . as List ( this ) ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL ; } if ( ! ( obj instanceof Candlestick Renderer ) ) { return BOOL ; } Candlestick Renderer that = ( Candlestick Renderer ) obj ; if ( this . candle Width != that . candle Width ) { return BOOL ; } if ( ! Paint Utilities . equal ( this . up Paint , that . up Paint ) ) { return BOOL ; } if ( ! Paint Utilities . equal ( this . down Paint , that . down Paint ) ) { return BOOL ; } if ( this . draw Volume != that . draw Volume ) { return BOOL ; } if ( this . max Candle Width In Milliseconds != that . max Candle Width In Milliseconds ) { return BOOL ; } if ( this . auto Width Method != that . auto Width Method ) { return BOOL ; } if ( this . auto Width Factor != that . auto Width Factor ) { return BOOL ; } if ( this . auto Width Gap != that . auto Width Gap ) { return BOOL ; } if ( this . use Outline Paint != that . use Outline Paint ) { return BOOL ; } if ( ! Paint Utilities . equal ( this . volume Paint , that . volume Paint ) ) { return BOOL ; } return super . equals ( obj ) ; }
public static boolean is Android Runtime ( ) { final String runtime = System . get Property ( STRING ) ; return runtime != null && runtime . equals ( STRING ) ; }
public static void o ( Z a ) { o ( a , Parameters . Output Field Width , Parameters . Output Frac Places ) ; }
public void add ( @ Not Null final Scp Operation operation ) { my Ops . add ( operation ) ; }
public void add ( @ Not Null final Scp Operation operation ) { my Ops . add ( operation ) ; }
private boolean has Prefix ( byte [ ] nal ) { if ( nal [ NUM ] == NUM && nal [ NUM ] == NUM && nal [ NUM ] == NUM && nal [ NUM ] == NUM ) return BOOL ; else return BOOL ; }
private boolean has Prefix ( byte [ ] nal ) { if ( nal [ NUM ] == NUM && nal [ NUM ] == NUM && nal [ NUM ] == NUM && nal [ NUM ] == NUM ) return BOOL ; else return BOOL ; }
public Map < Graph Node , Graph Node > build Hidden Node Map ( ) { Map < Graph Node , Graph Node > result = Maps . new Hash Map ( ) ; for ( Collapse Data master Data : collapsed Data . values ( ) ) { Collection < Graph Node > master Nodes = Lists . new Array List ( ) ; master Data . add Member Nodes ( master Nodes ) ; for ( Graph Node child Node : master Nodes ) { result . put ( child Node , master Data . get Master Node ( ) ) ; } } return result ; }
public Map < Graph Node , Graph Node > build Hidden Node Map ( ) { Map < Graph Node , Graph Node > result = Maps . new Hash Map ( ) ; for ( Collapse Data master Data : collapsed Data . values ( ) ) { Collection < Graph Node > master Nodes = Lists . new Array List ( ) ; master Data . add Member Nodes ( master Nodes ) ; for ( Graph Node child Node : master Nodes ) { result . put ( child Node , master Data . get Master Node ( ) ) ; } } return result ; }
public Map < Graph Node , Graph Node > build Hidden Node Map ( ) { Map < Graph Node , Graph Node > result = Maps . new Hash Map ( ) ; for ( Collapse Data master Data : collapsed Data . values ( ) ) { Collection < Graph Node > master Nodes = Lists . new Array List ( ) ; master Data . add Member Nodes ( master Nodes ) ; for ( Graph Node child Node : master Nodes ) { result . put ( child Node , master Data . get Master Node ( ) ) ; } } return result ; }
public Map < Graph Node , Graph Node > build Hidden Node Map ( ) { Map < Graph Node , Graph Node > result = Maps . new Hash Map ( ) ; for ( Collapse Data master Data : collapsed Data . values ( ) ) { Collection < Graph Node > master Nodes = Lists . new Array List ( ) ; master Data . add Member Nodes ( master Nodes ) ; for ( Graph Node child Node : master Nodes ) { result . put ( child Node , master Data . get Master Node ( ) ) ; } } return result ; }
public void delete On Query ( final Token Filter filter ) throws Core Token Exception , Illegal Argument Exception { filter . add Return Attribute ( Core Token Field . TOKEN ID ) ; Result Handler < Collection < Partial Token > , Core Token Exception > handler = handler Factory . get Delete On Query Handler ( ) ; try { attribute Query With Handler ( filter , handler ) ; } catch ( Core Token Exception e ) { throw new Query Failed Exception ( filter , e ) ; } }
public void delete On Query ( final Token Filter filter ) throws Core Token Exception , Illegal Argument Exception { filter . add Return Attribute ( Core Token Field . TOKEN ID ) ; Result Handler < Collection < Partial Token > , Core Token Exception > handler = handler Factory . get Delete On Query Handler ( ) ; try { attribute Query With Handler ( filter , handler ) ; } catch ( Core Token Exception e ) { throw new Query Failed Exception ( filter , e ) ; } }
public void delete On Query ( final Token Filter filter ) throws Core Token Exception , Illegal Argument Exception { filter . add Return Attribute ( Core Token Field . TOKEN ID ) ; Result Handler < Collection < Partial Token > , Core Token Exception > handler = handler Factory . get Delete On Query Handler ( ) ; try { attribute Query With Handler ( filter , handler ) ; } catch ( Core Token Exception e ) { throw new Query Failed Exception ( filter , e ) ; } }
public void delete On Query ( final Token Filter filter ) throws Core Token Exception , Illegal Argument Exception { filter . add Return Attribute ( Core Token Field . TOKEN ID ) ; Result Handler < Collection < Partial Token > , Core Token Exception > handler = handler Factory . get Delete On Query Handler ( ) ; try { attribute Query With Handler ( filter , handler ) ; } catch ( Core Token Exception e ) { throw new Query Failed Exception ( filter , e ) ; } }
public static void write String ASCII ( Byte Buf stream , String str ) throws Unsupported Encoding Exception { final byte [ ] bytes = str . get Bytes ( STRING ) ; stream . write Int ( str . length ( ) ) ; stream . write Bytes ( bytes ) ; }
public static < T > Combined Download Task < T > single ( Download Task < T > task ) { Objects . require Non Null ( task ) ; return new Single Combined Task < T > ( task ) ; }
public void write Results ( Print Stream out ) { logger . info ( String . format ( STRING , output Format . to String ( ) ) ) ; Collections . sort ( effective Vocabulary , new Word Class Comparator ( word To Class ) ) ; for ( I String word : effective Vocabulary ) { int assignment = word To Class . get ( word ) ; if ( output Format == Output Format . TSV ) { out . printf ( STRING , word . to String ( ) , assignment ) ; } else if ( output Format == Output Format . SRILM ) { out . printf ( STRING , assignment , word . to String ( ) ) ; } } }
private byte [ ] entity To Bytes ( Http Entity entity ) throws IO Exception , Server Error { Pooling Byte Array Output Stream bytes = new Pooling Byte Array Output Stream ( m Pool , ( int ) entity . get Content Length ( ) ) ; byte [ ] buffer = null ; try { Input Stream in = entity . get Content ( ) ; if ( in == null ) { throw new Server Error ( ) ; } buffer = m Pool . get Buf ( NUM ) ; int count ; while ( ( count = in . read ( buffer ) ) != - NUM ) { bytes . write ( buffer , NUM , count ) ; } return bytes . to Byte Array ( ) ; } finally { try { entity . consume Content ( ) ; } catch ( IO Exception e ) { Volley Log . v ( STRING ) ; } m Pool . return Buf ( buffer ) ; bytes . close ( ) ; } }
@ Ignore @ Test public void test Set Base URL ( ) throws Parser Configuration Exception , SAX Exception , Malformed URL Exception { Config Manager config Manager = get Config Manager ( ) ; try { URL base URL 2 = new URL ( STRING ) ; config Manager . set Base Url ( base URL 2 ) ; fail ( ) ; } catch ( Invalid Config Exception e ) { } try { URL base URL 2 = new URL ( STRING ) ; config Manager . set Base Url ( base URL 2 ) ; fail ( ) ; } catch ( Invalid Config Exception e ) { } URL base URL = new URL ( STRING ) ; config Manager . set Base Url ( base URL ) ; assert Equals ( base URL . to String ( ) , app Config . get Property ( App Config . BASEURL ) ) ; }
@ Ignore @ Test public void test Set Base URL ( ) throws Parser Configuration Exception , SAX Exception , Malformed URL Exception { Config Manager config Manager = get Config Manager ( ) ; try { URL base URL 2 = new URL ( STRING ) ; config Manager . set Base Url ( base URL 2 ) ; fail ( ) ; } catch ( Invalid Config Exception e ) { } try { URL base URL 2 = new URL ( STRING ) ; config Manager . set Base Url ( base URL 2 ) ; fail ( ) ; } catch ( Invalid Config Exception e ) { } URL base URL = new URL ( STRING ) ; config Manager . set Base Url ( base URL ) ; assert Equals ( base URL . to String ( ) , app Config . get Property ( App Config . BASEURL ) ) ; }
public String apply ( Instance inst ) { for ( int i = NUM ; i < m selected Atts . length ; i ++ ) { if ( ! inst . is Missing ( m selected Atts [ i ] ) ) { String value = inst . string Value ( m selected Atts [ i ] ) ; String result = apply ( value ) ; if ( result != null ) { return result ; } } } return null ; }
public static boolean parse Boolean Param ( String value ) { if ( value == null ) { return BOOL ; } if ( value . equals Ignore Case ( STRING ) || value . equals ( STRING ) ) { return BOOL ; } return BOOL ; }
public static int round To Power Of Two ( final int value ) { return NUM << ( NUM - Integer . number Of Leading Zeros ( value - NUM ) ) ; }
public void animate ( Marker With Position marker , Lat Lng from , Lat Lng to ) { lock . lock ( ) ; m Animation Tasks . add ( new Animation Task ( marker , from , to ) ) ; lock . unlock ( ) ; }
public void animate ( Marker With Position marker , Lat Lng from , Lat Lng to ) { lock . lock ( ) ; m Animation Tasks . add ( new Animation Task ( marker , from , to ) ) ; lock . unlock ( ) ; }
protected void create Triple Buffer ( int width , int height ) { try { triple Buffer = mx Utils . create Buffered Image ( width , height , null ) ; triple Buffer Graphics = triple Buffer . create Graphics ( ) ; mx Utils . set Anti Alias ( triple Buffer Graphics , anti Alias , text Anti Alias ) ; repaint Triple Buffer ( null ) ; } catch ( Out Of Memory Error error ) { } }
protected void create Triple Buffer ( int width , int height ) { try { triple Buffer = mx Utils . create Buffered Image ( width , height , null ) ; triple Buffer Graphics = triple Buffer . create Graphics ( ) ; mx Utils . set Anti Alias ( triple Buffer Graphics , anti Alias , text Anti Alias ) ; repaint Triple Buffer ( null ) ; } catch ( Out Of Memory Error error ) { } }
protected void validate Current Time Between Since Until ( Factory Dto factory ) throws Bad Request Exception { final Policies Dto policies = factory . get Policies ( ) ; if ( policies == null ) { return ; } final Long since = policies . get Since ( ) == null ? NUM : policies . get Since ( ) ; final Long until = policies . get Until ( ) == null ? NUM : policies . get Until ( ) ; if ( since != NUM && current Time Millis ( ) < since ) { throw new Bad Request Exception ( Factory Constants . ILLEGAL FACTORY BY SINCE MESSAGE ) ; } if ( until != NUM && current Time Millis ( ) > until ) { throw new Bad Request Exception ( Factory Constants . ILLEGAL FACTORY BY UNTIL MESSAGE ) ; } }
public static Gas register ( Gas gas ) { if ( gas == null ) { return null ; } registered Gasses . add ( gas ) ; return get Gas ( gas . get Name ( ) ) ; }
@ Override public int on Start Command ( Intent intent , int flags , int start Id ) { Log OC . d ( TAG , STRING + start Id ) ; if ( ! intent . has Extra ( EXTRA ACCOUNT ) || ! intent . has Extra ( EXTRA FILE ) ) { Log OC . e ( TAG , STRING ) ; return START NOT STICKY ; } else { final Account account = intent . get Parcelable Extra ( EXTRA ACCOUNT ) ; final OC File file = intent . get Parcelable Extra ( EXTRA FILE ) ; Abstract List < String > requested Downloads = new Vector < > ( ) ; try { Download File Operation new Download = new Download File Operation ( account , file ) ; new Download . add Datatransfer Progress Listener ( this ) ; new Download . add Datatransfer Progress Listener ( ( File Downloader Binder ) m Binder ) ; Pair < String , String > put Result = m Pending Downloads . put If Absent ( account , file . get Remote Path ( ) , new Download ) ; String download Key = put Result . first ; requested Downloads . add ( download Key ) ; send Broadcast New Download ( new Download , put Result . second ) ; } catch ( Illegal Argument Exception e ) { Log OC . e ( TAG , STRING + e . get Message ( ) ) ; return START NOT STICKY ; } if ( requested Downloads . size ( ) > NUM ) { Message msg = m Service Handler . obtain Message ( ) ; msg . arg 1 = start Id ; msg . obj = requested Downloads ; m Service Handler . send Message ( msg ) ; } } return START NOT STICKY ; }
@ Override public int on Start Command ( Intent intent , int flags , int start Id ) { Log OC . d ( TAG , STRING + start Id ) ; if ( ! intent . has Extra ( EXTRA ACCOUNT ) || ! intent . has Extra ( EXTRA FILE ) ) { Log OC . e ( TAG , STRING ) ; return START NOT STICKY ; } else { final Account account = intent . get Parcelable Extra ( EXTRA ACCOUNT ) ; final OC File file = intent . get Parcelable Extra ( EXTRA FILE ) ; Abstract List < String > requested Downloads = new Vector < > ( ) ; try { Download File Operation new Download = new Download File Operation ( account , file ) ; new Download . add Datatransfer Progress Listener ( this ) ; new Download . add Datatransfer Progress Listener ( ( File Downloader Binder ) m Binder ) ; Pair < String , String > put Result = m Pending Downloads . put If Absent ( account , file . get Remote Path ( ) , new Download ) ; String download Key = put Result . first ; requested Downloads . add ( download Key ) ; send Broadcast New Download ( new Download , put Result . second ) ; } catch ( Illegal Argument Exception e ) { Log OC . e ( TAG , STRING + e . get Message ( ) ) ; return START NOT STICKY ; } if ( requested Downloads . size ( ) > NUM ) { Message msg = m Service Handler . obtain Message ( ) ; msg . arg 1 = start Id ; msg . obj = requested Downloads ; m Service Handler . send Message ( msg ) ; } } return START NOT STICKY ; }
@ Override public int on Start Command ( Intent intent , int flags , int start Id ) { Log OC . d ( TAG , STRING + start Id ) ; if ( ! intent . has Extra ( EXTRA ACCOUNT ) || ! intent . has Extra ( EXTRA FILE ) ) { Log OC . e ( TAG , STRING ) ; return START NOT STICKY ; } else { final Account account = intent . get Parcelable Extra ( EXTRA ACCOUNT ) ; final OC File file = intent . get Parcelable Extra ( EXTRA FILE ) ; Abstract List < String > requested Downloads = new Vector < > ( ) ; try { Download File Operation new Download = new Download File Operation ( account , file ) ; new Download . add Datatransfer Progress Listener ( this ) ; new Download . add Datatransfer Progress Listener ( ( File Downloader Binder ) m Binder ) ; Pair < String , String > put Result = m Pending Downloads . put If Absent ( account , file . get Remote Path ( ) , new Download ) ; String download Key = put Result . first ; requested Downloads . add ( download Key ) ; send Broadcast New Download ( new Download , put Result . second ) ; } catch ( Illegal Argument Exception e ) { Log OC . e ( TAG , STRING + e . get Message ( ) ) ; return START NOT STICKY ; } if ( requested Downloads . size ( ) > NUM ) { Message msg = m Service Handler . obtain Message ( ) ; msg . arg 1 = start Id ; msg . obj = requested Downloads ; m Service Handler . send Message ( msg ) ; } } return START NOT STICKY ; }
void free Ref Count Info ( Long address ) { if ( ! track Reference Counts ( ) ) return ; List < Ref Count Change Info > freed Info = stacktraces . remove ( address ) ; if ( freed Info == LOCKED ) { Memory Allocator Impl . debug Log ( STRING + Long . to Hex String ( address ) , BOOL ) ; } else if ( track Freed Reference Counts ( ) ) { if ( freed Info != null ) { freed Stacktraces . put ( address , freed Info ) ; } else { freed Stacktraces . remove ( address ) ; } } }
private void show Filter Dialog ( Filter filter ) { int sort Order = m Adapter . get Count ( ) - NUM ; if ( filter == null ) { Edit Filter Activity . create New Filter ( get Activity ( ) , sort Order ) ; } else { Edit Filter Activity . edit Filter ( get Activity ( ) , filter , sort Order ) ; } }
public void test Encode ( ) throws Stun Exception { byte [ ] expected Return = msg Fixture . err Code Test Value ; error Code Attribute . set Error Class ( Msg Fixture . ERROR CLASS ) ; error Code Attribute . set Error Number ( Msg Fixture . ERROR NUMBER ) ; error Code Attribute . set Reason Phrase ( Msg Fixture . REASON PHRASE ) ; byte [ ] actual Return = error Code Attribute . encode ( ) ; assert True ( STRING , Arrays . equals ( expected Return , actual Return ) ) ; }
public void remove ( String key ) { put ( key , null ) ; }
public void remove ( String key ) { put ( key , null ) ; }
public void remove ( String key ) { put ( key , null ) ; }
public void remove Rtcp Listener ( Rtcp Event Listener listener ) { listeners . remove Element ( listener ) ; }
public Relationship Builder add Columns ( Column from Col , Column to Col ) { return add Columns ( from Col . get Name ( ) , to Col . get Name ( ) ) ; }
private void update FS Export ( File Share fs Obj , Db Client db Client , VN Xe Api Client api Client , File Export new Export ) { logger . info ( STRING ) ; FS Export Map exports = fs Obj . get Fs Exports ( ) ; if ( exports == null ) { exports = new FS Export Map ( ) ; } VN Xe Nfs Share nfs Share = api Client . find Nfs Share ( fs Obj . get Native Id ( ) , share Name ) ; String nfs Share Id = nfs Share . get Id ( ) ; new Export . set Isilon Id ( nfs Share Id ) ; exports . put ( new Export . get File Export Key ( ) , new Export ) ; fs Obj . set Fs Exports ( exports ) ; update Export Rules ( fs Obj . get Id ( ) , new Export , db Client ) ; db Client . persist Object ( fs Obj ) ; }
private void wait For Errors ( Write Stream Old error , Input Stream input Stream , Input Stream error Stream ) throws IO Exception { byte [ ] buffer = new byte [ NUM ] ; int stderr Len = NUM ; int stdout Len = NUM ; if ( input Stream == null || error Stream == null ) return ; do { if ( ( stderr Len = error Stream . available ( ) ) > NUM ) { stderr Len = error Stream . read ( buffer , NUM , buffer . length ) ; if ( stderr Len > NUM ) { error . write ( buffer , NUM , stderr Len ) ; continue ; } } if ( ( stdout Len = input Stream . available ( ) ) > NUM ) { stdout Len = input Stream . read ( buffer , NUM , buffer . length ) ; if ( stdout Len > NUM ) { error . write ( buffer , NUM , stdout Len ) ; continue ; } } if ( stderr Len < NUM && stdout Len < NUM ) return ; stderr Len = error Stream . read ( buffer , NUM , buffer . length ) ; if ( stderr Len > NUM ) { error . write ( buffer , NUM , stderr Len ) ; continue ; } stdout Len = input Stream . read ( buffer , NUM , buffer . length ) ; if ( stdout Len > NUM ) { error . write ( buffer , NUM , stdout Len ) ; continue ; } } while ( ! is Dead && ( stderr Len >= NUM || stdout Len >= NUM ) ) ; }
public String login ( int AD Org ID , int AD Role ID , int AD User ID ) { Env . set Context ( Env . get Ctx ( ) , CTX Is Libero Enabled , BOOL ) ; return null ; }
protected int calculate Cycles ( int units Cycle , Big Decimal qty ) { Big Decimal cycles = qty ; Big Decimal units Cycle BD = Big Decimal . value Of ( units Cycle ) ; if ( units Cycle BD . signum ( ) > NUM ) { cycles = qty . divide ( units Cycle BD , NUM , Rounding Mode . UP ) ; } return cycles . int Value ( ) ; }
public static Comparable [ ] sort Copy ( Comparable [ ] objects ) { int len = objects . length ; Comparable [ ] copy = new Comparable [ len ] ; System . arraycopy ( objects , NUM , copy , NUM , len ) ; sort ( copy ) ; return copy ; }
private void queue Ready Jobs For Execution Locked H ( ) { Array Set < Job Status > jobs = m Jobs . get Jobs ( ) ; if ( DEBUG ) { } for ( int i = NUM ; i < jobs . size ( ) ; i ++ ) { Job Status job = jobs . value At ( i ) ; if ( is Ready To Be Executed Locked ( job ) ) { if ( DEBUG ) { } m Pending Jobs . add ( job ) ; } else if ( is Ready To Be Cancelled Locked ( job ) ) { stop Job On Service Context Locked ( job ) ; } } if ( DEBUG ) { final int queued Jobs = m Pending Jobs . size ( ) ; if ( queued Jobs == NUM ) { } else { } } }
private void queue Ready Jobs For Execution Locked H ( ) { Array Set < Job Status > jobs = m Jobs . get Jobs ( ) ; if ( DEBUG ) { } for ( int i = NUM ; i < jobs . size ( ) ; i ++ ) { Job Status job = jobs . value At ( i ) ; if ( is Ready To Be Executed Locked ( job ) ) { if ( DEBUG ) { } m Pending Jobs . add ( job ) ; } else if ( is Ready To Be Cancelled Locked ( job ) ) { stop Job On Service Context Locked ( job ) ; } } if ( DEBUG ) { final int queued Jobs = m Pending Jobs . size ( ) ; if ( queued Jobs == NUM ) { } else { } } }
private void validate Initiator Data ( Initiator initiator , Export Group export Group ) { validate Port Connectivity ( export Group , Collections . singleton List ( initiator ) ) ; }
public static Http 2 Headers to Netty Http 2 ( Http Headers input Headers ) { final Http 2 Headers output Headers = new Default Http 2 Headers ( BOOL , input Headers . size ( ) ) ; output Headers . set ( input Headers ) ; output Headers . remove ( Http Header Names . CONNECTION ) ; output Headers . remove ( Http Header Names . TRANSFER ENCODING ) ; output Headers . remove ( Http Header Names . TRAILER ) ; return output Headers ; }
public static Http 2 Headers to Netty Http 2 ( Http Headers input Headers ) { final Http 2 Headers output Headers = new Default Http 2 Headers ( BOOL , input Headers . size ( ) ) ; output Headers . set ( input Headers ) ; output Headers . remove ( Http Header Names . CONNECTION ) ; output Headers . remove ( Http Header Names . TRANSFER ENCODING ) ; output Headers . remove ( Http Header Names . TRAILER ) ; return output Headers ; }
private String uniquify ( String label ) { return label . replace All ( STRING , STRING ) ; }
private String uniquify ( String label ) { return label . replace All ( STRING , STRING ) ; }
public static boolean is Toshiba ( ) { return s Build Model . starts With ( STRING ) ; }
public static boolean is Toshiba ( ) { return s Build Model . starts With ( STRING ) ; }
public static String remove All ( String source , String str To Remove ) { int to Remove Index = source . index Of ( str To Remove ) ; if ( to Remove Index != - NUM ) { String Builder result = new String Builder ( source . length ( ) ) ; int source Index = NUM ; while ( to Remove Index != - NUM ) { result . append ( source . substring ( source Index , to Remove Index ) ) ; source Index = to Remove Index + str To Remove . length ( ) ; to Remove Index = source . index Of ( str To Remove , source Index ) ; if ( to Remove Index == - NUM ) { result . append ( source . substring ( source Index , source . length ( ) ) ) ; } } return result . to String ( ) ; } else { return source ; } }
@ Override public Iterator < Database > iterator ( ) { return m databases . iterator ( ) ; }
private static synchronized String make Date String ( Date date ) { return sdf Default . format ( date ) ; }
public Decimal add ( Decimal decimal ) { assert Defined ( ) ; if ( null == m value ) { if ( null == decimal . get Big Decimal Value ( ) ) { return new Decimal ( SCALE ) ; } else { return new Decimal ( decimal . get Big Decimal Value ( ) , SCALE ) ; } } Big Decimal value = m value . add ( decimal . get Big Decimal Value ( ) ) ; return new Decimal ( value , SCALE ) ; }
public static void register Info Listener ( Info Listener l ) { info Listeners . add ( l ) ; }
public static void register Info Listener ( Info Listener l ) { info Listeners . add ( l ) ; }
public static void register Info Listener ( Info Listener l ) { info Listeners . add ( l ) ; }
public static void register Info Listener ( Info Listener l ) { info Listeners . add ( l ) ; }
public static void register Info Listener ( Info Listener l ) { info Listeners . add ( l ) ; }
public static void register Info Listener ( Info Listener l ) { info Listeners . add ( l ) ; }
public static void register Info Listener ( Info Listener l ) { info Listeners . add ( l ) ; }
@ Override public void error ( String msg , Throwable t ) { if ( logger . is Loggable ( Level . SEVERE ) ) { log ( SELF , Level . SEVERE , msg , t ) ; } }
private void skip To End Of Line ( ) { for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . char At ( pos ) ; if ( c == STRING || c == STRING ) { pos ++ ; break ; } } }
private void skip To End Of Line ( ) { for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . char At ( pos ) ; if ( c == STRING || c == STRING ) { pos ++ ; break ; } } }
public void test Merge One Servlet Into Document With Another Servlet ( ) throws Exception { String src Xml = STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml src Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( src Xml . get Bytes ( STRING ) ) , null ) ; String merge Xml = STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml merge Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( merge Xml . get Bytes ( STRING ) ) , null ) ; Web Xml Merger merger = new Web Xml Merger ( src Web Xml ) ; merger . merge ( merge Web Xml ) ; assert True ( Web Xml Utils . has Servlet ( src Web Xml , STRING ) ) ; assert True ( Web Xml Utils . has Servlet ( src Web Xml , STRING ) ) ; }
private I Build Query Result query Builds ( final TFS Team Project Collection connection , final String build Name , final String team Project , final Build Status status ) { Check . not Null ( connection , STRING ) ; Check . not Null Or Empty ( build Name , STRING ) ; Check . not Null Or Empty ( team Project , STRING ) ; final I Build Server build Server = connection . get Build Server ( ) ; final I Build Detail Spec build Detail Spec = build Server . create Build Detail Spec ( team Project ) ; build Detail Spec . set Build Number ( build Name ) ; build Detail Spec . set Information Types ( new String [ ] { Information Types . CHECK IN OUTCOME } ) ; if ( status != null ) { build Detail Spec . set Status ( status ) ; } return build Server . query Builds ( build Detail Spec ) ; }
private I Build Query Result query Builds ( final TFS Team Project Collection connection , final String build Name , final String team Project , final Build Status status ) { Check . not Null ( connection , STRING ) ; Check . not Null Or Empty ( build Name , STRING ) ; Check . not Null Or Empty ( team Project , STRING ) ; final I Build Server build Server = connection . get Build Server ( ) ; final I Build Detail Spec build Detail Spec = build Server . create Build Detail Spec ( team Project ) ; build Detail Spec . set Build Number ( build Name ) ; build Detail Spec . set Information Types ( new String [ ] { Information Types . CHECK IN OUTCOME } ) ; if ( status != null ) { build Detail Spec . set Status ( status ) ; } return build Server . query Builds ( build Detail Spec ) ; }
public static double bernoullis ( double n , double k , double success Prob ) { double combo = Math Utils . combination ( n , k ) ; double q = NUM - success Prob ; return combo * Math . pow ( success Prob , k ) * Math . pow ( q , n - k ) ; }
public static double bernoullis ( double n , double k , double success Prob ) { double combo = Math Utils . combination ( n , k ) ; double q = NUM - success Prob ; return combo * Math . pow ( success Prob , k ) * Math . pow ( q , n - k ) ; }
public static double bernoullis ( double n , double k , double success Prob ) { double combo = Math Utils . combination ( n , k ) ; double q = NUM - success Prob ; return combo * Math . pow ( success Prob , k ) * Math . pow ( q , n - k ) ; }
private static String remove Trailing Space ( String raw ) { char c ; int i = raw . length ( ) - NUM ; for ( ; i >= NUM ; i -- ) { c = raw . char At ( i ) ; if ( c != STRING && c != STRING ) { break ; } } return raw . substring ( NUM , i + NUM ) ; }
protected Action update Action ( Action action , String name , String icon , String accel , Character mnemonic ) { Action result ; if ( action == null ) { result = m Actions . get ( name ) ; return result ; } result = action ; if ( ( name != null ) && ( name . length ( ) > NUM ) ) result . put Value ( Action . NAME , name ) ; if ( ( icon != null ) && ( icon . length ( ) > NUM ) ) result . put Value ( Action . SMALL ICON , Component Helper . get Image Icon ( icon ) ) ; if ( ( accel != null ) && ( accel . length ( ) > NUM ) ) result . put Value ( Action . ACCELERATOR KEY , Key Stroke . get Key Stroke ( accel ) ) ; if ( mnemonic != null ) result . put Value ( Action . MNEMONIC KEY , new Integer ( mnemonic . char Value ( ) ) ) ; return result ; }
private Boolean filter Existing Items ( List < Post Item > post Items , Post Item item ) { if ( post Items . contains ( item ) ) { int i = post Items . index Of ( item ) ; post Items . remove ( i ) ; post Items . add ( i , item ) ; return BOOL ; } return BOOL ; }
private Boolean filter Existing Items ( List < Post Item > post Items , Post Item item ) { if ( post Items . contains ( item ) ) { int i = post Items . index Of ( item ) ; post Items . remove ( i ) ; post Items . add ( i , item ) ; return BOOL ; } return BOOL ; }
private Boolean filter Existing Items ( List < Post Item > post Items , Post Item item ) { if ( post Items . contains ( item ) ) { int i = post Items . index Of ( item ) ; post Items . remove ( i ) ; post Items . add ( i , item ) ; return BOOL ; } return BOOL ; }
private Boolean filter Existing Items ( List < Post Item > post Items , Post Item item ) { if ( post Items . contains ( item ) ) { int i = post Items . index Of ( item ) ; post Items . remove ( i ) ; post Items . add ( i , item ) ; return BOOL ; } return BOOL ; }
public static void begin ( Servlet Request request , Servlet Response response , String service Name , String object Id ) throws Servlet Exception { Service Context context = ( Service Context ) local Context . get ( ) ; if ( context == null ) { context = new Service Context ( ) ; local Context . set ( context ) ; } context . request = request ; context . response = response ; context . service Name = service Name ; context . object Id = object Id ; context . count ++ ; }
public Result Set execute Query ( String query ) throws SQL Exception , No Connection Exception { if ( connection != null ) { Statement st = connection . create Statement ( ) ; return st . execute Query ( query ) ; } throw new No Connection Exception ( ) ; }
protected double compute Std Dev ( Instance inst , Matrix k ) throws Exception { double kappa = m kernel . eval ( - NUM , - NUM , inst ) + m delta Squared ; double s = NUM ; int n = m L . length ; for ( int i = NUM ; i < n ; i ++ ) { double t = NUM ; for ( int j = NUM ; j < n ; j ++ ) { t -= k . get ( j , NUM ) * ( i > j ? m L [ i ] [ j ] : m L [ j ] [ i ] ) ; } s += t * k . get ( i , NUM ) ; } double sigma = m delta ; if ( kappa > s ) { sigma = Math . sqrt ( kappa - s ) ; } return sigma ; }
private static byte [ ] stream To Bytes ( Input Stream in , int length ) throws IO Exception { byte [ ] bytes = new byte [ length ] ; int count ; int pos = NUM ; while ( pos < length && ( ( count = in . read ( bytes , pos , length - pos ) ) != - NUM ) ) { pos += count ; } if ( pos != length ) { throw new IO Exception ( STRING + length + STRING + pos + STRING ) ; } return bytes ; }
public static Search Scope value Of ( final int int Value ) { Search Scope result = null ; if ( NUM <= int Value && int Value < ELEMENTS . length ) { result = ELEMENTS [ int Value ] ; } if ( result == null ) { result = new Search Scope ( int Value , STRING + int Value + STRING , Enum . UNKNOWN ) ; } return result ; }
public static Search Scope value Of ( final int int Value ) { Search Scope result = null ; if ( NUM <= int Value && int Value < ELEMENTS . length ) { result = ELEMENTS [ int Value ] ; } if ( result == null ) { result = new Search Scope ( int Value , STRING + int Value + STRING , Enum . UNKNOWN ) ; } return result ; }
public boolean is Palindrome ( String s ) { if ( s == null || s . length ( ) == NUM ) { return BOOL ; } int i = NUM ; int j = s . length ( ) - NUM ; s = s . to Lower Case ( ) ; while ( i < j ) { while ( i < j && ! Character . is Letter Or Digit ( s . char At ( i ) ) ) { i ++ ; } if ( i >= j ) { return BOOL ; } while ( i < j && ! Character . is Letter Or Digit ( s . char At ( j ) ) ) { j -- ; } if ( s . char At ( i ) != s . char At ( j ) ) { return BOOL ; } i ++ ; j -- ; } return BOOL ; }
public boolean is Palindrome ( String s ) { if ( s == null || s . length ( ) == NUM ) { return BOOL ; } int i = NUM ; int j = s . length ( ) - NUM ; s = s . to Lower Case ( ) ; while ( i < j ) { while ( i < j && ! Character . is Letter Or Digit ( s . char At ( i ) ) ) { i ++ ; } if ( i >= j ) { return BOOL ; } while ( i < j && ! Character . is Letter Or Digit ( s . char At ( j ) ) ) { j -- ; } if ( s . char At ( i ) != s . char At ( j ) ) { return BOOL ; } i ++ ; j -- ; } return BOOL ; }
public boolean is Palindrome ( String s ) { if ( s == null || s . length ( ) == NUM ) { return BOOL ; } int i = NUM ; int j = s . length ( ) - NUM ; s = s . to Lower Case ( ) ; while ( i < j ) { while ( i < j && ! Character . is Letter Or Digit ( s . char At ( i ) ) ) { i ++ ; } if ( i >= j ) { return BOOL ; } while ( i < j && ! Character . is Letter Or Digit ( s . char At ( j ) ) ) { j -- ; } if ( s . char At ( i ) != s . char At ( j ) ) { return BOOL ; } i ++ ; j -- ; } return BOOL ; }
public boolean is Palindrome ( String s ) { if ( s == null || s . length ( ) == NUM ) { return BOOL ; } int i = NUM ; int j = s . length ( ) - NUM ; s = s . to Lower Case ( ) ; while ( i < j ) { while ( i < j && ! Character . is Letter Or Digit ( s . char At ( i ) ) ) { i ++ ; } if ( i >= j ) { return BOOL ; } while ( i < j && ! Character . is Letter Or Digit ( s . char At ( j ) ) ) { j -- ; } if ( s . char At ( i ) != s . char At ( j ) ) { return BOOL ; } i ++ ; j -- ; } return BOOL ; }
public boolean is Palindrome ( String s ) { if ( s == null || s . length ( ) == NUM ) { return BOOL ; } int i = NUM ; int j = s . length ( ) - NUM ; s = s . to Lower Case ( ) ; while ( i < j ) { while ( i < j && ! Character . is Letter Or Digit ( s . char At ( i ) ) ) { i ++ ; } if ( i >= j ) { return BOOL ; } while ( i < j && ! Character . is Letter Or Digit ( s . char At ( j ) ) ) { j -- ; } if ( s . char At ( i ) != s . char At ( j ) ) { return BOOL ; } i ++ ; j -- ; } return BOOL ; }
public boolean is Palindrome ( String s ) { if ( s == null || s . length ( ) == NUM ) { return BOOL ; } int i = NUM ; int j = s . length ( ) - NUM ; s = s . to Lower Case ( ) ; while ( i < j ) { while ( i < j && ! Character . is Letter Or Digit ( s . char At ( i ) ) ) { i ++ ; } if ( i >= j ) { return BOOL ; } while ( i < j && ! Character . is Letter Or Digit ( s . char At ( j ) ) ) { j -- ; } if ( s . char At ( i ) != s . char At ( j ) ) { return BOOL ; } i ++ ; j -- ; } return BOOL ; }
public static Char Sequence comments ( String comments ) { return Html . from Html ( comments . replace ( STRING , STRING ) ) ; }
public Token next ( ) throws IO Exception { skip Whitespace ( ) ; int c = reader . read ( ) ; if ( c < NUM ) { return new Token ( Token . EOF ) ; } else if ( c == STRING ) { return new Token ( Token . EOL ) ; } else if ( c == STRING || c == STRING ) { return munch String ( c ) ; } else if ( c == STRING ) { return maybe Comment ( ) ; } else if ( single . get ( c ) ) { return new Token ( Token . SINGLE , String . value Of ( ( char ) c ) ) ; } else { reader . unread ( c ) ; return parse Word ( ) ; } }
public Wiser ( ) { this . server = new SMTP Server ( new Simple Message Listener Adapter ( this ) ) ; }
private static String massage URI ( String uri ) { uri = uri . trim ( ) ; int protocol End = uri . index Of ( STRING ) ; if ( protocol End < NUM ) { uri = STRING + uri ; } else if ( is Colon Followed By Port Number ( uri , protocol End ) ) { uri = STRING + uri ; } return uri ; }
private static String massage URI ( String uri ) { uri = uri . trim ( ) ; int protocol End = uri . index Of ( STRING ) ; if ( protocol End < NUM ) { uri = STRING + uri ; } else if ( is Colon Followed By Port Number ( uri , protocol End ) ) { uri = STRING + uri ; } return uri ; }
private static String massage URI ( String uri ) { uri = uri . trim ( ) ; int protocol End = uri . index Of ( STRING ) ; if ( protocol End < NUM ) { uri = STRING + uri ; } else if ( is Colon Followed By Port Number ( uri , protocol End ) ) { uri = STRING + uri ; } return uri ; }
public static boolean equals ( Collection < ? > actual , Object ... reference ) { final Collection < Object > collection = new Hash Set < > ( ) ; Collections . add All ( collection , reference ) ; if ( actual == collection ) { return BOOL ; } if ( actual == null ) { return BOOL ; } if ( actual . size ( ) != collection . size ( ) ) { log . warn ( STRING + actual . size ( ) + STRING + collection . size ( ) ) ; return BOOL ; } for ( Object object : actual ) { if ( ! collection . contains ( object ) ) { log . warn ( STRING + object ) ; return BOOL ; } } for ( Object object : collection ) { if ( ! actual . contains ( object ) ) { log . warn ( STRING + object ) ; return BOOL ; } } return BOOL ; }
public static boolean equals ( Collection < ? > actual , Object ... reference ) { final Collection < Object > collection = new Hash Set < > ( ) ; Collections . add All ( collection , reference ) ; if ( actual == collection ) { return BOOL ; } if ( actual == null ) { return BOOL ; } if ( actual . size ( ) != collection . size ( ) ) { log . warn ( STRING + actual . size ( ) + STRING + collection . size ( ) ) ; return BOOL ; } for ( Object object : actual ) { if ( ! collection . contains ( object ) ) { log . warn ( STRING + object ) ; return BOOL ; } } for ( Object object : collection ) { if ( ! actual . contains ( object ) ) { log . warn ( STRING + object ) ; return BOOL ; } } return BOOL ; }
public static boolean equals ( Collection < ? > actual , Object ... reference ) { final Collection < Object > collection = new Hash Set < > ( ) ; Collections . add All ( collection , reference ) ; if ( actual == collection ) { return BOOL ; } if ( actual == null ) { return BOOL ; } if ( actual . size ( ) != collection . size ( ) ) { log . warn ( STRING + actual . size ( ) + STRING + collection . size ( ) ) ; return BOOL ; } for ( Object object : actual ) { if ( ! collection . contains ( object ) ) { log . warn ( STRING + object ) ; return BOOL ; } } for ( Object object : collection ) { if ( ! actual . contains ( object ) ) { log . warn ( STRING + object ) ; return BOOL ; } } return BOOL ; }
public static boolean equals ( Collection < ? > actual , Object ... reference ) { final Collection < Object > collection = new Hash Set < > ( ) ; Collections . add All ( collection , reference ) ; if ( actual == collection ) { return BOOL ; } if ( actual == null ) { return BOOL ; } if ( actual . size ( ) != collection . size ( ) ) { log . warn ( STRING + actual . size ( ) + STRING + collection . size ( ) ) ; return BOOL ; } for ( Object object : actual ) { if ( ! collection . contains ( object ) ) { log . warn ( STRING + object ) ; return BOOL ; } } for ( Object object : collection ) { if ( ! actual . contains ( object ) ) { log . warn ( STRING + object ) ; return BOOL ; } } return BOOL ; }
public static boolean equals ( Collection < ? > actual , Object ... reference ) { final Collection < Object > collection = new Hash Set < > ( ) ; Collections . add All ( collection , reference ) ; if ( actual == collection ) { return BOOL ; } if ( actual == null ) { return BOOL ; } if ( actual . size ( ) != collection . size ( ) ) { log . warn ( STRING + actual . size ( ) + STRING + collection . size ( ) ) ; return BOOL ; } for ( Object object : actual ) { if ( ! collection . contains ( object ) ) { log . warn ( STRING + object ) ; return BOOL ; } } for ( Object object : collection ) { if ( ! actual . contains ( object ) ) { log . warn ( STRING + object ) ; return BOOL ; } } return BOOL ; }
private void save Log File ( License license , Properties props ) { File log File = get Log File ( license ) ; logger . fine ( STRING + props ) ; try { final Output Stream out = new File Output Stream ( log File ) ; try { props . store ( out , String . format ( LOG HEADER , new Date ( ) ) ) ; } finally { out . close ( ) ; } } catch ( IO Exception ex ) { logger . log ( Level . SEVERE , STRING + log File . get Absolute Path ( ) , ex ) ; } }
@ Override public Object deserialize With Type ( Json Parser jp , Deserialization Context ctxt , Type Deserializer type Deserializer ) throws IO Exception , Json Processing Exception { switch ( jp . get Current Token ( ) ) { case VALUE NUMBER INT : case VALUE NUMBER FLOAT : case VALUE STRING : return deserialize ( jp , ctxt ) ; } return type Deserializer . deserialize Typed From Scalar ( jp , ctxt ) ; }
@ Override public Object deserialize With Type ( Json Parser jp , Deserialization Context ctxt , Type Deserializer type Deserializer ) throws IO Exception , Json Processing Exception { switch ( jp . get Current Token ( ) ) { case VALUE NUMBER INT : case VALUE NUMBER FLOAT : case VALUE STRING : return deserialize ( jp , ctxt ) ; } return type Deserializer . deserialize Typed From Scalar ( jp , ctxt ) ; }
@ Override public Object deserialize With Type ( Json Parser jp , Deserialization Context ctxt , Type Deserializer type Deserializer ) throws IO Exception , Json Processing Exception { switch ( jp . get Current Token ( ) ) { case VALUE NUMBER INT : case VALUE NUMBER FLOAT : case VALUE STRING : return deserialize ( jp , ctxt ) ; } return type Deserializer . deserialize Typed From Scalar ( jp , ctxt ) ; }
@ Override public Object deserialize With Type ( Json Parser jp , Deserialization Context ctxt , Type Deserializer type Deserializer ) throws IO Exception , Json Processing Exception { switch ( jp . get Current Token ( ) ) { case VALUE NUMBER INT : case VALUE NUMBER FLOAT : case VALUE STRING : return deserialize ( jp , ctxt ) ; } return type Deserializer . deserialize Typed From Scalar ( jp , ctxt ) ; }
public List < Inet Address > discover Hosts ( int udp Port , int timeout Millis ) { List < Inet Address > hosts = new Array List < Inet Address > ( ) ; Datagram Socket socket = null ; try { socket = new Datagram Socket ( ) ; broadcast ( udp Port , socket ) ; socket . set So Timeout ( timeout Millis ) ; while ( BOOL ) { Datagram Packet packet = new Datagram Packet ( new byte [ NUM ] , NUM ) ; try { socket . receive ( packet ) ; } catch ( Socket Timeout Exception ex ) { if ( INFO ) info ( STRING , STRING ) ; return hosts ; } if ( INFO ) info ( STRING , STRING + packet . get Address ( ) ) ; hosts . add ( packet . get Address ( ) ) ; } } catch ( IO Exception ex ) { if ( ERROR ) error ( STRING , STRING , ex ) ; return hosts ; } finally { if ( socket != null ) socket . close ( ) ; } }
public List < Inet Address > discover Hosts ( int udp Port , int timeout Millis ) { List < Inet Address > hosts = new Array List < Inet Address > ( ) ; Datagram Socket socket = null ; try { socket = new Datagram Socket ( ) ; broadcast ( udp Port , socket ) ; socket . set So Timeout ( timeout Millis ) ; while ( BOOL ) { Datagram Packet packet = new Datagram Packet ( new byte [ NUM ] , NUM ) ; try { socket . receive ( packet ) ; } catch ( Socket Timeout Exception ex ) { if ( INFO ) info ( STRING , STRING ) ; return hosts ; } if ( INFO ) info ( STRING , STRING + packet . get Address ( ) ) ; hosts . add ( packet . get Address ( ) ) ; } } catch ( IO Exception ex ) { if ( ERROR ) error ( STRING , STRING , ex ) ; return hosts ; } finally { if ( socket != null ) socket . close ( ) ; } }
public List < Inet Address > discover Hosts ( int udp Port , int timeout Millis ) { List < Inet Address > hosts = new Array List < Inet Address > ( ) ; Datagram Socket socket = null ; try { socket = new Datagram Socket ( ) ; broadcast ( udp Port , socket ) ; socket . set So Timeout ( timeout Millis ) ; while ( BOOL ) { Datagram Packet packet = new Datagram Packet ( new byte [ NUM ] , NUM ) ; try { socket . receive ( packet ) ; } catch ( Socket Timeout Exception ex ) { if ( INFO ) info ( STRING , STRING ) ; return hosts ; } if ( INFO ) info ( STRING , STRING + packet . get Address ( ) ) ; hosts . add ( packet . get Address ( ) ) ; } } catch ( IO Exception ex ) { if ( ERROR ) error ( STRING , STRING , ex ) ; return hosts ; } finally { if ( socket != null ) socket . close ( ) ; } }
protected ASN 1 Sequence ( ASN 1 Encodable [ ] array ) { for ( int i = NUM ; i != array . length ; i ++ ) { seq . add Element ( array [ i ] ) ; } }
protected ASN 1 Sequence ( ASN 1 Encodable [ ] array ) { for ( int i = NUM ; i != array . length ; i ++ ) { seq . add Element ( array [ i ] ) ; } }
protected ASN 1 Sequence ( ASN 1 Encodable [ ] array ) { for ( int i = NUM ; i != array . length ; i ++ ) { seq . add Element ( array [ i ] ) ; } }
private void handle Done Query ( final UUID query Id , final Future < Void > done Query Future ) { try { done Query Future . get ( ) ; throw new Interrupted Exception ( ) ; } catch ( Interrupted Exception e ) { throw new Runtime Exception ( e ) ; } catch ( Execution Exception e ) { throw new Runtime Exception ( e ) ; } }
private void handle Done Query ( final UUID query Id , final Future < Void > done Query Future ) { try { done Query Future . get ( ) ; throw new Interrupted Exception ( ) ; } catch ( Interrupted Exception e ) { throw new Runtime Exception ( e ) ; } catch ( Execution Exception e ) { throw new Runtime Exception ( e ) ; } }
public boolean equals ( Object o ) { return source . equals ( o ) ; }
public int compare ( Random Access Data o1 , Random Access Data o2 , int start Offset ) { if ( o1 == o2 ) { return NUM ; } if ( o1 == POSITIVE INFINITY ) { return NUM ; } if ( o2 == POSITIVE INFINITY ) { return - NUM ; } int min Bytes Len = Math . min ( o1 . size , o2 . size ) ; for ( int i = start Offset ; i < min Bytes Len ; i ++ ) { int b1 = o1 . buffer [ i ] & NUM ; int b2 = o2 . buffer [ i ] & NUM ; if ( b1 == b2 ) { continue ; } return b1 - b2 ; } return o1 . size - o2 . size ; }
@ Managed Operation ( description = STRING ) public void notify All Tag Cache Listeners ( ) { LOGGER . info ( STRING ) ; for ( Long key : control Tag Cache . get Keys ( ) ) { control Tag Cache . acquire Write Lock On Key ( key ) ; try { Control Tag control Tag = control Tag Cache . get Copy ( key ) ; long event Time = System . current Time Millis ( ) ; control Tag Cache . notify Listener Status Confirmation ( control Tag , event Time ) ; } finally { control Tag Cache . release Write Lock On Key ( key ) ; } } for ( Long key : data Tag Cache . get Keys ( ) ) { data Tag Cache . acquire Write Lock On Key ( key ) ; try { Data Tag data Tag = data Tag Cache . get Copy ( key ) ; long event Time = System . current Time Millis ( ) ; data Tag Cache . notify Listener Status Confirmation ( data Tag , event Time ) ; } finally { data Tag Cache . release Write Lock On Key ( key ) ; } } LOGGER . info ( STRING ) ; }
@ Managed Operation ( description = STRING ) public void notify All Tag Cache Listeners ( ) { LOGGER . info ( STRING ) ; for ( Long key : control Tag Cache . get Keys ( ) ) { control Tag Cache . acquire Write Lock On Key ( key ) ; try { Control Tag control Tag = control Tag Cache . get Copy ( key ) ; long event Time = System . current Time Millis ( ) ; control Tag Cache . notify Listener Status Confirmation ( control Tag , event Time ) ; } finally { control Tag Cache . release Write Lock On Key ( key ) ; } } for ( Long key : data Tag Cache . get Keys ( ) ) { data Tag Cache . acquire Write Lock On Key ( key ) ; try { Data Tag data Tag = data Tag Cache . get Copy ( key ) ; long event Time = System . current Time Millis ( ) ; data Tag Cache . notify Listener Status Confirmation ( data Tag , event Time ) ; } finally { data Tag Cache . release Write Lock On Key ( key ) ; } } LOGGER . info ( STRING ) ; }
@ Managed Operation ( description = STRING ) public void notify All Tag Cache Listeners ( ) { LOGGER . info ( STRING ) ; for ( Long key : control Tag Cache . get Keys ( ) ) { control Tag Cache . acquire Write Lock On Key ( key ) ; try { Control Tag control Tag = control Tag Cache . get Copy ( key ) ; long event Time = System . current Time Millis ( ) ; control Tag Cache . notify Listener Status Confirmation ( control Tag , event Time ) ; } finally { control Tag Cache . release Write Lock On Key ( key ) ; } } for ( Long key : data Tag Cache . get Keys ( ) ) { data Tag Cache . acquire Write Lock On Key ( key ) ; try { Data Tag data Tag = data Tag Cache . get Copy ( key ) ; long event Time = System . current Time Millis ( ) ; data Tag Cache . notify Listener Status Confirmation ( data Tag , event Time ) ; } finally { data Tag Cache . release Write Lock On Key ( key ) ; } } LOGGER . info ( STRING ) ; }
@ Managed Operation ( description = STRING ) public void notify All Tag Cache Listeners ( ) { LOGGER . info ( STRING ) ; for ( Long key : control Tag Cache . get Keys ( ) ) { control Tag Cache . acquire Write Lock On Key ( key ) ; try { Control Tag control Tag = control Tag Cache . get Copy ( key ) ; long event Time = System . current Time Millis ( ) ; control Tag Cache . notify Listener Status Confirmation ( control Tag , event Time ) ; } finally { control Tag Cache . release Write Lock On Key ( key ) ; } } for ( Long key : data Tag Cache . get Keys ( ) ) { data Tag Cache . acquire Write Lock On Key ( key ) ; try { Data Tag data Tag = data Tag Cache . get Copy ( key ) ; long event Time = System . current Time Millis ( ) ; data Tag Cache . notify Listener Status Confirmation ( data Tag , event Time ) ; } finally { data Tag Cache . release Write Lock On Key ( key ) ; } } LOGGER . info ( STRING ) ; }
private String [ ] parent Key ( String name , int idx ) { String [ ] parts = name . split ( STRING ) ; if ( idx > parts . length ) return null ; String parent = STRING ; String key = null ; if ( idx < parts . length ) key = parts [ idx ] ; for ( int i = NUM ; i < idx ; i ++ ) { parent = parent . length ( ) > NUM ? parent + STRING + parts [ i ] : parts [ i ] ; } return new String [ ] { parent , key } ; }
protected void long Key Press ( int key Code ) { }
public Outfit remove Outfit ( final Outfit other ) { int new Detail ; int new Hair ; int new Head ; int new Dress ; int new Body ; if ( ( detail == null ) || detail . equals ( other . detail ) ) { new Detail = NUM ; } else { new Detail = detail ; } if ( ( hair == null ) || hair . equals ( other . hair ) ) { new Hair = NUM ; } else { new Hair = hair ; } if ( ( head == null ) || head . equals ( other . head ) ) { new Head = NUM ; } else { new Head = head ; } if ( ( dress == null ) || dress . equals ( other . dress ) ) { new Dress = NUM ; } else { new Dress = dress ; } if ( ( body == null ) || body . equals ( other . body ) ) { new Body = NUM ; } else { new Body = body ; } return new Outfit ( new Detail , new Hair , new Head , new Dress , new Body ) ; }
public Outfit remove Outfit ( final Outfit other ) { int new Detail ; int new Hair ; int new Head ; int new Dress ; int new Body ; if ( ( detail == null ) || detail . equals ( other . detail ) ) { new Detail = NUM ; } else { new Detail = detail ; } if ( ( hair == null ) || hair . equals ( other . hair ) ) { new Hair = NUM ; } else { new Hair = hair ; } if ( ( head == null ) || head . equals ( other . head ) ) { new Head = NUM ; } else { new Head = head ; } if ( ( dress == null ) || dress . equals ( other . dress ) ) { new Dress = NUM ; } else { new Dress = dress ; } if ( ( body == null ) || body . equals ( other . body ) ) { new Body = NUM ; } else { new Body = body ; } return new Outfit ( new Detail , new Hair , new Head , new Dress , new Body ) ; }
public void add Action Listener ( Action Listener new A ) { m Listeners . add ( new A ) ; }
public static < T extends I Identifyable > List < T > check Ids ( @ Non Null List < T > items ) { for ( int i = NUM , size = items . size ( ) ; i < size ; i ++ ) { check Id ( items . get ( i ) ) ; } return items ; }
public static < T extends I Identifyable > List < T > check Ids ( @ Non Null List < T > items ) { for ( int i = NUM , size = items . size ( ) ; i < size ; i ++ ) { check Id ( items . get ( i ) ) ; } return items ; }
public static < T extends I Identifyable > List < T > check Ids ( @ Non Null List < T > items ) { for ( int i = NUM , size = items . size ( ) ; i < size ; i ++ ) { check Id ( items . get ( i ) ) ; } return items ; }
public static < T extends I Identifyable > List < T > check Ids ( @ Non Null List < T > items ) { for ( int i = NUM , size = items . size ( ) ; i < size ; i ++ ) { check Id ( items . get ( i ) ) ; } return items ; }
public static < T extends I Identifyable > List < T > check Ids ( @ Non Null List < T > items ) { for ( int i = NUM , size = items . size ( ) ; i < size ; i ++ ) { check Id ( items . get ( i ) ) ; } return items ; }
public void select Initial Value ( ) { Option Pane UI ui = get UI ( ) ; if ( ui != null ) { ui . select Initial Value ( this ) ; } }
public void select Initial Value ( ) { Option Pane UI ui = get UI ( ) ; if ( ui != null ) { ui . select Initial Value ( this ) ; } }
public void select Initial Value ( ) { Option Pane UI ui = get UI ( ) ; if ( ui != null ) { ui . select Initial Value ( this ) ; } }
public static Context create Context ( final Context c , final String path ) throws Naming Exception { Context crt Context = c ; for ( String Tokenizer st = new String Tokenizer ( path , STRING ) ; st . has More Tokens ( ) ; ) { String tok = st . next Token ( ) ; try { Object o = crt Context . lookup ( tok ) ; if ( ! ( o instanceof Context ) ) { throw new Naming Exception ( STRING + path + STRING ) ; } crt Context = ( Context ) o ; continue ; } catch ( Name Not Found Exception e ) { } crt Context = crt Context . create Subcontext ( tok ) ; } return crt Context ; }
public static Context create Context ( final Context c , final String path ) throws Naming Exception { Context crt Context = c ; for ( String Tokenizer st = new String Tokenizer ( path , STRING ) ; st . has More Tokens ( ) ; ) { String tok = st . next Token ( ) ; try { Object o = crt Context . lookup ( tok ) ; if ( ! ( o instanceof Context ) ) { throw new Naming Exception ( STRING + path + STRING ) ; } crt Context = ( Context ) o ; continue ; } catch ( Name Not Found Exception e ) { } crt Context = crt Context . create Subcontext ( tok ) ; } return crt Context ; }
@ Override public boolean connection Allowed ( String event Name ) { return event Name . equals ( STRING ) || event Name . equals ( STRING ) || event Name . equals ( STRING ) ; }
@ Override public boolean connection Allowed ( String event Name ) { return event Name . equals ( STRING ) || event Name . equals ( STRING ) || event Name . equals ( STRING ) ; }
@ Override public boolean connection Allowed ( String event Name ) { return event Name . equals ( STRING ) || event Name . equals ( STRING ) || event Name . equals ( STRING ) ; }
@ Override public boolean connection Allowed ( String event Name ) { return event Name . equals ( STRING ) || event Name . equals ( STRING ) || event Name . equals ( STRING ) ; }
public void put All With Prefix ( Tungsten Properties props , String prefix ) { Tungsten Properties new Props = new Tungsten Properties ( ) ; if ( props . is Empty ( ) ) { new Props . set Object ( prefix , props ) ; } else { for ( String key : props . key Names ( ) ) { new Props . set Object ( prefix + key , props . get Object ( key ) ) ; } } put All ( new Props ) ; }
public Backwards File Stream ( File file ) throws IO Exception { raf = new Random Access File ( file , STRING ) ; seek Pos = raf . length ( ) ; }
public Char Sequence Filter add Matches Pattern ( String regular Expression , int flags ) { m Cached To String = null ; m Matches Pattern . add ( Pattern . compile ( regular Expression , flags ) ) ; return this ; }
@ Override public void key Typed ( Key Event e ) { synchronized ( key Lock ) { keys Typed . add First ( e . get Key Char ( ) ) ; } }
public void add Debugger ( final I Debugger debugger ) { debuggers . add ( Preconditions . check Not Null ( debugger , STRING ) ) ; for ( final Debugger Provider Listener listener : m listeners ) { try { listener . debugger Added ( this , debugger ) ; } catch ( final Exception exception ) { C Utility Functions . log Exception ( exception ) ; } } }
public int size ( ) { return listeners . size ( ) ; }
public static boolean is Absolute URI ( String system Id ) { if ( is Windows Absolute Path ( system Id ) ) { return BOOL ; } final int fragment Index = system Id . index Of ( STRING ) ; final int query Index = system Id . index Of ( STRING ) ; final int slash Index = system Id . index Of ( STRING ) ; final int colon Index = system Id . index Of ( STRING ) ; int index = system Id . length ( ) - NUM ; if ( fragment Index > NUM ) index = fragment Index ; if ( ( query Index > NUM ) && ( query Index < index ) ) index = query Index ; if ( ( slash Index > NUM ) && ( slash Index < index ) ) index = slash Index ; return ( ( colon Index > NUM ) && ( colon Index < index ) ) ; }
public static boolean is Absolute URI ( String system Id ) { if ( is Windows Absolute Path ( system Id ) ) { return BOOL ; } final int fragment Index = system Id . index Of ( STRING ) ; final int query Index = system Id . index Of ( STRING ) ; final int slash Index = system Id . index Of ( STRING ) ; final int colon Index = system Id . index Of ( STRING ) ; int index = system Id . length ( ) - NUM ; if ( fragment Index > NUM ) index = fragment Index ; if ( ( query Index > NUM ) && ( query Index < index ) ) index = query Index ; if ( ( slash Index > NUM ) && ( slash Index < index ) ) index = slash Index ; return ( ( colon Index > NUM ) && ( colon Index < index ) ) ; }
public final void on Dead ( final Killer killer ) { on Dead ( killer , BOOL ) ; }
public void line ( double x , double y ) { Line line = new Line ( x , y ) ; if ( x < min X ) { min X = x ; } if ( y < min Y ) { min Y = y ; } if ( x > max X ) { max X = x ; } if ( y > max Y ) { max Y = y ; } elements . add ( line ) ; }
protected static String normalize Url Ending ( String link ) { if ( link . index Of ( STRING ) > - NUM ) link = link . substring ( NUM , link . index Of ( STRING ) ) ; if ( link . ends With ( STRING ) ) link = link . substring ( NUM , link . length ( ) - NUM ) ; if ( link . ends With ( STRING ) ) link = link . substring ( NUM , link . length ( ) - NUM ) ; return link ; }
protected static String normalize Url Ending ( String link ) { if ( link . index Of ( STRING ) > - NUM ) link = link . substring ( NUM , link . index Of ( STRING ) ) ; if ( link . ends With ( STRING ) ) link = link . substring ( NUM , link . length ( ) - NUM ) ; if ( link . ends With ( STRING ) ) link = link . substring ( NUM , link . length ( ) - NUM ) ; return link ; }
protected static String normalize Url Ending ( String link ) { if ( link . index Of ( STRING ) > - NUM ) link = link . substring ( NUM , link . index Of ( STRING ) ) ; if ( link . ends With ( STRING ) ) link = link . substring ( NUM , link . length ( ) - NUM ) ; if ( link . ends With ( STRING ) ) link = link . substring ( NUM , link . length ( ) - NUM ) ; return link ; }
private String align ( final String data , final Alignment alignment , final int width ) { final String raw Data = data . trim ( ) ; final int padding = width - raw Data . length ( ) ; if ( padding <= NUM ) { return raw Data ; } switch ( alignment ) { case RIGHT : return pad ( padding , raw Data , NUM ) ; case LEFT : return pad ( NUM , raw Data , padding ) ; case CENTER : final int padding Before = padding / NUM ; return pad ( padding Before , raw Data , padding - padding Before ) ; default : return STRING ; } }
private boolean check Time Passed ( Follower Info info ) { Integer error Count = errors . get ( info . stream ) ; if ( error Count == null ) { error Count = NUM ; } if ( System . current Time Millis ( ) - info . time > REQUEST DELAY * NUM + ( REQUEST DELAY * NUM * ( error Count ) / NUM ) ) { return BOOL ; } return BOOL ; }
private boolean check Time Passed ( Follower Info info ) { Integer error Count = errors . get ( info . stream ) ; if ( error Count == null ) { error Count = NUM ; } if ( System . current Time Millis ( ) - info . time > REQUEST DELAY * NUM + ( REQUEST DELAY * NUM * ( error Count ) / NUM ) ) { return BOOL ; } return BOOL ; }
private boolean check Time Passed ( Follower Info info ) { Integer error Count = errors . get ( info . stream ) ; if ( error Count == null ) { error Count = NUM ; } if ( System . current Time Millis ( ) - info . time > REQUEST DELAY * NUM + ( REQUEST DELAY * NUM * ( error Count ) / NUM ) ) { return BOOL ; } return BOOL ; }
private boolean check Time Passed ( Follower Info info ) { Integer error Count = errors . get ( info . stream ) ; if ( error Count == null ) { error Count = NUM ; } if ( System . current Time Millis ( ) - info . time > REQUEST DELAY * NUM + ( REQUEST DELAY * NUM * ( error Count ) / NUM ) ) { return BOOL ; } return BOOL ; }
public void store ( Output Stream out , String header ) throws IO Exception { Print Writer writer = new Print Writer ( new Output Stream Writer ( out , STRING ) ) ; String line ; String key ; String Buffer s = new String Buffer ( ) ; for ( int i = NUM ; i < line Data . size ( ) ; i ++ ) { line = ( String ) line Data . get ( i ) ; key = ( String ) key Data . get ( i ) ; if ( key . length ( ) > NUM ) { format For Output ( key , s , BOOL ) ; s . append ( STRING ) ; format For Output ( ( String ) get ( key ) , s , BOOL ) ; writer . println ( s ) ; } else { writer . println ( line ) ; } } writer . flush ( ) ; }
public void store ( Output Stream out , String header ) throws IO Exception { Print Writer writer = new Print Writer ( new Output Stream Writer ( out , STRING ) ) ; String line ; String key ; String Buffer s = new String Buffer ( ) ; for ( int i = NUM ; i < line Data . size ( ) ; i ++ ) { line = ( String ) line Data . get ( i ) ; key = ( String ) key Data . get ( i ) ; if ( key . length ( ) > NUM ) { format For Output ( key , s , BOOL ) ; s . append ( STRING ) ; format For Output ( ( String ) get ( key ) , s , BOOL ) ; writer . println ( s ) ; } else { writer . println ( line ) ; } } writer . flush ( ) ; }
public void store ( Output Stream out , String header ) throws IO Exception { Print Writer writer = new Print Writer ( new Output Stream Writer ( out , STRING ) ) ; String line ; String key ; String Buffer s = new String Buffer ( ) ; for ( int i = NUM ; i < line Data . size ( ) ; i ++ ) { line = ( String ) line Data . get ( i ) ; key = ( String ) key Data . get ( i ) ; if ( key . length ( ) > NUM ) { format For Output ( key , s , BOOL ) ; s . append ( STRING ) ; format For Output ( ( String ) get ( key ) , s , BOOL ) ; writer . println ( s ) ; } else { writer . println ( line ) ; } } writer . flush ( ) ; }
public void store ( Output Stream out , String header ) throws IO Exception { Print Writer writer = new Print Writer ( new Output Stream Writer ( out , STRING ) ) ; String line ; String key ; String Buffer s = new String Buffer ( ) ; for ( int i = NUM ; i < line Data . size ( ) ; i ++ ) { line = ( String ) line Data . get ( i ) ; key = ( String ) key Data . get ( i ) ; if ( key . length ( ) > NUM ) { format For Output ( key , s , BOOL ) ; s . append ( STRING ) ; format For Output ( ( String ) get ( key ) , s , BOOL ) ; writer . println ( s ) ; } else { writer . println ( line ) ; } } writer . flush ( ) ; }
public static String request Next Message ( ) throws Interrupted Exception { synchronized ( request Lock ) { next Line Requested = BOOL ; request Lock . wait ( ) ; next Line Requested = BOOL ; return ln ; } }
public void release ( ) { if ( m Media Player != null ) { if ( m Media Player . is Playing ( ) ) { m Media Player . stop ( ) ; } m Media Player . reset ( ) ; m Media Player . release ( ) ; } m Media Player = null ; }
public void release ( ) { if ( m Media Player != null ) { if ( m Media Player . is Playing ( ) ) { m Media Player . stop ( ) ; } m Media Player . reset ( ) ; m Media Player . release ( ) ; } m Media Player = null ; }
private void add To TT ( String tt S Name , boolean start BR , Object ... tt O ) { if ( start BR == BR ) tooltip String . append ( STRING ) ; if ( tt O != null ) { tooltip String . append ( Messages . get String ( STRING + tt S Name , tt O ) ) ; } else { tooltip String . append ( Messages . get String ( STRING + tt S Name ) ) ; } }
public void clear Operator Selection ( ) { this . selected Operators = Collections . unmodifiable List ( Collections . < Operator > empty List ( ) ) ; }
public static void drop Index ( Connection conn , String schema , String table ) throws SQL Exception { init ( conn ) ; Prepared Statement prep = conn . prepare Statement ( STRING + SCHEMA + STRING ) ; prep . set String ( NUM , schema ) ; prep . set String ( NUM , table ) ; int row Count = prep . execute Update ( ) ; if ( row Count == NUM ) { return ; } reindex ( conn ) ; }
public static void drop Index ( Connection conn , String schema , String table ) throws SQL Exception { init ( conn ) ; Prepared Statement prep = conn . prepare Statement ( STRING + SCHEMA + STRING ) ; prep . set String ( NUM , schema ) ; prep . set String ( NUM , table ) ; int row Count = prep . execute Update ( ) ; if ( row Count == NUM ) { return ; } reindex ( conn ) ; }
protected int skip Whitespace ( int c ) throws IO Exception { while ( c == STRING || c == STRING ) { c = reader . read ( ) ; } return c ; }
protected int skip Whitespace ( int c ) throws IO Exception { while ( c == STRING || c == STRING ) { c = reader . read ( ) ; } return c ; }
public Observable < Drive Id > create File ( Drive Folder folder , File file , String title ) { return create File ( folder , file , title , Mime Type Map . get File Extension From Url ( file . get Path ( ) ) ) ; }
public static int instance Of ( Object o , Class < ? > c ) { if ( o == null ) return FALSE ; return c . is Assignable From ( o . get Class ( ) ) ? TRUE : FALSE ; }
public static int instance Of ( Object o , Class < ? > c ) { if ( o == null ) return FALSE ; return c . is Assignable From ( o . get Class ( ) ) ? TRUE : FALSE ; }
@ Override public byte [ ] from Byte Array ( Slice fragment ) { if ( fragment == null || fragment . buffer == null ) { return null ; } else if ( fragment . offset == NUM && fragment . length == fragment . buffer . length ) { return fragment . buffer ; } else { byte [ ] buffer = new byte [ fragment . buffer . length ] ; System . arraycopy ( fragment . buffer , fragment . offset , buffer , NUM , fragment . length ) ; return buffer ; } }
public State Machine ( State [ ] s ) { for ( int i = NUM ; i < s . length ; i ++ ) states . add Element ( s [ i ] ) ; }
public State Machine ( State [ ] s ) { for ( int i = NUM ; i < s . length ; i ++ ) states . add Element ( s [ i ] ) ; }
public State Machine ( State [ ] s ) { for ( int i = NUM ; i < s . length ; i ++ ) states . add Element ( s [ i ] ) ; }
@ Override public synchronized void remove Data Source Listener ( Data Source Listener dsl ) { m data Listeners . remove ( dsl ) ; }
public void print Stack Trace ( Print Stream ps ) { ps . println ( fetch Stack Trace ( ) ) ; }
public void print Stack Trace ( Print Stream ps ) { ps . println ( fetch Stack Trace ( ) ) ; }
public void print Stack Trace ( Print Stream ps ) { ps . println ( fetch Stack Trace ( ) ) ; }
public void test Case 13 ( ) { byte a Bytes [ ] = { NUM , NUM , - NUM , NUM , NUM , - NUM , NUM , - NUM } ; int a Sign = NUM ; byte r Bytes [ ] = { NUM , NUM , - NUM , NUM , NUM , - NUM , NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = Big Integer . ONE ; Big Integer result = a Number . divide ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
private boolean is Shell Only ( Method method ) { Cli Meta Data cli Metadata = method . get Annotation ( Cli Meta Data . class ) ; return cli Metadata != null && cli Metadata . shell Only ( ) ; }
public boolean should Include ( final Path path ) { return include Matchers . size ( ) == NUM || matches ( path , include Matchers ) ; }
private void bappend ( char ch ) { try { m Buff [ ++ m Buff Idx ] = ch ; } catch ( Exception exp ) { char buff [ ] = new char [ m Buff . length << NUM ] ; System . arraycopy ( m Buff , NUM , buff , NUM , m Buff . length ) ; m Buff = buff ; m Buff [ m Buff Idx ] = ch ; } }
public static String convert Bytes To GB In Str ( Long size ) { if ( size == null ) { return String . format ( STRING ) ; } return String . format ( STRING , ( size / ( double ) GB ) ) ; }
public static String convert Bytes To GB In Str ( Long size ) { if ( size == null ) { return String . format ( STRING ) ; } return String . format ( STRING , ( size / ( double ) GB ) ) ; }
public void delete ( String name ) throws Certificate Exception , IO Exception { if ( name . equals Ignore Case ( NOT BEFORE ) ) { not Before = null ; } else if ( name . equals Ignore Case ( NOT AFTER ) ) { not After = null ; } else { throw new Certificate Exception ( STRING + STRING ) ; } encode This ( ) ; }
public static String create Test Pt Travel Times And Distances CSV File ( ) { String location = Temp Directory Util . create Custom Temp Directory ( STRING ) + STRING ; Buffered Writer bw = IO Utils . get Buffered Writer ( location ) ; try { for ( int origin = NUM ; origin <= NUM ; origin ++ ) { for ( int destination = NUM ; destination <= NUM ; destination ++ ) { if ( origin == destination ) bw . write ( origin + STRING + destination + STRING + org . matsim . contrib . matsim 4 urbansim . utils . Internal Constants . NEW LINE ) ; else bw . write ( origin + STRING + destination + STRING + org . matsim . contrib . matsim 4 urbansim . utils . Internal Constants . NEW LINE ) ; } } bw . flush ( ) ; bw . close ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } return location ; }
public static String create Test Pt Travel Times And Distances CSV File ( ) { String location = Temp Directory Util . create Custom Temp Directory ( STRING ) + STRING ; Buffered Writer bw = IO Utils . get Buffered Writer ( location ) ; try { for ( int origin = NUM ; origin <= NUM ; origin ++ ) { for ( int destination = NUM ; destination <= NUM ; destination ++ ) { if ( origin == destination ) bw . write ( origin + STRING + destination + STRING + org . matsim . contrib . matsim 4 urbansim . utils . Internal Constants . NEW LINE ) ; else bw . write ( origin + STRING + destination + STRING + org . matsim . contrib . matsim 4 urbansim . utils . Internal Constants . NEW LINE ) ; } } bw . flush ( ) ; bw . close ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } return location ; }
public static String create Test Pt Travel Times And Distances CSV File ( ) { String location = Temp Directory Util . create Custom Temp Directory ( STRING ) + STRING ; Buffered Writer bw = IO Utils . get Buffered Writer ( location ) ; try { for ( int origin = NUM ; origin <= NUM ; origin ++ ) { for ( int destination = NUM ; destination <= NUM ; destination ++ ) { if ( origin == destination ) bw . write ( origin + STRING + destination + STRING + org . matsim . contrib . matsim 4 urbansim . utils . Internal Constants . NEW LINE ) ; else bw . write ( origin + STRING + destination + STRING + org . matsim . contrib . matsim 4 urbansim . utils . Internal Constants . NEW LINE ) ; } } bw . flush ( ) ; bw . close ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } return location ; }
private static List < Ignite > all Grids ( boolean wait ) { List < Ignite > all Ignites = new Array List < > ( grids . size ( ) + NUM ) ; for ( Ignite Named Instance grid : grids . values ( ) ) { Ignite g = wait ? grid . grid ( ) : grid . gridx ( ) ; if ( g != null ) all Ignites . add ( g ) ; } Ignite Named Instance dflt Grid 0 = dflt Grid ; if ( dflt Grid 0 != null ) { Ignite Kernal g = wait ? dflt Grid 0 . grid ( ) : dflt Grid 0 . gridx ( ) ; if ( g != null ) all Ignites . add ( g ) ; } return all Ignites ; }
public static boolean is Unix Socket Uri ( @ Not Null URI uri ) { Objects . require Non Null ( uri , STRING ) ; return UNIX SOCKET SCHEME . equals ( uri . get Scheme ( ) ) ; }
private void gauss ( int size ) { int start = ( window Function . length - size ) / NUM ; int stop = ( window Function . length + size ) / NUM ; double delta = NUM / size ; double x = ( NUM - size ) / NUM * delta ; double c = - Math . PI * Math . exp ( NUM ) / NUM ; double sum = NUM ; for ( int i = start ; i < stop ; i ++ ) { window Function [ i ] = Math . exp ( c * x * x ) ; x += delta ; sum += window Function [ i ] ; } for ( int i = start ; i < stop ; i ++ ) window Function [ i ] /= sum ; }
public void remove On Tab Selected Listener ( On Tab Selected Listener listener ) { if ( listener != null ) { m Listeners . remove ( listener ) ; } }
public static File create Temp File ( ) { File temp File ; try { temp File = File . create Temp File ( STRING , STRING ) ; } catch ( Exception e ) { throw new Illegal State Exception ( STRING , e ) ; } return temp File ; }
public final boolean is Vbr ( ) { return vbr ; }
public final boolean is Vbr ( ) { return vbr ; }
public D Netscape Revocation Url ( J Dialog parent ) { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; }
private boolean select Item ( int position ) { dis Miss Or Update Popup Window ( ) ; if ( position >= NUM && m Cache Data List . size ( ) > position ) { set Text ( m Cache Data List . get ( position ) ) ; return BOOL ; } return BOOL ; }
public static double num All Conditions ( Instances data ) { double total = NUM ; Enumeration < Attribute > att Enum = data . enumerate Attributes ( ) ; while ( att Enum . has More Elements ( ) ) { Attribute att = att Enum . next Element ( ) ; if ( att . is Nominal ( ) ) { total += att . num Values ( ) ; } else { total += NUM * data . num Distinct Values ( att ) ; } } return total ; }
public static double num All Conditions ( Instances data ) { double total = NUM ; Enumeration < Attribute > att Enum = data . enumerate Attributes ( ) ; while ( att Enum . has More Elements ( ) ) { Attribute att = att Enum . next Element ( ) ; if ( att . is Nominal ( ) ) { total += att . num Values ( ) ; } else { total += NUM * data . num Distinct Values ( att ) ; } } return total ; }
public static double num All Conditions ( Instances data ) { double total = NUM ; Enumeration < Attribute > att Enum = data . enumerate Attributes ( ) ; while ( att Enum . has More Elements ( ) ) { Attribute att = att Enum . next Element ( ) ; if ( att . is Nominal ( ) ) { total += att . num Values ( ) ; } else { total += NUM * data . num Distinct Values ( att ) ; } } return total ; }
public static double num All Conditions ( Instances data ) { double total = NUM ; Enumeration < Attribute > att Enum = data . enumerate Attributes ( ) ; while ( att Enum . has More Elements ( ) ) { Attribute att = att Enum . next Element ( ) ; if ( att . is Nominal ( ) ) { total += att . num Values ( ) ; } else { total += NUM * data . num Distinct Values ( att ) ; } } return total ; }
public String allocate Route ( List < Block Order > orders ) { if ( total Allocated ) { return null ; } if ( orders == null ) { orders = get Block Orders ( ) ; } else { orders = orders ; } allocated = BOOL ; total Allocated = BOOL ; String msg = check In Service ( ) ; if ( msg != null ) { total Allocated = BOOL ; return msg ; } O Block block = get Block At ( NUM ) ; msg = block . allocate ( this ) ; if ( msg != null ) { return msg ; } allocate From Index ( NUM ) ; return null ; }
public static void skip Fully ( Input Stream in , long bytes ) throws IO Exception { if ( bytes < NUM ) { throw new Illegal Argument Exception ( STRING + bytes + STRING ) ; } long remaining = bytes ; while ( remaining > NUM ) { long skipped = in . skip ( remaining ) ; if ( skipped <= NUM ) { throw new EOF Exception ( STRING + bytes ) ; } remaining -= skipped ; } }
private void read Object ( Object Input Stream oos ) throws IO Exception , Class Not Found Exception { i Instant = ( Local Time ) oos . read Object ( ) ; Date Time Field Type type = ( Date Time Field Type ) oos . read Object ( ) ; i Field = type . get Field ( i Instant . get Chronology ( ) ) ; }
private void read Object ( Object Input Stream oos ) throws IO Exception , Class Not Found Exception { i Instant = ( Local Time ) oos . read Object ( ) ; Date Time Field Type type = ( Date Time Field Type ) oos . read Object ( ) ; i Field = type . get Field ( i Instant . get Chronology ( ) ) ; }
public Code Source Facade ( final Code Source code Source ) { this . location = code Source . get Location ( ) ; final Certificate [ ] certificates = code Source . get Certificates ( ) ; if ( null == certificates || NUM == certificates . length ) { LOGGER . warning ( String . format ( STRING , code Source ) ) ; this . first Certificate = null ; return ; } this . first Certificate = ( X509 Certificate ) certificates [ NUM ] ; }
private static byte [ ] create File Req ( byte [ ] command , String path ) { byte [ ] path Content ; try { path Content = path . get Bytes ( Adb Helper . DEFAULT ENCODING ) ; } catch ( Unsupported Encoding Exception e ) { return null ; } return create File Req ( command , path Content ) ; }
public void test Scalars With Typing ( ) throws Exception { Object Mapper m = new Object Mapper ( ) ; String json ; Dynamic Wrapper result ; json = m . write Value As String ( new Dynamic Wrapper ( Integer . value Of ( NUM ) ) ) ; result = m . read Value ( json , Dynamic Wrapper . class ) ; assert Equals ( Integer . value Of ( NUM ) , result . value ) ; json = m . write Value As String ( new Dynamic Wrapper ( STRING ) ) ; result = m . read Value ( json , Dynamic Wrapper . class ) ; assert Equals ( STRING , result . value ) ; json = m . write Value As String ( new Dynamic Wrapper ( STRING ) ) ; result = m . read Value ( json , Dynamic Wrapper . class ) ; assert Equals ( STRING , result . value ) ; json = m . write Value As String ( new Dynamic Wrapper ( Boolean . TRUE ) ) ; result = m . read Value ( json , Dynamic Wrapper . class ) ; assert Equals ( Boolean . TRUE , result . value ) ; json = m . write Value As String ( new Dynamic Wrapper ( Long . value Of ( NUM ) ) ) ; result = m . read Value ( json , Dynamic Wrapper . class ) ; assert Equals ( Long . value Of ( NUM ) , result . value ) ; json = m . write Value As String ( new Dynamic Wrapper ( Test Enum . B ) ) ; result = m . read Value ( json , Dynamic Wrapper . class ) ; assert Equals ( Test Enum . B , result . value ) ; }
public static void main ( String arg [ ] ) { Display display = new Display ( ) ; Shell shell = new Shell ( display ) ; File file = J File Data Store Chooser . show Open File ( STRING , shell ) ; if ( file != null ) { Message Dialog . open Information ( shell , STRING , STRING + file . get Absolute Path ( ) ) ; } else { Message Dialog . open Information ( shell , STRING , STRING ) ; } }
public static void main ( String arg [ ] ) { Display display = new Display ( ) ; Shell shell = new Shell ( display ) ; File file = J File Data Store Chooser . show Open File ( STRING , shell ) ; if ( file != null ) { Message Dialog . open Information ( shell , STRING , STRING + file . get Absolute Path ( ) ) ; } else { Message Dialog . open Information ( shell , STRING , STRING ) ; } }
public TFS Repository connect If Necessary ( final I Project project ) { Check . not Null ( project , STRING ) ; wait For Manager Startup ( ) ; Project Repository Data project Data ; synchronized ( project Data Lock ) { project Data = project Data Map . get ( project ) ; if ( project Data == null ) { Boolean should Connect = should Connect ( project ) ; if ( should Connect == null ) { return null ; } project Data = new Project Repository Data ( ) ; project Data Map . put ( project , project Data ) ; project Closed Set . remove ( project ) ; if ( should Connect . equals ( Boolean . FALSE ) && is Any Project Of Status ( Project Repository Status . ONLINE ) ) { should Connect = Boolean . TRUE ; } else if ( should Connect . equals ( Boolean . TRUE ) && is Any Project Of Status ( Project Repository Status . OFFLINE ) ) { should Connect = Boolean . FALSE ; } if ( should Connect == Boolean . FALSE ) { project Data . set Status ( Project Repository Status . OFFLINE ) ; return null ; } project Data . set Status ( Project Repository Status . CONNECTING ) ; } else { synchronized ( project Data ) { if ( project Data . get Status ( ) == Project Repository Status . INITIALIZING ) { return null ; } else if ( project Data . get Status ( ) != Project Repository Status . CONNECTING ) { return project Data . get Repository ( ) ; } } } } return connect Internal ( project , BOOL , project Data ) ; }
public TFS Repository connect If Necessary ( final I Project project ) { Check . not Null ( project , STRING ) ; wait For Manager Startup ( ) ; Project Repository Data project Data ; synchronized ( project Data Lock ) { project Data = project Data Map . get ( project ) ; if ( project Data == null ) { Boolean should Connect = should Connect ( project ) ; if ( should Connect == null ) { return null ; } project Data = new Project Repository Data ( ) ; project Data Map . put ( project , project Data ) ; project Closed Set . remove ( project ) ; if ( should Connect . equals ( Boolean . FALSE ) && is Any Project Of Status ( Project Repository Status . ONLINE ) ) { should Connect = Boolean . TRUE ; } else if ( should Connect . equals ( Boolean . TRUE ) && is Any Project Of Status ( Project Repository Status . OFFLINE ) ) { should Connect = Boolean . FALSE ; } if ( should Connect == Boolean . FALSE ) { project Data . set Status ( Project Repository Status . OFFLINE ) ; return null ; } project Data . set Status ( Project Repository Status . CONNECTING ) ; } else { synchronized ( project Data ) { if ( project Data . get Status ( ) == Project Repository Status . INITIALIZING ) { return null ; } else if ( project Data . get Status ( ) != Project Repository Status . CONNECTING ) { return project Data . get Repository ( ) ; } } } } return connect Internal ( project , BOOL , project Data ) ; }
public TFS Repository connect If Necessary ( final I Project project ) { Check . not Null ( project , STRING ) ; wait For Manager Startup ( ) ; Project Repository Data project Data ; synchronized ( project Data Lock ) { project Data = project Data Map . get ( project ) ; if ( project Data == null ) { Boolean should Connect = should Connect ( project ) ; if ( should Connect == null ) { return null ; } project Data = new Project Repository Data ( ) ; project Data Map . put ( project , project Data ) ; project Closed Set . remove ( project ) ; if ( should Connect . equals ( Boolean . FALSE ) && is Any Project Of Status ( Project Repository Status . ONLINE ) ) { should Connect = Boolean . TRUE ; } else if ( should Connect . equals ( Boolean . TRUE ) && is Any Project Of Status ( Project Repository Status . OFFLINE ) ) { should Connect = Boolean . FALSE ; } if ( should Connect == Boolean . FALSE ) { project Data . set Status ( Project Repository Status . OFFLINE ) ; return null ; } project Data . set Status ( Project Repository Status . CONNECTING ) ; } else { synchronized ( project Data ) { if ( project Data . get Status ( ) == Project Repository Status . INITIALIZING ) { return null ; } else if ( project Data . get Status ( ) != Project Repository Status . CONNECTING ) { return project Data . get Repository ( ) ; } } } } return connect Internal ( project , BOOL , project Data ) ; }
public TFS Repository connect If Necessary ( final I Project project ) { Check . not Null ( project , STRING ) ; wait For Manager Startup ( ) ; Project Repository Data project Data ; synchronized ( project Data Lock ) { project Data = project Data Map . get ( project ) ; if ( project Data == null ) { Boolean should Connect = should Connect ( project ) ; if ( should Connect == null ) { return null ; } project Data = new Project Repository Data ( ) ; project Data Map . put ( project , project Data ) ; project Closed Set . remove ( project ) ; if ( should Connect . equals ( Boolean . FALSE ) && is Any Project Of Status ( Project Repository Status . ONLINE ) ) { should Connect = Boolean . TRUE ; } else if ( should Connect . equals ( Boolean . TRUE ) && is Any Project Of Status ( Project Repository Status . OFFLINE ) ) { should Connect = Boolean . FALSE ; } if ( should Connect == Boolean . FALSE ) { project Data . set Status ( Project Repository Status . OFFLINE ) ; return null ; } project Data . set Status ( Project Repository Status . CONNECTING ) ; } else { synchronized ( project Data ) { if ( project Data . get Status ( ) == Project Repository Status . INITIALIZING ) { return null ; } else if ( project Data . get Status ( ) != Project Repository Status . CONNECTING ) { return project Data . get Repository ( ) ; } } } } return connect Internal ( project , BOOL , project Data ) ; }
public TFS Repository connect If Necessary ( final I Project project ) { Check . not Null ( project , STRING ) ; wait For Manager Startup ( ) ; Project Repository Data project Data ; synchronized ( project Data Lock ) { project Data = project Data Map . get ( project ) ; if ( project Data == null ) { Boolean should Connect = should Connect ( project ) ; if ( should Connect == null ) { return null ; } project Data = new Project Repository Data ( ) ; project Data Map . put ( project , project Data ) ; project Closed Set . remove ( project ) ; if ( should Connect . equals ( Boolean . FALSE ) && is Any Project Of Status ( Project Repository Status . ONLINE ) ) { should Connect = Boolean . TRUE ; } else if ( should Connect . equals ( Boolean . TRUE ) && is Any Project Of Status ( Project Repository Status . OFFLINE ) ) { should Connect = Boolean . FALSE ; } if ( should Connect == Boolean . FALSE ) { project Data . set Status ( Project Repository Status . OFFLINE ) ; return null ; } project Data . set Status ( Project Repository Status . CONNECTING ) ; } else { synchronized ( project Data ) { if ( project Data . get Status ( ) == Project Repository Status . INITIALIZING ) { return null ; } else if ( project Data . get Status ( ) != Project Repository Status . CONNECTING ) { return project Data . get Repository ( ) ; } } } } return connect Internal ( project , BOOL , project Data ) ; }
public TFS Repository connect If Necessary ( final I Project project ) { Check . not Null ( project , STRING ) ; wait For Manager Startup ( ) ; Project Repository Data project Data ; synchronized ( project Data Lock ) { project Data = project Data Map . get ( project ) ; if ( project Data == null ) { Boolean should Connect = should Connect ( project ) ; if ( should Connect == null ) { return null ; } project Data = new Project Repository Data ( ) ; project Data Map . put ( project , project Data ) ; project Closed Set . remove ( project ) ; if ( should Connect . equals ( Boolean . FALSE ) && is Any Project Of Status ( Project Repository Status . ONLINE ) ) { should Connect = Boolean . TRUE ; } else if ( should Connect . equals ( Boolean . TRUE ) && is Any Project Of Status ( Project Repository Status . OFFLINE ) ) { should Connect = Boolean . FALSE ; } if ( should Connect == Boolean . FALSE ) { project Data . set Status ( Project Repository Status . OFFLINE ) ; return null ; } project Data . set Status ( Project Repository Status . CONNECTING ) ; } else { synchronized ( project Data ) { if ( project Data . get Status ( ) == Project Repository Status . INITIALIZING ) { return null ; } else if ( project Data . get Status ( ) != Project Repository Status . CONNECTING ) { return project Data . get Repository ( ) ; } } } } return connect Internal ( project , BOOL , project Data ) ; }
public TFS Repository connect If Necessary ( final I Project project ) { Check . not Null ( project , STRING ) ; wait For Manager Startup ( ) ; Project Repository Data project Data ; synchronized ( project Data Lock ) { project Data = project Data Map . get ( project ) ; if ( project Data == null ) { Boolean should Connect = should Connect ( project ) ; if ( should Connect == null ) { return null ; } project Data = new Project Repository Data ( ) ; project Data Map . put ( project , project Data ) ; project Closed Set . remove ( project ) ; if ( should Connect . equals ( Boolean . FALSE ) && is Any Project Of Status ( Project Repository Status . ONLINE ) ) { should Connect = Boolean . TRUE ; } else if ( should Connect . equals ( Boolean . TRUE ) && is Any Project Of Status ( Project Repository Status . OFFLINE ) ) { should Connect = Boolean . FALSE ; } if ( should Connect == Boolean . FALSE ) { project Data . set Status ( Project Repository Status . OFFLINE ) ; return null ; } project Data . set Status ( Project Repository Status . CONNECTING ) ; } else { synchronized ( project Data ) { if ( project Data . get Status ( ) == Project Repository Status . INITIALIZING ) { return null ; } else if ( project Data . get Status ( ) != Project Repository Status . CONNECTING ) { return project Data . get Repository ( ) ; } } } } return connect Internal ( project , BOOL , project Data ) ; }
public TFS Repository connect If Necessary ( final I Project project ) { Check . not Null ( project , STRING ) ; wait For Manager Startup ( ) ; Project Repository Data project Data ; synchronized ( project Data Lock ) { project Data = project Data Map . get ( project ) ; if ( project Data == null ) { Boolean should Connect = should Connect ( project ) ; if ( should Connect == null ) { return null ; } project Data = new Project Repository Data ( ) ; project Data Map . put ( project , project Data ) ; project Closed Set . remove ( project ) ; if ( should Connect . equals ( Boolean . FALSE ) && is Any Project Of Status ( Project Repository Status . ONLINE ) ) { should Connect = Boolean . TRUE ; } else if ( should Connect . equals ( Boolean . TRUE ) && is Any Project Of Status ( Project Repository Status . OFFLINE ) ) { should Connect = Boolean . FALSE ; } if ( should Connect == Boolean . FALSE ) { project Data . set Status ( Project Repository Status . OFFLINE ) ; return null ; } project Data . set Status ( Project Repository Status . CONNECTING ) ; } else { synchronized ( project Data ) { if ( project Data . get Status ( ) == Project Repository Status . INITIALIZING ) { return null ; } else if ( project Data . get Status ( ) != Project Repository Status . CONNECTING ) { return project Data . get Repository ( ) ; } } } } return connect Internal ( project , BOOL , project Data ) ; }
public TFS Repository connect If Necessary ( final I Project project ) { Check . not Null ( project , STRING ) ; wait For Manager Startup ( ) ; Project Repository Data project Data ; synchronized ( project Data Lock ) { project Data = project Data Map . get ( project ) ; if ( project Data == null ) { Boolean should Connect = should Connect ( project ) ; if ( should Connect == null ) { return null ; } project Data = new Project Repository Data ( ) ; project Data Map . put ( project , project Data ) ; project Closed Set . remove ( project ) ; if ( should Connect . equals ( Boolean . FALSE ) && is Any Project Of Status ( Project Repository Status . ONLINE ) ) { should Connect = Boolean . TRUE ; } else if ( should Connect . equals ( Boolean . TRUE ) && is Any Project Of Status ( Project Repository Status . OFFLINE ) ) { should Connect = Boolean . FALSE ; } if ( should Connect == Boolean . FALSE ) { project Data . set Status ( Project Repository Status . OFFLINE ) ; return null ; } project Data . set Status ( Project Repository Status . CONNECTING ) ; } else { synchronized ( project Data ) { if ( project Data . get Status ( ) == Project Repository Status . INITIALIZING ) { return null ; } else if ( project Data . get Status ( ) != Project Repository Status . CONNECTING ) { return project Data . get Repository ( ) ; } } } } return connect Internal ( project , BOOL , project Data ) ; }
@ Override public Void visit Type ( Type Element e , Void p ) { scan ( e . get Type Parameters ( ) , p ) ; check Camel Case ( e , BOOL ) ; super . visit Type ( e , p ) ; return null ; }
public Char Seq replace All ( String regex , String replacement ) { return Char Seq . of ( str . replace All ( regex , replacement ) ) ; }
public Char Seq replace All ( String regex , String replacement ) { return Char Seq . of ( str . replace All ( regex , replacement ) ) ; }
public void add Child ( Tree Node node ) { if ( children == null ) children = new Array List < Tree Node > ( ) ; children . add ( node ) ; }
public void add Child ( Tree Node node ) { if ( children == null ) children = new Array List < Tree Node > ( ) ; children . add ( node ) ; }
private Object Animator create Entering Image Matrix Animator ( ) { Matrix init Matrix = Matrix Utils . get Image Matrix ( m Animated Image ) ; init Matrix . get Values ( m Init Thumbnail Matrix Values ) ; final Matrix end Matrix = Matrix Utils . get Image Matrix ( m Image To ) ; Log . v ( TAG , STRING + Arrays . to String ( m Init Thumbnail Matrix Values ) ) ; Log . v ( TAG , STRING + init Matrix ) ; Log . v ( TAG , STRING + end Matrix ) ; m Animated Image . set Scale Type ( Image View . Scale Type . MATRIX ) ; return Object Animator . of Object ( m Animated Image , Matrix Evaluator . ANIMATED TRANSFORM PROPERTY , new Matrix Evaluator ( ) , init Matrix , end Matrix ) ; }
private Object Animator create Entering Image Matrix Animator ( ) { Matrix init Matrix = Matrix Utils . get Image Matrix ( m Animated Image ) ; init Matrix . get Values ( m Init Thumbnail Matrix Values ) ; final Matrix end Matrix = Matrix Utils . get Image Matrix ( m Image To ) ; Log . v ( TAG , STRING + Arrays . to String ( m Init Thumbnail Matrix Values ) ) ; Log . v ( TAG , STRING + init Matrix ) ; Log . v ( TAG , STRING + end Matrix ) ; m Animated Image . set Scale Type ( Image View . Scale Type . MATRIX ) ; return Object Animator . of Object ( m Animated Image , Matrix Evaluator . ANIMATED TRANSFORM PROPERTY , new Matrix Evaluator ( ) , init Matrix , end Matrix ) ; }
private Object Animator create Entering Image Matrix Animator ( ) { Matrix init Matrix = Matrix Utils . get Image Matrix ( m Animated Image ) ; init Matrix . get Values ( m Init Thumbnail Matrix Values ) ; final Matrix end Matrix = Matrix Utils . get Image Matrix ( m Image To ) ; Log . v ( TAG , STRING + Arrays . to String ( m Init Thumbnail Matrix Values ) ) ; Log . v ( TAG , STRING + init Matrix ) ; Log . v ( TAG , STRING + end Matrix ) ; m Animated Image . set Scale Type ( Image View . Scale Type . MATRIX ) ; return Object Animator . of Object ( m Animated Image , Matrix Evaluator . ANIMATED TRANSFORM PROPERTY , new Matrix Evaluator ( ) , init Matrix , end Matrix ) ; }
private Object Animator create Entering Image Matrix Animator ( ) { Matrix init Matrix = Matrix Utils . get Image Matrix ( m Animated Image ) ; init Matrix . get Values ( m Init Thumbnail Matrix Values ) ; final Matrix end Matrix = Matrix Utils . get Image Matrix ( m Image To ) ; Log . v ( TAG , STRING + Arrays . to String ( m Init Thumbnail Matrix Values ) ) ; Log . v ( TAG , STRING + init Matrix ) ; Log . v ( TAG , STRING + end Matrix ) ; m Animated Image . set Scale Type ( Image View . Scale Type . MATRIX ) ; return Object Animator . of Object ( m Animated Image , Matrix Evaluator . ANIMATED TRANSFORM PROPERTY , new Matrix Evaluator ( ) , init Matrix , end Matrix ) ; }
private Object Animator create Entering Image Matrix Animator ( ) { Matrix init Matrix = Matrix Utils . get Image Matrix ( m Animated Image ) ; init Matrix . get Values ( m Init Thumbnail Matrix Values ) ; final Matrix end Matrix = Matrix Utils . get Image Matrix ( m Image To ) ; Log . v ( TAG , STRING + Arrays . to String ( m Init Thumbnail Matrix Values ) ) ; Log . v ( TAG , STRING + init Matrix ) ; Log . v ( TAG , STRING + end Matrix ) ; m Animated Image . set Scale Type ( Image View . Scale Type . MATRIX ) ; return Object Animator . of Object ( m Animated Image , Matrix Evaluator . ANIMATED TRANSFORM PROPERTY , new Matrix Evaluator ( ) , init Matrix , end Matrix ) ; }
protected boolean is Equal Value ( Object value 1 , Object value 2 ) { return ( value 1 == value 2 || value 1 . equals ( value 2 ) ) ; }
protected boolean is Equal Value ( Object value 1 , Object value 2 ) { return ( value 1 == value 2 || value 1 . equals ( value 2 ) ) ; }
private void restore Icon ( Key key , byte [ ] buffer , int data Size ) throws IO Exception { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base 64 . encode To String ( buffer , NUM , data Size , Base 64 . NO WRAP ) ) ; Resource res = unpack Proto ( new Resource ( ) , buffer , data Size ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = Bitmap Factory . decode Byte Array ( res . data , NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; Icon Cache . preload Icon ( m Context , Component Name . unflatten From String ( key . name ) , icon , res . dpi ) ; }
private void restore Icon ( Key key , byte [ ] buffer , int data Size ) throws IO Exception { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base 64 . encode To String ( buffer , NUM , data Size , Base 64 . NO WRAP ) ) ; Resource res = unpack Proto ( new Resource ( ) , buffer , data Size ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = Bitmap Factory . decode Byte Array ( res . data , NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; Icon Cache . preload Icon ( m Context , Component Name . unflatten From String ( key . name ) , icon , res . dpi ) ; }
private void restore Icon ( Key key , byte [ ] buffer , int data Size ) throws IO Exception { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base 64 . encode To String ( buffer , NUM , data Size , Base 64 . NO WRAP ) ) ; Resource res = unpack Proto ( new Resource ( ) , buffer , data Size ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = Bitmap Factory . decode Byte Array ( res . data , NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; Icon Cache . preload Icon ( m Context , Component Name . unflatten From String ( key . name ) , icon , res . dpi ) ; }
private void restore Icon ( Key key , byte [ ] buffer , int data Size ) throws IO Exception { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base 64 . encode To String ( buffer , NUM , data Size , Base 64 . NO WRAP ) ) ; Resource res = unpack Proto ( new Resource ( ) , buffer , data Size ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = Bitmap Factory . decode Byte Array ( res . data , NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; Icon Cache . preload Icon ( m Context , Component Name . unflatten From String ( key . name ) , icon , res . dpi ) ; }
private void restore Icon ( Key key , byte [ ] buffer , int data Size ) throws IO Exception { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base 64 . encode To String ( buffer , NUM , data Size , Base 64 . NO WRAP ) ) ; Resource res = unpack Proto ( new Resource ( ) , buffer , data Size ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = Bitmap Factory . decode Byte Array ( res . data , NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; Icon Cache . preload Icon ( m Context , Component Name . unflatten From String ( key . name ) , icon , res . dpi ) ; }
static Object new Property Change Event ( Object source , String prop , Object old Value , Object new Value ) { try { return property Event Ctor . new Instance ( source , prop , old Value , new Value ) ; } catch ( Instantiation Exception | Illegal Access Exception x ) { throw new Assertion Error ( x ) ; } catch ( Invocation Target Exception x ) { Throwable cause = x . get Cause ( ) ; if ( cause instanceof Error ) throw ( Error ) cause ; if ( cause instanceof Runtime Exception ) throw ( Runtime Exception ) cause ; throw new Assertion Error ( x ) ; } }
@ Override public Selectable Channel selectable Channel ( ) { return socket Channel ; }
@ Override public Selectable Channel selectable Channel ( ) { return socket Channel ; }
public static Executor Service Closer of ( Executor Service executor Service ) { return new Executor Service Closer ( executor Service , Optional . empty ( ) ) ; }
public static Executor Service Closer of ( Executor Service executor Service ) { return new Executor Service Closer ( executor Service , Optional . empty ( ) ) ; }
public static Executor Service Closer of ( Executor Service executor Service ) { return new Executor Service Closer ( executor Service , Optional . empty ( ) ) ; }
public static Executor Service Closer of ( Executor Service executor Service ) { return new Executor Service Closer ( executor Service , Optional . empty ( ) ) ; }
public void perform Actions ( ) throws Throwable { for ( Throwing . Runnable action : actions ) { action . run ( ) ; } }
private void show Popup Menu ( final Mouse Event event ) { final int [ ] rows = m event Table . get Converted Selected Rows ( ) ; final List < I Trace Event > traces = get Traces ( rows ) ; final C Event Table Menu menu = new C Event Table Menu ( m event Table , m model , traces ) ; menu . show ( m event Table , event . get X ( ) , event . get Y ( ) ) ; }
public void write Exif ( String jpeg File Name , String exif Out File Name ) throws File Not Found Exception , IO Exception { if ( jpeg File Name == null || exif Out File Name == null ) { throw new Illegal Argument Exception ( NULL ARGUMENT STRING ) ; } Input Stream is = null ; is = new File Input Stream ( jpeg File Name ) ; write Exif ( is , exif Out File Name ) ; is . close ( ) ; }
public void write Exif ( String jpeg File Name , String exif Out File Name ) throws File Not Found Exception , IO Exception { if ( jpeg File Name == null || exif Out File Name == null ) { throw new Illegal Argument Exception ( NULL ARGUMENT STRING ) ; } Input Stream is = null ; is = new File Input Stream ( jpeg File Name ) ; write Exif ( is , exif Out File Name ) ; is . close ( ) ; }
static public void assert Statement Indices Consistent ( final Abstract Triple Store db , final int maxerrors ) { if ( log . is Info Enabled ( ) ) log . info ( STRING ) ; final Atomic Integer nerrs = new Atomic Integer ( NUM ) ; final int from , to ; if ( db . get SPO Key Arity ( ) == NUM ) { from = SPO Key Order . FIRST TRIPLE INDEX ; to = SPO Key Order . LAST TRIPLE INDEX ; } else { from = SPO Key Order . FIRST QUAD INDEX ; to = SPO Key Order . LAST QUAD INDEX ; } for ( int i = from ; i <= to ; i ++ ) { for ( int j = from ; j <= to ; j ++ ) { if ( i <= j ) { continue ; } assert Same Statements ( db , SPO Key Order . value Of ( i ) , SPO Key Order . value Of ( j ) , nerrs , maxerrors ) ; } } assert Equals ( NUM , nerrs . get ( ) ) ; }
static public void assert Statement Indices Consistent ( final Abstract Triple Store db , final int maxerrors ) { if ( log . is Info Enabled ( ) ) log . info ( STRING ) ; final Atomic Integer nerrs = new Atomic Integer ( NUM ) ; final int from , to ; if ( db . get SPO Key Arity ( ) == NUM ) { from = SPO Key Order . FIRST TRIPLE INDEX ; to = SPO Key Order . LAST TRIPLE INDEX ; } else { from = SPO Key Order . FIRST QUAD INDEX ; to = SPO Key Order . LAST QUAD INDEX ; } for ( int i = from ; i <= to ; i ++ ) { for ( int j = from ; j <= to ; j ++ ) { if ( i <= j ) { continue ; } assert Same Statements ( db , SPO Key Order . value Of ( i ) , SPO Key Order . value Of ( j ) , nerrs , maxerrors ) ; } } assert Equals ( NUM , nerrs . get ( ) ) ; }
@ Rpc Method public void power Vm Op ( String vm Id , Power Vm Op op , Async Method Callback < Host . Async Client . power vm op call > handler ) throws Rpc Exception { ensure Client ( ) ; Power Vm Op Request power Vm Op Request = new Power Vm Op Request ( vm Id , op ) ; client Proxy . set Timeout ( POWER VM OP TIMEOUT MS ) ; logger . info ( STRING , vm Id , get Host Ip ( ) , power Vm Op Request ) ; try { client Proxy . power vm op ( power Vm Op Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Rpc Method public void power Vm Op ( String vm Id , Power Vm Op op , Async Method Callback < Host . Async Client . power vm op call > handler ) throws Rpc Exception { ensure Client ( ) ; Power Vm Op Request power Vm Op Request = new Power Vm Op Request ( vm Id , op ) ; client Proxy . set Timeout ( POWER VM OP TIMEOUT MS ) ; logger . info ( STRING , vm Id , get Host Ip ( ) , power Vm Op Request ) ; try { client Proxy . power vm op ( power Vm Op Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Rpc Method public void power Vm Op ( String vm Id , Power Vm Op op , Async Method Callback < Host . Async Client . power vm op call > handler ) throws Rpc Exception { ensure Client ( ) ; Power Vm Op Request power Vm Op Request = new Power Vm Op Request ( vm Id , op ) ; client Proxy . set Timeout ( POWER VM OP TIMEOUT MS ) ; logger . info ( STRING , vm Id , get Host Ip ( ) , power Vm Op Request ) ; try { client Proxy . power vm op ( power Vm Op Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
public File Confirmation Dialog ( @ Nullable Project project , Dialog Type dialog Type , @ Not Null Path target Path ) { super ( project ) ; this . dialog Type = dialog Type ; switch ( dialog Type ) { case CONFIRM OVERWRITE : set Title ( Gct Bundle . message ( STRING ) ) ; warning Label . set Text ( Gct Bundle . message ( STRING ) ) ; break ; case CONFIRM CREATE DIR : set Title ( Gct Bundle . message ( STRING ) ) ; warning Label . set Text ( Gct Bundle . message ( STRING ) ) ; break ; case NOT DIRECTORY ERROR : set Title ( Gct Bundle . message ( STRING ) ) ; warning Label . set Text ( Gct Bundle . message ( STRING ) ) ; break ; default : throw new Assertion Error ( ) ; } path Display . set Text ( target Path . to String ( ) ) ; init ( ) ; }
public void send Message ( Message message ) throws Not Yet Connected Exception { lock . lock ( ) ; try { if ( write Target == null ) throw new Not Yet Connected Exception ( ) ; } finally { lock . unlock ( ) ; } Byte Array Output Stream out = new Byte Array Output Stream ( ) ; try { serializer . serialize ( message , out ) ; write Target . write Bytes ( out . to Byte Array ( ) ) ; } catch ( IO Exception e ) { exception Caught ( e ) ; } }
public void send Message ( Message message ) throws Not Yet Connected Exception { lock . lock ( ) ; try { if ( write Target == null ) throw new Not Yet Connected Exception ( ) ; } finally { lock . unlock ( ) ; } Byte Array Output Stream out = new Byte Array Output Stream ( ) ; try { serializer . serialize ( message , out ) ; write Target . write Bytes ( out . to Byte Array ( ) ) ; } catch ( IO Exception e ) { exception Caught ( e ) ; } }
public void send Message ( Message message ) throws Not Yet Connected Exception { lock . lock ( ) ; try { if ( write Target == null ) throw new Not Yet Connected Exception ( ) ; } finally { lock . unlock ( ) ; } Byte Array Output Stream out = new Byte Array Output Stream ( ) ; try { serializer . serialize ( message , out ) ; write Target . write Bytes ( out . to Byte Array ( ) ) ; } catch ( IO Exception e ) { exception Caught ( e ) ; } }
public void send Message ( Message message ) throws Not Yet Connected Exception { lock . lock ( ) ; try { if ( write Target == null ) throw new Not Yet Connected Exception ( ) ; } finally { lock . unlock ( ) ; } Byte Array Output Stream out = new Byte Array Output Stream ( ) ; try { serializer . serialize ( message , out ) ; write Target . write Bytes ( out . to Byte Array ( ) ) ; } catch ( IO Exception e ) { exception Caught ( e ) ; } }
public void send Message ( Message message ) throws Not Yet Connected Exception { lock . lock ( ) ; try { if ( write Target == null ) throw new Not Yet Connected Exception ( ) ; } finally { lock . unlock ( ) ; } Byte Array Output Stream out = new Byte Array Output Stream ( ) ; try { serializer . serialize ( message , out ) ; write Target . write Bytes ( out . to Byte Array ( ) ) ; } catch ( IO Exception e ) { exception Caught ( e ) ; } }
public Builder entity ( Entity entity ) { if ( entities == null ) { entities = new Array List < Entity > ( ) ; } entities . add ( entity ) ; return this ; }
public static String create Name Identifier ( ) { String handle = null ; try { byte [ ] handle Bytes = new byte [ NUM ] ; random Generator . next Bytes ( handle Bytes ) ; handle = Base 64 . encode ( handle Bytes ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + handle ) ; } } catch ( Exception e ) { debug . message ( STRING + STRING + e . get Message ( ) ) ; } return handle ; }
public static Bootique app ( Collection < String > args ) { if ( args == null ) { args = Collections . empty List ( ) ; } return app ( to Array ( Objects . require Non Null ( args ) ) ) ; }
public static Bootique app ( Collection < String > args ) { if ( args == null ) { args = Collections . empty List ( ) ; } return app ( to Array ( Objects . require Non Null ( args ) ) ) ; }
private boolean verify Payment Allocate Vs Header ( M Payment Allocate [ ] p Allocs ) { if ( p Allocs . length > NUM ) { if ( get C Charge ID ( ) > NUM || get C Invoice ID ( ) > NUM || get C Order ID ( ) > NUM ) return BOOL ; } return BOOL ; }
private boolean verify Payment Allocate Vs Header ( M Payment Allocate [ ] p Allocs ) { if ( p Allocs . length > NUM ) { if ( get C Charge ID ( ) > NUM || get C Invoice ID ( ) > NUM || get C Order ID ( ) > NUM ) return BOOL ; } return BOOL ; }
protected void process Line ( String line ) throws IO Exception { if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + line ) ; } if ( line . starts With ( STRING ) ) { process Get Command ( line ) ; } else if ( line . starts With ( STRING ) ) { Debug . message ( STRING , STRING ) ; handle Post ( ) ; } }
private Method lookup Substitute ( ) { for ( Method m : declaring Class . get Declared Methods ( ) ) { if ( is Substitute ( m ) ) { return m ; } } throw new Graal Error ( STRING , this ) ; }
private static boolean valid Method ( String name ) { int len = name . length ( ) ; if ( len == NUM ) { return BOOL ; } char c = name . char At ( NUM ) ; if ( ! Character . is Java Identifier Start ( c ) && ! ( c == STRING && len > NUM ) ) { return BOOL ; } if ( c != STRING && name . char At ( len - NUM ) == STRING ) { len -- ; } while ( -- len >= NUM ) { if ( ! Character . is Java Identifier Part ( name . char At ( len ) ) ) { return BOOL ; } } return BOOL ; }
private static boolean valid Method ( String name ) { int len = name . length ( ) ; if ( len == NUM ) { return BOOL ; } char c = name . char At ( NUM ) ; if ( ! Character . is Java Identifier Start ( c ) && ! ( c == STRING && len > NUM ) ) { return BOOL ; } if ( c != STRING && name . char At ( len - NUM ) == STRING ) { len -- ; } while ( -- len >= NUM ) { if ( ! Character . is Java Identifier Part ( name . char At ( len ) ) ) { return BOOL ; } } return BOOL ; }
private static boolean valid Method ( String name ) { int len = name . length ( ) ; if ( len == NUM ) { return BOOL ; } char c = name . char At ( NUM ) ; if ( ! Character . is Java Identifier Start ( c ) && ! ( c == STRING && len > NUM ) ) { return BOOL ; } if ( c != STRING && name . char At ( len - NUM ) == STRING ) { len -- ; } while ( -- len >= NUM ) { if ( ! Character . is Java Identifier Part ( name . char At ( len ) ) ) { return BOOL ; } } return BOOL ; }
private Rectangle 2 D [ ] split Vertical Bar ( Rectangular Shape bar , double a , double b , double c ) { Rectangle 2 D [ ] result = new Rectangle 2 D [ NUM ] ; double x0 = bar . get Min X ( ) ; double x1 = Math . rint ( x0 + ( bar . get Width ( ) * a ) ) ; double x2 = Math . rint ( x0 + ( bar . get Width ( ) * b ) ) ; double x3 = Math . rint ( x0 + ( bar . get Width ( ) * c ) ) ; result [ NUM ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , bar . get Min Y ( ) , x1 - x0 , bar . get Height ( ) ) ; result [ NUM ] = new Rectangle 2 D . Double ( x1 , bar . get Min Y ( ) , x2 - x1 , bar . get Height ( ) ) ; result [ NUM ] = new Rectangle 2 D . Double ( x2 , bar . get Min Y ( ) , x3 - x2 , bar . get Height ( ) ) ; result [ NUM ] = new Rectangle 2 D . Double ( x3 , bar . get Min Y ( ) , bar . get Max X ( ) - x3 , bar . get Height ( ) ) ; return result ; }
private Rectangle 2 D [ ] split Vertical Bar ( Rectangular Shape bar , double a , double b , double c ) { Rectangle 2 D [ ] result = new Rectangle 2 D [ NUM ] ; double x0 = bar . get Min X ( ) ; double x1 = Math . rint ( x0 + ( bar . get Width ( ) * a ) ) ; double x2 = Math . rint ( x0 + ( bar . get Width ( ) * b ) ) ; double x3 = Math . rint ( x0 + ( bar . get Width ( ) * c ) ) ; result [ NUM ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , bar . get Min Y ( ) , x1 - x0 , bar . get Height ( ) ) ; result [ NUM ] = new Rectangle 2 D . Double ( x1 , bar . get Min Y ( ) , x2 - x1 , bar . get Height ( ) ) ; result [ NUM ] = new Rectangle 2 D . Double ( x2 , bar . get Min Y ( ) , x3 - x2 , bar . get Height ( ) ) ; result [ NUM ] = new Rectangle 2 D . Double ( x3 , bar . get Min Y ( ) , bar . get Max X ( ) - x3 , bar . get Height ( ) ) ; return result ; }
private Rectangle 2 D [ ] split Vertical Bar ( Rectangular Shape bar , double a , double b , double c ) { Rectangle 2 D [ ] result = new Rectangle 2 D [ NUM ] ; double x0 = bar . get Min X ( ) ; double x1 = Math . rint ( x0 + ( bar . get Width ( ) * a ) ) ; double x2 = Math . rint ( x0 + ( bar . get Width ( ) * b ) ) ; double x3 = Math . rint ( x0 + ( bar . get Width ( ) * c ) ) ; result [ NUM ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , bar . get Min Y ( ) , x1 - x0 , bar . get Height ( ) ) ; result [ NUM ] = new Rectangle 2 D . Double ( x1 , bar . get Min Y ( ) , x2 - x1 , bar . get Height ( ) ) ; result [ NUM ] = new Rectangle 2 D . Double ( x2 , bar . get Min Y ( ) , x3 - x2 , bar . get Height ( ) ) ; result [ NUM ] = new Rectangle 2 D . Double ( x3 , bar . get Min Y ( ) , bar . get Max X ( ) - x3 , bar . get Height ( ) ) ; return result ; }
public void write Field ( String name , int value ) throws java . io . IO Exception { write Field ( name , Integer . to String ( value ) ) ; }
private Enum Declaration generate Enum ( ) { final String value String = STRING ; Enum Declaration new Enum = new Enum Declaration ( Modifier Set . PUBLIC , null , get Enumeration Class Name ( ) , null , generate Enum Constant Declarations ( ) , null ) ; Field Declaration value Field = new Field Declaration ( Modifier Set . add Modifier ( Modifier Set . FINAL , Modifier Set . PUBLIC ) , AST Helper . INT TYPE , Collections . singleton List ( new Variable Declarator ( new Variable Declarator Id ( value String ) ) ) ) ; AST Helper . add Member ( new Enum , value Field ) ; Constructor Declaration enum Constructor = new Constructor Declaration ( NUM , null , null , name , Collections . singleton List ( AST Helper . create Parameter ( AST Helper . INT TYPE , value String ) ) , null , get Default Constructor Block Statement ( value String ) ) ; AST Helper . add Member ( new Enum , enum Constructor ) ; return new Enum ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return VOCAB ; case NUM : return LAYER SIZE ; case NUM : return VECTORS ; default : return null ; } }
public Iterator < E > snapshot Iterator ( ) { List < E > l = new Linked List < E > ( this ) ; return l . iterator ( ) ; }
public Iterator < E > snapshot Iterator ( ) { List < E > l = new Linked List < E > ( this ) ; return l . iterator ( ) ; }
public Iterator < E > snapshot Iterator ( ) { List < E > l = new Linked List < E > ( this ) ; return l . iterator ( ) ; }
public Iterator < E > snapshot Iterator ( ) { List < E > l = new Linked List < E > ( this ) ; return l . iterator ( ) ; }
public Iterator < E > snapshot Iterator ( ) { List < E > l = new Linked List < E > ( this ) ; return l . iterator ( ) ; }
public Iterator < E > snapshot Iterator ( ) { List < E > l = new Linked List < E > ( this ) ; return l . iterator ( ) ; }
public Iterator < E > snapshot Iterator ( ) { List < E > l = new Linked List < E > ( this ) ; return l . iterator ( ) ; }
public Iterator < E > snapshot Iterator ( ) { List < E > l = new Linked List < E > ( this ) ; return l . iterator ( ) ; }
public Iterator < E > snapshot Iterator ( ) { List < E > l = new Linked List < E > ( this ) ; return l . iterator ( ) ; }
public String to String ( ) { return super . to String ( ) + STRING + record Map . size ( ) + STRING + first Offset + STRING + release Buffer + STRING + prefix Writes + STRING + use Checksum + STRING + bytes Written ( ) + STRING + remaining ( ) + STRING + m removed + STRING ; }
protected void show Page ( int page ) { boolean is Empty = page == PAGE EMPTY ; Control control = is Empty ? ( Control ) f Empty Page Label : get Control ( ) ; if ( is Empty ) { set Content Description ( STRING ) ; clear Viewer ( ) ; } f Pagebook . show Page ( control ) ; }
@ Override protected void on Activity Result ( int request Code , int result Code , Intent data ) { super . on Activity Result ( request Code , result Code , data ) ; if ( request Code == REQUEST CODE AUTOCOMPLETE ) { if ( result Code == RESULT OK ) { Place place = Place Autocomplete . get Place ( this , data ) ; Log . i ( TAG , STRING + place . get Name ( ) ) ; m Place Details Text . set Text ( format Place Details ( get Resources ( ) , place . get Name ( ) , place . get Id ( ) , place . get Address ( ) , place . get Phone Number ( ) , place . get Website Uri ( ) ) ) ; Char Sequence attributions = place . get Attributions ( ) ; if ( ! Text Utils . is Empty ( attributions ) ) { m Place Attribution . set Text ( Html . from Html ( attributions . to String ( ) ) ) ; } else { m Place Attribution . set Text ( STRING ) ; } } else if ( result Code == Place Autocomplete . RESULT ERROR ) { Status status = Place Autocomplete . get Status ( this , data ) ; Log . e ( TAG , STRING + status . to String ( ) ) ; } else if ( result Code == RESULT CANCELED ) { } } }
@ Override protected void on Activity Result ( int request Code , int result Code , Intent data ) { super . on Activity Result ( request Code , result Code , data ) ; if ( request Code == REQUEST CODE AUTOCOMPLETE ) { if ( result Code == RESULT OK ) { Place place = Place Autocomplete . get Place ( this , data ) ; Log . i ( TAG , STRING + place . get Name ( ) ) ; m Place Details Text . set Text ( format Place Details ( get Resources ( ) , place . get Name ( ) , place . get Id ( ) , place . get Address ( ) , place . get Phone Number ( ) , place . get Website Uri ( ) ) ) ; Char Sequence attributions = place . get Attributions ( ) ; if ( ! Text Utils . is Empty ( attributions ) ) { m Place Attribution . set Text ( Html . from Html ( attributions . to String ( ) ) ) ; } else { m Place Attribution . set Text ( STRING ) ; } } else if ( result Code == Place Autocomplete . RESULT ERROR ) { Status status = Place Autocomplete . get Status ( this , data ) ; Log . e ( TAG , STRING + status . to String ( ) ) ; } else if ( result Code == RESULT CANCELED ) { } } }
@ Override public Void call ( ) throws Exception { try { Node Holder node Holder = process Data Rows ( data Rows ) ; int index In Node Holder Array = ( sequence Number - NUM ) % number Of Cores ; blocklet Data Holder . put ( node Holder , index In Node Holder Array ) ; return null ; } catch ( Throwable throwable ) { consumer Executor Service . shutdown Now ( ) ; reset Blocklet Processing Count ( ) ; throw new Carbon Data Writer Exception ( throwable . get Message ( ) ) ; } }
@ Override public Void call ( ) throws Exception { try { Node Holder node Holder = process Data Rows ( data Rows ) ; int index In Node Holder Array = ( sequence Number - NUM ) % number Of Cores ; blocklet Data Holder . put ( node Holder , index In Node Holder Array ) ; return null ; } catch ( Throwable throwable ) { consumer Executor Service . shutdown Now ( ) ; reset Blocklet Processing Count ( ) ; throw new Carbon Data Writer Exception ( throwable . get Message ( ) ) ; } }
final boolean are Bounds Valid ( ) { Container cont = get Container ( ) ; return cont == null || cont . is Valid ( ) || cont . get Layout ( ) == null ; }
final boolean are Bounds Valid ( ) { Container cont = get Container ( ) ; return cont == null || cont . is Valid ( ) || cont . get Layout ( ) == null ; }
final boolean are Bounds Valid ( ) { Container cont = get Container ( ) ; return cont == null || cont . is Valid ( ) || cont . get Layout ( ) == null ; }
final boolean are Bounds Valid ( ) { Container cont = get Container ( ) ; return cont == null || cont . is Valid ( ) || cont . get Layout ( ) == null ; }
final boolean are Bounds Valid ( ) { Container cont = get Container ( ) ; return cont == null || cont . is Valid ( ) || cont . get Layout ( ) == null ; }
final boolean are Bounds Valid ( ) { Container cont = get Container ( ) ; return cont == null || cont . is Valid ( ) || cont . get Layout ( ) == null ; }
final boolean are Bounds Valid ( ) { Container cont = get Container ( ) ; return cont == null || cont . is Valid ( ) || cont . get Layout ( ) == null ; }
final private String syntax Def 2 Syntax Desc ( Attributes attrs ) throws Naming Exception { String Buffer syntax Desc = new String Buffer ( STRING ) ; Attribute attr = null ; int count = NUM ; attr = attrs . get ( NUMERICOID ID ) ; if ( attr != null ) { syntax Desc . append ( write Numeric OID ( attr ) ) ; count ++ ; } else { throw new Configuration Exception ( STRING + STRING ) ; } attr = attrs . get ( DESC ID ) ; if ( attr != null ) { syntax Desc . append ( write QD String ( attr ) ) ; count ++ ; } if ( count < attrs . size ( ) ) { String attr Id = null ; for ( Naming Enumeration < ? extends Attribute > ae = attrs . get All ( ) ; ae . has More Elements ( ) ; ) { attr = ae . next ( ) ; attr Id = attr . get ID ( ) ; if ( attr Id . equals ( NUMERICOID ID ) || attr Id . equals ( DESC ID ) ) { continue ; } else { syntax Desc . append ( write QD Strings ( attr ) ) ; } } } syntax Desc . append ( STRING ) ; return syntax Desc . to String ( ) ; }
final private String syntax Def 2 Syntax Desc ( Attributes attrs ) throws Naming Exception { String Buffer syntax Desc = new String Buffer ( STRING ) ; Attribute attr = null ; int count = NUM ; attr = attrs . get ( NUMERICOID ID ) ; if ( attr != null ) { syntax Desc . append ( write Numeric OID ( attr ) ) ; count ++ ; } else { throw new Configuration Exception ( STRING + STRING ) ; } attr = attrs . get ( DESC ID ) ; if ( attr != null ) { syntax Desc . append ( write QD String ( attr ) ) ; count ++ ; } if ( count < attrs . size ( ) ) { String attr Id = null ; for ( Naming Enumeration < ? extends Attribute > ae = attrs . get All ( ) ; ae . has More Elements ( ) ; ) { attr = ae . next ( ) ; attr Id = attr . get ID ( ) ; if ( attr Id . equals ( NUMERICOID ID ) || attr Id . equals ( DESC ID ) ) { continue ; } else { syntax Desc . append ( write QD Strings ( attr ) ) ; } } } syntax Desc . append ( STRING ) ; return syntax Desc . to String ( ) ; }
public Metadata Block Header ( boolean is Last Block , Block Type block Type , int data Length ) { Byte Buffer rawdata = Byte Buffer . allocate ( HEADER LENGTH ) ; this . block Type = block Type ; this . is Last Block = is Last Block ; this . data Length = data Length ; byte type ; if ( is Last Block ) { type = ( byte ) ( NUM | block Type . get Id ( ) ) ; } else { type = ( byte ) block Type . get Id ( ) ; } rawdata . put ( type ) ; rawdata . put ( ( byte ) ( ( data Length & NUM ) > > > NUM ) ) ; rawdata . put ( ( byte ) ( ( data Length & NUM ) > > > NUM ) ) ; rawdata . put ( ( byte ) ( data Length & NUM ) ) ; bytes = new byte [ HEADER LENGTH ] ; for ( int i = NUM ; i < HEADER LENGTH ; i ++ ) { bytes [ i ] = rawdata . get ( i ) ; } }
public Metadata Block Header ( boolean is Last Block , Block Type block Type , int data Length ) { Byte Buffer rawdata = Byte Buffer . allocate ( HEADER LENGTH ) ; this . block Type = block Type ; this . is Last Block = is Last Block ; this . data Length = data Length ; byte type ; if ( is Last Block ) { type = ( byte ) ( NUM | block Type . get Id ( ) ) ; } else { type = ( byte ) block Type . get Id ( ) ; } rawdata . put ( type ) ; rawdata . put ( ( byte ) ( ( data Length & NUM ) > > > NUM ) ) ; rawdata . put ( ( byte ) ( ( data Length & NUM ) > > > NUM ) ) ; rawdata . put ( ( byte ) ( data Length & NUM ) ) ; bytes = new byte [ HEADER LENGTH ] ; for ( int i = NUM ; i < HEADER LENGTH ; i ++ ) { bytes [ i ] = rawdata . get ( i ) ; } }
@ Bean public Es Settings Holder es Settings Holder ( ) { return new Default Settings Holder ( ) ; }
private Referer Lookup lookup Referer ( String referer Host , String referer Path , Boolean include Path ) { Referer Lookup referer = ( include Path ) ? referers . get ( referer Host + referer Path ) : referers . get ( referer Host ) ; if ( include Path && referer == null ) { final String [ ] path Elements = referer Path . split ( STRING ) ; if ( path Elements . length > NUM ) { referer = referers . get ( referer Host + STRING + path Elements [ NUM ] ) ; } } if ( referer == null ) { final int idx = referer Host . index Of ( STRING ) ; if ( idx == - NUM ) { return null ; } else { return lookup Referer ( referer Host . substring ( idx + NUM ) , referer Path , include Path ) ; } } else { return referer ; } }
private Referer Lookup lookup Referer ( String referer Host , String referer Path , Boolean include Path ) { Referer Lookup referer = ( include Path ) ? referers . get ( referer Host + referer Path ) : referers . get ( referer Host ) ; if ( include Path && referer == null ) { final String [ ] path Elements = referer Path . split ( STRING ) ; if ( path Elements . length > NUM ) { referer = referers . get ( referer Host + STRING + path Elements [ NUM ] ) ; } } if ( referer == null ) { final int idx = referer Host . index Of ( STRING ) ; if ( idx == - NUM ) { return null ; } else { return lookup Referer ( referer Host . substring ( idx + NUM ) , referer Path , include Path ) ; } } else { return referer ; } }
private Referer Lookup lookup Referer ( String referer Host , String referer Path , Boolean include Path ) { Referer Lookup referer = ( include Path ) ? referers . get ( referer Host + referer Path ) : referers . get ( referer Host ) ; if ( include Path && referer == null ) { final String [ ] path Elements = referer Path . split ( STRING ) ; if ( path Elements . length > NUM ) { referer = referers . get ( referer Host + STRING + path Elements [ NUM ] ) ; } } if ( referer == null ) { final int idx = referer Host . index Of ( STRING ) ; if ( idx == - NUM ) { return null ; } else { return lookup Referer ( referer Host . substring ( idx + NUM ) , referer Path , include Path ) ; } } else { return referer ; } }
public void add All ( final Collection elements ) { adjusting = BOOL ; Set old Selection = new Hash Set ( selection ) ; boolean rv = selection . add All ( elements ) ; adjusting = BOOL ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } old Selection = null ; }
public final boolean is Secure ( Socket sock ) throws Illegal Argument Exception { if ( sock == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( sock . get Class ( ) != Socket . class ) { throw new Illegal Argument Exception ( STRING ) ; } if ( sock . is Closed ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } return BOOL ; }
public final boolean is Secure ( Socket sock ) throws Illegal Argument Exception { if ( sock == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( sock . get Class ( ) != Socket . class ) { throw new Illegal Argument Exception ( STRING ) ; } if ( sock . is Closed ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } return BOOL ; }
public Stax Writer ( final Q Name Map qname Map , final XML Stream Writer out , final boolean write Enclosing Document , final boolean namespace Repairing Mode , final Name Coder name Coder ) throws XML Stream Exception { super ( name Coder ) ; this . qname Map = qname Map ; this . out = out ; this . write Enclosing Document = write Enclosing Document ; this . namespace Repairing Mode = namespace Repairing Mode ; if ( write Enclosing Document ) { out . write Start Document ( ) ; } }
public Stax Writer ( final Q Name Map qname Map , final XML Stream Writer out , final boolean write Enclosing Document , final boolean namespace Repairing Mode , final Name Coder name Coder ) throws XML Stream Exception { super ( name Coder ) ; this . qname Map = qname Map ; this . out = out ; this . write Enclosing Document = write Enclosing Document ; this . namespace Repairing Mode = namespace Repairing Mode ; if ( write Enclosing Document ) { out . write Start Document ( ) ; } }
@ Zap Api Ignore public boolean is Confirm Remove Domain Always In Scope ( ) { return this . confirm Remove Domain Always In Scope ; }
public void CL ( int session Number , String client Line ) { this . max Session Number = Math . max ( this . max Session Number , session Number ) ; test Elements . add ( new Client Request ( session Number , client Line ) ) ; }
public void send ( Jetstream Message msg ) throws Exception { if ( msg == null ) { throw new Exception ( STRING ) ; } Request req = new ZK Send Message Request ( this , msg ) ; if ( ! m request Queue . offer ( req ) ) LOGGER . warn ( STRING ) ; }
public synchronized List < Call > running Calls ( ) { List < Call > result = new Array List < > ( ) ; result . add All ( running Sync Calls ) ; for ( Async Call async Call : running Async Calls ) { result . add ( async Call . get ( ) ) ; } return Collections . unmodifiable List ( result ) ; }
public void remove Overflow Command ( Command cmd ) { overflow Commands . remove ( cmd ) ; }
public void remove Overflow Command ( Command cmd ) { overflow Commands . remove ( cmd ) ; }
public void remove Overflow Command ( Command cmd ) { overflow Commands . remove ( cmd ) ; }
public void remove ( T graphic ) { synchronized ( m Lock ) { m Graphics . remove ( graphic ) ; if ( m First Graphic != null && m First Graphic . equals ( graphic ) ) { m First Graphic = null ; } } post Invalidate ( ) ; }
public static Long to Long ( Object o ) throws Page Exception { if ( o instanceof Long ) return ( Long ) o ; return Long . value Of ( to Long Value ( o ) ) ; }
public static Long to Long ( Object o ) throws Page Exception { if ( o instanceof Long ) return ( Long ) o ; return Long . value Of ( to Long Value ( o ) ) ; }
private void create Single Style Legend ( Map < String , Style > style Map , Styled Layer selected Styled Layer , Style selected Style ) { List < Style > style List = null ; if ( selected Styled Layer instanceof Named Layer Impl ) { Named Layer Impl named Layer = ( Named Layer Impl ) selected Styled Layer ; style List = named Layer . styles ( ) ; } else if ( selected Styled Layer instanceof User Layer Impl ) { User Layer Impl user Layer = ( User Layer Impl ) selected Styled Layer ; style List = user Layer . user Styles ( ) ; } String style Name ; if ( selected Style . get Name ( ) != null ) { style Name = selected Style . get Name ( ) ; } else { style Name = String . format ( STRING , style List . index Of ( selected Style ) ) ; } style Map . put ( style Name , selected Style ) ; }
public Event Bean [ ] to Array ( ) { if ( first Event == null ) { return new Event Bean [ NUM ] ; } if ( additional Events == null ) { return new Event Bean [ ] { first Event } ; } Event Bean [ ] events = new Event Bean [ NUM + additional Events . size ( ) ] ; events [ NUM ] = first Event ; int count = NUM ; for ( Event Bean the Event : additional Events ) { events [ count ] = the Event ; count ++ ; } return events ; }
private void retry Failed Interfaces ( ) { final Level level = multicast Interfaces Specified ? Level . INFO : Level . FINE ; if ( logger . is Loggable ( level ) ) logger . log ( level , STRING + failed Interfaces . size ( ) + STRING ) ; for ( Iterator < Network Interface > i = failed Interfaces . iterator ( ) ; i . has Next ( ) ; ) { Network Interface nic = i . next ( ) ; long start Time = Log Helper . get Curr Time If Needed ( logger , level ) ; try { if ( nic != null ) socket . set Network Interface ( nic ) ; socket . join Group ( request Addr ) ; i . remove ( ) ; if ( logger . is Loggable ( level ) ) { String message = nic == null ? STRING : STRING + nic ; Log Helper . log Duration ( logger , level , start Time , message ) ; } } catch ( IO Exception e ) { if ( logger . is Loggable ( level ) ) { String message = nic == null ? STRING : STRING + nic ; Log Helper . log Duration ( logger , level , start Time , message ) ; } } } }
private void retry Failed Interfaces ( ) { final Level level = multicast Interfaces Specified ? Level . INFO : Level . FINE ; if ( logger . is Loggable ( level ) ) logger . log ( level , STRING + failed Interfaces . size ( ) + STRING ) ; for ( Iterator < Network Interface > i = failed Interfaces . iterator ( ) ; i . has Next ( ) ; ) { Network Interface nic = i . next ( ) ; long start Time = Log Helper . get Curr Time If Needed ( logger , level ) ; try { if ( nic != null ) socket . set Network Interface ( nic ) ; socket . join Group ( request Addr ) ; i . remove ( ) ; if ( logger . is Loggable ( level ) ) { String message = nic == null ? STRING : STRING + nic ; Log Helper . log Duration ( logger , level , start Time , message ) ; } } catch ( IO Exception e ) { if ( logger . is Loggable ( level ) ) { String message = nic == null ? STRING : STRING + nic ; Log Helper . log Duration ( logger , level , start Time , message ) ; } } } }
private static void adjust Abs ( double [ ] array , int lower , int upper ) { int j , k ; double temp ; j = lower ; k = lower * NUM ; while ( k <= upper ) { if ( ( k < upper ) && ( Math . abs ( array [ k - NUM ] ) < Math . abs ( array [ k ] ) ) ) { k += NUM ; } if ( Math . abs ( array [ j - NUM ] ) < Math . abs ( array [ k - NUM ] ) ) { temp = array [ j - NUM ] ; array [ j - NUM ] = array [ k - NUM ] ; array [ k - NUM ] = temp ; } j = k ; k *= NUM ; } }
private static void adjust Abs ( double [ ] array , int lower , int upper ) { int j , k ; double temp ; j = lower ; k = lower * NUM ; while ( k <= upper ) { if ( ( k < upper ) && ( Math . abs ( array [ k - NUM ] ) < Math . abs ( array [ k ] ) ) ) { k += NUM ; } if ( Math . abs ( array [ j - NUM ] ) < Math . abs ( array [ k - NUM ] ) ) { temp = array [ j - NUM ] ; array [ j - NUM ] = array [ k - NUM ] ; array [ k - NUM ] = temp ; } j = k ; k *= NUM ; } }
private static void adjust Abs ( double [ ] array , int lower , int upper ) { int j , k ; double temp ; j = lower ; k = lower * NUM ; while ( k <= upper ) { if ( ( k < upper ) && ( Math . abs ( array [ k - NUM ] ) < Math . abs ( array [ k ] ) ) ) { k += NUM ; } if ( Math . abs ( array [ j - NUM ] ) < Math . abs ( array [ k - NUM ] ) ) { temp = array [ j - NUM ] ; array [ j - NUM ] = array [ k - NUM ] ; array [ k - NUM ] = temp ; } j = k ; k *= NUM ; } }
private static void adjust Abs ( double [ ] array , int lower , int upper ) { int j , k ; double temp ; j = lower ; k = lower * NUM ; while ( k <= upper ) { if ( ( k < upper ) && ( Math . abs ( array [ k - NUM ] ) < Math . abs ( array [ k ] ) ) ) { k += NUM ; } if ( Math . abs ( array [ j - NUM ] ) < Math . abs ( array [ k - NUM ] ) ) { temp = array [ j - NUM ] ; array [ j - NUM ] = array [ k - NUM ] ; array [ k - NUM ] = temp ; } j = k ; k *= NUM ; } }
private static void adjust Abs ( double [ ] array , int lower , int upper ) { int j , k ; double temp ; j = lower ; k = lower * NUM ; while ( k <= upper ) { if ( ( k < upper ) && ( Math . abs ( array [ k - NUM ] ) < Math . abs ( array [ k ] ) ) ) { k += NUM ; } if ( Math . abs ( array [ j - NUM ] ) < Math . abs ( array [ k - NUM ] ) ) { temp = array [ j - NUM ] ; array [ j - NUM ] = array [ k - NUM ] ; array [ k - NUM ] = temp ; } j = k ; k *= NUM ; } }
private static void adjust Abs ( double [ ] array , int lower , int upper ) { int j , k ; double temp ; j = lower ; k = lower * NUM ; while ( k <= upper ) { if ( ( k < upper ) && ( Math . abs ( array [ k - NUM ] ) < Math . abs ( array [ k ] ) ) ) { k += NUM ; } if ( Math . abs ( array [ j - NUM ] ) < Math . abs ( array [ k - NUM ] ) ) { temp = array [ j - NUM ] ; array [ j - NUM ] = array [ k - NUM ] ; array [ k - NUM ] = temp ; } j = k ; k *= NUM ; } }
public void add Maps Id Mapping ( Database Mapping mapping ) { maps Id Mappings . add ( mapping ) ; }
public void add Maps Id Mapping ( Database Mapping mapping ) { maps Id Mappings . add ( mapping ) ; }
public void add Maps Id Mapping ( Database Mapping mapping ) { maps Id Mappings . add ( mapping ) ; }
public void add Maps Id Mapping ( Database Mapping mapping ) { maps Id Mappings . add ( mapping ) ; }
public void add Maps Id Mapping ( Database Mapping mapping ) { maps Id Mappings . add ( mapping ) ; }
public void add Maps Id Mapping ( Database Mapping mapping ) { maps Id Mappings . add ( mapping ) ; }
public void add Maps Id Mapping ( Database Mapping mapping ) { maps Id Mappings . add ( mapping ) ; }
public void add Maps Id Mapping ( Database Mapping mapping ) { maps Id Mappings . add ( mapping ) ; }
public Proxy Settings add Header ( String name , String value ) { if ( name == null || name . length ( ) == NUM ) { return this ; } List < String > list = m Headers . get ( name ) ; if ( list == null ) { list = new Array List < String > ( ) ; m Headers . put ( name , list ) ; } list . add ( value ) ; return this ; }
public static boolean is Numeric ( Type Mirror type ) { switch ( type . get Kind ( ) ) { case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : return BOOL ; default : return BOOL ; } }
protected void serialize ( String filename ) { classifier . serialize Classifier ( filename ) ; }
@ Override public void force Refetch ( String url , Web Page page , boolean asap ) { if ( page . get Fetch Interval ( ) > max Interval ) page . set Fetch Interval ( Math . round ( max Interval * NUM ) ) ; page . set Status ( ( int ) Crawl Status . STATUS UNFETCHED ) ; page . set Retries Since Fetch ( NUM ) ; page . set Modified Time ( NUM ) ; if ( asap ) page . set Fetch Time ( System . current Time Millis ( ) ) ; }
@ Override public void force Refetch ( String url , Web Page page , boolean asap ) { if ( page . get Fetch Interval ( ) > max Interval ) page . set Fetch Interval ( Math . round ( max Interval * NUM ) ) ; page . set Status ( ( int ) Crawl Status . STATUS UNFETCHED ) ; page . set Retries Since Fetch ( NUM ) ; page . set Modified Time ( NUM ) ; if ( asap ) page . set Fetch Time ( System . current Time Millis ( ) ) ; }
@ Override public void force Refetch ( String url , Web Page page , boolean asap ) { if ( page . get Fetch Interval ( ) > max Interval ) page . set Fetch Interval ( Math . round ( max Interval * NUM ) ) ; page . set Status ( ( int ) Crawl Status . STATUS UNFETCHED ) ; page . set Retries Since Fetch ( NUM ) ; page . set Modified Time ( NUM ) ; if ( asap ) page . set Fetch Time ( System . current Time Millis ( ) ) ; }
protected void create Test Data Files ( Path local Path , List < Manifest File > manifest Files ) throws Exception { for ( Manifest File manifest File : manifest Files ) { create Local File ( local Path . to String ( ) , manifest File . get File Name ( ) , manifest File . get File Size Bytes ( ) ) ; } }
protected void create Test Data Files ( Path local Path , List < Manifest File > manifest Files ) throws Exception { for ( Manifest File manifest File : manifest Files ) { create Local File ( local Path . to String ( ) , manifest File . get File Name ( ) , manifest File . get File Size Bytes ( ) ) ; } }
private static void add Vertical Small Spring ( Path 2 D . Float path , int x0 , int y1 , int y2 ) { int spring Height = NUM ; int spring Width = NUM ; int distance = Math . abs ( y2 - y1 ) ; int num Springs = ( distance / ( spring Height ) ) ; int left Over = ( distance - ( num Springs * spring Height ) ) / NUM ; path . line To ( x0 , y1 ) ; path . line To ( x0 , y1 - left Over ) ; int count = NUM ; if ( y1 > y2 ) { for ( int y = y1 - left Over ; y > y2 + left Over ; y -= spring Height ) { int x = ( count % NUM == NUM ) ? x0 - spring Width : x0 + spring Width ; path . line To ( x , y ) ; count ++ ; } } else { for ( int y = y1 + left Over ; y < y2 - left Over ; y += spring Height ) { int x = ( count % NUM == NUM ) ? x0 - spring Width : x0 + spring Width ; path . line To ( x , y ) ; count ++ ; } } path . line To ( x0 , y2 + left Over ) ; path . line To ( x0 , y2 ) ; }
void dispatch Events ( ) { Event Info event Info = null ; synchronized ( this ) { try { if ( event Queue . size ( ) == NUM ) { if ( auto Closing Clips . size ( ) > NUM || line Monitors . size ( ) > NUM ) { int wait Time = AUTO CLOSE TIME ; if ( line Monitors . size ( ) > NUM ) { wait Time = LINE MONITOR TIME ; } wait ( wait Time ) ; } else { wait ( ) ; } } } catch ( Interrupted Exception e ) { } if ( event Queue . size ( ) > NUM ) { event Info = ( Event Info ) event Queue . remove ( NUM ) ; } } if ( event Info != null ) { process Event ( event Info ) ; } else { if ( auto Closing Clips . size ( ) > NUM ) { close Auto Closing Clips ( ) ; } if ( line Monitors . size ( ) > NUM ) { monitor Lines ( ) ; } } }
void dispatch Events ( ) { Event Info event Info = null ; synchronized ( this ) { try { if ( event Queue . size ( ) == NUM ) { if ( auto Closing Clips . size ( ) > NUM || line Monitors . size ( ) > NUM ) { int wait Time = AUTO CLOSE TIME ; if ( line Monitors . size ( ) > NUM ) { wait Time = LINE MONITOR TIME ; } wait ( wait Time ) ; } else { wait ( ) ; } } } catch ( Interrupted Exception e ) { } if ( event Queue . size ( ) > NUM ) { event Info = ( Event Info ) event Queue . remove ( NUM ) ; } } if ( event Info != null ) { process Event ( event Info ) ; } else { if ( auto Closing Clips . size ( ) > NUM ) { close Auto Closing Clips ( ) ; } if ( line Monitors . size ( ) > NUM ) { monitor Lines ( ) ; } } }
void dispatch Events ( ) { Event Info event Info = null ; synchronized ( this ) { try { if ( event Queue . size ( ) == NUM ) { if ( auto Closing Clips . size ( ) > NUM || line Monitors . size ( ) > NUM ) { int wait Time = AUTO CLOSE TIME ; if ( line Monitors . size ( ) > NUM ) { wait Time = LINE MONITOR TIME ; } wait ( wait Time ) ; } else { wait ( ) ; } } } catch ( Interrupted Exception e ) { } if ( event Queue . size ( ) > NUM ) { event Info = ( Event Info ) event Queue . remove ( NUM ) ; } } if ( event Info != null ) { process Event ( event Info ) ; } else { if ( auto Closing Clips . size ( ) > NUM ) { close Auto Closing Clips ( ) ; } if ( line Monitors . size ( ) > NUM ) { monitor Lines ( ) ; } } }
void dispatch Events ( ) { Event Info event Info = null ; synchronized ( this ) { try { if ( event Queue . size ( ) == NUM ) { if ( auto Closing Clips . size ( ) > NUM || line Monitors . size ( ) > NUM ) { int wait Time = AUTO CLOSE TIME ; if ( line Monitors . size ( ) > NUM ) { wait Time = LINE MONITOR TIME ; } wait ( wait Time ) ; } else { wait ( ) ; } } } catch ( Interrupted Exception e ) { } if ( event Queue . size ( ) > NUM ) { event Info = ( Event Info ) event Queue . remove ( NUM ) ; } } if ( event Info != null ) { process Event ( event Info ) ; } else { if ( auto Closing Clips . size ( ) > NUM ) { close Auto Closing Clips ( ) ; } if ( line Monitors . size ( ) > NUM ) { monitor Lines ( ) ; } } }
void dispatch Events ( ) { Event Info event Info = null ; synchronized ( this ) { try { if ( event Queue . size ( ) == NUM ) { if ( auto Closing Clips . size ( ) > NUM || line Monitors . size ( ) > NUM ) { int wait Time = AUTO CLOSE TIME ; if ( line Monitors . size ( ) > NUM ) { wait Time = LINE MONITOR TIME ; } wait ( wait Time ) ; } else { wait ( ) ; } } } catch ( Interrupted Exception e ) { } if ( event Queue . size ( ) > NUM ) { event Info = ( Event Info ) event Queue . remove ( NUM ) ; } } if ( event Info != null ) { process Event ( event Info ) ; } else { if ( auto Closing Clips . size ( ) > NUM ) { close Auto Closing Clips ( ) ; } if ( line Monitors . size ( ) > NUM ) { monitor Lines ( ) ; } } }
void dispatch Events ( ) { Event Info event Info = null ; synchronized ( this ) { try { if ( event Queue . size ( ) == NUM ) { if ( auto Closing Clips . size ( ) > NUM || line Monitors . size ( ) > NUM ) { int wait Time = AUTO CLOSE TIME ; if ( line Monitors . size ( ) > NUM ) { wait Time = LINE MONITOR TIME ; } wait ( wait Time ) ; } else { wait ( ) ; } } } catch ( Interrupted Exception e ) { } if ( event Queue . size ( ) > NUM ) { event Info = ( Event Info ) event Queue . remove ( NUM ) ; } } if ( event Info != null ) { process Event ( event Info ) ; } else { if ( auto Closing Clips . size ( ) > NUM ) { close Auto Closing Clips ( ) ; } if ( line Monitors . size ( ) > NUM ) { monitor Lines ( ) ; } } }
void dispatch Events ( ) { Event Info event Info = null ; synchronized ( this ) { try { if ( event Queue . size ( ) == NUM ) { if ( auto Closing Clips . size ( ) > NUM || line Monitors . size ( ) > NUM ) { int wait Time = AUTO CLOSE TIME ; if ( line Monitors . size ( ) > NUM ) { wait Time = LINE MONITOR TIME ; } wait ( wait Time ) ; } else { wait ( ) ; } } } catch ( Interrupted Exception e ) { } if ( event Queue . size ( ) > NUM ) { event Info = ( Event Info ) event Queue . remove ( NUM ) ; } } if ( event Info != null ) { process Event ( event Info ) ; } else { if ( auto Closing Clips . size ( ) > NUM ) { close Auto Closing Clips ( ) ; } if ( line Monitors . size ( ) > NUM ) { monitor Lines ( ) ; } } }
void dispatch Events ( ) { Event Info event Info = null ; synchronized ( this ) { try { if ( event Queue . size ( ) == NUM ) { if ( auto Closing Clips . size ( ) > NUM || line Monitors . size ( ) > NUM ) { int wait Time = AUTO CLOSE TIME ; if ( line Monitors . size ( ) > NUM ) { wait Time = LINE MONITOR TIME ; } wait ( wait Time ) ; } else { wait ( ) ; } } } catch ( Interrupted Exception e ) { } if ( event Queue . size ( ) > NUM ) { event Info = ( Event Info ) event Queue . remove ( NUM ) ; } } if ( event Info != null ) { process Event ( event Info ) ; } else { if ( auto Closing Clips . size ( ) > NUM ) { close Auto Closing Clips ( ) ; } if ( line Monitors . size ( ) > NUM ) { monitor Lines ( ) ; } } }
void dispatch Events ( ) { Event Info event Info = null ; synchronized ( this ) { try { if ( event Queue . size ( ) == NUM ) { if ( auto Closing Clips . size ( ) > NUM || line Monitors . size ( ) > NUM ) { int wait Time = AUTO CLOSE TIME ; if ( line Monitors . size ( ) > NUM ) { wait Time = LINE MONITOR TIME ; } wait ( wait Time ) ; } else { wait ( ) ; } } } catch ( Interrupted Exception e ) { } if ( event Queue . size ( ) > NUM ) { event Info = ( Event Info ) event Queue . remove ( NUM ) ; } } if ( event Info != null ) { process Event ( event Info ) ; } else { if ( auto Closing Clips . size ( ) > NUM ) { close Auto Closing Clips ( ) ; } if ( line Monitors . size ( ) > NUM ) { monitor Lines ( ) ; } } }
void dispatch Events ( ) { Event Info event Info = null ; synchronized ( this ) { try { if ( event Queue . size ( ) == NUM ) { if ( auto Closing Clips . size ( ) > NUM || line Monitors . size ( ) > NUM ) { int wait Time = AUTO CLOSE TIME ; if ( line Monitors . size ( ) > NUM ) { wait Time = LINE MONITOR TIME ; } wait ( wait Time ) ; } else { wait ( ) ; } } } catch ( Interrupted Exception e ) { } if ( event Queue . size ( ) > NUM ) { event Info = ( Event Info ) event Queue . remove ( NUM ) ; } } if ( event Info != null ) { process Event ( event Info ) ; } else { if ( auto Closing Clips . size ( ) > NUM ) { close Auto Closing Clips ( ) ; } if ( line Monitors . size ( ) > NUM ) { monitor Lines ( ) ; } } }
public void write Byte Stream ( Byte Array Output Stream s ) throws IO Exception { s . write To ( message Output ) ; }
protected int num Auto Moves ( ) { return auto Moves . size ( ) ; }
private long offset 2 Physical Address ( final long offset ) { return offset + header Size ; }
private long offset 2 Physical Address ( final long offset ) { return offset + header Size ; }
private long offset 2 Physical Address ( final long offset ) { return offset + header Size ; }
private long offset 2 Physical Address ( final long offset ) { return offset + header Size ; }
protected void compute P Dists ( Relation < O > relation , KNN Query < O > knn , Writable Double Data Store pdists ) { Finite Progress prds Progress = LOG . is Verbose ( ) ? new Finite Progress ( STRING , relation . size ( ) , LOG ) : null ; for ( DBID Iter iditer = relation . iter DBI Ds ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { final KNN List neighbors = knn . get KNN For DBID ( iditer , kreach + NUM ) ; int ks = NUM ; double ssum = NUM ; for ( Double DBID List Iter neighbor = neighbors . iter ( ) ; neighbor . valid ( ) && ks < kreach ; neighbor . advance ( ) ) { if ( DBID Util . equal ( neighbor , iditer ) ) { continue ; } final double d = neighbor . double Value ( ) ; ssum += d * d ; ks ++ ; } double pdist = ks > NUM ? Math . sqrt ( ssum / ks ) : NUM ; pdists . put Double ( iditer , pdist ) ; LOG . increment Processed ( prds Progress ) ; } LOG . ensure Completed ( prds Progress ) ; }
public void nullify Item ( String s Item ) { N Gram Histogram . put ( s Item , NUM ) ; }
public static char [ ] ensure Capacity ( final char [ ] array , final int length , final int preserve ) { if ( length > array . length ) { final char t [ ] = new char [ length ] ; System . arraycopy ( array , NUM , t , NUM , preserve ) ; return t ; } return array ; }
public static char [ ] ensure Capacity ( final char [ ] array , final int length , final int preserve ) { if ( length > array . length ) { final char t [ ] = new char [ length ] ; System . arraycopy ( array , NUM , t , NUM , preserve ) ; return t ; } return array ; }
public static char [ ] ensure Capacity ( final char [ ] array , final int length , final int preserve ) { if ( length > array . length ) { final char t [ ] = new char [ length ] ; System . arraycopy ( array , NUM , t , NUM , preserve ) ; return t ; } return array ; }
public void test Single Sentences ( ) throws Exception { Break Iterator expected = Break Iterator . get Sentence Instance ( Locale . ROOT ) ; Break Iterator actual = new Whole Break Iterator ( ) ; assert Same Breaks ( STRING , expected , actual ) ; assert Same Breaks ( STRING , expected , actual ) ; assert Same Breaks ( STRING , expected , actual ) ; assert Same Breaks ( STRING , expected , actual ) ; }
public void test Single Sentences ( ) throws Exception { Break Iterator expected = Break Iterator . get Sentence Instance ( Locale . ROOT ) ; Break Iterator actual = new Whole Break Iterator ( ) ; assert Same Breaks ( STRING , expected , actual ) ; assert Same Breaks ( STRING , expected , actual ) ; assert Same Breaks ( STRING , expected , actual ) ; assert Same Breaks ( STRING , expected , actual ) ; }
public void test Single Sentences ( ) throws Exception { Break Iterator expected = Break Iterator . get Sentence Instance ( Locale . ROOT ) ; Break Iterator actual = new Whole Break Iterator ( ) ; assert Same Breaks ( STRING , expected , actual ) ; assert Same Breaks ( STRING , expected , actual ) ; assert Same Breaks ( STRING , expected , actual ) ; assert Same Breaks ( STRING , expected , actual ) ; }
public void add Virtual Method ( Encoded Method method ) { if ( method == null ) { throw new Null Pointer Exception ( STRING ) ; } virtual Methods . add ( method ) ; }
public int min Meeting Rooms ( Interval [ ] intervals ) { if ( intervals == null || intervals . length == NUM ) { return NUM ; } Arrays . sort ( intervals , null ) ; Priority Queue < Interval > min Heap = new Priority Queue < > ( intervals . length , null ) ; for ( Interval i : intervals ) { if ( ! min Heap . is Empty ( ) && i . start >= min Heap . peek ( ) . end ) { min Heap . poll ( ) ; } min Heap . add ( i ) ; } return min Heap . size ( ) ; }
public int min Meeting Rooms ( Interval [ ] intervals ) { if ( intervals == null || intervals . length == NUM ) { return NUM ; } Arrays . sort ( intervals , null ) ; Priority Queue < Interval > min Heap = new Priority Queue < > ( intervals . length , null ) ; for ( Interval i : intervals ) { if ( ! min Heap . is Empty ( ) && i . start >= min Heap . peek ( ) . end ) { min Heap . poll ( ) ; } min Heap . add ( i ) ; } return min Heap . size ( ) ; }
public int min Meeting Rooms ( Interval [ ] intervals ) { if ( intervals == null || intervals . length == NUM ) { return NUM ; } Arrays . sort ( intervals , null ) ; Priority Queue < Interval > min Heap = new Priority Queue < > ( intervals . length , null ) ; for ( Interval i : intervals ) { if ( ! min Heap . is Empty ( ) && i . start >= min Heap . peek ( ) . end ) { min Heap . poll ( ) ; } min Heap . add ( i ) ; } return min Heap . size ( ) ; }
public int min Meeting Rooms ( Interval [ ] intervals ) { if ( intervals == null || intervals . length == NUM ) { return NUM ; } Arrays . sort ( intervals , null ) ; Priority Queue < Interval > min Heap = new Priority Queue < > ( intervals . length , null ) ; for ( Interval i : intervals ) { if ( ! min Heap . is Empty ( ) && i . start >= min Heap . peek ( ) . end ) { min Heap . poll ( ) ; } min Heap . add ( i ) ; } return min Heap . size ( ) ; }
public int min Meeting Rooms ( Interval [ ] intervals ) { if ( intervals == null || intervals . length == NUM ) { return NUM ; } Arrays . sort ( intervals , null ) ; Priority Queue < Interval > min Heap = new Priority Queue < > ( intervals . length , null ) ; for ( Interval i : intervals ) { if ( ! min Heap . is Empty ( ) && i . start >= min Heap . peek ( ) . end ) { min Heap . poll ( ) ; } min Heap . add ( i ) ; } return min Heap . size ( ) ; }
@ Override public Node insert Before ( Node new Child , Node ref Child ) throws DOM Exception { int type = new Child . get Node Type ( ) ; if ( error Checking ) { if ( needs Sync Children ( ) ) { synchronize Children ( ) ; } if ( ( type == Node . ELEMENT NODE && doc Element != null ) || ( type == Node . DOCUMENT TYPE NODE && doc Type != null ) ) { String msg = DOM Message Formatter . format Message ( DOM Message Formatter . DOM DOMAIN , STRING , null ) ; throw new DOM Exception ( DOM Exception . HIERARCHY REQUEST ERR , msg ) ; } } if ( new Child . get Owner Document ( ) == null && new Child instanceof Document Type Impl ) { ( ( Document Type Impl ) new Child ) . owner Document = this ; } super . insert Before ( new Child , ref Child ) ; if ( type == Node . ELEMENT NODE ) { doc Element = ( Element Impl ) new Child ; } else if ( type == Node . DOCUMENT TYPE NODE ) { doc Type = ( Document Type Impl ) new Child ; } return new Child ; }
@ Override public Node insert Before ( Node new Child , Node ref Child ) throws DOM Exception { int type = new Child . get Node Type ( ) ; if ( error Checking ) { if ( needs Sync Children ( ) ) { synchronize Children ( ) ; } if ( ( type == Node . ELEMENT NODE && doc Element != null ) || ( type == Node . DOCUMENT TYPE NODE && doc Type != null ) ) { String msg = DOM Message Formatter . format Message ( DOM Message Formatter . DOM DOMAIN , STRING , null ) ; throw new DOM Exception ( DOM Exception . HIERARCHY REQUEST ERR , msg ) ; } } if ( new Child . get Owner Document ( ) == null && new Child instanceof Document Type Impl ) { ( ( Document Type Impl ) new Child ) . owner Document = this ; } super . insert Before ( new Child , ref Child ) ; if ( type == Node . ELEMENT NODE ) { doc Element = ( Element Impl ) new Child ; } else if ( type == Node . DOCUMENT TYPE NODE ) { doc Type = ( Document Type Impl ) new Child ; } return new Child ; }
@ Override public Node insert Before ( Node new Child , Node ref Child ) throws DOM Exception { int type = new Child . get Node Type ( ) ; if ( error Checking ) { if ( needs Sync Children ( ) ) { synchronize Children ( ) ; } if ( ( type == Node . ELEMENT NODE && doc Element != null ) || ( type == Node . DOCUMENT TYPE NODE && doc Type != null ) ) { String msg = DOM Message Formatter . format Message ( DOM Message Formatter . DOM DOMAIN , STRING , null ) ; throw new DOM Exception ( DOM Exception . HIERARCHY REQUEST ERR , msg ) ; } } if ( new Child . get Owner Document ( ) == null && new Child instanceof Document Type Impl ) { ( ( Document Type Impl ) new Child ) . owner Document = this ; } super . insert Before ( new Child , ref Child ) ; if ( type == Node . ELEMENT NODE ) { doc Element = ( Element Impl ) new Child ; } else if ( type == Node . DOCUMENT TYPE NODE ) { doc Type = ( Document Type Impl ) new Child ; } return new Child ; }
@ Override public Node insert Before ( Node new Child , Node ref Child ) throws DOM Exception { int type = new Child . get Node Type ( ) ; if ( error Checking ) { if ( needs Sync Children ( ) ) { synchronize Children ( ) ; } if ( ( type == Node . ELEMENT NODE && doc Element != null ) || ( type == Node . DOCUMENT TYPE NODE && doc Type != null ) ) { String msg = DOM Message Formatter . format Message ( DOM Message Formatter . DOM DOMAIN , STRING , null ) ; throw new DOM Exception ( DOM Exception . HIERARCHY REQUEST ERR , msg ) ; } } if ( new Child . get Owner Document ( ) == null && new Child instanceof Document Type Impl ) { ( ( Document Type Impl ) new Child ) . owner Document = this ; } super . insert Before ( new Child , ref Child ) ; if ( type == Node . ELEMENT NODE ) { doc Element = ( Element Impl ) new Child ; } else if ( type == Node . DOCUMENT TYPE NODE ) { doc Type = ( Document Type Impl ) new Child ; } return new Child ; }
public boolean text Is Present ( String course Ware Error Text , String text ) { if ( course Ware Error Text . equals ( text ) ) { return BOOL ; } else { return BOOL ; } }
void node Insert ( char opcode , int opdata , int insert At ) { ensure ( RE . node Size ) ; System . arraycopy ( instruction , insert At , instruction , insert At + RE . node Size , len Instruction - insert At ) ; instruction [ insert At ] = opcode ; instruction [ insert At + RE . offset Opdata ] = ( char ) opdata ; instruction [ insert At + RE . offset Next ] = NUM ; len Instruction += RE . node Size ; }
void node Insert ( char opcode , int opdata , int insert At ) { ensure ( RE . node Size ) ; System . arraycopy ( instruction , insert At , instruction , insert At + RE . node Size , len Instruction - insert At ) ; instruction [ insert At ] = opcode ; instruction [ insert At + RE . offset Opdata ] = ( char ) opdata ; instruction [ insert At + RE . offset Next ] = NUM ; len Instruction += RE . node Size ; }
private void history Add Changed ( ) { if ( history Text Edited ) { history Add ( get Text ( ) ) ; history Text Edited = BOOL ; history Position = history . size ( ) ; } }
public V remove ( K key ) { if ( key == null ) { throw new Null Pointer Exception ( STRING ) ; } final Iterator < P > it = key . iterator ( ) ; final Stack < Node < P , V > > stack = new Stack < Node < P , V > > ( ) ; Node < P , V > parent = null ; Node < P , V > node = this . root ; while ( it . has Next ( ) ) { final P key Part = it . next ( ) ; final Node < P , V > child = node . get Child With Null ( key Part ) ; if ( child == null ) { return null ; } else { stack . push ( node ) ; parent = node ; node = child ; } } if ( ! stack . is Empty ( ) ) { stack . pop ( ) ; } final V result = node . value ; V propagated Value ; if ( node . is Leaf ) { node . is Leaf = BOOL ; propagated Value = update Node ( parent , node , BOOL , null ) ; } else { return null ; } Node < P , V > child = null ; while ( ! stack . is Empty ( ) ) { child = node ; node = parent ; parent = stack . pop ( ) ; node . leaf Count -= NUM ; final boolean update After Remove = ( node . get Child With Null ( child . key Part ) == null ) ; propagated Value = update Node ( parent , node , update After Remove , propagated Value ) ; } this . size -= NUM ; return result ; }
public D Issuer Alternative Name ( J Dialog parent , byte [ ] value ) throws IO Exception { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public T remove Item By Position ( int position ) { if ( position < m Objects . size ( ) && position != INVALID POSITION ) { m Object Deleted = m Objects . remove ( position ) ; m Has Deleted Position = position ; notify Data Set Changed ( ) ; return m Object Deleted ; } else { throw new Index Out Of Bounds Exception ( STRING ) ; } }
public static void sort ( long [ ] array , int start , int end ) { Dual Pivot Quicksort . sort ( array , start , end ) ; }
public void write ( Byte Buffer buffer ) { buffer . put ( mask ) ; }
public static String bytes To Hex String ( byte [ ] bytes ) { String Buffer buf = new String Buffer ( bytes . length * NUM ) ; for ( byte b : bytes ) { String s = Integer . to String ( NUM & b , NUM ) ; if ( s . length ( ) < NUM ) buf . append ( STRING ) ; buf . append ( s ) ; } return buf . to String ( ) ; }
public static Map parse Command Line Arguments ( String [ ] args ) { Map < String , String > result = new Hash Map < > ( ) ; String key , value ; for ( int i = NUM ; i < args . length ; i ++ ) { key = args [ i ] ; if ( key . char At ( NUM ) == STRING ) { if ( i + NUM < args . length ) { value = args [ i + NUM ] ; if ( value . char At ( NUM ) != STRING ) { result . put ( key , value ) ; i ++ ; } else { result . put ( key , null ) ; } } else { result . put ( key , null ) ; } } } return result ; }
public Set < String > add Content ( Independent Distribution distrib ) { if ( ! paused ) { cur State . add To State ( distrib ) ; return update ( ) ; } else { log . info ( STRING + distrib ) ; return Collections . empty Set ( ) ; } }
public Set < String > add Content ( Independent Distribution distrib ) { if ( ! paused ) { cur State . add To State ( distrib ) ; return update ( ) ; } else { log . info ( STRING + distrib ) ; return Collections . empty Set ( ) ; } }
public Set < String > add Content ( Independent Distribution distrib ) { if ( ! paused ) { cur State . add To State ( distrib ) ; return update ( ) ; } else { log . info ( STRING + distrib ) ; return Collections . empty Set ( ) ; } }
public void update ( Graphics g ) { if ( is Showing ( ) ) { if ( ! ( peer instanceof Lightweight Peer ) ) { g . clear Rect ( NUM , NUM , width , height ) ; } paint ( g ) ; } }
public void update ( Graphics g ) { if ( is Showing ( ) ) { if ( ! ( peer instanceof Lightweight Peer ) ) { g . clear Rect ( NUM , NUM , width , height ) ; } paint ( g ) ; } }
public void update ( Graphics g ) { if ( is Showing ( ) ) { if ( ! ( peer instanceof Lightweight Peer ) ) { g . clear Rect ( NUM , NUM , width , height ) ; } paint ( g ) ; } }
public void update ( Graphics g ) { if ( is Showing ( ) ) { if ( ! ( peer instanceof Lightweight Peer ) ) { g . clear Rect ( NUM , NUM , width , height ) ; } paint ( g ) ; } }
public void stop ( ) { if ( ! is Running ( ) ) { return ; } delayed Handler . remove Callbacks And Messages ( null ) ; if ( handler Thread != null ) { handler Thread . quit ( ) ; } is Running = BOOL ; current Time = NUM ; stored Time += System . current Time Millis ( ) - start Time ; }
public void stop ( ) { if ( ! is Running ( ) ) { return ; } delayed Handler . remove Callbacks And Messages ( null ) ; if ( handler Thread != null ) { handler Thread . quit ( ) ; } is Running = BOOL ; current Time = NUM ; stored Time += System . current Time Millis ( ) - start Time ; }
protected void write Attribute ( String ns Alias , String name , String value ) throws IO Exception { writer . write ( STRING ) ; write Qualified Name ( ns Alias , name ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; if ( value != null ) { writer . write ( String Util . xml Escape ( value ) ) ; } writer . write ( STRING ) ; }
public static void add Glue ( J Component b , boolean horiz ) { b . add ( horiz ? Box . create Horizontal Glue ( ) : Box . create Vertical Glue ( ) ) ; }
static List < String > union ( List < String > x List , List < String > y List , boolean is Suffix ) { List < String > union List = new Array List < String > ( x List ) ; union List . add All ( y List ) ; Translator Utils . remove Duplicate Affix ( union List , is Suffix ) ; return union List ; }
static List < String > union ( List < String > x List , List < String > y List , boolean is Suffix ) { List < String > union List = new Array List < String > ( x List ) ; union List . add All ( y List ) ; Translator Utils . remove Duplicate Affix ( union List , is Suffix ) ; return union List ; }
private static X509 Certificate resolve Certificate ( Element e , String base URI , Storage Resolver storage ) throws Key Resolver Exception { if ( log . is Loggable ( java . util . logging . Level . FINE ) ) { log . log ( java . util . logging . Level . FINE , STRING + e . get Namespace URI ( ) + STRING + e . get Local Name ( ) + STRING ) ; } if ( e != null ) { return Key Resolver . get X 509 Certificate ( e , base URI , storage ) ; } return null ; }
public String add Steps For Restore From Fullcopy ( Workflow workflow , String wait For , URI storage , List < URI > fullcopies , String op Id , Clone Restore Completer completer ) throws Internal Exception { Volume first Full Copy = get Data Object ( Volume . class , fullcopies . get ( NUM ) , db Client ) ; if ( ! first Full Copy . is V Plex Volume ( db Client ) ) { return wait For ; } Block Object first Source = Block Object . fetch ( db Client , first Full Copy . get Associated Source Volume ( ) ) ; if ( ! Null Column Value Getter . is Null URI ( first Source . get Consistency Group ( ) ) ) { completer . add Consistency Group Id ( first Source . get Consistency Group ( ) ) ; } Storage System vplex System = db Client . query Object ( Storage System . class , storage ) ; Workflow . Method restore From Fullcopy Method = new Workflow . Method ( RESTORE FROM FULLCOPY METHOD NAME , storage , fullcopies ) ; wait For = workflow . create Step ( RESTORE FROM FULLCOPY STEP , STRING , wait For , storage , vplex System . get System Type ( ) , V Plex Device Controller . class , restore From Fullcopy Method , null , null ) ; log . info ( STRING ) ; return wait For ; }
public void search ( ) { int to pop = config . pop limit ; if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( STRING , to pop , candidates . size ( ) ) ; for ( Candidate c : candidates ) LOG . debug ( STRING , c ) ; } while ( to pop > NUM && ! candidates . is Empty ( ) ) { Candidate got = candidates . poll ( ) ; if ( got != null ) { add Hypothesis ( got ) ; -- to pop ; for ( Candidate c : got . extend ( ) ) if ( c != null ) { add Candidate ( c ) ; } } } }
public boolean is Cell Editable ( int row , int col ) { return BOOL ; }
public static long count ( Bson q , Class < ? extends Bean > t ) { String collection = Mongo Helper . get Collection ( t ) ; if ( ! X . is Empty ( collection ) ) { return count ( collection , q ) ; } return NUM ; }
public static long count ( Bson q , Class < ? extends Bean > t ) { String collection = Mongo Helper . get Collection ( t ) ; if ( ! X . is Empty ( collection ) ) { return count ( collection , q ) ; } return NUM ; }
private static void analyze Hadoop Configuration ( ) { Job Conf job = Configuration Manager . get Cached Job Conf ( ) ; remote MR Sort Mem = ( NUM * NUM ) * job . get Long ( MR Configuration Names . MR TASK IO SORT MB , NUM ) ; String java Opts 1 = job . get ( MR Configuration Names . MR CHILD JAVA OPTS ) ; String java Opts 2 = job . get ( MR Configuration Names . MR MAP JAVA OPTS , null ) ; String java Opts 3 = job . get ( MR Configuration Names . MR REDUCE JAVA OPTS , null ) ; if ( java Opts 2 != null ) remote JVM Max Mem Map = extract Max Memory Opt ( java Opts 2 ) ; else remote JVM Max Mem Map = extract Max Memory Opt ( java Opts 1 ) ; if ( java Opts 3 != null ) remote JVM Max Mem Reduce = extract Max Memory Opt ( java Opts 3 ) ; else remote JVM Max Mem Reduce = extract Max Memory Opt ( java Opts 1 ) ; String blocksize = job . get ( MR Configuration Names . DFS BLOCKSIZE , STRING ) ; blocksize = Long . parse Long ( blocksize ) ; String framework = job . get ( MR Configuration Names . MR FRAMEWORK NAME ) ; yarn Enabled = ( framework != null && framework . equals ( STRING ) ) ; local JT = analyze Local Mode ( job ) ; }
private static void analyze Hadoop Configuration ( ) { Job Conf job = Configuration Manager . get Cached Job Conf ( ) ; remote MR Sort Mem = ( NUM * NUM ) * job . get Long ( MR Configuration Names . MR TASK IO SORT MB , NUM ) ; String java Opts 1 = job . get ( MR Configuration Names . MR CHILD JAVA OPTS ) ; String java Opts 2 = job . get ( MR Configuration Names . MR MAP JAVA OPTS , null ) ; String java Opts 3 = job . get ( MR Configuration Names . MR REDUCE JAVA OPTS , null ) ; if ( java Opts 2 != null ) remote JVM Max Mem Map = extract Max Memory Opt ( java Opts 2 ) ; else remote JVM Max Mem Map = extract Max Memory Opt ( java Opts 1 ) ; if ( java Opts 3 != null ) remote JVM Max Mem Reduce = extract Max Memory Opt ( java Opts 3 ) ; else remote JVM Max Mem Reduce = extract Max Memory Opt ( java Opts 1 ) ; String blocksize = job . get ( MR Configuration Names . DFS BLOCKSIZE , STRING ) ; blocksize = Long . parse Long ( blocksize ) ; String framework = job . get ( MR Configuration Names . MR FRAMEWORK NAME ) ; yarn Enabled = ( framework != null && framework . equals ( STRING ) ) ; local JT = analyze Local Mode ( job ) ; }
@ Override public double [ ] [ ] process Ids ( DBI Ds ids , Relation < ? extends Number Vector > relation ) { final int dim = Relation Util . dimensionality ( relation ) ; final Covariance Matrix cmat = new Covariance Matrix ( dim ) ; final Centroid centroid = Centroid . make ( relation , ids ) ; double maxdist = NUM ; double stddev = NUM ; { for ( DBID Iter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { Number Vector obj = relation . get ( iter ) ; double distance = weight Distance . distance ( centroid , obj ) ; stddev += distance * distance ; if ( distance > maxdist ) { maxdist = distance ; } } if ( maxdist == NUM ) { maxdist = NUM ; } stddev = Math . sqrt ( stddev / ids . size ( ) ) ; } for ( DBID Iter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { Number Vector obj = relation . get ( iter ) ; double distance = weight Distance . distance ( centroid , obj ) ; double weight = weightfunction . get Weight ( distance , maxdist , stddev ) ; cmat . put ( obj , weight ) ; } return cmat . destroy To Naive Matrix ( ) ; }
@ Override public double [ ] [ ] process Ids ( DBI Ds ids , Relation < ? extends Number Vector > relation ) { final int dim = Relation Util . dimensionality ( relation ) ; final Covariance Matrix cmat = new Covariance Matrix ( dim ) ; final Centroid centroid = Centroid . make ( relation , ids ) ; double maxdist = NUM ; double stddev = NUM ; { for ( DBID Iter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { Number Vector obj = relation . get ( iter ) ; double distance = weight Distance . distance ( centroid , obj ) ; stddev += distance * distance ; if ( distance > maxdist ) { maxdist = distance ; } } if ( maxdist == NUM ) { maxdist = NUM ; } stddev = Math . sqrt ( stddev / ids . size ( ) ) ; } for ( DBID Iter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { Number Vector obj = relation . get ( iter ) ; double distance = weight Distance . distance ( centroid , obj ) ; double weight = weightfunction . get Weight ( distance , maxdist , stddev ) ; cmat . put ( obj , weight ) ; } return cmat . destroy To Naive Matrix ( ) ; }
@ Override public double [ ] [ ] process Ids ( DBI Ds ids , Relation < ? extends Number Vector > relation ) { final int dim = Relation Util . dimensionality ( relation ) ; final Covariance Matrix cmat = new Covariance Matrix ( dim ) ; final Centroid centroid = Centroid . make ( relation , ids ) ; double maxdist = NUM ; double stddev = NUM ; { for ( DBID Iter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { Number Vector obj = relation . get ( iter ) ; double distance = weight Distance . distance ( centroid , obj ) ; stddev += distance * distance ; if ( distance > maxdist ) { maxdist = distance ; } } if ( maxdist == NUM ) { maxdist = NUM ; } stddev = Math . sqrt ( stddev / ids . size ( ) ) ; } for ( DBID Iter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { Number Vector obj = relation . get ( iter ) ; double distance = weight Distance . distance ( centroid , obj ) ; double weight = weightfunction . get Weight ( distance , maxdist , stddev ) ; cmat . put ( obj , weight ) ; } return cmat . destroy To Naive Matrix ( ) ; }
private void output Full Lines ( ) throws IO Exception { for ( ; ; ) { int left Len = left Buf . index Of ( STRING ) ; if ( left Len < NUM ) { return ; } int right Len = right Buf . index Of ( STRING ) ; if ( right Len < NUM ) { return ; } if ( left Len != NUM ) { out . write ( left Buf . substring ( NUM , left Len ) ) ; } if ( right Len != NUM ) { write Spaces ( out , left Width - left Len ) ; out . write ( right Buf . substring ( NUM , right Len ) ) ; } out . write ( STRING ) ; left Buf . delete ( NUM , left Len + NUM ) ; right Buf . delete ( NUM , right Len + NUM ) ; } }
public static boolean register Canonicalizer ( final String c14 n Algorithm URI ) { final boolean added = canonicalizers . add ( c14 n Algorithm URI ) ; return added ; }
public int compare To ( Lib Padstack p other ) { if ( p other == null ) return NUM ; return pads name . compare To Ignore Case ( p other . pads name ) ; }
private void compute Rotation Time ( ) { key Rotation Interval In Msecs = max Life Values Holder . compute Rotation Time In M Secs ( ) ; log . info ( STRING , key Rotation Interval In Msecs ) ; }
public Host State Change ( Host target , URI old Cluster URI ) { this . host = target ; this . old Initiators = Sets . new Hash Set ( ) ; this . new Initiators = Sets . new Hash Set ( ) ; this . old Cluster = old Cluster URI ; }
private Response request Http Get From Registry ( String url ) throws Registry Exception { try { Response resp = http . get ( url ) ; if ( resp != null && resp . content != null ) { return resp ; } else { throw new Registry Exception ( TYPE . BAD RESPONSE , STRING ) ; } } catch ( Class Cast Exception e ) { throw new Registry Exception ( TYPE . BAD RESPONSE , e ) ; } catch ( Connect Exception e ) { throw new Registry Exception ( TYPE . PROXY , e ) ; } catch ( Unknown Host Exception e ) { try { http . get ( STRING ) ; } catch ( Exception e1 ) { throw new Registry Exception ( TYPE . NO INTERNET , e1 ) ; } throw new Registry Exception ( TYPE . SITE DOWN , e ) ; } catch ( IO Exception e ) { throw new Registry Exception ( TYPE . IO ERROR , e ) ; } catch ( URI Syntax Exception e ) { throw new Registry Exception ( TYPE . BAD REQUEST , STRING + ( ( url != null ) ? url : STRING ) ) ; } }
private Response request Http Get From Registry ( String url ) throws Registry Exception { try { Response resp = http . get ( url ) ; if ( resp != null && resp . content != null ) { return resp ; } else { throw new Registry Exception ( TYPE . BAD RESPONSE , STRING ) ; } } catch ( Class Cast Exception e ) { throw new Registry Exception ( TYPE . BAD RESPONSE , e ) ; } catch ( Connect Exception e ) { throw new Registry Exception ( TYPE . PROXY , e ) ; } catch ( Unknown Host Exception e ) { try { http . get ( STRING ) ; } catch ( Exception e1 ) { throw new Registry Exception ( TYPE . NO INTERNET , e1 ) ; } throw new Registry Exception ( TYPE . SITE DOWN , e ) ; } catch ( IO Exception e ) { throw new Registry Exception ( TYPE . IO ERROR , e ) ; } catch ( URI Syntax Exception e ) { throw new Registry Exception ( TYPE . BAD REQUEST , STRING + ( ( url != null ) ? url : STRING ) ) ; } }
private Response request Http Get From Registry ( String url ) throws Registry Exception { try { Response resp = http . get ( url ) ; if ( resp != null && resp . content != null ) { return resp ; } else { throw new Registry Exception ( TYPE . BAD RESPONSE , STRING ) ; } } catch ( Class Cast Exception e ) { throw new Registry Exception ( TYPE . BAD RESPONSE , e ) ; } catch ( Connect Exception e ) { throw new Registry Exception ( TYPE . PROXY , e ) ; } catch ( Unknown Host Exception e ) { try { http . get ( STRING ) ; } catch ( Exception e1 ) { throw new Registry Exception ( TYPE . NO INTERNET , e1 ) ; } throw new Registry Exception ( TYPE . SITE DOWN , e ) ; } catch ( IO Exception e ) { throw new Registry Exception ( TYPE . IO ERROR , e ) ; } catch ( URI Syntax Exception e ) { throw new Registry Exception ( TYPE . BAD REQUEST , STRING + ( ( url != null ) ? url : STRING ) ) ; } }
private Response request Http Get From Registry ( String url ) throws Registry Exception { try { Response resp = http . get ( url ) ; if ( resp != null && resp . content != null ) { return resp ; } else { throw new Registry Exception ( TYPE . BAD RESPONSE , STRING ) ; } } catch ( Class Cast Exception e ) { throw new Registry Exception ( TYPE . BAD RESPONSE , e ) ; } catch ( Connect Exception e ) { throw new Registry Exception ( TYPE . PROXY , e ) ; } catch ( Unknown Host Exception e ) { try { http . get ( STRING ) ; } catch ( Exception e1 ) { throw new Registry Exception ( TYPE . NO INTERNET , e1 ) ; } throw new Registry Exception ( TYPE . SITE DOWN , e ) ; } catch ( IO Exception e ) { throw new Registry Exception ( TYPE . IO ERROR , e ) ; } catch ( URI Syntax Exception e ) { throw new Registry Exception ( TYPE . BAD REQUEST , STRING + ( ( url != null ) ? url : STRING ) ) ; } }
public static void launch URL ( final URI uri , final String title , String tooltip , String browser Id , Launch Mode launch Mode ) { Check . not Null ( uri , STRING ) ; if ( ! URI Scheme Helper . is On Trusted Uri White List ( uri ) ) { URI Scheme Helper . show Unsafe Scheme Error ( uri ) ; return ; } if ( launch Mode == null ) { launch Mode = Launch Mode . USER PREFERENCE ; } if ( browser Id == null ) { browser Id = STRING ; } if ( tooltip == null ) { tooltip = STRING ; } final boolean workbench Browser Mode ; synchronized ( Browser Facade . class ) { workbench Browser Mode = use Workbench Browser Support ; } if ( workbench Browser Mode ) { try { launch With Workbench Browser Support ( uri , title , tooltip , browser Id , launch Mode ) ; return ; } catch ( final Exception e ) { log . warn ( STRING , e ) ; } } launch In Fallback Mode ( uri . to String ( ) , title , tooltip , browser Id , launch Mode ) ; }
public int num Children ( ) { return m Children . size ( ) ; }
private void remove Acked ( Array List < Record Info > acks ) { for ( Record Info info : acks ) { Ack Describe ack = ( Ack Describe ) Describe Journal . new Object Encoding ( info , null ) ; Hash Map < Long , Reference Describe > reference Describe Hash Map = message Refs . get ( info . id ) ; reference Describe Hash Map . remove ( ack . ref Encoding . queue ID ) ; if ( reference Describe Hash Map . size ( ) == NUM ) { messages . remove ( info . id ) ; message Refs . remove ( info . id ) ; } } }
private void remove Acked ( Array List < Record Info > acks ) { for ( Record Info info : acks ) { Ack Describe ack = ( Ack Describe ) Describe Journal . new Object Encoding ( info , null ) ; Hash Map < Long , Reference Describe > reference Describe Hash Map = message Refs . get ( info . id ) ; reference Describe Hash Map . remove ( ack . ref Encoding . queue ID ) ; if ( reference Describe Hash Map . size ( ) == NUM ) { messages . remove ( info . id ) ; message Refs . remove ( info . id ) ; } } }
public Chess Square ( Composite parent , Chess Board chess Board , int id , boolean is Light ) { super ( parent , SWT . DOUBLE BUFFERED | SWT . NO BACKGROUND ) ; board = chess Board ; this . id = id ; this . is Light = is Light ; add Paint Listener ( paint Listener ) ; add Control Listener ( control Listener ) ; add Mouse Listener ( mouse Listener ) ; add Listener ( SWT . Mouse Wheel , mouse Wheel Listener ) ; add Listener ( SWT . Mouse Down , dnd Listener ) ; add Listener ( SWT . Mouse Up , dnd Listener ) ; }
public static double [ ] from String ( String data , String separator ) { String [ ] split = data . split ( separator ) ; double [ ] ret = new double [ split . length ] ; for ( int i = NUM ; i < split . length ; i ++ ) { ret [ i ] = Double . parse Double ( split [ i ] ) ; } return ret ; }
private synchronized boolean should Garbage Collect Peer ( Peer peer ) { Date last Seen = peer . get Last Seen ( ) ; Date now = new Date ( ) ; long ms Since Seen = now . get Time ( ) - last Seen . get Time ( ) ; return ms Since Seen > PEER TIMEOUT ; }
private synchronized boolean should Garbage Collect Peer ( Peer peer ) { Date last Seen = peer . get Last Seen ( ) ; Date now = new Date ( ) ; long ms Since Seen = now . get Time ( ) - last Seen . get Time ( ) ; return ms Since Seen > PEER TIMEOUT ; }
public boolean is Accepted ( Question q ) { if ( exclude Questions != null && exclude Questions . contains ( STRING + q . get Question Id ( ) + STRING ) ) { return BOOL ; } if ( filter Dupes ) { if ( ! q . is Possible Duplicate ( ) ) { return BOOL ; } } if ( close Votes != null && close Votes . is Filter Active ( ) ) { if ( ! close Votes . in Range ( q . get Close Vote Count ( ) ) ) { return BOOL ; } } if ( scores != null && scores . is Filter Active ( ) ) { if ( ! scores . in Range ( q . get Score ( ) ) ) { return BOOL ; } } if ( answer Type != null ) { switch ( answer Type ) { case CLICK FROM ROOMBA : return q . is Almost Roomba ( ) ; case HAS ANSWER : return q . get Answer Count ( ) > NUM ; case HAS ACCEPTED ANSWER : return q . is Answer Accepted ( ) ; case HAS NO ACCEPTED ANSWER : return ! q . is Answer Accepted ( ) ; case HAS NO ANSWER : return q . get Answer Count ( ) <= NUM ; case NO ROOMBA : return ! q . is Roomba ( ) ; case NO FILTER : return BOOL ; } } return BOOL ; }
public static String Buffer left Shift ( String Buffer self , Object value ) { self . append ( value ) ; return self ; }
public static String Buffer left Shift ( String Buffer self , Object value ) { self . append ( value ) ; return self ; }
private static void nio Copy ( File Output Stream fos , File Input Stream fis ) throws IO Exception { File Channel out Channel = fos . get Channel ( ) ; File Channel in Channel = fis . get Channel ( ) ; long length = in Channel . size ( ) ; long offset = NUM ; while ( BOOL ) { long remaining = length - offset ; long to Transfer = remaining < MAX TRANSFER SIZE ? remaining : MAX TRANSFER SIZE ; long transferred Bytes = in Channel . transfer To ( offset , to Transfer , out Channel ) ; offset += transferred Bytes ; length = in Channel . size ( ) ; if ( offset >= length ) { break ; } } }
public void legacy Process ( Class clazz , Method m , Method Appearance Decision decision ) { if ( m . get Declaring Class ( ) != Object . class && m . get Return Type ( ) != void . class && m . get Parameter Types ( ) . length == NUM ) { String m Name = m . get Name ( ) ; if ( ! looks Like Property Read Method ( m Name ) ) { decision . set Expose Method As ( null ) ; try { decision . set Expose As Property ( new Property Descriptor ( m Name , clazz , m Name , null ) ) ; } catch ( Introspection Exception e ) { throw new Runtime Exception ( e ) ; } } } }
public void legacy Process ( Class clazz , Method m , Method Appearance Decision decision ) { if ( m . get Declaring Class ( ) != Object . class && m . get Return Type ( ) != void . class && m . get Parameter Types ( ) . length == NUM ) { String m Name = m . get Name ( ) ; if ( ! looks Like Property Read Method ( m Name ) ) { decision . set Expose Method As ( null ) ; try { decision . set Expose As Property ( new Property Descriptor ( m Name , clazz , m Name , null ) ) ; } catch ( Introspection Exception e ) { throw new Runtime Exception ( e ) ; } } } }
public void legacy Process ( Class clazz , Method m , Method Appearance Decision decision ) { if ( m . get Declaring Class ( ) != Object . class && m . get Return Type ( ) != void . class && m . get Parameter Types ( ) . length == NUM ) { String m Name = m . get Name ( ) ; if ( ! looks Like Property Read Method ( m Name ) ) { decision . set Expose Method As ( null ) ; try { decision . set Expose As Property ( new Property Descriptor ( m Name , clazz , m Name , null ) ) ; } catch ( Introspection Exception e ) { throw new Runtime Exception ( e ) ; } } } }
public void legacy Process ( Class clazz , Method m , Method Appearance Decision decision ) { if ( m . get Declaring Class ( ) != Object . class && m . get Return Type ( ) != void . class && m . get Parameter Types ( ) . length == NUM ) { String m Name = m . get Name ( ) ; if ( ! looks Like Property Read Method ( m Name ) ) { decision . set Expose Method As ( null ) ; try { decision . set Expose As Property ( new Property Descriptor ( m Name , clazz , m Name , null ) ) ; } catch ( Introspection Exception e ) { throw new Runtime Exception ( e ) ; } } } }
private void release All Locks ( ) { synchronized ( read notify ) { read notify . notify All ( ) ; } synchronized ( write notify ) { write notify . notify All ( ) ; } synchronized ( state notify ) { state notify . notify All ( ) ; } }
public Servlet Binding ( Http Servlet Request request , Http Servlet Response response , Servlet Context context ) { super . set Variable ( STRING , request ) ; super . set Variable ( STRING , response ) ; super . set Variable ( STRING , context ) ; super . set Variable ( STRING , context ) ; super . set Variable ( STRING , request . get Session ( BOOL ) ) ; Map params = collect Params ( request ) ; super . set Variable ( STRING , params ) ; Map < String , String > headers = new Linked Hash Map < String , String > ( ) ; for ( Enumeration names = request . get Header Names ( ) ; names . has More Elements ( ) ; ) { String header Name = ( String ) names . next Element ( ) ; String header Value = request . get Header ( header Name ) ; headers . put ( header Name , header Value ) ; } super . set Variable ( STRING , headers ) ; }
private void add Composed Chars ( ) throws Parse Exception { Composed Char Iter iter = new Composed Char Iter ( ) ; int c ; while ( ( c = iter . next ( ) ) != Composed Char Iter . DONE ) { if ( get Char Order ( c ) == RB Collation Tables . UNMAPPED ) { String s = iter . decomposition ( ) ; if ( s . length ( ) == NUM ) { int order = get Char Order ( s . char At ( NUM ) ) ; if ( order != RB Collation Tables . UNMAPPED ) { add Order ( c , order ) ; } continue ; } else if ( s . length ( ) == NUM ) { char ch 0 = s . char At ( NUM ) ; if ( Character . is High Surrogate ( ch 0 ) ) { int order = get Char Order ( s . code Point At ( NUM ) ) ; if ( order != RB Collation Tables . UNMAPPED ) { add Order ( c , order ) ; } continue ; } } int contract Order = get Contract Order ( s ) ; if ( contract Order != RB Collation Tables . UNMAPPED ) { add Order ( c , contract Order ) ; } else { boolean all There = BOOL ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { if ( get Char Order ( s . char At ( i ) ) == RB Collation Tables . UNMAPPED ) { all There = BOOL ; break ; } } if ( all There ) { add Expand Order ( c , s , RB Collation Tables . UNMAPPED ) ; } } } } }
private void add Composed Chars ( ) throws Parse Exception { Composed Char Iter iter = new Composed Char Iter ( ) ; int c ; while ( ( c = iter . next ( ) ) != Composed Char Iter . DONE ) { if ( get Char Order ( c ) == RB Collation Tables . UNMAPPED ) { String s = iter . decomposition ( ) ; if ( s . length ( ) == NUM ) { int order = get Char Order ( s . char At ( NUM ) ) ; if ( order != RB Collation Tables . UNMAPPED ) { add Order ( c , order ) ; } continue ; } else if ( s . length ( ) == NUM ) { char ch 0 = s . char At ( NUM ) ; if ( Character . is High Surrogate ( ch 0 ) ) { int order = get Char Order ( s . code Point At ( NUM ) ) ; if ( order != RB Collation Tables . UNMAPPED ) { add Order ( c , order ) ; } continue ; } } int contract Order = get Contract Order ( s ) ; if ( contract Order != RB Collation Tables . UNMAPPED ) { add Order ( c , contract Order ) ; } else { boolean all There = BOOL ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { if ( get Char Order ( s . char At ( i ) ) == RB Collation Tables . UNMAPPED ) { all There = BOOL ; break ; } } if ( all There ) { add Expand Order ( c , s , RB Collation Tables . UNMAPPED ) ; } } } } }
private void add Composed Chars ( ) throws Parse Exception { Composed Char Iter iter = new Composed Char Iter ( ) ; int c ; while ( ( c = iter . next ( ) ) != Composed Char Iter . DONE ) { if ( get Char Order ( c ) == RB Collation Tables . UNMAPPED ) { String s = iter . decomposition ( ) ; if ( s . length ( ) == NUM ) { int order = get Char Order ( s . char At ( NUM ) ) ; if ( order != RB Collation Tables . UNMAPPED ) { add Order ( c , order ) ; } continue ; } else if ( s . length ( ) == NUM ) { char ch 0 = s . char At ( NUM ) ; if ( Character . is High Surrogate ( ch 0 ) ) { int order = get Char Order ( s . code Point At ( NUM ) ) ; if ( order != RB Collation Tables . UNMAPPED ) { add Order ( c , order ) ; } continue ; } } int contract Order = get Contract Order ( s ) ; if ( contract Order != RB Collation Tables . UNMAPPED ) { add Order ( c , contract Order ) ; } else { boolean all There = BOOL ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { if ( get Char Order ( s . char At ( i ) ) == RB Collation Tables . UNMAPPED ) { all There = BOOL ; break ; } } if ( all There ) { add Expand Order ( c , s , RB Collation Tables . UNMAPPED ) ; } } } } }
public void cancel ( ) { synchronized ( this ) { if ( performing Printing ) { user Cancelled = BOOL ; } notify ( ) ; } }
public void cancel ( ) { synchronized ( this ) { if ( performing Printing ) { user Cancelled = BOOL ; } notify ( ) ; } }
@ Override public void flush ( ) throws IO Exception { flush Buffer ( ) ; output Stream . flush ( ) ; }
@ Override public void flush ( ) throws IO Exception { flush Buffer ( ) ; output Stream . flush ( ) ; }
@ Override public void flush ( ) throws IO Exception { flush Buffer ( ) ; output Stream . flush ( ) ; }
@ Override public void flush ( ) throws IO Exception { flush Buffer ( ) ; output Stream . flush ( ) ; }
@ Override public void flush ( ) throws IO Exception { flush Buffer ( ) ; output Stream . flush ( ) ; }
@ Override public void flush ( ) throws IO Exception { flush Buffer ( ) ; output Stream . flush ( ) ; }
@ Deprecated public static void publish Install Async ( final Context context , final String application Id ) { publish Install Async ( context , application Id , null ) ; }
@ Deprecated public static void publish Install Async ( final Context context , final String application Id ) { publish Install Async ( context , application Id , null ) ; }
@ Deprecated public static void publish Install Async ( final Context context , final String application Id ) { publish Install Async ( context , application Id , null ) ; }
public void test When Complete source Failed Action Failed ( ) { for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) for ( Execution Mode m : Execution Mode . values ( ) ) { final Atomic Integer a = new Atomic Integer ( NUM ) ; final CF Exception ex 1 = new CF Exception ( ) ; final CF Exception ex 2 = new CF Exception ( ) ; final Completable Future < Integer > f = new Completable Future < > ( ) ; if ( ! create Incomplete ) f . complete Exceptionally ( ex 1 ) ; final Completable Future < Integer > g = m . when Complete ( f , null ) ; if ( create Incomplete ) f . complete Exceptionally ( ex 1 ) ; check Completed With Wrapped Exception ( g , ex 1 ) ; check Completed Exceptionally ( f , ex 1 ) ; assert Equals ( NUM , a . get ( ) ) ; } }
public void test When Complete source Failed Action Failed ( ) { for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) for ( Execution Mode m : Execution Mode . values ( ) ) { final Atomic Integer a = new Atomic Integer ( NUM ) ; final CF Exception ex 1 = new CF Exception ( ) ; final CF Exception ex 2 = new CF Exception ( ) ; final Completable Future < Integer > f = new Completable Future < > ( ) ; if ( ! create Incomplete ) f . complete Exceptionally ( ex 1 ) ; final Completable Future < Integer > g = m . when Complete ( f , null ) ; if ( create Incomplete ) f . complete Exceptionally ( ex 1 ) ; check Completed With Wrapped Exception ( g , ex 1 ) ; check Completed Exceptionally ( f , ex 1 ) ; assert Equals ( NUM , a . get ( ) ) ; } }
public void test When Complete source Failed Action Failed ( ) { for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) for ( Execution Mode m : Execution Mode . values ( ) ) { final Atomic Integer a = new Atomic Integer ( NUM ) ; final CF Exception ex 1 = new CF Exception ( ) ; final CF Exception ex 2 = new CF Exception ( ) ; final Completable Future < Integer > f = new Completable Future < > ( ) ; if ( ! create Incomplete ) f . complete Exceptionally ( ex 1 ) ; final Completable Future < Integer > g = m . when Complete ( f , null ) ; if ( create Incomplete ) f . complete Exceptionally ( ex 1 ) ; check Completed With Wrapped Exception ( g , ex 1 ) ; check Completed Exceptionally ( f , ex 1 ) ; assert Equals ( NUM , a . get ( ) ) ; } }
public void test When Complete source Failed Action Failed ( ) { for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) for ( Execution Mode m : Execution Mode . values ( ) ) { final Atomic Integer a = new Atomic Integer ( NUM ) ; final CF Exception ex 1 = new CF Exception ( ) ; final CF Exception ex 2 = new CF Exception ( ) ; final Completable Future < Integer > f = new Completable Future < > ( ) ; if ( ! create Incomplete ) f . complete Exceptionally ( ex 1 ) ; final Completable Future < Integer > g = m . when Complete ( f , null ) ; if ( create Incomplete ) f . complete Exceptionally ( ex 1 ) ; check Completed With Wrapped Exception ( g , ex 1 ) ; check Completed Exceptionally ( f , ex 1 ) ; assert Equals ( NUM , a . get ( ) ) ; } }
public void test When Complete source Failed Action Failed ( ) { for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) for ( Execution Mode m : Execution Mode . values ( ) ) { final Atomic Integer a = new Atomic Integer ( NUM ) ; final CF Exception ex 1 = new CF Exception ( ) ; final CF Exception ex 2 = new CF Exception ( ) ; final Completable Future < Integer > f = new Completable Future < > ( ) ; if ( ! create Incomplete ) f . complete Exceptionally ( ex 1 ) ; final Completable Future < Integer > g = m . when Complete ( f , null ) ; if ( create Incomplete ) f . complete Exceptionally ( ex 1 ) ; check Completed With Wrapped Exception ( g , ex 1 ) ; check Completed Exceptionally ( f , ex 1 ) ; assert Equals ( NUM , a . get ( ) ) ; } }
public void test When Complete source Failed Action Failed ( ) { for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) for ( Execution Mode m : Execution Mode . values ( ) ) { final Atomic Integer a = new Atomic Integer ( NUM ) ; final CF Exception ex 1 = new CF Exception ( ) ; final CF Exception ex 2 = new CF Exception ( ) ; final Completable Future < Integer > f = new Completable Future < > ( ) ; if ( ! create Incomplete ) f . complete Exceptionally ( ex 1 ) ; final Completable Future < Integer > g = m . when Complete ( f , null ) ; if ( create Incomplete ) f . complete Exceptionally ( ex 1 ) ; check Completed With Wrapped Exception ( g , ex 1 ) ; check Completed Exceptionally ( f , ex 1 ) ; assert Equals ( NUM , a . get ( ) ) ; } }
public Differences compare ( final File control File , final File test File ) throws SAX Exception , IO Exception { Document control = parser . parse ( control File ) ; Document test = parser . parse ( test File ) ; Comparator comparator = new Comparator ( control , test , config ) ; return comparator . compare ( ) ; }
public Differences compare ( final File control File , final File test File ) throws SAX Exception , IO Exception { Document control = parser . parse ( control File ) ; Document test = parser . parse ( test File ) ; Comparator comparator = new Comparator ( control , test , config ) ; return comparator . compare ( ) ; }
public static void dump When Sys Out Contains ( String trigger ) { System . set Out ( wrap And Dump When Contains ( System . out , trigger ) ) ; }
@ Override public List < Period > generate Rolling Periods ( Date date ) { Period period = create Period ( date ) ; List < Period > periods = Lists . new Array List ( ) ; periods . add ( get Previous Period ( period ) ) ; periods . add ( period ) ; return periods ; }
@ Override public List < Period > generate Rolling Periods ( Date date ) { Period period = create Period ( date ) ; List < Period > periods = Lists . new Array List ( ) ; periods . add ( get Previous Period ( period ) ) ; periods . add ( period ) ; return periods ; }
@ Override public List < Period > generate Rolling Periods ( Date date ) { Period period = create Period ( date ) ; List < Period > periods = Lists . new Array List ( ) ; periods . add ( get Previous Period ( period ) ) ; periods . add ( period ) ; return periods ; }
private static boolean contains ( String group , String member ) { String quote = Pattern . quote ( member ) ; Pattern pattern = Pattern . compile ( STRING + quote + STRING + quote + STRING + quote + STRING + STRING + quote + STRING ) ; Matcher matcher = pattern . matcher ( group ) ; return matcher . find ( ) ; }
private static boolean contains ( String group , String member ) { String quote = Pattern . quote ( member ) ; Pattern pattern = Pattern . compile ( STRING + quote + STRING + quote + STRING + quote + STRING + STRING + quote + STRING ) ; Matcher matcher = pattern . matcher ( group ) ; return matcher . find ( ) ; }
public void test Multiple Creators ( ) throws Exception { Multi Bean bean = MAPPER . read Value ( STRING , Multi Bean . class ) ; assert Equals ( Integer . value Of ( NUM ) , bean . value ) ; bean = MAPPER . read Value ( quote ( STRING ) , Multi Bean . class ) ; assert Equals ( STRING , bean . value ) ; bean = MAPPER . read Value ( STRING , Multi Bean . class ) ; assert Equals ( Double . value Of ( NUM ) , bean . value ) ; }
public void test Multiple Creators ( ) throws Exception { Multi Bean bean = MAPPER . read Value ( STRING , Multi Bean . class ) ; assert Equals ( Integer . value Of ( NUM ) , bean . value ) ; bean = MAPPER . read Value ( quote ( STRING ) , Multi Bean . class ) ; assert Equals ( STRING , bean . value ) ; bean = MAPPER . read Value ( STRING , Multi Bean . class ) ; assert Equals ( Double . value Of ( NUM ) , bean . value ) ; }
private static < E > List < Type Adapter > build Known Adapters ( ) { List < Type Adapter > result = Lists . new Array List ( ) ; result . add ( new Type Adapter ( Collapse Data Wrapper . class , new Collapse Data Wrapper Adapter < E > ( ) ) ) ; result . add ( new Type Adapter ( Collapse Tree Root . class , new Collapse Tree Root Adapter < E > ( ) ) ) ; result . add ( new Type Adapter ( Hierarchy Root . class , new Hierarchy Root Adapter ( ) ) ) ; result . add ( new Type Adapter ( Node Wrapper . class , new Node Wrapper Adapter < E > ( ) ) ) ; result . add ( new Type Adapter ( Node Wrapper Root . class , new Node Wrapper Root Adapter < E > ( ) ) ) ; result . add ( new Type Adapter ( Solitary Root . class , new Solitary Root Adapter ( ) ) ) ; result . add ( new Type Adapter ( Viewer Root . class , new Viewer Root Adapter ( ) ) ) ; return result ; }
private static < E > List < Type Adapter > build Known Adapters ( ) { List < Type Adapter > result = Lists . new Array List ( ) ; result . add ( new Type Adapter ( Collapse Data Wrapper . class , new Collapse Data Wrapper Adapter < E > ( ) ) ) ; result . add ( new Type Adapter ( Collapse Tree Root . class , new Collapse Tree Root Adapter < E > ( ) ) ) ; result . add ( new Type Adapter ( Hierarchy Root . class , new Hierarchy Root Adapter ( ) ) ) ; result . add ( new Type Adapter ( Node Wrapper . class , new Node Wrapper Adapter < E > ( ) ) ) ; result . add ( new Type Adapter ( Node Wrapper Root . class , new Node Wrapper Root Adapter < E > ( ) ) ) ; result . add ( new Type Adapter ( Solitary Root . class , new Solitary Root Adapter ( ) ) ) ; result . add ( new Type Adapter ( Viewer Root . class , new Viewer Root Adapter ( ) ) ) ; return result ; }
private static < E > List < Type Adapter > build Known Adapters ( ) { List < Type Adapter > result = Lists . new Array List ( ) ; result . add ( new Type Adapter ( Collapse Data Wrapper . class , new Collapse Data Wrapper Adapter < E > ( ) ) ) ; result . add ( new Type Adapter ( Collapse Tree Root . class , new Collapse Tree Root Adapter < E > ( ) ) ) ; result . add ( new Type Adapter ( Hierarchy Root . class , new Hierarchy Root Adapter ( ) ) ) ; result . add ( new Type Adapter ( Node Wrapper . class , new Node Wrapper Adapter < E > ( ) ) ) ; result . add ( new Type Adapter ( Node Wrapper Root . class , new Node Wrapper Root Adapter < E > ( ) ) ) ; result . add ( new Type Adapter ( Solitary Root . class , new Solitary Root Adapter ( ) ) ) ; result . add ( new Type Adapter ( Viewer Root . class , new Viewer Root Adapter ( ) ) ) ; return result ; }
public void open For Write ( ) throws Event Exception { File f = new File ( Config Utils . get Initial Property Expanded ( m address . get Pathname ( ) ) ) ; try { if ( ! f . exists ( ) ) { f . create New File ( ) ; } else { LOGGER . info ( STRING + m address . get Pathname ( ) ) ; } } catch ( IO Exception ioe ) { throw new Event Exception ( STRING + m address . get Pathname ( ) + STRING + ioe ) ; } try { m fos = new File Output Stream ( f , BOOL ) ; } catch ( File Not Found Exception fnfe ) { throw new Event Exception ( STRING + m address . get Pathname ( ) + STRING + fnfe ) ; } }
public void open For Write ( ) throws Event Exception { File f = new File ( Config Utils . get Initial Property Expanded ( m address . get Pathname ( ) ) ) ; try { if ( ! f . exists ( ) ) { f . create New File ( ) ; } else { LOGGER . info ( STRING + m address . get Pathname ( ) ) ; } } catch ( IO Exception ioe ) { throw new Event Exception ( STRING + m address . get Pathname ( ) + STRING + ioe ) ; } try { m fos = new File Output Stream ( f , BOOL ) ; } catch ( File Not Found Exception fnfe ) { throw new Event Exception ( STRING + m address . get Pathname ( ) + STRING + fnfe ) ; } }
protected Object read Resolve ( ) throws java . io . Object Stream Exception { try { Certificate Factory cf = Certificate Factory . get Instance ( type ) ; return cf . generate Certificate ( new java . io . Byte Array Input Stream ( data ) ) ; } catch ( Certificate Exception e ) { throw new java . io . Not Serializable Exception ( STRING + type + STRING + e . get Message ( ) ) ; } }
public void add Hex Listener ( final I Hex Panel Listener listener ) { Preconditions . check Not Null ( listener , STRING ) ; if ( ! m listeners . contains ( listener ) ) { m listeners . add ( listener ) ; } }
public static List < String > split At Last Blank ( String s , int width ) { List < String > chunks = new Array List < > ( ) ; String tmp = s ; while ( tmp . length ( ) > NUM ) { int index = find Splitpoint ( tmp , width ) ; chunks . add ( tmp . substring ( NUM , index ) ) ; while ( index < tmp . length ( ) && tmp . char At ( index ) == STRING ) { index += NUM ; } if ( index < tmp . length ( ) && tmp . region Matches ( index , NEWLINE , NUM , NEWLINE . length ( ) ) ) { index += NEWLINE . length ( ) ; } if ( index >= tmp . length ( ) ) { break ; } tmp = tmp . substring ( index ) ; } return chunks ; }
public static List < String > split At Last Blank ( String s , int width ) { List < String > chunks = new Array List < > ( ) ; String tmp = s ; while ( tmp . length ( ) > NUM ) { int index = find Splitpoint ( tmp , width ) ; chunks . add ( tmp . substring ( NUM , index ) ) ; while ( index < tmp . length ( ) && tmp . char At ( index ) == STRING ) { index += NUM ; } if ( index < tmp . length ( ) && tmp . region Matches ( index , NEWLINE , NUM , NEWLINE . length ( ) ) ) { index += NEWLINE . length ( ) ; } if ( index >= tmp . length ( ) ) { break ; } tmp = tmp . substring ( index ) ; } return chunks ; }
public static List < String > split At Last Blank ( String s , int width ) { List < String > chunks = new Array List < > ( ) ; String tmp = s ; while ( tmp . length ( ) > NUM ) { int index = find Splitpoint ( tmp , width ) ; chunks . add ( tmp . substring ( NUM , index ) ) ; while ( index < tmp . length ( ) && tmp . char At ( index ) == STRING ) { index += NUM ; } if ( index < tmp . length ( ) && tmp . region Matches ( index , NEWLINE , NUM , NEWLINE . length ( ) ) ) { index += NEWLINE . length ( ) ; } if ( index >= tmp . length ( ) ) { break ; } tmp = tmp . substring ( index ) ; } return chunks ; }
synchronized public long transfer To ( final Random Access File out ) throws IO Exception { final long count = next Offset . get ( ) ; final File Channel out Channel = out . get Channel ( ) ; final long to Position = out Channel . position ( ) ; buffer . limit ( ( int ) count ) ; buffer . position ( NUM ) ; File Channel Utility . write All ( out Channel , buffer , to Position ) ; out Channel . position ( to Position + count ) ; return count ; }
synchronized public long transfer To ( final Random Access File out ) throws IO Exception { final long count = next Offset . get ( ) ; final File Channel out Channel = out . get Channel ( ) ; final long to Position = out Channel . position ( ) ; buffer . limit ( ( int ) count ) ; buffer . position ( NUM ) ; File Channel Utility . write All ( out Channel , buffer , to Position ) ; out Channel . position ( to Position + count ) ; return count ; }
public static double [ ] random Double Array ( int len , Random r ) { final double [ ] ret = new double [ len ] ; for ( int i = NUM ; i < len ; i ++ ) { ret [ i ] = r . next Double ( ) ; } return ret ; }
private void update Info Flow Summary Map ( Method Model method Model , Method method ) { Set < Info Kind > sources Info Kinds = method . get Sources Info Kinds ( ) ; Set < Info Kind > sink Info Kinds = method . get Sink Info Kinds ( ) ; if ( ! sources Info Kinds . is Empty ( ) && ! sink Info Kinds . is Empty ( ) ) { for ( Info Kind source Info Kind : sources Info Kinds ) { String source = source Info Kind . to String ( ) ; Map < String , Set < Method Model > > sink Map = info Flow Summary Map . get ( source ) ; if ( sink Map == null ) { sink Map = new Tree Map < String , Set < Method Model > > ( ) ; info Flow Summary Map . put ( source , sink Map ) ; } for ( Info Kind sink Info Kind : sink Info Kinds ) { String sink = sink Info Kind . to String ( ) ; Set < Method Model > method Models = sink Map . get ( sink ) ; if ( method Models == null ) { method Models = new Tree Set < Method Model > ( ) ; sink Map . put ( sink , method Models ) ; } method Models . add ( method Model ) ; } } } }
private void gsave ( ) { G State old G State = get G State ( ) ; mG State Stack . add ( new G State ( old G State ) ) ; mPS Stream . println ( GSAVE STR ) ; }
private void gsave ( ) { G State old G State = get G State ( ) ; mG State Stack . add ( new G State ( old G State ) ) ; mPS Stream . println ( GSAVE STR ) ; }
private void gsave ( ) { G State old G State = get G State ( ) ; mG State Stack . add ( new G State ( old G State ) ) ; mPS Stream . println ( GSAVE STR ) ; }
private void gsave ( ) { G State old G State = get G State ( ) ; mG State Stack . add ( new G State ( old G State ) ) ; mPS Stream . println ( GSAVE STR ) ; }
private void gsave ( ) { G State old G State = get G State ( ) ; mG State Stack . add ( new G State ( old G State ) ) ; mPS Stream . println ( GSAVE STR ) ; }
private void gsave ( ) { G State old G State = get G State ( ) ; mG State Stack . add ( new G State ( old G State ) ) ; mPS Stream . println ( GSAVE STR ) ; }
public void log ( String question , String intent , String confidence , String entity , String convo Output , String convo Id , String retrieve And Rank Output ) throws Exception { logger . info ( Messages . get String ( STRING ) ) ; Database db = client . database ( STRING , BOOL ) ; db . save ( new Document ( question , intent , confidence , entity , convo Output , convo Id , retrieve And Rank Output ) ) ; }
public void log ( String question , String intent , String confidence , String entity , String convo Output , String convo Id , String retrieve And Rank Output ) throws Exception { logger . info ( Messages . get String ( STRING ) ) ; Database db = client . database ( STRING , BOOL ) ; db . save ( new Document ( question , intent , confidence , entity , convo Output , convo Id , retrieve And Rank Output ) ) ; }
private static String build Log Message ( String method Name , long loading Time Duration ) { String Builder message = new String Builder ( ) ; message . append ( STRING ) ; message . append ( method Name ) ; message . append ( STRING ) ; message . append ( STRING ) ; message . append ( loading Time Duration ) ; message . append ( STRING ) ; message . append ( STRING ) ; return message . to String ( ) ; }
private static List < Fixed Record > create Fixed Records ( int count ) { List < Fixed Record > records = new Array List < > ( ) ; for ( int i = NUM ; i < count ; i ++ ) { records . add ( new Fixed Record ( i ) ) ; } return records ; }
public static long stop ( @ Non Null String key ) { long now = System . current Time Millis ( ) ; Map < String , Long > current Map = map . get ( ) ; Optional < Long > maybe Previous Instant = Optional . with ( current Map . get ( key ) ) ; if ( maybe Previous Instant . is Empty ( ) ) { Log . warn ( Timer . class , STRING , key ) ; return NUM ; } long duration = now - maybe Previous Instant . get ( ) ; current Map . remove ( key ) ; map . set ( current Map ) ; return duration ; }
public static DSA Public Key load DSA Public Key File ( String uname ) { String filename = Client Config . get User Keys Path ( ) + STRING + uname + STRING ; DSA Public Key pub Key = null ; File Input Stream fis = null ; try { fis = new File Input Stream ( filename ) ; byte [ ] key Bytes = new byte [ fis . available ( ) ] ; fis . read ( key Bytes ) ; Key Factory key Factory = Key Factory . get Instance ( STRING , STRING ) ; X509 Encoded Key Spec pub Key Spec = new X509 Encoded Key Spec ( key Bytes ) ; pub Key = ( DSA Public Key ) key Factory . generate Public ( pub Key Spec ) ; } catch ( IO Exception e ) { Logging . error ( e . get Message ( ) ) ; } catch ( No Such Algorithm Exception e ) { Logging . error ( e . get Message ( ) ) ; } catch ( No Such Provider Exception e ) { Logging . error ( e . get Message ( ) ) ; } catch ( Invalid Key Spec Exception e ) { Logging . error ( e . get Message ( ) ) ; } finally { Common Messaging . close ( fis ) ; } return pub Key ; }
public Push Processor Pipeline build ( List < Push Processor Supplier > processor suppliers ) throws Exception { Api Server api = null ; Push Metric Registry Instance registry = null ; final List < Push Processor > processors = new Array List < > ( processor suppliers . size ( ) ) ; try { final Endpoint Registration epr ; if ( epr == null ) epr = api = new Api Server ( api sockaddr ) ; else epr = epr ; registry = cfg . create ( null , epr ) ; for ( Push Processor Supplier pps : processor suppliers ) processors . add ( pps . build ( epr ) ) ; if ( history != null ) registry . set History ( history ) ; if ( api != null ) api . start ( ) ; return new Push Processor Pipeline ( registry , collect interval seconds , processors ) ; } catch ( Exception ex ) { try { if ( api != null ) api . close ( ) ; } catch ( Exception ex 1 ) { ex . add Suppressed ( ex 1 ) ; } try { if ( registry != null ) registry . close ( ) ; } catch ( Exception ex 1 ) { ex . add Suppressed ( ex 1 ) ; } for ( Push Processor pp : processors ) { try { pp . close ( ) ; } catch ( Exception ex 1 ) { ex . add Suppressed ( ex 1 ) ; } } throw ex ; } }
public static final void write Int Array Xml ( int [ ] val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . to String ( N ) ) ; for ( int i = NUM ; i < N ; i ++ ) { out . start Tag ( null , STRING ) ; out . attribute ( null , STRING , Integer . to String ( val [ i ] ) ) ; out . end Tag ( null , STRING ) ; } out . end Tag ( null , STRING ) ; }
public static final void write Int Array Xml ( int [ ] val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . to String ( N ) ) ; for ( int i = NUM ; i < N ; i ++ ) { out . start Tag ( null , STRING ) ; out . attribute ( null , STRING , Integer . to String ( val [ i ] ) ) ; out . end Tag ( null , STRING ) ; } out . end Tag ( null , STRING ) ; }
public static final void write Int Array Xml ( int [ ] val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . to String ( N ) ) ; for ( int i = NUM ; i < N ; i ++ ) { out . start Tag ( null , STRING ) ; out . attribute ( null , STRING , Integer . to String ( val [ i ] ) ) ; out . end Tag ( null , STRING ) ; } out . end Tag ( null , STRING ) ; }
public static final void write Int Array Xml ( int [ ] val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . to String ( N ) ) ; for ( int i = NUM ; i < N ; i ++ ) { out . start Tag ( null , STRING ) ; out . attribute ( null , STRING , Integer . to String ( val [ i ] ) ) ; out . end Tag ( null , STRING ) ; } out . end Tag ( null , STRING ) ; }
static void load ( ) { }
static void load ( ) { }
static void load ( ) { }
static void load ( ) { }
static void load ( ) { }
static void load ( ) { }
public void test Sequence Index Query ( ) throws Throwable { Server State Machine Context context = mock ( Server State Machine Context . class ) ; Server Session Context session = new Server Session Context ( NUM , UUID . random UUID ( ) , mock ( Log . class ) , context , NUM ) ; Atomic Boolean complete = new Atomic Boolean ( ) ; session . register Index Query ( NUM , null ) ; assert False ( complete . get ( ) ) ; session . set Last Applied ( NUM ) ; assert False ( complete . get ( ) ) ; session . set Last Applied ( NUM ) ; assert True ( complete . get ( ) ) ; }
public void test Sequence Index Query ( ) throws Throwable { Server State Machine Context context = mock ( Server State Machine Context . class ) ; Server Session Context session = new Server Session Context ( NUM , UUID . random UUID ( ) , mock ( Log . class ) , context , NUM ) ; Atomic Boolean complete = new Atomic Boolean ( ) ; session . register Index Query ( NUM , null ) ; assert False ( complete . get ( ) ) ; session . set Last Applied ( NUM ) ; assert False ( complete . get ( ) ) ; session . set Last Applied ( NUM ) ; assert True ( complete . get ( ) ) ; }
void paint ( Graphics g ) { if ( vert == null || nvert <= NUM ) { return ; } transform ( ) ; if ( gr == null ) { gr = new Color [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { int grey = ( int ) ( NUM * ( NUM - Math . pow ( i / NUM , NUM ) ) ) ; gr [ i ] = new Color ( grey , grey , grey ) ; } } int lg = NUM ; int lim = ncon ; int c [ ] = con ; int v [ ] = tvert ; if ( lim <= NUM || nvert <= NUM ) { return ; } for ( int i = NUM ; i < lim ; i ++ ) { int T = c [ i ] ; int p1 = ( ( T > > NUM ) & NUM ) * NUM ; int p2 = ( T & NUM ) * NUM ; int grey = v [ p1 + NUM ] + v [ p2 + NUM ] ; if ( grey < NUM ) { grey = NUM ; } if ( grey > NUM ) { grey = NUM ; } if ( grey != lg ) { lg = grey ; g . set Color ( gr [ grey ] ) ; } g . draw Line ( v [ p1 ] , v [ p1 + NUM ] , v [ p2 ] , v [ p2 + NUM ] ) ; } }
void paint ( Graphics g ) { if ( vert == null || nvert <= NUM ) { return ; } transform ( ) ; if ( gr == null ) { gr = new Color [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { int grey = ( int ) ( NUM * ( NUM - Math . pow ( i / NUM , NUM ) ) ) ; gr [ i ] = new Color ( grey , grey , grey ) ; } } int lg = NUM ; int lim = ncon ; int c [ ] = con ; int v [ ] = tvert ; if ( lim <= NUM || nvert <= NUM ) { return ; } for ( int i = NUM ; i < lim ; i ++ ) { int T = c [ i ] ; int p1 = ( ( T > > NUM ) & NUM ) * NUM ; int p2 = ( T & NUM ) * NUM ; int grey = v [ p1 + NUM ] + v [ p2 + NUM ] ; if ( grey < NUM ) { grey = NUM ; } if ( grey > NUM ) { grey = NUM ; } if ( grey != lg ) { lg = grey ; g . set Color ( gr [ grey ] ) ; } g . draw Line ( v [ p1 ] , v [ p1 + NUM ] , v [ p2 ] , v [ p2 + NUM ] ) ; } }
void paint ( Graphics g ) { if ( vert == null || nvert <= NUM ) { return ; } transform ( ) ; if ( gr == null ) { gr = new Color [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { int grey = ( int ) ( NUM * ( NUM - Math . pow ( i / NUM , NUM ) ) ) ; gr [ i ] = new Color ( grey , grey , grey ) ; } } int lg = NUM ; int lim = ncon ; int c [ ] = con ; int v [ ] = tvert ; if ( lim <= NUM || nvert <= NUM ) { return ; } for ( int i = NUM ; i < lim ; i ++ ) { int T = c [ i ] ; int p1 = ( ( T > > NUM ) & NUM ) * NUM ; int p2 = ( T & NUM ) * NUM ; int grey = v [ p1 + NUM ] + v [ p2 + NUM ] ; if ( grey < NUM ) { grey = NUM ; } if ( grey > NUM ) { grey = NUM ; } if ( grey != lg ) { lg = grey ; g . set Color ( gr [ grey ] ) ; } g . draw Line ( v [ p1 ] , v [ p1 + NUM ] , v [ p2 ] , v [ p2 + NUM ] ) ; } }
public void consume Documents ( String topic Name , int count , long timeout , Time Unit unit , Runnable completion , Bi Predicate < String , Document > consumer ) { Atomic Long read Counter = new Atomic Long ( ) ; consume Documents ( continue If Not Expired ( null , timeout , unit ) , completion , Collections . singleton ( topic Name ) , null ) ; }
public void consume Documents ( String topic Name , int count , long timeout , Time Unit unit , Runnable completion , Bi Predicate < String , Document > consumer ) { Atomic Long read Counter = new Atomic Long ( ) ; consume Documents ( continue If Not Expired ( null , timeout , unit ) , completion , Collections . singleton ( topic Name ) , null ) ; }
public Enumeration list Options ( ) { Vector new Vector = new Vector ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
public Enumeration list Options ( ) { Vector new Vector = new Vector ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
private Map read Current State ( String dn ) { try { return read ( Access Controller . do Privileged ( Admin Token Action . get Instance ( ) ) , dn ) ; } catch ( SMS Exception | SSO Exception e ) { return null ; } }
private Map read Current State ( String dn ) { try { return read ( Access Controller . do Privileged ( Admin Token Action . get Instance ( ) ) , dn ) ; } catch ( SMS Exception | SSO Exception e ) { return null ; } }
private Object timed Get ( long nanos ) throws Timeout Exception { if ( Thread . interrupted ( ) ) return null ; if ( nanos > NUM ) { long d = System . nano Time ( ) + nanos ; long deadline = ( d == NUM ) ? NUM : d ; Signaller q = null ; boolean queued = BOOL ; Object r ; while ( ( r = result ) == null ) { if ( q == null ) { q = new Signaller ( BOOL , nanos , deadline ) ; if ( Thread . current Thread ( ) instanceof Fork Join Worker Thread ) Fork Join Pool . help Async Blocker ( default Executor ( ) , q ) ; } else if ( ! queued ) queued = try Push Stack ( q ) ; else if ( q . nanos <= NUM ) break ; else { try { Fork Join Pool . managed Block ( q ) ; } catch ( Interrupted Exception ie ) { q . interrupted = BOOL ; } if ( q . interrupted ) break ; } } if ( q != null && queued ) { q . thread = null ; if ( r == null ) clean Stack ( ) ; } if ( r != null || ( r = result ) != null ) post Complete ( ) ; if ( r != null || ( q != null && q . interrupted ) ) return r ; } throw new Timeout Exception ( ) ; }
public void clear Local Slots ( int start , int len ) { start += current Frame Bottom ; System . arraycopy ( m nulls , NUM , stack Frames , start , len ) ; }
public void clear Local Slots ( int start , int len ) { start += current Frame Bottom ; System . arraycopy ( m nulls , NUM , stack Frames , start , len ) ; }
public void clear Local Slots ( int start , int len ) { start += current Frame Bottom ; System . arraycopy ( m nulls , NUM , stack Frames , start , len ) ; }
public void test Access And Modification Time Upwards Propagation ( ) throws Exception { create ( igfs Secondary , paths ( DIR , SUBDIR ) , paths ( FILE , FILE 2 ) ) ; T2 < Long , Long > times Dir 0 = check Parent Listing Time ( igfs Secondary File System , DIR ) ; T2 < Long , Long > times Sub Dir 0 = check Parent Listing Time ( igfs Secondary File System , SUBDIR ) ; T2 < Long , Long > times File 0 = check Parent Listing Time ( igfs Secondary File System , FILE ) ; T2 < Long , Long > times File 20 = check Parent Listing Time ( igfs Secondary File System , FILE 2 ) ; Thread . sleep ( NUM ) ; T2 < Long , Long > times Dir 1 = check Parent Listing Time ( igfs . as Secondary ( ) , DIR ) ; T2 < Long , Long > times Sub Dir 1 = check Parent Listing Time ( igfs . as Secondary ( ) , SUBDIR ) ; T2 < Long , Long > times File 1 = check Parent Listing Time ( igfs . as Secondary ( ) , FILE ) ; T2 < Long , Long > times File 21 = check Parent Listing Time ( igfs . as Secondary ( ) , FILE 2 ) ; assert Equals ( times Dir 0 , times Dir 1 ) ; assert Equals ( times Sub Dir 0 , times Sub Dir 1 ) ; assert Equals ( times File 0 , times File 1 ) ; assert Equals ( times File 20 , times File 21 ) ; }
protected int draw Label Text ( int text Decoration , boolean rtl , boolean is Ticker Running , boolean ends With 3 Points , Object native Font , int txt W , int text Space W , int shift Text , String text , int x , int y , int font Height ) { if ( ( ! is Ticker Running ) || rtl ) { if ( txt W > text Space W && text Space W > NUM ) { if ( rtl ) { if ( ( ! is Ticker Running ) && ends With 3 Points ) { String points = STRING ; int points W = impl . string Width ( native Font , points ) ; draw String ( native Font , points , shift Text + x , y , text Decoration , font Height ) ; clip Rect ( points W + shift Text + x , y , text Space W - points W , font Height ) ; } x = x - txt W + text Space W ; } else if ( ends With 3 Points ) { String points = STRING ; int index = NUM ; int widest = impl . char Width ( native Font , STRING ) ; int points W = impl . string Width ( native Font , points ) ; while ( fast Char Width Check ( text , index , text Space W - points W , widest , native Font ) && index < text . length ( ) ) { index ++ ; } text = text . substring ( NUM , Math . min ( text . length ( ) , Math . max ( NUM , index - NUM ) ) ) + points ; txt W = impl . string Width ( native Font , text ) ; } } } draw String ( native Font , text , shift Text + x , y , text Decoration , font Height ) ; return Math . min ( txt W , text Space W ) ; }
@ POST @ Path ( STRING ) @ Produces ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Consumes ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Check Permission ( roles = { Role . SECURITY ADMIN , Role . RESTRICTED SECURITY ADMIN } , block Proxies = BOOL ) public String rotate I Psec Key ( ) { ipsec Mgr . verify I Psec Op Allowable ( ) ; String version = ipsec Mgr . rotate Key ( ) ; audit Mgr . record Audit Log ( null , null , IPSEC SERVICE TYPE , Operation Type Enum . UPDATE SYSTEM PROPERTY , System . current Time Millis ( ) , Audit Log Manager . AUDITLOG SUCCESS , null , STRING + version ) ; return version ; }
@ POST @ Path ( STRING ) @ Produces ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Consumes ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Check Permission ( roles = { Role . SECURITY ADMIN , Role . RESTRICTED SECURITY ADMIN } , block Proxies = BOOL ) public String rotate I Psec Key ( ) { ipsec Mgr . verify I Psec Op Allowable ( ) ; String version = ipsec Mgr . rotate Key ( ) ; audit Mgr . record Audit Log ( null , null , IPSEC SERVICE TYPE , Operation Type Enum . UPDATE SYSTEM PROPERTY , System . current Time Millis ( ) , Audit Log Manager . AUDITLOG SUCCESS , null , STRING + version ) ; return version ; }
private void validate Reference ( Element referent Element ) throws XML Security Exception { if ( ! XML Utils . element Is In Signature Space ( referent Element , Constants . TAG KEYINFO ) ) { Object ex Args [ ] = { new Q Name ( referent Element . get Namespace URI ( ) , referent Element . get Local Name ( ) ) } ; throw new XML Security Exception ( STRING , ex Args ) ; } Key Info referent = new Key Info ( referent Element , STRING ) ; if ( referent . contains Key Info Reference ( ) ) { if ( secure Validation ) { throw new XML Security Exception ( STRING ) ; } else { throw new XML Security Exception ( STRING ) ; } } }
public Content Impl create Compound Package Content ( Ole Blob Impl blob , String pretty Name , String class Name , String type Name , Byte Buffer blob Bb , int data Block Len ) { return new Compound Content Impl ( blob , pretty Name , class Name , type Name , blob Bb . position ( ) , data Block Len ) ; }
public static boolean is Before Today ( Calendar calendar ) { return calendar . before ( Calendar . get Instance ( ) ) ; }
private void initialize Font Metrics ( Font font ) { final Buffered Image temporary Image = new Buffered Image ( NUM , NUM , Buffered Image . TYPE INT RGB ) ; Graphics 2 D temporary Graphics 2 D = ( Graphics 2 D ) temporary Image . get Graphics ( ) ; temporary Graphics 2 D . set Font ( font ) ; font Metrics = temporary Graphics 2 D . get Font Metrics ( ) ; font Char Width = font Metrics . get Max Advance ( ) ; font Line Height = font Metrics . get Height ( ) ; }
private boolean announce ( String [ ] groups ) { if ( data Packets == null || ! last Locator . equals ( my Locator ) || ! Arrays . equals ( last Groups , groups ) ) { List < Datagram Packet > packets = new Array List < Datagram Packet > ( ) ; Discovery disco ; try { disco = get Discovery ( multicast Announcement Constraints . choose Protocol Version ( ) ) ; } catch ( Discovery Protocol Exception e ) { throw new Assertion Error ( e ) ; } Encode Iterator ei = disco . encode Multicast Announcement ( new Multicast Announcement ( announcement Seq No ++ , my Locator . get Host ( ) , my Locator . get Port ( ) , groups , my Service ID ) , multicast Announcement Constraints . get Multicast Max Packet Size ( DEFAULT MAX PACKET SIZE ) , multicast Announcement Constraints . get Unfulfilled Constraints ( ) ) ; while ( ei . has Next ( ) ) { try { packets . add All ( Arrays . as List ( ei . next ( ) ) ) ; } catch ( Exception e ) { logger . log ( ( e instanceof Unsupported Constraint Exception ) ? Levels . HANDLED : Level . INFO , STRING + STRING , e ) ; } } last Locator = my Locator ; last Groups = groups ; data Packets = packets . to Array ( new Datagram Packet [ packets . size ( ) ] ) ; } try { send ( data Packets ) ; } catch ( Interrupted IO Exception e ) { return BOOL ; } return BOOL ; }
private static synchronized String parse Quoted String ( String s ) throws Unsupported Encoding Exception , Character Coding Exception { String Buffer result = new String Buffer ( ) ; String Character Iterator iterator = new String Character Iterator ( s ) ; char c = iterator . current ( ) ; while ( iterator . get Index ( ) < iterator . get End Index ( ) ) { switch ( c ) { case STRING : { result . append ( parse Escaped Sequence ( iterator ) ) ; break ; } default : { result . append ( c ) ; break ; } } c = iterator . next ( ) ; } return result . to String ( ) ; }
private static synchronized String parse Quoted String ( String s ) throws Unsupported Encoding Exception , Character Coding Exception { String Buffer result = new String Buffer ( ) ; String Character Iterator iterator = new String Character Iterator ( s ) ; char c = iterator . current ( ) ; while ( iterator . get Index ( ) < iterator . get End Index ( ) ) { switch ( c ) { case STRING : { result . append ( parse Escaped Sequence ( iterator ) ) ; break ; } default : { result . append ( c ) ; break ; } } c = iterator . next ( ) ; } return result . to String ( ) ; }
private static synchronized String parse Quoted String ( String s ) throws Unsupported Encoding Exception , Character Coding Exception { String Buffer result = new String Buffer ( ) ; String Character Iterator iterator = new String Character Iterator ( s ) ; char c = iterator . current ( ) ; while ( iterator . get Index ( ) < iterator . get End Index ( ) ) { switch ( c ) { case STRING : { result . append ( parse Escaped Sequence ( iterator ) ) ; break ; } default : { result . append ( c ) ; break ; } } c = iterator . next ( ) ; } return result . to String ( ) ; }
static boolean is Possible FP ( String val ) { final int length = val . length ( ) ; for ( int i = NUM ; i < length ; ++ i ) { char c = val . char At ( i ) ; if ( ! ( c >= STRING && c <= STRING || c == STRING || c == STRING || c == STRING || c == STRING || c == STRING ) ) { return BOOL ; } } return BOOL ; }
@ Override public Point 2 D . Double translate Point ( Point 2 D . Double p , Translation Direction dir ) { Point 2 D . Double p0 = constrain Point ( ( Point 2 D . Double ) p . clone ( ) ) ; switch ( dir ) { case NORTH : case NORTH WEST : case NORTH EAST : p . y = p0 . y - height ; break ; case SOUTH : case SOUTH WEST : case SOUTH EAST : p . y = p0 . y + height ; break ; } switch ( dir ) { case WEST : case NORTH WEST : case SOUTH WEST : p . x = p0 . x - width ; break ; case EAST : case NORTH EAST : case SOUTH EAST : p . x = p0 . x + width ; break ; } return p ; }
@ Override public Point 2 D . Double translate Point ( Point 2 D . Double p , Translation Direction dir ) { Point 2 D . Double p0 = constrain Point ( ( Point 2 D . Double ) p . clone ( ) ) ; switch ( dir ) { case NORTH : case NORTH WEST : case NORTH EAST : p . y = p0 . y - height ; break ; case SOUTH : case SOUTH WEST : case SOUTH EAST : p . y = p0 . y + height ; break ; } switch ( dir ) { case WEST : case NORTH WEST : case SOUTH WEST : p . x = p0 . x - width ; break ; case EAST : case NORTH EAST : case SOUTH EAST : p . x = p0 . x + width ; break ; } return p ; }
@ Override public Point 2 D . Double translate Point ( Point 2 D . Double p , Translation Direction dir ) { Point 2 D . Double p0 = constrain Point ( ( Point 2 D . Double ) p . clone ( ) ) ; switch ( dir ) { case NORTH : case NORTH WEST : case NORTH EAST : p . y = p0 . y - height ; break ; case SOUTH : case SOUTH WEST : case SOUTH EAST : p . y = p0 . y + height ; break ; } switch ( dir ) { case WEST : case NORTH WEST : case SOUTH WEST : p . x = p0 . x - width ; break ; case EAST : case NORTH EAST : case SOUTH EAST : p . x = p0 . x + width ; break ; } return p ; }
private static Create Vm Response check Create Vm Response ( Create Vm Response create Vm Response ) throws Rpc Exception { logger . info ( STRING , create Vm Response ) ; switch ( create Vm Response . get Result ( ) ) { case OK : break ; case DISK NOT FOUND : throw new Disk Not Found Exception ( create Vm Response . get Error ( ) ) ; case IMAGE NOT FOUND : throw new Image Not Found Exception ( create Vm Response . get Error ( ) ) ; case INVALID RESERVATION : throw new Invalid Reservation Exception ( create Vm Response . get Error ( ) ) ; case NETWORK NOT FOUND : throw new Network Not Found Exception ( create Vm Response . get Error ( ) ) ; case SYSTEM ERROR : throw new System Error Exception ( create Vm Response . get Error ( ) ) ; default : throw new Rpc Exception ( String . format ( STRING , create Vm Response . get Result ( ) ) ) ; } return create Vm Response ; }
private void record Log Data ( ) { try { int size = m Recording Data . size ( ) ; if ( size == NUM ) { return ; } Vector < String > recording Data = new Vector < > ( m Recording Data ) ; File log Dir = Constants . get Record Dir ( this ) ; log Dir . mkdirs ( ) ; File log File = new File ( log Dir , m Recording Filename ) ; File Writer log File Writer = new File Writer ( log File , BOOL ) ; for ( int i = NUM ; i < size ; i ++ ) { log File Writer . append ( recording Data . element At ( i ) + STRING ) ; m Recording Data . remove Element At ( NUM ) ; } recording Data . remove All Elements ( ) ; log File Writer . close ( ) ; } catch ( Exception e ) { Log . e ( LOG TAG , STRING + e . to String ( ) ) ; } }
@ Override public void create Connection Factory ( String name , boolean ha , boolean use Discovery , int cf Type , String connectors , String bindings ) throws Exception { create Connection Factory ( name , ha , use Discovery , cf Type , to Array ( connectors ) , to Array ( bindings ) ) ; }
public boolean is Directly Control Dependent On ( Basic Block ins Block , Branch b ) { Set < Control Flow Edge > incomming = incoming Edges Of ( ins Block ) ; if ( incomming . size ( ) == NUM ) { for ( Control Flow Edge e : incomming ) { if ( ! e . has Control Dependency ( ) && ! e . is Exception Edge ( ) ) { return is Directly Control Dependent On ( get Edge Source ( e ) , b ) ; } } } boolean is Root Dependent = is Root Dependent ( ins Block ) ; if ( b == null ) return is Root Dependent ; if ( is Root Dependent && b != null ) return BOOL ; for ( Control Flow Edge e : incomming ) { Branch current = e . get Branch Instruction ( ) ; if ( e . is Exception Edge ( ) ) { if ( current != null ) throw new Illegal State Exception ( STRING ) ; else continue ; } if ( current == null ) continue ; if ( current . equals ( b ) ) return BOOL ; } return BOOL ; }
public boolean is Directly Control Dependent On ( Basic Block ins Block , Branch b ) { Set < Control Flow Edge > incomming = incoming Edges Of ( ins Block ) ; if ( incomming . size ( ) == NUM ) { for ( Control Flow Edge e : incomming ) { if ( ! e . has Control Dependency ( ) && ! e . is Exception Edge ( ) ) { return is Directly Control Dependent On ( get Edge Source ( e ) , b ) ; } } } boolean is Root Dependent = is Root Dependent ( ins Block ) ; if ( b == null ) return is Root Dependent ; if ( is Root Dependent && b != null ) return BOOL ; for ( Control Flow Edge e : incomming ) { Branch current = e . get Branch Instruction ( ) ; if ( e . is Exception Edge ( ) ) { if ( current != null ) throw new Illegal State Exception ( STRING ) ; else continue ; } if ( current == null ) continue ; if ( current . equals ( b ) ) return BOOL ; } return BOOL ; }
public boolean is Directly Control Dependent On ( Basic Block ins Block , Branch b ) { Set < Control Flow Edge > incomming = incoming Edges Of ( ins Block ) ; if ( incomming . size ( ) == NUM ) { for ( Control Flow Edge e : incomming ) { if ( ! e . has Control Dependency ( ) && ! e . is Exception Edge ( ) ) { return is Directly Control Dependent On ( get Edge Source ( e ) , b ) ; } } } boolean is Root Dependent = is Root Dependent ( ins Block ) ; if ( b == null ) return is Root Dependent ; if ( is Root Dependent && b != null ) return BOOL ; for ( Control Flow Edge e : incomming ) { Branch current = e . get Branch Instruction ( ) ; if ( e . is Exception Edge ( ) ) { if ( current != null ) throw new Illegal State Exception ( STRING ) ; else continue ; } if ( current == null ) continue ; if ( current . equals ( b ) ) return BOOL ; } return BOOL ; }
public boolean is Directly Control Dependent On ( Basic Block ins Block , Branch b ) { Set < Control Flow Edge > incomming = incoming Edges Of ( ins Block ) ; if ( incomming . size ( ) == NUM ) { for ( Control Flow Edge e : incomming ) { if ( ! e . has Control Dependency ( ) && ! e . is Exception Edge ( ) ) { return is Directly Control Dependent On ( get Edge Source ( e ) , b ) ; } } } boolean is Root Dependent = is Root Dependent ( ins Block ) ; if ( b == null ) return is Root Dependent ; if ( is Root Dependent && b != null ) return BOOL ; for ( Control Flow Edge e : incomming ) { Branch current = e . get Branch Instruction ( ) ; if ( e . is Exception Edge ( ) ) { if ( current != null ) throw new Illegal State Exception ( STRING ) ; else continue ; } if ( current == null ) continue ; if ( current . equals ( b ) ) return BOOL ; } return BOOL ; }
public void rename Attribute ( Attribute att , String name ) { rename Attribute ( att . index ( ) , name ) ; }
public void rename Attribute ( Attribute att , String name ) { rename Attribute ( att . index ( ) , name ) ; }
private void split Bulk Request ( Snmp Pdu Bulk req , int non Repeaters , int max Repetitions , int R ) { for ( Enumeration < Snmp Mib Agent > e = mibs . elements ( ) ; e . has More Elements ( ) ; ) { final Snmp Mib Agent agent = e . next Element ( ) ; if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINER ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINER , dbg Tag , STRING , STRING + agent + STRING + non Repeaters + STRING + max Repetitions + STRING + R ) ; } subs . put ( agent , new Snmp Sub Bulk Request Handler ( adaptor , agent , req , non Repeaters , max Repetitions , R ) ) ; } }
private void split Bulk Request ( Snmp Pdu Bulk req , int non Repeaters , int max Repetitions , int R ) { for ( Enumeration < Snmp Mib Agent > e = mibs . elements ( ) ; e . has More Elements ( ) ; ) { final Snmp Mib Agent agent = e . next Element ( ) ; if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINER ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINER , dbg Tag , STRING , STRING + agent + STRING + non Repeaters + STRING + max Repetitions + STRING + R ) ; } subs . put ( agent , new Snmp Sub Bulk Request Handler ( adaptor , agent , req , non Repeaters , max Repetitions , R ) ) ; } }
private void split Bulk Request ( Snmp Pdu Bulk req , int non Repeaters , int max Repetitions , int R ) { for ( Enumeration < Snmp Mib Agent > e = mibs . elements ( ) ; e . has More Elements ( ) ; ) { final Snmp Mib Agent agent = e . next Element ( ) ; if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINER ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINER , dbg Tag , STRING , STRING + agent + STRING + non Repeaters + STRING + max Repetitions + STRING + R ) ; } subs . put ( agent , new Snmp Sub Bulk Request Handler ( adaptor , agent , req , non Repeaters , max Repetitions , R ) ) ; } }
private void on Cache Data Changed ( ) { if ( m Cache Data List . size ( ) >= NUM ) { m Icon Status = ICON SHOW DROP DOWN ; } else { m Icon Status = ICON ABSENT ; } }
public boolean is Query Running ( final Bound Entity song ) { synchronized ( m Running Queries ) { return m Running Queries . contains ( song ) ; } }
private void fire Process View Changed ( ) { for ( Extended Process Editor editor : process Editors . get Listeners ( Extended Process Editor . class ) ) { editor . process View Changed ( process ) ; } }
private void fire Process View Changed ( ) { for ( Extended Process Editor editor : process Editors . get Listeners ( Extended Process Editor . class ) ) { editor . process View Changed ( process ) ; } }
public boolean is Custom View Showing ( ) { return m Custom View != null ; }
public boolean is Custom View Showing ( ) { return m Custom View != null ; }
public boolean is Custom View Showing ( ) { return m Custom View != null ; }
private static Map < String , Boolean > read Properties ( Properties props , String key Prefix ) { Map < String , Boolean > filters = new Tree Map < String , Boolean > ( ) ; int counter = NUM ; boolean key Found = BOOL ; while ( key Found ) { String property = props . get Property ( key Prefix + counter ) ; if ( property != null ) { int pipe Pos = property . index Of ( BOOL SEPARATOR ) ; if ( pipe Pos >= NUM ) { String name = property . substring ( NUM , pipe Pos ) ; String enabled = property . substring ( pipe Pos + NUM ) ; filters . put ( name , Boolean . value Of ( enabled ) ) ; } else { filters . put ( property , Boolean . TRUE ) ; } counter ++ ; } else { key Found = BOOL ; } } return filters ; }
public void test Write Read Empty ( ) throws Exception { Byte Array Output Stream out = new Byte Array Output Stream ( NUM ) ; Object Output Stream os = new Object Output Stream ( out ) ; os . write Object ( empty ) ; Object Input Stream is = new Object Input Stream ( new Byte Array Input Stream ( out . to Byte Array ( ) ) ) ; Replication Policy copy = ( Replication Policy ) is . read Object ( ) ; is . close ( ) ; os . close ( ) ; assert True ( helper . are Equals ( empty , copy ) ) ; }
public static final void front End Statistics ( Spec Obj spec ) { }
private static void format ( String Buffer target , int scale , long int P , long dec P ) { if ( dec P != NUM ) { dec P += NUM ; dec P /= NUM ; if ( dec P >= ten Pow Double ( scale ) ) { int P ++ ; dec P -= ten Pow ( scale ) ; } if ( dec P != NUM ) { while ( dec P % NUM == NUM ) { dec P = dec P / NUM ; scale -- ; } } } target . append ( int P ) ; if ( dec P != NUM ) { target . append ( STRING ) ; while ( scale > NUM && ( scale > NUM ? dec P < ten Pow Double ( -- scale ) : dec P < ten Pow ( -- scale ) ) ) { target . append ( STRING ) ; } target . append ( dec P ) ; } }
private static void format ( String Buffer target , int scale , long int P , long dec P ) { if ( dec P != NUM ) { dec P += NUM ; dec P /= NUM ; if ( dec P >= ten Pow Double ( scale ) ) { int P ++ ; dec P -= ten Pow ( scale ) ; } if ( dec P != NUM ) { while ( dec P % NUM == NUM ) { dec P = dec P / NUM ; scale -- ; } } } target . append ( int P ) ; if ( dec P != NUM ) { target . append ( STRING ) ; while ( scale > NUM && ( scale > NUM ? dec P < ten Pow Double ( -- scale ) : dec P < ten Pow ( -- scale ) ) ) { target . append ( STRING ) ; } target . append ( dec P ) ; } }
private void high Light Marker ( int index ) { high Light Marker ( markers . get ( index ) ) ; }
@ Override public void on Value Selected ( int picker Index , int new Value , boolean auto Advance ) { if ( picker Index == HOUR INDEX ) { set Hour ( new Value , BOOL ) ; String announcement = String . format ( STRING , new Value ) ; if ( m Allow Auto Advance && auto Advance ) { set Current Item Showing ( MINUTE INDEX , BOOL , BOOL , BOOL ) ; announcement += STRING + m Select Minutes ; } else { m Time Picker . set Content Description ( m Hour Picker Description + STRING + new Value ) ; } Utils . try Accessibility Announce ( m Time Picker , announcement ) ; } else if ( picker Index == MINUTE INDEX ) { set Minute ( new Value ) ; m Time Picker . set Content Description ( m Minute Picker Description + STRING + new Value ) ; } else if ( picker Index == AMPM INDEX ) { update Am Pm Display ( new Value ) ; } else if ( picker Index == ENABLE PICKER INDEX ) { if ( ! is Typed Time Fully Legal ( ) ) { m Typed Times . clear ( ) ; } finish Kb Mode ( BOOL ) ; } }
@ HLE Function ( nid = NUM , version = NUM ) public int sce Net Resolver Start Ato N ( @ Check Argument ( STRING ) int rid , int addr , T Pointer hostname Addr , int hostname Length , int timeout , int retry ) { try { byte [ ] bytes = sce Net Inet . internet Address To Bytes ( addr ) ; Inet Address inet Address = Inet Address . get By Address ( bytes ) ; String host Name = inet Address . get Host Name ( ) ; hostname Addr . set String NZ ( hostname Length , host Name ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( String . format ( STRING , host Name ) ) ; } } catch ( Unknown Host Exception e ) { log . error ( e ) ; return Sce Kernel Errors . ERROR NET RESOLVER INVALID HOST ; } return NUM ; }
public static < T > Future W < T > of Supplier ( final Supplier < T > s , final Executor ex ) { return Future W . of ( Completable Future . supply Async ( s , ex ) ) ; }
public static < T > Future W < T > of Supplier ( final Supplier < T > s , final Executor ex ) { return Future W . of ( Completable Future . supply Async ( s , ex ) ) ; }
public static < T > Future W < T > of Supplier ( final Supplier < T > s , final Executor ex ) { return Future W . of ( Completable Future . supply Async ( s , ex ) ) ; }
@ Override public void write ( char c [ ] , int off , int len ) { if ( ( off < NUM ) || ( off > c . length ) || ( len < NUM ) || ( ( off + len ) > c . length ) || ( ( off + len ) < NUM ) ) { throw new Index Out Of Bounds Exception ( ) ; } else if ( len == NUM ) { return ; } int newcount = count + len ; if ( newcount > buf . length ) { buf = Arrays . copy Of ( buf , Math . max ( buf . length << NUM , newcount ) ) ; } System . arraycopy ( c , off , buf , count , len ) ; count = newcount ; }
private Linked Hash Map < Term , Integer > repeating Terms ( ) { Linked Hash Map < Term , Integer > tord = new Linked Hash Map < > ( ) ; Hash Map < Term , Integer > tcnt = new Hash Map < > ( ) ; for ( Phrase Positions pp : phrase Positions ) { for ( Term t : pp . terms ) { Integer cnt 0 = tcnt . get ( t ) ; Integer cnt = cnt 0 == null ? new Integer ( NUM ) : new Integer ( NUM + cnt 0 . int Value ( ) ) ; tcnt . put ( t , cnt ) ; if ( cnt == NUM ) { tord . put ( t , tord . size ( ) ) ; } } } return tord ; }
private Linked Hash Map < Term , Integer > repeating Terms ( ) { Linked Hash Map < Term , Integer > tord = new Linked Hash Map < > ( ) ; Hash Map < Term , Integer > tcnt = new Hash Map < > ( ) ; for ( Phrase Positions pp : phrase Positions ) { for ( Term t : pp . terms ) { Integer cnt 0 = tcnt . get ( t ) ; Integer cnt = cnt 0 == null ? new Integer ( NUM ) : new Integer ( NUM + cnt 0 . int Value ( ) ) ; tcnt . put ( t , cnt ) ; if ( cnt == NUM ) { tord . put ( t , tord . size ( ) ) ; } } } return tord ; }
public static synchronized void move Logs From Legacy Dir If Necessary ( ) { File sdcard Dir = Environment . get External Storage Directory ( ) ; File legacy Dir = new File ( sdcard Dir , LEGACY SAVED LOGS DIR ) ; if ( legacy Dir . exists ( ) && legacy Dir . is Directory ( ) ) { File saved Logs Dir = get Saved Logs Directory ( ) ; for ( File file : legacy Dir . list Files ( ) ) { file . rename To ( new File ( saved Logs Dir , file . get Name ( ) ) ) ; } legacy Dir . delete ( ) ; } }
public static synchronized void move Logs From Legacy Dir If Necessary ( ) { File sdcard Dir = Environment . get External Storage Directory ( ) ; File legacy Dir = new File ( sdcard Dir , LEGACY SAVED LOGS DIR ) ; if ( legacy Dir . exists ( ) && legacy Dir . is Directory ( ) ) { File saved Logs Dir = get Saved Logs Directory ( ) ; for ( File file : legacy Dir . list Files ( ) ) { file . rename To ( new File ( saved Logs Dir , file . get Name ( ) ) ) ; } legacy Dir . delete ( ) ; } }
public static synchronized void move Logs From Legacy Dir If Necessary ( ) { File sdcard Dir = Environment . get External Storage Directory ( ) ; File legacy Dir = new File ( sdcard Dir , LEGACY SAVED LOGS DIR ) ; if ( legacy Dir . exists ( ) && legacy Dir . is Directory ( ) ) { File saved Logs Dir = get Saved Logs Directory ( ) ; for ( File file : legacy Dir . list Files ( ) ) { file . rename To ( new File ( saved Logs Dir , file . get Name ( ) ) ) ; } legacy Dir . delete ( ) ; } }
public static synchronized void move Logs From Legacy Dir If Necessary ( ) { File sdcard Dir = Environment . get External Storage Directory ( ) ; File legacy Dir = new File ( sdcard Dir , LEGACY SAVED LOGS DIR ) ; if ( legacy Dir . exists ( ) && legacy Dir . is Directory ( ) ) { File saved Logs Dir = get Saved Logs Directory ( ) ; for ( File file : legacy Dir . list Files ( ) ) { file . rename To ( new File ( saved Logs Dir , file . get Name ( ) ) ) ; } legacy Dir . delete ( ) ; } }
public static synchronized void move Logs From Legacy Dir If Necessary ( ) { File sdcard Dir = Environment . get External Storage Directory ( ) ; File legacy Dir = new File ( sdcard Dir , LEGACY SAVED LOGS DIR ) ; if ( legacy Dir . exists ( ) && legacy Dir . is Directory ( ) ) { File saved Logs Dir = get Saved Logs Directory ( ) ; for ( File file : legacy Dir . list Files ( ) ) { file . rename To ( new File ( saved Logs Dir , file . get Name ( ) ) ) ; } legacy Dir . delete ( ) ; } }
public boolean contains ( T data Set ) { for ( int i = NUM ; i < m Data Sets . size ( ) ; i ++ ) { T set = m Data Sets . get ( i ) ; if ( set . equals ( data Set ) ) { return BOOL ; } } return BOOL ; }
public boolean contains ( T data Set ) { for ( int i = NUM ; i < m Data Sets . size ( ) ; i ++ ) { T set = m Data Sets . get ( i ) ; if ( set . equals ( data Set ) ) { return BOOL ; } } return BOOL ; }
private void reorder Spinners ( ) { m Spinners . remove All Views ( ) ; char [ ] order = Date Format . get Date Format Order ( m Context ) ; final int spinner Count = order . length ; for ( int i = NUM ; i < spinner Count ; i ++ ) { switch ( order [ i ] ) { case STRING : m Spinners . add View ( m Day Spinner ) ; set Ime Options ( m Day Spinner , spinner Count , i ) ; break ; case STRING : m Spinners . add View ( m Month Spinner ) ; set Ime Options ( m Month Spinner , spinner Count , i ) ; break ; case STRING : m Spinners . add View ( m Year Spinner ) ; set Ime Options ( m Year Spinner , spinner Count , i ) ; break ; default : throw new Illegal Argument Exception ( Arrays . to String ( order ) ) ; } } }
public File tmp Dir ( ) { String random = String . value Of ( RANDOM . next Long ( ) ) ; File dir = tmp File ( STRING + random ) ; assure Dir Exists ( dir ) ; return dir ; }
public File tmp Dir ( ) { String random = String . value Of ( RANDOM . next Long ( ) ) ; File dir = tmp File ( STRING + random ) ; assure Dir Exists ( dir ) ; return dir ; }
public File tmp Dir ( ) { String random = String . value Of ( RANDOM . next Long ( ) ) ; File dir = tmp File ( STRING + random ) ; assure Dir Exists ( dir ) ; return dir ; }
public File tmp Dir ( ) { String random = String . value Of ( RANDOM . next Long ( ) ) ; File dir = tmp File ( STRING + random ) ; assure Dir Exists ( dir ) ; return dir ; }
@ Rpc Method public void detach ISO ( String vm Id , boolean is Delete File , Async Method Callback < Host . Async Client . detach iso call > handler ) throws Rpc Exception { ensure Client ( ) ; Detach ISO Request detach ISO Request = new Detach ISO Request ( vm Id ) ; detach ISO Request . set Delete file ( is Delete File ) ; client Proxy . set Timeout ( DETACH ISO TIMEOUT MS ) ; logger . info ( STRING , vm Id , get Host Ip ( ) , detach ISO Request ) ; try { client Proxy . detach iso ( detach ISO Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Rpc Method public void detach ISO ( String vm Id , boolean is Delete File , Async Method Callback < Host . Async Client . detach iso call > handler ) throws Rpc Exception { ensure Client ( ) ; Detach ISO Request detach ISO Request = new Detach ISO Request ( vm Id ) ; detach ISO Request . set Delete file ( is Delete File ) ; client Proxy . set Timeout ( DETACH ISO TIMEOUT MS ) ; logger . info ( STRING , vm Id , get Host Ip ( ) , detach ISO Request ) ; try { client Proxy . detach iso ( detach ISO Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
public int write ( final Protein protein , final boolean standalone ) throws IO Exception { check Entry Hierarchy ( ) ; if ( entry Hierarchy != null ) { for ( Protein Xref xref : protein . get Cross References ( ) ) { final Simple Protein simple Protein = Simple Protein . value Of ( protein , xref , entry Hierarchy ) ; if ( simple Protein != null ) { final Simple Hash model = build Model Map ( simple Protein , entry Hierarchy , standalone ) ; Writer writer = null ; try { final Template temp = free Marker Config . get Template ( free Marker Template ) ; check Temp Directory ( temp Directory ) ; if ( ! temp Directory . ends With ( File . separator ) ) { temp Directory = temp Directory + File . separator ; } Url Friendly Id Generator gen = Url Friendly Id Generator . get Instance ( ) ; String url Friendly Id = gen . generate ( xref . get Identifier ( ) ) ; final Path new Result File = Paths . get ( temp Directory + url Friendly Id + STRING ) ; result Files . add ( new Result File ) ; writer = Files . new Buffered Writer ( new Result File , character Set ) ; temp . process ( model , writer ) ; writer . flush ( ) ; } catch ( Template Exception e ) { e . print Stack Trace ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } } } } return NUM ; }
@ Suppress Warnings ( STRING ) private < T > T allow Static Access To Member ( T member , boolean static Only ) { if ( member == null ) return null ; if ( ! static Only ) return member ; boolean is Static ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; is Static = Modifier . is Static ( v . get Modifiers ( ) ) ; } else if ( member instanceof List ) { List < Method Node > list = ( List < Method Node > ) member ; if ( list . size ( ) == NUM ) { return ( T ) Collections . singleton List ( allow Static Access To Member ( list . get ( NUM ) , static Only ) ) ; } return ( T ) Collections . empty List ( ) ; } else { Method Node mn = ( Method Node ) member ; is Static = mn . is Static ( ) ; } if ( static Only && ! is Static ) return null ; return member ; }
@ Suppress Warnings ( STRING ) private < T > T allow Static Access To Member ( T member , boolean static Only ) { if ( member == null ) return null ; if ( ! static Only ) return member ; boolean is Static ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; is Static = Modifier . is Static ( v . get Modifiers ( ) ) ; } else if ( member instanceof List ) { List < Method Node > list = ( List < Method Node > ) member ; if ( list . size ( ) == NUM ) { return ( T ) Collections . singleton List ( allow Static Access To Member ( list . get ( NUM ) , static Only ) ) ; } return ( T ) Collections . empty List ( ) ; } else { Method Node mn = ( Method Node ) member ; is Static = mn . is Static ( ) ; } if ( static Only && ! is Static ) return null ; return member ; }
@ Suppress Warnings ( STRING ) private < T > T allow Static Access To Member ( T member , boolean static Only ) { if ( member == null ) return null ; if ( ! static Only ) return member ; boolean is Static ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; is Static = Modifier . is Static ( v . get Modifiers ( ) ) ; } else if ( member instanceof List ) { List < Method Node > list = ( List < Method Node > ) member ; if ( list . size ( ) == NUM ) { return ( T ) Collections . singleton List ( allow Static Access To Member ( list . get ( NUM ) , static Only ) ) ; } return ( T ) Collections . empty List ( ) ; } else { Method Node mn = ( Method Node ) member ; is Static = mn . is Static ( ) ; } if ( static Only && ! is Static ) return null ; return member ; }
@ Suppress Warnings ( STRING ) private < T > T allow Static Access To Member ( T member , boolean static Only ) { if ( member == null ) return null ; if ( ! static Only ) return member ; boolean is Static ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; is Static = Modifier . is Static ( v . get Modifiers ( ) ) ; } else if ( member instanceof List ) { List < Method Node > list = ( List < Method Node > ) member ; if ( list . size ( ) == NUM ) { return ( T ) Collections . singleton List ( allow Static Access To Member ( list . get ( NUM ) , static Only ) ) ; } return ( T ) Collections . empty List ( ) ; } else { Method Node mn = ( Method Node ) member ; is Static = mn . is Static ( ) ; } if ( static Only && ! is Static ) return null ; return member ; }
@ Suppress Warnings ( STRING ) private < T > T allow Static Access To Member ( T member , boolean static Only ) { if ( member == null ) return null ; if ( ! static Only ) return member ; boolean is Static ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; is Static = Modifier . is Static ( v . get Modifiers ( ) ) ; } else if ( member instanceof List ) { List < Method Node > list = ( List < Method Node > ) member ; if ( list . size ( ) == NUM ) { return ( T ) Collections . singleton List ( allow Static Access To Member ( list . get ( NUM ) , static Only ) ) ; } return ( T ) Collections . empty List ( ) ; } else { Method Node mn = ( Method Node ) member ; is Static = mn . is Static ( ) ; } if ( static Only && ! is Static ) return null ; return member ; }
@ Suppress Warnings ( STRING ) private < T > T allow Static Access To Member ( T member , boolean static Only ) { if ( member == null ) return null ; if ( ! static Only ) return member ; boolean is Static ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; is Static = Modifier . is Static ( v . get Modifiers ( ) ) ; } else if ( member instanceof List ) { List < Method Node > list = ( List < Method Node > ) member ; if ( list . size ( ) == NUM ) { return ( T ) Collections . singleton List ( allow Static Access To Member ( list . get ( NUM ) , static Only ) ) ; } return ( T ) Collections . empty List ( ) ; } else { Method Node mn = ( Method Node ) member ; is Static = mn . is Static ( ) ; } if ( static Only && ! is Static ) return null ; return member ; }
@ Suppress Warnings ( STRING ) private < T > T allow Static Access To Member ( T member , boolean static Only ) { if ( member == null ) return null ; if ( ! static Only ) return member ; boolean is Static ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; is Static = Modifier . is Static ( v . get Modifiers ( ) ) ; } else if ( member instanceof List ) { List < Method Node > list = ( List < Method Node > ) member ; if ( list . size ( ) == NUM ) { return ( T ) Collections . singleton List ( allow Static Access To Member ( list . get ( NUM ) , static Only ) ) ; } return ( T ) Collections . empty List ( ) ; } else { Method Node mn = ( Method Node ) member ; is Static = mn . is Static ( ) ; } if ( static Only && ! is Static ) return null ; return member ; }
@ Suppress Warnings ( STRING ) private < T > T allow Static Access To Member ( T member , boolean static Only ) { if ( member == null ) return null ; if ( ! static Only ) return member ; boolean is Static ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; is Static = Modifier . is Static ( v . get Modifiers ( ) ) ; } else if ( member instanceof List ) { List < Method Node > list = ( List < Method Node > ) member ; if ( list . size ( ) == NUM ) { return ( T ) Collections . singleton List ( allow Static Access To Member ( list . get ( NUM ) , static Only ) ) ; } return ( T ) Collections . empty List ( ) ; } else { Method Node mn = ( Method Node ) member ; is Static = mn . is Static ( ) ; } if ( static Only && ! is Static ) return null ; return member ; }
public boolean contains ( Data Source source ) { return data . contains ( source ) ; }
public static Attrib Key for Attribute ( Namespaces in Scope , El Key el , String qname ) { Namespaces ns ; String local Name ; int colon = qname . index Of ( STRING ) ; if ( colon < NUM ) { ns = el . ns ; local Name = qname ; } else { ns = in Scope . for Attr Name ( el . ns , qname ) ; if ( ns == null ) { return null ; } ns = in Scope . for Uri ( ns . uri ) ; local Name = qname . substring ( colon + NUM ) ; } return new Attrib Key ( el , ns , local Name ) ; }
public static Attrib Key for Attribute ( Namespaces in Scope , El Key el , String qname ) { Namespaces ns ; String local Name ; int colon = qname . index Of ( STRING ) ; if ( colon < NUM ) { ns = el . ns ; local Name = qname ; } else { ns = in Scope . for Attr Name ( el . ns , qname ) ; if ( ns == null ) { return null ; } ns = in Scope . for Uri ( ns . uri ) ; local Name = qname . substring ( colon + NUM ) ; } return new Attrib Key ( el , ns , local Name ) ; }
public int write To Message ( byte [ ] byte Array ) { return write To Message ( byte Array , NUM , byte Array . length ) ; }
public int write To Message ( byte [ ] byte Array ) { return write To Message ( byte Array , NUM , byte Array . length ) ; }
public static Meth Executor Result execute Instance ( String receiver , String selector ) { try { Class receiver Class = Class . for Name ( receiver ) ; Object target = receiver Class . new Instance ( ) ; Object res = null ; try { Method the Method = get Method ( receiver Class , selector , new Class [ NUM ] ) ; res = the Method . invoke ( target , new Object [ NUM ] ) ; return new Meth Executor Result ( res ) ; } catch ( Invocation Target Exception inv Targ Ex ) { Throwable targ Ex = inv Targ Ex . get Target Exception ( ) ; if ( targ Ex == null ) { return new Meth Executor Result ( res ) ; } else { return new Meth Executor Result ( targ Ex ) ; } } } catch ( Virtual Machine Error e ) { System Failure . initiate Failure ( e ) ; throw e ; } catch ( Throwable t ) { return new Meth Executor Result ( t ) ; } }
public static Meth Executor Result execute Instance ( String receiver , String selector ) { try { Class receiver Class = Class . for Name ( receiver ) ; Object target = receiver Class . new Instance ( ) ; Object res = null ; try { Method the Method = get Method ( receiver Class , selector , new Class [ NUM ] ) ; res = the Method . invoke ( target , new Object [ NUM ] ) ; return new Meth Executor Result ( res ) ; } catch ( Invocation Target Exception inv Targ Ex ) { Throwable targ Ex = inv Targ Ex . get Target Exception ( ) ; if ( targ Ex == null ) { return new Meth Executor Result ( res ) ; } else { return new Meth Executor Result ( targ Ex ) ; } } } catch ( Virtual Machine Error e ) { System Failure . initiate Failure ( e ) ; throw e ; } catch ( Throwable t ) { return new Meth Executor Result ( t ) ; } }
protected Rect update Fast Scroller Bounds ( Fast Scroll Recycler View rv , int last Touch Y ) { invalidate Rect . set ( background Bounds ) ; if ( is Visible ( ) ) { int edge Padding = rv . get Max Scrollbar Width ( ) ; int bg Padding = ( original Background Size - text Bounds . height ( ) ) / NUM ; int bg Height = original Background Size ; int bg Width = Math . max ( original Background Size , text Bounds . width ( ) + ( NUM * bg Padding ) ) ; if ( Utilities . is Rtl ( resources ) ) { background Bounds . left = rv . get Background Padding ( ) . left + ( NUM * rv . get Max Scrollbar Width ( ) ) ; background Bounds . right = background Bounds . left + bg Width ; } else { background Bounds . right = rv . get Width ( ) - rv . get Background Padding ( ) . right - ( NUM * rv . get Max Scrollbar Width ( ) ) ; background Bounds . left = background Bounds . right - bg Width ; } background Bounds . top = last Touch Y - ( int ) ( FAST SCROLL OVERLAY Y OFFSET FACTOR * bg Height ) ; background Bounds . top = Math . max ( edge Padding , Math . min ( background Bounds . top , rv . get Height ( ) - edge Padding - bg Height ) ) ; background Bounds . bottom = background Bounds . top + bg Height ; } else { background Bounds . set Empty ( ) ; } invalidate Rect . union ( background Bounds ) ; return invalidate Rect ; }
private void change Columns Type ( List < Column Model > column Model List ) { Log Util . d ( TAG , STRING ) ; List < String > column Names = new Array List < String > ( ) ; if ( column Model List != null && ! column Model List . is Empty ( ) ) { for ( Column Model column Model : column Model List ) { column Names . add ( column Model . get Column Name ( ) ) ; } } remove Columns ( column Names ) ; add Columns ( column Model List ) ; }
private void change Columns Type ( List < Column Model > column Model List ) { Log Util . d ( TAG , STRING ) ; List < String > column Names = new Array List < String > ( ) ; if ( column Model List != null && ! column Model List . is Empty ( ) ) { for ( Column Model column Model : column Model List ) { column Names . add ( column Model . get Column Name ( ) ) ; } } remove Columns ( column Names ) ; add Columns ( column Model List ) ; }
public static void sort ( byte [ ] a ) { do Sort ( a , NUM , a . length - NUM ) ; }
public static List < Interval > slice Intervals ( Interval interval , Time Grain time Grain ) { Date Time interval End = interval . get End ( ) ; Date Time slice Start = interval . get Start ( ) ; Date Time period Start = time Grain . round Floor ( slice Start ) ; if ( ! slice Start . equals ( period Start ) ) { LOG . info ( STRING , interval , time Grain , period Start ) ; throw new Illegal Argument Exception ( STRING + period Start ) ; } List < Interval > interval Slices = new Array List < > ( ) ; while ( slice Start . is Before ( interval End ) ) { Date Time slice End = Date Time Utils . add Time Grain ( slice Start , time Grain ) ; Interval sliced Interval = new Interval ( slice Start , slice End ) ; if ( ! interval . contains ( sliced Interval ) ) { LOG . info ( STRING , interval , time Grain ) ; throw new Illegal Argument Exception ( STRING ) ; } interval Slices . add ( sliced Interval ) ; slice Start = slice End ; } LOG . debug ( STRING , interval , interval Slices . size ( ) , time Grain ) ; return interval Slices ; }
public static List < Interval > slice Intervals ( Interval interval , Time Grain time Grain ) { Date Time interval End = interval . get End ( ) ; Date Time slice Start = interval . get Start ( ) ; Date Time period Start = time Grain . round Floor ( slice Start ) ; if ( ! slice Start . equals ( period Start ) ) { LOG . info ( STRING , interval , time Grain , period Start ) ; throw new Illegal Argument Exception ( STRING + period Start ) ; } List < Interval > interval Slices = new Array List < > ( ) ; while ( slice Start . is Before ( interval End ) ) { Date Time slice End = Date Time Utils . add Time Grain ( slice Start , time Grain ) ; Interval sliced Interval = new Interval ( slice Start , slice End ) ; if ( ! interval . contains ( sliced Interval ) ) { LOG . info ( STRING , interval , time Grain ) ; throw new Illegal Argument Exception ( STRING ) ; } interval Slices . add ( sliced Interval ) ; slice Start = slice End ; } LOG . debug ( STRING , interval , interval Slices . size ( ) , time Grain ) ; return interval Slices ; }
@ Override public Inet Socket Address ip Local ( ) { Socket Channel s = channel ; if ( s != null ) { try { return ( Inet Socket Address ) s . get Local Address ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } } else { return null ; } }
@ Override public Inet Socket Address ip Local ( ) { Socket Channel s = channel ; if ( s != null ) { try { return ( Inet Socket Address ) s . get Local Address ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } } else { return null ; } }
public static boolean is Middle Mouse Button ( Mouse Event an Event ) { return ( an Event . get Modifiers Ex ( ) & Input Event . BUTTON 2 DOWN MASK ) > NUM ; }
public static boolean is Middle Mouse Button ( Mouse Event an Event ) { return ( an Event . get Modifiers Ex ( ) & Input Event . BUTTON 2 DOWN MASK ) > NUM ; }
private void update Seek Bars For Spring Config ( Spring Config spring Config ) { float tension = ( float ) Origami Value Converter . origami Value From Tension ( spring Config . tension ) ; float tension Range = MAX TENSION - MIN TENSION ; int scaled Tension = Math . round ( ( ( tension - MIN TENSION ) * MAX SEEKBAR VAL ) / tension Range ) ; float friction = ( float ) Origami Value Converter . origami Value From Friction ( spring Config . friction ) ; float friction Range = MAX FRICTION - MIN FRICTION ; int scaled Friction = Math . round ( ( ( friction - MIN FRICTION ) * MAX SEEKBAR VAL ) / friction Range ) ; m Tension Seek Bar . set Progress ( scaled Tension ) ; m Friction Seek Bar . set Progress ( scaled Friction ) ; }
public Painter Chain add Painter ( Painter p ) { if ( chain . length != NUM ) { Painter [ ] new Chain = new Painter [ chain . length + NUM ] ; System . arraycopy ( chain , NUM , new Chain , NUM , chain . length ) ; new Chain [ chain . length ] = p ; return new Painter Chain ( new Chain ) ; } return new Painter Chain ( new Painter [ ] { p } ) ; }
public Painter Chain add Painter ( Painter p ) { if ( chain . length != NUM ) { Painter [ ] new Chain = new Painter [ chain . length + NUM ] ; System . arraycopy ( chain , NUM , new Chain , NUM , chain . length ) ; new Chain [ chain . length ] = p ; return new Painter Chain ( new Chain ) ; } return new Painter Chain ( new Painter [ ] { p } ) ; }
@ Override public String model Name ( ) { return STRING ; }
@ Override public String model Name ( ) { return STRING ; }
@ Override public String model Name ( ) { return STRING ; }
protected void engine Init ( Algorithm Parameter Spec gen Param Spec , Secure Random random ) throws Invalid Algorithm Parameter Exception { if ( ! ( gen Param Spec instanceof DH Gen Parameter Spec ) ) { throw new Invalid Algorithm Parameter Exception ( STRING ) ; } DH Gen Parameter Spec dh Param Spec = ( DH Gen Parameter Spec ) gen Param Spec ; prime Size = dh Param Spec . get Prime Size ( ) ; try { check Key Size ( prime Size ) ; } catch ( Invalid Parameter Exception ipe ) { throw new Invalid Algorithm Parameter Exception ( ipe . get Message ( ) ) ; } exponent Size = dh Param Spec . get Exponent Size ( ) ; if ( exponent Size <= NUM ) { throw new Invalid Algorithm Parameter Exception ( STRING ) ; } if ( exponent Size >= prime Size ) { throw new Invalid Algorithm Parameter Exception ( STRING ) ; } }
protected void engine Init ( Algorithm Parameter Spec gen Param Spec , Secure Random random ) throws Invalid Algorithm Parameter Exception { if ( ! ( gen Param Spec instanceof DH Gen Parameter Spec ) ) { throw new Invalid Algorithm Parameter Exception ( STRING ) ; } DH Gen Parameter Spec dh Param Spec = ( DH Gen Parameter Spec ) gen Param Spec ; prime Size = dh Param Spec . get Prime Size ( ) ; try { check Key Size ( prime Size ) ; } catch ( Invalid Parameter Exception ipe ) { throw new Invalid Algorithm Parameter Exception ( ipe . get Message ( ) ) ; } exponent Size = dh Param Spec . get Exponent Size ( ) ; if ( exponent Size <= NUM ) { throw new Invalid Algorithm Parameter Exception ( STRING ) ; } if ( exponent Size >= prime Size ) { throw new Invalid Algorithm Parameter Exception ( STRING ) ; } }
protected void engine Init ( Algorithm Parameter Spec gen Param Spec , Secure Random random ) throws Invalid Algorithm Parameter Exception { if ( ! ( gen Param Spec instanceof DH Gen Parameter Spec ) ) { throw new Invalid Algorithm Parameter Exception ( STRING ) ; } DH Gen Parameter Spec dh Param Spec = ( DH Gen Parameter Spec ) gen Param Spec ; prime Size = dh Param Spec . get Prime Size ( ) ; try { check Key Size ( prime Size ) ; } catch ( Invalid Parameter Exception ipe ) { throw new Invalid Algorithm Parameter Exception ( ipe . get Message ( ) ) ; } exponent Size = dh Param Spec . get Exponent Size ( ) ; if ( exponent Size <= NUM ) { throw new Invalid Algorithm Parameter Exception ( STRING ) ; } if ( exponent Size >= prime Size ) { throw new Invalid Algorithm Parameter Exception ( STRING ) ; } }
private static int [ ] calculate Multipart Size ( long size ) throws Invalid Argument Exception { if ( size > MAX OBJECT SIZE ) { throw new Invalid Argument Exception ( STRING + size + STRING ) ; } double part Size = Math . ceil ( ( double ) size / MAX MULTIPART COUNT ) ; part Size = Math . ceil ( part Size / MIN MULTIPART SIZE ) * MIN MULTIPART SIZE ; double part Count = Math . ceil ( size / part Size ) ; double last Part Size = part Size - ( part Size * part Count - size ) ; if ( last Part Size == NUM ) { last Part Size = part Size ; } return new int [ ] { ( int ) part Size , ( int ) part Count , ( int ) last Part Size } ; }
private static int [ ] calculate Multipart Size ( long size ) throws Invalid Argument Exception { if ( size > MAX OBJECT SIZE ) { throw new Invalid Argument Exception ( STRING + size + STRING ) ; } double part Size = Math . ceil ( ( double ) size / MAX MULTIPART COUNT ) ; part Size = Math . ceil ( part Size / MIN MULTIPART SIZE ) * MIN MULTIPART SIZE ; double part Count = Math . ceil ( size / part Size ) ; double last Part Size = part Size - ( part Size * part Count - size ) ; if ( last Part Size == NUM ) { last Part Size = part Size ; } return new int [ ] { ( int ) part Size , ( int ) part Count , ( int ) last Part Size } ; }
public void delete Metadata Entry ( int i ) { if ( i < metadata . size ( ) ) { metadata . remove ( i ) ; } }
public void remove Consistency Group Snapshot ( String consistency Group Id ) throws Exception { String system Id = get System Id ( ) ; String uri = Scale IO Constants . get Remove Consistency Group Snapshots URI ( system Id ) ; Scale IO Remove Consistency Group Snapshots parm = new Scale IO Remove Consistency Group Snapshots ( ) ; parm . set Snap Group Id ( consistency Group Id ) ; post ( URI . create ( uri ) , get Json For Entity ( parm ) ) ; }
public void add ( int position , T item ) { m Data . add ( position , item ) ; notify Item Inserted ( position ) ; }
public void test Start ( long c ) { if ( this . is Singleton ) { throw new Illegal State Exception ( STRING ) ; } String test Name = build Test Name From Stack ( ) ; test Start ( test Name , Enum Set . none Of ( Test Property . class ) , c ) ; }
@ Override public void on Create ( Bundle saved Instance State ) { super . on Create ( saved Instance State ) ; m Handler = new Handler ( ) ; set Content View ( R . layout . voice recognition ) ; Button speak Button = ( Button ) find View By Id ( R . id . btn speak ) ; m List = ( List View ) find View By Id ( R . id . list ) ; m Supported Language View = ( Spinner ) find View By Id ( R . id . supported languages ) ; Package Manager pm = get Package Manager ( ) ; List < Resolve Info > activities = pm . query Intent Activities ( new Intent ( Recognizer Intent . ACTION RECOGNIZE SPEECH ) , NUM ) ; if ( activities . size ( ) != NUM ) { speak Button . set On Click Listener ( this ) ; } else { speak Button . set Enabled ( BOOL ) ; speak Button . set Text ( STRING ) ; } refresh Voice Settings ( ) ; }
@ Override public void on Create ( Bundle saved Instance State ) { super . on Create ( saved Instance State ) ; m Handler = new Handler ( ) ; set Content View ( R . layout . voice recognition ) ; Button speak Button = ( Button ) find View By Id ( R . id . btn speak ) ; m List = ( List View ) find View By Id ( R . id . list ) ; m Supported Language View = ( Spinner ) find View By Id ( R . id . supported languages ) ; Package Manager pm = get Package Manager ( ) ; List < Resolve Info > activities = pm . query Intent Activities ( new Intent ( Recognizer Intent . ACTION RECOGNIZE SPEECH ) , NUM ) ; if ( activities . size ( ) != NUM ) { speak Button . set On Click Listener ( this ) ; } else { speak Button . set Enabled ( BOOL ) ; speak Button . set Text ( STRING ) ; } refresh Voice Settings ( ) ; }
public Annotation Drawer ( final Annotations Model model , final Process Renderer Model renderer Model ) { this . model = model ; this . renderer Model = renderer Model ; this . display Cache = new Hash Map < > ( ) ; this . cached ID = new Hash Map < > ( ) ; pane = new J Editor Pane ( STRING , STRING ) ; pane . set Border ( null ) ; pane . set Opaque ( BOOL ) ; }
public boolean validate Password ( String password , String good Hash ) { return validate Password ( password . to Char Array ( ) , good Hash ) ; }
public URL find Resource ( String name , boolean check ) { Loader loader ; int [ ] cache = get Lookup Cache ( name ) ; for ( int i = NUM ; ( loader = get Next Loader ( cache , i ) ) != null ; i ++ ) { URL url = loader . find Resource ( name , check ) ; if ( url != null ) { return url ; } } return null ; }
public void push Scope ( ) { if ( f Current Scope + NUM == f Scope . length ) { int [ ] contextarray = new int [ f Scope . length * NUM ] ; System . arraycopy ( f Scope , NUM , contextarray , NUM , f Scope . length ) ; f Scope = contextarray ; } push Context ( ) ; f Scope [ ++ f Current Scope ] = f Current Context ; }
public void push Scope ( ) { if ( f Current Scope + NUM == f Scope . length ) { int [ ] contextarray = new int [ f Scope . length * NUM ] ; System . arraycopy ( f Scope , NUM , contextarray , NUM , f Scope . length ) ; f Scope = contextarray ; } push Context ( ) ; f Scope [ ++ f Current Scope ] = f Current Context ; }
public void push Scope ( ) { if ( f Current Scope + NUM == f Scope . length ) { int [ ] contextarray = new int [ f Scope . length * NUM ] ; System . arraycopy ( f Scope , NUM , contextarray , NUM , f Scope . length ) ; f Scope = contextarray ; } push Context ( ) ; f Scope [ ++ f Current Scope ] = f Current Context ; }
public static long create Bookmarks Folder Once ( Context context , String title , long parent Id ) { Long id = chrome Browser Provider Call ( Long . class , Chrome Browser Provider . CLIENT API CREATE BOOKMARKS FOLDER ONCE , context , args To Bundle ( title , parent Id ) ) ; return id != null ? id . long Value ( ) : INVALID BOOKMARK ID ; }
public static long create Bookmarks Folder Once ( Context context , String title , long parent Id ) { Long id = chrome Browser Provider Call ( Long . class , Chrome Browser Provider . CLIENT API CREATE BOOKMARKS FOLDER ONCE , context , args To Bundle ( title , parent Id ) ) ; return id != null ? id . long Value ( ) : INVALID BOOKMARK ID ; }
public static long create Bookmarks Folder Once ( Context context , String title , long parent Id ) { Long id = chrome Browser Provider Call ( Long . class , Chrome Browser Provider . CLIENT API CREATE BOOKMARKS FOLDER ONCE , context , args To Bundle ( title , parent Id ) ) ; return id != null ? id . long Value ( ) : INVALID BOOKMARK ID ; }
public static long create Bookmarks Folder Once ( Context context , String title , long parent Id ) { Long id = chrome Browser Provider Call ( Long . class , Chrome Browser Provider . CLIENT API CREATE BOOKMARKS FOLDER ONCE , context , args To Bundle ( title , parent Id ) ) ; return id != null ? id . long Value ( ) : INVALID BOOKMARK ID ; }
public static long create Bookmarks Folder Once ( Context context , String title , long parent Id ) { Long id = chrome Browser Provider Call ( Long . class , Chrome Browser Provider . CLIENT API CREATE BOOKMARKS FOLDER ONCE , context , args To Bundle ( title , parent Id ) ) ; return id != null ? id . long Value ( ) : INVALID BOOKMARK ID ; }
protected void compare Datasets ( Instances data 1 , Instances data 2 ) throws Exception { if ( ! data 2 . equal Headers ( data 1 ) ) { throw new Exception ( STRING + data 2 . equal Headers Msg ( data 1 ) ) ; } if ( ! ( data 2 . num Instances ( ) == data 1 . num Instances ( ) ) ) { throw new Exception ( STRING ) ; } for ( int i = NUM ; i < data 2 . num Instances ( ) ; i ++ ) { Instance orig = data 1 . instance ( i ) ; Instance copy = data 2 . instance ( i ) ; for ( int j = NUM ; j < orig . num Attributes ( ) ; j ++ ) { if ( orig . is Missing ( j ) ) { if ( ! copy . is Missing ( j ) ) { throw new Exception ( STRING ) ; } } else if ( orig . value ( j ) != copy . value ( j ) ) { throw new Exception ( STRING ) ; } if ( orig . weight ( ) != copy . weight ( ) ) { throw new Exception ( STRING ) ; } } } }
public int read ( ) throws IO Exception { synchronized ( lock ) { char [ ] char Array = new char [ NUM ] ; if ( read ( char Array , NUM , NUM ) != - NUM ) { return char Array [ NUM ] ; } return - NUM ; } }
public static X Content Type x Content Type ( Char Sequence content ) { int length = content . length ( ) < GUESS HEADER LENGTH ? content . length ( ) : GUESS HEADER LENGTH ; if ( length == NUM ) { return null ; } char first = content . char At ( NUM ) ; if ( first == STRING ) { return X Content Type . JSON ; } if ( length > NUM && first == Smile Constants . HEADER BYTE 1 && content . char At ( NUM ) == Smile Constants . HEADER BYTE 2 && content . char At ( NUM ) == Smile Constants . HEADER BYTE 3 ) { return X Content Type . SMILE ; } if ( length > NUM && first == STRING && content . char At ( NUM ) == STRING && content . char At ( NUM ) == STRING ) { return X Content Type . YAML ; } for ( int i = NUM ; i < length ; i ++ ) { char c = content . char At ( i ) ; if ( c == STRING ) { return X Content Type . JSON ; } if ( Character . is Whitespace ( c ) == BOOL ) { break ; } } return null ; }
@ Visible For Testing public static String file Name ( String url , String mime Type , String content Disposition ) { String file Name = URL Util . guess File Name ( url , content Disposition , mime Type ) ; int dot Index = file Name . last Index Of ( STRING ) ; if ( mime Type != null && ! mime Type . is Empty ( ) && dot Index > NUM && dot Index < file Name . length ( ) ) { Mime Type Map mime Type Map = Mime Type Map . get Singleton ( ) ; String file Root = file Name . substring ( NUM , dot Index ) ; String file Extension = file Name . substring ( dot Index + NUM ) ; String file Extension Mime Type = mime Type Map . get Mime Type From Extension ( file Extension ) ; if ( mime Type . equals ( file Extension Mime Type ) ) { file Name = file Root + STRING + file Extension ; } else { String mime Extension = mime Type Map . get Extension From Mime Type ( mime Type ) ; if ( mime Extension != null && ! mime Extension . equals ( file Extension ) ) { file Name = file Root + STRING + mime Extension ; } } } return file Name ; }
public static void remove Images ( @ Not Null List < String > lines ) { for ( int i = NUM ; i < lines . size ( ) ; i ++ ) { String new Text = remove All Images ( lines . get ( i ) ) ; lines . set ( i , new Text ) ; } }
public static void remove Images ( @ Not Null List < String > lines ) { for ( int i = NUM ; i < lines . size ( ) ; i ++ ) { String new Text = remove All Images ( lines . get ( i ) ) ; lines . set ( i , new Text ) ; } }
public T first ( ) { if ( filter == null ) { List < Search Result Resource Rep > result Refs = resources . perform Search ( parameters ) ; if ( result Refs . is Empty ( ) ) { return null ; } return resources . get ( result Refs . get ( NUM ) ) ; } else { List < T > items = run ( ) ; if ( items . is Empty ( ) ) { return null ; } return items . get ( NUM ) ; } }
public T first ( ) { if ( filter == null ) { List < Search Result Resource Rep > result Refs = resources . perform Search ( parameters ) ; if ( result Refs . is Empty ( ) ) { return null ; } return resources . get ( result Refs . get ( NUM ) ) ; } else { List < T > items = run ( ) ; if ( items . is Empty ( ) ) { return null ; } return items . get ( NUM ) ; } }
public void add Slide ( @ Non Null Fragment fragment ) { fragments . add ( fragment ) ; m Pager Adapter . notify Data Set Changed ( ) ; }
private Cipher Box ( Protocol Version protocol Version , Bulk Cipher bulk Cipher , Secret Key key , Iv Parameter Spec iv , Secure Random random , boolean encrypt ) throws No Such Algorithm Exception { try { this . protocol Version = protocol Version ; this . cipher = Jsse Jce . get Cipher ( bulk Cipher . transformation ) ; this . mode = encrypt ? Cipher . ENCRYPT MODE : Cipher . DECRYPT MODE ; if ( random == null ) { random = Jsse Jce . get Secure Random ( ) ; } this . random = random ; this . cipher Type = bulk Cipher . cipher Type ; if ( iv == null && bulk Cipher . iv Size != NUM && mode == Cipher . DECRYPT MODE && protocol Version . v >= Protocol Version . TLS 11 . v ) { iv = get Fixed Mask ( bulk Cipher . iv Size ) ; } if ( cipher Type == AEAD CIPHER ) { tag Size = bulk Cipher . tag Size ; this . key = key ; fixed Iv = iv . get IV ( ) ; if ( fixed Iv == null || fixed Iv . length != bulk Cipher . fixed Iv Size ) { throw new Runtime Exception ( STRING ) ; } record Iv Size = bulk Cipher . iv Size - bulk Cipher . fixed Iv Size ; } else { this . tag Size = NUM ; this . fixed Iv = new byte [ NUM ] ; this . record Iv Size = NUM ; this . key = null ; cipher . init ( mode , key , iv , random ) ; } } catch ( No Such Algorithm Exception e ) { throw e ; } catch ( Exception e ) { throw new No Such Algorithm Exception ( STRING + bulk Cipher , e ) ; } catch ( Exception In Initializer Error e ) { throw new No Such Algorithm Exception ( STRING + bulk Cipher , e ) ; } }
public static void write List Of Longs ( List list , boolean has Long I Ds , Data Output out ) throws IO Exception { if ( list == null ) { out . write Int ( - NUM ) ; } else { out . write Int ( list . size ( ) ) ; out . write Boolean ( has Long I Ds ) ; for ( Iterator it = list . iterator ( ) ; it . has Next ( ) ; ) { Long l = ( Long ) it . next ( ) ; if ( has Long I Ds ) { out . write Long ( l . long Value ( ) ) ; } else { out . write Int ( ( int ) l . long Value ( ) ) ; } } } }
public static Observable String Value decision ( Observable Boolean Value condition , Observable String Value if True , Observable String Value if False ) { String Property ret = new Simple String Property ( ) ; condition . add Listener ( null ) ; if True . add Listener ( null ) ; if False . add Listener ( null ) ; ret . set ( condition . get ( ) ? if True . get ( ) : if False . get ( ) ) ; return ret ; }
public static Observable String Value decision ( Observable Boolean Value condition , Observable String Value if True , Observable String Value if False ) { String Property ret = new Simple String Property ( ) ; condition . add Listener ( null ) ; if True . add Listener ( null ) ; if False . add Listener ( null ) ; ret . set ( condition . get ( ) ? if True . get ( ) : if False . get ( ) ) ; return ret ; }
private final File locate ( String name ) { String prefix = STRING ; File source File = null ; int idx = NUM ; while ( BOOL ) { if ( ( idx == NUM ) && ( Tool IO . get User Dir ( ) != null ) ) { source File = new File ( Tool IO . get User Dir ( ) , name ) ; } else { if ( is In Jar ( prefix ) ) { Input Stream is = cl . get Resource As Stream ( STANDARD MODULES + name ) ; if ( is != null ) { try { source File = new File ( TMPDIR + File . separator + name ) ; source File . delete On Exit ( ) ; File Output Stream fos = new File Output Stream ( source File ) ; byte buf [ ] = new byte [ NUM ] ; int len ; while ( ( len = is . read ( buf ) ) > NUM ) { fos . write ( buf , NUM , len ) ; } fos . close ( ) ; is . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } } else { source File = new File ( prefix + name ) ; } } if ( source File . exists ( ) ) break ; if ( idx >= library Paths . length ) break ; prefix = library Paths [ idx ++ ] ; } return source File ; }
private final File locate ( String name ) { String prefix = STRING ; File source File = null ; int idx = NUM ; while ( BOOL ) { if ( ( idx == NUM ) && ( Tool IO . get User Dir ( ) != null ) ) { source File = new File ( Tool IO . get User Dir ( ) , name ) ; } else { if ( is In Jar ( prefix ) ) { Input Stream is = cl . get Resource As Stream ( STANDARD MODULES + name ) ; if ( is != null ) { try { source File = new File ( TMPDIR + File . separator + name ) ; source File . delete On Exit ( ) ; File Output Stream fos = new File Output Stream ( source File ) ; byte buf [ ] = new byte [ NUM ] ; int len ; while ( ( len = is . read ( buf ) ) > NUM ) { fos . write ( buf , NUM , len ) ; } fos . close ( ) ; is . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } } else { source File = new File ( prefix + name ) ; } } if ( source File . exists ( ) ) break ; if ( idx >= library Paths . length ) break ; prefix = library Paths [ idx ++ ] ; } return source File ; }
private final File locate ( String name ) { String prefix = STRING ; File source File = null ; int idx = NUM ; while ( BOOL ) { if ( ( idx == NUM ) && ( Tool IO . get User Dir ( ) != null ) ) { source File = new File ( Tool IO . get User Dir ( ) , name ) ; } else { if ( is In Jar ( prefix ) ) { Input Stream is = cl . get Resource As Stream ( STANDARD MODULES + name ) ; if ( is != null ) { try { source File = new File ( TMPDIR + File . separator + name ) ; source File . delete On Exit ( ) ; File Output Stream fos = new File Output Stream ( source File ) ; byte buf [ ] = new byte [ NUM ] ; int len ; while ( ( len = is . read ( buf ) ) > NUM ) { fos . write ( buf , NUM , len ) ; } fos . close ( ) ; is . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } } else { source File = new File ( prefix + name ) ; } } if ( source File . exists ( ) ) break ; if ( idx >= library Paths . length ) break ; prefix = library Paths [ idx ++ ] ; } return source File ; }
private final File locate ( String name ) { String prefix = STRING ; File source File = null ; int idx = NUM ; while ( BOOL ) { if ( ( idx == NUM ) && ( Tool IO . get User Dir ( ) != null ) ) { source File = new File ( Tool IO . get User Dir ( ) , name ) ; } else { if ( is In Jar ( prefix ) ) { Input Stream is = cl . get Resource As Stream ( STANDARD MODULES + name ) ; if ( is != null ) { try { source File = new File ( TMPDIR + File . separator + name ) ; source File . delete On Exit ( ) ; File Output Stream fos = new File Output Stream ( source File ) ; byte buf [ ] = new byte [ NUM ] ; int len ; while ( ( len = is . read ( buf ) ) > NUM ) { fos . write ( buf , NUM , len ) ; } fos . close ( ) ; is . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } } else { source File = new File ( prefix + name ) ; } } if ( source File . exists ( ) ) break ; if ( idx >= library Paths . length ) break ; prefix = library Paths [ idx ++ ] ; } return source File ; }
private final File locate ( String name ) { String prefix = STRING ; File source File = null ; int idx = NUM ; while ( BOOL ) { if ( ( idx == NUM ) && ( Tool IO . get User Dir ( ) != null ) ) { source File = new File ( Tool IO . get User Dir ( ) , name ) ; } else { if ( is In Jar ( prefix ) ) { Input Stream is = cl . get Resource As Stream ( STANDARD MODULES + name ) ; if ( is != null ) { try { source File = new File ( TMPDIR + File . separator + name ) ; source File . delete On Exit ( ) ; File Output Stream fos = new File Output Stream ( source File ) ; byte buf [ ] = new byte [ NUM ] ; int len ; while ( ( len = is . read ( buf ) ) > NUM ) { fos . write ( buf , NUM , len ) ; } fos . close ( ) ; is . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } } else { source File = new File ( prefix + name ) ; } } if ( source File . exists ( ) ) break ; if ( idx >= library Paths . length ) break ; prefix = library Paths [ idx ++ ] ; } return source File ; }
private void paint Check Icon Selected And Mouse Over ( Graphics 2 D g , int width , int height ) { Shape s = shape Generator . create Check Mark ( NUM , NUM , width , height ) ; g . set Paint ( icon Selected Mouse Over ) ; g . fill ( s ) ; }
public String make Field Prompt ( final String field Name , final boolean default Value ) { return String . format ( STRING , field Name , default Value ) ; }
public void load Toolbox Contents ( String toolbox Xml ) { load Toolbox Contents ( new Byte Array Input Stream ( toolbox Xml . get Bytes ( ) ) ) ; }
public static void calc Text Size ( Paint paint , String demo Text , F Size output F Size ) { Rect r = m Calc Text Size Rect ; r . set ( NUM , NUM , NUM , NUM ) ; paint . get Text Bounds ( demo Text , NUM , demo Text . length ( ) , r ) ; output F Size . width = r . width ( ) ; output F Size . height = r . height ( ) ; }
public static void calc Text Size ( Paint paint , String demo Text , F Size output F Size ) { Rect r = m Calc Text Size Rect ; r . set ( NUM , NUM , NUM , NUM ) ; paint . get Text Bounds ( demo Text , NUM , demo Text . length ( ) , r ) ; output F Size . width = r . width ( ) ; output F Size . height = r . height ( ) ; }
public static Input Stream need Stream ( String property Name ) throws No Such Property Exception , File Not Found Exception , Mary Configuration Exception { Mary Properties . need Property ( property Name ) ; return get Stream ( property Name ) ; }
protected Ignite start Remote Grid ( String grid Name , Ignite Configuration cfg , Grid Spring Resource Context ctx ) throws Exception { if ( ctx != null ) throw new Unsupported Operation Exception ( STRING ) ; if ( cfg == null ) cfg = optimize ( get Configuration ( grid Name ) ) ; return new Ignite Process Proxy ( cfg , log , grid ( NUM ) ) ; }
protected Ignite start Remote Grid ( String grid Name , Ignite Configuration cfg , Grid Spring Resource Context ctx ) throws Exception { if ( ctx != null ) throw new Unsupported Operation Exception ( STRING ) ; if ( cfg == null ) cfg = optimize ( get Configuration ( grid Name ) ) ; return new Ignite Process Proxy ( cfg , log , grid ( NUM ) ) ; }
public void add Sensor Selection Listener ( final Sensor Selection Listener listener ) { listener List . add ( Sensor Selection Listener . class , listener ) ; }
public static void add Image Loader ( Image Loader loader ) { if ( null != loader && ! IMAGE LOADERS . contains ( loader ) ) { IMAGE LOADERS . add ( NUM , loader ) ; } }
public static void add Image Loader ( Image Loader loader ) { if ( null != loader && ! IMAGE LOADERS . contains ( loader ) ) { IMAGE LOADERS . add ( NUM , loader ) ; } }
public static void add Image Loader ( Image Loader loader ) { if ( null != loader && ! IMAGE LOADERS . contains ( loader ) ) { IMAGE LOADERS . add ( NUM , loader ) ; } }
private void add To Chart ( Trie trie , int j , boolean is Unary ) { if ( ! is Unary && trie . has Rules ( ) ) { Dot Node dot Node = new Dot Node ( i , j , trie , new Array List < > ( node Stack ) , null ) ; add To Candidates ( dot Node ) ; } for ( int l = j + NUM ; l <= sentence . length ( ) ; l ++ ) consume ( trie , j , l ) ; }
private void add To Chart ( Trie trie , int j , boolean is Unary ) { if ( ! is Unary && trie . has Rules ( ) ) { Dot Node dot Node = new Dot Node ( i , j , trie , new Array List < > ( node Stack ) , null ) ; add To Candidates ( dot Node ) ; } for ( int l = j + NUM ; l <= sentence . length ( ) ; l ++ ) consume ( trie , j , l ) ; }
private void add To Chart ( Trie trie , int j , boolean is Unary ) { if ( ! is Unary && trie . has Rules ( ) ) { Dot Node dot Node = new Dot Node ( i , j , trie , new Array List < > ( node Stack ) , null ) ; add To Candidates ( dot Node ) ; } for ( int l = j + NUM ; l <= sentence . length ( ) ; l ++ ) consume ( trie , j , l ) ; }
public static int ping ( String url ) throws Exception { URL u = new URL ( url ) ; Http URL Connection c = ( Http URL Connection ) u . open Connection ( ) ; c . connect ( ) ; int code = c . get Response Code ( ) ; log . debug ( STRING + url + STRING + code ) ; c . disconnect ( ) ; return code ; }
public static int ping ( String url ) throws Exception { URL u = new URL ( url ) ; Http URL Connection c = ( Http URL Connection ) u . open Connection ( ) ; c . connect ( ) ; int code = c . get Response Code ( ) ; log . debug ( STRING + url + STRING + code ) ; c . disconnect ( ) ; return code ; }
private void draw Y Tick Marks ( Graphics g ) { Rectangle plot Rect = get Plot Rect ( ) ; int x Pos = plot Rect . x ; Number Format nf = Number Format . get Instance ( ) ; nf . set Minimum Fraction Digits ( NUM ) ; nf . set Maximum Fraction Digits ( NUM ) ; for ( double d = NUM ; d <= NUM ; d += NUM ) { int y Pos = get Y Pos ( d ) ; g . set Color ( boundary Color ) ; g . draw Line ( x Pos , y Pos , x Pos + NUM , y Pos ) ; String str = nf . format ( d ) ; int str Wid = fm . string Width ( str ) ; int str Hgt = fm . get Ascent ( ) ; g . draw String ( str , x Pos - str Wid - NUM , y Pos + str Hgt / NUM ) ; } }
public final void remove Element At ( int i ) { if ( i > m first Free ) System . arraycopy ( m map , i + NUM , m map , i , m first Free ) ; else m map [ i ] = null ; m first Free -- ; }
public final void remove Element At ( int i ) { if ( i > m first Free ) System . arraycopy ( m map , i + NUM , m map , i , m first Free ) ; else m map [ i ] = null ; m first Free -- ; }
public final void remove Element At ( int i ) { if ( i > m first Free ) System . arraycopy ( m map , i + NUM , m map , i , m first Free ) ; else m map [ i ] = null ; m first Free -- ; }
public final void remove Element At ( int i ) { if ( i > m first Free ) System . arraycopy ( m map , i + NUM , m map , i , m first Free ) ; else m map [ i ] = null ; m first Free -- ; }
public final void remove Element At ( int i ) { if ( i > m first Free ) System . arraycopy ( m map , i + NUM , m map , i , m first Free ) ; else m map [ i ] = null ; m first Free -- ; }
protected abstract List < String > create Command ( Step Instance step Instance , String temporary File Directory ) ;
protected abstract List < String > create Command ( Step Instance step Instance , String temporary File Directory ) ;
protected abstract List < String > create Command ( Step Instance step Instance , String temporary File Directory ) ;
protected abstract List < String > create Command ( Step Instance step Instance , String temporary File Directory ) ;
protected abstract List < String > create Command ( Step Instance step Instance , String temporary File Directory ) ;
public Encoder Test Suite Builder invalid ( int min , int max ) { invalid . set ( min , max + NUM ) ; valid . clear ( min , max + NUM ) ; encoded . clear ( min , max + NUM ) ; return this ; }
public Encoder Test Suite Builder invalid ( int min , int max ) { invalid . set ( min , max + NUM ) ; valid . clear ( min , max + NUM ) ; encoded . clear ( min , max + NUM ) ; return this ; }
private void check Completion ( ) { for ( Iterator < Compute Task Future < Integer > > iter = futures . iterator ( ) ; iter . has Next ( ) ; ) { Compute Task Future < Integer > fut = iter . next ( ) ; if ( fut . is Done ( ) ) { try { Integer res = fut . get ( ) ; assert res == params . get Jobs Count ( ) : STRING + fut . get Task Session ( ) . get Id ( ) + STRING + res + STRING ; ignite . log ( ) . info ( STRING + fut . get Task Session ( ) . get Id ( ) ) ; } catch ( Ignite Future Cancelled Exception ignored ) { ignite . log ( ) . info ( STRING + fut . get Task Session ( ) . get Id ( ) ) ; } catch ( Ignite Exception e ) { ignite . log ( ) . warning ( STRING + fut . get Task Session ( ) . get Id ( ) , e ) ; } finally { iter . remove ( ) ; } } } }
private void check Completion ( ) { for ( Iterator < Compute Task Future < Integer > > iter = futures . iterator ( ) ; iter . has Next ( ) ; ) { Compute Task Future < Integer > fut = iter . next ( ) ; if ( fut . is Done ( ) ) { try { Integer res = fut . get ( ) ; assert res == params . get Jobs Count ( ) : STRING + fut . get Task Session ( ) . get Id ( ) + STRING + res + STRING ; ignite . log ( ) . info ( STRING + fut . get Task Session ( ) . get Id ( ) ) ; } catch ( Ignite Future Cancelled Exception ignored ) { ignite . log ( ) . info ( STRING + fut . get Task Session ( ) . get Id ( ) ) ; } catch ( Ignite Exception e ) { ignite . log ( ) . warning ( STRING + fut . get Task Session ( ) . get Id ( ) , e ) ; } finally { iter . remove ( ) ; } } } }
public void output Source ( int module , int line , String s ) { String Builder sb = new String Builder ( ) ; append Source ( sb , module , line , s , BOOL ) ; out ( sb . to String ( ) ) ; }
private synchronized void save To Settings ( ) { if ( settings != null ) { List < List > data To Save = new Array List < > ( ) ; for ( Hotkey hotkey : hotkeys ) { data To Save . add ( hotkey To List ( hotkey ) ) ; } settings . put List ( SETTING NAME , data To Save ) ; } }
@ Suppress Warnings ( STRING ) @ Override synchronized public void start ( ) { A . not Null ( spring Cfg Path , STRING ) ; A . not Null ( cache Name , STRING ) ; A . not Null ( event Transformer Cls , STRING ) ; sink Counter . start ( ) ; try { if ( ignite == null ) ignite = Ignition . start ( spring Cfg Path ) ; if ( event Transformer Cls != null && ! event Transformer Cls . is Empty ( ) ) { Class < ? extends Event Transformer > clazz = ( Class < ? extends Event Transformer < Event , Object , Object > > ) Class . for Name ( event Transformer Cls ) ; event Transformer = clazz . new Instance ( ) ; } } catch ( Exception e ) { log . error ( STRING , e ) ; throw new Flume Exception ( STRING , e ) ; } super . start ( ) ; }
public Task Convert Image To RGB Preview create Task Convert Image To RGB Preview ( Image To Process image , Executor executor , Image Backend image Backend , Capture Session session , Size target Size , Task Convert Image To RGB Preview . Thumbnail Shape thumbnail Shape ) { return new Task Convert Image To RGB Preview ( image , executor , image Backend , Task Image Container . Processing Priority . FAST , session , m Tiny Thumbnail Target Size , thumbnail Shape ) ; }
public void store Domain For ( Variable var , Domain domain ) { if ( ! affected Variables . contains ( var ) ) { saved Domains . add ( new Pair < Variable , Domain > ( var , domain ) ) ; affected Variables . add ( var ) ; } }
public void store Domain For ( Variable var , Domain domain ) { if ( ! affected Variables . contains ( var ) ) { saved Domains . add ( new Pair < Variable , Domain > ( var , domain ) ) ; affected Variables . add ( var ) ; } }
public static void update Media Notification For Tab ( Context context , int tab Id , boolean audio , boolean video , String full Url ) { int media Type = get Media Type ( audio , video ) ; if ( ! should Start Service ( context , media Type , tab Id ) ) return ; Intent intent = new Intent ( context , Media Capture Notification Service . class ) ; intent . put Extra ( NOTIFICATION ID EXTRA , tab Id ) ; String base Url = full Url ; try { URL url = new URL ( full Url ) ; base Url = url . get Protocol ( ) + STRING + url . get Host ( ) ; } catch ( Malformed URL Exception e ) { Log . w ( TAG , STRING + full Url ) ; } intent . put Extra ( NOTIFICATION MEDIA URL EXTRA , base Url ) ; intent . put Extra ( NOTIFICATION MEDIA TYPE EXTRA , media Type ) ; context . start Service ( intent ) ; }
public static void update Media Notification For Tab ( Context context , int tab Id , boolean audio , boolean video , String full Url ) { int media Type = get Media Type ( audio , video ) ; if ( ! should Start Service ( context , media Type , tab Id ) ) return ; Intent intent = new Intent ( context , Media Capture Notification Service . class ) ; intent . put Extra ( NOTIFICATION ID EXTRA , tab Id ) ; String base Url = full Url ; try { URL url = new URL ( full Url ) ; base Url = url . get Protocol ( ) + STRING + url . get Host ( ) ; } catch ( Malformed URL Exception e ) { Log . w ( TAG , STRING + full Url ) ; } intent . put Extra ( NOTIFICATION MEDIA URL EXTRA , base Url ) ; intent . put Extra ( NOTIFICATION MEDIA TYPE EXTRA , media Type ) ; context . start Service ( intent ) ; }
public static void update Media Notification For Tab ( Context context , int tab Id , boolean audio , boolean video , String full Url ) { int media Type = get Media Type ( audio , video ) ; if ( ! should Start Service ( context , media Type , tab Id ) ) return ; Intent intent = new Intent ( context , Media Capture Notification Service . class ) ; intent . put Extra ( NOTIFICATION ID EXTRA , tab Id ) ; String base Url = full Url ; try { URL url = new URL ( full Url ) ; base Url = url . get Protocol ( ) + STRING + url . get Host ( ) ; } catch ( Malformed URL Exception e ) { Log . w ( TAG , STRING + full Url ) ; } intent . put Extra ( NOTIFICATION MEDIA URL EXTRA , base Url ) ; intent . put Extra ( NOTIFICATION MEDIA TYPE EXTRA , media Type ) ; context . start Service ( intent ) ; }
public final boolean begin Atomic Transaction ( Connection connection ) throws Ade Exception { this . connection = connection ; created Statements = new Array List < Statement > ( ) ; final boolean result = perform Atomic Transaction ( ) ; for ( Statement s : created Statements ) { try { s . close ( ) ; } catch ( SQL Exception e ) { logger . error ( STRING , e ) ; } } this . connection = null ; return result ; }
public final boolean begin Atomic Transaction ( Connection connection ) throws Ade Exception { this . connection = connection ; created Statements = new Array List < Statement > ( ) ; final boolean result = perform Atomic Transaction ( ) ; for ( Statement s : created Statements ) { try { s . close ( ) ; } catch ( SQL Exception e ) { logger . error ( STRING , e ) ; } } this . connection = null ; return result ; }
public final boolean begin Atomic Transaction ( Connection connection ) throws Ade Exception { this . connection = connection ; created Statements = new Array List < Statement > ( ) ; final boolean result = perform Atomic Transaction ( ) ; for ( Statement s : created Statements ) { try { s . close ( ) ; } catch ( SQL Exception e ) { logger . error ( STRING , e ) ; } } this . connection = null ; return result ; }
public final boolean begin Atomic Transaction ( Connection connection ) throws Ade Exception { this . connection = connection ; created Statements = new Array List < Statement > ( ) ; final boolean result = perform Atomic Transaction ( ) ; for ( Statement s : created Statements ) { try { s . close ( ) ; } catch ( SQL Exception e ) { logger . error ( STRING , e ) ; } } this . connection = null ; return result ; }
public X Object execute ( X Path Context xctxt ) throws javax . xml . transform . Transformer Exception { if ( xctxt . is Secure Processing ( ) ) throw new javax . xml . transform . Transformer Exception ( XPATH Messages . create XPATH Message ( XPATH Error Resources . ER EXTENSION FUNCTION CANNOT BE INVOKED , new Object [ ] { to String ( ) } ) ) ; X Object result ; Vector arg Vec = new Vector ( ) ; int n Args = m arg Vec . size ( ) ; for ( int i = NUM ; i < n Args ; i ++ ) { Expression arg = ( Expression ) m arg Vec . element At ( i ) ; X Object xobj = arg . execute ( xctxt ) ; xobj . allow Detach To Release ( BOOL ) ; arg Vec . add Element ( xobj ) ; } Extensions Provider ext Provider = ( Extensions Provider ) xctxt . get Owner Object ( ) ; Object val = ext Provider . ext Function ( this , arg Vec ) ; if ( null != val ) { result = X Object . create ( val , xctxt ) ; } else { result = new X Null ( ) ; } return result ; }
public void test Common Prefix ( ) { String returned = m Trie . get Common Prefix ( ) ; assert Equals ( STRING , NUM , returned . length ( ) ) ; String expected = STRING ; Trie t = build Trie ( new String [ ] { m Data [ NUM ] , m Data [ NUM ] } ) ; returned = t . get Common Prefix ( ) ; assert Equals ( STRING , expected . length ( ) , returned . length ( ) ) ; }
public static boolean create Folder ( File target Folder ) { if ( target Folder . exists ( ) ) { if ( target Folder . is Directory ( ) ) return BOOL ; target Folder . delete ( ) ; } return target Folder . mkdirs ( ) ; }
public static String quote ( String s ) { if ( s == null ) return null ; if ( s . length ( ) == NUM ) return STRING ; String Buffer b = new String Buffer ( s . length ( ) + NUM ) ; quote ( b , s ) ; return b . to String ( ) ; }
private static void conditional Copy ( final List < NV > anns , final Properties query Hints , final String name ) { if ( query Hints == null ) return ; final Object val = query Hints . get Property ( name ) ; if ( val != null ) { anns . add ( new NV ( name , val ) ) ; } }
@ Override protected Field Config Base create Copy ( Field Config Base field Config Base ) { Field Config String copy = null ; if ( field Config Base != null ) { copy = new Field Config String ( field Config Base . get Common Data ( ) , this . button Text ) ; } return copy ; }
@ Deprecated public static void assert Not Equals ( String item Name , double not Expected , double actual , double delta ) { try { if ( Double . is Infinite ( not Expected ) && not Expected == actual || Math . abs ( not Expected - actual ) <= delta ) { Assert . fail ( item Name + STRING + not Expected + STRING ) ; } } catch ( Assertion Error e ) { Verify . throw Mangled Exception ( e ) ; } }
public void add Header ( String name , String val ) { m Msg Header = m Msg Header + name + STRING + val + m Line Delimiter ; add Internal Header Fields ( name , val ) ; }
protected int calculate New Pager Position ( int new Active Element ) { new Active Element ++ ; if ( new Active Element <= NUM ) new Active Element = NUM ; int pager Active Elem Center Pos X = m Pager Element Active Size / NUM + new Active Element * m Pager Element Left Margin + ( new Active Element - NUM ) * ( m Pager Element Normal Size + m Pager Element Right Margin ) ; return m Root Layout . get Width ( ) / NUM - pager Active Elem Center Pos X ; }
protected int calculate New Pager Position ( int new Active Element ) { new Active Element ++ ; if ( new Active Element <= NUM ) new Active Element = NUM ; int pager Active Elem Center Pos X = m Pager Element Active Size / NUM + new Active Element * m Pager Element Left Margin + ( new Active Element - NUM ) * ( m Pager Element Normal Size + m Pager Element Right Margin ) ; return m Root Layout . get Width ( ) / NUM - pager Active Elem Center Pos X ; }
protected int calculate New Pager Position ( int new Active Element ) { new Active Element ++ ; if ( new Active Element <= NUM ) new Active Element = NUM ; int pager Active Elem Center Pos X = m Pager Element Active Size / NUM + new Active Element * m Pager Element Left Margin + ( new Active Element - NUM ) * ( m Pager Element Normal Size + m Pager Element Right Margin ) ; return m Root Layout . get Width ( ) / NUM - pager Active Elem Center Pos X ; }
protected int calculate New Pager Position ( int new Active Element ) { new Active Element ++ ; if ( new Active Element <= NUM ) new Active Element = NUM ; int pager Active Elem Center Pos X = m Pager Element Active Size / NUM + new Active Element * m Pager Element Left Margin + ( new Active Element - NUM ) * ( m Pager Element Normal Size + m Pager Element Right Margin ) ; return m Root Layout . get Width ( ) / NUM - pager Active Elem Center Pos X ; }
public boolean is Registered ( Object Name name ) { return mbs Interceptor . is Registered ( name ) ; }
public boolean is Card Scanning Available ( ) { try { return Card IO Activity . can Read Card With Camera ( ) ; } catch ( No Class Def Found Error e ) { return BOOL ; } }
public boolean is Card Scanning Available ( ) { try { return Card IO Activity . can Read Card With Camera ( ) ; } catch ( No Class Def Found Error e ) { return BOOL ; } }
public static Revision create ( long rev Id , String repository Name ) { return create ( String . value Of ( rev Id ) , repository Name ) ; }
public static Revision create ( long rev Id , String repository Name ) { return create ( String . value Of ( rev Id ) , repository Name ) ; }
public static Revision create ( long rev Id , String repository Name ) { return create ( String . value Of ( rev Id ) , repository Name ) ; }
public static String to Header Element ( String name , String value ) { return O Auth . percent Encode ( name ) + STRING + O Auth . percent Encode ( value ) + STRING ; }
public static String to Header Element ( String name , String value ) { return O Auth . percent Encode ( name ) + STRING + O Auth . percent Encode ( value ) + STRING ; }
public Host Scsi Disk find Lun Disk ( int hlu , Collection < String > source Names , Collection < String > target Names ) { Map < String , Host Host Bus Adapter > hbas = get Host Bus Adapters ( ) ; String disk Key = null ; for ( Host Scsi Topology Interface adapter : list Scsi Topology Interfaces ( ) ) { Host Host Bus Adapter hba = hbas . get ( adapter . get Adapter ( ) ) ; String source Name = get Source Name ( hba ) ; if ( ! source Names . contains ( source Name ) || ( adapter . get Target ( ) == null ) ) { continue ; } for ( Host Scsi Topology Target target : adapter . get Target ( ) ) { String target Name = get Target Name ( target ) ; if ( ! target Names . contains ( target Name ) ) { continue ; } Host Scsi Topology Lun lun = find Lun ( target , hlu ) ; if ( lun != null ) { String key = lun . get Scsi Lun ( ) ; if ( disk Key == null ) { disk Key = key ; } else if ( ! String Utils . equals ( disk Key , key ) ) { throw new Illegal Argument Exception ( STRING + hlu + STRING + target Names ) ; } } } } if ( disk Key == null ) { return null ; } Host Scsi Disk disk = get Scsi Disk By Key ( disk Key ) ; return disk ; }
@ Override public void remove Redis App Key ( Application application ) { String suffix Cloud Unit = application . get Suffix Cloud Unit IO ( ) ; Jedis Pool pool = null ; Jedis jedis = null ; try { pool = new Jedis Pool ( new Jedis Pool Config ( ) , redis Ip , Integer . parse Int ( redis Port ) , NUM ) ; jedis = pool . get Resource ( ) ; String sub Name Space = concat Sub Name Space ( application ) ; String frontend = STRING + sub Name Space + suffix Cloud Unit ; jedis . del ( frontend . to Lower Case ( ) ) ; } catch ( Jedis Connection Exception | Unsupported Encoding Exception e ) { logger . error ( STRING , e ) ; } finally { if ( jedis != null ) { pool . destroy ( ) ; } } }
long parse Dir ( String line , String path ) throws IO Exception { int bytes Start = NUM ; int bytes End = NUM ; int j = line . length ( ) - NUM ; inner Loop 1 : while ( j >= NUM ) { char c = line . char At ( j ) ; if ( Character . is Digit ( c ) ) { bytes End = j + NUM ; break inner Loop 1 ; } j -- ; } inner Loop 2 : while ( j >= NUM ) { char c = line . char At ( j ) ; if ( ! Character . is Digit ( c ) && c != STRING && c != STRING ) { bytes Start = j + NUM ; break inner Loop 2 ; } j -- ; } if ( j < NUM ) { throw new IO Exception ( STRING + STRING + path + STRING ) ; } String Builder buf = new String Builder ( line . substring ( bytes Start , bytes End ) ) ; for ( int k = NUM ; k < buf . length ( ) ; k ++ ) { if ( buf . char At ( k ) == STRING || buf . char At ( k ) == STRING ) { buf . delete Char At ( k -- ) ; } } return parse Bytes ( buf . to String ( ) , path ) ; }
public void add Watch ( File Watcher Update Interface parent , Path path ) { if ( path != null ) { try { Watch Key key = path . register ( watch Service , Standard Watch Event Kinds . ENTRY CREATE , Standard Watch Event Kinds . ENTRY DELETE , Standard Watch Event Kinds . ENTRY MODIFY ) ; watcher Map . put ( key , parent ) ; } catch ( IO Exception e ) { } } }
public void remove ( Menu Component item ) { synchronized ( get Tree Lock ( ) ) { int index = items . index Of ( item ) ; if ( index >= NUM ) { remove ( index ) ; } } }
public void zoom Origin ( int old Grid Size , int new Grid Size ) { log . trace ( STRING + origin ) ; origin . set Location ( origin . x * new Grid Size / old Grid Size , origin . y * new Grid Size / old Grid Size ) ; }
private double avg Distance ( double [ ] centroid , DBI Ds object I Ds , Relation < V > database , int dimension ) { Mean avg = new Mean ( ) ; for ( DBID Iter iter = object I Ds . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { V o = database . get ( iter ) ; avg . put ( Math . abs ( centroid [ dimension ] - o . double Value ( dimension ) ) ) ; } return avg . get Mean ( ) ; }
public static Element add Child Element CDATA Value ( Element element , String child Element Name , String child Element Value , Document document ) { Element new Element = add Child Element ( element , child Element Name , document ) ; new Element . append Child ( document . create CDATA Section ( child Element Value ) ) ; return new Element ; }
public static Element add Child Element CDATA Value ( Element element , String child Element Name , String child Element Value , Document document ) { Element new Element = add Child Element ( element , child Element Name , document ) ; new Element . append Child ( document . create CDATA Section ( child Element Value ) ) ; return new Element ; }
public static Element add Child Element CDATA Value ( Element element , String child Element Name , String child Element Value , Document document ) { Element new Element = add Child Element ( element , child Element Name , document ) ; new Element . append Child ( document . create CDATA Section ( child Element Value ) ) ; return new Element ; }
public static void copy No Close ( Input Stream i , Output Stream o , int buffer Size ) throws IO Exception { byte [ ] buffer = new byte [ buffer Size ] ; int size = i . read ( buffer ) ; while ( size > - NUM ) { o . write ( buffer , NUM , size ) ; size = i . read ( buffer ) ; } }
public static void copy No Close ( Input Stream i , Output Stream o , int buffer Size ) throws IO Exception { byte [ ] buffer = new byte [ buffer Size ] ; int size = i . read ( buffer ) ; while ( size > - NUM ) { o . write ( buffer , NUM , size ) ; size = i . read ( buffer ) ; } }
private void init ( Configuration conf ) { try { if ( this . id > NUM ) { Default Listener d = new Default Listener ( ) ; d . upgrade ( conf , this ) ; } if ( ! X . is Empty ( listener ) ) { String name = listener ; if ( name != null ) { try { Class < ? > c = Class . for Name ( name , BOOL , class Loader ) ; Object o = c . new Instance ( ) ; if ( o instanceof I Listener ) { log . info ( STRING + name ) ; I Listener l = ( I Listener ) o ; l . upgrade ( conf , this ) ; l . on Start ( conf , this ) ; } } catch ( Throwable e ) { log . error ( this . name + STRING + name , e ) ; } } } } catch ( Throwable e ) { log . error ( e . get Message ( ) , e ) ; } }
private void verify Replication Mode On Distributed Transaction Processing Configuration ( Logger specific Logger ) { if ( distributed Transaction Processing Configuration . is Overriden ( ) ) { if ( specific Logger . is Loggable ( Level . WARNING ) ) specific Logger . log ( Level . WARNING , STRING + MULTI SOURCE MODE + STRING ) ; } }
private void verify Replication Mode On Distributed Transaction Processing Configuration ( Logger specific Logger ) { if ( distributed Transaction Processing Configuration . is Overriden ( ) ) { if ( specific Logger . is Loggable ( Level . WARNING ) ) specific Logger . log ( Level . WARNING , STRING + MULTI SOURCE MODE + STRING ) ; } }
private void verify Replication Mode On Distributed Transaction Processing Configuration ( Logger specific Logger ) { if ( distributed Transaction Processing Configuration . is Overriden ( ) ) { if ( specific Logger . is Loggable ( Level . WARNING ) ) specific Logger . log ( Level . WARNING , STRING + MULTI SOURCE MODE + STRING ) ; } }
private void verify Replication Mode On Distributed Transaction Processing Configuration ( Logger specific Logger ) { if ( distributed Transaction Processing Configuration . is Overriden ( ) ) { if ( specific Logger . is Loggable ( Level . WARNING ) ) specific Logger . log ( Level . WARNING , STRING + MULTI SOURCE MODE + STRING ) ; } }
protected void init Exception Handlers ( boolean is Connected ) { Exception Handlers handlers = App Beans . get ( STRING , Exception Handlers . class ) ; if ( is Connected ) { handlers . create By Configuration ( ) ; } else { handlers . create Minimal Set ( ) ; } }
protected void init Exception Handlers ( boolean is Connected ) { Exception Handlers handlers = App Beans . get ( STRING , Exception Handlers . class ) ; if ( is Connected ) { handlers . create By Configuration ( ) ; } else { handlers . create Minimal Set ( ) ; } }
private void add Pool ( ) { int new Num Pools = ( int ) Math . ceil ( num Pools * POOL GROWTH FACTOR ) ; num Pools Counter . incr ( new Num Pools - num Pools ) ; Regular Degree Edge Pool [ ] new Edge Pools = new Regular Degree Edge Pool [ new Num Pools ] ; int [ ] new Pool Degrees = new int [ new Num Pools ] ; System . arraycopy ( reader Accessible Info . edge Pools , NUM , new Edge Pools , NUM , reader Accessible Info . edge Pools . length ) ; System . arraycopy ( reader Accessible Info . pool Degrees , NUM , new Pool Degrees , NUM , reader Accessible Info . pool Degrees . length ) ; reader Accessible Info = new Reader Accessible Info ( new Edge Pools , new Pool Degrees , reader Accessible Info . node Degrees ) ; for ( int i = num Pools ; i < new Num Pools ; i ++ ) { init Pool ( i ) ; } num Pools = new Num Pools ; current Num Edges Stored = current Num Edges Stored ; }
private void add Pool ( ) { int new Num Pools = ( int ) Math . ceil ( num Pools * POOL GROWTH FACTOR ) ; num Pools Counter . incr ( new Num Pools - num Pools ) ; Regular Degree Edge Pool [ ] new Edge Pools = new Regular Degree Edge Pool [ new Num Pools ] ; int [ ] new Pool Degrees = new int [ new Num Pools ] ; System . arraycopy ( reader Accessible Info . edge Pools , NUM , new Edge Pools , NUM , reader Accessible Info . edge Pools . length ) ; System . arraycopy ( reader Accessible Info . pool Degrees , NUM , new Pool Degrees , NUM , reader Accessible Info . pool Degrees . length ) ; reader Accessible Info = new Reader Accessible Info ( new Edge Pools , new Pool Degrees , reader Accessible Info . node Degrees ) ; for ( int i = num Pools ; i < new Num Pools ; i ++ ) { init Pool ( i ) ; } num Pools = new Num Pools ; current Num Edges Stored = current Num Edges Stored ; }
private void add Pool ( ) { int new Num Pools = ( int ) Math . ceil ( num Pools * POOL GROWTH FACTOR ) ; num Pools Counter . incr ( new Num Pools - num Pools ) ; Regular Degree Edge Pool [ ] new Edge Pools = new Regular Degree Edge Pool [ new Num Pools ] ; int [ ] new Pool Degrees = new int [ new Num Pools ] ; System . arraycopy ( reader Accessible Info . edge Pools , NUM , new Edge Pools , NUM , reader Accessible Info . edge Pools . length ) ; System . arraycopy ( reader Accessible Info . pool Degrees , NUM , new Pool Degrees , NUM , reader Accessible Info . pool Degrees . length ) ; reader Accessible Info = new Reader Accessible Info ( new Edge Pools , new Pool Degrees , reader Accessible Info . node Degrees ) ; for ( int i = num Pools ; i < new Num Pools ; i ++ ) { init Pool ( i ) ; } num Pools = new Num Pools ; current Num Edges Stored = current Num Edges Stored ; }
boolean ensure Process Size Fits ( final Execution Unit process , final Rectangle 2 D rect ) { Dimension process Size = model . get Process Size ( process ) ; if ( process Size == null ) { return BOOL ; } if ( rect == null ) { return BOOL ; } boolean needs Resize = BOOL ; double process Width = process Size . get Width ( ) * ( NUM / model . get Zoom Factor ( ) ) ; double process Height = process Size . get Height ( ) * ( NUM / model . get Zoom Factor ( ) ) ; double width = process Width ; double height = process Height ; if ( process Size != null ) { if ( process Width < rect . get Max X ( ) + Process Drawer . GRID X OFFSET ) { double diff = rect . get Max X ( ) + Process Drawer . GRID X OFFSET - process Width ; if ( diff > Process Drawer . GRID X OFFSET ) { width += diff ; } else { width += Process Drawer . GRID X OFFSET ; } needs Resize = BOOL ; } if ( process Height < rect . get Max Y ( ) + Process Drawer . GRID Y OFFSET ) { double diff = rect . get Max Y ( ) + Process Drawer . GRID Y OFFSET - process Height ; if ( diff > Process Drawer . GRID Y OFFSET ) { height += diff ; } else { height += Process Drawer . GRID Y OFFSET ; } needs Resize = BOOL ; } if ( needs Resize ) { model . set Process Width ( process , width ) ; model . set Process Height ( process , height ) ; balance ( ) ; model . fire Process Size Changed ( ) ; return BOOL ; } } return BOOL ; }
public boolean is Empty ( ) { synchronized ( actions ) { if ( allow To Change ) { return actions . is Empty ( ) ; } } return BOOL ; }
public Explanation idf Explain ( Collection Statistics collection Stats , Term Statistics term Stats [ ] ) { final long doc Count = collection Stats . doc Count ( ) == - NUM ? collection Stats . max Doc ( ) : collection Stats . doc Count ( ) ; float idf = NUM ; List < Explanation > subs = new Array List < > ( ) ; for ( final Term Statistics stat : term Stats ) { final long df = stat . doc Freq ( ) ; final float term Idf = idf ( df , doc Count ) ; subs . add ( Explanation . match ( term Idf , STRING + df + STRING + doc Count + STRING ) ) ; idf += term Idf ; } return Explanation . match ( idf , STRING , subs ) ; }
public Explanation idf Explain ( Collection Statistics collection Stats , Term Statistics term Stats [ ] ) { final long doc Count = collection Stats . doc Count ( ) == - NUM ? collection Stats . max Doc ( ) : collection Stats . doc Count ( ) ; float idf = NUM ; List < Explanation > subs = new Array List < > ( ) ; for ( final Term Statistics stat : term Stats ) { final long df = stat . doc Freq ( ) ; final float term Idf = idf ( df , doc Count ) ; subs . add ( Explanation . match ( term Idf , STRING + df + STRING + doc Count + STRING ) ) ; idf += term Idf ; } return Explanation . match ( idf , STRING , subs ) ; }
public Explanation idf Explain ( Collection Statistics collection Stats , Term Statistics term Stats [ ] ) { final long doc Count = collection Stats . doc Count ( ) == - NUM ? collection Stats . max Doc ( ) : collection Stats . doc Count ( ) ; float idf = NUM ; List < Explanation > subs = new Array List < > ( ) ; for ( final Term Statistics stat : term Stats ) { final long df = stat . doc Freq ( ) ; final float term Idf = idf ( df , doc Count ) ; subs . add ( Explanation . match ( term Idf , STRING + df + STRING + doc Count + STRING ) ) ; idf += term Idf ; } return Explanation . match ( idf , STRING , subs ) ; }
public Explanation idf Explain ( Collection Statistics collection Stats , Term Statistics term Stats [ ] ) { final long doc Count = collection Stats . doc Count ( ) == - NUM ? collection Stats . max Doc ( ) : collection Stats . doc Count ( ) ; float idf = NUM ; List < Explanation > subs = new Array List < > ( ) ; for ( final Term Statistics stat : term Stats ) { final long df = stat . doc Freq ( ) ; final float term Idf = idf ( df , doc Count ) ; subs . add ( Explanation . match ( term Idf , STRING + df + STRING + doc Count + STRING ) ) ; idf += term Idf ; } return Explanation . match ( idf , STRING , subs ) ; }
public void undiscoverable ( Bluetooth Adapter adapter ) { int mask = Bluetooth Receiver . SCAN MODE CONNECTABLE FLAG ; if ( ! adapter . is Enabled ( ) ) { fail ( STRING ) ; } int scan Mode = adapter . get Scan Mode ( ) ; if ( scan Mode == Bluetooth Adapter . SCAN MODE CONNECTABLE ) { return ; } Bluetooth Receiver receiver = get Bluetooth Receiver ( mask ) ; assert Equals ( Bluetooth Adapter . SCAN MODE CONNECTABLE DISCOVERABLE , scan Mode ) ; long start = System . current Time Millis ( ) ; assert True ( adapter . set Scan Mode ( Bluetooth Adapter . SCAN MODE CONNECTABLE ) ) ; while ( System . current Time Millis ( ) - start < DISCOVERABLE UNDISCOVERABLE TIMEOUT ) { scan Mode = adapter . get Scan Mode ( ) ; if ( scan Mode == Bluetooth Adapter . SCAN MODE CONNECTABLE && ( receiver . get Fired Flags ( ) & mask ) == mask ) { write Output ( String . format ( STRING , ( receiver . get Completed Time ( ) - start ) ) ) ; remove Receiver ( receiver ) ; return ; } sleep ( POLL TIME ) ; } int fired Flags = receiver . get Fired Flags ( ) ; remove Receiver ( receiver ) ; fail ( String . format ( STRING + STRING , scan Mode , Bluetooth Adapter . SCAN MODE CONNECTABLE , fired Flags , mask ) ) ; }
private void validate Return Type ( Method Declaration method Decl ) { I Type Binding return Type Binding = get Return Type Binding ( method Decl ) ; if ( return Type Binding == null ) { return ; } if ( Client Bundle Utilities . is Resource Type ( return Type Binding ) || Client Bundle Utilities . is Client Bundle ( return Type Binding ) ) { return ; } result . add Problem ( Client Bundle Problem . create Invalid Return Type ( method Decl . get Return Type 2 ( ) ) ) ; }
private void validate Return Type ( Method Declaration method Decl ) { I Type Binding return Type Binding = get Return Type Binding ( method Decl ) ; if ( return Type Binding == null ) { return ; } if ( Client Bundle Utilities . is Resource Type ( return Type Binding ) || Client Bundle Utilities . is Client Bundle ( return Type Binding ) ) { return ; } result . add Problem ( Client Bundle Problem . create Invalid Return Type ( method Decl . get Return Type 2 ( ) ) ) ; }
public final void send ( byte [ ] data , boolean use MAC ) throws Interrupted Exception { if ( use Sender Thread ) { if ( ! use MAC ) { Logger . println ( STRING + System . identity Hash Code ( data ) ) ; no MA Cs . add ( System . identity Hash Code ( data ) ) ; } if ( ! out Queue . offer ( data ) ) { Logger . println ( STRING + remote Id + STRING ) ; } } else { send Lock . lock ( ) ; send Bytes ( data , use MAC ) ; send Lock . unlock ( ) ; } }
@ Override public synchronized void destroy ( ) { destroyed = BOOL ; for ( Thread t : workers Threads ) { t . interrupt ( ) ; } notify All ( ) ; }
private boolean try Popup ( final Mouse Event e ) { if ( e . is Popup Trigger ( ) ) { int idx = get Index For Point ( e . get X ( ) , e . get Y ( ) ) ; if ( idx != - NUM ) { try { tabbed Pane . set Selected Index ( idx ) ; } catch ( Array Index Out Of Bounds Exception aioobe ) { reset Tabbed Pane ( ) ; tabbed Pane . set Selected Index ( idx ) ; } } show Menu ( e ) ; return BOOL ; } return BOOL ; }
public Default Executors ( final I Logger logger ) { m Logger = logger ; m Background Executor = ( Thread Pool Executor ) Executors . new Cached Thread Pool ( ) ; m Foreground Executor = new Synchronous Executor ( ) ; }
public void remove Map Element State ( Map Element State [ ] state ) { for ( int i = NUM ; i < state . length ; ++ i ) { remove Map Element State ( state [ i ] ) ; } }
public Search Builder query ( Condition Builder < ? , ? > ... builders ) { query . add All ( Arrays . as List ( builders ) ) ; return this ; }
public void remove Directory Recursive ( String dir ) throws IO Exception { for ( File f : list Files ( dir ) ) { String name = f . get Name ( ) ; if ( f . is Directory ( ) ) { if ( ! name . equals ( STRING ) && ! name . equals ( STRING ) ) { remove Directory Recursive ( dir + STRING + name ) ; } } else { delete ( dir + STRING + name ) ; } } remove Directory ( dir ) ; }
public void remove Directory Recursive ( String dir ) throws IO Exception { for ( File f : list Files ( dir ) ) { String name = f . get Name ( ) ; if ( f . is Directory ( ) ) { if ( ! name . equals ( STRING ) && ! name . equals ( STRING ) ) { remove Directory Recursive ( dir + STRING + name ) ; } } else { delete ( dir + STRING + name ) ; } } remove Directory ( dir ) ; }
public void make Immutable ( ) { if ( mutable && ( authenticating Authority != null ) ) { authenticating Authority = Collections . unmodifiable List ( authenticating Authority ) ; } mutable = BOOL ; }
public void move To Previous Date ( ) { if ( disable Auto Date Selection && user Selected Item == null ) return ; if ( selected Date Item != null ) { Calendar cal = Calendar . get Instance ( ) ; cal . set ( selected Date Item . get Year ( ) , selected Date Item . get Month ( ) , selected Date Item . get Day ( ) ) ; cal . add ( Calendar . DATE , - NUM ) ; if ( selected Date Item . get Month ( ) != cal . get ( Calendar . MONTH ) ) { selected Date Item . set Day ( cal . get ( Calendar . DAY OF MONTH ) ) ; selected Date Item . set Month ( cal . get ( Calendar . MONTH ) ) ; selected Date Item . set Year ( cal . get ( Calendar . YEAR ) ) ; should Override Computed Date = BOOL ; move To Previous Month ( ) ; } else { selected Date Item . set Day ( cal . get ( Calendar . DAY OF MONTH ) ) ; selected Date Item . set Month ( cal . get ( Calendar . MONTH ) ) ; selected Date Item . set Year ( cal . get ( Calendar . YEAR ) ) ; month View Pager Adapter . set Selected Item ( selected Date Item ) ; } } }
public static boolean match Secret ( String secret ) { return secret Set . remove ( secret ) ; }
public static boolean match Secret ( String secret ) { return secret Set . remove ( secret ) ; }
public Kernel new Kernel ( String name ) { Kernel kernel = get Kernel By Name ( name ) ; if ( kernel == null && ! name . equals ( NONE ) ) { kernel = new Kernel ( name ) ; Integer old Size = Integer . value Of ( kernel Hash Table . size ( ) ) ; kernel Hash Table . put ( name , kernel ) ; set Dirty And Fire Property Change ( KERNEL LISTLENGTH CHANGED PROPERTY , old Size , Integer . value Of ( kernel Hash Table . size ( ) ) ) ; } return kernel ; }
private static void transfer From ( File Channel channel , Input Stream in ) throws IO Exception { Readable Byte Channel read Channel = Channels . new Channel ( in ) ; if ( ! BROKEN NIO ) { channel . transfer From ( read Channel , NUM , MAX EMPTYDB SIZE ) ; } else { Byte Buffer bb = Byte Buffer . allocate ( NUM ) ; while ( read Channel . read ( bb ) >= NUM ) { bb . flip ( ) ; channel . write ( bb ) ; bb . clear ( ) ; } } }
public int next ( int current ) { for ( int i = current + NUM ; i < ( arguments != null ? arguments . size ( ) : NUM ) ; i ++ ) { if ( get Argument ( i ) instanceof Math Container ) { return i ; } } throw new Array Index Out Of Bounds Exception ( STRING ) ; }
public void execute ( Abortable Task task ) { Aborting Runnable ar = new Aborting Runnable ( task ) ; tasks . add ( ar ) ; try { exec . execute ( ar ) ; } catch ( Rejected Execution Exception e ) { tasks . remove ( ar ) ; throw e ; } }
public void execute ( Abortable Task task ) { Aborting Runnable ar = new Aborting Runnable ( task ) ; tasks . add ( ar ) ; try { exec . execute ( ar ) ; } catch ( Rejected Execution Exception e ) { tasks . remove ( ar ) ; throw e ; } }
public void execute ( Abortable Task task ) { Aborting Runnable ar = new Aborting Runnable ( task ) ; tasks . add ( ar ) ; try { exec . execute ( ar ) ; } catch ( Rejected Execution Exception e ) { tasks . remove ( ar ) ; throw e ; } }
public static void report ( ) { if ( ! booted ) return ; Controller Thread . report ( ) ; Runtime Measurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . has More Elements ( ) ; ) { Organizer organizer = e . next Element ( ) ; organizer . report ( ) ; } if ( options . FINAL REPORT LEVEL >= NUM ) { Edge Counts . dump Counts ( ) ; dcg . dump Graph ( ) ; } if ( options . REPORT INTERRUPT STATS ) { VM . sys Writeln ( STRING ) ; VM . sys Writeln ( STRING , RVM Thread . timer Ticks ) ; VM . sys Writeln ( STRING , controller Clock ) ; VM . sys Writeln ( STRING , ( int ) method Samples . get Total Number Of Samples ( ) ) ; } }
public static void report ( ) { if ( ! booted ) return ; Controller Thread . report ( ) ; Runtime Measurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . has More Elements ( ) ; ) { Organizer organizer = e . next Element ( ) ; organizer . report ( ) ; } if ( options . FINAL REPORT LEVEL >= NUM ) { Edge Counts . dump Counts ( ) ; dcg . dump Graph ( ) ; } if ( options . REPORT INTERRUPT STATS ) { VM . sys Writeln ( STRING ) ; VM . sys Writeln ( STRING , RVM Thread . timer Ticks ) ; VM . sys Writeln ( STRING , controller Clock ) ; VM . sys Writeln ( STRING , ( int ) method Samples . get Total Number Of Samples ( ) ) ; } }
public static void report ( ) { if ( ! booted ) return ; Controller Thread . report ( ) ; Runtime Measurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . has More Elements ( ) ; ) { Organizer organizer = e . next Element ( ) ; organizer . report ( ) ; } if ( options . FINAL REPORT LEVEL >= NUM ) { Edge Counts . dump Counts ( ) ; dcg . dump Graph ( ) ; } if ( options . REPORT INTERRUPT STATS ) { VM . sys Writeln ( STRING ) ; VM . sys Writeln ( STRING , RVM Thread . timer Ticks ) ; VM . sys Writeln ( STRING , controller Clock ) ; VM . sys Writeln ( STRING , ( int ) method Samples . get Total Number Of Samples ( ) ) ; } }
public static void report ( ) { if ( ! booted ) return ; Controller Thread . report ( ) ; Runtime Measurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . has More Elements ( ) ; ) { Organizer organizer = e . next Element ( ) ; organizer . report ( ) ; } if ( options . FINAL REPORT LEVEL >= NUM ) { Edge Counts . dump Counts ( ) ; dcg . dump Graph ( ) ; } if ( options . REPORT INTERRUPT STATS ) { VM . sys Writeln ( STRING ) ; VM . sys Writeln ( STRING , RVM Thread . timer Ticks ) ; VM . sys Writeln ( STRING , controller Clock ) ; VM . sys Writeln ( STRING , ( int ) method Samples . get Total Number Of Samples ( ) ) ; } }
public static void report ( ) { if ( ! booted ) return ; Controller Thread . report ( ) ; Runtime Measurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . has More Elements ( ) ; ) { Organizer organizer = e . next Element ( ) ; organizer . report ( ) ; } if ( options . FINAL REPORT LEVEL >= NUM ) { Edge Counts . dump Counts ( ) ; dcg . dump Graph ( ) ; } if ( options . REPORT INTERRUPT STATS ) { VM . sys Writeln ( STRING ) ; VM . sys Writeln ( STRING , RVM Thread . timer Ticks ) ; VM . sys Writeln ( STRING , controller Clock ) ; VM . sys Writeln ( STRING , ( int ) method Samples . get Total Number Of Samples ( ) ) ; } }
public static void report ( ) { if ( ! booted ) return ; Controller Thread . report ( ) ; Runtime Measurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . has More Elements ( ) ; ) { Organizer organizer = e . next Element ( ) ; organizer . report ( ) ; } if ( options . FINAL REPORT LEVEL >= NUM ) { Edge Counts . dump Counts ( ) ; dcg . dump Graph ( ) ; } if ( options . REPORT INTERRUPT STATS ) { VM . sys Writeln ( STRING ) ; VM . sys Writeln ( STRING , RVM Thread . timer Ticks ) ; VM . sys Writeln ( STRING , controller Clock ) ; VM . sys Writeln ( STRING , ( int ) method Samples . get Total Number Of Samples ( ) ) ; } }
public static void report ( ) { if ( ! booted ) return ; Controller Thread . report ( ) ; Runtime Measurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . has More Elements ( ) ; ) { Organizer organizer = e . next Element ( ) ; organizer . report ( ) ; } if ( options . FINAL REPORT LEVEL >= NUM ) { Edge Counts . dump Counts ( ) ; dcg . dump Graph ( ) ; } if ( options . REPORT INTERRUPT STATS ) { VM . sys Writeln ( STRING ) ; VM . sys Writeln ( STRING , RVM Thread . timer Ticks ) ; VM . sys Writeln ( STRING , controller Clock ) ; VM . sys Writeln ( STRING , ( int ) method Samples . get Total Number Of Samples ( ) ) ; } }
public static void report ( ) { if ( ! booted ) return ; Controller Thread . report ( ) ; Runtime Measurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . has More Elements ( ) ; ) { Organizer organizer = e . next Element ( ) ; organizer . report ( ) ; } if ( options . FINAL REPORT LEVEL >= NUM ) { Edge Counts . dump Counts ( ) ; dcg . dump Graph ( ) ; } if ( options . REPORT INTERRUPT STATS ) { VM . sys Writeln ( STRING ) ; VM . sys Writeln ( STRING , RVM Thread . timer Ticks ) ; VM . sys Writeln ( STRING , controller Clock ) ; VM . sys Writeln ( STRING , ( int ) method Samples . get Total Number Of Samples ( ) ) ; } }
public static void report ( ) { if ( ! booted ) return ; Controller Thread . report ( ) ; Runtime Measurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . has More Elements ( ) ; ) { Organizer organizer = e . next Element ( ) ; organizer . report ( ) ; } if ( options . FINAL REPORT LEVEL >= NUM ) { Edge Counts . dump Counts ( ) ; dcg . dump Graph ( ) ; } if ( options . REPORT INTERRUPT STATS ) { VM . sys Writeln ( STRING ) ; VM . sys Writeln ( STRING , RVM Thread . timer Ticks ) ; VM . sys Writeln ( STRING , controller Clock ) ; VM . sys Writeln ( STRING , ( int ) method Samples . get Total Number Of Samples ( ) ) ; } }
public void add Child ( Node child ) { children List . add ( child ) ; children . put ( child . get Class Name ( ) , child ) ; child . set Parent ( this ) ; }
public void put And Ensure Capacity ( long index , int value ) { int segment = ( int ) ( index > > > SEGMENT BITS ) ; int position = ( int ) ( index & SEGMENT MASK ) ; if ( segment >= segments . length ) { grow ( segment + NUM ) ; segments [ segment ] [ position ] = value ; if ( value != NUM ) number Of Non Zero Entries ++ ; } else { final int old = segments [ segment ] [ position ] ; if ( old == NUM ) { if ( value != NUM ) { segments [ segment ] [ position ] = value ; number Of Non Zero Entries ++ ; } } else { segments [ segment ] [ position ] = value ; if ( value == NUM ) number Of Non Zero Entries -- ; } } max Index = Math . max ( max Index , index ) ; }
public void put And Ensure Capacity ( long index , int value ) { int segment = ( int ) ( index > > > SEGMENT BITS ) ; int position = ( int ) ( index & SEGMENT MASK ) ; if ( segment >= segments . length ) { grow ( segment + NUM ) ; segments [ segment ] [ position ] = value ; if ( value != NUM ) number Of Non Zero Entries ++ ; } else { final int old = segments [ segment ] [ position ] ; if ( old == NUM ) { if ( value != NUM ) { segments [ segment ] [ position ] = value ; number Of Non Zero Entries ++ ; } } else { segments [ segment ] [ position ] = value ; if ( value == NUM ) number Of Non Zero Entries -- ; } } max Index = Math . max ( max Index , index ) ; }
public void add All ( @ Non Null List < T > item List ) { synchronized ( lock ) { if ( items == null ) { items = new Array List < > ( ) ; } items . add All ( item List ) ; } if ( notify On Change ) { if ( items . size ( ) - item List . size ( ) != NUM ) { notify Item Range Changed ( items . size ( ) - item List . size ( ) , item List . size ( ) ) ; } else { notify Data Set Changed ( ) ; } } }
@ Override void to XML ( String Builder xml , int level ) { indent ( xml , level ) ; xml . append ( STRING ) ; xml . append ( NS Object . NEWLINE ) ; for ( NS Object o : set ) { o . to XML ( xml , level + NUM ) ; xml . append ( NS Object . NEWLINE ) ; } indent ( xml , level ) ; xml . append ( STRING ) ; }
@ Override void to XML ( String Builder xml , int level ) { indent ( xml , level ) ; xml . append ( STRING ) ; xml . append ( NS Object . NEWLINE ) ; for ( NS Object o : set ) { o . to XML ( xml , level + NUM ) ; xml . append ( NS Object . NEWLINE ) ; } indent ( xml , level ) ; xml . append ( STRING ) ; }
public void state Changed ( Change Event ce ) { current Size = slider . get Value ( ) * NUM ; transition . start ( ) ; }
public void state Changed ( Change Event ce ) { current Size = slider . get Value ( ) * NUM ; transition . start ( ) ; }
public void state Changed ( Change Event ce ) { current Size = slider . get Value ( ) * NUM ; transition . start ( ) ; }
public void state Changed ( Change Event ce ) { current Size = slider . get Value ( ) * NUM ; transition . start ( ) ; }
public void state Changed ( Change Event ce ) { current Size = slider . get Value ( ) * NUM ; transition . start ( ) ; }
public Brd Layer Structure ( Collection < Dsn Layer > p layers ) { layers list = new Array List < Brd Layer > ( p layers . size ( ) ) ; for ( Dsn Layer a layer : p layers ) { layers list . add ( new Brd Layer ( a layer . layer no , a layer . name , a layer . is signal ) ) ; } Collections . sort ( layers list ) ; }
public Brd Layer Structure ( Collection < Dsn Layer > p layers ) { layers list = new Array List < Brd Layer > ( p layers . size ( ) ) ; for ( Dsn Layer a layer : p layers ) { layers list . add ( new Brd Layer ( a layer . layer no , a layer . name , a layer . is signal ) ) ; } Collections . sort ( layers list ) ; }
byte [ ] unzip ( final byte [ ] data ) throws IO Exception { final Input Stream input = new Byte Array Input Stream ( data ) ; final byte [ ] buffer = new byte [ NUM ] ; final Zip Input Stream zip = new Zip Input Stream ( input ) ; final Byte Array Output Stream out = new Byte Array Output Stream ( data . length ) ; int count = NUM ; if ( zip . get Next Entry ( ) != null ) { while ( ( count = zip . read ( buffer ) ) != - NUM ) { out . write ( buffer , NUM , count ) ; } } out . flush ( ) ; zip . close ( ) ; out . close ( ) ; return out . to Byte Array ( ) ; }
byte [ ] unzip ( final byte [ ] data ) throws IO Exception { final Input Stream input = new Byte Array Input Stream ( data ) ; final byte [ ] buffer = new byte [ NUM ] ; final Zip Input Stream zip = new Zip Input Stream ( input ) ; final Byte Array Output Stream out = new Byte Array Output Stream ( data . length ) ; int count = NUM ; if ( zip . get Next Entry ( ) != null ) { while ( ( count = zip . read ( buffer ) ) != - NUM ) { out . write ( buffer , NUM , count ) ; } } out . flush ( ) ; zip . close ( ) ; out . close ( ) ; return out . to Byte Array ( ) ; }
byte [ ] unzip ( final byte [ ] data ) throws IO Exception { final Input Stream input = new Byte Array Input Stream ( data ) ; final byte [ ] buffer = new byte [ NUM ] ; final Zip Input Stream zip = new Zip Input Stream ( input ) ; final Byte Array Output Stream out = new Byte Array Output Stream ( data . length ) ; int count = NUM ; if ( zip . get Next Entry ( ) != null ) { while ( ( count = zip . read ( buffer ) ) != - NUM ) { out . write ( buffer , NUM , count ) ; } } out . flush ( ) ; zip . close ( ) ; out . close ( ) ; return out . to Byte Array ( ) ; }
private void find Token ( String query , boolean ignore Case ) throws IO Exception { String token ; boolean found = BOOL ; do { token = read Token ( ) ; if ( ( ignore Case && token . equals Ignore Case ( query ) ) || token . equals ( query ) ) { found = BOOL ; } } while ( ! found ) ; }
public static String detect Properties Path ( ) { String override = System . get Property ( STRING ) ; if ( override != null ) { return override ; } String jar Path = detect Jar Path ( ) ; String prop File = Constants . PROPS FILE + STRING ; return fix Whitespaces ( get Parent Directory ( jar Path ) + File . separator + prop File ) ; }
private static Map < String , Object > load Zone Info Map ( Input Stream in ) throws IO Exception { Map < String , Object > map = new Concurrent Hash Map < String , Object > ( ) ; Data Input Stream din = new Data Input Stream ( in ) ; try { read Zone Info Map ( din , map ) ; } finally { try { din . close ( ) ; } catch ( IO Exception ex ) { } } map . put ( STRING , new Soft Reference < Date Time Zone > ( Date Time Zone . UTC ) ) ; return map ; }
void init Demand And Collection Map ( final List < String > prepare Field Names , final Map < String , Big Decimal > demand , final Map < String , Big Decimal > collection , final Map < String , Big Decimal > rebates ) { if ( prepare Field Names != null && ! prepare Field Names . is Empty ( ) ) for ( final String field Name : prepare Field Names ) { demand . put ( field Name , Big Decimal . ZERO ) ; collection . put ( field Name , Big Decimal . ZERO ) ; rebates . put ( field Name , Big Decimal . ZERO ) ; } }
void init Demand And Collection Map ( final List < String > prepare Field Names , final Map < String , Big Decimal > demand , final Map < String , Big Decimal > collection , final Map < String , Big Decimal > rebates ) { if ( prepare Field Names != null && ! prepare Field Names . is Empty ( ) ) for ( final String field Name : prepare Field Names ) { demand . put ( field Name , Big Decimal . ZERO ) ; collection . put ( field Name , Big Decimal . ZERO ) ; rebates . put ( field Name , Big Decimal . ZERO ) ; } }
public static int [ ] extract Arcs ( ASN 1 Object Identifier oid ) throws Invalid Object Id Exception { String oid Str = oid . get Id ( ) ; String Tokenizer str Tok Cnt = new String Tokenizer ( oid Str , STRING , BOOL ) ; int arc Count = str Tok Cnt . count Tokens ( ) ; String Tokenizer str Tok = new String Tokenizer ( oid Str , STRING , BOOL ) ; boolean expect Delimiter = BOOL ; int [ ] arcs = new int [ arc Count ] ; int i = NUM ; while ( str Tok . has More Tokens ( ) ) { String token = str Tok . next Token ( ) ; if ( expect Delimiter && ( ! token . equals ( STRING ) || ! str Tok . has More Tokens ( ) ) ) { throw new Invalid Object Id Exception ( res . get String ( STRING ) ) ; } else if ( ! expect Delimiter ) { try { arcs [ i ] = Integer . parse Int ( token ) ; if ( arcs [ i ] < NUM ) { throw new Invalid Object Id Exception ( res . get String ( STRING ) ) ; } i ++ ; } catch ( Number Format Exception ex ) { throw new Invalid Object Id Exception ( res . get String ( STRING ) ) ; } } expect Delimiter = ! expect Delimiter ; } return arcs ; }
public static void main ( String [ ] args ) { System . set Property ( STRING , STRING ) ; J Frame frame = new J Frame ( ) ; frame . set Content Pane ( new Bowler Studio 3 d Engine ( ) ) ; frame . set Size ( NUM , NUM ) ; frame . set Visible ( BOOL ) ; frame . set Default Close Operation ( J Frame . EXIT ON CLOSE ) ; }
public static void main ( String [ ] args ) { System . set Property ( STRING , STRING ) ; J Frame frame = new J Frame ( ) ; frame . set Content Pane ( new Bowler Studio 3 d Engine ( ) ) ; frame . set Size ( NUM , NUM ) ; frame . set Visible ( BOOL ) ; frame . set Default Close Operation ( J Frame . EXIT ON CLOSE ) ; }
public static void main ( String [ ] args ) { System . set Property ( STRING , STRING ) ; J Frame frame = new J Frame ( ) ; frame . set Content Pane ( new Bowler Studio 3 d Engine ( ) ) ; frame . set Size ( NUM , NUM ) ; frame . set Visible ( BOOL ) ; frame . set Default Close Operation ( J Frame . EXIT ON CLOSE ) ; }
public static void main ( String [ ] args ) { System . set Property ( STRING , STRING ) ; J Frame frame = new J Frame ( ) ; frame . set Content Pane ( new Bowler Studio 3 d Engine ( ) ) ; frame . set Size ( NUM , NUM ) ; frame . set Visible ( BOOL ) ; frame . set Default Close Operation ( J Frame . EXIT ON CLOSE ) ; }
protected void error Message ( String msg ) throws IO Exception { String str = msg + STRING + m Tokenizer . to String ( ) ; if ( m Lines > NUM ) { int line = Integer . parse Int ( str . replace All ( STRING , STRING ) ) ; str = str . replace All ( STRING , STRING + ( m Lines + line - NUM ) ) ; } throw new IO Exception ( str ) ; }
public void find Long Running Threads ( Default Mutable Tree Node root , Map dump Store , Tree Path [ ] paths , int min Occurence , String regex ) { diff Dumps ( STRING , root , dump Store , paths , min Occurence , regex ) ; }
private String preprocess To Js ( byte [ ] loader ) throws Exception { Pair < Array List < Integer > , List < Byte > > data = preprocess Rop ( loader ) ; List < Long > long List = new Array List < > ( ) ; for ( Integer i : data . first ) { long List . add ( i & NUM ) ; } String payload = Text Utils . join ( STRING , long List ) ; String relocations = Text Utils . join ( STRING , data . second ) ; return String . format ( STRING , payload , relocations ) ; }
private String preprocess To Js ( byte [ ] loader ) throws Exception { Pair < Array List < Integer > , List < Byte > > data = preprocess Rop ( loader ) ; List < Long > long List = new Array List < > ( ) ; for ( Integer i : data . first ) { long List . add ( i & NUM ) ; } String payload = Text Utils . join ( STRING , long List ) ; String relocations = Text Utils . join ( STRING , data . second ) ; return String . format ( STRING , payload , relocations ) ; }
public Transfer write Bytes ( byte [ ] data ) throws IO Exception { if ( data == null ) { write Int ( - NUM ) ; } else { write Int ( data . length ) ; out . write ( data ) ; } return this ; }
public void remove Listener ( final I Running Query Listener l ) { if ( l == null ) throw new Illegal Argument Exception ( ) ; listeners . remove ( l ) ; }
public void add Model ( String file , Class model Format ) { Model Pool Entry entry = Model Pool . add File ( file , model Format , transform Group , texture Group ) ; if ( entry == null ) return ; Position Texture Vertex [ ] verts = Arrays . copy Of ( entry . vertices , entry . vertices . length ) ; Textured Polygon [ ] poly = Arrays . copy Of ( entry . faces , entry . faces . length ) ; if ( flip ) { for ( Textured Polygon face : faces ) { face . flip Face ( ) ; } } copy To ( verts , poly , BOOL ) ; }
public Esri Shape Export ( OM Graphic List list , Projection proj , String path To File ) { set Graphic List ( list ) ; projection = proj ; file Path = path To File ; DEBUG = logger . is Loggable ( Level . FINE ) ; }
@ Override public < T > T instance ( Injection Point < T > ip ) { Objects . require Non Null ( ip ) ; Provider < T > provider = provider ( ip ) ; if ( provider != null ) { return provider . get ( ) ; } else { return null ; } }
static Method Handle link Method Handle Constant ( Class < ? > caller Class , int ref Kind , Class < ? > defc , String name , Object type ) { try { Lookup lookup = IMPL LOOKUP . in ( caller Class ) ; assert ( ref Kind Is Valid ( ref Kind ) ) ; return lookup . link Method Handle Constant ( ( byte ) ref Kind , defc , name , type ) ; } catch ( Illegal Access Exception ex ) { Throwable cause = ex . get Cause ( ) ; if ( cause instanceof Abstract Method Error ) { throw ( Abstract Method Error ) cause ; } else { Error err = new Illegal Access Error ( ex . get Message ( ) ) ; throw init Cause From ( err , ex ) ; } } catch ( No Such Method Exception ex ) { Error err = new No Such Method Error ( ex . get Message ( ) ) ; throw init Cause From ( err , ex ) ; } catch ( No Such Field Exception ex ) { Error err = new No Such Field Error ( ex . get Message ( ) ) ; throw init Cause From ( err , ex ) ; } catch ( Reflective Operation Exception ex ) { Error err = new Incompatible Class Change Error ( ) ; throw init Cause From ( err , ex ) ; } }
static Method Handle link Method Handle Constant ( Class < ? > caller Class , int ref Kind , Class < ? > defc , String name , Object type ) { try { Lookup lookup = IMPL LOOKUP . in ( caller Class ) ; assert ( ref Kind Is Valid ( ref Kind ) ) ; return lookup . link Method Handle Constant ( ( byte ) ref Kind , defc , name , type ) ; } catch ( Illegal Access Exception ex ) { Throwable cause = ex . get Cause ( ) ; if ( cause instanceof Abstract Method Error ) { throw ( Abstract Method Error ) cause ; } else { Error err = new Illegal Access Error ( ex . get Message ( ) ) ; throw init Cause From ( err , ex ) ; } } catch ( No Such Method Exception ex ) { Error err = new No Such Method Error ( ex . get Message ( ) ) ; throw init Cause From ( err , ex ) ; } catch ( No Such Field Exception ex ) { Error err = new No Such Field Error ( ex . get Message ( ) ) ; throw init Cause From ( err , ex ) ; } catch ( Reflective Operation Exception ex ) { Error err = new Incompatible Class Change Error ( ) ; throw init Cause From ( err , ex ) ; } }
static Method Handle link Method Handle Constant ( Class < ? > caller Class , int ref Kind , Class < ? > defc , String name , Object type ) { try { Lookup lookup = IMPL LOOKUP . in ( caller Class ) ; assert ( ref Kind Is Valid ( ref Kind ) ) ; return lookup . link Method Handle Constant ( ( byte ) ref Kind , defc , name , type ) ; } catch ( Illegal Access Exception ex ) { Throwable cause = ex . get Cause ( ) ; if ( cause instanceof Abstract Method Error ) { throw ( Abstract Method Error ) cause ; } else { Error err = new Illegal Access Error ( ex . get Message ( ) ) ; throw init Cause From ( err , ex ) ; } } catch ( No Such Method Exception ex ) { Error err = new No Such Method Error ( ex . get Message ( ) ) ; throw init Cause From ( err , ex ) ; } catch ( No Such Field Exception ex ) { Error err = new No Such Field Error ( ex . get Message ( ) ) ; throw init Cause From ( err , ex ) ; } catch ( Reflective Operation Exception ex ) { Error err = new Incompatible Class Change Error ( ) ; throw init Cause From ( err , ex ) ; } }
static Method Handle link Method Handle Constant ( Class < ? > caller Class , int ref Kind , Class < ? > defc , String name , Object type ) { try { Lookup lookup = IMPL LOOKUP . in ( caller Class ) ; assert ( ref Kind Is Valid ( ref Kind ) ) ; return lookup . link Method Handle Constant ( ( byte ) ref Kind , defc , name , type ) ; } catch ( Illegal Access Exception ex ) { Throwable cause = ex . get Cause ( ) ; if ( cause instanceof Abstract Method Error ) { throw ( Abstract Method Error ) cause ; } else { Error err = new Illegal Access Error ( ex . get Message ( ) ) ; throw init Cause From ( err , ex ) ; } } catch ( No Such Method Exception ex ) { Error err = new No Such Method Error ( ex . get Message ( ) ) ; throw init Cause From ( err , ex ) ; } catch ( No Such Field Exception ex ) { Error err = new No Such Field Error ( ex . get Message ( ) ) ; throw init Cause From ( err , ex ) ; } catch ( Reflective Operation Exception ex ) { Error err = new Incompatible Class Change Error ( ) ; throw init Cause From ( err , ex ) ; } }
static Method Handle link Method Handle Constant ( Class < ? > caller Class , int ref Kind , Class < ? > defc , String name , Object type ) { try { Lookup lookup = IMPL LOOKUP . in ( caller Class ) ; assert ( ref Kind Is Valid ( ref Kind ) ) ; return lookup . link Method Handle Constant ( ( byte ) ref Kind , defc , name , type ) ; } catch ( Illegal Access Exception ex ) { Throwable cause = ex . get Cause ( ) ; if ( cause instanceof Abstract Method Error ) { throw ( Abstract Method Error ) cause ; } else { Error err = new Illegal Access Error ( ex . get Message ( ) ) ; throw init Cause From ( err , ex ) ; } } catch ( No Such Method Exception ex ) { Error err = new No Such Method Error ( ex . get Message ( ) ) ; throw init Cause From ( err , ex ) ; } catch ( No Such Field Exception ex ) { Error err = new No Such Field Error ( ex . get Message ( ) ) ; throw init Cause From ( err , ex ) ; } catch ( Reflective Operation Exception ex ) { Error err = new Incompatible Class Change Error ( ) ; throw init Cause From ( err , ex ) ; } }
public static Stream < Transaction > stream Self And All Transactions ( final Transaction transaction ) { final List < Transaction > all Transactions = new Array List < > ( ) ; all Transactions . add ( transaction ) ; add Transactions Recursive ( all Transactions , transaction . get Child Transactions ( ) ) ; return all Transactions . stream ( ) ; }
private void init Class Path ( ) { String Builder cpath = new String Builder ( ) ; String sep = System . get Property ( STRING ) ; cpath . append ( options . get Scratch Dir ( ) + sep ) ; String cp = ( String ) context . get Attribute ( Constants . SERVLET CLASSPATH ) ; if ( cp == null || cp . equals ( STRING ) ) { cp = options . get Class Path ( ) ; } if ( cp != null ) { classpath = cpath . to String ( ) + cp ; } if ( classpath != null ) { try { classpath = URL Decoder . decode ( classpath , STRING ) ; } catch ( Unsupported Encoding Exception e ) { if ( log . is Loggable ( Level . FINE ) ) log . log ( Level . FINE , STRING + classpath , e ) ; } } }
private void init Class Path ( ) { String Builder cpath = new String Builder ( ) ; String sep = System . get Property ( STRING ) ; cpath . append ( options . get Scratch Dir ( ) + sep ) ; String cp = ( String ) context . get Attribute ( Constants . SERVLET CLASSPATH ) ; if ( cp == null || cp . equals ( STRING ) ) { cp = options . get Class Path ( ) ; } if ( cp != null ) { classpath = cpath . to String ( ) + cp ; } if ( classpath != null ) { try { classpath = URL Decoder . decode ( classpath , STRING ) ; } catch ( Unsupported Encoding Exception e ) { if ( log . is Loggable ( Level . FINE ) ) log . log ( Level . FINE , STRING + classpath , e ) ; } } }
private void init Class Path ( ) { String Builder cpath = new String Builder ( ) ; String sep = System . get Property ( STRING ) ; cpath . append ( options . get Scratch Dir ( ) + sep ) ; String cp = ( String ) context . get Attribute ( Constants . SERVLET CLASSPATH ) ; if ( cp == null || cp . equals ( STRING ) ) { cp = options . get Class Path ( ) ; } if ( cp != null ) { classpath = cpath . to String ( ) + cp ; } if ( classpath != null ) { try { classpath = URL Decoder . decode ( classpath , STRING ) ; } catch ( Unsupported Encoding Exception e ) { if ( log . is Loggable ( Level . FINE ) ) log . log ( Level . FINE , STRING + classpath , e ) ; } } }
public static double norm 2 ( Point 2 D A , Point 2 D B ) { return ( A . get X ( ) - B . get X ( ) ) * ( A . get X ( ) - B . get X ( ) ) + ( A . get Y ( ) - B . get Y ( ) ) * ( A . get Y ( ) - B . get Y ( ) ) ; }
public List < Statement > wikibase Style ( ) { return built ( ) ; }
public List < Statement > wikibase Style ( ) { return built ( ) ; }
public Xml Generator ( Stream Properties props , Writer w , Charset cs , boolean pretty Print , Xml Namespace default Namespace ) { Enum Set < Writer Flags > flags = Enum Set . of ( Writer Flags . WRITE HEADER ) ; if ( pretty Print ) { flags . add ( Writer Flags . PRETTY PRINT ) ; } try { this . xw = new Xml Writer ( w , flags , cs . name ( ) ) ; } catch ( IO Exception ioe ) { throw new Runtime Exception ( STRING , ioe ) ; } this . root Metadata = props . get Root Metadata ( ) ; this . default Namespace = default Namespace ; }
public Xml Generator ( Stream Properties props , Writer w , Charset cs , boolean pretty Print , Xml Namespace default Namespace ) { Enum Set < Writer Flags > flags = Enum Set . of ( Writer Flags . WRITE HEADER ) ; if ( pretty Print ) { flags . add ( Writer Flags . PRETTY PRINT ) ; } try { this . xw = new Xml Writer ( w , flags , cs . name ( ) ) ; } catch ( IO Exception ioe ) { throw new Runtime Exception ( STRING , ioe ) ; } this . root Metadata = props . get Root Metadata ( ) ; this . default Namespace = default Namespace ; }
public Xml Generator ( Stream Properties props , Writer w , Charset cs , boolean pretty Print , Xml Namespace default Namespace ) { Enum Set < Writer Flags > flags = Enum Set . of ( Writer Flags . WRITE HEADER ) ; if ( pretty Print ) { flags . add ( Writer Flags . PRETTY PRINT ) ; } try { this . xw = new Xml Writer ( w , flags , cs . name ( ) ) ; } catch ( IO Exception ioe ) { throw new Runtime Exception ( STRING , ioe ) ; } this . root Metadata = props . get Root Metadata ( ) ; this . default Namespace = default Namespace ; }
public List < Storage File > create Storage Files From S 3 Object Summaries ( List < S3 Object Summary > s3 Object Summaries ) { List < Storage File > storage Files = new Array List < > ( ) ; for ( S3 Object Summary s3 Object Summary : s3 Object Summaries ) { storage Files . add ( new Storage File ( s3 Object Summary . get Key ( ) , s3 Object Summary . get Size ( ) , null ) ) ; } return storage Files ; }
public static String fix Desc ( String description , Map < String , Mapped Class > old Namesto Classes ) { if ( description == null || description . length ( ) == NUM || is Primitive ( description ) ) { return description ; } if ( description . contains ( STRING ) && description . contains ( STRING ) ) { if ( description . starts With ( STRING ) || ( description . starts With ( STRING ) || description . starts With ( STRING ) ) && description . ends With ( STRING ) ) { String regex = STRING ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( Pattern . quote ( description ) ) ; for ( int i = NUM ; i < m . group Count ( ) ; i ++ ) { String found = m . group ( i ) ; description = description . replace ( found , fix Desc ( found , old Namesto Classes ) ) ; } return description ; } } else { Mapped Class mc = old Namesto Classes . get ( description ) ; if ( mc == null ) { return description ; } return mc . get New Name ( ) ; } return description ; }
static File Channel new File Channel ( String path For Windows , String path To Check , Set < ? extends Open Option > options , long p Security Descriptor ) throws Windows Exception { Flags flags = Flags . to Flags ( options ) ; if ( ! flags . read && ! flags . write ) { if ( flags . append ) { flags . write = BOOL ; } else { flags . read = BOOL ; } } if ( flags . read && flags . append ) throw new Illegal Argument Exception ( STRING ) ; if ( flags . append && flags . truncate Existing ) throw new Illegal Argument Exception ( STRING ) ; File Descriptor fd Obj = open ( path For Windows , path To Check , flags , p Security Descriptor ) ; return File Channel Impl . open ( fd Obj , path For Windows , flags . read , flags . write , flags . append , null ) ; }
public void mouse Move ( int x , int y , int dx , int dy , int button ) { if ( ( mouse X < NUM ) || ( Math . abs ( dx ) > NUM ) || ( Math . abs ( dy ) > NUM ) ) { dx = NUM ; dy = NUM ; } else { dx = x - mouse X ; dy = y - mouse Y ; } mouse X = x ; mouse Y = y ; switch ( button ) { case NUM : mouse X = - NUM ; mouse Y = - NUM ; break ; case NUM : long now = System . current Time Millis ( ) ; long elapsed = now - timestamp ; timestamp = now ; double delta = Math . sqrt ( dx * dx + dy * dy ) ; velocity = ( NUM * delta / ( NUM + elapsed ) ) * NUM + NUM * velocity ; viewpoint Node . drag ( dx , dy ) ; last Dx = dx ; last Dy = dy ; break ; case NUM : viewpoint Node . translate In Screen Plane ( - dx , - dy ) ; break ; case NUM : viewpoint Node . rotate ( dy , dx ) ; break ; } }
public Options resource Dirs ( List < File > value ) { resource Dirs . clear ( ) ; resource Dirs . add All ( value ) ; return this ; }
@ Override public void begin Window ( long window Id ) { current Cursor = ( current Cursor + NUM ) % window Size ; last Expired Window State = states . get ( current Cursor ) ; states . set ( current Cursor , create Window State ( ) ) ; }
@ Override public void begin Window ( long window Id ) { current Cursor = ( current Cursor + NUM ) % window Size ; last Expired Window State = states . get ( current Cursor ) ; states . set ( current Cursor , create Window State ( ) ) ; }
@ Override public void begin Window ( long window Id ) { current Cursor = ( current Cursor + NUM ) % window Size ; last Expired Window State = states . get ( current Cursor ) ; states . set ( current Cursor , create Window State ( ) ) ; }
@ Override public void begin Window ( long window Id ) { current Cursor = ( current Cursor + NUM ) % window Size ; last Expired Window State = states . get ( current Cursor ) ; states . set ( current Cursor , create Window State ( ) ) ; }
@ Override public void begin Window ( long window Id ) { current Cursor = ( current Cursor + NUM ) % window Size ; last Expired Window State = states . get ( current Cursor ) ; states . set ( current Cursor , create Window State ( ) ) ; }
private static void create Script ( ) throws Exception { Class . for Name ( STRING ) ; Connection conn = Driver Manager . get Connection ( STRING ) ; Statement stat = conn . create Statement ( ) ; stat . execute ( STRING ) ; stat . execute ( STRING ) ; stat . execute ( STRING ) ; stat . close ( ) ; conn . close ( ) ; }
protected long output Offset ( ) { return bytes Written + output Tail ; }
protected long output Offset ( ) { return bytes Written + output Tail ; }
public int size ( ) { return read Methods . size ( ) ; }
private String read Line ( Input Stream input Stream ) throws IO Exception { int counter = NUM ; int increment = NUM ; int buffer Size = increment ; byte [ ] line Buffer = new byte [ buffer Size ] ; byte [ ] crlf Buffer = new byte [ NUM ] ; int crlf Counter = NUM ; while ( BOOL ) { char ch ; int i = input Stream . read ( ) ; if ( i == - NUM ) { throw new IO Exception ( STRING ) ; } else ch = ( char ) ( i & NUM ) ; if ( this . max Message Size > NUM ) { this . size Counter -- ; if ( this . size Counter <= NUM ) throw new IO Exception ( STRING ) ; } if ( ch != STRING ) line Buffer [ counter ++ ] = ( byte ) ( i & NUM ) ; else if ( counter == NUM ) crlf Buffer [ crlf Counter ++ ] = ( byte ) STRING ; if ( ch == STRING ) { if ( counter == NUM && crlf Counter > NUM ) { crlf Buffer [ crlf Counter ++ ] = ( byte ) STRING ; } break ; } if ( counter == buffer Size ) { byte [ ] temp Buffer = new byte [ buffer Size + increment ] ; System . arraycopy ( ( Object ) line Buffer , NUM , ( Object ) temp Buffer , NUM , buffer Size ) ; buffer Size = buffer Size + increment ; line Buffer = temp Buffer ; } } if ( counter == NUM && crlf Counter > NUM ) { return new String ( crlf Buffer , NUM , crlf Counter , STRING ) ; } else { return new String ( line Buffer , NUM , counter , STRING ) ; } }
private String read Line ( Input Stream input Stream ) throws IO Exception { int counter = NUM ; int increment = NUM ; int buffer Size = increment ; byte [ ] line Buffer = new byte [ buffer Size ] ; byte [ ] crlf Buffer = new byte [ NUM ] ; int crlf Counter = NUM ; while ( BOOL ) { char ch ; int i = input Stream . read ( ) ; if ( i == - NUM ) { throw new IO Exception ( STRING ) ; } else ch = ( char ) ( i & NUM ) ; if ( this . max Message Size > NUM ) { this . size Counter -- ; if ( this . size Counter <= NUM ) throw new IO Exception ( STRING ) ; } if ( ch != STRING ) line Buffer [ counter ++ ] = ( byte ) ( i & NUM ) ; else if ( counter == NUM ) crlf Buffer [ crlf Counter ++ ] = ( byte ) STRING ; if ( ch == STRING ) { if ( counter == NUM && crlf Counter > NUM ) { crlf Buffer [ crlf Counter ++ ] = ( byte ) STRING ; } break ; } if ( counter == buffer Size ) { byte [ ] temp Buffer = new byte [ buffer Size + increment ] ; System . arraycopy ( ( Object ) line Buffer , NUM , ( Object ) temp Buffer , NUM , buffer Size ) ; buffer Size = buffer Size + increment ; line Buffer = temp Buffer ; } } if ( counter == NUM && crlf Counter > NUM ) { return new String ( crlf Buffer , NUM , crlf Counter , STRING ) ; } else { return new String ( line Buffer , NUM , counter , STRING ) ; } }
protected void pad Selected Tab ( int tab Placement , int selected Index ) { if ( selected Index >= NUM ) { Rectangle sel Rect = rects [ selected Index ] ; Insets pad Insets = get Selected Tab Pad Insets ( tab Placement ) ; sel Rect . x -= pad Insets . left ; sel Rect . width += ( pad Insets . left + pad Insets . right ) ; sel Rect . y -= pad Insets . top ; sel Rect . height += ( pad Insets . top + pad Insets . bottom ) ; } }
protected void pad Selected Tab ( int tab Placement , int selected Index ) { if ( selected Index >= NUM ) { Rectangle sel Rect = rects [ selected Index ] ; Insets pad Insets = get Selected Tab Pad Insets ( tab Placement ) ; sel Rect . x -= pad Insets . left ; sel Rect . width += ( pad Insets . left + pad Insets . right ) ; sel Rect . y -= pad Insets . top ; sel Rect . height += ( pad Insets . top + pad Insets . bottom ) ; } }
public static void stream Content To Browser ( Http Servlet Response response , Input Stream in , int length , String content Type , String file Name ) throws IO Exception { set Response Browser Proxy No Cache ( response ) ; response . set Content Length ( length ) ; if ( content Type != null ) { response . set Content Type ( content Type ) ; } if ( file Name != null ) { response . set Header ( STRING , STRING + file Name + STRING ) ; } Output Stream out = response . get Output Stream ( ) ; try { stream Content ( out , in , length ) ; } catch ( IO Exception e ) { out . close ( ) ; throw e ; } out . flush ( ) ; out . close ( ) ; }
public static void stream Content To Browser ( Http Servlet Response response , Input Stream in , int length , String content Type , String file Name ) throws IO Exception { set Response Browser Proxy No Cache ( response ) ; response . set Content Length ( length ) ; if ( content Type != null ) { response . set Content Type ( content Type ) ; } if ( file Name != null ) { response . set Header ( STRING , STRING + file Name + STRING ) ; } Output Stream out = response . get Output Stream ( ) ; try { stream Content ( out , in , length ) ; } catch ( IO Exception e ) { out . close ( ) ; throw e ; } out . flush ( ) ; out . close ( ) ; }
public static void stream Content To Browser ( Http Servlet Response response , Input Stream in , int length , String content Type , String file Name ) throws IO Exception { set Response Browser Proxy No Cache ( response ) ; response . set Content Length ( length ) ; if ( content Type != null ) { response . set Content Type ( content Type ) ; } if ( file Name != null ) { response . set Header ( STRING , STRING + file Name + STRING ) ; } Output Stream out = response . get Output Stream ( ) ; try { stream Content ( out , in , length ) ; } catch ( IO Exception e ) { out . close ( ) ; throw e ; } out . flush ( ) ; out . close ( ) ; }
public static void stream Content To Browser ( Http Servlet Response response , Input Stream in , int length , String content Type , String file Name ) throws IO Exception { set Response Browser Proxy No Cache ( response ) ; response . set Content Length ( length ) ; if ( content Type != null ) { response . set Content Type ( content Type ) ; } if ( file Name != null ) { response . set Header ( STRING , STRING + file Name + STRING ) ; } Output Stream out = response . get Output Stream ( ) ; try { stream Content ( out , in , length ) ; } catch ( IO Exception e ) { out . close ( ) ; throw e ; } out . flush ( ) ; out . close ( ) ; }
public int compare To ( App Version other ) { int result = major - other . major ; if ( result == NUM ) { result = minor - other . minor ; } if ( result == NUM ) { result = patch - other . patch ; } if ( result == NUM && ( milestone > - NUM || other . milestone > - NUM ) ) { if ( milestone > - NUM ) { if ( other . milestone == - NUM ) { result = - NUM ; } else { result = milestone - other . milestone ; } } else { if ( other . milestone > - NUM ) { result = NUM ; } } } if ( result == NUM && ! Object Util . null Equals ( modifier , other . modifier ) ) { if ( modifier == null ) { result = NUM ; } else if ( other . modifier == null ) { result = - NUM ; } else { result = modifier . compare To Ignore Case ( other . modifier ) ; } } return result ; }
public int compare To ( App Version other ) { int result = major - other . major ; if ( result == NUM ) { result = minor - other . minor ; } if ( result == NUM ) { result = patch - other . patch ; } if ( result == NUM && ( milestone > - NUM || other . milestone > - NUM ) ) { if ( milestone > - NUM ) { if ( other . milestone == - NUM ) { result = - NUM ; } else { result = milestone - other . milestone ; } } else { if ( other . milestone > - NUM ) { result = NUM ; } } } if ( result == NUM && ! Object Util . null Equals ( modifier , other . modifier ) ) { if ( modifier == null ) { result = NUM ; } else if ( other . modifier == null ) { result = - NUM ; } else { result = modifier . compare To Ignore Case ( other . modifier ) ; } } return result ; }
public int compare To ( App Version other ) { int result = major - other . major ; if ( result == NUM ) { result = minor - other . minor ; } if ( result == NUM ) { result = patch - other . patch ; } if ( result == NUM && ( milestone > - NUM || other . milestone > - NUM ) ) { if ( milestone > - NUM ) { if ( other . milestone == - NUM ) { result = - NUM ; } else { result = milestone - other . milestone ; } } else { if ( other . milestone > - NUM ) { result = NUM ; } } } if ( result == NUM && ! Object Util . null Equals ( modifier , other . modifier ) ) { if ( modifier == null ) { result = NUM ; } else if ( other . modifier == null ) { result = - NUM ; } else { result = modifier . compare To Ignore Case ( other . modifier ) ; } } return result ; }
public int compare To ( App Version other ) { int result = major - other . major ; if ( result == NUM ) { result = minor - other . minor ; } if ( result == NUM ) { result = patch - other . patch ; } if ( result == NUM && ( milestone > - NUM || other . milestone > - NUM ) ) { if ( milestone > - NUM ) { if ( other . milestone == - NUM ) { result = - NUM ; } else { result = milestone - other . milestone ; } } else { if ( other . milestone > - NUM ) { result = NUM ; } } } if ( result == NUM && ! Object Util . null Equals ( modifier , other . modifier ) ) { if ( modifier == null ) { result = NUM ; } else if ( other . modifier == null ) { result = - NUM ; } else { result = modifier . compare To Ignore Case ( other . modifier ) ; } } return result ; }
public static Day Of Week as Day ( String day ) { Day Of Week day Of Week = DAYMAP . get ( day . to Lower Case ( ) ) ; if ( day Of Week == null ) LOGGER . warn ( STRING , day ) ; return day Of Week ; }
public Steps Chain then ( Step step ) { steps . add ( step ) ; return this ; }
public static File relative File ( File f ) { if ( f . is Absolute ( ) ) { f = relative File ( new File ( STRING ) , f ) ; } return f ; }
public java . lang . String Buffer append ( java . lang . Object obj ) { internal . append ( obj ) ; return this ; }
public java . lang . String Buffer append ( java . lang . Object obj ) { internal . append ( obj ) ; return this ; }
public void add CRL ( X509 CRL Holder crl ) { crls . add ( crl . to ASN 1 Structure ( ) ) ; }
public void add CRL ( X509 CRL Holder crl ) { crls . add ( crl . to ASN 1 Structure ( ) ) ; }
public boolean validation ( ) throws Parallel Task Invalid Exception { Parallel Task task = new Parallel Task ( ) ; target Host Meta = new Target Host Meta ( target Hosts ) ; task = new Parallel Task ( request Protocol , concurrency , http Meta , target Host Meta , ssh Meta , tcp Meta , udp Meta , ping Meta , null , response Context , replacement Var Map Node Specific , replacement Var Map , request Replacement Type , config ) ; boolean valid = BOOL ; try { valid = task . validate With Fill Default ( ) ; } catch ( Parallel Task Invalid Exception e ) { logger . info ( STRING + e ) ; } return valid ; }
public boolean validation ( ) throws Parallel Task Invalid Exception { Parallel Task task = new Parallel Task ( ) ; target Host Meta = new Target Host Meta ( target Hosts ) ; task = new Parallel Task ( request Protocol , concurrency , http Meta , target Host Meta , ssh Meta , tcp Meta , udp Meta , ping Meta , null , response Context , replacement Var Map Node Specific , replacement Var Map , request Replacement Type , config ) ; boolean valid = BOOL ; try { valid = task . validate With Fill Default ( ) ; } catch ( Parallel Task Invalid Exception e ) { logger . info ( STRING + e ) ; } return valid ; }
public static boolean url Equals Host Ignore Case ( String endpoint Url , String url ) { try { return url Equals Host Ignore Case ( new URI ( endpoint Url ) , new URI ( url ) ) ; } catch ( URI Syntax Exception e ) { return BOOL ; } }
private void add To Access Control Entries ( Integer object Id , Integer parent Id , List < byte [ ] > sids ) throws IO Exception { if ( sids . is Empty ( ) ) { collect New Object SI Ds ( parent Id , sids ) ; } Table Impl ac Entries = get Access Control Entries ( ) ; Column Impl acm Col = ac Entries . get Column ( ACE COL ACM ) ; Column Impl inherit Col = ac Entries . get Column ( ACE COL F INHERITABLE ) ; Column Impl obj Id Col = ac Entries . get Column ( ACE COL OBJECT ID ) ; Column Impl sid Col = ac Entries . get Column ( ACE COL SID ) ; List < Object [ ] > ace Rows = new Array List < Object [ ] > ( sids . size ( ) ) ; for ( byte [ ] sid : sids ) { Object [ ] ace Row = new Object [ ac Entries . get Column Count ( ) ] ; acm Col . set Row Value ( ace Row , SYS FULL ACCESS ACM ) ; inherit Col . set Row Value ( ace Row , Boolean . FALSE ) ; obj Id Col . set Row Value ( ace Row , object Id ) ; sid Col . set Row Value ( ace Row , sid ) ; ace Rows . add ( ace Row ) ; } ac Entries . add Rows ( ace Rows ) ; }
public static double [ ] [ ] random ( int m , int n ) { double [ ] [ ] matres = new double [ m ] [ ] ; for ( int i = NUM ; i < m ; ++ i ) { matres [ i ] = new double [ n ] ; for ( int j = NUM ; j < n ; ++ j ) { matres [ i ] [ j ] = Math . random ( ) ; } } return ( matres ) ; }
public boolean exists ( Mon Key key ) { return map . contains Key ( key ) ; }
public boolean exists ( Mon Key key ) { return map . contains Key ( key ) ; }
public boolean exists ( Mon Key key ) { return map . contains Key ( key ) ; }
public boolean exists ( Mon Key key ) { return map . contains Key ( key ) ; }
@ Override public String to String No Weight ( int after Decimal Point ) { String Buffer text = new String Buffer ( ) ; for ( int i = NUM ; i < m Att Values . length ; i ++ ) { if ( i > NUM ) { text . append ( STRING ) ; } text . append ( to String ( i , after Decimal Point ) ) ; } return text . to String ( ) ; }
@ Override public String to String No Weight ( int after Decimal Point ) { String Buffer text = new String Buffer ( ) ; for ( int i = NUM ; i < m Att Values . length ; i ++ ) { if ( i > NUM ) { text . append ( STRING ) ; } text . append ( to String ( i , after Decimal Point ) ) ; } return text . to String ( ) ; }
public String parse DTD Markup ( ) throws IO Exception { String Builder str Buff = new String Builder ( ) ; ch = read Ch ( ) ; while ( BOOL ) { switch ( ch ) { case STRING : ch = read Ch ( ) ; return str Buff . to String ( ) ; case - NUM : error ( STRING ) ; return str Buff . to String ( ) ; case STRING : ln ++ ; ch = read Ch ( ) ; lf Count ++ ; break ; case STRING : ch = read Ch ( ) ; break ; case STRING : ln ++ ; if ( ( ch = read Ch ( ) ) == STRING ) { ch = read Ch ( ) ; crlf Count ++ ; } else { cr Count ++ ; } break ; default : str Buff . append ( ( char ) ( ch & NUM ) ) ; ch = read Ch ( ) ; break ; } } }
public Config ( ) { this ( null , null , ! DISABLE PERSIST BACKUP , ! DISABLE REGISTER INTEREST ) ; }
public final int move Made ( long now , boolean use Increment ) { stop Timer ( now ) ; Array List < Time Control Field > tc = tc Data . get TC ( white To Move ) ; Pair < Integer , Integer > tc Info = get Current TC ( white To Move ) ; int tc Idx = tc Info . first ; int moves To Tc = tc Info . second ; int remaining = get Remaining Time ( white To Move , now ) ; if ( use Increment ) { remaining += tc . get ( tc Idx ) . increment ; if ( moves To Tc == NUM ) { if ( tc Idx + NUM < tc . size ( ) ) tc Idx ++ ; remaining += tc . get ( tc Idx ) . time Control ; } } elapsed = NUM ; return remaining ; }
public static String print ( Node node , String encoding ) { if ( node == null ) { return null ; } try { Transformer Factory t Factory = Transformer Factory . new Instance ( ) ; Transformer transformer = t Factory . new Transformer ( ) ; transformer . set Output Property ( STRING , STRING ) ; transformer . set Output Property ( STRING , encoding ) ; DOM Source source = new DOM Source ( node ) ; Byte Array Output Stream os = new Byte Array Output Stream ( NUM ) ; Stream Result result = new Stream Result ( os ) ; transformer . transform ( source , result ) ; return os . to String ( encoding ) ; } catch ( Exception e ) { return null ; } }
public Http Cookie ( String name , String value ) { String ntrim = name . trim ( ) ; if ( ! is Valid Name ( ntrim ) ) { throw new Illegal Argument Exception ( STRING + name ) ; } this . name = ntrim ; this . value = value ; }
public void add Header View ( View view , int view Height , int expand Height ) { if ( expand Height != - NUM ) { m Header View Expand Height = Screen Util . dip 2 px ( m Context , expand Height ) ; } m Header Views . clear ( ) ; m Header View = view ; if ( m Header View . get Layout Params ( ) == null ) { m Header View . set Layout Params ( new Linear Layout . Layout Params ( Layout Params . MATCH PARENT , Screen Util . dip 2 px ( m Context , view Height ) ) ) ; } mark Header View Height ( m Header View ) ; m Header View . get Layout Params ( ) . height = NUM ; m Header Views . add ( m Header View ) ; if ( m Adapter != null ) { if ( ! ( m Adapter instanceof X Wrap Adapter ) ) { m Adapter = new X Wrap Adapter ( m Header Views , m Foot Views , m Adapter ) ; } } }
public Open SAML Test ( String test Name ) throws Key Store Exception , File Not Found Exception , Certificate Exception , IO Exception , No Such Algorithm Exception { super ( test Name ) ; Property Configurator . configure ( LOG FILE ) ; ks = Key Store . get Instance ( STRING ) ; Input Stream is = new File Input Stream ( new File ( path ) ) ; try { ks . load ( is , password ) ; } finally { if ( is != null ) { is . close ( ) ; } } }
public static String read String ( final JSON Object json Object , final String key , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return json Object . get String ( key ) ; } if ( not Null && json Object . is Null ( key ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT OBJECT , key ) ) ; } String value = null ; if ( ! json Object . is Null ( key ) ) { value = json Object . get String ( key ) ; } return value ; }
public boolean add Rules ( Array List < Rule > rule List ) { for ( int i = NUM ; i < rule List . size ( ) ; i ++ ) { if ( ! super . valid Rule ( rule List . get ( i ) ) ) { return BOOL ; } if ( ! valid Rule ( rule List . get ( i ) ) ) { return BOOL ; } } this . rules = rule List ; update Vars And Terminals ( ) ; return BOOL ; }
public boolean add Rules ( Array List < Rule > rule List ) { for ( int i = NUM ; i < rule List . size ( ) ; i ++ ) { if ( ! super . valid Rule ( rule List . get ( i ) ) ) { return BOOL ; } if ( ! valid Rule ( rule List . get ( i ) ) ) { return BOOL ; } } this . rules = rule List ; update Vars And Terminals ( ) ; return BOOL ; }
public boolean add Rules ( Array List < Rule > rule List ) { for ( int i = NUM ; i < rule List . size ( ) ; i ++ ) { if ( ! super . valid Rule ( rule List . get ( i ) ) ) { return BOOL ; } if ( ! valid Rule ( rule List . get ( i ) ) ) { return BOOL ; } } this . rules = rule List ; update Vars And Terminals ( ) ; return BOOL ; }
public Builder ( ) { }
public void display State ( ) { Print Writer xout = context . get ( Log . out Key ) ; xout . println ( STRING + file Object History ) ; xout . println ( STRING + open Type Names ) ; xout . println ( STRING + generated Source Names ) ; xout . println ( STRING + generated Classes . key Set ( ) ) ; xout . println ( STRING + aggregate Generated Source Names ) ; xout . println ( STRING + aggregate Generated Class Names ) ; }
public void display State ( ) { Print Writer xout = context . get ( Log . out Key ) ; xout . println ( STRING + file Object History ) ; xout . println ( STRING + open Type Names ) ; xout . println ( STRING + generated Source Names ) ; xout . println ( STRING + generated Classes . key Set ( ) ) ; xout . println ( STRING + aggregate Generated Source Names ) ; xout . println ( STRING + aggregate Generated Class Names ) ; }
private void relax ( Integer node ) { double time Now = times . get ( node ) ; int to ; double time To ; for ( Schedule Entry se : oracle . get Connected ( node , time Now ) ) { to = se . get To ( ) ; if ( visited . contains ( to ) ) { continue ; } time To = se . get Time ( ) + se . get Duration ( ) ; if ( time To < times . get ( to ) ) { prev Hops . put ( to , se ) ; set Time ( to , time To ) ; } } }
public Search Source Builder no Fields ( ) { this . field Names = Collections . empty List ( ) ; return this ; }
private static void check Shared Vocabulary Checksums For Packed Grammars ( final List < Packed Grammar > packed grammars ) { String previous checksum = STRING ; for ( Packed Grammar grammar : packed grammars ) { final String checksum = grammar . compute Vocabulary Checksum ( ) ; if ( previous checksum . is Empty ( ) ) { previous checksum = checksum ; } else { if ( ! checksum . equals ( previous checksum ) ) { throw new Runtime Exception ( STRING + STRING ) ; } previous checksum = checksum ; } } }
private static void check Shared Vocabulary Checksums For Packed Grammars ( final List < Packed Grammar > packed grammars ) { String previous checksum = STRING ; for ( Packed Grammar grammar : packed grammars ) { final String checksum = grammar . compute Vocabulary Checksum ( ) ; if ( previous checksum . is Empty ( ) ) { previous checksum = checksum ; } else { if ( ! checksum . equals ( previous checksum ) ) { throw new Runtime Exception ( STRING + STRING ) ; } previous checksum = checksum ; } } }
private static void check Shared Vocabulary Checksums For Packed Grammars ( final List < Packed Grammar > packed grammars ) { String previous checksum = STRING ; for ( Packed Grammar grammar : packed grammars ) { final String checksum = grammar . compute Vocabulary Checksum ( ) ; if ( previous checksum . is Empty ( ) ) { previous checksum = checksum ; } else { if ( ! checksum . equals ( previous checksum ) ) { throw new Runtime Exception ( STRING + STRING ) ; } previous checksum = checksum ; } } }
public void run Sessions ( Session [ ] sessions ) throws Exception { this . sessions = sessions ; elements Iterator = test Elements . iterator ( ) ; while ( elements Iterator . has Next ( ) ) { Object obj = elements Iterator . next ( ) ; if ( obj instanceof Protocol Element ) { Protocol Element test = ( Protocol Element ) obj ; test . test Protocol ( sessions , continue After Failure ) ; } } }
public void run Sessions ( Session [ ] sessions ) throws Exception { this . sessions = sessions ; elements Iterator = test Elements . iterator ( ) ; while ( elements Iterator . has Next ( ) ) { Object obj = elements Iterator . next ( ) ; if ( obj instanceof Protocol Element ) { Protocol Element test = ( Protocol Element ) obj ; test . test Protocol ( sessions , continue After Failure ) ; } } }
public void run Sessions ( Session [ ] sessions ) throws Exception { this . sessions = sessions ; elements Iterator = test Elements . iterator ( ) ; while ( elements Iterator . has Next ( ) ) { Object obj = elements Iterator . next ( ) ; if ( obj instanceof Protocol Element ) { Protocol Element test = ( Protocol Element ) obj ; test . test Protocol ( sessions , continue After Failure ) ; } } }
public void run Sessions ( Session [ ] sessions ) throws Exception { this . sessions = sessions ; elements Iterator = test Elements . iterator ( ) ; while ( elements Iterator . has Next ( ) ) { Object obj = elements Iterator . next ( ) ; if ( obj instanceof Protocol Element ) { Protocol Element test = ( Protocol Element ) obj ; test . test Protocol ( sessions , continue After Failure ) ; } } }
public void run Sessions ( Session [ ] sessions ) throws Exception { this . sessions = sessions ; elements Iterator = test Elements . iterator ( ) ; while ( elements Iterator . has Next ( ) ) { Object obj = elements Iterator . next ( ) ; if ( obj instanceof Protocol Element ) { Protocol Element test = ( Protocol Element ) obj ; test . test Protocol ( sessions , continue After Failure ) ; } } }
public void run Sessions ( Session [ ] sessions ) throws Exception { this . sessions = sessions ; elements Iterator = test Elements . iterator ( ) ; while ( elements Iterator . has Next ( ) ) { Object obj = elements Iterator . next ( ) ; if ( obj instanceof Protocol Element ) { Protocol Element test = ( Protocol Element ) obj ; test . test Protocol ( sessions , continue After Failure ) ; } } }
public static String remove Url Scheme ( String a Url ) { String url Ret Value = a Url ; if ( null != a Url ) { if ( a Url . starts With ( HTTP SCHEME ) ) { url Ret Value = a Url . substring ( HTTP SCHEME . length ( ) ) ; } else if ( a Url . starts With ( HTTPS SCHEME ) ) { url Ret Value = a Url . substring ( HTTPS SCHEME . length ( ) ) ; } } return url Ret Value ; }
public final long read Long ( ) throws java . io . IO Exception { read Fully ( scratch , NUM , NUM ) ; int h = ( ( scratch [ NUM ] & NUM ) << NUM ) | ( ( scratch [ NUM ] & NUM ) << NUM ) | ( ( scratch [ NUM ] & NUM ) << NUM ) | ( ( scratch [ NUM ] & NUM ) << NUM ) ; int l = ( ( scratch [ NUM ] & NUM ) << NUM ) | ( ( scratch [ NUM ] & NUM ) << NUM ) | ( ( scratch [ NUM ] & NUM ) << NUM ) | ( ( scratch [ NUM ] & NUM ) << NUM ) ; return ( ( ( long ) h ) << NUM ) | ( ( long ) l ) & NUM ; }
public static void thread Wants Shared Resources ( ) { thread Wants Own Resources . set ( Boolean . FALSE ) ; }
public static String force To String ( Object o ) { try { return object To String ( o , BOOL , MAX ARRAY ELEMENTS TO CONVERT ) ; } catch ( Runtime Exception ex ) { return STRING + ex ; } }
public static String force To String ( Object o ) { try { return object To String ( o , BOOL , MAX ARRAY ELEMENTS TO CONVERT ) ; } catch ( Runtime Exception ex ) { return STRING + ex ; } }
public static String force To String ( Object o ) { try { return object To String ( o , BOOL , MAX ARRAY ELEMENTS TO CONVERT ) ; } catch ( Runtime Exception ex ) { return STRING + ex ; } }
public static String force To String ( Object o ) { try { return object To String ( o , BOOL , MAX ARRAY ELEMENTS TO CONVERT ) ; } catch ( Runtime Exception ex ) { return STRING + ex ; } }
public static String force To String ( Object o ) { try { return object To String ( o , BOOL , MAX ARRAY ELEMENTS TO CONVERT ) ; } catch ( Runtime Exception ex ) { return STRING + ex ; } }
public static String force To String ( Object o ) { try { return object To String ( o , BOOL , MAX ARRAY ELEMENTS TO CONVERT ) ; } catch ( Runtime Exception ex ) { return STRING + ex ; } }
public static String force To String ( Object o ) { try { return object To String ( o , BOOL , MAX ARRAY ELEMENTS TO CONVERT ) ; } catch ( Runtime Exception ex ) { return STRING + ex ; } }
public static String force To String ( Object o ) { try { return object To String ( o , BOOL , MAX ARRAY ELEMENTS TO CONVERT ) ; } catch ( Runtime Exception ex ) { return STRING + ex ; } }
public static String force To String ( Object o ) { try { return object To String ( o , BOOL , MAX ARRAY ELEMENTS TO CONVERT ) ; } catch ( Runtime Exception ex ) { return STRING + ex ; } }
public static String force To String ( Object o ) { try { return object To String ( o , BOOL , MAX ARRAY ELEMENTS TO CONVERT ) ; } catch ( Runtime Exception ex ) { return STRING + ex ; } }
final synchronized void release Socket ( ) { running = BOOL ; sender . interrupt ( ) ; outbound Messages . clear ( ) ; if ( socket != null ) { socket . close ( ) ; socket = null ; } maximum Transmission Unit = NUM ; }
final synchronized void release Socket ( ) { running = BOOL ; sender . interrupt ( ) ; outbound Messages . clear ( ) ; if ( socket != null ) { socket . close ( ) ; socket = null ; } maximum Transmission Unit = NUM ; }
protected void complete Commandline ( Commandline cmd ) { append Verbose Option ( cmd , verbose ) ; }
protected void complete Commandline ( Commandline cmd ) { append Verbose Option ( cmd , verbose ) ; }
private void signal All ( ) { lock . lock ( ) ; try { is Done = BOOL ; done . signal All ( ) ; } finally { lock . unlock ( ) ; } }
private void signal All ( ) { lock . lock ( ) ; try { is Done = BOOL ; done . signal All ( ) ; } finally { lock . unlock ( ) ; } }
private void signal All ( ) { lock . lock ( ) ; try { is Done = BOOL ; done . signal All ( ) ; } finally { lock . unlock ( ) ; } }
private void signal All ( ) { lock . lock ( ) ; try { is Done = BOOL ; done . signal All ( ) ; } finally { lock . unlock ( ) ; } }
private void signal All ( ) { lock . lock ( ) ; try { is Done = BOOL ; done . signal All ( ) ; } finally { lock . unlock ( ) ; } }
private int remove Next ( ) { if ( last Usage Dates . is Empty ( ) ) { return INVALID SIZE ; } Long oldest Usage = null ; File most Long Used File = null ; Set < Entry < File , Long > > entries = last Usage Dates . entry Set ( ) ; synchronized ( last Usage Dates ) { for ( Entry < File , Long > entry : entries ) { if ( most Long Used File == null ) { most Long Used File = entry . get Key ( ) ; oldest Usage = entry . get Value ( ) ; } else { Long last Value Usage = entry . get Value ( ) ; if ( last Value Usage < oldest Usage ) { oldest Usage = last Value Usage ; most Long Used File = entry . get Key ( ) ; } } } } int file Size = NUM ; if ( most Long Used File != null ) { if ( most Long Used File . exists ( ) ) { file Size = get Size ( most Long Used File ) ; if ( most Long Used File . delete ( ) ) { last Usage Dates . remove ( most Long Used File ) ; } } else { last Usage Dates . remove ( most Long Used File ) ; } } return file Size ; }
@ Suppress Warnings ( { STRING , STRING } ) private void init Columns ( ) { columns . clear ( ) ; final Array List < Column Id > column Order = get Column Order From Config ( ) ; column Order . for Each ( null ) ; }
protected Set < String > read File To Set ( Buffered Reader a Reader ) throws IO Exception { Set < String > words = new Hash Set < String > ( ) ; String line ; while ( ( line = a Reader . read Line ( ) ) != null ) { words . add ( line . to Lower Case ( ) ) ; } return words ; }
public void test Get Certificate Issuer ( ) { assert Null ( STRING , tbt crlentry . get Certificate Issuer ( ) ) ; }
public static Area punch ( Area shape Area , double gap , boolean rounded , Point 2 D point Pos , Shape point Shape ) { if ( gap <= NUM || point Pos == null || point Shape == null ) { return shape Area ; } Affine Transform tx = Affine Transform . get Translate Instance ( point Pos . get X ( ) , point Pos . get Y ( ) ) ; int gap Join = rounded ? Basic Stroke . JOIN ROUND : Basic Stroke . JOIN MITER ; Area gap Area = Geometry Utils . grow ( tx . create Transformed Shape ( point Shape ) , gap , gap Join , NUM ) ; shape Area . subtract ( gap Area ) ; return shape Area ; }
public static Area punch ( Area shape Area , double gap , boolean rounded , Point 2 D point Pos , Shape point Shape ) { if ( gap <= NUM || point Pos == null || point Shape == null ) { return shape Area ; } Affine Transform tx = Affine Transform . get Translate Instance ( point Pos . get X ( ) , point Pos . get Y ( ) ) ; int gap Join = rounded ? Basic Stroke . JOIN ROUND : Basic Stroke . JOIN MITER ; Area gap Area = Geometry Utils . grow ( tx . create Transformed Shape ( point Shape ) , gap , gap Join , NUM ) ; shape Area . subtract ( gap Area ) ; return shape Area ; }
protected void add Class Path ( String classpath ) { if ( classpath == null ) return ; String sep = classpath . index Of ( STRING ) == - NUM ? STRING : STRING ; String [ ] parse Cp = classpath . split ( sep ) ; for ( String cp Entry : parse Cp ) { add Entry ( cp Entry ) ; } }
void case Action ( Node Representation node Rep ) { make Proof ( node Rep , BOOL , BOOL ) ; }
static public boolean is Same Day ( Timestamp one , Timestamp two ) { Gregorian Calendar cal One = new Gregorian Calendar ( ) ; if ( one != null ) cal One . set Time In Millis ( one . get Time ( ) ) ; Gregorian Calendar cal Two = new Gregorian Calendar ( ) ; if ( two != null ) cal Two . set Time In Millis ( two . get Time ( ) ) ; if ( cal One . get ( Calendar . YEAR ) == cal Two . get ( Calendar . YEAR ) && cal One . get ( Calendar . MONTH ) == cal Two . get ( Calendar . MONTH ) && cal One . get ( Calendar . DAY OF MONTH ) == cal Two . get ( Calendar . DAY OF MONTH ) ) return BOOL ; return BOOL ; }
public static final int binary Search ( Object [ ] a , Object key , Comparator cp , int begin , int end ) { int x1 = begin ; int x2 = end ; int i = x1 + ( x2 - x1 ) / NUM , c ; while ( x1 < x2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == NUM ) { return i ; } else if ( c < NUM ) { x1 = i + NUM ; } else { x2 = i ; } i = x1 + ( x2 - x1 ) / NUM ; } return - NUM * ( i + NUM ) ; }
public static final int binary Search ( Object [ ] a , Object key , Comparator cp , int begin , int end ) { int x1 = begin ; int x2 = end ; int i = x1 + ( x2 - x1 ) / NUM , c ; while ( x1 < x2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == NUM ) { return i ; } else if ( c < NUM ) { x1 = i + NUM ; } else { x2 = i ; } i = x1 + ( x2 - x1 ) / NUM ; } return - NUM * ( i + NUM ) ; }
public static short read U Byte ( Byte Buffer buffer ) { byte b = buffer . get ( ) ; return ( short ) ( b & NUM ) ; }
public static List < Item Stack > consolidate Item Stacks ( List < Item Stack > input Stacks ) { List < Item Stack > output Stacks = new Array List < Item Stack > ( ) ; for ( Item Stack source IS : input Stacks ) { boolean b Found = BOOL ; for ( Item Stack dest IS : output Stacks ) { if ( dest IS != null && source IS != null && item Stack Ingredients Match ( dest IS , source IS ) ) { b Found = BOOL ; dest IS . stack Size += source IS . stack Size ; } } if ( ! b Found ) output Stacks . add ( source IS . copy ( ) ) ; } return output Stacks ; }
public void init ( boolean encrypting , Cipher Parameters params ) throws Illegal Argument Exception { this . encrypting = encrypting ; if ( params instanceof Parameters With IV ) { Parameters With IV iv Param = ( Parameters With IV ) params ; byte [ ] iv = iv Param . get IV ( ) ; if ( iv . length < IV . length ) { System . arraycopy ( iv , NUM , IV , IV . length - iv . length , iv . length ) ; for ( int i = NUM ; i < IV . length - iv . length ; i ++ ) { IV [ i ] = NUM ; } } else { System . arraycopy ( iv , NUM , IV , NUM , IV . length ) ; } reset ( ) ; if ( iv Param . get Parameters ( ) != null ) { cipher . init ( BOOL , iv Param . get Parameters ( ) ) ; } } else { reset ( ) ; if ( params != null ) { cipher . init ( BOOL , params ) ; } } }
public void init ( boolean encrypting , Cipher Parameters params ) throws Illegal Argument Exception { this . encrypting = encrypting ; if ( params instanceof Parameters With IV ) { Parameters With IV iv Param = ( Parameters With IV ) params ; byte [ ] iv = iv Param . get IV ( ) ; if ( iv . length < IV . length ) { System . arraycopy ( iv , NUM , IV , IV . length - iv . length , iv . length ) ; for ( int i = NUM ; i < IV . length - iv . length ; i ++ ) { IV [ i ] = NUM ; } } else { System . arraycopy ( iv , NUM , IV , NUM , IV . length ) ; } reset ( ) ; if ( iv Param . get Parameters ( ) != null ) { cipher . init ( BOOL , iv Param . get Parameters ( ) ) ; } } else { reset ( ) ; if ( params != null ) { cipher . init ( BOOL , params ) ; } } }
public static String [ ] grab Args ( String signature ) { Matcher matcher = sig RE . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . group Count ( ) != NUM ) logger . error ( STRING , signature ) ; String args = matcher . group ( NUM ) ; if ( args . is Empty ( ) ) return new String [ NUM ] ; return args . split ( STRING ) ; }
public static float int Root ( int base , int root ) { float g New = base / root ; float g Old = NUM ; int counter = NUM ; while ( Math . abs ( g Old - g New ) > NUM ) { float g Pow = float Pow ( g New , root ) ; while ( Float . is Infinite ( g Pow ) ) { g New = ( g New + g Old ) / NUM ; g Pow = float Pow ( g New , root ) ; } counter += NUM ; g Old = g New ; g New = g Old - ( g Pow - base ) / ( root * float Pow ( g Old , root - NUM ) ) ; } return g New ; }
protected String Property Matcher ( String property Name , Mode mode , Boolean ignore Case , String expected Pattern , Function < Issue , String > get Actual Value ) { super ( property Name ) ; this . mode = mode ; this . ignore Case = Objects . require Non Null ( ignore Case ) ; this . expected Pattern = safe Get Value ( expected Pattern ) ; this . get Actual Value = Objects . require Non Null ( get Actual Value ) ; }
public synchronized void add ( long [ ] arg Ids , int arg Length ) { if ( length + arg Length > data . length ) { long [ ] old Data = data ; data = new long [ arg Length + length ] ; System . arraycopy ( old Data , NUM , data , NUM , old Data . length ) ; } System . arraycopy ( arg Ids , NUM , data , length , arg Length ) ; length += arg Length ; }
BCRSA Private Crt Key ( RSA Private Crt Key Spec spec ) { this . modulus = spec . get Modulus ( ) ; this . public Exponent = spec . get Public Exponent ( ) ; this . private Exponent = spec . get Private Exponent ( ) ; this . prime P = spec . get Prime P ( ) ; this . prime Q = spec . get Prime Q ( ) ; this . prime Exponent P = spec . get Prime Exponent P ( ) ; this . prime Exponent Q = spec . get Prime Exponent Q ( ) ; this . crt Coefficient = spec . get Crt Coefficient ( ) ; }
public void write ( J Window jW ) { if ( page == null ) { newpage ( ) ; } if ( page != null && pagenum >= pr First ) { int x = x0 ; int y = y0 + ( linenum * lineheight ) ; page . translate ( x , y ) ; jW . set Visible ( BOOL ) ; jW . print All ( page ) ; jW . set Visible ( BOOL ) ; jW . dispose ( ) ; page . translate ( - x , - y ) ; } }
public void write ( J Window jW ) { if ( page == null ) { newpage ( ) ; } if ( page != null && pagenum >= pr First ) { int x = x0 ; int y = y0 + ( linenum * lineheight ) ; page . translate ( x , y ) ; jW . set Visible ( BOOL ) ; jW . print All ( page ) ; jW . set Visible ( BOOL ) ; jW . dispose ( ) ; page . translate ( - x , - y ) ; } }
public void write ( J Window jW ) { if ( page == null ) { newpage ( ) ; } if ( page != null && pagenum >= pr First ) { int x = x0 ; int y = y0 + ( linenum * lineheight ) ; page . translate ( x , y ) ; jW . set Visible ( BOOL ) ; jW . print All ( page ) ; jW . set Visible ( BOOL ) ; jW . dispose ( ) ; page . translate ( - x , - y ) ; } }
public void write ( J Window jW ) { if ( page == null ) { newpage ( ) ; } if ( page != null && pagenum >= pr First ) { int x = x0 ; int y = y0 + ( linenum * lineheight ) ; page . translate ( x , y ) ; jW . set Visible ( BOOL ) ; jW . print All ( page ) ; jW . set Visible ( BOOL ) ; jW . dispose ( ) ; page . translate ( - x , - y ) ; } }
public void write ( J Window jW ) { if ( page == null ) { newpage ( ) ; } if ( page != null && pagenum >= pr First ) { int x = x0 ; int y = y0 + ( linenum * lineheight ) ; page . translate ( x , y ) ; jW . set Visible ( BOOL ) ; jW . print All ( page ) ; jW . set Visible ( BOOL ) ; jW . dispose ( ) ; page . translate ( - x , - y ) ; } }
@ Override public boolean implies ( Protection Domain pd , Permission p ) { Policy Info pi = policy Info . get ( ) ; Protection Domain Cache pd Map = pi . get Pd Mapping ( ) ; Permission Collection pc = pd Map . get ( pd ) ; if ( pc != null ) { return pc . implies ( p ) ; } pc = get Permissions ( pd ) ; if ( pc == null ) { return BOOL ; } pd Map . put ( pd , pc ) ; return pc . implies ( p ) ; }
@ Override public boolean implies ( Protection Domain pd , Permission p ) { Policy Info pi = policy Info . get ( ) ; Protection Domain Cache pd Map = pi . get Pd Mapping ( ) ; Permission Collection pc = pd Map . get ( pd ) ; if ( pc != null ) { return pc . implies ( p ) ; } pc = get Permissions ( pd ) ; if ( pc == null ) { return BOOL ; } pd Map . put ( pd , pc ) ; return pc . implies ( p ) ; }
private static List create List ( Object obj 0 , Object obj 1 ) { List list = new Array List ( ) ; list . add ( obj 0 ) ; list . add ( obj 1 ) ; return list ; }
public static float max ( final float a , final float b ) { if ( a > b ) { return a ; } if ( a < b ) { return b ; } if ( a != b ) { return Float . Na N ; } int bits = Float . float To Raw Int Bits ( a ) ; if ( bits == NUM ) { return b ; } return a ; }
public void remove Swipe Listener ( On Swipe Listener listener ) { if ( m Listeners == null ) { return ; } m Listeners . remove ( listener ) ; }
public Rectangle ( double top , double left , double bottom , double right ) { double width = Math . abs ( right - left ) ; double height = Math . abs ( bottom - top ) ; Point center = new Point ( left + ( width / NUM ) , top + ( height / NUM ) ) ; set Rect ( new Rect ( ( int ) ( center . x - ( width / NUM ) ) , ( int ) ( center . y - ( height / NUM ) ) , ( int ) width , ( int ) height ) ) ; }
public Set < Table Id > read All Table Names ( String [ ] table Types ) throws SQL Exception { return read Table Names ( null , null , null , table Types ) ; }
public static Intent create Take Picture Intent ( Activity ctx , Uri saving Uri ) { if ( saving Uri == null ) { throw new Null Pointer Exception ( STRING ) ; } final List < Intent > camera Intents = new Array List < Intent > ( ) ; final Intent capture Intent = new Intent ( Media Store . ACTION IMAGE CAPTURE ) ; final Package Manager package Manager = ctx . get Package Manager ( ) ; final List < Resolve Info > list Cam = package Manager . query Intent Activities ( capture Intent , NUM ) ; for ( Resolve Info res : list Cam ) { final String package Name = res . activity Info . package Name ; final Intent intent = new Intent ( capture Intent ) ; intent . set Component ( new Component Name ( res . activity Info . package Name , res . activity Info . name ) ) ; intent . set Package ( package Name ) ; intent . put Extra ( Media Store . EXTRA OUTPUT , saving Uri ) ; camera Intents . add ( intent ) ; } final Intent gallery Intent = new Intent ( ) ; gallery Intent . set Type ( STRING ) ; gallery Intent . set Action ( Intent . ACTION GET CONTENT ) ; final Intent chooser Intent = Intent . create Chooser ( gallery Intent , STRING ) ; chooser Intent . put Extra ( Intent . EXTRA INITIAL INTENTS , camera Intents . to Array ( new Parcelable [ ] { } ) ) ; return chooser Intent ; }
public static Intent create Take Picture Intent ( Activity ctx , Uri saving Uri ) { if ( saving Uri == null ) { throw new Null Pointer Exception ( STRING ) ; } final List < Intent > camera Intents = new Array List < Intent > ( ) ; final Intent capture Intent = new Intent ( Media Store . ACTION IMAGE CAPTURE ) ; final Package Manager package Manager = ctx . get Package Manager ( ) ; final List < Resolve Info > list Cam = package Manager . query Intent Activities ( capture Intent , NUM ) ; for ( Resolve Info res : list Cam ) { final String package Name = res . activity Info . package Name ; final Intent intent = new Intent ( capture Intent ) ; intent . set Component ( new Component Name ( res . activity Info . package Name , res . activity Info . name ) ) ; intent . set Package ( package Name ) ; intent . put Extra ( Media Store . EXTRA OUTPUT , saving Uri ) ; camera Intents . add ( intent ) ; } final Intent gallery Intent = new Intent ( ) ; gallery Intent . set Type ( STRING ) ; gallery Intent . set Action ( Intent . ACTION GET CONTENT ) ; final Intent chooser Intent = Intent . create Chooser ( gallery Intent , STRING ) ; chooser Intent . put Extra ( Intent . EXTRA INITIAL INTENTS , camera Intents . to Array ( new Parcelable [ ] { } ) ) ; return chooser Intent ; }
public static Intent create Take Picture Intent ( Activity ctx , Uri saving Uri ) { if ( saving Uri == null ) { throw new Null Pointer Exception ( STRING ) ; } final List < Intent > camera Intents = new Array List < Intent > ( ) ; final Intent capture Intent = new Intent ( Media Store . ACTION IMAGE CAPTURE ) ; final Package Manager package Manager = ctx . get Package Manager ( ) ; final List < Resolve Info > list Cam = package Manager . query Intent Activities ( capture Intent , NUM ) ; for ( Resolve Info res : list Cam ) { final String package Name = res . activity Info . package Name ; final Intent intent = new Intent ( capture Intent ) ; intent . set Component ( new Component Name ( res . activity Info . package Name , res . activity Info . name ) ) ; intent . set Package ( package Name ) ; intent . put Extra ( Media Store . EXTRA OUTPUT , saving Uri ) ; camera Intents . add ( intent ) ; } final Intent gallery Intent = new Intent ( ) ; gallery Intent . set Type ( STRING ) ; gallery Intent . set Action ( Intent . ACTION GET CONTENT ) ; final Intent chooser Intent = Intent . create Chooser ( gallery Intent , STRING ) ; chooser Intent . put Extra ( Intent . EXTRA INITIAL INTENTS , camera Intents . to Array ( new Parcelable [ ] { } ) ) ; return chooser Intent ; }
public static void add Lifecycle Listener ( Lifecycle Listener l ) { if ( listeners == null ) { listeners = new Array List < Lifecycle Listener > ( ) ; } listeners . add ( l ) ; }
public void clear Tick Label Sections ( ) { tick Label Sections . clear ( ) ; fire Update Event ( REDRAW EVENT ) ; }
@ Override public String [ ] determine Column Constraints ( Result Producer rp ) throws Exception { return null ; }
public static String token To String ( byte token ) { return ( token == Token . END ) ? STRING : TOKEN TYPES [ token ] ; }
protected Query Recycler Adapter ( Type < E > type ) { set Has Stable Ids ( BOOL ) ; proxy Provider = type == null ? null : type . get Proxy Provider ( ) ; handler = new Handler ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
protected void rehash ( ) { int old Capacity = table . length ; Cache Entry old Table [ ] = table ; int new Capacity = old Capacity * NUM + NUM ; Cache Entry new Table [ ] = new Cache Entry [ new Capacity ] ; threshold = ( int ) ( new Capacity * load Factor ) ; table = new Table ; for ( int i = old Capacity ; i -- > NUM ; ) { for ( Cache Entry old = old Table [ i ] ; old != null ; ) { Cache Entry e = old ; old = old . next ; if ( e . check ( ) != null ) { int index = ( e . hash & NUM ) % new Capacity ; e . next = new Table [ index ] ; new Table [ index ] = e ; } else count -- ; } } }
protected void rehash ( ) { int old Capacity = table . length ; Cache Entry old Table [ ] = table ; int new Capacity = old Capacity * NUM + NUM ; Cache Entry new Table [ ] = new Cache Entry [ new Capacity ] ; threshold = ( int ) ( new Capacity * load Factor ) ; table = new Table ; for ( int i = old Capacity ; i -- > NUM ; ) { for ( Cache Entry old = old Table [ i ] ; old != null ; ) { Cache Entry e = old ; old = old . next ; if ( e . check ( ) != null ) { int index = ( e . hash & NUM ) % new Capacity ; e . next = new Table [ index ] ; new Table [ index ] = e ; } else count -- ; } } }
public Explanation idf Explain ( Collection Statistics collection Stats , Term Statistics term Stats [ ] ) { final long doc Count = collection Stats . doc Count ( ) == - NUM ? collection Stats . max Doc ( ) : collection Stats . doc Count ( ) ; float idf = NUM ; List < Explanation > details = new Array List < > ( ) ; for ( final Term Statistics stat : term Stats ) { final long df = stat . doc Freq ( ) ; final float term Idf = idf ( df , doc Count ) ; details . add ( Explanation . match ( term Idf , STRING + df + STRING + doc Count + STRING ) ) ; idf += term Idf ; } return Explanation . match ( idf , STRING , details ) ; }
public Explanation idf Explain ( Collection Statistics collection Stats , Term Statistics term Stats [ ] ) { final long doc Count = collection Stats . doc Count ( ) == - NUM ? collection Stats . max Doc ( ) : collection Stats . doc Count ( ) ; float idf = NUM ; List < Explanation > details = new Array List < > ( ) ; for ( final Term Statistics stat : term Stats ) { final long df = stat . doc Freq ( ) ; final float term Idf = idf ( df , doc Count ) ; details . add ( Explanation . match ( term Idf , STRING + df + STRING + doc Count + STRING ) ) ; idf += term Idf ; } return Explanation . match ( idf , STRING , details ) ; }
public Explanation idf Explain ( Collection Statistics collection Stats , Term Statistics term Stats [ ] ) { final long doc Count = collection Stats . doc Count ( ) == - NUM ? collection Stats . max Doc ( ) : collection Stats . doc Count ( ) ; float idf = NUM ; List < Explanation > details = new Array List < > ( ) ; for ( final Term Statistics stat : term Stats ) { final long df = stat . doc Freq ( ) ; final float term Idf = idf ( df , doc Count ) ; details . add ( Explanation . match ( term Idf , STRING + df + STRING + doc Count + STRING ) ) ; idf += term Idf ; } return Explanation . match ( idf , STRING , details ) ; }
public Explanation idf Explain ( Collection Statistics collection Stats , Term Statistics term Stats [ ] ) { final long doc Count = collection Stats . doc Count ( ) == - NUM ? collection Stats . max Doc ( ) : collection Stats . doc Count ( ) ; float idf = NUM ; List < Explanation > details = new Array List < > ( ) ; for ( final Term Statistics stat : term Stats ) { final long df = stat . doc Freq ( ) ; final float term Idf = idf ( df , doc Count ) ; details . add ( Explanation . match ( term Idf , STRING + df + STRING + doc Count + STRING ) ) ; idf += term Idf ; } return Explanation . match ( idf , STRING , details ) ; }
public File Channel Output Stream ( File Channel channel , boolean append ) throws IO Exception { this . channel = channel ; if ( append ) { channel . position ( channel . size ( ) ) ; } else { channel . position ( NUM ) ; channel . truncate ( NUM ) ; } }
public File Channel Output Stream ( File Channel channel , boolean append ) throws IO Exception { this . channel = channel ; if ( append ) { channel . position ( channel . size ( ) ) ; } else { channel . position ( NUM ) ; channel . truncate ( NUM ) ; } }
public T vertex Processor ( final Bi Consumer < Vertex , Map < String , Object > > vertex Processor ) { this . vertex Processor = Optional . of Nullable ( vertex Processor ) ; return extending Class . cast ( this ) ; }
public T vertex Processor ( final Bi Consumer < Vertex , Map < String , Object > > vertex Processor ) { this . vertex Processor = Optional . of Nullable ( vertex Processor ) ; return extending Class . cast ( this ) ; }
public static String select Preferred MIME Type ( Iterator < String > mime Types , Http Servlet Request request ) { List < Header Element > accept Elements = get Header Elements ( request , STRING ) ; if ( accept Elements . is Empty ( ) ) { if ( mime Types . has Next ( ) ) { return mime Types . next ( ) ; } else { return null ; } } String result = null ; Header Element matching Accept Type = null ; double highest Quality = NUM ; while ( mime Types . has Next ( ) ) { String mime Type = mime Types . next ( ) ; Header Element accept Type = match Accept Header ( mime Type , accept Elements ) ; if ( accept Type != null ) { double quality = NUM ; String quality Str = accept Type . get Parameter Value ( STRING ) ; if ( quality Str != null ) { try { quality = Double . parse Double ( quality Str ) ; } catch ( Number Format Exception e ) { } } if ( quality > highest Quality ) { result = mime Type ; matching Accept Type = accept Type ; highest Quality = quality ; } else if ( quality == highest Quality ) { if ( is More Specific Type ( accept Type , matching Accept Type ) ) { result = mime Type ; matching Accept Type = accept Type ; } } } } return result ; }
public static String select Preferred MIME Type ( Iterator < String > mime Types , Http Servlet Request request ) { List < Header Element > accept Elements = get Header Elements ( request , STRING ) ; if ( accept Elements . is Empty ( ) ) { if ( mime Types . has Next ( ) ) { return mime Types . next ( ) ; } else { return null ; } } String result = null ; Header Element matching Accept Type = null ; double highest Quality = NUM ; while ( mime Types . has Next ( ) ) { String mime Type = mime Types . next ( ) ; Header Element accept Type = match Accept Header ( mime Type , accept Elements ) ; if ( accept Type != null ) { double quality = NUM ; String quality Str = accept Type . get Parameter Value ( STRING ) ; if ( quality Str != null ) { try { quality = Double . parse Double ( quality Str ) ; } catch ( Number Format Exception e ) { } } if ( quality > highest Quality ) { result = mime Type ; matching Accept Type = accept Type ; highest Quality = quality ; } else if ( quality == highest Quality ) { if ( is More Specific Type ( accept Type , matching Accept Type ) ) { result = mime Type ; matching Accept Type = accept Type ; } } } } return result ; }
public synchronized void add ( double min Value , double max Value ) { super . add ( min Value ) ; m Max Values . add ( max Value ) ; }
public boolean is Optional ( final Attribute Type attribute Type ) { return optional Attributes . contains ( attribute Type ) ; }
protected int do Opcode ( int pos , byte [ ] code ) throws Bad Bytecode { try { int op = code [ pos ] & NUM ; if ( op < NUM ) if ( op < NUM ) return do Opcode 0 53 ( pos , code , op ) ; else return do Opcode 54 95 ( pos , code , op ) ; else if ( op < NUM ) return do Opcode 96 147 ( pos , code , op ) ; else return do Opcode 148 201 ( pos , code , op ) ; } catch ( Array Index Out Of Bounds Exception e ) { throw new Bad Bytecode ( STRING + e . get Message ( ) , e ) ; } }
protected int do Opcode ( int pos , byte [ ] code ) throws Bad Bytecode { try { int op = code [ pos ] & NUM ; if ( op < NUM ) if ( op < NUM ) return do Opcode 0 53 ( pos , code , op ) ; else return do Opcode 54 95 ( pos , code , op ) ; else if ( op < NUM ) return do Opcode 96 147 ( pos , code , op ) ; else return do Opcode 148 201 ( pos , code , op ) ; } catch ( Array Index Out Of Bounds Exception e ) { throw new Bad Bytecode ( STRING + e . get Message ( ) , e ) ; } }
protected int do Opcode ( int pos , byte [ ] code ) throws Bad Bytecode { try { int op = code [ pos ] & NUM ; if ( op < NUM ) if ( op < NUM ) return do Opcode 0 53 ( pos , code , op ) ; else return do Opcode 54 95 ( pos , code , op ) ; else if ( op < NUM ) return do Opcode 96 147 ( pos , code , op ) ; else return do Opcode 148 201 ( pos , code , op ) ; } catch ( Array Index Out Of Bounds Exception e ) { throw new Bad Bytecode ( STRING + e . get Message ( ) , e ) ; } }
protected int do Opcode ( int pos , byte [ ] code ) throws Bad Bytecode { try { int op = code [ pos ] & NUM ; if ( op < NUM ) if ( op < NUM ) return do Opcode 0 53 ( pos , code , op ) ; else return do Opcode 54 95 ( pos , code , op ) ; else if ( op < NUM ) return do Opcode 96 147 ( pos , code , op ) ; else return do Opcode 148 201 ( pos , code , op ) ; } catch ( Array Index Out Of Bounds Exception e ) { throw new Bad Bytecode ( STRING + e . get Message ( ) , e ) ; } }
protected int do Opcode ( int pos , byte [ ] code ) throws Bad Bytecode { try { int op = code [ pos ] & NUM ; if ( op < NUM ) if ( op < NUM ) return do Opcode 0 53 ( pos , code , op ) ; else return do Opcode 54 95 ( pos , code , op ) ; else if ( op < NUM ) return do Opcode 96 147 ( pos , code , op ) ; else return do Opcode 148 201 ( pos , code , op ) ; } catch ( Array Index Out Of Bounds Exception e ) { throw new Bad Bytecode ( STRING + e . get Message ( ) , e ) ; } }
protected int do Opcode ( int pos , byte [ ] code ) throws Bad Bytecode { try { int op = code [ pos ] & NUM ; if ( op < NUM ) if ( op < NUM ) return do Opcode 0 53 ( pos , code , op ) ; else return do Opcode 54 95 ( pos , code , op ) ; else if ( op < NUM ) return do Opcode 96 147 ( pos , code , op ) ; else return do Opcode 148 201 ( pos , code , op ) ; } catch ( Array Index Out Of Bounds Exception e ) { throw new Bad Bytecode ( STRING + e . get Message ( ) , e ) ; } }
protected int do Opcode ( int pos , byte [ ] code ) throws Bad Bytecode { try { int op = code [ pos ] & NUM ; if ( op < NUM ) if ( op < NUM ) return do Opcode 0 53 ( pos , code , op ) ; else return do Opcode 54 95 ( pos , code , op ) ; else if ( op < NUM ) return do Opcode 96 147 ( pos , code , op ) ; else return do Opcode 148 201 ( pos , code , op ) ; } catch ( Array Index Out Of Bounds Exception e ) { throw new Bad Bytecode ( STRING + e . get Message ( ) , e ) ; } }
public void test RW Bits ( ) { final int b Size = NUM << NUM ; final int [ ] bits = new int [ b Size ] ; final int nbits = b Size * NUM ; for ( int i = NUM ; i < nbits ; i ++ ) { final int b = RW Store . fnd Bit ( bits , b Size ) ; assert True ( b != - NUM ) ; assert False ( RW Store . tst Bit ( bits , b ) ) ; RW Store . set Bit ( bits , b ) ; assert True ( RW Store . tst Bit ( bits , b ) ) ; } assert True ( - NUM == RW Store . fnd Bit ( bits , b Size ) ) ; for ( int i = NUM ; i < NUM * NUM * NUM ; i ++ ) { final int b = r . next Int ( nbits ) ; assert True ( RW Store . tst Bit ( bits , b ) ) ; RW Store . clr Bit ( bits , b ) ; assert False ( RW Store . tst Bit ( bits , b ) ) ; assert True ( b == RW Store . fnd Bit ( bits , b Size ) ) ; RW Store . set Bit ( bits , b ) ; assert True ( RW Store . tst Bit ( bits , b ) ) ; } assert True ( - NUM == RW Store . fnd Bit ( bits , b Size ) ) ; }
@ Override public List < Node > generate ( int pop Size ) { List < Node > population = new Array List < > ( ) ; for ( int i = NUM ; i < pop Size ; ) { Node candidate = grow ( NUM ) ; if ( candidate . is Valid ( ) ) { population . add ( candidate ) ; i ++ ; } } return population ; }
private void create Day Slot ( Array List < M Assignment Slot > list , M Assignment Slot ma ) { Timestamp start = ma . get Start Time ( ) ; Gregorian Calendar cal Start = new Gregorian Calendar ( ) ; cal Start . set Time ( start ) ; cal Start . set ( Calendar . HOUR OF DAY , NUM ) ; cal Start . set ( Calendar . MINUTE , NUM ) ; cal Start . set ( Calendar . SECOND , NUM ) ; cal Start . set ( Calendar . MILLISECOND , NUM ) ; Timestamp end = ma . get End Time ( ) ; Gregorian Calendar cal End = new Gregorian Calendar ( ) ; cal End . set Time ( end ) ; cal End . set ( Calendar . HOUR OF DAY , NUM ) ; cal End . set ( Calendar . MINUTE , NUM ) ; cal End . set ( Calendar . SECOND , NUM ) ; cal End . set ( Calendar . MILLISECOND , NUM ) ; while ( cal Start . before ( cal End ) ) { Timestamp x Start = new Timestamp ( cal Start . get Time In Millis ( ) ) ; cal Start . add ( Calendar . DAY OF YEAR , NUM ) ; Timestamp x End = new Timestamp ( cal Start . get Time In Millis ( ) ) ; M Assignment Slot my Ma = new M Assignment Slot ( x Start , x End , ma . get Name ( ) , ma . get Description ( ) , ma . get Status ( ) ) ; list . add ( my Ma ) ; } }
public static < T > List < T > ro Copy List ( Collection < T > l ) { return Collections . unmodifiable List ( new Array List < > ( l ) ) ; }
public static < T > List < T > ro Copy List ( Collection < T > l ) { return Collections . unmodifiable List ( new Array List < > ( l ) ) ; }
protected void process Window Event ( Window Event e ) { super . process Window Event ( e ) ; if ( e . get ID ( ) == Window Event . WINDOW CLOSING ) { j Menu File Exit action Performed ( null ) ; } }
protected void process Window Event ( Window Event e ) { super . process Window Event ( e ) ; if ( e . get ID ( ) == Window Event . WINDOW CLOSING ) { j Menu File Exit action Performed ( null ) ; } }
public Socket Address start ( ) throws Socket Exception { running = BOOL ; server = new Datagram Socket ( ) ; if ( network Monitor != null ) { server = new Monitor Datagram Socket Wrapper ( server , network Monitor ) ; } Socket Address socket Address = server . get Local Socket Address ( ) ; thread = new Thread ( this ) ; thread . start ( ) ; return socket Address ; }
public void add Bridge Idle Debug Listener ( Not Thread Safe Bridge Idle Debug Listener listener ) { m Bridge Idle Listeners . add ( listener ) ; }
public void add Bridge Idle Debug Listener ( Not Thread Safe Bridge Idle Debug Listener listener ) { m Bridge Idle Listeners . add ( listener ) ; }
public void add Bridge Idle Debug Listener ( Not Thread Safe Bridge Idle Debug Listener listener ) { m Bridge Idle Listeners . add ( listener ) ; }
public void fault ( String fault Xml ) throws Exception { LOG . trace ( STRING , fault Xml ) ; if ( in Attachment Part ) { end Attachments ( ) ; } mp Encoder . start Part ( TEXT XML UTF 8 ) ; mp Encoder . write ( fault Xml . get Bytes ( Standard Charsets . UTF 8 ) ) ; }
public void add Parse Template ( String parse Template ) { parse Templates . add ( parse Template ) ; }
public void add Parse Template ( String parse Template ) { parse Templates . add ( parse Template ) ; }
@ Override public Set < K > key Set ( ) { Hash Set < K > set = new Hash Set < K > ( ) ; for ( Segment < K , V > s : segments ) { set . add All ( s . key Set ( ) ) ; } return set ; }
public Subcollection create Sub Collection ( final String id , final String name ) { Subcollection sub Col = null ; if ( ! collection Map . contains Key ( id ) ) { sub Col = new Subcollection ( id , name , get Conf ( ) ) ; collection Map . put ( id , sub Col ) ; } return sub Col ; }
@ Override public void flush ( ) throws IO Exception { synchronized ( lock ) { out . flush ( ) ; } }
@ Override public void flush ( ) throws IO Exception { synchronized ( lock ) { out . flush ( ) ; } }
@ Override public void flush ( ) throws IO Exception { synchronized ( lock ) { out . flush ( ) ; } }
static byte [ ] read Bytes ( Input Stream is , byte [ ] io Buffer , int max Size ) throws IO Exception { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; copy Bytes ( baos , is , io Buffer , max Size ) ; return baos . to Byte Array ( ) ; }
static byte [ ] read Bytes ( Input Stream is , byte [ ] io Buffer , int max Size ) throws IO Exception { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; copy Bytes ( baos , is , io Buffer , max Size ) ; return baos . to Byte Array ( ) ; }
protected Issue Property Matcher Base ( String property Name ) { this . property Name = Objects . require Non Null ( property Name ) ; }
protected Object convert Value From Xml ( Class type , Object value ) { if ( value instanceof String && type . is Primitive ( ) ) { String tmp = ( String ) value ; if ( type . equals ( boolean . class ) ) { if ( tmp . equals ( STRING ) || tmp . equals ( STRING ) ) { tmp = ( tmp . equals ( STRING ) ) ? STRING : STRING ; } value = new Boolean ( tmp ) ; } else if ( type . equals ( char . class ) ) { value = new Character ( tmp . char At ( NUM ) ) ; } else if ( type . equals ( byte . class ) ) { value = new Byte ( tmp ) ; } else if ( type . equals ( short . class ) ) { value = new Short ( tmp ) ; } else if ( type . equals ( int . class ) ) { value = new Integer ( tmp ) ; } else if ( type . equals ( long . class ) ) { value = new Long ( tmp ) ; } else if ( type . equals ( float . class ) ) { value = new Float ( tmp ) ; } else if ( type . equals ( double . class ) ) { value = new Double ( tmp ) ; } } return value ; }
protected Object convert Value From Xml ( Class type , Object value ) { if ( value instanceof String && type . is Primitive ( ) ) { String tmp = ( String ) value ; if ( type . equals ( boolean . class ) ) { if ( tmp . equals ( STRING ) || tmp . equals ( STRING ) ) { tmp = ( tmp . equals ( STRING ) ) ? STRING : STRING ; } value = new Boolean ( tmp ) ; } else if ( type . equals ( char . class ) ) { value = new Character ( tmp . char At ( NUM ) ) ; } else if ( type . equals ( byte . class ) ) { value = new Byte ( tmp ) ; } else if ( type . equals ( short . class ) ) { value = new Short ( tmp ) ; } else if ( type . equals ( int . class ) ) { value = new Integer ( tmp ) ; } else if ( type . equals ( long . class ) ) { value = new Long ( tmp ) ; } else if ( type . equals ( float . class ) ) { value = new Float ( tmp ) ; } else if ( type . equals ( double . class ) ) { value = new Double ( tmp ) ; } } return value ; }
protected boolean verify Limit ( Collection result , int limit , Execution Context context ) { if ( limit > NUM ) { return result . size ( ) == limit ; } return BOOL ; }
public void append ( final Object value ) { if ( needs Comma ) { sb . append ( m separator ) ; } needs Comma = BOOL ; sb . append ( value ) ; }
@ Override public int startup New Worker ( ) { final int priority = ( Math . random ( ) < NUM ) ? NUM : NUM ; int actual Workers Started = startup New Worker ( priority ) ; return actual Workers Started ; }
@ Override public int startup New Worker ( ) { final int priority = ( Math . random ( ) < NUM ) ? NUM : NUM ; int actual Workers Started = startup New Worker ( priority ) ; return actual Workers Started ; }
@ Override public int startup New Worker ( ) { final int priority = ( Math . random ( ) < NUM ) ? NUM : NUM ; int actual Workers Started = startup New Worker ( priority ) ; return actual Workers Started ; }
@ Override public int startup New Worker ( ) { final int priority = ( Math . random ( ) < NUM ) ? NUM : NUM ; int actual Workers Started = startup New Worker ( priority ) ; return actual Workers Started ; }
@ Override public int startup New Worker ( ) { final int priority = ( Math . random ( ) < NUM ) ? NUM : NUM ; int actual Workers Started = startup New Worker ( priority ) ; return actual Workers Started ; }
public static String join ( String separator , List < String > strings ) { String Builder sb = new String Builder ( ) ; for ( Iterator < String > iter = strings . iterator ( ) ; iter . has Next ( ) ; ) { String s = iter . next ( ) ; sb . append ( s ) ; if ( iter . has Next ( ) ) sb . append ( separator ) ; } return sb . to String ( ) ; }
public static String join ( String separator , List < String > strings ) { String Builder sb = new String Builder ( ) ; for ( Iterator < String > iter = strings . iterator ( ) ; iter . has Next ( ) ; ) { String s = iter . next ( ) ; sb . append ( s ) ; if ( iter . has Next ( ) ) sb . append ( separator ) ; } return sb . to String ( ) ; }
public Json Value undeploy ( String route Id ) throws Router Handler Exception { write . lock ( ) ; try { Json Value route Config = unload ( route Id ) ; directory Monitor . delete ( route Id ) ; logger . info ( STRING , route Id ) ; return route Config ; } finally { write . unlock ( ) ; } }
public Json Value undeploy ( String route Id ) throws Router Handler Exception { write . lock ( ) ; try { Json Value route Config = unload ( route Id ) ; directory Monitor . delete ( route Id ) ; logger . info ( STRING , route Id ) ; return route Config ; } finally { write . unlock ( ) ; } }
public boolean remove Element ( Object obj ) { int index = index Of ( obj ) ; boolean rv = delegate . remove Element ( obj ) ; if ( index >= NUM ) { fire Interval Removed ( this , index , index ) ; } return rv ; }
public static Help Sub Command Handler create ( Sub Command Argument Parser parser ) throws Argument Exception { return new Help Sub Command Handler ( parser ) ; }
public String html All ( boolean set Included ) { String Builder sb = new String Builder ( ) ; for ( Node node : nodes ) { sb . append ( set Included ? node . get Html ( ) : node . get Inner Html ( ) ) ; } return sb . to String ( ) ; }
public void schedule ( Timer Task task , Date when , long period ) { if ( period <= NUM || when . get Time ( ) < NUM ) { throw new Illegal Argument Exception ( ) ; } long delay = when . get Time ( ) - System . current Time Millis ( ) ; schedule Impl ( task , delay < NUM ? NUM : delay , period , BOOL ) ; }
void schedule Message Received ( Next Filter next Filter , Object message ) { message Received Event Queue . add ( new Io Filter Event ( next Filter , Io Event Type . MESSAGE RECEIVED , session , message ) ) ; }
void schedule Message Received ( Next Filter next Filter , Object message ) { message Received Event Queue . add ( new Io Filter Event ( next Filter , Io Event Type . MESSAGE RECEIVED , session , message ) ) ; }
public void add All ( T ... items ) { synchronized ( m Lock ) { if ( m Original Values != null ) { Collections . add All ( m Original Values , items ) ; } else { Collections . add All ( m Objects , items ) ; } } if ( m Notify On Change ) notify Data Set Changed ( ) ; }
public void add All ( T ... items ) { synchronized ( m Lock ) { if ( m Original Values != null ) { Collections . add All ( m Original Values , items ) ; } else { Collections . add All ( m Objects , items ) ; } } if ( m Notify On Change ) notify Data Set Changed ( ) ; }
protected String convert Word ( String word ) { word = word . to Upper Case ( ) ; if ( ignore List . contains ( word ) ) { return null ; } return word ; }
public void remove Change Listener ( Change Listener l ) { if ( listeners == null ) return ; listeners . remove ( l ) ; }
private boolean is In Thumb Range ( float touch X , double normalized Thumb Value ) { return Math . abs ( touch X - normalized To Screen ( normalized Thumb Value ) ) <= thumb Half Width ; }
private boolean is In Thumb Range ( float touch X , double normalized Thumb Value ) { return Math . abs ( touch X - normalized To Screen ( normalized Thumb Value ) ) <= thumb Half Width ; }
private boolean is In Thumb Range ( float touch X , double normalized Thumb Value ) { return Math . abs ( touch X - normalized To Screen ( normalized Thumb Value ) ) <= thumb Half Width ; }
private boolean is In Thumb Range ( float touch X , double normalized Thumb Value ) { return Math . abs ( touch X - normalized To Screen ( normalized Thumb Value ) ) <= thumb Half Width ; }
public static Object read Object ( java . sql . Result Set result Set , int index ) throws Exception { Object Input Stream obj In = new Object Input Stream ( result Set . get Binary Stream ( index ) ) ; Object obj = obj In . read Object ( ) ; obj In . close ( ) ; return obj ; }
public static Object read Object ( java . sql . Result Set result Set , int index ) throws Exception { Object Input Stream obj In = new Object Input Stream ( result Set . get Binary Stream ( index ) ) ; Object obj = obj In . read Object ( ) ; obj In . close ( ) ; return obj ; }
public static Struct Type convert Frame Schema To DF Schema ( Value Type [ ] fschema , boolean contains ID ) { List < Struct Field > fields = new Array List < Struct Field > ( ) ; if ( contains ID ) fields . add ( Data Types . create Struct Field ( RDD Converter Utils . DF ID COLUMN , Data Types . Double Type , BOOL ) ) ; int col = NUM ; for ( Value Type schema : fschema ) { Data Type dt = null ; switch ( schema ) { case STRING : dt = Data Types . String Type ; break ; case DOUBLE : dt = Data Types . Double Type ; break ; case INT : dt = Data Types . Long Type ; break ; case BOOLEAN : dt = Data Types . Boolean Type ; break ; default : dt = Data Types . String Type ; LOG . warn ( STRING + schema . to String ( ) ) ; } fields . add ( Data Types . create Struct Field ( STRING + col ++ , dt , BOOL ) ) ; } return Data Types . create Struct Type ( fields ) ; }
private static void close And Drain ( Default Http Response actual Res , Http Response deferred Res ) { actual Res . close ( ) ; deferred Res . subscribe ( Noop Subscriber . get ( ) ) ; wait For Event Loop ( ) ; }
private static void close And Drain ( Default Http Response actual Res , Http Response deferred Res ) { actual Res . close ( ) ; deferred Res . subscribe ( Noop Subscriber . get ( ) ) ; wait For Event Loop ( ) ; }
private static void close And Drain ( Default Http Response actual Res , Http Response deferred Res ) { actual Res . close ( ) ; deferred Res . subscribe ( Noop Subscriber . get ( ) ) ; wait For Event Loop ( ) ; }
private Http URL Connection open Connection Follow Redirects ( String url Str , String auth Sub Token ) throws Malformed URL Exception , General Security Exception , IO Exception { boolean redirects Done = BOOL ; Http URL Connection connection = null ; while ( ! redirects Done ) { URL url = new URL ( url Str ) ; connection = ( Http URL Connection ) url . open Connection ( ) ; connection . set Request Property ( STRING , STRING ) ; String auth Header = null ; auth Header = Auth Sub Util . form Authorization Header ( auth Sub Token , Utility . get Private Key ( ) , url , STRING ) ; connection . set Request Property ( STRING , auth Header ) ; connection . set Instance Follow Redirects ( BOOL ) ; int response Code = connection . get Response Code ( ) ; if ( response Code == Http URL Connection . HTTP MOVED PERM || response Code == Http URL Connection . HTTP MOVED TEMP ) { url Str = connection . get Header Field ( STRING ) ; if ( url Str == null ) { redirects Done = BOOL ; } } else { redirects Done = BOOL ; } } return connection ; }
private Http URL Connection open Connection Follow Redirects ( String url Str , String auth Sub Token ) throws Malformed URL Exception , General Security Exception , IO Exception { boolean redirects Done = BOOL ; Http URL Connection connection = null ; while ( ! redirects Done ) { URL url = new URL ( url Str ) ; connection = ( Http URL Connection ) url . open Connection ( ) ; connection . set Request Property ( STRING , STRING ) ; String auth Header = null ; auth Header = Auth Sub Util . form Authorization Header ( auth Sub Token , Utility . get Private Key ( ) , url , STRING ) ; connection . set Request Property ( STRING , auth Header ) ; connection . set Instance Follow Redirects ( BOOL ) ; int response Code = connection . get Response Code ( ) ; if ( response Code == Http URL Connection . HTTP MOVED PERM || response Code == Http URL Connection . HTTP MOVED TEMP ) { url Str = connection . get Header Field ( STRING ) ; if ( url Str == null ) { redirects Done = BOOL ; } } else { redirects Done = BOOL ; } } return connection ; }
private Http URL Connection open Connection Follow Redirects ( String url Str , String auth Sub Token ) throws Malformed URL Exception , General Security Exception , IO Exception { boolean redirects Done = BOOL ; Http URL Connection connection = null ; while ( ! redirects Done ) { URL url = new URL ( url Str ) ; connection = ( Http URL Connection ) url . open Connection ( ) ; connection . set Request Property ( STRING , STRING ) ; String auth Header = null ; auth Header = Auth Sub Util . form Authorization Header ( auth Sub Token , Utility . get Private Key ( ) , url , STRING ) ; connection . set Request Property ( STRING , auth Header ) ; connection . set Instance Follow Redirects ( BOOL ) ; int response Code = connection . get Response Code ( ) ; if ( response Code == Http URL Connection . HTTP MOVED PERM || response Code == Http URL Connection . HTTP MOVED TEMP ) { url Str = connection . get Header Field ( STRING ) ; if ( url Str == null ) { redirects Done = BOOL ; } } else { redirects Done = BOOL ; } } return connection ; }
public void update Timers And Events ( Process Definition Entity process Definition , Process Definition Entity previous Process Definition , Parsed Deployment parsed Deployment ) { Process process = parsed Deployment . get Process Model For Process Definition ( process Definition ) ; Bpmn Model bpmn Model = parsed Deployment . get Bpmn Model For Process Definition ( process Definition ) ; event Subscription Manager . remove Obsolete Message Event Subscriptions ( previous Process Definition ) ; event Subscription Manager . add Message Event Subscriptions ( process Definition , process , bpmn Model ) ; event Subscription Manager . remove Obsolete Signal Event Sub Scription ( previous Process Definition ) ; event Subscription Manager . add Signal Event Subscriptions ( Context . get Command Context ( ) , process Definition , process , bpmn Model ) ; timer Manager . remove Obsolete Timers ( process Definition ) ; timer Manager . schedule Timers ( process Definition , process ) ; }
public void update Timers And Events ( Process Definition Entity process Definition , Process Definition Entity previous Process Definition , Parsed Deployment parsed Deployment ) { Process process = parsed Deployment . get Process Model For Process Definition ( process Definition ) ; Bpmn Model bpmn Model = parsed Deployment . get Bpmn Model For Process Definition ( process Definition ) ; event Subscription Manager . remove Obsolete Message Event Subscriptions ( previous Process Definition ) ; event Subscription Manager . add Message Event Subscriptions ( process Definition , process , bpmn Model ) ; event Subscription Manager . remove Obsolete Signal Event Sub Scription ( previous Process Definition ) ; event Subscription Manager . add Signal Event Subscriptions ( Context . get Command Context ( ) , process Definition , process , bpmn Model ) ; timer Manager . remove Obsolete Timers ( process Definition ) ; timer Manager . schedule Timers ( process Definition , process ) ; }
@ Suppress Warnings ( { STRING , STRING } ) private static void merge Sort ( Object [ ] src , Object [ ] dest , int low , int high , int off , Comparator c ) { int length = high - low ; if ( length < INSERTIONSORT THRESHOLD ) { for ( int i = low ; i < high ; i ++ ) for ( int j = i ; j > low && c . compare ( dest [ j - NUM ] , dest [ j ] ) > NUM ; j -- ) swap ( dest , j , j - NUM ) ; return ; } int dest Low = low ; int dest High = high ; low += off ; high += off ; int mid = ( low + high ) > > > NUM ; merge Sort ( dest , src , low , mid , - off , c ) ; merge Sort ( dest , src , mid , high , - off , c ) ; if ( c . compare ( src [ mid - NUM ] , src [ mid ] ) <= NUM ) { System . arraycopy ( src , low , dest , dest Low , length ) ; return ; } for ( int i = dest Low , p = low , q = mid ; i < dest High ; i ++ ) { if ( q >= high || p < mid && c . compare ( src [ p ] , src [ q ] ) <= NUM ) dest [ i ] = src [ p ++ ] ; else dest [ i ] = src [ q ++ ] ; } }
@ Suppress Warnings ( { STRING , STRING } ) private static void merge Sort ( Object [ ] src , Object [ ] dest , int low , int high , int off , Comparator c ) { int length = high - low ; if ( length < INSERTIONSORT THRESHOLD ) { for ( int i = low ; i < high ; i ++ ) for ( int j = i ; j > low && c . compare ( dest [ j - NUM ] , dest [ j ] ) > NUM ; j -- ) swap ( dest , j , j - NUM ) ; return ; } int dest Low = low ; int dest High = high ; low += off ; high += off ; int mid = ( low + high ) > > > NUM ; merge Sort ( dest , src , low , mid , - off , c ) ; merge Sort ( dest , src , mid , high , - off , c ) ; if ( c . compare ( src [ mid - NUM ] , src [ mid ] ) <= NUM ) { System . arraycopy ( src , low , dest , dest Low , length ) ; return ; } for ( int i = dest Low , p = low , q = mid ; i < dest High ; i ++ ) { if ( q >= high || p < mid && c . compare ( src [ p ] , src [ q ] ) <= NUM ) dest [ i ] = src [ p ++ ] ; else dest [ i ] = src [ q ++ ] ; } }
@ Suppress Warnings ( { STRING , STRING } ) private static void merge Sort ( Object [ ] src , Object [ ] dest , int low , int high , int off , Comparator c ) { int length = high - low ; if ( length < INSERTIONSORT THRESHOLD ) { for ( int i = low ; i < high ; i ++ ) for ( int j = i ; j > low && c . compare ( dest [ j - NUM ] , dest [ j ] ) > NUM ; j -- ) swap ( dest , j , j - NUM ) ; return ; } int dest Low = low ; int dest High = high ; low += off ; high += off ; int mid = ( low + high ) > > > NUM ; merge Sort ( dest , src , low , mid , - off , c ) ; merge Sort ( dest , src , mid , high , - off , c ) ; if ( c . compare ( src [ mid - NUM ] , src [ mid ] ) <= NUM ) { System . arraycopy ( src , low , dest , dest Low , length ) ; return ; } for ( int i = dest Low , p = low , q = mid ; i < dest High ; i ++ ) { if ( q >= high || p < mid && c . compare ( src [ p ] , src [ q ] ) <= NUM ) dest [ i ] = src [ p ++ ] ; else dest [ i ] = src [ q ++ ] ; } }
@ Suppress Warnings ( { STRING , STRING } ) private static void merge Sort ( Object [ ] src , Object [ ] dest , int low , int high , int off , Comparator c ) { int length = high - low ; if ( length < INSERTIONSORT THRESHOLD ) { for ( int i = low ; i < high ; i ++ ) for ( int j = i ; j > low && c . compare ( dest [ j - NUM ] , dest [ j ] ) > NUM ; j -- ) swap ( dest , j , j - NUM ) ; return ; } int dest Low = low ; int dest High = high ; low += off ; high += off ; int mid = ( low + high ) > > > NUM ; merge Sort ( dest , src , low , mid , - off , c ) ; merge Sort ( dest , src , mid , high , - off , c ) ; if ( c . compare ( src [ mid - NUM ] , src [ mid ] ) <= NUM ) { System . arraycopy ( src , low , dest , dest Low , length ) ; return ; } for ( int i = dest Low , p = low , q = mid ; i < dest High ; i ++ ) { if ( q >= high || p < mid && c . compare ( src [ p ] , src [ q ] ) <= NUM ) dest [ i ] = src [ p ++ ] ; else dest [ i ] = src [ q ++ ] ; } }
public void update ( int n , byte [ ] b , int off , int len , Manifest Entry Verifier mev ) throws IO Exception { if ( n != - NUM ) { if ( parsing Block Or SF ) { baos . write ( b , off , n ) ; } else { mev . update ( b , off , n ) ; } } else { process Entry ( mev ) ; } }
public void clear ( ) { if ( m View Type Count == NUM ) { final Array List < View > scrap = m Current Scrap ; final int scrap Count = scrap . size ( ) ; for ( int i = NUM ; i < scrap Count ; i ++ ) { remove Detached View ( scrap . remove ( scrap Count - NUM - i ) , BOOL ) ; } } else { final int type Count = m View Type Count ; for ( int i = NUM ; i < type Count ; i ++ ) { final Array List < View > scrap = m Scrap Views [ i ] ; final int scrap Count = scrap . size ( ) ; for ( int j = NUM ; j < scrap Count ; j ++ ) { remove Detached View ( scrap . remove ( scrap Count - NUM - j ) , BOOL ) ; } } } if ( m Transient State Views != null ) { m Transient State Views . clear ( ) ; } }
public void test Get Version 30 ( ) throws Exception { String xml = WEBAPP 30 HEADER + STRING ; Web Xml web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( xml . get Bytes ( STRING ) ) , get Entity Resolver ( ) ) ; assert Equals ( Web Xml Version . V3 0 , web Xml . get Version ( ) ) ; }
public static < T > Set < T > to Set ( T obj 1 , T obj 2 ) { Set < T > the Set = new Linked Hash Set < T > ( ) ; the Set . add ( obj 1 ) ; the Set . add ( obj 2 ) ; return the Set ; }
private FC Zone Reference find FC Zone Reference For Vol Group Key ( URI export Group URI , URI volume URI , String ref Key , String [ ] new Or Existing ) { Map < String , FC Zone Reference > vol Ref Map = network Scheduler . make Export To Reference Map ( ref Key ) ; String vol Export Key = make 2 Uri Key ( volume URI , export Group URI ) ; if ( vol Ref Map . contains Key ( vol Export Key ) ) { FC Zone Reference ref = vol Ref Map . get ( vol Export Key ) ; if ( ref != null && ref . get Inactive ( ) == BOOL ) { log . info ( String . format ( STRING , volume URI , export Group URI , ref Key ) ) ; new Or Existing [ NUM ] = STRING ; return ref ; } } return null ; }
public void remove ( int i ) { if ( ( i >= array . length ) || ( i < NUM ) ) throw new Array Index Out Of Bounds Exception ( STRING + i + STRING + array . length ) ; NS Object [ ] new Array = new NS Object [ array . length - NUM ] ; System . arraycopy ( array , NUM , new Array , NUM , i ) ; System . arraycopy ( array , i + NUM , new Array , i , array . length - i - NUM ) ; array = new Array ; }
public Name add ( int posn , Rdn comp ) { if ( comp == null ) { throw new Null Pointer Exception ( STRING ) ; } rdns . add ( posn , comp ) ; unparsed = null ; return this ; }
public Name add ( int posn , Rdn comp ) { if ( comp == null ) { throw new Null Pointer Exception ( STRING ) ; } rdns . add ( posn , comp ) ; unparsed = null ; return this ; }
public void send Tams Message ( Tams Message m , Tams Listener tl ) { tm = m ; tmq . offer ( tm ) ; if ( tm . is Binary ( ) ) { } else { } send Message ( tm , tl ) ; }
public Initial Transition ( State < S , E > target , Action < S , E > action ) { super ( null , target , action != null ? Collections . singleton ( action ) : null , null , Transition Kind . INITIAL , null , null , null ) ; }
public void delete ( String name ) throws IO Exception { if ( name . equals Ignore Case ( DESCRIPTIONS ) ) { access Descriptions = new Array List < Access Description > ( ) ; } else { throw new IO Exception ( STRING + name + STRING + STRING ) ; } encode This ( ) ; }
public Set < ? extends Annotation Mirror > greatest Lower Bounds Type Variable ( Collection < ? extends Annotation Mirror > annos 1 , Collection < ? extends Annotation Mirror > annos 2 ) { Set < Annotation Mirror > result = Annotation Utils . create Annotation Set ( ) ; for ( Annotation Mirror top : get Top Annotations ( ) ) { Annotation Mirror anno 1 For Top = null ; for ( Annotation Mirror anno 1 : annos 1 ) { if ( is Subtype Type Variable ( anno 1 , top ) ) { anno 1 For Top = anno 1 ; } } Annotation Mirror anno 2 For Top = null ; for ( Annotation Mirror anno 2 : annos 2 ) { if ( is Subtype Type Variable ( anno 2 , top ) ) { anno 2 For Top = anno 2 ; } } Annotation Mirror t = greatest Lower Bound Type Variable ( anno 1 For Top , anno 2 For Top ) ; if ( t != null ) { result . add ( t ) ; } } return result ; }
public Set < ? extends Annotation Mirror > greatest Lower Bounds Type Variable ( Collection < ? extends Annotation Mirror > annos 1 , Collection < ? extends Annotation Mirror > annos 2 ) { Set < Annotation Mirror > result = Annotation Utils . create Annotation Set ( ) ; for ( Annotation Mirror top : get Top Annotations ( ) ) { Annotation Mirror anno 1 For Top = null ; for ( Annotation Mirror anno 1 : annos 1 ) { if ( is Subtype Type Variable ( anno 1 , top ) ) { anno 1 For Top = anno 1 ; } } Annotation Mirror anno 2 For Top = null ; for ( Annotation Mirror anno 2 : annos 2 ) { if ( is Subtype Type Variable ( anno 2 , top ) ) { anno 2 For Top = anno 2 ; } } Annotation Mirror t = greatest Lower Bound Type Variable ( anno 1 For Top , anno 2 For Top ) ; if ( t != null ) { result . add ( t ) ; } } return result ; }
public void on Tab Closure Committed ( long time , int id , boolean incognito ) { }
public void on Tab Closure Committed ( long time , int id , boolean incognito ) { }
public Raptor State ( int n Stops ) { this . best Times = new int [ n Stops ] ; this . best Non Transfer Times = new int [ n Stops ] ; Arrays . fill ( best Times , Raptor Worker . UNREACHED ) ; Arrays . fill ( best Non Transfer Times , Raptor Worker . UNREACHED ) ; this . previous Patterns = new int [ n Stops ] ; this . previous Stop = new int [ n Stops ] ; this . transfer Stop = new int [ n Stops ] ; Arrays . fill ( previous Patterns , - NUM ) ; Arrays . fill ( previous Stop , - NUM ) ; Arrays . fill ( transfer Stop , - NUM ) ; this . in Vehicle Travel Time = new int [ n Stops ] ; this . wait Time = new int [ n Stops ] ; this . non Transfer Wait Time = new int [ n Stops ] ; this . non Transfer In Vehicle Travel Time = new int [ n Stops ] ; }
public synchronized void rewind To ( long time ) { if ( time > current Track Time ) throw new Illegal Argument Exception ( STRING + time + STRING + current Track Time + STRING ) ; time = Math . max ( NUM , time ) ; time -= time % NUM ; current Track Time = time ; }
public synchronized void rewind To ( long time ) { if ( time > current Track Time ) throw new Illegal Argument Exception ( STRING + time + STRING + current Track Time + STRING ) ; time = Math . max ( NUM , time ) ; time -= time % NUM ; current Track Time = time ; }
public synchronized void rewind To ( long time ) { if ( time > current Track Time ) throw new Illegal Argument Exception ( STRING + time + STRING + current Track Time + STRING ) ; time = Math . max ( NUM , time ) ; time -= time % NUM ; current Track Time = time ; }
public byte [ ] filter ( byte [ ] buffer , int offset , int len ) { byte [ ] slices = get Slices ( buffer , offset , len ) ; if ( null == slices ) { return null ; } int insertion Point = find Insertion Point ( slices ) ; if ( insertion Point >= NUM ) { return buffer ; } if ( - NUM == insertion Point ) { if ( has Hinting ) { return Arrays . copy Of ( this . rangekeys , this . bounds [ NUM ] ) ; } else { return null ; } } if ( - nranges - NUM == insertion Point ) { if ( has Hinting ) { return EMPTY BYTE ARRAY ; } else { return null ; } } if ( - ( insertion Point + NUM ) % NUM == NUM ) { if ( has Hinting ) { int hint Offset = this . slices Length * ( - ( insertion Point + NUM ) ) ; return Arrays . copy Of Range ( this . rangekeys , hint Offset , this . bounds [ NUM ] ) ; } else { return null ; } } return buffer ; }
public byte [ ] filter ( byte [ ] buffer , int offset , int len ) { byte [ ] slices = get Slices ( buffer , offset , len ) ; if ( null == slices ) { return null ; } int insertion Point = find Insertion Point ( slices ) ; if ( insertion Point >= NUM ) { return buffer ; } if ( - NUM == insertion Point ) { if ( has Hinting ) { return Arrays . copy Of ( this . rangekeys , this . bounds [ NUM ] ) ; } else { return null ; } } if ( - nranges - NUM == insertion Point ) { if ( has Hinting ) { return EMPTY BYTE ARRAY ; } else { return null ; } } if ( - ( insertion Point + NUM ) % NUM == NUM ) { if ( has Hinting ) { int hint Offset = this . slices Length * ( - ( insertion Point + NUM ) ) ; return Arrays . copy Of Range ( this . rangekeys , hint Offset , this . bounds [ NUM ] ) ; } else { return null ; } } return buffer ; }
@ Override public Object annotation Button ( final Form Object form ) { final int subtype = form . get Parameter Constant ( Pdf Dictionary . Subtype ) ; if ( subtype == Pdf Dictionary . Popup ) { return create Annotation Popup ( form ) ; } if ( ! form . is Appearance Used ( ) ) { switch ( subtype ) { case Pdf Dictionary . Text : return create Annotation Text ( form ) ; case Pdf Dictionary . Free Text : return create Annotation Free Text ( form ) ; case Pdf Dictionary . Highlight : return create Anntoation Highlight ( form ) ; case Pdf Dictionary . Underline : return create Annotation Underline ( form ) ; case Pdf Dictionary . Ink : return create Annotation Ink ( form ) ; case Pdf Dictionary . Strick Out : return create Annotation Strike Out ( form ) ; } } return setup Annotation Button ( form ) ; }
public static void back And Forth ( HG Search Result < ? > rs , int window Size , int iteration ) { boolean advance = BOOL ; for ( int i = NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( window Size ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new Runtime Exception ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new Runtime Exception ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( window Size ) ) ; if ( ! rs . has Next ( ) ) { back ( rs , random ( window Size ) ) ; advance = BOOL ; } } else { back ( rs , random ( window Size ) ) ; if ( ! rs . has Prev ( ) ) { forward ( rs , random ( window Size ) ) ; advance = BOOL ; } } } }
public static void back And Forth ( HG Search Result < ? > rs , int window Size , int iteration ) { boolean advance = BOOL ; for ( int i = NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( window Size ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new Runtime Exception ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new Runtime Exception ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( window Size ) ) ; if ( ! rs . has Next ( ) ) { back ( rs , random ( window Size ) ) ; advance = BOOL ; } } else { back ( rs , random ( window Size ) ) ; if ( ! rs . has Prev ( ) ) { forward ( rs , random ( window Size ) ) ; advance = BOOL ; } } } }
public static void back And Forth ( HG Search Result < ? > rs , int window Size , int iteration ) { boolean advance = BOOL ; for ( int i = NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( window Size ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new Runtime Exception ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new Runtime Exception ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( window Size ) ) ; if ( ! rs . has Next ( ) ) { back ( rs , random ( window Size ) ) ; advance = BOOL ; } } else { back ( rs , random ( window Size ) ) ; if ( ! rs . has Prev ( ) ) { forward ( rs , random ( window Size ) ) ; advance = BOOL ; } } } }
public static void back And Forth ( HG Search Result < ? > rs , int window Size , int iteration ) { boolean advance = BOOL ; for ( int i = NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( window Size ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new Runtime Exception ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new Runtime Exception ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( window Size ) ) ; if ( ! rs . has Next ( ) ) { back ( rs , random ( window Size ) ) ; advance = BOOL ; } } else { back ( rs , random ( window Size ) ) ; if ( ! rs . has Prev ( ) ) { forward ( rs , random ( window Size ) ) ; advance = BOOL ; } } } }
public static void back And Forth ( HG Search Result < ? > rs , int window Size , int iteration ) { boolean advance = BOOL ; for ( int i = NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( window Size ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new Runtime Exception ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new Runtime Exception ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( window Size ) ) ; if ( ! rs . has Next ( ) ) { back ( rs , random ( window Size ) ) ; advance = BOOL ; } } else { back ( rs , random ( window Size ) ) ; if ( ! rs . has Prev ( ) ) { forward ( rs , random ( window Size ) ) ; advance = BOOL ; } } } }
public static void back And Forth ( HG Search Result < ? > rs , int window Size , int iteration ) { boolean advance = BOOL ; for ( int i = NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( window Size ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new Runtime Exception ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new Runtime Exception ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( window Size ) ) ; if ( ! rs . has Next ( ) ) { back ( rs , random ( window Size ) ) ; advance = BOOL ; } } else { back ( rs , random ( window Size ) ) ; if ( ! rs . has Prev ( ) ) { forward ( rs , random ( window Size ) ) ; advance = BOOL ; } } } }
public static void back And Forth ( HG Search Result < ? > rs , int window Size , int iteration ) { boolean advance = BOOL ; for ( int i = NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( window Size ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new Runtime Exception ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new Runtime Exception ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( window Size ) ) ; if ( ! rs . has Next ( ) ) { back ( rs , random ( window Size ) ) ; advance = BOOL ; } } else { back ( rs , random ( window Size ) ) ; if ( ! rs . has Prev ( ) ) { forward ( rs , random ( window Size ) ) ; advance = BOOL ; } } } }
public static void back And Forth ( HG Search Result < ? > rs , int window Size , int iteration ) { boolean advance = BOOL ; for ( int i = NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( window Size ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new Runtime Exception ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new Runtime Exception ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( window Size ) ) ; if ( ! rs . has Next ( ) ) { back ( rs , random ( window Size ) ) ; advance = BOOL ; } } else { back ( rs , random ( window Size ) ) ; if ( ! rs . has Prev ( ) ) { forward ( rs , random ( window Size ) ) ; advance = BOOL ; } } } }
public void wait Until Free ( ) { while ( is Busy ( ) ) { send Empty Message ( BLANK ) ; lock . lock ( ) ; try { if ( is Busy ( ) ) { busy Condition . await ( ) ; } } catch ( Interrupted Exception e ) { throw new Runtime Exception ( e ) ; } finally { lock . unlock ( ) ; } } }
void put ( final Object item ) { lbd . add ( item ) ; }
private static int Call Static Int Method V ( JNI Environment env , int class JREF , int method ID , Address arg Address ) throws Exception { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { Object return Obj = JNI Helpers . invoke With Var Arg ( method ID , arg Address , Type Reference . Int ) ; return Reflection . unwrap Int ( return Obj ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
private static int Call Static Int Method V ( JNI Environment env , int class JREF , int method ID , Address arg Address ) throws Exception { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { Object return Obj = JNI Helpers . invoke With Var Arg ( method ID , arg Address , Type Reference . Int ) ; return Reflection . unwrap Int ( return Obj ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
public static List Multimap < Category , Unary Rule > load Unary Rules ( final File file ) throws IO Exception { final Multimap < Category , Unary Rule > result = Hash Multimap . create ( ) ; final Lexicon lexicon = new Default Lexicon ( ) ; for ( String line : Util . read File ( file ) ) { if ( line . starts With ( STRING ) ) { continue ; } line = line . trim ( ) ; if ( line . is Empty ( ) ) { continue ; } final String [ ] fields = line . split ( STRING ) ; if ( fields . length != NUM && fields . length != NUM ) { throw new Error ( STRING + line ) ; } final String from = fields [ NUM ] ; final String to = fields [ NUM ] ; final Category cat = Category . make ( Category . value Of ( to ) , Slash . FWD , Category . value Of ( from ) ) ; Logic logic ; if ( fields . length == NUM ) { logic = Logic Parser . from String ( fields [ NUM ] , cat ) ; } else { logic = lexicon . get Entry ( null , STRING , cat , Coindexation . from String ( to + STRING + from , - NUM ) ) ; } result . put ( Category . value Of ( from ) , new Unary Rule ( result . size ( ) , from , to , logic ) ) ; } return Immutable List Multimap . copy Of ( result ) ; }
@ Override public UUID session Id ( ) { if ( session Id == null ) session Id = UUID . random UUID ( ) ; return session Id ; }
@ Override public UUID session Id ( ) { if ( session Id == null ) session Id = UUID . random UUID ( ) ; return session Id ; }
@ Override public UUID session Id ( ) { if ( session Id == null ) session Id = UUID . random UUID ( ) ; return session Id ; }
public void test no Resources Does Not Wait predeclare Locks unbounded Queue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = NUM ; final int ntasks = NUM ; properties . set Property ( Test Options . CORE POOL SIZE , STRING + nthreads ) ; properties . set Property ( Test Options . NTASKS , STRING + ntasks ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; final Result result = do Comparison Test ( properties ) ; assert Equals ( STRING , ntasks , Integer . parse Int ( result . get ( STRING ) ) ) ; assert Equals ( STRING , nthreads , Integer . parse Int ( result . get ( STRING ) ) ) ; }
public void test no Resources Does Not Wait predeclare Locks unbounded Queue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = NUM ; final int ntasks = NUM ; properties . set Property ( Test Options . CORE POOL SIZE , STRING + nthreads ) ; properties . set Property ( Test Options . NTASKS , STRING + ntasks ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; final Result result = do Comparison Test ( properties ) ; assert Equals ( STRING , ntasks , Integer . parse Int ( result . get ( STRING ) ) ) ; assert Equals ( STRING , nthreads , Integer . parse Int ( result . get ( STRING ) ) ) ; }
public void test no Resources Does Not Wait predeclare Locks unbounded Queue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = NUM ; final int ntasks = NUM ; properties . set Property ( Test Options . CORE POOL SIZE , STRING + nthreads ) ; properties . set Property ( Test Options . NTASKS , STRING + ntasks ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; final Result result = do Comparison Test ( properties ) ; assert Equals ( STRING , ntasks , Integer . parse Int ( result . get ( STRING ) ) ) ; assert Equals ( STRING , nthreads , Integer . parse Int ( result . get ( STRING ) ) ) ; }
public void test no Resources Does Not Wait predeclare Locks unbounded Queue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = NUM ; final int ntasks = NUM ; properties . set Property ( Test Options . CORE POOL SIZE , STRING + nthreads ) ; properties . set Property ( Test Options . NTASKS , STRING + ntasks ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; final Result result = do Comparison Test ( properties ) ; assert Equals ( STRING , ntasks , Integer . parse Int ( result . get ( STRING ) ) ) ; assert Equals ( STRING , nthreads , Integer . parse Int ( result . get ( STRING ) ) ) ; }
public void test no Resources Does Not Wait predeclare Locks unbounded Queue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = NUM ; final int ntasks = NUM ; properties . set Property ( Test Options . CORE POOL SIZE , STRING + nthreads ) ; properties . set Property ( Test Options . NTASKS , STRING + ntasks ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; final Result result = do Comparison Test ( properties ) ; assert Equals ( STRING , ntasks , Integer . parse Int ( result . get ( STRING ) ) ) ; assert Equals ( STRING , nthreads , Integer . parse Int ( result . get ( STRING ) ) ) ; }
public void test no Resources Does Not Wait predeclare Locks unbounded Queue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = NUM ; final int ntasks = NUM ; properties . set Property ( Test Options . CORE POOL SIZE , STRING + nthreads ) ; properties . set Property ( Test Options . NTASKS , STRING + ntasks ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; final Result result = do Comparison Test ( properties ) ; assert Equals ( STRING , ntasks , Integer . parse Int ( result . get ( STRING ) ) ) ; assert Equals ( STRING , nthreads , Integer . parse Int ( result . get ( STRING ) ) ) ; }
public void test no Resources Does Not Wait predeclare Locks unbounded Queue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = NUM ; final int ntasks = NUM ; properties . set Property ( Test Options . CORE POOL SIZE , STRING + nthreads ) ; properties . set Property ( Test Options . NTASKS , STRING + ntasks ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; final Result result = do Comparison Test ( properties ) ; assert Equals ( STRING , ntasks , Integer . parse Int ( result . get ( STRING ) ) ) ; assert Equals ( STRING , nthreads , Integer . parse Int ( result . get ( STRING ) ) ) ; }
public void test no Resources Does Not Wait predeclare Locks unbounded Queue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = NUM ; final int ntasks = NUM ; properties . set Property ( Test Options . CORE POOL SIZE , STRING + nthreads ) ; properties . set Property ( Test Options . NTASKS , STRING + ntasks ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; final Result result = do Comparison Test ( properties ) ; assert Equals ( STRING , ntasks , Integer . parse Int ( result . get ( STRING ) ) ) ; assert Equals ( STRING , nthreads , Integer . parse Int ( result . get ( STRING ) ) ) ; }
private String read ( ) throws IO Exception { String line = reader . read Line ( ) ; if ( line == null ) { throw new IO Exception ( STRING ) ; } for ( Iterator iter = communication Listeners . iterator ( ) ; iter . has Next ( ) ; ) { FTP Communication Listener l = ( FTP Communication Listener ) iter . next ( ) ; l . received ( line ) ; } return line ; }
protected int calc Text Width ( Paint paint , String demo Text ) { Rect r = new Rect ( ) ; paint . get Text Bounds ( demo Text , NUM , demo Text . length ( ) , r ) ; return r . width ( ) ; }
protected int calc Text Width ( Paint paint , String demo Text ) { Rect r = new Rect ( ) ; paint . get Text Bounds ( demo Text , NUM , demo Text . length ( ) , r ) ; return r . width ( ) ; }
public Signature Evaluator ( int suggested Buffer Size , boolean human Readable ) { this ( suggested Buffer Size , human Readable , new Signature Rules ( ) ) ; }
public static void for Each Token ( String string , String separator , Procedure < String > procedure ) { for ( String Tokenizer string Tokenizer = new String Tokenizer ( string , separator ) ; string Tokenizer . has More Tokens ( ) ; ) { String token = string Tokenizer . next Token ( ) ; procedure . value ( token ) ; } }
public static void for Each Token ( String string , String separator , Procedure < String > procedure ) { for ( String Tokenizer string Tokenizer = new String Tokenizer ( string , separator ) ; string Tokenizer . has More Tokens ( ) ; ) { String token = string Tokenizer . next Token ( ) ; procedure . value ( token ) ; } }
public final boolean is Good State ( TLC State state ) { return state . all Assigned ( ) ; }
public static String generate Scale Markers ( int protein Length , int max Num Scale Markers ) { if ( max Num Scale Markers < NUM ) { max Num Scale Markers = NUM ; } int scale = calc Scale ( protein Length , max Num Scale Markers ) ; String Builder sb = new String Builder ( STRING ) ; int index = NUM ; int num Remaining = protein Length ; while ( index <= protein Length ) { index += scale ; num Remaining -= scale ; sb . append ( STRING ) ; if ( ( num Remaining > NUM ) && ( num Remaining < scale ) ) { if ( num Remaining < ( scale / NUM ) ) { sb . append ( protein Length ) ; break ; } } if ( index >= protein Length ) { sb . append ( protein Length ) ; } else { sb . append ( index ) ; } } return sb . to String ( ) ; }
public static String generate Scale Markers ( int protein Length , int max Num Scale Markers ) { if ( max Num Scale Markers < NUM ) { max Num Scale Markers = NUM ; } int scale = calc Scale ( protein Length , max Num Scale Markers ) ; String Builder sb = new String Builder ( STRING ) ; int index = NUM ; int num Remaining = protein Length ; while ( index <= protein Length ) { index += scale ; num Remaining -= scale ; sb . append ( STRING ) ; if ( ( num Remaining > NUM ) && ( num Remaining < scale ) ) { if ( num Remaining < ( scale / NUM ) ) { sb . append ( protein Length ) ; break ; } } if ( index >= protein Length ) { sb . append ( protein Length ) ; } else { sb . append ( index ) ; } } return sb . to String ( ) ; }
public static String generate Scale Markers ( int protein Length , int max Num Scale Markers ) { if ( max Num Scale Markers < NUM ) { max Num Scale Markers = NUM ; } int scale = calc Scale ( protein Length , max Num Scale Markers ) ; String Builder sb = new String Builder ( STRING ) ; int index = NUM ; int num Remaining = protein Length ; while ( index <= protein Length ) { index += scale ; num Remaining -= scale ; sb . append ( STRING ) ; if ( ( num Remaining > NUM ) && ( num Remaining < scale ) ) { if ( num Remaining < ( scale / NUM ) ) { sb . append ( protein Length ) ; break ; } } if ( index >= protein Length ) { sb . append ( protein Length ) ; } else { sb . append ( index ) ; } } return sb . to String ( ) ; }
public void process Transaction Terminated ( Transaction Terminated Event transaction Terminated Event ) { }
void add Index ( Index index ) { indexes . add ( index ) ; }
public void add ( final int start , final int end , final byte status ) { final int s = start - m Start ; if ( s < m Interval . length && end > m Start ) { Arrays . fill ( m Interval , Math . max ( s , NUM ) , Math . min ( end - m Start , m Interval . length ) , status ) ; } }
@ Override public void init ( ) { }
protected static void draw Data Point ( double x , double y , double xprev , double yprev , int size , int shape , Graphics gx ) { draw Data Point ( x , y , size , shape , gx ) ; gx . draw Line ( ( int ) x , ( int ) y , ( int ) xprev , ( int ) yprev ) ; }
protected static void draw Data Point ( double x , double y , double xprev , double yprev , int size , int shape , Graphics gx ) { draw Data Point ( x , y , size , shape , gx ) ; gx . draw Line ( ( int ) x , ( int ) y , ( int ) xprev , ( int ) yprev ) ; }
protected static void draw Data Point ( double x , double y , double xprev , double yprev , int size , int shape , Graphics gx ) { draw Data Point ( x , y , size , shape , gx ) ; gx . draw Line ( ( int ) x , ( int ) y , ( int ) xprev , ( int ) yprev ) ; }
private Query Exp build Query Exp ( final String pid Attribute , final String [ ] attributes , final Object [ ] values ) { final Query Exp optional Attributes = build Optional Query Exp ( attributes , values ) ; Query Exp constraint ; if ( optional Attributes != null ) { constraint = Query . and ( optional Attributes , Query . eq ( Query . attr ( pid Attribute ) , Query . value ( this . pid ) ) ) ; } else { constraint = Query . eq ( Query . attr ( pid Attribute ) , Query . value ( this . pid ) ) ; } return constraint ; }
private Query Exp build Query Exp ( final String pid Attribute , final String [ ] attributes , final Object [ ] values ) { final Query Exp optional Attributes = build Optional Query Exp ( attributes , values ) ; Query Exp constraint ; if ( optional Attributes != null ) { constraint = Query . and ( optional Attributes , Query . eq ( Query . attr ( pid Attribute ) , Query . value ( this . pid ) ) ) ; } else { constraint = Query . eq ( Query . attr ( pid Attribute ) , Query . value ( this . pid ) ) ; } return constraint ; }
private void validate Will ( String dest , Object payload ) { if ( ( dest == null ) || ( payload == null ) ) { throw new Illegal Argument Exception ( ) ; } Mqtt Topic . validate ( dest , BOOL ) ; }
public Ranking Image List Provider in Hours ( int hours ) { m Time = Integer . to String ( hours ) + STRING ; return this ; }
public static Position from Radians ( double latitude Radians , double longitude Radians , double altitude ) { Position pos = new Position ( ) ; pos . latitude = Math . to Degrees ( latitude Radians ) ; pos . longitude = Math . to Degrees ( longitude Radians ) ; pos . altitude = altitude ; return pos ; }
public void reset Name For HTML ( String new Name ) { glyphs . font Name = new Name ; glyphs . base Font Name = new Name ; }
public void reset Name For HTML ( String new Name ) { glyphs . font Name = new Name ; glyphs . base Font Name = new Name ; }
public void add ( String path ) { deleted Files . add ( path ) ; }
public void add ( String path ) { deleted Files . add ( path ) ; }
public void add ( String path ) { deleted Files . add ( path ) ; }
public static void main ( String [ ] args ) { Timer timer = new Timer ( STRING ) ; Timer overall Timer = new Timer ( STRING ) ; timer . show Times ( NUM ) ; overall Timer . start ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { timer . start ( ) ; try { Thread . sleep ( i * NUM ) ; } catch ( Interrupted Exception e ) { } timer . stop ( BOOL ) ; } overall Timer . stop ( ) ; timer . show Times ( overall Timer . get Current Time ( ) ) ; overall Timer . show Times ( ) ; }
public static void main ( String [ ] args ) { Timer timer = new Timer ( STRING ) ; Timer overall Timer = new Timer ( STRING ) ; timer . show Times ( NUM ) ; overall Timer . start ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { timer . start ( ) ; try { Thread . sleep ( i * NUM ) ; } catch ( Interrupted Exception e ) { } timer . stop ( BOOL ) ; } overall Timer . stop ( ) ; timer . show Times ( overall Timer . get Current Time ( ) ) ; overall Timer . show Times ( ) ; }
public static void main ( String [ ] args ) { Timer timer = new Timer ( STRING ) ; Timer overall Timer = new Timer ( STRING ) ; timer . show Times ( NUM ) ; overall Timer . start ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { timer . start ( ) ; try { Thread . sleep ( i * NUM ) ; } catch ( Interrupted Exception e ) { } timer . stop ( BOOL ) ; } overall Timer . stop ( ) ; timer . show Times ( overall Timer . get Current Time ( ) ) ; overall Timer . show Times ( ) ; }
@ Override protected void send Data ( final Output Stream out ) throws IO Exception { LOG . trace ( STRING ) ; if ( length Of Data ( ) == NUM ) { LOG . debug ( STRING ) ; return ; } final byte [ ] tmp = new byte [ NUM ] ; final Input Stream instream = source . create Input Stream ( ) ; try { int len ; while ( ( len = instream . read ( tmp ) ) >= NUM ) { out . write ( tmp , NUM , len ) ; } } finally { instream . close ( ) ; } }
@ Override protected void send Data ( final Output Stream out ) throws IO Exception { LOG . trace ( STRING ) ; if ( length Of Data ( ) == NUM ) { LOG . debug ( STRING ) ; return ; } final byte [ ] tmp = new byte [ NUM ] ; final Input Stream instream = source . create Input Stream ( ) ; try { int len ; while ( ( len = instream . read ( tmp ) ) >= NUM ) { out . write ( tmp , NUM , len ) ; } } finally { instream . close ( ) ; } }
public void generate Add Animation ( View child , boolean from More Card ) { if ( m Is Expanded && m Animations Enabled && ! m Change Position In Progress ) { m Children To Add Animated . add ( child ) ; if ( from More Card ) { m From More Card Additions . add ( child ) ; } m Needs Animation = BOOL ; } }
public void stop ( ) { synchronized ( lock ) { scheduler Service . shutdown Now ( ) ; state = State . STOPPED ; } }
public void stop ( ) { synchronized ( lock ) { scheduler Service . shutdown Now ( ) ; state = State . STOPPED ; } }
public void stop ( ) { synchronized ( lock ) { scheduler Service . shutdown Now ( ) ; state = State . STOPPED ; } }
private int match String ( String text , int start , int field , Map < String , Integer > data , Calendar Builder calb ) { if ( data != null ) { if ( data instanceof Sorted Map ) { for ( String name : data . key Set ( ) ) { if ( text . region Matches ( BOOL , start , name , NUM , name . length ( ) ) ) { calb . set ( field , data . get ( name ) ) ; return start + name . length ( ) ; } } return - start ; } String best Match = null ; for ( String name : data . key Set ( ) ) { int length = name . length ( ) ; if ( best Match == null || length > best Match . length ( ) ) { if ( text . region Matches ( BOOL , start , name , NUM , length ) ) { best Match = name ; } } } if ( best Match != null ) { calb . set ( field , data . get ( best Match ) ) ; return start + best Match . length ( ) ; } } return - start ; }
public static String remove Backslash Escapes ( final String s ) { final String Builder sb = new String Builder ( ) ; for ( int k = NUM ; k < s . length ( ) ; k ++ ) { final char c = s . char At ( k ) ; if ( c == STRING ) { if ( ++ k == s . length ( ) ) { break ; } final char d = s . char At ( k ) ; switch ( d ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; default : sb . append ( d ) ; break ; } } else if ( c == STRING ) { break ; } else { sb . append ( c ) ; } } return sb . to String ( ) ; }
void process File ( Resource resource , File file , File dest Dir ) throws IO Exception ;
void process File ( Resource resource , File file , File dest Dir ) throws IO Exception ;
void process File ( Resource resource , File file , File dest Dir ) throws IO Exception ;
void process File ( Resource resource , File file , File dest Dir ) throws IO Exception ;
void process File ( Resource resource , File file , File dest Dir ) throws IO Exception ;
void process File ( Resource resource , File file , File dest Dir ) throws IO Exception ;
public void add Unmanaged Target Volume To Update ( Un Managed Volume volume ) { if ( null == unmanaged Target Volumes To Update ) { unmanaged Target Volumes To Update = new Array List < Un Managed Volume > ( ) ; } unmanaged Target Volumes To Update . add ( volume ) ; }
protected final Configuration Loader build Configuration Loader ( ) { Dimension Loader dimension Loader = get Dimension Loader ( ) ; Table Loader table Loader = get Table Loader ( ) ; Metric Loader metric Loader = get Metric Loader ( ) ; return build Configuration Loader ( dimension Loader , metric Loader , table Loader ) ; }
public long elapsed ( ) { return MILLISECONDS . convert ( System . nano Time ( ) - start Time Nanos , NANOSECONDS ) ; }
public void replace FD Violating Tuples With Missing ( ) { for ( String premise : F Ds . key Set ( ) ) { Array List < Integer > attr Indexes = new Array List < Integer > ( ) ; attr Indexes . add ( Integer . parse Int ( premise ) ) ; for ( String RHS : F Ds . get ( premise ) ) { attr Indexes . add ( Integer . parse Int ( RHS ) ) ; } set Missing At Index ( violated , Util . convert Integers ( attr Indexes ) ) ; } }
public void replace FD Violating Tuples With Missing ( ) { for ( String premise : F Ds . key Set ( ) ) { Array List < Integer > attr Indexes = new Array List < Integer > ( ) ; attr Indexes . add ( Integer . parse Int ( premise ) ) ; for ( String RHS : F Ds . get ( premise ) ) { attr Indexes . add ( Integer . parse Int ( RHS ) ) ; } set Missing At Index ( violated , Util . convert Integers ( attr Indexes ) ) ; } }
public static boolean assert Cumulative ( final double [ ] da ) { final double tolerance = NUM ; Exam . assert True ( Utils . real Format Array ( da ) , da . length > NUM ) ; double prev = Double . NEGATIVE INFINITY ; for ( final double d : da ) { Exam . assert True ( Utils . real Format ( d ) , d >= NUM && d <= ( NUM + tolerance ) && ! Double . is Na N ( d ) ) ; Exam . assert True ( prev <= d ) ; prev = d ; } if ( check Equals ( NUM , prev , tolerance ) ) { return BOOL ; } throw new Exam . Exam Exception ( Utils . real Format Array ( da ) ) ; }
public static boolean assert Cumulative ( final double [ ] da ) { final double tolerance = NUM ; Exam . assert True ( Utils . real Format Array ( da ) , da . length > NUM ) ; double prev = Double . NEGATIVE INFINITY ; for ( final double d : da ) { Exam . assert True ( Utils . real Format ( d ) , d >= NUM && d <= ( NUM + tolerance ) && ! Double . is Na N ( d ) ) ; Exam . assert True ( prev <= d ) ; prev = d ; } if ( check Equals ( NUM , prev , tolerance ) ) { return BOOL ; } throw new Exam . Exam Exception ( Utils . real Format Array ( da ) ) ; }
public static boolean assert Cumulative ( final double [ ] da ) { final double tolerance = NUM ; Exam . assert True ( Utils . real Format Array ( da ) , da . length > NUM ) ; double prev = Double . NEGATIVE INFINITY ; for ( final double d : da ) { Exam . assert True ( Utils . real Format ( d ) , d >= NUM && d <= ( NUM + tolerance ) && ! Double . is Na N ( d ) ) ; Exam . assert True ( prev <= d ) ; prev = d ; } if ( check Equals ( NUM , prev , tolerance ) ) { return BOOL ; } throw new Exam . Exam Exception ( Utils . real Format Array ( da ) ) ; }
public static boolean assert Cumulative ( final double [ ] da ) { final double tolerance = NUM ; Exam . assert True ( Utils . real Format Array ( da ) , da . length > NUM ) ; double prev = Double . NEGATIVE INFINITY ; for ( final double d : da ) { Exam . assert True ( Utils . real Format ( d ) , d >= NUM && d <= ( NUM + tolerance ) && ! Double . is Na N ( d ) ) ; Exam . assert True ( prev <= d ) ; prev = d ; } if ( check Equals ( NUM , prev , tolerance ) ) { return BOOL ; } throw new Exam . Exam Exception ( Utils . real Format Array ( da ) ) ; }
private boolean is obstacle clearance ( Brd Item curr item ) { boolean is obstacle = curr item . is obstacle ( this ) ; if ( ! is obstacle ) return BOOL ; if ( ! ( this instanceof Brd Tracep && curr item instanceof Brd Tracep ) ) return BOOL ; Brd Tracep this trace = ( Brd Tracep ) this ; boolean contact found = BOOL ; Pla Point contact point = this trace . corner first ( ) ; Collection < Brd Item > curr contacts = this trace . get normal contacts ( contact point , BOOL ) ; if ( curr contacts . contains ( curr item ) ) contact found = BOOL ; if ( ! contact found ) { contact point = this trace . corner last ( ) ; curr contacts = this trace . get normal contacts ( contact point , BOOL ) ; if ( curr contacts . contains ( curr item ) ) contact found = BOOL ; } if ( ! contact found ) return BOOL ; for ( Brd Item curr contact : curr contacts ) { if ( ! ( curr contact instanceof Brd Abit Pin ) ) continue ; if ( curr contact . shares net ( this ) && curr contact . shares net ( curr item ) ) return BOOL ; } return BOOL ; }
private boolean is obstacle clearance ( Brd Item curr item ) { boolean is obstacle = curr item . is obstacle ( this ) ; if ( ! is obstacle ) return BOOL ; if ( ! ( this instanceof Brd Tracep && curr item instanceof Brd Tracep ) ) return BOOL ; Brd Tracep this trace = ( Brd Tracep ) this ; boolean contact found = BOOL ; Pla Point contact point = this trace . corner first ( ) ; Collection < Brd Item > curr contacts = this trace . get normal contacts ( contact point , BOOL ) ; if ( curr contacts . contains ( curr item ) ) contact found = BOOL ; if ( ! contact found ) { contact point = this trace . corner last ( ) ; curr contacts = this trace . get normal contacts ( contact point , BOOL ) ; if ( curr contacts . contains ( curr item ) ) contact found = BOOL ; } if ( ! contact found ) return BOOL ; for ( Brd Item curr contact : curr contacts ) { if ( ! ( curr contact instanceof Brd Abit Pin ) ) continue ; if ( curr contact . shares net ( this ) && curr contact . shares net ( curr item ) ) return BOOL ; } return BOOL ; }
public void add Listener ( Listener a Listener ) { if ( a Listener == null ) return ; if ( hex Edit Control == null ) { if ( list Of Status Changed Listeners == null ) list Of Status Changed Listeners = new Array List < > ( ) ; list Of Status Changed Listeners . add ( a Listener ) ; } else { hex Edit Control . add Listener ( SWT . Modify , a Listener ) ; } }
@ Suppress Warnings ( STRING ) private Object from Reflection Type ( final Object value ) { Field Descriptor descriptor = get Descriptor ( ) ; if ( descriptor . is Repeated ( ) ) { if ( descriptor . get Java Type ( ) == Field Descriptor . Java Type . MESSAGE || descriptor . get Java Type ( ) == Field Descriptor . Java Type . ENUM ) { final List result = new Array List ( ) ; for ( final Object element : ( List ) value ) { result . add ( singular From Reflection Type ( element ) ) ; } return result ; } else { return value ; } } else { return singular From Reflection Type ( value ) ; } }
@ Suppress Warnings ( STRING ) private Object from Reflection Type ( final Object value ) { Field Descriptor descriptor = get Descriptor ( ) ; if ( descriptor . is Repeated ( ) ) { if ( descriptor . get Java Type ( ) == Field Descriptor . Java Type . MESSAGE || descriptor . get Java Type ( ) == Field Descriptor . Java Type . ENUM ) { final List result = new Array List ( ) ; for ( final Object element : ( List ) value ) { result . add ( singular From Reflection Type ( element ) ) ; } return result ; } else { return value ; } } else { return singular From Reflection Type ( value ) ; } }
@ Suppress Warnings ( STRING ) private Object from Reflection Type ( final Object value ) { Field Descriptor descriptor = get Descriptor ( ) ; if ( descriptor . is Repeated ( ) ) { if ( descriptor . get Java Type ( ) == Field Descriptor . Java Type . MESSAGE || descriptor . get Java Type ( ) == Field Descriptor . Java Type . ENUM ) { final List result = new Array List ( ) ; for ( final Object element : ( List ) value ) { result . add ( singular From Reflection Type ( element ) ) ; } return result ; } else { return value ; } } else { return singular From Reflection Type ( value ) ; } }
@ Suppress Warnings ( STRING ) private Object from Reflection Type ( final Object value ) { Field Descriptor descriptor = get Descriptor ( ) ; if ( descriptor . is Repeated ( ) ) { if ( descriptor . get Java Type ( ) == Field Descriptor . Java Type . MESSAGE || descriptor . get Java Type ( ) == Field Descriptor . Java Type . ENUM ) { final List result = new Array List ( ) ; for ( final Object element : ( List ) value ) { result . add ( singular From Reflection Type ( element ) ) ; } return result ; } else { return value ; } } else { return singular From Reflection Type ( value ) ; } }
public void flush ( ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . flush ( ) ; }
public void flush ( ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . flush ( ) ; }
public void flush ( ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . flush ( ) ; }
public void flush ( ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . flush ( ) ; }
@ Truffle Boundary static void exception Event For Client Instrument ( Event Binding < ? > b , String event Name , Throwable t ) { assert ! b . is Language Binding ( ) ; if ( t instanceof Thread Death ) { throw ( Thread Death ) t ; } Instrument Client Instrumenter instrumenter = ( Instrument Client Instrumenter ) b . get Instrumenter ( ) ; Class < ? > instrument Class = instrumenter . get Instrument Class ( ) ; String message = String . format ( STRING , event Name , instrument Class . get Name ( ) , b . get Element ( ) ) ; Exception exception = new Exception ( message , t ) ; Print Stream stream = new Print Stream ( instrumenter . get Env ( ) . err ( ) ) ; exception . print Stack Trace ( stream ) ; }
@ Truffle Boundary static void exception Event For Client Instrument ( Event Binding < ? > b , String event Name , Throwable t ) { assert ! b . is Language Binding ( ) ; if ( t instanceof Thread Death ) { throw ( Thread Death ) t ; } Instrument Client Instrumenter instrumenter = ( Instrument Client Instrumenter ) b . get Instrumenter ( ) ; Class < ? > instrument Class = instrumenter . get Instrument Class ( ) ; String message = String . format ( STRING , event Name , instrument Class . get Name ( ) , b . get Element ( ) ) ; Exception exception = new Exception ( message , t ) ; Print Stream stream = new Print Stream ( instrumenter . get Env ( ) . err ( ) ) ; exception . print Stack Trace ( stream ) ; }
@ Truffle Boundary static void exception Event For Client Instrument ( Event Binding < ? > b , String event Name , Throwable t ) { assert ! b . is Language Binding ( ) ; if ( t instanceof Thread Death ) { throw ( Thread Death ) t ; } Instrument Client Instrumenter instrumenter = ( Instrument Client Instrumenter ) b . get Instrumenter ( ) ; Class < ? > instrument Class = instrumenter . get Instrument Class ( ) ; String message = String . format ( STRING , event Name , instrument Class . get Name ( ) , b . get Element ( ) ) ; Exception exception = new Exception ( message , t ) ; Print Stream stream = new Print Stream ( instrumenter . get Env ( ) . err ( ) ) ; exception . print Stack Trace ( stream ) ; }
void terminated Request ( Integer index ) { servers Counters . decrement And Get ( index ) ; }
@ Override public int following ( int offset ) { Character Iterator text = get Text ( ) ; check Offset ( offset , text ) ; text . set Index ( offset ) ; if ( offset == text . get Begin Index ( ) ) { cached Last Known Break = handle Next ( ) ; return cached Last Known Break ; } int result = cached Last Known Break ; if ( result >= offset || result <= Break Iterator . DONE ) { result = handle Previous ( ) ; } else { text . set Index ( result ) ; } while ( result != Break Iterator . DONE && result <= offset ) { result = handle Next ( ) ; } cached Last Known Break = result ; return result ; }
public static Set combine O Cs ( Set one , Set two ) { if ( one == null || one . is Empty ( ) ) { return two ; } if ( two == null || two . is Empty ( ) ) { return one ; } Set result Set = new Hash Set ( ) ; Iterator itr 1 = one . iterator ( ) ; while ( itr 1 . has Next ( ) ) { String value 1 = ( String ) itr 1 . next ( ) ; result Set . add ( value 1 . to Lower Case ( ) ) ; } Iterator itr 2 = two . iterator ( ) ; while ( itr 2 . has Next ( ) ) { String value 2 = ( String ) itr 2 . next ( ) ; result Set . add ( value 2 . to Lower Case ( ) ) ; } return result Set ; }
public static Set combine O Cs ( Set one , Set two ) { if ( one == null || one . is Empty ( ) ) { return two ; } if ( two == null || two . is Empty ( ) ) { return one ; } Set result Set = new Hash Set ( ) ; Iterator itr 1 = one . iterator ( ) ; while ( itr 1 . has Next ( ) ) { String value 1 = ( String ) itr 1 . next ( ) ; result Set . add ( value 1 . to Lower Case ( ) ) ; } Iterator itr 2 = two . iterator ( ) ; while ( itr 2 . has Next ( ) ) { String value 2 = ( String ) itr 2 . next ( ) ; result Set . add ( value 2 . to Lower Case ( ) ) ; } return result Set ; }
public static Set combine O Cs ( Set one , Set two ) { if ( one == null || one . is Empty ( ) ) { return two ; } if ( two == null || two . is Empty ( ) ) { return one ; } Set result Set = new Hash Set ( ) ; Iterator itr 1 = one . iterator ( ) ; while ( itr 1 . has Next ( ) ) { String value 1 = ( String ) itr 1 . next ( ) ; result Set . add ( value 1 . to Lower Case ( ) ) ; } Iterator itr 2 = two . iterator ( ) ; while ( itr 2 . has Next ( ) ) { String value 2 = ( String ) itr 2 . next ( ) ; result Set . add ( value 2 . to Lower Case ( ) ) ; } return result Set ; }
public static Set combine O Cs ( Set one , Set two ) { if ( one == null || one . is Empty ( ) ) { return two ; } if ( two == null || two . is Empty ( ) ) { return one ; } Set result Set = new Hash Set ( ) ; Iterator itr 1 = one . iterator ( ) ; while ( itr 1 . has Next ( ) ) { String value 1 = ( String ) itr 1 . next ( ) ; result Set . add ( value 1 . to Lower Case ( ) ) ; } Iterator itr 2 = two . iterator ( ) ; while ( itr 2 . has Next ( ) ) { String value 2 = ( String ) itr 2 . next ( ) ; result Set . add ( value 2 . to Lower Case ( ) ) ; } return result Set ; }
public static Set combine O Cs ( Set one , Set two ) { if ( one == null || one . is Empty ( ) ) { return two ; } if ( two == null || two . is Empty ( ) ) { return one ; } Set result Set = new Hash Set ( ) ; Iterator itr 1 = one . iterator ( ) ; while ( itr 1 . has Next ( ) ) { String value 1 = ( String ) itr 1 . next ( ) ; result Set . add ( value 1 . to Lower Case ( ) ) ; } Iterator itr 2 = two . iterator ( ) ; while ( itr 2 . has Next ( ) ) { String value 2 = ( String ) itr 2 . next ( ) ; result Set . add ( value 2 . to Lower Case ( ) ) ; } return result Set ; }
public static Set combine O Cs ( Set one , Set two ) { if ( one == null || one . is Empty ( ) ) { return two ; } if ( two == null || two . is Empty ( ) ) { return one ; } Set result Set = new Hash Set ( ) ; Iterator itr 1 = one . iterator ( ) ; while ( itr 1 . has Next ( ) ) { String value 1 = ( String ) itr 1 . next ( ) ; result Set . add ( value 1 . to Lower Case ( ) ) ; } Iterator itr 2 = two . iterator ( ) ; while ( itr 2 . has Next ( ) ) { String value 2 = ( String ) itr 2 . next ( ) ; result Set . add ( value 2 . to Lower Case ( ) ) ; } return result Set ; }
public static Set combine O Cs ( Set one , Set two ) { if ( one == null || one . is Empty ( ) ) { return two ; } if ( two == null || two . is Empty ( ) ) { return one ; } Set result Set = new Hash Set ( ) ; Iterator itr 1 = one . iterator ( ) ; while ( itr 1 . has Next ( ) ) { String value 1 = ( String ) itr 1 . next ( ) ; result Set . add ( value 1 . to Lower Case ( ) ) ; } Iterator itr 2 = two . iterator ( ) ; while ( itr 2 . has Next ( ) ) { String value 2 = ( String ) itr 2 . next ( ) ; result Set . add ( value 2 . to Lower Case ( ) ) ; } return result Set ; }
public static Set combine O Cs ( Set one , Set two ) { if ( one == null || one . is Empty ( ) ) { return two ; } if ( two == null || two . is Empty ( ) ) { return one ; } Set result Set = new Hash Set ( ) ; Iterator itr 1 = one . iterator ( ) ; while ( itr 1 . has Next ( ) ) { String value 1 = ( String ) itr 1 . next ( ) ; result Set . add ( value 1 . to Lower Case ( ) ) ; } Iterator itr 2 = two . iterator ( ) ; while ( itr 2 . has Next ( ) ) { String value 2 = ( String ) itr 2 . next ( ) ; result Set . add ( value 2 . to Lower Case ( ) ) ; } return result Set ; }
@ Override public void closing OK ( ) { List < Add User Fields . Attribute Spec > specs = new Array List < Add User Fields . Attribute Spec > ( ) ; for ( int i = NUM ; i < m list Model . size ( ) ; i ++ ) { Add User Fields . Attribute Spec a = ( Add User Fields . Attribute Spec ) m list Model . element At ( i ) ; specs . add ( a ) ; } if ( m modify L != null ) { m modify L . set Modified Status ( Add User Fields Customizer . this , BOOL ) ; } m filter . set Attribute Specs ( specs ) ; }
@ Override public void closing OK ( ) { List < Add User Fields . Attribute Spec > specs = new Array List < Add User Fields . Attribute Spec > ( ) ; for ( int i = NUM ; i < m list Model . size ( ) ; i ++ ) { Add User Fields . Attribute Spec a = ( Add User Fields . Attribute Spec ) m list Model . element At ( i ) ; specs . add ( a ) ; } if ( m modify L != null ) { m modify L . set Modified Status ( Add User Fields Customizer . this , BOOL ) ; } m filter . set Attribute Specs ( specs ) ; }
@ Override public void closing OK ( ) { List < Add User Fields . Attribute Spec > specs = new Array List < Add User Fields . Attribute Spec > ( ) ; for ( int i = NUM ; i < m list Model . size ( ) ; i ++ ) { Add User Fields . Attribute Spec a = ( Add User Fields . Attribute Spec ) m list Model . element At ( i ) ; specs . add ( a ) ; } if ( m modify L != null ) { m modify L . set Modified Status ( Add User Fields Customizer . this , BOOL ) ; } m filter . set Attribute Specs ( specs ) ; }
public static char [ ] create Method Signature ( char [ ] [ ] parameter Types , char [ ] return Type ) { int parameter Types Length = parameter Types . length ; int parameter Length = NUM ; for ( int i = NUM ; i < parameter Types Length ; i ++ ) { parameter Length += parameter Types [ i ] . length ; } int return Type Length = return Type . length ; char [ ] result = new char [ NUM + parameter Length + NUM + return Type Length ] ; result [ NUM ] = C PARAM START ; int index = NUM ; for ( int i = NUM ; i < parameter Types Length ; i ++ ) { char [ ] parameter Type = parameter Types [ i ] ; int length = parameter Type . length ; System . arraycopy ( parameter Type , NUM , result , index , length ) ; index += length ; } result [ index ] = C PARAM END ; System . arraycopy ( return Type , NUM , result , index + NUM , return Type Length ) ; return result ; }
public static String join String List ( List < String > str List , String delimit ) { Iterator < String > entries = str List . iterator ( ) ; String Builder builder = new String Builder ( ) ; while ( entries . has Next ( ) ) { builder . append ( entries . next ( ) ) ; if ( entries . has Next ( ) ) { builder . append ( delimit ) ; } } return builder . to String ( ) ; }
public String lookup ( String data ) { Iterator < String > it = map . get Prefixed By ( data ) ; if ( ! it . has Next ( ) ) return null ; return it . next ( ) ; }
public String lookup ( String data ) { Iterator < String > it = map . get Prefixed By ( data ) ; if ( ! it . has Next ( ) ) return null ; return it . next ( ) ; }
public static String extract Uri From Address ( String addr ) { String uri = addr ; int index = addr . index Of ( STRING ) ; if ( index != - NUM ) { uri = addr . substring ( index + NUM , addr . index Of ( STRING , index ) ) ; } return uri ; }
private Set merge Set ( Set < String > set 1 , Set < String > set 2 ) { if ( set 1 == null || set 1 . is Empty ( ) ) { if ( set 2 == null || set 2 . is Empty ( ) ) { return Collections . EMPTY SET ; } else { return set 2 ; } } else { if ( set 2 == null || set 2 . is Empty ( ) ) { return set 1 ; } else { Set < String > return Set = new Hash Set < String > ( set 1 ) ; return Set . add All ( set 2 ) ; return return Set ; } } }
private Set merge Set ( Set < String > set 1 , Set < String > set 2 ) { if ( set 1 == null || set 1 . is Empty ( ) ) { if ( set 2 == null || set 2 . is Empty ( ) ) { return Collections . EMPTY SET ; } else { return set 2 ; } } else { if ( set 2 == null || set 2 . is Empty ( ) ) { return set 1 ; } else { Set < String > return Set = new Hash Set < String > ( set 1 ) ; return Set . add All ( set 2 ) ; return return Set ; } } }
public boolean remove Row ( int row ) { if ( m rows . is Valid Row ( row ) ) { fire Table Event ( row , row , Table Model Event . ALL COLUMNS , Table Model Event . DELETE ) ; m tuples . invalidate ( row ) ; m rows . release Row ( row ) ; for ( Iterator cols = get Columns ( ) ; cols . has Next ( ) ; ) { Column c = ( Column ) cols . next ( ) ; c . revert To Default ( row ) ; } return BOOL ; } return BOOL ; }
public boolean opt Boolean ( int index ) { return opt Boolean ( index , BOOL ) ; }
public static Structural Typing Result result ( Type Ref left , Type Ref right , List < String > missing Members , List < String > wrong Members Errors ) { if ( missing Members . is Empty ( ) && wrong Members Errors . is Empty ( ) ) { return success ( ) ; } else { String msg = left . get Type Ref As String ( ) + STRING + right . get Type Ref As String ( ) + STRING ; if ( ! missing Members . is Empty ( ) ) { msg += STRING + missing Members . get ( NUM ) ; if ( missing Members . size ( ) > NUM ) { msg += STRING + ( missing Members . size ( ) - NUM ) + STRING ; } } if ( ! wrong Members Errors . is Empty ( ) ) { if ( ! missing Members . is Empty ( ) ) { msg += STRING ; } msg += wrong Members Errors . get ( NUM ) ; if ( wrong Members Errors . size ( ) > NUM ) { msg += STRING + ( wrong Members Errors . size ( ) - NUM ) + STRING ; } } return failure ( msg ) ; } }
private Watcher init Watcher ( Solr Zk Client zk Client ) { wrapped Watcher = new Process State Watcher ( ) ; return zk Client . wrap Watcher ( wrapped Watcher ) ; }
private Watcher init Watcher ( Solr Zk Client zk Client ) { wrapped Watcher = new Process State Watcher ( ) ; return zk Client . wrap Watcher ( wrapped Watcher ) ; }
private Watcher init Watcher ( Solr Zk Client zk Client ) { wrapped Watcher = new Process State Watcher ( ) ; return zk Client . wrap Watcher ( wrapped Watcher ) ; }
private Watcher init Watcher ( Solr Zk Client zk Client ) { wrapped Watcher = new Process State Watcher ( ) ; return zk Client . wrap Watcher ( wrapped Watcher ) ; }
public static byte [ ] string To Gsm 7 Bit Packed With Header ( String data , byte [ ] header , int language Table , int language Shift Table ) throws Encode Exception { if ( header == null || header . length == NUM ) { return string To Gsm 7 Bit Packed ( data , language Table , language Shift Table ) ; } int header Bits = ( header . length + NUM ) * NUM ; int header Septets = ( header Bits + NUM ) / NUM ; byte [ ] ret = string To Gsm 7 Bit Packed ( data , header Septets , BOOL , language Table , language Shift Table ) ; ret [ NUM ] = ( byte ) header . length ; System . arraycopy ( header , NUM , ret , NUM , header . length ) ; return ret ; }
public static byte [ ] string To Gsm 7 Bit Packed With Header ( String data , byte [ ] header , int language Table , int language Shift Table ) throws Encode Exception { if ( header == null || header . length == NUM ) { return string To Gsm 7 Bit Packed ( data , language Table , language Shift Table ) ; } int header Bits = ( header . length + NUM ) * NUM ; int header Septets = ( header Bits + NUM ) / NUM ; byte [ ] ret = string To Gsm 7 Bit Packed ( data , header Septets , BOOL , language Table , language Shift Table ) ; ret [ NUM ] = ( byte ) header . length ; System . arraycopy ( header , NUM , ret , NUM , header . length ) ; return ret ; }
public static byte [ ] string To Gsm 7 Bit Packed With Header ( String data , byte [ ] header , int language Table , int language Shift Table ) throws Encode Exception { if ( header == null || header . length == NUM ) { return string To Gsm 7 Bit Packed ( data , language Table , language Shift Table ) ; } int header Bits = ( header . length + NUM ) * NUM ; int header Septets = ( header Bits + NUM ) / NUM ; byte [ ] ret = string To Gsm 7 Bit Packed ( data , header Septets , BOOL , language Table , language Shift Table ) ; ret [ NUM ] = ( byte ) header . length ; System . arraycopy ( header , NUM , ret , NUM , header . length ) ; return ret ; }
public static byte [ ] string To Gsm 7 Bit Packed With Header ( String data , byte [ ] header , int language Table , int language Shift Table ) throws Encode Exception { if ( header == null || header . length == NUM ) { return string To Gsm 7 Bit Packed ( data , language Table , language Shift Table ) ; } int header Bits = ( header . length + NUM ) * NUM ; int header Septets = ( header Bits + NUM ) / NUM ; byte [ ] ret = string To Gsm 7 Bit Packed ( data , header Septets , BOOL , language Table , language Shift Table ) ; ret [ NUM ] = ( byte ) header . length ; System . arraycopy ( header , NUM , ret , NUM , header . length ) ; return ret ; }
public static byte [ ] string To Gsm 7 Bit Packed With Header ( String data , byte [ ] header , int language Table , int language Shift Table ) throws Encode Exception { if ( header == null || header . length == NUM ) { return string To Gsm 7 Bit Packed ( data , language Table , language Shift Table ) ; } int header Bits = ( header . length + NUM ) * NUM ; int header Septets = ( header Bits + NUM ) / NUM ; byte [ ] ret = string To Gsm 7 Bit Packed ( data , header Septets , BOOL , language Table , language Shift Table ) ; ret [ NUM ] = ( byte ) header . length ; System . arraycopy ( header , NUM , ret , NUM , header . length ) ; return ret ; }
public static byte [ ] string To Gsm 7 Bit Packed With Header ( String data , byte [ ] header , int language Table , int language Shift Table ) throws Encode Exception { if ( header == null || header . length == NUM ) { return string To Gsm 7 Bit Packed ( data , language Table , language Shift Table ) ; } int header Bits = ( header . length + NUM ) * NUM ; int header Septets = ( header Bits + NUM ) / NUM ; byte [ ] ret = string To Gsm 7 Bit Packed ( data , header Septets , BOOL , language Table , language Shift Table ) ; ret [ NUM ] = ( byte ) header . length ; System . arraycopy ( header , NUM , ret , NUM , header . length ) ; return ret ; }
public static byte [ ] string To Gsm 7 Bit Packed With Header ( String data , byte [ ] header , int language Table , int language Shift Table ) throws Encode Exception { if ( header == null || header . length == NUM ) { return string To Gsm 7 Bit Packed ( data , language Table , language Shift Table ) ; } int header Bits = ( header . length + NUM ) * NUM ; int header Septets = ( header Bits + NUM ) / NUM ; byte [ ] ret = string To Gsm 7 Bit Packed ( data , header Septets , BOOL , language Table , language Shift Table ) ; ret [ NUM ] = ( byte ) header . length ; System . arraycopy ( header , NUM , ret , NUM , header . length ) ; return ret ; }
public static byte [ ] string To Gsm 7 Bit Packed With Header ( String data , byte [ ] header , int language Table , int language Shift Table ) throws Encode Exception { if ( header == null || header . length == NUM ) { return string To Gsm 7 Bit Packed ( data , language Table , language Shift Table ) ; } int header Bits = ( header . length + NUM ) * NUM ; int header Septets = ( header Bits + NUM ) / NUM ; byte [ ] ret = string To Gsm 7 Bit Packed ( data , header Septets , BOOL , language Table , language Shift Table ) ; ret [ NUM ] = ( byte ) header . length ; System . arraycopy ( header , NUM , ret , NUM , header . length ) ; return ret ; }
public static byte [ ] string To Gsm 7 Bit Packed With Header ( String data , byte [ ] header , int language Table , int language Shift Table ) throws Encode Exception { if ( header == null || header . length == NUM ) { return string To Gsm 7 Bit Packed ( data , language Table , language Shift Table ) ; } int header Bits = ( header . length + NUM ) * NUM ; int header Septets = ( header Bits + NUM ) / NUM ; byte [ ] ret = string To Gsm 7 Bit Packed ( data , header Septets , BOOL , language Table , language Shift Table ) ; ret [ NUM ] = ( byte ) header . length ; System . arraycopy ( header , NUM , ret , NUM , header . length ) ; return ret ; }
public static byte [ ] string To Gsm 7 Bit Packed With Header ( String data , byte [ ] header , int language Table , int language Shift Table ) throws Encode Exception { if ( header == null || header . length == NUM ) { return string To Gsm 7 Bit Packed ( data , language Table , language Shift Table ) ; } int header Bits = ( header . length + NUM ) * NUM ; int header Septets = ( header Bits + NUM ) / NUM ; byte [ ] ret = string To Gsm 7 Bit Packed ( data , header Septets , BOOL , language Table , language Shift Table ) ; ret [ NUM ] = ( byte ) header . length ; System . arraycopy ( header , NUM , ret , NUM , header . length ) ; return ret ; }
public static synchronized byte [ ] generate Nonce ( int length ) throws No Such Algorithm Exception { if ( random == null ) { random = Secure Random . get Instance ( STRING ) ; } byte [ ] temp = new byte [ length ] ; random . next Bytes ( temp ) ; return temp ; }
public static synchronized byte [ ] generate Nonce ( int length ) throws No Such Algorithm Exception { if ( random == null ) { random = Secure Random . get Instance ( STRING ) ; } byte [ ] temp = new byte [ length ] ; random . next Bytes ( temp ) ; return temp ; }
public static synchronized byte [ ] generate Nonce ( int length ) throws No Such Algorithm Exception { if ( random == null ) { random = Secure Random . get Instance ( STRING ) ; } byte [ ] temp = new byte [ length ] ; random . next Bytes ( temp ) ; return temp ; }
static private byte [ ] class Name To Bytes ( String cn ) { return cn . get Bytes ( ) ; }
static private byte [ ] class Name To Bytes ( String cn ) { return cn . get Bytes ( ) ; }
static private byte [ ] class Name To Bytes ( String cn ) { return cn . get Bytes ( ) ; }
public static void write ( float x ) { write ( Float . float To Raw Int Bits ( x ) ) ; }
public static void check Serialized Equality ( Object object ) { Object object 2 = serialize And Recover ( object ) ; Assert . assert Equals ( STRING , object , object 2 ) ; Assert . assert Equals ( STRING , object . hash Code ( ) , object 2 . hash Code ( ) ) ; }
public static void check Serialized Equality ( Object object ) { Object object 2 = serialize And Recover ( object ) ; Assert . assert Equals ( STRING , object , object 2 ) ; Assert . assert Equals ( STRING , object . hash Code ( ) , object 2 . hash Code ( ) ) ; }
public void define Fill Style ( Color color 2 ) { Color color = color 2 ; if ( color == null ) { color = new Color ( NUM , NUM , NUM ) ; } Color Fill fill = new Color Fill ( color ) ; if ( color instanceof Alpha Color ) { has Alpha = BOOL ; } elements . add ( fill ) ; }
public void write Binary ( final Packet Output Stream write Buffer ) { if ( options . use Legacy Datetime Code ) calendar = Calendar . get Instance ( ) ; calendar . set Time In Millis ( ts . get Time ( ) ) ; write Buffer . write Timestamp Length ( calendar , ts , fractional Seconds ) ; }
public void write Binary ( final Packet Output Stream write Buffer ) { if ( options . use Legacy Datetime Code ) calendar = Calendar . get Instance ( ) ; calendar . set Time In Millis ( ts . get Time ( ) ) ; write Buffer . write Timestamp Length ( calendar , ts , fractional Seconds ) ; }
public static boolean verify Destination ( String destination , String location ) { return ( ( location != null ) && ( location . length ( ) != NUM ) && ( destination != null ) && ( destination . length ( ) != NUM ) && ( location . equals Ignore Case ( destination ) ) ) ; }
protected void start Reset Expired Jobs Thread ( ) { if ( reset Expired Job Thread == null ) { reset Expired Job Thread = new Thread ( reset Expired Jobs Runnable ) ; } reset Expired Job Thread . start ( ) ; }
public void populate Edit Text ( String match ) { toggle Search ( ) ; String text = match . trim ( ) ; set Search String ( text ) ; search ( text ) ; }
public void populate Edit Text ( String match ) { toggle Search ( ) ; String text = match . trim ( ) ; set Search String ( text ) ; search ( text ) ; }
@ Override public boolean is Supported ( ) { final Package Info package Info = Package Managers . get Package Info ( activity , UBER PACKAGE NAME ) ; return ( package Info != null ) && ( package Info . version Code >= MIN VERSION SUPPORTED ) && app Protocol . validate Signature ( activity , UBER PACKAGE NAME ) ; }
@ Override public boolean is Supported ( ) { final Package Info package Info = Package Managers . get Package Info ( activity , UBER PACKAGE NAME ) ; return ( package Info != null ) && ( package Info . version Code >= MIN VERSION SUPPORTED ) && app Protocol . validate Signature ( activity , UBER PACKAGE NAME ) ; }
public Search Result current ( ) { return m reduced Results . is Empty ( ) ? null : m reduced Results . get ( m current Search Index ) ; }
public Ntp Message ( ) { this . mode = NUM ; this . transmit Timestamp = ( System . current Time Millis ( ) / NUM ) + NUM ; }
public Ntp Message ( ) { this . mode = NUM ; this . transmit Timestamp = ( System . current Time Millis ( ) / NUM ) + NUM ; }
public abstract void done With Directory ( Directory directory ) throws IO Exception ;
public abstract void done With Directory ( Directory directory ) throws IO Exception ;
public abstract void done With Directory ( Directory directory ) throws IO Exception ;
public abstract void done With Directory ( Directory directory ) throws IO Exception ;
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return STRING THING ; case NUM : return CHANGED ; case NUM : return I32 THING ; case NUM : return I64 THING ; default : return null ; } }
public void fix Conversion ( String rep ) { if ( s Hash Code != rep . hash Code ( ) ) throw new Runtime Exception ( STRING ) ; if ( s == null ) { s = rep ; } }
public void fix Conversion ( String rep ) { if ( s Hash Code != rep . hash Code ( ) ) throw new Runtime Exception ( STRING ) ; if ( s == null ) { s = rep ; } }
public void fix Conversion ( String rep ) { if ( s Hash Code != rep . hash Code ( ) ) throw new Runtime Exception ( STRING ) ; if ( s == null ) { s = rep ; } }
public void fix Conversion ( String rep ) { if ( s Hash Code != rep . hash Code ( ) ) throw new Runtime Exception ( STRING ) ; if ( s == null ) { s = rep ; } }
public void fix Conversion ( String rep ) { if ( s Hash Code != rep . hash Code ( ) ) throw new Runtime Exception ( STRING ) ; if ( s == null ) { s = rep ; } }
public void fix Conversion ( String rep ) { if ( s Hash Code != rep . hash Code ( ) ) throw new Runtime Exception ( STRING ) ; if ( s == null ) { s = rep ; } }
public void fix Conversion ( String rep ) { if ( s Hash Code != rep . hash Code ( ) ) throw new Runtime Exception ( STRING ) ; if ( s == null ) { s = rep ; } }
public void test Bug 33734 ( ) throws Exception { Connection test Conn = get Connection With Props ( STRING ) ; try { test Conn . prepare Statement ( STRING ) ; } finally { test Conn . close ( ) ; } }
protected void alloc Resource ( Object resource ) { alloced . add ( resource ) ; }
protected void alloc Resource ( Object resource ) { alloced . add ( resource ) ; }
protected void alloc Resource ( Object resource ) { alloced . add ( resource ) ; }
final public int load Unsigned 8 ( int addr ) { return load Unsigned 8 ( addr , Access Source . CODE ) ; }
public boolean is Empty ( ) { return ( intervals . length == NUM ) ; }
public boolean is Empty ( ) { return ( intervals . length == NUM ) ; }
public void group By ( String column ) throws Query Plan Exception { this . group By Column = column ; }
public void group By ( String column ) throws Query Plan Exception { this . group By Column = column ; }
public void group By ( String column ) throws Query Plan Exception { this . group By Column = column ; }
private void validate Storage Policy Selection ( Storage Policy Selection storage Policy Selection ) { Assert . not Null ( storage Policy Selection , STRING ) ; business Object Data Helper . validate Business Object Data Key ( storage Policy Selection . get Business Object Data Key ( ) , BOOL , BOOL ) ; storage Policy Helper . validate Storage Policy Key ( storage Policy Selection . get Storage Policy Key ( ) ) ; Assert . not Null ( storage Policy Selection . get Storage Policy Version ( ) , STRING ) ; }
private void validate Storage Policy Selection ( Storage Policy Selection storage Policy Selection ) { Assert . not Null ( storage Policy Selection , STRING ) ; business Object Data Helper . validate Business Object Data Key ( storage Policy Selection . get Business Object Data Key ( ) , BOOL , BOOL ) ; storage Policy Helper . validate Storage Policy Key ( storage Policy Selection . get Storage Policy Key ( ) ) ; Assert . not Null ( storage Policy Selection . get Storage Policy Version ( ) , STRING ) ; }
public Incomplete Annotation Exception ( Class < ? extends Annotation > annotation Type , String element Name ) { super ( annotation Type . get Name ( ) + STRING + element Name . to String ( ) ) ; this . annotation Type = annotation Type ; this . element Name = element Name ; }
public Incomplete Annotation Exception ( Class < ? extends Annotation > annotation Type , String element Name ) { super ( annotation Type . get Name ( ) + STRING + element Name . to String ( ) ) ; this . annotation Type = annotation Type ; this . element Name = element Name ; }
private void put Entry ( String key , Cache Header entry ) { if ( ! m Entries . contains Key ( key ) ) { m Total Size += entry . size ; } else { Cache Header old Entry = m Entries . get ( key ) ; m Total Size += ( entry . size - old Entry . size ) ; } m Entries . put ( key , entry ) ; }
public void do Window Open ( ) { do Connect ( ) ; }
@ Override public void action Performed ( Action Event e ) { File Dialog chooser = new File Dialog ( frame , STRING , File Dialog . SAVE ) ; chooser . set Visible ( BOOL ) ; if ( chooser . get File ( ) != null ) { save ( chooser . get Directory ( ) + File . separator + chooser . get File ( ) ) ; } }
public void with Transaction ( Closure closure ) throws SQL Exception { boolean saved Cache Connection = cache Connection ; cache Connection = BOOL ; Connection connection = null ; boolean saved Auto Commit = BOOL ; try { connection = create Connection ( ) ; saved Auto Commit = connection . get Auto Commit ( ) ; connection . set Auto Commit ( BOOL ) ; call Closure Possibly With Connection ( closure , connection ) ; connection . commit ( ) ; } catch ( SQL Exception e ) { handle Error ( connection , e ) ; throw e ; } catch ( Runtime Exception e ) { handle Error ( connection , e ) ; throw e ; } catch ( Error e ) { handle Error ( connection , e ) ; throw e ; } catch ( Exception e ) { handle Error ( connection , e ) ; throw new SQL Exception ( STRING , e ) ; } finally { if ( connection != null ) { try { connection . set Auto Commit ( saved Auto Commit ) ; } catch ( SQL Exception e ) { LOG . finest ( STRING + e . get Message ( ) + STRING ) ; } } cache Connection = BOOL ; close Resources ( connection , null ) ; cache Connection = saved Cache Connection ; if ( data Source != null && ! cache Connection ) { use Connection = null ; } } }
public void with Transaction ( Closure closure ) throws SQL Exception { boolean saved Cache Connection = cache Connection ; cache Connection = BOOL ; Connection connection = null ; boolean saved Auto Commit = BOOL ; try { connection = create Connection ( ) ; saved Auto Commit = connection . get Auto Commit ( ) ; connection . set Auto Commit ( BOOL ) ; call Closure Possibly With Connection ( closure , connection ) ; connection . commit ( ) ; } catch ( SQL Exception e ) { handle Error ( connection , e ) ; throw e ; } catch ( Runtime Exception e ) { handle Error ( connection , e ) ; throw e ; } catch ( Error e ) { handle Error ( connection , e ) ; throw e ; } catch ( Exception e ) { handle Error ( connection , e ) ; throw new SQL Exception ( STRING , e ) ; } finally { if ( connection != null ) { try { connection . set Auto Commit ( saved Auto Commit ) ; } catch ( SQL Exception e ) { LOG . finest ( STRING + e . get Message ( ) + STRING ) ; } } cache Connection = BOOL ; close Resources ( connection , null ) ; cache Connection = saved Cache Connection ; if ( data Source != null && ! cache Connection ) { use Connection = null ; } } }
public void with Transaction ( Closure closure ) throws SQL Exception { boolean saved Cache Connection = cache Connection ; cache Connection = BOOL ; Connection connection = null ; boolean saved Auto Commit = BOOL ; try { connection = create Connection ( ) ; saved Auto Commit = connection . get Auto Commit ( ) ; connection . set Auto Commit ( BOOL ) ; call Closure Possibly With Connection ( closure , connection ) ; connection . commit ( ) ; } catch ( SQL Exception e ) { handle Error ( connection , e ) ; throw e ; } catch ( Runtime Exception e ) { handle Error ( connection , e ) ; throw e ; } catch ( Error e ) { handle Error ( connection , e ) ; throw e ; } catch ( Exception e ) { handle Error ( connection , e ) ; throw new SQL Exception ( STRING , e ) ; } finally { if ( connection != null ) { try { connection . set Auto Commit ( saved Auto Commit ) ; } catch ( SQL Exception e ) { LOG . finest ( STRING + e . get Message ( ) + STRING ) ; } } cache Connection = BOOL ; close Resources ( connection , null ) ; cache Connection = saved Cache Connection ; if ( data Source != null && ! cache Connection ) { use Connection = null ; } } }
public void with Transaction ( Closure closure ) throws SQL Exception { boolean saved Cache Connection = cache Connection ; cache Connection = BOOL ; Connection connection = null ; boolean saved Auto Commit = BOOL ; try { connection = create Connection ( ) ; saved Auto Commit = connection . get Auto Commit ( ) ; connection . set Auto Commit ( BOOL ) ; call Closure Possibly With Connection ( closure , connection ) ; connection . commit ( ) ; } catch ( SQL Exception e ) { handle Error ( connection , e ) ; throw e ; } catch ( Runtime Exception e ) { handle Error ( connection , e ) ; throw e ; } catch ( Error e ) { handle Error ( connection , e ) ; throw e ; } catch ( Exception e ) { handle Error ( connection , e ) ; throw new SQL Exception ( STRING , e ) ; } finally { if ( connection != null ) { try { connection . set Auto Commit ( saved Auto Commit ) ; } catch ( SQL Exception e ) { LOG . finest ( STRING + e . get Message ( ) + STRING ) ; } } cache Connection = BOOL ; close Resources ( connection , null ) ; cache Connection = saved Cache Connection ; if ( data Source != null && ! cache Connection ) { use Connection = null ; } } }
public Section ( Location location , Location location 2 ) { this . min X = Math . min ( location . get Block X ( ) , location 2 . get Block X ( ) ) ; this . min Y = Math . min ( location . get Block Y ( ) , location 2 . get Block Y ( ) ) ; this . min Z = Math . min ( location . get Block Z ( ) , location 2 . get Block Z ( ) ) ; this . max X = Math . max ( location . get Block X ( ) , location 2 . get Block X ( ) ) ; this . max Y = Math . max ( location . get Block Y ( ) , location 2 . get Block Y ( ) ) ; this . max Z = Math . max ( location . get Block Z ( ) , location 2 . get Block Z ( ) ) ; this . world = location . get World ( ) ; }
public Section ( Location location , Location location 2 ) { this . min X = Math . min ( location . get Block X ( ) , location 2 . get Block X ( ) ) ; this . min Y = Math . min ( location . get Block Y ( ) , location 2 . get Block Y ( ) ) ; this . min Z = Math . min ( location . get Block Z ( ) , location 2 . get Block Z ( ) ) ; this . max X = Math . max ( location . get Block X ( ) , location 2 . get Block X ( ) ) ; this . max Y = Math . max ( location . get Block Y ( ) , location 2 . get Block Y ( ) ) ; this . max Z = Math . max ( location . get Block Z ( ) , location 2 . get Block Z ( ) ) ; this . world = location . get World ( ) ; }
public Section ( Location location , Location location 2 ) { this . min X = Math . min ( location . get Block X ( ) , location 2 . get Block X ( ) ) ; this . min Y = Math . min ( location . get Block Y ( ) , location 2 . get Block Y ( ) ) ; this . min Z = Math . min ( location . get Block Z ( ) , location 2 . get Block Z ( ) ) ; this . max X = Math . max ( location . get Block X ( ) , location 2 . get Block X ( ) ) ; this . max Y = Math . max ( location . get Block Y ( ) , location 2 . get Block Y ( ) ) ; this . max Z = Math . max ( location . get Block Z ( ) , location 2 . get Block Z ( ) ) ; this . world = location . get World ( ) ; }
public Section ( Location location , Location location 2 ) { this . min X = Math . min ( location . get Block X ( ) , location 2 . get Block X ( ) ) ; this . min Y = Math . min ( location . get Block Y ( ) , location 2 . get Block Y ( ) ) ; this . min Z = Math . min ( location . get Block Z ( ) , location 2 . get Block Z ( ) ) ; this . max X = Math . max ( location . get Block X ( ) , location 2 . get Block X ( ) ) ; this . max Y = Math . max ( location . get Block Y ( ) , location 2 . get Block Y ( ) ) ; this . max Z = Math . max ( location . get Block Z ( ) , location 2 . get Block Z ( ) ) ; this . world = location . get World ( ) ; }
public static < K > Map < K , Double > normalize Invert ( Map < K , Double > map ) { Double max Value = NUM ; for ( Double v : map . values ( ) ) { if ( v > max Value ) max Value = v ; } for ( Map . Entry < K , Double > e : map . entry Set ( ) ) { map . put ( e . get Key ( ) , NUM - map . get ( e . get Key ( ) ) / max Value ) ; } return map ; }
private void do Normal Command Line List ( List < String > command Line List , List < String > joint Options , Path classpath ) { command Line List . add ( STRING ) ; command Line List . add ( classpath . to String ( ) ) ; if ( joint Compilation ) { command Line List . add ( STRING ) ; command Line List . add All ( joint Options ) ; } if ( dest Dir != null ) { command Line List . add ( STRING ) ; command Line List . add ( dest Dir . get Path ( ) ) ; } if ( encoding != null ) { command Line List . add ( STRING ) ; command Line List . add ( encoding ) ; } if ( stacktrace ) { command Line List . add ( STRING ) ; } if ( parameters ) { command Line List . add ( STRING ) ; } if ( use Indy ) { command Line List . add ( STRING ) ; } if ( script Base Class != null ) { command Line List . add ( STRING ) ; command Line List . add ( script Base Class ) ; } if ( configscript != null ) { command Line List . add ( STRING ) ; command Line List . add ( configscript ) ; } }
private void do Normal Command Line List ( List < String > command Line List , List < String > joint Options , Path classpath ) { command Line List . add ( STRING ) ; command Line List . add ( classpath . to String ( ) ) ; if ( joint Compilation ) { command Line List . add ( STRING ) ; command Line List . add All ( joint Options ) ; } if ( dest Dir != null ) { command Line List . add ( STRING ) ; command Line List . add ( dest Dir . get Path ( ) ) ; } if ( encoding != null ) { command Line List . add ( STRING ) ; command Line List . add ( encoding ) ; } if ( stacktrace ) { command Line List . add ( STRING ) ; } if ( parameters ) { command Line List . add ( STRING ) ; } if ( use Indy ) { command Line List . add ( STRING ) ; } if ( script Base Class != null ) { command Line List . add ( STRING ) ; command Line List . add ( script Base Class ) ; } if ( configscript != null ) { command Line List . add ( STRING ) ; command Line List . add ( configscript ) ; } }
public void remove Listener ( Search Listener listener ) { listeners . remove ( listener ) ; }
public static boolean is Sign Equal ( Context ctx , String apk File ) { String package Sign = get Install Package Signature ( ctx , ctx . get Package Name ( ) ) ; String apk File Sign = get Apk Signature ( apk File ) ; return Text Utils . equals ( package Sign , apk File Sign ) ; }
public static String to String ( final boolean value ) { return value ? STRING : STRING ; }
public static String to String ( final boolean value ) { return value ? STRING : STRING ; }
public static boolean is Empty Or Blanks ( String string ) { if ( string == null || string . length ( ) == NUM ) { return BOOL ; } for ( int i = NUM ; i < string . length ( ) ; i ++ ) { char c = string . char At ( i ) ; if ( ! Character . is Whitespace ( c ) ) { return BOOL ; } } return BOOL ; }
public static boolean is Empty Or Blanks ( String string ) { if ( string == null || string . length ( ) == NUM ) { return BOOL ; } for ( int i = NUM ; i < string . length ( ) ; i ++ ) { char c = string . char At ( i ) ; if ( ! Character . is Whitespace ( c ) ) { return BOOL ; } } return BOOL ; }
@ Override public void close ( ) throws IO Exception { in . close ( ) ; }
@ Override public void close ( ) throws IO Exception { in . close ( ) ; }
private void finalize Project Creation ( Project project , String visibility ) throws Server Exception , Forbidden Exception { final Project Misc misc = project . get Misc ( ) ; misc . set Creation Date ( System . current Time Millis ( ) ) ; misc . save ( ) ; if ( visibility != null ) { project . set Visibility ( visibility ) ; } }
private void finalize Project Creation ( Project project , String visibility ) throws Server Exception , Forbidden Exception { final Project Misc misc = project . get Misc ( ) ; misc . set Creation Date ( System . current Time Millis ( ) ) ; misc . save ( ) ; if ( visibility != null ) { project . set Visibility ( visibility ) ; } }
public Start Listener ( Object resource ) { resource = resource ; }
public static boolean string To File ( final String data , final File target File , final boolean do Append ) { if ( target File == null || ! is Writable ( target File , BOOL ) ) { Log . e ( File Utils . class , STRING ) ; return BOOL ; } boolean is Succeed = BOOL ; try { final File Writer out = new File Writer ( target File , do Append ) ; out . write ( data ) ; out . flush ( ) ; out . close ( ) ; } catch ( IO Exception e ) { is Succeed = BOOL ; } return is Succeed ; }
@ Suppress Warnings ( STRING ) @ Override public void paint Icon ( Component c , Graphics g , int x , int y ) { Sea Glass Painter painter = ( Sea Glass Painter ) UI Manager . get ( prefix + STRING + key ) ; if ( painter != null ) { J Component jc = ( c instanceof J Component ) ? ( J Component ) c : null ; Graphics 2 D gfx = ( Graphics 2 D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
@ Suppress Warnings ( STRING ) @ Override public void paint Icon ( Component c , Graphics g , int x , int y ) { Sea Glass Painter painter = ( Sea Glass Painter ) UI Manager . get ( prefix + STRING + key ) ; if ( painter != null ) { J Component jc = ( c instanceof J Component ) ? ( J Component ) c : null ; Graphics 2 D gfx = ( Graphics 2 D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
@ Suppress Warnings ( STRING ) @ Override public void paint Icon ( Component c , Graphics g , int x , int y ) { Sea Glass Painter painter = ( Sea Glass Painter ) UI Manager . get ( prefix + STRING + key ) ; if ( painter != null ) { J Component jc = ( c instanceof J Component ) ? ( J Component ) c : null ; Graphics 2 D gfx = ( Graphics 2 D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
@ Suppress Warnings ( STRING ) @ Override public void paint Icon ( Component c , Graphics g , int x , int y ) { Sea Glass Painter painter = ( Sea Glass Painter ) UI Manager . get ( prefix + STRING + key ) ; if ( painter != null ) { J Component jc = ( c instanceof J Component ) ? ( J Component ) c : null ; Graphics 2 D gfx = ( Graphics 2 D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
@ Suppress Warnings ( STRING ) @ Override public void paint Icon ( Component c , Graphics g , int x , int y ) { Sea Glass Painter painter = ( Sea Glass Painter ) UI Manager . get ( prefix + STRING + key ) ; if ( painter != null ) { J Component jc = ( c instanceof J Component ) ? ( J Component ) c : null ; Graphics 2 D gfx = ( Graphics 2 D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
@ Suppress Warnings ( STRING ) @ Override public void paint Icon ( Component c , Graphics g , int x , int y ) { Sea Glass Painter painter = ( Sea Glass Painter ) UI Manager . get ( prefix + STRING + key ) ; if ( painter != null ) { J Component jc = ( c instanceof J Component ) ? ( J Component ) c : null ; Graphics 2 D gfx = ( Graphics 2 D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
@ Suppress Warnings ( STRING ) @ Override public void paint Icon ( Component c , Graphics g , int x , int y ) { Sea Glass Painter painter = ( Sea Glass Painter ) UI Manager . get ( prefix + STRING + key ) ; if ( painter != null ) { J Component jc = ( c instanceof J Component ) ? ( J Component ) c : null ; Graphics 2 D gfx = ( Graphics 2 D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
private String mutator ( String http Request , String static Resource Folder , String payload ) { return http Request . replace First ( static Resource Folder + STRING , payload + STRING ) ; }
private String mutator ( String http Request , String static Resource Folder , String payload ) { return http Request . replace First ( static Resource Folder + STRING , payload + STRING ) ; }
private String mutator ( String http Request , String static Resource Folder , String payload ) { return http Request . replace First ( static Resource Folder + STRING , payload + STRING ) ; }
private static void adjust Mapping Pair Vector ( int col , int incr , Vector < Mapping Pair > vec ) { int i ; for ( i = NUM ; ( i < vec . size ( ) ) && ( vec . element At ( i ) . col < col ) ; i ++ ) { } if ( i == vec . size ( ) ) { vec . add ( new Mapping Pair ( col , incr ) ) ; } else if ( vec . element At ( i ) . col == col ) { vec . element At ( i ) . inc = vec . element At ( i ) . inc + incr ; } else { vec . insert Element At ( new Mapping Pair ( col , incr ) , i ) ; } }
private static void adjust Mapping Pair Vector ( int col , int incr , Vector < Mapping Pair > vec ) { int i ; for ( i = NUM ; ( i < vec . size ( ) ) && ( vec . element At ( i ) . col < col ) ; i ++ ) { } if ( i == vec . size ( ) ) { vec . add ( new Mapping Pair ( col , incr ) ) ; } else if ( vec . element At ( i ) . col == col ) { vec . element At ( i ) . inc = vec . element At ( i ) . inc + incr ; } else { vec . insert Element At ( new Mapping Pair ( col , incr ) , i ) ; } }
private static void adjust Mapping Pair Vector ( int col , int incr , Vector < Mapping Pair > vec ) { int i ; for ( i = NUM ; ( i < vec . size ( ) ) && ( vec . element At ( i ) . col < col ) ; i ++ ) { } if ( i == vec . size ( ) ) { vec . add ( new Mapping Pair ( col , incr ) ) ; } else if ( vec . element At ( i ) . col == col ) { vec . element At ( i ) . inc = vec . element At ( i ) . inc + incr ; } else { vec . insert Element At ( new Mapping Pair ( col , incr ) , i ) ; } }
private static void adjust Mapping Pair Vector ( int col , int incr , Vector < Mapping Pair > vec ) { int i ; for ( i = NUM ; ( i < vec . size ( ) ) && ( vec . element At ( i ) . col < col ) ; i ++ ) { } if ( i == vec . size ( ) ) { vec . add ( new Mapping Pair ( col , incr ) ) ; } else if ( vec . element At ( i ) . col == col ) { vec . element At ( i ) . inc = vec . element At ( i ) . inc + incr ; } else { vec . insert Element At ( new Mapping Pair ( col , incr ) , i ) ; } }
@ Override public Invocation . Builder accept ( String ... media Types ) { client Request Context . set Accept Response Types Str ( Arrays . as List ( media Types ) ) ; return this ; }
@ Override public Invocation . Builder accept ( String ... media Types ) { client Request Context . set Accept Response Types Str ( Arrays . as List ( media Types ) ) ; return this ; }
public static String quantityplnoun ( final int quantity , final String noun , final String one ) { final String word = plnoun ( quantity , noun ) ; if ( quantity == NUM ) { if ( one . equals ( STRING ) ) { return a noun ( word ) ; } else if ( one . equals ( STRING ) ) { return A noun ( word ) ; } else if ( one . equals ( STRING ) ) { return word ; } else { return one + STRING + word ; } } else { return Integer . to String ( quantity ) + STRING + plural ( noun ) ; } }
public static String quantityplnoun ( final int quantity , final String noun , final String one ) { final String word = plnoun ( quantity , noun ) ; if ( quantity == NUM ) { if ( one . equals ( STRING ) ) { return a noun ( word ) ; } else if ( one . equals ( STRING ) ) { return A noun ( word ) ; } else if ( one . equals ( STRING ) ) { return word ; } else { return one + STRING + word ; } } else { return Integer . to String ( quantity ) + STRING + plural ( noun ) ; } }
public static String quantityplnoun ( final int quantity , final String noun , final String one ) { final String word = plnoun ( quantity , noun ) ; if ( quantity == NUM ) { if ( one . equals ( STRING ) ) { return a noun ( word ) ; } else if ( one . equals ( STRING ) ) { return A noun ( word ) ; } else if ( one . equals ( STRING ) ) { return word ; } else { return one + STRING + word ; } } else { return Integer . to String ( quantity ) + STRING + plural ( noun ) ; } }
public void invalidate Layout ( Container parent ) { check Parent ( parent ) ; synchronized ( parent . get Tree Lock ( ) ) { is Valid = BOOL ; } }
public void invalidate Layout ( Container parent ) { check Parent ( parent ) ; synchronized ( parent . get Tree Lock ( ) ) { is Valid = BOOL ; } }
public void invalidate Layout ( Container parent ) { check Parent ( parent ) ; synchronized ( parent . get Tree Lock ( ) ) { is Valid = BOOL ; } }
public void invalidate Layout ( Container parent ) { check Parent ( parent ) ; synchronized ( parent . get Tree Lock ( ) ) { is Valid = BOOL ; } }
public double linear Distance ( Location location ) { if ( location == null ) { throw new Illegal Argument Exception ( Logger . log Message ( Logger . ERROR , STRING , STRING , STRING ) ) ; } double lat 1 = Math . to Radians ( this . latitude ) ; double lon 1 = Math . to Radians ( this . longitude ) ; double lat 2 = Math . to Radians ( location . latitude ) ; double lon 2 = Math . to Radians ( location . longitude ) ; if ( lat 1 == lat 2 && lon 1 == lon 2 ) { return NUM ; } double d Lat = lat 2 - lat 1 ; double d Lon = lon 2 - lon 1 ; if ( Math . abs ( d Lon ) > Math . PI ) { d Lon = d Lon > NUM ? - ( NUM * Math . PI - d Lon ) : ( NUM * Math . PI + d Lon ) ; } double distance Radians = Math . sqrt ( d Lat * d Lat + d Lon * d Lon ) ; return Double . is Na N ( distance Radians ) ? NUM : distance Radians ; }
public double linear Distance ( Location location ) { if ( location == null ) { throw new Illegal Argument Exception ( Logger . log Message ( Logger . ERROR , STRING , STRING , STRING ) ) ; } double lat 1 = Math . to Radians ( this . latitude ) ; double lon 1 = Math . to Radians ( this . longitude ) ; double lat 2 = Math . to Radians ( location . latitude ) ; double lon 2 = Math . to Radians ( location . longitude ) ; if ( lat 1 == lat 2 && lon 1 == lon 2 ) { return NUM ; } double d Lat = lat 2 - lat 1 ; double d Lon = lon 2 - lon 1 ; if ( Math . abs ( d Lon ) > Math . PI ) { d Lon = d Lon > NUM ? - ( NUM * Math . PI - d Lon ) : ( NUM * Math . PI + d Lon ) ; } double distance Radians = Math . sqrt ( d Lat * d Lat + d Lon * d Lon ) ; return Double . is Na N ( distance Radians ) ? NUM : distance Radians ; }
public double linear Distance ( Location location ) { if ( location == null ) { throw new Illegal Argument Exception ( Logger . log Message ( Logger . ERROR , STRING , STRING , STRING ) ) ; } double lat 1 = Math . to Radians ( this . latitude ) ; double lon 1 = Math . to Radians ( this . longitude ) ; double lat 2 = Math . to Radians ( location . latitude ) ; double lon 2 = Math . to Radians ( location . longitude ) ; if ( lat 1 == lat 2 && lon 1 == lon 2 ) { return NUM ; } double d Lat = lat 2 - lat 1 ; double d Lon = lon 2 - lon 1 ; if ( Math . abs ( d Lon ) > Math . PI ) { d Lon = d Lon > NUM ? - ( NUM * Math . PI - d Lon ) : ( NUM * Math . PI + d Lon ) ; } double distance Radians = Math . sqrt ( d Lat * d Lat + d Lon * d Lon ) ; return Double . is Na N ( distance Radians ) ? NUM : distance Radians ; }
private Record parse Response ( String response ) throws Stage Exception { Record record = null ; try ( Data Parser parser = parser Factory . get Parser ( STRING , response ) ) { record = parser . parse ( ) ; if ( conf . data Format == Data Format . TEXT ) { record . set ( record . get ( STRING ) ) ; } } catch ( IO Exception | Data Parser Exception e ) { error Record Handler . on Error ( Errors . HTTP 00 , e . to String ( ) , e ) ; } return record ; }
private Record parse Response ( String response ) throws Stage Exception { Record record = null ; try ( Data Parser parser = parser Factory . get Parser ( STRING , response ) ) { record = parser . parse ( ) ; if ( conf . data Format == Data Format . TEXT ) { record . set ( record . get ( STRING ) ) ; } } catch ( IO Exception | Data Parser Exception e ) { error Record Handler . on Error ( Errors . HTTP 00 , e . to String ( ) , e ) ; } return record ; }
public final boolean contains ( V value ) { if ( GWT . is Script ( ) ) { return js Array . index Of ( value ) != - NUM ; } else { return java Array . contains ( value ) ; } }
public final boolean contains ( V value ) { if ( GWT . is Script ( ) ) { return js Array . index Of ( value ) != - NUM ; } else { return java Array . contains ( value ) ; } }
public int Compare ( final String str ) { return Object Name . compare To ( str ) ; }
public static URL find Resource Base ( String base Resource , Class Loader loader ) { URL url = loader . get Resource ( base Resource ) ; return find Resource Base ( url , base Resource ) ; }
public static String iterable To Comma Separated List ( Iterable < ? > iterable ) { String Builder builder = new String Builder ( ) ; boolean first = BOOL ; for ( Object obj : iterable ) { if ( first ) { builder . append ( String . format ( STRING , obj . to String ( ) ) ) ; first = BOOL ; } else { builder . append ( String . format ( STRING , obj . to String ( ) ) ) ; } } return builder . to String ( ) ; }
public boolean check Reference ( Sequences Reader sr , Map < String , Long > sequence Name Map ) throws IO Exception { for ( Check Values cv : m Values ) { if ( ! sequence Name Map . contains Key ( cv . get Sequence Name ( ) ) ) { return BOOL ; } final long sequence Id = sequence Name Map . get ( cv . get Sequence Name ( ) ) ; for ( int i = NUM ; i < m Checks . size ( ) ; i ++ ) { final Check Type check = m Checks . get ( i ) ; if ( ! check . check Value ( sr , sequence Id , cv . get Value ( i ) ) ) { return BOOL ; } } } return BOOL ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return TRUE AS OF SECS ; case NUM : return SOURCE ; case NUM : return SYSTEM ; default : return null ; } }
public String find Token ( ) { Matcher m ; Pattern p ; switch ( super . get Param Name ( ) ) { case REQUEST : p = Pattern . compile ( STRING ) ; break ; case RESPONSE : p = Pattern . compile ( STRING ) ; break ; case ARTIFACT : p = Pattern . compile ( STRING ) ; break ; default : return STRING ; } if ( super . get Parsed Content ( ) != null ) { m = p . matcher ( super . get Parsed Content ( ) ) ; if ( m . find ( ) ) { return m . group ( NUM ) ; } } return STRING ; }
protected int make Press Color ( ) { int r = ( this . background Color > > NUM ) & NUM ; int g = ( this . background Color > > NUM ) & NUM ; int b = ( this . background Color > > NUM ) & NUM ; r = ( r - NUM < NUM ) ? NUM : r - NUM ; g = ( g - NUM < NUM ) ? NUM : g - NUM ; b = ( b - NUM < NUM ) ? NUM : b - NUM ; return Color . rgb ( r , g , b ) ; }
public C Open Function Action ( final C Graph Window parent , final I View Container container , final I Navi Function function ) { super ( String . format ( STRING , function . get Name ( ) ) ) ; Preconditions . check Not Null ( parent , STRING ) ; Preconditions . check Not Null ( container , STRING ) ; m parent = parent ; m container = container ; m function = function ; }
private int find Checkpoint Position ( int [ ] cids ) { if ( checkpoint Period < NUM ) { return - NUM ; } if ( cids . length == NUM ) { throw new Illegal Argument Exception ( ) ; } int first CID = cids [ NUM ] ; if ( ( first CID + NUM ) % checkpoint Period == NUM ) { return cid Position ( cids , first CID ) ; } else { int next Ckp Index = ( ( ( first CID / checkpoint Period ) + NUM ) * checkpoint Period ) - NUM ; if ( next Ckp Index <= cids [ cids . length - NUM ] ) { return cid Position ( cids , next Ckp Index ) ; } } return - NUM ; }
private int find Checkpoint Position ( int [ ] cids ) { if ( checkpoint Period < NUM ) { return - NUM ; } if ( cids . length == NUM ) { throw new Illegal Argument Exception ( ) ; } int first CID = cids [ NUM ] ; if ( ( first CID + NUM ) % checkpoint Period == NUM ) { return cid Position ( cids , first CID ) ; } else { int next Ckp Index = ( ( ( first CID / checkpoint Period ) + NUM ) * checkpoint Period ) - NUM ; if ( next Ckp Index <= cids [ cids . length - NUM ] ) { return cid Position ( cids , next Ckp Index ) ; } } return - NUM ; }
private int find Checkpoint Position ( int [ ] cids ) { if ( checkpoint Period < NUM ) { return - NUM ; } if ( cids . length == NUM ) { throw new Illegal Argument Exception ( ) ; } int first CID = cids [ NUM ] ; if ( ( first CID + NUM ) % checkpoint Period == NUM ) { return cid Position ( cids , first CID ) ; } else { int next Ckp Index = ( ( ( first CID / checkpoint Period ) + NUM ) * checkpoint Period ) - NUM ; if ( next Ckp Index <= cids [ cids . length - NUM ] ) { return cid Position ( cids , next Ckp Index ) ; } } return - NUM ; }
private int find Checkpoint Position ( int [ ] cids ) { if ( checkpoint Period < NUM ) { return - NUM ; } if ( cids . length == NUM ) { throw new Illegal Argument Exception ( ) ; } int first CID = cids [ NUM ] ; if ( ( first CID + NUM ) % checkpoint Period == NUM ) { return cid Position ( cids , first CID ) ; } else { int next Ckp Index = ( ( ( first CID / checkpoint Period ) + NUM ) * checkpoint Period ) - NUM ; if ( next Ckp Index <= cids [ cids . length - NUM ] ) { return cid Position ( cids , next Ckp Index ) ; } } return - NUM ; }
private int find Checkpoint Position ( int [ ] cids ) { if ( checkpoint Period < NUM ) { return - NUM ; } if ( cids . length == NUM ) { throw new Illegal Argument Exception ( ) ; } int first CID = cids [ NUM ] ; if ( ( first CID + NUM ) % checkpoint Period == NUM ) { return cid Position ( cids , first CID ) ; } else { int next Ckp Index = ( ( ( first CID / checkpoint Period ) + NUM ) * checkpoint Period ) - NUM ; if ( next Ckp Index <= cids [ cids . length - NUM ] ) { return cid Position ( cids , next Ckp Index ) ; } } return - NUM ; }
private int find Checkpoint Position ( int [ ] cids ) { if ( checkpoint Period < NUM ) { return - NUM ; } if ( cids . length == NUM ) { throw new Illegal Argument Exception ( ) ; } int first CID = cids [ NUM ] ; if ( ( first CID + NUM ) % checkpoint Period == NUM ) { return cid Position ( cids , first CID ) ; } else { int next Ckp Index = ( ( ( first CID / checkpoint Period ) + NUM ) * checkpoint Period ) - NUM ; if ( next Ckp Index <= cids [ cids . length - NUM ] ) { return cid Position ( cids , next Ckp Index ) ; } } return - NUM ; }
private int find Checkpoint Position ( int [ ] cids ) { if ( checkpoint Period < NUM ) { return - NUM ; } if ( cids . length == NUM ) { throw new Illegal Argument Exception ( ) ; } int first CID = cids [ NUM ] ; if ( ( first CID + NUM ) % checkpoint Period == NUM ) { return cid Position ( cids , first CID ) ; } else { int next Ckp Index = ( ( ( first CID / checkpoint Period ) + NUM ) * checkpoint Period ) - NUM ; if ( next Ckp Index <= cids [ cids . length - NUM ] ) { return cid Position ( cids , next Ckp Index ) ; } } return - NUM ; }
private int find Checkpoint Position ( int [ ] cids ) { if ( checkpoint Period < NUM ) { return - NUM ; } if ( cids . length == NUM ) { throw new Illegal Argument Exception ( ) ; } int first CID = cids [ NUM ] ; if ( ( first CID + NUM ) % checkpoint Period == NUM ) { return cid Position ( cids , first CID ) ; } else { int next Ckp Index = ( ( ( first CID / checkpoint Period ) + NUM ) * checkpoint Period ) - NUM ; if ( next Ckp Index <= cids [ cids . length - NUM ] ) { return cid Position ( cids , next Ckp Index ) ; } } return - NUM ; }
private int find Checkpoint Position ( int [ ] cids ) { if ( checkpoint Period < NUM ) { return - NUM ; } if ( cids . length == NUM ) { throw new Illegal Argument Exception ( ) ; } int first CID = cids [ NUM ] ; if ( ( first CID + NUM ) % checkpoint Period == NUM ) { return cid Position ( cids , first CID ) ; } else { int next Ckp Index = ( ( ( first CID / checkpoint Period ) + NUM ) * checkpoint Period ) - NUM ; if ( next Ckp Index <= cids [ cids . length - NUM ] ) { return cid Position ( cids , next Ckp Index ) ; } } return - NUM ; }
private int find Checkpoint Position ( int [ ] cids ) { if ( checkpoint Period < NUM ) { return - NUM ; } if ( cids . length == NUM ) { throw new Illegal Argument Exception ( ) ; } int first CID = cids [ NUM ] ; if ( ( first CID + NUM ) % checkpoint Period == NUM ) { return cid Position ( cids , first CID ) ; } else { int next Ckp Index = ( ( ( first CID / checkpoint Period ) + NUM ) * checkpoint Period ) - NUM ; if ( next Ckp Index <= cids [ cids . length - NUM ] ) { return cid Position ( cids , next Ckp Index ) ; } } return - NUM ; }
public static void expand ( Rectangle 2 D r , double amount ) { r . set Rect ( r . get X ( ) - amount , r . get Y ( ) - amount , r . get Width ( ) + NUM * amount , r . get Height ( ) + NUM * amount ) ; }
public static void expand ( Rectangle 2 D r , double amount ) { r . set Rect ( r . get X ( ) - amount , r . get Y ( ) - amount , r . get Width ( ) + NUM * amount , r . get Height ( ) + NUM * amount ) ; }
@ Override public Move Path clone ( ) { final Move Path copy = new Move Path ( get Game ( ) , get Entity ( ) ) ; copy . steps = new Vector < Move Step > ( steps ) ; copy . careful = careful ; return copy ; }
@ Override public Move Path clone ( ) { final Move Path copy = new Move Path ( get Game ( ) , get Entity ( ) ) ; copy . steps = new Vector < Move Step > ( steps ) ; copy . careful = careful ; return copy ; }
public final void add Required Imports ( Set < Declared Type Name > imports ) { imports . add ( Type Constants . PROPERTY ) ; imports . add ( Type Constants . VALUES STORAGE ) ; imports . add ( get Model Superclass ( ) ) ; for ( Property Generator generator : property Generators ) { generator . register Required Imports ( imports ) ; } add Model Specific Imports ( imports ) ; plugin Bundle . add Required Imports ( imports ) ; }
private void read Object ( Object Input Stream oos ) throws IO Exception , Class Not Found Exception { i Instant = ( Local Date ) oos . read Object ( ) ; Date Time Field Type type = ( Date Time Field Type ) oos . read Object ( ) ; i Field = type . get Field ( i Instant . get Chronology ( ) ) ; }
private void read Object ( Object Input Stream oos ) throws IO Exception , Class Not Found Exception { i Instant = ( Local Date ) oos . read Object ( ) ; Date Time Field Type type = ( Date Time Field Type ) oos . read Object ( ) ; i Field = type . get Field ( i Instant . get Chronology ( ) ) ; }
protected void add To Bottom Box ( Component comp ) { bottom Box . add ( Box . create Horizontal Strut ( bottom Strut Width ) , bottom Box Index ) ; ++ bottom Box Index ; bottom Box . add ( comp , bottom Box Index ) ; ++ bottom Box Index ; }
protected void add To Bottom Box ( Component comp ) { bottom Box . add ( Box . create Horizontal Strut ( bottom Strut Width ) , bottom Box Index ) ; ++ bottom Box Index ; bottom Box . add ( comp , bottom Box Index ) ; ++ bottom Box Index ; }
public void test Range Shard Mapping Key Lookup ( ) throws Exception { final String global Group Name = STRING ; final int lower Bounds [ ] = new int [ ] { NUM , NUM , NUM , NUM , NUM , NUM } ; final int lowest Lower Bound = NUM ; Set < Shard Index > shard Indices = new Hash Set < Shard Index > ( ) ; int shard Id = NUM ; for ( Integer lower Bound : lower Bounds ) { Shard Index i = new Shard Index ( String . value Of ( lower Bound ) , shard Id , STRING + shard Id ) ; shard Id ++ ; shard Indices . add ( i ) ; } Shard Mapping mapping = new Range Shard Mapping ( NUM , Sharding Type . RANGE , global Group Name , null , shard Indices ) ; try { mapping . get Group Name For Key ( String . value Of ( lowest Lower Bound - NUM ) ) ; fail ( STRING ) ; } catch ( Exception ex ) { } try { mapping . get Group Name For Key ( String . value Of ( lowest Lower Bound - NUM ) ) ; fail ( STRING ) ; } catch ( Exception ex ) { } for ( shard Id = NUM ; shard Id < lower Bounds . length ; ++ shard Id ) { int lower Bound = lower Bounds [ shard Id ] ; String group Name = mapping . get Group Name For Key ( String . value Of ( lower Bound ) ) ; assert Equals ( STRING + lower Bound , STRING + shard Id , group Name ) ; } }
public void test Range Shard Mapping Key Lookup ( ) throws Exception { final String global Group Name = STRING ; final int lower Bounds [ ] = new int [ ] { NUM , NUM , NUM , NUM , NUM , NUM } ; final int lowest Lower Bound = NUM ; Set < Shard Index > shard Indices = new Hash Set < Shard Index > ( ) ; int shard Id = NUM ; for ( Integer lower Bound : lower Bounds ) { Shard Index i = new Shard Index ( String . value Of ( lower Bound ) , shard Id , STRING + shard Id ) ; shard Id ++ ; shard Indices . add ( i ) ; } Shard Mapping mapping = new Range Shard Mapping ( NUM , Sharding Type . RANGE , global Group Name , null , shard Indices ) ; try { mapping . get Group Name For Key ( String . value Of ( lowest Lower Bound - NUM ) ) ; fail ( STRING ) ; } catch ( Exception ex ) { } try { mapping . get Group Name For Key ( String . value Of ( lowest Lower Bound - NUM ) ) ; fail ( STRING ) ; } catch ( Exception ex ) { } for ( shard Id = NUM ; shard Id < lower Bounds . length ; ++ shard Id ) { int lower Bound = lower Bounds [ shard Id ] ; String group Name = mapping . get Group Name For Key ( String . value Of ( lower Bound ) ) ; assert Equals ( STRING + lower Bound , STRING + shard Id , group Name ) ; } }
public void test Range Shard Mapping Key Lookup ( ) throws Exception { final String global Group Name = STRING ; final int lower Bounds [ ] = new int [ ] { NUM , NUM , NUM , NUM , NUM , NUM } ; final int lowest Lower Bound = NUM ; Set < Shard Index > shard Indices = new Hash Set < Shard Index > ( ) ; int shard Id = NUM ; for ( Integer lower Bound : lower Bounds ) { Shard Index i = new Shard Index ( String . value Of ( lower Bound ) , shard Id , STRING + shard Id ) ; shard Id ++ ; shard Indices . add ( i ) ; } Shard Mapping mapping = new Range Shard Mapping ( NUM , Sharding Type . RANGE , global Group Name , null , shard Indices ) ; try { mapping . get Group Name For Key ( String . value Of ( lowest Lower Bound - NUM ) ) ; fail ( STRING ) ; } catch ( Exception ex ) { } try { mapping . get Group Name For Key ( String . value Of ( lowest Lower Bound - NUM ) ) ; fail ( STRING ) ; } catch ( Exception ex ) { } for ( shard Id = NUM ; shard Id < lower Bounds . length ; ++ shard Id ) { int lower Bound = lower Bounds [ shard Id ] ; String group Name = mapping . get Group Name For Key ( String . value Of ( lower Bound ) ) ; assert Equals ( STRING + lower Bound , STRING + shard Id , group Name ) ; } }
public static String [ ] split CSV ( String str , String delim ) { if ( str == null || str . is Empty ( ) ) return new String [ ] { STRING } ; Array List < String > tokens = new Array List < String > ( ) ; int from = NUM , to = NUM ; int len = str . length ( ) ; while ( from < len ) { if ( str . char At ( from ) == CSV QUOTE CHAR && str . index Of ( CSV QUOTE CHAR , from + NUM ) > NUM ) { to = str . index Of ( CSV QUOTE CHAR , from + NUM ) ; while ( to + NUM < len && str . char At ( to + NUM ) == CSV QUOTE CHAR ) to = str . index Of ( CSV QUOTE CHAR , to + NUM ) ; to += NUM ; } else if ( str . region Matches ( from , delim , NUM , delim . length ( ) ) ) { to = from ; } else { to = str . index Of ( delim , from + NUM ) ; } to = ( to >= NUM ) ? to : len ; tokens . add ( str . substring ( from , to ) ) ; from = to + delim . length ( ) ; } if ( from == len ) tokens . add ( STRING ) ; return tokens . to Array ( new String [ NUM ] ) ; }
public static String [ ] split CSV ( String str , String delim ) { if ( str == null || str . is Empty ( ) ) return new String [ ] { STRING } ; Array List < String > tokens = new Array List < String > ( ) ; int from = NUM , to = NUM ; int len = str . length ( ) ; while ( from < len ) { if ( str . char At ( from ) == CSV QUOTE CHAR && str . index Of ( CSV QUOTE CHAR , from + NUM ) > NUM ) { to = str . index Of ( CSV QUOTE CHAR , from + NUM ) ; while ( to + NUM < len && str . char At ( to + NUM ) == CSV QUOTE CHAR ) to = str . index Of ( CSV QUOTE CHAR , to + NUM ) ; to += NUM ; } else if ( str . region Matches ( from , delim , NUM , delim . length ( ) ) ) { to = from ; } else { to = str . index Of ( delim , from + NUM ) ; } to = ( to >= NUM ) ? to : len ; tokens . add ( str . substring ( from , to ) ) ; from = to + delim . length ( ) ; } if ( from == len ) tokens . add ( STRING ) ; return tokens . to Array ( new String [ NUM ] ) ; }
public void delete Auth Configuration ( String realm , Set names ) throws AM Console Exception { String Builder error List = new String Builder ( ) ; String message = null ; for ( Iterator i = names . iterator ( ) ; i . has Next ( ) ; ) { String config = ( String ) i . next ( ) ; message = null ; try { AM Auth Config Utils . remove Named Config ( config , realm , get User SSO Token ( ) ) ; } catch ( AM Configuration Exception e ) { debug . warning ( STRING , e ) ; message = e . get Message ( ) ; error List . append ( config ) ; } catch ( SMS Exception e ) { debug . warning ( STRING , e ) ; message = e . get Message ( ) ; error List . append ( config ) ; } catch ( SSO Exception e ) { debug . warning ( STRING , e ) ; message = e . get Message ( ) ; error List . append ( config ) ; } if ( message != null ) { if ( error List . length ( ) > NUM ) { error List . append ( STRING ) ; } } } if ( error List . length ( ) > NUM ) { String [ ] tmp = { error List . to String ( ) , message } ; throw new AM Console Exception ( Message Format . format ( get Localized String ( STRING ) , ( Object [ ] ) tmp ) ) ; } }
protected Text Anchor calculate Text Anchor ( double angle Degrees ) { Text Anchor ta = Text Anchor . CENTER ; double offset = this . angle Offset ; while ( offset < NUM ) { offset += NUM ; } double normalized Angle = ( ( ( this . counter Clockwise ? - NUM : NUM ) * angle Degrees ) + offset ) % NUM ; while ( this . counter Clockwise && ( normalized Angle < NUM ) ) { normalized Angle += NUM ; } if ( normalized Angle == NUM ) { ta = Text Anchor . CENTER LEFT ; } else if ( normalized Angle > NUM && normalized Angle < NUM ) { ta = Text Anchor . TOP LEFT ; } else if ( normalized Angle == NUM ) { ta = Text Anchor . TOP CENTER ; } else if ( normalized Angle > NUM && normalized Angle < NUM ) { ta = Text Anchor . TOP RIGHT ; } else if ( normalized Angle == NUM ) { ta = Text Anchor . CENTER RIGHT ; } else if ( normalized Angle > NUM && normalized Angle < NUM ) { ta = Text Anchor . BOTTOM RIGHT ; } else if ( normalized Angle == NUM ) { ta = Text Anchor . BOTTOM CENTER ; } else if ( normalized Angle > NUM && normalized Angle < NUM ) { ta = Text Anchor . BOTTOM LEFT ; } return ta ; }
@ Override public int compare ( Physical Table left , Physical Table right ) { long left Volatile Data Duration = get Available Volatile Data Duration ( left ) ; long right Volatile Data Duration = get Available Volatile Data Duration ( right ) ; long most Complete Volatile = right Volatile Data Duration - left Volatile Data Duration ; return ( int ) Math . max ( Math . min ( Integer . MAX VALUE , most Complete Volatile ) , Integer . MIN VALUE ) ; }
@ Override public int compare ( Physical Table left , Physical Table right ) { long left Volatile Data Duration = get Available Volatile Data Duration ( left ) ; long right Volatile Data Duration = get Available Volatile Data Duration ( right ) ; long most Complete Volatile = right Volatile Data Duration - left Volatile Data Duration ; return ( int ) Math . max ( Math . min ( Integer . MAX VALUE , most Complete Volatile ) , Integer . MIN VALUE ) ; }
private Json Node parse Language Resource ( Resource resource ) throws IO Exception { Input Stream stream = resource . as Stream ( ) ; if ( stream == null ) return null ; try { Json Node tree = mapper . read Tree ( stream ) ; return tree ; } finally { stream . close ( ) ; } }
private Json Node parse Language Resource ( Resource resource ) throws IO Exception { Input Stream stream = resource . as Stream ( ) ; if ( stream == null ) return null ; try { Json Node tree = mapper . read Tree ( stream ) ; return tree ; } finally { stream . close ( ) ; } }
private Json Node parse Language Resource ( Resource resource ) throws IO Exception { Input Stream stream = resource . as Stream ( ) ; if ( stream == null ) return null ; try { Json Node tree = mapper . read Tree ( stream ) ; return tree ; } finally { stream . close ( ) ; } }
public final boolean is Command Builder Useful ( ) { return is Command Builder Useful ; }
public final boolean is Command Builder Useful ( ) { return is Command Builder Useful ; }
public final boolean is Command Builder Useful ( ) { return is Command Builder Useful ; }
public final boolean is Command Builder Useful ( ) { return is Command Builder Useful ; }
public final boolean is Command Builder Useful ( ) { return is Command Builder Useful ; }
public final boolean is Command Builder Useful ( ) { return is Command Builder Useful ; }
private static int encode Value Num ( int value Num , boolean is Object Kind ) { assert value Num > NUM ; if ( is Object Kind ) { return - value Num ; } return value Num ; }
public C Tag Tree Node Menu Builder ( final J Frame parent , final Zy Graph graph , final I Tag Manager tag Manager , final I Tree Node < C Tag > tag ) { m popup Menu = new J Popup Menu ( ) ; m popup Menu . add ( C Action Proxy . proxy ( new C Add Tag To Selected Nodes Action ( parent , graph , tag ) ) ) ; m popup Menu . add ( new J Separator ( ) ) ; m popup Menu . add ( C Action Proxy . proxy ( new C Remove Tag From Selected Nodes Action ( parent , graph , tag ) ) ) ; m popup Menu . add ( C Action Proxy . proxy ( new C Remove Tag From All Nodes Action ( parent , graph , tag . get Object ( ) ) ) ) ; m popup Menu . add ( new J Separator ( ) ) ; m popup Menu . add ( C Action Proxy . proxy ( new C Append Tag Action ( parent , tag Manager , tag ) ) ) ; m popup Menu . add ( C Action Proxy . proxy ( new C Insert Tag Action ( parent , tag Manager , tag ) ) ) ; m popup Menu . add ( new J Separator ( ) ) ; m popup Menu . add ( C Action Proxy . proxy ( new C Edit Tag Action ( parent , tag . get Object ( ) ) ) ) ; m popup Menu . add ( new J Separator ( ) ) ; m popup Menu . add ( C Action Proxy . proxy ( new C Delete Tag Action ( parent , tag Manager , tag ) ) ) ; m popup Menu . add ( C Action Proxy . proxy ( new C Delete Tag Subtree Action ( parent , tag Manager , tag ) ) ) ; }
protected boolean is IDP Proxy Enabled ( FS Authn Request authn Request ) throws FS Exception { if ( authn Request . get Minor Version ( ) != IFS Constants . FF 12 PROTOCOL MINOR VERSION ) { return BOOL ; } FS Scoping scoping = authn Request . get Scoping ( ) ; if ( scoping != null && scoping . get Proxy Count ( ) == NUM ) { return BOOL ; } String enabled String = IDFF Meta Utils . get First Attribute Value From Config ( sp Config , IFS Constants . ENABLE IDP PROXY ) ; if ( enabled String != null && enabled String . equals Ignore Case ( STRING ) ) { return BOOL ; } else { return BOOL ; } }
protected boolean is IDP Proxy Enabled ( FS Authn Request authn Request ) throws FS Exception { if ( authn Request . get Minor Version ( ) != IFS Constants . FF 12 PROTOCOL MINOR VERSION ) { return BOOL ; } FS Scoping scoping = authn Request . get Scoping ( ) ; if ( scoping != null && scoping . get Proxy Count ( ) == NUM ) { return BOOL ; } String enabled String = IDFF Meta Utils . get First Attribute Value From Config ( sp Config , IFS Constants . ENABLE IDP PROXY ) ; if ( enabled String != null && enabled String . equals Ignore Case ( STRING ) ) { return BOOL ; } else { return BOOL ; } }
public void add Request Header ( String key , String value ) { if ( user Headers == null ) { user Headers = new Hashtable ( ) ; } if ( key . equals Ignore Case ( STRING ) ) { set Content Type ( value ) ; } else { user Headers . put ( key , value ) ; } }
public static boolean any Dimension Has Items ( Collection < Dimensional Object > dimensions ) { if ( dimensions == null || dimensions . is Empty ( ) ) { return BOOL ; } for ( Dimensional Object dim : dimensions ) { if ( dim . has Items ( ) ) { return BOOL ; } } return BOOL ; }
public static boolean any Dimension Has Items ( Collection < Dimensional Object > dimensions ) { if ( dimensions == null || dimensions . is Empty ( ) ) { return BOOL ; } for ( Dimensional Object dim : dimensions ) { if ( dim . has Items ( ) ) { return BOOL ; } } return BOOL ; }
public static boolean any Dimension Has Items ( Collection < Dimensional Object > dimensions ) { if ( dimensions == null || dimensions . is Empty ( ) ) { return BOOL ; } for ( Dimensional Object dim : dimensions ) { if ( dim . has Items ( ) ) { return BOOL ; } } return BOOL ; }
public int read ( String table , String key , Set < String > fields , Hash Map < String , Byte Iterator > result ) { long st = System . nano Time ( ) ; int res = db . read ( table , key , fields , result ) ; long en = System . nano Time ( ) ; measurements . measure ( STRING , ( int ) ( ( en - st ) / NUM ) ) ; measurements . report Return Code ( STRING , res ) ; return res ; }
public int read ( String table , String key , Set < String > fields , Hash Map < String , Byte Iterator > result ) { long st = System . nano Time ( ) ; int res = db . read ( table , key , fields , result ) ; long en = System . nano Time ( ) ; measurements . measure ( STRING , ( int ) ( ( en - st ) / NUM ) ) ; measurements . report Return Code ( STRING , res ) ; return res ; }
public int read ( String table , String key , Set < String > fields , Hash Map < String , Byte Iterator > result ) { long st = System . nano Time ( ) ; int res = db . read ( table , key , fields , result ) ; long en = System . nano Time ( ) ; measurements . measure ( STRING , ( int ) ( ( en - st ) / NUM ) ) ; measurements . report Return Code ( STRING , res ) ; return res ; }
public Filter add Attribute ( String attribute , Object entity ) { put ( attribute , entity ) ; return ( this ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public static Alert find By Name And Owner ( Entity Manager em , String alert Name , Principal User owner ) { require Argument ( em != null , STRING ) ; require Argument ( alert Name != null && ! alert Name . is Empty ( ) , STRING ) ; require Argument ( owner != null , STRING ) ; Typed Query < Alert > query = em . create Named Query ( STRING , Alert . class ) ; query . set Hint ( STRING , STRING ) ; try { query . set Parameter ( STRING , alert Name ) ; query . set Parameter ( STRING , owner ) ; return query . get Single Result ( ) ; } catch ( No Result Exception ex ) { return null ; } }
public static Alert find By Name And Owner ( Entity Manager em , String alert Name , Principal User owner ) { require Argument ( em != null , STRING ) ; require Argument ( alert Name != null && ! alert Name . is Empty ( ) , STRING ) ; require Argument ( owner != null , STRING ) ; Typed Query < Alert > query = em . create Named Query ( STRING , Alert . class ) ; query . set Hint ( STRING , STRING ) ; try { query . set Parameter ( STRING , alert Name ) ; query . set Parameter ( STRING , owner ) ; return query . get Single Result ( ) ; } catch ( No Result Exception ex ) { return null ; } }
private void enter Linked Mode For Prefix ( I Document document , I Text Viewer viewer , IDOM Element root Element , String prefix ) throws Bad Location Exception { int linked Pos Sequence = NUM ; Linked Position pos 1 = new Linked Position ( document , start Position , prefix . length ( ) , linked Pos Sequence ++ ) ; Linked Position pos 2 = new Linked Position ( document , cursor Position + NUM , prefix . length ( ) , linked Pos Sequence ++ ) ; IDOM Element root Dom Element = ( IDOM Element ) root Element ; final String xmlns Prefix = STRING ; String full Prefix Name = xmlns Prefix + prefix ; IDOM Attr dom Attribute = ( IDOM Attr ) root Dom Element . get Attribute Node ( full Prefix Name ) ; Linked Position pos 3 = new Linked Position ( document , dom Attribute . get Start Offset ( ) + xmlns Prefix . length ( ) , prefix . length ( ) , linked Pos Sequence ++ ) ; Linked Position Group group = new Linked Position Group ( ) ; group . add Position ( pos 1 ) ; group . add Position ( pos 2 ) ; group . add Position ( pos 3 ) ; Linked Mode Model model = new Linked Mode Model ( ) ; model . add Group ( group ) ; model . force Install ( ) ; Linked Mode UI ui = new Linked Mode UI ( model , viewer ) ; ui . enter ( ) ; was Linked Mode Entered = BOOL ; }
public void write Header Part ( Annotated Output out ) { throw If Not Prepared ( ) ; if ( write Size == - NUM ) { throw new Runtime Exception ( STRING ) ; } int sz = write Size ; int offset = ( sz == NUM ) ? NUM : get File Offset ( ) ; String name = get Name ( ) ; if ( name == null ) { name = STRING ; } int space Count = NUM - name . length ( ) ; char [ ] space Arr = new char [ space Count ] ; Arrays . fill ( space Arr , STRING ) ; String spaces = new String ( space Arr ) ; if ( out . annotates ( ) ) { out . annotate ( NUM , name + STRING + spaces + Hex . u4 ( sz ) ) ; out . annotate ( NUM , name + STRING + spaces + Hex . u4 ( offset ) ) ; } out . write Int ( sz ) ; out . write Int ( offset ) ; }
public Add World Parameter Dialog ( java . awt . Frame parent , boolean modal , Diagram diagram , Point click Position ) { super ( parent , modal ) ; init Components ( ) ; Default Combo Box Model model = new Default Combo Box Model ( ) ; for ( Uniform Binding binding : Uniform Binding . values ( ) ) { model . add Element ( binding ) ; } this . diagram = diagram ; this . click Position = click Position ; name Field . set Model ( model ) ; }
private static Bitmap Sampled crop Bitmap ( Context context , Uri loaded Image Uri , float [ ] points , int degrees Rotated , boolean fix Aspect Ratio , int aspect Ratio X , int aspect Ratio Y , int sample Multi , Rect rect , int width , int height ) { Bitmap result = null ; int sample Size ; try { Bitmap Factory . Options options = new Bitmap Factory . Options ( ) ; options . in Sample Size = sample Size = sample Multi * calculate In Sample Size By Reqested Size ( rect . width ( ) , rect . height ( ) , width , height ) ; Bitmap full Bitmap = decode Image ( context . get Content Resolver ( ) , loaded Image Uri , options ) ; if ( full Bitmap != null ) { try { float [ ] points 2 = new float [ points . length ] ; System . arraycopy ( points , NUM , points 2 , NUM , points . length ) ; for ( int i = NUM ; i < points 2 . length ; i ++ ) { points 2 [ i ] = points 2 [ i ] / options . in Sample Size ; } result = crop Bitmap ( full Bitmap , points 2 , degrees Rotated , fix Aspect Ratio , aspect Ratio X , aspect Ratio Y ) ; } finally { if ( result != full Bitmap ) { full Bitmap . recycle ( ) ; } } } } catch ( Out Of Memory Error e ) { if ( result != null ) { result . recycle ( ) ; } throw e ; } catch ( Exception e ) { throw new Runtime Exception ( STRING + loaded Image Uri + STRING + e . get Message ( ) , e ) ; } return new Bitmap Sampled ( result , sample Size ) ; }
private Text Cluster Data find Cluster ( String text , Date time Stamp , boolean is Trace ) throws Ade Exception { boolean paths Are One Token = BOOL ; if ( m message Text Preprocessor != null ) { paths Are One Token = m message Text Preprocessor . treat Paths As One Token ( ) ; } Word [ ] words ; if ( paths Are One Token ) { words = Levenshtein Text Summary . prepare String Token ( text ) ; } else { words = Levenshtein Text Summary . prepare String ( text ) ; } final Iterator < Text Cluster Data > e = m clusters Data . iterator ( ) ; while ( e . has Next ( ) ) { final Text Cluster Data cluster = e . next ( ) ; final String cluster Representative = cluster . get Text Representative ( ) ; Word [ ] cluster Representative Words ; if ( paths Are One Token ) { cluster Representative Words = Levenshtein Text Summary . prepare String Token ( cluster Representative ) ; } else { cluster Representative Words = Levenshtein Text Summary . prepare String ( cluster Representative ) ; } final int threshold = m threshold Setter . get Threshold ( cluster Representative Words . length , words . length ) ; final boolean are Close = are Close ( cluster Representative Words , words , threshold , is Trace ) ; boolean updated Last Observed ; if ( are Close ) { updated Last Observed = cluster . set Last Observed ( time Stamp ) ; e . remove ( ) ; m clusters Data . push ( cluster ) ; if ( m update Data Store && updated Last Observed ) { m ds Text Clustering . update Text Cluster Time Stamp ( cluster . get Cluster Id ( ) , cluster . get Last Observed ( ) ) ; } return cluster ; } } return null ; }
public void add Tracks ( Sound Cloud Track track ) { m Tracks . add ( track ) ; }
public void start ( ) { log . info ( STRING , this . name , this . frequency In Secs ) ; stopped = BOOL ; Thread dr Health Monitor Thread = new Thread ( this ) ; dr Health Monitor Thread . set Name ( this . name ) ; dr Health Monitor Thread . start ( ) ; }
public void clear Gesture ( ) { current Gesture Action List . remove All Elements ( ) ; }
public void invalidate ( String group ) { Iterator items = items ( group , Validated Predicate . TRUE ) ; while ( items . has Next ( ) ) { Visual Item item = ( Visual Item ) items . next ( ) ; item . set Validated ( BOOL ) ; } }
public void invalidate ( String group ) { Iterator items = items ( group , Validated Predicate . TRUE ) ; while ( items . has Next ( ) ) { Visual Item item = ( Visual Item ) items . next ( ) ; item . set Validated ( BOOL ) ; } }
public void invalidate ( String group ) { Iterator items = items ( group , Validated Predicate . TRUE ) ; while ( items . has Next ( ) ) { Visual Item item = ( Visual Item ) items . next ( ) ; item . set Validated ( BOOL ) ; } }
public void add Listener ( Navigator Listener listener ) { listeners . add ( listener ) ; }
public Runtime Collector ( Algorithm algorithm , int frequency , Result File Writer writer ) { super ( algorithm , frequency , Frequency Type . EVALUATIONS ) ; this . writer = writer ; start Time = System . nano Time ( ) ; }
public Runtime Collector ( Algorithm algorithm , int frequency , Result File Writer writer ) { super ( algorithm , frequency , Frequency Type . EVALUATIONS ) ; this . writer = writer ; start Time = System . nano Time ( ) ; }
public static boolean via Equals ( final X500 Principal p1 , final X500 Principal p2 ) { return p1 . equals ( p2 ) ; }
public Osc World Component ( final String name ) { super ( name ) ; }
public void try Connect ( ) { try { if ( Text Utils . is Empty ( App Info . bt Address ) ) { return ; } if ( null == m Adapter ) { m Adapter = Bluetooth Adapter . get Default Adapter ( ) ; } if ( null == m Adapter ) { return ; } if ( null == m Bt Service ) { m Bt Service = new Bt Service ( m Context ) ; } if ( m Bt Service . get State ( ) != Bt Service . STATE CONNECTED ) { if ( ! Text Utils . is Empty ( App Info . bt Address ) ) { Bluetooth Device device = m Adapter . get Remote Device ( App Info . bt Address ) ; m Bt Service . connect ( device ) ; return ; } } else { } } catch ( Exception e ) { e . print Stack Trace ( ) ; } catch ( Error e ) { e . print Stack Trace ( ) ; } }
protected static List < Endpoint Help Dto > describe Endpoints ( List < Class < ? extends Abstract Resource > > resource Classes ) { List < Endpoint Help Dto > result = new Linked List < > ( ) ; if ( resource Classes != null && ! resource Classes . is Empty ( ) ) { for ( Class < ? extends Abstract Resource > resource Class : resource Classes ) { Endpoint Help Dto dto = Endpoint Help Dto . from Resource Class ( resource Class ) ; if ( dto != null ) { result . add ( dto ) ; } } } return result ; }
protected void on Progress ( int itemcount , int size ) { }
protected void on Progress ( int itemcount , int size ) { }
protected void on Progress ( int itemcount , int size ) { }
protected void on Progress ( int itemcount , int size ) { }
public void randomize ( List < Cell Index > cell Indices ) { Random rand = new Random ( ) ; int range = get Upper Bound ( ) - get Lower Bound ( ) ; for ( Cell Index cell Index : cell Indices ) { int row = cell Index . row ; int col = cell Index . col ; double value = ( rand . next Double ( ) * range ) + get Lower Bound ( ) ; set Logical Value ( row , col , value , BOOL ) ; } fire Table Data Changed ( ) ; }
public Order By Clause add ( String property , boolean is Descending ) { order By Expressions . add ( new Order By Element ( Expressions . get Prop Expr ( property ) , is Descending ) ) ; return this ; }
public void result Photo ( int request Code , int result Code , Intent data ) { if ( result Code == Activity . RESULT OK ) { if ( request Code == SELECT PHOTO ) { this . my Photo = on Select From Gallery Result ( data ) ; } else if ( request Code == TAKE PHOTO ) { this . my Photo = on Take Photo Result ( ) ; } if ( this . my Photo != null ) { if ( if Camera Land Scape ( BOOL ) == LANDSCAPE CAMERA ) { this . my Photo = rotate Image ( get My Photo ( ) , NUM ) ; } } } }
default String role Parent Name ( String type ) { return String . format ( ROLE PARENT , type ) ; }
public void start Element ( ) { nss . push Context ( ) ; in Collecting Mode = BOOL ; }
public static boolean is Valid No Colon WWN ( String wwn ) { return wwn != null && wwn . matches ( WWN NO COLON PATTERN ) ; }
public boolean field Is Transient ( ) { return Modifier . is Transient ( field . get Modifiers ( ) ) ; }
final int full Try Acquire Shared ( Thread current ) { Hold Counter rh = null ; for ( ; ; ) { int c = get State ( ) ; if ( exclusive Count ( c ) != NUM ) { if ( get Exclusive Owner Thread ( ) != current ) return - NUM ; } else if ( reader Should Block ( ) ) { if ( first Reader == current ) { } else { if ( rh == null ) { rh = cached Hold Counter ; if ( rh == null || rh . tid != current . get Id ( ) ) { rh = read Holds . get ( ) ; if ( rh . count == NUM ) read Holds . remove ( ) ; } } if ( rh . count == NUM ) return - NUM ; } } if ( shared Count ( c ) == MAX COUNT ) throw new Error ( STRING ) ; if ( compare And Set State ( c , c + SHARED UNIT ) ) { if ( shared Count ( c ) == NUM ) { first Reader = current ; first Reader Hold Count = NUM ; } else if ( first Reader == current ) { first Reader Hold Count ++ ; } else { if ( rh == null ) rh = cached Hold Counter ; if ( rh == null || rh . tid != current . get Id ( ) ) rh = read Holds . get ( ) ; else if ( rh . count == NUM ) read Holds . set ( rh ) ; rh . count ++ ; cached Hold Counter = rh ; } return NUM ; } } }
final int full Try Acquire Shared ( Thread current ) { Hold Counter rh = null ; for ( ; ; ) { int c = get State ( ) ; if ( exclusive Count ( c ) != NUM ) { if ( get Exclusive Owner Thread ( ) != current ) return - NUM ; } else if ( reader Should Block ( ) ) { if ( first Reader == current ) { } else { if ( rh == null ) { rh = cached Hold Counter ; if ( rh == null || rh . tid != current . get Id ( ) ) { rh = read Holds . get ( ) ; if ( rh . count == NUM ) read Holds . remove ( ) ; } } if ( rh . count == NUM ) return - NUM ; } } if ( shared Count ( c ) == MAX COUNT ) throw new Error ( STRING ) ; if ( compare And Set State ( c , c + SHARED UNIT ) ) { if ( shared Count ( c ) == NUM ) { first Reader = current ; first Reader Hold Count = NUM ; } else if ( first Reader == current ) { first Reader Hold Count ++ ; } else { if ( rh == null ) rh = cached Hold Counter ; if ( rh == null || rh . tid != current . get Id ( ) ) rh = read Holds . get ( ) ; else if ( rh . count == NUM ) read Holds . set ( rh ) ; rh . count ++ ; cached Hold Counter = rh ; } return NUM ; } } }
final int full Try Acquire Shared ( Thread current ) { Hold Counter rh = null ; for ( ; ; ) { int c = get State ( ) ; if ( exclusive Count ( c ) != NUM ) { if ( get Exclusive Owner Thread ( ) != current ) return - NUM ; } else if ( reader Should Block ( ) ) { if ( first Reader == current ) { } else { if ( rh == null ) { rh = cached Hold Counter ; if ( rh == null || rh . tid != current . get Id ( ) ) { rh = read Holds . get ( ) ; if ( rh . count == NUM ) read Holds . remove ( ) ; } } if ( rh . count == NUM ) return - NUM ; } } if ( shared Count ( c ) == MAX COUNT ) throw new Error ( STRING ) ; if ( compare And Set State ( c , c + SHARED UNIT ) ) { if ( shared Count ( c ) == NUM ) { first Reader = current ; first Reader Hold Count = NUM ; } else if ( first Reader == current ) { first Reader Hold Count ++ ; } else { if ( rh == null ) rh = cached Hold Counter ; if ( rh == null || rh . tid != current . get Id ( ) ) rh = read Holds . get ( ) ; else if ( rh . count == NUM ) read Holds . set ( rh ) ; rh . count ++ ; cached Hold Counter = rh ; } return NUM ; } } }
final int full Try Acquire Shared ( Thread current ) { Hold Counter rh = null ; for ( ; ; ) { int c = get State ( ) ; if ( exclusive Count ( c ) != NUM ) { if ( get Exclusive Owner Thread ( ) != current ) return - NUM ; } else if ( reader Should Block ( ) ) { if ( first Reader == current ) { } else { if ( rh == null ) { rh = cached Hold Counter ; if ( rh == null || rh . tid != current . get Id ( ) ) { rh = read Holds . get ( ) ; if ( rh . count == NUM ) read Holds . remove ( ) ; } } if ( rh . count == NUM ) return - NUM ; } } if ( shared Count ( c ) == MAX COUNT ) throw new Error ( STRING ) ; if ( compare And Set State ( c , c + SHARED UNIT ) ) { if ( shared Count ( c ) == NUM ) { first Reader = current ; first Reader Hold Count = NUM ; } else if ( first Reader == current ) { first Reader Hold Count ++ ; } else { if ( rh == null ) rh = cached Hold Counter ; if ( rh == null || rh . tid != current . get Id ( ) ) rh = read Holds . get ( ) ; else if ( rh . count == NUM ) read Holds . set ( rh ) ; rh . count ++ ; cached Hold Counter = rh ; } return NUM ; } } }
final int full Try Acquire Shared ( Thread current ) { Hold Counter rh = null ; for ( ; ; ) { int c = get State ( ) ; if ( exclusive Count ( c ) != NUM ) { if ( get Exclusive Owner Thread ( ) != current ) return - NUM ; } else if ( reader Should Block ( ) ) { if ( first Reader == current ) { } else { if ( rh == null ) { rh = cached Hold Counter ; if ( rh == null || rh . tid != current . get Id ( ) ) { rh = read Holds . get ( ) ; if ( rh . count == NUM ) read Holds . remove ( ) ; } } if ( rh . count == NUM ) return - NUM ; } } if ( shared Count ( c ) == MAX COUNT ) throw new Error ( STRING ) ; if ( compare And Set State ( c , c + SHARED UNIT ) ) { if ( shared Count ( c ) == NUM ) { first Reader = current ; first Reader Hold Count = NUM ; } else if ( first Reader == current ) { first Reader Hold Count ++ ; } else { if ( rh == null ) rh = cached Hold Counter ; if ( rh == null || rh . tid != current . get Id ( ) ) rh = read Holds . get ( ) ; else if ( rh . count == NUM ) read Holds . set ( rh ) ; rh . count ++ ; cached Hold Counter = rh ; } return NUM ; } } }
private boolean can Force Perform ( String permission Name ) { List < Permission Rule > access = access ( permission Name ) ; List < Permission Rule > overridden = relevant . get Overridden ( permission Name ) ; Set < Project Ref > allows = new Hash Set < > ( ) ; Set < Project Ref > blocks = new Hash Set < > ( ) ; for ( Permission Rule rule : access ) { if ( rule . is Block ( ) ) { blocks . add ( relevant . get Rule Props ( rule ) ) ; } else if ( rule . get Force ( ) ) { allows . add ( relevant . get Rule Props ( rule ) ) ; } } for ( Permission Rule rule : overridden ) { if ( rule . get Force ( ) ) { blocks . remove ( relevant . get Rule Props ( rule ) ) ; } } blocks . remove All ( allows ) ; return blocks . is Empty ( ) && ! allows . is Empty ( ) ; }
private boolean can Force Perform ( String permission Name ) { List < Permission Rule > access = access ( permission Name ) ; List < Permission Rule > overridden = relevant . get Overridden ( permission Name ) ; Set < Project Ref > allows = new Hash Set < > ( ) ; Set < Project Ref > blocks = new Hash Set < > ( ) ; for ( Permission Rule rule : access ) { if ( rule . is Block ( ) ) { blocks . add ( relevant . get Rule Props ( rule ) ) ; } else if ( rule . get Force ( ) ) { allows . add ( relevant . get Rule Props ( rule ) ) ; } } for ( Permission Rule rule : overridden ) { if ( rule . get Force ( ) ) { blocks . remove ( relevant . get Rule Props ( rule ) ) ; } } blocks . remove All ( allows ) ; return blocks . is Empty ( ) && ! allows . is Empty ( ) ; }
public static int decoded Length ( String secret ) { check Not Null ( secret ) ; secret = remove End ( remove End ( chomp ( secret ) , STRING ) , STRING ) ; return ( secret . length ( ) * NUM ) / NUM ; }
private Double read Double Number From Expression ( String expression ) throws Parsing Exception { Character c = expression . char At ( expression Iterator ) ; Double number = get Double Digit ( c ) ; while ( ++ expression Iterator < expression . length ( ) ) { c = expression . char At ( expression Iterator ) ; if ( ! Character . is Digit ( c ) ) { break ; } number *= NUM ; number += get Double Digit ( c ) ; } if ( c == STRING ) { if ( ++ expression Iterator == expression . length ( ) ) { throw new Parsing Exception ( ILLEGAL POSITION IN EXPRESSION + c ) ; } c = expression . char At ( expression Iterator ) ; double place Factor = NUM ; number += get Double Digit ( c ) / place Factor ; if ( ! Character . is Digit ( c ) ) { throw new Parsing Exception ( ILLEGAL POSITION IN EXPRESSION + c ) ; } while ( ++ expression Iterator < expression . length ( ) ) { c = expression . char At ( expression Iterator ) ; if ( ! Character . is Digit ( c ) ) { break ; } place Factor *= NUM ; number += get Double Digit ( c ) / place Factor ; } } -- expression Iterator ; return number ; }
static int write Var Long ( Output Stream out , long x ) throws IO Exception { int len = NUM ; while ( ( x & ~ NUM ) != NUM ) { out . write ( ( byte ) ( NUM | ( x & NUM ) ) ) ; x >>>= NUM ; len ++ ; } out . write ( ( byte ) x ) ; return ++ len ; }
public void clear Images ( ) { chunks . clear ( ) ; markers . clear ( ) ; redraw ( BOOL ) ; shift x = NUM ; shift y = NUM ; zoom level pos = NUM ; zoom level = NUM ; }
public void clear Images ( ) { chunks . clear ( ) ; markers . clear ( ) ; redraw ( BOOL ) ; shift x = NUM ; shift y = NUM ; zoom level pos = NUM ; zoom level = NUM ; }
public static String strip File Protocol ( String uri String ) { if ( uri String . starts With ( STRING ) ) { uri String = uri String . substring ( NUM ) ; } return uri String ; }
public static String strip File Protocol ( String uri String ) { if ( uri String . starts With ( STRING ) ) { uri String = uri String . substring ( NUM ) ; } return uri String ; }
public static String strip File Protocol ( String uri String ) { if ( uri String . starts With ( STRING ) ) { uri String = uri String . substring ( NUM ) ; } return uri String ; }
public static String strip File Protocol ( String uri String ) { if ( uri String . starts With ( STRING ) ) { uri String = uri String . substring ( NUM ) ; } return uri String ; }
void create Login Config ( ) { Hash Map < String , String > ssl Config Options = new Hash Map < > ( ) ; Hash Map < String , String > config Options = new Hash Map < > ( ) ; ssl Config Options . put ( Stub Login Module . ALLOW LOGIN PROPERTY , STRING ) ; ssl Config Options . put ( Stub Login Module . USERS PROPERTY , DN USERNAME ) ; ssl Config Options . put ( Stub Login Module . GROUPS PROPERTY , DN GROUP ) ; App Configuration Entry ssl Config Entry = new App Configuration Entry ( STRING , App Configuration Entry . Login Module Control Flag . REQUIRED , ssl Config Options ) ; config Options . put ( Stub Login Module . ALLOW LOGIN PROPERTY , STRING ) ; config Options . put ( Stub Login Module . USERS PROPERTY , INSECURE USERNAME ) ; config Options . put ( Stub Login Module . GROUPS PROPERTY , INSECURE GROUP ) ; App Configuration Entry config Entry = new App Configuration Entry ( STRING , App Configuration Entry . Login Module Control Flag . REQUIRED , config Options ) ; Stub Dual Jaas Configuration jaas Config = new Stub Dual Jaas Configuration ( config Entry , ssl Config Entry ) ; Configuration . set Configuration ( jaas Config ) ; }
private void validate Debug Settings ( ) { verify Diff Check Box . set Selected ( controller . is Diff Verification Enabled ( ) ) ; verify Encoding Check Box . set Selected ( controller . is Encoding Verification Enabled ( ) ) ; stats Output Check Box . set Selected ( controller . is Stats Output Enabled ( ) ) ; boolean flag A = controller . is Diff Verification Enabled ( ) || controller . is Encoding Verification Enabled ( ) ; debug Ouput Check Box . set Enabled ( flag A ) ; debug Ouput Check Box . set Selected ( controller . is Debug Output Enabled ( ) ) ; boolean flag B = controller . is Debug Output Enabled ( ) ; debug Output Label . set Enabled ( flag A && flag B ) ; debug Output Field . set Enabled ( flag A && flag B ) ; }
@ Override public void reset Learning ( ) { this . instances Seen = NUM ; this . class Instances = new Hash Map < > ( ) ; this . class Prototypes = new Hash Map < > ( ) ; this . attribute Observers = new Hash Map < > ( ) ; }
@ Override public void on Project Closed ( Project Action Event event ) { Project Descriptor project = event . get Project ( ) ; final String project Type Id = project . get Type ( ) ; boolean is JS Project = project Type Id . ends With ( STRING ) ; if ( is JS Project ) { workspace Agent . remove Part ( yeoman Part Presenter ) ; } }
@ Override public void on Project Closed ( Project Action Event event ) { Project Descriptor project = event . get Project ( ) ; final String project Type Id = project . get Type ( ) ; boolean is JS Project = project Type Id . ends With ( STRING ) ; if ( is JS Project ) { workspace Agent . remove Part ( yeoman Part Presenter ) ; } }
@ Override public void write ( T value ) throws Exception { marshaller . marshal ( value , os ) ; }
private Ok Http Client copy With Defaults ( ) { Ok Http Client result = new Ok Http Client ( this ) ; result . proxy = proxy ; result . proxy Selector = proxy Selector != null ? proxy Selector : Proxy Selector . get Default ( ) ; result . cookie Handler = cookie Handler != null ? cookie Handler : Cookie Handler . get Default ( ) ; result . response Cache = response Cache != null ? response Cache : Response Cache . get Default ( ) ; result . ssl Socket Factory = ssl Socket Factory != null ? ssl Socket Factory : Https URL Connection . get Default SSL Socket Factory ( ) ; result . hostname Verifier = hostname Verifier != null ? hostname Verifier : Ok Hostname Verifier . INSTANCE ; result . authenticator = authenticator != null ? authenticator : Http Authenticator . SYSTEM DEFAULT ; result . connection Pool = connection Pool != null ? connection Pool : Connection Pool . get Default ( ) ; result . follow Protocol Redirects = follow Protocol Redirects ; result . transports = transports != null ? transports : DEFAULT TRANSPORTS ; result . connect Timeout = connect Timeout ; result . read Timeout = read Timeout ; return result ; }
private Ok Http Client copy With Defaults ( ) { Ok Http Client result = new Ok Http Client ( this ) ; result . proxy = proxy ; result . proxy Selector = proxy Selector != null ? proxy Selector : Proxy Selector . get Default ( ) ; result . cookie Handler = cookie Handler != null ? cookie Handler : Cookie Handler . get Default ( ) ; result . response Cache = response Cache != null ? response Cache : Response Cache . get Default ( ) ; result . ssl Socket Factory = ssl Socket Factory != null ? ssl Socket Factory : Https URL Connection . get Default SSL Socket Factory ( ) ; result . hostname Verifier = hostname Verifier != null ? hostname Verifier : Ok Hostname Verifier . INSTANCE ; result . authenticator = authenticator != null ? authenticator : Http Authenticator . SYSTEM DEFAULT ; result . connection Pool = connection Pool != null ? connection Pool : Connection Pool . get Default ( ) ; result . follow Protocol Redirects = follow Protocol Redirects ; result . transports = transports != null ? transports : DEFAULT TRANSPORTS ; result . connect Timeout = connect Timeout ; result . read Timeout = read Timeout ; return result ; }
private Ok Http Client copy With Defaults ( ) { Ok Http Client result = new Ok Http Client ( this ) ; result . proxy = proxy ; result . proxy Selector = proxy Selector != null ? proxy Selector : Proxy Selector . get Default ( ) ; result . cookie Handler = cookie Handler != null ? cookie Handler : Cookie Handler . get Default ( ) ; result . response Cache = response Cache != null ? response Cache : Response Cache . get Default ( ) ; result . ssl Socket Factory = ssl Socket Factory != null ? ssl Socket Factory : Https URL Connection . get Default SSL Socket Factory ( ) ; result . hostname Verifier = hostname Verifier != null ? hostname Verifier : Ok Hostname Verifier . INSTANCE ; result . authenticator = authenticator != null ? authenticator : Http Authenticator . SYSTEM DEFAULT ; result . connection Pool = connection Pool != null ? connection Pool : Connection Pool . get Default ( ) ; result . follow Protocol Redirects = follow Protocol Redirects ; result . transports = transports != null ? transports : DEFAULT TRANSPORTS ; result . connect Timeout = connect Timeout ; result . read Timeout = read Timeout ; return result ; }
public Compute Task Timeout Checked Exception ( Throwable cause ) { this ( cause . get Message ( ) , cause ) ; }
public void test Get Elements By Tag Name NS 1 ( ) throws Throwable { Document doc ; Document new Doc ; Document Type doc Type = null ; DOM Implementation dom Impl ; Node List child List ; String null NS = null ; doc = ( Document ) load ( STRING , builder ) ; dom Impl = doc . get Implementation ( ) ; new Doc = dom Impl . create Document ( null NS , STRING , doc Type ) ; child List = new Doc . get Elements By Tag Name NS ( STRING , STRING ) ; assert Equals ( STRING , NUM , child List . get Length ( ) ) ; }
private Method find From String Method ( Class < ? > cls , boolean search Superclasses ) { Method matched = null ; Class < ? > loop Cls = cls ; while ( loop Cls != null && matched == null ) { Method [ ] methods = loop Cls . get Declared Methods ( ) ; for ( Method method : methods ) { From String from String = method . get Annotation ( From String . class ) ; if ( from String != null ) { if ( matched != null ) { throw new Illegal State Exception ( STRING ) ; } matched = method ; } } if ( search Superclasses == BOOL ) { break ; } loop Cls = loop Cls . get Superclass ( ) ; } return matched ; }
protected int size ( ) { return document . length ( ) ; }
public TS Data Optimizer Task ( @ Non Null Path dest Dir ) { this . dest Dir = dest Dir ; if ( ! Files . is Directory ( dest Dir ) ) throw new Illegal Argument Exception ( dest Dir + STRING ) ; }
public Manager Factory ( String database Url , Manager Pool pool , long poll Period , Time Unit unit , Connection Mode mode ) { this . database Url = database Url ; this . pool = pool ; this . poll Ms = unit . to Millis ( poll Period ) ; this . mode = mode ; try Create Tables ( ) ; }
public Manager Factory ( String database Url , Manager Pool pool , long poll Period , Time Unit unit , Connection Mode mode ) { this . database Url = database Url ; this . pool = pool ; this . poll Ms = unit . to Millis ( poll Period ) ; this . mode = mode ; try Create Tables ( ) ; }
boolean cancel ( int property Constant ) { if ( ( m Property Mask & property Constant ) != NUM && m Name Values Holder != null ) { int count = m Name Values Holder . size ( ) ; for ( int i = NUM ; i < count ; ++ i ) { Name Values Holder name Values Holder = m Name Values Holder . get ( i ) ; if ( name Values Holder . m Name Constant == property Constant ) { m Name Values Holder . remove ( i ) ; m Property Mask &= ~ property Constant ; return BOOL ; } } } return BOOL ; }
boolean cancel ( int property Constant ) { if ( ( m Property Mask & property Constant ) != NUM && m Name Values Holder != null ) { int count = m Name Values Holder . size ( ) ; for ( int i = NUM ; i < count ; ++ i ) { Name Values Holder name Values Holder = m Name Values Holder . get ( i ) ; if ( name Values Holder . m Name Constant == property Constant ) { m Name Values Holder . remove ( i ) ; m Property Mask &= ~ property Constant ; return BOOL ; } } } return BOOL ; }
boolean cancel ( int property Constant ) { if ( ( m Property Mask & property Constant ) != NUM && m Name Values Holder != null ) { int count = m Name Values Holder . size ( ) ; for ( int i = NUM ; i < count ; ++ i ) { Name Values Holder name Values Holder = m Name Values Holder . get ( i ) ; if ( name Values Holder . m Name Constant == property Constant ) { m Name Values Holder . remove ( i ) ; m Property Mask &= ~ property Constant ; return BOOL ; } } } return BOOL ; }
@ Override public Volatile Image create Back Buffer ( W Component Peer peer ) { Component target = ( Component ) peer . get Target ( ) ; return new Sun Volatile Image ( target , target . get Width ( ) , target . get Height ( ) , Boolean . TRUE ) ; }
public static Pattern build Stopword Pattern ( Collection < String > stopwords , Boolean case Sensitive ) { String Joiner sj = new String Joiner ( STRING ) ; for ( String s : stopwords ) { sj . add ( Pattern . quote ( s ) ) ; } if ( case Sensitive ) { return Pattern . compile ( STRING + sj . to String ( ) + STRING ) ; } else { return Pattern . compile ( STRING + sj . to String ( ) + STRING , Pattern . CASE INSENSITIVE ) ; } }
private int exception End Range ( int bc Index ) { int max = bcodes . length ( ) ; if ( start P Cs != null ) { for ( int spc : start P Cs ) { if ( bc Index < spc && max > spc ) { max = spc ; } } for ( int epc : end P Cs ) { if ( bc Index < epc && max > epc ) { max = epc ; } } } return max ; }
private int exception End Range ( int bc Index ) { int max = bcodes . length ( ) ; if ( start P Cs != null ) { for ( int spc : start P Cs ) { if ( bc Index < spc && max > spc ) { max = spc ; } } for ( int epc : end P Cs ) { if ( bc Index < epc && max > epc ) { max = epc ; } } } return max ; }
public boolean namespace Published To Mapgraph ( final String namespace ) throws Exception { assert Mapgraph Runtime Available ( ) ; final String repository Url = get Sparql Endpoint Url For Namespace Or Default ( namespace ) ; final Connect Options opts = new Connect Options ( repository Url , UUID . random UUID ( ) , null ) ; Jetty Response Listener response = null ; { opts . set Accept Header ( STRING ) ; opts . add Request Param ( MAPGRAPH , CHECK PUBLISHED ) ; opts . method = STRING ; } try { check Response Code ( response = do Connect ( opts ) ) ; final String response Body = response . get Response Body ( ) ; return response Body != null && response Body . contains ( STRING ) ; } finally { if ( response != null ) response . abort ( ) ; } }
public void clear ( ) { clear ( BOOL ) ; }
public void close ( ) { synchronized ( m Disk Cache Lock ) { if ( m Disk Lru Cache != null ) { try { if ( ! m Disk Lru Cache . is Closed ( ) ) { m Disk Lru Cache . close ( ) ; } } catch ( Throwable e ) { Log Utils . e ( e . get Message ( ) , e ) ; } m Disk Lru Cache = null ; } } }
public void close ( ) { synchronized ( m Disk Cache Lock ) { if ( m Disk Lru Cache != null ) { try { if ( ! m Disk Lru Cache . is Closed ( ) ) { m Disk Lru Cache . close ( ) ; } } catch ( Throwable e ) { Log Utils . e ( e . get Message ( ) , e ) ; } m Disk Lru Cache = null ; } } }
public void close ( ) { synchronized ( m Disk Cache Lock ) { if ( m Disk Lru Cache != null ) { try { if ( ! m Disk Lru Cache . is Closed ( ) ) { m Disk Lru Cache . close ( ) ; } } catch ( Throwable e ) { Log Utils . e ( e . get Message ( ) , e ) ; } m Disk Lru Cache = null ; } } }
public void close ( ) { synchronized ( m Disk Cache Lock ) { if ( m Disk Lru Cache != null ) { try { if ( ! m Disk Lru Cache . is Closed ( ) ) { m Disk Lru Cache . close ( ) ; } } catch ( Throwable e ) { Log Utils . e ( e . get Message ( ) , e ) ; } m Disk Lru Cache = null ; } } }
public void show Error ( Drawable error Image Drawable , String error Text Title , String error Text Content , String error Button Text , View . On Click Listener on Click Listener ) { switch State ( ERROR , error Image Drawable , error Text Title , error Text Content , error Button Text , on Click Listener , Collections . < Integer > empty List ( ) ) ; }
public void show Error ( Drawable error Image Drawable , String error Text Title , String error Text Content , String error Button Text , View . On Click Listener on Click Listener ) { switch State ( ERROR , error Image Drawable , error Text Title , error Text Content , error Button Text , on Click Listener , Collections . < Integer > empty List ( ) ) ; }
public void show Error ( Drawable error Image Drawable , String error Text Title , String error Text Content , String error Button Text , View . On Click Listener on Click Listener ) { switch State ( ERROR , error Image Drawable , error Text Title , error Text Content , error Button Text , on Click Listener , Collections . < Integer > empty List ( ) ) ; }
public void show Error ( Drawable error Image Drawable , String error Text Title , String error Text Content , String error Button Text , View . On Click Listener on Click Listener ) { switch State ( ERROR , error Image Drawable , error Text Title , error Text Content , error Button Text , on Click Listener , Collections . < Integer > empty List ( ) ) ; }
public void show Error ( Drawable error Image Drawable , String error Text Title , String error Text Content , String error Button Text , View . On Click Listener on Click Listener ) { switch State ( ERROR , error Image Drawable , error Text Title , error Text Content , error Button Text , on Click Listener , Collections . < Integer > empty List ( ) ) ; }
public static void run In Background ( Runnable runnable ) { background Executor . submit ( runnable ) ; }
public static void run In Background ( Runnable runnable ) { background Executor . submit ( runnable ) ; }
public static void run In Background ( Runnable runnable ) { background Executor . submit ( runnable ) ; }
protected void write Model File ( ) throws IO Exception { modfile = File . create Temp File ( STRING , STRING ) ; try ( Output Stream Writer fw = new Output Stream Writer ( new File Output Stream ( modfile ) , encoding ) ) { Js Compiler . begin Wrapper ( fw ) ; fw . write ( STRING ) ; Model Encoder . encode Model ( mmg . get Model ( ) , fw ) ; fw . write ( STRING ) ; Js Compiler . end Wrapper ( fw ) ; } finally { } }
public static void replace Value ( Example Set example Set , Attribute attribute , String old Value , String new Value ) { if ( ! attribute . is Nominal ( ) ) { throw new Runtime Exception ( STRING ) ; } Nominal Mapping mapping = attribute . get Mapping ( ) ; if ( old Value . equals ( STRING ) ) { for ( Example example : example Set ) { if ( Double . is Na N ( example . get Value ( attribute ) ) ) { example . set Value ( attribute , mapping . map String ( new Value ) ) ; } } } else { int old Index = mapping . get Index ( old Value ) ; if ( old Index < NUM ) { throw new Runtime Exception ( STRING ) ; } if ( new Value . equals ( STRING ) ) { for ( Example example : example Set ) { int index = mapping . get Index ( example . get Value As String ( attribute ) ) ; if ( index == old Index ) { example . set Value ( attribute , Double . Na N ) ; } } return ; } int new Index = mapping . get Index ( new Value ) ; if ( new Index >= NUM ) { for ( Example example : example Set ) { int index = mapping . get Index ( example . get Value As String ( attribute ) ) ; if ( index == old Index ) { example . set Value ( attribute , new Index ) ; } } } else { mapping . set Mapping ( new Value , old Index ) ; } } }
Login Process start Login Process ( Login Process login Process ) throws Auth Login Exception { Login Configuration login Configuration = login Process . get Login Configuration ( ) ; Http Servlet Request request = login Configuration . get Http Request ( ) ; Auth Index Type index Type = login Configuration . get Index Type ( ) ; String index Value = login Configuration . get Index Value ( ) ; Authentication Context auth Context = login Process . get Auth Context ( ) ; if ( index Type != null && index Type . equals ( Auth Index Type . RESOURCE ) ) { Map < String , Set < String > > env Map = core Services Wrapper . get Env Map ( request ) ; if ( String Utils . is Blank ( index Value ) || Boolean . parse Boolean ( index Value ) ) { index Value = core Services Wrapper . get Resource URL ( request ) ; } auth Context . login ( index Type . get Index Type ( ) , index Value , env Map , null ) ; } else if ( index Type != null && index Type . get Index Type ( ) != null ) { auth Context . login ( index Type . get Index Type ( ) , index Value ) ; } else { auth Context . login ( ) ; } try { Http Servlet Response response = login Configuration . get Http Response ( ) ; core Services Wrapper . set Lb Cookie ( auth Context . get Auth Context ( ) , request , response ) ; } catch ( Auth Exception e ) { throw new Auth Login Exception ( e ) ; } return login Process ; }
Login Process start Login Process ( Login Process login Process ) throws Auth Login Exception { Login Configuration login Configuration = login Process . get Login Configuration ( ) ; Http Servlet Request request = login Configuration . get Http Request ( ) ; Auth Index Type index Type = login Configuration . get Index Type ( ) ; String index Value = login Configuration . get Index Value ( ) ; Authentication Context auth Context = login Process . get Auth Context ( ) ; if ( index Type != null && index Type . equals ( Auth Index Type . RESOURCE ) ) { Map < String , Set < String > > env Map = core Services Wrapper . get Env Map ( request ) ; if ( String Utils . is Blank ( index Value ) || Boolean . parse Boolean ( index Value ) ) { index Value = core Services Wrapper . get Resource URL ( request ) ; } auth Context . login ( index Type . get Index Type ( ) , index Value , env Map , null ) ; } else if ( index Type != null && index Type . get Index Type ( ) != null ) { auth Context . login ( index Type . get Index Type ( ) , index Value ) ; } else { auth Context . login ( ) ; } try { Http Servlet Response response = login Configuration . get Http Response ( ) ; core Services Wrapper . set Lb Cookie ( auth Context . get Auth Context ( ) , request , response ) ; } catch ( Auth Exception e ) { throw new Auth Login Exception ( e ) ; } return login Process ; }
public void remove Cert By Alias ( String [ ] cert Aliases ) throws Key Store Exception { if ( cert Aliases == null ) { return ; } for ( String s : cert Aliases ) { key Store . delete Entry ( s ) ; } return ; }
public static final boolean execute Potential Work ( final Object data , final Image View image View ) { final Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final Object bitmap Data = bitmap Worker Task . m Key ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( BOOL ) ; } else { return BOOL ; } } return BOOL ; }
public static final boolean execute Potential Work ( final Object data , final Image View image View ) { final Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final Object bitmap Data = bitmap Worker Task . m Key ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( BOOL ) ; } else { return BOOL ; } } return BOOL ; }
public static final boolean execute Potential Work ( final Object data , final Image View image View ) { final Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final Object bitmap Data = bitmap Worker Task . m Key ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( BOOL ) ; } else { return BOOL ; } } return BOOL ; }
public void test Mark Supported ( ) { byte [ ] data = new byte [ ] { - NUM , - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM } ; Test Input Stream tis = new Test Input Stream ( data ) ; Cipher Input Stream cis = new Cipher Input Stream ( tis , new Null Cipher ( ) ) ; assert False ( STRING + STRING , cis . mark Supported ( ) ) ; }
private static int find Esds Position ( Parsable Byte Array parent , int position , int size ) { int child Atom Position = parent . get Position ( ) ; while ( child Atom Position - position < size ) { parent . set Position ( child Atom Position ) ; int child Atom Size = parent . read Int ( ) ; Assertions . check Argument ( child Atom Size > NUM , STRING ) ; int child Type = parent . read Int ( ) ; if ( child Type == Atom . TYPE esds ) { return child Atom Position ; } child Atom Position += child Atom Size ; } return - NUM ; }
public static Enum Set < Facet Range Include > parse Param ( final String [ ] param ) { if ( null == param || NUM == param . length ) return Enum Set . of ( LOWER ) ; final Enum Set < Facet Range Include > include = Enum Set . none Of ( Facet Range Include . class ) ; for ( final String o : param ) { include . add ( Facet Range Include . get ( o ) ) ; } if ( include . contains ( Facet Range Include . ALL ) ) return Enum Set . all Of ( Facet Range Include . class ) ; return include ; }
public boolean on Intercept Touch Event ( Motion Event ev ) { @ Suppress Warnings ( STRING ) final boolean debug = BOOL ; if ( debug ) { Log . d ( Launcher . TAG , STRING + ev + STRING + m Dragging ) ; } acquire Velocity Tracker And Add Movement ( ev ) ; final int action = ev . get Action ( ) ; final int [ ] drag Layer Pos = get Clamped Drag Layer Pos ( ev . get X ( ) , ev . get Y ( ) ) ; final int drag Layer X = drag Layer Pos [ NUM ] ; final int drag Layer Y = drag Layer Pos [ NUM ] ; switch ( action ) { case Motion Event . ACTION MOVE : break ; case Motion Event . ACTION DOWN : m Motion Down X = drag Layer X ; m Motion Down Y = drag Layer Y ; m Last Drop Target = null ; break ; case Motion Event . ACTION UP : m Last Touch Up Time = System . current Time Millis ( ) ; if ( m Dragging ) { Point F vec = is Flinging To Delete ( m Drag Object . drag Source ) ; if ( ! Delete Drop Target . will Accept Drop ( m Drag Object . drag Info ) ) { vec = null ; } if ( vec != null ) { drop On Fling To Delete Target ( drag Layer X , drag Layer Y , vec ) ; } else { drop ( drag Layer X , drag Layer Y ) ; } } end Drag ( ) ; break ; case Motion Event . ACTION CANCEL : cancel Drag ( ) ; break ; } return m Dragging ; }
public void volume Change ( Change Event e ) { J Slider v = ( J Slider ) e . get Source ( ) ; log . debug ( STRING + v . get Value ( ) ) ; fire Property Change ( Property Change ID . VOLUME CHANGE , v . get Value ( ) , v . get Value ( ) ) ; }
@ Override public final int read Unsigned Short ( ) throws IO Exception { dis . read Fully ( work , NUM , NUM ) ; return ( ( work [ NUM ] & NUM ) << NUM | ( work [ NUM ] & NUM ) ) ; }
@ Override public final int read Unsigned Short ( ) throws IO Exception { dis . read Fully ( work , NUM , NUM ) ; return ( ( work [ NUM ] & NUM ) << NUM | ( work [ NUM ] & NUM ) ) ; }
@ Override public final int read Unsigned Short ( ) throws IO Exception { dis . read Fully ( work , NUM , NUM ) ; return ( ( work [ NUM ] & NUM ) << NUM | ( work [ NUM ] & NUM ) ) ; }
private boolean try Increment ( Atomic Integer counter , int max ) { while ( BOOL ) { int count = counter . get ( ) ; if ( count >= max && max != NUM ) return BOOL ; if ( counter . compare And Set ( count , count + NUM ) ) return BOOL ; } }
private boolean try Increment ( Atomic Integer counter , int max ) { while ( BOOL ) { int count = counter . get ( ) ; if ( count >= max && max != NUM ) return BOOL ; if ( counter . compare And Set ( count , count + NUM ) ) return BOOL ; } }
public List < Order > fetch Orders ( int start Index ) { try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } return fetch Orders ( start Index , NUM ) ; }
public List < Order > fetch Orders ( int start Index ) { try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } return fetch Orders ( start Index , NUM ) ; }
public static boolean match User Status ( String id , User user ) { if ( id . equals ( STRING ) ) { if ( user . is Moderator ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Subscriber ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . has Turbo ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Admin ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Broadcaster ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Staff ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Bot ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Global Mod ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Admin ( ) || user . is Broadcaster ( ) || user . is Global Mod ( ) || user . is Moderator ( ) || user . is Staff ( ) ) { return BOOL ; } } return BOOL ; }
public static boolean match User Status ( String id , User user ) { if ( id . equals ( STRING ) ) { if ( user . is Moderator ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Subscriber ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . has Turbo ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Admin ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Broadcaster ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Staff ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Bot ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Global Mod ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Admin ( ) || user . is Broadcaster ( ) || user . is Global Mod ( ) || user . is Moderator ( ) || user . is Staff ( ) ) { return BOOL ; } } return BOOL ; }
public static boolean match User Status ( String id , User user ) { if ( id . equals ( STRING ) ) { if ( user . is Moderator ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Subscriber ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . has Turbo ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Admin ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Broadcaster ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Staff ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Bot ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Global Mod ( ) ) { return BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . is Admin ( ) || user . is Broadcaster ( ) || user . is Global Mod ( ) || user . is Moderator ( ) || user . is Staff ( ) ) { return BOOL ; } } return BOOL ; }
@ Override public void add Batch ( String sql ) throws SQL Exception { try { debug Code Call ( STRING , sql ) ; check Closed ( ) ; sql = Jdbc Connection . translate SQL ( sql , escape Processing ) ; if ( batch Commands == null ) { batch Commands = New . array List ( ) ; } batch Commands . add ( sql ) ; } catch ( Exception e ) { throw log And Convert ( e ) ; } }
public boolean has Dimension Or Filter ( String key ) { return dimensions . index Of ( new Base Dimensional Object ( key ) ) != - NUM || filters . index Of ( new Base Dimensional Object ( key ) ) != - NUM ; }
public Enumerated Distribution ( final List < Pair < T , Double > > pmf ) throws Math Illegal Argument Exception { singletons = new Array List < > ( pmf . size ( ) ) ; final double [ ] probs = new double [ pmf . size ( ) ] ; for ( int i = NUM ; i < pmf . size ( ) ; i ++ ) { final Pair < T , Double > sample = pmf . get ( i ) ; singletons . add ( sample . get Key ( ) ) ; final double p = sample . get Value ( ) ; probs [ i ] = p ; } probabilities = check And Normalize ( probs ) ; cumulative Probabilities = new double [ probabilities . length ] ; double sum = NUM ; for ( int i = NUM ; i < probabilities . length ; i ++ ) { sum += probabilities [ i ] ; cumulative Probabilities [ i ] = sum ; } }
public Enumerated Distribution ( final List < Pair < T , Double > > pmf ) throws Math Illegal Argument Exception { singletons = new Array List < > ( pmf . size ( ) ) ; final double [ ] probs = new double [ pmf . size ( ) ] ; for ( int i = NUM ; i < pmf . size ( ) ; i ++ ) { final Pair < T , Double > sample = pmf . get ( i ) ; singletons . add ( sample . get Key ( ) ) ; final double p = sample . get Value ( ) ; probs [ i ] = p ; } probabilities = check And Normalize ( probs ) ; cumulative Probabilities = new double [ probabilities . length ] ; double sum = NUM ; for ( int i = NUM ; i < probabilities . length ; i ++ ) { sum += probabilities [ i ] ; cumulative Probabilities [ i ] = sum ; } }
public Enumerated Distribution ( final List < Pair < T , Double > > pmf ) throws Math Illegal Argument Exception { singletons = new Array List < > ( pmf . size ( ) ) ; final double [ ] probs = new double [ pmf . size ( ) ] ; for ( int i = NUM ; i < pmf . size ( ) ; i ++ ) { final Pair < T , Double > sample = pmf . get ( i ) ; singletons . add ( sample . get Key ( ) ) ; final double p = sample . get Value ( ) ; probs [ i ] = p ; } probabilities = check And Normalize ( probs ) ; cumulative Probabilities = new double [ probabilities . length ] ; double sum = NUM ; for ( int i = NUM ; i < probabilities . length ; i ++ ) { sum += probabilities [ i ] ; cumulative Probabilities [ i ] = sum ; } }
public C Tag Filter Tree ( final I Tag Manager tag Manager ) { super ( new C Filter Tree Model ( tag Manager . get Root Tag ( ) ) ) ; m tag Manager = tag Manager ; set Dig In ( BOOL ) ; final Default Tree Cell Renderer renderer = new Default Tree Cell Renderer ( ) ; renderer . set Open Icon ( ICON CONTAINER TAG ) ; renderer . set Closed Icon ( ICON CONTAINER TAG ) ; renderer . set Leaf Icon ( ICON TAG ) ; set Cell Renderer ( renderer ) ; set Root Visible ( BOOL ) ; Tree Helpers . expand All ( this , BOOL ) ; tag Manager . add Listener ( m tag Manager Listener ) ; }
private void calculate Sun Rotation ( float offset , Time time , int canvas Width , int canvas Height ) { sun Position X = ( float ) ( canvas Width / NUM + ( canvas Width / NUM + NUM ) * Math . cos ( ( NUM * Math . PI * time . minute / NUM ) + offset - Math . PI / NUM ) ) ; sun Position Y = ( float ) ( canvas Height / NUM + ( canvas Width / NUM + NUM ) * Math . sin ( ( NUM * Math . PI * time . minute / NUM ) + offset - Math . PI / NUM ) ) ; }
private int find Split ( Array DBI Ds order , DBID Array Iter it , Double Data Store lambda ) { int split ; if ( minclusters > NUM ) { split = order . size ( ) > minclusters ? order . size ( ) - minclusters : NUM ; it . seek ( split ) ; final double stopdist = lambda . double Value ( it ) ; for ( it . retract ( ) ; it . valid ( ) && stopdist <= lambda . double Value ( it ) ; it . retract ( ) ) { split -- ; } } else if ( ! Double . is Na N ( threshold ) ) { split = order . size ( ) ; it . seek ( split - NUM ) ; while ( it . valid ( ) && threshold <= lambda . double Value ( it ) ) { split -- ; it . retract ( ) ; } } else { split = NUM ; } return split ; }
private synchronized void rebuild Journal ( ) throws IO Exception { if ( journal Writer != null ) { journal Writer . close ( ) ; } Writer writer = new Buffered Writer ( new File Writer ( journal File Tmp ) , IO BUFFER SIZE ) ; writer . write ( MAGIC ) ; writer . write ( STRING ) ; writer . write ( VERSION 1 ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( app Version ) ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( value Count ) ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; for ( Entry entry : lru Entries . values ( ) ) { if ( entry . current Editor != null ) { writer . write ( DIRTY + STRING + entry . key + STRING ) ; } else { writer . write ( CLEAN + STRING + entry . key + entry . get Lengths ( ) + STRING ) ; } } writer . close ( ) ; journal File Tmp . rename To ( journal File ) ; journal Writer = new Buffered Writer ( new File Writer ( journal File , BOOL ) , IO BUFFER SIZE ) ; }
private synchronized void rebuild Journal ( ) throws IO Exception { if ( journal Writer != null ) { journal Writer . close ( ) ; } Writer writer = new Buffered Writer ( new File Writer ( journal File Tmp ) , IO BUFFER SIZE ) ; writer . write ( MAGIC ) ; writer . write ( STRING ) ; writer . write ( VERSION 1 ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( app Version ) ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( value Count ) ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; for ( Entry entry : lru Entries . values ( ) ) { if ( entry . current Editor != null ) { writer . write ( DIRTY + STRING + entry . key + STRING ) ; } else { writer . write ( CLEAN + STRING + entry . key + entry . get Lengths ( ) + STRING ) ; } } writer . close ( ) ; journal File Tmp . rename To ( journal File ) ; journal Writer = new Buffered Writer ( new File Writer ( journal File , BOOL ) , IO BUFFER SIZE ) ; }
private synchronized void rebuild Journal ( ) throws IO Exception { if ( journal Writer != null ) { journal Writer . close ( ) ; } Writer writer = new Buffered Writer ( new File Writer ( journal File Tmp ) , IO BUFFER SIZE ) ; writer . write ( MAGIC ) ; writer . write ( STRING ) ; writer . write ( VERSION 1 ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( app Version ) ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( value Count ) ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; for ( Entry entry : lru Entries . values ( ) ) { if ( entry . current Editor != null ) { writer . write ( DIRTY + STRING + entry . key + STRING ) ; } else { writer . write ( CLEAN + STRING + entry . key + entry . get Lengths ( ) + STRING ) ; } } writer . close ( ) ; journal File Tmp . rename To ( journal File ) ; journal Writer = new Buffered Writer ( new File Writer ( journal File , BOOL ) , IO BUFFER SIZE ) ; }
protected void revert Setting ( String key ) { Key Panel kp = key Panels . get ( key ) ; kp . set Value ( get Setting ( key ) ) ; }
private void check Priority ( double priority ) { if ( Double . is Na N ( priority ) ) throw new Illegal Argument Exception ( priority + STRING ) ; }
private void check Priority ( double priority ) { if ( Double . is Na N ( priority ) ) throw new Illegal Argument Exception ( priority + STRING ) ; }
@ Override public void emit ( Alert Stream Event event ) { try { queue . put ( event ) ; } catch ( Interrupted Exception e ) { LOG . error ( e . get Message ( ) , e ) ; } }
public Cache put ( String host , Inet Address [ ] addresses ) { int policy = get Policy ( ) ; if ( policy == Inet Address Cache Policy . NEVER ) { return this ; } if ( policy != Inet Address Cache Policy . FOREVER ) { Linked List < String > expired = new Linked List < > ( ) ; long now = System . current Time Millis ( ) ; for ( String key : cache . key Set ( ) ) { Cache Entry entry = cache . get ( key ) ; if ( entry . expiration >= NUM && entry . expiration < now ) { expired . add ( key ) ; } else { break ; } } for ( String key : expired ) { cache . remove ( key ) ; } } long expiration ; if ( policy == Inet Address Cache Policy . FOREVER ) { expiration = - NUM ; } else { expiration = System . current Time Millis ( ) + ( policy * NUM ) ; } Cache Entry entry = new Cache Entry ( addresses , expiration ) ; cache . put ( host , entry ) ; return this ; }
public static void main ( String [ ] args ) { java . net . URL input 100 = Class Loader . get System Resource ( filename data 100 + STRING ) ; java . net . URL input 200 = Class Loader . get System Resource ( filename data 200 + STRING ) ; log . info ( STRING ) ; sg 100 = Spatial Grid . read From File ( input 100 . get File ( ) ) ; sg 200 = Spatial Grid . read From File ( input 200 . get File ( ) ) ; try { out = new File Writer ( output File ) ; out . write ( STRING ) ; out . write ( STRING ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } log . info ( STRING + filename data 200 + STRING ) ; test One Method ( Interpolation . BILINEAR , Double . Na N ) ; test One Method ( Interpolation . BICUBIC , Double . Na N ) ; for ( int e = NUM ; e <= NUM ; e ++ ) { test One Method ( Interpolation . INVERSE DISTANCE WEIGHTING , e ) ; } try { out . write ( STRING ) ; out . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } log . info ( STRING ) ; }
public static void main ( String [ ] args ) { java . net . URL input 100 = Class Loader . get System Resource ( filename data 100 + STRING ) ; java . net . URL input 200 = Class Loader . get System Resource ( filename data 200 + STRING ) ; log . info ( STRING ) ; sg 100 = Spatial Grid . read From File ( input 100 . get File ( ) ) ; sg 200 = Spatial Grid . read From File ( input 200 . get File ( ) ) ; try { out = new File Writer ( output File ) ; out . write ( STRING ) ; out . write ( STRING ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } log . info ( STRING + filename data 200 + STRING ) ; test One Method ( Interpolation . BILINEAR , Double . Na N ) ; test One Method ( Interpolation . BICUBIC , Double . Na N ) ; for ( int e = NUM ; e <= NUM ; e ++ ) { test One Method ( Interpolation . INVERSE DISTANCE WEIGHTING , e ) ; } try { out . write ( STRING ) ; out . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } log . info ( STRING ) ; }
public static void main ( String [ ] args ) { java . net . URL input 100 = Class Loader . get System Resource ( filename data 100 + STRING ) ; java . net . URL input 200 = Class Loader . get System Resource ( filename data 200 + STRING ) ; log . info ( STRING ) ; sg 100 = Spatial Grid . read From File ( input 100 . get File ( ) ) ; sg 200 = Spatial Grid . read From File ( input 200 . get File ( ) ) ; try { out = new File Writer ( output File ) ; out . write ( STRING ) ; out . write ( STRING ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } log . info ( STRING + filename data 200 + STRING ) ; test One Method ( Interpolation . BILINEAR , Double . Na N ) ; test One Method ( Interpolation . BICUBIC , Double . Na N ) ; for ( int e = NUM ; e <= NUM ; e ++ ) { test One Method ( Interpolation . INVERSE DISTANCE WEIGHTING , e ) ; } try { out . write ( STRING ) ; out . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } log . info ( STRING ) ; }
public Range < C > until ( C to ) { Objects . require Non Null ( to ) ; this . to = to ; to Included = BOOL ; return this ; }
public Range < C > until ( C to ) { Objects . require Non Null ( to ) ; this . to = to ; to Included = BOOL ; return this ; }
public Range < C > until ( C to ) { Objects . require Non Null ( to ) ; this . to = to ; to Included = BOOL ; return this ; }
public void add ( Test test ) { tests . add ( test ) ; }
private int calculate 8 Bit Checksum ( String info String ) { int len = info String . length ( ) ; if ( ( ( len + NUM ) / NUM ) != ( len / NUM ) ) { return - NUM ; } int calculated Checksum = NUM ; for ( int i = NUM ; i < len ; i += NUM ) { calculated Checksum += Integer . parse Int ( info String . substring ( i , i + NUM ) , NUM ) ; } return ( NUM & ( NUM - ( calculated Checksum & NUM ) ) ) ; }
private int calculate 8 Bit Checksum ( String info String ) { int len = info String . length ( ) ; if ( ( ( len + NUM ) / NUM ) != ( len / NUM ) ) { return - NUM ; } int calculated Checksum = NUM ; for ( int i = NUM ; i < len ; i += NUM ) { calculated Checksum += Integer . parse Int ( info String . substring ( i , i + NUM ) , NUM ) ; } return ( NUM & ( NUM - ( calculated Checksum & NUM ) ) ) ; }
private int calculate 8 Bit Checksum ( String info String ) { int len = info String . length ( ) ; if ( ( ( len + NUM ) / NUM ) != ( len / NUM ) ) { return - NUM ; } int calculated Checksum = NUM ; for ( int i = NUM ; i < len ; i += NUM ) { calculated Checksum += Integer . parse Int ( info String . substring ( i , i + NUM ) , NUM ) ; } return ( NUM & ( NUM - ( calculated Checksum & NUM ) ) ) ; }
private int calculate 8 Bit Checksum ( String info String ) { int len = info String . length ( ) ; if ( ( ( len + NUM ) / NUM ) != ( len / NUM ) ) { return - NUM ; } int calculated Checksum = NUM ; for ( int i = NUM ; i < len ; i += NUM ) { calculated Checksum += Integer . parse Int ( info String . substring ( i , i + NUM ) , NUM ) ; } return ( NUM & ( NUM - ( calculated Checksum & NUM ) ) ) ; }
private int calculate 8 Bit Checksum ( String info String ) { int len = info String . length ( ) ; if ( ( ( len + NUM ) / NUM ) != ( len / NUM ) ) { return - NUM ; } int calculated Checksum = NUM ; for ( int i = NUM ; i < len ; i += NUM ) { calculated Checksum += Integer . parse Int ( info String . substring ( i , i + NUM ) , NUM ) ; } return ( NUM & ( NUM - ( calculated Checksum & NUM ) ) ) ; }
private int calculate 8 Bit Checksum ( String info String ) { int len = info String . length ( ) ; if ( ( ( len + NUM ) / NUM ) != ( len / NUM ) ) { return - NUM ; } int calculated Checksum = NUM ; for ( int i = NUM ; i < len ; i += NUM ) { calculated Checksum += Integer . parse Int ( info String . substring ( i , i + NUM ) , NUM ) ; } return ( NUM & ( NUM - ( calculated Checksum & NUM ) ) ) ; }
private int calculate 8 Bit Checksum ( String info String ) { int len = info String . length ( ) ; if ( ( ( len + NUM ) / NUM ) != ( len / NUM ) ) { return - NUM ; } int calculated Checksum = NUM ; for ( int i = NUM ; i < len ; i += NUM ) { calculated Checksum += Integer . parse Int ( info String . substring ( i , i + NUM ) , NUM ) ; } return ( NUM & ( NUM - ( calculated Checksum & NUM ) ) ) ; }
private int calculate 8 Bit Checksum ( String info String ) { int len = info String . length ( ) ; if ( ( ( len + NUM ) / NUM ) != ( len / NUM ) ) { return - NUM ; } int calculated Checksum = NUM ; for ( int i = NUM ; i < len ; i += NUM ) { calculated Checksum += Integer . parse Int ( info String . substring ( i , i + NUM ) , NUM ) ; } return ( NUM & ( NUM - ( calculated Checksum & NUM ) ) ) ; }
private int calculate 8 Bit Checksum ( String info String ) { int len = info String . length ( ) ; if ( ( ( len + NUM ) / NUM ) != ( len / NUM ) ) { return - NUM ; } int calculated Checksum = NUM ; for ( int i = NUM ; i < len ; i += NUM ) { calculated Checksum += Integer . parse Int ( info String . substring ( i , i + NUM ) , NUM ) ; } return ( NUM & ( NUM - ( calculated Checksum & NUM ) ) ) ; }
private int calculate 8 Bit Checksum ( String info String ) { int len = info String . length ( ) ; if ( ( ( len + NUM ) / NUM ) != ( len / NUM ) ) { return - NUM ; } int calculated Checksum = NUM ; for ( int i = NUM ; i < len ; i += NUM ) { calculated Checksum += Integer . parse Int ( info String . substring ( i , i + NUM ) , NUM ) ; } return ( NUM & ( NUM - ( calculated Checksum & NUM ) ) ) ; }
private int calculate 8 Bit Checksum ( String info String ) { int len = info String . length ( ) ; if ( ( ( len + NUM ) / NUM ) != ( len / NUM ) ) { return - NUM ; } int calculated Checksum = NUM ; for ( int i = NUM ; i < len ; i += NUM ) { calculated Checksum += Integer . parse Int ( info String . substring ( i , i + NUM ) , NUM ) ; } return ( NUM & ( NUM - ( calculated Checksum & NUM ) ) ) ; }
private int calculate 8 Bit Checksum ( String info String ) { int len = info String . length ( ) ; if ( ( ( len + NUM ) / NUM ) != ( len / NUM ) ) { return - NUM ; } int calculated Checksum = NUM ; for ( int i = NUM ; i < len ; i += NUM ) { calculated Checksum += Integer . parse Int ( info String . substring ( i , i + NUM ) , NUM ) ; } return ( NUM & ( NUM - ( calculated Checksum & NUM ) ) ) ; }
private void add Notification Category Separator ( J Panel panel ) { J Separator jsep = new J Separator ( Swing Constants . HORIZONTAL ) ; jsep . set Maximum Size ( new Dimension ( Short . MAX VALUE , NUM ) ) ; panel . add ( jsep ) ; }
public static List series Name List From Data Array ( Object [ ] [ ] data ) { int series Count = data . length ; List series Name List = new java . util . Array List ( series Count ) ; for ( int i = NUM ; i < series Count ; i ++ ) { series Name List . add ( STRING + ( i + NUM ) ) ; } return series Name List ; }
public static String remove Static Attribute Flag ( String attribute Name ) { if ( is Static Attribute ( attribute Name ) ) { return attribute Name . substring ( STATIC QUOTE . length ( ) , attribute Name . length ( ) - STATIC QUOTE . length ( ) ) ; } else { return attribute Name ; } }
protected int hash ( Object o ) { int h = o == null ? NUM : o . hash Code ( ) ; h += ( h << NUM ) ^ NUM ; h ^= ( h > > > NUM ) ; h += ( h << NUM ) ; h ^= ( h > > > NUM ) ; h += ( h << NUM ) + ( h << NUM ) ; return h ^ ( h > > > NUM ) ; }
public static String string To Base 64 ( final String data ) { return Base 64 . encode Base 64 String ( Conversion Utils . string To Array ( data ) ) ; }
public static String string To Base 64 ( final String data ) { return Base 64 . encode Base 64 String ( Conversion Utils . string To Array ( data ) ) ; }
public void build Network ( ) { Neuron first Neuron = new Neuron ( network , DEFAULT NEURON TYPE ) ; List < Neuron > current Layer = new Array List < Neuron > ( ) ; first Neuron . set Position ( initial Position ) ; current Layer . add ( first Neuron ) ; int num Neurons Last Layer = ( int ) Math . pow ( num Braches Per Neuron , num Layers ) ; double total Space = num Neurons Last Layer * horizontal Spacing ; for ( int layer Index = NUM ; layer Index <= num Layers ; layer Index ++ ) { List < Neuron > temp List = new Array List < Neuron > ( ) ; double layer Spacing = total Space / ( int ) Math . pow ( num Braches Per Neuron , layer Index ) ; double branch Width = layer Spacing * ( num Braches Per Neuron - NUM ) ; for ( Neuron base Neuron : current Layer ) { network . add Neuron ( base Neuron ) ; double initial X Offset = branch Width / NUM ; for ( int j = NUM ; j < num Braches Per Neuron ; j ++ ) { Neuron target Neuron = new Neuron ( network , new Linear Rule ( ) ) ; target Neuron . set Location ( base Neuron . get X ( ) - initial X Offset + ( j * layer Spacing ) , initial Position . y - ( layer Index * vertical Spacing ) ) ; temp List . add ( target Neuron ) ; network . add Neuron ( target Neuron ) ; target Neuron . set Update Priority ( layer Index ) ; Synapse synapse = new Synapse ( network , base Neuron , target Neuron , new Static Synapse Rule ( ) ) ; network . add Synapse ( synapse ) ; } } current Layer = temp List ; } }
void start Scrolling Instance ( ) { if ( log . is Loggable ( Platform Logger . Level . FINER ) ) { log . finer ( STRING + this ) ; } scroll ( ) ; i scroller . set Scrollbar ( this ) ; i scroller . start ( ) ; }
void start Scrolling Instance ( ) { if ( log . is Loggable ( Platform Logger . Level . FINER ) ) { log . finer ( STRING + this ) ; } scroll ( ) ; i scroller . set Scrollbar ( this ) ; i scroller . start ( ) ; }
void start Scrolling Instance ( ) { if ( log . is Loggable ( Platform Logger . Level . FINER ) ) { log . finer ( STRING + this ) ; } scroll ( ) ; i scroller . set Scrollbar ( this ) ; i scroller . start ( ) ; }
public void reset Duration ( ) { start = System . current Time Millis ( ) ; }
public Extension User Management ( ) { initialize ( ) ; }
private void startup Processor ( ) { Processor processor = processor Ref . get ( ) ; if ( processor == null ) { processor = new Processor ( ) ; if ( processor Ref . compare And Set ( null , processor ) ) { executor . execute ( new Name Preserving Runnable ( processor , thread Name ) ) ; } } wakeup ( ) ; }
private void startup Processor ( ) { Processor processor = processor Ref . get ( ) ; if ( processor == null ) { processor = new Processor ( ) ; if ( processor Ref . compare And Set ( null , processor ) ) { executor . execute ( new Name Preserving Runnable ( processor , thread Name ) ) ; } } wakeup ( ) ; }
private void startup Processor ( ) { Processor processor = processor Ref . get ( ) ; if ( processor == null ) { processor = new Processor ( ) ; if ( processor Ref . compare And Set ( null , processor ) ) { executor . execute ( new Name Preserving Runnable ( processor , thread Name ) ) ; } } wakeup ( ) ; }
private void startup Processor ( ) { Processor processor = processor Ref . get ( ) ; if ( processor == null ) { processor = new Processor ( ) ; if ( processor Ref . compare And Set ( null , processor ) ) { executor . execute ( new Name Preserving Runnable ( processor , thread Name ) ) ; } } wakeup ( ) ; }
private void startup Processor ( ) { Processor processor = processor Ref . get ( ) ; if ( processor == null ) { processor = new Processor ( ) ; if ( processor Ref . compare And Set ( null , processor ) ) { executor . execute ( new Name Preserving Runnable ( processor , thread Name ) ) ; } } wakeup ( ) ; }
protected static Boolean lock ( String service Name , Object name ) { Distributed Lock Service service = Distributed Lock Service . get Service Named ( service Name ) ; boolean locked = service . lock ( name , NUM , - NUM ) ; return Boolean . value Of ( locked ) ; }
private boolean is Continuation Line ( final String line ) { return line . char At ( NUM ) == STRING || line . char At ( NUM ) == STRING ; }
private boolean is Continuation Line ( final String line ) { return line . char At ( NUM ) == STRING || line . char At ( NUM ) == STRING ; }
private boolean is Continuation Line ( final String line ) { return line . char At ( NUM ) == STRING || line . char At ( NUM ) == STRING ; }
private boolean is Continuation Line ( final String line ) { return line . char At ( NUM ) == STRING || line . char At ( NUM ) == STRING ; }
private Byte Buffer write Header To Buffer ( int padding , int size ) throws IO Exception { compression = BOOL ; Byte Buffer header Buffer = Byte Buffer . allocate ( TAG HEADER LENGTH ) ; header Buffer . put ( TAG ID ) ; header Buffer . put ( get Major Version ( ) ) ; header Buffer . put ( get Revision ( ) ) ; byte flags = ( byte ) NUM ; if ( unsynchronization ) { flags |= ( byte ) MASK V22 UNSYNCHRONIZATION ; } if ( compression ) { flags |= ( byte ) MASK V22 COMPRESSION ; } header Buffer . put ( flags ) ; header Buffer . put ( ID 3 Sync Safe Integer . value To Buffer ( padding + size ) ) ; header Buffer . flip ( ) ; return header Buffer ; }
public Map < String , List < String > > to Multimap ( boolean response ) { Map < String , List < String > > result = new Tree Map < String , List < String > > ( FIELD NAME COMPARATOR ) ; for ( int i = NUM ; i < names And Values . size ( ) ; i += NUM ) { String field Name = names And Values . get ( i ) ; String value = names And Values . get ( i + NUM ) ; List < String > all Values = new Array List < String > ( ) ; List < String > other Values = result . get ( field Name ) ; if ( other Values != null ) { all Values . add All ( other Values ) ; } all Values . add ( value ) ; result . put ( field Name , Collections . unmodifiable List ( all Values ) ) ; } if ( response && status Line != null ) { result . put ( null , Collections . unmodifiable List ( Collections . singleton List ( status Line ) ) ) ; } else if ( request Line != null ) { result . put ( null , Collections . unmodifiable List ( Collections . singleton List ( request Line ) ) ) ; } return Collections . unmodifiable Map ( result ) ; }
public Map < String , List < String > > to Multimap ( boolean response ) { Map < String , List < String > > result = new Tree Map < String , List < String > > ( FIELD NAME COMPARATOR ) ; for ( int i = NUM ; i < names And Values . size ( ) ; i += NUM ) { String field Name = names And Values . get ( i ) ; String value = names And Values . get ( i + NUM ) ; List < String > all Values = new Array List < String > ( ) ; List < String > other Values = result . get ( field Name ) ; if ( other Values != null ) { all Values . add All ( other Values ) ; } all Values . add ( value ) ; result . put ( field Name , Collections . unmodifiable List ( all Values ) ) ; } if ( response && status Line != null ) { result . put ( null , Collections . unmodifiable List ( Collections . singleton List ( status Line ) ) ) ; } else if ( request Line != null ) { result . put ( null , Collections . unmodifiable List ( Collections . singleton List ( request Line ) ) ) ; } return Collections . unmodifiable Map ( result ) ; }
public Map < String , List < String > > to Multimap ( boolean response ) { Map < String , List < String > > result = new Tree Map < String , List < String > > ( FIELD NAME COMPARATOR ) ; for ( int i = NUM ; i < names And Values . size ( ) ; i += NUM ) { String field Name = names And Values . get ( i ) ; String value = names And Values . get ( i + NUM ) ; List < String > all Values = new Array List < String > ( ) ; List < String > other Values = result . get ( field Name ) ; if ( other Values != null ) { all Values . add All ( other Values ) ; } all Values . add ( value ) ; result . put ( field Name , Collections . unmodifiable List ( all Values ) ) ; } if ( response && status Line != null ) { result . put ( null , Collections . unmodifiable List ( Collections . singleton List ( status Line ) ) ) ; } else if ( request Line != null ) { result . put ( null , Collections . unmodifiable List ( Collections . singleton List ( request Line ) ) ) ; } return Collections . unmodifiable Map ( result ) ; }
public Map < String , List < String > > to Multimap ( boolean response ) { Map < String , List < String > > result = new Tree Map < String , List < String > > ( FIELD NAME COMPARATOR ) ; for ( int i = NUM ; i < names And Values . size ( ) ; i += NUM ) { String field Name = names And Values . get ( i ) ; String value = names And Values . get ( i + NUM ) ; List < String > all Values = new Array List < String > ( ) ; List < String > other Values = result . get ( field Name ) ; if ( other Values != null ) { all Values . add All ( other Values ) ; } all Values . add ( value ) ; result . put ( field Name , Collections . unmodifiable List ( all Values ) ) ; } if ( response && status Line != null ) { result . put ( null , Collections . unmodifiable List ( Collections . singleton List ( status Line ) ) ) ; } else if ( request Line != null ) { result . put ( null , Collections . unmodifiable List ( Collections . singleton List ( request Line ) ) ) ; } return Collections . unmodifiable Map ( result ) ; }
public static boolean is Protected ( int mod ) { return Modifier . is Protected ( mod ) ; }
public static boolean is Protected ( int mod ) { return Modifier . is Protected ( mod ) ; }
void acknowledge ( ) throws Commit Failed Exception { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + m session ID ) ; } unacked Messages . clear ( ) ; if ( this . m is Queue && ! is Auto Ack ( ) ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING + tx ) ; } commit Local Transaction ( ) ; } }
void acknowledge ( ) throws Commit Failed Exception { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + m session ID ) ; } unacked Messages . clear ( ) ; if ( this . m is Queue && ! is Auto Ack ( ) ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING + tx ) ; } commit Local Transaction ( ) ; } }
void acknowledge ( ) throws Commit Failed Exception { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + m session ID ) ; } unacked Messages . clear ( ) ; if ( this . m is Queue && ! is Auto Ack ( ) ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING + tx ) ; } commit Local Transaction ( ) ; } }
static boolean is Viable Phone Number ( String number ) { if ( number . length ( ) < MIN LENGTH FOR NSN ) { return BOOL ; } Matcher m = VALID PHONE NUMBER PATTERN . matcher ( number ) ; return m . matches ( ) ; }
static boolean is Viable Phone Number ( String number ) { if ( number . length ( ) < MIN LENGTH FOR NSN ) { return BOOL ; } Matcher m = VALID PHONE NUMBER PATTERN . matcher ( number ) ; return m . matches ( ) ; }
static boolean is Viable Phone Number ( String number ) { if ( number . length ( ) < MIN LENGTH FOR NSN ) { return BOOL ; } Matcher m = VALID PHONE NUMBER PATTERN . matcher ( number ) ; return m . matches ( ) ; }
static boolean is Viable Phone Number ( String number ) { if ( number . length ( ) < MIN LENGTH FOR NSN ) { return BOOL ; } Matcher m = VALID PHONE NUMBER PATTERN . matcher ( number ) ; return m . matches ( ) ; }
static boolean is Viable Phone Number ( String number ) { if ( number . length ( ) < MIN LENGTH FOR NSN ) { return BOOL ; } Matcher m = VALID PHONE NUMBER PATTERN . matcher ( number ) ; return m . matches ( ) ; }
static boolean is Viable Phone Number ( String number ) { if ( number . length ( ) < MIN LENGTH FOR NSN ) { return BOOL ; } Matcher m = VALID PHONE NUMBER PATTERN . matcher ( number ) ; return m . matches ( ) ; }
public void darker Color ( int factor ) { int color = get Color ( ) ; int r = color > > NUM & NUM ; int g = color > > NUM & NUM ; int b = color & NUM ; r = Math . max ( NUM , r - factor ) ; g = Math . max ( NUM , g - factor ) ; b = Math . max ( NUM , b - factor ) ; set Color ( ( ( r << NUM ) & NUM ) | ( ( g << NUM ) & NUM ) | ( b & NUM ) ) ; }
protected void configure Reader ( XML Reader reader , Default Handler handler ) throws Document Exception { SAX Helper . set Parser Property ( reader , SAX LEXICALHANDLER , handler ) ; SAX Helper . set Parser Property ( reader , SAX LEXICAL HANDLER , handler ) ; if ( include Internal DTD Declarations || include External DTD Declarations ) { SAX Helper . set Parser Property ( reader , SAX DECL HANDLER , handler ) ; } SAX Helper . set Parser Feature ( reader , SAX NAMESPACES , BOOL ) ; SAX Helper . set Parser Feature ( reader , SAX NAMESPACE PREFIXES , BOOL ) ; SAX Helper . set Parser Feature ( reader , SAX STRING INTERNING , is String Intern Enabled ( ) ) ; SAX Helper . set Parser Feature ( reader , STRING , BOOL ) ; try { reader . set Feature ( STRING , is Validating ( ) ) ; if ( error Handler != null ) { reader . set Error Handler ( error Handler ) ; } else { reader . set Error Handler ( handler ) ; } } catch ( Exception e ) { if ( is Validating ( ) ) { throw new Document Exception ( STRING + STRING + reader , e ) ; } } }
public void write Data To File ( byte [ ] key Array , byte [ ] [ ] data Array , int entry Count , byte [ ] start Key , byte [ ] end Key ) throws Carbon Data Writer Exception { if ( this . is New File Creation Required ) { update Blocklet File Channel ( ) ; } int total Msr Array Size = NUM ; int current Msr Lenght = NUM ; int [ ] msr Length = new int [ this . measure Count ] ; for ( int i = NUM ; i < data Array . length ; i ++ ) { current Msr Lenght = data Array [ i ] . length ; total Msr Array Size += current Msr Lenght ; msr Length [ i ] = current Msr Lenght ; } byte [ ] writable Data Array = new byte [ total Msr Array Size ] ; int start Position = NUM ; for ( int i = NUM ; i < data Array . length ; i ++ ) { System . arraycopy ( data Array [ i ] , NUM , writable Data Array , start Position , data Array [ i ] . length ) ; start Position += msr Length [ i ] ; } write Data To File ( key Array , writable Data Array , msr Length , entry Count , start Key , end Key ) ; }
public void write Data To File ( byte [ ] key Array , byte [ ] [ ] data Array , int entry Count , byte [ ] start Key , byte [ ] end Key ) throws Carbon Data Writer Exception { if ( this . is New File Creation Required ) { update Blocklet File Channel ( ) ; } int total Msr Array Size = NUM ; int current Msr Lenght = NUM ; int [ ] msr Length = new int [ this . measure Count ] ; for ( int i = NUM ; i < data Array . length ; i ++ ) { current Msr Lenght = data Array [ i ] . length ; total Msr Array Size += current Msr Lenght ; msr Length [ i ] = current Msr Lenght ; } byte [ ] writable Data Array = new byte [ total Msr Array Size ] ; int start Position = NUM ; for ( int i = NUM ; i < data Array . length ; i ++ ) { System . arraycopy ( data Array [ i ] , NUM , writable Data Array , start Position , data Array [ i ] . length ) ; start Position += msr Length [ i ] ; } write Data To File ( key Array , writable Data Array , msr Length , entry Count , start Key , end Key ) ; }
public boolean read Message ( Input Stream is , Outbox Amp outbox ) throws IO Exception { In H 3 h In = h In ; if ( is . available ( ) < NUM ) { return BOOL ; } try { return read Message ( h In , outbox ) ; } finally { } }
public boolean read Message ( Input Stream is , Outbox Amp outbox ) throws IO Exception { In H 3 h In = h In ; if ( is . available ( ) < NUM ) { return BOOL ; } try { return read Message ( h In , outbox ) ; } finally { } }
public boolean read Message ( Input Stream is , Outbox Amp outbox ) throws IO Exception { In H 3 h In = h In ; if ( is . available ( ) < NUM ) { return BOOL ; } try { return read Message ( h In , outbox ) ; } finally { } }
public static < T > T first ( List < T > l ) { return l . get ( NUM ) ; }
public boolean write Characteristic ( Bluetooth Gatt Characteristic characteristic , String value ) { return write Characteristic ( characteristic , value . get Bytes ( ) ) ; }
private boolean has Searchable Columns ( ) { boolean ret Value = BOOL ; m table Name = M Query . get Zoom Table Name ( m column Name ) ; m key Column Name = M Query . get Zoom Column Name ( m column Name ) ; if ( m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) ) { ret Value = BOOL ; } else { String query = STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( query , null ) ; pstmt . set String ( NUM , m key Column Name ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { ret Value = BOOL ; } } catch ( SQL Exception ex ) { log . log ( Level . SEVERE , query , ex ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } } return ret Value ; }
private boolean has Searchable Columns ( ) { boolean ret Value = BOOL ; m table Name = M Query . get Zoom Table Name ( m column Name ) ; m key Column Name = M Query . get Zoom Column Name ( m column Name ) ; if ( m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) ) { ret Value = BOOL ; } else { String query = STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( query , null ) ; pstmt . set String ( NUM , m key Column Name ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { ret Value = BOOL ; } } catch ( SQL Exception ex ) { log . log ( Level . SEVERE , query , ex ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } } return ret Value ; }
public void send ( Set recipients , boolean multicast ) throws Interrupted Exception , Reply Exception { final boolean is Debug Enabled = logger . is Debug Enabled ( ) ; if ( Thread . interrupted ( ) ) throw new Interrupted Exception ( ) ; recipients = new Hash Set ( recipients ) ; Distributed Member me = origin Dm . get Distribution Manager Id ( ) ; if ( recipients . contains ( me ) ) { recipients . remove ( me ) ; } if ( is Debug Enabled ) { logger . debug ( STRING , recipients ) ; } rp = new Reply Processor 21 ( origin Dm , recipients ) ; processor Id = rp . get Processor Id ( ) ; set Recipients ( recipients ) ; set Multicast ( multicast ) ; Set failures = origin Dm . put Outgoing ( this ) ; if ( failures != null && failures . size ( ) > NUM ) { for ( Iterator i = failures . iterator ( ) ; i . has Next ( ) ; ) { Internal Distributed Member mbr = ( Internal Distributed Member ) i . next ( ) ; if ( is Debug Enabled ) { logger . debug ( STRING , mbr ) ; } } } rp . wait For Replies ( ) ; }
@ Override public boolean remove ( Object o ) { if ( o == null || size == NUM ) { return BOOL ; } for ( int i = NUM ; i < size ; i ++ ) { if ( o . equals ( elements [ i ] ) ) { remove At ( i ) ; return BOOL ; } } return BOOL ; }
public CIDR ( String cidr Or IP ) { String [ ] parts = cidr Or IP . split ( STRING ) ; if ( ( parts . length < NUM ) || ( parts . length > NUM ) ) throw new Illegal Argument Exception ( cidr Or IP + STRING ) ; bits = ( NUM == parts . length ) ? NUM : Short . parse Short ( parts [ NUM ] ) ; if ( ( bits < NUM ) || ( bits > NUM ) ) throw new Illegal Argument Exception ( cidr Or IP + STRING + bits + STRING ) ; this . first IP = to IP ( parts [ NUM ] ) ; }
public void start ( ) ;
private void hide Main Layout And Toast ( String text ) { m Main Layout . set Visibility ( View . GONE ) ; m Progress Text View . set Visibility ( View . VISIBLE ) ; m Progress Text View . set Text ( text ) ; }
public void add Animation ( Animation Object o ) { Animation Object [ ] n = new Animation Object [ animations . length + NUM ] ; System . arraycopy ( animations , NUM , n , NUM , animations . length ) ; n [ animations . length ] = o ; animations = n ; }
public void add Animation ( Animation Object o ) { Animation Object [ ] n = new Animation Object [ animations . length + NUM ] ; System . arraycopy ( animations , NUM , n , NUM , animations . length ) ; n [ animations . length ] = o ; animations = n ; }
public String read String ( ) throws IO Exception { return dis . read UTF ( ) ; }
public Outer Join Qualifier add ( String property Left , String property Right ) { additional Properties . add ( new Property Value Expression Pair ( new Property Value Expression ( property Left ) , new Property Value Expression ( property Right ) ) ) ; return this ; }
public static String encode Query ( String url ) { Uri uri = Uri . parse ( url ) ; try { String query = uri . get Query ( ) ; String encoded Query = query != null ? URL Encoder . encode ( query , STRING ) : null ; URI tmp = new URI ( uri . get Scheme ( ) , uri . get Authority ( ) , uri . get Path ( ) , null , uri . get Fragment ( ) ) ; return tmp + ( encoded Query != null && encoded Query . length ( ) > NUM ? STRING + encoded Query : STRING ) ; } catch ( Unsupported Encoding Exception ignore ) { } catch ( URI Syntax Exception ignore ) { } return uri . to String ( ) ; }
public void constrain ( int min Left , int min Top , int max Left , int max Top ) { left = Math . max ( min Left , Math . min ( left , max Left ) ) ; top = Math . max ( min Top , Math . min ( top , max Top ) ) ; }
private void add Path ( final String path ) { if ( ! my Paths . contains ( path ) ) { my Paths . add ( path ) ; } }
private static void unregister Mbeans From Props File ( M Bean Server m Bean Server ) throws Exception { Jamon Properties Loader loader = new Jamon Properties Loader ( ) ; List < String > jamon Jmx Bean Properties = loader . get Mx Beans ( ) ; Iterator < String > iter = jamon Jmx Bean Properties . iterator ( ) ; while ( iter . has Next ( ) ) { String bean Info = iter . next ( ) ; Monitor MX Bean m Xbean = Monitor MX Bean Factory . create ( bean Info ) ; m Bean Server . unregister M Bean ( Monitor MX Bean Factory . get Object Name ( m Xbean ) ) ; Monitor MX Bean m Xbean Delta = Monitor MX Bean Factory . create Delta ( bean Info ) ; m Bean Server . unregister M Bean ( Monitor MX Bean Factory . get Delta Object Name ( m Xbean Delta ) ) ; } }
private static void unregister Mbeans From Props File ( M Bean Server m Bean Server ) throws Exception { Jamon Properties Loader loader = new Jamon Properties Loader ( ) ; List < String > jamon Jmx Bean Properties = loader . get Mx Beans ( ) ; Iterator < String > iter = jamon Jmx Bean Properties . iterator ( ) ; while ( iter . has Next ( ) ) { String bean Info = iter . next ( ) ; Monitor MX Bean m Xbean = Monitor MX Bean Factory . create ( bean Info ) ; m Bean Server . unregister M Bean ( Monitor MX Bean Factory . get Object Name ( m Xbean ) ) ; Monitor MX Bean m Xbean Delta = Monitor MX Bean Factory . create Delta ( bean Info ) ; m Bean Server . unregister M Bean ( Monitor MX Bean Factory . get Delta Object Name ( m Xbean Delta ) ) ; } }
private static void unregister Mbeans From Props File ( M Bean Server m Bean Server ) throws Exception { Jamon Properties Loader loader = new Jamon Properties Loader ( ) ; List < String > jamon Jmx Bean Properties = loader . get Mx Beans ( ) ; Iterator < String > iter = jamon Jmx Bean Properties . iterator ( ) ; while ( iter . has Next ( ) ) { String bean Info = iter . next ( ) ; Monitor MX Bean m Xbean = Monitor MX Bean Factory . create ( bean Info ) ; m Bean Server . unregister M Bean ( Monitor MX Bean Factory . get Object Name ( m Xbean ) ) ; Monitor MX Bean m Xbean Delta = Monitor MX Bean Factory . create Delta ( bean Info ) ; m Bean Server . unregister M Bean ( Monitor MX Bean Factory . get Delta Object Name ( m Xbean Delta ) ) ; } }
private static void unregister Mbeans From Props File ( M Bean Server m Bean Server ) throws Exception { Jamon Properties Loader loader = new Jamon Properties Loader ( ) ; List < String > jamon Jmx Bean Properties = loader . get Mx Beans ( ) ; Iterator < String > iter = jamon Jmx Bean Properties . iterator ( ) ; while ( iter . has Next ( ) ) { String bean Info = iter . next ( ) ; Monitor MX Bean m Xbean = Monitor MX Bean Factory . create ( bean Info ) ; m Bean Server . unregister M Bean ( Monitor MX Bean Factory . get Object Name ( m Xbean ) ) ; Monitor MX Bean m Xbean Delta = Monitor MX Bean Factory . create Delta ( bean Info ) ; m Bean Server . unregister M Bean ( Monitor MX Bean Factory . get Delta Object Name ( m Xbean Delta ) ) ; } }
private static void unregister Mbeans From Props File ( M Bean Server m Bean Server ) throws Exception { Jamon Properties Loader loader = new Jamon Properties Loader ( ) ; List < String > jamon Jmx Bean Properties = loader . get Mx Beans ( ) ; Iterator < String > iter = jamon Jmx Bean Properties . iterator ( ) ; while ( iter . has Next ( ) ) { String bean Info = iter . next ( ) ; Monitor MX Bean m Xbean = Monitor MX Bean Factory . create ( bean Info ) ; m Bean Server . unregister M Bean ( Monitor MX Bean Factory . get Object Name ( m Xbean ) ) ; Monitor MX Bean m Xbean Delta = Monitor MX Bean Factory . create Delta ( bean Info ) ; m Bean Server . unregister M Bean ( Monitor MX Bean Factory . get Delta Object Name ( m Xbean Delta ) ) ; } }
private static void unregister Mbeans From Props File ( M Bean Server m Bean Server ) throws Exception { Jamon Properties Loader loader = new Jamon Properties Loader ( ) ; List < String > jamon Jmx Bean Properties = loader . get Mx Beans ( ) ; Iterator < String > iter = jamon Jmx Bean Properties . iterator ( ) ; while ( iter . has Next ( ) ) { String bean Info = iter . next ( ) ; Monitor MX Bean m Xbean = Monitor MX Bean Factory . create ( bean Info ) ; m Bean Server . unregister M Bean ( Monitor MX Bean Factory . get Object Name ( m Xbean ) ) ; Monitor MX Bean m Xbean Delta = Monitor MX Bean Factory . create Delta ( bean Info ) ; m Bean Server . unregister M Bean ( Monitor MX Bean Factory . get Delta Object Name ( m Xbean Delta ) ) ; } }
public FPS Surface View remove Child At ( int location ) { Display Base removed = m Display List . remove ( location ) ; if ( removed != null ) { removed . disable ( ) ; } return this ; }
protected void run ( long elapsed Time ) { Visualization vis = get Visualization ( ) ; if ( vis != null ) { synchronized ( vis ) { run ( get Pace ( elapsed Time ) ) ; } } else { s logger . info ( STRING ) ; run ( get Pace ( elapsed Time ) ) ; } }
public void open ( ) throws IO Exception { writer = new Print Writer ( new Buffered Writer ( new File Writer ( filename ) ) ) ; writer . println ( column Names ) ; }
public void open ( ) throws IO Exception { writer = new Print Writer ( new Buffered Writer ( new File Writer ( filename ) ) ) ; writer . println ( column Names ) ; }
protected void draw Zero Domain Baseline ( Graphics 2 D g2 , Rectangle 2 D area ) { if ( is Domain Zero Baseline Visible ( ) ) { XY Item Renderer r = get Renderer ( ) ; if ( r instanceof Abstract XY Item Renderer ) { Abstract XY Item Renderer renderer = ( Abstract XY Item Renderer ) r ; renderer . draw Domain Line ( g2 , this , get Domain Axis ( ) , area , NUM , this . domain Zero Baseline Paint , this . domain Zero Baseline Stroke ) ; } } }
protected void draw Zero Domain Baseline ( Graphics 2 D g2 , Rectangle 2 D area ) { if ( is Domain Zero Baseline Visible ( ) ) { XY Item Renderer r = get Renderer ( ) ; if ( r instanceof Abstract XY Item Renderer ) { Abstract XY Item Renderer renderer = ( Abstract XY Item Renderer ) r ; renderer . draw Domain Line ( g2 , this , get Domain Axis ( ) , area , NUM , this . domain Zero Baseline Paint , this . domain Zero Baseline Stroke ) ; } } }
protected void draw Zero Domain Baseline ( Graphics 2 D g2 , Rectangle 2 D area ) { if ( is Domain Zero Baseline Visible ( ) ) { XY Item Renderer r = get Renderer ( ) ; if ( r instanceof Abstract XY Item Renderer ) { Abstract XY Item Renderer renderer = ( Abstract XY Item Renderer ) r ; renderer . draw Domain Line ( g2 , this , get Domain Axis ( ) , area , NUM , this . domain Zero Baseline Paint , this . domain Zero Baseline Stroke ) ; } } }
public static double prob Of ( int k , double lambda ) { return Math . exp ( ( k * Math . log ( lambda ) ) - lambda - Functions . log Factorial ( k ) ) ; }
public static Java RDD < List < Writable > > normalize ( Schema schema , Java RDD < List < Writable > > data ) { return normalize ( schema , data , NUM , NUM , Collections . < String > empty List ( ) ) ; }
@ Deprecated public static JSON Object parse Json ( String response ) throws JSON Exception , Facebook Error { if ( response . equals ( STRING ) ) { throw new Facebook Error ( STRING ) ; } if ( response . equals ( STRING ) ) { response = STRING ; } JSON Object json = new JSON Object ( response ) ; if ( json . has ( STRING ) ) { JSON Object error = json . get JSON Object ( STRING ) ; throw new Facebook Error ( error . get String ( STRING ) , error . get String ( STRING ) , NUM ) ; } if ( json . has ( STRING ) && json . has ( STRING ) ) { throw new Facebook Error ( json . get String ( STRING ) , STRING , Integer . parse Int ( json . get String ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new Facebook Error ( STRING , STRING , Integer . parse Int ( json . get String ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new Facebook Error ( json . get String ( STRING ) ) ; } if ( json . has ( STRING ) ) { throw new Facebook Error ( json . get String ( STRING ) ) ; } return json ; }
@ Deprecated public static JSON Object parse Json ( String response ) throws JSON Exception , Facebook Error { if ( response . equals ( STRING ) ) { throw new Facebook Error ( STRING ) ; } if ( response . equals ( STRING ) ) { response = STRING ; } JSON Object json = new JSON Object ( response ) ; if ( json . has ( STRING ) ) { JSON Object error = json . get JSON Object ( STRING ) ; throw new Facebook Error ( error . get String ( STRING ) , error . get String ( STRING ) , NUM ) ; } if ( json . has ( STRING ) && json . has ( STRING ) ) { throw new Facebook Error ( json . get String ( STRING ) , STRING , Integer . parse Int ( json . get String ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new Facebook Error ( STRING , STRING , Integer . parse Int ( json . get String ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new Facebook Error ( json . get String ( STRING ) ) ; } if ( json . has ( STRING ) ) { throw new Facebook Error ( json . get String ( STRING ) ) ; } return json ; }
@ Deprecated public static JSON Object parse Json ( String response ) throws JSON Exception , Facebook Error { if ( response . equals ( STRING ) ) { throw new Facebook Error ( STRING ) ; } if ( response . equals ( STRING ) ) { response = STRING ; } JSON Object json = new JSON Object ( response ) ; if ( json . has ( STRING ) ) { JSON Object error = json . get JSON Object ( STRING ) ; throw new Facebook Error ( error . get String ( STRING ) , error . get String ( STRING ) , NUM ) ; } if ( json . has ( STRING ) && json . has ( STRING ) ) { throw new Facebook Error ( json . get String ( STRING ) , STRING , Integer . parse Int ( json . get String ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new Facebook Error ( STRING , STRING , Integer . parse Int ( json . get String ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new Facebook Error ( json . get String ( STRING ) ) ; } if ( json . has ( STRING ) ) { throw new Facebook Error ( json . get String ( STRING ) ) ; } return json ; }
@ Deprecated public static JSON Object parse Json ( String response ) throws JSON Exception , Facebook Error { if ( response . equals ( STRING ) ) { throw new Facebook Error ( STRING ) ; } if ( response . equals ( STRING ) ) { response = STRING ; } JSON Object json = new JSON Object ( response ) ; if ( json . has ( STRING ) ) { JSON Object error = json . get JSON Object ( STRING ) ; throw new Facebook Error ( error . get String ( STRING ) , error . get String ( STRING ) , NUM ) ; } if ( json . has ( STRING ) && json . has ( STRING ) ) { throw new Facebook Error ( json . get String ( STRING ) , STRING , Integer . parse Int ( json . get String ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new Facebook Error ( STRING , STRING , Integer . parse Int ( json . get String ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new Facebook Error ( json . get String ( STRING ) ) ; } if ( json . has ( STRING ) ) { throw new Facebook Error ( json . get String ( STRING ) ) ; } return json ; }
@ Deprecated public static JSON Object parse Json ( String response ) throws JSON Exception , Facebook Error { if ( response . equals ( STRING ) ) { throw new Facebook Error ( STRING ) ; } if ( response . equals ( STRING ) ) { response = STRING ; } JSON Object json = new JSON Object ( response ) ; if ( json . has ( STRING ) ) { JSON Object error = json . get JSON Object ( STRING ) ; throw new Facebook Error ( error . get String ( STRING ) , error . get String ( STRING ) , NUM ) ; } if ( json . has ( STRING ) && json . has ( STRING ) ) { throw new Facebook Error ( json . get String ( STRING ) , STRING , Integer . parse Int ( json . get String ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new Facebook Error ( STRING , STRING , Integer . parse Int ( json . get String ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new Facebook Error ( json . get String ( STRING ) ) ; } if ( json . has ( STRING ) ) { throw new Facebook Error ( json . get String ( STRING ) ) ; } return json ; }
public List < T > to List ( ) { @ Suppress Warnings ( STRING ) T [ ] copied Elements = ( T [ ] ) new Object [ num Elements ] ; System . arraycopy ( elements , NUM , copied Elements , NUM , num Elements ) ; return Arrays . as List ( copied Elements ) ; }
public List < T > to List ( ) { @ Suppress Warnings ( STRING ) T [ ] copied Elements = ( T [ ] ) new Object [ num Elements ] ; System . arraycopy ( elements , NUM , copied Elements , NUM , num Elements ) ; return Arrays . as List ( copied Elements ) ; }
protected void on Show Conversations ( @ Non Null List < C > conversations ) { if ( DEBUG ) { Log . d ( TAG , STRING + conversations . size ( ) + STRING ) ; } m View . show Conversations ( new Array List < > ( conversations ) ) ; }
protected void on Show Conversations ( @ Non Null List < C > conversations ) { if ( DEBUG ) { Log . d ( TAG , STRING + conversations . size ( ) + STRING ) ; } m View . show Conversations ( new Array List < > ( conversations ) ) ; }
protected void on Show Conversations ( @ Non Null List < C > conversations ) { if ( DEBUG ) { Log . d ( TAG , STRING + conversations . size ( ) + STRING ) ; } m View . show Conversations ( new Array List < > ( conversations ) ) ; }
private void validate Collection Attribute ( Collection Attribute collection , Set < String > all Collections ) { if ( collection == null || all Collections == null ) { return ; } for ( Rest Method rest Method : collection . get Methods ( ) ) { if ( all Collections . contains ( rest Method . get Rest Full Method Name ( ) ) ) { aspect . warning ( Simple Location . TOPLEVEL , STRING + STRING + STRING + STRING , collection . get Full Name ( ) , rest Method . get Rest Method Name ( ) ) ; } } }
private void validate Collection Attribute ( Collection Attribute collection , Set < String > all Collections ) { if ( collection == null || all Collections == null ) { return ; } for ( Rest Method rest Method : collection . get Methods ( ) ) { if ( all Collections . contains ( rest Method . get Rest Full Method Name ( ) ) ) { aspect . warning ( Simple Location . TOPLEVEL , STRING + STRING + STRING + STRING , collection . get Full Name ( ) , rest Method . get Rest Method Name ( ) ) ; } } }
private void validate Collection Attribute ( Collection Attribute collection , Set < String > all Collections ) { if ( collection == null || all Collections == null ) { return ; } for ( Rest Method rest Method : collection . get Methods ( ) ) { if ( all Collections . contains ( rest Method . get Rest Full Method Name ( ) ) ) { aspect . warning ( Simple Location . TOPLEVEL , STRING + STRING + STRING + STRING , collection . get Full Name ( ) , rest Method . get Rest Method Name ( ) ) ; } } }
public void execute ( String sql ) throws Database Exception { Statement stmt = null ; try { stmt = connection . create Statement ( ) ; stmt . execute ( sql ) ; } catch ( SQL Exception e ) { throw ( new Database Exception ( e ) ) ; } finally { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQL Exception e ) { } } } }
public void execute ( String sql ) throws Database Exception { Statement stmt = null ; try { stmt = connection . create Statement ( ) ; stmt . execute ( sql ) ; } catch ( SQL Exception e ) { throw ( new Database Exception ( e ) ) ; } finally { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQL Exception e ) { } } } }
public void execute ( String sql ) throws Database Exception { Statement stmt = null ; try { stmt = connection . create Statement ( ) ; stmt . execute ( sql ) ; } catch ( SQL Exception e ) { throw ( new Database Exception ( e ) ) ; } finally { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQL Exception e ) { } } } }
public void execute ( String sql ) throws Database Exception { Statement stmt = null ; try { stmt = connection . create Statement ( ) ; stmt . execute ( sql ) ; } catch ( SQL Exception e ) { throw ( new Database Exception ( e ) ) ; } finally { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQL Exception e ) { } } } }
private boolean is Contained ( Tree Node parent , String [ ] values , int lvl ) { if ( lvl == values . length ) { return BOOL ; } else if ( lvl > values . length ) { return BOOL ; } else { Vector < Tree Node > kids = parent . children ; int index = search ( kids , values [ lvl ] ) ; if ( index != - NUM ) { Tree Node new Parent = kids . element At ( index ) ; return is Contained ( new Parent , values , lvl + NUM ) ; } else { return BOOL ; } } }
private boolean is Contained ( Tree Node parent , String [ ] values , int lvl ) { if ( lvl == values . length ) { return BOOL ; } else if ( lvl > values . length ) { return BOOL ; } else { Vector < Tree Node > kids = parent . children ; int index = search ( kids , values [ lvl ] ) ; if ( index != - NUM ) { Tree Node new Parent = kids . element At ( index ) ; return is Contained ( new Parent , values , lvl + NUM ) ; } else { return BOOL ; } } }
public static void write ( OM Line line , Link link , Link Properties props ) throws IO Exception { switch ( line . get Render Type ( ) ) { case OM Line . RENDERTYPE LATLON : double [ ] ll = line . get LL ( ) ; Link Line . write ( ( float ) ll [ NUM ] , ( float ) ll [ NUM ] , ( float ) ll [ NUM ] , ( float ) ll [ NUM ] , line . get Line Type ( ) , line . get Num Segs ( ) , props , link . dos ) ; break ; case OM Line . RENDERTYPE XY : int [ ] pts = line . get Pts ( ) ; Link Line . write ( pts [ NUM ] , pts [ NUM ] , pts [ NUM ] , pts [ NUM ] , props , link . dos ) ; break ; case OM Line . RENDERTYPE OFFSET : ll = line . get LL ( ) ; pts = line . get Pts ( ) ; Link Line . write ( ( float ) ll [ NUM ] , ( float ) ll [ NUM ] , pts [ NUM ] , pts [ NUM ] , pts [ NUM ] , pts [ NUM ] , props , link . dos ) ; break ; default : Debug . error ( STRING ) ; } }
public static Date parse ( String src , String ptrn ) throws java . text . Parse Exception { java . text . Date Format format = new java . text . Simple Date Format ( ptrn ) ; return format . parse ( src ) ; }
static float log Func ( float x ) { return NUM - ( float ) ( Math . pow ( Log Base , reverse ( x ) ) ) / ( Log Base ) ; }
static float log Func ( float x ) { return NUM - ( float ) ( Math . pow ( Log Base , reverse ( x ) ) ) / ( Log Base ) ; }
public Tagged Input Stream ( Input Stream proxy ) { super ( proxy ) ; }
public void put ( Repl DBMS Event event ) throws Interrupted Exception , Replicator Exception { queue . put ( event ) ; transaction Count ++ ; if ( logger . is Debug Enabled ( ) ) { if ( transaction Count % NUM == NUM ) logger . debug ( STRING + transaction Count + STRING + queue . size ( ) ) ; } }
public boolean equals ( Object o ) { if ( o instanceof DSAME Role ) { DSAME Role role = ( DSAME Role ) o ; return ( subject Roles . equals ( role . subject Roles ) ) ; } return ( BOOL ) ; }
protected < T extends AST Node > T move Node ( T old Node , AST Rewrite rewrite ) { T moved Node ; if ( AST Nodes . is Existing Node ( old Node ) ) moved Node = AST Nodes . create Move Target ( rewrite , old Node ) ; else moved Node = AST Nodes . copy Subtree ( rewrite . get AST ( ) , old Node ) ; return moved Node ; }
protected < T extends AST Node > T move Node ( T old Node , AST Rewrite rewrite ) { T moved Node ; if ( AST Nodes . is Existing Node ( old Node ) ) moved Node = AST Nodes . create Move Target ( rewrite , old Node ) ; else moved Node = AST Nodes . copy Subtree ( rewrite . get AST ( ) , old Node ) ; return moved Node ; }
protected < T extends AST Node > T move Node ( T old Node , AST Rewrite rewrite ) { T moved Node ; if ( AST Nodes . is Existing Node ( old Node ) ) moved Node = AST Nodes . create Move Target ( rewrite , old Node ) ; else moved Node = AST Nodes . copy Subtree ( rewrite . get AST ( ) , old Node ) ; return moved Node ; }
protected < T extends AST Node > T move Node ( T old Node , AST Rewrite rewrite ) { T moved Node ; if ( AST Nodes . is Existing Node ( old Node ) ) moved Node = AST Nodes . create Move Target ( rewrite , old Node ) ; else moved Node = AST Nodes . copy Subtree ( rewrite . get AST ( ) , old Node ) ; return moved Node ; }
protected < T extends AST Node > T move Node ( T old Node , AST Rewrite rewrite ) { T moved Node ; if ( AST Nodes . is Existing Node ( old Node ) ) moved Node = AST Nodes . create Move Target ( rewrite , old Node ) ; else moved Node = AST Nodes . copy Subtree ( rewrite . get AST ( ) , old Node ) ; return moved Node ; }
protected < T extends AST Node > T move Node ( T old Node , AST Rewrite rewrite ) { T moved Node ; if ( AST Nodes . is Existing Node ( old Node ) ) moved Node = AST Nodes . create Move Target ( rewrite , old Node ) ; else moved Node = AST Nodes . copy Subtree ( rewrite . get AST ( ) , old Node ) ; return moved Node ; }
protected < T extends AST Node > T move Node ( T old Node , AST Rewrite rewrite ) { T moved Node ; if ( AST Nodes . is Existing Node ( old Node ) ) moved Node = AST Nodes . create Move Target ( rewrite , old Node ) ; else moved Node = AST Nodes . copy Subtree ( rewrite . get AST ( ) , old Node ) ; return moved Node ; }
protected < T extends AST Node > T move Node ( T old Node , AST Rewrite rewrite ) { T moved Node ; if ( AST Nodes . is Existing Node ( old Node ) ) moved Node = AST Nodes . create Move Target ( rewrite , old Node ) ; else moved Node = AST Nodes . copy Subtree ( rewrite . get AST ( ) , old Node ) ; return moved Node ; }
protected < T extends AST Node > T move Node ( T old Node , AST Rewrite rewrite ) { T moved Node ; if ( AST Nodes . is Existing Node ( old Node ) ) moved Node = AST Nodes . create Move Target ( rewrite , old Node ) ; else moved Node = AST Nodes . copy Subtree ( rewrite . get AST ( ) , old Node ) ; return moved Node ; }
private void create Composition Area ( ) { synchronized ( composition Area Lock ) { composition Area = new Composition Area ( ) ; if ( composition Area Owner != null ) { composition Area . set Handler Info ( composition Area Owner , input Method Context ) ; } Component client = client Component . get ( ) ; if ( client != null ) { Input Method Requests req = client . get Input Method Requests ( ) ; if ( req != null && input Method Context . use Below The Spot Input ( ) ) { set Composition Area Undecorated ( BOOL ) ; } } } }
public static Request Log copy ( ) { Request Log current = RLOG . get ( ) ; return new Request Log ( current ) ; }