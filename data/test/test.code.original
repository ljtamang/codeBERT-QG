public static LinuxDesktop detectDesktopSession ( ) { ArrayList < String > command = new ArrayList < String > ( ) ; command . add ( STRING ) ; command . add ( STRING ) ; command . add ( STRING ) ; Map < String , Object > desktops = new HashMap < String , Object > ( ) ; desktops . put ( STRING , LinuxDesktop . desktopKde ) ; desktops . put ( STRING , LinuxDesktop . desktopGnome ) ; desktops . put ( STRING , LinuxDesktop . desktopCinnamon ) ; desktops . put ( STRING , LinuxDesktop . desktopXfce ) ; Object desktop = Utils . isExpectedCommandOutput ( command , desktops ) ; if ( desktop != null ) { return ( LinuxDesktop ) desktop ; } return LinuxDesktop . desktopUnknown ; }
public static LinuxDesktop detectDesktopSession ( ) { ArrayList < String > command = new ArrayList < String > ( ) ; command . add ( STRING ) ; command . add ( STRING ) ; command . add ( STRING ) ; Map < String , Object > desktops = new HashMap < String , Object > ( ) ; desktops . put ( STRING , LinuxDesktop . desktopKde ) ; desktops . put ( STRING , LinuxDesktop . desktopGnome ) ; desktops . put ( STRING , LinuxDesktop . desktopCinnamon ) ; desktops . put ( STRING , LinuxDesktop . desktopXfce ) ; Object desktop = Utils . isExpectedCommandOutput ( command , desktops ) ; if ( desktop != null ) { return ( LinuxDesktop ) desktop ; } return LinuxDesktop . desktopUnknown ; }
public void removed ( java . awt . Container cont ) { }
public void removed ( java . awt . Container cont ) { }
public void removed ( java . awt . Container cont ) { }
public Builder deleteUserType ( ) { deleteFields . add ( STRING ) ; return this ; }
public static boolean registerTransform ( final String transformURI ) { final boolean added = transforms . add ( transformURI ) ; return added ; }
void incrementSchema ( String schemaName ) { if ( schemaName != null ) { Integer count = dbMap . get ( schemaName ) ; if ( count == null ) dbMap . put ( schemaName , _NUM ) ; else dbMap . put ( schemaName , count . intValue ( ) + _NUM ) ; } lastDb = schemaName ; }
static void createPolicyTree ( String configName , String configId , ServiceConfigManager scm , String org ) throws NoPermissionException , PolicyException , SSOException { try { ServiceConfig pConfig = scm . getOrganizationConfig ( org , null ) ; if ( pConfig == null ) { scm . createOrganizationConfig ( org , null ) ; pConfig = scm . getOrganizationConfig ( org , null ) ; } pConfig . addSubConfig ( configName , configId , _NUM , null ) ; } catch ( ServiceAlreadyExistsException se ) { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + configName + STRING + configId + STRING + org ) ; } } catch ( SMSException e ) { String [ ] objs = { org } ; if ( e . getExceptionCode ( ) == SMSException . STATUS_NO_PERMISSION ) { throw ( new NoPermissionException ( ResBundleUtils . rbName , STRING , null ) ) ; } else { throw ( new PolicyException ( ResBundleUtils . rbName , STRING , objs , e ) ) ; } } }
NativeObject ( long address ) { this . allocationAddress = address ; this . address = address ; }
NativeObject ( long address ) { this . allocationAddress = address ; this . address = address ; }
NativeObject ( long address ) { this . allocationAddress = address ; this . address = address ; }
void updateVisibilityModel ( ) { Component c = getContainer ( ) ; if ( c instanceof JTextField ) { JTextField field = ( JTextField ) c ; BoundedRangeModel vis = field . getHorizontalVisibility ( ) ; int hspan = ( int ) getPreferredSpan ( X_AXIS ) ; int extent = vis . getExtent ( ) ; int maximum = Math . max ( hspan , extent ) ; extent = ( extent == _NUM ) ? maximum : extent ; int value = maximum - extent ; int oldValue = vis . getValue ( ) ; if ( ( oldValue + extent ) > maximum ) { oldValue = maximum - extent ; } value = Math . max ( _NUM , Math . min ( value , oldValue ) ) ; vis . setRangeProperties ( value , extent , _NUM , maximum , _BOOL ) ; } }
void updateVisibilityModel ( ) { Component c = getContainer ( ) ; if ( c instanceof JTextField ) { JTextField field = ( JTextField ) c ; BoundedRangeModel vis = field . getHorizontalVisibility ( ) ; int hspan = ( int ) getPreferredSpan ( X_AXIS ) ; int extent = vis . getExtent ( ) ; int maximum = Math . max ( hspan , extent ) ; extent = ( extent == _NUM ) ? maximum : extent ; int value = maximum - extent ; int oldValue = vis . getValue ( ) ; if ( ( oldValue + extent ) > maximum ) { oldValue = maximum - extent ; } value = Math . max ( _NUM , Math . min ( value , oldValue ) ) ; vis . setRangeProperties ( value , extent , _NUM , maximum , _BOOL ) ; } }
void updateVisibilityModel ( ) { Component c = getContainer ( ) ; if ( c instanceof JTextField ) { JTextField field = ( JTextField ) c ; BoundedRangeModel vis = field . getHorizontalVisibility ( ) ; int hspan = ( int ) getPreferredSpan ( X_AXIS ) ; int extent = vis . getExtent ( ) ; int maximum = Math . max ( hspan , extent ) ; extent = ( extent == _NUM ) ? maximum : extent ; int value = maximum - extent ; int oldValue = vis . getValue ( ) ; if ( ( oldValue + extent ) > maximum ) { oldValue = maximum - extent ; } value = Math . max ( _NUM , Math . min ( value , oldValue ) ) ; vis . setRangeProperties ( value , extent , _NUM , maximum , _BOOL ) ; } }
void updateVisibilityModel ( ) { Component c = getContainer ( ) ; if ( c instanceof JTextField ) { JTextField field = ( JTextField ) c ; BoundedRangeModel vis = field . getHorizontalVisibility ( ) ; int hspan = ( int ) getPreferredSpan ( X_AXIS ) ; int extent = vis . getExtent ( ) ; int maximum = Math . max ( hspan , extent ) ; extent = ( extent == _NUM ) ? maximum : extent ; int value = maximum - extent ; int oldValue = vis . getValue ( ) ; if ( ( oldValue + extent ) > maximum ) { oldValue = maximum - extent ; } value = Math . max ( _NUM , Math . min ( value , oldValue ) ) ; vis . setRangeProperties ( value , extent , _NUM , maximum , _BOOL ) ; } }
void updateVisibilityModel ( ) { Component c = getContainer ( ) ; if ( c instanceof JTextField ) { JTextField field = ( JTextField ) c ; BoundedRangeModel vis = field . getHorizontalVisibility ( ) ; int hspan = ( int ) getPreferredSpan ( X_AXIS ) ; int extent = vis . getExtent ( ) ; int maximum = Math . max ( hspan , extent ) ; extent = ( extent == _NUM ) ? maximum : extent ; int value = maximum - extent ; int oldValue = vis . getValue ( ) ; if ( ( oldValue + extent ) > maximum ) { oldValue = maximum - extent ; } value = Math . max ( _NUM , Math . min ( value , oldValue ) ) ; vis . setRangeProperties ( value , extent , _NUM , maximum , _BOOL ) ; } }
void updateVisibilityModel ( ) { Component c = getContainer ( ) ; if ( c instanceof JTextField ) { JTextField field = ( JTextField ) c ; BoundedRangeModel vis = field . getHorizontalVisibility ( ) ; int hspan = ( int ) getPreferredSpan ( X_AXIS ) ; int extent = vis . getExtent ( ) ; int maximum = Math . max ( hspan , extent ) ; extent = ( extent == _NUM ) ? maximum : extent ; int value = maximum - extent ; int oldValue = vis . getValue ( ) ; if ( ( oldValue + extent ) > maximum ) { oldValue = maximum - extent ; } value = Math . max ( _NUM , Math . min ( value , oldValue ) ) ; vis . setRangeProperties ( value , extent , _NUM , maximum , _BOOL ) ; } }
void updateVisibilityModel ( ) { Component c = getContainer ( ) ; if ( c instanceof JTextField ) { JTextField field = ( JTextField ) c ; BoundedRangeModel vis = field . getHorizontalVisibility ( ) ; int hspan = ( int ) getPreferredSpan ( X_AXIS ) ; int extent = vis . getExtent ( ) ; int maximum = Math . max ( hspan , extent ) ; extent = ( extent == _NUM ) ? maximum : extent ; int value = maximum - extent ; int oldValue = vis . getValue ( ) ; if ( ( oldValue + extent ) > maximum ) { oldValue = maximum - extent ; } value = Math . max ( _NUM , Math . min ( value , oldValue ) ) ; vis . setRangeProperties ( value , extent , _NUM , maximum , _BOOL ) ; } }
public static String createDescription ( final String description , final String [ ] causes , final String [ ] impacts ) { final StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( description ) ; stringBuilder . append ( STRING ) ; if ( causes . length != _NUM ) { stringBuilder . append ( STRING ) ; stringBuilder . append ( STRING + STRING ) ; for ( final String cause : causes ) { stringBuilder . append ( STRING ) ; stringBuilder . append ( cause ) ; stringBuilder . append ( STRING ) ; } } if ( impacts . length != _NUM ) { stringBuilder . append ( STRING ) ; stringBuilder . append ( STRING + STRING ) ; for ( final String impact : impacts ) { stringBuilder . append ( STRING ) ; stringBuilder . append ( impact ) ; stringBuilder . append ( STRING ) ; } } return stringBuilder . toString ( ) ; }
public static String createDescription ( final String description , final String [ ] causes , final String [ ] impacts ) { final StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( description ) ; stringBuilder . append ( STRING ) ; if ( causes . length != _NUM ) { stringBuilder . append ( STRING ) ; stringBuilder . append ( STRING + STRING ) ; for ( final String cause : causes ) { stringBuilder . append ( STRING ) ; stringBuilder . append ( cause ) ; stringBuilder . append ( STRING ) ; } } if ( impacts . length != _NUM ) { stringBuilder . append ( STRING ) ; stringBuilder . append ( STRING + STRING ) ; for ( final String impact : impacts ) { stringBuilder . append ( STRING ) ; stringBuilder . append ( impact ) ; stringBuilder . append ( STRING ) ; } } return stringBuilder . toString ( ) ; }
protected URIPropertyMatcher ( String propertyName , Mode mode , URI expectedPattern , Function < Issue , URI > getActualValue ) { super ( propertyName ) ; this . mode = mode ; this . expectedPattern = Objects . requireNonNull ( expectedPattern ) ; this . getActualValue = Objects . requireNonNull ( getActualValue ) ; }
public final void addHelperTextColor ( @ ColorInt final int color ) { if ( ! helperTextColors . contains ( color ) ) { helperTextColors . add ( color ) ; verifyPasswordStrength ( ) ; } }
public final void addHelperTextColor ( @ ColorInt final int color ) { if ( ! helperTextColors . contains ( color ) ) { helperTextColors . add ( color ) ; verifyPasswordStrength ( ) ; } }
public final void addHelperTextColor ( @ ColorInt final int color ) { if ( ! helperTextColors . contains ( color ) ) { helperTextColors . add ( color ) ; verifyPasswordStrength ( ) ; } }
public final void addHelperTextColor ( @ ColorInt final int color ) { if ( ! helperTextColors . contains ( color ) ) { helperTextColors . add ( color ) ; verifyPasswordStrength ( ) ; } }
public final void addHelperTextColor ( @ ColorInt final int color ) { if ( ! helperTextColors . contains ( color ) ) { helperTextColors . add ( color ) ; verifyPasswordStrength ( ) ; } }
public static int hash ( byte [ ] data , int offset , int length , int seed ) { return hash ( ByteBuffer . wrap ( data , offset , length ) , seed ) ; }
public static int hash ( byte [ ] data , int offset , int length , int seed ) { return hash ( ByteBuffer . wrap ( data , offset , length ) , seed ) ; }
public void addTask ( JoinTask task ) { synchronized ( JoinManager . this ) { if ( bTerminated ) return ; } synchronized ( taskList ) { if ( bTerminated ) { return ; } taskList . add ( task ) ; if ( this . proxyRegTask == null ) { this . proxyRegTask = new ProxyRegTask ( this , taskSeqN ++ ) ; synchronized ( taskMgr ) { taskMgr . add ( this . proxyRegTask ) ; } } } }
public void addTask ( JoinTask task ) { synchronized ( JoinManager . this ) { if ( bTerminated ) return ; } synchronized ( taskList ) { if ( bTerminated ) { return ; } taskList . add ( task ) ; if ( this . proxyRegTask == null ) { this . proxyRegTask = new ProxyRegTask ( this , taskSeqN ++ ) ; synchronized ( taskMgr ) { taskMgr . add ( this . proxyRegTask ) ; } } } }
public String escapeLDAPSearchFilter ( String filter ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = _NUM ; i < filter . length ( ) ; i ++ ) { char curChar = filter . charAt ( i ) ; switch ( curChar ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; default : sb . append ( curChar ) ; } } return sb . toString ( ) ; }
@ POST @ Consumes ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ Produces ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ CheckPermission ( roles = { Role . TENANT_ADMIN } , acls = { ACL . OWN } ) @ Path ( STRING ) public CatalogServiceRestRep createCatalogService ( CatalogServiceCreateParam createParam ) { StorageOSUser user = getUserFromContext ( ) ; CatalogCategory parentCatalogCategory = catalogCategoryManager . getCatalogCategoryById ( createParam . getCatalogCategory ( ) ) ; verifyAuthorizedInTenantOrg ( uri ( parentCatalogCategory . getTenant ( ) ) , user ) ; validateParam ( createParam , null ) ; CatalogService catalogService = createNewObject ( createParam , parentCatalogCategory ) ; List < CatalogServiceField > catalogServiceFields = createNewObjectList ( catalogService , createParam . getCatalogServiceFields ( ) ) ; catalogServiceManager . createCatalogService ( catalogService , catalogServiceFields ) ; auditOpSuccess ( OperationTypeEnum . CREATE_CATALOG_SERVICE , catalogService . auditParameters ( ) ) ; catalogService = catalogServiceManager . getCatalogServiceById ( catalogService . getId ( ) ) ; catalogServiceFields = catalogServiceManager . getCatalogServiceFields ( catalogService . getId ( ) ) ; ServiceDescriptor serviceDescriptor = getServiceDescriptor ( catalogService ) ; return map ( catalogService , serviceDescriptor , catalogServiceFields ) ; }
@ Override public void buildStructure ( BayesNet bayesNet , Instances instances ) throws Exception { m_BayesNet = bayesNet ; super . buildStructure ( bayesNet , instances ) ; }
@ Override public void buildStructure ( BayesNet bayesNet , Instances instances ) throws Exception { m_BayesNet = bayesNet ; super . buildStructure ( bayesNet , instances ) ; }
@ Override public void buildStructure ( BayesNet bayesNet , Instances instances ) throws Exception { m_BayesNet = bayesNet ; super . buildStructure ( bayesNet , instances ) ; }
public boolean copyImage ( Image img , int dx , int dy , int sx , int sy , int width , int height , Color bgcolor , ImageObserver observer ) { try { return imagepipe . copyImage ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( InvalidPipeException e ) { try { revalidateAll ( ) ; return imagepipe . copyImage ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( InvalidPipeException e2 ) { return _BOOL ; } } finally { surfaceData . markDirty ( ) ; } }
public boolean copyImage ( Image img , int dx , int dy , int sx , int sy , int width , int height , Color bgcolor , ImageObserver observer ) { try { return imagepipe . copyImage ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( InvalidPipeException e ) { try { revalidateAll ( ) ; return imagepipe . copyImage ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( InvalidPipeException e2 ) { return _BOOL ; } } finally { surfaceData . markDirty ( ) ; } }
public boolean copyImage ( Image img , int dx , int dy , int sx , int sy , int width , int height , Color bgcolor , ImageObserver observer ) { try { return imagepipe . copyImage ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( InvalidPipeException e ) { try { revalidateAll ( ) ; return imagepipe . copyImage ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( InvalidPipeException e2 ) { return _BOOL ; } } finally { surfaceData . markDirty ( ) ; } }
public boolean copyImage ( Image img , int dx , int dy , int sx , int sy , int width , int height , Color bgcolor , ImageObserver observer ) { try { return imagepipe . copyImage ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( InvalidPipeException e ) { try { revalidateAll ( ) ; return imagepipe . copyImage ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( InvalidPipeException e2 ) { return _BOOL ; } } finally { surfaceData . markDirty ( ) ; } }
public boolean copyImage ( Image img , int dx , int dy , int sx , int sy , int width , int height , Color bgcolor , ImageObserver observer ) { try { return imagepipe . copyImage ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( InvalidPipeException e ) { try { revalidateAll ( ) ; return imagepipe . copyImage ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( InvalidPipeException e2 ) { return _BOOL ; } } finally { surfaceData . markDirty ( ) ; } }
public boolean endsWith ( String string ) { if ( string == null ) return _BOOL ; int strlen = string . length ( ) ; if ( _length < strlen ) return _BOOL ; char [ ] buffer = _buffer ; int offset = _offset + _length - strlen ; while ( -- strlen >= _NUM ) { if ( buffer [ offset + strlen ] != string . charAt ( strlen ) ) return _BOOL ; } return _BOOL ; }
public int compareTo ( ResourceUsage o ) { double required = o . limit - o . usage ; double available = limit - usage ; return Double . compare ( available , required ) ; }
public Skeleton ( PrintWriter out ) { this . out = out ; }
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; registrarID = new ServiceID ( in ) ; if ( server == null ) { throw new InvalidObjectException ( STRING ) ; } else if ( leaseID == null ) { throw new InvalidObjectException ( STRING ) ; } }
public static void write ( float lt , float ln , Image image , int image_width , int image_height , LinkProperties properties , DataOutputStream dos ) throws IOException , InterruptedException { int [ ] pixels = new int [ image_width * image_height ] ; PixelGrabber pixelgrabber = new PixelGrabber ( image , _NUM , _NUM , image_width , image_height , pixels , _NUM , image_width ) ; pixelgrabber . grabPixels ( ) ; LinkRaster . write ( lt , ln , image_width , image_height , pixels , properties , dos ) ; }
public boolean isNullStrokeFill ( boolean isRectangle ) { MetaPen pen = state . getCurrentPen ( ) ; MetaBrush brush = state . getCurrentBrush ( ) ; boolean noPen = pen . getStyle ( ) == MetaPen . PS_NULL ; int style = brush . getStyle ( ) ; boolean isBrush = style == MetaBrush . BS_SOLID || style == MetaBrush . BS_HATCHED && state . getBackgroundMode ( ) == MetaState . OPAQUE ; boolean result = noPen && ! isBrush ; if ( ! noPen ) { if ( isRectangle ) state . setLineJoinRectangle ( cb ) ; else state . setLineJoinPolygon ( cb ) ; } return result ; }
void visitMacroDef ( Macro macro ) { macroToNamespaceLookup . put ( macro , currentNamespace ) ; currentNamespace . put ( macro . getName ( ) , macro ) ; }
void visitMacroDef ( Macro macro ) { macroToNamespaceLookup . put ( macro , currentNamespace ) ; currentNamespace . put ( macro . getName ( ) , macro ) ; }
protected void awaitCompletionComputeValuesAndShutdown ( ) { { final long before = System . currentTimeMillis ( ) ; runExecutorAndAwaitCompletion ( ) ; durationFlowFunctionConstruction = System . currentTimeMillis ( ) - before ; } if ( computeValues ) { final long before = System . currentTimeMillis ( ) ; computeValues ( ) ; durationFlowFunctionApplication = System . currentTimeMillis ( ) - before ; } if ( logger . isDebugEnabled ( ) ) printStats ( ) ; executor . shutdown ( ) ; runExecutorAndAwaitCompletion ( ) ; }
protected void awaitCompletionComputeValuesAndShutdown ( ) { { final long before = System . currentTimeMillis ( ) ; runExecutorAndAwaitCompletion ( ) ; durationFlowFunctionConstruction = System . currentTimeMillis ( ) - before ; } if ( computeValues ) { final long before = System . currentTimeMillis ( ) ; computeValues ( ) ; durationFlowFunctionApplication = System . currentTimeMillis ( ) - before ; } if ( logger . isDebugEnabled ( ) ) printStats ( ) ; executor . shutdown ( ) ; runExecutorAndAwaitCompletion ( ) ; }
private int calculateMaxCharacterWidthBasedOnPixelWidth ( ) { String testWidthString = STRING ; for ( int i = _NUM ; i < _NUM ; i ++ ) { testWidthString = testWidthString + STRING ; } BufferedImage temp = new BufferedImage ( _NUM , _NUM , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D tempG2d = temp . createGraphics ( ) ; ; FontMetrics metrics = tempG2d . getFontMetrics ( this . labelFont ) ; int strWidth = metrics . stringWidth ( testWidthString ) ; while ( strWidth > this . maxPixelWidth ) { testWidthString = testWidthString . substring ( _NUM , testWidthString . length ( ) - _NUM ) ; strWidth = metrics . stringWidth ( testWidthString ) ; } return testWidthString . length ( ) ; }
private int calculateMaxCharacterWidthBasedOnPixelWidth ( ) { String testWidthString = STRING ; for ( int i = _NUM ; i < _NUM ; i ++ ) { testWidthString = testWidthString + STRING ; } BufferedImage temp = new BufferedImage ( _NUM , _NUM , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D tempG2d = temp . createGraphics ( ) ; ; FontMetrics metrics = tempG2d . getFontMetrics ( this . labelFont ) ; int strWidth = metrics . stringWidth ( testWidthString ) ; while ( strWidth > this . maxPixelWidth ) { testWidthString = testWidthString . substring ( _NUM , testWidthString . length ( ) - _NUM ) ; strWidth = metrics . stringWidth ( testWidthString ) ; } return testWidthString . length ( ) ; }
private int calculateMaxCharacterWidthBasedOnPixelWidth ( ) { String testWidthString = STRING ; for ( int i = _NUM ; i < _NUM ; i ++ ) { testWidthString = testWidthString + STRING ; } BufferedImage temp = new BufferedImage ( _NUM , _NUM , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D tempG2d = temp . createGraphics ( ) ; ; FontMetrics metrics = tempG2d . getFontMetrics ( this . labelFont ) ; int strWidth = metrics . stringWidth ( testWidthString ) ; while ( strWidth > this . maxPixelWidth ) { testWidthString = testWidthString . substring ( _NUM , testWidthString . length ( ) - _NUM ) ; strWidth = metrics . stringWidth ( testWidthString ) ; } return testWidthString . length ( ) ; }
private static int readLength ( @ NonNull SocketChannel socket , @ NonNull byte [ ] buffer ) throws IOException { String msg = read ( socket , buffer ) ; if ( msg != null ) { try { return Integer . parseInt ( msg , _NUM ) ; } catch ( NumberFormatException nfe ) { } } throw new IOException ( STRING ) ; }
public DockNode ( Node contents , String title ) { this ( contents , title , null ) ; }
private MatchingPart createEmoPermissionPart ( String part , PartType partType ) { part = unescapeSeparators ( part ) ; switch ( part . charAt ( _NUM ) ) { case STRING : if ( isTableResource ( partType ) && part . startsWith ( STRING ) && part . endsWith ( STRING ) ) { String rison = part . substring ( _NUM , part . length ( ) - _NUM ) ; return RisonHelper . fromORison ( rison , CreateTablePart . class ) ; } break ; case STRING : if ( part . startsWith ( STRING ) && part . endsWith ( STRING ) ) { String condition = part . substring ( _NUM , part . length ( ) - _NUM ) ; switch ( partType ) { case SOR_TABLE : return new SorTableConditionPart ( Conditions . fromString ( condition ) , _dataStore ) ; case BLOB_TABLE : return new BlobTableConditionPart ( Conditions . fromString ( condition ) , _blobStore ) ; default : return new ConditionPart ( Conditions . fromString ( condition ) ) ; } } break ; case STRING : if ( part . length ( ) == _NUM ) { return getAnyPart ( ) ; } break ; } Condition condition = Conditions . like ( part ) ; if ( condition instanceof EqualCondition ) { return new EmoConstantPart ( part ) ; } return new ConditionPart ( condition ) ; }
public static void addGuiExperiment ( final IExperimentPlan experiment ) { }
public ProducerWorker ( String topic , String message ) { this . _topic = topic ; this . _message = message ; }
default Optional < String > tooltip ( ) { return Optional . empty ( ) ; }
public static void addPermissionRecursive ( Path path , PosixFilePermission permission ) throws IOException { changePermissionsRecursive ( path , PermissionChange . ADD , Collections . singleton ( permission ) ) ; }
public static Document jsoup2DOM ( org . jsoup . nodes . Document jsoupDocument ) { Document document = null ; try { DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docBuilder = docBuilderFactory . newDocumentBuilder ( ) ; document = docBuilder . newDocument ( ) ; Map < String , String > nsMap = new HashMap < String , String > ( ) ; createDOM ( jsoupDocument , document , document , nsMap ) ; } catch ( ParserConfigurationException pce ) { throw new RuntimeException ( pce ) ; } return document ; }
public static Document jsoup2DOM ( org . jsoup . nodes . Document jsoupDocument ) { Document document = null ; try { DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docBuilder = docBuilderFactory . newDocumentBuilder ( ) ; document = docBuilder . newDocument ( ) ; Map < String , String > nsMap = new HashMap < String , String > ( ) ; createDOM ( jsoupDocument , document , document , nsMap ) ; } catch ( ParserConfigurationException pce ) { throw new RuntimeException ( pce ) ; } return document ; }
@ Override public boolean isArmed ( ) { boolean b = shouldActLikeButton ( ) || ( pressedWhenPopupVisible && comboBox . isPopupVisible ( ) ) ; return b ? isPressed ( ) : super . isArmed ( ) ; }
public static Date dateFromHeaderString ( String datstr ) { SimpleDateFormat fmt = new SimpleDateFormat ( HTTP_FORMAT , Locale . US ) ; ParsePosition zero = new ParsePosition ( _NUM ) ; fmt . setTimeZone ( GMT_ZONE ) ; return ( fmt . parse ( datstr , zero ) ) ; }
public static Date dateFromHeaderString ( String datstr ) { SimpleDateFormat fmt = new SimpleDateFormat ( HTTP_FORMAT , Locale . US ) ; ParsePosition zero = new ParsePosition ( _NUM ) ; fmt . setTimeZone ( GMT_ZONE ) ; return ( fmt . parse ( datstr , zero ) ) ; }
public static < T extends CharSequence > T eachMatch ( T self , Pattern pattern , @ ClosureParams ( value = FromString . class , options = { STRING , STRING } ) Closure closure ) { eachMatch ( self . toString ( ) , pattern , closure ) ; return self ; }
public static < T extends CharSequence > T eachMatch ( T self , Pattern pattern , @ ClosureParams ( value = FromString . class , options = { STRING , STRING } ) Closure closure ) { eachMatch ( self . toString ( ) , pattern , closure ) ; return self ; }
public static < T extends CharSequence > T eachMatch ( T self , Pattern pattern , @ ClosureParams ( value = FromString . class , options = { STRING , STRING } ) Closure closure ) { eachMatch ( self . toString ( ) , pattern , closure ) ; return self ; }
public static < T extends CharSequence > T eachMatch ( T self , Pattern pattern , @ ClosureParams ( value = FromString . class , options = { STRING , STRING } ) Closure closure ) { eachMatch ( self . toString ( ) , pattern , closure ) ; return self ; }
private static Point2D detectLine ( Point2D p1 , Point2D p2 , Point2D p , Line2D line , GeneralPath path ) { if ( line . ptLineDistSq ( p ) == _NUM ) { p2 . setLocation ( p ) ; } else { p1 . setLocation ( p2 ) ; p2 . setLocation ( p ) ; line . setLine ( p1 , p2 ) ; path . lineTo ( ( float ) p1 . getX ( ) , ( float ) p1 . getY ( ) ) ; } return p2 ; }
private static Point2D detectLine ( Point2D p1 , Point2D p2 , Point2D p , Line2D line , GeneralPath path ) { if ( line . ptLineDistSq ( p ) == _NUM ) { p2 . setLocation ( p ) ; } else { p1 . setLocation ( p2 ) ; p2 . setLocation ( p ) ; line . setLine ( p1 , p2 ) ; path . lineTo ( ( float ) p1 . getX ( ) , ( float ) p1 . getY ( ) ) ; } return p2 ; }
private static Point2D detectLine ( Point2D p1 , Point2D p2 , Point2D p , Line2D line , GeneralPath path ) { if ( line . ptLineDistSq ( p ) == _NUM ) { p2 . setLocation ( p ) ; } else { p1 . setLocation ( p2 ) ; p2 . setLocation ( p ) ; line . setLine ( p1 , p2 ) ; path . lineTo ( ( float ) p1 . getX ( ) , ( float ) p1 . getY ( ) ) ; } return p2 ; }
public boolean hasListeners ( ) { return listeners != null && listeners . size ( ) > _NUM ; }
public boolean hasListeners ( ) { return listeners != null && listeners . size ( ) > _NUM ; }
private void flashSelectedProperty ( ThemeModel model , String key ) { }
private void processWorkerExit ( Worker w , boolean completedAbruptly ) { if ( completedAbruptly ) decrementWorkerCount ( ) ; final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { completedTaskCount += w . completedTasks ; workers . remove ( w ) ; } finally { mainLock . unlock ( ) ; } tryTerminate2 ( ) ; if ( ! completedAbruptly ) { int min = allowCoreThreadTimeOut ? _NUM : corePoolSize ; if ( min == _NUM && ! workQueue . isEmpty ( ) ) min = _NUM ; int c = ctl . get ( ) ; if ( workerCountOf ( c ) >= min || runStateOf ( c ) >= STOP ) return ; } addWorker ( null , _BOOL ) ; }
private void processWorkerExit ( Worker w , boolean completedAbruptly ) { if ( completedAbruptly ) decrementWorkerCount ( ) ; final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { completedTaskCount += w . completedTasks ; workers . remove ( w ) ; } finally { mainLock . unlock ( ) ; } tryTerminate2 ( ) ; if ( ! completedAbruptly ) { int min = allowCoreThreadTimeOut ? _NUM : corePoolSize ; if ( min == _NUM && ! workQueue . isEmpty ( ) ) min = _NUM ; int c = ctl . get ( ) ; if ( workerCountOf ( c ) >= min || runStateOf ( c ) >= STOP ) return ; } addWorker ( null , _BOOL ) ; }
private void processWorkerExit ( Worker w , boolean completedAbruptly ) { if ( completedAbruptly ) decrementWorkerCount ( ) ; final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { completedTaskCount += w . completedTasks ; workers . remove ( w ) ; } finally { mainLock . unlock ( ) ; } tryTerminate2 ( ) ; if ( ! completedAbruptly ) { int min = allowCoreThreadTimeOut ? _NUM : corePoolSize ; if ( min == _NUM && ! workQueue . isEmpty ( ) ) min = _NUM ; int c = ctl . get ( ) ; if ( workerCountOf ( c ) >= min || runStateOf ( c ) >= STOP ) return ; } addWorker ( null , _BOOL ) ; }
private void processWorkerExit ( Worker w , boolean completedAbruptly ) { if ( completedAbruptly ) decrementWorkerCount ( ) ; final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { completedTaskCount += w . completedTasks ; workers . remove ( w ) ; } finally { mainLock . unlock ( ) ; } tryTerminate2 ( ) ; if ( ! completedAbruptly ) { int min = allowCoreThreadTimeOut ? _NUM : corePoolSize ; if ( min == _NUM && ! workQueue . isEmpty ( ) ) min = _NUM ; int c = ctl . get ( ) ; if ( workerCountOf ( c ) >= min || runStateOf ( c ) >= STOP ) return ; } addWorker ( null , _BOOL ) ; }
private void processWorkerExit ( Worker w , boolean completedAbruptly ) { if ( completedAbruptly ) decrementWorkerCount ( ) ; final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { completedTaskCount += w . completedTasks ; workers . remove ( w ) ; } finally { mainLock . unlock ( ) ; } tryTerminate2 ( ) ; if ( ! completedAbruptly ) { int min = allowCoreThreadTimeOut ? _NUM : corePoolSize ; if ( min == _NUM && ! workQueue . isEmpty ( ) ) min = _NUM ; int c = ctl . get ( ) ; if ( workerCountOf ( c ) >= min || runStateOf ( c ) >= STOP ) return ; } addWorker ( null , _BOOL ) ; }
private void processWorkerExit ( Worker w , boolean completedAbruptly ) { if ( completedAbruptly ) decrementWorkerCount ( ) ; final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { completedTaskCount += w . completedTasks ; workers . remove ( w ) ; } finally { mainLock . unlock ( ) ; } tryTerminate2 ( ) ; if ( ! completedAbruptly ) { int min = allowCoreThreadTimeOut ? _NUM : corePoolSize ; if ( min == _NUM && ! workQueue . isEmpty ( ) ) min = _NUM ; int c = ctl . get ( ) ; if ( workerCountOf ( c ) >= min || runStateOf ( c ) >= STOP ) return ; } addWorker ( null , _BOOL ) ; }
private void processWorkerExit ( Worker w , boolean completedAbruptly ) { if ( completedAbruptly ) decrementWorkerCount ( ) ; final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { completedTaskCount += w . completedTasks ; workers . remove ( w ) ; } finally { mainLock . unlock ( ) ; } tryTerminate2 ( ) ; if ( ! completedAbruptly ) { int min = allowCoreThreadTimeOut ? _NUM : corePoolSize ; if ( min == _NUM && ! workQueue . isEmpty ( ) ) min = _NUM ; int c = ctl . get ( ) ; if ( workerCountOf ( c ) >= min || runStateOf ( c ) >= STOP ) return ; } addWorker ( null , _BOOL ) ; }
private static Entry [ ] delete ( Entry [ ] attrs , int i ) { int len = attrs . length - _NUM ; Entry [ ] nattrs = new Entry [ len ] ; System . arraycopy ( attrs , _NUM , nattrs , _NUM , i ) ; System . arraycopy ( attrs , i + _NUM , nattrs , i , len - i ) ; return nattrs ; }
public Transit createNewTransit ( String userName ) { boolean found = _BOOL ; String testName = STRING ; Transit z ; while ( ! found ) { int nextAutoTransitRef = lastAutoTransitRef + _NUM ; testName = STRING + nextAutoTransitRef ; z = getBySystemName ( testName ) ; if ( z == null ) { found = _BOOL ; } lastAutoTransitRef = nextAutoTransitRef ; } return createNewTransit ( testName , userName ) ; }
public Transit createNewTransit ( String userName ) { boolean found = _BOOL ; String testName = STRING ; Transit z ; while ( ! found ) { int nextAutoTransitRef = lastAutoTransitRef + _NUM ; testName = STRING + nextAutoTransitRef ; z = getBySystemName ( testName ) ; if ( z == null ) { found = _BOOL ; } lastAutoTransitRef = nextAutoTransitRef ; } return createNewTransit ( testName , userName ) ; }
public Transit createNewTransit ( String userName ) { boolean found = _BOOL ; String testName = STRING ; Transit z ; while ( ! found ) { int nextAutoTransitRef = lastAutoTransitRef + _NUM ; testName = STRING + nextAutoTransitRef ; z = getBySystemName ( testName ) ; if ( z == null ) { found = _BOOL ; } lastAutoTransitRef = nextAutoTransitRef ; } return createNewTransit ( testName , userName ) ; }
public Transit createNewTransit ( String userName ) { boolean found = _BOOL ; String testName = STRING ; Transit z ; while ( ! found ) { int nextAutoTransitRef = lastAutoTransitRef + _NUM ; testName = STRING + nextAutoTransitRef ; z = getBySystemName ( testName ) ; if ( z == null ) { found = _BOOL ; } lastAutoTransitRef = nextAutoTransitRef ; } return createNewTransit ( testName , userName ) ; }
public Transit createNewTransit ( String userName ) { boolean found = _BOOL ; String testName = STRING ; Transit z ; while ( ! found ) { int nextAutoTransitRef = lastAutoTransitRef + _NUM ; testName = STRING + nextAutoTransitRef ; z = getBySystemName ( testName ) ; if ( z == null ) { found = _BOOL ; } lastAutoTransitRef = nextAutoTransitRef ; } return createNewTransit ( testName , userName ) ; }
public Transit createNewTransit ( String userName ) { boolean found = _BOOL ; String testName = STRING ; Transit z ; while ( ! found ) { int nextAutoTransitRef = lastAutoTransitRef + _NUM ; testName = STRING + nextAutoTransitRef ; z = getBySystemName ( testName ) ; if ( z == null ) { found = _BOOL ; } lastAutoTransitRef = nextAutoTransitRef ; } return createNewTransit ( testName , userName ) ; }
public Transit createNewTransit ( String userName ) { boolean found = _BOOL ; String testName = STRING ; Transit z ; while ( ! found ) { int nextAutoTransitRef = lastAutoTransitRef + _NUM ; testName = STRING + nextAutoTransitRef ; z = getBySystemName ( testName ) ; if ( z == null ) { found = _BOOL ; } lastAutoTransitRef = nextAutoTransitRef ; } return createNewTransit ( testName , userName ) ; }
public Transit createNewTransit ( String userName ) { boolean found = _BOOL ; String testName = STRING ; Transit z ; while ( ! found ) { int nextAutoTransitRef = lastAutoTransitRef + _NUM ; testName = STRING + nextAutoTransitRef ; z = getBySystemName ( testName ) ; if ( z == null ) { found = _BOOL ; } lastAutoTransitRef = nextAutoTransitRef ; } return createNewTransit ( testName , userName ) ; }
public Transit createNewTransit ( String userName ) { boolean found = _BOOL ; String testName = STRING ; Transit z ; while ( ! found ) { int nextAutoTransitRef = lastAutoTransitRef + _NUM ; testName = STRING + nextAutoTransitRef ; z = getBySystemName ( testName ) ; if ( z == null ) { found = _BOOL ; } lastAutoTransitRef = nextAutoTransitRef ; } return createNewTransit ( testName , userName ) ; }
public Transit createNewTransit ( String userName ) { boolean found = _BOOL ; String testName = STRING ; Transit z ; while ( ! found ) { int nextAutoTransitRef = lastAutoTransitRef + _NUM ; testName = STRING + nextAutoTransitRef ; z = getBySystemName ( testName ) ; if ( z == null ) { found = _BOOL ; } lastAutoTransitRef = nextAutoTransitRef ; } return createNewTransit ( testName , userName ) ; }
private void updateAttrs ( SvcReg reg , EntryRep entry , Object [ ] values ) { EntryClass eclass = entry . eclass ; for ( int fldidx = values . length ; -- fldidx >= _NUM ; ) { Object oval = entry . fields [ fldidx ] ; Object nval = values [ fldidx ] ; if ( nval != null && ! nval . equals ( oval ) ) { eclass = getDefiningClass ( eclass , fldidx ) ; HashMap map = addAttr ( reg , eclass , fldidx , nval ) ; entry . fields [ fldidx ] = nval ; if ( hasAttr ( reg , eclass , fldidx , oval ) ) continue ; ArrayList regs = ( ArrayList ) map . get ( oval ) ; regs . remove ( regs . indexOf ( reg ) ) ; if ( regs . isEmpty ( ) ) map . remove ( oval ) ; } } }
public List < JsonValue > values ( ) { return Collections . unmodifiableList ( values ) ; }
public List < JsonValue > values ( ) { return Collections . unmodifiableList ( values ) ; }
public List < JsonValue > values ( ) { return Collections . unmodifiableList ( values ) ; }
public List < JsonValue > values ( ) { return Collections . unmodifiableList ( values ) ; }
public static int verifyOrder ( String input , String [ ] subStrings ) { int prev = - _NUM ; for ( int i = _NUM ; i < subStrings . length ; i ++ ) { int current = input . indexOf ( subStrings [ i ] ) ; if ( current < prev ) { return i ; } else { prev = current ; } } return - _NUM ; }
public static int verifyOrder ( String input , String [ ] subStrings ) { int prev = - _NUM ; for ( int i = _NUM ; i < subStrings . length ; i ++ ) { int current = input . indexOf ( subStrings [ i ] ) ; if ( current < prev ) { return i ; } else { prev = current ; } } return - _NUM ; }
protected static int [ ] remove ( int [ ] old , int oldSize , int pos ) { int [ ] result ; if ( old . length - oldSize < COPY_THRESHOLD ) { result = old ; } else { result = new int [ oldSize - _NUM ] ; System . arraycopy ( old , _NUM , result , _NUM , Math . min ( oldSize - _NUM , pos ) ) ; } if ( pos < oldSize ) { System . arraycopy ( old , pos + _NUM , result , pos , oldSize - pos - _NUM ) ; } return result ; }
protected static int [ ] remove ( int [ ] old , int oldSize , int pos ) { int [ ] result ; if ( old . length - oldSize < COPY_THRESHOLD ) { result = old ; } else { result = new int [ oldSize - _NUM ] ; System . arraycopy ( old , _NUM , result , _NUM , Math . min ( oldSize - _NUM , pos ) ) ; } if ( pos < oldSize ) { System . arraycopy ( old , pos + _NUM , result , pos , oldSize - pos - _NUM ) ; } return result ; }
public JsonNode put ( String fieldName , JsonNode value ) { if ( value == null ) { value = nullNode ( ) ; } return _put ( fieldName , value ) ; }
public JsonNode put ( String fieldName , JsonNode value ) { if ( value == null ) { value = nullNode ( ) ; } return _put ( fieldName , value ) ; }
public void reset ( ) { Iterator iter = m_vis . visibleItems ( m_nodeGroup ) ; while ( iter . hasNext ( ) ) { VisualItem item = ( VisualItem ) iter . next ( ) ; ForceItem fitem = ( ForceItem ) item . get ( FORCEITEM ) ; if ( fitem != null ) { fitem . location [ _NUM ] = ( float ) item . getEndX ( ) ; fitem . location [ _NUM ] = ( float ) item . getEndY ( ) ; fitem . force [ _NUM ] = fitem . force [ _NUM ] = _NUM ; fitem . velocity [ _NUM ] = fitem . velocity [ _NUM ] = _NUM ; } } m_lasttime = - _NUM ; }
public void deletePersistentStore ( ) { try { close ( ) ; } catch ( IOException e ) { } try { deleteLogFile ( version ) ; } catch ( LogException e ) { } try { deleteSnapshot ( version ) ; } catch ( LogException e ) { } try { deleteFile ( fName ( versionFile ) ) ; } catch ( LogException e ) { } try { dir . delete ( ) ; } catch ( SecurityException e ) { } }
public void deletePersistentStore ( ) { try { close ( ) ; } catch ( IOException e ) { } try { deleteLogFile ( version ) ; } catch ( LogException e ) { } try { deleteSnapshot ( version ) ; } catch ( LogException e ) { } try { deleteFile ( fName ( versionFile ) ) ; } catch ( LogException e ) { } try { dir . delete ( ) ; } catch ( SecurityException e ) { } }
public void deletePersistentStore ( ) { try { close ( ) ; } catch ( IOException e ) { } try { deleteLogFile ( version ) ; } catch ( LogException e ) { } try { deleteSnapshot ( version ) ; } catch ( LogException e ) { } try { deleteFile ( fName ( versionFile ) ) ; } catch ( LogException e ) { } try { dir . delete ( ) ; } catch ( SecurityException e ) { } }
protected void addFilter ( DimensionalObject filter ) { filters . add ( filter ) ; }
public static String toString ( double M_ [ ] [ ] , int adp ) { StringBuilder sb = new StringBuilder ( ) ; for ( int j = _NUM ; j < M_ . length ; j ++ ) { for ( int k = _NUM ; k < M_ [ j ] . length ; k ++ ) { double d = M_ [ j ] [ k ] ; String num = String . format ( STRING , d ) ; if ( adp == _NUM ) num = String . format ( STRING , d ) ; sb . append ( num ) ; } sb . append ( STRING ) ; } return sb . toString ( ) ; }
private int readArgumentIndex ( final String pattern , final ParsePosition pos ) { final int start = pos . getIndex ( ) ; seekNonWs ( pattern , pos ) ; final StringBuilder result = new StringBuilder ( ) ; boolean error = _BOOL ; for ( ; ! error && pos . getIndex ( ) < pattern . length ( ) ; next ( pos ) ) { char c = pattern . charAt ( pos . getIndex ( ) ) ; if ( Character . isWhitespace ( c ) ) { seekNonWs ( pattern , pos ) ; c = pattern . charAt ( pos . getIndex ( ) ) ; if ( c != START_FMT && c != END_FE ) { error = _BOOL ; continue ; } } if ( ( c == START_FMT || c == END_FE ) && result . length ( ) > _NUM ) { try { return Integer . parseInt ( result . toString ( ) ) ; } catch ( final NumberFormatException e ) { } } error = ! Character . isDigit ( c ) ; result . append ( c ) ; } if ( error ) { throw new IllegalArgumentException ( STRING + start + STRING + pattern . substring ( start , pos . getIndex ( ) ) ) ; } throw new IllegalArgumentException ( STRING + start ) ; }
public void addTintResourceId ( int resId ) { if ( mCustomTintDrawableIds == null ) mCustomTintDrawableIds = new ArrayList < Integer > ( ) ; mCustomTintDrawableIds . add ( resId ) ; }
public void addTintResourceId ( int resId ) { if ( mCustomTintDrawableIds == null ) mCustomTintDrawableIds = new ArrayList < Integer > ( ) ; mCustomTintDrawableIds . add ( resId ) ; }
public void addAllIndividuals ( Collection < ExampleSetBasedIndividual > newIndividuals ) { individuals . addAll ( newIndividuals ) ; }
public static File findConfigInWorkingDirectory ( ) { for ( final String suffix : SUFFIXES ) { final File configFile = new File ( System . getProperty ( STRING ) , PREFIX + suffix ) ; if ( configFile . isFile ( ) ) { return configFile ; } } return null ; }
private ForeignKey findCorrespondingForeignKey ( Table table , ForeignKey fk ) { for ( int fkIdx = _NUM ; fkIdx < table . getForeignKeyCount ( ) ; fkIdx ++ ) { ForeignKey curFk = table . getForeignKey ( fkIdx ) ; if ( ( caseSensitive && fk . equals ( curFk ) ) || ( ! caseSensitive && fk . equalsIgnoreCase ( curFk ) ) ) { return curFk ; } } return null ; }
private ForeignKey findCorrespondingForeignKey ( Table table , ForeignKey fk ) { for ( int fkIdx = _NUM ; fkIdx < table . getForeignKeyCount ( ) ; fkIdx ++ ) { ForeignKey curFk = table . getForeignKey ( fkIdx ) ; if ( ( caseSensitive && fk . equals ( curFk ) ) || ( ! caseSensitive && fk . equalsIgnoreCase ( curFk ) ) ) { return curFk ; } } return null ; }
private ForeignKey findCorrespondingForeignKey ( Table table , ForeignKey fk ) { for ( int fkIdx = _NUM ; fkIdx < table . getForeignKeyCount ( ) ; fkIdx ++ ) { ForeignKey curFk = table . getForeignKey ( fkIdx ) ; if ( ( caseSensitive && fk . equals ( curFk ) ) || ( ! caseSensitive && fk . equalsIgnoreCase ( curFk ) ) ) { return curFk ; } } return null ; }
private ForeignKey findCorrespondingForeignKey ( Table table , ForeignKey fk ) { for ( int fkIdx = _NUM ; fkIdx < table . getForeignKeyCount ( ) ; fkIdx ++ ) { ForeignKey curFk = table . getForeignKey ( fkIdx ) ; if ( ( caseSensitive && fk . equals ( curFk ) ) || ( ! caseSensitive && fk . equalsIgnoreCase ( curFk ) ) ) { return curFk ; } } return null ; }
private ForeignKey findCorrespondingForeignKey ( Table table , ForeignKey fk ) { for ( int fkIdx = _NUM ; fkIdx < table . getForeignKeyCount ( ) ; fkIdx ++ ) { ForeignKey curFk = table . getForeignKey ( fkIdx ) ; if ( ( caseSensitive && fk . equals ( curFk ) ) || ( ! caseSensitive && fk . equalsIgnoreCase ( curFk ) ) ) { return curFk ; } } return null ; }
public void addStringToTable ( byte [ ] oldString , byte newString ) { int length = oldString . length ; byte [ ] string = new byte [ length + _NUM ] ; System . arraycopy ( oldString , _NUM , string , _NUM , length ) ; string [ length ] = newString ; stringTable [ tableIndex ++ ] = string ; if ( tableIndex == _NUM ) { bitsToGet = _NUM ; } else if ( tableIndex == _NUM ) { bitsToGet = _NUM ; } else if ( tableIndex == _NUM ) { bitsToGet = _NUM ; } }
@ KnownFailure ( STRING ) public void test_SelectRightOuterJoin ( ) throws SQLException { String sql = STRING + DatabaseCreator . CUSTOMERS_TABLE + STRING + DatabaseCreator . SALESPEOPLE_TABLE + STRING ; ResultSet result = statement . executeQuery ( sql ) ; HashMap < Integer , Integer > value = new HashMap < Integer , Integer > ( ) ; value . put ( _NUM , _NUM ) ; value . put ( _NUM , _NUM ) ; value . put ( _NUM , _NUM ) ; value . put ( _NUM , _NUM ) ; value . put ( _NUM , _NUM ) ; value . put ( _NUM , null ) ; while ( result . next ( ) ) { int key = result . getInt ( STRING ) ; Object val = result . getObject ( STRING ) ; assertTrue ( STRING , value . containsKey ( key ) ) ; assertEquals ( STRING , value . get ( key ) , ( Integer ) val ) ; value . remove ( key ) ; } assertTrue ( STRING , value . isEmpty ( ) ) ; result . close ( ) ; }
@ KnownFailure ( STRING ) public void test_SelectRightOuterJoin ( ) throws SQLException { String sql = STRING + DatabaseCreator . CUSTOMERS_TABLE + STRING + DatabaseCreator . SALESPEOPLE_TABLE + STRING ; ResultSet result = statement . executeQuery ( sql ) ; HashMap < Integer , Integer > value = new HashMap < Integer , Integer > ( ) ; value . put ( _NUM , _NUM ) ; value . put ( _NUM , _NUM ) ; value . put ( _NUM , _NUM ) ; value . put ( _NUM , _NUM ) ; value . put ( _NUM , _NUM ) ; value . put ( _NUM , null ) ; while ( result . next ( ) ) { int key = result . getInt ( STRING ) ; Object val = result . getObject ( STRING ) ; assertTrue ( STRING , value . containsKey ( key ) ) ; assertEquals ( STRING , value . get ( key ) , ( Integer ) val ) ; value . remove ( key ) ; } assertTrue ( STRING , value . isEmpty ( ) ) ; result . close ( ) ; }
public static long nowInNanos ( ) { return System . nanoTime ( ) ; }
public void testCorrectBuild ( ) { Iterator < String > iter = m_Trie . iterator ( ) ; HashSet < String > set = new HashSet < String > ( ) ; while ( iter . hasNext ( ) ) set . add ( iter . next ( ) ) ; assertEquals ( STRING , m_Data . length , m_Trie . size ( ) ) ; assertEquals ( STRING , m_Data . length , set . size ( ) ) ; for ( int i = _NUM ; i < m_Data . length ; i ++ ) { if ( ! set . contains ( m_Data [ i ] ) ) fail ( STRING + m_Data [ i ] + STRING ) ; } }
public void testCorrectBuild ( ) { Iterator < String > iter = m_Trie . iterator ( ) ; HashSet < String > set = new HashSet < String > ( ) ; while ( iter . hasNext ( ) ) set . add ( iter . next ( ) ) ; assertEquals ( STRING , m_Data . length , m_Trie . size ( ) ) ; assertEquals ( STRING , m_Data . length , set . size ( ) ) ; for ( int i = _NUM ; i < m_Data . length ; i ++ ) { if ( ! set . contains ( m_Data [ i ] ) ) fail ( STRING + m_Data [ i ] + STRING ) ; } }
public ActivityResolveInfo ( ResolveInfo resolveInfo ) { this . resolveInfo = resolveInfo ; }
@ SuppressWarnings ( STRING ) public static void translatePoint ( PointF point , float offset , float angle ) { float radiant = ( float ) Math . toRadians ( angle ) ; point . x += ( float ) ( Math . cos ( radiant ) * offset ) ; point . y += ( float ) ( Math . sin ( radiant ) * offset ) ; }
@ SuppressWarnings ( STRING ) public static void translatePoint ( PointF point , float offset , float angle ) { float radiant = ( float ) Math . toRadians ( angle ) ; point . x += ( float ) ( Math . cos ( radiant ) * offset ) ; point . y += ( float ) ( Math . sin ( radiant ) * offset ) ; }
public IPoint next ( ) { if ( stack . empty ( ) ) { throw new java . util . NoSuchElementException ( STRING ) ; } Moment m = stack . peek ( ) ; advance ( ) ; return m . node . point ; }
public IPoint next ( ) { if ( stack . empty ( ) ) { throw new java . util . NoSuchElementException ( STRING ) ; } Moment m = stack . peek ( ) ; advance ( ) ; return m . node . point ; }
public static void bindPreferenceSummaryToValue ( Preference preference ) { setAndCallPreferenceChangeListener ( preference , sBindPreferenceSummaryToValueListener ) ; }
public static void bindPreferenceSummaryToValue ( Preference preference ) { setAndCallPreferenceChangeListener ( preference , sBindPreferenceSummaryToValueListener ) ; }
public static void bindPreferenceSummaryToValue ( Preference preference ) { setAndCallPreferenceChangeListener ( preference , sBindPreferenceSummaryToValueListener ) ; }
public static void bindPreferenceSummaryToValue ( Preference preference ) { setAndCallPreferenceChangeListener ( preference , sBindPreferenceSummaryToValueListener ) ; }
private double secondPartialDerivative ( FittingFunction f , int i , int j , double [ ] p , double delt ) { double [ ] arg = new double [ p . length ] ; System . arraycopy ( p , _NUM , arg , _NUM , p . length ) ; double center = f . evaluate ( arg ) ; arg [ i ] += delt ; arg [ j ] += delt ; double ff1 = f . evaluate ( arg ) ; arg [ j ] -= _NUM * delt ; double ff2 = f . evaluate ( arg ) ; arg [ i ] -= _NUM * delt ; arg [ j ] += _NUM * delt ; double ff3 = f . evaluate ( arg ) ; arg [ j ] -= _NUM * delt ; double ff4 = f . evaluate ( arg ) ; if ( Double . isNaN ( ff1 ) ) { ff1 = center ; } if ( Double . isNaN ( ff2 ) ) { ff2 = center ; } if ( Double . isNaN ( ff3 ) ) { ff3 = center ; } if ( Double . isNaN ( ff4 ) ) { ff4 = center ; } double fsSum = ff1 - ff2 - ff3 + ff4 ; return fsSum / ( _NUM * delt * delt ) ; }
private double secondPartialDerivative ( FittingFunction f , int i , int j , double [ ] p , double delt ) { double [ ] arg = new double [ p . length ] ; System . arraycopy ( p , _NUM , arg , _NUM , p . length ) ; double center = f . evaluate ( arg ) ; arg [ i ] += delt ; arg [ j ] += delt ; double ff1 = f . evaluate ( arg ) ; arg [ j ] -= _NUM * delt ; double ff2 = f . evaluate ( arg ) ; arg [ i ] -= _NUM * delt ; arg [ j ] += _NUM * delt ; double ff3 = f . evaluate ( arg ) ; arg [ j ] -= _NUM * delt ; double ff4 = f . evaluate ( arg ) ; if ( Double . isNaN ( ff1 ) ) { ff1 = center ; } if ( Double . isNaN ( ff2 ) ) { ff2 = center ; } if ( Double . isNaN ( ff3 ) ) { ff3 = center ; } if ( Double . isNaN ( ff4 ) ) { ff4 = center ; } double fsSum = ff1 - ff2 - ff3 + ff4 ; return fsSum / ( _NUM * delt * delt ) ; }
static String internalToBinaryClassName ( String className ) { if ( className == null ) { return null ; } else { return className . replace ( STRING , STRING ) ; } }
static String internalToBinaryClassName ( String className ) { if ( className == null ) { return null ; } else { return className . replace ( STRING , STRING ) ; } }
static String internalToBinaryClassName ( String className ) { if ( className == null ) { return null ; } else { return className . replace ( STRING , STRING ) ; } }
static String internalToBinaryClassName ( String className ) { if ( className == null ) { return null ; } else { return className . replace ( STRING , STRING ) ; } }
public static void copyFile ( File srcFile , File destFile ) throws IOException { if ( destFile . exists ( ) && destFile . isDirectory ( ) ) { throw new IOException ( STRING + destFile + STRING ) ; } FileInputStream input = new FileInputStream ( srcFile ) ; try { FileOutputStream output = new FileOutputStream ( destFile ) ; try { copy ( input , output ) ; } finally { close ( output ) ; } } finally { close ( input ) ; } if ( srcFile . length ( ) != destFile . length ( ) ) { throw new IOException ( STRING + srcFile + STRING + destFile + STRING ) ; } destFile . setLastModified ( srcFile . lastModified ( ) ) ; }
public static void copyFile ( File srcFile , File destFile ) throws IOException { if ( destFile . exists ( ) && destFile . isDirectory ( ) ) { throw new IOException ( STRING + destFile + STRING ) ; } FileInputStream input = new FileInputStream ( srcFile ) ; try { FileOutputStream output = new FileOutputStream ( destFile ) ; try { copy ( input , output ) ; } finally { close ( output ) ; } } finally { close ( input ) ; } if ( srcFile . length ( ) != destFile . length ( ) ) { throw new IOException ( STRING + srcFile + STRING + destFile + STRING ) ; } destFile . setLastModified ( srcFile . lastModified ( ) ) ; }
public static long binCoeff ( int n , int k ) { return Math . round ( Math . exp ( logBinCoeff ( n , k ) ) ) ; }
public static long binCoeff ( int n , int k ) { return Math . round ( Math . exp ( logBinCoeff ( n , k ) ) ) ; }
@ SuppressWarnings ( { STRING , STRING } ) private static Method findApplyMethod ( ) { try { Class clz = SharedPreferences . Editor . class ; return clz . getMethod ( STRING ) ; } catch ( NoSuchMethodException e ) { } return null ; }
public NameAndTypeConstant addNameAndType ( String name , String type ) { NameAndTypeConstant entry = getNameAndType ( name , type ) ; if ( entry != null ) return entry ; Utf8Constant nameEntry = addUTF8 ( name ) ; Utf8Constant typeEntry = addUTF8 ( type ) ; entry = new NameAndTypeConstant ( this , _entries . size ( ) , nameEntry . getIndex ( ) , typeEntry . getIndex ( ) ) ; addConstant ( entry ) ; return entry ; }
private void placeChild ( View child , int gravity ) { LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; int availableWidth = Math . max ( _NUM , mEnd - mStart - lp . startMargin - lp . endMargin ) ; if ( child . getMeasuredWidth ( ) > availableWidth || gravity == Gravity . FILL_HORIZONTAL ) { measureChildWithFixedWidth ( child , availableWidth ) ; } if ( gravity == Gravity . START || gravity == Gravity . FILL_HORIZONTAL ) { lp . start = mStart + lp . startMargin ; mStart = lp . start + child . getMeasuredWidth ( ) + lp . endMargin ; } else { lp . start = mEnd - lp . endMargin - child . getMeasuredWidth ( ) ; mEnd = lp . start - lp . startMargin ; } lp . top = mTop + lp . topMargin ; mBottom = Math . max ( mBottom , lp . top + child . getMeasuredHeight ( ) + lp . bottomMargin ) ; }
private void placeChild ( View child , int gravity ) { LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; int availableWidth = Math . max ( _NUM , mEnd - mStart - lp . startMargin - lp . endMargin ) ; if ( child . getMeasuredWidth ( ) > availableWidth || gravity == Gravity . FILL_HORIZONTAL ) { measureChildWithFixedWidth ( child , availableWidth ) ; } if ( gravity == Gravity . START || gravity == Gravity . FILL_HORIZONTAL ) { lp . start = mStart + lp . startMargin ; mStart = lp . start + child . getMeasuredWidth ( ) + lp . endMargin ; } else { lp . start = mEnd - lp . endMargin - child . getMeasuredWidth ( ) ; mEnd = lp . start - lp . startMargin ; } lp . top = mTop + lp . topMargin ; mBottom = Math . max ( mBottom , lp . top + child . getMeasuredHeight ( ) + lp . bottomMargin ) ; }
public void terminate ( ) throws IOException { try { try { synchronized ( mJobs ) { while ( mBusy || ! mJobs . isEmpty ( ) ) { mJobs . wait ( NOT_DONE_SLEEP_TIME ) ; } } } catch ( final InterruptedException e ) { ProgramState . setAbort ( ) ; } finally { shutdown ( ) ; } rethrow ( ) ; } finally { ProgramState . clearAbort ( ) ; try { synchronized ( mQueueThread ) { while ( ! mQueueDone ) { mQueueThread . wait ( NOT_DONE_SLEEP_TIME ) ; } } } catch ( final InterruptedException e ) { } } }
public void terminate ( ) throws IOException { try { try { synchronized ( mJobs ) { while ( mBusy || ! mJobs . isEmpty ( ) ) { mJobs . wait ( NOT_DONE_SLEEP_TIME ) ; } } } catch ( final InterruptedException e ) { ProgramState . setAbort ( ) ; } finally { shutdown ( ) ; } rethrow ( ) ; } finally { ProgramState . clearAbort ( ) ; try { synchronized ( mQueueThread ) { while ( ! mQueueDone ) { mQueueThread . wait ( NOT_DONE_SLEEP_TIME ) ; } } } catch ( final InterruptedException e ) { } } }
public void terminate ( ) throws IOException { try { try { synchronized ( mJobs ) { while ( mBusy || ! mJobs . isEmpty ( ) ) { mJobs . wait ( NOT_DONE_SLEEP_TIME ) ; } } } catch ( final InterruptedException e ) { ProgramState . setAbort ( ) ; } finally { shutdown ( ) ; } rethrow ( ) ; } finally { ProgramState . clearAbort ( ) ; try { synchronized ( mQueueThread ) { while ( ! mQueueDone ) { mQueueThread . wait ( NOT_DONE_SLEEP_TIME ) ; } } } catch ( final InterruptedException e ) { } } }
public void terminate ( ) throws IOException { try { try { synchronized ( mJobs ) { while ( mBusy || ! mJobs . isEmpty ( ) ) { mJobs . wait ( NOT_DONE_SLEEP_TIME ) ; } } } catch ( final InterruptedException e ) { ProgramState . setAbort ( ) ; } finally { shutdown ( ) ; } rethrow ( ) ; } finally { ProgramState . clearAbort ( ) ; try { synchronized ( mQueueThread ) { while ( ! mQueueDone ) { mQueueThread . wait ( NOT_DONE_SLEEP_TIME ) ; } } } catch ( final InterruptedException e ) { } } }
public Future < ? > drainContinuously ( ) { return drainer . submit ( new ContinuousDrain ( ) ) ; }
public Future < ? > drainContinuously ( ) { return drainer . submit ( new ContinuousDrain ( ) ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case _NUM : return HOST ; case _NUM : return PORT ; case _NUM : return ID ; case _NUM : return STATE ; case _NUM : return TIMESTAMP ; case _NUM : return VERSION ; default : return null ; } }
protected void addToPortMap ( IOFSwitch sw , long mac , short vlan , short portVal ) { Map < MacVlanPair , Short > swMap = macVlanToSwitchPortMap . get ( sw ) ; if ( vlan == ( short ) _NUM ) { vlan = _NUM ; } if ( swMap == null ) { swMap = Collections . synchronizedMap ( new LRULinkedHashMap < MacVlanPair , Short > ( MAX_MACS_PER_SWITCH ) ) ; macVlanToSwitchPortMap . put ( sw , swMap ) ; } swMap . put ( new MacVlanPair ( mac , vlan ) , portVal ) ; }
@ Override public synchronized boolean takePartition ( String topic , int partition ) { Set < Integer > partitionSet = m_myTopicPartitions . get ( topic ) ; if ( partitionSet == null ) return _BOOL ; String ownerPath = ownerPath ( topic , partition ) ; try { if ( m_zk . exists ( ownerPath ) ) { return _BOOL ; } if ( m_zk . create ( ownerPath , _BOOL ) ) { m_zk . writeString ( ownerPath , m_consumerId ) ; partitionSet . add ( partition ) ; return _BOOL ; } else return _BOOL ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { LOGGER . error ( STRING + ownerPath , e ) ; return _BOOL ; } }
@ Override public synchronized boolean takePartition ( String topic , int partition ) { Set < Integer > partitionSet = m_myTopicPartitions . get ( topic ) ; if ( partitionSet == null ) return _BOOL ; String ownerPath = ownerPath ( topic , partition ) ; try { if ( m_zk . exists ( ownerPath ) ) { return _BOOL ; } if ( m_zk . create ( ownerPath , _BOOL ) ) { m_zk . writeString ( ownerPath , m_consumerId ) ; partitionSet . add ( partition ) ; return _BOOL ; } else return _BOOL ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { LOGGER . error ( STRING + ownerPath , e ) ; return _BOOL ; } }
@ Override public void close ( ) { actionDelegates . clear ( ) ; }
public OrQueryBuilder add ( QueryBuilder filterBuilder ) { filters . add ( filterBuilder ) ; return this ; }
@ Override public String firstChunk ( List < String > chunks ) { if ( chunks == null || chunks . size ( ) == _NUM ) { return null ; } return chunks . get ( _NUM ) ; }
@ Override public String firstChunk ( List < String > chunks ) { if ( chunks == null || chunks . size ( ) == _NUM ) { return null ; } return chunks . get ( _NUM ) ; }
public void dispose ( ) { logDebug ( STRING ) ; mSetupDone = _BOOL ; if ( mServiceConn != null ) { logDebug ( STRING ) ; if ( mContext != null && mService != null ) { try { mContext . unbindService ( mServiceConn ) ; } catch ( Exception e ) { } } } mDisposed = _BOOL ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
public void dispose ( ) { logDebug ( STRING ) ; mSetupDone = _BOOL ; if ( mServiceConn != null ) { logDebug ( STRING ) ; if ( mContext != null && mService != null ) { try { mContext . unbindService ( mServiceConn ) ; } catch ( Exception e ) { } } } mDisposed = _BOOL ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
public void dispose ( ) { logDebug ( STRING ) ; mSetupDone = _BOOL ; if ( mServiceConn != null ) { logDebug ( STRING ) ; if ( mContext != null && mService != null ) { try { mContext . unbindService ( mServiceConn ) ; } catch ( Exception e ) { } } } mDisposed = _BOOL ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
public void dispose ( ) { logDebug ( STRING ) ; mSetupDone = _BOOL ; if ( mServiceConn != null ) { logDebug ( STRING ) ; if ( mContext != null && mService != null ) { try { mContext . unbindService ( mServiceConn ) ; } catch ( Exception e ) { } } } mDisposed = _BOOL ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
M meta ( ) ;
private void checkToRepaint ( ) { long timePassed = ( System . currentTimeMillis ( ) - lastRepainted ) / _NUM ; if ( timePassed > REPAINT_DELAY ) { repaint ( ) ; lastRepainted = System . currentTimeMillis ( ) ; } }
public int [ ] toUnsortedModelIndices ( int [ ] sortedSelectedIndices ) { int [ ] unsortedSelectedIndices = new int [ sortedSelectedIndices . length ] ; int x = _NUM ; for ( int sortedIndex : sortedSelectedIndices ) { unsortedSelectedIndices [ x ++ ] = toUnsortedModelIndex ( sortedIndex ) ; } Arrays . sort ( unsortedSelectedIndices ) ; return unsortedSelectedIndices ; }
public int [ ] toUnsortedModelIndices ( int [ ] sortedSelectedIndices ) { int [ ] unsortedSelectedIndices = new int [ sortedSelectedIndices . length ] ; int x = _NUM ; for ( int sortedIndex : sortedSelectedIndices ) { unsortedSelectedIndices [ x ++ ] = toUnsortedModelIndex ( sortedIndex ) ; } Arrays . sort ( unsortedSelectedIndices ) ; return unsortedSelectedIndices ; }
public void notifyAddressThrottleFound ( DccThrottle t ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING ) ; } mThrottle = t ; setEnabled ( _BOOL ) ; mThrottle . addPropertyChangeListener ( this ) ; setFnButtons ( ) ; }
public void notifyAddressThrottleFound ( DccThrottle t ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING ) ; } mThrottle = t ; setEnabled ( _BOOL ) ; mThrottle . addPropertyChangeListener ( this ) ; setFnButtons ( ) ; }
public void notifyAddressThrottleFound ( DccThrottle t ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING ) ; } mThrottle = t ; setEnabled ( _BOOL ) ; mThrottle . addPropertyChangeListener ( this ) ; setFnButtons ( ) ; }
@ ResponseBody @ RequestMapping ( value = STRING , method = RequestMethod . GET ) public List < ContainerUnit > listContainer ( @ PathVariable String applicationName ) throws ServiceException , CheckException { logger . debug ( STRING + applicationName ) ; return applicationService . listContainers ( applicationName ) ; }
private void writePacketOutForPacketIn ( IOFSwitch sw , OFPacketIn packetInMessage , OFPort egressPort ) { OFMessageUtils . writePacketOutForPacketIn ( sw , packetInMessage , egressPort ) ; counterPacketOut . increment ( ) ; }
public < U > SimpleReactStream < Long > from ( final LongStream stream ) { return from ( stream . boxed ( ) ) ; }
private void writeJournal ( ParcelFileDescriptor newState , Journal journal ) { try { FileOutputStream outStream = new FileOutputStream ( newState . getFileDescriptor ( ) ) ; final byte [ ] journalBytes = writeCheckedBytes ( journal ) ; outStream . write ( journalBytes ) ; if ( VERBOSE ) Log . v ( TAG , STRING + journalBytes . length + STRING ) ; } catch ( IOException e ) { Log . w ( TAG , STRING , e ) ; } }
private void writeJournal ( ParcelFileDescriptor newState , Journal journal ) { try { FileOutputStream outStream = new FileOutputStream ( newState . getFileDescriptor ( ) ) ; final byte [ ] journalBytes = writeCheckedBytes ( journal ) ; outStream . write ( journalBytes ) ; if ( VERBOSE ) Log . v ( TAG , STRING + journalBytes . length + STRING ) ; } catch ( IOException e ) { Log . w ( TAG , STRING , e ) ; } }
private void writeJournal ( ParcelFileDescriptor newState , Journal journal ) { try { FileOutputStream outStream = new FileOutputStream ( newState . getFileDescriptor ( ) ) ; final byte [ ] journalBytes = writeCheckedBytes ( journal ) ; outStream . write ( journalBytes ) ; if ( VERBOSE ) Log . v ( TAG , STRING + journalBytes . length + STRING ) ; } catch ( IOException e ) { Log . w ( TAG , STRING , e ) ; } }
protected boolean unsyncEnclosed ( ) { try { OffsetGrabPoint gb0 = ( OffsetGrabPoint ) polyGrabPoints . get ( _NUM ) ; OffsetGrabPoint ogb = ( OffsetGrabPoint ) polyGrabPoints . get ( polyGrabPoints . size ( ) - _NUM ) ; if ( gb0 . getX ( ) == ogb . getX ( ) && gb0 . getY ( ) == ogb . getY ( ) ) { gb0 . removeGrabPoint ( ogb ) ; ogb . removeGrabPoint ( gb0 ) ; return _BOOL ; } } catch ( ClassCastException cce ) { } catch ( ArrayIndexOutOfBoundsException aioobe ) { } return _BOOL ; }
protected boolean unsyncEnclosed ( ) { try { OffsetGrabPoint gb0 = ( OffsetGrabPoint ) polyGrabPoints . get ( _NUM ) ; OffsetGrabPoint ogb = ( OffsetGrabPoint ) polyGrabPoints . get ( polyGrabPoints . size ( ) - _NUM ) ; if ( gb0 . getX ( ) == ogb . getX ( ) && gb0 . getY ( ) == ogb . getY ( ) ) { gb0 . removeGrabPoint ( ogb ) ; ogb . removeGrabPoint ( gb0 ) ; return _BOOL ; } } catch ( ClassCastException cce ) { } catch ( ArrayIndexOutOfBoundsException aioobe ) { } return _BOOL ; }
Cut ( Constant value , double diff ) { this . value = value ; this . diff = diff ; }
Cut ( Constant value , double diff ) { this . value = value ; this . diff = diff ; }
Cut ( Constant value , double diff ) { this . value = value ; this . diff = diff ; }
Cut ( Constant value , double diff ) { this . value = value ; this . diff = diff ; }
static public void doRejectionTest ( String data , Class exceptionClass ) { try { MIMEType t = new MIMEType ( data ) ; } catch ( Throwable t ) { if ( exceptionClass . isInstance ( t ) ) return ; t . printStackTrace ( System . err ) ; throw new AssertionFailedError2 ( STRING + exceptionClass + STRING + STRING + t . getClass ( ) + STRING + data + STRING , t ) ; } throw new AssertionFailedError ( STRING + exceptionClass + STRING + data + STRING ) ; }
static public void doRejectionTest ( String data , Class exceptionClass ) { try { MIMEType t = new MIMEType ( data ) ; } catch ( Throwable t ) { if ( exceptionClass . isInstance ( t ) ) return ; t . printStackTrace ( System . err ) ; throw new AssertionFailedError2 ( STRING + exceptionClass + STRING + STRING + t . getClass ( ) + STRING + data + STRING , t ) ; } throw new AssertionFailedError ( STRING + exceptionClass + STRING + data + STRING ) ; }
public boolean deleteProject ( File directory ) { Log . i ( TAG , STRING + directory . toString ( ) ) ; if ( directory . isDirectory ( ) ) { String [ ] filesInDirecory = directory . list ( ) ; for ( int i = _NUM ; i < filesInDirecory . length ; i ++ ) { boolean success = deleteProject ( new File ( directory , filesInDirecory [ i ] ) ) ; if ( ! success ) { return _BOOL ; } } } return directory . delete ( ) ; }
public void verifyCountsAndClear ( int expectedRegistrations , int expectedUnregistrations ) { assertEquals ( expectedRegistrations , registrationCount ) ; assertEquals ( expectedUnregistrations , unregistrationCount ) ; registrationCount = _NUM ; unregistrationCount = _NUM ; }
@ Override public ShardResponse takeCompletedIncludingErrors ( ) { return take ( _BOOL ) ; }
public static boolean match ( String value , String strPattern ) { if ( isNotEmpty ( strPattern ) ) { if ( isBlank ( value ) ) { return strPattern . equals ( STRING ) ; } value = value . toLowerCase ( ) ; strPattern = strPattern . toLowerCase ( ) ; StringBuilder buff = new StringBuilder ( ) ; for ( int i = _NUM ; i < strPattern . length ( ) - _NUM ; i ++ ) { char c = strPattern . charAt ( i ) ; if ( c == STRING ) { buff . append ( STRING ) ; } else { buff . append ( c ) ; } } char lastChar = strPattern . charAt ( strPattern . length ( ) - _NUM ) ; if ( lastChar == STRING ) { buff . append ( STRING ) ; } else { buff . append ( lastChar ) ; } return Pattern . matches ( buff . toString ( ) , value ) ; } return _BOOL ; }
public int writeProtoId ( ProtoId protoId ) { int off = data . position ( ) ; writeInt ( protoId . shortyIndex ) ; writeInt ( protoId . returnTypeIndex ) ; writeInt ( protoId . parametersOffset ) ; return off ; }
@ Override public synchronized Object executeTask ( Task t ) throws RemoteException { String taskId = STRING + System . currentTimeMillis ( ) + STRING ; taskId += t . hashCode ( ) ; addTaskToQueue ( t , taskId ) ; return taskId ; }
public static ConstraintsParameters loadPolicyData ( InputStream policyDataStream ) { if ( policyDataStream != null ) { return load ( policyDataStream ) ; } if ( ( defaultPolicyConstraintsLocation != null ) && ! defaultPolicyConstraintsLocation . isEmpty ( ) ) { return load ( defaultPolicyConstraintsLocation ) ; } return null ; }
private List < VcsException > parseException ( final String stderr ) { final List < VcsException > exceptions = new ArrayList < VcsException > ( ) ; final String [ ] exceptionLines = getLines ( stderr ) ; for ( int i = exceptionLines . length / _NUM ; i < exceptionLines . length ; i ++ ) { if ( StringUtils . isNotEmpty ( exceptionLines [ i ] ) && ! StringUtils . contains ( exceptionLines [ i ] , CONFLICT_MESSAGE ) ) { final VcsException exception = new VcsException ( ( exceptionLines [ i ] ) ) ; exception . setIsWarning ( StringUtils . startsWith ( exceptionLines [ i ] , WARNING_PREFIX ) ) ; exceptions . add ( exception ) ; } } return exceptions ; }
private List < VcsException > parseException ( final String stderr ) { final List < VcsException > exceptions = new ArrayList < VcsException > ( ) ; final String [ ] exceptionLines = getLines ( stderr ) ; for ( int i = exceptionLines . length / _NUM ; i < exceptionLines . length ; i ++ ) { if ( StringUtils . isNotEmpty ( exceptionLines [ i ] ) && ! StringUtils . contains ( exceptionLines [ i ] , CONFLICT_MESSAGE ) ) { final VcsException exception = new VcsException ( ( exceptionLines [ i ] ) ) ; exception . setIsWarning ( StringUtils . startsWith ( exceptionLines [ i ] , WARNING_PREFIX ) ) ; exceptions . add ( exception ) ; } } return exceptions ; }
private List < VcsException > parseException ( final String stderr ) { final List < VcsException > exceptions = new ArrayList < VcsException > ( ) ; final String [ ] exceptionLines = getLines ( stderr ) ; for ( int i = exceptionLines . length / _NUM ; i < exceptionLines . length ; i ++ ) { if ( StringUtils . isNotEmpty ( exceptionLines [ i ] ) && ! StringUtils . contains ( exceptionLines [ i ] , CONFLICT_MESSAGE ) ) { final VcsException exception = new VcsException ( ( exceptionLines [ i ] ) ) ; exception . setIsWarning ( StringUtils . startsWith ( exceptionLines [ i ] , WARNING_PREFIX ) ) ; exceptions . add ( exception ) ; } } return exceptions ; }
private List < VcsException > parseException ( final String stderr ) { final List < VcsException > exceptions = new ArrayList < VcsException > ( ) ; final String [ ] exceptionLines = getLines ( stderr ) ; for ( int i = exceptionLines . length / _NUM ; i < exceptionLines . length ; i ++ ) { if ( StringUtils . isNotEmpty ( exceptionLines [ i ] ) && ! StringUtils . contains ( exceptionLines [ i ] , CONFLICT_MESSAGE ) ) { final VcsException exception = new VcsException ( ( exceptionLines [ i ] ) ) ; exception . setIsWarning ( StringUtils . startsWith ( exceptionLines [ i ] , WARNING_PREFIX ) ) ; exceptions . add ( exception ) ; } } return exceptions ; }
private List < VcsException > parseException ( final String stderr ) { final List < VcsException > exceptions = new ArrayList < VcsException > ( ) ; final String [ ] exceptionLines = getLines ( stderr ) ; for ( int i = exceptionLines . length / _NUM ; i < exceptionLines . length ; i ++ ) { if ( StringUtils . isNotEmpty ( exceptionLines [ i ] ) && ! StringUtils . contains ( exceptionLines [ i ] , CONFLICT_MESSAGE ) ) { final VcsException exception = new VcsException ( ( exceptionLines [ i ] ) ) ; exception . setIsWarning ( StringUtils . startsWith ( exceptionLines [ i ] , WARNING_PREFIX ) ) ; exceptions . add ( exception ) ; } } return exceptions ; }
public static int intFromProperties ( Properties p , String propName , int defaultValue ) { int ret = defaultValue ; String intString = p . getProperty ( propName ) ; if ( intString != null ) { try { ret = Integer . parseInt ( intString . trim ( ) ) ; } catch ( NumberFormatException e ) { ret = defaultValue ; } } return ret ; }
public static int intFromProperties ( Properties p , String propName , int defaultValue ) { int ret = defaultValue ; String intString = p . getProperty ( propName ) ; if ( intString != null ) { try { ret = Integer . parseInt ( intString . trim ( ) ) ; } catch ( NumberFormatException e ) { ret = defaultValue ; } } return ret ; }
protected final void firePropertyChange ( PropertyChangeEvent event ) { PropertyChangeSupport aChangeSupport = this . changeSupport ; if ( aChangeSupport == null ) { return ; } aChangeSupport . firePropertyChange ( event ) ; }
public ToHitData losModifiers ( IGame game ) { return losModifiers ( game , _NUM , _BOOL ) ; }
public ToHitData losModifiers ( IGame game ) { return losModifiers ( game , _NUM , _BOOL ) ; }
public void append ( File file , FTPDataTransferListener listener ) throws IllegalStateException , FileNotFoundException , IOException , FTPIllegalReplyException , FTPException , FTPDataTransferException , FTPAbortedException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getAbsolutePath ( ) ) ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; } catch ( IOException e ) { throw new FTPDataTransferException ( e ) ; } try { append ( file . getName ( ) , inputStream , _NUM , listener ) ; } catch ( IllegalStateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( FTPIllegalReplyException e ) { throw e ; } catch ( FTPException e ) { throw e ; } catch ( FTPDataTransferException e ) { throw e ; } catch ( FTPAbortedException e ) { throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void append ( File file , FTPDataTransferListener listener ) throws IllegalStateException , FileNotFoundException , IOException , FTPIllegalReplyException , FTPException , FTPDataTransferException , FTPAbortedException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getAbsolutePath ( ) ) ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; } catch ( IOException e ) { throw new FTPDataTransferException ( e ) ; } try { append ( file . getName ( ) , inputStream , _NUM , listener ) ; } catch ( IllegalStateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( FTPIllegalReplyException e ) { throw e ; } catch ( FTPException e ) { throw e ; } catch ( FTPDataTransferException e ) { throw e ; } catch ( FTPAbortedException e ) { throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void append ( File file , FTPDataTransferListener listener ) throws IllegalStateException , FileNotFoundException , IOException , FTPIllegalReplyException , FTPException , FTPDataTransferException , FTPAbortedException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getAbsolutePath ( ) ) ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; } catch ( IOException e ) { throw new FTPDataTransferException ( e ) ; } try { append ( file . getName ( ) , inputStream , _NUM , listener ) ; } catch ( IllegalStateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( FTPIllegalReplyException e ) { throw e ; } catch ( FTPException e ) { throw e ; } catch ( FTPDataTransferException e ) { throw e ; } catch ( FTPAbortedException e ) { throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void append ( File file , FTPDataTransferListener listener ) throws IllegalStateException , FileNotFoundException , IOException , FTPIllegalReplyException , FTPException , FTPDataTransferException , FTPAbortedException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getAbsolutePath ( ) ) ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; } catch ( IOException e ) { throw new FTPDataTransferException ( e ) ; } try { append ( file . getName ( ) , inputStream , _NUM , listener ) ; } catch ( IllegalStateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( FTPIllegalReplyException e ) { throw e ; } catch ( FTPException e ) { throw e ; } catch ( FTPDataTransferException e ) { throw e ; } catch ( FTPAbortedException e ) { throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void append ( File file , FTPDataTransferListener listener ) throws IllegalStateException , FileNotFoundException , IOException , FTPIllegalReplyException , FTPException , FTPDataTransferException , FTPAbortedException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getAbsolutePath ( ) ) ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; } catch ( IOException e ) { throw new FTPDataTransferException ( e ) ; } try { append ( file . getName ( ) , inputStream , _NUM , listener ) ; } catch ( IllegalStateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( FTPIllegalReplyException e ) { throw e ; } catch ( FTPException e ) { throw e ; } catch ( FTPDataTransferException e ) { throw e ; } catch ( FTPAbortedException e ) { throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void append ( File file , FTPDataTransferListener listener ) throws IllegalStateException , FileNotFoundException , IOException , FTPIllegalReplyException , FTPException , FTPDataTransferException , FTPAbortedException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getAbsolutePath ( ) ) ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; } catch ( IOException e ) { throw new FTPDataTransferException ( e ) ; } try { append ( file . getName ( ) , inputStream , _NUM , listener ) ; } catch ( IllegalStateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( FTPIllegalReplyException e ) { throw e ; } catch ( FTPException e ) { throw e ; } catch ( FTPDataTransferException e ) { throw e ; } catch ( FTPAbortedException e ) { throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void append ( File file , FTPDataTransferListener listener ) throws IllegalStateException , FileNotFoundException , IOException , FTPIllegalReplyException , FTPException , FTPDataTransferException , FTPAbortedException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getAbsolutePath ( ) ) ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; } catch ( IOException e ) { throw new FTPDataTransferException ( e ) ; } try { append ( file . getName ( ) , inputStream , _NUM , listener ) ; } catch ( IllegalStateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( FTPIllegalReplyException e ) { throw e ; } catch ( FTPException e ) { throw e ; } catch ( FTPDataTransferException e ) { throw e ; } catch ( FTPAbortedException e ) { throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { ; } } } }
protected Transferable createTransferable ( JComponent c ) { if ( c instanceof JList ) { JList list = ( JList ) c ; Object [ ] values = list . getSelectedValues ( ) ; if ( values == null || values . length == _NUM ) { return null ; } StringBuffer plainBuf = new StringBuffer ( ) ; StringBuffer htmlBuf = new StringBuffer ( ) ; htmlBuf . append ( STRING ) ; for ( int i = _NUM ; i < values . length ; i ++ ) { Object obj = values [ i ] ; String val = ( ( obj == null ) ? STRING : obj . toString ( ) ) ; plainBuf . append ( val + STRING ) ; htmlBuf . append ( STRING + val + STRING ) ; } plainBuf . deleteCharAt ( plainBuf . length ( ) - _NUM ) ; htmlBuf . append ( STRING ) ; return new BasicTransferable ( plainBuf . toString ( ) , htmlBuf . toString ( ) ) ; } return null ; }
public static void updateStateSetTrees ( List < Tree < StateSet > > trees , ArrayParser parser ) { for ( Tree < StateSet > tree : trees ) { parser . doInsideOutsideScores ( tree , _BOOL , _BOOL ) ; } }
public static void updateStateSetTrees ( List < Tree < StateSet > > trees , ArrayParser parser ) { for ( Tree < StateSet > tree : trees ) { parser . doInsideOutsideScores ( tree , _BOOL , _BOOL ) ; } }
public static void updateStateSetTrees ( List < Tree < StateSet > > trees , ArrayParser parser ) { for ( Tree < StateSet > tree : trees ) { parser . doInsideOutsideScores ( tree , _BOOL , _BOOL ) ; } }
public static void updateStateSetTrees ( List < Tree < StateSet > > trees , ArrayParser parser ) { for ( Tree < StateSet > tree : trees ) { parser . doInsideOutsideScores ( tree , _BOOL , _BOOL ) ; } }
public void actionPerformed ( ActionEvent ae ) { if ( ae . getSource ( ) == getTimer ( ) ) { changeTimeBy ( timeIncrement * clockDirection , timeWrap , clockDirection < _NUM ? TimerStatus . UPDATE : TimerStatus . FORWARD ) ; } }
public void actionPerformed ( ActionEvent ae ) { if ( ae . getSource ( ) == getTimer ( ) ) { changeTimeBy ( timeIncrement * clockDirection , timeWrap , clockDirection < _NUM ? TimerStatus . UPDATE : TimerStatus . FORWARD ) ; } }
public static int findWordStart ( String line , int pos , String noWordSep ) { char ch = line . charAt ( pos - _NUM ) ; if ( noWordSep == null ) noWordSep = STRING ; boolean selectNoLetter = ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - _NUM ) ; int wordStart = _NUM ; for ( int i = pos - _NUM ; i >= _NUM ; i -- ) { ch = line . charAt ( i ) ; if ( selectNoLetter ^ ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - _NUM ) ) { wordStart = i + _NUM ; break ; } } return wordStart ; }
public static int findWordStart ( String line , int pos , String noWordSep ) { char ch = line . charAt ( pos - _NUM ) ; if ( noWordSep == null ) noWordSep = STRING ; boolean selectNoLetter = ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - _NUM ) ; int wordStart = _NUM ; for ( int i = pos - _NUM ; i >= _NUM ; i -- ) { ch = line . charAt ( i ) ; if ( selectNoLetter ^ ( ! Character . isLetterOrDigit ( ch ) && noWordSep . indexOf ( ch ) == - _NUM ) ) { wordStart = i + _NUM ; break ; } } return wordStart ; }
public double adjustedRandIndex ( ) { double d = Math . sqrt ( pairconfuse [ _NUM ] + pairconfuse [ _NUM ] + pairconfuse [ _NUM ] + pairconfuse [ _NUM ] ) ; double exp = ( pairconfuse [ _NUM ] + pairconfuse [ _NUM ] ) / d * ( pairconfuse [ _NUM ] + pairconfuse [ _NUM ] ) / d ; double opt = pairconfuse [ _NUM ] + _NUM * ( pairconfuse [ _NUM ] + pairconfuse [ _NUM ] ) ; return ( pairconfuse [ _NUM ] - exp ) / ( opt - exp ) ; }
public int right_x_value ( int p_y ) { int result = Math . min ( oct_rx , oct_urx - p_y ) ; return Math . min ( result , oct_lrx + p_y ) ; }
public void addStaticField ( EncodedField field , Constant value ) { if ( field == null ) { throw new NullPointerException ( STRING ) ; } if ( staticValuesConstant != null ) { throw new UnsupportedOperationException ( STRING ) ; } staticFields . add ( field ) ; staticValues . put ( field , value ) ; }
protected boolean filterFiles ( List < File > files ) { if ( task . getNoMtimeCheck ( ) || isOutputRepositoryURL ( ) ) { return _BOOL ; } Iterator < File > iter = files . iterator ( ) ; while ( iter . hasNext ( ) ) { File file = iter . next ( ) ; Module module = inferModule ( file ) ; if ( module == null ) { task . log ( STRING + file , Project . MSG_VERBOSE ) ; continue ; } if ( module . getVersion ( ) == null ) { task . log ( STRING + module . getName ( ) , Project . MSG_VERBOSE ) ; continue ; } long oldest = getArtifactFileTime ( module , file ) ; if ( oldest == Long . MAX_VALUE ) { File outModuleDir = getArtifactDir ( module ) ; oldest = oldestOutputArtifact ( Long . MAX_VALUE , outModuleDir ) ; task . log ( STRING + module + STRING + new Date ( oldest ) , Project . MSG_DEBUG ) ; } else { task . log ( STRING + file + STRING + module + STRING + new Date ( oldest ) , Project . MSG_DEBUG ) ; } long newestFile = file . lastModified ( ) ; task . log ( STRING + file + STRING + new Date ( newestFile ) , Project . MSG_DEBUG ) ; if ( newestFile != Long . MIN_VALUE && oldest != Long . MAX_VALUE && newestFile < oldest ) { task . log ( STRING + file + STRING ) ; iter . remove ( ) ; } } return files . size ( ) == _NUM ; }
protected boolean filterFiles ( List < File > files ) { if ( task . getNoMtimeCheck ( ) || isOutputRepositoryURL ( ) ) { return _BOOL ; } Iterator < File > iter = files . iterator ( ) ; while ( iter . hasNext ( ) ) { File file = iter . next ( ) ; Module module = inferModule ( file ) ; if ( module == null ) { task . log ( STRING + file , Project . MSG_VERBOSE ) ; continue ; } if ( module . getVersion ( ) == null ) { task . log ( STRING + module . getName ( ) , Project . MSG_VERBOSE ) ; continue ; } long oldest = getArtifactFileTime ( module , file ) ; if ( oldest == Long . MAX_VALUE ) { File outModuleDir = getArtifactDir ( module ) ; oldest = oldestOutputArtifact ( Long . MAX_VALUE , outModuleDir ) ; task . log ( STRING + module + STRING + new Date ( oldest ) , Project . MSG_DEBUG ) ; } else { task . log ( STRING + file + STRING + module + STRING + new Date ( oldest ) , Project . MSG_DEBUG ) ; } long newestFile = file . lastModified ( ) ; task . log ( STRING + file + STRING + new Date ( newestFile ) , Project . MSG_DEBUG ) ; if ( newestFile != Long . MIN_VALUE && oldest != Long . MAX_VALUE && newestFile < oldest ) { task . log ( STRING + file + STRING ) ; iter . remove ( ) ; } } return files . size ( ) == _NUM ; }
protected boolean filterFiles ( List < File > files ) { if ( task . getNoMtimeCheck ( ) || isOutputRepositoryURL ( ) ) { return _BOOL ; } Iterator < File > iter = files . iterator ( ) ; while ( iter . hasNext ( ) ) { File file = iter . next ( ) ; Module module = inferModule ( file ) ; if ( module == null ) { task . log ( STRING + file , Project . MSG_VERBOSE ) ; continue ; } if ( module . getVersion ( ) == null ) { task . log ( STRING + module . getName ( ) , Project . MSG_VERBOSE ) ; continue ; } long oldest = getArtifactFileTime ( module , file ) ; if ( oldest == Long . MAX_VALUE ) { File outModuleDir = getArtifactDir ( module ) ; oldest = oldestOutputArtifact ( Long . MAX_VALUE , outModuleDir ) ; task . log ( STRING + module + STRING + new Date ( oldest ) , Project . MSG_DEBUG ) ; } else { task . log ( STRING + file + STRING + module + STRING + new Date ( oldest ) , Project . MSG_DEBUG ) ; } long newestFile = file . lastModified ( ) ; task . log ( STRING + file + STRING + new Date ( newestFile ) , Project . MSG_DEBUG ) ; if ( newestFile != Long . MIN_VALUE && oldest != Long . MAX_VALUE && newestFile < oldest ) { task . log ( STRING + file + STRING ) ; iter . remove ( ) ; } } return files . size ( ) == _NUM ; }
public void closeFile ( boolean showCancel ) { if ( getCurrentIndex ( ) == - _NUM ) { return ; } if ( ! saveChanges ( showCancel ) ) { return ; } m_TabbedPane . removeTabAt ( getCurrentIndex ( ) ) ; updateFrameTitle ( ) ; System . gc ( ) ; }
public static void unregisterDeferral ( ProfileActivator pa ) { if ( ! deferring ) { return ; } if ( aVector == null ) { return ; } aVector . removeElement ( pa ) ; return ; }
public CAS process ( String text ) { CAS cas = retrieve ( ) ; cas . setDocumentText ( text ) ; try { analysisEngine . process ( cas ) ; } catch ( AnalysisEngineProcessException e ) { if ( text != null && ! text . isEmpty ( ) ) return process ( text ) ; throw new RuntimeException ( e ) ; } return cas ; }
public ProgramRewriter ( StatementBlockRewriteRule rewrite ) { _dagRuleSet = new ArrayList < HopRewriteRule > ( ) ; _sbRuleSet = new ArrayList < StatementBlockRewriteRule > ( ) ; _sbRuleSet . add ( rewrite ) ; }
public static String toSepList ( Iterator stringIter , String sep ) { StringBuilder sb = new StringBuilder ( ) ; if ( stringIter . hasNext ( ) ) { sb . append ( ( String ) stringIter . next ( ) ) ; } while ( stringIter . hasNext ( ) ) { sb . append ( sep ) ; sb . append ( ( String ) stringIter . next ( ) ) ; } return sb . toString ( ) ; }
public static String toSepList ( Iterator stringIter , String sep ) { StringBuilder sb = new StringBuilder ( ) ; if ( stringIter . hasNext ( ) ) { sb . append ( ( String ) stringIter . next ( ) ) ; } while ( stringIter . hasNext ( ) ) { sb . append ( sep ) ; sb . append ( ( String ) stringIter . next ( ) ) ; } return sb . toString ( ) ; }
public DNetscapeCertificateType ( JDialog parent , byte [ ] value ) throws IOException { super ( parent ) ; setTitle ( res . getString ( STRING ) ) ; initComponents ( ) ; prepopulateWithValue ( value ) ; }
public static IJavaSearchScope createRelatedProjectsScope ( IJavaProject project , int includeMask ) throws CoreException { IJavaProject [ ] projects = getRelatedProjects ( project ) ; return SearchEngine . createJavaSearchScope ( projects , includeMask ) ; }
public static IJavaSearchScope createRelatedProjectsScope ( IJavaProject project , int includeMask ) throws CoreException { IJavaProject [ ] projects = getRelatedProjects ( project ) ; return SearchEngine . createJavaSearchScope ( projects , includeMask ) ; }
public static IJavaSearchScope createRelatedProjectsScope ( IJavaProject project , int includeMask ) throws CoreException { IJavaProject [ ] projects = getRelatedProjects ( project ) ; return SearchEngine . createJavaSearchScope ( projects , includeMask ) ; }
protected void handleMatch ( T mapping , String lookupPath , ServerWebExchange exchange ) { }
public void addForeignKey ( int idx , ForeignKey foreignKey ) { if ( foreignKey != null ) { foreignKeys . add ( idx , foreignKey ) ; } }
public void addForeignKey ( int idx , ForeignKey foreignKey ) { if ( foreignKey != null ) { foreignKeys . add ( idx , foreignKey ) ; } }
private Node rotateRight ( Node x ) { Node y = x . left ; x . left = y . right ; y . right = x ; y . size = x . size ; x . size = _NUM + size ( x . left ) + size ( x . right ) ; x . height = _NUM + Math . max ( height ( x . left ) , height ( x . right ) ) ; y . height = _NUM + Math . max ( height ( y . left ) , height ( y . right ) ) ; return y ; }
public int compare ( File file1 , File file2 ) { String suffix1 = FilenameUtils . getExtension ( file1 . getName ( ) ) ; String suffix2 = FilenameUtils . getExtension ( file2 . getName ( ) ) ; return caseSensitivity . checkCompareTo ( suffix1 , suffix2 ) ; }
private void compactCriticals ( Mech mech ) { for ( int loc = _NUM ; loc < mech . locations ( ) ; loc ++ ) { compactCriticals ( mech , loc ) ; } }
private void compactCriticals ( Mech mech ) { for ( int loc = _NUM ; loc < mech . locations ( ) ; loc ++ ) { compactCriticals ( mech , loc ) ; } }
private void compactCriticals ( Mech mech ) { for ( int loc = _NUM ; loc < mech . locations ( ) ; loc ++ ) { compactCriticals ( mech , loc ) ; } }
private void compactCriticals ( Mech mech ) { for ( int loc = _NUM ; loc < mech . locations ( ) ; loc ++ ) { compactCriticals ( mech , loc ) ; } }
private void compactCriticals ( Mech mech ) { for ( int loc = _NUM ; loc < mech . locations ( ) ; loc ++ ) { compactCriticals ( mech , loc ) ; } }
private void compactCriticals ( Mech mech ) { for ( int loc = _NUM ; loc < mech . locations ( ) ; loc ++ ) { compactCriticals ( mech , loc ) ; } }
private void compactCriticals ( Mech mech ) { for ( int loc = _NUM ; loc < mech . locations ( ) ; loc ++ ) { compactCriticals ( mech , loc ) ; } }
public int numberOfShardsWithState ( ShardRoutingState ... states ) { int count = _NUM ; for ( ShardRouting shardEntry : this ) { for ( ShardRoutingState state : states ) { if ( shardEntry . state ( ) == state ) { count ++ ; } } } return count ; }
protected boolean isSideChannelActive ( ) { return System . getenv ( SIDECHANNEL_AUTH_ENV_NAME ) != null ; }
protected boolean isSideChannelActive ( ) { return System . getenv ( SIDECHANNEL_AUTH_ENV_NAME ) != null ; }
protected boolean isSideChannelActive ( ) { return System . getenv ( SIDECHANNEL_AUTH_ENV_NAME ) != null ; }
protected boolean isSideChannelActive ( ) { return System . getenv ( SIDECHANNEL_AUTH_ENV_NAME ) != null ; }
protected boolean isSideChannelActive ( ) { return System . getenv ( SIDECHANNEL_AUTH_ENV_NAME ) != null ; }
public void testSerialization ( ) throws IOException , ClassNotFoundException { final IHAWriteMessage msg1 = new HAWriteMessage ( UUID . randomUUID ( ) , _NUM , _NUM , _NUM , _NUM , _NUM , StoreTypeEnum . RW , _NUM , _NUM , _NUM ) ; final byte [ ] ser1 = serialized ( msg1 ) ; final IHAWriteMessage msg2 = ( IHAWriteMessage ) SerializerUtil . deserialize ( ser1 ) ; assertTrue ( msg1 . equals ( msg2 ) ) ; final byte [ ] ser2 = serialized ( msg2 ) ; assertTrue ( BytesUtil . bytesEqual ( ser1 , ser2 ) ) ; }
public static boolean isZoningRequired ( DbClient dbClient , URI varrayUri ) { if ( varrayUri != null ) { VirtualArray nh = dbClient . queryObject ( VirtualArray . class , varrayUri ) ; if ( nh != null ) { return isZoningRequired ( dbClient , nh ) ; } } return _BOOL ; }
public static void addAttributeDefaultValues ( String serviceName , String subSchemaName , String schemaType , String attributeName , Set defaultValues ) throws UpgradeException { String classMethod = STRING ; if ( debug . messageEnabled ( ) ) { debug . message ( classMethod + STRING ) ; debug . message ( STRING + serviceName + STRING + attributeName ) ; } ServiceSchema ss = getServiceSchema ( serviceName , subSchemaName , schemaType ) ; try { Map attributeDefaults = ss . getAttributeDefaults ( ) ; Set oldAttrValues = ( Set ) attributeDefaults . get ( attributeName ) ; Set newAttrValues = ( ( oldAttrValues == null ) || oldAttrValues . isEmpty ( ) ) ? new HashSet ( ) : new HashSet ( oldAttrValues ) ; newAttrValues . addAll ( defaultValues ) ; ss . setAttributeDefaults ( attributeName , newAttrValues ) ; } catch ( SSOException ssoe ) { throw new UpgradeException ( STRING ) ; } catch ( SMSException sme ) { throw new UpgradeException ( STRING + STRING ) ; } }
public static String createResourceName ( String resource , Locale locale , boolean removeExtension ) { String resourceName = resource ; if ( removeExtension ) { if ( resourceName . endsWith ( STRING ) ) { resourceName = resourceName . replace ( STRING , STRING ) ; } else if ( resourceName . endsWith ( STRING ) ) { resourceName = resourceName . replace ( STRING , STRING ) ; } } if ( locale != null ) { if ( UtilValidate . isNotEmpty ( locale . toString ( ) ) ) { resourceName = resourceName + STRING + locale ; } } return resourceName ; }
private void removeFromMyPlanUI ( int position ) { offers . remove ( position ) ; notifyBinderItemRemoved ( position ) ; notifyBinderItemRangeChanged ( position , _NUM ) ; }
public static Map < String , String > jsonToMap ( String jsonString ) { Map < String , String > jsonMap = new TreeMap < String , String > ( ) ; try { GfJsonObject jsonObject = new GfJsonObject ( jsonString ) ; Iterator < String > keys = jsonObject . keys ( ) ; while ( keys . hasNext ( ) ) { String key = keys . next ( ) ; jsonMap . put ( key , jsonObject . getString ( key ) ) ; } } catch ( GfJsonException e ) { throw new IllegalArgumentException ( STRING + jsonString + STRING ) ; } return jsonMap ; }
public static Map < String , String > jsonToMap ( String jsonString ) { Map < String , String > jsonMap = new TreeMap < String , String > ( ) ; try { GfJsonObject jsonObject = new GfJsonObject ( jsonString ) ; Iterator < String > keys = jsonObject . keys ( ) ; while ( keys . hasNext ( ) ) { String key = keys . next ( ) ; jsonMap . put ( key , jsonObject . getString ( key ) ) ; } } catch ( GfJsonException e ) { throw new IllegalArgumentException ( STRING + jsonString + STRING ) ; } return jsonMap ; }
public static Map < String , String > jsonToMap ( String jsonString ) { Map < String , String > jsonMap = new TreeMap < String , String > ( ) ; try { GfJsonObject jsonObject = new GfJsonObject ( jsonString ) ; Iterator < String > keys = jsonObject . keys ( ) ; while ( keys . hasNext ( ) ) { String key = keys . next ( ) ; jsonMap . put ( key , jsonObject . getString ( key ) ) ; } } catch ( GfJsonException e ) { throw new IllegalArgumentException ( STRING + jsonString + STRING ) ; } return jsonMap ; }
public static Map < String , String > jsonToMap ( String jsonString ) { Map < String , String > jsonMap = new TreeMap < String , String > ( ) ; try { GfJsonObject jsonObject = new GfJsonObject ( jsonString ) ; Iterator < String > keys = jsonObject . keys ( ) ; while ( keys . hasNext ( ) ) { String key = keys . next ( ) ; jsonMap . put ( key , jsonObject . getString ( key ) ) ; } } catch ( GfJsonException e ) { throw new IllegalArgumentException ( STRING + jsonString + STRING ) ; } return jsonMap ; }
public void destroy ( ) { config = null ; }
BigInteger add ( long val ) { if ( val == _NUM ) return this ; if ( signum == _NUM ) return valueOf ( val ) ; if ( Long . signum ( val ) == signum ) return new BigInteger ( add ( mag , Math . abs ( val ) ) , signum ) ; int cmp = compareMagnitude ( val ) ; if ( cmp == _NUM ) return ZERO ; int [ ] resultMag = ( cmp > _NUM ? subtract ( mag , Math . abs ( val ) ) : subtract ( Math . abs ( val ) , mag ) ) ; resultMag = trustedStripLeadingZeroInts ( resultMag ) ; return new BigInteger ( resultMag , cmp == signum ? _NUM : - _NUM ) ; }
BigInteger add ( long val ) { if ( val == _NUM ) return this ; if ( signum == _NUM ) return valueOf ( val ) ; if ( Long . signum ( val ) == signum ) return new BigInteger ( add ( mag , Math . abs ( val ) ) , signum ) ; int cmp = compareMagnitude ( val ) ; if ( cmp == _NUM ) return ZERO ; int [ ] resultMag = ( cmp > _NUM ? subtract ( mag , Math . abs ( val ) ) : subtract ( Math . abs ( val ) , mag ) ) ; resultMag = trustedStripLeadingZeroInts ( resultMag ) ; return new BigInteger ( resultMag , cmp == signum ? _NUM : - _NUM ) ; }
public DataFile createDataFile ( ) { DataFile dataFile = new DataFile ( ) ; dataFileList . add ( dataFile ) ; return dataFile ; }
public static ExecutorService createBackgroundExecutor ( ) { final ExecutorService executor = Executors . newSingleThreadExecutor ( new DaemonThreadFactory ( DEFAULT_BACKGROUND_EXECUTOR_NAME ) ) ; BACKGROUND_EXECUTORS . add ( executor ) ; return executor ; }
public static ExecutorService createBackgroundExecutor ( ) { final ExecutorService executor = Executors . newSingleThreadExecutor ( new DaemonThreadFactory ( DEFAULT_BACKGROUND_EXECUTOR_NAME ) ) ; BACKGROUND_EXECUTORS . add ( executor ) ; return executor ; }
public static ExecutorService createBackgroundExecutor ( ) { final ExecutorService executor = Executors . newSingleThreadExecutor ( new DaemonThreadFactory ( DEFAULT_BACKGROUND_EXECUTOR_NAME ) ) ; BACKGROUND_EXECUTORS . add ( executor ) ; return executor ; }
public ClosureStats assertAll ( final TempTripleStore tempStore ) { return assertAll ( tempStore , null ) ; }
public ClosureStats assertAll ( final TempTripleStore tempStore ) { return assertAll ( tempStore , null ) ; }
public ClosureStats assertAll ( final TempTripleStore tempStore ) { return assertAll ( tempStore , null ) ; }
public ClosureStats assertAll ( final TempTripleStore tempStore ) { return assertAll ( tempStore , null ) ; }
public ClosureStats assertAll ( final TempTripleStore tempStore ) { return assertAll ( tempStore , null ) ; }
public LogCursorManager ( ) throws ReplicatorException { nextTimeoutCheck = lastTimeoutCheck + timeoutMillis ; }
protected VisorCache initHistory ( VisorCache c ) { if ( c != null ) { c . name = name ; c . mode = mode ; c . memorySize = memorySize ; c . indexesSize = indexesSize ; c . size = size ; c . nearSize = nearSize ; c . dhtSize = dhtSize ; c . primarySize = primarySize ; c . offHeapAllocatedSize = offHeapAllocatedSize ; c . offHeapEntriesCnt = offHeapEntriesCnt ; c . swapSize = swapSize ; c . swapKeys = swapKeys ; c . partitions = partitions ; c . primaryPartitions = Collections . emptyList ( ) ; c . backupPartitions = Collections . emptyList ( ) ; c . metrics = metrics ; } return c ; }
public final boolean isSupported ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean isSupported ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean isSupported ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public void testConstructorBytesPositive1 ( ) { byte aBytes [ ] = { _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM } ; byte rBytes [ ] = { _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM } ; BigInteger aNumber = new BigInteger ( aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , aNumber . signum ( ) ) ; }
public void testConstructorBytesPositive1 ( ) { byte aBytes [ ] = { _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM } ; byte rBytes [ ] = { _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM } ; BigInteger aNumber = new BigInteger ( aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , aNumber . signum ( ) ) ; }
public void testConstructorBytesPositive1 ( ) { byte aBytes [ ] = { _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM } ; byte rBytes [ ] = { _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM } ; BigInteger aNumber = new BigInteger ( aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , aNumber . signum ( ) ) ; }
public boolean isOpen ( ) { if ( secureChannelId == - _NUM ) return _BOOL ; long expireTime = ( ( long ) ( tokenLifetime * _NUM ) ) + tokenIssueTime ; long currentTime = System . currentTimeMillis ( ) ; return expireTime > currentTime ; }
static public SourcePosition findSourcePosition ( File javaFile , int lineNumber , int columnNumber ) throws IOException { String [ ] lines = new String [ _NUM ] ; int currentLineNumber = _NUM ; try ( BufferedReader br = new BufferedReader ( new FileReader ( javaFile ) ) ) { for ( String line ; ( line = br . readLine ( ) ) != null ; ) { lines [ _NUM ] = lines [ _NUM ] ; lines [ _NUM ] = lines [ _NUM ] ; lines [ _NUM ] = line ; if ( lineNumber == currentLineNumber ) { break ; } currentLineNumber ++ ; } } if ( lineNumber != currentLineNumber ) { return null ; } SourcePosition pos0 = findSourcePositionInComment ( lines [ _NUM ] ) ; if ( pos0 != null ) { return pos0 ; } SourcePosition pos1 = findSourcePositionInComment ( lines [ _NUM ] ) ; return pos1 ; }
public void forwardReference ( TraceLocal trace ) { if ( cleared ) return ; Clock . stop ( ) ; Trace . trace ( Item . REFERENCES , STRING , System . identityHashCode ( this ) , semantics , ObjectModel . getString ( ref ) ) ; Clock . start ( ) ; processReference ( trace ) ; }
public void forwardReference ( TraceLocal trace ) { if ( cleared ) return ; Clock . stop ( ) ; Trace . trace ( Item . REFERENCES , STRING , System . identityHashCode ( this ) , semantics , ObjectModel . getString ( ref ) ) ; Clock . start ( ) ; processReference ( trace ) ; }
public void forwardReference ( TraceLocal trace ) { if ( cleared ) return ; Clock . stop ( ) ; Trace . trace ( Item . REFERENCES , STRING , System . identityHashCode ( this ) , semantics , ObjectModel . getString ( ref ) ) ; Clock . start ( ) ; processReference ( trace ) ; }
public void forwardReference ( TraceLocal trace ) { if ( cleared ) return ; Clock . stop ( ) ; Trace . trace ( Item . REFERENCES , STRING , System . identityHashCode ( this ) , semantics , ObjectModel . getString ( ref ) ) ; Clock . start ( ) ; processReference ( trace ) ; }
public void forwardReference ( TraceLocal trace ) { if ( cleared ) return ; Clock . stop ( ) ; Trace . trace ( Item . REFERENCES , STRING , System . identityHashCode ( this ) , semantics , ObjectModel . getString ( ref ) ) ; Clock . start ( ) ; processReference ( trace ) ; }
public static int parseTime ( String input ) { Scanner scanner = new Scanner ( input . trim ( ) ) ; scanner . useLocale ( Locale . ENGLISH ) ; int time ; if ( input . contains ( STRING ) ) { scanner . useDelimiter ( STRING ) ; if ( ! scanner . hasNextLong ( ) ) { return _NUM ; } long minutes = scanner . nextLong ( ) ; if ( minutes < _NUM ) { return _NUM ; } if ( ! scanner . hasNextDouble ( ) ) { return _NUM ; } double seconds = scanner . nextDouble ( ) ; if ( seconds < _NUM || seconds >= _NUM ) { return _NUM ; } time = ( int ) ( _NUM * minutes + _NUM * seconds ) ; } else { if ( ! scanner . hasNextDouble ( ) ) { return _NUM ; } double seconds = scanner . nextDouble ( ) ; if ( seconds < _NUM ) { return _NUM ; } time = ( int ) ( _NUM * seconds ) ; } return _NUM * ( ( time + _NUM ) / _NUM ) ; }
public static Result failure ( String messageKey , Object ... args ) { return new Result ( Type . FAILURE , Collections . singleton ( new DiagMessage ( messageKey , args ) ) ) ; }
public static List findDirEdgesInRing ( PolygonizeDirectedEdge startDE ) { PolygonizeDirectedEdge de = startDE ; List edges = new ArrayList ( ) ; do { edges . add ( de ) ; de = de . getNext ( ) ; Assert . isTrue ( de != null , STRING ) ; Assert . isTrue ( de == startDE || ! de . isInRing ( ) , STRING ) ; } while ( de != startDE ) ; return edges ; }
public static List findDirEdgesInRing ( PolygonizeDirectedEdge startDE ) { PolygonizeDirectedEdge de = startDE ; List edges = new ArrayList ( ) ; do { edges . add ( de ) ; de = de . getNext ( ) ; Assert . isTrue ( de != null , STRING ) ; Assert . isTrue ( de == startDE || ! de . isInRing ( ) , STRING ) ; } while ( de != startDE ) ; return edges ; }
public static Set < JComponent > allComponents ( JComponent parent ) { Set < JComponent > result = new HashSet < > ( ) ; Deque < JComponent > queue = new LinkedList < > ( ) ; queue . add ( parent ) ; while ( ! queue . isEmpty ( ) ) { JComponent c = queue . removeFirst ( ) ; result . add ( c ) ; for ( Component c0 : c . getComponents ( ) ) { if ( c0 instanceof JComponent ) { queue . add ( ( JComponent ) c0 ) ; } } } result . remove ( parent ) ; return result ; }
public static Set < JComponent > allComponents ( JComponent parent ) { Set < JComponent > result = new HashSet < > ( ) ; Deque < JComponent > queue = new LinkedList < > ( ) ; queue . add ( parent ) ; while ( ! queue . isEmpty ( ) ) { JComponent c = queue . removeFirst ( ) ; result . add ( c ) ; for ( Component c0 : c . getComponents ( ) ) { if ( c0 instanceof JComponent ) { queue . add ( ( JComponent ) c0 ) ; } } } result . remove ( parent ) ; return result ; }
public void addRecognizedProperties ( String [ ] propertyIds ) { int propertyIdsCount = propertyIds != null ? propertyIds . length : _NUM ; for ( int i = _NUM ; i < propertyIdsCount ; i ++ ) { String propertyId = propertyIds [ i ] ; if ( ! fRecognizedProperties . contains ( propertyId ) ) { fRecognizedProperties . add ( propertyId ) ; } } }
public void addRecognizedProperties ( String [ ] propertyIds ) { int propertyIdsCount = propertyIds != null ? propertyIds . length : _NUM ; for ( int i = _NUM ; i < propertyIdsCount ; i ++ ) { String propertyId = propertyIds [ i ] ; if ( ! fRecognizedProperties . contains ( propertyId ) ) { fRecognizedProperties . add ( propertyId ) ; } } }
public void addRecognizedProperties ( String [ ] propertyIds ) { int propertyIdsCount = propertyIds != null ? propertyIds . length : _NUM ; for ( int i = _NUM ; i < propertyIdsCount ; i ++ ) { String propertyId = propertyIds [ i ] ; if ( ! fRecognizedProperties . contains ( propertyId ) ) { fRecognizedProperties . add ( propertyId ) ; } } }
public static String trimLeadingTabsAndSpaces ( String line ) { int size = line . length ( ) ; int start = size ; for ( int i = _NUM ; i < size ; i ++ ) { char c = line . charAt ( i ) ; if ( ! IndentManipulation . isIndentChar ( c ) ) { start = i ; break ; } } if ( start == _NUM ) return line ; else if ( start == size ) return STRING ; else return line . substring ( start ) ; }
public Preceding ( int end ) { super ( _NUM , end ) ; }
public Preceding ( int end ) { super ( _NUM , end ) ; }
public Preceding ( int end ) { super ( _NUM , end ) ; }
public void testIsParityAdjusted ( ) { try { DESKeySpec . isParityAdjusted ( null , _NUM ) ; fail ( STRING + STRING ) ; } catch ( NullPointerException e ) { fail ( STRING ) ; } catch ( InvalidKeyException e ) { } byte [ ] key = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; try { DESKeySpec . isParityAdjusted ( key , _NUM ) ; fail ( STRING + STRING ) ; } catch ( NullPointerException e ) { fail ( STRING ) ; } catch ( InvalidKeyException e ) { } byte [ ] key_not_pa = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; try { assertFalse ( STRING , DESKeySpec . isParityAdjusted ( key_not_pa , _NUM ) ) ; } catch ( NullPointerException e ) { fail ( STRING ) ; } catch ( InvalidKeyException e ) { fail ( STRING ) ; } byte [ ] key_pa = { ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM } ; try { assertTrue ( STRING , DESKeySpec . isParityAdjusted ( key_pa , _NUM ) ) ; } catch ( NullPointerException e ) { fail ( STRING ) ; } catch ( InvalidKeyException e ) { fail ( STRING ) ; } }
public void testIsParityAdjusted ( ) { try { DESKeySpec . isParityAdjusted ( null , _NUM ) ; fail ( STRING + STRING ) ; } catch ( NullPointerException e ) { fail ( STRING ) ; } catch ( InvalidKeyException e ) { } byte [ ] key = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; try { DESKeySpec . isParityAdjusted ( key , _NUM ) ; fail ( STRING + STRING ) ; } catch ( NullPointerException e ) { fail ( STRING ) ; } catch ( InvalidKeyException e ) { } byte [ ] key_not_pa = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; try { assertFalse ( STRING , DESKeySpec . isParityAdjusted ( key_not_pa , _NUM ) ) ; } catch ( NullPointerException e ) { fail ( STRING ) ; } catch ( InvalidKeyException e ) { fail ( STRING ) ; } byte [ ] key_pa = { ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM } ; try { assertTrue ( STRING , DESKeySpec . isParityAdjusted ( key_pa , _NUM ) ) ; } catch ( NullPointerException e ) { fail ( STRING ) ; } catch ( InvalidKeyException e ) { fail ( STRING ) ; } }
public void testIsParityAdjusted ( ) { try { DESKeySpec . isParityAdjusted ( null , _NUM ) ; fail ( STRING + STRING ) ; } catch ( NullPointerException e ) { fail ( STRING ) ; } catch ( InvalidKeyException e ) { } byte [ ] key = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; try { DESKeySpec . isParityAdjusted ( key , _NUM ) ; fail ( STRING + STRING ) ; } catch ( NullPointerException e ) { fail ( STRING ) ; } catch ( InvalidKeyException e ) { } byte [ ] key_not_pa = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; try { assertFalse ( STRING , DESKeySpec . isParityAdjusted ( key_not_pa , _NUM ) ) ; } catch ( NullPointerException e ) { fail ( STRING ) ; } catch ( InvalidKeyException e ) { fail ( STRING ) ; } byte [ ] key_pa = { ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM , ( byte ) _NUM } ; try { assertTrue ( STRING , DESKeySpec . isParityAdjusted ( key_pa , _NUM ) ) ; } catch ( NullPointerException e ) { fail ( STRING ) ; } catch ( InvalidKeyException e ) { fail ( STRING ) ; } }
public IgfsStringDelimiterRecordResolver ( String ... delims ) { super ( toBytes ( Charset . defaultCharset ( ) , delims ) ) ; }
protected void CreateFDArray ( OffsetItem fdarrayRef , OffsetItem privateRef , int Font ) { OutputList . addLast ( new MarkerItem ( fdarrayRef ) ) ; BuildIndexHeader ( _NUM , _NUM , _NUM ) ; OffsetItem privateIndex1Ref = new IndexOffsetItem ( _NUM ) ; OutputList . addLast ( privateIndex1Ref ) ; IndexBaseItem privateBase = new IndexBaseItem ( ) ; OutputList . addLast ( privateBase ) ; int NewSize = fonts [ Font ] . privateLength ; int OrgSubrsOffsetSize = CalcSubrOffsetSize ( fonts [ Font ] . privateOffset , fonts [ Font ] . privateLength ) ; if ( OrgSubrsOffsetSize != _NUM ) NewSize += _NUM - OrgSubrsOffsetSize ; OutputList . addLast ( new DictNumberItem ( NewSize ) ) ; OutputList . addLast ( privateRef ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( new IndexMarkerItem ( privateIndex1Ref , privateBase ) ) ; }
protected void CreateFDArray ( OffsetItem fdarrayRef , OffsetItem privateRef , int Font ) { OutputList . addLast ( new MarkerItem ( fdarrayRef ) ) ; BuildIndexHeader ( _NUM , _NUM , _NUM ) ; OffsetItem privateIndex1Ref = new IndexOffsetItem ( _NUM ) ; OutputList . addLast ( privateIndex1Ref ) ; IndexBaseItem privateBase = new IndexBaseItem ( ) ; OutputList . addLast ( privateBase ) ; int NewSize = fonts [ Font ] . privateLength ; int OrgSubrsOffsetSize = CalcSubrOffsetSize ( fonts [ Font ] . privateOffset , fonts [ Font ] . privateLength ) ; if ( OrgSubrsOffsetSize != _NUM ) NewSize += _NUM - OrgSubrsOffsetSize ; OutputList . addLast ( new DictNumberItem ( NewSize ) ) ; OutputList . addLast ( privateRef ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( new IndexMarkerItem ( privateIndex1Ref , privateBase ) ) ; }
protected void CreateFDArray ( OffsetItem fdarrayRef , OffsetItem privateRef , int Font ) { OutputList . addLast ( new MarkerItem ( fdarrayRef ) ) ; BuildIndexHeader ( _NUM , _NUM , _NUM ) ; OffsetItem privateIndex1Ref = new IndexOffsetItem ( _NUM ) ; OutputList . addLast ( privateIndex1Ref ) ; IndexBaseItem privateBase = new IndexBaseItem ( ) ; OutputList . addLast ( privateBase ) ; int NewSize = fonts [ Font ] . privateLength ; int OrgSubrsOffsetSize = CalcSubrOffsetSize ( fonts [ Font ] . privateOffset , fonts [ Font ] . privateLength ) ; if ( OrgSubrsOffsetSize != _NUM ) NewSize += _NUM - OrgSubrsOffsetSize ; OutputList . addLast ( new DictNumberItem ( NewSize ) ) ; OutputList . addLast ( privateRef ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( new IndexMarkerItem ( privateIndex1Ref , privateBase ) ) ; }
protected void CreateFDArray ( OffsetItem fdarrayRef , OffsetItem privateRef , int Font ) { OutputList . addLast ( new MarkerItem ( fdarrayRef ) ) ; BuildIndexHeader ( _NUM , _NUM , _NUM ) ; OffsetItem privateIndex1Ref = new IndexOffsetItem ( _NUM ) ; OutputList . addLast ( privateIndex1Ref ) ; IndexBaseItem privateBase = new IndexBaseItem ( ) ; OutputList . addLast ( privateBase ) ; int NewSize = fonts [ Font ] . privateLength ; int OrgSubrsOffsetSize = CalcSubrOffsetSize ( fonts [ Font ] . privateOffset , fonts [ Font ] . privateLength ) ; if ( OrgSubrsOffsetSize != _NUM ) NewSize += _NUM - OrgSubrsOffsetSize ; OutputList . addLast ( new DictNumberItem ( NewSize ) ) ; OutputList . addLast ( privateRef ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( new IndexMarkerItem ( privateIndex1Ref , privateBase ) ) ; }
@ Override public void commit ( ) { if ( writeCache != null ) { synchronized ( this ) { flushWriteCache ( ) ; } } super . commit ( ) ; }
@ Override public void commit ( ) { if ( writeCache != null ) { synchronized ( this ) { flushWriteCache ( ) ; } } super . commit ( ) ; }
@ Override public void commit ( ) { if ( writeCache != null ) { synchronized ( this ) { flushWriteCache ( ) ; } } super . commit ( ) ; }
@ Override public void commit ( ) { if ( writeCache != null ) { synchronized ( this ) { flushWriteCache ( ) ; } } super . commit ( ) ; }
@ Override public void commit ( ) { if ( writeCache != null ) { synchronized ( this ) { flushWriteCache ( ) ; } } super . commit ( ) ; }
@ Override public void commit ( ) { if ( writeCache != null ) { synchronized ( this ) { flushWriteCache ( ) ; } } super . commit ( ) ; }
private static JFreeChart createChart ( ) { XYSeries series1 = new XYSeries ( STRING ) ; series1 . add ( _NUM , _NUM ) ; series1 . add ( _NUM , _NUM ) ; series1 . add ( _NUM , _NUM ) ; XYDataset dataset = new XYSeriesCollection ( series1 ) ; return ChartFactory . createTimeSeriesChart ( STRING , STRING , STRING , dataset , _BOOL , _BOOL , _BOOL ) ; }
@ Nullable public static < R > R wrapThreadLoader ( ClassLoader ldr , IgniteOutClosure < R > c ) { Thread curThread = Thread . currentThread ( ) ; ClassLoader ctxLdr = curThread . getContextClassLoader ( ) ; try { curThread . setContextClassLoader ( ldr ) ; return c . apply ( ) ; } finally { curThread . setContextClassLoader ( ctxLdr ) ; } }
@ Nullable public static < R > R wrapThreadLoader ( ClassLoader ldr , IgniteOutClosure < R > c ) { Thread curThread = Thread . currentThread ( ) ; ClassLoader ctxLdr = curThread . getContextClassLoader ( ) ; try { curThread . setContextClassLoader ( ldr ) ; return c . apply ( ) ; } finally { curThread . setContextClassLoader ( ctxLdr ) ; } }
public static IP parseFromString ( String ip ) { String regex = STRING ; Pattern pattern = Pattern . compile ( regex ) ; Matcher m = pattern . matcher ( ip ) ; checkArgument ( m . find ( ) , STRING , regex ) ; int a = Integer . parseInt ( m . group ( _NUM ) ) ; int b = Integer . parseInt ( m . group ( _NUM ) ) ; int c = Integer . parseInt ( m . group ( _NUM ) ) ; int d = Integer . parseInt ( m . group ( _NUM ) ) ; return new IP ( a , b , c , d ) ; }
public static IP parseFromString ( String ip ) { String regex = STRING ; Pattern pattern = Pattern . compile ( regex ) ; Matcher m = pattern . matcher ( ip ) ; checkArgument ( m . find ( ) , STRING , regex ) ; int a = Integer . parseInt ( m . group ( _NUM ) ) ; int b = Integer . parseInt ( m . group ( _NUM ) ) ; int c = Integer . parseInt ( m . group ( _NUM ) ) ; int d = Integer . parseInt ( m . group ( _NUM ) ) ; return new IP ( a , b , c , d ) ; }
public static boolean isTableExists ( String tableName , SQLiteDatabase db ) { boolean exist ; try { exist = BaseUtility . containsIgnoreCases ( findAllTableNames ( db ) , tableName ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; exist = _BOOL ; } return exist ; }
public static boolean isTableExists ( String tableName , SQLiteDatabase db ) { boolean exist ; try { exist = BaseUtility . containsIgnoreCases ( findAllTableNames ( db ) , tableName ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; exist = _BOOL ; } return exist ; }
public static boolean isTableExists ( String tableName , SQLiteDatabase db ) { boolean exist ; try { exist = BaseUtility . containsIgnoreCases ( findAllTableNames ( db ) , tableName ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; exist = _BOOL ; } return exist ; }
static int deriveARGB ( Color color1 , Color color2 , float midPoint ) { int r = color1 . getRed ( ) + Math . round ( ( color2 . getRed ( ) - color1 . getRed ( ) ) * midPoint ) ; int g = color1 . getGreen ( ) + Math . round ( ( color2 . getGreen ( ) - color1 . getGreen ( ) ) * midPoint ) ; int b = color1 . getBlue ( ) + Math . round ( ( color2 . getBlue ( ) - color1 . getBlue ( ) ) * midPoint ) ; int a = color1 . getAlpha ( ) + Math . round ( ( color2 . getAlpha ( ) - color1 . getAlpha ( ) ) * midPoint ) ; return ( ( a & _NUM ) << _NUM ) | ( ( r & _NUM ) << _NUM ) | ( ( g & _NUM ) << _NUM ) | ( b & _NUM ) ; }
public void insertRecord ( int id , byte [ ] record ) throws IOException { if ( ! database . isOpen ( ) ) throw new IllegalStateException ( STRING ) ; if ( id < committedNextRowId ) { throw new IllegalStateException ( STRING + id + STRING + this ) ; } if ( id != lastTransactionInsertId + _NUM ) { throw new IllegalStateException ( STRING + lastTransactionInsertId + STRING + id ) ; } if ( record . length != recordSize ) { throw new IllegalStateException ( STRING + record . length + STRING + this ) ; } synchronized ( this ) { rwRaf . seek ( HEADER_SIZE + recordSize * id ) ; rwRaf . write ( record ) ; } lastTransactionInsertId = id ; }
public static void removeLoggingBehavior ( LoggingBehavior behavior ) { synchronized ( loggingBehaviors ) { loggingBehaviors . remove ( behavior ) ; } }
public static void removeLoggingBehavior ( LoggingBehavior behavior ) { synchronized ( loggingBehaviors ) { loggingBehaviors . remove ( behavior ) ; } }
public void deepFill ( MaryNode specTree ) { tree = specTree ; numberOfLeaves = _NUM ; sortNode ( _NUM , tree ) ; }
public void deepFill ( MaryNode specTree ) { tree = specTree ; numberOfLeaves = _NUM ; sortNode ( _NUM , tree ) ; }
public void replaceLineAt ( int pos , String newLines ) throws BadLocationException { Element e = getParagraphElement ( pos ) ; replace ( e . getStartOffset ( ) , getElementLength ( e ) , newLines , null ) ; }
public void replaceLineAt ( int pos , String newLines ) throws BadLocationException { Element e = getParagraphElement ( pos ) ; replace ( e . getStartOffset ( ) , getElementLength ( e ) , newLines , null ) ; }
public void replaceLineAt ( int pos , String newLines ) throws BadLocationException { Element e = getParagraphElement ( pos ) ; replace ( e . getStartOffset ( ) , getElementLength ( e ) , newLines , null ) ; }
protected void handleMesosFailure ( String taskId ) { int attempt = TaskUtils . getAttemptForTaskId ( taskId ) ; BaseContainer container = containersInfo . get ( TaskUtils . getContainerIndexForTaskId ( taskId ) ) ; boolean hasAttemptsLeft = attempt < container . retries ; if ( hasAttemptsLeft ) { LOG . warning ( String . format ( STRING , container . name , attempt + _NUM ) ) ; String newTaskId = TaskUtils . getTaskId ( container . name , attempt + _NUM ) ; scheduleNewTask ( newTaskId ) ; } else { LOG . severe ( STRING + attempt ) ; } }
public boolean contains ( String key ) { return myProperties . containsKey ( key ) ; }
public boolean contains ( String key ) { return myProperties . containsKey ( key ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
@ Override public List < byte [ ] > read ( long startOffset ) throws IOException { List < CarbonDictionaryColumnMetaChunk > carbonDictionaryColumnMetaChunks = readDictionaryMetadataFile ( ) ; CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk = carbonDictionaryColumnMetaChunks . get ( carbonDictionaryColumnMetaChunks . size ( ) - _NUM ) ; long endOffset = carbonDictionaryColumnMetaChunk . getEnd_offset ( ) ; return read ( carbonDictionaryColumnMetaChunks , startOffset , endOffset ) ; }
@ Override public List < byte [ ] > read ( long startOffset ) throws IOException { List < CarbonDictionaryColumnMetaChunk > carbonDictionaryColumnMetaChunks = readDictionaryMetadataFile ( ) ; CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk = carbonDictionaryColumnMetaChunks . get ( carbonDictionaryColumnMetaChunks . size ( ) - _NUM ) ; long endOffset = carbonDictionaryColumnMetaChunk . getEnd_offset ( ) ; return read ( carbonDictionaryColumnMetaChunks , startOffset , endOffset ) ; }
@ Override public List < byte [ ] > read ( long startOffset ) throws IOException { List < CarbonDictionaryColumnMetaChunk > carbonDictionaryColumnMetaChunks = readDictionaryMetadataFile ( ) ; CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk = carbonDictionaryColumnMetaChunks . get ( carbonDictionaryColumnMetaChunks . size ( ) - _NUM ) ; long endOffset = carbonDictionaryColumnMetaChunk . getEnd_offset ( ) ; return read ( carbonDictionaryColumnMetaChunks , startOffset , endOffset ) ; }
@ Override public List < byte [ ] > read ( long startOffset ) throws IOException { List < CarbonDictionaryColumnMetaChunk > carbonDictionaryColumnMetaChunks = readDictionaryMetadataFile ( ) ; CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk = carbonDictionaryColumnMetaChunks . get ( carbonDictionaryColumnMetaChunks . size ( ) - _NUM ) ; long endOffset = carbonDictionaryColumnMetaChunk . getEnd_offset ( ) ; return read ( carbonDictionaryColumnMetaChunks , startOffset , endOffset ) ; }
@ Override public List < byte [ ] > read ( long startOffset ) throws IOException { List < CarbonDictionaryColumnMetaChunk > carbonDictionaryColumnMetaChunks = readDictionaryMetadataFile ( ) ; CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk = carbonDictionaryColumnMetaChunks . get ( carbonDictionaryColumnMetaChunks . size ( ) - _NUM ) ; long endOffset = carbonDictionaryColumnMetaChunk . getEnd_offset ( ) ; return read ( carbonDictionaryColumnMetaChunks , startOffset , endOffset ) ; }
@ Override public List < byte [ ] > read ( long startOffset ) throws IOException { List < CarbonDictionaryColumnMetaChunk > carbonDictionaryColumnMetaChunks = readDictionaryMetadataFile ( ) ; CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk = carbonDictionaryColumnMetaChunks . get ( carbonDictionaryColumnMetaChunks . size ( ) - _NUM ) ; long endOffset = carbonDictionaryColumnMetaChunk . getEnd_offset ( ) ; return read ( carbonDictionaryColumnMetaChunks , startOffset , endOffset ) ; }
public void addSource ( ITLAPMOutputSource source ) { ITLAPMOutputSource existingSource = ( ITLAPMOutputSource ) sources . get ( source . getFullModulePath ( ) ) ; if ( existingSource != null ) { ITLAPMOutputSourceListener [ ] existingListeners = existingSource . getListeners ( ) ; for ( int i = _NUM ; i < existingListeners . length ; i ++ ) { source . addListener ( existingListeners [ i ] ) ; existingSource . removeListener ( existingListeners [ i ] ) ; } } else { List list = ( List ) listenerLists . get ( source . getFullModulePath ( ) ) ; if ( list != null ) { for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { source . addListener ( ( ITLAPMOutputSourceListener ) it . next ( ) ) ; it . remove ( ) ; } } } sources . put ( source . getFullModulePath ( ) , source ) ; }
public void addSource ( ITLAPMOutputSource source ) { ITLAPMOutputSource existingSource = ( ITLAPMOutputSource ) sources . get ( source . getFullModulePath ( ) ) ; if ( existingSource != null ) { ITLAPMOutputSourceListener [ ] existingListeners = existingSource . getListeners ( ) ; for ( int i = _NUM ; i < existingListeners . length ; i ++ ) { source . addListener ( existingListeners [ i ] ) ; existingSource . removeListener ( existingListeners [ i ] ) ; } } else { List list = ( List ) listenerLists . get ( source . getFullModulePath ( ) ) ; if ( list != null ) { for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { source . addListener ( ( ITLAPMOutputSourceListener ) it . next ( ) ) ; it . remove ( ) ; } } } sources . put ( source . getFullModulePath ( ) , source ) ; }
public void addSource ( ITLAPMOutputSource source ) { ITLAPMOutputSource existingSource = ( ITLAPMOutputSource ) sources . get ( source . getFullModulePath ( ) ) ; if ( existingSource != null ) { ITLAPMOutputSourceListener [ ] existingListeners = existingSource . getListeners ( ) ; for ( int i = _NUM ; i < existingListeners . length ; i ++ ) { source . addListener ( existingListeners [ i ] ) ; existingSource . removeListener ( existingListeners [ i ] ) ; } } else { List list = ( List ) listenerLists . get ( source . getFullModulePath ( ) ) ; if ( list != null ) { for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { source . addListener ( ( ITLAPMOutputSourceListener ) it . next ( ) ) ; it . remove ( ) ; } } } sources . put ( source . getFullModulePath ( ) , source ) ; }
public MSecurityManager ( ) { privilegedThreads = new CopyOnWriteArraySet < > ( ) ; privilegedThreads . add ( Thread . currentThread ( ) ) ; defaultManager = System . getSecurityManager ( ) ; executingTestCase = _BOOL ; privilegedThreadToIgnore = null ; unrecognizedPermissions = new CopyOnWriteArraySet < > ( ) ; filesToDelete = new CopyOnWriteArraySet < > ( ) ; }
public MSecurityManager ( ) { privilegedThreads = new CopyOnWriteArraySet < > ( ) ; privilegedThreads . add ( Thread . currentThread ( ) ) ; defaultManager = System . getSecurityManager ( ) ; executingTestCase = _BOOL ; privilegedThreadToIgnore = null ; unrecognizedPermissions = new CopyOnWriteArraySet < > ( ) ; filesToDelete = new CopyOnWriteArraySet < > ( ) ; }
public MSecurityManager ( ) { privilegedThreads = new CopyOnWriteArraySet < > ( ) ; privilegedThreads . add ( Thread . currentThread ( ) ) ; defaultManager = System . getSecurityManager ( ) ; executingTestCase = _BOOL ; privilegedThreadToIgnore = null ; unrecognizedPermissions = new CopyOnWriteArraySet < > ( ) ; filesToDelete = new CopyOnWriteArraySet < > ( ) ; }
protected Graphics createGraphics ( ImageFormatter formatter , int width , int height ) { java . awt . Graphics graphics = null ; if ( formatter == null ) { logger . warning ( STRING ) ; return null ; } graphics = formatter . getGraphics ( width , height , getTransparent ( ) ) ; if ( graphics == null ) { logger . warning ( STRING ) ; return null ; } if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STRING ) ; } if ( doAntiAliasing && graphics instanceof java . awt . Graphics2D ) { java . awt . Graphics2D g2d = ( java . awt . Graphics2D ) graphics ; g2d . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; } return graphics ; }
protected Graphics createGraphics ( ImageFormatter formatter , int width , int height ) { java . awt . Graphics graphics = null ; if ( formatter == null ) { logger . warning ( STRING ) ; return null ; } graphics = formatter . getGraphics ( width , height , getTransparent ( ) ) ; if ( graphics == null ) { logger . warning ( STRING ) ; return null ; } if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STRING ) ; } if ( doAntiAliasing && graphics instanceof java . awt . Graphics2D ) { java . awt . Graphics2D g2d = ( java . awt . Graphics2D ) graphics ; g2d . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; } return graphics ; }
public void remove ( T line ) { int idx = _list . indexOf ( line ) ; if ( idx != - _NUM ) remove ( idx ) ; }
public void remove ( T line ) { int idx = _list . indexOf ( line ) ; if ( idx != - _NUM ) remove ( idx ) ; }
public void remove ( T line ) { int idx = _list . indexOf ( line ) ; if ( idx != - _NUM ) remove ( idx ) ; }
public static Object initializeScalarHeader ( Address ptr , TIB tib , int size ) { Object ref = Magic . addressAsObject ( ptr . plus ( OBJECT_REF_OFFSET ) ) ; return ref ; }
public static boolean usesSecondOperand ( final Integer mnemonic ) { return ! mnemonic . equals ( ReilHelpers . _OPCODE_NOP ) && ! mnemonic . equals ( ReilHelpers . _OPCODE_BISZ ) && ! mnemonic . equals ( ReilHelpers . _OPCODE_STR ) && ! mnemonic . equals ( ReilHelpers . _OPCODE_STM ) && ! mnemonic . equals ( ReilHelpers . _OPCODE_LDM ) && ! mnemonic . equals ( ReilHelpers . _OPCODE_JCC ) ; }
private void addExposedTypes ( ParameterizedType type , Class < ? > cause ) { boolean alreadyDone = done ( type ) ; if ( ! pruned ( type ) ) { visit ( type ) ; recordExposure ( type , cause ) ; } if ( alreadyDone ) { return ; } logger . debug ( STRING , type . getRawType ( ) , type ) ; addExposedTypes ( type . getRawType ( ) , cause ) ; for ( Type typeArg : type . getActualTypeArguments ( ) ) { logger . debug ( STRING , typeArg , type ) ; addExposedTypes ( typeArg , cause ) ; } }
private void addExposedTypes ( ParameterizedType type , Class < ? > cause ) { boolean alreadyDone = done ( type ) ; if ( ! pruned ( type ) ) { visit ( type ) ; recordExposure ( type , cause ) ; } if ( alreadyDone ) { return ; } logger . debug ( STRING , type . getRawType ( ) , type ) ; addExposedTypes ( type . getRawType ( ) , cause ) ; for ( Type typeArg : type . getActualTypeArguments ( ) ) { logger . debug ( STRING , typeArg , type ) ; addExposedTypes ( typeArg , cause ) ; } }
private void addExposedTypes ( ParameterizedType type , Class < ? > cause ) { boolean alreadyDone = done ( type ) ; if ( ! pruned ( type ) ) { visit ( type ) ; recordExposure ( type , cause ) ; } if ( alreadyDone ) { return ; } logger . debug ( STRING , type . getRawType ( ) , type ) ; addExposedTypes ( type . getRawType ( ) , cause ) ; for ( Type typeArg : type . getActualTypeArguments ( ) ) { logger . debug ( STRING , typeArg , type ) ; addExposedTypes ( typeArg , cause ) ; } }
public void addProcessToReboot ( final String processName ) { processesToReboot . add ( processName ) ; }
public void addProcessToReboot ( final String processName ) { processesToReboot . add ( processName ) ; }
public static Class boxType ( Class primitiveType ) { Class c = ( Class ) wrapperMap . get ( primitiveType ) ; if ( c != null ) return c ; throw new InterpreterError ( STRING + primitiveType ) ; }
public static void increaseTime ( Clock clock ) { Calendar c = Calendar . getInstance ( ) ; c . setTime ( clock . getCurrentTime ( ) ) ; c . add ( Calendar . SECOND , _NUM ) ; clock . setCurrentTime ( c . getTime ( ) ) ; }
public static void increaseTime ( Clock clock ) { Calendar c = Calendar . getInstance ( ) ; c . setTime ( clock . getCurrentTime ( ) ) ; c . add ( Calendar . SECOND , _NUM ) ; clock . setCurrentTime ( c . getTime ( ) ) ; }
@ Override public boolean hasDispatchFunction ( ) { return _BOOL ; }
@ Override public boolean hasDispatchFunction ( ) { return _BOOL ; }
@ Override public boolean hasDispatchFunction ( ) { return _BOOL ; }
public void deleteObligation ( final Obligation obligation , int basicBlockId ) throws ObligationAcquiredOrReleasedInLoopException { Map < ObligationSet , State > updatedStateMap = new HashMap < ObligationSet , State > ( ) ; for ( Iterator < State > i = stateIterator ( ) ; i . hasNext ( ) ; ) { State state = i . next ( ) ; checkCircularity ( state , obligation , basicBlockId ) ; ObligationSet obligationSet = state . getObligationSet ( ) ; obligationSet . remove ( obligation ) ; if ( ! obligationSet . isEmpty ( ) ) { updatedStateMap . put ( obligationSet , state ) ; } } replaceMap ( updatedStateMap ) ; }
private List < String > findColumnsToRemove ( ) { String tableName = mTableModel . getTableName ( ) ; List < String > removeColumns = new ArrayList < String > ( ) ; List < ColumnModel > columnModelList = mTableModelDB . getColumnModels ( ) ; for ( ColumnModel columnModel : columnModelList ) { String dbColumnName = columnModel . getColumnName ( ) ; if ( isNeedToRemove ( dbColumnName ) ) { removeColumns . add ( dbColumnName ) ; } } LogUtil . d ( TAG , STRING + tableName + STRING + removeColumns ) ; return removeColumns ; }
private List < String > findColumnsToRemove ( ) { String tableName = mTableModel . getTableName ( ) ; List < String > removeColumns = new ArrayList < String > ( ) ; List < ColumnModel > columnModelList = mTableModelDB . getColumnModels ( ) ; for ( ColumnModel columnModel : columnModelList ) { String dbColumnName = columnModel . getColumnName ( ) ; if ( isNeedToRemove ( dbColumnName ) ) { removeColumns . add ( dbColumnName ) ; } } LogUtil . d ( TAG , STRING + tableName + STRING + removeColumns ) ; return removeColumns ; }
private List < String > findColumnsToRemove ( ) { String tableName = mTableModel . getTableName ( ) ; List < String > removeColumns = new ArrayList < String > ( ) ; List < ColumnModel > columnModelList = mTableModelDB . getColumnModels ( ) ; for ( ColumnModel columnModel : columnModelList ) { String dbColumnName = columnModel . getColumnName ( ) ; if ( isNeedToRemove ( dbColumnName ) ) { removeColumns . add ( dbColumnName ) ; } } LogUtil . d ( TAG , STRING + tableName + STRING + removeColumns ) ; return removeColumns ; }
private List < String > findColumnsToRemove ( ) { String tableName = mTableModel . getTableName ( ) ; List < String > removeColumns = new ArrayList < String > ( ) ; List < ColumnModel > columnModelList = mTableModelDB . getColumnModels ( ) ; for ( ColumnModel columnModel : columnModelList ) { String dbColumnName = columnModel . getColumnName ( ) ; if ( isNeedToRemove ( dbColumnName ) ) { removeColumns . add ( dbColumnName ) ; } } LogUtil . d ( TAG , STRING + tableName + STRING + removeColumns ) ; return removeColumns ; }
private List < String > findColumnsToRemove ( ) { String tableName = mTableModel . getTableName ( ) ; List < String > removeColumns = new ArrayList < String > ( ) ; List < ColumnModel > columnModelList = mTableModelDB . getColumnModels ( ) ; for ( ColumnModel columnModel : columnModelList ) { String dbColumnName = columnModel . getColumnName ( ) ; if ( isNeedToRemove ( dbColumnName ) ) { removeColumns . add ( dbColumnName ) ; } } LogUtil . d ( TAG , STRING + tableName + STRING + removeColumns ) ; return removeColumns ; }
private List < String > findColumnsToRemove ( ) { String tableName = mTableModel . getTableName ( ) ; List < String > removeColumns = new ArrayList < String > ( ) ; List < ColumnModel > columnModelList = mTableModelDB . getColumnModels ( ) ; for ( ColumnModel columnModel : columnModelList ) { String dbColumnName = columnModel . getColumnName ( ) ; if ( isNeedToRemove ( dbColumnName ) ) { removeColumns . add ( dbColumnName ) ; } } LogUtil . d ( TAG , STRING + tableName + STRING + removeColumns ) ; return removeColumns ; }
private List < String > findColumnsToRemove ( ) { String tableName = mTableModel . getTableName ( ) ; List < String > removeColumns = new ArrayList < String > ( ) ; List < ColumnModel > columnModelList = mTableModelDB . getColumnModels ( ) ; for ( ColumnModel columnModel : columnModelList ) { String dbColumnName = columnModel . getColumnName ( ) ; if ( isNeedToRemove ( dbColumnName ) ) { removeColumns . add ( dbColumnName ) ; } } LogUtil . d ( TAG , STRING + tableName + STRING + removeColumns ) ; return removeColumns ; }
private void handleIncomingInlineQuery ( InlineQuery inlineQuery ) { String query = inlineQuery . getQuery ( ) ; BotLogger . debug ( LOGTAG , STRING + query ) ; try { if ( ! query . isEmpty ( ) ) { List < RaeService . RaeResult > results = raeService . getResults ( query ) ; answerInlineQuery ( converteResultsToResponse ( inlineQuery , results ) ) ; } else { answerInlineQuery ( converteResultsToResponse ( inlineQuery , new ArrayList < > ( ) ) ) ; } } catch ( TelegramApiException e ) { BotLogger . error ( LOGTAG , e ) ; } }
private PlatformTarget createPlatformCache ( IgniteCacheProxy cache ) { return new PlatformCache ( platformCtx , cache , _BOOL , cacheExts ) ; }
public double calculateWeight ( int trooper ) { double weight = _NUM ; weight += getWeightStructure ( ) ; weight += getWeightArmor ( ) ; weight += getWeightMiscEquip ( trooper ) ; weight += getWeightWeapon ( trooper ) ; weight += getWeightAmmo ( trooper ) ; return Math . round ( weight * _NUM ) / _NUM ; }
public double calculateWeight ( int trooper ) { double weight = _NUM ; weight += getWeightStructure ( ) ; weight += getWeightArmor ( ) ; weight += getWeightMiscEquip ( trooper ) ; weight += getWeightWeapon ( trooper ) ; weight += getWeightAmmo ( trooper ) ; return Math . round ( weight * _NUM ) / _NUM ; }
public double calculateWeight ( int trooper ) { double weight = _NUM ; weight += getWeightStructure ( ) ; weight += getWeightArmor ( ) ; weight += getWeightMiscEquip ( trooper ) ; weight += getWeightWeapon ( trooper ) ; weight += getWeightAmmo ( trooper ) ; return Math . round ( weight * _NUM ) / _NUM ; }
public void test_sessionProtection ( ) { final Journal store = ( Journal ) getStore ( ) ; try { final RWStrategy bs = ( RWStrategy ) store . getBufferStrategy ( ) ; final RWStore rw = bs . getStore ( ) ; final byte [ ] buf = new byte [ _NUM ] ; r . nextBytes ( buf ) ; final ByteBuffer bb = ByteBuffer . wrap ( buf ) ; long faddr = bs . write ( bb ) ; IRawTx tx = rw . newTx ( ) ; bs . delete ( faddr ) ; bb . position ( _NUM ) ; final ByteBuffer rdBuf = bs . read ( faddr ) ; assertEquals ( bb , rdBuf ) ; tx . close ( ) ; store . commit ( ) ; } finally { store . destroy ( ) ; } }
public void test_sessionProtection ( ) { final Journal store = ( Journal ) getStore ( ) ; try { final RWStrategy bs = ( RWStrategy ) store . getBufferStrategy ( ) ; final RWStore rw = bs . getStore ( ) ; final byte [ ] buf = new byte [ _NUM ] ; r . nextBytes ( buf ) ; final ByteBuffer bb = ByteBuffer . wrap ( buf ) ; long faddr = bs . write ( bb ) ; IRawTx tx = rw . newTx ( ) ; bs . delete ( faddr ) ; bb . position ( _NUM ) ; final ByteBuffer rdBuf = bs . read ( faddr ) ; assertEquals ( bb , rdBuf ) ; tx . close ( ) ; store . commit ( ) ; } finally { store . destroy ( ) ; } }
public void test_sessionProtection ( ) { final Journal store = ( Journal ) getStore ( ) ; try { final RWStrategy bs = ( RWStrategy ) store . getBufferStrategy ( ) ; final RWStore rw = bs . getStore ( ) ; final byte [ ] buf = new byte [ _NUM ] ; r . nextBytes ( buf ) ; final ByteBuffer bb = ByteBuffer . wrap ( buf ) ; long faddr = bs . write ( bb ) ; IRawTx tx = rw . newTx ( ) ; bs . delete ( faddr ) ; bb . position ( _NUM ) ; final ByteBuffer rdBuf = bs . read ( faddr ) ; assertEquals ( bb , rdBuf ) ; tx . close ( ) ; store . commit ( ) ; } finally { store . destroy ( ) ; } }
public void test_sessionProtection ( ) { final Journal store = ( Journal ) getStore ( ) ; try { final RWStrategy bs = ( RWStrategy ) store . getBufferStrategy ( ) ; final RWStore rw = bs . getStore ( ) ; final byte [ ] buf = new byte [ _NUM ] ; r . nextBytes ( buf ) ; final ByteBuffer bb = ByteBuffer . wrap ( buf ) ; long faddr = bs . write ( bb ) ; IRawTx tx = rw . newTx ( ) ; bs . delete ( faddr ) ; bb . position ( _NUM ) ; final ByteBuffer rdBuf = bs . read ( faddr ) ; assertEquals ( bb , rdBuf ) ; tx . close ( ) ; store . commit ( ) ; } finally { store . destroy ( ) ; } }
public void test_sessionProtection ( ) { final Journal store = ( Journal ) getStore ( ) ; try { final RWStrategy bs = ( RWStrategy ) store . getBufferStrategy ( ) ; final RWStore rw = bs . getStore ( ) ; final byte [ ] buf = new byte [ _NUM ] ; r . nextBytes ( buf ) ; final ByteBuffer bb = ByteBuffer . wrap ( buf ) ; long faddr = bs . write ( bb ) ; IRawTx tx = rw . newTx ( ) ; bs . delete ( faddr ) ; bb . position ( _NUM ) ; final ByteBuffer rdBuf = bs . read ( faddr ) ; assertEquals ( bb , rdBuf ) ; tx . close ( ) ; store . commit ( ) ; } finally { store . destroy ( ) ; } }
@ Override public synchronized void removeInstanceListener ( InstanceListener dsl ) { m_listeners . remove ( dsl ) ; }
public void removeDocuments ( List < Query > queries ) { IndexWriter writer = getWriter ( ) ; for ( Query query : queries ) { try { writer . deleteDocuments ( query ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; closeWriter ( writer ) ; throw new RuntimeException ( e ) ; } } closeWriter ( writer ) ; }
boolean updateValueType ( Object value ) { if ( _valueTypeFinallySet || value == null ) return _valueTypeFinallySet ; Class < ? > type = value . getClass ( ) ; if ( _valueType == null ) { synchronized ( this ) { if ( _valueType == null ) _valueType = type ; } } else if ( _valueType != type && ! _valueType . isAssignableFrom ( type ) ) { synchronized ( this ) { _valueType = TypeDataIndex . getCommonSuperType ( type , _valueType ) ; } } if ( _valueType == Object . class ) _valueTypeFinallySet = _BOOL ; return _valueTypeFinallySet ; }
boolean updateValueType ( Object value ) { if ( _valueTypeFinallySet || value == null ) return _valueTypeFinallySet ; Class < ? > type = value . getClass ( ) ; if ( _valueType == null ) { synchronized ( this ) { if ( _valueType == null ) _valueType = type ; } } else if ( _valueType != type && ! _valueType . isAssignableFrom ( type ) ) { synchronized ( this ) { _valueType = TypeDataIndex . getCommonSuperType ( type , _valueType ) ; } } if ( _valueType == Object . class ) _valueTypeFinallySet = _BOOL ; return _valueTypeFinallySet ; }
protected final void serialize ( ObjectOutputStream oos , Collection coll ) throws IOException { int count = _NUM ; Object [ ] objects = coll . toArray ( ) ; for ( int i = _NUM ; i < objects . length ; i ++ ) { if ( objects [ i ] instanceof Serializable ) count ++ ; else objects [ i ] = null ; } oos . writeInt ( count ) ; for ( int i = _NUM ; count > _NUM ; i ++ ) { Object o = objects [ i ] ; if ( o != null ) { oos . writeObject ( o ) ; count -- ; } } }
protected final void serialize ( ObjectOutputStream oos , Collection coll ) throws IOException { int count = _NUM ; Object [ ] objects = coll . toArray ( ) ; for ( int i = _NUM ; i < objects . length ; i ++ ) { if ( objects [ i ] instanceof Serializable ) count ++ ; else objects [ i ] = null ; } oos . writeInt ( count ) ; for ( int i = _NUM ; count > _NUM ; i ++ ) { Object o = objects [ i ] ; if ( o != null ) { oos . writeObject ( o ) ; count -- ; } } }
protected void subscribeUnsubscribe ( String nameValue ) throws Throwable { URI observerUri = URI . create ( observerServiceUriForUnsubscribe ) ; waitForSubscriptionToAppear ( observerUri , EXAMPLES_SUBSCRIPTIONS ) ; verifyNotification ( nameValue , observerUri ) ; JsExecutor . executeSynchronously ( null ) ; waitForSubscriptionToDisappear ( observerUri , EXAMPLES_SUBSCRIPTIONS ) ; }
protected void subscribeUnsubscribe ( String nameValue ) throws Throwable { URI observerUri = URI . create ( observerServiceUriForUnsubscribe ) ; waitForSubscriptionToAppear ( observerUri , EXAMPLES_SUBSCRIPTIONS ) ; verifyNotification ( nameValue , observerUri ) ; JsExecutor . executeSynchronously ( null ) ; waitForSubscriptionToDisappear ( observerUri , EXAMPLES_SUBSCRIPTIONS ) ; }
protected void subscribeUnsubscribe ( String nameValue ) throws Throwable { URI observerUri = URI . create ( observerServiceUriForUnsubscribe ) ; waitForSubscriptionToAppear ( observerUri , EXAMPLES_SUBSCRIPTIONS ) ; verifyNotification ( nameValue , observerUri ) ; JsExecutor . executeSynchronously ( null ) ; waitForSubscriptionToDisappear ( observerUri , EXAMPLES_SUBSCRIPTIONS ) ; }
private int initialNumber ( String tform ) { int i ; for ( i = _NUM ; i < tform . length ( ) ; i ++ ) { if ( ! Character . isDigit ( tform . charAt ( i ) ) ) { break ; } } return Integer . parseInt ( tform . substring ( _NUM , i ) ) ; }
private int initialNumber ( String tform ) { int i ; for ( i = _NUM ; i < tform . length ( ) ; i ++ ) { if ( ! Character . isDigit ( tform . charAt ( i ) ) ) { break ; } } return Integer . parseInt ( tform . substring ( _NUM , i ) ) ; }
public Console format ( String format , Object ... args ) { Formatter f = new Formatter ( writer ) ; f . format ( format , args ) ; f . flush ( ) ; return this ; }
public Console format ( String format , Object ... args ) { Formatter f = new Formatter ( writer ) ; f . format ( format , args ) ; f . flush ( ) ; return this ; }
protected final void addExceptionHandler ( final ICommandExceptionHandler handler ) { exceptionHandlerList . add ( _NUM , handler ) ; }
protected final void addExceptionHandler ( final ICommandExceptionHandler handler ) { exceptionHandlerList . add ( _NUM , handler ) ; }
public static void insertThriftRenameTableLogEntry ( org . apache . hadoop . hive . metastore . api . Table oldTable , org . apache . hadoop . hive . metastore . api . Table newTable , HiveConf hiveConf ) throws Exception { final MetastoreAuditLogListener metastoreAuditLogListener = new MetastoreAuditLogListener ( hiveConf ) ; AlterTableEvent event = new AlterTableEvent ( oldTable , newTable , _BOOL , null ) ; metastoreAuditLogListener . onAlterTable ( event ) ; }
public static void insertThriftRenameTableLogEntry ( org . apache . hadoop . hive . metastore . api . Table oldTable , org . apache . hadoop . hive . metastore . api . Table newTable , HiveConf hiveConf ) throws Exception { final MetastoreAuditLogListener metastoreAuditLogListener = new MetastoreAuditLogListener ( hiveConf ) ; AlterTableEvent event = new AlterTableEvent ( oldTable , newTable , _BOOL , null ) ; metastoreAuditLogListener . onAlterTable ( event ) ; }
public static void insertThriftRenameTableLogEntry ( org . apache . hadoop . hive . metastore . api . Table oldTable , org . apache . hadoop . hive . metastore . api . Table newTable , HiveConf hiveConf ) throws Exception { final MetastoreAuditLogListener metastoreAuditLogListener = new MetastoreAuditLogListener ( hiveConf ) ; AlterTableEvent event = new AlterTableEvent ( oldTable , newTable , _BOOL , null ) ; metastoreAuditLogListener . onAlterTable ( event ) ; }
int generate ( byte [ ] output , boolean predictionResistant ) { if ( R . length == _NUM ) { if ( reseedCounter > BLOCK64_RESEED_MAX ) { return - _NUM ; } if ( isTooLarge ( output , BLOCK64_MAX_BITS_REQUEST / _NUM ) ) { throw new IllegalArgumentException ( STRING + BLOCK64_MAX_BITS_REQUEST ) ; } } else { if ( reseedCounter > BLOCK128_RESEED_MAX ) { return - _NUM ; } if ( isTooLarge ( output , BLOCK128_MAX_BITS_REQUEST / _NUM ) ) { throw new IllegalArgumentException ( STRING + BLOCK128_MAX_BITS_REQUEST ) ; } } if ( predictionResistant || V == null ) { V = entropySource . getEntropy ( ) ; } int m = output . length / R . length ; for ( int i = _NUM ; i < m ; i ++ ) { engine . processBlock ( DT , _NUM , I , _NUM ) ; process ( R , I , V ) ; process ( V , R , I ) ; System . arraycopy ( R , _NUM , output , i * R . length , R . length ) ; increment ( DT ) ; } int bytesToCopy = ( output . length - m * R . length ) ; if ( bytesToCopy > _NUM ) { engine . processBlock ( DT , _NUM , I , _NUM ) ; process ( R , I , V ) ; process ( V , R , I ) ; System . arraycopy ( R , _NUM , output , m * R . length , bytesToCopy ) ; increment ( DT ) ; } reseedCounter ++ ; return output . length ; }
public void dispose ( ) { if ( pingLabelsMap != null ) { pingLabelsMap . clear ( ) ; pingLabelsMap = null ; } if ( itemsManaged != null ) { itemsManaged . clear ( ) ; itemsManaged = null ; } if ( folders != null ) { folders = null ; } if ( sashes != null ) { sashes = null ; } }
public WritableRaster createCompatibleWritableRaster ( int w , int h ) { int [ ] bOffs = { _NUM , _NUM , _NUM } ; return Raster . createInterleavedRaster ( DataBuffer . TYPE_BYTE , w , h , w * _NUM , _NUM , bOffs , null ) ; }
public WritableRaster createCompatibleWritableRaster ( int w , int h ) { int [ ] bOffs = { _NUM , _NUM , _NUM } ; return Raster . createInterleavedRaster ( DataBuffer . TYPE_BYTE , w , h , w * _NUM , _NUM , bOffs , null ) ; }
public char abbreviation ( ) { return name . charAt ( _NUM ) ; }
public char abbreviation ( ) { return name . charAt ( _NUM ) ; }
public char abbreviation ( ) { return name . charAt ( _NUM ) ; }
@ Deprecated public static String join ( String delimiter , String ... parts ) { if ( delimiter == null ) { throw new IllegalArgumentException ( STRING ) ; } StringBuilder sb = new StringBuilder ( ) ; for ( String alias : parts ) { if ( sb . length ( ) != _NUM ) { sb . append ( delimiter ) ; } sb . append ( alias ) ; } return sb . toString ( ) ; }
@ Deprecated public static String join ( String delimiter , String ... parts ) { if ( delimiter == null ) { throw new IllegalArgumentException ( STRING ) ; } StringBuilder sb = new StringBuilder ( ) ; for ( String alias : parts ) { if ( sb . length ( ) != _NUM ) { sb . append ( delimiter ) ; } sb . append ( alias ) ; } return sb . toString ( ) ; }
@ Deprecated public static String join ( String delimiter , String ... parts ) { if ( delimiter == null ) { throw new IllegalArgumentException ( STRING ) ; } StringBuilder sb = new StringBuilder ( ) ; for ( String alias : parts ) { if ( sb . length ( ) != _NUM ) { sb . append ( delimiter ) ; } sb . append ( alias ) ; } return sb . toString ( ) ; }
@ Deprecated public static String join ( String delimiter , String ... parts ) { if ( delimiter == null ) { throw new IllegalArgumentException ( STRING ) ; } StringBuilder sb = new StringBuilder ( ) ; for ( String alias : parts ) { if ( sb . length ( ) != _NUM ) { sb . append ( delimiter ) ; } sb . append ( alias ) ; } return sb . toString ( ) ; }
public static final void fillCircleFromStartToEnd ( GL2 gl , double sx , double sy , double ex , double ey ) { double w = Math . abs ( sx - ex ) ; double h = Math . abs ( sy - ey ) ; RenderUtilities . fillCircleFromTopLeft ( gl , sx , sy , w , h ) ; }
public void addNotification ( @ NotNull Notification notification ) { notifications . add ( notification ) ; NotificationContainerItem item = new NotificationContainerItem ( notification , resources ) ; item . setDelegate ( this ) ; int index = nGrid . getRowCount ( ) ; nGrid . resizeRows ( index + _NUM ) ; nGrid . setWidget ( index , _NUM , item ) ; }
public void addNotification ( @ NotNull Notification notification ) { notifications . add ( notification ) ; NotificationContainerItem item = new NotificationContainerItem ( notification , resources ) ; item . setDelegate ( this ) ; int index = nGrid . getRowCount ( ) ; nGrid . resizeRows ( index + _NUM ) ; nGrid . setWidget ( index , _NUM , item ) ; }
private List < FileMatch > filterTargetMatchesWithoutSourceMatches ( List < FileMatch > sourceMatchCandidates , List < FileMatch > targetMatchCandidates ) { List < FileMatch > filteredTargetMatchCandidates = new ArrayList < > ( ) ; List < String > sourceFilenames = getSourceFilenames ( sourceMatchCandidates ) ; for ( FileMatch targetMatchCandidate : targetMatchCandidates ) { if ( sourceFilenames . contains ( targetMatchCandidate . getSourcePath ( ) ) ) { filteredTargetMatchCandidates . add ( targetMatchCandidate ) ; } } return filteredTargetMatchCandidates ; }
private List < FileMatch > filterTargetMatchesWithoutSourceMatches ( List < FileMatch > sourceMatchCandidates , List < FileMatch > targetMatchCandidates ) { List < FileMatch > filteredTargetMatchCandidates = new ArrayList < > ( ) ; List < String > sourceFilenames = getSourceFilenames ( sourceMatchCandidates ) ; for ( FileMatch targetMatchCandidate : targetMatchCandidates ) { if ( sourceFilenames . contains ( targetMatchCandidate . getSourcePath ( ) ) ) { filteredTargetMatchCandidates . add ( targetMatchCandidate ) ; } } return filteredTargetMatchCandidates ; }
public boolean implies ( Permission < ? > that ) { if ( category == null ) return _BOOL ; if ( ! category . isAssignableFrom ( that . category ) ) return _BOOL ; if ( action == null ) return _BOOL ; if ( ! action . equals ( that . action ) ) return _BOOL ; if ( instance == null ) return _BOOL ; if ( ! instance . equals ( that . instance ) ) return _BOOL ; return _BOOL ; }
private FPTree buildFPTree ( final Relation < BitVector > relation , int [ ] iidx , final int items ) { FPTree tree = new FPTree ( items ) ; FiniteProgress prog = LOG . isVerbose ( ) ? new FiniteProgress ( STRING , relation . size ( ) , LOG ) : null ; int [ ] buf = new int [ items ] ; for ( DBIDIter iditer = relation . iterDBIDs ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { int l = _NUM ; SparseFeatureVector < ? > bv = relation . get ( iditer ) ; for ( int it = bv . iter ( ) ; bv . iterValid ( it ) ; it = bv . iterAdvance ( it ) ) { int i = iidx [ bv . iterDim ( it ) ] ; if ( i < _NUM ) { continue ; } buf [ l ++ ] = i ; } if ( l >= minlength ) { Arrays . sort ( buf , _NUM , l ) ; tree . insert ( buf , _NUM , l , _NUM ) ; } LOG . incrementProcessed ( prog ) ; } LOG . ensureCompleted ( prog ) ; return tree ; }
private void adjustView ( ) { if ( ( dvx == _NUM ) && ( dvy == _NUM ) ) { return ; } final int sx = convertWorldXToScaledScreen ( x ) - getScreenViewX ( ) + SIZE_UNIT_PIXELS / _NUM ; final int sy = convertWorldYToScaledScreen ( y ) - getScreenViewY ( ) + SIZE_UNIT_PIXELS / _NUM ; if ( ( sx < _NUM ) || ( sx >= sw ) || ( sy < - SIZE_UNIT_PIXELS ) || ( sy > sh ) ) { center ( ) ; } else { calculatePanningSpeed ( ) ; if ( speed != _NUM ) { final int scalediv = ( Math . abs ( dvx ) + Math . abs ( dvy ) ) * PAN_SCALE ; int dx = speed * dvx / scalediv ; int dy = speed * dvy / scalediv ; if ( dvx < _NUM ) { dx = MathHelper . clamp ( dx , dvx , - _NUM ) ; } else if ( dvx > _NUM ) { dx = MathHelper . clamp ( dx , _NUM , dvx ) ; } if ( dvy < _NUM ) { dy = MathHelper . clamp ( dy , dvy , - _NUM ) ; } else if ( dvy > _NUM ) { dy = MathHelper . clamp ( dy , _NUM , dvy ) ; } svx += dx ; dvx -= dx ; svy += dy ; dvy -= dy ; } } }
private void adjustView ( ) { if ( ( dvx == _NUM ) && ( dvy == _NUM ) ) { return ; } final int sx = convertWorldXToScaledScreen ( x ) - getScreenViewX ( ) + SIZE_UNIT_PIXELS / _NUM ; final int sy = convertWorldYToScaledScreen ( y ) - getScreenViewY ( ) + SIZE_UNIT_PIXELS / _NUM ; if ( ( sx < _NUM ) || ( sx >= sw ) || ( sy < - SIZE_UNIT_PIXELS ) || ( sy > sh ) ) { center ( ) ; } else { calculatePanningSpeed ( ) ; if ( speed != _NUM ) { final int scalediv = ( Math . abs ( dvx ) + Math . abs ( dvy ) ) * PAN_SCALE ; int dx = speed * dvx / scalediv ; int dy = speed * dvy / scalediv ; if ( dvx < _NUM ) { dx = MathHelper . clamp ( dx , dvx , - _NUM ) ; } else if ( dvx > _NUM ) { dx = MathHelper . clamp ( dx , _NUM , dvx ) ; } if ( dvy < _NUM ) { dy = MathHelper . clamp ( dy , dvy , - _NUM ) ; } else if ( dvy > _NUM ) { dy = MathHelper . clamp ( dy , _NUM , dvy ) ; } svx += dx ; dvx -= dx ; svy += dy ; dvy -= dy ; } } }
public boolean equals ( Object obj ) { if ( this == obj ) return _BOOL ; if ( obj instanceof EllipticCurve ) { EllipticCurve curve = ( EllipticCurve ) obj ; if ( ( field . equals ( curve . field ) ) && ( a . equals ( curve . a ) ) && ( b . equals ( curve . b ) ) ) { return _BOOL ; } } return _BOOL ; }
public synchronized void unweave ( ByteString id ) { if ( woven . containsKey ( id ) ) { removed . add ( woven . remove ( id ) ) ; } }
public static String readString ( ByteBuffer buffer , int strLen ) { StringBuilder sb = new StringBuilder ( strLen ) ; for ( int i = _NUM ; i < strLen ; i ++ ) { sb . append ( buffer . getChar ( ) ) ; } return sb . toString ( ) ; }
public void remove ( boolean priority , Marker m ) { lock . lock ( ) ; sendEmptyMessage ( BLANK ) ; if ( priority ) { mOnScreenRemoveMarkerTasks . add ( m ) ; } else { mRemoveMarkerTasks . add ( m ) ; } lock . unlock ( ) ; }
public void remove ( boolean priority , Marker m ) { lock . lock ( ) ; sendEmptyMessage ( BLANK ) ; if ( priority ) { mOnScreenRemoveMarkerTasks . add ( m ) ; } else { mRemoveMarkerTasks . add ( m ) ; } lock . unlock ( ) ; }
public static String [ ] sortCopy ( String [ ] objects ) { int len = objects . length ; String [ ] copy = new String [ len ] ; System . arraycopy ( objects , _NUM , copy , _NUM , len ) ; sort ( copy ) ; return copy ; }
protected Message createResponseMessage ( ) { return new Message ( _NUM , Version . CURRENT ) ; }
protected Message createResponseMessage ( ) { return new Message ( _NUM , Version . CURRENT ) ; }
protected Message createResponseMessage ( ) { return new Message ( _NUM , Version . CURRENT ) ; }
public static < T > Set < T > synchronizedSet ( ) { return Collections . synchronizedSet ( new HashSet < T > ( ) ) ; }
private StringTextStore ( String text ) { super ( ) ; fText = text != null ? text : STRING ; fCopyLimit = fText . length ( ) > SMALL_TEXT_LIMIT ? fText . length ( ) / _NUM : _NUM ; }
public boolean isPrimitive ( Type type ) throws Exception { return isPrimitive ( type . getType ( ) ) ; }
public boolean isPrimitive ( Type type ) throws Exception { return isPrimitive ( type . getType ( ) ) ; }
public Random ( byte [ ] randomBytes ) { if ( randomBytes == null ) { throw new NullPointerException ( STRING ) ; } else if ( randomBytes . length != _NUM ) { throw new IllegalArgumentException ( STRING ) ; } else { this . randomBytes = Arrays . copyOf ( randomBytes , randomBytes . length ) ; } }
public byte [ ] encrypt ( byte [ ] data , byte [ ] key , byte [ ] ivec , int usage ) throws KrbCryptoException { if ( key . length > _NUM ) throw new KrbCryptoException ( STRING ) ; int new_size = data . length + confounderSize ( ) + checksumSize ( ) ; byte [ ] new_data ; byte pad ; if ( new_size % blockSize ( ) == _NUM ) { new_data = new byte [ new_size + blockSize ( ) ] ; pad = ( byte ) _NUM ; } else { new_data = new byte [ new_size + blockSize ( ) - new_size % blockSize ( ) ] ; pad = ( byte ) ( blockSize ( ) - new_size % blockSize ( ) ) ; } for ( int i = new_size ; i < new_data . length ; i ++ ) { new_data [ i ] = pad ; } byte [ ] conf = Confounder . bytes ( confounderSize ( ) ) ; System . arraycopy ( conf , _NUM , new_data , _NUM , confounderSize ( ) ) ; System . arraycopy ( data , _NUM , new_data , startOfData ( ) , data . length ) ; byte [ ] cksum = calculateChecksum ( new_data , new_data . length ) ; System . arraycopy ( cksum , _NUM , new_data , startOfChecksum ( ) , checksumSize ( ) ) ; byte [ ] cipher = new byte [ new_data . length ] ; Des . cbc_encrypt ( new_data , cipher , key , ivec , _BOOL ) ; return cipher ; }
private void updateStateView ( Metrics metrics ) { Platform . runLater ( null ) ; simPaneCtrl . waitAfterStep ( ) ; }
private void updateStateView ( Metrics metrics ) { Platform . runLater ( null ) ; simPaneCtrl . waitAfterStep ( ) ; }
public Object createSoftWeakRef ( Object o ) { return new WeakReference ( o ) ; }
public Object createSoftWeakRef ( Object o ) { return new WeakReference ( o ) ; }
public Object createSoftWeakRef ( Object o ) { return new WeakReference ( o ) ; }
public Object createSoftWeakRef ( Object o ) { return new WeakReference ( o ) ; }
private Set < ClusterNode > replicatedUnstableDataNodes ( GridCacheContext < ? , ? > cctx ) { assert cctx . isReplicated ( ) : cctx . name ( ) + STRING ; String space = cctx . name ( ) ; Set < ClusterNode > dataNodes = new HashSet < > ( dataNodes ( space , NONE ) ) ; if ( dataNodes . isEmpty ( ) ) throw new CacheException ( STRING + space ) ; for ( int p = _NUM , parts = cctx . affinity ( ) . partitions ( ) ; p < parts ; p ++ ) { List < ClusterNode > owners = cctx . topology ( ) . owners ( p ) ; if ( F . isEmpty ( owners ) ) return null ; dataNodes . retainAll ( owners ) ; if ( dataNodes . isEmpty ( ) ) return null ; } return dataNodes ; }
private Set < ClusterNode > replicatedUnstableDataNodes ( GridCacheContext < ? , ? > cctx ) { assert cctx . isReplicated ( ) : cctx . name ( ) + STRING ; String space = cctx . name ( ) ; Set < ClusterNode > dataNodes = new HashSet < > ( dataNodes ( space , NONE ) ) ; if ( dataNodes . isEmpty ( ) ) throw new CacheException ( STRING + space ) ; for ( int p = _NUM , parts = cctx . affinity ( ) . partitions ( ) ; p < parts ; p ++ ) { List < ClusterNode > owners = cctx . topology ( ) . owners ( p ) ; if ( F . isEmpty ( owners ) ) return null ; dataNodes . retainAll ( owners ) ; if ( dataNodes . isEmpty ( ) ) return null ; } return dataNodes ; }
protected void headerToXML ( ) { Element root ; Element node ; Element child ; int i ; root = m_Document . getDocumentElement ( ) ; root . setAttribute ( ATT_NAME , validContent ( m_Instances . relationName ( ) ) ) ; root . setAttribute ( ATT_VERSION , Version . VERSION ) ; node = m_Document . createElement ( TAG_HEADER ) ; root . appendChild ( node ) ; child = m_Document . createElement ( TAG_ATTRIBUTES ) ; node . appendChild ( child ) ; for ( i = _NUM ; i < m_Instances . numAttributes ( ) ; i ++ ) { addAttribute ( child , m_Instances . attribute ( i ) ) ; } }
private static long periodEnd ( long now , long period , LocalDateTime cal ) { if ( period < _NUM ) return Long . MAX_VALUE ; else if ( period == _NUM ) return now ; if ( period < _NUM * DAY ) { long localTime = cal . toEpochSecond ( ZoneOffset . UTC ) * _NUM ; localTime = localTime + ( period - ( localTime + _NUM * DAY ) % period ) ; return cal . toEpochSecond ( ZoneOffset . UTC ) * _NUM ; } if ( period % ( _NUM * DAY ) == _NUM ) { int months = ( int ) ( period / ( _NUM * DAY ) ) ; long year = cal . getYear ( ) ; int month = cal . getMonthValue ( ) ; cal . withMonth ( month + months ) ; cal . withDayOfMonth ( _NUM ) ; return cal . toEpochSecond ( ZoneOffset . UTC ) * _NUM ; } if ( period % ( _NUM * DAY ) == _NUM ) { long years = ( period / ( _NUM * DAY ) ) ; long year = cal . getYear ( ) ; long newYear = year + ( years - year % years ) ; cal . withYear ( ( int ) newYear ) ; cal . withMonth ( _NUM ) ; cal . withDayOfMonth ( _NUM ) ; return cal . toEpochSecond ( ZoneOffset . UTC ) * _NUM ; } return cal . toEpochSecond ( ZoneOffset . UTC ) * _NUM ; }
public VideoStreamingSession createLiveVideoSharingSession ( ContactId contact , IVideoPlayer player , long timestamp ) throws CoreException { if ( sLogger . isActivated ( ) ) { sLogger . info ( STRING ) ; } if ( ! isCallConnectedWith ( contact ) ) { if ( sLogger . isActivated ( ) ) { sLogger . debug ( STRING ) ; } throw new CoreException ( STRING ) ; } boolean rejectInvitation = _BOOL ; if ( isCurrentlyVideoSharingBiDirectional ( ) ) { if ( sLogger . isActivated ( ) ) { sLogger . debug ( STRING ) ; } rejectInvitation = _BOOL ; } else if ( isCurrentlyVideoSharingUniDirectional ( ) ) { VideoStreamingSession currentSession = getUnidirectionalVideoSharingSession ( ) ; if ( isSessionOriginating ( currentSession ) ) { if ( sLogger . isActivated ( ) ) { sLogger . debug ( STRING ) ; } rejectInvitation = _BOOL ; } else if ( contact == null || ! contact . equals ( currentSession . getRemoteContact ( ) ) ) { if ( sLogger . isActivated ( ) ) { sLogger . debug ( STRING ) ; } rejectInvitation = _BOOL ; } } if ( rejectInvitation ) { if ( sLogger . isActivated ( ) ) { sLogger . debug ( STRING ) ; } throw new CoreException ( STRING ) ; } return new OriginatingVideoStreamingSession ( this , player , ContentManager . createGenericLiveVideoContent ( ) , contact , mRcsSettings , timestamp , mContactManager , mCapabilityService ) ; }
public Iterator < String > iterateSerializers ( ) { return serializers . iterator ( ) ; }
public void addPerson ( Id person ) { boardingAtFacility . add ( person ) ; if ( rule . getsSeatOnEnter ( person , vehicle , sittingPersons . size ( ) , standingPersons . size ( ) ) ) { addSitting ( person ) ; } else { addStanding ( person ) ; } }
public void addPerson ( Id person ) { boardingAtFacility . add ( person ) ; if ( rule . getsSeatOnEnter ( person , vehicle , sittingPersons . size ( ) , standingPersons . size ( ) ) ) { addSitting ( person ) ; } else { addStanding ( person ) ; } }
public void addPerson ( Id person ) { boardingAtFacility . add ( person ) ; if ( rule . getsSeatOnEnter ( person , vehicle , sittingPersons . size ( ) , standingPersons . size ( ) ) ) { addSitting ( person ) ; } else { addStanding ( person ) ; } }
public void addPerson ( Id person ) { boardingAtFacility . add ( person ) ; if ( rule . getsSeatOnEnter ( person , vehicle , sittingPersons . size ( ) , standingPersons . size ( ) ) ) { addSitting ( person ) ; } else { addStanding ( person ) ; } }
public void addPerson ( Id person ) { boardingAtFacility . add ( person ) ; if ( rule . getsSeatOnEnter ( person , vehicle , sittingPersons . size ( ) , standingPersons . size ( ) ) ) { addSitting ( person ) ; } else { addStanding ( person ) ; } }
public void addPerson ( Id person ) { boardingAtFacility . add ( person ) ; if ( rule . getsSeatOnEnter ( person , vehicle , sittingPersons . size ( ) , standingPersons . size ( ) ) ) { addSitting ( person ) ; } else { addStanding ( person ) ; } }
@ Override public final int hashCode ( ) { long secondhash = Double . doubleToLongBits ( second ) ; secondhash = secondhash ^ ( secondhash > > _NUM ) ; return ( int ) ( first * _NUM + secondhash ) ; }
@ Override public final int hashCode ( ) { long secondhash = Double . doubleToLongBits ( second ) ; secondhash = secondhash ^ ( secondhash > > _NUM ) ; return ( int ) ( first * _NUM + secondhash ) ; }
protected void addCustomPanel ( JPanel customPanel ) { if ( customPanelList == null ) { customPanelList = new ArrayList < Component > ( ) ; } customPanelList . add ( customPanel ) ; }
public ParseACL ( ParseUser owner ) { this ( ) ; setReadAccess ( owner , _BOOL ) ; setWriteAccess ( owner , _BOOL ) ; }
public ParseACL ( ParseUser owner ) { this ( ) ; setReadAccess ( owner , _BOOL ) ; setWriteAccess ( owner , _BOOL ) ; }
public static void describeShapeDetail ( Shape shape , double flattening ) { PathIterator pi2 = shape . getPathIterator ( null ) ; FlatteningPathIterator pi = new FlatteningPathIterator ( pi2 , flattening ) ; double [ ] coords = new double [ _NUM ] ; int pointCount = _NUM ; Debug . output ( STRING + flattening + STRING ) ; while ( ! pi . isDone ( ) ) { int type = pi . currentSegment ( coords ) ; Debug . output ( STRING + type + STRING + ( pointCount ++ ) + STRING + coords [ _NUM ] + STRING + coords [ _NUM ] ) ; pi . next ( ) ; } Debug . output ( STRING + pointCount + STRING ) ; }
public static void describeShapeDetail ( Shape shape , double flattening ) { PathIterator pi2 = shape . getPathIterator ( null ) ; FlatteningPathIterator pi = new FlatteningPathIterator ( pi2 , flattening ) ; double [ ] coords = new double [ _NUM ] ; int pointCount = _NUM ; Debug . output ( STRING + flattening + STRING ) ; while ( ! pi . isDone ( ) ) { int type = pi . currentSegment ( coords ) ; Debug . output ( STRING + type + STRING + ( pointCount ++ ) + STRING + coords [ _NUM ] + STRING + coords [ _NUM ] ) ; pi . next ( ) ; } Debug . output ( STRING + pointCount + STRING ) ; }
public void paintValue ( Graphics g , Rectangle box ) { Color oldColor = g . getColor ( ) ; Font oldFont = g . getFont ( ) ; g . setColor ( Color . blue ) ; g . setFont ( new Font ( oldFont . getFontName ( ) , Font . BOLD , oldFont . getSize ( ) ) ) ; g . drawRect ( box . x - _NUM , box . y + _NUM , box . width - _NUM , box . height - _NUM ) ; g . setColor ( Color . white ) ; g . drawString ( STRING , box . x + _NUM , box . y + box . height / _NUM + _NUM ) ; g . setFont ( oldFont ) ; g . setColor ( oldColor ) ; }
public void paintValue ( Graphics g , Rectangle box ) { Color oldColor = g . getColor ( ) ; Font oldFont = g . getFont ( ) ; g . setColor ( Color . blue ) ; g . setFont ( new Font ( oldFont . getFontName ( ) , Font . BOLD , oldFont . getSize ( ) ) ) ; g . drawRect ( box . x - _NUM , box . y + _NUM , box . width - _NUM , box . height - _NUM ) ; g . setColor ( Color . white ) ; g . drawString ( STRING , box . x + _NUM , box . y + box . height / _NUM + _NUM ) ; g . setFont ( oldFont ) ; g . setColor ( oldColor ) ; }
public void paintValue ( Graphics g , Rectangle box ) { Color oldColor = g . getColor ( ) ; Font oldFont = g . getFont ( ) ; g . setColor ( Color . blue ) ; g . setFont ( new Font ( oldFont . getFontName ( ) , Font . BOLD , oldFont . getSize ( ) ) ) ; g . drawRect ( box . x - _NUM , box . y + _NUM , box . width - _NUM , box . height - _NUM ) ; g . setColor ( Color . white ) ; g . drawString ( STRING , box . x + _NUM , box . y + box . height / _NUM + _NUM ) ; g . setFont ( oldFont ) ; g . setColor ( oldColor ) ; }
private boolean isCanonicalEquals ( ClientProxyMembershipID that ) { if ( this == that ) { return _BOOL ; } if ( this . uniqueId != that . uniqueId ) { return _BOOL ; } return Arrays . equals ( this . identity , that . identity ) ; }
public void addAdapter ( RecyclerView . Adapter adapter ) { addAdapter ( adapters . size ( ) , adapter ) ; }
public static String convertNewLines ( String string ) { int index ; StringBuffer newStringBuffer = new StringBuffer ( ) ; while ( ( index = string . indexOf ( STRING ) ) != - _NUM ) { if ( index > _NUM ) { newStringBuffer . append ( string . substring ( _NUM , index ) ) ; } newStringBuffer . append ( STRING ) ; newStringBuffer . append ( STRING ) ; if ( ( index + _NUM ) < string . length ( ) ) { string = string . substring ( index + _NUM ) ; } else { string = STRING ; } } newStringBuffer . append ( string ) ; string = newStringBuffer . toString ( ) ; newStringBuffer = new StringBuffer ( ) ; while ( ( index = string . indexOf ( STRING ) ) != - _NUM ) { if ( index > _NUM ) { newStringBuffer . append ( string . substring ( _NUM , index ) ) ; } newStringBuffer . append ( STRING ) ; newStringBuffer . append ( STRING ) ; if ( ( index + _NUM ) < string . length ( ) ) { string = string . substring ( index + _NUM ) ; } else { string = STRING ; } } newStringBuffer . append ( string ) ; return newStringBuffer . toString ( ) ; }
public char charAt ( int index ) { if ( index < _NUM || index >= nextFencePost ) return _NUM ; return s . charAt ( index ) ; }
private void performUpdateOperations ( Context context , Request request , JsonValue afterValue , JsonValue beforeValue ) throws ResourceException { final String managedId = getManagedObjectId ( context ) ; activityLogger . log ( context , request , STRING , getManagedObjectPath ( context ) , beforeValue , afterValue , Status . SUCCESS ) ; managedObjectSetService . update ( context , newUpdateRequest ( managedId , afterValue ) , managedId , null , beforeValue , afterValue , new HashSet < > ( Arrays . asList ( propertyPtr ) ) , new HashSet < > ( Arrays . asList ( propertyPtr ) ) ) ; }
private void performUpdateOperations ( Context context , Request request , JsonValue afterValue , JsonValue beforeValue ) throws ResourceException { final String managedId = getManagedObjectId ( context ) ; activityLogger . log ( context , request , STRING , getManagedObjectPath ( context ) , beforeValue , afterValue , Status . SUCCESS ) ; managedObjectSetService . update ( context , newUpdateRequest ( managedId , afterValue ) , managedId , null , beforeValue , afterValue , new HashSet < > ( Arrays . asList ( propertyPtr ) ) , new HashSet < > ( Arrays . asList ( propertyPtr ) ) ) ; }
void restore ( ) { System . arraycopy ( rSave , _NUM , r , _NUM , blockSize ) ; }
void restore ( ) { System . arraycopy ( rSave , _NUM , r , _NUM , blockSize ) ; }
public static String dump ( final InterfaceDescriptor descriptor ) { return String . format ( STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING , descriptor . bLength ( ) , descriptor . bDescriptorType ( ) , descriptor . bInterfaceNumber ( ) & _NUM , descriptor . bAlternateSetting ( ) & _NUM , descriptor . bNumEndpoints ( ) & _NUM , descriptor . bInterfaceClass ( ) & _NUM , getUSBClassName ( descriptor . bInterfaceClass ( ) ) , descriptor . bInterfaceSubClass ( ) & _NUM , descriptor . bInterfaceProtocol ( ) & _NUM , descriptor . iInterface ( ) & _NUM ) ; }
public static String quote ( String s ) { s = s . replaceAll ( STRING , STRING ) ; return STRING + s + STRING ; }
public static String quote ( String s ) { s = s . replaceAll ( STRING , STRING ) ; return STRING + s + STRING ; }
private void addReplicationFactor ( Operation op ) { op . addRequestHeader ( Operation . REPLICATION_QUORUM_HEADER , Operation . REPLICATION_QUORUM_HEADER_VALUE_ALL ) ; }
private void addReplicationFactor ( Operation op ) { op . addRequestHeader ( Operation . REPLICATION_QUORUM_HEADER , Operation . REPLICATION_QUORUM_HEADER_VALUE_ALL ) ; }
private void addReplicationFactor ( Operation op ) { op . addRequestHeader ( Operation . REPLICATION_QUORUM_HEADER , Operation . REPLICATION_QUORUM_HEADER_VALUE_ALL ) ; }
private void addReplicationFactor ( Operation op ) { op . addRequestHeader ( Operation . REPLICATION_QUORUM_HEADER , Operation . REPLICATION_QUORUM_HEADER_VALUE_ALL ) ; }
private void addReplicationFactor ( Operation op ) { op . addRequestHeader ( Operation . REPLICATION_QUORUM_HEADER , Operation . REPLICATION_QUORUM_HEADER_VALUE_ALL ) ; }
private void addReplicationFactor ( Operation op ) { op . addRequestHeader ( Operation . REPLICATION_QUORUM_HEADER , Operation . REPLICATION_QUORUM_HEADER_VALUE_ALL ) ; }
private void addReplicationFactor ( Operation op ) { op . addRequestHeader ( Operation . REPLICATION_QUORUM_HEADER , Operation . REPLICATION_QUORUM_HEADER_VALUE_ALL ) ; }
private void addReplicationFactor ( Operation op ) { op . addRequestHeader ( Operation . REPLICATION_QUORUM_HEADER , Operation . REPLICATION_QUORUM_HEADER_VALUE_ALL ) ; }
public static String printLine ( String a , int num ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = _NUM ; i < num ; i ++ ) { builder . append ( a ) ; } return builder . toString ( ) ; }
public synchronized void removeConsumer ( ImageConsumer ic ) { ics . removeElement ( ic ) ; }
public static Tuple max ( TupleSet tuples , String field , Comparator cmp ) { if ( tuples instanceof Table ) { Table table = ( Table ) tuples ; ColumnMetadata md = table . getMetadata ( field ) ; return table . getTuple ( md . getMaximumRow ( ) ) ; } else { return max ( tuples . tuples ( ) , field , cmp ) ; } }
public static void addStartupListener ( StartUpListener s ) { s_startupListeners . add ( s ) ; }
public static void addStartupListener ( StartUpListener s ) { s_startupListeners . add ( s ) ; }
private MessageListView renderConversation ( ConversationInfo convInfo , View parent ) { MessageListView list = new MessageListView ( parent . getContext ( ) ) ; convInfo . view = list ; list . setOnItemClickListener ( MessageClickListener . getInstance ( ) ) ; MessageListAdapter adapter = convInfo . adapter ; if ( adapter == null ) { adapter = new MessageListAdapter ( convInfo . conv , parent . getContext ( ) ) ; convInfo . adapter = adapter ; } list . setAdapter ( adapter ) ; list . setSelection ( adapter . getCount ( ) - _NUM ) ; return list ; }
private MessageListView renderConversation ( ConversationInfo convInfo , View parent ) { MessageListView list = new MessageListView ( parent . getContext ( ) ) ; convInfo . view = list ; list . setOnItemClickListener ( MessageClickListener . getInstance ( ) ) ; MessageListAdapter adapter = convInfo . adapter ; if ( adapter == null ) { adapter = new MessageListAdapter ( convInfo . conv , parent . getContext ( ) ) ; convInfo . adapter = adapter ; } list . setAdapter ( adapter ) ; list . setSelection ( adapter . getCount ( ) - _NUM ) ; return list ; }
public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( ! ( htmlMode && ( uri . equals ( STRING ) || uri . equals ( STRING ) ) && ( qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) ) ) ) { write ( STRING ) ; writeName ( uri , localName , qName , _BOOL ) ; write ( STRING ) ; } if ( elementLevel == _NUM ) { write ( STRING ) ; } cdataElement = _BOOL ; super . endElement ( uri , localName , qName ) ; nsSupport . popContext ( ) ; elementLevel -- ; }
public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( ! ( htmlMode && ( uri . equals ( STRING ) || uri . equals ( STRING ) ) && ( qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) ) ) ) { write ( STRING ) ; writeName ( uri , localName , qName , _BOOL ) ; write ( STRING ) ; } if ( elementLevel == _NUM ) { write ( STRING ) ; } cdataElement = _BOOL ; super . endElement ( uri , localName , qName ) ; nsSupport . popContext ( ) ; elementLevel -- ; }
public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( ! ( htmlMode && ( uri . equals ( STRING ) || uri . equals ( STRING ) ) && ( qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) ) ) ) { write ( STRING ) ; writeName ( uri , localName , qName , _BOOL ) ; write ( STRING ) ; } if ( elementLevel == _NUM ) { write ( STRING ) ; } cdataElement = _BOOL ; super . endElement ( uri , localName , qName ) ; nsSupport . popContext ( ) ; elementLevel -- ; }
public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( ! ( htmlMode && ( uri . equals ( STRING ) || uri . equals ( STRING ) ) && ( qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) || qName . equals ( STRING ) ) ) ) { write ( STRING ) ; writeName ( uri , localName , qName , _BOOL ) ; write ( STRING ) ; } if ( elementLevel == _NUM ) { write ( STRING ) ; } cdataElement = _BOOL ; super . endElement ( uri , localName , qName ) ; nsSupport . popContext ( ) ; elementLevel -- ; }
@ Override public void close ( ) throws XMLStreamException { log . log ( Level . FINE , STRING ) ; stream . close ( ) ; }
@ Override public void close ( ) throws XMLStreamException { log . log ( Level . FINE , STRING ) ; stream . close ( ) ; }
public void disconnect ( final BluetoothDevice device ) { final BleManager < BleManagerCallbacks > manager = mBleManagers . get ( device ) ; if ( manager != null && manager . isConnected ( ) ) { manager . disconnect ( ) ; } mManagedDevices . remove ( device ) ; }
public void disconnect ( final BluetoothDevice device ) { final BleManager < BleManagerCallbacks > manager = mBleManagers . get ( device ) ; if ( manager != null && manager . isConnected ( ) ) { manager . disconnect ( ) ; } mManagedDevices . remove ( device ) ; }
public void disconnect ( final BluetoothDevice device ) { final BleManager < BleManagerCallbacks > manager = mBleManagers . get ( device ) ; if ( manager != null && manager . isConnected ( ) ) { manager . disconnect ( ) ; } mManagedDevices . remove ( device ) ; }
public void disconnect ( final BluetoothDevice device ) { final BleManager < BleManagerCallbacks > manager = mBleManagers . get ( device ) ; if ( manager != null && manager . isConnected ( ) ) { manager . disconnect ( ) ; } mManagedDevices . remove ( device ) ; }
public void disconnect ( final BluetoothDevice device ) { final BleManager < BleManagerCallbacks > manager = mBleManagers . get ( device ) ; if ( manager != null && manager . isConnected ( ) ) { manager . disconnect ( ) ; } mManagedDevices . remove ( device ) ; }
public int tpgid ( ) { return Integer . parseInt ( fields [ _NUM ] ) ; }
public int tpgid ( ) { return Integer . parseInt ( fields [ _NUM ] ) ; }
public static void deinitialize ( ) { INSTANCE . codenameOneRunning = _BOOL ; synchronized ( lock ) { lock . notifyAll ( ) ; } }
public static void deinitialize ( ) { INSTANCE . codenameOneRunning = _BOOL ; synchronized ( lock ) { lock . notifyAll ( ) ; } }
public static void deinitialize ( ) { INSTANCE . codenameOneRunning = _BOOL ; synchronized ( lock ) { lock . notifyAll ( ) ; } }
public static void deinitialize ( ) { INSTANCE . codenameOneRunning = _BOOL ; synchronized ( lock ) { lock . notifyAll ( ) ; } }
public static void deinitialize ( ) { INSTANCE . codenameOneRunning = _BOOL ; synchronized ( lock ) { lock . notifyAll ( ) ; } }
public static void deinitialize ( ) { INSTANCE . codenameOneRunning = _BOOL ; synchronized ( lock ) { lock . notifyAll ( ) ; } }
public static void deinitialize ( ) { INSTANCE . codenameOneRunning = _BOOL ; synchronized ( lock ) { lock . notifyAll ( ) ; } }
@ VisibleForTesting protected Process startExecutorProcess ( int container ) { return ShellUtils . runASyncProcess ( getExecutorCommand ( container ) , new File ( LocalContext . workingDirectory ( config ) ) , Integer . toString ( container ) ) ; }
public static TimeZone parseXSTimeZone ( String timeZoneStr ) throws DateParseException { Matcher m = PATTERN_XS_TIME_ZONE . matcher ( timeZoneStr ) ; if ( ! m . matches ( ) ) { throw new DateParseException ( STRING + PATTERN_XS_TIME_ZONE ) ; } return parseMatchingTimeZone ( timeZoneStr , null ) ; }
public DelegatingResourceLoader ( Map < String , ResourceLoader > loaders , File cacheDirectory ) { this . loaders = CollectionUtils . isEmpty ( loaders ) ? Collections . < String , ResourceLoader > emptyMap ( ) : Collections . unmodifiableMap ( loaders ) ; this . cacheDirectory = initCacheDirectory ( cacheDirectory ) ; }
public static String removeExtraSpaces ( String text ) { text = text . replace ( ChineseLanguageConstants . SPACE [ _NUM ] , ChineseLanguageConstants . SPACE [ _NUM ] ) ; text = text . replaceAll ( STRING , STRING ) ; text = text . replaceAll ( STRING , STRING ) ; return text ; }
public static String removeExtraSpaces ( String text ) { text = text . replace ( ChineseLanguageConstants . SPACE [ _NUM ] , ChineseLanguageConstants . SPACE [ _NUM ] ) ; text = text . replaceAll ( STRING , STRING ) ; text = text . replaceAll ( STRING , STRING ) ; return text ; }
public static String removeExtraSpaces ( String text ) { text = text . replace ( ChineseLanguageConstants . SPACE [ _NUM ] , ChineseLanguageConstants . SPACE [ _NUM ] ) ; text = text . replaceAll ( STRING , STRING ) ; text = text . replaceAll ( STRING , STRING ) ; return text ; }
byte [ ] encryptContentEncryptionKey ( byte [ ] contentEncryptionKey , PublicKey publicKey ) throws EncryptDataException { try { Cipher rsaCipher = Cipher . getInstance ( RSA_ALGORITHM_MODE ) ; rsaCipher . init ( Cipher . ENCRYPT_MODE , publicKey ) ; byte [ ] encryptedData = rsaCipher . doFinal ( contentEncryptionKey ) ; return encryptedData ; } catch ( Exception e ) { throw new EncryptDataException ( STRING , e ) ; } }
byte [ ] encryptContentEncryptionKey ( byte [ ] contentEncryptionKey , PublicKey publicKey ) throws EncryptDataException { try { Cipher rsaCipher = Cipher . getInstance ( RSA_ALGORITHM_MODE ) ; rsaCipher . init ( Cipher . ENCRYPT_MODE , publicKey ) ; byte [ ] encryptedData = rsaCipher . doFinal ( contentEncryptionKey ) ; return encryptedData ; } catch ( Exception e ) { throw new EncryptDataException ( STRING , e ) ; } }
byte [ ] encryptContentEncryptionKey ( byte [ ] contentEncryptionKey , PublicKey publicKey ) throws EncryptDataException { try { Cipher rsaCipher = Cipher . getInstance ( RSA_ALGORITHM_MODE ) ; rsaCipher . init ( Cipher . ENCRYPT_MODE , publicKey ) ; byte [ ] encryptedData = rsaCipher . doFinal ( contentEncryptionKey ) ; return encryptedData ; } catch ( Exception e ) { throw new EncryptDataException ( STRING , e ) ; } }
byte [ ] encryptContentEncryptionKey ( byte [ ] contentEncryptionKey , PublicKey publicKey ) throws EncryptDataException { try { Cipher rsaCipher = Cipher . getInstance ( RSA_ALGORITHM_MODE ) ; rsaCipher . init ( Cipher . ENCRYPT_MODE , publicKey ) ; byte [ ] encryptedData = rsaCipher . doFinal ( contentEncryptionKey ) ; return encryptedData ; } catch ( Exception e ) { throw new EncryptDataException ( STRING , e ) ; } }
public void addArc ( String sParent , ArrayList < Integer > nodes ) throws Exception { int nParent = getNode ( sParent ) ; if ( m_bNeedsUndoAction ) { addUndoAction ( new AddArcAction ( nParent , nodes ) ) ; } boolean bNeedsUndoAction = m_bNeedsUndoAction ; m_bNeedsUndoAction = _BOOL ; for ( int iNode = _NUM ; iNode < nodes . size ( ) ; iNode ++ ) { int nNode = nodes . get ( iNode ) ; addArc ( nParent , nNode ) ; } m_bNeedsUndoAction = bNeedsUndoAction ; }
public void addArc ( String sParent , ArrayList < Integer > nodes ) throws Exception { int nParent = getNode ( sParent ) ; if ( m_bNeedsUndoAction ) { addUndoAction ( new AddArcAction ( nParent , nodes ) ) ; } boolean bNeedsUndoAction = m_bNeedsUndoAction ; m_bNeedsUndoAction = _BOOL ; for ( int iNode = _NUM ; iNode < nodes . size ( ) ; iNode ++ ) { int nNode = nodes . get ( iNode ) ; addArc ( nParent , nNode ) ; } m_bNeedsUndoAction = bNeedsUndoAction ; }
public static int numDecodings ( String s ) { if ( s == null || s . length ( ) == _NUM ) { return _NUM ; } int len = s . length ( ) ; int [ ] ways = new int [ len + _NUM ] ; ways [ _NUM ] = _NUM ; ways [ _NUM ] = s . charAt ( _NUM ) == STRING ? _NUM : _NUM ; for ( int i = _NUM ; i <= len ; i ++ ) { int code1 = Integer . valueOf ( s . substring ( i - _NUM , i ) ) ; int code2 = Integer . valueOf ( s . substring ( i - _NUM , i ) ) ; ways [ i ] = ( code1 != _NUM ? ways [ i - _NUM ] : _NUM ) + ( code2 <= _NUM && code2 > _NUM ? ways [ i - _NUM ] : _NUM ) ; } return ways [ len ] ; }
public static int numDecodings ( String s ) { if ( s == null || s . length ( ) == _NUM ) { return _NUM ; } int len = s . length ( ) ; int [ ] ways = new int [ len + _NUM ] ; ways [ _NUM ] = _NUM ; ways [ _NUM ] = s . charAt ( _NUM ) == STRING ? _NUM : _NUM ; for ( int i = _NUM ; i <= len ; i ++ ) { int code1 = Integer . valueOf ( s . substring ( i - _NUM , i ) ) ; int code2 = Integer . valueOf ( s . substring ( i - _NUM , i ) ) ; ways [ i ] = ( code1 != _NUM ? ways [ i - _NUM ] : _NUM ) + ( code2 <= _NUM && code2 > _NUM ? ways [ i - _NUM ] : _NUM ) ; } return ways [ len ] ; }
public static int numDecodings ( String s ) { if ( s == null || s . length ( ) == _NUM ) { return _NUM ; } int len = s . length ( ) ; int [ ] ways = new int [ len + _NUM ] ; ways [ _NUM ] = _NUM ; ways [ _NUM ] = s . charAt ( _NUM ) == STRING ? _NUM : _NUM ; for ( int i = _NUM ; i <= len ; i ++ ) { int code1 = Integer . valueOf ( s . substring ( i - _NUM , i ) ) ; int code2 = Integer . valueOf ( s . substring ( i - _NUM , i ) ) ; ways [ i ] = ( code1 != _NUM ? ways [ i - _NUM ] : _NUM ) + ( code2 <= _NUM && code2 > _NUM ? ways [ i - _NUM ] : _NUM ) ; } return ways [ len ] ; }
public static int numDecodings ( String s ) { if ( s == null || s . length ( ) == _NUM ) { return _NUM ; } int len = s . length ( ) ; int [ ] ways = new int [ len + _NUM ] ; ways [ _NUM ] = _NUM ; ways [ _NUM ] = s . charAt ( _NUM ) == STRING ? _NUM : _NUM ; for ( int i = _NUM ; i <= len ; i ++ ) { int code1 = Integer . valueOf ( s . substring ( i - _NUM , i ) ) ; int code2 = Integer . valueOf ( s . substring ( i - _NUM , i ) ) ; ways [ i ] = ( code1 != _NUM ? ways [ i - _NUM ] : _NUM ) + ( code2 <= _NUM && code2 > _NUM ? ways [ i - _NUM ] : _NUM ) ; } return ways [ len ] ; }
public static String extractClassname ( String fullname ) { return fullname . replaceFirst ( STRING , STRING ) ; }
public static String extractClassname ( String fullname ) { return fullname . replaceFirst ( STRING , STRING ) ; }
public static int findMethodInReminderList ( ArrayList < Integer > values , int method ) { int index = values . indexOf ( method ) ; if ( index == - _NUM ) { index = _NUM ; } return index ; }
public static int findMethodInReminderList ( ArrayList < Integer > values , int method ) { int index = values . indexOf ( method ) ; if ( index == - _NUM ) { index = _NUM ; } return index ; }
public static int findMethodInReminderList ( ArrayList < Integer > values , int method ) { int index = values . indexOf ( method ) ; if ( index == - _NUM ) { index = _NUM ; } return index ; }
public static int findMethodInReminderList ( ArrayList < Integer > values , int method ) { int index = values . indexOf ( method ) ; if ( index == - _NUM ) { index = _NUM ; } return index ; }
public static int findMethodInReminderList ( ArrayList < Integer > values , int method ) { int index = values . indexOf ( method ) ; if ( index == - _NUM ) { index = _NUM ; } return index ; }
public static int findMethodInReminderList ( ArrayList < Integer > values , int method ) { int index = values . indexOf ( method ) ; if ( index == - _NUM ) { index = _NUM ; } return index ; }
public static int findMethodInReminderList ( ArrayList < Integer > values , int method ) { int index = values . indexOf ( method ) ; if ( index == - _NUM ) { index = _NUM ; } return index ; }
public static int findMethodInReminderList ( ArrayList < Integer > values , int method ) { int index = values . indexOf ( method ) ; if ( index == - _NUM ) { index = _NUM ; } return index ; }
public static Date calculateGregorianDate ( double jd ) { int l = ( int ) jd + _NUM ; int n = ( _NUM * l ) / _NUM ; l = l - ( _NUM * n + _NUM ) / _NUM ; int i = ( _NUM * ( l + _NUM ) ) / _NUM ; l = l - ( _NUM * i ) / _NUM + _NUM ; int j = ( _NUM * l ) / _NUM ; int d = l - ( _NUM * j ) / _NUM ; l = j / _NUM ; int m = j + _NUM - _NUM * l ; int y = _NUM * ( n - _NUM ) + i + l ; double fraction = jd - Math . floor ( jd ) ; double dHours = fraction * _NUM ; int hours = ( int ) dHours ; double dMinutes = ( dHours - hours ) * _NUM ; int minutes = ( int ) dMinutes ; int seconds = ( int ) ( ( dMinutes - minutes ) * _NUM ) ; Calendar cal = Calendar . getInstance ( TimeZone . getTimeZone ( STRING ) ) ; cal . set ( y , m - _NUM , d , hours + _NUM , minutes , seconds ) ; return cal . getTime ( ) ; }
public static Date calculateGregorianDate ( double jd ) { int l = ( int ) jd + _NUM ; int n = ( _NUM * l ) / _NUM ; l = l - ( _NUM * n + _NUM ) / _NUM ; int i = ( _NUM * ( l + _NUM ) ) / _NUM ; l = l - ( _NUM * i ) / _NUM + _NUM ; int j = ( _NUM * l ) / _NUM ; int d = l - ( _NUM * j ) / _NUM ; l = j / _NUM ; int m = j + _NUM - _NUM * l ; int y = _NUM * ( n - _NUM ) + i + l ; double fraction = jd - Math . floor ( jd ) ; double dHours = fraction * _NUM ; int hours = ( int ) dHours ; double dMinutes = ( dHours - hours ) * _NUM ; int minutes = ( int ) dMinutes ; int seconds = ( int ) ( ( dMinutes - minutes ) * _NUM ) ; Calendar cal = Calendar . getInstance ( TimeZone . getTimeZone ( STRING ) ) ; cal . set ( y , m - _NUM , d , hours + _NUM , minutes , seconds ) ; return cal . getTime ( ) ; }
public static Date calculateGregorianDate ( double jd ) { int l = ( int ) jd + _NUM ; int n = ( _NUM * l ) / _NUM ; l = l - ( _NUM * n + _NUM ) / _NUM ; int i = ( _NUM * ( l + _NUM ) ) / _NUM ; l = l - ( _NUM * i ) / _NUM + _NUM ; int j = ( _NUM * l ) / _NUM ; int d = l - ( _NUM * j ) / _NUM ; l = j / _NUM ; int m = j + _NUM - _NUM * l ; int y = _NUM * ( n - _NUM ) + i + l ; double fraction = jd - Math . floor ( jd ) ; double dHours = fraction * _NUM ; int hours = ( int ) dHours ; double dMinutes = ( dHours - hours ) * _NUM ; int minutes = ( int ) dMinutes ; int seconds = ( int ) ( ( dMinutes - minutes ) * _NUM ) ; Calendar cal = Calendar . getInstance ( TimeZone . getTimeZone ( STRING ) ) ; cal . set ( y , m - _NUM , d , hours + _NUM , minutes , seconds ) ; return cal . getTime ( ) ; }
public void commitRandom ( final Randomizer rand ) { rand . setPdf ( pdf ) ; if ( pdf == ProbDistribution . NULL ) { return ; } double param1 = Utils . doubleParsable ( tfParam1 ) ; if ( tfParam1 . isEnabled ( ) && ! Double . isNaN ( param1 ) ) { rand . setParam1Consistent ( pdf . getParam1Name ( ) , param1 ) ; } double param2 = Utils . doubleParsable ( tfParam2 ) ; if ( tfParam2 . isEnabled ( ) && ! Double . isNaN ( param2 ) ) { rand . setParam2Consistent ( pdf . getParam2Name ( ) , param2 ) ; } if ( ! tsClipping . isNull ( ) ) { rand . setClipping ( tsClipping . isSelected ( ) ) ; if ( tsClipping . isSelected ( ) ) { double upperBound = Utils . doubleParsable ( tfUpBound ) ; if ( ! Double . isNaN ( upperBound ) ) { rand . setUpperBound ( upperBound ) ; } double lowerBound = Utils . doubleParsable ( tfLowBound ) ; if ( ! Double . isNaN ( lowerBound ) ) { rand . setLowerBound ( lowerBound ) ; } } } }
public void removeWhitelistURL ( String URL ) { serviceWhitelist . remove ( URL ) ; }
@ Override public void postPutAllSend ( DistributedPutAllOperation putAllOp , VersionedObjectList successfulPuts ) { if ( putAllOp . putAllDataSize > _NUM ) { putAllOp . distribute ( ) ; } else { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING ) ; } } }
public ServerConfigXML ( String xml ) throws Exception { Document doc = XMLUtils . getXMLDocument ( new ByteArrayInputStream ( xml . getBytes ( STRING ) ) ) ; Node root = XMLUtils . getRootNode ( doc , DSConfigMgr . ROOT ) ; defaultServerGroup = new ServerGroup ( XMLUtils . getNamedChildNode ( root , DSConfigMgr . SERVERGROUP , DSConfigMgr . NAME , DSConfigMgr . DEFAULT ) ) ; smsServerGroup = new ServerGroup ( XMLUtils . getNamedChildNode ( root , DSConfigMgr . SERVERGROUP , DSConfigMgr . NAME , STRING ) ) ; }
public ServerConfigXML ( String xml ) throws Exception { Document doc = XMLUtils . getXMLDocument ( new ByteArrayInputStream ( xml . getBytes ( STRING ) ) ) ; Node root = XMLUtils . getRootNode ( doc , DSConfigMgr . ROOT ) ; defaultServerGroup = new ServerGroup ( XMLUtils . getNamedChildNode ( root , DSConfigMgr . SERVERGROUP , DSConfigMgr . NAME , DSConfigMgr . DEFAULT ) ) ; smsServerGroup = new ServerGroup ( XMLUtils . getNamedChildNode ( root , DSConfigMgr . SERVERGROUP , DSConfigMgr . NAME , STRING ) ) ; }
public void hideColumn ( Object columnName ) { if ( columnName == null ) { return ; } for ( int i = _NUM ; i < columnModel . getColumnCount ( ) ; i ++ ) { TableColumn column = columnModel . getColumn ( i ) ; if ( columnName . equals ( column . getHeaderValue ( ) ) ) { hideColumn ( column ) ; break ; } } }
private void update ( ) { dataControl . setFirstRow ( _NUM ) ; dataControl . setLastRow ( Math . min ( dataControl . getMaxRows ( ) , getDefaultMaximumNumber ( STRING , dataControl . getMaxRows ( ) ) ) ) ; dataControl . setFirstColumn ( _NUM ) ; dataControl . setLastColumn ( Math . min ( dataControl . getMaxColumns ( ) , getDefaultMaximumNumber ( STRING , dataControl . getMaxColumns ( ) ) ) ) ; dataControl . update ( ) ; }
private void update ( ) { dataControl . setFirstRow ( _NUM ) ; dataControl . setLastRow ( Math . min ( dataControl . getMaxRows ( ) , getDefaultMaximumNumber ( STRING , dataControl . getMaxRows ( ) ) ) ) ; dataControl . setFirstColumn ( _NUM ) ; dataControl . setLastColumn ( Math . min ( dataControl . getMaxColumns ( ) , getDefaultMaximumNumber ( STRING , dataControl . getMaxColumns ( ) ) ) ) ; dataControl . update ( ) ; }
private void update ( ) { dataControl . setFirstRow ( _NUM ) ; dataControl . setLastRow ( Math . min ( dataControl . getMaxRows ( ) , getDefaultMaximumNumber ( STRING , dataControl . getMaxRows ( ) ) ) ) ; dataControl . setFirstColumn ( _NUM ) ; dataControl . setLastColumn ( Math . min ( dataControl . getMaxColumns ( ) , getDefaultMaximumNumber ( STRING , dataControl . getMaxColumns ( ) ) ) ) ; dataControl . update ( ) ; }
protected void doGetData ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { Properties properties = null ; try { properties = buildProperties ( request . getPathInfo ( ) , KEY_DEVICE_ID , KEY_DEVICE_TYPE_ID , KEY_MESSAGE_TYPE_ID , KEY_LIMIT ) ; } catch ( IllegalArgumentException e ) { printError ( response , e . getMessage ( ) ) ; return ; } try { String tableName = properties . getProperty ( KEY_TABLE_NAME ) ; if ( ! isTableExists ( tableName ) ) { printError ( response , STRING + tableName + STRING + properties . getProperty ( KEY_MESSAGE_TYPE_ID ) + STRING ) ; return ; } } catch ( SQLException e ) { printError ( response , e . getMessage ( ) ) ; return ; } String tableData = null ; try { tableData = selectTableData ( properties ) ; } catch ( SQLException e ) { printError ( response , e . getMessage ( ) ) ; return ; } printJson ( response , tableData ) ; }
public AugmentedDickeyFuller ( double [ ] ts ) { this . ts = ts ; this . lag = ( int ) Math . floor ( Math . cbrt ( ( ts . length - _NUM ) ) ) ; computeADFStatistics ( ) ; }
public AugmentedDickeyFuller ( double [ ] ts ) { this . ts = ts ; this . lag = ( int ) Math . floor ( Math . cbrt ( ( ts . length - _NUM ) ) ) ; computeADFStatistics ( ) ; }
protected StringBuilder processLine ( String nextElement ) { StringBuilder sb = new StringBuilder ( INITIAL_STRING_SIZE ) ; for ( int j = _NUM ; j < nextElement . length ( ) ; j ++ ) { char nextChar = nextElement . charAt ( j ) ; processCharacter ( sb , nextChar ) ; } return sb ; }
protected StringBuilder processLine ( String nextElement ) { StringBuilder sb = new StringBuilder ( INITIAL_STRING_SIZE ) ; for ( int j = _NUM ; j < nextElement . length ( ) ; j ++ ) { char nextChar = nextElement . charAt ( j ) ; processCharacter ( sb , nextChar ) ; } return sb ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
public static boolean isNewer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
private static void deleteDirectoryOnExit ( File directory ) throws IOException { if ( ! directory . exists ( ) ) { return ; } directory . deleteOnExit ( ) ; if ( ! isSymlink ( directory ) ) { cleanDirectoryOnExit ( directory ) ; } }
private static void deleteDirectoryOnExit ( File directory ) throws IOException { if ( ! directory . exists ( ) ) { return ; } directory . deleteOnExit ( ) ; if ( ! isSymlink ( directory ) ) { cleanDirectoryOnExit ( directory ) ; } }
public void addUnmanagedSourceVolumeToUpdate ( UnManagedVolume volume ) { if ( null == _unmanagedSourceVolumesToUpdate ) { _unmanagedSourceVolumesToUpdate = new ArrayList < UnManagedVolume > ( ) ; } _unmanagedSourceVolumesToUpdate . add ( volume ) ; }
final protected < T > T create ( Class < T > type , InjectContext env ) throws ConfigException { try { T value = type . newInstance ( ) ; inject ( value , env ) ; return value ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw ConfigException . wrap ( e ) ; } }
public Array ( final Array array ) { this ( array , EnumSet . noneOf ( Address . Flags . class ) ) ; }
public static String join ( String separator , List < ? > elements ) { if ( elements == null || elements . size ( ) == _NUM ) { return STRING ; } StringBuilder sb = new StringBuilder ( elements . size ( ) * _NUM ) ; int i = _NUM ; for ( Object elem : elements ) { if ( separator . length ( ) > _NUM && i ++ > _NUM ) { sb . append ( separator ) ; } sb . append ( format ( elem ) ) ; } return sb . toString ( ) ; }
public static String join ( String separator , List < ? > elements ) { if ( elements == null || elements . size ( ) == _NUM ) { return STRING ; } StringBuilder sb = new StringBuilder ( elements . size ( ) * _NUM ) ; int i = _NUM ; for ( Object elem : elements ) { if ( separator . length ( ) > _NUM && i ++ > _NUM ) { sb . append ( separator ) ; } sb . append ( format ( elem ) ) ; } return sb . toString ( ) ; }
private void reserveOneDoc ( ) { if ( pendingNumDocs . incrementAndGet ( ) > IndexWriter . getActualMaxDocs ( ) ) { pendingNumDocs . decrementAndGet ( ) ; throw new IllegalArgumentException ( STRING + IndexWriter . getActualMaxDocs ( ) ) ; } }
private void reserveOneDoc ( ) { if ( pendingNumDocs . incrementAndGet ( ) > IndexWriter . getActualMaxDocs ( ) ) { pendingNumDocs . decrementAndGet ( ) ; throw new IllegalArgumentException ( STRING + IndexWriter . getActualMaxDocs ( ) ) ; } }
private void reserveOneDoc ( ) { if ( pendingNumDocs . incrementAndGet ( ) > IndexWriter . getActualMaxDocs ( ) ) { pendingNumDocs . decrementAndGet ( ) ; throw new IllegalArgumentException ( STRING + IndexWriter . getActualMaxDocs ( ) ) ; } }
private void reserveOneDoc ( ) { if ( pendingNumDocs . incrementAndGet ( ) > IndexWriter . getActualMaxDocs ( ) ) { pendingNumDocs . decrementAndGet ( ) ; throw new IllegalArgumentException ( STRING + IndexWriter . getActualMaxDocs ( ) ) ; } }
public void write ( char [ ] cbuf , int off , int len ) throws IOException { internalOut . write ( cbuf , off , len ) ; }
@ Override default CompletableFuture < OptionalLong > minLong ( final ToLongFunction < ? super T > fn ) { return CompletableFuture . supplyAsync ( null , getExec ( ) ) ; }
public void sendNoMsgToTargetWithToken ( Object token , Object target ) { sendToTargetOrType ( target . getClass ( ) , token ) ; }
public void sendNoMsgToTargetWithToken ( Object token , Object target ) { sendToTargetOrType ( target . getClass ( ) , token ) ; }
public void initChannel ( ) throws CarbonDataWriterException { initFileCount ( ) ; if ( this . isInProgressExtrequired ) { this . fileName = MessageFormat . format ( this . fileNameFormat , this . fileCount ) + CarbonCommonConstants . FILE_INPROGRESS_STATUS ; FileData fileData = new FileData ( this . fileName , this . storeLocation ) ; fileManager . add ( fileData ) ; } else { this . fileName = MessageFormat . format ( this . fileNameFormat , this . fileCount ) ; } this . fileCount ++ ; try { this . fileDataOutStream = FileFactory . getDataOutputStream ( this . fileName , FileFactory . getFileType ( this . fileName ) , ( short ) _NUM ) ; } catch ( FileNotFoundException fileNotFoundException ) { throw new CarbonDataWriterException ( STRING , fileNotFoundException ) ; } catch ( IOException e ) { throw new CarbonDataWriterException ( STRING , e ) ; } }
public synchronized void updateNString ( String columnName , String x ) throws SQLException { updateNString ( findColumn ( columnName ) , x ) ; }
public synchronized void updateNString ( String columnName , String x ) throws SQLException { updateNString ( findColumn ( columnName ) , x ) ; }
public synchronized void updateNString ( String columnName , String x ) throws SQLException { updateNString ( findColumn ( columnName ) , x ) ; }
public synchronized void updateNString ( String columnName , String x ) throws SQLException { updateNString ( findColumn ( columnName ) , x ) ; }
public synchronized void updateNString ( String columnName , String x ) throws SQLException { updateNString ( findColumn ( columnName ) , x ) ; }
public synchronized void updateNString ( String columnName , String x ) throws SQLException { updateNString ( findColumn ( columnName ) , x ) ; }
public synchronized void updateNString ( String columnName , String x ) throws SQLException { updateNString ( findColumn ( columnName ) , x ) ; }
public double migrationEventProposalDensity ( int x , int y , double t , double [ ] m ) { if ( x == y ) { return Math . exp ( - t * m [ _NUM - x ] ) ; } else { return Math . exp ( - t * m [ _NUM - x ] ) * m [ _NUM - x ] ; } }
public double migrationEventProposalDensity ( int x , int y , double t , double [ ] m ) { if ( x == y ) { return Math . exp ( - t * m [ _NUM - x ] ) ; } else { return Math . exp ( - t * m [ _NUM - x ] ) * m [ _NUM - x ] ; } }
public static < C extends ConfigurationClient , S extends Configuration > CreateSubCommandHandler < C , S > create ( SubCommandArgumentParser parser , ManagedObjectPath < ? , ? > p , OptionalRelationDefinition < C , S > r ) throws ArgumentException { return new CreateSubCommandHandler < > ( parser , p , r , null , p . child ( r ) ) ; }
public void addListener ( FailoverTtsListener listener ) { mListeners . add ( listener ) ; }
private ConcurrentBufferedUpdate ( final Network network ) { this . network = network ; currentAvailableProcessors = getAvailableConsumerProcessors ( ) ; executors = Executors . newFixedThreadPool ( currentAvailableProcessors ) ; for ( Neuron n : network . getFlatNeuronList ( ) ) { neurons . add ( n ) ; } for ( NeuronGroup ng : network . getFlatNeuronGroupList ( ) ) { neurons . addAll ( ng . getNeuronList ( ) ) ; } taskSet = new CyclicTaskQueue ( neurons , currentAvailableProcessors ) ; }
private ConcurrentBufferedUpdate ( final Network network ) { this . network = network ; currentAvailableProcessors = getAvailableConsumerProcessors ( ) ; executors = Executors . newFixedThreadPool ( currentAvailableProcessors ) ; for ( Neuron n : network . getFlatNeuronList ( ) ) { neurons . add ( n ) ; } for ( NeuronGroup ng : network . getFlatNeuronGroupList ( ) ) { neurons . addAll ( ng . getNeuronList ( ) ) ; } taskSet = new CyclicTaskQueue ( neurons , currentAvailableProcessors ) ; }
public void addOnCompleteCall ( Runnable r ) { if ( post == null ) { post = new ArrayList < Runnable > ( ) ; } post . add ( r ) ; }
public static final String removeDataFolderPath ( String fullPath ) { File sdCard = Environment . getExternalStorageDirectory ( ) ; String dataFolderPath = sdCard . getAbsolutePath ( ) + STRING + MainApp . getDataFolder ( ) + STRING ; if ( fullPath . indexOf ( dataFolderPath ) == _NUM ) { return fullPath . substring ( dataFolderPath . length ( ) ) ; } return fullPath ; }
public static final String removeDataFolderPath ( String fullPath ) { File sdCard = Environment . getExternalStorageDirectory ( ) ; String dataFolderPath = sdCard . getAbsolutePath ( ) + STRING + MainApp . getDataFolder ( ) + STRING ; if ( fullPath . indexOf ( dataFolderPath ) == _NUM ) { return fullPath . substring ( dataFolderPath . length ( ) ) ; } return fullPath ; }
public static final String removeDataFolderPath ( String fullPath ) { File sdCard = Environment . getExternalStorageDirectory ( ) ; String dataFolderPath = sdCard . getAbsolutePath ( ) + STRING + MainApp . getDataFolder ( ) + STRING ; if ( fullPath . indexOf ( dataFolderPath ) == _NUM ) { return fullPath . substring ( dataFolderPath . length ( ) ) ; } return fullPath ; }
public static final String removeDataFolderPath ( String fullPath ) { File sdCard = Environment . getExternalStorageDirectory ( ) ; String dataFolderPath = sdCard . getAbsolutePath ( ) + STRING + MainApp . getDataFolder ( ) + STRING ; if ( fullPath . indexOf ( dataFolderPath ) == _NUM ) { return fullPath . substring ( dataFolderPath . length ( ) ) ; } return fullPath ; }
public static final String removeDataFolderPath ( String fullPath ) { File sdCard = Environment . getExternalStorageDirectory ( ) ; String dataFolderPath = sdCard . getAbsolutePath ( ) + STRING + MainApp . getDataFolder ( ) + STRING ; if ( fullPath . indexOf ( dataFolderPath ) == _NUM ) { return fullPath . substring ( dataFolderPath . length ( ) ) ; } return fullPath ; }
public static final String removeDataFolderPath ( String fullPath ) { File sdCard = Environment . getExternalStorageDirectory ( ) ; String dataFolderPath = sdCard . getAbsolutePath ( ) + STRING + MainApp . getDataFolder ( ) + STRING ; if ( fullPath . indexOf ( dataFolderPath ) == _NUM ) { return fullPath . substring ( dataFolderPath . length ( ) ) ; } return fullPath ; }
public ThreadPool ( String name , int poolSize ) { this . poolSize = poolSize ; this . poolName = name ; taskList = new LinkedList < Runnable > ( ) ; threads = new WorkerThread [ poolSize ] ; createThreads ( ) ; }
public static String PlaybackRuntimeFromMilliseconds ( long milliseconds ) { long hours = _NUM ; long minutes = _NUM ; long seconds = _NUM ; if ( milliseconds >= ( _NUM * _NUM * _NUM ) ) { hours = milliseconds / ( _NUM * _NUM * _NUM ) ; } if ( milliseconds >= ( _NUM * _NUM ) ) { minutes = ( milliseconds % ( _NUM * _NUM * _NUM ) ) / ( _NUM * _NUM ) ; } if ( milliseconds >= _NUM ) { seconds = ( ( milliseconds % ( _NUM * _NUM * _NUM ) ) % ( _NUM * _NUM ) ) / _NUM ; } String runtime = STRING ; if ( hours > _NUM ) { runtime = String . valueOf ( hours ) + STRING ; } if ( minutes > _NUM ) { if ( minutes < _NUM && hours > _NUM ) { runtime += STRING ; } runtime += String . valueOf ( minutes ) + STRING ; } else { if ( hours > _NUM ) { runtime += STRING ; } } if ( seconds > _NUM ) { if ( seconds < _NUM ) { runtime += STRING ; } runtime += String . valueOf ( seconds ) ; if ( hours < _NUM && minutes < _NUM ) { runtime = STRING + runtime ; } } else { if ( hours < _NUM && minutes < _NUM ) { runtime += STRING ; } else { runtime += STRING ; } } return runtime ; }
public static JClassLoaderWrapper create ( ClassLoader loader ) { JClassLoaderWrapper jLoader = _localClassLoader . getLevel ( loader ) ; if ( jLoader == null ) { jLoader = new JClassLoaderWrapper ( loader ) ; _localClassLoader . set ( jLoader , loader ) ; } return jLoader ; }
public void remove ( int size ) throws CacheException { for ( int i = _NUM ; i < size ; i ++ ) { remove ( ) ; } if ( logger . isTraceEnabled ( ) ) { logger . trace ( STRING , this , size ) ; } }
public void remove ( int size ) throws CacheException { for ( int i = _NUM ; i < size ; i ++ ) { remove ( ) ; } if ( logger . isTraceEnabled ( ) ) { logger . trace ( STRING , this , size ) ; } }
@ Override public void uninitialize ( ) { removeOurUIs ( ) ; resetDefaultBorders ( ) ; JFrame . setDefaultLookAndFeelDecorated ( _BOOL ) ; super . uninitialize ( ) ; }
private String dive ( int depth , int iteration ) { String str0 ; String str1 ; String str2 ; String str3 ; String str4 ; String str5 ; String str6 ; String str7 ; String funStr ; funStr = STRING ; switch ( iteration % _NUM ) { case _NUM : funStr = str0 = makeString ( iteration ) ; break ; case _NUM : funStr = str1 = makeString ( iteration ) ; break ; case _NUM : funStr = str2 = makeString ( iteration ) ; break ; case _NUM : funStr = str3 = makeString ( iteration ) ; break ; case _NUM : funStr = str4 = makeString ( iteration ) ; break ; case _NUM : funStr = str5 = makeString ( iteration ) ; break ; case _NUM : funStr = str6 = makeString ( iteration ) ; break ; case _NUM : funStr = str7 = makeString ( iteration ) ; break ; } strong [ depth ] = funStr ; weak [ depth ] = new WeakReference ( funStr ) ; if ( depth + _NUM < MAX_DEPTH ) dive ( depth + _NUM , iteration + _NUM ) ; else Main . sleep ( _NUM ) ; return funStr ; }
private String dive ( int depth , int iteration ) { String str0 ; String str1 ; String str2 ; String str3 ; String str4 ; String str5 ; String str6 ; String str7 ; String funStr ; funStr = STRING ; switch ( iteration % _NUM ) { case _NUM : funStr = str0 = makeString ( iteration ) ; break ; case _NUM : funStr = str1 = makeString ( iteration ) ; break ; case _NUM : funStr = str2 = makeString ( iteration ) ; break ; case _NUM : funStr = str3 = makeString ( iteration ) ; break ; case _NUM : funStr = str4 = makeString ( iteration ) ; break ; case _NUM : funStr = str5 = makeString ( iteration ) ; break ; case _NUM : funStr = str6 = makeString ( iteration ) ; break ; case _NUM : funStr = str7 = makeString ( iteration ) ; break ; } strong [ depth ] = funStr ; weak [ depth ] = new WeakReference ( funStr ) ; if ( depth + _NUM < MAX_DEPTH ) dive ( depth + _NUM , iteration + _NUM ) ; else Main . sleep ( _NUM ) ; return funStr ; }
private String dive ( int depth , int iteration ) { String str0 ; String str1 ; String str2 ; String str3 ; String str4 ; String str5 ; String str6 ; String str7 ; String funStr ; funStr = STRING ; switch ( iteration % _NUM ) { case _NUM : funStr = str0 = makeString ( iteration ) ; break ; case _NUM : funStr = str1 = makeString ( iteration ) ; break ; case _NUM : funStr = str2 = makeString ( iteration ) ; break ; case _NUM : funStr = str3 = makeString ( iteration ) ; break ; case _NUM : funStr = str4 = makeString ( iteration ) ; break ; case _NUM : funStr = str5 = makeString ( iteration ) ; break ; case _NUM : funStr = str6 = makeString ( iteration ) ; break ; case _NUM : funStr = str7 = makeString ( iteration ) ; break ; } strong [ depth ] = funStr ; weak [ depth ] = new WeakReference ( funStr ) ; if ( depth + _NUM < MAX_DEPTH ) dive ( depth + _NUM , iteration + _NUM ) ; else Main . sleep ( _NUM ) ; return funStr ; }
private String dive ( int depth , int iteration ) { String str0 ; String str1 ; String str2 ; String str3 ; String str4 ; String str5 ; String str6 ; String str7 ; String funStr ; funStr = STRING ; switch ( iteration % _NUM ) { case _NUM : funStr = str0 = makeString ( iteration ) ; break ; case _NUM : funStr = str1 = makeString ( iteration ) ; break ; case _NUM : funStr = str2 = makeString ( iteration ) ; break ; case _NUM : funStr = str3 = makeString ( iteration ) ; break ; case _NUM : funStr = str4 = makeString ( iteration ) ; break ; case _NUM : funStr = str5 = makeString ( iteration ) ; break ; case _NUM : funStr = str6 = makeString ( iteration ) ; break ; case _NUM : funStr = str7 = makeString ( iteration ) ; break ; } strong [ depth ] = funStr ; weak [ depth ] = new WeakReference ( funStr ) ; if ( depth + _NUM < MAX_DEPTH ) dive ( depth + _NUM , iteration + _NUM ) ; else Main . sleep ( _NUM ) ; return funStr ; }
public void clear ( ) { mStrings . clear ( ) ; notifyDataSetChanged ( ) ; }
private boolean execute ( ) { final String tag = STRING + taskid + STRING ; try { if ( cancelled ) { LOG . finer ( tag + STRING ) ; return _BOOL ; } if ( ! notifyStateChange ( RUNNING , STRING ) ) { LOG . finer ( tag + STRING ) ; return _BOOL ; } scanAllDirectories ( ) ; } catch ( Exception x ) { if ( LOG . isLoggable ( Level . FINEST ) ) { LOG . log ( Level . FINEST , tag + STRING + x , x ) ; } else if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( tag + STRING + x ) ; } } return _BOOL ; }
private boolean execute ( ) { final String tag = STRING + taskid + STRING ; try { if ( cancelled ) { LOG . finer ( tag + STRING ) ; return _BOOL ; } if ( ! notifyStateChange ( RUNNING , STRING ) ) { LOG . finer ( tag + STRING ) ; return _BOOL ; } scanAllDirectories ( ) ; } catch ( Exception x ) { if ( LOG . isLoggable ( Level . FINEST ) ) { LOG . log ( Level . FINEST , tag + STRING + x , x ) ; } else if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( tag + STRING + x ) ; } } return _BOOL ; }
void checkinCommand ( Command command ) { pool . add ( command ) ; }
void checkinCommand ( Command command ) { pool . add ( command ) ; }
public JsonArray add ( JsonValue value ) { if ( value == null ) { throw new NullPointerException ( STRING ) ; } values . add ( value ) ; return this ; }
private void showSelectedNodes ( ) { final Set < NaviNode > selectedNodes = m_graph . getSelectedNodes ( ) ; final List < NaviNode > allNodes = GraphHelpers . getNodes ( m_graph ) ; allNodes . removeAll ( selectedNodes ) ; showNodes ( selectedNodes , allNodes ) ; }
private void addToFavorites ( ) { for ( String game : list . getSelectedValuesList ( ) ) { favorites . add ( game ) ; } saveFavorites ( ) ; update ( ) ; }
private void addToFavorites ( ) { for ( String game : list . getSelectedValuesList ( ) ) { favorites . add ( game ) ; } saveFavorites ( ) ; update ( ) ; }
private void fling ( int velocityY ) { if ( getChildCount ( ) > _NUM ) { int scrollRange = getScrollRange ( ) ; float topAmount = getCurrentOverScrollAmount ( _BOOL ) ; float bottomAmount = getCurrentOverScrollAmount ( _BOOL ) ; if ( velocityY < _NUM && topAmount > _NUM ) { mOwnScrollY -= ( int ) topAmount ; mDontReportNextOverScroll = _BOOL ; setOverScrollAmount ( _NUM , _BOOL , _BOOL ) ; mMaxOverScroll = Math . abs ( velocityY ) / _NUM * getRubberBandFactor ( _BOOL ) * mOverflingDistance + topAmount ; } else if ( velocityY > _NUM && bottomAmount > _NUM ) { mOwnScrollY += bottomAmount ; setOverScrollAmount ( _NUM , _BOOL , _BOOL ) ; mMaxOverScroll = Math . abs ( velocityY ) / _NUM * getRubberBandFactor ( _BOOL ) * mOverflingDistance + bottomAmount ; } else { mMaxOverScroll = _NUM ; } mScroller . fling ( getScrollX ( ) , mOwnScrollY , _NUM , velocityY , _NUM , _NUM , _NUM , Math . max ( _NUM , scrollRange ) , _NUM , Integer . MAX_VALUE / _NUM ) ; postInvalidateOnAnimation ( ) ; } }
public static synchronized void refresh ( ) throws KrbException { singleton = new Config ( ) ; KdcComm . initStatic ( ) ; EType . initStatic ( ) ; Checksum . initStatic ( ) ; }
public static synchronized void refresh ( ) throws KrbException { singleton = new Config ( ) ; KdcComm . initStatic ( ) ; EType . initStatic ( ) ; Checksum . initStatic ( ) ; }
public static synchronized void refresh ( ) throws KrbException { singleton = new Config ( ) ; KdcComm . initStatic ( ) ; EType . initStatic ( ) ; Checksum . initStatic ( ) ; }
public static synchronized void refresh ( ) throws KrbException { singleton = new Config ( ) ; KdcComm . initStatic ( ) ; EType . initStatic ( ) ; Checksum . initStatic ( ) ; }
public static synchronized void refresh ( ) throws KrbException { singleton = new Config ( ) ; KdcComm . initStatic ( ) ; EType . initStatic ( ) ; Checksum . initStatic ( ) ; }
public boolean addAllUnique ( List < Album > ps ) { boolean didChange = _BOOL ; synchronized ( mAlbums ) { for ( Album p : ps ) { if ( ! mAlbums . contains ( p ) && p . isLoaded ( ) ) { mAlbums . add ( p ) ; didChange = _BOOL ; } } if ( didChange ) { sortListLocked ( ) ; } } return didChange ; }
public final JMenuItem addItem ( JMenu menu , String key , String label , int mnemonic ) { JMenuItem item = new JMenuItem ( label ) ; if ( mnemonic != - _NUM ) { item . setMnemonic ( mnemonic ) ; } menuItems . put ( key , item ) ; item . setActionCommand ( key ) ; menu . add ( item ) ; item . addActionListener ( actionListener ) ; return item ; }
public static AnyMSeq < Integer > fromRange ( final int start , final int end ) { return AnyM . fromStream ( ReactiveSeq . range ( start , end ) ) ; }
public static AnyMSeq < Integer > fromRange ( final int start , final int end ) { return AnyM . fromStream ( ReactiveSeq . range ( start , end ) ) ; }
public static AnyMSeq < Integer > fromRange ( final int start , final int end ) { return AnyM . fromStream ( ReactiveSeq . range ( start , end ) ) ; }
public static AnyMSeq < Integer > fromRange ( final int start , final int end ) { return AnyM . fromStream ( ReactiveSeq . range ( start , end ) ) ; }
public static < T extends Writable > T clone ( T orig , Configuration conf ) { try { @ SuppressWarnings ( STRING ) T newInst = ReflectionUtils . newInstance ( ( Class < T > ) orig . getClass ( ) , conf ) ; ReflectionUtils . copy ( conf , orig , newInst ) ; return newInst ; } catch ( IOException e ) { throw new RuntimeException ( STRING , e ) ; } }
public static String removeChars ( String str , String oldchars ) { int pos = indexOfChars ( str , oldchars ) ; if ( pos == - _NUM ) { return str ; } StringBuilder buf = new StringBuilder ( ) ; int start = _NUM ; do { buf . append ( str . substring ( start , pos ) ) ; start = pos + _NUM ; pos = indexOfChars ( str , oldchars , start ) ; } while ( pos != - _NUM ) ; if ( start < str . length ( ) ) { buf . append ( str . substring ( start ) ) ; } return buf . toString ( ) ; }
public void removeProcessListener ( INodejsProcessListener listener ) { synchronized ( listeners ) { listeners . remove ( listener ) ; } }
private void balance ( ) { balanceHeights ( ) ; }
public static long nanosFromDate ( long ms ) { Calendar cal = getCalendar ( ) ; cal . setTimeInMillis ( ms ) ; return nanosFromCalendar ( cal ) ; }
public static long nanosFromDate ( long ms ) { Calendar cal = getCalendar ( ) ; cal . setTimeInMillis ( ms ) ; return nanosFromCalendar ( cal ) ; }
public static long nanosFromDate ( long ms ) { Calendar cal = getCalendar ( ) ; cal . setTimeInMillis ( ms ) ; return nanosFromCalendar ( cal ) ; }
public void registerTableNodes ( SnmpMib mib , MBeanServer server ) { tableJvmThreadInstanceTable = createJvmThreadInstanceTableMetaNode ( STRING , STRING , mib , server ) ; if ( tableJvmThreadInstanceTable != null ) { tableJvmThreadInstanceTable . registerEntryNode ( mib , server ) ; mib . registerTableMeta ( STRING , tableJvmThreadInstanceTable ) ; } }
public void copyResource ( String resourceName , File destFile ) throws IOException { copyResource ( resourceName , destFile . getPath ( ) , defaultFileHandler ) ; }
protected int countToken ( String token , String target ) { int tokenIndex = _NUM ; int count = _NUM ; while ( tokenIndex != - _NUM ) { tokenIndex = target . indexOf ( token , tokenIndex ) ; if ( tokenIndex > - _NUM ) { tokenIndex ++ ; count ++ ; } } return count ; }
protected int countToken ( String token , String target ) { int tokenIndex = _NUM ; int count = _NUM ; while ( tokenIndex != - _NUM ) { tokenIndex = target . indexOf ( token , tokenIndex ) ; if ( tokenIndex > - _NUM ) { tokenIndex ++ ; count ++ ; } } return count ; }
protected int countToken ( String token , String target ) { int tokenIndex = _NUM ; int count = _NUM ; while ( tokenIndex != - _NUM ) { tokenIndex = target . indexOf ( token , tokenIndex ) ; if ( tokenIndex > - _NUM ) { tokenIndex ++ ; count ++ ; } } return count ; }
protected int countToken ( String token , String target ) { int tokenIndex = _NUM ; int count = _NUM ; while ( tokenIndex != - _NUM ) { tokenIndex = target . indexOf ( token , tokenIndex ) ; if ( tokenIndex > - _NUM ) { tokenIndex ++ ; count ++ ; } } return count ; }
@ Override public void emitTuple ( Object tuple ) { outputPort . emit ( tuple ) ; }
public StringList plus ( String ... args ) { StringList newList = new StringList ( ) ; newList . addAll ( this ) ; newList . addAll ( Arrays . asList ( args ) ) ; return newList ; }
public void addDependency ( DbObject obj ) { dependencies . add ( obj ) ; }
public void testCanHandleZeroOrMore ( ) throws Exception { Dtd dtd = new Dtd ( STRING ) ; List < DescriptorTag > elementOrder = dtd . getElementOrder ( STRING ) ; assertEquals ( _NUM , elementOrder . size ( ) ) ; DescriptorTag tag = elementOrder . get ( _NUM ) ; assertEquals ( STRING , tag . getTagName ( ) ) ; assertFalse ( tag . isMultipleAllowed ( ) ) ; tag = elementOrder . get ( _NUM ) ; assertEquals ( STRING , tag . getTagName ( ) ) ; assertFalse ( tag . isMultipleAllowed ( ) ) ; tag = elementOrder . get ( _NUM ) ; assertEquals ( STRING , tag . getTagName ( ) ) ; assertTrue ( tag . isMultipleAllowed ( ) ) ; tag = elementOrder . get ( _NUM ) ; assertEquals ( STRING , tag . getTagName ( ) ) ; assertTrue ( tag . isMultipleAllowed ( ) ) ; }
private ConcurrentSkipListMap . Node < K , V > loNode ( ) { if ( lo == null ) return m . findFirst ( ) ; else if ( loInclusive ) return m . findNear ( lo , GT | EQ ) ; else return m . findNear ( lo , GT ) ; }
private ConcurrentSkipListMap . Node < K , V > loNode ( ) { if ( lo == null ) return m . findFirst ( ) ; else if ( loInclusive ) return m . findNear ( lo , GT | EQ ) ; else return m . findNear ( lo , GT ) ; }
private ConcurrentSkipListMap . Node < K , V > loNode ( ) { if ( lo == null ) return m . findFirst ( ) ; else if ( loInclusive ) return m . findNear ( lo , GT | EQ ) ; else return m . findNear ( lo , GT ) ; }
public Node ( final char [ ] a , final int offset , final int length , final boolean isWord , final int numNodes ) { path = new char [ length ] ; System . arraycopy ( a , offset , path , _NUM , length ) ; this . isWord = isWord ; this . numNodes = numNodes ; }
public Node ( final char [ ] a , final int offset , final int length , final boolean isWord , final int numNodes ) { path = new char [ length ] ; System . arraycopy ( a , offset , path , _NUM , length ) ; this . isWord = isWord ; this . numNodes = numNodes ; }
private void abortWithError ( @ NonNull String msg , @ NonNull Element e ) { reportError ( msg , e ) ; throw new AbortProcessingException ( ) ; }
private void abortWithError ( @ NonNull String msg , @ NonNull Element e ) { reportError ( msg , e ) ; throw new AbortProcessingException ( ) ; }
private void abortWithError ( @ NonNull String msg , @ NonNull Element e ) { reportError ( msg , e ) ; throw new AbortProcessingException ( ) ; }
private void drawMap ( final Graphics g ) { g . drawImage ( mapImage , _NUM , _NUM , null ) ; }
boolean containsArguments ( ) { return ! args . isEmpty ( ) ; }
boolean containsArguments ( ) { return ! args . isEmpty ( ) ; }
boolean containsArguments ( ) { return ! args . isEmpty ( ) ; }
private void consume ( ) { curCharIndex ++ ; curChar = ( curCharIndex == pattern . length ( ) ) ? EOF : pattern . charAt ( curCharIndex ) ; }
private void consume ( ) { curCharIndex ++ ; curChar = ( curCharIndex == pattern . length ( ) ) ? EOF : pattern . charAt ( curCharIndex ) ; }
private void consume ( ) { curCharIndex ++ ; curChar = ( curCharIndex == pattern . length ( ) ) ? EOF : pattern . charAt ( curCharIndex ) ; }
public static void writeElement ( final XMLStreamWriter writer , final String elementName , final String [ ] value ) throws XMLStreamException { if ( value == null || value . length == _NUM ) { return ; } writer . writeStartElement ( elementName ) ; for ( int i = _NUM ; i < value . length ; i ++ ) { writer . writeStartElement ( STRING ) ; writer . writeCharacters ( value [ i ] ) ; writer . writeEndElement ( ) ; } writer . writeEndElement ( ) ; }
private void stretchViewVertically ( View view , int crossSize ) { LayoutParams lp = ( LayoutParams ) view . getLayoutParams ( ) ; int newHeight = crossSize - lp . topMargin - lp . bottomMargin ; newHeight = Math . max ( newHeight , _NUM ) ; view . measure ( MeasureSpec . makeMeasureSpec ( view . getMeasuredWidth ( ) , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( newHeight , MeasureSpec . EXACTLY ) ) ; }
private void stretchViewVertically ( View view , int crossSize ) { LayoutParams lp = ( LayoutParams ) view . getLayoutParams ( ) ; int newHeight = crossSize - lp . topMargin - lp . bottomMargin ; newHeight = Math . max ( newHeight , _NUM ) ; view . measure ( MeasureSpec . makeMeasureSpec ( view . getMeasuredWidth ( ) , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( newHeight , MeasureSpec . EXACTLY ) ) ; }
public void addPoint ( Location location ) { points . add ( location ) ; }
public List < IdentityDetails > searchIdentityDetails ( CrestQuery crestQuery , Map < String , Set < String > > searchModifiers , SSOToken admin ) throws ResourceException { try { String realm = STRING ; String objectType = STRING ; if ( searchModifiers != null ) { realm = attractValues ( STRING , searchModifiers , STRING ) ; objectType = attractValues ( STRING , searchModifiers , STRING ) ; } AMIdentityRepository repo = getRepo ( admin , realm ) ; IdType idType = getIdType ( objectType ) ; if ( idType != null ) { List < AMIdentity > identities = fetchAMIdentities ( idType , crestQuery , _BOOL , repo , searchModifiers ) ; List < IdentityDetails > result = new ArrayList < > ( ) ; for ( AMIdentity identity : identities ) { result . add ( convertToIdentityDetails ( identity , null ) ) ; } return result ; } debug . error ( STRING + objectType ) ; throw new BadRequestException ( STRING + objectType ) ; } catch ( IdRepoException e ) { debug . error ( STRING , e ) ; throw new InternalServerErrorException ( e . getMessage ( ) ) ; } catch ( SSOException e ) { debug . error ( STRING , e ) ; throw new InternalServerErrorException ( e . getMessage ( ) ) ; } catch ( ObjectNotFound e ) { debug . error ( STRING , e ) ; throw new NotFoundException ( e . getMessage ( ) ) ; } }
public void event ( String event , String parameter , long duration ) { logEntries . add ( new EventEntry ( event , parameter , duration ) ) ; }
private < T > T performWithoutMissingBundlePool ( Supplier < T > supplier ) { createBundlePoolIfNecessary ( ) ; return supplier . get ( ) ; }
private < T > T performWithoutMissingBundlePool ( Supplier < T > supplier ) { createBundlePoolIfNecessary ( ) ; return supplier . get ( ) ; }
private < T > T performWithoutMissingBundlePool ( Supplier < T > supplier ) { createBundlePoolIfNecessary ( ) ; return supplier . get ( ) ; }
private < T > T performWithoutMissingBundlePool ( Supplier < T > supplier ) { createBundlePoolIfNecessary ( ) ; return supplier . get ( ) ; }
public Vector ( int capacity , int capacityIncrement ) { if ( capacity < _NUM ) { throw new IllegalArgumentException ( ) ; } elementData = newElementArray ( capacity ) ; elementCount = _NUM ; this . capacityIncrement = capacityIncrement ; }
public Vector ( int capacity , int capacityIncrement ) { if ( capacity < _NUM ) { throw new IllegalArgumentException ( ) ; } elementData = newElementArray ( capacity ) ; elementCount = _NUM ; this . capacityIncrement = capacityIncrement ; }
public Vector ( int capacity , int capacityIncrement ) { if ( capacity < _NUM ) { throw new IllegalArgumentException ( ) ; } elementData = newElementArray ( capacity ) ; elementCount = _NUM ; this . capacityIncrement = capacityIncrement ; }
private synchronized void startUpdateThread ( ) { if ( screenUpdater == null ) { screenUpdater = AccessController . doPrivileged ( ( PrivilegedAction < Thread > ) null ) ; screenUpdater . start ( ) ; } else { wakeUpUpdateThread ( ) ; } }
public void stopEnumeration ( EnumerationDeletionContext aws ) { aws . computeEnumerationRequest . enumerationAction = EnumerationAction . STOP ; handleEnumerationRequestForDeletion ( aws ) ; }
public void stopEnumeration ( EnumerationDeletionContext aws ) { aws . computeEnumerationRequest . enumerationAction = EnumerationAction . STOP ; handleEnumerationRequestForDeletion ( aws ) ; }
public void stopEnumeration ( EnumerationDeletionContext aws ) { aws . computeEnumerationRequest . enumerationAction = EnumerationAction . STOP ; handleEnumerationRequestForDeletion ( aws ) ; }
public void stopEnumeration ( EnumerationDeletionContext aws ) { aws . computeEnumerationRequest . enumerationAction = EnumerationAction . STOP ; handleEnumerationRequestForDeletion ( aws ) ; }
public void stopEnumeration ( EnumerationDeletionContext aws ) { aws . computeEnumerationRequest . enumerationAction = EnumerationAction . STOP ; handleEnumerationRequestForDeletion ( aws ) ; }
public byte [ ] encodeToBitcoin ( ) { try { ByteArrayOutputStream bos = derByteStream ( ) ; bos . write ( sighashFlags ) ; return bos . toByteArray ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public byte [ ] encodeToBitcoin ( ) { try { ByteArrayOutputStream bos = derByteStream ( ) ; bos . write ( sighashFlags ) ; return bos . toByteArray ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public byte [ ] encodeToBitcoin ( ) { try { ByteArrayOutputStream bos = derByteStream ( ) ; bos . write ( sighashFlags ) ; return bos . toByteArray ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public byte [ ] encodeToBitcoin ( ) { try { ByteArrayOutputStream bos = derByteStream ( ) ; bos . write ( sighashFlags ) ; return bos . toByteArray ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public byte [ ] encodeToBitcoin ( ) { try { ByteArrayOutputStream bos = derByteStream ( ) ; bos . write ( sighashFlags ) ; return bos . toByteArray ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public byte [ ] encodeToBitcoin ( ) { try { ByteArrayOutputStream bos = derByteStream ( ) ; bos . write ( sighashFlags ) ; return bos . toByteArray ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
private void loadButtonText ( AbstractButton component , String text ) { StringBuffer result = new StringBuffer ( ) ; boolean haveMnemonic = _BOOL ; char mnemonic = STRING ; int mnemonicIndex = - _NUM ; for ( int i = _NUM ; i < text . length ( ) ; i ++ ) { if ( text . charAt ( i ) == STRING ) { i ++ ; if ( i == text . length ( ) ) { break ; } if ( ! haveMnemonic && text . charAt ( i ) != STRING ) { haveMnemonic = _BOOL ; mnemonic = text . charAt ( i ) ; mnemonicIndex = result . length ( ) ; } } result . append ( text . charAt ( i ) ) ; } component . setText ( result . toString ( ) ) ; if ( haveMnemonic ) { component . setMnemonic ( mnemonic ) ; component . setDisplayedMnemonicIndex ( mnemonicIndex ) ; } }
public static void sendResponseWithStatus ( HttpServletRequest request , HttpServletResponse response , PrintWriter out , String idpMetaAlias , String idpEntityID , String realm , AuthnRequest authnReq , String relayState , String spEntityID , String firstlevelStatusCodeValue , String secondlevelStatusCodeValue ) throws SAML2Exception { Response res = SAML2Utils . getErrorResponse ( authnReq , firstlevelStatusCodeValue , secondlevelStatusCodeValue , null , idpEntityID ) ; StringBuffer returnedBinding = new StringBuffer ( ) ; String acsURL = IDPSSOUtil . getACSurl ( spEntityID , realm , authnReq , request , returnedBinding ) ; String acsBinding = returnedBinding . toString ( ) ; sendResponse ( request , response , out , acsBinding , spEntityID , idpEntityID , idpMetaAlias , realm , relayState , acsURL , res , null ) ; }
public static void sendResponseWithStatus ( HttpServletRequest request , HttpServletResponse response , PrintWriter out , String idpMetaAlias , String idpEntityID , String realm , AuthnRequest authnReq , String relayState , String spEntityID , String firstlevelStatusCodeValue , String secondlevelStatusCodeValue ) throws SAML2Exception { Response res = SAML2Utils . getErrorResponse ( authnReq , firstlevelStatusCodeValue , secondlevelStatusCodeValue , null , idpEntityID ) ; StringBuffer returnedBinding = new StringBuffer ( ) ; String acsURL = IDPSSOUtil . getACSurl ( spEntityID , realm , authnReq , request , returnedBinding ) ; String acsBinding = returnedBinding . toString ( ) ; sendResponse ( request , response , out , acsBinding , spEntityID , idpEntityID , idpMetaAlias , realm , relayState , acsURL , res , null ) ; }
public static void logError ( String logEntry ) { }
public static void logError ( String logEntry ) { }
public static void logError ( String logEntry ) { }
final int rllong ( DataInputStream dis ) throws IOException { int b1 , b2 , b3 , b4 ; int i = _NUM ; i = dis . readInt ( ) ; b1 = ( i & _NUM ) << _NUM ; b2 = ( i & _NUM ) << _NUM ; b3 = ( i & _NUM ) > > _NUM ; b4 = ( i & _NUM ) > > > _NUM ; i = ( b1 | b2 | b3 | b4 ) ; return i ; }
final int rllong ( DataInputStream dis ) throws IOException { int b1 , b2 , b3 , b4 ; int i = _NUM ; i = dis . readInt ( ) ; b1 = ( i & _NUM ) << _NUM ; b2 = ( i & _NUM ) << _NUM ; b3 = ( i & _NUM ) > > _NUM ; b4 = ( i & _NUM ) > > > _NUM ; i = ( b1 | b2 | b3 | b4 ) ; return i ; }
private static String prependIfMissing ( final String str , final CharSequence prefix , final boolean ignoreCase , final CharSequence ... prefixes ) { if ( str == null || isEmpty ( prefix ) || startsWith ( str , prefix , ignoreCase ) ) { return str ; } if ( prefixes != null && prefixes . length > _NUM ) { for ( final CharSequence p : prefixes ) { if ( startsWith ( str , p , ignoreCase ) ) { return str ; } } } return prefix . toString ( ) + str ; }
public WaveWriter ( AudioFormat format , Path file , long maxSize ) throws IOException { assert ( format != null ) ; assert ( file != null ) ; mAudioFormat = format ; mFile = file ; if ( _NUM < maxSize && maxSize <= MAX_WAVE_SIZE ) { mMaxSize = maxSize ; } else { mMaxSize = MAX_WAVE_SIZE ; } open ( ) ; }
public WaveWriter ( AudioFormat format , Path file , long maxSize ) throws IOException { assert ( format != null ) ; assert ( file != null ) ; mAudioFormat = format ; mFile = file ; if ( _NUM < maxSize && maxSize <= MAX_WAVE_SIZE ) { mMaxSize = maxSize ; } else { mMaxSize = MAX_WAVE_SIZE ; } open ( ) ; }
public WaveWriter ( AudioFormat format , Path file , long maxSize ) throws IOException { assert ( format != null ) ; assert ( file != null ) ; mAudioFormat = format ; mFile = file ; if ( _NUM < maxSize && maxSize <= MAX_WAVE_SIZE ) { mMaxSize = maxSize ; } else { mMaxSize = MAX_WAVE_SIZE ; } open ( ) ; }
private void globalAccelFromMenu ( MenuElement me ) { for ( MenuElement element : me . getSubElements ( ) ) { if ( ( element instanceof JPopupMenu ) || ( element instanceof JMenu ) ) { globalAccelFromMenu ( element ) ; } else if ( element instanceof JMenuItem ) { JMenuItem item = ( JMenuItem ) element ; if ( item . getAccelerator ( ) != null ) { actionListenerMap . put ( item . getAccelerator ( ) , item . getActionListeners ( ) ) ; } } } }
private void globalAccelFromMenu ( MenuElement me ) { for ( MenuElement element : me . getSubElements ( ) ) { if ( ( element instanceof JPopupMenu ) || ( element instanceof JMenu ) ) { globalAccelFromMenu ( element ) ; } else if ( element instanceof JMenuItem ) { JMenuItem item = ( JMenuItem ) element ; if ( item . getAccelerator ( ) != null ) { actionListenerMap . put ( item . getAccelerator ( ) , item . getActionListeners ( ) ) ; } } } }
private void globalAccelFromMenu ( MenuElement me ) { for ( MenuElement element : me . getSubElements ( ) ) { if ( ( element instanceof JPopupMenu ) || ( element instanceof JMenu ) ) { globalAccelFromMenu ( element ) ; } else if ( element instanceof JMenuItem ) { JMenuItem item = ( JMenuItem ) element ; if ( item . getAccelerator ( ) != null ) { actionListenerMap . put ( item . getAccelerator ( ) , item . getActionListeners ( ) ) ; } } } }
private void globalAccelFromMenu ( MenuElement me ) { for ( MenuElement element : me . getSubElements ( ) ) { if ( ( element instanceof JPopupMenu ) || ( element instanceof JMenu ) ) { globalAccelFromMenu ( element ) ; } else if ( element instanceof JMenuItem ) { JMenuItem item = ( JMenuItem ) element ; if ( item . getAccelerator ( ) != null ) { actionListenerMap . put ( item . getAccelerator ( ) , item . getActionListeners ( ) ) ; } } } }
public DataSet ( List < T > yVals , String label ) { super ( label ) ; this . mYVals = yVals ; if ( mYVals == null ) mYVals = new ArrayList < > ( ) ; calcMinMax ( _NUM , mYVals . size ( ) ) ; }
public DataSet ( List < T > yVals , String label ) { super ( label ) ; this . mYVals = yVals ; if ( mYVals == null ) mYVals = new ArrayList < > ( ) ; calcMinMax ( _NUM , mYVals . size ( ) ) ; }
public DataSet ( List < T > yVals , String label ) { super ( label ) ; this . mYVals = yVals ; if ( mYVals == null ) mYVals = new ArrayList < > ( ) ; calcMinMax ( _NUM , mYVals . size ( ) ) ; }
public DataSet ( List < T > yVals , String label ) { super ( label ) ; this . mYVals = yVals ; if ( mYVals == null ) mYVals = new ArrayList < > ( ) ; calcMinMax ( _NUM , mYVals . size ( ) ) ; }
private void computeClosure ( ) { for ( Enumeration < GraphNode > e = enumerateVertices ( ) ; e . hasMoreElements ( ) ; ) { ValueGraphVertex v = ( ValueGraphVertex ) e . nextElement ( ) ; if ( v . getName ( ) instanceof Register ) { if ( v . getLabel ( ) instanceof Register ) { if ( v . getName ( ) != v . getLabel ( ) ) { ValueGraphVertex v2 = getVertex ( v . getLabel ( ) ) ; if ( VM . VerifyAssertions ) { if ( v2 . getName ( ) instanceof Register && v2 . getLabel ( ) instanceof Register && v2 . getLabel ( ) != v2 . getName ( ) ) { VM . _assert ( VM . NOT_REACHED ) ; } } v . copyVertex ( v2 ) ; } } } } }
private void computeClosure ( ) { for ( Enumeration < GraphNode > e = enumerateVertices ( ) ; e . hasMoreElements ( ) ; ) { ValueGraphVertex v = ( ValueGraphVertex ) e . nextElement ( ) ; if ( v . getName ( ) instanceof Register ) { if ( v . getLabel ( ) instanceof Register ) { if ( v . getName ( ) != v . getLabel ( ) ) { ValueGraphVertex v2 = getVertex ( v . getLabel ( ) ) ; if ( VM . VerifyAssertions ) { if ( v2 . getName ( ) instanceof Register && v2 . getLabel ( ) instanceof Register && v2 . getLabel ( ) != v2 . getName ( ) ) { VM . _assert ( VM . NOT_REACHED ) ; } } v . copyVertex ( v2 ) ; } } } } }
public static void addSearchAlgorithm ( String name , SearchForActions algo ) { SEARCH_NAMES . add ( name ) ; SEARCH_ALGOS . add ( algo ) ; }
public void saveData ( File file ) throws IOException { synchronized ( accumulators ) { ObjectOutputStream oos = null ; try { oos = new ObjectOutputStream ( new FileOutputStream ( file ) ) ; oos . writeObject ( accumulators ) ; } finally { if ( oos != null ) { oos . close ( ) ; } } } }
public void saveData ( File file ) throws IOException { synchronized ( accumulators ) { ObjectOutputStream oos = null ; try { oos = new ObjectOutputStream ( new FileOutputStream ( file ) ) ; oos . writeObject ( accumulators ) ; } finally { if ( oos != null ) { oos . close ( ) ; } } } }
static void putCircleOfTrust ( String realm , String name , CircleOfTrustDescriptor cotDescriptor ) { String classMethod = STRING ; String cacheKey = buildCacheKey ( realm , name ) ; if ( debug . messageEnabled ( ) ) { debug . message ( classMethod + STRING + cacheKey ) ; } cotCache . put ( cacheKey , cotDescriptor ) ; }
protected void writeNetscapeExt ( ) throws IOException { out . write ( _NUM ) ; out . write ( _NUM ) ; out . write ( _NUM ) ; writeString ( STRING + STRING ) ; out . write ( _NUM ) ; out . write ( _NUM ) ; writeShort ( repeat ) ; out . write ( _NUM ) ; }
@ Override public int compareTo ( DoubleIntPair other ) { int fdiff = Double . compare ( this . first , other . first ) ; if ( fdiff != _NUM ) { return fdiff ; } return this . second - other . second ; }
public static void add ( ClassFileTransformer t ) { synchronized ( transformers ) { transformers . add ( t ) ; } }
public void updateViewport ( ) { setToOrtho ( _BOOL , virtualViewport . getWidth ( ) , virtualViewport . getHeight ( ) ) ; }
public void updateViewport ( ) { setToOrtho ( _BOOL , virtualViewport . getWidth ( ) , virtualViewport . getHeight ( ) ) ; }
public static String extractRequestedDomainName ( final String requestURL ) { final int domainNameStartIndex = requestURL . indexOf ( STRING ) + _NUM ; String domainName = requestURL . substring ( domainNameStartIndex , requestURL . indexOf ( STRING , domainNameStartIndex ) ) ; if ( domainName . contains ( STRING ) ) domainName = domainName . split ( STRING ) [ _NUM ] ; return domainName ; }
public Object loadNativeFont ( String lookup ) { try { lookup = lookup . split ( STRING ) [ _NUM ] ; int typeface = Typeface . NORMAL ; String familyName = lookup . substring ( _NUM , lookup . indexOf ( STRING ) ) ; String style = lookup . substring ( lookup . indexOf ( STRING ) + _NUM , lookup . lastIndexOf ( STRING ) ) ; String size = lookup . substring ( lookup . lastIndexOf ( STRING ) + _NUM , lookup . length ( ) ) ; if ( style . equals ( STRING ) ) { typeface = Typeface . BOLD_ITALIC ; } else if ( style . equals ( STRING ) ) { typeface = Typeface . ITALIC ; } else if ( style . equals ( STRING ) ) { typeface = Typeface . BOLD ; } Paint font = new CodenameOneTextPaint ( Typeface . create ( familyName , typeface ) ) ; font . setAntiAlias ( _BOOL ) ; font . setTextSize ( Integer . parseInt ( size ) ) ; return new NativeFont ( _NUM , _NUM , _NUM , font ) ; } catch ( Exception err ) { return null ; } }
public Object loadNativeFont ( String lookup ) { try { lookup = lookup . split ( STRING ) [ _NUM ] ; int typeface = Typeface . NORMAL ; String familyName = lookup . substring ( _NUM , lookup . indexOf ( STRING ) ) ; String style = lookup . substring ( lookup . indexOf ( STRING ) + _NUM , lookup . lastIndexOf ( STRING ) ) ; String size = lookup . substring ( lookup . lastIndexOf ( STRING ) + _NUM , lookup . length ( ) ) ; if ( style . equals ( STRING ) ) { typeface = Typeface . BOLD_ITALIC ; } else if ( style . equals ( STRING ) ) { typeface = Typeface . ITALIC ; } else if ( style . equals ( STRING ) ) { typeface = Typeface . BOLD ; } Paint font = new CodenameOneTextPaint ( Typeface . create ( familyName , typeface ) ) ; font . setAntiAlias ( _BOOL ) ; font . setTextSize ( Integer . parseInt ( size ) ) ; return new NativeFont ( _NUM , _NUM , _NUM , font ) ; } catch ( Exception err ) { return null ; } }
public Object loadNativeFont ( String lookup ) { try { lookup = lookup . split ( STRING ) [ _NUM ] ; int typeface = Typeface . NORMAL ; String familyName = lookup . substring ( _NUM , lookup . indexOf ( STRING ) ) ; String style = lookup . substring ( lookup . indexOf ( STRING ) + _NUM , lookup . lastIndexOf ( STRING ) ) ; String size = lookup . substring ( lookup . lastIndexOf ( STRING ) + _NUM , lookup . length ( ) ) ; if ( style . equals ( STRING ) ) { typeface = Typeface . BOLD_ITALIC ; } else if ( style . equals ( STRING ) ) { typeface = Typeface . ITALIC ; } else if ( style . equals ( STRING ) ) { typeface = Typeface . BOLD ; } Paint font = new CodenameOneTextPaint ( Typeface . create ( familyName , typeface ) ) ; font . setAntiAlias ( _BOOL ) ; font . setTextSize ( Integer . parseInt ( size ) ) ; return new NativeFont ( _NUM , _NUM , _NUM , font ) ; } catch ( Exception err ) { return null ; } }
public void addResponse ( Response response ) { responseVector . addElement ( response ) ; }
static private String calcThreshold ( double scoreThreshold , double lambda ) { final double logProbThreshold = Math . log ( _NUM - scoreThreshold / _NUM ) ; int maxNum = _NUM ; if ( calcLogProb ( maxNum , lambda ) > logProbThreshold ) { return STRING ; } int minNum = _NUM ; while ( minNum < maxNum ) { final int midNum = ( maxNum + minNum ) / _NUM ; final boolean passThreshold = calcLogProb ( midNum , lambda ) <= logProbThreshold ; if ( passThreshold ) { maxNum = midNum ; } else { if ( midNum == minNum ) { break ; } minNum = midNum ; } } return Integer . toString ( maxNum ) ; }
private static String [ ] appendEnabled ( final String [ ] options ) { for ( final String option : options ) { if ( option . equals ( STRING ) ) { return options ; } } String [ ] result = new String [ options . length + _NUM ] ; result [ _NUM ] = STRING ; System . arraycopy ( options , _NUM , result , _NUM , options . length ) ; return result ; }
private static String [ ] appendEnabled ( final String [ ] options ) { for ( final String option : options ) { if ( option . equals ( STRING ) ) { return options ; } } String [ ] result = new String [ options . length + _NUM ] ; result [ _NUM ] = STRING ; System . arraycopy ( options , _NUM , result , _NUM , options . length ) ; return result ; }
public static void sign ( File jadFile , File jarFile , RSAPrivateKey privateKey , X509Certificate [ ] certificateChain , int certificateNumber ) throws IOException , CryptoException { File tmpFile = File . createTempFile ( STRING , STRING ) ; tmpFile . deleteOnExit ( ) ; sign ( jadFile , tmpFile , jarFile , privateKey , certificateChain , certificateNumber ) ; CopyUtil . copyClose ( new FileInputStream ( tmpFile ) , new FileOutputStream ( jadFile ) ) ; tmpFile . delete ( ) ; }
public static void sign ( File jadFile , File jarFile , RSAPrivateKey privateKey , X509Certificate [ ] certificateChain , int certificateNumber ) throws IOException , CryptoException { File tmpFile = File . createTempFile ( STRING , STRING ) ; tmpFile . deleteOnExit ( ) ; sign ( jadFile , tmpFile , jarFile , privateKey , certificateChain , certificateNumber ) ; CopyUtil . copyClose ( new FileInputStream ( tmpFile ) , new FileOutputStream ( jadFile ) ) ; tmpFile . delete ( ) ; }
public void store ( Document document , String pathToParent , String elementName ) throws XMLException { Element parent = ( Element ) DocUtil . evalXPathAsNode ( document , pathToParent ) ; BeanConverter converter = new BeanConverter ( this , document ) ; Element elem = converter . createElement ( elementName ) ; parent . appendChild ( elem ) ; }
public static void delete ( String path ) { if ( path != null ) delete ( Paths . get ( path ) ) ; }
public static void delete ( String path ) { if ( path != null ) delete ( Paths . get ( path ) ) ; }
public static void delete ( String path ) { if ( path != null ) delete ( Paths . get ( path ) ) ; }
public static void delete ( String path ) { if ( path != null ) delete ( Paths . get ( path ) ) ; }
public static Byte toByte ( Object o , Byte defaultValue ) { if ( o instanceof Byte ) return ( Byte ) o ; if ( defaultValue != null ) return new Byte ( toByteValue ( o , defaultValue . byteValue ( ) ) ) ; byte res = toByteValue ( o , Byte . MIN_VALUE ) ; if ( res == Byte . MIN_VALUE ) return defaultValue ; return new Byte ( res ) ; }
public static Byte toByte ( Object o , Byte defaultValue ) { if ( o instanceof Byte ) return ( Byte ) o ; if ( defaultValue != null ) return new Byte ( toByteValue ( o , defaultValue . byteValue ( ) ) ) ; byte res = toByteValue ( o , Byte . MIN_VALUE ) ; if ( res == Byte . MIN_VALUE ) return defaultValue ; return new Byte ( res ) ; }
private static AnalysisResult checkAllAppearances ( Register reg , IR ir ) { return new AnalysisResult ( ! checkIfUseEscapesThread ( reg , ir , null ) , ! checkIfUseEscapesMethod ( reg , ir , null ) ) ; }
private static AnalysisResult checkAllAppearances ( Register reg , IR ir ) { return new AnalysisResult ( ! checkIfUseEscapesThread ( reg , ir , null ) , ! checkIfUseEscapesMethod ( reg , ir , null ) ) ; }
private void clearOutput ( ) { if ( currentOutput != null ) { out . println ( ) ; } currentOutput = null ; }
void refreshUI ( String xml , DOMTree m_tree ) { if ( ( xml == null ) || xml . equals ( STRING ) ) { setErrorMessage ( STRING , STRING ) ; return ; } final Document newRoot = getRoot ( xml ) ; if ( newRoot == null ) { setErrorMessage ( STRING , STRING ) ; return ; } m_tree . setDocument ( newRoot ) ; }
void refreshUI ( String xml , DOMTree m_tree ) { if ( ( xml == null ) || xml . equals ( STRING ) ) { setErrorMessage ( STRING , STRING ) ; return ; } final Document newRoot = getRoot ( xml ) ; if ( newRoot == null ) { setErrorMessage ( STRING , STRING ) ; return ; } m_tree . setDocument ( newRoot ) ; }
public Address ( final long value ) { m_value = BigInteger . valueOf ( value ) ; }
public SeaGlassTabbedPaneMouseHandler ( MouseListener originalMouseListener ) { delegate = originalMouseListener ; delegate2 = ( MouseMotionListener ) originalMouseListener ; closeButtonHoverIndex = - _NUM ; closeButtonArmedIndex = - _NUM ; }
@ Override public InetSocketAddress ipLocal ( ) { Socket s = getSocket ( ) ; if ( s != null ) { return ( InetSocketAddress ) s . getLocalSocketAddress ( ) ; } else { return null ; } }
@ Override public InetSocketAddress ipLocal ( ) { Socket s = getSocket ( ) ; if ( s != null ) { return ( InetSocketAddress ) s . getLocalSocketAddress ( ) ; } else { return null ; } }
@ SuppressWarnings ( STRING ) public static < K > ImmutableArray2 < K > empty ( ) { return ( ImmutableArray2 < K > ) EMPTY ; }
boolean removeTab ( Tab t ) { if ( t == null ) { return _BOOL ; } Tab current = getCurrentTab ( ) ; mTabs . remove ( t ) ; mTabCountObservable . set ( mTabs . size ( ) ) ; if ( t . isPrivateBrowsingEnabled ( ) ) { mNumIncognito -= _NUM ; if ( mNumIncognito == _NUM ) { GeolocationPermissions . onIncognitoTabsRemoved ( ) ; Engine . destroyIncognitoProfile ( ) ; } } if ( current == t ) { t . putInBackground ( ) ; mCurrentTab = - _NUM ; } else { mCurrentTab = getTabPosition ( current ) ; } t . destroy ( ) ; t . removeFromTree ( ) ; mTabQueue . remove ( t ) ; return _BOOL ; }
private static int uarimaxGt ( double value , double [ ] bv , int bvi [ ] , BinaryOperator bOp ) throws DMLRuntimeException { int ixMax = bv . length ; if ( value <= bv [ _NUM ] || value > bv [ bv . length - _NUM ] ) return ixMax ; int ix = Arrays . binarySearch ( bv , value ) ; ix = Math . abs ( ix ) - _NUM ; ixMax = bvi [ ix - _NUM ] + _NUM ; return ixMax ; }
public LTRPulseShapingFilter ( ) { mBuffer = new BitSet ( ) ; mBuffer . clear ( ) ; }
public LTRPulseShapingFilter ( ) { mBuffer = new BitSet ( ) ; mBuffer . clear ( ) ; }
public LTRPulseShapingFilter ( ) { mBuffer = new BitSet ( ) ; mBuffer . clear ( ) ; }
public LTRPulseShapingFilter ( ) { mBuffer = new BitSet ( ) ; mBuffer . clear ( ) ; }
@ SuppressWarnings ( STRING ) public static < T > Sequence < T > wrapEnd ( Sequence < T > sequence , T endToken ) { Object [ ] arr = new Object [ sequence . size ( ) + _NUM ] ; System . arraycopy ( sequence . elements ( ) , _NUM , arr , _NUM , sequence . size ( ) ) ; arr [ sequence . size ( ) ] = endToken ; return new ArraySequence < T > ( _BOOL , ( T [ ] ) arr ) ; }
public String replace ( char oldChar , char newChar ) { char [ ] buffer = value ; int _offset = offset ; int _count = count ; int idx = _offset ; int last = _offset + _count ; boolean copied = _BOOL ; while ( idx < last ) { if ( buffer [ idx ] == oldChar ) { if ( ! copied ) { char [ ] newBuffer = new char [ _count ] ; System . arraycopy ( buffer , _offset , newBuffer , _NUM , _count ) ; buffer = newBuffer ; idx -= _offset ; last -= _offset ; copied = _BOOL ; } buffer [ idx ] = newChar ; } idx ++ ; } return copied ? new String ( _NUM , count , buffer ) : this ; }
public String replace ( char oldChar , char newChar ) { char [ ] buffer = value ; int _offset = offset ; int _count = count ; int idx = _offset ; int last = _offset + _count ; boolean copied = _BOOL ; while ( idx < last ) { if ( buffer [ idx ] == oldChar ) { if ( ! copied ) { char [ ] newBuffer = new char [ _count ] ; System . arraycopy ( buffer , _offset , newBuffer , _NUM , _count ) ; buffer = newBuffer ; idx -= _offset ; last -= _offset ; copied = _BOOL ; } buffer [ idx ] = newChar ; } idx ++ ; } return copied ? new String ( _NUM , count , buffer ) : this ; }
private static Map < String , SoInfo > findProvidedLibraries ( JarFile apk ) { Pattern libPattern = Pattern . compile ( STRING ) ; HashMap < String , SoInfo > providedLibraries = new HashMap < > ( ) ; String [ ] supportedAbis = SysUtil . getSupportedAbis ( ) ; Enumeration < JarEntry > entries = apk . entries ( ) ; while ( entries . hasMoreElements ( ) ) { JarEntry entry = entries . nextElement ( ) ; Matcher m = libPattern . matcher ( entry . getName ( ) ) ; if ( m . matches ( ) ) { String libraryAbi = m . group ( _NUM ) ; String soName = m . group ( _NUM ) ; int abiScore = SysUtil . findAbiScore ( supportedAbis , libraryAbi ) ; if ( abiScore >= _NUM ) { SoInfo so = providedLibraries . get ( soName ) ; if ( so == null || abiScore < so . abiScore ) { providedLibraries . put ( soName , new SoInfo ( soName , entry , abiScore ) ) ; } } } } return providedLibraries ; }
private static Map < String , SoInfo > findProvidedLibraries ( JarFile apk ) { Pattern libPattern = Pattern . compile ( STRING ) ; HashMap < String , SoInfo > providedLibraries = new HashMap < > ( ) ; String [ ] supportedAbis = SysUtil . getSupportedAbis ( ) ; Enumeration < JarEntry > entries = apk . entries ( ) ; while ( entries . hasMoreElements ( ) ) { JarEntry entry = entries . nextElement ( ) ; Matcher m = libPattern . matcher ( entry . getName ( ) ) ; if ( m . matches ( ) ) { String libraryAbi = m . group ( _NUM ) ; String soName = m . group ( _NUM ) ; int abiScore = SysUtil . findAbiScore ( supportedAbis , libraryAbi ) ; if ( abiScore >= _NUM ) { SoInfo so = providedLibraries . get ( soName ) ; if ( so == null || abiScore < so . abiScore ) { providedLibraries . put ( soName , new SoInfo ( soName , entry , abiScore ) ) ; } } } } return providedLibraries ; }
private static Map < String , SoInfo > findProvidedLibraries ( JarFile apk ) { Pattern libPattern = Pattern . compile ( STRING ) ; HashMap < String , SoInfo > providedLibraries = new HashMap < > ( ) ; String [ ] supportedAbis = SysUtil . getSupportedAbis ( ) ; Enumeration < JarEntry > entries = apk . entries ( ) ; while ( entries . hasMoreElements ( ) ) { JarEntry entry = entries . nextElement ( ) ; Matcher m = libPattern . matcher ( entry . getName ( ) ) ; if ( m . matches ( ) ) { String libraryAbi = m . group ( _NUM ) ; String soName = m . group ( _NUM ) ; int abiScore = SysUtil . findAbiScore ( supportedAbis , libraryAbi ) ; if ( abiScore >= _NUM ) { SoInfo so = providedLibraries . get ( soName ) ; if ( so == null || abiScore < so . abiScore ) { providedLibraries . put ( soName , new SoInfo ( soName , entry , abiScore ) ) ; } } } } return providedLibraries ; }
private static Map < String , SoInfo > findProvidedLibraries ( JarFile apk ) { Pattern libPattern = Pattern . compile ( STRING ) ; HashMap < String , SoInfo > providedLibraries = new HashMap < > ( ) ; String [ ] supportedAbis = SysUtil . getSupportedAbis ( ) ; Enumeration < JarEntry > entries = apk . entries ( ) ; while ( entries . hasMoreElements ( ) ) { JarEntry entry = entries . nextElement ( ) ; Matcher m = libPattern . matcher ( entry . getName ( ) ) ; if ( m . matches ( ) ) { String libraryAbi = m . group ( _NUM ) ; String soName = m . group ( _NUM ) ; int abiScore = SysUtil . findAbiScore ( supportedAbis , libraryAbi ) ; if ( abiScore >= _NUM ) { SoInfo so = providedLibraries . get ( soName ) ; if ( so == null || abiScore < so . abiScore ) { providedLibraries . put ( soName , new SoInfo ( soName , entry , abiScore ) ) ; } } } } return providedLibraries ; }
private static Map < String , SoInfo > findProvidedLibraries ( JarFile apk ) { Pattern libPattern = Pattern . compile ( STRING ) ; HashMap < String , SoInfo > providedLibraries = new HashMap < > ( ) ; String [ ] supportedAbis = SysUtil . getSupportedAbis ( ) ; Enumeration < JarEntry > entries = apk . entries ( ) ; while ( entries . hasMoreElements ( ) ) { JarEntry entry = entries . nextElement ( ) ; Matcher m = libPattern . matcher ( entry . getName ( ) ) ; if ( m . matches ( ) ) { String libraryAbi = m . group ( _NUM ) ; String soName = m . group ( _NUM ) ; int abiScore = SysUtil . findAbiScore ( supportedAbis , libraryAbi ) ; if ( abiScore >= _NUM ) { SoInfo so = providedLibraries . get ( soName ) ; if ( so == null || abiScore < so . abiScore ) { providedLibraries . put ( soName , new SoInfo ( soName , entry , abiScore ) ) ; } } } } return providedLibraries ; }
private static Map < String , SoInfo > findProvidedLibraries ( JarFile apk ) { Pattern libPattern = Pattern . compile ( STRING ) ; HashMap < String , SoInfo > providedLibraries = new HashMap < > ( ) ; String [ ] supportedAbis = SysUtil . getSupportedAbis ( ) ; Enumeration < JarEntry > entries = apk . entries ( ) ; while ( entries . hasMoreElements ( ) ) { JarEntry entry = entries . nextElement ( ) ; Matcher m = libPattern . matcher ( entry . getName ( ) ) ; if ( m . matches ( ) ) { String libraryAbi = m . group ( _NUM ) ; String soName = m . group ( _NUM ) ; int abiScore = SysUtil . findAbiScore ( supportedAbis , libraryAbi ) ; if ( abiScore >= _NUM ) { SoInfo so = providedLibraries . get ( soName ) ; if ( so == null || abiScore < so . abiScore ) { providedLibraries . put ( soName , new SoInfo ( soName , entry , abiScore ) ) ; } } } } return providedLibraries ; }
protected void cutSelectedBean ( ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; if ( selectedBean == null || selectedBeanLocation == null ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selectedBean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selectedBeanLocation ) ; clearSelection ( ) ; return ; } try { serBean = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( serBean ) ; oos . writeObject ( selectedBean ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; clearSelection ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; return ; } cutBean = selectedBean ; selectedBeanBox . showCut ( selectedBean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; }
protected void cutSelectedBean ( ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; if ( selectedBean == null || selectedBeanLocation == null ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selectedBean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selectedBeanLocation ) ; clearSelection ( ) ; return ; } try { serBean = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( serBean ) ; oos . writeObject ( selectedBean ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; clearSelection ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; return ; } cutBean = selectedBean ; selectedBeanBox . showCut ( selectedBean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; }
protected void cutSelectedBean ( ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; if ( selectedBean == null || selectedBeanLocation == null ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selectedBean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selectedBeanLocation ) ; clearSelection ( ) ; return ; } try { serBean = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( serBean ) ; oos . writeObject ( selectedBean ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; clearSelection ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; return ; } cutBean = selectedBean ; selectedBeanBox . showCut ( selectedBean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; }
protected void cutSelectedBean ( ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; if ( selectedBean == null || selectedBeanLocation == null ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selectedBean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selectedBeanLocation ) ; clearSelection ( ) ; return ; } try { serBean = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( serBean ) ; oos . writeObject ( selectedBean ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; clearSelection ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; return ; } cutBean = selectedBean ; selectedBeanBox . showCut ( selectedBean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; }
protected void cutSelectedBean ( ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; if ( selectedBean == null || selectedBeanLocation == null ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selectedBean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selectedBeanLocation ) ; clearSelection ( ) ; return ; } try { serBean = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( serBean ) ; oos . writeObject ( selectedBean ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; clearSelection ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; return ; } cutBean = selectedBean ; selectedBeanBox . showCut ( selectedBean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; }
protected void cutSelectedBean ( ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; if ( selectedBean == null || selectedBeanLocation == null ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selectedBean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selectedBeanLocation ) ; clearSelection ( ) ; return ; } try { serBean = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( serBean ) ; oos . writeObject ( selectedBean ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; clearSelection ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; return ; } cutBean = selectedBean ; selectedBeanBox . showCut ( selectedBean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; }
protected void cutSelectedBean ( ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; if ( selectedBean == null || selectedBeanLocation == null ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selectedBean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selectedBeanLocation ) ; clearSelection ( ) ; return ; } try { serBean = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( serBean ) ; oos . writeObject ( selectedBean ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; clearSelection ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; return ; } cutBean = selectedBean ; selectedBeanBox . showCut ( selectedBean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; }
public void updateDeltas ( int deltaX , int deltaY ) { if ( mLeftBorderActive ) { mDeltaX = Math . max ( - mBaselineX , deltaX ) ; mDeltaX = Math . min ( mBaselineWidth - _NUM * mTouchTargetWidth , mDeltaX ) ; } else if ( mRightBorderActive ) { mDeltaX = Math . min ( mDragLayer . getWidth ( ) - ( mBaselineX + mBaselineWidth ) , deltaX ) ; mDeltaX = Math . max ( - mBaselineWidth + _NUM * mTouchTargetWidth , mDeltaX ) ; } if ( mTopBorderActive ) { mDeltaY = Math . max ( - mBaselineY , deltaY ) ; mDeltaY = Math . min ( mBaselineHeight - _NUM * mTouchTargetWidth , mDeltaY ) ; } else if ( mBottomBorderActive ) { mDeltaY = Math . min ( mDragLayer . getHeight ( ) - ( mBaselineY + mBaselineHeight ) , deltaY ) ; mDeltaY = Math . max ( - mBaselineHeight + _NUM * mTouchTargetWidth , mDeltaY ) ; } }
public static void dump ( ResultSet rs ) throws SQLException { ResultSetMetaData md = rs . getMetaData ( ) ; for ( int i = _NUM ; i < md . getColumnCount ( ) ; i ++ ) { int index = i + _NUM ; String info = md . getColumnLabel ( index ) ; String name = md . getColumnName ( index ) ; if ( info == null ) info = name ; else if ( name != null && ! name . equals ( info ) ) info += STRING + name + STRING ; info += STRING + rs . getString ( index ) ; info += STRING + md . getColumnTypeName ( index ) + STRING + md . getPrecision ( index ) ; if ( md . getScale ( index ) != _NUM ) info += STRING + md . getScale ( index ) ; info += STRING ; log . fine ( info ) ; } }
public final void add ( K key , V value ) { mItems . add ( new Item ( key , value ) ) ; mSorted = _BOOL ; }
public static byte [ ] convertDsaASN1toXMLDSIG ( byte [ ] asn1Bytes , int size ) throws IOException { if ( asn1Bytes [ _NUM ] != _NUM || asn1Bytes [ _NUM ] != asn1Bytes . length - _NUM || asn1Bytes [ _NUM ] != _NUM ) { throw new IOException ( STRING ) ; } byte rLength = asn1Bytes [ _NUM ] ; int i ; for ( i = rLength ; i > _NUM && asn1Bytes [ _NUM + rLength - i ] == _NUM ; i -- ) ; byte sLength = asn1Bytes [ _NUM + rLength ] ; int j ; for ( j = sLength ; j > _NUM && asn1Bytes [ _NUM + rLength + sLength - j ] == _NUM ; j -- ) ; if ( i > size || asn1Bytes [ _NUM + rLength ] != _NUM || j > size ) { throw new IOException ( STRING ) ; } else { byte [ ] xmldsigBytes = new byte [ size * _NUM ] ; System . arraycopy ( asn1Bytes , _NUM + rLength - i , xmldsigBytes , size - i , i ) ; System . arraycopy ( asn1Bytes , _NUM + rLength + sLength - j , xmldsigBytes , size * _NUM - j , j ) ; return xmldsigBytes ; } }
public static byte [ ] convertDsaASN1toXMLDSIG ( byte [ ] asn1Bytes , int size ) throws IOException { if ( asn1Bytes [ _NUM ] != _NUM || asn1Bytes [ _NUM ] != asn1Bytes . length - _NUM || asn1Bytes [ _NUM ] != _NUM ) { throw new IOException ( STRING ) ; } byte rLength = asn1Bytes [ _NUM ] ; int i ; for ( i = rLength ; i > _NUM && asn1Bytes [ _NUM + rLength - i ] == _NUM ; i -- ) ; byte sLength = asn1Bytes [ _NUM + rLength ] ; int j ; for ( j = sLength ; j > _NUM && asn1Bytes [ _NUM + rLength + sLength - j ] == _NUM ; j -- ) ; if ( i > size || asn1Bytes [ _NUM + rLength ] != _NUM || j > size ) { throw new IOException ( STRING ) ; } else { byte [ ] xmldsigBytes = new byte [ size * _NUM ] ; System . arraycopy ( asn1Bytes , _NUM + rLength - i , xmldsigBytes , size - i , i ) ; System . arraycopy ( asn1Bytes , _NUM + rLength + sLength - j , xmldsigBytes , size * _NUM - j , j ) ; return xmldsigBytes ; } }
public static byte [ ] convertDsaASN1toXMLDSIG ( byte [ ] asn1Bytes , int size ) throws IOException { if ( asn1Bytes [ _NUM ] != _NUM || asn1Bytes [ _NUM ] != asn1Bytes . length - _NUM || asn1Bytes [ _NUM ] != _NUM ) { throw new IOException ( STRING ) ; } byte rLength = asn1Bytes [ _NUM ] ; int i ; for ( i = rLength ; i > _NUM && asn1Bytes [ _NUM + rLength - i ] == _NUM ; i -- ) ; byte sLength = asn1Bytes [ _NUM + rLength ] ; int j ; for ( j = sLength ; j > _NUM && asn1Bytes [ _NUM + rLength + sLength - j ] == _NUM ; j -- ) ; if ( i > size || asn1Bytes [ _NUM + rLength ] != _NUM || j > size ) { throw new IOException ( STRING ) ; } else { byte [ ] xmldsigBytes = new byte [ size * _NUM ] ; System . arraycopy ( asn1Bytes , _NUM + rLength - i , xmldsigBytes , size - i , i ) ; System . arraycopy ( asn1Bytes , _NUM + rLength + sLength - j , xmldsigBytes , size * _NUM - j , j ) ; return xmldsigBytes ; } }
public static byte [ ] convertDsaASN1toXMLDSIG ( byte [ ] asn1Bytes , int size ) throws IOException { if ( asn1Bytes [ _NUM ] != _NUM || asn1Bytes [ _NUM ] != asn1Bytes . length - _NUM || asn1Bytes [ _NUM ] != _NUM ) { throw new IOException ( STRING ) ; } byte rLength = asn1Bytes [ _NUM ] ; int i ; for ( i = rLength ; i > _NUM && asn1Bytes [ _NUM + rLength - i ] == _NUM ; i -- ) ; byte sLength = asn1Bytes [ _NUM + rLength ] ; int j ; for ( j = sLength ; j > _NUM && asn1Bytes [ _NUM + rLength + sLength - j ] == _NUM ; j -- ) ; if ( i > size || asn1Bytes [ _NUM + rLength ] != _NUM || j > size ) { throw new IOException ( STRING ) ; } else { byte [ ] xmldsigBytes = new byte [ size * _NUM ] ; System . arraycopy ( asn1Bytes , _NUM + rLength - i , xmldsigBytes , size - i , i ) ; System . arraycopy ( asn1Bytes , _NUM + rLength + sLength - j , xmldsigBytes , size * _NUM - j , j ) ; return xmldsigBytes ; } }
public static byte [ ] convertDsaASN1toXMLDSIG ( byte [ ] asn1Bytes , int size ) throws IOException { if ( asn1Bytes [ _NUM ] != _NUM || asn1Bytes [ _NUM ] != asn1Bytes . length - _NUM || asn1Bytes [ _NUM ] != _NUM ) { throw new IOException ( STRING ) ; } byte rLength = asn1Bytes [ _NUM ] ; int i ; for ( i = rLength ; i > _NUM && asn1Bytes [ _NUM + rLength - i ] == _NUM ; i -- ) ; byte sLength = asn1Bytes [ _NUM + rLength ] ; int j ; for ( j = sLength ; j > _NUM && asn1Bytes [ _NUM + rLength + sLength - j ] == _NUM ; j -- ) ; if ( i > size || asn1Bytes [ _NUM + rLength ] != _NUM || j > size ) { throw new IOException ( STRING ) ; } else { byte [ ] xmldsigBytes = new byte [ size * _NUM ] ; System . arraycopy ( asn1Bytes , _NUM + rLength - i , xmldsigBytes , size - i , i ) ; System . arraycopy ( asn1Bytes , _NUM + rLength + sLength - j , xmldsigBytes , size * _NUM - j , j ) ; return xmldsigBytes ; } }
public void generateLootPot ( World world , Random random , BlockPos pos , int min , int max , ResourceLocation list ) { world . setBlockState ( pos , getRandomLootPot ( random ) , _NUM ) ; TileEntityLootPot lootPot = ( TileEntityLootPot ) world . getTileEntity ( pos ) ; if ( lootPot != null ) lootPot . setLootTable ( LootTableRegistry . COMMON_CHEST_LOOT , random . nextLong ( ) ) ; }
public void generateLootPot ( World world , Random random , BlockPos pos , int min , int max , ResourceLocation list ) { world . setBlockState ( pos , getRandomLootPot ( random ) , _NUM ) ; TileEntityLootPot lootPot = ( TileEntityLootPot ) world . getTileEntity ( pos ) ; if ( lootPot != null ) lootPot . setLootTable ( LootTableRegistry . COMMON_CHEST_LOOT , random . nextLong ( ) ) ; }
@ SuppressWarnings ( STRING ) public SelectionBuilder reset ( ) { mTable = null ; mSelection . setLength ( _NUM ) ; mSelectionArgs . clear ( ) ; return this ; }
public static Object read ( InputStream stream ) throws Exception { Class < ? > xstreamClass ; java . lang . reflect . Constructor < ? > constructor ; Object xstream ; Class < ? > [ ] deSerializeArgsClasses = new Class [ _NUM ] ; Object [ ] deSerializeArgs = new Object [ _NUM ] ; java . lang . reflect . Method methodDeSerialize ; Object result ; xstreamClass = Class . forName ( STRING ) ; constructor = xstreamClass . getConstructor ( ) ; xstream = constructor . newInstance ( ) ; deSerializeArgsClasses [ _NUM ] = InputStream . class ; deSerializeArgs [ _NUM ] = stream ; methodDeSerialize = xstreamClass . getMethod ( STRING , deSerializeArgsClasses ) ; try { result = methodDeSerialize . invoke ( xstream , deSerializeArgs ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; result = null ; } return result ; }
@ SuppressWarnings ( STRING ) public void remove ( MenuComponent popup ) { synchronized ( getTreeLock ( ) ) { if ( popups == null ) { return ; } int index = popups . indexOf ( popup ) ; if ( index >= _NUM ) { PopupMenu pmenu = ( PopupMenu ) popup ; if ( pmenu . peer != null ) { pmenu . removeNotify ( ) ; } pmenu . parent = null ; popups . removeElementAt ( index ) ; if ( popups . size ( ) == _NUM ) { popups = null ; } } } }
public static Set < String > putSetIntoMap ( String key , Map < String , Set < String > > map , String value ) { Set < String > set = new HashSet < String > ( ) ; set . add ( value ) ; map . put ( key , set ) ; return set ; }
public static Set < String > putSetIntoMap ( String key , Map < String , Set < String > > map , String value ) { Set < String > set = new HashSet < String > ( ) ; set . add ( value ) ; map . put ( key , set ) ; return set ; }
public static Set < String > putSetIntoMap ( String key , Map < String , Set < String > > map , String value ) { Set < String > set = new HashSet < String > ( ) ; set . add ( value ) ; map . put ( key , set ) ; return set ; }
public static Set < String > putSetIntoMap ( String key , Map < String , Set < String > > map , String value ) { Set < String > set = new HashSet < String > ( ) ; set . add ( value ) ; map . put ( key , set ) ; return set ; }
public static boolean isHeader ( Header hdr ) { return hdr . getBooleanValue ( ZIMAGE , _BOOL ) ; }
public static boolean isHeader ( Header hdr ) { return hdr . getBooleanValue ( ZIMAGE , _BOOL ) ; }
protected final void clearSerializationCaches ( ) { try { clearSerializationCache ( Class . forName ( STRING ) , STRING ) ; clearSerializationCache ( Class . forName ( STRING ) , STRING ) ; clearSerializationCache ( Class . forName ( STRING ) , STRING ) ; clearSerializationCache ( Class . forName ( STRING ) , STRING ) ; } catch ( ClassNotFoundException e ) { if ( log . isDebugEnabled ( ) ) log . debug ( STRING + e . getMessage ( ) ) ; } catch ( NoSuchFieldException e ) { if ( log . isDebugEnabled ( ) ) log . debug ( STRING + e . getMessage ( ) ) ; } catch ( IllegalAccessException e ) { if ( log . isDebugEnabled ( ) ) log . debug ( STRING + e . getMessage ( ) ) ; } }
protected final void clearSerializationCaches ( ) { try { clearSerializationCache ( Class . forName ( STRING ) , STRING ) ; clearSerializationCache ( Class . forName ( STRING ) , STRING ) ; clearSerializationCache ( Class . forName ( STRING ) , STRING ) ; clearSerializationCache ( Class . forName ( STRING ) , STRING ) ; } catch ( ClassNotFoundException e ) { if ( log . isDebugEnabled ( ) ) log . debug ( STRING + e . getMessage ( ) ) ; } catch ( NoSuchFieldException e ) { if ( log . isDebugEnabled ( ) ) log . debug ( STRING + e . getMessage ( ) ) ; } catch ( IllegalAccessException e ) { if ( log . isDebugEnabled ( ) ) log . debug ( STRING + e . getMessage ( ) ) ; } }
private char readEscapeCharacter ( ) throws JSONException { char escaped = in . charAt ( pos ++ ) ; switch ( escaped ) { case STRING : if ( pos + _NUM > in . length ( ) ) { throw syntaxError ( STRING ) ; } String hex = in . substring ( pos , pos + _NUM ) ; pos += _NUM ; try { return ( char ) Integer . parseInt ( hex , _NUM ) ; } catch ( NumberFormatException nfe ) { throw syntaxError ( STRING + hex ) ; } case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private char readEscapeCharacter ( ) throws JSONException { char escaped = in . charAt ( pos ++ ) ; switch ( escaped ) { case STRING : if ( pos + _NUM > in . length ( ) ) { throw syntaxError ( STRING ) ; } String hex = in . substring ( pos , pos + _NUM ) ; pos += _NUM ; try { return ( char ) Integer . parseInt ( hex , _NUM ) ; } catch ( NumberFormatException nfe ) { throw syntaxError ( STRING + hex ) ; } case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private char readEscapeCharacter ( ) throws JSONException { char escaped = in . charAt ( pos ++ ) ; switch ( escaped ) { case STRING : if ( pos + _NUM > in . length ( ) ) { throw syntaxError ( STRING ) ; } String hex = in . substring ( pos , pos + _NUM ) ; pos += _NUM ; try { return ( char ) Integer . parseInt ( hex , _NUM ) ; } catch ( NumberFormatException nfe ) { throw syntaxError ( STRING + hex ) ; } case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private char readEscapeCharacter ( ) throws JSONException { char escaped = in . charAt ( pos ++ ) ; switch ( escaped ) { case STRING : if ( pos + _NUM > in . length ( ) ) { throw syntaxError ( STRING ) ; } String hex = in . substring ( pos , pos + _NUM ) ; pos += _NUM ; try { return ( char ) Integer . parseInt ( hex , _NUM ) ; } catch ( NumberFormatException nfe ) { throw syntaxError ( STRING + hex ) ; } case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private char readEscapeCharacter ( ) throws JSONException { char escaped = in . charAt ( pos ++ ) ; switch ( escaped ) { case STRING : if ( pos + _NUM > in . length ( ) ) { throw syntaxError ( STRING ) ; } String hex = in . substring ( pos , pos + _NUM ) ; pos += _NUM ; try { return ( char ) Integer . parseInt ( hex , _NUM ) ; } catch ( NumberFormatException nfe ) { throw syntaxError ( STRING + hex ) ; } case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private static boolean packageMatches ( ResolveInfo app , ProcessError err ) { final String appPkg = app . activityInfo . packageName ; final String errPkg = err . info . processName ; Log . d ( TAG , String . format ( STRING , appPkg , errPkg ) ) ; return appPkg . equals ( errPkg ) ; }
private void updateRange ( double x , double y ) { mMinX = Math . min ( mMinX , x ) ; mMaxX = Math . max ( mMaxX , x ) ; mMinY = Math . min ( mMinY , y ) ; mMaxY = Math . max ( mMaxY , y ) ; }
public static File createTempPath ( String path ) throws IOException { String sep = File . separator ; File tempDir = new File ( System . getProperty ( STRING ) + sep + path ) ; if ( ! tempDir . exists ( ) ) if ( ! tempDir . mkdirs ( ) ) { boolean status = tempDir . delete ( ) ; throw new IOException ( STRING + tempDir + STRING + status ) ; } tempDir . deleteOnExit ( ) ; return tempDir ; }
public Node text ( final String text ) throws IOException { closeHead ( ) ; m_writer . write ( cdata ( text ) ) ; m_text ++ ; return this ; }
public Node text ( final String text ) throws IOException { closeHead ( ) ; m_writer . write ( cdata ( text ) ) ; m_text ++ ; return this ; }
public Node text ( final String text ) throws IOException { closeHead ( ) ; m_writer . write ( cdata ( text ) ) ; m_text ++ ; return this ; }
public Node text ( final String text ) throws IOException { closeHead ( ) ; m_writer . write ( cdata ( text ) ) ; m_text ++ ; return this ; }
public Node text ( final String text ) throws IOException { closeHead ( ) ; m_writer . write ( cdata ( text ) ) ; m_text ++ ; return this ; }
public ArrayRealVector ( ArrayRealVector v1 , RealVector v2 ) { final int l1 = v1 . data . length ; final int l2 = v2 . getDimension ( ) ; data = new double [ l1 + l2 ] ; System . arraycopy ( v1 . data , _NUM , data , _NUM , l1 ) ; for ( int i = _NUM ; i < l2 ; ++ i ) { data [ l1 + i ] = v2 . getEntry ( i ) ; } }
public ArrayRealVector ( ArrayRealVector v1 , RealVector v2 ) { final int l1 = v1 . data . length ; final int l2 = v2 . getDimension ( ) ; data = new double [ l1 + l2 ] ; System . arraycopy ( v1 . data , _NUM , data , _NUM , l1 ) ; for ( int i = _NUM ; i < l2 ; ++ i ) { data [ l1 + i ] = v2 . getEntry ( i ) ; } }
public ArrayRealVector ( ArrayRealVector v1 , RealVector v2 ) { final int l1 = v1 . data . length ; final int l2 = v2 . getDimension ( ) ; data = new double [ l1 + l2 ] ; System . arraycopy ( v1 . data , _NUM , data , _NUM , l1 ) ; for ( int i = _NUM ; i < l2 ; ++ i ) { data [ l1 + i ] = v2 . getEntry ( i ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( getCovMatrix ( ) == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( getCovMatrix ( ) == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( getCovMatrix ( ) == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( getCovMatrix ( ) == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( getCovMatrix ( ) == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( getCovMatrix ( ) == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( getCovMatrix ( ) == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( getCovMatrix ( ) == null ) { throw new NullPointerException ( ) ; } }
protected WorkerThread ( ) { super ( ControlThread . getWorkerThreadGroup ( ) , STRING ) ; threadnum = nextThreadNum . getAndIncrement ( ) ; }
public static boolean isNestedMapping ( String regex ) { return regex . startsWith ( NESTED_MAPPING_STARTS_SYMBOL ) && regex . endsWith ( NESTED_MAPPING_ENDS_SYMBOL ) ; }
public static boolean isNestedMapping ( String regex ) { return regex . startsWith ( NESTED_MAPPING_STARTS_SYMBOL ) && regex . endsWith ( NESTED_MAPPING_ENDS_SYMBOL ) ; }
public Iterator < Method > calledMethodIterator ( ) { return calledMethodSet . iterator ( ) ; }
public Iterator < Method > calledMethodIterator ( ) { return calledMethodSet . iterator ( ) ; }
static String valueToString ( Object value ) throws JSONException { if ( value == null ) { return STRING ; } if ( value instanceof Number ) { return numberToString ( ( Number ) value ) ; } if ( value instanceof Boolean || value instanceof JSONObject || value instanceof JSONArray ) { return value . toString ( ) ; } return quote ( value . toString ( ) ) ; }
static String valueToString ( Object value ) throws JSONException { if ( value == null ) { return STRING ; } if ( value instanceof Number ) { return numberToString ( ( Number ) value ) ; } if ( value instanceof Boolean || value instanceof JSONObject || value instanceof JSONArray ) { return value . toString ( ) ; } return quote ( value . toString ( ) ) ; }
public void drawGlyphVector ( GlyphVector g , float x , float y ) { Rectangle2D bbox = g . getLogicalBounds ( ) ; addDrawingRect ( bbox , x , y ) ; mPrintMetrics . drawText ( this ) ; }
public void drawGlyphVector ( GlyphVector g , float x , float y ) { Rectangle2D bbox = g . getLogicalBounds ( ) ; addDrawingRect ( bbox , x , y ) ; mPrintMetrics . drawText ( this ) ; }
public void drawGlyphVector ( GlyphVector g , float x , float y ) { Rectangle2D bbox = g . getLogicalBounds ( ) ; addDrawingRect ( bbox , x , y ) ; mPrintMetrics . drawText ( this ) ; }
public OutSegment ( TableKelp table , PageServiceSync tableService , TableWriterServiceImpl readWrite , SegmentKelp segment ) { Objects . requireNonNull ( table ) ; Objects . requireNonNull ( tableService ) ; Objects . requireNonNull ( readWrite ) ; Objects . requireNonNull ( segment ) ; _table = table ; _readWrite = readWrite ; _segment = segment ; if ( ! _segment . isWriting ( ) ) { throw new IllegalStateException ( String . valueOf ( _segment ) ) ; } _indexTempBuf = TempBuffer . createLarge ( ) ; _indexBuffer = _indexTempBuf . buffer ( ) ; _indexAddress = _segment . length ( ) - BLOCK_SIZE ; fillHeader ( ) ; _compressor = readWrite . compressor ( ) ; _sOut = _readWrite . openWrite ( segment . extent ( ) ) ; }
public void appendBefore ( StringBuilder sb ) { if ( before != null ) { sb . append ( before ) ; } }
public void appendBefore ( StringBuilder sb ) { if ( before != null ) { sb . append ( before ) ; } }
public static boolean isUseStringWidth ( ) { return useStringWidth ; }
public static boolean isUseStringWidth ( ) { return useStringWidth ; }
public static boolean isUseStringWidth ( ) { return useStringWidth ; }
public static boolean isUseStringWidth ( ) { return useStringWidth ; }
public static boolean isUseStringWidth ( ) { return useStringWidth ; }
public static boolean isUseStringWidth ( ) { return useStringWidth ; }
public MessagePropertyKey ( String description , Integer ordinal ) { this . description = description ; this . ordinal = ordinal ; }
List < String > findInPackage ( Test test , String packageName ) { List < String > localClsssOrPkgs = new ArrayList < String > ( ) ; packageName = packageName . replace ( STRING , STRING ) ; Enumeration < URL > urls ; try { urls = classloader . getResources ( packageName ) ; if ( ! urls . hasMoreElements ( ) ) { log . warn ( STRING + packageName + STRING ) ; } } catch ( IOException ioe ) { log . warn ( STRING + packageName ) ; return localClsssOrPkgs ; } return findInPackageWithUrls ( test , packageName , urls ) ; }
List < String > findInPackage ( Test test , String packageName ) { List < String > localClsssOrPkgs = new ArrayList < String > ( ) ; packageName = packageName . replace ( STRING , STRING ) ; Enumeration < URL > urls ; try { urls = classloader . getResources ( packageName ) ; if ( ! urls . hasMoreElements ( ) ) { log . warn ( STRING + packageName + STRING ) ; } } catch ( IOException ioe ) { log . warn ( STRING + packageName ) ; return localClsssOrPkgs ; } return findInPackageWithUrls ( test , packageName , urls ) ; }
List < String > findInPackage ( Test test , String packageName ) { List < String > localClsssOrPkgs = new ArrayList < String > ( ) ; packageName = packageName . replace ( STRING , STRING ) ; Enumeration < URL > urls ; try { urls = classloader . getResources ( packageName ) ; if ( ! urls . hasMoreElements ( ) ) { log . warn ( STRING + packageName + STRING ) ; } } catch ( IOException ioe ) { log . warn ( STRING + packageName ) ; return localClsssOrPkgs ; } return findInPackageWithUrls ( test , packageName , urls ) ; }
public boolean checkPosConstraint ( Sentence s , String posConstraint , MatchResult m , JCas jcas ) { Pattern paConstraint = Pattern . compile ( STRING ) ; for ( MatchResult mr : Toolbox . findMatches ( paConstraint , posConstraint ) ) { int groupNumber = Integer . parseInt ( mr . group ( _NUM ) ) ; int tokenBegin = s . getBegin ( ) + m . start ( groupNumber ) ; int tokenEnd = s . getBegin ( ) + m . end ( groupNumber ) ; String pos = mr . group ( _NUM ) ; String pos_as_is = getPosFromMatchResult ( tokenBegin , tokenEnd , s , jcas ) ; if ( pos_as_is . matches ( pos ) ) { Logger . printDetail ( STRING + pos + STRING + pos_as_is ) ; } else { return _BOOL ; } } return _BOOL ; }
public void dispose ( ) { setMapBean ( null ) ; setLayout ( null ) ; removeAll ( ) ; }
public void dispose ( ) { setMapBean ( null ) ; setLayout ( null ) ; removeAll ( ) ; }
private ServerPod [ ] buildClusterServers ( ClusterHeartbeat cluster , int serverCount ) { ArrayList < ServerPod > serversPod = new ArrayList < > ( ) ; for ( ServerHeartbeat server : cluster . getServers ( ) ) { ServerPod serverPod = new ServerPod ( serversPod . size ( ) ) ; serversPod . add ( serverPod ) ; serverPod . setServer ( server ) ; } while ( serversPod . size ( ) < serverCount ) { serversPod . add ( new ServerPod ( serversPod . size ( ) ) ) ; } ServerPod [ ] serverArray = new ServerPod [ serverCount ] ; for ( int i = _NUM ; i < serverCount ; i ++ ) { serverArray [ i ] = serversPod . get ( i ) ; } return serverArray ; }
private ServerPod [ ] buildClusterServers ( ClusterHeartbeat cluster , int serverCount ) { ArrayList < ServerPod > serversPod = new ArrayList < > ( ) ; for ( ServerHeartbeat server : cluster . getServers ( ) ) { ServerPod serverPod = new ServerPod ( serversPod . size ( ) ) ; serversPod . add ( serverPod ) ; serverPod . setServer ( server ) ; } while ( serversPod . size ( ) < serverCount ) { serversPod . add ( new ServerPod ( serversPod . size ( ) ) ) ; } ServerPod [ ] serverArray = new ServerPod [ serverCount ] ; for ( int i = _NUM ; i < serverCount ; i ++ ) { serverArray [ i ] = serversPod . get ( i ) ; } return serverArray ; }
private ServerPod [ ] buildClusterServers ( ClusterHeartbeat cluster , int serverCount ) { ArrayList < ServerPod > serversPod = new ArrayList < > ( ) ; for ( ServerHeartbeat server : cluster . getServers ( ) ) { ServerPod serverPod = new ServerPod ( serversPod . size ( ) ) ; serversPod . add ( serverPod ) ; serverPod . setServer ( server ) ; } while ( serversPod . size ( ) < serverCount ) { serversPod . add ( new ServerPod ( serversPod . size ( ) ) ) ; } ServerPod [ ] serverArray = new ServerPod [ serverCount ] ; for ( int i = _NUM ; i < serverCount ; i ++ ) { serverArray [ i ] = serversPod . get ( i ) ; } return serverArray ; }
private ServerPod [ ] buildClusterServers ( ClusterHeartbeat cluster , int serverCount ) { ArrayList < ServerPod > serversPod = new ArrayList < > ( ) ; for ( ServerHeartbeat server : cluster . getServers ( ) ) { ServerPod serverPod = new ServerPod ( serversPod . size ( ) ) ; serversPod . add ( serverPod ) ; serverPod . setServer ( server ) ; } while ( serversPod . size ( ) < serverCount ) { serversPod . add ( new ServerPod ( serversPod . size ( ) ) ) ; } ServerPod [ ] serverArray = new ServerPod [ serverCount ] ; for ( int i = _NUM ; i < serverCount ; i ++ ) { serverArray [ i ] = serversPod . get ( i ) ; } return serverArray ; }
private ServerPod [ ] buildClusterServers ( ClusterHeartbeat cluster , int serverCount ) { ArrayList < ServerPod > serversPod = new ArrayList < > ( ) ; for ( ServerHeartbeat server : cluster . getServers ( ) ) { ServerPod serverPod = new ServerPod ( serversPod . size ( ) ) ; serversPod . add ( serverPod ) ; serverPod . setServer ( server ) ; } while ( serversPod . size ( ) < serverCount ) { serversPod . add ( new ServerPod ( serversPod . size ( ) ) ) ; } ServerPod [ ] serverArray = new ServerPod [ serverCount ] ; for ( int i = _NUM ; i < serverCount ; i ++ ) { serverArray [ i ] = serversPod . get ( i ) ; } return serverArray ; }
public RestControllerProcessor ( Log log , Swagger swagger , String restJavaPackage , String tagPatternTemplate , Class < ? > modelErrorClass ) throws MojoExecutionException { this . log = log ; this . swagger = swagger ; this . restJavaPackage = restJavaPackage ; this . modelErrorClass = modelErrorClass ; tagPattern = Pattern . compile ( tagPatternTemplate ) ; findAndProcessRestControllers ( ) ; }
public RestControllerProcessor ( Log log , Swagger swagger , String restJavaPackage , String tagPatternTemplate , Class < ? > modelErrorClass ) throws MojoExecutionException { this . log = log ; this . swagger = swagger ; this . restJavaPackage = restJavaPackage ; this . modelErrorClass = modelErrorClass ; tagPattern = Pattern . compile ( tagPatternTemplate ) ; findAndProcessRestControllers ( ) ; }
public RestControllerProcessor ( Log log , Swagger swagger , String restJavaPackage , String tagPatternTemplate , Class < ? > modelErrorClass ) throws MojoExecutionException { this . log = log ; this . swagger = swagger ; this . restJavaPackage = restJavaPackage ; this . modelErrorClass = modelErrorClass ; tagPattern = Pattern . compile ( tagPatternTemplate ) ; findAndProcessRestControllers ( ) ; }
public boolean isSignatureValid ( ) { return ECKey . verify ( Sha256Hash . hashTwice ( content ) , signature , params . getAlertSigningKey ( ) ) ; }
public boolean isSignatureValid ( ) { return ECKey . verify ( Sha256Hash . hashTwice ( content ) , signature , params . getAlertSigningKey ( ) ) ; }
public boolean isSignatureValid ( ) { return ECKey . verify ( Sha256Hash . hashTwice ( content ) , signature , params . getAlertSigningKey ( ) ) ; }
public boolean isSignatureValid ( ) { return ECKey . verify ( Sha256Hash . hashTwice ( content ) , signature , params . getAlertSigningKey ( ) ) ; }
public boolean isSignatureValid ( ) { return ECKey . verify ( Sha256Hash . hashTwice ( content ) , signature , params . getAlertSigningKey ( ) ) ; }
public boolean isSignatureValid ( ) { return ECKey . verify ( Sha256Hash . hashTwice ( content ) , signature , params . getAlertSigningKey ( ) ) ; }
public List < EdxLocalParseChannel > filterForInactiveCourses ( List < CourseEntry > courseEntryList ) { Set < String > activeCourseList = new HashSet < > ( ) ; for ( CourseEntry entry : courseEntryList ) { activeCourseList . add ( entry . getId ( ) ) ; } List < EdxLocalParseChannel > inactiveCourseList = new LinkedList < EdxLocalParseChannel > ( ) ; for ( EdxLocalParseChannel pc : this ) { if ( ! activeCourseList . contains ( pc . getCourseId ( ) ) ) { inactiveCourseList . add ( pc ) ; } } return inactiveCourseList ; }
public void appendCell ( double value ) { appendCell ( String . valueOf ( value ) ) ; }
public static < T > T parse ( InputStream xml , String xmlPath , String [ ] xsds , String pkg , Class < T > resultClass ) throws XmlParsingException { try { JAXBContext jaxbContext = JAXBContext . newInstance ( pkg ) ; Unmarshaller unmarshaller = jaxbContext . createUnmarshaller ( ) ; UnmarshallerHandler unmarshallerHandler = unmarshaller . getUnmarshallerHandler ( ) ; XmlParsingHandler contentErrorHandler = new XmlParsingHandlerWrapper ( unmarshallerHandler , xmlPath ) ; doParse ( xml , xsds , contentErrorHandler ) ; Object result = JAXBIntrospector . getValue ( unmarshallerHandler . getResult ( ) ) ; if ( ! resultClass . isInstance ( result ) ) { throw new RuntimeException ( String . format ( STRING , xmlPath , resultClass . getSimpleName ( ) ) ) ; } return ( T ) result ; } catch ( JAXBException e ) { throw new RuntimeException ( e ) ; } }
public static < T > T parse ( InputStream xml , String xmlPath , String [ ] xsds , String pkg , Class < T > resultClass ) throws XmlParsingException { try { JAXBContext jaxbContext = JAXBContext . newInstance ( pkg ) ; Unmarshaller unmarshaller = jaxbContext . createUnmarshaller ( ) ; UnmarshallerHandler unmarshallerHandler = unmarshaller . getUnmarshallerHandler ( ) ; XmlParsingHandler contentErrorHandler = new XmlParsingHandlerWrapper ( unmarshallerHandler , xmlPath ) ; doParse ( xml , xsds , contentErrorHandler ) ; Object result = JAXBIntrospector . getValue ( unmarshallerHandler . getResult ( ) ) ; if ( ! resultClass . isInstance ( result ) ) { throw new RuntimeException ( String . format ( STRING , xmlPath , resultClass . getSimpleName ( ) ) ) ; } return ( T ) result ; } catch ( JAXBException e ) { throw new RuntimeException ( e ) ; } }
@ Deprecated protected void drawMultiLineTextAppearance ( Rectangle rect , PdfFont font , int fontSize , String value , PdfFormXObject appearance ) { drawMultiLineTextAppearance ( rect , font , ( float ) fontSize , value , appearance ) ; }
public CDatabaseConfiguration ( final IDatabase database , final ListenerProvider < IDatabaseListener > listeners , final String description , final String driver , final String host , final String name , final String user , final String password , final String identity , final boolean autoConnect , final boolean savePassword ) { m_database = Preconditions . checkNotNull ( database , STRING ) ; m_listeners = Preconditions . checkNotNull ( listeners , STRING ) ; m_description = Preconditions . checkNotNull ( description , STRING ) ; m_driver = Preconditions . checkNotNull ( driver , STRING ) ; m_host = Preconditions . checkNotNull ( host , STRING ) ; m_name = Preconditions . checkNotNull ( name , STRING ) ; m_user = Preconditions . checkNotNull ( user , STRING ) ; m_password = Preconditions . checkNotNull ( password , STRING ) ; m_identity = Preconditions . checkNotNull ( identity , STRING ) ; if ( m_identity . isEmpty ( ) ) { m_identity = STRING ; } m_autoConnect = autoConnect ; m_savePassword = savePassword ; }
public boolean hasItems ( ) { return items != null && ! items . isEmpty ( ) ; }
public boolean hasItems ( ) { return items != null && ! items . isEmpty ( ) ; }
public void removeAttribute ( int index ) { if ( index >= _NUM && index < length ) { if ( index < length - _NUM ) { System . arraycopy ( data , ( index + _NUM ) * _NUM , data , index * _NUM , ( length - index - _NUM ) * _NUM ) ; } index = ( length - _NUM ) * _NUM ; data [ index ++ ] = null ; data [ index ++ ] = null ; data [ index ++ ] = null ; data [ index ++ ] = null ; data [ index ] = null ; length -- ; } else { badIndex ( index ) ; } }
private static int endOfTagMatch ( String string , int fromIndex , String tag ) { int pos = string . indexOf ( tag , fromIndex ) ; if ( pos != - _NUM ) { while ( pos < string . length ( ) && Character . isWhitespace ( string . charAt ( pos ) ) ) pos ++ ; return pos + tag . length ( ) ; } if ( tag . contains ( STRING ) ) { tag = tag . replaceAll ( STRING , STRING ) ; pos = string . indexOf ( tag ) ; if ( pos != - _NUM ) { while ( pos < string . length ( ) && Character . isWhitespace ( string . charAt ( pos ) ) ) pos ++ ; return pos + tag . length ( ) ; } } return - _NUM ; }
private static int endOfTagMatch ( String string , int fromIndex , String tag ) { int pos = string . indexOf ( tag , fromIndex ) ; if ( pos != - _NUM ) { while ( pos < string . length ( ) && Character . isWhitespace ( string . charAt ( pos ) ) ) pos ++ ; return pos + tag . length ( ) ; } if ( tag . contains ( STRING ) ) { tag = tag . replaceAll ( STRING , STRING ) ; pos = string . indexOf ( tag ) ; if ( pos != - _NUM ) { while ( pos < string . length ( ) && Character . isWhitespace ( string . charAt ( pos ) ) ) pos ++ ; return pos + tag . length ( ) ; } } return - _NUM ; }
private JMenu createViewMenu ( ) { JMenu viewMenu = new JMenu ( STRING ) ; viewMenu . add ( actionManager . getPropertyTabAction ( ) ) ; viewMenu . addSeparator ( ) ; viewMenu . add ( new JMenuItem ( actionManager . getRepositionAllWindowsAction ( ) ) ) ; return viewMenu ; }
public Shape createScrollCap ( int x , int y , int w , int h ) { path . reset ( ) ; path . moveTo ( x , y ) ; path . lineTo ( x , y + h ) ; path . lineTo ( x + w , y + h ) ; addScrollGapPath ( x , y , w , h , _BOOL ) ; path . closePath ( ) ; return path ; }
public Shape createScrollCap ( int x , int y , int w , int h ) { path . reset ( ) ; path . moveTo ( x , y ) ; path . lineTo ( x , y + h ) ; path . lineTo ( x + w , y + h ) ; addScrollGapPath ( x , y , w , h , _BOOL ) ; path . closePath ( ) ; return path ; }
public Shape createScrollCap ( int x , int y , int w , int h ) { path . reset ( ) ; path . moveTo ( x , y ) ; path . lineTo ( x , y + h ) ; path . lineTo ( x + w , y + h ) ; addScrollGapPath ( x , y , w , h , _BOOL ) ; path . closePath ( ) ; return path ; }
public static String quotedString ( String str ) { if ( str == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( STRING ) ; for ( int i = _NUM ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ( ch == STRING ) || ( ch == STRING ) ) { if ( ( i > _NUM ) && ( str . charAt ( i - _NUM ) != STRING ) ) { sb . append ( STRING ) ; } else if ( i == _NUM ) { sb . append ( STRING ) ; } } sb . append ( ch ) ; } sb . append ( STRING ) ; return sb . toString ( ) ; }
public int currentAsTarget ( ) { return currentAsTarget . get ( ) ; }
private static float fuzzAspectRatio ( float aspectRatio ) { for ( float desiredAspectRatio : sDesiredAspectRatios ) { if ( ( Math . abs ( aspectRatio - desiredAspectRatio ) ) < ASPECT_RATIO_TOLERANCE ) { return desiredAspectRatio ; } } return aspectRatio ; }
public KeyInfo toDTO ( ) { return new KeyInfo ( available , usage , friendlyName , id , publicKey , Collections . unmodifiableList ( getCertsAsDTOs ( ) ) , Collections . unmodifiableList ( getCertRequestsAsDTOs ( ) ) ) ; }
public KeyInfo toDTO ( ) { return new KeyInfo ( available , usage , friendlyName , id , publicKey , Collections . unmodifiableList ( getCertsAsDTOs ( ) ) , Collections . unmodifiableList ( getCertRequestsAsDTOs ( ) ) ) ; }
public void addLayersToBeanContext ( List < Layer > layers ) { BeanContext bc = getBeanContext ( ) ; if ( bc == null || layers == null ) { return ; } for ( Layer layer : layers ) { if ( layer . getAddToBeanContext ( ) && layer . getBeanContext ( ) == null ) { bc . add ( layer ) ; } } }
public void addLayersToBeanContext ( List < Layer > layers ) { BeanContext bc = getBeanContext ( ) ; if ( bc == null || layers == null ) { return ; } for ( Layer layer : layers ) { if ( layer . getAddToBeanContext ( ) && layer . getBeanContext ( ) == null ) { bc . add ( layer ) ; } } }
public void addLayersToBeanContext ( List < Layer > layers ) { BeanContext bc = getBeanContext ( ) ; if ( bc == null || layers == null ) { return ; } for ( Layer layer : layers ) { if ( layer . getAddToBeanContext ( ) && layer . getBeanContext ( ) == null ) { bc . add ( layer ) ; } } }
public void addLayersToBeanContext ( List < Layer > layers ) { BeanContext bc = getBeanContext ( ) ; if ( bc == null || layers == null ) { return ; } for ( Layer layer : layers ) { if ( layer . getAddToBeanContext ( ) && layer . getBeanContext ( ) == null ) { bc . add ( layer ) ; } } }
public void addLayersToBeanContext ( List < Layer > layers ) { BeanContext bc = getBeanContext ( ) ; if ( bc == null || layers == null ) { return ; } for ( Layer layer : layers ) { if ( layer . getAddToBeanContext ( ) && layer . getBeanContext ( ) == null ) { bc . add ( layer ) ; } } }
private final long logarithmicDistribution ( long mean , long max ) { final double x = localRandom . nextDouble ( ) ; if ( x == _NUM ) { return max ; } return Math . min ( ( long ) ( mean * - Math . log ( x ) ) , max ) ; }
private final long logarithmicDistribution ( long mean , long max ) { final double x = localRandom . nextDouble ( ) ; if ( x == _NUM ) { return max ; } return Math . min ( ( long ) ( mean * - Math . log ( x ) ) , max ) ; }
private final long logarithmicDistribution ( long mean , long max ) { final double x = localRandom . nextDouble ( ) ; if ( x == _NUM ) { return max ; } return Math . min ( ( long ) ( mean * - Math . log ( x ) ) , max ) ; }
public boolean union ( RWSet other ) { throw new RuntimeException ( STRING ) ; }
@ Override public BasicBlock nextElement ( ) { BasicBlock result = blocks . get ( currentBlock ) ; currentBlock ++ ; return result ; }
@ Override public BasicBlock nextElement ( ) { BasicBlock result = blocks . get ( currentBlock ) ; currentBlock ++ ; return result ; }
@ Override public BasicBlock nextElement ( ) { BasicBlock result = blocks . get ( currentBlock ) ; currentBlock ++ ; return result ; }
private boolean addState ( long stateNumber ) { if ( firstState < _NUM ) { firstState = stateNumber ; } else if ( stepSize < _NUM ) { stepSize = ( int ) ( stateNumber - firstState ) ; } else { int step = ( int ) ( stateNumber - lastState ) ; if ( step != stepSize ) { return _BOOL ; } } lastState = stateNumber ; return _BOOL ; }
private boolean addState ( long stateNumber ) { if ( firstState < _NUM ) { firstState = stateNumber ; } else if ( stepSize < _NUM ) { stepSize = ( int ) ( stateNumber - firstState ) ; } else { int step = ( int ) ( stateNumber - lastState ) ; if ( step != stepSize ) { return _BOOL ; } } lastState = stateNumber ; return _BOOL ; }
private void logException ( Throwable t , String url ) { log . log ( String . format ( STRING , url ) ) ; StringWriter sw = new StringWriter ( ) ; t . printStackTrace ( new PrintWriter ( sw ) ) ; log . log ( sw . toString ( ) ) ; log . log ( STRING ) ; }
private void validateCloumns ( Map < String , Object > columnNameToTypeMap ) { if ( columnNameToTypeMap == null ) { throw new IllegalArgumentException ( STRING ) ; } for ( Map . Entry < String , Object > entry : columnNameToTypeMap . entrySet ( ) ) { Object objValue = entry . getValue ( ) ; if ( objValue == null ) { throw new IllegalArgumentException ( STRING + entry . getKey ( ) + STRING ) ; } if ( objValue instanceof Class < ? > ) { continue ; } if ( objValue instanceof String ) { try { entry . setValue ( Class . forName ( ( String ) objValue ) ) ; } catch ( ClassNotFoundException e ) { throw new IllegalArgumentException ( STRING , e ) ; } } } }
public void addString ( String s , String encoding ) { if ( encoding == null || encoding . equals ( STRING ) ) { addString ( s ) ; return ; } byte [ ] bytes = null ; try { bytes = s . getBytes ( encoding ) ; } catch ( UnsupportedEncodingException e ) { addString ( s ) ; return ; } int len = bytes . length ; if ( len + _length > _capacity ) ensureCapacity ( _length + len ) ; for ( int i = _NUM ; i < len ; i ++ ) _buffer [ _length ++ ] = bytes [ i ] ; }
protected void releaseBlock ( OBlock block , int idx ) { _idxLastOrder = idx ; firePropertyChange ( STRING , null , block ) ; for ( int i = idx ; i > - _NUM ; i -- ) { boolean dealloc = _BOOL ; OBlock prevBlock = getBlockAt ( i ) ; for ( int j = i + _NUM ; j < _orders . size ( ) ; j ++ ) { if ( prevBlock . equals ( getBlockAt ( j ) ) ) { dealloc = _BOOL ; } } if ( dealloc ) { prevBlock . setValue ( null ) ; prevBlock . deAllocate ( this ) ; } } }
public void removeMarker ( final Marker MARKER ) { if ( null == MARKER ) return ; markers . remove ( MARKER ) ; Collections . sort ( markers , new MarkerComparator ( ) ) ; fireUpdateEvent ( REDRAW_EVENT ) ; }
protected long scaleTime ( int reqSampleRate , long targetTimeInSamples ) { if ( reqSampleRate == sampleRate ) return ( targetTimeInSamples ) ; return ( Math . round ( ( double ) ( reqSampleRate ) * ( double ) ( targetTimeInSamples ) / ( sampleRate ) ) ) ; }
protected long scaleTime ( int reqSampleRate , long targetTimeInSamples ) { if ( reqSampleRate == sampleRate ) return ( targetTimeInSamples ) ; return ( Math . round ( ( double ) ( reqSampleRate ) * ( double ) ( targetTimeInSamples ) / ( sampleRate ) ) ) ; }
public static < C extends ConfigurationClient , S extends Configuration > CreateSubCommandHandler < C , S > create ( SubCommandArgumentParser parser , ManagedObjectPath < ? , ? > p , SetRelationDefinition < C , S > r ) throws ArgumentException { return new CreateSubCommandHandler < > ( parser , p , r , null , p . child ( r ) ) ; }
public List < MethodNode > handleMissingMethod ( ClassNode receiver , String name , ArgumentListExpression argumentList , ClassNode [ ] argumentTypes , MethodCall call ) { return Collections . emptyList ( ) ; }
public List < MethodNode > handleMissingMethod ( ClassNode receiver , String name , ArgumentListExpression argumentList , ClassNode [ ] argumentTypes , MethodCall call ) { return Collections . emptyList ( ) ; }
@ Override protected void keyTyped ( char par1 , int par2 ) { }
public void overrideCurrentTime ( long time ) { startTime = System . currentTimeMillis ( ) ; currentTime = _NUM ; storedTime = time ; }
private ImmutableList < String > saveFilesOnDisk ( ImmutableMap < String , String > swaggerFilePathToContentMap ) { List < String > savedfilePaths = new ArrayList < > ( ) ; File tempDir = Files . createTempDir ( ) ; String tmpDirLocation = tempDir . getAbsolutePath ( ) ; for ( Entry < String , String > entry : swaggerFilePathToContentMap . entrySet ( ) ) { String filePath = entry . getKey ( ) ; String fileContent = entry . getValue ( ) ; Preconditions . checkState ( ! Strings . isNullOrEmpty ( fileContent ) , STRING ) ; Preconditions . checkState ( ! Strings . isNullOrEmpty ( filePath ) , STRING ) ; String filePathToSave = File . separator + tmpDirLocation + File . separator + STRING + File . separator + filePath ; try { String savedFilePath = saveFileOnDisk ( filePathToSave , fileContent ) ; savedfilePaths . add ( savedFilePath ) ; } catch ( IOException e ) { throw new IllegalStateException ( String . format ( STRING , filePathToSave ) , e ) ; } } return ImmutableList . copyOf ( savedfilePaths ) ; }
private ImmutableList < String > saveFilesOnDisk ( ImmutableMap < String , String > swaggerFilePathToContentMap ) { List < String > savedfilePaths = new ArrayList < > ( ) ; File tempDir = Files . createTempDir ( ) ; String tmpDirLocation = tempDir . getAbsolutePath ( ) ; for ( Entry < String , String > entry : swaggerFilePathToContentMap . entrySet ( ) ) { String filePath = entry . getKey ( ) ; String fileContent = entry . getValue ( ) ; Preconditions . checkState ( ! Strings . isNullOrEmpty ( fileContent ) , STRING ) ; Preconditions . checkState ( ! Strings . isNullOrEmpty ( filePath ) , STRING ) ; String filePathToSave = File . separator + tmpDirLocation + File . separator + STRING + File . separator + filePath ; try { String savedFilePath = saveFileOnDisk ( filePathToSave , fileContent ) ; savedfilePaths . add ( savedFilePath ) ; } catch ( IOException e ) { throw new IllegalStateException ( String . format ( STRING , filePathToSave ) , e ) ; } } return ImmutableList . copyOf ( savedfilePaths ) ; }
public void notifyChangedSlot ( LocoNetSlot s ) { if ( s . getSlot ( ) != LnConstants . FC_SLOT ) { return ; } if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + s ) ; } days . setText ( STRING + s . getFcDays ( ) ) ; hours . setText ( STRING + s . getFcHours ( ) ) ; minutes . setText ( STRING + s . getFcMinutes ( ) ) ; rate . setText ( STRING + s . getFcRate ( ) ) ; frac_mins . setText ( STRING + s . getFcFracMins ( ) ) ; }
public static boolean isMagic ( String path ) { return COMMIT_MSG . equals ( path ) || MERGE_LIST . equals ( path ) ; }
public static boolean isMagic ( String path ) { return COMMIT_MSG . equals ( path ) || MERGE_LIST . equals ( path ) ; }
public static boolean isMagic ( String path ) { return COMMIT_MSG . equals ( path ) || MERGE_LIST . equals ( path ) ; }
public static boolean isMagic ( String path ) { return COMMIT_MSG . equals ( path ) || MERGE_LIST . equals ( path ) ; }
public static boolean isMagic ( String path ) { return COMMIT_MSG . equals ( path ) || MERGE_LIST . equals ( path ) ; }
public static void addComboBox ( final JPanel panel , final JComboBox < String > comboBox , final String description , final String hint , final String [ ] values , final int selectedOption ) { Preconditions . checkNotNull ( panel , STRING ) ; Preconditions . checkNotNull ( comboBox , STRING ) ; Preconditions . checkNotNull ( description , STRING ) ; Preconditions . checkNotNull ( values , STRING ) ; for ( final String string : values ) { comboBox . addItem ( string ) ; } comboBox . setSelectedIndex ( selectedOption ) ; comboBox . setPreferredSize ( new Dimension ( PREFERRED_WIDTH , PREFERRED_HEIGHT ) ) ; addComponent ( panel , comboBox , description , hint ) ; }
public static int findEndOfString ( String str , int loc , int line ) throws ParseAlgorithmException { int pos = loc + _NUM ; boolean found = _BOOL ; while ( ( ! found ) && ( pos < str . length ( ) ) ) { char c = str . charAt ( pos ) ; if ( c == STRING ) { found = _BOOL ; } else if ( c == STRING && ( pos < str . length ( ) - _NUM ) ) { pos ++ ; } pos ++ ; } if ( ! found ) { throw new ParseAlgorithmException ( STRING + STRING + ( line + _NUM ) + STRING + ( loc + _NUM ) ) ; } return pos ; }
public static int findEndOfString ( String str , int loc , int line ) throws ParseAlgorithmException { int pos = loc + _NUM ; boolean found = _BOOL ; while ( ( ! found ) && ( pos < str . length ( ) ) ) { char c = str . charAt ( pos ) ; if ( c == STRING ) { found = _BOOL ; } else if ( c == STRING && ( pos < str . length ( ) - _NUM ) ) { pos ++ ; } pos ++ ; } if ( ! found ) { throw new ParseAlgorithmException ( STRING + STRING + ( line + _NUM ) + STRING + ( loc + _NUM ) ) ; } return pos ; }
public static IViewPart openViewNoFocus ( final String viewId ) { return openViewNoFocus ( viewId , null ) ; }
public static IViewPart openViewNoFocus ( final String viewId ) { return openViewNoFocus ( viewId , null ) ; }
public static IViewPart openViewNoFocus ( final String viewId ) { return openViewNoFocus ( viewId , null ) ; }
public static IViewPart openViewNoFocus ( final String viewId ) { return openViewNoFocus ( viewId , null ) ; }
public static IViewPart openViewNoFocus ( final String viewId ) { return openViewNoFocus ( viewId , null ) ; }
public static IViewPart openViewNoFocus ( final String viewId ) { return openViewNoFocus ( viewId , null ) ; }
@ OnMessage public void onMessage ( ByteBuffer buffer ) { if ( messageHandler != null ) { messageHandler . handleMessage ( buffer ) ; } fireWSHeartBitMonitorTimer ( ) ; }
@ OnMessage public void onMessage ( ByteBuffer buffer ) { if ( messageHandler != null ) { messageHandler . handleMessage ( buffer ) ; } fireWSHeartBitMonitorTimer ( ) ; }
@ OnMessage public void onMessage ( ByteBuffer buffer ) { if ( messageHandler != null ) { messageHandler . handleMessage ( buffer ) ; } fireWSHeartBitMonitorTimer ( ) ; }
private ValueRange rangeByWeek ( TemporalAccessor temporal , TemporalField field ) { int dow = localizedDayOfWeek ( temporal ) ; int offset = startOfWeekOffset ( temporal . get ( field ) , dow ) ; ValueRange fieldRange = temporal . range ( field ) ; return ValueRange . of ( computeWeek ( offset , ( int ) fieldRange . getMinimum ( ) ) , computeWeek ( offset , ( int ) fieldRange . getMaximum ( ) ) ) ; }
public static String mapModule ( String directory ) throws FileNotFoundException , JsonParserException { ScriptEngine engine = JavaScript . getEngine ( ) ; if ( engine . get ( STRING ) == null ) engine . put ( STRING , new HashMap < String , File > ( ) ) ; return mapModule ( new File ( directory ) , ( HashMap < String , File > ) engine . get ( STRING ) ) ; }
public CircularCharArrayBuffer ( int maxChar ) { buffer = new char [ maxChar ] ; if ( DEBUG ) Arrays . fill ( buffer , STRING ) ; }
private static ArrayList < IVCombination > findIVIntersection ( IVScanResult poke1 , IVScanResult poke2 ) { ArrayList < IVCombination > intersection = new ArrayList < > ( ) ; if ( poke1 != null && poke2 != null ) { ArrayList < IVCombination > p1IVs = poke1 . iVCombinations ; ArrayList < IVCombination > p2IVs = poke2 . iVCombinations ; for ( IVCombination p1IV : p1IVs ) { for ( IVCombination p2IV : p2IVs ) { if ( p1IV . equals ( p2IV ) ) { intersection . add ( p1IV ) ; } } } } return intersection ; }
private static ArrayList < IVCombination > findIVIntersection ( IVScanResult poke1 , IVScanResult poke2 ) { ArrayList < IVCombination > intersection = new ArrayList < > ( ) ; if ( poke1 != null && poke2 != null ) { ArrayList < IVCombination > p1IVs = poke1 . iVCombinations ; ArrayList < IVCombination > p2IVs = poke2 . iVCombinations ; for ( IVCombination p1IV : p1IVs ) { for ( IVCombination p2IV : p2IVs ) { if ( p1IV . equals ( p2IV ) ) { intersection . add ( p1IV ) ; } } } } return intersection ; }
private static ArrayList < IVCombination > findIVIntersection ( IVScanResult poke1 , IVScanResult poke2 ) { ArrayList < IVCombination > intersection = new ArrayList < > ( ) ; if ( poke1 != null && poke2 != null ) { ArrayList < IVCombination > p1IVs = poke1 . iVCombinations ; ArrayList < IVCombination > p2IVs = poke2 . iVCombinations ; for ( IVCombination p1IV : p1IVs ) { for ( IVCombination p2IV : p2IVs ) { if ( p1IV . equals ( p2IV ) ) { intersection . add ( p1IV ) ; } } } } return intersection ; }
private static ArrayList < IVCombination > findIVIntersection ( IVScanResult poke1 , IVScanResult poke2 ) { ArrayList < IVCombination > intersection = new ArrayList < > ( ) ; if ( poke1 != null && poke2 != null ) { ArrayList < IVCombination > p1IVs = poke1 . iVCombinations ; ArrayList < IVCombination > p2IVs = poke2 . iVCombinations ; for ( IVCombination p1IV : p1IVs ) { for ( IVCombination p2IV : p2IVs ) { if ( p1IV . equals ( p2IV ) ) { intersection . add ( p1IV ) ; } } } } return intersection ; }
private static ArrayList < IVCombination > findIVIntersection ( IVScanResult poke1 , IVScanResult poke2 ) { ArrayList < IVCombination > intersection = new ArrayList < > ( ) ; if ( poke1 != null && poke2 != null ) { ArrayList < IVCombination > p1IVs = poke1 . iVCombinations ; ArrayList < IVCombination > p2IVs = poke2 . iVCombinations ; for ( IVCombination p1IV : p1IVs ) { for ( IVCombination p2IV : p2IVs ) { if ( p1IV . equals ( p2IV ) ) { intersection . add ( p1IV ) ; } } } } return intersection ; }
void maybeAddDependency ( View anchorView , View childView , ViewChaseChoreography choreography ) { if ( childChoreography . containsKey ( anchorView ) ) { ChoreographyChain child = childChoreography . get ( anchorView ) ; child . addChildDependency ( childView , choreography ) ; return ; } for ( ChoreographyChain d : childChoreography . values ( ) ) { d . maybeAddDependency ( anchorView , childView , choreography ) ; } }
void maybeAddDependency ( View anchorView , View childView , ViewChaseChoreography choreography ) { if ( childChoreography . containsKey ( anchorView ) ) { ChoreographyChain child = childChoreography . get ( anchorView ) ; child . addChildDependency ( childView , choreography ) ; return ; } for ( ChoreographyChain d : childChoreography . values ( ) ) { d . maybeAddDependency ( anchorView , childView , choreography ) ; } }
public void parseSignaturesFile ( InputStream in , String name ) throws IOException , ParseException { logger . info ( STRING + name ) ; parseSignaturesFile ( in , _BOOL ) ; }
public void parseSignaturesFile ( InputStream in , String name ) throws IOException , ParseException { logger . info ( STRING + name ) ; parseSignaturesFile ( in , _BOOL ) ; }
public void parseSignaturesFile ( InputStream in , String name ) throws IOException , ParseException { logger . info ( STRING + name ) ; parseSignaturesFile ( in , _BOOL ) ; }
public void call ( String name , Writable json ) throws IOException { writeName ( name ) ; verifyValue ( ) ; if ( json instanceof GString ) { writer . write ( JsonOutput . toJson ( json . toString ( ) ) ) ; } else { json . writeTo ( writer ) ; } }
public void sort ( int fromIndex , int toIndex ) { Arrays . sort ( _data , fromIndex , toIndex ) ; }
protected void unpackElement ( Element shared , Element perNode ) { }
public boolean hasFreq ( ) { return hasFreq ; }
public boolean hasFreq ( ) { return hasFreq ; }
public GenericFeed retrievePageOfMailboxDumpRequests ( Date fromDate ) throws AppsForYourDomainException , MalformedURLException , IOException , ServiceException { String url = BASE_URL + STRING + domain ; if ( fromDate != null ) { url += STRING + DATE_FORMAT . format ( fromDate ) ; } return getFeed ( new URL ( url ) , GenericFeed . class ) ; }
public void add ( String argName , String desc , int expectedNumberOfArguments , boolean expectDashedArguments ) { Arg newArg = new Arg ( argName , desc , expectedNumberOfArguments , expectDashedArguments ) ; args . add ( newArg ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + argName ) ; } }
public void add ( String argName , String desc , int expectedNumberOfArguments , boolean expectDashedArguments ) { Arg newArg = new Arg ( argName , desc , expectedNumberOfArguments , expectDashedArguments ) ; args . add ( newArg ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + argName ) ; } }
public BottomNavigationBar addItem ( BottomNavigationItem item ) { mBottomNavigationItems . add ( item ) ; return this ; }
private void findCollapsesFromExistingVertices ( List collapsedVertexIndexes ) { for ( int i = _NUM ; i < edge . size ( ) - _NUM ; i ++ ) { Coordinate p0 = edge . getCoordinate ( i ) ; Coordinate p1 = edge . getCoordinate ( i + _NUM ) ; Coordinate p2 = edge . getCoordinate ( i + _NUM ) ; if ( p0 . equals2D ( p2 ) ) { collapsedVertexIndexes . add ( new Integer ( i + _NUM ) ) ; } } }
private void findCollapsesFromExistingVertices ( List collapsedVertexIndexes ) { for ( int i = _NUM ; i < edge . size ( ) - _NUM ; i ++ ) { Coordinate p0 = edge . getCoordinate ( i ) ; Coordinate p1 = edge . getCoordinate ( i + _NUM ) ; Coordinate p2 = edge . getCoordinate ( i + _NUM ) ; if ( p0 . equals2D ( p2 ) ) { collapsedVertexIndexes . add ( new Integer ( i + _NUM ) ) ; } } }
private void findCollapsesFromExistingVertices ( List collapsedVertexIndexes ) { for ( int i = _NUM ; i < edge . size ( ) - _NUM ; i ++ ) { Coordinate p0 = edge . getCoordinate ( i ) ; Coordinate p1 = edge . getCoordinate ( i + _NUM ) ; Coordinate p2 = edge . getCoordinate ( i + _NUM ) ; if ( p0 . equals2D ( p2 ) ) { collapsedVertexIndexes . add ( new Integer ( i + _NUM ) ) ; } } }
private void findCollapsesFromExistingVertices ( List collapsedVertexIndexes ) { for ( int i = _NUM ; i < edge . size ( ) - _NUM ; i ++ ) { Coordinate p0 = edge . getCoordinate ( i ) ; Coordinate p1 = edge . getCoordinate ( i + _NUM ) ; Coordinate p2 = edge . getCoordinate ( i + _NUM ) ; if ( p0 . equals2D ( p2 ) ) { collapsedVertexIndexes . add ( new Integer ( i + _NUM ) ) ; } } }
public SimpleSimilarity ( double dInit ) { Simil = Double . valueOf ( dInit ) ; }
public void addAllTagsOf ( Host h ) { List < Tag > tags = h . getTags ( ) ; if ( tags . isEmpty ( ) ) return ; if ( mTagList == null ) { mTagList = new ArrayList < Tag > ( tags . size ( ) ) ; } mTagList . addAll ( tags ) ; }
protected void stopSpin ( ) { if ( spinning ) { try { spinLimiter . acquire ( ) ; } catch ( InterruptedException e ) { throw new ActiveMQInterruptedException ( e ) ; } spinning = _BOOL ; } }
protected void stopSpin ( ) { if ( spinning ) { try { spinLimiter . acquire ( ) ; } catch ( InterruptedException e ) { throw new ActiveMQInterruptedException ( e ) ; } spinning = _BOOL ; } }
protected void stopSpin ( ) { if ( spinning ) { try { spinLimiter . acquire ( ) ; } catch ( InterruptedException e ) { throw new ActiveMQInterruptedException ( e ) ; } spinning = _BOOL ; } }
public Form showForm ( String resourceName , Command sourceCommand ) { Form f = ( Form ) createContainer ( fetchResourceFile ( ) , resourceName ) ; showForm ( f , sourceCommand , null ) ; return f ; }
public String extract_package ( String fullname ) { return fullname . replaceFirst ( STRING , STRING ) ; }
public String extract_package ( String fullname ) { return fullname . replaceFirst ( STRING , STRING ) ; }
private String createDashArrayString ( List < Float > dashesArray ) { StringBuilder sb = new StringBuilder ( ) ; if ( dashesArray != null ) { int index = _NUM ; for ( Float value : dashesArray ) { String str = Float . toString ( value ) ; if ( str . endsWith ( STRING ) ) { sb . append ( value . intValue ( ) ) ; } else { sb . append ( value ) ; } if ( index < dashesArray . size ( ) - _NUM ) { sb . append ( STRING ) ; } index ++ ; } } return sb . toString ( ) ; }
public Bitmap pop ( long timeout , TimeUnit unit ) throws InterruptedException { checkNotMainThread ( ) ; ensureScheduled ( ) ; return finished . poll ( timeout , unit ) ; }
public Bitmap pop ( long timeout , TimeUnit unit ) throws InterruptedException { checkNotMainThread ( ) ; ensureScheduled ( ) ; return finished . poll ( timeout , unit ) ; }
public Bitmap pop ( long timeout , TimeUnit unit ) throws InterruptedException { checkNotMainThread ( ) ; ensureScheduled ( ) ; return finished . poll ( timeout , unit ) ; }
public void applyMissingValuesTreatment ( double [ ] values ) throws Exception { for ( int i = _NUM ; i < m_miningMeta . size ( ) ; i ++ ) { MiningFieldMetaInfo mfi = m_miningMeta . get ( i ) ; values [ i ] = mfi . applyMissingValueTreatment ( values [ i ] ) ; } }
Set findRemovableAciList ( Set aciList ) throws AMException , SSOException { Set resultSet = new HashSet ( ) ; if ( aciList == null ) { return resultSet ; } Iterator iter = aciList . iterator ( ) ; while ( iter . hasNext ( ) ) { String aci = ( String ) iter . next ( ) ; Set objs = dsServices . search ( token , AMStoreConnection . getAMSdkBaseDN ( ) , STRING + AMSearchFilterManager . getGlobalSearchFilter ( AMObject . GROUP ) + STRING + aci + STRING , AMConstants . SCOPE_SUB ) ; if ( objs . size ( ) < _NUM ) { resultSet . add ( aci ) ; } } return resultSet ; }
public String evaluate ( Associator associator , Instances data ) throws Exception { long startTime ; long endTime ; startTime = System . currentTimeMillis ( ) ; associator . buildAssociations ( data ) ; endTime = System . currentTimeMillis ( ) ; m_Result = new StringBuffer ( associator . toString ( ) ) ; m_Result . append ( STRING ) ; m_Result . append ( STRING + ( ( ( double ) ( endTime - startTime ) ) / _NUM ) + STRING ) ; m_Result . append ( STRING ) ; return m_Result . toString ( ) ; }
public String evaluate ( Associator associator , Instances data ) throws Exception { long startTime ; long endTime ; startTime = System . currentTimeMillis ( ) ; associator . buildAssociations ( data ) ; endTime = System . currentTimeMillis ( ) ; m_Result = new StringBuffer ( associator . toString ( ) ) ; m_Result . append ( STRING ) ; m_Result . append ( STRING + ( ( ( double ) ( endTime - startTime ) ) / _NUM ) + STRING ) ; m_Result . append ( STRING ) ; return m_Result . toString ( ) ; }
public String evaluate ( Associator associator , Instances data ) throws Exception { long startTime ; long endTime ; startTime = System . currentTimeMillis ( ) ; associator . buildAssociations ( data ) ; endTime = System . currentTimeMillis ( ) ; m_Result = new StringBuffer ( associator . toString ( ) ) ; m_Result . append ( STRING ) ; m_Result . append ( STRING + ( ( ( double ) ( endTime - startTime ) ) / _NUM ) + STRING ) ; m_Result . append ( STRING ) ; return m_Result . toString ( ) ; }
@ Override public void modifyVariableId ( String oldId , String newId ) { if ( variables . contains ( oldId ) ) { variables . remove ( oldId ) ; variables . add ( newId ) ; } for ( Assignment a : samples ) { if ( a . containsVar ( oldId ) ) { Value v = a . removePair ( oldId ) ; a . addPair ( newId , v ) ; } } if ( discreteCache != null ) { discreteCache . modifyVariableId ( oldId , newId ) ; } if ( continuousCache != null ) { continuousCache . modifyVariableId ( oldId , newId ) ; } }
@ Override public void modifyVariableId ( String oldId , String newId ) { if ( variables . contains ( oldId ) ) { variables . remove ( oldId ) ; variables . add ( newId ) ; } for ( Assignment a : samples ) { if ( a . containsVar ( oldId ) ) { Value v = a . removePair ( oldId ) ; a . addPair ( newId , v ) ; } } if ( discreteCache != null ) { discreteCache . modifyVariableId ( oldId , newId ) ; } if ( continuousCache != null ) { continuousCache . modifyVariableId ( oldId , newId ) ; } }
public String toString ( ) { return WKTWriter . toLineString ( new CoordinateArraySequence ( getCoordinates ( ) ) ) ; }
public static < V > Future < V > submit ( Callable < V > task ) { if ( task == null ) { throw new NullPointerException ( ) ; } FutureTask < V > future = new FutureTask < V > ( task ) ; execute ( future ) ; return future ; }
public static < V > Future < V > submit ( Callable < V > task ) { if ( task == null ) { throw new NullPointerException ( ) ; } FutureTask < V > future = new FutureTask < V > ( task ) ; execute ( future ) ; return future ; }
public static < V > Future < V > submit ( Callable < V > task ) { if ( task == null ) { throw new NullPointerException ( ) ; } FutureTask < V > future = new FutureTask < V > ( task ) ; execute ( future ) ; return future ; }
public static < V > Future < V > submit ( Callable < V > task ) { if ( task == null ) { throw new NullPointerException ( ) ; } FutureTask < V > future = new FutureTask < V > ( task ) ; execute ( future ) ; return future ; }
public synchronized void sleepUntil ( long timeToWakeFromPhoneBoot ) { writeDebug ( STRING + new Date ( System . currentTimeMillis ( ) + timeToWakeFromPhoneBoot - SystemClock . elapsedRealtime ( ) ) ) ; if ( wakeLock . isHeld ( ) ) { writeDebug ( STRING ) ; wakeLock . release ( ) ; } alarmManager . set ( AlarmManager . ELAPSED_REALTIME_WAKEUP , timeToWakeFromPhoneBoot , sender ) ; }
public synchronized void sleepUntil ( long timeToWakeFromPhoneBoot ) { writeDebug ( STRING + new Date ( System . currentTimeMillis ( ) + timeToWakeFromPhoneBoot - SystemClock . elapsedRealtime ( ) ) ) ; if ( wakeLock . isHeld ( ) ) { writeDebug ( STRING ) ; wakeLock . release ( ) ; } alarmManager . set ( AlarmManager . ELAPSED_REALTIME_WAKEUP , timeToWakeFromPhoneBoot , sender ) ; }
public synchronized void sleepUntil ( long timeToWakeFromPhoneBoot ) { writeDebug ( STRING + new Date ( System . currentTimeMillis ( ) + timeToWakeFromPhoneBoot - SystemClock . elapsedRealtime ( ) ) ) ; if ( wakeLock . isHeld ( ) ) { writeDebug ( STRING ) ; wakeLock . release ( ) ; } alarmManager . set ( AlarmManager . ELAPSED_REALTIME_WAKEUP , timeToWakeFromPhoneBoot , sender ) ; }
public synchronized void sleepUntil ( long timeToWakeFromPhoneBoot ) { writeDebug ( STRING + new Date ( System . currentTimeMillis ( ) + timeToWakeFromPhoneBoot - SystemClock . elapsedRealtime ( ) ) ) ; if ( wakeLock . isHeld ( ) ) { writeDebug ( STRING ) ; wakeLock . release ( ) ; } alarmManager . set ( AlarmManager . ELAPSED_REALTIME_WAKEUP , timeToWakeFromPhoneBoot , sender ) ; }
public Tag read ( RandomAccessFile raf ) throws CannotReadException , IOException { logger . config ( STRING ) ; byte [ ] rawVorbisCommentData = readRawPacketData ( raf ) ; VorbisCommentTag tag = vorbisCommentReader . read ( rawVorbisCommentData , _BOOL ) ; logger . fine ( STRING ) ; return tag ; }
public Tag read ( RandomAccessFile raf ) throws CannotReadException , IOException { logger . config ( STRING ) ; byte [ ] rawVorbisCommentData = readRawPacketData ( raf ) ; VorbisCommentTag tag = vorbisCommentReader . read ( rawVorbisCommentData , _BOOL ) ; logger . fine ( STRING ) ; return tag ; }
public Tag read ( RandomAccessFile raf ) throws CannotReadException , IOException { logger . config ( STRING ) ; byte [ ] rawVorbisCommentData = readRawPacketData ( raf ) ; VorbisCommentTag tag = vorbisCommentReader . read ( rawVorbisCommentData , _BOOL ) ; logger . fine ( STRING ) ; return tag ; }
public void findChargeElementID ( ) { m_C_AcctSchema_ID = Env . getContextAsInt ( Env . getCtx ( ) , STRING ) ; String sql = STRING + STRING + STRING ; try { PreparedStatement pstmt = DB . prepareStatement ( sql , null ) ; pstmt . setInt ( _NUM , m_C_AcctSchema_ID ) ; ResultSet rs = pstmt . executeQuery ( ) ; if ( rs . next ( ) ) { m_C_Element_ID = rs . getInt ( _NUM ) ; } rs . close ( ) ; pstmt . close ( ) ; } catch ( SQLException exception ) { log . log ( Level . SEVERE , sql , exception ) ; } }
public static byte [ ] packByteBufferIntoSingleByteArray ( byte [ ] [ ] byteBufferArr ) { if ( null == byteBufferArr || byteBufferArr . length == _NUM ) { return null ; } int noOfCol = byteBufferArr . length ; short toDetermineLengthOfByteArr = _NUM ; short offsetLen = ( short ) ( noOfCol * _NUM + toDetermineLengthOfByteArr ) ; int totalBytes = calculateTotalBytes ( byteBufferArr ) + offsetLen ; ByteBuffer buffer = ByteBuffer . allocate ( totalBytes ) ; buffer . putShort ( ( short ) ( totalBytes - toDetermineLengthOfByteArr ) ) ; buffer . putShort ( offsetLen ) ; for ( int index = _NUM ; index < byteBufferArr . length - _NUM ; index ++ ) { int noOfBytes = byteBufferArr [ index ] . length ; buffer . putShort ( ( short ) ( offsetLen + noOfBytes ) ) ; offsetLen += noOfBytes ; } for ( int index = _NUM ; index < byteBufferArr . length ; index ++ ) { buffer . put ( byteBufferArr [ index ] ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }
public static byte [ ] packByteBufferIntoSingleByteArray ( byte [ ] [ ] byteBufferArr ) { if ( null == byteBufferArr || byteBufferArr . length == _NUM ) { return null ; } int noOfCol = byteBufferArr . length ; short toDetermineLengthOfByteArr = _NUM ; short offsetLen = ( short ) ( noOfCol * _NUM + toDetermineLengthOfByteArr ) ; int totalBytes = calculateTotalBytes ( byteBufferArr ) + offsetLen ; ByteBuffer buffer = ByteBuffer . allocate ( totalBytes ) ; buffer . putShort ( ( short ) ( totalBytes - toDetermineLengthOfByteArr ) ) ; buffer . putShort ( offsetLen ) ; for ( int index = _NUM ; index < byteBufferArr . length - _NUM ; index ++ ) { int noOfBytes = byteBufferArr [ index ] . length ; buffer . putShort ( ( short ) ( offsetLen + noOfBytes ) ) ; offsetLen += noOfBytes ; } for ( int index = _NUM ; index < byteBufferArr . length ; index ++ ) { buffer . put ( byteBufferArr [ index ] ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }
public static byte [ ] packByteBufferIntoSingleByteArray ( byte [ ] [ ] byteBufferArr ) { if ( null == byteBufferArr || byteBufferArr . length == _NUM ) { return null ; } int noOfCol = byteBufferArr . length ; short toDetermineLengthOfByteArr = _NUM ; short offsetLen = ( short ) ( noOfCol * _NUM + toDetermineLengthOfByteArr ) ; int totalBytes = calculateTotalBytes ( byteBufferArr ) + offsetLen ; ByteBuffer buffer = ByteBuffer . allocate ( totalBytes ) ; buffer . putShort ( ( short ) ( totalBytes - toDetermineLengthOfByteArr ) ) ; buffer . putShort ( offsetLen ) ; for ( int index = _NUM ; index < byteBufferArr . length - _NUM ; index ++ ) { int noOfBytes = byteBufferArr [ index ] . length ; buffer . putShort ( ( short ) ( offsetLen + noOfBytes ) ) ; offsetLen += noOfBytes ; } for ( int index = _NUM ; index < byteBufferArr . length ; index ++ ) { buffer . put ( byteBufferArr [ index ] ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }
public SuffixFileFilter ( String [ ] suffixes , IOCase caseSensitivity ) { if ( suffixes == null ) { throw new IllegalArgumentException ( STRING ) ; } this . suffixes = new String [ suffixes . length ] ; System . arraycopy ( suffixes , _NUM , this . suffixes , _NUM , suffixes . length ) ; this . caseSensitivity = caseSensitivity == null ? IOCase . SENSITIVE : caseSensitivity ; }
public SuffixFileFilter ( String [ ] suffixes , IOCase caseSensitivity ) { if ( suffixes == null ) { throw new IllegalArgumentException ( STRING ) ; } this . suffixes = new String [ suffixes . length ] ; System . arraycopy ( suffixes , _NUM , this . suffixes , _NUM , suffixes . length ) ; this . caseSensitivity = caseSensitivity == null ? IOCase . SENSITIVE : caseSensitivity ; }
public void remove ( ) throws RecurrenceInfoException { List < RecurrenceRule > rulesList = new ArrayList < RecurrenceRule > ( ) ; rulesList . addAll ( rRulesList ) ; rulesList . addAll ( eRulesList ) ; try { for ( RecurrenceRule rule : rulesList ) rule . remove ( ) ; info . remove ( ) ; } catch ( RecurrenceRuleException rre ) { throw new RecurrenceInfoException ( rre . getMessage ( ) , rre ) ; } catch ( GenericEntityException gee ) { throw new RecurrenceInfoException ( gee . getMessage ( ) , gee ) ; } }
public static double nonRobustComputeEdgeDistance ( Coordinate p , Coordinate p1 , Coordinate p2 ) { double dx = p . x - p1 . x ; double dy = p . y - p1 . y ; double dist = Math . sqrt ( dx * dx + dy * dy ) ; Assert . isTrue ( ! ( dist == _NUM && ! p . equals ( p1 ) ) , STRING ) ; return dist ; }
public static double nonRobustComputeEdgeDistance ( Coordinate p , Coordinate p1 , Coordinate p2 ) { double dx = p . x - p1 . x ; double dy = p . y - p1 . y ; double dist = Math . sqrt ( dx * dx + dy * dy ) ; Assert . isTrue ( ! ( dist == _NUM && ! p . equals ( p1 ) ) , STRING ) ; return dist ; }
public static double nonRobustComputeEdgeDistance ( Coordinate p , Coordinate p1 , Coordinate p2 ) { double dx = p . x - p1 . x ; double dy = p . y - p1 . y ; double dist = Math . sqrt ( dx * dx + dy * dy ) ; Assert . isTrue ( ! ( dist == _NUM && ! p . equals ( p1 ) ) , STRING ) ; return dist ; }
private CertificateVerify ( SignatureAndHashAlgorithm signatureAndHashAlgorithm , byte [ ] signatureBytes , InetSocketAddress peerAddress ) { this ( signatureAndHashAlgorithm , peerAddress ) ; this . signatureBytes = Arrays . copyOf ( signatureBytes , signatureBytes . length ) ; }
public synchronized void recordStatistics ( QueryStatistic statistic ) { queryStatistics . add ( statistic ) ; }
public synchronized void recordStatistics ( QueryStatistic statistic ) { queryStatistics . add ( statistic ) ; }
public synchronized void addActionListener ( ActionListener actionListener ) { if ( actionListeners == null ) actionListeners = new ArrayList < ActionListener > ( ) ; actionListeners . add ( actionListener ) ; if ( fired ) { actionListener . actionPerformed ( new ActionEvent ( this , ActionEvent . ACTION_PERFORMED , STRING ) ) ; } }
public synchronized void addActionListener ( ActionListener actionListener ) { if ( actionListeners == null ) actionListeners = new ArrayList < ActionListener > ( ) ; actionListeners . add ( actionListener ) ; if ( fired ) { actionListener . actionPerformed ( new ActionEvent ( this , ActionEvent . ACTION_PERFORMED , STRING ) ) ; } }
static void orderedShowViews ( final List < View > views , long animationDuration , int animationDelay ) { if ( views != null ) { for ( int viewIndex = _NUM ; viewIndex < views . size ( ) ; viewIndex ++ ) { final View childView = views . get ( viewIndex ) ; childView . setVisibility ( View . VISIBLE ) ; final ScaleAnimation scaleAnimation = new ScaleAnimation ( _NUM , childView . getScaleX ( ) , _NUM , childView . getScaleY ( ) , Animation . RELATIVE_TO_SELF , _NUM , Animation . RELATIVE_TO_SELF , _NUM ) ; scaleAnimation . setInterpolator ( new DecelerateInterpolator ( ) ) ; scaleAnimation . setDuration ( animationDuration ) ; scaleAnimation . setStartOffset ( viewIndex * animationDelay ) ; childView . startAnimation ( scaleAnimation ) ; } } }
static void orderedShowViews ( final List < View > views , long animationDuration , int animationDelay ) { if ( views != null ) { for ( int viewIndex = _NUM ; viewIndex < views . size ( ) ; viewIndex ++ ) { final View childView = views . get ( viewIndex ) ; childView . setVisibility ( View . VISIBLE ) ; final ScaleAnimation scaleAnimation = new ScaleAnimation ( _NUM , childView . getScaleX ( ) , _NUM , childView . getScaleY ( ) , Animation . RELATIVE_TO_SELF , _NUM , Animation . RELATIVE_TO_SELF , _NUM ) ; scaleAnimation . setInterpolator ( new DecelerateInterpolator ( ) ) ; scaleAnimation . setDuration ( animationDuration ) ; scaleAnimation . setStartOffset ( viewIndex * animationDelay ) ; childView . startAnimation ( scaleAnimation ) ; } } }
private static int createPackedParams ( SunGraphics2D sg2d , GlyphList gl ) { return ( ( ( gl . usePositions ( ) ? _NUM : _NUM ) << OFFSET_POSITIONS ) | ( ( gl . isSubPixPos ( ) ? _NUM : _NUM ) << OFFSET_SUBPIXPOS ) | ( ( gl . isRGBOrder ( ) ? _NUM : _NUM ) << OFFSET_RGBORDER ) | ( ( sg2d . lcdTextContrast & _NUM ) << OFFSET_CONTRAST ) ) ; }
private static int createPackedParams ( SunGraphics2D sg2d , GlyphList gl ) { return ( ( ( gl . usePositions ( ) ? _NUM : _NUM ) << OFFSET_POSITIONS ) | ( ( gl . isSubPixPos ( ) ? _NUM : _NUM ) << OFFSET_SUBPIXPOS ) | ( ( gl . isRGBOrder ( ) ? _NUM : _NUM ) << OFFSET_RGBORDER ) | ( ( sg2d . lcdTextContrast & _NUM ) << OFFSET_CONTRAST ) ) ; }
private static int createPackedParams ( SunGraphics2D sg2d , GlyphList gl ) { return ( ( ( gl . usePositions ( ) ? _NUM : _NUM ) << OFFSET_POSITIONS ) | ( ( gl . isSubPixPos ( ) ? _NUM : _NUM ) << OFFSET_SUBPIXPOS ) | ( ( gl . isRGBOrder ( ) ? _NUM : _NUM ) << OFFSET_RGBORDER ) | ( ( sg2d . lcdTextContrast & _NUM ) << OFFSET_CONTRAST ) ) ; }
private static int createPackedParams ( SunGraphics2D sg2d , GlyphList gl ) { return ( ( ( gl . usePositions ( ) ? _NUM : _NUM ) << OFFSET_POSITIONS ) | ( ( gl . isSubPixPos ( ) ? _NUM : _NUM ) << OFFSET_SUBPIXPOS ) | ( ( gl . isRGBOrder ( ) ? _NUM : _NUM ) << OFFSET_RGBORDER ) | ( ( sg2d . lcdTextContrast & _NUM ) << OFFSET_CONTRAST ) ) ; }
private static int createPackedParams ( SunGraphics2D sg2d , GlyphList gl ) { return ( ( ( gl . usePositions ( ) ? _NUM : _NUM ) << OFFSET_POSITIONS ) | ( ( gl . isSubPixPos ( ) ? _NUM : _NUM ) << OFFSET_SUBPIXPOS ) | ( ( gl . isRGBOrder ( ) ? _NUM : _NUM ) << OFFSET_RGBORDER ) | ( ( sg2d . lcdTextContrast & _NUM ) << OFFSET_CONTRAST ) ) ; }
private static int createPackedParams ( SunGraphics2D sg2d , GlyphList gl ) { return ( ( ( gl . usePositions ( ) ? _NUM : _NUM ) << OFFSET_POSITIONS ) | ( ( gl . isSubPixPos ( ) ? _NUM : _NUM ) << OFFSET_SUBPIXPOS ) | ( ( gl . isRGBOrder ( ) ? _NUM : _NUM ) << OFFSET_RGBORDER ) | ( ( sg2d . lcdTextContrast & _NUM ) << OFFSET_CONTRAST ) ) ; }
private static int createPackedParams ( SunGraphics2D sg2d , GlyphList gl ) { return ( ( ( gl . usePositions ( ) ? _NUM : _NUM ) << OFFSET_POSITIONS ) | ( ( gl . isSubPixPos ( ) ? _NUM : _NUM ) << OFFSET_SUBPIXPOS ) | ( ( gl . isRGBOrder ( ) ? _NUM : _NUM ) << OFFSET_RGBORDER ) | ( ( sg2d . lcdTextContrast & _NUM ) << OFFSET_CONTRAST ) ) ; }
private static int createPackedParams ( SunGraphics2D sg2d , GlyphList gl ) { return ( ( ( gl . usePositions ( ) ? _NUM : _NUM ) << OFFSET_POSITIONS ) | ( ( gl . isSubPixPos ( ) ? _NUM : _NUM ) << OFFSET_SUBPIXPOS ) | ( ( gl . isRGBOrder ( ) ? _NUM : _NUM ) << OFFSET_RGBORDER ) | ( ( sg2d . lcdTextContrast & _NUM ) << OFFSET_CONTRAST ) ) ; }
protected void updateView ( View view ) { try { mStatusText = ( TextView ) view . findViewById ( R . id . seekBarPrefValue ) ; mStatusText . setText ( String . valueOf ( mCurrentValue ) ) ; mStatusText . setMinimumWidth ( _NUM ) ; mSeekBar . setProgress ( mCurrentValue - mMinValue ) ; } catch ( Exception e ) { Log . e ( TAG , STRING , e ) ; } }
public void addItemBoundsListener ( ItemBoundsListener ibl ) { if ( m_bounders == null ) { m_bounders = new CopyOnWriteArrayList ( ) ; } m_bounders . add ( ibl ) ; }
public void addItemBoundsListener ( ItemBoundsListener ibl ) { if ( m_bounders == null ) { m_bounders = new CopyOnWriteArrayList ( ) ; } m_bounders . add ( ibl ) ; }
public void addItemBoundsListener ( ItemBoundsListener ibl ) { if ( m_bounders == null ) { m_bounders = new CopyOnWriteArrayList ( ) ; } m_bounders . add ( ibl ) ; }
public void addItemBoundsListener ( ItemBoundsListener ibl ) { if ( m_bounders == null ) { m_bounders = new CopyOnWriteArrayList ( ) ; } m_bounders . add ( ibl ) ; }
public static Supply add ( final int divisibility , final Supply s1 , final Supply s2 ) { final Supply sum = MosaicUtils . tryAdd ( divisibility , s1 , s2 ) ; if ( null == sum ) { final String message = String . format ( STRING , s1 , s2 , divisibility ) ; throw new IllegalArgumentException ( message ) ; } return sum ; }
public static Supply add ( final int divisibility , final Supply s1 , final Supply s2 ) { final Supply sum = MosaicUtils . tryAdd ( divisibility , s1 , s2 ) ; if ( null == sum ) { final String message = String . format ( STRING , s1 , s2 , divisibility ) ; throw new IllegalArgumentException ( message ) ; } return sum ; }
public synchronized boolean containsKey ( CacheKey key ) { Preconditions . checkNotNull ( key ) ; if ( ! mMap . containsKey ( key ) ) { return _BOOL ; } EncodedImage storedEncodedImage = mMap . get ( key ) ; synchronized ( storedEncodedImage ) { if ( ! EncodedImage . isValid ( storedEncodedImage ) ) { mMap . remove ( key ) ; FLog . w ( TAG , STRING , System . identityHashCode ( storedEncodedImage ) , key . toString ( ) , System . identityHashCode ( key ) ) ; return _BOOL ; } return _BOOL ; } }
public synchronized boolean containsKey ( CacheKey key ) { Preconditions . checkNotNull ( key ) ; if ( ! mMap . containsKey ( key ) ) { return _BOOL ; } EncodedImage storedEncodedImage = mMap . get ( key ) ; synchronized ( storedEncodedImage ) { if ( ! EncodedImage . isValid ( storedEncodedImage ) ) { mMap . remove ( key ) ; FLog . w ( TAG , STRING , System . identityHashCode ( storedEncodedImage ) , key . toString ( ) , System . identityHashCode ( key ) ) ; return _BOOL ; } return _BOOL ; } }
public void testReverseStepByOneWithClosure ( ) { final List callLog = new ArrayList ( ) ; final Closure closure = new RecordingClosure ( callLog ) ; final Range range = createRange ( _NUM , _NUM ) ; range . step ( _NUM , closure ) ; assertEquals ( STRING , _NUM , callLog . size ( ) ) ; final Iterator iter = callLog . iterator ( ) ; for ( int i = _NUM ; i >= _NUM ; i -- ) { assertEquals ( STRING , createValue ( i ) , iter . next ( ) ) ; } }
public VNXeCommandResult addLunsToLunGroup ( String lunGroupId , List < String > luns ) { LunGroupModifyParam param = new LunGroupModifyParam ( ) ; List < LunAddParam > lunAdds = new ArrayList < LunAddParam > ( ) ; for ( String lunId : luns ) { VNXeBase lun = new VNXeBase ( lunId ) ; LunAddParam lunAdd = new LunAddParam ( ) ; lunAdd . setLun ( lun ) ; lunAdds . add ( lunAdd ) ; } param . setLunAdd ( lunAdds ) ; LunGroupRequests req = new LunGroupRequests ( _khClient ) ; return req . modifyLunGroupSync ( lunGroupId , param ) ; }
private synchronized void migrateAPI ( SQLiteDatabase db ) { Log . d ( LOGTAG , STRING ) ; String user = prefs . getString ( r . getString ( R . string . config_username_key ) , STRING ) ; String pass = prefs . getString ( r . getString ( R . string . config_password_key ) , STRING ) ; String name = STRING ; Log . d ( LOGTAG , STRING + user + STRING ) ; addAPI ( db , ID_DEFAULT , name , API_DEFAULT , null , null , user , pass , ID_DEFAULT , _BOOL , _BOOL ) ; Log . d ( LOGTAG , STRING ) ; addAPI ( db , ID_DEFAULT_NO_HTTPS , STRING , API_DEFAULT_NO_HTTPS , null , null , STRING , STRING , ID_DEFAULT_NO_HTTPS , _BOOL , _BOOL ) ; Log . d ( LOGTAG , STRING ) ; selectAPI ( db , ID_DEFAULT ) ; Log . d ( LOGTAG , STRING ) ; Editor editor = prefs . edit ( ) ; editor . remove ( r . getString ( R . string . config_username_key ) ) ; editor . remove ( r . getString ( R . string . config_password_key ) ) ; editor . commit ( ) ; Log . d ( LOGTAG , STRING ) ; }
private synchronized void migrateAPI ( SQLiteDatabase db ) { Log . d ( LOGTAG , STRING ) ; String user = prefs . getString ( r . getString ( R . string . config_username_key ) , STRING ) ; String pass = prefs . getString ( r . getString ( R . string . config_password_key ) , STRING ) ; String name = STRING ; Log . d ( LOGTAG , STRING + user + STRING ) ; addAPI ( db , ID_DEFAULT , name , API_DEFAULT , null , null , user , pass , ID_DEFAULT , _BOOL , _BOOL ) ; Log . d ( LOGTAG , STRING ) ; addAPI ( db , ID_DEFAULT_NO_HTTPS , STRING , API_DEFAULT_NO_HTTPS , null , null , STRING , STRING , ID_DEFAULT_NO_HTTPS , _BOOL , _BOOL ) ; Log . d ( LOGTAG , STRING ) ; selectAPI ( db , ID_DEFAULT ) ; Log . d ( LOGTAG , STRING ) ; Editor editor = prefs . edit ( ) ; editor . remove ( r . getString ( R . string . config_username_key ) ) ; editor . remove ( r . getString ( R . string . config_password_key ) ) ; editor . commit ( ) ; Log . d ( LOGTAG , STRING ) ; }
public static Annotation findFirstQualifierInAnnotations ( Field field ) { return findFirstQualifierInAnnotations ( field . getAnnotations ( ) ) ; }
public SourceModel sourceForClass ( ReferenceType refType ) { SourceModel sm = classToSource . get ( refType ) ; if ( sm != null ) { return sm ; } try { String filename = refType . sourceName ( ) ; String refName = refType . name ( ) ; int iDot = refName . lastIndexOf ( STRING ) ; String pkgName = ( iDot >= _NUM ) ? refName . substring ( _NUM , iDot + _NUM ) : STRING ; String full = pkgName . replace ( STRING , File . separatorChar ) + filename ; File path = sourcePath . resolve ( full ) ; if ( path != null ) { sm = sourceForFile ( path ) ; classToSource . put ( refType , sm ) ; return sm ; } return null ; } catch ( AbsentInformationException e ) { return null ; } }
protected AbstractProtocolDescriptor ( int version , int architecture , int minimumType , int maximumType , int weight ) { this . version = version ; this . architecture = architecture ; this . minimumType = minimumType ; this . maximumType = maximumType ; this . weight = weight ; hashCode = Objects . hash ( version , architecture , minimumType , maximumType , weight ) ; }
public ChatBuilder addEmail ( String email ) { emails . add ( email ) ; return this ; }
public ChatBuilder addEmail ( String email ) { emails . add ( email ) ; return this ; }
public static String encryptWithAsymmetricKey ( String data , String encryptionAlgorithm , int encryptionStrength , Key encKey ) throws Exception { try { KeyGenerator keygen = KeyGenerator . getInstance ( encryptionAlgorithm ) ; if ( encryptionStrength != _NUM ) { keygen . init ( encryptionStrength ) ; } SecretKey sKey = keygen . generateKey ( ) ; Cipher cipher = Cipher . getInstance ( encryptionAlgorithm ) ; cipher . init ( Cipher . ENCRYPT_MODE , sKey ) ; byte [ ] encData = cipher . doFinal ( data . getBytes ( STRING ) ) ; cipher = Cipher . getInstance ( encKey . getAlgorithm ( ) ) ; cipher . init ( Cipher . WRAP_MODE , encKey ) ; byte [ ] keyWrap = cipher . wrap ( sKey ) ; byte [ ] encDataPad = wrapKeyWithEncryptedData ( encData , keyWrap ) ; return Base64 . encode ( encDataPad ) ; } catch ( NoSuchAlgorithmException nse ) { throw new Exception ( nse . getMessage ( ) ) ; } catch ( NoSuchPaddingException npe ) { throw new Exception ( npe . getMessage ( ) ) ; } catch ( InvalidKeyException ike ) { throw new Exception ( ike . getMessage ( ) ) ; } catch ( UnsupportedEncodingException uae ) { throw new Exception ( uae . getMessage ( ) ) ; } }
public static String encryptWithAsymmetricKey ( String data , String encryptionAlgorithm , int encryptionStrength , Key encKey ) throws Exception { try { KeyGenerator keygen = KeyGenerator . getInstance ( encryptionAlgorithm ) ; if ( encryptionStrength != _NUM ) { keygen . init ( encryptionStrength ) ; } SecretKey sKey = keygen . generateKey ( ) ; Cipher cipher = Cipher . getInstance ( encryptionAlgorithm ) ; cipher . init ( Cipher . ENCRYPT_MODE , sKey ) ; byte [ ] encData = cipher . doFinal ( data . getBytes ( STRING ) ) ; cipher = Cipher . getInstance ( encKey . getAlgorithm ( ) ) ; cipher . init ( Cipher . WRAP_MODE , encKey ) ; byte [ ] keyWrap = cipher . wrap ( sKey ) ; byte [ ] encDataPad = wrapKeyWithEncryptedData ( encData , keyWrap ) ; return Base64 . encode ( encDataPad ) ; } catch ( NoSuchAlgorithmException nse ) { throw new Exception ( nse . getMessage ( ) ) ; } catch ( NoSuchPaddingException npe ) { throw new Exception ( npe . getMessage ( ) ) ; } catch ( InvalidKeyException ike ) { throw new Exception ( ike . getMessage ( ) ) ; } catch ( UnsupportedEncodingException uae ) { throw new Exception ( uae . getMessage ( ) ) ; } }
public static String encryptWithAsymmetricKey ( String data , String encryptionAlgorithm , int encryptionStrength , Key encKey ) throws Exception { try { KeyGenerator keygen = KeyGenerator . getInstance ( encryptionAlgorithm ) ; if ( encryptionStrength != _NUM ) { keygen . init ( encryptionStrength ) ; } SecretKey sKey = keygen . generateKey ( ) ; Cipher cipher = Cipher . getInstance ( encryptionAlgorithm ) ; cipher . init ( Cipher . ENCRYPT_MODE , sKey ) ; byte [ ] encData = cipher . doFinal ( data . getBytes ( STRING ) ) ; cipher = Cipher . getInstance ( encKey . getAlgorithm ( ) ) ; cipher . init ( Cipher . WRAP_MODE , encKey ) ; byte [ ] keyWrap = cipher . wrap ( sKey ) ; byte [ ] encDataPad = wrapKeyWithEncryptedData ( encData , keyWrap ) ; return Base64 . encode ( encDataPad ) ; } catch ( NoSuchAlgorithmException nse ) { throw new Exception ( nse . getMessage ( ) ) ; } catch ( NoSuchPaddingException npe ) { throw new Exception ( npe . getMessage ( ) ) ; } catch ( InvalidKeyException ike ) { throw new Exception ( ike . getMessage ( ) ) ; } catch ( UnsupportedEncodingException uae ) { throw new Exception ( uae . getMessage ( ) ) ; } }
public static String encryptWithAsymmetricKey ( String data , String encryptionAlgorithm , int encryptionStrength , Key encKey ) throws Exception { try { KeyGenerator keygen = KeyGenerator . getInstance ( encryptionAlgorithm ) ; if ( encryptionStrength != _NUM ) { keygen . init ( encryptionStrength ) ; } SecretKey sKey = keygen . generateKey ( ) ; Cipher cipher = Cipher . getInstance ( encryptionAlgorithm ) ; cipher . init ( Cipher . ENCRYPT_MODE , sKey ) ; byte [ ] encData = cipher . doFinal ( data . getBytes ( STRING ) ) ; cipher = Cipher . getInstance ( encKey . getAlgorithm ( ) ) ; cipher . init ( Cipher . WRAP_MODE , encKey ) ; byte [ ] keyWrap = cipher . wrap ( sKey ) ; byte [ ] encDataPad = wrapKeyWithEncryptedData ( encData , keyWrap ) ; return Base64 . encode ( encDataPad ) ; } catch ( NoSuchAlgorithmException nse ) { throw new Exception ( nse . getMessage ( ) ) ; } catch ( NoSuchPaddingException npe ) { throw new Exception ( npe . getMessage ( ) ) ; } catch ( InvalidKeyException ike ) { throw new Exception ( ike . getMessage ( ) ) ; } catch ( UnsupportedEncodingException uae ) { throw new Exception ( uae . getMessage ( ) ) ; } }
public static String encryptWithAsymmetricKey ( String data , String encryptionAlgorithm , int encryptionStrength , Key encKey ) throws Exception { try { KeyGenerator keygen = KeyGenerator . getInstance ( encryptionAlgorithm ) ; if ( encryptionStrength != _NUM ) { keygen . init ( encryptionStrength ) ; } SecretKey sKey = keygen . generateKey ( ) ; Cipher cipher = Cipher . getInstance ( encryptionAlgorithm ) ; cipher . init ( Cipher . ENCRYPT_MODE , sKey ) ; byte [ ] encData = cipher . doFinal ( data . getBytes ( STRING ) ) ; cipher = Cipher . getInstance ( encKey . getAlgorithm ( ) ) ; cipher . init ( Cipher . WRAP_MODE , encKey ) ; byte [ ] keyWrap = cipher . wrap ( sKey ) ; byte [ ] encDataPad = wrapKeyWithEncryptedData ( encData , keyWrap ) ; return Base64 . encode ( encDataPad ) ; } catch ( NoSuchAlgorithmException nse ) { throw new Exception ( nse . getMessage ( ) ) ; } catch ( NoSuchPaddingException npe ) { throw new Exception ( npe . getMessage ( ) ) ; } catch ( InvalidKeyException ike ) { throw new Exception ( ike . getMessage ( ) ) ; } catch ( UnsupportedEncodingException uae ) { throw new Exception ( uae . getMessage ( ) ) ; } }
public static String encryptWithAsymmetricKey ( String data , String encryptionAlgorithm , int encryptionStrength , Key encKey ) throws Exception { try { KeyGenerator keygen = KeyGenerator . getInstance ( encryptionAlgorithm ) ; if ( encryptionStrength != _NUM ) { keygen . init ( encryptionStrength ) ; } SecretKey sKey = keygen . generateKey ( ) ; Cipher cipher = Cipher . getInstance ( encryptionAlgorithm ) ; cipher . init ( Cipher . ENCRYPT_MODE , sKey ) ; byte [ ] encData = cipher . doFinal ( data . getBytes ( STRING ) ) ; cipher = Cipher . getInstance ( encKey . getAlgorithm ( ) ) ; cipher . init ( Cipher . WRAP_MODE , encKey ) ; byte [ ] keyWrap = cipher . wrap ( sKey ) ; byte [ ] encDataPad = wrapKeyWithEncryptedData ( encData , keyWrap ) ; return Base64 . encode ( encDataPad ) ; } catch ( NoSuchAlgorithmException nse ) { throw new Exception ( nse . getMessage ( ) ) ; } catch ( NoSuchPaddingException npe ) { throw new Exception ( npe . getMessage ( ) ) ; } catch ( InvalidKeyException ike ) { throw new Exception ( ike . getMessage ( ) ) ; } catch ( UnsupportedEncodingException uae ) { throw new Exception ( uae . getMessage ( ) ) ; } }
private void initPanel ( ) { if ( effectorType . getSelectedItem ( ) == STRING ) { cleareffectorPanel ( ) ; setTitle ( STRING ) ; currentEffectorPanel = new StraightEffectorPanel ( rotatingEntity ) ; mainPanel . add ( currentEffectorPanel ) ; } else if ( effectorType . getSelectedItem ( ) == STRING ) { cleareffectorPanel ( ) ; setTitle ( STRING ) ; currentEffectorPanel = new TurningEffectorPanel ( rotatingEntity ) ; mainPanel . add ( currentEffectorPanel ) ; } else if ( effectorType . getSelectedItem ( ) == STRING ) { cleareffectorPanel ( ) ; setTitle ( STRING ) ; currentEffectorPanel = new SpeechEffectorPanel ( rotatingEntity ) ; mainPanel . add ( currentEffectorPanel ) ; } pack ( ) ; setLocationRelativeTo ( null ) ; }
private void initPanel ( ) { if ( effectorType . getSelectedItem ( ) == STRING ) { cleareffectorPanel ( ) ; setTitle ( STRING ) ; currentEffectorPanel = new StraightEffectorPanel ( rotatingEntity ) ; mainPanel . add ( currentEffectorPanel ) ; } else if ( effectorType . getSelectedItem ( ) == STRING ) { cleareffectorPanel ( ) ; setTitle ( STRING ) ; currentEffectorPanel = new TurningEffectorPanel ( rotatingEntity ) ; mainPanel . add ( currentEffectorPanel ) ; } else if ( effectorType . getSelectedItem ( ) == STRING ) { cleareffectorPanel ( ) ; setTitle ( STRING ) ; currentEffectorPanel = new SpeechEffectorPanel ( rotatingEntity ) ; mainPanel . add ( currentEffectorPanel ) ; } pack ( ) ; setLocationRelativeTo ( null ) ; }
static public String randomPositiveWhole ( int length ) { if ( length == _NUM ) { return STRING ; } StringBuilder output = new StringBuilder ( length ) ; output . append ( rnd . nextInt ( _NUM ) + _NUM ) ; for ( int i = _NUM ; i < length - _NUM ; i ++ ) { output . append ( rnd . nextInt ( _NUM ) ) ; } return output . toString ( ) ; }
public VNXeCommandResult addLunsToConsistencyGroup ( String cgId , List < String > luns ) { LunGroupModifyParam param = new LunGroupModifyParam ( ) ; List < LunAddParam > lunAdds = new ArrayList < LunAddParam > ( ) ; for ( String lunId : luns ) { VNXeBase lun = new VNXeBase ( lunId ) ; LunAddParam lunAdd = new LunAddParam ( ) ; lunAdd . setLun ( lun ) ; lunAdds . add ( lunAdd ) ; } param . setLunAdd ( lunAdds ) ; ConsistencyGroupRequests req = new ConsistencyGroupRequests ( _khClient ) ; return req . modifyConsistencyGroupSync ( cgId , param ) ; }
public void addState ( int [ ] specs , Animator animation , Animator . AnimatorListener listener ) { Tuple tuple = new Tuple ( specs , animation , listener ) ; animation . addListener ( mAnimationListener ) ; mTuples . add ( tuple ) ; }
public void addState ( int [ ] specs , Animator animation , Animator . AnimatorListener listener ) { Tuple tuple = new Tuple ( specs , animation , listener ) ; animation . addListener ( mAnimationListener ) ; mTuples . add ( tuple ) ; }
public void addState ( int [ ] specs , Animator animation , Animator . AnimatorListener listener ) { Tuple tuple = new Tuple ( specs , animation , listener ) ; animation . addListener ( mAnimationListener ) ; mTuples . add ( tuple ) ; }
void update ( long timeNanos , int rows ) { count ++ ; executionTimeMinNanos = Math . min ( timeNanos , executionTimeMinNanos ) ; executionTimeMaxNanos = Math . max ( timeNanos , executionTimeMaxNanos ) ; rowCountMin = Math . min ( rows , rowCountMin ) ; rowCountMax = Math . max ( rows , rowCountMax ) ; double rowDelta = rows - rowCountMean ; rowCountMean += rowDelta / count ; rowCountM2 += rowDelta * ( rows - rowCountMean ) ; double timeDelta = timeNanos - executionTimeMeanNanos ; executionTimeMeanNanos += timeDelta / count ; executionTimeM2Nanos += timeDelta * ( timeNanos - executionTimeMeanNanos ) ; executionTimeCumulativeNanos += timeNanos ; rowCountCumulative += rows ; lastUpdateTime = System . currentTimeMillis ( ) ; }
public List < SourceRecord > ddlRecordsForDatabase ( String dbName ) { return ddlRecordsByDbName . get ( dbName ) ; }
public String makeLiteralSQ ( Object object ) { StringBuilder sb = new StringBuilder ( ) ; makeLiteral ( sb , object , _BOOL ) ; return sb . toString ( ) ; }
public static void startupDelay ( ) { sleep ( _NUM ) ; }
private static boolean dateByOrdinal ( DateTimeFormatterBuilder bld , Collection < DateTimeFieldType > fields , boolean extended , boolean strictISO ) { boolean reducedPrec = _BOOL ; if ( fields . remove ( DateTimeFieldType . year ( ) ) ) { bld . append ( yearElement ( ) ) ; if ( fields . remove ( DateTimeFieldType . dayOfYear ( ) ) ) { appendSeparator ( bld , extended ) ; bld . appendDayOfYear ( _NUM ) ; } else { reducedPrec = _BOOL ; } } else if ( fields . remove ( DateTimeFieldType . dayOfYear ( ) ) ) { bld . appendLiteral ( STRING ) ; bld . appendDayOfYear ( _NUM ) ; } return reducedPrec ; }
private static boolean dateByOrdinal ( DateTimeFormatterBuilder bld , Collection < DateTimeFieldType > fields , boolean extended , boolean strictISO ) { boolean reducedPrec = _BOOL ; if ( fields . remove ( DateTimeFieldType . year ( ) ) ) { bld . append ( yearElement ( ) ) ; if ( fields . remove ( DateTimeFieldType . dayOfYear ( ) ) ) { appendSeparator ( bld , extended ) ; bld . appendDayOfYear ( _NUM ) ; } else { reducedPrec = _BOOL ; } } else if ( fields . remove ( DateTimeFieldType . dayOfYear ( ) ) ) { bld . appendLiteral ( STRING ) ; bld . appendDayOfYear ( _NUM ) ; } return reducedPrec ; }
private static boolean dateByOrdinal ( DateTimeFormatterBuilder bld , Collection < DateTimeFieldType > fields , boolean extended , boolean strictISO ) { boolean reducedPrec = _BOOL ; if ( fields . remove ( DateTimeFieldType . year ( ) ) ) { bld . append ( yearElement ( ) ) ; if ( fields . remove ( DateTimeFieldType . dayOfYear ( ) ) ) { appendSeparator ( bld , extended ) ; bld . appendDayOfYear ( _NUM ) ; } else { reducedPrec = _BOOL ; } } else if ( fields . remove ( DateTimeFieldType . dayOfYear ( ) ) ) { bld . appendLiteral ( STRING ) ; bld . appendDayOfYear ( _NUM ) ; } return reducedPrec ; }
public static Collection < ContentStream > toContentStreams ( final String str , final String contentType ) { if ( str == null ) return null ; ArrayList < ContentStream > streams = new ArrayList < > ( _NUM ) ; ContentStreamBase ccc = new ContentStreamBase . StringStream ( str ) ; ccc . setContentType ( contentType ) ; streams . add ( ccc ) ; return streams ; }
public static Collection < ContentStream > toContentStreams ( final String str , final String contentType ) { if ( str == null ) return null ; ArrayList < ContentStream > streams = new ArrayList < > ( _NUM ) ; ContentStreamBase ccc = new ContentStreamBase . StringStream ( str ) ; ccc . setContentType ( contentType ) ; streams . add ( ccc ) ; return streams ; }
public void flush ( ) throws IOException { WspUtil . writeUint8 ( os_ , _NUM ) ; writePublicIdentifier ( os_ , publicID_ ) ; WspUtil . writeUintvar ( os_ , WapConstants . MIB_ENUM_UTF_8 ) ; writeStringTable ( os_ ) ; wbxmlBody_ . close ( ) ; wbxmlBody_ . writeTo ( os_ ) ; os_ . flush ( ) ; }
public static XPath2FilterContainer04 newInstanceIntersect ( Document doc , String xpath2filter ) { return new XPath2FilterContainer04 ( doc , xpath2filter , XPath2FilterContainer04 . _ATT_FILTER_VALUE_INTERSECT ) ; }
public static XPath2FilterContainer04 newInstanceIntersect ( Document doc , String xpath2filter ) { return new XPath2FilterContainer04 ( doc , xpath2filter , XPath2FilterContainer04 . _ATT_FILTER_VALUE_INTERSECT ) ; }
public void releaseProxyMouseMode ( ) { MapMouseMode pmmm = getProxyMouseMode ( ) ; OMDrawingTool dt = getDrawingTool ( ) ; if ( pmmm != null && dt != null ) { if ( pmmm . isProxyFor ( dt . getMouseMode ( ) ) ) { if ( DTL_DEBUG ) { Debug . output ( STRING + pmmm . getID ( ) ) ; } pmmm . releaseProxy ( ) ; setProxyMouseMode ( null ) ; fireRequestInfoLine ( STRING ) ; } if ( dt . isActivated ( ) ) { dt . deactivate ( ) ; } } }
public void releaseProxyMouseMode ( ) { MapMouseMode pmmm = getProxyMouseMode ( ) ; OMDrawingTool dt = getDrawingTool ( ) ; if ( pmmm != null && dt != null ) { if ( pmmm . isProxyFor ( dt . getMouseMode ( ) ) ) { if ( DTL_DEBUG ) { Debug . output ( STRING + pmmm . getID ( ) ) ; } pmmm . releaseProxy ( ) ; setProxyMouseMode ( null ) ; fireRequestInfoLine ( STRING ) ; } if ( dt . isActivated ( ) ) { dt . deactivate ( ) ; } } }
@ SuppressWarnings ( STRING ) public static < ValueT > ValueT toObject ( ByteBuffer bf ) throws IOException , ClassNotFoundException { Object obj = null ; InputStream is = null ; ObjectInputStream ois = null ; try { is = new ByteBufferBackedInputStream ( bf ) ; ois = new ObjectInputStream ( is ) ; obj = ois . readObject ( ) ; } finally { if ( is != null ) { is . close ( ) ; } if ( ois != null ) { ois . close ( ) ; } } return ( ValueT ) obj ; }
@ SuppressWarnings ( STRING ) public static < ValueT > ValueT toObject ( ByteBuffer bf ) throws IOException , ClassNotFoundException { Object obj = null ; InputStream is = null ; ObjectInputStream ois = null ; try { is = new ByteBufferBackedInputStream ( bf ) ; ois = new ObjectInputStream ( is ) ; obj = ois . readObject ( ) ; } finally { if ( is != null ) { is . close ( ) ; } if ( ois != null ) { ois . close ( ) ; } } return ( ValueT ) obj ; }
public Boolean consumeBooleanConstantAttribute ( String name ) throws UnableToCompleteException { String value = consumeRawAttribute ( name ) ; if ( value == null ) { return null ; } if ( value . equals ( STRING ) || value . equals ( STRING ) ) { return Boolean . valueOf ( value ) ; } logger . die ( this , STRING , name ) ; return null ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = enumToVector ( super . listOptions ( ) ) ; result . addElement ( new Option ( STRING + defaultNumAttributes ( ) + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = enumToVector ( super . listOptions ( ) ) ; result . addElement ( new Option ( STRING + defaultNumAttributes ( ) + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; return result . elements ( ) ; }
public void evaluateRotationAngle ( Projection proj ) { renderRotationAngle = null ; double projRotation = proj . getRotationAngle ( ) ; Object noRotationAtt = getAttribute ( OMGraphicConstants . NO_ROTATE ) ; boolean compensateForProjRot = noRotationAtt != null && ! noRotationAtt . equals ( Boolean . FALSE ) ; if ( compensateForProjRot ) { renderRotationAngle = rotationAngle - projRotation ; } else if ( rotationAngle != DEFAULT_ROTATIONANGLE ) { renderRotationAngle = rotationAngle ; } }
public void evaluateRotationAngle ( Projection proj ) { renderRotationAngle = null ; double projRotation = proj . getRotationAngle ( ) ; Object noRotationAtt = getAttribute ( OMGraphicConstants . NO_ROTATE ) ; boolean compensateForProjRot = noRotationAtt != null && ! noRotationAtt . equals ( Boolean . FALSE ) ; if ( compensateForProjRot ) { renderRotationAngle = rotationAngle - projRotation ; } else if ( rotationAngle != DEFAULT_ROTATIONANGLE ) { renderRotationAngle = rotationAngle ; } }
public boolean refreshNeeded ( ) { return this . softTtl < System . currentTimeMillis ( ) ; }
public boolean refreshNeeded ( ) { return this . softTtl < System . currentTimeMillis ( ) ; }
@ Override public Range findRangeBounds ( XYDataset dataset ) { ParamChecks . nullNotPermitted ( dataset , STRING ) ; double minimum = Double . POSITIVE_INFINITY ; double maximum = Double . NEGATIVE_INFINITY ; int seriesCount = dataset . getSeriesCount ( ) ; double lvalue ; double uvalue ; if ( dataset instanceof VectorXYDataset ) { VectorXYDataset vdataset = ( VectorXYDataset ) dataset ; for ( int series = _NUM ; series < seriesCount ; series ++ ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = _NUM ; item < itemCount ; item ++ ) { double delta = vdataset . getVectorYValue ( series , item ) ; if ( delta < _NUM ) { uvalue = vdataset . getYValue ( series , item ) ; lvalue = uvalue + delta ; } else { lvalue = vdataset . getYValue ( series , item ) ; uvalue = lvalue + delta ; } minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } else { for ( int series = _NUM ; series < seriesCount ; series ++ ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = _NUM ; item < itemCount ; item ++ ) { lvalue = dataset . getYValue ( series , item ) ; uvalue = lvalue ; minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } if ( minimum > maximum ) { return null ; } else { return new Range ( minimum , maximum ) ; } }
@ Override public Range findRangeBounds ( XYDataset dataset ) { ParamChecks . nullNotPermitted ( dataset , STRING ) ; double minimum = Double . POSITIVE_INFINITY ; double maximum = Double . NEGATIVE_INFINITY ; int seriesCount = dataset . getSeriesCount ( ) ; double lvalue ; double uvalue ; if ( dataset instanceof VectorXYDataset ) { VectorXYDataset vdataset = ( VectorXYDataset ) dataset ; for ( int series = _NUM ; series < seriesCount ; series ++ ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = _NUM ; item < itemCount ; item ++ ) { double delta = vdataset . getVectorYValue ( series , item ) ; if ( delta < _NUM ) { uvalue = vdataset . getYValue ( series , item ) ; lvalue = uvalue + delta ; } else { lvalue = vdataset . getYValue ( series , item ) ; uvalue = lvalue + delta ; } minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } else { for ( int series = _NUM ; series < seriesCount ; series ++ ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = _NUM ; item < itemCount ; item ++ ) { lvalue = dataset . getYValue ( series , item ) ; uvalue = lvalue ; minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } if ( minimum > maximum ) { return null ; } else { return new Range ( minimum , maximum ) ; } }
@ Override public Range findRangeBounds ( XYDataset dataset ) { ParamChecks . nullNotPermitted ( dataset , STRING ) ; double minimum = Double . POSITIVE_INFINITY ; double maximum = Double . NEGATIVE_INFINITY ; int seriesCount = dataset . getSeriesCount ( ) ; double lvalue ; double uvalue ; if ( dataset instanceof VectorXYDataset ) { VectorXYDataset vdataset = ( VectorXYDataset ) dataset ; for ( int series = _NUM ; series < seriesCount ; series ++ ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = _NUM ; item < itemCount ; item ++ ) { double delta = vdataset . getVectorYValue ( series , item ) ; if ( delta < _NUM ) { uvalue = vdataset . getYValue ( series , item ) ; lvalue = uvalue + delta ; } else { lvalue = vdataset . getYValue ( series , item ) ; uvalue = lvalue + delta ; } minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } else { for ( int series = _NUM ; series < seriesCount ; series ++ ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = _NUM ; item < itemCount ; item ++ ) { lvalue = dataset . getYValue ( series , item ) ; uvalue = lvalue ; minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } if ( minimum > maximum ) { return null ; } else { return new Range ( minimum , maximum ) ; } }
protected void openButton ( ) { if ( locoBox . getSelectedRosterEntries ( ) . length != _NUM ) { openKnownLoco ( ) ; } else if ( isDecoderSelected ( ) ) { openNewLoco ( ) ; } else { log . error ( STRING ) ; } }
protected void openButton ( ) { if ( locoBox . getSelectedRosterEntries ( ) . length != _NUM ) { openKnownLoco ( ) ; } else if ( isDecoderSelected ( ) ) { openNewLoco ( ) ; } else { log . error ( STRING ) ; } }
public void addTargetedBySwarm ( int entityId , int weaponId ) { hitBySwarmsEntity . addElement ( new Integer ( entityId ) ) ; hitBySwarmsWeapon . addElement ( new Integer ( weaponId ) ) ; }
public void addNativeChildAt ( ReactShadowNode child , int nativeIndex ) { Assertions . assertCondition ( ! mIsLayoutOnly ) ; Assertions . assertCondition ( ! child . mIsLayoutOnly ) ; if ( mNativeChildren == null ) { mNativeChildren = new ArrayList < > ( _NUM ) ; } mNativeChildren . add ( nativeIndex , child ) ; child . mNativeParent = this ; }
public void addNativeChildAt ( ReactShadowNode child , int nativeIndex ) { Assertions . assertCondition ( ! mIsLayoutOnly ) ; Assertions . assertCondition ( ! child . mIsLayoutOnly ) ; if ( mNativeChildren == null ) { mNativeChildren = new ArrayList < > ( _NUM ) ; } mNativeChildren . add ( nativeIndex , child ) ; child . mNativeParent = this ; }
public void addNativeChildAt ( ReactShadowNode child , int nativeIndex ) { Assertions . assertCondition ( ! mIsLayoutOnly ) ; Assertions . assertCondition ( ! child . mIsLayoutOnly ) ; if ( mNativeChildren == null ) { mNativeChildren = new ArrayList < > ( _NUM ) ; } mNativeChildren . add ( nativeIndex , child ) ; child . mNativeParent = this ; }
private void readDownloadApps ( XmlPullParser parser , Set < DownloadAppInfo > apps ) throws XmlPullParserException , IOException { while ( parser . next ( ) != XmlPullParser . END_TAG ) { if ( parser . getEventType ( ) != XmlPullParser . START_TAG ) { continue ; } String name = parser . getName ( ) ; if ( TAG_APP . equals ( name ) ) { String packageName = parser . getAttributeValue ( null , ATTRIBUTE_PACKAGE_NAME ) ; String downloadLocation = parser . getAttributeValue ( null , ATTRIBUTE_DOWNLOAD_LOCATION ) ; if ( packageName != null && downloadLocation != null ) { apps . add ( new DownloadAppInfo ( packageName , downloadLocation ) ) ; } skipCurrentTag ( parser ) ; } } }
public static void reindex ( Connection conn ) throws SQLException { init ( conn ) ; removeAllTriggers ( conn , TRIGGER_PREFIX ) ; removeIndexFiles ( conn ) ; Statement stat = conn . createStatement ( ) ; ResultSet rs = stat . executeQuery ( STRING + SCHEMA + STRING ) ; while ( rs . next ( ) ) { String schema = rs . getString ( STRING ) ; String table = rs . getString ( STRING ) ; createTrigger ( conn , schema , table ) ; indexExistingRows ( conn , schema , table ) ; } }
public static void reindex ( Connection conn ) throws SQLException { init ( conn ) ; removeAllTriggers ( conn , TRIGGER_PREFIX ) ; removeIndexFiles ( conn ) ; Statement stat = conn . createStatement ( ) ; ResultSet rs = stat . executeQuery ( STRING + SCHEMA + STRING ) ; while ( rs . next ( ) ) { String schema = rs . getString ( STRING ) ; String table = rs . getString ( STRING ) ; createTrigger ( conn , schema , table ) ; indexExistingRows ( conn , schema , table ) ; } }
private ArrayDBIDs computeM_current ( DBIDs m , DBIDs m_best , DBIDs m_bad , Random random ) { ArrayModifiableDBIDs m_list = DBIDUtil . newArray ( m ) ; m_list . removeDBIDs ( m_best ) ; DBIDArrayMIter it = m_list . iter ( ) ; ArrayModifiableDBIDs m_current = DBIDUtil . newArray ( ) ; for ( DBIDIter iter = m_best . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { if ( m_bad . contains ( iter ) ) { int currentSize = m_current . size ( ) ; while ( m_current . size ( ) == currentSize ) { m_current . add ( it . seek ( random . nextInt ( m_list . size ( ) ) ) ) ; it . remove ( ) ; } } else { m_current . add ( iter ) ; } } return m_current ; }
private List < Integer > convertToList ( int [ ] data ) { Integer [ ] wrapperType = ArrayUtils . toObject ( data ) ; return Arrays . asList ( wrapperType ) ; }
private List < Integer > convertToList ( int [ ] data ) { Integer [ ] wrapperType = ArrayUtils . toObject ( data ) ; return Arrays . asList ( wrapperType ) ; }
public void addListener ( IFrequencyChangeProcessor processor ) { if ( ! mProcessors . contains ( processor ) ) { mProcessors . add ( processor ) ; } }
public void addListener ( IFrequencyChangeProcessor processor ) { if ( ! mProcessors . contains ( processor ) ) { mProcessors . add ( processor ) ; } }
public void addListener ( IFrequencyChangeProcessor processor ) { if ( ! mProcessors . contains ( processor ) ) { mProcessors . add ( processor ) ; } }
public void waitForCurrentOperations ( long timeout ) { long startTime = System . currentTimeMillis ( ) ; long warnTime = startTime + timeout ; long quitTime = warnTime + timeout - _NUM ; boolean warned = _BOOL ; final boolean isDebugEnabled_STATE_FLUSH_OP = logger . isTraceEnabled ( LogMarker . STATE_FLUSH_OP ) ; while ( _BOOL ) { long opCount ; synchronized ( this . opCountLock ) { opCount = this . previousVersionOpCount ; } if ( opCount <= _NUM ) { break ; } if ( isDebugEnabled_STATE_FLUSH_OP ) { logger . trace ( LogMarker . STATE_FLUSH_OP , STRING , opCount ) ; } try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException e ) { throw new GemFireIOException ( STRING ) ; } long now = System . currentTimeMillis ( ) ; if ( ( ! warned ) && System . currentTimeMillis ( ) >= warnTime ) { warned = _BOOL ; logger . warn ( LocalizedMessage . create ( LocalizedStrings . DistributionAdvisor_0_SEC_HAVE_ELAPSED_WHILE_WAITING_FOR_CURRENT_OPERATIONS_TO_DISTRIBUTE , Long . toString ( ( warnTime - startTime ) / _NUM ) ) ) ; } else if ( warned && ( now >= quitTime ) ) { throw new GemFireIOException ( STRING + ( now - startTime ) + STRING ) ; } } if ( this . membershipClosed ) { if ( isDebugEnabled_STATE_FLUSH_OP ) { logger . trace ( LogMarker . STATE_FLUSH_OP , STRING ) ; } } }
private static String doGetFullPath ( String filename , boolean includeSeparator ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < _NUM ) { return null ; } if ( prefix >= filename . length ( ) ) { if ( includeSeparator ) { return getPrefix ( filename ) ; } else { return filename ; } } int index = indexOfLastSeparator ( filename ) ; if ( index < _NUM ) { return filename . substring ( _NUM , prefix ) ; } int end = index + ( includeSeparator ? _NUM : _NUM ) ; if ( end == _NUM ) { end ++ ; } return filename . substring ( _NUM , end ) ; }
public static AMIdentity createATestUser ( SSOToken adminToken , String username , String realm ) throws IdRepoException , SSOException { AMIdentityRepository amir = new AMIdentityRepository ( adminToken , realm ) ; Map < String , Set < String > > attrValues = new HashMap < String , Set < String > > ( ) ; Set < String > set = new HashSet < String > ( ) ; set . add ( username ) ; attrValues . put ( STRING , set ) ; attrValues . put ( STRING , set ) ; attrValues . put ( STRING , set ) ; attrValues . put ( STRING , set ) ; return amir . createIdentity ( IdType . USER , username , attrValues ) ; }
public static AMIdentity createATestUser ( SSOToken adminToken , String username , String realm ) throws IdRepoException , SSOException { AMIdentityRepository amir = new AMIdentityRepository ( adminToken , realm ) ; Map < String , Set < String > > attrValues = new HashMap < String , Set < String > > ( ) ; Set < String > set = new HashSet < String > ( ) ; set . add ( username ) ; attrValues . put ( STRING , set ) ; attrValues . put ( STRING , set ) ; attrValues . put ( STRING , set ) ; attrValues . put ( STRING , set ) ; return amir . createIdentity ( IdType . USER , username , attrValues ) ; }
public boolean containsValue ( Object value ) { return contains ( value ) ; }
public boolean containsValue ( Object value ) { return contains ( value ) ; }
public PlayerLevelUpRewards ( final Status status ) { this . status = status ; this . rewards = Collections . emptyList ( ) ; this . unlockedItems = Collections . emptyList ( ) ; }
private Resource packIcon ( int dpi , Bitmap icon ) { Resource res = new Resource ( ) ; res . dpi = dpi ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; if ( icon . compress ( IMAGE_FORMAT , IMAGE_COMPRESSION_QUALITY , os ) ) { res . data = os . toByteArray ( ) ; } return res ; }
public boolean isFolder ( ) { return mMimeType != null && mMimeType . equals ( STRING ) ; }
public boolean isFolder ( ) { return mMimeType != null && mMimeType . equals ( STRING ) ; }
private void reposition ( int startIndex ) { for ( int j = startIndex ; j < iconManagers . size ( ) ; j ++ ) { AbstractStatusIconManager follower = iconManagers . get ( j ) ; if ( sharesPosition ( follower ) ) { follower . setVisible ( _BOOL ) ; follower . position ( ) ; follower . setVisible ( _BOOL ) ; break ; } } }
public WritableRaster createCompatibleWritableRaster ( int w , int h ) { if ( w <= _NUM || h <= _NUM ) { throw new RasterFormatException ( STRING + ( ( w <= _NUM ) ? STRING : STRING ) ) ; } SampleModel sm = sampleModel . createCompatibleSampleModel ( w , h ) ; return new BytePackedRaster ( sm , new Point ( _NUM , _NUM ) ) ; }
public void removeKeyListener ( GlobalKeyListener listener ) { listeners . remove ( listener ) ; }
@ SuppressWarnings ( STRING ) public void addEntry ( Entry e ) { if ( e == null ) return ; float val = e . getVal ( ) ; if ( mYVals == null ) { mYVals = new ArrayList < T > ( ) ; } if ( mYVals . size ( ) == _NUM ) { mYMax = val ; mYMin = val ; } else { if ( mYMax < val ) mYMax = val ; if ( mYMin > val ) mYMin = val ; } mYValueSum += val ; mYVals . add ( ( T ) e ) ; }
@ SuppressWarnings ( STRING ) public void addEntry ( Entry e ) { if ( e == null ) return ; float val = e . getVal ( ) ; if ( mYVals == null ) { mYVals = new ArrayList < T > ( ) ; } if ( mYVals . size ( ) == _NUM ) { mYMax = val ; mYMin = val ; } else { if ( mYMax < val ) mYMax = val ; if ( mYMin > val ) mYMin = val ; } mYValueSum += val ; mYVals . add ( ( T ) e ) ; }
public static < E extends Enum < E > > EnumSet < E > of ( E e ) { EnumSet < E > result = noneOf ( e . getDeclaringClass ( ) ) ; result . add ( e ) ; return result ; }
public static < E extends Enum < E > > EnumSet < E > of ( E e ) { EnumSet < E > result = noneOf ( e . getDeclaringClass ( ) ) ; result . add ( e ) ; return result ; }
public static < E extends Enum < E > > EnumSet < E > of ( E e ) { EnumSet < E > result = noneOf ( e . getDeclaringClass ( ) ) ; result . add ( e ) ; return result ; }
public static < E extends Enum < E > > EnumSet < E > of ( E e ) { EnumSet < E > result = noneOf ( e . getDeclaringClass ( ) ) ; result . add ( e ) ; return result ; }
public static < E extends Enum < E > > EnumSet < E > of ( E e ) { EnumSet < E > result = noneOf ( e . getDeclaringClass ( ) ) ; result . add ( e ) ; return result ; }
public static < E extends Enum < E > > EnumSet < E > of ( E e ) { EnumSet < E > result = noneOf ( e . getDeclaringClass ( ) ) ; result . add ( e ) ; return result ; }
public static < E extends Enum < E > > EnumSet < E > of ( E e ) { EnumSet < E > result = noneOf ( e . getDeclaringClass ( ) ) ; result . add ( e ) ; return result ; }
public static < E extends Enum < E > > EnumSet < E > of ( E e ) { EnumSet < E > result = noneOf ( e . getDeclaringClass ( ) ) ; result . add ( e ) ; return result ; }
public Object lookup ( FacesContext facesContext , String name ) { Object object = null ; try { InitialContext context = new InitialContext ( ) ; object = context . lookup ( name ) ; } catch ( NamingException ne ) { if ( LOGGER . isLoggable ( Level . WARNING ) ) { LOGGER . log ( Level . WARNING , STRING + name , ne ) ; } if ( facesContext . isProjectStage ( ProjectStage . Development ) ) { facesContext . addMessage ( null , new FacesMessage ( STRING + name , STRING + name ) ) ; } } return object ; }
public Object lookup ( FacesContext facesContext , String name ) { Object object = null ; try { InitialContext context = new InitialContext ( ) ; object = context . lookup ( name ) ; } catch ( NamingException ne ) { if ( LOGGER . isLoggable ( Level . WARNING ) ) { LOGGER . log ( Level . WARNING , STRING + name , ne ) ; } if ( facesContext . isProjectStage ( ProjectStage . Development ) ) { facesContext . addMessage ( null , new FacesMessage ( STRING + name , STRING + name ) ) ; } } return object ; }
private void signalControlOpEnd ( ) { controlOperationExecuting . set ( _BOOL ) ; LockSupport . unpark ( controlWaiters . peek ( ) ) ; if ( controlWaiters . size ( ) == _NUM ) { Thread t = evalWaiters . poll ( ) ; while ( t != null ) { LockSupport . unpark ( t ) ; t = evalWaiters . poll ( ) ; } } }
private void signalControlOpEnd ( ) { controlOperationExecuting . set ( _BOOL ) ; LockSupport . unpark ( controlWaiters . peek ( ) ) ; if ( controlWaiters . size ( ) == _NUM ) { Thread t = evalWaiters . poll ( ) ; while ( t != null ) { LockSupport . unpark ( t ) ; t = evalWaiters . poll ( ) ; } } }
private void signalControlOpEnd ( ) { controlOperationExecuting . set ( _BOOL ) ; LockSupport . unpark ( controlWaiters . peek ( ) ) ; if ( controlWaiters . size ( ) == _NUM ) { Thread t = evalWaiters . poll ( ) ; while ( t != null ) { LockSupport . unpark ( t ) ; t = evalWaiters . poll ( ) ; } } }
private void signalControlOpEnd ( ) { controlOperationExecuting . set ( _BOOL ) ; LockSupport . unpark ( controlWaiters . peek ( ) ) ; if ( controlWaiters . size ( ) == _NUM ) { Thread t = evalWaiters . poll ( ) ; while ( t != null ) { LockSupport . unpark ( t ) ; t = evalWaiters . poll ( ) ; } } }
private void signalControlOpEnd ( ) { controlOperationExecuting . set ( _BOOL ) ; LockSupport . unpark ( controlWaiters . peek ( ) ) ; if ( controlWaiters . size ( ) == _NUM ) { Thread t = evalWaiters . poll ( ) ; while ( t != null ) { LockSupport . unpark ( t ) ; t = evalWaiters . poll ( ) ; } } }
private void signalControlOpEnd ( ) { controlOperationExecuting . set ( _BOOL ) ; LockSupport . unpark ( controlWaiters . peek ( ) ) ; if ( controlWaiters . size ( ) == _NUM ) { Thread t = evalWaiters . poll ( ) ; while ( t != null ) { LockSupport . unpark ( t ) ; t = evalWaiters . poll ( ) ; } } }
private void signalControlOpEnd ( ) { controlOperationExecuting . set ( _BOOL ) ; LockSupport . unpark ( controlWaiters . peek ( ) ) ; if ( controlWaiters . size ( ) == _NUM ) { Thread t = evalWaiters . poll ( ) ; while ( t != null ) { LockSupport . unpark ( t ) ; t = evalWaiters . poll ( ) ; } } }
private void signalControlOpEnd ( ) { controlOperationExecuting . set ( _BOOL ) ; LockSupport . unpark ( controlWaiters . peek ( ) ) ; if ( controlWaiters . size ( ) == _NUM ) { Thread t = evalWaiters . poll ( ) ; while ( t != null ) { LockSupport . unpark ( t ) ; t = evalWaiters . poll ( ) ; } } }
private void signalControlOpEnd ( ) { controlOperationExecuting . set ( _BOOL ) ; LockSupport . unpark ( controlWaiters . peek ( ) ) ; if ( controlWaiters . size ( ) == _NUM ) { Thread t = evalWaiters . poll ( ) ; while ( t != null ) { LockSupport . unpark ( t ) ; t = evalWaiters . poll ( ) ; } } }
private void signalControlOpEnd ( ) { controlOperationExecuting . set ( _BOOL ) ; LockSupport . unpark ( controlWaiters . peek ( ) ) ; if ( controlWaiters . size ( ) == _NUM ) { Thread t = evalWaiters . poll ( ) ; while ( t != null ) { LockSupport . unpark ( t ) ; t = evalWaiters . poll ( ) ; } } }
public static Object [ ] assertThreadIdToSequenceIdMapHasEntryIds ( ) { EventID [ ] evids = new EventID [ _NUM ] ; Map map = pool . getThreadIdToSequenceIdMap ( ) ; assertNotNull ( map ) ; evids [ _NUM ] = putAlleventId1 ; evids [ _NUM ] = putAlleventId2 ; evids [ _NUM ] = putAlleventId3 ; evids [ _NUM ] = putAlleventId4 ; evids [ _NUM ] = putAlleventId5 ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; return evids ; }
public static Object [ ] assertThreadIdToSequenceIdMapHasEntryIds ( ) { EventID [ ] evids = new EventID [ _NUM ] ; Map map = pool . getThreadIdToSequenceIdMap ( ) ; assertNotNull ( map ) ; evids [ _NUM ] = putAlleventId1 ; evids [ _NUM ] = putAlleventId2 ; evids [ _NUM ] = putAlleventId3 ; evids [ _NUM ] = putAlleventId4 ; evids [ _NUM ] = putAlleventId5 ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; return evids ; }
public static Object [ ] assertThreadIdToSequenceIdMapHasEntryIds ( ) { EventID [ ] evids = new EventID [ _NUM ] ; Map map = pool . getThreadIdToSequenceIdMap ( ) ; assertNotNull ( map ) ; evids [ _NUM ] = putAlleventId1 ; evids [ _NUM ] = putAlleventId2 ; evids [ _NUM ] = putAlleventId3 ; evids [ _NUM ] = putAlleventId4 ; evids [ _NUM ] = putAlleventId5 ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; return evids ; }
@ Override public int locations ( ) { return _NUM ; }
public void clear ( ) { selectedTasks . clear ( ) ; fireSelectionChanged ( ) ; }
public static String id ( Object ... ss ) { StringBuilder sb = new StringBuilder ( ) ; for ( Object s : ss ) { if ( sb . length ( ) > _NUM ) sb . append ( STRING ) ; sb . append ( s ) ; } return id ( hash ( sb . toString ( ) ) ) ; }
public KCResponse ( String status , String mimeType , String txt ) { this . status = status ; this . mimeType = mimeType ; try { this . data = new ByteArrayInputStream ( txt . getBytes ( STRING ) ) ; } catch ( java . io . UnsupportedEncodingException uee ) { KCLog . e ( uee ) ; } }
public KCResponse ( String status , String mimeType , String txt ) { this . status = status ; this . mimeType = mimeType ; try { this . data = new ByteArrayInputStream ( txt . getBytes ( STRING ) ) ; } catch ( java . io . UnsupportedEncodingException uee ) { KCLog . e ( uee ) ; } }
public void add ( URI uri , HttpCookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( STRING ) ; } lock . lock ( ) ; try { cookieJar . remove ( cookie ) ; if ( cookie . getMaxAge ( ) != _NUM ) { cookieJar . add ( cookie ) ; if ( cookie . getDomain ( ) != null ) { addIndex ( domainIndex , cookie . getDomain ( ) , cookie ) ; } if ( uri != null ) { addIndex ( uriIndex , getEffectiveURI ( uri ) , cookie ) ; } } } finally { lock . unlock ( ) ; } }
public static byte [ ] writeToArray ( NSObject root ) throws IOException { ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; write ( bout , root ) ; return bout . toByteArray ( ) ; }
public void writeByte ( final byte octet ) { if ( remaining ( ) < _NUM ) { if ( index == blocks . size ( ) - _NUM ) { allocateNewBlock ( ) ; } index ++ ; current = blocks . get ( index ) ; } final Block block = current ; block . data [ block . limit ] = octet ; block . limit ++ ; }
public void removeResultListener ( ResultListener listener ) { listenerList . remove ( listener ) ; }
private static JFreeChart createChart ( ) { XYSeries series1 = new XYSeries ( STRING ) ; series1 . add ( _NUM , _NUM ) ; series1 . add ( _NUM , _NUM ) ; series1 . add ( _NUM , _NUM ) ; XYDataset dataset = new XYSeriesCollection ( series1 ) ; return ChartFactory . createXYStepAreaChart ( STRING , STRING , STRING , dataset ) ; }
public void releaseShared ( ) { shared . unlock ( ) ; }
void show ( ) { if ( mIsVisible ) return ; mIsVisible = _BOOL ; mHeightPx = Math . round ( mDefaultHeightPx ) ; invalidate ( ) ; }
void show ( ) { if ( mIsVisible ) return ; mIsVisible = _BOOL ; mHeightPx = Math . round ( mDefaultHeightPx ) ; invalidate ( ) ; }
void show ( ) { if ( mIsVisible ) return ; mIsVisible = _BOOL ; mHeightPx = Math . round ( mDefaultHeightPx ) ; invalidate ( ) ; }
void show ( ) { if ( mIsVisible ) return ; mIsVisible = _BOOL ; mHeightPx = Math . round ( mDefaultHeightPx ) ; invalidate ( ) ; }
public static void closeQuiet ( @ Nullable SelectionKey rsrc ) { if ( rsrc != null ) closeQuiet ( rsrc . channel ( ) ) ; }
private void sortListLocked ( ) { Collections . sort ( mAlbums , mComparator ) ; }
private byte [ ] windowsAbsolutePath ( ) { ByteArrayOutputStream bstream = new ByteArrayOutputStream ( ) ; bstream . write ( WINDOWS_ROOT_PATH , _NUM , WINDOWS_ROOT_PATH . length - _NUM ) ; StringTokenizer tokenizer = new StringTokenizer ( absolutePath ( ) , STRING ) ; while ( tokenizer . hasMoreTokens ( ) ) { bstream . write ( ( byte ) STRING ) ; String nextName = tokenizer . nextToken ( ) ; byte [ ] windowsNextName = toWindowsName ( nextName ) ; bstream . write ( windowsNextName , _NUM , windowsNextName . length - _NUM ) ; } bstream . write ( _NUM ) ; return bstream . toByteArray ( ) ; }
public static String transformClassName ( String className ) { int lastDot = className . lastIndexOf ( STRING ) ; if ( lastDot >= _NUM ) { String pkg = className . substring ( _NUM , lastDot ) ; if ( ! isUnlikelyToBeRenamed ( pkg ) ) { className = className . substring ( lastDot + _NUM ) ; } } return className ; }
@ Deprecated public void writeXML ( Writer out , String indent , boolean hideDefault ) throws IOException { writeXML ( out , hideDefault ) ; }
public void start ( ) { if ( setState ( EnumSet . of ( TaskState . INITIAL , TaskState . QUEUED ) , TaskState . RUNNING ) ) { DHT . logDebug ( STRING + toString ( ) ) ; startTime = System . currentTimeMillis ( ) ; try { serializedUpdate . run ( ) ; } catch ( Exception e ) { DHT . log ( e , LogLevel . Error ) ; } } }
public int match ( byte [ ] search , int offset , int length ) { int ret = - _NUM ; int searchLength = search . length ; if ( searchLength > _NUM ) { int limit = Math . min ( offset + length , buffer . size ( ) ) - searchLength - offset ; byte byte0 = search [ _NUM ] ; for ( int start = offset ; start <= limit ; ++ start ) { if ( buffer . getByte ( start ) == byte0 ) { int i = _NUM ; for ( ; i < searchLength ; ++ i ) { if ( search [ i ] != buffer . getByte ( start + i ) ) { break ; } } if ( i == searchLength ) { ret = start ; break ; } } } } return ret ; }
protected void add ( Instance inst ) { for ( int i = _NUM ; i < m_Specifiers . size ( ) ; i ++ ) { Instance specifier = m_Specifiers . get ( i ) ; boolean found = _BOOL ; for ( int m_DatasetKeyColumn : m_DatasetKeyColumns ) { if ( inst . value ( m_DatasetKeyColumn ) != specifier . value ( m_DatasetKeyColumn ) ) { found = _BOOL ; } } if ( found ) { return ; } } m_Specifiers . add ( inst ) ; }
public boolean drawImage ( Image img , AffineTransform xform , ImageObserver obs ) { if ( img == null ) { return _BOOL ; } boolean result ; int srcWidth = img . getWidth ( null ) ; int srcHeight = img . getHeight ( null ) ; if ( srcWidth < _NUM || srcHeight < _NUM ) { result = _BOOL ; } else { result = drawImageToPlatform ( img , xform , null , _NUM , _NUM , srcWidth , srcHeight , _BOOL ) ; } return result ; }
public boolean drawImage ( Image img , AffineTransform xform , ImageObserver obs ) { if ( img == null ) { return _BOOL ; } boolean result ; int srcWidth = img . getWidth ( null ) ; int srcHeight = img . getHeight ( null ) ; if ( srcWidth < _NUM || srcHeight < _NUM ) { result = _BOOL ; } else { result = drawImageToPlatform ( img , xform , null , _NUM , _NUM , srcWidth , srcHeight , _BOOL ) ; } return result ; }
public boolean drawImage ( Image img , AffineTransform xform , ImageObserver obs ) { if ( img == null ) { return _BOOL ; } boolean result ; int srcWidth = img . getWidth ( null ) ; int srcHeight = img . getHeight ( null ) ; if ( srcWidth < _NUM || srcHeight < _NUM ) { result = _BOOL ; } else { result = drawImageToPlatform ( img , xform , null , _NUM , _NUM , srcWidth , srcHeight , _BOOL ) ; } return result ; }
public static boolean isControlOrMetaDown ( MouseEvent e ) { if ( ! IS_MAC ) { return e . isControlDown ( ) ; } else { return e . isMetaDown ( ) ; } }
public static boolean isControlOrMetaDown ( MouseEvent e ) { if ( ! IS_MAC ) { return e . isControlDown ( ) ; } else { return e . isMetaDown ( ) ; } }
public void certificateCreated ( long startTimeMs , long finishTimeMs ) { certificatesGenerated . incrementAndGet ( ) ; certificateGenerationTimeMs . addAndGet ( finishTimeMs - startTimeMs ) ; firstCertificateGeneratedTimestamp . compareAndSet ( _NUM , System . currentTimeMillis ( ) ) ; }
public void certificateCreated ( long startTimeMs , long finishTimeMs ) { certificatesGenerated . incrementAndGet ( ) ; certificateGenerationTimeMs . addAndGet ( finishTimeMs - startTimeMs ) ; firstCertificateGeneratedTimestamp . compareAndSet ( _NUM , System . currentTimeMillis ( ) ) ; }
private String globToRegex ( String glob ) { if ( glob . charAt ( _NUM ) == STRING || glob . contains ( STRING ) || glob . contains ( STRING ) ) { throw new IllegalArgumentException ( STRING ) ; } glob = glob . replace ( STRING , STRING ) ; glob = glob . replace ( STRING , STRING ) ; glob = glob . replace ( STRING , STRING ) ; return glob ; }
private void updateBoundsForAddedItem ( TimeSeriesDataItem item ) { Number yN = item . getValue ( ) ; if ( item . getValue ( ) != null ) { double y = yN . doubleValue ( ) ; this . minY = minIgnoreNaN ( this . minY , y ) ; this . maxY = maxIgnoreNaN ( this . maxY , y ) ; } }
public static void encode ( Appendable out , int value ) throws IOException { value = toVLQSigned ( value ) ; do { int digit = value & VLQ_BASE_MASK ; value >>>= VLQ_BASE_SHIFT ; if ( value > _NUM ) { digit |= VLQ_CONTINUATION_BIT ; } out . append ( Base64 . toBase64 ( digit ) ) ; } while ( value > _NUM ) ; }
public boolean removeMessage ( String message ) { SQLiteDatabase db = getWritableDatabase ( ) ; if ( db != null && message != null ) { db . execSQL ( STRING + TABLE + STRING + COL_DELETED + STRING + TRUE + STRING + COL_MESSAGE + STRING + message + STRING ) ; return _BOOL ; } log . debug ( STRING + message + STRING ) ; return _BOOL ; }
public static String computeSimpsonReciprocal ( ViewerBase viewer , ProgressListener progressListener ) throws IOException , CanceledException { if ( viewer instanceof MainViewer ) return toString ( computeSimpsonReciprocal ( ( MainViewer ) viewer , progressListener ) ) ; else if ( viewer instanceof ClassificationViewer ) return toString ( computeSimpsonReciprocal ( ( ClassificationViewer ) viewer , progressListener ) ) ; else return null ; }
public static String computeSimpsonReciprocal ( ViewerBase viewer , ProgressListener progressListener ) throws IOException , CanceledException { if ( viewer instanceof MainViewer ) return toString ( computeSimpsonReciprocal ( ( MainViewer ) viewer , progressListener ) ) ; else if ( viewer instanceof ClassificationViewer ) return toString ( computeSimpsonReciprocal ( ( ClassificationViewer ) viewer , progressListener ) ) ; else return null ; }
public void read ( DataInputStream in ) throws IOException { if ( in . readInt ( ) != FILE_VERSION ) { } String [ ] names = new String [ in . readShort ( ) ] ; for ( int i = _NUM ; i < names . length ; i ++ ) { names [ i ] = in . readUTF ( ) ; } int num = in . readShort ( ) ; for ( int i = _NUM ; i < num ; i ++ ) { short nameId = in . readShort ( ) ; int type = in . readByte ( ) ; String name = in . readUTF ( ) ; defEntity ( names [ nameId ] , type | GENERAL , name ) ; } num = in . readShort ( ) ; for ( int i = _NUM ; i < num ; i ++ ) { short nameId = in . readShort ( ) ; int type = in . readByte ( ) ; byte flags = in . readByte ( ) ; ContentModel m = readContentModel ( in , names ) ; String [ ] exclusions = readNameArray ( in , names ) ; String [ ] inclusions = readNameArray ( in , names ) ; AttributeList atts = readAttributeList ( in , names ) ; defElement ( names [ nameId ] , type , ( ( flags & _NUM ) != _NUM ) , ( ( flags & _NUM ) != _NUM ) , m , exclusions , inclusions , atts ) ; } }
default < T > void forEachMatchingFieldNameWithInteger ( String regex , int groupNumber , BiConsumer < String , Integer > function ) { forEachMatchingFieldNameWithInteger ( Pattern . compile ( regex ) , groupNumber , function ) ; }
protected AbstractRegionPainter ( ) { focusInsets = UIManager . getInsets ( STRING ) ; }
public boolean isMine ( Wallet wallet ) { try { Script script = getScriptPubKey ( ) ; if ( script . isSentToRawPubKey ( ) ) { byte [ ] pubkey = script . getPubKey ( ) ; return wallet . isPubKeyMine ( pubkey ) ; } else { byte [ ] pubkeyHash = script . getPubKeyHash ( ) ; return wallet . isPubKeyHashMine ( pubkeyHash ) ; } } catch ( ScriptException e ) { log . debug ( STRING , e . toString ( ) ) ; return _BOOL ; } }
public void removeMorphListener ( MorphListener listener ) { mMorphListeners . remove ( listener ) ; }
public void removeMorphListener ( MorphListener listener ) { mMorphListeners . remove ( listener ) ; }
private StringBuilder makeDescription ( Collection < Relation < ? > > relations , DBIDRef id ) { StringBuilder buf = new StringBuilder ( ) ; for ( Relation < ? > rel : relations ) { Object o = rel . get ( id ) ; if ( o == null ) { continue ; } String s = o . toString ( ) ; if ( s != null ) { if ( buf . length ( ) > _NUM ) { buf . append ( STRING ) ; } buf . append ( s ) ; } } return buf ; }
public void rotate ( double theta ) { currentTransform . rotate ( theta ) ; try { writeTransform ( new AffineTransform ( Math . cos ( theta ) , Math . sin ( theta ) , - Math . sin ( theta ) , Math . cos ( theta ) , _NUM , _NUM ) ) ; } catch ( IOException e ) { handleException ( e ) ; } }
public void rotate ( double theta ) { currentTransform . rotate ( theta ) ; try { writeTransform ( new AffineTransform ( Math . cos ( theta ) , Math . sin ( theta ) , - Math . sin ( theta ) , Math . cos ( theta ) , _NUM , _NUM ) ) ; } catch ( IOException e ) { handleException ( e ) ; } }
public void rotate ( double theta ) { currentTransform . rotate ( theta ) ; try { writeTransform ( new AffineTransform ( Math . cos ( theta ) , Math . sin ( theta ) , - Math . sin ( theta ) , Math . cos ( theta ) , _NUM , _NUM ) ) ; } catch ( IOException e ) { handleException ( e ) ; } }
public int read ( ) throws IOException { int b0 = fInputStream . read ( ) & _NUM ; if ( b0 == _NUM ) return - _NUM ; int b1 = fInputStream . read ( ) & _NUM ; if ( b1 == _NUM ) return - _NUM ; if ( fEncoding >= _NUM ) { int b2 = fInputStream . read ( ) & _NUM ; if ( b2 == _NUM ) return - _NUM ; int b3 = fInputStream . read ( ) & _NUM ; if ( b3 == _NUM ) return - _NUM ; if ( log . isLoggable ( Level . FINE ) ) log . fine ( STRING + ( b0 & _NUM ) + STRING + ( b1 & _NUM ) + STRING + ( b2 & _NUM ) + STRING + ( b3 & _NUM ) ) ; if ( fEncoding == UCS4BE ) return ( b0 << _NUM ) + ( b1 << _NUM ) + ( b2 << _NUM ) + b3 ; else return ( b3 << _NUM ) + ( b2 << _NUM ) + ( b1 << _NUM ) + b0 ; } else { if ( fEncoding == UCS2BE ) return ( b0 << _NUM ) + b1 ; else return ( b1 << _NUM ) + b0 ; } }
public int read ( ) throws IOException { int b0 = fInputStream . read ( ) & _NUM ; if ( b0 == _NUM ) return - _NUM ; int b1 = fInputStream . read ( ) & _NUM ; if ( b1 == _NUM ) return - _NUM ; if ( fEncoding >= _NUM ) { int b2 = fInputStream . read ( ) & _NUM ; if ( b2 == _NUM ) return - _NUM ; int b3 = fInputStream . read ( ) & _NUM ; if ( b3 == _NUM ) return - _NUM ; if ( log . isLoggable ( Level . FINE ) ) log . fine ( STRING + ( b0 & _NUM ) + STRING + ( b1 & _NUM ) + STRING + ( b2 & _NUM ) + STRING + ( b3 & _NUM ) ) ; if ( fEncoding == UCS4BE ) return ( b0 << _NUM ) + ( b1 << _NUM ) + ( b2 << _NUM ) + b3 ; else return ( b3 << _NUM ) + ( b2 << _NUM ) + ( b1 << _NUM ) + b0 ; } else { if ( fEncoding == UCS2BE ) return ( b0 << _NUM ) + b1 ; else return ( b1 << _NUM ) + b0 ; } }
public int read ( ) throws IOException { int b0 = fInputStream . read ( ) & _NUM ; if ( b0 == _NUM ) return - _NUM ; int b1 = fInputStream . read ( ) & _NUM ; if ( b1 == _NUM ) return - _NUM ; if ( fEncoding >= _NUM ) { int b2 = fInputStream . read ( ) & _NUM ; if ( b2 == _NUM ) return - _NUM ; int b3 = fInputStream . read ( ) & _NUM ; if ( b3 == _NUM ) return - _NUM ; if ( log . isLoggable ( Level . FINE ) ) log . fine ( STRING + ( b0 & _NUM ) + STRING + ( b1 & _NUM ) + STRING + ( b2 & _NUM ) + STRING + ( b3 & _NUM ) ) ; if ( fEncoding == UCS4BE ) return ( b0 << _NUM ) + ( b1 << _NUM ) + ( b2 << _NUM ) + b3 ; else return ( b3 << _NUM ) + ( b2 << _NUM ) + ( b1 << _NUM ) + b0 ; } else { if ( fEncoding == UCS2BE ) return ( b0 << _NUM ) + b1 ; else return ( b1 << _NUM ) + b0 ; } }
public int read ( ) throws IOException { int b0 = fInputStream . read ( ) & _NUM ; if ( b0 == _NUM ) return - _NUM ; int b1 = fInputStream . read ( ) & _NUM ; if ( b1 == _NUM ) return - _NUM ; if ( fEncoding >= _NUM ) { int b2 = fInputStream . read ( ) & _NUM ; if ( b2 == _NUM ) return - _NUM ; int b3 = fInputStream . read ( ) & _NUM ; if ( b3 == _NUM ) return - _NUM ; if ( log . isLoggable ( Level . FINE ) ) log . fine ( STRING + ( b0 & _NUM ) + STRING + ( b1 & _NUM ) + STRING + ( b2 & _NUM ) + STRING + ( b3 & _NUM ) ) ; if ( fEncoding == UCS4BE ) return ( b0 << _NUM ) + ( b1 << _NUM ) + ( b2 << _NUM ) + b3 ; else return ( b3 << _NUM ) + ( b2 << _NUM ) + ( b1 << _NUM ) + b0 ; } else { if ( fEncoding == UCS2BE ) return ( b0 << _NUM ) + b1 ; else return ( b1 << _NUM ) + b0 ; } }
public int read ( ) throws IOException { int b0 = fInputStream . read ( ) & _NUM ; if ( b0 == _NUM ) return - _NUM ; int b1 = fInputStream . read ( ) & _NUM ; if ( b1 == _NUM ) return - _NUM ; if ( fEncoding >= _NUM ) { int b2 = fInputStream . read ( ) & _NUM ; if ( b2 == _NUM ) return - _NUM ; int b3 = fInputStream . read ( ) & _NUM ; if ( b3 == _NUM ) return - _NUM ; if ( log . isLoggable ( Level . FINE ) ) log . fine ( STRING + ( b0 & _NUM ) + STRING + ( b1 & _NUM ) + STRING + ( b2 & _NUM ) + STRING + ( b3 & _NUM ) ) ; if ( fEncoding == UCS4BE ) return ( b0 << _NUM ) + ( b1 << _NUM ) + ( b2 << _NUM ) + b3 ; else return ( b3 << _NUM ) + ( b2 << _NUM ) + ( b1 << _NUM ) + b0 ; } else { if ( fEncoding == UCS2BE ) return ( b0 << _NUM ) + b1 ; else return ( b1 << _NUM ) + b0 ; } }
static void handleReopen ( ) { if ( _allowVisible ) { if ( ! _visibleOnce ) restoreView ( ) ; setAppVisible ( _BOOL ) ; } }
static void handleReopen ( ) { if ( _allowVisible ) { if ( ! _visibleOnce ) restoreView ( ) ; setAppVisible ( _BOOL ) ; } }
static void handleReopen ( ) { if ( _allowVisible ) { if ( ! _visibleOnce ) restoreView ( ) ; setAppVisible ( _BOOL ) ; } }
static void handleReopen ( ) { if ( _allowVisible ) { if ( ! _visibleOnce ) restoreView ( ) ; setAppVisible ( _BOOL ) ; } }
public static OutputStream outputStream ( String out ) throws IOException { if ( out . equals ( STRING ) ) { return ForbiddenOk . systemDotOut ( ) ; } Files . createParentDirs ( new File ( out ) ) ; OutputStream stream = new BufferedOutputStream ( new FileOutputStream ( out ) ) ; if ( out . endsWith ( STRING ) ) { stream = new GZIPOutputStream ( stream ) ; } return stream ; }
public static OutputStream outputStream ( String out ) throws IOException { if ( out . equals ( STRING ) ) { return ForbiddenOk . systemDotOut ( ) ; } Files . createParentDirs ( new File ( out ) ) ; OutputStream stream = new BufferedOutputStream ( new FileOutputStream ( out ) ) ; if ( out . endsWith ( STRING ) ) { stream = new GZIPOutputStream ( stream ) ; } return stream ; }
public static OutputStream outputStream ( String out ) throws IOException { if ( out . equals ( STRING ) ) { return ForbiddenOk . systemDotOut ( ) ; } Files . createParentDirs ( new File ( out ) ) ; OutputStream stream = new BufferedOutputStream ( new FileOutputStream ( out ) ) ; if ( out . endsWith ( STRING ) ) { stream = new GZIPOutputStream ( stream ) ; } return stream ; }
public static List toEdges ( Collection dirEdges ) { List edges = new ArrayList ( ) ; for ( Iterator i = dirEdges . iterator ( ) ; i . hasNext ( ) ; ) { edges . add ( ( ( DirectedEdge ) i . next ( ) ) . parentEdge ) ; } return edges ; }
protected KeyPair generateKeyPair ( ) { KeyPair keyPair = null ; DHParameterSpec keySpec = new DHParameterSpec ( DH_MODULUS , DH_BASE ) ; try { KeyPairGenerator keyGen = KeyPairGenerator . getInstance ( STRING ) ; keyGen . initialize ( keySpec ) ; keyPair = keyGen . generateKeyPair ( ) ; keyAgreement = KeyAgreement . getInstance ( STRING ) ; keyAgreement . init ( keyPair . getPrivate ( ) ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; } return keyPair ; }
public long insertEntry ( ArrayList < String > key , ArrayList < String > value ) { ContentValues contentValues = new ContentValues ( ) ; for ( int i = _NUM ; key . size ( ) > i ; i ++ ) { contentValues . put ( key . get ( i ) , value . get ( i ) ) ; } Log . v ( STRING , contentValues . toString ( ) ) ; return db . insert ( mDefaultTable , null , contentValues ) ; }
private static Comparable < ? > castToComparable ( Object obj ) { try { return ( Comparable < ? > ) obj ; } catch ( ClassCastException cce ) { throw new IllegalArgumentException ( STRING + obj . getClass ( ) + STRING + StorageType . OBJECT + STRING , cce ) ; } }
private static Comparable < ? > castToComparable ( Object obj ) { try { return ( Comparable < ? > ) obj ; } catch ( ClassCastException cce ) { throw new IllegalArgumentException ( STRING + obj . getClass ( ) + STRING + StorageType . OBJECT + STRING , cce ) ; } }
public List < String > makeURLList ( String shard ) { List < String > urls = StrUtils . splitSmart ( shard , STRING , _BOOL ) ; for ( int i = _NUM ; i < urls . size ( ) ; i ++ ) { urls . set ( i , buildUrl ( urls . get ( i ) ) ) ; } if ( urls . size ( ) > _NUM ) Collections . shuffle ( urls , r ) ; return urls ; }
@ Override public boolean input ( Instance instance ) { if ( getInputFormat ( ) == null ) { throw new IllegalStateException ( STRING ) ; } if ( m_NewBatch ) { resetQueue ( ) ; m_NewBatch = _BOOL ; } if ( isFirstBatchDone ( ) && m_dontFilterAfterFirstBatch ) { push ( ( Instance ) instance . copy ( ) ) ; return _BOOL ; } if ( instance . isMissing ( m_AttIndex . getIndex ( ) ) ) { if ( ! getMatchMissingValues ( ) ) { push ( ( Instance ) instance . copy ( ) ) ; return _BOOL ; } else { return _BOOL ; } } if ( isNumeric ( ) ) { if ( ! m_Values . getInvert ( ) ) { if ( instance . value ( m_AttIndex . getIndex ( ) ) < m_Value ) { push ( ( Instance ) instance . copy ( ) ) ; return _BOOL ; } } else { if ( instance . value ( m_AttIndex . getIndex ( ) ) >= m_Value ) { push ( ( Instance ) instance . copy ( ) ) ; return _BOOL ; } } } if ( isNominal ( ) ) { if ( m_Values . isInRange ( ( int ) instance . value ( m_AttIndex . getIndex ( ) ) ) ) { Instance temp = ( Instance ) instance . copy ( ) ; if ( getModifyHeader ( ) ) { temp . setValue ( m_AttIndex . getIndex ( ) , m_NominalMapping [ ( int ) instance . value ( m_AttIndex . getIndex ( ) ) ] ) ; } push ( temp ) ; return _BOOL ; } } return _BOOL ; }
@ Override public boolean input ( Instance instance ) { if ( getInputFormat ( ) == null ) { throw new IllegalStateException ( STRING ) ; } if ( m_NewBatch ) { resetQueue ( ) ; m_NewBatch = _BOOL ; } if ( isFirstBatchDone ( ) && m_dontFilterAfterFirstBatch ) { push ( ( Instance ) instance . copy ( ) ) ; return _BOOL ; } if ( instance . isMissing ( m_AttIndex . getIndex ( ) ) ) { if ( ! getMatchMissingValues ( ) ) { push ( ( Instance ) instance . copy ( ) ) ; return _BOOL ; } else { return _BOOL ; } } if ( isNumeric ( ) ) { if ( ! m_Values . getInvert ( ) ) { if ( instance . value ( m_AttIndex . getIndex ( ) ) < m_Value ) { push ( ( Instance ) instance . copy ( ) ) ; return _BOOL ; } } else { if ( instance . value ( m_AttIndex . getIndex ( ) ) >= m_Value ) { push ( ( Instance ) instance . copy ( ) ) ; return _BOOL ; } } } if ( isNominal ( ) ) { if ( m_Values . isInRange ( ( int ) instance . value ( m_AttIndex . getIndex ( ) ) ) ) { Instance temp = ( Instance ) instance . copy ( ) ; if ( getModifyHeader ( ) ) { temp . setValue ( m_AttIndex . getIndex ( ) , m_NominalMapping [ ( int ) instance . value ( m_AttIndex . getIndex ( ) ) ] ) ; } push ( temp ) ; return _BOOL ; } } return _BOOL ; }
@ Override public boolean input ( Instance instance ) { if ( getInputFormat ( ) == null ) { throw new IllegalStateException ( STRING ) ; } if ( m_NewBatch ) { resetQueue ( ) ; m_NewBatch = _BOOL ; } if ( isFirstBatchDone ( ) && m_dontFilterAfterFirstBatch ) { push ( ( Instance ) instance . copy ( ) ) ; return _BOOL ; } if ( instance . isMissing ( m_AttIndex . getIndex ( ) ) ) { if ( ! getMatchMissingValues ( ) ) { push ( ( Instance ) instance . copy ( ) ) ; return _BOOL ; } else { return _BOOL ; } } if ( isNumeric ( ) ) { if ( ! m_Values . getInvert ( ) ) { if ( instance . value ( m_AttIndex . getIndex ( ) ) < m_Value ) { push ( ( Instance ) instance . copy ( ) ) ; return _BOOL ; } } else { if ( instance . value ( m_AttIndex . getIndex ( ) ) >= m_Value ) { push ( ( Instance ) instance . copy ( ) ) ; return _BOOL ; } } } if ( isNominal ( ) ) { if ( m_Values . isInRange ( ( int ) instance . value ( m_AttIndex . getIndex ( ) ) ) ) { Instance temp = ( Instance ) instance . copy ( ) ; if ( getModifyHeader ( ) ) { temp . setValue ( m_AttIndex . getIndex ( ) , m_NominalMapping [ ( int ) instance . value ( m_AttIndex . getIndex ( ) ) ] ) ; } push ( temp ) ; return _BOOL ; } } return _BOOL ; }
public boolean contains ( lalr_item itm ) { return _all . containsKey ( itm ) ; }
public boolean contains ( lalr_item itm ) { return _all . containsKey ( itm ) ; }
public static IndexWriterConfig newIndexWriterConfig ( ) { return newIndexWriterConfig ( new MockAnalyzer ( random ( ) ) ) ; }
protected SprogSlot findFree ( ) { for ( SprogSlot s : slots ) { if ( s . isFree ( ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + s . getSlotNumber ( ) ) ; } return s ; } } return ( null ) ; }
private void write ( final String str ) { try { if ( writer == null ) { writer = new OutputStreamWriter ( System . out ) ; } writer . write ( str ) ; } catch ( IOException ioe ) { logger . error ( STRING , ioe ) ; System . exit ( _NUM ) ; } }
public static void instrument ( Instrumentation inst ) throws ClassNotFoundException , UnmodifiableClassException , IOException { inst . redefineClasses ( new ClassDefinition [ ] { getRedefinedClass ( Object . class ) } ) ; }
public void dispose ( ) { logDebug ( STRING ) ; mSetupDone = _BOOL ; if ( mServiceConn != null ) { logDebug ( STRING ) ; if ( mContext != null && mService != null ) { try { mContext . unbindService ( mServiceConn ) ; } catch ( Exception e ) { logError ( e . getMessage ( ) ) ; } } } mDisposed = _BOOL ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
public void dispose ( ) { logDebug ( STRING ) ; mSetupDone = _BOOL ; if ( mServiceConn != null ) { logDebug ( STRING ) ; if ( mContext != null && mService != null ) { try { mContext . unbindService ( mServiceConn ) ; } catch ( Exception e ) { logError ( e . getMessage ( ) ) ; } } } mDisposed = _BOOL ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
public void dispose ( ) { logDebug ( STRING ) ; mSetupDone = _BOOL ; if ( mServiceConn != null ) { logDebug ( STRING ) ; if ( mContext != null && mService != null ) { try { mContext . unbindService ( mServiceConn ) ; } catch ( Exception e ) { logError ( e . getMessage ( ) ) ; } } } mDisposed = _BOOL ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
public void dispose ( ) { logDebug ( STRING ) ; mSetupDone = _BOOL ; if ( mServiceConn != null ) { logDebug ( STRING ) ; if ( mContext != null && mService != null ) { try { mContext . unbindService ( mServiceConn ) ; } catch ( Exception e ) { logError ( e . getMessage ( ) ) ; } } } mDisposed = _BOOL ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
public FloatArray resize ( FloatArray array , long size ) { if ( array instanceof BigFloatArray ) { return resizeInPlace ( ( BigFloatArray ) array , size ) ; } else { AbstractArray arr = ( AbstractArray ) array ; final FloatArray newArray = newFloatArray ( size , arr . clearOnResize ) ; for ( long i = _NUM , end = Math . min ( size , array . size ( ) ) ; i < end ; ++ i ) { newArray . set ( i , array . get ( i ) ) ; } arr . close ( ) ; return newArray ; } }
public static boolean equalPopulation ( final Population s1 , final Population s2 ) { try { @ SuppressWarnings ( STRING ) InputStream inputStream1 = null ; @ SuppressWarnings ( STRING ) InputStream inputStream2 = null ; try { inputStream1 = openPopulationInputStream ( s1 ) ; inputStream2 = openPopulationInputStream ( s2 ) ; return IOUtils . isEqual ( inputStream1 , inputStream2 ) ; } finally { if ( inputStream1 != null ) inputStream1 . close ( ) ; if ( inputStream2 != null ) inputStream2 . close ( ) ; } } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
public static boolean equalPopulation ( final Population s1 , final Population s2 ) { try { @ SuppressWarnings ( STRING ) InputStream inputStream1 = null ; @ SuppressWarnings ( STRING ) InputStream inputStream2 = null ; try { inputStream1 = openPopulationInputStream ( s1 ) ; inputStream2 = openPopulationInputStream ( s2 ) ; return IOUtils . isEqual ( inputStream1 , inputStream2 ) ; } finally { if ( inputStream1 != null ) inputStream1 . close ( ) ; if ( inputStream2 != null ) inputStream2 . close ( ) ; } } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
public static boolean equalPopulation ( final Population s1 , final Population s2 ) { try { @ SuppressWarnings ( STRING ) InputStream inputStream1 = null ; @ SuppressWarnings ( STRING ) InputStream inputStream2 = null ; try { inputStream1 = openPopulationInputStream ( s1 ) ; inputStream2 = openPopulationInputStream ( s2 ) ; return IOUtils . isEqual ( inputStream1 , inputStream2 ) ; } finally { if ( inputStream1 != null ) inputStream1 . close ( ) ; if ( inputStream2 != null ) inputStream2 . close ( ) ; } } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
public static boolean equalPopulation ( final Population s1 , final Population s2 ) { try { @ SuppressWarnings ( STRING ) InputStream inputStream1 = null ; @ SuppressWarnings ( STRING ) InputStream inputStream2 = null ; try { inputStream1 = openPopulationInputStream ( s1 ) ; inputStream2 = openPopulationInputStream ( s2 ) ; return IOUtils . isEqual ( inputStream1 , inputStream2 ) ; } finally { if ( inputStream1 != null ) inputStream1 . close ( ) ; if ( inputStream2 != null ) inputStream2 . close ( ) ; } } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
public static boolean equalPopulation ( final Population s1 , final Population s2 ) { try { @ SuppressWarnings ( STRING ) InputStream inputStream1 = null ; @ SuppressWarnings ( STRING ) InputStream inputStream2 = null ; try { inputStream1 = openPopulationInputStream ( s1 ) ; inputStream2 = openPopulationInputStream ( s2 ) ; return IOUtils . isEqual ( inputStream1 , inputStream2 ) ; } finally { if ( inputStream1 != null ) inputStream1 . close ( ) ; if ( inputStream2 != null ) inputStream2 . close ( ) ; } } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
public static boolean equalPopulation ( final Population s1 , final Population s2 ) { try { @ SuppressWarnings ( STRING ) InputStream inputStream1 = null ; @ SuppressWarnings ( STRING ) InputStream inputStream2 = null ; try { inputStream1 = openPopulationInputStream ( s1 ) ; inputStream2 = openPopulationInputStream ( s2 ) ; return IOUtils . isEqual ( inputStream1 , inputStream2 ) ; } finally { if ( inputStream1 != null ) inputStream1 . close ( ) ; if ( inputStream2 != null ) inputStream2 . close ( ) ; } } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
public static boolean equalPopulation ( final Population s1 , final Population s2 ) { try { @ SuppressWarnings ( STRING ) InputStream inputStream1 = null ; @ SuppressWarnings ( STRING ) InputStream inputStream2 = null ; try { inputStream1 = openPopulationInputStream ( s1 ) ; inputStream2 = openPopulationInputStream ( s2 ) ; return IOUtils . isEqual ( inputStream1 , inputStream2 ) ; } finally { if ( inputStream1 != null ) inputStream1 . close ( ) ; if ( inputStream2 != null ) inputStream2 . close ( ) ; } } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
public static boolean equalPopulation ( final Population s1 , final Population s2 ) { try { @ SuppressWarnings ( STRING ) InputStream inputStream1 = null ; @ SuppressWarnings ( STRING ) InputStream inputStream2 = null ; try { inputStream1 = openPopulationInputStream ( s1 ) ; inputStream2 = openPopulationInputStream ( s2 ) ; return IOUtils . isEqual ( inputStream1 , inputStream2 ) ; } finally { if ( inputStream1 != null ) inputStream1 . close ( ) ; if ( inputStream2 != null ) inputStream2 . close ( ) ; } } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
public static boolean equalPopulation ( final Population s1 , final Population s2 ) { try { @ SuppressWarnings ( STRING ) InputStream inputStream1 = null ; @ SuppressWarnings ( STRING ) InputStream inputStream2 = null ; try { inputStream1 = openPopulationInputStream ( s1 ) ; inputStream2 = openPopulationInputStream ( s2 ) ; return IOUtils . isEqual ( inputStream1 , inputStream2 ) ; } finally { if ( inputStream1 != null ) inputStream1 . close ( ) ; if ( inputStream2 != null ) inputStream2 . close ( ) ; } } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
public String toEncodedString ( ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( getMinPriority ( ) ) ; buf . append ( FIELD_DELIMITER ) ; for ( Iterator < String > i = activeBugCategorySet . iterator ( ) ; i . hasNext ( ) ; ) { buf . append ( i . next ( ) ) ; if ( i . hasNext ( ) ) { buf . append ( LISTITEM_DELIMITER ) ; } } buf . append ( FIELD_DELIMITER ) ; buf . append ( displayFalseWarnings ? STRING : STRING ) ; buf . append ( FIELD_DELIMITER ) ; buf . append ( getMinRank ( ) ) ; return buf . toString ( ) ; }
public String toEncodedString ( ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( getMinPriority ( ) ) ; buf . append ( FIELD_DELIMITER ) ; for ( Iterator < String > i = activeBugCategorySet . iterator ( ) ; i . hasNext ( ) ; ) { buf . append ( i . next ( ) ) ; if ( i . hasNext ( ) ) { buf . append ( LISTITEM_DELIMITER ) ; } } buf . append ( FIELD_DELIMITER ) ; buf . append ( displayFalseWarnings ? STRING : STRING ) ; buf . append ( FIELD_DELIMITER ) ; buf . append ( getMinRank ( ) ) ; return buf . toString ( ) ; }
static private String SHORT_Min ( ) { short tempValue = Short . MIN_VALUE ; return String . valueOf ( tempValue ) ; }
public SelectionBuilder reset ( ) { mTable = null ; mSelection . setLength ( _NUM ) ; mSelectionArgs . clear ( ) ; return this ; }
private void remove ( final IProgressOperation operation ) { m_progressPanel . remove ( operation . getProgressPanel ( ) ) ; if ( m_progressPanel . getComponentCount ( ) == _NUM ) { setVisible ( _BOOL ) ; } }
private void remove ( final IProgressOperation operation ) { m_progressPanel . remove ( operation . getProgressPanel ( ) ) ; if ( m_progressPanel . getComponentCount ( ) == _NUM ) { setVisible ( _BOOL ) ; } }
private long tryIncReaderOverflow ( long s ) { if ( ( s & ABITS ) == RFULL ) { if ( U . compareAndSwapLong ( this , STATE , s , s | RBITS ) ) { ++ readerOverflow ; U . putLongVolatile ( this , STATE , s ) ; return s ; } } else if ( ( nextSecondarySeed ( ) & OVERFLOW_YIELD_RATE ) == _NUM ) Thread . yield ( ) ; return _NUM ; }
private long tryIncReaderOverflow ( long s ) { if ( ( s & ABITS ) == RFULL ) { if ( U . compareAndSwapLong ( this , STATE , s , s | RBITS ) ) { ++ readerOverflow ; U . putLongVolatile ( this , STATE , s ) ; return s ; } } else if ( ( nextSecondarySeed ( ) & OVERFLOW_YIELD_RATE ) == _NUM ) Thread . yield ( ) ; return _NUM ; }
private void initComputeProgram ( ) { glUseProgram ( computeProgram ) ; IntBuffer workGroupSize = BufferUtils . createIntBuffer ( _NUM ) ; glGetProgramiv ( computeProgram , GL_COMPUTE_WORK_GROUP_SIZE , workGroupSize ) ; workGroupSizeX = workGroupSize . get ( _NUM ) ; workGroupSizeY = workGroupSize . get ( _NUM ) ; timeUniform = glGetUniformLocation ( computeProgram , STRING ) ; blendFactorUniform = glGetUniformLocation ( computeProgram , STRING ) ; bounceCountUniform = glGetUniformLocation ( computeProgram , STRING ) ; IntBuffer params = BufferUtils . createIntBuffer ( _NUM ) ; int loc = glGetUniformLocation ( computeProgram , STRING ) ; glGetUniformiv ( computeProgram , loc , params ) ; framebufferImageBinding = params . get ( _NUM ) ; loc = glGetUniformLocation ( computeProgram , STRING ) ; glGetUniformiv ( computeProgram , loc , params ) ; worldPositionImageBinding = params . get ( _NUM ) ; loc = glGetUniformLocation ( computeProgram , STRING ) ; glGetUniformiv ( computeProgram , loc , params ) ; worldNormalImageBinding = params . get ( _NUM ) ; glUseProgram ( _NUM ) ; }
public static void writeToFile ( String fileName , String content ) { String classMethod = STRING ; FileWriter fout = null ; try { fout = new FileWriter ( fileName ) ; fout . write ( content ) ; } catch ( IOException e ) { debug . error ( classMethod + STRING + fileName ) ; } finally { if ( fout != null ) { try { fout . close ( ) ; } catch ( Exception ex ) { } } } }
public RecognitionRequest addCustomOperation ( String customOperation ) { operations . add ( customOperation ) ; return this ; }
static public String toString ( ArrayList value ) { String str = STRING ; for ( int i = _NUM ; i < value . size ( ) ; i ++ ) { if ( i > _NUM ) str += STRING ; str += ( String ) value . get ( i ) ; } return str ; }
static public String toString ( ArrayList value ) { String str = STRING ; for ( int i = _NUM ; i < value . size ( ) ; i ++ ) { if ( i > _NUM ) str += STRING ; str += ( String ) value . get ( i ) ; } return str ; }
private Component createSeparator ( ) { JSeparator sep = new JSeparator ( SwingConstants . VERTICAL ) ; sep . setPreferredSize ( new Dimension ( _NUM , _NUM ) ) ; sep . setMinimumSize ( new Dimension ( _NUM , _NUM ) ) ; return sep ; }
static double fd ( double x ) { return x * Math . cos ( x ) + _NUM * Math . sin ( x ) - _NUM ; }
static double fd ( double x ) { return x * Math . cos ( x ) + _NUM * Math . sin ( x ) - _NUM ; }
public Requestor ( String [ ] groups , int port , boolean delayFlag ) throws IOException { super ( STRING ) ; setDaemon ( _BOOL ) ; sock = new MulticastSocket ( Constants . getDiscoveryPort ( ) ) ; sock . setTimeToLive ( multicastRequestConstraints . getMulticastTimeToLive ( Constants . getTtl ( ) ) ) ; responsePort = port ; this . groups = groups == null ? new String [ _NUM ] : groups ; this . delayFlag = delayFlag ; }
public static Script createMultiSigInputScript ( List < TransactionSignature > signatures ) { List < byte [ ] > sigs = new ArrayList < byte [ ] > ( signatures . size ( ) ) ; for ( TransactionSignature signature : signatures ) sigs . add ( signature . encodeToBitcoin ( ) ) ; return createMultiSigInputScriptBytes ( sigs ) ; }
public static Script createMultiSigInputScript ( List < TransactionSignature > signatures ) { List < byte [ ] > sigs = new ArrayList < byte [ ] > ( signatures . size ( ) ) ; for ( TransactionSignature signature : signatures ) sigs . add ( signature . encodeToBitcoin ( ) ) ; return createMultiSigInputScriptBytes ( sigs ) ; }
public static Script createMultiSigInputScript ( List < TransactionSignature > signatures ) { List < byte [ ] > sigs = new ArrayList < byte [ ] > ( signatures . size ( ) ) ; for ( TransactionSignature signature : signatures ) sigs . add ( signature . encodeToBitcoin ( ) ) ; return createMultiSigInputScriptBytes ( sigs ) ; }
public static List < MRelationType > retrieveTypes ( final PO po , final int windowId ) { if ( po . get_KeyColumns ( ) . length != _NUM ) { logger . severe ( po + STRING + po . get_KeyColumns ( ) . length + STRING ) ; PORelationException . throwWrongKeyColumnCount ( po ) ; } final String keyColumn = po . get_KeyColumns ( ) [ _NUM ] ; final int colId = MColumn . getColumn_ID ( po . get_TableName ( ) , keyColumn ) ; final PreparedStatement pstmt = DB . prepareStatement ( SQL , po . get_TrxName ( ) ) ; ResultSet rs = null ; try { pstmt . setInt ( _NUM , po . get_Table_ID ( ) ) ; pstmt . setInt ( _NUM , colId ) ; rs = pstmt . executeQuery ( ) ; final List < MRelationType > result = evalResultSet ( po , windowId , rs ) ; logger . info ( STRING + result . size ( ) + STRING + po ) ; return result ; } catch ( SQLException e ) { logger . severe ( e . getMessage ( ) ) ; throw new AdempiereException ( e ) ; } finally { DB . close ( rs , pstmt ) ; } }
public static List < MRelationType > retrieveTypes ( final PO po , final int windowId ) { if ( po . get_KeyColumns ( ) . length != _NUM ) { logger . severe ( po + STRING + po . get_KeyColumns ( ) . length + STRING ) ; PORelationException . throwWrongKeyColumnCount ( po ) ; } final String keyColumn = po . get_KeyColumns ( ) [ _NUM ] ; final int colId = MColumn . getColumn_ID ( po . get_TableName ( ) , keyColumn ) ; final PreparedStatement pstmt = DB . prepareStatement ( SQL , po . get_TrxName ( ) ) ; ResultSet rs = null ; try { pstmt . setInt ( _NUM , po . get_Table_ID ( ) ) ; pstmt . setInt ( _NUM , colId ) ; rs = pstmt . executeQuery ( ) ; final List < MRelationType > result = evalResultSet ( po , windowId , rs ) ; logger . info ( STRING + result . size ( ) + STRING + po ) ; return result ; } catch ( SQLException e ) { logger . severe ( e . getMessage ( ) ) ; throw new AdempiereException ( e ) ; } finally { DB . close ( rs , pstmt ) ; } }
public static List < MRelationType > retrieveTypes ( final PO po , final int windowId ) { if ( po . get_KeyColumns ( ) . length != _NUM ) { logger . severe ( po + STRING + po . get_KeyColumns ( ) . length + STRING ) ; PORelationException . throwWrongKeyColumnCount ( po ) ; } final String keyColumn = po . get_KeyColumns ( ) [ _NUM ] ; final int colId = MColumn . getColumn_ID ( po . get_TableName ( ) , keyColumn ) ; final PreparedStatement pstmt = DB . prepareStatement ( SQL , po . get_TrxName ( ) ) ; ResultSet rs = null ; try { pstmt . setInt ( _NUM , po . get_Table_ID ( ) ) ; pstmt . setInt ( _NUM , colId ) ; rs = pstmt . executeQuery ( ) ; final List < MRelationType > result = evalResultSet ( po , windowId , rs ) ; logger . info ( STRING + result . size ( ) + STRING + po ) ; return result ; } catch ( SQLException e ) { logger . severe ( e . getMessage ( ) ) ; throw new AdempiereException ( e ) ; } finally { DB . close ( rs , pstmt ) ; } }
public static List < MRelationType > retrieveTypes ( final PO po , final int windowId ) { if ( po . get_KeyColumns ( ) . length != _NUM ) { logger . severe ( po + STRING + po . get_KeyColumns ( ) . length + STRING ) ; PORelationException . throwWrongKeyColumnCount ( po ) ; } final String keyColumn = po . get_KeyColumns ( ) [ _NUM ] ; final int colId = MColumn . getColumn_ID ( po . get_TableName ( ) , keyColumn ) ; final PreparedStatement pstmt = DB . prepareStatement ( SQL , po . get_TrxName ( ) ) ; ResultSet rs = null ; try { pstmt . setInt ( _NUM , po . get_Table_ID ( ) ) ; pstmt . setInt ( _NUM , colId ) ; rs = pstmt . executeQuery ( ) ; final List < MRelationType > result = evalResultSet ( po , windowId , rs ) ; logger . info ( STRING + result . size ( ) + STRING + po ) ; return result ; } catch ( SQLException e ) { logger . severe ( e . getMessage ( ) ) ; throw new AdempiereException ( e ) ; } finally { DB . close ( rs , pstmt ) ; } }
public boolean canEdit ( Class omgc ) { Iterator iterator ; if ( possibleEditableClasses == null ) { Set keys = loaders . keySet ( ) ; possibleEditableClasses = new Vector ( keys . size ( ) ) ; iterator = keys . iterator ( ) ; while ( iterator . hasNext ( ) ) { String key = ( String ) iterator . next ( ) ; try { possibleEditableClasses . add ( Class . forName ( key ) ) ; } catch ( ClassNotFoundException cnfe ) { } } } iterator = possibleEditableClasses . iterator ( ) ; while ( iterator . hasNext ( ) ) { Class kc = ( Class ) iterator . next ( ) ; if ( kc == omgc || kc . isAssignableFrom ( omgc ) ) { return _BOOL ; } } return _BOOL ; }
public boolean canEdit ( Class omgc ) { Iterator iterator ; if ( possibleEditableClasses == null ) { Set keys = loaders . keySet ( ) ; possibleEditableClasses = new Vector ( keys . size ( ) ) ; iterator = keys . iterator ( ) ; while ( iterator . hasNext ( ) ) { String key = ( String ) iterator . next ( ) ; try { possibleEditableClasses . add ( Class . forName ( key ) ) ; } catch ( ClassNotFoundException cnfe ) { } } } iterator = possibleEditableClasses . iterator ( ) ; while ( iterator . hasNext ( ) ) { Class kc = ( Class ) iterator . next ( ) ; if ( kc == omgc || kc . isAssignableFrom ( omgc ) ) { return _BOOL ; } } return _BOOL ; }
private BinlogPosition findHeartbeat ( MaxwellReplicator r ) throws Exception { r . startReplicator ( ) ; for ( RowMap row = r . getRow ( ) ; row != null ; row = r . getRow ( ) ) { if ( Objects . equals ( r . getLastHeartbeatRead ( ) , recoveryInfo . heartbeat ) ) return row . getPosition ( ) ; } return null ; }
private BinlogPosition findHeartbeat ( MaxwellReplicator r ) throws Exception { r . startReplicator ( ) ; for ( RowMap row = r . getRow ( ) ; row != null ; row = r . getRow ( ) ) { if ( Objects . equals ( r . getLastHeartbeatRead ( ) , recoveryInfo . heartbeat ) ) return row . getPosition ( ) ; } return null ; }
private void discard ( ) { if ( mReviewId == _NUM ) { deleteDraft ( ) ; } discardReview ( _BOOL ) ; }
CorsServiceBuilder ( final String ... origins ) { final Set < String > originsCopy = new LinkedHashSet < > ( ) ; for ( String o : origins ) { originsCopy . add ( o . toLowerCase ( Locale . ENGLISH ) ) ; } this . origins = Collections . unmodifiableSet ( originsCopy ) ; anyOriginSupported = _BOOL ; }
public static int eliminateZeroMassPoints ( int [ ] densityPoints , double [ ] densityValues ) { int positiveMassCount = _NUM ; for ( int i = _NUM ; i < densityValues . length ; i ++ ) { if ( densityValues [ i ] > _NUM ) { positiveMassCount ++ ; } } if ( positiveMassCount < densityValues . length ) { int [ ] newPoints = new int [ positiveMassCount ] ; double [ ] newValues = new double [ positiveMassCount ] ; int j = _NUM ; for ( int i = _NUM ; i < densityValues . length ; i ++ ) { if ( densityValues [ i ] > _NUM ) { newPoints [ j ] = densityPoints [ i ] ; newValues [ j ] = densityValues [ i ] ; j ++ ; } } System . arraycopy ( newPoints , _NUM , densityPoints , _NUM , positiveMassCount ) ; System . arraycopy ( newValues , _NUM , densityValues , _NUM , positiveMassCount ) ; } return positiveMassCount ; }
public static int eliminateZeroMassPoints ( int [ ] densityPoints , double [ ] densityValues ) { int positiveMassCount = _NUM ; for ( int i = _NUM ; i < densityValues . length ; i ++ ) { if ( densityValues [ i ] > _NUM ) { positiveMassCount ++ ; } } if ( positiveMassCount < densityValues . length ) { int [ ] newPoints = new int [ positiveMassCount ] ; double [ ] newValues = new double [ positiveMassCount ] ; int j = _NUM ; for ( int i = _NUM ; i < densityValues . length ; i ++ ) { if ( densityValues [ i ] > _NUM ) { newPoints [ j ] = densityPoints [ i ] ; newValues [ j ] = densityValues [ i ] ; j ++ ; } } System . arraycopy ( newPoints , _NUM , densityPoints , _NUM , positiveMassCount ) ; System . arraycopy ( newValues , _NUM , densityValues , _NUM , positiveMassCount ) ; } return positiveMassCount ; }
public static int eliminateZeroMassPoints ( int [ ] densityPoints , double [ ] densityValues ) { int positiveMassCount = _NUM ; for ( int i = _NUM ; i < densityValues . length ; i ++ ) { if ( densityValues [ i ] > _NUM ) { positiveMassCount ++ ; } } if ( positiveMassCount < densityValues . length ) { int [ ] newPoints = new int [ positiveMassCount ] ; double [ ] newValues = new double [ positiveMassCount ] ; int j = _NUM ; for ( int i = _NUM ; i < densityValues . length ; i ++ ) { if ( densityValues [ i ] > _NUM ) { newPoints [ j ] = densityPoints [ i ] ; newValues [ j ] = densityValues [ i ] ; j ++ ; } } System . arraycopy ( newPoints , _NUM , densityPoints , _NUM , positiveMassCount ) ; System . arraycopy ( newValues , _NUM , densityValues , _NUM , positiveMassCount ) ; } return positiveMassCount ; }
@ SafeVarargs public static < E extends Enum < E > > EnumSet < E > of ( E start , E ... others ) { EnumSet < E > set = of ( start ) ; for ( E e : others ) { set . add ( e ) ; } return set ; }
@ SafeVarargs public static < E extends Enum < E > > EnumSet < E > of ( E start , E ... others ) { EnumSet < E > set = of ( start ) ; for ( E e : others ) { set . add ( e ) ; } return set ; }
@ SafeVarargs public static < E extends Enum < E > > EnumSet < E > of ( E start , E ... others ) { EnumSet < E > set = of ( start ) ; for ( E e : others ) { set . add ( e ) ; } return set ; }
@ SafeVarargs public static < E extends Enum < E > > EnumSet < E > of ( E start , E ... others ) { EnumSet < E > set = of ( start ) ; for ( E e : others ) { set . add ( e ) ; } return set ; }
@ SafeVarargs public static < E extends Enum < E > > EnumSet < E > of ( E start , E ... others ) { EnumSet < E > set = of ( start ) ; for ( E e : others ) { set . add ( e ) ; } return set ; }
@ SafeVarargs public static < E extends Enum < E > > EnumSet < E > of ( E start , E ... others ) { EnumSet < E > set = of ( start ) ; for ( E e : others ) { set . add ( e ) ; } return set ; }
@ SafeVarargs public static < E extends Enum < E > > EnumSet < E > of ( E start , E ... others ) { EnumSet < E > set = of ( start ) ; for ( E e : others ) { set . add ( e ) ; } return set ; }
@ Override public Value concatenate ( Value value ) { if ( ! ( value instanceof RelationalVal ) ) { throw new RuntimeException ( STRING + this + STRING + value ) ; } return new RelationalVal ( toString ( ) + value . toString ( ) ) ; }
ClassIntrospector ( ClassIntrospectorBuilder pa , Object sharedLock ) { this ( pa , sharedLock , _BOOL , _BOOL ) ; }
public Builder histogramQuantiles ( double ... quantiles ) { histogramPercentiles = new HashSet < > ( ) ; for ( double q : quantiles ) { histogramPercentiles . add ( new Percentile ( q ) ) ; } return this ; }
public Builder histogramQuantiles ( double ... quantiles ) { histogramPercentiles = new HashSet < > ( ) ; for ( double q : quantiles ) { histogramPercentiles . add ( new Percentile ( q ) ) ; } return this ; }
private List < Item > moveItemsFromSlotToList ( RPSlot slot ) { List < Item > items = new LinkedList < Item > ( ) ; for ( RPObject item : slot ) { if ( item instanceof Item ) { items . add ( ( Item ) item ) ; } } slot . clear ( ) ; return items ; }
public static void checkProxyPackageAccess ( Class < ? > clazz ) { SecurityManager s = System . getSecurityManager ( ) ; if ( s != null ) { if ( Proxy . isProxyClass ( clazz ) ) { for ( Class < ? > intf : clazz . getInterfaces ( ) ) { checkPackageAccess ( intf ) ; } } } }
public Object createSoftWeakRef ( Object o ) { return new SoftReference ( o ) ; }
public Object createSoftWeakRef ( Object o ) { return new SoftReference ( o ) ; }
public Object createSoftWeakRef ( Object o ) { return new SoftReference ( o ) ; }
public Object createSoftWeakRef ( Object o ) { return new SoftReference ( o ) ; }
public void call ( String name , JsonOutput . JsonUnescaped json ) throws IOException { if ( generator . isExcludingFieldsNamed ( name ) ) { return ; } writeName ( name ) ; verifyValue ( ) ; writer . write ( json . toString ( ) ) ; }
public synchronized void removeOFChannelHandler ( OFChannelHandler h ) { connectedChannelHandlers . remove ( h ) ; }
public synchronized void removeOFChannelHandler ( OFChannelHandler h ) { connectedChannelHandlers . remove ( h ) ; }
private String gaps ( int n ) { StringBuilder buf = new StringBuilder ( ) ; for ( ; n > _NUM ; n -- ) { buf . append ( STRING ) ; } return buf . toString ( ) ; }
public void deleteAll ( ) { Integer oldSize = Integer . valueOf ( _hashTable . size ( ) ) ; Enumeration < String > en = _hashTable . keys ( ) ; while ( en . hasMoreElements ( ) ) { RollingStock rs = getById ( en . nextElement ( ) ) ; rs . dispose ( ) ; _hashTable . remove ( rs . getId ( ) ) ; } firePropertyChange ( LISTLENGTH_CHANGED_PROPERTY , oldSize , Integer . valueOf ( _hashTable . size ( ) ) ) ; }
private Node < K , V > putIfAbsent ( Node < K , V > node ) { Node < K , V > old = data . putIfAbsent ( node . getKey ( ) , node ) ; if ( old == null ) { length . incrementAndGet ( ) ; node . appendToTail ( ) ; evict ( ) ; } else { policy . onAccess ( this , old ) ; } return old ; }
private Node < K , V > putIfAbsent ( Node < K , V > node ) { Node < K , V > old = data . putIfAbsent ( node . getKey ( ) , node ) ; if ( old == null ) { length . incrementAndGet ( ) ; node . appendToTail ( ) ; evict ( ) ; } else { policy . onAccess ( this , old ) ; } return old ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( _NUM ) ; buf . append ( STRING ) ; ObjectIdentifier oid ; PKCS9Attribute value ; boolean first = _BOOL ; for ( int i = _NUM ; i < PKCS9Attribute . PKCS9_OIDS . length ; i ++ ) { value = getAttribute ( PKCS9Attribute . PKCS9_OIDS [ i ] ) ; if ( value == null ) continue ; if ( first ) first = _BOOL ; else buf . append ( STRING ) ; buf . append ( value . toString ( ) ) ; } buf . append ( STRING ) ; return buf . toString ( ) ; }
public synchronized void addNewMention ( int serverId , Conversation conversation , String msg , boolean vibrate , boolean sound , boolean light ) { if ( conversation == null ) { return ; } conversation . addNewMention ( ) ; ++ newMentions ; String convId = getConversationId ( serverId , conversation . getName ( ) ) ; if ( ! mentions . containsKey ( convId ) ) { mentions . put ( convId , conversation ) ; } if ( newMentions == _NUM ) { updateNotification ( msg , msg , vibrate , sound , light ) ; } else { updateNotification ( msg , null , vibrate , sound , light ) ; } }
public EncryptedEditor putBoolean ( String key , boolean value ) { putValue ( key , String . valueOf ( value ) ) ; return this ; }
@ Override public double java2DToValue ( double java2DValue , Rectangle2D area , RectangleEdge edge ) { double result = _NUM ; if ( this . displayStart < this . displayEnd ) { result = super . java2DToValue ( java2DValue , area , edge ) ; } else { } return result ; }
public static boolean exists ( final String url ) { return XAdES132 . equals ( url ) || XAdES111 . equals ( url ) || XAdES122 . equals ( url ) || XAdES . equals ( url ) ; }
public static boolean exists ( final String url ) { return XAdES132 . equals ( url ) || XAdES111 . equals ( url ) || XAdES122 . equals ( url ) || XAdES . equals ( url ) ; }
public static void closeInputStream ( InputStream stream , String tag ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { Log . e ( tag , STRING , e ) ; } } }
public int lastIndexOf ( String subString , int start ) { int count = length ( ) ; int subCount = subString . length ( ) ; if ( subCount <= count && start >= _NUM ) { if ( subCount > _NUM ) { if ( start > count - subCount ) { start = count - subCount ; } char [ ] target = subString . toCharArray ( ) ; int subOffset = _NUM ; char firstChar = target [ subOffset ] ; int end = subOffset + subCount ; while ( _BOOL ) { int i = lastIndexOf ( firstChar , start ) ; if ( i == - _NUM ) { return - _NUM ; } int o1 = i , o2 = subOffset ; while ( ++ o2 < end && charAt ( ++ o1 ) == target [ o2 ] ) { } if ( o2 == end ) { return i ; } start = i - _NUM ; } } return start < count ? start : count ; } return - _NUM ; }
public int lastIndexOf ( String subString , int start ) { int count = length ( ) ; int subCount = subString . length ( ) ; if ( subCount <= count && start >= _NUM ) { if ( subCount > _NUM ) { if ( start > count - subCount ) { start = count - subCount ; } char [ ] target = subString . toCharArray ( ) ; int subOffset = _NUM ; char firstChar = target [ subOffset ] ; int end = subOffset + subCount ; while ( _BOOL ) { int i = lastIndexOf ( firstChar , start ) ; if ( i == - _NUM ) { return - _NUM ; } int o1 = i , o2 = subOffset ; while ( ++ o2 < end && charAt ( ++ o1 ) == target [ o2 ] ) { } if ( o2 == end ) { return i ; } start = i - _NUM ; } } return start < count ? start : count ; } return - _NUM ; }
protected void removeCycles ( ) { int visited [ ] = new int [ m_nodes . size ( ) ] ; for ( int i = _NUM ; i < graphMatrix . length ; i ++ ) { if ( visited [ i ] == _NUM ) { removeCycles2 ( i , visited ) ; visited [ i ] = _NUM ; } } }
protected void removeCycles ( ) { int visited [ ] = new int [ m_nodes . size ( ) ] ; for ( int i = _NUM ; i < graphMatrix . length ; i ++ ) { if ( visited [ i ] == _NUM ) { removeCycles2 ( i , visited ) ; visited [ i ] = _NUM ; } } }
public String createQueryString ( Projection p ) { if ( queryHeader == null ) { return null ; } StringBuffer buf = new StringBuffer ( queryHeader ) ; buf . append ( REQUEST + STRING + MAP + STRING ) ; if ( p != null ) { Point2D center = p . getCenter ( ) ; buf . append ( PROJTYPE + STRING + p . getName ( ) + STRING + SCALE + STRING + p . getScale ( ) + STRING + LAT + STRING + center . getY ( ) + STRING + LON + STRING + center . getX ( ) + STRING + HEIGHT + STRING + p . getHeight ( ) + STRING + WIDTH + STRING + p . getWidth ( ) ) ; } else { buf . append ( PROJTYPE + STRING + SCALE + STRING + LAT + STRING + LON + STRING + HEIGHT + STRING + WIDTH + STRING ) ; } if ( imageFormat != null ) { buf . append ( STRING + FORMAT + STRING + imageFormat ) ; } if ( transparent ) { buf . append ( STRING + TRANSPARENT + STRING ) ; } if ( backgroundColor != null ) { buf . append ( STRING + BGCOLOR + STRING + backgroundColor ) ; } String layers = getLayerMarkers ( ) ; if ( layers != null ) { buf . append ( STRING + layers ) ; } return buf . toString ( ) ; }
public String createQueryString ( Projection p ) { if ( queryHeader == null ) { return null ; } StringBuffer buf = new StringBuffer ( queryHeader ) ; buf . append ( REQUEST + STRING + MAP + STRING ) ; if ( p != null ) { Point2D center = p . getCenter ( ) ; buf . append ( PROJTYPE + STRING + p . getName ( ) + STRING + SCALE + STRING + p . getScale ( ) + STRING + LAT + STRING + center . getY ( ) + STRING + LON + STRING + center . getX ( ) + STRING + HEIGHT + STRING + p . getHeight ( ) + STRING + WIDTH + STRING + p . getWidth ( ) ) ; } else { buf . append ( PROJTYPE + STRING + SCALE + STRING + LAT + STRING + LON + STRING + HEIGHT + STRING + WIDTH + STRING ) ; } if ( imageFormat != null ) { buf . append ( STRING + FORMAT + STRING + imageFormat ) ; } if ( transparent ) { buf . append ( STRING + TRANSPARENT + STRING ) ; } if ( backgroundColor != null ) { buf . append ( STRING + BGCOLOR + STRING + backgroundColor ) ; } String layers = getLayerMarkers ( ) ; if ( layers != null ) { buf . append ( STRING + layers ) ; } return buf . toString ( ) ; }
public String readLine ( String fmt , Object ... args ) { String line = null ; synchronized ( writeLock ) { synchronized ( readLock ) { if ( fmt . length ( ) != _NUM ) pw . format ( fmt , args ) ; try { char [ ] ca = readline ( _BOOL ) ; if ( ca != null ) line = new String ( ca ) ; } catch ( IOException x ) { throw new IOError ( x ) ; } } } return line ; }
private static String [ ] match ( String value ) { if ( value == null ) { return null ; } Matcher matcher = IPV4_PATTERN . matcher ( value ) ; if ( matcher . matches ( ) ) { int count = matcher . groupCount ( ) ; String [ ] groups = new String [ count ] ; for ( int j = _NUM ; j < count ; j ++ ) { groups [ j ] = matcher . group ( j + _NUM ) ; } return groups ; } return null ; }
private static String [ ] match ( String value ) { if ( value == null ) { return null ; } Matcher matcher = IPV4_PATTERN . matcher ( value ) ; if ( matcher . matches ( ) ) { int count = matcher . groupCount ( ) ; String [ ] groups = new String [ count ] ; for ( int j = _NUM ; j < count ; j ++ ) { groups [ j ] = matcher . group ( j + _NUM ) ; } return groups ; } return null ; }
public void writeInt ( int v ) throws IOException { dataOutput . writeInt ( v ) ; offset += _NUM ; }
void appendWhere ( CharSequence inWhere ) { }
private static void deleteStackTrace ( WeakReference < Context > weakContext , String filename ) { Context context = null ; ArtisanLogUtil . debugLog ( STRING + filename ) ; if ( weakContext != null ) { context = weakContext . get ( ) ; if ( context != null ) { File file = new File ( filename ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } }
@ Override public void actionPerformed ( ActionEvent event ) { String command = event . getActionCommand ( ) ; if ( command . equals ( STRING ) ) { attemptFontSelection ( ) ; } else if ( command . equals ( STRING ) ) { attemptPaintSelection ( ) ; } else if ( command . equals ( STRING ) ) { attemptModifyShowTitle ( ) ; } }
public void ignoreAttKeys ( String [ ] attKeys , boolean ignorePathKeys ) { ignoredAttKeys . clear ( ) ; for ( String key : attKeys ) ignoredAttKeys . add ( key ) ; this . ignorePathKeys = ignorePathKeys ; }
public void ignoreAttKeys ( String [ ] attKeys , boolean ignorePathKeys ) { ignoredAttKeys . clear ( ) ; for ( String key : attKeys ) ignoredAttKeys . add ( key ) ; this . ignorePathKeys = ignorePathKeys ; }
public void ignoreAttKeys ( String [ ] attKeys , boolean ignorePathKeys ) { ignoredAttKeys . clear ( ) ; for ( String key : attKeys ) ignoredAttKeys . add ( key ) ; this . ignorePathKeys = ignorePathKeys ; }
public static final boolean validateGroupName ( String sGroupName ) { if ( sGroupName . length ( ) == _NUM ) { return _BOOL ; } return sGroupName . matches ( STRING ) ; }
@ SuppressWarnings ( STRING ) public List < String > removeInitiatorDetails ( URI initiatorId ) { List < String > result = Lists . newArrayList ( ) ; Initiator initiator = _dbClient . queryObject ( Initiator . class , initiatorId ) ; if ( initiator != null ) { result . add ( ComputeSystemDialogProperties . getMessage ( STRING , initiator . getInitiatorPort ( ) ) ) ; List < ExportGroup > exportGroups = ComputeSystemControllerImpl . getExportGroups ( _dbClient , initiator . getId ( ) , Lists . newArrayList ( initiator ) ) ; for ( ExportGroup export : exportGroups ) { List < URI > updatedInitiators = StringSetUtil . stringSetToUriList ( export . getInitiators ( ) ) ; if ( updatedInitiators . remove ( initiatorId ) ) { List < BlockObjectDetails > volumeDetails = getBlockObjectDetails ( initiator . getHost ( ) , export . getVolumes ( ) ) ; result . addAll ( getVolumeInitiatorDetails ( volumeDetails , _BOOL ) ) ; } } } return result ; }
public DSSDocument generateXAdESContentTimestampAsDSSDocument ( final DSSDocument toSignDocument , final XAdESSignatureParameters externalParameters , final TimestampType timestampType ) { final TimestampToken timestampToken = generateXAdESContentTimestampAsTimestampToken ( toSignDocument , externalParameters , timestampType ) ; return new InMemoryDocument ( timestampToken . getEncoded ( ) ) ; }
public DSSDocument generateXAdESContentTimestampAsDSSDocument ( final DSSDocument toSignDocument , final XAdESSignatureParameters externalParameters , final TimestampType timestampType ) { final TimestampToken timestampToken = generateXAdESContentTimestampAsTimestampToken ( toSignDocument , externalParameters , timestampType ) ; return new InMemoryDocument ( timestampToken . getEncoded ( ) ) ; }
public DateTime toDateTime ( double days ) { long utc = Math . round ( days * DAY_MILLIS ) ; utc -= CF_UNIX_OFFSET ; utc -= getLocalTimeZoneOffset ( utc ) ; return new DateTimeImpl ( utc , _BOOL ) ; }
private void addToQueue ( SerialMessage serialMessage ) { if ( serialMessage == null ) { return ; } if ( ! msgQueue . contains ( serialMessage ) && msgQueue . remainingCapacity ( ) > _NUM ) { msgQueue . add ( serialMessage ) ; } sendMessage ( ) ; }
public void storeLastPVPActionTime ( ) { put ( STRING , System . currentTimeMillis ( ) ) ; }
public static boolean isAnonymous ( String className ) { int i = className . lastIndexOf ( STRING ) ; if ( i >= _NUM && ++ i < className . length ( ) ) { while ( i < className . length ( ) ) { if ( ! Character . isDigit ( className . charAt ( i ) ) ) { return _BOOL ; } i ++ ; } return _BOOL ; } return _BOOL ; }
public static boolean isAnonymous ( String className ) { int i = className . lastIndexOf ( STRING ) ; if ( i >= _NUM && ++ i < className . length ( ) ) { while ( i < className . length ( ) ) { if ( ! Character . isDigit ( className . charAt ( i ) ) ) { return _BOOL ; } i ++ ; } return _BOOL ; } return _BOOL ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case _NUM : return ERROR_CODE ; case _NUM : return MESSAGE ; default : return null ; } }
protected void runFullImport ( String dataConfig , Map < String , String > extraParams ) throws Exception { HashMap < String , String > params = new HashMap < > ( ) ; params . put ( STRING , STRING ) ; params . put ( STRING , STRING ) ; params . put ( STRING , dataConfig ) ; params . put ( STRING , STRING ) ; params . put ( STRING , STRING ) ; params . putAll ( extraParams ) ; NamedList l = new NamedList ( ) ; for ( Map . Entry < String , String > e : params . entrySet ( ) ) { l . add ( e . getKey ( ) , e . getValue ( ) ) ; } LocalSolrQueryRequest request = new LocalSolrQueryRequest ( h . getCore ( ) , l ) ; h . query ( STRING , request ) ; }
protected void runFullImport ( String dataConfig , Map < String , String > extraParams ) throws Exception { HashMap < String , String > params = new HashMap < > ( ) ; params . put ( STRING , STRING ) ; params . put ( STRING , STRING ) ; params . put ( STRING , dataConfig ) ; params . put ( STRING , STRING ) ; params . put ( STRING , STRING ) ; params . putAll ( extraParams ) ; NamedList l = new NamedList ( ) ; for ( Map . Entry < String , String > e : params . entrySet ( ) ) { l . add ( e . getKey ( ) , e . getValue ( ) ) ; } LocalSolrQueryRequest request = new LocalSolrQueryRequest ( h . getCore ( ) , l ) ; h . query ( STRING , request ) ; }
protected void helpSetDefaultValueEditText ( String defaultText ) { mEditTextForList . setText ( defaultText ) ; mEditTextForList . setSelection ( defaultText . length ( ) ) ; }
protected void helpSetDefaultValueEditText ( String defaultText ) { mEditTextForList . setText ( defaultText ) ; mEditTextForList . setSelection ( defaultText . length ( ) ) ; }
protected void helpSetDefaultValueEditText ( String defaultText ) { mEditTextForList . setText ( defaultText ) ; mEditTextForList . setSelection ( defaultText . length ( ) ) ; }
private void filterByContextTenant ( List < VirtualArrayRestRep > inputArrays , List < VirtualArrayRestRep > virtualArraysByTenant ) { Iterator < VirtualArrayRestRep > iterator = inputArrays . iterator ( ) ; while ( iterator . hasNext ( ) ) { VirtualArrayRestRep rep = iterator . next ( ) ; if ( ! contains ( rep . getId ( ) , virtualArraysByTenant ) ) { iterator . remove ( ) ; } } }
private void filterByContextTenant ( List < VirtualArrayRestRep > inputArrays , List < VirtualArrayRestRep > virtualArraysByTenant ) { Iterator < VirtualArrayRestRep > iterator = inputArrays . iterator ( ) ; while ( iterator . hasNext ( ) ) { VirtualArrayRestRep rep = iterator . next ( ) ; if ( ! contains ( rep . getId ( ) , virtualArraysByTenant ) ) { iterator . remove ( ) ; } } }
private void hamming ( int size ) { int start = ( windowFunction . length - size ) / _NUM ; int stop = ( windowFunction . length + size ) / _NUM ; double scale = _NUM / ( double ) size / _NUM ; double factor = twoPI / ( double ) size ; for ( int i = _NUM ; start < stop ; start ++ , i ++ ) windowFunction [ i ] = scale * ( _NUM / _NUM - _NUM / _NUM * Math . cos ( factor * i ) ) ; }
@ Override public boolean addEdge ( Number edge , Pair < ? extends Integer > endpoints , EdgeType edgeType ) { if ( endpoints == null ) throw new IllegalArgumentException ( STRING ) ; Integer v1 = endpoints . getFirst ( ) ; Integer v2 = endpoints . getSecond ( ) ; if ( v1 . equals ( v2 ) ) throw new IllegalArgumentException ( STRING ) ; else return super . addEdge ( edge , endpoints , edgeType ) ; }
@ Override public boolean addEdge ( Number edge , Pair < ? extends Integer > endpoints , EdgeType edgeType ) { if ( endpoints == null ) throw new IllegalArgumentException ( STRING ) ; Integer v1 = endpoints . getFirst ( ) ; Integer v2 = endpoints . getSecond ( ) ; if ( v1 . equals ( v2 ) ) throw new IllegalArgumentException ( STRING ) ; else return super . addEdge ( edge , endpoints , edgeType ) ; }
private void processVolumeSampleList ( List < Sample > sampleList , Map < String , Object > keyMap , Map < String , String > volFileMap , List < Stat > statsList ) { Iterator < Sample > itemItr = sampleList . iterator ( ) ; while ( itemItr . hasNext ( ) ) { Sample volSample = itemItr . next ( ) ; List < Item > volItems = volSample . getItem ( ) ; Iterator < Item > volItemsItr = volItems . iterator ( ) ; while ( volItemsItr . hasNext ( ) ) { Item volItem = volItemsItr . next ( ) ; if ( volFileMap . containsKey ( volItem . getVolume ( ) ) ) { String fileSystem = volFileMap . get ( volItem . getVolume ( ) ) ; if ( null != fileSystem ) { injectBWInOut ( fileSystem , keyMap , volItem , statsList ) ; } } } } }
static long makeId ( SnmpOid oid ) { long id = _NUM ; long [ ] arcs = oid . longValue ( _BOOL ) ; id |= arcs [ _NUM ] << _NUM ; id |= arcs [ _NUM ] << _NUM ; id |= arcs [ _NUM ] << _NUM ; id |= arcs [ _NUM ] << _NUM ; id |= arcs [ _NUM ] << _NUM ; id |= arcs [ _NUM ] << _NUM ; id |= arcs [ _NUM ] << _NUM ; id |= arcs [ _NUM ] ; return id ; }
public static void rotateM ( float [ ] m , int mOffset , float a , float x , float y , float z ) { synchronized ( TEMP_MATRIX_ARRAY ) { setRotateM ( TEMP_MATRIX_ARRAY , _NUM , a , x , y , z ) ; multiplyMM ( TEMP_MATRIX_ARRAY , _NUM , m , mOffset , TEMP_MATRIX_ARRAY , _NUM ) ; System . arraycopy ( TEMP_MATRIX_ARRAY , _NUM , m , mOffset , _NUM ) ; } }
public static void rotateM ( float [ ] m , int mOffset , float a , float x , float y , float z ) { synchronized ( TEMP_MATRIX_ARRAY ) { setRotateM ( TEMP_MATRIX_ARRAY , _NUM , a , x , y , z ) ; multiplyMM ( TEMP_MATRIX_ARRAY , _NUM , m , mOffset , TEMP_MATRIX_ARRAY , _NUM ) ; System . arraycopy ( TEMP_MATRIX_ARRAY , _NUM , m , mOffset , _NUM ) ; } }
public static void rotateM ( float [ ] m , int mOffset , float a , float x , float y , float z ) { synchronized ( TEMP_MATRIX_ARRAY ) { setRotateM ( TEMP_MATRIX_ARRAY , _NUM , a , x , y , z ) ; multiplyMM ( TEMP_MATRIX_ARRAY , _NUM , m , mOffset , TEMP_MATRIX_ARRAY , _NUM ) ; System . arraycopy ( TEMP_MATRIX_ARRAY , _NUM , m , mOffset , _NUM ) ; } }
public void putAll ( Map < ? extends K , ? extends V > m ) { for ( Map . Entry < ? extends K , ? extends V > e : m . entrySet ( ) ) put ( e . getKey ( ) , e . getValue ( ) ) ; }
public void putAll ( Map < ? extends K , ? extends V > m ) { for ( Map . Entry < ? extends K , ? extends V > e : m . entrySet ( ) ) put ( e . getKey ( ) , e . getValue ( ) ) ; }
private void sendBroadcastDownloadFinished ( DownloadFileOperation download , RemoteOperationResult downloadResult , String unlinkedFromRemotePath ) { Intent end = new Intent ( getDownloadFinishMessage ( ) ) ; end . putExtra ( EXTRA_DOWNLOAD_RESULT , downloadResult . isSuccess ( ) ) ; end . putExtra ( ACCOUNT_NAME , download . getAccount ( ) . name ) ; end . putExtra ( EXTRA_REMOTE_PATH , download . getRemotePath ( ) ) ; end . putExtra ( EXTRA_FILE_PATH , download . getSavePath ( ) ) ; if ( unlinkedFromRemotePath != null ) { end . putExtra ( EXTRA_LINKED_TO_PATH , unlinkedFromRemotePath ) ; } sendStickyBroadcast ( end ) ; }
private void sendBroadcastDownloadFinished ( DownloadFileOperation download , RemoteOperationResult downloadResult , String unlinkedFromRemotePath ) { Intent end = new Intent ( getDownloadFinishMessage ( ) ) ; end . putExtra ( EXTRA_DOWNLOAD_RESULT , downloadResult . isSuccess ( ) ) ; end . putExtra ( ACCOUNT_NAME , download . getAccount ( ) . name ) ; end . putExtra ( EXTRA_REMOTE_PATH , download . getRemotePath ( ) ) ; end . putExtra ( EXTRA_FILE_PATH , download . getSavePath ( ) ) ; if ( unlinkedFromRemotePath != null ) { end . putExtra ( EXTRA_LINKED_TO_PATH , unlinkedFromRemotePath ) ; } sendStickyBroadcast ( end ) ; }
private void sendBroadcastDownloadFinished ( DownloadFileOperation download , RemoteOperationResult downloadResult , String unlinkedFromRemotePath ) { Intent end = new Intent ( getDownloadFinishMessage ( ) ) ; end . putExtra ( EXTRA_DOWNLOAD_RESULT , downloadResult . isSuccess ( ) ) ; end . putExtra ( ACCOUNT_NAME , download . getAccount ( ) . name ) ; end . putExtra ( EXTRA_REMOTE_PATH , download . getRemotePath ( ) ) ; end . putExtra ( EXTRA_FILE_PATH , download . getSavePath ( ) ) ; if ( unlinkedFromRemotePath != null ) { end . putExtra ( EXTRA_LINKED_TO_PATH , unlinkedFromRemotePath ) ; } sendStickyBroadcast ( end ) ; }
private void sendBroadcastDownloadFinished ( DownloadFileOperation download , RemoteOperationResult downloadResult , String unlinkedFromRemotePath ) { Intent end = new Intent ( getDownloadFinishMessage ( ) ) ; end . putExtra ( EXTRA_DOWNLOAD_RESULT , downloadResult . isSuccess ( ) ) ; end . putExtra ( ACCOUNT_NAME , download . getAccount ( ) . name ) ; end . putExtra ( EXTRA_REMOTE_PATH , download . getRemotePath ( ) ) ; end . putExtra ( EXTRA_FILE_PATH , download . getSavePath ( ) ) ; if ( unlinkedFromRemotePath != null ) { end . putExtra ( EXTRA_LINKED_TO_PATH , unlinkedFromRemotePath ) ; } sendStickyBroadcast ( end ) ; }
public Point2D inverseTransform ( Point2D viewPoint ) { Point2D viewCenter = getViewCenter ( ) ; double viewRadius = getViewRadius ( ) ; double ratio = getRatio ( ) ; double dx = viewPoint . getX ( ) - viewCenter . getX ( ) ; double dy = viewPoint . getY ( ) - viewCenter . getY ( ) ; dx *= ratio ; Point2D pointFromCenter = new Point2D . Double ( dx , dy ) ; PolarPoint polar = PolarPoint . cartesianToPolar ( pointFromCenter ) ; double radius = polar . getRadius ( ) ; if ( radius > viewRadius ) return delegate . inverseTransform ( viewPoint ) ; double mag = magnification ; radius /= mag ; polar . setRadius ( radius ) ; Point2D projectedPoint = PolarPoint . polarToCartesian ( polar ) ; projectedPoint . setLocation ( projectedPoint . getX ( ) / ratio , projectedPoint . getY ( ) ) ; Point2D translatedBack = new Point2D . Double ( projectedPoint . getX ( ) + viewCenter . getX ( ) , projectedPoint . getY ( ) + viewCenter . getY ( ) ) ; return delegate . inverseTransform ( translatedBack ) ; }
public BitArray resize ( long size ) { bytes . resize ( Math . max ( size / _NUM + _NUM , _NUM ) ) ; this . size = size ; return this ; }
public static File toFile ( File parent , String path ) { return new File ( parent , path . replace ( FILE_ANTI_SEPERATOR , FILE_SEPERATOR ) ) ; }
public static int parseInt ( java . lang . String s ) throws java . lang . NumberFormatException { return parseInt ( s , _NUM ) ; }
long cleanup ( long now ) { int inUseConnectionCount = _NUM ; int idleConnectionCount = _NUM ; RealConnection longestIdleConnection = null ; long longestIdleDurationNs = Long . MIN_VALUE ; synchronized ( this ) { for ( Iterator < RealConnection > i = connections . iterator ( ) ; i . hasNext ( ) ; ) { RealConnection connection = i . next ( ) ; if ( pruneAndGetAllocationCount ( connection , now ) > _NUM ) { inUseConnectionCount ++ ; continue ; } idleConnectionCount ++ ; long idleDurationNs = now - connection . idleAtNanos ; if ( idleDurationNs > longestIdleDurationNs ) { longestIdleDurationNs = idleDurationNs ; longestIdleConnection = connection ; } } if ( longestIdleDurationNs >= this . keepAliveDurationNs || idleConnectionCount > this . maxIdleConnections ) { connections . remove ( longestIdleConnection ) ; } else if ( idleConnectionCount > _NUM ) { return keepAliveDurationNs - longestIdleDurationNs ; } else if ( inUseConnectionCount > _NUM ) { return keepAliveDurationNs ; } else { cleanupRunning = _BOOL ; return - _NUM ; } } closeQuietly ( longestIdleConnection . socket ( ) ) ; return _NUM ; }
long cleanup ( long now ) { int inUseConnectionCount = _NUM ; int idleConnectionCount = _NUM ; RealConnection longestIdleConnection = null ; long longestIdleDurationNs = Long . MIN_VALUE ; synchronized ( this ) { for ( Iterator < RealConnection > i = connections . iterator ( ) ; i . hasNext ( ) ; ) { RealConnection connection = i . next ( ) ; if ( pruneAndGetAllocationCount ( connection , now ) > _NUM ) { inUseConnectionCount ++ ; continue ; } idleConnectionCount ++ ; long idleDurationNs = now - connection . idleAtNanos ; if ( idleDurationNs > longestIdleDurationNs ) { longestIdleDurationNs = idleDurationNs ; longestIdleConnection = connection ; } } if ( longestIdleDurationNs >= this . keepAliveDurationNs || idleConnectionCount > this . maxIdleConnections ) { connections . remove ( longestIdleConnection ) ; } else if ( idleConnectionCount > _NUM ) { return keepAliveDurationNs - longestIdleDurationNs ; } else if ( inUseConnectionCount > _NUM ) { return keepAliveDurationNs ; } else { cleanupRunning = _BOOL ; return - _NUM ; } } closeQuietly ( longestIdleConnection . socket ( ) ) ; return _NUM ; }
private Region findRegion ( int size , Packing packing ) { validate ( ! VALIDATING || Integer . bitCount ( size ) == _NUM ) ; Node < Region > currentNode = getRoot ( ) ; Region currentRegion = currentNode . getPayload ( ) ; if ( currentRegion == null || ( currentRegion . available ( ) & size ) == _NUM ) { return null ; } else { while ( _BOOL ) { Node < Region > prefered = packing . prefered ( currentNode ) ; Region preferedRegion = prefered . getPayload ( ) ; if ( preferedRegion != null && ( preferedRegion . available ( ) & size ) != _NUM ) { currentNode = prefered ; currentRegion = preferedRegion ; } else if ( ( currentRegion . availableHere ( ) & size ) != _NUM ) { return packing . slice ( currentRegion , size ) ; } else { Node < Region > fallback = packing . fallback ( currentNode ) ; Region fallbackRegion = fallback . getPayload ( ) ; if ( fallbackRegion != null && ( fallbackRegion . available ( ) & size ) != _NUM ) { currentNode = fallback ; currentRegion = fallbackRegion ; } else { throw new AssertionError ( ) ; } } } } }
public static TypeInstanceDialog instantiateCreateTypeInstanceDialog ( final JFrame owner , final TypeManager typeManager , final Section section , final Long offset ) { return new TypeInstanceDialog ( owner , STRING , new TypeListModel ( typeManager . getTypes ( ) , new TypeListModel . PrototypesFilter ( ) ) , null , section , offset ) ; }
public static TypeInstanceDialog instantiateCreateTypeInstanceDialog ( final JFrame owner , final TypeManager typeManager , final Section section , final Long offset ) { return new TypeInstanceDialog ( owner , STRING , new TypeListModel ( typeManager . getTypes ( ) , new TypeListModel . PrototypesFilter ( ) ) , null , section , offset ) ; }
public static TypeInstanceDialog instantiateCreateTypeInstanceDialog ( final JFrame owner , final TypeManager typeManager , final Section section , final Long offset ) { return new TypeInstanceDialog ( owner , STRING , new TypeListModel ( typeManager . getTypes ( ) , new TypeListModel . PrototypesFilter ( ) ) , null , section , offset ) ; }
public static TypeInstanceDialog instantiateCreateTypeInstanceDialog ( final JFrame owner , final TypeManager typeManager , final Section section , final Long offset ) { return new TypeInstanceDialog ( owner , STRING , new TypeListModel ( typeManager . getTypes ( ) , new TypeListModel . PrototypesFilter ( ) ) , null , section , offset ) ; }
public static TypeInstanceDialog instantiateCreateTypeInstanceDialog ( final JFrame owner , final TypeManager typeManager , final Section section , final Long offset ) { return new TypeInstanceDialog ( owner , STRING , new TypeListModel ( typeManager . getTypes ( ) , new TypeListModel . PrototypesFilter ( ) ) , null , section , offset ) ; }
public void addCompareCol ( int sortCol , Comparator comparator ) { sortCols . add ( new ArrayElementComparator ( sortCol , comparator ) ) ; }
@ RequestMapping ( value = STRING , method = RequestMethod . POST , produces = MediaType . APPLICATION_JSON_VALUE ) @ Timed public ResponseEntity < ? > changePassword ( @ RequestBody PasswordChangeDTO passwordChange ) { if ( StringUtils . isEmpty ( passwordChange . getNewPassword ( ) ) || StringUtils . isEmpty ( passwordChange . getOldPassword ( ) ) ) { return new ResponseEntity < > ( HttpStatus . FORBIDDEN ) ; } if ( userService . checkPassword ( passwordChange . getOldPassword ( ) ) ) { userService . changePassword ( passwordChange . getNewPassword ( ) ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } else { return new ResponseEntity < > ( HttpStatus . FORBIDDEN ) ; } }
public static void closeGlobal ( ) { ArrayList < EnvLoaderListener > listeners ; listeners = new ArrayList < > ( ) ; listeners . addAll ( _globalLoaderListeners ) ; _globalLoaderListeners . clear ( ) ; for ( int i = _NUM ; i < listeners . size ( ) ; i ++ ) { EnvLoaderListener listener = listeners . get ( i ) ; listener . classLoaderDestroy ( null ) ; } }
@ Override protected void tearDown ( ) { m_Classifier = null ; m_OptionTester = null ; File file = new File ( MODEL_FILENAME ) ; if ( file . exists ( ) ) { file . delete ( ) ; } }
private String generatePortName ( ) { StringBuffer portName = new StringBuffer ( STRING ) ; int portCount = allStoragePortsList . size ( ) ; portName = portName . append ( String . valueOf ( portCount - _NUM ) ) ; return portName . toString ( ) ; }
private String generatePortName ( ) { StringBuffer portName = new StringBuffer ( STRING ) ; int portCount = allStoragePortsList . size ( ) ; portName = portName . append ( String . valueOf ( portCount - _NUM ) ) ; return portName . toString ( ) ; }
public String ( byte [ ] bytes , int off , int len ) { this ( bytesToChars ( bytes , off , len , STRING ) ) ; }
public String ( byte [ ] bytes , int off , int len ) { this ( bytesToChars ( bytes , off , len , STRING ) ) ; }
public String ( byte [ ] bytes , int off , int len ) { this ( bytesToChars ( bytes , off , len , STRING ) ) ; }
public abstract ServletRequest doBefore ( final ServletRequest servletRequest , final ServletResponse servletResponse ) throws IOException , ServletException ;
public abstract ServletRequest doBefore ( final ServletRequest servletRequest , final ServletResponse servletResponse ) throws IOException , ServletException ;
@ Override public void flush ( ) throws IOException { flushBytes ( _BOOL ) ; }
@ Override public void flush ( ) throws IOException { flushBytes ( _BOOL ) ; }
@ Override public void flush ( ) throws IOException { flushBytes ( _BOOL ) ; }
public static void addRecentFile ( File file ) { addRecentFile ( file . getPath ( ) ) ; }
public static int generarMarcas ( int [ ] bitsActivos ) { int result = _NUM ; for ( int i = _NUM ; i < bitsActivos . length ; i ++ ) { result += ( int ) Math . pow ( _NUM , bitsActivos [ i ] ) ; } return result ; }
private static State next ( final InputStream stream , final State state , final ByteArrayOutputStream line ) throws IOException { final int next = stream . read ( ) ; if ( next == - _NUM ) { throw new IOException ( STRING ) ; } final State result ; switch ( state ) { case NORMAL : result = nextNormal ( state , line , next ) ; break ; case R : if ( next == STRING ) { result = State . END ; } else { throw new IOException ( String . format ( STRING , STRING , STRING ) ) ; } break ; case QUOTED_STRING : result = nextQuoted ( stream , state , line , next ) ; break ; default : throw new IllegalStateException ( STRING ) ; } return result ; }
public boolean write ( byte [ ] audioData ) { return write ( audioData , _NUM , audioData . length ) ; }
public static StoredCellProbsObs serializableInstance ( ) { return new StoredCellProbsObs ( new ArrayList < Node > ( ) ) ; }
public static StoredCellProbsObs serializableInstance ( ) { return new StoredCellProbsObs ( new ArrayList < Node > ( ) ) ; }
@ Override public boolean hasMoreElements ( ) { return ( ( instructionOperands . hasMoreElements ( ) ) || ( ( heapOperands != null ) && ( curHeapOperand < heapOperands . length ) ) || ( ( implicitDefs != null ) && ( implicitDefs . hasMoreElements ( ) ) ) ) ; }
public long roundTripTime ( ) throws InterruptedException { latch . await ( ) ; return received - sent ; }
public long roundTripTime ( ) throws InterruptedException { latch . await ( ) ; return received - sent ; }
public void stateChanged ( ChangeEvent e ) { if ( e == null ) { return ; } if ( myBar != null ) { Object newModelValue = myBar . getValue ( ) ; firePropertyChange ( ACCESSIBLE_VALUE_PROPERTY , oldModelValue , newModelValue ) ; oldModelValue = newModelValue ; } }
public void stateChanged ( ChangeEvent e ) { if ( e == null ) { return ; } if ( myBar != null ) { Object newModelValue = myBar . getValue ( ) ; firePropertyChange ( ACCESSIBLE_VALUE_PROPERTY , oldModelValue , newModelValue ) ; oldModelValue = newModelValue ; } }
public void stateChanged ( ChangeEvent e ) { if ( e == null ) { return ; } if ( myBar != null ) { Object newModelValue = myBar . getValue ( ) ; firePropertyChange ( ACCESSIBLE_VALUE_PROPERTY , oldModelValue , newModelValue ) ; oldModelValue = newModelValue ; } }
@ Override public List < Proxy > select ( URI uri ) { ArrayList < Proxy > proxies = new ArrayList < Proxy > ( ) ; proxies . add ( Proxy . NO_PROXY ) ; return proxies ; }
private void clearAnswer ( QuestionWidget qw ) { if ( qw . getAnswer ( ) != null ) { qw . clearAnswer ( ) ; } }
private void clearAnswer ( QuestionWidget qw ) { if ( qw . getAnswer ( ) != null ) { qw . clearAnswer ( ) ; } }
public static byte [ ] packHeader ( byte cmd , long pkg_len , byte errno ) throws UnsupportedEncodingException { byte [ ] header ; byte [ ] hex_len ; header = new byte [ FDFS_PROTO_PKG_LEN_SIZE + _NUM ] ; Arrays . fill ( header , ( byte ) _NUM ) ; hex_len = ProtoCommon . long2buff ( pkg_len ) ; System . arraycopy ( hex_len , _NUM , header , _NUM , hex_len . length ) ; header [ PROTO_HEADER_CMD_INDEX ] = cmd ; header [ PROTO_HEADER_STATUS_INDEX ] = errno ; return header ; }
public static void insertEmptyData ( ByteBuffer buffer , int len ) { byte [ ] buf = buffer . array ( ) ; int pos = buffer . position ( ) ; int limit = buffer . limit ( ) ; System . arraycopy ( buf , pos , buf , pos + len , limit - pos ) ; Arrays . fill ( buf , pos , pos + len , ( byte ) _NUM ) ; buffer . limit ( limit + len ) ; }
public static void insertEmptyData ( ByteBuffer buffer , int len ) { byte [ ] buf = buffer . array ( ) ; int pos = buffer . position ( ) ; int limit = buffer . limit ( ) ; System . arraycopy ( buf , pos , buf , pos + len , limit - pos ) ; Arrays . fill ( buf , pos , pos + len , ( byte ) _NUM ) ; buffer . limit ( limit + len ) ; }
public void removeChangeListener ( ChangeListener cl ) { m_listeners . remove ( cl ) ; }
private void cleanStatic ( MethodNode method ) { }
protected abstract GuacamoleTunnel createTunnel ( Session session , EndpointConfig config ) throws GuacamoleException ;
protected abstract GuacamoleTunnel createTunnel ( Session session , EndpointConfig config ) throws GuacamoleException ;
private void checkRequiredFields ( SimpleObject simpleObject , String [ ] requiredFields ) { List < String > missingFields = new ArrayList < > ( ) ; for ( String requiredField : requiredFields ) { if ( ! simpleObject . containsKey ( requiredField ) ) { missingFields . add ( requiredField ) ; } } if ( ! missingFields . isEmpty ( ) ) { throw new InvalidObjectDataException ( STRING + StringUtils . join ( missingFields , STRING ) ) ; } }
private void checkRequiredFields ( SimpleObject simpleObject , String [ ] requiredFields ) { List < String > missingFields = new ArrayList < > ( ) ; for ( String requiredField : requiredFields ) { if ( ! simpleObject . containsKey ( requiredField ) ) { missingFields . add ( requiredField ) ; } } if ( ! missingFields . isEmpty ( ) ) { throw new InvalidObjectDataException ( STRING + StringUtils . join ( missingFields , STRING ) ) ; } }
public void reset ( ) { techTree . checkSubTree ( techTree . getPathForRow ( _NUM ) , _BOOL ) ; }
public boolean write ( Type type , Object value , NodeMap node ) { Class actual = value . getClass ( ) ; Class expect = type . getType ( ) ; Class real = actual ; if ( actual . isArray ( ) ) { real = writeArray ( actual , value , node ) ; } if ( actual != expect ) { node . put ( label , real . getName ( ) ) ; } return writeReference ( value , node ) ; }
public boolean write ( Type type , Object value , NodeMap node ) { Class actual = value . getClass ( ) ; Class expect = type . getType ( ) ; Class real = actual ; if ( actual . isArray ( ) ) { real = writeArray ( actual , value , node ) ; } if ( actual != expect ) { node . put ( label , real . getName ( ) ) ; } return writeReference ( value , node ) ; }
public boolean write ( Type type , Object value , NodeMap node ) { Class actual = value . getClass ( ) ; Class expect = type . getType ( ) ; Class real = actual ; if ( actual . isArray ( ) ) { real = writeArray ( actual , value , node ) ; } if ( actual != expect ) { node . put ( label , real . getName ( ) ) ; } return writeReference ( value , node ) ; }
public boolean write ( Type type , Object value , NodeMap node ) { Class actual = value . getClass ( ) ; Class expect = type . getType ( ) ; Class real = actual ; if ( actual . isArray ( ) ) { real = writeArray ( actual , value , node ) ; } if ( actual != expect ) { node . put ( label , real . getName ( ) ) ; } return writeReference ( value , node ) ; }
public static < T , U extends Closeable > T withCloseable ( U self , @ ClosureParams ( value = FirstParam . class ) Closure < T > action ) throws IOException { try { T result = action . call ( self ) ; Closeable temp = self ; self = null ; temp . close ( ) ; return result ; } finally { DefaultGroovyMethodsSupport . closeWithWarning ( self ) ; } }
public static < T , U extends Closeable > T withCloseable ( U self , @ ClosureParams ( value = FirstParam . class ) Closure < T > action ) throws IOException { try { T result = action . call ( self ) ; Closeable temp = self ; self = null ; temp . close ( ) ; return result ; } finally { DefaultGroovyMethodsSupport . closeWithWarning ( self ) ; } }
public static void validateCompositeData ( CompositeData cd ) { if ( cd == null ) { throw new NullPointerException ( STRING ) ; } if ( ! isTypeMatched ( getBaseGcInfoCompositeType ( ) , cd . getCompositeType ( ) ) ) { throw new IllegalArgumentException ( STRING ) ; } }
public static void validateCompositeData ( CompositeData cd ) { if ( cd == null ) { throw new NullPointerException ( STRING ) ; } if ( ! isTypeMatched ( getBaseGcInfoCompositeType ( ) , cd . getCompositeType ( ) ) ) { throw new IllegalArgumentException ( STRING ) ; } }
public static void validateCompositeData ( CompositeData cd ) { if ( cd == null ) { throw new NullPointerException ( STRING ) ; } if ( ! isTypeMatched ( getBaseGcInfoCompositeType ( ) , cd . getCompositeType ( ) ) ) { throw new IllegalArgumentException ( STRING ) ; } }
public static void validateCompositeData ( CompositeData cd ) { if ( cd == null ) { throw new NullPointerException ( STRING ) ; } if ( ! isTypeMatched ( getBaseGcInfoCompositeType ( ) , cd . getCompositeType ( ) ) ) { throw new IllegalArgumentException ( STRING ) ; } }
protected void doAddUser ( User user ) throws UsersRepositoryException { Connection conn = null ; PreparedStatement addUserStatement = null ; try { conn = openConnection ( ) ; addUserStatement = conn . prepareStatement ( m_insertUserSql ) ; setUserForInsertStatement ( user , addUserStatement ) ; addUserStatement . execute ( ) ; } catch ( SQLException sqlExc ) { sqlExc . printStackTrace ( ) ; throw new UsersRepositoryException ( STRING , sqlExc ) ; } finally { theJDBCUtil . closeJDBCStatement ( addUserStatement ) ; theJDBCUtil . closeJDBCConnection ( conn ) ; } }
public void visit ( BnfVisitor visitor , String s ) { this . syntax = s ; tokens = tokenize ( ) ; index = _NUM ; Rule rule = parseRule ( ) ; rule . setLinks ( ruleMap ) ; rule . accept ( visitor ) ; }
public void visit ( BnfVisitor visitor , String s ) { this . syntax = s ; tokens = tokenize ( ) ; index = _NUM ; Rule rule = parseRule ( ) ; rule . setLinks ( ruleMap ) ; rule . accept ( visitor ) ; }
public void visit ( BnfVisitor visitor , String s ) { this . syntax = s ; tokens = tokenize ( ) ; index = _NUM ; Rule rule = parseRule ( ) ; rule . setLinks ( ruleMap ) ; rule . accept ( visitor ) ; }
public static < T > Set < T > toSet ( T obj1 , T obj2 , T obj3 ) { Set < T > theSet = new LinkedHashSet < T > ( ) ; theSet . add ( obj1 ) ; theSet . add ( obj2 ) ; theSet . add ( obj3 ) ; return theSet ; }
public void clear ( ) { final Object [ ] items = this . items ; final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { int k = count ; if ( k > _NUM ) { final int putIndex = this . putIndex ; int i = takeIndex ; do { items [ i ] = null ; } while ( ( i = inc ( i ) ) != putIndex ) ; takeIndex = putIndex ; count = _NUM ; if ( itrs != null ) itrs . queueIsEmpty ( ) ; for ( ; k > _NUM && lock . hasWaiters ( notFull ) ; k -- ) notFull . signal ( ) ; } } finally { lock . unlock ( ) ; } }
public void clear ( ) { final Object [ ] items = this . items ; final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { int k = count ; if ( k > _NUM ) { final int putIndex = this . putIndex ; int i = takeIndex ; do { items [ i ] = null ; } while ( ( i = inc ( i ) ) != putIndex ) ; takeIndex = putIndex ; count = _NUM ; if ( itrs != null ) itrs . queueIsEmpty ( ) ; for ( ; k > _NUM && lock . hasWaiters ( notFull ) ; k -- ) notFull . signal ( ) ; } } finally { lock . unlock ( ) ; } }
protected void runDBSCAN ( Relation < O > relation , RangeQuery < O > rangeQuery ) { final int size = relation . size ( ) ; FiniteProgress objprog = LOG . isVerbose ( ) ? new FiniteProgress ( STRING , size , LOG ) : null ; IndefiniteProgress clusprog = LOG . isVerbose ( ) ? new IndefiniteProgress ( STRING , LOG ) : null ; processedIDs = DBIDUtil . newHashSet ( size ) ; ArrayModifiableDBIDs seeds = DBIDUtil . newArray ( ) ; for ( DBIDIter iditer = relation . iterDBIDs ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { if ( ! processedIDs . contains ( iditer ) ) { expandCluster ( relation , rangeQuery , iditer , seeds , objprog , clusprog ) ; } if ( objprog != null && clusprog != null ) { objprog . setProcessed ( processedIDs . size ( ) , LOG ) ; clusprog . setProcessed ( resultList . size ( ) , LOG ) ; } if ( processedIDs . size ( ) == size ) { break ; } } LOG . ensureCompleted ( objprog ) ; LOG . setCompleted ( clusprog ) ; }
public void doSearch ( ) { doRefresh ( ) ; }
public void doSearch ( ) { doRefresh ( ) ; }
public void testComputeZNaN ( ) { Geometry linearGeom = read ( STRING ) ; LengthIndexedLine indexedLine = new LengthIndexedLine ( linearGeom ) ; double projIndex = indexedLine . project ( new Coordinate ( _NUM , _NUM ) ) ; Coordinate projPt = indexedLine . extractPoint ( projIndex ) ; assertTrue ( Double . isNaN ( projPt . z ) ) ; }
public static String normalize ( String value ) { if ( value == null ) return value ; value = value . trim ( ) ; if ( value . indexOf ( STRING ) == - _NUM ) return value ; boolean space = _BOOL ; int len = value . length ( ) ; StringBuffer b = new StringBuffer ( len ) ; for ( int i = _NUM ; i < len ; i ++ ) { char v = value . charAt ( i ) ; if ( v == STRING ) { if ( ! space ) b . append ( v ) ; space = _BOOL ; } else { b . append ( v ) ; space = _BOOL ; } } return b . toString ( ) ; }
public static String normalize ( String value ) { if ( value == null ) return value ; value = value . trim ( ) ; if ( value . indexOf ( STRING ) == - _NUM ) return value ; boolean space = _BOOL ; int len = value . length ( ) ; StringBuffer b = new StringBuffer ( len ) ; for ( int i = _NUM ; i < len ; i ++ ) { char v = value . charAt ( i ) ; if ( v == STRING ) { if ( ! space ) b . append ( v ) ; space = _BOOL ; } else { b . append ( v ) ; space = _BOOL ; } } return b . toString ( ) ; }
@ Override String debugDecodeSortKeyBytes ( byte [ ] bytes , int index , int length ) { StringBuilder sb = new StringBuilder ( ) ; Util . bytesToHex ( sb , bytes , index , length ) ; return sb . toString ( ) ; }
public void exportAsKML ( XMLStreamWriter xmlWriter ) throws IOException , XMLStreamException { }
AutoDetectDataType switchType ( Object obj ) { int typeId = getTypeId ( obj ) ; AutoDetectDataType l = last ; if ( typeId != l . typeId ) { last = l = newType ( typeId ) ; } return l ; }
public CacheLoaderWithDeclarables ( ) { this . props = new Properties ( ) ; props . put ( STRING , STRING ) ; props . put ( STRING , new TestDeclarable ( ) ) ; }
public CacheLoaderWithDeclarables ( ) { this . props = new Properties ( ) ; props . put ( STRING , STRING ) ; props . put ( STRING , new TestDeclarable ( ) ) ; }
public void reloadRosterFile ( ) { _list . clear ( ) ; try { _instance . readFile ( defaultNceConsistRosterFilename ( ) ) ; } catch ( Exception e ) { log . error ( STRING + e ) ; } }
public void reloadRosterFile ( ) { _list . clear ( ) ; try { _instance . readFile ( defaultNceConsistRosterFilename ( ) ) ; } catch ( Exception e ) { log . error ( STRING + e ) ; } }
public void reloadRosterFile ( ) { _list . clear ( ) ; try { _instance . readFile ( defaultNceConsistRosterFilename ( ) ) ; } catch ( Exception e ) { log . error ( STRING + e ) ; } }
public void reloadRosterFile ( ) { _list . clear ( ) ; try { _instance . readFile ( defaultNceConsistRosterFilename ( ) ) ; } catch ( Exception e ) { log . error ( STRING + e ) ; } }
private boolean hasWrappedMethodsForClass ( SootClass parentClass , boolean newTaints , boolean killTaints , boolean excludeTaints ) { if ( newTaints && classList . containsKey ( parentClass . getName ( ) ) ) return _BOOL ; if ( excludeTaints && excludeList . containsKey ( parentClass . getName ( ) ) ) return _BOOL ; if ( killTaints && killList . containsKey ( parentClass . getName ( ) ) ) return _BOOL ; return _BOOL ; }
private boolean hasWrappedMethodsForClass ( SootClass parentClass , boolean newTaints , boolean killTaints , boolean excludeTaints ) { if ( newTaints && classList . containsKey ( parentClass . getName ( ) ) ) return _BOOL ; if ( excludeTaints && excludeList . containsKey ( parentClass . getName ( ) ) ) return _BOOL ; if ( killTaints && killList . containsKey ( parentClass . getName ( ) ) ) return _BOOL ; return _BOOL ; }
@ Bean public DefaultJmsListenerContainerFactory jmsListenerContainerFactory ( ConnectionFactory jmsConnectionFactory ) { DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory ( ) ; factory . setConnectionFactory ( jmsConnectionFactory ) ; factory . setDestinationResolver ( herdDestinationResolver ) ; factory . setConcurrency ( configurationHelper . getProperty ( ConfigurationValue . JMS_LISTENER_POOL_CONCURRENCY_LIMITS ) ) ; return factory ; }
@ Bean public DefaultJmsListenerContainerFactory jmsListenerContainerFactory ( ConnectionFactory jmsConnectionFactory ) { DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory ( ) ; factory . setConnectionFactory ( jmsConnectionFactory ) ; factory . setDestinationResolver ( herdDestinationResolver ) ; factory . setConcurrency ( configurationHelper . getProperty ( ConfigurationValue . JMS_LISTENER_POOL_CONCURRENCY_LIMITS ) ) ; return factory ; }
@ Bean public DefaultJmsListenerContainerFactory jmsListenerContainerFactory ( ConnectionFactory jmsConnectionFactory ) { DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory ( ) ; factory . setConnectionFactory ( jmsConnectionFactory ) ; factory . setDestinationResolver ( herdDestinationResolver ) ; factory . setConcurrency ( configurationHelper . getProperty ( ConfigurationValue . JMS_LISTENER_POOL_CONCURRENCY_LIMITS ) ) ; return factory ; }
public void buttonClicked ( ActionEvent e ) ;
public DViewCertificateFingerprint ( JFrame parent , byte [ ] encodedCertificate , DigestType fingerprintAlg ) { super ( parent , Dialog . ModalityType . DOCUMENT_MODAL ) ; this . encodedCertificate = encodedCertificate ; this . fingerprintAlg = fingerprintAlg ; initComponents ( ) ; }
public static int convertSpToPx ( int spSize ) { return Math . round ( ( float ) spSize / getDisplayDensity4Fonts ( ) ) ; }
public static int convertSpToPx ( int spSize ) { return Math . round ( ( float ) spSize / getDisplayDensity4Fonts ( ) ) ; }
public static int convertSpToPx ( int spSize ) { return Math . round ( ( float ) spSize / getDisplayDensity4Fonts ( ) ) ; }
public static int convertSpToPx ( int spSize ) { return Math . round ( ( float ) spSize / getDisplayDensity4Fonts ( ) ) ; }
private static String extractTopItem ( String searchString , String schema , int startIdx ) { String extracted = null ; int propIdx = schema . indexOf ( STRING , startIdx ) ; if ( propIdx == - _NUM ) { propIdx = Integer . MAX_VALUE ; } int idIdx = schema . indexOf ( STRING + searchString + STRING , startIdx ) ; int secondIdIdx = schema . indexOf ( STRING + searchString + STRING , idIdx + _NUM ) ; if ( secondIdIdx != - _NUM && propIdx > secondIdIdx ) { idIdx = secondIdIdx ; } if ( idIdx != - _NUM && propIdx > idIdx ) { int valueStartIdx = schema . indexOf ( STRING , idIdx + ( searchString . length ( ) + _NUM ) ) ; int valueEndIdx = schema . indexOf ( STRING , valueStartIdx + _NUM ) ; extracted = schema . substring ( valueStartIdx + _NUM , valueEndIdx ) ; } return extracted ; }
public int read ( char ch [ ] , int offset , int length ) throws IOException { if ( length > fBuffer . length ) { length = fBuffer . length ; } int count = fInputStream . read ( fBuffer , _NUM , length ) ; for ( int i = _NUM ; i < count ; i ++ ) { int b0 = fBuffer [ i ] ; if ( b0 < _NUM ) { throw new IOException ( Localizer . getMessage ( STRING , Integer . toString ( b0 ) ) ) ; } ch [ offset + i ] = ( char ) b0 ; } return count ; }
public int read ( char ch [ ] , int offset , int length ) throws IOException { if ( length > fBuffer . length ) { length = fBuffer . length ; } int count = fInputStream . read ( fBuffer , _NUM , length ) ; for ( int i = _NUM ; i < count ; i ++ ) { int b0 = fBuffer [ i ] ; if ( b0 < _NUM ) { throw new IOException ( Localizer . getMessage ( STRING , Integer . toString ( b0 ) ) ) ; } ch [ offset + i ] = ( char ) b0 ; } return count ; }
public boolean removeArgument ( String arg ) { return arguments . remove ( arg ) ; }
private static String replaceChars ( String str ) { StringBuffer buf = new StringBuffer ( str ) ; int length = buf . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char currentChar = buf . charAt ( i ) ; if ( currentChar == STRING ) { buf . setCharAt ( i , STRING ) ; buf . insert ( i + _NUM , STRING ) ; length = length + _NUM ; i = i + _NUM ; } else if ( currentChar == STRING ) { buf . setCharAt ( i , STRING ) ; } } return buf . toString ( ) ; }
private static String replaceChars ( String str ) { StringBuffer buf = new StringBuffer ( str ) ; int length = buf . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char currentChar = buf . charAt ( i ) ; if ( currentChar == STRING ) { buf . setCharAt ( i , STRING ) ; buf . insert ( i + _NUM , STRING ) ; length = length + _NUM ; i = i + _NUM ; } else if ( currentChar == STRING ) { buf . setCharAt ( i , STRING ) ; } } return buf . toString ( ) ; }
private static String replaceChars ( String str ) { StringBuffer buf = new StringBuffer ( str ) ; int length = buf . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char currentChar = buf . charAt ( i ) ; if ( currentChar == STRING ) { buf . setCharAt ( i , STRING ) ; buf . insert ( i + _NUM , STRING ) ; length = length + _NUM ; i = i + _NUM ; } else if ( currentChar == STRING ) { buf . setCharAt ( i , STRING ) ; } } return buf . toString ( ) ; }
public boolean addMouseListener ( final MapMouseListener listener ) { if ( listener == null ) { throw new IllegalArgumentException ( STRING ) ; } return listeners . add ( listener ) ; }
private static int findClosest ( int desiredFactor , Set < Integer > factors ) { int bestFactor = _NUM ; int bestDelta = desiredFactor ; for ( Integer factor : factors ) { int testDelta = Math . abs ( desiredFactor - factor ) ; if ( testDelta < bestDelta ) { bestDelta = testDelta ; bestFactor = factor ; } } return bestFactor ; }
public int lastIndexOf ( String string ) { return lastIndexOf ( string , length ( ) ) ; }
public int lastIndexOf ( String string ) { return lastIndexOf ( string , length ( ) ) ; }
public StrokeCellRenderer ( ) { panel = new JPanel ( ) ; panel . setOpaque ( _BOOL ) ; }
public boolean areOnEquivalentHost ( InternalDistributedMember member1 , InternalDistributedMember member2 ) { Set < InetAddress > equivalents1 = getEquivalents ( member1 . getInetAddress ( ) ) ; return equivalents1 . contains ( member2 . getInetAddress ( ) ) ; }
@ Override @ Deprecated public Condition duplicate ( ) { return this ; }
@ Override @ Deprecated public Condition duplicate ( ) { return this ; }
public void initUnitTurn ( Entity unit , IGame game ) { }
public void initUnitTurn ( Entity unit , IGame game ) { }
public void initUnitTurn ( Entity unit , IGame game ) { }
public void initUnitTurn ( Entity unit , IGame game ) { }
public void initUnitTurn ( Entity unit , IGame game ) { }
@ NotNull private FlutterDaemonController controllerFor ( String projectDir , String deviceId ) { synchronized ( myLock ) { FlutterDaemonController newController = new FlutterDaemonController ( projectDir ) ; myControllers . add ( newController ) ; newController . addListener ( myListener ) ; return newController ; } }
@ NotNull private FlutterDaemonController controllerFor ( String projectDir , String deviceId ) { synchronized ( myLock ) { FlutterDaemonController newController = new FlutterDaemonController ( projectDir ) ; myControllers . add ( newController ) ; newController . addListener ( myListener ) ; return newController ; } }
@ NotNull private FlutterDaemonController controllerFor ( String projectDir , String deviceId ) { synchronized ( myLock ) { FlutterDaemonController newController = new FlutterDaemonController ( projectDir ) ; myControllers . add ( newController ) ; newController . addListener ( myListener ) ; return newController ; } }
@ NotNull private FlutterDaemonController controllerFor ( String projectDir , String deviceId ) { synchronized ( myLock ) { FlutterDaemonController newController = new FlutterDaemonController ( projectDir ) ; myControllers . add ( newController ) ; newController . addListener ( myListener ) ; return newController ; } }
@ NotNull private FlutterDaemonController controllerFor ( String projectDir , String deviceId ) { synchronized ( myLock ) { FlutterDaemonController newController = new FlutterDaemonController ( projectDir ) ; myControllers . add ( newController ) ; newController . addListener ( myListener ) ; return newController ; } }
public byte byteAt ( int index ) { bb . position ( index ) ; return bb . get ( ) ; }
public static OutputStream encrypt ( OutputStream unencryptedOutputStream , char [ ] password ) throws EncryptionException , IOException { OutputStream encryptedOutputStream = null ; PBEKeySpec pbeKeySpec = new PBEKeySpec ( password ) ; PBEParameterSpec pbeParameterSpec = new PBEParameterSpec ( SALT , ITERATION_COUNT ) ; try { SecretKeyFactory secretKeyFactory = SecretKeyFactory . getInstance ( ENCRYPTION_ALGORITHM , CRYPTOPROVIDER ) ; SecretKey pbeKey = secretKeyFactory . generateSecret ( pbeKeySpec ) ; Cipher cipher = Cipher . getInstance ( ENCRYPTION_ALGORITHM , CRYPTOPROVIDER ) ; cipher . init ( Cipher . ENCRYPT_MODE , pbeKey , pbeParameterSpec ) ; encryptedOutputStream = new CipherOutputStream ( unencryptedOutputStream , cipher ) ; } catch ( GeneralSecurityException e ) { throw new EncryptionException ( STRING , e ) ; } return encryptedOutputStream ; }
public String service ( String serviceSpec , String serviceCmd ) throws Exception { return executeExtension ( ResourceType . SERVICE , serviceSpec , KEY_COMMAND , serviceCmd , null ) ; }
public String service ( String serviceSpec , String serviceCmd ) throws Exception { return executeExtension ( ResourceType . SERVICE , serviceSpec , KEY_COMMAND , serviceCmd , null ) ; }
public String service ( String serviceSpec , String serviceCmd ) throws Exception { return executeExtension ( ResourceType . SERVICE , serviceSpec , KEY_COMMAND , serviceCmd , null ) ; }
public void fireStateChanged ( ) { ChangeEvent e = new ChangeEvent ( this ) ; for ( ChangeListener listener : listeners ) { listener . stateChanged ( e ) ; } }
@ Override public void close ( ) throws IOException { synchronized ( lock ) { buf = null ; in . close ( ) ; } }
@ Override public void close ( ) throws IOException { synchronized ( lock ) { buf = null ; in . close ( ) ; } }
@ Override public void close ( ) throws IOException { synchronized ( lock ) { buf = null ; in . close ( ) ; } }
public void makeImmutable ( ) { if ( isMutable ) { if ( subjectConfirmations != null ) { int length = subjectConfirmations . size ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { SubjectConfirmation subjectConfirmation = ( SubjectConfirmation ) subjectConfirmations . get ( i ) ; subjectConfirmation . makeImmutable ( ) ; } subjectConfirmations = Collections . unmodifiableList ( subjectConfirmations ) ; } if ( baseId != null ) { baseId . makeImmutable ( ) ; } if ( nameId != null ) { nameId . makeImmutable ( ) ; } isMutable = _BOOL ; } }
public static void addFilterInitParam ( WebXml webXml , String name , String paramName , String paramValue ) { WebXmlElement element = ( WebXmlElement ) webXml . getTagByIdentifier ( WebXmlType . FILTER , name ) ; addTagInitParam ( element , paramName , paramValue ) ; }
public int size ( ) { return values . size ( ) ; }
public int size ( ) { return values . size ( ) ; }
public void check ( ) throws ErlangVersionException { String erlangVersion ; try { erlangVersion = erlangShell . getErlangVersion ( ) ; LOGGER . debug ( STRING , erlangVersion ) ; } catch ( ErlangShellException e ) { throw new ErlangVersionException ( STRING , e ) ; } if ( minErlangVersion == null ) { LOGGER . debug ( STRING ) ; return ; } else { LOGGER . debug ( STRING , minErlangVersion ) ; } double expected ; double actual ; try { expected = parse ( minErlangVersion ) ; actual = parse ( erlangVersion ) ; } catch ( RuntimeException e ) { LOGGER . warn ( STRING + minErlangVersion + STRING + erlangVersion + STRING ) ; return ; } if ( actual < expected ) { throw new ErlangVersionException ( String . format ( STRING , minErlangVersion , erlangVersion ) ) ; } }
public void check ( ) throws ErlangVersionException { String erlangVersion ; try { erlangVersion = erlangShell . getErlangVersion ( ) ; LOGGER . debug ( STRING , erlangVersion ) ; } catch ( ErlangShellException e ) { throw new ErlangVersionException ( STRING , e ) ; } if ( minErlangVersion == null ) { LOGGER . debug ( STRING ) ; return ; } else { LOGGER . debug ( STRING , minErlangVersion ) ; } double expected ; double actual ; try { expected = parse ( minErlangVersion ) ; actual = parse ( erlangVersion ) ; } catch ( RuntimeException e ) { LOGGER . warn ( STRING + minErlangVersion + STRING + erlangVersion + STRING ) ; return ; } if ( actual < expected ) { throw new ErlangVersionException ( String . format ( STRING , minErlangVersion , erlangVersion ) ) ; } }
public void check ( ) throws ErlangVersionException { String erlangVersion ; try { erlangVersion = erlangShell . getErlangVersion ( ) ; LOGGER . debug ( STRING , erlangVersion ) ; } catch ( ErlangShellException e ) { throw new ErlangVersionException ( STRING , e ) ; } if ( minErlangVersion == null ) { LOGGER . debug ( STRING ) ; return ; } else { LOGGER . debug ( STRING , minErlangVersion ) ; } double expected ; double actual ; try { expected = parse ( minErlangVersion ) ; actual = parse ( erlangVersion ) ; } catch ( RuntimeException e ) { LOGGER . warn ( STRING + minErlangVersion + STRING + erlangVersion + STRING ) ; return ; } if ( actual < expected ) { throw new ErlangVersionException ( String . format ( STRING , minErlangVersion , erlangVersion ) ) ; } }
public void check ( ) throws ErlangVersionException { String erlangVersion ; try { erlangVersion = erlangShell . getErlangVersion ( ) ; LOGGER . debug ( STRING , erlangVersion ) ; } catch ( ErlangShellException e ) { throw new ErlangVersionException ( STRING , e ) ; } if ( minErlangVersion == null ) { LOGGER . debug ( STRING ) ; return ; } else { LOGGER . debug ( STRING , minErlangVersion ) ; } double expected ; double actual ; try { expected = parse ( minErlangVersion ) ; actual = parse ( erlangVersion ) ; } catch ( RuntimeException e ) { LOGGER . warn ( STRING + minErlangVersion + STRING + erlangVersion + STRING ) ; return ; } if ( actual < expected ) { throw new ErlangVersionException ( String . format ( STRING , minErlangVersion , erlangVersion ) ) ; } }
public void check ( ) throws ErlangVersionException { String erlangVersion ; try { erlangVersion = erlangShell . getErlangVersion ( ) ; LOGGER . debug ( STRING , erlangVersion ) ; } catch ( ErlangShellException e ) { throw new ErlangVersionException ( STRING , e ) ; } if ( minErlangVersion == null ) { LOGGER . debug ( STRING ) ; return ; } else { LOGGER . debug ( STRING , minErlangVersion ) ; } double expected ; double actual ; try { expected = parse ( minErlangVersion ) ; actual = parse ( erlangVersion ) ; } catch ( RuntimeException e ) { LOGGER . warn ( STRING + minErlangVersion + STRING + erlangVersion + STRING ) ; return ; } if ( actual < expected ) { throw new ErlangVersionException ( String . format ( STRING , minErlangVersion , erlangVersion ) ) ; } }
static Thread createThread ( final Runnable runnable , final String threadName , final boolean isDaemon , final int priority , final boolean doStart ) { Thread thread = new Thread ( runnable ) ; if ( threadName != null ) { thread . setName ( threadName ) ; } thread . setDaemon ( isDaemon ) ; if ( priority >= _NUM ) { thread . setPriority ( priority ) ; } if ( doStart ) { thread . start ( ) ; } return thread ; }
static Thread createThread ( final Runnable runnable , final String threadName , final boolean isDaemon , final int priority , final boolean doStart ) { Thread thread = new Thread ( runnable ) ; if ( threadName != null ) { thread . setName ( threadName ) ; } thread . setDaemon ( isDaemon ) ; if ( priority >= _NUM ) { thread . setPriority ( priority ) ; } if ( doStart ) { thread . start ( ) ; } return thread ; }
protected void beginPath ( ) { prepDrawing ( ) ; mPSStream . println ( NEWPATH_STR ) ; mPenX = _NUM ; mPenY = _NUM ; }
protected void beginPath ( ) { prepDrawing ( ) ; mPSStream . println ( NEWPATH_STR ) ; mPenX = _NUM ; mPenY = _NUM ; }
@ Override @ SuppressWarnings ( STRING ) public synchronized < T > T [ ] toArray ( T [ ] contents ) { if ( elementCount > contents . length ) { throw new RuntimeException ( STRING ) ; } System . arraycopy ( elementData , _NUM , contents , _NUM , elementCount ) ; if ( elementCount < contents . length ) { contents [ elementCount ] = null ; } return contents ; }
@ Override @ SuppressWarnings ( STRING ) public synchronized < T > T [ ] toArray ( T [ ] contents ) { if ( elementCount > contents . length ) { throw new RuntimeException ( STRING ) ; } System . arraycopy ( elementData , _NUM , contents , _NUM , elementCount ) ; if ( elementCount < contents . length ) { contents [ elementCount ] = null ; } return contents ; }
@ Override @ SuppressWarnings ( STRING ) public synchronized < T > T [ ] toArray ( T [ ] contents ) { if ( elementCount > contents . length ) { throw new RuntimeException ( STRING ) ; } System . arraycopy ( elementData , _NUM , contents , _NUM , elementCount ) ; if ( elementCount < contents . length ) { contents [ elementCount ] = null ; } return contents ; }
@ Override @ SuppressWarnings ( STRING ) public synchronized < T > T [ ] toArray ( T [ ] contents ) { if ( elementCount > contents . length ) { throw new RuntimeException ( STRING ) ; } System . arraycopy ( elementData , _NUM , contents , _NUM , elementCount ) ; if ( elementCount < contents . length ) { contents [ elementCount ] = null ; } return contents ; }
@ Override @ SuppressWarnings ( STRING ) public synchronized < T > T [ ] toArray ( T [ ] contents ) { if ( elementCount > contents . length ) { throw new RuntimeException ( STRING ) ; } System . arraycopy ( elementData , _NUM , contents , _NUM , elementCount ) ; if ( elementCount < contents . length ) { contents [ elementCount ] = null ; } return contents ; }
@ Override @ SuppressWarnings ( STRING ) public synchronized < T > T [ ] toArray ( T [ ] contents ) { if ( elementCount > contents . length ) { throw new RuntimeException ( STRING ) ; } System . arraycopy ( elementData , _NUM , contents , _NUM , elementCount ) ; if ( elementCount < contents . length ) { contents [ elementCount ] = null ; } return contents ; }
@ Override @ SuppressWarnings ( STRING ) public synchronized < T > T [ ] toArray ( T [ ] contents ) { if ( elementCount > contents . length ) { throw new RuntimeException ( STRING ) ; } System . arraycopy ( elementData , _NUM , contents , _NUM , elementCount ) ; if ( elementCount < contents . length ) { contents [ elementCount ] = null ; } return contents ; }
@ Override @ SuppressWarnings ( STRING ) public synchronized < T > T [ ] toArray ( T [ ] contents ) { if ( elementCount > contents . length ) { throw new RuntimeException ( STRING ) ; } System . arraycopy ( elementData , _NUM , contents , _NUM , elementCount ) ; if ( elementCount < contents . length ) { contents [ elementCount ] = null ; } return contents ; }
public BigdataSailRepositoryConnection cxn ( ) { return tlTx . get ( ) ; }
public BigdataSailRepositoryConnection cxn ( ) { return tlTx . get ( ) ; }
@ VisibleForTesting public static boolean isTextFile ( @ NonNull File file ) { String name = file . getName ( ) ; return name . endsWith ( DOT_JAVA ) || name . endsWith ( DOT_XML ) || name . endsWith ( DOT_AIDL ) || name . endsWith ( DOT_FS ) || name . endsWith ( DOT_RS ) || name . endsWith ( DOT_RSH ) || name . endsWith ( DOT_RSH ) || name . endsWith ( DOT_TXT ) || name . endsWith ( DOT_GRADLE ) || name . endsWith ( DOT_PROPERTIES ) || name . endsWith ( STRING ) || name . endsWith ( STRING ) || name . endsWith ( STRING ) || name . endsWith ( STRING ) || name . endsWith ( STRING ) ; }
@ VisibleForTesting public static boolean isTextFile ( @ NonNull File file ) { String name = file . getName ( ) ; return name . endsWith ( DOT_JAVA ) || name . endsWith ( DOT_XML ) || name . endsWith ( DOT_AIDL ) || name . endsWith ( DOT_FS ) || name . endsWith ( DOT_RS ) || name . endsWith ( DOT_RSH ) || name . endsWith ( DOT_RSH ) || name . endsWith ( DOT_TXT ) || name . endsWith ( DOT_GRADLE ) || name . endsWith ( DOT_PROPERTIES ) || name . endsWith ( STRING ) || name . endsWith ( STRING ) || name . endsWith ( STRING ) || name . endsWith ( STRING ) || name . endsWith ( STRING ) ; }
private void collectCompatibleExceptions ( ClassDoc [ ] froms , ClassDoc [ ] withs , List < ClassDoc > list ) { for ( ClassDoc from : froms ) { if ( ! list . contains ( from ) ) { for ( ClassDoc with : withs ) { if ( from . subclassOf ( with ) ) { list . add ( from ) ; break ; } } } } }
void sendBit5Baud ( boolean bitValue ) throws IOException { SerialExt . setBreak ( bitValue ? _NUM : _NUM ) ; try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException e ) { log . error ( null , e ) ; } }
public static URL [ ] pathToURLs ( String path ) { StringTokenizer st = new StringTokenizer ( path , File . pathSeparator ) ; URL [ ] urls = new URL [ st . countTokens ( ) ] ; int count = _NUM ; while ( st . hasMoreTokens ( ) ) { File f = new File ( st . nextToken ( ) ) ; try { f = new File ( f . getCanonicalPath ( ) ) ; } catch ( IOException x ) { } try { urls [ count ++ ] = ParseUtil . fileToEncodedURL ( f ) ; } catch ( IOException x ) { } } if ( urls . length != count ) { URL [ ] tmp = new URL [ count ] ; System . arraycopy ( urls , _NUM , tmp , _NUM , count ) ; urls = tmp ; } return urls ; }
public static URL [ ] pathToURLs ( String path ) { StringTokenizer st = new StringTokenizer ( path , File . pathSeparator ) ; URL [ ] urls = new URL [ st . countTokens ( ) ] ; int count = _NUM ; while ( st . hasMoreTokens ( ) ) { File f = new File ( st . nextToken ( ) ) ; try { f = new File ( f . getCanonicalPath ( ) ) ; } catch ( IOException x ) { } try { urls [ count ++ ] = ParseUtil . fileToEncodedURL ( f ) ; } catch ( IOException x ) { } } if ( urls . length != count ) { URL [ ] tmp = new URL [ count ] ; System . arraycopy ( urls , _NUM , tmp , _NUM , count ) ; urls = tmp ; } return urls ; }
public static URL [ ] pathToURLs ( String path ) { StringTokenizer st = new StringTokenizer ( path , File . pathSeparator ) ; URL [ ] urls = new URL [ st . countTokens ( ) ] ; int count = _NUM ; while ( st . hasMoreTokens ( ) ) { File f = new File ( st . nextToken ( ) ) ; try { f = new File ( f . getCanonicalPath ( ) ) ; } catch ( IOException x ) { } try { urls [ count ++ ] = ParseUtil . fileToEncodedURL ( f ) ; } catch ( IOException x ) { } } if ( urls . length != count ) { URL [ ] tmp = new URL [ count ] ; System . arraycopy ( urls , _NUM , tmp , _NUM , count ) ; urls = tmp ; } return urls ; }
public static URL [ ] pathToURLs ( String path ) { StringTokenizer st = new StringTokenizer ( path , File . pathSeparator ) ; URL [ ] urls = new URL [ st . countTokens ( ) ] ; int count = _NUM ; while ( st . hasMoreTokens ( ) ) { File f = new File ( st . nextToken ( ) ) ; try { f = new File ( f . getCanonicalPath ( ) ) ; } catch ( IOException x ) { } try { urls [ count ++ ] = ParseUtil . fileToEncodedURL ( f ) ; } catch ( IOException x ) { } } if ( urls . length != count ) { URL [ ] tmp = new URL [ count ] ; System . arraycopy ( urls , _NUM , tmp , _NUM , count ) ; urls = tmp ; } return urls ; }
public static URL [ ] pathToURLs ( String path ) { StringTokenizer st = new StringTokenizer ( path , File . pathSeparator ) ; URL [ ] urls = new URL [ st . countTokens ( ) ] ; int count = _NUM ; while ( st . hasMoreTokens ( ) ) { File f = new File ( st . nextToken ( ) ) ; try { f = new File ( f . getCanonicalPath ( ) ) ; } catch ( IOException x ) { } try { urls [ count ++ ] = ParseUtil . fileToEncodedURL ( f ) ; } catch ( IOException x ) { } } if ( urls . length != count ) { URL [ ] tmp = new URL [ count ] ; System . arraycopy ( urls , _NUM , tmp , _NUM , count ) ; urls = tmp ; } return urls ; }
void addTransaction ( Transaction t , boolean runSanityChecks ) { unCacheTransactions ( ) ; if ( transactions == null ) { transactions = new ArrayList < Transaction > ( ) ; } t . setParent ( this ) ; if ( runSanityChecks && transactions . size ( ) == _NUM && ! t . isCoinBase ( ) ) throw new RuntimeException ( STRING + t ) ; else if ( runSanityChecks && transactions . size ( ) > _NUM && t . isCoinBase ( ) ) throw new RuntimeException ( STRING + t ) ; transactions . add ( t ) ; adjustLength ( transactions . size ( ) , t . length ) ; merkleRoot = null ; hash = null ; }
public void addReturnAttribute ( CoreTokenField field ) { Reject . ifNull ( field ) ; returnFields . add ( field ) ; }
public void addReturnAttribute ( CoreTokenField field ) { Reject . ifNull ( field ) ; returnFields . add ( field ) ; }
public void addReturnAttribute ( CoreTokenField field ) { Reject . ifNull ( field ) ; returnFields . add ( field ) ; }
public void deleteEntityConfig ( String realm , String entityId ) throws SAML2MetaException { if ( entityId == null ) { return ; } if ( realm == null ) { realm = STRING ; } String [ ] objs = { entityId , realm } ; try { Map oldAttrs = configInst . getConfiguration ( realm , entityId ) ; Set oldValues = ( Set ) oldAttrs . get ( ATTR_ENTITY_CONFIG ) ; if ( oldValues == null || oldValues . isEmpty ( ) ) { LogUtil . error ( Level . INFO , LogUtil . NO_ENTITY_DESCRIPTOR_DELETE_ENTITY_CONFIG , objs , null ) ; throw new SAML2MetaException ( STRING , objs ) ; } removeFromCircleOfTrust ( realm , entityId ) ; Set attr = new HashSet ( ) ; attr . add ( ATTR_ENTITY_CONFIG ) ; configInst . deleteConfiguration ( realm , entityId , attr ) ; LogUtil . access ( Level . INFO , LogUtil . ENTITY_CONFIG_DELETED , objs , null ) ; SAML2MetaCache . putEntityConfig ( realm , entityId , null ) ; } catch ( ConfigurationException e ) { debug . error ( STRING , e ) ; String [ ] data = { e . getMessage ( ) , entityId , realm } ; LogUtil . error ( Level . INFO , LogUtil . CONFIG_ERROR_DELETE_ENTITY_CONFIG , data , null ) ; throw new SAML2MetaException ( e ) ; } }
public int interpolateOutOfBoundsScroll ( RecyclerView recyclerView , int viewSize , int viewSizeOutOfBounds , int totalSize , long msSinceStartScroll ) { final int maxScroll = getMaxDragScroll ( recyclerView ) ; final int absOutOfBounds = Math . abs ( viewSizeOutOfBounds ) ; final int direction = ( int ) Math . signum ( viewSizeOutOfBounds ) ; float outOfBoundsRatio = Math . min ( _NUM , _NUM * absOutOfBounds / viewSize ) ; final int cappedScroll = ( int ) ( direction * maxScroll * sDragViewScrollCapInterpolator . getInterpolation ( outOfBoundsRatio ) ) ; final float timeRatio ; if ( msSinceStartScroll > DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ) { timeRatio = _NUM ; } else { timeRatio = ( float ) msSinceStartScroll / DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ; } final int value = ( int ) ( cappedScroll * sDragScrollInterpolator . getInterpolation ( timeRatio ) ) ; if ( value == _NUM ) { return viewSizeOutOfBounds > _NUM ? _NUM : - _NUM ; } return value ; }
public int interpolateOutOfBoundsScroll ( RecyclerView recyclerView , int viewSize , int viewSizeOutOfBounds , int totalSize , long msSinceStartScroll ) { final int maxScroll = getMaxDragScroll ( recyclerView ) ; final int absOutOfBounds = Math . abs ( viewSizeOutOfBounds ) ; final int direction = ( int ) Math . signum ( viewSizeOutOfBounds ) ; float outOfBoundsRatio = Math . min ( _NUM , _NUM * absOutOfBounds / viewSize ) ; final int cappedScroll = ( int ) ( direction * maxScroll * sDragViewScrollCapInterpolator . getInterpolation ( outOfBoundsRatio ) ) ; final float timeRatio ; if ( msSinceStartScroll > DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ) { timeRatio = _NUM ; } else { timeRatio = ( float ) msSinceStartScroll / DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ; } final int value = ( int ) ( cappedScroll * sDragScrollInterpolator . getInterpolation ( timeRatio ) ) ; if ( value == _NUM ) { return viewSizeOutOfBounds > _NUM ? _NUM : - _NUM ; } return value ; }
public int interpolateOutOfBoundsScroll ( RecyclerView recyclerView , int viewSize , int viewSizeOutOfBounds , int totalSize , long msSinceStartScroll ) { final int maxScroll = getMaxDragScroll ( recyclerView ) ; final int absOutOfBounds = Math . abs ( viewSizeOutOfBounds ) ; final int direction = ( int ) Math . signum ( viewSizeOutOfBounds ) ; float outOfBoundsRatio = Math . min ( _NUM , _NUM * absOutOfBounds / viewSize ) ; final int cappedScroll = ( int ) ( direction * maxScroll * sDragViewScrollCapInterpolator . getInterpolation ( outOfBoundsRatio ) ) ; final float timeRatio ; if ( msSinceStartScroll > DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ) { timeRatio = _NUM ; } else { timeRatio = ( float ) msSinceStartScroll / DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ; } final int value = ( int ) ( cappedScroll * sDragScrollInterpolator . getInterpolation ( timeRatio ) ) ; if ( value == _NUM ) { return viewSizeOutOfBounds > _NUM ? _NUM : - _NUM ; } return value ; }
public int interpolateOutOfBoundsScroll ( RecyclerView recyclerView , int viewSize , int viewSizeOutOfBounds , int totalSize , long msSinceStartScroll ) { final int maxScroll = getMaxDragScroll ( recyclerView ) ; final int absOutOfBounds = Math . abs ( viewSizeOutOfBounds ) ; final int direction = ( int ) Math . signum ( viewSizeOutOfBounds ) ; float outOfBoundsRatio = Math . min ( _NUM , _NUM * absOutOfBounds / viewSize ) ; final int cappedScroll = ( int ) ( direction * maxScroll * sDragViewScrollCapInterpolator . getInterpolation ( outOfBoundsRatio ) ) ; final float timeRatio ; if ( msSinceStartScroll > DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ) { timeRatio = _NUM ; } else { timeRatio = ( float ) msSinceStartScroll / DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ; } final int value = ( int ) ( cappedScroll * sDragScrollInterpolator . getInterpolation ( timeRatio ) ) ; if ( value == _NUM ) { return viewSizeOutOfBounds > _NUM ? _NUM : - _NUM ; } return value ; }
public int interpolateOutOfBoundsScroll ( RecyclerView recyclerView , int viewSize , int viewSizeOutOfBounds , int totalSize , long msSinceStartScroll ) { final int maxScroll = getMaxDragScroll ( recyclerView ) ; final int absOutOfBounds = Math . abs ( viewSizeOutOfBounds ) ; final int direction = ( int ) Math . signum ( viewSizeOutOfBounds ) ; float outOfBoundsRatio = Math . min ( _NUM , _NUM * absOutOfBounds / viewSize ) ; final int cappedScroll = ( int ) ( direction * maxScroll * sDragViewScrollCapInterpolator . getInterpolation ( outOfBoundsRatio ) ) ; final float timeRatio ; if ( msSinceStartScroll > DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ) { timeRatio = _NUM ; } else { timeRatio = ( float ) msSinceStartScroll / DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ; } final int value = ( int ) ( cappedScroll * sDragScrollInterpolator . getInterpolation ( timeRatio ) ) ; if ( value == _NUM ) { return viewSizeOutOfBounds > _NUM ? _NUM : - _NUM ; } return value ; }
public int interpolateOutOfBoundsScroll ( RecyclerView recyclerView , int viewSize , int viewSizeOutOfBounds , int totalSize , long msSinceStartScroll ) { final int maxScroll = getMaxDragScroll ( recyclerView ) ; final int absOutOfBounds = Math . abs ( viewSizeOutOfBounds ) ; final int direction = ( int ) Math . signum ( viewSizeOutOfBounds ) ; float outOfBoundsRatio = Math . min ( _NUM , _NUM * absOutOfBounds / viewSize ) ; final int cappedScroll = ( int ) ( direction * maxScroll * sDragViewScrollCapInterpolator . getInterpolation ( outOfBoundsRatio ) ) ; final float timeRatio ; if ( msSinceStartScroll > DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ) { timeRatio = _NUM ; } else { timeRatio = ( float ) msSinceStartScroll / DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ; } final int value = ( int ) ( cappedScroll * sDragScrollInterpolator . getInterpolation ( timeRatio ) ) ; if ( value == _NUM ) { return viewSizeOutOfBounds > _NUM ? _NUM : - _NUM ; } return value ; }
public int interpolateOutOfBoundsScroll ( RecyclerView recyclerView , int viewSize , int viewSizeOutOfBounds , int totalSize , long msSinceStartScroll ) { final int maxScroll = getMaxDragScroll ( recyclerView ) ; final int absOutOfBounds = Math . abs ( viewSizeOutOfBounds ) ; final int direction = ( int ) Math . signum ( viewSizeOutOfBounds ) ; float outOfBoundsRatio = Math . min ( _NUM , _NUM * absOutOfBounds / viewSize ) ; final int cappedScroll = ( int ) ( direction * maxScroll * sDragViewScrollCapInterpolator . getInterpolation ( outOfBoundsRatio ) ) ; final float timeRatio ; if ( msSinceStartScroll > DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ) { timeRatio = _NUM ; } else { timeRatio = ( float ) msSinceStartScroll / DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ; } final int value = ( int ) ( cappedScroll * sDragScrollInterpolator . getInterpolation ( timeRatio ) ) ; if ( value == _NUM ) { return viewSizeOutOfBounds > _NUM ? _NUM : - _NUM ; } return value ; }
public int interpolateOutOfBoundsScroll ( RecyclerView recyclerView , int viewSize , int viewSizeOutOfBounds , int totalSize , long msSinceStartScroll ) { final int maxScroll = getMaxDragScroll ( recyclerView ) ; final int absOutOfBounds = Math . abs ( viewSizeOutOfBounds ) ; final int direction = ( int ) Math . signum ( viewSizeOutOfBounds ) ; float outOfBoundsRatio = Math . min ( _NUM , _NUM * absOutOfBounds / viewSize ) ; final int cappedScroll = ( int ) ( direction * maxScroll * sDragViewScrollCapInterpolator . getInterpolation ( outOfBoundsRatio ) ) ; final float timeRatio ; if ( msSinceStartScroll > DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ) { timeRatio = _NUM ; } else { timeRatio = ( float ) msSinceStartScroll / DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ; } final int value = ( int ) ( cappedScroll * sDragScrollInterpolator . getInterpolation ( timeRatio ) ) ; if ( value == _NUM ) { return viewSizeOutOfBounds > _NUM ? _NUM : - _NUM ; } return value ; }
public int interpolateOutOfBoundsScroll ( RecyclerView recyclerView , int viewSize , int viewSizeOutOfBounds , int totalSize , long msSinceStartScroll ) { final int maxScroll = getMaxDragScroll ( recyclerView ) ; final int absOutOfBounds = Math . abs ( viewSizeOutOfBounds ) ; final int direction = ( int ) Math . signum ( viewSizeOutOfBounds ) ; float outOfBoundsRatio = Math . min ( _NUM , _NUM * absOutOfBounds / viewSize ) ; final int cappedScroll = ( int ) ( direction * maxScroll * sDragViewScrollCapInterpolator . getInterpolation ( outOfBoundsRatio ) ) ; final float timeRatio ; if ( msSinceStartScroll > DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ) { timeRatio = _NUM ; } else { timeRatio = ( float ) msSinceStartScroll / DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ; } final int value = ( int ) ( cappedScroll * sDragScrollInterpolator . getInterpolation ( timeRatio ) ) ; if ( value == _NUM ) { return viewSizeOutOfBounds > _NUM ? _NUM : - _NUM ; } return value ; }
public int interpolateOutOfBoundsScroll ( RecyclerView recyclerView , int viewSize , int viewSizeOutOfBounds , int totalSize , long msSinceStartScroll ) { final int maxScroll = getMaxDragScroll ( recyclerView ) ; final int absOutOfBounds = Math . abs ( viewSizeOutOfBounds ) ; final int direction = ( int ) Math . signum ( viewSizeOutOfBounds ) ; float outOfBoundsRatio = Math . min ( _NUM , _NUM * absOutOfBounds / viewSize ) ; final int cappedScroll = ( int ) ( direction * maxScroll * sDragViewScrollCapInterpolator . getInterpolation ( outOfBoundsRatio ) ) ; final float timeRatio ; if ( msSinceStartScroll > DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ) { timeRatio = _NUM ; } else { timeRatio = ( float ) msSinceStartScroll / DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ; } final int value = ( int ) ( cappedScroll * sDragScrollInterpolator . getInterpolation ( timeRatio ) ) ; if ( value == _NUM ) { return viewSizeOutOfBounds > _NUM ? _NUM : - _NUM ; } return value ; }
public String decode ( String encoded ) { JsonObject object = new JsonObject ( encoded ) ; JsonArray headers = object . getJsonArray ( STRING ) ; for ( Object headerObj : headers ) { JsonArray header = ( JsonArray ) headerObj ; String key = header . getString ( _NUM ) ; String value = header . getString ( _NUM ) ; if ( key . equalsIgnoreCase ( CONTENT_TYPE ) && ( value . contains ( STRING ) || value . contains ( APPLICATION_JSON ) ) ) { try { object . put ( STRING , new JsonObject ( new String ( object . getBinary ( PAYLOAD ) , Charset . forName ( UTF_8 ) ) ) ) ; } catch ( DecodeException e ) { object . put ( STRING , new String ( object . getBinary ( PAYLOAD ) , Charset . forName ( UTF_8 ) ) ) ; } object . remove ( PAYLOAD ) ; break ; } } return object . toString ( ) ; }
public static boolean substractTradingFee ( Player player , int price ) { BigDecimal fee = calculateFee ( player , price ) ; return player . drop ( STRING , fee . intValue ( ) ) ; }
String capitalise ( final String s ) { if ( s . length ( ) == _NUM ) { return s ; } final StringBuffer s1 = new StringBuffer ( s ) ; if ( Character . isLowerCase ( s1 . charAt ( _NUM ) ) ) { s1 . setCharAt ( _NUM , Character . toUpperCase ( s1 . charAt ( _NUM ) ) ) ; } for ( int j = _NUM ; j < s1 . length ( ) ; j ++ ) { if ( Character . isUpperCase ( s1 . charAt ( j ) ) ) { s1 . setCharAt ( j , Character . toLowerCase ( s1 . charAt ( j ) ) ) ; } } return s1 . toString ( ) ; }
public void connect ( SocketAddress endpoint , int timeout ) throws IOException { if ( endpoint == null ) throw new IllegalArgumentException ( STRING ) ; if ( timeout < _NUM ) throw new IllegalArgumentException ( STRING ) ; if ( isClosed ( ) ) throw new SocketException ( STRING ) ; if ( ! oldImpl && isConnected ( ) ) throw new SocketException ( STRING ) ; if ( ! ( endpoint instanceof InetSocketAddress ) ) throw new IllegalArgumentException ( STRING ) ; InetSocketAddress epoint = ( InetSocketAddress ) endpoint ; InetAddress addr = epoint . getAddress ( ) ; int port = epoint . getPort ( ) ; checkAddress ( addr , STRING ) ; SecurityManager security = System . getSecurityManager ( ) ; if ( security != null ) { if ( epoint . isUnresolved ( ) ) security . checkConnect ( epoint . getHostName ( ) , port ) ; else security . checkConnect ( addr . getHostAddress ( ) , port ) ; } if ( ! created ) createImpl ( _BOOL ) ; if ( ! oldImpl ) impl . connect ( epoint , timeout ) ; else if ( timeout == _NUM ) { if ( epoint . isUnresolved ( ) ) impl . connect ( addr . getHostName ( ) , port ) ; else impl . connect ( addr , port ) ; } else throw new UnsupportedOperationException ( STRING ) ; connected = _BOOL ; bound = _BOOL ; }
Class < ? > loadClass ( String className , URL [ ] urls ) throws ClassNotFoundException { URLClassLoader cl = new URLClassLoader ( urls ) ; Class < ? > testClass = cl . loadClass ( className ) ; return testClass ; }
public void addRow ( final MemberTableRowData rowData ) { model . add ( rowData ) ; validRows . add ( _BOOL ) ; fireTableRowsInserted ( model . size ( ) - _NUM , model . size ( ) - _NUM ) ; }
private static void verifyConfPathCorrectness ( ) { GlobalConf . getInstanceIdentifier ( ) ; }
private static void verifyConfPathCorrectness ( ) { GlobalConf . getInstanceIdentifier ( ) ; }
boolean onItemMove ( final int fromPos , final int toPos ) { if ( mSwappedItem == null ) { mStartDragPos = fromPos ; mSwappedItem = mData . get ( fromPos ) ; } mStopDragPos = toPos ; final int jumpSize = Math . abs ( toPos - fromPos ) ; if ( jumpSize > _NUM ) { final int sign = Integer . signum ( toPos - fromPos ) ; int startPos = fromPos ; for ( int i = _NUM ; i < jumpSize ; i ++ ) { final int endPos = startPos + sign ; Collections . swap ( mData , startPos , endPos ) ; startPos += sign ; } } else { Collections . swap ( mData , fromPos , toPos ) ; } notifyItemMoved ( fromPos , toPos ) ; return _BOOL ; }
public boolean hasPeriods ( ) { List < DimensionalItemObject > dimOpts = getDimensionOptions ( PERIOD_DIM_ID ) ; List < DimensionalItemObject > filterOpts = getFilterOptions ( PERIOD_DIM_ID ) ; return ! dimOpts . isEmpty ( ) || ! filterOpts . isEmpty ( ) ; }
public FileImageRecorder ( File base_path , int starting_seq , String prefix , RecordingSuccessCallback callback ) { super ( base_path , starting_seq , prefix , callback ) ; this . activated = _BOOL ; executor = Executors . newFixedThreadPool ( MAX_SAVING_THREADS ) ; }
public List < NceConsistRosterEntry > matchingList ( String roadName , String roadNumber , String consistNumber , String eng1Address , String eng2Address , String eng3Address , String eng4Address , String eng5Address , String eng6Address , String id ) { List < NceConsistRosterEntry > l = new ArrayList < NceConsistRosterEntry > ( ) ; for ( int i = _NUM ; i < numEntries ( ) ; i ++ ) { if ( checkEntry ( i , roadName , roadNumber , consistNumber , eng1Address , eng2Address , eng3Address , eng4Address , eng5Address , eng6Address , id ) ) { l . add ( _list . get ( i ) ) ; } } return l ; }
public List < NceConsistRosterEntry > matchingList ( String roadName , String roadNumber , String consistNumber , String eng1Address , String eng2Address , String eng3Address , String eng4Address , String eng5Address , String eng6Address , String id ) { List < NceConsistRosterEntry > l = new ArrayList < NceConsistRosterEntry > ( ) ; for ( int i = _NUM ; i < numEntries ( ) ; i ++ ) { if ( checkEntry ( i , roadName , roadNumber , consistNumber , eng1Address , eng2Address , eng3Address , eng4Address , eng5Address , eng6Address , id ) ) { l . add ( _list . get ( i ) ) ; } } return l ; }
@ Override public boolean isValid ( ) { return valid ; }
public static Blob toBlob ( Connection conn , Object value ) throws PageException , SQLException { if ( value instanceof Blob ) return ( Blob ) value ; if ( SystemUtil . JAVA_VERSION >= SystemUtil . JAVA_VERSION_1_6 ) { try { Blob blob = conn . createBlob ( ) ; blob . setBytes ( _NUM , Caster . toBinary ( value ) ) ; return blob ; } catch ( Throwable t ) { return BlobImpl . toBlob ( value ) ; } } if ( isOracle ( conn ) ) { Blob blob = OracleBlob . createBlob ( conn , Caster . toBinary ( value ) , null ) ; if ( blob != null ) return blob ; } return BlobImpl . toBlob ( value ) ; }
public static String convertBracketsToPTBFormat ( String sentence ) { sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; return sentence ; }
public static String convertBracketsToPTBFormat ( String sentence ) { sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; return sentence ; }
public static String convertBracketsToPTBFormat ( String sentence ) { sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; return sentence ; }
public static String convertBracketsToPTBFormat ( String sentence ) { sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; sentence = sentence . replaceAll ( STRING , STRING ) ; return sentence ; }
public void readNodes ( final int [ ] columnsIndices , final BufferedReader reader ) throws IOException { String line = reader . readLine ( ) ; while ( line != null && line . length ( ) > _NUM ) { final String [ ] parts = line . split ( STRING ) ; Node node = NetworkUtils . createNode ( Id . createNodeId ( parts [ columnsIndices [ _NUM ] ] ) ) ; node . setCoord ( new Coord ( Double . parseDouble ( parts [ columnsIndices [ _NUM ] ] ) , Double . parseDouble ( parts [ columnsIndices [ _NUM ] ] ) ) ) ; network . addNode ( node ) ; line = reader . readLine ( ) ; } }
private static String [ ] splitConsolidated ( String s ) { if ( ( s . length ( ) % _NUM ) != _NUM ) { throw new IllegalArgumentException ( STRING + s ) ; } int index = s . length ( ) / _NUM ; return new String [ ] { s . substring ( _NUM , index ) , s . substring ( index ) } ; }
private String diff_linesToCharsMunge ( String text , List < String > lineArray , Map < String , Integer > lineHash ) { int lineStart = _NUM ; int lineEnd = - _NUM ; String line ; StringBuilder chars = new StringBuilder ( ) ; while ( lineEnd < text . length ( ) - _NUM ) { lineEnd = text . indexOf ( STRING , lineStart ) ; if ( lineEnd == - _NUM ) { lineEnd = text . length ( ) - _NUM ; } line = text . substring ( lineStart , lineEnd + _NUM ) ; lineStart = lineEnd + _NUM ; if ( lineHash . containsKey ( line ) ) { chars . append ( String . valueOf ( ( char ) ( int ) lineHash . get ( line ) ) ) ; } else { lineArray . add ( line ) ; lineHash . put ( line , lineArray . size ( ) - _NUM ) ; chars . append ( String . valueOf ( ( char ) ( lineArray . size ( ) - _NUM ) ) ) ; } } return chars . toString ( ) ; }
private String diff_linesToCharsMunge ( String text , List < String > lineArray , Map < String , Integer > lineHash ) { int lineStart = _NUM ; int lineEnd = - _NUM ; String line ; StringBuilder chars = new StringBuilder ( ) ; while ( lineEnd < text . length ( ) - _NUM ) { lineEnd = text . indexOf ( STRING , lineStart ) ; if ( lineEnd == - _NUM ) { lineEnd = text . length ( ) - _NUM ; } line = text . substring ( lineStart , lineEnd + _NUM ) ; lineStart = lineEnd + _NUM ; if ( lineHash . containsKey ( line ) ) { chars . append ( String . valueOf ( ( char ) ( int ) lineHash . get ( line ) ) ) ; } else { lineArray . add ( line ) ; lineHash . put ( line , lineArray . size ( ) - _NUM ) ; chars . append ( String . valueOf ( ( char ) ( lineArray . size ( ) - _NUM ) ) ) ; } } return chars . toString ( ) ; }
private String diff_linesToCharsMunge ( String text , List < String > lineArray , Map < String , Integer > lineHash ) { int lineStart = _NUM ; int lineEnd = - _NUM ; String line ; StringBuilder chars = new StringBuilder ( ) ; while ( lineEnd < text . length ( ) - _NUM ) { lineEnd = text . indexOf ( STRING , lineStart ) ; if ( lineEnd == - _NUM ) { lineEnd = text . length ( ) - _NUM ; } line = text . substring ( lineStart , lineEnd + _NUM ) ; lineStart = lineEnd + _NUM ; if ( lineHash . containsKey ( line ) ) { chars . append ( String . valueOf ( ( char ) ( int ) lineHash . get ( line ) ) ) ; } else { lineArray . add ( line ) ; lineHash . put ( line , lineArray . size ( ) - _NUM ) ; chars . append ( String . valueOf ( ( char ) ( lineArray . size ( ) - _NUM ) ) ) ; } } return chars . toString ( ) ; }
protected void filterMembers ( Collection < InternalDistributedMember > mbrs , Set < InternalDistributedMember > matchingMembers , short requestType ) { Set < InternalDistributedMember > requests = getPendingRequestIDs ( requestType ) ; if ( ! requests . isEmpty ( ) ) { logger . debug ( STRING + requests . size ( ) + STRING + requestType ) ; Iterator < InternalDistributedMember > itr = requests . iterator ( ) ; while ( itr . hasNext ( ) ) { InternalDistributedMember memberID = itr . next ( ) ; if ( mbrs . contains ( memberID ) ) { testFlagForRemovalRequest = _BOOL ; matchingMembers . add ( memberID ) ; } } } }
protected void filterMembers ( Collection < InternalDistributedMember > mbrs , Set < InternalDistributedMember > matchingMembers , short requestType ) { Set < InternalDistributedMember > requests = getPendingRequestIDs ( requestType ) ; if ( ! requests . isEmpty ( ) ) { logger . debug ( STRING + requests . size ( ) + STRING + requestType ) ; Iterator < InternalDistributedMember > itr = requests . iterator ( ) ; while ( itr . hasNext ( ) ) { InternalDistributedMember memberID = itr . next ( ) ; if ( mbrs . contains ( memberID ) ) { testFlagForRemovalRequest = _BOOL ; matchingMembers . add ( memberID ) ; } } } }
private Set < StoragePort > reduceStoragePortMap ( Map < String , Set < StoragePort > > map ) { Set < StoragePort > set = new HashSet < StoragePort > ( ) ; for ( Set < StoragePort > aSet : map . values ( ) ) { set . addAll ( aSet ) ; } return set ; }
private Set < StoragePort > reduceStoragePortMap ( Map < String , Set < StoragePort > > map ) { Set < StoragePort > set = new HashSet < StoragePort > ( ) ; for ( Set < StoragePort > aSet : map . values ( ) ) { set . addAll ( aSet ) ; } return set ; }
private Set < StoragePort > reduceStoragePortMap ( Map < String , Set < StoragePort > > map ) { Set < StoragePort > set = new HashSet < StoragePort > ( ) ; for ( Set < StoragePort > aSet : map . values ( ) ) { set . addAll ( aSet ) ; } return set ; }
public void addSet ( String name , TupleSet set ) { if ( hasSet ( name ) ) { throw new IllegalArgumentException ( STRING + name ) ; } m_map . put ( name , set ) ; m_sets . add ( set ) ; m_count += set . getTupleCount ( ) ; if ( m_lstnr != null ) set . addTupleSetListener ( m_lstnr ) ; }
public double percentage ( Constant v ) { if ( pcts . containsKey ( v ) ) return pcts . get ( v ) ; SortedSet < Constant > sorted = values ( ) ; if ( v . compareTo ( sorted . first ( ) ) < _NUM ) return _NUM ; Constant prev = null ; for ( Constant pct : sorted ) { if ( prev != null && v . compareTo ( prev ) >= _NUM && v . compareTo ( pct ) < _NUM ) return pcts . get ( prev ) ; prev = pct ; } return pcts . get ( sorted . last ( ) ) ; }
private String createLicenseKey ( final String licenseKey ) { if ( validateLicenseKey ( licenseKey ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i : LICENSE_CHARS ) { sb . append ( licenseKey . charAt ( i ) ) ; } return sb . toString ( ) ; } return STRING ; }
protected void readOptionalMeasure ( ByteBuffer buffer ) { if ( buffer . hasRemaining ( ) && ( buffer . limit ( ) - buffer . position ( ) ) >= _NUM ) { double [ ] mArray = ShapefileUtils . readDoubleArray ( buffer , _NUM ) ; this . m = mArray [ _NUM ] ; } }
public final boolean check_trace ( Polyline p_polyline , int p_half_width , int p_layer , NetNosList p_net_no_arr , int p_clearance_class_no , int p_max_recursion_depth , int p_max_via_recursion_depth , int p_max_spring_over_recursion_depth ) { AwtreeShapeSearch search_tree = search_tree_manager . get_default_tree ( ) ; int compensated_half_width = p_half_width + search_tree . get_clearance_compensation ( p_clearance_class_no , p_layer ) ; ArrayList < ShapeTile > trace_shapes = p_polyline . offset_shapes ( compensated_half_width , _NUM , p_polyline . corner_count ( ) ) ; for ( int index = _NUM ; index < trace_shapes . size ( ) ; ++ index ) { ShapeTile curr_trace_shape = trace_shapes . get ( index ) ; BrdFromSide from_side = new BrdFromSide ( p_polyline , index + _NUM , curr_trace_shape ) ; boolean check_shove_ok = shove_trace_algo . shove_trace_check ( curr_trace_shape , from_side , null , p_layer , p_net_no_arr , p_clearance_class_no , p_max_recursion_depth , p_max_via_recursion_depth , p_max_spring_over_recursion_depth , null ) ; if ( ! check_shove_ok ) return _BOOL ; } return _BOOL ; }
public void addMethod ( MethodInfo minfo ) throws DuplicateMemberException { testExistingMethod ( minfo ) ; methods . add ( minfo ) ; }
public int read ( byte [ ] b , int off , int len ) throws IOException { if ( closed ) { throw new IOException ( STRING ) ; } if ( eof ) { return - _NUM ; } if ( pos >= chunkSize ) { nextChunk ( ) ; if ( eof ) { return - _NUM ; } } len = Math . min ( len , chunkSize - pos ) ; int count = in . read ( b , off , len ) ; pos += count ; return count ; }
public static AnnotationMirror buildAnnoMirrorWithNoPrefix ( final ProcessingEnvironment env , final Class < ? extends Annotation > annoClass ) { if ( env == null || annoClass == null ) { return null ; } return AnnotationUtils . fromClass ( env . getElementUtils ( ) , annoClass ) ; }
public static AnnotationMirror buildAnnoMirrorWithNoPrefix ( final ProcessingEnvironment env , final Class < ? extends Annotation > annoClass ) { if ( env == null || annoClass == null ) { return null ; } return AnnotationUtils . fromClass ( env . getElementUtils ( ) , annoClass ) ; }
@ Override public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { String rememberMeCookie = extractRememberMeCookie ( request ) ; if ( rememberMeCookie != null && rememberMeCookie . length ( ) != _NUM ) { try { String [ ] cookieTokens = decodeCookie ( rememberMeCookie ) ; if ( cookieTokens . length != _NUM ) { throw new InvalidCookieException ( STRING + _NUM + STRING + Arrays . asList ( cookieTokens ) + STRING ) ; } persistentTokenRepository . deleteById ( cookieTokens [ _NUM ] ) ; } catch ( InvalidCookieException ice ) { log . info ( STRING ) ; } catch ( RememberMeAuthenticationException rmae ) { log . debug ( STRING ) ; } } super . logout ( request , response , authentication ) ; }
@ Override public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { String rememberMeCookie = extractRememberMeCookie ( request ) ; if ( rememberMeCookie != null && rememberMeCookie . length ( ) != _NUM ) { try { String [ ] cookieTokens = decodeCookie ( rememberMeCookie ) ; if ( cookieTokens . length != _NUM ) { throw new InvalidCookieException ( STRING + _NUM + STRING + Arrays . asList ( cookieTokens ) + STRING ) ; } persistentTokenRepository . deleteById ( cookieTokens [ _NUM ] ) ; } catch ( InvalidCookieException ice ) { log . info ( STRING ) ; } catch ( RememberMeAuthenticationException rmae ) { log . debug ( STRING ) ; } } super . logout ( request , response , authentication ) ; }
@ Override public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { String rememberMeCookie = extractRememberMeCookie ( request ) ; if ( rememberMeCookie != null && rememberMeCookie . length ( ) != _NUM ) { try { String [ ] cookieTokens = decodeCookie ( rememberMeCookie ) ; if ( cookieTokens . length != _NUM ) { throw new InvalidCookieException ( STRING + _NUM + STRING + Arrays . asList ( cookieTokens ) + STRING ) ; } persistentTokenRepository . deleteById ( cookieTokens [ _NUM ] ) ; } catch ( InvalidCookieException ice ) { log . info ( STRING ) ; } catch ( RememberMeAuthenticationException rmae ) { log . debug ( STRING ) ; } } super . logout ( request , response , authentication ) ; }
@ Override public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { String rememberMeCookie = extractRememberMeCookie ( request ) ; if ( rememberMeCookie != null && rememberMeCookie . length ( ) != _NUM ) { try { String [ ] cookieTokens = decodeCookie ( rememberMeCookie ) ; if ( cookieTokens . length != _NUM ) { throw new InvalidCookieException ( STRING + _NUM + STRING + Arrays . asList ( cookieTokens ) + STRING ) ; } persistentTokenRepository . deleteById ( cookieTokens [ _NUM ] ) ; } catch ( InvalidCookieException ice ) { log . info ( STRING ) ; } catch ( RememberMeAuthenticationException rmae ) { log . debug ( STRING ) ; } } super . logout ( request , response , authentication ) ; }
public Set < String > keyNames ( String prefix ) { Set < String > keys = keyNames ( ) ; HashSet < String > subset = new HashSet < String > ( ) ; for ( String key : keys ) { if ( key != null && key . startsWith ( prefix ) ) subset . add ( key ) ; } return subset ; }
public Set < String > keyNames ( String prefix ) { Set < String > keys = keyNames ( ) ; HashSet < String > subset = new HashSet < String > ( ) ; for ( String key : keys ) { if ( key != null && key . startsWith ( prefix ) ) subset . add ( key ) ; } return subset ; }
public boolean killJob ( String jobIdFile ) { List < String > jobIdFileContent = readFromFile ( jobIdFile ) ; if ( jobIdFileContent . size ( ) > _NUM ) { String [ ] slurmCmd = new String [ ] { STRING , jobIdFileContent . get ( _NUM ) } ; return runProcess ( null , slurmCmd , new StringBuilder ( ) , new StringBuilder ( ) ) ; } else { LOG . log ( Level . SEVERE , STRING , jobIdFile ) ; return _BOOL ; } }
public boolean killJob ( String jobIdFile ) { List < String > jobIdFileContent = readFromFile ( jobIdFile ) ; if ( jobIdFileContent . size ( ) > _NUM ) { String [ ] slurmCmd = new String [ ] { STRING , jobIdFileContent . get ( _NUM ) } ; return runProcess ( null , slurmCmd , new StringBuilder ( ) , new StringBuilder ( ) ) ; } else { LOG . log ( Level . SEVERE , STRING , jobIdFile ) ; return _BOOL ; } }
public boolean killJob ( String jobIdFile ) { List < String > jobIdFileContent = readFromFile ( jobIdFile ) ; if ( jobIdFileContent . size ( ) > _NUM ) { String [ ] slurmCmd = new String [ ] { STRING , jobIdFileContent . get ( _NUM ) } ; return runProcess ( null , slurmCmd , new StringBuilder ( ) , new StringBuilder ( ) ) ; } else { LOG . log ( Level . SEVERE , STRING , jobIdFile ) ; return _BOOL ; } }
public boolean killJob ( String jobIdFile ) { List < String > jobIdFileContent = readFromFile ( jobIdFile ) ; if ( jobIdFileContent . size ( ) > _NUM ) { String [ ] slurmCmd = new String [ ] { STRING , jobIdFileContent . get ( _NUM ) } ; return runProcess ( null , slurmCmd , new StringBuilder ( ) , new StringBuilder ( ) ) ; } else { LOG . log ( Level . SEVERE , STRING , jobIdFile ) ; return _BOOL ; } }
public boolean killJob ( String jobIdFile ) { List < String > jobIdFileContent = readFromFile ( jobIdFile ) ; if ( jobIdFileContent . size ( ) > _NUM ) { String [ ] slurmCmd = new String [ ] { STRING , jobIdFileContent . get ( _NUM ) } ; return runProcess ( null , slurmCmd , new StringBuilder ( ) , new StringBuilder ( ) ) ; } else { LOG . log ( Level . SEVERE , STRING , jobIdFile ) ; return _BOOL ; } }
public boolean killJob ( String jobIdFile ) { List < String > jobIdFileContent = readFromFile ( jobIdFile ) ; if ( jobIdFileContent . size ( ) > _NUM ) { String [ ] slurmCmd = new String [ ] { STRING , jobIdFileContent . get ( _NUM ) } ; return runProcess ( null , slurmCmd , new StringBuilder ( ) , new StringBuilder ( ) ) ; } else { LOG . log ( Level . SEVERE , STRING , jobIdFile ) ; return _BOOL ; } }
protected static void checkGetAndDestroy ( ) { assertNull ( TXLockService . getDTLS ( ) ) ; TXLockService dtls = TXLockService . createDTLS ( ) ; assertNotNull ( dtls ) ; assertEquals ( _BOOL , dtls == TXLockService . getDTLS ( ) ) ; assertEquals ( _BOOL , dtls . isDestroyed ( ) ) ; TXLockService . destroyServices ( ) ; assertEquals ( _BOOL , dtls . isDestroyed ( ) ) ; assertNull ( TXLockService . getDTLS ( ) ) ; dtls = TXLockService . createDTLS ( ) ; assertNotNull ( dtls ) ; assertEquals ( _BOOL , dtls == TXLockService . getDTLS ( ) ) ; assertEquals ( _BOOL , dtls . isDestroyed ( ) ) ; }
public boolean matches ( GridCacheVersion ver , UUID nodeId , long threadId ) { return ver . equals ( this . ver ) || ( nodeId . equals ( this . nodeId ) && threadId == this . threadId ) ; }
public boolean matches ( GridCacheVersion ver , UUID nodeId , long threadId ) { return ver . equals ( this . ver ) || ( nodeId . equals ( this . nodeId ) && threadId == this . threadId ) ; }
boolean isLocalAuthenticationValid ( ) { if ( localPrivateKey != null ) { try { localPrivateKey . getAlgorithm ( ) ; } catch ( Exception e ) { invalidate ( ) ; return _BOOL ; } } return _BOOL ; }
boolean isLocalAuthenticationValid ( ) { if ( localPrivateKey != null ) { try { localPrivateKey . getAlgorithm ( ) ; } catch ( Exception e ) { invalidate ( ) ; return _BOOL ; } } return _BOOL ; }
public File suffixedFile ( String suffix , boolean gzip ) { return new File ( mBaseFile . getParentFile ( ) , mBaseFile . getName ( ) + suffix + mExtension + ( gzip ? FileUtils . GZ_SUFFIX : STRING ) ) ; }
public File suffixedFile ( String suffix , boolean gzip ) { return new File ( mBaseFile . getParentFile ( ) , mBaseFile . getName ( ) + suffix + mExtension + ( gzip ? FileUtils . GZ_SUFFIX : STRING ) ) ; }
public static Timestamp toTimestamp ( String string ) { if ( string == null ) return null ; else try { return Timestamp . valueOf ( string ) ; } catch ( Throwable t ) { return null ; } }
public void flushDiskCache ( ) { synchronized ( mDiskCacheLock ) { long now = System . currentTimeMillis ( ) ; if ( now - _NUM < mLastFlushTime ) { return ; } mLastFlushTime = now ; if ( mDiskLruCache != null ) { try { mDiskLruCache . flush ( ) ; if ( DEBUG ) { Log . d ( TAG , STRING ) ; } } catch ( IOException e ) { Log . e ( TAG , STRING + e ) ; } } } }
public boolean add ( AccessibleRelation relation ) { if ( relations == null ) { relations = new Vector ( ) ; } AccessibleRelation existingRelation = get ( relation . getKey ( ) ) ; if ( existingRelation == null ) { relations . addElement ( relation ) ; return _BOOL ; } else { Object [ ] existingTarget = existingRelation . getTarget ( ) ; Object [ ] newTarget = relation . getTarget ( ) ; int mergedLength = existingTarget . length + newTarget . length ; Object [ ] mergedTarget = new Object [ mergedLength ] ; for ( int i = _NUM ; i < existingTarget . length ; i ++ ) { mergedTarget [ i ] = existingTarget [ i ] ; } for ( int i = existingTarget . length , j = _NUM ; i < mergedLength ; i ++ , j ++ ) { mergedTarget [ i ] = newTarget [ j ] ; } existingRelation . setTarget ( mergedTarget ) ; } return _BOOL ; }
private void updateUser ( User user , boolean refreshAvatar ) { this . user = user ; if ( avatar == null ) { return ; } if ( avatar . getDrawable ( ) == null || refreshAvatar ) { loadAvatar ( ! refreshAvatar ) ; } if ( user . getPoints ( ) != null ) { long points = user . getPoints ( ) ; Level level = new Level ( points ) ; levelText . setText ( String . valueOf ( level . getLevel ( ) ) ) ; } followView . setUser ( user , userHandler , client ) ; decideEditLinks ( ) ; }
public static Future < ? > submit ( Runnable task ) { return THREAD_POOL . submit ( task ) ; }
public static Future < ? > submit ( Runnable task ) { return THREAD_POOL . submit ( task ) ; }
public void removeImmunity ( StatusType statusType ) { RPEntity entity = entityRef . get ( ) ; if ( entity == null ) { return ; } immunities . remove ( statusType ) ; entity . sendPrivateText ( STRING + statusType . getName ( ) + STRING ) ; }
private boolean regionDialingFromMatchesNumber ( PhoneNumber number , String regionDialingFrom ) { List < String > regionCodes = getRegionCodesForCountryCode ( number . getCountryCode ( ) ) ; return regionCodes . contains ( regionDialingFrom ) ; }
private boolean regionDialingFromMatchesNumber ( PhoneNumber number , String regionDialingFrom ) { List < String > regionCodes = getRegionCodesForCountryCode ( number . getCountryCode ( ) ) ; return regionCodes . contains ( regionDialingFrom ) ; }
private boolean regionDialingFromMatchesNumber ( PhoneNumber number , String regionDialingFrom ) { List < String > regionCodes = getRegionCodesForCountryCode ( number . getCountryCode ( ) ) ; return regionCodes . contains ( regionDialingFrom ) ; }
@ Override public void makeImmutable ( ) { if ( isMutable ) { if ( authnStatements != null ) { int length = authnStatements . size ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { AuthnStatement authn = ( AuthnStatement ) authnStatements . get ( i ) ; authn . makeImmutable ( ) ; } authnStatements = Collections . unmodifiableList ( authnStatements ) ; } if ( authzDecisionStatements != null ) { int length = authzDecisionStatements . size ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { AuthzDecisionStatement authz = ( AuthzDecisionStatement ) authzDecisionStatements . get ( i ) ; authz . makeImmutable ( ) ; } authzDecisionStatements = Collections . unmodifiableList ( authzDecisionStatements ) ; } if ( attributeStatements != null ) { int length = attributeStatements . size ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { AttributeStatement attr = ( AttributeStatement ) attributeStatements . get ( i ) ; attr . makeImmutable ( ) ; } attributeStatements = Collections . unmodifiableList ( attributeStatements ) ; } if ( statements != null ) { statements = Collections . unmodifiableList ( statements ) ; } if ( conditions != null ) { conditions . makeImmutable ( ) ; } if ( issuer != null ) { issuer . makeImmutable ( ) ; } if ( subject != null ) { subject . makeImmutable ( ) ; } if ( advice != null ) { advice . makeImmutable ( ) ; } isMutable = _BOOL ; } }
void renderShadowMap ( ) { glUseProgram ( shadowProgram ) ; glUniformMatrix4fv ( shadowProgramVPUniform , _BOOL , light . get ( matrixBuffer ) ) ; glBindFramebuffer ( GL_FRAMEBUFFER , fbo ) ; glViewport ( _NUM , _NUM , shadowMapSize , shadowMapSize ) ; glClear ( GL_DEPTH_BUFFER_BIT ) ; glBindVertexArray ( vao ) ; glDrawArrays ( GL_TRIANGLES , _NUM , _NUM * _NUM * boxes . length ) ; glBindVertexArray ( _NUM ) ; glBindFramebuffer ( GL_FRAMEBUFFER , _NUM ) ; glUseProgram ( _NUM ) ; }
protected void removeColumns ( Collection < String > removeColumnNames , String tableName ) { if ( removeColumnNames != null && ! removeColumnNames . isEmpty ( ) ) { execute ( getRemoveColumnSQLs ( removeColumnNames , tableName ) , mDb ) ; } }
protected void removeColumns ( Collection < String > removeColumnNames , String tableName ) { if ( removeColumnNames != null && ! removeColumnNames . isEmpty ( ) ) { execute ( getRemoveColumnSQLs ( removeColumnNames , tableName ) , mDb ) ; } }
protected void removeColumns ( Collection < String > removeColumnNames , String tableName ) { if ( removeColumnNames != null && ! removeColumnNames . isEmpty ( ) ) { execute ( getRemoveColumnSQLs ( removeColumnNames , tableName ) , mDb ) ; } }
protected void removeColumns ( Collection < String > removeColumnNames , String tableName ) { if ( removeColumnNames != null && ! removeColumnNames . isEmpty ( ) ) { execute ( getRemoveColumnSQLs ( removeColumnNames , tableName ) , mDb ) ; } }
protected void removeColumns ( Collection < String > removeColumnNames , String tableName ) { if ( removeColumnNames != null && ! removeColumnNames . isEmpty ( ) ) { execute ( getRemoveColumnSQLs ( removeColumnNames , tableName ) , mDb ) ; } }
public void updateKernelComboBox ( JComboBox < String > box ) { box . removeAllItems ( ) ; box . addItem ( NONE ) ; for ( String kernelName : getKernelNameList ( ) ) { box . addItem ( kernelName ) ; } }
@ Override public < U extends Comparable < ? super U > > CompletableFuture < Optional < T > > maxBy ( final Function < ? super T , ? extends U > function ) { return CompletableFuture . supplyAsync ( null ) ; }
@ Override public < U extends Comparable < ? super U > > CompletableFuture < Optional < T > > maxBy ( final Function < ? super T , ? extends U > function ) { return CompletableFuture . supplyAsync ( null ) ; }
@ Override public < U extends Comparable < ? super U > > CompletableFuture < Optional < T > > maxBy ( final Function < ? super T , ? extends U > function ) { return CompletableFuture . supplyAsync ( null ) ; }
public void output ( PrintWriter out ) { Element element = null ; Enumeration < Element > data = ec . elements ( ) ; while ( data . hasMoreElements ( ) ) { element = data . nextElement ( ) ; element . output ( out ) ; } }
@ DataProvider ( name = STRING ) public Object [ ] [ ] classProvider ( ) { return TESTING_CLASSES ; }
public final int [ ] hashSignature ( final int [ ] signature ) { int [ ] hash = new int [ stages ] ; int rows = signature . length / stages ; for ( int i = _NUM ; i < signature . length ; i ++ ) { int stage = Math . min ( i / rows , stages - _NUM ) ; hash [ stage ] = ( int ) ( ( hash [ stage ] + ( long ) signature [ i ] * LARGE_PRIME ) % buckets ) ; } return hash ; }
public String makeStringLiteralSQ ( String value ) { if ( value == null ) { return this . literalSQStringDefault ; } else if ( value . isEmpty ( ) ) { return STRING ; } else if ( ! value . contains ( STRING ) ) { return STRING + value + STRING ; } else { return STRING + makeStringValueSQ ( value ) + STRING ; } }
public void write ( char [ ] buf ) throws IOException { if ( writer != null ) { writer . write ( buf ) ; } else { write ( buf , _NUM , buf . length ) ; } }
public void write ( char [ ] buf ) throws IOException { if ( writer != null ) { writer . write ( buf ) ; } else { write ( buf , _NUM , buf . length ) ; } }
public void write ( char [ ] buf ) throws IOException { if ( writer != null ) { writer . write ( buf ) ; } else { write ( buf , _NUM , buf . length ) ; } }
public void addMetadata ( String name , String value ) { if ( ( name != null ) && ( value != null ) ) { Metadata m = new Metadata ( name , value ) ; _metadata . add ( m ) ; } }
public String clientAppId ( ) { return ( String ) httpRequest . getAttribute ( AuthenticationFilter . AuthenticatedRoleAttributeName ) ; }
public void test_multipleWrites ( ) { final IRawStore store = getStore ( ) ; try { final int limit = _NUM ; final long [ ] addrs = new long [ limit ] ; final byte [ ] [ ] records = new byte [ limit ] [ ] ; for ( int i = _NUM ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . nextInt ( _NUM ) + _NUM ] ; r . nextBytes ( expected ) ; final ByteBuffer tmp = ByteBuffer . wrap ( expected ) ; final long addr = store . write ( tmp ) ; assertEquals ( expected . length , tmp . position ( ) ) ; assertEquals ( tmp . position ( ) , tmp . limit ( ) ) ; assertEquals ( expected , store . read ( addr ) ) ; addrs [ i ] = addr ; records [ i ] = expected ; } final int [ ] order = getRandomOrder ( limit ) ; for ( int i = _NUM ; i < limit ; i ++ ) { final long addr = addrs [ order [ i ] ] ; final byte [ ] expected = records [ order [ i ] ] ; assertEquals ( expected , store . read ( addr ) ) ; } } finally { store . destroy ( ) ; } }
public void test_multipleWrites ( ) { final IRawStore store = getStore ( ) ; try { final int limit = _NUM ; final long [ ] addrs = new long [ limit ] ; final byte [ ] [ ] records = new byte [ limit ] [ ] ; for ( int i = _NUM ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . nextInt ( _NUM ) + _NUM ] ; r . nextBytes ( expected ) ; final ByteBuffer tmp = ByteBuffer . wrap ( expected ) ; final long addr = store . write ( tmp ) ; assertEquals ( expected . length , tmp . position ( ) ) ; assertEquals ( tmp . position ( ) , tmp . limit ( ) ) ; assertEquals ( expected , store . read ( addr ) ) ; addrs [ i ] = addr ; records [ i ] = expected ; } final int [ ] order = getRandomOrder ( limit ) ; for ( int i = _NUM ; i < limit ; i ++ ) { final long addr = addrs [ order [ i ] ] ; final byte [ ] expected = records [ order [ i ] ] ; assertEquals ( expected , store . read ( addr ) ) ; } } finally { store . destroy ( ) ; } }
public void test_multipleWrites ( ) { final IRawStore store = getStore ( ) ; try { final int limit = _NUM ; final long [ ] addrs = new long [ limit ] ; final byte [ ] [ ] records = new byte [ limit ] [ ] ; for ( int i = _NUM ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . nextInt ( _NUM ) + _NUM ] ; r . nextBytes ( expected ) ; final ByteBuffer tmp = ByteBuffer . wrap ( expected ) ; final long addr = store . write ( tmp ) ; assertEquals ( expected . length , tmp . position ( ) ) ; assertEquals ( tmp . position ( ) , tmp . limit ( ) ) ; assertEquals ( expected , store . read ( addr ) ) ; addrs [ i ] = addr ; records [ i ] = expected ; } final int [ ] order = getRandomOrder ( limit ) ; for ( int i = _NUM ; i < limit ; i ++ ) { final long addr = addrs [ order [ i ] ] ; final byte [ ] expected = records [ order [ i ] ] ; assertEquals ( expected , store . read ( addr ) ) ; } } finally { store . destroy ( ) ; } }
public void test_multipleWrites ( ) { final IRawStore store = getStore ( ) ; try { final int limit = _NUM ; final long [ ] addrs = new long [ limit ] ; final byte [ ] [ ] records = new byte [ limit ] [ ] ; for ( int i = _NUM ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . nextInt ( _NUM ) + _NUM ] ; r . nextBytes ( expected ) ; final ByteBuffer tmp = ByteBuffer . wrap ( expected ) ; final long addr = store . write ( tmp ) ; assertEquals ( expected . length , tmp . position ( ) ) ; assertEquals ( tmp . position ( ) , tmp . limit ( ) ) ; assertEquals ( expected , store . read ( addr ) ) ; addrs [ i ] = addr ; records [ i ] = expected ; } final int [ ] order = getRandomOrder ( limit ) ; for ( int i = _NUM ; i < limit ; i ++ ) { final long addr = addrs [ order [ i ] ] ; final byte [ ] expected = records [ order [ i ] ] ; assertEquals ( expected , store . read ( addr ) ) ; } } finally { store . destroy ( ) ; } }
public void test_multipleWrites ( ) { final IRawStore store = getStore ( ) ; try { final int limit = _NUM ; final long [ ] addrs = new long [ limit ] ; final byte [ ] [ ] records = new byte [ limit ] [ ] ; for ( int i = _NUM ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . nextInt ( _NUM ) + _NUM ] ; r . nextBytes ( expected ) ; final ByteBuffer tmp = ByteBuffer . wrap ( expected ) ; final long addr = store . write ( tmp ) ; assertEquals ( expected . length , tmp . position ( ) ) ; assertEquals ( tmp . position ( ) , tmp . limit ( ) ) ; assertEquals ( expected , store . read ( addr ) ) ; addrs [ i ] = addr ; records [ i ] = expected ; } final int [ ] order = getRandomOrder ( limit ) ; for ( int i = _NUM ; i < limit ; i ++ ) { final long addr = addrs [ order [ i ] ] ; final byte [ ] expected = records [ order [ i ] ] ; assertEquals ( expected , store . read ( addr ) ) ; } } finally { store . destroy ( ) ; } }
public void test_multipleWrites ( ) { final IRawStore store = getStore ( ) ; try { final int limit = _NUM ; final long [ ] addrs = new long [ limit ] ; final byte [ ] [ ] records = new byte [ limit ] [ ] ; for ( int i = _NUM ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . nextInt ( _NUM ) + _NUM ] ; r . nextBytes ( expected ) ; final ByteBuffer tmp = ByteBuffer . wrap ( expected ) ; final long addr = store . write ( tmp ) ; assertEquals ( expected . length , tmp . position ( ) ) ; assertEquals ( tmp . position ( ) , tmp . limit ( ) ) ; assertEquals ( expected , store . read ( addr ) ) ; addrs [ i ] = addr ; records [ i ] = expected ; } final int [ ] order = getRandomOrder ( limit ) ; for ( int i = _NUM ; i < limit ; i ++ ) { final long addr = addrs [ order [ i ] ] ; final byte [ ] expected = records [ order [ i ] ] ; assertEquals ( expected , store . read ( addr ) ) ; } } finally { store . destroy ( ) ; } }
public void addComment ( Comment comment ) { assertNotNull ( comment ) ; if ( comments == null ) { comments = new TreeSet < Comment > ( new AstNode . PositionComparator ( ) ) ; } comments . add ( comment ) ; comment . setParent ( this ) ; }
synchronized public Event end ( ) { if ( complete ) { throw new IllegalStateException ( ) ; } complete = _BOOL ; endTime = System . currentTimeMillis ( ) ; if ( startTime == _NUM ) { startTime = endTime ; } try { sendEvent ( ) ; } catch ( Throwable t ) { log . warn ( t ) ; } return this ; }
public void add ( XMPPathSegment segment ) { segments . add ( segment ) ; }
protected void init ( ) { if ( ! isInit ) { Terminal [ ] terminals = Reflection . getTerminals ( ) ; NonTerminal [ ] nonTerminals = Reflection . getNonTerminals ( ) ; symbolValueClasses = Reflection . getSymbolValueClasses ( terminals , nonTerminals ) ; isInit = _BOOL ; } }
public void enableInputMethods ( boolean enable ) { if ( enable ) { if ( ( eventMask & AWTEvent . INPUT_METHODS_ENABLED_MASK ) != _NUM ) return ; if ( isFocusOwner ( ) ) { InputContext inputContext = getInputContext ( ) ; if ( inputContext != null ) { FocusEvent focusGainedEvent = new FocusEvent ( this , FocusEvent . FOCUS_GAINED ) ; inputContext . dispatchEvent ( focusGainedEvent ) ; } } eventMask |= AWTEvent . INPUT_METHODS_ENABLED_MASK ; } else { if ( ( eventMask & AWTEvent . INPUT_METHODS_ENABLED_MASK ) != _NUM ) { InputContext inputContext = getInputContext ( ) ; if ( inputContext != null ) { inputContext . endComposition ( ) ; inputContext . removeNotify ( this ) ; } } eventMask &= ~ AWTEvent . INPUT_METHODS_ENABLED_MASK ; } }
private void executeMove ( @ NonNull DecoEvent event ) { if ( ( event . getEventType ( ) != DecoEvent . EventType . EVENT_MOVE ) && ( event . getEventType ( ) != DecoEvent . EventType . EVENT_COLOR_CHANGE ) ) { return ; } if ( mChartSeries != null ) { if ( mChartSeries . size ( ) <= event . getIndexPosition ( ) ) { throw new IllegalArgumentException ( STRING + event . getIndexPosition ( ) + STRING + mChartSeries . size ( ) + STRING ) ; } final int index = event . getIndexPosition ( ) ; if ( index >= _NUM && index < mChartSeries . size ( ) ) { ChartSeries item = mChartSeries . get ( event . getIndexPosition ( ) ) ; if ( event . getEventType ( ) == DecoEvent . EventType . EVENT_COLOR_CHANGE ) { item . startAnimateColorChange ( event ) ; } else { item . startAnimateMove ( event ) ; } } else { Log . e ( TAG , STRING + index + STRING + mChartSeries . size ( ) ) ; } } }
public static String readLine ( InputStream in , String charset ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; while ( _BOOL ) { int b = in . read ( ) ; if ( b == - _NUM ) { if ( baos . size ( ) == _NUM ) { return null ; } else { break ; } } if ( b == STRING ) { break ; } if ( b != STRING ) { baos . write ( b ) ; continue ; } int b2 = in . read ( ) ; if ( b2 == - _NUM ) { baos . write ( b ) ; break ; } if ( b2 == STRING ) { break ; } baos . write ( b ) ; baos . write ( b2 ) ; } return baos . toString ( charset ) ; }
@ RpcMethod public void copyImage ( String imageId , String source , String destination , AsyncMethodCallback < Host . AsyncClient . copy_image_call > handler ) throws RpcException { ensureClient ( ) ; CopyImageRequest copyImageRequest = new CopyImageRequest ( ) ; copyImageRequest . setSource ( Util . constructImage ( source , imageId ) ) ; copyImageRequest . setDestination ( Util . constructImage ( destination , imageId ) ) ; logger . info ( STRING , getHostIp ( ) , copyImageRequest ) ; try { clientProxy . copy_image ( copyImageRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
@ RpcMethod public void copyImage ( String imageId , String source , String destination , AsyncMethodCallback < Host . AsyncClient . copy_image_call > handler ) throws RpcException { ensureClient ( ) ; CopyImageRequest copyImageRequest = new CopyImageRequest ( ) ; copyImageRequest . setSource ( Util . constructImage ( source , imageId ) ) ; copyImageRequest . setDestination ( Util . constructImage ( destination , imageId ) ) ; logger . info ( STRING , getHostIp ( ) , copyImageRequest ) ; try { clientProxy . copy_image ( copyImageRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
@ RpcMethod public void copyImage ( String imageId , String source , String destination , AsyncMethodCallback < Host . AsyncClient . copy_image_call > handler ) throws RpcException { ensureClient ( ) ; CopyImageRequest copyImageRequest = new CopyImageRequest ( ) ; copyImageRequest . setSource ( Util . constructImage ( source , imageId ) ) ; copyImageRequest . setDestination ( Util . constructImage ( destination , imageId ) ) ; logger . info ( STRING , getHostIp ( ) , copyImageRequest ) ; try { clientProxy . copy_image ( copyImageRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
@ RpcMethod public void copyImage ( String imageId , String source , String destination , AsyncMethodCallback < Host . AsyncClient . copy_image_call > handler ) throws RpcException { ensureClient ( ) ; CopyImageRequest copyImageRequest = new CopyImageRequest ( ) ; copyImageRequest . setSource ( Util . constructImage ( source , imageId ) ) ; copyImageRequest . setDestination ( Util . constructImage ( destination , imageId ) ) ; logger . info ( STRING , getHostIp ( ) , copyImageRequest ) ; try { clientProxy . copy_image ( copyImageRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
public IResource [ ] promptForMultiple ( ) throws InterruptedException { List targetResources = new ArrayList ( ) ; for ( int i = _NUM ; i < resources . length ; i ++ ) { IResource resource = resources [ i ] ; if ( condition . needsPrompt ( resource ) && confirmOverwrite ) { if ( confirmOverwrite ( condition . promptMessage ( resource ) ) ) { targetResources . add ( resource ) ; } } else { targetResources . add ( resource ) ; } } return ( IResource [ ] ) targetResources . toArray ( new IResource [ targetResources . size ( ) ] ) ; }
public IResource [ ] promptForMultiple ( ) throws InterruptedException { List targetResources = new ArrayList ( ) ; for ( int i = _NUM ; i < resources . length ; i ++ ) { IResource resource = resources [ i ] ; if ( condition . needsPrompt ( resource ) && confirmOverwrite ) { if ( confirmOverwrite ( condition . promptMessage ( resource ) ) ) { targetResources . add ( resource ) ; } } else { targetResources . add ( resource ) ; } } return ( IResource [ ] ) targetResources . toArray ( new IResource [ targetResources . size ( ) ] ) ; }
public void sendMessage ( String type , String key , String value ) { if ( type . equals ( SET_CONFIG_TYPE ) ) { sendSetConfigMessage ( key , value ) ; } else { throw new IllegalArgumentException ( STRING + SET_CONFIG_TYPE + STRING ) ; } }
public void sendMessage ( String type , String key , String value ) { if ( type . equals ( SET_CONFIG_TYPE ) ) { sendSetConfigMessage ( key , value ) ; } else { throw new IllegalArgumentException ( STRING + SET_CONFIG_TYPE + STRING ) ; } }
public void sendMessage ( String type , String key , String value ) { if ( type . equals ( SET_CONFIG_TYPE ) ) { sendSetConfigMessage ( key , value ) ; } else { throw new IllegalArgumentException ( STRING + SET_CONFIG_TYPE + STRING ) ; } }
public void sendMessage ( String type , String key , String value ) { if ( type . equals ( SET_CONFIG_TYPE ) ) { sendSetConfigMessage ( key , value ) ; } else { throw new IllegalArgumentException ( STRING + SET_CONFIG_TYPE + STRING ) ; } }
@ Override public String createEmrCluster ( String clusterName , EmrClusterDefinition emrClusterDefinition , AwsParamsDto awsParams ) { return emrOperations . runEmrJobFlow ( getEmrClient ( awsParams ) , getRunJobFlowRequest ( clusterName , emrClusterDefinition ) ) ; }
public void writeRawLittleEndian64 ( final long value ) throws IOException { if ( buffer . remaining ( ) < _NUM ) { throw new OutOfSpaceException ( buffer . position ( ) , buffer . limit ( ) ) ; } buffer . putLong ( value ) ; }
@ Nullable public byte [ ] findClassDefinition ( @ NotNull String name , @ NotNull AppResourceRepository appRepo ) { int index = name . lastIndexOf ( STRING ) ; if ( index != - _NUM && name . charAt ( index + _NUM ) == STRING && ( index == name . length ( ) - _NUM || name . charAt ( index + _NUM ) == STRING ) && index > _NUM ) { String pkg = name . substring ( _NUM , index ) ; if ( myPackages != null && myPackages . contains ( pkg ) ) { AarResourceClassGenerator generator = myGeneratorMap . get ( appRepo ) ; if ( generator != null ) { return generator . generate ( name ) ; } } } return null ; }
public void init ( CipherParameters params ) throws IllegalArgumentException { if ( params instanceof ParametersWithIV ) { ParametersWithIV ivParam = ( ParametersWithIV ) params ; byte [ ] iv = ivParam . getIV ( ) ; if ( iv . length < IV . length ) { System . arraycopy ( iv , _NUM , IV , IV . length - iv . length , iv . length ) ; } else { System . arraycopy ( iv , _NUM , IV , _NUM , IV . length ) ; } reset ( ) ; cipher . init ( _BOOL , ivParam . getParameters ( ) ) ; } else { reset ( ) ; cipher . init ( _BOOL , params ) ; } }
public void init ( CipherParameters params ) throws IllegalArgumentException { if ( params instanceof ParametersWithIV ) { ParametersWithIV ivParam = ( ParametersWithIV ) params ; byte [ ] iv = ivParam . getIV ( ) ; if ( iv . length < IV . length ) { System . arraycopy ( iv , _NUM , IV , IV . length - iv . length , iv . length ) ; } else { System . arraycopy ( iv , _NUM , IV , _NUM , IV . length ) ; } reset ( ) ; cipher . init ( _BOOL , ivParam . getParameters ( ) ) ; } else { reset ( ) ; cipher . init ( _BOOL , params ) ; } }
public boolean acceptsOwnerName ( String owner ) { if ( _ownerOption . equals ( ALL_OWNERS ) ) { return _BOOL ; } if ( _ownerOption . equals ( INCLUDE_OWNERS ) ) { return _ownerList . contains ( owner ) ; } return ! _ownerList . contains ( owner ) ; }
@ LayoutlibDelegate static long currentThreadTimeMicro ( ) { return System . currentTimeMillis ( ) * _NUM ; }
public static int countNnz ( String [ ] cols , int pos , int len ) { int lnnz = _NUM ; for ( int i = pos ; i < pos + len ; i ++ ) { String col = cols [ i ] ; lnnz += ( ! col . isEmpty ( ) && ! col . equals ( STRING ) && ! col . equals ( STRING ) ) ? _NUM : _NUM ; } return lnnz ; }
public static int countNnz ( String [ ] cols , int pos , int len ) { int lnnz = _NUM ; for ( int i = pos ; i < pos + len ; i ++ ) { String col = cols [ i ] ; lnnz += ( ! col . isEmpty ( ) && ! col . equals ( STRING ) && ! col . equals ( STRING ) ) ? _NUM : _NUM ; } return lnnz ; }
public JarFileLister ( ZipFile zipFile , DependenciesListener builder , ClassFileReader reader , ProgressListener progress ) { this . zipFile = zipFile ; this . builder = builder ; this . reader = reader ; this . progress = progress ; }
public JarFileLister ( ZipFile zipFile , DependenciesListener builder , ClassFileReader reader , ProgressListener progress ) { this . zipFile = zipFile ; this . builder = builder ; this . reader = reader ; this . progress = progress ; }
public JarFileLister ( ZipFile zipFile , DependenciesListener builder , ClassFileReader reader , ProgressListener progress ) { this . zipFile = zipFile ; this . builder = builder ; this . reader = reader ; this . progress = progress ; }
public JarFileLister ( ZipFile zipFile , DependenciesListener builder , ClassFileReader reader , ProgressListener progress ) { this . zipFile = zipFile ; this . builder = builder ; this . reader = reader ; this . progress = progress ; }
protected void processSpecialAttributes ( Node node ) { processStateAttributes ( node , component ) ; }
protected void processSpecialAttributes ( Node node ) { processStateAttributes ( node , component ) ; }
protected void processSpecialAttributes ( Node node ) { processStateAttributes ( node , component ) ; }
private void createTextField ( JPanel parentPanel , String label , JTextField textField , int fieldWidth ) { JPanel panel = new JPanel ( ) ; panel . setLayout ( null ) ; parentPanel . add ( panel ) ; JLabel lblName = new JLabel ( label ) ; lblName . setHorizontalAlignment ( SwingConstants . TRAILING ) ; lblName . setBounds ( LABEL_X_START , _NUM , LABEL_WIDTH , FIELD_HEIGHT ) ; panel . add ( lblName ) ; textField . setBounds ( LABEL_X_START + LABEL_WIDTH + FIELD_X_OFFSET , _NUM , fieldWidth , FIELD_HEIGHT ) ; textField . setColumns ( _NUM ) ; panel . add ( textField ) ; }
public void putIcon ( String extension , Icon icon ) { icons . put ( extension , icon ) ; }
private void run ( ) { try { Thread current = Thread . currentThread ( ) ; byte [ ] buf = new byte [ _NUM ] ; for ( int len = in . read ( buf ) ; len != - _NUM ; len = in . read ( buf ) ) { buffer . write ( buf , _NUM , len ) ; if ( current != thread ) { break ; } } buffer . flush ( ) ; buffer . close ( ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } }
@ Override protected void doBefore ( ) { filePrefs . add ( new ApplicationPreference ( STRING ) ) ; filePrefs . add ( new ApplicationPreference ( STRING ) ) ; persistedPrefs . add ( new ApplicationPreference ( PERSISTED_APP_PREF1 ) ) ; persistedPrefs . add ( new ApplicationPreference ( PERSISTED_APP_PREF2 ) ) ; }
public static double angle ( Coordinate p0 , Coordinate p1 ) { double dx = p1 . x - p0 . x ; double dy = p1 . y - p0 . y ; return Math . atan2 ( dy , dx ) ; }
public static double angle ( Coordinate p0 , Coordinate p1 ) { double dx = p1 . x - p0 . x ; double dy = p1 . y - p0 . y ; return Math . atan2 ( dy , dx ) ; }
@ Override public int hashCode ( ) { int result = _NUM ; result = _NUM * result + type ; result = _NUM * result + Arrays . hashCode ( encoded ) ; return result ; }
@ Override public void paintText ( SynthContext ss , Graphics g , String text , int x , int y , int mnemonicIndex ) { Graphics2D g2 = ( Graphics2D ) g ; if ( desktopHints == null ) { Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; desktopHints = ( Map < ? , ? > ) ( toolkit . getDesktopProperty ( STRING ) ) ; } Object oldAA = null ; RenderingHints oldHints = null ; if ( desktopHints != null ) { oldHints = getRenderingHints ( g2 , desktopHints , null ) ; g2 . addRenderingHints ( desktopHints ) ; } else { oldAA = g2 . getRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING ) ; g2 . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; } super . paintText ( ss , g , text , x , y , mnemonicIndex ) ; if ( oldHints != null ) g2 . addRenderingHints ( oldHints ) ; else if ( oldAA != null ) g2 . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , oldAA ) ; }
@ Override public void paintText ( SynthContext ss , Graphics g , String text , int x , int y , int mnemonicIndex ) { Graphics2D g2 = ( Graphics2D ) g ; if ( desktopHints == null ) { Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; desktopHints = ( Map < ? , ? > ) ( toolkit . getDesktopProperty ( STRING ) ) ; } Object oldAA = null ; RenderingHints oldHints = null ; if ( desktopHints != null ) { oldHints = getRenderingHints ( g2 , desktopHints , null ) ; g2 . addRenderingHints ( desktopHints ) ; } else { oldAA = g2 . getRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING ) ; g2 . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; } super . paintText ( ss , g , text , x , y , mnemonicIndex ) ; if ( oldHints != null ) g2 . addRenderingHints ( oldHints ) ; else if ( oldAA != null ) g2 . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , oldAA ) ; }
int putData ( Object data ) throws FitsException { long lsize = ArrayFuncs . computeLSize ( data ) ; if ( lsize > Integer . MAX_VALUE ) { throw new FitsException ( STRING ) ; } int size = ( int ) lsize ; expandHeap ( size ) ; ByteArrayOutputStream bo = new ByteArrayOutputStream ( size ) ; try { BufferedDataOutputStream o = new BufferedDataOutputStream ( bo ) ; o . writeArray ( data ) ; o . flush ( ) ; o . close ( ) ; } catch ( IOException e ) { throw new FitsException ( STRING , e ) ; } System . arraycopy ( bo . toByteArray ( ) , _NUM , this . heap , this . heapSize , size ) ; int oldOffset = this . heapSize ; this . heapSize += size ; return oldOffset ; }
private void populateAvailableDataStores ( ) { DataAccessFactory fac ; logger . debug ( STRING ) ; Iterator < DataStoreFactorySpi > iterator = DataStoreFinder . getAvailableDataStores ( ) ; while ( iterator . hasNext ( ) ) { fac = ( DataAccessFactory ) iterator . next ( ) ; logger . debug ( STRING + fac . getDisplayName ( ) ) ; availableDataStoreList . add ( fac . getDisplayName ( ) ) ; } }
private void handleCommand ( int id , String command , String params ) { String originCommand = commandId . get ( id ) ; if ( originCommand == null ) { originCommand = STRING ; } handler . handleCommand ( id , command , params , originCommand ) ; if ( command . equals ( STRING ) ) { LOGGER . warning ( STRING + params ) ; } }
public static double mad ( final double [ ] data ) { double mad = _NUM ; if ( data . length > _NUM ) { double median = median ( data ) ; double [ ] deviationSum = new double [ data . length ] ; for ( int i = _NUM ; i < data . length ; i ++ ) { deviationSum [ i ] = Math . abs ( median - data [ i ] ) ; } mad = median ( deviationSum ) ; } return mad ; }
public boolean equals ( Object o ) { return ( o != null ) && ( o . getClass ( ) == Instruction . class ) && equals ( ( Instruction ) o ) ; }
public boolean equals ( Object o ) { return ( o != null ) && ( o . getClass ( ) == Instruction . class ) && equals ( ( Instruction ) o ) ; }
static boolean isPackageAccess ( final int modifiers ) { return ( modifiers & MemberUtils . ACCESS_TEST ) == _NUM ; }
static boolean isPackageAccess ( final int modifiers ) { return ( modifiers & MemberUtils . ACCESS_TEST ) == _NUM ; }
public static TimeOfDay hourAndMinuteFromDate ( Date dateTime , TimeZone tz ) { if ( dateTime == null ) return null ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( dateTime ) ; if ( tz != null ) cal . setTimeZone ( tz ) ; return new TimeOfDay ( cal . get ( Calendar . HOUR_OF_DAY ) , cal . get ( Calendar . MINUTE ) ) ; }
public static TimeOfDay hourAndMinuteFromDate ( Date dateTime , TimeZone tz ) { if ( dateTime == null ) return null ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( dateTime ) ; if ( tz != null ) cal . setTimeZone ( tz ) ; return new TimeOfDay ( cal . get ( Calendar . HOUR_OF_DAY ) , cal . get ( Calendar . MINUTE ) ) ; }
public static TimeOfDay hourAndMinuteFromDate ( Date dateTime , TimeZone tz ) { if ( dateTime == null ) return null ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( dateTime ) ; if ( tz != null ) cal . setTimeZone ( tz ) ; return new TimeOfDay ( cal . get ( Calendar . HOUR_OF_DAY ) , cal . get ( Calendar . MINUTE ) ) ; }
private String extractSignatureId ( UseKeyType useKey , SecurityHeaderType header ) { assert header != null ; String signatureId = null ; if ( useKey != null ) { signatureId = useKey . getSig ( ) ; if ( header . getSignature ( ) == null || ! signatureId . equalsIgnoreCase ( header . getSignature ( ) . getId ( ) ) ) { throw new InvalidSecurityHeaderException ( STRING ) ; } } return signatureId ; }
private String extractSignatureId ( UseKeyType useKey , SecurityHeaderType header ) { assert header != null ; String signatureId = null ; if ( useKey != null ) { signatureId = useKey . getSig ( ) ; if ( header . getSignature ( ) == null || ! signatureId . equalsIgnoreCase ( header . getSignature ( ) . getId ( ) ) ) { throw new InvalidSecurityHeaderException ( STRING ) ; } } return signatureId ; }
private void moveTo ( float x , float y ) { mPath . moveTo ( mLastX = x , mLastY = y ) ; }
private char stringChar ( ) throws JsonParserException { int c = advanceChar ( ) ; if ( c == - _NUM ) throw createParseException ( null , STRING , _BOOL ) ; if ( c < _NUM ) throw createParseException ( null , STRING + Integer . toString ( c , _NUM ) , _BOOL ) ; return ( char ) c ; }
public int interpElevationAt ( float lat , float lon ) { if ( frame_is_valid == _BOOL ) { if ( lat >= dsi . sw_lat && lat <= dsi . ne_lat && lon >= dsi . sw_lon && lon <= dsi . ne_lon ) { float lat_index = ( lat - dsi . sw_lat ) * _NUM / uhl . lat_post_interval ; float lon_index = ( lon - dsi . sw_lon ) * _NUM / uhl . lon_post_interval ; int lflon_index = ( int ) Math . floor ( lon_index ) ; int lclon_index = ( int ) Math . ceil ( lon_index ) ; int lclat_index = ( int ) Math . ceil ( lat_index ) ; if ( elevations [ lflon_index ] == null ) readDataRecord ( lflon_index ) ; if ( elevations [ lclon_index ] == null ) readDataRecord ( lclon_index ) ; int ul = elevations [ lflon_index ] [ lclat_index ] ; int ur = elevations [ lclon_index ] [ lclat_index ] ; int ll = elevations [ lflon_index ] [ lclat_index ] ; int lr = elevations [ lclon_index ] [ lclat_index ] ; float answer = resolveFourPoints ( ul , ur , lr , ll , lat_index , lon_index ) ; return Math . round ( answer ) ; } } return - _NUM ; }
protected void reportMetricsIfNeeded ( ) { if ( getGatherPerformanceMetrics ( ) ) { if ( ( System . currentTimeMillis ( ) - this . metricsLastReportedMs ) > getReportMetricsIntervalMillis ( ) ) { reportMetrics ( ) ; } } }
public void waitForSchemaAgreement ( String targetSchemaVersion , int nodeCount ) { long start = System . currentTimeMillis ( ) ; Map < String , List < String > > versions = null ; while ( System . currentTimeMillis ( ) - start < MAX_SCHEMA_WAIT_MS ) { log . info ( STRING , targetSchemaVersion , nodeCount ) ; versions = getSchemaVersions ( ) ; if ( versions . size ( ) == _NUM ) { if ( ! versions . containsKey ( targetSchemaVersion ) ) { log . warn ( STRING , versions , targetSchemaVersion ) ; return ; } if ( nodeCount != - _NUM ) { List < String > hosts = null ; for ( Entry < String , List < String > > entry : versions . entrySet ( ) ) { hosts = entry . getValue ( ) ; } if ( hosts != null && hosts . size ( ) == nodeCount ) { log . info ( STRING , targetSchemaVersion , nodeCount ) ; return ; } } else { log . info ( STRING , targetSchemaVersion ) ; return ; } } log . info ( STRING ) ; try { Thread . sleep ( SCHEMA_RETRY_SLEEP_MILLIS ) ; } catch ( InterruptedException ex ) { } } log . warn ( STRING , versions ) ; }
public void waitForSchemaAgreement ( String targetSchemaVersion , int nodeCount ) { long start = System . currentTimeMillis ( ) ; Map < String , List < String > > versions = null ; while ( System . currentTimeMillis ( ) - start < MAX_SCHEMA_WAIT_MS ) { log . info ( STRING , targetSchemaVersion , nodeCount ) ; versions = getSchemaVersions ( ) ; if ( versions . size ( ) == _NUM ) { if ( ! versions . containsKey ( targetSchemaVersion ) ) { log . warn ( STRING , versions , targetSchemaVersion ) ; return ; } if ( nodeCount != - _NUM ) { List < String > hosts = null ; for ( Entry < String , List < String > > entry : versions . entrySet ( ) ) { hosts = entry . getValue ( ) ; } if ( hosts != null && hosts . size ( ) == nodeCount ) { log . info ( STRING , targetSchemaVersion , nodeCount ) ; return ; } } else { log . info ( STRING , targetSchemaVersion ) ; return ; } } log . info ( STRING ) ; try { Thread . sleep ( SCHEMA_RETRY_SLEEP_MILLIS ) ; } catch ( InterruptedException ex ) { } } log . warn ( STRING , versions ) ; }
private void loadOrgAccessAdd ( ArrayList < OrgAccess > list , OrgAccess oa ) { if ( list . contains ( oa ) ) return ; list . add ( oa ) ; if ( getAD_Tree_Org_ID ( ) == _NUM ) return ; MOrg org = MOrg . get ( getCtx ( ) , oa . AD_Org_ID ) ; if ( ! org . isSummary ( ) ) return ; MTree_Base tree = MTree_Base . get ( getCtx ( ) , getAD_Tree_Org_ID ( ) , get_TrxName ( ) ) ; String sql = STRING + STRING + tree . getNodeTableName ( ) + STRING ; PreparedStatement pstmt = null ; ResultSet rs = null ; try { pstmt = DB . prepareStatement ( sql , get_TrxName ( ) ) ; pstmt . setInt ( _NUM , tree . getAD_Tree_ID ( ) ) ; pstmt . setInt ( _NUM , org . getAD_Org_ID ( ) ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { int AD_Client_ID = rs . getInt ( _NUM ) ; int AD_Org_ID = rs . getInt ( _NUM ) ; loadOrgAccessAdd ( list , new OrgAccess ( AD_Client_ID , AD_Org_ID , oa . readOnly ) ) ; } } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } }
private void loadOrgAccessAdd ( ArrayList < OrgAccess > list , OrgAccess oa ) { if ( list . contains ( oa ) ) return ; list . add ( oa ) ; if ( getAD_Tree_Org_ID ( ) == _NUM ) return ; MOrg org = MOrg . get ( getCtx ( ) , oa . AD_Org_ID ) ; if ( ! org . isSummary ( ) ) return ; MTree_Base tree = MTree_Base . get ( getCtx ( ) , getAD_Tree_Org_ID ( ) , get_TrxName ( ) ) ; String sql = STRING + STRING + tree . getNodeTableName ( ) + STRING ; PreparedStatement pstmt = null ; ResultSet rs = null ; try { pstmt = DB . prepareStatement ( sql , get_TrxName ( ) ) ; pstmt . setInt ( _NUM , tree . getAD_Tree_ID ( ) ) ; pstmt . setInt ( _NUM , org . getAD_Org_ID ( ) ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { int AD_Client_ID = rs . getInt ( _NUM ) ; int AD_Org_ID = rs . getInt ( _NUM ) ; loadOrgAccessAdd ( list , new OrgAccess ( AD_Client_ID , AD_Org_ID , oa . readOnly ) ) ; } } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } }
private List < Statistics > removeSucceeded ( List < Statistics > statistics ) { List < Statistics > result = new ArrayList < > ( ) ; for ( Statistics statistic : statistics ) { if ( ! statistic . getSucceeded ( ) ) result . add ( statistic ) ; } return result ; }
private List < Statistics > removeSucceeded ( List < Statistics > statistics ) { List < Statistics > result = new ArrayList < > ( ) ; for ( Statistics statistic : statistics ) { if ( ! statistic . getSucceeded ( ) ) result . add ( statistic ) ; } return result ; }
public void doEditChartProperties ( ) { ChartEditor editor = ChartEditorManager . getChartEditor ( this . chart ) ; int result = JOptionPane . showConfirmDialog ( this , editor , localizationResources . getString ( STRING ) , JOptionPane . OK_CANCEL_OPTION , JOptionPane . PLAIN_MESSAGE ) ; if ( result == JOptionPane . OK_OPTION ) { editor . updateChart ( this . chart ) ; } }
public void doEditChartProperties ( ) { ChartEditor editor = ChartEditorManager . getChartEditor ( this . chart ) ; int result = JOptionPane . showConfirmDialog ( this , editor , localizationResources . getString ( STRING ) , JOptionPane . OK_CANCEL_OPTION , JOptionPane . PLAIN_MESSAGE ) ; if ( result == JOptionPane . OK_OPTION ) { editor . updateChart ( this . chart ) ; } }
public void doEditChartProperties ( ) { ChartEditor editor = ChartEditorManager . getChartEditor ( this . chart ) ; int result = JOptionPane . showConfirmDialog ( this , editor , localizationResources . getString ( STRING ) , JOptionPane . OK_CANCEL_OPTION , JOptionPane . PLAIN_MESSAGE ) ; if ( result == JOptionPane . OK_OPTION ) { editor . updateChart ( this . chart ) ; } }
public void doEditChartProperties ( ) { ChartEditor editor = ChartEditorManager . getChartEditor ( this . chart ) ; int result = JOptionPane . showConfirmDialog ( this , editor , localizationResources . getString ( STRING ) , JOptionPane . OK_CANCEL_OPTION , JOptionPane . PLAIN_MESSAGE ) ; if ( result == JOptionPane . OK_OPTION ) { editor . updateChart ( this . chart ) ; } }
public void release ( ) { ReentrantLock lock = Bridge . getLock ( ) ; if ( lock . isHeldByCurrentThread ( ) ) { tearDown ( ) ; lock . unlock ( ) ; } }
public StatusComponent ( ) { STEPPING = _BOOL ; NF = null ; LABEL = new JLabel ( ) ; BAR = new JProgressBar ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; construct ( ) ; GUIUtils . setOpaque ( _BOOL , this ) ; if ( BAR != null && ! OSUtils . isMacOSX ( ) ) { BAR . setOpaque ( _BOOL ) ; } BAR . setIndeterminate ( _BOOL ) ; }
private String buildVirtualVolumeName ( List < String > nativeVolumeNames ) { s_logger . info ( STRING ) ; StringBuilder nameBuilder = new StringBuilder ( ) ; if ( nativeVolumeNames . size ( ) == _NUM ) { nameBuilder . append ( VPlexApiConstants . DEVICE_PREFIX ) ; nameBuilder . append ( nativeVolumeNames . get ( _NUM ) ) ; nameBuilder . append ( VPlexApiConstants . VIRTUAL_VOLUME_SUFFIX ) ; } else { nameBuilder . append ( VPlexApiConstants . DIST_DEVICE_PREFIX ) ; for ( String nativeVolumeName : nativeVolumeNames ) { nameBuilder . append ( VPlexApiConstants . DIST_DEVICE_NAME_DELIM ) ; nameBuilder . append ( nativeVolumeName ) ; } nameBuilder . append ( VPlexApiConstants . VIRTUAL_VOLUME_SUFFIX ) ; } s_logger . info ( STRING , nameBuilder . toString ( ) ) ; return nameBuilder . toString ( ) ; }
private String buildVirtualVolumeName ( List < String > nativeVolumeNames ) { s_logger . info ( STRING ) ; StringBuilder nameBuilder = new StringBuilder ( ) ; if ( nativeVolumeNames . size ( ) == _NUM ) { nameBuilder . append ( VPlexApiConstants . DEVICE_PREFIX ) ; nameBuilder . append ( nativeVolumeNames . get ( _NUM ) ) ; nameBuilder . append ( VPlexApiConstants . VIRTUAL_VOLUME_SUFFIX ) ; } else { nameBuilder . append ( VPlexApiConstants . DIST_DEVICE_PREFIX ) ; for ( String nativeVolumeName : nativeVolumeNames ) { nameBuilder . append ( VPlexApiConstants . DIST_DEVICE_NAME_DELIM ) ; nameBuilder . append ( nativeVolumeName ) ; } nameBuilder . append ( VPlexApiConstants . VIRTUAL_VOLUME_SUFFIX ) ; } s_logger . info ( STRING , nameBuilder . toString ( ) ) ; return nameBuilder . toString ( ) ; }
public static boolean isValidVector ( Vector2f vector ) { if ( vector == null ) return _BOOL ; if ( Float . isNaN ( vector . x ) || Float . isNaN ( vector . y ) ) return _BOOL ; if ( Float . isInfinite ( vector . x ) || Float . isInfinite ( vector . y ) ) return _BOOL ; return _BOOL ; }
public boolean mustRefresh ( ) { try { if ( currentSnapshot == null || sourceFile . countFiles ( ) != currentSnapshot . size ( ) ) return _BOOL ; if ( currentOpenFile != null ) { if ( ! Files . exists ( currentOpenFile . getPath ( ) ) ) { LOGGER . debug ( STRING , currentOpenFile . getPath ( ) ) ; return _BOOL ; } BasicFileAttributes newAttr = Files . readAttributes ( currentOpenFile . getPath ( ) , BasicFileAttributes . class ) ; FileId newId = FileId . get ( newAttr ) ; if ( ! newId . equals ( currentOpenFile . getId ( ) ) ) { LOGGER . debug ( STRING , currentOpenFile . getPath ( ) , currentOpenFile . getId ( ) , newId ) ; return _BOOL ; } if ( newAttr . size ( ) < currentOpenFile . getSize ( ) ) { LOGGER . debug ( STRING , currentOpenFile . getPath ( ) , currentOpenFile . getSize ( ) , newAttr . size ( ) ) ; return _BOOL ; } } } catch ( IOException e ) { LOGGER . error ( STRING , e ) ; return _BOOL ; } return _BOOL ; }
public boolean mustRefresh ( ) { try { if ( currentSnapshot == null || sourceFile . countFiles ( ) != currentSnapshot . size ( ) ) return _BOOL ; if ( currentOpenFile != null ) { if ( ! Files . exists ( currentOpenFile . getPath ( ) ) ) { LOGGER . debug ( STRING , currentOpenFile . getPath ( ) ) ; return _BOOL ; } BasicFileAttributes newAttr = Files . readAttributes ( currentOpenFile . getPath ( ) , BasicFileAttributes . class ) ; FileId newId = FileId . get ( newAttr ) ; if ( ! newId . equals ( currentOpenFile . getId ( ) ) ) { LOGGER . debug ( STRING , currentOpenFile . getPath ( ) , currentOpenFile . getId ( ) , newId ) ; return _BOOL ; } if ( newAttr . size ( ) < currentOpenFile . getSize ( ) ) { LOGGER . debug ( STRING , currentOpenFile . getPath ( ) , currentOpenFile . getSize ( ) , newAttr . size ( ) ) ; return _BOOL ; } } } catch ( IOException e ) { LOGGER . error ( STRING , e ) ; return _BOOL ; } return _BOOL ; }
public boolean mustRefresh ( ) { try { if ( currentSnapshot == null || sourceFile . countFiles ( ) != currentSnapshot . size ( ) ) return _BOOL ; if ( currentOpenFile != null ) { if ( ! Files . exists ( currentOpenFile . getPath ( ) ) ) { LOGGER . debug ( STRING , currentOpenFile . getPath ( ) ) ; return _BOOL ; } BasicFileAttributes newAttr = Files . readAttributes ( currentOpenFile . getPath ( ) , BasicFileAttributes . class ) ; FileId newId = FileId . get ( newAttr ) ; if ( ! newId . equals ( currentOpenFile . getId ( ) ) ) { LOGGER . debug ( STRING , currentOpenFile . getPath ( ) , currentOpenFile . getId ( ) , newId ) ; return _BOOL ; } if ( newAttr . size ( ) < currentOpenFile . getSize ( ) ) { LOGGER . debug ( STRING , currentOpenFile . getPath ( ) , currentOpenFile . getSize ( ) , newAttr . size ( ) ) ; return _BOOL ; } } } catch ( IOException e ) { LOGGER . error ( STRING , e ) ; return _BOOL ; } return _BOOL ; }
public static byte [ ] toByteArray ( String spacedHex ) { int idx = _NUM ; final int len = spacedHex . length ( ) ; final StringBuilder sb = new StringBuilder ( ) ; final ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; while ( idx < len ) { final char chr = spacedHex . charAt ( idx ++ ) ; if ( chr != STRING ) { sb . setLength ( _NUM ) ; sb . append ( chr ) ; sb . append ( spacedHex . charAt ( idx ++ ) ) ; final int i = Integer . parseInt ( sb . toString ( ) , _NUM ) ; final byte b = ( ( byte ) i ) ; bytes . write ( b ) ; } } return bytes . toByteArray ( ) ; }
public static boolean renameFile ( final File fromFile , final File toFile ) { File toFile2 = toFile ; if ( fromFile . renameTo ( toFile ) ) { return _BOOL ; } if ( ! fromFile . exists ( ) ) { return _BOOL ; } if ( ! fromFile . canRead ( ) ) { return _BOOL ; } if ( toFile . isDirectory ( ) ) { toFile2 = new File ( toFile , fromFile . getName ( ) ) ; } if ( toFile2 . exists ( ) ) { return _BOOL ; } String parent = toFile2 . getParent ( ) ; if ( parent == null ) parent = System . getProperty ( STRING ) ; File dir = new File ( parent ) ; if ( ! dir . exists ( ) ) { return _BOOL ; } if ( ! dir . canWrite ( ) ) { return _BOOL ; } try { copyFile ( fromFile , toFile2 ) ; } catch ( UncheckedIOException e ) { if ( toFile2 . exists ( ) ) toFile2 . delete ( ) ; return _BOOL ; } fromFile . delete ( ) ; return _BOOL ; }
public static boolean renameFile ( final File fromFile , final File toFile ) { File toFile2 = toFile ; if ( fromFile . renameTo ( toFile ) ) { return _BOOL ; } if ( ! fromFile . exists ( ) ) { return _BOOL ; } if ( ! fromFile . canRead ( ) ) { return _BOOL ; } if ( toFile . isDirectory ( ) ) { toFile2 = new File ( toFile , fromFile . getName ( ) ) ; } if ( toFile2 . exists ( ) ) { return _BOOL ; } String parent = toFile2 . getParent ( ) ; if ( parent == null ) parent = System . getProperty ( STRING ) ; File dir = new File ( parent ) ; if ( ! dir . exists ( ) ) { return _BOOL ; } if ( ! dir . canWrite ( ) ) { return _BOOL ; } try { copyFile ( fromFile , toFile2 ) ; } catch ( UncheckedIOException e ) { if ( toFile2 . exists ( ) ) toFile2 . delete ( ) ; return _BOOL ; } fromFile . delete ( ) ; return _BOOL ; }
public static boolean renameFile ( final File fromFile , final File toFile ) { File toFile2 = toFile ; if ( fromFile . renameTo ( toFile ) ) { return _BOOL ; } if ( ! fromFile . exists ( ) ) { return _BOOL ; } if ( ! fromFile . canRead ( ) ) { return _BOOL ; } if ( toFile . isDirectory ( ) ) { toFile2 = new File ( toFile , fromFile . getName ( ) ) ; } if ( toFile2 . exists ( ) ) { return _BOOL ; } String parent = toFile2 . getParent ( ) ; if ( parent == null ) parent = System . getProperty ( STRING ) ; File dir = new File ( parent ) ; if ( ! dir . exists ( ) ) { return _BOOL ; } if ( ! dir . canWrite ( ) ) { return _BOOL ; } try { copyFile ( fromFile , toFile2 ) ; } catch ( UncheckedIOException e ) { if ( toFile2 . exists ( ) ) toFile2 . delete ( ) ; return _BOOL ; } fromFile . delete ( ) ; return _BOOL ; }
public static boolean renameFile ( final File fromFile , final File toFile ) { File toFile2 = toFile ; if ( fromFile . renameTo ( toFile ) ) { return _BOOL ; } if ( ! fromFile . exists ( ) ) { return _BOOL ; } if ( ! fromFile . canRead ( ) ) { return _BOOL ; } if ( toFile . isDirectory ( ) ) { toFile2 = new File ( toFile , fromFile . getName ( ) ) ; } if ( toFile2 . exists ( ) ) { return _BOOL ; } String parent = toFile2 . getParent ( ) ; if ( parent == null ) parent = System . getProperty ( STRING ) ; File dir = new File ( parent ) ; if ( ! dir . exists ( ) ) { return _BOOL ; } if ( ! dir . canWrite ( ) ) { return _BOOL ; } try { copyFile ( fromFile , toFile2 ) ; } catch ( UncheckedIOException e ) { if ( toFile2 . exists ( ) ) toFile2 . delete ( ) ; return _BOOL ; } fromFile . delete ( ) ; return _BOOL ; }
public static boolean renameFile ( final File fromFile , final File toFile ) { File toFile2 = toFile ; if ( fromFile . renameTo ( toFile ) ) { return _BOOL ; } if ( ! fromFile . exists ( ) ) { return _BOOL ; } if ( ! fromFile . canRead ( ) ) { return _BOOL ; } if ( toFile . isDirectory ( ) ) { toFile2 = new File ( toFile , fromFile . getName ( ) ) ; } if ( toFile2 . exists ( ) ) { return _BOOL ; } String parent = toFile2 . getParent ( ) ; if ( parent == null ) parent = System . getProperty ( STRING ) ; File dir = new File ( parent ) ; if ( ! dir . exists ( ) ) { return _BOOL ; } if ( ! dir . canWrite ( ) ) { return _BOOL ; } try { copyFile ( fromFile , toFile2 ) ; } catch ( UncheckedIOException e ) { if ( toFile2 . exists ( ) ) toFile2 . delete ( ) ; return _BOOL ; } fromFile . delete ( ) ; return _BOOL ; }
public static boolean renameFile ( final File fromFile , final File toFile ) { File toFile2 = toFile ; if ( fromFile . renameTo ( toFile ) ) { return _BOOL ; } if ( ! fromFile . exists ( ) ) { return _BOOL ; } if ( ! fromFile . canRead ( ) ) { return _BOOL ; } if ( toFile . isDirectory ( ) ) { toFile2 = new File ( toFile , fromFile . getName ( ) ) ; } if ( toFile2 . exists ( ) ) { return _BOOL ; } String parent = toFile2 . getParent ( ) ; if ( parent == null ) parent = System . getProperty ( STRING ) ; File dir = new File ( parent ) ; if ( ! dir . exists ( ) ) { return _BOOL ; } if ( ! dir . canWrite ( ) ) { return _BOOL ; } try { copyFile ( fromFile , toFile2 ) ; } catch ( UncheckedIOException e ) { if ( toFile2 . exists ( ) ) toFile2 . delete ( ) ; return _BOOL ; } fromFile . delete ( ) ; return _BOOL ; }
public MediaConfig createChannelImageAttachment ( String file , MediaConfig config ) { config . addCredentials ( this ) ; String xml = POSTIMAGE ( this . url + STRING , file , config . name , config . toXML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { MediaConfig media = new MediaConfig ( ) ; media . parseXML ( root ) ; return media ; } catch ( Exception exception ) { this . exception = SDKException . parseFailure ( exception ) ; throw this . exception ; } }
private boolean isUploadSizeAndFrequencyAllowed ( ) { if ( mFileToUpload . length ( ) > LOG_SIZE_LIMIT_BYTES ) return _BOOL ; if ( mSharedPreferences . getInt ( PREF_LAST_UPLOAD_DAY , _NUM ) != getCurrentDay ( ) ) return _BOOL ; return mSharedPreferences . getInt ( PREF_UPLOAD_COUNT , _NUM ) < LOG_UPLOAD_LIMIT_PER_DAY ; }
private boolean isUploadSizeAndFrequencyAllowed ( ) { if ( mFileToUpload . length ( ) > LOG_SIZE_LIMIT_BYTES ) return _BOOL ; if ( mSharedPreferences . getInt ( PREF_LAST_UPLOAD_DAY , _NUM ) != getCurrentDay ( ) ) return _BOOL ; return mSharedPreferences . getInt ( PREF_UPLOAD_COUNT , _NUM ) < LOG_UPLOAD_LIMIT_PER_DAY ; }
private void removeUselessTask ( ProxyReg reg ) { List pendingTasks = cacheTaskMgr . getPending ( ) ; for ( int i = _NUM ; i < pendingTasks . size ( ) ; i ++ ) { CacheTask t = ( CacheTask ) pendingTasks . get ( i ) ; if ( t . isFromProxy ( reg ) ) cacheTaskMgr . remove ( t ) ; } }
public static String fakeSignature ( String qualifiedName ) { String cname = qualifiedName . substring ( _NUM , qualifiedName . lastIndexOf ( STRING ) ) ; String mname = qualifiedName . substring ( qualifiedName . lastIndexOf ( STRING ) + _NUM , qualifiedName . length ( ) ) ; return STRING + cname + STRING + mname + STRING ; }
private void valuesTester ( final int treeSize , final Collection < String > values ) { int counter = _NUM ; for ( String value : values ) { counter ++ ; } assertEquals ( treeSize , counter ) ; assertEquals ( treeSize , values . size ( ) ) ; }
private void valuesTester ( final int treeSize , final Collection < String > values ) { int counter = _NUM ; for ( String value : values ) { counter ++ ; } assertEquals ( treeSize , counter ) ; assertEquals ( treeSize , values . size ( ) ) ; }
public static void appendEscapedSQLString ( StringBuilder sb , String sqlString ) { sb . append ( STRING ) ; if ( sqlString . indexOf ( STRING ) != - _NUM ) { int length = sqlString . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = sqlString . charAt ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sqlString ) ; } sb . append ( STRING ) ; }
public static void appendEscapedSQLString ( StringBuilder sb , String sqlString ) { sb . append ( STRING ) ; if ( sqlString . indexOf ( STRING ) != - _NUM ) { int length = sqlString . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = sqlString . charAt ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sqlString ) ; } sb . append ( STRING ) ; }
public static void appendEscapedSQLString ( StringBuilder sb , String sqlString ) { sb . append ( STRING ) ; if ( sqlString . indexOf ( STRING ) != - _NUM ) { int length = sqlString . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = sqlString . charAt ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sqlString ) ; } sb . append ( STRING ) ; }
public static void appendEscapedSQLString ( StringBuilder sb , String sqlString ) { sb . append ( STRING ) ; if ( sqlString . indexOf ( STRING ) != - _NUM ) { int length = sqlString . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = sqlString . charAt ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sqlString ) ; } sb . append ( STRING ) ; }
public static void appendEscapedSQLString ( StringBuilder sb , String sqlString ) { sb . append ( STRING ) ; if ( sqlString . indexOf ( STRING ) != - _NUM ) { int length = sqlString . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = sqlString . charAt ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sqlString ) ; } sb . append ( STRING ) ; }
public static void appendEscapedSQLString ( StringBuilder sb , String sqlString ) { sb . append ( STRING ) ; if ( sqlString . indexOf ( STRING ) != - _NUM ) { int length = sqlString . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = sqlString . charAt ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sqlString ) ; } sb . append ( STRING ) ; }
public static void appendEscapedSQLString ( StringBuilder sb , String sqlString ) { sb . append ( STRING ) ; if ( sqlString . indexOf ( STRING ) != - _NUM ) { int length = sqlString . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = sqlString . charAt ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sqlString ) ; } sb . append ( STRING ) ; }
public static void appendEscapedSQLString ( StringBuilder sb , String sqlString ) { sb . append ( STRING ) ; if ( sqlString . indexOf ( STRING ) != - _NUM ) { int length = sqlString . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = sqlString . charAt ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sqlString ) ; } sb . append ( STRING ) ; }
public static void appendEscapedSQLString ( StringBuilder sb , String sqlString ) { sb . append ( STRING ) ; if ( sqlString . indexOf ( STRING ) != - _NUM ) { int length = sqlString . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = sqlString . charAt ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sqlString ) ; } sb . append ( STRING ) ; }
public static void appendEscapedSQLString ( StringBuilder sb , String sqlString ) { sb . append ( STRING ) ; if ( sqlString . indexOf ( STRING ) != - _NUM ) { int length = sqlString . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = sqlString . charAt ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sqlString ) ; } sb . append ( STRING ) ; }
public static void appendEscapedSQLString ( StringBuilder sb , String sqlString ) { sb . append ( STRING ) ; if ( sqlString . indexOf ( STRING ) != - _NUM ) { int length = sqlString . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = sqlString . charAt ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sqlString ) ; } sb . append ( STRING ) ; }
public static void appendEscapedSQLString ( StringBuilder sb , String sqlString ) { sb . append ( STRING ) ; if ( sqlString . indexOf ( STRING ) != - _NUM ) { int length = sqlString . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = sqlString . charAt ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sqlString ) ; } sb . append ( STRING ) ; }
public static void appendEscapedSQLString ( StringBuilder sb , String sqlString ) { sb . append ( STRING ) ; if ( sqlString . indexOf ( STRING ) != - _NUM ) { int length = sqlString . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = sqlString . charAt ( i ) ; if ( c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } } else { sb . append ( sqlString ) ; } sb . append ( STRING ) ; }
private String isVolumeIngestable ( CIMInstance volumeInstance , String isBound , String usageProp , String unManagedVolumeNativeGuid , Map < String , Set < String > > duplicateSyncAspectElementNameMap ) { String usage = getCIMPropertyValue ( volumeInstance , usageProp ) ; if ( ! Boolean . valueOf ( isBound ) ) { return STRING ; } if ( ! ( TWO . equalsIgnoreCase ( usage ) || NINE . equalsIgnoreCase ( usage ) || SEVEN . equalsIgnoreCase ( usage ) || ELEVEN . equalsIgnoreCase ( usage ) || USAGE_LOCAL_REPLICA_TARGET . equalsIgnoreCase ( usage ) || USAGE_DELTA_REPLICA_TARGET . equalsIgnoreCase ( usage ) || USGAE_LOCAL_REPLICA_SOURCE . equalsIgnoreCase ( usage ) || USAGE_LOCAL_REPLICA_SOURCE_OR_TARGET . equalsIgnoreCase ( usage ) ) ) { return STRING ; } boolean hasUnsupportedSnapshotSessions = _BOOL ; if ( duplicateSyncAspectElementNameMap . containsKey ( unManagedVolumeNativeGuid ) ) { Set < String > duplicateSyncAspectElementNames = duplicateSyncAspectElementNameMap . get ( unManagedVolumeNativeGuid ) ; if ( ( duplicateSyncAspectElementNames != null ) && ( ! duplicateSyncAspectElementNames . isEmpty ( ) ) ) { hasUnsupportedSnapshotSessions = _BOOL ; } } if ( hasUnsupportedSnapshotSessions ) { return STRING + STRING + STRING ; } return null ; }
private String isVolumeIngestable ( CIMInstance volumeInstance , String isBound , String usageProp , String unManagedVolumeNativeGuid , Map < String , Set < String > > duplicateSyncAspectElementNameMap ) { String usage = getCIMPropertyValue ( volumeInstance , usageProp ) ; if ( ! Boolean . valueOf ( isBound ) ) { return STRING ; } if ( ! ( TWO . equalsIgnoreCase ( usage ) || NINE . equalsIgnoreCase ( usage ) || SEVEN . equalsIgnoreCase ( usage ) || ELEVEN . equalsIgnoreCase ( usage ) || USAGE_LOCAL_REPLICA_TARGET . equalsIgnoreCase ( usage ) || USAGE_DELTA_REPLICA_TARGET . equalsIgnoreCase ( usage ) || USGAE_LOCAL_REPLICA_SOURCE . equalsIgnoreCase ( usage ) || USAGE_LOCAL_REPLICA_SOURCE_OR_TARGET . equalsIgnoreCase ( usage ) ) ) { return STRING ; } boolean hasUnsupportedSnapshotSessions = _BOOL ; if ( duplicateSyncAspectElementNameMap . containsKey ( unManagedVolumeNativeGuid ) ) { Set < String > duplicateSyncAspectElementNames = duplicateSyncAspectElementNameMap . get ( unManagedVolumeNativeGuid ) ; if ( ( duplicateSyncAspectElementNames != null ) && ( ! duplicateSyncAspectElementNames . isEmpty ( ) ) ) { hasUnsupportedSnapshotSessions = _BOOL ; } } if ( hasUnsupportedSnapshotSessions ) { return STRING + STRING + STRING ; } return null ; }
private String isVolumeIngestable ( CIMInstance volumeInstance , String isBound , String usageProp , String unManagedVolumeNativeGuid , Map < String , Set < String > > duplicateSyncAspectElementNameMap ) { String usage = getCIMPropertyValue ( volumeInstance , usageProp ) ; if ( ! Boolean . valueOf ( isBound ) ) { return STRING ; } if ( ! ( TWO . equalsIgnoreCase ( usage ) || NINE . equalsIgnoreCase ( usage ) || SEVEN . equalsIgnoreCase ( usage ) || ELEVEN . equalsIgnoreCase ( usage ) || USAGE_LOCAL_REPLICA_TARGET . equalsIgnoreCase ( usage ) || USAGE_DELTA_REPLICA_TARGET . equalsIgnoreCase ( usage ) || USGAE_LOCAL_REPLICA_SOURCE . equalsIgnoreCase ( usage ) || USAGE_LOCAL_REPLICA_SOURCE_OR_TARGET . equalsIgnoreCase ( usage ) ) ) { return STRING ; } boolean hasUnsupportedSnapshotSessions = _BOOL ; if ( duplicateSyncAspectElementNameMap . containsKey ( unManagedVolumeNativeGuid ) ) { Set < String > duplicateSyncAspectElementNames = duplicateSyncAspectElementNameMap . get ( unManagedVolumeNativeGuid ) ; if ( ( duplicateSyncAspectElementNames != null ) && ( ! duplicateSyncAspectElementNames . isEmpty ( ) ) ) { hasUnsupportedSnapshotSessions = _BOOL ; } } if ( hasUnsupportedSnapshotSessions ) { return STRING + STRING + STRING ; } return null ; }
CompilationUnitCompletion ( ICompilationUnit unit ) { reset ( unit ) ; setIgnored ( CompletionProposal . ANONYMOUS_CLASS_DECLARATION , _BOOL ) ; setIgnored ( CompletionProposal . ANONYMOUS_CLASS_CONSTRUCTOR_INVOCATION , _BOOL ) ; setIgnored ( CompletionProposal . KEYWORD , _BOOL ) ; setIgnored ( CompletionProposal . LABEL_REF , _BOOL ) ; setIgnored ( CompletionProposal . METHOD_DECLARATION , _BOOL ) ; setIgnored ( CompletionProposal . METHOD_NAME_REFERENCE , _BOOL ) ; setIgnored ( CompletionProposal . METHOD_REF , _BOOL ) ; setIgnored ( CompletionProposal . CONSTRUCTOR_INVOCATION , _BOOL ) ; setIgnored ( CompletionProposal . METHOD_REF_WITH_CASTED_RECEIVER , _BOOL ) ; setIgnored ( CompletionProposal . PACKAGE_REF , _BOOL ) ; setIgnored ( CompletionProposal . POTENTIAL_METHOD_DECLARATION , _BOOL ) ; setIgnored ( CompletionProposal . VARIABLE_DECLARATION , _BOOL ) ; setIgnored ( CompletionProposal . TYPE_REF , _BOOL ) ; }
public static BartenderSystem createAndAddSystem ( BartenderBuilder builder ) { BartenderSystemFull systemBartender = new BartenderSystemFull ( builder ) ; SystemManager system = preCreate ( BartenderSystem . class ) ; system . addSystem ( BartenderSystem . class , systemBartender ) ; return systemBartender ; }
protected final void checkNamePresent ( ) { if ( ! name . isPresent ( ) ) { throw new IllegalStateException ( STRING ) ; } }
private static String convertCalendarToString ( Calendar calendar ) { if ( calendar != null ) { SimpleDateFormat sdf = new SimpleDateFormat ( LicenseConstants . MM_DD_YYYY_FORMAT ) ; return sdf . format ( calendar . getTime ( ) ) ; } else { return null ; } }
private static String convertCalendarToString ( Calendar calendar ) { if ( calendar != null ) { SimpleDateFormat sdf = new SimpleDateFormat ( LicenseConstants . MM_DD_YYYY_FORMAT ) ; return sdf . format ( calendar . getTime ( ) ) ; } else { return null ; } }
public void testToEngineeringStringZeroPosExponent ( ) { String a = STRING ; BigDecimal aNumber = new BigDecimal ( a ) ; String result = STRING ; assertEquals ( STRING , result , aNumber . toEngineeringString ( ) ) ; }
@ Constraints ( noNullInputs = _BOOL , notMutable = _BOOL , noDirectInsertion = _BOOL ) public static < T > void validateBean ( @ BoundInputVariable ( initializer = _BOOL , atMostOnceWithSameParameters = _BOOL ) T instance , Class < ? > clazz ) throws FalsePositiveException , IllegalArgumentException { Inputs . checkNull ( instance , clazz ) ; for ( Field f : getAllFieldsToInject ( clazz ) ) { f . setAccessible ( _BOOL ) ; try { Object obj = f . get ( instance ) ; if ( obj == null ) { throw new FalsePositiveException ( STRING + f . getName ( ) + STRING + clazz . getName ( ) ) ; } } catch ( IllegalAccessException e ) { logger . warn ( e . toString ( ) ) ; } } Class < ? > parent = clazz . getSuperclass ( ) ; if ( parent != null && ! parent . equals ( Object . class ) ) { validateBean ( instance , parent ) ; } }
@ Constraints ( noNullInputs = _BOOL , notMutable = _BOOL , noDirectInsertion = _BOOL ) public static < T > void validateBean ( @ BoundInputVariable ( initializer = _BOOL , atMostOnceWithSameParameters = _BOOL ) T instance , Class < ? > clazz ) throws FalsePositiveException , IllegalArgumentException { Inputs . checkNull ( instance , clazz ) ; for ( Field f : getAllFieldsToInject ( clazz ) ) { f . setAccessible ( _BOOL ) ; try { Object obj = f . get ( instance ) ; if ( obj == null ) { throw new FalsePositiveException ( STRING + f . getName ( ) + STRING + clazz . getName ( ) ) ; } } catch ( IllegalAccessException e ) { logger . warn ( e . toString ( ) ) ; } } Class < ? > parent = clazz . getSuperclass ( ) ; if ( parent != null && ! parent . equals ( Object . class ) ) { validateBean ( instance , parent ) ; } }
@ Constraints ( noNullInputs = _BOOL , notMutable = _BOOL , noDirectInsertion = _BOOL ) public static < T > void validateBean ( @ BoundInputVariable ( initializer = _BOOL , atMostOnceWithSameParameters = _BOOL ) T instance , Class < ? > clazz ) throws FalsePositiveException , IllegalArgumentException { Inputs . checkNull ( instance , clazz ) ; for ( Field f : getAllFieldsToInject ( clazz ) ) { f . setAccessible ( _BOOL ) ; try { Object obj = f . get ( instance ) ; if ( obj == null ) { throw new FalsePositiveException ( STRING + f . getName ( ) + STRING + clazz . getName ( ) ) ; } } catch ( IllegalAccessException e ) { logger . warn ( e . toString ( ) ) ; } } Class < ? > parent = clazz . getSuperclass ( ) ; if ( parent != null && ! parent . equals ( Object . class ) ) { validateBean ( instance , parent ) ; } }
public boolean writeHeader ( OutputStream os ) { try { writeInt ( os , CACHE_MAGIC ) ; writeString ( os , key ) ; writeString ( os , etag == null ? STRING : etag ) ; writeLong ( os , serverDate ) ; writeLong ( os , ttl ) ; writeStringStringMap ( responseHeaders , os ) ; os . flush ( ) ; return _BOOL ; } catch ( IOException e ) { Loger . debug ( String . format ( STRING , e . toString ( ) ) ) ; return _BOOL ; } }
public static EndpointDescription selectEndpoint ( EndpointDescription [ ] endpoints ) { if ( endpoints == null ) throw new IllegalArgumentException ( STRING ) ; endpoints = EndpointUtil . selectByProtocol ( endpoints , STRING ) ; endpoints = EndpointUtil . selectByMessageSecurityMode ( endpoints , MessageSecurityMode . SignAndEncrypt ) ; if ( endpoints . length == _NUM ) return null ; endpoints = EndpointUtil . sortBySecurityLevel ( endpoints ) ; EndpointUtil . reverse ( endpoints ) ; return endpoints [ _NUM ] ; }
public static EndpointDescription selectEndpoint ( EndpointDescription [ ] endpoints ) { if ( endpoints == null ) throw new IllegalArgumentException ( STRING ) ; endpoints = EndpointUtil . selectByProtocol ( endpoints , STRING ) ; endpoints = EndpointUtil . selectByMessageSecurityMode ( endpoints , MessageSecurityMode . SignAndEncrypt ) ; if ( endpoints . length == _NUM ) return null ; endpoints = EndpointUtil . sortBySecurityLevel ( endpoints ) ; EndpointUtil . reverse ( endpoints ) ; return endpoints [ _NUM ] ; }
public static EndpointDescription selectEndpoint ( EndpointDescription [ ] endpoints ) { if ( endpoints == null ) throw new IllegalArgumentException ( STRING ) ; endpoints = EndpointUtil . selectByProtocol ( endpoints , STRING ) ; endpoints = EndpointUtil . selectByMessageSecurityMode ( endpoints , MessageSecurityMode . SignAndEncrypt ) ; if ( endpoints . length == _NUM ) return null ; endpoints = EndpointUtil . sortBySecurityLevel ( endpoints ) ; EndpointUtil . reverse ( endpoints ) ; return endpoints [ _NUM ] ; }
public static EndpointDescription selectEndpoint ( EndpointDescription [ ] endpoints ) { if ( endpoints == null ) throw new IllegalArgumentException ( STRING ) ; endpoints = EndpointUtil . selectByProtocol ( endpoints , STRING ) ; endpoints = EndpointUtil . selectByMessageSecurityMode ( endpoints , MessageSecurityMode . SignAndEncrypt ) ; if ( endpoints . length == _NUM ) return null ; endpoints = EndpointUtil . sortBySecurityLevel ( endpoints ) ; EndpointUtil . reverse ( endpoints ) ; return endpoints [ _NUM ] ; }
private void drawText ( final Graphics2D g2d ) { g2d . translate ( - getScreenViewX ( ) , - getScreenViewY ( ) ) ; synchronized ( texts ) { Iterator < RemovableSprite > it = texts . iterator ( ) ; while ( it . hasNext ( ) ) { RemovableSprite text = it . next ( ) ; if ( ! text . shouldBeRemoved ( ) ) { text . draw ( g2d ) ; } else { it . remove ( ) ; } } } g2d . translate ( getScreenViewX ( ) , getScreenViewY ( ) ) ; synchronized ( staticSprites ) { Iterator < RemovableSprite > it = staticSprites . iterator ( ) ; while ( it . hasNext ( ) ) { RemovableSprite text = it . next ( ) ; if ( ! text . shouldBeRemoved ( ) ) { text . draw ( g2d ) ; } else { it . remove ( ) ; } } } }
public void render ( Graphics graphics ) { if ( getNeedToRegenerate ( ) || getNeedToReposition ( ) || ! isVisible ( ) ) { return ; } boolean smallWorld = bitmap != null && corners != null && corners . size ( ) >= _NUM ; if ( smallWorld ) { float [ ] xs = corners . get ( _NUM ) ; float [ ] ys = corners . get ( _NUM ) ; Point point1 = new Point ( ) ; point1 . setLocation ( ( double ) xs [ _NUM ] , ( double ) ys [ _NUM ] ) ; Point point2 = new Point ( ) ; point2 . setLocation ( ( double ) xs [ _NUM ] , ( double ) ys [ _NUM ] ) ; Graphics g = graphics . create ( ) ; if ( g instanceof Graphics2D && renderRotationAngle != null ) { rotate ( ( Graphics2D ) g ) ; } renderImage ( g , bitmap , point1 ) ; } super . render ( graphics ) ; }
public InputStream executeDownload ( String url , String cookie ) throws IOException { String [ ] [ ] headerParams = new String [ ] [ ] { { STRING , cookie } , { STRING , STRING } } ; HttpEntity httpEntity = executeGet ( url , null , headerParams ) ; return httpEntity . getContent ( ) ; }
public InputStream executeDownload ( String url , String cookie ) throws IOException { String [ ] [ ] headerParams = new String [ ] [ ] { { STRING , cookie } , { STRING , STRING } } ; HttpEntity httpEntity = executeGet ( url , null , headerParams ) ; return httpEntity . getContent ( ) ; }
@ AfterClass public static void afterClassBaseTest ( ) throws SQLException { if ( testSingleHost ) { if ( ! sharedConnection . isClosed ( ) ) { if ( ! tempViewList . isEmpty ( ) ) { Statement stmt = sharedConnection . createStatement ( ) ; String viewName ; while ( ( viewName = tempViewList . poll ( ) ) != null ) { try { stmt . execute ( STRING + viewName ) ; } catch ( SQLException e ) { } } } if ( ! tempTableList . isEmpty ( ) ) { Statement stmt = sharedConnection . createStatement ( ) ; String tableName ; while ( ( tableName = tempTableList . poll ( ) ) != null ) { try { stmt . execute ( STRING + tableName ) ; } catch ( SQLException e ) { } } } if ( ! tempProcedureList . isEmpty ( ) ) { Statement stmt = sharedConnection . createStatement ( ) ; String procedureName ; while ( ( procedureName = tempProcedureList . poll ( ) ) != null ) { try { stmt . execute ( STRING + procedureName ) ; } catch ( SQLException e ) { } } } if ( ! tempFunctionList . isEmpty ( ) ) { Statement stmt = sharedConnection . createStatement ( ) ; String functionName ; while ( ( functionName = tempFunctionList . poll ( ) ) != null ) { try { stmt . execute ( STRING + functionName ) ; } catch ( SQLException e ) { } } } } try { sharedConnection . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } } }
private void updateHeaderRow ( ) { int headerRow = ( int ) headerRowSpinner . getValue ( ) ; configuration . setHeaderRow ( headerRow - _NUM ) ; previewTable . repaint ( ) ; }
protected String indent ( String content , int count , String indentStr ) { String result ; StringTokenizer tok ; int i ; tok = new StringTokenizer ( content , STRING , _BOOL ) ; result = STRING ; while ( tok . hasMoreTokens ( ) ) { if ( result . endsWith ( STRING ) || ( result . length ( ) == _NUM ) ) { for ( i = _NUM ; i < count ; i ++ ) { result += indentStr ; } } result += tok . nextToken ( ) ; } return result ; }
public MultiplexManager ( DataStore ... dataStores ) { this . dataStores = Arrays . asList ( dataStores ) ; }
public MultiplexManager ( DataStore ... dataStores ) { this . dataStores = Arrays . asList ( dataStores ) ; }
public MultiplexManager ( DataStore ... dataStores ) { this . dataStores = Arrays . asList ( dataStores ) ; }
public void removeAttributeDefaults ( Set attrs ) throws SMSException , SSOException { SMSEntry . validateToken ( ssm . getSSOToken ( ) ) ; Iterator it = attrs . iterator ( ) ; while ( it . hasNext ( ) ) { String asName = ( String ) it . next ( ) ; AttributeSchema as = getAttributeSchema ( asName ) ; if ( as == null ) { throw ( new InvalidAttributeNameException ( IUMSConstants . UMS_BUNDLE_NAME , IUMSConstants . services_validator_invalid_attr_name , null ) ) ; } as . removeDefaultValues ( ) ; } }
public IPreparedGraphQuery prepareGraphQuery ( final String query ) throws Exception { return prepareGraphQuery ( query , UUID . randomUUID ( ) ) ; }
private Rectangle2D [ ] splitHorizontalBar ( RectangularShape bar , double a , double b , double c ) { Rectangle2D [ ] result = new Rectangle2D [ _NUM ] ; double y0 = bar . getMinY ( ) ; double y1 = Math . rint ( y0 + ( bar . getHeight ( ) * a ) ) ; double y2 = Math . rint ( y0 + ( bar . getHeight ( ) * b ) ) ; double y3 = Math . rint ( y0 + ( bar . getHeight ( ) * c ) ) ; result [ _NUM ] = new Rectangle2D . Double ( bar . getMinX ( ) , bar . getMinY ( ) , bar . getWidth ( ) , y1 - y0 ) ; result [ _NUM ] = new Rectangle2D . Double ( bar . getMinX ( ) , y1 , bar . getWidth ( ) , y2 - y1 ) ; result [ _NUM ] = new Rectangle2D . Double ( bar . getMinX ( ) , y2 , bar . getWidth ( ) , y3 - y2 ) ; result [ _NUM ] = new Rectangle2D . Double ( bar . getMinX ( ) , y3 , bar . getWidth ( ) , bar . getMaxY ( ) - y3 ) ; return result ; }
private Rectangle2D [ ] splitHorizontalBar ( RectangularShape bar , double a , double b , double c ) { Rectangle2D [ ] result = new Rectangle2D [ _NUM ] ; double y0 = bar . getMinY ( ) ; double y1 = Math . rint ( y0 + ( bar . getHeight ( ) * a ) ) ; double y2 = Math . rint ( y0 + ( bar . getHeight ( ) * b ) ) ; double y3 = Math . rint ( y0 + ( bar . getHeight ( ) * c ) ) ; result [ _NUM ] = new Rectangle2D . Double ( bar . getMinX ( ) , bar . getMinY ( ) , bar . getWidth ( ) , y1 - y0 ) ; result [ _NUM ] = new Rectangle2D . Double ( bar . getMinX ( ) , y1 , bar . getWidth ( ) , y2 - y1 ) ; result [ _NUM ] = new Rectangle2D . Double ( bar . getMinX ( ) , y2 , bar . getWidth ( ) , y3 - y2 ) ; result [ _NUM ] = new Rectangle2D . Double ( bar . getMinX ( ) , y3 , bar . getWidth ( ) , bar . getMaxY ( ) - y3 ) ; return result ; }
private Rectangle2D [ ] splitHorizontalBar ( RectangularShape bar , double a , double b , double c ) { Rectangle2D [ ] result = new Rectangle2D [ _NUM ] ; double y0 = bar . getMinY ( ) ; double y1 = Math . rint ( y0 + ( bar . getHeight ( ) * a ) ) ; double y2 = Math . rint ( y0 + ( bar . getHeight ( ) * b ) ) ; double y3 = Math . rint ( y0 + ( bar . getHeight ( ) * c ) ) ; result [ _NUM ] = new Rectangle2D . Double ( bar . getMinX ( ) , bar . getMinY ( ) , bar . getWidth ( ) , y1 - y0 ) ; result [ _NUM ] = new Rectangle2D . Double ( bar . getMinX ( ) , y1 , bar . getWidth ( ) , y2 - y1 ) ; result [ _NUM ] = new Rectangle2D . Double ( bar . getMinX ( ) , y2 , bar . getWidth ( ) , y3 - y2 ) ; result [ _NUM ] = new Rectangle2D . Double ( bar . getMinX ( ) , y3 , bar . getWidth ( ) , bar . getMaxY ( ) - y3 ) ; return result ; }
public boolean equals ( int ignoreOwnElement , Sequence sequence , int ignoreItsElement ) { int ownIndex = _NUM ; int itsIndex = _NUM ; Iterator < Item > ownIterator = itemIterator ( ) ; Iterator < Item > itsIterator = sequence . itemIterator ( ) ; while ( _BOOL ) { if ( ignoreOwnElement == ownIndex ) { ownIterator . next ( ) ; ownIndex ++ ; } if ( ignoreItsElement == itsIndex ) { itsIterator . next ( ) ; itsIndex ++ ; } if ( ! ownIterator . hasNext ( ) || ! itsIterator . hasNext ( ) ) { if ( ! ownIterator . hasNext ( ) && ! itsIterator . hasNext ( ) ) { return _BOOL ; } return _BOOL ; } Item ownItem = ownIterator . next ( ) ; Item itsItem = itsIterator . next ( ) ; ownIndex ++ ; itsIndex ++ ; if ( ! ownItem . equals ( itsItem ) ) { return _BOOL ; } } }
public static String eachMatch ( String self , Pattern pattern , @ ClosureParams ( value = FromString . class , options = { STRING , STRING } ) Closure closure ) { Matcher m = pattern . matcher ( self ) ; each ( m , closure ) ; return self ; }
public static String eachMatch ( String self , Pattern pattern , @ ClosureParams ( value = FromString . class , options = { STRING , STRING } ) Closure closure ) { Matcher m = pattern . matcher ( self ) ; each ( m , closure ) ; return self ; }
public static String eachMatch ( String self , Pattern pattern , @ ClosureParams ( value = FromString . class , options = { STRING , STRING } ) Closure closure ) { Matcher m = pattern . matcher ( self ) ; each ( m , closure ) ; return self ; }
public static String eachMatch ( String self , Pattern pattern , @ ClosureParams ( value = FromString . class , options = { STRING , STRING } ) Closure closure ) { Matcher m = pattern . matcher ( self ) ; each ( m , closure ) ; return self ; }
public void delItem ( int index ) { synchronized ( getMenuTreeLock ( ) ) { if ( selectedIndex == index ) { selectItem ( null , _BOOL ) ; } else if ( selectedIndex > index ) { selectedIndex -- ; } if ( index < items . size ( ) ) { items . remove ( index ) ; } else { if ( log . isLoggable ( PlatformLogger . Level . FINE ) ) { log . fine ( STRING + index + STRING + items . size ( ) ) ; } } } updateSize ( ) ; }
protected Socket __openPassiveDataConnection ( int command , String arg ) throws IOException , FtpExceptionCanNotHaveDataConnection { Socket socket ; if ( pasv ( ) != FTPReply . ENTERING_PASSIVE_MODE ) throw new FtpExceptionCanNotHaveDataConnection ( STRING + getReplyString ( ) ) ; try { __parsePassiveModeReply ( getReplyStrings ( ) [ _NUM ] ) ; } catch ( MalformedServerReplyException e ) { throw new FtpExceptionCanNotHaveDataConnection ( e . getMessage ( ) ) ; } socket = _socketFactory_ . createSocket ( __passiveHost , __passivePort ) ; if ( ! FTPReply . isPositivePreliminary ( sendCommand ( command , arg ) ) ) { socket . close ( ) ; return null ; } if ( __remoteVerificationEnabled && ! verifyRemote ( socket ) ) { InetAddress host1 , host2 ; host1 = socket . getInetAddress ( ) ; host2 = getRemoteAddress ( ) ; socket . close ( ) ; throw new FtpExceptionCanNotHaveDataConnection ( STRING + host1 . getHostAddress ( ) + STRING + host2 . getHostAddress ( ) + STRING ) ; } if ( __dataTimeout >= _NUM ) socket . setSoTimeout ( __dataTimeout ) ; return socket ; }
protected long releaseMemory ( ) { long memoryFreed = _NUM ; while ( ! windowsForFreeMemory . isEmpty ( ) ) { long windowId = windowsForFreeMemory . poll ( ) ; long originSize = keyStream . size ( ) + valueStream . size ( ) ; keyStream . completeWindow ( windowId ) ; valueStream . completeWindow ( windowId ) ; memoryFreed += originSize - ( keyStream . size ( ) + valueStream . size ( ) ) ; } if ( memoryFreed > _NUM ) { LOG . debug ( STRING , memoryFreed ) ; sizeInBytes . getAndAdd ( - memoryFreed ) ; } return memoryFreed ; }
static UnixStream < String > cat ( final String filePath ) throws IOException { Objects . requireNonNull ( filePath , STRING ) ; return new UnixStreamImpl < > ( lines ( Paths . get ( filePath ) ) ) ; }
public static String readAndCloseQuietly ( InputStream inputStream ) throws IOException { try { return readStream ( inputStream ) ; } catch ( IOException e ) { LOG . error ( e . getLocalizedMessage ( ) , e ) ; throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( IOException e ) { LOG . error ( e . getLocalizedMessage ( ) , e ) ; } } } }
public AMServiceProfileModelImpl ( HttpServletRequest req , String serviceName , Map map ) throws AMConsoleException { super ( req , map ) ; this . serviceName = serviceName ; try { xmlBuilder = new PropertyXMLBuilder ( serviceName , getDisplaySchemaTypes ( ) , this ) ; if ( serviceName . equals ( ADMIN_CONSOLE_SERVICE ) && ServiceManager . isRealmEnabled ( ) ) { AMViewConfig config = AMViewConfig . getInstance ( ) ; xmlBuilder . discardAttribute ( config . getRealmEnableHiddenConsoleAttrNames ( ) ) ; } } catch ( SMSException e ) { throw new AMConsoleException ( getErrorString ( e ) ) ; } catch ( SSOException e ) { throw new AMConsoleException ( getErrorString ( e ) ) ; } }
public AMServiceProfileModelImpl ( HttpServletRequest req , String serviceName , Map map ) throws AMConsoleException { super ( req , map ) ; this . serviceName = serviceName ; try { xmlBuilder = new PropertyXMLBuilder ( serviceName , getDisplaySchemaTypes ( ) , this ) ; if ( serviceName . equals ( ADMIN_CONSOLE_SERVICE ) && ServiceManager . isRealmEnabled ( ) ) { AMViewConfig config = AMViewConfig . getInstance ( ) ; xmlBuilder . discardAttribute ( config . getRealmEnableHiddenConsoleAttrNames ( ) ) ; } } catch ( SMSException e ) { throw new AMConsoleException ( getErrorString ( e ) ) ; } catch ( SSOException e ) { throw new AMConsoleException ( getErrorString ( e ) ) ; } }
public AMServiceProfileModelImpl ( HttpServletRequest req , String serviceName , Map map ) throws AMConsoleException { super ( req , map ) ; this . serviceName = serviceName ; try { xmlBuilder = new PropertyXMLBuilder ( serviceName , getDisplaySchemaTypes ( ) , this ) ; if ( serviceName . equals ( ADMIN_CONSOLE_SERVICE ) && ServiceManager . isRealmEnabled ( ) ) { AMViewConfig config = AMViewConfig . getInstance ( ) ; xmlBuilder . discardAttribute ( config . getRealmEnableHiddenConsoleAttrNames ( ) ) ; } } catch ( SMSException e ) { throw new AMConsoleException ( getErrorString ( e ) ) ; } catch ( SSOException e ) { throw new AMConsoleException ( getErrorString ( e ) ) ; } }
public WebViewLocalServer ( Context context ) { this ( new AndroidProtocolHandler ( context . getApplicationContext ( ) ) ) ; }
private boolean isNoun ( String word ) { if ( nouns == null ) return _BOOL ; return nouns . contains ( word . toLowerCase ( ) ) ; }
private boolean isNoun ( String word ) { if ( nouns == null ) return _BOOL ; return nouns . contains ( word . toLowerCase ( ) ) ; }
public void partChannel ( String channel ) { if ( ! channel . startsWith ( STRING ) ) { channel = STRING + channel ; } send ( STRING + channel ) ; }
public void partChannel ( String channel ) { if ( ! channel . startsWith ( STRING ) ) { channel = STRING + channel ; } send ( STRING + channel ) ; }
public Date randomDate ( ) { if ( random . nextInt ( _NUM ) == _NUM ) { return null ; } StringBuilder buff = new StringBuilder ( ) ; buff . append ( getInt ( _NUM ) + _NUM ) ; buff . append ( STRING ) ; int month = getInt ( _NUM ) + _NUM ; if ( month < _NUM ) { buff . append ( STRING ) ; } buff . append ( month ) ; buff . append ( STRING ) ; int day = getInt ( _NUM ) + _NUM ; if ( day < _NUM ) { buff . append ( STRING ) ; } buff . append ( day ) ; return Date . valueOf ( buff . toString ( ) ) ; }
public void registerFmRadioListener ( FmRadioListener callback ) { synchronized ( mRecords ) { Record record = null ; int hashCode = callback . hashCode ( ) ; final int n = mRecords . size ( ) ; for ( int i = _NUM ; i < n ; i ++ ) { record = mRecords . get ( i ) ; if ( hashCode == record . mHashCode ) { return ; } } record = new Record ( ) ; record . mHashCode = hashCode ; record . mCallback = callback ; mRecords . add ( record ) ; } }
public void registerFmRadioListener ( FmRadioListener callback ) { synchronized ( mRecords ) { Record record = null ; int hashCode = callback . hashCode ( ) ; final int n = mRecords . size ( ) ; for ( int i = _NUM ; i < n ; i ++ ) { record = mRecords . get ( i ) ; if ( hashCode == record . mHashCode ) { return ; } } record = new Record ( ) ; record . mHashCode = hashCode ; record . mCallback = callback ; mRecords . add ( record ) ; } }
public void makeImmutable ( ) { if ( isMutable ) { isMutable = _BOOL ; } }
private int crossCheckGetColumnsAndResultSetMetaData ( ResultSet rs , boolean partial ) throws SQLException { Statement s = conn . createStatement ( ) ; while ( rs . next ( ) ) { String schema = rs . getString ( STRING ) ; String table = rs . getString ( STRING ) ; ResultSet rst = s . executeQuery ( STRING + schema + STRING + table ) ; ResultSetMetaData rsmdt = rst . getMetaData ( ) ; for ( int col = _NUM ; col <= rsmdt . getColumnCount ( ) ; col ++ ) { if ( ! partial ) { if ( col != _NUM ) assertTrue ( rs . next ( ) ) ; assertEquals ( STRING , col , rs . getInt ( STRING ) ) ; } assertEquals ( STRING , STRING , rs . getString ( STRING ) ) ; assertEquals ( STRING , schema , rs . getString ( STRING ) ) ; assertEquals ( STRING , table , rs . getString ( STRING ) ) ; crossCheckGetColumnRowAndResultSetMetaData ( rs , rsmdt ) ; if ( partial ) break ; } rst . close ( ) ; } int count = rs . getRow ( ) ; rs . close ( ) ; s . close ( ) ; return count ; }
private int crossCheckGetColumnsAndResultSetMetaData ( ResultSet rs , boolean partial ) throws SQLException { Statement s = conn . createStatement ( ) ; while ( rs . next ( ) ) { String schema = rs . getString ( STRING ) ; String table = rs . getString ( STRING ) ; ResultSet rst = s . executeQuery ( STRING + schema + STRING + table ) ; ResultSetMetaData rsmdt = rst . getMetaData ( ) ; for ( int col = _NUM ; col <= rsmdt . getColumnCount ( ) ; col ++ ) { if ( ! partial ) { if ( col != _NUM ) assertTrue ( rs . next ( ) ) ; assertEquals ( STRING , col , rs . getInt ( STRING ) ) ; } assertEquals ( STRING , STRING , rs . getString ( STRING ) ) ; assertEquals ( STRING , schema , rs . getString ( STRING ) ) ; assertEquals ( STRING , table , rs . getString ( STRING ) ) ; crossCheckGetColumnRowAndResultSetMetaData ( rs , rsmdt ) ; if ( partial ) break ; } rst . close ( ) ; } int count = rs . getRow ( ) ; rs . close ( ) ; s . close ( ) ; return count ; }
public synchronized void incubate ( T o ) { if ( o == null ) throw new IllegalArgumentException ( STRING ) ; if ( hatchMap . containsKey ( o ) ) throw new IllegalArgumentException ( o + STRING ) ; hatchMap . put ( o , o ) ; orderList . addLast ( o ) ; notifyAll ( ) ; }
public void execute ( ) { final RTimer timer = new RTimer ( ) ; if ( DATA_MODE_FILES . equals ( mode ) && args . length > _NUM ) { doFilesMode ( ) ; } else if ( DATA_MODE_ARGS . equals ( mode ) && args . length > _NUM ) { doArgsMode ( ) ; } else if ( DATA_MODE_WEB . equals ( mode ) && args . length > _NUM ) { doWebMode ( ) ; } else if ( DATA_MODE_STDIN . equals ( mode ) ) { doStdinMode ( ) ; } else { usageShort ( ) ; return ; } if ( commit ) commit ( ) ; if ( optimize ) optimize ( ) ; displayTiming ( ( long ) timer . getTime ( ) ) ; }
protected CmapTable ( ) { super ( TrueTypeTable . CMAP_TABLE ) ; setVersion ( ( short ) _NUM ) ; subtables = Collections . synchronizedSortedMap ( new TreeMap < CmapSubtable , CMap > ( ) ) ; }
private static Pair < String , String > generateSignMask ( final ITranslationEnvironment environment , long offset , final String value , final OperandSize size , final List < ReilInstruction > instructions ) { final String msbMask = String . valueOf ( TranslationHelpers . getMsbMask ( size ) ) ; final String shiftValue = String . valueOf ( TranslationHelpers . getShiftMsbLsbMask ( size ) ) ; final String maskedMsb = environment . getNextVariableString ( ) ; final String msbInLsb = environment . getNextVariableString ( ) ; final String signMask = environment . getNextVariableString ( ) ; instructions . add ( ReilHelpers . createAnd ( offset ++ , size , value , size , msbMask , size , maskedMsb ) ) ; instructions . add ( ReilHelpers . createBsh ( offset ++ , size , maskedMsb , size , shiftValue , size , msbInLsb ) ) ; instructions . add ( ReilHelpers . createSub ( offset ++ , size , STRING , size , msbInLsb , size , signMask ) ) ; return new Pair < String , String > ( msbInLsb , signMask ) ; }
private static Pair < String , String > generateSignMask ( final ITranslationEnvironment environment , long offset , final String value , final OperandSize size , final List < ReilInstruction > instructions ) { final String msbMask = String . valueOf ( TranslationHelpers . getMsbMask ( size ) ) ; final String shiftValue = String . valueOf ( TranslationHelpers . getShiftMsbLsbMask ( size ) ) ; final String maskedMsb = environment . getNextVariableString ( ) ; final String msbInLsb = environment . getNextVariableString ( ) ; final String signMask = environment . getNextVariableString ( ) ; instructions . add ( ReilHelpers . createAnd ( offset ++ , size , value , size , msbMask , size , maskedMsb ) ) ; instructions . add ( ReilHelpers . createBsh ( offset ++ , size , maskedMsb , size , shiftValue , size , msbInLsb ) ) ; instructions . add ( ReilHelpers . createSub ( offset ++ , size , STRING , size , msbInLsb , size , signMask ) ) ; return new Pair < String , String > ( msbInLsb , signMask ) ; }
public double sigmoid ( double z ) { double answer = _NUM ; if ( z >= maxExponent ) return _NUM ; else if ( z <= - maxExponent ) return _NUM ; else { double index = tableSize * Math . abs ( z ) / ( double ) maxExponent ; answer = sigmoidTable [ ( int ) index ] ; if ( z < _NUM ) answer = _NUM - answer ; } return answer ; }
public static LeftRegularBipartiteGraphSegment buildRandomLeftRegularBipartiteGraph ( int leftSize , int rightSize , int leftDegree , Random random ) { LeftRegularBipartiteGraphSegment leftRegularBipartiteGraphSegment = new LeftRegularBipartiteGraphSegment ( leftSize / _NUM , leftDegree , rightSize / _NUM , leftSize / _NUM , _NUM , Integer . MAX_VALUE , new IdentityEdgeTypeMask ( ) , new NullStatsReceiver ( ) ) ; LongSet addedIds = new LongOpenHashSet ( leftDegree ) ; for ( int i = _NUM ; i < leftSize ; i ++ ) { addedIds . clear ( ) ; for ( int j = _NUM ; j < leftDegree ; j ++ ) { long idToAdd ; do { idToAdd = random . nextInt ( rightSize ) ; } while ( addedIds . contains ( idToAdd ) ) ; addedIds . add ( idToAdd ) ; leftRegularBipartiteGraphSegment . addEdge ( i , idToAdd , ( byte ) _NUM ) ; } } return leftRegularBipartiteGraphSegment ; }
private void sendTrapPdu ( InetAddress addr , SnmpPduPacket pdu ) throws SnmpStatusException , IOException { SnmpMessage msg = null ; try { msg = ( SnmpMessage ) pduFactory . encodeSnmpPdu ( pdu , bufferSize ) ; if ( msg == null ) { throw new SnmpStatusException ( SnmpDefinitions . snmpRspAuthorizationError ) ; } } catch ( SnmpTooBigException x ) { if ( SNMP_ADAPTOR_LOGGER . isLoggable ( Level . FINEST ) ) { SNMP_ADAPTOR_LOGGER . logp ( Level . FINEST , dbgTag , STRING , STRING + STRING ) ; } throw new SnmpStatusException ( SnmpDefinitions . snmpRspTooBig ) ; } openTrapSocketIfNeeded ( ) ; if ( addr != null ) { msg . address = addr ; try { sendTrapMessage ( msg ) ; } catch ( SnmpTooBigException x ) { if ( SNMP_ADAPTOR_LOGGER . isLoggable ( Level . FINEST ) ) { SNMP_ADAPTOR_LOGGER . logp ( Level . FINEST , dbgTag , STRING , STRING + STRING + msg . address ) ; } } } closeTrapSocketIfNeeded ( ) ; }
@ POST @ Consumes ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ Produces ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ CheckPermission ( roles = { Role . TENANT_ADMIN } ) @ Path ( STRING ) public IpInterfaceRestRep createIpInterface ( @ PathParam ( STRING ) URI id , IpInterfaceCreateParam createParam ) throws DatabaseException { Host host = queryObject ( Host . class , id , _BOOL ) ; validateIpInterfaceData ( createParam , null ) ; IpInterface ipInterface = new IpInterface ( ) ; ipInterface . setHost ( host . getId ( ) ) ; ipInterface . setId ( URIUtil . createId ( IpInterface . class ) ) ; populateIpInterface ( createParam , ipInterface ) ; _dbClient . createObject ( ipInterface ) ; auditOp ( OperationTypeEnum . CREATE_HOST_IPINTERFACE , _BOOL , null , ipInterface . auditParameters ( ) ) ; return map ( ipInterface ) ; }
public static SymbolVariant symbolVariant ( CharSequence symbol ) { int length = symbol . length ( ) ; if ( length == _NUM ) { throw new EmptySymbolException ( ) ; } if ( isIdentifierKeyword ( symbol ) ) { return SymbolVariant . QUOTED ; } char c = symbol . charAt ( _NUM ) ; if ( isIdentifierStart ( c ) ) { for ( int ii = _NUM ; ii < length ; ii ++ ) { c = symbol . charAt ( ii ) ; if ( ( c == STRING || c < _NUM || c > _NUM ) || ! isIdentifierPart ( c ) ) { return SymbolVariant . QUOTED ; } } return SymbolVariant . IDENTIFIER ; } if ( isOperatorPart ( c ) ) { for ( int ii = _NUM ; ii < length ; ii ++ ) { c = symbol . charAt ( ii ) ; if ( ! isOperatorPart ( c ) ) { return SymbolVariant . QUOTED ; } } return SymbolVariant . OPERATOR ; } return SymbolVariant . QUOTED ; }
private void addObjectPermissions ( Map < String , Set < ObjectPermission . Type > > permissions , ObjectPermissionSet permSet ) throws GuacamoleException { for ( ObjectPermission permission : permSet . getPermissions ( ) ) { String identifier = permission . getObjectIdentifier ( ) ; Set < ObjectPermission . Type > objectPermissions = permissions . get ( identifier ) ; if ( objectPermissions == null ) permissions . put ( identifier , EnumSet . of ( permission . getType ( ) ) ) ; else objectPermissions . add ( permission . getType ( ) ) ; } }
public LiveRef ( ObjID objID , int port ) { this ( objID , TCPEndpoint . getLocalEndpoint ( port ) , _BOOL ) ; }
public LiveRef ( ObjID objID , int port ) { this ( objID , TCPEndpoint . getLocalEndpoint ( port ) , _BOOL ) ; }
public static void throwException ( Throwable t ) { if ( UNSAFE != null ) { UNSAFE . throwException ( t ) ; } else { JUnsafe . < RuntimeException > throwException0 ( t ) ; } }
public static void throwException ( Throwable t ) { if ( UNSAFE != null ) { UNSAFE . throwException ( t ) ; } else { JUnsafe . < RuntimeException > throwException0 ( t ) ; } }
public List < SaveResult > checkResults ( BulkConnection bulkConnection , JobInfo job , List < BatchInfo > batchInfoList ) throws AsyncApiException , IOException { LOG . debug ( STRING ) ; List < SaveResult > saveResults = new ArrayList < SaveResult > ( ) ; for ( BatchInfo batchInfo : batchInfoList ) { CSVReader csvReaderForBatchResultStream = new CSVReader ( bulkConnection . getBatchResultStream ( job . getId ( ) , batchInfo . getId ( ) ) ) ; List < String > resultHeader = csvReaderForBatchResultStream . nextRecord ( ) ; int resultCols = resultHeader . size ( ) ; List < String > batchResultStream = null ; while ( ( batchResultStream = csvReaderForBatchResultStream . nextRecord ( ) ) != null ) { Map < String , String > resultInfo = new HashMap < String , String > ( ) ; for ( int i = _NUM ; i < resultCols ; i ++ ) { resultInfo . put ( resultHeader . get ( i ) , batchResultStream . get ( i ) ) ; } SaveResult sr = new SaveResult ( ) ; sr . setId ( resultInfo . get ( STRING ) ) ; boolean success = Boolean . valueOf ( resultInfo . get ( STRING ) ) ; sr . setSuccess ( success ) ; if ( ! success ) { if ( resultInfo . get ( STRING ) != null && StringUtils . isNotEmpty ( resultInfo . get ( STRING ) ) ) { ApexUnitUtils . shutDownWithErrMsg ( STRING + resultInfo . get ( STRING ) ) ; } } saveResults . add ( sr ) ; } } return saveResults ; }
public static double euclideanDistance ( double [ ] p , double [ ] q ) { double ret = _NUM ; for ( int i = _NUM ; i < p . length ; i ++ ) { double diff = ( q [ i ] - p [ i ] ) ; double sq = Math . pow ( diff , _NUM ) ; ret += sq ; } return ret ; }
public static double calculatePValue ( double t , int v ) { return _NUM * ( _NUM - StudentsTDistribution . cdf ( Math . abs ( t ) , v ) ) ; }
public void doLayout ( ) { for ( int i = _NUM ; i < getComponentCount ( ) ; i ++ ) { Marker m = ( Marker ) getComponent ( i ) ; m . updateLocation ( ) ; } listener . caretUpdate ( null ) ; }
public void doLayout ( ) { for ( int i = _NUM ; i < getComponentCount ( ) ; i ++ ) { Marker m = ( Marker ) getComponent ( i ) ; m . updateLocation ( ) ; } listener . caretUpdate ( null ) ; }
public void doLayout ( ) { for ( int i = _NUM ; i < getComponentCount ( ) ; i ++ ) { Marker m = ( Marker ) getComponent ( i ) ; m . updateLocation ( ) ; } listener . caretUpdate ( null ) ; }
public void doLayout ( ) { for ( int i = _NUM ; i < getComponentCount ( ) ; i ++ ) { Marker m = ( Marker ) getComponent ( i ) ; m . updateLocation ( ) ; } listener . caretUpdate ( null ) ; }
public static Map parseCommandLineArguments ( String [ ] args ) { Map < String , String > result = new HashMap < String , String > ( ) ; String key , value ; for ( int i = _NUM ; i < args . length ; i ++ ) { key = args [ i ] ; if ( key . charAt ( _NUM ) == STRING ) { if ( i + _NUM < args . length ) { value = args [ i + _NUM ] ; if ( value . charAt ( _NUM ) != STRING ) { result . put ( key , value ) ; i ++ ; } else { result . put ( key , null ) ; } } else { result . put ( key , null ) ; } } } return result ; }
protected void addLine ( PrintWriter file , String string ) { log . debug ( string ) ; if ( file != null ) { file . println ( string ) ; } }
int readInt ( ) throws IOException { mDexFile . readFully ( tmpBuf , _NUM , _NUM ) ; if ( isBigEndian ) { return ( tmpBuf [ _NUM ] & _NUM ) | ( ( tmpBuf [ _NUM ] & _NUM ) << _NUM ) | ( ( tmpBuf [ _NUM ] & _NUM ) << _NUM ) | ( ( tmpBuf [ _NUM ] & _NUM ) << _NUM ) ; } else { return ( tmpBuf [ _NUM ] & _NUM ) | ( ( tmpBuf [ _NUM ] & _NUM ) << _NUM ) | ( ( tmpBuf [ _NUM ] & _NUM ) << _NUM ) | ( ( tmpBuf [ _NUM ] & _NUM ) << _NUM ) ; } }
public int read ( ) throws IOException { int ch1 = is . read ( ) ; switch ( ch1 ) { case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return _NUM ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return _NUM ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : case _NUM : return STRING ; case _NUM : case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return _NUM ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return STRING ; default : return ch1 ; } }
public int read ( ) throws IOException { int ch1 = is . read ( ) ; switch ( ch1 ) { case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return _NUM ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return _NUM ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : case _NUM : return STRING ; case _NUM : case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return _NUM ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return STRING ; default : return ch1 ; } }
public int read ( ) throws IOException { int ch1 = is . read ( ) ; switch ( ch1 ) { case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return _NUM ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return _NUM ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : case _NUM : return STRING ; case _NUM : case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return _NUM ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return STRING ; case _NUM : return STRING ; default : return ch1 ; } }
public static String sortKey ( String key ) { if ( key != null ) { String [ ] ids = key . split ( DIMENSION_SEP ) ; Collections . sort ( Arrays . asList ( ids ) ) ; key = StringUtils . join ( ids , DIMENSION_SEP ) ; } return key ; }
private static List < Cookie > removeLocalLoadBalancingCookie ( final List < Cookie > cookies ) { final String lblCookieName = getlbCookieName ( ) ; final String lblCookieValue = getlbCookieValue ( ) ; final List < Cookie > filteredCookies = new ArrayList < > ( ) ; for ( final Cookie cookie : cookies ) { if ( ! Objects . equals ( cookie . getName ( ) , lblCookieName ) && ! Objects . equals ( cookie . getValue ( ) , lblCookieValue ) ) { filteredCookies . add ( cookie ) ; } } return filteredCookies ; }
private static List < Cookie > removeLocalLoadBalancingCookie ( final List < Cookie > cookies ) { final String lblCookieName = getlbCookieName ( ) ; final String lblCookieValue = getlbCookieValue ( ) ; final List < Cookie > filteredCookies = new ArrayList < > ( ) ; for ( final Cookie cookie : cookies ) { if ( ! Objects . equals ( cookie . getName ( ) , lblCookieName ) && ! Objects . equals ( cookie . getValue ( ) , lblCookieValue ) ) { filteredCookies . add ( cookie ) ; } } return filteredCookies ; }
private static List < Cookie > removeLocalLoadBalancingCookie ( final List < Cookie > cookies ) { final String lblCookieName = getlbCookieName ( ) ; final String lblCookieValue = getlbCookieValue ( ) ; final List < Cookie > filteredCookies = new ArrayList < > ( ) ; for ( final Cookie cookie : cookies ) { if ( ! Objects . equals ( cookie . getName ( ) , lblCookieName ) && ! Objects . equals ( cookie . getValue ( ) , lblCookieValue ) ) { filteredCookies . add ( cookie ) ; } } return filteredCookies ; }
public void close ( ) throws IOException { rafile . close ( ) ; }
public void purgeAndNotifyRemovedLayers ( ) { ArrayList < Layer > rLayers = new ArrayList < Layer > ( removedLayers ) ; removedLayers . clear ( ) ; if ( rLayers . isEmpty ( ) ) { return ; } for ( Layer layer : rLayers ) { layer . removed ( this ) ; } if ( Debug . debugging ( STRING ) ) { System . gc ( ) ; } }
public void purgeAndNotifyRemovedLayers ( ) { ArrayList < Layer > rLayers = new ArrayList < Layer > ( removedLayers ) ; removedLayers . clear ( ) ; if ( rLayers . isEmpty ( ) ) { return ; } for ( Layer layer : rLayers ) { layer . removed ( this ) ; } if ( Debug . debugging ( STRING ) ) { System . gc ( ) ; } }
public void purgeAndNotifyRemovedLayers ( ) { ArrayList < Layer > rLayers = new ArrayList < Layer > ( removedLayers ) ; removedLayers . clear ( ) ; if ( rLayers . isEmpty ( ) ) { return ; } for ( Layer layer : rLayers ) { layer . removed ( this ) ; } if ( Debug . debugging ( STRING ) ) { System . gc ( ) ; } }
public void purgeAndNotifyRemovedLayers ( ) { ArrayList < Layer > rLayers = new ArrayList < Layer > ( removedLayers ) ; removedLayers . clear ( ) ; if ( rLayers . isEmpty ( ) ) { return ; } for ( Layer layer : rLayers ) { layer . removed ( this ) ; } if ( Debug . debugging ( STRING ) ) { System . gc ( ) ; } }
private Spannable highlightUserHandles ( Spannable text ) { if ( text == null ) { return null ; } final Matcher matcher = PATTERN_USER_HANDLES . matcher ( text ) ; while ( matcher . find ( ) ) { final int start = matcher . start ( _NUM ) ; final int end = matcher . end ( _NUM ) ; text . setSpan ( new ForegroundColorSpan ( mHighlightColor ) , start , end , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; text . setSpan ( new StyleSpan ( android . graphics . Typeface . BOLD ) , start , end , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; } return text ; }
private void initAuthServiceGlobalSettings ( ) throws Exception { ServiceSchemaManager scm = new ServiceSchemaManager ( ISAuthConstants . AUTH_SERVICE_NAME , ssoAuthSession ) ; updateAuthServiceGlobals ( scm ) ; new AuthConfigMonitor ( scm ) ; }
public static String escapeRegex ( final String regex ) { Matcher match = REGEX_CHARS . matcher ( regex ) ; return match . replaceAll ( STRING ) ; }
public static String escapeRegex ( final String regex ) { Matcher match = REGEX_CHARS . matcher ( regex ) ; return match . replaceAll ( STRING ) ; }
public static String escapeRegex ( final String regex ) { Matcher match = REGEX_CHARS . matcher ( regex ) ; return match . replaceAll ( STRING ) ; }
public static String escapeRegex ( final String regex ) { Matcher match = REGEX_CHARS . matcher ( regex ) ; return match . replaceAll ( STRING ) ; }
public static String escapeRegex ( final String regex ) { Matcher match = REGEX_CHARS . matcher ( regex ) ; return match . replaceAll ( STRING ) ; }
public static String escapeRegex ( final String regex ) { Matcher match = REGEX_CHARS . matcher ( regex ) ; return match . replaceAll ( STRING ) ; }
public void write ( String s ) throws IOException { write ( s , _NUM , ( s != null ) ? s . length ( ) : _NUM ) ; }
public void write ( String s ) throws IOException { write ( s , _NUM , ( s != null ) ? s . length ( ) : _NUM ) ; }
public void write ( String s ) throws IOException { write ( s , _NUM , ( s != null ) ? s . length ( ) : _NUM ) ; }
protected void mergeChildrenImpl ( mxICell from , mxICell to , boolean cloneAllEdges , Hashtable < Object , Object > mapping ) throws CloneNotSupportedException { beginUpdate ( ) ; try { int childCount = from . getChildCount ( ) ; for ( int i = _NUM ; i < childCount ; i ++ ) { Object child = from . getChildAt ( i ) ; if ( child instanceof mxICell ) { mxICell cell = ( mxICell ) child ; String id = cell . getId ( ) ; mxICell target = ( mxICell ) ( ( id != null && ( ! isEdge ( cell ) || ! cloneAllEdges ) ) ? getCell ( id ) : null ) ; if ( target == null ) { mxCell clone = ( mxCell ) cell . clone ( ) ; clone . setId ( id ) ; target = ( mxICell ) to . insert ( clone ) ; cellAdded ( target ) ; } mapping . put ( cell , target ) ; mergeChildrenImpl ( cell , target , cloneAllEdges , mapping ) ; } } } finally { endUpdate ( ) ; } }
public int count_examples ( ) { return train_size ; }
private Workflow . Method createRollbackForgetVolumesMethod ( URI vplexSystemURI , List < URI > volumeURIs ) { return new Workflow . Method ( RB_FORGET_VOLUMES_METHOD_NAME , vplexSystemURI , volumeURIs ) ; }
protected final Statement createStatement ( int resultSetType , int resultSetConcurrency ) throws SQLException { return addAndReturnStatement ( createdStatements , connection . createStatement ( resultSetType , resultSetConcurrency ) ) ; }
public void parentExplotion ( int PP_Product_BOM_ID ) throws Exception { PreparedStatement stmt = null ; ResultSet rs = null ; String sql = STRING + STRING ; try { stmt = DB . prepareStatement ( sql , get_TrxName ( ) ) ; stmt . setInt ( _NUM , PP_Product_BOM_ID ) ; rs = stmt . executeQuery ( ) ; while ( rs . next ( ) ) { SeqNo += _NUM ; X_T_BOMLine tboml = new X_T_BOMLine ( ctx , _NUM , null ) ; tboml . setPP_Product_BOM_ID ( PP_Product_BOM_ID ) ; tboml . setPP_Product_BOMLine_ID ( rs . getInt ( _NUM ) ) ; tboml . setM_Product_ID ( rs . getInt ( _NUM ) ) ; tboml . setLevelNo ( LevelNo ) ; tboml . setLevels ( levels . substring ( _NUM , LevelNo ) + LevelNo ) ; tboml . setSeqNo ( SeqNo ) ; tboml . setAD_PInstance_ID ( AD_PInstance_ID ) ; tboml . setSel_Product_ID ( p_M_Product_ID ) ; tboml . setImplosion ( p_implosion ) ; tboml . save ( ) ; component ( rs . getInt ( _NUM ) ) ; } } catch ( SQLException e ) { log . log ( Level . SEVERE , e . getLocalizedMessage ( ) + sql , e ) ; throw new Exception ( STRING + e . getLocalizedMessage ( ) ) ; } finally { DB . close ( rs , stmt ) ; rs = null ; stmt = null ; } }
public final void walkGraph ( Hashtable h ) { }
public ExtendedKeyUsageExtension ( Boolean critical , Vector < ObjectIdentifier > keyUsages ) throws IOException { this . keyUsages = keyUsages ; this . extensionId = PKIXExtensions . ExtendedKeyUsage_Id ; this . critical = critical . booleanValue ( ) ; encodeThis ( ) ; }
public void addPoint ( PolygonPoint p ) { p . setPrevious ( _last ) ; p . setNext ( _last . getNext ( ) ) ; _last . setNext ( p ) ; _points . add ( p ) ; }
public void rotateLeft ( int places , int startIndex , int endIndex ) { for ( int x = _NUM ; x < places ; x ++ ) { rotateLeft ( startIndex , endIndex ) ; } }
public void rotateLeft ( int places , int startIndex , int endIndex ) { for ( int x = _NUM ; x < places ; x ++ ) { rotateLeft ( startIndex , endIndex ) ; } }
GL createGL ( ) { return mEglContext . getGL ( ) ; }
private void adjustDayOfWeek ( Calendar startTime ) { int daysDiff = getDayOfWeek ( ) - getDayOfWeek ( startTime ) ; startTime . add ( Calendar . DAY_OF_WEEK , daysDiff ) ; }
public Object2DoubleOpenHashMap < int [ ] > supportMap ( int supportThreshold ) { List < ItemSet > itemSets = learn ( ) ; Object2DoubleOpenHashMap < int [ ] > supportMap = new Object2DoubleOpenHashMap < > ( itemSets . size ( ) ) ; for ( ItemSet itemSet : itemSets ) { if ( itemSet . support >= supportThreshold ) { supportMap . put ( itemSet . items , itemSet . support ) ; } } return supportMap ; }
public Builder ( String host , int port ) { this . host = host ; this . port = Integer . toString ( port ) ; }
public boolean verifyMatches ( Matches matches ) { int lenLimit = Math . min ( getAvail ( ) , matchLenMax ) ; for ( int i = _NUM ; i < matches . count ; ++ i ) if ( getMatchLen ( matches . dist [ i ] , lenLimit ) != matches . len [ i ] ) return _BOOL ; return _BOOL ; }
private void showMessage ( String message , boolean error ) { lblError . setForeground ( error ? Color . RED : Color . BLACK ) ; lblError . setText ( message ) ; }
protected ConversationParser ( final SentenceImplementation sentence ) { String text = sentence . getOriginalText ( ) ; if ( text == null ) { text = STRING ; } else if ( text . startsWith ( STRING ) ) { text = STRING ; } final String textWithoutPunctation = detectSentenceType ( text , sentence ) ; tokenizer = new StringTokenizer ( textWithoutPunctation ) ; }
public static String normalizeUrl ( String requestUrl ) throws OAuthException { if ( ( requestUrl == null ) || ( requestUrl . length ( ) == _NUM ) ) { throw new OAuthException ( STRING ) ; } URI uri ; try { uri = new URI ( requestUrl ) ; } catch ( URISyntaxException e ) { throw new OAuthException ( e ) ; } String authority = uri . getAuthority ( ) ; String scheme = uri . getScheme ( ) ; if ( authority == null || scheme == null ) { throw new OAuthException ( STRING ) ; } authority = authority . toLowerCase ( ) ; scheme = scheme . toLowerCase ( ) ; if ( ( scheme . equals ( STRING ) && uri . getPort ( ) == _NUM ) || ( scheme . equals ( STRING ) && uri . getPort ( ) == _NUM ) ) { int index = authority . lastIndexOf ( STRING ) ; if ( index >= _NUM ) { authority = authority . substring ( _NUM , index ) ; } } return scheme + STRING + authority + uri . getRawPath ( ) ; }
public static String normalizeUrl ( String requestUrl ) throws OAuthException { if ( ( requestUrl == null ) || ( requestUrl . length ( ) == _NUM ) ) { throw new OAuthException ( STRING ) ; } URI uri ; try { uri = new URI ( requestUrl ) ; } catch ( URISyntaxException e ) { throw new OAuthException ( e ) ; } String authority = uri . getAuthority ( ) ; String scheme = uri . getScheme ( ) ; if ( authority == null || scheme == null ) { throw new OAuthException ( STRING ) ; } authority = authority . toLowerCase ( ) ; scheme = scheme . toLowerCase ( ) ; if ( ( scheme . equals ( STRING ) && uri . getPort ( ) == _NUM ) || ( scheme . equals ( STRING ) && uri . getPort ( ) == _NUM ) ) { int index = authority . lastIndexOf ( STRING ) ; if ( index >= _NUM ) { authority = authority . substring ( _NUM , index ) ; } } return scheme + STRING + authority + uri . getRawPath ( ) ; }
public static String normalizeUrl ( String requestUrl ) throws OAuthException { if ( ( requestUrl == null ) || ( requestUrl . length ( ) == _NUM ) ) { throw new OAuthException ( STRING ) ; } URI uri ; try { uri = new URI ( requestUrl ) ; } catch ( URISyntaxException e ) { throw new OAuthException ( e ) ; } String authority = uri . getAuthority ( ) ; String scheme = uri . getScheme ( ) ; if ( authority == null || scheme == null ) { throw new OAuthException ( STRING ) ; } authority = authority . toLowerCase ( ) ; scheme = scheme . toLowerCase ( ) ; if ( ( scheme . equals ( STRING ) && uri . getPort ( ) == _NUM ) || ( scheme . equals ( STRING ) && uri . getPort ( ) == _NUM ) ) { int index = authority . lastIndexOf ( STRING ) ; if ( index >= _NUM ) { authority = authority . substring ( _NUM , index ) ; } } return scheme + STRING + authority + uri . getRawPath ( ) ; }
public static String normalizeUrl ( String requestUrl ) throws OAuthException { if ( ( requestUrl == null ) || ( requestUrl . length ( ) == _NUM ) ) { throw new OAuthException ( STRING ) ; } URI uri ; try { uri = new URI ( requestUrl ) ; } catch ( URISyntaxException e ) { throw new OAuthException ( e ) ; } String authority = uri . getAuthority ( ) ; String scheme = uri . getScheme ( ) ; if ( authority == null || scheme == null ) { throw new OAuthException ( STRING ) ; } authority = authority . toLowerCase ( ) ; scheme = scheme . toLowerCase ( ) ; if ( ( scheme . equals ( STRING ) && uri . getPort ( ) == _NUM ) || ( scheme . equals ( STRING ) && uri . getPort ( ) == _NUM ) ) { int index = authority . lastIndexOf ( STRING ) ; if ( index >= _NUM ) { authority = authority . substring ( _NUM , index ) ; } } return scheme + STRING + authority + uri . getRawPath ( ) ; }
protected String buildCreateSchemaStatement ( ) throws ReplicatorException { return null ; }
protected String buildCreateSchemaStatement ( ) throws ReplicatorException { return null ; }
private void handleEndOfStream ( State state , InnerState innerState ) throws StopRequest { mInfo . mCurrentBytes = innerState . mBytesSoFar ; mDB . updateDownload ( mInfo ) ; boolean lengthMismatched = ( innerState . mHeaderContentLength != null ) && ( innerState . mBytesSoFar != Integer . parseInt ( innerState . mHeaderContentLength ) ) ; if ( lengthMismatched ) { if ( cannotResume ( innerState ) ) { throw new StopRequest ( DownloaderService . STATUS_CANNOT_RESUME , STRING ) ; } else { throw new StopRequest ( getFinalStatusForHttpError ( state ) , STRING ) ; } } }
private void handleEndOfStream ( State state , InnerState innerState ) throws StopRequest { mInfo . mCurrentBytes = innerState . mBytesSoFar ; mDB . updateDownload ( mInfo ) ; boolean lengthMismatched = ( innerState . mHeaderContentLength != null ) && ( innerState . mBytesSoFar != Integer . parseInt ( innerState . mHeaderContentLength ) ) ; if ( lengthMismatched ) { if ( cannotResume ( innerState ) ) { throw new StopRequest ( DownloaderService . STATUS_CANNOT_RESUME , STRING ) ; } else { throw new StopRequest ( getFinalStatusForHttpError ( state ) , STRING ) ; } } }
private void handleEndOfStream ( State state , InnerState innerState ) throws StopRequest { mInfo . mCurrentBytes = innerState . mBytesSoFar ; mDB . updateDownload ( mInfo ) ; boolean lengthMismatched = ( innerState . mHeaderContentLength != null ) && ( innerState . mBytesSoFar != Integer . parseInt ( innerState . mHeaderContentLength ) ) ; if ( lengthMismatched ) { if ( cannotResume ( innerState ) ) { throw new StopRequest ( DownloaderService . STATUS_CANNOT_RESUME , STRING ) ; } else { throw new StopRequest ( getFinalStatusForHttpError ( state ) , STRING ) ; } } }
private void handleEndOfStream ( State state , InnerState innerState ) throws StopRequest { mInfo . mCurrentBytes = innerState . mBytesSoFar ; mDB . updateDownload ( mInfo ) ; boolean lengthMismatched = ( innerState . mHeaderContentLength != null ) && ( innerState . mBytesSoFar != Integer . parseInt ( innerState . mHeaderContentLength ) ) ; if ( lengthMismatched ) { if ( cannotResume ( innerState ) ) { throw new StopRequest ( DownloaderService . STATUS_CANNOT_RESUME , STRING ) ; } else { throw new StopRequest ( getFinalStatusForHttpError ( state ) , STRING ) ; } } }
public static URL [ ] parseClassPath ( ) { return parseClassPath ( System . getProperty ( STRING ) ) ; }
private void initSelectPosition ( int position ) { if ( mSelectMode == ISelectable . SELECT_MODE_SINGLE ) { if ( mSelectedPosition == ISelectable . INVALID_POSITION ) { mSelectedPosition = position ; } } else if ( mSelectMode == ISelectable . SELECT_MODE_MULTI ) { if ( ! mSelectedPositions . contains ( position ) ) mSelectedPositions . add ( position ) ; } else { throw new RuntimeException ( ) ; } }
private void reset ( ) { serialInterface . ifPresent ( null ) ; serialInterface = Optional . empty ( ) ; cancelRead ( ) ; cancelWrite ( ) ; }
private byte [ ] [ ] readSubrs ( byte [ ] d ) { return readArray ( d , STRING , STRING ) ; }
void readBytes ( byte [ ] buffer ) throws IOException { mDexFile . readFully ( buffer ) ; }
void readBytes ( byte [ ] buffer ) throws IOException { mDexFile . readFully ( buffer ) ; }
protected void applyGradientToPaint ( ) { if ( Color . alpha ( mSeriesItem . getSecondaryColor ( ) ) != _NUM ) { int colorOne = mSeriesItem . getSpinClockwise ( ) ? mSeriesItem . getColor ( ) : mSeriesItem . getSecondaryColor ( ) ; int colorTwo = mSeriesItem . getSpinClockwise ( ) ? mSeriesItem . getSecondaryColor ( ) : mSeriesItem . getColor ( ) ; LinearGradient gradient = new LinearGradient ( mBounds . left , mBounds . top , mBounds . right , mBounds . bottom , colorOne , colorTwo , Shader . TileMode . CLAMP ) ; mPaint . setShader ( gradient ) ; } }
protected void applyGradientToPaint ( ) { if ( Color . alpha ( mSeriesItem . getSecondaryColor ( ) ) != _NUM ) { int colorOne = mSeriesItem . getSpinClockwise ( ) ? mSeriesItem . getColor ( ) : mSeriesItem . getSecondaryColor ( ) ; int colorTwo = mSeriesItem . getSpinClockwise ( ) ? mSeriesItem . getSecondaryColor ( ) : mSeriesItem . getColor ( ) ; LinearGradient gradient = new LinearGradient ( mBounds . left , mBounds . top , mBounds . right , mBounds . bottom , colorOne , colorTwo , Shader . TileMode . CLAMP ) ; mPaint . setShader ( gradient ) ; } }
public MotifSplitPaneDivider ( BasicSplitPaneUI ui ) { super ( ui ) ; highlightColor = UIManager . getColor ( STRING ) ; shadowColor = UIManager . getColor ( STRING ) ; focusedColor = UIManager . getColor ( STRING ) ; setDividerSize ( hThumbWidth + pad ) ; }
@ edu . umd . cs . findbugs . annotations . SuppressFBWarnings ( value = STRING , justification = STRING ) public void changeLocoSpeed ( DccThrottle t , Section sec , float speed ) { if ( sec == referenced && speed == desiredSpeedStep ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING ) ; } return ; } float sectionLength = sec . getActualLength ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + sec . getDisplayName ( ) ) ; } if ( sec == referenced ) { distanceRemaining = distanceRemaining - getDistanceTravelled ( _throttle . getIsForward ( ) , _throttle . getSpeedSetting ( ) , ( ( float ) ( System . nanoTime ( ) - lastTimeTimerStarted ) / _NUM ) ) ; sectionLength = distanceRemaining ; } else { referenced = sec ; } changeLocoSpeed ( t , sectionLength , speed ) ; }
@ edu . umd . cs . findbugs . annotations . SuppressFBWarnings ( value = STRING , justification = STRING ) public void changeLocoSpeed ( DccThrottle t , Section sec , float speed ) { if ( sec == referenced && speed == desiredSpeedStep ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING ) ; } return ; } float sectionLength = sec . getActualLength ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + sec . getDisplayName ( ) ) ; } if ( sec == referenced ) { distanceRemaining = distanceRemaining - getDistanceTravelled ( _throttle . getIsForward ( ) , _throttle . getSpeedSetting ( ) , ( ( float ) ( System . nanoTime ( ) - lastTimeTimerStarted ) / _NUM ) ) ; sectionLength = distanceRemaining ; } else { referenced = sec ; } changeLocoSpeed ( t , sectionLength , speed ) ; }
@ edu . umd . cs . findbugs . annotations . SuppressFBWarnings ( value = STRING , justification = STRING ) public void changeLocoSpeed ( DccThrottle t , Section sec , float speed ) { if ( sec == referenced && speed == desiredSpeedStep ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING ) ; } return ; } float sectionLength = sec . getActualLength ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + sec . getDisplayName ( ) ) ; } if ( sec == referenced ) { distanceRemaining = distanceRemaining - getDistanceTravelled ( _throttle . getIsForward ( ) , _throttle . getSpeedSetting ( ) , ( ( float ) ( System . nanoTime ( ) - lastTimeTimerStarted ) / _NUM ) ) ; sectionLength = distanceRemaining ; } else { referenced = sec ; } changeLocoSpeed ( t , sectionLength , speed ) ; }
public Object beforeEncode ( mxCodec enc , Object obj , Node node ) { return obj ; }
public Object beforeEncode ( mxCodec enc , Object obj , Node node ) { return obj ; }
public Object beforeEncode ( mxCodec enc , Object obj , Node node ) { return obj ; }
public Object beforeEncode ( mxCodec enc , Object obj , Node node ) { return obj ; }
public Object beforeEncode ( mxCodec enc , Object obj , Node node ) { return obj ; }
protected boolean startingMultiLineComment ( String content , int startOffset , int endOffset ) throws BadLocationException { if ( ! getMultiLineComment ( ) ) { return _BOOL ; } int index = indexOf ( content , getMultiLineCommentStart ( ) , startOffset ) ; if ( ( index < _NUM ) || ( index > endOffset ) ) { return _BOOL ; } else { setInsideMultiLineComment ( _BOOL ) ; return _BOOL ; } }
public void removeEvents ( ) { scene . setOnKeyPressed ( null ) ; scene . setOnKeyReleased ( null ) ; up = down = left = right = sprint = jump = shootFireball = _BOOL ; }
public TXStateProxy masqueradeAs ( TransactionMessage msg ) throws InterruptedException { if ( msg . getTXUniqId ( ) == NOTX || ! msg . canParticipateInTransaction ( ) ) { return null ; } TXId key = new TXId ( msg . getMemberToMasqueradeAs ( ) , msg . getTXUniqId ( ) ) ; TXStateProxy val = getOrSetHostedTXState ( key , msg ) ; if ( val != null ) { boolean success = getLock ( val , key ) ; while ( ! success ) { val = getOrSetHostedTXState ( key , msg ) ; if ( val != null ) { success = getLock ( val , key ) ; } else { break ; } } } setTXState ( val ) ; return val ; }
public TXStateProxy masqueradeAs ( TransactionMessage msg ) throws InterruptedException { if ( msg . getTXUniqId ( ) == NOTX || ! msg . canParticipateInTransaction ( ) ) { return null ; } TXId key = new TXId ( msg . getMemberToMasqueradeAs ( ) , msg . getTXUniqId ( ) ) ; TXStateProxy val = getOrSetHostedTXState ( key , msg ) ; if ( val != null ) { boolean success = getLock ( val , key ) ; while ( ! success ) { val = getOrSetHostedTXState ( key , msg ) ; if ( val != null ) { success = getLock ( val , key ) ; } else { break ; } } } setTXState ( val ) ; return val ; }
public TXStateProxy masqueradeAs ( TransactionMessage msg ) throws InterruptedException { if ( msg . getTXUniqId ( ) == NOTX || ! msg . canParticipateInTransaction ( ) ) { return null ; } TXId key = new TXId ( msg . getMemberToMasqueradeAs ( ) , msg . getTXUniqId ( ) ) ; TXStateProxy val = getOrSetHostedTXState ( key , msg ) ; if ( val != null ) { boolean success = getLock ( val , key ) ; while ( ! success ) { val = getOrSetHostedTXState ( key , msg ) ; if ( val != null ) { success = getLock ( val , key ) ; } else { break ; } } } setTXState ( val ) ; return val ; }
public TXStateProxy masqueradeAs ( TransactionMessage msg ) throws InterruptedException { if ( msg . getTXUniqId ( ) == NOTX || ! msg . canParticipateInTransaction ( ) ) { return null ; } TXId key = new TXId ( msg . getMemberToMasqueradeAs ( ) , msg . getTXUniqId ( ) ) ; TXStateProxy val = getOrSetHostedTXState ( key , msg ) ; if ( val != null ) { boolean success = getLock ( val , key ) ; while ( ! success ) { val = getOrSetHostedTXState ( key , msg ) ; if ( val != null ) { success = getLock ( val , key ) ; } else { break ; } } } setTXState ( val ) ; return val ; }
public TXStateProxy masqueradeAs ( TransactionMessage msg ) throws InterruptedException { if ( msg . getTXUniqId ( ) == NOTX || ! msg . canParticipateInTransaction ( ) ) { return null ; } TXId key = new TXId ( msg . getMemberToMasqueradeAs ( ) , msg . getTXUniqId ( ) ) ; TXStateProxy val = getOrSetHostedTXState ( key , msg ) ; if ( val != null ) { boolean success = getLock ( val , key ) ; while ( ! success ) { val = getOrSetHostedTXState ( key , msg ) ; if ( val != null ) { success = getLock ( val , key ) ; } else { break ; } } } setTXState ( val ) ; return val ; }
public TXStateProxy masqueradeAs ( TransactionMessage msg ) throws InterruptedException { if ( msg . getTXUniqId ( ) == NOTX || ! msg . canParticipateInTransaction ( ) ) { return null ; } TXId key = new TXId ( msg . getMemberToMasqueradeAs ( ) , msg . getTXUniqId ( ) ) ; TXStateProxy val = getOrSetHostedTXState ( key , msg ) ; if ( val != null ) { boolean success = getLock ( val , key ) ; while ( ! success ) { val = getOrSetHostedTXState ( key , msg ) ; if ( val != null ) { success = getLock ( val , key ) ; } else { break ; } } } setTXState ( val ) ; return val ; }
public TXStateProxy masqueradeAs ( TransactionMessage msg ) throws InterruptedException { if ( msg . getTXUniqId ( ) == NOTX || ! msg . canParticipateInTransaction ( ) ) { return null ; } TXId key = new TXId ( msg . getMemberToMasqueradeAs ( ) , msg . getTXUniqId ( ) ) ; TXStateProxy val = getOrSetHostedTXState ( key , msg ) ; if ( val != null ) { boolean success = getLock ( val , key ) ; while ( ! success ) { val = getOrSetHostedTXState ( key , msg ) ; if ( val != null ) { success = getLock ( val , key ) ; } else { break ; } } } setTXState ( val ) ; return val ; }
public TXStateProxy masqueradeAs ( TransactionMessage msg ) throws InterruptedException { if ( msg . getTXUniqId ( ) == NOTX || ! msg . canParticipateInTransaction ( ) ) { return null ; } TXId key = new TXId ( msg . getMemberToMasqueradeAs ( ) , msg . getTXUniqId ( ) ) ; TXStateProxy val = getOrSetHostedTXState ( key , msg ) ; if ( val != null ) { boolean success = getLock ( val , key ) ; while ( ! success ) { val = getOrSetHostedTXState ( key , msg ) ; if ( val != null ) { success = getLock ( val , key ) ; } else { break ; } } } setTXState ( val ) ; return val ; }
private void rProbeAndAddHopsToCandidateSet ( Hop hop , HashSet < Hop > probeSet , HashSet < Pair < Hop , Hop > > candSet ) { if ( hop . getVisited ( ) == VisitStatus . DONE ) return ; if ( hop . getInput ( ) != null ) for ( Hop c : hop . getInput ( ) ) { if ( ! probeSet . contains ( c ) ) rProbeAndAddHopsToCandidateSet ( c , probeSet , candSet ) ; else { candSet . add ( new Pair < Hop , Hop > ( hop , c ) ) ; } } hop . setVisited ( VisitStatus . DONE ) ; }
private void rProbeAndAddHopsToCandidateSet ( Hop hop , HashSet < Hop > probeSet , HashSet < Pair < Hop , Hop > > candSet ) { if ( hop . getVisited ( ) == VisitStatus . DONE ) return ; if ( hop . getInput ( ) != null ) for ( Hop c : hop . getInput ( ) ) { if ( ! probeSet . contains ( c ) ) rProbeAndAddHopsToCandidateSet ( c , probeSet , candSet ) ; else { candSet . add ( new Pair < Hop , Hop > ( hop , c ) ) ; } } hop . setVisited ( VisitStatus . DONE ) ; }
default boolean ifString ( Consumer < String > consumer ) { if ( isString ( ) ) { consumer . accept ( asString ( ) ) ; return _BOOL ; } return _BOOL ; }
private static void populateBlocks ( Set < Distributable > uniqueBlocks , int noOfBlocksPerNode , List < Distributable > blockLst ) { Iterator < Distributable > blocks = uniqueBlocks . iterator ( ) ; if ( blockLst . size ( ) == noOfBlocksPerNode ) { return ; } while ( blocks . hasNext ( ) ) { Distributable block = blocks . next ( ) ; blockLst . add ( block ) ; blocks . remove ( ) ; if ( blockLst . size ( ) >= noOfBlocksPerNode ) { break ; } } }
public void append ( byte [ ] bytes , int offset , int length ) { while ( length > _NUM ) { int freeSpaceInEndChunk = mChunks . size ( ) * mChunkSize - mSize ; int positionInEndChunk = mChunkSize - freeSpaceInEndChunk ; if ( freeSpaceInEndChunk == _NUM ) { mChunks . add ( new byte [ mChunkSize ] ) ; freeSpaceInEndChunk = mChunkSize ; positionInEndChunk = _NUM ; } byte [ ] endChunk = mChunks . get ( mChunks . size ( ) - _NUM ) ; if ( length > freeSpaceInEndChunk ) { System . arraycopy ( bytes , offset , endChunk , positionInEndChunk , freeSpaceInEndChunk ) ; mSize += freeSpaceInEndChunk ; offset += freeSpaceInEndChunk ; length -= freeSpaceInEndChunk ; } else { System . arraycopy ( bytes , offset , endChunk , positionInEndChunk , length ) ; mSize += length ; offset += length ; length = _NUM ; } } }
@ Override public void addNewSubscription ( final Subscription newSubscription ) { final String clientID = newSubscription . getClientId ( ) ; List < ClientTopicCouple > clientSubscriptions = subscriptions . get ( clientID ) ; if ( clientSubscriptions == null ) { clientSubscriptions = new ArrayList < > ( ) ; subscriptions . put ( clientID , clientSubscriptions ) ; } clientSubscriptions . add ( newSubscription . asClientTopicCouple ( ) ) ; }
@ Override protected void createMenus ( JMenuBar menuBar , WindowInterface wi ) { super . createMenus ( menuBar , wi ) ; developmentMenu ( menuBar , wi ) ; menuBar . add ( new jmri . jmris . ServerMenu ( ) ) ; }
protected void addMultipart ( NokiaItemType theItemType , byte [ ] data ) { parts_ . add ( new NokiaPart ( theItemType , data ) ) ; }
public int matchesRecommended ( Map < String , String > tagSet ) { if ( name . equals ( STRING ) ) { Log . d ( DEBUG_TAG , STRING ) ; } int matches = _NUM ; for ( Entry < String , StringWithDescription [ ] > tag : recommendedTags . entrySet ( ) ) { String key = tag . getKey ( ) ; if ( tagSet . containsKey ( key ) ) { if ( getMatchType ( key ) == MatchType . NONE ) { break ; } if ( getMatchType ( key ) == MatchType . KEY ) { matches ++ ; break ; } String otherTagValue = tagSet . get ( key ) ; for ( StringWithDescription v : tag . getValue ( ) ) { if ( v . equals ( otherTagValue ) ) { matches ++ ; break ; } } } } return matches ; }
@ TargetApi ( Build . VERSION_CODES . LOLLIPOP ) public OptionScanNode buildTreeFromWindowList ( List < SwitchAccessWindowInfo > windowList , OptionScanNode contextMenuTree ) { contextMenuTree = ( contextMenuTree == null ) ? new ClearFocusNode ( ) : contextMenuTree ; if ( windowList == null || windowList . size ( ) == _NUM ) { return contextMenuTree ; } List < OptionScanNode > treeNodes = new ArrayList < > ( ) ; for ( SwitchAccessWindowInfo window : windowList ) { SwitchAccessNodeCompat windowRoot = window . getRoot ( ) ; if ( windowRoot != null ) { treeNodes . addAll ( getNodeListFromNodeTree ( windowRoot ) ) ; windowRoot . recycle ( ) ; } } return buildTreeFromNodeList ( treeNodes , OPTION_SCAN_SELECTION_NODE , contextMenuTree ) ; }
public static String trim ( final String value ) { return ( value == null ? null : value . trim ( ) ) ; }
final void revalidate ( ) { for ( Document doc : documents ) { if ( doc . getLength ( ) == _NUM ) { component . setEnabled ( _BOOL ) ; return ; } } component . setEnabled ( _BOOL ) ; }
final void revalidate ( ) { for ( Document doc : documents ) { if ( doc . getLength ( ) == _NUM ) { component . setEnabled ( _BOOL ) ; return ; } } component . setEnabled ( _BOOL ) ; }
public void keepPredictions ( boolean keepPredictions ) { this . keepPredictions = keepPredictions ; }
public void keepPredictions ( boolean keepPredictions ) { this . keepPredictions = keepPredictions ; }
public void keepPredictions ( boolean keepPredictions ) { this . keepPredictions = keepPredictions ; }
public void keepPredictions ( boolean keepPredictions ) { this . keepPredictions = keepPredictions ; }
public static int findOptimalRoot ( int [ ] msg ) { final int size = ( msg . length > > _NUM ) + _NUM ; int [ ] depth = new int [ size ] ; int [ ] missing = new int [ size ] ; int root = - _NUM ; for ( int i = _NUM ; i < size ; i ++ ) { boolean active = _BOOL ; for ( int e = _NUM ; e < msg . length ; e += _NUM ) { if ( depth [ msg [ e ] ] == _NUM ) { missing [ msg [ e + _NUM ] ] ++ ; } if ( depth [ msg [ e + _NUM ] ] == _NUM ) { missing [ msg [ e ] ] ++ ; } } for ( int n = _NUM ; n < size ; n ++ ) { if ( depth [ n ] == _NUM && missing [ n ] <= _NUM ) { depth [ n ] = i ; root = n ; active = _BOOL ; } } if ( ! active ) { break ; } Arrays . fill ( missing , _NUM ) ; } return root ; }
public static int findOptimalRoot ( int [ ] msg ) { final int size = ( msg . length > > _NUM ) + _NUM ; int [ ] depth = new int [ size ] ; int [ ] missing = new int [ size ] ; int root = - _NUM ; for ( int i = _NUM ; i < size ; i ++ ) { boolean active = _BOOL ; for ( int e = _NUM ; e < msg . length ; e += _NUM ) { if ( depth [ msg [ e ] ] == _NUM ) { missing [ msg [ e + _NUM ] ] ++ ; } if ( depth [ msg [ e + _NUM ] ] == _NUM ) { missing [ msg [ e ] ] ++ ; } } for ( int n = _NUM ; n < size ; n ++ ) { if ( depth [ n ] == _NUM && missing [ n ] <= _NUM ) { depth [ n ] = i ; root = n ; active = _BOOL ; } } if ( ! active ) { break ; } Arrays . fill ( missing , _NUM ) ; } return root ; }
public static int findOptimalRoot ( int [ ] msg ) { final int size = ( msg . length > > _NUM ) + _NUM ; int [ ] depth = new int [ size ] ; int [ ] missing = new int [ size ] ; int root = - _NUM ; for ( int i = _NUM ; i < size ; i ++ ) { boolean active = _BOOL ; for ( int e = _NUM ; e < msg . length ; e += _NUM ) { if ( depth [ msg [ e ] ] == _NUM ) { missing [ msg [ e + _NUM ] ] ++ ; } if ( depth [ msg [ e + _NUM ] ] == _NUM ) { missing [ msg [ e ] ] ++ ; } } for ( int n = _NUM ; n < size ; n ++ ) { if ( depth [ n ] == _NUM && missing [ n ] <= _NUM ) { depth [ n ] = i ; root = n ; active = _BOOL ; } } if ( ! active ) { break ; } Arrays . fill ( missing , _NUM ) ; } return root ; }
public static int findOptimalRoot ( int [ ] msg ) { final int size = ( msg . length > > _NUM ) + _NUM ; int [ ] depth = new int [ size ] ; int [ ] missing = new int [ size ] ; int root = - _NUM ; for ( int i = _NUM ; i < size ; i ++ ) { boolean active = _BOOL ; for ( int e = _NUM ; e < msg . length ; e += _NUM ) { if ( depth [ msg [ e ] ] == _NUM ) { missing [ msg [ e + _NUM ] ] ++ ; } if ( depth [ msg [ e + _NUM ] ] == _NUM ) { missing [ msg [ e ] ] ++ ; } } for ( int n = _NUM ; n < size ; n ++ ) { if ( depth [ n ] == _NUM && missing [ n ] <= _NUM ) { depth [ n ] = i ; root = n ; active = _BOOL ; } } if ( ! active ) { break ; } Arrays . fill ( missing , _NUM ) ; } return root ; }
public static int findOptimalRoot ( int [ ] msg ) { final int size = ( msg . length > > _NUM ) + _NUM ; int [ ] depth = new int [ size ] ; int [ ] missing = new int [ size ] ; int root = - _NUM ; for ( int i = _NUM ; i < size ; i ++ ) { boolean active = _BOOL ; for ( int e = _NUM ; e < msg . length ; e += _NUM ) { if ( depth [ msg [ e ] ] == _NUM ) { missing [ msg [ e + _NUM ] ] ++ ; } if ( depth [ msg [ e + _NUM ] ] == _NUM ) { missing [ msg [ e ] ] ++ ; } } for ( int n = _NUM ; n < size ; n ++ ) { if ( depth [ n ] == _NUM && missing [ n ] <= _NUM ) { depth [ n ] = i ; root = n ; active = _BOOL ; } } if ( ! active ) { break ; } Arrays . fill ( missing , _NUM ) ; } return root ; }
public static int findOptimalRoot ( int [ ] msg ) { final int size = ( msg . length > > _NUM ) + _NUM ; int [ ] depth = new int [ size ] ; int [ ] missing = new int [ size ] ; int root = - _NUM ; for ( int i = _NUM ; i < size ; i ++ ) { boolean active = _BOOL ; for ( int e = _NUM ; e < msg . length ; e += _NUM ) { if ( depth [ msg [ e ] ] == _NUM ) { missing [ msg [ e + _NUM ] ] ++ ; } if ( depth [ msg [ e + _NUM ] ] == _NUM ) { missing [ msg [ e ] ] ++ ; } } for ( int n = _NUM ; n < size ; n ++ ) { if ( depth [ n ] == _NUM && missing [ n ] <= _NUM ) { depth [ n ] = i ; root = n ; active = _BOOL ; } } if ( ! active ) { break ; } Arrays . fill ( missing , _NUM ) ; } return root ; }
public static int findOptimalRoot ( int [ ] msg ) { final int size = ( msg . length > > _NUM ) + _NUM ; int [ ] depth = new int [ size ] ; int [ ] missing = new int [ size ] ; int root = - _NUM ; for ( int i = _NUM ; i < size ; i ++ ) { boolean active = _BOOL ; for ( int e = _NUM ; e < msg . length ; e += _NUM ) { if ( depth [ msg [ e ] ] == _NUM ) { missing [ msg [ e + _NUM ] ] ++ ; } if ( depth [ msg [ e + _NUM ] ] == _NUM ) { missing [ msg [ e ] ] ++ ; } } for ( int n = _NUM ; n < size ; n ++ ) { if ( depth [ n ] == _NUM && missing [ n ] <= _NUM ) { depth [ n ] = i ; root = n ; active = _BOOL ; } } if ( ! active ) { break ; } Arrays . fill ( missing , _NUM ) ; } return root ; }
public static int findOptimalRoot ( int [ ] msg ) { final int size = ( msg . length > > _NUM ) + _NUM ; int [ ] depth = new int [ size ] ; int [ ] missing = new int [ size ] ; int root = - _NUM ; for ( int i = _NUM ; i < size ; i ++ ) { boolean active = _BOOL ; for ( int e = _NUM ; e < msg . length ; e += _NUM ) { if ( depth [ msg [ e ] ] == _NUM ) { missing [ msg [ e + _NUM ] ] ++ ; } if ( depth [ msg [ e + _NUM ] ] == _NUM ) { missing [ msg [ e ] ] ++ ; } } for ( int n = _NUM ; n < size ; n ++ ) { if ( depth [ n ] == _NUM && missing [ n ] <= _NUM ) { depth [ n ] = i ; root = n ; active = _BOOL ; } } if ( ! active ) { break ; } Arrays . fill ( missing , _NUM ) ; } return root ; }
public void guard ( final Runnable r ) { incThread ( ) ; try { r . run ( ) ; } finally { decThread ( ) ; } }
public void guard ( final Runnable r ) { incThread ( ) ; try { r . run ( ) ; } finally { decThread ( ) ; } }
public void guard ( final Runnable r ) { incThread ( ) ; try { r . run ( ) ; } finally { decThread ( ) ; } }
private void initCircleCropWindow ( @ NonNull RectF bitmapRect ) { mOffset = _NUM * Math . min ( bitmapRect . width ( ) , bitmapRect . height ( ) ) ; mDrawableWidth = bitmapRect . width ( ) ; mDrawableHeight = bitmapRect . height ( ) ; mCenterPointX = mDrawableWidth / _NUM ; mCenterPointY = mDrawableHeight / _NUM ; mRadius = ( Math . min ( mDrawableWidth , mDrawableHeight ) - mOffset ) / _NUM ; }
private void initCircleCropWindow ( @ NonNull RectF bitmapRect ) { mOffset = _NUM * Math . min ( bitmapRect . width ( ) , bitmapRect . height ( ) ) ; mDrawableWidth = bitmapRect . width ( ) ; mDrawableHeight = bitmapRect . height ( ) ; mCenterPointX = mDrawableWidth / _NUM ; mCenterPointY = mDrawableHeight / _NUM ; mRadius = ( Math . min ( mDrawableWidth , mDrawableHeight ) - mOffset ) / _NUM ; }
private void initCircleCropWindow ( @ NonNull RectF bitmapRect ) { mOffset = _NUM * Math . min ( bitmapRect . width ( ) , bitmapRect . height ( ) ) ; mDrawableWidth = bitmapRect . width ( ) ; mDrawableHeight = bitmapRect . height ( ) ; mCenterPointX = mDrawableWidth / _NUM ; mCenterPointY = mDrawableHeight / _NUM ; mRadius = ( Math . min ( mDrawableWidth , mDrawableHeight ) - mOffset ) / _NUM ; }
Color nextColor ( ) { int red = Math . min ( _NUM , ( ( measurementColor > > _NUM ) & _NUM ) * _NUM / _NUM ) ; int green = Math . min ( _NUM , ( ( measurementColor > > _NUM ) & _NUM ) * _NUM / _NUM ) ; int blue = Math . min ( _NUM , ( ( measurementColor > > _NUM ) & _NUM ) * _NUM / _NUM ) ; measurementColor ++ ; return new Color ( red , green , blue ) ; }
void addWaitStatement ( ) { if ( isRecording ( ) ) { long t = System . currentTimeMillis ( ) ; long d = t - waitTimer ; generatedCode += STRING + d + STRING ; waitTimer = t ; } }
void addWaitStatement ( ) { if ( isRecording ( ) ) { long t = System . currentTimeMillis ( ) ; long d = t - waitTimer ; generatedCode += STRING + d + STRING ; waitTimer = t ; } }
void addWaitStatement ( ) { if ( isRecording ( ) ) { long t = System . currentTimeMillis ( ) ; long d = t - waitTimer ; generatedCode += STRING + d + STRING ; waitTimer = t ; } }
long offer ( int part , long addr , int hash ) throws GridOffHeapOutOfMemoryException { lock . lock ( ) ; try { long qAddr = mem . allocateSystem ( NODE , _BOOL ) ; if ( head == _NUM ) head = qAddr ; long prev = tail ; tail = qAddr ; if ( prev != _NUM ) next ( prev , qAddr ) ; order ( qAddr ) ; partition ( qAddr , part ) ; polling ( qAddr , _BOOL ) ; hash ( qAddr , hash ) ; entry ( qAddr , addr ) ; previous ( qAddr , prev ) ; next ( qAddr , _NUM ) ; size ++ ; return qAddr ; } finally { lock . unlock ( ) ; } }
long offer ( int part , long addr , int hash ) throws GridOffHeapOutOfMemoryException { lock . lock ( ) ; try { long qAddr = mem . allocateSystem ( NODE , _BOOL ) ; if ( head == _NUM ) head = qAddr ; long prev = tail ; tail = qAddr ; if ( prev != _NUM ) next ( prev , qAddr ) ; order ( qAddr ) ; partition ( qAddr , part ) ; polling ( qAddr , _BOOL ) ; hash ( qAddr , hash ) ; entry ( qAddr , addr ) ; previous ( qAddr , prev ) ; next ( qAddr , _NUM ) ; size ++ ; return qAddr ; } finally { lock . unlock ( ) ; } }
private static float CallStaticFloatMethodV ( JNIEnvironment env , int classJREF , int methodID , Address argAddress ) throws Exception { if ( traceJNI ) VM . sysWrite ( STRING ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { Object returnObj = JNIHelpers . invokeWithVarArg ( methodID , argAddress , TypeReference . Float ) ; return Reflection . unwrapFloat ( returnObj ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return _NUM ; } }
private static float CallStaticFloatMethodV ( JNIEnvironment env , int classJREF , int methodID , Address argAddress ) throws Exception { if ( traceJNI ) VM . sysWrite ( STRING ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { Object returnObj = JNIHelpers . invokeWithVarArg ( methodID , argAddress , TypeReference . Float ) ; return Reflection . unwrapFloat ( returnObj ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return _NUM ; } }
@ Override public synchronized void addInstanceListener ( InstanceListener dsl ) { m_instanceListeners . addElement ( dsl ) ; if ( m_format != null ) { InstanceEvent e = new InstanceEvent ( this , m_format ) ; dsl . acceptInstance ( e ) ; } }
public boolean containsBaseTypeOnly ( ) { return members . isEmpty ( ) ; }
public static void appendEscapedTextToBuilder ( StringBuilder out , String item , char separator ) { for ( int i = _NUM ; i < item . length ( ) ; i ++ ) { char ch = item . charAt ( i ) ; if ( ch == STRING || ch == separator ) { out . append ( STRING ) ; } out . append ( ch ) ; } }
public static void join ( DetachedBaggage otherBaggage ) { if ( otherBaggage == null || otherBaggage . impl == null ) { return ; } BaggageImpl impl = current . get ( ) ; if ( impl == null ) { current . set ( otherBaggage . impl ) ; } else { impl . merge ( otherBaggage . impl ) ; } otherBaggage . impl = null ; }
public static void join ( DetachedBaggage otherBaggage ) { if ( otherBaggage == null || otherBaggage . impl == null ) { return ; } BaggageImpl impl = current . get ( ) ; if ( impl == null ) { current . set ( otherBaggage . impl ) ; } else { impl . merge ( otherBaggage . impl ) ; } otherBaggage . impl = null ; }
public static void join ( DetachedBaggage otherBaggage ) { if ( otherBaggage == null || otherBaggage . impl == null ) { return ; } BaggageImpl impl = current . get ( ) ; if ( impl == null ) { current . set ( otherBaggage . impl ) ; } else { impl . merge ( otherBaggage . impl ) ; } otherBaggage . impl = null ; }
public static void join ( DetachedBaggage otherBaggage ) { if ( otherBaggage == null || otherBaggage . impl == null ) { return ; } BaggageImpl impl = current . get ( ) ; if ( impl == null ) { current . set ( otherBaggage . impl ) ; } else { impl . merge ( otherBaggage . impl ) ; } otherBaggage . impl = null ; }
public static void join ( DetachedBaggage otherBaggage ) { if ( otherBaggage == null || otherBaggage . impl == null ) { return ; } BaggageImpl impl = current . get ( ) ; if ( impl == null ) { current . set ( otherBaggage . impl ) ; } else { impl . merge ( otherBaggage . impl ) ; } otherBaggage . impl = null ; }
private static void logOsInfo ( ) { Logger . appendLog ( STRING + Cfg . getOs ( ) ) ; Logger . appendLog ( STRING + Os . getOsName ( ) ) ; Logger . appendLog ( STRING + Os . platform ( ) ) ; Logger . appendLog ( STRING + System . getProperty ( STRING ) ) ; Logger . appendLog ( STRING + HostInfo . availableCpus ( ) ) ; Logger . appendLog ( STRING + HostInfo . getMaxMemory ( ) + STRING ) ; }
public static void startServer ( ) { startServer ( Charset . defaultCharset ( ) , null ) ; }
boolean isSocketScheme ( String scheme ) { for ( String p : URIHelper . SOCKET_SCHEMES ) { if ( p . equals ( scheme ) ) { return _BOOL ; } } return _BOOL ; }
boolean isSocketScheme ( String scheme ) { for ( String p : URIHelper . SOCKET_SCHEMES ) { if ( p . equals ( scheme ) ) { return _BOOL ; } } return _BOOL ; }
public byte [ ] handleRequest ( String request ) throws IOException , MapRequestFormatException { Properties requestProperties = convertRequestToProps ( request ) ; String requestType = requestProperties . getProperty ( REQUEST ) ; if ( requestType != null ) { if ( requestType . equalsIgnoreCase ( MAP ) ) { Debug . message ( STRING , STRING ) ; return handleMapRequest ( requestProperties ) ; } else { throw new MapRequestFormatException ( STRING + requestType ) ; } } else { throw new MapRequestFormatException ( STRING + request ) ; } }
public byte [ ] handleRequest ( String request ) throws IOException , MapRequestFormatException { Properties requestProperties = convertRequestToProps ( request ) ; String requestType = requestProperties . getProperty ( REQUEST ) ; if ( requestType != null ) { if ( requestType . equalsIgnoreCase ( MAP ) ) { Debug . message ( STRING , STRING ) ; return handleMapRequest ( requestProperties ) ; } else { throw new MapRequestFormatException ( STRING + requestType ) ; } } else { throw new MapRequestFormatException ( STRING + request ) ; } }
public Composer transform ( float x , float y , int alpha , float scaleX , float scaleY , float rotation ) { if ( mTweenParameterList . size ( ) > _NUM ) { to ( _NUM , x , y , alpha , scaleX , scaleY , rotation , Ease . NONE ) ; } else { mInitialParam = new AnimParameter ( x , y , alpha , scaleX , scaleY , rotation ) ; } return this ; }
public Composer transform ( float x , float y , int alpha , float scaleX , float scaleY , float rotation ) { if ( mTweenParameterList . size ( ) > _NUM ) { to ( _NUM , x , y , alpha , scaleX , scaleY , rotation , Ease . NONE ) ; } else { mInitialParam = new AnimParameter ( x , y , alpha , scaleX , scaleY , rotation ) ; } return this ; }
public Composer transform ( float x , float y , int alpha , float scaleX , float scaleY , float rotation ) { if ( mTweenParameterList . size ( ) > _NUM ) { to ( _NUM , x , y , alpha , scaleX , scaleY , rotation , Ease . NONE ) ; } else { mInitialParam = new AnimParameter ( x , y , alpha , scaleX , scaleY , rotation ) ; } return this ; }
private void determineFunctionCandidatesNNZPropagation ( Map < String , FunctionOp > fcandHops , Map < String , Set < Long > > fcandSafeNNZ ) { for ( Entry < String , FunctionOp > e : fcandHops . entrySet ( ) ) { String fKey = e . getKey ( ) ; FunctionOp fop = e . getValue ( ) ; HashSet < Long > tmp = new HashSet < Long > ( ) ; for ( Hop input : fop . getInput ( ) ) { if ( input . getNnz ( ) >= _NUM ) tmp . add ( input . getHopID ( ) ) ; } fcandSafeNNZ . put ( fKey , tmp ) ; } }
private void determineFunctionCandidatesNNZPropagation ( Map < String , FunctionOp > fcandHops , Map < String , Set < Long > > fcandSafeNNZ ) { for ( Entry < String , FunctionOp > e : fcandHops . entrySet ( ) ) { String fKey = e . getKey ( ) ; FunctionOp fop = e . getValue ( ) ; HashSet < Long > tmp = new HashSet < Long > ( ) ; for ( Hop input : fop . getInput ( ) ) { if ( input . getNnz ( ) >= _NUM ) tmp . add ( input . getHopID ( ) ) ; } fcandSafeNNZ . put ( fKey , tmp ) ; } }
private void determineFunctionCandidatesNNZPropagation ( Map < String , FunctionOp > fcandHops , Map < String , Set < Long > > fcandSafeNNZ ) { for ( Entry < String , FunctionOp > e : fcandHops . entrySet ( ) ) { String fKey = e . getKey ( ) ; FunctionOp fop = e . getValue ( ) ; HashSet < Long > tmp = new HashSet < Long > ( ) ; for ( Hop input : fop . getInput ( ) ) { if ( input . getNnz ( ) >= _NUM ) tmp . add ( input . getHopID ( ) ) ; } fcandSafeNNZ . put ( fKey , tmp ) ; } }
@ Override public int storedMB ( ) { long bytes = _NUM ; final File [ ] files = cacheDirectory . listFiles ( ) ; if ( files == null ) return _NUM ; for ( File file : files ) { bytes += file . length ( ) ; } double megabytes = Math . ceil ( ( double ) bytes / _NUM / _NUM ) ; return ( int ) megabytes ; }
public void calculate_scores ( ) { score = _NUM ; if ( contents . length == _NUM ) { API api = API . v ( ) ; Set < InfoKind > source = api . getSourceInfoKinds ( method ) ; Set < InfoKind > sink = api . getSinkInfoKinds ( method ) ; if ( is_system ( method ) ) { if ( api . isSafeMethod ( method ) ) score = _NUM ; else if ( api . isSpecMethod ( method ) ) score = _NUM ; else if ( api . isBannedMethod ( method ) ) score = _NUM ; if ( ! source . isEmpty ( ) ) score += _NUM ; else if ( ! sink . isEmpty ( ) ) score += _NUM ; } return ; } for ( SourceCallChainInfo cci : contents ) { cci . calculate_scores ( ) ; calls += cci . calls ; syscalls += cci . syscalls ; if ( cci . score > score ) score = cci . score ; } }
protected static Span findRootOrServerSpan ( String tenantId , Span span , SpanCache spanCache ) { while ( span != null && ! span . serverSpan ( ) && ! span . topLevelSpan ( ) ) { span = spanCache . get ( tenantId , span . getParentId ( ) ) ; } return span ; }
protected static Span findRootOrServerSpan ( String tenantId , Span span , SpanCache spanCache ) { while ( span != null && ! span . serverSpan ( ) && ! span . topLevelSpan ( ) ) { span = spanCache . get ( tenantId , span . getParentId ( ) ) ; } return span ; }
protected static Span findRootOrServerSpan ( String tenantId , Span span , SpanCache spanCache ) { while ( span != null && ! span . serverSpan ( ) && ! span . topLevelSpan ( ) ) { span = spanCache . get ( tenantId , span . getParentId ( ) ) ; } return span ; }
public void toggle ( JFXDrawer drawer ) { if ( ! drawers . contains ( drawer ) ) addDrawer ( drawer ) ; if ( drawer . isShown ( ) || drawer . isShowing ( ) ) drawer . close ( ) ; else { updateDrawerPosition ( drawer ) ; drawer . open ( ) ; } }
public static long secondsSinceMillis ( long timeInMillis ) { return ( System . currentTimeMillis ( ) - timeInMillis ) / _NUM ; }
public static long secondsSinceMillis ( long timeInMillis ) { return ( System . currentTimeMillis ( ) - timeInMillis ) / _NUM ; }
public FieldStorageSchemeImpl ( int digestSize , String algorithm ) throws Exception { this . messageDigest = MessageDigest . getInstance ( algorithm ) ; this . digestLock = new Object ( ) ; this . random = new SecureRandom ( ) ; this . digestSize = digestSize ; }
public synchronized TypeInstance createInstance ( final String name , final String comment , final BaseType baseType , final Section section , final long sectionOffset ) throws CouldntSaveDataException , CouldntLoadDataException { Preconditions . checkNotNull ( name , STRING ) ; Preconditions . checkArgument ( comment == null || ! comment . isEmpty ( ) , STRING ) ; Preconditions . checkNotNull ( baseType , STRING ) ; Preconditions . checkNotNull ( section , STRING ) ; Preconditions . checkArgument ( sectionOffset >= _NUM , STRING ) ; Preconditions . checkArgument ( ! instancesByAddress . containsKey ( new TypeInstanceAddress ( section . getStartAddress ( ) , sectionOffset ) ) ) ; final TypeInstance instance = backend . createTypeInstance ( name , comment , baseType , section , sectionOffset ) ; instancesByAddress . put ( instance . getAddress ( ) , instance ) ; instances . add ( instance ) ; notifyInstanceAdded ( instance ) ; return instance ; }
public SpeechData ( byte [ ] data ) { AudioInputStream stream = AudioUtils . getAudioStream ( data ) ; format = stream . getFormat ( ) ; this . data = data ; isFinal = _BOOL ; }
protected ClassNode inferReturnTypeGenerics ( ClassNode receiver , MethodNode method , Expression arguments ) { return inferReturnTypeGenerics ( receiver , method , arguments , null ) ; }
protected ClassNode inferReturnTypeGenerics ( ClassNode receiver , MethodNode method , Expression arguments ) { return inferReturnTypeGenerics ( receiver , method , arguments , null ) ; }
protected ClassNode inferReturnTypeGenerics ( ClassNode receiver , MethodNode method , Expression arguments ) { return inferReturnTypeGenerics ( receiver , method , arguments , null ) ; }
protected ClassNode inferReturnTypeGenerics ( ClassNode receiver , MethodNode method , Expression arguments ) { return inferReturnTypeGenerics ( receiver , method , arguments , null ) ; }
public DeadLockDetector ( int sleepTime , byte doWhenDL ) { super ( STRING ) ; this . sleepTime = sleepTime * _NUM ; this . tmx = ManagementFactory . getThreadMXBean ( ) ; this . doWhenDL = doWhenDL ; }
public static Date convertISO8601toDate ( String dateString ) throws ParseException { DateFormat dateFormat = new SimpleDateFormat ( STRING ) ; Date date = dateFormat . parse ( dateString ) ; return date ; }
public synchronized String generateCallIdentifier ( String address ) { String date = Long . toString ( System . currentTimeMillis ( ) + callIDCounter ++ + rand . nextLong ( ) ) ; byte cid [ ] = digester . digest ( date . getBytes ( ) ) ; String cidString = Utils . toHexString ( cid ) ; return cidString + STRING + address ; }
public synchronized String generateCallIdentifier ( String address ) { String date = Long . toString ( System . currentTimeMillis ( ) + callIDCounter ++ + rand . nextLong ( ) ) ; byte cid [ ] = digester . digest ( date . getBytes ( ) ) ; String cidString = Utils . toHexString ( cid ) ; return cidString + STRING + address ; }
public synchronized String generateCallIdentifier ( String address ) { String date = Long . toString ( System . currentTimeMillis ( ) + callIDCounter ++ + rand . nextLong ( ) ) ; byte cid [ ] = digester . digest ( date . getBytes ( ) ) ; String cidString = Utils . toHexString ( cid ) ; return cidString + STRING + address ; }
public synchronized String generateCallIdentifier ( String address ) { String date = Long . toString ( System . currentTimeMillis ( ) + callIDCounter ++ + rand . nextLong ( ) ) ; byte cid [ ] = digester . digest ( date . getBytes ( ) ) ; String cidString = Utils . toHexString ( cid ) ; return cidString + STRING + address ; }
public boolean consumeEncumbranceBudget ( final Map < String , Object > detailsMap ) { if ( detailsMap == null ) throw new ValidationException ( Arrays . asList ( new ValidationError ( STRING , STRING ) ) ) ; detailsMap . put ( Constants . CONSUMEORRELEASE , _BOOL ) ; final BigDecimal bd = getDetails ( detailsMap ) ; return bd . intValue ( ) == _NUM ; }
public boolean consumeEncumbranceBudget ( final Map < String , Object > detailsMap ) { if ( detailsMap == null ) throw new ValidationException ( Arrays . asList ( new ValidationError ( STRING , STRING ) ) ) ; detailsMap . put ( Constants . CONSUMEORRELEASE , _BOOL ) ; final BigDecimal bd = getDetails ( detailsMap ) ; return bd . intValue ( ) == _NUM ; }
public boolean consumeEncumbranceBudget ( final Map < String , Object > detailsMap ) { if ( detailsMap == null ) throw new ValidationException ( Arrays . asList ( new ValidationError ( STRING , STRING ) ) ) ; detailsMap . put ( Constants . CONSUMEORRELEASE , _BOOL ) ; final BigDecimal bd = getDetails ( detailsMap ) ; return bd . intValue ( ) == _NUM ; }
public boolean consumeEncumbranceBudget ( final Map < String , Object > detailsMap ) { if ( detailsMap == null ) throw new ValidationException ( Arrays . asList ( new ValidationError ( STRING , STRING ) ) ) ; detailsMap . put ( Constants . CONSUMEORRELEASE , _BOOL ) ; final BigDecimal bd = getDetails ( detailsMap ) ; return bd . intValue ( ) == _NUM ; }
public boolean consumeEncumbranceBudget ( final Map < String , Object > detailsMap ) { if ( detailsMap == null ) throw new ValidationException ( Arrays . asList ( new ValidationError ( STRING , STRING ) ) ) ; detailsMap . put ( Constants . CONSUMEORRELEASE , _BOOL ) ; final BigDecimal bd = getDetails ( detailsMap ) ; return bd . intValue ( ) == _NUM ; }
public boolean consumeEncumbranceBudget ( final Map < String , Object > detailsMap ) { if ( detailsMap == null ) throw new ValidationException ( Arrays . asList ( new ValidationError ( STRING , STRING ) ) ) ; detailsMap . put ( Constants . CONSUMEORRELEASE , _BOOL ) ; final BigDecimal bd = getDetails ( detailsMap ) ; return bd . intValue ( ) == _NUM ; }
public boolean consumeEncumbranceBudget ( final Map < String , Object > detailsMap ) { if ( detailsMap == null ) throw new ValidationException ( Arrays . asList ( new ValidationError ( STRING , STRING ) ) ) ; detailsMap . put ( Constants . CONSUMEORRELEASE , _BOOL ) ; final BigDecimal bd = getDetails ( detailsMap ) ; return bd . intValue ( ) == _NUM ; }
public boolean consumeEncumbranceBudget ( final Map < String , Object > detailsMap ) { if ( detailsMap == null ) throw new ValidationException ( Arrays . asList ( new ValidationError ( STRING , STRING ) ) ) ; detailsMap . put ( Constants . CONSUMEORRELEASE , _BOOL ) ; final BigDecimal bd = getDetails ( detailsMap ) ; return bd . intValue ( ) == _NUM ; }
public boolean consumeEncumbranceBudget ( final Map < String , Object > detailsMap ) { if ( detailsMap == null ) throw new ValidationException ( Arrays . asList ( new ValidationError ( STRING , STRING ) ) ) ; detailsMap . put ( Constants . CONSUMEORRELEASE , _BOOL ) ; final BigDecimal bd = getDetails ( detailsMap ) ; return bd . intValue ( ) == _NUM ; }
public boolean consumeEncumbranceBudget ( final Map < String , Object > detailsMap ) { if ( detailsMap == null ) throw new ValidationException ( Arrays . asList ( new ValidationError ( STRING , STRING ) ) ) ; detailsMap . put ( Constants . CONSUMEORRELEASE , _BOOL ) ; final BigDecimal bd = getDetails ( detailsMap ) ; return bd . intValue ( ) == _NUM ; }
public boolean consumeEncumbranceBudget ( final Map < String , Object > detailsMap ) { if ( detailsMap == null ) throw new ValidationException ( Arrays . asList ( new ValidationError ( STRING , STRING ) ) ) ; detailsMap . put ( Constants . CONSUMEORRELEASE , _BOOL ) ; final BigDecimal bd = getDetails ( detailsMap ) ; return bd . intValue ( ) == _NUM ; }
public boolean consumeEncumbranceBudget ( final Map < String , Object > detailsMap ) { if ( detailsMap == null ) throw new ValidationException ( Arrays . asList ( new ValidationError ( STRING , STRING ) ) ) ; detailsMap . put ( Constants . CONSUMEORRELEASE , _BOOL ) ; final BigDecimal bd = getDetails ( detailsMap ) ; return bd . intValue ( ) == _NUM ; }
public boolean consumeEncumbranceBudget ( final Map < String , Object > detailsMap ) { if ( detailsMap == null ) throw new ValidationException ( Arrays . asList ( new ValidationError ( STRING , STRING ) ) ) ; detailsMap . put ( Constants . CONSUMEORRELEASE , _BOOL ) ; final BigDecimal bd = getDetails ( detailsMap ) ; return bd . intValue ( ) == _NUM ; }
public boolean consumeEncumbranceBudget ( final Map < String , Object > detailsMap ) { if ( detailsMap == null ) throw new ValidationException ( Arrays . asList ( new ValidationError ( STRING , STRING ) ) ) ; detailsMap . put ( Constants . CONSUMEORRELEASE , _BOOL ) ; final BigDecimal bd = getDetails ( detailsMap ) ; return bd . intValue ( ) == _NUM ; }
public boolean hasForward ( ) { if ( index + _NUM < history . size ( ) && index >= _NUM ) { return _BOOL ; } else { return _BOOL ; } }
public boolean removeTelegramListener ( TelegramListener remListener ) { return ( TelegramListeners . remove ( remListener ) ) ; }
public boolean removeTelegramListener ( TelegramListener remListener ) { return ( TelegramListeners . remove ( remListener ) ) ; }
public static final ArrayList readListXml ( InputStream in ) throws XmlPullParserException , java . io . IOException { XmlPullParser parser = Xml . newPullParser ( ) ; parser . setInput ( in , null ) ; return ( ArrayList ) readValueXml ( parser , new String [ _NUM ] ) ; }
public static final ArrayList readListXml ( InputStream in ) throws XmlPullParserException , java . io . IOException { XmlPullParser parser = Xml . newPullParser ( ) ; parser . setInput ( in , null ) ; return ( ArrayList ) readValueXml ( parser , new String [ _NUM ] ) ; }
public static final ArrayList readListXml ( InputStream in ) throws XmlPullParserException , java . io . IOException { XmlPullParser parser = Xml . newPullParser ( ) ; parser . setInput ( in , null ) ; return ( ArrayList ) readValueXml ( parser , new String [ _NUM ] ) ; }
public static final ArrayList readListXml ( InputStream in ) throws XmlPullParserException , java . io . IOException { XmlPullParser parser = Xml . newPullParser ( ) ; parser . setInput ( in , null ) ; return ( ArrayList ) readValueXml ( parser , new String [ _NUM ] ) ; }
public static final ArrayList readListXml ( InputStream in ) throws XmlPullParserException , java . io . IOException { XmlPullParser parser = Xml . newPullParser ( ) ; parser . setInput ( in , null ) ; return ( ArrayList ) readValueXml ( parser , new String [ _NUM ] ) ; }
public static final ArrayList readListXml ( InputStream in ) throws XmlPullParserException , java . io . IOException { XmlPullParser parser = Xml . newPullParser ( ) ; parser . setInput ( in , null ) ; return ( ArrayList ) readValueXml ( parser , new String [ _NUM ] ) ; }
protected void initResultMatrix ( ) { m_ResultMatrix . setSize ( getNumResultsets ( ) , getNumDatasets ( ) ) ; m_ResultMatrix . setShowStdDev ( m_ShowStdDevs ) ; for ( int i = _NUM ; i < getNumDatasets ( ) ; i ++ ) { m_ResultMatrix . setRowName ( i , templateString ( m_DatasetSpecifiers . specifier ( i ) ) ) ; } for ( int j = _NUM ; j < getNumResultsets ( ) ; j ++ ) { m_ResultMatrix . setColName ( j , getResultsetName ( j ) ) ; m_ResultMatrix . setColHidden ( j , ! displayResultset ( j ) ) ; } }
protected void initResultMatrix ( ) { m_ResultMatrix . setSize ( getNumResultsets ( ) , getNumDatasets ( ) ) ; m_ResultMatrix . setShowStdDev ( m_ShowStdDevs ) ; for ( int i = _NUM ; i < getNumDatasets ( ) ; i ++ ) { m_ResultMatrix . setRowName ( i , templateString ( m_DatasetSpecifiers . specifier ( i ) ) ) ; } for ( int j = _NUM ; j < getNumResultsets ( ) ; j ++ ) { m_ResultMatrix . setColName ( j , getResultsetName ( j ) ) ; m_ResultMatrix . setColHidden ( j , ! displayResultset ( j ) ) ; } }
public static void enterMethod ( int globalMethodId ) { final Thread ct = Thread . currentThread ( ) ; if ( ct == Agent . server || Thread . holdsLock ( rl ) || Thread . holdsLock ( globalLock ) || ct . getThreadGroup ( ) == systemThreadGroup || ct == Transformer . transformerThread ) { return ; } if ( ! enabled ) { return ; } synchronized ( globalLock ) { int sessionIdOfMethod = globalMethodId > > _NUM ; if ( sessionIdOfMethod != sessionId ) { return ; } int mid = globalMethodId & _NUM ; ThreadProfiler ti = null ; synchronized ( rl ) { ti = globalThreadInfos . get ( ct ) ; if ( ti == null ) { ti = new ThreadProfiler ( ) ; globalThreadInfos . put ( ct , ti ) ; } } ti . enter0 ( globalMethods [ mid ] ) ; } }
@ Override public int read ( final char [ ] array , final int offset , final int length ) { if ( idx >= charSequence . length ( ) ) { return EOF ; } if ( array == null ) { throw new NullPointerException ( STRING ) ; } if ( length < _NUM || offset < _NUM || offset + length > array . length ) { throw new IndexOutOfBoundsException ( STRING + array . length + STRING + offset + STRING + length ) ; } int count = _NUM ; for ( int i = _NUM ; i < length ; i ++ ) { final int c = read ( ) ; if ( c == EOF ) { return count ; } array [ offset + i ] = ( char ) c ; count ++ ; } return count ; }
public void accept ( final AnnotationVisitor av ) { if ( av != null ) { if ( values != null ) { for ( int i = _NUM ; i < values . size ( ) ; i += _NUM ) { String name = ( String ) values . get ( i ) ; Object value = values . get ( i + _NUM ) ; accept ( av , name , value ) ; } } av . visitEnd ( ) ; } }
public void resume ( ) { if ( ! isPaused ) return ; setAnimationInterval ( oldAnimationInterval_ ) ; lastUpdate_ = System . currentTimeMillis ( ) ; isPaused = _BOOL ; dt = _NUM ; }
public void resume ( ) { if ( ! isPaused ) return ; setAnimationInterval ( oldAnimationInterval_ ) ; lastUpdate_ = System . currentTimeMillis ( ) ; isPaused = _BOOL ; dt = _NUM ; }
protected void flushCache ( ) throws IOException { if ( cachePosition > _NUM ) { final byte chunkHeader [ ] = EncodingUtil . getAsciiBytes ( Integer . toHexString ( cachePosition ) + STRING ) ; stream . write ( chunkHeader , _NUM , chunkHeader . length ) ; stream . write ( cache , _NUM , cachePosition ) ; stream . write ( ENDCHUNK , _NUM , ENDCHUNK . length ) ; cachePosition = _NUM ; } }
protected void flushCache ( ) throws IOException { if ( cachePosition > _NUM ) { final byte chunkHeader [ ] = EncodingUtil . getAsciiBytes ( Integer . toHexString ( cachePosition ) + STRING ) ; stream . write ( chunkHeader , _NUM , chunkHeader . length ) ; stream . write ( cache , _NUM , cachePosition ) ; stream . write ( ENDCHUNK , _NUM , ENDCHUNK . length ) ; cachePosition = _NUM ; } }
public boolean dumpVMNamespace ( String namespace ) { return vmManager . dumpNamespace ( namespace ) ; }
public boolean dumpVMNamespace ( String namespace ) { return vmManager . dumpNamespace ( namespace ) ; }
private void updateGroupChatViewTitle ( String subject ) { if ( ! TextUtils . isEmpty ( subject ) ) { setTitle ( getString ( R . string . title_group_chat ) + STRING + mSubject + STRING ) ; } }
protected void writeHeader ( ) throws IOException { header = new byte [ SHAPE_FILE_HEADER_LENGTH ] ; writeBEInt ( header , _NUM , SHAPE_FILE_CODE ) ; writeBEInt ( header , _NUM , _NUM ) ; writeLEInt ( header , _NUM , SHAPE_FILE_VERSION ) ; writeLEInt ( header , _NUM , SHAPE_TYPE_NULL ) ; writeLEDouble ( header , _NUM , _NUM ) ; writeLEDouble ( header , _NUM , _NUM ) ; writeLEDouble ( header , _NUM , _NUM ) ; writeLEDouble ( header , _NUM , _NUM ) ; raf . seek ( _NUM ) ; raf . write ( header , _NUM , SHAPE_FILE_HEADER_LENGTH ) ; }
@ Override public boolean equals ( Object other ) { return this == other || ( other instanceof User && hashCode ( ) == other . hashCode ( ) ) ; }
private void createDistributedSubRegion ( List vmList , boolean firstCreationFlag ) { Iterator nodeIterator = vmList . iterator ( ) ; while ( nodeIterator . hasNext ( ) ) { VM vm = ( VM ) nodeIterator . next ( ) ; vm . invoke ( createSubRegion ( firstCreationFlag , DISTRIBUTED_REGION ) ) ; } }
public static boolean isSQL99NonReservedKeyword ( String identifier ) { if ( identifier == null ) { throw new NullPointerException ( STRING ) ; } return Arrays . binarySearch ( SQL99_NON_RESERVED , identifier . toUpperCase ( ) ) >= _NUM ; }
public int addItemToEnd ( ShoppingCartItem item ) throws CartItemModifyException { return addItem ( cartLines . size ( ) , item ) ; }
private boolean processNotification ( Notification notification , BigInteger historyId , Metric metric , Alert alert , EntityManager em ) { if ( ! shouldEvaluateNotification ( notification , historyId ) ) { return _BOOL ; } String logMessage = null ; if ( notification . isActive ( ) && notification . getFiredTrigger ( ) != null ) { Long triggerFiredTime = getTriggerFiredDatapointTime ( notification . getFiredTrigger ( ) , metric ) ; if ( triggerFiredTime == null ) { clearNotification ( notification . getFiredTrigger ( ) , metric , historyId , notification , em , alert ) ; } } try { if ( ! notification . onCooldown ( ) ) { for ( Trigger trigger : notification . getTriggers ( ) ) { boolean triggerFired = evaluateTrigger ( trigger , metric , historyId , notification , em , alert ) ; if ( triggerFired ) { break ; } } } else { logMessage = MessageFormat . format ( STRING , notification . getName ( ) , getDateMMDDYYYY ( notification . getCooldownExpiration ( ) ) ) ; _logger . info ( logMessage ) ; appendMessageNUpdateHistory ( historyId , logMessage , null , _NUM , _NUM ) ; } } catch ( Exception ex ) { logMessage = MessageFormat . format ( STRING , notification . getName ( ) , ex . toString ( ) ) ; _logger . warn ( STRING , notification , ex . toString ( ) ) ; appendMessageNUpdateHistory ( historyId , logMessage , null , _NUM , _NUM ) ; return _BOOL ; } return _BOOL ; }
private boolean processNotification ( Notification notification , BigInteger historyId , Metric metric , Alert alert , EntityManager em ) { if ( ! shouldEvaluateNotification ( notification , historyId ) ) { return _BOOL ; } String logMessage = null ; if ( notification . isActive ( ) && notification . getFiredTrigger ( ) != null ) { Long triggerFiredTime = getTriggerFiredDatapointTime ( notification . getFiredTrigger ( ) , metric ) ; if ( triggerFiredTime == null ) { clearNotification ( notification . getFiredTrigger ( ) , metric , historyId , notification , em , alert ) ; } } try { if ( ! notification . onCooldown ( ) ) { for ( Trigger trigger : notification . getTriggers ( ) ) { boolean triggerFired = evaluateTrigger ( trigger , metric , historyId , notification , em , alert ) ; if ( triggerFired ) { break ; } } } else { logMessage = MessageFormat . format ( STRING , notification . getName ( ) , getDateMMDDYYYY ( notification . getCooldownExpiration ( ) ) ) ; _logger . info ( logMessage ) ; appendMessageNUpdateHistory ( historyId , logMessage , null , _NUM , _NUM ) ; } } catch ( Exception ex ) { logMessage = MessageFormat . format ( STRING , notification . getName ( ) , ex . toString ( ) ) ; _logger . warn ( STRING , notification , ex . toString ( ) ) ; appendMessageNUpdateHistory ( historyId , logMessage , null , _NUM , _NUM ) ; return _BOOL ; } return _BOOL ; }
public EngineOutput ( List < String > oStd , List < String > oErr ) { std = Collections . unmodifiableList ( oStd ) ; err = Collections . unmodifiableList ( oErr ) ; }
public void validateSubPartitionValues ( List < String > subPartitionValues ) throws IllegalArgumentException { int subPartitionValuesCount = CollectionUtils . size ( subPartitionValues ) ; Assert . isTrue ( subPartitionValuesCount <= BusinessObjectDataEntity . MAX_SUBPARTITIONS , String . format ( STRING , BusinessObjectDataEntity . MAX_SUBPARTITIONS ) ) ; for ( int i = _NUM ; i < subPartitionValuesCount ; i ++ ) { subPartitionValues . set ( i , alternateKeyHelper . validateStringParameter ( STRING , subPartitionValues . get ( i ) ) ) ; } }
protected void drawCenterText ( Canvas c ) { String centerText = mChart . getCenterText ( ) ; if ( mChart . isDrawCenterTextEnabled ( ) && centerText != null ) { PointF center = mChart . getCenterCircleBox ( ) ; String [ ] lines = centerText . split ( STRING ) ; float maxlineheight = _NUM ; for ( String line : lines ) { float curHeight = Utils . calcTextHeight ( mCenterTextPaint , line ) ; if ( curHeight > maxlineheight ) maxlineheight = curHeight ; } float linespacing = maxlineheight * _NUM ; float totalheight = maxlineheight * lines . length - linespacing * ( lines . length - _NUM ) ; int cnt = lines . length ; float y = center . y ; for ( int i = _NUM ; i < lines . length ; i ++ ) { String line = lines [ lines . length - i - _NUM ] ; c . drawText ( line , center . x , y + maxlineheight * cnt - totalheight / _NUM , mCenterTextPaint ) ; cnt -- ; y -= linespacing ; } } }
protected void drawCenterText ( Canvas c ) { String centerText = mChart . getCenterText ( ) ; if ( mChart . isDrawCenterTextEnabled ( ) && centerText != null ) { PointF center = mChart . getCenterCircleBox ( ) ; String [ ] lines = centerText . split ( STRING ) ; float maxlineheight = _NUM ; for ( String line : lines ) { float curHeight = Utils . calcTextHeight ( mCenterTextPaint , line ) ; if ( curHeight > maxlineheight ) maxlineheight = curHeight ; } float linespacing = maxlineheight * _NUM ; float totalheight = maxlineheight * lines . length - linespacing * ( lines . length - _NUM ) ; int cnt = lines . length ; float y = center . y ; for ( int i = _NUM ; i < lines . length ; i ++ ) { String line = lines [ lines . length - i - _NUM ] ; c . drawText ( line , center . x , y + maxlineheight * cnt - totalheight / _NUM , mCenterTextPaint ) ; cnt -- ; y -= linespacing ; } } }
public Polyline ( PlaPointInt p_from_corner , PlaPointInt p_to_corner ) { if ( p_from_corner . equals ( p_to_corner ) ) throw new IllegalArgumentException ( classname + STRING ) ; lines_list = new ArrayList < PlaLineInt > ( _NUM ) ; PlaDirection dir = new PlaDirection ( p_from_corner , p_to_corner ) ; lines_list . add ( new PlaLineInt ( p_from_corner , dir . rotate_45_deg ( _NUM ) ) ) ; lines_list . add ( new PlaLineInt ( p_from_corner , p_to_corner ) ) ; lines_list . add ( new PlaLineInt ( p_to_corner , dir . rotate_45_deg ( _NUM ) ) ) ; corners_allocate ( corner_count ( ) ) ; precalculated_corners [ _NUM ] = p_from_corner ; precalculated_corners [ _NUM ] = p_to_corner ; }
public List < DiffRow > generateDiffRows ( List < String > original , List < String > revised ) { return generateDiffRows ( original , revised , DiffUtils . diff ( original , revised , equalizer ) ) ; }
public List < DiffRow > generateDiffRows ( List < String > original , List < String > revised ) { return generateDiffRows ( original , revised , DiffUtils . diff ( original , revised , equalizer ) ) ; }
public List < DiffRow > generateDiffRows ( List < String > original , List < String > revised ) { return generateDiffRows ( original , revised , DiffUtils . diff ( original , revised , equalizer ) ) ; }
public List < DiffRow > generateDiffRows ( List < String > original , List < String > revised ) { return generateDiffRows ( original , revised , DiffUtils . diff ( original , revised , equalizer ) ) ; }
private T [ ] ensureCapacity ( int minCapacity ) { if ( tmp . length < minCapacity ) { int newSize = minCapacity ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize ++ ; if ( newSize < _NUM ) newSize = minCapacity ; else newSize = Math . min ( newSize , a . length > > > _NUM ) ; T [ ] newArray = ( T [ ] ) new Object [ newSize ] ; tmp = newArray ; } return tmp ; }
private T [ ] ensureCapacity ( int minCapacity ) { if ( tmp . length < minCapacity ) { int newSize = minCapacity ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize ++ ; if ( newSize < _NUM ) newSize = minCapacity ; else newSize = Math . min ( newSize , a . length > > > _NUM ) ; T [ ] newArray = ( T [ ] ) new Object [ newSize ] ; tmp = newArray ; } return tmp ; }
private T [ ] ensureCapacity ( int minCapacity ) { if ( tmp . length < minCapacity ) { int newSize = minCapacity ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize ++ ; if ( newSize < _NUM ) newSize = minCapacity ; else newSize = Math . min ( newSize , a . length > > > _NUM ) ; T [ ] newArray = ( T [ ] ) new Object [ newSize ] ; tmp = newArray ; } return tmp ; }
private T [ ] ensureCapacity ( int minCapacity ) { if ( tmp . length < minCapacity ) { int newSize = minCapacity ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize ++ ; if ( newSize < _NUM ) newSize = minCapacity ; else newSize = Math . min ( newSize , a . length > > > _NUM ) ; T [ ] newArray = ( T [ ] ) new Object [ newSize ] ; tmp = newArray ; } return tmp ; }
public void sortFromTo ( int from , int to ) { final int widthThreshold = _NUM ; if ( size == _NUM ) return ; checkRangeFromTo ( from , to , size ) ; long min = elements [ from ] ; long max = elements [ from ] ; long [ ] theElements = elements ; for ( int i = from + _NUM ; i <= to ; ) { long elem = theElements [ i ++ ] ; if ( elem > max ) max = elem ; else if ( elem < min ) min = elem ; } double N = ( double ) to - ( double ) from + _NUM ; double quickSortEstimate = N * Math . log ( N ) / _NUM ; double width = ( double ) max - ( double ) min + _NUM ; double countSortEstimate = Math . max ( width , N ) ; if ( width < widthThreshold && countSortEstimate < quickSortEstimate ) { countSortFromTo ( from , to , min , max ) ; } else { quickSortFromTo ( from , to ) ; } }
public void sortFromTo ( int from , int to ) { final int widthThreshold = _NUM ; if ( size == _NUM ) return ; checkRangeFromTo ( from , to , size ) ; long min = elements [ from ] ; long max = elements [ from ] ; long [ ] theElements = elements ; for ( int i = from + _NUM ; i <= to ; ) { long elem = theElements [ i ++ ] ; if ( elem > max ) max = elem ; else if ( elem < min ) min = elem ; } double N = ( double ) to - ( double ) from + _NUM ; double quickSortEstimate = N * Math . log ( N ) / _NUM ; double width = ( double ) max - ( double ) min + _NUM ; double countSortEstimate = Math . max ( width , N ) ; if ( width < widthThreshold && countSortEstimate < quickSortEstimate ) { countSortFromTo ( from , to , min , max ) ; } else { quickSortFromTo ( from , to ) ; } }
public void sortFromTo ( int from , int to ) { final int widthThreshold = _NUM ; if ( size == _NUM ) return ; checkRangeFromTo ( from , to , size ) ; long min = elements [ from ] ; long max = elements [ from ] ; long [ ] theElements = elements ; for ( int i = from + _NUM ; i <= to ; ) { long elem = theElements [ i ++ ] ; if ( elem > max ) max = elem ; else if ( elem < min ) min = elem ; } double N = ( double ) to - ( double ) from + _NUM ; double quickSortEstimate = N * Math . log ( N ) / _NUM ; double width = ( double ) max - ( double ) min + _NUM ; double countSortEstimate = Math . max ( width , N ) ; if ( width < widthThreshold && countSortEstimate < quickSortEstimate ) { countSortFromTo ( from , to , min , max ) ; } else { quickSortFromTo ( from , to ) ; } }
public void sortFromTo ( int from , int to ) { final int widthThreshold = _NUM ; if ( size == _NUM ) return ; checkRangeFromTo ( from , to , size ) ; long min = elements [ from ] ; long max = elements [ from ] ; long [ ] theElements = elements ; for ( int i = from + _NUM ; i <= to ; ) { long elem = theElements [ i ++ ] ; if ( elem > max ) max = elem ; else if ( elem < min ) min = elem ; } double N = ( double ) to - ( double ) from + _NUM ; double quickSortEstimate = N * Math . log ( N ) / _NUM ; double width = ( double ) max - ( double ) min + _NUM ; double countSortEstimate = Math . max ( width , N ) ; if ( width < widthThreshold && countSortEstimate < quickSortEstimate ) { countSortFromTo ( from , to , min , max ) ; } else { quickSortFromTo ( from , to ) ; } }
public void sortFromTo ( int from , int to ) { final int widthThreshold = _NUM ; if ( size == _NUM ) return ; checkRangeFromTo ( from , to , size ) ; long min = elements [ from ] ; long max = elements [ from ] ; long [ ] theElements = elements ; for ( int i = from + _NUM ; i <= to ; ) { long elem = theElements [ i ++ ] ; if ( elem > max ) max = elem ; else if ( elem < min ) min = elem ; } double N = ( double ) to - ( double ) from + _NUM ; double quickSortEstimate = N * Math . log ( N ) / _NUM ; double width = ( double ) max - ( double ) min + _NUM ; double countSortEstimate = Math . max ( width , N ) ; if ( width < widthThreshold && countSortEstimate < quickSortEstimate ) { countSortFromTo ( from , to , min , max ) ; } else { quickSortFromTo ( from , to ) ; } }
public static String parseDiskString ( String input ) { String delims = STRING ; String [ ] tokens = input . split ( delims ) ; return tokens [ _NUM ] ; }
public boolean addUser ( @ NotNull User user ) { int updatedRows = _NUM ; try { final PreparedStatement preparedStatement = connetion . getPreparedStatement ( STRING + STRING ) ; preparedStatement . setInt ( _NUM , user . getUserId ( ) ) ; if ( ( user . getUserHash ( ) == null ) || ( user . getUserHash ( ) == _NUM ) ) { preparedStatement . setNull ( _NUM , Types . NUMERIC ) ; } else { preparedStatement . setLong ( _NUM , user . getUserHash ( ) ) ; } updatedRows = preparedStatement . executeUpdate ( ) ; } catch ( SQLException e ) { BotLogger . error ( LOGTAG , e ) ; } return updatedRows > _NUM ; }
public void offset ( float dx , float dy , Path_Delegate dst ) { GeneralPath newPath = new GeneralPath ( ) ; PathIterator iterator = mPath . getPathIterator ( new AffineTransform ( _NUM , _NUM , dx , _NUM , _NUM , dy ) ) ; newPath . append ( iterator , _BOOL ) ; if ( dst != null ) { dst . mPath = newPath ; } else { mPath = newPath ; } }
public static JsDate toJs ( Date java ) { return java == null ? null : create ( java . getTime ( ) ) ; }
public static JsDate toJs ( Date java ) { return java == null ? null : create ( java . getTime ( ) ) ; }
private static String attributeValuesString ( Instance instance , Range attRange ) { StringBuffer text = new StringBuffer ( ) ; if ( attRange != null ) { boolean firstOutput = _BOOL ; attRange . setUpper ( instance . numAttributes ( ) - _NUM ) ; for ( int i = _NUM ; i < instance . numAttributes ( ) ; i ++ ) { if ( attRange . isInRange ( i ) ) { if ( firstOutput ) { text . append ( STRING ) ; } else { text . append ( STRING ) ; } text . append ( instance . toString ( i ) ) ; firstOutput = _BOOL ; } } if ( ! firstOutput ) { text . append ( STRING ) ; } } return text . toString ( ) ; }
private static String attributeValuesString ( Instance instance , Range attRange ) { StringBuffer text = new StringBuffer ( ) ; if ( attRange != null ) { boolean firstOutput = _BOOL ; attRange . setUpper ( instance . numAttributes ( ) - _NUM ) ; for ( int i = _NUM ; i < instance . numAttributes ( ) ; i ++ ) { if ( attRange . isInRange ( i ) ) { if ( firstOutput ) { text . append ( STRING ) ; } else { text . append ( STRING ) ; } text . append ( instance . toString ( i ) ) ; firstOutput = _BOOL ; } } if ( ! firstOutput ) { text . append ( STRING ) ; } } return text . toString ( ) ; }
protected abstract boolean isEndOfChunk ( char currPrefix , String currLabel , char nextPrefix , String nextLabel ) ;
protected abstract boolean isEndOfChunk ( char currPrefix , String currLabel , char nextPrefix , String nextLabel ) ;
public < T > List < T > testTwoThreadsOneItem ( T a , T b ) { Trace . trace ( Item . SCHEDULER , STRING ) ; List < T > results = Collections . synchronizedList ( new ArrayList < T > ( _NUM ) ) ; Scheduler . scheduleMutator ( new TestMutator < T > ( results , a ) ) ; Scheduler . scheduleMutator ( new TestMutator < T > ( results , b ) ) ; Scheduler . schedule ( ) ; Trace . trace ( Item . SCHEDULER , STRING ) ; return results ; }
public < T > List < T > testTwoThreadsOneItem ( T a , T b ) { Trace . trace ( Item . SCHEDULER , STRING ) ; List < T > results = Collections . synchronizedList ( new ArrayList < T > ( _NUM ) ) ; Scheduler . scheduleMutator ( new TestMutator < T > ( results , a ) ) ; Scheduler . scheduleMutator ( new TestMutator < T > ( results , b ) ) ; Scheduler . schedule ( ) ; Trace . trace ( Item . SCHEDULER , STRING ) ; return results ; }
public < T > List < T > testTwoThreadsOneItem ( T a , T b ) { Trace . trace ( Item . SCHEDULER , STRING ) ; List < T > results = Collections . synchronizedList ( new ArrayList < T > ( _NUM ) ) ; Scheduler . scheduleMutator ( new TestMutator < T > ( results , a ) ) ; Scheduler . scheduleMutator ( new TestMutator < T > ( results , b ) ) ; Scheduler . schedule ( ) ; Trace . trace ( Item . SCHEDULER , STRING ) ; return results ; }
public < T > List < T > testTwoThreadsOneItem ( T a , T b ) { Trace . trace ( Item . SCHEDULER , STRING ) ; List < T > results = Collections . synchronizedList ( new ArrayList < T > ( _NUM ) ) ; Scheduler . scheduleMutator ( new TestMutator < T > ( results , a ) ) ; Scheduler . scheduleMutator ( new TestMutator < T > ( results , b ) ) ; Scheduler . schedule ( ) ; Trace . trace ( Item . SCHEDULER , STRING ) ; return results ; }
public static Graph < String , Number > createDirectedAcyclicGraph ( int layers , int maxNodesPerLayer , double linkprob ) { DirectedGraph < String , Number > dag = new DirectedSparseMultigraph < String , Number > ( ) ; Set < String > previousLayers = new HashSet < String > ( ) ; Set < String > inThisLayer = new HashSet < String > ( ) ; for ( int i = _NUM ; i < layers ; i ++ ) { int nodesThisLayer = ( int ) ( Math . random ( ) * maxNodesPerLayer ) + _NUM ; for ( int j = _NUM ; j < nodesThisLayer ; j ++ ) { String v = i + STRING + j ; dag . addVertex ( v ) ; inThisLayer . add ( v ) ; for ( String v2 : previousLayers ) { if ( Math . random ( ) < linkprob ) { Double de = new Double ( Math . random ( ) ) ; dag . addEdge ( de , v , v2 ) ; } } } previousLayers . addAll ( inThisLayer ) ; inThisLayer . clear ( ) ; } return dag ; }
public static Graph < String , Number > createDirectedAcyclicGraph ( int layers , int maxNodesPerLayer , double linkprob ) { DirectedGraph < String , Number > dag = new DirectedSparseMultigraph < String , Number > ( ) ; Set < String > previousLayers = new HashSet < String > ( ) ; Set < String > inThisLayer = new HashSet < String > ( ) ; for ( int i = _NUM ; i < layers ; i ++ ) { int nodesThisLayer = ( int ) ( Math . random ( ) * maxNodesPerLayer ) + _NUM ; for ( int j = _NUM ; j < nodesThisLayer ; j ++ ) { String v = i + STRING + j ; dag . addVertex ( v ) ; inThisLayer . add ( v ) ; for ( String v2 : previousLayers ) { if ( Math . random ( ) < linkprob ) { Double de = new Double ( Math . random ( ) ) ; dag . addEdge ( de , v , v2 ) ; } } } previousLayers . addAll ( inThisLayer ) ; inThisLayer . clear ( ) ; } return dag ; }
public static Graph < String , Number > createDirectedAcyclicGraph ( int layers , int maxNodesPerLayer , double linkprob ) { DirectedGraph < String , Number > dag = new DirectedSparseMultigraph < String , Number > ( ) ; Set < String > previousLayers = new HashSet < String > ( ) ; Set < String > inThisLayer = new HashSet < String > ( ) ; for ( int i = _NUM ; i < layers ; i ++ ) { int nodesThisLayer = ( int ) ( Math . random ( ) * maxNodesPerLayer ) + _NUM ; for ( int j = _NUM ; j < nodesThisLayer ; j ++ ) { String v = i + STRING + j ; dag . addVertex ( v ) ; inThisLayer . add ( v ) ; for ( String v2 : previousLayers ) { if ( Math . random ( ) < linkprob ) { Double de = new Double ( Math . random ( ) ) ; dag . addEdge ( de , v , v2 ) ; } } } previousLayers . addAll ( inThisLayer ) ; inThisLayer . clear ( ) ; } return dag ; }
public static Graph < String , Number > createDirectedAcyclicGraph ( int layers , int maxNodesPerLayer , double linkprob ) { DirectedGraph < String , Number > dag = new DirectedSparseMultigraph < String , Number > ( ) ; Set < String > previousLayers = new HashSet < String > ( ) ; Set < String > inThisLayer = new HashSet < String > ( ) ; for ( int i = _NUM ; i < layers ; i ++ ) { int nodesThisLayer = ( int ) ( Math . random ( ) * maxNodesPerLayer ) + _NUM ; for ( int j = _NUM ; j < nodesThisLayer ; j ++ ) { String v = i + STRING + j ; dag . addVertex ( v ) ; inThisLayer . add ( v ) ; for ( String v2 : previousLayers ) { if ( Math . random ( ) < linkprob ) { Double de = new Double ( Math . random ( ) ) ; dag . addEdge ( de , v , v2 ) ; } } } previousLayers . addAll ( inThisLayer ) ; inThisLayer . clear ( ) ; } return dag ; }
public static Graph < String , Number > createDirectedAcyclicGraph ( int layers , int maxNodesPerLayer , double linkprob ) { DirectedGraph < String , Number > dag = new DirectedSparseMultigraph < String , Number > ( ) ; Set < String > previousLayers = new HashSet < String > ( ) ; Set < String > inThisLayer = new HashSet < String > ( ) ; for ( int i = _NUM ; i < layers ; i ++ ) { int nodesThisLayer = ( int ) ( Math . random ( ) * maxNodesPerLayer ) + _NUM ; for ( int j = _NUM ; j < nodesThisLayer ; j ++ ) { String v = i + STRING + j ; dag . addVertex ( v ) ; inThisLayer . add ( v ) ; for ( String v2 : previousLayers ) { if ( Math . random ( ) < linkprob ) { Double de = new Double ( Math . random ( ) ) ; dag . addEdge ( de , v , v2 ) ; } } } previousLayers . addAll ( inThisLayer ) ; inThisLayer . clear ( ) ; } return dag ; }
public Map < String , String > parse ( final String str , char [ ] separators ) { if ( separators == null || separators . length == _NUM ) { return new HashMap < String , String > ( ) ; } char separator = separators [ _NUM ] ; if ( str != null ) { int idx = str . length ( ) ; for ( int i = _NUM ; i < separators . length ; i ++ ) { int tmp = str . indexOf ( separators [ i ] ) ; if ( tmp != - _NUM ) { if ( tmp < idx ) { idx = tmp ; separator = separators [ i ] ; } } } } return parse ( str , separator ) ; }
public Map < String , String > parse ( final String str , char [ ] separators ) { if ( separators == null || separators . length == _NUM ) { return new HashMap < String , String > ( ) ; } char separator = separators [ _NUM ] ; if ( str != null ) { int idx = str . length ( ) ; for ( int i = _NUM ; i < separators . length ; i ++ ) { int tmp = str . indexOf ( separators [ i ] ) ; if ( tmp != - _NUM ) { if ( tmp < idx ) { idx = tmp ; separator = separators [ i ] ; } } } } return parse ( str , separator ) ; }
public Map < String , String > parse ( final String str , char [ ] separators ) { if ( separators == null || separators . length == _NUM ) { return new HashMap < String , String > ( ) ; } char separator = separators [ _NUM ] ; if ( str != null ) { int idx = str . length ( ) ; for ( int i = _NUM ; i < separators . length ; i ++ ) { int tmp = str . indexOf ( separators [ i ] ) ; if ( tmp != - _NUM ) { if ( tmp < idx ) { idx = tmp ; separator = separators [ i ] ; } } } } return parse ( str , separator ) ; }
private void drawFill ( Graphics g , int x , int y , int w , int h ) { g . setColor ( Color . BLACK ) ; g . drawRect ( x , y , w , h ) ; g . setColor ( Color . LIGHT_GRAY ) ; g . fillRect ( x , y , w , h ) ; }
@ Override public void writeStartDocument ( String encoding , String version ) throws XMLStreamException { log . log ( Level . FINE , STRING , new Object [ ] { encoding , version } ) ; if ( encoding == null ) { encoding = this . encoding ; } doc = new WbXmlDocument ( WbXmlVersion . VERSION_1_3 , IanaCharset . getIanaCharset ( encoding ) ) ; if ( def != null ) { log . log ( Level . FINE , STRING , def . getName ( ) ) ; doc . setDefinition ( def ) ; } }
@ Override public void writeStartDocument ( String encoding , String version ) throws XMLStreamException { log . log ( Level . FINE , STRING , new Object [ ] { encoding , version } ) ; if ( encoding == null ) { encoding = this . encoding ; } doc = new WbXmlDocument ( WbXmlVersion . VERSION_1_3 , IanaCharset . getIanaCharset ( encoding ) ) ; if ( def != null ) { log . log ( Level . FINE , STRING , def . getName ( ) ) ; doc . setDefinition ( def ) ; } }
@ Override public void writeStartDocument ( String encoding , String version ) throws XMLStreamException { log . log ( Level . FINE , STRING , new Object [ ] { encoding , version } ) ; if ( encoding == null ) { encoding = this . encoding ; } doc = new WbXmlDocument ( WbXmlVersion . VERSION_1_3 , IanaCharset . getIanaCharset ( encoding ) ) ; if ( def != null ) { log . log ( Level . FINE , STRING , def . getName ( ) ) ; doc . setDefinition ( def ) ; } }
@ Override public void writeStartDocument ( String encoding , String version ) throws XMLStreamException { log . log ( Level . FINE , STRING , new Object [ ] { encoding , version } ) ; if ( encoding == null ) { encoding = this . encoding ; } doc = new WbXmlDocument ( WbXmlVersion . VERSION_1_3 , IanaCharset . getIanaCharset ( encoding ) ) ; if ( def != null ) { log . log ( Level . FINE , STRING , def . getName ( ) ) ; doc . setDefinition ( def ) ; } }
private void updatePolyLine ( LatLng latLng ) { List < LatLng > points = polyLine . getPoints ( ) ; points . add ( latLng ) ; polyLine . setPoints ( points ) ; }
@ RequestMapping ( value = { STRING , STRING } , method = RequestMethod . PUT ) @ ResponseBody public RestWrapper insert ( @ ModelAttribute ( STRING ) @ Valid WorkflowType workflowType , BindingResult bindingResult , Principal principal ) { RestWrapper restWrapper = null ; if ( bindingResult . hasErrors ( ) ) { BindingResultError bindingResultError = new BindingResultError ( ) ; return bindingResultError . errorMessage ( bindingResult ) ; } try { com . wipro . ats . bdre . md . dao . jpa . WorkflowType jpaWorkflowType = new com . wipro . ats . bdre . md . dao . jpa . WorkflowType ( ) ; jpaWorkflowType . setWorkflowId ( workflowType . getWorkflowId ( ) ) ; jpaWorkflowType . setWorkflowTypeName ( workflowType . getWorkflowTypeName ( ) ) ; workflowTypeDAO . insert ( jpaWorkflowType ) ; restWrapper = new RestWrapper ( workflowType , RestWrapper . OK ) ; LOGGER . info ( STRING + workflowType . getWorkflowId ( ) + STRING + principal . getName ( ) + workflowType ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
@ RequestMapping ( value = { STRING , STRING } , method = RequestMethod . PUT ) @ ResponseBody public RestWrapper insert ( @ ModelAttribute ( STRING ) @ Valid WorkflowType workflowType , BindingResult bindingResult , Principal principal ) { RestWrapper restWrapper = null ; if ( bindingResult . hasErrors ( ) ) { BindingResultError bindingResultError = new BindingResultError ( ) ; return bindingResultError . errorMessage ( bindingResult ) ; } try { com . wipro . ats . bdre . md . dao . jpa . WorkflowType jpaWorkflowType = new com . wipro . ats . bdre . md . dao . jpa . WorkflowType ( ) ; jpaWorkflowType . setWorkflowId ( workflowType . getWorkflowId ( ) ) ; jpaWorkflowType . setWorkflowTypeName ( workflowType . getWorkflowTypeName ( ) ) ; workflowTypeDAO . insert ( jpaWorkflowType ) ; restWrapper = new RestWrapper ( workflowType , RestWrapper . OK ) ; LOGGER . info ( STRING + workflowType . getWorkflowId ( ) + STRING + principal . getName ( ) + workflowType ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
public RelNode convertSelect ( SqlSelect select , boolean top ) { final SqlValidatorScope selectScope = validator . getWhereScope ( select ) ; final Blackboard bb = createBlackboard ( selectScope , null , top ) ; convertSelectImpl ( bb , select ) ; return bb . root ; }
public static String [ ] splitWithoutEscaped ( String str , char separatorChar , boolean retainEmpty ) { int len = str . length ( ) ; if ( len == _NUM ) { return new String [ _NUM ] ; } List < String > list = new ArrayList < String > ( ) ; int i = _NUM ; int start = _NUM ; boolean match = _BOOL ; while ( i < len ) { if ( str . charAt ( i ) == STRING ) { match = _BOOL ; i += _NUM ; } else if ( str . charAt ( i ) == separatorChar ) { if ( retainEmpty || match ) { list . add ( str . substring ( start , i ) ) ; match = _BOOL ; } start = ++ i ; } else { match = _BOOL ; i ++ ; } } if ( retainEmpty || match ) { list . add ( str . substring ( start , i ) ) ; } return list . toArray ( new String [ list . size ( ) ] ) ; }
public static String [ ] splitWithoutEscaped ( String str , char separatorChar , boolean retainEmpty ) { int len = str . length ( ) ; if ( len == _NUM ) { return new String [ _NUM ] ; } List < String > list = new ArrayList < String > ( ) ; int i = _NUM ; int start = _NUM ; boolean match = _BOOL ; while ( i < len ) { if ( str . charAt ( i ) == STRING ) { match = _BOOL ; i += _NUM ; } else if ( str . charAt ( i ) == separatorChar ) { if ( retainEmpty || match ) { list . add ( str . substring ( start , i ) ) ; match = _BOOL ; } start = ++ i ; } else { match = _BOOL ; i ++ ; } } if ( retainEmpty || match ) { list . add ( str . substring ( start , i ) ) ; } return list . toArray ( new String [ list . size ( ) ] ) ; }
public void resetNetworkState ( ) { mStateDepository . clear ( ) ; mTransitionDirection = StateTransitionDirection . DO_NOTHING ; mTransitionTarget = State . UNKNOWN ; }
public String toHexString ( final int start , final int length ) { final int roundedStart = ( start / LOG_BYTES_PER_ROW ) * LOG_BYTES_PER_ROW ; final StringBuilder sb = new StringBuilder ( STRING ) ; int index = roundedStart ; for ( int nLogged = _NUM ; nLogged < length ; nLogged += LOG_BYTES_PER_ROW ) { sb . append ( String . format ( STRING , index , index + LOG_BYTES_PER_ROW - _NUM ) ) ; for ( int i = _NUM ; i < LOG_BYTES_PER_ROW ; ++ i ) { try { final byte b = getByte ( index ++ ) ; sb . append ( String . format ( STRING , b ) ) ; } catch ( IndexOutOfBoundsException ioob ) { sb . append ( STRING ) ; } } sb . append ( STRING ) ; } return sb . toString ( ) ; }
private void reverseChildren ( ) { List < View > children = new ArrayList < View > ( ) ; for ( int i = getChildCount ( ) - _NUM ; i >= _NUM ; i -- ) { children . add ( getChildAt ( i ) ) ; } for ( View v : children ) { bringChildToFront ( v ) ; } }
private void reverseChildren ( ) { List < View > children = new ArrayList < View > ( ) ; for ( int i = getChildCount ( ) - _NUM ; i >= _NUM ; i -- ) { children . add ( getChildAt ( i ) ) ; } for ( View v : children ) { bringChildToFront ( v ) ; } }
private void reverseChildren ( ) { List < View > children = new ArrayList < View > ( ) ; for ( int i = getChildCount ( ) - _NUM ; i >= _NUM ; i -- ) { children . add ( getChildAt ( i ) ) ; } for ( View v : children ) { bringChildToFront ( v ) ; } }
public String treeToFilePositionString ( Tree tree , CompilationUnitTree currentRoot , ProcessingEnvironment processingEnv ) { if ( tree == null ) { return null ; } SourcePositions sourcePositions = trees . getSourcePositions ( ) ; long start = sourcePositions . getStartPosition ( currentRoot , tree ) ; long end = sourcePositions . getEndPosition ( currentRoot , tree ) ; return STRING + start + STRING + end + STRING ; }
public String treeToFilePositionString ( Tree tree , CompilationUnitTree currentRoot , ProcessingEnvironment processingEnv ) { if ( tree == null ) { return null ; } SourcePositions sourcePositions = trees . getSourcePositions ( ) ; long start = sourcePositions . getStartPosition ( currentRoot , tree ) ; long end = sourcePositions . getEndPosition ( currentRoot , tree ) ; return STRING + start + STRING + end + STRING ; }
public String treeToFilePositionString ( Tree tree , CompilationUnitTree currentRoot , ProcessingEnvironment processingEnv ) { if ( tree == null ) { return null ; } SourcePositions sourcePositions = trees . getSourcePositions ( ) ; long start = sourcePositions . getStartPosition ( currentRoot , tree ) ; long end = sourcePositions . getEndPosition ( currentRoot , tree ) ; return STRING + start + STRING + end + STRING ; }
public static String rightPad ( String original , int length , char padChar ) { if ( original . length ( ) >= length ) { return original ; } return original + stringOfChar ( padChar , length - original . length ( ) ) ; }
public static String rightPad ( String original , int length , char padChar ) { if ( original . length ( ) >= length ) { return original ; } return original + stringOfChar ( padChar , length - original . length ( ) ) ; }
public void add ( LeafAtom atom ) { leafChildren . add ( atom ) ; }
public String toString ( ) { return Byte . toString ( getValue ( ) ) ; }
public static String formatMillisToGMT ( long milliseconds ) { Date date = new Date ( milliseconds ) ; SimpleDateFormat simpleDateFormat = new SimpleDateFormat ( FORMAT_HTTP_DATA , Locale . US ) ; simpleDateFormat . setTimeZone ( GMT_TIME_ZONE ) ; return simpleDateFormat . format ( date ) ; }
public static String formatMillisToGMT ( long milliseconds ) { Date date = new Date ( milliseconds ) ; SimpleDateFormat simpleDateFormat = new SimpleDateFormat ( FORMAT_HTTP_DATA , Locale . US ) ; simpleDateFormat . setTimeZone ( GMT_TIME_ZONE ) ; return simpleDateFormat . format ( date ) ; }
public Map < String , String > environment ( ) { String base64 = toStringBase64 ( ) ; if ( base64 == null || base64 . length ( ) == _NUM ) { return Collections . emptyMap ( ) ; } Map < String , String > environment = Maps . newHashMap ( ) ; environment . put ( BaggageUtils . BAGGAGE_ENVIRONMENT_VARIABLE , base64 ) ; return environment ; }
private Rectangle2D viewToFrame ( Rectangle2D view ) { double width = view . getWidth ( ) / this . viewW ; double height = view . getHeight ( ) / this . viewH ; double x = view . getX ( ) - ( width * this . viewX ) ; double y = view . getY ( ) - ( height * this . viewY ) ; return new Rectangle2D . Double ( x , y , width , height ) ; }
private Rectangle2D viewToFrame ( Rectangle2D view ) { double width = view . getWidth ( ) / this . viewW ; double height = view . getHeight ( ) / this . viewH ; double x = view . getX ( ) - ( width * this . viewX ) ; double y = view . getY ( ) - ( height * this . viewY ) ; return new Rectangle2D . Double ( x , y , width , height ) ; }
public void addListener ( U type , T listener ) { List < T > newlisteners = new ArrayList < T > ( ) ; if ( listeners != null ) newlisteners . addAll ( listeners ) ; newlisteners . add ( listener ) ; List < T > terminals = new ArrayList < T > ( ) ; for ( T i : newlisteners ) { boolean isterm = _BOOL ; for ( T j : newlisteners ) { if ( ispre ( type , i , j ) ) { isterm = _BOOL ; break ; } } if ( isterm ) { terminals . add ( i ) ; } } if ( terminals . size ( ) == _NUM ) { logger . error ( STRING + STRING ) ; listeners = newlisteners ; return ; } HashSet < T > visited = new HashSet < T > ( ) ; List < T > ordering = new ArrayList < T > ( ) ; for ( T term : terminals ) { visit ( newlisteners , type , visited , ordering , term ) ; } listeners = ordering ; }
public void truncate ( final long size ) throws FileNotFoundException , IOException { fileChannel . truncate ( Math . max ( size , writePosition ) ) ; }
static Set < String > parsePathParameters ( String path ) { Matcher m = PARAM_URL_REGEX . matcher ( path ) ; Set < String > patterns = new LinkedHashSet < String > ( ) ; while ( m . find ( ) ) { patterns . add ( m . group ( _NUM ) ) ; } return patterns ; }
static Set < String > parsePathParameters ( String path ) { Matcher m = PARAM_URL_REGEX . matcher ( path ) ; Set < String > patterns = new LinkedHashSet < String > ( ) ; while ( m . find ( ) ) { patterns . add ( m . group ( _NUM ) ) ; } return patterns ; }
static Set < String > parsePathParameters ( String path ) { Matcher m = PARAM_URL_REGEX . matcher ( path ) ; Set < String > patterns = new LinkedHashSet < String > ( ) ; while ( m . find ( ) ) { patterns . add ( m . group ( _NUM ) ) ; } return patterns ; }
static Set < String > parsePathParameters ( String path ) { Matcher m = PARAM_URL_REGEX . matcher ( path ) ; Set < String > patterns = new LinkedHashSet < String > ( ) ; while ( m . find ( ) ) { patterns . add ( m . group ( _NUM ) ) ; } return patterns ; }
static Set < String > parsePathParameters ( String path ) { Matcher m = PARAM_URL_REGEX . matcher ( path ) ; Set < String > patterns = new LinkedHashSet < String > ( ) ; while ( m . find ( ) ) { patterns . add ( m . group ( _NUM ) ) ; } return patterns ; }
static Set < String > parsePathParameters ( String path ) { Matcher m = PARAM_URL_REGEX . matcher ( path ) ; Set < String > patterns = new LinkedHashSet < String > ( ) ; while ( m . find ( ) ) { patterns . add ( m . group ( _NUM ) ) ; } return patterns ; }
public OrderedThreadPoolExecutor ( int maximumPoolSize ) { this ( DEFAULT_INITIAL_THREAD_POOL_SIZE , maximumPoolSize , DEFAULT_KEEP_ALIVE , TimeUnit . SECONDS , Executors . defaultThreadFactory ( ) , null ) ; }
public static void removeForward ( InetSocketAddress adbSockAddr , Device device , String localPortSpec , String remotePortSpec ) throws TimeoutException , AdbCommandRejectedException , IOException { try ( SocketChannel adbChan = SocketChannel . open ( adbSockAddr ) ) { adbChan . configureBlocking ( _BOOL ) ; byte [ ] request = formAdbRequest ( String . format ( STRING , device . getSerialNumber ( ) , localPortSpec ) ) ; write ( adbChan , request ) ; AdbResponse resp = readAdbResponse ( adbChan , _BOOL ) ; if ( ! resp . okay ) { Log . w ( STRING , STRING + resp . message ) ; throw new AdbCommandRejectedException ( resp . message ) ; } } }
@ Override public void write ( DataOutput out ) throws IOException { if ( USE_HADOOP_TEXT ) Text . writeString ( out , term ) ; else out . writeUTF ( term ) ; WritableUtils . writeVInt ( out , splitno ) ; WritableUtils . writeVInt ( out , flushno ) ; }
public int typeIndexFromClassDefIndex ( int classDefIndex ) { checkBounds ( classDefIndex , tableOfContents . classDefs . size ) ; int position = tableOfContents . classDefs . off + ( SizeOf . CLASS_DEF_ITEM * classDefIndex ) ; return data . getInt ( position ) ; }
public final static HeaderElement parseHeaderElement ( final String value , HeaderValueParser parser ) throws ParseException { if ( value == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( parser == null ) parser = BasicHeaderValueParser . DEFAULT ; CharArrayBuffer buffer = new CharArrayBuffer ( value . length ( ) ) ; buffer . append ( value ) ; ParserCursor cursor = new ParserCursor ( _NUM , value . length ( ) ) ; return parser . parseHeaderElement ( buffer , cursor ) ; }
public void write ( final int c ) throws IOException { if ( m_writer != null ) m_writer . write ( c ) ; if ( count >= buf_length ) flushBuffer ( ) ; if ( c < _NUM ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < _NUM ) { buf [ count ++ ] = ( byte ) ( _NUM + ( c > > _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( c & _NUM ) ) ; } else { buf [ count ++ ] = ( byte ) ( _NUM + ( c > > _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( ( c > > _NUM ) & _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( c & _NUM ) ) ; } }
public void write ( final int c ) throws IOException { if ( m_writer != null ) m_writer . write ( c ) ; if ( count >= buf_length ) flushBuffer ( ) ; if ( c < _NUM ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < _NUM ) { buf [ count ++ ] = ( byte ) ( _NUM + ( c > > _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( c & _NUM ) ) ; } else { buf [ count ++ ] = ( byte ) ( _NUM + ( c > > _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( ( c > > _NUM ) & _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( c & _NUM ) ) ; } }
public void write ( final int c ) throws IOException { if ( m_writer != null ) m_writer . write ( c ) ; if ( count >= buf_length ) flushBuffer ( ) ; if ( c < _NUM ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < _NUM ) { buf [ count ++ ] = ( byte ) ( _NUM + ( c > > _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( c & _NUM ) ) ; } else { buf [ count ++ ] = ( byte ) ( _NUM + ( c > > _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( ( c > > _NUM ) & _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( c & _NUM ) ) ; } }
public void write ( final int c ) throws IOException { if ( m_writer != null ) m_writer . write ( c ) ; if ( count >= buf_length ) flushBuffer ( ) ; if ( c < _NUM ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < _NUM ) { buf [ count ++ ] = ( byte ) ( _NUM + ( c > > _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( c & _NUM ) ) ; } else { buf [ count ++ ] = ( byte ) ( _NUM + ( c > > _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( ( c > > _NUM ) & _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( c & _NUM ) ) ; } }
public void write ( final int c ) throws IOException { if ( m_writer != null ) m_writer . write ( c ) ; if ( count >= buf_length ) flushBuffer ( ) ; if ( c < _NUM ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < _NUM ) { buf [ count ++ ] = ( byte ) ( _NUM + ( c > > _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( c & _NUM ) ) ; } else { buf [ count ++ ] = ( byte ) ( _NUM + ( c > > _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( ( c > > _NUM ) & _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( c & _NUM ) ) ; } }
public void discoverable ( BluetoothAdapter adapter ) { int mask = BluetoothReceiver . SCAN_MODE_CONNECTABLE_DISCOVERABLE_FLAG ; if ( ! adapter . isEnabled ( ) ) { fail ( STRING ) ; } int scanMode = adapter . getScanMode ( ) ; if ( scanMode == BluetoothAdapter . SCAN_MODE_CONNECTABLE_DISCOVERABLE ) { return ; } BluetoothReceiver receiver = getBluetoothReceiver ( mask ) ; assertEquals ( BluetoothAdapter . SCAN_MODE_CONNECTABLE , scanMode ) ; long start = System . currentTimeMillis ( ) ; assertTrue ( adapter . setScanMode ( BluetoothAdapter . SCAN_MODE_CONNECTABLE_DISCOVERABLE ) ) ; while ( System . currentTimeMillis ( ) - start < DISCOVERABLE_UNDISCOVERABLE_TIMEOUT ) { scanMode = adapter . getScanMode ( ) ; if ( scanMode == BluetoothAdapter . SCAN_MODE_CONNECTABLE_DISCOVERABLE && ( receiver . getFiredFlags ( ) & mask ) == mask ) { writeOutput ( String . format ( STRING , ( receiver . getCompletedTime ( ) - start ) ) ) ; removeReceiver ( receiver ) ; return ; } sleep ( POLL_TIME ) ; } int firedFlags = receiver . getFiredFlags ( ) ; removeReceiver ( receiver ) ; fail ( String . format ( STRING + STRING , scanMode , BluetoothAdapter . SCAN_MODE_CONNECTABLE_DISCOVERABLE , firedFlags , mask ) ) ; }
public final static boolean isClassFileName ( String name ) { int nameLength = name == null ? _NUM : name . length ( ) ; int suffixLength = SUFFIX_CLASS . length ; if ( nameLength < suffixLength ) return _BOOL ; for ( int i = _NUM ; i < suffixLength ; i ++ ) { char c = name . charAt ( nameLength - i - _NUM ) ; int suffixIndex = suffixLength - i - _NUM ; if ( c != SUFFIX_class [ suffixIndex ] && c != SUFFIX_CLASS [ suffixIndex ] ) return _BOOL ; } return _BOOL ; }
public void onBackPressed ( ) { if ( ! mFragments . popBackStackImmediate ( ) ) { finish ( ) ; } }
public void onBackPressed ( ) { if ( ! mFragments . popBackStackImmediate ( ) ) { finish ( ) ; } }
public static Doc append ( Doc ... docs ) { return append ( Arrays . asList ( docs ) ) ; }
public void switchItem ( @ Nullable RecyclerView recyclerView , final int selectedViewPosition ) { if ( isDeselectAnimationInProcess || isSelectAnimationInProcess || isViewCollapsing || isWaitingToDeselectAnimation || isWaitingToSelectAnimation || isSelectedItemStraightened ) { return ; } if ( recyclerView != null ) { if ( this . selectedItemPosition != RecyclerView . NO_POSITION && this . selectedItemPosition != selectedViewPosition ) { deselectItem ( recyclerView , this . selectedItemPosition , selectedViewPosition , _NUM ) ; return ; } smoothScrollToPosition ( recyclerView , null , selectedViewPosition ) ; } }
public void componentHidden ( final ComponentEvent e ) { final Object source = e . getSource ( ) ; if ( ! ( source instanceof JMenuItem ) ) return ; setChildVisible ( ( JMenuItem ) source , _BOOL ) ; }
public void componentHidden ( final ComponentEvent e ) { final Object source = e . getSource ( ) ; if ( ! ( source instanceof JMenuItem ) ) return ; setChildVisible ( ( JMenuItem ) source , _BOOL ) ; }
private boolean isProjectUsingDefaultSdk ( T projectSdk ) { if ( ! isDefaultSdk ( projectSdk ) ) { return _BOOL ; } try { IClasspathEntry entry = ClasspathUtilities . findClasspathEntryContainer ( javaProject . getRawClasspath ( ) , doGetContainerId ( ) ) ; if ( entry != null ) { if ( SdkClasspathContainer . isDefaultContainerPath ( doGetContainerId ( ) , entry . getPath ( ) ) ) { return _BOOL ; } } } catch ( CoreException ce ) { CorePluginLog . logError ( ce ) ; } return _BOOL ; }
private boolean isProjectUsingDefaultSdk ( T projectSdk ) { if ( ! isDefaultSdk ( projectSdk ) ) { return _BOOL ; } try { IClasspathEntry entry = ClasspathUtilities . findClasspathEntryContainer ( javaProject . getRawClasspath ( ) , doGetContainerId ( ) ) ; if ( entry != null ) { if ( SdkClasspathContainer . isDefaultContainerPath ( doGetContainerId ( ) , entry . getPath ( ) ) ) { return _BOOL ; } } } catch ( CoreException ce ) { CorePluginLog . logError ( ce ) ; } return _BOOL ; }
private boolean isProjectUsingDefaultSdk ( T projectSdk ) { if ( ! isDefaultSdk ( projectSdk ) ) { return _BOOL ; } try { IClasspathEntry entry = ClasspathUtilities . findClasspathEntryContainer ( javaProject . getRawClasspath ( ) , doGetContainerId ( ) ) ; if ( entry != null ) { if ( SdkClasspathContainer . isDefaultContainerPath ( doGetContainerId ( ) , entry . getPath ( ) ) ) { return _BOOL ; } } } catch ( CoreException ce ) { CorePluginLog . logError ( ce ) ; } return _BOOL ; }
private boolean isProjectUsingDefaultSdk ( T projectSdk ) { if ( ! isDefaultSdk ( projectSdk ) ) { return _BOOL ; } try { IClasspathEntry entry = ClasspathUtilities . findClasspathEntryContainer ( javaProject . getRawClasspath ( ) , doGetContainerId ( ) ) ; if ( entry != null ) { if ( SdkClasspathContainer . isDefaultContainerPath ( doGetContainerId ( ) , entry . getPath ( ) ) ) { return _BOOL ; } } } catch ( CoreException ce ) { CorePluginLog . logError ( ce ) ; } return _BOOL ; }
private boolean isProjectUsingDefaultSdk ( T projectSdk ) { if ( ! isDefaultSdk ( projectSdk ) ) { return _BOOL ; } try { IClasspathEntry entry = ClasspathUtilities . findClasspathEntryContainer ( javaProject . getRawClasspath ( ) , doGetContainerId ( ) ) ; if ( entry != null ) { if ( SdkClasspathContainer . isDefaultContainerPath ( doGetContainerId ( ) , entry . getPath ( ) ) ) { return _BOOL ; } } } catch ( CoreException ce ) { CorePluginLog . logError ( ce ) ; } return _BOOL ; }
public void addCertChainListener ( CertChainListener listener ) { certChainListeners . add ( listener ) ; }
private static StringBuilder dump ( StringBuilder _lbuffer , long value ) { for ( int j = _NUM ; j < _NUM ; j ++ ) { _lbuffer . append ( CHARS [ ( int ) ( value > > SHIFTS [ j ] ) & _NUM ] ) ; } return _lbuffer ; }
protected Set < String > allowedDuplicateErrorCodes ( ) { return Collections . emptySet ( ) ; }
protected Set < String > allowedDuplicateErrorCodes ( ) { return Collections . emptySet ( ) ; }
protected Set < String > allowedDuplicateErrorCodes ( ) { return Collections . emptySet ( ) ; }
protected Set < String > allowedDuplicateErrorCodes ( ) { return Collections . emptySet ( ) ; }
protected Set < String > allowedDuplicateErrorCodes ( ) { return Collections . emptySet ( ) ; }
public synchronized byte [ ] toByteArray ( ) { int remaining = count ; if ( remaining == _NUM ) { return EMPTY_BYTE_ARRAY ; } byte [ ] newbuf = new byte [ remaining ] ; int pos = _NUM ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; System . arraycopy ( buf , _NUM , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == _NUM ) { break ; } } return newbuf ; }
void updatedTextField ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING ) ; } CvValue cv = _cvMap . get ( getCvNum ( ) ) ; int oldCv = cv . getValue ( ) ; int newVal ; try { newVal = textToValue ( _value . getText ( ) ) ; } catch ( java . lang . NumberFormatException ex ) { newVal = _NUM ; } int newCv = newValue ( oldCv , newVal , getMask ( ) ) ; if ( oldCv != newCv ) { cv . setValue ( newCv ) ; } }
void updatedTextField ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING ) ; } CvValue cv = _cvMap . get ( getCvNum ( ) ) ; int oldCv = cv . getValue ( ) ; int newVal ; try { newVal = textToValue ( _value . getText ( ) ) ; } catch ( java . lang . NumberFormatException ex ) { newVal = _NUM ; } int newCv = newValue ( oldCv , newVal , getMask ( ) ) ; if ( oldCv != newCv ) { cv . setValue ( newCv ) ; } }
void updatedTextField ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING ) ; } CvValue cv = _cvMap . get ( getCvNum ( ) ) ; int oldCv = cv . getValue ( ) ; int newVal ; try { newVal = textToValue ( _value . getText ( ) ) ; } catch ( java . lang . NumberFormatException ex ) { newVal = _NUM ; } int newCv = newValue ( oldCv , newVal , getMask ( ) ) ; if ( oldCv != newCv ) { cv . setValue ( newCv ) ; } }
void updatedTextField ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING ) ; } CvValue cv = _cvMap . get ( getCvNum ( ) ) ; int oldCv = cv . getValue ( ) ; int newVal ; try { newVal = textToValue ( _value . getText ( ) ) ; } catch ( java . lang . NumberFormatException ex ) { newVal = _NUM ; } int newCv = newValue ( oldCv , newVal , getMask ( ) ) ; if ( oldCv != newCv ) { cv . setValue ( newCv ) ; } }
void updatedTextField ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING ) ; } CvValue cv = _cvMap . get ( getCvNum ( ) ) ; int oldCv = cv . getValue ( ) ; int newVal ; try { newVal = textToValue ( _value . getText ( ) ) ; } catch ( java . lang . NumberFormatException ex ) { newVal = _NUM ; } int newCv = newValue ( oldCv , newVal , getMask ( ) ) ; if ( oldCv != newCv ) { cv . setValue ( newCv ) ; } }
void updatedTextField ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING ) ; } CvValue cv = _cvMap . get ( getCvNum ( ) ) ; int oldCv = cv . getValue ( ) ; int newVal ; try { newVal = textToValue ( _value . getText ( ) ) ; } catch ( java . lang . NumberFormatException ex ) { newVal = _NUM ; } int newCv = newValue ( oldCv , newVal , getMask ( ) ) ; if ( oldCv != newCv ) { cv . setValue ( newCv ) ; } }
void updatedTextField ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING ) ; } CvValue cv = _cvMap . get ( getCvNum ( ) ) ; int oldCv = cv . getValue ( ) ; int newVal ; try { newVal = textToValue ( _value . getText ( ) ) ; } catch ( java . lang . NumberFormatException ex ) { newVal = _NUM ; } int newCv = newValue ( oldCv , newVal , getMask ( ) ) ; if ( oldCv != newCv ) { cv . setValue ( newCv ) ; } }
void updatedTextField ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING ) ; } CvValue cv = _cvMap . get ( getCvNum ( ) ) ; int oldCv = cv . getValue ( ) ; int newVal ; try { newVal = textToValue ( _value . getText ( ) ) ; } catch ( java . lang . NumberFormatException ex ) { newVal = _NUM ; } int newCv = newValue ( oldCv , newVal , getMask ( ) ) ; if ( oldCv != newCv ) { cv . setValue ( newCv ) ; } }
void updatedTextField ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING ) ; } CvValue cv = _cvMap . get ( getCvNum ( ) ) ; int oldCv = cv . getValue ( ) ; int newVal ; try { newVal = textToValue ( _value . getText ( ) ) ; } catch ( java . lang . NumberFormatException ex ) { newVal = _NUM ; } int newCv = newValue ( oldCv , newVal , getMask ( ) ) ; if ( oldCv != newCv ) { cv . setValue ( newCv ) ; } }
void updatedTextField ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING ) ; } CvValue cv = _cvMap . get ( getCvNum ( ) ) ; int oldCv = cv . getValue ( ) ; int newVal ; try { newVal = textToValue ( _value . getText ( ) ) ; } catch ( java . lang . NumberFormatException ex ) { newVal = _NUM ; } int newCv = newValue ( oldCv , newVal , getMask ( ) ) ; if ( oldCv != newCv ) { cv . setValue ( newCv ) ; } }
void updateStylesListeningTo ( ) { synchronized ( listeningStyles ) { StyleContext styles = ( StyleContext ) getAttributeContext ( ) ; if ( styleChangeListener == null ) { styleChangeListener = createStyleChangeListener ( ) ; } if ( styleChangeListener != null && styles != null ) { Enumeration styleNames = styles . getStyleNames ( ) ; Vector v = ( Vector ) listeningStyles . clone ( ) ; listeningStyles . removeAllElements ( ) ; List < ChangeListener > staleListeners = AbstractChangeHandler . getStaleListeners ( styleChangeListener ) ; while ( styleNames . hasMoreElements ( ) ) { String name = ( String ) styleNames . nextElement ( ) ; Style aStyle = styles . getStyle ( name ) ; int index = v . indexOf ( aStyle ) ; listeningStyles . addElement ( aStyle ) ; if ( index == - _NUM ) { for ( ChangeListener l : staleListeners ) { aStyle . removeChangeListener ( l ) ; } aStyle . addChangeListener ( styleChangeListener ) ; } else { v . removeElementAt ( index ) ; } } for ( int counter = v . size ( ) - _NUM ; counter >= _NUM ; counter -- ) { Style aStyle = ( Style ) v . elementAt ( counter ) ; aStyle . removeChangeListener ( styleChangeListener ) ; } if ( listeningStyles . size ( ) == _NUM ) { styleChangeListener = null ; } } } }
protected Dimension computeLengths ( String annoText ) { String [ ] lines = Util . splitLines ( annoText ) ; int lineLength = _NUM ; for ( String line : lines ) { if ( line . length ( ) > lineLength ) lineLength = line . length ( ) ; } return new Dimension ( lineLength + _NUM , lines . length + _NUM ) ; }
public boolean usesDefaultPropertyAccess ( ) { return m_defaultAccess . equals ( JPA_ACCESS_PROPERTY ) ; }
public V put ( final K k , final V v ) { final WeakReference < V > ref = newWeakRef ( k , v , referenceQueue ) ; final WeakReference < V > oldRef = map . put ( k , ref ) ; final V oldVal = oldRef == null ? null : oldRef . get ( ) ; if ( queue . add ( v ) && DEBUG ) { log . debug ( STRING + k + STRING + v ) ; } didUpdate ( k , ref , oldRef ) ; return oldVal ; }
private void parse ( ) { if ( lexer == null ) { tokens = null ; return ; } List < Token > toks = new ArrayList < Token > ( getLength ( ) / _NUM ) ; long ts = System . nanoTime ( ) ; int len = getLength ( ) ; try { Segment seg = new Segment ( ) ; getText ( _NUM , getLength ( ) , seg ) ; CharArrayReader reader = new CharArrayReader ( seg . array , seg . offset , seg . count ) ; lexer . yyreset ( reader ) ; Token token ; while ( ( token = lexer . yylex ( ) ) != null ) { toks . add ( token ) ; } } catch ( BadLocationException ex ) { log . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { log . log ( Level . SEVERE , null , ex ) ; } finally { if ( log . isLoggable ( Level . FINEST ) ) { log . finest ( String . format ( STRING , len , ( System . nanoTime ( ) - ts ) / _NUM , toks . size ( ) ) ) ; } tokens = toks ; } }
private void parse ( ) { if ( lexer == null ) { tokens = null ; return ; } List < Token > toks = new ArrayList < Token > ( getLength ( ) / _NUM ) ; long ts = System . nanoTime ( ) ; int len = getLength ( ) ; try { Segment seg = new Segment ( ) ; getText ( _NUM , getLength ( ) , seg ) ; CharArrayReader reader = new CharArrayReader ( seg . array , seg . offset , seg . count ) ; lexer . yyreset ( reader ) ; Token token ; while ( ( token = lexer . yylex ( ) ) != null ) { toks . add ( token ) ; } } catch ( BadLocationException ex ) { log . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { log . log ( Level . SEVERE , null , ex ) ; } finally { if ( log . isLoggable ( Level . FINEST ) ) { log . finest ( String . format ( STRING , len , ( System . nanoTime ( ) - ts ) / _NUM , toks . size ( ) ) ) ; } tokens = toks ; } }
private void parse ( ) { if ( lexer == null ) { tokens = null ; return ; } List < Token > toks = new ArrayList < Token > ( getLength ( ) / _NUM ) ; long ts = System . nanoTime ( ) ; int len = getLength ( ) ; try { Segment seg = new Segment ( ) ; getText ( _NUM , getLength ( ) , seg ) ; CharArrayReader reader = new CharArrayReader ( seg . array , seg . offset , seg . count ) ; lexer . yyreset ( reader ) ; Token token ; while ( ( token = lexer . yylex ( ) ) != null ) { toks . add ( token ) ; } } catch ( BadLocationException ex ) { log . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { log . log ( Level . SEVERE , null , ex ) ; } finally { if ( log . isLoggable ( Level . FINEST ) ) { log . finest ( String . format ( STRING , len , ( System . nanoTime ( ) - ts ) / _NUM , toks . size ( ) ) ) ; } tokens = toks ; } }
private void parse ( ) { if ( lexer == null ) { tokens = null ; return ; } List < Token > toks = new ArrayList < Token > ( getLength ( ) / _NUM ) ; long ts = System . nanoTime ( ) ; int len = getLength ( ) ; try { Segment seg = new Segment ( ) ; getText ( _NUM , getLength ( ) , seg ) ; CharArrayReader reader = new CharArrayReader ( seg . array , seg . offset , seg . count ) ; lexer . yyreset ( reader ) ; Token token ; while ( ( token = lexer . yylex ( ) ) != null ) { toks . add ( token ) ; } } catch ( BadLocationException ex ) { log . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { log . log ( Level . SEVERE , null , ex ) ; } finally { if ( log . isLoggable ( Level . FINEST ) ) { log . finest ( String . format ( STRING , len , ( System . nanoTime ( ) - ts ) / _NUM , toks . size ( ) ) ) ; } tokens = toks ; } }
private void parse ( ) { if ( lexer == null ) { tokens = null ; return ; } List < Token > toks = new ArrayList < Token > ( getLength ( ) / _NUM ) ; long ts = System . nanoTime ( ) ; int len = getLength ( ) ; try { Segment seg = new Segment ( ) ; getText ( _NUM , getLength ( ) , seg ) ; CharArrayReader reader = new CharArrayReader ( seg . array , seg . offset , seg . count ) ; lexer . yyreset ( reader ) ; Token token ; while ( ( token = lexer . yylex ( ) ) != null ) { toks . add ( token ) ; } } catch ( BadLocationException ex ) { log . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { log . log ( Level . SEVERE , null , ex ) ; } finally { if ( log . isLoggable ( Level . FINEST ) ) { log . finest ( String . format ( STRING , len , ( System . nanoTime ( ) - ts ) / _NUM , toks . size ( ) ) ) ; } tokens = toks ; } }
private void addImpliedVersion ( Version v ) { if ( ! impliedVersions . contains ( v ) ) { impliedVersions . add ( v ) ; for ( Version impliedVersion : v . getImpliedVersions ( ) ) { addImpliedVersion ( impliedVersion ) ; } } }
private void addNameDatesPanel ( final String headline , final IFieldDescription < String > name , final IFieldDescription < Date > creationDate , final IFieldDescription < Date > modificationDate ) { final JPanel nameDatesPanel = new JPanel ( new GridLayout ( _NUM , _NUM , _NUM , _NUM ) ) ; nameDatesPanel . setBorder ( new TitledBorder ( headline ) ) ; nameDatesPanel . add ( new CLabeledComponent ( STRING + STRING , name . getHelp ( ) , m_nameTextField ) ) ; nameDatesPanel . add ( new CLabeledComponent ( STRING + STRING , creationDate . getHelp ( ) , m_creationDateValueLabel ) ) ; nameDatesPanel . add ( new CLabeledComponent ( STRING + STRING , modificationDate . getHelp ( ) , m_modificationDateValueLabel ) ) ; add ( nameDatesPanel , BorderLayout . NORTH ) ; }
private void addNameDatesPanel ( final String headline , final IFieldDescription < String > name , final IFieldDescription < Date > creationDate , final IFieldDescription < Date > modificationDate ) { final JPanel nameDatesPanel = new JPanel ( new GridLayout ( _NUM , _NUM , _NUM , _NUM ) ) ; nameDatesPanel . setBorder ( new TitledBorder ( headline ) ) ; nameDatesPanel . add ( new CLabeledComponent ( STRING + STRING , name . getHelp ( ) , m_nameTextField ) ) ; nameDatesPanel . add ( new CLabeledComponent ( STRING + STRING , creationDate . getHelp ( ) , m_creationDateValueLabel ) ) ; nameDatesPanel . add ( new CLabeledComponent ( STRING + STRING , modificationDate . getHelp ( ) , m_modificationDateValueLabel ) ) ; add ( nameDatesPanel , BorderLayout . NORTH ) ; }
private void addNameDatesPanel ( final String headline , final IFieldDescription < String > name , final IFieldDescription < Date > creationDate , final IFieldDescription < Date > modificationDate ) { final JPanel nameDatesPanel = new JPanel ( new GridLayout ( _NUM , _NUM , _NUM , _NUM ) ) ; nameDatesPanel . setBorder ( new TitledBorder ( headline ) ) ; nameDatesPanel . add ( new CLabeledComponent ( STRING + STRING , name . getHelp ( ) , m_nameTextField ) ) ; nameDatesPanel . add ( new CLabeledComponent ( STRING + STRING , creationDate . getHelp ( ) , m_creationDateValueLabel ) ) ; nameDatesPanel . add ( new CLabeledComponent ( STRING + STRING , modificationDate . getHelp ( ) , m_modificationDateValueLabel ) ) ; add ( nameDatesPanel , BorderLayout . NORTH ) ; }
public static File createTmpFile ( String pathToFile ) throws IOException { File file = new File ( pathToFile ) ; if ( file . exists ( ) ) { file . delete ( ) ; } if ( ! file . createNewFile ( ) ) { LOGGER . warn ( STRING + file . getAbsolutePath ( ) + STRING ) ; } return file ; }
public static File createTmpFile ( String pathToFile ) throws IOException { File file = new File ( pathToFile ) ; if ( file . exists ( ) ) { file . delete ( ) ; } if ( ! file . createNewFile ( ) ) { LOGGER . warn ( STRING + file . getAbsolutePath ( ) + STRING ) ; } return file ; }
public static void copyStream ( InputStream inputStream , OutputStream outputStream ) { if ( inputStream != null && outputStream != null ) { try { int length = - _NUM ; byte [ ] buffer = new byte [ Constant . Capacity . BYTES_PER_MB ] ; while ( ( length = inputStream . read ( buffer , _NUM , buffer . length ) ) != - _NUM ) { outputStream . write ( buffer , _NUM , length ) ; outputStream . flush ( ) ; } } catch ( Exception e ) { throw new FileUtilException ( e ) ; } } }
public synchronized void remove ( String k ) { if ( k == null ) { for ( int i = _NUM ; i < nkeys ; i ++ ) { while ( keys [ i ] == null && i < nkeys ) { for ( int j = i ; j < nkeys - _NUM ; j ++ ) { keys [ j ] = keys [ j + _NUM ] ; values [ j ] = values [ j + _NUM ] ; } nkeys -- ; } } } else { for ( int i = _NUM ; i < nkeys ; i ++ ) { while ( k . equalsIgnoreCase ( keys [ i ] ) && i < nkeys ) { for ( int j = i ; j < nkeys - _NUM ; j ++ ) { keys [ j ] = keys [ j + _NUM ] ; values [ j ] = values [ j + _NUM ] ; } nkeys -- ; } } } }
public synchronized void remove ( String k ) { if ( k == null ) { for ( int i = _NUM ; i < nkeys ; i ++ ) { while ( keys [ i ] == null && i < nkeys ) { for ( int j = i ; j < nkeys - _NUM ; j ++ ) { keys [ j ] = keys [ j + _NUM ] ; values [ j ] = values [ j + _NUM ] ; } nkeys -- ; } } } else { for ( int i = _NUM ; i < nkeys ; i ++ ) { while ( k . equalsIgnoreCase ( keys [ i ] ) && i < nkeys ) { for ( int j = i ; j < nkeys - _NUM ; j ++ ) { keys [ j ] = keys [ j + _NUM ] ; values [ j ] = values [ j + _NUM ] ; } nkeys -- ; } } } }
public static Thread consumeProcessErrorStream ( Process self , Appendable error ) { Thread thread = new Thread ( new TextDumper ( self . getErrorStream ( ) , error ) ) ; thread . start ( ) ; return thread ; }
public static Thread consumeProcessErrorStream ( Process self , Appendable error ) { Thread thread = new Thread ( new TextDumper ( self . getErrorStream ( ) , error ) ) ; thread . start ( ) ; return thread ; }
public static Thread consumeProcessErrorStream ( Process self , Appendable error ) { Thread thread = new Thread ( new TextDumper ( self . getErrorStream ( ) , error ) ) ; thread . start ( ) ; return thread ; }
public static Thread consumeProcessErrorStream ( Process self , Appendable error ) { Thread thread = new Thread ( new TextDumper ( self . getErrorStream ( ) , error ) ) ; thread . start ( ) ; return thread ; }
public static Thread consumeProcessErrorStream ( Process self , Appendable error ) { Thread thread = new Thread ( new TextDumper ( self . getErrorStream ( ) , error ) ) ; thread . start ( ) ; return thread ; }
public ExtensionQuery ( String pluginId , String extensionPointName , String attributeName ) { this . pluginId = extensionPointName . contains ( STRING ) ? null : pluginId ; this . extensionPointName = extensionPointName ; this . attributeName = attributeName ; }
private static void addDigest ( MessageDigest digest , int v ) { digest . update ( ( byte ) ( v > > _NUM ) ) ; digest . update ( ( byte ) ( v > > _NUM ) ) ; digest . update ( ( byte ) ( v > > _NUM ) ) ; digest . update ( ( byte ) v ) ; }
public static byte [ ] convertJWSConcatenatedToDEREncodedSignature ( final byte [ ] concatenatedSignatureValue ) throws IOException { final byte [ ] r = new byte [ _NUM ] ; final byte [ ] s = new byte [ _NUM ] ; System . arraycopy ( concatenatedSignatureValue , _NUM , r , _NUM , _NUM ) ; System . arraycopy ( concatenatedSignatureValue , _NUM , s , _NUM , _NUM ) ; final BigInteger rBigInteger = new BigInteger ( r ) ; final BigInteger sBigInteger = new BigInteger ( s ) ; final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; final DERSequenceGenerator seqGen = new DERSequenceGenerator ( bos ) ; seqGen . addObject ( new ASN1Integer ( rBigInteger . toByteArray ( ) ) ) ; seqGen . addObject ( new ASN1Integer ( sBigInteger . toByteArray ( ) ) ) ; seqGen . close ( ) ; bos . close ( ) ; final byte [ ] derEncodedSignatureValue = bos . toByteArray ( ) ; return derEncodedSignatureValue ; }
public static byte [ ] convertJWSConcatenatedToDEREncodedSignature ( final byte [ ] concatenatedSignatureValue ) throws IOException { final byte [ ] r = new byte [ _NUM ] ; final byte [ ] s = new byte [ _NUM ] ; System . arraycopy ( concatenatedSignatureValue , _NUM , r , _NUM , _NUM ) ; System . arraycopy ( concatenatedSignatureValue , _NUM , s , _NUM , _NUM ) ; final BigInteger rBigInteger = new BigInteger ( r ) ; final BigInteger sBigInteger = new BigInteger ( s ) ; final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; final DERSequenceGenerator seqGen = new DERSequenceGenerator ( bos ) ; seqGen . addObject ( new ASN1Integer ( rBigInteger . toByteArray ( ) ) ) ; seqGen . addObject ( new ASN1Integer ( sBigInteger . toByteArray ( ) ) ) ; seqGen . close ( ) ; bos . close ( ) ; final byte [ ] derEncodedSignatureValue = bos . toByteArray ( ) ; return derEncodedSignatureValue ; }
public Term ( String fld , BytesRef bytes ) { field = fld ; this . bytes = bytes == null ? null : BytesRef . deepCopyOf ( bytes ) ; }
public Term ( String fld , BytesRef bytes ) { field = fld ; this . bytes = bytes == null ? null : BytesRef . deepCopyOf ( bytes ) ; }
public Term ( String fld , BytesRef bytes ) { field = fld ; this . bytes = bytes == null ? null : BytesRef . deepCopyOf ( bytes ) ; }
public Term ( String fld , BytesRef bytes ) { field = fld ; this . bytes = bytes == null ? null : BytesRef . deepCopyOf ( bytes ) ; }
public PrivateKeyUsageExtension ( Boolean critical , Object value ) throws CertificateException , IOException { this . extensionId = PKIXExtensions . PrivateKeyUsage_Id ; this . critical = critical . booleanValue ( ) ; this . extensionValue = ( byte [ ] ) value ; DerInputStream str = new DerInputStream ( this . extensionValue ) ; DerValue [ ] seq = str . getSequence ( _NUM ) ; for ( int i = _NUM ; i < seq . length ; i ++ ) { DerValue opt = seq [ i ] ; if ( opt . isContextSpecific ( TAG_BEFORE ) && ! opt . isConstructed ( ) ) { if ( notBefore != null ) { throw new CertificateParsingException ( STRING ) ; } opt . resetTag ( DerValue . tag_GeneralizedTime ) ; str = new DerInputStream ( opt . toByteArray ( ) ) ; notBefore = str . getGeneralizedTime ( ) ; } else if ( opt . isContextSpecific ( TAG_AFTER ) && ! opt . isConstructed ( ) ) { if ( notAfter != null ) { throw new CertificateParsingException ( STRING ) ; } opt . resetTag ( DerValue . tag_GeneralizedTime ) ; str = new DerInputStream ( opt . toByteArray ( ) ) ; notAfter = str . getGeneralizedTime ( ) ; } else throw new IOException ( STRING + STRING ) ; } }
private void addMethod ( MappedClass clazz , String [ ] parts ) { String original = STRING ; String newName = STRING ; String desc = STRING ; if ( parts . length == _NUM ) { original = parts [ _NUM ] ; newName = parts [ _NUM ] ; desc = parts [ _NUM ] ; } else if ( parts . length == _NUM ) { original = parts [ _NUM ] ; newName = parts [ _NUM ] ; desc = parts [ _NUM ] ; } else { return ; } if ( desc . contains ( STRING ) ) { desc = desc . replace ( STRING , STRING ) ; } MappedMember mm = new MappedMember ( clazz , findMethod ( clazz . getNode ( ) , original , desc ) , - _NUM , desc , original ) ; mm . setNewName ( newName ) ; clazz . addMethod ( mm ) ; }
public AbstractTreePrinter removeLastIndent ( ) { removeLastChars ( indent * INDENT . length ( ) ) ; return this ; }
@ Override public void onViewPositionChanged ( View changedView , int left , int top , int dx , int dy ) { super . onViewPositionChanged ( changedView , left , top , dx , dy ) ; mDragOffset = Math . abs ( top ) ; float fractionScreen = ( float ) mDragOffset / mConfigView . getVerticalDragRange ( ) ; mConfigView . onViewPositionChanged ( fractionScreen >= _NUM ? _NUM : fractionScreen ) ; }
@ Override public void onViewPositionChanged ( View changedView , int left , int top , int dx , int dy ) { super . onViewPositionChanged ( changedView , left , top , dx , dy ) ; mDragOffset = Math . abs ( top ) ; float fractionScreen = ( float ) mDragOffset / mConfigView . getVerticalDragRange ( ) ; mConfigView . onViewPositionChanged ( fractionScreen >= _NUM ? _NUM : fractionScreen ) ; }
public SummaryPanel ( final NeuronGroup ng , boolean editable ) { setGroup ( ng ) ; this . editable = editable ; incomingGroupLabel . setText ( STRING ) ; outgoingGroupLabel . setText ( STRING ) ; fillFieldValues ( ) ; initializeLayout ( ) ; }
public IntColumn ( int nrows , int capacity , int defaultValue ) { super ( int . class , new Integer ( defaultValue ) ) ; if ( capacity < nrows ) { throw new IllegalArgumentException ( STRING ) ; } m_values = new int [ capacity ] ; Arrays . fill ( m_values , defaultValue ) ; m_size = nrows ; }
public boolean equals ( InitiativeRoll other ) { if ( size ( ) != other . size ( ) ) { return _BOOL ; } for ( int i = _NUM ; i < size ( ) ; i ++ ) { if ( getRoll ( i ) != other . getRoll ( i ) ) { return _BOOL ; } } return _BOOL ; }
public static Integer toRef ( int i ) { return Integer . valueOf ( i ) ; }
public void modifyVariableId ( String oldNodeId , String newNodeId ) { BNode node = nodes . remove ( oldNodeId ) ; chanceNodes . remove ( oldNodeId ) ; utilityNodes . remove ( oldNodeId ) ; actionNodes . remove ( oldNodeId ) ; if ( node != null ) { addNode ( node ) ; } else { log . warning ( STRING + oldNodeId + STRING ) ; } }
public void modifyVariableId ( String oldNodeId , String newNodeId ) { BNode node = nodes . remove ( oldNodeId ) ; chanceNodes . remove ( oldNodeId ) ; utilityNodes . remove ( oldNodeId ) ; actionNodes . remove ( oldNodeId ) ; if ( node != null ) { addNode ( node ) ; } else { log . warning ( STRING + oldNodeId + STRING ) ; } }
protected void append ( int value ) { mMessage . write ( value ) ; mPosition ++ ; }
@ Bean public ClientDetailsService clientDetailsService ( ) throws Exception { return combinedService_ ; }
protected org . codehaus . cargo . container . deployable . Deployable createAutoDeployDeployable ( org . codehaus . cargo . container . Container container ) throws MojoExecutionException { Deployable deployableElement = new Deployable ( ) ; return deployableElement . createDeployable ( container . getId ( ) , getCargoProject ( ) ) ; }
public static int nextMessageID ( ) { int nextID = nextMessageID . getAndIncrement ( ) ; if ( nextID == Integer . MAX_VALUE ) { nextMessageID . set ( _NUM ) ; } return nextID ; }
public IBlockingBuffer < E > newInstance ( ) { lock . lock ( ) ; try { if ( ! isOpen ( ) ) throw new BufferClosedException ( ) ; final IBlockingBuffer < E > n = new InnerBlockingBuffer ( ) ; if ( ! set . add ( n ) ) throw new AssertionError ( ) ; counter ++ ; return n ; } finally { lock . unlock ( ) ; } }
public IBlockingBuffer < E > newInstance ( ) { lock . lock ( ) ; try { if ( ! isOpen ( ) ) throw new BufferClosedException ( ) ; final IBlockingBuffer < E > n = new InnerBlockingBuffer ( ) ; if ( ! set . add ( n ) ) throw new AssertionError ( ) ; counter ++ ; return n ; } finally { lock . unlock ( ) ; } }
protected String metaOption ( ) { return STRING + STRING ; }
protected boolean containsURL ( URL url ) { if ( _urls != null ) { for ( URL testURL : _urls ) { if ( url . equals ( testURL ) ) return _BOOL ; } } ClassLoader parent = getParent ( ) ; if ( parent instanceof DynamicClassLoader ) { DynamicClassLoader dynParent = ( DynamicClassLoader ) parent ; if ( dynParent . containsURL ( url ) ) { return _BOOL ; } } for ( DynamicClassLoader loaderImport : _importLoaders ) { if ( loaderImport . containsURL ( url ) ) { return _BOOL ; } } return _BOOL ; }
protected boolean containsURL ( URL url ) { if ( _urls != null ) { for ( URL testURL : _urls ) { if ( url . equals ( testURL ) ) return _BOOL ; } } ClassLoader parent = getParent ( ) ; if ( parent instanceof DynamicClassLoader ) { DynamicClassLoader dynParent = ( DynamicClassLoader ) parent ; if ( dynParent . containsURL ( url ) ) { return _BOOL ; } } for ( DynamicClassLoader loaderImport : _importLoaders ) { if ( loaderImport . containsURL ( url ) ) { return _BOOL ; } } return _BOOL ; }
private void buildSubgraphs ( List subgraphList , PolygonBuilder polyBuilder ) { List processedGraphs = new ArrayList ( ) ; for ( Iterator i = subgraphList . iterator ( ) ; i . hasNext ( ) ; ) { BufferSubgraph subgraph = ( BufferSubgraph ) i . next ( ) ; Coordinate p = subgraph . getRightmostCoordinate ( ) ; SubgraphDepthLocater locater = new SubgraphDepthLocater ( processedGraphs ) ; int outsideDepth = locater . getDepth ( p ) ; subgraph . computeDepth ( outsideDepth ) ; subgraph . findResultEdges ( ) ; processedGraphs . add ( subgraph ) ; polyBuilder . add ( subgraph . getDirectedEdges ( ) , subgraph . getNodes ( ) ) ; } }
private void buildSubgraphs ( List subgraphList , PolygonBuilder polyBuilder ) { List processedGraphs = new ArrayList ( ) ; for ( Iterator i = subgraphList . iterator ( ) ; i . hasNext ( ) ; ) { BufferSubgraph subgraph = ( BufferSubgraph ) i . next ( ) ; Coordinate p = subgraph . getRightmostCoordinate ( ) ; SubgraphDepthLocater locater = new SubgraphDepthLocater ( processedGraphs ) ; int outsideDepth = locater . getDepth ( p ) ; subgraph . computeDepth ( outsideDepth ) ; subgraph . findResultEdges ( ) ; processedGraphs . add ( subgraph ) ; polyBuilder . add ( subgraph . getDirectedEdges ( ) , subgraph . getNodes ( ) ) ; } }
private void buildSubgraphs ( List subgraphList , PolygonBuilder polyBuilder ) { List processedGraphs = new ArrayList ( ) ; for ( Iterator i = subgraphList . iterator ( ) ; i . hasNext ( ) ; ) { BufferSubgraph subgraph = ( BufferSubgraph ) i . next ( ) ; Coordinate p = subgraph . getRightmostCoordinate ( ) ; SubgraphDepthLocater locater = new SubgraphDepthLocater ( processedGraphs ) ; int outsideDepth = locater . getDepth ( p ) ; subgraph . computeDepth ( outsideDepth ) ; subgraph . findResultEdges ( ) ; processedGraphs . add ( subgraph ) ; polyBuilder . add ( subgraph . getDirectedEdges ( ) , subgraph . getNodes ( ) ) ; } }
public static boolean clearDir ( File dir ) { if ( ! dir . isDirectory ( ) ) return _BOOL ; File [ ] files = dir . listFiles ( ) ; if ( files == null || files . length == _NUM ) return _BOOL ; boolean cleared = _BOOL ; for ( File sub : files ) { cleared &= delete ( sub ) ; } return cleared ; }
public static boolean clearDir ( File dir ) { if ( ! dir . isDirectory ( ) ) return _BOOL ; File [ ] files = dir . listFiles ( ) ; if ( files == null || files . length == _NUM ) return _BOOL ; boolean cleared = _BOOL ; for ( File sub : files ) { cleared &= delete ( sub ) ; } return cleared ; }
@ SuppressWarnings ( STRING ) public static < T , P extends Predicate < T > > P find ( Predicate < T > p , Class < P > clazz ) { if ( clazz . isAssignableFrom ( p . getClass ( ) ) ) { return ( P ) p ; } for ( Predicate < T > c : p . getChildren ( ) ) { P r = find ( c , clazz ) ; if ( r != null ) { return r ; } } return null ; }
private void toggleUnderlayImage ( ) { if ( enableBgImage . isSelected ( ) ) { String imgFile = null ; int [ ] offsets ; double scale , rotate ; BufferedImage image ; try { Settings settings = new Settings ( UNDERLAY_NS ) ; imgFile = settings . getSetting ( STRING ) ; offsets = settings . getCsvInts ( STRING , _NUM ) ; scale = settings . getDouble ( STRING ) ; rotate = settings . getDouble ( STRING ) ; image = ImageIO . read ( new File ( imgFile ) ) ; } catch ( IOException ex ) { warn ( STRING + imgFile + STRING + ex . getMessage ( ) ) ; enableBgImage . setSelected ( _BOOL ) ; return ; } catch ( SettingsError er ) { warn ( STRING + er . getMessage ( ) ) ; return ; } field . setUnderlayImage ( image , offsets [ _NUM ] , offsets [ _NUM ] , scale , rotate ) ; } else { field . setUnderlayImage ( null , _NUM , _NUM , _NUM , _NUM ) ; } }
private void toggleUnderlayImage ( ) { if ( enableBgImage . isSelected ( ) ) { String imgFile = null ; int [ ] offsets ; double scale , rotate ; BufferedImage image ; try { Settings settings = new Settings ( UNDERLAY_NS ) ; imgFile = settings . getSetting ( STRING ) ; offsets = settings . getCsvInts ( STRING , _NUM ) ; scale = settings . getDouble ( STRING ) ; rotate = settings . getDouble ( STRING ) ; image = ImageIO . read ( new File ( imgFile ) ) ; } catch ( IOException ex ) { warn ( STRING + imgFile + STRING + ex . getMessage ( ) ) ; enableBgImage . setSelected ( _BOOL ) ; return ; } catch ( SettingsError er ) { warn ( STRING + er . getMessage ( ) ) ; return ; } field . setUnderlayImage ( image , offsets [ _NUM ] , offsets [ _NUM ] , scale , rotate ) ; } else { field . setUnderlayImage ( null , _NUM , _NUM , _NUM , _NUM ) ; } }
private void toggleUnderlayImage ( ) { if ( enableBgImage . isSelected ( ) ) { String imgFile = null ; int [ ] offsets ; double scale , rotate ; BufferedImage image ; try { Settings settings = new Settings ( UNDERLAY_NS ) ; imgFile = settings . getSetting ( STRING ) ; offsets = settings . getCsvInts ( STRING , _NUM ) ; scale = settings . getDouble ( STRING ) ; rotate = settings . getDouble ( STRING ) ; image = ImageIO . read ( new File ( imgFile ) ) ; } catch ( IOException ex ) { warn ( STRING + imgFile + STRING + ex . getMessage ( ) ) ; enableBgImage . setSelected ( _BOOL ) ; return ; } catch ( SettingsError er ) { warn ( STRING + er . getMessage ( ) ) ; return ; } field . setUnderlayImage ( image , offsets [ _NUM ] , offsets [ _NUM ] , scale , rotate ) ; } else { field . setUnderlayImage ( null , _NUM , _NUM , _NUM , _NUM ) ; } }
private void toggleUnderlayImage ( ) { if ( enableBgImage . isSelected ( ) ) { String imgFile = null ; int [ ] offsets ; double scale , rotate ; BufferedImage image ; try { Settings settings = new Settings ( UNDERLAY_NS ) ; imgFile = settings . getSetting ( STRING ) ; offsets = settings . getCsvInts ( STRING , _NUM ) ; scale = settings . getDouble ( STRING ) ; rotate = settings . getDouble ( STRING ) ; image = ImageIO . read ( new File ( imgFile ) ) ; } catch ( IOException ex ) { warn ( STRING + imgFile + STRING + ex . getMessage ( ) ) ; enableBgImage . setSelected ( _BOOL ) ; return ; } catch ( SettingsError er ) { warn ( STRING + er . getMessage ( ) ) ; return ; } field . setUnderlayImage ( image , offsets [ _NUM ] , offsets [ _NUM ] , scale , rotate ) ; } else { field . setUnderlayImage ( null , _NUM , _NUM , _NUM , _NUM ) ; } }
public boolean insertsAreDetected ( int type ) throws SQLException { return _BOOL ; }
protected void addModule ( Map < Class < ? extends IFloodlightService > , IFloodlightModule > moduleMap , Collection < IFloodlightModule > moduleSet , IFloodlightModule module ) { if ( ! moduleSet . contains ( module ) ) { Collection < Class < ? extends IFloodlightService > > servs = moduleServiceMap . get ( module ) ; if ( servs != null ) { for ( Class < ? extends IFloodlightService > c : servs ) moduleMap . put ( c , module ) ; } moduleSet . add ( module ) ; } }
protected void addModule ( Map < Class < ? extends IFloodlightService > , IFloodlightModule > moduleMap , Collection < IFloodlightModule > moduleSet , IFloodlightModule module ) { if ( ! moduleSet . contains ( module ) ) { Collection < Class < ? extends IFloodlightService > > servs = moduleServiceMap . get ( module ) ; if ( servs != null ) { for ( Class < ? extends IFloodlightService > c : servs ) moduleMap . put ( c , module ) ; } moduleSet . add ( module ) ; } }
protected void renderMenuFull ( Appendable writer , Map < String , Object > context , ModelMenu menu , StringBuffer sb ) throws IOException { try { executeMacro ( writer , sb . toString ( ) ) ; } catch ( TemplateException e ) { throw new IOException ( e ) ; } }
protected void renderMenuFull ( Appendable writer , Map < String , Object > context , ModelMenu menu , StringBuffer sb ) throws IOException { try { executeMacro ( writer , sb . toString ( ) ) ; } catch ( TemplateException e ) { throw new IOException ( e ) ; } }
protected void renderMenuFull ( Appendable writer , Map < String , Object > context , ModelMenu menu , StringBuffer sb ) throws IOException { try { executeMacro ( writer , sb . toString ( ) ) ; } catch ( TemplateException e ) { throw new IOException ( e ) ; } }
private void parseUnit ( Element unitNode , Vector < Entity > list ) { NodeList nl = unitNode . getChildNodes ( ) ; for ( int i = _NUM ; i < nl . getLength ( ) ; i ++ ) { Node currNode = nl . item ( i ) ; if ( currNode . getParentNode ( ) != unitNode ) { continue ; } int nodeType = currNode . getNodeType ( ) ; if ( nodeType == Node . ELEMENT_NODE ) { String nodeName = currNode . getNodeName ( ) ; if ( nodeName . equalsIgnoreCase ( ENTITY ) ) { parseEntity ( ( Element ) currNode , list ) ; } else if ( nodeName . equalsIgnoreCase ( PILOT ) ) { parsePilot ( ( Element ) currNode ) ; } } else { continue ; } } }
protected int indexedTermPrefixLength ( final BytesRef priorTerm , final BytesRef indexedTerm ) { final int idxTermOffset = indexedTerm . offset ; final int priorTermOffset = priorTerm . offset ; final int limit = Math . min ( priorTerm . length , indexedTerm . length ) ; for ( int byteIdx = _NUM ; byteIdx < limit ; byteIdx ++ ) { if ( priorTerm . bytes [ priorTermOffset + byteIdx ] != indexedTerm . bytes [ idxTermOffset + byteIdx ] ) { return byteIdx + _NUM ; } } return Math . min ( _NUM + priorTerm . length , indexedTerm . length ) ; }
protected int indexedTermPrefixLength ( final BytesRef priorTerm , final BytesRef indexedTerm ) { final int idxTermOffset = indexedTerm . offset ; final int priorTermOffset = priorTerm . offset ; final int limit = Math . min ( priorTerm . length , indexedTerm . length ) ; for ( int byteIdx = _NUM ; byteIdx < limit ; byteIdx ++ ) { if ( priorTerm . bytes [ priorTermOffset + byteIdx ] != indexedTerm . bytes [ idxTermOffset + byteIdx ] ) { return byteIdx + _NUM ; } } return Math . min ( _NUM + priorTerm . length , indexedTerm . length ) ; }
protected int indexedTermPrefixLength ( final BytesRef priorTerm , final BytesRef indexedTerm ) { final int idxTermOffset = indexedTerm . offset ; final int priorTermOffset = priorTerm . offset ; final int limit = Math . min ( priorTerm . length , indexedTerm . length ) ; for ( int byteIdx = _NUM ; byteIdx < limit ; byteIdx ++ ) { if ( priorTerm . bytes [ priorTermOffset + byteIdx ] != indexedTerm . bytes [ idxTermOffset + byteIdx ] ) { return byteIdx + _NUM ; } } return Math . min ( _NUM + priorTerm . length , indexedTerm . length ) ; }
protected int indexedTermPrefixLength ( final BytesRef priorTerm , final BytesRef indexedTerm ) { final int idxTermOffset = indexedTerm . offset ; final int priorTermOffset = priorTerm . offset ; final int limit = Math . min ( priorTerm . length , indexedTerm . length ) ; for ( int byteIdx = _NUM ; byteIdx < limit ; byteIdx ++ ) { if ( priorTerm . bytes [ priorTermOffset + byteIdx ] != indexedTerm . bytes [ idxTermOffset + byteIdx ] ) { return byteIdx + _NUM ; } } return Math . min ( _NUM + priorTerm . length , indexedTerm . length ) ; }
protected int indexedTermPrefixLength ( final BytesRef priorTerm , final BytesRef indexedTerm ) { final int idxTermOffset = indexedTerm . offset ; final int priorTermOffset = priorTerm . offset ; final int limit = Math . min ( priorTerm . length , indexedTerm . length ) ; for ( int byteIdx = _NUM ; byteIdx < limit ; byteIdx ++ ) { if ( priorTerm . bytes [ priorTermOffset + byteIdx ] != indexedTerm . bytes [ idxTermOffset + byteIdx ] ) { return byteIdx + _NUM ; } } return Math . min ( _NUM + priorTerm . length , indexedTerm . length ) ; }
@ Override public void run ( ) { try { audioLine . open ( ) ; audioLine . start ( ) ; audioLine . flush ( ) ; AudioFormat format = audioLine . getFormat ( ) ; byte [ ] buffer = new byte [ _NUM ] ; while ( audioLine . isOpen ( ) ) { boolean systemTurnBeforeRead = outputSpeech != null ; int numBytesRead = audioLine . read ( buffer , _NUM , buffer . length ) ; if ( systemTurnBeforeRead && outputSpeech == null ) { audioLine . drain ( ) ; continue ; } else if ( outputSpeech != null || numBytesRead == _NUM || ( ! voiceActivityDetection && inputSpeech == null ) ) { if ( speechPanel != null ) { speechPanel . clearVolume ( ) ; } continue ; } double rms = AudioUtils . getRMS ( buffer , format ) ; currentVolume = ( currentVolume + rms ) / _NUM ; if ( rms < backgroundVolume ) { backgroundVolume = rms ; } else { backgroundVolume += ( rms - backgroundVolume ) * _NUM ; } if ( speechPanel != null ) { speechPanel . updateVolume ( ( int ) currentVolume ) ; } double difference = currentVolume - backgroundVolume ; if ( voiceActivityDetection && inputSpeech == null && difference > VOLUME_THRESHOLD ) { startRecording ( ) ; } if ( inputSpeech != null && ! inputSpeech . isFinal ( ) ) { inputSpeech . write ( buffer ) ; if ( voiceActivityDetection && difference < VOLUME_THRESHOLD / _NUM ) { stopRecording ( ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
@ Override public void run ( ) { try { audioLine . open ( ) ; audioLine . start ( ) ; audioLine . flush ( ) ; AudioFormat format = audioLine . getFormat ( ) ; byte [ ] buffer = new byte [ _NUM ] ; while ( audioLine . isOpen ( ) ) { boolean systemTurnBeforeRead = outputSpeech != null ; int numBytesRead = audioLine . read ( buffer , _NUM , buffer . length ) ; if ( systemTurnBeforeRead && outputSpeech == null ) { audioLine . drain ( ) ; continue ; } else if ( outputSpeech != null || numBytesRead == _NUM || ( ! voiceActivityDetection && inputSpeech == null ) ) { if ( speechPanel != null ) { speechPanel . clearVolume ( ) ; } continue ; } double rms = AudioUtils . getRMS ( buffer , format ) ; currentVolume = ( currentVolume + rms ) / _NUM ; if ( rms < backgroundVolume ) { backgroundVolume = rms ; } else { backgroundVolume += ( rms - backgroundVolume ) * _NUM ; } if ( speechPanel != null ) { speechPanel . updateVolume ( ( int ) currentVolume ) ; } double difference = currentVolume - backgroundVolume ; if ( voiceActivityDetection && inputSpeech == null && difference > VOLUME_THRESHOLD ) { startRecording ( ) ; } if ( inputSpeech != null && ! inputSpeech . isFinal ( ) ) { inputSpeech . write ( buffer ) ; if ( voiceActivityDetection && difference < VOLUME_THRESHOLD / _NUM ) { stopRecording ( ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
@ Override public void writeJSONString ( Writer out ) throws IOException { writeJSONString ( this , out ) ; }
@ Override public void writeJSONString ( Writer out ) throws IOException { writeJSONString ( this , out ) ; }
static public ResourceState replicatorStateToResourceState ( String state ) { if ( state . startsWith ( REPLICATOR_STATE_ONLINE ) ) return ResourceState . ONLINE ; else if ( state . startsWith ( REPLICATOR_STATE_STOPPED ) ) { return ResourceState . STOPPED ; } else if ( state . startsWith ( REPLICATOR_STATE_OFFLINE ) ) { if ( state . equals ( REPLICATOR_STATE_ERROR ) ) { return ResourceState . SUSPECT ; } else if ( state . equals ( REPLICATOR_STATE_BACKUP ) ) { return ResourceState . BACKUP ; } else if ( state . equals ( REPLICATOR_STATE_RESTORING ) ) { return ResourceState . RESTORING ; } else { return ResourceState . OFFLINE ; } } else if ( state . contains ( REPLICATOR_STATE_SYNCHRONIZING ) ) return ResourceState . SYNCHRONIZING ; else return ResourceState . UNKNOWN ; }
static public ResourceState replicatorStateToResourceState ( String state ) { if ( state . startsWith ( REPLICATOR_STATE_ONLINE ) ) return ResourceState . ONLINE ; else if ( state . startsWith ( REPLICATOR_STATE_STOPPED ) ) { return ResourceState . STOPPED ; } else if ( state . startsWith ( REPLICATOR_STATE_OFFLINE ) ) { if ( state . equals ( REPLICATOR_STATE_ERROR ) ) { return ResourceState . SUSPECT ; } else if ( state . equals ( REPLICATOR_STATE_BACKUP ) ) { return ResourceState . BACKUP ; } else if ( state . equals ( REPLICATOR_STATE_RESTORING ) ) { return ResourceState . RESTORING ; } else { return ResourceState . OFFLINE ; } } else if ( state . contains ( REPLICATOR_STATE_SYNCHRONIZING ) ) return ResourceState . SYNCHRONIZING ; else return ResourceState . UNKNOWN ; }
@ GET @ Path ( STRING ) @ Produces ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ CheckPermission ( roles = { Role . SECURITY_ADMIN } ) public OSTenantListRestRep listCoprhdOsTenants ( ) { _log . debug ( STRING ) ; List < OSTenant > tenants = getOsTenantsFromCoprhdDb ( ) ; return map ( tenants ) ; }
public static < R , A , B > CompletionStage < R > combine ( CompletionStage < A > a , CompletionStage < B > b , BiFunction < A , B , R > function ) { return a . thenCombine ( b , function ) ; }
public ClassNode transform ( ) { processFields ( ) ; processMethods ( ) ; clearIntermediateResults ( ) ; if ( className . equals ( Properties . TARGET_CLASS ) || className . startsWith ( Properties . TARGET_CLASS + STRING ) ) TransformationStatistics . writeStatistics ( className ) ; return cn ; }
abstract boolean containsKey ( T container , String key ) ;
abstract boolean containsKey ( T container , String key ) ;
abstract boolean containsKey ( T container , String key ) ;
abstract boolean containsKey ( T container , String key ) ;
protected void addOptions ( Map < String , String > moreopts ) { Map < String , String > activeOpts = new HashMap < String , String > ( getOptions ( ) ) ; activeOpts . putAll ( moreopts ) ; activeOptions = Collections . unmodifiableMap ( activeOpts ) ; }
protected void addOptions ( Map < String , String > moreopts ) { Map < String , String > activeOpts = new HashMap < String , String > ( getOptions ( ) ) ; activeOpts . putAll ( moreopts ) ; activeOptions = Collections . unmodifiableMap ( activeOpts ) ; }
protected void addOptions ( Map < String , String > moreopts ) { Map < String , String > activeOpts = new HashMap < String , String > ( getOptions ( ) ) ; activeOpts . putAll ( moreopts ) ; activeOptions = Collections . unmodifiableMap ( activeOpts ) ; }
protected void addOptions ( Map < String , String > moreopts ) { Map < String , String > activeOpts = new HashMap < String , String > ( getOptions ( ) ) ; activeOpts . putAll ( moreopts ) ; activeOptions = Collections . unmodifiableMap ( activeOpts ) ; }
public void paint ( Graphics g ) { g . setColor ( Color . white ) ; g . fillRect ( _NUM , _NUM , getWidth ( ) , getHeight ( ) ) ; g . setColor ( Color . BLACK ) ; for ( int stripeX = _NUM ; stripeX < getWidth ( ) ; stripeX += CHECKER_SIZE ) { for ( int y = _NUM , row = _NUM ; y < getHeight ( ) ; y += CHECKER_SIZE / _NUM , ++ row ) { int x = ( row % _NUM == _NUM ) ? stripeX : ( stripeX + CHECKER_SIZE / _NUM ) ; g . fillRect ( x , y , CHECKER_SIZE / _NUM , CHECKER_SIZE / _NUM ) ; } } g . translate ( _NUM , translateY ) ; super . paint ( g ) ; }
public void paint ( Graphics g ) { g . setColor ( Color . white ) ; g . fillRect ( _NUM , _NUM , getWidth ( ) , getHeight ( ) ) ; g . setColor ( Color . BLACK ) ; for ( int stripeX = _NUM ; stripeX < getWidth ( ) ; stripeX += CHECKER_SIZE ) { for ( int y = _NUM , row = _NUM ; y < getHeight ( ) ; y += CHECKER_SIZE / _NUM , ++ row ) { int x = ( row % _NUM == _NUM ) ? stripeX : ( stripeX + CHECKER_SIZE / _NUM ) ; g . fillRect ( x , y , CHECKER_SIZE / _NUM , CHECKER_SIZE / _NUM ) ; } } g . translate ( _NUM , translateY ) ; super . paint ( g ) ; }
public ServiceHost startFactory ( Supplier < FactoryService > factoryCreator , String servicePath ) { Operation post = Operation . createPost ( UriUtils . buildUri ( this , servicePath ) ) ; FactoryService factoryService = factoryCreator . get ( ) ; return startService ( post , factoryService ) ; }
public ServiceHost startFactory ( Supplier < FactoryService > factoryCreator , String servicePath ) { Operation post = Operation . createPost ( UriUtils . buildUri ( this , servicePath ) ) ; FactoryService factoryService = factoryCreator . get ( ) ; return startService ( post , factoryService ) ; }
public ServiceHost startFactory ( Supplier < FactoryService > factoryCreator , String servicePath ) { Operation post = Operation . createPost ( UriUtils . buildUri ( this , servicePath ) ) ; FactoryService factoryService = factoryCreator . get ( ) ; return startService ( post , factoryService ) ; }
public ServiceHost startFactory ( Supplier < FactoryService > factoryCreator , String servicePath ) { Operation post = Operation . createPost ( UriUtils . buildUri ( this , servicePath ) ) ; FactoryService factoryService = factoryCreator . get ( ) ; return startService ( post , factoryService ) ; }
void writeBytes ( ChannelHandlerContext ctx , ByteBuf bytes ) ;
void writeBytes ( ChannelHandlerContext ctx , ByteBuf bytes ) ;
void writeBytes ( ChannelHandlerContext ctx , ByteBuf bytes ) ;
void writeBytes ( ChannelHandlerContext ctx , ByteBuf bytes ) ;
public boolean waitUntilEmpty ( long timeout ) throws InterruptedException { if ( ! notifyLock . tryLock ( timeout , TimeUnit . MILLISECONDS ) ) { return _BOOL ; } try { return pending . isEmpty ( ) || notifyCondition . await ( timeout , TimeUnit . MILLISECONDS ) ; } finally { notifyLock . unlock ( ) ; } }
public static void report ( ) { if ( License . isDeveloper ( ) ) { for ( final Object obj : SPIES ) { Diagnostic . developerLog ( obj . toString ( ) ) ; } } }
private void addInternalListeners ( ) { cbDistribution . addItemListener ( cbItemListener ) ; }
private void addInternalListeners ( ) { cbDistribution . addItemListener ( cbItemListener ) ; }
private void updatePropertyToValue2 ( ) throws Exception { properties . put ( TEST_KEY , TEST_VALUE_2 ) ; updatePropertiesFile ( ) ; }
protected StringBuffer parseString ( StringBuffer sbuf ) throws IOException { int ch ; while ( ( ch = readChar ( ) ) >= _NUM ) sbuf . append ( ( char ) ch ) ; return sbuf ; }
public TextEditor replaceAll ( Pattern pattern , Replacement replacement ) { Matcher m = pattern . matcher ( text ) ; int lastIndex = _NUM ; StringBuffer sb = new StringBuffer ( ) ; while ( m . find ( ) ) { sb . append ( text . subSequence ( lastIndex , m . start ( ) ) ) ; sb . append ( replacement . replacement ( m ) ) ; lastIndex = m . end ( ) ; } sb . append ( text . subSequence ( lastIndex , text . length ( ) ) ) ; text = sb ; return this ; }
public TextEditor replaceAll ( Pattern pattern , Replacement replacement ) { Matcher m = pattern . matcher ( text ) ; int lastIndex = _NUM ; StringBuffer sb = new StringBuffer ( ) ; while ( m . find ( ) ) { sb . append ( text . subSequence ( lastIndex , m . start ( ) ) ) ; sb . append ( replacement . replacement ( m ) ) ; lastIndex = m . end ( ) ; } sb . append ( text . subSequence ( lastIndex , text . length ( ) ) ) ; text = sb ; return this ; }
public TextEditor replaceAll ( Pattern pattern , Replacement replacement ) { Matcher m = pattern . matcher ( text ) ; int lastIndex = _NUM ; StringBuffer sb = new StringBuffer ( ) ; while ( m . find ( ) ) { sb . append ( text . subSequence ( lastIndex , m . start ( ) ) ) ; sb . append ( replacement . replacement ( m ) ) ; lastIndex = m . end ( ) ; } sb . append ( text . subSequence ( lastIndex , text . length ( ) ) ) ; text = sb ; return this ; }
public TextEditor replaceAll ( Pattern pattern , Replacement replacement ) { Matcher m = pattern . matcher ( text ) ; int lastIndex = _NUM ; StringBuffer sb = new StringBuffer ( ) ; while ( m . find ( ) ) { sb . append ( text . subSequence ( lastIndex , m . start ( ) ) ) ; sb . append ( replacement . replacement ( m ) ) ; lastIndex = m . end ( ) ; } sb . append ( text . subSequence ( lastIndex , text . length ( ) ) ) ; text = sb ; return this ; }
public Set < String > addContent ( String variable , double value ) { if ( ! paused ) { curState . addToState ( new Assignment ( variable , value ) ) ; return update ( ) ; } else { log . info ( STRING + variable + STRING + value ) ; return Collections . emptySet ( ) ; } }
public Set < String > addContent ( String variable , double value ) { if ( ! paused ) { curState . addToState ( new Assignment ( variable , value ) ) ; return update ( ) ; } else { log . info ( STRING + variable + STRING + value ) ; return Collections . emptySet ( ) ; } }
public Set < String > addContent ( String variable , double value ) { if ( ! paused ) { curState . addToState ( new Assignment ( variable , value ) ) ; return update ( ) ; } else { log . info ( STRING + variable + STRING + value ) ; return Collections . emptySet ( ) ; } }
private void createInputList ( ) { inputList . clear ( ) ; List < CmrRepositoryDefinition > repositories = cmrRepositoryManager . getCmrRepositoryDefinitions ( ) ; for ( CmrRepositoryDefinition cmrRepositoryDefinition : repositories ) { inputList . add ( new DeferredAgentsComposite ( cmrRepositoryDefinition , showOldAgents ) ) ; OnlineStatus onlineStatus = cmrRepositoryDefinition . getOnlineStatus ( ) ; if ( ( onlineStatus == OnlineStatus . ONLINE ) || ( onlineStatus == OnlineStatus . OFFLINE ) ) { cachedStatusMap . put ( cmrRepositoryDefinition , onlineStatus ) ; } } }
public static String toString ( final byte [ ] bytes ) { StringBuilder hexed = new StringBuilder ( ) ; for ( int i = _NUM ; i < bytes . length ; i ++ ) { hexed . append ( toString ( bytes [ i ] ) ) ; hexed . append ( STRING ) ; } return hexed . substring ( _NUM , hexed . length ( ) - _NUM ) ; }
public IssuerAlternativeNameExtension ( Boolean critical , Object value ) throws IOException { this . extensionId = PKIXExtensions . IssuerAlternativeName_Id ; this . critical = critical . booleanValue ( ) ; this . extensionValue = ( byte [ ] ) value ; DerValue val = new DerValue ( this . extensionValue ) ; if ( val . data == null ) { names = new GeneralNames ( ) ; return ; } names = new GeneralNames ( val ) ; }
protected < T extends AbstractOptionValue < ? , ? > > AbstractOptions ( Function < T , T > valueFilter , AbstractOptions baseOptions , Iterable < T > values ) { requireNonNull ( baseOptions , STRING ) ; requireNonNull ( valueFilter , STRING ) ; requireNonNull ( values , STRING ) ; valueMap = new IdentityHashMap < > ( baseOptions . valueMap ) ; putAll ( valueFilter , StreamSupport . stream ( values . spliterator ( ) , _BOOL ) ) ; }
public default UtilityTable queryUtil ( BNetwork network , String queryVar , Assignment evidence ) { return queryUtil ( new Query . UtilQuery ( network , Arrays . asList ( queryVar ) , evidence ) ) ; }
public CreateCustomMetric ( Monitoring monitoringService , String projectResource ) { this . monitoringService = monitoringService ; this . projectResource = projectResource ; this . metricType = CUSTOM_METRIC_DOMAIN + STRING + DEFAULT_METRIC_TYPE ; this . metricName = projectResource + STRING + metricType ; }
public void init ( MyPerfContext ctx ) { logger . info ( STRING ) ; configured = _BOOL ; File cfgFile = null ; myperfConfigPath = System . getProperty ( MYPERF_CONFIG_PATH_PROP_NAME ) ; if ( myperfConfigPath == null || myperfConfigPath . isEmpty ( ) ) { File cfgDir = new File ( new File ( ROOTPATH ) , STORAGE_DIR ) ; if ( ! cfgDir . exists ( ) ) cfgDir . mkdirs ( ) ; cfgFile = new File ( cfgDir , MYPERF_CONFIG_FILE_NAME ) ; myperfConfigPath = cfgFile . getAbsolutePath ( ) ; } else cfgFile = new File ( myperfConfigPath ) ; if ( ! cfgFile . exists ( ) ) { logger . info ( STRING + cfgFile . getAbsolutePath ( ) + STRING ) ; return ; } logger . info ( STRING + cfgFile . getAbsolutePath ( ) ) ; if ( readConfig ( cfgFile , ctx ) ) { configured = _BOOL ; } logger . info ( STRING + cfgFile . getAbsolutePath ( ) + STRING + configured ) ; }
public static ResourceGroupState createDefaultResourceGroup ( VerificationHost host , String projectId ) throws Throwable { ResourceGroupState resourceGroup = new ResourceGroupState ( ) ; resourceGroup . name = projectId ; return TestUtils . doPost ( host , resourceGroup , ResourceGroupState . class , UriUtils . buildUri ( host , ResourceGroupService . FACTORY_LINK ) ) ; }
public Object put ( String key , Object value ) { Object oldValue = context . getAttribute ( key , ENGINE_SCOPE ) ; context . setAttribute ( key , value , ENGINE_SCOPE ) ; return oldValue ; }
private static boolean isGnome ( ) { return System . getenv ( STRING ) != null ; }
private static boolean isGnome ( ) { return System . getenv ( STRING ) != null ; }
public boolean isRemoveUnsupportedEncodings ( ) { return removeUnsupportedEncodings ; }
public void restoreTopology ( Iterable < TcpDiscoveryNode > nodes , long topVer ) { assert ! F . isEmpty ( nodes ) ; assert topVer > _NUM ; rwLock . writeLock ( ) . lock ( ) ; try { locNode . internalOrder ( topVer ) ; clear ( ) ; boolean firstAdd = _BOOL ; for ( TcpDiscoveryNode node : nodes ) { if ( nodesMap . containsKey ( node . id ( ) ) ) continue ; nodesMap . put ( node . id ( ) , node ) ; if ( firstAdd ) { this . nodes = new TreeSet < > ( this . nodes ) ; firstAdd = _BOOL ; } node . lastUpdateTime ( U . currentTimeMillis ( ) ) ; this . nodes . add ( node ) ; } nodeOrder = topVer ; initializeMinimumVersion ( ) ; } finally { rwLock . writeLock ( ) . unlock ( ) ; } }
public void restoreTopology ( Iterable < TcpDiscoveryNode > nodes , long topVer ) { assert ! F . isEmpty ( nodes ) ; assert topVer > _NUM ; rwLock . writeLock ( ) . lock ( ) ; try { locNode . internalOrder ( topVer ) ; clear ( ) ; boolean firstAdd = _BOOL ; for ( TcpDiscoveryNode node : nodes ) { if ( nodesMap . containsKey ( node . id ( ) ) ) continue ; nodesMap . put ( node . id ( ) , node ) ; if ( firstAdd ) { this . nodes = new TreeSet < > ( this . nodes ) ; firstAdd = _BOOL ; } node . lastUpdateTime ( U . currentTimeMillis ( ) ) ; this . nodes . add ( node ) ; } nodeOrder = topVer ; initializeMinimumVersion ( ) ; } finally { rwLock . writeLock ( ) . unlock ( ) ; } }
public void restoreTopology ( Iterable < TcpDiscoveryNode > nodes , long topVer ) { assert ! F . isEmpty ( nodes ) ; assert topVer > _NUM ; rwLock . writeLock ( ) . lock ( ) ; try { locNode . internalOrder ( topVer ) ; clear ( ) ; boolean firstAdd = _BOOL ; for ( TcpDiscoveryNode node : nodes ) { if ( nodesMap . containsKey ( node . id ( ) ) ) continue ; nodesMap . put ( node . id ( ) , node ) ; if ( firstAdd ) { this . nodes = new TreeSet < > ( this . nodes ) ; firstAdd = _BOOL ; } node . lastUpdateTime ( U . currentTimeMillis ( ) ) ; this . nodes . add ( node ) ; } nodeOrder = topVer ; initializeMinimumVersion ( ) ; } finally { rwLock . writeLock ( ) . unlock ( ) ; } }
public void restoreTopology ( Iterable < TcpDiscoveryNode > nodes , long topVer ) { assert ! F . isEmpty ( nodes ) ; assert topVer > _NUM ; rwLock . writeLock ( ) . lock ( ) ; try { locNode . internalOrder ( topVer ) ; clear ( ) ; boolean firstAdd = _BOOL ; for ( TcpDiscoveryNode node : nodes ) { if ( nodesMap . containsKey ( node . id ( ) ) ) continue ; nodesMap . put ( node . id ( ) , node ) ; if ( firstAdd ) { this . nodes = new TreeSet < > ( this . nodes ) ; firstAdd = _BOOL ; } node . lastUpdateTime ( U . currentTimeMillis ( ) ) ; this . nodes . add ( node ) ; } nodeOrder = topVer ; initializeMinimumVersion ( ) ; } finally { rwLock . writeLock ( ) . unlock ( ) ; } }
public EncryptedEditor putLong ( String key , long value ) { putValue ( key , String . valueOf ( value ) ) ; return this ; }
public void await ( ) throws InterruptedException { awaitSemaphore . acquire ( ) ; awaitSemaphore . release ( ) ; }
public int available ( ) throws IOException { int bytesAvailable = in . available ( ) ; if ( bytesAvailable > bytesLeft ) bytesAvailable = bytesLeft ; return bytesAvailable ; }
public int available ( ) throws IOException { int bytesAvailable = in . available ( ) ; if ( bytesAvailable > bytesLeft ) bytesAvailable = bytesLeft ; return bytesAvailable ; }
public int available ( ) throws IOException { int bytesAvailable = in . available ( ) ; if ( bytesAvailable > bytesLeft ) bytesAvailable = bytesLeft ; return bytesAvailable ; }
public int available ( ) throws IOException { int bytesAvailable = in . available ( ) ; if ( bytesAvailable > bytesLeft ) bytesAvailable = bytesLeft ; return bytesAvailable ; }
public int available ( ) throws IOException { int bytesAvailable = in . available ( ) ; if ( bytesAvailable > bytesLeft ) bytesAvailable = bytesLeft ; return bytesAvailable ; }
public int available ( ) throws IOException { int bytesAvailable = in . available ( ) ; if ( bytesAvailable > bytesLeft ) bytesAvailable = bytesLeft ; return bytesAvailable ; }
public int available ( ) throws IOException { int bytesAvailable = in . available ( ) ; if ( bytesAvailable > bytesLeft ) bytesAvailable = bytesLeft ; return bytesAvailable ; }
@ Override public final void readFully ( byte ba [ ] ) throws IOException { dis . readFully ( ba , _NUM , ba . length ) ; }
public int read ( ) throws IOException { return _is . read ( ) ; }
private static double distanceSq ( Color a , Color b ) { double rMean = ( a . getRed ( ) + b . getRed ( ) ) / _NUM / _NUM ; double dr = ( a . getRed ( ) - b . getRed ( ) ) / _NUM ; double dg = ( a . getGreen ( ) - b . getGreen ( ) ) / _NUM ; double db = ( a . getBlue ( ) - b . getBlue ( ) ) / _NUM ; double d = ( _NUM + rMean ) * dr * dr + _NUM * dg * dg + ( _NUM + _NUM - rMean ) * db * db ; return d / _NUM ; }
public Iterator < DetectorFactory > iterator ( ) { return orderedFactoryList . iterator ( ) ; }
public Iterator < DetectorFactory > iterator ( ) { return orderedFactoryList . iterator ( ) ; }
public void testManyConnectionsUsingManyThreads ( ) { int numTasks = getConnectionNum ( ) ; ThreadPool threadPool = new ThreadPool ( numTasks ) ; for ( int i = _NUM ; i < numTasks ; i ++ ) { threadPool . runTask ( createTask ( i ) ) ; } threadPool . join ( ) ; assertEquals ( STRING , numTasks , vc . size ( ) ) ; if ( numTasks != Support_SQL . sqlMaxConnections ) { try { Connection c = Support_SQL . getConnection ( ) ; c . close ( ) ; fail ( STRING + numTasks + STRING ) ; } catch ( SQLException sql ) { } } }
public String basicTypeNameBoxed ( Field field ) { return javaCommon . boxedTypeName ( basicTypeName ( field ) ) ; }
public String basicTypeNameBoxed ( Field field ) { return javaCommon . boxedTypeName ( basicTypeName ( field ) ) ; }
public static int hash ( double [ ] value ) { return Arrays . hashCode ( value ) ; }
public static int hash ( double [ ] value ) { return Arrays . hashCode ( value ) ; }
private char readEscapeCharacter ( ) throws IOException { if ( pos == limit && ! fillBuffer ( _NUM ) ) { throw syntaxError ( STRING ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case STRING : if ( pos + _NUM > limit && ! fillBuffer ( _NUM ) ) { throw syntaxError ( STRING ) ; } String hex = stringPool . get ( buffer , pos , _NUM ) ; pos += _NUM ; return ( char ) Integer . parseInt ( hex , _NUM ) ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private char readEscapeCharacter ( ) throws IOException { if ( pos == limit && ! fillBuffer ( _NUM ) ) { throw syntaxError ( STRING ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case STRING : if ( pos + _NUM > limit && ! fillBuffer ( _NUM ) ) { throw syntaxError ( STRING ) ; } String hex = stringPool . get ( buffer , pos , _NUM ) ; pos += _NUM ; return ( char ) Integer . parseInt ( hex , _NUM ) ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private char readEscapeCharacter ( ) throws IOException { if ( pos == limit && ! fillBuffer ( _NUM ) ) { throw syntaxError ( STRING ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case STRING : if ( pos + _NUM > limit && ! fillBuffer ( _NUM ) ) { throw syntaxError ( STRING ) ; } String hex = stringPool . get ( buffer , pos , _NUM ) ; pos += _NUM ; return ( char ) Integer . parseInt ( hex , _NUM ) ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private char readEscapeCharacter ( ) throws IOException { if ( pos == limit && ! fillBuffer ( _NUM ) ) { throw syntaxError ( STRING ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case STRING : if ( pos + _NUM > limit && ! fillBuffer ( _NUM ) ) { throw syntaxError ( STRING ) ; } String hex = stringPool . get ( buffer , pos , _NUM ) ; pos += _NUM ; return ( char ) Integer . parseInt ( hex , _NUM ) ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private char readEscapeCharacter ( ) throws IOException { if ( pos == limit && ! fillBuffer ( _NUM ) ) { throw syntaxError ( STRING ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case STRING : if ( pos + _NUM > limit && ! fillBuffer ( _NUM ) ) { throw syntaxError ( STRING ) ; } String hex = stringPool . get ( buffer , pos , _NUM ) ; pos += _NUM ; return ( char ) Integer . parseInt ( hex , _NUM ) ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private String stripCodeValueSentences ( String string ) { return string . replaceAll ( STRING , STRING ) ; }
private void map ( Collection < KeyCacheObject > keys , boolean remap , boolean topLocked ) { try { map0 ( keys , remap , topLocked ) ; } catch ( IgniteCheckedException ex ) { onDone ( _BOOL , ex ) ; } }
private void map ( Collection < KeyCacheObject > keys , boolean remap , boolean topLocked ) { try { map0 ( keys , remap , topLocked ) ; } catch ( IgniteCheckedException ex ) { onDone ( _BOOL , ex ) ; } }
private void map ( Collection < KeyCacheObject > keys , boolean remap , boolean topLocked ) { try { map0 ( keys , remap , topLocked ) ; } catch ( IgniteCheckedException ex ) { onDone ( _BOOL , ex ) ; } }
private void map ( Collection < KeyCacheObject > keys , boolean remap , boolean topLocked ) { try { map0 ( keys , remap , topLocked ) ; } catch ( IgniteCheckedException ex ) { onDone ( _BOOL , ex ) ; } }
private void map ( Collection < KeyCacheObject > keys , boolean remap , boolean topLocked ) { try { map0 ( keys , remap , topLocked ) ; } catch ( IgniteCheckedException ex ) { onDone ( _BOOL , ex ) ; } }
public static byte randomByte ( int max ) { return ( byte ) random . nextInt ( max + _NUM ) ; }
protected boolean strictParseBoolean ( String s ) { if ( s == null || s . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( s . equalsIgnoreCase ( STRING ) ) { return _BOOL ; } if ( s . equalsIgnoreCase ( STRING ) ) { return _BOOL ; } throw new IllegalArgumentException ( STRING + s ) ; }
protected boolean strictParseBoolean ( String s ) { if ( s == null || s . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( s . equalsIgnoreCase ( STRING ) ) { return _BOOL ; } if ( s . equalsIgnoreCase ( STRING ) ) { return _BOOL ; } throw new IllegalArgumentException ( STRING + s ) ; }
protected boolean strictParseBoolean ( String s ) { if ( s == null || s . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( s . equalsIgnoreCase ( STRING ) ) { return _BOOL ; } if ( s . equalsIgnoreCase ( STRING ) ) { return _BOOL ; } throw new IllegalArgumentException ( STRING + s ) ; }
protected boolean strictParseBoolean ( String s ) { if ( s == null || s . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( s . equalsIgnoreCase ( STRING ) ) { return _BOOL ; } if ( s . equalsIgnoreCase ( STRING ) ) { return _BOOL ; } throw new IllegalArgumentException ( STRING + s ) ; }
protected boolean strictParseBoolean ( String s ) { if ( s == null || s . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( s . equalsIgnoreCase ( STRING ) ) { return _BOOL ; } if ( s . equalsIgnoreCase ( STRING ) ) { return _BOOL ; } throw new IllegalArgumentException ( STRING + s ) ; }
private void step ( ) { casings . forEach ( null ) ; casings . forEach ( null ) ; casings . forEach ( null ) ; stepPipes ( ) ; stepForwarders ( ) ; }
public static Element addChildElementNSElement ( Element element , String childElementName , Document document , String nameSpaceUrl ) { Element newElement = document . createElementNS ( nameSpaceUrl , childElementName ) ; element . appendChild ( newElement ) ; return element ; }
public static Element addChildElementNSElement ( Element element , String childElementName , Document document , String nameSpaceUrl ) { Element newElement = document . createElementNS ( nameSpaceUrl , childElementName ) ; element . appendChild ( newElement ) ; return element ; }
public boolean deleteRoadName ( String road ) { if ( ! _roadList . contains ( road ) ) { return _BOOL ; } _roadList . remove ( road ) ; log . debug ( STRING + getName ( ) + STRING + road ) ; setDirtyAndFirePropertyChange ( ROADS_CHANGED_PROPERTY , _roadList . size ( ) + _NUM , _roadList . size ( ) ) ; return _BOOL ; }
public void retrieveFile ( String path , OutputStream os , int limit ) throws IOException , FtpExceptionCanNotHaveDataConnection , FtpExceptionUnknownForcedDataClose , FtpExceptionControlClosedByForcedDataClose { Socket socket = __openPassiveDataConnection ( FTPCommand . RETR , path ) ; if ( socket == null ) throw new FtpExceptionCanNotHaveDataConnection ( STRING + ( ( path == null ) ? STRING : path ) ) ; InputStream input = socket . getInputStream ( ) ; int len ; int count = _NUM ; byte [ ] buf = new byte [ org . apache . commons . net . io . Util . DEFAULT_COPY_BUFFER_SIZE ] ; while ( ( len = input . read ( buf , _NUM , buf . length ) ) != - _NUM ) { count += len ; if ( limit >= _NUM && count > limit ) { os . write ( buf , _NUM , len - ( count - limit ) ) ; break ; } os . write ( buf , _NUM , len ) ; os . flush ( ) ; } socket . close ( ) ; try { int reply = getReply ( ) ; if ( ! _notBadReply ( reply ) ) throw new FtpExceptionUnknownForcedDataClose ( getReplyString ( ) ) ; } catch ( FTPConnectionClosedException e ) { throw new FtpExceptionControlClosedByForcedDataClose ( e . getMessage ( ) ) ; } }
public AbstractDdlBuilder ( String databaseName ) { this . databaseName = databaseName ; addEscapedCharSequence ( STRING , STRING ) ; }
private Map < PluginUtil . CheckerProp , Object > makeProps ( ) { final String sourcePath = StringUtils . join ( compileSourceRoots . iterator ( ) , File . pathSeparator ) ; final List < String > miscOptions = new ArrayList < String > ( ) ; miscOptions . add ( STRING ) ; miscOptions . add ( sourcePath ) ; if ( ! StringUtils . isEmpty ( javaParams ) ) { miscOptions . addAll ( PluginUtil . toJavaOpts ( Arrays . asList ( javaParams . split ( STRING ) ) ) ) ; } if ( ! StringUtils . isEmpty ( javacParams ) ) { miscOptions . addAll ( Arrays . asList ( javacParams . split ( STRING ) ) ) ; } final Map < PluginUtil . CheckerProp , Object > props = new HashMap < PluginUtil . CheckerProp , Object > ( ) ; props . put ( PluginUtil . CheckerProp . MISC_COMPILER , miscOptions ) ; return props ; }
private Map < PluginUtil . CheckerProp , Object > makeProps ( ) { final String sourcePath = StringUtils . join ( compileSourceRoots . iterator ( ) , File . pathSeparator ) ; final List < String > miscOptions = new ArrayList < String > ( ) ; miscOptions . add ( STRING ) ; miscOptions . add ( sourcePath ) ; if ( ! StringUtils . isEmpty ( javaParams ) ) { miscOptions . addAll ( PluginUtil . toJavaOpts ( Arrays . asList ( javaParams . split ( STRING ) ) ) ) ; } if ( ! StringUtils . isEmpty ( javacParams ) ) { miscOptions . addAll ( Arrays . asList ( javacParams . split ( STRING ) ) ) ; } final Map < PluginUtil . CheckerProp , Object > props = new HashMap < PluginUtil . CheckerProp , Object > ( ) ; props . put ( PluginUtil . CheckerProp . MISC_COMPILER , miscOptions ) ; return props ; }
private Map < PluginUtil . CheckerProp , Object > makeProps ( ) { final String sourcePath = StringUtils . join ( compileSourceRoots . iterator ( ) , File . pathSeparator ) ; final List < String > miscOptions = new ArrayList < String > ( ) ; miscOptions . add ( STRING ) ; miscOptions . add ( sourcePath ) ; if ( ! StringUtils . isEmpty ( javaParams ) ) { miscOptions . addAll ( PluginUtil . toJavaOpts ( Arrays . asList ( javaParams . split ( STRING ) ) ) ) ; } if ( ! StringUtils . isEmpty ( javacParams ) ) { miscOptions . addAll ( Arrays . asList ( javacParams . split ( STRING ) ) ) ; } final Map < PluginUtil . CheckerProp , Object > props = new HashMap < PluginUtil . CheckerProp , Object > ( ) ; props . put ( PluginUtil . CheckerProp . MISC_COMPILER , miscOptions ) ; return props ; }
public void close ( ) throws java . io . IOException { internal . close ( ) ; cbufferOff = - _NUM ; }
public void close ( ) throws java . io . IOException { internal . close ( ) ; cbufferOff = - _NUM ; }
public void close ( ) throws java . io . IOException { internal . close ( ) ; cbufferOff = - _NUM ; }
public static void UF10 ( double [ ] x , double [ ] f , int nx ) { int count1 = _NUM ; int count2 = _NUM ; int count3 = _NUM ; double sum1 = _NUM ; double sum2 = _NUM ; double sum3 = _NUM ; double yj ; double hj ; for ( int j = _NUM ; j <= nx ; j ++ ) { yj = x [ j - _NUM ] - _NUM * x [ _NUM ] * Math . sin ( _NUM * PI * x [ _NUM ] + j * PI / nx ) ; hj = _NUM * yj * yj - Math . cos ( _NUM * PI * yj ) + _NUM ; if ( j % _NUM == _NUM ) { sum1 += hj ; count1 ++ ; } else if ( j % _NUM == _NUM ) { sum2 += hj ; count2 ++ ; } else { sum3 += hj ; count3 ++ ; } } f [ _NUM ] = Math . cos ( _NUM * PI * x [ _NUM ] ) * Math . cos ( _NUM * PI * x [ _NUM ] ) + _NUM * sum1 / ( double ) count1 ; f [ _NUM ] = Math . cos ( _NUM * PI * x [ _NUM ] ) * Math . sin ( _NUM * PI * x [ _NUM ] ) + _NUM * sum2 / ( double ) count2 ; f [ _NUM ] = Math . sin ( _NUM * PI * x [ _NUM ] ) + _NUM * sum3 / ( double ) count3 ; }
public long toSeconds ( ) { return timeUnit . toSeconds ( length ) ; }
protected void handleOrDeferMessage ( DistributionMessage msg ) { synchronized ( startupLock ) { if ( beingSick || playingDead ) { if ( msg . containsRegionContentChange ( ) || msg instanceof PartitionMessageWithDirectReply ) { startupMessages . add ( new StartupEvent ( msg ) ) ; return ; } } if ( ! processingEvents ) { startupMessages . add ( new StartupEvent ( msg ) ) ; return ; } } dispatchMessage ( msg ) ; }
public static List < Long > zScoreTest ( GeoTimeSerie gts , boolean useMedian , double d ) throws WarpScriptException { doubleCheck ( gts ) ; List < Long > anomalous_ticks = new ArrayList < Long > ( ) ; double [ ] musigma = madsigma ( gts , useMedian ) ; double m = musigma [ _NUM ] ; double std = musigma [ _NUM ] ; if ( _NUM == std ) { return anomalous_ticks ; } for ( int i = _NUM ; i < gts . values ; i ++ ) { double z = ( gts . doubleValues [ i ] - m ) / std ; if ( Math . abs ( z ) >= d ) { anomalous_ticks . add ( gts . ticks [ i ] ) ; } } return anomalous_ticks ; }
public static boolean isEmailRegistered ( String email ) { PersistenceManager pm = pmf . getPersistenceManager ( ) ; try { UserRecord user = findUserByEmail ( pm , email ) ; return user != null ; } finally { pm . close ( ) ; } }
public static boolean isEmailRegistered ( String email ) { PersistenceManager pm = pmf . getPersistenceManager ( ) ; try { UserRecord user = findUserByEmail ( pm , email ) ; return user != null ; } finally { pm . close ( ) ; } }
private FileLogAccessor resolveStdoutLogDestination ( String fileName ) { File stdout = new File ( System . getProperty ( STRING ) , STRING + fileName ) ; if ( stdout . exists ( ) ) { FileLogAccessor fla = new FileLogAccessor ( ) ; fla . setName ( fileName ) ; fla . setFile ( stdout ) ; return fla ; } return null ; }
private FileLogAccessor resolveStdoutLogDestination ( String fileName ) { File stdout = new File ( System . getProperty ( STRING ) , STRING + fileName ) ; if ( stdout . exists ( ) ) { FileLogAccessor fla = new FileLogAccessor ( ) ; fla . setName ( fileName ) ; fla . setFile ( stdout ) ; return fla ; } return null ; }
public boolean hasLogicalMapping ( String logicalName ) { return logicalToPhysicalColumnNames . containsKey ( logicalName ) ; }
public boolean hasLogicalMapping ( String logicalName ) { return logicalToPhysicalColumnNames . containsKey ( logicalName ) ; }
public void addHoldAndReleaseView ( @ IdRes int holdAndReleaseViewId ) { holdAndReleaseViews . add ( new HoldAndReleaseView ( peekView . findViewById ( holdAndReleaseViewId ) ) ) ; }
public void addHoldAndReleaseView ( @ IdRes int holdAndReleaseViewId ) { holdAndReleaseViews . add ( new HoldAndReleaseView ( peekView . findViewById ( holdAndReleaseViewId ) ) ) ; }
public void addHoldAndReleaseView ( @ IdRes int holdAndReleaseViewId ) { holdAndReleaseViews . add ( new HoldAndReleaseView ( peekView . findViewById ( holdAndReleaseViewId ) ) ) ; }
public void addHoldAndReleaseView ( @ IdRes int holdAndReleaseViewId ) { holdAndReleaseViews . add ( new HoldAndReleaseView ( peekView . findViewById ( holdAndReleaseViewId ) ) ) ; }
public void addHoldAndReleaseView ( @ IdRes int holdAndReleaseViewId ) { holdAndReleaseViews . add ( new HoldAndReleaseView ( peekView . findViewById ( holdAndReleaseViewId ) ) ) ; }
public void addHoldAndReleaseView ( @ IdRes int holdAndReleaseViewId ) { holdAndReleaseViews . add ( new HoldAndReleaseView ( peekView . findViewById ( holdAndReleaseViewId ) ) ) ; }
public boolean importPvk ( ) { return jrbPvk . isSelected ( ) ; }
public Node addNode ( Coordinate coord ) { Node node = ( Node ) nodeMap . get ( coord ) ; if ( node == null ) { node = nodeFact . createNode ( coord ) ; nodeMap . put ( coord , node ) ; } return node ; }
public Node addNode ( Coordinate coord ) { Node node = ( Node ) nodeMap . get ( coord ) ; if ( node == null ) { node = nodeFact . createNode ( coord ) ; nodeMap . put ( coord , node ) ; } return node ; }
public Node addNode ( Coordinate coord ) { Node node = ( Node ) nodeMap . get ( coord ) ; if ( node == null ) { node = nodeFact . createNode ( coord ) ; nodeMap . put ( coord , node ) ; } return node ; }
private void ensureCapacity ( int wordsRequired ) { if ( words . length < wordsRequired ) { int request = Math . max ( _NUM * words . length , wordsRequired ) ; words = Arrays . copyOf ( words , request ) ; sizeIsSticky = _BOOL ; } }
private void ensureCapacity ( int wordsRequired ) { if ( words . length < wordsRequired ) { int request = Math . max ( _NUM * words . length , wordsRequired ) ; words = Arrays . copyOf ( words , request ) ; sizeIsSticky = _BOOL ; } }
protected Logger ( String name , String resourceBundleName ) { super ( name , resourceBundleName ) ; }
protected Logger ( String name , String resourceBundleName ) { super ( name , resourceBundleName ) ; }
protected void sendEndOfHeader ( final OutputStream out ) throws IOException { LOG . trace ( STRING ) ; out . write ( CRLF_BYTES ) ; out . write ( CRLF_BYTES ) ; }
public static int height ( final Segment document , final int maxWidth , final FontRenderer renderer ) { int currentX = _NUM ; int currentY = _NUM ; Segment segment = document ; while ( segment != null ) { currentY += segment . nextY ( currentX , maxWidth , renderer ) ; currentX = segment . nextX ( currentX , maxWidth , renderer ) ; segment = segment . next ( ) ; } return currentY ; }
public static int height ( final Segment document , final int maxWidth , final FontRenderer renderer ) { int currentX = _NUM ; int currentY = _NUM ; Segment segment = document ; while ( segment != null ) { currentY += segment . nextY ( currentX , maxWidth , renderer ) ; currentX = segment . nextX ( currentX , maxWidth , renderer ) ; segment = segment . next ( ) ; } return currentY ; }
private synchronized static Datastore createDatastore ( ) { if ( dataStore == null ) { Morphia m = new Morphia ( ) ; String mongoName = KrakenConfig . getProperty ( STRING ) ; dataStore = m . createDatastore ( getMongo ( mongoName ) , mongoName ) ; m . map ( Customer . class ) ; m . map ( Project . class ) ; m . map ( Attribute . class ) ; m . map ( Dimension . class ) ; m . map ( Domain . class ) ; m . map ( ProjectFacetJob . class ) ; m . map ( Metric . class ) ; m . map ( Client . class ) ; m . map ( User . class ) ; m . map ( UserGroup . class ) ; m . map ( ProjectAnalysisJob . class ) ; m . map ( AccessToken . class ) ; m . map ( Relation . class ) ; m . map ( Annotation . class ) ; m . map ( ProjectUser . class ) ; m . map ( State . class ) ; m . map ( Shortcut . class ) ; try { dataStore . ensureIndexes ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } } return dataStore ; }
public final void addCategory ( String category ) { if ( mCategories == null ) mCategories = new ArrayList < String > ( ) ; if ( ! mCategories . contains ( category ) ) { mCategories . add ( category . intern ( ) ) ; } }
public final void addCategory ( String category ) { if ( mCategories == null ) mCategories = new ArrayList < String > ( ) ; if ( ! mCategories . contains ( category ) ) { mCategories . add ( category . intern ( ) ) ; } }
public final void addCategory ( String category ) { if ( mCategories == null ) mCategories = new ArrayList < String > ( ) ; if ( ! mCategories . contains ( category ) ) { mCategories . add ( category . intern ( ) ) ; } }
public final void addCategory ( String category ) { if ( mCategories == null ) mCategories = new ArrayList < String > ( ) ; if ( ! mCategories . contains ( category ) ) { mCategories . add ( category . intern ( ) ) ; } }
public final void addCategory ( String category ) { if ( mCategories == null ) mCategories = new ArrayList < String > ( ) ; if ( ! mCategories . contains ( category ) ) { mCategories . add ( category . intern ( ) ) ; } }
public final void addCategory ( String category ) { if ( mCategories == null ) mCategories = new ArrayList < String > ( ) ; if ( ! mCategories . contains ( category ) ) { mCategories . add ( category . intern ( ) ) ; } }
public static long parseMemorySize ( String arg ) { if ( arg . endsWith ( STRING ) || arg . endsWith ( STRING ) ) return Long . parseLong ( arg . substring ( _NUM , arg . length ( ) - _NUM ) ) * _NUM * _NUM * _NUM ; else if ( arg . endsWith ( STRING ) || arg . endsWith ( STRING ) ) return Long . parseLong ( arg . substring ( _NUM , arg . length ( ) - _NUM ) ) * _NUM * _NUM ; else if ( arg . endsWith ( STRING ) || arg . endsWith ( STRING ) ) return Long . parseLong ( arg . substring ( _NUM , arg . length ( ) - _NUM ) ) * _NUM ; else return Long . parseLong ( arg . substring ( _NUM , arg . length ( ) ) ) ; }
public void addTypeName ( String type ) { if ( type == null || _typeList . contains ( type ) ) { return ; } _typeList . add ( _NUM , type ) ; log . debug ( STRING , getName ( ) , type ) ; setDirtyAndFirePropertyChange ( TYPES_CHANGED_PROPERTY , _typeList . size ( ) - _NUM , _typeList . size ( ) ) ; }
private void updateExpandInfoLabel ( ) { if ( model . isEnlarged ( ) ) { labelStatsExp . setIcon ( MetaDataStatisticsViewer . ICON_ARROW_UP ) ; } else { labelStatsExp . setIcon ( MetaDataStatisticsViewer . ICON_ARROW_DOWN ) ; } }
public void readFNum ( ) { float f = _NUM ; boolean neg = _BOOL ; int exp = _NUM ; int eval = _NUM ; float mul = _NUM ; byte work = data [ pos ++ ] ; while ( _BOOL ) { if ( work == ( byte ) _NUM ) { work = data [ pos ++ ] ; } int nyb = ( work > > _NUM ) & _NUM ; work = ( byte ) ( ( work << _NUM ) | _NUM ) ; if ( nyb < _NUM ) { if ( exp != _NUM ) { eval = eval * _NUM + nyb ; } else if ( mul == _NUM ) { f = f * _NUM + nyb ; } else { f += nyb * mul ; mul /= _NUM ; } } else if ( nyb == _NUM ) { mul = _NUM ; } else if ( nyb == _NUM ) { exp = _NUM ; } else if ( nyb == _NUM ) { exp = - _NUM ; } else if ( nyb == _NUM ) { neg = _BOOL ; } else { break ; } } fnum = ( neg ? - _NUM : _NUM ) * f * ( float ) Math . pow ( _NUM , eval * exp ) ; }
private StringBuilder createIndent ( ) { StringBuilder oneIndent = new StringBuilder ( ) ; oneIndent . append ( STRING ) ; return oneIndent ; }
private StringBuilder createIndent ( ) { StringBuilder oneIndent = new StringBuilder ( ) ; oneIndent . append ( STRING ) ; return oneIndent ; }
private StringBuilder createIndent ( ) { StringBuilder oneIndent = new StringBuilder ( ) ; oneIndent . append ( STRING ) ; return oneIndent ; }
public static void writeFixInt32 ( final OutputStream output , final int val ) throws IOException { output . write ( ( val > > > _NUM ) & _NUM ) ; output . write ( ( val > > > _NUM ) & _NUM ) ; output . write ( ( val > > > _NUM ) & _NUM ) ; output . write ( val & _NUM ) ; }
private static boolean verifyStringParam ( String str , int maxLength , String acceptableCharacters ) { return ! ( str == null || str . length ( ) == _NUM || str . length ( ) > maxLength || ! Pattern . matches ( acceptableCharacters , str ) ) ; }
private static boolean verifyStringParam ( String str , int maxLength , String acceptableCharacters ) { return ! ( str == null || str . length ( ) == _NUM || str . length ( ) > maxLength || ! Pattern . matches ( acceptableCharacters , str ) ) ; }
protected void create_y_axis ( int i ) { Log . e ( STRING , i + STRING ) ; float ver_height = ( ( graphheight / label_size ) * i ) + border ; if ( i == largest_value_set . size ( ) - _NUM ) canvas . drawLine ( horstart , ver_height , width - ( border ) , ver_height , paint ) ; else canvas . drawLine ( horstart , ver_height , border , ver_height , paint ) ; paint . setColor ( Color . BLACK ) ; int Y_labels = ( int ) size - _NUM - i ; String y_labels = String . format ( STRING , Y_labels * y_axis_ratio ) ; paint . setTextAlign ( Paint . Align . RIGHT ) ; canvas . drawText ( y_labels , horstart - _NUM , ver_height - _NUM , paint ) ; paint . setTextAlign ( Paint . Align . LEFT ) ; }
protected void create_y_axis ( int i ) { Log . e ( STRING , i + STRING ) ; float ver_height = ( ( graphheight / label_size ) * i ) + border ; if ( i == largest_value_set . size ( ) - _NUM ) canvas . drawLine ( horstart , ver_height , width - ( border ) , ver_height , paint ) ; else canvas . drawLine ( horstart , ver_height , border , ver_height , paint ) ; paint . setColor ( Color . BLACK ) ; int Y_labels = ( int ) size - _NUM - i ; String y_labels = String . format ( STRING , Y_labels * y_axis_ratio ) ; paint . setTextAlign ( Paint . Align . RIGHT ) ; canvas . drawText ( y_labels , horstart - _NUM , ver_height - _NUM , paint ) ; paint . setTextAlign ( Paint . Align . LEFT ) ; }
protected void create_y_axis ( int i ) { Log . e ( STRING , i + STRING ) ; float ver_height = ( ( graphheight / label_size ) * i ) + border ; if ( i == largest_value_set . size ( ) - _NUM ) canvas . drawLine ( horstart , ver_height , width - ( border ) , ver_height , paint ) ; else canvas . drawLine ( horstart , ver_height , border , ver_height , paint ) ; paint . setColor ( Color . BLACK ) ; int Y_labels = ( int ) size - _NUM - i ; String y_labels = String . format ( STRING , Y_labels * y_axis_ratio ) ; paint . setTextAlign ( Paint . Align . RIGHT ) ; canvas . drawText ( y_labels , horstart - _NUM , ver_height - _NUM , paint ) ; paint . setTextAlign ( Paint . Align . LEFT ) ; }
public ViewRefRender ( ViewRender < T > view ) { Objects . requireNonNull ( view ) ; _view = view ; _type = typeOf ( view ) ; _priority = priorityOf ( view ) ; }
public ViewRefRender ( ViewRender < T > view ) { Objects . requireNonNull ( view ) ; _view = view ; _type = typeOf ( view ) ; _priority = priorityOf ( view ) ; }
protected void deleteProject ( String projectId ) throws IOException { File wsp = new File ( TARGET , WSP ) ; File project = new File ( wsp , projectId ) ; FileDeleter . delete ( project . toPath ( ) ) ; }
protected void deleteProject ( String projectId ) throws IOException { File wsp = new File ( TARGET , WSP ) ; File project = new File ( wsp , projectId ) ; FileDeleter . delete ( project . toPath ( ) ) ; }
protected void deleteProject ( String projectId ) throws IOException { File wsp = new File ( TARGET , WSP ) ; File project = new File ( wsp , projectId ) ; FileDeleter . delete ( project . toPath ( ) ) ; }
protected void deleteProject ( String projectId ) throws IOException { File wsp = new File ( TARGET , WSP ) ; File project = new File ( wsp , projectId ) ; FileDeleter . delete ( project . toPath ( ) ) ; }
protected void deleteProject ( String projectId ) throws IOException { File wsp = new File ( TARGET , WSP ) ; File project = new File ( wsp , projectId ) ; FileDeleter . delete ( project . toPath ( ) ) ; }
protected void deleteProject ( String projectId ) throws IOException { File wsp = new File ( TARGET , WSP ) ; File project = new File ( wsp , projectId ) ; FileDeleter . delete ( project . toPath ( ) ) ; }
@ Override public void printStackTrace ( ) { super . printStackTrace ( ) ; if ( nested != null ) { nested . printStackTrace ( ) ; } }
public int hashCode ( ) { return lastPathComponent . hashCode ( ) ; }
public int hashCode ( ) { return lastPathComponent . hashCode ( ) ; }
public boolean shouldReverse ( String token ) { int posQ = token . indexOf ( STRING ) ; int posA = token . indexOf ( STRING ) ; if ( posQ == - _NUM && posA == - _NUM ) { return _BOOL ; } int pos ; int lastPos ; int len = token . length ( ) ; lastPos = token . lastIndexOf ( STRING ) ; pos = token . lastIndexOf ( STRING ) ; if ( pos > lastPos ) lastPos = pos ; if ( posQ != - _NUM ) { pos = posQ ; if ( posA != - _NUM ) { pos = Math . min ( posQ , posA ) ; } } else { pos = posA ; } if ( len - lastPos < minTrailing ) { return _BOOL ; } if ( posQ != - _NUM && posQ < maxPosQuestion ) { return _BOOL ; } if ( posA != - _NUM && posA < maxPosAsterisk ) { return _BOOL ; } if ( maxFractionAsterisk > _NUM && pos < ( float ) token . length ( ) * maxFractionAsterisk ) { return _BOOL ; } return _BOOL ; }
public boolean shouldReverse ( String token ) { int posQ = token . indexOf ( STRING ) ; int posA = token . indexOf ( STRING ) ; if ( posQ == - _NUM && posA == - _NUM ) { return _BOOL ; } int pos ; int lastPos ; int len = token . length ( ) ; lastPos = token . lastIndexOf ( STRING ) ; pos = token . lastIndexOf ( STRING ) ; if ( pos > lastPos ) lastPos = pos ; if ( posQ != - _NUM ) { pos = posQ ; if ( posA != - _NUM ) { pos = Math . min ( posQ , posA ) ; } } else { pos = posA ; } if ( len - lastPos < minTrailing ) { return _BOOL ; } if ( posQ != - _NUM && posQ < maxPosQuestion ) { return _BOOL ; } if ( posA != - _NUM && posA < maxPosAsterisk ) { return _BOOL ; } if ( maxFractionAsterisk > _NUM && pos < ( float ) token . length ( ) * maxFractionAsterisk ) { return _BOOL ; } return _BOOL ; }
public boolean shouldReverse ( String token ) { int posQ = token . indexOf ( STRING ) ; int posA = token . indexOf ( STRING ) ; if ( posQ == - _NUM && posA == - _NUM ) { return _BOOL ; } int pos ; int lastPos ; int len = token . length ( ) ; lastPos = token . lastIndexOf ( STRING ) ; pos = token . lastIndexOf ( STRING ) ; if ( pos > lastPos ) lastPos = pos ; if ( posQ != - _NUM ) { pos = posQ ; if ( posA != - _NUM ) { pos = Math . min ( posQ , posA ) ; } } else { pos = posA ; } if ( len - lastPos < minTrailing ) { return _BOOL ; } if ( posQ != - _NUM && posQ < maxPosQuestion ) { return _BOOL ; } if ( posA != - _NUM && posA < maxPosAsterisk ) { return _BOOL ; } if ( maxFractionAsterisk > _NUM && pos < ( float ) token . length ( ) * maxFractionAsterisk ) { return _BOOL ; } return _BOOL ; }
public boolean shouldReverse ( String token ) { int posQ = token . indexOf ( STRING ) ; int posA = token . indexOf ( STRING ) ; if ( posQ == - _NUM && posA == - _NUM ) { return _BOOL ; } int pos ; int lastPos ; int len = token . length ( ) ; lastPos = token . lastIndexOf ( STRING ) ; pos = token . lastIndexOf ( STRING ) ; if ( pos > lastPos ) lastPos = pos ; if ( posQ != - _NUM ) { pos = posQ ; if ( posA != - _NUM ) { pos = Math . min ( posQ , posA ) ; } } else { pos = posA ; } if ( len - lastPos < minTrailing ) { return _BOOL ; } if ( posQ != - _NUM && posQ < maxPosQuestion ) { return _BOOL ; } if ( posA != - _NUM && posA < maxPosAsterisk ) { return _BOOL ; } if ( maxFractionAsterisk > _NUM && pos < ( float ) token . length ( ) * maxFractionAsterisk ) { return _BOOL ; } return _BOOL ; }
public boolean shouldReverse ( String token ) { int posQ = token . indexOf ( STRING ) ; int posA = token . indexOf ( STRING ) ; if ( posQ == - _NUM && posA == - _NUM ) { return _BOOL ; } int pos ; int lastPos ; int len = token . length ( ) ; lastPos = token . lastIndexOf ( STRING ) ; pos = token . lastIndexOf ( STRING ) ; if ( pos > lastPos ) lastPos = pos ; if ( posQ != - _NUM ) { pos = posQ ; if ( posA != - _NUM ) { pos = Math . min ( posQ , posA ) ; } } else { pos = posA ; } if ( len - lastPos < minTrailing ) { return _BOOL ; } if ( posQ != - _NUM && posQ < maxPosQuestion ) { return _BOOL ; } if ( posA != - _NUM && posA < maxPosAsterisk ) { return _BOOL ; } if ( maxFractionAsterisk > _NUM && pos < ( float ) token . length ( ) * maxFractionAsterisk ) { return _BOOL ; } return _BOOL ; }
public boolean shouldReverse ( String token ) { int posQ = token . indexOf ( STRING ) ; int posA = token . indexOf ( STRING ) ; if ( posQ == - _NUM && posA == - _NUM ) { return _BOOL ; } int pos ; int lastPos ; int len = token . length ( ) ; lastPos = token . lastIndexOf ( STRING ) ; pos = token . lastIndexOf ( STRING ) ; if ( pos > lastPos ) lastPos = pos ; if ( posQ != - _NUM ) { pos = posQ ; if ( posA != - _NUM ) { pos = Math . min ( posQ , posA ) ; } } else { pos = posA ; } if ( len - lastPos < minTrailing ) { return _BOOL ; } if ( posQ != - _NUM && posQ < maxPosQuestion ) { return _BOOL ; } if ( posA != - _NUM && posA < maxPosAsterisk ) { return _BOOL ; } if ( maxFractionAsterisk > _NUM && pos < ( float ) token . length ( ) * maxFractionAsterisk ) { return _BOOL ; } return _BOOL ; }
synchronized void redo ( RTEditText editor ) { Stack < Operation > redoStack = getRedoStack ( editor ) ; if ( ! redoStack . empty ( ) ) { Stack < Operation > undoStack = getUndoStack ( editor ) ; Operation op = redoStack . pop ( ) ; push ( op , undoStack ) ; op . redo ( editor ) ; while ( ! redoStack . empty ( ) && op . canMerge ( redoStack . peek ( ) ) ) { op = redoStack . pop ( ) ; push ( op , undoStack ) ; op . redo ( editor ) ; } } }
protected void updateAnnotations ( Annotation existingAnnotation , Position newPos , Map additions , List modifications , List deletions ) { if ( existingAnnotation instanceof FoldingAnnotation ) { FoldingAnnotation foldingAnnotation = ( FoldingAnnotation ) existingAnnotation ; if ( newPos != null && newPos . length > _NUM && projectionAnnotationModel != null ) { Position oldPos = projectionAnnotationModel . getPosition ( foldingAnnotation ) ; if ( ! newPos . equals ( oldPos ) ) { oldPos . setOffset ( newPos . offset ) ; oldPos . setLength ( newPos . length ) ; modifications . add ( foldingAnnotation ) ; } } else { deletions . add ( foldingAnnotation ) ; } } }
protected void updateAnnotations ( Annotation existingAnnotation , Position newPos , Map additions , List modifications , List deletions ) { if ( existingAnnotation instanceof FoldingAnnotation ) { FoldingAnnotation foldingAnnotation = ( FoldingAnnotation ) existingAnnotation ; if ( newPos != null && newPos . length > _NUM && projectionAnnotationModel != null ) { Position oldPos = projectionAnnotationModel . getPosition ( foldingAnnotation ) ; if ( ! newPos . equals ( oldPos ) ) { oldPos . setOffset ( newPos . offset ) ; oldPos . setLength ( newPos . length ) ; modifications . add ( foldingAnnotation ) ; } } else { deletions . add ( foldingAnnotation ) ; } } }
public TextEditor replaceAll ( String regex , String replacement ) { if ( text . length ( ) > _NUM ) { final String r = replacement ; Pattern p = Pattern . compile ( regex , Pattern . MULTILINE ) ; Matcher m = p . matcher ( text ) ; StringBuffer sb = new StringBuffer ( ) ; while ( m . find ( ) ) { m . appendReplacement ( sb , r ) ; } m . appendTail ( sb ) ; text = sb ; } return this ; }
public TextEditor replaceAll ( String regex , String replacement ) { if ( text . length ( ) > _NUM ) { final String r = replacement ; Pattern p = Pattern . compile ( regex , Pattern . MULTILINE ) ; Matcher m = p . matcher ( text ) ; StringBuffer sb = new StringBuffer ( ) ; while ( m . find ( ) ) { m . appendReplacement ( sb , r ) ; } m . appendTail ( sb ) ; text = sb ; } return this ; }
@ SuppressWarnings ( STRING ) public static < K > ImmutableArray < K > empty ( ) { return ( ImmutableArray < K > ) EMPTY ; }
private static AdeException adeExceptionOf ( Throwable t ) { if ( t instanceof AdeException ) { return ( AdeException ) t ; } else { return new AdeInternalException ( STRING + t . getMessage ( ) + STRING , t ) ; } }
private static AdeException adeExceptionOf ( Throwable t ) { if ( t instanceof AdeException ) { return ( AdeException ) t ; } else { return new AdeInternalException ( STRING + t . getMessage ( ) + STRING , t ) ; } }
private static AdeException adeExceptionOf ( Throwable t ) { if ( t instanceof AdeException ) { return ( AdeException ) t ; } else { return new AdeInternalException ( STRING + t . getMessage ( ) + STRING , t ) ; } }
private static AdeException adeExceptionOf ( Throwable t ) { if ( t instanceof AdeException ) { return ( AdeException ) t ; } else { return new AdeInternalException ( STRING + t . getMessage ( ) + STRING , t ) ; } }
@ Override public int compare ( final Long o1 , final Long o2 ) { if ( o1 . longValue ( ) < o2 . longValue ( ) ) return _NUM ; if ( o1 . longValue ( ) > o2 . longValue ( ) ) return - _NUM ; return _NUM ; }
@ Override public int compare ( final Long o1 , final Long o2 ) { if ( o1 . longValue ( ) < o2 . longValue ( ) ) return _NUM ; if ( o1 . longValue ( ) > o2 . longValue ( ) ) return - _NUM ; return _NUM ; }
@ Override public int compare ( final Long o1 , final Long o2 ) { if ( o1 . longValue ( ) < o2 . longValue ( ) ) return _NUM ; if ( o1 . longValue ( ) > o2 . longValue ( ) ) return - _NUM ; return _NUM ; }
public static void addItemStackToList ( ItemStack stack ) { if ( ! hasItems ( stack ) ) { stacks . add ( stack ) ; } }
public static double ceil ( double f , Ceil type ) { return Math . ceil ( f * type . mult ) / type . mult ; }
public static double ceil ( double f , Ceil type ) { return Math . ceil ( f * type . mult ) / type . mult ; }
public void preAllocateSynapses ( int expectedNumSynapses ) throws IllegalStateException { if ( ! exSynapseSet . isEmpty ( ) || ! inSynapseSet . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING + STRING + STRING + STRING + STRING ) ; } exSynapseSet = new HashSet < Synapse > ( ( int ) ( expectedNumSynapses * excitatoryRatio / _NUM ) ) ; inSynapseSet = new HashSet < Synapse > ( ( int ) ( expectedNumSynapses * ( _NUM - excitatoryRatio ) / _NUM ) ) ; }
public void preAllocateSynapses ( int expectedNumSynapses ) throws IllegalStateException { if ( ! exSynapseSet . isEmpty ( ) || ! inSynapseSet . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING + STRING + STRING + STRING + STRING ) ; } exSynapseSet = new HashSet < Synapse > ( ( int ) ( expectedNumSynapses * excitatoryRatio / _NUM ) ) ; inSynapseSet = new HashSet < Synapse > ( ( int ) ( expectedNumSynapses * ( _NUM - excitatoryRatio ) / _NUM ) ) ; }
public void preAllocateSynapses ( int expectedNumSynapses ) throws IllegalStateException { if ( ! exSynapseSet . isEmpty ( ) || ! inSynapseSet . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING + STRING + STRING + STRING + STRING ) ; } exSynapseSet = new HashSet < Synapse > ( ( int ) ( expectedNumSynapses * excitatoryRatio / _NUM ) ) ; inSynapseSet = new HashSet < Synapse > ( ( int ) ( expectedNumSynapses * ( _NUM - excitatoryRatio ) / _NUM ) ) ; }
public void preAllocateSynapses ( int expectedNumSynapses ) throws IllegalStateException { if ( ! exSynapseSet . isEmpty ( ) || ! inSynapseSet . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING + STRING + STRING + STRING + STRING ) ; } exSynapseSet = new HashSet < Synapse > ( ( int ) ( expectedNumSynapses * excitatoryRatio / _NUM ) ) ; inSynapseSet = new HashSet < Synapse > ( ( int ) ( expectedNumSynapses * ( _NUM - excitatoryRatio ) / _NUM ) ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; return newVector . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; return newVector . elements ( ) ; }
public DefaultConsolePanel ( ) { setLayout ( new BorderLayout ( _NUM , _NUM ) ) ; textPane = new JTextArea ( ) ; textPane . setRows ( _NUM ) ; textPane . setEditable ( _BOOL ) ; JScrollPane jp = new JScrollPane ( textPane ) ; add ( jp , BorderLayout . CENTER ) ; }
private void trace ( ) { glUseProgram ( computeProgram ) ; glDisable ( GL_DEPTH_TEST ) ; long thisTime = System . nanoTime ( ) ; float elapsedSeconds = ( thisTime - firstTime ) / _NUM ; glUniform1f ( timeUniform , elapsedSeconds ) ; float blendFactor = frameNumber / ( frameNumber + _NUM ) ; glUniform1f ( blendFactorUniform , blendFactor ) ; glUniform1i ( bounceCountUniform , bounceCount ) ; glBindImageTexture ( framebufferImageBinding , raytraceTexture , _NUM , _BOOL , _NUM , GL_READ_WRITE , GL_RGBA32F ) ; glBindImageTexture ( worldPositionImageBinding , positionTexture , _NUM , _BOOL , _NUM , GL_READ_ONLY , GL_RGBA32F ) ; glBindImageTexture ( worldNormalImageBinding , normalTexture , _NUM , _BOOL , _NUM , GL_READ_ONLY , GL_RGBA16F ) ; int worksizeX = mathRoundPoT ( width ) ; int worksizeY = mathRoundPoT ( height ) ; glDispatchCompute ( worksizeX / workGroupSizeX , worksizeY / workGroupSizeY , _NUM ) ; glMemoryBarrier ( GL_SHADER_IMAGE_ACCESS_BARRIER_BIT ) ; glBindImageTexture ( framebufferImageBinding , _NUM , _NUM , _BOOL , _NUM , GL_READ_WRITE , GL_RGBA32F ) ; glBindImageTexture ( worldPositionImageBinding , _NUM , _NUM , _BOOL , _NUM , GL_READ_ONLY , GL_RGBA32F ) ; glBindImageTexture ( worldNormalImageBinding , _NUM , _NUM , _BOOL , _NUM , GL_READ_ONLY , GL_RGBA16F ) ; glUseProgram ( _NUM ) ; frameNumber ++ ; }
private void trace ( ) { glUseProgram ( computeProgram ) ; glDisable ( GL_DEPTH_TEST ) ; long thisTime = System . nanoTime ( ) ; float elapsedSeconds = ( thisTime - firstTime ) / _NUM ; glUniform1f ( timeUniform , elapsedSeconds ) ; float blendFactor = frameNumber / ( frameNumber + _NUM ) ; glUniform1f ( blendFactorUniform , blendFactor ) ; glUniform1i ( bounceCountUniform , bounceCount ) ; glBindImageTexture ( framebufferImageBinding , raytraceTexture , _NUM , _BOOL , _NUM , GL_READ_WRITE , GL_RGBA32F ) ; glBindImageTexture ( worldPositionImageBinding , positionTexture , _NUM , _BOOL , _NUM , GL_READ_ONLY , GL_RGBA32F ) ; glBindImageTexture ( worldNormalImageBinding , normalTexture , _NUM , _BOOL , _NUM , GL_READ_ONLY , GL_RGBA16F ) ; int worksizeX = mathRoundPoT ( width ) ; int worksizeY = mathRoundPoT ( height ) ; glDispatchCompute ( worksizeX / workGroupSizeX , worksizeY / workGroupSizeY , _NUM ) ; glMemoryBarrier ( GL_SHADER_IMAGE_ACCESS_BARRIER_BIT ) ; glBindImageTexture ( framebufferImageBinding , _NUM , _NUM , _BOOL , _NUM , GL_READ_WRITE , GL_RGBA32F ) ; glBindImageTexture ( worldPositionImageBinding , _NUM , _NUM , _BOOL , _NUM , GL_READ_ONLY , GL_RGBA32F ) ; glBindImageTexture ( worldNormalImageBinding , _NUM , _NUM , _BOOL , _NUM , GL_READ_ONLY , GL_RGBA16F ) ; glUseProgram ( _NUM ) ; frameNumber ++ ; }
protected Signature ( String algorithm ) { this . algorithm = algorithm ; }
public static Process runCommand ( String command , Consumer < String > stdoutConsumer , Runnable errorHandler , String ... args ) { return runCommand ( command , null , _BOOL , stdoutConsumer , null , errorHandler , args ) ; }
private boolean isNeedToRemove ( String columnName ) { return isRemovedFromClass ( columnName ) && ! isIdColumn ( columnName ) && ! isForeignKeyColumn ( mTableModel , columnName ) ; }
private boolean isNeedToRemove ( String columnName ) { return isRemovedFromClass ( columnName ) && ! isIdColumn ( columnName ) && ! isForeignKeyColumn ( mTableModel , columnName ) ; }
private boolean isNeedToRemove ( String columnName ) { return isRemovedFromClass ( columnName ) && ! isIdColumn ( columnName ) && ! isForeignKeyColumn ( mTableModel , columnName ) ; }
private boolean isNeedToRemove ( String columnName ) { return isRemovedFromClass ( columnName ) && ! isIdColumn ( columnName ) && ! isForeignKeyColumn ( mTableModel , columnName ) ; }
private static String removeFileNameExtension ( String fileName ) { if ( fileName . lastIndexOf ( STRING ) == - _NUM ) return fileName ; return fileName . substring ( _NUM , fileName . lastIndexOf ( STRING ) ) ; }
private static String removeFileNameExtension ( String fileName ) { if ( fileName . lastIndexOf ( STRING ) == - _NUM ) return fileName ; return fileName . substring ( _NUM , fileName . lastIndexOf ( STRING ) ) ; }
public StrBuilder deleteFirst ( final String str ) { final int len = ( str == null ? _NUM : str . length ( ) ) ; if ( len > _NUM ) { final int index = indexOf ( str , _NUM ) ; if ( index >= _NUM ) { deleteImpl ( index , index + len , len ) ; } } return this ; }
public StrBuilder deleteFirst ( final String str ) { final int len = ( str == null ? _NUM : str . length ( ) ) ; if ( len > _NUM ) { final int index = indexOf ( str , _NUM ) ; if ( index >= _NUM ) { deleteImpl ( index , index + len , len ) ; } } return this ; }
public StrBuilder deleteFirst ( final String str ) { final int len = ( str == null ? _NUM : str . length ( ) ) ; if ( len > _NUM ) { final int index = indexOf ( str , _NUM ) ; if ( index >= _NUM ) { deleteImpl ( index , index + len , len ) ; } } return this ; }
public static void write ( Id parcelID , double freeSpeedAccessibility , double carAccessibility , double bikeAccessibility , double walkAccessibility ) { try { assert ( UrbanSimParcelCSVWriter . parcelWriter != null ) ; parcelWriter . write ( parcelID + STRING + freeSpeedAccessibility + STRING + carAccessibility + STRING + bikeAccessibility + STRING + walkAccessibility ) ; parcelWriter . newLine ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
public static Document parse ( Reader reader , boolean validating , boolean namespaceAware , boolean allowDocTypeDeclaration ) throws SAXException , IOException , ParserConfigurationException { DocumentBuilderFactory factory = FactorySupport . createDocumentBuilderFactory ( ) ; factory . setNamespaceAware ( namespaceAware ) ; factory . setValidating ( validating ) ; setQuietly ( factory , XMLConstants . FEATURE_SECURE_PROCESSING , _BOOL ) ; setQuietly ( factory , STRING , ! allowDocTypeDeclaration ) ; DocumentBuilder documentBuilder = factory . newDocumentBuilder ( ) ; return documentBuilder . parse ( new InputSource ( reader ) ) ; }
public static Document parse ( Reader reader , boolean validating , boolean namespaceAware , boolean allowDocTypeDeclaration ) throws SAXException , IOException , ParserConfigurationException { DocumentBuilderFactory factory = FactorySupport . createDocumentBuilderFactory ( ) ; factory . setNamespaceAware ( namespaceAware ) ; factory . setValidating ( validating ) ; setQuietly ( factory , XMLConstants . FEATURE_SECURE_PROCESSING , _BOOL ) ; setQuietly ( factory , STRING , ! allowDocTypeDeclaration ) ; DocumentBuilder documentBuilder = factory . newDocumentBuilder ( ) ; return documentBuilder . parse ( new InputSource ( reader ) ) ; }
public static Document parse ( Reader reader , boolean validating , boolean namespaceAware , boolean allowDocTypeDeclaration ) throws SAXException , IOException , ParserConfigurationException { DocumentBuilderFactory factory = FactorySupport . createDocumentBuilderFactory ( ) ; factory . setNamespaceAware ( namespaceAware ) ; factory . setValidating ( validating ) ; setQuietly ( factory , XMLConstants . FEATURE_SECURE_PROCESSING , _BOOL ) ; setQuietly ( factory , STRING , ! allowDocTypeDeclaration ) ; DocumentBuilder documentBuilder = factory . newDocumentBuilder ( ) ; return documentBuilder . parse ( new InputSource ( reader ) ) ; }
static public void addQueryParams ( final StringBuilder urlString , final Map < String , String [ ] > requestParams ) throws UnsupportedEncodingException { if ( requestParams == null ) return ; boolean first = _BOOL ; for ( Map . Entry < String , String [ ] > e : requestParams . entrySet ( ) ) { final String name = e . getKey ( ) ; final String [ ] vals = e . getValue ( ) ; if ( vals == null ) { urlString . append ( first ? STRING : STRING ) ; first = _BOOL ; urlString . append ( URLEncoder . encode ( name , RemoteRepository . UTF8 ) ) ; } else { for ( String val : vals ) { urlString . append ( first ? STRING : STRING ) ; first = _BOOL ; urlString . append ( URLEncoder . encode ( name , RemoteRepository . UTF8 ) ) ; urlString . append ( STRING ) ; if ( val != null ) urlString . append ( URLEncoder . encode ( val , RemoteRepository . UTF8 ) ) ; } } } }
static public void addQueryParams ( final StringBuilder urlString , final Map < String , String [ ] > requestParams ) throws UnsupportedEncodingException { if ( requestParams == null ) return ; boolean first = _BOOL ; for ( Map . Entry < String , String [ ] > e : requestParams . entrySet ( ) ) { final String name = e . getKey ( ) ; final String [ ] vals = e . getValue ( ) ; if ( vals == null ) { urlString . append ( first ? STRING : STRING ) ; first = _BOOL ; urlString . append ( URLEncoder . encode ( name , RemoteRepository . UTF8 ) ) ; } else { for ( String val : vals ) { urlString . append ( first ? STRING : STRING ) ; first = _BOOL ; urlString . append ( URLEncoder . encode ( name , RemoteRepository . UTF8 ) ) ; urlString . append ( STRING ) ; if ( val != null ) urlString . append ( URLEncoder . encode ( val , RemoteRepository . UTF8 ) ) ; } } } }
public E remove ( int index ) { rangeCheck ( index ) ; modCount ++ ; E oldValue = elementData ( index ) ; int numMoved = size - index - _NUM ; if ( numMoved > _NUM ) System . arraycopy ( elementData , index + _NUM , elementData , index , numMoved ) ; elementData [ -- size ] = null ; return oldValue ; }
public E remove ( int index ) { rangeCheck ( index ) ; modCount ++ ; E oldValue = elementData ( index ) ; int numMoved = size - index - _NUM ; if ( numMoved > _NUM ) System . arraycopy ( elementData , index + _NUM , elementData , index , numMoved ) ; elementData [ -- size ] = null ; return oldValue ; }
public E remove ( int index ) { rangeCheck ( index ) ; modCount ++ ; E oldValue = elementData ( index ) ; int numMoved = size - index - _NUM ; if ( numMoved > _NUM ) System . arraycopy ( elementData , index + _NUM , elementData , index , numMoved ) ; elementData [ -- size ] = null ; return oldValue ; }
void addOption ( Option opt ) { options . add ( opt ) ; }
protected static void addVolume ( List < BlockObjectRestRep > blockObjects , VolumeRestRep volume , List < BlockSnapshotRestRep > snapshots ) { blockObjects . add ( volume ) ; if ( CollectionUtils . isNotEmpty ( snapshots ) ) { Iterator < BlockSnapshotRestRep > snapshotIter = snapshots . iterator ( ) ; while ( snapshotIter . hasNext ( ) ) { BlockSnapshotRestRep snap = snapshotIter . next ( ) ; if ( ResourceUtils . idEquals ( snap . getParent ( ) , volume ) ) { blockObjects . add ( snap ) ; snapshotIter . remove ( ) ; } } } }
protected static void addVolume ( List < BlockObjectRestRep > blockObjects , VolumeRestRep volume , List < BlockSnapshotRestRep > snapshots ) { blockObjects . add ( volume ) ; if ( CollectionUtils . isNotEmpty ( snapshots ) ) { Iterator < BlockSnapshotRestRep > snapshotIter = snapshots . iterator ( ) ; while ( snapshotIter . hasNext ( ) ) { BlockSnapshotRestRep snap = snapshotIter . next ( ) ; if ( ResourceUtils . idEquals ( snap . getParent ( ) , volume ) ) { blockObjects . add ( snap ) ; snapshotIter . remove ( ) ; } } } }
private static void cacheFactory ( ClassLoader classLoader , LogFactory factory ) { if ( factory != null ) { if ( classLoader == null ) { nullClassLoaderFactory = factory ; } else { factories . put ( classLoader , factory ) ; } } }
private static void cacheFactory ( ClassLoader classLoader , LogFactory factory ) { if ( factory != null ) { if ( classLoader == null ) { nullClassLoaderFactory = factory ; } else { factories . put ( classLoader , factory ) ; } } }
private static void cacheFactory ( ClassLoader classLoader , LogFactory factory ) { if ( factory != null ) { if ( classLoader == null ) { nullClassLoaderFactory = factory ; } else { factories . put ( classLoader , factory ) ; } } }
private static void cacheFactory ( ClassLoader classLoader , LogFactory factory ) { if ( factory != null ) { if ( classLoader == null ) { nullClassLoaderFactory = factory ; } else { factories . put ( classLoader , factory ) ; } } }
private static void cacheFactory ( ClassLoader classLoader , LogFactory factory ) { if ( factory != null ) { if ( classLoader == null ) { nullClassLoaderFactory = factory ; } else { factories . put ( classLoader , factory ) ; } } }
public static boolean serializeSpecToFile ( SecuritySpecModel spec , String androidProjectRootPath ) { boolean saved = _BOOL ; String fileName = androidProjectRootPath + File . separator + Project . OUTPUT_DIR + File . separator + SECURITY_SPEC_SERIAL_FILE_NAME ; try { ObjectOutputStream oos = new ObjectOutputStream ( new BufferedOutputStream ( new FileOutputStream ( fileName ) ) ) ; try { oos . writeObject ( spec ) ; saved = _BOOL ; } finally { oos . close ( ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return saved ; }
public void manage ( Subscription subscription ) { mSubscriptions . add ( subscription ) ; }
public void printLastSeenInfo ( String messageID ) { if ( m_verbose ) { logger . info ( messageID + STRING + m_deltasInSeconds . toString ( ) ) ; } }
private void addToScene ( final Node items ) { collection . add ( items ) ; }
private void addToScene ( final Node items ) { collection . add ( items ) ; }
public static GraphRequest newUploadVideoRequest ( AccessToken accessToken , File file , Callback callback ) throws FileNotFoundException { ParcelFileDescriptor descriptor = ParcelFileDescriptor . open ( file , ParcelFileDescriptor . MODE_READ_ONLY ) ; Bundle parameters = new Bundle ( _NUM ) ; parameters . putParcelable ( file . getName ( ) , descriptor ) ; return new GraphRequest ( accessToken , MY_VIDEOS , parameters , HttpMethod . POST , callback ) ; }
public static GraphRequest newUploadVideoRequest ( AccessToken accessToken , File file , Callback callback ) throws FileNotFoundException { ParcelFileDescriptor descriptor = ParcelFileDescriptor . open ( file , ParcelFileDescriptor . MODE_READ_ONLY ) ; Bundle parameters = new Bundle ( _NUM ) ; parameters . putParcelable ( file . getName ( ) , descriptor ) ; return new GraphRequest ( accessToken , MY_VIDEOS , parameters , HttpMethod . POST , callback ) ; }
public static GraphRequest newUploadVideoRequest ( AccessToken accessToken , File file , Callback callback ) throws FileNotFoundException { ParcelFileDescriptor descriptor = ParcelFileDescriptor . open ( file , ParcelFileDescriptor . MODE_READ_ONLY ) ; Bundle parameters = new Bundle ( _NUM ) ; parameters . putParcelable ( file . getName ( ) , descriptor ) ; return new GraphRequest ( accessToken , MY_VIDEOS , parameters , HttpMethod . POST , callback ) ; }
public static GraphRequest newUploadVideoRequest ( AccessToken accessToken , File file , Callback callback ) throws FileNotFoundException { ParcelFileDescriptor descriptor = ParcelFileDescriptor . open ( file , ParcelFileDescriptor . MODE_READ_ONLY ) ; Bundle parameters = new Bundle ( _NUM ) ; parameters . putParcelable ( file . getName ( ) , descriptor ) ; return new GraphRequest ( accessToken , MY_VIDEOS , parameters , HttpMethod . POST , callback ) ; }
public static GraphRequest newUploadVideoRequest ( AccessToken accessToken , File file , Callback callback ) throws FileNotFoundException { ParcelFileDescriptor descriptor = ParcelFileDescriptor . open ( file , ParcelFileDescriptor . MODE_READ_ONLY ) ; Bundle parameters = new Bundle ( _NUM ) ; parameters . putParcelable ( file . getName ( ) , descriptor ) ; return new GraphRequest ( accessToken , MY_VIDEOS , parameters , HttpMethod . POST , callback ) ; }
public static GraphRequest newUploadVideoRequest ( AccessToken accessToken , File file , Callback callback ) throws FileNotFoundException { ParcelFileDescriptor descriptor = ParcelFileDescriptor . open ( file , ParcelFileDescriptor . MODE_READ_ONLY ) ; Bundle parameters = new Bundle ( _NUM ) ; parameters . putParcelable ( file . getName ( ) , descriptor ) ; return new GraphRequest ( accessToken , MY_VIDEOS , parameters , HttpMethod . POST , callback ) ; }
private Map < String , Integer > findLanguageFallbacks ( final ServiceParams params ) { List < TermNode > paramNodes = params . get ( LANGUAGE_PARAM ) ; if ( paramNodes . size ( ) < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } Map < String , Integer > fallbacksMap = new HashMap < > ( ) ; int cnt = _NUM ; for ( TermNode term : paramNodes ) { if ( term . isVariable ( ) ) { throw new IllegalArgumentException ( STRING ) ; } final Value v = term . getValue ( ) ; if ( ! ( v instanceof Literal ) ) { throw new IllegalArgumentException ( STRING ) ; } final String s = v . stringValue ( ) ; if ( s . contains ( STRING ) ) { for ( String ls : s . split ( STRING ) ) { fallbacksMap . put ( ls . trim ( ) , cnt ) ; ++ cnt ; } } else { fallbacksMap . put ( s . trim ( ) , cnt ) ; } ++ cnt ; } return fallbacksMap ; }
private Map < String , Integer > findLanguageFallbacks ( final ServiceParams params ) { List < TermNode > paramNodes = params . get ( LANGUAGE_PARAM ) ; if ( paramNodes . size ( ) < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } Map < String , Integer > fallbacksMap = new HashMap < > ( ) ; int cnt = _NUM ; for ( TermNode term : paramNodes ) { if ( term . isVariable ( ) ) { throw new IllegalArgumentException ( STRING ) ; } final Value v = term . getValue ( ) ; if ( ! ( v instanceof Literal ) ) { throw new IllegalArgumentException ( STRING ) ; } final String s = v . stringValue ( ) ; if ( s . contains ( STRING ) ) { for ( String ls : s . split ( STRING ) ) { fallbacksMap . put ( ls . trim ( ) , cnt ) ; ++ cnt ; } } else { fallbacksMap . put ( s . trim ( ) , cnt ) ; } ++ cnt ; } return fallbacksMap ; }
private Map < String , Integer > findLanguageFallbacks ( final ServiceParams params ) { List < TermNode > paramNodes = params . get ( LANGUAGE_PARAM ) ; if ( paramNodes . size ( ) < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } Map < String , Integer > fallbacksMap = new HashMap < > ( ) ; int cnt = _NUM ; for ( TermNode term : paramNodes ) { if ( term . isVariable ( ) ) { throw new IllegalArgumentException ( STRING ) ; } final Value v = term . getValue ( ) ; if ( ! ( v instanceof Literal ) ) { throw new IllegalArgumentException ( STRING ) ; } final String s = v . stringValue ( ) ; if ( s . contains ( STRING ) ) { for ( String ls : s . split ( STRING ) ) { fallbacksMap . put ( ls . trim ( ) , cnt ) ; ++ cnt ; } } else { fallbacksMap . put ( s . trim ( ) , cnt ) ; } ++ cnt ; } return fallbacksMap ; }
private void recomputeSeperation ( double [ ] [ ] means , double [ ] sep ) { final int k = means . length ; assert ( sep . length == k ) ; boolean issquared = ( distanceFunction instanceof SquaredEuclideanDistanceFunction ) ; Arrays . fill ( sep , Double . POSITIVE_INFINITY ) ; for ( int i = _NUM ; i < k ; i ++ ) { DoubleVector m1 = DoubleVector . wrap ( means [ i ] ) ; for ( int j = _NUM ; j < i ; j ++ ) { double d = distanceFunction . distance ( m1 , DoubleVector . wrap ( means [ j ] ) ) ; sep [ i ] = ( d < sep [ i ] ) ? d : sep [ i ] ; sep [ j ] = ( d < sep [ j ] ) ? d : sep [ j ] ; } } for ( int i = _NUM ; i < k ; i ++ ) { sep [ i ] = issquared ? Math . sqrt ( sep [ i ] ) : sep [ i ] ; sep [ i ] *= _NUM ; } }
protected final void addImpl ( Component comp , Object constraints , int index ) { synchronized ( getTreeLock ( ) ) { if ( getComponentCount ( ) > _NUM ) { remove ( _NUM ) ; } if ( index > _NUM ) { throw new IllegalArgumentException ( STRING ) ; } if ( ! SunToolkit . isLightweightOrUnknown ( comp ) ) { super . addImpl ( comp , constraints , index ) ; } else { addToPanel ( comp , constraints , index ) ; } } }
protected final void addImpl ( Component comp , Object constraints , int index ) { synchronized ( getTreeLock ( ) ) { if ( getComponentCount ( ) > _NUM ) { remove ( _NUM ) ; } if ( index > _NUM ) { throw new IllegalArgumentException ( STRING ) ; } if ( ! SunToolkit . isLightweightOrUnknown ( comp ) ) { super . addImpl ( comp , constraints , index ) ; } else { addToPanel ( comp , constraints , index ) ; } } }
protected final void addImpl ( Component comp , Object constraints , int index ) { synchronized ( getTreeLock ( ) ) { if ( getComponentCount ( ) > _NUM ) { remove ( _NUM ) ; } if ( index > _NUM ) { throw new IllegalArgumentException ( STRING ) ; } if ( ! SunToolkit . isLightweightOrUnknown ( comp ) ) { super . addImpl ( comp , constraints , index ) ; } else { addToPanel ( comp , constraints , index ) ; } } }
public XTraceReport put ( Object key , Object value ) { if ( key != null ) { builder . addKey ( key . toString ( ) ) ; builder . addValue ( value == null ? STRING : value . toString ( ) ) ; } return this ; }
public static TextLine standardCreateTextLine ( FontRenderContext frc , AttributedCharacterIterator text , char [ ] chars , float [ ] baselineOffsets ) { StyledParagraph styledParagraph = new StyledParagraph ( text , chars ) ; Bidi bidi = new Bidi ( text ) ; if ( bidi . isLeftToRight ( ) ) { bidi = null ; } int layoutFlags = _NUM ; TextLabelFactory factory = new TextLabelFactory ( frc , chars , bidi , layoutFlags ) ; boolean isDirectionLTR = _BOOL ; if ( bidi != null ) { isDirectionLTR = bidi . baseIsLeftToRight ( ) ; } return createLineFromText ( chars , styledParagraph , factory , isDirectionLTR , baselineOffsets ) ; }
public static double calculateAnalyticalLogLikelihood ( IntervalList intervals ) { if ( ! intervals . isCoalescentOnly ( ) ) { throw new IllegalArgumentException ( STRING ) ; } final double lambda = getLambda ( intervals ) ; final int n = intervals . getSampleCount ( ) ; return ( _NUM - n ) * Math . log ( lambda ) ; }
public static double calculateAnalyticalLogLikelihood ( IntervalList intervals ) { if ( ! intervals . isCoalescentOnly ( ) ) { throw new IllegalArgumentException ( STRING ) ; } final double lambda = getLambda ( intervals ) ; final int n = intervals . getSampleCount ( ) ; return ( _NUM - n ) * Math . log ( lambda ) ; }
public static double calculateAnalyticalLogLikelihood ( IntervalList intervals ) { if ( ! intervals . isCoalescentOnly ( ) ) { throw new IllegalArgumentException ( STRING ) ; } final double lambda = getLambda ( intervals ) ; final int n = intervals . getSampleCount ( ) ; return ( _NUM - n ) * Math . log ( lambda ) ; }
public boolean add_via_padstack ( LibPadstack p_padstack ) { if ( p_padstack == null ) return _BOOL ; if ( get_via_padstack ( p_padstack . pads_name ) != null ) return _BOOL ; via_padstacks . add ( p_padstack ) ; return _BOOL ; }
public byte [ ] encodeFrame ( ) { int length = this . payload . length + frameLengthOverhead ; if ( this . payload . length > _NUM ) { length += _NUM ; } else if ( this . payload . length >= _NUM ) { length += _NUM ; } ByteBuffer buffer = ByteBuffer . allocate ( length ) ; appendFinAndOpCode ( buffer , this . opcode , this . fin ) ; byte mask [ ] = generateMaskingKey ( ) ; appendLengthAndMask ( buffer , this . payload . length , mask ) ; for ( int i = _NUM ; i < this . payload . length ; i ++ ) { buffer . put ( ( byte ) ( this . payload [ i ] ^= mask [ i % _NUM ] ) ) ; } buffer . flip ( ) ; return buffer . array ( ) ; }
private TypeConstraint combine ( TypeBound boundI , TypeBound boundJ ) { switch ( boundI . variance ) { case INV : switch ( boundJ . variance ) { case INV : return combineInvInv ( boundI , boundJ ) ; case CO : case CONTRA : return combineInvVar ( boundI , boundJ ) ; } break ; case CO : switch ( boundJ . variance ) { case INV : return combineInvVar ( boundJ , boundI ) ; case CONTRA : return combineContraCo ( boundJ , boundI ) ; case CO : return combineBothCoOrBothContra ( boundI , boundJ ) ; } break ; case CONTRA : switch ( boundJ . variance ) { case INV : return combineInvVar ( boundJ , boundI ) ; case CO : return combineContraCo ( boundI , boundJ ) ; case CONTRA : return combineBothCoOrBothContra ( boundI , boundJ ) ; } } throw new IllegalStateException ( STRING ) ; }
private TypeConstraint combine ( TypeBound boundI , TypeBound boundJ ) { switch ( boundI . variance ) { case INV : switch ( boundJ . variance ) { case INV : return combineInvInv ( boundI , boundJ ) ; case CO : case CONTRA : return combineInvVar ( boundI , boundJ ) ; } break ; case CO : switch ( boundJ . variance ) { case INV : return combineInvVar ( boundJ , boundI ) ; case CONTRA : return combineContraCo ( boundJ , boundI ) ; case CO : return combineBothCoOrBothContra ( boundI , boundJ ) ; } break ; case CONTRA : switch ( boundJ . variance ) { case INV : return combineInvVar ( boundJ , boundI ) ; case CO : return combineContraCo ( boundI , boundJ ) ; case CONTRA : return combineBothCoOrBothContra ( boundI , boundJ ) ; } } throw new IllegalStateException ( STRING ) ; }
public void shutdown ( ) { ExecutorService executor = Executors . newScheduledThreadPool ( _NUM ) ; executor . submit ( createShutdown ( _NUM ) ) ; }
protected void handleBouncing ( Mail mail ) throws MessagingException { mail . setState ( Mail . ERROR ) ; setMessageDeleted ( ) ; mail . setErrorMessage ( STRING + getFetchTaskName ( ) + STRING ) ; logStatusError ( STRING ) ; }
protected void handleBouncing ( Mail mail ) throws MessagingException { mail . setState ( Mail . ERROR ) ; setMessageDeleted ( ) ; mail . setErrorMessage ( STRING + getFetchTaskName ( ) + STRING ) ; logStatusError ( STRING ) ; }
public void removeColumn ( Column column ) { if ( column != null ) { columns . remove ( column ) ; } }
public static void initKeys ( KeyStore keystore , Properties props ) { if ( props . containsKey ( Configuration . WEBCALL_KAFKA_AES ) ) { byte [ ] key = keystore . decodeKey ( props . getProperty ( Configuration . WEBCALL_KAFKA_AES ) ) ; Preconditions . checkArgument ( ( _NUM == key . length || _NUM == key . length || _NUM == key . length ) , Configuration . WEBCALL_KAFKA_AES + STRING ) ; keystore . setKey ( KeyStore . AES_KAFKA_WEBCALL , key ) ; aesKey = key ; } if ( props . containsKey ( Configuration . WEBCALL_KAFKA_MAC ) ) { byte [ ] key = keystore . decodeKey ( props . getProperty ( Configuration . WEBCALL_KAFKA_MAC ) ) ; Preconditions . checkArgument ( ( _NUM == key . length ) , Configuration . WEBCALL_KAFKA_MAC + STRING ) ; keystore . setKey ( KeyStore . SIPHASH_KAFKA_WEBCALL , key ) ; siphashKey = key ; } }
private int assertPivotCountsAreCorrect ( String pivotName , SolrParams baseParams , PivotField constraint ) throws SolrServerException { SolrParams p = SolrParams . wrapAppended ( baseParams , params ( STRING , buildFilter ( constraint ) ) ) ; List < PivotField > subPivots = null ; try { assertNumFound ( pivotName , constraint . getCount ( ) , p ) ; subPivots = constraint . getPivot ( ) ; } catch ( Exception e ) { throw new RuntimeException ( pivotName + STRING + p + STRING + e . getMessage ( ) , e ) ; } int depth = _NUM ; if ( null != subPivots ) { assertTraceOk ( pivotName , baseParams , subPivots ) ; for ( PivotField subPivot : subPivots ) { depth = assertPivotCountsAreCorrect ( pivotName , p , subPivot ) ; } } return depth + _NUM ; }
private int assertPivotCountsAreCorrect ( String pivotName , SolrParams baseParams , PivotField constraint ) throws SolrServerException { SolrParams p = SolrParams . wrapAppended ( baseParams , params ( STRING , buildFilter ( constraint ) ) ) ; List < PivotField > subPivots = null ; try { assertNumFound ( pivotName , constraint . getCount ( ) , p ) ; subPivots = constraint . getPivot ( ) ; } catch ( Exception e ) { throw new RuntimeException ( pivotName + STRING + p + STRING + e . getMessage ( ) , e ) ; } int depth = _NUM ; if ( null != subPivots ) { assertTraceOk ( pivotName , baseParams , subPivots ) ; for ( PivotField subPivot : subPivots ) { depth = assertPivotCountsAreCorrect ( pivotName , p , subPivot ) ; } } return depth + _NUM ; }
private int assertPivotCountsAreCorrect ( String pivotName , SolrParams baseParams , PivotField constraint ) throws SolrServerException { SolrParams p = SolrParams . wrapAppended ( baseParams , params ( STRING , buildFilter ( constraint ) ) ) ; List < PivotField > subPivots = null ; try { assertNumFound ( pivotName , constraint . getCount ( ) , p ) ; subPivots = constraint . getPivot ( ) ; } catch ( Exception e ) { throw new RuntimeException ( pivotName + STRING + p + STRING + e . getMessage ( ) , e ) ; } int depth = _NUM ; if ( null != subPivots ) { assertTraceOk ( pivotName , baseParams , subPivots ) ; for ( PivotField subPivot : subPivots ) { depth = assertPivotCountsAreCorrect ( pivotName , p , subPivot ) ; } } return depth + _NUM ; }
private double calculateBarThickness ( Rectangle2D plotArea , RectangleEdge edge ) { double result ; if ( RectangleEdge . isLeftOrRight ( edge ) ) { result = plotArea . getWidth ( ) * this . colorBarThicknessPercent ; } else { result = plotArea . getHeight ( ) * this . colorBarThicknessPercent ; } return result ; }
public static Plane constructNormalizedZPlane ( final double x , final double y ) { if ( Math . abs ( x ) < MINIMUM_RESOLUTION && Math . abs ( y ) < MINIMUM_RESOLUTION ) return null ; final double denom = _NUM / Math . sqrt ( x * x + y * y ) ; return new Plane ( y * denom , - x * denom , _NUM , _NUM ) ; }
public synchronized void notifyDisconnected ( String title ) { connectedServerTitles . remove ( title ) ; updateNotification ( getString ( R . string . notification_disconnected , title ) , null , _BOOL , _BOOL , _BOOL ) ; }
public synchronized void notifyDisconnected ( String title ) { connectedServerTitles . remove ( title ) ; updateNotification ( getString ( R . string . notification_disconnected , title ) , null , _BOOL , _BOOL , _BOOL ) ; }
private void appendBuffer ( StringBuilder buffer , String name , String value ) { if ( buffer . length ( ) > _NUM ) { buffer . append ( STRING ) ; } String encodedName = URLEncoder . encode ( name ) ; buffer . append ( encodedName ) ; buffer . append ( STRING ) ; String encodedValue = URLEncoder . encode ( value ) ; buffer . append ( encodedValue ) ; }
private void appendBuffer ( StringBuilder buffer , String name , String value ) { if ( buffer . length ( ) > _NUM ) { buffer . append ( STRING ) ; } String encodedName = URLEncoder . encode ( name ) ; buffer . append ( encodedName ) ; buffer . append ( STRING ) ; String encodedValue = URLEncoder . encode ( value ) ; buffer . append ( encodedValue ) ; }
public static JSONObject readJSONObject ( final JSONObject jsonObject , final String key , final boolean required , final boolean notNull ) throws JSONException { if ( required ) { return jsonObject . getJSONObject ( key ) ; } if ( notNull && jsonObject . isNull ( key ) ) { throw new JSONException ( String . format ( Locale . US , NULL_VALUE_FORMAT_OBJECT , key ) ) ; } JSONObject value = null ; if ( ! jsonObject . isNull ( key ) ) { value = jsonObject . getJSONObject ( key ) ; } return value ; }
public void obtain ( ) throws IOException { if ( fileLock != null && fileLock . isValid ( ) ) { return ; } fileLock = fileToLock . lock ( ) ; }
public void dump_stack ( ) { if ( stack == null ) { debug_message ( STRING ) ; return ; } debug_message ( STRING ) ; for ( int i = _NUM ; i < stack . size ( ) ; i ++ ) { debug_message ( STRING + ( ( Symbol ) stack . elementAt ( i ) ) . sym + STRING + ( ( Symbol ) stack . elementAt ( i ) ) . parse_state ) ; } debug_message ( STRING ) ; }
public void dump_stack ( ) { if ( stack == null ) { debug_message ( STRING ) ; return ; } debug_message ( STRING ) ; for ( int i = _NUM ; i < stack . size ( ) ; i ++ ) { debug_message ( STRING + ( ( Symbol ) stack . elementAt ( i ) ) . sym + STRING + ( ( Symbol ) stack . elementAt ( i ) ) . parse_state ) ; } debug_message ( STRING ) ; }
public void addDefaultValue ( String value ) throws SMSException , SSOException { Set defaultValues = getDefaultValues ( ) ; if ( defaultValues != Collections . EMPTY_SET ) { defaultValues . add ( value ) ; } else { defaultValues = new HashSet ( ) ; defaultValues . add ( value ) ; } updateDefaultValues ( defaultValues ) ; }
public void expandToObjectAndSelect ( Object elementOrTreePath , int level ) { if ( checkBusy ( ) ) { return ; } Object parent = getParentElement ( elementOrTreePath ) ; if ( ( ( parent != null ) && getExpandedState ( parent ) ) || isRootElement ( elementOrTreePath ) ) { Widget w = internalGetWidgetToSelect ( elementOrTreePath ) ; if ( null != w ) { List < Object > selectionList = new ArrayList < > ( ) ; selectionList . add ( w ) ; setSelection ( selectionList ) ; objectToSelect . set ( null ) ; } else { objectToSelect . set ( elementOrTreePath ) ; } } else { objectToSelect . set ( elementOrTreePath ) ; List < Object > objectsToExpand = createObjectList ( parent , new ArrayList < > ( ) ) ; if ( ! objectsToExpand . isEmpty ( ) ) { objectsToBeExpanded . addAll ( objectsToExpand ) ; Widget w = internalExpand ( elementOrTreePath , _BOOL ) ; if ( w != null ) { internalExpandToLevel ( w , level ) ; } } else { Widget w = internalGetWidgetToSelect ( elementOrTreePath ) ; if ( null != w ) { List < Object > selectionList = new ArrayList < > ( ) ; selectionList . add ( w ) ; setSelection ( selectionList ) ; objectToSelect . set ( null ) ; } } } }
public void expandToObjectAndSelect ( Object elementOrTreePath , int level ) { if ( checkBusy ( ) ) { return ; } Object parent = getParentElement ( elementOrTreePath ) ; if ( ( ( parent != null ) && getExpandedState ( parent ) ) || isRootElement ( elementOrTreePath ) ) { Widget w = internalGetWidgetToSelect ( elementOrTreePath ) ; if ( null != w ) { List < Object > selectionList = new ArrayList < > ( ) ; selectionList . add ( w ) ; setSelection ( selectionList ) ; objectToSelect . set ( null ) ; } else { objectToSelect . set ( elementOrTreePath ) ; } } else { objectToSelect . set ( elementOrTreePath ) ; List < Object > objectsToExpand = createObjectList ( parent , new ArrayList < > ( ) ) ; if ( ! objectsToExpand . isEmpty ( ) ) { objectsToBeExpanded . addAll ( objectsToExpand ) ; Widget w = internalExpand ( elementOrTreePath , _BOOL ) ; if ( w != null ) { internalExpandToLevel ( w , level ) ; } } else { Widget w = internalGetWidgetToSelect ( elementOrTreePath ) ; if ( null != w ) { List < Object > selectionList = new ArrayList < > ( ) ; selectionList . add ( w ) ; setSelection ( selectionList ) ; objectToSelect . set ( null ) ; } } } }
public void expandToObjectAndSelect ( Object elementOrTreePath , int level ) { if ( checkBusy ( ) ) { return ; } Object parent = getParentElement ( elementOrTreePath ) ; if ( ( ( parent != null ) && getExpandedState ( parent ) ) || isRootElement ( elementOrTreePath ) ) { Widget w = internalGetWidgetToSelect ( elementOrTreePath ) ; if ( null != w ) { List < Object > selectionList = new ArrayList < > ( ) ; selectionList . add ( w ) ; setSelection ( selectionList ) ; objectToSelect . set ( null ) ; } else { objectToSelect . set ( elementOrTreePath ) ; } } else { objectToSelect . set ( elementOrTreePath ) ; List < Object > objectsToExpand = createObjectList ( parent , new ArrayList < > ( ) ) ; if ( ! objectsToExpand . isEmpty ( ) ) { objectsToBeExpanded . addAll ( objectsToExpand ) ; Widget w = internalExpand ( elementOrTreePath , _BOOL ) ; if ( w != null ) { internalExpandToLevel ( w , level ) ; } } else { Widget w = internalGetWidgetToSelect ( elementOrTreePath ) ; if ( null != w ) { List < Object > selectionList = new ArrayList < > ( ) ; selectionList . add ( w ) ; setSelection ( selectionList ) ; objectToSelect . set ( null ) ; } } } }
public void expandToObjectAndSelect ( Object elementOrTreePath , int level ) { if ( checkBusy ( ) ) { return ; } Object parent = getParentElement ( elementOrTreePath ) ; if ( ( ( parent != null ) && getExpandedState ( parent ) ) || isRootElement ( elementOrTreePath ) ) { Widget w = internalGetWidgetToSelect ( elementOrTreePath ) ; if ( null != w ) { List < Object > selectionList = new ArrayList < > ( ) ; selectionList . add ( w ) ; setSelection ( selectionList ) ; objectToSelect . set ( null ) ; } else { objectToSelect . set ( elementOrTreePath ) ; } } else { objectToSelect . set ( elementOrTreePath ) ; List < Object > objectsToExpand = createObjectList ( parent , new ArrayList < > ( ) ) ; if ( ! objectsToExpand . isEmpty ( ) ) { objectsToBeExpanded . addAll ( objectsToExpand ) ; Widget w = internalExpand ( elementOrTreePath , _BOOL ) ; if ( w != null ) { internalExpandToLevel ( w , level ) ; } } else { Widget w = internalGetWidgetToSelect ( elementOrTreePath ) ; if ( null != w ) { List < Object > selectionList = new ArrayList < > ( ) ; selectionList . add ( w ) ; setSelection ( selectionList ) ; objectToSelect . set ( null ) ; } } } }
public void expandToObjectAndSelect ( Object elementOrTreePath , int level ) { if ( checkBusy ( ) ) { return ; } Object parent = getParentElement ( elementOrTreePath ) ; if ( ( ( parent != null ) && getExpandedState ( parent ) ) || isRootElement ( elementOrTreePath ) ) { Widget w = internalGetWidgetToSelect ( elementOrTreePath ) ; if ( null != w ) { List < Object > selectionList = new ArrayList < > ( ) ; selectionList . add ( w ) ; setSelection ( selectionList ) ; objectToSelect . set ( null ) ; } else { objectToSelect . set ( elementOrTreePath ) ; } } else { objectToSelect . set ( elementOrTreePath ) ; List < Object > objectsToExpand = createObjectList ( parent , new ArrayList < > ( ) ) ; if ( ! objectsToExpand . isEmpty ( ) ) { objectsToBeExpanded . addAll ( objectsToExpand ) ; Widget w = internalExpand ( elementOrTreePath , _BOOL ) ; if ( w != null ) { internalExpandToLevel ( w , level ) ; } } else { Widget w = internalGetWidgetToSelect ( elementOrTreePath ) ; if ( null != w ) { List < Object > selectionList = new ArrayList < > ( ) ; selectionList . add ( w ) ; setSelection ( selectionList ) ; objectToSelect . set ( null ) ; } } } }
private void interruptIdleWorkers ( boolean onlyOne ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { for ( Worker w : workers ) { Thread t = w . thread ; if ( ! t . isInterrupted ( ) && w . tryLock ( ) ) { try { t . interrupt ( ) ; } catch ( SecurityException ignore ) { } finally { w . unlock ( ) ; } } if ( onlyOne ) break ; } } finally { mainLock . unlock ( ) ; } }
private void interruptIdleWorkers ( boolean onlyOne ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { for ( Worker w : workers ) { Thread t = w . thread ; if ( ! t . isInterrupted ( ) && w . tryLock ( ) ) { try { t . interrupt ( ) ; } catch ( SecurityException ignore ) { } finally { w . unlock ( ) ; } } if ( onlyOne ) break ; } } finally { mainLock . unlock ( ) ; } }
public SearchSourceBuilder fieldDataField ( String name ) { if ( fieldDataFields == null ) { fieldDataFields = new ArrayList < > ( ) ; } fieldDataFields . add ( name ) ; return this ; }
public SearchSourceBuilder fieldDataField ( String name ) { if ( fieldDataFields == null ) { fieldDataFields = new ArrayList < > ( ) ; } fieldDataFields . add ( name ) ; return this ; }
private void removeIgnore ( RPObject ignoreObj ) { for ( String attr : ignoreObj ) { if ( attr . charAt ( _NUM ) == STRING ) { ignore . remove ( attr . substring ( _NUM ) ) ; } } }
private void removeIgnore ( RPObject ignoreObj ) { for ( String attr : ignoreObj ) { if ( attr . charAt ( _NUM ) == STRING ) { ignore . remove ( attr . substring ( _NUM ) ) ; } } }
public static Kernel createKernel ( int kernelType ) { switch ( kernelType ) { case KERNEL_RADIAL : return new KernelRadial ( ) ; case KERNEL_POLYNOMIAL : return new KernelPolynomial ( ) ; case KERNEL_NEURAL : return new KernelNeural ( ) ; default : return new KernelDot ( ) ; } }
public boolean loopback ( ) { try { return _myMulticastSocket . getLoopbackMode ( ) ; } catch ( SocketException se ) { Logger . printError ( STRING , STRING + se ) ; } return _BOOL ; }
private void oops ( String what , int lineno , int override , Throwable t ) throws ConfigurationException { ErrorDescriptor error = new ErrorDescriptor ( lineno , override , what , location , t ) ; throwConfigurationException ( new ConfigurationException ( error . toString ( ) , t ) , Collections . singletonList ( error ) ) ; throw new AssertionError ( STRING + STRING ) ; }
private void adjustForTopFadingEdge ( View childInSelectedRow , int topSelectionPixel , int bottomSelectionPixel ) { if ( childInSelectedRow . getTop ( ) < topSelectionPixel ) { int spaceAbove = topSelectionPixel - childInSelectedRow . getTop ( ) ; int spaceBelow = bottomSelectionPixel - childInSelectedRow . getBottom ( ) ; int offset = Math . min ( spaceAbove , spaceBelow ) ; offsetChildrenTopAndBottom ( offset ) ; } }
private void adjustForTopFadingEdge ( View childInSelectedRow , int topSelectionPixel , int bottomSelectionPixel ) { if ( childInSelectedRow . getTop ( ) < topSelectionPixel ) { int spaceAbove = topSelectionPixel - childInSelectedRow . getTop ( ) ; int spaceBelow = bottomSelectionPixel - childInSelectedRow . getBottom ( ) ; int offset = Math . min ( spaceAbove , spaceBelow ) ; offsetChildrenTopAndBottom ( offset ) ; } }
private void adjustForTopFadingEdge ( View childInSelectedRow , int topSelectionPixel , int bottomSelectionPixel ) { if ( childInSelectedRow . getTop ( ) < topSelectionPixel ) { int spaceAbove = topSelectionPixel - childInSelectedRow . getTop ( ) ; int spaceBelow = bottomSelectionPixel - childInSelectedRow . getBottom ( ) ; int offset = Math . min ( spaceAbove , spaceBelow ) ; offsetChildrenTopAndBottom ( offset ) ; } }
private void adjustForTopFadingEdge ( View childInSelectedRow , int topSelectionPixel , int bottomSelectionPixel ) { if ( childInSelectedRow . getTop ( ) < topSelectionPixel ) { int spaceAbove = topSelectionPixel - childInSelectedRow . getTop ( ) ; int spaceBelow = bottomSelectionPixel - childInSelectedRow . getBottom ( ) ; int offset = Math . min ( spaceAbove , spaceBelow ) ; offsetChildrenTopAndBottom ( offset ) ; } }
private void adjustForTopFadingEdge ( View childInSelectedRow , int topSelectionPixel , int bottomSelectionPixel ) { if ( childInSelectedRow . getTop ( ) < topSelectionPixel ) { int spaceAbove = topSelectionPixel - childInSelectedRow . getTop ( ) ; int spaceBelow = bottomSelectionPixel - childInSelectedRow . getBottom ( ) ; int offset = Math . min ( spaceAbove , spaceBelow ) ; offsetChildrenTopAndBottom ( offset ) ; } }
private void adjustForTopFadingEdge ( View childInSelectedRow , int topSelectionPixel , int bottomSelectionPixel ) { if ( childInSelectedRow . getTop ( ) < topSelectionPixel ) { int spaceAbove = topSelectionPixel - childInSelectedRow . getTop ( ) ; int spaceBelow = bottomSelectionPixel - childInSelectedRow . getBottom ( ) ; int offset = Math . min ( spaceAbove , spaceBelow ) ; offsetChildrenTopAndBottom ( offset ) ; } }
public boolean isOpaqueCube ( IBlockState state ) { return _BOOL ; }
public boolean isOpaqueCube ( IBlockState state ) { return _BOOL ; }
private final void populateNameList ( final Argument arg , final List < Object > nameList ) { List < Object > valueObjList = ( List < Object > ) arg . getValue ( ) ; for ( Object valargobj : valueObjList ) { Argument valarg = ( Argument ) valargobj ; nameList . add ( valarg . getName ( ) ) ; } }
private final void populateNameList ( final Argument arg , final List < Object > nameList ) { List < Object > valueObjList = ( List < Object > ) arg . getValue ( ) ; for ( Object valargobj : valueObjList ) { Argument valarg = ( Argument ) valargobj ; nameList . add ( valarg . getName ( ) ) ; } }
CollationEqualityMatchingRuleImpl ( Locale locale ) { super ( locale ) ; }
public void testWriteReadEmpty ( ) throws Exception { ByteArrayOutputStream out = new ByteArrayOutputStream ( _NUM ) ; ObjectOutputStream os = new ObjectOutputStream ( out ) ; os . writeObject ( empty ) ; ObjectInputStream is = new ObjectInputStream ( new ByteArrayInputStream ( out . toByteArray ( ) ) ) ; FailOverPolicy . FailOverPolicyDescription copy = ( FailOverPolicy . FailOverPolicyDescription ) is . readObject ( ) ; is . close ( ) ; os . close ( ) ; assertNull ( copy . m_BackupMemberNames ) ; assertNull ( copy . m_BackupOnly ) ; assertEquals ( - _NUM , copy . m_PolicyType ) ; }
public static void deleteFile ( final File file , final boolean deleteDir ) { if ( file . isDirectory ( ) ) { for ( final File subFile : file . listFiles ( ) ) { deleteFile ( subFile , _BOOL ) ; } if ( deleteDir ) { file . delete ( ) ; } } else { file . delete ( ) ; } }
@ Override public ShapeTile [ ] split_to_convex ( ) { if ( precalculated_convex_pieces != null ) return precalculated_convex_pieces ; random_generator . setSeed ( seed ) ; Collection < ShapePolygon > convex_pieces = split_to_convex_recu ( ) ; if ( convex_pieces == null ) { return null ; } precalculated_convex_pieces = new ShapeTile [ convex_pieces . size ( ) ] ; Iterator < ShapePolygon > it = convex_pieces . iterator ( ) ; for ( int i = _NUM ; i < precalculated_convex_pieces . length ; ++ i ) { ShapePolygon curr_piece = it . next ( ) ; precalculated_convex_pieces [ i ] = ShapeTile . get_instance ( curr_piece . corners ) ; } return precalculated_convex_pieces ; }
@ Override public ShapeTile [ ] split_to_convex ( ) { if ( precalculated_convex_pieces != null ) return precalculated_convex_pieces ; random_generator . setSeed ( seed ) ; Collection < ShapePolygon > convex_pieces = split_to_convex_recu ( ) ; if ( convex_pieces == null ) { return null ; } precalculated_convex_pieces = new ShapeTile [ convex_pieces . size ( ) ] ; Iterator < ShapePolygon > it = convex_pieces . iterator ( ) ; for ( int i = _NUM ; i < precalculated_convex_pieces . length ; ++ i ) { ShapePolygon curr_piece = it . next ( ) ; precalculated_convex_pieces [ i ] = ShapeTile . get_instance ( curr_piece . corners ) ; } return precalculated_convex_pieces ; }
@ Override public ShapeTile [ ] split_to_convex ( ) { if ( precalculated_convex_pieces != null ) return precalculated_convex_pieces ; random_generator . setSeed ( seed ) ; Collection < ShapePolygon > convex_pieces = split_to_convex_recu ( ) ; if ( convex_pieces == null ) { return null ; } precalculated_convex_pieces = new ShapeTile [ convex_pieces . size ( ) ] ; Iterator < ShapePolygon > it = convex_pieces . iterator ( ) ; for ( int i = _NUM ; i < precalculated_convex_pieces . length ; ++ i ) { ShapePolygon curr_piece = it . next ( ) ; precalculated_convex_pieces [ i ] = ShapeTile . get_instance ( curr_piece . corners ) ; } return precalculated_convex_pieces ; }
@ Override public ShapeTile [ ] split_to_convex ( ) { if ( precalculated_convex_pieces != null ) return precalculated_convex_pieces ; random_generator . setSeed ( seed ) ; Collection < ShapePolygon > convex_pieces = split_to_convex_recu ( ) ; if ( convex_pieces == null ) { return null ; } precalculated_convex_pieces = new ShapeTile [ convex_pieces . size ( ) ] ; Iterator < ShapePolygon > it = convex_pieces . iterator ( ) ; for ( int i = _NUM ; i < precalculated_convex_pieces . length ; ++ i ) { ShapePolygon curr_piece = it . next ( ) ; precalculated_convex_pieces [ i ] = ShapeTile . get_instance ( curr_piece . corners ) ; } return precalculated_convex_pieces ; }
public static boolean implementsZeroArgMethod ( ClassNode classNode , String methodName ) { return implementsMethod ( classNode , methodName , new Class [ _NUM ] ) ; }
public static boolean implementsZeroArgMethod ( ClassNode classNode , String methodName ) { return implementsMethod ( classNode , methodName , new Class [ _NUM ] ) ; }
private void indexCRL ( X509CRL crl ) { X500Principal issuer = crl . getIssuerX500Principal ( ) ; Object oldEntry = crlIssuers . put ( issuer , crl ) ; if ( oldEntry != null ) { if ( oldEntry instanceof X509CRL ) { if ( crl . equals ( oldEntry ) ) { return ; } List < X509CRL > list = new ArrayList < > ( _NUM ) ; list . add ( crl ) ; list . add ( ( X509CRL ) oldEntry ) ; crlIssuers . put ( issuer , list ) ; } else { @ SuppressWarnings ( STRING ) List < X509CRL > list = ( List < X509CRL > ) oldEntry ; if ( list . contains ( crl ) == _BOOL ) { list . add ( crl ) ; } crlIssuers . put ( issuer , list ) ; } } }
public Builder addSubButton ( Drawable drawable , int [ ] twoColors ) { if ( drawables == null ) drawables = new ArrayList < > ( ) ; drawables . add ( drawable ) ; if ( colors == null ) colors = new ArrayList < > ( ) ; colors . add ( twoColors ) ; return this ; }
public boolean nextLine ( ) throws IOException { while ( reader . readLine ( buf . delete ( _NUM , buf . length ( ) ) ) ) { ++ lineNumber ; if ( lengthWithoutLinefeed ( buf ) > _NUM ) { return _BOOL ; } } return _BOOL ; }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_ioThread . isAlive ( ) && m_state != IDLE ) { wait ( ) ; } } catch ( InterruptedException ex ) { } } else { notifyAll ( ) ; } }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_ioThread . isAlive ( ) && m_state != IDLE ) { wait ( ) ; } } catch ( InterruptedException ex ) { } } else { notifyAll ( ) ; } }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_ioThread . isAlive ( ) && m_state != IDLE ) { wait ( ) ; } } catch ( InterruptedException ex ) { } } else { notifyAll ( ) ; } }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_ioThread . isAlive ( ) && m_state != IDLE ) { wait ( ) ; } } catch ( InterruptedException ex ) { } } else { notifyAll ( ) ; } }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_ioThread . isAlive ( ) && m_state != IDLE ) { wait ( ) ; } } catch ( InterruptedException ex ) { } } else { notifyAll ( ) ; } }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_ioThread . isAlive ( ) && m_state != IDLE ) { wait ( ) ; } } catch ( InterruptedException ex ) { } } else { notifyAll ( ) ; } }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_ioThread . isAlive ( ) && m_state != IDLE ) { wait ( ) ; } } catch ( InterruptedException ex ) { } } else { notifyAll ( ) ; } }
public byte readByteLE ( ) throws IOException { return inputStream . readByte ( ) ; }
public byte readByteLE ( ) throws IOException { return inputStream . readByte ( ) ; }
public byte readByteLE ( ) throws IOException { return inputStream . readByte ( ) ; }
private void computeAreas ( NodeItem root ) { int leafCount = _NUM ; Graph g = ( Graph ) m_vis . getGroup ( m_group ) ; TupleSet nodes = g . getNodes ( ) ; nodes . addColumns ( AREA_SCHEMA ) ; Iterator iter = new TreeNodeIterator ( root ) ; while ( iter . hasNext ( ) ) { NodeItem n = ( NodeItem ) iter . next ( ) ; n . setDouble ( AREA , _NUM ) ; } iter = new TreeNodeIterator ( root , _BOOL ) ; while ( iter . hasNext ( ) ) { NodeItem n = ( NodeItem ) iter . next ( ) ; double area = _NUM ; if ( n . getChildCount ( ) == _NUM ) { area = n . getSize ( ) ; ++ leafCount ; } else if ( n . isExpanded ( ) ) { NodeItem c = ( NodeItem ) n . getFirstChild ( ) ; for ( ; c != null ; c = ( NodeItem ) c . getNextSibling ( ) ) { area += c . getDouble ( AREA ) ; ++ leafCount ; } } n . setDouble ( AREA , area ) ; } Rectangle2D b = getLayoutBounds ( ) ; double area = ( b . getWidth ( ) - _NUM ) * ( b . getHeight ( ) - _NUM ) ; double scale = area / root . getDouble ( AREA ) ; iter = new TreeNodeIterator ( root ) ; while ( iter . hasNext ( ) ) { NodeItem n = ( NodeItem ) iter . next ( ) ; n . setDouble ( AREA , n . getDouble ( AREA ) * scale ) ; } }
public int update ( String table , ContentValues values , String whereClause , String [ ] whereArgs ) { verifyDbIsOpen ( ) ; if ( values == null || values . size ( ) == _NUM ) { throw new IllegalArgumentException ( STRING ) ; } StringBuilder sql = new StringBuilder ( _NUM ) ; sql . append ( STRING ) ; sql . append ( table ) ; sql . append ( STRING ) ; int setValuesSize = values . size ( ) ; int bindArgsSize = ( whereArgs == null ) ? setValuesSize : ( setValuesSize + whereArgs . length ) ; Object [ ] bindArgs = new Object [ bindArgsSize ] ; int i = _NUM ; for ( String colName : values . keySet ( ) ) { sql . append ( ( i > _NUM ) ? STRING : STRING ) ; sql . append ( colName ) ; bindArgs [ i ++ ] = values . get ( colName ) ; sql . append ( STRING ) ; } if ( whereArgs != null ) { for ( i = setValuesSize ; i < bindArgsSize ; i ++ ) { bindArgs [ i ] = whereArgs [ i - setValuesSize ] ; } } if ( ! StringUtils . isEmpty ( whereClause ) ) { sql . append ( STRING ) ; sql . append ( whereClause ) ; } return executeSql ( sql . toString ( ) , bindArgs ) ; }
public int update ( String table , ContentValues values , String whereClause , String [ ] whereArgs ) { verifyDbIsOpen ( ) ; if ( values == null || values . size ( ) == _NUM ) { throw new IllegalArgumentException ( STRING ) ; } StringBuilder sql = new StringBuilder ( _NUM ) ; sql . append ( STRING ) ; sql . append ( table ) ; sql . append ( STRING ) ; int setValuesSize = values . size ( ) ; int bindArgsSize = ( whereArgs == null ) ? setValuesSize : ( setValuesSize + whereArgs . length ) ; Object [ ] bindArgs = new Object [ bindArgsSize ] ; int i = _NUM ; for ( String colName : values . keySet ( ) ) { sql . append ( ( i > _NUM ) ? STRING : STRING ) ; sql . append ( colName ) ; bindArgs [ i ++ ] = values . get ( colName ) ; sql . append ( STRING ) ; } if ( whereArgs != null ) { for ( i = setValuesSize ; i < bindArgsSize ; i ++ ) { bindArgs [ i ] = whereArgs [ i - setValuesSize ] ; } } if ( ! StringUtils . isEmpty ( whereClause ) ) { sql . append ( STRING ) ; sql . append ( whereClause ) ; } return executeSql ( sql . toString ( ) , bindArgs ) ; }
public Vector2 round ( ) { return new Vector2 ( Math . round ( x ) , Math . round ( z ) ) ; }
private ServerPod [ ] buildServers ( int serverCount ) { ArrayList < ServerPod > serversPod = new ArrayList < > ( ) ; for ( int i = _NUM ; i < serverCount ; i ++ ) { if ( i < _serverList . size ( ) ) { serversPod . add ( _serverList . get ( i ) ) ; } else { serversPod . add ( new ServerPod ( i ) ) ; } } ServerPod [ ] serverArray = new ServerPod [ serverCount ] ; for ( int i = _NUM ; i < serverCount ; i ++ ) { serverArray [ i ] = serversPod . get ( i ) ; } return serverArray ; }
private ServerPod [ ] buildServers ( int serverCount ) { ArrayList < ServerPod > serversPod = new ArrayList < > ( ) ; for ( int i = _NUM ; i < serverCount ; i ++ ) { if ( i < _serverList . size ( ) ) { serversPod . add ( _serverList . get ( i ) ) ; } else { serversPod . add ( new ServerPod ( i ) ) ; } } ServerPod [ ] serverArray = new ServerPod [ serverCount ] ; for ( int i = _NUM ; i < serverCount ; i ++ ) { serverArray [ i ] = serversPod . get ( i ) ; } return serverArray ; }
private ServerPod [ ] buildServers ( int serverCount ) { ArrayList < ServerPod > serversPod = new ArrayList < > ( ) ; for ( int i = _NUM ; i < serverCount ; i ++ ) { if ( i < _serverList . size ( ) ) { serversPod . add ( _serverList . get ( i ) ) ; } else { serversPod . add ( new ServerPod ( i ) ) ; } } ServerPod [ ] serverArray = new ServerPod [ serverCount ] ; for ( int i = _NUM ; i < serverCount ; i ++ ) { serverArray [ i ] = serversPod . get ( i ) ; } return serverArray ; }
private ServerPod [ ] buildServers ( int serverCount ) { ArrayList < ServerPod > serversPod = new ArrayList < > ( ) ; for ( int i = _NUM ; i < serverCount ; i ++ ) { if ( i < _serverList . size ( ) ) { serversPod . add ( _serverList . get ( i ) ) ; } else { serversPod . add ( new ServerPod ( i ) ) ; } } ServerPod [ ] serverArray = new ServerPod [ serverCount ] ; for ( int i = _NUM ; i < serverCount ; i ++ ) { serverArray [ i ] = serversPod . get ( i ) ; } return serverArray ; }
private ServerPod [ ] buildServers ( int serverCount ) { ArrayList < ServerPod > serversPod = new ArrayList < > ( ) ; for ( int i = _NUM ; i < serverCount ; i ++ ) { if ( i < _serverList . size ( ) ) { serversPod . add ( _serverList . get ( i ) ) ; } else { serversPod . add ( new ServerPod ( i ) ) ; } } ServerPod [ ] serverArray = new ServerPod [ serverCount ] ; for ( int i = _NUM ; i < serverCount ; i ++ ) { serverArray [ i ] = serversPod . get ( i ) ; } return serverArray ; }
public BoundingBox unifyWith ( BoundingBox bb ) { latMin = Math . min ( latMin , bb . latMin ) ; lonMin = Math . min ( lonMin , bb . lonMin ) ; latMax = Math . max ( latMax , bb . latMax ) ; lonMax = Math . max ( lonMax , bb . lonMax ) ; return this ; }
public BoundingBox unifyWith ( BoundingBox bb ) { latMin = Math . min ( latMin , bb . latMin ) ; lonMin = Math . min ( lonMin , bb . lonMin ) ; latMax = Math . max ( latMax , bb . latMax ) ; lonMax = Math . max ( lonMax , bb . lonMax ) ; return this ; }
public ReceiveFileTransfer acceptFileTransfer ( IncomingFileTransferEvent event , File destination ) throws IOException { checkNotNull ( event , STRING ) ; checkNotNull ( destination , STRING ) ; return acceptFileTransfer ( event , destination , _NUM ) ; }
public static void installResponseCache ( String baseURL , File cacheDir , boolean checkForUpdates ) { ResponseCache . setDefault ( new LocalResponseCache ( baseURL , cacheDir , checkForUpdates ) ) ; }
public OneToOneChatSession createOneToOneChatSession ( ContactId contact , ChatMessage firstMsg ) { if ( sLogger . isActivated ( ) ) { sLogger . info ( STRING + contact + STRING ) ; } long timestamp = firstMsg . getTimestamp ( ) ; return new OriginatingOneToOneChatSession ( this , contact , firstMsg , mRcsSettings , mMessagingLog , timestamp , mContactManager ) ; }
private static float saturate ( float f ) { return Math . max ( _NUM , Math . min ( _NUM , f ) ) ; }
static String plurals ( final String s , final Integer i ) { return i == null ? UNKNOWN + STRING + s + STRING : i . intValue ( ) != _NUM ? i + STRING + s + STRING : STRING + s ; }
static String plurals ( final String s , final Integer i ) { return i == null ? UNKNOWN + STRING + s + STRING : i . intValue ( ) != _NUM ? i + STRING + s + STRING : STRING + s ; }
static String plurals ( final String s , final Integer i ) { return i == null ? UNKNOWN + STRING + s + STRING : i . intValue ( ) != _NUM ? i + STRING + s + STRING : STRING + s ; }
static String plurals ( final String s , final Integer i ) { return i == null ? UNKNOWN + STRING + s + STRING : i . intValue ( ) != _NUM ? i + STRING + s + STRING : STRING + s ; }
private String linePrinter ( List < TextRead > textReads , boolean bs , boolean noFormat , boolean withReadName ) throws IOException { StringBuilder sb = new StringBuilder ( ) ; int curPos = _NUM ; for ( TextRead tr : textReads ) { sb . append ( StringUtils . repeat ( STRING , ( tr . getTextStart ( ) - _NUM ) - curPos ) ) ; String printableRead = tr . getPrintableTextRead ( bs , noFormat , withReadName ) ; sb . append ( printableRead ) ; curPos = tr . getTextEnd ( ) ; } return sb . toString ( ) ; }
public void createTimer ( ) { Timer t = new Timer ( updateInterval , null ) ; t . setInitialDelay ( initialDelay ) ; setTimer ( t ) ; }
private XMLStreamReader newXMLStreamReader ( ) { try { return XML_INPUT_FACTORY . createXMLStreamReader ( new ByteArrayInputStream ( xml ) , STRING ) ; } catch ( Exception xmlEx ) { throw XMLTreeException . wrap ( xmlEx ) ; } }
public void remove ( final int start , final int end ) { checkWidget ( ) ; if ( start > end ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } for ( int index = start ; index < end ; index ++ ) { if ( index < _NUM || index >= items . size ( ) ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } items . remove ( index ) ; } redrawTables ( ) ; }
public void addActiveHandler ( ContentHandler handler , ModeUsage attributeModeUsage ) { activeHandlers . addElement ( handler ) ; activeHandlersAttributeModeUsage . addElement ( attributeModeUsage ) ; attributeProcessing = Math . max ( attributeProcessing , attributeModeUsage . getAttributeProcessing ( ) ) ; if ( attributeModeUsage . isContextDependent ( ) ) contextDependent = _BOOL ; }
public synchronized SiteNode addPath ( HistoryReference ref ) { if ( Constant . isLowMemoryOptionSet ( ) ) { throw new InvalidParameterException ( STRING ) ; } HttpMessage msg = null ; try { msg = ref . getHttpMessage ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } return addPath ( ref , msg ) ; }
public ArrayRealVector ( int size , double preset ) { data = new double [ size ] ; Arrays . fill ( data , preset ) ; }
public static boolean isYouTubeUrl ( String url ) { if ( TextUtils . isEmpty ( url ) ) { return _BOOL ; } Uri uri = Uri . parse ( url ) ; String authority = uri . getAuthority ( ) ; if ( ! TextUtils . isEmpty ( authority ) && authority . contains ( STRING ) ) { return _BOOL ; } else { return _BOOL ; } }
public static boolean isYouTubeUrl ( String url ) { if ( TextUtils . isEmpty ( url ) ) { return _BOOL ; } Uri uri = Uri . parse ( url ) ; String authority = uri . getAuthority ( ) ; if ( ! TextUtils . isEmpty ( authority ) && authority . contains ( STRING ) ) { return _BOOL ; } else { return _BOOL ; } }
@ Override public void agg ( Object newVal ) { valueSet . add ( newVal instanceof BigDecimal ? ( BigDecimal ) newVal : new BigDecimal ( newVal . toString ( ) ) ) ; firstTime = _BOOL ; }
@ Override public void agg ( Object newVal ) { valueSet . add ( newVal instanceof BigDecimal ? ( BigDecimal ) newVal : new BigDecimal ( newVal . toString ( ) ) ) ; firstTime = _BOOL ; }
private static void writeSetting ( final CConnection connection , final int containerId , final String key , final String value , final String table ) throws CouldntSaveDataException { String id_column = STRING ; if ( table . equalsIgnoreCase ( CTableNames . MODULE_SETTINGS_TABLE ) ) { id_column = STRING ; } else { id_column = STRING ; } final String deleteQuery = STRING + table + STRING + id_column + STRING + containerId + STRING + key + STRING ; final String insertQuery = STRING + table + STRING + containerId + STRING + key + STRING + value + STRING ; try { PostgreSQLHelpers . beginTransaction ( connection ) ; connection . executeUpdate ( deleteQuery , _BOOL ) ; connection . executeUpdate ( insertQuery , _BOOL ) ; PostgreSQLHelpers . endTransaction ( connection ) ; } catch ( final SQLException exception ) { throw new CouldntSaveDataException ( STRING + table ) ; } }
protected void CreateKeys ( OffsetItem fdarrayRef , OffsetItem fdselectRef , OffsetItem charsetRef , OffsetItem charstringsRef ) { OutputList . addLast ( fdarrayRef ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( fdselectRef ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( charsetRef ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( charstringsRef ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; }
protected void CreateKeys ( OffsetItem fdarrayRef , OffsetItem fdselectRef , OffsetItem charsetRef , OffsetItem charstringsRef ) { OutputList . addLast ( fdarrayRef ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( fdselectRef ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( charsetRef ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( charstringsRef ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; }
@ MethodDesc ( description = STRING , usage = STRING ) public Map < String , String > replicatorStatus ( @ ParamDesc ( name = STRING , description = STRING ) String name ) throws Exception { OpenReplicatorManagerMBean mgr = replicators . get ( name ) ; if ( mgr == null ) { throw new Exception ( String . format ( STRING , name ) ) ; } return mgr . status ( ) ; }
@ MethodDesc ( description = STRING , usage = STRING ) public Map < String , String > replicatorStatus ( @ ParamDesc ( name = STRING , description = STRING ) String name ) throws Exception { OpenReplicatorManagerMBean mgr = replicators . get ( name ) ; if ( mgr == null ) { throw new Exception ( String . format ( STRING , name ) ) ; } return mgr . status ( ) ; }
protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * MILLISECONDS_PER_PX ) ; }
protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * MILLISECONDS_PER_PX ) ; }
public PWResetException ( Throwable t ) { super ( t ) ; errList = new ArrayList ( _NUM ) ; errList . add ( t . getMessage ( ) ) ; }
public static void sort ( int [ ] a ) { doSort ( a , _NUM , a . length - _NUM ) ; }
public static String encode ( Serializable o ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; try { ObjectOutputStream oos = new ObjectOutputStream ( bos ) ; try { oos . writeObject ( o ) ; oos . flush ( ) ; } finally { oos . close ( ) ; } return Base64 . encodeBytes ( bos . toByteArray ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
@ Override public boolean incrementToken ( ) throws IOException { if ( savedState != null ) { restoreState ( savedState ) ; savedState = null ; saveTermBuffer ( ) ; return _BOOL ; } else if ( ! input . incrementToken ( ) ) { return _BOOL ; } if ( lastWasCommon || ( isCommon ( ) && buffer . length ( ) > _NUM ) ) { savedState = captureState ( ) ; gramToken ( ) ; return _BOOL ; } saveTermBuffer ( ) ; return _BOOL ; }
@ Override public boolean incrementToken ( ) throws IOException { if ( savedState != null ) { restoreState ( savedState ) ; savedState = null ; saveTermBuffer ( ) ; return _BOOL ; } else if ( ! input . incrementToken ( ) ) { return _BOOL ; } if ( lastWasCommon || ( isCommon ( ) && buffer . length ( ) > _NUM ) ) { savedState = captureState ( ) ; gramToken ( ) ; return _BOOL ; } saveTermBuffer ( ) ; return _BOOL ; }
@ Override public boolean incrementToken ( ) throws IOException { if ( savedState != null ) { restoreState ( savedState ) ; savedState = null ; saveTermBuffer ( ) ; return _BOOL ; } else if ( ! input . incrementToken ( ) ) { return _BOOL ; } if ( lastWasCommon || ( isCommon ( ) && buffer . length ( ) > _NUM ) ) { savedState = captureState ( ) ; gramToken ( ) ; return _BOOL ; } saveTermBuffer ( ) ; return _BOOL ; }
@ Override public boolean incrementToken ( ) throws IOException { if ( savedState != null ) { restoreState ( savedState ) ; savedState = null ; saveTermBuffer ( ) ; return _BOOL ; } else if ( ! input . incrementToken ( ) ) { return _BOOL ; } if ( lastWasCommon || ( isCommon ( ) && buffer . length ( ) > _NUM ) ) { savedState = captureState ( ) ; gramToken ( ) ; return _BOOL ; } saveTermBuffer ( ) ; return _BOOL ; }
@ Override public boolean incrementToken ( ) throws IOException { if ( savedState != null ) { restoreState ( savedState ) ; savedState = null ; saveTermBuffer ( ) ; return _BOOL ; } else if ( ! input . incrementToken ( ) ) { return _BOOL ; } if ( lastWasCommon || ( isCommon ( ) && buffer . length ( ) > _NUM ) ) { savedState = captureState ( ) ; gramToken ( ) ; return _BOOL ; } saveTermBuffer ( ) ; return _BOOL ; }
@ Override public boolean incrementToken ( ) throws IOException { if ( savedState != null ) { restoreState ( savedState ) ; savedState = null ; saveTermBuffer ( ) ; return _BOOL ; } else if ( ! input . incrementToken ( ) ) { return _BOOL ; } if ( lastWasCommon || ( isCommon ( ) && buffer . length ( ) > _NUM ) ) { savedState = captureState ( ) ; gramToken ( ) ; return _BOOL ; } saveTermBuffer ( ) ; return _BOOL ; }
@ Override public boolean incrementToken ( ) throws IOException { if ( savedState != null ) { restoreState ( savedState ) ; savedState = null ; saveTermBuffer ( ) ; return _BOOL ; } else if ( ! input . incrementToken ( ) ) { return _BOOL ; } if ( lastWasCommon || ( isCommon ( ) && buffer . length ( ) > _NUM ) ) { savedState = captureState ( ) ; gramToken ( ) ; return _BOOL ; } saveTermBuffer ( ) ; return _BOOL ; }
@ Override public boolean incrementToken ( ) throws IOException { if ( savedState != null ) { restoreState ( savedState ) ; savedState = null ; saveTermBuffer ( ) ; return _BOOL ; } else if ( ! input . incrementToken ( ) ) { return _BOOL ; } if ( lastWasCommon || ( isCommon ( ) && buffer . length ( ) > _NUM ) ) { savedState = captureState ( ) ; gramToken ( ) ; return _BOOL ; } saveTermBuffer ( ) ; return _BOOL ; }
@ Override public boolean incrementToken ( ) throws IOException { if ( savedState != null ) { restoreState ( savedState ) ; savedState = null ; saveTermBuffer ( ) ; return _BOOL ; } else if ( ! input . incrementToken ( ) ) { return _BOOL ; } if ( lastWasCommon || ( isCommon ( ) && buffer . length ( ) > _NUM ) ) { savedState = captureState ( ) ; gramToken ( ) ; return _BOOL ; } saveTermBuffer ( ) ; return _BOOL ; }
public void rebuildEventList ( boolean resetSelected ) { if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STRING ) ; } allEvents = null ; activeEvents = null ; hideDetails ( ) ; initInterface ( getActiveEvents ( ) , resetSelected ) ; highlightCurrentEvent ( currentTime ) ; firePropertyChange ( ActiveEventsProperty , null , getActiveEvents ( ) ) ; }
public synchronized void insertText ( String inputtype , String outputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , String outputtext ) throws SQLException { if ( inputtype == null || outputtype == null || locale == null || voice == null || inputtext == null || outputtext == null ) { throw new NullPointerException ( STRING ) ; } if ( lookupText ( inputtype , outputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + outputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; PreparedStatement st = connection . prepareStatement ( query ) ; st . setString ( _NUM , inputtext ) ; st . setString ( _NUM , outputtext ) ; st . executeUpdate ( ) ; st . close ( ) ; }
public synchronized void insertText ( String inputtype , String outputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , String outputtext ) throws SQLException { if ( inputtype == null || outputtype == null || locale == null || voice == null || inputtext == null || outputtext == null ) { throw new NullPointerException ( STRING ) ; } if ( lookupText ( inputtype , outputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + outputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; PreparedStatement st = connection . prepareStatement ( query ) ; st . setString ( _NUM , inputtext ) ; st . setString ( _NUM , outputtext ) ; st . executeUpdate ( ) ; st . close ( ) ; }
public synchronized void insertText ( String inputtype , String outputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , String outputtext ) throws SQLException { if ( inputtype == null || outputtype == null || locale == null || voice == null || inputtext == null || outputtext == null ) { throw new NullPointerException ( STRING ) ; } if ( lookupText ( inputtype , outputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + outputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; PreparedStatement st = connection . prepareStatement ( query ) ; st . setString ( _NUM , inputtext ) ; st . setString ( _NUM , outputtext ) ; st . executeUpdate ( ) ; st . close ( ) ; }
public synchronized void insertText ( String inputtype , String outputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , String outputtext ) throws SQLException { if ( inputtype == null || outputtype == null || locale == null || voice == null || inputtext == null || outputtext == null ) { throw new NullPointerException ( STRING ) ; } if ( lookupText ( inputtype , outputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + outputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; PreparedStatement st = connection . prepareStatement ( query ) ; st . setString ( _NUM , inputtext ) ; st . setString ( _NUM , outputtext ) ; st . executeUpdate ( ) ; st . close ( ) ; }
public synchronized void insertText ( String inputtype , String outputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , String outputtext ) throws SQLException { if ( inputtype == null || outputtype == null || locale == null || voice == null || inputtext == null || outputtext == null ) { throw new NullPointerException ( STRING ) ; } if ( lookupText ( inputtype , outputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + outputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; PreparedStatement st = connection . prepareStatement ( query ) ; st . setString ( _NUM , inputtext ) ; st . setString ( _NUM , outputtext ) ; st . executeUpdate ( ) ; st . close ( ) ; }
public synchronized void insertText ( String inputtype , String outputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , String outputtext ) throws SQLException { if ( inputtype == null || outputtype == null || locale == null || voice == null || inputtext == null || outputtext == null ) { throw new NullPointerException ( STRING ) ; } if ( lookupText ( inputtype , outputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + outputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; PreparedStatement st = connection . prepareStatement ( query ) ; st . setString ( _NUM , inputtext ) ; st . setString ( _NUM , outputtext ) ; st . executeUpdate ( ) ; st . close ( ) ; }
void updateObjectId ( ParseObject object , String oldObjectId , String newObjectId ) { if ( oldObjectId != null ) { if ( oldObjectId . equals ( newObjectId ) ) { return ; } throw new RuntimeException ( STRING ) ; } String className = object . getClassName ( ) ; Pair < String , String > classNameAndNewObjectId = Pair . create ( className , newObjectId ) ; synchronized ( lock ) { ParseObject existing = classNameAndObjectIdToObjectMap . get ( classNameAndNewObjectId ) ; if ( existing != null && existing != object ) { throw new RuntimeException ( STRING + STRING ) ; } classNameAndObjectIdToObjectMap . put ( classNameAndNewObjectId , object ) ; } }
void updateObjectId ( ParseObject object , String oldObjectId , String newObjectId ) { if ( oldObjectId != null ) { if ( oldObjectId . equals ( newObjectId ) ) { return ; } throw new RuntimeException ( STRING ) ; } String className = object . getClassName ( ) ; Pair < String , String > classNameAndNewObjectId = Pair . create ( className , newObjectId ) ; synchronized ( lock ) { ParseObject existing = classNameAndObjectIdToObjectMap . get ( classNameAndNewObjectId ) ; if ( existing != null && existing != object ) { throw new RuntimeException ( STRING + STRING ) ; } classNameAndObjectIdToObjectMap . put ( classNameAndNewObjectId , object ) ; } }
private void sendBroadcastUploadsAdded ( ) { Intent start = new Intent ( getUploadsAddedMessage ( ) ) ; sendStickyBroadcast ( start ) ; }
private void sendBroadcastUploadsAdded ( ) { Intent start = new Intent ( getUploadsAddedMessage ( ) ) ; sendStickyBroadcast ( start ) ; }
private void sendBroadcastUploadsAdded ( ) { Intent start = new Intent ( getUploadsAddedMessage ( ) ) ; sendStickyBroadcast ( start ) ; }
private void sendBroadcastUploadsAdded ( ) { Intent start = new Intent ( getUploadsAddedMessage ( ) ) ; sendStickyBroadcast ( start ) ; }
public void addArgument ( AstNode arg ) { assertNotNull ( arg ) ; if ( arguments == null ) { arguments = new ArrayList < AstNode > ( ) ; } arguments . add ( arg ) ; arg . setParent ( this ) ; }
public void addArgument ( AstNode arg ) { assertNotNull ( arg ) ; if ( arguments == null ) { arguments = new ArrayList < AstNode > ( ) ; } arguments . add ( arg ) ; arg . setParent ( this ) ; }
public static boolean isFontEmbedded ( PdfObject pdfObject ) { final int fontType = pdfObject . getParameterConstant ( PdfDictionary . Subtype ) ; if ( fontType == StandardFonts . TYPE0 ) { pdfObject = pdfObject . getDictionary ( PdfDictionary . DescendantFonts ) ; } final PdfObject descFontObj = pdfObject . getDictionary ( PdfDictionary . FontDescriptor ) ; if ( descFontObj == null ) { return _BOOL ; } else { return descFontObj . hasStream ( ) ; } }
@ Override public void write ( int b ) throws IOException { if ( stack . size ( ) == _NUM || standaloneMarkers . contains ( stack . peek ( ) . marker ) ) { writeStuffed ( b ) ; } else { writeNonstuffed ( b ) ; } }
public void mouseDragged ( MouseEvent e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( getID ( ) + STRING ) ; } super . mouseDragged ( e ) ; Object obj = e . getSource ( ) ; if ( obj instanceof MapBean && theMap == null ) { theMap = ( MapBean ) obj ; theMap . addPaintListener ( this ) ; } MapBean map = this . theMap ; Point firstPoint = this . point1 ; if ( map != null ) { if ( ! autoZoom ) { return ; } point2 = getRatioPoint ( map , firstPoint , e . getPoint ( ) ) ; map . repaint ( ) ; } }
public void mouseDragged ( MouseEvent e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( getID ( ) + STRING ) ; } super . mouseDragged ( e ) ; Object obj = e . getSource ( ) ; if ( obj instanceof MapBean && theMap == null ) { theMap = ( MapBean ) obj ; theMap . addPaintListener ( this ) ; } MapBean map = this . theMap ; Point firstPoint = this . point1 ; if ( map != null ) { if ( ! autoZoom ) { return ; } point2 = getRatioPoint ( map , firstPoint , e . getPoint ( ) ) ; map . repaint ( ) ; } }
public static String padRight ( String s , int len , char pad_ch ) { if ( s . length ( ) >= len ) { return s ; } else { StringBuilder sb = new StringBuilder ( ) ; int n = len - s . length ( ) ; sb . append ( s ) ; for ( int i = _NUM ; i < n ; i ++ ) { sb . append ( pad_ch ) ; } return sb . toString ( ) ; } }
public static < S extends Declaration , S2 extends S > SymbolReference < S > solved ( S2 symbolDeclaration ) { return new SymbolReference ( Optional . of ( symbolDeclaration ) ) ; }
public static double ud ( ) { return R . nextDouble ( ) ; }
public boolean isEmpty ( ) { if ( ! built ) return itemBoundables . isEmpty ( ) ; return root . isEmpty ( ) ; }
public boolean isEmpty ( ) { if ( ! built ) return itemBoundables . isEmpty ( ) ; return root . isEmpty ( ) ; }
public boolean isEmpty ( ) { if ( ! built ) return itemBoundables . isEmpty ( ) ; return root . isEmpty ( ) ; }
public boolean isEmpty ( ) { if ( ! built ) return itemBoundables . isEmpty ( ) ; return root . isEmpty ( ) ; }
public final InputStream asInputStream ( ) throws UnknownResourceException { return toInputStream ( ) ; }
public final InputStream asInputStream ( ) throws UnknownResourceException { return toInputStream ( ) ; }
protected JPanel makeParamsPanel ( ) { JPanel panel = super . makeParamsPanel ( ) ; JPanel p = new JPanel ( ) ; p . setLayout ( new BoxLayout ( p , BoxLayout . Y_AXIS ) ) ; p . add ( new JLabel ( Bundle . getMessage ( STRING ) ) ) ; JPanel pp = new JPanel ( ) ; _radiusText = new JTextField ( _NUM ) ; _radiusText . setText ( Integer . toString ( _radius ) ) ; _radiusText . setHorizontalAlignment ( JTextField . RIGHT ) ; pp . add ( _radiusText ) ; pp . add ( new JLabel ( Bundle . getMessage ( STRING ) ) ) ; p . add ( pp ) ; panel . add ( p ) ; panel . add ( Box . createVerticalStrut ( STRUT_SIZE ) ) ; return panel ; }
private static boolean test ( ODatabaseDocumentPool pool , String dbURL , String user , String password , boolean finalTry ) { ODatabaseDocumentTx db = null ; try { logger . info ( STRING ) ; db = pool . acquire ( dbURL , user , password ) ; Iterator < ODocument > iter = db . browseClass ( STRING ) ; if ( iter . hasNext ( ) ) { iter . next ( ) ; } } catch ( OException ex ) { if ( finalTry ) { logger . info ( STRING , ex ) ; } else { logger . debug ( STRING , ex ) ; } return _BOOL ; } finally { if ( db != null ) { db . close ( ) ; } } return _BOOL ; }
private static boolean test ( ODatabaseDocumentPool pool , String dbURL , String user , String password , boolean finalTry ) { ODatabaseDocumentTx db = null ; try { logger . info ( STRING ) ; db = pool . acquire ( dbURL , user , password ) ; Iterator < ODocument > iter = db . browseClass ( STRING ) ; if ( iter . hasNext ( ) ) { iter . next ( ) ; } } catch ( OException ex ) { if ( finalTry ) { logger . info ( STRING , ex ) ; } else { logger . debug ( STRING , ex ) ; } return _BOOL ; } finally { if ( db != null ) { db . close ( ) ; } } return _BOOL ; }
public String productName ( ) { return properties . getProperty ( STRING ) ; }
public ExtendedMessageFormat ( final String pattern , final Map < String , ? extends FormatFactory > registry ) { this ( pattern , Locale . getDefault ( ) , registry ) ; }
private void addClassLoader ( ClassLoader loader , final ObjectName logicalName ) { final ModifiableClassLoaderRepository clr = getInstantiatorCLR ( ) ; if ( clr == null ) { final RuntimeException wrapped = new IllegalArgumentException ( STRING + STRING ) ; throw new RuntimeOperationsException ( wrapped , STRING + STRING ) ; } clr . addClassLoader ( logicalName , loader ) ; }
ContentTile ( int row , int column ) { this . row = row ; this . column = column ; }
private void add ( SessionID sessionID ) { remoteSessionSet . add ( sessionID ) ; }
protected void printAttributeSummary ( boolean nominalPredictor , boolean numericPredictor , boolean stringPredictor , boolean datePredictor , boolean relationalPredictor , boolean multiInstance ) { String str = STRING ; if ( numericPredictor ) { str += STRING ; } if ( nominalPredictor ) { if ( str . length ( ) > _NUM ) { str += STRING ; } str += STRING ; } if ( stringPredictor ) { if ( str . length ( ) > _NUM ) { str += STRING ; } str += STRING ; } if ( datePredictor ) { if ( str . length ( ) > _NUM ) { str += STRING ; } str += STRING ; } if ( relationalPredictor ) { if ( str . length ( ) > _NUM ) { str += STRING ; } str += STRING ; } str = STRING + str + STRING ; print ( str ) ; }
public boolean isServiceSelected ( ) { return tabbedPane != null && tabbedPane . getSelectedComponent ( ) != null && tabbedPane . getSelectedComponent ( ) instanceof ServicePanel ; }
private void unregister ( ) { GridDhtLocalPartition [ ] arr = parts . get ( ) ; if ( ! F . isEmpty ( arr ) && parts . compareAndSet ( arr , EMPTY ) ) { for ( int i = arr . length - _NUM ; i >= _NUM ; i -- ) { GridDhtLocalPartition part = arr [ i ] ; part . removeReservation ( this ) ; tryEvict ( part ) ; } } CI1 < GridDhtPartitionsReservation > u = unpublish . get ( ) ; if ( u != null && u != NO_OP && unpublish . compareAndSet ( u , NO_OP ) ) u . apply ( this ) ; }
public AdapterPathSegment firstSegment ( ) { return ( ! mSegments . isEmpty ( ) ) ? ( mSegments . get ( _NUM ) ) : null ; }
public BytePackedRaster ( SampleModel sampleModel , DataBuffer dataBuffer , Point origin ) { this ( sampleModel , dataBuffer , new Rectangle ( origin . x , origin . y , sampleModel . getWidth ( ) , sampleModel . getHeight ( ) ) , origin , null ) ; }
public Point translateJava2DToScreen ( Point2D java2DPoint ) { Insets insets = getInsets ( ) ; int x = ( int ) ( java2DPoint . getX ( ) * this . scaleX + insets . left ) ; int y = ( int ) ( java2DPoint . getY ( ) * this . scaleY + insets . top ) ; return new Point ( x , y ) ; }
@ Override public void suiteStart ( ) { throw new UnsupportedOperationException ( ) ; }
@ Override public void suiteStart ( ) { throw new UnsupportedOperationException ( ) ; }
public Activity currentActivity ( ) { if ( mActivityStack == null ) return null ; return mActivityStack . lastElement ( ) ; }
public Activity currentActivity ( ) { if ( mActivityStack == null ) return null ; return mActivityStack . lastElement ( ) ; }
private void populateCompletedActivitiSteps ( Job job , List < HistoricActivityInstance > historicActivitiTasks ) { List < WorkflowStep > completedWorkflowSteps = new ArrayList < > ( ) ; for ( HistoricActivityInstance historicActivityInstance : historicActivitiTasks ) { completedWorkflowSteps . add ( new WorkflowStep ( historicActivityInstance . getActivityId ( ) , historicActivityInstance . getActivityName ( ) , HerdDateUtils . getXMLGregorianCalendarValue ( historicActivityInstance . getStartTime ( ) ) , HerdDateUtils . getXMLGregorianCalendarValue ( historicActivityInstance . getEndTime ( ) ) ) ) ; } job . setCompletedWorkflowSteps ( completedWorkflowSteps ) ; }
public static float updateValue ( float current , float target , float factor ) { float times = ( System . currentTimeMillis ( ) - ClientUtils . lastUpdate ) / _NUM ; float off = ( off = target - current ) > _NUM || off < - _NUM ? off * ( float ) Math . pow ( factor , times ) : _NUM ; return target - off ; }
public static float updateValue ( float current , float target , float factor ) { float times = ( System . currentTimeMillis ( ) - ClientUtils . lastUpdate ) / _NUM ; float off = ( off = target - current ) > _NUM || off < - _NUM ? off * ( float ) Math . pow ( factor , times ) : _NUM ; return target - off ; }
public static float updateValue ( float current , float target , float factor ) { float times = ( System . currentTimeMillis ( ) - ClientUtils . lastUpdate ) / _NUM ; float off = ( off = target - current ) > _NUM || off < - _NUM ? off * ( float ) Math . pow ( factor , times ) : _NUM ; return target - off ; }
public static Model createIncludesModel ( Model model , String graphURI ) { Set < Graph > graphs = new HashSet < Graph > ( ) ; Graph baseGraph = model . getGraph ( ) ; addIncludes ( baseGraph , graphURI , graphs , new HashSet < String > ( ) ) ; if ( graphs . size ( ) == _NUM ) { return model ; } else { MultiUnion union = new MultiUnion ( graphs . iterator ( ) ) ; union . setBaseGraph ( baseGraph ) ; return ModelFactory . createModelForGraph ( union ) ; } }
public static void close ( @ CheckForNull InputStream inputStream ) { if ( inputStream == null ) { return ; } try { inputStream . close ( ) ; } catch ( IOException e ) { } }
public void testCase23 ( ) { byte rBytes [ ] = { _NUM } ; BigInteger aNumber = BigInteger . ZERO ; BigInteger bNumber = BigInteger . ZERO ; BigInteger result = aNumber . subtract ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( _NUM , result . signum ( ) ) ; }
public void testCase23 ( ) { byte rBytes [ ] = { _NUM } ; BigInteger aNumber = BigInteger . ZERO ; BigInteger bNumber = BigInteger . ZERO ; BigInteger result = aNumber . subtract ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( _NUM , result . signum ( ) ) ; }
private void reduceScrollSpeed ( double speed , int headerVisible ) { mRecyclerView . stopScroll ( ) ; int distToStop = minDistanceToScrollBack ; mScroller . setScrollVector ( getDecelVector ( headerVisible ) ) ; mScroller . setTargetPosition ( getDecelTargetPos ( headerVisible ) ) ; mScroller . setDistanceToStop ( distToStop ) ; mScroller . setInitialSpeed ( ( float ) Math . abs ( speed ) ) ; mLayoutManager . startSmoothScroll ( mScroller ) ; }
private void reduceScrollSpeed ( double speed , int headerVisible ) { mRecyclerView . stopScroll ( ) ; int distToStop = minDistanceToScrollBack ; mScroller . setScrollVector ( getDecelVector ( headerVisible ) ) ; mScroller . setTargetPosition ( getDecelTargetPos ( headerVisible ) ) ; mScroller . setDistanceToStop ( distToStop ) ; mScroller . setInitialSpeed ( ( float ) Math . abs ( speed ) ) ; mLayoutManager . startSmoothScroll ( mScroller ) ; }
public void start ( ) { eventLogThread . start ( ) ; LOGGER . info ( STRING + eventLogThread . getName ( ) + STRING + eventLogThread . getId ( ) + STRING ) ; }
private void onStopAttack ( ) { attacking = null ; }
private void onStopAttack ( ) { attacking = null ; }
public void printString ( String v ) throws IOException { printString ( v , _NUM , v . length ( ) ) ; }
public void printString ( String v ) throws IOException { printString ( v , _NUM , v . length ( ) ) ; }
public static boolean removeTable ( Table t ) { try { tableList . remove ( t ) ; } catch ( Exception e ) { return _BOOL ; } return _BOOL ; }
public static String formatDate ( Date d ) { try { synchronized ( timeFormatter ) { return timeFormatter . format ( d ) ; } } catch ( Exception e1 ) { try { return d . toString ( ) ; } catch ( Exception e2 ) { try { return Long . toString ( d . getTime ( ) ) ; } catch ( Exception e3 ) { return STRING ; } } } }
private void assertSerializeAndDesDateTime ( String dateTimeString ) throws RyaTypeResolverException { assertSerializeAndDesDateTime ( dateTimeString , dateTimeString ) ; }
void collectTypes ( ) { for ( Resource type : knownTypes . keySet ( ) ) { collect ( knownTypes . get ( type ) ) ; } }
void collectTypes ( ) { for ( Resource type : knownTypes . keySet ( ) ) { collect ( knownTypes . get ( type ) ) ; } }
static AggregatedHttpMessage of ( HttpHeaders headers , HttpData content , HttpHeaders trailingHeaders ) { return of ( Collections . emptyList ( ) , headers , content , trailingHeaders ) ; }
public void handleNotification ( Notification notification , Object handback ) { String notifyType = notification . getType ( ) ; if ( notifyType . equals ( GarbageCollectionNotificationInfo . GARBAGE_COLLECTION_NOTIFICATION ) ) { CompositeData cd = ( CompositeData ) notification . getUserData ( ) ; GarbageCollectionNotificationInfo gcNotifyInfo = GarbageCollectionNotificationInfo . from ( cd ) ; monitor ( gcNotifyInfo ) ; if ( ! gcNames . contains ( gcNotifyInfo . getGcName ( ) ) ) { registerDependentGcMbeans ( gcNotifyInfo . getGcName ( ) ) ; } } }
public void handleNotification ( Notification notification , Object handback ) { String notifyType = notification . getType ( ) ; if ( notifyType . equals ( GarbageCollectionNotificationInfo . GARBAGE_COLLECTION_NOTIFICATION ) ) { CompositeData cd = ( CompositeData ) notification . getUserData ( ) ; GarbageCollectionNotificationInfo gcNotifyInfo = GarbageCollectionNotificationInfo . from ( cd ) ; monitor ( gcNotifyInfo ) ; if ( ! gcNames . contains ( gcNotifyInfo . getGcName ( ) ) ) { registerDependentGcMbeans ( gcNotifyInfo . getGcName ( ) ) ; } } }
public double calculateLocalSwapTotalCapacity ( int hostcount , int hostlocalswapsize ) { double d = ( double ) ( hostcount * hostlocalswapsize ) / _NUM ; d *= - _NUM ; d = ( double ) Math . round ( d * _NUM ) / _NUM ; return d ; }
public double calculateLocalSwapTotalCapacity ( int hostcount , int hostlocalswapsize ) { double d = ( double ) ( hostcount * hostlocalswapsize ) / _NUM ; d *= - _NUM ; d = ( double ) Math . round ( d * _NUM ) / _NUM ; return d ; }
public double calculateLocalSwapTotalCapacity ( int hostcount , int hostlocalswapsize ) { double d = ( double ) ( hostcount * hostlocalswapsize ) / _NUM ; d *= - _NUM ; d = ( double ) Math . round ( d * _NUM ) / _NUM ; return d ; }
static List < File > tidyDatabaseList ( List < File > databaseFiles ) { List < File > tidiedList = new ArrayList < > ( ) ; for ( File databaseFile : databaseFiles ) { tidiedList . add ( databaseFile ) ; } return tidiedList ; }
static List < File > tidyDatabaseList ( List < File > databaseFiles ) { List < File > tidiedList = new ArrayList < > ( ) ; for ( File databaseFile : databaseFiles ) { tidiedList . add ( databaseFile ) ; } return tidiedList ; }
static List < File > tidyDatabaseList ( List < File > databaseFiles ) { List < File > tidiedList = new ArrayList < > ( ) ; for ( File databaseFile : databaseFiles ) { tidiedList . add ( databaseFile ) ; } return tidiedList ; }
static List < File > tidyDatabaseList ( List < File > databaseFiles ) { List < File > tidiedList = new ArrayList < > ( ) ; for ( File databaseFile : databaseFiles ) { tidiedList . add ( databaseFile ) ; } return tidiedList ; }
static List < File > tidyDatabaseList ( List < File > databaseFiles ) { List < File > tidiedList = new ArrayList < > ( ) ; for ( File databaseFile : databaseFiles ) { tidiedList . add ( databaseFile ) ; } return tidiedList ; }
private void enableMaintenanceMode ( ) { synchronized ( maintenanceEnabled ) { if ( ! maintenanceEnabled . getAndSet ( _BOOL ) ) { maintenanceFilter . enableMaintenanceMode ( ) ; } } }
private void enableMaintenanceMode ( ) { synchronized ( maintenanceEnabled ) { if ( ! maintenanceEnabled . getAndSet ( _BOOL ) ) { maintenanceFilter . enableMaintenanceMode ( ) ; } } }
private void enableMaintenanceMode ( ) { synchronized ( maintenanceEnabled ) { if ( ! maintenanceEnabled . getAndSet ( _BOOL ) ) { maintenanceFilter . enableMaintenanceMode ( ) ; } } }
private void enableMaintenanceMode ( ) { synchronized ( maintenanceEnabled ) { if ( ! maintenanceEnabled . getAndSet ( _BOOL ) ) { maintenanceFilter . enableMaintenanceMode ( ) ; } } }
public void create ( String [ ] rpfFilePaths , String outputFile ) throws MakeTocException { create ( rpfFilePaths , outputFile , _BOOL ) ; }
public void create ( String [ ] rpfFilePaths , String outputFile ) throws MakeTocException { create ( rpfFilePaths , outputFile , _BOOL ) ; }
public static void restorePreviousOutAndErrStream ( ) { if ( ! alreadyMuted ) { return ; } System . setOut ( latestOut ) ; System . setErr ( latestErr ) ; alreadyMuted = _BOOL ; }
public static void restorePreviousOutAndErrStream ( ) { if ( ! alreadyMuted ) { return ; } System . setOut ( latestOut ) ; System . setErr ( latestErr ) ; alreadyMuted = _BOOL ; }
void updateWSFedEntityConfig ( String realm , String cotName , Set trustedProviders ) throws COTException { String classMethod = STRING ; String entityId = null ; WSFederationCOTUtils wsfedCotUtils = new WSFederationCOTUtils ( callerSession ) ; if ( trustedProviders != null && ! trustedProviders . isEmpty ( ) ) { for ( Iterator iter = trustedProviders . iterator ( ) ; iter . hasNext ( ) ; ) { entityId = ( String ) iter . next ( ) ; try { wsfedCotUtils . updateEntityConfig ( realm , cotName , entityId ) ; } catch ( WSFederationMetaException sme ) { throw new COTException ( sme ) ; } catch ( JAXBException e ) { debug . error ( classMethod , e ) ; String [ ] data = { e . getMessage ( ) , cotName , entityId , realm } ; LogUtil . error ( Level . INFO , LogUtil . CONFIG_ERROR_CREATE_COT_DESCRIPTOR , data ) ; throw new COTException ( e ) ; } } } }
@ SuppressWarnings ( STRING ) public static < T > Sequence < T > wrapStart ( Sequence < T > sequence , T startToken ) { Object [ ] arr = new Object [ sequence . size ( ) + _NUM ] ; arr [ _NUM ] = startToken ; System . arraycopy ( sequence . elements ( ) , _NUM , arr , _NUM , sequence . size ( ) ) ; return new ArraySequence < T > ( _BOOL , ( T [ ] ) arr ) ; }
@ Override public void run ( ) { amIActive = _BOOL ; panel = new CoordinateTransformDialog ( myHost ) ; if ( myHost instanceof JFrame ) { JDialog dialog = new JDialog ( ( JFrame ) myHost , STRING , _BOOL ) ; Container contentPane = dialog . getContentPane ( ) ; contentPane . add ( panel , BorderLayout . CENTER ) ; dialog . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; dialog . pack ( ) ; dialog . setLocationRelativeTo ( null ) ; dialog . setVisible ( _BOOL ) ; } else { JFrame frame = new JFrame ( STRING ) ; Container contentPane = frame . getContentPane ( ) ; contentPane . add ( panel , BorderLayout . CENTER ) ; frame . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; frame . pack ( ) ; frame . setLocationRelativeTo ( null ) ; frame . setVisible ( _BOOL ) ; } }
public static boolean equals ( byte [ ] [ ] field1 , byte [ ] [ ] field2 ) { int index1 = _NUM ; int length1 = field1 == null ? _NUM : field1 . length ; int index2 = _NUM ; int length2 = field2 == null ? _NUM : field2 . length ; while ( _BOOL ) { while ( index1 < length1 && field1 [ index1 ] == null ) { index1 ++ ; } while ( index2 < length2 && field2 [ index2 ] == null ) { index2 ++ ; } boolean atEndOf1 = index1 >= length1 ; boolean atEndOf2 = index2 >= length2 ; if ( atEndOf1 && atEndOf2 ) { return _BOOL ; } else if ( atEndOf1 != atEndOf2 ) { return _BOOL ; } else if ( ! Arrays . equals ( field1 [ index1 ] , field2 [ index2 ] ) ) { return _BOOL ; } index1 ++ ; index2 ++ ; } }
public static boolean equals ( byte [ ] [ ] field1 , byte [ ] [ ] field2 ) { int index1 = _NUM ; int length1 = field1 == null ? _NUM : field1 . length ; int index2 = _NUM ; int length2 = field2 == null ? _NUM : field2 . length ; while ( _BOOL ) { while ( index1 < length1 && field1 [ index1 ] == null ) { index1 ++ ; } while ( index2 < length2 && field2 [ index2 ] == null ) { index2 ++ ; } boolean atEndOf1 = index1 >= length1 ; boolean atEndOf2 = index2 >= length2 ; if ( atEndOf1 && atEndOf2 ) { return _BOOL ; } else if ( atEndOf1 != atEndOf2 ) { return _BOOL ; } else if ( ! Arrays . equals ( field1 [ index1 ] , field2 [ index2 ] ) ) { return _BOOL ; } index1 ++ ; index2 ++ ; } }
protected void drawRhombus ( int x , int y , int w , int h , Color fillColor , Paint fillPaint , Color penColor , boolean shadow ) { int halfWidth = w / _NUM ; int halfHeight = h / _NUM ; Polygon rhombus = new Polygon ( ) ; rhombus . addPoint ( x + halfWidth , y ) ; rhombus . addPoint ( x + w , y + halfHeight ) ; rhombus . addPoint ( x + halfWidth , y + h ) ; rhombus . addPoint ( x , y + halfHeight ) ; drawPolygon ( rhombus , fillColor , fillPaint , penColor , shadow ) ; }
private void algorithmDouglasPeucker ( ArrayList < Entry > entries , double epsilon , int start , int end ) { if ( end <= start + _NUM ) { return ; } int maxDistIndex = _NUM ; double distMax = _NUM ; Entry firstEntry = entries . get ( start ) ; Entry lastEntry = entries . get ( end ) ; for ( int i = start + _NUM ; i < end ; i ++ ) { double dist = pointToLineDistance ( firstEntry , lastEntry , entries . get ( i ) ) ; if ( dist > distMax ) { distMax = dist ; maxDistIndex = i ; } } if ( distMax > epsilon ) { keep [ maxDistIndex ] = _BOOL ; algorithmDouglasPeucker ( entries , epsilon , start , maxDistIndex ) ; algorithmDouglasPeucker ( entries , epsilon , maxDistIndex , end ) ; } }
public static boolean isSynchronized ( int mod ) { return Modifier . isSynchronized ( mod ) ; }
public static boolean isSynchronized ( int mod ) { return Modifier . isSynchronized ( mod ) ; }
public void characters ( org . w3c . dom . Node node ) throws org . xml . sax . SAXException { flushPending ( ) ; String data = node . getNodeValue ( ) ; if ( data != null ) { final int length = data . length ( ) ; if ( length > m_charsBuff . length ) { m_charsBuff = new char [ length * _NUM + _NUM ] ; } data . getChars ( _NUM , length , m_charsBuff , _NUM ) ; characters ( m_charsBuff , _NUM , length ) ; } }
public void characters ( org . w3c . dom . Node node ) throws org . xml . sax . SAXException { flushPending ( ) ; String data = node . getNodeValue ( ) ; if ( data != null ) { final int length = data . length ( ) ; if ( length > m_charsBuff . length ) { m_charsBuff = new char [ length * _NUM + _NUM ] ; } data . getChars ( _NUM , length , m_charsBuff , _NUM ) ; characters ( m_charsBuff , _NUM , length ) ; } }
public void characters ( org . w3c . dom . Node node ) throws org . xml . sax . SAXException { flushPending ( ) ; String data = node . getNodeValue ( ) ; if ( data != null ) { final int length = data . length ( ) ; if ( length > m_charsBuff . length ) { m_charsBuff = new char [ length * _NUM + _NUM ] ; } data . getChars ( _NUM , length , m_charsBuff , _NUM ) ; characters ( m_charsBuff , _NUM , length ) ; } }
public void writeLine ( double [ ] column ) { String str = Double . toString ( column [ _NUM ] ) ; for ( int i = _NUM ; i < column . length ; ++ i ) { str += STRING + column [ i ] ; } writer . println ( str ) ; }
private static int hash ( Object x ) { int h = x . hashCode ( ) ; return ( ( h << _NUM ) - h + ( h > > > _NUM ) + ( h > > > _NUM ) ) ; }
private static int hash ( Object x ) { int h = x . hashCode ( ) ; return ( ( h << _NUM ) - h + ( h > > > _NUM ) + ( h > > > _NUM ) ) ; }
private static int hash ( Object x ) { int h = x . hashCode ( ) ; return ( ( h << _NUM ) - h + ( h > > > _NUM ) + ( h > > > _NUM ) ) ; }
private UnManagedVolume createUnManagedVolume ( String unManagedVolumeNativeGuid , LogicalUnit logicalUnit , StorageSystem system , StoragePool pool , DbClient dbClient ) { UnManagedVolume newUnManagedVolume = new UnManagedVolume ( ) ; newUnManagedVolume . setId ( URIUtil . createId ( UnManagedVolume . class ) ) ; newUnManagedVolume . setNativeGuid ( unManagedVolumeNativeGuid ) ; newUnManagedVolume . setStorageSystemUri ( system . getId ( ) ) ; newUnManagedVolume . setStoragePoolUri ( pool . getId ( ) ) ; updateUnManagedVolumeInfo ( logicalUnit , system , pool , newUnManagedVolume , dbClient ) ; return newUnManagedVolume ; }
private static File createTempFile ( String tempSubdirectoryName , String name ) throws IOException { String tempDirName = System . getProperty ( STRING ) ; File tempSubDirectory = new File ( tempDirName + File . separator + tempSubdirectoryName ) ; if ( ! tempSubDirectory . exists ( ) ) { boolean createdDirectory = tempSubDirectory . mkdirs ( ) ; if ( ! createdDirectory ) { throw new IOException ( STRING + tempSubDirectory ) ; } } String tempFileName = tempSubDirectory + File . separator + name ; File tempFile = new File ( tempFileName ) ; return tempFile ; }
private static File createTempFile ( String tempSubdirectoryName , String name ) throws IOException { String tempDirName = System . getProperty ( STRING ) ; File tempSubDirectory = new File ( tempDirName + File . separator + tempSubdirectoryName ) ; if ( ! tempSubDirectory . exists ( ) ) { boolean createdDirectory = tempSubDirectory . mkdirs ( ) ; if ( ! createdDirectory ) { throw new IOException ( STRING + tempSubDirectory ) ; } } String tempFileName = tempSubDirectory + File . separator + name ; File tempFile = new File ( tempFileName ) ; return tempFile ; }
private void paintZoomIndicator ( Graphics2D graphics ) { if ( mZoom != _NUM ) { int width = getWidth ( ) / _NUM ; int x = ( getWidth ( ) / _NUM ) - ( width / _NUM ) ; graphics . drawRect ( x , getHeight ( ) - _NUM , width , _NUM ) ; int zoomWidth = width / getZoomMultiplier ( ) ; int windowOffset = _NUM ; if ( mDFTZoomWindowOffset != _NUM ) { windowOffset = ( int ) ( ( ( double ) mDFTZoomWindowOffset / ( double ) mDFTSize ) * width ) ; } graphics . fillRect ( x + windowOffset , getHeight ( ) - _NUM , zoomWidth , _NUM ) ; graphics . drawString ( STRING + getZoomMultiplier ( ) + STRING , x + width + _NUM , getHeight ( ) - _NUM ) ; } }
private void paintZoomIndicator ( Graphics2D graphics ) { if ( mZoom != _NUM ) { int width = getWidth ( ) / _NUM ; int x = ( getWidth ( ) / _NUM ) - ( width / _NUM ) ; graphics . drawRect ( x , getHeight ( ) - _NUM , width , _NUM ) ; int zoomWidth = width / getZoomMultiplier ( ) ; int windowOffset = _NUM ; if ( mDFTZoomWindowOffset != _NUM ) { windowOffset = ( int ) ( ( ( double ) mDFTZoomWindowOffset / ( double ) mDFTSize ) * width ) ; } graphics . fillRect ( x + windowOffset , getHeight ( ) - _NUM , zoomWidth , _NUM ) ; graphics . drawString ( STRING + getZoomMultiplier ( ) + STRING , x + width + _NUM , getHeight ( ) - _NUM ) ; } }
private void paintZoomIndicator ( Graphics2D graphics ) { if ( mZoom != _NUM ) { int width = getWidth ( ) / _NUM ; int x = ( getWidth ( ) / _NUM ) - ( width / _NUM ) ; graphics . drawRect ( x , getHeight ( ) - _NUM , width , _NUM ) ; int zoomWidth = width / getZoomMultiplier ( ) ; int windowOffset = _NUM ; if ( mDFTZoomWindowOffset != _NUM ) { windowOffset = ( int ) ( ( ( double ) mDFTZoomWindowOffset / ( double ) mDFTSize ) * width ) ; } graphics . fillRect ( x + windowOffset , getHeight ( ) - _NUM , zoomWidth , _NUM ) ; graphics . drawString ( STRING + getZoomMultiplier ( ) + STRING , x + width + _NUM , getHeight ( ) - _NUM ) ; } }
private void paintZoomIndicator ( Graphics2D graphics ) { if ( mZoom != _NUM ) { int width = getWidth ( ) / _NUM ; int x = ( getWidth ( ) / _NUM ) - ( width / _NUM ) ; graphics . drawRect ( x , getHeight ( ) - _NUM , width , _NUM ) ; int zoomWidth = width / getZoomMultiplier ( ) ; int windowOffset = _NUM ; if ( mDFTZoomWindowOffset != _NUM ) { windowOffset = ( int ) ( ( ( double ) mDFTZoomWindowOffset / ( double ) mDFTSize ) * width ) ; } graphics . fillRect ( x + windowOffset , getHeight ( ) - _NUM , zoomWidth , _NUM ) ; graphics . drawString ( STRING + getZoomMultiplier ( ) + STRING , x + width + _NUM , getHeight ( ) - _NUM ) ; } }
private void paintZoomIndicator ( Graphics2D graphics ) { if ( mZoom != _NUM ) { int width = getWidth ( ) / _NUM ; int x = ( getWidth ( ) / _NUM ) - ( width / _NUM ) ; graphics . drawRect ( x , getHeight ( ) - _NUM , width , _NUM ) ; int zoomWidth = width / getZoomMultiplier ( ) ; int windowOffset = _NUM ; if ( mDFTZoomWindowOffset != _NUM ) { windowOffset = ( int ) ( ( ( double ) mDFTZoomWindowOffset / ( double ) mDFTSize ) * width ) ; } graphics . fillRect ( x + windowOffset , getHeight ( ) - _NUM , zoomWidth , _NUM ) ; graphics . drawString ( STRING + getZoomMultiplier ( ) + STRING , x + width + _NUM , getHeight ( ) - _NUM ) ; } }
public void processAttributes ( java . io . Writer writer , int nAttrs ) throws IOException , SAXException { String encoding = getEncoding ( ) ; for ( int i = _NUM ; i < nAttrs ; i ++ ) { final String name = m_attributes . getQName ( i ) ; final String value = m_attributes . getValue ( i ) ; writer . write ( STRING ) ; writer . write ( name ) ; writer . write ( STRING ) ; writeAttrString ( writer , value , encoding ) ; writer . write ( STRING ) ; } }
public void processAttributes ( java . io . Writer writer , int nAttrs ) throws IOException , SAXException { String encoding = getEncoding ( ) ; for ( int i = _NUM ; i < nAttrs ; i ++ ) { final String name = m_attributes . getQName ( i ) ; final String value = m_attributes . getValue ( i ) ; writer . write ( STRING ) ; writer . write ( name ) ; writer . write ( STRING ) ; writeAttrString ( writer , value , encoding ) ; writer . write ( STRING ) ; } }
public void processAttributes ( java . io . Writer writer , int nAttrs ) throws IOException , SAXException { String encoding = getEncoding ( ) ; for ( int i = _NUM ; i < nAttrs ; i ++ ) { final String name = m_attributes . getQName ( i ) ; final String value = m_attributes . getValue ( i ) ; writer . write ( STRING ) ; writer . write ( name ) ; writer . write ( STRING ) ; writeAttrString ( writer , value , encoding ) ; writer . write ( STRING ) ; } }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; return newVector . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; return newVector . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; return newVector . elements ( ) ; }
@ SuppressWarnings ( STRING ) public void checkDeliveryTime ( Message message ) throws JMSException { long creation = message . getJMSTimestamp ( ) ; long min = System . currentTimeMillis ( ) - ( offline . max + online . min ) * ( BROKER_RESTART > _NUM ? _NUM : _NUM ) ; if ( _BOOL && min > creation ) { SimpleDateFormat df = new SimpleDateFormat ( STRING ) ; exit ( STRING + this + STRING + df . format ( new Date ( creation ) ) + STRING + df . format ( new Date ( min ) ) + STRING + message ) ; } }
public synchronized void add ( Class t , EventListener l ) { if ( ! t . isInstance ( l ) ) { throw new IllegalArgumentException ( STRING + l + STRING + t ) ; } if ( l == null ) { throw new IllegalArgumentException ( STRING + l + STRING ) ; } if ( listenerList == NULL_ARRAY ) { listenerList = new Object [ ] { t , l } ; } else { int i = listenerList . length ; Object [ ] tmp = new Object [ i + _NUM ] ; System . arraycopy ( listenerList , _NUM , tmp , _NUM , i ) ; tmp [ i ] = t ; tmp [ i + _NUM ] = l ; listenerList = tmp ; } }
public static ArrayList < Object > deleteItemSets ( ArrayList < Object > itemSets , int minSupport , int maxSupport ) { ArrayList < Object > newVector = new ArrayList < Object > ( itemSets . size ( ) ) ; for ( int i = _NUM ; i < itemSets . size ( ) ; i ++ ) { ItemSet current = ( ItemSet ) itemSets . get ( i ) ; if ( ( current . m_counter >= minSupport ) && ( current . m_counter <= maxSupport ) ) { newVector . add ( current ) ; } } return newVector ; }
public static ArrayList < Object > deleteItemSets ( ArrayList < Object > itemSets , int minSupport , int maxSupport ) { ArrayList < Object > newVector = new ArrayList < Object > ( itemSets . size ( ) ) ; for ( int i = _NUM ; i < itemSets . size ( ) ; i ++ ) { ItemSet current = ( ItemSet ) itemSets . get ( i ) ; if ( ( current . m_counter >= minSupport ) && ( current . m_counter <= maxSupport ) ) { newVector . add ( current ) ; } } return newVector ; }
public static boolean isProcessing ( ) { return isProcessing ; }
public static boolean isProcessing ( ) { return isProcessing ; }
public static boolean isProcessing ( ) { return isProcessing ; }
public static boolean isProcessing ( ) { return isProcessing ; }
public static boolean isProcessing ( ) { return isProcessing ; }
public void onConsumeFinished ( Purchase purchase , IabResult result ) ;
@ NotNull public static ValidationResult validateAndroidNdk ( @ Nullable File ndkPath , boolean includePathInMessage ) { if ( ndkPath != null ) { WizardUtils . ValidationResult wizardValidationResult = WizardUtils . validateLocation ( ndkPath . getAbsolutePath ( ) , STRING , _BOOL , WritableCheckMode . DO_NOT_CHECK ) ; if ( ! wizardValidationResult . isOk ( ) ) { return ValidationResult . error ( wizardValidationResult . getFormattedMessage ( ) ) ; } } ValidationResult validationResult = validatedSdkPath ( ndkPath , STRING , _BOOL , includePathInMessage ) ; if ( validationResult . success && ndkPath != null ) { File toolchainsDirPath = new File ( ndkPath , STRING ) ; if ( ! toolchainsDirPath . isDirectory ( ) ) { String message ; if ( includePathInMessage ) { message = String . format ( STRING , ndkPath . getPath ( ) ) ; } else { message = STRING ; } return ValidationResult . error ( message ) ; } } return validationResult ; }
public UpdateClause addAssignment ( Expression expression ) { assignments . add ( new Assignment ( expression ) ) ; return this ; }
@ Override public double transform ( double value ) { if ( value <= _NUM ) { throw new IllegalArgumentException ( STRING ) ; } return Math . log10 ( value ) ; }
public void straight ( double x , double y ) { double dx = x - pen . x ; double dy = y - pen . y ; if ( convertToTwips ) { dx *= SwfConstants . TWIPS_PER_PIXEL ; dy *= SwfConstants . TWIPS_PER_PIXEL ; } if ( dx == _NUM && dy == _NUM ) { return ; } else { int intdx = ( int ) Math . rint ( dx ) ; int intdy = ( int ) Math . rint ( dy ) ; addLineSubdivideAware ( intdx , intdy ) ; pen . x = x ; pen . y = y ; dxSumTwips += intdx ; dySumTwips += intdy ; } }
public void straight ( double x , double y ) { double dx = x - pen . x ; double dy = y - pen . y ; if ( convertToTwips ) { dx *= SwfConstants . TWIPS_PER_PIXEL ; dy *= SwfConstants . TWIPS_PER_PIXEL ; } if ( dx == _NUM && dy == _NUM ) { return ; } else { int intdx = ( int ) Math . rint ( dx ) ; int intdy = ( int ) Math . rint ( dy ) ; addLineSubdivideAware ( intdx , intdy ) ; pen . x = x ; pen . y = y ; dxSumTwips += intdx ; dySumTwips += intdy ; } }
public void straight ( double x , double y ) { double dx = x - pen . x ; double dy = y - pen . y ; if ( convertToTwips ) { dx *= SwfConstants . TWIPS_PER_PIXEL ; dy *= SwfConstants . TWIPS_PER_PIXEL ; } if ( dx == _NUM && dy == _NUM ) { return ; } else { int intdx = ( int ) Math . rint ( dx ) ; int intdy = ( int ) Math . rint ( dy ) ; addLineSubdivideAware ( intdx , intdy ) ; pen . x = x ; pen . y = y ; dxSumTwips += intdx ; dySumTwips += intdy ; } }
public void straight ( double x , double y ) { double dx = x - pen . x ; double dy = y - pen . y ; if ( convertToTwips ) { dx *= SwfConstants . TWIPS_PER_PIXEL ; dy *= SwfConstants . TWIPS_PER_PIXEL ; } if ( dx == _NUM && dy == _NUM ) { return ; } else { int intdx = ( int ) Math . rint ( dx ) ; int intdy = ( int ) Math . rint ( dy ) ; addLineSubdivideAware ( intdx , intdy ) ; pen . x = x ; pen . y = y ; dxSumTwips += intdx ; dySumTwips += intdy ; } }
public void straight ( double x , double y ) { double dx = x - pen . x ; double dy = y - pen . y ; if ( convertToTwips ) { dx *= SwfConstants . TWIPS_PER_PIXEL ; dy *= SwfConstants . TWIPS_PER_PIXEL ; } if ( dx == _NUM && dy == _NUM ) { return ; } else { int intdx = ( int ) Math . rint ( dx ) ; int intdy = ( int ) Math . rint ( dy ) ; addLineSubdivideAware ( intdx , intdy ) ; pen . x = x ; pen . y = y ; dxSumTwips += intdx ; dySumTwips += intdy ; } }
public void addExceptionContext ( ExceptionContext exceptionContext ) { ExceptionMessage mostRecent ; mostRecent = m_exceptionMessages . lastElement ( ) ; if ( null != mostRecent ) { mostRecent . addExceptionContext ( exceptionContext ) ; } else { m_exceptionContexts . addElement ( exceptionContext ) ; } if ( null != m_nestedException ) { Enumeration < ? > enumeration ; enumeration = m_nestedException . getAllExceptionMessages ( ) ; ExceptionMessage exceptionMessage ; while ( enumeration . hasMoreElements ( ) ) { exceptionMessage = ( ExceptionMessage ) enumeration . nextElement ( ) ; exceptionMessage . addExceptionContext ( exceptionContext ) ; } } }
public void addExceptionContext ( ExceptionContext exceptionContext ) { ExceptionMessage mostRecent ; mostRecent = m_exceptionMessages . lastElement ( ) ; if ( null != mostRecent ) { mostRecent . addExceptionContext ( exceptionContext ) ; } else { m_exceptionContexts . addElement ( exceptionContext ) ; } if ( null != m_nestedException ) { Enumeration < ? > enumeration ; enumeration = m_nestedException . getAllExceptionMessages ( ) ; ExceptionMessage exceptionMessage ; while ( enumeration . hasMoreElements ( ) ) { exceptionMessage = ( ExceptionMessage ) enumeration . nextElement ( ) ; exceptionMessage . addExceptionContext ( exceptionContext ) ; } } }
public void addExceptionContext ( ExceptionContext exceptionContext ) { ExceptionMessage mostRecent ; mostRecent = m_exceptionMessages . lastElement ( ) ; if ( null != mostRecent ) { mostRecent . addExceptionContext ( exceptionContext ) ; } else { m_exceptionContexts . addElement ( exceptionContext ) ; } if ( null != m_nestedException ) { Enumeration < ? > enumeration ; enumeration = m_nestedException . getAllExceptionMessages ( ) ; ExceptionMessage exceptionMessage ; while ( enumeration . hasMoreElements ( ) ) { exceptionMessage = ( ExceptionMessage ) enumeration . nextElement ( ) ; exceptionMessage . addExceptionContext ( exceptionContext ) ; } } }
private Boolean shouldConnect ( final IProject project ) { Check . notNull ( project , STRING ) ; if ( ! project . isOpen ( ) ) { log . debug ( MessageFormat . format ( STRING , project . getName ( ) ) ) ; return null ; } String providerName ; try { providerName = project . getPersistentProperty ( TeamUtils . PROVIDER_PROP_KEY ) ; } catch ( final CoreException e ) { log . warn ( MessageFormat . format ( STRING , project . getName ( ) ) , e ) ; return null ; } if ( providerName == null || ! providerName . equals ( TFSRepositoryProvider . PROVIDER_ID ) ) { return null ; } String repositoryStatus = null ; try { repositoryStatus = project . getPersistentProperty ( REPOSITORY_STATUS_KEY ) ; } catch ( final CoreException e ) { log . warn ( MessageFormat . format ( STRING , project . getName ( ) ) , e ) ; } if ( REPOSITORY_STATUS_OFFLINE_VALUE . equals ( repositoryStatus ) ) { return Boolean . FALSE ; } return Boolean . TRUE ; }
private Boolean shouldConnect ( final IProject project ) { Check . notNull ( project , STRING ) ; if ( ! project . isOpen ( ) ) { log . debug ( MessageFormat . format ( STRING , project . getName ( ) ) ) ; return null ; } String providerName ; try { providerName = project . getPersistentProperty ( TeamUtils . PROVIDER_PROP_KEY ) ; } catch ( final CoreException e ) { log . warn ( MessageFormat . format ( STRING , project . getName ( ) ) , e ) ; return null ; } if ( providerName == null || ! providerName . equals ( TFSRepositoryProvider . PROVIDER_ID ) ) { return null ; } String repositoryStatus = null ; try { repositoryStatus = project . getPersistentProperty ( REPOSITORY_STATUS_KEY ) ; } catch ( final CoreException e ) { log . warn ( MessageFormat . format ( STRING , project . getName ( ) ) , e ) ; } if ( REPOSITORY_STATUS_OFFLINE_VALUE . equals ( repositoryStatus ) ) { return Boolean . FALSE ; } return Boolean . TRUE ; }
public boolean isNullOrEmpty ( String section , String key ) { String value = getKeyValueEL ( section , key ) ; return ( value == null || value . length ( ) == _NUM ) ; }
@ FlakyTest ( tolerance = _NUM ) public void testPopupNoSelection ( ) throws Exception { AutoCompleteTextViewSimple theActivity = getActivity ( ) ; AutoCompleteTextView textView = theActivity . getTextView ( ) ; final Instrumentation instrumentation = getInstrumentation ( ) ; textView . requestFocus ( ) ; instrumentation . waitForIdleSync ( ) ; sendKeys ( STRING ) ; instrumentation . waitForIdleSync ( ) ; Thread . sleep ( WAIT_TIME ) ; assertFalse ( STRING , theActivity . mItemClickCalled ) ; assertFalse ( STRING , theActivity . mItemSelectedCalled ) ; }
@ FlakyTest ( tolerance = _NUM ) public void testPopupNoSelection ( ) throws Exception { AutoCompleteTextViewSimple theActivity = getActivity ( ) ; AutoCompleteTextView textView = theActivity . getTextView ( ) ; final Instrumentation instrumentation = getInstrumentation ( ) ; textView . requestFocus ( ) ; instrumentation . waitForIdleSync ( ) ; sendKeys ( STRING ) ; instrumentation . waitForIdleSync ( ) ; Thread . sleep ( WAIT_TIME ) ; assertFalse ( STRING , theActivity . mItemClickCalled ) ; assertFalse ( STRING , theActivity . mItemSelectedCalled ) ; }
@ FlakyTest ( tolerance = _NUM ) public void testPopupNoSelection ( ) throws Exception { AutoCompleteTextViewSimple theActivity = getActivity ( ) ; AutoCompleteTextView textView = theActivity . getTextView ( ) ; final Instrumentation instrumentation = getInstrumentation ( ) ; textView . requestFocus ( ) ; instrumentation . waitForIdleSync ( ) ; sendKeys ( STRING ) ; instrumentation . waitForIdleSync ( ) ; Thread . sleep ( WAIT_TIME ) ; assertFalse ( STRING , theActivity . mItemClickCalled ) ; assertFalse ( STRING , theActivity . mItemSelectedCalled ) ; }
public static XMLInputSource resolveDocument ( XSDDescription desc , Hashtable locationPairs , XMLEntityResolver entityResolver ) throws IOException { String loc = null ; if ( desc . getContextType ( ) == XSDDescription . CONTEXT_IMPORT || desc . fromInstance ( ) ) { String namespace = desc . getTargetNamespace ( ) ; String ns = namespace == null ? XMLSymbols . EMPTY_STRING : namespace ; LocationArray tempLA = ( LocationArray ) locationPairs . get ( ns ) ; if ( tempLA != null ) loc = tempLA . getFirstLocation ( ) ; } if ( loc == null ) { String [ ] hints = desc . getLocationHints ( ) ; if ( hints != null && hints . length > _NUM ) loc = hints [ _NUM ] ; } String expandedLoc = XMLEntityManager . expandSystemId ( loc , desc . getBaseSystemId ( ) , _BOOL ) ; desc . setLiteralSystemId ( loc ) ; desc . setExpandedSystemId ( expandedLoc ) ; return entityResolver . resolveEntity ( desc ) ; }
public static XMLInputSource resolveDocument ( XSDDescription desc , Hashtable locationPairs , XMLEntityResolver entityResolver ) throws IOException { String loc = null ; if ( desc . getContextType ( ) == XSDDescription . CONTEXT_IMPORT || desc . fromInstance ( ) ) { String namespace = desc . getTargetNamespace ( ) ; String ns = namespace == null ? XMLSymbols . EMPTY_STRING : namespace ; LocationArray tempLA = ( LocationArray ) locationPairs . get ( ns ) ; if ( tempLA != null ) loc = tempLA . getFirstLocation ( ) ; } if ( loc == null ) { String [ ] hints = desc . getLocationHints ( ) ; if ( hints != null && hints . length > _NUM ) loc = hints [ _NUM ] ; } String expandedLoc = XMLEntityManager . expandSystemId ( loc , desc . getBaseSystemId ( ) , _BOOL ) ; desc . setLiteralSystemId ( loc ) ; desc . setExpandedSystemId ( expandedLoc ) ; return entityResolver . resolveEntity ( desc ) ; }
public static XMLInputSource resolveDocument ( XSDDescription desc , Hashtable locationPairs , XMLEntityResolver entityResolver ) throws IOException { String loc = null ; if ( desc . getContextType ( ) == XSDDescription . CONTEXT_IMPORT || desc . fromInstance ( ) ) { String namespace = desc . getTargetNamespace ( ) ; String ns = namespace == null ? XMLSymbols . EMPTY_STRING : namespace ; LocationArray tempLA = ( LocationArray ) locationPairs . get ( ns ) ; if ( tempLA != null ) loc = tempLA . getFirstLocation ( ) ; } if ( loc == null ) { String [ ] hints = desc . getLocationHints ( ) ; if ( hints != null && hints . length > _NUM ) loc = hints [ _NUM ] ; } String expandedLoc = XMLEntityManager . expandSystemId ( loc , desc . getBaseSystemId ( ) , _BOOL ) ; desc . setLiteralSystemId ( loc ) ; desc . setExpandedSystemId ( expandedLoc ) ; return entityResolver . resolveEntity ( desc ) ; }
public static XMLInputSource resolveDocument ( XSDDescription desc , Hashtable locationPairs , XMLEntityResolver entityResolver ) throws IOException { String loc = null ; if ( desc . getContextType ( ) == XSDDescription . CONTEXT_IMPORT || desc . fromInstance ( ) ) { String namespace = desc . getTargetNamespace ( ) ; String ns = namespace == null ? XMLSymbols . EMPTY_STRING : namespace ; LocationArray tempLA = ( LocationArray ) locationPairs . get ( ns ) ; if ( tempLA != null ) loc = tempLA . getFirstLocation ( ) ; } if ( loc == null ) { String [ ] hints = desc . getLocationHints ( ) ; if ( hints != null && hints . length > _NUM ) loc = hints [ _NUM ] ; } String expandedLoc = XMLEntityManager . expandSystemId ( loc , desc . getBaseSystemId ( ) , _BOOL ) ; desc . setLiteralSystemId ( loc ) ; desc . setExpandedSystemId ( expandedLoc ) ; return entityResolver . resolveEntity ( desc ) ; }
public static XMLInputSource resolveDocument ( XSDDescription desc , Hashtable locationPairs , XMLEntityResolver entityResolver ) throws IOException { String loc = null ; if ( desc . getContextType ( ) == XSDDescription . CONTEXT_IMPORT || desc . fromInstance ( ) ) { String namespace = desc . getTargetNamespace ( ) ; String ns = namespace == null ? XMLSymbols . EMPTY_STRING : namespace ; LocationArray tempLA = ( LocationArray ) locationPairs . get ( ns ) ; if ( tempLA != null ) loc = tempLA . getFirstLocation ( ) ; } if ( loc == null ) { String [ ] hints = desc . getLocationHints ( ) ; if ( hints != null && hints . length > _NUM ) loc = hints [ _NUM ] ; } String expandedLoc = XMLEntityManager . expandSystemId ( loc , desc . getBaseSystemId ( ) , _BOOL ) ; desc . setLiteralSystemId ( loc ) ; desc . setExpandedSystemId ( expandedLoc ) ; return entityResolver . resolveEntity ( desc ) ; }
public void testAddServletWithNameAndJspFile ( ) throws Exception { String xml = WEBAPP_TEST_HEADER + STRING + STRING ; WebXml webXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( xml . getBytes ( STRING ) ) , getEntityResolver ( ) ) ; WebXmlUtils . addJspFile ( webXml , STRING , STRING ) ; assertTrue ( WebXmlUtils . hasServlet ( webXml , STRING ) ) ; }
public void testAddServletWithNameAndJspFile ( ) throws Exception { String xml = WEBAPP_TEST_HEADER + STRING + STRING ; WebXml webXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( xml . getBytes ( STRING ) ) , getEntityResolver ( ) ) ; WebXmlUtils . addJspFile ( webXml , STRING , STRING ) ; assertTrue ( WebXmlUtils . hasServlet ( webXml , STRING ) ) ; }
static void stopRefreshTimer ( ) { try { if ( refreshTimer != null && mbeanServer != null ) { mbeanServer . unregisterMBean ( refreshTimerObjectName ) ; refreshTimer . stop ( ) ; } } catch ( JMException e ) { logStackTrace ( Level . WARN , e ) ; } catch ( JMRuntimeException e ) { logStackTrace ( Level . WARN , e ) ; } catch ( Exception e ) { logStackTrace ( Level . DEBUG , e , STRING ) ; } }
void expandCapacity ( int minimumCapacity ) { int newCapacity = ( value . length + _NUM ) * _NUM ; if ( newCapacity < _NUM ) { newCapacity = Integer . MAX_VALUE ; } else if ( minimumCapacity > newCapacity ) { newCapacity = minimumCapacity ; } value = Arrays . copyOf ( value , newCapacity ) ; }
void expandCapacity ( int minimumCapacity ) { int newCapacity = ( value . length + _NUM ) * _NUM ; if ( newCapacity < _NUM ) { newCapacity = Integer . MAX_VALUE ; } else if ( minimumCapacity > newCapacity ) { newCapacity = minimumCapacity ; } value = Arrays . copyOf ( value , newCapacity ) ; }
void expandCapacity ( int minimumCapacity ) { int newCapacity = ( value . length + _NUM ) * _NUM ; if ( newCapacity < _NUM ) { newCapacity = Integer . MAX_VALUE ; } else if ( minimumCapacity > newCapacity ) { newCapacity = minimumCapacity ; } value = Arrays . copyOf ( value , newCapacity ) ; }
private static String extractErrorSummary ( Throwable e ) { StringBuilder errorMessageBuilder = new StringBuilder ( ) ; Throwable cause = e ; errorMessageBuilder . append ( cause . getLocalizedMessage ( ) ) ; while ( cause != null ) { StackTraceElement [ ] stackTraceElements = cause . getStackTrace ( ) ; errorMessageBuilder . append ( stackTraceElements . length > _NUM ? STRING + stackTraceElements [ _NUM ] : STRING ) ; cause = cause . getCause ( ) ; } return errorMessageBuilder . toString ( ) ; }
static void validate ( ) { String sql = STRING ; PreparedStatement pstmt = null ; ResultSet rs = null ; try { pstmt = DB . prepareStatement ( sql , null ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { validate ( rs . getInt ( _NUM ) , rs . getString ( _NUM ) ) ; } } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } }
public double localScore ( int i , int [ ] parents ) { double sum = _NUM ; for ( BDeuScore score : scores ) { sum += score . localScore ( i , parents ) ; } return sum / scores . size ( ) ; }
public double localScore ( int i , int [ ] parents ) { double sum = _NUM ; for ( BDeuScore score : scores ) { sum += score . localScore ( i , parents ) ; } return sum / scores . size ( ) ; }
public double localScore ( int i , int [ ] parents ) { double sum = _NUM ; for ( BDeuScore score : scores ) { sum += score . localScore ( i , parents ) ; } return sum / scores . size ( ) ; }
public double localScore ( int i , int [ ] parents ) { double sum = _NUM ; for ( BDeuScore score : scores ) { sum += score . localScore ( i , parents ) ; } return sum / scores . size ( ) ; }
public void addNearEvicted ( KeyCacheObject key ) { if ( nearEvicted == null ) nearEvicted = new ArrayList < > ( ) ; nearEvicted . add ( key ) ; }
public static void checkExportGroupForCleanup ( ExportGroup exportGroup , DbClient dbClient ) { if ( exportGroup != null && dbClient != null ) { if ( ( exportGroup . checkInternalFlags ( Flag . INTERNAL_OBJECT ) ) && ( CollectionUtils . isEmpty ( exportGroup . getVolumes ( ) ) || CollectionUtils . isEmpty ( ExportMaskUtils . getExportMasks ( dbClient , exportGroup ) ) ) ) { _log . info ( String . format ( STRING , exportGroup . getLabel ( ) , exportGroup . getId ( ) ) ) ; dbClient . markForDeletion ( exportGroup ) ; } } }
public static void checkExportGroupForCleanup ( ExportGroup exportGroup , DbClient dbClient ) { if ( exportGroup != null && dbClient != null ) { if ( ( exportGroup . checkInternalFlags ( Flag . INTERNAL_OBJECT ) ) && ( CollectionUtils . isEmpty ( exportGroup . getVolumes ( ) ) || CollectionUtils . isEmpty ( ExportMaskUtils . getExportMasks ( dbClient , exportGroup ) ) ) ) { _log . info ( String . format ( STRING , exportGroup . getLabel ( ) , exportGroup . getId ( ) ) ) ; dbClient . markForDeletion ( exportGroup ) ; } } }
protected boolean [ ] incrementalEstimator ( ) { boolean [ ] result = new boolean [ _NUM ] ; print ( STRING ) ; if ( m_Estimator instanceof IncrementalEstimator ) { println ( STRING ) ; result [ _NUM ] = _BOOL ; } else { println ( STRING ) ; result [ _NUM ] = _BOOL ; } return result ; }
protected boolean [ ] incrementalEstimator ( ) { boolean [ ] result = new boolean [ _NUM ] ; print ( STRING ) ; if ( m_Estimator instanceof IncrementalEstimator ) { println ( STRING ) ; result [ _NUM ] = _BOOL ; } else { println ( STRING ) ; result [ _NUM ] = _BOOL ; } return result ; }
protected boolean [ ] incrementalEstimator ( ) { boolean [ ] result = new boolean [ _NUM ] ; print ( STRING ) ; if ( m_Estimator instanceof IncrementalEstimator ) { println ( STRING ) ; result [ _NUM ] = _BOOL ; } else { println ( STRING ) ; result [ _NUM ] = _BOOL ; } return result ; }
private final String msgStackToString ( ParseException e ) { StringBuffer msg ; msg = new StringBuffer ( STRING ) ; if ( ! expecting . equals ( emptyString ) ) { msg . append ( STRING ) ; msg . append ( expecting ) ; msg . append ( STRING ) ; } msg . append ( e . getShortMessage ( ) ) ; msg . append ( STRING ) ; int last = msgStackCurrentSize - _NUM ; if ( last < _NUM ) last = _NUM ; for ( int lvi = msgStackCurrentSize ; lvi > last ; lvi -= _NUM ) { msg . append ( ( String ) msgStack [ lvi - _NUM ] ) ; msg . append ( STRING ) ; Token t = ( Token ) msgStack [ lvi - _NUM ] ; msg . append ( t . beginLine ) ; msg . append ( STRING ) ; msg . append ( t . beginColumn ) ; msg . append ( STRING ) ; } return msg . toString ( ) ; }
private final String msgStackToString ( ParseException e ) { StringBuffer msg ; msg = new StringBuffer ( STRING ) ; if ( ! expecting . equals ( emptyString ) ) { msg . append ( STRING ) ; msg . append ( expecting ) ; msg . append ( STRING ) ; } msg . append ( e . getShortMessage ( ) ) ; msg . append ( STRING ) ; int last = msgStackCurrentSize - _NUM ; if ( last < _NUM ) last = _NUM ; for ( int lvi = msgStackCurrentSize ; lvi > last ; lvi -= _NUM ) { msg . append ( ( String ) msgStack [ lvi - _NUM ] ) ; msg . append ( STRING ) ; Token t = ( Token ) msgStack [ lvi - _NUM ] ; msg . append ( t . beginLine ) ; msg . append ( STRING ) ; msg . append ( t . beginColumn ) ; msg . append ( STRING ) ; } return msg . toString ( ) ; }
private final String msgStackToString ( ParseException e ) { StringBuffer msg ; msg = new StringBuffer ( STRING ) ; if ( ! expecting . equals ( emptyString ) ) { msg . append ( STRING ) ; msg . append ( expecting ) ; msg . append ( STRING ) ; } msg . append ( e . getShortMessage ( ) ) ; msg . append ( STRING ) ; int last = msgStackCurrentSize - _NUM ; if ( last < _NUM ) last = _NUM ; for ( int lvi = msgStackCurrentSize ; lvi > last ; lvi -= _NUM ) { msg . append ( ( String ) msgStack [ lvi - _NUM ] ) ; msg . append ( STRING ) ; Token t = ( Token ) msgStack [ lvi - _NUM ] ; msg . append ( t . beginLine ) ; msg . append ( STRING ) ; msg . append ( t . beginColumn ) ; msg . append ( STRING ) ; } return msg . toString ( ) ; }
private final String msgStackToString ( ParseException e ) { StringBuffer msg ; msg = new StringBuffer ( STRING ) ; if ( ! expecting . equals ( emptyString ) ) { msg . append ( STRING ) ; msg . append ( expecting ) ; msg . append ( STRING ) ; } msg . append ( e . getShortMessage ( ) ) ; msg . append ( STRING ) ; int last = msgStackCurrentSize - _NUM ; if ( last < _NUM ) last = _NUM ; for ( int lvi = msgStackCurrentSize ; lvi > last ; lvi -= _NUM ) { msg . append ( ( String ) msgStack [ lvi - _NUM ] ) ; msg . append ( STRING ) ; Token t = ( Token ) msgStack [ lvi - _NUM ] ; msg . append ( t . beginLine ) ; msg . append ( STRING ) ; msg . append ( t . beginColumn ) ; msg . append ( STRING ) ; } return msg . toString ( ) ; }
public void delete ( ) throws IOException { close ( ) ; Util . deleteContents ( directory ) ; }
public void delete ( ) throws IOException { close ( ) ; Util . deleteContents ( directory ) ; }
public void delete ( ) throws IOException { close ( ) ; Util . deleteContents ( directory ) ; }
public void delete ( ) throws IOException { close ( ) ; Util . deleteContents ( directory ) ; }
protected void sendFunctionGroup1 ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STRING ) ; sb . append ( address . getNumber ( ) ) ; sb . append ( STRING ) ; sb . append ( STRING ) ; sb . append ( ( f0 ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( STRING ) ; sb . append ( ( f1 ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( ( f2 ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( ( f3 ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( ( f4 ? STRING : STRING ) ) ; TamsMessage tm = new TamsMessage ( sb . toString ( ) ) ; tm . setBinary ( _BOOL ) ; tm . setReplyType ( STRING ) ; tc . sendTamsMessage ( tm , this ) ; tmq . add ( tm ) ; }
protected void sendFunctionGroup1 ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STRING ) ; sb . append ( address . getNumber ( ) ) ; sb . append ( STRING ) ; sb . append ( STRING ) ; sb . append ( ( f0 ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( STRING ) ; sb . append ( ( f1 ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( ( f2 ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( ( f3 ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( ( f4 ? STRING : STRING ) ) ; TamsMessage tm = new TamsMessage ( sb . toString ( ) ) ; tm . setBinary ( _BOOL ) ; tm . setReplyType ( STRING ) ; tc . sendTamsMessage ( tm , this ) ; tmq . add ( tm ) ; }
protected void calculateDestination ( IFile uxf , ICompilationUnit referencingCompilationUnit , Destination dest ) throws CoreException { IFile uxfDest = calculateImgDestination ( uxf , referencingCompilationUnit ) ; if ( uxfDest != null ) { dest . imgFileDestination = uxfDest ; } }
protected void calculateDestination ( IFile uxf , ICompilationUnit referencingCompilationUnit , Destination dest ) throws CoreException { IFile uxfDest = calculateImgDestination ( uxf , referencingCompilationUnit ) ; if ( uxfDest != null ) { dest . imgFileDestination = uxfDest ; } }
protected void calculateDestination ( IFile uxf , ICompilationUnit referencingCompilationUnit , Destination dest ) throws CoreException { IFile uxfDest = calculateImgDestination ( uxf , referencingCompilationUnit ) ; if ( uxfDest != null ) { dest . imgFileDestination = uxfDest ; } }
protected void calculateDestination ( IFile uxf , ICompilationUnit referencingCompilationUnit , Destination dest ) throws CoreException { IFile uxfDest = calculateImgDestination ( uxf , referencingCompilationUnit ) ; if ( uxfDest != null ) { dest . imgFileDestination = uxfDest ; } }
public void addUndoEvent ( UndoInterface event ) { if ( shouldProcessUndoRedoAction ( ) ) { boolean atEndOfList = ( currentIndex >= undoList . size ( ) ) ; if ( ! atEndOfList ) { while ( undoList . size ( ) > currentIndex ) { int lastIndex = undoList . size ( ) - _NUM ; undoList . remove ( lastIndex ) ; } } undoList . add ( event ) ; currentIndex = undoList . size ( ) ; updateMenuItems ( ) ; logger . debug ( event . getStringRepresentation ( ) ) ; } }
void removeCallback ( JSObject source , String method , boolean async ) { String key = source . toJSPointer ( ) + STRING + method ; callbacks . remove ( key ) ; String js = STRING + source . toJSPointer ( ) + STRING + method ; exec ( js , async ) ; }
public QueueTimeoutException ( Task task ) { super ( MessageFormat . format ( STRING + STRING , task ) ) ; }
public QueueTimeoutException ( Task task ) { super ( MessageFormat . format ( STRING + STRING , task ) ) ; }
public QueueTimeoutException ( Task task ) { super ( MessageFormat . format ( STRING + STRING , task ) ) ; }
public void removeProtocols ( final Set < String > protocols ) { if ( protocols != null && _protocols != null ) { HashSet < String > removeProtocols = new HashSet < String > ( ) ; removeProtocols . addAll ( protocols ) ; _protocols . removeAll ( removeProtocols ) ; } }
public SessionPropertyOpViewBeanBase ( String name ) { super ( name ) ; createPageTitleModel ( ) ; createPropertyModel ( ) ; registerChildren ( ) ; }
public < T > T asClass ( Class < T > clazz , T defaultValue ) { if ( value == null ) return defaultValue ; try { return clazz . cast ( value ) ; } catch ( ClassCastException e ) { return defaultValue ; } }
static boolean shouldOutput ( Configuration conf ) { return conf . getBoolean ( OUTPUT_FLAG , _BOOL ) ; }
public void addMenuItem ( FloatingActionButton item ) { mMenuItems . add ( item ) ; mMenuItemAnimators . add ( new ItemAnimator ( item ) ) ; TextView button = new TextView ( getContext ( ) ) ; LayoutParams params = new LayoutParams ( LayoutParams . WRAP_CONTENT , LayoutParams . WRAP_CONTENT ) ; button . setLayoutParams ( params ) ; button . setBackgroundResource ( R . drawable . rounded_corners ) ; button . setTextColor ( Color . WHITE ) ; button . setText ( item . getContentDescription ( ) ) ; Integer paddingSize = ( int ) button . getTextSize ( ) / _NUM ; button . setPadding ( paddingSize , paddingSize , paddingSize , paddingSize ) ; addView ( button ) ; mMenuItemLabels . add ( button ) ; item . setTag ( button ) ; item . setOnClickListener ( mOnItemClickListener ) ; button . setOnClickListener ( mOnItemClickListener ) ; }
private Object [ ] ensureCapacity ( int minCapacity ) { if ( tmp . length < minCapacity ) { int newSize = minCapacity ; { newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize ++ ; if ( newSize < _NUM ) newSize = minCapacity ; else newSize = Math . min ( newSize , a . length > > > _NUM ) ; } Object [ ] newArray = ( Object [ ] ) new Object [ newSize ] ; tmp = newArray ; } return tmp ; }
private Object [ ] ensureCapacity ( int minCapacity ) { if ( tmp . length < minCapacity ) { int newSize = minCapacity ; { newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize ++ ; if ( newSize < _NUM ) newSize = minCapacity ; else newSize = Math . min ( newSize , a . length > > > _NUM ) ; } Object [ ] newArray = ( Object [ ] ) new Object [ newSize ] ; tmp = newArray ; } return tmp ; }
private Object [ ] ensureCapacity ( int minCapacity ) { if ( tmp . length < minCapacity ) { int newSize = minCapacity ; { newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize ++ ; if ( newSize < _NUM ) newSize = minCapacity ; else newSize = Math . min ( newSize , a . length > > > _NUM ) ; } Object [ ] newArray = ( Object [ ] ) new Object [ newSize ] ; tmp = newArray ; } return tmp ; }
private Object [ ] ensureCapacity ( int minCapacity ) { if ( tmp . length < minCapacity ) { int newSize = minCapacity ; { newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize |= newSize > > _NUM ; newSize ++ ; if ( newSize < _NUM ) newSize = minCapacity ; else newSize = Math . min ( newSize , a . length > > > _NUM ) ; } Object [ ] newArray = ( Object [ ] ) new Object [ newSize ] ; tmp = newArray ; } return tmp ; }
public static WGLWindowSurfaceData createData ( WComponentPeer peer ) { if ( ! peer . isAccelCapable ( ) || ! SunToolkit . isContainingTopLevelOpaque ( ( Component ) peer . getTarget ( ) ) ) { return null ; } WGLGraphicsConfig gc = getGC ( peer ) ; return new WGLWindowSurfaceData ( peer , gc ) ; }
public static WGLWindowSurfaceData createData ( WComponentPeer peer ) { if ( ! peer . isAccelCapable ( ) || ! SunToolkit . isContainingTopLevelOpaque ( ( Component ) peer . getTarget ( ) ) ) { return null ; } WGLGraphicsConfig gc = getGC ( peer ) ; return new WGLWindowSurfaceData ( peer , gc ) ; }
public static WGLWindowSurfaceData createData ( WComponentPeer peer ) { if ( ! peer . isAccelCapable ( ) || ! SunToolkit . isContainingTopLevelOpaque ( ( Component ) peer . getTarget ( ) ) ) { return null ; } WGLGraphicsConfig gc = getGC ( peer ) ; return new WGLWindowSurfaceData ( peer , gc ) ; }
public DDistinguishedNameChooser ( JFrame parent , String title , X500Name distinguishedName , boolean editable ) { super ( parent , title , Dialog . ModalityType . DOCUMENT_MODAL ) ; this . distinguishedName = distinguishedName ; this . editable = editable ; initComponents ( ) ; }
protected char [ ] preprocess ( String text ) { return text . toCharArray ( ) ; }
protected char [ ] preprocess ( String text ) { return text . toCharArray ( ) ; }
protected char [ ] preprocess ( String text ) { return text . toCharArray ( ) ; }
protected char [ ] preprocess ( String text ) { return text . toCharArray ( ) ; }
protected char [ ] preprocess ( String text ) { return text . toCharArray ( ) ; }
protected char [ ] preprocess ( String text ) { return text . toCharArray ( ) ; }
protected char [ ] preprocess ( String text ) { return text . toCharArray ( ) ; }
protected char [ ] preprocess ( String text ) { return text . toCharArray ( ) ; }
protected char [ ] preprocess ( String text ) { return text . toCharArray ( ) ; }
public static DBIDs randomSample ( DBIDs ids , double rate , Random random ) { if ( rate <= _NUM ) { return ids ; } if ( rate < _NUM ) { int size = Math . min ( ( int ) ( rate * ids . size ( ) ) , ids . size ( ) ) ; return randomSample ( ids , size , random ) ; } int size = Math . min ( ( int ) rate , ids . size ( ) ) ; return randomSample ( ids , size , random ) ; }
protected void renumberColumns ( ) { Iterator iter = m_names . iterator ( ) ; for ( int idx = _NUM ; iter . hasNext ( ) ; ++ idx ) { String name = ( String ) iter . next ( ) ; ColumnEntry e = ( ColumnEntry ) m_entries . get ( name ) ; e . colnum = idx ; } }
protected void renumberColumns ( ) { Iterator iter = m_names . iterator ( ) ; for ( int idx = _NUM ; iter . hasNext ( ) ; ++ idx ) { String name = ( String ) iter . next ( ) ; ColumnEntry e = ( ColumnEntry ) m_entries . get ( name ) ; e . colnum = idx ; } }
protected void renumberColumns ( ) { Iterator iter = m_names . iterator ( ) ; for ( int idx = _NUM ; iter . hasNext ( ) ; ++ idx ) { String name = ( String ) iter . next ( ) ; ColumnEntry e = ( ColumnEntry ) m_entries . get ( name ) ; e . colnum = idx ; } }
void markInternalClasses ( ) { for ( int i = mClassDefs . length - _NUM ; i >= _NUM ; i -- ) { mTypeIds [ mClassDefs [ i ] . classIdx ] . internal = _BOOL ; } for ( int i = _NUM ; i < mTypeIds . length ; i ++ ) { String className = mStrings [ mTypeIds [ i ] . descriptorIdx ] ; if ( className . length ( ) == _NUM ) { mTypeIds [ i ] . internal = _BOOL ; } else if ( className . charAt ( _NUM ) == STRING ) { mTypeIds [ i ] . internal = _BOOL ; } } }
void markInternalClasses ( ) { for ( int i = mClassDefs . length - _NUM ; i >= _NUM ; i -- ) { mTypeIds [ mClassDefs [ i ] . classIdx ] . internal = _BOOL ; } for ( int i = _NUM ; i < mTypeIds . length ; i ++ ) { String className = mStrings [ mTypeIds [ i ] . descriptorIdx ] ; if ( className . length ( ) == _NUM ) { mTypeIds [ i ] . internal = _BOOL ; } else if ( className . charAt ( _NUM ) == STRING ) { mTypeIds [ i ] . internal = _BOOL ; } } }
void markInternalClasses ( ) { for ( int i = mClassDefs . length - _NUM ; i >= _NUM ; i -- ) { mTypeIds [ mClassDefs [ i ] . classIdx ] . internal = _BOOL ; } for ( int i = _NUM ; i < mTypeIds . length ; i ++ ) { String className = mStrings [ mTypeIds [ i ] . descriptorIdx ] ; if ( className . length ( ) == _NUM ) { mTypeIds [ i ] . internal = _BOOL ; } else if ( className . charAt ( _NUM ) == STRING ) { mTypeIds [ i ] . internal = _BOOL ; } } }
private long calculateMillisFor ( MPPOrderNode node , long commonBase ) { final BigDecimal qty = node . getQtyToDeliver ( ) ; long totalDuration = + node . getQueuingTime ( ) + node . getSetupTimeRequired ( ) + node . getMovingTime ( ) + node . getWaitingTime ( ) ; final BigDecimal workingTime = routingService . estimateWorkingTime ( node , qty ) ; totalDuration += workingTime . doubleValue ( ) ; return ( long ) ( totalDuration * commonBase * _NUM ) ; }
private long calculateMillisFor ( MPPOrderNode node , long commonBase ) { final BigDecimal qty = node . getQtyToDeliver ( ) ; long totalDuration = + node . getQueuingTime ( ) + node . getSetupTimeRequired ( ) + node . getMovingTime ( ) + node . getWaitingTime ( ) ; final BigDecimal workingTime = routingService . estimateWorkingTime ( node , qty ) ; totalDuration += workingTime . doubleValue ( ) ; return ( long ) ( totalDuration * commonBase * _NUM ) ; }
public static Plane constructNormalizedYPlane ( final double x , final double z , final double DValue ) { if ( Math . abs ( x ) < MINIMUM_RESOLUTION && Math . abs ( z ) < MINIMUM_RESOLUTION ) return null ; final double denom = _NUM / Math . sqrt ( x * x + z * z ) ; return new Plane ( z * denom , _NUM , - x * denom , DValue ) ; }
public List < String > tokenize ( String inputFileName , PrintWriter writer ) { JavaRDD < String > input = readTextFile ( inputFileName ) ; JavaRDD < String > output = tokenize ( input ) ; List < String > lines = output . collect ( ) ; for ( String line : lines ) { writer . write ( line ) ; writer . write ( STRING ) ; } writer . flush ( ) ; return lines ; }
public List < String > tokenize ( String inputFileName , PrintWriter writer ) { JavaRDD < String > input = readTextFile ( inputFileName ) ; JavaRDD < String > output = tokenize ( input ) ; List < String > lines = output . collect ( ) ; for ( String line : lines ) { writer . write ( line ) ; writer . write ( STRING ) ; } writer . flush ( ) ; return lines ; }
private CallLocationModel ( String clz , int line , Edge edge ) { super ( clz , line ) ; SootMethod targetMethod = edge . tgt ( ) ; String sig = targetMethod . getSignature ( ) ; targetMethodSig = sig . substring ( _NUM , sig . length ( ) - _NUM ) ; }
private CallLocationModel ( String clz , int line , Edge edge ) { super ( clz , line ) ; SootMethod targetMethod = edge . tgt ( ) ; String sig = targetMethod . getSignature ( ) ; targetMethodSig = sig . substring ( _NUM , sig . length ( ) - _NUM ) ; }
public void rewind ( ) { synchronized ( used ) { for ( ParameterPair pair : used ) { current . addParameter ( pair . option , pair . value ) ; } used . clear ( ) ; } }
public static void saveAsGnuStepASCII ( NSArray root , File out ) throws IOException { File parent = out . getParentFile ( ) ; if ( ! parent . exists ( ) && ! parent . mkdirs ( ) ) { throw new IOException ( STRING ) ; } OutputStreamWriter w = new OutputStreamWriter ( new FileOutputStream ( out ) , STRING ) ; w . write ( root . toGnuStepASCIIPropertyList ( ) ) ; w . close ( ) ; }
public static PersistentSearchRequestControl newControl ( final boolean isCritical , final boolean changesOnly , final boolean returnECs , final Collection < PersistentSearchChangeType > changeTypes ) { Reject . ifNull ( changeTypes ) ; final Set < PersistentSearchChangeType > copyOfChangeTypes = EnumSet . noneOf ( PersistentSearchChangeType . class ) ; copyOfChangeTypes . addAll ( changeTypes ) ; return new PersistentSearchRequestControl ( isCritical , changesOnly , returnECs , Collections . unmodifiableSet ( copyOfChangeTypes ) ) ; }
@ Override public double prevCumulativeQuantity ( final Long woActivityId , Long mbHeaderId ) { if ( mbHeaderId == null ) mbHeaderId = - _NUM ; final Object [ ] params = new Object [ ] { mbHeaderId , mbHeaderId , WorksConstants . CANCELLED_STATUS , woActivityId } ; final Double pQuant = ( Double ) genericService . findByNamedQuery ( STRING , params ) ; if ( pQuant == null ) return _NUM ; else return pQuant . doubleValue ( ) ; }
@ Override public double prevCumulativeQuantity ( final Long woActivityId , Long mbHeaderId ) { if ( mbHeaderId == null ) mbHeaderId = - _NUM ; final Object [ ] params = new Object [ ] { mbHeaderId , mbHeaderId , WorksConstants . CANCELLED_STATUS , woActivityId } ; final Double pQuant = ( Double ) genericService . findByNamedQuery ( STRING , params ) ; if ( pQuant == null ) return _NUM ; else return pQuant . doubleValue ( ) ; }
@ Override public double prevCumulativeQuantity ( final Long woActivityId , Long mbHeaderId ) { if ( mbHeaderId == null ) mbHeaderId = - _NUM ; final Object [ ] params = new Object [ ] { mbHeaderId , mbHeaderId , WorksConstants . CANCELLED_STATUS , woActivityId } ; final Double pQuant = ( Double ) genericService . findByNamedQuery ( STRING , params ) ; if ( pQuant == null ) return _NUM ; else return pQuant . doubleValue ( ) ; }
@ Override public double prevCumulativeQuantity ( final Long woActivityId , Long mbHeaderId ) { if ( mbHeaderId == null ) mbHeaderId = - _NUM ; final Object [ ] params = new Object [ ] { mbHeaderId , mbHeaderId , WorksConstants . CANCELLED_STATUS , woActivityId } ; final Double pQuant = ( Double ) genericService . findByNamedQuery ( STRING , params ) ; if ( pQuant == null ) return _NUM ; else return pQuant . doubleValue ( ) ; }
public boolean checkAllQueriedMessages ( boolean check , String query ) { if ( query == null || query . length ( ) == _NUM ) { return checkAllMessages ( check , _BOOL ) ; } SQLiteDatabase db = getWritableDatabase ( ) ; if ( db != null ) { String parentOnly = STRING + COL_BIGPARENT + STRING + COL_BIGPARENT + STRING + COL_MESSAGE_ID + STRING + TABLE + STRING + COL_DELETED + STRING + FALSE + STRING + COL_PARENT + STRING + COL_MESSAGE_ID + STRING + TABLE + STRING + COL_DELETED + STRING + FALSE + STRING ; db . execSQL ( STRING + TABLE + STRING + COL_CHECKED + STRING + ( check ? TRUE : FALSE ) + STRING + COL_DELETED + STRING + FALSE + STRING + query + parentOnly + STRING ) ; return _BOOL ; } return _BOOL ; }
public void addEventFirst ( SimEvent newEvent ) { newEvent . setSerial ( _NUM ) ; sortedSet . add ( newEvent ) ; }
private boolean isHardcodedFilenameString ( String string ) { if ( string == null ) { return _BOOL ; } if ( string . indexOf ( ( int ) STRING ) == - _NUM && string . indexOf ( ( int ) STRING ) == - _NUM ) { return _BOOL ; } final char startChar = string . charAt ( _NUM ) ; if ( Character . isLetter ( startChar ) && string . charAt ( _NUM ) == STRING ) { return _BOOL ; } if ( isXMLString ( string ) ) { return _BOOL ; } if ( isDateFormatString ( string ) ) { return _BOOL ; } if ( isURLString ( string ) ) { return _BOOL ; } if ( isMediaTypeString ( string ) ) { return _BOOL ; } return ! isTimeZoneIdString ( string ) ; }
private boolean isHardcodedFilenameString ( String string ) { if ( string == null ) { return _BOOL ; } if ( string . indexOf ( ( int ) STRING ) == - _NUM && string . indexOf ( ( int ) STRING ) == - _NUM ) { return _BOOL ; } final char startChar = string . charAt ( _NUM ) ; if ( Character . isLetter ( startChar ) && string . charAt ( _NUM ) == STRING ) { return _BOOL ; } if ( isXMLString ( string ) ) { return _BOOL ; } if ( isDateFormatString ( string ) ) { return _BOOL ; } if ( isURLString ( string ) ) { return _BOOL ; } if ( isMediaTypeString ( string ) ) { return _BOOL ; } return ! isTimeZoneIdString ( string ) ; }
private boolean isHardcodedFilenameString ( String string ) { if ( string == null ) { return _BOOL ; } if ( string . indexOf ( ( int ) STRING ) == - _NUM && string . indexOf ( ( int ) STRING ) == - _NUM ) { return _BOOL ; } final char startChar = string . charAt ( _NUM ) ; if ( Character . isLetter ( startChar ) && string . charAt ( _NUM ) == STRING ) { return _BOOL ; } if ( isXMLString ( string ) ) { return _BOOL ; } if ( isDateFormatString ( string ) ) { return _BOOL ; } if ( isURLString ( string ) ) { return _BOOL ; } if ( isMediaTypeString ( string ) ) { return _BOOL ; } return ! isTimeZoneIdString ( string ) ; }
private boolean isHardcodedFilenameString ( String string ) { if ( string == null ) { return _BOOL ; } if ( string . indexOf ( ( int ) STRING ) == - _NUM && string . indexOf ( ( int ) STRING ) == - _NUM ) { return _BOOL ; } final char startChar = string . charAt ( _NUM ) ; if ( Character . isLetter ( startChar ) && string . charAt ( _NUM ) == STRING ) { return _BOOL ; } if ( isXMLString ( string ) ) { return _BOOL ; } if ( isDateFormatString ( string ) ) { return _BOOL ; } if ( isURLString ( string ) ) { return _BOOL ; } if ( isMediaTypeString ( string ) ) { return _BOOL ; } return ! isTimeZoneIdString ( string ) ; }
private boolean isHardcodedFilenameString ( String string ) { if ( string == null ) { return _BOOL ; } if ( string . indexOf ( ( int ) STRING ) == - _NUM && string . indexOf ( ( int ) STRING ) == - _NUM ) { return _BOOL ; } final char startChar = string . charAt ( _NUM ) ; if ( Character . isLetter ( startChar ) && string . charAt ( _NUM ) == STRING ) { return _BOOL ; } if ( isXMLString ( string ) ) { return _BOOL ; } if ( isDateFormatString ( string ) ) { return _BOOL ; } if ( isURLString ( string ) ) { return _BOOL ; } if ( isMediaTypeString ( string ) ) { return _BOOL ; } return ! isTimeZoneIdString ( string ) ; }
private String stringifyIP ( byte [ ] ip ) { String temp = STRING ; for ( int i = _NUM ; i < ip . length / _NUM ; i ++ ) { temp += Integer . toString ( ip [ i ] & _NUM ) + STRING ; } temp = temp . substring ( _NUM , temp . length ( ) - _NUM ) ; temp += STRING ; for ( int i = ip . length / _NUM ; i < ip . length ; i ++ ) { temp += Integer . toString ( ip [ i ] & _NUM ) + STRING ; } temp = temp . substring ( _NUM , temp . length ( ) - _NUM ) ; return temp ; }
public ResultSet executeQuery ( String sql ) throws DatabaseException { Statement stmt = null ; try { stmt = connection . createStatement ( ) ; return stmt . executeQuery ( sql ) ; } catch ( SQLException e ) { throw ( new DatabaseException ( e ) ) ; } finally { try { if ( stmt != null ) { stmt . close ( ) ; } } catch ( SQLException e ) { } } }
public ResultSet executeQuery ( String sql ) throws DatabaseException { Statement stmt = null ; try { stmt = connection . createStatement ( ) ; return stmt . executeQuery ( sql ) ; } catch ( SQLException e ) { throw ( new DatabaseException ( e ) ) ; } finally { try { if ( stmt != null ) { stmt . close ( ) ; } } catch ( SQLException e ) { } } }
@ Override public void process ( String tuple ) { if ( ! validTuple ( tuple ) ) { return ; } beginProcessTokens ( ) ; processTokens ( tuple . split ( splitBy ) ) ; endProcessTokens ( ) ; }
@ Override public void process ( String tuple ) { if ( ! validTuple ( tuple ) ) { return ; } beginProcessTokens ( ) ; processTokens ( tuple . split ( splitBy ) ) ; endProcessTokens ( ) ; }
protected void computeLinks ( Element e ) throws BadLocationException { int caretPos = getCaretPosition ( ) ; try { if ( isLink ( e ) ) correctLink ( e ) ; else createLink ( e ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } setCaretPosition ( Math . min ( caretPos , getLength ( ) ) ) ; }
public static void submitGraphOptimizerJob ( OptimizableBipartiteGraph graph , OptimizableBipartiteGraphSegment segment ) { OPTIMIZER_SERVICE . submit ( new GraphOptimizerJob ( graph , segment ) ) ; }
public static void submitGraphOptimizerJob ( OptimizableBipartiteGraph graph , OptimizableBipartiteGraphSegment segment ) { OPTIMIZER_SERVICE . submit ( new GraphOptimizerJob ( graph , segment ) ) ; }
public final double doOperation ( ) { final int dim = parameter . getDimension ( ) ; double sum = _NUM ; if ( usesPriorOnSum ) { for ( int i = _NUM ; i < dim ; i ++ ) { sum += Math . abs ( parameter . getParameterValue ( i ) ) ; } } final int pos = MathUtils . nextInt ( dim ) ; final int value = ( int ) parameter . getParameterValue ( pos ) ; double logq = _NUM ; if ( value == _NUM ) { logq = bitFlipHelper . flipZero ( pos , dim , sum ) ; } else if ( value == _NUM ) { logq = bitFlipHelper . flipOne ( pos , dim , sum ) ; } else if ( value == - _NUM ) { logq = bitFlipHelper . flipNegOne ( pos , dim , sum ) ; } else { throw new RuntimeException ( STRING ) ; } if ( ! usesPriorOnSum ) { logq = _NUM ; } return logq ; }
public final double doOperation ( ) { final int dim = parameter . getDimension ( ) ; double sum = _NUM ; if ( usesPriorOnSum ) { for ( int i = _NUM ; i < dim ; i ++ ) { sum += Math . abs ( parameter . getParameterValue ( i ) ) ; } } final int pos = MathUtils . nextInt ( dim ) ; final int value = ( int ) parameter . getParameterValue ( pos ) ; double logq = _NUM ; if ( value == _NUM ) { logq = bitFlipHelper . flipZero ( pos , dim , sum ) ; } else if ( value == _NUM ) { logq = bitFlipHelper . flipOne ( pos , dim , sum ) ; } else if ( value == - _NUM ) { logq = bitFlipHelper . flipNegOne ( pos , dim , sum ) ; } else { throw new RuntimeException ( STRING ) ; } if ( ! usesPriorOnSum ) { logq = _NUM ; } return logq ; }
public final double doOperation ( ) { final int dim = parameter . getDimension ( ) ; double sum = _NUM ; if ( usesPriorOnSum ) { for ( int i = _NUM ; i < dim ; i ++ ) { sum += Math . abs ( parameter . getParameterValue ( i ) ) ; } } final int pos = MathUtils . nextInt ( dim ) ; final int value = ( int ) parameter . getParameterValue ( pos ) ; double logq = _NUM ; if ( value == _NUM ) { logq = bitFlipHelper . flipZero ( pos , dim , sum ) ; } else if ( value == _NUM ) { logq = bitFlipHelper . flipOne ( pos , dim , sum ) ; } else if ( value == - _NUM ) { logq = bitFlipHelper . flipNegOne ( pos , dim , sum ) ; } else { throw new RuntimeException ( STRING ) ; } if ( ! usesPriorOnSum ) { logq = _NUM ; } return logq ; }
@ NotNull public static String capitalize ( @ NotNull String s ) { return s . isEmpty ( ) ? s : ( toUpperCase ( s . charAt ( _NUM ) ) + s . substring ( _NUM ) ) ; }
private boolean canMapRegs ( ArrayList < RegisterSpec > specs , int ropReg ) { for ( RegisterSpec spec : specs ) { if ( ssaRegsMapped . get ( spec . getReg ( ) ) ) continue ; if ( ! canMapReg ( spec , ropReg ) ) return _BOOL ; } return _BOOL ; }
private boolean canMapRegs ( ArrayList < RegisterSpec > specs , int ropReg ) { for ( RegisterSpec spec : specs ) { if ( ssaRegsMapped . get ( spec . getReg ( ) ) ) continue ; if ( ! canMapReg ( spec , ropReg ) ) return _BOOL ; } return _BOOL ; }
private boolean canMapRegs ( ArrayList < RegisterSpec > specs , int ropReg ) { for ( RegisterSpec spec : specs ) { if ( ssaRegsMapped . get ( spec . getReg ( ) ) ) continue ; if ( ! canMapReg ( spec , ropReg ) ) return _BOOL ; } return _BOOL ; }
private boolean canMapRegs ( ArrayList < RegisterSpec > specs , int ropReg ) { for ( RegisterSpec spec : specs ) { if ( ssaRegsMapped . get ( spec . getReg ( ) ) ) continue ; if ( ! canMapReg ( spec , ropReg ) ) return _BOOL ; } return _BOOL ; }
private boolean canMapRegs ( ArrayList < RegisterSpec > specs , int ropReg ) { for ( RegisterSpec spec : specs ) { if ( ssaRegsMapped . get ( spec . getReg ( ) ) ) continue ; if ( ! canMapReg ( spec , ropReg ) ) return _BOOL ; } return _BOOL ; }
private boolean canMapRegs ( ArrayList < RegisterSpec > specs , int ropReg ) { for ( RegisterSpec spec : specs ) { if ( ssaRegsMapped . get ( spec . getReg ( ) ) ) continue ; if ( ! canMapReg ( spec , ropReg ) ) return _BOOL ; } return _BOOL ; }
private double allowableError ( int rank ) { int size = samples . size ( ) ; final double error = calculateError ( rank , size ) ; final double minError = size + _NUM ; if ( error < minError ) { return error ; } return minError ; }
public void addColumn ( Column previousColumn , Column column ) { if ( column != null ) { if ( previousColumn == null ) { columns . add ( _NUM , column ) ; } else { columns . add ( columns . indexOf ( previousColumn ) , column ) ; } } }
public static Shape3D createShape3D ( double [ ] data , int realDataIndex , int [ ] stripCount , Color color , boolean filled ) { try { double [ ] newData = new double [ realDataIndex ] ; System . arraycopy ( data , _NUM , newData , _NUM , realDataIndex ) ; if ( filled ) { return createFilled ( newData , stripCount , color ) ; } else { return createEdges ( newData , color ) ; } } catch ( java . lang . IllegalArgumentException iae ) { Debug . error ( STRING + iae . toString ( ) ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = _NUM ; i < stripCount . length ; i ++ ) { sb . append ( STRING + stripCount [ i ] + STRING ) ; } Debug . output ( STRING + ( filled ? STRING : STRING ) + STRING + data . length + STRING + data . length / _NUM + STRING + stripCount . length + STRING + sb . toString ( ) ) ; } return null ; }
public static Shape3D createShape3D ( double [ ] data , int realDataIndex , int [ ] stripCount , Color color , boolean filled ) { try { double [ ] newData = new double [ realDataIndex ] ; System . arraycopy ( data , _NUM , newData , _NUM , realDataIndex ) ; if ( filled ) { return createFilled ( newData , stripCount , color ) ; } else { return createEdges ( newData , color ) ; } } catch ( java . lang . IllegalArgumentException iae ) { Debug . error ( STRING + iae . toString ( ) ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = _NUM ; i < stripCount . length ; i ++ ) { sb . append ( STRING + stripCount [ i ] + STRING ) ; } Debug . output ( STRING + ( filled ? STRING : STRING ) + STRING + data . length + STRING + data . length / _NUM + STRING + stripCount . length + STRING + sb . toString ( ) ) ; } return null ; }
@ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { if ( readySent ) { setScaleAndCenter ( getScale ( ) , getCenter ( ) ) ; } }
private void registerDefaultValidatorIds ( Application application , LinkedHashSet < String > defaultValidatorIds ) { if ( defaultValidatorIds == null ) { defaultValidatorIds = new LinkedHashSet < > ( ) ; if ( isBeanValidatorAvailable ( ) ) { WebConfiguration webConfig = WebConfiguration . getInstance ( ) ; if ( ! webConfig . isOptionEnabled ( WebConfiguration . BooleanWebContextInitParameter . DisableDefaultBeanValidator ) ) { defaultValidatorIds . add ( BeanValidator . VALIDATOR_ID ) ; } } } for ( String validatorId : defaultValidatorIds ) { if ( LOGGER . isLoggable ( Level . FINE ) ) { LOGGER . log ( Level . FINE , MessageFormat . format ( STRING , validatorId ) ) ; } application . addDefaultValidatorId ( validatorId ) ; } }
private void registerDefaultValidatorIds ( Application application , LinkedHashSet < String > defaultValidatorIds ) { if ( defaultValidatorIds == null ) { defaultValidatorIds = new LinkedHashSet < > ( ) ; if ( isBeanValidatorAvailable ( ) ) { WebConfiguration webConfig = WebConfiguration . getInstance ( ) ; if ( ! webConfig . isOptionEnabled ( WebConfiguration . BooleanWebContextInitParameter . DisableDefaultBeanValidator ) ) { defaultValidatorIds . add ( BeanValidator . VALIDATOR_ID ) ; } } } for ( String validatorId : defaultValidatorIds ) { if ( LOGGER . isLoggable ( Level . FINE ) ) { LOGGER . log ( Level . FINE , MessageFormat . format ( STRING , validatorId ) ) ; } application . addDefaultValidatorId ( validatorId ) ; } }
private void registerDefaultValidatorIds ( Application application , LinkedHashSet < String > defaultValidatorIds ) { if ( defaultValidatorIds == null ) { defaultValidatorIds = new LinkedHashSet < > ( ) ; if ( isBeanValidatorAvailable ( ) ) { WebConfiguration webConfig = WebConfiguration . getInstance ( ) ; if ( ! webConfig . isOptionEnabled ( WebConfiguration . BooleanWebContextInitParameter . DisableDefaultBeanValidator ) ) { defaultValidatorIds . add ( BeanValidator . VALIDATOR_ID ) ; } } } for ( String validatorId : defaultValidatorIds ) { if ( LOGGER . isLoggable ( Level . FINE ) ) { LOGGER . log ( Level . FINE , MessageFormat . format ( STRING , validatorId ) ) ; } application . addDefaultValidatorId ( validatorId ) ; } }
public ConnectionAcceptor ( TCPTransport transport ) { this . transport = transport ; }
public ConnectionAcceptor ( TCPTransport transport ) { this . transport = transport ; }
public ConnectionAcceptor ( TCPTransport transport ) { this . transport = transport ; }
@ Override public boolean add ( IMessage message ) { return add ( message , _BOOL ) ; }
@ Override public boolean add ( IMessage message ) { return add ( message , _BOOL ) ; }
@ Override public String toString ( ) { StringBuilder stringBuilder = new StringBuilder ( STRING ) ; for ( NodeCollection parent : parents ) { stringBuilder . append ( parent . getId ( ) + STRING ) ; } stringBuilder . append ( STRING ) ; for ( NodeCollection child : children ) { stringBuilder . append ( child . getId ( ) + STRING ) ; } stringBuilder . append ( STRING ) ; return stringBuilder . toString ( ) ; }
@ Override public String toString ( ) { StringBuilder stringBuilder = new StringBuilder ( STRING ) ; for ( NodeCollection parent : parents ) { stringBuilder . append ( parent . getId ( ) + STRING ) ; } stringBuilder . append ( STRING ) ; for ( NodeCollection child : children ) { stringBuilder . append ( child . getId ( ) + STRING ) ; } stringBuilder . append ( STRING ) ; return stringBuilder . toString ( ) ; }
@ Override public String toString ( ) { StringBuilder stringBuilder = new StringBuilder ( STRING ) ; for ( NodeCollection parent : parents ) { stringBuilder . append ( parent . getId ( ) + STRING ) ; } stringBuilder . append ( STRING ) ; for ( NodeCollection child : children ) { stringBuilder . append ( child . getId ( ) + STRING ) ; } stringBuilder . append ( STRING ) ; return stringBuilder . toString ( ) ; }
@ Override public String toString ( ) { StringBuilder stringBuilder = new StringBuilder ( STRING ) ; for ( NodeCollection parent : parents ) { stringBuilder . append ( parent . getId ( ) + STRING ) ; } stringBuilder . append ( STRING ) ; for ( NodeCollection child : children ) { stringBuilder . append ( child . getId ( ) + STRING ) ; } stringBuilder . append ( STRING ) ; return stringBuilder . toString ( ) ; }
@ Override public String toString ( ) { StringBuilder stringBuilder = new StringBuilder ( STRING ) ; for ( NodeCollection parent : parents ) { stringBuilder . append ( parent . getId ( ) + STRING ) ; } stringBuilder . append ( STRING ) ; for ( NodeCollection child : children ) { stringBuilder . append ( child . getId ( ) + STRING ) ; } stringBuilder . append ( STRING ) ; return stringBuilder . toString ( ) ; }
public void testCreateAttributeNS2 ( ) throws Throwable { Document doc ; Attr attribute1 ; Attr attribute2 ; String name ; String nodeName ; String nodeValue ; String prefix ; String namespaceURI ; doc = ( Document ) load ( STRING , builder ) ; attribute1 = doc . createAttributeNS ( STRING , STRING ) ; name = attribute1 . getName ( ) ; nodeName = attribute1 . getNodeName ( ) ; nodeValue = attribute1 . getNodeValue ( ) ; prefix = attribute1 . getPrefix ( ) ; namespaceURI = attribute1 . getNamespaceURI ( ) ; assertEquals ( STRING , STRING , name ) ; assertEquals ( STRING , STRING , nodeName ) ; assertEquals ( STRING , STRING , nodeValue ) ; assertEquals ( STRING , STRING , prefix ) ; assertEquals ( STRING , STRING , namespaceURI ) ; attribute2 = doc . createAttributeNS ( STRING , STRING ) ; name = attribute2 . getName ( ) ; nodeName = attribute2 . getNodeName ( ) ; nodeValue = attribute2 . getNodeValue ( ) ; prefix = attribute2 . getPrefix ( ) ; namespaceURI = attribute2 . getNamespaceURI ( ) ; assertEquals ( STRING , STRING , name ) ; assertEquals ( STRING , STRING , nodeName ) ; assertEquals ( STRING , STRING , nodeValue ) ; assertEquals ( STRING , STRING , namespaceURI ) ; }
public int checksum_ts ( ) { return calculateChecksum ( compile_checksum . toString ( ) + compile_checksum_ts . toString ( ) ) ; }
public int checksum_ts ( ) { return calculateChecksum ( compile_checksum . toString ( ) + compile_checksum_ts . toString ( ) ) ; }
private GeneralName createGeneralName ( String t , String v ) throws Exception { GeneralNameInterface gn ; int p = oneOf ( t , STRING , STRING , STRING , STRING , STRING ) ; if ( p < _NUM ) { throw new Exception ( rb . getString ( STRING ) + t ) ; } switch ( p ) { case _NUM : gn = new RFC822Name ( v ) ; break ; case _NUM : gn = new URIName ( v ) ; break ; case _NUM : gn = new DNSName ( v ) ; break ; case _NUM : gn = new IPAddressName ( v ) ; break ; default : gn = new OIDName ( v ) ; break ; } return new GeneralName ( gn ) ; }
@ Override public void modifyMemberShip ( SSOToken token , IdType type , String name , Set < String > members , IdType membersType , int operation ) throws IdRepoException { if ( DEBUG . messageEnabled ( ) ) { DEBUG . message ( STRING ) ; } if ( members == null || members . isEmpty ( ) ) { throw newIdRepoException ( IdRepoErrorCode . ILLEGAL_ARGUMENTS ) ; } if ( type . equals ( IdType . USER ) ) { throw newIdRepoException ( IdRepoErrorCode . MEMBERSHIP_TO_USERS_AND_AGENTS_NOT_ALLOWED ) ; } if ( ! membersType . equals ( IdType . USER ) ) { throw newIdRepoException ( IdRepoErrorCode . MEMBERSHIPS_FOR_NOT_USERS_NOT_ALLOWED , CLASS_NAME ) ; } String dn = getDN ( type , name ) ; Set < String > memberDNs = new HashSet < > ( members . size ( ) ) ; for ( String member : members ) { memberDNs . add ( getDN ( membersType , member ) ) ; } if ( type . equals ( IdType . GROUP ) ) { modifyGroupMembership ( dn , memberDNs , operation ) ; } else if ( type . equals ( IdType . ROLE ) ) { modifyRoleMembership ( dn , memberDNs , operation ) ; } else { throw newIdRepoException ( IdRepoErrorCode . MEMBERSHIP_CANNOT_BE_MODIFIED , CLASS_NAME , type . getName ( ) ) ; } }
private TemplateValue templateValue ( String value ) { TemplateValue templateVal = new TemplateFile . TemplateValue ( null ) ; templateVal . append ( value ) ; return templateVal ; }
private boolean annotationPropertySet ( Annotation annotation , String attributeName ) { Object defaultValue = AnnotationUtils . getDefaultValue ( annotation , attributeName ) ; Object currentValue = AnnotationUtils . getValue ( annotation , attributeName ) ; return ! currentValue . equals ( defaultValue ) ; }
public static void addActivityListener ( ActivityListener listener ) { if ( listener != null ) { startTracking ( ) ; listeners . add ( listener ) ; } }
public static void addActivityListener ( ActivityListener listener ) { if ( listener != null ) { startTracking ( ) ; listeners . add ( listener ) ; } }
public void parseElement ( String tagName , Map < String , Object > attrs ) { if ( canvas == null && tagName . equalsIgnoreCase ( STRING ) ) { scale = mxUtils . getDouble ( attrs , STRING , _NUM ) ; canvas = createCanvas ( attrs ) ; if ( canvas != null ) { canvas . setScale ( scale ) ; } } else if ( canvas != null ) { boolean drawLabel = _BOOL ; if ( tagName . equalsIgnoreCase ( STRING ) || tagName . equalsIgnoreCase ( STRING ) ) { drawVertex ( attrs ) ; drawLabel = _BOOL ; } else if ( tagName . equalsIgnoreCase ( STRING ) ) { drawEdge ( attrs ) ; drawLabel = _BOOL ; } if ( drawLabel ) { drawLabel ( tagName . equalsIgnoreCase ( STRING ) , attrs ) ; } } }
public String makeLiteral ( Object object , boolean singleQuote ) { StringBuilder sb = new StringBuilder ( ) ; makeLiteral ( sb , object , singleQuote ) ; return sb . toString ( ) ; }
public static Point2D intersectParam ( Point2D u0 , Point2D v0 , Point2D u1 , Point2D v1 ) { double det = determinant2by2 ( v1 , v0 ) ; if ( Double . isNaN ( det ) || det == _NUM ) { return null ; } double x00 = u0 . getX ( ) ; double y00 = u0 . getY ( ) ; double x10 = u1 . getX ( ) ; double y10 = u1 . getY ( ) ; double x01 = v0 . getX ( ) ; double y01 = v0 . getY ( ) ; double x11 = v1 . getX ( ) ; double y11 = v1 . getY ( ) ; double s = ( _NUM / det ) * ( ( x00 - x10 ) * y01 - ( y00 - y10 ) * x01 ) ; double t = ( _NUM / det ) * - ( - ( x00 - x10 ) * y11 + ( y00 - y10 ) * x11 ) ; return new java . awt . geom . Point2D . Double ( t , s ) ; }
public static PrivateKey privateKeyFromPkcs8 ( String privateKeyPem ) throws IOException { StringReader reader = new StringReader ( privateKeyPem ) ; Section section = PemReader . readFirstSectionAndClose ( reader , PRIVATE_KEY ) ; if ( section == null ) { throw new IOException ( STRING ) ; } try { byte [ ] decodedKey = section . getBase64DecodedBytes ( ) ; PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec ( decodedKey ) ; KeyFactory keyFactory = SecurityUtils . getRsaKeyFactory ( ) ; return keyFactory . generatePrivate ( keySpec ) ; } catch ( Exception e ) { throw new IOException ( STRING , e ) ; } }
public static PrivateKey privateKeyFromPkcs8 ( String privateKeyPem ) throws IOException { StringReader reader = new StringReader ( privateKeyPem ) ; Section section = PemReader . readFirstSectionAndClose ( reader , PRIVATE_KEY ) ; if ( section == null ) { throw new IOException ( STRING ) ; } try { byte [ ] decodedKey = section . getBase64DecodedBytes ( ) ; PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec ( decodedKey ) ; KeyFactory keyFactory = SecurityUtils . getRsaKeyFactory ( ) ; return keyFactory . generatePrivate ( keySpec ) ; } catch ( Exception e ) { throw new IOException ( STRING , e ) ; } }
protected void createRenderers ( CombinedChart chart , ChartAnimator animator , ViewPortHandler viewPortHandler ) { mRenderers = new ArrayList < DataRenderer > ( ) ; DrawOrder [ ] orders = chart . getDrawOrder ( ) ; for ( DrawOrder order : orders ) { switch ( order ) { case BAR : if ( chart . getBarData ( ) != null ) mRenderers . add ( new BarChartRenderer ( chart , animator , viewPortHandler ) ) ; break ; case LINE : if ( chart . getLineData ( ) != null ) mRenderers . add ( new LineChartRenderer ( chart , animator , viewPortHandler ) ) ; break ; case CANDLE : if ( chart . getCandleData ( ) != null ) mRenderers . add ( new CandleStickChartRenderer ( chart , animator , viewPortHandler ) ) ; break ; case SCATTER : if ( chart . getScatterData ( ) != null ) mRenderers . add ( new ScatterChartRenderer ( chart , animator , viewPortHandler ) ) ; break ; } } }
protected void createRenderers ( CombinedChart chart , ChartAnimator animator , ViewPortHandler viewPortHandler ) { mRenderers = new ArrayList < DataRenderer > ( ) ; DrawOrder [ ] orders = chart . getDrawOrder ( ) ; for ( DrawOrder order : orders ) { switch ( order ) { case BAR : if ( chart . getBarData ( ) != null ) mRenderers . add ( new BarChartRenderer ( chart , animator , viewPortHandler ) ) ; break ; case LINE : if ( chart . getLineData ( ) != null ) mRenderers . add ( new LineChartRenderer ( chart , animator , viewPortHandler ) ) ; break ; case CANDLE : if ( chart . getCandleData ( ) != null ) mRenderers . add ( new CandleStickChartRenderer ( chart , animator , viewPortHandler ) ) ; break ; case SCATTER : if ( chart . getScatterData ( ) != null ) mRenderers . add ( new ScatterChartRenderer ( chart , animator , viewPortHandler ) ) ; break ; } } }
public static boolean cancelPotentialWork ( Object data , ImageView imageView ) { final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask ( imageView ) ; if ( bitmapWorkerTask != null ) { final Object bitmapData = bitmapWorkerTask . mData ; if ( bitmapData == null || ! bitmapData . equals ( data ) ) { bitmapWorkerTask . cancel ( _BOOL ) ; Log . d ( TAG , STRING + data ) ; } else { return _BOOL ; } } return _BOOL ; }
public static boolean cancelPotentialWork ( Object data , ImageView imageView ) { final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask ( imageView ) ; if ( bitmapWorkerTask != null ) { final Object bitmapData = bitmapWorkerTask . mData ; if ( bitmapData == null || ! bitmapData . equals ( data ) ) { bitmapWorkerTask . cancel ( _BOOL ) ; Log . d ( TAG , STRING + data ) ; } else { return _BOOL ; } } return _BOOL ; }
public static boolean cancelPotentialWork ( Object data , ImageView imageView ) { final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask ( imageView ) ; if ( bitmapWorkerTask != null ) { final Object bitmapData = bitmapWorkerTask . mData ; if ( bitmapData == null || ! bitmapData . equals ( data ) ) { bitmapWorkerTask . cancel ( _BOOL ) ; Log . d ( TAG , STRING + data ) ; } else { return _BOOL ; } } return _BOOL ; }
public InstanceProcess exec ( String workspaceId , String machineId , Command command , @ Nullable String outputChannel ) throws NotFoundException , MachineException , BadRequestException { requiredNotNull ( machineId , STRING ) ; requiredNotNull ( command , STRING ) ; requiredNotNull ( command . getCommandLine ( ) , STRING ) ; requiredNotNull ( command . getName ( ) , STRING ) ; requiredNotNull ( command . getType ( ) , STRING ) ; final Instance machine = environmentEngine . getMachine ( workspaceId , machineId ) ; final InstanceProcess instanceProcess = machine . createProcess ( command , outputChannel ) ; final int pid = instanceProcess . getPid ( ) ; final LineConsumer processLogger = getProcessLogger ( machineId , pid , outputChannel ) ; executor . execute ( ThreadLocalPropagateContext . wrap ( null ) ) ; return instanceProcess ; }
@ RequestMapping ( value = { STRING , STRING } , method = RequestMethod . POST ) @ ResponseBody public RestWrapper update ( @ ModelAttribute ( STRING ) @ Valid AppDeploymentQueueStatus adqStatus , BindingResult bindingResult , Principal principal ) { LOGGER . debug ( STRING ) ; RestWrapper restWrapper = null ; if ( bindingResult . hasErrors ( ) ) { BindingResultError bindingResultError = new BindingResultError ( ) ; return bindingResultError . errorMessage ( bindingResult ) ; } try { com . wipro . ats . bdre . md . dao . jpa . AppDeploymentQueueStatus jpaAdqStatus = new com . wipro . ats . bdre . md . dao . jpa . AppDeploymentQueueStatus ( ) ; jpaAdqStatus . setDescription ( adqStatus . getDescription ( ) ) ; appDeploymentQueueStatusDAO . update ( jpaAdqStatus ) ; LOGGER . debug ( STRING + jpaAdqStatus . getAppDeploymentStatusId ( ) ) ; LOGGER . debug ( STRING ) ; restWrapper = new RestWrapper ( adqStatus , RestWrapper . OK ) ; LOGGER . info ( RECORDWITHID + adqStatus . getAppDeploymentStatusId ( ) + STRING + principal . getName ( ) + adqStatus ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; return new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
@ RequestMapping ( value = { STRING , STRING } , method = RequestMethod . POST ) @ ResponseBody public RestWrapper update ( @ ModelAttribute ( STRING ) @ Valid AppDeploymentQueueStatus adqStatus , BindingResult bindingResult , Principal principal ) { LOGGER . debug ( STRING ) ; RestWrapper restWrapper = null ; if ( bindingResult . hasErrors ( ) ) { BindingResultError bindingResultError = new BindingResultError ( ) ; return bindingResultError . errorMessage ( bindingResult ) ; } try { com . wipro . ats . bdre . md . dao . jpa . AppDeploymentQueueStatus jpaAdqStatus = new com . wipro . ats . bdre . md . dao . jpa . AppDeploymentQueueStatus ( ) ; jpaAdqStatus . setDescription ( adqStatus . getDescription ( ) ) ; appDeploymentQueueStatusDAO . update ( jpaAdqStatus ) ; LOGGER . debug ( STRING + jpaAdqStatus . getAppDeploymentStatusId ( ) ) ; LOGGER . debug ( STRING ) ; restWrapper = new RestWrapper ( adqStatus , RestWrapper . OK ) ; LOGGER . info ( RECORDWITHID + adqStatus . getAppDeploymentStatusId ( ) + STRING + principal . getName ( ) + adqStatus ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; return new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
public void sendUserDeleteNotification ( Map attributes ) { try { if ( deleteNotifyList != null && ! deleteNotifyList . isEmpty ( ) ) { sendEmail ( deleteNotifyList , attributes , STRING , STRING , STRING ) ; } } catch ( MessagingException e ) { if ( debug . warningEnabled ( ) ) { debug . warning ( STRING + STRING + STRING + entryDN , e ) ; } } }
public final void hackGravity ( double rsize , Node root ) { MathVector pos0 = ( MathVector ) pos . clone ( ) ; HG hg = new HG ( this , pos ) ; hg = root . walkSubTree ( rsize * rsize , hg ) ; phi = hg . phi0 ; newAcc = hg . acc0 ; }
public final void hackGravity ( double rsize , Node root ) { MathVector pos0 = ( MathVector ) pos . clone ( ) ; HG hg = new HG ( this , pos ) ; hg = root . walkSubTree ( rsize * rsize , hg ) ; phi = hg . phi0 ; newAcc = hg . acc0 ; }
public final void hackGravity ( double rsize , Node root ) { MathVector pos0 = ( MathVector ) pos . clone ( ) ; HG hg = new HG ( this , pos ) ; hg = root . walkSubTree ( rsize * rsize , hg ) ; phi = hg . phi0 ; newAcc = hg . acc0 ; }
@ Override public void readExternal ( ObjectInput in ) throws IOException { b = new double [ in . readInt ( ) ] ; for ( int p = _NUM ; p < b . length ; p ++ ) { b [ p ] = in . readDouble ( ) ; } }
@ Override public void readExternal ( ObjectInput in ) throws IOException { b = new double [ in . readInt ( ) ] ; for ( int p = _NUM ; p < b . length ; p ++ ) { b [ p ] = in . readDouble ( ) ; } }
@ Override public void readExternal ( ObjectInput in ) throws IOException { b = new double [ in . readInt ( ) ] ; for ( int p = _NUM ; p < b . length ; p ++ ) { b [ p ] = in . readDouble ( ) ; } }
@ Override public void readExternal ( ObjectInput in ) throws IOException { b = new double [ in . readInt ( ) ] ; for ( int p = _NUM ; p < b . length ; p ++ ) { b [ p ] = in . readDouble ( ) ; } }
@ Override public void readExternal ( ObjectInput in ) throws IOException { b = new double [ in . readInt ( ) ] ; for ( int p = _NUM ; p < b . length ; p ++ ) { b [ p ] = in . readDouble ( ) ; } }
@ Override public void readExternal ( ObjectInput in ) throws IOException { b = new double [ in . readInt ( ) ] ; for ( int p = _NUM ; p < b . length ; p ++ ) { b [ p ] = in . readDouble ( ) ; } }
public void randomizeIncomingWeights ( ) { for ( Neuron n : getNeuronList ( ) ) { for ( Synapse s : n . getFanIn ( ) ) { s . setLowerBound ( _NUM ) ; s . setStrength ( s . getUpperBound ( ) * Math . random ( ) ) ; } } }
public void randomizeIncomingWeights ( ) { for ( Neuron n : getNeuronList ( ) ) { for ( Synapse s : n . getFanIn ( ) ) { s . setLowerBound ( _NUM ) ; s . setStrength ( s . getUpperBound ( ) * Math . random ( ) ) ; } } }
private static List < String [ ] > readSentence ( BufferedReader aReader ) throws IOException { List < String [ ] > words = new ArrayList < String [ ] > ( ) ; String line ; while ( ( line = aReader . readLine ( ) ) != null ) { if ( StringUtils . isBlank ( line ) ) { break ; } if ( line . startsWith ( STRING ) ) { continue ; } String [ ] fields = line . split ( STRING ) ; if ( fields . length != _NUM ) { throw new IOException ( STRING ) ; } words . add ( fields ) ; } if ( line == null && words . isEmpty ( ) ) { return null ; } else { return words ; } }
public void writeGpxFile ( String trackName , DBtrackingPoints db , File gpxFile ) throws IOException { String METADATA = STRING + STRING + STRING + STRING + STRING + DF . format ( System . currentTimeMillis ( ) ) + STRING + STRING ; if ( ! gpxFile . exists ( ) ) { gpxFile . createNewFile ( ) ; } FileWriter fw = new FileWriter ( gpxFile ) ; fw . write ( XML_HEADER + STRING ) ; fw . write ( TAG_GPX + STRING ) ; fw . write ( METADATA + STRING ) ; writeTrackPoints ( trackName , fw , db ) ; fw . write ( STRING ) ; fw . close ( ) ; }
private void twoWayMergeInternal ( final ReservoirItemsSketch < T > sketchIn , final boolean isModifiable ) { if ( sketchIn . getN ( ) <= sketchIn . getK ( ) ) { twoWayMergeInternalStandard ( sketchIn ) ; } else if ( gadget_ . getN ( ) < gadget_ . getK ( ) ) { final ReservoirItemsSketch < T > tmpSketch = gadget_ ; gadget_ = ( isModifiable ? sketchIn : sketchIn . copy ( ) ) ; twoWayMergeInternalStandard ( tmpSketch ) ; } else if ( sketchIn . getImplicitSampleWeight ( ) < gadget_ . getN ( ) / ( ( double ) ( gadget_ . getK ( ) - _NUM ) ) ) { twoWayMergeInternalWeighted ( sketchIn ) ; } else { final ReservoirItemsSketch < T > tmpSketch = gadget_ ; gadget_ = ( isModifiable ? sketchIn : sketchIn . copy ( ) ) ; twoWayMergeInternalWeighted ( tmpSketch ) ; } }
private void twoWayMergeInternal ( final ReservoirItemsSketch < T > sketchIn , final boolean isModifiable ) { if ( sketchIn . getN ( ) <= sketchIn . getK ( ) ) { twoWayMergeInternalStandard ( sketchIn ) ; } else if ( gadget_ . getN ( ) < gadget_ . getK ( ) ) { final ReservoirItemsSketch < T > tmpSketch = gadget_ ; gadget_ = ( isModifiable ? sketchIn : sketchIn . copy ( ) ) ; twoWayMergeInternalStandard ( tmpSketch ) ; } else if ( sketchIn . getImplicitSampleWeight ( ) < gadget_ . getN ( ) / ( ( double ) ( gadget_ . getK ( ) - _NUM ) ) ) { twoWayMergeInternalWeighted ( sketchIn ) ; } else { final ReservoirItemsSketch < T > tmpSketch = gadget_ ; gadget_ = ( isModifiable ? sketchIn : sketchIn . copy ( ) ) ; twoWayMergeInternalWeighted ( tmpSketch ) ; } }
public double continueToMargin ( double [ ] origin , double [ ] delta ) { assert ( delta . length == _NUM && origin . length == _NUM ) ; double factor = Double . POSITIVE_INFINITY ; if ( delta [ _NUM ] > _NUM ) { factor = Math . min ( factor , ( maxx - origin [ _NUM ] ) / delta [ _NUM ] ) ; } else if ( delta [ _NUM ] < _NUM ) { factor = Math . min ( factor , ( origin [ _NUM ] - minx ) / - delta [ _NUM ] ) ; } if ( delta [ _NUM ] > _NUM ) { factor = Math . min ( factor , ( maxy - origin [ _NUM ] ) / delta [ _NUM ] ) ; } else if ( delta [ _NUM ] < _NUM ) { factor = Math . min ( factor , ( origin [ _NUM ] - miny ) / - delta [ _NUM ] ) ; } return factor ; }
@ Nullable public static Pair < String , String > splitJarUrl ( @ NotNull String url ) { int pivot = url . indexOf ( JAR_SEPARATOR ) ; if ( pivot < _NUM ) return null ; String resourcePath = url . substring ( pivot + _NUM ) ; String jarPath = url . substring ( _NUM , pivot ) ; if ( StringUtil . startsWithConcatenation ( jarPath , JAR_PROTOCOL , STRING ) ) { jarPath = jarPath . substring ( JAR_PROTOCOL . length ( ) + _NUM ) ; } if ( jarPath . startsWith ( FILE_PROTOCOL ) ) { jarPath = jarPath . substring ( FILE_PROTOCOL . length ( ) ) ; if ( jarPath . startsWith ( SCHEME_SEPARATOR ) ) { jarPath = jarPath . substring ( SCHEME_SEPARATOR . length ( ) ) ; } else if ( StringUtil . startsWithChar ( jarPath , STRING ) ) { jarPath = jarPath . substring ( _NUM ) ; } } return Pair . create ( jarPath , resourcePath ) ; }
@ Nullable public static Pair < String , String > splitJarUrl ( @ NotNull String url ) { int pivot = url . indexOf ( JAR_SEPARATOR ) ; if ( pivot < _NUM ) return null ; String resourcePath = url . substring ( pivot + _NUM ) ; String jarPath = url . substring ( _NUM , pivot ) ; if ( StringUtil . startsWithConcatenation ( jarPath , JAR_PROTOCOL , STRING ) ) { jarPath = jarPath . substring ( JAR_PROTOCOL . length ( ) + _NUM ) ; } if ( jarPath . startsWith ( FILE_PROTOCOL ) ) { jarPath = jarPath . substring ( FILE_PROTOCOL . length ( ) ) ; if ( jarPath . startsWith ( SCHEME_SEPARATOR ) ) { jarPath = jarPath . substring ( SCHEME_SEPARATOR . length ( ) ) ; } else if ( StringUtil . startsWithChar ( jarPath , STRING ) ) { jarPath = jarPath . substring ( _NUM ) ; } } return Pair . create ( jarPath , resourcePath ) ; }
@ Nullable public static Pair < String , String > splitJarUrl ( @ NotNull String url ) { int pivot = url . indexOf ( JAR_SEPARATOR ) ; if ( pivot < _NUM ) return null ; String resourcePath = url . substring ( pivot + _NUM ) ; String jarPath = url . substring ( _NUM , pivot ) ; if ( StringUtil . startsWithConcatenation ( jarPath , JAR_PROTOCOL , STRING ) ) { jarPath = jarPath . substring ( JAR_PROTOCOL . length ( ) + _NUM ) ; } if ( jarPath . startsWith ( FILE_PROTOCOL ) ) { jarPath = jarPath . substring ( FILE_PROTOCOL . length ( ) ) ; if ( jarPath . startsWith ( SCHEME_SEPARATOR ) ) { jarPath = jarPath . substring ( SCHEME_SEPARATOR . length ( ) ) ; } else if ( StringUtil . startsWithChar ( jarPath , STRING ) ) { jarPath = jarPath . substring ( _NUM ) ; } } return Pair . create ( jarPath , resourcePath ) ; }
public static void writeProperties ( Properties props , OutputStream out , boolean includeDefaults ) throws IOException { if ( includeDefaults ) { Properties all = new Properties ( ) ; Enumeration < ? > propNames = props . propertyNames ( ) ; while ( propNames . hasMoreElements ( ) ) { String propName = ( String ) propNames . nextElement ( ) ; String propValue = props . getProperty ( propName ) ; all . put ( propName , propValue ) ; } props = all ; } try { props . store ( out , null ) ; } finally { out . close ( ) ; } }
public synchronized void ensureCapacity ( int minimumCapacity ) { if ( elementData . length < minimumCapacity ) { int next = ( capacityIncrement <= _NUM ? elementData . length : capacityIncrement ) + elementData . length ; grow ( minimumCapacity > next ? minimumCapacity : next ) ; } }
public synchronized void ensureCapacity ( int minimumCapacity ) { if ( elementData . length < minimumCapacity ) { int next = ( capacityIncrement <= _NUM ? elementData . length : capacityIncrement ) + elementData . length ; grow ( minimumCapacity > next ? minimumCapacity : next ) ; } }
public static int compare ( String left , boolean right ) { if ( Decision . isBoolean ( left ) ) return compare ( Caster . toBooleanValue ( left , _BOOL ) , right ) ; if ( Decision . isNumber ( left ) ) return compare ( Caster . toDoubleValue ( left , Double . NaN ) , right ? _NUM : _NUM ) ; if ( left . length ( ) == _NUM ) return - _NUM ; char leftFirst = left . charAt ( _NUM ) ; if ( leftFirst >= STRING && leftFirst <= STRING ) return left . compareToIgnoreCase ( Caster . toString ( right ? _NUM : _NUM ) ) ; return leftFirst - STRING ; }
public static BufferedInputStream newInputStream ( URL url ) throws MalformedURLException , IOException { return new BufferedInputStream ( configuredInputStream ( null , url ) ) ; }
public final TreeSet < AwtreeObject > find_overlap_objects ( ShapeConvex p_shape , int p_layer , NetNosList p_ignore_net_nos ) { TreeSet < AwtreeObject > risul = new TreeSet < AwtreeObject > ( ) ; Collection < AwtreeFindEntry > tree_entries = find_overlap_tree_entries ( p_shape , p_layer , p_ignore_net_nos ) ; for ( AwtreeFindEntry curr_entry : tree_entries ) risul . add ( curr_entry . object ) ; return risul ; }
public SGraphItemProviderAdapterFactory ( ) { supportedTypes . add ( IEditingDomainItemProvider . class ) ; supportedTypes . add ( IStructuredItemContentProvider . class ) ; supportedTypes . add ( ITreeItemContentProvider . class ) ; supportedTypes . add ( IItemLabelProvider . class ) ; supportedTypes . add ( IItemPropertySource . class ) ; }
public SGraphItemProviderAdapterFactory ( ) { supportedTypes . add ( IEditingDomainItemProvider . class ) ; supportedTypes . add ( IStructuredItemContentProvider . class ) ; supportedTypes . add ( ITreeItemContentProvider . class ) ; supportedTypes . add ( IItemLabelProvider . class ) ; supportedTypes . add ( IItemPropertySource . class ) ; }
public char charAt ( int index ) { return internal . charAt ( index ) ; }
@ SuppressWarnings ( STRING ) public < T extends PO > T firstOnly ( ) throws DBException { T po = null ; String sql = buildSQL ( null , _BOOL ) ; PreparedStatement pstmt = null ; ResultSet rs = null ; try { pstmt = DB . prepareStatement ( sql , trxName ) ; rs = createResultSet ( pstmt ) ; if ( rs . next ( ) ) { po = ( T ) table . getPO ( rs , trxName ) ; } if ( rs . next ( ) ) { throw new DBException ( STRING ) ; } } catch ( SQLException e ) { log . log ( Level . SEVERE , sql , e ) ; throw new DBException ( e , sql ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return po ; }
private void addTerm ( String term ) { Integer index = termToIndex . get ( term ) ; if ( index == null ) { synchronized ( this ) { index = termToIndex . get ( term ) ; if ( index == null ) { index = Integer . valueOf ( termIndexCounter . getAndIncrement ( ) ) ; termToIndex . put ( term , index ) ; } } } }
private void addTerm ( String term ) { Integer index = termToIndex . get ( term ) ; if ( index == null ) { synchronized ( this ) { index = termToIndex . get ( term ) ; if ( index == null ) { index = Integer . valueOf ( termIndexCounter . getAndIncrement ( ) ) ; termToIndex . put ( term , index ) ; } } } }
private void addTerm ( String term ) { Integer index = termToIndex . get ( term ) ; if ( index == null ) { synchronized ( this ) { index = termToIndex . get ( term ) ; if ( index == null ) { index = Integer . valueOf ( termIndexCounter . getAndIncrement ( ) ) ; termToIndex . put ( term , index ) ; } } } }
private void addTerm ( String term ) { Integer index = termToIndex . get ( term ) ; if ( index == null ) { synchronized ( this ) { index = termToIndex . get ( term ) ; if ( index == null ) { index = Integer . valueOf ( termIndexCounter . getAndIncrement ( ) ) ; termToIndex . put ( term , index ) ; } } } }
private MimeMessage findMessage ( String key ) { MimeMessage foundMessage ; foundMessage = selectMessage ( key ) ; if ( foundMessage == null ) { mList = null ; loadKeys ( ) ; foundMessage = selectMessage ( key ) ; } return foundMessage ; }
private MimeMessage findMessage ( String key ) { MimeMessage foundMessage ; foundMessage = selectMessage ( key ) ; if ( foundMessage == null ) { mList = null ; loadKeys ( ) ; foundMessage = selectMessage ( key ) ; } return foundMessage ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = enumToVector ( super . listOptions ( ) ) ; result . addElement ( new Option ( STRING + defaultNumClusters ( ) + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + defaultMinInstNum ( ) + STRING + defaultMaxInstNum ( ) + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + defaultMinRadius ( ) + STRING + defaultMaxRadius ( ) + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + defaultDistMult ( ) + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + defaultNumCycles ( ) + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + defaultNoiseRate ( ) + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = enumToVector ( super . listOptions ( ) ) ; result . addElement ( new Option ( STRING + defaultNumClusters ( ) + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + defaultMinInstNum ( ) + STRING + defaultMaxInstNum ( ) + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + defaultMinRadius ( ) + STRING + defaultMaxRadius ( ) + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + defaultDistMult ( ) + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + defaultNumCycles ( ) + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + defaultNoiseRate ( ) + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; return result . elements ( ) ; }
public static synchronized void addResource ( RecoverableResource resource ) throws IllegalStateException { purgeResources ( ) ; if ( resources_ . containsKey ( resource . getName ( ) ) ) throw new IllegalStateException ( STRING + STRING + resource . getName ( ) ) ; resource . setRecoveryService ( recoveryService_ ) ; resources_ . put ( resource . getName ( ) , resource ) ; resourceList_ . add ( resource ) ; }
public static synchronized void addResource ( RecoverableResource resource ) throws IllegalStateException { purgeResources ( ) ; if ( resources_ . containsKey ( resource . getName ( ) ) ) throw new IllegalStateException ( STRING + STRING + resource . getName ( ) ) ; resource . setRecoveryService ( recoveryService_ ) ; resources_ . put ( resource . getName ( ) , resource ) ; resourceList_ . add ( resource ) ; }
public static synchronized void addResource ( RecoverableResource resource ) throws IllegalStateException { purgeResources ( ) ; if ( resources_ . containsKey ( resource . getName ( ) ) ) throw new IllegalStateException ( STRING + STRING + resource . getName ( ) ) ; resource . setRecoveryService ( recoveryService_ ) ; resources_ . put ( resource . getName ( ) , resource ) ; resourceList_ . add ( resource ) ; }
public static synchronized void addResource ( RecoverableResource resource ) throws IllegalStateException { purgeResources ( ) ; if ( resources_ . containsKey ( resource . getName ( ) ) ) throw new IllegalStateException ( STRING + STRING + resource . getName ( ) ) ; resource . setRecoveryService ( recoveryService_ ) ; resources_ . put ( resource . getName ( ) , resource ) ; resourceList_ . add ( resource ) ; }
public static synchronized void addResource ( RecoverableResource resource ) throws IllegalStateException { purgeResources ( ) ; if ( resources_ . containsKey ( resource . getName ( ) ) ) throw new IllegalStateException ( STRING + STRING + resource . getName ( ) ) ; resource . setRecoveryService ( recoveryService_ ) ; resources_ . put ( resource . getName ( ) , resource ) ; resourceList_ . add ( resource ) ; }
public static synchronized void addResource ( RecoverableResource resource ) throws IllegalStateException { purgeResources ( ) ; if ( resources_ . containsKey ( resource . getName ( ) ) ) throw new IllegalStateException ( STRING + STRING + resource . getName ( ) ) ; resource . setRecoveryService ( recoveryService_ ) ; resources_ . put ( resource . getName ( ) , resource ) ; resourceList_ . add ( resource ) ; }
public static synchronized void addResource ( RecoverableResource resource ) throws IllegalStateException { purgeResources ( ) ; if ( resources_ . containsKey ( resource . getName ( ) ) ) throw new IllegalStateException ( STRING + STRING + resource . getName ( ) ) ; resource . setRecoveryService ( recoveryService_ ) ; resources_ . put ( resource . getName ( ) , resource ) ; resourceList_ . add ( resource ) ; }
public static synchronized void addResource ( RecoverableResource resource ) throws IllegalStateException { purgeResources ( ) ; if ( resources_ . containsKey ( resource . getName ( ) ) ) throw new IllegalStateException ( STRING + STRING + resource . getName ( ) ) ; resource . setRecoveryService ( recoveryService_ ) ; resources_ . put ( resource . getName ( ) , resource ) ; resourceList_ . add ( resource ) ; }
private static < T extends AbstractBlockBase < T > > void enqueueSuccessors ( T block , PriorityQueue < T > worklist , BitSet visitedBlocks ) { for ( T successor : block . getSuccessors ( ) ) { if ( ! visitedBlocks . get ( successor . getId ( ) ) ) { visitedBlocks . set ( successor . getId ( ) ) ; worklist . add ( successor ) ; } } }
public static boolean hasPermission ( Security security , GenericValue userLogin , GenericValue orderHeader ) { if ( userLogin == null || orderHeader == null ) return _BOOL ; if ( security . hasEntityPermission ( STRING , STRING , userLogin ) ) { return _BOOL ; } else if ( security . hasEntityPermission ( STRING , STRING , userLogin ) ) { List < GenericValue > orderRoles = null ; try { orderRoles = orderHeader . getRelated ( STRING , UtilMisc . toMap ( STRING , userLogin . getString ( STRING ) ) , null , _BOOL ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , STRING , module ) ; } if ( UtilValidate . isNotEmpty ( orderRoles ) ) { return _BOOL ; } } return _BOOL ; }
public static boolean hasPermission ( Security security , GenericValue userLogin , GenericValue orderHeader ) { if ( userLogin == null || orderHeader == null ) return _BOOL ; if ( security . hasEntityPermission ( STRING , STRING , userLogin ) ) { return _BOOL ; } else if ( security . hasEntityPermission ( STRING , STRING , userLogin ) ) { List < GenericValue > orderRoles = null ; try { orderRoles = orderHeader . getRelated ( STRING , UtilMisc . toMap ( STRING , userLogin . getString ( STRING ) ) , null , _BOOL ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , STRING , module ) ; } if ( UtilValidate . isNotEmpty ( orderRoles ) ) { return _BOOL ; } } return _BOOL ; }
public void updateComponentDataMemberDefaultAccess ( String strAccess ) throws SecurityException , ApplicationException { checkWriteAccess ( ) ; boolean hasAccess = ConfigWebUtil . hasAccess ( config , SecurityManager . TYPE_SETTING ) ; if ( ! hasAccess ) throw new SecurityException ( STRING ) ; Element scope = _getRootElement ( STRING ) ; if ( StringUtil . isEmpty ( strAccess ) ) { scope . setAttribute ( STRING , STRING ) ; } else { scope . setAttribute ( STRING , ComponentUtil . toStringAccess ( ComponentUtil . toIntAccess ( strAccess ) ) ) ; } }
public static final void clear ( final double [ ] v1 ) { Arrays . fill ( v1 , _NUM ) ; }
public static void copyAll ( File root , File dest ) throws IOException { if ( root . isDirectory ( ) ) { for ( File child : root . listFiles ( ) ) { File childDest = new File ( dest , child . getName ( ) ) ; if ( child . isDirectory ( ) ) { if ( ! childDest . exists ( ) && ! mkdirs ( childDest ) ) throw new IOException ( STRING + childDest . getPath ( ) ) ; copyAll ( child , childDest ) ; } else { Files . copy ( child . toPath ( ) , childDest . toPath ( ) , StandardCopyOption . COPY_ATTRIBUTES ) ; } } } else { File childDest = new File ( dest , root . getName ( ) ) ; if ( ! dest . exists ( ) && ! mkdirs ( dest ) ) throw new IOException ( STRING + dest . getPath ( ) ) ; Files . copy ( root . toPath ( ) , childDest . toPath ( ) , StandardCopyOption . COPY_ATTRIBUTES ) ; } }
public static List < String > extractOutcomeLabelsFromPredictions ( File predictionsFile , BidiMap labelsToIntegersMapping ) throws IOException { List < String > result = new ArrayList < > ( ) ; for ( String line : FileUtils . readLines ( predictionsFile ) ) { Integer intLabel = Integer . valueOf ( line ) ; String outcomeLabel = ( String ) labelsToIntegersMapping . getKey ( intLabel ) ; result . add ( outcomeLabel ) ; } return result ; }
public static List < String > extractOutcomeLabelsFromPredictions ( File predictionsFile , BidiMap labelsToIntegersMapping ) throws IOException { List < String > result = new ArrayList < > ( ) ; for ( String line : FileUtils . readLines ( predictionsFile ) ) { Integer intLabel = Integer . valueOf ( line ) ; String outcomeLabel = ( String ) labelsToIntegersMapping . getKey ( intLabel ) ; result . add ( outcomeLabel ) ; } return result ; }
public String toStringTree ( ) { StringBuilder b = new StringBuilder ( ) ; toStringTree ( b , STRING ) ; return b . toString ( ) ; }
public static Object parseUIFile ( String resourceString , String schemaResource , Class < ? > classToParse ) { return parseFile ( UI_RESOURCE_FOLDER , resourceString , schemaResource , classToParse ) ; }
public static void substituteProperties ( Node node , Properties properties ) { Node child ; Node next = node . getFirstChild ( ) ; while ( ( child = next ) != null ) { next = child . getNextSibling ( ) ; if ( child . getNodeType ( ) == Node . TEXT_NODE ) { child . setNodeValue ( PropertiesUtil . substituteProperty ( child . getNodeValue ( ) , properties ) ) ; } else if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { NamedNodeMap attributes = child . getAttributes ( ) ; for ( int i = _NUM ; i < attributes . getLength ( ) ; i ++ ) { Node attribute = attributes . item ( i ) ; attribute . setNodeValue ( PropertiesUtil . substituteProperty ( attribute . getNodeValue ( ) , properties ) ) ; } substituteProperties ( child , properties ) ; } } }
public static void substituteProperties ( Node node , Properties properties ) { Node child ; Node next = node . getFirstChild ( ) ; while ( ( child = next ) != null ) { next = child . getNextSibling ( ) ; if ( child . getNodeType ( ) == Node . TEXT_NODE ) { child . setNodeValue ( PropertiesUtil . substituteProperty ( child . getNodeValue ( ) , properties ) ) ; } else if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { NamedNodeMap attributes = child . getAttributes ( ) ; for ( int i = _NUM ; i < attributes . getLength ( ) ; i ++ ) { Node attribute = attributes . item ( i ) ; attribute . setNodeValue ( PropertiesUtil . substituteProperty ( attribute . getNodeValue ( ) , properties ) ) ; } substituteProperties ( child , properties ) ; } } }
public static void substituteProperties ( Node node , Properties properties ) { Node child ; Node next = node . getFirstChild ( ) ; while ( ( child = next ) != null ) { next = child . getNextSibling ( ) ; if ( child . getNodeType ( ) == Node . TEXT_NODE ) { child . setNodeValue ( PropertiesUtil . substituteProperty ( child . getNodeValue ( ) , properties ) ) ; } else if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { NamedNodeMap attributes = child . getAttributes ( ) ; for ( int i = _NUM ; i < attributes . getLength ( ) ; i ++ ) { Node attribute = attributes . item ( i ) ; attribute . setNodeValue ( PropertiesUtil . substituteProperty ( attribute . getNodeValue ( ) , properties ) ) ; } substituteProperties ( child , properties ) ; } } }
public String backupNow ( String backupFilePrefix ) throws McException , IOException { _logger . debug ( STRING ) ; return Backup . backup ( backupFilePrefix ) ; }
protected void drawYLegend ( ) { float [ ] positions = new float [ mYLegend . length * _NUM ] ; for ( int i = _NUM ; i < positions . length ; i += _NUM ) { positions [ i ] = _NUM ; positions [ i + _NUM ] = mYLegend [ i / _NUM ] ; } transformPointArrayNoTouch ( positions ) ; float [ ] xy ; String yLengend ; float x , y ; for ( int i = _NUM ; i < positions . length ; i += _NUM ) { if ( mYLegend [ i / _NUM ] != null ) { if ( mDrawUnitInLegend ) { yLengend = mFormatYLegend . format ( mYLegend [ i / _NUM ] ) + mUnit ; } else { yLengend = mFormatYLegend . format ( mYLegend [ i / _NUM ] ) ; } xy = measureTextDimension ( mYLegendPaint , yLengend ) ; x = positions [ i ] - xy [ _NUM ] - _NUM ; y = positions [ i + _NUM ] + xy [ _NUM ] / _NUM ; if ( ! mDrawTopYLegendEntry && i >= positions . length - _NUM ) return ; mDrawCanvas . drawText ( yLengend , x , y , mYLegendPaint ) ; } } }
public static boolean checkChrootPath ( String zkHost , boolean create ) throws KeeperException , InterruptedException { if ( ! containsChroot ( zkHost ) ) { return _BOOL ; } log . info ( STRING ) ; String chrootPath = zkHost . substring ( zkHost . indexOf ( STRING ) , zkHost . length ( ) ) ; SolrZkClient tmpClient = new SolrZkClient ( zkHost . substring ( _NUM , zkHost . indexOf ( STRING ) ) , _NUM * _NUM ) ; boolean exists = tmpClient . exists ( chrootPath , _BOOL ) ; if ( ! exists && create ) { tmpClient . makePath ( chrootPath , _BOOL , _BOOL ) ; exists = _BOOL ; } tmpClient . close ( ) ; return exists ; }
public static boolean checkChrootPath ( String zkHost , boolean create ) throws KeeperException , InterruptedException { if ( ! containsChroot ( zkHost ) ) { return _BOOL ; } log . info ( STRING ) ; String chrootPath = zkHost . substring ( zkHost . indexOf ( STRING ) , zkHost . length ( ) ) ; SolrZkClient tmpClient = new SolrZkClient ( zkHost . substring ( _NUM , zkHost . indexOf ( STRING ) ) , _NUM * _NUM ) ; boolean exists = tmpClient . exists ( chrootPath , _BOOL ) ; if ( ! exists && create ) { tmpClient . makePath ( chrootPath , _BOOL , _BOOL ) ; exists = _BOOL ; } tmpClient . close ( ) ; return exists ; }
public static boolean checkChrootPath ( String zkHost , boolean create ) throws KeeperException , InterruptedException { if ( ! containsChroot ( zkHost ) ) { return _BOOL ; } log . info ( STRING ) ; String chrootPath = zkHost . substring ( zkHost . indexOf ( STRING ) , zkHost . length ( ) ) ; SolrZkClient tmpClient = new SolrZkClient ( zkHost . substring ( _NUM , zkHost . indexOf ( STRING ) ) , _NUM * _NUM ) ; boolean exists = tmpClient . exists ( chrootPath , _BOOL ) ; if ( ! exists && create ) { tmpClient . makePath ( chrootPath , _BOOL , _BOOL ) ; exists = _BOOL ; } tmpClient . close ( ) ; return exists ; }
public void generateHeader ( Writer out ) throws java . io . IOException { out . write ( STRING ) ; if ( title != null ) { out . write ( STRING ) ; out . write ( title ) ; out . write ( STRING ) ; } if ( base != null ) { out . write ( STRING + STRING ) ; } out . write ( STRING ) ; }
void lightweightPaint ( Graphics g ) { paint ( g ) ; }
void lightweightPaint ( Graphics g ) { paint ( g ) ; }
void invalidate ( ) { for ( int i = _NUM ; i < mCursors . size ( ) ; i ++ ) { swapCursor ( i , null , null ) ; } }
public static PaginationContext fromContext ( RoutingContext context ) { HttpServerRequest request = context . request ( ) ; String pageStr = request . getParam ( PaginationContext . CURRENT_PAGE_QUERY_PARAM ) ; String perPageStr = request . getParam ( PaginationContext . PER_PAGE_QUERY_PARAM ) ; Integer page = null ; Integer perPage = null ; try { if ( pageStr != null ) { page = Integer . parseInt ( pageStr ) ; } if ( perPageStr != null ) { perPage = Integer . parseInt ( perPageStr ) ; } } catch ( NumberFormatException e ) { DefaultErrorHandler . badRequest ( context , STRING ) ; } if ( perPage != null && perPage > PaginationContext . MAX_PER_PAGE ) { DefaultErrorHandler . badRequest ( context , STRING + PaginationContext . PER_PAGE_QUERY_PARAM + STRING + PaginationContext . MAX_PER_PAGE ) ; } return new PaginationContext ( page , perPage ) ; }
static void redistributeBuckets ( ArrayList < NotificationInfo > highPriorityEvents , ArrayList < NotificationInfo > mediumPriorityEvents , ArrayList < NotificationInfo > lowPriorityEvents , int maxNotifications ) { if ( highPriorityEvents . size ( ) > maxNotifications ) { lowPriorityEvents . addAll ( _NUM , mediumPriorityEvents ) ; List < NotificationInfo > itemsToMoveSublist = highPriorityEvents . subList ( _NUM , highPriorityEvents . size ( ) - maxNotifications ) ; lowPriorityEvents . addAll ( _NUM , itemsToMoveSublist ) ; if ( DEBUG ) { logEventIdsBumped ( mediumPriorityEvents , itemsToMoveSublist ) ; } mediumPriorityEvents . clear ( ) ; itemsToMoveSublist . clear ( ) ; } if ( mediumPriorityEvents . size ( ) + highPriorityEvents . size ( ) > maxNotifications ) { int spaceRemaining = maxNotifications - highPriorityEvents . size ( ) ; List < NotificationInfo > itemsToMoveSublist = mediumPriorityEvents . subList ( spaceRemaining , mediumPriorityEvents . size ( ) ) ; lowPriorityEvents . addAll ( _NUM , itemsToMoveSublist ) ; if ( DEBUG ) { logEventIdsBumped ( itemsToMoveSublist , null ) ; } itemsToMoveSublist . clear ( ) ; } }
protected void finishGridRow ( ) { GridBagConstraints constraints = new GridBagConstraints ( ) ; constraints . gridwidth = GridBagConstraints . REMAINDER ; constraints . weightx = _NUM ; final JLabel icon ; if ( param . isOptional ( ) ) { if ( param . isDefined ( ) && param . tookDefaultValue ( ) && ! ( param instanceof Flag ) ) { icon = new JLabel ( StockIcon . getStockIcon ( StockIcon . DIALOG_INFORMATION ) ) ; icon . setToolTipText ( STRING + param . getDefaultValueAsString ( ) ) ; } else { icon = new JLabel ( ) ; icon . setMinimumSize ( new Dimension ( _NUM , _NUM ) ) ; } } else { if ( ! param . isDefined ( ) ) { icon = new JLabel ( StockIcon . getStockIcon ( StockIcon . DIALOG_ERROR ) ) ; icon . setToolTipText ( STRING ) ; } else { icon = new JLabel ( ) ; icon . setMinimumSize ( new Dimension ( _NUM , _NUM ) ) ; } } parent . add ( icon , constraints ) ; }
protected void finishGridRow ( ) { GridBagConstraints constraints = new GridBagConstraints ( ) ; constraints . gridwidth = GridBagConstraints . REMAINDER ; constraints . weightx = _NUM ; final JLabel icon ; if ( param . isOptional ( ) ) { if ( param . isDefined ( ) && param . tookDefaultValue ( ) && ! ( param instanceof Flag ) ) { icon = new JLabel ( StockIcon . getStockIcon ( StockIcon . DIALOG_INFORMATION ) ) ; icon . setToolTipText ( STRING + param . getDefaultValueAsString ( ) ) ; } else { icon = new JLabel ( ) ; icon . setMinimumSize ( new Dimension ( _NUM , _NUM ) ) ; } } else { if ( ! param . isDefined ( ) ) { icon = new JLabel ( StockIcon . getStockIcon ( StockIcon . DIALOG_ERROR ) ) ; icon . setToolTipText ( STRING ) ; } else { icon = new JLabel ( ) ; icon . setMinimumSize ( new Dimension ( _NUM , _NUM ) ) ; } } parent . add ( icon , constraints ) ; }
protected void finishGridRow ( ) { GridBagConstraints constraints = new GridBagConstraints ( ) ; constraints . gridwidth = GridBagConstraints . REMAINDER ; constraints . weightx = _NUM ; final JLabel icon ; if ( param . isOptional ( ) ) { if ( param . isDefined ( ) && param . tookDefaultValue ( ) && ! ( param instanceof Flag ) ) { icon = new JLabel ( StockIcon . getStockIcon ( StockIcon . DIALOG_INFORMATION ) ) ; icon . setToolTipText ( STRING + param . getDefaultValueAsString ( ) ) ; } else { icon = new JLabel ( ) ; icon . setMinimumSize ( new Dimension ( _NUM , _NUM ) ) ; } } else { if ( ! param . isDefined ( ) ) { icon = new JLabel ( StockIcon . getStockIcon ( StockIcon . DIALOG_ERROR ) ) ; icon . setToolTipText ( STRING ) ; } else { icon = new JLabel ( ) ; icon . setMinimumSize ( new Dimension ( _NUM , _NUM ) ) ; } } parent . add ( icon , constraints ) ; }
public FontHints ( ) { Toolkit tk = Toolkit . getDefaultToolkit ( ) ; desktopHints = ( Map ) ( tk . getDesktopProperty ( STRING ) ) ; }
protected int hash ( Object key1 , Object key2 , Object key3 , Object key4 ) { int h = _NUM ; if ( key1 != null ) { h ^= key1 . hashCode ( ) ; } if ( key2 != null ) { h ^= key2 . hashCode ( ) ; } if ( key3 != null ) { h ^= key3 . hashCode ( ) ; } if ( key4 != null ) { h ^= key4 . hashCode ( ) ; } h += ~ ( h << _NUM ) ; h ^= ( h > > > _NUM ) ; h += ( h << _NUM ) ; h ^= ( h > > > _NUM ) ; return h ; }
private String [ ] splitSpaceDelemitNameValuePair ( String str ) { if ( str == null || str . isEmpty ( ) ) return null ; String str2 = str . trim ( ) ; int idx = str2 . lastIndexOf ( STRING ) ; if ( idx <= _NUM ) return null ; String name = str2 . substring ( _NUM , idx ) ; String val = str2 . substring ( idx + _NUM ) ; if ( name . isEmpty ( ) || val . isEmpty ( ) ) return null ; name = name . trim ( ) ; try { BigDecimal bdecimal = new BigDecimal ( val ) ; if ( bdecimal != null ) { String [ ] res = new String [ _NUM ] ; res [ _NUM ] = name ; res [ _NUM ] = val ; return res ; } } catch ( Exception ex ) { } return null ; }
private String [ ] splitSpaceDelemitNameValuePair ( String str ) { if ( str == null || str . isEmpty ( ) ) return null ; String str2 = str . trim ( ) ; int idx = str2 . lastIndexOf ( STRING ) ; if ( idx <= _NUM ) return null ; String name = str2 . substring ( _NUM , idx ) ; String val = str2 . substring ( idx + _NUM ) ; if ( name . isEmpty ( ) || val . isEmpty ( ) ) return null ; name = name . trim ( ) ; try { BigDecimal bdecimal = new BigDecimal ( val ) ; if ( bdecimal != null ) { String [ ] res = new String [ _NUM ] ; res [ _NUM ] = name ; res [ _NUM ] = val ; return res ; } } catch ( Exception ex ) { } return null ; }
private String [ ] splitSpaceDelemitNameValuePair ( String str ) { if ( str == null || str . isEmpty ( ) ) return null ; String str2 = str . trim ( ) ; int idx = str2 . lastIndexOf ( STRING ) ; if ( idx <= _NUM ) return null ; String name = str2 . substring ( _NUM , idx ) ; String val = str2 . substring ( idx + _NUM ) ; if ( name . isEmpty ( ) || val . isEmpty ( ) ) return null ; name = name . trim ( ) ; try { BigDecimal bdecimal = new BigDecimal ( val ) ; if ( bdecimal != null ) { String [ ] res = new String [ _NUM ] ; res [ _NUM ] = name ; res [ _NUM ] = val ; return res ; } } catch ( Exception ex ) { } return null ; }
private String [ ] splitSpaceDelemitNameValuePair ( String str ) { if ( str == null || str . isEmpty ( ) ) return null ; String str2 = str . trim ( ) ; int idx = str2 . lastIndexOf ( STRING ) ; if ( idx <= _NUM ) return null ; String name = str2 . substring ( _NUM , idx ) ; String val = str2 . substring ( idx + _NUM ) ; if ( name . isEmpty ( ) || val . isEmpty ( ) ) return null ; name = name . trim ( ) ; try { BigDecimal bdecimal = new BigDecimal ( val ) ; if ( bdecimal != null ) { String [ ] res = new String [ _NUM ] ; res [ _NUM ] = name ; res [ _NUM ] = val ; return res ; } } catch ( Exception ex ) { } return null ; }
private void eliminateBackfillStates ( int baseState ) { if ( statesToBackfill . contains ( new Integer ( baseState ) ) ) { statesToBackfill . removeElement ( new Integer ( baseState ) ) ; short [ ] state = tempStateTable . elementAt ( baseState ) ; for ( int i = _NUM ; i < numCategories ; i ++ ) { if ( state [ i ] != _NUM ) { eliminateBackfillStates ( state [ i ] ) ; } } } }
private void eliminateBackfillStates ( int baseState ) { if ( statesToBackfill . contains ( new Integer ( baseState ) ) ) { statesToBackfill . removeElement ( new Integer ( baseState ) ) ; short [ ] state = tempStateTable . elementAt ( baseState ) ; for ( int i = _NUM ; i < numCategories ; i ++ ) { if ( state [ i ] != _NUM ) { eliminateBackfillStates ( state [ i ] ) ; } } } }
private void eliminateBackfillStates ( int baseState ) { if ( statesToBackfill . contains ( new Integer ( baseState ) ) ) { statesToBackfill . removeElement ( new Integer ( baseState ) ) ; short [ ] state = tempStateTable . elementAt ( baseState ) ; for ( int i = _NUM ; i < numCategories ; i ++ ) { if ( state [ i ] != _NUM ) { eliminateBackfillStates ( state [ i ] ) ; } } } }
@ Override public void endOfStream ( ) throws AdeException { if ( m_inPeriod ) { closePeriod ( ) ; } }
@ Override public boolean equals ( Object otherRules ) { if ( this == otherRules ) { return _BOOL ; } if ( otherRules instanceof ZoneRules ) { ZoneRules other = ( ZoneRules ) otherRules ; return Arrays . equals ( standardTransitions , other . standardTransitions ) && Arrays . equals ( standardOffsets , other . standardOffsets ) && Arrays . equals ( savingsInstantTransitions , other . savingsInstantTransitions ) && Arrays . equals ( wallOffsets , other . wallOffsets ) && Arrays . equals ( lastRules , other . lastRules ) ; } return _BOOL ; }
@ Override public boolean equals ( Object otherRules ) { if ( this == otherRules ) { return _BOOL ; } if ( otherRules instanceof ZoneRules ) { ZoneRules other = ( ZoneRules ) otherRules ; return Arrays . equals ( standardTransitions , other . standardTransitions ) && Arrays . equals ( standardOffsets , other . standardOffsets ) && Arrays . equals ( savingsInstantTransitions , other . savingsInstantTransitions ) && Arrays . equals ( wallOffsets , other . wallOffsets ) && Arrays . equals ( lastRules , other . lastRules ) ; } return _BOOL ; }
@ Override public boolean equals ( Object otherRules ) { if ( this == otherRules ) { return _BOOL ; } if ( otherRules instanceof ZoneRules ) { ZoneRules other = ( ZoneRules ) otherRules ; return Arrays . equals ( standardTransitions , other . standardTransitions ) && Arrays . equals ( standardOffsets , other . standardOffsets ) && Arrays . equals ( savingsInstantTransitions , other . savingsInstantTransitions ) && Arrays . equals ( wallOffsets , other . wallOffsets ) && Arrays . equals ( lastRules , other . lastRules ) ; } return _BOOL ; }
protected void beat ( ) { sendUDPString ( getBeatSignal ( ) , this . address , this . port ) ; this . timeOfLastBeat = System . currentTimeMillis ( ) ; }
protected void beat ( ) { sendUDPString ( getBeatSignal ( ) , this . address , this . port ) ; this . timeOfLastBeat = System . currentTimeMillis ( ) ; }
public static String toNTriplesString ( Literal lit , boolean xsdStringToPlainLiteral ) { try { StringBuilder sb = new StringBuilder ( ) ; append ( lit , sb , xsdStringToPlainLiteral ) ; return sb . toString ( ) ; } catch ( IOException e ) { throw new AssertionError ( ) ; } }
public void reset ( ) { mCodes . clear ( ) ; mIsFirstCharCapitalized = _BOOL ; mPreferredWord = null ; mTypedWord . setLength ( _NUM ) ; mCapsCount = _NUM ; }
private List < FileMatch > filterSourceMatchesThatAreTargetMatches ( List < FileMatch > sourceMatchCandidates , List < FileMatch > targetMatchCandidates ) { List < FileMatch > filteredSourceMatchCandidates = new ArrayList < > ( ) ; List < Path > targetPaths = getPaths ( targetMatchCandidates ) ; for ( FileMatch sourceMatchCandidate : sourceMatchCandidates ) { if ( ! targetPaths . contains ( sourceMatchCandidate . getPath ( ) ) ) { filteredSourceMatchCandidates . add ( sourceMatchCandidate ) ; } } return filteredSourceMatchCandidates ; }
private List < FileMatch > filterSourceMatchesThatAreTargetMatches ( List < FileMatch > sourceMatchCandidates , List < FileMatch > targetMatchCandidates ) { List < FileMatch > filteredSourceMatchCandidates = new ArrayList < > ( ) ; List < Path > targetPaths = getPaths ( targetMatchCandidates ) ; for ( FileMatch sourceMatchCandidate : sourceMatchCandidates ) { if ( ! targetPaths . contains ( sourceMatchCandidate . getPath ( ) ) ) { filteredSourceMatchCandidates . add ( sourceMatchCandidate ) ; } } return filteredSourceMatchCandidates ; }
private List < FileMatch > filterSourceMatchesThatAreTargetMatches ( List < FileMatch > sourceMatchCandidates , List < FileMatch > targetMatchCandidates ) { List < FileMatch > filteredSourceMatchCandidates = new ArrayList < > ( ) ; List < Path > targetPaths = getPaths ( targetMatchCandidates ) ; for ( FileMatch sourceMatchCandidate : sourceMatchCandidates ) { if ( ! targetPaths . contains ( sourceMatchCandidate . getPath ( ) ) ) { filteredSourceMatchCandidates . add ( sourceMatchCandidate ) ; } } return filteredSourceMatchCandidates ; }
private List < FileMatch > filterSourceMatchesThatAreTargetMatches ( List < FileMatch > sourceMatchCandidates , List < FileMatch > targetMatchCandidates ) { List < FileMatch > filteredSourceMatchCandidates = new ArrayList < > ( ) ; List < Path > targetPaths = getPaths ( targetMatchCandidates ) ; for ( FileMatch sourceMatchCandidate : sourceMatchCandidates ) { if ( ! targetPaths . contains ( sourceMatchCandidate . getPath ( ) ) ) { filteredSourceMatchCandidates . add ( sourceMatchCandidate ) ; } } return filteredSourceMatchCandidates ; }
private List < FileMatch > filterSourceMatchesThatAreTargetMatches ( List < FileMatch > sourceMatchCandidates , List < FileMatch > targetMatchCandidates ) { List < FileMatch > filteredSourceMatchCandidates = new ArrayList < > ( ) ; List < Path > targetPaths = getPaths ( targetMatchCandidates ) ; for ( FileMatch sourceMatchCandidate : sourceMatchCandidates ) { if ( ! targetPaths . contains ( sourceMatchCandidate . getPath ( ) ) ) { filteredSourceMatchCandidates . add ( sourceMatchCandidate ) ; } } return filteredSourceMatchCandidates ; }
public void addLast ( StatementSequence statements ) { if ( statements != null ) { sequence . addAll ( statements . sequence ) ; } }
public void addLast ( StatementSequence statements ) { if ( statements != null ) { sequence . addAll ( statements . sequence ) ; } }
public void addLast ( StatementSequence statements ) { if ( statements != null ) { sequence . addAll ( statements . sequence ) ; } }
public static FactoryImage createImage ( InputStream is , String mediaType , String name ) throws BadRequestException , ServerException { try { final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; final byte [ ] buffer = new byte [ _NUM ] ; int read ; while ( ( read = is . read ( buffer , _NUM , buffer . length ) ) != - _NUM ) { out . write ( buffer , _NUM , read ) ; if ( out . size ( ) > _NUM * _NUM ) { throw new BadRequestException ( STRING ) ; } } if ( out . size ( ) == _NUM ) { return new FactoryImage ( ) ; } out . flush ( ) ; return new FactoryImage ( out . toByteArray ( ) , mediaType , name ) ; } catch ( IOException ioEx ) { throw new ServerException ( ioEx . getLocalizedMessage ( ) ) ; } }
public static FactoryImage createImage ( InputStream is , String mediaType , String name ) throws BadRequestException , ServerException { try { final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; final byte [ ] buffer = new byte [ _NUM ] ; int read ; while ( ( read = is . read ( buffer , _NUM , buffer . length ) ) != - _NUM ) { out . write ( buffer , _NUM , read ) ; if ( out . size ( ) > _NUM * _NUM ) { throw new BadRequestException ( STRING ) ; } } if ( out . size ( ) == _NUM ) { return new FactoryImage ( ) ; } out . flush ( ) ; return new FactoryImage ( out . toByteArray ( ) , mediaType , name ) ; } catch ( IOException ioEx ) { throw new ServerException ( ioEx . getLocalizedMessage ( ) ) ; } }
public BottomNavigationBar removeItem ( BottomNavigationItem item ) { mBottomNavigationItems . remove ( item ) ; return this ; }
public BottomNavigationBar removeItem ( BottomNavigationItem item ) { mBottomNavigationItems . remove ( item ) ; return this ; }
public BottomNavigationBar removeItem ( BottomNavigationItem item ) { mBottomNavigationItems . remove ( item ) ; return this ; }
public BottomNavigationBar removeItem ( BottomNavigationItem item ) { mBottomNavigationItems . remove ( item ) ; return this ; }
public String primaryOccupationName ( ) { String primaryOccupation = null ; if ( professionalExperience != null && professionalExperience . primaryCompany ( ) != null ) { Company company = professionalExperience . primaryCompany ( ) ; primaryOccupation = company . title ( ) ; } if ( primaryOccupation == null || primaryOccupation . isEmpty ( ) ) { if ( educationBackground != null && educationBackground . primarySchool ( ) != null ) { School primarySchool = educationBackground . primarySchool ( ) ; primaryOccupation = primarySchool . degree ( ) ; } } return primaryOccupation ; }
private Element createKeyValue ( ) throws Exception { Element keyValueEle = null ; PrivateKey key = idmClient . getTenantPrivateKey ( tenantName ) ; if ( key != null ) { RSAPrivateKey rsaKey = ( RSAPrivateKey ) key ; Element rsaKeyEle = createRSAKeyValue ( rsaKey ) ; if ( rsaKeyEle != null ) { keyValueEle = doc . createElement ( SAMLNames . DS_KEYVALUE ) ; keyValueEle . appendChild ( rsaKeyEle ) ; } } return keyValueEle ; }
private Element createKeyValue ( ) throws Exception { Element keyValueEle = null ; PrivateKey key = idmClient . getTenantPrivateKey ( tenantName ) ; if ( key != null ) { RSAPrivateKey rsaKey = ( RSAPrivateKey ) key ; Element rsaKeyEle = createRSAKeyValue ( rsaKey ) ; if ( rsaKeyEle != null ) { keyValueEle = doc . createElement ( SAMLNames . DS_KEYVALUE ) ; keyValueEle . appendChild ( rsaKeyEle ) ; } } return keyValueEle ; }
private IJavaElement findSourceFolderElement ( IFolder moduleFolder ) { IFolder folderSourcePackage = findSourcePackage ( moduleFolder , STRING ) ; if ( folderSourcePackage == null ) { return null ; } IJavaProject javaProject = JavaCore . create ( folderSourcePackage . getProject ( ) ) ; if ( javaProject == null ) { return null ; } try { IPackageFragment clientPackage = javaProject . findPackageFragment ( folderSourcePackage . getFullPath ( ) ) ; return clientPackage ; } catch ( JavaModelException e ) { e . printStackTrace ( ) ; } return null ; }
private IJavaElement findSourceFolderElement ( IFolder moduleFolder ) { IFolder folderSourcePackage = findSourcePackage ( moduleFolder , STRING ) ; if ( folderSourcePackage == null ) { return null ; } IJavaProject javaProject = JavaCore . create ( folderSourcePackage . getProject ( ) ) ; if ( javaProject == null ) { return null ; } try { IPackageFragment clientPackage = javaProject . findPackageFragment ( folderSourcePackage . getFullPath ( ) ) ; return clientPackage ; } catch ( JavaModelException e ) { e . printStackTrace ( ) ; } return null ; }
void crossOver ( BayesNetRepresentation other ) { boolean [ ] bits = new boolean [ m_bits . length ] ; for ( int i = _NUM ; i < m_bits . length ; i ++ ) { bits [ i ] = m_bits [ i ] ; } int iCrossOverPoint = m_bits . length ; do { for ( int i = iCrossOverPoint ; i < m_bits . length ; i ++ ) { m_bits [ i ] = bits [ i ] ; } iCrossOverPoint = m_random . nextInt ( m_bits . length ) ; for ( int i = iCrossOverPoint ; i < m_bits . length ; i ++ ) { m_bits [ i ] = other . m_bits [ i ] ; } } while ( hasCycles ( ) ) ; calcGlobalScore ( ) ; }
void clear ( ) ;
void clear ( ) ;
void clear ( ) ;
public static void registerDefaultPrefixes ( ) throws XMLSecurityException { setDefaultPrefix ( STRING , STRING ) ; setDefaultPrefix ( STRING , STRING ) ; setDefaultPrefix ( STRING , STRING ) ; setDefaultPrefix ( STRING , STRING ) ; setDefaultPrefix ( STRING , STRING ) ; setDefaultPrefix ( STRING , STRING ) ; setDefaultPrefix ( STRING , STRING ) ; setDefaultPrefix ( STRING , STRING ) ; }
public static String derivePath ( String baseDir , String fileName ) { Logger logger = Logger . getLogger ( COMPONENT ) ; if ( logger . isLoggable ( Level . FINE ) ) logger . log ( Level . FINE , STRING + fileName + STRING + baseDir ) ; if ( baseDir == null ) throw new NullPointerException ( STRING ) ; if ( fileName == null ) throw new NullPointerException ( STRING ) ; if ( baseDir . startsWith ( STRING ) ) { String sysProp = baseDir . substring ( _NUM ) ; baseDir = System . getProperty ( sysProp ) ; if ( baseDir == null ) throw new IllegalArgumentException ( STRING + sysProp + STRING + STRING + STRING ) ; } File base = new File ( baseDir ) ; if ( ! base . exists ( ) ) throw new IllegalArgumentException ( baseDir + STRING ) ; if ( ! base . isDirectory ( ) ) throw new IllegalArgumentException ( baseDir + STRING ) ; if ( ! base . canRead ( ) ) throw new IllegalArgumentException ( STRING + baseDir ) ; String path = locate ( base , fileName ) ; if ( path != null ) { File checkDir = new File ( path ) ; if ( checkDir . isDirectory ( ) ) path = checkDirFormat ( path ) ; } return ( path ) ; }
void removeAt ( final int removeIndex ) { final Object [ ] items = this . items ; if ( removeIndex == takeIndex ) { items [ takeIndex ] = null ; if ( ++ takeIndex == items . length ) takeIndex = _NUM ; count -- ; if ( itrs != null ) itrs . elementDequeued ( ) ; } else { final int putIndex = this . putIndex ; for ( int i = removeIndex ; ; ) { int next = i + _NUM ; if ( next == items . length ) next = _NUM ; if ( next != putIndex ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . putIndex = i ; break ; } } count -- ; if ( itrs != null ) itrs . removedAt ( removeIndex ) ; } notFull . signal ( ) ; }
void removeAt ( final int removeIndex ) { final Object [ ] items = this . items ; if ( removeIndex == takeIndex ) { items [ takeIndex ] = null ; if ( ++ takeIndex == items . length ) takeIndex = _NUM ; count -- ; if ( itrs != null ) itrs . elementDequeued ( ) ; } else { final int putIndex = this . putIndex ; for ( int i = removeIndex ; ; ) { int next = i + _NUM ; if ( next == items . length ) next = _NUM ; if ( next != putIndex ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . putIndex = i ; break ; } } count -- ; if ( itrs != null ) itrs . removedAt ( removeIndex ) ; } notFull . signal ( ) ; }
void removeAt ( final int removeIndex ) { final Object [ ] items = this . items ; if ( removeIndex == takeIndex ) { items [ takeIndex ] = null ; if ( ++ takeIndex == items . length ) takeIndex = _NUM ; count -- ; if ( itrs != null ) itrs . elementDequeued ( ) ; } else { final int putIndex = this . putIndex ; for ( int i = removeIndex ; ; ) { int next = i + _NUM ; if ( next == items . length ) next = _NUM ; if ( next != putIndex ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . putIndex = i ; break ; } } count -- ; if ( itrs != null ) itrs . removedAt ( removeIndex ) ; } notFull . signal ( ) ; }
public static float [ ] join ( float [ ] arrayA , float ... arrayB ) { if ( ( arrayB == null ) || ( arrayB . length == _NUM ) ) { return arrayA ; } if ( ( arrayA == null ) || ( arrayA . length == _NUM ) ) { return arrayB ; } float [ ] array = new float [ arrayA . length + arrayB . length ] ; System . arraycopy ( arrayA , _NUM , array , _NUM , arrayA . length ) ; System . arraycopy ( arrayB , _NUM , array , arrayA . length , arrayB . length ) ; return array ; }
public static float [ ] join ( float [ ] arrayA , float ... arrayB ) { if ( ( arrayB == null ) || ( arrayB . length == _NUM ) ) { return arrayA ; } if ( ( arrayA == null ) || ( arrayA . length == _NUM ) ) { return arrayB ; } float [ ] array = new float [ arrayA . length + arrayB . length ] ; System . arraycopy ( arrayA , _NUM , array , _NUM , arrayA . length ) ; System . arraycopy ( arrayB , _NUM , array , arrayA . length , arrayB . length ) ; return array ; }
DateTimeParseContext ( DateTimeFormatter formatter ) { super ( ) ; this . formatter = formatter ; parsed . add ( new Parsed ( ) ) ; }
public static void randShuffleK ( ArrayList < Integer > inds , int k , Random rand ) { for ( int i = _NUM ; i < k ; i ++ ) { Collections . swap ( inds , i , rand . nextInt ( inds . size ( ) ) ) ; } }
public static void randShuffleK ( ArrayList < Integer > inds , int k , Random rand ) { for ( int i = _NUM ; i < k ; i ++ ) { Collections . swap ( inds , i , rand . nextInt ( inds . size ( ) ) ) ; } }
public static void randShuffleK ( ArrayList < Integer > inds , int k , Random rand ) { for ( int i = _NUM ; i < k ; i ++ ) { Collections . swap ( inds , i , rand . nextInt ( inds . size ( ) ) ) ; } }
public String toString ( ) { return String . format ( STRING , this . numberOfElements , this . sizeOfElement ) ; }
public String toString ( ) { return String . format ( STRING , this . numberOfElements , this . sizeOfElement ) ; }
public boolean remove ( SimEvent event ) { return sortedSet . remove ( event ) ; }
@ Override public void handleClick ( int x , int y , PlotRenderingInfo info ) { Rectangle2D dataArea = info . getDataArea ( ) ; if ( dataArea . contains ( x , y ) ) { ValueAxis xaxis = getDomainAxis ( ) ; if ( xaxis != null ) { double hvalue = xaxis . java2DToValue ( x , info . getDataArea ( ) , getDomainAxisEdge ( ) ) ; setDomainCrosshairValue ( hvalue ) ; } ValueAxis yaxis = getRangeAxis ( ) ; if ( yaxis != null ) { double vvalue = yaxis . java2DToValue ( y , info . getDataArea ( ) , getRangeAxisEdge ( ) ) ; setRangeCrosshairValue ( vvalue ) ; } } }
@ Override public void handleClick ( int x , int y , PlotRenderingInfo info ) { Rectangle2D dataArea = info . getDataArea ( ) ; if ( dataArea . contains ( x , y ) ) { ValueAxis xaxis = getDomainAxis ( ) ; if ( xaxis != null ) { double hvalue = xaxis . java2DToValue ( x , info . getDataArea ( ) , getDomainAxisEdge ( ) ) ; setDomainCrosshairValue ( hvalue ) ; } ValueAxis yaxis = getRangeAxis ( ) ; if ( yaxis != null ) { double vvalue = yaxis . java2DToValue ( y , info . getDataArea ( ) , getRangeAxisEdge ( ) ) ; setRangeCrosshairValue ( vvalue ) ; } } }
public float angle ( Vector other ) { double dot = dot ( other ) / ( length ( ) * other . length ( ) ) ; return ( float ) Math . acos ( dot ) ; }
public static boolean shouldRun ( String entry ) { return Cron . shouldRun ( entry , new Date ( ) ) ; }
public final boolean hasMedia ( ) { return mediaComponents != null && mediaComponents . size ( ) > _NUM ; }
public final boolean hasMedia ( ) { return mediaComponents != null && mediaComponents . size ( ) > _NUM ; }
public final boolean hasMedia ( ) { return mediaComponents != null && mediaComponents . size ( ) > _NUM ; }
public void start ( boolean show ) { if ( show ) { setVisible ( _BOOL ) ; } timer . start ( ) ; }
public void start ( boolean show ) { if ( show ) { setVisible ( _BOOL ) ; } timer . start ( ) ; }
public void start ( boolean show ) { if ( show ) { setVisible ( _BOOL ) ; } timer . start ( ) ; }
public void addRoot ( ProtoElement root ) { roots . add ( root ) ; }
public void addRoot ( ProtoElement root ) { roots . add ( root ) ; }
public void addRoot ( ProtoElement root ) { roots . add ( root ) ; }
public void addRoot ( ProtoElement root ) { roots . add ( root ) ; }
public boolean canGetInt ( ) { return canGet ( int . class ) ; }
@ SuppressLint ( STRING ) @ Nullable public static Drawable inflate ( boolean forceSystemHandlingWhenPossible , @ NonNull Resources resources , @ DrawableRes int id ) { boolean systemHandling = isSystemHandling ( forceSystemHandlingWhenPossible ) ; Log . d ( LOG_TAG , String . format ( STRING , Integer . toHexString ( id ) , systemHandling ) ) ; if ( systemHandling ) { return resources . getDrawable ( id , null ) ; } try { return VectorDrawable . create ( resources , id ) ; } catch ( Resources . NotFoundException e ) { return null ; } }
private void _serializeList ( PageContext pc , Set test , List list , StringBuilder sb , boolean serializeQueryByColumns , Set < Object > done ) throws ConverterException { sb . append ( goIn ( ) ) ; sb . append ( STRING ) ; boolean doIt = _BOOL ; ListIterator it = list . listIterator ( ) ; while ( it . hasNext ( ) ) { if ( doIt ) sb . append ( STRING ) ; doIt = _BOOL ; _serialize ( pc , test , it . next ( ) , sb , serializeQueryByColumns , done ) ; } sb . append ( STRING ) ; }
private void addReachable ( Node startNode , Subgraph subgraph ) { Stack nodeStack = new Stack ( ) ; nodeStack . add ( startNode ) ; while ( ! nodeStack . empty ( ) ) { Node node = ( Node ) nodeStack . pop ( ) ; addEdges ( node , nodeStack , subgraph ) ; } }
private void addReachable ( Node startNode , Subgraph subgraph ) { Stack nodeStack = new Stack ( ) ; nodeStack . add ( startNode ) ; while ( ! nodeStack . empty ( ) ) { Node node = ( Node ) nodeStack . pop ( ) ; addEdges ( node , nodeStack , subgraph ) ; } }
private void addReachable ( Node startNode , Subgraph subgraph ) { Stack nodeStack = new Stack ( ) ; nodeStack . add ( startNode ) ; while ( ! nodeStack . empty ( ) ) { Node node = ( Node ) nodeStack . pop ( ) ; addEdges ( node , nodeStack , subgraph ) ; } }
public String hash ( String key ) { try { MessageDigest md = MessageDigest . getInstance ( algorithm ) ; byte [ ] keyBytes = key . getBytes ( STRING ) ; md . update ( keyBytes , _NUM , keyBytes . length ) ; byte [ ] binaryhash = md . digest ( ) ; return Base64 . encode ( binaryhash ) ; } catch ( Exception e ) { LOG . warn ( STRING , key , e ) ; return key ; } }
public static void document ( ClassDoc c , PrintWriter pw ) throws IOException { pw . println ( c . qualifiedName ( ) ) ; { String comment = c . commentText ( ) ; if ( comment != null && ! comment . equals ( STRING ) ) { pw . println ( STRING ) ; indent ( comment , _NUM , pw ) ; pw . println ( STRING ) ; } } MethodDoc [ ] methods = getTestMethods ( c ) ; for ( int i = _NUM ; i < methods . length ; i ++ ) { MethodDoc method = methods [ i ] ; pw . print ( STRING ) ; pw . println ( method . name ( ) ) ; String comment = method . commentText ( ) ; if ( comment != null && ! comment . equals ( STRING ) ) { pw . println ( STRING ) ; indent ( comment , _NUM , pw ) ; pw . println ( STRING ) ; } } pw . println ( STRING ) ; }
protected final StringBuilder write ( StringBuilder sb , final Object ... objects ) { for ( Object string : objects ) sb . append ( string ) ; return sb ; }
public void push ( Namespace namespace ) { namespaceStack . add ( namespace ) ; namespaceCacheList . add ( null ) ; currentNamespaceCache = null ; String prefix = namespace . getPrefix ( ) ; if ( ( prefix == null ) || ( prefix . length ( ) == _NUM ) ) { defaultNamespace = namespace ; } }
private void appendManagedObjectPathElement ( RelationDefinition < ? , ? > r ) { DN dn = DN . valueOf ( profile . getRelationRDNSequence ( r ) ) ; List < RDN > rdnsOfDn = getRdnsInBigEndianOrder ( dn ) ; rdns . addAll ( rdnsOfDn ) ; }
private void appendManagedObjectPathElement ( RelationDefinition < ? , ? > r ) { DN dn = DN . valueOf ( profile . getRelationRDNSequence ( r ) ) ; List < RDN > rdnsOfDn = getRdnsInBigEndianOrder ( dn ) ; rdns . addAll ( rdnsOfDn ) ; }
private void appendManagedObjectPathElement ( RelationDefinition < ? , ? > r ) { DN dn = DN . valueOf ( profile . getRelationRDNSequence ( r ) ) ; List < RDN > rdnsOfDn = getRdnsInBigEndianOrder ( dn ) ; rdns . addAll ( rdnsOfDn ) ; }
private static void findOuterShells ( List shellList ) { for ( Iterator i = shellList . iterator ( ) ; i . hasNext ( ) ; ) { EdgeRing er = ( EdgeRing ) i . next ( ) ; EdgeRing outerHoleER = er . getOuterHole ( ) ; if ( outerHoleER != null && ! outerHoleER . isProcessed ( ) ) { er . setIncluded ( _BOOL ) ; outerHoleER . setProcessed ( _BOOL ) ; } } }
private static void findOuterShells ( List shellList ) { for ( Iterator i = shellList . iterator ( ) ; i . hasNext ( ) ; ) { EdgeRing er = ( EdgeRing ) i . next ( ) ; EdgeRing outerHoleER = er . getOuterHole ( ) ; if ( outerHoleER != null && ! outerHoleER . isProcessed ( ) ) { er . setIncluded ( _BOOL ) ; outerHoleER . setProcessed ( _BOOL ) ; } } }
NetClass append ( BrdLayerStructure p_layer_structure , ClearanceMatrix p_clearance_matrix , IteraBoard itera_board ) { GuiResources resources = itera_board . newGuiResources ( STRING ) ; String name_front = resources . getString ( STRING ) ; String new_name = null ; Integer index = _NUM ; for ( ; ; ) { ++ index ; new_name = name_front + index . toString ( ) ; if ( get ( new_name ) == null ) break ; } return append ( new_name , p_layer_structure , p_clearance_matrix ) ; }
NetClass append ( BrdLayerStructure p_layer_structure , ClearanceMatrix p_clearance_matrix , IteraBoard itera_board ) { GuiResources resources = itera_board . newGuiResources ( STRING ) ; String name_front = resources . getString ( STRING ) ; String new_name = null ; Integer index = _NUM ; for ( ; ; ) { ++ index ; new_name = name_front + index . toString ( ) ; if ( get ( new_name ) == null ) break ; } return append ( new_name , p_layer_structure , p_clearance_matrix ) ; }
public void start ( ) { runningThread = new Thread ( this ) ; runningThread . setName ( STRING ) ; runningThread . start ( ) ; }
public int write ( Connection conn , String outputFileName , String sql , String charset ) throws SQLException { Statement stat = conn . createStatement ( ) ; ResultSet rs = stat . executeQuery ( sql ) ; int rows = write ( outputFileName , rs , charset ) ; stat . close ( ) ; return rows ; }
public VersionNamingConfiguration ( String searchVersionRegex , String replaceVersionRegex , BranchingPolicy ... policies ) { this . branchPolicies = new LinkedList < > ( Arrays . asList ( policies ) ) ; this . searchPattern = Pattern . compile ( searchVersionRegex ) ; this . replaceVersionRegex = replaceVersionRegex ; }
public boolean compile ( String [ ] args ) { long startTime = System . currentTimeMillis ( ) ; long batchID ; synchronized ( batchCountLock ) { batchID = batchCount ++ ; } Batch batch = parseArgs ( args ) ; if ( batch == null ) { return _BOOL ; } boolean status ; try { batchTable . put ( batchID , batch ) ; status = invokeJavadoc ( batch , batchID ) ; } finally { batchTable . remove ( batchID ) ; } if ( batch . verbose ) { long deltaTime = System . currentTimeMillis ( ) - startTime ; output ( Resources . getText ( STRING , Long . toString ( deltaTime ) ) ) ; } return status ; }
public MetricInstance withMaker ( MetricMaker maker ) { return new MetricInstance ( metricName , maker , dependencyMetricNames . toArray ( new String [ dependencyMetricNames . size ( ) ] ) ) ; }
private void validateAndLoadDefaultProperties ( ) { if ( null == carbonProperties . getProperty ( CarbonCommonConstants . STORE_LOCATION ) ) { carbonProperties . setProperty ( CarbonCommonConstants . STORE_LOCATION , CarbonCommonConstants . STORE_LOCATION_DEFAULT_VAL ) ; } validateBlockletSize ( ) ; validateMaxFileSize ( ) ; validateNumCores ( ) ; validateNumCoresBlockSort ( ) ; validateSortSize ( ) ; validateBadRecordsLocation ( ) ; validateHighCardinalityIdentify ( ) ; validateHighCardinalityThreshold ( ) ; validateHighCardinalityInRowCountPercentage ( ) ; }
private void validateAndLoadDefaultProperties ( ) { if ( null == carbonProperties . getProperty ( CarbonCommonConstants . STORE_LOCATION ) ) { carbonProperties . setProperty ( CarbonCommonConstants . STORE_LOCATION , CarbonCommonConstants . STORE_LOCATION_DEFAULT_VAL ) ; } validateBlockletSize ( ) ; validateMaxFileSize ( ) ; validateNumCores ( ) ; validateNumCoresBlockSort ( ) ; validateSortSize ( ) ; validateBadRecordsLocation ( ) ; validateHighCardinalityIdentify ( ) ; validateHighCardinalityThreshold ( ) ; validateHighCardinalityInRowCountPercentage ( ) ; }
private void validateAndLoadDefaultProperties ( ) { if ( null == carbonProperties . getProperty ( CarbonCommonConstants . STORE_LOCATION ) ) { carbonProperties . setProperty ( CarbonCommonConstants . STORE_LOCATION , CarbonCommonConstants . STORE_LOCATION_DEFAULT_VAL ) ; } validateBlockletSize ( ) ; validateMaxFileSize ( ) ; validateNumCores ( ) ; validateNumCoresBlockSort ( ) ; validateSortSize ( ) ; validateBadRecordsLocation ( ) ; validateHighCardinalityIdentify ( ) ; validateHighCardinalityThreshold ( ) ; validateHighCardinalityInRowCountPercentage ( ) ; }
@ Override public void check ( Certificate cert , Collection < String > unresCritExts ) throws CertPathValidatorException { X509Certificate currCert = ( X509Certificate ) cert ; i ++ ; checkBasicConstraints ( currCert ) ; verifyNameConstraints ( currCert ) ; if ( unresCritExts != null && ! unresCritExts . isEmpty ( ) ) { unresCritExts . remove ( BasicConstraints_Id . toString ( ) ) ; unresCritExts . remove ( NameConstraints_Id . toString ( ) ) ; } }
@ Override public void check ( Certificate cert , Collection < String > unresCritExts ) throws CertPathValidatorException { X509Certificate currCert = ( X509Certificate ) cert ; i ++ ; checkBasicConstraints ( currCert ) ; verifyNameConstraints ( currCert ) ; if ( unresCritExts != null && ! unresCritExts . isEmpty ( ) ) { unresCritExts . remove ( BasicConstraints_Id . toString ( ) ) ; unresCritExts . remove ( NameConstraints_Id . toString ( ) ) ; } }
@ Override public void check ( Certificate cert , Collection < String > unresCritExts ) throws CertPathValidatorException { X509Certificate currCert = ( X509Certificate ) cert ; i ++ ; checkBasicConstraints ( currCert ) ; verifyNameConstraints ( currCert ) ; if ( unresCritExts != null && ! unresCritExts . isEmpty ( ) ) { unresCritExts . remove ( BasicConstraints_Id . toString ( ) ) ; unresCritExts . remove ( NameConstraints_Id . toString ( ) ) ; } }
synchronized void attach ( Closeable c ) { if ( parent == null ) { parent = c ; } else if ( otherParents == null ) { otherParents = new ArrayList < > ( ) ; otherParents . add ( parent ) ; otherParents . add ( c ) ; } else { otherParents . add ( c ) ; } }
synchronized void attach ( Closeable c ) { if ( parent == null ) { parent = c ; } else if ( otherParents == null ) { otherParents = new ArrayList < > ( ) ; otherParents . add ( parent ) ; otherParents . add ( c ) ; } else { otherParents . add ( c ) ; } }
synchronized void attach ( Closeable c ) { if ( parent == null ) { parent = c ; } else if ( otherParents == null ) { otherParents = new ArrayList < > ( ) ; otherParents . add ( parent ) ; otherParents . add ( c ) ; } else { otherParents . add ( c ) ; } }
synchronized void attach ( Closeable c ) { if ( parent == null ) { parent = c ; } else if ( otherParents == null ) { otherParents = new ArrayList < > ( ) ; otherParents . add ( parent ) ; otherParents . add ( c ) ; } else { otherParents . add ( c ) ; } }
public static void registerContextMenuAction ( Class < ? > associatedClass , SelectionDependentAction action ) { List < SelectionDependentAction > actions = contextMenuActions . get ( associatedClass ) ; if ( actions == null ) { actions = new LinkedList < SelectionDependentAction > ( ) ; contextMenuActions . put ( associatedClass , actions ) ; } actions . add ( action ) ; }
public static void registerContextMenuAction ( Class < ? > associatedClass , SelectionDependentAction action ) { List < SelectionDependentAction > actions = contextMenuActions . get ( associatedClass ) ; if ( actions == null ) { actions = new LinkedList < SelectionDependentAction > ( ) ; contextMenuActions . put ( associatedClass , actions ) ; } actions . add ( action ) ; }
public static void registerContextMenuAction ( Class < ? > associatedClass , SelectionDependentAction action ) { List < SelectionDependentAction > actions = contextMenuActions . get ( associatedClass ) ; if ( actions == null ) { actions = new LinkedList < SelectionDependentAction > ( ) ; contextMenuActions . put ( associatedClass , actions ) ; } actions . add ( action ) ; }
public static void registerContextMenuAction ( Class < ? > associatedClass , SelectionDependentAction action ) { List < SelectionDependentAction > actions = contextMenuActions . get ( associatedClass ) ; if ( actions == null ) { actions = new LinkedList < SelectionDependentAction > ( ) ; contextMenuActions . put ( associatedClass , actions ) ; } actions . add ( action ) ; }
DangerIndicator ( int maxSkulls ) { setLayout ( new SBoxLayout ( SBoxLayout . HORIZONTAL ) ) ; indicators = new JComponent [ maxSkulls ] ; for ( int i = _NUM ; i < maxSkulls ; i ++ ) { JLabel indicator = new JLabel ( skullIcon ) ; indicator . setVisible ( _BOOL ) ; add ( indicator ) ; indicators [ i ] = indicator ; } }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
public void preferProportionalFonts ( ) { FontManager fm = FontManagerFactory . getInstance ( ) ; fm . preferProportionalFonts ( ) ; }
private void cmd_deleteSelection ( ) { m_frame . setCursor ( Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ) ; if ( ADialog . ask ( getWindowNo ( ) , m_frame , STRING ) ) { int records = deleteSelection ( ) ; setStatusLine ( Msg . getMsg ( Env . getCtx ( ) , STRING ) + records , _BOOL ) ; } m_frame . setCursor ( Cursor . getDefaultCursor ( ) ) ; bDelete . setSelected ( _BOOL ) ; executeQuery ( ) ; ; }
static String toS ( float [ ] a ) { String s = STRING ; if ( a == null ) { return STRING ; } for ( int i = _NUM ; i < a . length ; i ++ ) { if ( i != _NUM ) { s += STRING ; } String t = df . format ( a [ i ] ) + STRING ; s += t . substring ( _NUM , _NUM ) ; } s += STRING ; return s ; }
public MonthDateFormat ( TimeZone zone , int chars ) { this ( zone , Locale . getDefault ( ) , chars , _BOOL , _BOOL ) ; }
public static Resource createResource ( Resource res , short level , short type ) { boolean asDir = type == TYPE_DIR ; if ( level >= LEVEL_FILE && res . exists ( ) && ( ( res . isDirectory ( ) && asDir ) || ( res . isFile ( ) && ! asDir ) ) ) { return getCanonicalResourceEL ( res ) ; } Resource parent = res . getParentResource ( ) ; if ( level >= LEVEL_PARENT_FILE && parent != null && parent . exists ( ) && canRW ( parent ) ) { if ( asDir ) { if ( res . mkdirs ( ) ) return getCanonicalResourceEL ( res ) ; } else { if ( createNewResourceEL ( res ) ) return getCanonicalResourceEL ( res ) ; } return getCanonicalResourceEL ( res ) ; } if ( level >= LEVEL_GRAND_PARENT_FILE && parent != null ) { Resource gparent = parent . getParentResource ( ) ; if ( gparent != null && gparent . exists ( ) && canRW ( gparent ) ) { if ( asDir ) { if ( res . mkdirs ( ) ) return getCanonicalResourceEL ( res ) ; } else { if ( parent . mkdirs ( ) && createNewResourceEL ( res ) ) return getCanonicalResourceEL ( res ) ; } } } return null ; }
public static Resource createResource ( Resource res , short level , short type ) { boolean asDir = type == TYPE_DIR ; if ( level >= LEVEL_FILE && res . exists ( ) && ( ( res . isDirectory ( ) && asDir ) || ( res . isFile ( ) && ! asDir ) ) ) { return getCanonicalResourceEL ( res ) ; } Resource parent = res . getParentResource ( ) ; if ( level >= LEVEL_PARENT_FILE && parent != null && parent . exists ( ) && canRW ( parent ) ) { if ( asDir ) { if ( res . mkdirs ( ) ) return getCanonicalResourceEL ( res ) ; } else { if ( createNewResourceEL ( res ) ) return getCanonicalResourceEL ( res ) ; } return getCanonicalResourceEL ( res ) ; } if ( level >= LEVEL_GRAND_PARENT_FILE && parent != null ) { Resource gparent = parent . getParentResource ( ) ; if ( gparent != null && gparent . exists ( ) && canRW ( gparent ) ) { if ( asDir ) { if ( res . mkdirs ( ) ) return getCanonicalResourceEL ( res ) ; } else { if ( parent . mkdirs ( ) && createNewResourceEL ( res ) ) return getCanonicalResourceEL ( res ) ; } } } return null ; }
public V put ( K key , V value ) { final int hash ; int index ; if ( key == null ) { hash = _NUM ; index = indexOfNull ( ) ; } else { hash = key . hashCode ( ) ; index = indexOf ( key , hash ) ; } if ( index >= _NUM ) { index = ( index << _NUM ) + _NUM ; final V old = ( V ) mArray [ index ] ; mArray [ index ] = value ; return old ; } index = ~ index ; if ( mSize >= mHashes . length ) { final int n = mSize >= ( BASE_SIZE * _NUM ) ? ( mSize + ( mSize > > _NUM ) ) : ( mSize >= BASE_SIZE ? ( BASE_SIZE * _NUM ) : BASE_SIZE ) ; final int [ ] ohashes = mHashes ; final Object [ ] oarray = mArray ; allocArrays ( n ) ; if ( mHashes . length > _NUM ) { System . arraycopy ( ohashes , _NUM , mHashes , _NUM , ohashes . length ) ; System . arraycopy ( oarray , _NUM , mArray , _NUM , oarray . length ) ; } freeArrays ( ohashes , oarray , mSize ) ; } if ( index < mSize ) { System . arraycopy ( mHashes , index , mHashes , index + _NUM , mSize - index ) ; System . arraycopy ( mArray , index << _NUM , mArray , ( index + _NUM ) << _NUM , ( mSize - index ) << _NUM ) ; } mHashes [ index ] = hash ; mArray [ index << _NUM ] = key ; mArray [ ( index << _NUM ) + _NUM ] = value ; mSize ++ ; return null ; }
public static String relativePath ( File file , File dir ) { checkArgument ( file . isFile ( ) || file . isDirectory ( ) , STRING , file . getPath ( ) ) ; checkArgument ( dir . isDirectory ( ) , STRING , dir . getPath ( ) ) ; return relativePossiblyNonExistingPath ( file , dir ) ; }
public static String relativePath ( File file , File dir ) { checkArgument ( file . isFile ( ) || file . isDirectory ( ) , STRING , file . getPath ( ) ) ; checkArgument ( dir . isDirectory ( ) , STRING , dir . getPath ( ) ) ; return relativePossiblyNonExistingPath ( file , dir ) ; }
public void remove ( ExampleSetBasedIndividual individual ) { individuals . remove ( individual ) ; }
public void ensureCapacity ( int minimumCapacity ) { if ( minimumCapacity <= _capacity ) return ; if ( minimumCapacity > _NUM ) { _capacity = ( minimumCapacity + _NUM ) & ~ _NUM ; } else { while ( _capacity < minimumCapacity ) { _capacity += _capacity ; } } byte [ ] bytes = new byte [ _capacity ] ; System . arraycopy ( _buffer , _NUM , bytes , _NUM , _length ) ; _buffer = bytes ; }
public void ensureCapacity ( int minimumCapacity ) { if ( minimumCapacity <= _capacity ) return ; if ( minimumCapacity > _NUM ) { _capacity = ( minimumCapacity + _NUM ) & ~ _NUM ; } else { while ( _capacity < minimumCapacity ) { _capacity += _capacity ; } } byte [ ] bytes = new byte [ _capacity ] ; System . arraycopy ( _buffer , _NUM , bytes , _NUM , _length ) ; _buffer = bytes ; }
public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( super . toString ( ) + STRING ) ; if ( fullName != null ) { sb . append ( STRING + fullName + STRING ) ; } if ( relativeName != null ) { sb . append ( STRING + relativeName + STRING ) ; } sb . append ( STRING + onlyContainsUserCerts + STRING ) ; sb . append ( STRING + onlyContainsCACerts + STRING ) ; if ( reasonFlags != null ) { sb . append ( STRING ) ; for ( int i = _NUM ; i < reasonFlags . length ; i ++ ) { if ( reasonFlags [ i ] ) { sb . append ( STRING + reasonToString ( i ) + STRING ) ; } } } sb . append ( STRING + indirectCRL + STRING ) ; return sb . toString ( ) ; }
public void addDimensionKeyName ( String key ) { dimensionKeyNames . add ( key ) ; }
private MovieChooserModel ( ) { setName ( BUNDLE . getString ( STRING ) ) ; combinedName = name ; }
public static void queueColumnLoad ( ICubicWorld world , CubeIO loader , int x , int z , Consumer < Column > runnable ) { QueuedColumn key = new QueuedColumn ( x , z , world ) ; AsyncColumnIOProvider task = columnTasks . get ( key ) ; if ( task == null ) { task = new AsyncColumnIOProvider ( key , loader ) ; task . addCallback ( runnable ) ; columnTasks . put ( key , task ) ; pool . execute ( task ) ; } else { task . addCallback ( runnable ) ; } }
public static void editNodeComments ( final CGraphModel model , final INaviViewNode node , final InitialTab initialTab ) { Preconditions . checkNotNull ( node , STRING ) ; final JDialog dialog = getCommentDialog ( model , node , initialTab ) ; GuiHelper . centerChildToParent ( model . getParent ( ) , dialog , _BOOL ) ; dialog . setVisible ( _BOOL ) ; }
public static void editNodeComments ( final CGraphModel model , final INaviViewNode node , final InitialTab initialTab ) { Preconditions . checkNotNull ( node , STRING ) ; final JDialog dialog = getCommentDialog ( model , node , initialTab ) ; GuiHelper . centerChildToParent ( model . getParent ( ) , dialog , _BOOL ) ; dialog . setVisible ( _BOOL ) ; }
public static void editNodeComments ( final CGraphModel model , final INaviViewNode node , final InitialTab initialTab ) { Preconditions . checkNotNull ( node , STRING ) ; final JDialog dialog = getCommentDialog ( model , node , initialTab ) ; GuiHelper . centerChildToParent ( model . getParent ( ) , dialog , _BOOL ) ; dialog . setVisible ( _BOOL ) ; }
public RTHtml < RTImage , RTAudio , RTVideo > convert ( final Spanned text , RTFormat . Html rtFormat ) { mText = text ; mRTFormat = rtFormat ; mOut = new StringBuilder ( ) ; mImages = new ArrayList < > ( ) ; mParagraphStyles . clear ( ) ; convertParagraphs ( ) ; return new RTHtml < > ( rtFormat , mOut . toString ( ) , mImages ) ; }
public RTHtml < RTImage , RTAudio , RTVideo > convert ( final Spanned text , RTFormat . Html rtFormat ) { mText = text ; mRTFormat = rtFormat ; mOut = new StringBuilder ( ) ; mImages = new ArrayList < > ( ) ; mParagraphStyles . clear ( ) ; convertParagraphs ( ) ; return new RTHtml < > ( rtFormat , mOut . toString ( ) , mImages ) ; }
protected void assertSameScores ( Query q1 , Query q2 ) throws Exception { assertSameSet ( q1 , q2 ) ; assertSameScores ( q1 , q2 , null ) ; int numFilters = TEST_NIGHTLY ? atLeast ( _NUM ) : atLeast ( _NUM ) ; for ( int i = _NUM ; i < numFilters ; i ++ ) { Query filter = randomFilter ( ) ; assertSameScores ( q1 , q2 , filter ) ; assertSameScores ( filteredQuery ( q1 , filter ) , filteredQuery ( q2 , filter ) , null ) ; } }
protected void assertSameScores ( Query q1 , Query q2 ) throws Exception { assertSameSet ( q1 , q2 ) ; assertSameScores ( q1 , q2 , null ) ; int numFilters = TEST_NIGHTLY ? atLeast ( _NUM ) : atLeast ( _NUM ) ; for ( int i = _NUM ; i < numFilters ; i ++ ) { Query filter = randomFilter ( ) ; assertSameScores ( q1 , q2 , filter ) ; assertSameScores ( filteredQuery ( q1 , filter ) , filteredQuery ( q2 , filter ) , null ) ; } }
protected void assertSameScores ( Query q1 , Query q2 ) throws Exception { assertSameSet ( q1 , q2 ) ; assertSameScores ( q1 , q2 , null ) ; int numFilters = TEST_NIGHTLY ? atLeast ( _NUM ) : atLeast ( _NUM ) ; for ( int i = _NUM ; i < numFilters ; i ++ ) { Query filter = randomFilter ( ) ; assertSameScores ( q1 , q2 , filter ) ; assertSameScores ( filteredQuery ( q1 , filter ) , filteredQuery ( q2 , filter ) , null ) ; } }
@ Override public String toString ( String pad , int recursionLevel ) { StringBuffer result = new StringBuffer ( ) ; result . append ( pad ) ; result . append ( STRING ) ; for ( FPTreeNode node : m_children . values ( ) ) { result . append ( node . toString ( pad + STRING , recursionLevel ) ) ; } return result . toString ( ) ; }
private String fName ( String name ) { return dir . getPath ( ) + File . separator + name ; }
public static String formatNumber ( final BigDecimal number , final int fractionDigits , final boolean useGrouping ) { final NumberFormat numberFormat = NumberFormat . getInstance ( ) ; numberFormat . setMinimumFractionDigits ( fractionDigits ) ; numberFormat . setMaximumFractionDigits ( fractionDigits ) ; numberFormat . setGroupingUsed ( useGrouping ) ; return numberFormat . format ( number . doubleValue ( ) ) ; }
public EncoderTestSuiteBuilder encoded ( int min , int max ) { _encoded . set ( min , max + _NUM ) ; _valid . clear ( min , max + _NUM ) ; _invalid . clear ( min , max + _NUM ) ; return this ; }
public EncoderTestSuiteBuilder encoded ( int min , int max ) { _encoded . set ( min , max + _NUM ) ; _valid . clear ( min , max + _NUM ) ; _invalid . clear ( min , max + _NUM ) ; return this ; }
public void addDocument ( Document d ) { if ( ! m_readMode ) { try { writer . addDocument ( d ) ; m_hitCountCache . clear ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { throw new IllegalStateException ( STRING + STRING ) ; } }
public void dup2X2 ( ) { mv . visitInsn ( Opcodes . DUP2_X2 ) ; }
public static Builder createBuilder ( Header header , WritableFontData data ) { return new Builder ( header , data ) ; }
public static Builder createBuilder ( Header header , WritableFontData data ) { return new Builder ( header , data ) ; }
public static Builder createBuilder ( Header header , WritableFontData data ) { return new Builder ( header , data ) ; }
public boolean verify ( ) throws NoSuchAlgorithmException , NoSuchProviderException , InvalidKeyException , SignatureException { return verify ( BouncyCastleProvider . PROVIDER_NAME ) ; }
public boolean verify ( ) throws NoSuchAlgorithmException , NoSuchProviderException , InvalidKeyException , SignatureException { return verify ( BouncyCastleProvider . PROVIDER_NAME ) ; }
public static String [ ] split ( String searchIn , String splitter ) { String [ ] results = new String [ count ( searchIn , splitter ) + _NUM ] ; int position = _NUM ; int i = _NUM ; while ( searchIn . indexOf ( splitter , position ) >= _NUM ) { results [ i ] = searchIn . substring ( position , searchIn . indexOf ( splitter , position + _NUM ) ) ; position = searchIn . indexOf ( splitter , position ) + _NUM ; i ++ ; } results [ ( results . length - _NUM ) ] = searchIn . substring ( position ) ; return results ; }
public static double parseDouble ( byte [ ] bytes , int startIndex , int endIndex ) { if ( endIndex - startIndex == _NUM ) { return Double . longBitsToDouble ( parseLong ( bytes , startIndex , endIndex ) ) ; } else if ( endIndex - startIndex == _NUM ) { return Float . intBitsToFloat ( ( int ) parseLong ( bytes , startIndex , endIndex ) ) ; } else { throw new IllegalArgumentException ( STRING + endIndex + STRING + startIndex + STRING ) ; } }
public static double parseDouble ( byte [ ] bytes , int startIndex , int endIndex ) { if ( endIndex - startIndex == _NUM ) { return Double . longBitsToDouble ( parseLong ( bytes , startIndex , endIndex ) ) ; } else if ( endIndex - startIndex == _NUM ) { return Float . intBitsToFloat ( ( int ) parseLong ( bytes , startIndex , endIndex ) ) ; } else { throw new IllegalArgumentException ( STRING + endIndex + STRING + startIndex + STRING ) ; } }
public FileReaderSource ( File file , CompilerConfiguration configuration ) { super ( configuration ) ; this . file = file ; }
public void removeBookmark ( final CBookmark bookmark ) { Preconditions . checkNotNull ( bookmark , STRING ) ; Preconditions . checkArgument ( m_bookmarks . remove ( bookmark ) , STRING ) ; for ( final IBookmarkManagerListener listener : m_listeners ) { try { listener . removedBookmark ( this , bookmark ) ; } catch ( final Exception exception ) { CUtilityFunctions . logException ( exception ) ; } } }
public void removeBookmark ( final CBookmark bookmark ) { Preconditions . checkNotNull ( bookmark , STRING ) ; Preconditions . checkArgument ( m_bookmarks . remove ( bookmark ) , STRING ) ; for ( final IBookmarkManagerListener listener : m_listeners ) { try { listener . removedBookmark ( this , bookmark ) ; } catch ( final Exception exception ) { CUtilityFunctions . logException ( exception ) ; } } }
public Picture ( File file ) { try { image = ImageIO . read ( file ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( STRING + file ) ; } if ( image == null ) { throw new RuntimeException ( STRING + file ) ; } width = image . getWidth ( null ) ; height = image . getHeight ( null ) ; filename = file . getName ( ) ; }
public Picture ( File file ) { try { image = ImageIO . read ( file ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( STRING + file ) ; } if ( image == null ) { throw new RuntimeException ( STRING + file ) ; } width = image . getWidth ( null ) ; height = image . getHeight ( null ) ; filename = file . getName ( ) ; }
abstract protected void processCommand ( String line ) throws Exception ;
void seek ( int position ) throws IOException { mDexFile . seek ( position ) ; }
void seek ( int position ) throws IOException { mDexFile . seek ( position ) ; }
public static String convertCrlToPEM ( final X509CRL crl ) throws DSSException { try { final byte [ ] derCrl = crl . getEncoded ( ) ; String pemCrlPre = Base64 . encodeBase64String ( derCrl ) ; final String pemCrl = CRL_BEGIN + NEW_LINE + pemCrlPre + NEW_LINE + CRL_END ; return pemCrl ; } catch ( CRLException e ) { throw new DSSException ( STRING + e . getMessage ( ) ) ; } }
public String process ( String to_process ) { if ( to_process == null || to_process . length ( ) == _NUM ) return STRING ; String tmp = STRING ; StringTokenizer st = new StringTokenizer ( to_process , STRING , _BOOL ) ; StringBuffer newValue = new StringBuffer ( to_process . length ( ) + _NUM ) ; while ( st . hasMoreTokens ( ) ) { tmp = st . nextToken ( ) ; if ( hasAttribute ( tmp ) ) newValue . append ( ( String ) get ( tmp ) ) ; else newValue . append ( tmp ) ; } return newValue . toString ( ) ; }
public static Document stringToDom ( String xmlString , boolean useNamespaces ) throws SAXException { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setNamespaceAware ( useNamespaces ) ; StringReader reader = new StringReader ( xmlString ) ; InputSource input = new InputSource ( reader ) ; DocumentBuilder builder ; try { builder = factory . newDocumentBuilder ( ) ; } catch ( ParserConfigurationException e ) { log . fatal ( STRING + e . getMessage ( ) ) ; return null ; } Document dom ; try { dom = builder . parse ( input ) ; } catch ( IOException e ) { log . fatal ( STRING + e . getMessage ( ) ) ; return null ; } return dom ; }
public static Document stringToDom ( String xmlString , boolean useNamespaces ) throws SAXException { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setNamespaceAware ( useNamespaces ) ; StringReader reader = new StringReader ( xmlString ) ; InputSource input = new InputSource ( reader ) ; DocumentBuilder builder ; try { builder = factory . newDocumentBuilder ( ) ; } catch ( ParserConfigurationException e ) { log . fatal ( STRING + e . getMessage ( ) ) ; return null ; } Document dom ; try { dom = builder . parse ( input ) ; } catch ( IOException e ) { log . fatal ( STRING + e . getMessage ( ) ) ; return null ; } return dom ; }
public void writeField ( String name , String value ) throws IOException { if ( name == null ) { throw new IllegalArgumentException ( STRING ) ; } out . writeBytes ( PREFIX ) ; out . writeBytes ( boundary ) ; out . writeBytes ( NEWLINE ) ; out . writeBytes ( STRING + name + STRING ) ; out . writeBytes ( NEWLINE ) ; out . writeBytes ( NEWLINE ) ; if ( value != null ) { out . writeBytes ( value ) ; } out . writeBytes ( NEWLINE ) ; out . flush ( ) ; }
public ServerConfiguration killBookie ( int index ) throws Exception { if ( index >= bs . size ( ) ) { throw new IOException ( STRING ) ; } BookieServer server = bs . get ( index ) ; server . shutdown ( ) ; stopAutoRecoveryService ( server ) ; bs . remove ( server ) ; return bsConfs . remove ( index ) ; }
public static boolean removeBeanOrFolder ( String path ) { return removePath ( path . split ( PATH_SEPARATOR ) , s_directory , _NUM ) > _NUM ; }
public void close ( ResultSet rs ) { try { Statement statement = rs . getStatement ( ) ; rs . close ( ) ; statement . close ( ) ; statement = null ; rs = null ; } catch ( Exception e ) { } }
public void close ( ResultSet rs ) { try { Statement statement = rs . getStatement ( ) ; rs . close ( ) ; statement . close ( ) ; statement = null ; rs = null ; } catch ( Exception e ) { } }
public DNetscapeBaseUrl ( JDialog parent , byte [ ] value ) throws IOException { super ( parent ) ; setTitle ( res . getString ( STRING ) ) ; initComponents ( ) ; prepopulateWithValue ( value ) ; }
protected double compute ( String value ) { if ( value != null ) { try { return Double . parseDouble ( value ) ; } catch ( NumberFormatException e ) { if ( POSITIVE_INFINITY_STRING . equals ( value ) ) { return Double . POSITIVE_INFINITY ; } else if ( NEGATIVE_INFINITY_STRING . equals ( value ) ) { return Double . NEGATIVE_INFINITY ; } return Double . NaN ; } } return Double . NaN ; }
public void forcePut ( E e ) throws InterruptedException { if ( e == null ) throw new NullPointerException ( ) ; int c = - _NUM ; final ReentrantLock putLock = this . putLock ; final AtomicInteger count = this . count ; putLock . lockInterruptibly ( ) ; try { enqueue ( e ) ; c = count . getAndIncrement ( ) ; if ( c + _NUM < capacity ) notFull . signal ( ) ; } finally { putLock . unlock ( ) ; } if ( c == _NUM ) signalNotEmpty ( ) ; }
public void forcePut ( E e ) throws InterruptedException { if ( e == null ) throw new NullPointerException ( ) ; int c = - _NUM ; final ReentrantLock putLock = this . putLock ; final AtomicInteger count = this . count ; putLock . lockInterruptibly ( ) ; try { enqueue ( e ) ; c = count . getAndIncrement ( ) ; if ( c + _NUM < capacity ) notFull . signal ( ) ; } finally { putLock . unlock ( ) ; } if ( c == _NUM ) signalNotEmpty ( ) ; }
public void forcePut ( E e ) throws InterruptedException { if ( e == null ) throw new NullPointerException ( ) ; int c = - _NUM ; final ReentrantLock putLock = this . putLock ; final AtomicInteger count = this . count ; putLock . lockInterruptibly ( ) ; try { enqueue ( e ) ; c = count . getAndIncrement ( ) ; if ( c + _NUM < capacity ) notFull . signal ( ) ; } finally { putLock . unlock ( ) ; } if ( c == _NUM ) signalNotEmpty ( ) ; }
public static JCas runTest ( String aDocumentId , AnalysisEngine aEngine , String aLanguage , String aDocument ) throws UIMAException { if ( offline ) { System . setProperty ( ResourceObjectProviderBase . PROP_REPO_OFFLINE , STRING ) ; } offline = _BOOL ; JCas jcas = aEngine . newJCas ( ) ; if ( aDocumentId != null ) { DocumentMetaData meta = DocumentMetaData . create ( jcas ) ; meta . setDocumentId ( aDocumentId ) ; } jcas . setDocumentLanguage ( aLanguage ) ; TokenBuilder < Token , Sentence > tb = new TokenBuilder < Token , Sentence > ( Token . class , Sentence . class ) ; tb . buildTokens ( jcas , aDocument ) ; aEngine . process ( jcas ) ; AssertAnnotations . assertValid ( jcas ) ; return jcas ; }
public static JCas runTest ( String aDocumentId , AnalysisEngine aEngine , String aLanguage , String aDocument ) throws UIMAException { if ( offline ) { System . setProperty ( ResourceObjectProviderBase . PROP_REPO_OFFLINE , STRING ) ; } offline = _BOOL ; JCas jcas = aEngine . newJCas ( ) ; if ( aDocumentId != null ) { DocumentMetaData meta = DocumentMetaData . create ( jcas ) ; meta . setDocumentId ( aDocumentId ) ; } jcas . setDocumentLanguage ( aLanguage ) ; TokenBuilder < Token , Sentence > tb = new TokenBuilder < Token , Sentence > ( Token . class , Sentence . class ) ; tb . buildTokens ( jcas , aDocument ) ; aEngine . process ( jcas ) ; AssertAnnotations . assertValid ( jcas ) ; return jcas ; }
public void addUpdateCallback ( ILocalCallback cb ) { synchronized ( mUpdateCallbacks ) { mUpdateCallbacks . add ( cb ) ; } }
public static byte [ ] hexStringToBytes ( String hex ) { int l = ( hex . length ( ) + _NUM ) / _NUM ; byte [ ] r = new byte [ l ] ; int i = _NUM ; int j = _NUM ; if ( hex . length ( ) % _NUM == _NUM ) { r [ _NUM ] = hexDigitToByte ( hex . charAt ( _NUM ) ) ; i = j = _NUM ; } while ( i < l ) r [ i ++ ] = ( byte ) ( ( hexDigitToByte ( hex . charAt ( j ++ ) ) << _NUM ) | hexDigitToByte ( hex . charAt ( j ++ ) ) ) ; return r ; }
protected boolean isAlwaysNonNull ( Value v ) { return _BOOL ; }
protected boolean isAlwaysNonNull ( Value v ) { return _BOOL ; }
private final double readDatum ( final DataInput in , final ColumnType columnType ) throws IOException { switch ( columnType ) { case DOUBLE : return in . readDouble ( ) ; case INTEGER : int iValue = in . readInt ( ) ; if ( iValue == Integer . MIN_VALUE + _NUM ) { boolean isMissing = in . readBoolean ( ) ; if ( isMissing ) { return Double . NaN ; } else { return iValue ; } } else { return iValue ; } case NOMINAL_BYTE : byte bValue = in . readByte ( ) ; if ( bValue == - _NUM ) { return Double . NaN ; } else { return bValue ; } case NOMINAL_INTEGER : iValue = in . readInt ( ) ; if ( iValue == - _NUM ) { return Double . NaN ; } else { return iValue ; } case NOMINAL_SHORT : short sValue = in . readShort ( ) ; if ( sValue == - _NUM ) { return Double . NaN ; } else { return sValue ; } default : throw new RuntimeException ( STRING + columnType ) ; } }
private final double readDatum ( final DataInput in , final ColumnType columnType ) throws IOException { switch ( columnType ) { case DOUBLE : return in . readDouble ( ) ; case INTEGER : int iValue = in . readInt ( ) ; if ( iValue == Integer . MIN_VALUE + _NUM ) { boolean isMissing = in . readBoolean ( ) ; if ( isMissing ) { return Double . NaN ; } else { return iValue ; } } else { return iValue ; } case NOMINAL_BYTE : byte bValue = in . readByte ( ) ; if ( bValue == - _NUM ) { return Double . NaN ; } else { return bValue ; } case NOMINAL_INTEGER : iValue = in . readInt ( ) ; if ( iValue == - _NUM ) { return Double . NaN ; } else { return iValue ; } case NOMINAL_SHORT : short sValue = in . readShort ( ) ; if ( sValue == - _NUM ) { return Double . NaN ; } else { return sValue ; } default : throw new RuntimeException ( STRING + columnType ) ; } }
private void processNewPort ( DatapathId sw , OFPort p ) { if ( isLinkDiscoverySuppressed ( sw , p ) ) { return ; } IOFSwitch iofSwitch = switchService . getSwitch ( sw ) ; if ( iofSwitch == null ) { return ; } NodePortTuple npt = new NodePortTuple ( sw , p ) ; discover ( sw , p ) ; addToQuarantineQueue ( npt ) ; }
private void processNewPort ( DatapathId sw , OFPort p ) { if ( isLinkDiscoverySuppressed ( sw , p ) ) { return ; } IOFSwitch iofSwitch = switchService . getSwitch ( sw ) ; if ( iofSwitch == null ) { return ; } NodePortTuple npt = new NodePortTuple ( sw , p ) ; discover ( sw , p ) ; addToQuarantineQueue ( npt ) ; }
protected void showPopup ( Iterator < String > iter ) { getPopupComponent ( ) ; boolean different = _BOOL ; Vector < String > v = new Vector < String > ( ) ; ListModel < String > model = entryList . getModel ( ) ; for ( int i = _NUM ; iter . hasNext ( ) ; i ++ ) { String next = iter . next ( ) ; v . add ( next ) ; if ( ! different && i < model . getSize ( ) ) different |= ! next . equals ( model . getElementAt ( i ) ) ; } different |= model . getSize ( ) != v . size ( ) ; if ( different ) { entryList . setListData ( v ) ; entryList . clearSelection ( ) ; } entryList . setCurrentText ( getText ( ) ) ; showPopup ( ) ; }
public static byte [ ] decode ( String data ) throws CoderException { byte [ ] array = new byte [ data . length ( ) * _NUM / _NUM ] ; char [ ] block = new char [ _NUM ] ; int length = _NUM ; data = data . trim ( ) ; final int len = data . length ( ) ; if ( len == _NUM ) return new byte [ _NUM ] ; if ( len % _NUM != _NUM || len < _NUM ) throw new CoderException ( STRING + printString ( data ) + STRING ) ; for ( int position = _NUM ; position < len ; ) { int p ; for ( p = _NUM ; p < _NUM && position < data . length ( ) ; position ++ ) { char c = data . charAt ( position ) ; if ( ! Character . isWhitespace ( c ) ) { block [ p ] = c ; p ++ ; } } if ( p == _NUM ) break ; int l = decodeGroup ( block , array , length ) ; length += l ; if ( l < _NUM ) break ; } return Arrays . copyOf ( array , length ) ; }
public String toHTML ( ) { StringBuilder builder = new StringBuilder ( ) ; int numClasses = classes . size ( ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( String . format ( STRING , numClasses + _NUM ) ) ; builder . append ( STRING ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( predicted ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( STRING ) ; String firstColumnLabel = String . format ( STRING , numClasses + _NUM ) ; for ( T actual : classes ) { builder . append ( firstColumnLabel ) ; firstColumnLabel = STRING ; builder . append ( String . format ( STRING , actual ) ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( getCount ( actual , predicted ) ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( getActualTotal ( actual ) ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( getPredictedTotal ( predicted ) ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; return builder . toString ( ) ; }
public String toHTML ( ) { StringBuilder builder = new StringBuilder ( ) ; int numClasses = classes . size ( ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( String . format ( STRING , numClasses + _NUM ) ) ; builder . append ( STRING ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( predicted ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( STRING ) ; String firstColumnLabel = String . format ( STRING , numClasses + _NUM ) ; for ( T actual : classes ) { builder . append ( firstColumnLabel ) ; firstColumnLabel = STRING ; builder . append ( String . format ( STRING , actual ) ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( getCount ( actual , predicted ) ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( getActualTotal ( actual ) ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( getPredictedTotal ( predicted ) ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; return builder . toString ( ) ; }
public String toHTML ( ) { StringBuilder builder = new StringBuilder ( ) ; int numClasses = classes . size ( ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( String . format ( STRING , numClasses + _NUM ) ) ; builder . append ( STRING ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( predicted ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( STRING ) ; String firstColumnLabel = String . format ( STRING , numClasses + _NUM ) ; for ( T actual : classes ) { builder . append ( firstColumnLabel ) ; firstColumnLabel = STRING ; builder . append ( String . format ( STRING , actual ) ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( getCount ( actual , predicted ) ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( getActualTotal ( actual ) ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( getPredictedTotal ( predicted ) ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; return builder . toString ( ) ; }
void close ( ) throws IOException ;
void close ( ) throws IOException ;
void close ( ) throws IOException ;
void close ( ) throws IOException ;
@ Override public void destroy ( ) { Thread thread = Thread . currentThread ( ) ; ClassLoader oldLoader = thread . getContextClassLoader ( ) ; try { thread . setContextClassLoader ( this ) ; WeakStopListener stopListener = _stopListener ; _stopListener = null ; super . destroy ( ) ; thread . setContextClassLoader ( oldLoader ) ; ClassLoader parent = getParent ( ) ; for ( ; parent != null ; parent = parent . getParent ( ) ) { if ( parent instanceof EnvironmentClassLoader ) { EnvironmentClassLoader loader = ( EnvironmentClassLoader ) parent ; loader . removeListener ( stopListener ) ; } } } finally { thread . setContextClassLoader ( oldLoader ) ; _attributes = null ; _listeners = null ; } }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case _NUM : return AFTER_ID ; case _NUM : return MAX_JOBS ; default : return null ; } }
public DefaultTerminalFactory ( ) { this ( DEFAULT_OUTPUT_STREAM , DEFAULT_INPUT_STREAM , DEFAULT_CHARSET ) ; }
static private String LONG_Min ( ) { long tempValue = Long . MIN_VALUE ; return String . valueOf ( tempValue ) ; }
static private String LONG_Min ( ) { long tempValue = Long . MIN_VALUE ; return String . valueOf ( tempValue ) ; }
public static String implode ( Collection < String > items , String delimiter ) { Parameters . notNull ( STRING , items ) ; Parameters . notNull ( STRING , delimiter ) ; if ( items . isEmpty ( ) ) { return STRING ; } StringBuilder buffer = new StringBuilder ( _NUM ) ; boolean first = _BOOL ; for ( String s : items ) { if ( ! first ) { buffer . append ( delimiter ) ; } buffer . append ( s ) ; first = _BOOL ; } return buffer . toString ( ) ; }
public void init ( ) throws SpaceComponentsInitializeException { _componentsHandlers = _space . getSpaceComponentHandlers ( ) ; try { SpaceInitializationIndicator . setInitializer ( ) ; for ( Iterator < ISpaceComponentsHandler > iterator = _componentsHandlers . iterator ( ) ; iterator . hasNext ( ) ; ) { ISpaceComponentsHandler handler = iterator . next ( ) ; if ( handler . isRecoverySupported ( ) ) handler . initComponents ( _BOOL ) ; } } finally { SpaceInitializationIndicator . unsetInitializer ( ) ; } _space . addInternalSpaceModeListener ( this ) ; }
public void init ( ) throws SpaceComponentsInitializeException { _componentsHandlers = _space . getSpaceComponentHandlers ( ) ; try { SpaceInitializationIndicator . setInitializer ( ) ; for ( Iterator < ISpaceComponentsHandler > iterator = _componentsHandlers . iterator ( ) ; iterator . hasNext ( ) ; ) { ISpaceComponentsHandler handler = iterator . next ( ) ; if ( handler . isRecoverySupported ( ) ) handler . initComponents ( _BOOL ) ; } } finally { SpaceInitializationIndicator . unsetInitializer ( ) ; } _space . addInternalSpaceModeListener ( this ) ; }
public void init ( ) throws SpaceComponentsInitializeException { _componentsHandlers = _space . getSpaceComponentHandlers ( ) ; try { SpaceInitializationIndicator . setInitializer ( ) ; for ( Iterator < ISpaceComponentsHandler > iterator = _componentsHandlers . iterator ( ) ; iterator . hasNext ( ) ; ) { ISpaceComponentsHandler handler = iterator . next ( ) ; if ( handler . isRecoverySupported ( ) ) handler . initComponents ( _BOOL ) ; } } finally { SpaceInitializationIndicator . unsetInitializer ( ) ; } _space . addInternalSpaceModeListener ( this ) ; }
public static boolean write ( Writer writer , Object toSerialize ) throws Exception { Class < ? > xstreamClass ; java . lang . reflect . Constructor < ? > constructor ; Object xstream ; Class < ? > [ ] serializeArgsClasses = new Class [ _NUM ] ; Object [ ] serializeArgs = new Object [ _NUM ] ; java . lang . reflect . Method methodSerialize ; boolean result = _BOOL ; xstreamClass = Class . forName ( STRING ) ; constructor = xstreamClass . getConstructor ( ) ; xstream = constructor . newInstance ( ) ; serializeArgsClasses [ _NUM ] = Object . class ; serializeArgsClasses [ _NUM ] = Writer . class ; serializeArgs [ _NUM ] = toSerialize ; serializeArgs [ _NUM ] = writer ; methodSerialize = xstreamClass . getMethod ( STRING , serializeArgsClasses ) ; try { methodSerialize . invoke ( xstream , serializeArgs ) ; result = _BOOL ; } catch ( Exception ex ) { result = _BOOL ; } return result ; }
public PrintfFormat ( final String fmtArg ) throws IllegalArgumentException { this ( Locale . getDefault ( ) , fmtArg ) ; }
public PrintfFormat ( final String fmtArg ) throws IllegalArgumentException { this ( Locale . getDefault ( ) , fmtArg ) ; }
public static long now ( ) { return System . currentTimeMillis ( ) ; }
public static long now ( ) { return System . currentTimeMillis ( ) ; }
protected void profileCreated ( Profile profile ) { }
private void addTvShowSeason ( TvShowSeason season , TvShow tvShow ) { if ( nodeMap . get ( season ) != null ) { return ; } TvShowTreeNode parent = ( TvShowTreeNode ) nodeMap . get ( tvShow ) ; TvShowSeasonTreeNode child = new TvShowSeasonTreeNode ( season ) ; if ( parent != null ) { parent . add ( child ) ; nodeMap . put ( season , child ) ; int index = getIndexOfChild ( parent , child ) ; if ( index > - _NUM ) { TreeModelEvent event = new TreeModelEvent ( this , parent . getPath ( ) , new int [ ] { index } , new Object [ ] { child } ) ; for ( TreeModelListener listener : listeners ) { try { listener . treeNodesInserted ( event ) ; } catch ( NullPointerException | ArrayIndexOutOfBoundsException ignored ) { } } } TreeModelEvent event = new TreeModelEvent ( this , root . getPath ( ) , null , null ) ; for ( TreeModelListener listener : listeners ) { try { listener . treeNodesChanged ( event ) ; } catch ( NullPointerException | ArrayIndexOutOfBoundsException ignored ) { } } } }
private void updateCenterPanel ( ) { long now = System . currentTimeMillis ( ) ; if ( _nextUpdateTime > now ) return ; _nextUpdateTime = now + _NUM * _NUM ; _centerPanel . removeAll ( ) ; _centerComponent = new JLabel ( ) ; GridBagConstraints gbc = new GridBagConstraints ( ) ; gbc . gridx = _NUM ; gbc . gridy = _NUM ; gbc . weightx = _NUM ; gbc . fill = GridBagConstraints . NONE ; gbc . anchor = GridBagConstraints . CENTER ; _centerPanel . add ( _centerComponent , gbc ) ; refresh ( ) ; }
private void updateCenterPanel ( ) { long now = System . currentTimeMillis ( ) ; if ( _nextUpdateTime > now ) return ; _nextUpdateTime = now + _NUM * _NUM ; _centerPanel . removeAll ( ) ; _centerComponent = new JLabel ( ) ; GridBagConstraints gbc = new GridBagConstraints ( ) ; gbc . gridx = _NUM ; gbc . gridy = _NUM ; gbc . weightx = _NUM ; gbc . fill = GridBagConstraints . NONE ; gbc . anchor = GridBagConstraints . CENTER ; _centerPanel . add ( _centerComponent , gbc ) ; refresh ( ) ; }
private void updateCenterPanel ( ) { long now = System . currentTimeMillis ( ) ; if ( _nextUpdateTime > now ) return ; _nextUpdateTime = now + _NUM * _NUM ; _centerPanel . removeAll ( ) ; _centerComponent = new JLabel ( ) ; GridBagConstraints gbc = new GridBagConstraints ( ) ; gbc . gridx = _NUM ; gbc . gridy = _NUM ; gbc . weightx = _NUM ; gbc . fill = GridBagConstraints . NONE ; gbc . anchor = GridBagConstraints . CENTER ; _centerPanel . add ( _centerComponent , gbc ) ; refresh ( ) ; }
public void addCloseClientListener ( CloseClientListener l ) { closeClientListeners . addElement ( l ) ; }
public void addCloseClientListener ( CloseClientListener l ) { closeClientListeners . addElement ( l ) ; }
public void addCloseClientListener ( CloseClientListener l ) { closeClientListeners . addElement ( l ) ; }
public void addCloseClientListener ( CloseClientListener l ) { closeClientListeners . addElement ( l ) ; }
protected void initPool ( ) { running = _BOOL ; for ( int i = size ; -- i >= _NUM ; ) { PoolThread thread = new PoolThread ( ) ; threadPool . add ( thread ) ; thread . start ( ) ; } }
private static Future < ? > directExecute ( Runnable runnable , long delay ) { Future < ? > future = null ; if ( delay > _NUM ) { if ( ! ( executor instanceof ScheduledExecutorService ) ) { throw new IllegalArgumentException ( STRING ) ; } ScheduledExecutorService scheduledExecutorService = ( ScheduledExecutorService ) executor ; future = scheduledExecutorService . schedule ( runnable , delay , TimeUnit . MILLISECONDS ) ; } else { if ( executor instanceof ExecutorService ) { ExecutorService executorService = ( ExecutorService ) executor ; future = executorService . submit ( runnable ) ; } else { executor . execute ( runnable ) ; } } return future ; }
private static Future < ? > directExecute ( Runnable runnable , long delay ) { Future < ? > future = null ; if ( delay > _NUM ) { if ( ! ( executor instanceof ScheduledExecutorService ) ) { throw new IllegalArgumentException ( STRING ) ; } ScheduledExecutorService scheduledExecutorService = ( ScheduledExecutorService ) executor ; future = scheduledExecutorService . schedule ( runnable , delay , TimeUnit . MILLISECONDS ) ; } else { if ( executor instanceof ExecutorService ) { ExecutorService executorService = ( ExecutorService ) executor ; future = executorService . submit ( runnable ) ; } else { executor . execute ( runnable ) ; } } return future ; }
private String buildAuthHeaderString ( String httpsURL , String requestMethod , OAuthParameters params ) { generateAndSignSignature ( httpsURL , requestMethod , params ) ; StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( OAUTH_START_STRING ) ; Map < String , SortedSet < String > > paramMap = params . getBaseParameters ( ) ; buffer = parseParameters ( buffer , paramMap ) ; this . authHeader = buffer . toString ( ) ; return buffer . toString ( ) ; }
private String buildAuthHeaderString ( String httpsURL , String requestMethod , OAuthParameters params ) { generateAndSignSignature ( httpsURL , requestMethod , params ) ; StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( OAUTH_START_STRING ) ; Map < String , SortedSet < String > > paramMap = params . getBaseParameters ( ) ; buffer = parseParameters ( buffer , paramMap ) ; this . authHeader = buffer . toString ( ) ; return buffer . toString ( ) ; }
synchronized void unregisterToNotifications ( ) throws JMSException { if ( eventSession == null ) { return ; } if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , toString2 ( ) + STRING ) ; } try { eventSession . close ( ) ; } catch ( IOException e ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , toString2 ( ) + STRING + e ) ; } JMSException e1 = new JMSException ( STRING ) ; e1 . setLinkedException ( e ) ; throw e1 ; } catch ( UnknownLeaseException e ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , toString2 ( ) + STRING + e ) ; } JMSException e1 = new JMSException ( STRING ) ; e1 . setLinkedException ( e ) ; throw e1 ; } catch ( Exception e ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , toString2 ( ) + STRING + e ) ; } JMSException e1 = new JMSException ( STRING ) ; e1 . setLinkedException ( e ) ; throw e1 ; } finally { eventSession = null ; } }
public Element selectElementMatchingXPath ( String xpath , Element toSearch ) { List < Element > results = selectElementsMatchingXPath ( xpath , toSearch ) ; if ( results . isEmpty ( ) ) { throw new ElementNotFoundException ( xpath , toSearch ) ; } Element match = results . get ( _NUM ) ; return match ; }
public boolean checkError ( ) { try { out . flush ( ) ; } catch ( IOException e ) { hadError = _BOOL ; } return hadError ; }
public boolean checkError ( ) { try { out . flush ( ) ; } catch ( IOException e ) { hadError = _BOOL ; } return hadError ; }
public static String extractActualInstanceType ( String instanceType ) { String [ ] split = instanceType . split ( STRING ) ; return split [ split . length - _NUM ] ; }
public boolean isCloudMessageFailSilently ( ) { return cloudMessageFailSilently ; }
public boolean isCloudMessageFailSilently ( ) { return cloudMessageFailSilently ; }
private static int convertToInt ( String value , int defaultValue ) { String trim = value . trim ( ) ; if ( trim . length ( ) == _NUM ) { return defaultValue ; } return Integer . parseInt ( trim ) ; }
private TInput createInput ( String type , String name , String value ) { String outVal = value ; if ( value . contains ( STRING ) || value . contains ( STRING ) ) { if ( uniqueSources . containsKey ( value ) && value . contains ( STRING ) ) { outVal = STRING + uniqueSources . get ( value ) ; } else { int s = numSources ; numSources ++ ; uniqueSources . put ( value , s ) ; outVal = STRING + s ; } } else if ( value . contains ( STRING ) ) { outVal = STRING ; } return new TInput ( type , name , outVal ) ; }
public Iterator < String > iterateControllers ( ) { return controllers . iterator ( ) ; }
public String resolvePath ( String pathInfo ) { if ( ( pathInfo == null ) || ( pathInfo . indexOf ( STRING ) != - _NUM ) ) { return null ; } int libStart = pathInfo . indexOf ( STRING ) + _NUM ; int libEnd = pathInfo . indexOf ( STRING , libStart ) ; if ( libEnd == - _NUM ) { libEnd = pathInfo . length ( ) ; } String libname = pathInfo . substring ( libStart , libEnd ) ; String subpath = pathInfo . substring ( libEnd ) ; String lib_home = getPath ( libname ) ; if ( lib_home == null ) { return null ; } return lib_home + STRING + subpath ; }
public String resolvePath ( String pathInfo ) { if ( ( pathInfo == null ) || ( pathInfo . indexOf ( STRING ) != - _NUM ) ) { return null ; } int libStart = pathInfo . indexOf ( STRING ) + _NUM ; int libEnd = pathInfo . indexOf ( STRING , libStart ) ; if ( libEnd == - _NUM ) { libEnd = pathInfo . length ( ) ; } String libname = pathInfo . substring ( libStart , libEnd ) ; String subpath = pathInfo . substring ( libEnd ) ; String lib_home = getPath ( libname ) ; if ( lib_home == null ) { return null ; } return lib_home + STRING + subpath ; }
public String resolvePath ( String pathInfo ) { if ( ( pathInfo == null ) || ( pathInfo . indexOf ( STRING ) != - _NUM ) ) { return null ; } int libStart = pathInfo . indexOf ( STRING ) + _NUM ; int libEnd = pathInfo . indexOf ( STRING , libStart ) ; if ( libEnd == - _NUM ) { libEnd = pathInfo . length ( ) ; } String libname = pathInfo . substring ( libStart , libEnd ) ; String subpath = pathInfo . substring ( libEnd ) ; String lib_home = getPath ( libname ) ; if ( lib_home == null ) { return null ; } return lib_home + STRING + subpath ; }
public String resolvePath ( String pathInfo ) { if ( ( pathInfo == null ) || ( pathInfo . indexOf ( STRING ) != - _NUM ) ) { return null ; } int libStart = pathInfo . indexOf ( STRING ) + _NUM ; int libEnd = pathInfo . indexOf ( STRING , libStart ) ; if ( libEnd == - _NUM ) { libEnd = pathInfo . length ( ) ; } String libname = pathInfo . substring ( libStart , libEnd ) ; String subpath = pathInfo . substring ( libEnd ) ; String lib_home = getPath ( libname ) ; if ( lib_home == null ) { return null ; } return lib_home + STRING + subpath ; }
public String resolvePath ( String pathInfo ) { if ( ( pathInfo == null ) || ( pathInfo . indexOf ( STRING ) != - _NUM ) ) { return null ; } int libStart = pathInfo . indexOf ( STRING ) + _NUM ; int libEnd = pathInfo . indexOf ( STRING , libStart ) ; if ( libEnd == - _NUM ) { libEnd = pathInfo . length ( ) ; } String libname = pathInfo . substring ( libStart , libEnd ) ; String subpath = pathInfo . substring ( libEnd ) ; String lib_home = getPath ( libname ) ; if ( lib_home == null ) { return null ; } return lib_home + STRING + subpath ; }
public byte [ ] readRawBytes ( final int size ) throws IOException { if ( size < _NUM ) { throw InvalidProtocolBufferNanoException . negativeSize ( ) ; } if ( bufferPos + size > currentLimit ) { skipRawBytes ( currentLimit - bufferPos ) ; throw InvalidProtocolBufferNanoException . truncatedMessage ( ) ; } if ( size <= bufferSize - bufferPos ) { final byte [ ] bytes = new byte [ size ] ; System . arraycopy ( buffer , bufferPos , bytes , _NUM , size ) ; bufferPos += size ; return bytes ; } else { throw InvalidProtocolBufferNanoException . truncatedMessage ( ) ; } }
public DeferredSubscriptionSubscriber ( Subscriber < ? super O > subscriber ) { this . subscriber = Objects . requireNonNull ( subscriber , STRING ) ; }
static void computeCallerMap ( JsonElement jsonElt , boolean topLevel , Map < String , Map < String , Set < JsonElement > > > callerMap ) { JsonArray childrenArray = Utils . getChildrenArray ( jsonElt ) ; String sig = Utils . getFieldValueAsString ( jsonElt , STRING ) ; if ( childrenArray != null ) { for ( int i = _NUM ; i < childrenArray . size ( ) ; i ++ ) { JsonElement child = childrenArray . get ( i ) ; if ( child . isJsonObject ( ) && ! Utils . isEmptyJsonObject ( child ) ) { JsonObject childObj = child . getAsJsonObject ( ) ; String childSig = Utils . getFieldValueAsString ( childObj , STRING ) ; if ( ! topLevel ) { Map < String , Set < JsonElement > > callers = callerMap . get ( childSig ) ; if ( callers == null ) { callers = new HashMap < String , Set < JsonElement > > ( ) ; callerMap . put ( childSig , callers ) ; } Set < JsonElement > calls = callers . get ( sig ) ; if ( calls == null ) { calls = new HashSet < JsonElement > ( ) ; callers . put ( sig , calls ) ; } calls . add ( jsonElt ) ; } computeCallerMap ( childObj , _BOOL , callerMap ) ; } } } }
static void computeCallerMap ( JsonElement jsonElt , boolean topLevel , Map < String , Map < String , Set < JsonElement > > > callerMap ) { JsonArray childrenArray = Utils . getChildrenArray ( jsonElt ) ; String sig = Utils . getFieldValueAsString ( jsonElt , STRING ) ; if ( childrenArray != null ) { for ( int i = _NUM ; i < childrenArray . size ( ) ; i ++ ) { JsonElement child = childrenArray . get ( i ) ; if ( child . isJsonObject ( ) && ! Utils . isEmptyJsonObject ( child ) ) { JsonObject childObj = child . getAsJsonObject ( ) ; String childSig = Utils . getFieldValueAsString ( childObj , STRING ) ; if ( ! topLevel ) { Map < String , Set < JsonElement > > callers = callerMap . get ( childSig ) ; if ( callers == null ) { callers = new HashMap < String , Set < JsonElement > > ( ) ; callerMap . put ( childSig , callers ) ; } Set < JsonElement > calls = callers . get ( sig ) ; if ( calls == null ) { calls = new HashSet < JsonElement > ( ) ; callers . put ( sig , calls ) ; } calls . add ( jsonElt ) ; } computeCallerMap ( childObj , _BOOL , callerMap ) ; } } } }
static void computeCallerMap ( JsonElement jsonElt , boolean topLevel , Map < String , Map < String , Set < JsonElement > > > callerMap ) { JsonArray childrenArray = Utils . getChildrenArray ( jsonElt ) ; String sig = Utils . getFieldValueAsString ( jsonElt , STRING ) ; if ( childrenArray != null ) { for ( int i = _NUM ; i < childrenArray . size ( ) ; i ++ ) { JsonElement child = childrenArray . get ( i ) ; if ( child . isJsonObject ( ) && ! Utils . isEmptyJsonObject ( child ) ) { JsonObject childObj = child . getAsJsonObject ( ) ; String childSig = Utils . getFieldValueAsString ( childObj , STRING ) ; if ( ! topLevel ) { Map < String , Set < JsonElement > > callers = callerMap . get ( childSig ) ; if ( callers == null ) { callers = new HashMap < String , Set < JsonElement > > ( ) ; callerMap . put ( childSig , callers ) ; } Set < JsonElement > calls = callers . get ( sig ) ; if ( calls == null ) { calls = new HashSet < JsonElement > ( ) ; callers . put ( sig , calls ) ; } calls . add ( jsonElt ) ; } computeCallerMap ( childObj , _BOOL , callerMap ) ; } } } }
static void computeCallerMap ( JsonElement jsonElt , boolean topLevel , Map < String , Map < String , Set < JsonElement > > > callerMap ) { JsonArray childrenArray = Utils . getChildrenArray ( jsonElt ) ; String sig = Utils . getFieldValueAsString ( jsonElt , STRING ) ; if ( childrenArray != null ) { for ( int i = _NUM ; i < childrenArray . size ( ) ; i ++ ) { JsonElement child = childrenArray . get ( i ) ; if ( child . isJsonObject ( ) && ! Utils . isEmptyJsonObject ( child ) ) { JsonObject childObj = child . getAsJsonObject ( ) ; String childSig = Utils . getFieldValueAsString ( childObj , STRING ) ; if ( ! topLevel ) { Map < String , Set < JsonElement > > callers = callerMap . get ( childSig ) ; if ( callers == null ) { callers = new HashMap < String , Set < JsonElement > > ( ) ; callerMap . put ( childSig , callers ) ; } Set < JsonElement > calls = callers . get ( sig ) ; if ( calls == null ) { calls = new HashSet < JsonElement > ( ) ; callers . put ( sig , calls ) ; } calls . add ( jsonElt ) ; } computeCallerMap ( childObj , _BOOL , callerMap ) ; } } } }
private static String doGetFullPath ( String filename , boolean includeSeparator ) { if ( filename == null ) return null ; int prefix = getPrefixLength ( filename ) ; if ( prefix < _NUM ) return null ; if ( prefix >= filename . length ( ) ) { if ( includeSeparator ) return getPrefix ( filename ) ; else return filename ; } int index = indexOfLastSeparator ( filename ) ; if ( index < _NUM ) return filename . substring ( _NUM , prefix ) ; int end = index + ( includeSeparator ? _NUM : _NUM ) ; if ( end == _NUM ) end ++ ; return filename . substring ( _NUM , end ) ; }
public void start ( ) { running = _BOOL ; startTimeMillis = System . currentTimeMillis ( ) ; thread = new Thread ( this , THREAD_NAME_PREFIX + getPort ( ) ) ; thread . start ( ) ; }
public void start ( ) { running = _BOOL ; startTimeMillis = System . currentTimeMillis ( ) ; thread = new Thread ( this , THREAD_NAME_PREFIX + getPort ( ) ) ; thread . start ( ) ; }
public void start ( ) { running = _BOOL ; startTimeMillis = System . currentTimeMillis ( ) ; thread = new Thread ( this , THREAD_NAME_PREFIX + getPort ( ) ) ; thread . start ( ) ; }
public void start ( ) { running = _BOOL ; startTimeMillis = System . currentTimeMillis ( ) ; thread = new Thread ( this , THREAD_NAME_PREFIX + getPort ( ) ) ; thread . start ( ) ; }
public void start ( ) { running = _BOOL ; startTimeMillis = System . currentTimeMillis ( ) ; thread = new Thread ( this , THREAD_NAME_PREFIX + getPort ( ) ) ; thread . start ( ) ; }
public void start ( ) { running = _BOOL ; startTimeMillis = System . currentTimeMillis ( ) ; thread = new Thread ( this , THREAD_NAME_PREFIX + getPort ( ) ) ; thread . start ( ) ; }
public void start ( ) { running = _BOOL ; startTimeMillis = System . currentTimeMillis ( ) ; thread = new Thread ( this , THREAD_NAME_PREFIX + getPort ( ) ) ; thread . start ( ) ; }
private int addFilteredSubItems ( List < T > values , T item ) { if ( isExpandable ( item ) ) { IExpandable expandable = ( IExpandable ) item ; if ( hasSubItems ( expandable ) ) { List < T > filteredSubItems = new ArrayList < > ( ) ; List < T > subItems = expandable . getSubItems ( ) ; for ( T subItem : subItems ) { if ( ! subItem . isHidden ( ) ) filteredSubItems . add ( subItem ) ; } values . addAll ( filteredSubItems ) ; return filteredSubItems . size ( ) ; } } return _NUM ; }
private String listToString ( List roleNames ) { StringBuffer sb = new StringBuffer ( ) ; for ( Iterator i = roleNames . iterator ( ) ; i . hasNext ( ) ; ) { String role = ( String ) i . next ( ) ; if ( sb . length ( ) > _NUM ) { sb . append ( STRING ) ; } sb . append ( getLocalizedString ( role + STRING ) ) ; } return sb . toString ( ) ; }
private String listToString ( List roleNames ) { StringBuffer sb = new StringBuffer ( ) ; for ( Iterator i = roleNames . iterator ( ) ; i . hasNext ( ) ; ) { String role = ( String ) i . next ( ) ; if ( sb . length ( ) > _NUM ) { sb . append ( STRING ) ; } sb . append ( getLocalizedString ( role + STRING ) ) ; } return sb . toString ( ) ; }
public < T > JsonArray < T > createListDtoFromJson ( Reader json , Class < T > dtoInterface ) throws IOException { final DtoProvider < T > dtoProvider = getDtoProvider ( dtoInterface ) ; final List < JsonElement > list ; try { list = gson . fromJson ( json , listTypeCache . get ( JsonElement . class ) ) ; } catch ( JsonSyntaxException e ) { final Throwable cause = e . getCause ( ) ; if ( cause instanceof IOException ) { throw ( IOException ) cause ; } throw e ; } final List < T > result = new ArrayList < > ( list . size ( ) ) ; for ( JsonElement e : list ) { result . add ( dtoProvider . fromJson ( e ) ) ; } return new JsonArrayImpl < > ( result ) ; }
public < T > JsonArray < T > createListDtoFromJson ( Reader json , Class < T > dtoInterface ) throws IOException { final DtoProvider < T > dtoProvider = getDtoProvider ( dtoInterface ) ; final List < JsonElement > list ; try { list = gson . fromJson ( json , listTypeCache . get ( JsonElement . class ) ) ; } catch ( JsonSyntaxException e ) { final Throwable cause = e . getCause ( ) ; if ( cause instanceof IOException ) { throw ( IOException ) cause ; } throw e ; } final List < T > result = new ArrayList < > ( list . size ( ) ) ; for ( JsonElement e : list ) { result . add ( dtoProvider . fromJson ( e ) ) ; } return new JsonArrayImpl < > ( result ) ; }
public void reclaimViews ( List < View > views ) { int childCount = getChildCount ( ) ; RecyclerListener listener = mRecycler . mRecyclerListener ; for ( int i = _NUM ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; PLA_AbsListView . LayoutParams lp = ( PLA_AbsListView . LayoutParams ) child . getLayoutParams ( ) ; if ( lp != null && mRecycler . shouldRecycleViewType ( lp . viewType ) ) { views . add ( child ) ; if ( listener != null ) { listener . onMovedToScrapHeap ( child ) ; } } } mRecycler . reclaimScrapViews ( views ) ; removeAllViewsInLayout ( ) ; }
public void reclaimViews ( List < View > views ) { int childCount = getChildCount ( ) ; RecyclerListener listener = mRecycler . mRecyclerListener ; for ( int i = _NUM ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; PLA_AbsListView . LayoutParams lp = ( PLA_AbsListView . LayoutParams ) child . getLayoutParams ( ) ; if ( lp != null && mRecycler . shouldRecycleViewType ( lp . viewType ) ) { views . add ( child ) ; if ( listener != null ) { listener . onMovedToScrapHeap ( child ) ; } } } mRecycler . reclaimScrapViews ( views ) ; removeAllViewsInLayout ( ) ; }
public void reclaimViews ( List < View > views ) { int childCount = getChildCount ( ) ; RecyclerListener listener = mRecycler . mRecyclerListener ; for ( int i = _NUM ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; PLA_AbsListView . LayoutParams lp = ( PLA_AbsListView . LayoutParams ) child . getLayoutParams ( ) ; if ( lp != null && mRecycler . shouldRecycleViewType ( lp . viewType ) ) { views . add ( child ) ; if ( listener != null ) { listener . onMovedToScrapHeap ( child ) ; } } } mRecycler . reclaimScrapViews ( views ) ; removeAllViewsInLayout ( ) ; }
public static int findNextConsistencyId ( Database conn , Table ct ) throws Exception { int id = _NUM ; try { Statement st ; st = conn . createStatement ( ) ; ResultSet rs = st . executeQuery ( STRING + ConsistencyTable . idColumnName + STRING + ct . getSchema ( ) + STRING + ct . getName ( ) ) ; if ( rs . next ( ) ) { id = rs . getInt ( _NUM ) + _NUM ; } rs . close ( ) ; st . close ( ) ; } catch ( Exception e ) { logger . error ( STRING + e . getMessage ( ) ) ; throw e ; } return id ; }
public static int findNextConsistencyId ( Database conn , Table ct ) throws Exception { int id = _NUM ; try { Statement st ; st = conn . createStatement ( ) ; ResultSet rs = st . executeQuery ( STRING + ConsistencyTable . idColumnName + STRING + ct . getSchema ( ) + STRING + ct . getName ( ) ) ; if ( rs . next ( ) ) { id = rs . getInt ( _NUM ) + _NUM ; } rs . close ( ) ; st . close ( ) ; } catch ( Exception e ) { logger . error ( STRING + e . getMessage ( ) ) ; throw e ; } return id ; }
public Session ( ) { long uptime = System . currentTimeMillis ( ) ; HandlerThread thread = new HandlerThread ( STRING ) ; thread . start ( ) ; mHandler = new Handler ( thread . getLooper ( ) ) ; mMainHandler = new Handler ( Looper . getMainLooper ( ) ) ; mTimestamp = ( uptime / _NUM ) << _NUM & ( ( ( uptime - ( ( uptime / _NUM ) * _NUM ) ) > > _NUM ) / _NUM ) ; mOrigin = STRING ; }
public Session ( ) { long uptime = System . currentTimeMillis ( ) ; HandlerThread thread = new HandlerThread ( STRING ) ; thread . start ( ) ; mHandler = new Handler ( thread . getLooper ( ) ) ; mMainHandler = new Handler ( Looper . getMainLooper ( ) ) ; mTimestamp = ( uptime / _NUM ) << _NUM & ( ( ( uptime - ( ( uptime / _NUM ) * _NUM ) ) > > _NUM ) / _NUM ) ; mOrigin = STRING ; }
public synchronized void removeThresholdDataListener ( ThresholdDataListener cl ) { m_thresholdListeners . remove ( cl ) ; }
public DistributedLogConfiguration ( ) { super ( ) ; addConfiguration ( new SystemConfiguration ( ) ) ; }
public java . lang . StringBuilder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STRING ; } int min = string . length ( ) ; if ( min != _NUM ) { move ( min , index ) ; string . getChars ( _NUM , min , value , index ) ; count += min ; } return this ; }
public java . lang . StringBuilder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STRING ; } int min = string . length ( ) ; if ( min != _NUM ) { move ( min , index ) ; string . getChars ( _NUM , min , value , index ) ; count += min ; } return this ; }
public java . lang . StringBuilder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STRING ; } int min = string . length ( ) ; if ( min != _NUM ) { move ( min , index ) ; string . getChars ( _NUM , min , value , index ) ; count += min ; } return this ; }
public java . lang . StringBuilder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STRING ; } int min = string . length ( ) ; if ( min != _NUM ) { move ( min , index ) ; string . getChars ( _NUM , min , value , index ) ; count += min ; } return this ; }
public java . lang . StringBuilder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STRING ; } int min = string . length ( ) ; if ( min != _NUM ) { move ( min , index ) ; string . getChars ( _NUM , min , value , index ) ; count += min ; } return this ; }
public java . lang . StringBuilder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STRING ; } int min = string . length ( ) ; if ( min != _NUM ) { move ( min , index ) ; string . getChars ( _NUM , min , value , index ) ; count += min ; } return this ; }
public java . lang . StringBuilder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STRING ; } int min = string . length ( ) ; if ( min != _NUM ) { move ( min , index ) ; string . getChars ( _NUM , min , value , index ) ; count += min ; } return this ; }
public java . lang . StringBuilder insert ( int index , java . lang . String string ) { if ( string == null ) { string = STRING ; } int min = string . length ( ) ; if ( min != _NUM ) { move ( min , index ) ; string . getChars ( _NUM , min , value , index ) ; count += min ; } return this ; }
public void combine ( Stats o ) { max = Math . max ( max , o . max ) ; min = Math . min ( min , o . min ) ; m = m * ( n / ( double ) ( n + o . n ) ) + o . m * ( o . n / ( double ) ( n + o . n ) ) ; s = Double . NaN ; n += o . n ; }
public void combine ( Stats o ) { max = Math . max ( max , o . max ) ; min = Math . min ( min , o . min ) ; m = m * ( n / ( double ) ( n + o . n ) ) + o . m * ( o . n / ( double ) ( n + o . n ) ) ; s = Double . NaN ; n += o . n ; }
public void combine ( Stats o ) { max = Math . max ( max , o . max ) ; min = Math . min ( min , o . min ) ; m = m * ( n / ( double ) ( n + o . n ) ) + o . m * ( o . n / ( double ) ( n + o . n ) ) ; s = Double . NaN ; n += o . n ; }
public void combine ( Stats o ) { max = Math . max ( max , o . max ) ; min = Math . min ( min , o . min ) ; m = m * ( n / ( double ) ( n + o . n ) ) + o . m * ( o . n / ( double ) ( n + o . n ) ) ; s = Double . NaN ; n += o . n ; }
public static String dump ( final ByteBuffer bytes ) { bytes . rewind ( ) ; final int columns = _NUM ; final StringBuilder builder = new StringBuilder ( ) ; int i = _NUM ; while ( bytes . hasRemaining ( ) ) { if ( ( i % columns ) != _NUM ) { builder . append ( STRING ) ; } else if ( i >= columns ) { builder . append ( String . format ( STRING ) ) ; } builder . append ( String . format ( STRING , bytes . get ( ) ) ) ; i ++ ; } return builder . toString ( ) ; }
public Voice ( ) { utteranceProcessors = Collections . synchronizedList ( new ArrayList ( ) ) ; features = new FeatureSetImpl ( ) ; featureProcessors = new HashMap ( ) ; try { nominalRate = Float . parseFloat ( Utilities . getProperty ( PROP_PREFIX + STRING , STRING ) ) ; pitch = Float . parseFloat ( Utilities . getProperty ( PROP_PREFIX + STRING , STRING ) ) ; range = Float . parseFloat ( Utilities . getProperty ( PROP_PREFIX + STRING , STRING ) ) ; volume = Float . parseFloat ( Utilities . getProperty ( PROP_PREFIX + STRING , STRING ) ) ; } catch ( SecurityException se ) { } outputQueue = null ; audioPlayer = null ; defaultAudioPlayer = null ; }
public Voice ( ) { utteranceProcessors = Collections . synchronizedList ( new ArrayList ( ) ) ; features = new FeatureSetImpl ( ) ; featureProcessors = new HashMap ( ) ; try { nominalRate = Float . parseFloat ( Utilities . getProperty ( PROP_PREFIX + STRING , STRING ) ) ; pitch = Float . parseFloat ( Utilities . getProperty ( PROP_PREFIX + STRING , STRING ) ) ; range = Float . parseFloat ( Utilities . getProperty ( PROP_PREFIX + STRING , STRING ) ) ; volume = Float . parseFloat ( Utilities . getProperty ( PROP_PREFIX + STRING , STRING ) ) ; } catch ( SecurityException se ) { } outputQueue = null ; audioPlayer = null ; defaultAudioPlayer = null ; }
public Voice ( ) { utteranceProcessors = Collections . synchronizedList ( new ArrayList ( ) ) ; features = new FeatureSetImpl ( ) ; featureProcessors = new HashMap ( ) ; try { nominalRate = Float . parseFloat ( Utilities . getProperty ( PROP_PREFIX + STRING , STRING ) ) ; pitch = Float . parseFloat ( Utilities . getProperty ( PROP_PREFIX + STRING , STRING ) ) ; range = Float . parseFloat ( Utilities . getProperty ( PROP_PREFIX + STRING , STRING ) ) ; volume = Float . parseFloat ( Utilities . getProperty ( PROP_PREFIX + STRING , STRING ) ) ; } catch ( SecurityException se ) { } outputQueue = null ; audioPlayer = null ; defaultAudioPlayer = null ; }
public Voice ( ) { utteranceProcessors = Collections . synchronizedList ( new ArrayList ( ) ) ; features = new FeatureSetImpl ( ) ; featureProcessors = new HashMap ( ) ; try { nominalRate = Float . parseFloat ( Utilities . getProperty ( PROP_PREFIX + STRING , STRING ) ) ; pitch = Float . parseFloat ( Utilities . getProperty ( PROP_PREFIX + STRING , STRING ) ) ; range = Float . parseFloat ( Utilities . getProperty ( PROP_PREFIX + STRING , STRING ) ) ; volume = Float . parseFloat ( Utilities . getProperty ( PROP_PREFIX + STRING , STRING ) ) ; } catch ( SecurityException se ) { } outputQueue = null ; audioPlayer = null ; defaultAudioPlayer = null ; }
private static int annotatedFieldsNumber ( Class < ? > aClass ) { int count = _NUM ; for ( Field it : aClass . getDeclaredFields ( ) ) if ( it . getAnnotation ( JMap . class ) != null ) count ++ ; return count ; }
private static int annotatedFieldsNumber ( Class < ? > aClass ) { int count = _NUM ; for ( Field it : aClass . getDeclaredFields ( ) ) if ( it . getAnnotation ( JMap . class ) != null ) count ++ ; return count ; }
public double entropyNMIMin ( ) { return ( entropyMutualInformation ( ) / Math . min ( entropyFirst ( ) , entropySecond ( ) ) ) ; }
public WordDefinition ( String sWord ) { Word = new String ( sWord . toLowerCase ( ) ) ; Hash = hashWord ( sWord ) ; }
SentenceFilteredGrammar ( AbstractGrammar baseGrammar , Sentence sentence ) { super ( OwnerMap . getOwner ( baseGrammar . getOwner ( ) ) , baseGrammar . joshuaConfiguration , baseGrammar . getSpanLimit ( ) ) ; this . baseGrammar = baseGrammar ; this . sentence = sentence ; this . tokens = sentence . getWordIDs ( ) ; int origCount = getNumRules ( baseGrammar . getTrieRoot ( ) ) ; long startTime = System . currentTimeMillis ( ) ; this . filteredTrie = filter ( baseGrammar . getTrieRoot ( ) ) ; int filteredCount = getNumRules ( ) ; float seconds = ( System . currentTimeMillis ( ) - startTime ) / _NUM ; LOG . debug ( STRING , sentence . id ( ) , origCount , filteredCount , seconds ) ; }
SentenceFilteredGrammar ( AbstractGrammar baseGrammar , Sentence sentence ) { super ( OwnerMap . getOwner ( baseGrammar . getOwner ( ) ) , baseGrammar . joshuaConfiguration , baseGrammar . getSpanLimit ( ) ) ; this . baseGrammar = baseGrammar ; this . sentence = sentence ; this . tokens = sentence . getWordIDs ( ) ; int origCount = getNumRules ( baseGrammar . getTrieRoot ( ) ) ; long startTime = System . currentTimeMillis ( ) ; this . filteredTrie = filter ( baseGrammar . getTrieRoot ( ) ) ; int filteredCount = getNumRules ( ) ; float seconds = ( System . currentTimeMillis ( ) - startTime ) / _NUM ; LOG . debug ( STRING , sentence . id ( ) , origCount , filteredCount , seconds ) ; }
SentenceFilteredGrammar ( AbstractGrammar baseGrammar , Sentence sentence ) { super ( OwnerMap . getOwner ( baseGrammar . getOwner ( ) ) , baseGrammar . joshuaConfiguration , baseGrammar . getSpanLimit ( ) ) ; this . baseGrammar = baseGrammar ; this . sentence = sentence ; this . tokens = sentence . getWordIDs ( ) ; int origCount = getNumRules ( baseGrammar . getTrieRoot ( ) ) ; long startTime = System . currentTimeMillis ( ) ; this . filteredTrie = filter ( baseGrammar . getTrieRoot ( ) ) ; int filteredCount = getNumRules ( ) ; float seconds = ( System . currentTimeMillis ( ) - startTime ) / _NUM ; LOG . debug ( STRING , sentence . id ( ) , origCount , filteredCount , seconds ) ; }
SentenceFilteredGrammar ( AbstractGrammar baseGrammar , Sentence sentence ) { super ( OwnerMap . getOwner ( baseGrammar . getOwner ( ) ) , baseGrammar . joshuaConfiguration , baseGrammar . getSpanLimit ( ) ) ; this . baseGrammar = baseGrammar ; this . sentence = sentence ; this . tokens = sentence . getWordIDs ( ) ; int origCount = getNumRules ( baseGrammar . getTrieRoot ( ) ) ; long startTime = System . currentTimeMillis ( ) ; this . filteredTrie = filter ( baseGrammar . getTrieRoot ( ) ) ; int filteredCount = getNumRules ( ) ; float seconds = ( System . currentTimeMillis ( ) - startTime ) / _NUM ; LOG . debug ( STRING , sentence . id ( ) , origCount , filteredCount , seconds ) ; }
@ Override public TaskList createFileSystems ( FileSystemParam param , Project project , VirtualArray varray , VirtualPool vpool , TenantOrg tenantOrg , DataObject . Flag [ ] flags , List < Recommendation > recommendations , TaskList taskList , String taskId , VirtualPoolCapabilityValuesWrapper vpoolCapabilities ) throws InternalException { List < FileShare > fileList = null ; List < FileShare > fileShares = new ArrayList < FileShare > ( ) ; fileList = prepareFileSystems ( param , taskId , taskList , project , tenantOrg , flags , varray , vpool , recommendations , vpoolCapabilities , _BOOL ) ; fileShares . addAll ( fileList ) ; String suggestedNativeFsId = param . getFsId ( ) == null ? STRING : param . getFsId ( ) ; final List < FileDescriptor > fileDescriptors = prepareFileDescriptors ( fileShares , vpoolCapabilities , suggestedNativeFsId ) ; final FileOrchestrationController controller = getController ( FileOrchestrationController . class , FileOrchestrationController . FILE_ORCHESTRATION_DEVICE ) ; try { controller . createFileSystems ( fileDescriptors , taskId ) ; } catch ( InternalException e ) { _log . error ( STRING , e ) ; failFileShareCreateRequest ( taskId , taskList , fileShares , e . getMessage ( ) ) ; throw e ; } catch ( Exception e ) { _log . error ( STRING , e ) ; failFileShareCreateRequest ( taskId , taskList , fileShares , e . getMessage ( ) ) ; throw e ; } return taskList ; }
@ Override public TaskList createFileSystems ( FileSystemParam param , Project project , VirtualArray varray , VirtualPool vpool , TenantOrg tenantOrg , DataObject . Flag [ ] flags , List < Recommendation > recommendations , TaskList taskList , String taskId , VirtualPoolCapabilityValuesWrapper vpoolCapabilities ) throws InternalException { List < FileShare > fileList = null ; List < FileShare > fileShares = new ArrayList < FileShare > ( ) ; fileList = prepareFileSystems ( param , taskId , taskList , project , tenantOrg , flags , varray , vpool , recommendations , vpoolCapabilities , _BOOL ) ; fileShares . addAll ( fileList ) ; String suggestedNativeFsId = param . getFsId ( ) == null ? STRING : param . getFsId ( ) ; final List < FileDescriptor > fileDescriptors = prepareFileDescriptors ( fileShares , vpoolCapabilities , suggestedNativeFsId ) ; final FileOrchestrationController controller = getController ( FileOrchestrationController . class , FileOrchestrationController . FILE_ORCHESTRATION_DEVICE ) ; try { controller . createFileSystems ( fileDescriptors , taskId ) ; } catch ( InternalException e ) { _log . error ( STRING , e ) ; failFileShareCreateRequest ( taskId , taskList , fileShares , e . getMessage ( ) ) ; throw e ; } catch ( Exception e ) { _log . error ( STRING , e ) ; failFileShareCreateRequest ( taskId , taskList , fileShares , e . getMessage ( ) ) ; throw e ; } return taskList ; }
private void startAuthenticationActivity ( ) { Intent intent = new Intent ( ServerDetails . this , AuthenticationActivity . class ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; startActivity ( intent ) ; }
public static long string2long ( String s ) { s = s . trim ( ) ; final int lastpos = s . length ( ) - _NUM ; final char lastchar = s . charAt ( lastpos ) ; if ( Character . isDigit ( lastchar ) ) return Long . parseLong ( s ) ; else { long prefix = TraditionalBinaryPrefix . valueOf ( lastchar ) . value ; long num = Long . parseLong ( s . substring ( _NUM , lastpos ) ) ; if ( num > ( Long . MAX_VALUE / prefix ) || num < ( Long . MIN_VALUE / prefix ) ) { throw new IllegalArgumentException ( s + STRING ) ; } return num * prefix ; } }
public static long string2long ( String s ) { s = s . trim ( ) ; final int lastpos = s . length ( ) - _NUM ; final char lastchar = s . charAt ( lastpos ) ; if ( Character . isDigit ( lastchar ) ) return Long . parseLong ( s ) ; else { long prefix = TraditionalBinaryPrefix . valueOf ( lastchar ) . value ; long num = Long . parseLong ( s . substring ( _NUM , lastpos ) ) ; if ( num > ( Long . MAX_VALUE / prefix ) || num < ( Long . MIN_VALUE / prefix ) ) { throw new IllegalArgumentException ( s + STRING ) ; } return num * prefix ; } }
public static long string2long ( String s ) { s = s . trim ( ) ; final int lastpos = s . length ( ) - _NUM ; final char lastchar = s . charAt ( lastpos ) ; if ( Character . isDigit ( lastchar ) ) return Long . parseLong ( s ) ; else { long prefix = TraditionalBinaryPrefix . valueOf ( lastchar ) . value ; long num = Long . parseLong ( s . substring ( _NUM , lastpos ) ) ; if ( num > ( Long . MAX_VALUE / prefix ) || num < ( Long . MIN_VALUE / prefix ) ) { throw new IllegalArgumentException ( s + STRING ) ; } return num * prefix ; } }
protected void internalFrame ( DockWrapper wrapper ) { freeWrapper ( wrapper ) ; internalFrameWrappers . add ( wrapper ) ; wrapper . makeInternalFrame ( ) ; }
public static PublicKey generatePublicKey ( String encodedPublicKey ) { try { byte [ ] decodedKey = Base64 . decode ( encodedPublicKey , Base64 . DEFAULT ) ; KeyFactory keyFactory = KeyFactory . getInstance ( KEY_FACTORY_ALGORITHM ) ; return keyFactory . generatePublic ( new X509EncodedKeySpec ( decodedKey ) ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } catch ( InvalidKeySpecException e ) { Log . e ( TAG , STRING ) ; throw new IllegalArgumentException ( e ) ; } catch ( IllegalArgumentException e ) { Log . e ( TAG , STRING ) ; throw e ; } }
public static PublicKey generatePublicKey ( String encodedPublicKey ) { try { byte [ ] decodedKey = Base64 . decode ( encodedPublicKey , Base64 . DEFAULT ) ; KeyFactory keyFactory = KeyFactory . getInstance ( KEY_FACTORY_ALGORITHM ) ; return keyFactory . generatePublic ( new X509EncodedKeySpec ( decodedKey ) ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } catch ( InvalidKeySpecException e ) { Log . e ( TAG , STRING ) ; throw new IllegalArgumentException ( e ) ; } catch ( IllegalArgumentException e ) { Log . e ( TAG , STRING ) ; throw e ; } }
public static PublicKey generatePublicKey ( String encodedPublicKey ) { try { byte [ ] decodedKey = Base64 . decode ( encodedPublicKey , Base64 . DEFAULT ) ; KeyFactory keyFactory = KeyFactory . getInstance ( KEY_FACTORY_ALGORITHM ) ; return keyFactory . generatePublic ( new X509EncodedKeySpec ( decodedKey ) ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } catch ( InvalidKeySpecException e ) { Log . e ( TAG , STRING ) ; throw new IllegalArgumentException ( e ) ; } catch ( IllegalArgumentException e ) { Log . e ( TAG , STRING ) ; throw e ; } }
private void emitImplicitConversion ( BasicType ptype , Class < ? > pclass , Object arg ) { assert ( basicType ( pclass ) == ptype ) ; if ( pclass == ptype . basicTypeClass ( ) && ptype != L_TYPE ) return ; switch ( ptype ) { case L_TYPE : if ( VerifyType . isNullConversion ( Object . class , pclass , _BOOL ) ) { if ( PROFILE_LEVEL > _NUM ) emitReferenceCast ( Object . class , arg ) ; return ; } emitReferenceCast ( pclass , arg ) ; return ; case I_TYPE : if ( ! VerifyType . isNullConversion ( int . class , pclass , _BOOL ) ) emitPrimCast ( ptype . basicTypeWrapper ( ) , Wrapper . forPrimitiveType ( pclass ) ) ; return ; } throw newInternalError ( STRING + ptype + STRING + pclass ) ; }
public void addArgument ( final Argument argument ) { if ( ! args . contains ( argument ) ) { args . add ( argument ) ; } }
public Map < String , String > loadInstalledCodenvyProperties ( InstallType installType ) throws IOException { Map < String , String > properties = new HashMap < > ( ) ; Iterator < Path > propertiesFiles = getCodenvyPropertiesFiles ( installType ) ; while ( propertiesFiles . hasNext ( ) ) { Path file = propertiesFiles . next ( ) ; try { properties . putAll ( doLoadInstalledCodenvyProperties ( file ) ) ; } catch ( IOException e ) { throw new ConfigException ( format ( STRING , e . getMessage ( ) ) , e ) ; } } return properties ; }
public Map < String , String > loadInstalledCodenvyProperties ( InstallType installType ) throws IOException { Map < String , String > properties = new HashMap < > ( ) ; Iterator < Path > propertiesFiles = getCodenvyPropertiesFiles ( installType ) ; while ( propertiesFiles . hasNext ( ) ) { Path file = propertiesFiles . next ( ) ; try { properties . putAll ( doLoadInstalledCodenvyProperties ( file ) ) ; } catch ( IOException e ) { throw new ConfigException ( format ( STRING , e . getMessage ( ) ) , e ) ; } } return properties ; }
public Map < String , String > loadInstalledCodenvyProperties ( InstallType installType ) throws IOException { Map < String , String > properties = new HashMap < > ( ) ; Iterator < Path > propertiesFiles = getCodenvyPropertiesFiles ( installType ) ; while ( propertiesFiles . hasNext ( ) ) { Path file = propertiesFiles . next ( ) ; try { properties . putAll ( doLoadInstalledCodenvyProperties ( file ) ) ; } catch ( IOException e ) { throw new ConfigException ( format ( STRING , e . getMessage ( ) ) , e ) ; } } return properties ; }
public Map < String , String > loadInstalledCodenvyProperties ( InstallType installType ) throws IOException { Map < String , String > properties = new HashMap < > ( ) ; Iterator < Path > propertiesFiles = getCodenvyPropertiesFiles ( installType ) ; while ( propertiesFiles . hasNext ( ) ) { Path file = propertiesFiles . next ( ) ; try { properties . putAll ( doLoadInstalledCodenvyProperties ( file ) ) ; } catch ( IOException e ) { throw new ConfigException ( format ( STRING , e . getMessage ( ) ) , e ) ; } } return properties ; }
public void disconnectFromBeanContext ( ) throws PropertyVetoException { BeanContext bc = getBeanContext ( ) ; if ( bc != null ) { bc . removeBeanContextMembershipListener ( this ) ; beanContextChildSupport . setBeanContext ( null ) ; } }
public void disconnectFromBeanContext ( ) throws PropertyVetoException { BeanContext bc = getBeanContext ( ) ; if ( bc != null ) { bc . removeBeanContextMembershipListener ( this ) ; beanContextChildSupport . setBeanContext ( null ) ; } }
public static TextNode valueOf ( String v ) { if ( v == null ) { return null ; } if ( v . length ( ) == _NUM ) { return EMPTY_STRING_NODE ; } return new TextNode ( v ) ; }
public static TextNode valueOf ( String v ) { if ( v == null ) { return null ; } if ( v . length ( ) == _NUM ) { return EMPTY_STRING_NODE ; } return new TextNode ( v ) ; }
public Iterator iterator ( ) { sortEdges ( ) ; return outEdges . iterator ( ) ; }
public Iterator iterator ( ) { sortEdges ( ) ; return outEdges . iterator ( ) ; }
public Iterator iterator ( ) { sortEdges ( ) ; return outEdges . iterator ( ) ; }
public String mutateLangModel ( final String input ) { if ( input . length ( ) == _NUM ) { return input ; } int startPoint = ( int ) ( Randomness . nextDouble ( ) * ( input . length ( ) ) ) ; int remainingLength = ( int ) Math . round ( Randomness . nextDouble ( ) * ( input . length ( ) - startPoint ) ) ; if ( remainingLength == _NUM ) { return input ; } String output = input . substring ( _NUM , startPoint ) ; String replacementChunk = generateRandomStringFromModelWithExactLength ( remainingLength , STRING + input . charAt ( startPoint ) ) ; output += replacementChunk ; output += input . substring ( startPoint + remainingLength , input . length ( ) ) ; return output ; }
public String mutateLangModel ( final String input ) { if ( input . length ( ) == _NUM ) { return input ; } int startPoint = ( int ) ( Randomness . nextDouble ( ) * ( input . length ( ) ) ) ; int remainingLength = ( int ) Math . round ( Randomness . nextDouble ( ) * ( input . length ( ) - startPoint ) ) ; if ( remainingLength == _NUM ) { return input ; } String output = input . substring ( _NUM , startPoint ) ; String replacementChunk = generateRandomStringFromModelWithExactLength ( remainingLength , STRING + input . charAt ( startPoint ) ) ; output += replacementChunk ; output += input . substring ( startPoint + remainingLength , input . length ( ) ) ; return output ; }
public String mutateLangModel ( final String input ) { if ( input . length ( ) == _NUM ) { return input ; } int startPoint = ( int ) ( Randomness . nextDouble ( ) * ( input . length ( ) ) ) ; int remainingLength = ( int ) Math . round ( Randomness . nextDouble ( ) * ( input . length ( ) - startPoint ) ) ; if ( remainingLength == _NUM ) { return input ; } String output = input . substring ( _NUM , startPoint ) ; String replacementChunk = generateRandomStringFromModelWithExactLength ( remainingLength , STRING + input . charAt ( startPoint ) ) ; output += replacementChunk ; output += input . substring ( startPoint + remainingLength , input . length ( ) ) ; return output ; }
public String mutateLangModel ( final String input ) { if ( input . length ( ) == _NUM ) { return input ; } int startPoint = ( int ) ( Randomness . nextDouble ( ) * ( input . length ( ) ) ) ; int remainingLength = ( int ) Math . round ( Randomness . nextDouble ( ) * ( input . length ( ) - startPoint ) ) ; if ( remainingLength == _NUM ) { return input ; } String output = input . substring ( _NUM , startPoint ) ; String replacementChunk = generateRandomStringFromModelWithExactLength ( remainingLength , STRING + input . charAt ( startPoint ) ) ; output += replacementChunk ; output += input . substring ( startPoint + remainingLength , input . length ( ) ) ; return output ; }
public String mutateLangModel ( final String input ) { if ( input . length ( ) == _NUM ) { return input ; } int startPoint = ( int ) ( Randomness . nextDouble ( ) * ( input . length ( ) ) ) ; int remainingLength = ( int ) Math . round ( Randomness . nextDouble ( ) * ( input . length ( ) - startPoint ) ) ; if ( remainingLength == _NUM ) { return input ; } String output = input . substring ( _NUM , startPoint ) ; String replacementChunk = generateRandomStringFromModelWithExactLength ( remainingLength , STRING + input . charAt ( startPoint ) ) ; output += replacementChunk ; output += input . substring ( startPoint + remainingLength , input . length ( ) ) ; return output ; }
public String mutateLangModel ( final String input ) { if ( input . length ( ) == _NUM ) { return input ; } int startPoint = ( int ) ( Randomness . nextDouble ( ) * ( input . length ( ) ) ) ; int remainingLength = ( int ) Math . round ( Randomness . nextDouble ( ) * ( input . length ( ) - startPoint ) ) ; if ( remainingLength == _NUM ) { return input ; } String output = input . substring ( _NUM , startPoint ) ; String replacementChunk = generateRandomStringFromModelWithExactLength ( remainingLength , STRING + input . charAt ( startPoint ) ) ; output += replacementChunk ; output += input . substring ( startPoint + remainingLength , input . length ( ) ) ; return output ; }
protected Object fetch ( Object key ) { synchronized ( lock ) { Thread currentThread = Thread . currentThread ( ) ; if ( busyThread == currentThread ) { throw new IllegalStateException ( STRING ) ; } while ( busyThread != null ) { try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } busyThread = currentThread ; } try { return fetchSerial ( key ) ; } finally { synchronized ( lock ) { busyThread = null ; lock . notify ( ) ; } } }
protected Object fetch ( Object key ) { synchronized ( lock ) { Thread currentThread = Thread . currentThread ( ) ; if ( busyThread == currentThread ) { throw new IllegalStateException ( STRING ) ; } while ( busyThread != null ) { try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } busyThread = currentThread ; } try { return fetchSerial ( key ) ; } finally { synchronized ( lock ) { busyThread = null ; lock . notify ( ) ; } } }
protected Object fetch ( Object key ) { synchronized ( lock ) { Thread currentThread = Thread . currentThread ( ) ; if ( busyThread == currentThread ) { throw new IllegalStateException ( STRING ) ; } while ( busyThread != null ) { try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } busyThread = currentThread ; } try { return fetchSerial ( key ) ; } finally { synchronized ( lock ) { busyThread = null ; lock . notify ( ) ; } } }
private InstanceState checkIn ( ) { final InstanceState state ; try { logger . debug ( STRING , instanceId ) ; state = getInstanceState ( instanceId ) ; } catch ( ResourceException e ) { logger . info ( STRING , instanceId ) ; return null ; } try { if ( firstCheckin ) { state . updateStartup ( ) ; state . clearShutdown ( ) ; firstCheckin = _BOOL ; } switch ( state . getState ( ) ) { case InstanceState . STATE_RUNNING : state . updateTimestamp ( ) ; break ; case InstanceState . STATE_DOWN : state . setState ( InstanceState . STATE_RUNNING ) ; logger . debug ( STRING , instanceId , InstanceState . STATE_DOWN , InstanceState . STATE_RUNNING ) ; state . updateTimestamp ( ) ; break ; case InstanceState . STATE_PROCESSING_DOWN : logger . debug ( STRING , instanceId , state . getState ( ) ) ; return state ; } updateInstanceState ( instanceId , state ) ; logger . debug ( STRING , instanceId ) ; } catch ( ResourceException e ) { if ( e . getCode ( ) != ResourceException . CONFLICT ) { logger . warn ( STRING , e ) ; } else { logger . info ( STRING , state . getState ( ) ) ; return null ; } } return state ; }
public String read ( final int length ) { if ( length > this . length || pos + length > this . length ) { throw new StringIndexOutOfBoundsException ( ) ; } final String substring = source . substring ( pos , pos + length ) ; pos += length ; return substring ; }
public String read ( final int length ) { if ( length > this . length || pos + length > this . length ) { throw new StringIndexOutOfBoundsException ( ) ; } final String substring = source . substring ( pos , pos + length ) ; pos += length ; return substring ; }
public String read ( final int length ) { if ( length > this . length || pos + length > this . length ) { throw new StringIndexOutOfBoundsException ( ) ; } final String substring = source . substring ( pos , pos + length ) ; pos += length ; return substring ; }
public String read ( final int length ) { if ( length > this . length || pos + length > this . length ) { throw new StringIndexOutOfBoundsException ( ) ; } final String substring = source . substring ( pos , pos + length ) ; pos += length ; return substring ; }
public String read ( final int length ) { if ( length > this . length || pos + length > this . length ) { throw new StringIndexOutOfBoundsException ( ) ; } final String substring = source . substring ( pos , pos + length ) ; pos += length ; return substring ; }
public String read ( final int length ) { if ( length > this . length || pos + length > this . length ) { throw new StringIndexOutOfBoundsException ( ) ; } final String substring = source . substring ( pos , pos + length ) ; pos += length ; return substring ; }
public String read ( final int length ) { if ( length > this . length || pos + length > this . length ) { throw new StringIndexOutOfBoundsException ( ) ; } final String substring = source . substring ( pos , pos + length ) ; pos += length ; return substring ; }
@ Override public int showDialog ( Component parent , String approveButtonText ) { if ( m_DialogType == UNHANDLED_DIALOG ) throw new IllegalStateException ( STRING ) ; else return super . showDialog ( parent , approveButtonText ) ; }
public void writeLogln ( String logdata ) { writeLog ( logdata + System . getProperty ( STRING ) ) ; }
private static String stripAppleSpanFromMarkup ( String markup ) { StringBuilder stripped = new StringBuilder ( markup ) ; int prefixBegIdx = stripped . indexOf ( APPLE_SPAN_PREFIX ) ; while ( prefixBegIdx >= _NUM ) { int prefixEndIdx = stripped . indexOf ( STRING , prefixBegIdx ) + _NUM ; stripped . replace ( prefixBegIdx , prefixEndIdx , STRING ) ; int suffixBegIdx = stripped . lastIndexOf ( APPLE_SPAN_SUFFIX ) ; int suffixEndIdx = suffixBegIdx + APPLE_SPAN_SUFFIX . length ( ) ; stripped . replace ( suffixBegIdx , suffixEndIdx , STRING ) ; prefixBegIdx = stripped . indexOf ( APPLE_SPAN_PREFIX ) ; } return stripped . toString ( ) ; }
@ Override public long skip ( long bytes ) throws IOException { if ( closed ) { throw new FileUploadException ( ItemSkippedException ) ; } int av = available ( ) ; if ( av == _NUM ) { av = makeAvailable ( ) ; if ( av == _NUM ) { return _NUM ; } } long res = Math . min ( av , bytes ) ; head += res ; return res ; }
protected < T > ResponseEntity < T > send ( final ClientHttpRequest request , final Class < T > responseType ) { return send ( request , responseType , Collections . < String , Object > emptyMap ( ) ) ; }
protected < T > ResponseEntity < T > send ( final ClientHttpRequest request , final Class < T > responseType ) { return send ( request , responseType , Collections . < String , Object > emptyMap ( ) ) ; }
@ Override public void endRDF ( ) throws RDFHandlerException { logger . info ( STRING ) ; try { statementCache . put ( DONE ) ; } catch ( InterruptedException e ) { throw new RDFHandlerException ( STRING , e ) ; } }
@ Override public void endRDF ( ) throws RDFHandlerException { logger . info ( STRING ) ; try { statementCache . put ( DONE ) ; } catch ( InterruptedException e ) { throw new RDFHandlerException ( STRING , e ) ; } }
@ Override public void endRDF ( ) throws RDFHandlerException { logger . info ( STRING ) ; try { statementCache . put ( DONE ) ; } catch ( InterruptedException e ) { throw new RDFHandlerException ( STRING , e ) ; } }
public Date build ( ) { Calendar cal ; if ( tz != null && lc != null ) cal = Calendar . getInstance ( tz , lc ) ; else if ( tz != null ) cal = Calendar . getInstance ( tz ) ; else if ( lc != null ) cal = Calendar . getInstance ( lc ) ; else cal = Calendar . getInstance ( ) ; cal . set ( Calendar . YEAR , year ) ; cal . set ( Calendar . MONTH , month - _NUM ) ; cal . set ( Calendar . DAY_OF_MONTH , day ) ; cal . set ( Calendar . HOUR_OF_DAY , hour ) ; cal . set ( Calendar . MINUTE , minute ) ; cal . set ( Calendar . SECOND , second ) ; cal . set ( Calendar . MILLISECOND , _NUM ) ; return cal . getTime ( ) ; }
private String buildProvisioningAddress ( ) { String mnc = String . format ( Locale . US , STRING , mRcsSettings . getMobileNetworkCode ( ) ) ; String mcc = String . format ( Locale . US , STRING , mRcsSettings . getMobileCountryCode ( ) ) ; return STRING + mnc + STRING + mcc + STRING ; }
public static void print ( byte b , PrintStream out ) { out . print ( hex ( b ) ) ; }
protected allThreadsData readValues ( allThreadsData values ) { synchronized ( workers ) { int count = workers . size ( ) ; if ( values == null ) { values = new allThreadsData ( ) ; values . setSize ( count ) ; } else if ( values . getSize ( ) != count ) { values . setSize ( count ) ; } int i = _NUM ; final Iterator < WorkerThread > iter = workers . iterator ( ) ; while ( iter . hasNext ( ) && i < values . getSize ( ) ) { WorkerThread worker = ( WorkerThread ) iter . next ( ) ; int index = i ++ ; values . setIterationValue ( index , worker . getIterations ( ) ) ; values . setTotalResponseTimesValue ( index , worker . resetTotalTime ( ) ) ; } } return values ; }
void put ( int fieldNumber , FieldData data ) { int i = binarySearch ( fieldNumber ) ; if ( i >= _NUM ) { mData [ i ] = data ; } else { i = ~ i ; if ( i < mSize && mData [ i ] == DELETED ) { mFieldNumbers [ i ] = fieldNumber ; mData [ i ] = data ; return ; } if ( mGarbage && mSize >= mFieldNumbers . length ) { gc ( ) ; i = ~ binarySearch ( fieldNumber ) ; } if ( mSize >= mFieldNumbers . length ) { int n = idealIntArraySize ( mSize + _NUM ) ; int [ ] nkeys = new int [ n ] ; FieldData [ ] nvalues = new FieldData [ n ] ; System . arraycopy ( mFieldNumbers , _NUM , nkeys , _NUM , mFieldNumbers . length ) ; System . arraycopy ( mData , _NUM , nvalues , _NUM , mData . length ) ; mFieldNumbers = nkeys ; mData = nvalues ; } if ( mSize - i != _NUM ) { System . arraycopy ( mFieldNumbers , i , mFieldNumbers , i + _NUM , mSize - i ) ; System . arraycopy ( mData , i , mData , i + _NUM , mSize - i ) ; } mFieldNumbers [ i ] = fieldNumber ; mData [ i ] = data ; mSize ++ ; } }
void put ( int fieldNumber , FieldData data ) { int i = binarySearch ( fieldNumber ) ; if ( i >= _NUM ) { mData [ i ] = data ; } else { i = ~ i ; if ( i < mSize && mData [ i ] == DELETED ) { mFieldNumbers [ i ] = fieldNumber ; mData [ i ] = data ; return ; } if ( mGarbage && mSize >= mFieldNumbers . length ) { gc ( ) ; i = ~ binarySearch ( fieldNumber ) ; } if ( mSize >= mFieldNumbers . length ) { int n = idealIntArraySize ( mSize + _NUM ) ; int [ ] nkeys = new int [ n ] ; FieldData [ ] nvalues = new FieldData [ n ] ; System . arraycopy ( mFieldNumbers , _NUM , nkeys , _NUM , mFieldNumbers . length ) ; System . arraycopy ( mData , _NUM , nvalues , _NUM , mData . length ) ; mFieldNumbers = nkeys ; mData = nvalues ; } if ( mSize - i != _NUM ) { System . arraycopy ( mFieldNumbers , i , mFieldNumbers , i + _NUM , mSize - i ) ; System . arraycopy ( mData , i , mData , i + _NUM , mSize - i ) ; } mFieldNumbers [ i ] = fieldNumber ; mData [ i ] = data ; mSize ++ ; } }
public void ensureRowVisible ( int row ) { if ( row != - _NUM ) { Rectangle cellRect = getCellRect ( row , _NUM , _BOOL ) ; Rectangle visibleRect = getVisibleRect ( ) ; if ( ! visibleRect . intersects ( cellRect ) ) scrollRectToVisible ( cellRect ) ; } }
private boolean checkRequestedKeyAge ( String keyEntry ) throws NumberFormatException { long requestedTokenKeyTS = Long . parseLong ( keyEntry ) ; long now = System . currentTimeMillis ( ) ; long diff = now - requestedTokenKeyTS ; if ( diff > ( _NUM * _keyRotationIntervalInMsecs ) ) { _log . debug ( STRING , keyEntry ) ; return _BOOL ; } long youngestKey = Long . parseLong ( _cachedTokenKeysBundle . getCurrentKeyEntry ( ) ) ; if ( youngestKey < Long . parseLong ( keyEntry ) ) { _log . debug ( STRING , keyEntry ) ; return _BOOL ; } return _BOOL ; }
private boolean checkRequestedKeyAge ( String keyEntry ) throws NumberFormatException { long requestedTokenKeyTS = Long . parseLong ( keyEntry ) ; long now = System . currentTimeMillis ( ) ; long diff = now - requestedTokenKeyTS ; if ( diff > ( _NUM * _keyRotationIntervalInMsecs ) ) { _log . debug ( STRING , keyEntry ) ; return _BOOL ; } long youngestKey = Long . parseLong ( _cachedTokenKeysBundle . getCurrentKeyEntry ( ) ) ; if ( youngestKey < Long . parseLong ( keyEntry ) ) { _log . debug ( STRING , keyEntry ) ; return _BOOL ; } return _BOOL ; }
private boolean checkRequestedKeyAge ( String keyEntry ) throws NumberFormatException { long requestedTokenKeyTS = Long . parseLong ( keyEntry ) ; long now = System . currentTimeMillis ( ) ; long diff = now - requestedTokenKeyTS ; if ( diff > ( _NUM * _keyRotationIntervalInMsecs ) ) { _log . debug ( STRING , keyEntry ) ; return _BOOL ; } long youngestKey = Long . parseLong ( _cachedTokenKeysBundle . getCurrentKeyEntry ( ) ) ; if ( youngestKey < Long . parseLong ( keyEntry ) ) { _log . debug ( STRING , keyEntry ) ; return _BOOL ; } return _BOOL ; }
private boolean checkRequestedKeyAge ( String keyEntry ) throws NumberFormatException { long requestedTokenKeyTS = Long . parseLong ( keyEntry ) ; long now = System . currentTimeMillis ( ) ; long diff = now - requestedTokenKeyTS ; if ( diff > ( _NUM * _keyRotationIntervalInMsecs ) ) { _log . debug ( STRING , keyEntry ) ; return _BOOL ; } long youngestKey = Long . parseLong ( _cachedTokenKeysBundle . getCurrentKeyEntry ( ) ) ; if ( youngestKey < Long . parseLong ( keyEntry ) ) { _log . debug ( STRING , keyEntry ) ; return _BOOL ; } return _BOOL ; }
private void populateResultListView ( List < BookmarkMatch > ids ) { if ( ids . isEmpty ( ) ) { setUIState ( UIState . EMPTY ) ; } else { setUIState ( UIState . RESULT ) ; mResultList . setAdapter ( new ResultListAdapter ( ids , mDelegate ) ) ; } }
private void populateResultListView ( List < BookmarkMatch > ids ) { if ( ids . isEmpty ( ) ) { setUIState ( UIState . EMPTY ) ; } else { setUIState ( UIState . RESULT ) ; mResultList . setAdapter ( new ResultListAdapter ( ids , mDelegate ) ) ; } }
@ Override public final void addBezierCurveY ( final float x , final float y , final float x3 , final float y3 ) { elements . add ( new QuadCurveTo ( x , y , x3 , y3 ) ) ; currentPos [ _NUM ] = x3 ; currentPos [ _NUM ] = y3 ; }
public String html_tooltip ( String short_txt , String popup_txt ) { String out = STRING ; if ( jquery ) { out = String . format ( STRING , popup_txt , short_txt ) ; } else if ( jqueryMobile ) { String popup = String . format ( STRING + STRING + STRING , popupId , popup_txt ) ; String txt = String . format ( STRING , popupId ++ , short_txt ) ; out = popup + txt ; } return out ; }
public void addFXGLListener ( FXGLListener listener ) { systemListeners . add ( listener ) ; }
public Tasker addTask ( Task task ) { tasks . add ( task ) ; lastAddedTask = task ; return this ; }
public void computeRing ( ) { if ( ring != null ) return ; Coordinate [ ] coord = new Coordinate [ pts . size ( ) ] ; for ( int i = _NUM ; i < pts . size ( ) ; i ++ ) { coord [ i ] = ( Coordinate ) pts . get ( i ) ; } ring = geometryFactory . createLinearRing ( coord ) ; isHole = CGAlgorithms . isCCW ( ring . getCoordinates ( ) ) ; }
public boolean validateMutationFee ( String assessmentNo , BigDecimal paymentAmount ) { boolean validFee = _BOOL ; PropertyMutation propertyMutation = getLatestPropertyMutationByAssesmentNo ( assessmentNo ) ; if ( propertyMutation != null ) { if ( paymentAmount . compareTo ( propertyMutation . getMutationFee ( ) ) > _NUM ) { validFee = _BOOL ; } } else { validFee = _BOOL ; } return validFee ; }
public void updateConfiguration ( @ NotNull Configuration configuration ) { myConfiguration = configuration ; invalidateGraphicsRenderer ( ) ; }
public void updateConfiguration ( @ NotNull Configuration configuration ) { myConfiguration = configuration ; invalidateGraphicsRenderer ( ) ; }
public void updateConfiguration ( @ NotNull Configuration configuration ) { myConfiguration = configuration ; invalidateGraphicsRenderer ( ) ; }
private static void expand2DigitNumber ( String numberString , WordRelation wordRelation , Item tokenItem ) { if ( numberString . charAt ( _NUM ) == STRING ) { if ( numberString . charAt ( _NUM ) == STRING ) { } else { String number = digit2num [ numberString . charAt ( _NUM ) - STRING ] ; wordRelation . addWord ( tokenItem , number ) ; } } else if ( numberString . charAt ( _NUM ) == STRING ) { String number = digit2enty [ numberString . charAt ( _NUM ) - STRING ] ; wordRelation . addWord ( tokenItem , number ) ; } else if ( numberString . charAt ( _NUM ) == STRING ) { String number = digit2teen [ numberString . charAt ( _NUM ) - STRING ] ; wordRelation . addWord ( tokenItem , number ) ; } else { String enty = digit2enty [ numberString . charAt ( _NUM ) - STRING ] ; wordRelation . addWord ( tokenItem , enty ) ; expandDigits ( numberString . substring ( _NUM , numberString . length ( ) ) , wordRelation , tokenItem ) ; } }
private void compress ( BasicBlock block ) { if ( getAncestor ( getAncestor ( block ) ) != null ) { compress ( getAncestor ( block ) ) ; LTDominatorInfo blockInfo = LTDominatorInfo . getInfo ( block , ir ) ; if ( getSemi ( getLabel ( getAncestor ( block ) ) ) < getSemi ( getLabel ( block ) ) ) { blockInfo . setLabel ( getLabel ( getAncestor ( block ) ) ) ; } blockInfo . setAncestor ( getAncestor ( getAncestor ( block ) ) ) ; } }
private void compress ( BasicBlock block ) { if ( getAncestor ( getAncestor ( block ) ) != null ) { compress ( getAncestor ( block ) ) ; LTDominatorInfo blockInfo = LTDominatorInfo . getInfo ( block , ir ) ; if ( getSemi ( getLabel ( getAncestor ( block ) ) ) < getSemi ( getLabel ( block ) ) ) { blockInfo . setLabel ( getLabel ( getAncestor ( block ) ) ) ; } blockInfo . setAncestor ( getAncestor ( getAncestor ( block ) ) ) ; } }
public JaasConfiguration ( String principal , File keytab , String appName ) { this ( principal , keytab , null , null ) ; clientAppName = appName ; serverAppName = null ; }
public JaasConfiguration ( String principal , File keytab , String appName ) { this ( principal , keytab , null , null ) ; clientAppName = appName ; serverAppName = null ; }
static String plurals ( final String s , final AtomicInteger i ) { return i == null ? UNKNOWN + STRING + s + STRING : i . intValue ( ) != _NUM ? i + STRING + s + STRING : STRING + s ; }
static String plurals ( final String s , final AtomicInteger i ) { return i == null ? UNKNOWN + STRING + s + STRING : i . intValue ( ) != _NUM ? i + STRING + s + STRING : STRING + s ; }
static String plurals ( final String s , final AtomicInteger i ) { return i == null ? UNKNOWN + STRING + s + STRING : i . intValue ( ) != _NUM ? i + STRING + s + STRING : STRING + s ; }
static String plurals ( final String s , final AtomicInteger i ) { return i == null ? UNKNOWN + STRING + s + STRING : i . intValue ( ) != _NUM ? i + STRING + s + STRING : STRING + s ; }
public SignalBarrier ( ) { _owner = null ; }
private void toWagonFormat ( IntAndFloatArrayLeafNode node , DataOutputStream out , String extension , PrintWriter pw ) throws IOException { StringBuilder sb = new StringBuilder ( ) ; int data [ ] = node . getIntData ( ) ; float floats [ ] = node . getFloatData ( ) ; sb . append ( STRING ) ; for ( int i = _NUM ; i < data . length ; i ++ ) { sb . append ( STRING + data [ i ] + STRING + floats [ i ] + STRING ) ; if ( i + _NUM != data . length ) { sb . append ( STRING ) ; } } sb . append ( STRING + extension ) ; if ( out != null ) { writeStringToOutput ( sb . toString ( ) , out ) ; } else { } if ( pw != null ) { pw . println ( sb . toString ( ) ) ; } }
private void toWagonFormat ( IntAndFloatArrayLeafNode node , DataOutputStream out , String extension , PrintWriter pw ) throws IOException { StringBuilder sb = new StringBuilder ( ) ; int data [ ] = node . getIntData ( ) ; float floats [ ] = node . getFloatData ( ) ; sb . append ( STRING ) ; for ( int i = _NUM ; i < data . length ; i ++ ) { sb . append ( STRING + data [ i ] + STRING + floats [ i ] + STRING ) ; if ( i + _NUM != data . length ) { sb . append ( STRING ) ; } } sb . append ( STRING + extension ) ; if ( out != null ) { writeStringToOutput ( sb . toString ( ) , out ) ; } else { } if ( pw != null ) { pw . println ( sb . toString ( ) ) ; } }
public static boolean deleteFiles ( final File targetDir ) { if ( targetDir == null || ! targetDir . isDirectory ( ) ) { Log . e ( FileUtils . class , STRING ) ; return _BOOL ; } boolean isDeleted = _BOOL ; final File [ ] filesList = targetDir . listFiles ( ) ; for ( File file2Delete : filesList ) if ( file2Delete . isFile ( ) ) isDeleted &= file2Delete . delete ( ) ; return isDeleted ; }
public static boolean deleteFiles ( final File targetDir ) { if ( targetDir == null || ! targetDir . isDirectory ( ) ) { Log . e ( FileUtils . class , STRING ) ; return _BOOL ; } boolean isDeleted = _BOOL ; final File [ ] filesList = targetDir . listFiles ( ) ; for ( File file2Delete : filesList ) if ( file2Delete . isFile ( ) ) isDeleted &= file2Delete . delete ( ) ; return isDeleted ; }
void advanceCommitIndex ( ) throws InterruptedException { Map < Integer , Peer > peers = this . peers ; Arrays . fill ( matchIndices , _NUM ) ; final int [ ] ix = { _NUM } ; peers . forEach ( null ) ; for ( int i = _NUM ; i < matchIndices . length ; i ++ ) { for ( int j = _NUM ; j < matchIndices . length - i ; j ++ ) { if ( matchIndices [ j - _NUM ] < matchIndices [ j ] ) { int temp = matchIndices [ j - _NUM ] ; matchIndices [ j - _NUM ] = matchIndices [ j ] ; matchIndices [ j ] = temp ; } } } saveQueue . getLatest ( savedRid ) ; int newCommitIndex = Math . min ( savedRid . index , matchIndices [ matchIndices . length - majority ] ) ; if ( newCommitIndex > commitIndex ) { commitIndex = newCommitIndex ; } }
void advanceCommitIndex ( ) throws InterruptedException { Map < Integer , Peer > peers = this . peers ; Arrays . fill ( matchIndices , _NUM ) ; final int [ ] ix = { _NUM } ; peers . forEach ( null ) ; for ( int i = _NUM ; i < matchIndices . length ; i ++ ) { for ( int j = _NUM ; j < matchIndices . length - i ; j ++ ) { if ( matchIndices [ j - _NUM ] < matchIndices [ j ] ) { int temp = matchIndices [ j - _NUM ] ; matchIndices [ j - _NUM ] = matchIndices [ j ] ; matchIndices [ j ] = temp ; } } } saveQueue . getLatest ( savedRid ) ; int newCommitIndex = Math . min ( savedRid . index , matchIndices [ matchIndices . length - majority ] ) ; if ( newCommitIndex > commitIndex ) { commitIndex = newCommitIndex ; } }
void advanceCommitIndex ( ) throws InterruptedException { Map < Integer , Peer > peers = this . peers ; Arrays . fill ( matchIndices , _NUM ) ; final int [ ] ix = { _NUM } ; peers . forEach ( null ) ; for ( int i = _NUM ; i < matchIndices . length ; i ++ ) { for ( int j = _NUM ; j < matchIndices . length - i ; j ++ ) { if ( matchIndices [ j - _NUM ] < matchIndices [ j ] ) { int temp = matchIndices [ j - _NUM ] ; matchIndices [ j - _NUM ] = matchIndices [ j ] ; matchIndices [ j ] = temp ; } } } saveQueue . getLatest ( savedRid ) ; int newCommitIndex = Math . min ( savedRid . index , matchIndices [ matchIndices . length - majority ] ) ; if ( newCommitIndex > commitIndex ) { commitIndex = newCommitIndex ; } }
synchronized Set < Long > keySet ( ) { HashSet < Long > set = new HashSet < Long > ( ) ; for ( Entry < V > e = stack . stackNext ; e != stack ; e = e . stackNext ) { set . add ( e . key ) ; } for ( Entry < V > e = queue . queueNext ; e != queue ; e = e . queueNext ) { set . add ( e . key ) ; } return set ; }
SSLSession toSession ( byte [ ] data , String host , int port ) { ByteArrayInputStream bais = new ByteArrayInputStream ( data ) ; DataInputStream dais = new DataInputStream ( bais ) ; try { int type = dais . readInt ( ) ; if ( type != OPEN_SSL ) { log ( new AssertionError ( STRING + type ) ) ; return null ; } int length = dais . readInt ( ) ; byte [ ] sessionData = new byte [ length ] ; dais . readFully ( sessionData ) ; int count = dais . readInt ( ) ; X509Certificate [ ] certs = new X509Certificate [ count ] ; for ( int i = _NUM ; i < count ; i ++ ) { length = dais . readInt ( ) ; byte [ ] certData = new byte [ length ] ; dais . readFully ( certData ) ; certs [ i ] = OpenSSLX509Certificate . fromX509Der ( certData ) ; } return new OpenSSLSessionImpl ( sessionData , host , port , certs , this ) ; } catch ( IOException e ) { log ( e ) ; return null ; } }
public BasicI18n ( ) { this ( Locale . getDefault ( ) ) ; }
VPlexDistributedDeviceInfo findDistributedDevice ( String deviceName ) throws VPlexApiException { return findDistributedDevice ( deviceName , _BOOL ) ; }
@ Override public boolean connectionAllowed ( String eventName ) { if ( ! eventName . equals ( STRING ) && ! eventName . equals ( STRING ) && ! eventName . equals ( STRING ) && ! eventName . equals ( STRING ) ) { return _BOOL ; } if ( m_listeneeTypes . size ( ) == _NUM ) { return _BOOL ; } if ( m_listeneeTypes . contains ( STRING ) && ! eventName . equals ( STRING ) ) { return _BOOL ; } if ( ! m_listeneeTypes . contains ( STRING ) && eventName . equals ( STRING ) ) { return _BOOL ; } return _BOOL ; }
@ Override public boolean connectionAllowed ( String eventName ) { if ( ! eventName . equals ( STRING ) && ! eventName . equals ( STRING ) && ! eventName . equals ( STRING ) && ! eventName . equals ( STRING ) ) { return _BOOL ; } if ( m_listeneeTypes . size ( ) == _NUM ) { return _BOOL ; } if ( m_listeneeTypes . contains ( STRING ) && ! eventName . equals ( STRING ) ) { return _BOOL ; } if ( ! m_listeneeTypes . contains ( STRING ) && eventName . equals ( STRING ) ) { return _BOOL ; } return _BOOL ; }
@ Override public boolean connectionAllowed ( String eventName ) { if ( ! eventName . equals ( STRING ) && ! eventName . equals ( STRING ) && ! eventName . equals ( STRING ) && ! eventName . equals ( STRING ) ) { return _BOOL ; } if ( m_listeneeTypes . size ( ) == _NUM ) { return _BOOL ; } if ( m_listeneeTypes . contains ( STRING ) && ! eventName . equals ( STRING ) ) { return _BOOL ; } if ( ! m_listeneeTypes . contains ( STRING ) && eventName . equals ( STRING ) ) { return _BOOL ; } return _BOOL ; }
@ Override public boolean connectionAllowed ( String eventName ) { if ( ! eventName . equals ( STRING ) && ! eventName . equals ( STRING ) && ! eventName . equals ( STRING ) && ! eventName . equals ( STRING ) ) { return _BOOL ; } if ( m_listeneeTypes . size ( ) == _NUM ) { return _BOOL ; } if ( m_listeneeTypes . contains ( STRING ) && ! eventName . equals ( STRING ) ) { return _BOOL ; } if ( ! m_listeneeTypes . contains ( STRING ) && eventName . equals ( STRING ) ) { return _BOOL ; } return _BOOL ; }
protected double applyOperator ( double first , double second ) { switch ( m_operator ) { case STRING : return ( first + second ) ; case STRING : return ( first - second ) ; case STRING : return ( first * second ) ; case STRING : return ( first / second ) ; case STRING : return Math . pow ( first , second ) ; } return Double . NaN ; }
public static String [ ] [ ] read ( String logname , String logtype , String timeStamp , LogQuery logQuery , Object userCrdential ) throws IOException , NoSuchFieldException , IllegalArgumentException , RuntimeException , Exception { String mainFileName = new String ( ) ; setLoggerName ( logname , logtype ) ; mainFileName = loggerName ; if ( timeStamp != null ) { if ( mainFileName . length ( ) == _NUM ) { return null ; } mainFileName += STRING + timeStamp ; } queryResult = read ( mainFileName , logQuery , userCrdential ) ; return queryResult ; }
public static String [ ] [ ] read ( String logname , String logtype , String timeStamp , LogQuery logQuery , Object userCrdential ) throws IOException , NoSuchFieldException , IllegalArgumentException , RuntimeException , Exception { String mainFileName = new String ( ) ; setLoggerName ( logname , logtype ) ; mainFileName = loggerName ; if ( timeStamp != null ) { if ( mainFileName . length ( ) == _NUM ) { return null ; } mainFileName += STRING + timeStamp ; } queryResult = read ( mainFileName , logQuery , userCrdential ) ; return queryResult ; }
public static String [ ] [ ] read ( String logname , String logtype , String timeStamp , LogQuery logQuery , Object userCrdential ) throws IOException , NoSuchFieldException , IllegalArgumentException , RuntimeException , Exception { String mainFileName = new String ( ) ; setLoggerName ( logname , logtype ) ; mainFileName = loggerName ; if ( timeStamp != null ) { if ( mainFileName . length ( ) == _NUM ) { return null ; } mainFileName += STRING + timeStamp ; } queryResult = read ( mainFileName , logQuery , userCrdential ) ; return queryResult ; }
public static String [ ] [ ] read ( String logname , String logtype , String timeStamp , LogQuery logQuery , Object userCrdential ) throws IOException , NoSuchFieldException , IllegalArgumentException , RuntimeException , Exception { String mainFileName = new String ( ) ; setLoggerName ( logname , logtype ) ; mainFileName = loggerName ; if ( timeStamp != null ) { if ( mainFileName . length ( ) == _NUM ) { return null ; } mainFileName += STRING + timeStamp ; } queryResult = read ( mainFileName , logQuery , userCrdential ) ; return queryResult ; }
public static String [ ] [ ] read ( String logname , String logtype , String timeStamp , LogQuery logQuery , Object userCrdential ) throws IOException , NoSuchFieldException , IllegalArgumentException , RuntimeException , Exception { String mainFileName = new String ( ) ; setLoggerName ( logname , logtype ) ; mainFileName = loggerName ; if ( timeStamp != null ) { if ( mainFileName . length ( ) == _NUM ) { return null ; } mainFileName += STRING + timeStamp ; } queryResult = read ( mainFileName , logQuery , userCrdential ) ; return queryResult ; }
public static String [ ] [ ] read ( String logname , String logtype , String timeStamp , LogQuery logQuery , Object userCrdential ) throws IOException , NoSuchFieldException , IllegalArgumentException , RuntimeException , Exception { String mainFileName = new String ( ) ; setLoggerName ( logname , logtype ) ; mainFileName = loggerName ; if ( timeStamp != null ) { if ( mainFileName . length ( ) == _NUM ) { return null ; } mainFileName += STRING + timeStamp ; } queryResult = read ( mainFileName , logQuery , userCrdential ) ; return queryResult ; }
private void resetLabels ( ) { mFrom . setText ( STRING ) ; updateAlias ( mFromAlias , null ) ; mTo . setText ( STRING ) ; updateAlias ( mToAlias , null ) ; mConfigured = _BOOL ; }
private void resetLabels ( ) { mFrom . setText ( STRING ) ; updateAlias ( mFromAlias , null ) ; mTo . setText ( STRING ) ; updateAlias ( mToAlias , null ) ; mConfigured = _BOOL ; }
private void resetLabels ( ) { mFrom . setText ( STRING ) ; updateAlias ( mFromAlias , null ) ; mTo . setText ( STRING ) ; updateAlias ( mToAlias , null ) ; mConfigured = _BOOL ; }
private static boolean hasSpecializedHandlerIntents ( Context context , Intent intent ) { try { PackageManager pm = context . getPackageManager ( ) ; List < ResolveInfo > handlers = pm . queryIntentActivities ( intent , PackageManager . GET_RESOLVED_FILTER ) ; if ( handlers == null || handlers . isEmpty ( ) ) { return _BOOL ; } for ( ResolveInfo resolveInfo : handlers ) { IntentFilter filter = resolveInfo . filter ; if ( filter == null ) continue ; if ( filter . countDataAuthorities ( ) == _NUM || filter . countDataPaths ( ) == _NUM ) continue ; if ( resolveInfo . activityInfo == null ) continue ; return _BOOL ; } } catch ( RuntimeException e ) { Log . e ( TAG , STRING ) ; } return _BOOL ; }
public static String buildString ( Consumer < StringPrinter > printer ) { StringBuilder builder = new StringBuilder ( ) ; printer . accept ( new StringPrinter ( null ) ) ; return builder . toString ( ) ; }
public final void searchPattern ( IProgressMonitor monitor ) throws JavaModelException { Assert . isNotNull ( fPattern ) ; if ( monitor == null ) monitor = new NullProgressMonitor ( ) ; try { monitor . beginTask ( STRING , _NUM ) ; monitor . setTaskName ( RefactoringCoreMessages . RefactoringSearchEngine_searching_occurrences ) ; try { SearchEngine engine = null ; if ( fOwner != null ) engine = new SearchEngine ( fOwner ) ; else engine = new SearchEngine ( fWorkingCopies ) ; engine . search ( fPattern , SearchUtils . getDefaultSearchParticipants ( ) , fScope , getCollector ( ) , new SubProgressMonitor ( monitor , _NUM , SubProgressMonitor . SUPPRESS_SUBTASK_LABEL ) ) ; } catch ( CoreException exception ) { throw new JavaModelException ( exception ) ; } } finally { monitor . done ( ) ; } }
public void addNotice ( ParserNotice notice ) { notices . add ( notice ) ; }
private Iterable < String > distinctNames ( Iterable < InetSocketAddress > addresses ) { Set < String > result = new HashSet < > ( ) ; for ( InetSocketAddress address : addresses ) { result . add ( name ( address ) ) ; } return result ; }
public boolean sendViaDataSocket ( String string ) { try { byte [ ] bytes = string . getBytes ( encoding ) ; Log . d ( TAG , STRING + encoding ) ; return sendViaDataSocket ( bytes , bytes . length ) ; } catch ( UnsupportedEncodingException e ) { Log . e ( TAG , STRING ) ; return _BOOL ; } }
public boolean sendViaDataSocket ( String string ) { try { byte [ ] bytes = string . getBytes ( encoding ) ; Log . d ( TAG , STRING + encoding ) ; return sendViaDataSocket ( bytes , bytes . length ) ; } catch ( UnsupportedEncodingException e ) { Log . e ( TAG , STRING ) ; return _BOOL ; } }
public boolean sendViaDataSocket ( String string ) { try { byte [ ] bytes = string . getBytes ( encoding ) ; Log . d ( TAG , STRING + encoding ) ; return sendViaDataSocket ( bytes , bytes . length ) ; } catch ( UnsupportedEncodingException e ) { Log . e ( TAG , STRING ) ; return _BOOL ; } }
protected ArrayList < Integer > calculateHeightsForAnimationParts ( int titleViewHeight , int contentViewHeight , int additionalFlipsCount ) { ArrayList < Integer > partHeights = new ArrayList < > ( ) ; int additionalPartsTotalHeight = contentViewHeight - titleViewHeight * _NUM ; if ( additionalPartsTotalHeight < _NUM ) throw new IllegalStateException ( STRING ) ; partHeights . add ( titleViewHeight ) ; partHeights . add ( titleViewHeight ) ; if ( additionalPartsTotalHeight == _NUM ) return partHeights ; if ( additionalFlipsCount != _NUM ) { int additionalPartHeight = additionalPartsTotalHeight / additionalFlipsCount ; int remainingHeight = additionalPartsTotalHeight % additionalFlipsCount ; if ( additionalPartHeight + remainingHeight > titleViewHeight ) throw new IllegalStateException ( STRING ) ; for ( int i = _NUM ; i < additionalFlipsCount ; i ++ ) partHeights . add ( additionalPartHeight + ( i == _NUM ? remainingHeight : _NUM ) ) ; } else { int partsCount = additionalPartsTotalHeight / titleViewHeight ; int restPartHeight = additionalPartsTotalHeight % titleViewHeight ; for ( int i = _NUM ; i < partsCount ; i ++ ) partHeights . add ( titleViewHeight ) ; if ( restPartHeight > _NUM ) partHeights . add ( restPartHeight ) ; } return partHeights ; }
private void applyQueryHints ( final AST2BOpContext context , final QueryRoot queryRoot , final QueryHintScope scope , final ASTBase t , final Properties queryHints ) { @ SuppressWarnings ( STRING ) final Enumeration e = queryHints . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { final String name = ( String ) e . nextElement ( ) ; final String value = queryHints . getProperty ( name ) ; _applyQueryHint ( context , queryRoot , scope , t , name , value ) ; } }
@ Override protected void autoAdjustRange ( ) { Plot plot = getPlot ( ) ; if ( plot == null ) { return ; } if ( plot instanceof ValueAxisPlot ) { ValueAxisPlot vap = ( ValueAxisPlot ) plot ; Range r = vap . getDataRange ( this ) ; if ( r == null ) { r = getDefaultAutoRange ( ) ; } long upper = Math . round ( r . getUpperBound ( ) ) ; long lower = Math . round ( r . getLowerBound ( ) ) ; this . first = createInstance ( this . autoRangeTimePeriodClass , new Date ( lower ) , this . timeZone , this . locale ) ; this . last = createInstance ( this . autoRangeTimePeriodClass , new Date ( upper ) , this . timeZone , this . locale ) ; setRange ( r , _BOOL , _BOOL ) ; } }
@ Override protected void autoAdjustRange ( ) { Plot plot = getPlot ( ) ; if ( plot == null ) { return ; } if ( plot instanceof ValueAxisPlot ) { ValueAxisPlot vap = ( ValueAxisPlot ) plot ; Range r = vap . getDataRange ( this ) ; if ( r == null ) { r = getDefaultAutoRange ( ) ; } long upper = Math . round ( r . getUpperBound ( ) ) ; long lower = Math . round ( r . getLowerBound ( ) ) ; this . first = createInstance ( this . autoRangeTimePeriodClass , new Date ( lower ) , this . timeZone , this . locale ) ; this . last = createInstance ( this . autoRangeTimePeriodClass , new Date ( upper ) , this . timeZone , this . locale ) ; setRange ( r , _BOOL , _BOOL ) ; } }
public void sendRequest ( SloRequestSettings requestSettings , HttpServletResponse response ) throws IOException { Validate . notNull ( requestSettings , STRING ) ; Validate . notNull ( response , STRING ) ; Validate . notNull ( getMessageStore ( ) , STRING ) ; Validate . notNull ( getMetadataSettings ( ) , STRING ) ; String redirectUrl = getRequestUrl ( requestSettings ) ; if ( redirectUrl != null ) { response . sendRedirect ( redirectUrl ) ; } else { if ( SamlUtils . isIdpSupportSLO ( getMetadataSettings ( ) , requestSettings ) ) { logger . error ( STRING ) ; } else { logger . warn ( String . format ( STRING , requestSettings . getIDPAlias ( ) ) ) ; } } }
public void loadSettings ( File file ) { if ( ! file . canRead ( ) ) return ; FileInputStream input = null ; try { input = new FileInputStream ( file ) ; values . load ( input ) ; } catch ( IOException e ) { } finally { if ( input != null ) { try { input . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } }
public void loadSettings ( File file ) { if ( ! file . canRead ( ) ) return ; FileInputStream input = null ; try { input = new FileInputStream ( file ) ; values . load ( input ) ; } catch ( IOException e ) { } finally { if ( input != null ) { try { input . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } }
private void incrementSubmittedJobCount ( ) { countLock . lock ( ) ; try { submittedJobCount ++ ; } finally { countLock . unlock ( ) ; } }
private void incrementSubmittedJobCount ( ) { countLock . lock ( ) ; try { submittedJobCount ++ ; } finally { countLock . unlock ( ) ; } }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
private static SSLSocketFactory trustAllHosts ( HttpsURLConnection connection ) { SSLSocketFactory oldFactory = connection . getSSLSocketFactory ( ) ; try { SSLContext sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; SSLSocketFactory newFactory = sc . getSocketFactory ( ) ; connection . setSSLSocketFactory ( newFactory ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return oldFactory ; }
@ Override public void aroundWriteTo ( WriterInterceptorContext writerInterceptorContext ) throws IOException { LengthOfOutputStream stream = ( LengthOfOutputStream ) writerInterceptorContext . getProperty ( PROPERTY_OUTPUT_STREAM ) ; try { writerInterceptorContext . proceed ( ) ; if ( stream != null ) { emitSuccess ( stream ) ; } } catch ( EOFException e ) { if ( stream != null ) { emitError ( stream , e ) ; } LOG . warn ( STRING , e ) ; } catch ( Error | RuntimeException | IOException e ) { if ( stream != null ) { emitError ( stream , e ) ; } LOG . error ( STRING , e ) ; throw e ; } finally { try { RequestLog . stopTiming ( this ) ; RequestLog . stopTiming ( TOTAL_TIMER ) ; RequestLog . log ( ) ; } catch ( Exception e ) { LOG . error ( STRING , e ) ; } } }
@ Override public void aroundWriteTo ( WriterInterceptorContext writerInterceptorContext ) throws IOException { LengthOfOutputStream stream = ( LengthOfOutputStream ) writerInterceptorContext . getProperty ( PROPERTY_OUTPUT_STREAM ) ; try { writerInterceptorContext . proceed ( ) ; if ( stream != null ) { emitSuccess ( stream ) ; } } catch ( EOFException e ) { if ( stream != null ) { emitError ( stream , e ) ; } LOG . warn ( STRING , e ) ; } catch ( Error | RuntimeException | IOException e ) { if ( stream != null ) { emitError ( stream , e ) ; } LOG . error ( STRING , e ) ; throw e ; } finally { try { RequestLog . stopTiming ( this ) ; RequestLog . stopTiming ( TOTAL_TIMER ) ; RequestLog . log ( ) ; } catch ( Exception e ) { LOG . error ( STRING , e ) ; } } }
@ Override public void aroundWriteTo ( WriterInterceptorContext writerInterceptorContext ) throws IOException { LengthOfOutputStream stream = ( LengthOfOutputStream ) writerInterceptorContext . getProperty ( PROPERTY_OUTPUT_STREAM ) ; try { writerInterceptorContext . proceed ( ) ; if ( stream != null ) { emitSuccess ( stream ) ; } } catch ( EOFException e ) { if ( stream != null ) { emitError ( stream , e ) ; } LOG . warn ( STRING , e ) ; } catch ( Error | RuntimeException | IOException e ) { if ( stream != null ) { emitError ( stream , e ) ; } LOG . error ( STRING , e ) ; throw e ; } finally { try { RequestLog . stopTiming ( this ) ; RequestLog . stopTiming ( TOTAL_TIMER ) ; RequestLog . log ( ) ; } catch ( Exception e ) { LOG . error ( STRING , e ) ; } } }
private int [ ] parseSkillUpValues ( String ... skills ) { int [ ] ret = new int [ ] { DEFAULT_INT , DEFAULT_INT , DEFAULT_INT , DEFAULT_INT } ; try { for ( int i = _NUM ; i <= _NUM && i < skills . length ; i ++ ) { String skill = skills [ i ] ; if ( skill == null || skill . isEmpty ( ) ) { continue ; } else { ret [ i ] = Integer . parseInt ( skill . trim ( ) ) ; } } } catch ( NumberFormatException nfe ) { nfe . printStackTrace ( ) ; } return ret ; }
private int [ ] parseSkillUpValues ( String ... skills ) { int [ ] ret = new int [ ] { DEFAULT_INT , DEFAULT_INT , DEFAULT_INT , DEFAULT_INT } ; try { for ( int i = _NUM ; i <= _NUM && i < skills . length ; i ++ ) { String skill = skills [ i ] ; if ( skill == null || skill . isEmpty ( ) ) { continue ; } else { ret [ i ] = Integer . parseInt ( skill . trim ( ) ) ; } } } catch ( NumberFormatException nfe ) { nfe . printStackTrace ( ) ; } return ret ; }
private ImageData awtToSwt ( final BufferedImage bufferedImage , final int width , final int height ) { final int [ ] awtPixels = new int [ width * height ] ; final ImageData swtImageData = new ImageData ( width , height , _NUM , PALETTE_DATA ) ; swtImageData . transparentPixel = TRANSPARENT_COLOR ; final int step = swtImageData . depth / _NUM ; final byte [ ] data = swtImageData . data ; bufferedImage . getRGB ( _NUM , _NUM , width , height , awtPixels , _NUM , width ) ; for ( int i = _NUM ; i < height ; i ++ ) { int idx = ( _NUM + i ) * swtImageData . bytesPerLine + _NUM * step ; for ( int j = _NUM ; j < width ; j ++ ) { final int rgb = awtPixels [ j + i * width ] ; for ( int k = swtImageData . depth - _NUM ; k >= _NUM ; k -= _NUM ) { data [ idx ++ ] = ( byte ) ( rgb > > k & _NUM ) ; } } } return swtImageData ; }
public JComponent createPropertyGUI ( PropertyConsumer pc ) { this . propertyConsumer = pc ; Properties props = new Properties ( ) ; props = pc . getProperties ( props ) ; Properties info = new Properties ( ) ; info = pc . getPropertyInfo ( info ) ; String prefix = pc . getPropertyPrefix ( ) ; return createPropertyGUI ( prefix , props , info ) ; }
public IEEE802154Message ( byte [ ] a , int l ) { super ( String . valueOf ( a ) ) ; setResponseLength ( l ) ; setBinary ( _BOOL ) ; setTimeout ( _NUM ) ; }
public IEEE802154Message ( byte [ ] a , int l ) { super ( String . valueOf ( a ) ) ; setResponseLength ( l ) ; setBinary ( _BOOL ) ; setTimeout ( _NUM ) ; }
public Runnable incrementAsRunnable ( ) { return mIncrementRunnable ; }
public double clamp ( double value ) { return Math . min ( Math . max ( getMin ( ) , value ) , getMax ( ) ) ; }
public static String abbreviateName ( String str , FontMetrics fm , int width ) { if ( fm . stringWidth ( str ) > width ) str = abbreviateName ( str , _BOOL ) ; if ( fm . stringWidth ( str ) > width ) str = abbreviateName ( str , _BOOL ) ; return str ; }
@ RequestMapping ( value = STRING , method = POST , produces = APPLICATION_JSON_VALUE ) public ResponseEntity < PageResponse < AuthorDTO > > findAll ( @ RequestBody PageRequestByExample < AuthorDTO > prbe ) throws URISyntaxException { PageResponse < AuthorDTO > pageResponse = authorDTOService . findAll ( prbe ) ; return new ResponseEntity < > ( pageResponse , new HttpHeaders ( ) , HttpStatus . OK ) ; }
@ RequestMapping ( value = STRING , method = POST , produces = APPLICATION_JSON_VALUE ) public ResponseEntity < PageResponse < AuthorDTO > > findAll ( @ RequestBody PageRequestByExample < AuthorDTO > prbe ) throws URISyntaxException { PageResponse < AuthorDTO > pageResponse = authorDTOService . findAll ( prbe ) ; return new ResponseEntity < > ( pageResponse , new HttpHeaders ( ) , HttpStatus . OK ) ; }
public DBDataCollector ( ) { super ( ) ; propertiesFileName = DEFAULT_CONFIG_FILE_NAME ; final String userDefinedPropertiesFileName = System . getProperty ( CONFIG_PROPERTY_FILE_NAME ) ; if ( userDefinedPropertiesFileName != null ) { propertiesFileName = userDefinedPropertiesFileName ; } }
@ VisibleForTesting static boolean shouldOpenAfterDownload ( DownloadInfo downloadInfo ) { String type = downloadInfo . getMimeType ( ) ; return downloadInfo . hasUserGesture ( ) && ! isAttachment ( downloadInfo . getContentDisposition ( ) ) && MIME_TYPES_TO_OPEN . contains ( type ) ; }
public void onLocationChanged ( Location location ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + location ) ; } synchronized ( listeners ) { gotValidPosition = _BOOL ; for ( GPSLocationListener listener : listeners ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + listener ) ; } listener . onLocationChanged ( location ) ; } listeners . clear ( ) ; } }
protected final void parseArgs ( String [ ] args ) throws AdeException { final ArrayList < String > adeArgs = parseAdeExtArgs ( args ) ; super . parseArgs ( adeArgs . toArray ( new String [ adeArgs . size ( ) ] ) ) ; }
public static void saveImage ( final Bitmap bitmap , final File saveToFile ) { if ( saveToFile . exists ( ) ) { saveToFile . delete ( ) ; } try { final FileOutputStream out = new FileOutputStream ( saveToFile ) ; bitmap . compress ( Bitmap . CompressFormat . PNG , _NUM , out ) ; out . flush ( ) ; out . close ( ) ; } catch ( final Exception e ) { e . printStackTrace ( ) ; } }
public static void saveImage ( final Bitmap bitmap , final File saveToFile ) { if ( saveToFile . exists ( ) ) { saveToFile . delete ( ) ; } try { final FileOutputStream out = new FileOutputStream ( saveToFile ) ; bitmap . compress ( Bitmap . CompressFormat . PNG , _NUM , out ) ; out . flush ( ) ; out . close ( ) ; } catch ( final Exception e ) { e . printStackTrace ( ) ; } }
public static void saveImage ( final Bitmap bitmap , final File saveToFile ) { if ( saveToFile . exists ( ) ) { saveToFile . delete ( ) ; } try { final FileOutputStream out = new FileOutputStream ( saveToFile ) ; bitmap . compress ( Bitmap . CompressFormat . PNG , _NUM , out ) ; out . flush ( ) ; out . close ( ) ; } catch ( final Exception e ) { e . printStackTrace ( ) ; } }
public static void saveImage ( final Bitmap bitmap , final File saveToFile ) { if ( saveToFile . exists ( ) ) { saveToFile . delete ( ) ; } try { final FileOutputStream out = new FileOutputStream ( saveToFile ) ; bitmap . compress ( Bitmap . CompressFormat . PNG , _NUM , out ) ; out . flush ( ) ; out . close ( ) ; } catch ( final Exception e ) { e . printStackTrace ( ) ; } }
public static void saveImage ( final Bitmap bitmap , final File saveToFile ) { if ( saveToFile . exists ( ) ) { saveToFile . delete ( ) ; } try { final FileOutputStream out = new FileOutputStream ( saveToFile ) ; bitmap . compress ( Bitmap . CompressFormat . PNG , _NUM , out ) ; out . flush ( ) ; out . close ( ) ; } catch ( final Exception e ) { e . printStackTrace ( ) ; } }
public void propertyChange ( PropertyChangeEvent evt ) { repaint ( ) ; }
public DAuthorityInformationAccess ( JDialog parent , byte [ ] value ) throws IOException { super ( parent ) ; setTitle ( res . getString ( STRING ) ) ; initComponents ( ) ; prepopulateWithValue ( value ) ; }
@ Override public String toString ( ) { StringBuilder s = new StringBuilder ( _NUM ) ; final int numberOfLeadingZeros = Long . numberOfLeadingZeros ( term ) ; for ( int i = _NUM ; i < numberOfLeadingZeros ; i ++ ) { s . append ( STRING ) ; } if ( term != _NUM ) s . append ( Long . toBinaryString ( term ) ) ; return s . toString ( ) ; }
public Map < String , String > parse ( final String str , char [ ] separators ) { if ( separators == null || separators . length == _NUM ) { return new HashMap < > ( ) ; } char separator = separators [ _NUM ] ; if ( str != null ) { int idx = str . length ( ) ; for ( char separator2 : separators ) { int tmp = str . indexOf ( separator2 ) ; if ( tmp != - _NUM && tmp < idx ) { idx = tmp ; separator = separator2 ; } } } return parse ( str , separator ) ; }
public Map < String , String > parse ( final String str , char [ ] separators ) { if ( separators == null || separators . length == _NUM ) { return new HashMap < > ( ) ; } char separator = separators [ _NUM ] ; if ( str != null ) { int idx = str . length ( ) ; for ( char separator2 : separators ) { int tmp = str . indexOf ( separator2 ) ; if ( tmp != - _NUM && tmp < idx ) { idx = tmp ; separator = separator2 ; } } } return parse ( str , separator ) ; }
public Map < String , String > parse ( final String str , char [ ] separators ) { if ( separators == null || separators . length == _NUM ) { return new HashMap < > ( ) ; } char separator = separators [ _NUM ] ; if ( str != null ) { int idx = str . length ( ) ; for ( char separator2 : separators ) { int tmp = str . indexOf ( separator2 ) ; if ( tmp != - _NUM && tmp < idx ) { idx = tmp ; separator = separator2 ; } } } return parse ( str , separator ) ; }
private void reduce ( CssTokenType type ) { StringBuilder sb = new StringBuilder ( ) ; for ( Token < CssTokenType > t : pending ) { sb . append ( t . text ) ; } FilePosition fp = FilePosition . span ( pending . getFirst ( ) . pos , pending . getLast ( ) . pos ) ; pending . clear ( ) ; pending . add ( Token . instance ( sb . toString ( ) , type , fp ) ) ; }
private void reduce ( CssTokenType type ) { StringBuilder sb = new StringBuilder ( ) ; for ( Token < CssTokenType > t : pending ) { sb . append ( t . text ) ; } FilePosition fp = FilePosition . span ( pending . getFirst ( ) . pos , pending . getLast ( ) . pos ) ; pending . clear ( ) ; pending . add ( Token . instance ( sb . toString ( ) , type , fp ) ) ; }
private void reduce ( CssTokenType type ) { StringBuilder sb = new StringBuilder ( ) ; for ( Token < CssTokenType > t : pending ) { sb . append ( t . text ) ; } FilePosition fp = FilePosition . span ( pending . getFirst ( ) . pos , pending . getLast ( ) . pos ) ; pending . clear ( ) ; pending . add ( Token . instance ( sb . toString ( ) , type , fp ) ) ; }
public static String normalizeDir ( String path ) { return ( path != null && ( ! ( path . endsWith ( STRING ) || path . endsWith ( STRING ) ) ) ) ? path + File . separator : path ; }
public static String normalizeDir ( String path ) { return ( path != null && ( ! ( path . endsWith ( STRING ) || path . endsWith ( STRING ) ) ) ) ? path + File . separator : path ; }
public boolean greaterThan ( FXGVersion version ) { return ( compareTo ( version ) > _NUM ) ; }
protected void handleUnexamineOnSendMessage ( String message ) { if ( StringUtils . isBlank ( message ) ) { return ; } String firstWord = message . split ( STRING ) [ _NUM ] ; if ( StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) ) { Game [ ] games = gameService . getAllActiveGames ( ) ; Game examinedGame = null ; for ( Game game : games ) { if ( game . isInState ( Game . EXAMINING_STATE ) || game . isInState ( Game . SETUP_STATE ) ) { examinedGame = game ; break ; } } if ( examinedGame != null ) { onUnexamine ( examinedGame ) ; } } }
protected void handleUnexamineOnSendMessage ( String message ) { if ( StringUtils . isBlank ( message ) ) { return ; } String firstWord = message . split ( STRING ) [ _NUM ] ; if ( StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) ) { Game [ ] games = gameService . getAllActiveGames ( ) ; Game examinedGame = null ; for ( Game game : games ) { if ( game . isInState ( Game . EXAMINING_STATE ) || game . isInState ( Game . SETUP_STATE ) ) { examinedGame = game ; break ; } } if ( examinedGame != null ) { onUnexamine ( examinedGame ) ; } } }
protected void handleUnexamineOnSendMessage ( String message ) { if ( StringUtils . isBlank ( message ) ) { return ; } String firstWord = message . split ( STRING ) [ _NUM ] ; if ( StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) || StringUtils . equalsIgnoreCase ( firstWord , STRING ) ) { Game [ ] games = gameService . getAllActiveGames ( ) ; Game examinedGame = null ; for ( Game game : games ) { if ( game . isInState ( Game . EXAMINING_STATE ) || game . isInState ( Game . SETUP_STATE ) ) { examinedGame = game ; break ; } } if ( examinedGame != null ) { onUnexamine ( examinedGame ) ; } } }
public final void addReference ( Object ref ) { refSet . add ( ref ) ; }
public void clear ( ) { if ( mOriginalValues != null ) { synchronized ( mLock ) { mOriginalValues . clear ( ) ; } } else { mObjects . clear ( ) ; } if ( mNotifyOnChange ) notifyDataSetChanged ( ) ; }
public RepeatedFieldBuilder < MType , BType , IType > addMessage ( int index , MType message ) { if ( message == null ) { throw new NullPointerException ( ) ; } ensureMutableMessageList ( ) ; messages . add ( index , message ) ; if ( builders != null ) { builders . add ( index , null ) ; } onChanged ( ) ; incrementModCounts ( ) ; return this ; }
public RepeatedFieldBuilder < MType , BType , IType > addMessage ( int index , MType message ) { if ( message == null ) { throw new NullPointerException ( ) ; } ensureMutableMessageList ( ) ; messages . add ( index , message ) ; if ( builders != null ) { builders . add ( index , null ) ; } onChanged ( ) ; incrementModCounts ( ) ; return this ; }
private static boolean isInvoiceTypeRecurse ( GenericValue invoiceType , String inputTypeId ) throws GenericEntityException { String invoiceTypeId = invoiceType . getString ( STRING ) ; String parentTypeId = invoiceType . getString ( STRING ) ; if ( parentTypeId == null || invoiceTypeId . equals ( parentTypeId ) ) { return _BOOL ; } if ( parentTypeId . equals ( inputTypeId ) ) { return _BOOL ; } return isInvoiceTypeRecurse ( invoiceType . getRelatedOne ( STRING , _BOOL ) , inputTypeId ) ; }
private static boolean isInvoiceTypeRecurse ( GenericValue invoiceType , String inputTypeId ) throws GenericEntityException { String invoiceTypeId = invoiceType . getString ( STRING ) ; String parentTypeId = invoiceType . getString ( STRING ) ; if ( parentTypeId == null || invoiceTypeId . equals ( parentTypeId ) ) { return _BOOL ; } if ( parentTypeId . equals ( inputTypeId ) ) { return _BOOL ; } return isInvoiceTypeRecurse ( invoiceType . getRelatedOne ( STRING , _BOOL ) , inputTypeId ) ; }
public NamedColumnProjection ( String name , boolean include ) { m_names = new HashSet ( ) ; m_names . add ( name ) ; m_include = include ; }
protected void processNodesAfterAddInstance ( BallNode node ) { node . m_Start ++ ; node . m_End ++ ; if ( node . m_Left != null && node . m_Right != null ) { processNodesAfterAddInstance ( node . m_Left ) ; processNodesAfterAddInstance ( node . m_Right ) ; } }
protected void processNodesAfterAddInstance ( BallNode node ) { node . m_Start ++ ; node . m_End ++ ; if ( node . m_Left != null && node . m_Right != null ) { processNodesAfterAddInstance ( node . m_Left ) ; processNodesAfterAddInstance ( node . m_Right ) ; } }
protected void processNodesAfterAddInstance ( BallNode node ) { node . m_Start ++ ; node . m_End ++ ; if ( node . m_Left != null && node . m_Right != null ) { processNodesAfterAddInstance ( node . m_Left ) ; processNodesAfterAddInstance ( node . m_Right ) ; } }
@ Override public boolean canUndo ( ) { return ! m_UndoList . isEmpty ( ) ; }
public void removeIndexKeyspace ( final String index ) throws IOException { try { QueryProcessor . process ( String . format ( STRING , index ) , ConsistencyLevel . LOCAL_ONE ) ; } catch ( Throwable e ) { throw new IOException ( e . getMessage ( ) , e ) ; } }
public void removeIndexKeyspace ( final String index ) throws IOException { try { QueryProcessor . process ( String . format ( STRING , index ) , ConsistencyLevel . LOCAL_ONE ) ; } catch ( Throwable e ) { throw new IOException ( e . getMessage ( ) , e ) ; } }
public void removeIndexKeyspace ( final String index ) throws IOException { try { QueryProcessor . process ( String . format ( STRING , index ) , ConsistencyLevel . LOCAL_ONE ) ; } catch ( Throwable e ) { throw new IOException ( e . getMessage ( ) , e ) ; } }
public boolean removeOnItemClickListener ( OnItemClickListener itemClickListener ) { return clickListeners . remove ( itemClickListener ) ; }
public boolean toBoolean ( Element el , String attributeName ) { return Caster . toBooleanValue ( el . getAttribute ( attributeName ) , _BOOL ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; Enumeration < Option > enm = super . listOptions ( ) ; while ( enm . hasMoreElements ( ) ) result . add ( enm . nextElement ( ) ) ; result . addElement ( new Option ( STRING + stopwordsTipText ( ) + STRING + STRING , STRING , _NUM , STRING ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; Enumeration < Option > enm = super . listOptions ( ) ; while ( enm . hasMoreElements ( ) ) result . add ( enm . nextElement ( ) ) ; result . addElement ( new Option ( STRING + stopwordsTipText ( ) + STRING + STRING , STRING , _NUM , STRING ) ) ; return result . elements ( ) ; }
public final int dataOffset ( ) { return this . boundOffset ; }
public final int dataOffset ( ) { return this . boundOffset ; }
public static Number minus ( Character left , Character right ) { return minus ( Integer . valueOf ( left ) , right ) ; }
public static Number minus ( Character left , Character right ) { return minus ( Integer . valueOf ( left ) , right ) ; }
public static Number minus ( Character left , Character right ) { return minus ( Integer . valueOf ( left ) , right ) ; }
public void drawConnection ( ViewTransform transform , Graphics2D g , ColorSet colorSet , boolean isSelected , Point target ) { ConnectionDrawing drawing = new ConnectionDrawing ( ) ; addPathConnection ( transform , g , isSelected , _BOOL , drawing , colorSet , ( int ) target . getX ( ) , ( int ) target . getY ( ) , _BOOL , _BOOL ) ; boolean drawShadow = isSelected && mAnchor . getConnectionCreator ( ) != ConstraintAnchor . AUTO_CONSTRAINT_CREATOR ; if ( drawShadow ) { Color pre = g . getColor ( ) ; Stroke s = g . getStroke ( ) ; g . setColor ( sShadowColor ) ; g . setStroke ( sShadowStroke ) ; drawing . draw ( g ) ; g . setColor ( pre ) ; g . setStroke ( s ) ; } drawing . draw ( g ) ; }
public AppConfigBase ( ) { }
@ Override public SurfaceData createSurfaceData ( WComponentPeer peer , int numBackBuffers ) { SurfaceData sd = WGLSurfaceData . createData ( peer ) ; if ( sd == null ) { sd = GDIWindowSurfaceData . createData ( peer ) ; } return sd ; }
public void registerShareKey ( String shareKey ) { shareKeys . add ( shareKey ) ; }
public void registerShareKey ( String shareKey ) { shareKeys . add ( shareKey ) ; }
public double valueAt ( double x ) { return constant * Math . pow ( _NUM - x * x , outsideExp ) ; }
public double valueAt ( double x ) { return constant * Math . pow ( _NUM - x * x , outsideExp ) ; }
public void start ( ) { try { heart = new Heart ( ) ; int threads = Integer . parseInt ( properties . getProperty ( STRING , STRING ) ) ; for ( int i = _NUM ; i < threads ; i ++ ) { Worker worker = new Worker ( this , i ) ; workers . add ( worker ) ; } client = new Async ( this , async_timeout , _BOOL ) ; client . start ( threads ) ; alive = _BOOL ; Thread thread = new Thread ( this , STRING ) ; id = thread . getId ( ) ; thread . start ( ) ; } catch ( Exception e ) { e . printStackTrace ( out ) ; } }
private static ServerSocket random ( ) throws IOException { final ServerSocket skt = new ServerSocket ( _NUM ) ; skt . setReuseAddress ( _BOOL ) ; return skt ; }
public static boolean containsIgnoreCases ( Collection < String > collection , String string ) { if ( collection == null ) { return _BOOL ; } if ( string == null ) { return collection . contains ( null ) ; } boolean contains = _BOOL ; for ( String element : collection ) { if ( string . equalsIgnoreCase ( element ) ) { contains = _BOOL ; break ; } } return contains ; }
public static boolean containsIgnoreCases ( Collection < String > collection , String string ) { if ( collection == null ) { return _BOOL ; } if ( string == null ) { return collection . contains ( null ) ; } boolean contains = _BOOL ; for ( String element : collection ) { if ( string . equalsIgnoreCase ( element ) ) { contains = _BOOL ; break ; } } return contains ; }
public static boolean containsIgnoreCases ( Collection < String > collection , String string ) { if ( collection == null ) { return _BOOL ; } if ( string == null ) { return collection . contains ( null ) ; } boolean contains = _BOOL ; for ( String element : collection ) { if ( string . equalsIgnoreCase ( element ) ) { contains = _BOOL ; break ; } } return contains ; }
public static boolean containsIgnoreCases ( Collection < String > collection , String string ) { if ( collection == null ) { return _BOOL ; } if ( string == null ) { return collection . contains ( null ) ; } boolean contains = _BOOL ; for ( String element : collection ) { if ( string . equalsIgnoreCase ( element ) ) { contains = _BOOL ; break ; } } return contains ; }
public static boolean containsIgnoreCases ( Collection < String > collection , String string ) { if ( collection == null ) { return _BOOL ; } if ( string == null ) { return collection . contains ( null ) ; } boolean contains = _BOOL ; for ( String element : collection ) { if ( string . equalsIgnoreCase ( element ) ) { contains = _BOOL ; break ; } } return contains ; }
public boolean intersects ( Polygon2D polygon ) { for ( Point2D p : polygon . points ) if ( contains ( p ) ) return _BOOL ; for ( Point2D p : points ) if ( polygon . contains ( p ) ) return _BOOL ; return _BOOL ; }
public boolean intersects ( Polygon2D polygon ) { for ( Point2D p : polygon . points ) if ( contains ( p ) ) return _BOOL ; for ( Point2D p : points ) if ( polygon . contains ( p ) ) return _BOOL ; return _BOOL ; }
@ Override public void onViewPositionChanged ( View changedView , int left , int top , int dx , int dy ) { super . onViewPositionChanged ( changedView , left , top , dx , dy ) ; float fractionScreen ; switch ( draggerView . getDragPosition ( ) ) { case TOP : case BOTTOM : dragOffset = Math . abs ( top ) ; fractionScreen = ( float ) dragOffset / draggerListener . dragVerticalDragRange ( ) ; break ; case LEFT : case RIGHT : default : dragOffset = Math . abs ( left ) ; fractionScreen = ( float ) dragOffset / draggerListener . dragHorizontalDragRange ( ) ; break ; } if ( draggerListener != null ) { draggerListener . onViewPositionChanged ( fractionScreen >= _NUM ? _NUM : fractionScreen ) ; } }
@ Override public void onViewPositionChanged ( View changedView , int left , int top , int dx , int dy ) { super . onViewPositionChanged ( changedView , left , top , dx , dy ) ; float fractionScreen ; switch ( draggerView . getDragPosition ( ) ) { case TOP : case BOTTOM : dragOffset = Math . abs ( top ) ; fractionScreen = ( float ) dragOffset / draggerListener . dragVerticalDragRange ( ) ; break ; case LEFT : case RIGHT : default : dragOffset = Math . abs ( left ) ; fractionScreen = ( float ) dragOffset / draggerListener . dragHorizontalDragRange ( ) ; break ; } if ( draggerListener != null ) { draggerListener . onViewPositionChanged ( fractionScreen >= _NUM ? _NUM : fractionScreen ) ; } }
private String generateFittingText ( MethodUsage method , Rectangle2D rect , FontMetrics fontMetrics ) { if ( rect . getWidth ( ) < fontMetrics . stringWidth ( STRING ) ) { return STRING ; } String fullyQualified = method . getNameSpace ( ) + STRING + method . getName ( ) ; if ( fontMetrics . stringWidth ( fullyQualified ) < rect . getWidth ( ) ) { return fullyQualified ; } String abbrevPackage = getShortPackageName ( method . getNameSpace ( ) ) + STRING + method . getName ( ) ; if ( fontMetrics . stringWidth ( abbrevPackage ) < rect . getWidth ( ) ) { return abbrevPackage ; } if ( fontMetrics . stringWidth ( method . getName ( ) ) < rect . getWidth ( ) ) { return method . getName ( ) ; } return STRING ; }
void materialize ( ) { if ( cachefill < _NUM ) { return ; } double min = Double . MAX_VALUE , max = Double . MIN_VALUE ; for ( int i = _NUM ; i < cachefill ; i ++ ) { min = Math . min ( min , cachec [ i ] ) ; max = Math . max ( max , cachec [ i ] ) ; } LinearScale scale = new LinearScale ( min , max ) ; min = scale . getMin ( ) ; max = scale . getMax ( ) ; this . base = min ; this . max = max ; this . binsize = ( max - min ) / this . destsize ; this . data = new double [ this . destsize << _NUM ] ; size = destsize ; final int end = cachefill ; cachefill = - _NUM ; for ( int i = _NUM ; i < end ; i ++ ) { increment ( cachec [ i ] , cachev [ i ] ) ; } cachec = null ; cachev = null ; }
private int loadTable ( long uuid ) throws IOException { int bufferIndex = - _NUM ; Set < Long > uuids = null ; int blockIndex = _blocks . size ( ) - _NUM ; TableBlock lastBlock = _blocks . get ( blockIndex ) ; while ( bufferIndex == - _NUM ) { Pair < Integer , Set < Long > > bufferIndexAndUuuids = lastBlock . writeTable ( uuid ) ; bufferIndex = bufferIndexAndUuuids . left ; if ( bufferIndex == - _NUM ) { blockIndex ++ ; lastBlock = new TableBlock ( blockIndex * _blockSize ) ; _blocks . add ( lastBlock ) ; } else { uuids = bufferIndexAndUuuids . right ; } } int index = toIndex ( blockIndex , bufferIndex ) ; for ( Long tableUuid : uuids ) { _fileIndexByUuid . put ( tableUuid , index ) ; } return index ; }
private int loadTable ( long uuid ) throws IOException { int bufferIndex = - _NUM ; Set < Long > uuids = null ; int blockIndex = _blocks . size ( ) - _NUM ; TableBlock lastBlock = _blocks . get ( blockIndex ) ; while ( bufferIndex == - _NUM ) { Pair < Integer , Set < Long > > bufferIndexAndUuuids = lastBlock . writeTable ( uuid ) ; bufferIndex = bufferIndexAndUuuids . left ; if ( bufferIndex == - _NUM ) { blockIndex ++ ; lastBlock = new TableBlock ( blockIndex * _blockSize ) ; _blocks . add ( lastBlock ) ; } else { uuids = bufferIndexAndUuuids . right ; } } int index = toIndex ( blockIndex , bufferIndex ) ; for ( Long tableUuid : uuids ) { _fileIndexByUuid . put ( tableUuid , index ) ; } return index ; }
public double powerRequest ( ) { update ( ) ; return Math . min ( maxEnergyReceived , maxEnergyStored - energyStored ) ; }
public static ReplyProcessor21 send ( Set recipients , DM dm , int prId , int bucketId , BucketProfile bp , boolean requireAck ) { if ( recipients . isEmpty ( ) ) { return null ; } ReplyProcessor21 rp = null ; int procId = _NUM ; if ( requireAck ) { rp = new ReplyProcessor21 ( dm , recipients ) ; procId = rp . getProcessorId ( ) ; } BucketProfileUpdateMessage m = new BucketProfileUpdateMessage ( recipients , prId , procId , bucketId , bp ) ; dm . putOutgoing ( m ) ; return rp ; }
@ Override public void mouseDragged ( MouseEvent evt ) { int xTrans = _NUM ; int yTrans = _NUM ; if ( slider . getSnapToTicks ( ) ) { int pos = getLocationForValue ( getSnappedValue ( evt ) ) ; if ( pos > - _NUM ) { if ( slider . getOrientation ( ) == JSlider . HORIZONTAL ) { xTrans = pos - evt . getX ( ) + offset ; evt . translatePoint ( xTrans , _NUM ) ; } else { yTrans = pos - evt . getY ( ) + offset ; evt . translatePoint ( _NUM , yTrans ) ; } } } delegate . mouseDragged ( evt ) ; evt . translatePoint ( xTrans , yTrans ) ; }
@ Override public void mouseDragged ( MouseEvent evt ) { int xTrans = _NUM ; int yTrans = _NUM ; if ( slider . getSnapToTicks ( ) ) { int pos = getLocationForValue ( getSnappedValue ( evt ) ) ; if ( pos > - _NUM ) { if ( slider . getOrientation ( ) == JSlider . HORIZONTAL ) { xTrans = pos - evt . getX ( ) + offset ; evt . translatePoint ( xTrans , _NUM ) ; } else { yTrans = pos - evt . getY ( ) + offset ; evt . translatePoint ( _NUM , yTrans ) ; } } } delegate . mouseDragged ( evt ) ; evt . translatePoint ( xTrans , yTrans ) ; }
public static < T > List < T > splice ( List < T > list , int index , int deleteCount ) { return spliceImpl ( list , index , deleteCount , _BOOL , null ) ; }
public static < T > List < T > splice ( List < T > list , int index , int deleteCount ) { return spliceImpl ( list , index , deleteCount , _BOOL , null ) ; }
public static boolean containsFile ( @ NotNull SourceProvider provider , @ NotNull File file ) { Collection < File > srcDirectories = getAllSourceFolders ( provider ) ; if ( filesEqual ( provider . getManifestFile ( ) , file ) ) { return _BOOL ; } for ( File container : srcDirectories ) { File parent = container . getParentFile ( ) ; if ( parent != null && parent . isDirectory ( ) && filesEqual ( parent , file ) ) { return _BOOL ; } if ( ! container . exists ( ) ) { continue ; } if ( isAncestor ( container , file , _BOOL ) ) { return _BOOL ; } } return _BOOL ; }
private void parseText ( ) { StringBuilder buf = new StringBuilder ( ) ; int start = nextChar ; do { char ch = text . charAt ( nextChar ++ ) ; switch ( ch ) { case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; default : buf . append ( ch ) ; break ; } } while ( ! isWordBreak ( nextChar ) ) ; addToken ( new Html ( text . substring ( start , nextChar ) , buf . toString ( ) ) ) ; }
private void parseText ( ) { StringBuilder buf = new StringBuilder ( ) ; int start = nextChar ; do { char ch = text . charAt ( nextChar ++ ) ; switch ( ch ) { case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; case STRING : buf . append ( STRING ) ; break ; default : buf . append ( ch ) ; break ; } } while ( ! isWordBreak ( nextChar ) ) ; addToken ( new Html ( text . substring ( start , nextChar ) , buf . toString ( ) ) ) ; }
private void terminateTaskMgr ( ) { if ( discoveryWakeupMgr != null ) { discoveryWakeupMgr . stop ( ) ; discoveryWakeupMgr . cancelAll ( ) ; } if ( discoveryTaskMgr != null ) { List pendingTasks = discoveryTaskMgr . getPending ( ) ; for ( int i = _NUM ; i < pendingTasks . size ( ) ; i ++ ) { RetryTask pendingTask = ( RetryTask ) pendingTasks . get ( i ) ; pendingTask . cancel ( ) ; discoveryTaskMgr . remove ( pendingTask ) ; } discoveryTaskMgr . terminate ( ) ; discoveryTaskMgr = null ; discoveryWakeupMgr = null ; } }
@ Override public CategoryItemRendererState initialise ( Graphics2D g2 , Rectangle2D dataArea , CategoryPlot plot , int rendererIndex , PlotRenderingInfo info ) { setPlot ( plot ) ; CategoryDataset data = plot . getDataset ( rendererIndex ) ; if ( data != null ) { this . rowCount = data . getRowCount ( ) ; this . columnCount = data . getColumnCount ( ) ; } else { this . rowCount = _NUM ; this . columnCount = _NUM ; } CategoryItemRendererState state = createState ( info ) ; state . setElementHinting ( plot . fetchElementHintingFlag ( ) ) ; int [ ] visibleSeriesTemp = new int [ this . rowCount ] ; int visibleSeriesCount = _NUM ; for ( int row = _NUM ; row < this . rowCount ; row ++ ) { if ( isSeriesVisible ( row ) ) { visibleSeriesTemp [ visibleSeriesCount ] = row ; visibleSeriesCount ++ ; } } int [ ] visibleSeries = new int [ visibleSeriesCount ] ; System . arraycopy ( visibleSeriesTemp , _NUM , visibleSeries , _NUM , visibleSeriesCount ) ; state . setVisibleSeriesArray ( visibleSeries ) ; return state ; }
@ Override public CategoryItemRendererState initialise ( Graphics2D g2 , Rectangle2D dataArea , CategoryPlot plot , int rendererIndex , PlotRenderingInfo info ) { setPlot ( plot ) ; CategoryDataset data = plot . getDataset ( rendererIndex ) ; if ( data != null ) { this . rowCount = data . getRowCount ( ) ; this . columnCount = data . getColumnCount ( ) ; } else { this . rowCount = _NUM ; this . columnCount = _NUM ; } CategoryItemRendererState state = createState ( info ) ; state . setElementHinting ( plot . fetchElementHintingFlag ( ) ) ; int [ ] visibleSeriesTemp = new int [ this . rowCount ] ; int visibleSeriesCount = _NUM ; for ( int row = _NUM ; row < this . rowCount ; row ++ ) { if ( isSeriesVisible ( row ) ) { visibleSeriesTemp [ visibleSeriesCount ] = row ; visibleSeriesCount ++ ; } } int [ ] visibleSeries = new int [ visibleSeriesCount ] ; System . arraycopy ( visibleSeriesTemp , _NUM , visibleSeries , _NUM , visibleSeriesCount ) ; state . setVisibleSeriesArray ( visibleSeries ) ; return state ; }
protected void seedLine ( String uri ) { if ( ! uri . matches ( STRING ) ) { uri = STRING + uri ; } try { UURI uuri = UURIFactory . getInstance ( uri ) ; CrawlURI curi = new CrawlURI ( uuri ) ; curi . setSeed ( _BOOL ) ; curi . setSchedulingDirective ( SchedulingConstants . MEDIUM ) ; if ( getSourceTagSeeds ( ) ) { curi . setSourceTag ( curi . toString ( ) ) ; } publishAddedSeed ( curi ) ; } catch ( URIException e ) { nonseedLine ( uri ) ; } }
public void dischargeItem ( ItemStack aStack ) { increaseStoredEnergyUnits ( GT_ModHandler . dischargeElectricItem ( aStack , ( int ) Math . min ( Integer . MAX_VALUE , getEUCapacity ( ) - getStoredEU ( ) ) , ( int ) Math . min ( Integer . MAX_VALUE , mMetaTileEntity . getInputTier ( ) ) , _BOOL , _BOOL , _BOOL ) , _BOOL ) ; }
public StrBuilder insert ( final int index , final char chars [ ] ) { validateIndex ( index ) ; if ( chars == null ) { return insert ( index , nullText ) ; } final int len = chars . length ; if ( len > _NUM ) { ensureCapacity ( size + len ) ; System . arraycopy ( buffer , index , buffer , index + len , size - index ) ; System . arraycopy ( chars , _NUM , buffer , index , len ) ; size += len ; } return this ; }
@ NamespacePermission ( fields = STRING , permissions = NamespacePermissionEnum . EXECUTE ) @ Override @ Transactional ( propagation = Propagation . REQUIRES_NEW ) public EmrCluster createCluster ( EmrClusterCreateRequest request ) throws Exception { return createClusterImpl ( request ) ; }
public static List < Volume > queryVolumesByIterativeQuery ( DbClient dbClient , List < URI > volumeURIs ) { List < Volume > volumes = new ArrayList < Volume > ( ) ; @ SuppressWarnings ( STRING ) Iterator < Volume > volumeIterator = dbClient . queryIterativeObjects ( Volume . class , volumeURIs ) ; while ( volumeIterator . hasNext ( ) ) { volumes . add ( volumeIterator . next ( ) ) ; } return volumes ; }
public Commafier ( final String initial ) { m_separator = DEFAULT_SEPARATOR ; sb . append ( initial ) ; }
public void addConnectionListener ( ConnectionListener listener ) { connectionListeners . addElement ( listener ) ; }
public void addConnectionListener ( ConnectionListener listener ) { connectionListeners . addElement ( listener ) ; }
public void addConnectionListener ( ConnectionListener listener ) { connectionListeners . addElement ( listener ) ; }
public int indexOf ( String arg ) { return arguments . indexOf ( arg ) ; }
private void endDataSourceTag ( ) { buffer . append ( STRING ) ; }
public static ConnectionFactory configureConnectionFactory ( final JsonValue configuration , final String name , final TrustManager trustManager , final X509KeyManager keyManager , final ClassLoader providerClassLoader ) { final JsonValue normalizedConfiguration = normalizeConnectionFactory ( configuration , name , _NUM ) ; return configureConnectionFactory ( normalizedConfiguration , trustManager , keyManager , providerClassLoader ) ; }
public static ConnectionFactory configureConnectionFactory ( final JsonValue configuration , final String name , final TrustManager trustManager , final X509KeyManager keyManager , final ClassLoader providerClassLoader ) { final JsonValue normalizedConfiguration = normalizeConnectionFactory ( configuration , name , _NUM ) ; return configureConnectionFactory ( normalizedConfiguration , trustManager , keyManager , providerClassLoader ) ; }
public static ConnectionFactory configureConnectionFactory ( final JsonValue configuration , final String name , final TrustManager trustManager , final X509KeyManager keyManager , final ClassLoader providerClassLoader ) { final JsonValue normalizedConfiguration = normalizeConnectionFactory ( configuration , name , _NUM ) ; return configureConnectionFactory ( normalizedConfiguration , trustManager , keyManager , providerClassLoader ) ; }
public static String trim ( final String string ) { String result = null ; if ( string == null ) { result = BLANK ; } else { result = string . trim ( ) ; } return result ; }
public static String trim ( final String string ) { String result = null ; if ( string == null ) { result = BLANK ; } else { result = string . trim ( ) ; } return result ; }
public static String trim ( final String string ) { String result = null ; if ( string == null ) { result = BLANK ; } else { result = string . trim ( ) ; } return result ; }
public static String trim ( final String string ) { String result = null ; if ( string == null ) { result = BLANK ; } else { result = string . trim ( ) ; } return result ; }
public static String removeIllegalCharacter ( final String text ) { final StringBuilder rVal = new StringBuilder ( ) ; for ( int i = _NUM ; i < text . length ( ) ; ++ i ) { if ( ! isIllegalFileNameChar ( text . charAt ( i ) ) ) { rVal . append ( text . charAt ( i ) ) ; } } return rVal . toString ( ) ; }
@ Override public ArrayList < String > reportDenseFeatures ( int index ) { denseFeatureIndex = index ; ArrayList < String > names = new ArrayList < > ( ) ; for ( int i = _NUM ; i < phrase_weights . length ; i ++ ) names . add ( String . format ( STRING , owner , i ) ) ; return names ; }
public static Set < String > computeHashIndex ( long docHash ) { int bandIndex = _NUM ; BitSet bitRange = new BitSet ( BAND_WIDTH ) ; int bitsWidthCounter = _NUM ; Set < String > bandBitset = new HashSet < > ( ) ; for ( int i = _NUM ; i < HASH_LENGTH ; ++ i ) { bitRange . set ( bitsWidthCounter , ( ( docHash > > i ) & _NUM ) == _NUM ) ; if ( bitsWidthCounter ++ == BAND_WIDTH ) { bandBitset . add ( bandIndex + STRING + bitRange . toString ( ) ) ; bitsWidthCounter = _NUM ; bitRange = new BitSet ( BAND_WIDTH ) ; bandIndex ++ ; } } return bandBitset ; }
public static Set < String > computeHashIndex ( long docHash ) { int bandIndex = _NUM ; BitSet bitRange = new BitSet ( BAND_WIDTH ) ; int bitsWidthCounter = _NUM ; Set < String > bandBitset = new HashSet < > ( ) ; for ( int i = _NUM ; i < HASH_LENGTH ; ++ i ) { bitRange . set ( bitsWidthCounter , ( ( docHash > > i ) & _NUM ) == _NUM ) ; if ( bitsWidthCounter ++ == BAND_WIDTH ) { bandBitset . add ( bandIndex + STRING + bitRange . toString ( ) ) ; bitsWidthCounter = _NUM ; bitRange = new BitSet ( BAND_WIDTH ) ; bandIndex ++ ; } } return bandBitset ; }
@ Override public String toString ( ) { if ( markers == null ) { return String . format ( STRING , DECIMAL_FORMAT . format ( lastObservation ) , DECIMAL_FORMAT . format ( pValue ) ) ; } else { return String . format ( STRING , DECIMAL_FORMAT . format ( lastObservation ) , markers . toString ( ) ) ; } }
private static boolean isCorbaUrl ( String url ) { return url . startsWith ( STRING ) || url . startsWith ( STRING ) || url . startsWith ( STRING ) ; }
private static boolean isCorbaUrl ( String url ) { return url . startsWith ( STRING ) || url . startsWith ( STRING ) || url . startsWith ( STRING ) ; }
private static boolean isCorbaUrl ( String url ) { return url . startsWith ( STRING ) || url . startsWith ( STRING ) || url . startsWith ( STRING ) ; }
public Object create ( String url ) throws MalformedURLException , ClassNotFoundException { HessianMetaInfoAPI metaInfo ; metaInfo = ( HessianMetaInfoAPI ) create ( HessianMetaInfoAPI . class , url ) ; String apiClassName = ( String ) metaInfo . _hessian_getAttribute ( STRING ) ; if ( apiClassName == null ) throw new HessianRuntimeException ( url + STRING ) ; Class < ? > apiClass = Class . forName ( apiClassName , _BOOL , _loader ) ; return create ( apiClass , url ) ; }
private boolean checkDatabase ( ) { SQLiteDatabase checkDB = null ; try { String path = DB_PATH + DB_NAME ; checkDB = SQLiteDatabase . openDatabase ( path , null , SQLiteDatabase . OPEN_READONLY ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; Log . e ( STRING , STRING ) ; } if ( checkDB != null ) checkDB . close ( ) ; return checkDB != null ? _BOOL : _BOOL ; }
private boolean checkDatabase ( ) { SQLiteDatabase checkDB = null ; try { String path = DB_PATH + DB_NAME ; checkDB = SQLiteDatabase . openDatabase ( path , null , SQLiteDatabase . OPEN_READONLY ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; Log . e ( STRING , STRING ) ; } if ( checkDB != null ) checkDB . close ( ) ; return checkDB != null ? _BOOL : _BOOL ; }
public synchronized GcmHelper addOnMessageReceivedCallback ( @ NonNull GcmMessageListener messageReceivedListener ) { if ( null == messageReceivedCallbacks ) { messageReceivedCallbacks = new ConcurrentLinkedQueue < > ( ) ; } messageReceivedCallbacks . add ( messageReceivedListener ) ; return this ; }
public synchronized GcmHelper addOnMessageReceivedCallback ( @ NonNull GcmMessageListener messageReceivedListener ) { if ( null == messageReceivedCallbacks ) { messageReceivedCallbacks = new ConcurrentLinkedQueue < > ( ) ; } messageReceivedCallbacks . add ( messageReceivedListener ) ; return this ; }
public void append ( int key , E value ) { if ( mSize != _NUM && key <= mKeys [ mSize - _NUM ] ) { put ( key , value ) ; return ; } if ( mGarbage && mSize >= mKeys . length ) { gc ( ) ; } int pos = mSize ; if ( pos >= mKeys . length ) { int n = idealIntArraySize ( pos + _NUM ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( mKeys , _NUM , nkeys , _NUM , mKeys . length ) ; System . arraycopy ( mValues , _NUM , nvalues , _NUM , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } mKeys [ pos ] = key ; mValues [ pos ] = value ; mSize = pos + _NUM ; }
public void append ( int key , E value ) { if ( mSize != _NUM && key <= mKeys [ mSize - _NUM ] ) { put ( key , value ) ; return ; } if ( mGarbage && mSize >= mKeys . length ) { gc ( ) ; } int pos = mSize ; if ( pos >= mKeys . length ) { int n = idealIntArraySize ( pos + _NUM ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( mKeys , _NUM , nkeys , _NUM , mKeys . length ) ; System . arraycopy ( mValues , _NUM , nvalues , _NUM , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } mKeys [ pos ] = key ; mValues [ pos ] = value ; mSize = pos + _NUM ; }
public void append ( int key , E value ) { if ( mSize != _NUM && key <= mKeys [ mSize - _NUM ] ) { put ( key , value ) ; return ; } if ( mGarbage && mSize >= mKeys . length ) { gc ( ) ; } int pos = mSize ; if ( pos >= mKeys . length ) { int n = idealIntArraySize ( pos + _NUM ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( mKeys , _NUM , nkeys , _NUM , mKeys . length ) ; System . arraycopy ( mValues , _NUM , nvalues , _NUM , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } mKeys [ pos ] = key ; mValues [ pos ] = value ; mSize = pos + _NUM ; }
public int compareTo ( Object obj ) { int diff = - _NUM ; if ( obj instanceof ParserNotice ) { ParserNotice p2 = ( ParserNotice ) obj ; diff = level - p2 . getLevel ( ) ; if ( diff == _NUM ) { diff = line - p2 . getLine ( ) ; if ( diff == _NUM ) { diff = message . compareTo ( p2 . getMessage ( ) ) ; } } } return diff ; }
public void deregister ( Location location ) { if ( location == null ) { return ; } location . dispose ( ) ; Integer oldSize = Integer . valueOf ( _locationHashTable . size ( ) ) ; _locationHashTable . remove ( location . getId ( ) ) ; setDirtyAndFirePropertyChange ( LISTLENGTH_CHANGED_PROPERTY , oldSize , Integer . valueOf ( _locationHashTable . size ( ) ) ) ; }
public void deregister ( Location location ) { if ( location == null ) { return ; } location . dispose ( ) ; Integer oldSize = Integer . valueOf ( _locationHashTable . size ( ) ) ; _locationHashTable . remove ( location . getId ( ) ) ; setDirtyAndFirePropertyChange ( LISTLENGTH_CHANGED_PROPERTY , oldSize , Integer . valueOf ( _locationHashTable . size ( ) ) ) ; }
public void deregister ( Location location ) { if ( location == null ) { return ; } location . dispose ( ) ; Integer oldSize = Integer . valueOf ( _locationHashTable . size ( ) ) ; _locationHashTable . remove ( location . getId ( ) ) ; setDirtyAndFirePropertyChange ( LISTLENGTH_CHANGED_PROPERTY , oldSize , Integer . valueOf ( _locationHashTable . size ( ) ) ) ; }
public void addCoreCommandTagChanger ( final Long equipmentId , final ICoreCommandTagChanger commandTagChanger ) { List < ICoreCommandTagChanger > changers = coreCommandTagChangers . get ( equipmentId ) ; if ( changers == null ) { changers = new ArrayList < > ( ) ; coreCommandTagChangers . put ( equipmentId , changers ) ; } changers . add ( commandTagChanger ) ; }
public void onUpdateFromPeekToExpand ( float percentage ) { if ( ! isVisible ( ) ) return ; mHeightPx = Math . round ( MathUtils . interpolate ( mDefaultHeightPx , _NUM , percentage ) ) ; mTextOpacity = MathUtils . interpolate ( _NUM , _NUM , percentage ) ; }
public void onUpdateFromPeekToExpand ( float percentage ) { if ( ! isVisible ( ) ) return ; mHeightPx = Math . round ( MathUtils . interpolate ( mDefaultHeightPx , _NUM , percentage ) ) ; mTextOpacity = MathUtils . interpolate ( _NUM , _NUM , percentage ) ; }
public static byte [ ] generateRandomBytes ( final int numBytes ) { final SecureRandom rand = new SecureRandom ( ) ; final byte [ ] input = new byte [ numBytes ] ; rand . nextBytes ( input ) ; return input ; }
public static byte [ ] generateRandomBytes ( final int numBytes ) { final SecureRandom rand = new SecureRandom ( ) ; final byte [ ] input = new byte [ numBytes ] ; rand . nextBytes ( input ) ; return input ; }
private static void shrinkHeap ( TreeSet < DoubleDBIDPair > hotset , int k ) { ModifiableDBIDs seenids = DBIDUtil . newHashSet ( _NUM * k ) ; int cnt = _NUM ; for ( Iterator < DoubleDBIDPair > i = hotset . iterator ( ) ; i . hasNext ( ) ; ) { DoubleDBIDPair p = i . next ( ) ; if ( cnt > k || seenids . contains ( p ) ) { i . remove ( ) ; } else { seenids . add ( p ) ; cnt ++ ; } } }
protected void processConnectionEvent ( ConnectionEvent event ) { for ( Enumeration < ConnectionListener > e = connectionListeners . elements ( ) ; e . hasMoreElements ( ) ; ) { ConnectionListener l = e . nextElement ( ) ; switch ( event . getType ( ) ) { case ConnectionEvent . CONNECTED : l . connected ( ( ConnectedEvent ) event ) ; break ; case ConnectionEvent . DISCONNECTED : l . disconnected ( ( DisconnectedEvent ) event ) ; break ; case ConnectionEvent . PACKET_RECEIVED : l . packetReceived ( ( PacketReceivedEvent ) event ) ; break ; } } }
protected void processConnectionEvent ( ConnectionEvent event ) { for ( Enumeration < ConnectionListener > e = connectionListeners . elements ( ) ; e . hasMoreElements ( ) ; ) { ConnectionListener l = e . nextElement ( ) ; switch ( event . getType ( ) ) { case ConnectionEvent . CONNECTED : l . connected ( ( ConnectedEvent ) event ) ; break ; case ConnectionEvent . DISCONNECTED : l . disconnected ( ( DisconnectedEvent ) event ) ; break ; case ConnectionEvent . PACKET_RECEIVED : l . packetReceived ( ( PacketReceivedEvent ) event ) ; break ; } } }
protected void processConnectionEvent ( ConnectionEvent event ) { for ( Enumeration < ConnectionListener > e = connectionListeners . elements ( ) ; e . hasMoreElements ( ) ; ) { ConnectionListener l = e . nextElement ( ) ; switch ( event . getType ( ) ) { case ConnectionEvent . CONNECTED : l . connected ( ( ConnectedEvent ) event ) ; break ; case ConnectionEvent . DISCONNECTED : l . disconnected ( ( DisconnectedEvent ) event ) ; break ; case ConnectionEvent . PACKET_RECEIVED : l . packetReceived ( ( PacketReceivedEvent ) event ) ; break ; } } }
void logMemory ( Bench bench , String action ) { log ( bench . getName ( ) + STRING + action , STRING , TestBase . getMemoryUsed ( ) ) ; }
protected void a_processJunction_nns ( String name , Continuation cont ) throws NamingException { if ( name . equals ( STRING ) ) { NameNotFoundException e = new NameNotFoundException ( ) ; cont . setErrorNNS ( this , name ) ; throw cont . fillInException ( e ) ; } try { Object target = a_lookup ( name , cont ) ; if ( cont . isContinue ( ) ) cont . appendRemainingComponent ( STRING ) ; else { cont . setContinueNNS ( target , name , this ) ; } } catch ( NamingException e ) { e . appendRemainingComponent ( STRING ) ; throw e ; } }
protected void a_processJunction_nns ( String name , Continuation cont ) throws NamingException { if ( name . equals ( STRING ) ) { NameNotFoundException e = new NameNotFoundException ( ) ; cont . setErrorNNS ( this , name ) ; throw cont . fillInException ( e ) ; } try { Object target = a_lookup ( name , cont ) ; if ( cont . isContinue ( ) ) cont . appendRemainingComponent ( STRING ) ; else { cont . setContinueNNS ( target , name , this ) ; } } catch ( NamingException e ) { e . appendRemainingComponent ( STRING ) ; throw e ; } }
protected void a_processJunction_nns ( String name , Continuation cont ) throws NamingException { if ( name . equals ( STRING ) ) { NameNotFoundException e = new NameNotFoundException ( ) ; cont . setErrorNNS ( this , name ) ; throw cont . fillInException ( e ) ; } try { Object target = a_lookup ( name , cont ) ; if ( cont . isContinue ( ) ) cont . appendRemainingComponent ( STRING ) ; else { cont . setContinueNNS ( target , name , this ) ; } } catch ( NamingException e ) { e . appendRemainingComponent ( STRING ) ; throw e ; } }
protected void a_processJunction_nns ( String name , Continuation cont ) throws NamingException { if ( name . equals ( STRING ) ) { NameNotFoundException e = new NameNotFoundException ( ) ; cont . setErrorNNS ( this , name ) ; throw cont . fillInException ( e ) ; } try { Object target = a_lookup ( name , cont ) ; if ( cont . isContinue ( ) ) cont . appendRemainingComponent ( STRING ) ; else { cont . setContinueNNS ( target , name , this ) ; } } catch ( NamingException e ) { e . appendRemainingComponent ( STRING ) ; throw e ; } }
protected void a_processJunction_nns ( String name , Continuation cont ) throws NamingException { if ( name . equals ( STRING ) ) { NameNotFoundException e = new NameNotFoundException ( ) ; cont . setErrorNNS ( this , name ) ; throw cont . fillInException ( e ) ; } try { Object target = a_lookup ( name , cont ) ; if ( cont . isContinue ( ) ) cont . appendRemainingComponent ( STRING ) ; else { cont . setContinueNNS ( target , name , this ) ; } } catch ( NamingException e ) { e . appendRemainingComponent ( STRING ) ; throw e ; } }
protected void a_processJunction_nns ( String name , Continuation cont ) throws NamingException { if ( name . equals ( STRING ) ) { NameNotFoundException e = new NameNotFoundException ( ) ; cont . setErrorNNS ( this , name ) ; throw cont . fillInException ( e ) ; } try { Object target = a_lookup ( name , cont ) ; if ( cont . isContinue ( ) ) cont . appendRemainingComponent ( STRING ) ; else { cont . setContinueNNS ( target , name , this ) ; } } catch ( NamingException e ) { e . appendRemainingComponent ( STRING ) ; throw e ; } }
protected void a_processJunction_nns ( String name , Continuation cont ) throws NamingException { if ( name . equals ( STRING ) ) { NameNotFoundException e = new NameNotFoundException ( ) ; cont . setErrorNNS ( this , name ) ; throw cont . fillInException ( e ) ; } try { Object target = a_lookup ( name , cont ) ; if ( cont . isContinue ( ) ) cont . appendRemainingComponent ( STRING ) ; else { cont . setContinueNNS ( target , name , this ) ; } } catch ( NamingException e ) { e . appendRemainingComponent ( STRING ) ; throw e ; } }
protected void a_processJunction_nns ( String name , Continuation cont ) throws NamingException { if ( name . equals ( STRING ) ) { NameNotFoundException e = new NameNotFoundException ( ) ; cont . setErrorNNS ( this , name ) ; throw cont . fillInException ( e ) ; } try { Object target = a_lookup ( name , cont ) ; if ( cont . isContinue ( ) ) cont . appendRemainingComponent ( STRING ) ; else { cont . setContinueNNS ( target , name , this ) ; } } catch ( NamingException e ) { e . appendRemainingComponent ( STRING ) ; throw e ; } }
protected void a_processJunction_nns ( String name , Continuation cont ) throws NamingException { if ( name . equals ( STRING ) ) { NameNotFoundException e = new NameNotFoundException ( ) ; cont . setErrorNNS ( this , name ) ; throw cont . fillInException ( e ) ; } try { Object target = a_lookup ( name , cont ) ; if ( cont . isContinue ( ) ) cont . appendRemainingComponent ( STRING ) ; else { cont . setContinueNNS ( target , name , this ) ; } } catch ( NamingException e ) { e . appendRemainingComponent ( STRING ) ; throw e ; } }
protected void a_processJunction_nns ( String name , Continuation cont ) throws NamingException { if ( name . equals ( STRING ) ) { NameNotFoundException e = new NameNotFoundException ( ) ; cont . setErrorNNS ( this , name ) ; throw cont . fillInException ( e ) ; } try { Object target = a_lookup ( name , cont ) ; if ( cont . isContinue ( ) ) cont . appendRemainingComponent ( STRING ) ; else { cont . setContinueNNS ( target , name , this ) ; } } catch ( NamingException e ) { e . appendRemainingComponent ( STRING ) ; throw e ; } }
protected void a_processJunction_nns ( String name , Continuation cont ) throws NamingException { if ( name . equals ( STRING ) ) { NameNotFoundException e = new NameNotFoundException ( ) ; cont . setErrorNNS ( this , name ) ; throw cont . fillInException ( e ) ; } try { Object target = a_lookup ( name , cont ) ; if ( cont . isContinue ( ) ) cont . appendRemainingComponent ( STRING ) ; else { cont . setContinueNNS ( target , name , this ) ; } } catch ( NamingException e ) { e . appendRemainingComponent ( STRING ) ; throw e ; } }
protected void a_processJunction_nns ( String name , Continuation cont ) throws NamingException { if ( name . equals ( STRING ) ) { NameNotFoundException e = new NameNotFoundException ( ) ; cont . setErrorNNS ( this , name ) ; throw cont . fillInException ( e ) ; } try { Object target = a_lookup ( name , cont ) ; if ( cont . isContinue ( ) ) cont . appendRemainingComponent ( STRING ) ; else { cont . setContinueNNS ( target , name , this ) ; } } catch ( NamingException e ) { e . appendRemainingComponent ( STRING ) ; throw e ; } }
protected void a_processJunction_nns ( String name , Continuation cont ) throws NamingException { if ( name . equals ( STRING ) ) { NameNotFoundException e = new NameNotFoundException ( ) ; cont . setErrorNNS ( this , name ) ; throw cont . fillInException ( e ) ; } try { Object target = a_lookup ( name , cont ) ; if ( cont . isContinue ( ) ) cont . appendRemainingComponent ( STRING ) ; else { cont . setContinueNNS ( target , name , this ) ; } } catch ( NamingException e ) { e . appendRemainingComponent ( STRING ) ; throw e ; } }
protected void a_processJunction_nns ( String name , Continuation cont ) throws NamingException { if ( name . equals ( STRING ) ) { NameNotFoundException e = new NameNotFoundException ( ) ; cont . setErrorNNS ( this , name ) ; throw cont . fillInException ( e ) ; } try { Object target = a_lookup ( name , cont ) ; if ( cont . isContinue ( ) ) cont . appendRemainingComponent ( STRING ) ; else { cont . setContinueNNS ( target , name , this ) ; } } catch ( NamingException e ) { e . appendRemainingComponent ( STRING ) ; throw e ; } }
private static List < Comment > orderComments ( List < Comment > comments ) { Map < String , List < Comment > > parentMap = new HashMap < > ( ) ; List < Comment > rootComments = new ArrayList < > ( ) ; for ( Comment c : comments ) { String parentUuid = c . parentUuid ; List < Comment > l = parentMap . get ( parentUuid ) ; if ( l == null ) { l = new ArrayList < > ( ) ; parentMap . put ( parentUuid , l ) ; } l . add ( c ) ; if ( parentUuid == null ) { rootComments . add ( c ) ; } } List < Comment > result = new ArrayList < > ( ) ; addChildren ( parentMap , rootComments , result ) ; return result ; }
private static List < Comment > orderComments ( List < Comment > comments ) { Map < String , List < Comment > > parentMap = new HashMap < > ( ) ; List < Comment > rootComments = new ArrayList < > ( ) ; for ( Comment c : comments ) { String parentUuid = c . parentUuid ; List < Comment > l = parentMap . get ( parentUuid ) ; if ( l == null ) { l = new ArrayList < > ( ) ; parentMap . put ( parentUuid , l ) ; } l . add ( c ) ; if ( parentUuid == null ) { rootComments . add ( c ) ; } } List < Comment > result = new ArrayList < > ( ) ; addChildren ( parentMap , rootComments , result ) ; return result ; }
private static List < Comment > orderComments ( List < Comment > comments ) { Map < String , List < Comment > > parentMap = new HashMap < > ( ) ; List < Comment > rootComments = new ArrayList < > ( ) ; for ( Comment c : comments ) { String parentUuid = c . parentUuid ; List < Comment > l = parentMap . get ( parentUuid ) ; if ( l == null ) { l = new ArrayList < > ( ) ; parentMap . put ( parentUuid , l ) ; } l . add ( c ) ; if ( parentUuid == null ) { rootComments . add ( c ) ; } } List < Comment > result = new ArrayList < > ( ) ; addChildren ( parentMap , rootComments , result ) ; return result ; }
private static List < Comment > orderComments ( List < Comment > comments ) { Map < String , List < Comment > > parentMap = new HashMap < > ( ) ; List < Comment > rootComments = new ArrayList < > ( ) ; for ( Comment c : comments ) { String parentUuid = c . parentUuid ; List < Comment > l = parentMap . get ( parentUuid ) ; if ( l == null ) { l = new ArrayList < > ( ) ; parentMap . put ( parentUuid , l ) ; } l . add ( c ) ; if ( parentUuid == null ) { rootComments . add ( c ) ; } } List < Comment > result = new ArrayList < > ( ) ; addChildren ( parentMap , rootComments , result ) ; return result ; }
public void replaceAttributeValue ( String attrName , String oldValue , String newValue ) throws SMSException , SSOException { validateServiceConfigImpl ( ) ; Map attributes = getAttributes ( ) ; Set currentValues = ( Set ) attributes . get ( attrName ) ; if ( currentValues != null && ! currentValues . contains ( oldValue ) ) { throw ( new SMSException ( STRING , STRING ) ) ; } Set newVals = new HashSet ( ) ; Set oldVals = ( Set ) attributes . get ( attrName ) ; if ( oldVals != null ) { newVals . addAll ( oldVals ) ; newVals . remove ( oldValue ) ; } newVals . add ( newValue ) ; ss . validateAttrValues ( token , attrName , newVals , _BOOL , sc . getOrganizationName ( ) ) ; SMSEntry e = sc . getSMSEntry ( ) ; SMSUtils . replaceAttributeValue ( e , attrName , oldValue , newValue , ss . getSearchableAttributeNames ( ) ) ; saveSMSEntry ( e ) ; }
public void replaceAttributeValue ( String attrName , String oldValue , String newValue ) throws SMSException , SSOException { validateServiceConfigImpl ( ) ; Map attributes = getAttributes ( ) ; Set currentValues = ( Set ) attributes . get ( attrName ) ; if ( currentValues != null && ! currentValues . contains ( oldValue ) ) { throw ( new SMSException ( STRING , STRING ) ) ; } Set newVals = new HashSet ( ) ; Set oldVals = ( Set ) attributes . get ( attrName ) ; if ( oldVals != null ) { newVals . addAll ( oldVals ) ; newVals . remove ( oldValue ) ; } newVals . add ( newValue ) ; ss . validateAttrValues ( token , attrName , newVals , _BOOL , sc . getOrganizationName ( ) ) ; SMSEntry e = sc . getSMSEntry ( ) ; SMSUtils . replaceAttributeValue ( e , attrName , oldValue , newValue , ss . getSearchableAttributeNames ( ) ) ; saveSMSEntry ( e ) ; }
public static String [ ] arraySplit ( String s , char separatorChar , boolean trim ) { if ( s == null ) { return null ; } int length = s . length ( ) ; if ( length == _NUM ) { return new String [ _NUM ] ; } ArrayList < String > list = New . arrayList ( ) ; StringBuilder buff = new StringBuilder ( length ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = s . charAt ( i ) ; if ( c == separatorChar ) { String e = buff . toString ( ) ; list . add ( trim ? e . trim ( ) : e ) ; buff . setLength ( _NUM ) ; } else if ( c == STRING && i < length - _NUM ) { buff . append ( s . charAt ( ++ i ) ) ; } else { buff . append ( c ) ; } } String e = buff . toString ( ) ; list . add ( trim ? e . trim ( ) : e ) ; String [ ] array = new String [ list . size ( ) ] ; list . toArray ( array ) ; return array ; }
public static String [ ] arraySplit ( String s , char separatorChar , boolean trim ) { if ( s == null ) { return null ; } int length = s . length ( ) ; if ( length == _NUM ) { return new String [ _NUM ] ; } ArrayList < String > list = New . arrayList ( ) ; StringBuilder buff = new StringBuilder ( length ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = s . charAt ( i ) ; if ( c == separatorChar ) { String e = buff . toString ( ) ; list . add ( trim ? e . trim ( ) : e ) ; buff . setLength ( _NUM ) ; } else if ( c == STRING && i < length - _NUM ) { buff . append ( s . charAt ( ++ i ) ) ; } else { buff . append ( c ) ; } } String e = buff . toString ( ) ; list . add ( trim ? e . trim ( ) : e ) ; String [ ] array = new String [ list . size ( ) ] ; list . toArray ( array ) ; return array ; }
public static String [ ] arraySplit ( String s , char separatorChar , boolean trim ) { if ( s == null ) { return null ; } int length = s . length ( ) ; if ( length == _NUM ) { return new String [ _NUM ] ; } ArrayList < String > list = New . arrayList ( ) ; StringBuilder buff = new StringBuilder ( length ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = s . charAt ( i ) ; if ( c == separatorChar ) { String e = buff . toString ( ) ; list . add ( trim ? e . trim ( ) : e ) ; buff . setLength ( _NUM ) ; } else if ( c == STRING && i < length - _NUM ) { buff . append ( s . charAt ( ++ i ) ) ; } else { buff . append ( c ) ; } } String e = buff . toString ( ) ; list . add ( trim ? e . trim ( ) : e ) ; String [ ] array = new String [ list . size ( ) ] ; list . toArray ( array ) ; return array ; }
private int determineFinalHorizontalLocation ( ) { if ( mGestureState == GESTURE_FLINGING ) { float msRequired = calculateMsRequiredToFlingOffScreen ( ) ; if ( msRequired > MS_DISMISS_FLING_THRESHOLD ) return DRAGGED_CANCEL ; } else if ( mGestureState == GESTURE_SCROLLING ) { float dismissPercentage = DISMISS_SWIPE_THRESHOLD ; float dismissThreshold = getWidth ( ) * dismissPercentage ; if ( Math . abs ( getTranslationX ( ) ) < dismissThreshold ) return DRAGGED_CANCEL ; } return mDragDirection ; }
private int determineFinalHorizontalLocation ( ) { if ( mGestureState == GESTURE_FLINGING ) { float msRequired = calculateMsRequiredToFlingOffScreen ( ) ; if ( msRequired > MS_DISMISS_FLING_THRESHOLD ) return DRAGGED_CANCEL ; } else if ( mGestureState == GESTURE_SCROLLING ) { float dismissPercentage = DISMISS_SWIPE_THRESHOLD ; float dismissThreshold = getWidth ( ) * dismissPercentage ; if ( Math . abs ( getTranslationX ( ) ) < dismissThreshold ) return DRAGGED_CANCEL ; } return mDragDirection ; }
private int determineFinalHorizontalLocation ( ) { if ( mGestureState == GESTURE_FLINGING ) { float msRequired = calculateMsRequiredToFlingOffScreen ( ) ; if ( msRequired > MS_DISMISS_FLING_THRESHOLD ) return DRAGGED_CANCEL ; } else if ( mGestureState == GESTURE_SCROLLING ) { float dismissPercentage = DISMISS_SWIPE_THRESHOLD ; float dismissThreshold = getWidth ( ) * dismissPercentage ; if ( Math . abs ( getTranslationX ( ) ) < dismissThreshold ) return DRAGGED_CANCEL ; } return mDragDirection ; }
private int determineFinalHorizontalLocation ( ) { if ( mGestureState == GESTURE_FLINGING ) { float msRequired = calculateMsRequiredToFlingOffScreen ( ) ; if ( msRequired > MS_DISMISS_FLING_THRESHOLD ) return DRAGGED_CANCEL ; } else if ( mGestureState == GESTURE_SCROLLING ) { float dismissPercentage = DISMISS_SWIPE_THRESHOLD ; float dismissThreshold = getWidth ( ) * dismissPercentage ; if ( Math . abs ( getTranslationX ( ) ) < dismissThreshold ) return DRAGGED_CANCEL ; } return mDragDirection ; }
private int determineFinalHorizontalLocation ( ) { if ( mGestureState == GESTURE_FLINGING ) { float msRequired = calculateMsRequiredToFlingOffScreen ( ) ; if ( msRequired > MS_DISMISS_FLING_THRESHOLD ) return DRAGGED_CANCEL ; } else if ( mGestureState == GESTURE_SCROLLING ) { float dismissPercentage = DISMISS_SWIPE_THRESHOLD ; float dismissThreshold = getWidth ( ) * dismissPercentage ; if ( Math . abs ( getTranslationX ( ) ) < dismissThreshold ) return DRAGGED_CANCEL ; } return mDragDirection ; }
private int determineFinalHorizontalLocation ( ) { if ( mGestureState == GESTURE_FLINGING ) { float msRequired = calculateMsRequiredToFlingOffScreen ( ) ; if ( msRequired > MS_DISMISS_FLING_THRESHOLD ) return DRAGGED_CANCEL ; } else if ( mGestureState == GESTURE_SCROLLING ) { float dismissPercentage = DISMISS_SWIPE_THRESHOLD ; float dismissThreshold = getWidth ( ) * dismissPercentage ; if ( Math . abs ( getTranslationX ( ) ) < dismissThreshold ) return DRAGGED_CANCEL ; } return mDragDirection ; }
private int determineFinalHorizontalLocation ( ) { if ( mGestureState == GESTURE_FLINGING ) { float msRequired = calculateMsRequiredToFlingOffScreen ( ) ; if ( msRequired > MS_DISMISS_FLING_THRESHOLD ) return DRAGGED_CANCEL ; } else if ( mGestureState == GESTURE_SCROLLING ) { float dismissPercentage = DISMISS_SWIPE_THRESHOLD ; float dismissThreshold = getWidth ( ) * dismissPercentage ; if ( Math . abs ( getTranslationX ( ) ) < dismissThreshold ) return DRAGGED_CANCEL ; } return mDragDirection ; }
@ Override public int previous ( ) { CharacterIterator text = getText ( ) ; if ( current ( ) == text . getBeginIndex ( ) ) { return BreakIterator . DONE ; } int start = current ( ) ; int lastResult = cachedLastKnownBreak ; if ( lastResult >= start || lastResult <= BreakIterator . DONE ) { getPrevious ( ) ; lastResult = handlePrevious ( ) ; } else { text . setIndex ( lastResult ) ; } int result = lastResult ; while ( result != BreakIterator . DONE && result < start ) { lastResult = result ; result = handleNext ( ) ; } text . setIndex ( lastResult ) ; cachedLastKnownBreak = lastResult ; return lastResult ; }
@ Override public int previous ( ) { CharacterIterator text = getText ( ) ; if ( current ( ) == text . getBeginIndex ( ) ) { return BreakIterator . DONE ; } int start = current ( ) ; int lastResult = cachedLastKnownBreak ; if ( lastResult >= start || lastResult <= BreakIterator . DONE ) { getPrevious ( ) ; lastResult = handlePrevious ( ) ; } else { text . setIndex ( lastResult ) ; } int result = lastResult ; while ( result != BreakIterator . DONE && result < start ) { lastResult = result ; result = handleNext ( ) ; } text . setIndex ( lastResult ) ; cachedLastKnownBreak = lastResult ; return lastResult ; }
@ Override public int previous ( ) { CharacterIterator text = getText ( ) ; if ( current ( ) == text . getBeginIndex ( ) ) { return BreakIterator . DONE ; } int start = current ( ) ; int lastResult = cachedLastKnownBreak ; if ( lastResult >= start || lastResult <= BreakIterator . DONE ) { getPrevious ( ) ; lastResult = handlePrevious ( ) ; } else { text . setIndex ( lastResult ) ; } int result = lastResult ; while ( result != BreakIterator . DONE && result < start ) { lastResult = result ; result = handleNext ( ) ; } text . setIndex ( lastResult ) ; cachedLastKnownBreak = lastResult ; return lastResult ; }
@ SuppressWarnings ( STRING ) public T read ( File file ) { Preconditions . checkNotNull ( file ) ; try ( InputStream stream = new FileInputStream ( file ) ) { return ( T ) yamlParser . load ( stream ) ; } catch ( IOException e ) { throw new RuntimeException ( STRING + file . getName ( ) , e ) ; } }
public static void putFloatLE ( long addr , float val ) { int intVal = Float . floatToIntBits ( val ) ; if ( UNALIGNED ) UNSAFE . putInt ( addr , Integer . reverseBytes ( intVal ) ) ; else putIntByByte ( addr , intVal , _BOOL ) ; }
public static void putFloatLE ( long addr , float val ) { int intVal = Float . floatToIntBits ( val ) ; if ( UNALIGNED ) UNSAFE . putInt ( addr , Integer . reverseBytes ( intVal ) ) ; else putIntByByte ( addr , intVal , _BOOL ) ; }
public static void putFloatLE ( long addr , float val ) { int intVal = Float . floatToIntBits ( val ) ; if ( UNALIGNED ) UNSAFE . putInt ( addr , Integer . reverseBytes ( intVal ) ) ; else putIntByByte ( addr , intVal , _BOOL ) ; }
public boolean spans ( String other ) { return spans ( other , _BOOL ) ; }
public boolean spans ( String other ) { return spans ( other , _BOOL ) ; }
@ SuppressWarnings ( STRING ) public static < T > TypeSerializer < T > deserialize ( byte [ ] bytes ) throws IOException { ByteArrayInputStream bis = new ByteArrayInputStream ( bytes ) ; ObjectInput in = null ; try { in = new ObjectInputStream ( bis ) ; return ( TypeSerializer < T > ) in . readObject ( ) ; } catch ( ClassNotFoundException e ) { throw new IOException ( STRING ) ; } finally { try { bis . close ( ) ; } catch ( IOException ex ) { } try { if ( in != null ) { in . close ( ) ; } } catch ( IOException ex ) { } } }
public String generateShortUpgradeReport ( SSOToken adminToken , boolean html ) { String delimiter = html ? HTML_BR : TXT_LF ; StringBuilder report = new StringBuilder ( ) ; for ( UpgradeStep upgradeStep : upgradeSteps ) { report . append ( upgradeStep . getShortReport ( delimiter ) ) ; } return report . toString ( ) ; }
@ Override public void apply ( NexusStreamParser np ) throws Exception { np . matchIgnoreCase ( STRING ) ; String shapeName = np . getWordMatchesIgnoringCase ( STRING ) ; np . matchIgnoreCase ( STRING ) ; byte shape ; if ( shapeName . equalsIgnoreCase ( STRING ) ) shape = EdgeView . ARC_LINE_EDGE ; else if ( shapeName . equalsIgnoreCase ( STRING ) ) shape = EdgeView . STRAIGHT_EDGE ; else if ( shapeName . equalsIgnoreCase ( STRING ) ) shape = EdgeView . QUAD_EDGE ; else shape = _NUM ; if ( getViewer ( ) instanceof GraphView ) { boolean changed = _BOOL ; GraphView viewer = ( GraphView ) getViewer ( ) ; for ( Edge e : viewer . getSelectedEdges ( ) ) { viewer . setShape ( e , shape ) ; changed = _BOOL ; } if ( changed ) { viewer . repaint ( ) ; } } }
@ Override synchronized public final boolean isRegistered ( ) { return ! keyList . isEmpty ( ) ; }
public static double calculateTestStatistic ( double [ ] sample1 , double [ ] sample2 ) { double maximum = _NUM ; int index1 = _NUM , index2 = _NUM ; double cdf1 = _NUM , cdf2 = _NUM ; while ( index1 < sample1 . length && index2 < sample2 . length ) { final double x1 = sample1 [ index1 ] , x2 = sample2 [ index2 ] ; if ( x1 <= x2 ) { index1 ++ ; while ( index1 < sample1 . length && sample1 [ index1 ] == x1 ) { index1 ++ ; } cdf1 = ( ( double ) index1 + _NUM ) / ( sample1 . length + _NUM ) ; } if ( x1 >= x2 ) { index2 ++ ; while ( index2 < sample2 . length && sample2 [ index2 ] == x2 ) { index2 ++ ; } cdf2 = ( ( double ) index2 + _NUM ) / ( sample2 . length + _NUM ) ; } maximum = Math . max ( maximum , Math . abs ( cdf1 - cdf2 ) ) ; } return maximum ; }
@ Override public void addTestSetListener ( TestSetListener tsl ) { m_testSetListeners . addElement ( tsl ) ; if ( m_format != null ) { TestSetEvent e = new TestSetEvent ( this , m_format ) ; tsl . acceptTestSet ( e ) ; } }
public synchronized IAudioProvider remove ( int index ) { return providers . remove ( index ) ; }
public synchronized IAudioProvider remove ( int index ) { return providers . remove ( index ) ; }
public int size ( ) { return _attrs . size ( ) ; }
void reset ( ) { System . arraycopy ( iv , _NUM , register , _NUM , blockSize ) ; }
void reset ( ) { System . arraycopy ( iv , _NUM , register , _NUM , blockSize ) ; }
void reset ( ) { System . arraycopy ( iv , _NUM , register , _NUM , blockSize ) ; }
public static EndpointEntry lookup ( Endpoint ep ) { synchronized ( endpointTable ) { EndpointEntry entry = endpointTable . get ( ep ) ; if ( entry == null ) { entry = new EndpointEntry ( ep ) ; endpointTable . put ( ep , entry ) ; if ( gcLatencyRequest == null ) { gcLatencyRequest = GC . requestLatency ( gcInterval ) ; } } return entry ; } }
@ SuppressWarnings ( STRING ) public Object [ ] toArray ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = _NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
@ SuppressWarnings ( STRING ) public Object [ ] toArray ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = _NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
@ SuppressWarnings ( STRING ) public Object [ ] toArray ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = _NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
@ SuppressWarnings ( STRING ) public Object [ ] toArray ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = _NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
@ SuppressWarnings ( STRING ) public Object [ ] toArray ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = _NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
@ SuppressWarnings ( STRING ) public Object [ ] toArray ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = _NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
public SpatialIndex ( String shpFilename ) throws IOException { this . shpFileName = shpFilename ; if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STRING + shpFilename + STRING ) ; } }
public static long toAddress ( Object obj ) { Object [ ] array = new Object [ ] { obj } ; long baseOffset = unsafe . arrayBaseOffset ( Object [ ] . class ) ; return normalize ( unsafe . getInt ( array , baseOffset ) ) ; }
public static long toAddress ( Object obj ) { Object [ ] array = new Object [ ] { obj } ; long baseOffset = unsafe . arrayBaseOffset ( Object [ ] . class ) ; return normalize ( unsafe . getInt ( array , baseOffset ) ) ; }
protected void processUpdates ( Queue < DeviceUpdate > updates ) { if ( updates == null ) return ; DeviceUpdate update = null ; while ( null != ( update = updates . poll ( ) ) ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( STRING , update ) ; } if ( update . change == DeviceUpdate . Change . DELETE ) deviceSyncManager . removeDevice ( update . device ) ; else deviceSyncManager . storeDevice ( update . device ) ; List < IDeviceListener > listeners = deviceListeners . getOrderedListeners ( ) ; notifyListeners ( listeners , update ) ; } }
public static final void removeSelection ( Spannable text ) { text . removeSpan ( SELECTION_START ) ; text . removeSpan ( SELECTION_END ) ; }
public SearchSourceBuilder query ( String queryString ) { return query ( queryString . getBytes ( Charsets . UTF_8 ) ) ; }
public void insert ( int elem ) { heap = Arrays . copyOf ( heap , size + _NUM ) ; int i = size ; int parentIndex = ( int ) Math . floor ( ( i - _NUM ) / _NUM ) ; while ( i > _NUM && elem > heap [ parentIndex ] ) { heap [ i ] = heap [ parentIndex ] ; i = parentIndex ; parentIndex = ( int ) Math . floor ( ( i - _NUM ) / _NUM ) ; } heap [ i ] = elem ; size ++ ; }
private void addConnections ( Collection < Connection > connections ) throws GuacamoleException { for ( Connection connection : connections ) { APIConnectionGroup parent = retrievedGroups . get ( connection . getParentIdentifier ( ) ) ; if ( parent != null ) { Collection < APIConnection > children = parent . getChildConnections ( ) ; if ( children == null ) { children = new ArrayList < APIConnection > ( ) ; parent . setChildConnections ( children ) ; } APIConnection apiConnection = new APIConnection ( connection ) ; retrievedConnections . put ( connection . getIdentifier ( ) , apiConnection ) ; children . add ( apiConnection ) ; } else logger . debug ( STRING , connection . getIdentifier ( ) , connection . getParentIdentifier ( ) ) ; } }
public void selectObject ( Object element ) { if ( controlShown ) { int index = objectsInCombo . indexOf ( element ) ; if ( index != - _NUM ) { objectSelection . select ( index ) ; } } }
protected static boolean hasEncodedTagValue ( Object obj , int tagValue ) { return ( obj instanceof byte [ ] ) && ( ( byte [ ] ) obj ) [ _NUM ] == tagValue ; }
protected static boolean hasEncodedTagValue ( Object obj , int tagValue ) { return ( obj instanceof byte [ ] ) && ( ( byte [ ] ) obj ) [ _NUM ] == tagValue ; }
private boolean searchPage ( final int page , final int currentKey , final ObservableList < String > resultListModel ) throws Exception { final PdfPageData currentPageData = decode_pdf . getPdfPageData ( ) ; final int x1 = currentPageData . getMediaBoxX ( page ) ; final int x2 = currentPageData . getMediaBoxWidth ( page ) + x1 ; final int y2 = currentPageData . getMediaBoxY ( page ) ; final int y1 = currentPageData . getMediaBoxHeight ( page ) + y2 ; return searchPage ( page , x1 , y1 , x2 , y2 , currentKey , resultListModel ) ; }
public void test_multipleResourceLocking_resources3_locktries_3 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . setProperty ( TestOptions . NTHREADS , STRING ) ; properties . setProperty ( TestOptions . NTASKS , STRING ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCK_TRIES , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; doComparisonTest ( properties ) ; }
public void test_multipleResourceLocking_resources3_locktries_3 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . setProperty ( TestOptions . NTHREADS , STRING ) ; properties . setProperty ( TestOptions . NTASKS , STRING ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCK_TRIES , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; doComparisonTest ( properties ) ; }
public void test_multipleResourceLocking_resources3_locktries_3 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . setProperty ( TestOptions . NTHREADS , STRING ) ; properties . setProperty ( TestOptions . NTASKS , STRING ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCK_TRIES , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; doComparisonTest ( properties ) ; }
public void test_multipleResourceLocking_resources3_locktries_3 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . setProperty ( TestOptions . NTHREADS , STRING ) ; properties . setProperty ( TestOptions . NTASKS , STRING ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCK_TRIES , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; doComparisonTest ( properties ) ; }
public void test_multipleResourceLocking_resources3_locktries_3 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . setProperty ( TestOptions . NTHREADS , STRING ) ; properties . setProperty ( TestOptions . NTASKS , STRING ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCK_TRIES , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; doComparisonTest ( properties ) ; }
public boolean isSignatureValid ( String signature , String data ) { if ( ! signature . isEmpty ( ) ) { RSATool tool = RSAToolFactory . getRSATool ( ) ; RSAKey thePublicKey = new RSAKeyImpl ( theCertificate . getPublicKey ( ) ) ; try { String hash = DigestUtils . sha256Hex ( data ) ; return tool . verifyWithKey ( StringUtils . getBytesUtf8 ( hash ) , Base64 . decode ( signature ) , thePublicKey ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; } } return _BOOL ; }
public Sort ( ) { this ( new String [ _NUM ] , new boolean [ _NUM ] ) ; }
public final void addPane ( final OptionsPane pane ) { MAIN_PANEL . add ( pane . getContainer ( ) , pane . getName ( ) ) ; OPTIONS_PANE_LIST . add ( pane ) ; }
private boolean matchAtom ( ContentType acceptedContentType ) { String atomType = getAttribute ( STRING ) ; String acceptedAtomType = acceptedContentType . getAttribute ( STRING ) ; return atomType == null || acceptedAtomType == null || atomType . equals ( acceptedAtomType ) ; }
private boolean matchAtom ( ContentType acceptedContentType ) { String atomType = getAttribute ( STRING ) ; String acceptedAtomType = acceptedContentType . getAttribute ( STRING ) ; return atomType == null || acceptedAtomType == null || atomType . equals ( acceptedAtomType ) ; }
private boolean matchAtom ( ContentType acceptedContentType ) { String atomType = getAttribute ( STRING ) ; String acceptedAtomType = acceptedContentType . getAttribute ( STRING ) ; return atomType == null || acceptedAtomType == null || atomType . equals ( acceptedAtomType ) ; }
public Composer arc ( long animDuration , float x , float y , float angle , Ease ease ) { AnimParameter beforeParam = mTweenParameterList . size ( ) > _NUM ? mTweenParameterList . get ( mTweenParameterList . size ( ) - _NUM ) : mInitialParam ; if ( angle < _NUM && angle > - _NUM ) { return to ( animDuration , x , y , beforeParam . alpha , beforeParam . scaleX , beforeParam . scaleY , beforeParam . rotation , ease ) ; } return arc ( animDuration , x , y , angle , beforeParam . alpha , beforeParam . scaleX , beforeParam . scaleY , beforeParam . rotation , ease ) ; }
public Composer arc ( long animDuration , float x , float y , float angle , Ease ease ) { AnimParameter beforeParam = mTweenParameterList . size ( ) > _NUM ? mTweenParameterList . get ( mTweenParameterList . size ( ) - _NUM ) : mInitialParam ; if ( angle < _NUM && angle > - _NUM ) { return to ( animDuration , x , y , beforeParam . alpha , beforeParam . scaleX , beforeParam . scaleY , beforeParam . rotation , ease ) ; } return arc ( animDuration , x , y , angle , beforeParam . alpha , beforeParam . scaleX , beforeParam . scaleY , beforeParam . rotation , ease ) ; }
public static XMLGregorianCalendar parseCalendar ( String s ) { return dtFactory . newXMLGregorianCalendar ( s ) ; }
public static XMLGregorianCalendar parseCalendar ( String s ) { return dtFactory . newXMLGregorianCalendar ( s ) ; }
@ Deprecated public static AttributeDescription create ( final String attributeName , final AttributeType attributeType , final String ... options ) { Reject . ifNull ( options ) ; return create ( attributeName , attributeType , Arrays . asList ( options ) ) ; }
public void annotationAdded ( Annotation annotation ) { addedAnnotations . add ( annotation ) ; }
public void annotationAdded ( Annotation annotation ) { addedAnnotations . add ( annotation ) ; }
public void annotationAdded ( Annotation annotation ) { addedAnnotations . add ( annotation ) ; }
long resizeLun ( long size , boolean force ) { NaElement elem = new NaElement ( STRING ) ; elem . addNewChild ( STRING , Boolean . toString ( force ) ) ; elem . addNewChild ( STRING , path ) ; elem . addNewChild ( STRING , Long . toString ( size ) ) ; NaElement result = null ; try { result = server . invokeElem ( elem ) ; return result . getChildLongValue ( STRING , - _NUM ) ; } catch ( Exception e ) { String msg = STRING + path ; log . error ( msg , e ) ; throw new NetAppException ( msg , e ) ; } }
private boolean isReadyToBeExecutedLocked ( JobStatus job ) { final boolean jobReady = job . isReady ( ) ; final boolean jobPending = mPendingJobs . contains ( job ) ; final boolean jobActive = isCurrentlyActiveLocked ( job ) ; final boolean userRunning = mStartedUsers . contains ( job . getUserId ( ) ) ; return userRunning && jobReady && ! jobPending && ! jobActive ; }
private boolean isReadyToBeExecutedLocked ( JobStatus job ) { final boolean jobReady = job . isReady ( ) ; final boolean jobPending = mPendingJobs . contains ( job ) ; final boolean jobActive = isCurrentlyActiveLocked ( job ) ; final boolean userRunning = mStartedUsers . contains ( job . getUserId ( ) ) ; return userRunning && jobReady && ! jobPending && ! jobActive ; }
private boolean isReadyToBeExecutedLocked ( JobStatus job ) { final boolean jobReady = job . isReady ( ) ; final boolean jobPending = mPendingJobs . contains ( job ) ; final boolean jobActive = isCurrentlyActiveLocked ( job ) ; final boolean userRunning = mStartedUsers . contains ( job . getUserId ( ) ) ; return userRunning && jobReady && ! jobPending && ! jobActive ; }
private boolean isReadyToBeExecutedLocked ( JobStatus job ) { final boolean jobReady = job . isReady ( ) ; final boolean jobPending = mPendingJobs . contains ( job ) ; final boolean jobActive = isCurrentlyActiveLocked ( job ) ; final boolean userRunning = mStartedUsers . contains ( job . getUserId ( ) ) ; return userRunning && jobReady && ! jobPending && ! jobActive ; }
private boolean isReadyToBeExecutedLocked ( JobStatus job ) { final boolean jobReady = job . isReady ( ) ; final boolean jobPending = mPendingJobs . contains ( job ) ; final boolean jobActive = isCurrentlyActiveLocked ( job ) ; final boolean userRunning = mStartedUsers . contains ( job . getUserId ( ) ) ; return userRunning && jobReady && ! jobPending && ! jobActive ; }
public void enqueue ( TerminatingRunnable r ) { synchronized ( queue ) { queue . add ( r ) ; queue . notifyAll ( ) ; } }
public static double mean ( final List < Double > list ) { double sum = _NUM ; for ( Double number : list ) { sum += number ; } return sum / list . size ( ) ; }
private Poi savePoiNoTransaction ( Poi poi ) { List < PoiTag > poiTagsToRemove = poiTagDao . queryByPoiId ( poi . getId ( ) ) ; poiTagsToRemove . removeAll ( poi . getTags ( ) ) ; for ( PoiTag poiTag : poiTagsToRemove ) { poiTagDao . delete ( poiTag ) ; } List < PoiNodeRef > poiNodeRefsToRemove = poiNodeRefDao . queryByPoiId ( poi . getId ( ) ) ; poiNodeRefsToRemove . removeAll ( poi . getNodeRefs ( ) ) ; for ( PoiNodeRef poiNodeRef : poiNodeRefsToRemove ) { poiNodeRefDao . delete ( poiNodeRef ) ; } poiDao . createOrUpdate ( poi ) ; if ( poi . getTags ( ) != null ) { for ( PoiTag poiTag : poi . getTags ( ) ) { poiTag . setPoi ( poi ) ; poiTagDao . createOrUpdate ( poiTag ) ; } } if ( poi . getNodeRefs ( ) != null ) { for ( PoiNodeRef poiNodeRef : poi . getNodeRefs ( ) ) { poiNodeRef . setPoi ( poi ) ; poiNodeRefDao . createOrUpdate ( poiNodeRef ) ; } } return poi ; }
private Poi savePoiNoTransaction ( Poi poi ) { List < PoiTag > poiTagsToRemove = poiTagDao . queryByPoiId ( poi . getId ( ) ) ; poiTagsToRemove . removeAll ( poi . getTags ( ) ) ; for ( PoiTag poiTag : poiTagsToRemove ) { poiTagDao . delete ( poiTag ) ; } List < PoiNodeRef > poiNodeRefsToRemove = poiNodeRefDao . queryByPoiId ( poi . getId ( ) ) ; poiNodeRefsToRemove . removeAll ( poi . getNodeRefs ( ) ) ; for ( PoiNodeRef poiNodeRef : poiNodeRefsToRemove ) { poiNodeRefDao . delete ( poiNodeRef ) ; } poiDao . createOrUpdate ( poi ) ; if ( poi . getTags ( ) != null ) { for ( PoiTag poiTag : poi . getTags ( ) ) { poiTag . setPoi ( poi ) ; poiTagDao . createOrUpdate ( poiTag ) ; } } if ( poi . getNodeRefs ( ) != null ) { for ( PoiNodeRef poiNodeRef : poi . getNodeRefs ( ) ) { poiNodeRef . setPoi ( poi ) ; poiNodeRefDao . createOrUpdate ( poiNodeRef ) ; } } return poi ; }
private Poi savePoiNoTransaction ( Poi poi ) { List < PoiTag > poiTagsToRemove = poiTagDao . queryByPoiId ( poi . getId ( ) ) ; poiTagsToRemove . removeAll ( poi . getTags ( ) ) ; for ( PoiTag poiTag : poiTagsToRemove ) { poiTagDao . delete ( poiTag ) ; } List < PoiNodeRef > poiNodeRefsToRemove = poiNodeRefDao . queryByPoiId ( poi . getId ( ) ) ; poiNodeRefsToRemove . removeAll ( poi . getNodeRefs ( ) ) ; for ( PoiNodeRef poiNodeRef : poiNodeRefsToRemove ) { poiNodeRefDao . delete ( poiNodeRef ) ; } poiDao . createOrUpdate ( poi ) ; if ( poi . getTags ( ) != null ) { for ( PoiTag poiTag : poi . getTags ( ) ) { poiTag . setPoi ( poi ) ; poiTagDao . createOrUpdate ( poiTag ) ; } } if ( poi . getNodeRefs ( ) != null ) { for ( PoiNodeRef poiNodeRef : poi . getNodeRefs ( ) ) { poiNodeRef . setPoi ( poi ) ; poiNodeRefDao . createOrUpdate ( poiNodeRef ) ; } } return poi ; }
private Poi savePoiNoTransaction ( Poi poi ) { List < PoiTag > poiTagsToRemove = poiTagDao . queryByPoiId ( poi . getId ( ) ) ; poiTagsToRemove . removeAll ( poi . getTags ( ) ) ; for ( PoiTag poiTag : poiTagsToRemove ) { poiTagDao . delete ( poiTag ) ; } List < PoiNodeRef > poiNodeRefsToRemove = poiNodeRefDao . queryByPoiId ( poi . getId ( ) ) ; poiNodeRefsToRemove . removeAll ( poi . getNodeRefs ( ) ) ; for ( PoiNodeRef poiNodeRef : poiNodeRefsToRemove ) { poiNodeRefDao . delete ( poiNodeRef ) ; } poiDao . createOrUpdate ( poi ) ; if ( poi . getTags ( ) != null ) { for ( PoiTag poiTag : poi . getTags ( ) ) { poiTag . setPoi ( poi ) ; poiTagDao . createOrUpdate ( poiTag ) ; } } if ( poi . getNodeRefs ( ) != null ) { for ( PoiNodeRef poiNodeRef : poi . getNodeRefs ( ) ) { poiNodeRef . setPoi ( poi ) ; poiNodeRefDao . createOrUpdate ( poiNodeRef ) ; } } return poi ; }
private Poi savePoiNoTransaction ( Poi poi ) { List < PoiTag > poiTagsToRemove = poiTagDao . queryByPoiId ( poi . getId ( ) ) ; poiTagsToRemove . removeAll ( poi . getTags ( ) ) ; for ( PoiTag poiTag : poiTagsToRemove ) { poiTagDao . delete ( poiTag ) ; } List < PoiNodeRef > poiNodeRefsToRemove = poiNodeRefDao . queryByPoiId ( poi . getId ( ) ) ; poiNodeRefsToRemove . removeAll ( poi . getNodeRefs ( ) ) ; for ( PoiNodeRef poiNodeRef : poiNodeRefsToRemove ) { poiNodeRefDao . delete ( poiNodeRef ) ; } poiDao . createOrUpdate ( poi ) ; if ( poi . getTags ( ) != null ) { for ( PoiTag poiTag : poi . getTags ( ) ) { poiTag . setPoi ( poi ) ; poiTagDao . createOrUpdate ( poiTag ) ; } } if ( poi . getNodeRefs ( ) != null ) { for ( PoiNodeRef poiNodeRef : poi . getNodeRefs ( ) ) { poiNodeRef . setPoi ( poi ) ; poiNodeRefDao . createOrUpdate ( poiNodeRef ) ; } } return poi ; }
private Poi savePoiNoTransaction ( Poi poi ) { List < PoiTag > poiTagsToRemove = poiTagDao . queryByPoiId ( poi . getId ( ) ) ; poiTagsToRemove . removeAll ( poi . getTags ( ) ) ; for ( PoiTag poiTag : poiTagsToRemove ) { poiTagDao . delete ( poiTag ) ; } List < PoiNodeRef > poiNodeRefsToRemove = poiNodeRefDao . queryByPoiId ( poi . getId ( ) ) ; poiNodeRefsToRemove . removeAll ( poi . getNodeRefs ( ) ) ; for ( PoiNodeRef poiNodeRef : poiNodeRefsToRemove ) { poiNodeRefDao . delete ( poiNodeRef ) ; } poiDao . createOrUpdate ( poi ) ; if ( poi . getTags ( ) != null ) { for ( PoiTag poiTag : poi . getTags ( ) ) { poiTag . setPoi ( poi ) ; poiTagDao . createOrUpdate ( poiTag ) ; } } if ( poi . getNodeRefs ( ) != null ) { for ( PoiNodeRef poiNodeRef : poi . getNodeRefs ( ) ) { poiNodeRef . setPoi ( poi ) ; poiNodeRefDao . createOrUpdate ( poiNodeRef ) ; } } return poi ; }
public String createTable ( Table table ) { StringBuilder ddl = new StringBuilder ( ) ; createTable ( table , ddl , _BOOL , _BOOL ) ; return ddl . toString ( ) ; }
public DNetscapeBaseUrl ( JDialog parent ) { super ( parent ) ; setTitle ( res . getString ( STRING ) ) ; initComponents ( ) ; }
public static String trim ( String str , CharacterPredicate predicate ) { int len = str . length ( ) ; if ( len == _NUM ) return str ; int st = _NUM ; while ( ( st < len ) && predicate . test ( str . charAt ( st ) ) ) { st ++ ; } while ( ( st < len ) && predicate . test ( str . charAt ( len - _NUM ) ) ) { len -- ; } return ( ( st > _NUM ) || ( len < str . length ( ) ) ) ? str . substring ( st , len ) : str ; }
public static String trim ( String str , CharacterPredicate predicate ) { int len = str . length ( ) ; if ( len == _NUM ) return str ; int st = _NUM ; while ( ( st < len ) && predicate . test ( str . charAt ( st ) ) ) { st ++ ; } while ( ( st < len ) && predicate . test ( str . charAt ( len - _NUM ) ) ) { len -- ; } return ( ( st > _NUM ) || ( len < str . length ( ) ) ) ? str . substring ( st , len ) : str ; }
public static String trim ( String str , CharacterPredicate predicate ) { int len = str . length ( ) ; if ( len == _NUM ) return str ; int st = _NUM ; while ( ( st < len ) && predicate . test ( str . charAt ( st ) ) ) { st ++ ; } while ( ( st < len ) && predicate . test ( str . charAt ( len - _NUM ) ) ) { len -- ; } return ( ( st > _NUM ) || ( len < str . length ( ) ) ) ? str . substring ( st , len ) : str ; }
public XintroActivityBuilder addFragment ( IntroFragmentModel introFragmentModel ) { introFragmentModelList . add ( introFragmentModel ) ; return this ; }
public void writeOne ( int opswIndex ) { try { setAddress ( _NUM ) ; } catch ( Exception e ) { if ( log . isDebugEnabled ( ) ) { log . debug ( rb . getString ( STRING ) + STRING + e ) ; } readAllButton . setSelected ( _BOOL ) ; writeAllButton . setSelected ( _BOOL ) ; status . setText ( STRING ) ; return ; } copyToOpsw ( ) ; read = _BOOL ; state = opswIndex ; onlyOneOperation = _BOOL ; nextRequest ( ) ; }
public static void addServersToSite ( SSOToken ssoToken , String siteName , Collection serverInstanceNames ) throws SMSException , SSOException , ConfigurationException { String siteId = getSiteId ( ssoToken , siteName ) ; if ( siteId != null ) { for ( Iterator i = serverInstanceNames . iterator ( ) ; i . hasNext ( ) ; ) { String svr = ( String ) i . next ( ) ; ServerConfiguration . addToSite ( ssoToken , svr , siteName ) ; } } }
public void removeColumn ( final String columnName ) { if ( columnName == null ) { return ; } final List < String > cols = Arrays . asList ( getInfo ( ) . headers ) ; final int colIndex = cols . indexOf ( columnName ) ; removeColumn ( colIndex ) ; }
public void removeColumn ( final String columnName ) { if ( columnName == null ) { return ; } final List < String > cols = Arrays . asList ( getInfo ( ) . headers ) ; final int colIndex = cols . indexOf ( columnName ) ; removeColumn ( colIndex ) ; }
public void addCallback ( Callback callback ) { if ( ! mCallbacks . contains ( callback ) ) { mCallbacks . add ( callback ) ; } }
IndexEntry ( ByteProvider byteProvider ) throws IOException { MXFPropertyPopulator . populateField ( byteProvider , this , STRING ) ; MXFPropertyPopulator . populateField ( byteProvider , this , STRING ) ; MXFPropertyPopulator . populateField ( byteProvider , this , STRING ) ; MXFPropertyPopulator . populateField ( byteProvider , this , STRING ) ; }
protected void processBDDPLists ( ) { int count = _NUM ; Set < NodePortTuple > nptList = new HashSet < NodePortTuple > ( ) ; while ( count < BDDP_TASK_SIZE && quarantineQueue . peek ( ) != null ) { NodePortTuple npt ; npt = quarantineQueue . remove ( ) ; sendDiscoveryMessage ( npt . getNodeId ( ) , npt . getPortId ( ) , _BOOL , _BOOL ) ; nptList . add ( npt ) ; count ++ ; } count = _NUM ; while ( count < BDDP_TASK_SIZE && maintenanceQueue . peek ( ) != null ) { NodePortTuple npt ; npt = maintenanceQueue . remove ( ) ; sendDiscoveryMessage ( npt . getNodeId ( ) , npt . getPortId ( ) , _BOOL , _BOOL ) ; count ++ ; } for ( NodePortTuple npt : nptList ) { generateSwitchPortStatusUpdate ( npt . getNodeId ( ) , npt . getPortId ( ) ) ; } }
protected void processBDDPLists ( ) { int count = _NUM ; Set < NodePortTuple > nptList = new HashSet < NodePortTuple > ( ) ; while ( count < BDDP_TASK_SIZE && quarantineQueue . peek ( ) != null ) { NodePortTuple npt ; npt = quarantineQueue . remove ( ) ; sendDiscoveryMessage ( npt . getNodeId ( ) , npt . getPortId ( ) , _BOOL , _BOOL ) ; nptList . add ( npt ) ; count ++ ; } count = _NUM ; while ( count < BDDP_TASK_SIZE && maintenanceQueue . peek ( ) != null ) { NodePortTuple npt ; npt = maintenanceQueue . remove ( ) ; sendDiscoveryMessage ( npt . getNodeId ( ) , npt . getPortId ( ) , _BOOL , _BOOL ) ; count ++ ; } for ( NodePortTuple npt : nptList ) { generateSwitchPortStatusUpdate ( npt . getNodeId ( ) , npt . getPortId ( ) ) ; } }
protected void processBDDPLists ( ) { int count = _NUM ; Set < NodePortTuple > nptList = new HashSet < NodePortTuple > ( ) ; while ( count < BDDP_TASK_SIZE && quarantineQueue . peek ( ) != null ) { NodePortTuple npt ; npt = quarantineQueue . remove ( ) ; sendDiscoveryMessage ( npt . getNodeId ( ) , npt . getPortId ( ) , _BOOL , _BOOL ) ; nptList . add ( npt ) ; count ++ ; } count = _NUM ; while ( count < BDDP_TASK_SIZE && maintenanceQueue . peek ( ) != null ) { NodePortTuple npt ; npt = maintenanceQueue . remove ( ) ; sendDiscoveryMessage ( npt . getNodeId ( ) , npt . getPortId ( ) , _BOOL , _BOOL ) ; count ++ ; } for ( NodePortTuple npt : nptList ) { generateSwitchPortStatusUpdate ( npt . getNodeId ( ) , npt . getPortId ( ) ) ; } }
protected void processBDDPLists ( ) { int count = _NUM ; Set < NodePortTuple > nptList = new HashSet < NodePortTuple > ( ) ; while ( count < BDDP_TASK_SIZE && quarantineQueue . peek ( ) != null ) { NodePortTuple npt ; npt = quarantineQueue . remove ( ) ; sendDiscoveryMessage ( npt . getNodeId ( ) , npt . getPortId ( ) , _BOOL , _BOOL ) ; nptList . add ( npt ) ; count ++ ; } count = _NUM ; while ( count < BDDP_TASK_SIZE && maintenanceQueue . peek ( ) != null ) { NodePortTuple npt ; npt = maintenanceQueue . remove ( ) ; sendDiscoveryMessage ( npt . getNodeId ( ) , npt . getPortId ( ) , _BOOL , _BOOL ) ; count ++ ; } for ( NodePortTuple npt : nptList ) { generateSwitchPortStatusUpdate ( npt . getNodeId ( ) , npt . getPortId ( ) ) ; } }
protected void processBDDPLists ( ) { int count = _NUM ; Set < NodePortTuple > nptList = new HashSet < NodePortTuple > ( ) ; while ( count < BDDP_TASK_SIZE && quarantineQueue . peek ( ) != null ) { NodePortTuple npt ; npt = quarantineQueue . remove ( ) ; sendDiscoveryMessage ( npt . getNodeId ( ) , npt . getPortId ( ) , _BOOL , _BOOL ) ; nptList . add ( npt ) ; count ++ ; } count = _NUM ; while ( count < BDDP_TASK_SIZE && maintenanceQueue . peek ( ) != null ) { NodePortTuple npt ; npt = maintenanceQueue . remove ( ) ; sendDiscoveryMessage ( npt . getNodeId ( ) , npt . getPortId ( ) , _BOOL , _BOOL ) ; count ++ ; } for ( NodePortTuple npt : nptList ) { generateSwitchPortStatusUpdate ( npt . getNodeId ( ) , npt . getPortId ( ) ) ; } }
public ConsulTopologyFraction ( ) { this . url = DEFAULT_URL ; }
public static String generateNativeGuid ( ProtectionSystem device , String uniqueId , String type ) { String typeStr = STRING ; if ( OBJECT_TYPE_SET . contains ( type ) ) { typeStr = type ; } return String . format ( STRING , _deviceTypeMap . get ( device . getSystemType ( ) ) , device . getInstallationId ( ) , typeStr , uniqueId ) ; }
public void clearDropItemList ( ) { dropsItems = new ArrayList < DropItem > ( ) ; dropItemInstances . clear ( ) ; }
public void clearDropItemList ( ) { dropsItems = new ArrayList < DropItem > ( ) ; dropItemInstances . clear ( ) ; }
@ Deprecated static public SerialSensorManager instance ( ) { return null ; }
@ Deprecated static public SerialSensorManager instance ( ) { return null ; }
@ Deprecated static public SerialSensorManager instance ( ) { return null ; }
public PerTestClassLoaderRunner ( Class < ? > klass ) throws InitializationError { super ( klass ) ; }
private float multilinearInterpolate ( float [ ] encoded , int od ) { float [ ] dists = new float [ encoded . length ] ; for ( int i = _NUM ; i < dists . length ; i ++ ) { dists [ i ] = ( float ) ( encoded [ i ] - Math . floor ( encoded [ i ] ) ) ; } int map = _NUM ; float val = getSample ( encoded , map , od ) ; float prev = val ; for ( int i = _NUM ; i < dists . length ; i ++ ) { int idx = _NUM ; float largest = - _NUM ; for ( int c = _NUM ; c < dists . length ; c ++ ) { if ( dists [ c ] > largest ) { largest = dists [ c ] ; idx = c ; } } map |= ( _NUM << idx ) ; float cur = getSample ( encoded , map , od ) ; val += dists [ idx ] * ( cur - prev ) ; prev = val ; dists [ idx ] = - _NUM ; } return val ; }
private float multilinearInterpolate ( float [ ] encoded , int od ) { float [ ] dists = new float [ encoded . length ] ; for ( int i = _NUM ; i < dists . length ; i ++ ) { dists [ i ] = ( float ) ( encoded [ i ] - Math . floor ( encoded [ i ] ) ) ; } int map = _NUM ; float val = getSample ( encoded , map , od ) ; float prev = val ; for ( int i = _NUM ; i < dists . length ; i ++ ) { int idx = _NUM ; float largest = - _NUM ; for ( int c = _NUM ; c < dists . length ; c ++ ) { if ( dists [ c ] > largest ) { largest = dists [ c ] ; idx = c ; } } map |= ( _NUM << idx ) ; float cur = getSample ( encoded , map , od ) ; val += dists [ idx ] * ( cur - prev ) ; prev = val ; dists [ idx ] = - _NUM ; } return val ; }
private float multilinearInterpolate ( float [ ] encoded , int od ) { float [ ] dists = new float [ encoded . length ] ; for ( int i = _NUM ; i < dists . length ; i ++ ) { dists [ i ] = ( float ) ( encoded [ i ] - Math . floor ( encoded [ i ] ) ) ; } int map = _NUM ; float val = getSample ( encoded , map , od ) ; float prev = val ; for ( int i = _NUM ; i < dists . length ; i ++ ) { int idx = _NUM ; float largest = - _NUM ; for ( int c = _NUM ; c < dists . length ; c ++ ) { if ( dists [ c ] > largest ) { largest = dists [ c ] ; idx = c ; } } map |= ( _NUM << idx ) ; float cur = getSample ( encoded , map , od ) ; val += dists [ idx ] * ( cur - prev ) ; prev = val ; dists [ idx ] = - _NUM ; } return val ; }
private float multilinearInterpolate ( float [ ] encoded , int od ) { float [ ] dists = new float [ encoded . length ] ; for ( int i = _NUM ; i < dists . length ; i ++ ) { dists [ i ] = ( float ) ( encoded [ i ] - Math . floor ( encoded [ i ] ) ) ; } int map = _NUM ; float val = getSample ( encoded , map , od ) ; float prev = val ; for ( int i = _NUM ; i < dists . length ; i ++ ) { int idx = _NUM ; float largest = - _NUM ; for ( int c = _NUM ; c < dists . length ; c ++ ) { if ( dists [ c ] > largest ) { largest = dists [ c ] ; idx = c ; } } map |= ( _NUM << idx ) ; float cur = getSample ( encoded , map , od ) ; val += dists [ idx ] * ( cur - prev ) ; prev = val ; dists [ idx ] = - _NUM ; } return val ; }
private boolean havePreviousDigestAuthorizationAndShouldAbort ( Request request , String nonce , boolean isStale ) { final String previousAuthorizationHeader = request . header ( STRING ) ; if ( previousAuthorizationHeader != null && previousAuthorizationHeader . startsWith ( STRING ) ) { return ! isStale ; } return _BOOL ; }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_splitThread . isAlive ( ) ) { wait ( ) ; } } catch ( InterruptedException ex ) { } } else { notifyAll ( ) ; } }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_splitThread . isAlive ( ) ) { wait ( ) ; } } catch ( InterruptedException ex ) { } } else { notifyAll ( ) ; } }
public void validateSession ( InternalSession internalSession , SessionID sid ) throws SessionException { if ( ! sid . equals ( internalSession . getID ( ) ) && internalSession . getRestrictionForToken ( sid ) == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( internalSession . getState ( ) != SessionState . VALID ) { if ( internalSession . isTimedOut ( ) ) { throw new SessionTimedOutException ( MessageFormat . format ( ERROR_FORMAT , SessionBundle . getString ( SESSION_TIMED_OUT ) , sid ) ) ; } else { throw new SessionException ( MessageFormat . format ( ERROR_FORMAT , SessionBundle . getString ( INVALID_SESSION_STATE ) , sid ) ) ; } } }
public void validateSession ( InternalSession internalSession , SessionID sid ) throws SessionException { if ( ! sid . equals ( internalSession . getID ( ) ) && internalSession . getRestrictionForToken ( sid ) == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( internalSession . getState ( ) != SessionState . VALID ) { if ( internalSession . isTimedOut ( ) ) { throw new SessionTimedOutException ( MessageFormat . format ( ERROR_FORMAT , SessionBundle . getString ( SESSION_TIMED_OUT ) , sid ) ) ; } else { throw new SessionException ( MessageFormat . format ( ERROR_FORMAT , SessionBundle . getString ( INVALID_SESSION_STATE ) , sid ) ) ; } } }
public void validateSession ( InternalSession internalSession , SessionID sid ) throws SessionException { if ( ! sid . equals ( internalSession . getID ( ) ) && internalSession . getRestrictionForToken ( sid ) == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( internalSession . getState ( ) != SessionState . VALID ) { if ( internalSession . isTimedOut ( ) ) { throw new SessionTimedOutException ( MessageFormat . format ( ERROR_FORMAT , SessionBundle . getString ( SESSION_TIMED_OUT ) , sid ) ) ; } else { throw new SessionException ( MessageFormat . format ( ERROR_FORMAT , SessionBundle . getString ( INVALID_SESSION_STATE ) , sid ) ) ; } } }
protected void deleteSessionVariables ( String sessionId , String ... varNames ) { if ( sessionId . equals ( STRING ) ) { return ; } Key key = keyFactory . newKey ( sessionId ) ; Transaction transaction = datastore . newTransaction ( ) ; try { Entity stateEntity = transaction . get ( key ) ; Entity . Builder builder = Entity . builder ( stateEntity ) ; StringBuilder delNames = new StringBuilder ( ) ; for ( String varName : varNames ) { delNames . append ( varName + STRING ) ; builder = builder . remove ( varName ) ; } datastore . update ( builder . build ( ) ) ; } catch ( NullPointerException e ) { } finally { if ( transaction . active ( ) ) { transaction . rollback ( ) ; } } }
protected void deleteSessionVariables ( String sessionId , String ... varNames ) { if ( sessionId . equals ( STRING ) ) { return ; } Key key = keyFactory . newKey ( sessionId ) ; Transaction transaction = datastore . newTransaction ( ) ; try { Entity stateEntity = transaction . get ( key ) ; Entity . Builder builder = Entity . builder ( stateEntity ) ; StringBuilder delNames = new StringBuilder ( ) ; for ( String varName : varNames ) { delNames . append ( varName + STRING ) ; builder = builder . remove ( varName ) ; } datastore . update ( builder . build ( ) ) ; } catch ( NullPointerException e ) { } finally { if ( transaction . active ( ) ) { transaction . rollback ( ) ; } } }
protected void deleteSessionVariables ( String sessionId , String ... varNames ) { if ( sessionId . equals ( STRING ) ) { return ; } Key key = keyFactory . newKey ( sessionId ) ; Transaction transaction = datastore . newTransaction ( ) ; try { Entity stateEntity = transaction . get ( key ) ; Entity . Builder builder = Entity . builder ( stateEntity ) ; StringBuilder delNames = new StringBuilder ( ) ; for ( String varName : varNames ) { delNames . append ( varName + STRING ) ; builder = builder . remove ( varName ) ; } datastore . update ( builder . build ( ) ) ; } catch ( NullPointerException e ) { } finally { if ( transaction . active ( ) ) { transaction . rollback ( ) ; } } }
private static void deserializeHeader ( KdbHeader kdbHeader , DataInput dataInput ) throws IOException { kdbHeader . setFlags ( dataInput . readInt ( ) ) ; kdbHeader . setVersion ( dataInput . readInt ( ) ) ; byte [ ] buffer = new byte [ _NUM ] ; dataInput . readFully ( buffer ) ; kdbHeader . setMasterSeed ( buffer ) ; buffer = new byte [ _NUM ] ; dataInput . readFully ( buffer ) ; kdbHeader . setEncryptionIv ( buffer ) ; kdbHeader . setGroupCount ( dataInput . readInt ( ) ) ; kdbHeader . setEntryCount ( dataInput . readInt ( ) ) ; byte [ ] buffer32 = new byte [ _NUM ] ; dataInput . readFully ( buffer32 ) ; kdbHeader . setContentHash ( buffer32 ) ; buffer32 = new byte [ _NUM ] ; dataInput . readFully ( buffer32 ) ; kdbHeader . setTransformSeed ( buffer32 ) ; kdbHeader . setTransformRounds ( dataInput . readInt ( ) ) ; }
private static void deserializeHeader ( KdbHeader kdbHeader , DataInput dataInput ) throws IOException { kdbHeader . setFlags ( dataInput . readInt ( ) ) ; kdbHeader . setVersion ( dataInput . readInt ( ) ) ; byte [ ] buffer = new byte [ _NUM ] ; dataInput . readFully ( buffer ) ; kdbHeader . setMasterSeed ( buffer ) ; buffer = new byte [ _NUM ] ; dataInput . readFully ( buffer ) ; kdbHeader . setEncryptionIv ( buffer ) ; kdbHeader . setGroupCount ( dataInput . readInt ( ) ) ; kdbHeader . setEntryCount ( dataInput . readInt ( ) ) ; byte [ ] buffer32 = new byte [ _NUM ] ; dataInput . readFully ( buffer32 ) ; kdbHeader . setContentHash ( buffer32 ) ; buffer32 = new byte [ _NUM ] ; dataInput . readFully ( buffer32 ) ; kdbHeader . setTransformSeed ( buffer32 ) ; kdbHeader . setTransformRounds ( dataInput . readInt ( ) ) ; }
private E dequeue ( ) { final Object [ ] items = this . items ; @ SuppressWarnings ( STRING ) E x = ( E ) items [ takeIndex ] ; items [ takeIndex ] = null ; takeIndex = inc ( takeIndex ) ; count -- ; if ( itrs != null ) itrs . elementDequeued ( ) ; notFull . signal ( ) ; return x ; }
public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; return result . elements ( ) ; }
public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; return result . elements ( ) ; }
static public void addAll ( List < String > list , String [ ] array ) { for ( String item : array ) list . add ( item ) ; }
public boolean contains ( ) { int next = _NUM ; final int size = fValues . size ( ) ; LOOP : for ( int i = _NUM ; i < size ; i = next ) { next = i + fFieldCount ; for ( int j = _NUM ; j < fFieldCount ; j ++ ) { Object value1 = fLocalValues [ j ] ; Object value2 = fValues . elementAt ( i ) ; short valueType1 = fLocalValueTypes [ j ] ; short valueType2 = getValueTypeAt ( i ) ; if ( value1 == null || value2 == null || valueType1 != valueType2 || ! ( value1 . equals ( value2 ) ) ) { continue LOOP ; } else if ( valueType1 == XSConstants . LIST_DT || valueType1 == XSConstants . LISTOFUNION_DT ) { ShortList list1 = fLocalItemValueTypes [ j ] ; ShortList list2 = getItemValueTypeAt ( i ) ; if ( list1 == null || list2 == null || ! list1 . equals ( list2 ) ) continue LOOP ; } i ++ ; } return _BOOL ; } return _BOOL ; }
public boolean contains ( ) { int next = _NUM ; final int size = fValues . size ( ) ; LOOP : for ( int i = _NUM ; i < size ; i = next ) { next = i + fFieldCount ; for ( int j = _NUM ; j < fFieldCount ; j ++ ) { Object value1 = fLocalValues [ j ] ; Object value2 = fValues . elementAt ( i ) ; short valueType1 = fLocalValueTypes [ j ] ; short valueType2 = getValueTypeAt ( i ) ; if ( value1 == null || value2 == null || valueType1 != valueType2 || ! ( value1 . equals ( value2 ) ) ) { continue LOOP ; } else if ( valueType1 == XSConstants . LIST_DT || valueType1 == XSConstants . LISTOFUNION_DT ) { ShortList list1 = fLocalItemValueTypes [ j ] ; ShortList list2 = getItemValueTypeAt ( i ) ; if ( list1 == null || list2 == null || ! list1 . equals ( list2 ) ) continue LOOP ; } i ++ ; } return _BOOL ; } return _BOOL ; }
public void doWindowOpen ( ) { }
static public PVector fromAngle ( float angle , PVector target ) { if ( target == null ) { target = new PVector ( ( float ) Math . cos ( angle ) , ( float ) Math . sin ( angle ) , _NUM ) ; } else { target . set ( ( float ) Math . cos ( angle ) , ( float ) Math . sin ( angle ) , _NUM ) ; } return target ; }
private void sendNextMessageOverNetwork ( ) throws Exception { RawData raw = outgoing . take ( ) ; if ( raw == null ) throw new NullPointerException ( ) ; sendNext ( raw ) ; }
protected Long encodeRangeShift ( final Long val , final Long minValue ) { if ( minValue == null ) { return val ; } if ( val < minValue ) { throw new RuntimeException ( STRING ) ; } return Long . MIN_VALUE + ( val - minValue ) ; }
protected Long encodeRangeShift ( final Long val , final Long minValue ) { if ( minValue == null ) { return val ; } if ( val < minValue ) { throw new RuntimeException ( STRING ) ; } return Long . MIN_VALUE + ( val - minValue ) ; }
private boolean isMenuTouched ( int ix , int iy , Bitmap b , int siteOffset ) { int angle = getOffsetHistory ( ) + siteOffset ; double x0 = RADIU * Math . cos ( Math . toRadians ( angle ) ) + circlePoint . getX ( ) ; double y0 = RADIU * Math . sin ( Math . toRadians ( angle ) ) + circlePoint . getY ( ) ; return ( ( x0 - ix ) * ( x0 - ix ) + ( y0 - iy ) * ( y0 - iy ) ) <= getMinCircleRadius ( b ) * getMinCircleRadius ( b ) ; }
private boolean isMenuTouched ( int ix , int iy , Bitmap b , int siteOffset ) { int angle = getOffsetHistory ( ) + siteOffset ; double x0 = RADIU * Math . cos ( Math . toRadians ( angle ) ) + circlePoint . getX ( ) ; double y0 = RADIU * Math . sin ( Math . toRadians ( angle ) ) + circlePoint . getY ( ) ; return ( ( x0 - ix ) * ( x0 - ix ) + ( y0 - iy ) * ( y0 - iy ) ) <= getMinCircleRadius ( b ) * getMinCircleRadius ( b ) ; }
private boolean isMenuTouched ( int ix , int iy , Bitmap b , int siteOffset ) { int angle = getOffsetHistory ( ) + siteOffset ; double x0 = RADIU * Math . cos ( Math . toRadians ( angle ) ) + circlePoint . getX ( ) ; double y0 = RADIU * Math . sin ( Math . toRadians ( angle ) ) + circlePoint . getY ( ) ; return ( ( x0 - ix ) * ( x0 - ix ) + ( y0 - iy ) * ( y0 - iy ) ) <= getMinCircleRadius ( b ) * getMinCircleRadius ( b ) ; }
public void deleteMetaObject ( int index ) { MetaObjects . set ( index , null ) ; }
public void deleteMetaObject ( int index ) { MetaObjects . set ( index , null ) ; }
public static boolean deletePhoto ( Uri fileUri ) { try { File mediaStorageDir = getMediaStorageDir ( ) ; if ( ! mediaStorageDir . exists ( ) ) return _BOOL ; File photoToDelete = new File ( fileUri . getPath ( ) ) ; return photoToDelete . delete ( ) ; } catch ( Exception e ) { Log . e ( TAG , STRING ) ; Log . e ( TAG , e . getLocalizedMessage ( ) ) ; return _BOOL ; } }
public void testAddAll3 ( ) { try { LinkedBlockingQueue q = new LinkedBlockingQueue ( SIZE ) ; Integer [ ] ints = new Integer [ SIZE ] ; for ( int i = _NUM ; i < SIZE - _NUM ; ++ i ) ints [ i ] = new Integer ( i ) ; q . addAll ( Arrays . asList ( ints ) ) ; shouldThrow ( ) ; } catch ( NullPointerException success ) { } }
@ CheckReturnValue @ Nonnull @ Deprecated static public String [ ] split ( @ Nonnull String input , @ Nonnull String divider ) { int size = _NUM ; String temp = input ; while ( temp . length ( ) > _NUM ) { size ++ ; int index = temp . indexOf ( divider ) ; if ( index < _NUM ) { break ; } temp = temp . substring ( index + divider . length ( ) ) ; if ( temp . length ( ) == _NUM ) { size ++ ; break ; } } String [ ] result = new String [ size ] ; temp = input ; size = _NUM ; while ( temp . length ( ) > _NUM ) { int index = temp . indexOf ( divider ) ; if ( index < _NUM ) { break ; } result [ size ] = temp . substring ( _NUM , index ) ; temp = temp . substring ( index + divider . length ( ) ) ; size ++ ; } result [ size ] = temp ; return result ; }
@ CheckReturnValue @ Nonnull @ Deprecated static public String [ ] split ( @ Nonnull String input , @ Nonnull String divider ) { int size = _NUM ; String temp = input ; while ( temp . length ( ) > _NUM ) { size ++ ; int index = temp . indexOf ( divider ) ; if ( index < _NUM ) { break ; } temp = temp . substring ( index + divider . length ( ) ) ; if ( temp . length ( ) == _NUM ) { size ++ ; break ; } } String [ ] result = new String [ size ] ; temp = input ; size = _NUM ; while ( temp . length ( ) > _NUM ) { int index = temp . indexOf ( divider ) ; if ( index < _NUM ) { break ; } result [ size ] = temp . substring ( _NUM , index ) ; temp = temp . substring ( index + divider . length ( ) ) ; size ++ ; } result [ size ] = temp ; return result ; }
@ CheckReturnValue @ Nonnull @ Deprecated static public String [ ] split ( @ Nonnull String input , @ Nonnull String divider ) { int size = _NUM ; String temp = input ; while ( temp . length ( ) > _NUM ) { size ++ ; int index = temp . indexOf ( divider ) ; if ( index < _NUM ) { break ; } temp = temp . substring ( index + divider . length ( ) ) ; if ( temp . length ( ) == _NUM ) { size ++ ; break ; } } String [ ] result = new String [ size ] ; temp = input ; size = _NUM ; while ( temp . length ( ) > _NUM ) { int index = temp . indexOf ( divider ) ; if ( index < _NUM ) { break ; } result [ size ] = temp . substring ( _NUM , index ) ; temp = temp . substring ( index + divider . length ( ) ) ; size ++ ; } result [ size ] = temp ; return result ; }
@ CheckReturnValue @ Nonnull @ Deprecated static public String [ ] split ( @ Nonnull String input , @ Nonnull String divider ) { int size = _NUM ; String temp = input ; while ( temp . length ( ) > _NUM ) { size ++ ; int index = temp . indexOf ( divider ) ; if ( index < _NUM ) { break ; } temp = temp . substring ( index + divider . length ( ) ) ; if ( temp . length ( ) == _NUM ) { size ++ ; break ; } } String [ ] result = new String [ size ] ; temp = input ; size = _NUM ; while ( temp . length ( ) > _NUM ) { int index = temp . indexOf ( divider ) ; if ( index < _NUM ) { break ; } result [ size ] = temp . substring ( _NUM , index ) ; temp = temp . substring ( index + divider . length ( ) ) ; size ++ ; } result [ size ] = temp ; return result ; }
@ CheckReturnValue @ Nonnull @ Deprecated static public String [ ] split ( @ Nonnull String input , @ Nonnull String divider ) { int size = _NUM ; String temp = input ; while ( temp . length ( ) > _NUM ) { size ++ ; int index = temp . indexOf ( divider ) ; if ( index < _NUM ) { break ; } temp = temp . substring ( index + divider . length ( ) ) ; if ( temp . length ( ) == _NUM ) { size ++ ; break ; } } String [ ] result = new String [ size ] ; temp = input ; size = _NUM ; while ( temp . length ( ) > _NUM ) { int index = temp . indexOf ( divider ) ; if ( index < _NUM ) { break ; } result [ size ] = temp . substring ( _NUM , index ) ; temp = temp . substring ( index + divider . length ( ) ) ; size ++ ; } result [ size ] = temp ; return result ; }
@ CheckReturnValue @ Nonnull @ Deprecated static public String [ ] split ( @ Nonnull String input , @ Nonnull String divider ) { int size = _NUM ; String temp = input ; while ( temp . length ( ) > _NUM ) { size ++ ; int index = temp . indexOf ( divider ) ; if ( index < _NUM ) { break ; } temp = temp . substring ( index + divider . length ( ) ) ; if ( temp . length ( ) == _NUM ) { size ++ ; break ; } } String [ ] result = new String [ size ] ; temp = input ; size = _NUM ; while ( temp . length ( ) > _NUM ) { int index = temp . indexOf ( divider ) ; if ( index < _NUM ) { break ; } result [ size ] = temp . substring ( _NUM , index ) ; temp = temp . substring ( index + divider . length ( ) ) ; size ++ ; } result [ size ] = temp ; return result ; }
protected void add ( DirectedEdge dirEdge ) { dirEdges . add ( dirEdge ) ; }
protected void add ( DirectedEdge dirEdge ) { dirEdges . add ( dirEdge ) ; }
protected void add ( DirectedEdge dirEdge ) { dirEdges . add ( dirEdge ) ; }
protected void add ( DirectedEdge dirEdge ) { dirEdges . add ( dirEdge ) ; }
Builder addLenient ( String name , String value ) { namesAndValues . add ( name ) ; namesAndValues . add ( value . trim ( ) ) ; return this ; }
Builder addLenient ( String name , String value ) { namesAndValues . add ( name ) ; namesAndValues . add ( value . trim ( ) ) ; return this ; }
public static void drawArrow ( Graphics2D g , Polygon arrow , int x , int y ) { arrow . translate ( x , y ) ; g . draw ( arrow ) ; g . fill ( arrow ) ; arrow . translate ( - x , - y ) ; }
public void removeCommunicationListener ( FTPCommunicationListener listener ) { synchronized ( lock ) { communicationListeners . remove ( listener ) ; if ( communication != null ) { communication . removeCommunicationListener ( listener ) ; } } }
public void removeCommunicationListener ( FTPCommunicationListener listener ) { synchronized ( lock ) { communicationListeners . remove ( listener ) ; if ( communication != null ) { communication . removeCommunicationListener ( listener ) ; } } }
private boolean isImplicitImport ( String name ) { Boolean yes = implicitImports . get ( name ) ; if ( yes != null ) { return yes ; } try { Class . forName ( STRING + name ) ; yes = _BOOL ; } catch ( Exception e ) { yes = _BOOL ; } implicitImports . put ( name , yes ) ; return yes ; }
private void validateTableMetaDataSingleRow ( String tableNamePattern , String [ ] types , Map < TableMetaData , Object > validationRules ) throws Exception { checkValidationRulesComplete ( validationRules ) ; try ( ResultSet tables = dbmd . getTables ( null , null , tableNamePattern , types ) ) { assertTrue ( STRING , tables . next ( ) ) ; validateRowValues ( tables , validationRules ) ; assertFalse ( STRING , tables . next ( ) ) ; } }
private void validateTableMetaDataSingleRow ( String tableNamePattern , String [ ] types , Map < TableMetaData , Object > validationRules ) throws Exception { checkValidationRulesComplete ( validationRules ) ; try ( ResultSet tables = dbmd . getTables ( null , null , tableNamePattern , types ) ) { assertTrue ( STRING , tables . next ( ) ) ; validateRowValues ( tables , validationRules ) ; assertFalse ( STRING , tables . next ( ) ) ; } }
private static int [ ] validateCoordinates ( int x1 , int y1 , int x2 , int y2 ) { if ( ( x1 > x2 ) | ( y1 < y2 ) ) { if ( x1 > x2 ) { final int temp = x1 ; x1 = x2 ; x2 = temp ; LogWriter . writeLog ( STRING ) ; } if ( y1 < y2 ) { final int temp = y1 ; y1 = y2 ; y2 = temp ; LogWriter . writeLog ( STRING ) ; } } return new int [ ] { x1 , y1 , x2 , y2 } ; }
private static int [ ] validateCoordinates ( int x1 , int y1 , int x2 , int y2 ) { if ( ( x1 > x2 ) | ( y1 < y2 ) ) { if ( x1 > x2 ) { final int temp = x1 ; x1 = x2 ; x2 = temp ; LogWriter . writeLog ( STRING ) ; } if ( y1 < y2 ) { final int temp = y1 ; y1 = y2 ; y2 = temp ; LogWriter . writeLog ( STRING ) ; } } return new int [ ] { x1 , y1 , x2 , y2 } ; }
@ SuppressWarnings ( STRING ) private Method findMatchingMethod ( JDiffMethod method ) { Method [ ] methods = mClass . getDeclaredMethods ( ) ; for ( Method m : methods ) { if ( matches ( method , m ) ) { return m ; } } return null ; }
@ Override public int compareTo ( Value o ) { if ( o instanceof StringVal ) { return str . compareTo ( ( ( StringVal ) o ) . str ) ; } else { return _NUM ; } }
private void addLicense ( Paragraph p , Eml eml ) throws DocumentException { String licenseTitle = eml . parseLicenseTitle ( ) ; String licenseUrl = eml . parseLicenseUrl ( ) ; if ( ! Strings . isNullOrEmpty ( licenseTitle ) && ! Strings . isNullOrEmpty ( licenseUrl ) ) { p . add ( new Phrase ( getText ( STRING ) + STRING , fontTitle ) ) ; Anchor licenseLink = new Anchor ( eml . parseLicenseTitle ( ) , fontLink ) ; licenseLink . setReference ( eml . parseLicenseUrl ( ) ) ; p . add ( licenseLink ) ; p . add ( Chunk . NEWLINE ) ; } }
public PartitionedRegionRebalanceOp ( PartitionedRegion region , boolean simulate , RebalanceDirector director , boolean replaceOfflineData , boolean isRebalance ) { this ( region , simulate , director , replaceOfflineData , isRebalance , new AtomicBoolean ( ) , null ) ; }
public PartitionedRegionRebalanceOp ( PartitionedRegion region , boolean simulate , RebalanceDirector director , boolean replaceOfflineData , boolean isRebalance ) { this ( region , simulate , director , replaceOfflineData , isRebalance , new AtomicBoolean ( ) , null ) ; }
public PathImpl lookupImpl ( String userPath , Map < String , Object > newAttributes , boolean isAllowRoot ) { if ( userPath == null ) { return lookupImpl ( getPath ( ) , newAttributes , isAllowRoot ) ; } if ( ! isAllowRoot ) { return schemeWalk ( userPath , newAttributes , userPath , _NUM ) ; } String scheme = scanScheme ( userPath ) ; if ( scheme == null ) { return schemeWalk ( userPath , newAttributes , userPath , _NUM ) ; } PathImpl path ; SchemeMap schemeMap = _schemeMap ; if ( isWindows ( ) ) { int length = scheme . length ( ) ; char ch ; if ( length == _NUM && ( STRING <= ( ch = scheme . charAt ( _NUM ) ) && ch <= STRING || STRING <= ch && ch <= STRING ) ) { userPath = Character . toLowerCase ( ch ) + userPath . substring ( _NUM ) ; if ( _isTestWindows ) return schemeWalk ( userPath , newAttributes , STRING + userPath , _NUM ) ; path = schemeMap . get ( STRING ) ; if ( path != null ) return path . schemeWalk ( userPath , newAttributes , STRING + userPath , _NUM ) ; else return schemeWalk ( userPath , newAttributes , STRING + userPath , _NUM ) ; } } path = schemeMap . get ( scheme ) ; if ( path == null ) { return schemeWalk ( userPath , newAttributes , userPath , _NUM ) ; } else { return path . schemeWalk ( userPath , newAttributes , userPath , scheme . length ( ) + _NUM ) ; } }
public PathImpl lookupImpl ( String userPath , Map < String , Object > newAttributes , boolean isAllowRoot ) { if ( userPath == null ) { return lookupImpl ( getPath ( ) , newAttributes , isAllowRoot ) ; } if ( ! isAllowRoot ) { return schemeWalk ( userPath , newAttributes , userPath , _NUM ) ; } String scheme = scanScheme ( userPath ) ; if ( scheme == null ) { return schemeWalk ( userPath , newAttributes , userPath , _NUM ) ; } PathImpl path ; SchemeMap schemeMap = _schemeMap ; if ( isWindows ( ) ) { int length = scheme . length ( ) ; char ch ; if ( length == _NUM && ( STRING <= ( ch = scheme . charAt ( _NUM ) ) && ch <= STRING || STRING <= ch && ch <= STRING ) ) { userPath = Character . toLowerCase ( ch ) + userPath . substring ( _NUM ) ; if ( _isTestWindows ) return schemeWalk ( userPath , newAttributes , STRING + userPath , _NUM ) ; path = schemeMap . get ( STRING ) ; if ( path != null ) return path . schemeWalk ( userPath , newAttributes , STRING + userPath , _NUM ) ; else return schemeWalk ( userPath , newAttributes , STRING + userPath , _NUM ) ; } } path = schemeMap . get ( scheme ) ; if ( path == null ) { return schemeWalk ( userPath , newAttributes , userPath , _NUM ) ; } else { return path . schemeWalk ( userPath , newAttributes , userPath , scheme . length ( ) + _NUM ) ; } }
public static void copyFile ( File in , File out ) throws IOException { FileInputStream fis = new FileInputStream ( in ) ; FileOutputStream fos = new FileOutputStream ( out ) ; try { copyStream ( fis , fos ) ; } finally { fis . close ( ) ; fos . close ( ) ; } }
public ThreadInterrupter ( ) { this ( Thread . currentThread ( ) ) ; }
default Document putAll ( Map < ? extends CharSequence , Object > fields ) { if ( fields != null ) { for ( Map . Entry < ? extends CharSequence , Object > entry : fields . entrySet ( ) ) { set ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return this ; }
public void testCreateElementNS1 ( ) throws Throwable { String namespaceURI = STRING ; String malformedName = STRING ; Document doc ; doc = ( Document ) load ( STRING , builder ) ; { boolean success = _BOOL ; try { doc . createElementNS ( namespaceURI , malformedName ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . NAMESPACE_ERR ) ; } assertTrue ( STRING , success ) ; } }
private static int compareLocales ( Locale primary , Locale other ) { final String lang = primary . getLanguage ( ) ; if ( ( lang == null ) || ! lang . equals ( other . getLanguage ( ) ) ) { return _NUM ; } final String country = primary . getCountry ( ) ; if ( ( country == null ) || ! country . equals ( other . getCountry ( ) ) ) { return _NUM ; } final String variant = primary . getVariant ( ) ; if ( ( variant == null ) || ! variant . equals ( other . getVariant ( ) ) ) { return _NUM ; } return _NUM ; }
private static int compareLocales ( Locale primary , Locale other ) { final String lang = primary . getLanguage ( ) ; if ( ( lang == null ) || ! lang . equals ( other . getLanguage ( ) ) ) { return _NUM ; } final String country = primary . getCountry ( ) ; if ( ( country == null ) || ! country . equals ( other . getCountry ( ) ) ) { return _NUM ; } final String variant = primary . getVariant ( ) ; if ( ( variant == null ) || ! variant . equals ( other . getVariant ( ) ) ) { return _NUM ; } return _NUM ; }
private static int compareLocales ( Locale primary , Locale other ) { final String lang = primary . getLanguage ( ) ; if ( ( lang == null ) || ! lang . equals ( other . getLanguage ( ) ) ) { return _NUM ; } final String country = primary . getCountry ( ) ; if ( ( country == null ) || ! country . equals ( other . getCountry ( ) ) ) { return _NUM ; } final String variant = primary . getVariant ( ) ; if ( ( variant == null ) || ! variant . equals ( other . getVariant ( ) ) ) { return _NUM ; } return _NUM ; }
private static int compareLocales ( Locale primary , Locale other ) { final String lang = primary . getLanguage ( ) ; if ( ( lang == null ) || ! lang . equals ( other . getLanguage ( ) ) ) { return _NUM ; } final String country = primary . getCountry ( ) ; if ( ( country == null ) || ! country . equals ( other . getCountry ( ) ) ) { return _NUM ; } final String variant = primary . getVariant ( ) ; if ( ( variant == null ) || ! variant . equals ( other . getVariant ( ) ) ) { return _NUM ; } return _NUM ; }
public void onSaveInstanceState ( Bundle outState ) { Log . d ( TAG , STRING + nesting ) ; checkNotNull ( outState , STRING ) ; Page page = peek ( ) ; savePageState ( page ) ; outState . putSerializable ( STACK_TAG , ( Stack ) mFactoryStack . clone ( ) ) ; outState . putBundle ( STATE_TAG , ( Bundle ) mPageStates . clone ( ) ) ; }
public void onSaveInstanceState ( Bundle outState ) { Log . d ( TAG , STRING + nesting ) ; checkNotNull ( outState , STRING ) ; Page page = peek ( ) ; savePageState ( page ) ; outState . putSerializable ( STACK_TAG , ( Stack ) mFactoryStack . clone ( ) ) ; outState . putBundle ( STATE_TAG , ( Bundle ) mPageStates . clone ( ) ) ; }
private String readFully ( HttpURLConnection connection ) throws IOException { String responseBody = STRING ; if ( connection . getContentLength ( ) != _NUM ) { try { InputStream in = connection . getInputStream ( ) ; if ( in != null ) { responseBody = readStreamData ( in ) ; } } catch ( IOException e ) { InputStream in = connection . getErrorStream ( ) ; if ( in != null ) { responseBody = readStreamData ( in ) ; } else { throw e ; } } } return responseBody ; }
private String readFully ( HttpURLConnection connection ) throws IOException { String responseBody = STRING ; if ( connection . getContentLength ( ) != _NUM ) { try { InputStream in = connection . getInputStream ( ) ; if ( in != null ) { responseBody = readStreamData ( in ) ; } } catch ( IOException e ) { InputStream in = connection . getErrorStream ( ) ; if ( in != null ) { responseBody = readStreamData ( in ) ; } else { throw e ; } } } return responseBody ; }
public static MosaicDefinition createMosaicDefinition ( final Account creator ) { return createMosaicDefinition ( creator , Utils . createMosaicId ( STRING , STRING ) , createMosaicProperties ( ) ) ; }
public ChunkScan ( TableInfo ti , long startBlkNum , long endBlkNum , Transaction tx ) { pages = new ArrayList < RecordPage > ( ) ; this . startBlkNum = startBlkNum ; this . endBlkNum = endBlkNum ; this . schema = ti . schema ( ) ; this . fileName = ti . fileName ( ) ; for ( long i = startBlkNum ; i <= endBlkNum ; i ++ ) { BlockId blk = new BlockId ( fileName , i ) ; pages . add ( new RecordPage ( blk , ti , tx , _BOOL ) ) ; } beforeFirst ( ) ; }
public void testSplitAndJoinMultiplePropertiesOnDot ( ) { Properties inner = PropertyUtils . splitPropertiesOnDelimiter ( ONE_DOT_TWO , STRING ) ; assertEquals ( STRING , inner . getProperty ( STRING ) ) ; assertEquals ( STRING , inner . getProperty ( STRING ) ) ; assertEquals ( _NUM , inner . size ( ) ) ; try { assertEquals ( ONE_DOT_TWO , PropertyUtils . joinOnDelimiter ( PropertyUtils . toMap ( inner ) , STRING ) ) ; } catch ( ComparisonFailure e ) { assertEquals ( TWO_DOT_ONE , PropertyUtils . joinOnDelimiter ( PropertyUtils . toMap ( inner ) , STRING ) ) ; } }
public void updatePosition ( Node node , double latitude , double longitude ) { nodePositions . put ( node . getId ( ) , new Position ( latitude , longitude ) ) ; refreshSingleLayer ( node ) ; }
public static boolean replicationGroupHasNoOtherSnapshot ( DbClient dbClient , String rgName , Collection < URI > snapshots , URI storage ) { List < BlockSnapshot > snapshotsInRG = getSnapshotsPartOfReplicationGroup ( rgName , storage , dbClient ) ; List < URI > snapshotURsInRG = newArrayList ( transform ( snapshotsInRG , fctnDataObjectToID ( ) ) ) ; s_logger . info ( STRING , snapshotsInRG . size ( ) , snapshots . size ( ) ) ; snapshotURsInRG . removeAll ( snapshots ) ; return snapshotURsInRG . isEmpty ( ) ; }
public static boolean replicationGroupHasNoOtherSnapshot ( DbClient dbClient , String rgName , Collection < URI > snapshots , URI storage ) { List < BlockSnapshot > snapshotsInRG = getSnapshotsPartOfReplicationGroup ( rgName , storage , dbClient ) ; List < URI > snapshotURsInRG = newArrayList ( transform ( snapshotsInRG , fctnDataObjectToID ( ) ) ) ; s_logger . info ( STRING , snapshotsInRG . size ( ) , snapshots . size ( ) ) ; snapshotURsInRG . removeAll ( snapshots ) ; return snapshotURsInRG . isEmpty ( ) ; }
public Address __mul__ ( final Object rhs ) { return new Address ( m_value . multiply ( getBigInteger ( rhs ) ) ) ; }
public Address __mul__ ( final Object rhs ) { return new Address ( m_value . multiply ( getBigInteger ( rhs ) ) ) ; }
public Address __mul__ ( final Object rhs ) { return new Address ( m_value . multiply ( getBigInteger ( rhs ) ) ) ; }
@ Override public boolean equals ( Object other ) { if ( ! ( other instanceof Matrix ) ) { return _BOOL ; } for ( int r = _NUM ; r < rows ; r ++ ) { if ( ! Arrays . equals ( data [ r ] , ( ( Matrix ) other ) . data [ r ] ) ) { return _BOOL ; } } return _BOOL ; }
public static int colorARGB ( int color , double alpha ) { int rgb = color & _NUM ; int a = ( int ) StrictMath . rint ( alpha * _NUM ) ; int argb = rgb | ( a << _NUM ) ; return argb ; }
public static int colorARGB ( int color , double alpha ) { int rgb = color & _NUM ; int a = ( int ) StrictMath . rint ( alpha * _NUM ) ; int argb = rgb | ( a << _NUM ) ; return argb ; }
public static int colorARGB ( int color , double alpha ) { int rgb = color & _NUM ; int a = ( int ) StrictMath . rint ( alpha * _NUM ) ; int argb = rgb | ( a << _NUM ) ; return argb ; }
public void addPopupListener ( final PopupListener listener ) { if ( ! popupListeners . contains ( listener ) ) { popupListeners . add ( listener ) ; } }
public void addPopupListener ( final PopupListener listener ) { if ( ! popupListeners . contains ( listener ) ) { popupListeners . add ( listener ) ; } }
public static double erf ( double x ) { return ( igamma ( _NUM , Math . pow ( x , _NUM ) ) ) ; }
static CipherSuite valueOf ( int id1 , int id2 ) { id1 &= _NUM ; id2 &= _NUM ; int id = ( id1 << _NUM ) | id2 ; CipherSuite c = idMap . get ( id ) ; if ( c == null ) { String h1 = Integer . toString ( id1 , _NUM ) ; String h2 = Integer . toString ( id2 , _NUM ) ; c = new CipherSuite ( STRING + h1 + STRING + h2 , id ) ; } return c ; }
static CipherSuite valueOf ( int id1 , int id2 ) { id1 &= _NUM ; id2 &= _NUM ; int id = ( id1 << _NUM ) | id2 ; CipherSuite c = idMap . get ( id ) ; if ( c == null ) { String h1 = Integer . toString ( id1 , _NUM ) ; String h2 = Integer . toString ( id2 , _NUM ) ; c = new CipherSuite ( STRING + h1 + STRING + h2 , id ) ; } return c ; }
static CipherSuite valueOf ( int id1 , int id2 ) { id1 &= _NUM ; id2 &= _NUM ; int id = ( id1 << _NUM ) | id2 ; CipherSuite c = idMap . get ( id ) ; if ( c == null ) { String h1 = Integer . toString ( id1 , _NUM ) ; String h2 = Integer . toString ( id2 , _NUM ) ; c = new CipherSuite ( STRING + h1 + STRING + h2 , id ) ; } return c ; }
private void saveNestedVariables ( ) { if ( nestedVars != null ) { Iterator < String > iter = nestedVars . iterator ( ) ; while ( iter . hasNext ( ) ) { String varName = iter . next ( ) ; varName = findAlias ( varName ) ; Object obj = invokingJspCtxt . getAttribute ( varName ) ; if ( obj != null ) { originalNestedVars . put ( varName , obj ) ; } } } }
private void saveNestedVariables ( ) { if ( nestedVars != null ) { Iterator < String > iter = nestedVars . iterator ( ) ; while ( iter . hasNext ( ) ) { String varName = iter . next ( ) ; varName = findAlias ( varName ) ; Object obj = invokingJspCtxt . getAttribute ( varName ) ; if ( obj != null ) { originalNestedVars . put ( varName , obj ) ; } } } }
private void saveNestedVariables ( ) { if ( nestedVars != null ) { Iterator < String > iter = nestedVars . iterator ( ) ; while ( iter . hasNext ( ) ) { String varName = iter . next ( ) ; varName = findAlias ( varName ) ; Object obj = invokingJspCtxt . getAttribute ( varName ) ; if ( obj != null ) { originalNestedVars . put ( varName , obj ) ; } } } }
public PlaPointInt round ( ) { if ( is_NaN ( ) ) return new PlaPointInt ( ) ; return new PlaPointInt ( Math . round ( v_x ) , Math . round ( v_y ) ) ; }
private double calcBIC ( CentroidClusterModel bestModel ) { double loglike = _NUM ; int numCenters = bestModel . getNumberOfClusters ( ) ; int numDimensions = bestModel . getCentroidCoordinates ( _NUM ) . length ; int numParameters = numCenters - _NUM + numCenters * numDimensions + numCenters ; for ( Cluster c : bestModel . getClusters ( ) ) { int current_id = c . getClusterId ( ) ; loglike += logLikelihoodEstimate ( c , bestModel . getCentroidCoordinates ( current_id ) , bestModel . getClusterAssignments ( exampleSet ) , numCenters ) ; } loglike -= numParameters / _NUM * Math . log ( examplesize ) ; return loglike ; }
private double calcBIC ( CentroidClusterModel bestModel ) { double loglike = _NUM ; int numCenters = bestModel . getNumberOfClusters ( ) ; int numDimensions = bestModel . getCentroidCoordinates ( _NUM ) . length ; int numParameters = numCenters - _NUM + numCenters * numDimensions + numCenters ; for ( Cluster c : bestModel . getClusters ( ) ) { int current_id = c . getClusterId ( ) ; loglike += logLikelihoodEstimate ( c , bestModel . getCentroidCoordinates ( current_id ) , bestModel . getClusterAssignments ( exampleSet ) , numCenters ) ; } loglike -= numParameters / _NUM * Math . log ( examplesize ) ; return loglike ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case _NUM : return MESSAGE ; default : return null ; } }
public void addFileset ( FileSet arg ) { fileSets . add ( arg ) ; }
public void addFileset ( FileSet arg ) { fileSets . add ( arg ) ; }
public void addFileset ( FileSet arg ) { fileSets . add ( arg ) ; }
public void addFileset ( FileSet arg ) { fileSets . add ( arg ) ; }
public static String toChannel ( String chan ) { if ( chan == null ) { return null ; } if ( ! validateChannel ( chan ) ) { return StringUtil . toLowerCase ( chan ) ; } if ( ! chan . startsWith ( STRING ) ) { chan = STRING + chan ; } return StringUtil . toLowerCase ( chan ) ; }
public static String toChannel ( String chan ) { if ( chan == null ) { return null ; } if ( ! validateChannel ( chan ) ) { return StringUtil . toLowerCase ( chan ) ; } if ( ! chan . startsWith ( STRING ) ) { chan = STRING + chan ; } return StringUtil . toLowerCase ( chan ) ; }
public String undo ( ) { if ( ! canUndo ( ) ) { return STRING ; } UndoAction undoAction = m_undoStack . get ( m_nCurrentEditAction ) ; m_bNeedsUndoAction = _BOOL ; undoAction . undo ( ) ; m_bNeedsUndoAction = _BOOL ; m_nCurrentEditAction -- ; return undoAction . getUndoMsg ( ) ; }
public String undo ( ) { if ( ! canUndo ( ) ) { return STRING ; } UndoAction undoAction = m_undoStack . get ( m_nCurrentEditAction ) ; m_bNeedsUndoAction = _BOOL ; undoAction . undo ( ) ; m_bNeedsUndoAction = _BOOL ; m_nCurrentEditAction -- ; return undoAction . getUndoMsg ( ) ; }
public String undo ( ) { if ( ! canUndo ( ) ) { return STRING ; } UndoAction undoAction = m_undoStack . get ( m_nCurrentEditAction ) ; m_bNeedsUndoAction = _BOOL ; undoAction . undo ( ) ; m_bNeedsUndoAction = _BOOL ; m_nCurrentEditAction -- ; return undoAction . getUndoMsg ( ) ; }
public String undo ( ) { if ( ! canUndo ( ) ) { return STRING ; } UndoAction undoAction = m_undoStack . get ( m_nCurrentEditAction ) ; m_bNeedsUndoAction = _BOOL ; undoAction . undo ( ) ; m_bNeedsUndoAction = _BOOL ; m_nCurrentEditAction -- ; return undoAction . getUndoMsg ( ) ; }
@ SafeVarargs public final ItemAdapter < Item > add ( int position , Item ... items ) { return add ( position , asList ( items ) ) ; }
@ SafeVarargs public final ItemAdapter < Item > add ( int position , Item ... items ) { return add ( position , asList ( items ) ) ; }
public synchronized void runTask ( Runnable task ) { if ( ! isAlive ) { throw new IllegalStateException ( ) ; } if ( task != null ) { taskQueue . add ( task ) ; notify ( ) ; } }
public synchronized void runTask ( Runnable task ) { if ( ! isAlive ) { throw new IllegalStateException ( ) ; } if ( task != null ) { taskQueue . add ( task ) ; notify ( ) ; } }
public static double distance ( LatLng pointA , LatLng pointB ) { double lat = Math . toRadians ( pointA . latitude ) ; double lat2 = Math . toRadians ( pointB . latitude ) ; double difLat = Math . toRadians ( pointB . latitude - pointA . latitude ) ; double difLong = Math . toRadians ( pointB . longitude - pointA . longitude ) ; double a = ( Math . pow ( Math . sin ( difLat / _NUM ) , _NUM ) ) + ( Math . cos ( lat ) * Math . cos ( lat2 ) * Math . pow ( Math . sin ( difLong / _NUM ) , _NUM ) ) ; double c = _NUM * Math . atan2 ( Math . sqrt ( a ) , Math . sqrt ( _NUM - a ) ) ; return EARTH * c ; }
public void add ( int what , DownloadRequest downloadRequest , DownloadListener downloadListener ) { if ( downloadRequest . inQueue ( ) ) Logger . w ( STRING ) ; else { downloadRequest . setQueue ( mUnFinishQueue ) ; downloadRequest . onPreResponse ( what , downloadListener ) ; downloadRequest . setSequence ( mInteger . incrementAndGet ( ) ) ; mUnFinishQueue . add ( downloadRequest ) ; mDownloadQueue . add ( downloadRequest ) ; } }
public void add ( int what , DownloadRequest downloadRequest , DownloadListener downloadListener ) { if ( downloadRequest . inQueue ( ) ) Logger . w ( STRING ) ; else { downloadRequest . setQueue ( mUnFinishQueue ) ; downloadRequest . onPreResponse ( what , downloadListener ) ; downloadRequest . setSequence ( mInteger . incrementAndGet ( ) ) ; mUnFinishQueue . add ( downloadRequest ) ; mDownloadQueue . add ( downloadRequest ) ; } }
protected List < MapNode [ ] > subdivideProblem ( List < MapNode > markers , OsmMap map , MapWayFilter wayFilter ) { List < MapNode [ ] > result = new ArrayList < MapNode [ ] > ( ) ; MapNode fromNode = map . getNearestWayNode ( new Position ( markers . get ( _NUM ) ) , wayFilter ) ; for ( int i = _NUM ; i < markers . size ( ) ; i ++ ) { MapNode toNode = map . getNearestWayNode ( new Position ( markers . get ( i ) ) , wayFilter ) ; result . add ( new MapNode [ ] { fromNode , toNode } ) ; fromNode = toNode ; } return result ; }
protected List < MapNode [ ] > subdivideProblem ( List < MapNode > markers , OsmMap map , MapWayFilter wayFilter ) { List < MapNode [ ] > result = new ArrayList < MapNode [ ] > ( ) ; MapNode fromNode = map . getNearestWayNode ( new Position ( markers . get ( _NUM ) ) , wayFilter ) ; for ( int i = _NUM ; i < markers . size ( ) ; i ++ ) { MapNode toNode = map . getNearestWayNode ( new Position ( markers . get ( i ) ) , wayFilter ) ; result . add ( new MapNode [ ] { fromNode , toNode } ) ; fromNode = toNode ; } return result ; }
protected List < MapNode [ ] > subdivideProblem ( List < MapNode > markers , OsmMap map , MapWayFilter wayFilter ) { List < MapNode [ ] > result = new ArrayList < MapNode [ ] > ( ) ; MapNode fromNode = map . getNearestWayNode ( new Position ( markers . get ( _NUM ) ) , wayFilter ) ; for ( int i = _NUM ; i < markers . size ( ) ; i ++ ) { MapNode toNode = map . getNearestWayNode ( new Position ( markers . get ( i ) ) , wayFilter ) ; result . add ( new MapNode [ ] { fromNode , toNode } ) ; fromNode = toNode ; } return result ; }
public DGetNewPassword ( JFrame parent , Dialog . ModalityType modality , PasswordQualityConfig passwordQualityConfig ) { super ( parent , res . getString ( STRING ) , modality ) ; this . passwordQualityConfig = passwordQualityConfig ; initComponents ( ) ; }
public DGetNewPassword ( JFrame parent , Dialog . ModalityType modality , PasswordQualityConfig passwordQualityConfig ) { super ( parent , res . getString ( STRING ) , modality ) ; this . passwordQualityConfig = passwordQualityConfig ; initComponents ( ) ; }
public DGetNewPassword ( JFrame parent , Dialog . ModalityType modality , PasswordQualityConfig passwordQualityConfig ) { super ( parent , res . getString ( STRING ) , modality ) ; this . passwordQualityConfig = passwordQualityConfig ; initComponents ( ) ; }
public static java . sql . Timestamp nowTimestamp ( ) { return getTimestamp ( System . currentTimeMillis ( ) ) ; }
public < U > MonoThenIgnore < U > shift ( Mono < U > newLast ) { Objects . requireNonNull ( newLast , STRING ) ; Mono < ? > [ ] a = ignore ; int n = a . length ; Mono < ? > [ ] b = new Mono [ n + _NUM ] ; System . arraycopy ( a , _NUM , b , _NUM , n ) ; b [ n ] = last ; return new MonoThenIgnore < > ( b , newLast ) ; }
public < U > MonoThenIgnore < U > shift ( Mono < U > newLast ) { Objects . requireNonNull ( newLast , STRING ) ; Mono < ? > [ ] a = ignore ; int n = a . length ; Mono < ? > [ ] b = new Mono [ n + _NUM ] ; System . arraycopy ( a , _NUM , b , _NUM , n ) ; b [ n ] = last ; return new MonoThenIgnore < > ( b , newLast ) ; }
@ SafeVarargs protected < T extends AbstractOptionValue < ? , ? > > AbstractOptions ( Function < T , T > valueFilter , AbstractOptions baseOptions , T ... values ) { requireNonNull ( baseOptions , STRING ) ; requireNonNull ( valueFilter , STRING ) ; requireNonNull ( values , STRING ) ; valueMap = new IdentityHashMap < > ( baseOptions . valueMap ) ; putAll ( valueFilter , Stream . of ( values ) ) ; }
public static JpaModule newClientModule ( String resourceSearchPackage ) { return new JpaModule ( resourceSearchPackage ) ; }
private static Object compressUuid ( String uuid ) { Matcher matcher = COMPRESSIBLE_UUID . matcher ( uuid ) ; if ( uuid . length ( ) == _NUM && matcher . matches ( ) ) { return Integer . valueOf ( matcher . group ( _NUM ) ) ; } return uuid ; }
private static Object compressUuid ( String uuid ) { Matcher matcher = COMPRESSIBLE_UUID . matcher ( uuid ) ; if ( uuid . length ( ) == _NUM && matcher . matches ( ) ) { return Integer . valueOf ( matcher . group ( _NUM ) ) ; } return uuid ; }
private static Object compressUuid ( String uuid ) { Matcher matcher = COMPRESSIBLE_UUID . matcher ( uuid ) ; if ( uuid . length ( ) == _NUM && matcher . matches ( ) ) { return Integer . valueOf ( matcher . group ( _NUM ) ) ; } return uuid ; }
public static void checkHTTPRequestLength ( HttpServletRequest request ) throws ServletException { int maxContentLength = SAMLUtils . getMaxContentLength ( ) ; if ( maxContentLength != _NUM ) { int length = request . getContentLength ( ) ; if ( length == - _NUM ) { throw new ServletException ( bundle . getString ( STRING ) ) ; } if ( length > maxContentLength ) { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + STRING + length ) ; } throw new ServletException ( bundle . getString ( STRING ) ) ; } } }
public static void checkHTTPRequestLength ( HttpServletRequest request ) throws ServletException { int maxContentLength = SAMLUtils . getMaxContentLength ( ) ; if ( maxContentLength != _NUM ) { int length = request . getContentLength ( ) ; if ( length == - _NUM ) { throw new ServletException ( bundle . getString ( STRING ) ) ; } if ( length > maxContentLength ) { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + STRING + length ) ; } throw new ServletException ( bundle . getString ( STRING ) ) ; } } }
public static void checkHTTPRequestLength ( HttpServletRequest request ) throws ServletException { int maxContentLength = SAMLUtils . getMaxContentLength ( ) ; if ( maxContentLength != _NUM ) { int length = request . getContentLength ( ) ; if ( length == - _NUM ) { throw new ServletException ( bundle . getString ( STRING ) ) ; } if ( length > maxContentLength ) { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + STRING + length ) ; } throw new ServletException ( bundle . getString ( STRING ) ) ; } } }
public static void checkHTTPRequestLength ( HttpServletRequest request ) throws ServletException { int maxContentLength = SAMLUtils . getMaxContentLength ( ) ; if ( maxContentLength != _NUM ) { int length = request . getContentLength ( ) ; if ( length == - _NUM ) { throw new ServletException ( bundle . getString ( STRING ) ) ; } if ( length > maxContentLength ) { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + STRING + length ) ; } throw new ServletException ( bundle . getString ( STRING ) ) ; } } }
public static void checkHTTPRequestLength ( HttpServletRequest request ) throws ServletException { int maxContentLength = SAMLUtils . getMaxContentLength ( ) ; if ( maxContentLength != _NUM ) { int length = request . getContentLength ( ) ; if ( length == - _NUM ) { throw new ServletException ( bundle . getString ( STRING ) ) ; } if ( length > maxContentLength ) { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + STRING + length ) ; } throw new ServletException ( bundle . getString ( STRING ) ) ; } } }
public static void checkHTTPRequestLength ( HttpServletRequest request ) throws ServletException { int maxContentLength = SAMLUtils . getMaxContentLength ( ) ; if ( maxContentLength != _NUM ) { int length = request . getContentLength ( ) ; if ( length == - _NUM ) { throw new ServletException ( bundle . getString ( STRING ) ) ; } if ( length > maxContentLength ) { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + STRING + length ) ; } throw new ServletException ( bundle . getString ( STRING ) ) ; } } }
public static void checkHTTPRequestLength ( HttpServletRequest request ) throws ServletException { int maxContentLength = SAMLUtils . getMaxContentLength ( ) ; if ( maxContentLength != _NUM ) { int length = request . getContentLength ( ) ; if ( length == - _NUM ) { throw new ServletException ( bundle . getString ( STRING ) ) ; } if ( length > maxContentLength ) { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + STRING + length ) ; } throw new ServletException ( bundle . getString ( STRING ) ) ; } } }
public void updateTerminalPoints ( mxCellState state , Object source , Object target ) { if ( target != null ) { updateTerminalPoint ( state , target , source , _BOOL ) ; } if ( source != null ) { updateTerminalPoint ( state , source , target , _BOOL ) ; } }
private static void generateGraphFile ( TransMeta transMeta , String graphFile ) throws GraphGeneratorException { DataOutputStream dos = null ; try { String xml = transMeta . getXML ( ) ; dos = new DataOutputStream ( new FileOutputStream ( new File ( graphFile ) ) ) ; dos . write ( xml . getBytes ( CarbonCommonConstants . DEFAULT_CHARSET ) ) ; } catch ( KettleException kettelException ) { throw new GraphGeneratorException ( STRING , kettelException ) ; } catch ( FileNotFoundException e ) { throw new GraphGeneratorException ( STRING , e ) ; } catch ( UnsupportedEncodingException ue ) { throw new GraphGeneratorException ( STRING , ue ) ; } catch ( IOException ioe ) { throw new GraphGeneratorException ( STRING , ioe ) ; } finally { if ( dos != null ) { try { dos . close ( ) ; } catch ( IOException e ) { e . getMessage ( ) ; } } } }
public static List < ? extends ImportModule > performImport ( @ NonNull GradleImport importer , @ NonNull Collection < EclipseProject > projects ) { List < EclipseImportModule > modules = Lists . newArrayList ( ) ; List < EclipseImportModule > replacedByDependencies = Lists . newArrayList ( ) ; for ( EclipseProject project : projects ) { EclipseImportModule module = new EclipseImportModule ( importer , project ) ; module . initialize ( ) ; if ( module . isReplacedWithDependency ( ) ) { replacedByDependencies . add ( module ) ; } else { modules . add ( module ) ; } } for ( EclipseImportModule replaced : replacedByDependencies ) { assert replaced . getReplaceWithDependencies ( ) != null ; EclipseProject project = replaced . getProject ( ) ; for ( EclipseImportModule module : modules ) { if ( module . getProject ( ) . getAllLibraries ( ) . contains ( project ) ) { module . addDependencies ( replaced . getReplaceWithDependencies ( ) ) ; } } } for ( EclipseImportModule module : modules ) { module . removeJarDependencies ( ) ; } Collections . sort ( modules ) ; return modules ; }
public static File writeJUnitTestFile ( String junitOutputDir , String packageName , ExecutableSequence es , String className ) { JunitFileWriter writer = new JunitFileWriter ( junitOutputDir , packageName , STRING ) ; writer . createOutputDir ( ) ; return writer . writeTestClass ( Collections . singletonList ( es ) , className ) ; }
public static File writeJUnitTestFile ( String junitOutputDir , String packageName , ExecutableSequence es , String className ) { JunitFileWriter writer = new JunitFileWriter ( junitOutputDir , packageName , STRING ) ; writer . createOutputDir ( ) ; return writer . writeTestClass ( Collections . singletonList ( es ) , className ) ; }
public static void computePolygonNormal ( FloatBuffer vertexBuffer , FloatBuffer normalBuffer , boolean zPos ) { int n = vertexBuffer . limit ( ) ; double count = _NUM ; Vector3 meanNormal = new Vector3 ( ) ; Vector3 vec0 = new Vector3 ( ) ; Vector3 vec1 = new Vector3 ( ) ; Vector3 vec2 = new Vector3 ( ) ; meanNormal . set ( _NUM , _NUM , _NUM ) ; for ( int i = _NUM ; i < n ; i += _NUM ) { vec0 . set ( vertexBuffer . get ( i ) , vertexBuffer . get ( i + _NUM ) , vertexBuffer . get ( i + _NUM ) ) ; vec1 . set ( vertexBuffer . get ( i + _NUM ) , vertexBuffer . get ( i + _NUM ) , vertexBuffer . get ( i + _NUM ) ) ; vec2 . set ( vertexBuffer . get ( i + _NUM ) , vertexBuffer . get ( i + _NUM ) , vertexBuffer . get ( i + _NUM ) ) ; vec0 . subtractLocal ( vec1 ) ; vec1 . subtractLocal ( vec2 ) ; vec0 . crossLocal ( vec1 ) ; if ( zPos && ( vec0 . getZ ( ) < _NUM ) ) { vec0 . negateLocal ( ) ; } meanNormal . addLocal ( vec0 ) ; count ++ ; } meanNormal . multiplyLocal ( _NUM / count ) ; meanNormal . normalizeLocal ( ) ; for ( int i = _NUM ; i < vertexBuffer . limit ( ) ; i += _NUM ) { normalBuffer . put ( meanNormal . getXf ( ) ) ; normalBuffer . put ( meanNormal . getYf ( ) ) ; normalBuffer . put ( meanNormal . getZf ( ) ) ; } normalBuffer . flip ( ) ; }
public static void addComboBox ( final JPanel panel , final JComboBox < String > comboBox , final String description , final String hint , final boolean value ) { Preconditions . checkNotNull ( panel , STRING ) ; Preconditions . checkNotNull ( comboBox , STRING ) ; Preconditions . checkNotNull ( description , STRING ) ; comboBox . addItem ( STRING ) ; comboBox . addItem ( STRING ) ; comboBox . setSelectedItem ( value ? STRING : STRING ) ; comboBox . setPreferredSize ( new Dimension ( PREFERRED_WIDTH , PREFERRED_HEIGHT ) ) ; addComponent ( panel , comboBox , description , hint ) ; }
private Reader createUTF8Reader ( InputStream stream ) { return new UTF8Reader ( stream , fTempString . ch . length , fErrorReporter . getMessageFormatter ( XMLMessageFormatter . XML_DOMAIN ) , fErrorReporter . getLocale ( ) ) ; }
public void addPermittedDomain ( String domainName ) { if ( StringUtils . isEmpty ( domainName ) ) { return ; } if ( permittedDomains == null ) { permittedDomains = new ArrayList < > ( ) ; } permittedDomains . add ( domainName ) ; }
private void addCombineMenu ( final JFrame parent , final ITraceListProvider traceProvider , final int [ ] selectedRows ) { addSeparator ( ) ; final JMenu combineMenu = new JMenu ( STRING ) ; final List < TraceList > traces = getTraces ( traceProvider , selectedRows ) ; combineMenu . add ( CActionProxy . proxy ( new CActionCombineTraces ( parent , traceProvider , traces ) ) ) ; combineMenu . add ( CActionProxy . proxy ( new CActionIntersectTraces ( parent , traceProvider , traces ) ) ) ; if ( traces . size ( ) == _NUM ) { combineMenu . addSeparator ( ) ; combineMenu . add ( CActionProxy . proxy ( new CActionDifferenceTraces ( parent , traceProvider , traces . get ( _NUM ) , traces . get ( _NUM ) ) ) ) ; combineMenu . add ( CActionProxy . proxy ( new CActionDifferenceTraces ( parent , traceProvider , traces . get ( _NUM ) , traces . get ( _NUM ) ) ) ) ; } add ( combineMenu ) ; }
private void addCombineMenu ( final JFrame parent , final ITraceListProvider traceProvider , final int [ ] selectedRows ) { addSeparator ( ) ; final JMenu combineMenu = new JMenu ( STRING ) ; final List < TraceList > traces = getTraces ( traceProvider , selectedRows ) ; combineMenu . add ( CActionProxy . proxy ( new CActionCombineTraces ( parent , traceProvider , traces ) ) ) ; combineMenu . add ( CActionProxy . proxy ( new CActionIntersectTraces ( parent , traceProvider , traces ) ) ) ; if ( traces . size ( ) == _NUM ) { combineMenu . addSeparator ( ) ; combineMenu . add ( CActionProxy . proxy ( new CActionDifferenceTraces ( parent , traceProvider , traces . get ( _NUM ) , traces . get ( _NUM ) ) ) ) ; combineMenu . add ( CActionProxy . proxy ( new CActionDifferenceTraces ( parent , traceProvider , traces . get ( _NUM ) , traces . get ( _NUM ) ) ) ) ; } add ( combineMenu ) ; }
private void addCombineMenu ( final JFrame parent , final ITraceListProvider traceProvider , final int [ ] selectedRows ) { addSeparator ( ) ; final JMenu combineMenu = new JMenu ( STRING ) ; final List < TraceList > traces = getTraces ( traceProvider , selectedRows ) ; combineMenu . add ( CActionProxy . proxy ( new CActionCombineTraces ( parent , traceProvider , traces ) ) ) ; combineMenu . add ( CActionProxy . proxy ( new CActionIntersectTraces ( parent , traceProvider , traces ) ) ) ; if ( traces . size ( ) == _NUM ) { combineMenu . addSeparator ( ) ; combineMenu . add ( CActionProxy . proxy ( new CActionDifferenceTraces ( parent , traceProvider , traces . get ( _NUM ) , traces . get ( _NUM ) ) ) ) ; combineMenu . add ( CActionProxy . proxy ( new CActionDifferenceTraces ( parent , traceProvider , traces . get ( _NUM ) , traces . get ( _NUM ) ) ) ) ; } add ( combineMenu ) ; }
public void cancelRequestsByTAG ( Object TAG , boolean mayInterruptIfRunning ) { if ( TAG == null ) { return ; } for ( List < RequestHandle > requestList : requestMap . values ( ) ) { if ( requestList != null ) { for ( RequestHandle requestHandle : requestList ) { if ( TAG . equals ( requestHandle . getTag ( ) ) ) requestHandle . cancel ( mayInterruptIfRunning ) ; } } } }
public void cancelRequestsByTAG ( Object TAG , boolean mayInterruptIfRunning ) { if ( TAG == null ) { return ; } for ( List < RequestHandle > requestList : requestMap . values ( ) ) { if ( requestList != null ) { for ( RequestHandle requestHandle : requestList ) { if ( TAG . equals ( requestHandle . getTag ( ) ) ) requestHandle . cancel ( mayInterruptIfRunning ) ; } } } }
public void cancelRequestsByTAG ( Object TAG , boolean mayInterruptIfRunning ) { if ( TAG == null ) { return ; } for ( List < RequestHandle > requestList : requestMap . values ( ) ) { if ( requestList != null ) { for ( RequestHandle requestHandle : requestList ) { if ( TAG . equals ( requestHandle . getTag ( ) ) ) requestHandle . cancel ( mayInterruptIfRunning ) ; } } } }
public void cancelRequestsByTAG ( Object TAG , boolean mayInterruptIfRunning ) { if ( TAG == null ) { return ; } for ( List < RequestHandle > requestList : requestMap . values ( ) ) { if ( requestList != null ) { for ( RequestHandle requestHandle : requestList ) { if ( TAG . equals ( requestHandle . getTag ( ) ) ) requestHandle . cancel ( mayInterruptIfRunning ) ; } } } }
private static AccessControlContext createPrivilegedContext ( Class caller , AccessControlContext acc ) { DomainCombiner comb = acc . getDomainCombiner ( ) ; ProtectionDomain pd = caller . getProtectionDomain ( ) ; ProtectionDomain [ ] pds = ( pd != null ) ? new ProtectionDomain [ ] { pd } : null ; if ( comb != null ) { pds = comb . combine ( pds , null ) ; } if ( pds == null ) { pds = new ProtectionDomain [ _NUM ] ; } return new AccessControlContext ( new AccessControlContext ( pds ) , comb ) ; }
private static AccessControlContext createPrivilegedContext ( Class caller , AccessControlContext acc ) { DomainCombiner comb = acc . getDomainCombiner ( ) ; ProtectionDomain pd = caller . getProtectionDomain ( ) ; ProtectionDomain [ ] pds = ( pd != null ) ? new ProtectionDomain [ ] { pd } : null ; if ( comb != null ) { pds = comb . combine ( pds , null ) ; } if ( pds == null ) { pds = new ProtectionDomain [ _NUM ] ; } return new AccessControlContext ( new AccessControlContext ( pds ) , comb ) ; }
private static AccessControlContext createPrivilegedContext ( Class caller , AccessControlContext acc ) { DomainCombiner comb = acc . getDomainCombiner ( ) ; ProtectionDomain pd = caller . getProtectionDomain ( ) ; ProtectionDomain [ ] pds = ( pd != null ) ? new ProtectionDomain [ ] { pd } : null ; if ( comb != null ) { pds = comb . combine ( pds , null ) ; } if ( pds == null ) { pds = new ProtectionDomain [ _NUM ] ; } return new AccessControlContext ( new AccessControlContext ( pds ) , comb ) ; }
private static AccessControlContext createPrivilegedContext ( Class caller , AccessControlContext acc ) { DomainCombiner comb = acc . getDomainCombiner ( ) ; ProtectionDomain pd = caller . getProtectionDomain ( ) ; ProtectionDomain [ ] pds = ( pd != null ) ? new ProtectionDomain [ ] { pd } : null ; if ( comb != null ) { pds = comb . combine ( pds , null ) ; } if ( pds == null ) { pds = new ProtectionDomain [ _NUM ] ; } return new AccessControlContext ( new AccessControlContext ( pds ) , comb ) ; }
private static AccessControlContext createPrivilegedContext ( Class caller , AccessControlContext acc ) { DomainCombiner comb = acc . getDomainCombiner ( ) ; ProtectionDomain pd = caller . getProtectionDomain ( ) ; ProtectionDomain [ ] pds = ( pd != null ) ? new ProtectionDomain [ ] { pd } : null ; if ( comb != null ) { pds = comb . combine ( pds , null ) ; } if ( pds == null ) { pds = new ProtectionDomain [ _NUM ] ; } return new AccessControlContext ( new AccessControlContext ( pds ) , comb ) ; }
private void sendCommittedText ( ) { AttributedString as = new AttributedString ( buffer . toString ( ) ) ; context . dispatchInputMethodEvent ( InputMethodEvent . INPUT_METHOD_TEXT_CHANGED , as . getIterator ( ) , buffer . length ( ) , TextHitInfo . leading ( insertionPoint ) , null ) ; buffer . setLength ( _NUM ) ; insertionPoint = _NUM ; format = UNSET ; }
public double snap ( double value ) { if ( gridEnabled ) { value = Math . round ( value / gridSize ) * gridSize ; } return value ; }
public KeyPair generateKeyPair ( ) throws KeyStoreException { KeyPair keyPair ; try { KeyPairGenerator generator = KeyPairGenerator . getInstance ( STRING ) ; generator . initialize ( _NUM ) ; keyPair = generator . generateKeyPair ( ) ; } catch ( NoSuchAlgorithmException e ) { throw new KeyStoreException ( STRING , e ) ; } return keyPair ; }
public final static boolean inLongRange ( char [ ] digitChars , int offset , int len , boolean negative ) { String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR ; int cmpLen = cmpStr . length ( ) ; if ( len < cmpLen ) return _BOOL ; if ( len > cmpLen ) return _BOOL ; for ( int i = _NUM ; i < cmpLen ; ++ i ) { if ( digitChars [ offset + i ] > cmpStr . charAt ( i ) ) { return _BOOL ; } } return _BOOL ; }
public final static boolean inLongRange ( char [ ] digitChars , int offset , int len , boolean negative ) { String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR ; int cmpLen = cmpStr . length ( ) ; if ( len < cmpLen ) return _BOOL ; if ( len > cmpLen ) return _BOOL ; for ( int i = _NUM ; i < cmpLen ; ++ i ) { if ( digitChars [ offset + i ] > cmpStr . charAt ( i ) ) { return _BOOL ; } } return _BOOL ; }
public final static boolean inLongRange ( char [ ] digitChars , int offset , int len , boolean negative ) { String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR ; int cmpLen = cmpStr . length ( ) ; if ( len < cmpLen ) return _BOOL ; if ( len > cmpLen ) return _BOOL ; for ( int i = _NUM ; i < cmpLen ; ++ i ) { if ( digitChars [ offset + i ] > cmpStr . charAt ( i ) ) { return _BOOL ; } } return _BOOL ; }
public final static boolean inLongRange ( char [ ] digitChars , int offset , int len , boolean negative ) { String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR ; int cmpLen = cmpStr . length ( ) ; if ( len < cmpLen ) return _BOOL ; if ( len > cmpLen ) return _BOOL ; for ( int i = _NUM ; i < cmpLen ; ++ i ) { if ( digitChars [ offset + i ] > cmpStr . charAt ( i ) ) { return _BOOL ; } } return _BOOL ; }
public final static boolean inLongRange ( char [ ] digitChars , int offset , int len , boolean negative ) { String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR ; int cmpLen = cmpStr . length ( ) ; if ( len < cmpLen ) return _BOOL ; if ( len > cmpLen ) return _BOOL ; for ( int i = _NUM ; i < cmpLen ; ++ i ) { if ( digitChars [ offset + i ] > cmpStr . charAt ( i ) ) { return _BOOL ; } } return _BOOL ; }
public final static boolean inLongRange ( char [ ] digitChars , int offset , int len , boolean negative ) { String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR ; int cmpLen = cmpStr . length ( ) ; if ( len < cmpLen ) return _BOOL ; if ( len > cmpLen ) return _BOOL ; for ( int i = _NUM ; i < cmpLen ; ++ i ) { if ( digitChars [ offset + i ] > cmpStr . charAt ( i ) ) { return _BOOL ; } } return _BOOL ; }
public static String extractFromCode128 ( String code ) { if ( code . length ( ) < _NUM ) { return null ; } if ( code . startsWith ( STRING ) || code . startsWith ( STRING ) ) { return code . substring ( _NUM , _NUM ) ; } return null ; }
private void updateStatusLabel ( ) { String text = STRING ; if ( searchResult != null ) { switch ( searchResult . size ( ) ) { case _NUM : text = STRING ; break ; case _NUM : text = STRING ; break ; default : text = STRING + ( searchResultIndex + _NUM ) + STRING + searchResult . size ( ) + STRING ; } } statusText . setText ( text ) ; }
private void updateStatusLabel ( ) { String text = STRING ; if ( searchResult != null ) { switch ( searchResult . size ( ) ) { case _NUM : text = STRING ; break ; case _NUM : text = STRING ; break ; default : text = STRING + ( searchResultIndex + _NUM ) + STRING + searchResult . size ( ) + STRING ; } } statusText . setText ( text ) ; }
public final synchronized Offset findOrCreateJtocOffset ( ) { if ( VM . VerifyAssertions ) VM . _assert ( ! isStatic ( ) && ! isObjectInitializer ( ) ) ; Offset jtocOffset = getJtocOffset ( ) ; ; if ( jtocOffset . EQ ( Offset . zero ( ) ) ) { jtocOffset = Statics . allocateReferenceSlot ( _BOOL ) ; Statics . setSlotContents ( jtocOffset , getCurrentEntryCodeArray ( ) ) ; synchronized ( jtocOffsets ) { jtocOffsets . put ( this , Integer . valueOf ( jtocOffset . toInt ( ) ) ) ; } } return jtocOffset ; }
public UpdateResponse remove ( long id ) throws IOException , SolrServerException { UpdateResponse res = solrClient . deleteById ( String . valueOf ( id ) ) ; solrClient . commit ( _BOOL , _BOOL , _BOOL ) ; return res ; }
void STAR_encoding_diag1 ( ) { int i , j , stripe , k ; char [ ] [ ] tmp ; tmp = new char [ block_nbr + _NUM ] [ block_size ] ; for ( stripe = _NUM ; stripe < block_nbr + _NUM ; stripe ++ ) { for ( i = _NUM ; i < data_disk_nbr ; i ++ ) { for ( j = _NUM ; j < block_size ; j ++ ) { k = ( stripe - i + p ) % p ; if ( k < block_nbr ) { tmp [ stripe ] [ j ] ^= check_data [ i ] [ ( stripe - i + p ) % p * block_size + j ] ; } } } } for ( i = _NUM ; i < block_nbr ; i ++ ) { for ( j = _NUM ; j < block_size ; j ++ ) { tmp [ i ] [ j ] = ( char ) ( tmp [ i ] [ j ] ^ tmp [ block_nbr ] [ j ] ) ; } } for ( i = _NUM ; i < block_nbr ; i ++ ) { System . arraycopy ( tmp [ i ] , _NUM , check_data [ data_disk_nbr + _NUM ] , i * block_size , block_size ) ; } }
void STAR_encoding_diag1 ( ) { int i , j , stripe , k ; char [ ] [ ] tmp ; tmp = new char [ block_nbr + _NUM ] [ block_size ] ; for ( stripe = _NUM ; stripe < block_nbr + _NUM ; stripe ++ ) { for ( i = _NUM ; i < data_disk_nbr ; i ++ ) { for ( j = _NUM ; j < block_size ; j ++ ) { k = ( stripe - i + p ) % p ; if ( k < block_nbr ) { tmp [ stripe ] [ j ] ^= check_data [ i ] [ ( stripe - i + p ) % p * block_size + j ] ; } } } } for ( i = _NUM ; i < block_nbr ; i ++ ) { for ( j = _NUM ; j < block_size ; j ++ ) { tmp [ i ] [ j ] = ( char ) ( tmp [ i ] [ j ] ^ tmp [ block_nbr ] [ j ] ) ; } } for ( i = _NUM ; i < block_nbr ; i ++ ) { System . arraycopy ( tmp [ i ] , _NUM , check_data [ data_disk_nbr + _NUM ] , i * block_size , block_size ) ; } }
@ Override public String toString ( ) { StringBuilder result = new StringBuilder ( ) ; result . append ( type . toString ( ) ) ; result . append ( STRING ) ; result . append ( name ) ; result . append ( STRING ) ; if ( fieldsData != null ) { result . append ( fieldsData ) ; } result . append ( STRING ) ; return result . toString ( ) ; }
public void runTest ( ) throws Throwable { Document doc ; EntityReference entRef ; CharacterData entText ; doc = ( Document ) load ( STRING , _BOOL ) ; entRef = doc . createEntityReference ( STRING ) ; assertNotNull ( STRING , entRef ) ; entText = ( CharacterData ) entRef . getFirstChild ( ) ; assertNotNull ( STRING , entText ) ; { boolean success = _BOOL ; try { entText . setNodeValue ( STRING ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } assertTrue ( STRING , success ) ; } }
protected MutableCoord calculatePointOnLine ( MutableCoord P1 , MutableCoord P2 , MutableCoord P3 ) { double rel = calculateRelation ( P1 , P2 , P3 ) ; double dx = Math . abs ( P1 . getX ( ) - P2 . getX ( ) ) , dy = Math . abs ( P1 . getY ( ) - P2 . getY ( ) ) ; double nx = P1 . getX ( ) + dx * rel , ny = P1 . getY ( ) + dy * rel ; if ( P1 . getX ( ) > P2 . getX ( ) ) nx = P1 . getX ( ) - dx * rel ; if ( P1 . getY ( ) > P2 . getY ( ) ) ny = P1 . getY ( ) - dy * rel ; MutableCoord result = new MutableCoord ( nx , ny ) ; return result ; }
public static void checkConvergenceFromAnyHost ( ServiceHost host , NodeGroupState ngs , Operation parentOp ) { checkConvergenceAcrossPeers ( host , ngs , parentOp ) ; }
public static void checkConvergenceFromAnyHost ( ServiceHost host , NodeGroupState ngs , Operation parentOp ) { checkConvergenceAcrossPeers ( host , ngs , parentOp ) ; }
public static void checkConvergenceFromAnyHost ( ServiceHost host , NodeGroupState ngs , Operation parentOp ) { checkConvergenceAcrossPeers ( host , ngs , parentOp ) ; }
public static void checkConvergenceFromAnyHost ( ServiceHost host , NodeGroupState ngs , Operation parentOp ) { checkConvergenceAcrossPeers ( host , ngs , parentOp ) ; }
public void cacheResolvedMethod ( Class clas , Class [ ] types , Method method ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + clas + STRING + method ) ; SignatureKey sk = new SignatureKey ( clas , method . getName ( ) , types ) ; if ( Modifier . isStatic ( method . getModifiers ( ) ) ) resolvedStaticMethods . put ( sk , method ) ; else resolvedObjectMethods . put ( sk , method ) ; }
public void cacheResolvedMethod ( Class clas , Class [ ] types , Method method ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + clas + STRING + method ) ; SignatureKey sk = new SignatureKey ( clas , method . getName ( ) , types ) ; if ( Modifier . isStatic ( method . getModifiers ( ) ) ) resolvedStaticMethods . put ( sk , method ) ; else resolvedObjectMethods . put ( sk , method ) ; }
public void cacheResolvedMethod ( Class clas , Class [ ] types , Method method ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + clas + STRING + method ) ; SignatureKey sk = new SignatureKey ( clas , method . getName ( ) , types ) ; if ( Modifier . isStatic ( method . getModifiers ( ) ) ) resolvedStaticMethods . put ( sk , method ) ; else resolvedObjectMethods . put ( sk , method ) ; }
public void cacheResolvedMethod ( Class clas , Class [ ] types , Method method ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + clas + STRING + method ) ; SignatureKey sk = new SignatureKey ( clas , method . getName ( ) , types ) ; if ( Modifier . isStatic ( method . getModifiers ( ) ) ) resolvedStaticMethods . put ( sk , method ) ; else resolvedObjectMethods . put ( sk , method ) ; }
public void cacheResolvedMethod ( Class clas , Class [ ] types , Method method ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + clas + STRING + method ) ; SignatureKey sk = new SignatureKey ( clas , method . getName ( ) , types ) ; if ( Modifier . isStatic ( method . getModifiers ( ) ) ) resolvedStaticMethods . put ( sk , method ) ; else resolvedObjectMethods . put ( sk , method ) ; }
public void cacheResolvedMethod ( Class clas , Class [ ] types , Method method ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + clas + STRING + method ) ; SignatureKey sk = new SignatureKey ( clas , method . getName ( ) , types ) ; if ( Modifier . isStatic ( method . getModifiers ( ) ) ) resolvedStaticMethods . put ( sk , method ) ; else resolvedObjectMethods . put ( sk , method ) ; }
public Java2TypeScriptTranslator ( TranspilationHandler logHandler , JSweetContext context , JCCompilationUnit compilationUnit , boolean preserveSourceLineNumbers ) { super ( logHandler , context , compilationUnit , new Java2TypeScriptAdapter ( context ) , preserveSourceLineNumbers ) ; }
private IPreferenceStore createCombinedPreferenceStore ( IEditorInput input ) { List stores = new ArrayList ( ) ; addPreferenceStores ( stores , input ) ; return new ChainedPreferenceStore ( ( IPreferenceStore [ ] ) stores . toArray ( new IPreferenceStore [ stores . size ( ) ] ) ) ; }
public void removeElementAt ( int index ) { if ( getElementAt ( index ) == m_selectedObject ) { if ( index == _NUM ) setSelectedItem ( getSize ( ) == _NUM ? null : getElementAt ( index + _NUM ) ) ; else setSelectedItem ( getElementAt ( index - _NUM ) ) ; } p_data . remove ( index ) ; fireIntervalRemoved ( this , index , index ) ; }
public void removeElementAt ( int index ) { if ( getElementAt ( index ) == m_selectedObject ) { if ( index == _NUM ) setSelectedItem ( getSize ( ) == _NUM ? null : getElementAt ( index + _NUM ) ) ; else setSelectedItem ( getElementAt ( index - _NUM ) ) ; } p_data . remove ( index ) ; fireIntervalRemoved ( this , index , index ) ; }
@ ZapApiIgnore public boolean isConfirmRemoveProxyExcludedDomain ( ) { return this . confirmRemoveProxyExcludeDomain ; }
public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( STRING , STRING ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( STRING , className , STRING ) ; } } }
public void add ( int start , int end , int handler , int type ) { if ( start < end ) entries . add ( new ExceptionTableEntry ( start , end , handler , type ) ) ; }
public void add ( int start , int end , int handler , int type ) { if ( start < end ) entries . add ( new ExceptionTableEntry ( start , end , handler , type ) ) ; }
protected void checkResultByText ( @ NonNls @ NotNull String fileText ) { checkResultByText ( null , fileText , _BOOL , null ) ; }
@ Override public boolean equals ( Object o ) { if ( this == o ) return _BOOL ; if ( o == null || getClass ( ) != o . getClass ( ) ) return _BOOL ; AbstractUserNotification that = ( AbstractUserNotification ) o ; return ! ( notificationConfiguration != null ? ! notificationConfiguration . equals ( that . notificationConfiguration ) : that . notificationConfiguration != null ) ; }
void onUpdate ( Data data ) ;
public static void writeVarInt ( OutputStream out , int x ) throws IOException { while ( ( x & ~ _NUM ) != _NUM ) { out . write ( ( byte ) ( _NUM | ( x & _NUM ) ) ) ; x >>>= _NUM ; } out . write ( ( byte ) x ) ; }
public static BufferedImage convertToARGB ( BufferedImage image ) { if ( image . getType ( ) != BufferedImage . TYPE_INT_ARGB ) { try { final BufferedImage raw_image = image ; image = new BufferedImage ( raw_image . getWidth ( ) , raw_image . getHeight ( ) , BufferedImage . TYPE_INT_ARGB ) ; final ColorConvertOp xformOp = new ColorConvertOp ( null ) ; xformOp . filter ( raw_image , image ) ; } catch ( final Exception e ) { LogWriter . writeLog ( STRING + e + STRING ) ; } } isUsingARGB = _BOOL ; return image ; }
public static BufferedImage convertToARGB ( BufferedImage image ) { if ( image . getType ( ) != BufferedImage . TYPE_INT_ARGB ) { try { final BufferedImage raw_image = image ; image = new BufferedImage ( raw_image . getWidth ( ) , raw_image . getHeight ( ) , BufferedImage . TYPE_INT_ARGB ) ; final ColorConvertOp xformOp = new ColorConvertOp ( null ) ; xformOp . filter ( raw_image , image ) ; } catch ( final Exception e ) { LogWriter . writeLog ( STRING + e + STRING ) ; } } isUsingARGB = _BOOL ; return image ; }
public static BufferedImage convertToARGB ( BufferedImage image ) { if ( image . getType ( ) != BufferedImage . TYPE_INT_ARGB ) { try { final BufferedImage raw_image = image ; image = new BufferedImage ( raw_image . getWidth ( ) , raw_image . getHeight ( ) , BufferedImage . TYPE_INT_ARGB ) ; final ColorConvertOp xformOp = new ColorConvertOp ( null ) ; xformOp . filter ( raw_image , image ) ; } catch ( final Exception e ) { LogWriter . writeLog ( STRING + e + STRING ) ; } } isUsingARGB = _BOOL ; return image ; }
public static BufferedImage convertToARGB ( BufferedImage image ) { if ( image . getType ( ) != BufferedImage . TYPE_INT_ARGB ) { try { final BufferedImage raw_image = image ; image = new BufferedImage ( raw_image . getWidth ( ) , raw_image . getHeight ( ) , BufferedImage . TYPE_INT_ARGB ) ; final ColorConvertOp xformOp = new ColorConvertOp ( null ) ; xformOp . filter ( raw_image , image ) ; } catch ( final Exception e ) { LogWriter . writeLog ( STRING + e + STRING ) ; } } isUsingARGB = _BOOL ; return image ; }
public static int calculateRMSLevel ( short [ ] audioData , int numframes ) { long lSum = _NUM ; int numread = _NUM ; for ( short s : audioData ) { lSum = lSum + s ; numread ++ ; if ( numread == numframes ) break ; } double dAvg = lSum / numframes ; double sumMeanSquare = _NUM ; numread = _NUM ; for ( short anAudioData : audioData ) { sumMeanSquare = sumMeanSquare + Math . pow ( anAudioData - dAvg , _NUM ) ; numread ++ ; if ( numread == numframes ) break ; } double averageMeanSquare = sumMeanSquare / numframes ; return ( int ) ( Math . pow ( averageMeanSquare , _NUM ) + _NUM ) ; }
private void calculateD ( double [ ] b ) { int length = mExtremalIndices . size ( ) - _NUM ; mD = new double [ length ] ; for ( int k = _NUM ; k < length ; k ++ ) { mD [ k ] = b [ k ] * ( mGrid . getCosineFrequencyGrid ( ) [ mExtremalIndices . get ( k ) ] - mGrid . getCosineFrequencyGrid ( ) [ mExtremalIndices . get ( length ) ] ) ; } }
public void addAttributePanelListener ( AttributePanelListener a ) { m_Listeners . add ( a ) ; }
private static String capitalFirst ( @ Nullable String str ) { return str == null ? null : str . isEmpty ( ) ? STRING : Character . toUpperCase ( str . charAt ( _NUM ) ) + str . substring ( _NUM ) ; }
public void storeStepData ( URI workflowURI , String key , String stepId , Object data ) { WorkflowStepData dataRecord = getWorkflowStepData ( workflowURI , stepId , key ) ; boolean created = _BOOL ; if ( dataRecord == null ) { dataRecord = new WorkflowStepData ( ) ; dataRecord . setId ( URIUtil . createId ( WorkflowStepData . class ) ) ; dataRecord . setWorkflowId ( workflowURI ) ; dataRecord . setStepId ( stepId ) ; dataRecord . setLabel ( key ) ; created = _BOOL ; } dataRecord . setData ( GenericSerializer . serialize ( data ) ) ; if ( created ) { _dbClient . createObject ( dataRecord ) ; _log . info ( String . format ( STRING , workflowURI , stepId , key ) ) ; } else { _dbClient . updateObject ( dataRecord ) ; _log . info ( String . format ( STRING , workflowURI , stepId , key ) ) ; } }
public void storeStepData ( URI workflowURI , String key , String stepId , Object data ) { WorkflowStepData dataRecord = getWorkflowStepData ( workflowURI , stepId , key ) ; boolean created = _BOOL ; if ( dataRecord == null ) { dataRecord = new WorkflowStepData ( ) ; dataRecord . setId ( URIUtil . createId ( WorkflowStepData . class ) ) ; dataRecord . setWorkflowId ( workflowURI ) ; dataRecord . setStepId ( stepId ) ; dataRecord . setLabel ( key ) ; created = _BOOL ; } dataRecord . setData ( GenericSerializer . serialize ( data ) ) ; if ( created ) { _dbClient . createObject ( dataRecord ) ; _log . info ( String . format ( STRING , workflowURI , stepId , key ) ) ; } else { _dbClient . updateObject ( dataRecord ) ; _log . info ( String . format ( STRING , workflowURI , stepId , key ) ) ; } }
public void appendLocalVariableLabel ( ILocalVariable localVariable , long flags ) { if ( getFlag ( flags , JavaElementLabels . F_PRE_TYPE_SIGNATURE ) ) { appendTypeSignatureLabel ( localVariable , localVariable . getTypeSignature ( ) , flags ) ; fBuffer . append ( STRING ) ; } if ( getFlag ( flags , JavaElementLabels . F_FULLY_QUALIFIED ) ) { appendElementLabel ( localVariable . getDeclaringMember ( ) , JavaElementLabels . M_PARAMETER_TYPES | JavaElementLabels . M_FULLY_QUALIFIED | JavaElementLabels . T_FULLY_QUALIFIED | ( flags & QUALIFIER_FLAGS ) ) ; fBuffer . append ( STRING ) ; } fBuffer . append ( getElementName ( localVariable ) ) ; if ( getFlag ( flags , JavaElementLabels . F_APP_TYPE_SIGNATURE ) ) { int offset = fBuffer . length ( ) ; fBuffer . append ( JavaElementLabels . DECL_STRING ) ; appendTypeSignatureLabel ( localVariable , localVariable . getTypeSignature ( ) , flags ) ; if ( getFlag ( flags , JavaElementLabels . COLORIZE ) ) { } } if ( getFlag ( flags , JavaElementLabels . F_POST_QUALIFIED ) ) { fBuffer . append ( JavaElementLabels . CONCAT_STRING ) ; appendElementLabel ( localVariable . getDeclaringMember ( ) , JavaElementLabels . M_PARAMETER_TYPES | JavaElementLabels . M_FULLY_QUALIFIED | JavaElementLabels . T_FULLY_QUALIFIED | ( flags & QUALIFIER_FLAGS ) ) ; } }
public void message ( Map headers , String body ) { transmit ( Command . MESSAGE , headers , body ) ; }
public void removeStat ( String key ) throws AdeInternalException { if ( ! m_allKeys . remove ( key ) ) { throw new AdeInternalException ( STRING + key ) ; } if ( m_doubleStats . remove ( key ) == null && m_stringStats . remove ( key ) == null ) { throw new AdeInternalException ( STRING ) ; } }
private double sin ( double angle ) { while ( angle >= _NUM ) { angle -= _NUM ; } double value = angle / _NUM * Math . PI ; return Math . sin ( value ) ; }
public static String addToList ( String newItem , String semicolonSepList , int maxItems ) { StringBuilder sb = new StringBuilder ( newItem ) ; String [ ] items = semicolonSepList . split ( STRING ) ; for ( int i = _NUM ; i < items . length && i < maxItems ; i ++ ) { String port = items [ i ] ; if ( port . equals ( newItem ) ) { continue ; } sb . append ( STRING ) ; sb . append ( port ) ; } return sb . toString ( ) ; }
public void addMarker ( ) { ClusterOrder order = getClusterOrder ( ) ; DBIDSelection selContext = context . getSelection ( ) ; if ( selContext != null ) { DBIDs selection = DBIDUtil . ensureSet ( selContext . getSelectedIds ( ) ) ; final double width = plotwidth / order . size ( ) ; int begin = - _NUM , j = _NUM ; for ( DBIDIter it = order . iter ( ) ; it . valid ( ) ; it . advance ( ) , j ++ ) { if ( selection . contains ( it ) ) { if ( begin == - _NUM ) { begin = j ; } } else { if ( begin != - _NUM ) { Element marker = addMarkerRect ( begin * width , ( j - begin ) * width ) ; SVGUtil . addCSSClass ( marker , CSS_MARKER ) ; mtag . appendChild ( marker ) ; begin = - _NUM ; } } } if ( begin != - _NUM ) { Element marker = addMarkerRect ( begin * width , ( order . size ( ) - begin ) * width ) ; SVGUtil . addCSSClass ( marker , CSS_MARKER ) ; mtag . appendChild ( marker ) ; } } }
public void addMarker ( ) { ClusterOrder order = getClusterOrder ( ) ; DBIDSelection selContext = context . getSelection ( ) ; if ( selContext != null ) { DBIDs selection = DBIDUtil . ensureSet ( selContext . getSelectedIds ( ) ) ; final double width = plotwidth / order . size ( ) ; int begin = - _NUM , j = _NUM ; for ( DBIDIter it = order . iter ( ) ; it . valid ( ) ; it . advance ( ) , j ++ ) { if ( selection . contains ( it ) ) { if ( begin == - _NUM ) { begin = j ; } } else { if ( begin != - _NUM ) { Element marker = addMarkerRect ( begin * width , ( j - begin ) * width ) ; SVGUtil . addCSSClass ( marker , CSS_MARKER ) ; mtag . appendChild ( marker ) ; begin = - _NUM ; } } } if ( begin != - _NUM ) { Element marker = addMarkerRect ( begin * width , ( order . size ( ) - begin ) * width ) ; SVGUtil . addCSSClass ( marker , CSS_MARKER ) ; mtag . appendChild ( marker ) ; } } }
static void addTemporalLevelConstraintToConstants ( HashSet params , SetOfLevelConstraints constrs ) { Iterator iter = params . iterator ( ) ; while ( iter . hasNext ( ) ) { LevelNode node = ( LevelNode ) iter . next ( ) ; if ( node . getKind ( ) == ConstantDeclKind ) { constrs . put ( node , Levels [ ActionLevel ] ) ; } ; } }
static void addTemporalLevelConstraintToConstants ( HashSet params , SetOfLevelConstraints constrs ) { Iterator iter = params . iterator ( ) ; while ( iter . hasNext ( ) ) { LevelNode node = ( LevelNode ) iter . next ( ) ; if ( node . getKind ( ) == ConstantDeclKind ) { constrs . put ( node , Levels [ ActionLevel ] ) ; } ; } }
public String toStringByValue ( ) { LongArrayList theKeys = new LongArrayList ( ) ; keysSortedByValue ( theKeys ) ; StringBuffer buf = new StringBuffer ( ) ; buf . append ( STRING ) ; int maxIndex = theKeys . size ( ) - _NUM ; for ( int i = _NUM ; i <= maxIndex ; i ++ ) { long key = theKeys . get ( i ) ; buf . append ( String . valueOf ( key ) ) ; buf . append ( STRING ) ; buf . append ( String . valueOf ( get ( key ) ) ) ; if ( i < maxIndex ) buf . append ( STRING ) ; } buf . append ( STRING ) ; return buf . toString ( ) ; }
public String toStringByValue ( ) { LongArrayList theKeys = new LongArrayList ( ) ; keysSortedByValue ( theKeys ) ; StringBuffer buf = new StringBuffer ( ) ; buf . append ( STRING ) ; int maxIndex = theKeys . size ( ) - _NUM ; for ( int i = _NUM ; i <= maxIndex ; i ++ ) { long key = theKeys . get ( i ) ; buf . append ( String . valueOf ( key ) ) ; buf . append ( STRING ) ; buf . append ( String . valueOf ( get ( key ) ) ) ; if ( i < maxIndex ) buf . append ( STRING ) ; } buf . append ( STRING ) ; return buf . toString ( ) ; }
public String toStringByValue ( ) { LongArrayList theKeys = new LongArrayList ( ) ; keysSortedByValue ( theKeys ) ; StringBuffer buf = new StringBuffer ( ) ; buf . append ( STRING ) ; int maxIndex = theKeys . size ( ) - _NUM ; for ( int i = _NUM ; i <= maxIndex ; i ++ ) { long key = theKeys . get ( i ) ; buf . append ( String . valueOf ( key ) ) ; buf . append ( STRING ) ; buf . append ( String . valueOf ( get ( key ) ) ) ; if ( i < maxIndex ) buf . append ( STRING ) ; } buf . append ( STRING ) ; return buf . toString ( ) ; }
boolean removeEntry ( PolicyEntry pe ) { parser . remove ( pe . getGrantEntry ( ) ) ; modified = _BOOL ; return ( policyEntries . removeElement ( pe ) ) ; }
static private String INT_Min ( ) { int tempValue = Integer . MIN_VALUE ; return String . valueOf ( tempValue ) ; }
public void updateVisibleIds ( List < Integer > priority ) { if ( mNativeTabContentManager != _NUM ) { int idsSize = Math . min ( mFullResThumbnailsMaxSize , priority . size ( ) ) ; if ( idsSize != mPriorityTabIds . length ) { mPriorityTabIds = new int [ idsSize ] ; } for ( int i = _NUM ; i < idsSize ; i ++ ) { mPriorityTabIds [ i ] = priority . get ( i ) ; } nativeUpdateVisibleIds ( mNativeTabContentManager , mPriorityTabIds ) ; } }
private Segment createDiskSegment ( SegmentDescriptor descriptor ) { File segmentFile = SegmentFile . createSegmentFile ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ; Buffer buffer = FileBuffer . allocate ( segmentFile , Math . min ( DEFAULT_BUFFER_SIZE , descriptor . maxSegmentSize ( ) ) , Integer . MAX_VALUE ) ; descriptor . copyTo ( buffer ) ; Segment segment = new Segment ( new SegmentFile ( segmentFile ) , buffer . slice ( ) , descriptor , createIndex ( descriptor ) , new OffsetPredicate ( ) , serializer . clone ( ) , this ) ; LOGGER . debug ( STRING , segment ) ; return segment ; }
private void grestore ( ) { int count = mGStateStack . size ( ) ; mGStateStack . remove ( count - _NUM ) ; mPSStream . println ( GRESTORE_STR ) ; }
private void grestore ( ) { int count = mGStateStack . size ( ) ; mGStateStack . remove ( count - _NUM ) ; mPSStream . println ( GRESTORE_STR ) ; }
public void handleCacheRemoval ( Cache cache ) throws ManagementException { if ( ! isServiceInitialised ( STRING ) ) { return ; } this . serviceInitialised = _BOOL ; try { cleanUpMonitors ( ) ; cleanBridgeResources ( ) ; } catch ( Exception e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( e . getMessage ( ) , e ) ; } } try { service . close ( ) ; } catch ( Exception e ) { logger . warn ( e . getMessage ( ) , e ) ; } finally { this . cacheImpl = null ; this . service = null ; this . memberMBeanBridge = null ; this . memberBean = null ; this . memberLevelNotifEmitter = null ; } }
public void handleCacheRemoval ( Cache cache ) throws ManagementException { if ( ! isServiceInitialised ( STRING ) ) { return ; } this . serviceInitialised = _BOOL ; try { cleanUpMonitors ( ) ; cleanBridgeResources ( ) ; } catch ( Exception e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( e . getMessage ( ) , e ) ; } } try { service . close ( ) ; } catch ( Exception e ) { logger . warn ( e . getMessage ( ) , e ) ; } finally { this . cacheImpl = null ; this . service = null ; this . memberMBeanBridge = null ; this . memberBean = null ; this . memberLevelNotifEmitter = null ; } }
static void sendRawLine ( PircBot bot , BufferedWriter bwriter , String line ) { if ( line . length ( ) > bot . getMaxLineLength ( ) - _NUM ) { line = line . substring ( _NUM , bot . getMaxLineLength ( ) - _NUM ) ; } synchronized ( bwriter ) { try { bwriter . write ( line + STRING ) ; bwriter . flush ( ) ; } catch ( Exception e ) { } } }
public synchronized void addPropertyChangeListener ( PropertyChangeListener listener ) { if ( listenerList == null ) { listenerList = new Vector < PropertyChangeListener > ( ) ; } listenerList . add ( listener ) ; }
public synchronized void addPropertyChangeListener ( PropertyChangeListener listener ) { if ( listenerList == null ) { listenerList = new Vector < PropertyChangeListener > ( ) ; } listenerList . add ( listener ) ; }
public synchronized void addPropertyChangeListener ( PropertyChangeListener listener ) { if ( listenerList == null ) { listenerList = new Vector < PropertyChangeListener > ( ) ; } listenerList . add ( listener ) ; }
public int readInt ( ) throws IOException { int v = dataInput . readInt ( ) ; offset += _NUM ; available -= _NUM ; return v ; }
public boolean isLoaded ( String name ) { PluginHolder < T > result = registry . get ( name ) ; if ( result == null ) return _BOOL ; return result . isLoaded ( ) ; }
protected Varargs execute ( String command ) { return varargsOf ( NIL , valueOf ( STRING ) , ONE ) ; }
public ScriptExecutorTaskStatus call ( ) throws Exception { ScriptMethodRequest request ; while ( ( request = requests . poll ( ) ) != null ) { ScriptMethodResponse response = null ; try { String method = request . getMethod ( ) ; Object argument = request . getArgument ( ) ; Object value = executor . execute ( method , argument ) ; response = new ScriptMethodResponse ( request , value , null , _BOOL ) ; } catch ( Throwable t ) { response = new ScriptMethodResponse ( request , null , t , _BOOL ) ; String msg = formatErrorMessage ( request ) ; logger . error ( msg , response . getThrowable ( ) ) ; ScriptExecutorTaskStatus status = new ScriptExecutorTaskStatus ( count . get ( ) , _BOOL , response ) ; return status ; } finally { responses . add ( response ) ; } count . incrementAndGet ( ) ; } return new ScriptExecutorTaskStatus ( count . get ( ) , _BOOL , null ) ; }
public TableBuilder addColumn ( ColumnBuilder column ) { if ( _escapeIdentifiers ) { column . escapeName ( ) ; } _columns . add ( column ) ; return this ; }
protected void clearCache ( ) { if ( _cache != null ) { _cache . clear ( ) ; _cache = null ; } }
private void validateUserNamespaceAuthorizationCreateRequest ( UserNamespaceAuthorizationCreateRequest request ) { Assert . notNull ( request , STRING ) ; validateUserNamespaceAuthorizationKey ( request . getUserNamespaceAuthorizationKey ( ) ) ; validateNamespacePermissions ( request . getNamespacePermissions ( ) ) ; }
private void validateUserNamespaceAuthorizationCreateRequest ( UserNamespaceAuthorizationCreateRequest request ) { Assert . notNull ( request , STRING ) ; validateUserNamespaceAuthorizationKey ( request . getUserNamespaceAuthorizationKey ( ) ) ; validateNamespacePermissions ( request . getNamespacePermissions ( ) ) ; }
public synchronized void connected ( BluetoothSocket socket , BluetoothDevice device , final String socketType ) { log . debug ( STRING + socketType ) ; if ( mBtConnectThread != null ) { mBtConnectThread . cancel ( ) ; mBtConnectThread = null ; } if ( mBtWorkerThread != null ) { mBtWorkerThread . cancel ( ) ; mBtWorkerThread = null ; } connectionEstablished ( device . getName ( ) ) ; mBtWorkerThread = new BtWorkerThread ( socket , socketType ) ; mBtWorkerThread . start ( ) ; }
public synchronized void connected ( BluetoothSocket socket , BluetoothDevice device , final String socketType ) { log . debug ( STRING + socketType ) ; if ( mBtConnectThread != null ) { mBtConnectThread . cancel ( ) ; mBtConnectThread = null ; } if ( mBtWorkerThread != null ) { mBtWorkerThread . cancel ( ) ; mBtWorkerThread = null ; } connectionEstablished ( device . getName ( ) ) ; mBtWorkerThread = new BtWorkerThread ( socket , socketType ) ; mBtWorkerThread . start ( ) ; }
private void describeDanger ( int dangerLevel ) { glassPane . setToolTipText ( dangerLevelStrings [ dangerLevel ] ) ; }
private void describeDanger ( int dangerLevel ) { glassPane . setToolTipText ( dangerLevelStrings [ dangerLevel ] ) ; }
private void describeDanger ( int dangerLevel ) { glassPane . setToolTipText ( dangerLevelStrings [ dangerLevel ] ) ; }
static public void assertTopAligned ( View first , View second , int margin ) { int [ ] xy = new int [ _NUM ] ; first . getLocationOnScreen ( xy ) ; int firstTop = xy [ _NUM ] ; second . getLocationOnScreen ( xy ) ; int secondTop = xy [ _NUM ] ; assertEquals ( STRING , Math . abs ( firstTop - secondTop ) , margin ) ; }
public static void viewMmsMessageAttachment ( Activity activity , Uri msgUri , SlideshowModel slideshow , AsyncDialog asyncDialog ) { viewMmsMessageAttachment ( activity , msgUri , slideshow , _NUM , asyncDialog ) ; }
public static void viewMmsMessageAttachment ( Activity activity , Uri msgUri , SlideshowModel slideshow , AsyncDialog asyncDialog ) { viewMmsMessageAttachment ( activity , msgUri , slideshow , _NUM , asyncDialog ) ; }
public static void viewMmsMessageAttachment ( Activity activity , Uri msgUri , SlideshowModel slideshow , AsyncDialog asyncDialog ) { viewMmsMessageAttachment ( activity , msgUri , slideshow , _NUM , asyncDialog ) ; }
public static void viewMmsMessageAttachment ( Activity activity , Uri msgUri , SlideshowModel slideshow , AsyncDialog asyncDialog ) { viewMmsMessageAttachment ( activity , msgUri , slideshow , _NUM , asyncDialog ) ; }
public static void viewMmsMessageAttachment ( Activity activity , Uri msgUri , SlideshowModel slideshow , AsyncDialog asyncDialog ) { viewMmsMessageAttachment ( activity , msgUri , slideshow , _NUM , asyncDialog ) ; }
public static void viewMmsMessageAttachment ( Activity activity , Uri msgUri , SlideshowModel slideshow , AsyncDialog asyncDialog ) { viewMmsMessageAttachment ( activity , msgUri , slideshow , _NUM , asyncDialog ) ; }
public static void viewMmsMessageAttachment ( Activity activity , Uri msgUri , SlideshowModel slideshow , AsyncDialog asyncDialog ) { viewMmsMessageAttachment ( activity , msgUri , slideshow , _NUM , asyncDialog ) ; }
public static void viewMmsMessageAttachment ( Activity activity , Uri msgUri , SlideshowModel slideshow , AsyncDialog asyncDialog ) { viewMmsMessageAttachment ( activity , msgUri , slideshow , _NUM , asyncDialog ) ; }
public static void viewMmsMessageAttachment ( Activity activity , Uri msgUri , SlideshowModel slideshow , AsyncDialog asyncDialog ) { viewMmsMessageAttachment ( activity , msgUri , slideshow , _NUM , asyncDialog ) ; }
public static void viewMmsMessageAttachment ( Activity activity , Uri msgUri , SlideshowModel slideshow , AsyncDialog asyncDialog ) { viewMmsMessageAttachment ( activity , msgUri , slideshow , _NUM , asyncDialog ) ; }
private Collection < Var > migrateColumns ( SQLTable currentTable ) { List < Var > vars = new ArrayList < > ( ) ; String tableType = currentTable . getEntityType ( ) ; Map < String , ResourceType . DataType > columns = currentTable . getColumns ( ) ; Map < String , String > foreignColumns = currentTable . getForeignKeyColumns ( ) ; for ( String column : columns . keySet ( ) ) { ResourceType . DataType columnType = columns . get ( column ) ; if ( foreignColumns . containsKey ( column ) ) { vars . addAll ( migrateAsRelation ( tableType , column , foreignColumns . get ( column ) ) ) ; } else { vars . addAll ( migrateAsResource ( tableType , columnType , column ) ) ; } } return vars ; }
public static void addMinutesToList ( Context context , ArrayList < Integer > values , ArrayList < String > labels , int minutes ) { int index = values . indexOf ( minutes ) ; if ( index != - _NUM ) { return ; } String label = constructReminderLabel ( context , minutes , _BOOL ) ; int len = values . size ( ) ; for ( int i = _NUM ; i < len ; i ++ ) { if ( minutes < values . get ( i ) ) { values . add ( i , minutes ) ; labels . add ( i , label ) ; return ; } } values . add ( minutes ) ; labels . add ( len , label ) ; }
public static void addMinutesToList ( Context context , ArrayList < Integer > values , ArrayList < String > labels , int minutes ) { int index = values . indexOf ( minutes ) ; if ( index != - _NUM ) { return ; } String label = constructReminderLabel ( context , minutes , _BOOL ) ; int len = values . size ( ) ; for ( int i = _NUM ; i < len ; i ++ ) { if ( minutes < values . get ( i ) ) { values . add ( i , minutes ) ; labels . add ( i , label ) ; return ; } } values . add ( minutes ) ; labels . add ( len , label ) ; }
private void readFromProperties ( final Properties props , final boolean defaultMinimized , final int defaultX , final int defaultY , final boolean defaultVisible ) { minimized = Boolean . parseBoolean ( props . getProperty ( STRING + name + STRING , Boolean . toString ( defaultMinimized ) ) ) ; visible = Boolean . parseBoolean ( props . getProperty ( STRING + name + STRING , Boolean . toString ( defaultVisible ) ) ) ; x = Integer . parseInt ( props . getProperty ( STRING + name + STRING , Integer . toString ( defaultX ) ) ) ; y = Integer . parseInt ( props . getProperty ( STRING + name + STRING , Integer . toString ( defaultY ) ) ) ; }
public ClassLocation createClass ( ) { ClassLocation cl = new ClassLocation ( ) ; classLocations . add ( cl ) ; return cl ; }
public final void writeDouble ( double val ) throws IOException { writeLong ( Double . doubleToLongBits ( val ) ) ; }
synchronized void updateAuthConfigGlobals ( ServiceSchemaManager scm ) throws SMSException { ServiceSchema schema = scm . getOrganizationSchema ( ) ; schema = schema . getSubSchema ( STRING ) ; schema = schema . getSubSchema ( STRING ) ; Map attrs = schema . getAttributeDefaults ( ) ; if ( attrs != null ) { defaultServiceSuccessURLSet = ( Set ) attrs . get ( ISAuthConstants . LOGIN_SUCCESS_URL ) ; defaultServiceFailureURLSet = ( Set ) attrs . get ( ISAuthConstants . LOGIN_FAILURE_URL ) ; } if ( debug . messageEnabled ( ) ) { debug . message ( STRING + defaultServiceSuccessURLSet ) ; debug . message ( STRING + defaultServiceFailureURLSet ) ; } }
public Integer read ( String value ) { return Integer . valueOf ( value ) ; }
public Integer read ( String value ) { return Integer . valueOf ( value ) ; }
public Integer read ( String value ) { return Integer . valueOf ( value ) ; }
@ KnownFailure ( STRING ) public void testUpdate6 ( ) throws SQLException { DatabaseCreator . fillFKCascadeTable ( conn ) ; try { statement . executeUpdate ( STRING + DatabaseCreator . FKCASCADE_TABLE + STRING ) ; fail ( STRING ) ; } catch ( SQLException ex ) { } }
@ KnownFailure ( STRING ) public void testUpdate6 ( ) throws SQLException { DatabaseCreator . fillFKCascadeTable ( conn ) ; try { statement . executeUpdate ( STRING + DatabaseCreator . FKCASCADE_TABLE + STRING ) ; fail ( STRING ) ; } catch ( SQLException ex ) { } }
public synchronized void trimToSize ( ) { if ( elementData . length != elementCount ) { grow ( elementCount ) ; } }
public synchronized void trimToSize ( ) { if ( elementData . length != elementCount ) { grow ( elementCount ) ; } }
public void registerOnSharedPreferenceChangeListener ( OnSharedPreferenceChangeListener listener ) { if ( listener != null ) { registerListener ( listener ) ; } }
protected abstract M newMapInstance ( ) ;
public void clearDirectory ( File directory ) { if ( directory . exists ( ) ) { for ( File file : directory . listFiles ( ) ) { file . delete ( ) ; } } }
public void clearDirectory ( File directory ) { if ( directory . exists ( ) ) { for ( File file : directory . listFiles ( ) ) { file . delete ( ) ; } } }
public void remove ( int amount ) { int size = stack . size ( ) ; for ( int i = size - _NUM ; i > size - _NUM - amount ; i -- ) { popWithMessage ( i ) ; } }
public void remove ( int amount ) { int size = stack . size ( ) ; for ( int i = size - _NUM ; i > size - _NUM - amount ; i -- ) { popWithMessage ( i ) ; } }
public void remove ( int amount ) { int size = stack . size ( ) ; for ( int i = size - _NUM ; i > size - _NUM - amount ; i -- ) { popWithMessage ( i ) ; } }
public void compactify ( ) { m_Instances . trimToSize ( ) ; }
public void compactify ( ) { m_Instances . trimToSize ( ) ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; String childValue ; int childLength ; doc = ( Document ) load ( STRING , _BOOL ) ; elementList = doc . getElementsByTagName ( STRING ) ; nameNode = elementList . item ( _NUM ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; child . appendData ( STRING ) ; childValue = child . getData ( ) ; childLength = childValue . length ( ) ; assertEquals ( STRING , _NUM , childLength ) ; }
public void addOptionToSelect ( String option ) { if ( optionsToSelect == null ) { optionsToSelect = new LinkedList < > ( ) ; } optionsToSelect . add ( option ) ; }
public static PublicKey readX509PublicKey ( byte [ ] encoded ) throws Exception { X509EncodedKeySpec x509EncodedPublicKey = new X509EncodedKeySpec ( encoded ) ; return KEY_FACTORY . generatePublic ( x509EncodedPublicKey ) ; }
protected boolean isCompletelySuppressed ( NodeSpec nodeSpec ) { if ( nodeSpec . getSuppression ( ) == null ) { return _BOOL ; } switch ( nodeSpec . getSuppression ( ) ) { case ENTITY_CONFIGURATION : return _BOOL ; case GENERATED_CODE : return _BOOL ; case GENERATED_CODE_SETTER : return _BOOL ; default : throw new IllegalStateException ( STRING + nodeSpec . getSuppression ( ) ) ; } }
private boolean allowUploadCrashDump ( ) { if ( isCellularExperimentEnabled ( ) ) return isUsageAndCrashReportingEnabled ( ) ; if ( isMobileNetworkCapable ( ) ) { String option = mSharedPreferences . getString ( PREF_CRASH_DUMP_UPLOAD , mCrashDumpNeverUpload ) ; return option . equals ( mCrashDumpAlwaysUpload ) || ( option . equals ( mCrashDumpWifiOnlyUpload ) && isWiFiOrEthernetNetwork ( ) ) ; } return mSharedPreferences . getBoolean ( PREF_CRASH_DUMP_UPLOAD_NO_CELLULAR , _BOOL ) ; }
private boolean allowUploadCrashDump ( ) { if ( isCellularExperimentEnabled ( ) ) return isUsageAndCrashReportingEnabled ( ) ; if ( isMobileNetworkCapable ( ) ) { String option = mSharedPreferences . getString ( PREF_CRASH_DUMP_UPLOAD , mCrashDumpNeverUpload ) ; return option . equals ( mCrashDumpAlwaysUpload ) || ( option . equals ( mCrashDumpWifiOnlyUpload ) && isWiFiOrEthernetNetwork ( ) ) ; } return mSharedPreferences . getBoolean ( PREF_CRASH_DUMP_UPLOAD_NO_CELLULAR , _BOOL ) ; }
@ Override protected String translate ( final String name ) { return STRING + name + STRING ; }
@ Override protected String translate ( final String name ) { return STRING + name + STRING ; }
public void init ( CipherParameters param ) { if ( param instanceof ParametersWithRandom ) { ParametersWithRandom rParam = ( ParametersWithRandom ) param ; key = ( RSAKeyParameters ) rParam . getParameters ( ) ; random = rParam . getRandom ( ) ; } else { key = ( RSAKeyParameters ) param ; random = new SecureRandom ( ) ; } if ( key instanceof RSAPrivateCrtKeyParameters ) { throw new IllegalArgumentException ( STRING ) ; } }
public boolean expired ( long expire ) { long mod = time . getTime ( ) ; long now = System . currentTimeMillis ( ) ; long diff = now - mod ; if ( diff > expire && getSource ( ) != NETWORK ) { return _BOOL ; } return _BOOL ; }
@ SuppressWarnings ( STRING ) private static int find ( Object [ ] arr , java . lang . Comparable val , int bnd , int l , int r ) { if ( NumberComparator . isNumber ( val ) ) { return find ( arr , val , bnd , l , r , NumberComparator . createComparator ( val . getClass ( ) ) ) ; } int m = l ; int d = _NUM ; while ( m <= r ) { if ( val . compareTo ( arr [ m ] ) > bnd ) { l = m + _NUM ; } else { r = m - _NUM ; break ; } m += d ; d <<= _NUM ; } while ( l <= r ) { m = ( l + r ) > > > _NUM ; if ( val . compareTo ( arr [ m ] ) > bnd ) { l = m + _NUM ; } else { r = m - _NUM ; } } return l - _NUM ; }
@ SuppressWarnings ( STRING ) private static int find ( Object [ ] arr , java . lang . Comparable val , int bnd , int l , int r ) { if ( NumberComparator . isNumber ( val ) ) { return find ( arr , val , bnd , l , r , NumberComparator . createComparator ( val . getClass ( ) ) ) ; } int m = l ; int d = _NUM ; while ( m <= r ) { if ( val . compareTo ( arr [ m ] ) > bnd ) { l = m + _NUM ; } else { r = m - _NUM ; break ; } m += d ; d <<= _NUM ; } while ( l <= r ) { m = ( l + r ) > > > _NUM ; if ( val . compareTo ( arr [ m ] ) > bnd ) { l = m + _NUM ; } else { r = m - _NUM ; } } return l - _NUM ; }
public void evaluate ( final MultivariateFunction evaluationFunction , final Comparator < PointValuePair > comparator ) { for ( int i = _NUM ; i < simplex . length ; i ++ ) { final PointValuePair vertex = simplex [ i ] ; final double [ ] point = vertex . getPointRef ( ) ; if ( Double . isNaN ( vertex . getValue ( ) ) ) { simplex [ i ] = new PointValuePair ( point , evaluationFunction . value ( point ) , _BOOL ) ; } } Arrays . sort ( simplex , comparator ) ; }
public CommandIterator ( final List commands , final Command command , final boolean forward ) { if ( commands == null || command == null ) throw new IllegalArgumentException ( ) ; fIterator = forward ? commands . iterator ( ) : new ReverseListIterator ( commands . listIterator ( commands . size ( ) ) ) ; fCommand = command ; fForward = forward ; }
public Transaction seen ( Transaction tx , PeerAddress byPeer ) { lock . lock ( ) ; try { final Transaction interned = intern ( tx ) ; markBroadcast ( byPeer , interned ) ; return interned ; } finally { lock . unlock ( ) ; } }
public Transaction seen ( Transaction tx , PeerAddress byPeer ) { lock . lock ( ) ; try { final Transaction interned = intern ( tx ) ; markBroadcast ( byPeer , interned ) ; return interned ; } finally { lock . unlock ( ) ; } }
public Transaction seen ( Transaction tx , PeerAddress byPeer ) { lock . lock ( ) ; try { final Transaction interned = intern ( tx ) ; markBroadcast ( byPeer , interned ) ; return interned ; } finally { lock . unlock ( ) ; } }
public Transaction seen ( Transaction tx , PeerAddress byPeer ) { lock . lock ( ) ; try { final Transaction interned = intern ( tx ) ; markBroadcast ( byPeer , interned ) ; return interned ; } finally { lock . unlock ( ) ; } }
public Transaction seen ( Transaction tx , PeerAddress byPeer ) { lock . lock ( ) ; try { final Transaction interned = intern ( tx ) ; markBroadcast ( byPeer , interned ) ; return interned ; } finally { lock . unlock ( ) ; } }
@ SuppressWarnings ( STRING ) public JdbcData ( Connection connection , String table , boolean buffered ) { this . connection = connection ; this . table = table ; setBuffered ( buffered ) ; try { setColumnTypes ( getJdbcColumnTypes ( ) ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
@ SuppressWarnings ( STRING ) public JdbcData ( Connection connection , String table , boolean buffered ) { this . connection = connection ; this . table = table ; setBuffered ( buffered ) ; try { setColumnTypes ( getJdbcColumnTypes ( ) ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
@ SuppressWarnings ( STRING ) public JdbcData ( Connection connection , String table , boolean buffered ) { this . connection = connection ; this . table = table ; setBuffered ( buffered ) ; try { setColumnTypes ( getJdbcColumnTypes ( ) ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
protected Stack < Throwable > unfoldExceptions ( Throwable exception ) { Stack < Throwable > throwables = new Stack < > ( ) ; Throwable current = exception ; while ( current != null ) { throwables . push ( current ) ; current = current . getCause ( ) ; } return throwables ; }
@ Override public final void writeLong ( long v ) throws IOException { work [ _NUM ] = ( byte ) v ; work [ _NUM ] = ( byte ) ( v > > _NUM ) ; work [ _NUM ] = ( byte ) ( v > > _NUM ) ; work [ _NUM ] = ( byte ) ( v > > _NUM ) ; work [ _NUM ] = ( byte ) ( v > > _NUM ) ; work [ _NUM ] = ( byte ) ( v > > _NUM ) ; work [ _NUM ] = ( byte ) ( v > > _NUM ) ; work [ _NUM ] = ( byte ) ( v > > _NUM ) ; dis . write ( work , _NUM , _NUM ) ; }
public static void writeTokenFile ( File tokenFile , String value ) throws IOException { writeToken ( tokenFile . getParentFile ( ) , tokenFile . getName ( ) , value ) ; }
public static void writeTokenFile ( File tokenFile , String value ) throws IOException { writeToken ( tokenFile . getParentFile ( ) , tokenFile . getName ( ) , value ) ; }
public static void writeTokenFile ( File tokenFile , String value ) throws IOException { writeToken ( tokenFile . getParentFile ( ) , tokenFile . getName ( ) , value ) ; }
public LexerNode createLexerNode ( ) { return new LexerNode ( _BOOL ) ; }
protected void addFontToPlatformFontPath ( String platformFontName ) { }
protected void addFontToPlatformFontPath ( String platformFontName ) { }
protected void addFontToPlatformFontPath ( String platformFontName ) { }
protected void addFontToPlatformFontPath ( String platformFontName ) { }
public void failoverCopyTest ( RPCopyRequestParams copyToFailoverTo ) throws RecoverPointException { String bookmarkName = copyToFailoverTo . getBookmarkName ( ) ; Date apitTime = copyToFailoverTo . getApitTime ( ) ; if ( bookmarkName != null ) { logger . info ( STRING + bookmarkName ) ; } else if ( apitTime != null ) { logger . info ( STRING + apitTime . toString ( ) ) ; } else { logger . info ( STRING ) ; } RecoverPointImageManagementUtils imageManager = new RecoverPointImageManagementUtils ( ) ; imageManager . enableCopyImage ( functionalAPI , copyToFailoverTo , _BOOL ) ; RecoverPointVolumeProtectionInfo failoverCopyInfo = copyToFailoverTo . getCopyVolumeInfo ( ) ; pauseTransfer ( failoverCopyInfo ) ; }
public void testCreateConsumer ( ) throws Exception { Message msg = super . createMessage ( ) ; producer . send ( msg ) ; synchronized ( lock ) { while ( testConsumer == null ) { lock . wait ( _NUM ) ; } } assertTrue ( testConsumer != null ) ; }
private Listing makeListing ( int number ) { int mod = number % _NUM ; int resource ; if ( mod == _NUM ) { resource = R . drawable . house1 ; } else if ( mod == _NUM ) { resource = R . drawable . house2 ; } else { resource = R . drawable . house3 ; } return new Listing ( String . format ( STRING , number ) , STRING , STRING , STRING , resource ) ; }
private void updateFont ( ) { String fontName = fontList . getValue ( ) ; Integer fontSize = FALLBACK_FONT_SIZE ; try { fontSize = Integer . parseInt ( fontSizeList . getValue ( ) ) ; } catch ( NumberFormatException ex ) { } font = new Font ( fontName , Font . PLAIN , fontSize ) ; preview . setFont ( font ) ; }
public void write ( String str ) throws IOException { write ( str , _NUM , str . length ( ) ) ; }
public void write ( String str ) throws IOException { write ( str , _NUM , str . length ( ) ) ; }
protected T prepareErrorFragment ( ThrowableFailureEvent event , boolean finishAfterDialog , Bundle argumentsForErrorDialog ) { if ( event . isSuppressErrorUi ( ) ) { return null ; } Bundle bundle ; if ( argumentsForErrorDialog != null ) { bundle = ( Bundle ) argumentsForErrorDialog . clone ( ) ; } else { bundle = new Bundle ( ) ; } if ( ! bundle . containsKey ( ErrorDialogManager . KEY_TITLE ) ) { String title = getTitleFor ( event , bundle ) ; bundle . putString ( ErrorDialogManager . KEY_TITLE , title ) ; } if ( ! bundle . containsKey ( ErrorDialogManager . KEY_MESSAGE ) ) { String message = getMessageFor ( event , bundle ) ; bundle . putString ( ErrorDialogManager . KEY_MESSAGE , message ) ; } if ( ! bundle . containsKey ( ErrorDialogManager . KEY_FINISH_AFTER_DIALOG ) ) { bundle . putBoolean ( ErrorDialogManager . KEY_FINISH_AFTER_DIALOG , finishAfterDialog ) ; } if ( ! bundle . containsKey ( ErrorDialogManager . KEY_EVENT_TYPE_ON_CLOSE ) && config . defaultEventTypeOnDialogClosed != null ) { bundle . putSerializable ( ErrorDialogManager . KEY_EVENT_TYPE_ON_CLOSE , config . defaultEventTypeOnDialogClosed ) ; } if ( ! bundle . containsKey ( ErrorDialogManager . KEY_ICON_ID ) && config . defaultDialogIconId != _NUM ) { bundle . putInt ( ErrorDialogManager . KEY_ICON_ID , config . defaultDialogIconId ) ; } return createErrorFragment ( event , bundle ) ; }
protected T prepareErrorFragment ( ThrowableFailureEvent event , boolean finishAfterDialog , Bundle argumentsForErrorDialog ) { if ( event . isSuppressErrorUi ( ) ) { return null ; } Bundle bundle ; if ( argumentsForErrorDialog != null ) { bundle = ( Bundle ) argumentsForErrorDialog . clone ( ) ; } else { bundle = new Bundle ( ) ; } if ( ! bundle . containsKey ( ErrorDialogManager . KEY_TITLE ) ) { String title = getTitleFor ( event , bundle ) ; bundle . putString ( ErrorDialogManager . KEY_TITLE , title ) ; } if ( ! bundle . containsKey ( ErrorDialogManager . KEY_MESSAGE ) ) { String message = getMessageFor ( event , bundle ) ; bundle . putString ( ErrorDialogManager . KEY_MESSAGE , message ) ; } if ( ! bundle . containsKey ( ErrorDialogManager . KEY_FINISH_AFTER_DIALOG ) ) { bundle . putBoolean ( ErrorDialogManager . KEY_FINISH_AFTER_DIALOG , finishAfterDialog ) ; } if ( ! bundle . containsKey ( ErrorDialogManager . KEY_EVENT_TYPE_ON_CLOSE ) && config . defaultEventTypeOnDialogClosed != null ) { bundle . putSerializable ( ErrorDialogManager . KEY_EVENT_TYPE_ON_CLOSE , config . defaultEventTypeOnDialogClosed ) ; } if ( ! bundle . containsKey ( ErrorDialogManager . KEY_ICON_ID ) && config . defaultDialogIconId != _NUM ) { bundle . putInt ( ErrorDialogManager . KEY_ICON_ID , config . defaultDialogIconId ) ; } return createErrorFragment ( event , bundle ) ; }
public void addExtensionFilter ( String extension ) { if ( ext == null ) { ext = new Vector ( ) ; } ext . addElement ( extension ) ; }
public String decrypt ( String value ) { if ( value == null || value . length ( ) == _NUM ) return value ; boolean isEncrypted = value . startsWith ( ENCRYPTEDVALUE_START ) && value . endsWith ( ENCRYPTEDVALUE_END ) ; if ( isEncrypted ) value = value . substring ( ENCRYPTEDVALUE_START . length ( ) , value . length ( ) - ENCRYPTEDVALUE_END . length ( ) ) ; byte [ ] data = convertHexString ( value ) ; if ( data == null ) { if ( isEncrypted ) { log . info ( STRING ) ; return null ; } return value ; } if ( m_cipher == null ) initCipher ( ) ; if ( m_cipher != null && value != null && value . length ( ) > _NUM ) { try { AlgorithmParameters ap = m_cipher . getParameters ( ) ; m_cipher . init ( Cipher . DECRYPT_MODE , m_key , ap ) ; byte [ ] out = m_cipher . doFinal ( data ) ; String retValue = new String ( out , STRING ) ; return retValue ; } catch ( Exception ex ) { log . info ( STRING + ex . toString ( ) ) ; } } return null ; }
public void guard ( final Guard r ) throws InterruptedException { incThread ( ) ; try { r . run ( ) ; } catch ( InterruptedException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } finally { decThread ( ) ; } }
public void guard ( final Guard r ) throws InterruptedException { incThread ( ) ; try { r . run ( ) ; } catch ( InterruptedException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } finally { decThread ( ) ; } }
public void guard ( final Guard r ) throws InterruptedException { incThread ( ) ; try { r . run ( ) ; } catch ( InterruptedException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } finally { decThread ( ) ; } }
public ShortBandedRaster ( SampleModel sampleModel , Point origin ) { this ( sampleModel , sampleModel . createDataBuffer ( ) , new Rectangle ( origin . x , origin . y , sampleModel . getWidth ( ) , sampleModel . getHeight ( ) ) , origin , null ) ; }
public ShortBandedRaster ( SampleModel sampleModel , Point origin ) { this ( sampleModel , sampleModel . createDataBuffer ( ) , new Rectangle ( origin . x , origin . y , sampleModel . getWidth ( ) , sampleModel . getHeight ( ) ) , origin , null ) ; }
private void initClientToken ( ) { clientToken = kerberosTicketService . getClientToken ( ) ; }
final void tryTerminate2 ( ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = runStateOf ( c ) ; if ( rs < SHUTDOWN || rs == TERMINATED || ( rs == SHUTDOWN && ! workQueue . isEmpty ( ) ) ) return ; if ( workerCountOf ( c ) != _NUM ) { interruptIdleWorkers ( ONLY_ONE ) ; return ; } if ( ctl . compareAndSet ( c , ctlOf ( TERMINATED , _NUM ) ) ) { mainLock . lock ( ) ; try { termination . signalAll ( ) ; } finally { mainLock . unlock ( ) ; } terminated ( ) ; return ; } } }
final void tryTerminate2 ( ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = runStateOf ( c ) ; if ( rs < SHUTDOWN || rs == TERMINATED || ( rs == SHUTDOWN && ! workQueue . isEmpty ( ) ) ) return ; if ( workerCountOf ( c ) != _NUM ) { interruptIdleWorkers ( ONLY_ONE ) ; return ; } if ( ctl . compareAndSet ( c , ctlOf ( TERMINATED , _NUM ) ) ) { mainLock . lock ( ) ; try { termination . signalAll ( ) ; } finally { mainLock . unlock ( ) ; } terminated ( ) ; return ; } } }
final void tryTerminate2 ( ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = runStateOf ( c ) ; if ( rs < SHUTDOWN || rs == TERMINATED || ( rs == SHUTDOWN && ! workQueue . isEmpty ( ) ) ) return ; if ( workerCountOf ( c ) != _NUM ) { interruptIdleWorkers ( ONLY_ONE ) ; return ; } if ( ctl . compareAndSet ( c , ctlOf ( TERMINATED , _NUM ) ) ) { mainLock . lock ( ) ; try { termination . signalAll ( ) ; } finally { mainLock . unlock ( ) ; } terminated ( ) ; return ; } } }
final void tryTerminate2 ( ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = runStateOf ( c ) ; if ( rs < SHUTDOWN || rs == TERMINATED || ( rs == SHUTDOWN && ! workQueue . isEmpty ( ) ) ) return ; if ( workerCountOf ( c ) != _NUM ) { interruptIdleWorkers ( ONLY_ONE ) ; return ; } if ( ctl . compareAndSet ( c , ctlOf ( TERMINATED , _NUM ) ) ) { mainLock . lock ( ) ; try { termination . signalAll ( ) ; } finally { mainLock . unlock ( ) ; } terminated ( ) ; return ; } } }
final void tryTerminate2 ( ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = runStateOf ( c ) ; if ( rs < SHUTDOWN || rs == TERMINATED || ( rs == SHUTDOWN && ! workQueue . isEmpty ( ) ) ) return ; if ( workerCountOf ( c ) != _NUM ) { interruptIdleWorkers ( ONLY_ONE ) ; return ; } if ( ctl . compareAndSet ( c , ctlOf ( TERMINATED , _NUM ) ) ) { mainLock . lock ( ) ; try { termination . signalAll ( ) ; } finally { mainLock . unlock ( ) ; } terminated ( ) ; return ; } } }
final void tryTerminate2 ( ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = runStateOf ( c ) ; if ( rs < SHUTDOWN || rs == TERMINATED || ( rs == SHUTDOWN && ! workQueue . isEmpty ( ) ) ) return ; if ( workerCountOf ( c ) != _NUM ) { interruptIdleWorkers ( ONLY_ONE ) ; return ; } if ( ctl . compareAndSet ( c , ctlOf ( TERMINATED , _NUM ) ) ) { mainLock . lock ( ) ; try { termination . signalAll ( ) ; } finally { mainLock . unlock ( ) ; } terminated ( ) ; return ; } } }
final void tryTerminate2 ( ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = runStateOf ( c ) ; if ( rs < SHUTDOWN || rs == TERMINATED || ( rs == SHUTDOWN && ! workQueue . isEmpty ( ) ) ) return ; if ( workerCountOf ( c ) != _NUM ) { interruptIdleWorkers ( ONLY_ONE ) ; return ; } if ( ctl . compareAndSet ( c , ctlOf ( TERMINATED , _NUM ) ) ) { mainLock . lock ( ) ; try { termination . signalAll ( ) ; } finally { mainLock . unlock ( ) ; } terminated ( ) ; return ; } } }
public VirtualStackSlot makeLockSlot ( int lockDepth ) { if ( locks == EMPTY ) { locks = new AllocatableValue [ lockDepth + _NUM ] ; } else if ( locks . length < lockDepth + _NUM ) { locks = Arrays . copyOf ( locks , lockDepth + _NUM ) ; } if ( locks [ lockDepth ] == null ) { locks [ lockDepth ] = frameMapBuilder . allocateSpillSlot ( slotKind ) ; } return ( VirtualStackSlot ) locks [ lockDepth ] ; }
public VirtualStackSlot makeLockSlot ( int lockDepth ) { if ( locks == EMPTY ) { locks = new AllocatableValue [ lockDepth + _NUM ] ; } else if ( locks . length < lockDepth + _NUM ) { locks = Arrays . copyOf ( locks , lockDepth + _NUM ) ; } if ( locks [ lockDepth ] == null ) { locks [ lockDepth ] = frameMapBuilder . allocateSpillSlot ( slotKind ) ; } return ( VirtualStackSlot ) locks [ lockDepth ] ; }
protected void displayGetSummary ( final GetStatus status ) { if ( ! shouldDisplaySummary ( status ) ) { return ; } displayGetStatus ( status ) ; for ( final GetEvent e : getWarningList ) { displayGetEvent ( e , e . getTargetLocalItem ( ) ) ; } displayErrors ( ) ; }
protected String instanceToMatlab ( Instance inst ) { StringBuffer result ; int i ; result = new StringBuffer ( ) ; for ( i = _NUM ; i < inst . numAttributes ( ) ; i ++ ) { if ( i > _NUM ) { result . append ( ( m_UseTabs ? STRING : STRING ) ) ; } result . append ( m_Format . format ( inst . value ( i ) ) ) ; } return result . toString ( ) ; }
public static Collection < ContentStream > toContentStreams ( final String str , final String contentType ) { ArrayList < ContentStream > streams = new ArrayList < > ( ) ; ContentStreamBase stream = new ContentStreamBase . StringStream ( str ) ; if ( contentType != null ) stream . setContentType ( contentType ) ; streams . add ( stream ) ; return streams ; }
public static Collection < ContentStream > toContentStreams ( final String str , final String contentType ) { ArrayList < ContentStream > streams = new ArrayList < > ( ) ; ContentStreamBase stream = new ContentStreamBase . StringStream ( str ) ; if ( contentType != null ) stream . setContentType ( contentType ) ; streams . add ( stream ) ; return streams ; }
@ Parameterized . Parameters ( name = STRING ) public static Collection < PaymentChannelClient . VersionSelector > data ( ) { return Arrays . asList ( PaymentChannelClient . VersionSelector . VERSION_1 , PaymentChannelClient . VersionSelector . VERSION_2_ALLOW_1 , PaymentChannelClient . VersionSelector . VERSION_2 ) ; }
@ Parameterized . Parameters ( name = STRING ) public static Collection < PaymentChannelClient . VersionSelector > data ( ) { return Arrays . asList ( PaymentChannelClient . VersionSelector . VERSION_1 , PaymentChannelClient . VersionSelector . VERSION_2_ALLOW_1 , PaymentChannelClient . VersionSelector . VERSION_2 ) ; }
@ Parameterized . Parameters ( name = STRING ) public static Collection < PaymentChannelClient . VersionSelector > data ( ) { return Arrays . asList ( PaymentChannelClient . VersionSelector . VERSION_1 , PaymentChannelClient . VersionSelector . VERSION_2_ALLOW_1 , PaymentChannelClient . VersionSelector . VERSION_2 ) ; }
public JobDefinitionCreateRequest createJobDefinitionCreateRequest ( String namespaceCd , String jobName , String jobDescription , String activitiXml , List < Parameter > parameters ) { JobDefinitionCreateRequest request = new JobDefinitionCreateRequest ( ) ; request . setNamespace ( namespaceCd ) ; request . setJobName ( jobName ) ; request . setDescription ( jobDescription ) ; request . setActivitiJobXml ( activitiXml ) ; request . setParameters ( parameters ) ; return request ; }
private void sendUpdate ( JSONObject obj , boolean keepCallback ) { sendUpdate ( obj , keepCallback , PluginResult . Status . OK ) ; }
public void build ( String code , JSONObject data ) { try { result . put ( resources . getString ( R . string . intent_extra_status ) , resources . getString ( R . string . shared_pref_default_status ) ) ; result . put ( resources . getString ( R . string . intent_extra_code ) , code ) ; if ( data != null ) { result . put ( resources . getString ( R . string . intent_extra_data ) , data ) ; } operationListResult . put ( result ) ; } catch ( JSONException e ) { Log . e ( TAG , STRING + e . toString ( ) ) ; } }
public void add ( String dn , String attributes , String delimiter , String seperator ) throws NamingException , PageException { DirContext ctx = new InitialDirContext ( env ) ; ctx . createSubcontext ( dn , toAttributes ( attributes , delimiter , seperator ) ) ; ctx . close ( ) ; }
private static List < Agent > prepareContributorsFromEmlAgents ( List < Agent > contacts , List < Agent > metadataProviders , List < Agent > associatedParties ) { List < Agent > ls = Lists . newArrayList ( ) ; for ( Agent contact : contacts ) { contact . setRole ( CONTACT_ROLE ) ; } ls . addAll ( contacts ) ; for ( Agent metadataProvider : metadataProviders ) { metadataProvider . setRole ( METADATA_PROVIDER_ROLE ) ; } ls . addAll ( metadataProviders ) ; ls . addAll ( associatedParties ) ; return ls ; }
private static List < Agent > prepareContributorsFromEmlAgents ( List < Agent > contacts , List < Agent > metadataProviders , List < Agent > associatedParties ) { List < Agent > ls = Lists . newArrayList ( ) ; for ( Agent contact : contacts ) { contact . setRole ( CONTACT_ROLE ) ; } ls . addAll ( contacts ) ; for ( Agent metadataProvider : metadataProviders ) { metadataProvider . setRole ( METADATA_PROVIDER_ROLE ) ; } ls . addAll ( metadataProviders ) ; ls . addAll ( associatedParties ) ; return ls ; }
private static List < Agent > prepareContributorsFromEmlAgents ( List < Agent > contacts , List < Agent > metadataProviders , List < Agent > associatedParties ) { List < Agent > ls = Lists . newArrayList ( ) ; for ( Agent contact : contacts ) { contact . setRole ( CONTACT_ROLE ) ; } ls . addAll ( contacts ) ; for ( Agent metadataProvider : metadataProviders ) { metadataProvider . setRole ( METADATA_PROVIDER_ROLE ) ; } ls . addAll ( metadataProviders ) ; ls . addAll ( associatedParties ) ; return ls ; }
private static List < Agent > prepareContributorsFromEmlAgents ( List < Agent > contacts , List < Agent > metadataProviders , List < Agent > associatedParties ) { List < Agent > ls = Lists . newArrayList ( ) ; for ( Agent contact : contacts ) { contact . setRole ( CONTACT_ROLE ) ; } ls . addAll ( contacts ) ; for ( Agent metadataProvider : metadataProviders ) { metadataProvider . setRole ( METADATA_PROVIDER_ROLE ) ; } ls . addAll ( metadataProviders ) ; ls . addAll ( associatedParties ) ; return ls ; }
private static List < Agent > prepareContributorsFromEmlAgents ( List < Agent > contacts , List < Agent > metadataProviders , List < Agent > associatedParties ) { List < Agent > ls = Lists . newArrayList ( ) ; for ( Agent contact : contacts ) { contact . setRole ( CONTACT_ROLE ) ; } ls . addAll ( contacts ) ; for ( Agent metadataProvider : metadataProviders ) { metadataProvider . setRole ( METADATA_PROVIDER_ROLE ) ; } ls . addAll ( metadataProviders ) ; ls . addAll ( associatedParties ) ; return ls ; }
public static File absoluteFile ( File file ) { if ( file != null ) { try { file = file . getCanonicalFile ( ) ; } catch ( IOException e ) { file = file . getAbsoluteFile ( ) ; } } return file ; }
@ SuppressWarnings ( STRING ) public CompositeFileComparator ( Comparator < File > ... delegates ) { if ( delegates == null ) { this . delegates = ( Comparator < File > [ ] ) NO_COMPARATORS ; } else { this . delegates = ( Comparator < File > [ ] ) new Comparator < ? > [ delegates . length ] ; System . arraycopy ( delegates , _NUM , this . delegates , _NUM , delegates . length ) ; } }
private ValueGeometry ( byte [ ] bytes , Geometry geometry ) { this . bytes = bytes ; this . geometry = geometry ; this . hashCode = Arrays . hashCode ( bytes ) ; }
public void addLoadMore ( ) { if ( loadMoreItem != null || footerItem != null ) { return ; } loadMoreItem = new Object ( ) ; notifyDataSetChanged ( ) ; }
boolean shouldAnimateSearchProviderIcon ( SelectionType selectionType , boolean isShowing ) { if ( isShowing || ContextualSearchFieldTrial . areExtraSearchBarAnimationsDisabled ( ) ) { return _BOOL ; } if ( selectionType == SelectionType . TAP ) { long currentTimeMillis = System . currentTimeMillis ( ) ; long lastAnimatedTimeMillis = mPreferenceManager . getContextualSearchLastAnimationTime ( ) ; if ( Math . abs ( currentTimeMillis - lastAnimatedTimeMillis ) > ONE_DAY_IN_MILLIS ) { mPreferenceManager . setContextualSearchLastAnimationTime ( currentTimeMillis ) ; return _BOOL ; } else { return _BOOL ; } } else if ( selectionType == SelectionType . LONG_PRESS ) { return getPromoOpenCount ( ) == _NUM ; } return _BOOL ; }
boolean shouldAnimateSearchProviderIcon ( SelectionType selectionType , boolean isShowing ) { if ( isShowing || ContextualSearchFieldTrial . areExtraSearchBarAnimationsDisabled ( ) ) { return _BOOL ; } if ( selectionType == SelectionType . TAP ) { long currentTimeMillis = System . currentTimeMillis ( ) ; long lastAnimatedTimeMillis = mPreferenceManager . getContextualSearchLastAnimationTime ( ) ; if ( Math . abs ( currentTimeMillis - lastAnimatedTimeMillis ) > ONE_DAY_IN_MILLIS ) { mPreferenceManager . setContextualSearchLastAnimationTime ( currentTimeMillis ) ; return _BOOL ; } else { return _BOOL ; } } else if ( selectionType == SelectionType . LONG_PRESS ) { return getPromoOpenCount ( ) == _NUM ; } return _BOOL ; }
boolean shouldAnimateSearchProviderIcon ( SelectionType selectionType , boolean isShowing ) { if ( isShowing || ContextualSearchFieldTrial . areExtraSearchBarAnimationsDisabled ( ) ) { return _BOOL ; } if ( selectionType == SelectionType . TAP ) { long currentTimeMillis = System . currentTimeMillis ( ) ; long lastAnimatedTimeMillis = mPreferenceManager . getContextualSearchLastAnimationTime ( ) ; if ( Math . abs ( currentTimeMillis - lastAnimatedTimeMillis ) > ONE_DAY_IN_MILLIS ) { mPreferenceManager . setContextualSearchLastAnimationTime ( currentTimeMillis ) ; return _BOOL ; } else { return _BOOL ; } } else if ( selectionType == SelectionType . LONG_PRESS ) { return getPromoOpenCount ( ) == _NUM ; } return _BOOL ; }
boolean shouldAnimateSearchProviderIcon ( SelectionType selectionType , boolean isShowing ) { if ( isShowing || ContextualSearchFieldTrial . areExtraSearchBarAnimationsDisabled ( ) ) { return _BOOL ; } if ( selectionType == SelectionType . TAP ) { long currentTimeMillis = System . currentTimeMillis ( ) ; long lastAnimatedTimeMillis = mPreferenceManager . getContextualSearchLastAnimationTime ( ) ; if ( Math . abs ( currentTimeMillis - lastAnimatedTimeMillis ) > ONE_DAY_IN_MILLIS ) { mPreferenceManager . setContextualSearchLastAnimationTime ( currentTimeMillis ) ; return _BOOL ; } else { return _BOOL ; } } else if ( selectionType == SelectionType . LONG_PRESS ) { return getPromoOpenCount ( ) == _NUM ; } return _BOOL ; }
boolean shouldAnimateSearchProviderIcon ( SelectionType selectionType , boolean isShowing ) { if ( isShowing || ContextualSearchFieldTrial . areExtraSearchBarAnimationsDisabled ( ) ) { return _BOOL ; } if ( selectionType == SelectionType . TAP ) { long currentTimeMillis = System . currentTimeMillis ( ) ; long lastAnimatedTimeMillis = mPreferenceManager . getContextualSearchLastAnimationTime ( ) ; if ( Math . abs ( currentTimeMillis - lastAnimatedTimeMillis ) > ONE_DAY_IN_MILLIS ) { mPreferenceManager . setContextualSearchLastAnimationTime ( currentTimeMillis ) ; return _BOOL ; } else { return _BOOL ; } } else if ( selectionType == SelectionType . LONG_PRESS ) { return getPromoOpenCount ( ) == _NUM ; } return _BOOL ; }
boolean shouldAnimateSearchProviderIcon ( SelectionType selectionType , boolean isShowing ) { if ( isShowing || ContextualSearchFieldTrial . areExtraSearchBarAnimationsDisabled ( ) ) { return _BOOL ; } if ( selectionType == SelectionType . TAP ) { long currentTimeMillis = System . currentTimeMillis ( ) ; long lastAnimatedTimeMillis = mPreferenceManager . getContextualSearchLastAnimationTime ( ) ; if ( Math . abs ( currentTimeMillis - lastAnimatedTimeMillis ) > ONE_DAY_IN_MILLIS ) { mPreferenceManager . setContextualSearchLastAnimationTime ( currentTimeMillis ) ; return _BOOL ; } else { return _BOOL ; } } else if ( selectionType == SelectionType . LONG_PRESS ) { return getPromoOpenCount ( ) == _NUM ; } return _BOOL ; }
boolean shouldAnimateSearchProviderIcon ( SelectionType selectionType , boolean isShowing ) { if ( isShowing || ContextualSearchFieldTrial . areExtraSearchBarAnimationsDisabled ( ) ) { return _BOOL ; } if ( selectionType == SelectionType . TAP ) { long currentTimeMillis = System . currentTimeMillis ( ) ; long lastAnimatedTimeMillis = mPreferenceManager . getContextualSearchLastAnimationTime ( ) ; if ( Math . abs ( currentTimeMillis - lastAnimatedTimeMillis ) > ONE_DAY_IN_MILLIS ) { mPreferenceManager . setContextualSearchLastAnimationTime ( currentTimeMillis ) ; return _BOOL ; } else { return _BOOL ; } } else if ( selectionType == SelectionType . LONG_PRESS ) { return getPromoOpenCount ( ) == _NUM ; } return _BOOL ; }
public CompositePredicate ( Predicate p1 , Predicate p2 ) { m_clauses . add ( p1 ) ; m_clauses . add ( p2 ) ; }
public boolean writeHeader ( OutputStream os ) { try { writeInt ( os , CACHE_MAGIC ) ; writeString ( os , key ) ; writeString ( os , etag == null ? STRING : etag ) ; writeLong ( os , serverDate ) ; writeLong ( os , lastModified ) ; writeLong ( os , ttl ) ; writeLong ( os , softTtl ) ; writeStringStringMap ( responseHeaders , os ) ; os . flush ( ) ; return _BOOL ; } catch ( IOException e ) { VolleyLog . d ( STRING , e . toString ( ) ) ; return _BOOL ; } }
public static void println ( ) { out . println ( ) ; }
public static void println ( ) { out . println ( ) ; }
public static void println ( ) { out . println ( ) ; }
public QuadEdge connect ( QuadEdge a , QuadEdge b ) { QuadEdge q = QuadEdge . connect ( a , b ) ; quadEdges . add ( q ) ; return q ; }
public QuadEdge connect ( QuadEdge a , QuadEdge b ) { QuadEdge q = QuadEdge . connect ( a , b ) ; quadEdges . add ( q ) ; return q ; }
public QuadEdge connect ( QuadEdge a , QuadEdge b ) { QuadEdge q = QuadEdge . connect ( a , b ) ; quadEdges . add ( q ) ; return q ; }
public QuadEdge connect ( QuadEdge a , QuadEdge b ) { QuadEdge q = QuadEdge . connect ( a , b ) ; quadEdges . add ( q ) ; return q ; }
public QuadEdge connect ( QuadEdge a , QuadEdge b ) { QuadEdge q = QuadEdge . connect ( a , b ) ; quadEdges . add ( q ) ; return q ; }
public QuadEdge connect ( QuadEdge a , QuadEdge b ) { QuadEdge q = QuadEdge . connect ( a , b ) ; quadEdges . add ( q ) ; return q ; }
public void engineDeleteEntry ( String alias ) throws KeyStoreException { permissionCheck ( ) ; synchronized ( entries ) { Object entry = entries . remove ( alias . toLowerCase ( ) ) ; deletedEntries . put ( alias . toLowerCase ( ) , entry ) ; } }
@ Override public void dispatch ( RemoteEventBusPacket packet ) { try { packet . execute ( this ) ; } catch ( Exception ex ) { if ( _logger . isLoggable ( Level . SEVERE ) ) _logger . log ( Level . SEVERE , ex . toString ( ) , ex ) ; } finally { _dataEventManager . notifyReturned ( packet . getStatus ( ) , ( ITemplateHolder ) packet . getEntryHolder ( ) ) ; } }
@ Override public void dispatch ( RemoteEventBusPacket packet ) { try { packet . execute ( this ) ; } catch ( Exception ex ) { if ( _logger . isLoggable ( Level . SEVERE ) ) _logger . log ( Level . SEVERE , ex . toString ( ) , ex ) ; } finally { _dataEventManager . notifyReturned ( packet . getStatus ( ) , ( ITemplateHolder ) packet . getEntryHolder ( ) ) ; } }
@ Override public void dispatch ( RemoteEventBusPacket packet ) { try { packet . execute ( this ) ; } catch ( Exception ex ) { if ( _logger . isLoggable ( Level . SEVERE ) ) _logger . log ( Level . SEVERE , ex . toString ( ) , ex ) ; } finally { _dataEventManager . notifyReturned ( packet . getStatus ( ) , ( ITemplateHolder ) packet . getEntryHolder ( ) ) ; } }
@ Override public void dispatch ( RemoteEventBusPacket packet ) { try { packet . execute ( this ) ; } catch ( Exception ex ) { if ( _logger . isLoggable ( Level . SEVERE ) ) _logger . log ( Level . SEVERE , ex . toString ( ) , ex ) ; } finally { _dataEventManager . notifyReturned ( packet . getStatus ( ) , ( ITemplateHolder ) packet . getEntryHolder ( ) ) ; } }
@ Override public Fraction multiply ( Fraction fraction ) { MathUtils . checkNotNull ( fraction , LocalizedCoreFormats . FRACTION ) ; if ( numerator == _NUM || fraction . numerator == _NUM ) { return ZERO ; } int d1 = ArithmeticUtils . gcd ( numerator , fraction . denominator ) ; int d2 = ArithmeticUtils . gcd ( fraction . numerator , denominator ) ; return getReducedFraction ( ArithmeticUtils . mulAndCheck ( numerator / d1 , fraction . numerator / d2 ) , ArithmeticUtils . mulAndCheck ( denominator / d2 , fraction . denominator / d1 ) ) ; }
@ Override void insertedText ( CharacterDataImpl node , int offset , int count ) { if ( ranges != null ) { notifyRangesInsertedText ( node , offset , count ) ; } }
public void addAttribute ( Object name , Object value ) { table . put ( name , value ) ; }
public void forward ( HttpServerRequest request ) { forward ( request , null ) ; }
private void updateOnes ( Statement stmt , String [ ] ones_updated , short [ ] twos ) throws SQLException { for ( int i = _NUM ; i < ones_updated . length ; i ++ ) { stmt . execute ( STRING + ones_updated [ i ] + STRING + twos [ i ] ) ; } }
public boolean hit ( Rectangle rect , Shape s , boolean onStroke ) { if ( onStroke ) { s = stroke . createStrokedShape ( s ) ; } s = transformShape ( s ) ; if ( ( constrainX | constrainY ) != _NUM ) { rect = new Rectangle ( rect ) ; rect . translate ( constrainX , constrainY ) ; } return s . intersects ( rect ) ; }
public SortClause ( String item , String order ) { this ( item , ORDER . valueOf ( order ) ) ; }
@ Override public void readNBT ( NBTTagCompound compound ) { super . readNBT ( compound ) ; if ( compound . hasKey ( STRING ) ) { this . exhaustionTimer = compound . getInteger ( STRING ) ; } if ( ! compound . hasKey ( STRING ) ) { setFoodLevel ( getFoodLevel ( ) * _NUM ) ; setSaturation ( _NUM ) ; } if ( getFoodLevel ( ) > _NUM ) setFoodLevel ( _NUM ) ; if ( getSaturationLevel ( ) > _NUM ) setSaturation ( _NUM ) ; }
@ Override public int maximumSize ( Container container , List components , FormLayout . Measure minMeasure , FormLayout . Measure prefMeasure , FormLayout . Measure defaultMeasure ) { FormLayout . Measure measure = this == MINIMUM ? minMeasure : ( this == PREFERRED ? prefMeasure : defaultMeasure ) ; int maximum = _NUM ; for ( Iterator i = components . iterator ( ) ; i . hasNext ( ) ; ) { Component c = ( Component ) i . next ( ) ; maximum = Math . max ( maximum , measure . sizeOf ( c ) ) ; } return maximum ; }
@ Override public int maximumSize ( Container container , List components , FormLayout . Measure minMeasure , FormLayout . Measure prefMeasure , FormLayout . Measure defaultMeasure ) { FormLayout . Measure measure = this == MINIMUM ? minMeasure : ( this == PREFERRED ? prefMeasure : defaultMeasure ) ; int maximum = _NUM ; for ( Iterator i = components . iterator ( ) ; i . hasNext ( ) ; ) { Component c = ( Component ) i . next ( ) ; maximum = Math . max ( maximum , measure . sizeOf ( c ) ) ; } return maximum ; }
@ Override public int maximumSize ( Container container , List components , FormLayout . Measure minMeasure , FormLayout . Measure prefMeasure , FormLayout . Measure defaultMeasure ) { FormLayout . Measure measure = this == MINIMUM ? minMeasure : ( this == PREFERRED ? prefMeasure : defaultMeasure ) ; int maximum = _NUM ; for ( Iterator i = components . iterator ( ) ; i . hasNext ( ) ; ) { Component c = ( Component ) i . next ( ) ; maximum = Math . max ( maximum , measure . sizeOf ( c ) ) ; } return maximum ; }
@ Override public int maximumSize ( Container container , List components , FormLayout . Measure minMeasure , FormLayout . Measure prefMeasure , FormLayout . Measure defaultMeasure ) { FormLayout . Measure measure = this == MINIMUM ? minMeasure : ( this == PREFERRED ? prefMeasure : defaultMeasure ) ; int maximum = _NUM ; for ( Iterator i = components . iterator ( ) ; i . hasNext ( ) ; ) { Component c = ( Component ) i . next ( ) ; maximum = Math . max ( maximum , measure . sizeOf ( c ) ) ; } return maximum ; }
@ Override public int maximumSize ( Container container , List components , FormLayout . Measure minMeasure , FormLayout . Measure prefMeasure , FormLayout . Measure defaultMeasure ) { FormLayout . Measure measure = this == MINIMUM ? minMeasure : ( this == PREFERRED ? prefMeasure : defaultMeasure ) ; int maximum = _NUM ; for ( Iterator i = components . iterator ( ) ; i . hasNext ( ) ; ) { Component c = ( Component ) i . next ( ) ; maximum = Math . max ( maximum , measure . sizeOf ( c ) ) ; } return maximum ; }
public static TimeSeriesData serializableInstance ( ) { List < String > varNames = new ArrayList < > ( ) ; varNames . add ( STRING ) ; varNames . add ( STRING ) ; return new TimeSeriesData ( new TetradMatrix ( _NUM , _NUM ) , varNames ) ; }
public static TimeSeriesData serializableInstance ( ) { List < String > varNames = new ArrayList < > ( ) ; varNames . add ( STRING ) ; varNames . add ( STRING ) ; return new TimeSeriesData ( new TetradMatrix ( _NUM , _NUM ) , varNames ) ; }
public double saxMinDist ( char [ ] a , char [ ] b , double [ ] [ ] distanceMatrix , int n , int w ) throws SAXException { if ( a . length == b . length ) { double dist = _NUM ; for ( int i = _NUM ; i < a . length ; i ++ ) { if ( Character . isLetter ( a [ i ] ) && Character . isLetter ( b [ i ] ) ) { int numA = Character . getNumericValue ( a [ i ] ) - _NUM ; int numB = Character . getNumericValue ( b [ i ] ) - _NUM ; int maxIdx = distanceMatrix [ _NUM ] . length ; if ( numA > ( maxIdx - _NUM ) || numA < _NUM || numB > ( maxIdx - _NUM ) || numB < _NUM ) { throw new SAXException ( STRING + maxIdx + STRING ) ; } double localDist = distanceMatrix [ numA ] [ numB ] ; dist = dist + localDist * localDist ; } else { throw new SAXException ( STRING ) ; } } return Math . sqrt ( ( double ) n / ( double ) w ) * Math . sqrt ( dist ) ; } else { throw new SAXException ( STRING ) ; } }
public double saxMinDist ( char [ ] a , char [ ] b , double [ ] [ ] distanceMatrix , int n , int w ) throws SAXException { if ( a . length == b . length ) { double dist = _NUM ; for ( int i = _NUM ; i < a . length ; i ++ ) { if ( Character . isLetter ( a [ i ] ) && Character . isLetter ( b [ i ] ) ) { int numA = Character . getNumericValue ( a [ i ] ) - _NUM ; int numB = Character . getNumericValue ( b [ i ] ) - _NUM ; int maxIdx = distanceMatrix [ _NUM ] . length ; if ( numA > ( maxIdx - _NUM ) || numA < _NUM || numB > ( maxIdx - _NUM ) || numB < _NUM ) { throw new SAXException ( STRING + maxIdx + STRING ) ; } double localDist = distanceMatrix [ numA ] [ numB ] ; dist = dist + localDist * localDist ; } else { throw new SAXException ( STRING ) ; } } return Math . sqrt ( ( double ) n / ( double ) w ) * Math . sqrt ( dist ) ; } else { throw new SAXException ( STRING ) ; } }
public double saxMinDist ( char [ ] a , char [ ] b , double [ ] [ ] distanceMatrix , int n , int w ) throws SAXException { if ( a . length == b . length ) { double dist = _NUM ; for ( int i = _NUM ; i < a . length ; i ++ ) { if ( Character . isLetter ( a [ i ] ) && Character . isLetter ( b [ i ] ) ) { int numA = Character . getNumericValue ( a [ i ] ) - _NUM ; int numB = Character . getNumericValue ( b [ i ] ) - _NUM ; int maxIdx = distanceMatrix [ _NUM ] . length ; if ( numA > ( maxIdx - _NUM ) || numA < _NUM || numB > ( maxIdx - _NUM ) || numB < _NUM ) { throw new SAXException ( STRING + maxIdx + STRING ) ; } double localDist = distanceMatrix [ numA ] [ numB ] ; dist = dist + localDist * localDist ; } else { throw new SAXException ( STRING ) ; } } return Math . sqrt ( ( double ) n / ( double ) w ) * Math . sqrt ( dist ) ; } else { throw new SAXException ( STRING ) ; } }
public boolean validSystemNameFormat ( String systemName ) { return ( getBitFromSystemName ( systemName ) != _NUM ) ; }
public boolean validSystemNameFormat ( String systemName ) { return ( getBitFromSystemName ( systemName ) != _NUM ) ; }
public byte [ ] toBytecode ( ) throws IOException , CannotCompileException { ByteArrayOutputStream barray = new ByteArrayOutputStream ( ) ; DataOutputStream out = new DataOutputStream ( barray ) ; try { toBytecode ( out ) ; } finally { out . close ( ) ; } return barray . toByteArray ( ) ; }
public byte [ ] toBytecode ( ) throws IOException , CannotCompileException { ByteArrayOutputStream barray = new ByteArrayOutputStream ( ) ; DataOutputStream out = new DataOutputStream ( barray ) ; try { toBytecode ( out ) ; } finally { out . close ( ) ; } return barray . toByteArray ( ) ; }
public byte [ ] toBytecode ( ) throws IOException , CannotCompileException { ByteArrayOutputStream barray = new ByteArrayOutputStream ( ) ; DataOutputStream out = new DataOutputStream ( barray ) ; try { toBytecode ( out ) ; } finally { out . close ( ) ; } return barray . toByteArray ( ) ; }
public static HttpURLConnection toHttpConnection ( RequestBatch requests ) { for ( Request request : requests ) { request . validate ( ) ; } URL url = null ; try { if ( requests . size ( ) == _NUM ) { Request request = requests . get ( _NUM ) ; url = new URL ( request . getUrlForSingleRequest ( ) ) ; } else { url = new URL ( ServerProtocol . getGraphUrlBase ( ) ) ; } } catch ( MalformedURLException e ) { throw new FacebookException ( STRING , e ) ; } HttpURLConnection connection ; try { connection = createConnection ( url ) ; serializeToUrlConnection ( requests , connection ) ; } catch ( IOException e ) { throw new FacebookException ( STRING , e ) ; } catch ( JSONException e ) { throw new FacebookException ( STRING , e ) ; } return connection ; }
public static HttpURLConnection toHttpConnection ( RequestBatch requests ) { for ( Request request : requests ) { request . validate ( ) ; } URL url = null ; try { if ( requests . size ( ) == _NUM ) { Request request = requests . get ( _NUM ) ; url = new URL ( request . getUrlForSingleRequest ( ) ) ; } else { url = new URL ( ServerProtocol . getGraphUrlBase ( ) ) ; } } catch ( MalformedURLException e ) { throw new FacebookException ( STRING , e ) ; } HttpURLConnection connection ; try { connection = createConnection ( url ) ; serializeToUrlConnection ( requests , connection ) ; } catch ( IOException e ) { throw new FacebookException ( STRING , e ) ; } catch ( JSONException e ) { throw new FacebookException ( STRING , e ) ; } return connection ; }
public static HttpURLConnection toHttpConnection ( RequestBatch requests ) { for ( Request request : requests ) { request . validate ( ) ; } URL url = null ; try { if ( requests . size ( ) == _NUM ) { Request request = requests . get ( _NUM ) ; url = new URL ( request . getUrlForSingleRequest ( ) ) ; } else { url = new URL ( ServerProtocol . getGraphUrlBase ( ) ) ; } } catch ( MalformedURLException e ) { throw new FacebookException ( STRING , e ) ; } HttpURLConnection connection ; try { connection = createConnection ( url ) ; serializeToUrlConnection ( requests , connection ) ; } catch ( IOException e ) { throw new FacebookException ( STRING , e ) ; } catch ( JSONException e ) { throw new FacebookException ( STRING , e ) ; } return connection ; }
public void removeLocators ( LookupLocator [ ] locators ) { testSetForNull ( locators ) ; synchronized ( this ) { if ( terminated ) { throw new IllegalStateException ( STRING ) ; } HashMap groupsMap = new HashMap ( _NUM ) ; for ( int i = _NUM ; i < locators . length ; i ++ ) { LocatorReg reg = removeDiscoveredLocator ( locators [ i ] ) ; if ( reg != null ) { groupsMap . put ( reg . proxy , reg . memberGroups ) ; continue ; } reg = findReg ( locators [ i ] ) ; if ( reg != null ) { undiscoveredLocators . remove ( reg ) ; } } if ( ! groupsMap . isEmpty ( ) && ! listeners . isEmpty ( ) ) { addNotify ( ( ArrayList ) listeners . clone ( ) , groupsMap , _BOOL ) ; } } }
public void removeLocators ( LookupLocator [ ] locators ) { testSetForNull ( locators ) ; synchronized ( this ) { if ( terminated ) { throw new IllegalStateException ( STRING ) ; } HashMap groupsMap = new HashMap ( _NUM ) ; for ( int i = _NUM ; i < locators . length ; i ++ ) { LocatorReg reg = removeDiscoveredLocator ( locators [ i ] ) ; if ( reg != null ) { groupsMap . put ( reg . proxy , reg . memberGroups ) ; continue ; } reg = findReg ( locators [ i ] ) ; if ( reg != null ) { undiscoveredLocators . remove ( reg ) ; } } if ( ! groupsMap . isEmpty ( ) && ! listeners . isEmpty ( ) ) { addNotify ( ( ArrayList ) listeners . clone ( ) , groupsMap , _BOOL ) ; } } }
public void removeLocators ( LookupLocator [ ] locators ) { testSetForNull ( locators ) ; synchronized ( this ) { if ( terminated ) { throw new IllegalStateException ( STRING ) ; } HashMap groupsMap = new HashMap ( _NUM ) ; for ( int i = _NUM ; i < locators . length ; i ++ ) { LocatorReg reg = removeDiscoveredLocator ( locators [ i ] ) ; if ( reg != null ) { groupsMap . put ( reg . proxy , reg . memberGroups ) ; continue ; } reg = findReg ( locators [ i ] ) ; if ( reg != null ) { undiscoveredLocators . remove ( reg ) ; } } if ( ! groupsMap . isEmpty ( ) && ! listeners . isEmpty ( ) ) { addNotify ( ( ArrayList ) listeners . clone ( ) , groupsMap , _BOOL ) ; } } }
public static void computePositions ( Node node , int depth , double aoff , double awid , int maxdepth ) { double r = depth / ( maxdepth - _NUM ) ; node . x = Math . sin ( aoff + awid * _NUM ) * r ; node . y = Math . cos ( aoff + awid * _NUM ) * r ; double cpos = aoff ; double cwid = awid / node . weight ; for ( Node c : node . children ) { computePositions ( c , depth + _NUM , cpos , cwid * c . weight , maxdepth ) ; cpos += cwid * c . weight ; } }
private static double threePointsAngle ( Point vertex , Point A , Point B ) { double b = pointsDistance ( vertex , A ) ; double c = pointsDistance ( A , B ) ; double a = pointsDistance ( B , vertex ) ; return Math . toDegrees ( Math . acos ( ( a * a + b * b - c * c ) / ( _NUM * a * b ) ) ) ; }
public void deleteStringAttributes ( ) { deleteAttributeType ( Attribute . STRING ) ; }
public void stepSystem ( int nstep ) { root = null ; makeTree ( nstep ) ; for ( Enumeration < Body > e = bodyTabRev . elementsRev ( ) ; e . hasMoreElements ( ) ; ) { Body b = e . nextElement ( ) ; b . hackGravity ( rsize , root ) ; } vp ( bodyTabRev , nstep ) ; }
public void stepSystem ( int nstep ) { root = null ; makeTree ( nstep ) ; for ( Enumeration < Body > e = bodyTabRev . elementsRev ( ) ; e . hasMoreElements ( ) ; ) { Body b = e . nextElement ( ) ; b . hackGravity ( rsize , root ) ; } vp ( bodyTabRev , nstep ) ; }
public final void test_ROUNDTRIP_GetKeySpecKeyProvider01 ( ) { boolean performed = _BOOL ; for ( int i = _NUM ; i < algName . length ; i ++ ) { for ( int l = _NUM ; l < provider . length ; l ++ ) { if ( provider [ l ] == null ) { continue ; } TestDataGenerator g ; try { g = new TestDataGenerator ( algName [ i ] [ _NUM ] , algName [ i ] [ _NUM ] , privateKeyInfo , provider [ l ] ) ; } catch ( TestDataGenerator . AllowedFailure allowedFailure ) { continue ; } try { EncryptedPrivateKeyInfo epki ; if ( g . ap ( ) == null ) { epki = new EncryptedPrivateKeyInfo ( algName [ i ] [ _NUM ] , g . ct ( ) ) ; } else { epki = new EncryptedPrivateKeyInfo ( g . ap ( ) , g . ct ( ) ) ; } try { PKCS8EncodedKeySpec eks = epki . getKeySpec ( g . pubK ( ) == null ? g . k ( ) : g . pubK ( ) , provider [ l ] ) ; if ( ! Arrays . equals ( privateKeyInfo , eks . getEncoded ( ) ) ) { fail ( algName [ i ] [ _NUM ] + STRING + algName [ i ] [ _NUM ] ) ; } } catch ( InvalidKeyException e ) { fail ( algName [ i ] [ _NUM ] + STRING + algName [ i ] [ _NUM ] + STRING + e ) ; } performed = _BOOL ; } catch ( NoSuchAlgorithmException allowedFailure ) { } } } assertTrue ( STRING , performed ) ; }
public final void test_ROUNDTRIP_GetKeySpecKeyProvider01 ( ) { boolean performed = _BOOL ; for ( int i = _NUM ; i < algName . length ; i ++ ) { for ( int l = _NUM ; l < provider . length ; l ++ ) { if ( provider [ l ] == null ) { continue ; } TestDataGenerator g ; try { g = new TestDataGenerator ( algName [ i ] [ _NUM ] , algName [ i ] [ _NUM ] , privateKeyInfo , provider [ l ] ) ; } catch ( TestDataGenerator . AllowedFailure allowedFailure ) { continue ; } try { EncryptedPrivateKeyInfo epki ; if ( g . ap ( ) == null ) { epki = new EncryptedPrivateKeyInfo ( algName [ i ] [ _NUM ] , g . ct ( ) ) ; } else { epki = new EncryptedPrivateKeyInfo ( g . ap ( ) , g . ct ( ) ) ; } try { PKCS8EncodedKeySpec eks = epki . getKeySpec ( g . pubK ( ) == null ? g . k ( ) : g . pubK ( ) , provider [ l ] ) ; if ( ! Arrays . equals ( privateKeyInfo , eks . getEncoded ( ) ) ) { fail ( algName [ i ] [ _NUM ] + STRING + algName [ i ] [ _NUM ] ) ; } } catch ( InvalidKeyException e ) { fail ( algName [ i ] [ _NUM ] + STRING + algName [ i ] [ _NUM ] + STRING + e ) ; } performed = _BOOL ; } catch ( NoSuchAlgorithmException allowedFailure ) { } } } assertTrue ( STRING , performed ) ; }
public MultiSearchRequest add ( SearchRequestBuilder request ) { requests . add ( request . request ( ) ) ; return this ; }
public MultiSearchRequest add ( SearchRequestBuilder request ) { requests . add ( request . request ( ) ) ; return this ; }
private String checkAllDependencies ( HashMap < String , ModuleDescriptor > modlist ) { for ( ModuleDescriptor md : modlist . values ( ) ) { String res = checkDependencies ( md , modlist ) ; if ( ! res . isEmpty ( ) ) { return res ; } } return STRING ; }
public boolean addNode ( ServiceNode node ) { try { return nodes . add ( node ) ; } catch ( Exception e ) { return _BOOL ; } }
private void handleCrawlDelay ( ParseState state , RobotToken token ) { if ( state . isSkipAgents ( ) ) { return ; } state . setFinishedAgentFields ( _BOOL ) ; if ( ! state . isAddingRules ( ) ) { return ; } String delayString = token . getData ( ) ; if ( delayString . length ( ) > _NUM ) { try { if ( delayString . indexOf ( STRING ) != - _NUM ) { double delayValue = Double . parseDouble ( delayString ) * _NUM ; state . setCrawlDelay ( Math . round ( delayValue ) ) ; } else { long delayValue = Integer . parseInt ( delayString ) * _NUM ; state . setCrawlDelay ( delayValue ) ; } } catch ( Exception e ) { reportWarning ( STRING + delayString , state . getUrl ( ) ) ; } } }
public Object [ ] toArray ( ) { Object [ ] rv = new Object [ delegate . size ( ) ] ; delegate . copyInto ( rv ) ; return rv ; }
public Object [ ] toArray ( ) { Object [ ] rv = new Object [ delegate . size ( ) ] ; delegate . copyInto ( rv ) ; return rv ; }
public Object [ ] toArray ( ) { Object [ ] rv = new Object [ delegate . size ( ) ] ; delegate . copyInto ( rv ) ; return rv ; }
public EventListenerSupport ( final Class < L > listenerInterface , final ClassLoader classLoader ) { this ( ) ; Validate . notNull ( listenerInterface , STRING ) ; Validate . notNull ( classLoader , STRING ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , STRING , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; }
public EventListenerSupport ( final Class < L > listenerInterface , final ClassLoader classLoader ) { this ( ) ; Validate . notNull ( listenerInterface , STRING ) ; Validate . notNull ( classLoader , STRING ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , STRING , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; }
public EventListenerSupport ( final Class < L > listenerInterface , final ClassLoader classLoader ) { this ( ) ; Validate . notNull ( listenerInterface , STRING ) ; Validate . notNull ( classLoader , STRING ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , STRING , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; }
public EventListenerSupport ( final Class < L > listenerInterface , final ClassLoader classLoader ) { this ( ) ; Validate . notNull ( listenerInterface , STRING ) ; Validate . notNull ( classLoader , STRING ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , STRING , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; }
public EventListenerSupport ( final Class < L > listenerInterface , final ClassLoader classLoader ) { this ( ) ; Validate . notNull ( listenerInterface , STRING ) ; Validate . notNull ( classLoader , STRING ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , STRING , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; }
public void removeUserLockoutEntry ( String userDN ) { pwResetFailHash . remove ( userDN ) ; userWarningCount = _NUM ; }
private void codeWrapArgument ( Class < ? > type , int slot , DataOutputStream out ) throws IOException { if ( type . isPrimitive ( ) ) { PrimitiveTypeInfo prim = PrimitiveTypeInfo . get ( type ) ; if ( type == int . class || type == boolean . class || type == byte . class || type == char . class || type == short . class ) { code_iload ( slot , out ) ; } else if ( type == long . class ) { code_lload ( slot , out ) ; } else if ( type == float . class ) { code_fload ( slot , out ) ; } else if ( type == double . class ) { code_dload ( slot , out ) ; } else { throw new AssertionError ( ) ; } out . writeByte ( opc_invokestatic ) ; out . writeShort ( cp . getMethodRef ( prim . wrapperClassName , STRING , prim . wrapperValueOfDesc ) ) ; } else { code_aload ( slot , out ) ; } }
private void codeWrapArgument ( Class < ? > type , int slot , DataOutputStream out ) throws IOException { if ( type . isPrimitive ( ) ) { PrimitiveTypeInfo prim = PrimitiveTypeInfo . get ( type ) ; if ( type == int . class || type == boolean . class || type == byte . class || type == char . class || type == short . class ) { code_iload ( slot , out ) ; } else if ( type == long . class ) { code_lload ( slot , out ) ; } else if ( type == float . class ) { code_fload ( slot , out ) ; } else if ( type == double . class ) { code_dload ( slot , out ) ; } else { throw new AssertionError ( ) ; } out . writeByte ( opc_invokestatic ) ; out . writeShort ( cp . getMethodRef ( prim . wrapperClassName , STRING , prim . wrapperValueOfDesc ) ) ; } else { code_aload ( slot , out ) ; } }
private void drawXAxisMarker ( Canvas canvas , double value , NumberFormat numberFormat , int spacing ) { String marker = chartByDistance ? numberFormat . format ( value ) : StringUtils . formatElapsedTime ( ( long ) value ) ; Rect rect = getRect ( xAxisMarkerPaint , marker ) ; canvas . drawText ( marker , getX ( value ) , topBorder + effectiveHeight + spacing + rect . height ( ) , xAxisMarkerPaint ) ; }
@ Override public void do_after_propagation ( ) { for ( PtInsIntervalManager pim : pt_objs . values ( ) ) { pim . flush ( ) ; } new_pts = new HashMap < AllocNode , PtInsIntervalManager > ( ) ; }
private static int [ ] flatten ( Set < Integer > [ ] algn ) { int [ ] flatArr = new int [ algn . length ] ; for ( int i = _NUM ; i < flatArr . length ; ++ i ) { if ( algn [ i ] == null ) continue ; List < Integer > points = new ArrayList < > ( algn [ i ] ) ; int al = _NUM ; for ( int j = _NUM , sz = Math . min ( MAX_FERTILITY , points . size ( ) ) ; j < sz ; ++ j ) { int pos = ( points . get ( j ) + _NUM ) << ( j * _NUM ) ; al |= pos ; } flatArr [ i ] = al ; } return flatArr ; }
private static int [ ] flatten ( Set < Integer > [ ] algn ) { int [ ] flatArr = new int [ algn . length ] ; for ( int i = _NUM ; i < flatArr . length ; ++ i ) { if ( algn [ i ] == null ) continue ; List < Integer > points = new ArrayList < > ( algn [ i ] ) ; int al = _NUM ; for ( int j = _NUM , sz = Math . min ( MAX_FERTILITY , points . size ( ) ) ; j < sz ; ++ j ) { int pos = ( points . get ( j ) + _NUM ) << ( j * _NUM ) ; al |= pos ; } flatArr [ i ] = al ; } return flatArr ; }
protected final void deserialize ( ObjectInputStream ois , Collection coll ) throws IOException , ClassNotFoundException { int count = _NUM ; count = ois . readInt ( ) ; while ( count -- > _NUM ) { coll . add ( ois . readObject ( ) ) ; } }
protected final void deserialize ( ObjectInputStream ois , Collection coll ) throws IOException , ClassNotFoundException { int count = _NUM ; count = ois . readInt ( ) ; while ( count -- > _NUM ) { coll . add ( ois . readObject ( ) ) ; } }
public boolean splitsTaxa ( BitSet taxa ) { return A . intersects ( taxa ) && B . intersects ( taxa ) ; }
public boolean splitsTaxa ( BitSet taxa ) { return A . intersects ( taxa ) && B . intersects ( taxa ) ; }
public static void toDo ( @ Scope int scope , String tag ) { List < Long > tagSeenList = tagLastSeenMap . get ( tag ) ; if ( tagSeenList . isEmpty ( ) ) { toDoSet . put ( tag ) ; return ; } Long tagLastSeen = tagSeenList . get ( tagSeenList . size ( ) - _NUM ) ; if ( scope == THIS_APP_VERSION && tagLastSeen <= lastAppUpdatedTime ) { toDoSet . put ( tag ) ; } }
public static void toDo ( @ Scope int scope , String tag ) { List < Long > tagSeenList = tagLastSeenMap . get ( tag ) ; if ( tagSeenList . isEmpty ( ) ) { toDoSet . put ( tag ) ; return ; } Long tagLastSeen = tagSeenList . get ( tagSeenList . size ( ) - _NUM ) ; if ( scope == THIS_APP_VERSION && tagLastSeen <= lastAppUpdatedTime ) { toDoSet . put ( tag ) ; } }
public static void clear ( String realmName ) { boolean isDefault = isDefaultOrg ( realmName ) ; if ( ( authCtxObjHash != null ) && ( ! authCtxObjHash . isEmpty ( ) ) ) { Enumeration keys = authCtxObjHash . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String key = ( String ) keys . nextElement ( ) ; if ( key . indexOf ( STRING + realmName ) != - _NUM ) { authCtxObjHash . remove ( key ) ; } if ( isDefault && key . endsWith ( STRING ) ) { authCtxObjHash . remove ( key ) ; } } } if ( ( authContextHash != null ) && ( ! authContextHash . isEmpty ( ) ) ) { Enumeration keys = authContextHash . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String key = ( String ) keys . nextElement ( ) ; if ( key . indexOf ( STRING + realmName ) != - _NUM ) { authContextHash . remove ( key ) ; } if ( isDefault && key . endsWith ( STRING ) ) { authCtxObjHash . remove ( key ) ; } } } }
protected final void fireVetoableChange ( String propertyName , float oldValue , float newValue ) throws PropertyVetoException { fireVetoableChange ( propertyName , Float . valueOf ( oldValue ) , Float . valueOf ( newValue ) ) ; }
protected final void fireVetoableChange ( String propertyName , float oldValue , float newValue ) throws PropertyVetoException { fireVetoableChange ( propertyName , Float . valueOf ( oldValue ) , Float . valueOf ( newValue ) ) ; }
private void writeInt ( DataOutput out , int val ) throws IOException { intBuf [ _NUM ] = ( byte ) ( val > > _NUM ) ; intBuf [ _NUM ] = ( byte ) ( val > > _NUM ) ; intBuf [ _NUM ] = ( byte ) ( val > > _NUM ) ; intBuf [ _NUM ] = ( byte ) val ; out . write ( intBuf ) ; }
private void writeInt ( DataOutput out , int val ) throws IOException { intBuf [ _NUM ] = ( byte ) ( val > > _NUM ) ; intBuf [ _NUM ] = ( byte ) ( val > > _NUM ) ; intBuf [ _NUM ] = ( byte ) ( val > > _NUM ) ; intBuf [ _NUM ] = ( byte ) val ; out . write ( intBuf ) ; }
private boolean isMechFactoryProperty ( String prop ) { return ( prop . startsWith ( PROV_PROP_PREFIX ) || prop . regionMatches ( _BOOL , _NUM , PROV_PROP_PREFIX , _NUM , PROV_PROP_PREFIX_LEN ) ) ; }
private boolean isMechFactoryProperty ( String prop ) { return ( prop . startsWith ( PROV_PROP_PREFIX ) || prop . regionMatches ( _BOOL , _NUM , PROV_PROP_PREFIX , _NUM , PROV_PROP_PREFIX_LEN ) ) ; }
@ RequestMapping ( value = STRING , method = RequestMethod . DELETE ) @ ResponseBody public RestWrapper delete ( @ PathVariable ( STRING ) Long queueId , Principal principal ) { RestWrapper restWrapper = null ; try { batchConsumpQueueDAO . delete ( queueId ) ; restWrapper = new RestWrapper ( null , RestWrapper . OK ) ; LOGGER . info ( RECORDWITHID + queueId + STRING + principal . getName ( ) ) ; } catch ( MetadataException e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
private static void skipMemberValue ( int tag , ByteBuffer buf ) { switch ( tag ) { case STRING : buf . getInt ( ) ; break ; case STRING : skipAnnotation ( buf , _BOOL ) ; break ; case STRING : skipArray ( buf ) ; break ; default : buf . getShort ( ) ; } }
private static void skipMemberValue ( int tag , ByteBuffer buf ) { switch ( tag ) { case STRING : buf . getInt ( ) ; break ; case STRING : skipAnnotation ( buf , _BOOL ) ; break ; case STRING : skipArray ( buf ) ; break ; default : buf . getShort ( ) ; } }
private static void skipMemberValue ( int tag , ByteBuffer buf ) { switch ( tag ) { case STRING : buf . getInt ( ) ; break ; case STRING : skipAnnotation ( buf , _BOOL ) ; break ; case STRING : skipArray ( buf ) ; break ; default : buf . getShort ( ) ; } }
private static void skipMemberValue ( int tag , ByteBuffer buf ) { switch ( tag ) { case STRING : buf . getInt ( ) ; break ; case STRING : skipAnnotation ( buf , _BOOL ) ; break ; case STRING : skipArray ( buf ) ; break ; default : buf . getShort ( ) ; } }
private static void skipMemberValue ( int tag , ByteBuffer buf ) { switch ( tag ) { case STRING : buf . getInt ( ) ; break ; case STRING : skipAnnotation ( buf , _BOOL ) ; break ; case STRING : skipArray ( buf ) ; break ; default : buf . getShort ( ) ; } }
public static void addEventCallback ( IEventCallback callback ) { sEventCallback . add ( callback ) ; }
public static void addEventCallback ( IEventCallback callback ) { sEventCallback . add ( callback ) ; }
private Map < URI , StorageSystem > buildArrayMap ( List < VolumeDescriptor > descriptors , VolumeDescriptor . Type type ) { Map < URI , StorageSystem > arrayMap = new HashMap < URI , StorageSystem > ( ) ; if ( type != null ) { descriptors = VolumeDescriptor . filterByType ( descriptors , new VolumeDescriptor . Type [ ] { type } , new VolumeDescriptor . Type [ ] { } ) ; } for ( VolumeDescriptor desc : descriptors ) { if ( arrayMap . containsKey ( desc . getDeviceURI ( ) ) == _BOOL ) { StorageSystem array = getDataObject ( StorageSystem . class , desc . getDeviceURI ( ) , _dbClient ) ; arrayMap . put ( desc . getDeviceURI ( ) , array ) ; } } return arrayMap ; }
public void runTestOnMethod ( MediaPlayerMethodUnderTest testMethod ) { mMethodUnderTest = testMethod ; if ( mMethodUnderTest != null ) { initializeMessageLooper ( ) ; synchronized ( lock ) { try { lock . wait ( WAIT_FOR_COMMAND_TO_COMPLETE ) ; } catch ( Exception e ) { Log . v ( TAG , STRING ) ; } } assertTrue ( mInitialized ) ; checkMethodUnderTestInAllPossibleStates ( ) ; terminateMessageLooper ( ) ; assertTrue ( mOnCompletionHasBeenCalled ) ; mMethodUnderTest . checkStateErrors ( mStateErrors ) ; cleanUp ( ) ; } }
public ScCopyMirrorMigrate createMirror ( String ssn , String srcId , String dstId ) throws StorageCenterAPIException { Parameters params = new Parameters ( ) ; params . add ( STRING , ssn ) ; params . add ( STRING , srcId ) ; params . add ( STRING , dstId ) ; params . add ( STRING , _BOOL ) ; RestResult rr = restClient . post ( STRING , params . toJson ( ) ) ; if ( ! checkResults ( rr ) ) { String msg = String . format ( STRING , srcId , dstId , rr . getErrorMsg ( ) ) ; LOG . warn ( msg ) ; throw new StorageCenterAPIException ( msg ) ; } return gson . fromJson ( rr . getResult ( ) , ScCopyMirrorMigrate . class ) ; }
public ScCopyMirrorMigrate createMirror ( String ssn , String srcId , String dstId ) throws StorageCenterAPIException { Parameters params = new Parameters ( ) ; params . add ( STRING , ssn ) ; params . add ( STRING , srcId ) ; params . add ( STRING , dstId ) ; params . add ( STRING , _BOOL ) ; RestResult rr = restClient . post ( STRING , params . toJson ( ) ) ; if ( ! checkResults ( rr ) ) { String msg = String . format ( STRING , srcId , dstId , rr . getErrorMsg ( ) ) ; LOG . warn ( msg ) ; throw new StorageCenterAPIException ( msg ) ; } return gson . fromJson ( rr . getResult ( ) , ScCopyMirrorMigrate . class ) ; }
public boolean isNoTextMode ( ) { return noTextMode ; }
public boolean isNoTextMode ( ) { return noTextMode ; }
public boolean isNoTextMode ( ) { return noTextMode ; }
static final void cancelIgnoringExceptions ( ForkJoinTask < ? > t ) { if ( t != null && t . status >= _NUM ) { try { t . cancel ( _BOOL ) ; } catch ( Throwable ignore ) { } } }
static final void cancelIgnoringExceptions ( ForkJoinTask < ? > t ) { if ( t != null && t . status >= _NUM ) { try { t . cancel ( _BOOL ) ; } catch ( Throwable ignore ) { } } }
static final void cancelIgnoringExceptions ( ForkJoinTask < ? > t ) { if ( t != null && t . status >= _NUM ) { try { t . cancel ( _BOOL ) ; } catch ( Throwable ignore ) { } } }
protected void checkJAXPVersion ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; final Class noArgs [ ] = new Class [ _NUM ] ; Class clazz = null ; try { final String JAXP1_CLASS = STRING ; final String JAXP11_METHOD = STRING ; clazz = ObjectFactory . findProviderClass ( JAXP1_CLASS , ObjectFactory . findClassLoader ( ) , _BOOL ) ; Method method = clazz . getMethod ( JAXP11_METHOD , noArgs ) ; h . put ( VERSION + STRING , STRING ) ; } catch ( Exception e ) { if ( null != clazz ) { h . put ( ERROR + VERSION + STRING , STRING ) ; h . put ( ERROR , ERROR_FOUND ) ; } else { h . put ( ERROR + VERSION + STRING , CLASS_NOTPRESENT ) ; h . put ( ERROR , ERROR_FOUND ) ; } } }
public final void testAddAllHelperTextsFromArray ( ) { CharSequence helperText1 = STRING ; CharSequence helperText2 = STRING ; CharSequence [ ] helperTexts1 = new CharSequence [ _NUM ] ; helperTexts1 [ _NUM ] = helperText1 ; helperTexts1 [ _NUM ] = helperText2 ; PasswordEditText passwordEditText = new PasswordEditText ( getContext ( ) ) ; passwordEditText . addAllHelperTexts ( helperTexts1 ) ; passwordEditText . addAllHelperTexts ( helperTexts1 ) ; Collection < CharSequence > helperTexts2 = passwordEditText . getHelperTexts ( ) ; assertEquals ( helperTexts1 . length , helperTexts2 . size ( ) ) ; Iterator < CharSequence > iterator = helperTexts2 . iterator ( ) ; assertEquals ( helperText1 , iterator . next ( ) ) ; assertEquals ( helperText2 , iterator . next ( ) ) ; }
public final void testAddAllHelperTextsFromArray ( ) { CharSequence helperText1 = STRING ; CharSequence helperText2 = STRING ; CharSequence [ ] helperTexts1 = new CharSequence [ _NUM ] ; helperTexts1 [ _NUM ] = helperText1 ; helperTexts1 [ _NUM ] = helperText2 ; PasswordEditText passwordEditText = new PasswordEditText ( getContext ( ) ) ; passwordEditText . addAllHelperTexts ( helperTexts1 ) ; passwordEditText . addAllHelperTexts ( helperTexts1 ) ; Collection < CharSequence > helperTexts2 = passwordEditText . getHelperTexts ( ) ; assertEquals ( helperTexts1 . length , helperTexts2 . size ( ) ) ; Iterator < CharSequence > iterator = helperTexts2 . iterator ( ) ; assertEquals ( helperText1 , iterator . next ( ) ) ; assertEquals ( helperText2 , iterator . next ( ) ) ; }
void addNodes ( List < Node > newNodes , boolean atBeginning ) { if ( atBeginning ) { if ( ( nodes . size ( ) > _NUM ) && nodes . get ( _NUM ) == newNodes . get ( newNodes . size ( ) - _NUM ) ) { Log . i ( DEBUG_TAG , STRING ) ; if ( newNodes . size ( ) > _NUM ) { Log . i ( DEBUG_TAG , STRING ) ; newNodes . remove ( newNodes . size ( ) - _NUM ) ; addNodes ( newNodes , atBeginning ) ; } return ; } nodes . addAll ( _NUM , newNodes ) ; } else { if ( ( nodes . size ( ) > _NUM ) && newNodes . get ( _NUM ) == nodes . get ( nodes . size ( ) - _NUM ) ) { Log . i ( DEBUG_TAG , STRING ) ; if ( newNodes . size ( ) > _NUM ) { Log . i ( DEBUG_TAG , STRING ) ; newNodes . remove ( _NUM ) ; addNodes ( newNodes , atBeginning ) ; } return ; } nodes . addAll ( newNodes ) ; } }
void addNodes ( List < Node > newNodes , boolean atBeginning ) { if ( atBeginning ) { if ( ( nodes . size ( ) > _NUM ) && nodes . get ( _NUM ) == newNodes . get ( newNodes . size ( ) - _NUM ) ) { Log . i ( DEBUG_TAG , STRING ) ; if ( newNodes . size ( ) > _NUM ) { Log . i ( DEBUG_TAG , STRING ) ; newNodes . remove ( newNodes . size ( ) - _NUM ) ; addNodes ( newNodes , atBeginning ) ; } return ; } nodes . addAll ( _NUM , newNodes ) ; } else { if ( ( nodes . size ( ) > _NUM ) && newNodes . get ( _NUM ) == nodes . get ( nodes . size ( ) - _NUM ) ) { Log . i ( DEBUG_TAG , STRING ) ; if ( newNodes . size ( ) > _NUM ) { Log . i ( DEBUG_TAG , STRING ) ; newNodes . remove ( _NUM ) ; addNodes ( newNodes , atBeginning ) ; } return ; } nodes . addAll ( newNodes ) ; } }
void addNodes ( List < Node > newNodes , boolean atBeginning ) { if ( atBeginning ) { if ( ( nodes . size ( ) > _NUM ) && nodes . get ( _NUM ) == newNodes . get ( newNodes . size ( ) - _NUM ) ) { Log . i ( DEBUG_TAG , STRING ) ; if ( newNodes . size ( ) > _NUM ) { Log . i ( DEBUG_TAG , STRING ) ; newNodes . remove ( newNodes . size ( ) - _NUM ) ; addNodes ( newNodes , atBeginning ) ; } return ; } nodes . addAll ( _NUM , newNodes ) ; } else { if ( ( nodes . size ( ) > _NUM ) && newNodes . get ( _NUM ) == nodes . get ( nodes . size ( ) - _NUM ) ) { Log . i ( DEBUG_TAG , STRING ) ; if ( newNodes . size ( ) > _NUM ) { Log . i ( DEBUG_TAG , STRING ) ; newNodes . remove ( _NUM ) ; addNodes ( newNodes , atBeginning ) ; } return ; } nodes . addAll ( newNodes ) ; } }
public static ExampleFormatter compile ( String formatString , ExampleSet exampleSet , int fractionDigits , boolean quoteWhitespace ) throws FormatterException { List < FormatCommand > commandList = new LinkedList < FormatCommand > ( ) ; compile ( formatString , exampleSet , commandList , fractionDigits , quoteWhitespace ) ; FormatCommand [ ] commands = new FormatCommand [ commandList . size ( ) ] ; commandList . toArray ( commands ) ; return new ExampleFormatter ( commands ) ; }
public static ExampleFormatter compile ( String formatString , ExampleSet exampleSet , int fractionDigits , boolean quoteWhitespace ) throws FormatterException { List < FormatCommand > commandList = new LinkedList < FormatCommand > ( ) ; compile ( formatString , exampleSet , commandList , fractionDigits , quoteWhitespace ) ; FormatCommand [ ] commands = new FormatCommand [ commandList . size ( ) ] ; commandList . toArray ( commands ) ; return new ExampleFormatter ( commands ) ; }
public void addAll ( IVector v ) { expandFor ( size + v . size - _NUM , _NUM ) ; System . arraycopy ( v . vector , _NUM , vector , size - v . size , v . size ) ; }
public void addAll ( IVector v ) { expandFor ( size + v . size - _NUM , _NUM ) ; System . arraycopy ( v . vector , _NUM , vector , size - v . size , v . size ) ; }
public void addAll ( IVector v ) { expandFor ( size + v . size - _NUM , _NUM ) ; System . arraycopy ( v . vector , _NUM , vector , size - v . size , v . size ) ; }
public void addOpAuths ( final Class < ? extends Operation > opClass , final String ... auths ) { Set < String > opAuths = opAuthsMap . get ( opClass ) ; if ( null == opAuths ) { opAuths = new HashSet < > ( ) ; opAuthsMap . put ( opClass , opAuths ) ; } Collections . addAll ( opAuths , auths ) ; Collections . addAll ( allOpAuths , auths ) ; }
public void addOpAuths ( final Class < ? extends Operation > opClass , final String ... auths ) { Set < String > opAuths = opAuthsMap . get ( opClass ) ; if ( null == opAuths ) { opAuths = new HashSet < > ( ) ; opAuthsMap . put ( opClass , opAuths ) ; } Collections . addAll ( opAuths , auths ) ; Collections . addAll ( allOpAuths , auths ) ; }
public void addOpAuths ( final Class < ? extends Operation > opClass , final String ... auths ) { Set < String > opAuths = opAuthsMap . get ( opClass ) ; if ( null == opAuths ) { opAuths = new HashSet < > ( ) ; opAuthsMap . put ( opClass , opAuths ) ; } Collections . addAll ( opAuths , auths ) ; Collections . addAll ( allOpAuths , auths ) ; }
private List < ColumnModel > findColumnsToAdd ( ) { List < ColumnModel > columnsToAdd = new ArrayList < ColumnModel > ( ) ; for ( ColumnModel columnModel : mTableModel . getColumnModels ( ) ) { String columnName = columnModel . getColumnName ( ) ; if ( ! mTableModelDB . containsColumn ( columnName ) ) { columnsToAdd . add ( columnModel ) ; } } return columnsToAdd ; }
private List < ColumnModel > findColumnsToAdd ( ) { List < ColumnModel > columnsToAdd = new ArrayList < ColumnModel > ( ) ; for ( ColumnModel columnModel : mTableModel . getColumnModels ( ) ) { String columnName = columnModel . getColumnName ( ) ; if ( ! mTableModelDB . containsColumn ( columnName ) ) { columnsToAdd . add ( columnModel ) ; } } return columnsToAdd ; }
private List < ColumnModel > findColumnsToAdd ( ) { List < ColumnModel > columnsToAdd = new ArrayList < ColumnModel > ( ) ; for ( ColumnModel columnModel : mTableModel . getColumnModels ( ) ) { String columnName = columnModel . getColumnName ( ) ; if ( ! mTableModelDB . containsColumn ( columnName ) ) { columnsToAdd . add ( columnModel ) ; } } return columnsToAdd ; }
protected void initializeDataExtends ( Relation < NumberVector > relation , int dim , double [ ] min , double [ ] extend ) { assert ( min . length == dim && extend . length == dim ) ; if ( minima == null || maxima == null || minima . length == _NUM || maxima . length == _NUM ) { double [ ] [ ] minmax = RelationUtil . computeMinMax ( relation ) ; final double [ ] dmin = minmax [ _NUM ] , dmax = minmax [ _NUM ] ; for ( int d = _NUM ; d < dim ; d ++ ) { min [ d ] = dmin [ d ] ; extend [ d ] = dmax [ d ] - dmin [ d ] ; } return ; } if ( minima . length == dim ) { System . arraycopy ( minima , _NUM , min , _NUM , dim ) ; } else if ( minima . length == _NUM ) { Arrays . fill ( min , minima [ _NUM ] ) ; } else { throw new AbortException ( STRING + dim + STRING + minima . length ) ; } if ( maxima . length == dim ) { for ( int d = _NUM ; d < dim ; d ++ ) { extend [ d ] = maxima [ d ] - min [ d ] ; } return ; } else if ( maxima . length == _NUM ) { for ( int d = _NUM ; d < dim ; d ++ ) { extend [ d ] = maxima [ _NUM ] - min [ d ] ; } return ; } else { throw new AbortException ( STRING + dim + STRING + maxima . length ) ; } }
public void encode ( OutputStream out ) throws IOException { DerOutputStream tmp = new DerOutputStream ( ) ; if ( this . extensionValue == null ) { this . extensionId = PKIXExtensions . InvalidityDate_Id ; this . critical = _BOOL ; encodeThis ( ) ; } super . encode ( tmp ) ; out . write ( tmp . toByteArray ( ) ) ; }
public static void deleteByColumnValue ( final CConnection connection , final String tableName , final String columnName , final int columnValue ) throws CouldntDeleteException { Preconditions . checkNotNull ( connection , STRING ) ; Preconditions . checkNotNull ( tableName , STRING ) ; Preconditions . checkNotNull ( columnName , STRING ) ; Preconditions . checkArgument ( columnValue >= _NUM , STRING ) ; try { connection . executeUpdate ( String . format ( STRING , tableName , columnName , columnValue ) , _BOOL ) ; } catch ( final SQLException exception ) { throw new CouldntDeleteException ( exception ) ; } }
public static void deleteByColumnValue ( final CConnection connection , final String tableName , final String columnName , final int columnValue ) throws CouldntDeleteException { Preconditions . checkNotNull ( connection , STRING ) ; Preconditions . checkNotNull ( tableName , STRING ) ; Preconditions . checkNotNull ( columnName , STRING ) ; Preconditions . checkArgument ( columnValue >= _NUM , STRING ) ; try { connection . executeUpdate ( String . format ( STRING , tableName , columnName , columnValue ) , _BOOL ) ; } catch ( final SQLException exception ) { throw new CouldntDeleteException ( exception ) ; } }
private void addGeneratedJSResource ( FacesContext context , String resourceName , String library , UIViewRoot view ) { addGeneratedResource ( context , resourceName , STRING , library , view ) ; }
public S2Cap complement ( ) { double cHeight = isFull ( ) ? - _NUM : _NUM - Math . max ( height , _NUM ) ; return S2Cap . fromAxisHeight ( S2Point . neg ( axis ) , cHeight ) ; }
public S2Cap complement ( ) { double cHeight = isFull ( ) ? - _NUM : _NUM - Math . max ( height , _NUM ) ; return S2Cap . fromAxisHeight ( S2Point . neg ( axis ) , cHeight ) ; }
public S2Cap complement ( ) { double cHeight = isFull ( ) ? - _NUM : _NUM - Math . max ( height , _NUM ) ; return S2Cap . fromAxisHeight ( S2Point . neg ( axis ) , cHeight ) ; }
public S2Cap complement ( ) { double cHeight = isFull ( ) ? - _NUM : _NUM - Math . max ( height , _NUM ) ; return S2Cap . fromAxisHeight ( S2Point . neg ( axis ) , cHeight ) ; }
public S2Cap complement ( ) { double cHeight = isFull ( ) ? - _NUM : _NUM - Math . max ( height , _NUM ) ; return S2Cap . fromAxisHeight ( S2Point . neg ( axis ) , cHeight ) ; }
public static boolean isExtension ( String filename , String extension ) { if ( filename == null ) return _BOOL ; if ( extension == null || extension . length ( ) == _NUM ) return indexOfExtension ( filename ) == - _NUM ; String fileExt = getExtension ( filename ) ; return fileExt . equals ( extension ) ; }
public static boolean isExtension ( String filename , String extension ) { if ( filename == null ) return _BOOL ; if ( extension == null || extension . length ( ) == _NUM ) return indexOfExtension ( filename ) == - _NUM ; String fileExt = getExtension ( filename ) ; return fileExt . equals ( extension ) ; }
public static boolean isExtension ( String filename , String extension ) { if ( filename == null ) return _BOOL ; if ( extension == null || extension . length ( ) == _NUM ) return indexOfExtension ( filename ) == - _NUM ; String fileExt = getExtension ( filename ) ; return fileExt . equals ( extension ) ; }
public static boolean isExtension ( String filename , String extension ) { if ( filename == null ) return _BOOL ; if ( extension == null || extension . length ( ) == _NUM ) return indexOfExtension ( filename ) == - _NUM ; String fileExt = getExtension ( filename ) ; return fileExt . equals ( extension ) ; }
public static boolean isExtension ( String filename , String extension ) { if ( filename == null ) return _BOOL ; if ( extension == null || extension . length ( ) == _NUM ) return indexOfExtension ( filename ) == - _NUM ; String fileExt = getExtension ( filename ) ; return fileExt . equals ( extension ) ; }
public Cloudlet ( final int cloudletId , final long cloudletLength , final int pesNumber , final long cloudletFileSize , final long cloudletOutputSize , final UtilizationModel utilizationModelCpu , final UtilizationModel utilizationModelRam , final UtilizationModel utilizationModelBw , final boolean record ) { userId = - _NUM ; status = CREATED ; this . cloudletId = cloudletId ; numberOfPes = pesNumber ; execStartTime = _NUM ; finishTime = - _NUM ; classType = _NUM ; netToS = _NUM ; this . cloudletLength = Math . max ( _NUM , cloudletLength ) ; this . cloudletFileSize = Math . max ( _NUM , cloudletFileSize ) ; this . cloudletOutputSize = Math . max ( _NUM , cloudletOutputSize ) ; resList = new ArrayList < Resource > ( _NUM ) ; index = - _NUM ; this . record = record ; vmId = - _NUM ; accumulatedBwCost = _NUM ; costPerBw = _NUM ; requiredFiles = new LinkedList < String > ( ) ; setUtilizationModelCpu ( utilizationModelCpu ) ; setUtilizationModelRam ( utilizationModelRam ) ; setUtilizationModelBw ( utilizationModelBw ) ; }
private void applyUseSchema ( String schema ) throws SQLException { boolean schemaSet = _BOOL ; if ( schema != null && schema . length ( ) > _NUM && ! schema . equals ( this . currentSchema ) ) { currentSchema = schema ; if ( conn . supportsUseDefaultSchema ( ) ) { String useQuery = conn . getUseSchemaQuery ( schema ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + useQuery ) ; } statement . addBatch ( useQuery ) ; schemaSet = _BOOL ; } } if ( ! schemaSet ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + schema + STRING + currentSchema ) ; } } }
private void applyUseSchema ( String schema ) throws SQLException { boolean schemaSet = _BOOL ; if ( schema != null && schema . length ( ) > _NUM && ! schema . equals ( this . currentSchema ) ) { currentSchema = schema ; if ( conn . supportsUseDefaultSchema ( ) ) { String useQuery = conn . getUseSchemaQuery ( schema ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + useQuery ) ; } statement . addBatch ( useQuery ) ; schemaSet = _BOOL ; } } if ( ! schemaSet ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + schema + STRING + currentSchema ) ; } } }
private void applyUseSchema ( String schema ) throws SQLException { boolean schemaSet = _BOOL ; if ( schema != null && schema . length ( ) > _NUM && ! schema . equals ( this . currentSchema ) ) { currentSchema = schema ; if ( conn . supportsUseDefaultSchema ( ) ) { String useQuery = conn . getUseSchemaQuery ( schema ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + useQuery ) ; } statement . addBatch ( useQuery ) ; schemaSet = _BOOL ; } } if ( ! schemaSet ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + schema + STRING + currentSchema ) ; } } }
private void applyUseSchema ( String schema ) throws SQLException { boolean schemaSet = _BOOL ; if ( schema != null && schema . length ( ) > _NUM && ! schema . equals ( this . currentSchema ) ) { currentSchema = schema ; if ( conn . supportsUseDefaultSchema ( ) ) { String useQuery = conn . getUseSchemaQuery ( schema ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + useQuery ) ; } statement . addBatch ( useQuery ) ; schemaSet = _BOOL ; } } if ( ! schemaSet ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + schema + STRING + currentSchema ) ; } } }
private void applyUseSchema ( String schema ) throws SQLException { boolean schemaSet = _BOOL ; if ( schema != null && schema . length ( ) > _NUM && ! schema . equals ( this . currentSchema ) ) { currentSchema = schema ; if ( conn . supportsUseDefaultSchema ( ) ) { String useQuery = conn . getUseSchemaQuery ( schema ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + useQuery ) ; } statement . addBatch ( useQuery ) ; schemaSet = _BOOL ; } } if ( ! schemaSet ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + schema + STRING + currentSchema ) ; } } }
public DropDownPopupButtonBuilder add ( JMenuItem item ) { popupMenu . add ( item ) ; return this ; }
public DropDownPopupButtonBuilder add ( JMenuItem item ) { popupMenu . add ( item ) ; return this ; }
public Builder deleteNickName ( ) { deleteFields . add ( STRING ) ; return this ; }
public static QueryTask waitForQuery ( ServiceHost host , String referrer , QueryTask query , Predicate < QueryTask > predicate , long waitIterationCount , long waitIterationSleep ) throws Throwable { for ( int i = _NUM ; i < waitIterationCount ; i ++ ) { QueryTask result = sendQueryAndWait ( host , referrer , query ) ; if ( predicate . test ( result ) ) { return result ; } Thread . sleep ( waitIterationSleep ) ; } throw new RuntimeException ( STRING ) ; }
public static QueryTask waitForQuery ( ServiceHost host , String referrer , QueryTask query , Predicate < QueryTask > predicate , long waitIterationCount , long waitIterationSleep ) throws Throwable { for ( int i = _NUM ; i < waitIterationCount ; i ++ ) { QueryTask result = sendQueryAndWait ( host , referrer , query ) ; if ( predicate . test ( result ) ) { return result ; } Thread . sleep ( waitIterationSleep ) ; } throw new RuntimeException ( STRING ) ; }
boolean isValidScheme ( String scheme ) { for ( int i = _NUM ; i < scheme . length ( ) ; i ++ ) { char ch = scheme . charAt ( i ) ; if ( URIHelper . isAlpha ( ch ) || URIHelper . isNumeric ( ch ) || ch == STRING ) { continue ; } return _BOOL ; } return _BOOL ; }
boolean isValidScheme ( String scheme ) { for ( int i = _NUM ; i < scheme . length ( ) ; i ++ ) { char ch = scheme . charAt ( i ) ; if ( URIHelper . isAlpha ( ch ) || URIHelper . isNumeric ( ch ) || ch == STRING ) { continue ; } return _BOOL ; } return _BOOL ; }
boolean isValidScheme ( String scheme ) { for ( int i = _NUM ; i < scheme . length ( ) ; i ++ ) { char ch = scheme . charAt ( i ) ; if ( URIHelper . isAlpha ( ch ) || URIHelper . isNumeric ( ch ) || ch == STRING ) { continue ; } return _BOOL ; } return _BOOL ; }
private void digitsToWords ( WordRelation wordRelation , Item tokenItem , String tokenVal ) { FeatureSet featureSet = tokenItem . getFeatures ( ) ; String nsw = STRING ; if ( featureSet . isPresent ( STRING ) ) { nsw = featureSet . getString ( STRING ) ; } if ( nsw . equals ( STRING ) ) { NumberExpander . expandID ( tokenVal , wordRelation , tokenItem ) ; } else { String rName = featureSet . getString ( STRING ) ; String digitsType = null ; if ( tokenVal . equals ( rName ) ) { digitsType = ( String ) cart . interpret ( tokenItem ) ; } else { featureSet . setString ( STRING , tokenVal ) ; digitsType = ( String ) cart . interpret ( tokenItem ) ; featureSet . setString ( STRING , rName ) ; } if ( digitsType . equals ( STRING ) ) { NumberExpander . expandOrdinal ( tokenVal , wordRelation , tokenItem ) ; } else if ( digitsType . equals ( STRING ) ) { NumberExpander . expandDigits ( tokenVal , wordRelation , tokenItem ) ; } else if ( digitsType . equals ( STRING ) ) { NumberExpander . expandID ( tokenVal , wordRelation , tokenItem ) ; } else { NumberExpander . expandNumber ( tokenVal , wordRelation , tokenItem ) ; } } }
public static PrintWriter newPrintWriter ( Path self ) throws IOException { return new GroovyPrintWriter ( newWriter ( self ) ) ; }
private void destroyInternalSession ( SessionID sessionID ) { InternalSession sess = sessionAccessManager . removeInternalSession ( sessionID ) ; if ( sess != null && sess . getState ( ) != INVALID ) { signalRemove ( sess , SessionEventType . DESTROY ) ; sessionAuditor . auditActivity ( sess . toSessionInfo ( ) , AM_SESSION_DESTROYED ) ; } sessionAccessManager . removeSessionId ( sessionID ) ; }
public Set < Resource > findSameAs ( Resource value , Resource ... contxts ) throws InferenceEngineException { Set < Resource > sameAs = new HashSet < Resource > ( ) ; sameAs . add ( value ) ; findSameAsChaining ( value , sameAs , contxts ) ; return sameAs ; }
public Set < Resource > findSameAs ( Resource value , Resource ... contxts ) throws InferenceEngineException { Set < Resource > sameAs = new HashSet < Resource > ( ) ; sameAs . add ( value ) ; findSameAsChaining ( value , sameAs , contxts ) ; return sameAs ; }
public Set < Resource > findSameAs ( Resource value , Resource ... contxts ) throws InferenceEngineException { Set < Resource > sameAs = new HashSet < Resource > ( ) ; sameAs . add ( value ) ; findSameAsChaining ( value , sameAs , contxts ) ; return sameAs ; }
public Set < Resource > findSameAs ( Resource value , Resource ... contxts ) throws InferenceEngineException { Set < Resource > sameAs = new HashSet < Resource > ( ) ; sameAs . add ( value ) ; findSameAsChaining ( value , sameAs , contxts ) ; return sameAs ; }
public Set < Resource > findSameAs ( Resource value , Resource ... contxts ) throws InferenceEngineException { Set < Resource > sameAs = new HashSet < Resource > ( ) ; sameAs . add ( value ) ; findSameAsChaining ( value , sameAs , contxts ) ; return sameAs ; }
public Set < Resource > findSameAs ( Resource value , Resource ... contxts ) throws InferenceEngineException { Set < Resource > sameAs = new HashSet < Resource > ( ) ; sameAs . add ( value ) ; findSameAsChaining ( value , sameAs , contxts ) ; return sameAs ; }
public Set < Resource > findSameAs ( Resource value , Resource ... contxts ) throws InferenceEngineException { Set < Resource > sameAs = new HashSet < Resource > ( ) ; sameAs . add ( value ) ; findSameAsChaining ( value , sameAs , contxts ) ; return sameAs ; }
public HashedBlockOutputStream ( OutputStream outputStream ) { this ( outputStream , _BOOL ) ; }
public int read ( ) throws java . io . IOException { synchronized ( lock ) { char charArray [ ] = new char [ _NUM ] ; if ( read ( charArray , _NUM , _NUM ) != - _NUM ) { return charArray [ _NUM ] ; } return - _NUM ; } }
public int read ( ) throws java . io . IOException { synchronized ( lock ) { char charArray [ ] = new char [ _NUM ] ; if ( read ( charArray , _NUM , _NUM ) != - _NUM ) { return charArray [ _NUM ] ; } return - _NUM ; } }
public int read ( ) throws java . io . IOException { synchronized ( lock ) { char charArray [ ] = new char [ _NUM ] ; if ( read ( charArray , _NUM , _NUM ) != - _NUM ) { return charArray [ _NUM ] ; } return - _NUM ; } }
public int read ( ) throws java . io . IOException { synchronized ( lock ) { char charArray [ ] = new char [ _NUM ] ; if ( read ( charArray , _NUM , _NUM ) != - _NUM ) { return charArray [ _NUM ] ; } return - _NUM ; } }
public int read ( ) throws java . io . IOException { synchronized ( lock ) { char charArray [ ] = new char [ _NUM ] ; if ( read ( charArray , _NUM , _NUM ) != - _NUM ) { return charArray [ _NUM ] ; } return - _NUM ; } }
public void connectionOpen ( ) { lock . lock ( ) ; try { log . info ( STRING ) ; connectionOpen = _BOOL ; } finally { lock . unlock ( ) ; } }
public void connectionOpen ( ) { lock . lock ( ) ; try { log . info ( STRING ) ; connectionOpen = _BOOL ; } finally { lock . unlock ( ) ; } }
private static int checkNumericZone ( String s ) throws UnknownHostException { int percent = s . indexOf ( STRING ) ; int slen = s . length ( ) ; int digit , zone = _NUM ; if ( percent == - _NUM ) { return - _NUM ; } for ( int i = percent + _NUM ; i < slen ; i ++ ) { char c = s . charAt ( i ) ; if ( c == STRING ) { if ( i == percent + _NUM ) { return - _NUM ; } break ; } if ( ( digit = Character . digit ( c , _NUM ) ) < _NUM ) { return - _NUM ; } zone = ( zone * _NUM ) + digit ; } return zone ; }
private static int checkNumericZone ( String s ) throws UnknownHostException { int percent = s . indexOf ( STRING ) ; int slen = s . length ( ) ; int digit , zone = _NUM ; if ( percent == - _NUM ) { return - _NUM ; } for ( int i = percent + _NUM ; i < slen ; i ++ ) { char c = s . charAt ( i ) ; if ( c == STRING ) { if ( i == percent + _NUM ) { return - _NUM ; } break ; } if ( ( digit = Character . digit ( c , _NUM ) ) < _NUM ) { return - _NUM ; } zone = ( zone * _NUM ) + digit ; } return zone ; }
private static int checkNumericZone ( String s ) throws UnknownHostException { int percent = s . indexOf ( STRING ) ; int slen = s . length ( ) ; int digit , zone = _NUM ; if ( percent == - _NUM ) { return - _NUM ; } for ( int i = percent + _NUM ; i < slen ; i ++ ) { char c = s . charAt ( i ) ; if ( c == STRING ) { if ( i == percent + _NUM ) { return - _NUM ; } break ; } if ( ( digit = Character . digit ( c , _NUM ) ) < _NUM ) { return - _NUM ; } zone = ( zone * _NUM ) + digit ; } return zone ; }
private static int checkNumericZone ( String s ) throws UnknownHostException { int percent = s . indexOf ( STRING ) ; int slen = s . length ( ) ; int digit , zone = _NUM ; if ( percent == - _NUM ) { return - _NUM ; } for ( int i = percent + _NUM ; i < slen ; i ++ ) { char c = s . charAt ( i ) ; if ( c == STRING ) { if ( i == percent + _NUM ) { return - _NUM ; } break ; } if ( ( digit = Character . digit ( c , _NUM ) ) < _NUM ) { return - _NUM ; } zone = ( zone * _NUM ) + digit ; } return zone ; }
public void updateTeamTalentRatings ( ) { for ( Team t : teamList ) { t . updateTalentRatings ( ) ; } }
public VacuumEnvironment ( ) { Random r = new Random ( ) ; envState = new VacuumEnvironmentState ( _NUM == r . nextInt ( _NUM ) ? LocationState . Clean : LocationState . Dirty , _NUM == r . nextInt ( _NUM ) ? LocationState . Clean : LocationState . Dirty ) ; }
public VacuumEnvironment ( ) { Random r = new Random ( ) ; envState = new VacuumEnvironmentState ( _NUM == r . nextInt ( _NUM ) ? LocationState . Clean : LocationState . Dirty , _NUM == r . nextInt ( _NUM ) ? LocationState . Clean : LocationState . Dirty ) ; }
public JrmpGenerator ( ) { }
public TextUnit createTextUnit ( Long id , String name , String source , String note , String target , String targetBcp47Tag , XliffState state ) { TextUnit textUnit = new TextUnit ( id . toString ( ) , source ) ; textUnit . setName ( name ) ; if ( note != null ) { textUnit . setSourceProperty ( new Property ( Property . NOTE , note ) ) ; } if ( target != null && targetBcp47Tag != null ) { LocaleId localeId = LocaleId . fromBCP47 ( targetBcp47Tag ) ; textUnit . setTarget ( localeId , new TextContainer ( target ) ) ; if ( state != null ) { textUnit . setProperty ( new Property ( STRING , state . toString ( ) ) ) ; } } return textUnit ; }
public TextUnit createTextUnit ( Long id , String name , String source , String note , String target , String targetBcp47Tag , XliffState state ) { TextUnit textUnit = new TextUnit ( id . toString ( ) , source ) ; textUnit . setName ( name ) ; if ( note != null ) { textUnit . setSourceProperty ( new Property ( Property . NOTE , note ) ) ; } if ( target != null && targetBcp47Tag != null ) { LocaleId localeId = LocaleId . fromBCP47 ( targetBcp47Tag ) ; textUnit . setTarget ( localeId , new TextContainer ( target ) ) ; if ( state != null ) { textUnit . setProperty ( new Property ( STRING , state . toString ( ) ) ) ; } } return textUnit ; }
public TextUnit createTextUnit ( Long id , String name , String source , String note , String target , String targetBcp47Tag , XliffState state ) { TextUnit textUnit = new TextUnit ( id . toString ( ) , source ) ; textUnit . setName ( name ) ; if ( note != null ) { textUnit . setSourceProperty ( new Property ( Property . NOTE , note ) ) ; } if ( target != null && targetBcp47Tag != null ) { LocaleId localeId = LocaleId . fromBCP47 ( targetBcp47Tag ) ; textUnit . setTarget ( localeId , new TextContainer ( target ) ) ; if ( state != null ) { textUnit . setProperty ( new Property ( STRING , state . toString ( ) ) ) ; } } return textUnit ; }
public TextUnit createTextUnit ( Long id , String name , String source , String note , String target , String targetBcp47Tag , XliffState state ) { TextUnit textUnit = new TextUnit ( id . toString ( ) , source ) ; textUnit . setName ( name ) ; if ( note != null ) { textUnit . setSourceProperty ( new Property ( Property . NOTE , note ) ) ; } if ( target != null && targetBcp47Tag != null ) { LocaleId localeId = LocaleId . fromBCP47 ( targetBcp47Tag ) ; textUnit . setTarget ( localeId , new TextContainer ( target ) ) ; if ( state != null ) { textUnit . setProperty ( new Property ( STRING , state . toString ( ) ) ) ; } } return textUnit ; }
private void writeNewlineOnDebug ( XMLStreamWriter out ) throws XMLStreamException { if ( LOG . isDebugging ( ) ) { out . writeCharacters ( STRING ) ; } }
public void message ( LocoNetMessage m ) { if ( m . getNumDataElements ( ) != _NUM ) { return ; } int b1 = m . getElement ( _NUM ) & _NUM ; int b2 = m . getElement ( _NUM ) & _NUM ; int b3 = m . getElement ( _NUM ) & _NUM ; int b4 = m . getElement ( _NUM ) & _NUM ; if ( ( b1 == _NUM ) && ( ( b2 == _NUM ) || ( b2 == _NUM ) || ( b2 == _NUM ) ) && ( b3 == _NUM ) ) { idBox . setSelectedIndex ( b4 + _NUM ) ; } }
public void message ( LocoNetMessage m ) { if ( m . getNumDataElements ( ) != _NUM ) { return ; } int b1 = m . getElement ( _NUM ) & _NUM ; int b2 = m . getElement ( _NUM ) & _NUM ; int b3 = m . getElement ( _NUM ) & _NUM ; int b4 = m . getElement ( _NUM ) & _NUM ; if ( ( b1 == _NUM ) && ( ( b2 == _NUM ) || ( b2 == _NUM ) || ( b2 == _NUM ) ) && ( b3 == _NUM ) ) { idBox . setSelectedIndex ( b4 + _NUM ) ; } }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) return _BOOL ; if ( obj == null ) return _BOOL ; if ( getClass ( ) != obj . getClass ( ) ) return _BOOL ; AttachmentPoint other = ( AttachmentPoint ) obj ; if ( port != other . port ) return _BOOL ; if ( sw != other . sw ) return _BOOL ; return _BOOL ; }
public void clear ( ) { infoQueue . clear ( ) ; while ( ! dataQueue . isEmpty ( ) ) { allocator . release ( dataQueue . remove ( ) ) ; } totalBytesDropped = _NUM ; totalBytesWritten = _NUM ; lastAllocation = null ; lastAllocationOffset = allocationLength ; }
public void clear ( ) { infoQueue . clear ( ) ; while ( ! dataQueue . isEmpty ( ) ) { allocator . release ( dataQueue . remove ( ) ) ; } totalBytesDropped = _NUM ; totalBytesWritten = _NUM ; lastAllocation = null ; lastAllocationOffset = allocationLength ; }
public static String unHide ( final String key ) { return isHidden ( key ) ? key . substring ( HIDDEN_PREFIX_LENGTH ) : key ; }
public void testCreateDocumentType1 ( ) throws Throwable { Document doc ; DOMImplementation domImpl ; DocumentType newDocType ; Document ownerDocument ; String qualifiedName = STRING ; String publicId ; String systemId ; List < String > publicIds = new ArrayList < String > ( ) ; publicIds . add ( STRING ) ; publicIds . add ( STRING ) ; List < String > systemIds = new ArrayList < String > ( ) ; systemIds . add ( STRING ) ; systemIds . add ( STRING ) ; doc = ( Document ) load ( STRING , builder ) ; domImpl = doc . getImplementation ( ) ; for ( int indexN1005D = _NUM ; indexN1005D < publicIds . size ( ) ; indexN1005D ++ ) { publicId = ( String ) publicIds . get ( indexN1005D ) ; for ( int indexN10061 = _NUM ; indexN10061 < systemIds . size ( ) ; indexN10061 ++ ) { systemId = ( String ) systemIds . get ( indexN10061 ) ; newDocType = domImpl . createDocumentType ( qualifiedName , publicId , systemId ) ; assertNotNull ( STRING , newDocType ) ; ownerDocument = newDocType . getOwnerDocument ( ) ; assertNull ( STRING , ownerDocument ) ; } } }
private ClassVertex resolveClassVertex ( ClassDescriptor classDescriptor ) throws ClassNotFoundException { ClassVertex typeVertex = optionallyResolveClassVertex ( classDescriptor ) ; if ( ! typeVertex . isResolved ( ) ) { ClassDescriptor . throwClassNotFoundException ( classDescriptor ) ; } assert typeVertex . isResolved ( ) ; return typeVertex ; }
protected void paintContentBorderBottomEdge ( Graphics g , int x , int y , int w , int h , boolean drawBroken , Rectangle selRect , boolean isContentBorderPainted ) { if ( isContentBorderPainted ) { g . setColor ( darkShadow ) ; g . fillRect ( x , y + h - _NUM , w - _NUM , _NUM ) ; } }
public static String sha1 ( final String string ) throws NoSuchAlgorithmException { final MessageDigest digest = MessageDigest . getInstance ( STRING ) ; digest . reset ( ) ; final byte [ ] data = digest . digest ( string . getBytes ( ) ) ; return String . format ( STRING + ( data . length * _NUM ) + STRING , new BigInteger ( _NUM , data ) ) ; }
void constructNode ( String nodeName , String prefix , String nodeNamespace , TransformerImpl transformer ) throws TransformerException { boolean shouldAddAttrs ; try { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; if ( null == nodeName ) { shouldAddAttrs = _BOOL ; } else { if ( null != prefix ) { rhandler . startPrefixMapping ( prefix , nodeNamespace , _BOOL ) ; } rhandler . startElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; super . execute ( transformer ) ; shouldAddAttrs = _BOOL ; } transformer . executeChildTemplates ( this , shouldAddAttrs ) ; if ( null != nodeName ) { rhandler . endElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; if ( null != prefix ) { rhandler . endPrefixMapping ( prefix ) ; } } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } }
void constructNode ( String nodeName , String prefix , String nodeNamespace , TransformerImpl transformer ) throws TransformerException { boolean shouldAddAttrs ; try { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; if ( null == nodeName ) { shouldAddAttrs = _BOOL ; } else { if ( null != prefix ) { rhandler . startPrefixMapping ( prefix , nodeNamespace , _BOOL ) ; } rhandler . startElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; super . execute ( transformer ) ; shouldAddAttrs = _BOOL ; } transformer . executeChildTemplates ( this , shouldAddAttrs ) ; if ( null != nodeName ) { rhandler . endElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; if ( null != prefix ) { rhandler . endPrefixMapping ( prefix ) ; } } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } }
void constructNode ( String nodeName , String prefix , String nodeNamespace , TransformerImpl transformer ) throws TransformerException { boolean shouldAddAttrs ; try { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; if ( null == nodeName ) { shouldAddAttrs = _BOOL ; } else { if ( null != prefix ) { rhandler . startPrefixMapping ( prefix , nodeNamespace , _BOOL ) ; } rhandler . startElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; super . execute ( transformer ) ; shouldAddAttrs = _BOOL ; } transformer . executeChildTemplates ( this , shouldAddAttrs ) ; if ( null != nodeName ) { rhandler . endElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; if ( null != prefix ) { rhandler . endPrefixMapping ( prefix ) ; } } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } }
void constructNode ( String nodeName , String prefix , String nodeNamespace , TransformerImpl transformer ) throws TransformerException { boolean shouldAddAttrs ; try { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; if ( null == nodeName ) { shouldAddAttrs = _BOOL ; } else { if ( null != prefix ) { rhandler . startPrefixMapping ( prefix , nodeNamespace , _BOOL ) ; } rhandler . startElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; super . execute ( transformer ) ; shouldAddAttrs = _BOOL ; } transformer . executeChildTemplates ( this , shouldAddAttrs ) ; if ( null != nodeName ) { rhandler . endElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; if ( null != prefix ) { rhandler . endPrefixMapping ( prefix ) ; } } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } }
void constructNode ( String nodeName , String prefix , String nodeNamespace , TransformerImpl transformer ) throws TransformerException { boolean shouldAddAttrs ; try { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; if ( null == nodeName ) { shouldAddAttrs = _BOOL ; } else { if ( null != prefix ) { rhandler . startPrefixMapping ( prefix , nodeNamespace , _BOOL ) ; } rhandler . startElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; super . execute ( transformer ) ; shouldAddAttrs = _BOOL ; } transformer . executeChildTemplates ( this , shouldAddAttrs ) ; if ( null != nodeName ) { rhandler . endElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; if ( null != prefix ) { rhandler . endPrefixMapping ( prefix ) ; } } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } }
void constructNode ( String nodeName , String prefix , String nodeNamespace , TransformerImpl transformer ) throws TransformerException { boolean shouldAddAttrs ; try { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; if ( null == nodeName ) { shouldAddAttrs = _BOOL ; } else { if ( null != prefix ) { rhandler . startPrefixMapping ( prefix , nodeNamespace , _BOOL ) ; } rhandler . startElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; super . execute ( transformer ) ; shouldAddAttrs = _BOOL ; } transformer . executeChildTemplates ( this , shouldAddAttrs ) ; if ( null != nodeName ) { rhandler . endElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; if ( null != prefix ) { rhandler . endPrefixMapping ( prefix ) ; } } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } }
public ExtendedErrorDialog ( Window owner , String key , String errorMessage , Object ... arguments ) { super ( owner , STRING + key , ModalityType . APPLICATION_MODAL , arguments ) ; boolean hasError = errorMessage != null && ! errorMessage . isEmpty ( ) ; JScrollPane detailedPane = hasError ? createDetailPanel ( errorMessage ) : null ; layoutDefault ( mainComponent , SIZE , getButtons ( hasError , _BOOL , detailedPane , null ) ) ; }
public static short parseShort ( java . lang . String s ) throws java . lang . NumberFormatException { return ( short ) Integer . parseInt ( s ) ; }
public static short parseShort ( java . lang . String s ) throws java . lang . NumberFormatException { return ( short ) Integer . parseInt ( s ) ; }
public static short parseShort ( java . lang . String s ) throws java . lang . NumberFormatException { return ( short ) Integer . parseInt ( s ) ; }
public static short parseShort ( java . lang . String s ) throws java . lang . NumberFormatException { return ( short ) Integer . parseInt ( s ) ; }
public void addChildFrame ( Container c ) { m_ChildFrames . add ( c ) ; }
protected double [ ] rhumbProjectDouble ( Point2D from , Point2D to , boolean include_last , int nsegs ) { if ( nsegs < _NUM ) { nsegs = DrawUtil . pixel_distance ( ( int ) from . getX ( ) , ( int ) from . getY ( ) , ( int ) to . getX ( ) , ( int ) to . getY ( ) ) > > _NUM ; if ( nsegs == _NUM ) nsegs = _NUM ; else if ( nsegs > MAX_RHUMB_SEGS ) nsegs = MAX_RHUMB_SEGS ; } LatLonPoint llp = new LatLonPoint . Double ( ) ; int [ ] xypts = DrawUtil . lineSegments ( ( int ) from . getX ( ) , ( int ) from . getY ( ) , ( int ) to . getX ( ) , ( int ) to . getY ( ) , nsegs , include_last , new int [ nsegs << _NUM ] ) ; double [ ] llpts = new double [ xypts . length ] ; for ( int i = _NUM ; i < llpts . length ; i += _NUM ) { inverse ( xypts [ i ] , xypts [ i + _NUM ] , llp ) ; llpts [ i ] = llp . getRadLat ( ) ; llpts [ i + _NUM ] = llp . getRadLon ( ) ; } return llpts ; }
protected double [ ] rhumbProjectDouble ( Point2D from , Point2D to , boolean include_last , int nsegs ) { if ( nsegs < _NUM ) { nsegs = DrawUtil . pixel_distance ( ( int ) from . getX ( ) , ( int ) from . getY ( ) , ( int ) to . getX ( ) , ( int ) to . getY ( ) ) > > _NUM ; if ( nsegs == _NUM ) nsegs = _NUM ; else if ( nsegs > MAX_RHUMB_SEGS ) nsegs = MAX_RHUMB_SEGS ; } LatLonPoint llp = new LatLonPoint . Double ( ) ; int [ ] xypts = DrawUtil . lineSegments ( ( int ) from . getX ( ) , ( int ) from . getY ( ) , ( int ) to . getX ( ) , ( int ) to . getY ( ) , nsegs , include_last , new int [ nsegs << _NUM ] ) ; double [ ] llpts = new double [ xypts . length ] ; for ( int i = _NUM ; i < llpts . length ; i += _NUM ) { inverse ( xypts [ i ] , xypts [ i + _NUM ] , llp ) ; llpts [ i ] = llp . getRadLat ( ) ; llpts [ i + _NUM ] = llp . getRadLon ( ) ; } return llpts ; }
protected String formatDate ( Date d ) { try { synchronized ( timeFormatter ) { return timeFormatter . format ( d ) ; } } catch ( Exception e1 ) { try { return d . toString ( ) ; } catch ( Exception e2 ) { try { return Long . toString ( d . getTime ( ) ) ; } catch ( Exception e3 ) { return STRING ; } } } }
public void close ( ) throws IOException { mOutputStream . close ( ) ; }
private void $$$setupUI$$$ ( ) { contentPane = new JPanel ( ) ; contentPane . setLayout ( new BorderLayout ( _NUM , _NUM ) ) ; splitPane = new JSplitPane ( ) ; contentPane . add ( splitPane , BorderLayout . CENTER ) ; final JScrollPane scrollPane1 = new JScrollPane ( ) ; splitPane . setLeftComponent ( scrollPane1 ) ; methodList = new JList ( ) ; scrollPane1 . setViewportView ( methodList ) ; final JScrollPane scrollPane2 = new JScrollPane ( ) ; splitPane . setRightComponent ( scrollPane2 ) ; methodDetailTable = new JTable ( ) ; scrollPane2 . setViewportView ( methodDetailTable ) ; }
private double [ ] extend ( double [ ] array , double value ) { double [ ] result = null ; if ( array == null ) { result = new double [ _NUM ] ; } else { result = Arrays . copyOf ( array , array . length + _NUM ) ; } result [ result . length - _NUM ] = value ; return result ; }
private double [ ] extend ( double [ ] array , double value ) { double [ ] result = null ; if ( array == null ) { result = new double [ _NUM ] ; } else { result = Arrays . copyOf ( array , array . length + _NUM ) ; } result [ result . length - _NUM ] = value ; return result ; }
private static MetricValue number_to_metric_value_ ( Number elem ) { if ( elem == null ) return MetricValue . EMPTY ; final String num = elem . toString ( ) ; try { return MetricValue . fromIntValue ( Long . parseLong ( num ) ) ; } catch ( NumberFormatException ex ) { } try { return MetricValue . fromDblValue ( Double . parseDouble ( num ) ) ; } catch ( NumberFormatException ex ) { } return MetricValue . fromStrValue ( num ) ; }
public byte [ ] createImage ( Projection proj , int scaledWidth , int scaledHeight , int includedLayerMask ) { return createImage ( proj , scaledWidth , scaledHeight , includedLayerMask , getBackground ( ) ) ; }
public byte [ ] createImage ( Projection proj , int scaledWidth , int scaledHeight , int includedLayerMask ) { return createImage ( proj , scaledWidth , scaledHeight , includedLayerMask , getBackground ( ) ) ; }
public byte [ ] createImage ( Projection proj , int scaledWidth , int scaledHeight , int includedLayerMask ) { return createImage ( proj , scaledWidth , scaledHeight , includedLayerMask , getBackground ( ) ) ; }
public byte [ ] createImage ( Projection proj , int scaledWidth , int scaledHeight , int includedLayerMask ) { return createImage ( proj , scaledWidth , scaledHeight , includedLayerMask , getBackground ( ) ) ; }
public byte [ ] createImage ( Projection proj , int scaledWidth , int scaledHeight , int includedLayerMask ) { return createImage ( proj , scaledWidth , scaledHeight , includedLayerMask , getBackground ( ) ) ; }
public byte [ ] createImage ( Projection proj , int scaledWidth , int scaledHeight , int includedLayerMask ) { return createImage ( proj , scaledWidth , scaledHeight , includedLayerMask , getBackground ( ) ) ; }
public byte [ ] createImage ( Projection proj , int scaledWidth , int scaledHeight , int includedLayerMask ) { return createImage ( proj , scaledWidth , scaledHeight , includedLayerMask , getBackground ( ) ) ; }
public static String concatenateRealmPath ( String parentRealm , String subrealm ) { String realm ; if ( subrealm == null ) { realm = parentRealm ; } else { subrealm = cleanRealm ( subrealm ) ; if ( parentRealm == null || parentRealm . equals ( STRING ) ) { realm = subrealm ; } else { realm = parentRealm + subrealm ; } } return cleanRealm ( realm ) ; }
public static String concatenateRealmPath ( String parentRealm , String subrealm ) { String realm ; if ( subrealm == null ) { realm = parentRealm ; } else { subrealm = cleanRealm ( subrealm ) ; if ( parentRealm == null || parentRealm . equals ( STRING ) ) { realm = subrealm ; } else { realm = parentRealm + subrealm ; } } return cleanRealm ( realm ) ; }
public boolean addAll ( NamedList < T > nl ) { nvPairs . addAll ( nl . nvPairs ) ; return nl . size ( ) > _NUM ; }
@ SafeVarargs public static < V > Set < V > createSet ( V ... values ) { Set < V > set = new LinkedHashSet < V > ( ) ; for ( V v : values ) { set . add ( v ) ; } return set ; }
public static void appendHexJavaScriptRepresentation ( StringBuilder sb , char c ) { sb . append ( STRING ) ; String val = Integer . toHexString ( c ) ; for ( int j = val . length ( ) ; j < _NUM ; j ++ ) { sb . append ( STRING ) ; } sb . append ( val ) ; }
void error ( String key , String arg1 , String arg2 ) throws SAXException { hadError = _BOOL ; if ( eh == null ) return ; eh . error ( new SAXParseException ( localizer . message ( key , arg1 , arg2 ) , locator ) ) ; }
public void addListener ( @ NotNull SelectionChangeListener listener ) { listeners . add ( listener ) ; }
private void writeObject ( ObjectOutputStream out ) throws IOException { out . defaultWriteObject ( ) ; serviceID . writeBytes ( out ) ; }
private void writeObject ( ObjectOutputStream out ) throws IOException { out . defaultWriteObject ( ) ; serviceID . writeBytes ( out ) ; }
public double findMinimum ( UnivariateFunction f , int fracDigits ) { double tol = Math . pow ( _NUM , - _NUM - fracDigits ) ; final double optx = optimize ( f , tol ) ; return optx ; }
public SequenceElement parse ( InputStream stream ) throws IOException , SAXException , ParserConfigurationException { return parse ( stream , STRING ) ; }
public SequenceElement parse ( InputStream stream ) throws IOException , SAXException , ParserConfigurationException { return parse ( stream , STRING ) ; }
private void ensureCapacity ( int unitsRequired ) { if ( bits . length < unitsRequired ) { int request = Math . max ( _NUM * bits . length , unitsRequired ) ; long [ ] newBits = new long [ request ] ; System . arraycopy ( bits , _NUM , newBits , _NUM , unitsInUse ) ; bits = newBits ; } }
private void ensureCapacity ( int unitsRequired ) { if ( bits . length < unitsRequired ) { int request = Math . max ( _NUM * bits . length , unitsRequired ) ; long [ ] newBits = new long [ request ] ; System . arraycopy ( bits , _NUM , newBits , _NUM , unitsInUse ) ; bits = newBits ; } }
public void fitCanvas ( ) { if ( sourceImage == null ) return ; Rectangle imageBound = sourceImage . getBounds ( ) ; Rectangle destRect = getClientArea ( ) ; double sx = ( double ) destRect . width / ( double ) imageBound . width ; double sy = ( double ) destRect . height / ( double ) imageBound . height ; double s = Math . min ( sx , sy ) ; double dx = _NUM * destRect . width ; double dy = _NUM * destRect . height ; centerZoom ( dx , dy , s , new AffineTransform ( ) ) ; }
public boolean add ( int value ) { int index = value % this . numBuckets ; Bucket bucket = this . buckets [ index ] ; if ( bucket == null ) { bucket = this . buckets [ index ] = new Bucket ( this . bucketInitialCapacity ) ; } else { for ( int i = _NUM ; i < bucket . length ; i ++ ) { if ( bucket . values [ i ] == value ) return _BOOL ; } } if ( bucket . values . length <= bucket . length ) { int [ ] tmp = new int [ _NUM * bucket . values . length ] ; System . arraycopy ( bucket . values , _NUM , tmp , _NUM , bucket . values . length ) ; bucket . values = tmp ; } bucket . values [ bucket . length ++ ] = value ; this . size ++ ; return _BOOL ; }
public boolean add ( int value ) { int index = value % this . numBuckets ; Bucket bucket = this . buckets [ index ] ; if ( bucket == null ) { bucket = this . buckets [ index ] = new Bucket ( this . bucketInitialCapacity ) ; } else { for ( int i = _NUM ; i < bucket . length ; i ++ ) { if ( bucket . values [ i ] == value ) return _BOOL ; } } if ( bucket . values . length <= bucket . length ) { int [ ] tmp = new int [ _NUM * bucket . values . length ] ; System . arraycopy ( bucket . values , _NUM , tmp , _NUM , bucket . values . length ) ; bucket . values = tmp ; } bucket . values [ bucket . length ++ ] = value ; this . size ++ ; return _BOOL ; }
public boolean add ( int value ) { int index = value % this . numBuckets ; Bucket bucket = this . buckets [ index ] ; if ( bucket == null ) { bucket = this . buckets [ index ] = new Bucket ( this . bucketInitialCapacity ) ; } else { for ( int i = _NUM ; i < bucket . length ; i ++ ) { if ( bucket . values [ i ] == value ) return _BOOL ; } } if ( bucket . values . length <= bucket . length ) { int [ ] tmp = new int [ _NUM * bucket . values . length ] ; System . arraycopy ( bucket . values , _NUM , tmp , _NUM , bucket . values . length ) ; bucket . values = tmp ; } bucket . values [ bucket . length ++ ] = value ; this . size ++ ; return _BOOL ; }
public boolean add ( int value ) { int index = value % this . numBuckets ; Bucket bucket = this . buckets [ index ] ; if ( bucket == null ) { bucket = this . buckets [ index ] = new Bucket ( this . bucketInitialCapacity ) ; } else { for ( int i = _NUM ; i < bucket . length ; i ++ ) { if ( bucket . values [ i ] == value ) return _BOOL ; } } if ( bucket . values . length <= bucket . length ) { int [ ] tmp = new int [ _NUM * bucket . values . length ] ; System . arraycopy ( bucket . values , _NUM , tmp , _NUM , bucket . values . length ) ; bucket . values = tmp ; } bucket . values [ bucket . length ++ ] = value ; this . size ++ ; return _BOOL ; }
@ SuppressWarnings ( STRING ) private void applyToGroupAndSubGroups ( final AST2BOpContext context , final QueryRoot queryRoot , final QueryHintScope scope , final GraphPatternGroup < IGroupMemberNode > group , final String name , final String value ) { for ( IGroupMemberNode child : group ) { _applyQueryHint ( context , queryRoot , scope , ( ASTBase ) child , name , value ) ; if ( child instanceof GraphPatternGroup < ? > ) { applyToGroupAndSubGroups ( context , queryRoot , scope , ( GraphPatternGroup < IGroupMemberNode > ) child , name , value ) ; } } _applyQueryHint ( context , queryRoot , scope , ( ASTBase ) group , name , value ) ; }
protected int addChildNode ( NodeBuilder child ) { synchronized ( nodes ) { nodes . add ( child ) ; return nodes . size ( ) - _NUM ; } }
public void initGL ( ) { mEglCore = new EglCore ( null , EglCore . FLAG_RECORDABLE | EglCore . FLAG_TRY_GLES3 ) ; mWindowSurface = new WindowSurface ( mEglCore , mSurfaceTexture ) ; mWindowSurface . makeCurrent ( ) ; mRecordSurface = new WindowSurface ( mEglCore , mMediaRecorder . getSurface ( ) , _BOOL ) ; initGLComponents ( ) ; }
public void initGL ( ) { mEglCore = new EglCore ( null , EglCore . FLAG_RECORDABLE | EglCore . FLAG_TRY_GLES3 ) ; mWindowSurface = new WindowSurface ( mEglCore , mSurfaceTexture ) ; mWindowSurface . makeCurrent ( ) ; mRecordSurface = new WindowSurface ( mEglCore , mMediaRecorder . getSurface ( ) , _BOOL ) ; initGLComponents ( ) ; }
public void initGL ( ) { mEglCore = new EglCore ( null , EglCore . FLAG_RECORDABLE | EglCore . FLAG_TRY_GLES3 ) ; mWindowSurface = new WindowSurface ( mEglCore , mSurfaceTexture ) ; mWindowSurface . makeCurrent ( ) ; mRecordSurface = new WindowSurface ( mEglCore , mMediaRecorder . getSurface ( ) , _BOOL ) ; initGLComponents ( ) ; }
public void addHouseNumbers ( List < HouseNumber > HouseNumbers ) { if ( HouseNumbers != null ) { for ( HouseNumber houseNumber : HouseNumbers ) { addHouseNumber ( houseNumber ) ; } } }
public void addHouseNumbers ( List < HouseNumber > HouseNumbers ) { if ( HouseNumbers != null ) { for ( HouseNumber houseNumber : HouseNumbers ) { addHouseNumber ( houseNumber ) ; } } }
public void addHouseNumbers ( List < HouseNumber > HouseNumbers ) { if ( HouseNumbers != null ) { for ( HouseNumber houseNumber : HouseNumbers ) { addHouseNumber ( houseNumber ) ; } } }
public void addHouseNumbers ( List < HouseNumber > HouseNumbers ) { if ( HouseNumbers != null ) { for ( HouseNumber houseNumber : HouseNumbers ) { addHouseNumber ( houseNumber ) ; } } }
private void fillScratchBuffer ( int bytesToRead ) throws IOException { assert ( bytesToRead <= scratchBuffer . capacity ( ) ) ; scratchBuffer . clear ( ) ; scratchBuffer . limit ( bytesToRead ) ; read ( scratchBuffer ) ; scratchBuffer . flip ( ) ; }
private void fillScratchBuffer ( int bytesToRead ) throws IOException { assert ( bytesToRead <= scratchBuffer . capacity ( ) ) ; scratchBuffer . clear ( ) ; scratchBuffer . limit ( bytesToRead ) ; read ( scratchBuffer ) ; scratchBuffer . flip ( ) ; }
private void fillScratchBuffer ( int bytesToRead ) throws IOException { assert ( bytesToRead <= scratchBuffer . capacity ( ) ) ; scratchBuffer . clear ( ) ; scratchBuffer . limit ( bytesToRead ) ; read ( scratchBuffer ) ; scratchBuffer . flip ( ) ; }
private void fillScratchBuffer ( int bytesToRead ) throws IOException { assert ( bytesToRead <= scratchBuffer . capacity ( ) ) ; scratchBuffer . clear ( ) ; scratchBuffer . limit ( bytesToRead ) ; read ( scratchBuffer ) ; scratchBuffer . flip ( ) ; }
public Interval1D ( double min , double max ) { if ( Double . isInfinite ( min ) || Double . isInfinite ( max ) ) throw new IllegalArgumentException ( STRING ) ; if ( Double . isNaN ( min ) || Double . isNaN ( max ) ) throw new IllegalArgumentException ( STRING ) ; if ( min == _NUM ) min = _NUM ; if ( max == _NUM ) max = _NUM ; if ( min <= max ) { this . min = min ; this . max = max ; } else throw new IllegalArgumentException ( STRING ) ; }
public void removeIdentifier ( String idName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( identifiers == null ) { return ; } identifiers . remove ( idName ) ; }
public void removeIdentifier ( String idName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( identifiers == null ) { return ; } identifiers . remove ( idName ) ; }
public static boolean isSSH ( String uri ) { return uri != null && uri . startsWith ( STRING ) ; }
protected void cleanUp ( ) { if ( isReleaseReferences ( ) ) { cleanUpOnAck ( ) ; if ( logger . isLoggingEnabled ( LogWriter . TRACE_DEBUG ) ) { logger . logDebug ( STRING + getDialogId ( ) ) ; } if ( eventListeners != null ) { eventListeners . clear ( ) ; } timerTaskLock = null ; ackSem = null ; contactHeader = null ; eventHeader = null ; firstTransactionId = null ; firstTransactionMethod = null ; lastResponseDialogId = null ; lastResponseMethod = null ; lastResponseTopMostVia = null ; if ( originalRequestRecordRouteHeaders != null ) { originalRequestRecordRouteHeaders . clear ( ) ; originalRequestRecordRouteHeaders = null ; originalRequestRecordRouteHeadersString = null ; } if ( routeList != null ) { routeList . clear ( ) ; routeList = null ; } responsesReceivedInForkingCase . clear ( ) ; } }
public void post ( Object event ) { List < Object > eventQueue = currentThreadEventQueue . get ( ) ; eventQueue . add ( event ) ; BooleanWrapper isPosting = currentThreadIsPosting . get ( ) ; if ( isPosting . value ) { return ; } else { boolean isMainThread = Looper . getMainLooper ( ) == Looper . myLooper ( ) ; isPosting . value = _BOOL ; try { while ( ! eventQueue . isEmpty ( ) ) { postSingleEvent ( eventQueue . remove ( _NUM ) , isMainThread ) ; } } finally { isPosting . value = _BOOL ; } } }
protected SlimException ( final boolean talkback , final Throwable t , final ErrorType type , final String ... args ) { super ( t != null ? t . toString ( ) : args . length > _NUM ? args [ _NUM ] : STRING , t ) ; mTalkback = talkback ; mErrorType = type ; mErrorArguments = args . clone ( ) ; }
protected SlimException ( final boolean talkback , final Throwable t , final ErrorType type , final String ... args ) { super ( t != null ? t . toString ( ) : args . length > _NUM ? args [ _NUM ] : STRING , t ) ; mTalkback = talkback ; mErrorType = type ; mErrorArguments = args . clone ( ) ; }
protected SlimException ( final boolean talkback , final Throwable t , final ErrorType type , final String ... args ) { super ( t != null ? t . toString ( ) : args . length > _NUM ? args [ _NUM ] : STRING , t ) ; mTalkback = talkback ; mErrorType = type ; mErrorArguments = args . clone ( ) ; }
protected SlimException ( final boolean talkback , final Throwable t , final ErrorType type , final String ... args ) { super ( t != null ? t . toString ( ) : args . length > _NUM ? args [ _NUM ] : STRING , t ) ; mTalkback = talkback ; mErrorType = type ; mErrorArguments = args . clone ( ) ; }
protected SlimException ( final boolean talkback , final Throwable t , final ErrorType type , final String ... args ) { super ( t != null ? t . toString ( ) : args . length > _NUM ? args [ _NUM ] : STRING , t ) ; mTalkback = talkback ; mErrorType = type ; mErrorArguments = args . clone ( ) ; }
private static String dirName ( String nodeName ) { for ( int i = _NUM , n = nodeName . length ( ) ; i < n ; i ++ ) if ( ! isDirChar ( nodeName . charAt ( i ) ) ) return STRING + Base64 . byteArrayToAltBase64 ( byteArray ( nodeName ) ) ; return nodeName ; }
private static String dirName ( String nodeName ) { for ( int i = _NUM , n = nodeName . length ( ) ; i < n ; i ++ ) if ( ! isDirChar ( nodeName . charAt ( i ) ) ) return STRING + Base64 . byteArrayToAltBase64 ( byteArray ( nodeName ) ) ; return nodeName ; }
private void buildAddressSelectionPopUp ( ) { final CAddressSelectionDialog dlg = new CAddressSelectionDialog ( m_parent , m_modules ) ; dlg . setVisible ( _BOOL ) ; final INaviModule result = dlg . getSelectionResult ( ) ; final IAddress address = new CAddress ( Long . parseLong ( getText ( ) , _NUM ) ) ; ZyZoomHelpers . zoomToAddress ( m_graph , address , result , _BOOL ) ; }
private void buildAddressSelectionPopUp ( ) { final CAddressSelectionDialog dlg = new CAddressSelectionDialog ( m_parent , m_modules ) ; dlg . setVisible ( _BOOL ) ; final INaviModule result = dlg . getSelectionResult ( ) ; final IAddress address = new CAddress ( Long . parseLong ( getText ( ) , _NUM ) ) ; ZyZoomHelpers . zoomToAddress ( m_graph , address , result , _BOOL ) ; }
private void buildAddressSelectionPopUp ( ) { final CAddressSelectionDialog dlg = new CAddressSelectionDialog ( m_parent , m_modules ) ; dlg . setVisible ( _BOOL ) ; final INaviModule result = dlg . getSelectionResult ( ) ; final IAddress address = new CAddress ( Long . parseLong ( getText ( ) , _NUM ) ) ; ZyZoomHelpers . zoomToAddress ( m_graph , address , result , _BOOL ) ; }
private void write ( String s ) throws SAXException { try { output . write ( s ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } }
public boolean epsilonEquals ( Vector3 obj , float epsilon ) { if ( obj == null ) return _BOOL ; if ( Math . abs ( obj . x - x ) > epsilon ) return _BOOL ; if ( Math . abs ( obj . y - y ) > epsilon ) return _BOOL ; if ( Math . abs ( obj . z - z ) > epsilon ) return _BOOL ; return _BOOL ; }
@ Override public Promise < Void , AuthenticationException > cleanSubject ( MessageInfoContext messageInfo , Subject clientSubject ) { return authModule . cleanSubject ( messageInfo , clientSubject ) ; }
private void update ( ) { Layout < String , Integer > layout = getGraphLayout ( currentState , tab . showParameters ( ) ) ; setGraphLayout ( layout ) ; updateDistribs ( ) ; }
private XNetReply loadChars ( java . io . BufferedReader istream ) throws java . io . IOException { String s = STRING ; s = istream . readLine ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + s ) ; } if ( s == null ) { return null ; } else { return new XNetReply ( s ) ; } }
@ NotNull public static List < String > completeRelativePath ( @ NotNull String baseDir , @ NotNull String shownBaseDir , @ NotNull String relativePath ) { List < String > result = Lists . newLinkedList ( ) ; String bashBaseDir = OSUtil . toBashCompatible ( baseDir ) ; for ( String path : completeAbsolutePath ( baseDir + File . separator + relativePath , Predicates . < File > alwaysTrue ( ) ) ) { if ( path . startsWith ( bashBaseDir ) ) { result . add ( shownBaseDir + path . substring ( bashBaseDir . length ( ) ) ) ; } } return result ; }
@ NotNull public static List < String > completeRelativePath ( @ NotNull String baseDir , @ NotNull String shownBaseDir , @ NotNull String relativePath ) { List < String > result = Lists . newLinkedList ( ) ; String bashBaseDir = OSUtil . toBashCompatible ( baseDir ) ; for ( String path : completeAbsolutePath ( baseDir + File . separator + relativePath , Predicates . < File > alwaysTrue ( ) ) ) { if ( path . startsWith ( bashBaseDir ) ) { result . add ( shownBaseDir + path . substring ( bashBaseDir . length ( ) ) ) ; } } return result ; }
protected void put100Int ( ) { for ( int i = _NUM ; i < _NUM ; i ++ ) { region . put ( new Integer ( i ) , new Integer ( i ) ) ; } }
public static void logJVMInfo ( ) { RuntimeMXBean runtime = ManagementFactory . getRuntimeMXBean ( ) ; if ( runtime != null ) { LOG . info ( STRING + runtime . getVmName ( ) + STRING + runtime . getVmVendor ( ) + STRING + runtime . getVmVersion ( ) ) ; LOG . info ( STRING + runtime . getInputArguments ( ) ) ; } }
private static void writeToConsole ( LDIFEntryWriter writer , Entry entry ) throws IOException { writer . writeEntry ( entry ) ; writer . flush ( ) ; }
public static ScrollableContainer createScrollableContainer ( JComponent contents ) { ScrollableContainer container = new ScrollableContainer ( contents , JScrollPane . VERTICAL_SCROLLBAR_AS_NEEDED , JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ; container . setViewportBorder ( BorderFactory . createEmptyBorder ( _NUM , _NUM , _NUM , _NUM ) ) ; container . setBorder ( BorderFactory . createEmptyBorder ( _NUM , _NUM , _NUM , _NUM ) ) ; return container ; }
public static ScrollableContainer createScrollableContainer ( JComponent contents ) { ScrollableContainer container = new ScrollableContainer ( contents , JScrollPane . VERTICAL_SCROLLBAR_AS_NEEDED , JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ; container . setViewportBorder ( BorderFactory . createEmptyBorder ( _NUM , _NUM , _NUM , _NUM ) ) ; container . setBorder ( BorderFactory . createEmptyBorder ( _NUM , _NUM , _NUM , _NUM ) ) ; return container ; }
public static ScrollableContainer createScrollableContainer ( JComponent contents ) { ScrollableContainer container = new ScrollableContainer ( contents , JScrollPane . VERTICAL_SCROLLBAR_AS_NEEDED , JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ; container . setViewportBorder ( BorderFactory . createEmptyBorder ( _NUM , _NUM , _NUM , _NUM ) ) ; container . setBorder ( BorderFactory . createEmptyBorder ( _NUM , _NUM , _NUM , _NUM ) ) ; return container ; }
public final BeanEventType createBeanType ( String name , Class clazz , boolean isPreconfiguredStatic , boolean isPreconfigured , boolean isConfigured ) { if ( clazz == null ) { throw new IllegalArgumentException ( STRING ) ; } BeanEventType eventType = null ; typesPerJavaBeanLock . lock ( ) ; try { eventType = typesPerJavaBean . get ( clazz ) ; if ( eventType != null ) { eventTypeIdGenerator . assignedType ( name , eventType ) ; return eventType ; } ConfigurationEventTypeLegacy legacyDef = classToLegacyConfigs . get ( clazz . getName ( ) ) ; if ( ( legacyDef == null ) && ( defaultAccessorStyle != ConfigurationEventTypeLegacy . AccessorStyle . JAVABEAN ) ) { legacyDef = new ConfigurationEventTypeLegacy ( ) ; legacyDef . setAccessorStyle ( defaultAccessorStyle ) ; } int typeId = eventTypeIdGenerator . getTypeId ( name ) ; EventTypeMetadata metadata = EventTypeMetadata . createBeanType ( name , clazz , isPreconfiguredStatic , isPreconfigured , isConfigured , EventTypeMetadata . TypeClass . APPLICATION ) ; eventType = new BeanEventType ( metadata , typeId , clazz , eventAdapterService , legacyDef ) ; typesPerJavaBean . put ( clazz , eventType ) ; } catch ( RuntimeException ex ) { throw ex ; } finally { typesPerJavaBeanLock . unlock ( ) ; } return eventType ; }
public final BeanEventType createBeanType ( String name , Class clazz , boolean isPreconfiguredStatic , boolean isPreconfigured , boolean isConfigured ) { if ( clazz == null ) { throw new IllegalArgumentException ( STRING ) ; } BeanEventType eventType = null ; typesPerJavaBeanLock . lock ( ) ; try { eventType = typesPerJavaBean . get ( clazz ) ; if ( eventType != null ) { eventTypeIdGenerator . assignedType ( name , eventType ) ; return eventType ; } ConfigurationEventTypeLegacy legacyDef = classToLegacyConfigs . get ( clazz . getName ( ) ) ; if ( ( legacyDef == null ) && ( defaultAccessorStyle != ConfigurationEventTypeLegacy . AccessorStyle . JAVABEAN ) ) { legacyDef = new ConfigurationEventTypeLegacy ( ) ; legacyDef . setAccessorStyle ( defaultAccessorStyle ) ; } int typeId = eventTypeIdGenerator . getTypeId ( name ) ; EventTypeMetadata metadata = EventTypeMetadata . createBeanType ( name , clazz , isPreconfiguredStatic , isPreconfigured , isConfigured , EventTypeMetadata . TypeClass . APPLICATION ) ; eventType = new BeanEventType ( metadata , typeId , clazz , eventAdapterService , legacyDef ) ; typesPerJavaBean . put ( clazz , eventType ) ; } catch ( RuntimeException ex ) { throw ex ; } finally { typesPerJavaBeanLock . unlock ( ) ; } return eventType ; }
public final BeanEventType createBeanType ( String name , Class clazz , boolean isPreconfiguredStatic , boolean isPreconfigured , boolean isConfigured ) { if ( clazz == null ) { throw new IllegalArgumentException ( STRING ) ; } BeanEventType eventType = null ; typesPerJavaBeanLock . lock ( ) ; try { eventType = typesPerJavaBean . get ( clazz ) ; if ( eventType != null ) { eventTypeIdGenerator . assignedType ( name , eventType ) ; return eventType ; } ConfigurationEventTypeLegacy legacyDef = classToLegacyConfigs . get ( clazz . getName ( ) ) ; if ( ( legacyDef == null ) && ( defaultAccessorStyle != ConfigurationEventTypeLegacy . AccessorStyle . JAVABEAN ) ) { legacyDef = new ConfigurationEventTypeLegacy ( ) ; legacyDef . setAccessorStyle ( defaultAccessorStyle ) ; } int typeId = eventTypeIdGenerator . getTypeId ( name ) ; EventTypeMetadata metadata = EventTypeMetadata . createBeanType ( name , clazz , isPreconfiguredStatic , isPreconfigured , isConfigured , EventTypeMetadata . TypeClass . APPLICATION ) ; eventType = new BeanEventType ( metadata , typeId , clazz , eventAdapterService , legacyDef ) ; typesPerJavaBean . put ( clazz , eventType ) ; } catch ( RuntimeException ex ) { throw ex ; } finally { typesPerJavaBeanLock . unlock ( ) ; } return eventType ; }
public final BeanEventType createBeanType ( String name , Class clazz , boolean isPreconfiguredStatic , boolean isPreconfigured , boolean isConfigured ) { if ( clazz == null ) { throw new IllegalArgumentException ( STRING ) ; } BeanEventType eventType = null ; typesPerJavaBeanLock . lock ( ) ; try { eventType = typesPerJavaBean . get ( clazz ) ; if ( eventType != null ) { eventTypeIdGenerator . assignedType ( name , eventType ) ; return eventType ; } ConfigurationEventTypeLegacy legacyDef = classToLegacyConfigs . get ( clazz . getName ( ) ) ; if ( ( legacyDef == null ) && ( defaultAccessorStyle != ConfigurationEventTypeLegacy . AccessorStyle . JAVABEAN ) ) { legacyDef = new ConfigurationEventTypeLegacy ( ) ; legacyDef . setAccessorStyle ( defaultAccessorStyle ) ; } int typeId = eventTypeIdGenerator . getTypeId ( name ) ; EventTypeMetadata metadata = EventTypeMetadata . createBeanType ( name , clazz , isPreconfiguredStatic , isPreconfigured , isConfigured , EventTypeMetadata . TypeClass . APPLICATION ) ; eventType = new BeanEventType ( metadata , typeId , clazz , eventAdapterService , legacyDef ) ; typesPerJavaBean . put ( clazz , eventType ) ; } catch ( RuntimeException ex ) { throw ex ; } finally { typesPerJavaBeanLock . unlock ( ) ; } return eventType ; }
public final BeanEventType createBeanType ( String name , Class clazz , boolean isPreconfiguredStatic , boolean isPreconfigured , boolean isConfigured ) { if ( clazz == null ) { throw new IllegalArgumentException ( STRING ) ; } BeanEventType eventType = null ; typesPerJavaBeanLock . lock ( ) ; try { eventType = typesPerJavaBean . get ( clazz ) ; if ( eventType != null ) { eventTypeIdGenerator . assignedType ( name , eventType ) ; return eventType ; } ConfigurationEventTypeLegacy legacyDef = classToLegacyConfigs . get ( clazz . getName ( ) ) ; if ( ( legacyDef == null ) && ( defaultAccessorStyle != ConfigurationEventTypeLegacy . AccessorStyle . JAVABEAN ) ) { legacyDef = new ConfigurationEventTypeLegacy ( ) ; legacyDef . setAccessorStyle ( defaultAccessorStyle ) ; } int typeId = eventTypeIdGenerator . getTypeId ( name ) ; EventTypeMetadata metadata = EventTypeMetadata . createBeanType ( name , clazz , isPreconfiguredStatic , isPreconfigured , isConfigured , EventTypeMetadata . TypeClass . APPLICATION ) ; eventType = new BeanEventType ( metadata , typeId , clazz , eventAdapterService , legacyDef ) ; typesPerJavaBean . put ( clazz , eventType ) ; } catch ( RuntimeException ex ) { throw ex ; } finally { typesPerJavaBeanLock . unlock ( ) ; } return eventType ; }
public boolean isRunning ( ) { return ( m_ScriptThread != null ) ; }
@ ExceptionHandler ( value = { JpaSystemException . class , PersistenceException . class } ) @ ResponseBody public ErrorInformation handlePersistenceException ( Exception exception , HttpServletResponse response ) { Throwable throwable = getRootCause ( exception ) ; if ( isDataTruncationException ( throwable ) ) { return getErrorInformationAndSetStatus ( HttpStatus . BAD_REQUEST , throwable , response ) ; } else if ( isCausedByConstraintViolationException ( exception ) ) { return getErrorInformationAndSetStatus ( HttpStatus . BAD_REQUEST , new Exception ( STRING + throwable . getMessage ( ) ) , response ) ; } else { logError ( STRING , exception ) ; return getErrorInformationAndSetStatus ( HttpStatus . INTERNAL_SERVER_ERROR , throwable == null ? new Exception ( STRING ) : throwable , response ) ; } }
@ ExceptionHandler ( value = { JpaSystemException . class , PersistenceException . class } ) @ ResponseBody public ErrorInformation handlePersistenceException ( Exception exception , HttpServletResponse response ) { Throwable throwable = getRootCause ( exception ) ; if ( isDataTruncationException ( throwable ) ) { return getErrorInformationAndSetStatus ( HttpStatus . BAD_REQUEST , throwable , response ) ; } else if ( isCausedByConstraintViolationException ( exception ) ) { return getErrorInformationAndSetStatus ( HttpStatus . BAD_REQUEST , new Exception ( STRING + throwable . getMessage ( ) ) , response ) ; } else { logError ( STRING , exception ) ; return getErrorInformationAndSetStatus ( HttpStatus . INTERNAL_SERVER_ERROR , throwable == null ? new Exception ( STRING ) : throwable , response ) ; } }
@ ExceptionHandler ( value = { JpaSystemException . class , PersistenceException . class } ) @ ResponseBody public ErrorInformation handlePersistenceException ( Exception exception , HttpServletResponse response ) { Throwable throwable = getRootCause ( exception ) ; if ( isDataTruncationException ( throwable ) ) { return getErrorInformationAndSetStatus ( HttpStatus . BAD_REQUEST , throwable , response ) ; } else if ( isCausedByConstraintViolationException ( exception ) ) { return getErrorInformationAndSetStatus ( HttpStatus . BAD_REQUEST , new Exception ( STRING + throwable . getMessage ( ) ) , response ) ; } else { logError ( STRING , exception ) ; return getErrorInformationAndSetStatus ( HttpStatus . INTERNAL_SERVER_ERROR , throwable == null ? new Exception ( STRING ) : throwable , response ) ; } }
public void removePropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . removePropertyChangeListener ( listener ) ; }
public static int calculateEANParity ( String code ) { int mul = _NUM ; int total = _NUM ; for ( int k = code . length ( ) - _NUM ; k >= _NUM ; -- k ) { int n = code . charAt ( k ) - STRING ; total += mul * n ; mul ^= _NUM ; } return ( _NUM - ( total % _NUM ) ) % _NUM ; }
public X509TrustChainKeySelector ( X509Certificate ... trustedRoots ) { _log = LoggerFactory . getLogger ( X509TrustChainKeySelector . class ) ; checkCtorArgsNotNull ( trustedRoots ) ; _trustAnchors = new HashSet < TrustAnchor > ( ) ; for ( X509Certificate cert : trustedRoots ) { _trustAnchors . add ( new TrustAnchor ( cert , null ) ) ; } }
public X509TrustChainKeySelector ( X509Certificate ... trustedRoots ) { _log = LoggerFactory . getLogger ( X509TrustChainKeySelector . class ) ; checkCtorArgsNotNull ( trustedRoots ) ; _trustAnchors = new HashSet < TrustAnchor > ( ) ; for ( X509Certificate cert : trustedRoots ) { _trustAnchors . add ( new TrustAnchor ( cert , null ) ) ; } }
public X509TrustChainKeySelector ( X509Certificate ... trustedRoots ) { _log = LoggerFactory . getLogger ( X509TrustChainKeySelector . class ) ; checkCtorArgsNotNull ( trustedRoots ) ; _trustAnchors = new HashSet < TrustAnchor > ( ) ; for ( X509Certificate cert : trustedRoots ) { _trustAnchors . add ( new TrustAnchor ( cert , null ) ) ; } }
public Shape createPoint ( Point2D point ) { Rectangle2D . Double pointMarker = new Rectangle2D . Double ( _NUM , _NUM , size , size ) ; pointMarker . x = ( double ) ( point . getX ( ) - ( size / _NUM ) ) ; pointMarker . y = ( double ) ( point . getY ( ) - ( size / _NUM ) ) ; return pointMarker ; }
public Shape createPoint ( Point2D point ) { Rectangle2D . Double pointMarker = new Rectangle2D . Double ( _NUM , _NUM , size , size ) ; pointMarker . x = ( double ) ( point . getX ( ) - ( size / _NUM ) ) ; pointMarker . y = ( double ) ( point . getY ( ) - ( size / _NUM ) ) ; return pointMarker ; }
public Shape createPoint ( Point2D point ) { Rectangle2D . Double pointMarker = new Rectangle2D . Double ( _NUM , _NUM , size , size ) ; pointMarker . x = ( double ) ( point . getX ( ) - ( size / _NUM ) ) ; pointMarker . y = ( double ) ( point . getY ( ) - ( size / _NUM ) ) ; return pointMarker ; }
private void postInitViewPager ( ) { try { Class < ? > viewpager = ViewPager . class ; Field scroller = viewpager . getDeclaredField ( STRING ) ; scroller . setAccessible ( _BOOL ) ; Field interpolator = viewpager . getDeclaredField ( STRING ) ; interpolator . setAccessible ( _BOOL ) ; mScroller = new CustomDurationScroller ( getContext ( ) , ( Interpolator ) interpolator . get ( null ) ) ; double duration = _NUM ; mScroller . setScrollDurationFactor ( duration ) ; scroller . set ( this , mScroller ) ; } catch ( NoSuchFieldException e ) { } catch ( IllegalArgumentException e ) { } catch ( IllegalAccessException e ) { } }
private void postInitViewPager ( ) { try { Class < ? > viewpager = ViewPager . class ; Field scroller = viewpager . getDeclaredField ( STRING ) ; scroller . setAccessible ( _BOOL ) ; Field interpolator = viewpager . getDeclaredField ( STRING ) ; interpolator . setAccessible ( _BOOL ) ; mScroller = new CustomDurationScroller ( getContext ( ) , ( Interpolator ) interpolator . get ( null ) ) ; double duration = _NUM ; mScroller . setScrollDurationFactor ( duration ) ; scroller . set ( this , mScroller ) ; } catch ( NoSuchFieldException e ) { } catch ( IllegalArgumentException e ) { } catch ( IllegalAccessException e ) { } }
private static void drawCircleEndpoint ( Point from , Point to , Graphics g ) { final int diameter = _NUM ; double a = to . x - from . x ; double b = from . y - to . y ; double theta = Math . atan2 ( b , a ) ; int xminus = ( int ) ( Math . cos ( theta ) * diameter / _NUM ) ; int yplus = ( int ) ( Math . sin ( theta ) * diameter / _NUM ) ; g . fillOval ( to . x - xminus - diameter / _NUM , to . y + yplus - diameter / _NUM , diameter , diameter ) ; Color c = g . getColor ( ) ; g . setColor ( Color . white ) ; g . fillOval ( to . x - xminus - diameter / _NUM - _NUM , to . y + yplus - diameter / _NUM - _NUM , ( int ) ( diameter / _NUM ) , ( int ) ( diameter / _NUM ) ) ; g . setColor ( c ) ; }
private static void drawCircleEndpoint ( Point from , Point to , Graphics g ) { final int diameter = _NUM ; double a = to . x - from . x ; double b = from . y - to . y ; double theta = Math . atan2 ( b , a ) ; int xminus = ( int ) ( Math . cos ( theta ) * diameter / _NUM ) ; int yplus = ( int ) ( Math . sin ( theta ) * diameter / _NUM ) ; g . fillOval ( to . x - xminus - diameter / _NUM , to . y + yplus - diameter / _NUM , diameter , diameter ) ; Color c = g . getColor ( ) ; g . setColor ( Color . white ) ; g . fillOval ( to . x - xminus - diameter / _NUM - _NUM , to . y + yplus - diameter / _NUM - _NUM , ( int ) ( diameter / _NUM ) , ( int ) ( diameter / _NUM ) ) ; g . setColor ( c ) ; }
private static void drawCircleEndpoint ( Point from , Point to , Graphics g ) { final int diameter = _NUM ; double a = to . x - from . x ; double b = from . y - to . y ; double theta = Math . atan2 ( b , a ) ; int xminus = ( int ) ( Math . cos ( theta ) * diameter / _NUM ) ; int yplus = ( int ) ( Math . sin ( theta ) * diameter / _NUM ) ; g . fillOval ( to . x - xminus - diameter / _NUM , to . y + yplus - diameter / _NUM , diameter , diameter ) ; Color c = g . getColor ( ) ; g . setColor ( Color . white ) ; g . fillOval ( to . x - xminus - diameter / _NUM - _NUM , to . y + yplus - diameter / _NUM - _NUM , ( int ) ( diameter / _NUM ) , ( int ) ( diameter / _NUM ) ) ; g . setColor ( c ) ; }
public Candidate extendHypothesis ( ) { if ( ranks [ _NUM ] < hypotheses . size ( ) - _NUM ) { return new Candidate ( featureFunctions , sentence , hypotheses , phrases , future_delta , new int [ ] { ranks [ _NUM ] + _NUM , ranks [ _NUM ] } ) ; } return null ; }
@ Override public int compareTo ( final MemoryChunk chunk ) { return Long . compare ( m_address , chunk . m_address ) ; }
@ Override public int compareTo ( final MemoryChunk chunk ) { return Long . compare ( m_address , chunk . m_address ) ; }
private ReplicatorRuntimeConf ( String serviceName ) { replicatorHomeDir = locateReplicatorHomeDir ( ) ; replicatorLogDir = locateReplicatorLogDir ( ) ; replicatorConfDir = locateReplicatorConfDir ( ) ; replicatorProperties = new File ( locateReplicatorConfDir ( ) , STRING + serviceName + STRING ) ; if ( ! replicatorProperties . isFile ( ) || ! replicatorProperties . canRead ( ) ) { throw new ServerRuntimeException ( STRING + replicatorProperties ) ; } replicatorDynamicProperties = new File ( replicatorConfDir , STRING + serviceName + STRING ) ; replicatorDynamicRole = new File ( replicatorConfDir , STRING + serviceName + STRING ) ; this . clearDynamicProperties = Boolean . parseBoolean ( System . getProperty ( CLEAR_DYNAMIC_PROPERTIES ) ) ; }
private void expect ( char expectedSymbol ) throws ParseException { if ( ! accept ( expectedSymbol ) ) throw new ParseException ( STRING + expectedSymbol + STRING + ( char ) data [ index ] + STRING , index ) ; }
private void expect ( char expectedSymbol ) throws ParseException { if ( ! accept ( expectedSymbol ) ) throw new ParseException ( STRING + expectedSymbol + STRING + ( char ) data [ index ] + STRING , index ) ; }
private void expect ( char expectedSymbol ) throws ParseException { if ( ! accept ( expectedSymbol ) ) throw new ParseException ( STRING + expectedSymbol + STRING + ( char ) data [ index ] + STRING , index ) ; }
private void expect ( char expectedSymbol ) throws ParseException { if ( ! accept ( expectedSymbol ) ) throw new ParseException ( STRING + expectedSymbol + STRING + ( char ) data [ index ] + STRING , index ) ; }
public static final < A > CollectionX < A > toLazyCollection ( final Stream < A > stream ) { return SeqUtils . toLazyCollection ( stream . iterator ( ) ) ; }
private static List < String > rewriteTermBruteForce ( String term ) { List < String > termsList = rewriteBrute ( term ) ; if ( term == STRING || ! term . equals ( termsList . get ( termsList . size ( ) - _NUM ) ) ) termsList . add ( term ) ; return termsList ; }
private static List < String > rewriteTermBruteForce ( String term ) { List < String > termsList = rewriteBrute ( term ) ; if ( term == STRING || ! term . equals ( termsList . get ( termsList . size ( ) - _NUM ) ) ) termsList . add ( term ) ; return termsList ; }
private static boolean createConstraintOnPostgres ( ConnectionSource connectionSource , String constraintName , String constraintStatement ) throws SQLException { Preconditions . checkArgument ( isUnquotedSqlIdentifier ( constraintName ) , STRING , constraintName ) ; if ( ! ( connectionSource . getDatabaseType ( ) instanceof PostgresDatabaseType ) ) { logger . warn ( STRING , constraintName ) ; return _BOOL ; } String queryString = STRING + constraintName + STRING ; long constraintCount = connectionSource . getReadOnlyConnection ( ) . queryForLong ( queryString ) ; if ( constraintCount != _NUM ) { assert constraintCount == _NUM ; return _BOOL ; } logger . info ( STRING , constraintName ) ; connectionSource . getReadWriteConnection ( ) . executeStatement ( constraintStatement , DatabaseConnection . DEFAULT_RESULT_FLAGS ) ; assert connectionSource . getReadOnlyConnection ( ) . queryForLong ( queryString ) == _NUM ; return _BOOL ; }
public void validateDerivedPKClassId ( String attributeName , String expectedType , String referenceClassName ) { if ( m_pkClassIDs . containsKey ( attributeName ) ) { String actualType = m_pkClassIDs . get ( attributeName ) ; if ( actualType . equals ( expectedType ) ) { m_pkClassIDs . remove ( attributeName ) ; } else { throw ValidationException . invalidDerivedCompositePKAttribute ( referenceClassName , getPKClassName ( ) , attributeName , expectedType , actualType ) ; } } }
public void validateDerivedPKClassId ( String attributeName , String expectedType , String referenceClassName ) { if ( m_pkClassIDs . containsKey ( attributeName ) ) { String actualType = m_pkClassIDs . get ( attributeName ) ; if ( actualType . equals ( expectedType ) ) { m_pkClassIDs . remove ( attributeName ) ; } else { throw ValidationException . invalidDerivedCompositePKAttribute ( referenceClassName , getPKClassName ( ) , attributeName , expectedType , actualType ) ; } } }
public void validateDerivedPKClassId ( String attributeName , String expectedType , String referenceClassName ) { if ( m_pkClassIDs . containsKey ( attributeName ) ) { String actualType = m_pkClassIDs . get ( attributeName ) ; if ( actualType . equals ( expectedType ) ) { m_pkClassIDs . remove ( attributeName ) ; } else { throw ValidationException . invalidDerivedCompositePKAttribute ( referenceClassName , getPKClassName ( ) , attributeName , expectedType , actualType ) ; } } }
public void validateDerivedPKClassId ( String attributeName , String expectedType , String referenceClassName ) { if ( m_pkClassIDs . containsKey ( attributeName ) ) { String actualType = m_pkClassIDs . get ( attributeName ) ; if ( actualType . equals ( expectedType ) ) { m_pkClassIDs . remove ( attributeName ) ; } else { throw ValidationException . invalidDerivedCompositePKAttribute ( referenceClassName , getPKClassName ( ) , attributeName , expectedType , actualType ) ; } } }
public void validateDerivedPKClassId ( String attributeName , String expectedType , String referenceClassName ) { if ( m_pkClassIDs . containsKey ( attributeName ) ) { String actualType = m_pkClassIDs . get ( attributeName ) ; if ( actualType . equals ( expectedType ) ) { m_pkClassIDs . remove ( attributeName ) ; } else { throw ValidationException . invalidDerivedCompositePKAttribute ( referenceClassName , getPKClassName ( ) , attributeName , expectedType , actualType ) ; } } }
public MimSearchEditor2 ( MimBuildRunner runner ) { this ( runner , STRING ) ; }
public MimSearchEditor2 ( MimBuildRunner runner ) { this ( runner , STRING ) ; }
public MimSearchEditor2 ( MimBuildRunner runner ) { this ( runner , STRING ) ; }
public static String readStringFixedSize ( final DataInput in , int size ) throws IOException { byte [ ] b = new byte [ size ] ; in . readFully ( b ) ; int n = b . length ; while ( n > _NUM && b [ n - _NUM ] == _NUM ) -- n ; return toString ( b , _NUM , n ) ; }
public int size ( ) { return items . size ( ) ; }
private String makeDeleteAllUrl ( ) throws UnsupportedEncodingException { HttpSolrClient client = ( HttpSolrClient ) getSolrClient ( ) ; String deleteQuery = STRING ; return client . getBaseURL ( ) + STRING + URLEncoder . encode ( deleteQuery , STRING ) ; }
private String makeDeleteAllUrl ( ) throws UnsupportedEncodingException { HttpSolrClient client = ( HttpSolrClient ) getSolrClient ( ) ; String deleteQuery = STRING ; return client . getBaseURL ( ) + STRING + URLEncoder . encode ( deleteQuery , STRING ) ; }
public void push ( Notification notification , NotificationResponseListener listener ) { final String notificationTopic = notification . getTopic ( ) ; final String topic = notificationTopic == null ? defaultTopic : notificationTopic ; Request req = Utils . buildRequest ( client , topic , notification , gateway ) ; semaphore . acquireUninterruptibly ( ) ; req . send ( new ResponseListener ( semaphore , notification , listener ) ) ; }
public void testFileFileWithConfigOption ( ) throws Exception { Properties properties = loadProperties ( STRING ) ; assertEquals ( STRING , properties . getProperty ( STRING ) ) ; }
protected void removeMember ( final RelationMember member ) { while ( members . remove ( member ) ) { } }
public void makeImmutable ( ) { if ( isMutable ) { if ( conditions != null ) { int length = conditions . size ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { Condition condition = ( Condition ) conditions . get ( i ) ; condition . makeImmutable ( ) ; } conditions = Collections . unmodifiableList ( conditions ) ; } if ( audienceRestrictions != null ) { int length = audienceRestrictions . size ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { AudienceRestriction ar = ( AudienceRestriction ) audienceRestrictions . get ( i ) ; ar . makeImmutable ( ) ; } audienceRestrictions = Collections . unmodifiableList ( audienceRestrictions ) ; } if ( oneTimeUses != null ) { int length = oneTimeUses . size ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { OneTimeUse oneTimeUse = ( OneTimeUse ) oneTimeUses . get ( i ) ; oneTimeUse . makeImmutable ( ) ; } oneTimeUses = Collections . unmodifiableList ( oneTimeUses ) ; } if ( proxyRestrictions != null ) { int length = proxyRestrictions . size ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { ProxyRestriction pr = ( ProxyRestriction ) proxyRestrictions . get ( i ) ; pr . makeImmutable ( ) ; } proxyRestrictions = Collections . unmodifiableList ( proxyRestrictions ) ; } isMutable = _BOOL ; } }
public void destroyScene ( ) { clearAnimations ( ) ; clearCameras ( ) ; clearLights ( ) ; clearPlugins ( ) ; clearChildren ( ) ; clearFrameCallbacks ( ) ; }
public void destroyScene ( ) { clearAnimations ( ) ; clearCameras ( ) ; clearLights ( ) ; clearPlugins ( ) ; clearChildren ( ) ; clearFrameCallbacks ( ) ; }
public void destroyScene ( ) { clearAnimations ( ) ; clearCameras ( ) ; clearLights ( ) ; clearPlugins ( ) ; clearChildren ( ) ; clearFrameCallbacks ( ) ; }
public void addScriptFinishedListener ( ScriptExecutionListener l ) { m_FinishedListeners . add ( l ) ; }
public boolean verify ( PublicKey key , String sigProvider ) throws NoSuchAlgorithmException , NoSuchProviderException , CMSException { return verify ( key , CMSUtils . getProvider ( sigProvider ) ) ; }
public boolean verify ( PublicKey key , String sigProvider ) throws NoSuchAlgorithmException , NoSuchProviderException , CMSException { return verify ( key , CMSUtils . getProvider ( sigProvider ) ) ; }
public boolean verify ( PublicKey key , String sigProvider ) throws NoSuchAlgorithmException , NoSuchProviderException , CMSException { return verify ( key , CMSUtils . getProvider ( sigProvider ) ) ; }
private static List < BlockNode > cleanBlockList ( List < BlockNode > list ) { List < BlockNode > ret = new ArrayList < BlockNode > ( list . size ( ) ) ; for ( BlockNode block : list ) { if ( ! isBlockMustBeCleared ( block ) ) { ret . add ( block ) ; } } return ret ; }
protected void logDiagnostic ( String msg ) { if ( isDiagnosticsEnabled ( ) ) { logRawDiagnostic ( diagnosticPrefix + msg ) ; } }
protected void logDiagnostic ( String msg ) { if ( isDiagnosticsEnabled ( ) ) { logRawDiagnostic ( diagnosticPrefix + msg ) ; } }
public TranslatingGraphMousePlugin ( int modifiers ) { super ( modifiers ) ; this . cursor = Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ; }
private void resizePanel ( ) { if ( parentFrame != null ) { int additionalParentHeight = ( parentFrame . getBounds ( ) . height - scroller . getHeight ( ) ) ; scroller . resize ( ) ; int newHeight = scroller . getPreferredSize ( ) . height + additionalParentHeight ; if ( newHeight > _NUM ) { parentFrame . pack ( ) ; parentFrame . setLocationRelativeTo ( null ) ; } } }
FixedAllocator ( final RWStore store , final int size ) { m_diskAddr = _NUM ; m_store = store ; m_size = size ; m_bitSize = calcBitSize ( _BOOL , size , cMinAllocation , cModAllocation ) ; allocBlockRange = _NUM * m_bitSize ; final int numBlocks = _NUM / ( m_bitSize + _NUM ) ; m_allocBlocks = new ArrayList < AllocBlock > ( numBlocks ) ; for ( int i = _NUM ; i < numBlocks ; i ++ ) { m_allocBlocks . add ( new AllocBlock ( _NUM , m_bitSize , this ) ) ; } m_freeTransients = _NUM ; m_freeBits = _NUM * m_bitSize * numBlocks ; }
FixedAllocator ( final RWStore store , final int size ) { m_diskAddr = _NUM ; m_store = store ; m_size = size ; m_bitSize = calcBitSize ( _BOOL , size , cMinAllocation , cModAllocation ) ; allocBlockRange = _NUM * m_bitSize ; final int numBlocks = _NUM / ( m_bitSize + _NUM ) ; m_allocBlocks = new ArrayList < AllocBlock > ( numBlocks ) ; for ( int i = _NUM ; i < numBlocks ; i ++ ) { m_allocBlocks . add ( new AllocBlock ( _NUM , m_bitSize , this ) ) ; } m_freeTransients = _NUM ; m_freeBits = _NUM * m_bitSize * numBlocks ; }
FixedAllocator ( final RWStore store , final int size ) { m_diskAddr = _NUM ; m_store = store ; m_size = size ; m_bitSize = calcBitSize ( _BOOL , size , cMinAllocation , cModAllocation ) ; allocBlockRange = _NUM * m_bitSize ; final int numBlocks = _NUM / ( m_bitSize + _NUM ) ; m_allocBlocks = new ArrayList < AllocBlock > ( numBlocks ) ; for ( int i = _NUM ; i < numBlocks ; i ++ ) { m_allocBlocks . add ( new AllocBlock ( _NUM , m_bitSize , this ) ) ; } m_freeTransients = _NUM ; m_freeBits = _NUM * m_bitSize * numBlocks ; }
FixedAllocator ( final RWStore store , final int size ) { m_diskAddr = _NUM ; m_store = store ; m_size = size ; m_bitSize = calcBitSize ( _BOOL , size , cMinAllocation , cModAllocation ) ; allocBlockRange = _NUM * m_bitSize ; final int numBlocks = _NUM / ( m_bitSize + _NUM ) ; m_allocBlocks = new ArrayList < AllocBlock > ( numBlocks ) ; for ( int i = _NUM ; i < numBlocks ; i ++ ) { m_allocBlocks . add ( new AllocBlock ( _NUM , m_bitSize , this ) ) ; } m_freeTransients = _NUM ; m_freeBits = _NUM * m_bitSize * numBlocks ; }
FixedAllocator ( final RWStore store , final int size ) { m_diskAddr = _NUM ; m_store = store ; m_size = size ; m_bitSize = calcBitSize ( _BOOL , size , cMinAllocation , cModAllocation ) ; allocBlockRange = _NUM * m_bitSize ; final int numBlocks = _NUM / ( m_bitSize + _NUM ) ; m_allocBlocks = new ArrayList < AllocBlock > ( numBlocks ) ; for ( int i = _NUM ; i < numBlocks ; i ++ ) { m_allocBlocks . add ( new AllocBlock ( _NUM , m_bitSize , this ) ) ; } m_freeTransients = _NUM ; m_freeBits = _NUM * m_bitSize * numBlocks ; }
public static UUID fromUUIDAsURNStringToUUID ( String UUIDasURN ) { if ( ! UUIDasURN . startsWith ( UUIDHelper . UUID_as_a_URN_PREFIX ) ) { IMFErrorLogger imfErrorLogger = new IMFErrorLoggerImpl ( ) ; imfErrorLogger . addError ( IMFErrorLogger . IMFErrors . ErrorCodes . UUID_ERROR , IMFErrorLogger . IMFErrors . ErrorLevels . FATAL , String . format ( STRING + STRING , UUIDasURN , UUIDHelper . UUID_as_a_URN_PREFIX ) ) ; throw new IMFException ( String . format ( STRING , UUIDasURN , UUIDHelper . UUID_as_a_URN_PREFIX ) , imfErrorLogger ) ; } return UUID . fromString ( UUIDasURN . split ( UUIDHelper . UUID_as_a_URN_PREFIX ) [ _NUM ] ) ; }
ExternalProblem ( Process process ) { this ( process . getInputStream ( ) , process . getOutputStream ( ) ) ; RedirectStream . redirect ( process . getErrorStream ( ) , System . err ) ; }
ExternalProblem ( Process process ) { this ( process . getInputStream ( ) , process . getOutputStream ( ) ) ; RedirectStream . redirect ( process . getErrorStream ( ) , System . err ) ; }
ExternalProblem ( Process process ) { this ( process . getInputStream ( ) , process . getOutputStream ( ) ) ; RedirectStream . redirect ( process . getErrorStream ( ) , System . err ) ; }
private static int uarimaxLe ( double value , double [ ] bv , int [ ] bvi , BinaryOperator bOp ) throws DMLRuntimeException { int ixMax = bv . length ; if ( value <= bv [ _NUM ] || value > bv [ bv . length - _NUM ] ) return ixMax ; int ix = Arrays . binarySearch ( bv , value ) ; if ( ix < _NUM ) ix = Math . abs ( ix ) - _NUM ; ixMax = bvi [ ix ] + _NUM ; return ixMax ; }
private static String capitalize ( String input ) { final char [ ] buffer = input . toCharArray ( ) ; buffer [ _NUM ] = Character . toTitleCase ( buffer [ _NUM ] ) ; return new String ( buffer ) ; }
protected AbstractRegexAnnotator ( String pattern , boolean caseSensitive , double confidence ) { this ( Pattern . compile ( pattern , caseSensitive ? _NUM : Pattern . CASE_INSENSITIVE ) , _NUM , confidence ) ; }
public CARTImpl ( BufferedReader reader , int nodes ) throws IOException { this ( nodes ) ; String line ; for ( int i = _NUM ; i < nodes ; i ++ ) { line = reader . readLine ( ) ; if ( ! line . startsWith ( STRING ) ) { parseAndAdd ( line ) ; } } }
public CARTImpl ( BufferedReader reader , int nodes ) throws IOException { this ( nodes ) ; String line ; for ( int i = _NUM ; i < nodes ; i ++ ) { line = reader . readLine ( ) ; if ( ! line . startsWith ( STRING ) ) { parseAndAdd ( line ) ; } } }
public CARTImpl ( BufferedReader reader , int nodes ) throws IOException { this ( nodes ) ; String line ; for ( int i = _NUM ; i < nodes ; i ++ ) { line = reader . readLine ( ) ; if ( ! line . startsWith ( STRING ) ) { parseAndAdd ( line ) ; } } }
void addNonExpiringSession ( InternalSession session ) { if ( session . willExpire ( ) ) { throw new IllegalStateException ( STRING ) ; } session . setMaxSessionTime ( NON_EXPIRING_SESSION_LENGTH_MINUTES ) ; session . setMaxIdleTime ( refreshPeriodInMinutes * _NUM ) ; updateSession ( session ) ; nonExpiringSessions . add ( session . getID ( ) ) ; }
private void exit ( ) { log . info ( STRING ) ; Object result = doIt ( START , STRING , null ) ; ProcessInfo pi = new ProcessInfo ( STRING , _NUM ) ; pi . setClassName ( REMOTE ) ; pi . setSerializableObject ( m_replicationStart ) ; try { m_serverRemote . process ( new Properties ( ) , pi ) ; } catch ( Exception ex ) { } }
synchronized boolean release ( ) { d ( STRING ) ; if ( state == BUSY ) { state = IDLE ; idleSince = System . currentTimeMillis ( ) ; return _BOOL ; } else { return _BOOL ; } }
synchronized boolean release ( ) { d ( STRING ) ; if ( state == BUSY ) { state = IDLE ; idleSince = System . currentTimeMillis ( ) ; return _BOOL ; } else { return _BOOL ; } }
synchronized boolean release ( ) { d ( STRING ) ; if ( state == BUSY ) { state = IDLE ; idleSince = System . currentTimeMillis ( ) ; return _BOOL ; } else { return _BOOL ; } }
public void removeAll ( ) { mParts . clear ( ) ; }
public static void readLines ( InputStream stream , Consumer < String > lineProcessor ) throws IOException { try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream ) ) ) { String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { lineProcessor . accept ( line ) ; } } }
public static void readLines ( InputStream stream , Consumer < String > lineProcessor ) throws IOException { try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream ) ) ) { String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { lineProcessor . accept ( line ) ; } } }
public static void readLines ( InputStream stream , Consumer < String > lineProcessor ) throws IOException { try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream ) ) ) { String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { lineProcessor . accept ( line ) ; } } }
public static String appendPath ( String pathTo , String pathFrom ) { if ( pathTo == null || pathTo . length ( ) == _NUM ) { return pathFrom ; } else if ( pathFrom == null || pathFrom . length ( ) == _NUM ) { return pathTo ; } else { return pathTo + File . pathSeparator + pathFrom ; } }
public static String appendPath ( String pathTo , String pathFrom ) { if ( pathTo == null || pathTo . length ( ) == _NUM ) { return pathFrom ; } else if ( pathFrom == null || pathFrom . length ( ) == _NUM ) { return pathTo ; } else { return pathTo + File . pathSeparator + pathFrom ; } }
public boolean equals ( Object o ) { if ( o instanceof AMIdentitySubject ) { AMIdentitySubject subject = ( AMIdentitySubject ) o ; return ( subjectValues . equals ( subject . subjectValues ) ) ; } return ( _BOOL ) ; }
private void reseed ( ) throws RandomDataGenerationException { if ( nBytesGenerated < RESEEDING_LIMIT ) { return ; } else { try { setSeed ( wrappedRandomnessGenerator . generateSeed ( _NUM ) ) ; } catch ( Exception e ) { throw new RandomDataGenerationException ( STRING ) ; } } }
private void reseed ( ) throws RandomDataGenerationException { if ( nBytesGenerated < RESEEDING_LIMIT ) { return ; } else { try { setSeed ( wrappedRandomnessGenerator . generateSeed ( _NUM ) ) ; } catch ( Exception e ) { throw new RandomDataGenerationException ( STRING ) ; } } }
private void reseed ( ) throws RandomDataGenerationException { if ( nBytesGenerated < RESEEDING_LIMIT ) { return ; } else { try { setSeed ( wrappedRandomnessGenerator . generateSeed ( _NUM ) ) ; } catch ( Exception e ) { throw new RandomDataGenerationException ( STRING ) ; } } }
private void reseed ( ) throws RandomDataGenerationException { if ( nBytesGenerated < RESEEDING_LIMIT ) { return ; } else { try { setSeed ( wrappedRandomnessGenerator . generateSeed ( _NUM ) ) ; } catch ( Exception e ) { throw new RandomDataGenerationException ( STRING ) ; } } }
@ Override public void passivate ( ) { cleanupUserTransaction ( ) ; super . passivate ( ) ; }
@ Override public void passivate ( ) { cleanupUserTransaction ( ) ; super . passivate ( ) ; }
public String toString ( int digits , boolean trailing ) { if ( isEmpty ( ) ) return STRING ; StringBuffer text = new StringBuffer ( ) ; FlexibleDecimalFormat nf = new FlexibleDecimalFormat ( digits , trailing ) ; nf . grouping ( _BOOL ) ; for ( int i = _NUM ; i < size ( ) ; i ++ ) nf . update ( get ( i ) ) ; int count = _NUM ; int width = _NUM ; String number ; for ( int i = _NUM ; i < size ( ) ; i ++ ) { number = nf . format ( get ( i ) ) ; count += _NUM + number . length ( ) ; if ( count > width - _NUM ) { text . append ( STRING ) ; count = _NUM + number . length ( ) ; } text . append ( STRING + number ) ; } return text . toString ( ) ; }
public void testConstructorSignBytesZero1 ( ) { byte aBytes [ ] = { - _NUM , _NUM , + _NUM , _NUM , _NUM , _NUM , _NUM } ; int aSign = - _NUM ; byte rBytes [ ] = { _NUM } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , aNumber . signum ( ) ) ; }
public void paintText ( SynthContext ss , Graphics g , String text , int x , int y , int mnemonicIndex ) { if ( text != null ) { Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; JComponent c = ss . getComponent ( ) ; FontMetrics fm = SwingUtilities2 . getFontMetrics ( c , g2d ) ; y += fm . getAscent ( ) ; SwingUtilities2 . drawString ( c , g2d , text , x , y ) ; if ( mnemonicIndex >= _NUM && mnemonicIndex < text . length ( ) ) { int underlineX = x + SwingUtilities2 . stringWidth ( c , fm , text . substring ( _NUM , mnemonicIndex ) ) ; int underlineY = y ; int underlineWidth = fm . charWidth ( text . charAt ( mnemonicIndex ) ) ; int underlineHeight = _NUM ; g2d . fillRect ( underlineX , underlineY + fm . getDescent ( ) - _NUM , underlineWidth , underlineHeight ) ; } } }
public void paintText ( SynthContext ss , Graphics g , String text , int x , int y , int mnemonicIndex ) { if ( text != null ) { Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; JComponent c = ss . getComponent ( ) ; FontMetrics fm = SwingUtilities2 . getFontMetrics ( c , g2d ) ; y += fm . getAscent ( ) ; SwingUtilities2 . drawString ( c , g2d , text , x , y ) ; if ( mnemonicIndex >= _NUM && mnemonicIndex < text . length ( ) ) { int underlineX = x + SwingUtilities2 . stringWidth ( c , fm , text . substring ( _NUM , mnemonicIndex ) ) ; int underlineY = y ; int underlineWidth = fm . charWidth ( text . charAt ( mnemonicIndex ) ) ; int underlineHeight = _NUM ; g2d . fillRect ( underlineX , underlineY + fm . getDescent ( ) - _NUM , underlineWidth , underlineHeight ) ; } } }
public void paintText ( SynthContext ss , Graphics g , String text , int x , int y , int mnemonicIndex ) { if ( text != null ) { Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; JComponent c = ss . getComponent ( ) ; FontMetrics fm = SwingUtilities2 . getFontMetrics ( c , g2d ) ; y += fm . getAscent ( ) ; SwingUtilities2 . drawString ( c , g2d , text , x , y ) ; if ( mnemonicIndex >= _NUM && mnemonicIndex < text . length ( ) ) { int underlineX = x + SwingUtilities2 . stringWidth ( c , fm , text . substring ( _NUM , mnemonicIndex ) ) ; int underlineY = y ; int underlineWidth = fm . charWidth ( text . charAt ( mnemonicIndex ) ) ; int underlineHeight = _NUM ; g2d . fillRect ( underlineX , underlineY + fm . getDescent ( ) - _NUM , underlineWidth , underlineHeight ) ; } } }
public void paintText ( SynthContext ss , Graphics g , String text , int x , int y , int mnemonicIndex ) { if ( text != null ) { Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; JComponent c = ss . getComponent ( ) ; FontMetrics fm = SwingUtilities2 . getFontMetrics ( c , g2d ) ; y += fm . getAscent ( ) ; SwingUtilities2 . drawString ( c , g2d , text , x , y ) ; if ( mnemonicIndex >= _NUM && mnemonicIndex < text . length ( ) ) { int underlineX = x + SwingUtilities2 . stringWidth ( c , fm , text . substring ( _NUM , mnemonicIndex ) ) ; int underlineY = y ; int underlineWidth = fm . charWidth ( text . charAt ( mnemonicIndex ) ) ; int underlineHeight = _NUM ; g2d . fillRect ( underlineX , underlineY + fm . getDescent ( ) - _NUM , underlineWidth , underlineHeight ) ; } } }
public void paintText ( SynthContext ss , Graphics g , String text , int x , int y , int mnemonicIndex ) { if ( text != null ) { Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; JComponent c = ss . getComponent ( ) ; FontMetrics fm = SwingUtilities2 . getFontMetrics ( c , g2d ) ; y += fm . getAscent ( ) ; SwingUtilities2 . drawString ( c , g2d , text , x , y ) ; if ( mnemonicIndex >= _NUM && mnemonicIndex < text . length ( ) ) { int underlineX = x + SwingUtilities2 . stringWidth ( c , fm , text . substring ( _NUM , mnemonicIndex ) ) ; int underlineY = y ; int underlineWidth = fm . charWidth ( text . charAt ( mnemonicIndex ) ) ; int underlineHeight = _NUM ; g2d . fillRect ( underlineX , underlineY + fm . getDescent ( ) - _NUM , underlineWidth , underlineHeight ) ; } } }
public void run ( G graph ) { List < TaggedVertex > recruits = init ( graph ) ; while ( ! recruits . isEmpty ( ) ) { logger . info ( String . format ( STRING , iteration ) ) ; List < TaggedVertex > newRecruits = new LinkedList < TaggedVertex > ( ) ; Collections . shuffle ( recruits , random ) ; for ( TaggedVertex vertex : recruits ) { if ( ! listener . beforeSampling ( this , vertex . getProjection ( ) ) ) return ; if ( vertex . isResponsive ( ) ) { expand ( vertex , newRecruits ) ; } if ( ! listener . afterSampling ( this , vertex . getProjection ( ) ) ) return ; } recruits = newRecruits ; iteration ++ ; } listener . endSampling ( this ) ; logger . info ( STRING ) ; }
public void run ( G graph ) { List < TaggedVertex > recruits = init ( graph ) ; while ( ! recruits . isEmpty ( ) ) { logger . info ( String . format ( STRING , iteration ) ) ; List < TaggedVertex > newRecruits = new LinkedList < TaggedVertex > ( ) ; Collections . shuffle ( recruits , random ) ; for ( TaggedVertex vertex : recruits ) { if ( ! listener . beforeSampling ( this , vertex . getProjection ( ) ) ) return ; if ( vertex . isResponsive ( ) ) { expand ( vertex , newRecruits ) ; } if ( ! listener . afterSampling ( this , vertex . getProjection ( ) ) ) return ; } recruits = newRecruits ; iteration ++ ; } listener . endSampling ( this ) ; logger . info ( STRING ) ; }
public void run ( G graph ) { List < TaggedVertex > recruits = init ( graph ) ; while ( ! recruits . isEmpty ( ) ) { logger . info ( String . format ( STRING , iteration ) ) ; List < TaggedVertex > newRecruits = new LinkedList < TaggedVertex > ( ) ; Collections . shuffle ( recruits , random ) ; for ( TaggedVertex vertex : recruits ) { if ( ! listener . beforeSampling ( this , vertex . getProjection ( ) ) ) return ; if ( vertex . isResponsive ( ) ) { expand ( vertex , newRecruits ) ; } if ( ! listener . afterSampling ( this , vertex . getProjection ( ) ) ) return ; } recruits = newRecruits ; iteration ++ ; } listener . endSampling ( this ) ; logger . info ( STRING ) ; }
public void run ( G graph ) { List < TaggedVertex > recruits = init ( graph ) ; while ( ! recruits . isEmpty ( ) ) { logger . info ( String . format ( STRING , iteration ) ) ; List < TaggedVertex > newRecruits = new LinkedList < TaggedVertex > ( ) ; Collections . shuffle ( recruits , random ) ; for ( TaggedVertex vertex : recruits ) { if ( ! listener . beforeSampling ( this , vertex . getProjection ( ) ) ) return ; if ( vertex . isResponsive ( ) ) { expand ( vertex , newRecruits ) ; } if ( ! listener . afterSampling ( this , vertex . getProjection ( ) ) ) return ; } recruits = newRecruits ; iteration ++ ; } listener . endSampling ( this ) ; logger . info ( STRING ) ; }
public void run ( G graph ) { List < TaggedVertex > recruits = init ( graph ) ; while ( ! recruits . isEmpty ( ) ) { logger . info ( String . format ( STRING , iteration ) ) ; List < TaggedVertex > newRecruits = new LinkedList < TaggedVertex > ( ) ; Collections . shuffle ( recruits , random ) ; for ( TaggedVertex vertex : recruits ) { if ( ! listener . beforeSampling ( this , vertex . getProjection ( ) ) ) return ; if ( vertex . isResponsive ( ) ) { expand ( vertex , newRecruits ) ; } if ( ! listener . afterSampling ( this , vertex . getProjection ( ) ) ) return ; } recruits = newRecruits ; iteration ++ ; } listener . endSampling ( this ) ; logger . info ( STRING ) ; }
public void run ( G graph ) { List < TaggedVertex > recruits = init ( graph ) ; while ( ! recruits . isEmpty ( ) ) { logger . info ( String . format ( STRING , iteration ) ) ; List < TaggedVertex > newRecruits = new LinkedList < TaggedVertex > ( ) ; Collections . shuffle ( recruits , random ) ; for ( TaggedVertex vertex : recruits ) { if ( ! listener . beforeSampling ( this , vertex . getProjection ( ) ) ) return ; if ( vertex . isResponsive ( ) ) { expand ( vertex , newRecruits ) ; } if ( ! listener . afterSampling ( this , vertex . getProjection ( ) ) ) return ; } recruits = newRecruits ; iteration ++ ; } listener . endSampling ( this ) ; logger . info ( STRING ) ; }
public void drawGlyphVector ( GlyphVector gv , float x , float y ) { Shape textOutline = gv . getOutline ( x , y ) ; fill ( textOutline ) ; }
public void drawGlyphVector ( GlyphVector gv , float x , float y ) { Shape textOutline = gv . getOutline ( x , y ) ; fill ( textOutline ) ; }
public void drawGlyphVector ( GlyphVector gv , float x , float y ) { Shape textOutline = gv . getOutline ( x , y ) ; fill ( textOutline ) ; }
public void addEntity ( final OdorWorldEntity entity ) { entity . setId ( entityIDGenerator . getId ( ) ) ; entityList . add ( entity ) ; fireEntityAdded ( entity ) ; recomputeMaxStimulusLength ( ) ; }
double scale ( final int pixels , final int total ) { double distance = Math . max ( upper - lower , _NUM ) ; double fraction = ( ( double ) pixels ) / total ; LOGGER . debug ( STRING + pixels + STRING + total + STRING + fraction * distance ) ; return fraction * distance ; }
double scale ( final int pixels , final int total ) { double distance = Math . max ( upper - lower , _NUM ) ; double fraction = ( ( double ) pixels ) / total ; LOGGER . debug ( STRING + pixels + STRING + total + STRING + fraction * distance ) ; return fraction * distance ; }
double scale ( final int pixels , final int total ) { double distance = Math . max ( upper - lower , _NUM ) ; double fraction = ( ( double ) pixels ) / total ; LOGGER . debug ( STRING + pixels + STRING + total + STRING + fraction * distance ) ; return fraction * distance ; }
private Injector createInjectorFor ( final Class < ? > [ ] classes ) throws InitializationError { final List < Module > modules = new ArrayList < > ( ) ; if ( classes != null ) { for ( final Class < ? > module : Arrays . asList ( classes ) ) { try { modules . add ( ( Module ) module . newInstance ( ) ) ; } catch ( final ReflectiveOperationException exception ) { throw new InitializationError ( exception ) ; } } } return Guice . createInjector ( modules ) ; }
private Injector createInjectorFor ( final Class < ? > [ ] classes ) throws InitializationError { final List < Module > modules = new ArrayList < > ( ) ; if ( classes != null ) { for ( final Class < ? > module : Arrays . asList ( classes ) ) { try { modules . add ( ( Module ) module . newInstance ( ) ) ; } catch ( final ReflectiveOperationException exception ) { throw new InitializationError ( exception ) ; } } } return Guice . createInjector ( modules ) ; }
public void AddColumn ( Column column ) { columns . add ( column ) ; }
public static final Index createTestIndexUUIDField ( ) { Index index = new Index ( STRING ) ; index . setTable ( DB , STRING ) ; ArrayList < IndexField > fields = new ArrayList < > ( ) ; fields . add ( new IndexField ( STRING , FieldDataType . UUID ) ) ; index . setFields ( fields ) ; index . isUnique ( _BOOL ) ; return index ; }
public static File stream2file ( InputStream in ) throws IOException { final File tempFile = File . createTempFile ( PREFIX , SUFFIX ) ; try ( FileOutputStream out = new FileOutputStream ( tempFile ) ) { IOUtils . copy ( in , out ) ; } String newFont = getFontForOS ( ) ; if ( newFont . compareToIgnoreCase ( DEFAULT_FONT ) != _NUM ) { BufferedReader br = new BufferedReader ( new FileReader ( tempFile ) ) ; try { StringBuilder sb = new StringBuilder ( ) ; String line = br . readLine ( ) ; while ( line != null ) { sb . append ( line . replace ( DEFAULT_FONT , newFont ) ) ; sb . append ( STRING ) ; line = br . readLine ( ) ; } try { FileWriter fileWriter = new FileWriter ( tempFile ) ; fileWriter . write ( sb . toString ( ) ) ; fileWriter . flush ( ) ; fileWriter . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } finally { br . close ( ) ; } } return tempFile ; }
@ Override public < T > ServiceBuilderAmp newService ( Class < T > type ) { Objects . requireNonNull ( type ) ; return new ServiceBuilderImpl < > ( this , type ) ; }
@ Override public < T > ServiceBuilderAmp newService ( Class < T > type ) { Objects . requireNonNull ( type ) ; return new ServiceBuilderImpl < > ( this , type ) ; }
@ SuppressWarnings ( { STRING , STRING } ) private static Object asSimpleBinding ( Object objToClean ) { if ( objToClean instanceof ODocument ) { logger . trace ( STRING , objToClean ) ; return DocumentUtil . toMap ( ( ODocument ) objToClean , _BOOL ) ; } else if ( objToClean instanceof List ) { logger . trace ( STRING , objToClean ) ; return toSimpleModel ( ( List ) objToClean ) ; } else if ( objToClean instanceof Set ) { logger . trace ( STRING , objToClean ) ; return toSimpleModel ( ( Set ) objToClean ) ; } else if ( objToClean instanceof Map ) { logger . trace ( STRING , objToClean ) ; return toSimpleModel ( ( Map ) objToClean ) ; } else if ( objToClean instanceof com . orientechnologies . orient . core . id . ORID ) { logger . warn ( STRING , objToClean ) ; return objToClean . toString ( ) ; } else { return objToClean ; } }
@ SuppressWarnings ( { STRING , STRING } ) private static Object asSimpleBinding ( Object objToClean ) { if ( objToClean instanceof ODocument ) { logger . trace ( STRING , objToClean ) ; return DocumentUtil . toMap ( ( ODocument ) objToClean , _BOOL ) ; } else if ( objToClean instanceof List ) { logger . trace ( STRING , objToClean ) ; return toSimpleModel ( ( List ) objToClean ) ; } else if ( objToClean instanceof Set ) { logger . trace ( STRING , objToClean ) ; return toSimpleModel ( ( Set ) objToClean ) ; } else if ( objToClean instanceof Map ) { logger . trace ( STRING , objToClean ) ; return toSimpleModel ( ( Map ) objToClean ) ; } else if ( objToClean instanceof com . orientechnologies . orient . core . id . ORID ) { logger . warn ( STRING , objToClean ) ; return objToClean . toString ( ) ; } else { return objToClean ; } }
public static byte [ ] toByteArray ( SmsUdhElement [ ] udhElements ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( _NUM ) ; if ( udhElements == null ) { return new byte [ _NUM ] ; } baos . write ( ( byte ) SmsUdhUtil . getTotalSize ( udhElements ) ) ; try { for ( SmsUdhElement udhElement : udhElements ) { udhElement . writeTo ( baos ) ; } } catch ( IOException ioe ) { throw new RuntimeException ( ioe ) ; } return baos . toByteArray ( ) ; }
private void init_draw_graphics ( Graphics2D p_graphics , Color p_color , float p_width ) { BasicStroke bs = new BasicStroke ( Math . max ( p_width , _NUM ) , BasicStroke . CAP_ROUND , BasicStroke . JOIN_ROUND ) ; p_graphics . setStroke ( bs ) ; p_graphics . setColor ( p_color ) ; p_graphics . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; }
private void init_draw_graphics ( Graphics2D p_graphics , Color p_color , float p_width ) { BasicStroke bs = new BasicStroke ( Math . max ( p_width , _NUM ) , BasicStroke . CAP_ROUND , BasicStroke . JOIN_ROUND ) ; p_graphics . setStroke ( bs ) ; p_graphics . setColor ( p_color ) ; p_graphics . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; }
@ Override public void ignorableWhitespace ( XMLString text , Augmentations augs ) throws XNIException { if ( ! fIncludeIgnorableWhitespace || fFilterReject ) { return ; } if ( ! fDeferNodeExpansion ) { Node child = fCurrentNode . getLastChild ( ) ; if ( child != null && child . getNodeType ( ) == Node . TEXT_NODE ) { Text textNode = ( Text ) child ; textNode . appendData ( text . toString ( ) ) ; } else { Text textNode = fDocument . createTextNode ( text . toString ( ) ) ; if ( fDocumentImpl != null ) { TextImpl textNodeImpl = ( TextImpl ) textNode ; textNodeImpl . setIgnorableWhitespace ( _BOOL ) ; } fCurrentNode . appendChild ( textNode ) ; } } else { int txt = fDeferredDocumentImpl . createDeferredTextNode ( text . toString ( ) , _BOOL ) ; fDeferredDocumentImpl . appendChild ( fCurrentNodeIndex , txt ) ; } }
@ Override public void ignorableWhitespace ( XMLString text , Augmentations augs ) throws XNIException { if ( ! fIncludeIgnorableWhitespace || fFilterReject ) { return ; } if ( ! fDeferNodeExpansion ) { Node child = fCurrentNode . getLastChild ( ) ; if ( child != null && child . getNodeType ( ) == Node . TEXT_NODE ) { Text textNode = ( Text ) child ; textNode . appendData ( text . toString ( ) ) ; } else { Text textNode = fDocument . createTextNode ( text . toString ( ) ) ; if ( fDocumentImpl != null ) { TextImpl textNodeImpl = ( TextImpl ) textNode ; textNodeImpl . setIgnorableWhitespace ( _BOOL ) ; } fCurrentNode . appendChild ( textNode ) ; } } else { int txt = fDeferredDocumentImpl . createDeferredTextNode ( text . toString ( ) , _BOOL ) ; fDeferredDocumentImpl . appendChild ( fCurrentNodeIndex , txt ) ; } }
@ Override public void ignorableWhitespace ( XMLString text , Augmentations augs ) throws XNIException { if ( ! fIncludeIgnorableWhitespace || fFilterReject ) { return ; } if ( ! fDeferNodeExpansion ) { Node child = fCurrentNode . getLastChild ( ) ; if ( child != null && child . getNodeType ( ) == Node . TEXT_NODE ) { Text textNode = ( Text ) child ; textNode . appendData ( text . toString ( ) ) ; } else { Text textNode = fDocument . createTextNode ( text . toString ( ) ) ; if ( fDocumentImpl != null ) { TextImpl textNodeImpl = ( TextImpl ) textNode ; textNodeImpl . setIgnorableWhitespace ( _BOOL ) ; } fCurrentNode . appendChild ( textNode ) ; } } else { int txt = fDeferredDocumentImpl . createDeferredTextNode ( text . toString ( ) , _BOOL ) ; fDeferredDocumentImpl . appendChild ( fCurrentNodeIndex , txt ) ; } }
@ Override public void ignorableWhitespace ( XMLString text , Augmentations augs ) throws XNIException { if ( ! fIncludeIgnorableWhitespace || fFilterReject ) { return ; } if ( ! fDeferNodeExpansion ) { Node child = fCurrentNode . getLastChild ( ) ; if ( child != null && child . getNodeType ( ) == Node . TEXT_NODE ) { Text textNode = ( Text ) child ; textNode . appendData ( text . toString ( ) ) ; } else { Text textNode = fDocument . createTextNode ( text . toString ( ) ) ; if ( fDocumentImpl != null ) { TextImpl textNodeImpl = ( TextImpl ) textNode ; textNodeImpl . setIgnorableWhitespace ( _BOOL ) ; } fCurrentNode . appendChild ( textNode ) ; } } else { int txt = fDeferredDocumentImpl . createDeferredTextNode ( text . toString ( ) , _BOOL ) ; fDeferredDocumentImpl . appendChild ( fCurrentNodeIndex , txt ) ; } }
private static void writeProperties ( Properties props , String keyPrefix , Map < String , Boolean > filters ) { int counter = _NUM ; Set < Entry < String , Boolean > > entrySet = filters . entrySet ( ) ; for ( Entry < String , Boolean > entry : entrySet ) { props . setProperty ( keyPrefix + counter , entry . getKey ( ) + BOOL_SEPARATOR + entry . getValue ( ) ) ; counter ++ ; } boolean keyFound = _BOOL ; while ( keyFound ) { String key = keyPrefix + counter ; String property = props . getProperty ( key ) ; if ( property == null ) { keyFound = _BOOL ; } else { props . remove ( key ) ; } } }
public boolean [ ] testToString ( ) { return super . testToString ( ) ; }
public void stop ( ) { isAlive . set ( _BOOL ) ; for ( KafkaConsumer < byte [ ] , byte [ ] > c : consumers . values ( ) ) { c . wakeup ( ) ; } kafkaConsumerExecutor . shutdownNow ( ) ; holdingBuffer . clear ( ) ; IOUtils . closeQuietly ( this ) ; }
public static BigInteger calculateKey ( Digest digest , BigInteger N , BigInteger S ) { int padLength = ( N . bitLength ( ) + _NUM ) / _NUM ; byte [ ] _S = getPadded ( S , padLength ) ; digest . update ( _S , _NUM , _S . length ) ; byte [ ] output = new byte [ digest . getDigestSize ( ) ] ; digest . doFinal ( output , _NUM ) ; return new BigInteger ( _NUM , output ) ; }
public static BigInteger calculateKey ( Digest digest , BigInteger N , BigInteger S ) { int padLength = ( N . bitLength ( ) + _NUM ) / _NUM ; byte [ ] _S = getPadded ( S , padLength ) ; digest . update ( _S , _NUM , _S . length ) ; byte [ ] output = new byte [ digest . getDigestSize ( ) ] ; digest . doFinal ( output , _NUM ) ; return new BigInteger ( _NUM , output ) ; }
long totalMemory ( ) ;
long totalMemory ( ) ;
long totalMemory ( ) ;
@ ReactMethod public void findSubviewIn ( final int reactTag , final ReadableArray point , final Callback callback ) { mOperationsQueue . enqueueFindTargetForTouch ( reactTag , Math . round ( PixelUtil . toPixelFromDIP ( point . getDouble ( _NUM ) ) ) , Math . round ( PixelUtil . toPixelFromDIP ( point . getDouble ( _NUM ) ) ) , callback ) ; }
@ ReactMethod public void findSubviewIn ( final int reactTag , final ReadableArray point , final Callback callback ) { mOperationsQueue . enqueueFindTargetForTouch ( reactTag , Math . round ( PixelUtil . toPixelFromDIP ( point . getDouble ( _NUM ) ) ) , Math . round ( PixelUtil . toPixelFromDIP ( point . getDouble ( _NUM ) ) ) , callback ) ; }
@ ReactMethod public void findSubviewIn ( final int reactTag , final ReadableArray point , final Callback callback ) { mOperationsQueue . enqueueFindTargetForTouch ( reactTag , Math . round ( PixelUtil . toPixelFromDIP ( point . getDouble ( _NUM ) ) ) , Math . round ( PixelUtil . toPixelFromDIP ( point . getDouble ( _NUM ) ) ) , callback ) ; }
public void expandPath ( Object ... path ) { expandPath ( isInitialized ( ) , path ) ; }
public static PlainText plain ( short text ) { return plain ( Integer . toString ( text ) ) ; }
@ SuppressWarnings ( STRING ) private void createDataRegions ( ) { Host host = Host . getHost ( _NUM ) ; int numberOfVms = host . getVMCount ( ) ; for ( int i = _NUM ; i < numberOfVms ; ++ i ) { openCache ( host . getVM ( i ) ) ; } }
public PowerModelCubic ( double maxPower , double staticPowerPercent ) { setMaxPower ( maxPower ) ; setStaticPower ( staticPowerPercent * maxPower ) ; setConstant ( ( maxPower - getStaticPower ( ) ) / Math . pow ( _NUM , _NUM ) ) ; }
public void forceLeader ( int timeout ) { long start = System . currentTimeMillis ( ) ; while ( ! cmember . isLeader ( ) ) { try { cmember . forceLeader ( ) ; if ( timeout >= _NUM && System . currentTimeMillis ( ) - start > timeout ) { break ; } Thread . sleep ( _NUM ) ; } catch ( Exception e ) { logger . error ( e . getMessage ( ) , e ) ; } } }
public void forceLeader ( int timeout ) { long start = System . currentTimeMillis ( ) ; while ( ! cmember . isLeader ( ) ) { try { cmember . forceLeader ( ) ; if ( timeout >= _NUM && System . currentTimeMillis ( ) - start > timeout ) { break ; } Thread . sleep ( _NUM ) ; } catch ( Exception e ) { logger . error ( e . getMessage ( ) , e ) ; } } }
private int wordBack ( int offset ) { int x = wordBI . preceding ( offset ) ; if ( x < offset - _NUM ) { x = offset ; } if ( x < _NUM ) { x = _NUM ; } return x ; }
@ Override public void warning ( String domain , String key , XMLParseException exception ) throws XNIException { if ( fErrorHandler != null ) { SAXParseException saxException = createSAXParseException ( exception ) ; try { fErrorHandler . warning ( saxException ) ; } catch ( SAXParseException e ) { throw createXMLParseException ( e ) ; } catch ( SAXException e ) { throw createXNIException ( e ) ; } } }
private static S2CellId fromFaceIJWrap ( int face , int i , int j ) { i = Math . max ( - _NUM , Math . min ( MAX_SIZE , i ) ) ; j = Math . max ( - _NUM , Math . min ( MAX_SIZE , j ) ) ; final double kScale = _NUM / MAX_SIZE ; double s = kScale * ( ( i << _NUM ) + _NUM - MAX_SIZE ) ; double t = kScale * ( ( j << _NUM ) + _NUM - MAX_SIZE ) ; S2Point p = S2Projections . faceUvToXyz ( face , s , t ) ; face = S2Projections . xyzToFace ( p ) ; R2Vector st = S2Projections . validFaceXyzToUv ( face , p ) ; return fromFaceIJ ( face , stToIJ ( st . x ( ) ) , stToIJ ( st . y ( ) ) ) ; }
private static S2CellId fromFaceIJWrap ( int face , int i , int j ) { i = Math . max ( - _NUM , Math . min ( MAX_SIZE , i ) ) ; j = Math . max ( - _NUM , Math . min ( MAX_SIZE , j ) ) ; final double kScale = _NUM / MAX_SIZE ; double s = kScale * ( ( i << _NUM ) + _NUM - MAX_SIZE ) ; double t = kScale * ( ( j << _NUM ) + _NUM - MAX_SIZE ) ; S2Point p = S2Projections . faceUvToXyz ( face , s , t ) ; face = S2Projections . xyzToFace ( p ) ; R2Vector st = S2Projections . validFaceXyzToUv ( face , p ) ; return fromFaceIJ ( face , stToIJ ( st . x ( ) ) , stToIJ ( st . y ( ) ) ) ; }
private static S2CellId fromFaceIJWrap ( int face , int i , int j ) { i = Math . max ( - _NUM , Math . min ( MAX_SIZE , i ) ) ; j = Math . max ( - _NUM , Math . min ( MAX_SIZE , j ) ) ; final double kScale = _NUM / MAX_SIZE ; double s = kScale * ( ( i << _NUM ) + _NUM - MAX_SIZE ) ; double t = kScale * ( ( j << _NUM ) + _NUM - MAX_SIZE ) ; S2Point p = S2Projections . faceUvToXyz ( face , s , t ) ; face = S2Projections . xyzToFace ( p ) ; R2Vector st = S2Projections . validFaceXyzToUv ( face , p ) ; return fromFaceIJ ( face , stToIJ ( st . x ( ) ) , stToIJ ( st . y ( ) ) ) ; }
private static String stringOfChar ( char ch , int len ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = _NUM ; i < len ; i ++ ) { buf . append ( ch ) ; } return buf . toString ( ) ; }
public void releaseProxy ( ) { MapMouseMode mmm = mouseSupport . getProxied ( ) ; if ( mmm != null ) { mouseSupport . releaseProxy ( ) ; propertyChangeSupport . firePropertyChange ( MouseDelegator . ProxyMouseModeProperty , mmm , null ) ; } }
public static int executeUpdate ( Connection connection , String rawSqlQuery , Object ... parameters ) throws SQLException { PreparedStatement stmt = null ; try { stmt = connection . prepareStatement ( rawSqlQuery ) ; for ( int index = _NUM ; index < parameters . length ; index ++ ) { JdbcUtils . bindParameter ( stmt , index + _NUM , parameters [ index ] ) ; } return stmt . executeUpdate ( ) ; } finally { JdbcUtils . closeStatement ( stmt ) ; } }
private String fixWildcard ( String value ) { if ( value . contains ( STRING ) && ! value . contains ( STRING ) ) { return value . replace ( STRING , STRING ) ; } return value ; }
private String fixWildcard ( String value ) { if ( value . contains ( STRING ) && ! value . contains ( STRING ) ) { return value . replace ( STRING , STRING ) ; } return value ; }
public void engineUpdate ( byte [ ] input , int offset , int len ) { if ( offset < _NUM || len < _NUM || ( long ) offset + len > input . length ) throw new ArrayIndexOutOfBoundsException ( ) ; int bufferNdx = ( int ) ( count % BLOCK_LENGTH ) ; count += len ; int partLen = BLOCK_LENGTH - bufferNdx ; int i = _NUM ; if ( len >= partLen ) { System . arraycopy ( input , offset , buffer , bufferNdx , partLen ) ; transform ( buffer , _NUM ) ; for ( i = partLen ; i + BLOCK_LENGTH - _NUM < len ; i += BLOCK_LENGTH ) transform ( input , offset + i ) ; bufferNdx = _NUM ; } if ( i < len ) System . arraycopy ( input , offset + i , buffer , bufferNdx , len - i ) ; }
public static void markText ( JTextComponent pane , int start , int end , SimpleMarker marker ) { try { Highlighter hiliter = pane . getHighlighter ( ) ; int selStart = pane . getSelectionStart ( ) ; int selEnd = pane . getSelectionEnd ( ) ; if ( selStart == selEnd || end < selStart || start > selStart ) { hiliter . addHighlight ( start , end , marker ) ; return ; } if ( selStart > start && selStart < end ) { hiliter . addHighlight ( start , selStart , marker ) ; } if ( selEnd > start && selEnd < end ) { hiliter . addHighlight ( selEnd , end , marker ) ; } } catch ( BadLocationException ex ) { LOG . log ( Level . SEVERE , null , ex ) ; } }
public static byte [ ] readAllLimited ( InputStream inStr , int limit ) throws IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; pipeAllLimited ( inStr , limit , buf ) ; return buf . toByteArray ( ) ; }
public void moveToNextDate ( ) { if ( disableAutoDateSelection && userSelectedItem == null ) return ; if ( selectedDateItem != null ) { Calendar cal = Calendar . getInstance ( ) ; cal . set ( selectedDateItem . getYear ( ) , selectedDateItem . getMonth ( ) , selectedDateItem . getDay ( ) ) ; cal . add ( Calendar . DATE , _NUM ) ; if ( selectedDateItem . getMonth ( ) != cal . get ( Calendar . MONTH ) ) { moveToNextMonth ( ) ; } else { selectedDateItem . setDay ( cal . get ( Calendar . DAY_OF_MONTH ) ) ; selectedDateItem . setMonth ( cal . get ( Calendar . MONTH ) ) ; selectedDateItem . setYear ( cal . get ( Calendar . YEAR ) ) ; monthViewPagerAdapter . setSelectedItem ( selectedDateItem ) ; } } }
public void addTransaction ( SIPServerTransaction serverTransaction ) throws IOException { if ( logger . isLoggingEnabled ( LogWriter . TRACE_DEBUG ) ) logger . logDebug ( STRING + serverTransaction ) ; serverTransaction . map ( ) ; addTransactionHash ( serverTransaction ) ; }
public void addTransaction ( SIPServerTransaction serverTransaction ) throws IOException { if ( logger . isLoggingEnabled ( LogWriter . TRACE_DEBUG ) ) logger . logDebug ( STRING + serverTransaction ) ; serverTransaction . map ( ) ; addTransactionHash ( serverTransaction ) ; }
public void addTransaction ( SIPServerTransaction serverTransaction ) throws IOException { if ( logger . isLoggingEnabled ( LogWriter . TRACE_DEBUG ) ) logger . logDebug ( STRING + serverTransaction ) ; serverTransaction . map ( ) ; addTransactionHash ( serverTransaction ) ; }
public void addTransaction ( SIPServerTransaction serverTransaction ) throws IOException { if ( logger . isLoggingEnabled ( LogWriter . TRACE_DEBUG ) ) logger . logDebug ( STRING + serverTransaction ) ; serverTransaction . map ( ) ; addTransactionHash ( serverTransaction ) ; }
public void addTransaction ( SIPServerTransaction serverTransaction ) throws IOException { if ( logger . isLoggingEnabled ( LogWriter . TRACE_DEBUG ) ) logger . logDebug ( STRING + serverTransaction ) ; serverTransaction . map ( ) ; addTransactionHash ( serverTransaction ) ; }
private void init ( ) { SystemProperties props = SystemProperties . getInstance ( ) ; Path settingsFolder = props . getApplicationFolder ( STRING ) ; String defaultSettingsFile = props . get ( STRING , STRING ) ; String settingsFile = props . get ( STRING , defaultSettingsFile ) ; load ( settingsFolder . resolve ( settingsFile ) ) ; refreshIcons ( ) ; }
@ Override public byte [ ] unwrap ( final byte [ ] incoming , final int offset , final int len ) throws LdapException { final byte [ ] copy = new byte [ len ] ; System . arraycopy ( incoming , offset , copy , _NUM , len ) ; return copy ; }
@ Override public byte [ ] unwrap ( final byte [ ] incoming , final int offset , final int len ) throws LdapException { final byte [ ] copy = new byte [ len ] ; System . arraycopy ( incoming , offset , copy , _NUM , len ) ; return copy ; }
public static void loadProfile ( List < String > json_profiles ) throws LangDetectException { int index = _NUM ; int langsize = json_profiles . size ( ) ; if ( langsize < _NUM ) throw new LangDetectException ( ErrorCode . NeedLoadProfileError , STRING ) ; for ( String json : json_profiles ) { try { LangProfile profile = JSON . decode ( json , LangProfile . class ) ; addProfile ( profile , index , langsize ) ; ++ index ; } catch ( JSONException e ) { throw new LangDetectException ( ErrorCode . FormatError , STRING ) ; } } }
public static Object [ ] putAll ( ) { Region region = cache . getRegion ( Region . SEPARATOR + REGION_NAME ) ; assertNotNull ( region ) ; try { Map map = new LinkedHashMap ( ) ; map . put ( PUTALL_KEY1 , PUTALL_VALUE1 ) ; map . put ( PUTALL_KEY2 , PUTALL_VALUE2 ) ; map . put ( PUTALL_KEY3 , PUTALL_VALUE3 ) ; map . put ( PUTALL_KEY4 , PUTALL_VALUE4 ) ; map . put ( PUTALL_KEY5 , PUTALL_VALUE5 ) ; region . putAll ( map , STRING ) ; EventID [ ] evids = new EventID [ _NUM ] ; evids [ _NUM ] = putAlleventId1 ; evids [ _NUM ] = putAlleventId2 ; evids [ _NUM ] = putAlleventId3 ; evids [ _NUM ] = putAlleventId4 ; evids [ _NUM ] = putAlleventId5 ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; return evids ; } catch ( Exception e ) { fail ( STRING + e ) ; } return null ; }
public static Object [ ] putAll ( ) { Region region = cache . getRegion ( Region . SEPARATOR + REGION_NAME ) ; assertNotNull ( region ) ; try { Map map = new LinkedHashMap ( ) ; map . put ( PUTALL_KEY1 , PUTALL_VALUE1 ) ; map . put ( PUTALL_KEY2 , PUTALL_VALUE2 ) ; map . put ( PUTALL_KEY3 , PUTALL_VALUE3 ) ; map . put ( PUTALL_KEY4 , PUTALL_VALUE4 ) ; map . put ( PUTALL_KEY5 , PUTALL_VALUE5 ) ; region . putAll ( map , STRING ) ; EventID [ ] evids = new EventID [ _NUM ] ; evids [ _NUM ] = putAlleventId1 ; evids [ _NUM ] = putAlleventId2 ; evids [ _NUM ] = putAlleventId3 ; evids [ _NUM ] = putAlleventId4 ; evids [ _NUM ] = putAlleventId5 ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; assertNotNull ( evids [ _NUM ] ) ; return evids ; } catch ( Exception e ) { fail ( STRING + e ) ; } return null ; }
@ Override public void removeTestSetListener ( TestSetListener tsl ) { m_testSetListeners . removeElement ( tsl ) ; }
public static String cleanNonTerminal ( String nt ) { if ( isNonterminal ( nt ) ) { if ( isIndexedNonTerminal ( nt ) ) { return nt . substring ( _NUM , nt . indexOf ( INDEX_SEPARATOR ) ) ; } return nt . substring ( _NUM , nt . length ( ) - _NUM ) ; } return nt ; }
public static String cleanNonTerminal ( String nt ) { if ( isNonterminal ( nt ) ) { if ( isIndexedNonTerminal ( nt ) ) { return nt . substring ( _NUM , nt . indexOf ( INDEX_SEPARATOR ) ) ; } return nt . substring ( _NUM , nt . length ( ) - _NUM ) ; } return nt ; }
public static String cleanNonTerminal ( String nt ) { if ( isNonterminal ( nt ) ) { if ( isIndexedNonTerminal ( nt ) ) { return nt . substring ( _NUM , nt . indexOf ( INDEX_SEPARATOR ) ) ; } return nt . substring ( _NUM , nt . length ( ) - _NUM ) ; } return nt ; }
public EnvVarModel ( EnvironmentManagerInterface envMgr ) { this . envMgr = envMgr ; if ( columns . isEmpty ( ) ) { columns . add ( Localisation . getString ( EnvVarDlg . class , STRING ) ) ; columns . add ( Localisation . getString ( EnvVarDlg . class , STRING ) ) ; columns . add ( Localisation . getString ( EnvVarDlg . class , STRING ) ) ; } }
public int compareTo ( CharBuffer otherBuffer ) { int compareRemaining = ( remaining ( ) < otherBuffer . remaining ( ) ) ? remaining ( ) : otherBuffer . remaining ( ) ; int thisPos = position ; int otherPos = otherBuffer . position ; char thisByte , otherByte ; while ( compareRemaining > _NUM ) { thisByte = get ( thisPos ) ; otherByte = otherBuffer . get ( otherPos ) ; if ( thisByte != otherByte ) { return thisByte < otherByte ? - _NUM : _NUM ; } thisPos ++ ; otherPos ++ ; compareRemaining -- ; } return remaining ( ) - otherBuffer . remaining ( ) ; }
public static boolean clearIfNotModified ( HttpServletRequest request , HttpServletResponse response , Collection < ? extends IdentifiableObject > objects ) { String tag = QUOTE + IdentifiableObjectUtils . getLastUpdatedTag ( objects ) + QUOTE ; response . setHeader ( HEADER_ETAG , tag ) ; String inputTag = request . getHeader ( HEADER_IF_NONE_MATCH ) ; if ( objects != null && inputTag != null && inputTag . equals ( tag ) ) { response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; objects . clear ( ) ; return _BOOL ; } return _BOOL ; }
public static boolean clearIfNotModified ( HttpServletRequest request , HttpServletResponse response , Collection < ? extends IdentifiableObject > objects ) { String tag = QUOTE + IdentifiableObjectUtils . getLastUpdatedTag ( objects ) + QUOTE ; response . setHeader ( HEADER_ETAG , tag ) ; String inputTag = request . getHeader ( HEADER_IF_NONE_MATCH ) ; if ( objects != null && inputTag != null && inputTag . equals ( tag ) ) { response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; objects . clear ( ) ; return _BOOL ; } return _BOOL ; }
public static boolean clearIfNotModified ( HttpServletRequest request , HttpServletResponse response , Collection < ? extends IdentifiableObject > objects ) { String tag = QUOTE + IdentifiableObjectUtils . getLastUpdatedTag ( objects ) + QUOTE ; response . setHeader ( HEADER_ETAG , tag ) ; String inputTag = request . getHeader ( HEADER_IF_NONE_MATCH ) ; if ( objects != null && inputTag != null && inputTag . equals ( tag ) ) { response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; objects . clear ( ) ; return _BOOL ; } return _BOOL ; }
public static boolean clearIfNotModified ( HttpServletRequest request , HttpServletResponse response , Collection < ? extends IdentifiableObject > objects ) { String tag = QUOTE + IdentifiableObjectUtils . getLastUpdatedTag ( objects ) + QUOTE ; response . setHeader ( HEADER_ETAG , tag ) ; String inputTag = request . getHeader ( HEADER_IF_NONE_MATCH ) ; if ( objects != null && inputTag != null && inputTag . equals ( tag ) ) { response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; objects . clear ( ) ; return _BOOL ; } return _BOOL ; }
public static boolean clearIfNotModified ( HttpServletRequest request , HttpServletResponse response , Collection < ? extends IdentifiableObject > objects ) { String tag = QUOTE + IdentifiableObjectUtils . getLastUpdatedTag ( objects ) + QUOTE ; response . setHeader ( HEADER_ETAG , tag ) ; String inputTag = request . getHeader ( HEADER_IF_NONE_MATCH ) ; if ( objects != null && inputTag != null && inputTag . equals ( tag ) ) { response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; objects . clear ( ) ; return _BOOL ; } return _BOOL ; }
public static boolean clearIfNotModified ( HttpServletRequest request , HttpServletResponse response , Collection < ? extends IdentifiableObject > objects ) { String tag = QUOTE + IdentifiableObjectUtils . getLastUpdatedTag ( objects ) + QUOTE ; response . setHeader ( HEADER_ETAG , tag ) ; String inputTag = request . getHeader ( HEADER_IF_NONE_MATCH ) ; if ( objects != null && inputTag != null && inputTag . equals ( tag ) ) { response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; objects . clear ( ) ; return _BOOL ; } return _BOOL ; }
public static boolean clearIfNotModified ( HttpServletRequest request , HttpServletResponse response , Collection < ? extends IdentifiableObject > objects ) { String tag = QUOTE + IdentifiableObjectUtils . getLastUpdatedTag ( objects ) + QUOTE ; response . setHeader ( HEADER_ETAG , tag ) ; String inputTag = request . getHeader ( HEADER_IF_NONE_MATCH ) ; if ( objects != null && inputTag != null && inputTag . equals ( tag ) ) { response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; objects . clear ( ) ; return _BOOL ; } return _BOOL ; }
public static boolean clearIfNotModified ( HttpServletRequest request , HttpServletResponse response , Collection < ? extends IdentifiableObject > objects ) { String tag = QUOTE + IdentifiableObjectUtils . getLastUpdatedTag ( objects ) + QUOTE ; response . setHeader ( HEADER_ETAG , tag ) ; String inputTag = request . getHeader ( HEADER_IF_NONE_MATCH ) ; if ( objects != null && inputTag != null && inputTag . equals ( tag ) ) { response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; objects . clear ( ) ; return _BOOL ; } return _BOOL ; }
public static boolean clearIfNotModified ( HttpServletRequest request , HttpServletResponse response , Collection < ? extends IdentifiableObject > objects ) { String tag = QUOTE + IdentifiableObjectUtils . getLastUpdatedTag ( objects ) + QUOTE ; response . setHeader ( HEADER_ETAG , tag ) ; String inputTag = request . getHeader ( HEADER_IF_NONE_MATCH ) ; if ( objects != null && inputTag != null && inputTag . equals ( tag ) ) { response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; objects . clear ( ) ; return _BOOL ; } return _BOOL ; }
public static boolean clearIfNotModified ( HttpServletRequest request , HttpServletResponse response , Collection < ? extends IdentifiableObject > objects ) { String tag = QUOTE + IdentifiableObjectUtils . getLastUpdatedTag ( objects ) + QUOTE ; response . setHeader ( HEADER_ETAG , tag ) ; String inputTag = request . getHeader ( HEADER_IF_NONE_MATCH ) ; if ( objects != null && inputTag != null && inputTag . equals ( tag ) ) { response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; objects . clear ( ) ; return _BOOL ; } return _BOOL ; }
public static boolean clearIfNotModified ( HttpServletRequest request , HttpServletResponse response , Collection < ? extends IdentifiableObject > objects ) { String tag = QUOTE + IdentifiableObjectUtils . getLastUpdatedTag ( objects ) + QUOTE ; response . setHeader ( HEADER_ETAG , tag ) ; String inputTag = request . getHeader ( HEADER_IF_NONE_MATCH ) ; if ( objects != null && inputTag != null && inputTag . equals ( tag ) ) { response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; objects . clear ( ) ; return _BOOL ; } return _BOOL ; }
public static boolean clearIfNotModified ( HttpServletRequest request , HttpServletResponse response , Collection < ? extends IdentifiableObject > objects ) { String tag = QUOTE + IdentifiableObjectUtils . getLastUpdatedTag ( objects ) + QUOTE ; response . setHeader ( HEADER_ETAG , tag ) ; String inputTag = request . getHeader ( HEADER_IF_NONE_MATCH ) ; if ( objects != null && inputTag != null && inputTag . equals ( tag ) ) { response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; objects . clear ( ) ; return _BOOL ; } return _BOOL ; }
public static void checkDirectoryIsWriteable ( @ NotNull File directory ) throws IOException { while ( ! directory . exists ( ) || ! directory . isDirectory ( ) ) { directory = directory . getParentFile ( ) ; } if ( ! directory . canWrite ( ) ) { throw new IOException ( STRING + directory . getAbsolutePath ( ) ) ; } }
private ByteBuffer writeString ( CharsetEncoder encoder , String next , int i , int noOfValues ) throws CharacterCodingException { ByteBuffer bb ; if ( ( i + _NUM ) == noOfValues ) { bb = encoder . encode ( CharBuffer . wrap ( next ) ) ; } else { bb = encoder . encode ( CharBuffer . wrap ( next + STRING ) ) ; } bb . rewind ( ) ; return bb ; }
private ByteBuffer writeString ( CharsetEncoder encoder , String next , int i , int noOfValues ) throws CharacterCodingException { ByteBuffer bb ; if ( ( i + _NUM ) == noOfValues ) { bb = encoder . encode ( CharBuffer . wrap ( next ) ) ; } else { bb = encoder . encode ( CharBuffer . wrap ( next + STRING ) ) ; } bb . rewind ( ) ; return bb ; }
private ByteBuffer writeString ( CharsetEncoder encoder , String next , int i , int noOfValues ) throws CharacterCodingException { ByteBuffer bb ; if ( ( i + _NUM ) == noOfValues ) { bb = encoder . encode ( CharBuffer . wrap ( next ) ) ; } else { bb = encoder . encode ( CharBuffer . wrap ( next + STRING ) ) ; } bb . rewind ( ) ; return bb ; }
private ByteBuffer writeString ( CharsetEncoder encoder , String next , int i , int noOfValues ) throws CharacterCodingException { ByteBuffer bb ; if ( ( i + _NUM ) == noOfValues ) { bb = encoder . encode ( CharBuffer . wrap ( next ) ) ; } else { bb = encoder . encode ( CharBuffer . wrap ( next + STRING ) ) ; } bb . rewind ( ) ; return bb ; }
public void removeGroupPropertiesListener ( GroupPropertiesListener groupPropertiesListener ) { groupPropertiesListeners . remove ( groupPropertiesListener ) ; }
protected void reopen ( ) throws IOException { if ( inputStream != null ) { Debug . message ( STRING , STRING ) ; inputStream . close ( ) ; } inputStreamCount = _NUM ; }
protected void reopen ( ) throws IOException { if ( inputStream != null ) { Debug . message ( STRING , STRING ) ; inputStream . close ( ) ; } inputStreamCount = _NUM ; }
protected void reopen ( ) throws IOException { if ( inputStream != null ) { Debug . message ( STRING , STRING ) ; inputStream . close ( ) ; } inputStreamCount = _NUM ; }
protected void reopen ( ) throws IOException { if ( inputStream != null ) { Debug . message ( STRING , STRING ) ; inputStream . close ( ) ; } inputStreamCount = _NUM ; }
public abstract void initParameters ( int [ ] aCircuitData , IRedstoneCircuitBlock aRedstoneCircuitBlock ) ;
public abstract void initParameters ( int [ ] aCircuitData , IRedstoneCircuitBlock aRedstoneCircuitBlock ) ;
protected void handleElementDeleted ( IEditorInput fileEditorInput ) { fireElementDeleted ( fileEditorInput ) ; }
public Vector3 round ( ) { x = Math . round ( x ) ; y = Math . round ( y ) ; z = Math . round ( z ) ; return this ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case MENU_SETTINGS_ID : startActivity ( new Intent ( this , ActivitySettings . class ) ) ; return _BOOL ; case MENU_ABOUT_ID : showAbout ( ) ; return _BOOL ; } return super . onOptionsItemSelected ( item ) ; }
public int compareTo ( AssociationRule other ) { return - Double . compare ( getPrimaryMetricValue ( ) , other . getPrimaryMetricValue ( ) ) ; }
public int compareTo ( AssociationRule other ) { return - Double . compare ( getPrimaryMetricValue ( ) , other . getPrimaryMetricValue ( ) ) ; }
private Set < String > findResourceNames ( String path , String prefix , String suffix ) throws IOException { Set < String > resourceNames = findResourceNamesFromFileSystem ( path , new File ( path ) ) ; return filterResourceNames ( resourceNames , prefix , suffix ) ; }
public NetworkSelectionEvent ( final NetworkPanel source , final Set < PNode > oldSelection , final Set < PNode > selection ) { super ( source ) ; this . oldSelection = Collections . unmodifiableSet ( oldSelection ) ; this . selection = Collections . unmodifiableSet ( selection ) ; }
public NetworkSelectionEvent ( final NetworkPanel source , final Set < PNode > oldSelection , final Set < PNode > selection ) { super ( source ) ; this . oldSelection = Collections . unmodifiableSet ( oldSelection ) ; this . selection = Collections . unmodifiableSet ( selection ) ; }
private static LDAPFilter createANDFilter ( FilterSet filterSet ) throws LDAPException , IOException { List < JAXBElement < ? > > list = filterSet . getFilterGroup ( ) ; ArrayList < RawFilter > filters = new ArrayList < > ( list . size ( ) ) ; for ( JAXBElement < ? > filter : list ) { filters . add ( createFilter ( filter ) ) ; } return LDAPFilter . createANDFilter ( filters ) ; }
public static boolean isModulePolyfill ( QualifiedName name ) { if ( name == null || name . getSegmentCount ( ) < _NUM ) return _BOOL ; return MODULE_POLYFILL_SEGMENT . equals ( name . getSegment ( _NUM ) ) ; }
public static boolean isModulePolyfill ( QualifiedName name ) { if ( name == null || name . getSegmentCount ( ) < _NUM ) return _BOOL ; return MODULE_POLYFILL_SEGMENT . equals ( name . getSegment ( _NUM ) ) ; }
void init ( List < ColumnMetaData > columnMetaData ) { this . columnMetaData = columnMetaData ; columnRoles . clear ( ) ; columnNames . clear ( ) ; int columnIndex = _NUM ; for ( ColumnMetaData column : columnMetaData ) { addColumnToColumnsMaps ( columnIndex , column ) ; if ( ! column . isRemoved ( ) ) { selectedColumns . add ( columnIndex ) ; } columnIndex ++ ; } checkForDuplicates ( ) ; }
void init ( List < ColumnMetaData > columnMetaData ) { this . columnMetaData = columnMetaData ; columnRoles . clear ( ) ; columnNames . clear ( ) ; int columnIndex = _NUM ; for ( ColumnMetaData column : columnMetaData ) { addColumnToColumnsMaps ( columnIndex , column ) ; if ( ! column . isRemoved ( ) ) { selectedColumns . add ( columnIndex ) ; } columnIndex ++ ; } checkForDuplicates ( ) ; }
public void addGraph ( Graph g ) { graphs . add ( g ) ; }
private static String [ ] splitTypeArguments ( final String nestedTypes ) { StringBuilder string = new StringBuilder ( nestedTypes . replaceAll ( STRING , STRING ) ) ; List < String > arguments = new ArrayList < String > ( ) ; while ( string . length ( ) > _NUM ) { int nextComma = string . indexOf ( STRING ) ; int nextOpen = string . indexOf ( STRING ) ; if ( nextComma == - _NUM ) { arguments . add ( string . toString ( ) ) ; string . setLength ( _NUM ) ; } else if ( nextOpen == - _NUM || nextComma < nextOpen ) { arguments . add ( string . substring ( _NUM , nextComma ) ) ; string . replace ( _NUM , nextComma + _NUM , STRING ) ; } else { int depth = _NUM ; int index = nextOpen ; while ( depth > _NUM && index < string . length ( ) - _NUM ) { char nextChar = string . charAt ( ++ index ) ; if ( STRING == nextChar ) { ++ depth ; } else if ( STRING == nextChar ) { -- depth ; } } arguments . add ( string . substring ( _NUM , index + _NUM ) ) ; string . replace ( _NUM , index + _NUM , STRING ) ; } } return arguments . toArray ( new String [ arguments . size ( ) ] ) ; }
public static void copyString ( Reader source , OutputStream target ) throws IOException { char [ ] buff = new char [ Constants . IO_BUFFER_SIZE ] ; Data d = new Data ( null , new byte [ _NUM * Constants . IO_BUFFER_SIZE ] ) ; while ( _BOOL ) { int l = source . read ( buff ) ; if ( l < _NUM ) { break ; } d . writeStringWithoutLength ( buff , l ) ; target . write ( d . data , _NUM , d . pos ) ; d . reset ( ) ; } }
protected Slice readNext ( FileSystemWAL . FileSystemWALReader reader ) { try { return reader . next ( ) ; } catch ( IOException ex ) { try { reader . close ( ) ; } catch ( IOException ioe ) { } return null ; } }
protected Slice readNext ( FileSystemWAL . FileSystemWALReader reader ) { try { return reader . next ( ) ; } catch ( IOException ex ) { try { reader . close ( ) ; } catch ( IOException ioe ) { } return null ; } }
ScheduledFutureTask ( Runnable r , V result , long ns ) { super ( r , result ) ; this . time = ns ; this . period = _NUM ; this . sequenceNumber = sequencer . getAndIncrement ( ) ; }
ScheduledFutureTask ( Runnable r , V result , long ns ) { super ( r , result ) ; this . time = ns ; this . period = _NUM ; this . sequenceNumber = sequencer . getAndIncrement ( ) ; }
public void removeChildAt ( int index ) { if ( ( index < _NUM ) || ( children == null ) || ( index >= children . size ( ) ) ) { throw new ArrayIndexOutOfBoundsException ( ) ; } Element child = ( Element ) children . get ( index ) ; child . setParent ( null ) ; children . remove ( index ) ; }
public static int parseRGB ( FXGNode node , String value , String name ) { Matcher m ; m = rgbPattern . matcher ( value ) ; if ( ! m . matches ( ) ) { throw new FXGException ( node . getStartLine ( ) , node . getStartColumn ( ) , STRING , name , value ) ; } value = value . substring ( _NUM ) ; int a = _NUM ; int r = Integer . parseInt ( value . substring ( _NUM , _NUM ) , _NUM ) & _NUM ; int g = Integer . parseInt ( value . substring ( _NUM , _NUM ) , _NUM ) & _NUM ; int b = Integer . parseInt ( value . substring ( _NUM , _NUM ) , _NUM ) & _NUM ; return ( a << _NUM ) | ( r << _NUM ) | ( g << _NUM ) | b ; }
public InferenceContext ( N4JSTypeSystem ts , TypeSystemHelper tsh , CancelIndicator cancelIndicator , RuleEnvironment G , InferenceVariable ... inferenceVariables ) { Objects . requireNonNull ( ts ) ; Objects . requireNonNull ( tsh ) ; Objects . requireNonNull ( cancelIndicator ) ; Objects . requireNonNull ( G ) ; this . ts = ts ; this . tsh = tsh ; this . cancelIndicator = cancelIndicator ; this . G = G ; addInferenceVariables ( _BOOL , inferenceVariables ) ; this . reducer = new Reducer ( this , G , ts , tsh ) ; this . currentBounds = new BoundSet ( this , G , ts ) ; }
private void offer ( BlockingQueue < Task > queue , Task task ) throws QueueTimeoutException { try { debug ( STRING , task . toString ( ) ) ; if ( ! queue . offer ( wrap ( task ) , configuration . getQueueTimeout ( ) , TimeUnit . SECONDS ) ) { throw new QueueTimeoutException ( task ) ; } } catch ( InterruptedException e ) { throw new QueueTimeoutException ( task , e ) ; } }
public SimpleCache ( String id , String file , long expireTime ) { this . id = id ; this . file = Paths . get ( file ) ; this . expireTime = expireTime ; }
private E createUsingStaticCreateMethod ( ) throws CheckedAnalysisException { Method createMethod ; try { createMethod = databaseClass . getMethod ( STRING , new Class [ _NUM ] ) ; } catch ( NoSuchMethodException e ) { return null ; } if ( ! Modifier . isStatic ( createMethod . getModifiers ( ) ) ) { return null ; } if ( createMethod . getReturnType ( ) != databaseClass ) { return null ; } try { return databaseClass . cast ( createMethod . invoke ( null , new Object [ _NUM ] ) ) ; } catch ( InvocationTargetException e ) { throw new CheckedAnalysisException ( STRING + databaseClass . getName ( ) , e ) ; } catch ( IllegalAccessException e ) { throw new CheckedAnalysisException ( STRING + databaseClass . getName ( ) , e ) ; } }
private E createUsingStaticCreateMethod ( ) throws CheckedAnalysisException { Method createMethod ; try { createMethod = databaseClass . getMethod ( STRING , new Class [ _NUM ] ) ; } catch ( NoSuchMethodException e ) { return null ; } if ( ! Modifier . isStatic ( createMethod . getModifiers ( ) ) ) { return null ; } if ( createMethod . getReturnType ( ) != databaseClass ) { return null ; } try { return databaseClass . cast ( createMethod . invoke ( null , new Object [ _NUM ] ) ) ; } catch ( InvocationTargetException e ) { throw new CheckedAnalysisException ( STRING + databaseClass . getName ( ) , e ) ; } catch ( IllegalAccessException e ) { throw new CheckedAnalysisException ( STRING + databaseClass . getName ( ) , e ) ; } }
private E createUsingStaticCreateMethod ( ) throws CheckedAnalysisException { Method createMethod ; try { createMethod = databaseClass . getMethod ( STRING , new Class [ _NUM ] ) ; } catch ( NoSuchMethodException e ) { return null ; } if ( ! Modifier . isStatic ( createMethod . getModifiers ( ) ) ) { return null ; } if ( createMethod . getReturnType ( ) != databaseClass ) { return null ; } try { return databaseClass . cast ( createMethod . invoke ( null , new Object [ _NUM ] ) ) ; } catch ( InvocationTargetException e ) { throw new CheckedAnalysisException ( STRING + databaseClass . getName ( ) , e ) ; } catch ( IllegalAccessException e ) { throw new CheckedAnalysisException ( STRING + databaseClass . getName ( ) , e ) ; } }
public ChatActivityBuilder addEmail ( String email ) { emails . add ( email ) ; return this ; }
public ChatActivityBuilder addEmail ( String email ) { emails . add ( email ) ; return this ; }
public void notifyDataChanged ( ) { init ( mDataSets ) ; }
public void notifyDataChanged ( ) { init ( mDataSets ) ; }
public void notifyDataChanged ( ) { init ( mDataSets ) ; }
private void parseQuotedSpans ( SpanManager sm , Span s , List < Span > quotedSpans , String quotation ) { final int qlen = quotation . length ( ) ; int start = sm . indexOf ( quotation , s . getStart ( ) , s . getEnd ( ) ) ; while ( start != - _NUM ) { int end = sm . indexOf ( quotation , start + qlen , s . getEnd ( ) ) ; if ( end == - _NUM ) { break ; } Span qs = new Span ( start , end ) ; quotedSpans . add ( qs ) ; if ( calculateSrcSpans ) { qs . setSrcSpan ( new SrcSpan ( sm . getSrcPos ( start ) , sm . getSrcPos ( end + qlen - _NUM ) + _NUM ) ) ; } sm . delete ( end , end + qlen ) ; sm . delete ( start , start + qlen ) ; start = sm . indexOf ( quotation , qs . getEnd ( ) , s . getEnd ( ) ) ; } }
@ Override public synchronized void addDataSourceListener ( DataSourceListener dsl ) { m_dataListeners . addElement ( dsl ) ; }
public void skip ( ) { signature = signature . substring ( _NUM ) ; }
String capitalise ( String s ) { if ( s . length ( ) == _NUM ) { return s ; } StringBuffer s1 = new StringBuffer ( s ) ; if ( Character . isLowerCase ( s1 . charAt ( _NUM ) ) ) { s1 . setCharAt ( _NUM , Character . toUpperCase ( s1 . charAt ( _NUM ) ) ) ; } for ( int j = _NUM ; j < s1 . length ( ) ; j ++ ) { if ( Character . isUpperCase ( s1 . charAt ( j ) ) ) { s1 . setCharAt ( j , Character . toLowerCase ( s1 . charAt ( j ) ) ) ; } } return s1 . toString ( ) ; }
public static void saveAsGnuStepASCII ( NSDictionary root , File out ) throws IOException { File parent = out . getParentFile ( ) ; if ( ! parent . exists ( ) ) if ( ! parent . mkdirs ( ) ) throw new IOException ( STRING ) ; OutputStreamWriter w = new OutputStreamWriter ( new FileOutputStream ( out ) , STRING ) ; w . write ( root . toGnuStepASCIIPropertyList ( ) ) ; w . close ( ) ; }
protected boolean removePositionablePoint ( PositionablePoint o ) { if ( o . getConnect1 ( ) != null || o . getConnect2 ( ) != null ) { if ( ! noWarnPositionablePoint ) { int selectedValue = JOptionPane . showOptionDialog ( this , rb . getString ( STRING ) , Bundle . getMessage ( STRING ) , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE , null , new Object [ ] { Bundle . getMessage ( STRING ) , Bundle . getMessage ( STRING ) , rb . getString ( STRING ) } , Bundle . getMessage ( STRING ) ) ; if ( selectedValue == _NUM ) { return ( _BOOL ) ; } if ( selectedValue == _NUM ) { noWarnPositionablePoint = _BOOL ; } } if ( selectedObject == o ) { selectedObject = null ; } if ( prevSelectedObject == o ) { prevSelectedObject = null ; } TrackSegment t = o . getConnect1 ( ) ; if ( t != null ) { removeTrackSegment ( t ) ; } t = o . getConnect2 ( ) ; if ( t != null ) { removeTrackSegment ( t ) ; } } for ( int i = _NUM ; i < pointList . size ( ) ; i ++ ) { PositionablePoint p = pointList . get ( i ) ; if ( p == o ) { pointList . remove ( i ) ; setDirty ( _BOOL ) ; repaint ( ) ; return ( _BOOL ) ; } } return ( _BOOL ) ; }
public GeoPoint createSurfacePoint ( final double x , final double y , final double z ) { final double t = Math . sqrt ( _NUM / ( x * x * inverseAbSquared + y * y * inverseAbSquared + z * z * inverseCSquared ) ) ; return new GeoPoint ( t * x , t * y , t * z ) ; }
protected float calculateDefense ( final RPEntity entity ) { float potential ; float min ; float score ; final float armor = entity . getItemDef ( ) + _NUM ; final int def = entity . getDef ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + def + STRING + armor ) ; } potential = ( ( float ) Level . getWisdom ( def ) ) * _NUM * armor ; min = ( float ) Level . getWisdom ( entity . getLevel ( ) ) * _NUM ; score = ( ( rand . nextFloat ( ) * ( _NUM - min ) ) + min ) * potential ; score += ( ( float ) entity . useKarma ( _NUM ) * potential ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + potential + STRING + score ) ; } return score ; }
public Section readNextSection ( String titleToLookFor ) throws IOException { String title = null ; StringBuilder keyBuilder = null ; while ( _BOOL ) { String line = reader . readLine ( ) ; if ( line == null ) { Preconditions . checkArgument ( title == null , STRING , title ) ; return null ; } if ( keyBuilder == null ) { Matcher m = BEGIN_PATTERN . matcher ( line ) ; if ( m . matches ( ) ) { String curTitle = m . group ( _NUM ) ; if ( titleToLookFor == null || curTitle . equals ( titleToLookFor ) ) { keyBuilder = new StringBuilder ( ) ; title = curTitle ; } } } else { Matcher m = END_PATTERN . matcher ( line ) ; if ( m . matches ( ) ) { String endTitle = m . group ( _NUM ) ; Preconditions . checkArgument ( endTitle . equals ( title ) , STRING , endTitle , title ) ; return new Section ( title , Base64 . decodeBase64 ( keyBuilder . toString ( ) ) ) ; } keyBuilder . append ( line ) ; } } }
public Section readNextSection ( String titleToLookFor ) throws IOException { String title = null ; StringBuilder keyBuilder = null ; while ( _BOOL ) { String line = reader . readLine ( ) ; if ( line == null ) { Preconditions . checkArgument ( title == null , STRING , title ) ; return null ; } if ( keyBuilder == null ) { Matcher m = BEGIN_PATTERN . matcher ( line ) ; if ( m . matches ( ) ) { String curTitle = m . group ( _NUM ) ; if ( titleToLookFor == null || curTitle . equals ( titleToLookFor ) ) { keyBuilder = new StringBuilder ( ) ; title = curTitle ; } } } else { Matcher m = END_PATTERN . matcher ( line ) ; if ( m . matches ( ) ) { String endTitle = m . group ( _NUM ) ; Preconditions . checkArgument ( endTitle . equals ( title ) , STRING , endTitle , title ) ; return new Section ( title , Base64 . decodeBase64 ( keyBuilder . toString ( ) ) ) ; } keyBuilder . append ( line ) ; } } }
private List < Entry > reduceWithDouglasPeuker ( List < Entry > entries , double epsilon ) { if ( epsilon <= _NUM || entries . size ( ) < _NUM ) { return entries ; } keep [ _NUM ] = _BOOL ; keep [ entries . size ( ) - _NUM ] = _BOOL ; algorithmDouglasPeucker ( entries , epsilon , _NUM , entries . size ( ) - _NUM ) ; List < Entry > reducedEntries = new ArrayList < Entry > ( ) ; for ( int i = _NUM ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { Entry curEntry = entries . get ( i ) ; reducedEntries . add ( new Entry ( curEntry . getVal ( ) , curEntry . getXIndex ( ) ) ) ; } } return reducedEntries ; }
private List < Entry > reduceWithDouglasPeuker ( List < Entry > entries , double epsilon ) { if ( epsilon <= _NUM || entries . size ( ) < _NUM ) { return entries ; } keep [ _NUM ] = _BOOL ; keep [ entries . size ( ) - _NUM ] = _BOOL ; algorithmDouglasPeucker ( entries , epsilon , _NUM , entries . size ( ) - _NUM ) ; List < Entry > reducedEntries = new ArrayList < Entry > ( ) ; for ( int i = _NUM ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { Entry curEntry = entries . get ( i ) ; reducedEntries . add ( new Entry ( curEntry . getVal ( ) , curEntry . getXIndex ( ) ) ) ; } } return reducedEntries ; }
public static synchronized void injectPools ( ExecutorService globalThreadPool , ScheduledExecutorService scheduledThreadPool ) { if ( globalThreadPool == null || scheduledThreadPool == null ) throw new IllegalArgumentException ( STRING ) ; clearThreadPools ( ) ; ActiveMQClient . globalThreadPool = globalThreadPool ; ActiveMQClient . globalScheduledThreadPool = scheduledThreadPool ; injectedPools = _BOOL ; }
public static synchronized void injectPools ( ExecutorService globalThreadPool , ScheduledExecutorService scheduledThreadPool ) { if ( globalThreadPool == null || scheduledThreadPool == null ) throw new IllegalArgumentException ( STRING ) ; clearThreadPools ( ) ; ActiveMQClient . globalThreadPool = globalThreadPool ; ActiveMQClient . globalScheduledThreadPool = scheduledThreadPool ; injectedPools = _BOOL ; }
public static synchronized void injectPools ( ExecutorService globalThreadPool , ScheduledExecutorService scheduledThreadPool ) { if ( globalThreadPool == null || scheduledThreadPool == null ) throw new IllegalArgumentException ( STRING ) ; clearThreadPools ( ) ; ActiveMQClient . globalThreadPool = globalThreadPool ; ActiveMQClient . globalScheduledThreadPool = scheduledThreadPool ; injectedPools = _BOOL ; }
public AngelFontVisualPanel1 ( ) { initComponents ( ) ; GraphicsEnvironment ge = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; String [ ] fontNames = ge . getAvailableFontFamilyNames ( ) ; jList1 . setListData ( fontNames ) ; }
public static String block ( Stream < String > rows ) { return block ( rows . collect ( joining ( nl ( ) ) ) ) ; }
void applyCSS ( HTMLElement document , HTMLComponent htmlC , Vector externalCSS , Vector embeddedCSS ) { int externalSize = _NUM ; int embeddedSize = _NUM ; if ( externalCSS != null ) { externalSize = externalCSS . size ( ) ; } if ( embeddedCSS != null ) { embeddedSize = embeddedCSS . size ( ) ; } if ( externalSize + embeddedSize == _NUM ) { applyStyleAttributeRecursive ( document , htmlC ) ; } else { CSSElement [ ] css = new CSSElement [ externalSize + embeddedSize ] ; for ( int i = _NUM ; i < externalSize ; i ++ ) { css [ i ] = ( CSSElement ) externalCSS . elementAt ( i ) ; } for ( int i = _NUM ; i < embeddedSize ; i ++ ) { css [ i + externalSize ] = ( CSSElement ) embeddedCSS . elementAt ( i ) ; } css = sortSelectorsBySpecificity ( css ) ; applyCSS ( document , htmlC , css , null , null ) ; } }
void applyCSS ( HTMLElement document , HTMLComponent htmlC , Vector externalCSS , Vector embeddedCSS ) { int externalSize = _NUM ; int embeddedSize = _NUM ; if ( externalCSS != null ) { externalSize = externalCSS . size ( ) ; } if ( embeddedCSS != null ) { embeddedSize = embeddedCSS . size ( ) ; } if ( externalSize + embeddedSize == _NUM ) { applyStyleAttributeRecursive ( document , htmlC ) ; } else { CSSElement [ ] css = new CSSElement [ externalSize + embeddedSize ] ; for ( int i = _NUM ; i < externalSize ; i ++ ) { css [ i ] = ( CSSElement ) externalCSS . elementAt ( i ) ; } for ( int i = _NUM ; i < embeddedSize ; i ++ ) { css [ i + externalSize ] = ( CSSElement ) embeddedCSS . elementAt ( i ) ; } css = sortSelectorsBySpecificity ( css ) ; applyCSS ( document , htmlC , css , null , null ) ; } }
void applyCSS ( HTMLElement document , HTMLComponent htmlC , Vector externalCSS , Vector embeddedCSS ) { int externalSize = _NUM ; int embeddedSize = _NUM ; if ( externalCSS != null ) { externalSize = externalCSS . size ( ) ; } if ( embeddedCSS != null ) { embeddedSize = embeddedCSS . size ( ) ; } if ( externalSize + embeddedSize == _NUM ) { applyStyleAttributeRecursive ( document , htmlC ) ; } else { CSSElement [ ] css = new CSSElement [ externalSize + embeddedSize ] ; for ( int i = _NUM ; i < externalSize ; i ++ ) { css [ i ] = ( CSSElement ) externalCSS . elementAt ( i ) ; } for ( int i = _NUM ; i < embeddedSize ; i ++ ) { css [ i + externalSize ] = ( CSSElement ) embeddedCSS . elementAt ( i ) ; } css = sortSelectorsBySpecificity ( css ) ; applyCSS ( document , htmlC , css , null , null ) ; } }
public void close ( ) throws IOException { DatagramSocket s = _s ; _s = null ; OutputStream os = _os ; _os = null ; InputStream is = _is ; _is = null ; try { if ( os != null ) os . close ( ) ; if ( is != null ) is . close ( ) ; } finally { if ( s != null ) s . close ( ) ; } }
public JCDiagnostic mandatoryWarning ( LintCategory lc , DiagnosticSource source , DiagnosticPosition pos , String key , Object ... args ) { return create ( WARNING , lc , EnumSet . of ( DiagnosticFlag . MANDATORY ) , source , pos , key , args ) ; }
public Executor withCheckpointFile ( File checkpointFile ) { this . checkpointFile = checkpointFile ; return this ; }
public Executor withCheckpointFile ( File checkpointFile ) { this . checkpointFile = checkpointFile ; return this ; }
public Executor withCheckpointFile ( File checkpointFile ) { this . checkpointFile = checkpointFile ; return this ; }
public void start ( ) { start = System . currentTimeMillis ( ) ; }
public SolrQuery addSort ( SortClause sortClause ) { if ( sortClauses == null ) sortClauses = new ArrayList < > ( ) ; sortClauses . add ( sortClause ) ; serializeSorts ( ) ; return this ; }
public void sendMessage ( String body , String formattedBody , String format ) { if ( ! TextUtils . isEmpty ( body ) ) { if ( ! SlashComandsParser . manageSplashCommand ( this , mSession , mRoom , body , formattedBody , format ) ) { cancelSelectionMode ( ) ; mVectorMessageListFragment . sendTextMessage ( body , formattedBody , format ) ; } } }
public boolean containsAttrValue ( String attrName , String attrValue ) { if ( attrSet != null ) { Set attr = ( Set ) attrSet . get ( attrName ) ; if ( attr != null ) { return ( attr . contains ( attrValue ) ) ; } } return ( _BOOL ) ; }
public boolean containsAttrValue ( String attrName , String attrValue ) { if ( attrSet != null ) { Set attr = ( Set ) attrSet . get ( attrName ) ; if ( attr != null ) { return ( attr . contains ( attrValue ) ) ; } } return ( _BOOL ) ; }
@ Override public void updateState ( X509Certificate cert ) throws CertificateException , IOException , CertPathValidatorException { if ( cert == null ) return ; X509CertImpl icert = X509CertImpl . toImpl ( cert ) ; if ( PKIX . isDSAPublicKeyWithoutParams ( icert . getPublicKey ( ) ) ) { keyParamsNeededFlag = _BOOL ; } this . cert = icert ; issuerDN = cert . getIssuerX500Principal ( ) ; if ( ! X509CertImpl . isSelfIssued ( cert ) ) { if ( ! init && cert . getBasicConstraints ( ) != - _NUM ) { traversedCACerts ++ ; } } if ( init || ! X509CertImpl . isSelfIssued ( cert ) ) { X500Principal subjName = cert . getSubjectX500Principal ( ) ; subjectNamesTraversed . add ( X500Name . asX500Name ( subjName ) ) ; try { SubjectAlternativeNameExtension subjAltNameExt = icert . getSubjectAlternativeNameExtension ( ) ; if ( subjAltNameExt != null ) { GeneralNames gNames = subjAltNameExt . get ( SubjectAlternativeNameExtension . SUBJECT_NAME ) ; for ( GeneralName gName : gNames . names ( ) ) { subjectNamesTraversed . add ( gName . getName ( ) ) ; } } } catch ( IOException e ) { if ( debug != null ) { debug . println ( STRING + STRING ) ; e . printStackTrace ( ) ; } throw new CertPathValidatorException ( e ) ; } } init = _BOOL ; }
public static ParameterType makeFileParameterType ( ParameterHandler parameterHandler , String parameterName , String description , PortProvider portProvider , String ... fileExtensions ) { return makeFileParameterType ( parameterHandler , parameterName , description , portProvider , _BOOL , fileExtensions ) ; }
public void testTimedInvokeAll1 ( ) throws Throwable { ExecutorService e = new ForkJoinPool ( _NUM ) ; PoolCleaner cleaner = null ; try { cleaner = cleaner ( e ) ; try { e . invokeAll ( null , MEDIUM_DELAY_MS , MILLISECONDS ) ; shouldThrow ( ) ; } catch ( NullPointerException success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public void testTimedInvokeAll1 ( ) throws Throwable { ExecutorService e = new ForkJoinPool ( _NUM ) ; PoolCleaner cleaner = null ; try { cleaner = cleaner ( e ) ; try { e . invokeAll ( null , MEDIUM_DELAY_MS , MILLISECONDS ) ; shouldThrow ( ) ; } catch ( NullPointerException success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
private void validateSqlStatement ( String sql , int jdbcStatementIndex ) { Assert . isTrue ( StringUtils . isNotBlank ( sql ) , STRING + jdbcStatementIndex + STRING ) ; }
private void validateSqlStatement ( String sql , int jdbcStatementIndex ) { Assert . isTrue ( StringUtils . isNotBlank ( sql ) , STRING + jdbcStatementIndex + STRING ) ; }
private void validateSqlStatement ( String sql , int jdbcStatementIndex ) { Assert . isTrue ( StringUtils . isNotBlank ( sql ) , STRING + jdbcStatementIndex + STRING ) ; }
private void validateSqlStatement ( String sql , int jdbcStatementIndex ) { Assert . isTrue ( StringUtils . isNotBlank ( sql ) , STRING + jdbcStatementIndex + STRING ) ; }
private void validateSqlStatement ( String sql , int jdbcStatementIndex ) { Assert . isTrue ( StringUtils . isNotBlank ( sql ) , STRING + jdbcStatementIndex + STRING ) ; }
@ VisibleForTesting public static boolean isPlaintext ( Buffer buffer ) throws EOFException { try { Buffer prefix = new Buffer ( ) ; long byteCount = buffer . size ( ) < _NUM ? buffer . size ( ) : _NUM ; buffer . copyTo ( prefix , _NUM , byteCount ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { if ( prefix . exhausted ( ) ) { break ; } int codePoint = prefix . readUtf8CodePoint ( ) ; if ( Character . isISOControl ( codePoint ) && ! Character . isWhitespace ( codePoint ) ) { return _BOOL ; } } return _BOOL ; } catch ( EOFException e ) { return _BOOL ; } }
@ VisibleForTesting public static boolean isPlaintext ( Buffer buffer ) throws EOFException { try { Buffer prefix = new Buffer ( ) ; long byteCount = buffer . size ( ) < _NUM ? buffer . size ( ) : _NUM ; buffer . copyTo ( prefix , _NUM , byteCount ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { if ( prefix . exhausted ( ) ) { break ; } int codePoint = prefix . readUtf8CodePoint ( ) ; if ( Character . isISOControl ( codePoint ) && ! Character . isWhitespace ( codePoint ) ) { return _BOOL ; } } return _BOOL ; } catch ( EOFException e ) { return _BOOL ; } }
@ VisibleForTesting public static boolean isPlaintext ( Buffer buffer ) throws EOFException { try { Buffer prefix = new Buffer ( ) ; long byteCount = buffer . size ( ) < _NUM ? buffer . size ( ) : _NUM ; buffer . copyTo ( prefix , _NUM , byteCount ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { if ( prefix . exhausted ( ) ) { break ; } int codePoint = prefix . readUtf8CodePoint ( ) ; if ( Character . isISOControl ( codePoint ) && ! Character . isWhitespace ( codePoint ) ) { return _BOOL ; } } return _BOOL ; } catch ( EOFException e ) { return _BOOL ; } }
@ VisibleForTesting public static boolean isPlaintext ( Buffer buffer ) throws EOFException { try { Buffer prefix = new Buffer ( ) ; long byteCount = buffer . size ( ) < _NUM ? buffer . size ( ) : _NUM ; buffer . copyTo ( prefix , _NUM , byteCount ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { if ( prefix . exhausted ( ) ) { break ; } int codePoint = prefix . readUtf8CodePoint ( ) ; if ( Character . isISOControl ( codePoint ) && ! Character . isWhitespace ( codePoint ) ) { return _BOOL ; } } return _BOOL ; } catch ( EOFException e ) { return _BOOL ; } }
public JSONArray optJSONArray ( String key ) { Object o = opt ( key ) ; return o instanceof JSONArray ? ( JSONArray ) o : null ; }
public static IgniteLogger logger ( GridKernalContext ctx , AtomicReference < IgniteLogger > logRef , Object obj ) { IgniteLogger log = logRef . get ( ) ; if ( log == null ) { logRef . compareAndSet ( null , ctx . log ( obj . getClass ( ) ) ) ; log = logRef . get ( ) ; } return log ; }
public static String formatMapOld ( String name , Map < String , String > props , String header , boolean wasModified ) { String indent = STRING ; StringBuilder builder = new StringBuilder ( ) ; builder . append ( header ) ; builder . append ( String . format ( STRING , name , modifiedSign ( wasModified ) ) ) ; builder . append ( STRING ) ; for ( String key : props . keySet ( ) ) { builder . append ( String . format ( STRING , indent , key , props . get ( key ) ) ) ; } builder . append ( String . format ( STRING ) ) ; return builder . toString ( ) ; }
MdInputStream ( URL url , InputStream in , MessageDigest messageDigest , byte [ ] expectedDigest ) { if ( url == null || in == null || messageDigest == null ) { throw new NullPointerException ( ) ; } this . url = url ; this . in = in ; this . messageDigest = messageDigest ; this . expectedDigest = expectedDigest . clone ( ) ; }
MdInputStream ( URL url , InputStream in , MessageDigest messageDigest , byte [ ] expectedDigest ) { if ( url == null || in == null || messageDigest == null ) { throw new NullPointerException ( ) ; } this . url = url ; this . in = in ; this . messageDigest = messageDigest ; this . expectedDigest = expectedDigest . clone ( ) ; }
MdInputStream ( URL url , InputStream in , MessageDigest messageDigest , byte [ ] expectedDigest ) { if ( url == null || in == null || messageDigest == null ) { throw new NullPointerException ( ) ; } this . url = url ; this . in = in ; this . messageDigest = messageDigest ; this . expectedDigest = expectedDigest . clone ( ) ; }
MdInputStream ( URL url , InputStream in , MessageDigest messageDigest , byte [ ] expectedDigest ) { if ( url == null || in == null || messageDigest == null ) { throw new NullPointerException ( ) ; } this . url = url ; this . in = in ; this . messageDigest = messageDigest ; this . expectedDigest = expectedDigest . clone ( ) ; }
MdInputStream ( URL url , InputStream in , MessageDigest messageDigest , byte [ ] expectedDigest ) { if ( url == null || in == null || messageDigest == null ) { throw new NullPointerException ( ) ; } this . url = url ; this . in = in ; this . messageDigest = messageDigest ; this . expectedDigest = expectedDigest . clone ( ) ; }
MdInputStream ( URL url , InputStream in , MessageDigest messageDigest , byte [ ] expectedDigest ) { if ( url == null || in == null || messageDigest == null ) { throw new NullPointerException ( ) ; } this . url = url ; this . in = in ; this . messageDigest = messageDigest ; this . expectedDigest = expectedDigest . clone ( ) ; }
MdInputStream ( URL url , InputStream in , MessageDigest messageDigest , byte [ ] expectedDigest ) { if ( url == null || in == null || messageDigest == null ) { throw new NullPointerException ( ) ; } this . url = url ; this . in = in ; this . messageDigest = messageDigest ; this . expectedDigest = expectedDigest . clone ( ) ; }
public ArrayList < Phone > addAliasByName ( String aliasName , String name ) { if ( aliasName . contains ( STRING ) ) return null ; ArrayList < Phone > res ; res = ContactsManager . getMobilePhones ( ctx , name ) ; if ( res . size ( ) == _NUM ) { Phone p = res . get ( _NUM ) ; addOrUpdate ( aliasName , p . getCleanNumber ( ) , p . getContactName ( ) ) ; } return res ; }
public void addFunctionalInstrumentation ( SpecialInstrumentationPoint functionalInstrumentation ) { if ( null == functionalInstrumentations ) { functionalInstrumentations = new HashSet < SpecialInstrumentationPoint > ( _NUM ) ; } functionalInstrumentations . add ( functionalInstrumentation ) ; }
private static URI fixUri ( URI uri0 , Configuration cfg ) { if ( uri0 == null ) return FileSystem . getDefaultUri ( cfg ) ; String scheme = uri0 . getScheme ( ) ; String authority = uri0 . getAuthority ( ) ; if ( authority == null ) { URI dfltUri = FileSystem . getDefaultUri ( cfg ) ; if ( scheme == null || ( scheme . equals ( dfltUri . getScheme ( ) ) && dfltUri . getAuthority ( ) != null ) ) return dfltUri ; } return uri0 ; }
private static URI fixUri ( URI uri0 , Configuration cfg ) { if ( uri0 == null ) return FileSystem . getDefaultUri ( cfg ) ; String scheme = uri0 . getScheme ( ) ; String authority = uri0 . getAuthority ( ) ; if ( authority == null ) { URI dfltUri = FileSystem . getDefaultUri ( cfg ) ; if ( scheme == null || ( scheme . equals ( dfltUri . getScheme ( ) ) && dfltUri . getAuthority ( ) != null ) ) return dfltUri ; } return uri0 ; }
void allowOffer ( boolean allow ) { offerButton . setEnabled ( allow ) ; }
void allowOffer ( boolean allow ) { offerButton . setEnabled ( allow ) ; }
private void addToken ( Token token ) { tokens . add ( token ) ; }
public static String tidyString ( String string ) { if ( string . matches ( STRING ) ) { return string ; } else { return string . replaceAll ( STRING , STRING ) ; } }
public static Writer leftShift ( Process self , Object value ) throws IOException { return IOGroovyMethods . leftShift ( self . getOutputStream ( ) , value ) ; }
public void createConnectionDialog ( ) { userNameLabel = new JLabel ( STRING , JLabel . RIGHT ) ; userNameField = new JTextField ( STRING ) ; passwordLabel = new JLabel ( STRING , JLabel . RIGHT ) ; passwordField = new JTextField ( STRING ) ; serverLabel = new JLabel ( STRING , JLabel . RIGHT ) ; serverField = new JTextField ( STRING ) ; driverLabel = new JLabel ( STRING , JLabel . RIGHT ) ; driverField = new JTextField ( STRING ) ; connectionPanel = new JPanel ( _BOOL ) ; connectionPanel . setLayout ( new BoxLayout ( connectionPanel , BoxLayout . X_AXIS ) ) ; JPanel namePanel = new JPanel ( _BOOL ) ; namePanel . setLayout ( new GridLayout ( _NUM , _NUM ) ) ; namePanel . add ( userNameLabel ) ; namePanel . add ( passwordLabel ) ; namePanel . add ( serverLabel ) ; namePanel . add ( driverLabel ) ; JPanel fieldPanel = new JPanel ( _BOOL ) ; fieldPanel . setLayout ( new GridLayout ( _NUM , _NUM ) ) ; fieldPanel . add ( userNameField ) ; fieldPanel . add ( passwordField ) ; fieldPanel . add ( serverField ) ; fieldPanel . add ( driverField ) ; connectionPanel . add ( namePanel ) ; connectionPanel . add ( fieldPanel ) ; }
public void createConnectionDialog ( ) { userNameLabel = new JLabel ( STRING , JLabel . RIGHT ) ; userNameField = new JTextField ( STRING ) ; passwordLabel = new JLabel ( STRING , JLabel . RIGHT ) ; passwordField = new JTextField ( STRING ) ; serverLabel = new JLabel ( STRING , JLabel . RIGHT ) ; serverField = new JTextField ( STRING ) ; driverLabel = new JLabel ( STRING , JLabel . RIGHT ) ; driverField = new JTextField ( STRING ) ; connectionPanel = new JPanel ( _BOOL ) ; connectionPanel . setLayout ( new BoxLayout ( connectionPanel , BoxLayout . X_AXIS ) ) ; JPanel namePanel = new JPanel ( _BOOL ) ; namePanel . setLayout ( new GridLayout ( _NUM , _NUM ) ) ; namePanel . add ( userNameLabel ) ; namePanel . add ( passwordLabel ) ; namePanel . add ( serverLabel ) ; namePanel . add ( driverLabel ) ; JPanel fieldPanel = new JPanel ( _BOOL ) ; fieldPanel . setLayout ( new GridLayout ( _NUM , _NUM ) ) ; fieldPanel . add ( userNameField ) ; fieldPanel . add ( passwordField ) ; fieldPanel . add ( serverField ) ; fieldPanel . add ( driverField ) ; connectionPanel . add ( namePanel ) ; connectionPanel . add ( fieldPanel ) ; }
public void createConnectionDialog ( ) { userNameLabel = new JLabel ( STRING , JLabel . RIGHT ) ; userNameField = new JTextField ( STRING ) ; passwordLabel = new JLabel ( STRING , JLabel . RIGHT ) ; passwordField = new JTextField ( STRING ) ; serverLabel = new JLabel ( STRING , JLabel . RIGHT ) ; serverField = new JTextField ( STRING ) ; driverLabel = new JLabel ( STRING , JLabel . RIGHT ) ; driverField = new JTextField ( STRING ) ; connectionPanel = new JPanel ( _BOOL ) ; connectionPanel . setLayout ( new BoxLayout ( connectionPanel , BoxLayout . X_AXIS ) ) ; JPanel namePanel = new JPanel ( _BOOL ) ; namePanel . setLayout ( new GridLayout ( _NUM , _NUM ) ) ; namePanel . add ( userNameLabel ) ; namePanel . add ( passwordLabel ) ; namePanel . add ( serverLabel ) ; namePanel . add ( driverLabel ) ; JPanel fieldPanel = new JPanel ( _BOOL ) ; fieldPanel . setLayout ( new GridLayout ( _NUM , _NUM ) ) ; fieldPanel . add ( userNameField ) ; fieldPanel . add ( passwordField ) ; fieldPanel . add ( serverField ) ; fieldPanel . add ( driverField ) ; connectionPanel . add ( namePanel ) ; connectionPanel . add ( fieldPanel ) ; }
public static Collection < CommunicationSummaryStatistics > buildCommunicationSummaryTree ( Collection < CommunicationSummaryStatistics > nodes , Set < String > endpoints ) { Map < String , CommunicationSummaryStatistics > nodeMap = new HashMap < String , CommunicationSummaryStatistics > ( ) ; for ( CommunicationSummaryStatistics css : nodes ) { nodeMap . put ( css . getId ( ) , css ) ; } List < CommunicationSummaryStatistics > ret = new ArrayList < > ( ) ; for ( String endpoint : endpoints ) { CommunicationSummaryStatistics n = nodeMap . get ( EndpointUtil . encodeClientURI ( endpoint ) ) ; if ( n == null ) { n = nodeMap . get ( endpoint ) ; } if ( n != null ) { CommunicationSummaryStatistics rootNode = new CommunicationSummaryStatistics ( n ) ; initCommunicationSummaryTreeNode ( rootNode , nodeMap , new HashSet < > ( Collections . singleton ( rootNode . getId ( ) ) ) ) ; ret . add ( rootNode ) ; } } return ret ; }
@ Deprecated protected boolean hasInput ( Class < ? extends IOObject > cls ) { try { getInput ( cls ) ; return _BOOL ; } catch ( MissingIOObjectException e ) { return _BOOL ; } }
@ Deprecated protected boolean hasInput ( Class < ? extends IOObject > cls ) { try { getInput ( cls ) ; return _BOOL ; } catch ( MissingIOObjectException e ) { return _BOOL ; } }
public static byte [ ] newBytes ( int len ) { if ( len == _NUM ) { return EMPTY_BYTES ; } try { return new byte [ len ] ; } catch ( OutOfMemoryError e ) { Error e2 = new OutOfMemoryError ( STRING + len ) ; e2 . initCause ( e ) ; throw e2 ; } }
public static byte [ ] newBytes ( int len ) { if ( len == _NUM ) { return EMPTY_BYTES ; } try { return new byte [ len ] ; } catch ( OutOfMemoryError e ) { Error e2 = new OutOfMemoryError ( STRING + len ) ; e2 . initCause ( e ) ; throw e2 ; } }
public static byte [ ] newBytes ( int len ) { if ( len == _NUM ) { return EMPTY_BYTES ; } try { return new byte [ len ] ; } catch ( OutOfMemoryError e ) { Error e2 = new OutOfMemoryError ( STRING + len ) ; e2 . initCause ( e ) ; throw e2 ; } }
public static byte [ ] newBytes ( int len ) { if ( len == _NUM ) { return EMPTY_BYTES ; } try { return new byte [ len ] ; } catch ( OutOfMemoryError e ) { Error e2 = new OutOfMemoryError ( STRING + len ) ; e2 . initCause ( e ) ; throw e2 ; } }
public static byte [ ] newBytes ( int len ) { if ( len == _NUM ) { return EMPTY_BYTES ; } try { return new byte [ len ] ; } catch ( OutOfMemoryError e ) { Error e2 = new OutOfMemoryError ( STRING + len ) ; e2 . initCause ( e ) ; throw e2 ; } }
private void updateMonitor ( ) { m_MonitorLabel . setText ( STRING + m_ActiveTasks ) ; if ( m_ActiveTasks > _NUM && ! m_animating ) { m_MonitorLabel . setIcon ( m_iconAnimated ) ; m_animating = _BOOL ; } if ( m_ActiveTasks == _NUM && m_animating ) { m_MonitorLabel . setIcon ( m_iconStationary ) ; m_animating = _BOOL ; } }
private IVGenerator ( ) { }
public static String [ ] split ( String line , String delim ) { List list = new ArrayList ( ) ; StringTokenizer t = new StringTokenizer ( line , delim ) ; while ( t . hasMoreTokens ( ) ) { list . add ( t . nextToken ( ) ) ; } return ( String [ ] ) list . toArray ( new String [ list . size ( ) ] ) ; }
public R1Interval union ( R1Interval y ) { if ( isEmpty ( ) ) { return y ; } if ( y . isEmpty ( ) ) { return this ; } return new R1Interval ( Math . min ( lo ( ) , y . lo ( ) ) , Math . max ( hi ( ) , y . hi ( ) ) ) ; }
public R1Interval union ( R1Interval y ) { if ( isEmpty ( ) ) { return y ; } if ( y . isEmpty ( ) ) { return this ; } return new R1Interval ( Math . min ( lo ( ) , y . lo ( ) ) , Math . max ( hi ( ) , y . hi ( ) ) ) ; }
public static void initUrbanSimPersonWriter ( UrbanSimParameterConfigModuleV3 module ) { try { log . info ( STRING ) ; personWriter = IOUtils . getBufferedWriter ( module . getMATSim4OpusTemp ( ) + FILE_NAME ) ; log . info ( STRING + module . getMATSim4OpusTemp ( ) + FILE_NAME + STRING ) ; personWriter . write ( InternalConstants . PERSON_ID + STRING + STRING + STRING + STRING + STRING + STRING ) ; personWriter . newLine ( ) ; log . info ( STRING ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
public static String addQuotationMarksIfNeeded ( String str ) { if ( ! str . startsWith ( STRING ) && ! str . isEmpty ( ) ) return STRING + str + STRING ; return str ; }
public static String addQuotationMarksIfNeeded ( String str ) { if ( ! str . startsWith ( STRING ) && ! str . isEmpty ( ) ) return STRING + str + STRING ; return str ; }
public final TestSubscriber assertNotComplete ( ) { String prefix = STRING ; boolean passed = _BOOL ; if ( done . getCount ( ) != _NUM ) { prefix = STRING ; } long c = completions ; if ( c == _NUM ) { fail ( prefix , STRING , errors ) ; fail ( STRING ) ; passed = _BOOL ; } else if ( c > _NUM ) { fail ( prefix , STRING + c , errors ) ; fail ( STRING ) ; passed = _BOOL ; } pass ( STRING , passed ) ; return this ; }
public final TestSubscriber assertNotComplete ( ) { String prefix = STRING ; boolean passed = _BOOL ; if ( done . getCount ( ) != _NUM ) { prefix = STRING ; } long c = completions ; if ( c == _NUM ) { fail ( prefix , STRING , errors ) ; fail ( STRING ) ; passed = _BOOL ; } else if ( c > _NUM ) { fail ( prefix , STRING + c , errors ) ; fail ( STRING ) ; passed = _BOOL ; } pass ( STRING , passed ) ; return this ; }
public final TestSubscriber assertNotComplete ( ) { String prefix = STRING ; boolean passed = _BOOL ; if ( done . getCount ( ) != _NUM ) { prefix = STRING ; } long c = completions ; if ( c == _NUM ) { fail ( prefix , STRING , errors ) ; fail ( STRING ) ; passed = _BOOL ; } else if ( c > _NUM ) { fail ( prefix , STRING + c , errors ) ; fail ( STRING ) ; passed = _BOOL ; } pass ( STRING , passed ) ; return this ; }
private double gammaRatio ( int n , int k ) { double top = ( n - k + _NUM ) / _NUM ; double bottom = ( n - k ) / _NUM ; double lngamma = ProbUtils . lngamma ( top ) - ProbUtils . lngamma ( bottom ) ; return Math . exp ( lngamma ) ; }
protected abstract int readSkipData ( int level , IndexInput skipStream ) throws IOException ;
protected abstract int readSkipData ( int level , IndexInput skipStream ) throws IOException ;
public Vector2 ceil ( ) { return new Vector2 ( Math . ceil ( x ) , Math . ceil ( z ) ) ; }
public Vector2 ceil ( ) { return new Vector2 ( Math . ceil ( x ) , Math . ceil ( z ) ) ; }
public void addPage ( int position , @ NonNull List < MODEL > items ) { setAutoNotifyDataSetChanged ( _BOOL ) ; addAll ( position , items ) ; setAutoNotifyDataSetChanged ( _BOOL ) ; onNewItemsAdded ( items . size ( ) ) ; notifyItemRangeInsertedIfNeed ( size ( ) - ( items . size ( ) + getHeadersCount ( ) ) , items . size ( ) ) ; }
public void addPage ( int position , @ NonNull List < MODEL > items ) { setAutoNotifyDataSetChanged ( _BOOL ) ; addAll ( position , items ) ; setAutoNotifyDataSetChanged ( _BOOL ) ; onNewItemsAdded ( items . size ( ) ) ; notifyItemRangeInsertedIfNeed ( size ( ) - ( items . size ( ) + getHeadersCount ( ) ) , items . size ( ) ) ; }
public void addPage ( int position , @ NonNull List < MODEL > items ) { setAutoNotifyDataSetChanged ( _BOOL ) ; addAll ( position , items ) ; setAutoNotifyDataSetChanged ( _BOOL ) ; onNewItemsAdded ( items . size ( ) ) ; notifyItemRangeInsertedIfNeed ( size ( ) - ( items . size ( ) + getHeadersCount ( ) ) , items . size ( ) ) ; }
public void addPage ( int position , @ NonNull List < MODEL > items ) { setAutoNotifyDataSetChanged ( _BOOL ) ; addAll ( position , items ) ; setAutoNotifyDataSetChanged ( _BOOL ) ; onNewItemsAdded ( items . size ( ) ) ; notifyItemRangeInsertedIfNeed ( size ( ) - ( items . size ( ) + getHeadersCount ( ) ) , items . size ( ) ) ; }
public void addPage ( int position , @ NonNull List < MODEL > items ) { setAutoNotifyDataSetChanged ( _BOOL ) ; addAll ( position , items ) ; setAutoNotifyDataSetChanged ( _BOOL ) ; onNewItemsAdded ( items . size ( ) ) ; notifyItemRangeInsertedIfNeed ( size ( ) - ( items . size ( ) + getHeadersCount ( ) ) , items . size ( ) ) ; }
private static Set < String > createCategoriesSet ( Set < String > categories ) { Set < String > result = new HashSet < > ( ) ; for ( String cat : categories ) { result . add ( StringUtil . toLowerCase ( cat ) ) ; } return result ; }
private static Set < String > createCategoriesSet ( Set < String > categories ) { Set < String > result = new HashSet < > ( ) ; for ( String cat : categories ) { result . add ( StringUtil . toLowerCase ( cat ) ) ; } return result ; }
public static Map < Unit , Unit > mapTransportsAlreadyLoaded ( final Collection < Unit > units , final Collection < Unit > transports ) { final Collection < Unit > canBeTransported = Match . getMatches ( units , Matches . UnitCanBeTransported ) ; final Collection < Unit > canTransport = Match . getMatches ( transports , Matches . UnitCanTransport ) ; final Map < Unit , Unit > mapping = new HashMap < > ( ) ; for ( final Unit currentTransported : canBeTransported ) { final Unit transport = TransportTracker . transportedBy ( currentTransported ) ; if ( transport == null || ! canTransport . contains ( transport ) ) { continue ; } mapping . put ( currentTransported , transport ) ; } return mapping ; }
public static Map < Unit , Unit > mapTransportsAlreadyLoaded ( final Collection < Unit > units , final Collection < Unit > transports ) { final Collection < Unit > canBeTransported = Match . getMatches ( units , Matches . UnitCanBeTransported ) ; final Collection < Unit > canTransport = Match . getMatches ( transports , Matches . UnitCanTransport ) ; final Map < Unit , Unit > mapping = new HashMap < > ( ) ; for ( final Unit currentTransported : canBeTransported ) { final Unit transport = TransportTracker . transportedBy ( currentTransported ) ; if ( transport == null || ! canTransport . contains ( transport ) ) { continue ; } mapping . put ( currentTransported , transport ) ; } return mapping ; }
@ Override public void presentation ( String programName , String programEditor , String editorURL , String scriptorName , String prefixName ) throws CancelException { final String textToShow = String . format ( translate ( STRING + STRING + STRING + STRING + STRING ) , programName , programEditor , editorURL , scriptorName , prefixName ) ; presentation ( textToShow ) ; }
public boolean onOwnerChanged ( GridCacheEntryEx entry , GridCacheMvccCandidate owner ) { if ( owner != null ) { IgniteTxAdapter tx = tx ( owner . version ( ) ) ; if ( tx == null ) tx = nearTx ( owner . version ( ) ) ; if ( tx != null ) { if ( ! tx . local ( ) ) { if ( log . isDebugEnabled ( ) ) log . debug ( STRING + owner + STRING + entry + STRING + tx + STRING ) ; tx . onOwnerChanged ( entry , owner ) ; return _BOOL ; } else if ( log . isDebugEnabled ( ) ) log . debug ( STRING + tx ) ; } else if ( log . isDebugEnabled ( ) ) log . debug ( STRING + owner + STRING + entry + STRING ) ; } return _BOOL ; }
public boolean onOwnerChanged ( GridCacheEntryEx entry , GridCacheMvccCandidate owner ) { if ( owner != null ) { IgniteTxAdapter tx = tx ( owner . version ( ) ) ; if ( tx == null ) tx = nearTx ( owner . version ( ) ) ; if ( tx != null ) { if ( ! tx . local ( ) ) { if ( log . isDebugEnabled ( ) ) log . debug ( STRING + owner + STRING + entry + STRING + tx + STRING ) ; tx . onOwnerChanged ( entry , owner ) ; return _BOOL ; } else if ( log . isDebugEnabled ( ) ) log . debug ( STRING + tx ) ; } else if ( log . isDebugEnabled ( ) ) log . debug ( STRING + owner + STRING + entry + STRING ) ; } return _BOOL ; }
public boolean onOwnerChanged ( GridCacheEntryEx entry , GridCacheMvccCandidate owner ) { if ( owner != null ) { IgniteTxAdapter tx = tx ( owner . version ( ) ) ; if ( tx == null ) tx = nearTx ( owner . version ( ) ) ; if ( tx != null ) { if ( ! tx . local ( ) ) { if ( log . isDebugEnabled ( ) ) log . debug ( STRING + owner + STRING + entry + STRING + tx + STRING ) ; tx . onOwnerChanged ( entry , owner ) ; return _BOOL ; } else if ( log . isDebugEnabled ( ) ) log . debug ( STRING + tx ) ; } else if ( log . isDebugEnabled ( ) ) log . debug ( STRING + owner + STRING + entry + STRING ) ; } return _BOOL ; }
public boolean onOwnerChanged ( GridCacheEntryEx entry , GridCacheMvccCandidate owner ) { if ( owner != null ) { IgniteTxAdapter tx = tx ( owner . version ( ) ) ; if ( tx == null ) tx = nearTx ( owner . version ( ) ) ; if ( tx != null ) { if ( ! tx . local ( ) ) { if ( log . isDebugEnabled ( ) ) log . debug ( STRING + owner + STRING + entry + STRING + tx + STRING ) ; tx . onOwnerChanged ( entry , owner ) ; return _BOOL ; } else if ( log . isDebugEnabled ( ) ) log . debug ( STRING + tx ) ; } else if ( log . isDebugEnabled ( ) ) log . debug ( STRING + owner + STRING + entry + STRING ) ; } return _BOOL ; }
public String toString ( Charset encoding ) { StringBuilder out = new StringBuilder ( ) ; appendTo ( out , encoding ) ; return out . toString ( ) ; }
public void ifNull ( final Label label ) { mv . visitJumpInsn ( Opcodes . IFNULL , label ) ; }
public boolean isDirty ( ) { return dirty . get ( ) ; }
public boolean isDirty ( ) { return dirty . get ( ) ; }
public boolean isDirty ( ) { return dirty . get ( ) ; }
public boolean isDirty ( ) { return dirty . get ( ) ; }
public boolean isDirty ( ) { return dirty . get ( ) ; }
public void testConstructorBytesNegative1 ( ) { byte aBytes [ ] = { - _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM } ; byte rBytes [ ] = { - _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM } ; BigInteger aNumber = new BigInteger ( aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , - _NUM , aNumber . signum ( ) ) ; }
public void testConstructorBytesNegative1 ( ) { byte aBytes [ ] = { - _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM } ; byte rBytes [ ] = { - _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM } ; BigInteger aNumber = new BigInteger ( aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , - _NUM , aNumber . signum ( ) ) ; }
public void testConstructorBytesNegative1 ( ) { byte aBytes [ ] = { - _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM } ; byte rBytes [ ] = { - _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM } ; BigInteger aNumber = new BigInteger ( aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , - _NUM , aNumber . signum ( ) ) ; }
private void reallocate ( final int row ) { final int size = this . cols [ row ] . length ; final int [ ] newCols = new int [ size * _NUM ] ; final double [ ] newValues = new double [ size * _NUM ] ; System . arraycopy ( this . cols [ row ] , _NUM , newCols , _NUM , size ) ; System . arraycopy ( this . values [ row ] , _NUM , newValues , _NUM , size ) ; this . cols [ row ] = newCols ; this . values [ row ] = newValues ; }
public CoreDescriptor ( CoreContainer container , String name , Path instanceDir ) { this ( container , name , instanceDir , Collections . emptyMap ( ) ) ; }
protected void fillToolbar ( ) { ToolBarManager toolBarManager = getToolBarManager ( ) ; if ( toolBarManager == null ) return ; fInput . fillToolBar ( toolBarManager , this ) ; toolBarManager . update ( _BOOL ) ; }
public ChatCompletionHelper ( final ChatTextController chatTextController , final Set < String > nameList , final Set < String > commands ) { chatController = chatTextController ; playersonline = nameList ; slashCommands = new HashSet < String > ( commands . size ( ) ) ; for ( String s : commands ) { slashCommands . add ( STRING + s ) ; } }
private String partiallyEscapeAssertionValue ( String assertionValue ) { StringBuilder sb = new StringBuilder ( assertionValue . length ( ) ) ; for ( int j = _NUM ; j < assertionValue . length ( ) ; j ++ ) { char c = assertionValue . charAt ( j ) ; if ( c == STRING ) { sb . append ( c ) ; } else { sb . append ( Filter . escapeAssertionValue ( String . valueOf ( c ) ) ) ; } } return sb . toString ( ) ; }
private String partiallyEscapeAssertionValue ( String assertionValue ) { StringBuilder sb = new StringBuilder ( assertionValue . length ( ) ) ; for ( int j = _NUM ; j < assertionValue . length ( ) ; j ++ ) { char c = assertionValue . charAt ( j ) ; if ( c == STRING ) { sb . append ( c ) ; } else { sb . append ( Filter . escapeAssertionValue ( String . valueOf ( c ) ) ) ; } } return sb . toString ( ) ; }
private String partiallyEscapeAssertionValue ( String assertionValue ) { StringBuilder sb = new StringBuilder ( assertionValue . length ( ) ) ; for ( int j = _NUM ; j < assertionValue . length ( ) ; j ++ ) { char c = assertionValue . charAt ( j ) ; if ( c == STRING ) { sb . append ( c ) ; } else { sb . append ( Filter . escapeAssertionValue ( String . valueOf ( c ) ) ) ; } } return sb . toString ( ) ; }
private String partiallyEscapeAssertionValue ( String assertionValue ) { StringBuilder sb = new StringBuilder ( assertionValue . length ( ) ) ; for ( int j = _NUM ; j < assertionValue . length ( ) ; j ++ ) { char c = assertionValue . charAt ( j ) ; if ( c == STRING ) { sb . append ( c ) ; } else { sb . append ( Filter . escapeAssertionValue ( String . valueOf ( c ) ) ) ; } } return sb . toString ( ) ; }
private String partiallyEscapeAssertionValue ( String assertionValue ) { StringBuilder sb = new StringBuilder ( assertionValue . length ( ) ) ; for ( int j = _NUM ; j < assertionValue . length ( ) ; j ++ ) { char c = assertionValue . charAt ( j ) ; if ( c == STRING ) { sb . append ( c ) ; } else { sb . append ( Filter . escapeAssertionValue ( String . valueOf ( c ) ) ) ; } } return sb . toString ( ) ; }
private String partiallyEscapeAssertionValue ( String assertionValue ) { StringBuilder sb = new StringBuilder ( assertionValue . length ( ) ) ; for ( int j = _NUM ; j < assertionValue . length ( ) ; j ++ ) { char c = assertionValue . charAt ( j ) ; if ( c == STRING ) { sb . append ( c ) ; } else { sb . append ( Filter . escapeAssertionValue ( String . valueOf ( c ) ) ) ; } } return sb . toString ( ) ; }
private String partiallyEscapeAssertionValue ( String assertionValue ) { StringBuilder sb = new StringBuilder ( assertionValue . length ( ) ) ; for ( int j = _NUM ; j < assertionValue . length ( ) ; j ++ ) { char c = assertionValue . charAt ( j ) ; if ( c == STRING ) { sb . append ( c ) ; } else { sb . append ( Filter . escapeAssertionValue ( String . valueOf ( c ) ) ) ; } } return sb . toString ( ) ; }
private String partiallyEscapeAssertionValue ( String assertionValue ) { StringBuilder sb = new StringBuilder ( assertionValue . length ( ) ) ; for ( int j = _NUM ; j < assertionValue . length ( ) ; j ++ ) { char c = assertionValue . charAt ( j ) ; if ( c == STRING ) { sb . append ( c ) ; } else { sb . append ( Filter . escapeAssertionValue ( String . valueOf ( c ) ) ) ; } } return sb . toString ( ) ; }
protected boolean checkList ( String currentVal , String tokenValue ) { if ( currentVal == null || tokenValue == null ) { throw new NullPointerException ( STRING ) ; } if ( ! currentVal . startsWith ( STRING ) && ! currentVal . startsWith ( STRING ) ) { throw new IllegalArgumentException ( STRING ) ; } boolean negation = currentVal . startsWith ( STRING ) ; String listName = currentVal . substring ( currentVal . indexOf ( STRING ) + _NUM ) ; Object listObj = listMap . get ( listName ) ; if ( listObj == null ) return _BOOL ; boolean contains ; if ( listObj instanceof Set ) { Set < String > set = ( Set ) listObj ; contains = set . contains ( tokenValue ) ; } else { throw new IllegalArgumentException ( STRING + listObj ) ; } return ! ( contains && negation || ! contains && ! negation ) ; }
protected boolean checkList ( String currentVal , String tokenValue ) { if ( currentVal == null || tokenValue == null ) { throw new NullPointerException ( STRING ) ; } if ( ! currentVal . startsWith ( STRING ) && ! currentVal . startsWith ( STRING ) ) { throw new IllegalArgumentException ( STRING ) ; } boolean negation = currentVal . startsWith ( STRING ) ; String listName = currentVal . substring ( currentVal . indexOf ( STRING ) + _NUM ) ; Object listObj = listMap . get ( listName ) ; if ( listObj == null ) return _BOOL ; boolean contains ; if ( listObj instanceof Set ) { Set < String > set = ( Set ) listObj ; contains = set . contains ( tokenValue ) ; } else { throw new IllegalArgumentException ( STRING + listObj ) ; } return ! ( contains && negation || ! contains && ! negation ) ; }
public abstract int compare ( String source , String target ) ;
public abstract int compare ( String source , String target ) ;
public abstract int compare ( String source , String target ) ;
public abstract int compare ( String source , String target ) ;
public abstract int compare ( String source , String target ) ;
public abstract int compare ( String source , String target ) ;
public abstract int compare ( String source , String target ) ;
public static void init ( Context context , boolean is_top ) { cameraManager = new CameraManager ( context , is_top ) ; }
public static void init ( Context context , boolean is_top ) { cameraManager = new CameraManager ( context , is_top ) ; }
protected static Long convertUuidToLong ( UUID uuid ) { if ( uuid == null ) { return null ; } Long convertedUuid ; if ( uuid . version ( ) == _NUM ) { convertedUuid = uuid . timestamp ( ) ; } else { convertedUuid = uuid . getMostSignificantBits ( ) ; } return convertedUuid ; }
static FileTime toFileTime ( long time ) { time /= _NUM ; time += WINDOWS_EPOCH_IN_MICROSECONDS ; return FileTime . from ( time , TimeUnit . MICROSECONDS ) ; }
static FileTime toFileTime ( long time ) { time /= _NUM ; time += WINDOWS_EPOCH_IN_MICROSECONDS ; return FileTime . from ( time , TimeUnit . MICROSECONDS ) ; }
static FileTime toFileTime ( long time ) { time /= _NUM ; time += WINDOWS_EPOCH_IN_MICROSECONDS ; return FileTime . from ( time , TimeUnit . MICROSECONDS ) ; }
public String resolveParentRelationName ( String parentName , Object parent , String childName , Object child ) { return parentName ; }
public SurroundWithLineSelection ( ) { super ( org . eclipse . jface . text . templates . GlobalTemplateVariables . LineSelection . NAME , JavaTemplateMessages . CompilationUnitContextType_variable_description_line_selection ) ; }
public static short [ ] join ( short [ ] arrayA , short ... arrayB ) { if ( ( arrayB == null ) || ( arrayB . length == _NUM ) ) { return arrayA ; } if ( ( arrayA == null ) || ( arrayA . length == _NUM ) ) { return arrayB ; } short [ ] array = new short [ arrayA . length + arrayB . length ] ; System . arraycopy ( arrayA , _NUM , array , _NUM , arrayA . length ) ; System . arraycopy ( arrayB , _NUM , array , arrayA . length , arrayB . length ) ; return array ; }
public static short [ ] join ( short [ ] arrayA , short ... arrayB ) { if ( ( arrayB == null ) || ( arrayB . length == _NUM ) ) { return arrayA ; } if ( ( arrayA == null ) || ( arrayA . length == _NUM ) ) { return arrayB ; } short [ ] array = new short [ arrayA . length + arrayB . length ] ; System . arraycopy ( arrayA , _NUM , array , _NUM , arrayA . length ) ; System . arraycopy ( arrayB , _NUM , array , arrayA . length , arrayB . length ) ; return array ; }
public void addField ( MappedMember mm ) { fields . add ( mm ) ; }
public void addField ( MappedMember mm ) { fields . add ( mm ) ; }
public int readInt ( ) throws IOException { return ( ( _is . read ( ) << _NUM ) | ( _is . read ( ) << _NUM ) | ( _is . read ( ) << _NUM ) | ( _is . read ( ) ) ) ; }
public Mp4BoxHeader ( String id ) { if ( id . length ( ) != IDENTIFIER_LENGTH ) { throw new RuntimeException ( STRING ) ; } dataBuffer = ByteBuffer . allocate ( HEADER_LENGTH ) ; try { this . id = id ; dataBuffer . put ( _NUM , id . getBytes ( STRING ) [ _NUM ] ) ; dataBuffer . put ( _NUM , id . getBytes ( STRING ) [ _NUM ] ) ; dataBuffer . put ( _NUM , id . getBytes ( STRING ) [ _NUM ] ) ; dataBuffer . put ( _NUM , id . getBytes ( STRING ) [ _NUM ] ) ; } catch ( UnsupportedEncodingException uee ) { throw new RuntimeException ( uee ) ; } }
public static void registerProtocol ( final String id , final Protocol protocol ) { if ( id == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( protocol == null ) { throw new IllegalArgumentException ( STRING ) ; } PROTOCOLS . put ( id , protocol ) ; }
public static void registerProtocol ( final String id , final Protocol protocol ) { if ( id == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( protocol == null ) { throw new IllegalArgumentException ( STRING ) ; } PROTOCOLS . put ( id , protocol ) ; }
public static void registerProtocol ( final String id , final Protocol protocol ) { if ( id == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( protocol == null ) { throw new IllegalArgumentException ( STRING ) ; } PROTOCOLS . put ( id , protocol ) ; }
protected void assertSameHits ( final IHit [ ] hits , final Iterator < ? extends IHit > itr ) { final int nhits = hits . length ; for ( int i = _NUM ; i < nhits ; i ++ ) { assertTrue ( STRING + ( i ) + STRING + nhits , itr . hasNext ( ) ) ; final IHit expected = hits [ i ] ; final IHit actual = itr . next ( ) ; if ( log . isInfoEnabled ( ) ) log . info ( STRING + ( i + _NUM ) + STRING + expected + STRING + actual ) ; assertEquals ( STRING + ( i + _NUM ) , expected . getDocId ( ) , actual . getDocId ( ) ) ; final double expectedCosine = expected . getCosine ( ) ; final double actualCosine = actual . getCosine ( ) ; if ( actualCosine < expectedCosine - _NUM || actualCosine > expectedCosine + _NUM ) { assertEquals ( STRING + ( i + _NUM ) , expected . getCosine ( ) , actual . getCosine ( ) ) ; } } assertFalse ( STRING + nhits + STRING , itr . hasNext ( ) ) ; }
protected void assertSameHits ( final IHit [ ] hits , final Iterator < ? extends IHit > itr ) { final int nhits = hits . length ; for ( int i = _NUM ; i < nhits ; i ++ ) { assertTrue ( STRING + ( i ) + STRING + nhits , itr . hasNext ( ) ) ; final IHit expected = hits [ i ] ; final IHit actual = itr . next ( ) ; if ( log . isInfoEnabled ( ) ) log . info ( STRING + ( i + _NUM ) + STRING + expected + STRING + actual ) ; assertEquals ( STRING + ( i + _NUM ) , expected . getDocId ( ) , actual . getDocId ( ) ) ; final double expectedCosine = expected . getCosine ( ) ; final double actualCosine = actual . getCosine ( ) ; if ( actualCosine < expectedCosine - _NUM || actualCosine > expectedCosine + _NUM ) { assertEquals ( STRING + ( i + _NUM ) , expected . getCosine ( ) , actual . getCosine ( ) ) ; } } assertFalse ( STRING + nhits + STRING , itr . hasNext ( ) ) ; }
protected void assertSameHits ( final IHit [ ] hits , final Iterator < ? extends IHit > itr ) { final int nhits = hits . length ; for ( int i = _NUM ; i < nhits ; i ++ ) { assertTrue ( STRING + ( i ) + STRING + nhits , itr . hasNext ( ) ) ; final IHit expected = hits [ i ] ; final IHit actual = itr . next ( ) ; if ( log . isInfoEnabled ( ) ) log . info ( STRING + ( i + _NUM ) + STRING + expected + STRING + actual ) ; assertEquals ( STRING + ( i + _NUM ) , expected . getDocId ( ) , actual . getDocId ( ) ) ; final double expectedCosine = expected . getCosine ( ) ; final double actualCosine = actual . getCosine ( ) ; if ( actualCosine < expectedCosine - _NUM || actualCosine > expectedCosine + _NUM ) { assertEquals ( STRING + ( i + _NUM ) , expected . getCosine ( ) , actual . getCosine ( ) ) ; } } assertFalse ( STRING + nhits + STRING , itr . hasNext ( ) ) ; }
public static void isValidPath ( String matsimConfiFile ) { if ( matsimConfiFile == null || matsimConfiFile . length ( ) <= _NUM || ! pathExsits ( matsimConfiFile ) ) throw new RuntimeException ( matsimConfiFile + STRING ) ; }
public static void isValidPath ( String matsimConfiFile ) { if ( matsimConfiFile == null || matsimConfiFile . length ( ) <= _NUM || ! pathExsits ( matsimConfiFile ) ) throw new RuntimeException ( matsimConfiFile + STRING ) ; }
public boolean isGranted ( final T tx ) { if ( tx == null ) { throw new IllegalArgumentException ( ) ; } return queue . peek ( ) == tx ; }
public boolean isGranted ( final T tx ) { if ( tx == null ) { throw new IllegalArgumentException ( ) ; } return queue . peek ( ) == tx ; }
public boolean isGranted ( final T tx ) { if ( tx == null ) { throw new IllegalArgumentException ( ) ; } return queue . peek ( ) == tx ; }
@ Override public String leaveDTD ( ) { if ( _writer == _dtdWriter ) { _line . append ( _text ) ; _text = new StringBuffer ( _NUM ) ; flushLine ( _BOOL ) ; _writer = _docWriter ; return _dtdWriter . toString ( ) ; } return null ; }
@ Override public String leaveDTD ( ) { if ( _writer == _dtdWriter ) { _line . append ( _text ) ; _text = new StringBuffer ( _NUM ) ; flushLine ( _BOOL ) ; _writer = _docWriter ; return _dtdWriter . toString ( ) ; } return null ; }
@ Override public String leaveDTD ( ) { if ( _writer == _dtdWriter ) { _line . append ( _text ) ; _text = new StringBuffer ( _NUM ) ; flushLine ( _BOOL ) ; _writer = _docWriter ; return _dtdWriter . toString ( ) ; } return null ; }
@ Override public String leaveDTD ( ) { if ( _writer == _dtdWriter ) { _line . append ( _text ) ; _text = new StringBuffer ( _NUM ) ; flushLine ( _BOOL ) ; _writer = _docWriter ; return _dtdWriter . toString ( ) ; } return null ; }
@ Override public String leaveDTD ( ) { if ( _writer == _dtdWriter ) { _line . append ( _text ) ; _text = new StringBuffer ( _NUM ) ; flushLine ( _BOOL ) ; _writer = _docWriter ; return _dtdWriter . toString ( ) ; } return null ; }
public EventSourceImpl ( ) { LOG . entering ( CLASS_NAME , STRING ) ; }
public EventSourceImpl ( ) { LOG . entering ( CLASS_NAME , STRING ) ; }
void clear ( ) { buffer . setLength ( _NUM ) ; startOffset = endOffset = type = subwordCount = _NUM ; }
public void add ( int index , PdfObject element ) { list . add ( index , element ) ; }
public void appendAndClearPending ( String s ) { output . append ( s ) ; complete = current ; }
protected static void writeQuotedStringValue ( ByteArrayOutputStream out , byte [ ] buf ) { int len = buf . length ; byte ch ; for ( int i = _NUM ; i < len ; i ++ ) { ch = buf [ i ] ; if ( needEscape ( ( char ) ch ) ) { out . write ( STRING ) ; } out . write ( ch ) ; } }
protected static void writeQuotedStringValue ( ByteArrayOutputStream out , byte [ ] buf ) { int len = buf . length ; byte ch ; for ( int i = _NUM ; i < len ; i ++ ) { ch = buf [ i ] ; if ( needEscape ( ( char ) ch ) ) { out . write ( STRING ) ; } out . write ( ch ) ; } }
public FeatureVector readFeatureVector ( int currentUnitIndex , ByteBuffer bb ) throws IOException { byte [ ] bytes = new byte [ numByteFeatures ] ; bb . get ( bytes ) ; short [ ] shorts = new short [ numShortFeatures ] ; for ( int i = _NUM ; i < shorts . length ; i ++ ) { shorts [ i ] = bb . getShort ( ) ; } float [ ] floats = new float [ numContinuousFeatures ] ; for ( int i = _NUM ; i < floats . length ; i ++ ) { floats [ i ] = bb . getFloat ( ) ; } return new FeatureVector ( bytes , shorts , floats , currentUnitIndex ) ; }
public FeatureVector readFeatureVector ( int currentUnitIndex , ByteBuffer bb ) throws IOException { byte [ ] bytes = new byte [ numByteFeatures ] ; bb . get ( bytes ) ; short [ ] shorts = new short [ numShortFeatures ] ; for ( int i = _NUM ; i < shorts . length ; i ++ ) { shorts [ i ] = bb . getShort ( ) ; } float [ ] floats = new float [ numContinuousFeatures ] ; for ( int i = _NUM ; i < floats . length ; i ++ ) { floats [ i ] = bb . getFloat ( ) ; } return new FeatureVector ( bytes , shorts , floats , currentUnitIndex ) ; }
public StatusBar ( boolean showMemory ) { super ( new BorderLayout ( ) ) ; add ( createInfoPanel ( ) , BorderLayout . WEST ) ; if ( showMemory ) { add ( createMemoryStatus ( ) , BorderLayout . CENTER ) ; JPanel iconPanel = new JPanel ( new BorderLayout ( ) ) ; iconPanel . add ( new JLabel ( new AngledLinesWindowsCornerIcon ( ) ) , BorderLayout . SOUTH ) ; add ( iconPanel , BorderLayout . EAST ) ; } else { setBackground ( Color . WHITE ) ; } }
private void updateSliding ( float newPositionNormalized ) { currentSlide = newPositionNormalized ; state = currentSlide == _NUM ? EXPANDED : currentSlide == _NUM ? COLLAPSED : SLIDING ; float slideY = Math . abs ( ( currentSlide * maxSlide ) - maxSlide ) ; slidableView . setY ( slideY ) ; invalidate ( ) ; notifyListeners ( currentSlide ) ; }
public OkapiBM25 ( double k1 , double b ) { if ( Double . isNaN ( k1 ) || Double . isInfinite ( k1 ) || k1 < _NUM ) throw new IllegalArgumentException ( STRING + k1 ) ; this . k1 = k1 ; if ( Double . isNaN ( b ) || b < _NUM || b > _NUM ) throw new IllegalArgumentException ( STRING + b ) ; this . b = b ; }
private void deleteAngle ( ) { if ( angles == null ) return ; if ( angles . length == _NUM ) { angles = null ; jTFChangeAngle . setText ( STRING ) ; angleModel . removeValueAt ( _NUM ) ; jLAngleCount . setText ( JL_NUMBER_OF_ANGLES_TEXT + STRING ) ; btnDeleteAngle . setEnabled ( _BOOL ) ; } else { double [ ] tmpAngles = new double [ angles . length - _NUM ] ; for ( int i = _NUM ; i < angles . length - _NUM ; i ++ ) { if ( i >= selectedAngleIndex ) { tmpAngles [ i ] = angles [ i + _NUM ] ; } else { tmpAngles [ i ] = angles [ i ] ; } } angles = tmpAngles ; angleModel . removeValueAt ( selectedAngleIndex ) ; selectedAngleIndex = _NUM ; jTFChangeAngle . setText ( angles [ selectedAngleIndex ] + STRING ) ; jLAngleCount . setText ( STRING + angles . length ) ; } repaint ( ) ; }
private void updatePlacements ( ResourcePoolService . ResourcePoolState resourcePoolState ) { QueryTask queryTask = QueryUtil . buildPropertyQuery ( GroupResourcePlacementService . GroupResourcePlacementState . class , GroupResourcePlacementService . GroupResourcePlacementState . FIELD_NAME_RESOURCE_POOL_LINK , resourcePoolState . documentSelfLink ) ; QueryUtil . addExpandOption ( queryTask ) ; ServiceDocumentQuery < GroupResourcePlacementState > query = new ServiceDocumentQuery < > ( getHost ( ) , GroupResourcePlacementState . class ) ; List < GroupResourcePlacementState > placements = new ArrayList < > ( ) ; query . query ( queryTask , null ) ; }
private void updatePlacements ( ResourcePoolService . ResourcePoolState resourcePoolState ) { QueryTask queryTask = QueryUtil . buildPropertyQuery ( GroupResourcePlacementService . GroupResourcePlacementState . class , GroupResourcePlacementService . GroupResourcePlacementState . FIELD_NAME_RESOURCE_POOL_LINK , resourcePoolState . documentSelfLink ) ; QueryUtil . addExpandOption ( queryTask ) ; ServiceDocumentQuery < GroupResourcePlacementState > query = new ServiceDocumentQuery < > ( getHost ( ) , GroupResourcePlacementState . class ) ; List < GroupResourcePlacementState > placements = new ArrayList < > ( ) ; query . query ( queryTask , null ) ; }
private void updatePlacements ( ResourcePoolService . ResourcePoolState resourcePoolState ) { QueryTask queryTask = QueryUtil . buildPropertyQuery ( GroupResourcePlacementService . GroupResourcePlacementState . class , GroupResourcePlacementService . GroupResourcePlacementState . FIELD_NAME_RESOURCE_POOL_LINK , resourcePoolState . documentSelfLink ) ; QueryUtil . addExpandOption ( queryTask ) ; ServiceDocumentQuery < GroupResourcePlacementState > query = new ServiceDocumentQuery < > ( getHost ( ) , GroupResourcePlacementState . class ) ; List < GroupResourcePlacementState > placements = new ArrayList < > ( ) ; query . query ( queryTask , null ) ; }
public void forceFullScan ( ) throws IOException { final Set < WorkspaceWatcher > watchers = new HashSet < WorkspaceWatcher > ( ) ; for ( final TFSRepositoryPathWatcher watcher : getPathWatchers ( ) ) { watchers . add ( watcher . getWatcher ( ) ) ; } for ( final WorkspaceWatcher watcher : watchers ) { watcher . forceFullScan ( ) ; } }
public void forceFullScan ( ) throws IOException { final Set < WorkspaceWatcher > watchers = new HashSet < WorkspaceWatcher > ( ) ; for ( final TFSRepositoryPathWatcher watcher : getPathWatchers ( ) ) { watchers . add ( watcher . getWatcher ( ) ) ; } for ( final WorkspaceWatcher watcher : watchers ) { watcher . forceFullScan ( ) ; } }
public void forceFullScan ( ) throws IOException { final Set < WorkspaceWatcher > watchers = new HashSet < WorkspaceWatcher > ( ) ; for ( final TFSRepositoryPathWatcher watcher : getPathWatchers ( ) ) { watchers . add ( watcher . getWatcher ( ) ) ; } for ( final WorkspaceWatcher watcher : watchers ) { watcher . forceFullScan ( ) ; } }
public void forceFullScan ( ) throws IOException { final Set < WorkspaceWatcher > watchers = new HashSet < WorkspaceWatcher > ( ) ; for ( final TFSRepositoryPathWatcher watcher : getPathWatchers ( ) ) { watchers . add ( watcher . getWatcher ( ) ) ; } for ( final WorkspaceWatcher watcher : watchers ) { watcher . forceFullScan ( ) ; } }
public void forceFullScan ( ) throws IOException { final Set < WorkspaceWatcher > watchers = new HashSet < WorkspaceWatcher > ( ) ; for ( final TFSRepositoryPathWatcher watcher : getPathWatchers ( ) ) { watchers . add ( watcher . getWatcher ( ) ) ; } for ( final WorkspaceWatcher watcher : watchers ) { watcher . forceFullScan ( ) ; } }
@ Override public int read ( ) throws IOException { while ( in != null ) { int result = in . read ( ) ; if ( result >= _NUM ) { return result ; } nextStream ( ) ; } return - _NUM ; }
@ Override public int read ( ) throws IOException { while ( in != null ) { int result = in . read ( ) ; if ( result >= _NUM ) { return result ; } nextStream ( ) ; } return - _NUM ; }
@ Override public int read ( ) throws IOException { while ( in != null ) { int result = in . read ( ) ; if ( result >= _NUM ) { return result ; } nextStream ( ) ; } return - _NUM ; }
@ Override public int read ( ) throws IOException { while ( in != null ) { int result = in . read ( ) ; if ( result >= _NUM ) { return result ; } nextStream ( ) ; } return - _NUM ; }
private double boxRadius ( int i , int a , int b ) { final int level ; if ( a < _NUM ) { if ( b >= pf . length ) { return Double . POSITIVE_INFINITY ; } level = maxRegLevel ( i , b ) ; } else if ( b >= pf . length ) { level = maxRegLevel ( i , a ) ; } else { level = Math . max ( maxRegLevel ( i , a ) , maxRegLevel ( i , b ) ) ; } return minDistLevel ( pf [ i ] . id , level ) ; }
private double boxRadius ( int i , int a , int b ) { final int level ; if ( a < _NUM ) { if ( b >= pf . length ) { return Double . POSITIVE_INFINITY ; } level = maxRegLevel ( i , b ) ; } else if ( b >= pf . length ) { level = maxRegLevel ( i , a ) ; } else { level = Math . max ( maxRegLevel ( i , a ) , maxRegLevel ( i , b ) ) ; } return minDistLevel ( pf [ i ] . id , level ) ; }
@ Timed @ ExceptionMetered @ Path ( STRING ) @ GET @ Produces ( APPLICATION_JSON ) public Iterable < SanitizedSecret > secretListingV2 ( @ Auth AutomationClient automationClient , @ QueryParam ( STRING ) Integer idx , @ QueryParam ( STRING ) Integer num , @ DefaultValue ( STRING ) @ QueryParam ( STRING ) boolean newestFirst ) { if ( idx != null && num != null ) { if ( idx < _NUM || num < _NUM ) { throw new BadRequestException ( STRING ) ; } return secretController . getSecretsBatched ( idx , num , newestFirst ) ; } return secretController . getSanitizedSecrets ( null , null ) ; }
@ Timed @ ExceptionMetered @ Path ( STRING ) @ GET @ Produces ( APPLICATION_JSON ) public Iterable < SanitizedSecret > secretListingV2 ( @ Auth AutomationClient automationClient , @ QueryParam ( STRING ) Integer idx , @ QueryParam ( STRING ) Integer num , @ DefaultValue ( STRING ) @ QueryParam ( STRING ) boolean newestFirst ) { if ( idx != null && num != null ) { if ( idx < _NUM || num < _NUM ) { throw new BadRequestException ( STRING ) ; } return secretController . getSecretsBatched ( idx , num , newestFirst ) ; } return secretController . getSanitizedSecrets ( null , null ) ; }
@ Timed @ ExceptionMetered @ Path ( STRING ) @ GET @ Produces ( APPLICATION_JSON ) public Iterable < SanitizedSecret > secretListingV2 ( @ Auth AutomationClient automationClient , @ QueryParam ( STRING ) Integer idx , @ QueryParam ( STRING ) Integer num , @ DefaultValue ( STRING ) @ QueryParam ( STRING ) boolean newestFirst ) { if ( idx != null && num != null ) { if ( idx < _NUM || num < _NUM ) { throw new BadRequestException ( STRING ) ; } return secretController . getSecretsBatched ( idx , num , newestFirst ) ; } return secretController . getSanitizedSecrets ( null , null ) ; }
public static boolean doubleArrayEquals ( double [ ] x , double [ ] y , double tol ) { for ( int i = _NUM ; i < x . length ; i += _NUM ) { if ( x [ i ] == _NUM ) { return y [ i ] == _NUM ; } if ( Math . abs ( ( y [ i ] - x [ i ] ) / x [ i ] ) > tol ) { return _BOOL ; } } return _BOOL ; }
public static String md5 ( String key ) { String cacheKey ; try { final MessageDigest mDigest = MessageDigest . getInstance ( STRING ) ; mDigest . update ( key . getBytes ( ) ) ; cacheKey = bytesToHexString ( mDigest . digest ( ) ) ; } catch ( NoSuchAlgorithmException e ) { cacheKey = String . valueOf ( key . hashCode ( ) ) ; } return cacheKey ; }
public static String md5 ( String key ) { String cacheKey ; try { final MessageDigest mDigest = MessageDigest . getInstance ( STRING ) ; mDigest . update ( key . getBytes ( ) ) ; cacheKey = bytesToHexString ( mDigest . digest ( ) ) ; } catch ( NoSuchAlgorithmException e ) { cacheKey = String . valueOf ( key . hashCode ( ) ) ; } return cacheKey ; }
private void startupAcceptor ( ) throws InterruptedException { if ( ! selectable ) { registerQueue . clear ( ) ; cancelQueue . clear ( ) ; flushingSessions . clear ( ) ; } lock . acquire ( ) ; if ( acceptor == null ) { acceptor = new Acceptor ( ) ; executeWorker ( acceptor ) ; } else { lock . release ( ) ; } }
public void collect ( Thread thread ) { final StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; collectByKey ( GLOBAL , stackTrace ) ; }
public void collect ( Thread thread ) { final StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; collectByKey ( GLOBAL , stackTrace ) ; }
public void collect ( Thread thread ) { final StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; collectByKey ( GLOBAL , stackTrace ) ; }
public void collect ( Thread thread ) { final StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; collectByKey ( GLOBAL , stackTrace ) ; }
public void collect ( Thread thread ) { final StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; collectByKey ( GLOBAL , stackTrace ) ; }
public void collect ( Thread thread ) { final StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; collectByKey ( GLOBAL , stackTrace ) ; }
public void collect ( Thread thread ) { final StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; collectByKey ( GLOBAL , stackTrace ) ; }
void addTerm ( MapBuilderTermType type , JClass jclass , String alias ) { MapBuilderTerm newTerm = new MapBuilderTerm ( ) ; newTerm . type = type ; newTerm . jclass = jclass ; newTerm . alias = alias ; terms . add ( newTerm ) ; }
private synchronized void updateEffectiveLevel ( ClassLoader loader ) { if ( loader == null ) loader = _systemClassLoader ; int oldEffectiveLevel = getEffectiveLevel ( loader ) ; Level newEffectiveLevel = calculateEffectiveLevel ( loader ) ; if ( oldEffectiveLevel == newEffectiveLevel . intValue ( ) && loader != _systemClassLoader ) return ; _finestEffectiveLevel = newEffectiveLevel ; _hasLocalEffectiveLevel = _BOOL ; updateEffectiveLevelPart ( _systemClassLoader ) ; updateEffectiveLevelPart ( loader ) ; for ( int i = _NUM ; i < _loaders . size ( ) ; i ++ ) { WeakReference < ClassLoader > loaderRef = _loaders . get ( i ) ; ClassLoader classLoader = loaderRef . get ( ) ; if ( classLoader != null ) updateEffectiveLevelPart ( classLoader ) ; } super . setLevel ( _finestEffectiveLevel ) ; _finestEffectiveLevelValue = _finestEffectiveLevel . intValue ( ) ; updateChildren ( ) ; }
private int findWordEnd ( String text , int pos ) { int end = - _NUM ; Matcher m = WORD . matcher ( text ) ; if ( pos > _NUM ) { pos -- ; } if ( m . find ( pos ) ) { end = m . end ( ) ; } if ( text . length ( ) == pos ) { end = text . length ( ) ; } if ( end == - _NUM ) { end = text . length ( ) ; } return end ; }
private int findWordEnd ( String text , int pos ) { int end = - _NUM ; Matcher m = WORD . matcher ( text ) ; if ( pos > _NUM ) { pos -- ; } if ( m . find ( pos ) ) { end = m . end ( ) ; } if ( text . length ( ) == pos ) { end = text . length ( ) ; } if ( end == - _NUM ) { end = text . length ( ) ; } return end ; }
private void addProgrammerBox ( ) { JPanel pane3a = new JPanel ( ) ; pane3a . setLayout ( new BoxLayout ( pane3a , BoxLayout . X_AXIS ) ) ; pane3a . add ( new JLabel ( Bundle . getMessage ( STRING ) ) ) ; programmerBox = new JComboBox < String > ( ProgDefault . findListOfProgFiles ( ) ) ; programmerBox . setSelectedIndex ( _NUM ) ; if ( ProgDefault . getDefaultProgFile ( ) != null ) { programmerBox . setSelectedItem ( ProgDefault . getDefaultProgFile ( ) ) ; } pane3a . add ( programmerBox ) ; add ( pane3a ) ; }
private void addProgrammerBox ( ) { JPanel pane3a = new JPanel ( ) ; pane3a . setLayout ( new BoxLayout ( pane3a , BoxLayout . X_AXIS ) ) ; pane3a . add ( new JLabel ( Bundle . getMessage ( STRING ) ) ) ; programmerBox = new JComboBox < String > ( ProgDefault . findListOfProgFiles ( ) ) ; programmerBox . setSelectedIndex ( _NUM ) ; if ( ProgDefault . getDefaultProgFile ( ) != null ) { programmerBox . setSelectedItem ( ProgDefault . getDefaultProgFile ( ) ) ; } pane3a . add ( programmerBox ) ; add ( pane3a ) ; }
public void createAndSendMoveToAction ( final Point2D point , boolean doubleClick ) { final RPAction action = new RPAction ( ) ; action . put ( STRING , STRING ) ; action . put ( STRING , ( int ) point . getX ( ) ) ; action . put ( STRING , ( int ) point . getY ( ) ) ; if ( doubleClick ) { action . put ( STRING , STRING ) ; } Direction dir = calculateZoneChangeDirection ( point ) ; if ( dir != null ) { action . put ( STRING , dir . ordinal ( ) ) ; } client . send ( action ) ; }
private String generateS3Path ( String pathPrefixParent , String topologyName , String filename ) { List < String > pathParts = new ArrayList < > ( Arrays . asList ( pathPrefixParent . split ( STRING ) ) ) ; pathParts . add ( topologyName ) ; pathParts . add ( filename ) ; return String . join ( STRING , pathParts ) ; }
public boolean supports ( @ MagicConstant ( flagsFromClass = Features . class ) int capability ) { IAndroidTarget target = getTarget ( ) ; if ( target != null ) { return RenderService . supportsCapability ( getModule ( ) , target , capability ) ; } return _BOOL ; }
public boolean supports ( @ MagicConstant ( flagsFromClass = Features . class ) int capability ) { IAndroidTarget target = getTarget ( ) ; if ( target != null ) { return RenderService . supportsCapability ( getModule ( ) , target , capability ) ; } return _BOOL ; }
public void addPrimary ( int part , int heap , long offheap , long swap ) { primary . add ( new VisorCachePartition ( part , heap , offheap , swap ) ) ; }
private static String listify ( final Collection < String > registers ) { final List < String > registerList = new ArrayList < String > ( registers ) ; Collections . sort ( registerList ) ; return Commafier . commafy ( registerList ) ; }
private static String listify ( final Collection < String > registers ) { final List < String > registerList = new ArrayList < String > ( registers ) ; Collections . sort ( registerList ) ; return Commafier . commafy ( registerList ) ; }
private static String listify ( final Collection < String > registers ) { final List < String > registerList = new ArrayList < String > ( registers ) ; Collections . sort ( registerList ) ; return Commafier . commafy ( registerList ) ; }
private static String listify ( final Collection < String > registers ) { final List < String > registerList = new ArrayList < String > ( registers ) ; Collections . sort ( registerList ) ; return Commafier . commafy ( registerList ) ; }
public void remove ( symbol sym ) throws internal_error { not_null ( sym ) ; _all . remove ( sym . name ( ) ) ; }
public void start ( ) throws Exception { if ( dbsvc != null ) { return ; } DataObjectScanner dataObjectScanner = new DataObjectScanner ( ) ; dataObjectScanner . setPackages ( modelPackages . toArray ( new String [ _NUM ] ) ) ; dataObjectScanner . init ( ) ; ServiceImpl dummyDBService = new ServiceImpl ( ) ; dummyDBService . setName ( STRING ) ; dummyDBService . setVersion ( STRING ) ; dummyDBService . setEndpoint ( URI . create ( STRING ) ) ; dummyDBService . setId ( STRING ) ; SchemaUtil schemaUtil = new SchemaUtil ( ) ; schemaUtil . setKeyspaceName ( STRING ) ; schemaUtil . setService ( dummyDBService ) ; schemaUtil . setCoordinator ( coordinatorClient ) ; schemaUtil . setDataObjectScanner ( dataObjectScanner ) ; String config = createConfig ( dataDir . getAbsolutePath ( ) ) ; dbsvc = new DbServiceImpl ( ) ; dbsvc . setConfig ( config ) ; dbsvc . setSchemaUtil ( schemaUtil ) ; dbsvc . setCoordinator ( coordinatorClient ) ; dbsvc . setService ( dummyDBService ) ; dbsvc . start ( ) ; }
public void start ( ) throws Exception { if ( dbsvc != null ) { return ; } DataObjectScanner dataObjectScanner = new DataObjectScanner ( ) ; dataObjectScanner . setPackages ( modelPackages . toArray ( new String [ _NUM ] ) ) ; dataObjectScanner . init ( ) ; ServiceImpl dummyDBService = new ServiceImpl ( ) ; dummyDBService . setName ( STRING ) ; dummyDBService . setVersion ( STRING ) ; dummyDBService . setEndpoint ( URI . create ( STRING ) ) ; dummyDBService . setId ( STRING ) ; SchemaUtil schemaUtil = new SchemaUtil ( ) ; schemaUtil . setKeyspaceName ( STRING ) ; schemaUtil . setService ( dummyDBService ) ; schemaUtil . setCoordinator ( coordinatorClient ) ; schemaUtil . setDataObjectScanner ( dataObjectScanner ) ; String config = createConfig ( dataDir . getAbsolutePath ( ) ) ; dbsvc = new DbServiceImpl ( ) ; dbsvc . setConfig ( config ) ; dbsvc . setSchemaUtil ( schemaUtil ) ; dbsvc . setCoordinator ( coordinatorClient ) ; dbsvc . setService ( dummyDBService ) ; dbsvc . start ( ) ; }
public void initialize ( int initialPoolSize ) { candidates . clear ( ) ; addRandomCandidates ( initialPoolSize ) ; }
public void initialize ( int initialPoolSize ) { candidates . clear ( ) ; addRandomCandidates ( initialPoolSize ) ; }
public void initialize ( int initialPoolSize ) { candidates . clear ( ) ; addRandomCandidates ( initialPoolSize ) ; }
public void initialize ( int initialPoolSize ) { candidates . clear ( ) ; addRandomCandidates ( initialPoolSize ) ; }
public void initialize ( int initialPoolSize ) { candidates . clear ( ) ; addRandomCandidates ( initialPoolSize ) ; }
public String constructTrainNumberOfCars ( String trainName ) throws IOException { Train train = tm . getTrainByName ( trainName ) ; if ( train != null ) { return String . valueOf ( train . getNumberCarsInTrain ( ) ) ; } sendErrorStatus ( STRING + trainName ) ; return null ; }
public String constructTrainNumberOfCars ( String trainName ) throws IOException { Train train = tm . getTrainByName ( trainName ) ; if ( train != null ) { return String . valueOf ( train . getNumberCarsInTrain ( ) ) ; } sendErrorStatus ( STRING + trainName ) ; return null ; }
public MemorizingTrustManager ( Context m , X509TrustManager defaultTrustManager ) { init ( m ) ; this . appTrustManager = getTrustManager ( appKeyStore ) ; this . defaultTrustManager = defaultTrustManager ; }
public abstract void internalPrepare ( OutputCollector collector , IMetadataChangeNotifyService metadataManager , Config config , TopologyContext context ) ;
public abstract void internalPrepare ( OutputCollector collector , IMetadataChangeNotifyService metadataManager , Config config , TopologyContext context ) ;
private void forceKillApplication ( ApplicationId appId ) throws YarnException , IOException { yarnClient . killApplication ( appId ) ; }
private void forceKillApplication ( ApplicationId appId ) throws YarnException , IOException { yarnClient . killApplication ( appId ) ; }
static public AnalysisContext currentAnalysisContext ( ) { return currentAnalysisContext . get ( ) ; }
public void openPopup ( ) { if ( settings == null ) { return ; } if ( ! isEnabled ( ) ) { return ; } if ( ! dateTextField . hasFocus ( ) ) { dateTextField . requestFocusInWindow ( ) ; } LocalDate selectedDateForCalendar = lastValidDate ; DatePicker thisDatePicker = this ; calendarPanel = new CalendarPanel ( thisDatePicker ) ; if ( selectedDateForCalendar != null ) { calendarPanel . setSelectedDate ( selectedDateForCalendar ) ; } popup = new CustomPopup ( calendarPanel , SwingUtilities . getWindowAncestor ( this ) , this , settings . getBorderCalendarPopup ( ) ) ; int defaultX = toggleCalendarButton . getLocationOnScreen ( ) . x + toggleCalendarButton . getBounds ( ) . width - popup . getBounds ( ) . width - _NUM ; int defaultY = toggleCalendarButton . getLocationOnScreen ( ) . y + toggleCalendarButton . getBounds ( ) . height + _NUM ; zSetPopupLocation ( popup , defaultX , defaultY , this , dateTextField , _NUM , _NUM ) ; popup . show ( ) ; calendarPanel . requestFocus ( ) ; }
public void openPopup ( ) { if ( settings == null ) { return ; } if ( ! isEnabled ( ) ) { return ; } if ( ! dateTextField . hasFocus ( ) ) { dateTextField . requestFocusInWindow ( ) ; } LocalDate selectedDateForCalendar = lastValidDate ; DatePicker thisDatePicker = this ; calendarPanel = new CalendarPanel ( thisDatePicker ) ; if ( selectedDateForCalendar != null ) { calendarPanel . setSelectedDate ( selectedDateForCalendar ) ; } popup = new CustomPopup ( calendarPanel , SwingUtilities . getWindowAncestor ( this ) , this , settings . getBorderCalendarPopup ( ) ) ; int defaultX = toggleCalendarButton . getLocationOnScreen ( ) . x + toggleCalendarButton . getBounds ( ) . width - popup . getBounds ( ) . width - _NUM ; int defaultY = toggleCalendarButton . getLocationOnScreen ( ) . y + toggleCalendarButton . getBounds ( ) . height + _NUM ; zSetPopupLocation ( popup , defaultX , defaultY , this , dateTextField , _NUM , _NUM ) ; popup . show ( ) ; calendarPanel . requestFocus ( ) ; }
public void openPopup ( ) { if ( settings == null ) { return ; } if ( ! isEnabled ( ) ) { return ; } if ( ! dateTextField . hasFocus ( ) ) { dateTextField . requestFocusInWindow ( ) ; } LocalDate selectedDateForCalendar = lastValidDate ; DatePicker thisDatePicker = this ; calendarPanel = new CalendarPanel ( thisDatePicker ) ; if ( selectedDateForCalendar != null ) { calendarPanel . setSelectedDate ( selectedDateForCalendar ) ; } popup = new CustomPopup ( calendarPanel , SwingUtilities . getWindowAncestor ( this ) , this , settings . getBorderCalendarPopup ( ) ) ; int defaultX = toggleCalendarButton . getLocationOnScreen ( ) . x + toggleCalendarButton . getBounds ( ) . width - popup . getBounds ( ) . width - _NUM ; int defaultY = toggleCalendarButton . getLocationOnScreen ( ) . y + toggleCalendarButton . getBounds ( ) . height + _NUM ; zSetPopupLocation ( popup , defaultX , defaultY , this , dateTextField , _NUM , _NUM ) ; popup . show ( ) ; calendarPanel . requestFocus ( ) ; }
public void openPopup ( ) { if ( settings == null ) { return ; } if ( ! isEnabled ( ) ) { return ; } if ( ! dateTextField . hasFocus ( ) ) { dateTextField . requestFocusInWindow ( ) ; } LocalDate selectedDateForCalendar = lastValidDate ; DatePicker thisDatePicker = this ; calendarPanel = new CalendarPanel ( thisDatePicker ) ; if ( selectedDateForCalendar != null ) { calendarPanel . setSelectedDate ( selectedDateForCalendar ) ; } popup = new CustomPopup ( calendarPanel , SwingUtilities . getWindowAncestor ( this ) , this , settings . getBorderCalendarPopup ( ) ) ; int defaultX = toggleCalendarButton . getLocationOnScreen ( ) . x + toggleCalendarButton . getBounds ( ) . width - popup . getBounds ( ) . width - _NUM ; int defaultY = toggleCalendarButton . getLocationOnScreen ( ) . y + toggleCalendarButton . getBounds ( ) . height + _NUM ; zSetPopupLocation ( popup , defaultX , defaultY , this , dateTextField , _NUM , _NUM ) ; popup . show ( ) ; calendarPanel . requestFocus ( ) ; }
public static void removeConnectionList ( Integer tab ) { TABBED_CONNECTIONS . remove ( tab . intValue ( ) ) ; }
public static int toChars ( int [ ] src , int srcOff , int srcLen , char [ ] dest , int destOff ) { if ( srcLen < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } int written = _NUM ; for ( int i = _NUM ; i < srcLen ; ++ i ) { written += Character . toChars ( src [ srcOff + i ] , dest , destOff + written ) ; } return written ; }
public static int toChars ( int [ ] src , int srcOff , int srcLen , char [ ] dest , int destOff ) { if ( srcLen < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } int written = _NUM ; for ( int i = _NUM ; i < srcLen ; ++ i ) { written += Character . toChars ( src [ srcOff + i ] , dest , destOff + written ) ; } return written ; }
protected boolean tryAgain ( ) { if ( ! isCancelled ( ) ) { try { value = request . request ( ) ; timeForNextRequest = - _NUM ; isDone = _BOOL ; } catch ( RateLimitException e ) { timeForNextRequest = System . currentTimeMillis ( ) + e . getRetryDelay ( ) ; bucket = e . getMethod ( ) ; } } return isDone ( ) || isCancelled ( ) ; }
public static < T > Set < T > emptySet ( final Set < T > set ) { return ( set != null ? set : Collections . < T > emptySet ( ) ) ; }
public static < T > Set < T > emptySet ( final Set < T > set ) { return ( set != null ? set : Collections . < T > emptySet ( ) ) ; }
public void fillDefaultValues ( ) { tfLearningRate . setText ( Double . toString ( HebbianCPCARule . DEFAULT_LEARNING_RATE ) ) ; tfM . setText ( Double . toString ( HebbianCPCARule . DEFAULT_M ) ) ; tfTheta . setText ( Double . toString ( HebbianCPCARule . DEFAULT_THETA ) ) ; tfLambda . setText ( Double . toString ( HebbianCPCARule . DEFAULT_LAMBDA ) ) ; }
public void fillDefaultValues ( ) { tfLearningRate . setText ( Double . toString ( HebbianCPCARule . DEFAULT_LEARNING_RATE ) ) ; tfM . setText ( Double . toString ( HebbianCPCARule . DEFAULT_M ) ) ; tfTheta . setText ( Double . toString ( HebbianCPCARule . DEFAULT_THETA ) ) ; tfLambda . setText ( Double . toString ( HebbianCPCARule . DEFAULT_LAMBDA ) ) ; }
public String sql_select ( String vendorName , String catalogName , String schemaName , String tableName , String condition ) { ArrayList < String > columnNames = null ; ArrayList < String > aliasNames = null ; ArrayList < String > conditions = null ; ArrayList < String > sortColumns = null ; if ( condition != null && condition . length ( ) > _NUM ) { conditions = new ArrayList < String > ( ) ; conditions . add ( condition ) ; } return sql_select ( vendorName , catalogName , schemaName , tableName , null , columnNames , aliasNames , conditions , sortColumns , _BOOL ) ; }
protected int align ( int e ) { int lostdigit = _NUM ; boolean inexact = _BOOL ; int diff = exp - e ; int adiff = diff ; if ( adiff < _NUM ) { adiff = - adiff ; } if ( diff == _NUM ) { return _NUM ; } if ( adiff > ( mant . length + _NUM ) ) { Arrays . fill ( mant , _NUM ) ; exp = e ; field . setIEEEFlagsBits ( DfpField . FLAG_INEXACT ) ; dotrap ( DfpField . FLAG_INEXACT , ALIGN_TRAP , this , this ) ; return _NUM ; } for ( int i = _NUM ; i < adiff ; i ++ ) { if ( diff < _NUM ) { if ( lostdigit != _NUM ) { inexact = _BOOL ; } lostdigit = mant [ _NUM ] ; shiftRight ( ) ; } else { shiftLeft ( ) ; } } if ( inexact ) { field . setIEEEFlagsBits ( DfpField . FLAG_INEXACT ) ; dotrap ( DfpField . FLAG_INEXACT , ALIGN_TRAP , this , this ) ; } return lostdigit ; }
protected int align ( int e ) { int lostdigit = _NUM ; boolean inexact = _BOOL ; int diff = exp - e ; int adiff = diff ; if ( adiff < _NUM ) { adiff = - adiff ; } if ( diff == _NUM ) { return _NUM ; } if ( adiff > ( mant . length + _NUM ) ) { Arrays . fill ( mant , _NUM ) ; exp = e ; field . setIEEEFlagsBits ( DfpField . FLAG_INEXACT ) ; dotrap ( DfpField . FLAG_INEXACT , ALIGN_TRAP , this , this ) ; return _NUM ; } for ( int i = _NUM ; i < adiff ; i ++ ) { if ( diff < _NUM ) { if ( lostdigit != _NUM ) { inexact = _BOOL ; } lostdigit = mant [ _NUM ] ; shiftRight ( ) ; } else { shiftLeft ( ) ; } } if ( inexact ) { field . setIEEEFlagsBits ( DfpField . FLAG_INEXACT ) ; dotrap ( DfpField . FLAG_INEXACT , ALIGN_TRAP , this , this ) ; } return lostdigit ; }
protected int align ( int e ) { int lostdigit = _NUM ; boolean inexact = _BOOL ; int diff = exp - e ; int adiff = diff ; if ( adiff < _NUM ) { adiff = - adiff ; } if ( diff == _NUM ) { return _NUM ; } if ( adiff > ( mant . length + _NUM ) ) { Arrays . fill ( mant , _NUM ) ; exp = e ; field . setIEEEFlagsBits ( DfpField . FLAG_INEXACT ) ; dotrap ( DfpField . FLAG_INEXACT , ALIGN_TRAP , this , this ) ; return _NUM ; } for ( int i = _NUM ; i < adiff ; i ++ ) { if ( diff < _NUM ) { if ( lostdigit != _NUM ) { inexact = _BOOL ; } lostdigit = mant [ _NUM ] ; shiftRight ( ) ; } else { shiftLeft ( ) ; } } if ( inexact ) { field . setIEEEFlagsBits ( DfpField . FLAG_INEXACT ) ; dotrap ( DfpField . FLAG_INEXACT , ALIGN_TRAP , this , this ) ; } return lostdigit ; }
protected int align ( int e ) { int lostdigit = _NUM ; boolean inexact = _BOOL ; int diff = exp - e ; int adiff = diff ; if ( adiff < _NUM ) { adiff = - adiff ; } if ( diff == _NUM ) { return _NUM ; } if ( adiff > ( mant . length + _NUM ) ) { Arrays . fill ( mant , _NUM ) ; exp = e ; field . setIEEEFlagsBits ( DfpField . FLAG_INEXACT ) ; dotrap ( DfpField . FLAG_INEXACT , ALIGN_TRAP , this , this ) ; return _NUM ; } for ( int i = _NUM ; i < adiff ; i ++ ) { if ( diff < _NUM ) { if ( lostdigit != _NUM ) { inexact = _BOOL ; } lostdigit = mant [ _NUM ] ; shiftRight ( ) ; } else { shiftLeft ( ) ; } } if ( inexact ) { field . setIEEEFlagsBits ( DfpField . FLAG_INEXACT ) ; dotrap ( DfpField . FLAG_INEXACT , ALIGN_TRAP , this , this ) ; } return lostdigit ; }
protected int align ( int e ) { int lostdigit = _NUM ; boolean inexact = _BOOL ; int diff = exp - e ; int adiff = diff ; if ( adiff < _NUM ) { adiff = - adiff ; } if ( diff == _NUM ) { return _NUM ; } if ( adiff > ( mant . length + _NUM ) ) { Arrays . fill ( mant , _NUM ) ; exp = e ; field . setIEEEFlagsBits ( DfpField . FLAG_INEXACT ) ; dotrap ( DfpField . FLAG_INEXACT , ALIGN_TRAP , this , this ) ; return _NUM ; } for ( int i = _NUM ; i < adiff ; i ++ ) { if ( diff < _NUM ) { if ( lostdigit != _NUM ) { inexact = _BOOL ; } lostdigit = mant [ _NUM ] ; shiftRight ( ) ; } else { shiftLeft ( ) ; } } if ( inexact ) { field . setIEEEFlagsBits ( DfpField . FLAG_INEXACT ) ; dotrap ( DfpField . FLAG_INEXACT , ALIGN_TRAP , this , this ) ; } return lostdigit ; }
protected int align ( int e ) { int lostdigit = _NUM ; boolean inexact = _BOOL ; int diff = exp - e ; int adiff = diff ; if ( adiff < _NUM ) { adiff = - adiff ; } if ( diff == _NUM ) { return _NUM ; } if ( adiff > ( mant . length + _NUM ) ) { Arrays . fill ( mant , _NUM ) ; exp = e ; field . setIEEEFlagsBits ( DfpField . FLAG_INEXACT ) ; dotrap ( DfpField . FLAG_INEXACT , ALIGN_TRAP , this , this ) ; return _NUM ; } for ( int i = _NUM ; i < adiff ; i ++ ) { if ( diff < _NUM ) { if ( lostdigit != _NUM ) { inexact = _BOOL ; } lostdigit = mant [ _NUM ] ; shiftRight ( ) ; } else { shiftLeft ( ) ; } } if ( inexact ) { field . setIEEEFlagsBits ( DfpField . FLAG_INEXACT ) ; dotrap ( DfpField . FLAG_INEXACT , ALIGN_TRAP , this , this ) ; } return lostdigit ; }
protected int align ( int e ) { int lostdigit = _NUM ; boolean inexact = _BOOL ; int diff = exp - e ; int adiff = diff ; if ( adiff < _NUM ) { adiff = - adiff ; } if ( diff == _NUM ) { return _NUM ; } if ( adiff > ( mant . length + _NUM ) ) { Arrays . fill ( mant , _NUM ) ; exp = e ; field . setIEEEFlagsBits ( DfpField . FLAG_INEXACT ) ; dotrap ( DfpField . FLAG_INEXACT , ALIGN_TRAP , this , this ) ; return _NUM ; } for ( int i = _NUM ; i < adiff ; i ++ ) { if ( diff < _NUM ) { if ( lostdigit != _NUM ) { inexact = _BOOL ; } lostdigit = mant [ _NUM ] ; shiftRight ( ) ; } else { shiftLeft ( ) ; } } if ( inexact ) { field . setIEEEFlagsBits ( DfpField . FLAG_INEXACT ) ; dotrap ( DfpField . FLAG_INEXACT , ALIGN_TRAP , this , this ) ; } return lostdigit ; }
protected int align ( int e ) { int lostdigit = _NUM ; boolean inexact = _BOOL ; int diff = exp - e ; int adiff = diff ; if ( adiff < _NUM ) { adiff = - adiff ; } if ( diff == _NUM ) { return _NUM ; } if ( adiff > ( mant . length + _NUM ) ) { Arrays . fill ( mant , _NUM ) ; exp = e ; field . setIEEEFlagsBits ( DfpField . FLAG_INEXACT ) ; dotrap ( DfpField . FLAG_INEXACT , ALIGN_TRAP , this , this ) ; return _NUM ; } for ( int i = _NUM ; i < adiff ; i ++ ) { if ( diff < _NUM ) { if ( lostdigit != _NUM ) { inexact = _BOOL ; } lostdigit = mant [ _NUM ] ; shiftRight ( ) ; } else { shiftLeft ( ) ; } } if ( inexact ) { field . setIEEEFlagsBits ( DfpField . FLAG_INEXACT ) ; dotrap ( DfpField . FLAG_INEXACT , ALIGN_TRAP , this , this ) ; } return lostdigit ; }
static public BTree doInsertRandomSparseKeySequenceTest ( final BTree btree , final int ninserts , final int trace ) { final int keys [ ] = new int [ ninserts ] ; final SimpleEntry entries [ ] = new SimpleEntry [ ninserts ] ; final Random r = new Random ( ) ; int lastKey = _NUM ; for ( int i = _NUM ; i < ninserts ; i ++ ) { final int key = r . nextInt ( _NUM ) + lastKey + _NUM ; keys [ i ] = key ; entries [ i ] = new SimpleEntry ( ) ; lastKey = key ; } return doInsertRandomKeySequenceTest ( btree , keys , entries , trace ) ; }
static public BTree doInsertRandomSparseKeySequenceTest ( final BTree btree , final int ninserts , final int trace ) { final int keys [ ] = new int [ ninserts ] ; final SimpleEntry entries [ ] = new SimpleEntry [ ninserts ] ; final Random r = new Random ( ) ; int lastKey = _NUM ; for ( int i = _NUM ; i < ninserts ; i ++ ) { final int key = r . nextInt ( _NUM ) + lastKey + _NUM ; keys [ i ] = key ; entries [ i ] = new SimpleEntry ( ) ; lastKey = key ; } return doInsertRandomKeySequenceTest ( btree , keys , entries , trace ) ; }
static public BTree doInsertRandomSparseKeySequenceTest ( final BTree btree , final int ninserts , final int trace ) { final int keys [ ] = new int [ ninserts ] ; final SimpleEntry entries [ ] = new SimpleEntry [ ninserts ] ; final Random r = new Random ( ) ; int lastKey = _NUM ; for ( int i = _NUM ; i < ninserts ; i ++ ) { final int key = r . nextInt ( _NUM ) + lastKey + _NUM ; keys [ i ] = key ; entries [ i ] = new SimpleEntry ( ) ; lastKey = key ; } return doInsertRandomKeySequenceTest ( btree , keys , entries , trace ) ; }
static public BTree doInsertRandomSparseKeySequenceTest ( final BTree btree , final int ninserts , final int trace ) { final int keys [ ] = new int [ ninserts ] ; final SimpleEntry entries [ ] = new SimpleEntry [ ninserts ] ; final Random r = new Random ( ) ; int lastKey = _NUM ; for ( int i = _NUM ; i < ninserts ; i ++ ) { final int key = r . nextInt ( _NUM ) + lastKey + _NUM ; keys [ i ] = key ; entries [ i ] = new SimpleEntry ( ) ; lastKey = key ; } return doInsertRandomKeySequenceTest ( btree , keys , entries , trace ) ; }
static public BTree doInsertRandomSparseKeySequenceTest ( final BTree btree , final int ninserts , final int trace ) { final int keys [ ] = new int [ ninserts ] ; final SimpleEntry entries [ ] = new SimpleEntry [ ninserts ] ; final Random r = new Random ( ) ; int lastKey = _NUM ; for ( int i = _NUM ; i < ninserts ; i ++ ) { final int key = r . nextInt ( _NUM ) + lastKey + _NUM ; keys [ i ] = key ; entries [ i ] = new SimpleEntry ( ) ; lastKey = key ; } return doInsertRandomKeySequenceTest ( btree , keys , entries , trace ) ; }
private void readClassFile ( ClassSymbol c ) throws IOException { int magic = nextInt ( ) ; if ( magic != JAVA_MAGIC ) throw badClassFile ( STRING ) ; minorVersion = nextChar ( ) ; majorVersion = nextChar ( ) ; int maxMajor = Target . MAX ( ) . majorVersion ; int maxMinor = Target . MAX ( ) . minorVersion ; if ( majorVersion > maxMajor || majorVersion * _NUM + minorVersion < Target . MIN ( ) . majorVersion * _NUM + Target . MIN ( ) . minorVersion ) { if ( majorVersion == ( maxMajor + _NUM ) ) log . warning ( STRING , currentClassFile , majorVersion , maxMajor ) ; else throw badClassFile ( STRING , Integer . toString ( majorVersion ) , Integer . toString ( minorVersion ) , Integer . toString ( maxMajor ) , Integer . toString ( maxMinor ) ) ; } else if ( checkClassFile && majorVersion == maxMajor && minorVersion > maxMinor ) { printCCF ( STRING , Integer . toString ( minorVersion ) ) ; } indexPool ( ) ; if ( signatureBuffer . length < bp ) { int ns = Integer . highestOneBit ( bp ) << _NUM ; signatureBuffer = new byte [ ns ] ; } readClass ( c ) ; }
public void clearCache ( ) { clearMemoryCache ( ) ; clearDiskCache ( ) ; }
public void clearCache ( ) { clearMemoryCache ( ) ; clearDiskCache ( ) ; }
public void clearCache ( ) { clearMemoryCache ( ) ; clearDiskCache ( ) ; }
public void clearCache ( ) { clearMemoryCache ( ) ; clearDiskCache ( ) ; }
protected int selectItem ( IntSortedSet remainingI , List < Tuple2od < I > > list ) { double [ ] max = new double [ ] { Double . NEGATIVE_INFINITY } ; int [ ] bestI = new int [ ] { remainingI . firstInt ( ) } ; remainingI . forEach ( null ) ; return bestI [ _NUM ] ; }
protected int selectItem ( IntSortedSet remainingI , List < Tuple2od < I > > list ) { double [ ] max = new double [ ] { Double . NEGATIVE_INFINITY } ; int [ ] bestI = new int [ ] { remainingI . firstInt ( ) } ; remainingI . forEach ( null ) ; return bestI [ _NUM ] ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
static StringBuilder appendQuotedString ( StringBuilder target , String key ) { target . append ( STRING ) ; for ( int i = _NUM , len = key . length ( ) ; i < len ; i ++ ) { char ch = key . charAt ( i ) ; switch ( ch ) { case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; case STRING : target . append ( STRING ) ; break ; default : target . append ( ch ) ; break ; } } target . append ( STRING ) ; return target ; }
private VbriFrame ( ByteBuffer header ) { this . header = header ; header . rewind ( ) ; header . position ( _NUM ) ; setAudioSize ( ) ; setFrameCount ( ) ; }
protected void waitForShutdownSignal ( ) throws InterruptedException { if ( mutexWaiting == null ) { mutexWaiting = new Object ( ) ; } try { synchronized ( mutexWaiting ) { mutexWaiting . wait ( ) ; } } catch ( InterruptedException e ) { if ( ! shutdown ) { throw e ; } } }
protected void waitForShutdownSignal ( ) throws InterruptedException { if ( mutexWaiting == null ) { mutexWaiting = new Object ( ) ; } try { synchronized ( mutexWaiting ) { mutexWaiting . wait ( ) ; } } catch ( InterruptedException e ) { if ( ! shutdown ) { throw e ; } } }
protected void waitForShutdownSignal ( ) throws InterruptedException { if ( mutexWaiting == null ) { mutexWaiting = new Object ( ) ; } try { synchronized ( mutexWaiting ) { mutexWaiting . wait ( ) ; } } catch ( InterruptedException e ) { if ( ! shutdown ) { throw e ; } } }
protected void waitForShutdownSignal ( ) throws InterruptedException { if ( mutexWaiting == null ) { mutexWaiting = new Object ( ) ; } try { synchronized ( mutexWaiting ) { mutexWaiting . wait ( ) ; } } catch ( InterruptedException e ) { if ( ! shutdown ) { throw e ; } } }
protected void waitForShutdownSignal ( ) throws InterruptedException { if ( mutexWaiting == null ) { mutexWaiting = new Object ( ) ; } try { synchronized ( mutexWaiting ) { mutexWaiting . wait ( ) ; } } catch ( InterruptedException e ) { if ( ! shutdown ) { throw e ; } } }
protected void waitForShutdownSignal ( ) throws InterruptedException { if ( mutexWaiting == null ) { mutexWaiting = new Object ( ) ; } try { synchronized ( mutexWaiting ) { mutexWaiting . wait ( ) ; } } catch ( InterruptedException e ) { if ( ! shutdown ) { throw e ; } } }
public ArrayList < Value > keys ( ) { ArrayList < Value > list = New . arrayList ( size ) ; for ( Value k : keys ) { if ( k != null && k != ValueNull . DELETED ) { list . add ( k ) ; } } return list ; }
public synchronized void addPanListener ( PanListener listener ) { mPanListeners . add ( listener ) ; }
private static BigInteger valueOf ( int val [ ] ) { return ( val [ _NUM ] > _NUM ? new BigInteger ( val , _NUM ) : new BigInteger ( val ) ) ; }
private static BigInteger valueOf ( int val [ ] ) { return ( val [ _NUM ] > _NUM ? new BigInteger ( val , _NUM ) : new BigInteger ( val ) ) ; }
public boolean show ( Container c , int x , int y , int w , int h ) { synchronized ( this ) { if ( painting ) { return _BOOL ; } showing = _BOOL ; } try { BufferInfo info = getBufferInfo ( c ) ; BufferStrategy bufferStrategy ; if ( info != null && info . isInSync ( ) && ( bufferStrategy = info . getBufferStrategy ( _BOOL ) ) != null ) { SubRegionShowable bsSubRegion = ( SubRegionShowable ) bufferStrategy ; boolean paintAllOnExpose = info . getPaintAllOnExpose ( ) ; info . setPaintAllOnExpose ( _BOOL ) ; if ( bsSubRegion . showIfNotLost ( x , y , ( x + w ) , ( y + h ) ) ) { return ! paintAllOnExpose ; } bufferInfo . setContentsLostDuringExpose ( _BOOL ) ; } } finally { synchronized ( this ) { showing = _BOOL ; notifyAll ( ) ; } } return _BOOL ; }
public boolean show ( Container c , int x , int y , int w , int h ) { synchronized ( this ) { if ( painting ) { return _BOOL ; } showing = _BOOL ; } try { BufferInfo info = getBufferInfo ( c ) ; BufferStrategy bufferStrategy ; if ( info != null && info . isInSync ( ) && ( bufferStrategy = info . getBufferStrategy ( _BOOL ) ) != null ) { SubRegionShowable bsSubRegion = ( SubRegionShowable ) bufferStrategy ; boolean paintAllOnExpose = info . getPaintAllOnExpose ( ) ; info . setPaintAllOnExpose ( _BOOL ) ; if ( bsSubRegion . showIfNotLost ( x , y , ( x + w ) , ( y + h ) ) ) { return ! paintAllOnExpose ; } bufferInfo . setContentsLostDuringExpose ( _BOOL ) ; } } finally { synchronized ( this ) { showing = _BOOL ; notifyAll ( ) ; } } return _BOOL ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; return result . elements ( ) ; }
private int calculateStrokeWeight ( ) { int strokeWeight = ( int ) ( getStrokeWidth ( ) * _NUM ) ; LOGGER . trace ( STRING , strokeWidth ) ; return strokeWeight ; }
@ SuppressWarnings ( STRING ) public static float valueRangeLimit ( float value , float startValue , float endValue ) { if ( value < Math . min ( startValue , endValue ) ) return Math . min ( startValue , endValue ) ; if ( value > Math . max ( startValue , endValue ) ) return Math . max ( startValue , endValue ) ; return value ; }
@ SuppressWarnings ( STRING ) public static float valueRangeLimit ( float value , float startValue , float endValue ) { if ( value < Math . min ( startValue , endValue ) ) return Math . min ( startValue , endValue ) ; if ( value > Math . max ( startValue , endValue ) ) return Math . max ( startValue , endValue ) ; return value ; }
@ Nullable private List < String > toArray ( @ Nullable String s , @ NotNull String separators , @ Nullable List < Boolean > markers ) { if ( s == null ) return null ; s = s . trim ( ) ; if ( s . isEmpty ( ) ) return null ; boolean p2nl = markers != null && mySettings . JD_P_AT_EMPTY_LINES ; List < String > list = new ArrayList < String > ( ) ; StringTokenizer st = new StringTokenizer ( s , separators , _BOOL ) ; boolean first = _BOOL ; int preCount = _NUM ; int curPos = _NUM ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; curPos += token . length ( ) ; if ( separators . contains ( token ) ) { if ( ! first ) { list . add ( STRING ) ; if ( markers != null ) markers . add ( Boolean . valueOf ( preCount > _NUM ) ) ; } first = _BOOL ; } else { first = _BOOL ; if ( p2nl ) { if ( isParaTag ( token ) && s . indexOf ( P_END_TAG , curPos ) < _NUM ) { list . add ( STRING ) ; markers . add ( Boolean . valueOf ( preCount > _NUM ) ) ; continue ; } } if ( preCount == _NUM ) token = token . trim ( ) ; list . add ( token ) ; if ( markers != null ) { if ( token . contains ( PRE_TAG_START ) ) preCount ++ ; markers . add ( Boolean . valueOf ( preCount > _NUM ) ) ; if ( token . contains ( PRE_TAG_END ) ) preCount -- ; } } } return list ; }
@ Nullable private List < String > toArray ( @ Nullable String s , @ NotNull String separators , @ Nullable List < Boolean > markers ) { if ( s == null ) return null ; s = s . trim ( ) ; if ( s . isEmpty ( ) ) return null ; boolean p2nl = markers != null && mySettings . JD_P_AT_EMPTY_LINES ; List < String > list = new ArrayList < String > ( ) ; StringTokenizer st = new StringTokenizer ( s , separators , _BOOL ) ; boolean first = _BOOL ; int preCount = _NUM ; int curPos = _NUM ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; curPos += token . length ( ) ; if ( separators . contains ( token ) ) { if ( ! first ) { list . add ( STRING ) ; if ( markers != null ) markers . add ( Boolean . valueOf ( preCount > _NUM ) ) ; } first = _BOOL ; } else { first = _BOOL ; if ( p2nl ) { if ( isParaTag ( token ) && s . indexOf ( P_END_TAG , curPos ) < _NUM ) { list . add ( STRING ) ; markers . add ( Boolean . valueOf ( preCount > _NUM ) ) ; continue ; } } if ( preCount == _NUM ) token = token . trim ( ) ; list . add ( token ) ; if ( markers != null ) { if ( token . contains ( PRE_TAG_START ) ) preCount ++ ; markers . add ( Boolean . valueOf ( preCount > _NUM ) ) ; if ( token . contains ( PRE_TAG_END ) ) preCount -- ; } } } return list ; }
public void removeUserMessageListener ( UserMessageListener userMessageListener ) { userMessageListeners . remove ( userMessageListener ) ; }
@ Override public void createControl ( Composite parent ) { initializeDialogUnits ( parent ) ; Composite composite = new Composite ( parent , SWT . NULL ) ; composite . setLayout ( new GridLayout ( ) ) ; composite . setLayoutData ( new GridData ( GridData . VERTICAL_ALIGN_FILL | GridData . HORIZONTAL_ALIGN_FILL ) ) ; composite . setFont ( parent . getFont ( ) ) ; createExportGoups ( composite ) ; restoreWidgetValues ( ) ; if ( initialResourceSelection != null ) { setupBasedOnInitialSelections ( ) ; } updateWidgetEnablements ( ) ; setPageComplete ( determinePageCompletion ( ) ) ; setErrorMessage ( null ) ; setControl ( composite ) ; giveFocusToDestination ( ) ; }
@ Override public void createControl ( Composite parent ) { initializeDialogUnits ( parent ) ; Composite composite = new Composite ( parent , SWT . NULL ) ; composite . setLayout ( new GridLayout ( ) ) ; composite . setLayoutData ( new GridData ( GridData . VERTICAL_ALIGN_FILL | GridData . HORIZONTAL_ALIGN_FILL ) ) ; composite . setFont ( parent . getFont ( ) ) ; createExportGoups ( composite ) ; restoreWidgetValues ( ) ; if ( initialResourceSelection != null ) { setupBasedOnInitialSelections ( ) ; } updateWidgetEnablements ( ) ; setPageComplete ( determinePageCompletion ( ) ) ; setErrorMessage ( null ) ; setControl ( composite ) ; giveFocusToDestination ( ) ; }
public void delete ( @ Nonnull Integer id ) throws HibernateException { EntityManager em = getEntityManager ( ) ; try { begin ( ) ; T_ENTITY entity = em . find ( entityClass , id ) ; if ( entity != null ) { LOG . debug ( STRING + entity . toString ( ) ) ; em . remove ( entity ) ; } commit ( ) ; } catch ( Exception e ) { rollback ( ) ; e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } finally { cleanup ( ) ; } }
public void removeActivity ( Activity activity ) { if ( activityStack == null ) { activityStack = new Stack < Activity > ( ) ; } activityStack . remove ( activity ) ; }
public String list ( String dir ) throws IOException { passive ( ) ; send ( STRING + dir ) ; readCode ( _NUM ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; IOUtils . copyAndClose ( inData , out ) ; readCode ( _NUM ) ; byte [ ] data = out . toByteArray ( ) ; return new String ( data ) ; }
private synchronized IMqttToken removeMqttToken ( Bundle data ) { String activityToken = data . getString ( MqttServiceConstants . CALLBACK_ACTIVITY_TOKEN ) ; if ( activityToken != null ) { int tokenNumber = Integer . parseInt ( activityToken ) ; IMqttToken token = tokenMap . get ( tokenNumber ) ; tokenMap . delete ( tokenNumber ) ; return token ; } return null ; }
private void enableDeviceCapabilitiesArea ( boolean enabled ) { mDisableCameraCheckbox . setEnabled ( enabled ) ; mDisableKeyguardWidgetsCheckbox . setEnabled ( enabled ) ; mDisableKeyguardSecureCameraCheckbox . setEnabled ( enabled ) ; mDisableKeyguardNotificationCheckbox . setEnabled ( enabled ) ; mDisableKeyguardUnredactedCheckbox . setEnabled ( enabled ) ; mDisableKeyguardTrustAgentCheckbox . setEnabled ( enabled ) ; mTrustAgentComponent . setEnabled ( enabled ) ; mTrustAgentFeatures . setEnabled ( enabled ) ; }
private void enableDeviceCapabilitiesArea ( boolean enabled ) { mDisableCameraCheckbox . setEnabled ( enabled ) ; mDisableKeyguardWidgetsCheckbox . setEnabled ( enabled ) ; mDisableKeyguardSecureCameraCheckbox . setEnabled ( enabled ) ; mDisableKeyguardNotificationCheckbox . setEnabled ( enabled ) ; mDisableKeyguardUnredactedCheckbox . setEnabled ( enabled ) ; mDisableKeyguardTrustAgentCheckbox . setEnabled ( enabled ) ; mTrustAgentComponent . setEnabled ( enabled ) ; mTrustAgentFeatures . setEnabled ( enabled ) ; }
public synchronized void stopRecording ( ) { if ( isRecordingOn ( ) ) { if ( null != stopRecordingFuture ) { if ( ! stopRecordingFuture . isDone ( ) && ! stopRecordingFuture . isCancelled ( ) ) { stopRecordingFuture . cancel ( _BOOL ) ; } stopRecordingFuture = null ; } Collection < AbstractDataProcessor > recordingDataProcessors = recordingProperties . getRecordingDataProcessors ( ) ; if ( null != recordingDataProcessors ) { for ( AbstractDataProcessor abstractDataProcessor : recordingDataProcessors ) { abstractDataProcessor . flush ( ) ; } } if ( ! involvedAgentsSet . isEmpty ( ) ) { List < SystemInformationData > toRecord = storageDataDao . getSystemInformationData ( involvedAgentsSet ) ; for ( SystemInformationData defaultData : toRecord ) { record ( defaultData ) ; } } involvedAgentsSet . clear ( ) ; if ( log . isDebugEnabled ( ) ) { log . info ( STRING + getStorageData ( ) ) ; } } else if ( isRecordingScheduled ( ) ) { if ( null != startRecordingFuture ) { if ( ! startRecordingFuture . isDone ( ) && ! startRecordingFuture . isCancelled ( ) ) { startRecordingFuture . cancel ( _BOOL ) ; } startRecordingFuture = null ; } } storageWriter = null ; recordingProperties = null ; recordingState = RecordingState . OFF ; }
private boolean isEmpty ( String value ) { if ( value != null ) { return value . length ( ) == _NUM ; } return _BOOL ; }
private CarbonDictionaryWriterImpl prepareWriter ( ) throws IOException { initDictionaryDirPaths ( ) ; return new CarbonDictionaryWriterImpl ( this . carbonStorePath , carbonTableIdentifier , columnIdentifier ) ; }
protected void updateThrottle ( ) { long now = CurrentTime . getCurrentTimeActual ( ) ; if ( _throttleTimestamp + _throttlePeriod < now ) { _throttleTimestamp = now ; _throttleCount = _NUM ; _isThrottle = _BOOL ; return ; } _throttleCount ++ ; if ( _throttleCount < _throttleLimit ) { return ; } if ( ! _isThrottle ) { _isThrottle = _BOOL ; if ( _throttleSleep > _NUM || log . isLoggable ( Level . FINE ) ) { String msg = ( this + STRING + _throttleCount + STRING + _throttlePeriod + STRING + STRING + _throttleSleep + STRING ) ; onThrottle ( msg ) ; } } if ( _throttleSleep > _NUM ) { try { Thread . sleep ( _throttleSleep ) ; } catch ( Exception e ) { } } }
private static List < Field > filterFieldList ( List < Field > fields , Class < ? > filterClass ) { List < Field > filteredFields = new LinkedList < > ( ) ; for ( Field f : fields ) { if ( ( filterClass == null ) || filterClass . isAssignableFrom ( f . getType ( ) ) ) { filteredFields . add ( f ) ; } } return filteredFields ; }
public void remove ( String key ) throws MqttPersistenceException { checkIsOpen ( ) ; File file = new File ( clientDir , key + MESSAGE_FILE_EXTENSION ) ; if ( file . exists ( ) ) { file . delete ( ) ; } }
public void remove ( String key ) throws MqttPersistenceException { checkIsOpen ( ) ; File file = new File ( clientDir , key + MESSAGE_FILE_EXTENSION ) ; if ( file . exists ( ) ) { file . delete ( ) ; } }
public void remove ( String key ) throws MqttPersistenceException { checkIsOpen ( ) ; File file = new File ( clientDir , key + MESSAGE_FILE_EXTENSION ) ; if ( file . exists ( ) ) { file . delete ( ) ; } }
public String toMatlab ( ) { StringBuffer result ; int i ; int n ; result = new StringBuffer ( ) ; result . append ( STRING ) ; for ( i = _NUM ; i < getRowDimension ( ) ; i ++ ) { if ( i > _NUM ) { result . append ( STRING ) ; } for ( n = _NUM ; n < getColumnDimension ( ) ; n ++ ) { if ( n > _NUM ) { result . append ( STRING ) ; } result . append ( Double . toString ( get ( i , n ) ) ) ; } } result . append ( STRING ) ; return result . toString ( ) ; }
public NTLMAuthentication ( boolean isProxy , URL url , PasswordAuthentication pw ) { super ( isProxy ? PROXY_AUTHENTICATION : SERVER_AUTHENTICATION , AuthScheme . NTLM , url , STRING ) ; init ( pw ) ; }
URLClassLoader newLoader ( URL base ) { return new URLClassLoader ( new URL [ ] { base } ) ; }
public Set < Property > allProperties ( ) { Set < Property > properties = new HashSet < Property > ( ) ; for ( Node n : nodes ) { n . includeProperties ( properties ) ; } return Collections . unmodifiableSet ( properties ) ; }
public Set < Property > allProperties ( ) { Set < Property > properties = new HashSet < Property > ( ) ; for ( Node n : nodes ) { n . includeProperties ( properties ) ; } return Collections . unmodifiableSet ( properties ) ; }
public Set < Property > allProperties ( ) { Set < Property > properties = new HashSet < Property > ( ) ; for ( Node n : nodes ) { n . includeProperties ( properties ) ; } return Collections . unmodifiableSet ( properties ) ; }
private void putParameterIntoS3 ( String s3BucketName , String s3ObjectKey , Parameter parameter ) { String content = parameter . getName ( ) + STRING + parameter . getValue ( ) ; byte [ ] bytes = content . getBytes ( ) ; ByteArrayInputStream inputStream = new ByteArrayInputStream ( bytes ) ; ObjectMetadata metadata = new ObjectMetadata ( ) ; metadata . setContentLength ( content . length ( ) ) ; PutObjectRequest putObjectRequest = new PutObjectRequest ( s3BucketName , s3ObjectKey , inputStream , metadata ) ; s3Operations . putObject ( putObjectRequest , null ) ; }
private void putParameterIntoS3 ( String s3BucketName , String s3ObjectKey , Parameter parameter ) { String content = parameter . getName ( ) + STRING + parameter . getValue ( ) ; byte [ ] bytes = content . getBytes ( ) ; ByteArrayInputStream inputStream = new ByteArrayInputStream ( bytes ) ; ObjectMetadata metadata = new ObjectMetadata ( ) ; metadata . setContentLength ( content . length ( ) ) ; PutObjectRequest putObjectRequest = new PutObjectRequest ( s3BucketName , s3ObjectKey , inputStream , metadata ) ; s3Operations . putObject ( putObjectRequest , null ) ; }
public String waitForConfigChange ( ) throws InterruptedException { logger . message ( STRING ) ; String msg = null ; try { msg = configChangedQueue . take ( ) ; } catch ( final InterruptedException e ) { logger . warning ( STRING ) ; throw e ; } logger . message ( STRING + msg ) ; return msg ; }
private String aggregateWildcard ( String targetToken ) { int len = _NUM ; if ( targetToken == null || ( len = targetToken . length ( ) ) == _NUM ) { return targetToken ; } char [ ] oldchars = targetToken . toCharArray ( ) ; char [ ] newchars = new char [ len ] ; int i = _NUM ; int j = _NUM ; int k = _NUM ; boolean foundWildcard = _BOOL ; while ( i < len ) { if ( targetToken . startsWith ( oneLevelWildcard , i ) ) { if ( ! foundWildcard ) { k = i ; while ( i < k + oneLevelWildcardLength ) { newchars [ j ++ ] = oldchars [ i ++ ] ; } foundWildcard = _BOOL ; } else { i = i + oneLevelWildcardLength ; } } else { foundWildcard = _BOOL ; newchars [ j ++ ] = oldchars [ i ++ ] ; } } return String . valueOf ( newchars , _NUM , j ) ; }
public static int extractReference ( String text ) { int lparenthIndex = text . indexOf ( STRING ) ; int spaceIndex = text . indexOf ( STRING ) ; if ( spaceIndex < _NUM ) { spaceIndex = text . length ( ) ; } if ( lparenthIndex < _NUM ) { return spaceIndex ; } else { if ( spaceIndex < lparenthIndex ) { return spaceIndex ; } int rparenthIndex = text . indexOf ( STRING , lparenthIndex ) ; if ( rparenthIndex < _NUM ) { rparenthIndex = text . length ( ) - _NUM ; } return rparenthIndex + _NUM ; } }
public XmlPullParser newPullParser ( ) throws XmlPullParserException { if ( parserClasses == null ) throw new XmlPullParserException ( STRING + classNamesLocation ) ; if ( parserClasses . size ( ) == _NUM ) throw new XmlPullParserException ( STRING + classNamesLocation ) ; final StringBuffer issues = new StringBuffer ( ) ; for ( int i = _NUM ; i < parserClasses . size ( ) ; i ++ ) { final Class ppClass = ( Class ) parserClasses . elementAt ( i ) ; try { final XmlPullParser pp = ( XmlPullParser ) ppClass . newInstance ( ) ; for ( Enumeration e = features . keys ( ) ; e . hasMoreElements ( ) ; ) { final String key = ( String ) e . nextElement ( ) ; final Boolean value = ( Boolean ) features . get ( key ) ; if ( value != null && value . booleanValue ( ) ) { pp . setFeature ( key , _BOOL ) ; } } return pp ; } catch ( Exception ex ) { issues . append ( ppClass . getName ( ) + STRING + ex . toString ( ) + STRING ) ; } } throw new XmlPullParserException ( STRING + issues ) ; }
public XmlPullParser newPullParser ( ) throws XmlPullParserException { if ( parserClasses == null ) throw new XmlPullParserException ( STRING + classNamesLocation ) ; if ( parserClasses . size ( ) == _NUM ) throw new XmlPullParserException ( STRING + classNamesLocation ) ; final StringBuffer issues = new StringBuffer ( ) ; for ( int i = _NUM ; i < parserClasses . size ( ) ; i ++ ) { final Class ppClass = ( Class ) parserClasses . elementAt ( i ) ; try { final XmlPullParser pp = ( XmlPullParser ) ppClass . newInstance ( ) ; for ( Enumeration e = features . keys ( ) ; e . hasMoreElements ( ) ; ) { final String key = ( String ) e . nextElement ( ) ; final Boolean value = ( Boolean ) features . get ( key ) ; if ( value != null && value . booleanValue ( ) ) { pp . setFeature ( key , _BOOL ) ; } } return pp ; } catch ( Exception ex ) { issues . append ( ppClass . getName ( ) + STRING + ex . toString ( ) + STRING ) ; } } throw new XmlPullParserException ( STRING + issues ) ; }
public XmlPullParser newPullParser ( ) throws XmlPullParserException { if ( parserClasses == null ) throw new XmlPullParserException ( STRING + classNamesLocation ) ; if ( parserClasses . size ( ) == _NUM ) throw new XmlPullParserException ( STRING + classNamesLocation ) ; final StringBuffer issues = new StringBuffer ( ) ; for ( int i = _NUM ; i < parserClasses . size ( ) ; i ++ ) { final Class ppClass = ( Class ) parserClasses . elementAt ( i ) ; try { final XmlPullParser pp = ( XmlPullParser ) ppClass . newInstance ( ) ; for ( Enumeration e = features . keys ( ) ; e . hasMoreElements ( ) ; ) { final String key = ( String ) e . nextElement ( ) ; final Boolean value = ( Boolean ) features . get ( key ) ; if ( value != null && value . booleanValue ( ) ) { pp . setFeature ( key , _BOOL ) ; } } return pp ; } catch ( Exception ex ) { issues . append ( ppClass . getName ( ) + STRING + ex . toString ( ) + STRING ) ; } } throw new XmlPullParserException ( STRING + issues ) ; }
public XmlPullParser newPullParser ( ) throws XmlPullParserException { if ( parserClasses == null ) throw new XmlPullParserException ( STRING + classNamesLocation ) ; if ( parserClasses . size ( ) == _NUM ) throw new XmlPullParserException ( STRING + classNamesLocation ) ; final StringBuffer issues = new StringBuffer ( ) ; for ( int i = _NUM ; i < parserClasses . size ( ) ; i ++ ) { final Class ppClass = ( Class ) parserClasses . elementAt ( i ) ; try { final XmlPullParser pp = ( XmlPullParser ) ppClass . newInstance ( ) ; for ( Enumeration e = features . keys ( ) ; e . hasMoreElements ( ) ; ) { final String key = ( String ) e . nextElement ( ) ; final Boolean value = ( Boolean ) features . get ( key ) ; if ( value != null && value . booleanValue ( ) ) { pp . setFeature ( key , _BOOL ) ; } } return pp ; } catch ( Exception ex ) { issues . append ( ppClass . getName ( ) + STRING + ex . toString ( ) + STRING ) ; } } throw new XmlPullParserException ( STRING + issues ) ; }
public void removeThread ( final TargetProcessThread thread ) { activeProcessThreads . remove ( thread ) ; for ( final ProcessManagerListener listener : listeners ) { try { listener . removedThread ( thread ) ; } catch ( final Exception exception ) { CUtilityFunctions . logException ( exception ) ; } } }
public boolean compare ( Object expected , Object current ) { if ( current != null ) { equal = current . equals ( expected ) ; } else if ( expected != null ) { equal = expected . equals ( _NUM ) ; } return equal ; }
public boolean compare ( Object expected , Object current ) { if ( current != null ) { equal = current . equals ( expected ) ; } else if ( expected != null ) { equal = expected . equals ( _NUM ) ; } return equal ; }
public boolean compare ( Object expected , Object current ) { if ( current != null ) { equal = current . equals ( expected ) ; } else if ( expected != null ) { equal = expected . equals ( _NUM ) ; } return equal ; }
public boolean compare ( Object expected , Object current ) { if ( current != null ) { equal = current . equals ( expected ) ; } else if ( expected != null ) { equal = expected . equals ( _NUM ) ; } return equal ; }
public boolean compare ( Object expected , Object current ) { if ( current != null ) { equal = current . equals ( expected ) ; } else if ( expected != null ) { equal = expected . equals ( _NUM ) ; } return equal ; }
public Money add ( Money money ) { assertDefined ( ) ; if ( null == m_value ) { if ( null == money . getBigDecimalValue ( ) ) { return new Money ( ) ; } else { return new Money ( money . getBigDecimalValue ( ) ) ; } } BigDecimal value = m_value . add ( money . getBigDecimalValue ( ) ) ; return new Money ( value ) ; }
public static DetalleEstadoBDBean obtenerEstadoBD ( Integer idEstado , String entidad ) throws SgmException { EstadosDatos estado = new EstadosDatos ( ) ; DetalleEstadoBDBean salida = new DetalleEstadoBDBean ( ) ; try { estado . setId ( idEstado . toString ( ) ) ; estado . load ( entidad ) ; salida . setId ( estado . getId ( ) ) ; salida . setIdSisnot ( estado . getIdSisnot ( ) ) ; salida . setDescripcion ( estado . getDescripcion ( ) ) ; } catch ( Exception ex ) { logger . debug ( STRING + ex . getMessage ( ) ) ; throw new ServicioWebExcepcion ( ServicioWebErrorCodigos . EC_UNKNOW_ERROR , ex ) ; } return salida ; }
public static DetalleEstadoBDBean obtenerEstadoBD ( Integer idEstado , String entidad ) throws SgmException { EstadosDatos estado = new EstadosDatos ( ) ; DetalleEstadoBDBean salida = new DetalleEstadoBDBean ( ) ; try { estado . setId ( idEstado . toString ( ) ) ; estado . load ( entidad ) ; salida . setId ( estado . getId ( ) ) ; salida . setIdSisnot ( estado . getIdSisnot ( ) ) ; salida . setDescripcion ( estado . getDescripcion ( ) ) ; } catch ( Exception ex ) { logger . debug ( STRING + ex . getMessage ( ) ) ; throw new ServicioWebExcepcion ( ServicioWebErrorCodigos . EC_UNKNOW_ERROR , ex ) ; } return salida ; }
private Object executeIn ( PageContext pc , SQL sql , Query qr , ZExpression expression , int row ) throws PageException { int len = expression . nbOperands ( ) ; Object left = executeExp ( pc , sql , qr , expression . getOperand ( _NUM ) , row ) ; for ( int i = _NUM ; i < len ; i ++ ) { if ( Operator . compare ( left , executeExp ( pc , sql , qr , expression . getOperand ( i ) , row ) ) == _NUM ) return Boolean . TRUE ; } return Boolean . FALSE ; }
void dumpUnsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + mConnectionId + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . toHexString ( System . identityHashCode ( mConnectionPtr ) ) ) ; } printer . println ( STRING + mIsPrimaryConnection ) ; printer . println ( STRING + mOnlyAllowReadOnlyOperations ) ; mRecentOperations . dump ( printer , verbose ) ; if ( verbose ) { mPreparedStatementCache . dump ( printer ) ; } }
void dumpUnsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + mConnectionId + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . toHexString ( System . identityHashCode ( mConnectionPtr ) ) ) ; } printer . println ( STRING + mIsPrimaryConnection ) ; printer . println ( STRING + mOnlyAllowReadOnlyOperations ) ; mRecentOperations . dump ( printer , verbose ) ; if ( verbose ) { mPreparedStatementCache . dump ( printer ) ; } }
void dumpUnsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + mConnectionId + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . toHexString ( System . identityHashCode ( mConnectionPtr ) ) ) ; } printer . println ( STRING + mIsPrimaryConnection ) ; printer . println ( STRING + mOnlyAllowReadOnlyOperations ) ; mRecentOperations . dump ( printer , verbose ) ; if ( verbose ) { mPreparedStatementCache . dump ( printer ) ; } }
void dumpUnsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + mConnectionId + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . toHexString ( System . identityHashCode ( mConnectionPtr ) ) ) ; } printer . println ( STRING + mIsPrimaryConnection ) ; printer . println ( STRING + mOnlyAllowReadOnlyOperations ) ; mRecentOperations . dump ( printer , verbose ) ; if ( verbose ) { mPreparedStatementCache . dump ( printer ) ; } }
void dumpUnsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + mConnectionId + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . toHexString ( System . identityHashCode ( mConnectionPtr ) ) ) ; } printer . println ( STRING + mIsPrimaryConnection ) ; printer . println ( STRING + mOnlyAllowReadOnlyOperations ) ; mRecentOperations . dump ( printer , verbose ) ; if ( verbose ) { mPreparedStatementCache . dump ( printer ) ; } }
void dumpUnsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + mConnectionId + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . toHexString ( System . identityHashCode ( mConnectionPtr ) ) ) ; } printer . println ( STRING + mIsPrimaryConnection ) ; printer . println ( STRING + mOnlyAllowReadOnlyOperations ) ; mRecentOperations . dump ( printer , verbose ) ; if ( verbose ) { mPreparedStatementCache . dump ( printer ) ; } }
void dumpUnsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + mConnectionId + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . toHexString ( System . identityHashCode ( mConnectionPtr ) ) ) ; } printer . println ( STRING + mIsPrimaryConnection ) ; printer . println ( STRING + mOnlyAllowReadOnlyOperations ) ; mRecentOperations . dump ( printer , verbose ) ; if ( verbose ) { mPreparedStatementCache . dump ( printer ) ; } }
void dumpUnsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + mConnectionId + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . toHexString ( System . identityHashCode ( mConnectionPtr ) ) ) ; } printer . println ( STRING + mIsPrimaryConnection ) ; printer . println ( STRING + mOnlyAllowReadOnlyOperations ) ; mRecentOperations . dump ( printer , verbose ) ; if ( verbose ) { mPreparedStatementCache . dump ( printer ) ; } }
void dumpUnsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + mConnectionId + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . toHexString ( System . identityHashCode ( mConnectionPtr ) ) ) ; } printer . println ( STRING + mIsPrimaryConnection ) ; printer . println ( STRING + mOnlyAllowReadOnlyOperations ) ; mRecentOperations . dump ( printer , verbose ) ; if ( verbose ) { mPreparedStatementCache . dump ( printer ) ; } }
void dumpUnsafe ( Printer printer , boolean verbose ) { printer . println ( STRING + mConnectionId + STRING ) ; if ( verbose ) { printer . println ( STRING + Integer . toHexString ( System . identityHashCode ( mConnectionPtr ) ) ) ; } printer . println ( STRING + mIsPrimaryConnection ) ; printer . println ( STRING + mOnlyAllowReadOnlyOperations ) ; mRecentOperations . dump ( printer , verbose ) ; if ( verbose ) { mPreparedStatementCache . dump ( printer ) ; } }
public boolean isDatabaseIntegrityOk ( ) { acquireReference ( ) ; try { List < Pair < String , String > > attachedDbs = null ; try { attachedDbs = getAttachedDbs ( ) ; if ( attachedDbs == null ) { throw new IllegalStateException ( STRING + getPath ( ) + STRING + STRING ) ; } } catch ( SQLiteException e ) { attachedDbs = new ArrayList < Pair < String , String > > ( ) ; attachedDbs . add ( new Pair < String , String > ( STRING , getPath ( ) ) ) ; } for ( int i = _NUM ; i < attachedDbs . size ( ) ; i ++ ) { Pair < String , String > p = attachedDbs . get ( i ) ; SQLiteStatement prog = null ; try { prog = compileStatement ( STRING + p . first + STRING ) ; String rslt = prog . simpleQueryForString ( ) ; if ( ! rslt . equalsIgnoreCase ( STRING ) ) { Log . e ( TAG , STRING + p . second + STRING + rslt ) ; return _BOOL ; } } finally { if ( prog != null ) prog . close ( ) ; } } } finally { releaseReference ( ) ; } return _BOOL ; }
public boolean isDatabaseIntegrityOk ( ) { acquireReference ( ) ; try { List < Pair < String , String > > attachedDbs = null ; try { attachedDbs = getAttachedDbs ( ) ; if ( attachedDbs == null ) { throw new IllegalStateException ( STRING + getPath ( ) + STRING + STRING ) ; } } catch ( SQLiteException e ) { attachedDbs = new ArrayList < Pair < String , String > > ( ) ; attachedDbs . add ( new Pair < String , String > ( STRING , getPath ( ) ) ) ; } for ( int i = _NUM ; i < attachedDbs . size ( ) ; i ++ ) { Pair < String , String > p = attachedDbs . get ( i ) ; SQLiteStatement prog = null ; try { prog = compileStatement ( STRING + p . first + STRING ) ; String rslt = prog . simpleQueryForString ( ) ; if ( ! rslt . equalsIgnoreCase ( STRING ) ) { Log . e ( TAG , STRING + p . second + STRING + rslt ) ; return _BOOL ; } } finally { if ( prog != null ) prog . close ( ) ; } } } finally { releaseReference ( ) ; } return _BOOL ; }
public boolean isDatabaseIntegrityOk ( ) { acquireReference ( ) ; try { List < Pair < String , String > > attachedDbs = null ; try { attachedDbs = getAttachedDbs ( ) ; if ( attachedDbs == null ) { throw new IllegalStateException ( STRING + getPath ( ) + STRING + STRING ) ; } } catch ( SQLiteException e ) { attachedDbs = new ArrayList < Pair < String , String > > ( ) ; attachedDbs . add ( new Pair < String , String > ( STRING , getPath ( ) ) ) ; } for ( int i = _NUM ; i < attachedDbs . size ( ) ; i ++ ) { Pair < String , String > p = attachedDbs . get ( i ) ; SQLiteStatement prog = null ; try { prog = compileStatement ( STRING + p . first + STRING ) ; String rslt = prog . simpleQueryForString ( ) ; if ( ! rslt . equalsIgnoreCase ( STRING ) ) { Log . e ( TAG , STRING + p . second + STRING + rslt ) ; return _BOOL ; } } finally { if ( prog != null ) prog . close ( ) ; } } } finally { releaseReference ( ) ; } return _BOOL ; }
public boolean isDatabaseIntegrityOk ( ) { acquireReference ( ) ; try { List < Pair < String , String > > attachedDbs = null ; try { attachedDbs = getAttachedDbs ( ) ; if ( attachedDbs == null ) { throw new IllegalStateException ( STRING + getPath ( ) + STRING + STRING ) ; } } catch ( SQLiteException e ) { attachedDbs = new ArrayList < Pair < String , String > > ( ) ; attachedDbs . add ( new Pair < String , String > ( STRING , getPath ( ) ) ) ; } for ( int i = _NUM ; i < attachedDbs . size ( ) ; i ++ ) { Pair < String , String > p = attachedDbs . get ( i ) ; SQLiteStatement prog = null ; try { prog = compileStatement ( STRING + p . first + STRING ) ; String rslt = prog . simpleQueryForString ( ) ; if ( ! rslt . equalsIgnoreCase ( STRING ) ) { Log . e ( TAG , STRING + p . second + STRING + rslt ) ; return _BOOL ; } } finally { if ( prog != null ) prog . close ( ) ; } } } finally { releaseReference ( ) ; } return _BOOL ; }
public boolean isDatabaseIntegrityOk ( ) { acquireReference ( ) ; try { List < Pair < String , String > > attachedDbs = null ; try { attachedDbs = getAttachedDbs ( ) ; if ( attachedDbs == null ) { throw new IllegalStateException ( STRING + getPath ( ) + STRING + STRING ) ; } } catch ( SQLiteException e ) { attachedDbs = new ArrayList < Pair < String , String > > ( ) ; attachedDbs . add ( new Pair < String , String > ( STRING , getPath ( ) ) ) ; } for ( int i = _NUM ; i < attachedDbs . size ( ) ; i ++ ) { Pair < String , String > p = attachedDbs . get ( i ) ; SQLiteStatement prog = null ; try { prog = compileStatement ( STRING + p . first + STRING ) ; String rslt = prog . simpleQueryForString ( ) ; if ( ! rslt . equalsIgnoreCase ( STRING ) ) { Log . e ( TAG , STRING + p . second + STRING + rslt ) ; return _BOOL ; } } finally { if ( prog != null ) prog . close ( ) ; } } } finally { releaseReference ( ) ; } return _BOOL ; }
public static boolean isLocalFileUri ( Uri uri ) { final String scheme = getSchemeOrNull ( uri ) ; return LOCAL_FILE_SCHEME . equals ( scheme ) ; }
public static boolean isLocalFileUri ( Uri uri ) { final String scheme = getSchemeOrNull ( uri ) ; return LOCAL_FILE_SCHEME . equals ( scheme ) ; }
public DebugInputBitStream ( final InputBitStream ibs , final PrintStream pw ) { this . ibs = ibs ; this . pw = pw ; pw . print ( STRING ) ; }
public DebugInputBitStream ( final InputBitStream ibs , final PrintStream pw ) { this . ibs = ibs ; this . pw = pw ; pw . print ( STRING ) ; }
public DebugInputBitStream ( final InputBitStream ibs , final PrintStream pw ) { this . ibs = ibs ; this . pw = pw ; pw . print ( STRING ) ; }
void updateInsets ( ) { short top = ( short ) painter . getInset ( TOP , this ) ; short bottom = ( short ) painter . getInset ( BOTTOM , this ) ; if ( captionIndex != - _NUM ) { View caption = getView ( captionIndex ) ; short h = ( short ) caption . getPreferredSpan ( Y_AXIS ) ; AttributeSet a = caption . getAttributes ( ) ; Object align = a . getAttribute ( CSS . Attribute . CAPTION_SIDE ) ; if ( ( align != null ) && ( align . equals ( STRING ) ) ) { bottom += h ; } else { top += h ; } } setInsets ( top , ( short ) painter . getInset ( LEFT , this ) , bottom , ( short ) painter . getInset ( RIGHT , this ) ) ; }
void updateInsets ( ) { short top = ( short ) painter . getInset ( TOP , this ) ; short bottom = ( short ) painter . getInset ( BOTTOM , this ) ; if ( captionIndex != - _NUM ) { View caption = getView ( captionIndex ) ; short h = ( short ) caption . getPreferredSpan ( Y_AXIS ) ; AttributeSet a = caption . getAttributes ( ) ; Object align = a . getAttribute ( CSS . Attribute . CAPTION_SIDE ) ; if ( ( align != null ) && ( align . equals ( STRING ) ) ) { bottom += h ; } else { top += h ; } } setInsets ( top , ( short ) painter . getInset ( LEFT , this ) , bottom , ( short ) painter . getInset ( RIGHT , this ) ) ; }
void updateInsets ( ) { short top = ( short ) painter . getInset ( TOP , this ) ; short bottom = ( short ) painter . getInset ( BOTTOM , this ) ; if ( captionIndex != - _NUM ) { View caption = getView ( captionIndex ) ; short h = ( short ) caption . getPreferredSpan ( Y_AXIS ) ; AttributeSet a = caption . getAttributes ( ) ; Object align = a . getAttribute ( CSS . Attribute . CAPTION_SIDE ) ; if ( ( align != null ) && ( align . equals ( STRING ) ) ) { bottom += h ; } else { top += h ; } } setInsets ( top , ( short ) painter . getInset ( LEFT , this ) , bottom , ( short ) painter . getInset ( RIGHT , this ) ) ; }
public int indexOf ( int ch ) { return indexOf ( ch , _NUM ) ; }
public int indexOf ( int ch ) { return indexOf ( ch , _NUM ) ; }
public int indexOf ( int ch ) { return indexOf ( ch , _NUM ) ; }
public int indexOf ( int ch ) { return indexOf ( ch , _NUM ) ; }
private static void createFixedPartitionList ( int primaryIndex ) { fpaList . clear ( ) ; if ( primaryIndex == _NUM ) { fpaList . add ( FixedPartitionAttributes . createFixedPartition ( STRING , _BOOL , _NUM ) ) ; fpaList . add ( FixedPartitionAttributes . createFixedPartition ( STRING , _NUM ) ) ; fpaList . add ( FixedPartitionAttributes . createFixedPartition ( STRING , _NUM ) ) ; } if ( primaryIndex == _NUM ) { fpaList . add ( FixedPartitionAttributes . createFixedPartition ( STRING , _NUM ) ) ; fpaList . add ( FixedPartitionAttributes . createFixedPartition ( STRING , _BOOL , _NUM ) ) ; fpaList . add ( FixedPartitionAttributes . createFixedPartition ( STRING , _NUM ) ) ; } if ( primaryIndex == _NUM ) { fpaList . add ( FixedPartitionAttributes . createFixedPartition ( STRING , _NUM ) ) ; fpaList . add ( FixedPartitionAttributes . createFixedPartition ( STRING , _NUM ) ) ; fpaList . add ( FixedPartitionAttributes . createFixedPartition ( STRING , _BOOL , _NUM ) ) ; } }
@ Override public void dropDatabaseSchema ( AbstractSession session , Writer writer ) throws EclipseLinkException { buildDatabaseSchemaDeletionWriter ( session , writer ) ; }
private void draw ( final ExecutionUnit process , final Graphics2D g2 , final ProcessRendererModel rendererModel , final boolean printing ) { ProcessBackgroundImage image = rendererModel . getBackgroundImage ( process ) ; if ( image != null ) { Graphics2D g2D = ( Graphics2D ) g2 . create ( ) ; int x = image . getX ( ) ; int y = image . getY ( ) ; int w = image . getWidth ( ) ; int h = image . getHeight ( ) ; if ( x == - _NUM ) { double processWidth = rendererModel . getProcessWidth ( process ) ; x = ( int ) ( ( processWidth - w ) / _NUM ) ; } if ( y == - _NUM ) { double processHeight = rendererModel . getProcessHeight ( process ) ; y = ( int ) ( ( processHeight - h ) / _NUM ) ; } if ( rendererModel . getZoomFactor ( ) > _NUM ) { float alpha = Math . max ( MIN_OPACITY , _NUM - ( float ) rendererModel . getZoomFactor ( ) ) ; AlphaComposite ac = AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , alpha ) ; g2D . setComposite ( ac ) ; } g2D . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BILINEAR ) ; g2D . drawImage ( image . getImage ( loadListener ) , x , y , w , h , null ) ; g2D . dispose ( ) ; } }
protected void smoothScrollByOffset ( int position ) { int index = - _NUM ; if ( position < _NUM ) { index = getFirstVisiblePosition ( ) ; } else if ( position > _NUM ) { index = getLastVisiblePosition ( ) ; } if ( index > - _NUM ) { View child = getChildAt ( index - getFirstVisiblePosition ( ) ) ; if ( child != null ) { Rect visibleRect = new Rect ( ) ; if ( child . getGlobalVisibleRect ( visibleRect ) ) { int childRectArea = child . getWidth ( ) * child . getHeight ( ) ; int visibleRectArea = visibleRect . width ( ) * visibleRect . height ( ) ; float visibleArea = ( visibleRectArea / ( float ) childRectArea ) ; final float visibleThreshold = _NUM ; if ( ( position < _NUM ) && ( visibleArea < visibleThreshold ) ) { ++ index ; } else if ( ( position > _NUM ) && ( visibleArea < visibleThreshold ) ) { -- index ; } } smoothScrollToPosition ( Math . max ( _NUM , Math . min ( getCount ( ) , index + position ) ) ) ; } } }
public void windowClosing ( java . awt . event . WindowEvent e ) { doneButtonActionPerformed ( ) ; }
public void windowClosing ( java . awt . event . WindowEvent e ) { doneButtonActionPerformed ( ) ; }
public static boolean isInProcessMode ( ProjectSystemId externalSystemId ) { return Registry . is ( externalSystemId . getId ( ) + ExternalSystemConstants . USE_IN_PROCESS_COMMUNICATION_REGISTRY_KEY_SUFFIX , _BOOL ) ; }
public static boolean isInProcessMode ( ProjectSystemId externalSystemId ) { return Registry . is ( externalSystemId . getId ( ) + ExternalSystemConstants . USE_IN_PROCESS_COMMUNICATION_REGISTRY_KEY_SUFFIX , _BOOL ) ; }
public static boolean isInProcessMode ( ProjectSystemId externalSystemId ) { return Registry . is ( externalSystemId . getId ( ) + ExternalSystemConstants . USE_IN_PROCESS_COMMUNICATION_REGISTRY_KEY_SUFFIX , _BOOL ) ; }
public static boolean isInProcessMode ( ProjectSystemId externalSystemId ) { return Registry . is ( externalSystemId . getId ( ) + ExternalSystemConstants . USE_IN_PROCESS_COMMUNICATION_REGISTRY_KEY_SUFFIX , _BOOL ) ; }
public static boolean isInProcessMode ( ProjectSystemId externalSystemId ) { return Registry . is ( externalSystemId . getId ( ) + ExternalSystemConstants . USE_IN_PROCESS_COMMUNICATION_REGISTRY_KEY_SUFFIX , _BOOL ) ; }
public static boolean isInProcessMode ( ProjectSystemId externalSystemId ) { return Registry . is ( externalSystemId . getId ( ) + ExternalSystemConstants . USE_IN_PROCESS_COMMUNICATION_REGISTRY_KEY_SUFFIX , _BOOL ) ; }
public static boolean isInProcessMode ( ProjectSystemId externalSystemId ) { return Registry . is ( externalSystemId . getId ( ) + ExternalSystemConstants . USE_IN_PROCESS_COMMUNICATION_REGISTRY_KEY_SUFFIX , _BOOL ) ; }
public static boolean isInProcessMode ( ProjectSystemId externalSystemId ) { return Registry . is ( externalSystemId . getId ( ) + ExternalSystemConstants . USE_IN_PROCESS_COMMUNICATION_REGISTRY_KEY_SUFFIX , _BOOL ) ; }
public static boolean isInProcessMode ( ProjectSystemId externalSystemId ) { return Registry . is ( externalSystemId . getId ( ) + ExternalSystemConstants . USE_IN_PROCESS_COMMUNICATION_REGISTRY_KEY_SUFFIX , _BOOL ) ; }
public static boolean isInProcessMode ( ProjectSystemId externalSystemId ) { return Registry . is ( externalSystemId . getId ( ) + ExternalSystemConstants . USE_IN_PROCESS_COMMUNICATION_REGISTRY_KEY_SUFFIX , _BOOL ) ; }
public static boolean isInProcessMode ( ProjectSystemId externalSystemId ) { return Registry . is ( externalSystemId . getId ( ) + ExternalSystemConstants . USE_IN_PROCESS_COMMUNICATION_REGISTRY_KEY_SUFFIX , _BOOL ) ; }
public static boolean isInProcessMode ( ProjectSystemId externalSystemId ) { return Registry . is ( externalSystemId . getId ( ) + ExternalSystemConstants . USE_IN_PROCESS_COMMUNICATION_REGISTRY_KEY_SUFFIX , _BOOL ) ; }
public static boolean isInProcessMode ( ProjectSystemId externalSystemId ) { return Registry . is ( externalSystemId . getId ( ) + ExternalSystemConstants . USE_IN_PROCESS_COMMUNICATION_REGISTRY_KEY_SUFFIX , _BOOL ) ; }
public short [ ] readShortArray ( final int items , final JBBPByteOrder byteOrder ) throws IOException { int pos = _NUM ; if ( items < _NUM ) { short [ ] buffer = new short [ INITIAL_ARRAY_BUFFER_SIZE ] ; while ( hasAvailableData ( ) ) { final int next = readUnsignedShort ( byteOrder ) ; if ( buffer . length == pos ) { final short [ ] newbuffer = new short [ buffer . length << _NUM ] ; System . arraycopy ( buffer , _NUM , newbuffer , _NUM , buffer . length ) ; buffer = newbuffer ; } buffer [ pos ++ ] = ( short ) next ; } if ( buffer . length == pos ) { return buffer ; } final short [ ] result = new short [ pos ] ; System . arraycopy ( buffer , _NUM , result , _NUM , pos ) ; return result ; } else { final short [ ] buffer = new short [ items ] ; for ( int i = _NUM ; i < items ; i ++ ) { buffer [ i ] = ( short ) readUnsignedShort ( byteOrder ) ; } return buffer ; } }
@ POST @ Path ( STRING ) @ Consumes ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ Produces ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) public Response validateUserPasswordForChange ( @ Context HttpServletRequest httpRequest , PasswordChangeParam passwordParam ) { String clientIP = _invLoginManager . getClientIP ( httpRequest ) ; isClientIPBlocked ( clientIP ) ; Response response = _passwordUtils . changePassword ( passwordParam , _BOOL ) ; return response ; }
@ Override public URI toVertexURI ( final Object key ) { return toURI ( key . toString ( ) ) ; }
public void rearrangeChildren ( int itemCount ) { ArrayList < View > views = getItemsInReadingOrder ( ) ; mContent . arrangeChildren ( views , Math . max ( itemCount , views . size ( ) ) ) ; mItemsInvalidated = _BOOL ; }
public void rearrangeChildren ( int itemCount ) { ArrayList < View > views = getItemsInReadingOrder ( ) ; mContent . arrangeChildren ( views , Math . max ( itemCount , views . size ( ) ) ) ; mItemsInvalidated = _BOOL ; }
public FilterableTripleHandler ( StringBuffer osw , List < String > negativeFilterNamespaces , List < String > positivFilterNamespaces ) { this . writer = osw ; this . negativeFilterNamespaces = negativeFilterNamespaces ; this . positiveFilterNamespaces = positivFilterNamespaces ; for ( String ex : EXTRACTORS ) { triplesPerExtractor . put ( ex , new Long ( _NUM ) ) ; } }
public FilterableTripleHandler ( StringBuffer osw , List < String > negativeFilterNamespaces , List < String > positivFilterNamespaces ) { this . writer = osw ; this . negativeFilterNamespaces = negativeFilterNamespaces ; this . positiveFilterNamespaces = positivFilterNamespaces ; for ( String ex : EXTRACTORS ) { triplesPerExtractor . put ( ex , new Long ( _NUM ) ) ; } }
public FilterableTripleHandler ( StringBuffer osw , List < String > negativeFilterNamespaces , List < String > positivFilterNamespaces ) { this . writer = osw ; this . negativeFilterNamespaces = negativeFilterNamespaces ; this . positiveFilterNamespaces = positivFilterNamespaces ; for ( String ex : EXTRACTORS ) { triplesPerExtractor . put ( ex , new Long ( _NUM ) ) ; } }
protected WireFormat ( String name ) { this . name = name ; }
@ SuppressWarnings ( { STRING , STRING } ) public static Comparable < ? > max ( Comparable < ? > [ ] ar ) { Comparable ret = ar [ _NUM ] ; for ( int i = _NUM ; i < ar . length ; i ++ ) { if ( ret . compareTo ( ar [ i ] ) < _NUM ) { ret = ar [ i ] ; } } return ret ; }
public void run ( ) { closed = _BOOL ; thread = Thread . currentThread ( ) ; do { try { byte [ ] message = sendQueue . take ( ) ; DatagramPacket req = requests . remove ( ModbusUtil . registersToInt ( message ) ) ; if ( req != null ) { DatagramPacket res = new DatagramPacket ( message , message . length , req . getAddress ( ) , req . getPort ( ) ) ; socket . send ( res ) ; logger . debug ( STRING ) ; } } catch ( Exception ex ) { if ( running ) { logger . error ( STRING , ex ) ; } } } while ( running ) ; closed = _BOOL ; }
public void run ( ) { closed = _BOOL ; thread = Thread . currentThread ( ) ; do { try { byte [ ] message = sendQueue . take ( ) ; DatagramPacket req = requests . remove ( ModbusUtil . registersToInt ( message ) ) ; if ( req != null ) { DatagramPacket res = new DatagramPacket ( message , message . length , req . getAddress ( ) , req . getPort ( ) ) ; socket . send ( res ) ; logger . debug ( STRING ) ; } } catch ( Exception ex ) { if ( running ) { logger . error ( STRING , ex ) ; } } } while ( running ) ; closed = _BOOL ; }
Date delayedDate ( long delayMillis ) { return new Date ( System . currentTimeMillis ( ) + delayMillis + _NUM ) ; }
Date delayedDate ( long delayMillis ) { return new Date ( System . currentTimeMillis ( ) + delayMillis + _NUM ) ; }
Date delayedDate ( long delayMillis ) { return new Date ( System . currentTimeMillis ( ) + delayMillis + _NUM ) ; }
public void serialize ( ManagedObjectPathSerializer serializer ) { for ( Element < ? , ? > element : elements ) { element . serialize ( serializer ) ; } }
public void serialize ( ManagedObjectPathSerializer serializer ) { for ( Element < ? , ? > element : elements ) { element . serialize ( serializer ) ; } }
public void add ( SelectClauseElementRaw element ) { selectClauseElements . add ( element ) ; }
@ Override public double [ ] makeInverseCumulativeTestValues ( ) { double [ ] points = makeCumulativeTestPoints ( ) ; double [ ] points2 = new double [ points . length - _NUM ] ; System . arraycopy ( points , _NUM , points2 , _NUM , points . length - _NUM ) ; return points2 ; }
public String line ( ) throws IOException { StringBuilder buffer = new StringBuilder ( ) ; while ( _BOOL ) { if ( buffer . length ( ) > Hash . MAX ) { throw new IOException ( STRING ) ; } int a = real ( ) ; if ( a == STRING ) { return buffer . toString ( ) ; } if ( a == STRING ) { int b = real ( ) ; if ( b == STRING ) { return buffer . toString ( ) ; } else if ( b > - _NUM ) { buffer . append ( ( char ) a ) ; buffer . append ( ( char ) b ) ; } } else if ( a > - _NUM ) { buffer . append ( ( char ) a ) ; } } }
public static String withFirst ( String input , Function < Character , String > callback ) { if ( input == null ) { return null ; } else if ( input . length ( ) == _NUM ) { return STRING ; } else { return String . join ( STRING , callback . apply ( input . charAt ( _NUM ) ) , input . subSequence ( _NUM , input . length ( ) ) ) ; } }
@ Override protected void fireInsertUpdate ( DocumentEvent evt ) { if ( tokenMarker != null ) { DocumentEvent . ElementChange ch = evt . getChange ( getDefaultRootElement ( ) ) ; if ( ch != null ) { tokenMarker . insertLines ( ch . getIndex ( ) + _NUM , ch . getChildrenAdded ( ) . length - ch . getChildrenRemoved ( ) . length ) ; } } super . fireInsertUpdate ( evt ) ; }
@ Override protected void fireInsertUpdate ( DocumentEvent evt ) { if ( tokenMarker != null ) { DocumentEvent . ElementChange ch = evt . getChange ( getDefaultRootElement ( ) ) ; if ( ch != null ) { tokenMarker . insertLines ( ch . getIndex ( ) + _NUM , ch . getChildrenAdded ( ) . length - ch . getChildrenRemoved ( ) . length ) ; } } super . fireInsertUpdate ( evt ) ; }
@ Override protected void fireInsertUpdate ( DocumentEvent evt ) { if ( tokenMarker != null ) { DocumentEvent . ElementChange ch = evt . getChange ( getDefaultRootElement ( ) ) ; if ( ch != null ) { tokenMarker . insertLines ( ch . getIndex ( ) + _NUM , ch . getChildrenAdded ( ) . length - ch . getChildrenRemoved ( ) . length ) ; } } super . fireInsertUpdate ( evt ) ; }
@ Override protected void fireInsertUpdate ( DocumentEvent evt ) { if ( tokenMarker != null ) { DocumentEvent . ElementChange ch = evt . getChange ( getDefaultRootElement ( ) ) ; if ( ch != null ) { tokenMarker . insertLines ( ch . getIndex ( ) + _NUM , ch . getChildrenAdded ( ) . length - ch . getChildrenRemoved ( ) . length ) ; } } super . fireInsertUpdate ( evt ) ; }
@ Override protected void fireInsertUpdate ( DocumentEvent evt ) { if ( tokenMarker != null ) { DocumentEvent . ElementChange ch = evt . getChange ( getDefaultRootElement ( ) ) ; if ( ch != null ) { tokenMarker . insertLines ( ch . getIndex ( ) + _NUM , ch . getChildrenAdded ( ) . length - ch . getChildrenRemoved ( ) . length ) ; } } super . fireInsertUpdate ( evt ) ; }
@ Override protected void fireInsertUpdate ( DocumentEvent evt ) { if ( tokenMarker != null ) { DocumentEvent . ElementChange ch = evt . getChange ( getDefaultRootElement ( ) ) ; if ( ch != null ) { tokenMarker . insertLines ( ch . getIndex ( ) + _NUM , ch . getChildrenAdded ( ) . length - ch . getChildrenRemoved ( ) . length ) ; } } super . fireInsertUpdate ( evt ) ; }
private static boolean isTempPathSecure ( ) { if ( ! wasTempPathChecked ) { synchronized ( WindowsAttachProvider . class ) { if ( ! wasTempPathChecked ) { String temp = tempPath ( ) ; if ( ( temp != null ) && ( temp . length ( ) >= _NUM ) && ( temp . charAt ( _NUM ) == STRING ) && ( temp . charAt ( _NUM ) == STRING ) ) { long flags = volumeFlags ( temp . substring ( _NUM , _NUM ) ) ; isTempPathSecure = ( ( flags & FS_PERSISTENT_ACLS ) != _NUM ) ; } wasTempPathChecked = _BOOL ; } } } return isTempPathSecure ; }
private static boolean isTempPathSecure ( ) { if ( ! wasTempPathChecked ) { synchronized ( WindowsAttachProvider . class ) { if ( ! wasTempPathChecked ) { String temp = tempPath ( ) ; if ( ( temp != null ) && ( temp . length ( ) >= _NUM ) && ( temp . charAt ( _NUM ) == STRING ) && ( temp . charAt ( _NUM ) == STRING ) ) { long flags = volumeFlags ( temp . substring ( _NUM , _NUM ) ) ; isTempPathSecure = ( ( flags & FS_PERSISTENT_ACLS ) != _NUM ) ; } wasTempPathChecked = _BOOL ; } } } return isTempPathSecure ; }
public static String quoteStringSQL ( String s ) { if ( s == null ) { return STRING ; } int length = s . length ( ) ; StringBuilder buff = new StringBuilder ( length + _NUM ) ; buff . append ( STRING ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = s . charAt ( i ) ; if ( c == STRING ) { buff . append ( c ) ; } else if ( c < STRING || c > _NUM ) { return STRING + quoteStringSQL ( javaEncode ( s ) ) + STRING ; } buff . append ( c ) ; } buff . append ( STRING ) ; return buff . toString ( ) ; }
private void addIndex ( Index < K , V > idx , HeadIndex < K , V > h , int indexLevel ) { int insertionLevel = indexLevel ; Comparable < ? super K > key = comparable ( idx . node . key ) ; if ( key == null ) throw new NullPointerException ( ) ; for ( ; ; ) { int j = h . level ; Index < K , V > q = h ; Index < K , V > r = q . right ; Index < K , V > t = idx ; for ( ; ; ) { if ( r != null ) { Node < K , V > n = r . node ; int c = key . compareTo ( n . key ) ; if ( n . value == null ) { if ( ! q . unlink ( r ) ) break ; r = q . right ; continue ; } if ( c > _NUM ) { q = r ; r = r . right ; continue ; } } if ( j == insertionLevel ) { if ( t . indexesDeletedNode ( ) ) { findNode ( key ) ; return ; } if ( ! q . link ( r , t ) ) break ; if ( -- insertionLevel == _NUM ) { if ( t . indexesDeletedNode ( ) ) findNode ( key ) ; return ; } } if ( -- j >= insertionLevel && j < indexLevel ) t = t . down ; q = q . down ; r = q . right ; } } }
public static Date parse ( String timeString ) throws ParseException { if ( timeString == null || timeString . isEmpty ( ) ) return null ; DateFormat timeFormat = new SimpleDateFormat ( TimeField . FORMAT ) ; return timeFormat . parse ( timeString ) ; }
public static Date parse ( String timeString ) throws ParseException { if ( timeString == null || timeString . isEmpty ( ) ) return null ; DateFormat timeFormat = new SimpleDateFormat ( TimeField . FORMAT ) ; return timeFormat . parse ( timeString ) ; }
public void componentShown ( ComponentEvent e ) { Layer layer = getLayer ( ) ; if ( layer != null ) { if ( e . getComponent ( ) == layer ) { if ( getState ( ) != _BOOL && menuType == LAYERS_ON_OFF ) { setState ( _BOOL ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + layer . getName ( ) + STRING ) ; } } } else if ( e . getComponent ( ) == layer . getPalette ( ) && menuType == PALETTES_ON_OFF ) { setState ( _BOOL ) ; } } }
public static String hashMapToString ( HashMap < ? , ? > map , int dp ) { StringBuilder sb = new StringBuilder ( ) ; for ( Object k : map . keySet ( ) ) { sb . append ( Utils . padRight ( k . toString ( ) , _NUM ) ) ; Object obj = map . get ( k ) ; if ( obj instanceof Double ) { sb . append ( Utils . doubleToString ( ( Double ) obj , _NUM , dp ) ) ; } else if ( obj instanceof double [ ] ) { sb . append ( A . toString ( ( double [ ] ) obj , dp ) ) ; } else if ( obj instanceof int [ ] ) { sb . append ( A . toString ( ( int [ ] ) obj , dp + _NUM ) ) ; } else if ( obj instanceof String ) { String s = ( String ) obj ; if ( s . contains ( STRING ) ) sb . append ( STRING ) ; sb . append ( obj ) ; if ( s . contains ( STRING ) ) sb . append ( STRING ) ; } else { } sb . append ( STRING ) ; } return sb . toString ( ) ; }
public void launch ( ) { if ( TextUtils . isEmpty ( appName ) ) { throw new RuntimeException ( STRING ) ; } if ( permissions . isEmpty ( ) ) { throw new RuntimeException ( STRING ) ; } List < Permission > permissionList = permissionsDenied ( permissions ) ; if ( permissionList == null || permissionList . isEmpty ( ) ) { return ; } permissionsActivity = this ; Intent permissionActivity = new Intent ( launchContext , PermissionsFlowActivity . class ) ; permissionActivity . putExtra ( APP_NAME , appName ) ; permissionActivity . putExtra ( PERMISSIONS , permissionList . toArray ( new Permission [ permissionList . size ( ) ] ) ) ; permissionActivity . putExtra ( BG_COLOR , bgColor ) ; permissionActivity . putExtra ( BAR_COLOR , barColor ) ; permissionActivity . putExtra ( MAIN_TEXT_COLOR , mainTextColor ) ; permissionActivity . putExtra ( MAIN_TEXT_COLOR_SECONDARY , mainTextColorSecondary ) ; permissionActivity . putExtra ( BAR_TEXT_COLOR , barTextColor ) ; permissionActivity . putExtra ( STATUS_BAR_COLOR , statusBarColor ) ; permissionActivity . putExtra ( NAVIGATION_BAR_COLOR , navBarColor ) ; permissionActivity . putExtra ( LIGHT_STATUS_BAR , lightStatusBar ) ; permissionActivity . putExtra ( ICON_COLOR , iconColor ) ; permissionActivity . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; launchContext . startActivity ( permissionActivity ) ; }
public boolean inTestSet ( String sourceSide ) { if ( ! sourceSide . equals ( lastSourceSide ) ) { lastSourceSide = sourceSide ; acceptedLastSourceSide = filter . permits ( sourceSide ) ; } else { cached ++ ; } return acceptedLastSourceSide ; }
public boolean inTestSet ( String sourceSide ) { if ( ! sourceSide . equals ( lastSourceSide ) ) { lastSourceSide = sourceSide ; acceptedLastSourceSide = filter . permits ( sourceSide ) ; } else { cached ++ ; } return acceptedLastSourceSide ; }
public boolean inTestSet ( String sourceSide ) { if ( ! sourceSide . equals ( lastSourceSide ) ) { lastSourceSide = sourceSide ; acceptedLastSourceSide = filter . permits ( sourceSide ) ; } else { cached ++ ; } return acceptedLastSourceSide ; }
ThreadPool ( ThreadGroup threadGroup ) { this . threadGroup = threadGroup ; }
ThreadPool ( ThreadGroup threadGroup ) { this . threadGroup = threadGroup ; }
ThreadPool ( ThreadGroup threadGroup ) { this . threadGroup = threadGroup ; }
ThreadPool ( ThreadGroup threadGroup ) { this . threadGroup = threadGroup ; }
@ Category ( FlakyTest . class ) @ Test public void testMissingMemberRedundancy1 ( ) { Host host = Host . getHost ( _NUM ) ; VM vm0 = host . getVM ( _NUM ) ; VM vm1 = host . getVM ( _NUM ) ; VM vm2 = host . getVM ( _NUM ) ; createPR ( vm0 , _NUM ) ; createPR ( vm1 , _NUM ) ; createData ( vm0 , _NUM , NUM_BUCKETS , STRING ) ; Set < Integer > vm0Buckets = getBucketList ( vm0 ) ; Set < Integer > vm1Buckets = getBucketList ( vm1 ) ; closeCache ( vm1 ) ; checkData ( vm0 , _NUM , NUM_BUCKETS , STRING ) ; removeData ( vm0 , _NUM , NUM_BUCKETS / _NUM ) ; createData ( vm0 , NUM_BUCKETS / _NUM , NUM_BUCKETS , STRING ) ; createPR ( vm2 , _NUM ) ; Set < Integer > vm2Buckets = getBucketList ( vm2 ) ; assertEquals ( Collections . emptySet ( ) , vm2Buckets ) ; createPR ( vm1 , _NUM ) ; checkData ( vm1 , _NUM , NUM_BUCKETS / _NUM , null ) ; checkData ( vm1 , NUM_BUCKETS / _NUM , NUM_BUCKETS , STRING ) ; assertEquals ( vm0Buckets , getBucketList ( vm0 ) ) ; assertEquals ( vm1Buckets , getBucketList ( vm1 ) ) ; assertEquals ( Collections . emptySet ( ) , getBucketList ( vm2 ) ) ; }
@ Category ( FlakyTest . class ) @ Test public void testMissingMemberRedundancy1 ( ) { Host host = Host . getHost ( _NUM ) ; VM vm0 = host . getVM ( _NUM ) ; VM vm1 = host . getVM ( _NUM ) ; VM vm2 = host . getVM ( _NUM ) ; createPR ( vm0 , _NUM ) ; createPR ( vm1 , _NUM ) ; createData ( vm0 , _NUM , NUM_BUCKETS , STRING ) ; Set < Integer > vm0Buckets = getBucketList ( vm0 ) ; Set < Integer > vm1Buckets = getBucketList ( vm1 ) ; closeCache ( vm1 ) ; checkData ( vm0 , _NUM , NUM_BUCKETS , STRING ) ; removeData ( vm0 , _NUM , NUM_BUCKETS / _NUM ) ; createData ( vm0 , NUM_BUCKETS / _NUM , NUM_BUCKETS , STRING ) ; createPR ( vm2 , _NUM ) ; Set < Integer > vm2Buckets = getBucketList ( vm2 ) ; assertEquals ( Collections . emptySet ( ) , vm2Buckets ) ; createPR ( vm1 , _NUM ) ; checkData ( vm1 , _NUM , NUM_BUCKETS / _NUM , null ) ; checkData ( vm1 , NUM_BUCKETS / _NUM , NUM_BUCKETS , STRING ) ; assertEquals ( vm0Buckets , getBucketList ( vm0 ) ) ; assertEquals ( vm1Buckets , getBucketList ( vm1 ) ) ; assertEquals ( Collections . emptySet ( ) , getBucketList ( vm2 ) ) ; }
public Message ( String type , double value ) { if ( ! VALID_TYPES . contains ( type ) ) { throw new IllegalArgumentException ( type + STRING + STRING ) ; } this . type = type ; this . value = value ; }
public static boolean isInputStreamGZIPCompressed ( final PushbackInputStream inputStream ) throws IOException { if ( inputStream == null ) return _BOOL ; byte [ ] signature = new byte [ _NUM ] ; int readStatus = inputStream . read ( signature ) ; inputStream . unread ( signature ) ; int streamHeader = ( ( int ) signature [ _NUM ] & _NUM ) | ( ( signature [ _NUM ] << _NUM ) & _NUM ) ; return readStatus == _NUM && GZIPInputStream . GZIP_MAGIC == streamHeader ; }
public static String formatUrlForSecurityDisplay ( URI uri , boolean showScheme ) { return formatUrlForSecurityDisplay ( uri . toString ( ) , showScheme ) ; }
boolean hasMinFeatureCount ( String feature ) { if ( minFeatureCount == _NUM ) return _BOOL ; Set < Integer > ids = clippedFeatureIndex . get ( feature ) ; if ( ids == null ) return _BOOL ; return ids . size ( ) >= minFeatureCount ; }
boolean hasMinFeatureCount ( String feature ) { if ( minFeatureCount == _NUM ) return _BOOL ; Set < Integer > ids = clippedFeatureIndex . get ( feature ) ; if ( ids == null ) return _BOOL ; return ids . size ( ) >= minFeatureCount ; }
boolean hasMinFeatureCount ( String feature ) { if ( minFeatureCount == _NUM ) return _BOOL ; Set < Integer > ids = clippedFeatureIndex . get ( feature ) ; if ( ids == null ) return _BOOL ; return ids . size ( ) >= minFeatureCount ; }
public int y ( double lat ) { return ( int ) Math . round ( dotsPerDeg * ( originLat - lat ) ) ; }
public int y ( double lat ) { return ( int ) Math . round ( dotsPerDeg * ( originLat - lat ) ) ; }
public static TempPath createDirectory ( Path dir ) throws IOException { return wrap ( Files . createTempDirectory ( dir , PREFIX ) ) ; }
public static TempPath createDirectory ( Path dir ) throws IOException { return wrap ( Files . createTempDirectory ( dir , PREFIX ) ) ; }
public String pickImage ( ) { String path = null ; try { path = pick ( ) ; } catch ( PickerException e ) { e . printStackTrace ( ) ; if ( callback != null ) { callback . onError ( e . getMessage ( ) ) ; } } return path ; }
protected void rejectDrop ( ) { DropTargetContextPeer peer = getDropTargetContextPeer ( ) ; if ( peer != null ) { peer . rejectDrop ( ) ; } }
protected void fillParameter ( PreparedStatement stmt , int idx , JdbcTypeField field , @ Nullable Object fieldVal ) throws CacheException { try { if ( fieldVal != null ) { if ( field . getJavaFieldType ( ) == UUID . class ) { switch ( field . getDatabaseFieldType ( ) ) { case Types . BINARY : fieldVal = U . uuidToBytes ( ( UUID ) fieldVal ) ; break ; case Types . CHAR : case Types . VARCHAR : fieldVal = fieldVal . toString ( ) ; break ; } } stmt . setObject ( idx , fieldVal ) ; } else stmt . setNull ( idx , field . getDatabaseFieldType ( ) ) ; } catch ( SQLException e ) { throw new CacheException ( STRING + field . getDatabaseFieldName ( ) , e ) ; } }
protected void putChild ( String name , FieldVector vector ) { putVector ( name , vector ) ; }
protected void putChild ( String name , FieldVector vector ) { putVector ( name , vector ) ; }
int priorityValue ( int state ) { int value = _NUM ; switch ( state ) { case AbstractValue . UNKNOWN : value ++ ; case AbstractValue . DIFF : value ++ ; case AbstractValue . EDITED : value ++ ; case AbstractValue . FROMFILE : value ++ ; default : return value ; } }
private static void generateReservationTokenAttribute ( ReservationTokenAttribute token , int nb ) { long left = System . currentTimeMillis ( ) ; long right = random . nextLong ( ) ; int b = nb / _NUM ; for ( int i = _NUM ; i < b ; i ++ ) { token . reservationToken [ i ] = ( byte ) ( ( left > > ( i * _NUM ) ) & _NUM ) ; token . reservationToken [ i + b ] = ( byte ) ( ( right > > ( i * _NUM ) ) & _NUM ) ; } token . hashCode = ( token . reservationToken [ _NUM ] << _NUM & _NUM ) | ( token . reservationToken [ _NUM ] << _NUM & _NUM ) | ( token . reservationToken [ _NUM ] << _NUM & _NUM ) | ( token . reservationToken [ _NUM ] & _NUM ) ; }
@ SuppressWarnings ( STRING ) void addAdapter ( int position , UniversalAdapter adapter ) { int count = getCount ( ) ; ListPiece piece = new ListPiece ( adapter , this ) ; listPieces . add ( position , piece ) ; piece . setStartPosition ( count ) ; piece . initializeItemViewTypes ( ) ; }
public Storage ( File directory , String propertiesFile ) { if ( directory == null ) throw new NullPointerException ( STRING ) ; if ( directory . isFile ( ) ) throw new IllegalArgumentException ( STRING + directory ) ; this . directory = directory ; this . propertiesFile = propertiesFile != null ? new File ( directory , propertiesFile ) : null ; }
public String createMessage ( SsoRuntimeException e ) { return createMessage ( e . getMessageKey ( ) , e . getMessageDetails ( ) , e . getMessage ( ) ) ; }
public boolean draw ( Canvas canvas ) { update ( ) ; final float centerX = mBounds . centerX ( ) ; final float centerY = mBounds . height ( ) - mRadius ; canvas . scale ( _NUM , Math . min ( mGlowScaleY , _NUM ) * mBaseGlowScale , centerX , _NUM ) ; final float displacement = Math . max ( _NUM , Math . min ( mDisplacement , _NUM ) ) - _NUM ; float translateX = mBounds . width ( ) * displacement / _NUM ; mPaint . setAlpha ( ( int ) ( _NUM * mGlowAlpha ) ) ; canvas . drawCircle ( centerX + translateX , centerY , mRadius , mPaint ) ; boolean oneLastFrame = _BOOL ; if ( mState == STATE_RECEDE && mGlowScaleY == _NUM ) { mState = STATE_IDLE ; oneLastFrame = _BOOL ; } return mState != STATE_IDLE || oneLastFrame ; }
public boolean draw ( Canvas canvas ) { update ( ) ; final float centerX = mBounds . centerX ( ) ; final float centerY = mBounds . height ( ) - mRadius ; canvas . scale ( _NUM , Math . min ( mGlowScaleY , _NUM ) * mBaseGlowScale , centerX , _NUM ) ; final float displacement = Math . max ( _NUM , Math . min ( mDisplacement , _NUM ) ) - _NUM ; float translateX = mBounds . width ( ) * displacement / _NUM ; mPaint . setAlpha ( ( int ) ( _NUM * mGlowAlpha ) ) ; canvas . drawCircle ( centerX + translateX , centerY , mRadius , mPaint ) ; boolean oneLastFrame = _BOOL ; if ( mState == STATE_RECEDE && mGlowScaleY == _NUM ) { mState = STATE_IDLE ; oneLastFrame = _BOOL ; } return mState != STATE_IDLE || oneLastFrame ; }
public boolean draw ( Canvas canvas ) { update ( ) ; final float centerX = mBounds . centerX ( ) ; final float centerY = mBounds . height ( ) - mRadius ; canvas . scale ( _NUM , Math . min ( mGlowScaleY , _NUM ) * mBaseGlowScale , centerX , _NUM ) ; final float displacement = Math . max ( _NUM , Math . min ( mDisplacement , _NUM ) ) - _NUM ; float translateX = mBounds . width ( ) * displacement / _NUM ; mPaint . setAlpha ( ( int ) ( _NUM * mGlowAlpha ) ) ; canvas . drawCircle ( centerX + translateX , centerY , mRadius , mPaint ) ; boolean oneLastFrame = _BOOL ; if ( mState == STATE_RECEDE && mGlowScaleY == _NUM ) { mState = STATE_IDLE ; oneLastFrame = _BOOL ; } return mState != STATE_IDLE || oneLastFrame ; }
public VcsRevisionNumber originalRevision ( int lineNumber ) { return getLineRevisionNumber ( lineNumber ) ; }
public void test_create01 ( ) throws Exception { final String namespace2 = STRING + UUID . randomUUID ( ) ; doTestCreate ( namespace2 ) ; }
public void test_create01 ( ) throws Exception { final String namespace2 = STRING + UUID . randomUUID ( ) ; doTestCreate ( namespace2 ) ; }
public void test_create01 ( ) throws Exception { final String namespace2 = STRING + UUID . randomUUID ( ) ; doTestCreate ( namespace2 ) ; }
public IntArrayList ( int [ ] data ) { array = new int [ ( int ) ( data . length * _NUM ) + _NUM ] ; size = data . length ; System . arraycopy ( data , _NUM , array , _NUM , size ) ; }
public IntArrayList ( int [ ] data ) { array = new int [ ( int ) ( data . length * _NUM ) + _NUM ] ; size = data . length ; System . arraycopy ( data , _NUM , array , _NUM , size ) ; }
public IntArrayList ( int [ ] data ) { array = new int [ ( int ) ( data . length * _NUM ) + _NUM ] ; size = data . length ; System . arraycopy ( data , _NUM , array , _NUM , size ) ; }
public boolean addMarker ( String label , int value , int textOffsetX , int textOffsetY , OnMarkerClickListener onMarkerClickListener ) { if ( value > mMax || value < _NUM ) { return _BOOL ; } Marker marker = new Marker ( ) ; String lb = label ; if ( label != null && label . length ( ) > _NUM ) { lb = label . substring ( _NUM , _NUM ) ; } marker . label = lb ; marker . value = value ; marker . offsetX = textOffsetX ; marker . offsetY = textOffsetY ; marker . progressSweep = ( float ) value / mMax * mSweepAngle ; marker . onMarkerClickListener = onMarkerClickListener ; if ( mMarkers == null ) { mMarkers = new ArrayList < > ( ) ; } mMarkers . add ( marker ) ; requestLayout ( ) ; postInvalidate ( ) ; return _BOOL ; }
public boolean addMarker ( String label , int value , int textOffsetX , int textOffsetY , OnMarkerClickListener onMarkerClickListener ) { if ( value > mMax || value < _NUM ) { return _BOOL ; } Marker marker = new Marker ( ) ; String lb = label ; if ( label != null && label . length ( ) > _NUM ) { lb = label . substring ( _NUM , _NUM ) ; } marker . label = lb ; marker . value = value ; marker . offsetX = textOffsetX ; marker . offsetY = textOffsetY ; marker . progressSweep = ( float ) value / mMax * mSweepAngle ; marker . onMarkerClickListener = onMarkerClickListener ; if ( mMarkers == null ) { mMarkers = new ArrayList < > ( ) ; } mMarkers . add ( marker ) ; requestLayout ( ) ; postInvalidate ( ) ; return _BOOL ; }
public boolean addMarker ( String label , int value , int textOffsetX , int textOffsetY , OnMarkerClickListener onMarkerClickListener ) { if ( value > mMax || value < _NUM ) { return _BOOL ; } Marker marker = new Marker ( ) ; String lb = label ; if ( label != null && label . length ( ) > _NUM ) { lb = label . substring ( _NUM , _NUM ) ; } marker . label = lb ; marker . value = value ; marker . offsetX = textOffsetX ; marker . offsetY = textOffsetY ; marker . progressSweep = ( float ) value / mMax * mSweepAngle ; marker . onMarkerClickListener = onMarkerClickListener ; if ( mMarkers == null ) { mMarkers = new ArrayList < > ( ) ; } mMarkers . add ( marker ) ; requestLayout ( ) ; postInvalidate ( ) ; return _BOOL ; }
public static void clearCell ( final Cell < ? > tableCell ) { if ( tableCell != null ) { tableCell . clearActor ( ) ; tableCell . reset ( ) ; } }
public static void clearCell ( final Cell < ? > tableCell ) { if ( tableCell != null ) { tableCell . clearActor ( ) ; tableCell . reset ( ) ; } }
public static void validateMacTag ( String participantId , String partnerParticipantId , BigInteger gx1 , BigInteger gx2 , BigInteger gx3 , BigInteger gx4 , BigInteger keyingMaterial , Digest digest , BigInteger partnerMacTag ) throws CryptoException { BigInteger expectedMacTag = calculateMacTag ( partnerParticipantId , participantId , gx3 , gx4 , gx1 , gx2 , keyingMaterial , digest ) ; if ( ! expectedMacTag . equals ( partnerMacTag ) ) { throw new CryptoException ( STRING + STRING ) ; } }
public void add ( double weight , double x , double y ) { observations . add ( new WeightedObservedPoint ( weight , x , y ) ) ; }
private void finalizeAdditions ( boolean addHomeScreenShortcuts ) { finalizeWorkFolder ( ) ; if ( addHomeScreenShortcuts && ! mHomescreenApps . isEmpty ( ) ) { mModel . addAndBindAddedWorkspaceItems ( mContext , mHomescreenApps ) ; } }
private void finalizeAdditions ( boolean addHomeScreenShortcuts ) { finalizeWorkFolder ( ) ; if ( addHomeScreenShortcuts && ! mHomescreenApps . isEmpty ( ) ) { mModel . addAndBindAddedWorkspaceItems ( mContext , mHomescreenApps ) ; } }
private String emailToString ( String subject , String msg , String ... to ) { return STRING + msg + STRING + Arrays . asList ( to ) + STRING + subject + STRING ; }
private String emailToString ( String subject , String msg , String ... to ) { return STRING + msg + STRING + Arrays . asList ( to ) + STRING + subject + STRING ; }
private static TreeMap < Integer , Long > loadWorkspaceScreensDb ( Context context ) { final ContentResolver contentResolver = context . getContentResolver ( ) ; final Uri screensUri = LauncherSettings . WorkspaceScreens . CONTENT_URI ; final Cursor sc = contentResolver . query ( screensUri , null , null , null , null ) ; TreeMap < Integer , Long > orderedScreens = new TreeMap < Integer , Long > ( ) ; try { final int idIndex = sc . getColumnIndexOrThrow ( LauncherSettings . WorkspaceScreens . _ID ) ; final int rankIndex = sc . getColumnIndexOrThrow ( LauncherSettings . WorkspaceScreens . SCREEN_RANK ) ; while ( sc . moveToNext ( ) ) { try { long screenId = sc . getLong ( idIndex ) ; int rank = sc . getInt ( rankIndex ) ; orderedScreens . put ( rank , screenId ) ; } catch ( Exception e ) { Launcher . addDumpLog ( TAG , STRING + e , _BOOL ) ; } } } finally { sc . close ( ) ; } Launcher . addDumpLog ( TAG , STRING , _BOOL ) ; ArrayList < String > orderedScreensPairs = new ArrayList < String > ( ) ; for ( Integer i : orderedScreens . keySet ( ) ) { orderedScreensPairs . add ( STRING + i + STRING + orderedScreens . get ( i ) + STRING ) ; } Launcher . addDumpLog ( TAG , STRING + TextUtils . join ( STRING , orderedScreensPairs ) , _BOOL ) ; return orderedScreens ; }
@ RpcMethod public void transferImage ( String imageId , String source , String destination , ServerAddress destinationHost , AsyncMethodCallback < Host . AsyncClient . copy_image_call > handler ) throws RpcException { ensureClient ( ) ; TransferImageRequest transferImageRequest = new TransferImageRequest ( ) ; transferImageRequest . setDestination_datastore_id ( destination ) ; transferImageRequest . setDestination_host ( destinationHost ) ; transferImageRequest . setSource_datastore_id ( source ) ; transferImageRequest . setSource_image_id ( imageId ) ; clientProxy . setTimeout ( TRANSFER_IMAGE_TIMEOUT_MS ) ; logger . info ( STRING , getHostIp ( ) , transferImageRequest ) ; try { clientProxy . transfer_image ( transferImageRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
@ RpcMethod public void transferImage ( String imageId , String source , String destination , ServerAddress destinationHost , AsyncMethodCallback < Host . AsyncClient . copy_image_call > handler ) throws RpcException { ensureClient ( ) ; TransferImageRequest transferImageRequest = new TransferImageRequest ( ) ; transferImageRequest . setDestination_datastore_id ( destination ) ; transferImageRequest . setDestination_host ( destinationHost ) ; transferImageRequest . setSource_datastore_id ( source ) ; transferImageRequest . setSource_image_id ( imageId ) ; clientProxy . setTimeout ( TRANSFER_IMAGE_TIMEOUT_MS ) ; logger . info ( STRING , getHostIp ( ) , transferImageRequest ) ; try { clientProxy . transfer_image ( transferImageRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
@ RpcMethod public void transferImage ( String imageId , String source , String destination , ServerAddress destinationHost , AsyncMethodCallback < Host . AsyncClient . copy_image_call > handler ) throws RpcException { ensureClient ( ) ; TransferImageRequest transferImageRequest = new TransferImageRequest ( ) ; transferImageRequest . setDestination_datastore_id ( destination ) ; transferImageRequest . setDestination_host ( destinationHost ) ; transferImageRequest . setSource_datastore_id ( source ) ; transferImageRequest . setSource_image_id ( imageId ) ; clientProxy . setTimeout ( TRANSFER_IMAGE_TIMEOUT_MS ) ; logger . info ( STRING , getHostIp ( ) , transferImageRequest ) ; try { clientProxy . transfer_image ( transferImageRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
public void swapElements ( final int index1 , final int index2 ) { Collections . swap ( actionList , index1 , index2 ) ; for ( UpdateManagerListener listener : listeners ) { listener . actionOrderChanged ( ) ; } }
public void swapElements ( final int index1 , final int index2 ) { Collections . swap ( actionList , index1 , index2 ) ; for ( UpdateManagerListener listener : listeners ) { listener . actionOrderChanged ( ) ; } }
InternalWindow ( String title ) { setLayout ( new BorderLayout ( ) ) ; titleBar = new TitleBar ( ) ; add ( titleBar , BorderLayout . NORTH ) ; titleBar . setLayout ( new SBoxLayout ( SBoxLayout . HORIZONTAL , TITLEBAR_PADDING ) ) ; titleLabel = new JLabel ( ) ; setTitle ( title ) ; titleLabel . setMinimumSize ( new Dimension ( _NUM , _NUM ) ) ; titleBar . add ( titleLabel ) ; SBoxLayout . addSpring ( titleBar ) ; minimizeButton = new JButton ( minimizeIcon ) ; minimizeButton . setMargin ( new Insets ( _NUM , _NUM , _NUM , _NUM ) ) ; minimizeButton . setBorder ( BorderFactory . createEmptyBorder ( ) ) ; minimizeButton . setFocusable ( _BOOL ) ; minimizeButton . addActionListener ( new MinimizeListener ( ) ) ; titleBar . add ( minimizeButton ) ; closeButton = new JButton ( closeIcon ) ; closeButton . setMargin ( new Insets ( _NUM , _NUM , _NUM , _NUM ) ) ; closeButton . setBorder ( BorderFactory . createEmptyBorder ( ) ) ; closeButton . setFocusable ( _BOOL ) ; closeButton . addActionListener ( new CloseActionListener ( ) ) ; titleBar . add ( closeButton ) ; cache = new ComponentPaintCache ( this ) ; }
public void removeStorage ( ) throws BackupException { logger . debug ( STRING + dataDirSpec . getAbsolutePath ( ) ) ; processHelper . exec ( STRING , rmCmd ) ; }
public synchronized int add ( IAudioProvider provider ) { providers . add ( provider ) ; return providers . indexOf ( provider ) ; }
public void addAttributeListener ( final AttributeListener listener ) { attributeListeners . add ( listener ) ; }
public final void writeLong ( final long l ) { baos . write ( ( byte ) ( l & _NUM ) ) ; baos . write ( ( byte ) ( ( l > > > _NUM ) & _NUM ) ) ; baos . write ( ( byte ) ( ( l > > > _NUM ) & _NUM ) ) ; baos . write ( ( byte ) ( ( l > > > _NUM ) & _NUM ) ) ; baos . write ( ( byte ) ( ( l > > > _NUM ) & _NUM ) ) ; baos . write ( ( byte ) ( ( l > > > _NUM ) & _NUM ) ) ; baos . write ( ( byte ) ( ( l > > > _NUM ) & _NUM ) ) ; baos . write ( ( byte ) ( ( l > > > _NUM ) & _NUM ) ) ; }
public static String transformMethodSignature ( String signature ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( STRING ) ; SignatureParser parser = new SignatureParser ( signature ) ; for ( Iterator < String > i = parser . parameterSignatureIterator ( ) ; i . hasNext ( ) ; ) { String param = i . next ( ) ; param = transformSignature ( param ) ; buf . append ( param ) ; } buf . append ( STRING ) ; return buf . toString ( ) ; }
public Math_Vector rotate ( double angle ) { double rad = angle * TO_RADIANS ; double cos = Math . cos ( rad ) ; double sin = Math . sin ( rad ) ; double newX = this . x * cos - this . y * sin ; double newY = this . x * sin + this . y * cos ; this . x = newX ; this . y = newY ; return this ; }
public Math_Vector rotate ( double angle ) { double rad = angle * TO_RADIANS ; double cos = Math . cos ( rad ) ; double sin = Math . sin ( rad ) ; double newX = this . x * cos - this . y * sin ; double newY = this . x * sin + this . y * cos ; this . x = newX ; this . y = newY ; return this ; }
private void startDistributedSystem ( FilterConfig config ) { final String cacheType = config . getInitParameter ( INIT_PARAM_CACHE_TYPE ) ; if ( CACHE_TYPE_CLIENT_SERVER . equals ( cacheType ) ) { distributedCache = ClientServerCache . getInstance ( ) ; } else if ( CACHE_TYPE_PEER_TO_PEER . equals ( cacheType ) ) { distributedCache = PeerToPeerCache . getInstance ( ) ; } else { LOG . error ( STRING + STRING ) ; return ; } if ( ! distributedCache . isStarted ( ) ) { for ( Enumeration < String > e = config . getInitParameterNames ( ) ; e . hasMoreElements ( ) ; ) { String param = e . nextElement ( ) ; if ( ! param . startsWith ( GEMFIRE_PROPERTY ) ) { continue ; } String gemfireProperty = param . substring ( GEMFIRE_PROPERTY . length ( ) ) ; LOG . info ( STRING , gemfireProperty , config . getInitParameter ( param ) ) ; distributedCache . setProperty ( gemfireProperty , config . getInitParameter ( param ) ) ; } distributedCache . lifecycleEvent ( LifecycleTypeAdapter . START ) ; } }
public Tristate hasPermission ( Node node , boolean t ) { for ( Node n : t ? getTransientNodes ( ) : getNodes ( ) ) { if ( n . almostEquals ( node ) ) { return n . getTristate ( ) ; } } return Tristate . UNDEFINED ; }
protected void logLayout ( VisualTable labels ) { Rectangle2D b = getLayoutBounds ( ) ; double breadth = getBreadth ( b ) ; labels . clear ( ) ; double llo = MathLib . safeLog10 ( m_lo ) ; double lhi = MathLib . safeLog10 ( m_hi ) ; double lspan = lhi - llo ; double d = MathLib . log10 ( lhi - llo ) ; int e = ( int ) Math . floor ( d ) ; int ilo = ( int ) Math . floor ( llo ) ; int ihi = ( int ) Math . ceil ( lhi ) ; double start = Math . pow ( _NUM , ilo ) ; double end = Math . pow ( _NUM , ihi ) ; double step = start * Math . pow ( _NUM , e ) ; for ( double val , v = start , i = _NUM ; v <= end ; v += step , ++ i ) { val = MathLib . safeLog10 ( v ) ; if ( i != _NUM && Math . abs ( val - Math . round ( val ) ) < _NUM ) { i = _NUM ; step = _NUM * step ; } val = ( ( val - llo ) / lspan ) * breadth ; if ( val < - _NUM ) continue ; VisualItem item = labels . addItem ( ) ; set ( item , val , b ) ; String label = i == _NUM ? m_nf . format ( v ) : null ; item . set ( LABEL , label ) ; item . setDouble ( VALUE , v ) ; } }
protected void logLayout ( VisualTable labels ) { Rectangle2D b = getLayoutBounds ( ) ; double breadth = getBreadth ( b ) ; labels . clear ( ) ; double llo = MathLib . safeLog10 ( m_lo ) ; double lhi = MathLib . safeLog10 ( m_hi ) ; double lspan = lhi - llo ; double d = MathLib . log10 ( lhi - llo ) ; int e = ( int ) Math . floor ( d ) ; int ilo = ( int ) Math . floor ( llo ) ; int ihi = ( int ) Math . ceil ( lhi ) ; double start = Math . pow ( _NUM , ilo ) ; double end = Math . pow ( _NUM , ihi ) ; double step = start * Math . pow ( _NUM , e ) ; for ( double val , v = start , i = _NUM ; v <= end ; v += step , ++ i ) { val = MathLib . safeLog10 ( v ) ; if ( i != _NUM && Math . abs ( val - Math . round ( val ) ) < _NUM ) { i = _NUM ; step = _NUM * step ; } val = ( ( val - llo ) / lspan ) * breadth ; if ( val < - _NUM ) continue ; VisualItem item = labels . addItem ( ) ; set ( item , val , b ) ; String label = i == _NUM ? m_nf . format ( v ) : null ; item . set ( LABEL , label ) ; item . setDouble ( VALUE , v ) ; } }
protected void logLayout ( VisualTable labels ) { Rectangle2D b = getLayoutBounds ( ) ; double breadth = getBreadth ( b ) ; labels . clear ( ) ; double llo = MathLib . safeLog10 ( m_lo ) ; double lhi = MathLib . safeLog10 ( m_hi ) ; double lspan = lhi - llo ; double d = MathLib . log10 ( lhi - llo ) ; int e = ( int ) Math . floor ( d ) ; int ilo = ( int ) Math . floor ( llo ) ; int ihi = ( int ) Math . ceil ( lhi ) ; double start = Math . pow ( _NUM , ilo ) ; double end = Math . pow ( _NUM , ihi ) ; double step = start * Math . pow ( _NUM , e ) ; for ( double val , v = start , i = _NUM ; v <= end ; v += step , ++ i ) { val = MathLib . safeLog10 ( v ) ; if ( i != _NUM && Math . abs ( val - Math . round ( val ) ) < _NUM ) { i = _NUM ; step = _NUM * step ; } val = ( ( val - llo ) / lspan ) * breadth ; if ( val < - _NUM ) continue ; VisualItem item = labels . addItem ( ) ; set ( item , val , b ) ; String label = i == _NUM ? m_nf . format ( v ) : null ; item . set ( LABEL , label ) ; item . setDouble ( VALUE , v ) ; } }
protected void logLayout ( VisualTable labels ) { Rectangle2D b = getLayoutBounds ( ) ; double breadth = getBreadth ( b ) ; labels . clear ( ) ; double llo = MathLib . safeLog10 ( m_lo ) ; double lhi = MathLib . safeLog10 ( m_hi ) ; double lspan = lhi - llo ; double d = MathLib . log10 ( lhi - llo ) ; int e = ( int ) Math . floor ( d ) ; int ilo = ( int ) Math . floor ( llo ) ; int ihi = ( int ) Math . ceil ( lhi ) ; double start = Math . pow ( _NUM , ilo ) ; double end = Math . pow ( _NUM , ihi ) ; double step = start * Math . pow ( _NUM , e ) ; for ( double val , v = start , i = _NUM ; v <= end ; v += step , ++ i ) { val = MathLib . safeLog10 ( v ) ; if ( i != _NUM && Math . abs ( val - Math . round ( val ) ) < _NUM ) { i = _NUM ; step = _NUM * step ; } val = ( ( val - llo ) / lspan ) * breadth ; if ( val < - _NUM ) continue ; VisualItem item = labels . addItem ( ) ; set ( item , val , b ) ; String label = i == _NUM ? m_nf . format ( v ) : null ; item . set ( LABEL , label ) ; item . setDouble ( VALUE , v ) ; } }
public int estimateCellVSpan ( int height ) { int availHeight = height - ( getPaddingTop ( ) + getPaddingBottom ( ) ) ; int n = Math . max ( _NUM , ( availHeight + mHeightGap ) / ( mCellHeight + mHeightGap ) ) ; return n ; }
public static long copyStream ( InputStream in , OutputStream out ) throws IOException { Reject . ifNull ( in , out ) ; final byte [ ] buffer = new byte [ BUFFER_SIZE ] ; long bytesCopied = _NUM ; for ( int bytesRead = in . read ( buffer ) ; bytesRead != - _NUM ; bytesRead = in . read ( buffer ) ) { out . write ( buffer , _NUM , bytesRead ) ; bytesCopied += bytesRead ; } return bytesCopied ; }
public synchronized boolean onDeltaReceived ( UUID nodeId , long timeDelta ) { DeltaAverage avg = pendingDeltas . get ( nodeId ) ; if ( avg != null ) { avg . onValue ( timeDelta ) ; if ( avg . ready ( ) ) { pendingDeltas . remove ( nodeId ) ; deltas . put ( nodeId , avg . average ( ) ) ; if ( ready ( ) ) notifyAll ( ) ; return _BOOL ; } return _BOOL ; } return _BOOL ; }
public List < CorrelationIdentifier > findCorrelationIds ( Scope ... scope ) { List < CorrelationIdentifier > ret = null ; for ( int i = _NUM ; i < correlationIds . size ( ) ; i ++ ) { CorrelationIdentifier cid = correlationIds . get ( i ) ; for ( int j = _NUM ; j < scope . length ; j ++ ) { if ( cid . getScope ( ) == scope [ j ] ) { if ( ret == null ) { ret = new ArrayList < CorrelationIdentifier > ( ) ; } if ( ! ret . contains ( cid ) ) { ret . add ( cid ) ; } } } } return ret == null ? Collections . emptyList ( ) : ret ; }
public List < CorrelationIdentifier > findCorrelationIds ( Scope ... scope ) { List < CorrelationIdentifier > ret = null ; for ( int i = _NUM ; i < correlationIds . size ( ) ; i ++ ) { CorrelationIdentifier cid = correlationIds . get ( i ) ; for ( int j = _NUM ; j < scope . length ; j ++ ) { if ( cid . getScope ( ) == scope [ j ] ) { if ( ret == null ) { ret = new ArrayList < CorrelationIdentifier > ( ) ; } if ( ! ret . contains ( cid ) ) { ret . add ( cid ) ; } } } } return ret == null ? Collections . emptyList ( ) : ret ; }
public List < CorrelationIdentifier > findCorrelationIds ( Scope ... scope ) { List < CorrelationIdentifier > ret = null ; for ( int i = _NUM ; i < correlationIds . size ( ) ; i ++ ) { CorrelationIdentifier cid = correlationIds . get ( i ) ; for ( int j = _NUM ; j < scope . length ; j ++ ) { if ( cid . getScope ( ) == scope [ j ] ) { if ( ret == null ) { ret = new ArrayList < CorrelationIdentifier > ( ) ; } if ( ! ret . contains ( cid ) ) { ret . add ( cid ) ; } } } } return ret == null ? Collections . emptyList ( ) : ret ; }
public List < CorrelationIdentifier > findCorrelationIds ( Scope ... scope ) { List < CorrelationIdentifier > ret = null ; for ( int i = _NUM ; i < correlationIds . size ( ) ; i ++ ) { CorrelationIdentifier cid = correlationIds . get ( i ) ; for ( int j = _NUM ; j < scope . length ; j ++ ) { if ( cid . getScope ( ) == scope [ j ] ) { if ( ret == null ) { ret = new ArrayList < CorrelationIdentifier > ( ) ; } if ( ! ret . contains ( cid ) ) { ret . add ( cid ) ; } } } } return ret == null ? Collections . emptyList ( ) : ret ; }
public List < CorrelationIdentifier > findCorrelationIds ( Scope ... scope ) { List < CorrelationIdentifier > ret = null ; for ( int i = _NUM ; i < correlationIds . size ( ) ; i ++ ) { CorrelationIdentifier cid = correlationIds . get ( i ) ; for ( int j = _NUM ; j < scope . length ; j ++ ) { if ( cid . getScope ( ) == scope [ j ] ) { if ( ret == null ) { ret = new ArrayList < CorrelationIdentifier > ( ) ; } if ( ! ret . contains ( cid ) ) { ret . add ( cid ) ; } } } } return ret == null ? Collections . emptyList ( ) : ret ; }
public List < CorrelationIdentifier > findCorrelationIds ( Scope ... scope ) { List < CorrelationIdentifier > ret = null ; for ( int i = _NUM ; i < correlationIds . size ( ) ; i ++ ) { CorrelationIdentifier cid = correlationIds . get ( i ) ; for ( int j = _NUM ; j < scope . length ; j ++ ) { if ( cid . getScope ( ) == scope [ j ] ) { if ( ret == null ) { ret = new ArrayList < CorrelationIdentifier > ( ) ; } if ( ! ret . contains ( cid ) ) { ret . add ( cid ) ; } } } } return ret == null ? Collections . emptyList ( ) : ret ; }
public static String displayInputs ( String name , Map < String , Object > map , LocalVariableMap symbolTable ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( name ) ; sb . append ( STRING ) ; Set < String > keys = map . keySet ( ) ; if ( keys . isEmpty ( ) ) { sb . append ( STRING ) ; } else { int count = _NUM ; for ( String key : keys ) { Object object = map . get ( key ) ; @ SuppressWarnings ( STRING ) Class clazz = object . getClass ( ) ; String type = clazz . getSimpleName ( ) ; if ( object instanceof JavaRDD < ? > ) { type = STRING ; } else if ( object instanceof RDD < ? > ) { type = STRING ; } sb . append ( STRING ) ; sb . append ( ++ count ) ; sb . append ( STRING ) ; sb . append ( STRING ) ; sb . append ( type ) ; if ( doesSymbolTableContainMatrixObject ( symbolTable , key ) ) { sb . append ( STRING ) ; } else if ( doesSymbolTableContainFrameObject ( symbolTable , key ) ) { sb . append ( STRING ) ; } sb . append ( STRING ) ; sb . append ( key ) ; sb . append ( STRING ) ; String str = object . toString ( ) ; str = StringUtils . abbreviate ( str , _NUM ) ; sb . append ( str ) ; sb . append ( STRING ) ; } } return sb . toString ( ) ; }
private String asRegPattern ( String string ) { StringBuffer out = new StringBuffer ( string . length ( ) ) ; for ( int i = _NUM , length = string . length ( ) ; i < length ; i ++ ) { char ch = string . charAt ( i ) ; if ( ch == STRING ) { out . append ( STRING ) ; } else if ( ch == STRING ) { out . append ( STRING ) ; } else { out . append ( ch ) ; } } return out . toString ( ) ; }
private String asRegPattern ( String string ) { StringBuffer out = new StringBuffer ( string . length ( ) ) ; for ( int i = _NUM , length = string . length ( ) ; i < length ; i ++ ) { char ch = string . charAt ( i ) ; if ( ch == STRING ) { out . append ( STRING ) ; } else if ( ch == STRING ) { out . append ( STRING ) ; } else { out . append ( ch ) ; } } return out . toString ( ) ; }
private String asRegPattern ( String string ) { StringBuffer out = new StringBuffer ( string . length ( ) ) ; for ( int i = _NUM , length = string . length ( ) ; i < length ; i ++ ) { char ch = string . charAt ( i ) ; if ( ch == STRING ) { out . append ( STRING ) ; } else if ( ch == STRING ) { out . append ( STRING ) ; } else { out . append ( ch ) ; } } return out . toString ( ) ; }
protected String constName ( ) { return STRING + name . toUpperCase ( ) ; }
protected String constName ( ) { return STRING + name . toUpperCase ( ) ; }
@ Override public void write ( byte [ ] buffer , int offset , int length ) { if ( isClosed ( ) || isHead ( ) ) { return ; } int byteLength = _offset ; while ( _BOOL ) { int sublen = Math . min ( length , SIZE - byteLength ) ; System . arraycopy ( buffer , offset , _buffer , byteLength , sublen ) ; offset += sublen ; length -= sublen ; byteLength += sublen ; if ( length <= _NUM ) { break ; } _offset = byteLength ; flushByteBuffer ( ) ; byteLength = _offset ; } _offset = byteLength ; }
private void disableMaintenanceMode ( ) { synchronized ( maintenanceEnabled ) { if ( maintenanceEnabled . getAndSet ( _BOOL ) ) { maintenanceFilter . disableMaintenanceMode ( ) ; } } }
private void disableMaintenanceMode ( ) { synchronized ( maintenanceEnabled ) { if ( maintenanceEnabled . getAndSet ( _BOOL ) ) { maintenanceFilter . disableMaintenanceMode ( ) ; } } }
private static Hashtable updateNamingTable ( boolean forClient ) throws SMSException { Hashtable nametable = null ; try { ServiceSchema sc = ssmNaming . getGlobalSchema ( ) ; Map namingAttrs = sc . getAttributeDefaults ( ) ; sc = ssmPlatform . getGlobalSchema ( ) ; Map platformAttrs = sc . getAttributeDefaults ( ) ; Set sites = getSites ( platformAttrs ) ; Set servers = getServers ( platformAttrs , sites ) ; Set siteNamesAndIDs = getSiteNamesAndIDs ( ) ; storeSiteNames ( siteNamesAndIDs , namingAttrs ) ; if ( ( sites != null ) && ! sites . isEmpty ( ) ) { if ( ! forClient ) { registFQDNMapping ( sites ) ; } sites . addAll ( servers ) ; } else { sites = servers ; } if ( forClient ) { storeServerListForClient ( sites , namingAttrs ) ; } else { storeServerList ( sites , namingAttrs ) ; } nametable = convertToHash ( namingAttrs ) ; if ( forClient && ( namingTable != null ) ) { String siteList = ( String ) namingTable . get ( Constants . SITE_ID_LIST ) ; nametable . put ( Constants . SITE_ID_LIST , siteList ) ; } insertLBCookieValues ( nametable ) ; } catch ( Exception ex ) { String errorMsg = STRING ; namingDebug . error ( errorMsg , ex ) ; if ( ex . getMessage ( ) != null ) { errorMsg = ex . getMessage ( ) ; } throw new SMSException ( errorMsg ) ; } return nametable ; }
public final void translate ( CharSequence input , Writer out ) throws IOException { if ( out == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( input == null ) { return ; } int pos = _NUM ; int len = input . length ( ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed == _NUM ) { char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; out . write ( c ) ; pos += c . length ; continue ; } for ( int pt = _NUM ; pt < consumed ; pt ++ ) { pos += Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }
public final void translate ( CharSequence input , Writer out ) throws IOException { if ( out == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( input == null ) { return ; } int pos = _NUM ; int len = input . length ( ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed == _NUM ) { char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; out . write ( c ) ; pos += c . length ; continue ; } for ( int pt = _NUM ; pt < consumed ; pt ++ ) { pos += Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }
public final void translate ( CharSequence input , Writer out ) throws IOException { if ( out == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( input == null ) { return ; } int pos = _NUM ; int len = input . length ( ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed == _NUM ) { char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; out . write ( c ) ; pos += c . length ; continue ; } for ( int pt = _NUM ; pt < consumed ; pt ++ ) { pos += Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }
@ Override public void onSuccess ( DLSN value ) { if ( value . getLogSegmentSequenceNo ( ) != currentLogSegmentSeqNo ) { LOG . error ( STRING , value . getLogSegmentSequenceNo ( ) , currentLogSegmentSeqNo ) ; errorsFound . set ( _BOOL ) ; } if ( verifyEntryId && value . getEntryId ( ) != currentEntryId ) { LOG . error ( STRING , value . getEntryId ( ) , currentEntryId ) ; errorsFound . set ( _BOOL ) ; } syncLatch . countDown ( ) ; }
public void testConstructorSignBytesPositive7 ( ) { byte aBytes [ ] = { - _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM , _NUM , - _NUM } ; int aSign = _NUM ; byte rBytes [ ] = { _NUM , - _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM , _NUM , - _NUM } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , aNumber . signum ( ) ) ; }
void write ( ImageOutputStream ios ) throws IOException { length = _NUM + ( ( data != null ) ? data . length : _NUM ) ; writeTag ( ios ) ; if ( data != null ) { ios . write ( data ) ; } }
private static < T > void assertCollectionEqualsNoOrder ( Collection < T > expected , Collection < T > actual ) { String msg = String . format ( STRING , expected . toString ( ) , actual . toString ( ) ) ; assertEquals ( msg , expected . size ( ) , actual . size ( ) ) ; for ( T e : expected ) { if ( ! actual . contains ( e ) ) { msg = String . format ( STRING + STRING , e , expected , actual ) ; fail ( msg ) ; } } }
private static < T > void assertCollectionEqualsNoOrder ( Collection < T > expected , Collection < T > actual ) { String msg = String . format ( STRING , expected . toString ( ) , actual . toString ( ) ) ; assertEquals ( msg , expected . size ( ) , actual . size ( ) ) ; for ( T e : expected ) { if ( ! actual . contains ( e ) ) { msg = String . format ( STRING + STRING , e , expected , actual ) ; fail ( msg ) ; } } }
private static < T > void assertCollectionEqualsNoOrder ( Collection < T > expected , Collection < T > actual ) { String msg = String . format ( STRING , expected . toString ( ) , actual . toString ( ) ) ; assertEquals ( msg , expected . size ( ) , actual . size ( ) ) ; for ( T e : expected ) { if ( ! actual . contains ( e ) ) { msg = String . format ( STRING + STRING , e , expected , actual ) ; fail ( msg ) ; } } }
private static < T > void assertCollectionEqualsNoOrder ( Collection < T > expected , Collection < T > actual ) { String msg = String . format ( STRING , expected . toString ( ) , actual . toString ( ) ) ; assertEquals ( msg , expected . size ( ) , actual . size ( ) ) ; for ( T e : expected ) { if ( ! actual . contains ( e ) ) { msg = String . format ( STRING + STRING , e , expected , actual ) ; fail ( msg ) ; } } }
private static byte [ ] hmac_sha ( String crypto , byte [ ] keyBytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . getInstance ( crypto ) ; SecretKeySpec macKey = new SecretKeySpec ( keyBytes , STRING ) ; hmac . init ( macKey ) ; return hmac . doFinal ( text ) ; } catch ( GeneralSecurityException gse ) { throw new UndeclaredThrowableException ( gse ) ; } }
private static byte [ ] hmac_sha ( String crypto , byte [ ] keyBytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . getInstance ( crypto ) ; SecretKeySpec macKey = new SecretKeySpec ( keyBytes , STRING ) ; hmac . init ( macKey ) ; return hmac . doFinal ( text ) ; } catch ( GeneralSecurityException gse ) { throw new UndeclaredThrowableException ( gse ) ; } }
public void writeComments ( Writer writer ) throws IOException { for ( String s : keyValComments ) { writer . write ( s ) ; } }
public void writeComments ( Writer writer ) throws IOException { for ( String s : keyValComments ) { writer . write ( s ) ; } }
public void writeComments ( Writer writer ) throws IOException { for ( String s : keyValComments ) { writer . write ( s ) ; } }
public static < E extends Enum < E > > EnumSet < E > of ( E e ) { EnumSet < E > set = EnumSet . noneOf ( e . getDeclaringClass ( ) ) ; set . add ( e ) ; return set ; }
public static < E extends Enum < E > > EnumSet < E > of ( E e ) { EnumSet < E > set = EnumSet . noneOf ( e . getDeclaringClass ( ) ) ; set . add ( e ) ; return set ; }
public static < E extends Enum < E > > EnumSet < E > of ( E e ) { EnumSet < E > set = EnumSet . noneOf ( e . getDeclaringClass ( ) ) ; set . add ( e ) ; return set ; }
public static < E extends Enum < E > > EnumSet < E > of ( E e ) { EnumSet < E > set = EnumSet . noneOf ( e . getDeclaringClass ( ) ) ; set . add ( e ) ; return set ; }
public static < E extends Enum < E > > EnumSet < E > of ( E e ) { EnumSet < E > set = EnumSet . noneOf ( e . getDeclaringClass ( ) ) ; set . add ( e ) ; return set ; }
public static < E extends Enum < E > > EnumSet < E > of ( E e ) { EnumSet < E > set = EnumSet . noneOf ( e . getDeclaringClass ( ) ) ; set . add ( e ) ; return set ; }
public static < E extends Enum < E > > EnumSet < E > of ( E e ) { EnumSet < E > set = EnumSet . noneOf ( e . getDeclaringClass ( ) ) ; set . add ( e ) ; return set ; }
public static < E extends Enum < E > > EnumSet < E > of ( E e ) { EnumSet < E > set = EnumSet . noneOf ( e . getDeclaringClass ( ) ) ; set . add ( e ) ; return set ; }
public IdQuery ( Class < T > type , Object id , Object routing , int version ) { this ( type . getName ( ) , id , routing , QueryResultType . DEFAULT , version ) ; }
public IdQuery ( Class < T > type , Object id , Object routing , int version ) { this ( type . getName ( ) , id , routing , QueryResultType . DEFAULT , version ) ; }
public IdQuery ( Class < T > type , Object id , Object routing , int version ) { this ( type . getName ( ) , id , routing , QueryResultType . DEFAULT , version ) ; }
private String stripOffCR ( String str ) { String [ ] arr = str . split ( STRING ) ; StringBuilder buf = new StringBuilder ( ) ; for ( String s : arr ) { if ( s . endsWith ( STRING ) ) { buf . append ( s . substring ( _NUM , s . length ( ) - _NUM ) ) ; } else { buf . append ( s ) ; } buf . append ( STRING ) ; } return buf . toString ( ) ; }
private String stripOffCR ( String str ) { String [ ] arr = str . split ( STRING ) ; StringBuilder buf = new StringBuilder ( ) ; for ( String s : arr ) { if ( s . endsWith ( STRING ) ) { buf . append ( s . substring ( _NUM , s . length ( ) - _NUM ) ) ; } else { buf . append ( s ) ; } buf . append ( STRING ) ; } return buf . toString ( ) ; }
@ Override public int hashCode ( ) { int hc = hashCodeValue ; if ( hc == _NUM ) { hc = baseLocale . hashCode ( ) ; if ( localeExtensions != null ) { hc ^= localeExtensions . hashCode ( ) ; } hashCodeValue = hc ; } return hc ; }
@ Override public int hashCode ( ) { int hc = hashCodeValue ; if ( hc == _NUM ) { hc = baseLocale . hashCode ( ) ; if ( localeExtensions != null ) { hc ^= localeExtensions . hashCode ( ) ; } hashCodeValue = hc ; } return hc ; }
@ Override public int hashCode ( ) { int hc = hashCodeValue ; if ( hc == _NUM ) { hc = baseLocale . hashCode ( ) ; if ( localeExtensions != null ) { hc ^= localeExtensions . hashCode ( ) ; } hashCodeValue = hc ; } return hc ; }
public static void updatePortAssociations ( NetworkLite network , List < StoragePort > ports , DbClient dbClient ) { Set < String > varraySet = new HashSet < String > ( network . getAssignedVirtualArrays ( ) ) ; for ( StoragePort port : ports ) { port . setNetwork ( network . getId ( ) ) ; port . replaceConnectedVirtualArray ( varraySet ) ; _log . info ( STRING , port . getPortNetworkId ( ) , varraySet ) ; } dbClient . updateAndReindexObject ( ports ) ; }
public Socket accept ( ) throws IOException { synchronized ( initLock ) { try { while ( ! initDone ) { initLock . wait ( ) ; } } catch ( InterruptedException ignore ) { throw new AssertionError ( ignore ) ; } } return serverSocket . accept ( ) ; }
public static boolean reachable ( NetworkInterface itf , InetAddress addr , int reachTimeout ) { try { return addr . isReachable ( itf , _NUM , reachTimeout ) ; } catch ( IOException ignore ) { return _BOOL ; } }
public Permuter ( int n ) { if ( n < _NUM ) { throw new IllegalArgumentException ( ) ; } modulus = n ; if ( n == _NUM ) { return ; } multiplier = ( int ) Math . sqrt ( n ) ; while ( gcd ( multiplier , n ) != _NUM ) { if ( ++ multiplier == n ) { multiplier = _NUM ; } } }
public static boolean moveFile ( Context context , @ NonNull final File source , @ NonNull final File targetDir ) { File target = new File ( targetDir , source . getName ( ) ) ; boolean success = source . renameTo ( target ) ; if ( ! success ) { success = copyFile ( context , source , targetDir ) ; if ( success ) { success = deleteFile ( context , source ) ; } } return success ; }
public void testDelete5 ( ) throws SQLException { statement . execute ( STRING + DatabaseCreator . PARENT_TABLE + STRING ) ; ResultSet r = statement . executeQuery ( STRING + DatabaseCreator . FKCASCADE_TABLE + STRING ) ; r . next ( ) ; assertEquals ( STRING , _NUM , r . getInt ( _NUM ) ) ; r . close ( ) ; }
public synchronized void shutdown ( boolean immediate ) { logger . info ( STRING + name ) ; for ( Stage stage : stages ) stage . shutdown ( immediate ) ; shutdownTaskExec . shutdownNow ( ) ; }
public synchronized void shutdown ( boolean immediate ) { logger . info ( STRING + name ) ; for ( Stage stage : stages ) stage . shutdown ( immediate ) ; shutdownTaskExec . shutdownNow ( ) ; }
public synchronized void shutdown ( boolean immediate ) { logger . info ( STRING + name ) ; for ( Stage stage : stages ) stage . shutdown ( immediate ) ; shutdownTaskExec . shutdownNow ( ) ; }
public boolean checkForType ( Types type ) { if ( types == null ) { return _BOOL ; } else { return types . contains ( type . toString ( ) ) ; } }
@ Override public void processHeadlessEvents ( List < EventObject > headless ) { if ( ! GraphicsEnvironment . isHeadless ( ) ) { m_processingHeadlessEvents = _BOOL ; for ( EventObject e : headless ) { if ( e instanceof ThresholdDataEvent ) { acceptDataSet ( ( ThresholdDataEvent ) e ) ; } else if ( e instanceof VisualizableErrorEvent ) { acceptDataSet ( ( VisualizableErrorEvent ) e ) ; } } } m_processingHeadlessEvents = _BOOL ; }
@ Override public void processHeadlessEvents ( List < EventObject > headless ) { if ( ! GraphicsEnvironment . isHeadless ( ) ) { m_processingHeadlessEvents = _BOOL ; for ( EventObject e : headless ) { if ( e instanceof ThresholdDataEvent ) { acceptDataSet ( ( ThresholdDataEvent ) e ) ; } else if ( e instanceof VisualizableErrorEvent ) { acceptDataSet ( ( VisualizableErrorEvent ) e ) ; } } } m_processingHeadlessEvents = _BOOL ; }
@ Override public void processHeadlessEvents ( List < EventObject > headless ) { if ( ! GraphicsEnvironment . isHeadless ( ) ) { m_processingHeadlessEvents = _BOOL ; for ( EventObject e : headless ) { if ( e instanceof ThresholdDataEvent ) { acceptDataSet ( ( ThresholdDataEvent ) e ) ; } else if ( e instanceof VisualizableErrorEvent ) { acceptDataSet ( ( VisualizableErrorEvent ) e ) ; } } } m_processingHeadlessEvents = _BOOL ; }
@ Override public void processHeadlessEvents ( List < EventObject > headless ) { if ( ! GraphicsEnvironment . isHeadless ( ) ) { m_processingHeadlessEvents = _BOOL ; for ( EventObject e : headless ) { if ( e instanceof ThresholdDataEvent ) { acceptDataSet ( ( ThresholdDataEvent ) e ) ; } else if ( e instanceof VisualizableErrorEvent ) { acceptDataSet ( ( VisualizableErrorEvent ) e ) ; } } } m_processingHeadlessEvents = _BOOL ; }
public synchronized void decrement ( int weight ) { if ( weight == _NUM ) return ; minimum += weight ; int logfloor = ( int ) ( Math . floor ( Math . log ( weight ) / Math . log ( _NUM ) ) ) ; if ( logfloor < votingRecord . size ( ) - _NUM ) { while ( logfloor > _NUM ) { selectedDecrement ( logfloor ) ; weight = weight - ( int ) Math . pow ( _NUM , logfloor ) ; logfloor = ( int ) ( Math . floor ( Math . log ( weight ) / Math . log ( _NUM ) ) ) ; } } for ( int x = _NUM ; x < weight ; x ++ ) { decrement ( ) ; } }
public synchronized void decrement ( int weight ) { if ( weight == _NUM ) return ; minimum += weight ; int logfloor = ( int ) ( Math . floor ( Math . log ( weight ) / Math . log ( _NUM ) ) ) ; if ( logfloor < votingRecord . size ( ) - _NUM ) { while ( logfloor > _NUM ) { selectedDecrement ( logfloor ) ; weight = weight - ( int ) Math . pow ( _NUM , logfloor ) ; logfloor = ( int ) ( Math . floor ( Math . log ( weight ) / Math . log ( _NUM ) ) ) ; } } for ( int x = _NUM ; x < weight ; x ++ ) { decrement ( ) ; } }
public synchronized void decrement ( int weight ) { if ( weight == _NUM ) return ; minimum += weight ; int logfloor = ( int ) ( Math . floor ( Math . log ( weight ) / Math . log ( _NUM ) ) ) ; if ( logfloor < votingRecord . size ( ) - _NUM ) { while ( logfloor > _NUM ) { selectedDecrement ( logfloor ) ; weight = weight - ( int ) Math . pow ( _NUM , logfloor ) ; logfloor = ( int ) ( Math . floor ( Math . log ( weight ) / Math . log ( _NUM ) ) ) ; } } for ( int x = _NUM ; x < weight ; x ++ ) { decrement ( ) ; } }
public synchronized void cancelIfKilled ( Future < ? > f ) { cleanFuturesToKill ( ) ; if ( isKilled ( ) ) { f . cancel ( _BOOL ) ; } futureToCancel . add ( new WeakReference < > ( f ) ) ; }
private static Class < ? > findClass ( ClassLoader loader , Class < ? > clazz ) { final String name = clazz . getName ( ) ; if ( name . startsWith ( STRING ) || name . startsWith ( STRING ) ) return null ; String generatedClassName = generateRetainerClassName ( name ) ; try { if ( Akatsuki . loggingLevel == AkatsukiConfig . LoggingLevel . VERBOSE ) Log . i ( Akatsuki . TAG , STRING + clazz ) ; return Class . forName ( generatedClassName , _BOOL , loader ) ; } catch ( ClassNotFoundException e ) { return findClass ( loader , clazz . getSuperclass ( ) ) ; } }
private static Class < ? > findClass ( ClassLoader loader , Class < ? > clazz ) { final String name = clazz . getName ( ) ; if ( name . startsWith ( STRING ) || name . startsWith ( STRING ) ) return null ; String generatedClassName = generateRetainerClassName ( name ) ; try { if ( Akatsuki . loggingLevel == AkatsukiConfig . LoggingLevel . VERBOSE ) Log . i ( Akatsuki . TAG , STRING + clazz ) ; return Class . forName ( generatedClassName , _BOOL , loader ) ; } catch ( ClassNotFoundException e ) { return findClass ( loader , clazz . getSuperclass ( ) ) ; } }
public Parse filter ( String url , WebPage page , Parse parse , HTMLMetaTags metaTags , DocumentFragment doc ) { for ( ParseFilter parseFilter : parseFilters ) { parse = parseFilter . filter ( url , page , parse , metaTags , doc ) ; if ( ! ParseStatusUtils . isSuccess ( parse . getParseStatus ( ) ) ) { return parse ; } } return parse ; }
private void displayPopupMenu ( final MouseEvent event ) { final int selectedIndex = m_table . rowAtPoint ( event . getPoint ( ) ) ; if ( selectedIndex != - _NUM ) { final CCrossReference reference = m_crossReferences . get ( selectedIndex ) ; final CCrossReferencesTableMenu popupMenu = new CCrossReferencesTableMenu ( m_parent , m_viewContainer , reference . getCallingFunction ( ) ) ; popupMenu . show ( m_table , event . getX ( ) , event . getY ( ) ) ; } }
public void testComputeClasspathForJre ( ) throws CoreException { assertEquals ( _NUM , javaProjectA . getRawClasspath ( ) . length ) ; List < File > actualCp = getListOfFiles ( GWTCompileRunner . computeClasspath ( javaProjectA ) ) ; assertEquals ( _NUM , actualCp . size ( ) ) ; }
public void testComputeClasspathForJre ( ) throws CoreException { assertEquals ( _NUM , javaProjectA . getRawClasspath ( ) . length ) ; List < File > actualCp = getListOfFiles ( GWTCompileRunner . computeClasspath ( javaProjectA ) ) ; assertEquals ( _NUM , actualCp . size ( ) ) ; }
public void testComputeClasspathForJre ( ) throws CoreException { assertEquals ( _NUM , javaProjectA . getRawClasspath ( ) . length ) ; List < File > actualCp = getListOfFiles ( GWTCompileRunner . computeClasspath ( javaProjectA ) ) ; assertEquals ( _NUM , actualCp . size ( ) ) ; }
static boolean copyTo ( ByteBuffer inBuffer , CharBuffer outBuffer , CharsetDecoder decoder ) { final CoderResult result = decoder . decode ( inBuffer , outBuffer , _BOOL ) ; decoder . flush ( outBuffer ) ; return ! result . isError ( ) && ! result . isOverflow ( ) ; }
private void visitFromCached ( Document document , StoredFieldVisitor visitor ) throws IOException { for ( IndexableField f : document ) { FieldInfo info = fieldInfos . fieldInfo ( f . name ( ) ) ; switch ( visitor . needsField ( info ) ) { case YES : if ( f . binaryValue ( ) != null ) { BytesRef binaryValue = f . binaryValue ( ) ; byte copy [ ] = new byte [ binaryValue . length ] ; System . arraycopy ( binaryValue . bytes , binaryValue . offset , copy , _NUM , copy . length ) ; visitor . binaryField ( info , copy ) ; } else if ( f . numericValue ( ) != null ) { Number numericValue = f . numericValue ( ) ; if ( numericValue instanceof Double ) { visitor . doubleField ( info , numericValue . doubleValue ( ) ) ; } else if ( numericValue instanceof Integer ) { visitor . intField ( info , numericValue . intValue ( ) ) ; } else if ( numericValue instanceof Float ) { visitor . floatField ( info , numericValue . floatValue ( ) ) ; } else if ( numericValue instanceof Long ) { visitor . longField ( info , numericValue . longValue ( ) ) ; } else { throw new AssertionError ( ) ; } } else { visitor . stringField ( info , f . stringValue ( ) ) ; } break ; case NO : break ; case STOP : return ; } } }
private void visitFromCached ( Document document , StoredFieldVisitor visitor ) throws IOException { for ( IndexableField f : document ) { FieldInfo info = fieldInfos . fieldInfo ( f . name ( ) ) ; switch ( visitor . needsField ( info ) ) { case YES : if ( f . binaryValue ( ) != null ) { BytesRef binaryValue = f . binaryValue ( ) ; byte copy [ ] = new byte [ binaryValue . length ] ; System . arraycopy ( binaryValue . bytes , binaryValue . offset , copy , _NUM , copy . length ) ; visitor . binaryField ( info , copy ) ; } else if ( f . numericValue ( ) != null ) { Number numericValue = f . numericValue ( ) ; if ( numericValue instanceof Double ) { visitor . doubleField ( info , numericValue . doubleValue ( ) ) ; } else if ( numericValue instanceof Integer ) { visitor . intField ( info , numericValue . intValue ( ) ) ; } else if ( numericValue instanceof Float ) { visitor . floatField ( info , numericValue . floatValue ( ) ) ; } else if ( numericValue instanceof Long ) { visitor . longField ( info , numericValue . longValue ( ) ) ; } else { throw new AssertionError ( ) ; } } else { visitor . stringField ( info , f . stringValue ( ) ) ; } break ; case NO : break ; case STOP : return ; } } }
protected void moveRandomly ( OMPoint point , double factor , Projection proj ) { double hor = Math . random ( ) - _NUM ; double vert = Math . random ( ) - _NUM ; Point2D mapPoint = proj . forward ( point . getLat ( ) , point . getLon ( ) ) ; mapPoint . setLocation ( mapPoint . getX ( ) + ( hor * factor ) , mapPoint . getY ( ) + ( vert * factor ) ) ; Point2D llp = proj . inverse ( mapPoint ) ; point . setLat ( llp . getY ( ) ) ; point . setLon ( llp . getX ( ) ) ; }
private void createPartitionRegion ( List vmList , int startIndexForRegion , int endIndexForRegion , int localMaxMemory , int redundancy , boolean firstCreationFlag , boolean multipleVMFlag ) { Iterator nodeIterator = vmList . iterator ( ) ; while ( nodeIterator . hasNext ( ) ) { VM vm = ( VM ) nodeIterator . next ( ) ; vm . invoke ( createMultiplePartitionRegion ( prPrefix , startIndexForRegion , endIndexForRegion , redundancy , localMaxMemory , firstCreationFlag , multipleVMFlag ) ) ; } }
private void createPartitionRegion ( List vmList , int startIndexForRegion , int endIndexForRegion , int localMaxMemory , int redundancy , boolean firstCreationFlag , boolean multipleVMFlag ) { Iterator nodeIterator = vmList . iterator ( ) ; while ( nodeIterator . hasNext ( ) ) { VM vm = ( VM ) nodeIterator . next ( ) ; vm . invoke ( createMultiplePartitionRegion ( prPrefix , startIndexForRegion , endIndexForRegion , redundancy , localMaxMemory , firstCreationFlag , multipleVMFlag ) ) ; } }
private void createPartitionRegion ( List vmList , int startIndexForRegion , int endIndexForRegion , int localMaxMemory , int redundancy , boolean firstCreationFlag , boolean multipleVMFlag ) { Iterator nodeIterator = vmList . iterator ( ) ; while ( nodeIterator . hasNext ( ) ) { VM vm = ( VM ) nodeIterator . next ( ) ; vm . invoke ( createMultiplePartitionRegion ( prPrefix , startIndexForRegion , endIndexForRegion , redundancy , localMaxMemory , firstCreationFlag , multipleVMFlag ) ) ; } }
private void createPartitionRegion ( List vmList , int startIndexForRegion , int endIndexForRegion , int localMaxMemory , int redundancy , boolean firstCreationFlag , boolean multipleVMFlag ) { Iterator nodeIterator = vmList . iterator ( ) ; while ( nodeIterator . hasNext ( ) ) { VM vm = ( VM ) nodeIterator . next ( ) ; vm . invoke ( createMultiplePartitionRegion ( prPrefix , startIndexForRegion , endIndexForRegion , redundancy , localMaxMemory , firstCreationFlag , multipleVMFlag ) ) ; } }
private boolean validateNewPassword ( RequestAndResponse requestAndResponse , final User editedUser , final boolean currentIsEditedUser , final String newPassword , final String newPassword2 ) throws IOException { boolean hasErrors = _BOOL ; if ( newPassword == null || newPassword . isEmpty ( ) ) { addErrorMessage ( requestAndResponse , servletText . errorFirstPasswordMustBeSet ( currentIsEditedUser , editedUser . getUserName ( ) ) ) ; hasErrors = _BOOL ; } if ( newPassword2 == null || newPassword2 . isEmpty ( ) ) { addErrorMessage ( requestAndResponse , servletText . errorSecondPasswordMustBeSet ( currentIsEditedUser , editedUser . getUserName ( ) ) ) ; hasErrors = _BOOL ; } if ( ! hasErrors && newPassword != null && newPassword2 != null && ! newPassword2 . equals ( newPassword ) ) { addErrorMessage ( requestAndResponse , servletText . errorPasswordsMustMatch ( ) ) ; hasErrors = _BOOL ; } if ( ! hasErrors && ! AccountAttributeValidator . isPasswordValid ( newPassword ) ) { addErrorMessage ( requestAndResponse , servletText . errorPasswordIsNotValid ( ) ) ; hasErrors = _BOOL ; } return hasErrors ; }
private void addMatch ( String n ) { if ( names == null ) names = new ArrayList < > ( ) ; if ( ! names . contains ( n ) ) { names . add ( n ) ; } }
public int lastIndexOf ( String subString , int start ) { int subCount = subString . length ( ) ; if ( subCount <= count && start >= _NUM ) { if ( subCount > _NUM ) { if ( start > count - subCount ) { start = count - subCount ; } char firstChar = subString . charAt ( _NUM ) ; while ( _BOOL ) { int i = start ; boolean found = _BOOL ; for ( ; i >= _NUM ; -- i ) { if ( value [ i ] == firstChar ) { found = _BOOL ; break ; } } if ( ! found ) { return - _NUM ; } int o1 = i , o2 = _NUM ; while ( ++ o2 < subCount && value [ ++ o1 ] == subString . charAt ( o2 ) ) { } if ( o2 == subCount ) { return i ; } start = i - _NUM ; } } return start < count ? start : count ; } return - _NUM ; }
public int lastIndexOf ( String subString , int start ) { int subCount = subString . length ( ) ; if ( subCount <= count && start >= _NUM ) { if ( subCount > _NUM ) { if ( start > count - subCount ) { start = count - subCount ; } char firstChar = subString . charAt ( _NUM ) ; while ( _BOOL ) { int i = start ; boolean found = _BOOL ; for ( ; i >= _NUM ; -- i ) { if ( value [ i ] == firstChar ) { found = _BOOL ; break ; } } if ( ! found ) { return - _NUM ; } int o1 = i , o2 = _NUM ; while ( ++ o2 < subCount && value [ ++ o1 ] == subString . charAt ( o2 ) ) { } if ( o2 == subCount ) { return i ; } start = i - _NUM ; } } return start < count ? start : count ; } return - _NUM ; }
public KeyValueTableView ( List < Pair < K , V > > items , List < K > skipKeys ) { this ( FXCollections . observableArrayList ( items ) , FXCollections . observableArrayList ( skipKeys ) , null , null ) ; }
public Object put ( Object key , Object value ) { Object oldValue = null ; synchronized ( map ) { oldValue = map . put ( key , value ) ; if ( oldValue != null ) { removeElement ( key ) ; } addElement ( key ) ; } return oldValue ; }
@ Override public Long call ( ) throws Exception { final boolean TRACE = log . isTraceEnabled ( ) ; if ( pushDownApply ( ) ) { program . apply ( gasState , u , null ) ; } if ( ! program . isChanged ( gasState , u ) ) { return _NUM ; } long nedges = _NUM ; final IGASScheduler sch = scheduler ( ) ; final Iterator < Statement > eitr = graphAccessor . getEdges ( GASContext . this , u , getEdgesEnum ( ) ) ; try { while ( eitr . hasNext ( ) ) { final Statement e = eitr . next ( ) ; nedges ++ ; if ( TRACE ) log . trace ( STRING + gasState . toString ( e ) ) ; program . scatter ( gasState , sch , u , e ) ; } } finally { } return nedges ; }
void collectUnresponsiveMembers ( Set s ) { if ( stillWaiting ( ) ) { InternalDistributedMember [ ] memberList = getMembers ( ) ; synchronized ( memberList ) { for ( int i = _NUM ; i < memberList . length ; i ++ ) { InternalDistributedMember m = memberList [ i ] ; if ( m != null ) { s . add ( m ) ; } } } } }
private void updateStats ( ) { if ( lastValidInfo != null ) { stats . setText ( STRING + Stats . makeFullStats ( lastValidInfo ) ) ; } else { stats . setText ( STRING ) ; } }
protected IObjectInfo < T > store_impl ( Segment < T > segment , ObjectInfo < T > oi ) { if ( _invalid ) return null ; _size . incrementAndGet ( ) ; segment . incrementSize ( ) ; ObjectInfo < T > tail = segment . getTail ( ) ; tail . setForwardRef ( oi ) ; oi . setBackwardRef ( tail ) ; segment . setTail ( oi ) ; return oi ; }
public QoSHandler ( final Vertx vertx , final ResourceStorage storage , final String qosSettingsPath , final Map < String , Object > properties , String prefix ) { this . vertx = vertx ; this . storage = storage ; this . qosSettingsUri = qosSettingsPath ; this . properties = properties ; this . prefix = prefix ; qosRules = new ArrayList < > ( ) ; setMBeanServer ( ManagementFactory . getPlatformMBeanServer ( ) ) ; loadQoSSettings ( ) ; registerUpdateHandler ( ) ; }
public Position createPosition ( int offset ) throws BadLocationException { while ( queue . poll ( ) != null ) { unusedMarks ++ ; } if ( unusedMarks > Math . max ( _NUM , ( marks . size ( ) / _NUM ) ) ) { removeUnusedMarks ( ) ; } int g0 = getGapStart ( ) ; int g1 = getGapEnd ( ) ; int index = ( offset < g0 ) ? offset : offset + ( g1 - g0 ) ; search . index = index ; int sortIndex = findSortIndex ( search ) ; MarkData m ; StickyPosition position ; if ( sortIndex < marks . size ( ) && ( m = marks . elementAt ( sortIndex ) ) . index == index && ( position = m . getPosition ( ) ) != null ) { } else { position = new StickyPosition ( ) ; m = new MarkData ( index , position , queue ) ; position . setMark ( m ) ; marks . insertElementAt ( m , sortIndex ) ; } return position ; }
public Position createPosition ( int offset ) throws BadLocationException { while ( queue . poll ( ) != null ) { unusedMarks ++ ; } if ( unusedMarks > Math . max ( _NUM , ( marks . size ( ) / _NUM ) ) ) { removeUnusedMarks ( ) ; } int g0 = getGapStart ( ) ; int g1 = getGapEnd ( ) ; int index = ( offset < g0 ) ? offset : offset + ( g1 - g0 ) ; search . index = index ; int sortIndex = findSortIndex ( search ) ; MarkData m ; StickyPosition position ; if ( sortIndex < marks . size ( ) && ( m = marks . elementAt ( sortIndex ) ) . index == index && ( position = m . getPosition ( ) ) != null ) { } else { position = new StickyPosition ( ) ; m = new MarkData ( index , position , queue ) ; position . setMark ( m ) ; marks . insertElementAt ( m , sortIndex ) ; } return position ; }
public Position createPosition ( int offset ) throws BadLocationException { while ( queue . poll ( ) != null ) { unusedMarks ++ ; } if ( unusedMarks > Math . max ( _NUM , ( marks . size ( ) / _NUM ) ) ) { removeUnusedMarks ( ) ; } int g0 = getGapStart ( ) ; int g1 = getGapEnd ( ) ; int index = ( offset < g0 ) ? offset : offset + ( g1 - g0 ) ; search . index = index ; int sortIndex = findSortIndex ( search ) ; MarkData m ; StickyPosition position ; if ( sortIndex < marks . size ( ) && ( m = marks . elementAt ( sortIndex ) ) . index == index && ( position = m . getPosition ( ) ) != null ) { } else { position = new StickyPosition ( ) ; m = new MarkData ( index , position , queue ) ; position . setMark ( m ) ; marks . insertElementAt ( m , sortIndex ) ; } return position ; }
public Position createPosition ( int offset ) throws BadLocationException { while ( queue . poll ( ) != null ) { unusedMarks ++ ; } if ( unusedMarks > Math . max ( _NUM , ( marks . size ( ) / _NUM ) ) ) { removeUnusedMarks ( ) ; } int g0 = getGapStart ( ) ; int g1 = getGapEnd ( ) ; int index = ( offset < g0 ) ? offset : offset + ( g1 - g0 ) ; search . index = index ; int sortIndex = findSortIndex ( search ) ; MarkData m ; StickyPosition position ; if ( sortIndex < marks . size ( ) && ( m = marks . elementAt ( sortIndex ) ) . index == index && ( position = m . getPosition ( ) ) != null ) { } else { position = new StickyPosition ( ) ; m = new MarkData ( index , position , queue ) ; position . setMark ( m ) ; marks . insertElementAt ( m , sortIndex ) ; } return position ; }
public void testToString ( ) { LinkedBlockingDeque q = populatedDeque ( SIZE ) ; String s = q . toString ( ) ; for ( int i = _NUM ; i < SIZE ; ++ i ) { assertTrue ( s . indexOf ( String . valueOf ( i ) ) >= _NUM ) ; } }
public void testToString ( ) { LinkedBlockingDeque q = populatedDeque ( SIZE ) ; String s = q . toString ( ) ; for ( int i = _NUM ; i < SIZE ; ++ i ) { assertTrue ( s . indexOf ( String . valueOf ( i ) ) >= _NUM ) ; } }
private final void drawIsometricSprites ( Graphics g , Collection < IsometricSprite > spriteArrayList ) { Rectangle view = g . getClipBounds ( ) ; for ( IsometricSprite sprite : spriteArrayList ) { Rectangle spriteBounds = sprite . getBounds ( ) ; if ( view . intersects ( spriteBounds ) && ! sprite . isHidden ( ) ) { if ( ! sprite . isReady ( ) ) { sprite . prepare ( ) ; } sprite . drawOnto ( g , spriteBounds . x , spriteBounds . y , this , _BOOL ) ; } } }
private final void drawIsometricSprites ( Graphics g , Collection < IsometricSprite > spriteArrayList ) { Rectangle view = g . getClipBounds ( ) ; for ( IsometricSprite sprite : spriteArrayList ) { Rectangle spriteBounds = sprite . getBounds ( ) ; if ( view . intersects ( spriteBounds ) && ! sprite . isHidden ( ) ) { if ( ! sprite . isReady ( ) ) { sprite . prepare ( ) ; } sprite . drawOnto ( g , spriteBounds . x , spriteBounds . y , this , _BOOL ) ; } } }
private final void drawIsometricSprites ( Graphics g , Collection < IsometricSprite > spriteArrayList ) { Rectangle view = g . getClipBounds ( ) ; for ( IsometricSprite sprite : spriteArrayList ) { Rectangle spriteBounds = sprite . getBounds ( ) ; if ( view . intersects ( spriteBounds ) && ! sprite . isHidden ( ) ) { if ( ! sprite . isReady ( ) ) { sprite . prepare ( ) ; } sprite . drawOnto ( g , spriteBounds . x , spriteBounds . y , this , _BOOL ) ; } } }
private final void drawIsometricSprites ( Graphics g , Collection < IsometricSprite > spriteArrayList ) { Rectangle view = g . getClipBounds ( ) ; for ( IsometricSprite sprite : spriteArrayList ) { Rectangle spriteBounds = sprite . getBounds ( ) ; if ( view . intersects ( spriteBounds ) && ! sprite . isHidden ( ) ) { if ( ! sprite . isReady ( ) ) { sprite . prepare ( ) ; } sprite . drawOnto ( g , spriteBounds . x , spriteBounds . y , this , _BOOL ) ; } } }
private final void drawIsometricSprites ( Graphics g , Collection < IsometricSprite > spriteArrayList ) { Rectangle view = g . getClipBounds ( ) ; for ( IsometricSprite sprite : spriteArrayList ) { Rectangle spriteBounds = sprite . getBounds ( ) ; if ( view . intersects ( spriteBounds ) && ! sprite . isHidden ( ) ) { if ( ! sprite . isReady ( ) ) { sprite . prepare ( ) ; } sprite . drawOnto ( g , spriteBounds . x , spriteBounds . y , this , _BOOL ) ; } } }
private final void drawIsometricSprites ( Graphics g , Collection < IsometricSprite > spriteArrayList ) { Rectangle view = g . getClipBounds ( ) ; for ( IsometricSprite sprite : spriteArrayList ) { Rectangle spriteBounds = sprite . getBounds ( ) ; if ( view . intersects ( spriteBounds ) && ! sprite . isHidden ( ) ) { if ( ! sprite . isReady ( ) ) { sprite . prepare ( ) ; } sprite . drawOnto ( g , spriteBounds . x , spriteBounds . y , this , _BOOL ) ; } } }
private final void drawIsometricSprites ( Graphics g , Collection < IsometricSprite > spriteArrayList ) { Rectangle view = g . getClipBounds ( ) ; for ( IsometricSprite sprite : spriteArrayList ) { Rectangle spriteBounds = sprite . getBounds ( ) ; if ( view . intersects ( spriteBounds ) && ! sprite . isHidden ( ) ) { if ( ! sprite . isReady ( ) ) { sprite . prepare ( ) ; } sprite . drawOnto ( g , spriteBounds . x , spriteBounds . y , this , _BOOL ) ; } } }
private final void drawIsometricSprites ( Graphics g , Collection < IsometricSprite > spriteArrayList ) { Rectangle view = g . getClipBounds ( ) ; for ( IsometricSprite sprite : spriteArrayList ) { Rectangle spriteBounds = sprite . getBounds ( ) ; if ( view . intersects ( spriteBounds ) && ! sprite . isHidden ( ) ) { if ( ! sprite . isReady ( ) ) { sprite . prepare ( ) ; } sprite . drawOnto ( g , spriteBounds . x , spriteBounds . y , this , _BOOL ) ; } } }
private final void drawIsometricSprites ( Graphics g , Collection < IsometricSprite > spriteArrayList ) { Rectangle view = g . getClipBounds ( ) ; for ( IsometricSprite sprite : spriteArrayList ) { Rectangle spriteBounds = sprite . getBounds ( ) ; if ( view . intersects ( spriteBounds ) && ! sprite . isHidden ( ) ) { if ( ! sprite . isReady ( ) ) { sprite . prepare ( ) ; } sprite . drawOnto ( g , spriteBounds . x , spriteBounds . y , this , _BOOL ) ; } } }
static String cleanup ( String s ) { for ( ; ; ) { s = s . trim ( ) ; if ( s . startsWith ( STRING ) || s . startsWith ( STRING ) || s . startsWith ( STRING ) || s . startsWith ( STRING ) ) { s = s . substring ( _NUM ) ; } else { return s ; } } }
static String cleanup ( String s ) { for ( ; ; ) { s = s . trim ( ) ; if ( s . startsWith ( STRING ) || s . startsWith ( STRING ) || s . startsWith ( STRING ) || s . startsWith ( STRING ) ) { s = s . substring ( _NUM ) ; } else { return s ; } } }
public static void appendPath ( StringBuffer sb , Resource path ) { if ( path . isURIResource ( ) ) { sb . append ( FmtUtils . stringForNode ( path . asNode ( ) , path . getModel ( ) ) ) ; } else { appendPathBlankNode ( sb , path , SEQUENCE_PATH_SEPARATOR ) ; } }
public static Text valueOf ( char [ ] chars , int offset , int length ) { if ( ( offset < _NUM ) || ( length < _NUM ) || ( ( offset + length ) > chars . length ) ) throw new IndexOutOfBoundsException ( ) ; if ( length <= BLOCK_SIZE ) { Text text = Text . newPrimitive ( length ) ; System . arraycopy ( chars , offset , text . _data , _NUM , length ) ; return text ; } else { int half = ( ( length + BLOCK_SIZE ) > > _NUM ) & BLOCK_MASK ; return Text . newComposite ( Text . valueOf ( chars , offset , half ) , Text . valueOf ( chars , offset + half , length - half ) ) ; } }
public static Text valueOf ( char [ ] chars , int offset , int length ) { if ( ( offset < _NUM ) || ( length < _NUM ) || ( ( offset + length ) > chars . length ) ) throw new IndexOutOfBoundsException ( ) ; if ( length <= BLOCK_SIZE ) { Text text = Text . newPrimitive ( length ) ; System . arraycopy ( chars , offset , text . _data , _NUM , length ) ; return text ; } else { int half = ( ( length + BLOCK_SIZE ) > > _NUM ) & BLOCK_MASK ; return Text . newComposite ( Text . valueOf ( chars , offset , half ) , Text . valueOf ( chars , offset + half , length - half ) ) ; } }
public void testConstructorBytesPositive ( ) { byte aBytes [ ] = { _NUM , _NUM , _NUM , - _NUM , _NUM , _NUM , - _NUM , - _NUM } ; byte rBytes [ ] = { _NUM , _NUM , _NUM , - _NUM , _NUM , _NUM , - _NUM , - _NUM } ; BigInteger aNumber = new BigInteger ( aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , aNumber . signum ( ) ) ; }
public MimSearchEditor ( MimBuildRunner runner ) { this ( runner , STRING ) ; }
public MimSearchEditor ( MimBuildRunner runner ) { this ( runner , STRING ) ; }
public MimSearchEditor ( MimBuildRunner runner ) { this ( runner , STRING ) ; }
public void addChildFrame ( Container c ) { m_ChildFrames . add ( c ) ; windowListChanged ( ) ; }
public static int findIndexOf ( String str , char search ) { return findIndexOf ( str , search , search ) ; }
public static int findIndexOf ( String str , char search ) { return findIndexOf ( str , search , search ) ; }
public static int findIndexOf ( String str , char search ) { return findIndexOf ( str , search , search ) ; }
public static int findIndexOf ( String str , char search ) { return findIndexOf ( str , search , search ) ; }
public JdbcConnection execute ( Operations operations ) throws SQLException { Connection conn = connection ( ) ; try ( Statement statement = conn . createStatement ( ) ) { operations . apply ( statement ) ; if ( ! conn . getAutoCommit ( ) ) conn . commit ( ) ; } return this ; }
@ Override public AlarmEvent evaluate ( AlarmPoint alarm , String trigger ) { if ( trigger . equals ( AlarmPoint . TRIGGER_ACTIVATE ) ) { return activation ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_DEACTIVATE ) ) { return deactivation ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_ACKNOWLEDGE ) ) { return acknowledge ( alarm ) ; } else { throw new IllegalArgumentException ( STRING + trigger + STRING ) ; } }
@ Override public AlarmEvent evaluate ( AlarmPoint alarm , String trigger ) { if ( trigger . equals ( AlarmPoint . TRIGGER_ACTIVATE ) ) { return activation ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_DEACTIVATE ) ) { return deactivation ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_ACKNOWLEDGE ) ) { return acknowledge ( alarm ) ; } else { throw new IllegalArgumentException ( STRING + trigger + STRING ) ; } }
private static long CallLongMethodV ( JNIEnvironment env , int objJREF , int methodID , Address argAddress ) throws Exception { if ( traceJNI ) VM . sysWrite ( STRING ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { Object obj = env . getJNIRef ( objJREF ) ; Object returnObj = JNIHelpers . invokeWithVarArg ( obj , methodID , argAddress , TypeReference . Long , _BOOL ) ; return Reflection . unwrapLong ( returnObj ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return _NUM ; } }
private static long CallLongMethodV ( JNIEnvironment env , int objJREF , int methodID , Address argAddress ) throws Exception { if ( traceJNI ) VM . sysWrite ( STRING ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { Object obj = env . getJNIRef ( objJREF ) ; Object returnObj = JNIHelpers . invokeWithVarArg ( obj , methodID , argAddress , TypeReference . Long , _BOOL ) ; return Reflection . unwrapLong ( returnObj ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return _NUM ; } }
public static List < Apn > query ( Context context ) { String [ ] simCodes = getSimOperatorCodes ( context ) ; String [ ] networkCodes = getNetworkOperatorCodes ( context ) ; Set < Apn > resultSet = new HashSet < > ( ) ; resultSet . addAll ( query ( context , simCodes [ _NUM ] , simCodes [ _NUM ] ) ) ; resultSet . addAll ( query ( context , networkCodes [ _NUM ] , networkCodes [ _NUM ] ) ) ; List < Apn > result = new ArrayList < > ( resultSet . size ( ) ) ; result . addAll ( resultSet ) ; return result ; }
public static List < Apn > query ( Context context ) { String [ ] simCodes = getSimOperatorCodes ( context ) ; String [ ] networkCodes = getNetworkOperatorCodes ( context ) ; Set < Apn > resultSet = new HashSet < > ( ) ; resultSet . addAll ( query ( context , simCodes [ _NUM ] , simCodes [ _NUM ] ) ) ; resultSet . addAll ( query ( context , networkCodes [ _NUM ] , networkCodes [ _NUM ] ) ) ; List < Apn > result = new ArrayList < > ( resultSet . size ( ) ) ; result . addAll ( resultSet ) ; return result ; }
public SubjectAlternativeNameExtension ( Boolean critical , Object value ) throws IOException { this . extensionId = PKIXExtensions . SubjectAlternativeName_Id ; this . critical = critical . booleanValue ( ) ; this . extensionValue = ( byte [ ] ) value ; DerValue val = new DerValue ( this . extensionValue ) ; if ( val . data == null ) { names = new GeneralNames ( ) ; return ; } names = new GeneralNames ( val ) ; }
private static void adjustPoolSize ( int players ) { pool . setCorePoolSize ( Math . max ( BASE_THREADS , players / PLAYERS_PER_THREAD ) ) ; }
private static void adjustPoolSize ( int players ) { pool . setCorePoolSize ( Math . max ( BASE_THREADS , players / PLAYERS_PER_THREAD ) ) ; }
@ Override public synchronized void put ( String key , Entry entry ) { pruneIfNeeded ( entry . data . length ) ; File file = getFileForKey ( key ) ; try { BufferedOutputStream fos = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; CacheHeader e = new CacheHeader ( key , entry ) ; boolean success = e . writeHeader ( fos ) ; if ( ! success ) { fos . close ( ) ; VolleyLog . d ( STRING , file . getAbsolutePath ( ) ) ; throw new IOException ( ) ; } fos . write ( entry . data ) ; fos . close ( ) ; putEntry ( key , e ) ; return ; } catch ( IOException e ) { } boolean deleted = file . delete ( ) ; if ( ! deleted ) { VolleyLog . d ( STRING , file . getAbsolutePath ( ) ) ; } }
public void writePopulationAndAttributes ( String inputFolder , String provinceName ) throws IOException { String path = inputFolder . endsWith ( STRING ) ? STRING : STRING ; File outputFolder = new File ( inputFolder + path + provinceName + path ) ; if ( outputFolder . exists ( ) ) { throw new IOException ( STRING + outputFolder . getAbsolutePath ( ) ) ; } else { outputFolder . mkdirs ( ) ; } writeHouseholds ( outputFolder . getAbsolutePath ( ) ) ; writePopulation ( outputFolder . getAbsolutePath ( ) ) ; }
public void writePopulationAndAttributes ( String inputFolder , String provinceName ) throws IOException { String path = inputFolder . endsWith ( STRING ) ? STRING : STRING ; File outputFolder = new File ( inputFolder + path + provinceName + path ) ; if ( outputFolder . exists ( ) ) { throw new IOException ( STRING + outputFolder . getAbsolutePath ( ) ) ; } else { outputFolder . mkdirs ( ) ; } writeHouseholds ( outputFolder . getAbsolutePath ( ) ) ; writePopulation ( outputFolder . getAbsolutePath ( ) ) ; }
public void writePopulationAndAttributes ( String inputFolder , String provinceName ) throws IOException { String path = inputFolder . endsWith ( STRING ) ? STRING : STRING ; File outputFolder = new File ( inputFolder + path + provinceName + path ) ; if ( outputFolder . exists ( ) ) { throw new IOException ( STRING + outputFolder . getAbsolutePath ( ) ) ; } else { outputFolder . mkdirs ( ) ; } writeHouseholds ( outputFolder . getAbsolutePath ( ) ) ; writePopulation ( outputFolder . getAbsolutePath ( ) ) ; }
public void writePopulationAndAttributes ( String inputFolder , String provinceName ) throws IOException { String path = inputFolder . endsWith ( STRING ) ? STRING : STRING ; File outputFolder = new File ( inputFolder + path + provinceName + path ) ; if ( outputFolder . exists ( ) ) { throw new IOException ( STRING + outputFolder . getAbsolutePath ( ) ) ; } else { outputFolder . mkdirs ( ) ; } writeHouseholds ( outputFolder . getAbsolutePath ( ) ) ; writePopulation ( outputFolder . getAbsolutePath ( ) ) ; }
public void writePopulationAndAttributes ( String inputFolder , String provinceName ) throws IOException { String path = inputFolder . endsWith ( STRING ) ? STRING : STRING ; File outputFolder = new File ( inputFolder + path + provinceName + path ) ; if ( outputFolder . exists ( ) ) { throw new IOException ( STRING + outputFolder . getAbsolutePath ( ) ) ; } else { outputFolder . mkdirs ( ) ; } writeHouseholds ( outputFolder . getAbsolutePath ( ) ) ; writePopulation ( outputFolder . getAbsolutePath ( ) ) ; }
public void addTag ( final String key , final PresetKeyType type , String value , String text ) { if ( key == null ) throw new NullPointerException ( STRING ) ; if ( value == null ) value = STRING ; if ( text != null && po != null ) { text = po . t ( text ) ; } fixedTags . put ( key , new StringWithDescription ( value , text ) ) ; if ( ! chunk ) { tagItems . add ( key + STRING + value , this ) ; } keyType . put ( key , type ) ; if ( appliesTo ( ElementType . NODE ) ) autosuggestNodes . add ( key , value . length ( ) > _NUM ? new StringWithDescription ( value , text ) : null ) ; if ( appliesTo ( ElementType . WAY ) ) autosuggestWays . add ( key , value . length ( ) > _NUM ? new StringWithDescription ( value , text ) : null ) ; if ( appliesTo ( ElementType . CLOSEDWAY ) ) autosuggestClosedways . add ( key , value . length ( ) > _NUM ? new StringWithDescription ( value , text ) : null ) ; if ( appliesTo ( ElementType . RELATION ) ) autosuggestRelations . add ( key , value . length ( ) > _NUM ? new StringWithDescription ( value , text ) : null ) ; if ( appliesTo ( ElementType . AREA ) ) autosuggestAreas . add ( key , value . length ( ) > _NUM ? new StringWithDescription ( value , text ) : null ) ; }
public void addTag ( final String key , final PresetKeyType type , String value , String text ) { if ( key == null ) throw new NullPointerException ( STRING ) ; if ( value == null ) value = STRING ; if ( text != null && po != null ) { text = po . t ( text ) ; } fixedTags . put ( key , new StringWithDescription ( value , text ) ) ; if ( ! chunk ) { tagItems . add ( key + STRING + value , this ) ; } keyType . put ( key , type ) ; if ( appliesTo ( ElementType . NODE ) ) autosuggestNodes . add ( key , value . length ( ) > _NUM ? new StringWithDescription ( value , text ) : null ) ; if ( appliesTo ( ElementType . WAY ) ) autosuggestWays . add ( key , value . length ( ) > _NUM ? new StringWithDescription ( value , text ) : null ) ; if ( appliesTo ( ElementType . CLOSEDWAY ) ) autosuggestClosedways . add ( key , value . length ( ) > _NUM ? new StringWithDescription ( value , text ) : null ) ; if ( appliesTo ( ElementType . RELATION ) ) autosuggestRelations . add ( key , value . length ( ) > _NUM ? new StringWithDescription ( value , text ) : null ) ; if ( appliesTo ( ElementType . AREA ) ) autosuggestAreas . add ( key , value . length ( ) > _NUM ? new StringWithDescription ( value , text ) : null ) ; }
public void addMethod ( SootMethod m ) { checkLevel ( SIGNATURES ) ; if ( m . isDeclared ( ) ) throw new RuntimeException ( STRING + m . getName ( ) ) ; if ( subSigToMethods . get ( m . getNumberedSubSignature ( ) ) != null ) { throw new RuntimeException ( STRING + m . getSubSignature ( ) + STRING + this + STRING ) ; } subSigToMethods . put ( m . getNumberedSubSignature ( ) , m ) ; methodList . add ( m ) ; m . setDeclared ( _BOOL ) ; m . setDeclaringClass ( this ) ; }
public ConcurrentSkipListMap ( SortedMap < K , ? extends V > m ) { this . comparator = m . comparator ( ) ; initialize ( ) ; buildFromSorted ( m ) ; }
public ConcurrentSkipListMap ( SortedMap < K , ? extends V > m ) { this . comparator = m . comparator ( ) ; initialize ( ) ; buildFromSorted ( m ) ; }
public void removeEventListener ( SIPTransactionEventListener oldListener ) { eventListeners . remove ( oldListener ) ; }
public static int [ ] subArray ( final int [ ] input , final int start , final int end ) { int [ ] result = new int [ end - start ] ; System . arraycopy ( input , start , result , _NUM , end - start ) ; return result ; }
public void addURL ( String url ) { ActionUnion ret = new ActionUnion ( ) ; ret . url ( url ) ; currentGestureActionList . addElement ( ret ) ; }
public void addURL ( String url ) { ActionUnion ret = new ActionUnion ( ) ; ret . url ( url ) ; currentGestureActionList . addElement ( ret ) ; }
protected void nextTable ( ) throws ReplicatorException , SQLException { while ( importTables . next ( ) ) { if ( includeImportTable ( ) == _BOOL ) { currentTablePosition = _NUM ; extractCreateTableStatement = this . includeStructure ; prepareImportTable ( ) ; break ; } } }
protected void nextTable ( ) throws ReplicatorException , SQLException { while ( importTables . next ( ) ) { if ( includeImportTable ( ) == _BOOL ) { currentTablePosition = _NUM ; extractCreateTableStatement = this . includeStructure ; prepareImportTable ( ) ; break ; } } }
private static int applyPrecision ( int decExp , char [ ] digits , int nDigits , int prec ) { if ( prec >= nDigits || prec < _NUM ) { return decExp ; } if ( prec == _NUM ) { if ( digits [ _NUM ] >= STRING ) { digits [ _NUM ] = STRING ; Arrays . fill ( digits , _NUM , nDigits , STRING ) ; return decExp + _NUM ; } else { Arrays . fill ( digits , _NUM , nDigits , STRING ) ; return decExp ; } } int q = digits [ prec ] ; if ( q >= STRING ) { int i = prec ; q = digits [ -- i ] ; if ( q == STRING ) { while ( q == STRING && i > _NUM ) { q = digits [ -- i ] ; } if ( q == STRING ) { digits [ _NUM ] = STRING ; Arrays . fill ( digits , _NUM , nDigits , STRING ) ; return decExp + _NUM ; } } digits [ i ] = ( char ) ( q + _NUM ) ; Arrays . fill ( digits , i + _NUM , nDigits , STRING ) ; } else { Arrays . fill ( digits , prec , nDigits , STRING ) ; } return decExp ; }
@ Nullable public File resolveParentDirectory ( @ Nullable Label label ) { return label != null ? resolveParentDirectory ( label . blazePackage ( ) , label . ruleName ( ) ) : null ; }
public void addNotifyTask ( Runnable run ) { if ( run != null ) { tasks . add ( run ) ; } }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . nextDouble ( ) <= insertRate ) { for ( int i = _NUM ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; vals [ i ] = new byte [ _NUM ] ; r . nextBytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( _NUM , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; if ( groundTruth != null ) { groundTruth . submit ( _NUM , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = _NUM ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; } lock . lock ( ) ; try { ndx . submit ( _NUM , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; if ( groundTruth != null ) { groundTruth . submit ( _NUM , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . nextDouble ( ) <= insertRate ) { for ( int i = _NUM ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; vals [ i ] = new byte [ _NUM ] ; r . nextBytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( _NUM , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; if ( groundTruth != null ) { groundTruth . submit ( _NUM , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = _NUM ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; } lock . lock ( ) ; try { ndx . submit ( _NUM , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; if ( groundTruth != null ) { groundTruth . submit ( _NUM , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . nextDouble ( ) <= insertRate ) { for ( int i = _NUM ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; vals [ i ] = new byte [ _NUM ] ; r . nextBytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( _NUM , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; if ( groundTruth != null ) { groundTruth . submit ( _NUM , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = _NUM ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; } lock . lock ( ) ; try { ndx . submit ( _NUM , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; if ( groundTruth != null ) { groundTruth . submit ( _NUM , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . nextDouble ( ) <= insertRate ) { for ( int i = _NUM ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; vals [ i ] = new byte [ _NUM ] ; r . nextBytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( _NUM , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; if ( groundTruth != null ) { groundTruth . submit ( _NUM , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = _NUM ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; } lock . lock ( ) ; try { ndx . submit ( _NUM , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; if ( groundTruth != null ) { groundTruth . submit ( _NUM , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . nextDouble ( ) <= insertRate ) { for ( int i = _NUM ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; vals [ i ] = new byte [ _NUM ] ; r . nextBytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( _NUM , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; if ( groundTruth != null ) { groundTruth . submit ( _NUM , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = _NUM ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; } lock . lock ( ) ; try { ndx . submit ( _NUM , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; if ( groundTruth != null ) { groundTruth . submit ( _NUM , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . nextDouble ( ) <= insertRate ) { for ( int i = _NUM ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; vals [ i ] = new byte [ _NUM ] ; r . nextBytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( _NUM , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; if ( groundTruth != null ) { groundTruth . submit ( _NUM , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = _NUM ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; } lock . lock ( ) ; try { ndx . submit ( _NUM , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; if ( groundTruth != null ) { groundTruth . submit ( _NUM , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . nextDouble ( ) <= insertRate ) { for ( int i = _NUM ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; vals [ i ] = new byte [ _NUM ] ; r . nextBytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( _NUM , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; if ( groundTruth != null ) { groundTruth . submit ( _NUM , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = _NUM ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; } lock . lock ( ) ; try { ndx . submit ( _NUM , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; if ( groundTruth != null ) { groundTruth . submit ( _NUM , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public Void call ( ) throws Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . nextDouble ( ) <= insertRate ) { for ( int i = _NUM ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; vals [ i ] = new byte [ _NUM ] ; r . nextBytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( _NUM , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; if ( groundTruth != null ) { groundTruth . submit ( _NUM , nops , keys , vals , BatchInsertConstructor . RETURN_NO_VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = _NUM ; i < nops ; i ++ ) { keys [ i ] = nextKey ( ) ; } lock . lock ( ) ; try { ndx . submit ( _NUM , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; if ( groundTruth != null ) { groundTruth . submit ( _NUM , nops , keys , null , BatchRemoveConstructor . RETURN_MUTATION_COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public static List < String > refNames ( Collection < ? extends NamedRelatedResourceRep > refs ) { List < String > names = new ArrayList < String > ( ) ; if ( refs != null ) { for ( NamedRelatedResourceRep ref : refs ) { names . add ( ref . getName ( ) ) ; } } return names ; }
protected double angleBetween ( Point2D v1 , Point2D v2 ) { double x1 = v1 . getX ( ) ; double y1 = v1 . getY ( ) ; double x2 = v2 . getX ( ) ; double y2 = v2 . getY ( ) ; double cross = x1 * y2 - x2 * y1 ; int cw = _NUM ; if ( cross > _NUM ) { cw = - _NUM ; } double angle = cw * Math . acos ( ( x1 * x2 + y1 * y2 ) / ( Math . sqrt ( x1 * x1 + y1 * y1 ) * Math . sqrt ( x2 * x2 + y2 * y2 ) ) ) ; if ( Double . isNaN ( angle ) ) { angle = _NUM ; } return angle ; }
public void write ( int c ) throws java . io . IOException { synchronized ( lock ) { char oneCharArray [ ] = new char [ _NUM ] ; oneCharArray [ _NUM ] = ( char ) c ; write ( oneCharArray ) ; } }
public void write ( int c ) throws java . io . IOException { synchronized ( lock ) { char oneCharArray [ ] = new char [ _NUM ] ; oneCharArray [ _NUM ] = ( char ) c ; write ( oneCharArray ) ; } }
public void write ( int c ) throws java . io . IOException { synchronized ( lock ) { char oneCharArray [ ] = new char [ _NUM ] ; oneCharArray [ _NUM ] = ( char ) c ; write ( oneCharArray ) ; } }
public void write ( int c ) throws java . io . IOException { synchronized ( lock ) { char oneCharArray [ ] = new char [ _NUM ] ; oneCharArray [ _NUM ] = ( char ) c ; write ( oneCharArray ) ; } }
public void write ( int c ) throws java . io . IOException { synchronized ( lock ) { char oneCharArray [ ] = new char [ _NUM ] ; oneCharArray [ _NUM ] = ( char ) c ; write ( oneCharArray ) ; } }
private String listToString ( List < String > stringList ) { StringBuilder concat = new StringBuilder ( ) ; for ( String str : stringList ) { concat . append ( str ) ; concat . append ( System . getProperty ( STRING ) ) ; } return concat . toString ( ) ; }
private EnvironmentLogger buildParentTree ( String childName ) { if ( childName == null || childName . equals ( STRING ) ) return null ; int p = childName . lastIndexOf ( STRING ) ; String parentName ; if ( p > _NUM ) parentName = childName . substring ( _NUM , p ) ; else parentName = STRING ; EnvironmentLogger parent = null ; SoftReference < EnvironmentLogger > parentRef = _envLoggers . get ( parentName ) ; if ( parentRef != null ) parent = parentRef . get ( ) ; if ( parent != null ) return parent ; else { parent = new EnvironmentLogger ( parentName , null ) ; _envLoggers . put ( parentName , new SoftReference < EnvironmentLogger > ( parent ) ) ; EnvironmentLogger grandparent = buildParentTree ( parentName ) ; if ( grandparent != null ) parent . setParent ( grandparent ) ; return parent ; } }
public final void buildSignedDirectory ( ) throws Exception { try ( ByteArrayOutputStream mimeContent = new ByteArrayOutputStream ( ) ) { build ( mimeContent ) ; log . debug ( STRING , mimeContent . toString ( ) ) ; byte [ ] contentBytes = mimeContent . toByteArray ( ) ; mimeContent . reset ( ) ; sign ( contentBytes , mimeContent ) ; Files . write ( tempConfPath , mimeContent . toByteArray ( ) ) ; log . debug ( STRING , tempConfPath ) ; } }
public final void buildSignedDirectory ( ) throws Exception { try ( ByteArrayOutputStream mimeContent = new ByteArrayOutputStream ( ) ) { build ( mimeContent ) ; log . debug ( STRING , mimeContent . toString ( ) ) ; byte [ ] contentBytes = mimeContent . toByteArray ( ) ; mimeContent . reset ( ) ; sign ( contentBytes , mimeContent ) ; Files . write ( tempConfPath , mimeContent . toByteArray ( ) ) ; log . debug ( STRING , tempConfPath ) ; } }
public void addBiomes ( List < BiomeGenBase > biomes ) { allowedBiomes . addAll ( getBiomesEntries ( biomes ) ) ; }
protected int drawUnselectedText ( Graphics g , int x , int y , int p0 , int p1 ) throws BadLocationException { g . setColor ( unselected ) ; Document doc = getDocument ( ) ; Segment s = SegmentCache . getSharedSegment ( ) ; doc . getText ( p0 , p1 - p0 , s ) ; int ret = Utilities . drawTabbedText ( this , s , x , y , g , this , p0 ) ; SegmentCache . releaseSharedSegment ( s ) ; return ret ; }
protected int drawUnselectedText ( Graphics g , int x , int y , int p0 , int p1 ) throws BadLocationException { g . setColor ( unselected ) ; Document doc = getDocument ( ) ; Segment s = SegmentCache . getSharedSegment ( ) ; doc . getText ( p0 , p1 - p0 , s ) ; int ret = Utilities . drawTabbedText ( this , s , x , y , g , this , p0 ) ; SegmentCache . releaseSharedSegment ( s ) ; return ret ; }
public TestClientAbstract ( String testName , boolean verbose , boolean synchronous ) { if ( testName == null || testName . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING ) ; } this . testName = testName ; this . verbose = verbose ; this . sync = synchronous ; }
public DateTimeFormatterBuilder parseDefaulting ( TemporalField field , long value ) { Objects . requireNonNull ( field , STRING ) ; appendInternal ( new DefaultValueParser ( field , value ) ) ; return this ; }
public DateTimeFormatterBuilder parseDefaulting ( TemporalField field , long value ) { Objects . requireNonNull ( field , STRING ) ; appendInternal ( new DefaultValueParser ( field , value ) ) ; return this ; }
public DateTimeFormatterBuilder parseDefaulting ( TemporalField field , long value ) { Objects . requireNonNull ( field , STRING ) ; appendInternal ( new DefaultValueParser ( field , value ) ) ; return this ; }
public DateTimeFormatterBuilder parseDefaulting ( TemporalField field , long value ) { Objects . requireNonNull ( field , STRING ) ; appendInternal ( new DefaultValueParser ( field , value ) ) ; return this ; }
@ Override protected EClass findInstantiableCompatible ( EClass eType ) { if ( ! isInstantiatableSubType ( eType , eType ) ) { throw new IllegalStateException ( String . valueOf ( eType ) ) ; } return eType ; }
@ VisibleForTesting protected Map < String , String > calculateModifiedServerDefaults ( Map < String , String > newDefaults , Map < String , String > existingDefaults , Set < String > attrToModify ) { Map < String , String > modifiedValues = new HashMap < String , String > ( ) ; for ( String attrName : attrToModify ) { String newAttr = newDefaults . get ( attrName ) ; String existingAttr = existingDefaults . get ( attrName ) ; if ( newAttr != null && existingAttr != null && ! newAttr . equals ( existingAttr ) ) { modifiedValues . put ( attrName , newAttr ) ; } } return modifiedValues ; }
public static List < SOAPElement > inputNeeded ( SOAPElement ele ) { List < SOAPElement > l = new ArrayList < SOAPElement > ( ) ; log . trace ( STRING + ele . getNodeName ( ) ) ; inputNeeded ( ele , l ) ; log . trace ( STRING + l ) ; return l ; }
public static List < SOAPElement > inputNeeded ( SOAPElement ele ) { List < SOAPElement > l = new ArrayList < SOAPElement > ( ) ; log . trace ( STRING + ele . getNodeName ( ) ) ; inputNeeded ( ele , l ) ; log . trace ( STRING + l ) ; return l ; }
public static List < SOAPElement > inputNeeded ( SOAPElement ele ) { List < SOAPElement > l = new ArrayList < SOAPElement > ( ) ; log . trace ( STRING + ele . getNodeName ( ) ) ; inputNeeded ( ele , l ) ; log . trace ( STRING + l ) ; return l ; }
public static Color blend ( Color color1 , Color color2 , double weight ) { double w2 = MathUtils . limit ( weight , _NUM , _NUM ) ; double w1 = _NUM - w2 ; int r = ( int ) Math . round ( w1 * color1 . getRed ( ) + w2 * color2 . getRed ( ) ) ; int g = ( int ) Math . round ( w1 * color1 . getGreen ( ) + w2 * color2 . getGreen ( ) ) ; int b = ( int ) Math . round ( w1 * color1 . getBlue ( ) + w2 * color2 . getBlue ( ) ) ; int a = ( int ) Math . round ( w1 * color1 . getAlpha ( ) + w2 * color2 . getAlpha ( ) ) ; return new Color ( r , g , b , a ) ; }
@ Override public void onItemClick ( AdapterView < ? > parent , View view , int position , long id ) { setSelection ( position ) ; }
@ Override public void onItemClick ( AdapterView < ? > parent , View view , int position , long id ) { setSelection ( position ) ; }
public static int countOccurrences ( String fullString , String pattern ) { int lastIndex = _NUM ; int count = _NUM ; while ( lastIndex != - _NUM ) { lastIndex = fullString . indexOf ( pattern , lastIndex ) ; if ( lastIndex != - _NUM ) { count ++ ; lastIndex += pattern . length ( ) ; } } return count ; }
private void pendingEvent ( EventReg reg , ServiceID sid , Item item , int transition , boolean copyItem ) { if ( item != null && copyItem ) item = copyItem ( item ) ; newNotifies . add ( new EventTask ( reg , sid , item , transition ) ) ; }
@ Override protected void paintTabBackground ( Graphics g , int tabPlacement , int tabIndex , int x , int y , int w , int h , boolean isSelected ) { if ( isSelected ) { if ( tabPlacement == TOP ) { g . setColor ( Color . white ) ; g . fillRoundRect ( x , y , w , h + R + R , R , R ) ; } } else { } }
@ Override protected void paintTabBackground ( Graphics g , int tabPlacement , int tabIndex , int x , int y , int w , int h , boolean isSelected ) { if ( isSelected ) { if ( tabPlacement == TOP ) { g . setColor ( Color . white ) ; g . fillRoundRect ( x , y , w , h + R + R , R , R ) ; } } else { } }
@ Override public String stem ( String word ) { String result ; Object [ ] args ; if ( m_Stemmer == null ) { result = new String ( word ) ; } else { if ( m_SetCurrentMethod == null ) { setStemmer ( getStemmer ( ) ) ; } try { args = new Object [ _NUM ] ; args [ _NUM ] = word ; m_SetCurrentMethod . invoke ( m_Stemmer , args ) ; args = new Object [ _NUM ] ; m_StemMethod . invoke ( m_Stemmer , args ) ; args = new Object [ _NUM ] ; result = ( String ) m_GetCurrentMethod . invoke ( m_Stemmer , args ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; result = word ; } } return result ; }
public String toString ( ) { return STRING + val . replace ( STRING , STRING ) + STRING ; }
public String toString ( ) { return STRING + val . replace ( STRING , STRING ) + STRING ; }
int findSyncPosition ( ) { int count = mItemCount ; if ( count == _NUM ) { return INVALID_POSITION ; } long idToMatch = mSyncRowId ; int seed = mSyncPosition ; if ( idToMatch == INVALID_ROW_ID ) { return INVALID_POSITION ; } seed = Math . max ( _NUM , seed ) ; seed = Math . min ( count - _NUM , seed ) ; long endTime = SystemClock . uptimeMillis ( ) + SYNC_MAX_DURATION_MILLIS ; long rowId ; int first = seed ; int last = seed ; boolean next = _BOOL ; boolean hitFirst ; boolean hitLast ; T adapter = getAdapter ( ) ; if ( adapter == null ) { return INVALID_POSITION ; } while ( SystemClock . uptimeMillis ( ) <= endTime ) { rowId = adapter . getItemId ( seed ) ; if ( rowId == idToMatch ) { return seed ; } hitLast = last == count - _NUM ; hitFirst = first == _NUM ; if ( hitLast && hitFirst ) { break ; } if ( hitFirst || ( next && ! hitLast ) ) { last ++ ; seed = last ; next = _BOOL ; } else if ( hitLast ) { first -- ; seed = first ; next = _BOOL ; } } return INVALID_POSITION ; }
int findSyncPosition ( ) { int count = mItemCount ; if ( count == _NUM ) { return INVALID_POSITION ; } long idToMatch = mSyncRowId ; int seed = mSyncPosition ; if ( idToMatch == INVALID_ROW_ID ) { return INVALID_POSITION ; } seed = Math . max ( _NUM , seed ) ; seed = Math . min ( count - _NUM , seed ) ; long endTime = SystemClock . uptimeMillis ( ) + SYNC_MAX_DURATION_MILLIS ; long rowId ; int first = seed ; int last = seed ; boolean next = _BOOL ; boolean hitFirst ; boolean hitLast ; T adapter = getAdapter ( ) ; if ( adapter == null ) { return INVALID_POSITION ; } while ( SystemClock . uptimeMillis ( ) <= endTime ) { rowId = adapter . getItemId ( seed ) ; if ( rowId == idToMatch ) { return seed ; } hitLast = last == count - _NUM ; hitFirst = first == _NUM ; if ( hitLast && hitFirst ) { break ; } if ( hitFirst || ( next && ! hitLast ) ) { last ++ ; seed = last ; next = _BOOL ; } else if ( hitLast ) { first -- ; seed = first ; next = _BOOL ; } } return INVALID_POSITION ; }
int findSyncPosition ( ) { int count = mItemCount ; if ( count == _NUM ) { return INVALID_POSITION ; } long idToMatch = mSyncRowId ; int seed = mSyncPosition ; if ( idToMatch == INVALID_ROW_ID ) { return INVALID_POSITION ; } seed = Math . max ( _NUM , seed ) ; seed = Math . min ( count - _NUM , seed ) ; long endTime = SystemClock . uptimeMillis ( ) + SYNC_MAX_DURATION_MILLIS ; long rowId ; int first = seed ; int last = seed ; boolean next = _BOOL ; boolean hitFirst ; boolean hitLast ; T adapter = getAdapter ( ) ; if ( adapter == null ) { return INVALID_POSITION ; } while ( SystemClock . uptimeMillis ( ) <= endTime ) { rowId = adapter . getItemId ( seed ) ; if ( rowId == idToMatch ) { return seed ; } hitLast = last == count - _NUM ; hitFirst = first == _NUM ; if ( hitLast && hitFirst ) { break ; } if ( hitFirst || ( next && ! hitLast ) ) { last ++ ; seed = last ; next = _BOOL ; } else if ( hitLast ) { first -- ; seed = first ; next = _BOOL ; } } return INVALID_POSITION ; }
int findSyncPosition ( ) { int count = mItemCount ; if ( count == _NUM ) { return INVALID_POSITION ; } long idToMatch = mSyncRowId ; int seed = mSyncPosition ; if ( idToMatch == INVALID_ROW_ID ) { return INVALID_POSITION ; } seed = Math . max ( _NUM , seed ) ; seed = Math . min ( count - _NUM , seed ) ; long endTime = SystemClock . uptimeMillis ( ) + SYNC_MAX_DURATION_MILLIS ; long rowId ; int first = seed ; int last = seed ; boolean next = _BOOL ; boolean hitFirst ; boolean hitLast ; T adapter = getAdapter ( ) ; if ( adapter == null ) { return INVALID_POSITION ; } while ( SystemClock . uptimeMillis ( ) <= endTime ) { rowId = adapter . getItemId ( seed ) ; if ( rowId == idToMatch ) { return seed ; } hitLast = last == count - _NUM ; hitFirst = first == _NUM ; if ( hitLast && hitFirst ) { break ; } if ( hitFirst || ( next && ! hitLast ) ) { last ++ ; seed = last ; next = _BOOL ; } else if ( hitLast ) { first -- ; seed = first ; next = _BOOL ; } } return INVALID_POSITION ; }
public ModeledAuthenticatedUser ( AuthenticatedUser authenticatedUser , AuthenticationProvider modelAuthenticationProvider , ModeledUser user ) { super ( authenticatedUser . getAuthenticationProvider ( ) , authenticatedUser . getCredentials ( ) ) ; this . modelAuthenticationProvider = modelAuthenticationProvider ; this . user = user ; }
public ModeledAuthenticatedUser ( AuthenticatedUser authenticatedUser , AuthenticationProvider modelAuthenticationProvider , ModeledUser user ) { super ( authenticatedUser . getAuthenticationProvider ( ) , authenticatedUser . getCredentials ( ) ) ; this . modelAuthenticationProvider = modelAuthenticationProvider ; this . user = user ; }
public ModeledAuthenticatedUser ( AuthenticatedUser authenticatedUser , AuthenticationProvider modelAuthenticationProvider , ModeledUser user ) { super ( authenticatedUser . getAuthenticationProvider ( ) , authenticatedUser . getCredentials ( ) ) ; this . modelAuthenticationProvider = modelAuthenticationProvider ; this . user = user ; }
public ModeledAuthenticatedUser ( AuthenticatedUser authenticatedUser , AuthenticationProvider modelAuthenticationProvider , ModeledUser user ) { super ( authenticatedUser . getAuthenticationProvider ( ) , authenticatedUser . getCredentials ( ) ) ; this . modelAuthenticationProvider = modelAuthenticationProvider ; this . user = user ; }
public ModeledAuthenticatedUser ( AuthenticatedUser authenticatedUser , AuthenticationProvider modelAuthenticationProvider , ModeledUser user ) { super ( authenticatedUser . getAuthenticationProvider ( ) , authenticatedUser . getCredentials ( ) ) ; this . modelAuthenticationProvider = modelAuthenticationProvider ; this . user = user ; }
void add ( SuperCardToast superCardToast ) { mList . add ( superCardToast ) ; }
public AuthConfigurationModelImpl ( HttpServletRequest req , Map map ) { super ( req , map ) ; currentRealm = ( String ) map . get ( AMAdminConstants . CURRENT_REALM ) ; }
public Time randomTime ( ) { if ( random . nextInt ( _NUM ) == _NUM ) { return null ; } StringBuilder buff = new StringBuilder ( ) ; buff . append ( getInt ( _NUM ) ) ; buff . append ( STRING ) ; buff . append ( getInt ( _NUM ) ) ; buff . append ( STRING ) ; buff . append ( getInt ( _NUM ) ) ; return Time . valueOf ( buff . toString ( ) ) ; }
public void deleteUnused ( ) { while ( queue != null ) { Reference < ? extends Object > ref = queue . poll ( ) ; if ( ref == null ) { break ; } deleteFile ( ref , null ) ; } }
public void deleteUnused ( ) { while ( queue != null ) { Reference < ? extends Object > ref = queue . poll ( ) ; if ( ref == null ) { break ; } deleteFile ( ref , null ) ; } }
public static X500Name x500PrincipalToX500Name ( X500Principal principal ) { return X500Name . getInstance ( KseX500NameStyle . INSTANCE , principal . getEncoded ( ) ) ; }
public TimmyTable addTimmyTable ( String filename , int recordSize ) throws SyncFailedException , IOException { if ( isOpen ) throw new IllegalStateException ( STRING ) ; TimmyTable tt = new TimmyTable ( filename , recordSize , this ) ; tables . add ( tt ) ; return tt ; }
@ Override public String toString ( ) { return buf . toString ( ) ; }
public void write ( byte [ ] buffer , int offset , int length ) throws IOException { _file . write ( buffer , offset , length ) ; }
protected void updateRange ( ) { if ( m_type == int . class ) { setRange ( m_lo . intValue ( ) , m_hi . intValue ( ) - m_lo . intValue ( ) , m_min . intValue ( ) , m_max . intValue ( ) ) ; } else if ( m_type == long . class ) { long range = m_max . longValue ( ) - m_min . longValue ( ) ; if ( range == _NUM ) { setRange ( _NUM , _NUM , _NUM , _NUM ) ; } else { long lo = m_lo . longValue ( ) - m_min . longValue ( ) ; long hi = m_hi . longValue ( ) - m_min . longValue ( ) ; int v = ( int ) ( _NUM * lo / range ) ; int e = ( int ) ( _NUM * hi / range ) - v ; setRange ( v , e , _NUM , _NUM ) ; } } else { double range = m_max . doubleValue ( ) - m_min . doubleValue ( ) ; if ( range == _NUM ) { setRange ( _NUM , _NUM , _NUM , _NUM ) ; } else { double lo = m_lo . doubleValue ( ) - m_min . doubleValue ( ) ; double hi = m_hi . doubleValue ( ) - m_min . doubleValue ( ) ; int v = ( int ) ( _NUM * lo / range ) ; int e = ( int ) ( _NUM * hi / range ) - v ; setRange ( v , e , _NUM , _NUM ) ; } } }
public int pixelFor ( int rgb ) { return surfaceType . pixelFor ( rgb , colorModel ) ; }
protected double distance ( Instance first , Instance second ) { double distance = _NUM ; int firstI , secondI ; for ( int p1 = _NUM , p2 = _NUM ; p1 < first . numValues ( ) || p2 < second . numValues ( ) ; ) { if ( p1 >= first . numValues ( ) ) { firstI = m_instances . numAttributes ( ) ; } else { firstI = first . index ( p1 ) ; } if ( p2 >= second . numValues ( ) ) { secondI = m_instances . numAttributes ( ) ; } else { secondI = second . index ( p2 ) ; } if ( firstI == m_instances . classIndex ( ) ) { p1 ++ ; continue ; } if ( secondI == m_instances . classIndex ( ) ) { p2 ++ ; continue ; } double diff ; if ( firstI == secondI ) { diff = difference ( firstI , first . valueSparse ( p1 ) , second . valueSparse ( p2 ) ) ; p1 ++ ; p2 ++ ; } else if ( firstI > secondI ) { diff = difference ( secondI , _NUM , second . valueSparse ( p2 ) ) ; p2 ++ ; } else { diff = difference ( firstI , first . valueSparse ( p1 ) , _NUM ) ; p1 ++ ; } distance += diff * diff ; } return Math . sqrt ( distance / m_instances . numAttributes ( ) ) ; }
public static ExampleSet createExampleSet ( double [ ] [ ] data , double [ ] labels ) { if ( data . length == _NUM ) { throw new RuntimeException ( STRING ) ; } int numberOfAttributes = data [ _NUM ] . length ; List < Attribute > attributeList = new ArrayList < Attribute > ( numberOfAttributes + ( labels != null ? _NUM : _NUM ) ) ; for ( int a = _NUM ; a < numberOfAttributes ; a ++ ) { attributeList . add ( AttributeFactory . createAttribute ( STRING + ( a + _NUM ) , Ontology . NUMERICAL ) ) ; } Attribute labelAttribute = null ; if ( labels != null ) { labelAttribute = AttributeFactory . createAttribute ( STRING , Ontology . NUMERICAL ) ; attributeList . add ( labelAttribute ) ; } MemoryExampleTable table = new MemoryExampleTable ( attributeList ) ; for ( int e = _NUM ; e < data . length ; e ++ ) { double [ ] dataRow = data [ e ] ; if ( labelAttribute != null ) { dataRow = new double [ numberOfAttributes + _NUM ] ; System . arraycopy ( data [ e ] , _NUM , dataRow , _NUM , data [ e ] . length ) ; dataRow [ dataRow . length - _NUM ] = labels [ e ] ; } table . addDataRow ( new DoubleArrayDataRow ( dataRow ) ) ; } return table . createExampleSet ( labelAttribute ) ; }
public PublisherAmb < T > ambAdditionalSource ( Publisher < ? extends T > source ) { if ( array != null ) { int n = array . length ; @ SuppressWarnings ( STRING ) Publisher < ? extends T > [ ] newArray = new Publisher [ n + _NUM ] ; System . arraycopy ( array , _NUM , newArray , _NUM , n ) ; newArray [ n ] = source ; return new PublisherAmb < > ( newArray ) ; } return null ; }
public PublisherAmb < T > ambAdditionalSource ( Publisher < ? extends T > source ) { if ( array != null ) { int n = array . length ; @ SuppressWarnings ( STRING ) Publisher < ? extends T > [ ] newArray = new Publisher [ n + _NUM ] ; System . arraycopy ( array , _NUM , newArray , _NUM , n ) ; newArray [ n ] = source ; return new PublisherAmb < > ( newArray ) ; } return null ; }
public PublisherAmb < T > ambAdditionalSource ( Publisher < ? extends T > source ) { if ( array != null ) { int n = array . length ; @ SuppressWarnings ( STRING ) Publisher < ? extends T > [ ] newArray = new Publisher [ n + _NUM ] ; System . arraycopy ( array , _NUM , newArray , _NUM , n ) ; newArray [ n ] = source ; return new PublisherAmb < > ( newArray ) ; } return null ; }
public PublisherAmb < T > ambAdditionalSource ( Publisher < ? extends T > source ) { if ( array != null ) { int n = array . length ; @ SuppressWarnings ( STRING ) Publisher < ? extends T > [ ] newArray = new Publisher [ n + _NUM ] ; System . arraycopy ( array , _NUM , newArray , _NUM , n ) ; newArray [ n ] = source ; return new PublisherAmb < > ( newArray ) ; } return null ; }
@ Override public void run ( ) { if ( ! running . compareAndSet ( _BOOL , _BOOL ) ) { throw new IllegalStateException ( STRING ) ; } sequenceBarrier . clearAlert ( ) ; notifyStart ( ) ; boolean processedSequence = _BOOL ; long cachedAvailableSequence = Long . MIN_VALUE ; long nextSequence = sequence . get ( ) ; T event = null ; while ( _BOOL ) { try { if ( processedSequence ) { processedSequence = _BOOL ; do { nextSequence = workSequence . get ( ) + _NUM ; sequence . set ( nextSequence - _NUM ) ; } while ( ! workSequence . compareAndSet ( nextSequence - _NUM , nextSequence ) ) ; } if ( cachedAvailableSequence >= nextSequence ) { event = ringBuffer . get ( nextSequence ) ; workHandler . onEvent ( event ) ; processedSequence = _BOOL ; } else { cachedAvailableSequence = sequenceBarrier . waitFor ( nextSequence ) ; } } catch ( final AlertException ex ) { if ( ! running . get ( ) ) { break ; } } catch ( final Throwable ex ) { exceptionHandler . handleEventException ( ex , nextSequence , event ) ; processedSequence = _BOOL ; } } notifyShutdown ( ) ; running . set ( _BOOL ) ; }
public void addCertRequest ( CertRequest certReq ) { certRequests . add ( certReq ) ; }
public void close ( ) throws IOException { inputStream . close ( ) ; }
@ SuppressWarnings ( STRING ) private static final PipelineOp addKnownInConditional ( PipelineOp left , final FilterNode filter , final AST2BOpContext ctx ) { final InBOp bop = ( InBOp ) filter . getValueExpression ( ) ; final IConstant < IV > [ ] set = bop . getSet ( ) ; final LinkedHashSet < IV > ivs = new LinkedHashSet < IV > ( ) ; for ( IConstant < IV > iv : set ) { ivs . add ( iv . get ( ) ) ; } final IVariable var = ( IVariable ) bop . getValueExpression ( ) ; left = new DataSetJoin ( leftOrEmpty ( left ) , NV . asMap ( new NV [ ] { new NV ( DataSetJoin . Annotations . VAR , var ) , new NV ( DataSetJoin . Annotations . BOP_ID , ctx . nextId ( ) ) , new NV ( DataSetJoin . Annotations . GRAPHS , ivs ) } ) ) ; return left ; }
@ SuppressWarnings ( STRING ) private static final PipelineOp addKnownInConditional ( PipelineOp left , final FilterNode filter , final AST2BOpContext ctx ) { final InBOp bop = ( InBOp ) filter . getValueExpression ( ) ; final IConstant < IV > [ ] set = bop . getSet ( ) ; final LinkedHashSet < IV > ivs = new LinkedHashSet < IV > ( ) ; for ( IConstant < IV > iv : set ) { ivs . add ( iv . get ( ) ) ; } final IVariable var = ( IVariable ) bop . getValueExpression ( ) ; left = new DataSetJoin ( leftOrEmpty ( left ) , NV . asMap ( new NV [ ] { new NV ( DataSetJoin . Annotations . VAR , var ) , new NV ( DataSetJoin . Annotations . BOP_ID , ctx . nextId ( ) ) , new NV ( DataSetJoin . Annotations . GRAPHS , ivs ) } ) ) ; return left ; }
@ Override public void onPlaceSelected ( Place place ) { Log . i ( TAG , STRING + place . getName ( ) ) ; mPlaceDetailsText . setText ( formatPlaceDetails ( getResources ( ) , place . getName ( ) , place . getId ( ) , place . getAddress ( ) , place . getPhoneNumber ( ) , place . getWebsiteUri ( ) ) ) ; CharSequence attributions = place . getAttributions ( ) ; if ( ! TextUtils . isEmpty ( attributions ) ) { mPlaceAttribution . setText ( Html . fromHtml ( attributions . toString ( ) ) ) ; } else { mPlaceAttribution . setText ( STRING ) ; } }
public static boolean checkThickPoolCandidacy ( StoragePool pool , long requiredCapacityInKB , CoordinatorClient coordinator ) { return ( _NUM - getThickPoolFreeCapacityPercentage ( pool , requiredCapacityInKB ) ) <= getMaxPoolUtilizationPercentage ( pool , coordinator ) ; }
public static boolean checkThickPoolCandidacy ( StoragePool pool , long requiredCapacityInKB , CoordinatorClient coordinator ) { return ( _NUM - getThickPoolFreeCapacityPercentage ( pool , requiredCapacityInKB ) ) <= getMaxPoolUtilizationPercentage ( pool , coordinator ) ; }
public static boolean checkThickPoolCandidacy ( StoragePool pool , long requiredCapacityInKB , CoordinatorClient coordinator ) { return ( _NUM - getThickPoolFreeCapacityPercentage ( pool , requiredCapacityInKB ) ) <= getMaxPoolUtilizationPercentage ( pool , coordinator ) ; }
public byte [ ] calculateChecksum ( byte [ ] data , int size ) throws KrbCryptoException { MessageDigest md5 ; byte [ ] result = null ; try { md5 = MessageDigest . getInstance ( STRING ) ; } catch ( Exception e ) { throw new KrbCryptoException ( STRING + e . getMessage ( ) ) ; } try { md5 . update ( data ) ; result = md5 . digest ( ) ; } catch ( Exception e ) { throw new KrbCryptoException ( e . getMessage ( ) ) ; } return result ; }
public Pair < String , String > parse ( String entry ) { if ( entry . length ( ) > _NUM ) { Matcher m = pattern . matcher ( entry ) ; if ( m . matches ( ) ) { String name = m . group ( _NUM ) ; String value = m . group ( _NUM ) ; if ( name != null ) { name = name . trim ( ) ; if ( value == null ) { value = STRING ; } else { value = value . trim ( ) ; } return Pair . of ( name , value ) ; } } } return null ; }
public Pair < String , String > parse ( String entry ) { if ( entry . length ( ) > _NUM ) { Matcher m = pattern . matcher ( entry ) ; if ( m . matches ( ) ) { String name = m . group ( _NUM ) ; String value = m . group ( _NUM ) ; if ( name != null ) { name = name . trim ( ) ; if ( value == null ) { value = STRING ; } else { value = value . trim ( ) ; } return Pair . of ( name , value ) ; } } } return null ; }
public Pair < String , String > parse ( String entry ) { if ( entry . length ( ) > _NUM ) { Matcher m = pattern . matcher ( entry ) ; if ( m . matches ( ) ) { String name = m . group ( _NUM ) ; String value = m . group ( _NUM ) ; if ( name != null ) { name = name . trim ( ) ; if ( value == null ) { value = STRING ; } else { value = value . trim ( ) ; } return Pair . of ( name , value ) ; } } } return null ; }
public Pair < String , String > parse ( String entry ) { if ( entry . length ( ) > _NUM ) { Matcher m = pattern . matcher ( entry ) ; if ( m . matches ( ) ) { String name = m . group ( _NUM ) ; String value = m . group ( _NUM ) ; if ( name != null ) { name = name . trim ( ) ; if ( value == null ) { value = STRING ; } else { value = value . trim ( ) ; } return Pair . of ( name , value ) ; } } } return null ; }
public void reopenReadWrite ( ) { synchronized ( mLock ) { throwIfNotOpenLocked ( ) ; if ( ! isReadOnlyLocked ( ) ) { return ; } final int oldOpenFlags = mConfigurationLocked . openFlags ; mConfigurationLocked . openFlags = ( mConfigurationLocked . openFlags & ~ OPEN_READ_MASK ) | OPEN_READWRITE ; try { mConnectionPoolLocked . reconfigure ( mConfigurationLocked ) ; } catch ( RuntimeException ex ) { mConfigurationLocked . openFlags = oldOpenFlags ; throw ex ; } } }
public void reopenReadWrite ( ) { synchronized ( mLock ) { throwIfNotOpenLocked ( ) ; if ( ! isReadOnlyLocked ( ) ) { return ; } final int oldOpenFlags = mConfigurationLocked . openFlags ; mConfigurationLocked . openFlags = ( mConfigurationLocked . openFlags & ~ OPEN_READ_MASK ) | OPEN_READWRITE ; try { mConnectionPoolLocked . reconfigure ( mConfigurationLocked ) ; } catch ( RuntimeException ex ) { mConfigurationLocked . openFlags = oldOpenFlags ; throw ex ; } } }
public void reopenReadWrite ( ) { synchronized ( mLock ) { throwIfNotOpenLocked ( ) ; if ( ! isReadOnlyLocked ( ) ) { return ; } final int oldOpenFlags = mConfigurationLocked . openFlags ; mConfigurationLocked . openFlags = ( mConfigurationLocked . openFlags & ~ OPEN_READ_MASK ) | OPEN_READWRITE ; try { mConnectionPoolLocked . reconfigure ( mConfigurationLocked ) ; } catch ( RuntimeException ex ) { mConfigurationLocked . openFlags = oldOpenFlags ; throw ex ; } } }
public void reopenReadWrite ( ) { synchronized ( mLock ) { throwIfNotOpenLocked ( ) ; if ( ! isReadOnlyLocked ( ) ) { return ; } final int oldOpenFlags = mConfigurationLocked . openFlags ; mConfigurationLocked . openFlags = ( mConfigurationLocked . openFlags & ~ OPEN_READ_MASK ) | OPEN_READWRITE ; try { mConnectionPoolLocked . reconfigure ( mConfigurationLocked ) ; } catch ( RuntimeException ex ) { mConfigurationLocked . openFlags = oldOpenFlags ; throw ex ; } } }
public void resetStats ( ) { if ( lock . tryLock ( ) ) { try { ensureInitialized ( ) ; updateStats ( ) ; } finally { lock . unlock ( ) ; } } }
public void resetStats ( ) { if ( lock . tryLock ( ) ) { try { ensureInitialized ( ) ; updateStats ( ) ; } finally { lock . unlock ( ) ; } } }
public void resetStats ( ) { if ( lock . tryLock ( ) ) { try { ensureInitialized ( ) ; updateStats ( ) ; } finally { lock . unlock ( ) ; } } }
public void resetStats ( ) { if ( lock . tryLock ( ) ) { try { ensureInitialized ( ) ; updateStats ( ) ; } finally { lock . unlock ( ) ; } } }
public void resetStats ( ) { if ( lock . tryLock ( ) ) { try { ensureInitialized ( ) ; updateStats ( ) ; } finally { lock . unlock ( ) ; } } }
public void resetStats ( ) { if ( lock . tryLock ( ) ) { try { ensureInitialized ( ) ; updateStats ( ) ; } finally { lock . unlock ( ) ; } } }
@ Override public < T extends ServiceDocument > List < String > queryDocumentsForLinks ( Class < T > documentType , ImmutableMap < String , String > terms ) throws BadRequestException , DocumentNotFoundException , TimeoutException , InterruptedException { checkNotNull ( documentType , STRING ) ; QueryTask . QuerySpecification spec = QueryTaskUtils . buildQuerySpec ( documentType , terms ) ; Operation result = postToBroadcastQueryService ( spec ) ; Set < String > documentLinks = QueryTaskUtils . getBroadcastQueryDocumentLinks ( result ) ; if ( documentLinks . size ( ) <= _NUM ) { return ImmutableList . of ( ) ; } return ImmutableList . copyOf ( documentLinks ) ; }
@ Override public < T extends ServiceDocument > List < String > queryDocumentsForLinks ( Class < T > documentType , ImmutableMap < String , String > terms ) throws BadRequestException , DocumentNotFoundException , TimeoutException , InterruptedException { checkNotNull ( documentType , STRING ) ; QueryTask . QuerySpecification spec = QueryTaskUtils . buildQuerySpec ( documentType , terms ) ; Operation result = postToBroadcastQueryService ( spec ) ; Set < String > documentLinks = QueryTaskUtils . getBroadcastQueryDocumentLinks ( result ) ; if ( documentLinks . size ( ) <= _NUM ) { return ImmutableList . of ( ) ; } return ImmutableList . copyOf ( documentLinks ) ; }
@ Override public < T extends ServiceDocument > List < String > queryDocumentsForLinks ( Class < T > documentType , ImmutableMap < String , String > terms ) throws BadRequestException , DocumentNotFoundException , TimeoutException , InterruptedException { checkNotNull ( documentType , STRING ) ; QueryTask . QuerySpecification spec = QueryTaskUtils . buildQuerySpec ( documentType , terms ) ; Operation result = postToBroadcastQueryService ( spec ) ; Set < String > documentLinks = QueryTaskUtils . getBroadcastQueryDocumentLinks ( result ) ; if ( documentLinks . size ( ) <= _NUM ) { return ImmutableList . of ( ) ; } return ImmutableList . copyOf ( documentLinks ) ; }
@ Override public < T extends ServiceDocument > List < String > queryDocumentsForLinks ( Class < T > documentType , ImmutableMap < String , String > terms ) throws BadRequestException , DocumentNotFoundException , TimeoutException , InterruptedException { checkNotNull ( documentType , STRING ) ; QueryTask . QuerySpecification spec = QueryTaskUtils . buildQuerySpec ( documentType , terms ) ; Operation result = postToBroadcastQueryService ( spec ) ; Set < String > documentLinks = QueryTaskUtils . getBroadcastQueryDocumentLinks ( result ) ; if ( documentLinks . size ( ) <= _NUM ) { return ImmutableList . of ( ) ; } return ImmutableList . copyOf ( documentLinks ) ; }
@ Override public < T extends ServiceDocument > List < String > queryDocumentsForLinks ( Class < T > documentType , ImmutableMap < String , String > terms ) throws BadRequestException , DocumentNotFoundException , TimeoutException , InterruptedException { checkNotNull ( documentType , STRING ) ; QueryTask . QuerySpecification spec = QueryTaskUtils . buildQuerySpec ( documentType , terms ) ; Operation result = postToBroadcastQueryService ( spec ) ; Set < String > documentLinks = QueryTaskUtils . getBroadcastQueryDocumentLinks ( result ) ; if ( documentLinks . size ( ) <= _NUM ) { return ImmutableList . of ( ) ; } return ImmutableList . copyOf ( documentLinks ) ; }
public CProcessListPanel ( final ProcessList processList ) { super ( new BorderLayout ( ) ) ; m_processList = processList ; final CProcessListModel model = new CProcessListModel ( processList ) ; m_sorter = new TableRowSorter < CProcessListModel > ( model ) ; m_table = new JTable ( model ) ; m_table . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; m_table . setRowSorter ( m_sorter ) ; final JScrollPane scrollPane = new JScrollPane ( m_table ) ; scrollPane . setBorder ( new TitledBorder ( STRING ) ) ; add ( scrollPane ) ; setPreferredSize ( new Dimension ( _NUM , _NUM ) ) ; }
public boolean offer ( E e , long timeout , TimeUnit unit ) throws InterruptedException { if ( e == null ) throw new NullPointerException ( ) ; long nanos = unit . toNanos ( timeout ) ; int c = - _NUM ; final ReentrantLock putLock = this . putLock ; final AtomicInteger count = this . count ; putLock . lockInterruptibly ( ) ; try { while ( count . get ( ) == capacity ) { if ( nanos <= _NUM ) return _BOOL ; nanos = notFull . awaitNanos ( nanos ) ; } enqueue ( new Node < E > ( e ) ) ; c = count . getAndIncrement ( ) ; if ( c + _NUM < capacity ) notFull . signal ( ) ; } finally { putLock . unlock ( ) ; } if ( c == _NUM ) signalNotEmpty ( ) ; return _BOOL ; }
public boolean offer ( E e , long timeout , TimeUnit unit ) throws InterruptedException { if ( e == null ) throw new NullPointerException ( ) ; long nanos = unit . toNanos ( timeout ) ; int c = - _NUM ; final ReentrantLock putLock = this . putLock ; final AtomicInteger count = this . count ; putLock . lockInterruptibly ( ) ; try { while ( count . get ( ) == capacity ) { if ( nanos <= _NUM ) return _BOOL ; nanos = notFull . awaitNanos ( nanos ) ; } enqueue ( new Node < E > ( e ) ) ; c = count . getAndIncrement ( ) ; if ( c + _NUM < capacity ) notFull . signal ( ) ; } finally { putLock . unlock ( ) ; } if ( c == _NUM ) signalNotEmpty ( ) ; return _BOOL ; }
public void updateComponentTreeUI ( ) { SwingUtilities . updateComponentTreeUI ( dialog ) ; }
public void init ( ) { MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; try { mbs . registerMBean ( this , new ObjectName ( MBEAN_NAME ) ) ; } catch ( JMException e ) { throw new RuntimeException ( e ) ; } }
public void init ( ) { MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; try { mbs . registerMBean ( this , new ObjectName ( MBEAN_NAME ) ) ; } catch ( JMException e ) { throw new RuntimeException ( e ) ; } }
public void init ( ) { MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; try { mbs . registerMBean ( this , new ObjectName ( MBEAN_NAME ) ) ; } catch ( JMException e ) { throw new RuntimeException ( e ) ; } }
public IgniteSpiMultiException ( String msg , @ Nullable Throwable cause , @ Nullable Collection < Throwable > nestedCauses ) { super ( msg , cause ) ; if ( nestedCauses != null ) causes . addAll ( nestedCauses ) ; }
private void saveSPsoapMni ( String mnisoapLocation , String mnirespLoaction , List manageNameIdList , com . sun . identity . saml2 . jaxb . metadata . ObjectFactory objFact ) throws JAXBException { if ( mnisoapLocation != null && mnisoapLocation . length ( ) > _NUM ) { ManageNameIDServiceElement slsElemSoap = objFact . createManageNameIDServiceElement ( ) ; slsElemSoap . setBinding ( soapBinding ) ; slsElemSoap . setLocation ( mnisoapLocation ) ; slsElemSoap . setResponseLocation ( mnirespLoaction ) ; manageNameIdList . add ( slsElemSoap ) ; } }
private static void addDefaultProfile ( SpringApplication app , SimpleCommandLinePropertySource source ) { if ( ! source . containsProperty ( STRING ) ) { app . setAdditionalProfiles ( Constants . SPRING_PROFILE_DEVELOPMENT ) ; } }
@ Override public void acceptDataPoint ( ChartEvent e ) { if ( e . getReset ( ) ) { m_xCount = _NUM ; m_max = _NUM ; m_min = _NUM ; } if ( m_outputFrame != null ) { boolean refresh = _BOOL ; if ( e . getLegendText ( ) != null & e . getLegendText ( ) != m_legendText ) { m_legendText = e . getLegendText ( ) ; refresh = _BOOL ; } if ( e . getMin ( ) != m_min || e . getMax ( ) != m_max ) { m_oldMax = m_max ; m_oldMin = m_min ; m_max = e . getMax ( ) ; m_min = e . getMin ( ) ; refresh = _BOOL ; m_yScaleUpdate = _BOOL ; } if ( refresh ) { m_legendPanel . repaint ( ) ; m_scalePanel . repaint ( ) ; } acceptDataPoint ( e . getDataPoint ( ) ) ; } m_xCount ++ ; }
public void addEdgeConnector ( ) { numEdgeConnectors ++ ; String name = STRING ; boolean duplicate = _BOOL ; while ( duplicate ) { name = STRING + numEdgeConnectors ; if ( finder . findPositionablePointByName ( name ) == null ) { duplicate = _BOOL ; } if ( duplicate ) { numEdgeConnectors ++ ; } } PositionablePoint o = new PositionablePoint ( name , PositionablePoint . EDGE_CONNECTOR , currentPoint , this ) ; pointList . add ( o ) ; setDirty ( _BOOL ) ; }
private static String wordShapeChris2 ( String s , boolean omitIfInBoundary , Collection < String > knownLCWords ) { int len = s . length ( ) ; if ( len <= BOUNDARY_SIZE * _NUM ) { return wordShapeChris2Short ( s , len , knownLCWords ) ; } else { return wordShapeChris2Long ( s , omitIfInBoundary , len , knownLCWords ) ; } }
private static String wordShapeChris2 ( String s , boolean omitIfInBoundary , Collection < String > knownLCWords ) { int len = s . length ( ) ; if ( len <= BOUNDARY_SIZE * _NUM ) { return wordShapeChris2Short ( s , len , knownLCWords ) ; } else { return wordShapeChris2Long ( s , omitIfInBoundary , len , knownLCWords ) ; } }
private static String wordShapeChris2 ( String s , boolean omitIfInBoundary , Collection < String > knownLCWords ) { int len = s . length ( ) ; if ( len <= BOUNDARY_SIZE * _NUM ) { return wordShapeChris2Short ( s , len , knownLCWords ) ; } else { return wordShapeChris2Long ( s , omitIfInBoundary , len , knownLCWords ) ; } }
private static String wordShapeChris2 ( String s , boolean omitIfInBoundary , Collection < String > knownLCWords ) { int len = s . length ( ) ; if ( len <= BOUNDARY_SIZE * _NUM ) { return wordShapeChris2Short ( s , len , knownLCWords ) ; } else { return wordShapeChris2Long ( s , omitIfInBoundary , len , knownLCWords ) ; } }
private static String wordShapeChris2 ( String s , boolean omitIfInBoundary , Collection < String > knownLCWords ) { int len = s . length ( ) ; if ( len <= BOUNDARY_SIZE * _NUM ) { return wordShapeChris2Short ( s , len , knownLCWords ) ; } else { return wordShapeChris2Long ( s , omitIfInBoundary , len , knownLCWords ) ; } }
protected void logAssignNode ( GraphNode node , int level , int offset ) { logger . info ( STRING + level + STRING + offset + STRING + node ) ; }
protected void logAssignNode ( GraphNode node , int level , int offset ) { logger . info ( STRING + level + STRING + offset + STRING + node ) ; }
@ Deprecated public static void runFinalizersOnExit ( boolean run ) { finalizeOnExit = run ; }
@ Deprecated public static void runFinalizersOnExit ( boolean run ) { finalizeOnExit = run ; }
@ Deprecated public static void runFinalizersOnExit ( boolean run ) { finalizeOnExit = run ; }
@ Deprecated public static void runFinalizersOnExit ( boolean run ) { finalizeOnExit = run ; }
@ Deprecated public static void runFinalizersOnExit ( boolean run ) { finalizeOnExit = run ; }
public boolean remove ( Predicate p ) { if ( m_clauses . remove ( p ) ) { fireExpressionChange ( ) ; return _BOOL ; } else { return _BOOL ; } }
public DoubleArray resize ( DoubleArray array , long size ) { if ( array instanceof BigDoubleArray ) { return resizeInPlace ( ( BigDoubleArray ) array , size ) ; } else { AbstractArray arr = ( AbstractArray ) array ; final DoubleArray newArray = newDoubleArray ( size , arr . clearOnResize ) ; for ( long i = _NUM , end = Math . min ( size , array . size ( ) ) ; i < end ; ++ i ) { newArray . set ( i , array . get ( i ) ) ; } array . close ( ) ; return newArray ; } }
public static List < User > from ( Cursor c ) { List < User > users = null ; int count = c . getCount ( ) ; if ( count > _NUM ) { users = new ArrayList < > ( count ) ; while ( c . moveToNext ( ) ) { User user = new User ( ) ; Syncing . from ( c , user ) ; int col = c . getColumnIndex ( EMAIL_HASH ) ; if ( col >= _NUM ) { user . emailHash = c . getString ( col ) ; } col = c . getColumnIndex ( FOLLOWING ) ; if ( col >= _NUM ) { user . isFollowing = c . getInt ( col ) == _NUM ; } users . add ( user ) ; } } c . close ( ) ; return users ; }
public void updateYawAndPitch ( ) { long timeNow = System . currentTimeMillis ( ) ; long deltaTime = timeNow - this . lastAngularUpdateTime ; this . lastAngularUpdateTime = timeNow ; double overclockScale = _NUM / ( double ) TimeHelper . serverTickLength ; double deltaYaw = this . yawScale * overclockScale * this . maxAngularVelocityDegreesPerSecond * ( deltaTime / _NUM ) ; double deltaPitch = this . pitchScale * overclockScale * this . maxAngularVelocityDegreesPerSecond * ( deltaTime / _NUM ) ; mYaw += deltaYaw ; mCameraPitch += deltaPitch ; mCameraPitch = ( mCameraPitch < - _NUM ) ? - _NUM : ( mCameraPitch > _NUM ? _NUM : mCameraPitch ) ; }
private static void drawLeftTab ( int x , int y , int w , int h , Graphics2D g2 , ColorUIResource color ) { double rTop = RapidLookAndFeel . CORNER_TAB_RADIUS * _NUM ; g2 . setColor ( color ) ; g2 . fill ( createLeftTabShape ( x + _NUM , y + _NUM , w - _NUM , h , rTop , _BOOL ) ) ; g2 . setColor ( Colors . TAB_BORDER ) ; g2 . draw ( createLeftTabShape ( x , y , w - _NUM , h , rTop , _BOOL ) ) ; }
private static void drawLeftTab ( int x , int y , int w , int h , Graphics2D g2 , ColorUIResource color ) { double rTop = RapidLookAndFeel . CORNER_TAB_RADIUS * _NUM ; g2 . setColor ( color ) ; g2 . fill ( createLeftTabShape ( x + _NUM , y + _NUM , w - _NUM , h , rTop , _BOOL ) ) ; g2 . setColor ( Colors . TAB_BORDER ) ; g2 . draw ( createLeftTabShape ( x , y , w - _NUM , h , rTop , _BOOL ) ) ; }
private static void drawLeftTab ( int x , int y , int w , int h , Graphics2D g2 , ColorUIResource color ) { double rTop = RapidLookAndFeel . CORNER_TAB_RADIUS * _NUM ; g2 . setColor ( color ) ; g2 . fill ( createLeftTabShape ( x + _NUM , y + _NUM , w - _NUM , h , rTop , _BOOL ) ) ; g2 . setColor ( Colors . TAB_BORDER ) ; g2 . draw ( createLeftTabShape ( x , y , w - _NUM , h , rTop , _BOOL ) ) ; }
public void addSlide ( @ NonNull Fragment fragment ) { fragments . add ( fragment ) ; if ( isWizardMode ) { setOffScreenPageLimit ( fragments . size ( ) ) ; } mPagerAdapter . notifyDataSetChanged ( ) ; }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { super . writeExternal ( out ) ; int k_max = knnDistances . length ; out . writeInt ( k_max ) ; for ( int i = _NUM ; i < k_max ; i ++ ) { out . writeDouble ( knnDistances [ i ] ) ; } }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { super . writeExternal ( out ) ; int k_max = knnDistances . length ; out . writeInt ( k_max ) ; for ( int i = _NUM ; i < k_max ; i ++ ) { out . writeDouble ( knnDistances [ i ] ) ; } }
@ Override public int length ( ) { return data . length / ( format . getFrameSize ( ) * _NUM ) ; }
public static BooleanGlassFunction serializableInstance ( ) { return new BooleanGlassFunction ( BasicLagGraph . serializableInstance ( ) ) ; }
public static BooleanGlassFunction serializableInstance ( ) { return new BooleanGlassFunction ( BasicLagGraph . serializableInstance ( ) ) ; }
@ NoWarning ( STRING ) int fp1 ( int level ) { Object x = null ; if ( level > _NUM ) x = new Object ( ) ; if ( level > _NUM ) return x . hashCode ( ) ; return _NUM ; }
public boolean memoryIsLow ( ) { m_MemoryUsage = m_MemoryMXBean . getHeapMemoryUsage ( ) ; if ( isEnabled ( ) ) { long lowThreshold = ( long ) ( _NUM * m_MemoryUsage . getMax ( ) ) ; if ( lowThreshold < LOW_MEMORY_MINIMUM ) { lowThreshold = LOW_MEMORY_MINIMUM ; } long avail = m_MemoryUsage . getMax ( ) - m_MemoryUsage . getUsed ( ) ; return ( avail < lowThreshold ) ; } else { return _BOOL ; } }
public static void objectStringNonRecursive ( @ Unretained Object obj , StringBuilder sb ) { if ( obj instanceof Object [ ] ) { sb . append ( STRING ) ; boolean first = _BOOL ; for ( Object o : ( Object [ ] ) obj ) { if ( ! first ) { sb . append ( STRING ) ; sb . append ( o ) ; } else { first = _BOOL ; objectStringWithBytes ( o , sb ) ; } } sb . append ( STRING ) ; } else { objectStringWithBytes ( obj , sb ) ; } }
public int processor ( ) { return Integer . parseInt ( fields [ _NUM ] ) ; }
public int processor ( ) { return Integer . parseInt ( fields [ _NUM ] ) ; }
private final String stdToLocal ( String name ) { return name . replace ( STRING , java . io . File . separatorChar ) ; }
public boolean mouseMoved ( MouseEvent e ) { EsriGraphicList list = getEsriGraphicList ( ) ; boolean ret = _BOOL ; if ( list != null ) { OMGraphic omg = list . findClosest ( e . getX ( ) , e . getY ( ) , _NUM ) ; if ( omg != null ) { int index ; Integer I = ( ( Integer ) omg . getAttribute ( SHAPE_INDEX_ATTRIBUTE ) ) ; if ( I != null ) { index = I . intValue ( ) ; } else { index = list . indexOf ( omg ) ; } if ( parentLayer == null ) { Component comp = getComponent ( ) ; if ( comp instanceof Layer ) { parentLayer = ( Layer ) comp ; } } if ( parentLayer != null ) { parentLayer . fireRequestToolTip ( getDescription ( index ) ) ; } ret = _BOOL ; } else if ( parentLayer != null ) { parentLayer . fireHideToolTip ( ) ; } } return ret ; }
public static void append ( Path self , Object text , String charset ) throws IOException { append ( self , text , charset , _BOOL ) ; }
public static void append ( Path self , Object text , String charset ) throws IOException { append ( self , text , charset , _BOOL ) ; }
void stopTask ( String processName ) { trace ( STRING + processName ) ; Process p = tasks . remove ( processName ) ; if ( p == null ) { return ; } p . destroy ( ) ; }
private void drawUnit ( final Graphics2D graphics , final Image image , final Point placementPoint2 , final Rectangle bounds ) { graphics . drawImage ( image , placementPoint . x - bounds . x , placementPoint . y - bounds . y , null ) ; }
private void drawUnit ( final Graphics2D graphics , final Image image , final Point placementPoint2 , final Rectangle bounds ) { graphics . drawImage ( image , placementPoint . x - bounds . x , placementPoint . y - bounds . y , null ) ; }
public void trimToSize ( ) { if ( size < array . length ) { int [ ] olddata = array ; array = new int [ size ] ; System . arraycopy ( olddata , _NUM , array , _NUM , size ) ; } }
public void trimToSize ( ) { if ( size < array . length ) { int [ ] olddata = array ; array = new int [ size ] ; System . arraycopy ( olddata , _NUM , array , _NUM , size ) ; } }
public void trimToSize ( ) { if ( size < array . length ) { int [ ] olddata = array ; array = new int [ size ] ; System . arraycopy ( olddata , _NUM , array , _NUM , size ) ; } }
public void trimToSize ( ) { if ( size < array . length ) { int [ ] olddata = array ; array = new int [ size ] ; System . arraycopy ( olddata , _NUM , array , _NUM , size ) ; } }
public void trimToSize ( ) { if ( size < array . length ) { int [ ] olddata = array ; array = new int [ size ] ; System . arraycopy ( olddata , _NUM , array , _NUM , size ) ; } }
public void trimToSize ( ) { if ( size < array . length ) { int [ ] olddata = array ; array = new int [ size ] ; System . arraycopy ( olddata , _NUM , array , _NUM , size ) ; } }
public static String computeDigest ( URL url , String algorithm ) throws IOException , NoSuchAlgorithmException { return computeDigest ( url . openStream ( ) , algorithm ) ; }
public ScaleIOSnapshotVolumeResponse snapshotVolume ( String volId , String snapshotName , String systemId ) throws Exception { String uri = ScaleIOConstants . getSnapshotVolumesURI ( systemId ) ; ScaleIOSnapshotVolumes spVol = new ScaleIOSnapshotVolumes ( ) ; spVol . addSnapshot ( volId , snapshotName ) ; ClientResponse response = post ( URI . create ( uri ) , getJsonForEntity ( spVol ) ) ; return getResponseObject ( ScaleIOSnapshotVolumeResponse . class , response ) ; }
public static Enum castToEnum ( Object object , Class < ? extends Enum > type ) { if ( object == null ) return null ; if ( type . isInstance ( object ) ) return ( Enum ) object ; if ( object instanceof String || object instanceof GString ) { return Enum . valueOf ( type , object . toString ( ) ) ; } throw new GroovyCastException ( object , type ) ; }
public static Enum castToEnum ( Object object , Class < ? extends Enum > type ) { if ( object == null ) return null ; if ( type . isInstance ( object ) ) return ( Enum ) object ; if ( object instanceof String || object instanceof GString ) { return Enum . valueOf ( type , object . toString ( ) ) ; } throw new GroovyCastException ( object , type ) ; }
public static Enum castToEnum ( Object object , Class < ? extends Enum > type ) { if ( object == null ) return null ; if ( type . isInstance ( object ) ) return ( Enum ) object ; if ( object instanceof String || object instanceof GString ) { return Enum . valueOf ( type , object . toString ( ) ) ; } throw new GroovyCastException ( object , type ) ; }
protected String makeSuffix ( String path , String contentType ) { String suffix = contentType != null ? WWIO . makeSuffixForMimeType ( contentType ) : null ; String existingSuffix = WWIO . getSuffix ( path ) ; if ( existingSuffix != null && existingSuffix . equalsIgnoreCase ( STRING ) ) existingSuffix = STRING ; if ( suffix != null && ( existingSuffix == null || ! existingSuffix . equalsIgnoreCase ( suffix . substring ( _NUM ) ) ) ) return suffix ; else return null ; }
protected String makeSuffix ( String path , String contentType ) { String suffix = contentType != null ? WWIO . makeSuffixForMimeType ( contentType ) : null ; String existingSuffix = WWIO . getSuffix ( path ) ; if ( existingSuffix != null && existingSuffix . equalsIgnoreCase ( STRING ) ) existingSuffix = STRING ; if ( suffix != null && ( existingSuffix == null || ! existingSuffix . equalsIgnoreCase ( suffix . substring ( _NUM ) ) ) ) return suffix ; else return null ; }
protected String makeSuffix ( String path , String contentType ) { String suffix = contentType != null ? WWIO . makeSuffixForMimeType ( contentType ) : null ; String existingSuffix = WWIO . getSuffix ( path ) ; if ( existingSuffix != null && existingSuffix . equalsIgnoreCase ( STRING ) ) existingSuffix = STRING ; if ( suffix != null && ( existingSuffix == null || ! existingSuffix . equalsIgnoreCase ( suffix . substring ( _NUM ) ) ) ) return suffix ; else return null ; }
protected String makeSuffix ( String path , String contentType ) { String suffix = contentType != null ? WWIO . makeSuffixForMimeType ( contentType ) : null ; String existingSuffix = WWIO . getSuffix ( path ) ; if ( existingSuffix != null && existingSuffix . equalsIgnoreCase ( STRING ) ) existingSuffix = STRING ; if ( suffix != null && ( existingSuffix == null || ! existingSuffix . equalsIgnoreCase ( suffix . substring ( _NUM ) ) ) ) return suffix ; else return null ; }
@ RequestMapping ( value = STRING , method = { RequestMethod . GET } ) @ ResponseBody private static List < String > showHiveDatabases ( ) throws IOException { IHiveClient hiveClient = HiveClientFactory . getHiveClient ( ) ; List < String > results = null ; try { results = hiveClient . getHiveDbNames ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new IOException ( e ) ; } return results ; }
@ Override public void removeAlarm ( final Long alarmId , final ConfigurationElementReport alarmReport ) { try { AlarmCacheObject alarm = ( AlarmCacheObject ) alarmCache . getCopy ( alarmId ) ; alarmConfigTransacted . doRemoveAlarm ( alarmId , alarmReport ) ; alarmCache . remove ( alarmId ) ; alarm . setState ( AlarmCondition . TERMINATE ) ; alarm . setInfo ( STRING ) ; alarm . setTimestamp ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; alarmCache . notifyListenersOfUpdate ( alarm ) ; } catch ( CacheElementNotFoundException e ) { alarmReport . setWarning ( STRING + alarmId + STRING ) ; } }
@ Override public void removeAlarm ( final Long alarmId , final ConfigurationElementReport alarmReport ) { try { AlarmCacheObject alarm = ( AlarmCacheObject ) alarmCache . getCopy ( alarmId ) ; alarmConfigTransacted . doRemoveAlarm ( alarmId , alarmReport ) ; alarmCache . remove ( alarmId ) ; alarm . setState ( AlarmCondition . TERMINATE ) ; alarm . setInfo ( STRING ) ; alarm . setTimestamp ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; alarmCache . notifyListenersOfUpdate ( alarm ) ; } catch ( CacheElementNotFoundException e ) { alarmReport . setWarning ( STRING + alarmId + STRING ) ; } }
@ Override public void removeAlarm ( final Long alarmId , final ConfigurationElementReport alarmReport ) { try { AlarmCacheObject alarm = ( AlarmCacheObject ) alarmCache . getCopy ( alarmId ) ; alarmConfigTransacted . doRemoveAlarm ( alarmId , alarmReport ) ; alarmCache . remove ( alarmId ) ; alarm . setState ( AlarmCondition . TERMINATE ) ; alarm . setInfo ( STRING ) ; alarm . setTimestamp ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; alarmCache . notifyListenersOfUpdate ( alarm ) ; } catch ( CacheElementNotFoundException e ) { alarmReport . setWarning ( STRING + alarmId + STRING ) ; } }
@ Override public void removeAlarm ( final Long alarmId , final ConfigurationElementReport alarmReport ) { try { AlarmCacheObject alarm = ( AlarmCacheObject ) alarmCache . getCopy ( alarmId ) ; alarmConfigTransacted . doRemoveAlarm ( alarmId , alarmReport ) ; alarmCache . remove ( alarmId ) ; alarm . setState ( AlarmCondition . TERMINATE ) ; alarm . setInfo ( STRING ) ; alarm . setTimestamp ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; alarmCache . notifyListenersOfUpdate ( alarm ) ; } catch ( CacheElementNotFoundException e ) { alarmReport . setWarning ( STRING + alarmId + STRING ) ; } }
@ Override public void removeAlarm ( final Long alarmId , final ConfigurationElementReport alarmReport ) { try { AlarmCacheObject alarm = ( AlarmCacheObject ) alarmCache . getCopy ( alarmId ) ; alarmConfigTransacted . doRemoveAlarm ( alarmId , alarmReport ) ; alarmCache . remove ( alarmId ) ; alarm . setState ( AlarmCondition . TERMINATE ) ; alarm . setInfo ( STRING ) ; alarm . setTimestamp ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; alarmCache . notifyListenersOfUpdate ( alarm ) ; } catch ( CacheElementNotFoundException e ) { alarmReport . setWarning ( STRING + alarmId + STRING ) ; } }
@ Override public void removeAlarm ( final Long alarmId , final ConfigurationElementReport alarmReport ) { try { AlarmCacheObject alarm = ( AlarmCacheObject ) alarmCache . getCopy ( alarmId ) ; alarmConfigTransacted . doRemoveAlarm ( alarmId , alarmReport ) ; alarmCache . remove ( alarmId ) ; alarm . setState ( AlarmCondition . TERMINATE ) ; alarm . setInfo ( STRING ) ; alarm . setTimestamp ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; alarmCache . notifyListenersOfUpdate ( alarm ) ; } catch ( CacheElementNotFoundException e ) { alarmReport . setWarning ( STRING + alarmId + STRING ) ; } }
@ Override public void removeAlarm ( final Long alarmId , final ConfigurationElementReport alarmReport ) { try { AlarmCacheObject alarm = ( AlarmCacheObject ) alarmCache . getCopy ( alarmId ) ; alarmConfigTransacted . doRemoveAlarm ( alarmId , alarmReport ) ; alarmCache . remove ( alarmId ) ; alarm . setState ( AlarmCondition . TERMINATE ) ; alarm . setInfo ( STRING ) ; alarm . setTimestamp ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; alarmCache . notifyListenersOfUpdate ( alarm ) ; } catch ( CacheElementNotFoundException e ) { alarmReport . setWarning ( STRING + alarmId + STRING ) ; } }
public boolean hasFile ( InputFile inputFile ) { return patchPositionMappingByFile . containsKey ( getPath ( inputFile ) ) ; }
public Segment ( short startCode , short endCode , boolean hasMap ) { this . endCode = ( _NUM & endCode ) ; this . startCode = ( _NUM & startCode ) ; this . hasMap = hasMap ; }
public static TaskBuilder start ( BasePlugin dioritePlugin , Runnable runnable ) { return new TaskBuilder ( dioritePlugin , runnable ) ; }
public static Map appendMapToMap ( Map mapToAdd , Map toMap ) { if ( ( mapToAdd != null ) && ( toMap != null ) ) { Set keySet = mapToAdd . keySet ( ) ; Iterator keyIter = keySet . iterator ( ) ; while ( keyIter . hasNext ( ) ) { String key = ( String ) keyIter . next ( ) ; Set values = ( Set ) mapToAdd . get ( key ) ; appendElementToMap ( key , values , toMap ) ; } } return toMap ; }
private static int level ( long position ) { return _NUM + Long . numberOfTrailingZeros ( position ) ; }
private static int level ( long position ) { return _NUM + Long . numberOfTrailingZeros ( position ) ; }
public static void cancel ( ) { if ( fetchExe != null ) { fetchExe . shutdownNow ( ) ; fetchExe = null ; } BitmapAjaxCallback . clearTasks ( ) ; }
public boolean required ( ) { return _parameterMetadata . contains ( Metadata . REQUIRED ) ; }
protected void prepareDataSet ( ) { dataSet1 = Arrays . asList ( new String [ ] { STRING , STRING , STRING } ) ; dataSet2 = Arrays . asList ( new String [ ] { STRING , STRING , STRING } ) ; dataSet3 = Arrays . asList ( new String [ ] { STRING , STRING , STRING , STRING } ) ; }
public void sort ( Comparator < FragmentData > comparator ) { checkTransaction ( ) ; saveOldOrder ( ) ; if ( comparator == null ) { Collections . sort ( mFragmentDatas ) ; } else { Collections . sort ( this . mFragmentDatas , comparator ) ; } checkPositionChange ( ) ; }
public ArithmeticCondition ( String cond ) { String value ; int multiplier = _NUM ; if ( cond . length ( ) < _NUM ) { throw new SettingsError ( STRING + cond + STRING ) ; } operator = cond . charAt ( _NUM ) ; value = cond . substring ( _NUM ) ; if ( value . endsWith ( STRING ) ) { multiplier = _NUM ; } else if ( value . endsWith ( STRING ) ) { multiplier = _NUM ; } if ( multiplier > _NUM ) { value = value . substring ( _NUM , value . length ( ) - _NUM ) ; } if ( VALID_OPERATORS . indexOf ( operator ) == - _NUM ) { throw new SettingsError ( STRING + cond + STRING + VALID_OPERATORS ) ; } try { number = Double . parseDouble ( value ) ; } catch ( NumberFormatException e ) { throw new SettingsError ( STRING + cond + STRING ) ; } number *= multiplier ; }
private long retrieveRowCount ( Database conn , Table table ) throws SQLException { return retrieveRowCount ( conn , table , - _NUM , - _NUM ) ; }
private List < Entry > reduceWithDouglasPeuker ( List < Entry > entries , double epsilon ) { if ( epsilon <= _NUM || entries . size ( ) < _NUM ) { return entries ; } keep [ _NUM ] = _BOOL ; keep [ entries . size ( ) - _NUM ] = _BOOL ; algorithmDouglasPeucker ( entries , epsilon , _NUM , entries . size ( ) - _NUM ) ; List < Entry > reducedEntries = new ArrayList < > ( ) ; for ( int i = _NUM ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { Entry curEntry = entries . get ( i ) ; reducedEntries . add ( new Entry ( curEntry . getVal ( ) , curEntry . getXIndex ( ) ) ) ; } } return reducedEntries ; }
private List < Entry > reduceWithDouglasPeuker ( List < Entry > entries , double epsilon ) { if ( epsilon <= _NUM || entries . size ( ) < _NUM ) { return entries ; } keep [ _NUM ] = _BOOL ; keep [ entries . size ( ) - _NUM ] = _BOOL ; algorithmDouglasPeucker ( entries , epsilon , _NUM , entries . size ( ) - _NUM ) ; List < Entry > reducedEntries = new ArrayList < > ( ) ; for ( int i = _NUM ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { Entry curEntry = entries . get ( i ) ; reducedEntries . add ( new Entry ( curEntry . getVal ( ) , curEntry . getXIndex ( ) ) ) ; } } return reducedEntries ; }
private void addLenient ( String fieldName , String value ) { namesAndValues . add ( fieldName ) ; namesAndValues . add ( value . trim ( ) ) ; }
private void addLenient ( String fieldName , String value ) { namesAndValues . add ( fieldName ) ; namesAndValues . add ( value . trim ( ) ) ; }
private void renderTexture ( Texture texture , double centerX , double centerY ) { TextureCoords tc = texture . getImageTexCoords ( ) ; float tx1 = tc . left ( ) ; float ty1 = tc . top ( ) ; float tx2 = tc . right ( ) ; float ty2 = tc . bottom ( ) ; float halfWidth = quarterValue ( texture . getWidth ( ) ) ; float halfHeight = quarterValue ( texture . getHeight ( ) ) ; GL2 gl = scene . gl ; texture . bind ( gl ) ; texture . enable ( gl ) ; Color foreground = scene . getForegroundColor ( ) ; gl . glColor4f ( foreground . getRed ( ) / _NUM , foreground . getGreen ( ) / _NUM , foreground . getBlue ( ) / _NUM , foreground . getAlpha ( ) / _NUM ) ; gl . glPushMatrix ( ) ; float [ ] translate = GLScene . P ( ( float ) centerX , ( float ) centerY ) ; gl . glTranslatef ( translate [ _NUM ] , translate [ _NUM ] , translate [ _NUM ] ) ; gl . glBegin ( GL2 . GL_QUADS ) ; gl . glTexCoord2f ( tx1 , ty1 ) ; GLScene . V ( gl , - halfWidth , halfHeight ) ; gl . glTexCoord2f ( tx2 , ty1 ) ; GLScene . V ( gl , halfWidth , halfHeight ) ; gl . glTexCoord2f ( tx2 , ty2 ) ; GLScene . V ( gl , halfWidth , - halfHeight ) ; gl . glTexCoord2f ( tx1 , ty2 ) ; GLScene . V ( gl , - halfWidth , - halfHeight ) ; gl . glEnd ( ) ; gl . glPopMatrix ( ) ; texture . disable ( gl ) ; }
public static Short toShort ( String str ) throws PageException { return Short . valueOf ( toShortValue ( str ) ) ; }
public static Short toShort ( String str ) throws PageException { return Short . valueOf ( toShortValue ( str ) ) ; }
public void select ( OMGraphicList list ) { if ( list != null && ! list . isEmpty ( ) ) { OMGraphic omg = list . getOMGraphicAt ( _NUM ) ; DrawingTool dt = getDrawingTool ( ) ; if ( dt != null && dt . canEdit ( omg . getClass ( ) ) ) { dt . setBehaviorMask ( OMDrawingTool . QUICK_CHANGE_BEHAVIOR_MASK ) ; if ( dt . edit ( omg , this ) == null ) { fireRequestInfoLine ( STRING ) ; } } } }
public void select ( OMGraphicList list ) { if ( list != null && ! list . isEmpty ( ) ) { OMGraphic omg = list . getOMGraphicAt ( _NUM ) ; DrawingTool dt = getDrawingTool ( ) ; if ( dt != null && dt . canEdit ( omg . getClass ( ) ) ) { dt . setBehaviorMask ( OMDrawingTool . QUICK_CHANGE_BEHAVIOR_MASK ) ; if ( dt . edit ( omg , this ) == null ) { fireRequestInfoLine ( STRING ) ; } } } }
@ Override protected void addEventListener ( NodeImpl node , String type , EventListener listener , boolean useCapture ) { if ( type == null || type . length ( ) == _NUM || listener == null ) return ; removeEventListener ( node , type , listener , useCapture ) ; Vector nodeListeners = getEventListeners ( node ) ; if ( nodeListeners == null ) { nodeListeners = new Vector ( ) ; setEventListeners ( node , nodeListeners ) ; } nodeListeners . addElement ( new LEntry ( type , listener , useCapture ) ) ; LCount lc = LCount . lookup ( type ) ; if ( useCapture ) { ++ lc . captures ; ++ lc . total ; } else { ++ lc . bubbles ; ++ lc . total ; } }
void reset ( ) { if ( version != - _NUM ) { throw new RuntimeException ( STRING ) ; } data . reset ( ) ; }
void reset ( ) { if ( version != - _NUM ) { throw new RuntimeException ( STRING ) ; } data . reset ( ) ; }
void reset ( ) { if ( version != - _NUM ) { throw new RuntimeException ( STRING ) ; } data . reset ( ) ; }
void reset ( ) { if ( version != - _NUM ) { throw new RuntimeException ( STRING ) ; } data . reset ( ) ; }
void reset ( ) { if ( version != - _NUM ) { throw new RuntimeException ( STRING ) ; } data . reset ( ) ; }
public String mailboxUTF7 ( ) throws DecodingException { String mailbox = astring ( ) ; if ( mailbox . equalsIgnoreCase ( ImapConstants . INBOX_NAME ) ) { return ImapConstants . INBOX_NAME ; } else { return mailbox ; } }
public String mailboxUTF7 ( ) throws DecodingException { String mailbox = astring ( ) ; if ( mailbox . equalsIgnoreCase ( ImapConstants . INBOX_NAME ) ) { return ImapConstants . INBOX_NAME ; } else { return mailbox ; } }
public String mailboxUTF7 ( ) throws DecodingException { String mailbox = astring ( ) ; if ( mailbox . equalsIgnoreCase ( ImapConstants . INBOX_NAME ) ) { return ImapConstants . INBOX_NAME ; } else { return mailbox ; } }
public String mailboxUTF7 ( ) throws DecodingException { String mailbox = astring ( ) ; if ( mailbox . equalsIgnoreCase ( ImapConstants . INBOX_NAME ) ) { return ImapConstants . INBOX_NAME ; } else { return mailbox ; } }
public String mailboxUTF7 ( ) throws DecodingException { String mailbox = astring ( ) ; if ( mailbox . equalsIgnoreCase ( ImapConstants . INBOX_NAME ) ) { return ImapConstants . INBOX_NAME ; } else { return mailbox ; } }
public String mailboxUTF7 ( ) throws DecodingException { String mailbox = astring ( ) ; if ( mailbox . equalsIgnoreCase ( ImapConstants . INBOX_NAME ) ) { return ImapConstants . INBOX_NAME ; } else { return mailbox ; } }
public String mailboxUTF7 ( ) throws DecodingException { String mailbox = astring ( ) ; if ( mailbox . equalsIgnoreCase ( ImapConstants . INBOX_NAME ) ) { return ImapConstants . INBOX_NAME ; } else { return mailbox ; } }
@ Override public void keyReleased ( KeyEvent e ) { synchronized ( keyLock ) { keysDown . remove ( e . getKeyCode ( ) ) ; } for ( DrawListener listener : listeners ) listener . keyPressed ( e . getKeyCode ( ) ) ; }
private void createDefaultManagedObject ( ManagedObjectDefinition < ? , ? > d , ManagedObject < ? > child , DefaultManagedObject < ? , ? > dmo ) { for ( PropertyDefinition < ? > pd : d . getAllPropertyDefinitions ( ) ) { setPropertyValues ( child , pd , dmo ) ; } try { child . commit ( ) ; } catch ( ManagedObjectAlreadyExistsException e ) { moaee = e ; } catch ( MissingMandatoryPropertiesException e ) { mmpe = e ; } catch ( ConcurrentModificationException e ) { cme = e ; } catch ( OperationRejectedException e ) { ore = e ; } catch ( LdapException e ) { ere = e ; } }
public static String replace ( String a , String b , String c ) { StringBuffer result = new StringBuffer ( c . length ( ) ) ; int i = _NUM ; int j = c . indexOf ( a ) ; while ( j >= i ) { result . append ( c . substring ( i , j ) ) ; result . append ( b ) ; i = j + a . length ( ) ; j = c . indexOf ( a , i ) ; } result . append ( c . substring ( i , c . length ( ) ) ) ; return result . toString ( ) ; }
public void stop ( ) { for ( Gondola g : gondolas ) { boolean status = g . stop ( ) ; if ( ! status ) { logger . warn ( STRING + g . getHostId ( ) ) ; } } extras . clear ( ) ; members . clear ( ) ; }
public void stop ( ) { for ( Gondola g : gondolas ) { boolean status = g . stop ( ) ; if ( ! status ) { logger . warn ( STRING + g . getHostId ( ) ) ; } } extras . clear ( ) ; members . clear ( ) ; }
public PostgresFullPrunedBlockStore ( NetworkParameters params , int fullStoreDepth , String hostname , String dbName , String username , String password ) throws BlockStoreException { this . params = params ; this . fullStoreDepth = fullStoreDepth ; connectionURL = STRING + hostname + STRING + dbName ; this . username = username ; this . password = password ; conn = new ThreadLocal < Connection > ( ) ; allConnections = new LinkedList < Connection > ( ) ; try { Class . forName ( driver ) ; log . info ( driver + STRING ) ; } catch ( java . lang . ClassNotFoundException e ) { log . error ( STRING , e ) ; } maybeConnect ( ) ; try { if ( ! tableExists ( STRING ) ) createTables ( ) ; initFromDatabase ( ) ; } catch ( SQLException e ) { throw new BlockStoreException ( e ) ; } }
@ SuppressWarnings ( STRING ) protected void writeToTerminal ( byte ... bytes ) throws IOException { synchronized ( terminalOutput ) { terminalOutput . write ( bytes ) ; } }
@ SuppressWarnings ( STRING ) protected void writeToTerminal ( byte ... bytes ) throws IOException { synchronized ( terminalOutput ) { terminalOutput . write ( bytes ) ; } }
public void disconnect ( ) { connected = _BOOL ; synchronized ( connLostWait ) { connLostWait . notify ( ) ; } if ( mqtt != null ) { try { mqtt . disconnect ( ) ; } catch ( Exception ex ) { setTitleText ( STRING ) ; ex . printStackTrace ( ) ; System . exit ( _NUM ) ; } } if ( led . isFlashing ( ) ) { led . setFlash ( ) ; } led . setRed ( ) ; setConnected ( _BOOL ) ; synchronized ( this ) { writeLogln ( STRING ) ; } }
protected void markFirstTime ( Element elem ) { String elemName = elem . getName ( ) ; if ( elemName . equals ( STRING ) ) { seenHtml = _BOOL ; } else if ( elemName . equals ( STRING ) ) { seenHead = _BOOL ; } else if ( elemName . equals ( STRING ) ) { if ( buf . length == _NUM ) { char [ ] newBuf = new char [ _NUM ] ; newBuf [ _NUM ] = buf [ _NUM ] ; buf = newBuf ; } seenBody = _BOOL ; } }
protected void markFirstTime ( Element elem ) { String elemName = elem . getName ( ) ; if ( elemName . equals ( STRING ) ) { seenHtml = _BOOL ; } else if ( elemName . equals ( STRING ) ) { seenHead = _BOOL ; } else if ( elemName . equals ( STRING ) ) { if ( buf . length == _NUM ) { char [ ] newBuf = new char [ _NUM ] ; newBuf [ _NUM ] = buf [ _NUM ] ; buf = newBuf ; } seenBody = _BOOL ; } }
private static void flipCoordinates ( final PhyloTreeView treeView , final SIDE rootSide ) { final PhyloTree tree = treeView . getPhyloTree ( ) ; for ( Node v = tree . getFirstNode ( ) ; v != null ; v = tree . getNextNode ( v ) ) { final Point2D loc = treeView . getLocation ( v ) ; switch ( rootSide ) { case TOP : treeView . setLocation ( v , loc . getY ( ) , loc . getX ( ) ) ; break ; case BOTTOM : treeView . setLocation ( v , loc . getY ( ) , - loc . getX ( ) ) ; break ; case RIGHT : treeView . setLocation ( v , - loc . getX ( ) , loc . getY ( ) ) ; break ; default : case LEFT : break ; } } }
private void mapOldFramesToNew ( int isolateId ) { ArrayList < DStackContext > previousFrames = null ; ArrayList < DStackContext > frames = null ; Map < Long , DValue > previousValues = null ; previousFrames = getIsolateState ( isolateId ) . m_previousFrames ; frames = getIsolateState ( isolateId ) . m_frames ; previousValues = getIsolateState ( isolateId ) . m_previousValues ; int oldSize = previousFrames . size ( ) ; int newSize = frames . size ( ) ; DValue [ ] oldFrames = new DValue [ oldSize ] ; for ( int depth = _NUM ; depth < oldSize ; depth ++ ) { oldFrames [ depth ] = ( DValue ) previousValues . remove ( Value . BASE_ID - depth ) ; } int oldDepth = oldSize - _NUM ; int newDepth = newSize - _NUM ; while ( oldDepth >= _NUM && newDepth >= _NUM ) { DStackContext oldFrame = previousFrames . get ( oldDepth ) ; DStackContext newFrame = frames . get ( newDepth ) ; if ( oldFrame != null && newFrame != null ) { if ( stringsEqual ( oldFrame . getCallSignature ( ) , newFrame . getCallSignature ( ) ) ) { DValue frame = oldFrames [ oldDepth ] ; if ( frame != null ) previousValues . put ( Value . BASE_ID - newDepth , frame ) ; } } oldDepth -- ; newDepth -- ; } }
private void mapOldFramesToNew ( int isolateId ) { ArrayList < DStackContext > previousFrames = null ; ArrayList < DStackContext > frames = null ; Map < Long , DValue > previousValues = null ; previousFrames = getIsolateState ( isolateId ) . m_previousFrames ; frames = getIsolateState ( isolateId ) . m_frames ; previousValues = getIsolateState ( isolateId ) . m_previousValues ; int oldSize = previousFrames . size ( ) ; int newSize = frames . size ( ) ; DValue [ ] oldFrames = new DValue [ oldSize ] ; for ( int depth = _NUM ; depth < oldSize ; depth ++ ) { oldFrames [ depth ] = ( DValue ) previousValues . remove ( Value . BASE_ID - depth ) ; } int oldDepth = oldSize - _NUM ; int newDepth = newSize - _NUM ; while ( oldDepth >= _NUM && newDepth >= _NUM ) { DStackContext oldFrame = previousFrames . get ( oldDepth ) ; DStackContext newFrame = frames . get ( newDepth ) ; if ( oldFrame != null && newFrame != null ) { if ( stringsEqual ( oldFrame . getCallSignature ( ) , newFrame . getCallSignature ( ) ) ) { DValue frame = oldFrames [ oldDepth ] ; if ( frame != null ) previousValues . put ( Value . BASE_ID - newDepth , frame ) ; } } oldDepth -- ; newDepth -- ; } }
private void mapOldFramesToNew ( int isolateId ) { ArrayList < DStackContext > previousFrames = null ; ArrayList < DStackContext > frames = null ; Map < Long , DValue > previousValues = null ; previousFrames = getIsolateState ( isolateId ) . m_previousFrames ; frames = getIsolateState ( isolateId ) . m_frames ; previousValues = getIsolateState ( isolateId ) . m_previousValues ; int oldSize = previousFrames . size ( ) ; int newSize = frames . size ( ) ; DValue [ ] oldFrames = new DValue [ oldSize ] ; for ( int depth = _NUM ; depth < oldSize ; depth ++ ) { oldFrames [ depth ] = ( DValue ) previousValues . remove ( Value . BASE_ID - depth ) ; } int oldDepth = oldSize - _NUM ; int newDepth = newSize - _NUM ; while ( oldDepth >= _NUM && newDepth >= _NUM ) { DStackContext oldFrame = previousFrames . get ( oldDepth ) ; DStackContext newFrame = frames . get ( newDepth ) ; if ( oldFrame != null && newFrame != null ) { if ( stringsEqual ( oldFrame . getCallSignature ( ) , newFrame . getCallSignature ( ) ) ) { DValue frame = oldFrames [ oldDepth ] ; if ( frame != null ) previousValues . put ( Value . BASE_ID - newDepth , frame ) ; } } oldDepth -- ; newDepth -- ; } }
private void mapOldFramesToNew ( int isolateId ) { ArrayList < DStackContext > previousFrames = null ; ArrayList < DStackContext > frames = null ; Map < Long , DValue > previousValues = null ; previousFrames = getIsolateState ( isolateId ) . m_previousFrames ; frames = getIsolateState ( isolateId ) . m_frames ; previousValues = getIsolateState ( isolateId ) . m_previousValues ; int oldSize = previousFrames . size ( ) ; int newSize = frames . size ( ) ; DValue [ ] oldFrames = new DValue [ oldSize ] ; for ( int depth = _NUM ; depth < oldSize ; depth ++ ) { oldFrames [ depth ] = ( DValue ) previousValues . remove ( Value . BASE_ID - depth ) ; } int oldDepth = oldSize - _NUM ; int newDepth = newSize - _NUM ; while ( oldDepth >= _NUM && newDepth >= _NUM ) { DStackContext oldFrame = previousFrames . get ( oldDepth ) ; DStackContext newFrame = frames . get ( newDepth ) ; if ( oldFrame != null && newFrame != null ) { if ( stringsEqual ( oldFrame . getCallSignature ( ) , newFrame . getCallSignature ( ) ) ) { DValue frame = oldFrames [ oldDepth ] ; if ( frame != null ) previousValues . put ( Value . BASE_ID - newDepth , frame ) ; } } oldDepth -- ; newDepth -- ; } }
private void mapOldFramesToNew ( int isolateId ) { ArrayList < DStackContext > previousFrames = null ; ArrayList < DStackContext > frames = null ; Map < Long , DValue > previousValues = null ; previousFrames = getIsolateState ( isolateId ) . m_previousFrames ; frames = getIsolateState ( isolateId ) . m_frames ; previousValues = getIsolateState ( isolateId ) . m_previousValues ; int oldSize = previousFrames . size ( ) ; int newSize = frames . size ( ) ; DValue [ ] oldFrames = new DValue [ oldSize ] ; for ( int depth = _NUM ; depth < oldSize ; depth ++ ) { oldFrames [ depth ] = ( DValue ) previousValues . remove ( Value . BASE_ID - depth ) ; } int oldDepth = oldSize - _NUM ; int newDepth = newSize - _NUM ; while ( oldDepth >= _NUM && newDepth >= _NUM ) { DStackContext oldFrame = previousFrames . get ( oldDepth ) ; DStackContext newFrame = frames . get ( newDepth ) ; if ( oldFrame != null && newFrame != null ) { if ( stringsEqual ( oldFrame . getCallSignature ( ) , newFrame . getCallSignature ( ) ) ) { DValue frame = oldFrames [ oldDepth ] ; if ( frame != null ) previousValues . put ( Value . BASE_ID - newDepth , frame ) ; } } oldDepth -- ; newDepth -- ; } }
private void mapOldFramesToNew ( int isolateId ) { ArrayList < DStackContext > previousFrames = null ; ArrayList < DStackContext > frames = null ; Map < Long , DValue > previousValues = null ; previousFrames = getIsolateState ( isolateId ) . m_previousFrames ; frames = getIsolateState ( isolateId ) . m_frames ; previousValues = getIsolateState ( isolateId ) . m_previousValues ; int oldSize = previousFrames . size ( ) ; int newSize = frames . size ( ) ; DValue [ ] oldFrames = new DValue [ oldSize ] ; for ( int depth = _NUM ; depth < oldSize ; depth ++ ) { oldFrames [ depth ] = ( DValue ) previousValues . remove ( Value . BASE_ID - depth ) ; } int oldDepth = oldSize - _NUM ; int newDepth = newSize - _NUM ; while ( oldDepth >= _NUM && newDepth >= _NUM ) { DStackContext oldFrame = previousFrames . get ( oldDepth ) ; DStackContext newFrame = frames . get ( newDepth ) ; if ( oldFrame != null && newFrame != null ) { if ( stringsEqual ( oldFrame . getCallSignature ( ) , newFrame . getCallSignature ( ) ) ) { DValue frame = oldFrames [ oldDepth ] ; if ( frame != null ) previousValues . put ( Value . BASE_ID - newDepth , frame ) ; } } oldDepth -- ; newDepth -- ; } }
protected void addToGUI ( JPanel gui , AbstractButton b , String cmd ) { b . setActionCommand ( cmd ) ; b . addActionListener ( this ) ; gui . add ( b ) ; }
private void internalAddHead ( final MessageReference ref ) { queueMemorySize . addAndGet ( ref . getMessageMemoryEstimate ( ) ) ; refAdded ( ref ) ; int priority = getPriority ( ref ) ; messageReferences . addHead ( ref , priority ) ; }
private void internalAddHead ( final MessageReference ref ) { queueMemorySize . addAndGet ( ref . getMessageMemoryEstimate ( ) ) ; refAdded ( ref ) ; int priority = getPriority ( ref ) ; messageReferences . addHead ( ref , priority ) ; }
private void internalAddHead ( final MessageReference ref ) { queueMemorySize . addAndGet ( ref . getMessageMemoryEstimate ( ) ) ; refAdded ( ref ) ; int priority = getPriority ( ref ) ; messageReferences . addHead ( ref , priority ) ; }
private void internalAddHead ( final MessageReference ref ) { queueMemorySize . addAndGet ( ref . getMessageMemoryEstimate ( ) ) ; refAdded ( ref ) ; int priority = getPriority ( ref ) ; messageReferences . addHead ( ref , priority ) ; }
private void internalAddHead ( final MessageReference ref ) { queueMemorySize . addAndGet ( ref . getMessageMemoryEstimate ( ) ) ; refAdded ( ref ) ; int priority = getPriority ( ref ) ; messageReferences . addHead ( ref , priority ) ; }
@ SuppressWarnings ( STRING ) public List < Product > read ( List < Long > ids ) { if ( ( ids == null ) || ids . isEmpty ( ) ) return ImmutableList . of ( ) ; String facet = STRING ; String logic_op = STRING ; for ( Long id : ids ) { facet += STRING + logic_op + STRING + id ; logic_op = STRING ; } return ( List < Product > ) find ( STRING + entityClass . getName ( ) + STRING + facet ) ; }
@ SuppressWarnings ( STRING ) public List < Product > read ( List < Long > ids ) { if ( ( ids == null ) || ids . isEmpty ( ) ) return ImmutableList . of ( ) ; String facet = STRING ; String logic_op = STRING ; for ( Long id : ids ) { facet += STRING + logic_op + STRING + id ; logic_op = STRING ; } return ( List < Product > ) find ( STRING + entityClass . getName ( ) + STRING + facet ) ; }
public DexlibWrapper ( File inputDexFile ) { this . inputDexFile = inputDexFile ; }
public DexlibWrapper ( File inputDexFile ) { this . inputDexFile = inputDexFile ; }
public Object removeProperty ( final URI uri , final String prop ) { return removeProperty ( uri , factory . toPropertyURI ( prop ) ) ; }
public DSubjectAlternativeName ( JDialog parent , byte [ ] value ) throws IOException { super ( parent ) ; setTitle ( res . getString ( STRING ) ) ; initComponents ( ) ; prepopulateWithValue ( value ) ; }
protected abstract void performDeployerActionOnSingleDeployable ( org . codehaus . cargo . container . deployer . Deployer deployer , org . codehaus . cargo . container . deployable . Deployable deployable , org . codehaus . cargo . container . deployer . DeployableMonitor monitor ) ;
protected abstract void performDeployerActionOnSingleDeployable ( org . codehaus . cargo . container . deployer . Deployer deployer , org . codehaus . cargo . container . deployable . Deployable deployable , org . codehaus . cargo . container . deployer . DeployableMonitor monitor ) ;
public void lockRowAdd ( ArrayList < Row > rows ) { if ( state == FOUND ) { rows . add ( get ( ) ) ; } }
public void drawCalendar ( ) { drawCalendar ( displayedYearMonth ) ; }
public void drawCalendar ( ) { drawCalendar ( displayedYearMonth ) ; }
public void drawCalendar ( ) { drawCalendar ( displayedYearMonth ) ; }
public void drawCalendar ( ) { drawCalendar ( displayedYearMonth ) ; }
public void drawCalendar ( ) { drawCalendar ( displayedYearMonth ) ; }
public void drawCalendar ( ) { drawCalendar ( displayedYearMonth ) ; }
public void drawCalendar ( ) { drawCalendar ( displayedYearMonth ) ; }
public void drawCalendar ( ) { drawCalendar ( displayedYearMonth ) ; }
public void drawCalendar ( ) { drawCalendar ( displayedYearMonth ) ; }
public void removeLayer ( int index ) { List < Layer > currentLayers = getLayerList ( ) ; try { currentLayers . remove ( index ) ; setLayerList ( currentLayers ) ; } catch ( IndexOutOfBoundsException ioobe ) { } }
protected RouteCalculator createRouteCalculator ( ) { return new RouteCalculator ( ) ; }
protected RouteCalculator createRouteCalculator ( ) { return new RouteCalculator ( ) ; }
public static void init ( ) { init ( System . getProperties ( ) ) ; }
public static void init ( ) { init ( System . getProperties ( ) ) ; }
protected void requestUpdate ( boolean force ) { if ( LogConfiguration . loggingIsEnabled ( ) ) { logger . log ( Level . INFO , STRING ) ; } if ( force ) { Screen . reload ( ) ; } else { uiHandler . confirmReloadPage ( ) ; } }
protected void requestUpdate ( boolean force ) { if ( LogConfiguration . loggingIsEnabled ( ) ) { logger . log ( Level . INFO , STRING ) ; } if ( force ) { Screen . reload ( ) ; } else { uiHandler . confirmReloadPage ( ) ; } }
protected void requestUpdate ( boolean force ) { if ( LogConfiguration . loggingIsEnabled ( ) ) { logger . log ( Level . INFO , STRING ) ; } if ( force ) { Screen . reload ( ) ; } else { uiHandler . confirmReloadPage ( ) ; } }
protected void requestUpdate ( boolean force ) { if ( LogConfiguration . loggingIsEnabled ( ) ) { logger . log ( Level . INFO , STRING ) ; } if ( force ) { Screen . reload ( ) ; } else { uiHandler . confirmReloadPage ( ) ; } }
public static String currentDefaultFormattedTimeStamp ( ) { try { SimpleDateFormat sdf = new SimpleDateFormat ( DEFAULT_TIME_STAMP_FORMAT ) ; final String formattedTimeStamp = sdf . format ( new Date ( ) ) ; return formattedTimeStamp ; } catch ( IllegalArgumentException e ) { SimpleDateFormat sdf = new SimpleDateFormat ( SAFE_TIME_STAMP_FORMAT ) ; final String formattedTimeStamp = sdf . format ( new Date ( ) ) ; return formattedTimeStamp ; } }
public static String currentDefaultFormattedTimeStamp ( ) { try { SimpleDateFormat sdf = new SimpleDateFormat ( DEFAULT_TIME_STAMP_FORMAT ) ; final String formattedTimeStamp = sdf . format ( new Date ( ) ) ; return formattedTimeStamp ; } catch ( IllegalArgumentException e ) { SimpleDateFormat sdf = new SimpleDateFormat ( SAFE_TIME_STAMP_FORMAT ) ; final String formattedTimeStamp = sdf . format ( new Date ( ) ) ; return formattedTimeStamp ; } }
public static String currentDefaultFormattedTimeStamp ( ) { try { SimpleDateFormat sdf = new SimpleDateFormat ( DEFAULT_TIME_STAMP_FORMAT ) ; final String formattedTimeStamp = sdf . format ( new Date ( ) ) ; return formattedTimeStamp ; } catch ( IllegalArgumentException e ) { SimpleDateFormat sdf = new SimpleDateFormat ( SAFE_TIME_STAMP_FORMAT ) ; final String formattedTimeStamp = sdf . format ( new Date ( ) ) ; return formattedTimeStamp ; } }
protected FlashingIcon ( Icon icon ) { this . icon = icon ; Dimension d = new Dimension ( icon . getIconWidth ( ) , icon . getIconHeight ( ) ) ; setMinimumSize ( d ) ; setMaximumSize ( d ) ; setPreferredSize ( d ) ; setVisible ( _BOOL ) ; addMouseListener ( this ) ; }
public String toString ( ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( STRING ) ; Collection < String > factors = connectivity . keySet ( ) ; for ( String factor : factors ) { buf . append ( STRING ) ; buf . append ( factor ) ; buf . append ( STRING ) ; Collection < LaggedFactor > edges = connectivity . get ( factor ) ; for ( LaggedFactor edge : edges ) { buf . append ( STRING ) ; buf . append ( edge ) ; } } buf . append ( STRING ) ; return buf . toString ( ) ; }
public static String exceptionStackTraceToString ( Exception ex ) { StringWriter errors = new StringWriter ( ) ; ex . printStackTrace ( new PrintWriter ( errors ) ) ; return errors . toString ( ) ; }
protected void writeRaw ( CharSequence seq , CharBuf buffer ) { if ( seq != null ) { buffer . add ( seq . toString ( ) ) ; } }
protected void writeRaw ( CharSequence seq , CharBuf buffer ) { if ( seq != null ) { buffer . add ( seq . toString ( ) ) ; } }
protected void writeRaw ( CharSequence seq , CharBuf buffer ) { if ( seq != null ) { buffer . add ( seq . toString ( ) ) ; } }
public T image ( File file , boolean memCache , int targetWidth , BitmapAjaxCallback callback ) { if ( callback == null ) callback = new BitmapAjaxCallback ( ) ; callback . file ( file ) ; String url = null ; if ( file != null ) url = file . getAbsolutePath ( ) ; return image ( url , memCache , _BOOL , targetWidth , _NUM , callback ) ; }
public T image ( File file , boolean memCache , int targetWidth , BitmapAjaxCallback callback ) { if ( callback == null ) callback = new BitmapAjaxCallback ( ) ; callback . file ( file ) ; String url = null ; if ( file != null ) url = file . getAbsolutePath ( ) ; return image ( url , memCache , _BOOL , targetWidth , _NUM , callback ) ; }
public static ApiMethod processMethod ( ApiService apiService , MethodDoc method , String baseURL , boolean isDataService ) { try { ApiMethod apiMethodDesc = new ApiMethod ( ) ; apiMethodDesc . javaMethodName = method . name ( ) ; apiMethodDesc . apiService = apiService ; apiMethodDesc . isDataService = isDataService ; addPath ( method , apiMethodDesc , baseURL ) ; addHttpMethod ( method , apiMethodDesc ) ; addDescription ( method , apiMethodDesc ) ; addBriefDescription ( method , apiMethodDesc ) ; addResponseDescription ( method , apiMethodDesc ) ; addPrerequisites ( method , apiMethodDesc ) ; addSecurity ( method , apiMethodDesc ) ; if ( isDataService ) { addDataServiceInformation ( method , apiMethodDesc ) ; } else { addInputs ( method , apiMethodDesc ) ; } addOutput ( method , apiMethodDesc ) ; addQueryParameters ( method , apiMethodDesc ) ; addPathParameters ( method , apiMethodDesc ) ; addExamples ( apiMethodDesc ) ; addDeprecated ( method , apiMethodDesc ) ; return apiMethodDesc ; } catch ( Exception e ) { throw new RuntimeException ( STRING + apiService . getFqJavaClassName ( ) + STRING + method . name ( ) , e ) ; } }
private void stretchViewHorizontally ( View view , int crossSize ) { LayoutParams lp = ( LayoutParams ) view . getLayoutParams ( ) ; int newWidth = crossSize - lp . leftMargin - lp . rightMargin ; newWidth = Math . max ( newWidth , _NUM ) ; view . measure ( MeasureSpec . makeMeasureSpec ( newWidth , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( view . getMeasuredHeight ( ) , MeasureSpec . EXACTLY ) ) ; }
private void stretchViewHorizontally ( View view , int crossSize ) { LayoutParams lp = ( LayoutParams ) view . getLayoutParams ( ) ; int newWidth = crossSize - lp . leftMargin - lp . rightMargin ; newWidth = Math . max ( newWidth , _NUM ) ; view . measure ( MeasureSpec . makeMeasureSpec ( newWidth , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( view . getMeasuredHeight ( ) , MeasureSpec . EXACTLY ) ) ; }
@ VisibleForTesting static String escapeSqlString ( String string ) { return string . replaceAll ( STRING , STRING ) ; }
public static OutputStream leftShift ( Process self , byte [ ] value ) throws IOException { return IOGroovyMethods . leftShift ( self . getOutputStream ( ) , value ) ; }
HttpsClient ( SSLSocketFactory sf , URL url , String proxyHost , int proxyPort , int connectTimeout ) throws IOException { this ( sf , url , ( proxyHost == null ? null : HttpClient . newHttpProxy ( proxyHost , proxyPort , STRING ) ) , connectTimeout ) ; }
public EconomyConcurrentHashMap ( Map < ? extends K , ? extends V > m , IHashEntryHandler < K , V > handler ) { this ( Math . max ( ( int ) ( m . size ( ) / DEFAULT_LOAD_FACTOR ) + _NUM , DEFAULT_INITIAL_CAPACITY ) , DEFAULT_LOAD_FACTOR , DEFAULT_CONCURRENCY_LEVEL , handler ) ; putAll ( m ) ; }
@ Override public synchronized void removeInstanceListener ( InstanceListener tsl ) { m_instanceListeners . remove ( tsl ) ; }
public static < T > List < T > toList ( T obj1 , T obj2 , T obj3 , T obj4 , T obj5 , T obj6 ) { List < T > list = new LinkedList < T > ( ) ; list . add ( obj1 ) ; list . add ( obj2 ) ; list . add ( obj3 ) ; list . add ( obj4 ) ; list . add ( obj5 ) ; list . add ( obj6 ) ; return list ; }
public KernelDensityFunction ( Collection < double [ ] > points ) { this ( points . toArray ( new double [ points . size ( ) ] [ ] ) ) ; }
@ Deprecated public boolean isToolEffective ( String type , int level ) { String t = getHarvestTool ( ) ; return ( t == null && type == null ) || type . equals ( t ) ; }
private void digitsToWords ( String tokenVal ) { FeatureSet featureSet = tokenItem . getFeatures ( ) ; String nsw = STRING ; if ( featureSet . isPresent ( STRING ) ) { nsw = featureSet . getString ( STRING ) ; } if ( nsw . equals ( STRING ) ) { NumberExpander . expandID ( tokenVal , wordRelation ) ; } else { String rName = featureSet . getString ( STRING ) ; String digitsType = null ; if ( tokenVal . equals ( rName ) ) { digitsType = ( String ) cart . interpret ( tokenItem ) ; } else { featureSet . setString ( STRING , tokenVal ) ; digitsType = ( String ) cart . interpret ( tokenItem ) ; featureSet . setString ( STRING , rName ) ; } if ( digitsType . equals ( STRING ) ) { NumberExpander . expandOrdinal ( tokenVal , wordRelation ) ; } else if ( digitsType . equals ( STRING ) ) { NumberExpander . expandDigits ( tokenVal , wordRelation ) ; } else if ( digitsType . equals ( STRING ) ) { NumberExpander . expandID ( tokenVal , wordRelation ) ; } else { NumberExpander . expandNumber ( tokenVal , wordRelation ) ; } } }
public static Font createBitmapFont ( String name , Image bitmap , int [ ] cutOffsets , int [ ] charWidth , String charsets ) { Font f = createBitmapFont ( bitmap , cutOffsets , charWidth , charsets ) ; bitmapCache . put ( name , f ) ; return f ; }
public static Font createBitmapFont ( String name , Image bitmap , int [ ] cutOffsets , int [ ] charWidth , String charsets ) { Font f = createBitmapFont ( bitmap , cutOffsets , charWidth , charsets ) ; bitmapCache . put ( name , f ) ; return f ; }
public static Font createBitmapFont ( String name , Image bitmap , int [ ] cutOffsets , int [ ] charWidth , String charsets ) { Font f = createBitmapFont ( bitmap , cutOffsets , charWidth , charsets ) ; bitmapCache . put ( name , f ) ; return f ; }
public static synchronized String generateSegmentName ( ) { try { Thread . sleep ( _NUM ) ; } catch ( Throwable t ) { } return sdf . format ( new Date ( System . currentTimeMillis ( ) ) ) ; }
public Element signXML ( Document doc , String certAlias , String algorithm , String idAttrName , String id , boolean includeCert , String xpath ) throws XMLSignatureException { return signXMLUsingKeyPass ( doc , certAlias , null , algorithm , idAttrName , id , includeCert , xpath ) ; }
public Storage ( ) { this ( new File ( getTemporaryStorageDirectoryString ( ) ) ) ; }
public Object touch ( int row ) throws PageException { Object o = query . getAt ( columnName , row , NullSupportHelper . NULL ( ) ) ; if ( o != NullSupportHelper . NULL ( ) ) return o ; return query . setAt ( columnName , row , new StructImpl ( ) ) ; }
public int compareSwappedTo ( DoubleIntPair other ) { int fdiff = this . second - other . second ; if ( fdiff != _NUM ) { return fdiff ; } return Double . compare ( this . second , other . second ) ; }
private void alignLabels ( ) { final int height = m_selectorLabel . getPreferredSize ( ) . height ; int width = m_selectorLabel . getPreferredSize ( ) . width ; if ( m_editor != null ) { final int labelWidth = m_editor . getLabelWidth ( ) ; if ( width < labelWidth ) { width = labelWidth ; } else { m_editor . setLabelWidth ( width ) ; } } final Dimension dimension = new Dimension ( width , height ) ; m_selectorLabel . setPreferredSize ( dimension ) ; m_selectorLabel . setSize ( dimension ) ; }
private void alignLabels ( ) { final int height = m_selectorLabel . getPreferredSize ( ) . height ; int width = m_selectorLabel . getPreferredSize ( ) . width ; if ( m_editor != null ) { final int labelWidth = m_editor . getLabelWidth ( ) ; if ( width < labelWidth ) { width = labelWidth ; } else { m_editor . setLabelWidth ( width ) ; } } final Dimension dimension = new Dimension ( width , height ) ; m_selectorLabel . setPreferredSize ( dimension ) ; m_selectorLabel . setSize ( dimension ) ; }
private int reverseAlignForBidi ( Component c , int align ) { if ( c . isRTL ( ) ) { switch ( align ) { case Component . RIGHT : return Component . LEFT ; case Component . LEFT : return Component . RIGHT ; } } return align ; }
private int reverseAlignForBidi ( Component c , int align ) { if ( c . isRTL ( ) ) { switch ( align ) { case Component . RIGHT : return Component . LEFT ; case Component . LEFT : return Component . RIGHT ; } } return align ; }
public static Collection < String > nodeId8s ( @ Nullable Collection < ? extends ClusterNode > nodes ) { if ( nodes == null || nodes . isEmpty ( ) ) return Collections . emptyList ( ) ; return F . viewReadOnly ( nodes , NODE2ID8 ) ; }
public static Collection < String > nodeId8s ( @ Nullable Collection < ? extends ClusterNode > nodes ) { if ( nodes == null || nodes . isEmpty ( ) ) return Collections . emptyList ( ) ; return F . viewReadOnly ( nodes , NODE2ID8 ) ; }
public static Collection < String > nodeId8s ( @ Nullable Collection < ? extends ClusterNode > nodes ) { if ( nodes == null || nodes . isEmpty ( ) ) return Collections . emptyList ( ) ; return F . viewReadOnly ( nodes , NODE2ID8 ) ; }
public static Collection < String > nodeId8s ( @ Nullable Collection < ? extends ClusterNode > nodes ) { if ( nodes == null || nodes . isEmpty ( ) ) return Collections . emptyList ( ) ; return F . viewReadOnly ( nodes , NODE2ID8 ) ; }
public static Collection < String > nodeId8s ( @ Nullable Collection < ? extends ClusterNode > nodes ) { if ( nodes == null || nodes . isEmpty ( ) ) return Collections . emptyList ( ) ; return F . viewReadOnly ( nodes , NODE2ID8 ) ; }
public static void writeUINT32 ( long number , OutputStream out ) throws IOException { if ( number < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } byte [ ] toWrite = new byte [ _NUM ] ; for ( int i = _NUM ; i <= _NUM ; i += _NUM ) { toWrite [ i / _NUM ] = ( byte ) ( ( number > > i ) & _NUM ) ; } out . write ( toWrite ) ; }
public void run ( ) { ClusterResourceNotification notification ; int warningCount = _NUM ; do { try { notification = notifications . take ( ) ; notifyListeners ( notification ) ; } catch ( InterruptedException i ) { logger . warn ( STRING ) ; warningCount ++ ; } catch ( ResourceNotificationException r ) { logger . warn ( STRING + r ) ; warningCount ++ ; } } while ( warningCount < MAX_WARNINGS ) ; logger . fatal ( STRING ) ; System . exit ( _NUM ) ; }
public void run ( ) { ClusterResourceNotification notification ; int warningCount = _NUM ; do { try { notification = notifications . take ( ) ; notifyListeners ( notification ) ; } catch ( InterruptedException i ) { logger . warn ( STRING ) ; warningCount ++ ; } catch ( ResourceNotificationException r ) { logger . warn ( STRING + r ) ; warningCount ++ ; } } while ( warningCount < MAX_WARNINGS ) ; logger . fatal ( STRING ) ; System . exit ( _NUM ) ; }
public void run ( ) { ClusterResourceNotification notification ; int warningCount = _NUM ; do { try { notification = notifications . take ( ) ; notifyListeners ( notification ) ; } catch ( InterruptedException i ) { logger . warn ( STRING ) ; warningCount ++ ; } catch ( ResourceNotificationException r ) { logger . warn ( STRING + r ) ; warningCount ++ ; } } while ( warningCount < MAX_WARNINGS ) ; logger . fatal ( STRING ) ; System . exit ( _NUM ) ; }
public void run ( ) { ClusterResourceNotification notification ; int warningCount = _NUM ; do { try { notification = notifications . take ( ) ; notifyListeners ( notification ) ; } catch ( InterruptedException i ) { logger . warn ( STRING ) ; warningCount ++ ; } catch ( ResourceNotificationException r ) { logger . warn ( STRING + r ) ; warningCount ++ ; } } while ( warningCount < MAX_WARNINGS ) ; logger . fatal ( STRING ) ; System . exit ( _NUM ) ; }
public void run ( ) { ClusterResourceNotification notification ; int warningCount = _NUM ; do { try { notification = notifications . take ( ) ; notifyListeners ( notification ) ; } catch ( InterruptedException i ) { logger . warn ( STRING ) ; warningCount ++ ; } catch ( ResourceNotificationException r ) { logger . warn ( STRING + r ) ; warningCount ++ ; } } while ( warningCount < MAX_WARNINGS ) ; logger . fatal ( STRING ) ; System . exit ( _NUM ) ; }
public String serialize ( Object object ) throws ConverterException { deep = _NUM ; StringBuilder sb = new StringBuilder ( ) ; _serialize ( object , sb , new HashSet < Object > ( ) ) ; return sb . toString ( ) ; }
public void compileAllProjects ( List < File > pProjectRoots , IssueAcceptor issueAcceptor ) throws N4JSCompileException { List < File > absProjectRoots = HeadlessHelper . toAbsoluteFileList ( pProjectRoots ) ; ArrayList < File > pDir = HeadlessHelper . collectAllProjectPaths ( absProjectRoots ) ; compileProjects ( pProjectRoots , pDir , Collections . emptyList ( ) , issueAcceptor ) ; }
public void compileAllProjects ( List < File > pProjectRoots , IssueAcceptor issueAcceptor ) throws N4JSCompileException { List < File > absProjectRoots = HeadlessHelper . toAbsoluteFileList ( pProjectRoots ) ; ArrayList < File > pDir = HeadlessHelper . collectAllProjectPaths ( absProjectRoots ) ; compileProjects ( pProjectRoots , pDir , Collections . emptyList ( ) , issueAcceptor ) ; }
public void compileAllProjects ( List < File > pProjectRoots , IssueAcceptor issueAcceptor ) throws N4JSCompileException { List < File > absProjectRoots = HeadlessHelper . toAbsoluteFileList ( pProjectRoots ) ; ArrayList < File > pDir = HeadlessHelper . collectAllProjectPaths ( absProjectRoots ) ; compileProjects ( pProjectRoots , pDir , Collections . emptyList ( ) , issueAcceptor ) ; }
public void removeQualifiers ( ) { PropertyOptions opts = getOptions ( ) ; opts . setHasQualifiers ( _BOOL ) ; opts . setHasLanguage ( _BOOL ) ; opts . setHasType ( _BOOL ) ; qualifier = null ; }
public void removeQualifiers ( ) { PropertyOptions opts = getOptions ( ) ; opts . setHasQualifiers ( _BOOL ) ; opts . setHasLanguage ( _BOOL ) ; opts . setHasType ( _BOOL ) ; qualifier = null ; }
private static byte [ ] createReq ( byte [ ] command , int value ) { byte [ ] array = new byte [ _NUM ] ; System . arraycopy ( command , _NUM , array , _NUM , _NUM ) ; ArrayHelper . swap32bitsToArray ( value , array , _NUM ) ; return array ; }
protected static Boolean tryToLock ( String serviceName ) { DistributedLockService service = DistributedLockService . getServiceNamed ( serviceName ) ; boolean locked = service . lock ( STRING , _NUM , - _NUM ) ; if ( locked ) { service . unlock ( STRING ) ; } return Boolean . valueOf ( locked ) ; }
public void clearRow ( int nodeIndex , int rowIndex ) { for ( int colIndex = _NUM ; colIndex < getNumColumns ( nodeIndex ) ; colIndex ++ ) { setProbability ( nodeIndex , rowIndex , colIndex , Double . NaN ) ; } }
public void clearRow ( int nodeIndex , int rowIndex ) { for ( int colIndex = _NUM ; colIndex < getNumColumns ( nodeIndex ) ; colIndex ++ ) { setProbability ( nodeIndex , rowIndex , colIndex , Double . NaN ) ; } }
@ Override public void unindent ( ) { _nextIndent -= _format . getIndent ( ) ; if ( _nextIndent < _NUM ) _nextIndent = _NUM ; if ( ( _line . length ( ) + _spaces + _text . length ( ) ) == _NUM ) _thisIndent = _nextIndent ; }
public void move ( int from , int to , int count ) { if ( ! valid ( ) ) { return ; } invalidateLineMapAfter ( Math . min ( from , to ) ) ; Point [ ] itemsToMove = new Point [ count ] ; for ( int i = from ; i < from + count ; i ++ ) { itemsToMove [ i - from ] = sizeMap . get ( i ) ; } boolean movingForward = from - to > _NUM ; int itemsToShift = Math . abs ( from - to ) ; if ( ! movingForward ) { itemsToShift -= count ; } int shiftIndex = movingForward ? from - _NUM : from + count ; int shiftIndexStep = movingForward ? - _NUM : _NUM ; int shifted = _NUM ; while ( shifted < itemsToShift ) { sizeMap . put ( shiftIndex - ( shiftIndexStep ) * count , sizeMap . get ( shiftIndex ) ) ; shiftIndex += shiftIndexStep ; shifted ++ ; } int setIndex = to ; if ( ! movingForward ) { setIndex = from + itemsToShift ; } for ( Point item : itemsToMove ) { sizeMap . put ( setIndex ++ , item ) ; } refreshLineMap ( ) ; }
public void hideAllBudges ( ) { for ( RelativeLayout badge : badgeList ) { if ( badge . getVisibility ( ) == VISIBLE ) BadgeHelper . hideBadge ( badge ) ; } badgeSaveInstanceHashMap . clear ( ) ; }
public static ServerSocket createServerSocket ( int port , InetAddress bindAddress ) throws IOException { ServerSocket socket = null ; if ( SysProperties . ENABLE_ANONYMOUS_TLS ) { removeAnonFromLegacyAlgorithms ( ) ; } setKeystore ( ) ; ServerSocketFactory f = SSLServerSocketFactory . getDefault ( ) ; SSLServerSocket secureSocket ; if ( bindAddress == null ) { secureSocket = ( SSLServerSocket ) f . createServerSocket ( port ) ; } else { secureSocket = ( SSLServerSocket ) f . createServerSocket ( port , _NUM , bindAddress ) ; } secureSocket . setEnabledProtocols ( disableSSL ( secureSocket . getEnabledProtocols ( ) ) ) ; if ( SysProperties . ENABLE_ANONYMOUS_TLS ) { String [ ] list = enableAnonymous ( secureSocket . getEnabledCipherSuites ( ) , secureSocket . getSupportedCipherSuites ( ) ) ; secureSocket . setEnabledCipherSuites ( list ) ; } socket = secureSocket ; return socket ; }
public static ServerSocket createServerSocket ( int port , InetAddress bindAddress ) throws IOException { ServerSocket socket = null ; if ( SysProperties . ENABLE_ANONYMOUS_TLS ) { removeAnonFromLegacyAlgorithms ( ) ; } setKeystore ( ) ; ServerSocketFactory f = SSLServerSocketFactory . getDefault ( ) ; SSLServerSocket secureSocket ; if ( bindAddress == null ) { secureSocket = ( SSLServerSocket ) f . createServerSocket ( port ) ; } else { secureSocket = ( SSLServerSocket ) f . createServerSocket ( port , _NUM , bindAddress ) ; } secureSocket . setEnabledProtocols ( disableSSL ( secureSocket . getEnabledProtocols ( ) ) ) ; if ( SysProperties . ENABLE_ANONYMOUS_TLS ) { String [ ] list = enableAnonymous ( secureSocket . getEnabledCipherSuites ( ) , secureSocket . getSupportedCipherSuites ( ) ) ; secureSocket . setEnabledCipherSuites ( list ) ; } socket = secureSocket ; return socket ; }
public static ServerSocket createServerSocket ( int port , InetAddress bindAddress ) throws IOException { ServerSocket socket = null ; if ( SysProperties . ENABLE_ANONYMOUS_TLS ) { removeAnonFromLegacyAlgorithms ( ) ; } setKeystore ( ) ; ServerSocketFactory f = SSLServerSocketFactory . getDefault ( ) ; SSLServerSocket secureSocket ; if ( bindAddress == null ) { secureSocket = ( SSLServerSocket ) f . createServerSocket ( port ) ; } else { secureSocket = ( SSLServerSocket ) f . createServerSocket ( port , _NUM , bindAddress ) ; } secureSocket . setEnabledProtocols ( disableSSL ( secureSocket . getEnabledProtocols ( ) ) ) ; if ( SysProperties . ENABLE_ANONYMOUS_TLS ) { String [ ] list = enableAnonymous ( secureSocket . getEnabledCipherSuites ( ) , secureSocket . getSupportedCipherSuites ( ) ) ; secureSocket . setEnabledCipherSuites ( list ) ; } socket = secureSocket ; return socket ; }
static Rectangle translateCoordinates ( long src , long dst , Rectangle r ) { Point translatedLoc = translateCoordinates ( src , dst , r . getLocation ( ) ) ; if ( translatedLoc == null ) { return null ; } else { return new Rectangle ( translatedLoc , r . getSize ( ) ) ; } }
public int [ ] time2LMST ( long time ) { int [ ] result = new int [ _NUM ] ; long marsTime = Math . round ( ( time - epoch ) / _NUM / toEarth ) ; result [ _NUM ] = ( int ) ( marsTime / ( secondsInADay ) ) ; marsTime = ( int ) ( marsTime % secondsInADay ) ; result [ _NUM ] = Math . abs ( ( int ) ( marsTime / secondsInAnHr ) ) ; marsTime = ( int ) ( marsTime % secondsInAnHr ) ; result [ _NUM ] = Math . abs ( ( int ) ( marsTime / secondsInAMin ) ) ; result [ _NUM ] = Math . abs ( ( int ) ( marsTime % secondsInAMin ) ) ; return ( result ) ; }
public int [ ] time2LMST ( long time ) { int [ ] result = new int [ _NUM ] ; long marsTime = Math . round ( ( time - epoch ) / _NUM / toEarth ) ; result [ _NUM ] = ( int ) ( marsTime / ( secondsInADay ) ) ; marsTime = ( int ) ( marsTime % secondsInADay ) ; result [ _NUM ] = Math . abs ( ( int ) ( marsTime / secondsInAnHr ) ) ; marsTime = ( int ) ( marsTime % secondsInAnHr ) ; result [ _NUM ] = Math . abs ( ( int ) ( marsTime / secondsInAMin ) ) ; result [ _NUM ] = Math . abs ( ( int ) ( marsTime % secondsInAMin ) ) ; return ( result ) ; }
public void testFileFile ( ) throws Exception { Properties properties = loadProperties ( STRING ) ; assertEquals ( STRING , properties . getProperty ( STRING ) ) ; }
public void findAndUndo ( Object someObj ) { if ( someObj == getInformationDelegator ( ) ) { if ( dtmm != null && dtmm . getInfoDelegator ( ) == ( InformationDelegator ) someObj ) { dtmm . setInfoDelegator ( null ) ; } setInformationDelegator ( null ) ; } if ( someObj == getMouseDelegator ( ) ) { setMouseDelegator ( null ) ; } if ( someObj == getCanvas ( ) ) { setCanvas ( null ) ; } if ( someObj instanceof EditToolLoader ) { removeLoader ( ( EditToolLoader ) someObj ) ; } }
public void findAndUndo ( Object someObj ) { if ( someObj == getInformationDelegator ( ) ) { if ( dtmm != null && dtmm . getInfoDelegator ( ) == ( InformationDelegator ) someObj ) { dtmm . setInfoDelegator ( null ) ; } setInformationDelegator ( null ) ; } if ( someObj == getMouseDelegator ( ) ) { setMouseDelegator ( null ) ; } if ( someObj == getCanvas ( ) ) { setCanvas ( null ) ; } if ( someObj instanceof EditToolLoader ) { removeLoader ( ( EditToolLoader ) someObj ) ; } }
@ Override protected Instances process ( Instances instances ) throws Exception { if ( ! isFirstBatchDone ( ) ) { HashSet < DecisionTableHashKey > hs = new HashSet < DecisionTableHashKey > ( ) ; Instances newInstances = new Instances ( instances , instances . numInstances ( ) ) ; for ( Instance inst : instances ) { DecisionTableHashKey key = new DecisionTableHashKey ( inst , instances . numAttributes ( ) , _BOOL ) ; if ( hs . add ( key ) ) { newInstances . add ( inst ) ; } } newInstances . compactify ( ) ; return newInstances ; } throw new Exception ( STRING ) ; }
@ Override protected Instances process ( Instances instances ) throws Exception { if ( ! isFirstBatchDone ( ) ) { HashSet < DecisionTableHashKey > hs = new HashSet < DecisionTableHashKey > ( ) ; Instances newInstances = new Instances ( instances , instances . numInstances ( ) ) ; for ( Instance inst : instances ) { DecisionTableHashKey key = new DecisionTableHashKey ( inst , instances . numAttributes ( ) , _BOOL ) ; if ( hs . add ( key ) ) { newInstances . add ( inst ) ; } } newInstances . compactify ( ) ; return newInstances ; } throw new Exception ( STRING ) ; }
@ Override protected Instances process ( Instances instances ) throws Exception { if ( ! isFirstBatchDone ( ) ) { HashSet < DecisionTableHashKey > hs = new HashSet < DecisionTableHashKey > ( ) ; Instances newInstances = new Instances ( instances , instances . numInstances ( ) ) ; for ( Instance inst : instances ) { DecisionTableHashKey key = new DecisionTableHashKey ( inst , instances . numAttributes ( ) , _BOOL ) ; if ( hs . add ( key ) ) { newInstances . add ( inst ) ; } } newInstances . compactify ( ) ; return newInstances ; } throw new Exception ( STRING ) ; }
@ Override protected Instances process ( Instances instances ) throws Exception { if ( ! isFirstBatchDone ( ) ) { HashSet < DecisionTableHashKey > hs = new HashSet < DecisionTableHashKey > ( ) ; Instances newInstances = new Instances ( instances , instances . numInstances ( ) ) ; for ( Instance inst : instances ) { DecisionTableHashKey key = new DecisionTableHashKey ( inst , instances . numAttributes ( ) , _BOOL ) ; if ( hs . add ( key ) ) { newInstances . add ( inst ) ; } } newInstances . compactify ( ) ; return newInstances ; } throw new Exception ( STRING ) ; }
protected void appendQueryParams ( NonSyncStringBuffer buffer ) throws JspException { String nvPairs = getQueryParams ( ) ; if ( ( nvPairs != null ) && ( nvPairs . length ( ) > _NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nvPairs ) ; } }
protected void appendQueryParams ( NonSyncStringBuffer buffer ) throws JspException { String nvPairs = getQueryParams ( ) ; if ( ( nvPairs != null ) && ( nvPairs . length ( ) > _NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nvPairs ) ; } }
protected void appendQueryParams ( NonSyncStringBuffer buffer ) throws JspException { String nvPairs = getQueryParams ( ) ; if ( ( nvPairs != null ) && ( nvPairs . length ( ) > _NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nvPairs ) ; } }
protected void appendQueryParams ( NonSyncStringBuffer buffer ) throws JspException { String nvPairs = getQueryParams ( ) ; if ( ( nvPairs != null ) && ( nvPairs . length ( ) > _NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nvPairs ) ; } }
protected void appendQueryParams ( NonSyncStringBuffer buffer ) throws JspException { String nvPairs = getQueryParams ( ) ; if ( ( nvPairs != null ) && ( nvPairs . length ( ) > _NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nvPairs ) ; } }
protected void appendQueryParams ( NonSyncStringBuffer buffer ) throws JspException { String nvPairs = getQueryParams ( ) ; if ( ( nvPairs != null ) && ( nvPairs . length ( ) > _NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nvPairs ) ; } }
protected void appendQueryParams ( NonSyncStringBuffer buffer ) throws JspException { String nvPairs = getQueryParams ( ) ; if ( ( nvPairs != null ) && ( nvPairs . length ( ) > _NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nvPairs ) ; } }
protected void appendQueryParams ( NonSyncStringBuffer buffer ) throws JspException { String nvPairs = getQueryParams ( ) ; if ( ( nvPairs != null ) && ( nvPairs . length ( ) > _NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nvPairs ) ; } }
protected void appendQueryParams ( NonSyncStringBuffer buffer ) throws JspException { String nvPairs = getQueryParams ( ) ; if ( ( nvPairs != null ) && ( nvPairs . length ( ) > _NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nvPairs ) ; } }
protected void appendQueryParams ( NonSyncStringBuffer buffer ) throws JspException { String nvPairs = getQueryParams ( ) ; if ( ( nvPairs != null ) && ( nvPairs . length ( ) > _NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nvPairs ) ; } }
protected void appendQueryParams ( NonSyncStringBuffer buffer ) throws JspException { String nvPairs = getQueryParams ( ) ; if ( ( nvPairs != null ) && ( nvPairs . length ( ) > _NUM ) ) { buffer . append ( STRING ) ; buffer . append ( nvPairs ) ; } }
protected int read ( SpeechRecord recorder , byte [ ] buffer ) { int len = buffer . length ; int numOfBytes = recorder . read ( buffer , _NUM , len ) ; int status = getStatus ( numOfBytes , len ) ; if ( status == _NUM && numOfBytes >= _NUM ) { System . arraycopy ( buffer , _NUM , mRecording , mRecordedLength , numOfBytes ) ; mRecordedLength += len ; } return status ; }
public void removeEntryIndexedField ( IEntryHolder eh , Object fieldValue , TemplateCacheInfo pTemplate , IObjectInfo oi ) { removeNonUniqueIndexedField ( eh , fieldValue , pTemplate , oi ) ; _size . decrementAndGet ( ) ; }
public void moveToTop ( Pinger pinger ) { mPingers . remove ( pinger ) ; mPingers . add ( _NUM , pinger ) ; notifyDataSetChanged ( ) ; }
private Platform createPlatform ( ) { Platform platform ; try { String osName = System . getProperty ( STRING ) ; if ( osName != null ) { osName = osName . toLowerCase ( ) ; logger . debug ( STRING , osName ) ; if ( osName . contains ( STRING ) ) { logger . debug ( STRING ) ; platform = new WindowsPlatform ( ) ; } else if ( osName . contains ( STRING ) || osName . contains ( STRING ) || osName . contains ( STRING ) || osName . contains ( STRING ) ) { if ( isGnome ( ) ) { logger . debug ( STRING ) ; platform = new PosixGnomePlatform ( ) ; } else if ( isKDE ( ) ) { logger . debug ( STRING ) ; platform = new PosixKDEPlatform ( ) ; } else { logger . debug ( STRING ) ; platform = new PosixPlatform ( ) ; } } else if ( osName . contains ( STRING ) || osName . contains ( STRING ) || osName . contains ( STRING ) || System . getProperty ( STRING ) != null ) { logger . debug ( STRING ) ; platform = new MacOSXPlatform ( ) ; } else { logger . warn ( STRING , osName ) ; platform = new DefaultPlatform ( ) ; } } else { logger . warn ( STRING ) ; platform = new DefaultPlatform ( ) ; } } catch ( SecurityException e ) { logger . warn ( STRING , e ) ; platform = new DefaultPlatform ( ) ; } return platform ; }
@ Override protected void afterExecute ( Runnable r , Throwable t ) { super . afterExecute ( r , t ) ; synchronized ( this ) { tasksInProcess . decrementAndGet ( ) ; if ( tasksInProcess . intValue ( ) == _NUM ) { synchronizer . signalAll ( ) ; } } }
public static File createTempDir ( File parent ) { File temp = new File ( parent , Integer . toString ( Math . abs ( UNSEEDED_RANDOM . nextInt ( ) ) % _NUM ) ) ; temp . delete ( ) ; temp . mkdir ( ) ; temp . deleteOnExit ( ) ; return temp ; }
char caseFold ( char c ) { if ( alternateCasing ) { if ( c == STRING ) { return STRING ; } else if ( c == STRING ) { return STRING ; } else { return Character . toLowerCase ( c ) ; } } else { return Character . toLowerCase ( c ) ; } }
public void clearTickMarkSections ( ) { tickMarkSections . clear ( ) ; fireUpdateEvent ( REDRAW_EVENT ) ; }
public Map < Long , PoiType > loadPoiTypes ( ) { List < PoiType > poiTypes = poiTypeDao . queryForAll ( ) ; Map < Long , PoiType > result = new HashMap < > ( ) ; for ( PoiType poiType : poiTypes ) { result . put ( poiType . getId ( ) , poiType ) ; } return result ; }
@ ObjectiveCName ( STRING ) Connection ( final String url , final DeepstreamConfig options , DeepstreamClient client , Endpoint endpoint ) { this . client = client ; this . connectStateListeners = new ArrayList < > ( ) ; this . originalUrl = url ; this . url = url ; this . connectionState = ConnectionState . CLOSED ; this . messageBuffer = new StringBuilder ( ) ; this . tooManyAuthAttempts = _BOOL ; this . challengeDenied = _BOOL ; this . deliberateClose = _BOOL ; this . redirecting = _BOOL ; this . reconnectTimeout = null ; this . reconnectionAttempt = _NUM ; this . options = options ; this . endpoint = endpoint ; this . recordThread = Executors . newSingleThreadExecutor ( ) ; this . eventThread = Executors . newSingleThreadExecutor ( ) ; this . rpcThread = Executors . newSingleThreadExecutor ( ) ; }
protected static void appendDecorations ( int basePos , String sourceCode , CreateSimpleLexer langHandler , List < Object > out ) { if ( sourceCode == null ) { throw new NullPointerException ( STRING ) ; } Job job = new Job ( ) ; job . setSourceCode ( sourceCode ) ; job . setBasePos ( basePos ) ; langHandler . decorate ( job ) ; out . addAll ( job . getDecorations ( ) ) ; }
protected static void appendDecorations ( int basePos , String sourceCode , CreateSimpleLexer langHandler , List < Object > out ) { if ( sourceCode == null ) { throw new NullPointerException ( STRING ) ; } Job job = new Job ( ) ; job . setSourceCode ( sourceCode ) ; job . setBasePos ( basePos ) ; langHandler . decorate ( job ) ; out . addAll ( job . getDecorations ( ) ) ; }
protected static void appendDecorations ( int basePos , String sourceCode , CreateSimpleLexer langHandler , List < Object > out ) { if ( sourceCode == null ) { throw new NullPointerException ( STRING ) ; } Job job = new Job ( ) ; job . setSourceCode ( sourceCode ) ; job . setBasePos ( basePos ) ; langHandler . decorate ( job ) ; out . addAll ( job . getDecorations ( ) ) ; }
private static String printOffset ( int offset ) { StringBuffer buf = new StringBuffer ( ) ; if ( offset >= _NUM ) { buf . append ( STRING ) ; } else { buf . append ( STRING ) ; offset = - offset ; } int hours = offset / DateTimeConstants . MILLIS_PER_HOUR ; FormatUtils . appendPaddedInteger ( buf , hours , _NUM ) ; offset -= hours * ( int ) DateTimeConstants . MILLIS_PER_HOUR ; int minutes = offset / DateTimeConstants . MILLIS_PER_MINUTE ; buf . append ( STRING ) ; FormatUtils . appendPaddedInteger ( buf , minutes , _NUM ) ; offset -= minutes * DateTimeConstants . MILLIS_PER_MINUTE ; if ( offset == _NUM ) { return buf . toString ( ) ; } int seconds = offset / DateTimeConstants . MILLIS_PER_SECOND ; buf . append ( STRING ) ; FormatUtils . appendPaddedInteger ( buf , seconds , _NUM ) ; offset -= seconds * DateTimeConstants . MILLIS_PER_SECOND ; if ( offset == _NUM ) { return buf . toString ( ) ; } buf . append ( STRING ) ; FormatUtils . appendPaddedInteger ( buf , offset , _NUM ) ; return buf . toString ( ) ; }
public static void sendEMail ( final Context context , final String dialogTitle , final String to , final String subject , final String body ) { final Intent send = new Intent ( Intent . ACTION_SENDTO ) ; final String uriText = STRING + Uri . encode ( to ) + STRING + Uri . encode ( subject ) + STRING + Uri . encode ( body ) ; send . setData ( Uri . parse ( uriText ) ) ; context . startActivity ( Intent . createChooser ( send , dialogTitle ) ) ; }
public static void sendEMail ( final Context context , final String dialogTitle , final String to , final String subject , final String body ) { final Intent send = new Intent ( Intent . ACTION_SENDTO ) ; final String uriText = STRING + Uri . encode ( to ) + STRING + Uri . encode ( subject ) + STRING + Uri . encode ( body ) ; send . setData ( Uri . parse ( uriText ) ) ; context . startActivity ( Intent . createChooser ( send , dialogTitle ) ) ; }
public double calculateLog ( double value ) { return Math . log ( value ) / this . baseLog ; }
public double calculateLog ( double value ) { return Math . log ( value ) / this . baseLog ; }
public String toString ( ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( STRING ) ; for ( int i = _NUM ; i < getNumFactors ( ) ; i ++ ) { String factor = getFactor ( i ) ; buf . append ( STRING ) ; buf . append ( factor ) ; buf . append ( STRING ) ; for ( int j = _NUM ; j < getNumParents ( i ) ; j ++ ) { IndexedParent parent = getParent ( i , j ) ; buf . append ( STRING ) ; buf . append ( getFactor ( parent . getIndex ( ) ) ) ; buf . append ( STRING ) ; buf . append ( parent . getLag ( ) ) ; } } buf . append ( STRING ) ; return buf . toString ( ) ; }
public static String formatIntegerIfPossible ( double value , int numberOfDigits , boolean groupingCharacter ) { if ( Double . isNaN ( value ) ) { return STRING ; } if ( Double . isInfinite ( value ) ) { if ( value < _NUM ) { return STRING + FORMAT_SYMBOLS . getInfinity ( ) ; } else { return FORMAT_SYMBOLS . getInfinity ( ) ; } } long longValue = Math . round ( value ) ; if ( Math . abs ( longValue - value ) < epsilonDisplayValue ) { INTEGER_FORMAT . setGroupingUsed ( groupingCharacter ) ; return INTEGER_FORMAT . format ( value ) ; } return formatNumber ( value , numberOfDigits , groupingCharacter ) ; }
public static InetAddress findInetAddress ( ) throws SocketException , UnknownHostException { final Enumeration < NetworkInterface > enum1 = NetworkInterface . getNetworkInterfaces ( ) ; if ( enum1 == null ) { final InetAddress ip1 = InetAddress . getLocalHost ( ) ; return ip1 ; } final List < InetAddress > allButLoopback = new ArrayList < > ( ) ; while ( enum1 . hasMoreElements ( ) ) { final NetworkInterface netface = enum1 . nextElement ( ) ; final Enumeration < InetAddress > enum2 = netface . getInetAddresses ( ) ; while ( enum2 . hasMoreElements ( ) ) { final InetAddress ip2 = enum2 . nextElement ( ) ; if ( ! ip2 . isLoopbackAddress ( ) ) { allButLoopback . add ( ip2 ) ; } } } for ( final InetAddress address : allButLoopback ) { if ( address . getAddress ( ) . length == _NUM && ! isPrivateNetworkAddress ( address ) ) { return address ; } } for ( final InetAddress address : allButLoopback ) { if ( ! isPrivateNetworkAddress ( address ) ) { return address ; } } for ( final InetAddress address : allButLoopback ) { if ( ! address . isLinkLocalAddress ( ) ) { return address ; } } return InetAddress . getLocalHost ( ) ; }
public static InetAddress findInetAddress ( ) throws SocketException , UnknownHostException { final Enumeration < NetworkInterface > enum1 = NetworkInterface . getNetworkInterfaces ( ) ; if ( enum1 == null ) { final InetAddress ip1 = InetAddress . getLocalHost ( ) ; return ip1 ; } final List < InetAddress > allButLoopback = new ArrayList < > ( ) ; while ( enum1 . hasMoreElements ( ) ) { final NetworkInterface netface = enum1 . nextElement ( ) ; final Enumeration < InetAddress > enum2 = netface . getInetAddresses ( ) ; while ( enum2 . hasMoreElements ( ) ) { final InetAddress ip2 = enum2 . nextElement ( ) ; if ( ! ip2 . isLoopbackAddress ( ) ) { allButLoopback . add ( ip2 ) ; } } } for ( final InetAddress address : allButLoopback ) { if ( address . getAddress ( ) . length == _NUM && ! isPrivateNetworkAddress ( address ) ) { return address ; } } for ( final InetAddress address : allButLoopback ) { if ( ! isPrivateNetworkAddress ( address ) ) { return address ; } } for ( final InetAddress address : allButLoopback ) { if ( ! address . isLinkLocalAddress ( ) ) { return address ; } } return InetAddress . getLocalHost ( ) ; }
public static InetAddress findInetAddress ( ) throws SocketException , UnknownHostException { final Enumeration < NetworkInterface > enum1 = NetworkInterface . getNetworkInterfaces ( ) ; if ( enum1 == null ) { final InetAddress ip1 = InetAddress . getLocalHost ( ) ; return ip1 ; } final List < InetAddress > allButLoopback = new ArrayList < > ( ) ; while ( enum1 . hasMoreElements ( ) ) { final NetworkInterface netface = enum1 . nextElement ( ) ; final Enumeration < InetAddress > enum2 = netface . getInetAddresses ( ) ; while ( enum2 . hasMoreElements ( ) ) { final InetAddress ip2 = enum2 . nextElement ( ) ; if ( ! ip2 . isLoopbackAddress ( ) ) { allButLoopback . add ( ip2 ) ; } } } for ( final InetAddress address : allButLoopback ) { if ( address . getAddress ( ) . length == _NUM && ! isPrivateNetworkAddress ( address ) ) { return address ; } } for ( final InetAddress address : allButLoopback ) { if ( ! isPrivateNetworkAddress ( address ) ) { return address ; } } for ( final InetAddress address : allButLoopback ) { if ( ! address . isLinkLocalAddress ( ) ) { return address ; } } return InetAddress . getLocalHost ( ) ; }
public static InetAddress findInetAddress ( ) throws SocketException , UnknownHostException { final Enumeration < NetworkInterface > enum1 = NetworkInterface . getNetworkInterfaces ( ) ; if ( enum1 == null ) { final InetAddress ip1 = InetAddress . getLocalHost ( ) ; return ip1 ; } final List < InetAddress > allButLoopback = new ArrayList < > ( ) ; while ( enum1 . hasMoreElements ( ) ) { final NetworkInterface netface = enum1 . nextElement ( ) ; final Enumeration < InetAddress > enum2 = netface . getInetAddresses ( ) ; while ( enum2 . hasMoreElements ( ) ) { final InetAddress ip2 = enum2 . nextElement ( ) ; if ( ! ip2 . isLoopbackAddress ( ) ) { allButLoopback . add ( ip2 ) ; } } } for ( final InetAddress address : allButLoopback ) { if ( address . getAddress ( ) . length == _NUM && ! isPrivateNetworkAddress ( address ) ) { return address ; } } for ( final InetAddress address : allButLoopback ) { if ( ! isPrivateNetworkAddress ( address ) ) { return address ; } } for ( final InetAddress address : allButLoopback ) { if ( ! address . isLinkLocalAddress ( ) ) { return address ; } } return InetAddress . getLocalHost ( ) ; }
public static InetAddress findInetAddress ( ) throws SocketException , UnknownHostException { final Enumeration < NetworkInterface > enum1 = NetworkInterface . getNetworkInterfaces ( ) ; if ( enum1 == null ) { final InetAddress ip1 = InetAddress . getLocalHost ( ) ; return ip1 ; } final List < InetAddress > allButLoopback = new ArrayList < > ( ) ; while ( enum1 . hasMoreElements ( ) ) { final NetworkInterface netface = enum1 . nextElement ( ) ; final Enumeration < InetAddress > enum2 = netface . getInetAddresses ( ) ; while ( enum2 . hasMoreElements ( ) ) { final InetAddress ip2 = enum2 . nextElement ( ) ; if ( ! ip2 . isLoopbackAddress ( ) ) { allButLoopback . add ( ip2 ) ; } } } for ( final InetAddress address : allButLoopback ) { if ( address . getAddress ( ) . length == _NUM && ! isPrivateNetworkAddress ( address ) ) { return address ; } } for ( final InetAddress address : allButLoopback ) { if ( ! isPrivateNetworkAddress ( address ) ) { return address ; } } for ( final InetAddress address : allButLoopback ) { if ( ! address . isLinkLocalAddress ( ) ) { return address ; } } return InetAddress . getLocalHost ( ) ; }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { super . writeExternal ( out ) ; out . writeObject ( knnDistance ) ; }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { super . writeExternal ( out ) ; out . writeObject ( knnDistance ) ; }
public void save ( ) { doSave ( ) ; messages . info ( STRING + project . getName ( ) + STRING ) ; }
public void save ( ) { doSave ( ) ; messages . info ( STRING + project . getName ( ) + STRING ) ; }
public boolean offer ( E e , long timeout , TimeUnit unit ) throws InterruptedException { if ( e == null ) throw new NullPointerException ( ) ; long nanos = unit . toNanos ( timeout ) ; int c = - _NUM ; final ReentrantLock putLock = this . putLock ; final AtomicInteger count = this . count ; putLock . lockInterruptibly ( ) ; try { while ( count . get ( ) >= capacity ) { if ( nanos <= _NUM ) return _BOOL ; nanos = notFull . awaitNanos ( nanos ) ; } enqueue ( e ) ; c = count . getAndIncrement ( ) ; if ( c + _NUM < capacity ) notFull . signal ( ) ; } finally { putLock . unlock ( ) ; } if ( c == _NUM ) signalNotEmpty ( ) ; return _BOOL ; }
public boolean offer ( E e , long timeout , TimeUnit unit ) throws InterruptedException { if ( e == null ) throw new NullPointerException ( ) ; long nanos = unit . toNanos ( timeout ) ; int c = - _NUM ; final ReentrantLock putLock = this . putLock ; final AtomicInteger count = this . count ; putLock . lockInterruptibly ( ) ; try { while ( count . get ( ) >= capacity ) { if ( nanos <= _NUM ) return _BOOL ; nanos = notFull . awaitNanos ( nanos ) ; } enqueue ( e ) ; c = count . getAndIncrement ( ) ; if ( c + _NUM < capacity ) notFull . signal ( ) ; } finally { putLock . unlock ( ) ; } if ( c == _NUM ) signalNotEmpty ( ) ; return _BOOL ; }
protected static Die die ( String why ) { return new Die ( why ) ; }
protected static Die die ( String why ) { return new Die ( why ) ; }
public int eval ( INode state ) { TinyPuzzle tp = ( TinyPuzzle ) state ; if ( tp . s [ _NUM ] > target [ _NUM ] ) return Integer . MAX_VALUE ; if ( tp . s [ _NUM ] > target [ _NUM ] ) return Integer . MAX_VALUE ; return Math . abs ( target [ _NUM ] - tp . s [ _NUM ] ) + Math . abs ( target [ _NUM ] - tp . s [ _NUM ] ) ; }
public Image addImage ( String location , Image image ) { if ( m_maxImageWidth > - _NUM || m_maxImageHeight > - _NUM ) { image = getScaledImage ( image ) ; image . getWidth ( null ) ; } imageCache . put ( location , image ) ; return image ; }
public void stopAutoFailThread ( ) { if ( isAutoFail ( ) && autoFailThread != null && autoFailThread . isAlive ( ) ) { isTestSuccess . set ( _BOOL ) ; if ( verbose ) { LOG . info ( STRING ) ; } LOG . info ( STRING ) ; autoFailThread . interrupt ( ) ; } }
public void writeRequest ( ) { Object lock = new Object ( ) ; synchronized ( lock ) { synchronized ( this ) { boolean goAheadWithWrite = writerLocks . size ( ) == _NUM && currentReaders == _NUM && currentWriters == _NUM ; if ( goAheadWithWrite ) { ++ currentWriters ; return ; } writerLocks . addLast ( lock ) ; } try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } }
public void writeRequest ( ) { Object lock = new Object ( ) ; synchronized ( lock ) { synchronized ( this ) { boolean goAheadWithWrite = writerLocks . size ( ) == _NUM && currentReaders == _NUM && currentWriters == _NUM ; if ( goAheadWithWrite ) { ++ currentWriters ; return ; } writerLocks . addLast ( lock ) ; } try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } }
public void writeRequest ( ) { Object lock = new Object ( ) ; synchronized ( lock ) { synchronized ( this ) { boolean goAheadWithWrite = writerLocks . size ( ) == _NUM && currentReaders == _NUM && currentWriters == _NUM ; if ( goAheadWithWrite ) { ++ currentWriters ; return ; } writerLocks . addLast ( lock ) ; } try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } }
public void writeRequest ( ) { Object lock = new Object ( ) ; synchronized ( lock ) { synchronized ( this ) { boolean goAheadWithWrite = writerLocks . size ( ) == _NUM && currentReaders == _NUM && currentWriters == _NUM ; if ( goAheadWithWrite ) { ++ currentWriters ; return ; } writerLocks . addLast ( lock ) ; } try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } }
public void writeRequest ( ) { Object lock = new Object ( ) ; synchronized ( lock ) { synchronized ( this ) { boolean goAheadWithWrite = writerLocks . size ( ) == _NUM && currentReaders == _NUM && currentWriters == _NUM ; if ( goAheadWithWrite ) { ++ currentWriters ; return ; } writerLocks . addLast ( lock ) ; } try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } }
@ Override public synchronized void reset ( ) throws IOException { try { buffer . reset ( ) ; } catch ( InvalidMarkException e ) { throw new IOException ( STRING ) ; } }
public static void silentCloseOutputStream ( OutputStream os ) { try { if ( os != null ) { os . close ( ) ; } } catch ( IOException e ) { log . w ( LOG_TAG , STRING , e ) ; } }
public static void silentCloseOutputStream ( OutputStream os ) { try { if ( os != null ) { os . close ( ) ; } } catch ( IOException e ) { log . w ( LOG_TAG , STRING , e ) ; } }
public static void silentCloseOutputStream ( OutputStream os ) { try { if ( os != null ) { os . close ( ) ; } } catch ( IOException e ) { log . w ( LOG_TAG , STRING , e ) ; } }
public VNXeCommandJob createLunsInConsistencyGroup ( List < String > names , String poolId , Long size , boolean isThin , String tieringPolicy , String cgId ) { _logger . info ( STRING , cgId ) ; LunGroupModifyParam param = new LunGroupModifyParam ( ) ; List < LunCreateParam > lunCreates = new ArrayList < LunCreateParam > ( ) ; boolean isPolicyOn = _BOOL ; FastVPParam fastVP = new FastVPParam ( ) ; if ( tieringPolicy != null && ! tieringPolicy . isEmpty ( ) ) { TieringPolicyEnum tierValue = TieringPolicyEnum . valueOf ( tieringPolicy ) ; if ( tierValue != null ) { fastVP . setTieringPolicy ( tierValue . getValue ( ) ) ; isPolicyOn = _BOOL ; } } for ( String lunName : names ) { LunParam lunParam = new LunParam ( ) ; lunParam . setIsThinEnabled ( isThin ) ; lunParam . setSize ( size ) ; lunParam . setPool ( new VNXeBase ( poolId ) ) ; LunCreateParam createParam = new LunCreateParam ( ) ; createParam . setName ( lunName ) ; createParam . setLunParameters ( lunParam ) ; if ( isPolicyOn ) { lunParam . setFastVPParameters ( fastVP ) ; } lunCreates . add ( createParam ) ; } param . setLunCreate ( lunCreates ) ; ConsistencyGroupRequests req = new ConsistencyGroupRequests ( _khClient ) ; return req . modifyConsistencyGroupAsync ( cgId , param ) ; }
public VNXeCommandJob createLunsInConsistencyGroup ( List < String > names , String poolId , Long size , boolean isThin , String tieringPolicy , String cgId ) { _logger . info ( STRING , cgId ) ; LunGroupModifyParam param = new LunGroupModifyParam ( ) ; List < LunCreateParam > lunCreates = new ArrayList < LunCreateParam > ( ) ; boolean isPolicyOn = _BOOL ; FastVPParam fastVP = new FastVPParam ( ) ; if ( tieringPolicy != null && ! tieringPolicy . isEmpty ( ) ) { TieringPolicyEnum tierValue = TieringPolicyEnum . valueOf ( tieringPolicy ) ; if ( tierValue != null ) { fastVP . setTieringPolicy ( tierValue . getValue ( ) ) ; isPolicyOn = _BOOL ; } } for ( String lunName : names ) { LunParam lunParam = new LunParam ( ) ; lunParam . setIsThinEnabled ( isThin ) ; lunParam . setSize ( size ) ; lunParam . setPool ( new VNXeBase ( poolId ) ) ; LunCreateParam createParam = new LunCreateParam ( ) ; createParam . setName ( lunName ) ; createParam . setLunParameters ( lunParam ) ; if ( isPolicyOn ) { lunParam . setFastVPParameters ( fastVP ) ; } lunCreates . add ( createParam ) ; } param . setLunCreate ( lunCreates ) ; ConsistencyGroupRequests req = new ConsistencyGroupRequests ( _khClient ) ; return req . modifyConsistencyGroupAsync ( cgId , param ) ; }
void make ( BulkTest bulk ) { Class c = bulk . getClass ( ) ; Method [ ] all = c . getMethods ( ) ; for ( int i = _NUM ; i < all . length ; i ++ ) { if ( isTest ( all [ i ] ) ) addTest ( bulk , all [ i ] ) ; if ( isBulk ( all [ i ] ) ) addBulk ( bulk , all [ i ] ) ; } }
void make ( BulkTest bulk ) { Class c = bulk . getClass ( ) ; Method [ ] all = c . getMethods ( ) ; for ( int i = _NUM ; i < all . length ; i ++ ) { if ( isTest ( all [ i ] ) ) addTest ( bulk , all [ i ] ) ; if ( isBulk ( all [ i ] ) ) addBulk ( bulk , all [ i ] ) ; } }
private DateTimeZone loadZoneData ( String id ) { InputStream in = null ; try { in = openResource ( id ) ; DateTimeZone tz = DateTimeZoneBuilder . readFrom ( in , id ) ; iZoneInfoMap . put ( id , new SoftReference < DateTimeZone > ( tz ) ) ; return tz ; } catch ( IOException ex ) { uncaughtException ( ex ) ; iZoneInfoMap . remove ( id ) ; return null ; } finally { try { if ( in != null ) { in . close ( ) ; } } catch ( IOException ex ) { } } }
public void simulateMethod ( SootMethod method , ReferenceVariable thisVar , ReferenceVariable returnVar , ReferenceVariable params [ ] ) { String subSignature = method . getSubSignature ( ) ; if ( subSignature . equals ( STRING ) ) { java_util_ResourceBundle_getClassContext ( method , thisVar , returnVar , params ) ; return ; } else { defaultMethod ( method , thisVar , returnVar , params ) ; return ; } }
public void simulateMethod ( SootMethod method , ReferenceVariable thisVar , ReferenceVariable returnVar , ReferenceVariable params [ ] ) { String subSignature = method . getSubSignature ( ) ; if ( subSignature . equals ( STRING ) ) { java_util_ResourceBundle_getClassContext ( method , thisVar , returnVar , params ) ; return ; } else { defaultMethod ( method , thisVar , returnVar , params ) ; return ; } }
public final void put ( String key , int value ) { if ( ( m_firstFree + _NUM ) >= m_mapSize ) { m_mapSize += m_blocksize ; String newMap [ ] = new String [ m_mapSize ] ; System . arraycopy ( m_map , _NUM , newMap , _NUM , m_firstFree + _NUM ) ; m_map = newMap ; int newValues [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_values , _NUM , newValues , _NUM , m_firstFree + _NUM ) ; m_values = newValues ; } m_map [ m_firstFree ] = key ; m_values [ m_firstFree ] = value ; m_firstFree ++ ; }
public Synapse ( Neuron source , Neuron target ) { setSourceAndTarget ( source , target ) ; initSpikeResponder ( ) ; if ( source != null ) { parentNetwork = source . getNetwork ( ) ; } isTemplate = source == null ; }
public Synapse ( Neuron source , Neuron target ) { setSourceAndTarget ( source , target ) ; initSpikeResponder ( ) ; if ( source != null ) { parentNetwork = source . getNetwork ( ) ; } isTemplate = source == null ; }
public Synapse ( Neuron source , Neuron target ) { setSourceAndTarget ( source , target ) ; initSpikeResponder ( ) ; if ( source != null ) { parentNetwork = source . getNetwork ( ) ; } isTemplate = source == null ; }
public void updateHold ( @ Nullable Object key , Instant newHold ) { removeHold ( key ) ; KeyedHold newKeyedHold = KeyedHold . of ( key , newHold ) ; keyedHolds . put ( key , newKeyedHold ) ; allHolds . offer ( newKeyedHold ) ; }
public static AlertDialogHelper newInstance ( final Fragment container , final int id , final int title , final int message , final String args , final boolean neutralOnly ) { final AlertDialogHelper frag = new AlertDialogHelper ( ) ; frag . setTargetFragment ( container , id ) ; final Bundle bundle = new Bundle ( ) ; bundle . putInt ( STRING , id ) ; bundle . putInt ( STRING , title ) ; bundle . putInt ( STRING , message ) ; bundle . putString ( STRING , args ) ; bundle . putBoolean ( STRING , neutralOnly ) ; frag . setArguments ( bundle ) ; return frag ; }
private Token createVmArgsToken ( ) { StringBuilder jvmArgs = new StringBuilder ( ) ; File hotFixJar = new File ( jrunContainer . getHome ( ) + STRING ) ; if ( hotFixJar . exists ( ) ) { jvmArgs . append ( STRING ) ; } jvmArgs . append ( STRING ) ; jvmArgs . append ( STRING ) ; jvmArgs . append ( STRING ) ; jvmArgs . append ( STRING ) ; ReplaceTokens . Token tokenVmArgs = new ReplaceTokens . Token ( ) ; tokenVmArgs . setKey ( STRING ) ; tokenVmArgs . setValue ( jvmArgs . toString ( ) ) ; return tokenVmArgs ; }
public DImportKeyPairOpenSsl ( JFrame parent ) { super ( parent , Dialog . ModalityType . DOCUMENT_MODAL ) ; initComponents ( ) ; }
public static ServerSideSortRequestControl newControl ( final boolean isCritical , final Collection < SortKey > keys ) { Reject . ifNull ( keys ) ; Reject . ifFalse ( ! keys . isEmpty ( ) , STRING ) ; return new ServerSideSortRequestControl ( isCritical , Collections . unmodifiableList ( new ArrayList < SortKey > ( keys ) ) ) ; }
static void appendVmErgoMessage ( boolean isServerClass , String vm ) { outBuf = outBuf . append ( getLocalizedMessage ( STRING , vm ) ) ; outBuf = ( isServerClass ) ? outBuf . append ( STRING + getLocalizedMessage ( STRING ) + STRING ) : outBuf . append ( STRING ) ; }
public long count ( ) { return cnt . get ( ) ; }
public static String findCodeBaseInClassPath ( Pattern codeBaseNamePattern , String classPath ) { if ( classPath == null ) { return null ; } StringTokenizer tok = new StringTokenizer ( classPath , File . pathSeparator ) ; while ( tok . hasMoreTokens ( ) ) { String t = tok . nextToken ( ) ; File f = new File ( t ) ; Matcher m = codeBaseNamePattern . matcher ( f . getName ( ) ) ; if ( m . matches ( ) ) { return t ; } } return null ; }
public static String findCodeBaseInClassPath ( Pattern codeBaseNamePattern , String classPath ) { if ( classPath == null ) { return null ; } StringTokenizer tok = new StringTokenizer ( classPath , File . pathSeparator ) ; while ( tok . hasMoreTokens ( ) ) { String t = tok . nextToken ( ) ; File f = new File ( t ) ; Matcher m = codeBaseNamePattern . matcher ( f . getName ( ) ) ; if ( m . matches ( ) ) { return t ; } } return null ; }
public synchronized void addSelectionListener ( SelectionListener listener ) { if ( listeners == null ) { listeners = new Vector < SelectionListener > ( ) ; } listeners . addElement ( listener ) ; }
public static void storeLocation ( Context context , LatLng location ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putLong ( PREFERENCES_LAT , Double . doubleToRawLongBits ( location . latitude ) ) ; editor . putLong ( PREFERENCES_LNG , Double . doubleToRawLongBits ( location . longitude ) ) ; editor . apply ( ) ; }
public static void storeLocation ( Context context , LatLng location ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putLong ( PREFERENCES_LAT , Double . doubleToRawLongBits ( location . latitude ) ) ; editor . putLong ( PREFERENCES_LNG , Double . doubleToRawLongBits ( location . longitude ) ) ; editor . apply ( ) ; }
public ObjectInstance ( ObjectName objectName , String className ) { if ( objectName . isPattern ( ) ) { final IllegalArgumentException iae = new IllegalArgumentException ( STRING + objectName . toString ( ) ) ; throw new RuntimeOperationsException ( iae ) ; } this . name = objectName ; this . className = className ; }
protected Resource createResource ( final Element resourceElement ) { final String uri = resourceElement . getTextContent ( ) ; final String minimizeAsString = resourceElement . getAttribute ( ATTR_MINIMIZE ) ; final boolean minimize = StringUtils . isEmpty ( minimizeAsString ) || Boolean . valueOf ( minimizeAsString ) ; final Resource resource = Resource . create ( uri , getResourceType ( resourceElement ) ) ; resource . setMinimize ( minimize ) ; return resource ; }
protected Resource createResource ( final Element resourceElement ) { final String uri = resourceElement . getTextContent ( ) ; final String minimizeAsString = resourceElement . getAttribute ( ATTR_MINIMIZE ) ; final boolean minimize = StringUtils . isEmpty ( minimizeAsString ) || Boolean . valueOf ( minimizeAsString ) ; final Resource resource = Resource . create ( uri , getResourceType ( resourceElement ) ) ; resource . setMinimize ( minimize ) ; return resource ; }
protected Resource createResource ( final Element resourceElement ) { final String uri = resourceElement . getTextContent ( ) ; final String minimizeAsString = resourceElement . getAttribute ( ATTR_MINIMIZE ) ; final boolean minimize = StringUtils . isEmpty ( minimizeAsString ) || Boolean . valueOf ( minimizeAsString ) ; final Resource resource = Resource . create ( uri , getResourceType ( resourceElement ) ) ; resource . setMinimize ( minimize ) ; return resource ; }
public static ObjectOutputStream newObjectOutputStream ( Path self ) throws IOException { return new ObjectOutputStream ( Files . newOutputStream ( self ) ) ; }
public boolean hasPayload ( ) { return ( payload == null ) ? _BOOL : payload . hasPayload ( ) ; }
public boolean hasPayload ( ) { return ( payload == null ) ? _BOOL : payload . hasPayload ( ) ; }
void composeTemplates ( ElemTemplateElement templ ) throws TransformerException { templ . compose ( this ) ; for ( ElemTemplateElement child = templ . getFirstChildElem ( ) ; child != null ; child = child . getNextSiblingElem ( ) ) { composeTemplates ( child ) ; } templ . endCompose ( this ) ; }
protected void sendFunctionGroup1 ( ) { sendUpdate ( ) ; }
public void resolve ( Class type , String value ) throws Exception { String name = type . getName ( ) ; read . put ( value , name ) ; write . put ( name , value ) ; }
public void resolve ( Class type , String value ) throws Exception { String name = type . getName ( ) ; read . put ( value , name ) ; write . put ( name , value ) ; }
public void resolve ( Class type , String value ) throws Exception { String name = type . getName ( ) ; read . put ( value , name ) ; write . put ( name , value ) ; }
public void resolve ( Class type , String value ) throws Exception { String name = type . getName ( ) ; read . put ( value , name ) ; write . put ( name , value ) ; }
public void resolve ( Class type , String value ) throws Exception { String name = type . getName ( ) ; read . put ( value , name ) ; write . put ( name , value ) ; }
public void resolve ( Class type , String value ) throws Exception { String name = type . getName ( ) ; read . put ( value , name ) ; write . put ( name , value ) ; }
public int capacity ( ) { return internal . capacity ( ) ; }
public int capacity ( ) { return internal . capacity ( ) ; }
public static String extract ( String s ) { String result ; result = s ; result = result . replaceAll ( STRING , STRING ) ; result = result . replaceAll ( STRING , STRING ) ; result = result . replaceAll ( STRING , STRING ) ; return result ; }
private void enableDeviceCapabilitiesArea ( boolean enabled ) { mDisableCameraCheckbox . setEnabled ( enabled ) ; mDisableKeyguardWidgetsCheckbox . setEnabled ( enabled ) ; mDisableKeyguardSecureCameraCheckbox . setEnabled ( enabled ) ; mDisableKeyguardNotificationCheckbox . setEnabled ( enabled ) ; mDisableKeyguardUnredactedCheckbox . setEnabled ( enabled ) ; mDisableKeyguardTrustAgentCheckbox . setEnabled ( enabled ) ; }
private void enableDeviceCapabilitiesArea ( boolean enabled ) { mDisableCameraCheckbox . setEnabled ( enabled ) ; mDisableKeyguardWidgetsCheckbox . setEnabled ( enabled ) ; mDisableKeyguardSecureCameraCheckbox . setEnabled ( enabled ) ; mDisableKeyguardNotificationCheckbox . setEnabled ( enabled ) ; mDisableKeyguardUnredactedCheckbox . setEnabled ( enabled ) ; mDisableKeyguardTrustAgentCheckbox . setEnabled ( enabled ) ; }
private void abortLoading ( ) { if ( thread == null ) return ; if ( thread . isAlive ( ) ) { thread . interrupt ( ) ; try { thread . join ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
private void abortLoading ( ) { if ( thread == null ) return ; if ( thread . isAlive ( ) ) { thread . interrupt ( ) ; try { thread . join ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
private String parseTimeFromPing ( String ping ) { String time = STRING ; if ( ping . contains ( TIME_PING ) ) { int index = ping . indexOf ( TIME_PING ) ; time = ping . substring ( index + _NUM ) ; index = time . indexOf ( STRING ) ; time = time . substring ( _NUM , index ) ; } return time ; }
private void restoreIcon ( BackupProtos . Key key , byte [ ] buffer , int dataSize ) throws IOException { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base64 . encodeToString ( buffer , _NUM , dataSize , Base64 . NO_WRAP ) ) ; BackupProtos . Resource res = unpackProto ( new BackupProtos . Resource ( ) , buffer , dataSize ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = BitmapFactory . decodeByteArray ( res . data , _NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } else { if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; mIconCache . preloadIcon ( ComponentName . unflattenFromString ( key . name ) , icon , res . dpi , STRING , mUserSerial , mIdp ) ; } }
private void restoreIcon ( BackupProtos . Key key , byte [ ] buffer , int dataSize ) throws IOException { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base64 . encodeToString ( buffer , _NUM , dataSize , Base64 . NO_WRAP ) ) ; BackupProtos . Resource res = unpackProto ( new BackupProtos . Resource ( ) , buffer , dataSize ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = BitmapFactory . decodeByteArray ( res . data , _NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } else { if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; mIconCache . preloadIcon ( ComponentName . unflattenFromString ( key . name ) , icon , res . dpi , STRING , mUserSerial , mIdp ) ; } }
private void restoreIcon ( BackupProtos . Key key , byte [ ] buffer , int dataSize ) throws IOException { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base64 . encodeToString ( buffer , _NUM , dataSize , Base64 . NO_WRAP ) ) ; BackupProtos . Resource res = unpackProto ( new BackupProtos . Resource ( ) , buffer , dataSize ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = BitmapFactory . decodeByteArray ( res . data , _NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } else { if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; mIconCache . preloadIcon ( ComponentName . unflattenFromString ( key . name ) , icon , res . dpi , STRING , mUserSerial , mIdp ) ; } }
private void restoreIcon ( BackupProtos . Key key , byte [ ] buffer , int dataSize ) throws IOException { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base64 . encodeToString ( buffer , _NUM , dataSize , Base64 . NO_WRAP ) ) ; BackupProtos . Resource res = unpackProto ( new BackupProtos . Resource ( ) , buffer , dataSize ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = BitmapFactory . decodeByteArray ( res . data , _NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } else { if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; mIconCache . preloadIcon ( ComponentName . unflattenFromString ( key . name ) , icon , res . dpi , STRING , mUserSerial , mIdp ) ; } }
private void restoreIcon ( BackupProtos . Key key , byte [ ] buffer , int dataSize ) throws IOException { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base64 . encodeToString ( buffer , _NUM , dataSize , Base64 . NO_WRAP ) ) ; BackupProtos . Resource res = unpackProto ( new BackupProtos . Resource ( ) , buffer , dataSize ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = BitmapFactory . decodeByteArray ( res . data , _NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } else { if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; mIconCache . preloadIcon ( ComponentName . unflattenFromString ( key . name ) , icon , res . dpi , STRING , mUserSerial , mIdp ) ; } }
protected void updateMenu ( ) { boolean present ; boolean initializing ; boolean running ; boolean stopping ; boolean active ; if ( m_MenuBar == null ) return ; present = ( m_Experiment != null ) ; initializing = present && m_Experiment . isInitializing ( ) ; running = present && m_Experiment . isRunning ( ) ; stopping = present && m_Experiment . isStopping ( ) ; active = initializing || running || stopping ; m_MenuItemFileNew . setEnabled ( ! active ) ; m_MenuItemFileOpen . setEnabled ( ! active ) ; m_MenuItemFileSave . setEnabled ( present && ( getCurrentFile ( ) != null ) ) ; m_MenuItemFileSaveAs . setEnabled ( present ) ; m_MenuItemFileClose . setEnabled ( ! active ) ; m_MenuItemExecutionStart . setEnabled ( present && ! active ) ; m_MenuItemExecutionStop . setEnabled ( present && running ) ; for ( AbstractExperimenterMenuItem item : m_AdditionalMenuItems . keySet ( ) ) item . update ( this , m_AdditionalMenuItems . get ( item ) ) ; }
public SharedIteratorSpaceDataSourceDecorator ( SpaceDataSource spaceDataSource , long timeToLive ) { _spaceDataSource = spaceDataSource ; _timeToLive = timeToLive ; _queryToSources = new ConcurrentHashMap < DataSourceSQLQuery , SharedDataIteratorSource < Object > > ( ) ; _sourcesToQuery = new ConcurrentHashMap < SharedDataIteratorSource < Object > , DataSourceSQLQuery > ( ) ; }
public static String convertDateToISO8601 ( Date date ) { DateFormat dateFormat = new SimpleDateFormat ( STRING ) ; return dateFormat . format ( date ) ; }
public static String convertDateToISO8601 ( Date date ) { DateFormat dateFormat = new SimpleDateFormat ( STRING ) ; return dateFormat . format ( date ) ; }
public void addToAssociated ( Message asMessage ) { associatedMessages . add ( asMessage ) ; }
public boolean addOwner ( Principal caller , Principal owner ) throws NotOwnerException { if ( ! ownerList . contains ( caller ) ) throw new NotOwnerException ( ) ; if ( ownerList . contains ( owner ) ) { return _BOOL ; } else { ownerList . addElement ( owner ) ; return _BOOL ; } }
public boolean addOwner ( Principal caller , Principal owner ) throws NotOwnerException { if ( ! ownerList . contains ( caller ) ) throw new NotOwnerException ( ) ; if ( ownerList . contains ( owner ) ) { return _BOOL ; } else { ownerList . addElement ( owner ) ; return _BOOL ; } }
public boolean addOwner ( Principal caller , Principal owner ) throws NotOwnerException { if ( ! ownerList . contains ( caller ) ) throw new NotOwnerException ( ) ; if ( ownerList . contains ( owner ) ) { return _BOOL ; } else { ownerList . addElement ( owner ) ; return _BOOL ; } }
public boolean addOwner ( Principal caller , Principal owner ) throws NotOwnerException { if ( ! ownerList . contains ( caller ) ) throw new NotOwnerException ( ) ; if ( ownerList . contains ( owner ) ) { return _BOOL ; } else { ownerList . addElement ( owner ) ; return _BOOL ; } }
public boolean addOwner ( Principal caller , Principal owner ) throws NotOwnerException { if ( ! ownerList . contains ( caller ) ) throw new NotOwnerException ( ) ; if ( ownerList . contains ( owner ) ) { return _BOOL ; } else { ownerList . addElement ( owner ) ; return _BOOL ; } }
public boolean addOwner ( Principal caller , Principal owner ) throws NotOwnerException { if ( ! ownerList . contains ( caller ) ) throw new NotOwnerException ( ) ; if ( ownerList . contains ( owner ) ) { return _BOOL ; } else { ownerList . addElement ( owner ) ; return _BOOL ; } }
public boolean addOwner ( Principal caller , Principal owner ) throws NotOwnerException { if ( ! ownerList . contains ( caller ) ) throw new NotOwnerException ( ) ; if ( ownerList . contains ( owner ) ) { return _BOOL ; } else { ownerList . addElement ( owner ) ; return _BOOL ; } }
public void waitForActiveLocks ( ) throws InterruptedException { long now = - _NUM ; while ( _BOOL ) { boolean nochange ; Set < WeakLockReference > before ; synchronized ( activeLocks ) { if ( activeLocks . isEmpty ( ) ) return ; before = new HashSet < WeakLockReference > ( activeLocks ) ; if ( now < _NUM ) { now = System . currentTimeMillis ( ) ; } activeLocks . wait ( waitToCollect ) ; if ( activeLocks . isEmpty ( ) ) return ; nochange = before . equals ( activeLocks ) ; } if ( nochange && System . currentTimeMillis ( ) - now >= waitToCollect / _NUM ) { releaseAbandoned ( ) ; now = - _NUM ; } } }
public void waitForActiveLocks ( ) throws InterruptedException { long now = - _NUM ; while ( _BOOL ) { boolean nochange ; Set < WeakLockReference > before ; synchronized ( activeLocks ) { if ( activeLocks . isEmpty ( ) ) return ; before = new HashSet < WeakLockReference > ( activeLocks ) ; if ( now < _NUM ) { now = System . currentTimeMillis ( ) ; } activeLocks . wait ( waitToCollect ) ; if ( activeLocks . isEmpty ( ) ) return ; nochange = before . equals ( activeLocks ) ; } if ( nochange && System . currentTimeMillis ( ) - now >= waitToCollect / _NUM ) { releaseAbandoned ( ) ; now = - _NUM ; } } }
public void waitForActiveLocks ( ) throws InterruptedException { long now = - _NUM ; while ( _BOOL ) { boolean nochange ; Set < WeakLockReference > before ; synchronized ( activeLocks ) { if ( activeLocks . isEmpty ( ) ) return ; before = new HashSet < WeakLockReference > ( activeLocks ) ; if ( now < _NUM ) { now = System . currentTimeMillis ( ) ; } activeLocks . wait ( waitToCollect ) ; if ( activeLocks . isEmpty ( ) ) return ; nochange = before . equals ( activeLocks ) ; } if ( nochange && System . currentTimeMillis ( ) - now >= waitToCollect / _NUM ) { releaseAbandoned ( ) ; now = - _NUM ; } } }
public static boolean dateIsValid ( String dateString ) { return dateString . matches ( DEFAULT_DATE_REGEX ) ; }
protected void drawTickMarksVertical ( Graphics2D g2 , AxisState state , Rectangle2D dataArea , RectangleEdge edge ) { }
protected void drawTickMarksVertical ( Graphics2D g2 , AxisState state , Rectangle2D dataArea , RectangleEdge edge ) { }
protected double kernelLP ( int n , char [ ] s , int endIndexS , char [ ] t , int endIndexT , int remainingMatchLength ) { if ( Math . min ( endIndexS + _NUM , endIndexT + _NUM ) < n ) { return getReturnValue ( n ) ; } if ( remainingMatchLength == _NUM ) { return getReturnValue ( n ) ; } double result = _NUM ; for ( int iS = endIndexS ; iS > n - _NUM ; iS -- ) { double buf = _NUM ; char x = s [ iS ] ; for ( int j = _NUM ; j <= endIndexT ; j ++ ) { if ( t [ j ] == x ) { buf += kernelHelperLP ( n - _NUM , s , iS - _NUM , t , j - _NUM , remainingMatchLength - _NUM ) ; } } result += buf * m_powersOflambda [ _NUM ] ; } return result ; }
protected double kernelLP ( int n , char [ ] s , int endIndexS , char [ ] t , int endIndexT , int remainingMatchLength ) { if ( Math . min ( endIndexS + _NUM , endIndexT + _NUM ) < n ) { return getReturnValue ( n ) ; } if ( remainingMatchLength == _NUM ) { return getReturnValue ( n ) ; } double result = _NUM ; for ( int iS = endIndexS ; iS > n - _NUM ; iS -- ) { double buf = _NUM ; char x = s [ iS ] ; for ( int j = _NUM ; j <= endIndexT ; j ++ ) { if ( t [ j ] == x ) { buf += kernelHelperLP ( n - _NUM , s , iS - _NUM , t , j - _NUM , remainingMatchLength - _NUM ) ; } } result += buf * m_powersOflambda [ _NUM ] ; } return result ; }
protected double kernelLP ( int n , char [ ] s , int endIndexS , char [ ] t , int endIndexT , int remainingMatchLength ) { if ( Math . min ( endIndexS + _NUM , endIndexT + _NUM ) < n ) { return getReturnValue ( n ) ; } if ( remainingMatchLength == _NUM ) { return getReturnValue ( n ) ; } double result = _NUM ; for ( int iS = endIndexS ; iS > n - _NUM ; iS -- ) { double buf = _NUM ; char x = s [ iS ] ; for ( int j = _NUM ; j <= endIndexT ; j ++ ) { if ( t [ j ] == x ) { buf += kernelHelperLP ( n - _NUM , s , iS - _NUM , t , j - _NUM , remainingMatchLength - _NUM ) ; } } result += buf * m_powersOflambda [ _NUM ] ; } return result ; }
protected double kernelLP ( int n , char [ ] s , int endIndexS , char [ ] t , int endIndexT , int remainingMatchLength ) { if ( Math . min ( endIndexS + _NUM , endIndexT + _NUM ) < n ) { return getReturnValue ( n ) ; } if ( remainingMatchLength == _NUM ) { return getReturnValue ( n ) ; } double result = _NUM ; for ( int iS = endIndexS ; iS > n - _NUM ; iS -- ) { double buf = _NUM ; char x = s [ iS ] ; for ( int j = _NUM ; j <= endIndexT ; j ++ ) { if ( t [ j ] == x ) { buf += kernelHelperLP ( n - _NUM , s , iS - _NUM , t , j - _NUM , remainingMatchLength - _NUM ) ; } } result += buf * m_powersOflambda [ _NUM ] ; } return result ; }
private void remove ( PollController conn ) { if ( conn == null ) { return ; } JniSocketImpl socket = ( JniSocketImpl ) conn . getSocket ( ) ; int nativeFd = socket . getNativeFd ( ) ; if ( _lifecycle . isDestroyed ( ) ) { return ; } _activeCount . incrementAndGet ( ) ; if ( nativeFd > _NUM ) { try { removeNative ( _fd , nativeFd ) ; } catch ( Throwable e ) { log . log ( Level . WARNING , e . toString ( ) , e ) ; _lifecycle . toError ( ) ; } } conn . toKeepaliveClose ( ) ; if ( _activeCount . decrementAndGet ( ) == _NUM && _lifecycle . isDestroyed ( ) ) { destroy ( ) ; } }
public static final String repeatString ( String sStr , int iTimes ) { StringBuffer sb = new StringBuffer ( ) ; for ( int iCnt = _NUM ; iCnt < iTimes ; iCnt ++ ) sb . append ( sStr ) ; return sb . toString ( ) ; }
public void add ( int position , Product product ) { relatedProducts . add ( position , product ) ; notifyItemInserted ( position ) ; }
public final void onBeforeStart ( ) { if ( ! startedFlag . compareAndSet ( _BOOL , _BOOL ) ) throw new IllegalStateException ( STRING + STRING + STRING + this + STRING ) ; }
static int nextPowerOfTwo ( int val ) { int highestBit = Integer . highestOneBit ( val ) ; if ( highestBit == val ) { return val ; } else { return highestBit << _NUM ; } }
static int nextPowerOfTwo ( int val ) { int highestBit = Integer . highestOneBit ( val ) ; if ( highestBit == val ) { return val ; } else { return highestBit << _NUM ; } }
@ edu . umd . cs . findbugs . annotations . SuppressFBWarnings ( value = STRING , justification = STRING ) public void changeLocoSpeed ( DccThrottle t , Block blk , float speed ) { if ( blk == referenced && speed == desiredSpeedStep ) { return ; } float blockLength = blk . getLengthMm ( ) ; if ( blk == referenced ) { distanceRemaining = distanceRemaining - getDistanceTravelled ( _throttle . getIsForward ( ) , _throttle . getSpeedSetting ( ) , ( ( float ) ( System . nanoTime ( ) - lastTimeTimerStarted ) / _NUM ) ) ; blockLength = distanceRemaining ; log . debug ( STRING ) ; } else { referenced = blk ; } changeLocoSpeed ( t , blockLength , speed ) ; }
@ edu . umd . cs . findbugs . annotations . SuppressFBWarnings ( value = STRING , justification = STRING ) public void changeLocoSpeed ( DccThrottle t , Block blk , float speed ) { if ( blk == referenced && speed == desiredSpeedStep ) { return ; } float blockLength = blk . getLengthMm ( ) ; if ( blk == referenced ) { distanceRemaining = distanceRemaining - getDistanceTravelled ( _throttle . getIsForward ( ) , _throttle . getSpeedSetting ( ) , ( ( float ) ( System . nanoTime ( ) - lastTimeTimerStarted ) / _NUM ) ) ; blockLength = distanceRemaining ; log . debug ( STRING ) ; } else { referenced = blk ; } changeLocoSpeed ( t , blockLength , speed ) ; }
@ edu . umd . cs . findbugs . annotations . SuppressFBWarnings ( value = STRING , justification = STRING ) public void changeLocoSpeed ( DccThrottle t , Block blk , float speed ) { if ( blk == referenced && speed == desiredSpeedStep ) { return ; } float blockLength = blk . getLengthMm ( ) ; if ( blk == referenced ) { distanceRemaining = distanceRemaining - getDistanceTravelled ( _throttle . getIsForward ( ) , _throttle . getSpeedSetting ( ) , ( ( float ) ( System . nanoTime ( ) - lastTimeTimerStarted ) / _NUM ) ) ; blockLength = distanceRemaining ; log . debug ( STRING ) ; } else { referenced = blk ; } changeLocoSpeed ( t , blockLength , speed ) ; }
public synchronized void add ( final IProgressOperation operation ) { m_operations . add ( operation ) ; for ( final IGlobalProgressManagerListener listener : m_listeners ) { try { listener . added ( operation ) ; } catch ( final Exception exception ) { CUtilityFunctions . logException ( exception ) ; } } }
public static Map < String , Object > performFindList ( DispatchContext dctx , Map < String , Object > context ) { Integer viewSize = ( Integer ) context . get ( STRING ) ; if ( viewSize == null ) viewSize = Integer . valueOf ( _NUM ) ; context . put ( STRING , viewSize ) ; Integer viewIndex = ( Integer ) context . get ( STRING ) ; if ( viewIndex == null ) viewIndex = Integer . valueOf ( _NUM ) ; context . put ( STRING , viewIndex ) ; Map < String , Object > result = performFind ( dctx , context ) ; int start = viewIndex . intValue ( ) * viewSize . intValue ( ) ; List < GenericValue > list = null ; Integer listSize = null ; try { EntityListIterator it = ( EntityListIterator ) result . get ( STRING ) ; list = it . getPartialList ( start + _NUM , viewSize ) ; listSize = it . getResultsSizeAfterPartialList ( ) ; it . close ( ) ; } catch ( Exception e ) { Debug . logInfo ( STRING + e , module ) ; } result . put ( STRING , listSize ) ; result . put ( STRING , list ) ; result . remove ( STRING ) ; return result ; }
public void writeTo ( final PacketOutputStream os ) { os . write ( ParameterWriter . QUOTE ) ; os . write ( dateToBytes ( ) ) ; ParameterWriter . formatMicroseconds ( os , ( int ) ( time . getTime ( ) % _NUM ) * _NUM , fractionalSeconds ) ; os . write ( ParameterWriter . QUOTE ) ; }
public void writeTo ( final PacketOutputStream os ) { os . write ( ParameterWriter . QUOTE ) ; os . write ( dateToBytes ( ) ) ; ParameterWriter . formatMicroseconds ( os , ( int ) ( time . getTime ( ) % _NUM ) * _NUM , fractionalSeconds ) ; os . write ( ParameterWriter . QUOTE ) ; }
public static Experiment createExperimentWithRule ( ) { Experiment experiment = ExperimentFactory . createExperiment ( ) ; experiment . rule = STRING ; return experiment ; }
public static void removeAllUsers ( ) { Preferences prefs = getPrefs ( ) ; prefs . remove ( USERS ) ; prefs . remove ( ACTIVE_USER ) ; flushPrefs ( prefs ) ; }
public static void removeAllUsers ( ) { Preferences prefs = getPrefs ( ) ; prefs . remove ( USERS ) ; prefs . remove ( ACTIVE_USER ) ; flushPrefs ( prefs ) ; }
public synchronized void search ( String searchString , boolean regexp ) { int i ; SearchParameters params ; m_RegExpSearch = regexp ; m_SearchString = searchString ; params = new SearchParameters ( m_SearchString , m_RegExpSearch ) ; if ( m_SearchString == null ) { m_DisplayIndices = null ; } else { m_DisplayIndices = new TIntArrayList ( ) ; for ( i = _NUM ; i < getActualRowCount ( ) ; i ++ ) { if ( isSearchMatch ( params , m_SortedIndices [ i ] ) ) m_DisplayIndices . add ( i ) ; } } fireTableDataChanged ( ) ; }
public synchronized void search ( String searchString , boolean regexp ) { int i ; SearchParameters params ; m_RegExpSearch = regexp ; m_SearchString = searchString ; params = new SearchParameters ( m_SearchString , m_RegExpSearch ) ; if ( m_SearchString == null ) { m_DisplayIndices = null ; } else { m_DisplayIndices = new TIntArrayList ( ) ; for ( i = _NUM ; i < getActualRowCount ( ) ; i ++ ) { if ( isSearchMatch ( params , m_SortedIndices [ i ] ) ) m_DisplayIndices . add ( i ) ; } } fireTableDataChanged ( ) ; }
private double round ( double value , int places ) { if ( places < _NUM ) throw new IllegalArgumentException ( ) ; long factor = ( long ) Math . pow ( _NUM , places ) ; value = value * factor ; long tmp = Math . round ( value ) ; return ( double ) tmp / factor ; }
private double round ( double value , int places ) { if ( places < _NUM ) throw new IllegalArgumentException ( ) ; long factor = ( long ) Math . pow ( _NUM , places ) ; value = value * factor ; long tmp = Math . round ( value ) ; return ( double ) tmp / factor ; }
public static float computeDiscardAlpha ( float amount , float range ) { if ( Math . abs ( amount ) < _NUM ) return _NUM ; float t = amount / range ; t = MathUtils . clamp ( t , - _NUM , _NUM ) ; return _NUM - Math . abs ( t ) ; }
public static void frontEndInitialize ( SpecObj spec , PrintStream syserr ) throws InitException { String fileName = spec . getFileName ( ) ; Errors initErrors = spec . initErrors ; try { Configuration . ReInit ( ) ; Context . reInit ( ) ; Configuration . load ( initErrors ) ; BuiltInLevel . load ( ) ; if ( ! initErrors . isSuccess ( ) ) { syserr . println ( STRING ) ; syserr . print ( initErrors ) ; spec . errorLevel = _NUM ; throw new InitException ( ) ; } } catch ( Exception e ) { syserr . println ( STRING + fileName + STRING + e ) ; syserr . println ( STRING + STRING ) ; syserr . print ( initErrors ) ; spec . errorLevel = _NUM ; throw new InitException ( ) ; } return ; }
public static void frontEndInitialize ( SpecObj spec , PrintStream syserr ) throws InitException { String fileName = spec . getFileName ( ) ; Errors initErrors = spec . initErrors ; try { Configuration . ReInit ( ) ; Context . reInit ( ) ; Configuration . load ( initErrors ) ; BuiltInLevel . load ( ) ; if ( ! initErrors . isSuccess ( ) ) { syserr . println ( STRING ) ; syserr . print ( initErrors ) ; spec . errorLevel = _NUM ; throw new InitException ( ) ; } } catch ( Exception e ) { syserr . println ( STRING + fileName + STRING + e ) ; syserr . println ( STRING + STRING ) ; syserr . print ( initErrors ) ; spec . errorLevel = _NUM ; throw new InitException ( ) ; } return ; }
public static void frontEndInitialize ( SpecObj spec , PrintStream syserr ) throws InitException { String fileName = spec . getFileName ( ) ; Errors initErrors = spec . initErrors ; try { Configuration . ReInit ( ) ; Context . reInit ( ) ; Configuration . load ( initErrors ) ; BuiltInLevel . load ( ) ; if ( ! initErrors . isSuccess ( ) ) { syserr . println ( STRING ) ; syserr . print ( initErrors ) ; spec . errorLevel = _NUM ; throw new InitException ( ) ; } } catch ( Exception e ) { syserr . println ( STRING + fileName + STRING + e ) ; syserr . println ( STRING + STRING ) ; syserr . print ( initErrors ) ; spec . errorLevel = _NUM ; throw new InitException ( ) ; } return ; }
public void unregisterReceiver ( Context context ) { mHandler . removeCallbacks ( mServiceRunnable ) ; if ( mIsRegistered . getAndSet ( _BOOL ) ) { context . unregisterReceiver ( this ) ; mNeedToRunActions . set ( _BOOL ) ; } }
public void unregisterReceiver ( Context context ) { mHandler . removeCallbacks ( mServiceRunnable ) ; if ( mIsRegistered . getAndSet ( _BOOL ) ) { context . unregisterReceiver ( this ) ; mNeedToRunActions . set ( _BOOL ) ; } }
public void unregisterReceiver ( Context context ) { mHandler . removeCallbacks ( mServiceRunnable ) ; if ( mIsRegistered . getAndSet ( _BOOL ) ) { context . unregisterReceiver ( this ) ; mNeedToRunActions . set ( _BOOL ) ; } }
public void unregisterReceiver ( Context context ) { mHandler . removeCallbacks ( mServiceRunnable ) ; if ( mIsRegistered . getAndSet ( _BOOL ) ) { context . unregisterReceiver ( this ) ; mNeedToRunActions . set ( _BOOL ) ; } }
void fixCompatibility ( View root ) { Queue < View > queue = new LinkedList < View > ( ) ; queue . add ( root ) ; View view = null ; while ( ( view = queue . poll ( ) ) != null ) { if ( view instanceof ViewGroup ) { ViewGroup group = ( ViewGroup ) view ; for ( int i = _NUM ; i < group . getChildCount ( ) ; i ++ ) { queue . add ( group . getChildAt ( i ) ) ; } } } }
void fixCompatibility ( View root ) { Queue < View > queue = new LinkedList < View > ( ) ; queue . add ( root ) ; View view = null ; while ( ( view = queue . poll ( ) ) != null ) { if ( view instanceof ViewGroup ) { ViewGroup group = ( ViewGroup ) view ; for ( int i = _NUM ; i < group . getChildCount ( ) ; i ++ ) { queue . add ( group . getChildAt ( i ) ) ; } } } }
void fixCompatibility ( View root ) { Queue < View > queue = new LinkedList < View > ( ) ; queue . add ( root ) ; View view = null ; while ( ( view = queue . poll ( ) ) != null ) { if ( view instanceof ViewGroup ) { ViewGroup group = ( ViewGroup ) view ; for ( int i = _NUM ; i < group . getChildCount ( ) ; i ++ ) { queue . add ( group . getChildAt ( i ) ) ; } } } }
void fixCompatibility ( View root ) { Queue < View > queue = new LinkedList < View > ( ) ; queue . add ( root ) ; View view = null ; while ( ( view = queue . poll ( ) ) != null ) { if ( view instanceof ViewGroup ) { ViewGroup group = ( ViewGroup ) view ; for ( int i = _NUM ; i < group . getChildCount ( ) ; i ++ ) { queue . add ( group . getChildAt ( i ) ) ; } } } }
public static String stripMetaFromName ( String fileName ) { int end = fileName . indexOf ( STRING ) ; if ( end == - _NUM ) end = fileName . indexOf ( STRING ) ; if ( end == - _NUM ) return fileName ; return fileName . substring ( _NUM , end ) ; }
public static String stripMetaFromName ( String fileName ) { int end = fileName . indexOf ( STRING ) ; if ( end == - _NUM ) end = fileName . indexOf ( STRING ) ; if ( end == - _NUM ) return fileName ; return fileName . substring ( _NUM , end ) ; }
public DOM4JTestDocumentBuilderFactory ( DocumentBuilderSetting [ ] settings ) throws DOMTestIncompatibleException { super ( settings ) ; try { ClassLoader classLoader = ClassLoader . getSystemClassLoader ( ) ; Class domFactoryClass = classLoader . loadClass ( STRING ) ; Method getInstance = domFactoryClass . getMethod ( STRING , new Class [ ] { } ) ; domFactory = getInstance . invoke ( null , new Object [ ] { } ) ; domImpl = ( DOMImplementation ) domFactory ; Class saxReaderClass = classLoader . loadClass ( STRING ) ; Constructor saxReaderConstructor = saxReaderClass . getConstructor ( new Class [ ] { classLoader . loadClass ( STRING ) } ) ; saxReader = saxReaderConstructor . newInstance ( new Object [ ] { domFactory } ) ; Method getReaderMethod = saxReaderClass . getMethod ( STRING , new Class [ ] { } ) ; xmlReader = ( XMLReader ) getReaderMethod . invoke ( saxReader , new Object [ _NUM ] ) ; readMethod = saxReaderClass . getMethod ( STRING , new Class [ ] { java . net . URL . class } ) ; } catch ( InvocationTargetException ex ) { throw new DOMTestIncompatibleException ( ex . getTargetException ( ) , null ) ; } catch ( Exception ex ) { throw new DOMTestIncompatibleException ( ex , null ) ; } }
@ Override public boolean isAccountNonExpired ( ) { return _BOOL ; }
@ Override public boolean isAccountNonExpired ( ) { return _BOOL ; }
private Bitmap addThumbnailToCache ( String imageKey , Bitmap bitmap , String path , int px ) { Bitmap thumbnail = ThumbnailUtils . extractThumbnail ( bitmap , px , px ) ; thumbnail = BitmapUtils . rotateImage ( thumbnail , path ) ; addBitmapToCache ( imageKey , thumbnail ) ; return thumbnail ; }
@ Override public String graph ( ) throws Exception { StringBuffer text = new StringBuffer ( ) ; text . append ( STRING ) ; if ( m_isLeaf ) { text . append ( STRING + m_id + STRING + STRING + STRING + STRING ) ; if ( m_train != null && m_train . numInstances ( ) > _NUM ) { text . append ( STRING + m_train + STRING ) ; text . append ( STRING ) ; } text . append ( STRING ) ; } else { text . append ( STRING + m_id + STRING + Utils . backQuoteChars ( m_localModel . leftSide ( m_train ) ) + STRING ) ; if ( m_train != null && m_train . numInstances ( ) > _NUM ) { text . append ( STRING + m_train + STRING ) ; text . append ( STRING ) ; } text . append ( STRING ) ; graphTree ( text ) ; } return text . toString ( ) + STRING ; }
@ Override public String graph ( ) throws Exception { StringBuffer text = new StringBuffer ( ) ; text . append ( STRING ) ; if ( m_isLeaf ) { text . append ( STRING + m_id + STRING + STRING + STRING + STRING ) ; if ( m_train != null && m_train . numInstances ( ) > _NUM ) { text . append ( STRING + m_train + STRING ) ; text . append ( STRING ) ; } text . append ( STRING ) ; } else { text . append ( STRING + m_id + STRING + Utils . backQuoteChars ( m_localModel . leftSide ( m_train ) ) + STRING ) ; if ( m_train != null && m_train . numInstances ( ) > _NUM ) { text . append ( STRING + m_train + STRING ) ; text . append ( STRING ) ; } text . append ( STRING ) ; graphTree ( text ) ; } return text . toString ( ) + STRING ; }
private File findSettingsFile ( String context ) { File userDir = new File ( PlatformUtil . getUserHomeDir ( ) ) ; StringBuilder path = new StringBuilder ( ) ; String [ ] parts = context . split ( STRING ) ; for ( String part : parts ) { path . append ( part ) ; path . append ( File . separator ) ; } File settingsFile = new File ( userDir , STRING + File . separator + path . toString ( ) + STRING ) ; if ( ! settingsFile . exists ( ) ) { Logger . log ( getClass ( ) , LogLevel . WARNING , STRING , settingsFile ) ; return null ; } return settingsFile ; }
@ NotNull public MessageBuilder type ( @ NotNull MessageType type ) { types . add ( type ) ; return this ; }
@ NotNull public MessageBuilder type ( @ NotNull MessageType type ) { types . add ( type ) ; return this ; }
@ NotNull public MessageBuilder type ( @ NotNull MessageType type ) { types . add ( type ) ; return this ; }
@ NotNull public MessageBuilder type ( @ NotNull MessageType type ) { types . add ( type ) ; return this ; }
@ NotNull public MessageBuilder type ( @ NotNull MessageType type ) { types . add ( type ) ; return this ; }
@ NotNull public MessageBuilder type ( @ NotNull MessageType type ) { types . add ( type ) ; return this ; }
public Timestamp randomTimestamp ( ) { if ( random . nextInt ( _NUM ) == _NUM ) { return null ; } StringBuilder buff = new StringBuilder ( ) ; buff . append ( getInt ( _NUM ) + _NUM ) ; buff . append ( STRING ) ; int month = getInt ( _NUM ) + _NUM ; if ( month < _NUM ) { buff . append ( STRING ) ; } buff . append ( month ) ; buff . append ( STRING ) ; int day = getInt ( _NUM ) + _NUM ; if ( day < _NUM ) { buff . append ( STRING ) ; } buff . append ( day ) ; buff . append ( STRING ) ; int hour = getInt ( _NUM ) ; if ( hour < _NUM ) { buff . append ( STRING ) ; } buff . append ( hour ) ; buff . append ( STRING ) ; int minute = getInt ( _NUM ) ; if ( minute < _NUM ) { buff . append ( STRING ) ; } buff . append ( minute ) ; buff . append ( STRING ) ; int second = getInt ( _NUM ) ; if ( second < _NUM ) { buff . append ( STRING ) ; } buff . append ( second ) ; return Timestamp . valueOf ( buff . toString ( ) ) ; }
public void put ( int key , int value ) { int i = binarySearch ( mKeys , _NUM , mSize , key ) ; if ( i >= _NUM ) { mValues [ i ] = value ; } else { i = ~ i ; if ( mSize >= mKeys . length ) { int n = Math . max ( mSize + _NUM , mKeys . length * _NUM ) ; int [ ] nkeys = new int [ n ] ; int [ ] nvalues = new int [ n ] ; System . arraycopy ( mKeys , _NUM , nkeys , _NUM , mKeys . length ) ; System . arraycopy ( mValues , _NUM , nvalues , _NUM , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } if ( mSize - i != _NUM ) { System . arraycopy ( mKeys , i , mKeys , i + _NUM , mSize - i ) ; System . arraycopy ( mValues , i , mValues , i + _NUM , mSize - i ) ; } mKeys [ i ] = key ; mValues [ i ] = value ; mSize ++ ; } }
private void internalRemove ( final Object [ ] elements ) { Object input = getInput ( ) ; for ( int i = _NUM ; i < elements . length ; ++ i ) { if ( equals ( elements [ i ] , input ) ) { setInput ( null ) ; return ; } int ix = getElementIndex ( elements [ i ] ) ; if ( ix >= _NUM ) { CheckItem item = listRemove ( ix ) ; listMap . remove ( ix ) ; unmapElement ( elements [ i ] , item . getControl ( ) ) ; } } }
public static < T > T showDialog ( WindowBasedTextGUI textGUI , String title , String description , int listBoxHeight , T ... items ) { int width = _NUM ; for ( T item : items ) { width = Math . max ( width , TerminalTextUtils . getColumnWidth ( item . toString ( ) ) ) ; } width += _NUM ; return showDialog ( textGUI , title , description , new TerminalSize ( width , listBoxHeight ) , items ) ; }
public GammaInvFitnessFunction ( int genomeLength , double alpha , double beta , double pInv , int stateSize , boolean randomFittest ) { GammaDistribution gamma = new GammaDistribution ( beta , alpha ) ; fitness = new double [ genomeLength ] [ stateSize ] ; fittest = new byte [ genomeLength ] ; int fitpos = _NUM ; for ( int i = _NUM ; i < genomeLength ; i ++ ) { if ( randomFittest ) { fitpos = MathUtils . nextInt ( stateSize ) ; } fitness [ i ] [ fitpos ] = _NUM ; fittest [ i ] = ( byte ) fitpos ; for ( int j = _NUM ; j < stateSize ; j ++ ) { if ( j != fitpos ) { if ( MathUtils . nextDouble ( ) > pInv ) { double prob = Math . round ( MathUtils . nextDouble ( ) * _NUM ) / _NUM ; while ( ( prob <= _NUM ) || ( prob >= _NUM ) ) { prob = Math . round ( MathUtils . nextDouble ( ) * _NUM ) / _NUM ; } fitness [ i ] [ j ] = Math . max ( _NUM , _NUM - gamma . quantile ( prob ) ) ; } else { fitness [ i ] [ j ] = _NUM ; } } } } }
private void growSpine ( ) { int size = ( spine . length << _NUM ) + _NUM ; spine = new int [ size ] ; spineEmpty = new int [ size ] ; threshold = ( int ) ( spine . length * loadFactor ) ; Arrays . fill ( spineEmpty , - _NUM ) ; GridUnsafe . copyMemory ( spineEmpty , INT_ARR_OFF , spine , INT_ARR_OFF , spineEmpty . length << _NUM ) ; for ( int i = _NUM ; i < this . size ; i ++ ) { Object obj = objs [ i ] ; int idx = hash ( obj ) % spine . length ; insert ( objs [ i ] , i , idx ) ; } }
public static < T > DatabaseTableConfig < T > fromClass ( ConnectionSource connectionSource , Class < T > clazz ) throws SQLException { DatabaseType databaseType = connectionSource . getDatabaseType ( ) ; String tableName = DatabaseTableConfig . extractTableName ( clazz ) ; List < DatabaseFieldConfig > fieldConfigs = new ArrayList < DatabaseFieldConfig > ( ) ; for ( Class < ? > classWalk = clazz ; classWalk != null ; classWalk = classWalk . getSuperclass ( ) ) { for ( Field field : classWalk . getDeclaredFields ( ) ) { DatabaseFieldConfig config = configFromField ( databaseType , tableName , field ) ; if ( config != null && config . isPersisted ( ) ) { fieldConfigs . add ( config ) ; } } } if ( fieldConfigs . size ( ) == _NUM ) { return null ; } else { return new DatabaseTableConfig < T > ( clazz , tableName , fieldConfigs ) ; } }
public String toString ( ) { StringBuilder result = new StringBuilder ( ) ; result . append ( STRING ) ; result . append ( klazz . getName ( ) ) ; result . append ( STRING ) ; for ( int i = _NUM ; i < elements . length ; ++ i ) { if ( i != _NUM ) { result . append ( STRING ) ; } result . append ( elements [ i ] ) ; } result . append ( STRING ) ; return result . toString ( ) ; }
private boolean checkForDoubleSpendAgainstPending ( Transaction tx , boolean takeAction ) { checkState ( lock . isHeldByCurrentThread ( ) ) ; HashSet < TransactionOutPoint > outpoints = new HashSet < TransactionOutPoint > ( ) ; for ( TransactionInput input : tx . getInputs ( ) ) { outpoints . add ( input . getOutpoint ( ) ) ; } LinkedList < Transaction > doubleSpentTxns = Lists . newLinkedList ( ) ; for ( Transaction p : pending . values ( ) ) { for ( TransactionInput input : p . getInputs ( ) ) { TransactionOutPoint outpoint = input . getOutpoint ( ) ; if ( outpoints . contains ( outpoint ) ) { if ( ! doubleSpentTxns . isEmpty ( ) && doubleSpentTxns . getLast ( ) == p ) continue ; doubleSpentTxns . add ( p ) ; } } } if ( takeAction && ! doubleSpentTxns . isEmpty ( ) ) { killTx ( tx , doubleSpentTxns ) ; } return ! doubleSpentTxns . isEmpty ( ) ; }
private boolean checkForDoubleSpendAgainstPending ( Transaction tx , boolean takeAction ) { checkState ( lock . isHeldByCurrentThread ( ) ) ; HashSet < TransactionOutPoint > outpoints = new HashSet < TransactionOutPoint > ( ) ; for ( TransactionInput input : tx . getInputs ( ) ) { outpoints . add ( input . getOutpoint ( ) ) ; } LinkedList < Transaction > doubleSpentTxns = Lists . newLinkedList ( ) ; for ( Transaction p : pending . values ( ) ) { for ( TransactionInput input : p . getInputs ( ) ) { TransactionOutPoint outpoint = input . getOutpoint ( ) ; if ( outpoints . contains ( outpoint ) ) { if ( ! doubleSpentTxns . isEmpty ( ) && doubleSpentTxns . getLast ( ) == p ) continue ; doubleSpentTxns . add ( p ) ; } } } if ( takeAction && ! doubleSpentTxns . isEmpty ( ) ) { killTx ( tx , doubleSpentTxns ) ; } return ! doubleSpentTxns . isEmpty ( ) ; }
private boolean checkForDoubleSpendAgainstPending ( Transaction tx , boolean takeAction ) { checkState ( lock . isHeldByCurrentThread ( ) ) ; HashSet < TransactionOutPoint > outpoints = new HashSet < TransactionOutPoint > ( ) ; for ( TransactionInput input : tx . getInputs ( ) ) { outpoints . add ( input . getOutpoint ( ) ) ; } LinkedList < Transaction > doubleSpentTxns = Lists . newLinkedList ( ) ; for ( Transaction p : pending . values ( ) ) { for ( TransactionInput input : p . getInputs ( ) ) { TransactionOutPoint outpoint = input . getOutpoint ( ) ; if ( outpoints . contains ( outpoint ) ) { if ( ! doubleSpentTxns . isEmpty ( ) && doubleSpentTxns . getLast ( ) == p ) continue ; doubleSpentTxns . add ( p ) ; } } } if ( takeAction && ! doubleSpentTxns . isEmpty ( ) ) { killTx ( tx , doubleSpentTxns ) ; } return ! doubleSpentTxns . isEmpty ( ) ; }
public void arrayLength ( ) { mv . visitInsn ( Opcodes . ARRAYLENGTH ) ; }
protected void process ( List < String > messages ) { setStatusBarMessage ( messages . get ( messages . size ( ) - _NUM ) , BasePanel . INFORMATION ) ; }
private void pushStack ( int newTop ) { if ( stackSize == stack . length ) { int [ ] newStack = new int [ stackSize * _NUM ] ; int [ ] newPathIndices = new int [ stackSize * _NUM ] ; String [ ] newPathNames = new String [ stackSize * _NUM ] ; System . arraycopy ( stack , _NUM , newStack , _NUM , stackSize ) ; System . arraycopy ( pathIndices , _NUM , newPathIndices , _NUM , stackSize ) ; System . arraycopy ( pathNames , _NUM , newPathNames , _NUM , stackSize ) ; stack = newStack ; pathIndices = newPathIndices ; pathNames = newPathNames ; } stack [ stackSize ++ ] = newTop ; }
ComputingImpl ( ComputingStrategy < K , V , E > strategy , Builder builder , Function < ? super K , ? extends V > computer ) { super ( strategy , builder ) ; this . computingStrategy = strategy ; this . computer = computer ; }
@ Override public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case android . R . id . home : finish ( ) ; return _BOOL ; default : return super . onOptionsItemSelected ( item ) ; } }
public final TestSubscriber assertValue ( Tuple < String , String > value ) { String prefix = STRING ; boolean passed = _BOOL ; if ( done . getCount ( ) != _NUM ) { prefix = STRING ; } int s = values . size ( ) ; if ( s != _NUM ) { fail ( prefix , STRING + value + STRING + values , errors ) ; fail ( STRING ) ; passed = _BOOL ; } Tuple < String , String > v = values . get ( _NUM ) ; if ( ! Objects . equals ( value , v ) ) { fail ( prefix , STRING + valueAndClass ( value ) + STRING + valueAndClass ( v ) , errors ) ; fail ( STRING ) ; passed = _BOOL ; } pass ( STRING , passed ) ; return this ; }
public final TestSubscriber assertValue ( Tuple < String , String > value ) { String prefix = STRING ; boolean passed = _BOOL ; if ( done . getCount ( ) != _NUM ) { prefix = STRING ; } int s = values . size ( ) ; if ( s != _NUM ) { fail ( prefix , STRING + value + STRING + values , errors ) ; fail ( STRING ) ; passed = _BOOL ; } Tuple < String , String > v = values . get ( _NUM ) ; if ( ! Objects . equals ( value , v ) ) { fail ( prefix , STRING + valueAndClass ( value ) + STRING + valueAndClass ( v ) , errors ) ; fail ( STRING ) ; passed = _BOOL ; } pass ( STRING , passed ) ; return this ; }
@ Override public String update ( String xml ) { try { return query ( STRING + URLEncoder . encode ( xml , STRING ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
@ Override public String update ( String xml ) { try { return query ( STRING + URLEncoder . encode ( xml , STRING ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
@ Override public String update ( String xml ) { try { return query ( STRING + URLEncoder . encode ( xml , STRING ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
private static boolean trustGetContextClassLoader ( Thread t ) { Class cl = t . getClass ( ) ; if ( cl == Thread . class ) { return _BOOL ; } Boolean b ; synchronized ( trustGetCCL ) { b = ( Boolean ) trustGetCCL . get ( cl ) ; } if ( b == null ) { b = trustGetContextClassLoader0 ( cl ) ; synchronized ( trustGetCCL ) { trustGetCCL . put ( cl , b ) ; } } return b . booleanValue ( ) ; }
private static boolean trustGetContextClassLoader ( Thread t ) { Class cl = t . getClass ( ) ; if ( cl == Thread . class ) { return _BOOL ; } Boolean b ; synchronized ( trustGetCCL ) { b = ( Boolean ) trustGetCCL . get ( cl ) ; } if ( b == null ) { b = trustGetContextClassLoader0 ( cl ) ; synchronized ( trustGetCCL ) { trustGetCCL . put ( cl , b ) ; } } return b . booleanValue ( ) ; }
private static boolean trustGetContextClassLoader ( Thread t ) { Class cl = t . getClass ( ) ; if ( cl == Thread . class ) { return _BOOL ; } Boolean b ; synchronized ( trustGetCCL ) { b = ( Boolean ) trustGetCCL . get ( cl ) ; } if ( b == null ) { b = trustGetContextClassLoader0 ( cl ) ; synchronized ( trustGetCCL ) { trustGetCCL . put ( cl , b ) ; } } return b . booleanValue ( ) ; }
protected boolean shardAvailable ( @ Nullable IndexShard shard ) { return shard != null && shard . canIndex ( ) && CAN_UPDATE_INDEX_BUFFER_STATES . contains ( shard . state ( ) ) ; }
private void validateExpectedPartitionValuesCreateRequest ( ExpectedPartitionValuesCreateRequest expectedPartitionValuesCreateRequest ) { partitionKeyGroupHelper . validatePartitionKeyGroupKey ( expectedPartitionValuesCreateRequest . getPartitionKeyGroupKey ( ) ) ; expectedPartitionValuesCreateRequest . setExpectedPartitionValues ( validateExpectedPartitionValues ( expectedPartitionValuesCreateRequest . getExpectedPartitionValues ( ) ) ) ; }
public boolean hasAttribute ( final AttributeType attributeType ) { return attributes . contains ( attributeType ) ; }
public void memberJoined ( ClientMembershipEvent event ) { Notification notification = new Notification ( JMXNotificationType . CLIENT_JOINED , serverSource , SequenceNumber . next ( ) , System . currentTimeMillis ( ) , ManagementConstants . CLIENT_JOINED_PREFIX + event . getMemberId ( ) ) ; serverLevelNotifEmitter . sendNotification ( notification ) ; memberLevelNotifEmitter . sendNotification ( notification ) ; }
public static String escapeString ( final String string ) { if ( string . indexOf ( DELIMITER_COMPONENT ) < _NUM ) { final int length = string . length ( ) ; final StringBuffer buffer = new StringBuffer ( length + _NUM ) ; for ( int index = _NUM ; index < length ; index ++ ) { final char character = string . charAt ( index ) ; if ( DELIMITER_COMPONENT == character ) buffer . append ( DELIMITER_COMPONENT ) ; buffer . append ( character ) ; } return buffer . toString ( ) ; } return string ; }
private void checkNoMoreAtts ( Atts atts ) throws RDFParseException { if ( atts . size ( ) > _NUM ) { Iterator < Att > iter = atts . iterator ( ) ; while ( iter . hasNext ( ) ) { Att att = iter . next ( ) ; reportError ( STRING + att . getQName ( ) + STRING , XMLParserSettings . FAIL_ON_NON_STANDARD_ATTRIBUTES ) ; iter . remove ( ) ; } } }
public static String padAndTruncateString ( String s , int fieldSize ) { return padAndTruncateString ( s , fieldSize , Setup . isTabEnabled ( ) ) ; }
public static String padAndTruncateString ( String s , int fieldSize ) { return padAndTruncateString ( s , fieldSize , Setup . isTabEnabled ( ) ) ; }
public static String padAndTruncateString ( String s , int fieldSize ) { return padAndTruncateString ( s , fieldSize , Setup . isTabEnabled ( ) ) ; }
public boolean isRslUrlSigned ( String url ) { if ( url == null ) { return _BOOL ; } return url . endsWith ( SIGNED_RSL_URL_DOT_EXTENSION ) ; }
public boolean isRslUrlSigned ( String url ) { if ( url == null ) { return _BOOL ; } return url . endsWith ( SIGNED_RSL_URL_DOT_EXTENSION ) ; }
@ Override public boolean done ( ) { if ( stoppingIncrements && incrementsLeft == _NUM ) return _BOOL ; else return _BOOL ; }
public ProjectionStack ( ) { }
@ SuppressWarnings ( { STRING } ) public File generate ( ) throws IOException { File scriptPath = FileUtil . createTempFile ( myPrefix , SCRIPT_EXT ) ; scriptPath . deleteOnExit ( ) ; PrintWriter out = new PrintWriter ( new FileWriter ( scriptPath ) ) ; try { if ( SystemInfo . isWindows ) { out . println ( STRING ) ; } else { out . println ( STRING ) ; } String line = commandLine ( ) ; if ( SystemInfo . isWindows ) { line += STRING ; } else { line += STRING ; } out . println ( line ) ; } finally { out . close ( ) ; } FileUtil . setExecutableAttribute ( scriptPath . getPath ( ) , _BOOL ) ; return scriptPath ; }
public void forEachBlockDepthFirst ( boolean reverse , SsaBasicBlock . Visitor v ) { BitSet visited = new BitSet ( blocks . size ( ) ) ; Stack < SsaBasicBlock > stack = new Stack < SsaBasicBlock > ( ) ; SsaBasicBlock rootBlock = reverse ? getExitBlock ( ) : getEntryBlock ( ) ; if ( rootBlock == null ) { return ; } stack . add ( null ) ; stack . add ( rootBlock ) ; while ( stack . size ( ) > _NUM ) { SsaBasicBlock cur = stack . pop ( ) ; SsaBasicBlock parent = stack . pop ( ) ; if ( ! visited . get ( cur . getIndex ( ) ) ) { BitSet children = reverse ? cur . getPredecessors ( ) : cur . getSuccessors ( ) ; for ( int i = children . nextSetBit ( _NUM ) ; i >= _NUM ; i = children . nextSetBit ( i + _NUM ) ) { stack . add ( cur ) ; stack . add ( blocks . get ( i ) ) ; } visited . set ( cur . getIndex ( ) ) ; v . visitBlock ( cur , parent ) ; } } }
private byte [ ] createHaystack ( byte [ ] needle , int position , int size ) { byte [ ] haystack = new byte [ size ] ; for ( int i = position , j = _NUM ; i < size && j < needle . length ; i ++ , j ++ ) { haystack [ i ] = needle [ j ] ; } return haystack ; }
private byte [ ] createHaystack ( byte [ ] needle , int position , int size ) { byte [ ] haystack = new byte [ size ] ; for ( int i = position , j = _NUM ; i < size && j < needle . length ; i ++ , j ++ ) { haystack [ i ] = needle [ j ] ; } return haystack ; }
private byte [ ] createHaystack ( byte [ ] needle , int position , int size ) { byte [ ] haystack = new byte [ size ] ; for ( int i = position , j = _NUM ; i < size && j < needle . length ; i ++ , j ++ ) { haystack [ i ] = needle [ j ] ; } return haystack ; }
private byte [ ] createHaystack ( byte [ ] needle , int position , int size ) { byte [ ] haystack = new byte [ size ] ; for ( int i = position , j = _NUM ; i < size && j < needle . length ; i ++ , j ++ ) { haystack [ i ] = needle [ j ] ; } return haystack ; }
public Interval reverseThis ( ) { return Interval . fromToBy ( this . to , this . from , - this . step ) ; }
public static < T > T [ ] copyFrom ( T [ ] array , int newLength ) { T [ ] copy = createWithSameComponentType ( newLength , array ) ; System . arraycopy ( array , _NUM , copy , _NUM , Math . min ( array . length , newLength ) ) ; return copy ; }
public int createBinomial ( final int n , final double p ) { double value = p ; final StringBuilder bits = new StringBuilder ( _NUM ) ; double bitValue = _NUM ; while ( value > _NUM ) { if ( value >= bitValue ) { bits . append ( STRING ) ; value -= bitValue ; } else { bits . append ( STRING ) ; } bitValue /= _NUM ; } final BitString pBits = new BitString ( bits . toString ( ) ) ; int trials = n ; int totalSuccesses = _NUM ; int pIndex = pBits . getLength ( ) - _NUM ; while ( trials > _NUM && pIndex >= _NUM ) { final BitString bs = new BitString ( trials , generator ) ; final int successes = bs . countSetBits ( ) ; trials -= successes ; if ( pBits . getBit ( pIndex ) ) { totalSuccesses += successes ; } -- pIndex ; } return totalSuccesses ; }
public static boolean isSnapshotFullCopySupported ( URI blockSnapURI , DbClient dbClient ) { BlockSnapshot blockObj = dbClient . queryObject ( BlockSnapshot . class , blockSnapURI ) ; StorageSystem storage = dbClient . queryObject ( StorageSystem . class , blockObj . getStorageController ( ) ) ; return ( storage != null && ( storage . deviceIsType ( Type . openstack ) || storage . deviceIsType ( Type . vnxblock ) || storage . deviceIsType ( Type . ibmxiv ) || storage . deviceIsType ( Type . vmax ) ) ) ; }
public static boolean isSnapshotFullCopySupported ( URI blockSnapURI , DbClient dbClient ) { BlockSnapshot blockObj = dbClient . queryObject ( BlockSnapshot . class , blockSnapURI ) ; StorageSystem storage = dbClient . queryObject ( StorageSystem . class , blockObj . getStorageController ( ) ) ; return ( storage != null && ( storage . deviceIsType ( Type . openstack ) || storage . deviceIsType ( Type . vnxblock ) || storage . deviceIsType ( Type . ibmxiv ) || storage . deviceIsType ( Type . vmax ) ) ) ; }
@ Override public boolean ready ( ) throws IOException { synchronized ( lock ) { checkNotClosed ( ) ; return ( ( end - pos ) > _NUM ) || in . ready ( ) ; } }
@ Override public boolean ready ( ) throws IOException { synchronized ( lock ) { checkNotClosed ( ) ; return ( ( end - pos ) > _NUM ) || in . ready ( ) ; } }
public double [ ] distributionForInstance ( Instance instance ) throws Exception { double [ ] probOfClassGivenDoc = new double [ m_numClasses ] ; double [ ] logDocGivenClass = new double [ m_numClasses ] ; for ( int h = _NUM ; h < m_numClasses ; h ++ ) logDocGivenClass [ h ] = probOfDocGivenClass ( instance , h ) ; double max = logDocGivenClass [ Utils . maxIndex ( logDocGivenClass ) ] ; double probOfDoc = _NUM ; for ( int i = _NUM ; i < m_numClasses ; i ++ ) { probOfClassGivenDoc [ i ] = Math . exp ( logDocGivenClass [ i ] - max ) * m_probOfClass [ i ] ; probOfDoc += probOfClassGivenDoc [ i ] ; } Utils . normalize ( probOfClassGivenDoc , probOfDoc ) ; return probOfClassGivenDoc ; }
@ Override public Request < List < RunnerStatus > > processes ( ProjectReference projectReference ) { List < DummyRunnerStatus > current = currentRunnerStatuses . get ( projectReference . name ( ) ) ; List < RunnerStatus > update = new ArrayList < > ( ) ; if ( current != null ) { for ( DummyRunnerStatus dummyRunnerStatus : current ) { update . add ( dummyRunnerStatus ) ; } } return new DummyRequest < > ( update ) ; }
public static String toJSONString ( Map map ) { final StringWriter writer = new StringWriter ( ) ; try { writeJSONString ( map , writer ) ; return writer . toString ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public static String toJSONString ( Map map ) { final StringWriter writer = new StringWriter ( ) ; try { writeJSONString ( map , writer ) ; return writer . toString ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public static String toJSONString ( Map map ) { final StringWriter writer = new StringWriter ( ) ; try { writeJSONString ( map , writer ) ; return writer . toString ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
protected String translateColumnName ( String columnName ) { return columnName . replaceAll ( STRING , STRING ) ; }
protected String translateColumnName ( String columnName ) { return columnName . replaceAll ( STRING , STRING ) ; }
protected String translateColumnName ( String columnName ) { return columnName . replaceAll ( STRING , STRING ) ; }
protected String translateColumnName ( String columnName ) { return columnName . replaceAll ( STRING , STRING ) ; }
public void actionPerformed ( ActionEvent e ) { JTextPane pane ; DocumentPrinting doc ; pane = newCodePane ( ) ; pane . setText ( m_TextCode . getText ( ) ) ; doc = new DocumentPrinting ( ) ; doc . print ( pane ) ; }
public static void sortMethods ( MethodBinding [ ] sortedMethods , int left , int right ) { Arrays . sort ( sortedMethods , left , right , METHOD_COMPARATOR ) ; }
public static void sortMethods ( MethodBinding [ ] sortedMethods , int left , int right ) { Arrays . sort ( sortedMethods , left , right , METHOD_COMPARATOR ) ; }
public static void sortMethods ( MethodBinding [ ] sortedMethods , int left , int right ) { Arrays . sort ( sortedMethods , left , right , METHOD_COMPARATOR ) ; }
public void addRevision ( int revnumber , String date , String authorinitials , String revremark ) { Revision r = new Revision ( ) ; r . revnumber = revnumber ; r . date = date ; r . authorinitials = authorinitials ; r . revremark = revremark ; list . add ( r ) ; }
public Workflow . Method verifyDatastoreMethod ( URI exportGroup , URI vcenter , URI vcenterDatacenter ) { return new Workflow . Method ( STRING , exportGroup , vcenter , vcenterDatacenter ) ; }
public Workflow . Method verifyDatastoreMethod ( URI exportGroup , URI vcenter , URI vcenterDatacenter ) { return new Workflow . Method ( STRING , exportGroup , vcenter , vcenterDatacenter ) ; }
public Workflow . Method verifyDatastoreMethod ( URI exportGroup , URI vcenter , URI vcenterDatacenter ) { return new Workflow . Method ( STRING , exportGroup , vcenter , vcenterDatacenter ) ; }
public Workflow . Method verifyDatastoreMethod ( URI exportGroup , URI vcenter , URI vcenterDatacenter ) { return new Workflow . Method ( STRING , exportGroup , vcenter , vcenterDatacenter ) ; }
public void removeItem ( int position ) { mDatas . remove ( position ) ; notifyItemRemoved ( position ) ; }
public MessageFormatter removeMessageFormatter ( String domain ) { return ( MessageFormatter ) fMessageFormatters . remove ( domain ) ; }
public MessageFormatter removeMessageFormatter ( String domain ) { return ( MessageFormatter ) fMessageFormatters . remove ( domain ) ; }
private static void insertValueUsingIfNotEmpty ( final Map < String , List < String > > paramsMap , final String paramVal , final String parameterName ) { if ( StringUtils . isNotEmpty ( paramVal ) ) { List < String > list = new ArrayList < > ( ) ; list . add ( paramVal ) ; paramsMap . put ( parameterName , list ) ; } }
public void keyPressed ( final KeyEvent k ) { if ( k . getKeyCode ( ) == KeyEvent . VK_SPACE ) { } if ( k . getKeyCode ( ) != KeyEvent . VK_SPACE ) { } repaint ( ) ; }
private Point calculateLocation ( int position , Rectangle bounds , Dimension size , int offset ) { Point location = new Point ( ) ; location . x = bounds . x - horizontalMoveDirection * HORIZONTAL_MARGIN ; location . y = bounds . y ; if ( position == _NUM || position == _NUM ) { location . x += ( bounds . width - size . width ) ; } if ( position == _NUM || position == _NUM ) { location . y += ( bounds . height - size . height ) ; offset = - offset ; } location . y += offset ; return location ; }
public static void putPWStat ( long id , Stat type , double s ) { if ( _disabled ) return ; if ( ! _pwstats . containsKey ( id ) ) _pwstats . put ( id , new HashMap < Stat , LinkedList < Double > > ( ) ) ; HashMap < Stat , LinkedList < Double > > allstats = _pwstats . get ( id ) ; if ( ! allstats . containsKey ( type ) ) allstats . put ( type , new LinkedList < Double > ( ) ) ; LinkedList < Double > stats = allstats . get ( type ) ; stats . addLast ( s ) ; }
protected void sendIntensity ( double intensity ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING + STRING + lastOutputStep + STRING + maxDimStep ) ; } int newStep = ( int ) Math . round ( intensity * maxDimStep ) ; if ( ( newStep < _NUM ) || ( newStep > maxDimStep ) ) { log . error ( STRING + newStep + STRING + intensity ) ; } if ( newStep == lastOutputStep ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING ) ; } return ; } if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity ) ; } InsteonSequence out = new InsteonSequence ( ) ; out . addFunction ( idhighbyte , idmiddlebyte , idlowbyte , Constants . FUNCTION_REQ_STD , Constants . FLAG_STD , Constants . CMD_LIGHT_CHG , newStep ) ; tc . sendInsteonSequence ( out , null ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING + idhighbyte + idmiddlebyte + idlowbyte + STRING + newStep ) ; } lastOutputStep = newStep ; }
protected void sendIntensity ( double intensity ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING + STRING + lastOutputStep + STRING + maxDimStep ) ; } int newStep = ( int ) Math . round ( intensity * maxDimStep ) ; if ( ( newStep < _NUM ) || ( newStep > maxDimStep ) ) { log . error ( STRING + newStep + STRING + intensity ) ; } if ( newStep == lastOutputStep ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING ) ; } return ; } if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity ) ; } InsteonSequence out = new InsteonSequence ( ) ; out . addFunction ( idhighbyte , idmiddlebyte , idlowbyte , Constants . FUNCTION_REQ_STD , Constants . FLAG_STD , Constants . CMD_LIGHT_CHG , newStep ) ; tc . sendInsteonSequence ( out , null ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING + idhighbyte + idmiddlebyte + idlowbyte + STRING + newStep ) ; } lastOutputStep = newStep ; }
protected void sendIntensity ( double intensity ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING + STRING + lastOutputStep + STRING + maxDimStep ) ; } int newStep = ( int ) Math . round ( intensity * maxDimStep ) ; if ( ( newStep < _NUM ) || ( newStep > maxDimStep ) ) { log . error ( STRING + newStep + STRING + intensity ) ; } if ( newStep == lastOutputStep ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING ) ; } return ; } if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity ) ; } InsteonSequence out = new InsteonSequence ( ) ; out . addFunction ( idhighbyte , idmiddlebyte , idlowbyte , Constants . FUNCTION_REQ_STD , Constants . FLAG_STD , Constants . CMD_LIGHT_CHG , newStep ) ; tc . sendInsteonSequence ( out , null ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING + idhighbyte + idmiddlebyte + idlowbyte + STRING + newStep ) ; } lastOutputStep = newStep ; }
protected void sendIntensity ( double intensity ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING + STRING + lastOutputStep + STRING + maxDimStep ) ; } int newStep = ( int ) Math . round ( intensity * maxDimStep ) ; if ( ( newStep < _NUM ) || ( newStep > maxDimStep ) ) { log . error ( STRING + newStep + STRING + intensity ) ; } if ( newStep == lastOutputStep ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING ) ; } return ; } if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity ) ; } InsteonSequence out = new InsteonSequence ( ) ; out . addFunction ( idhighbyte , idmiddlebyte , idlowbyte , Constants . FUNCTION_REQ_STD , Constants . FLAG_STD , Constants . CMD_LIGHT_CHG , newStep ) ; tc . sendInsteonSequence ( out , null ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING + idhighbyte + idmiddlebyte + idlowbyte + STRING + newStep ) ; } lastOutputStep = newStep ; }
protected void sendIntensity ( double intensity ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING + STRING + lastOutputStep + STRING + maxDimStep ) ; } int newStep = ( int ) Math . round ( intensity * maxDimStep ) ; if ( ( newStep < _NUM ) || ( newStep > maxDimStep ) ) { log . error ( STRING + newStep + STRING + intensity ) ; } if ( newStep == lastOutputStep ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING ) ; } return ; } if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity ) ; } InsteonSequence out = new InsteonSequence ( ) ; out . addFunction ( idhighbyte , idmiddlebyte , idlowbyte , Constants . FUNCTION_REQ_STD , Constants . FLAG_STD , Constants . CMD_LIGHT_CHG , newStep ) ; tc . sendInsteonSequence ( out , null ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING + idhighbyte + idmiddlebyte + idlowbyte + STRING + newStep ) ; } lastOutputStep = newStep ; }
protected void sendIntensity ( double intensity ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING + STRING + lastOutputStep + STRING + maxDimStep ) ; } int newStep = ( int ) Math . round ( intensity * maxDimStep ) ; if ( ( newStep < _NUM ) || ( newStep > maxDimStep ) ) { log . error ( STRING + newStep + STRING + intensity ) ; } if ( newStep == lastOutputStep ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING ) ; } return ; } if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity ) ; } InsteonSequence out = new InsteonSequence ( ) ; out . addFunction ( idhighbyte , idmiddlebyte , idlowbyte , Constants . FUNCTION_REQ_STD , Constants . FLAG_STD , Constants . CMD_LIGHT_CHG , newStep ) ; tc . sendInsteonSequence ( out , null ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING + idhighbyte + idmiddlebyte + idlowbyte + STRING + newStep ) ; } lastOutputStep = newStep ; }
protected void sendIntensity ( double intensity ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING + STRING + lastOutputStep + STRING + maxDimStep ) ; } int newStep = ( int ) Math . round ( intensity * maxDimStep ) ; if ( ( newStep < _NUM ) || ( newStep > maxDimStep ) ) { log . error ( STRING + newStep + STRING + intensity ) ; } if ( newStep == lastOutputStep ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING ) ; } return ; } if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity ) ; } InsteonSequence out = new InsteonSequence ( ) ; out . addFunction ( idhighbyte , idmiddlebyte , idlowbyte , Constants . FUNCTION_REQ_STD , Constants . FLAG_STD , Constants . CMD_LIGHT_CHG , newStep ) ; tc . sendInsteonSequence ( out , null ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + intensity + STRING + idhighbyte + idmiddlebyte + idlowbyte + STRING + newStep ) ; } lastOutputStep = newStep ; }
private void readObject ( ObjectInputStream s ) throws ClassNotFoundException , IOException , HeadlessException { GraphicsEnvironment . checkHeadless ( ) ; ObjectInputStream . GetField f = s . readFields ( ) ; scrollbarDisplayPolicy = f . get ( STRING , SCROLLBARS_AS_NEEDED ) ; hAdjustable = ( ScrollPaneAdjustable ) f . get ( STRING , null ) ; vAdjustable = ( ScrollPaneAdjustable ) f . get ( STRING , null ) ; wheelScrollingEnabled = f . get ( STRING , defaultWheelScroll ) ; }
public AutoMixBucket createBucket ( String name , String [ ] styles , String [ ] moods , boolean taste , float adventurous , String [ ] songTypes , float speechiness , float energy , float familiar ) { AutoMixBucket bucket = new AutoMixBucket ( name , styles , moods , taste , adventurous , songTypes , speechiness , energy , familiar ) ; bucket . createPlaylistSession ( ) ; mBuckets . add ( bucket ) ; saveBucket ( bucket ) ; return bucket ; }
public synchronized void removeListener ( final T listener ) { listeners . remove ( listener ) ; }
public int writeGraphToFile ( byte [ ] img , File to ) { try { FileOutputStream fos = new FileOutputStream ( to ) ; fos . write ( img ) ; fos . close ( ) ; } catch ( java . io . IOException ioe ) { return - _NUM ; } return _NUM ; }
public int writeGraphToFile ( byte [ ] img , File to ) { try { FileOutputStream fos = new FileOutputStream ( to ) ; fos . write ( img ) ; fos . close ( ) ; } catch ( java . io . IOException ioe ) { return - _NUM ; } return _NUM ; }
public void postCommit ( boolean jobSuccessful , Configuration conf ) throws RetryException , UnrecoverableException { if ( jobSuccessful ) { JdbcOutputFormat . finalizeOutput ( conf ) ; } else { JdbcOutputFormat . rollback ( conf ) ; } }
public void postCommit ( boolean jobSuccessful , Configuration conf ) throws RetryException , UnrecoverableException { if ( jobSuccessful ) { JdbcOutputFormat . finalizeOutput ( conf ) ; } else { JdbcOutputFormat . rollback ( conf ) ; } }
public void postCommit ( boolean jobSuccessful , Configuration conf ) throws RetryException , UnrecoverableException { if ( jobSuccessful ) { JdbcOutputFormat . finalizeOutput ( conf ) ; } else { JdbcOutputFormat . rollback ( conf ) ; } }
@ TargetApi ( Build . VERSION_CODES . M ) public boolean ensureStoragePermissionGranted ( ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { if ( checkSelfPermission ( Manifest . permission . WRITE_EXTERNAL_STORAGE ) == PackageManager . PERMISSION_GRANTED ) { return _BOOL ; } else { requestPermissions ( new String [ ] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , REQUESTCODE_PERMISSION_STORAGE ) ; return _BOOL ; } } else { return _BOOL ; } }
@ TargetApi ( Build . VERSION_CODES . M ) public boolean ensureStoragePermissionGranted ( ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { if ( checkSelfPermission ( Manifest . permission . WRITE_EXTERNAL_STORAGE ) == PackageManager . PERMISSION_GRANTED ) { return _BOOL ; } else { requestPermissions ( new String [ ] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , REQUESTCODE_PERMISSION_STORAGE ) ; return _BOOL ; } } else { return _BOOL ; } }
private void copyVdcObject ( VirtualDataCenter src , VirtualDataCenter dest ) { log . info ( STRING , dest . getId ( ) ) ; dest . setShortId ( src . getShortId ( ) ) ; dest . setVersion ( src . getVersion ( ) ) ; dest . setApiEndpoint ( src . getApiEndpoint ( ) ) ; dest . setConnectionStatus ( src . getConnectionStatus ( ) ) ; dest . setLocal ( src . getLocal ( ) ) ; dest . setHostCount ( src . getHostCount ( ) ) ; dest . setHostIPv4AddressesMap ( src . getHostIPv4AddressesMap ( ) ) ; dest . setHostIPv6AddressesMap ( src . getHostIPv6AddressesMap ( ) ) ; Assert . assertNotNull ( src . getHostIPv4AddressesMap ( ) ) ; }
private void updateCalendarView ( ) { mCalendarView . setDate ( mCurrentDate . getTimeInMillis ( ) , _BOOL , _BOOL ) ; }
private void updateCalendarView ( ) { mCalendarView . setDate ( mCurrentDate . getTimeInMillis ( ) , _BOOL , _BOOL ) ; }
public void add ( ESRIRecord r ) throws IOException { if ( r . getShapeType ( ) == fileShapeType ) { verifyRecordBuffer ( r . getBinaryStoreSize ( ) ) ; int nBytes = r . write ( recBuf , _NUM ) ; raf . seek ( raf . length ( ) ) ; raf . write ( recBuf , _NUM , nBytes ) ; } else { Debug . error ( STRING + r . getShapeType ( ) + STRING + fileShapeType ) ; } }
public void add ( ESRIRecord r ) throws IOException { if ( r . getShapeType ( ) == fileShapeType ) { verifyRecordBuffer ( r . getBinaryStoreSize ( ) ) ; int nBytes = r . write ( recBuf , _NUM ) ; raf . seek ( raf . length ( ) ) ; raf . write ( recBuf , _NUM , nBytes ) ; } else { Debug . error ( STRING + r . getShapeType ( ) + STRING + fileShapeType ) ; } }
public SdpException ( String message , Throwable rootCause ) { super ( rootCause . getMessage ( ) + Separators . SEMICOLON + message ) ; }
public SdpException ( String message , Throwable rootCause ) { super ( rootCause . getMessage ( ) + Separators . SEMICOLON + message ) ; }
public static SwitchDateTimeDialogFragment newInstance ( String label , String positiveButton , String negativeButton ) { SwitchDateTimeDialogFragment switchDateTimeDialogFragment = new SwitchDateTimeDialogFragment ( ) ; Bundle args = new Bundle ( ) ; args . putString ( TAG_LABEL , label ) ; args . putString ( TAG_POSITIVE_BUTTON , positiveButton ) ; args . putString ( TAG_NEGATIVE_BUTTON , negativeButton ) ; switchDateTimeDialogFragment . setArguments ( args ) ; return switchDateTimeDialogFragment ; }
@ NotNull public static Map < RadComponent , List < RadComponent > > groupSiblings ( @ NotNull List < ? extends RadComponent > components ) { Map < RadComponent , List < RadComponent > > siblingLists = new HashMap < RadComponent , List < RadComponent > > ( ) ; if ( components . isEmpty ( ) ) { return siblingLists ; } if ( components . size ( ) == _NUM ) { RadComponent component = components . get ( _NUM ) ; siblingLists . put ( component . getParent ( ) , Collections . singletonList ( component ) ) ; return siblingLists ; } for ( RadComponent component : components ) { RadComponent parent = component . getParent ( ) ; List < RadComponent > children = siblingLists . get ( parent ) ; if ( children == null ) { children = new ArrayList < RadComponent > ( ) ; siblingLists . put ( parent , children ) ; } children . add ( component ) ; } return siblingLists ; }
@ NotNull public static Map < RadComponent , List < RadComponent > > groupSiblings ( @ NotNull List < ? extends RadComponent > components ) { Map < RadComponent , List < RadComponent > > siblingLists = new HashMap < RadComponent , List < RadComponent > > ( ) ; if ( components . isEmpty ( ) ) { return siblingLists ; } if ( components . size ( ) == _NUM ) { RadComponent component = components . get ( _NUM ) ; siblingLists . put ( component . getParent ( ) , Collections . singletonList ( component ) ) ; return siblingLists ; } for ( RadComponent component : components ) { RadComponent parent = component . getParent ( ) ; List < RadComponent > children = siblingLists . get ( parent ) ; if ( children == null ) { children = new ArrayList < RadComponent > ( ) ; siblingLists . put ( parent , children ) ; } children . add ( component ) ; } return siblingLists ; }
@ NotNull public static Map < RadComponent , List < RadComponent > > groupSiblings ( @ NotNull List < ? extends RadComponent > components ) { Map < RadComponent , List < RadComponent > > siblingLists = new HashMap < RadComponent , List < RadComponent > > ( ) ; if ( components . isEmpty ( ) ) { return siblingLists ; } if ( components . size ( ) == _NUM ) { RadComponent component = components . get ( _NUM ) ; siblingLists . put ( component . getParent ( ) , Collections . singletonList ( component ) ) ; return siblingLists ; } for ( RadComponent component : components ) { RadComponent parent = component . getParent ( ) ; List < RadComponent > children = siblingLists . get ( parent ) ; if ( children == null ) { children = new ArrayList < RadComponent > ( ) ; siblingLists . put ( parent , children ) ; } children . add ( component ) ; } return siblingLists ; }
@ NotNull public static Map < RadComponent , List < RadComponent > > groupSiblings ( @ NotNull List < ? extends RadComponent > components ) { Map < RadComponent , List < RadComponent > > siblingLists = new HashMap < RadComponent , List < RadComponent > > ( ) ; if ( components . isEmpty ( ) ) { return siblingLists ; } if ( components . size ( ) == _NUM ) { RadComponent component = components . get ( _NUM ) ; siblingLists . put ( component . getParent ( ) , Collections . singletonList ( component ) ) ; return siblingLists ; } for ( RadComponent component : components ) { RadComponent parent = component . getParent ( ) ; List < RadComponent > children = siblingLists . get ( parent ) ; if ( children == null ) { children = new ArrayList < RadComponent > ( ) ; siblingLists . put ( parent , children ) ; } children . add ( component ) ; } return siblingLists ; }
@ NotNull public static Map < RadComponent , List < RadComponent > > groupSiblings ( @ NotNull List < ? extends RadComponent > components ) { Map < RadComponent , List < RadComponent > > siblingLists = new HashMap < RadComponent , List < RadComponent > > ( ) ; if ( components . isEmpty ( ) ) { return siblingLists ; } if ( components . size ( ) == _NUM ) { RadComponent component = components . get ( _NUM ) ; siblingLists . put ( component . getParent ( ) , Collections . singletonList ( component ) ) ; return siblingLists ; } for ( RadComponent component : components ) { RadComponent parent = component . getParent ( ) ; List < RadComponent > children = siblingLists . get ( parent ) ; if ( children == null ) { children = new ArrayList < RadComponent > ( ) ; siblingLists . put ( parent , children ) ; } children . add ( component ) ; } return siblingLists ; }
@ NotNull public static Map < RadComponent , List < RadComponent > > groupSiblings ( @ NotNull List < ? extends RadComponent > components ) { Map < RadComponent , List < RadComponent > > siblingLists = new HashMap < RadComponent , List < RadComponent > > ( ) ; if ( components . isEmpty ( ) ) { return siblingLists ; } if ( components . size ( ) == _NUM ) { RadComponent component = components . get ( _NUM ) ; siblingLists . put ( component . getParent ( ) , Collections . singletonList ( component ) ) ; return siblingLists ; } for ( RadComponent component : components ) { RadComponent parent = component . getParent ( ) ; List < RadComponent > children = siblingLists . get ( parent ) ; if ( children == null ) { children = new ArrayList < RadComponent > ( ) ; siblingLists . put ( parent , children ) ; } children . add ( component ) ; } return siblingLists ; }
public static void copyStreams ( InputStream in , OutputStream out ) throws IOException { if ( in == null || out == null ) { throw new IllegalArgumentException ( ) ; } final byte [ ] buffer = new byte [ _NUM ] ; int len ; while ( - _NUM != ( len = in . read ( buffer , _NUM , buffer . length ) ) ) { out . write ( buffer , _NUM , len ) ; } }
void initProxy ( Class < ? > cl , ClassNotFoundException resolveEx , ObjectStreamClass superDesc ) throws InvalidClassException { ObjectStreamClass osc = null ; if ( cl != null ) { osc = lookup ( cl , _BOOL ) ; if ( ! osc . isProxy ) { throw new InvalidClassException ( STRING ) ; } } this . cl = cl ; this . resolveEx = resolveEx ; this . superDesc = superDesc ; isProxy = _BOOL ; serializable = _BOOL ; suid = Long . valueOf ( _NUM ) ; fields = NO_FIELDS ; if ( osc != null ) { localDesc = osc ; name = localDesc . name ; externalizable = localDesc . externalizable ; writeReplaceMethod = localDesc . writeReplaceMethod ; readResolveMethod = localDesc . readResolveMethod ; deserializeEx = localDesc . deserializeEx ; cons = localDesc . cons ; } fieldRefl = getReflector ( fields , localDesc ) ; initialized = _BOOL ; }
void initProxy ( Class < ? > cl , ClassNotFoundException resolveEx , ObjectStreamClass superDesc ) throws InvalidClassException { ObjectStreamClass osc = null ; if ( cl != null ) { osc = lookup ( cl , _BOOL ) ; if ( ! osc . isProxy ) { throw new InvalidClassException ( STRING ) ; } } this . cl = cl ; this . resolveEx = resolveEx ; this . superDesc = superDesc ; isProxy = _BOOL ; serializable = _BOOL ; suid = Long . valueOf ( _NUM ) ; fields = NO_FIELDS ; if ( osc != null ) { localDesc = osc ; name = localDesc . name ; externalizable = localDesc . externalizable ; writeReplaceMethod = localDesc . writeReplaceMethod ; readResolveMethod = localDesc . readResolveMethod ; deserializeEx = localDesc . deserializeEx ; cons = localDesc . cons ; } fieldRefl = getReflector ( fields , localDesc ) ; initialized = _BOOL ; }
@ Override public Storage createStorage ( StorageCreateRequest storageCreateRequest ) { validateStorageCreateRequest ( storageCreateRequest ) ; StoragePlatformEntity storagePlatformEntity = storagePlatformHelper . getStoragePlatformEntity ( storageCreateRequest . getStoragePlatformName ( ) ) ; StorageEntity storageEntity = storageDao . getStorageByName ( storageCreateRequest . getName ( ) ) ; if ( storageEntity != null ) { throw new AlreadyExistsException ( String . format ( STRING , storageCreateRequest . getName ( ) ) ) ; } storageEntity = new StorageEntity ( ) ; storageEntity . setName ( storageCreateRequest . getName ( ) ) ; storageEntity . setStoragePlatform ( storagePlatformEntity ) ; if ( ! CollectionUtils . isEmpty ( storageCreateRequest . getAttributes ( ) ) ) { List < StorageAttributeEntity > attributeEntities = new ArrayList < > ( ) ; storageEntity . setAttributes ( attributeEntities ) ; for ( Attribute attribute : storageCreateRequest . getAttributes ( ) ) { StorageAttributeEntity attributeEntity = new StorageAttributeEntity ( ) ; attributeEntities . add ( attributeEntity ) ; attributeEntity . setStorage ( storageEntity ) ; attributeEntity . setName ( attribute . getName ( ) ) ; attributeEntity . setValue ( attribute . getValue ( ) ) ; } } storageEntity = storageDao . saveAndRefresh ( storageEntity ) ; return createStorageFromEntity ( storageEntity ) ; }
public FPSTextureView addChild ( @ NonNull DisplayBase DisplayObject ) { DisplayObject . setUp ( mFps ) ; mDisplayList . add ( DisplayObject ) ; return this ; }
@ SuppressWarnings ( STRING ) private boolean scanVersionLine ( String line ) { if ( line != null ) { Matcher matcher = sAdbVersion . matcher ( line ) ; if ( matcher . matches ( ) ) { int majorVersion = Integer . parseInt ( matcher . group ( _NUM ) ) ; int minorVersion = Integer . parseInt ( matcher . group ( _NUM ) ) ; int microVersion = Integer . parseInt ( matcher . group ( _NUM ) ) ; if ( microVersion < ADB_VERSION_MICRO_MIN ) { String message = String . format ( STRING + STRING , majorVersion , minorVersion , ADB_VERSION_MICRO_MIN , microVersion ) ; Log . logAndDisplay ( LogLevel . ERROR , ADB , message ) ; } else if ( ADB_VERSION_MICRO_MAX != - _NUM && microVersion > ADB_VERSION_MICRO_MAX ) { String message = String . format ( STRING + STRING , majorVersion , minorVersion , ADB_VERSION_MICRO_MAX , microVersion ) ; Log . logAndDisplay ( LogLevel . ERROR , ADB , message ) ; } else { mVersionCheck = _BOOL ; } return _BOOL ; } } return _BOOL ; }
@ SuppressWarnings ( STRING ) private boolean scanVersionLine ( String line ) { if ( line != null ) { Matcher matcher = sAdbVersion . matcher ( line ) ; if ( matcher . matches ( ) ) { int majorVersion = Integer . parseInt ( matcher . group ( _NUM ) ) ; int minorVersion = Integer . parseInt ( matcher . group ( _NUM ) ) ; int microVersion = Integer . parseInt ( matcher . group ( _NUM ) ) ; if ( microVersion < ADB_VERSION_MICRO_MIN ) { String message = String . format ( STRING + STRING , majorVersion , minorVersion , ADB_VERSION_MICRO_MIN , microVersion ) ; Log . logAndDisplay ( LogLevel . ERROR , ADB , message ) ; } else if ( ADB_VERSION_MICRO_MAX != - _NUM && microVersion > ADB_VERSION_MICRO_MAX ) { String message = String . format ( STRING + STRING , majorVersion , minorVersion , ADB_VERSION_MICRO_MAX , microVersion ) ; Log . logAndDisplay ( LogLevel . ERROR , ADB , message ) ; } else { mVersionCheck = _BOOL ; } return _BOOL ; } } return _BOOL ; }
@ SuppressWarnings ( STRING ) private boolean scanVersionLine ( String line ) { if ( line != null ) { Matcher matcher = sAdbVersion . matcher ( line ) ; if ( matcher . matches ( ) ) { int majorVersion = Integer . parseInt ( matcher . group ( _NUM ) ) ; int minorVersion = Integer . parseInt ( matcher . group ( _NUM ) ) ; int microVersion = Integer . parseInt ( matcher . group ( _NUM ) ) ; if ( microVersion < ADB_VERSION_MICRO_MIN ) { String message = String . format ( STRING + STRING , majorVersion , minorVersion , ADB_VERSION_MICRO_MIN , microVersion ) ; Log . logAndDisplay ( LogLevel . ERROR , ADB , message ) ; } else if ( ADB_VERSION_MICRO_MAX != - _NUM && microVersion > ADB_VERSION_MICRO_MAX ) { String message = String . format ( STRING + STRING , majorVersion , minorVersion , ADB_VERSION_MICRO_MAX , microVersion ) ; Log . logAndDisplay ( LogLevel . ERROR , ADB , message ) ; } else { mVersionCheck = _BOOL ; } return _BOOL ; } } return _BOOL ; }
@ SuppressWarnings ( STRING ) private boolean scanVersionLine ( String line ) { if ( line != null ) { Matcher matcher = sAdbVersion . matcher ( line ) ; if ( matcher . matches ( ) ) { int majorVersion = Integer . parseInt ( matcher . group ( _NUM ) ) ; int minorVersion = Integer . parseInt ( matcher . group ( _NUM ) ) ; int microVersion = Integer . parseInt ( matcher . group ( _NUM ) ) ; if ( microVersion < ADB_VERSION_MICRO_MIN ) { String message = String . format ( STRING + STRING , majorVersion , minorVersion , ADB_VERSION_MICRO_MIN , microVersion ) ; Log . logAndDisplay ( LogLevel . ERROR , ADB , message ) ; } else if ( ADB_VERSION_MICRO_MAX != - _NUM && microVersion > ADB_VERSION_MICRO_MAX ) { String message = String . format ( STRING + STRING , majorVersion , minorVersion , ADB_VERSION_MICRO_MAX , microVersion ) ; Log . logAndDisplay ( LogLevel . ERROR , ADB , message ) ; } else { mVersionCheck = _BOOL ; } return _BOOL ; } } return _BOOL ; }
@ SuppressWarnings ( STRING ) private boolean scanVersionLine ( String line ) { if ( line != null ) { Matcher matcher = sAdbVersion . matcher ( line ) ; if ( matcher . matches ( ) ) { int majorVersion = Integer . parseInt ( matcher . group ( _NUM ) ) ; int minorVersion = Integer . parseInt ( matcher . group ( _NUM ) ) ; int microVersion = Integer . parseInt ( matcher . group ( _NUM ) ) ; if ( microVersion < ADB_VERSION_MICRO_MIN ) { String message = String . format ( STRING + STRING , majorVersion , minorVersion , ADB_VERSION_MICRO_MIN , microVersion ) ; Log . logAndDisplay ( LogLevel . ERROR , ADB , message ) ; } else if ( ADB_VERSION_MICRO_MAX != - _NUM && microVersion > ADB_VERSION_MICRO_MAX ) { String message = String . format ( STRING + STRING , majorVersion , minorVersion , ADB_VERSION_MICRO_MAX , microVersion ) ; Log . logAndDisplay ( LogLevel . ERROR , ADB , message ) ; } else { mVersionCheck = _BOOL ; } return _BOOL ; } } return _BOOL ; }
public PageFormat validatePage ( PageFormat page ) { PageFormat newPage = ( PageFormat ) page . clone ( ) ; Paper newPaper = new Paper ( ) ; validatePaper ( newPage . getPaper ( ) , newPaper ) ; newPage . setPaper ( newPaper ) ; return newPage ; }
public PageFormat validatePage ( PageFormat page ) { PageFormat newPage = ( PageFormat ) page . clone ( ) ; Paper newPaper = new Paper ( ) ; validatePaper ( newPage . getPaper ( ) , newPaper ) ; newPage . setPaper ( newPaper ) ; return newPage ; }
default B with ( String key , Object value ) { return with ( key , value != null ? value . toString ( ) : null ) ; }
default B with ( String key , Object value ) { return with ( key , value != null ? value . toString ( ) : null ) ; }
public void addItem ( int position , Object o ) { if ( ! isDataListEmpty ( ) && position >= _NUM && position <= mDataList . size ( ) ) { mDataList . add ( position , o ) ; notifyItemInserted ( position ) ; } }
public void addItem ( int position , Object o ) { if ( ! isDataListEmpty ( ) && position >= _NUM && position <= mDataList . size ( ) ) { mDataList . add ( position , o ) ; notifyItemInserted ( position ) ; } }
public void resetData ( ) { data . clear ( ) ; dataNames . clear ( ) ; dataSet . resetData ( dataNames , data , bins ) ; }
public void resetData ( ) { data . clear ( ) ; dataNames . clear ( ) ; dataSet . resetData ( dataNames , data , bins ) ; }
public void resetData ( ) { data . clear ( ) ; dataNames . clear ( ) ; dataSet . resetData ( dataNames , data , bins ) ; }
public static void writeElementList ( XMLOutput xmlOutput , String tagName , Iterator < String > listValueIterator ) throws IOException { while ( listValueIterator . hasNext ( ) ) { xmlOutput . openTag ( tagName ) ; xmlOutput . writeText ( listValueIterator . next ( ) ) ; xmlOutput . closeTag ( tagName ) ; } }
public void startHeartbeat ( Database database , String name ) throws SQLException { ArrayList < Column > whereClause = new ArrayList < Column > ( ) ; ArrayList < Column > values = new ArrayList < Column > ( ) ; Timestamp now = new Timestamp ( System . currentTimeMillis ( ) ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( STRING + name + STRING + now ) ; hbId . setValue ( KEY ) ; whereClause . add ( hbId ) ; hbSourceTstamp . setValue ( now ) ; hbSalt . setValue ( saltValue . getAndIncrement ( ) ) ; hbName . setValue ( name ) ; values . add ( hbSourceTstamp ) ; values . add ( hbSalt ) ; values . add ( hbName ) ; database . update ( hbTable , whereClause , values ) ; }
public void startHeartbeat ( Database database , String name ) throws SQLException { ArrayList < Column > whereClause = new ArrayList < Column > ( ) ; ArrayList < Column > values = new ArrayList < Column > ( ) ; Timestamp now = new Timestamp ( System . currentTimeMillis ( ) ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( STRING + name + STRING + now ) ; hbId . setValue ( KEY ) ; whereClause . add ( hbId ) ; hbSourceTstamp . setValue ( now ) ; hbSalt . setValue ( saltValue . getAndIncrement ( ) ) ; hbName . setValue ( name ) ; values . add ( hbSourceTstamp ) ; values . add ( hbSalt ) ; values . add ( hbName ) ; database . update ( hbTable , whereClause , values ) ; }
public boolean isValid ( World world ) { return _BOOL ; }
public boolean isValid ( World world ) { return _BOOL ; }
public boolean isValid ( World world ) { return _BOOL ; }
public boolean isValid ( World world ) { return _BOOL ; }
public boolean isValid ( World world ) { return _BOOL ; }
public boolean isValid ( World world ) { return _BOOL ; }
public boolean isValid ( World world ) { return _BOOL ; }
protected String colorToRGB ( final Color color ) { return String . format ( STRING , color . getRed ( ) , color . getGreen ( ) , color . getBlue ( ) ) ; }
public String normalizeUri ( String uri ) { if ( uri != null && ! uri . endsWith ( STRING ) ) { uri += STRING ; } return uri ; }
public String normalizeUri ( String uri ) { if ( uri != null && ! uri . endsWith ( STRING ) ) { uri += STRING ; } return uri ; }
private Generator ( boolean full , File buildDir , String packageNamePrefix , String lafName , SynthModel model ) { this . full = full ; if ( packageNamePrefix == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( buildDir == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( model == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( lafName == null ) { throw new IllegalArgumentException ( STRING ) ; } variables = new HashMap < String , String > ( ) ; variables . put ( STRING , packageNamePrefix ) ; variables . put ( STRING , lafName ) ; buildPackageRoot = new File ( buildDir , packageNamePrefix . replaceAll ( STRING , STRING ) ) ; buildPackageRoot . mkdirs ( ) ; this . packageNamePrefix = packageNamePrefix ; this . lafName = lafName ; this . model = model ; }
private Generator ( boolean full , File buildDir , String packageNamePrefix , String lafName , SynthModel model ) { this . full = full ; if ( packageNamePrefix == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( buildDir == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( model == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( lafName == null ) { throw new IllegalArgumentException ( STRING ) ; } variables = new HashMap < String , String > ( ) ; variables . put ( STRING , packageNamePrefix ) ; variables . put ( STRING , lafName ) ; buildPackageRoot = new File ( buildDir , packageNamePrefix . replaceAll ( STRING , STRING ) ) ; buildPackageRoot . mkdirs ( ) ; this . packageNamePrefix = packageNamePrefix ; this . lafName = lafName ; this . model = model ; }
private Generator ( boolean full , File buildDir , String packageNamePrefix , String lafName , SynthModel model ) { this . full = full ; if ( packageNamePrefix == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( buildDir == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( model == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( lafName == null ) { throw new IllegalArgumentException ( STRING ) ; } variables = new HashMap < String , String > ( ) ; variables . put ( STRING , packageNamePrefix ) ; variables . put ( STRING , lafName ) ; buildPackageRoot = new File ( buildDir , packageNamePrefix . replaceAll ( STRING , STRING ) ) ; buildPackageRoot . mkdirs ( ) ; this . packageNamePrefix = packageNamePrefix ; this . lafName = lafName ; this . model = model ; }
private Generator ( boolean full , File buildDir , String packageNamePrefix , String lafName , SynthModel model ) { this . full = full ; if ( packageNamePrefix == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( buildDir == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( model == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( lafName == null ) { throw new IllegalArgumentException ( STRING ) ; } variables = new HashMap < String , String > ( ) ; variables . put ( STRING , packageNamePrefix ) ; variables . put ( STRING , lafName ) ; buildPackageRoot = new File ( buildDir , packageNamePrefix . replaceAll ( STRING , STRING ) ) ; buildPackageRoot . mkdirs ( ) ; this . packageNamePrefix = packageNamePrefix ; this . lafName = lafName ; this . model = model ; }
public void renderValidationMessages ( PaymentItem paymentItem ) { fieldIdsOfErrorMessagesShowing . clear ( ) ; for ( ValidationErrorMessage validationResult : validationMessages ) { renderValidationMessageOnScreen ( validationResult , paymentItem ) ; } }
public void renderValidationMessages ( PaymentItem paymentItem ) { fieldIdsOfErrorMessagesShowing . clear ( ) ; for ( ValidationErrorMessage validationResult : validationMessages ) { renderValidationMessageOnScreen ( validationResult , paymentItem ) ; } }
public void addAll ( final Collection < ? extends T > collection ) { synchronized ( mLock ) { mList . addAll ( collection ) ; } notifyDataSetChanged ( ) ; }
public void addAll ( final Collection < ? extends T > collection ) { synchronized ( mLock ) { mList . addAll ( collection ) ; } notifyDataSetChanged ( ) ; }
public void addTestDataSource ( Class < ? > classContext , String testDataDir ) { classContexts . add ( classContext ) ; testDataDirs . add ( testDataDir ) ; }
void remove ( final BlazeVertex vertex ) { final String queryStr = sparql . removeVertex ( vertex ) ; update ( queryStr ) ; }
private static String fillString ( String in , int len ) { String out = new String ( in ) ; while ( out . length ( ) < len ) { out = STRING + out ; } return ( out ) ; }
private static String fillString ( String in , int len ) { String out = new String ( in ) ; while ( out . length ( ) < len ) { out = STRING + out ; } return ( out ) ; }
private PhrasePositions [ ] repeatingPPs ( HashMap < Term , Integer > rptTerms ) { ArrayList < PhrasePositions > rp = new ArrayList < > ( ) ; for ( PhrasePositions pp : phrasePositions ) { for ( Term t : pp . terms ) { if ( rptTerms . containsKey ( t ) ) { rp . add ( pp ) ; hasMultiTermRpts |= ( pp . terms . length > _NUM ) ; break ; } } } return rp . toArray ( new PhrasePositions [ _NUM ] ) ; }
public String byteStringNoSemicolon ( ) { StringBuilder retval = new StringBuilder ( ) ; try { while ( _BOOL ) { char next = lookAhead ( _NUM ) ; if ( next == STRING || next == STRING || next == STRING || next == STRING ) { break ; } else { consume ( _NUM ) ; retval . append ( next ) ; } } } catch ( ParseException ex ) { return retval . toString ( ) ; } return retval . toString ( ) ; }
public String byteStringNoSemicolon ( ) { StringBuilder retval = new StringBuilder ( ) ; try { while ( _BOOL ) { char next = lookAhead ( _NUM ) ; if ( next == STRING || next == STRING || next == STRING || next == STRING ) { break ; } else { consume ( _NUM ) ; retval . append ( next ) ; } } } catch ( ParseException ex ) { return retval . toString ( ) ; } return retval . toString ( ) ; }
public String toHTML ( ) { List < TestCase > failed = getFailedTestCases ( ) ; List < TestCase > passed = getPassedTestCases ( ) ; List < TestCase > skipped = getSkippedTestCases ( ) ; StringBuffer buff = new StringBuffer ( ) ; for ( TestCase tc : failed ) { buff . append ( tc . toHTML ( ) ) ; } for ( TestCase tc : passed ) { buff . append ( tc . toHTML ( ) ) ; } for ( TestCase tc : skipped ) { buff . append ( tc . toHTML ( ) ) ; } Object [ ] params = { name , buff . toString ( ) } ; return MessageFormat . format ( HTMLConstants . TEST_TABLE , params ) ; }
private boolean matchFilter ( String string , String pattern ) { if ( pattern . equals ( STRING ) || pattern . equals ( string ) ) { return _BOOL ; } int length = pattern . length ( ) ; int wildCardIndex = pattern . indexOf ( STRING ) ; if ( wildCardIndex >= _NUM ) { String patternSubStr = pattern . substring ( _NUM , wildCardIndex ) ; if ( ! string . startsWith ( patternSubStr , _NUM ) ) { return _BOOL ; } int beginIndex = patternSubStr . length ( ) + _NUM ; int stringIndex = _NUM ; if ( wildCardIndex > _NUM ) { stringIndex = beginIndex ; } String sub = pattern . substring ( beginIndex , length ) ; while ( ( wildCardIndex = pattern . indexOf ( STRING , beginIndex ) ) != - _NUM ) { patternSubStr = pattern . substring ( beginIndex , wildCardIndex ) ; if ( string . indexOf ( patternSubStr , stringIndex ) == - _NUM ) { return _BOOL ; } beginIndex = wildCardIndex + _NUM ; stringIndex = stringIndex + patternSubStr . length ( ) + _NUM ; sub = pattern . substring ( beginIndex , length ) ; } if ( string . endsWith ( sub ) ) { return _BOOL ; } } return _BOOL ; }
private boolean matchFilter ( String string , String pattern ) { if ( pattern . equals ( STRING ) || pattern . equals ( string ) ) { return _BOOL ; } int length = pattern . length ( ) ; int wildCardIndex = pattern . indexOf ( STRING ) ; if ( wildCardIndex >= _NUM ) { String patternSubStr = pattern . substring ( _NUM , wildCardIndex ) ; if ( ! string . startsWith ( patternSubStr , _NUM ) ) { return _BOOL ; } int beginIndex = patternSubStr . length ( ) + _NUM ; int stringIndex = _NUM ; if ( wildCardIndex > _NUM ) { stringIndex = beginIndex ; } String sub = pattern . substring ( beginIndex , length ) ; while ( ( wildCardIndex = pattern . indexOf ( STRING , beginIndex ) ) != - _NUM ) { patternSubStr = pattern . substring ( beginIndex , wildCardIndex ) ; if ( string . indexOf ( patternSubStr , stringIndex ) == - _NUM ) { return _BOOL ; } beginIndex = wildCardIndex + _NUM ; stringIndex = stringIndex + patternSubStr . length ( ) + _NUM ; sub = pattern . substring ( beginIndex , length ) ; } if ( string . endsWith ( sub ) ) { return _BOOL ; } } return _BOOL ; }
public int [ ] toArray ( ) { int [ ] value = new int [ _size ] ; System . arraycopy ( _data , _NUM , value , _NUM , _size ) ; return value ; }
@ Override public void run ( ) { _log . info ( STRING ) ; try { if ( ! _callHomeEventManager . canSendEvent ( ) ) { return ; } int totalSleep = _NUM ; while ( _BOOL ) { if ( _licenseManager . getTargetInfoLock ( ) ) { try { performSendEvents ( ) ; } catch ( Exception e ) { _log . error ( STRING , e ) ; break ; } finally { _licenseManager . releaseTargetVersionLock ( ) ; } break ; } else { _log . info ( STRING ) ; if ( totalSleep >= CallHomeConstants . MAX_LOCK_WAIT_TIME_MS ) { _log . warn ( STRING , CallHomeConstants . MAX_LOCK_WAIT_TIME_MS ) ; break ; } Thread . sleep ( CallHomeConstants . LOCK_WAIT_TIME_MS ) ; totalSleep += CallHomeConstants . LOCK_WAIT_TIME_MS ; } } } catch ( APIException i ) { _log . info ( STRING ) ; } catch ( Exception e ) { _log . error ( STRING , e ) ; } _log . info ( STRING ) ; }
@ Override public void run ( ) { _log . info ( STRING ) ; try { if ( ! _callHomeEventManager . canSendEvent ( ) ) { return ; } int totalSleep = _NUM ; while ( _BOOL ) { if ( _licenseManager . getTargetInfoLock ( ) ) { try { performSendEvents ( ) ; } catch ( Exception e ) { _log . error ( STRING , e ) ; break ; } finally { _licenseManager . releaseTargetVersionLock ( ) ; } break ; } else { _log . info ( STRING ) ; if ( totalSleep >= CallHomeConstants . MAX_LOCK_WAIT_TIME_MS ) { _log . warn ( STRING , CallHomeConstants . MAX_LOCK_WAIT_TIME_MS ) ; break ; } Thread . sleep ( CallHomeConstants . LOCK_WAIT_TIME_MS ) ; totalSleep += CallHomeConstants . LOCK_WAIT_TIME_MS ; } } } catch ( APIException i ) { _log . info ( STRING ) ; } catch ( Exception e ) { _log . error ( STRING , e ) ; } _log . info ( STRING ) ; }
public void simulateMethod ( SootMethod method , ReferenceVariable thisVar , ReferenceVariable returnVar , ReferenceVariable params [ ] ) { String subSignature = method . getSubSignature ( ) ; if ( subSignature . equals ( STRING ) ) { java_net_InetAddressImpl_getLocalHostName ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STRING ) ) { java_net_InetAddressImpl_getHostByAddr ( method , thisVar , returnVar , params ) ; return ; } else { defaultMethod ( method , thisVar , returnVar , params ) ; return ; } }
public void simulateMethod ( SootMethod method , ReferenceVariable thisVar , ReferenceVariable returnVar , ReferenceVariable params [ ] ) { String subSignature = method . getSubSignature ( ) ; if ( subSignature . equals ( STRING ) ) { java_net_InetAddressImpl_getLocalHostName ( method , thisVar , returnVar , params ) ; return ; } else if ( subSignature . equals ( STRING ) ) { java_net_InetAddressImpl_getHostByAddr ( method , thisVar , returnVar , params ) ; return ; } else { defaultMethod ( method , thisVar , returnVar , params ) ; return ; } }
public static String transformToolTipText ( final String description , final boolean addHTMLTags , final int lineLength , final boolean escapeSlashes , final boolean escapeHTML ) { String completeText = description . trim ( ) ; if ( escapeHTML ) { completeText = Tools . escapeHTML ( completeText ) ; } if ( escapeSlashes ) { completeText = completeText . replaceAll ( STRING , STRING ) ; } StringBuffer result = new StringBuffer ( ) ; if ( addHTMLTags ) { result . append ( STRING ) ; } completeText = Tools . transformAllLineSeparators ( completeText ) ; String [ ] lines = completeText . split ( STRING ) ; for ( String text : lines ) { boolean first = _BOOL ; while ( text . length ( ) > lineLength ) { int spaceIndex = text . indexOf ( STRING , lineLength ) ; if ( ! first ) { result . append ( STRING ) ; } first = _BOOL ; if ( spaceIndex >= _NUM ) { result . append ( text . substring ( _NUM , spaceIndex ) ) ; text = text . substring ( spaceIndex + _NUM ) ; } else { result . append ( text ) ; text = STRING ; } } if ( ! first && text . length ( ) > _NUM ) { result . append ( STRING ) ; } result . append ( text ) ; result . append ( STRING ) ; } if ( addHTMLTags ) { result . append ( STRING ) ; } return result . toString ( ) ; }
public static String transformToolTipText ( final String description , final boolean addHTMLTags , final int lineLength , final boolean escapeSlashes , final boolean escapeHTML ) { String completeText = description . trim ( ) ; if ( escapeHTML ) { completeText = Tools . escapeHTML ( completeText ) ; } if ( escapeSlashes ) { completeText = completeText . replaceAll ( STRING , STRING ) ; } StringBuffer result = new StringBuffer ( ) ; if ( addHTMLTags ) { result . append ( STRING ) ; } completeText = Tools . transformAllLineSeparators ( completeText ) ; String [ ] lines = completeText . split ( STRING ) ; for ( String text : lines ) { boolean first = _BOOL ; while ( text . length ( ) > lineLength ) { int spaceIndex = text . indexOf ( STRING , lineLength ) ; if ( ! first ) { result . append ( STRING ) ; } first = _BOOL ; if ( spaceIndex >= _NUM ) { result . append ( text . substring ( _NUM , spaceIndex ) ) ; text = text . substring ( spaceIndex + _NUM ) ; } else { result . append ( text ) ; text = STRING ; } } if ( ! first && text . length ( ) > _NUM ) { result . append ( STRING ) ; } result . append ( text ) ; result . append ( STRING ) ; } if ( addHTMLTags ) { result . append ( STRING ) ; } return result . toString ( ) ; }
public static String transformToolTipText ( final String description , final boolean addHTMLTags , final int lineLength , final boolean escapeSlashes , final boolean escapeHTML ) { String completeText = description . trim ( ) ; if ( escapeHTML ) { completeText = Tools . escapeHTML ( completeText ) ; } if ( escapeSlashes ) { completeText = completeText . replaceAll ( STRING , STRING ) ; } StringBuffer result = new StringBuffer ( ) ; if ( addHTMLTags ) { result . append ( STRING ) ; } completeText = Tools . transformAllLineSeparators ( completeText ) ; String [ ] lines = completeText . split ( STRING ) ; for ( String text : lines ) { boolean first = _BOOL ; while ( text . length ( ) > lineLength ) { int spaceIndex = text . indexOf ( STRING , lineLength ) ; if ( ! first ) { result . append ( STRING ) ; } first = _BOOL ; if ( spaceIndex >= _NUM ) { result . append ( text . substring ( _NUM , spaceIndex ) ) ; text = text . substring ( spaceIndex + _NUM ) ; } else { result . append ( text ) ; text = STRING ; } } if ( ! first && text . length ( ) > _NUM ) { result . append ( STRING ) ; } result . append ( text ) ; result . append ( STRING ) ; } if ( addHTMLTags ) { result . append ( STRING ) ; } return result . toString ( ) ; }
protected static void printExceptionStack ( Throwable th , PrintWriter out , int depth ) { boolean printStackDepth = depth > _NUM ; Throwable wrappedException = ExceptionUtil . wrappedException ( th ) ; if ( wrappedException != null ) { printStackDepth = _BOOL ; printExceptionStack ( wrappedException , out , depth + _NUM ) ; } if ( printStackDepth ) { out . write ( STRING + depth + STRING ) ; } th . printStackTrace ( out ) ; }
public short readShortLE ( ) throws IOException { inputStream . readFully ( workSpace , _NUM , _NUM ) ; return ( short ) ( ( ( workSpace [ _NUM ] & _NUM ) << _NUM ) | ( workSpace [ _NUM ] & _NUM ) ) ; }
public short readShortLE ( ) throws IOException { inputStream . readFully ( workSpace , _NUM , _NUM ) ; return ( short ) ( ( ( workSpace [ _NUM ] & _NUM ) << _NUM ) | ( workSpace [ _NUM ] & _NUM ) ) ; }
private List < LatLng > createRectangle ( LatLng center , double halfWidth , double halfHeight ) { return Arrays . asList ( new LatLng ( center . latitude - halfHeight , center . longitude - halfWidth ) , new LatLng ( center . latitude - halfHeight , center . longitude + halfWidth ) , new LatLng ( center . latitude + halfHeight , center . longitude + halfWidth ) , new LatLng ( center . latitude + halfHeight , center . longitude - halfWidth ) , new LatLng ( center . latitude - halfHeight , center . longitude - halfWidth ) ) ; }
private List < LatLng > createRectangle ( LatLng center , double halfWidth , double halfHeight ) { return Arrays . asList ( new LatLng ( center . latitude - halfHeight , center . longitude - halfWidth ) , new LatLng ( center . latitude - halfHeight , center . longitude + halfWidth ) , new LatLng ( center . latitude + halfHeight , center . longitude + halfWidth ) , new LatLng ( center . latitude + halfHeight , center . longitude - halfWidth ) , new LatLng ( center . latitude - halfHeight , center . longitude - halfWidth ) ) ; }
private List < LatLng > createRectangle ( LatLng center , double halfWidth , double halfHeight ) { return Arrays . asList ( new LatLng ( center . latitude - halfHeight , center . longitude - halfWidth ) , new LatLng ( center . latitude - halfHeight , center . longitude + halfWidth ) , new LatLng ( center . latitude + halfHeight , center . longitude + halfWidth ) , new LatLng ( center . latitude + halfHeight , center . longitude - halfWidth ) , new LatLng ( center . latitude - halfHeight , center . longitude - halfWidth ) ) ; }
@ Override public final boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { for ( TypeElement elem : ElementFilter . typesIn ( roundEnv . getRootElements ( ) ) ) { elements . add ( elem . getQualifiedName ( ) ) ; } return _BOOL ; }
@ Override public final boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { for ( TypeElement elem : ElementFilter . typesIn ( roundEnv . getRootElements ( ) ) ) { elements . add ( elem . getQualifiedName ( ) ) ; } return _BOOL ; }
@ Override public final boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { for ( TypeElement elem : ElementFilter . typesIn ( roundEnv . getRootElements ( ) ) ) { elements . add ( elem . getQualifiedName ( ) ) ; } return _BOOL ; }
@ Override public final boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { for ( TypeElement elem : ElementFilter . typesIn ( roundEnv . getRootElements ( ) ) ) { elements . add ( elem . getQualifiedName ( ) ) ; } return _BOOL ; }
public DBInstanceInfo retrieveDBInfo ( String dbGroupName , String hostName ) { Connection conn = null ; try { conn = createConnection ( _BOOL ) ; return retrieveDBInfo ( conn , dbGroupName , hostName ) ; } catch ( Exception ex ) { logger . log ( Level . SEVERE , STRING , ex ) ; } finally { DBUtils . close ( conn ) ; } return null ; }
@ Override protected void initializeBounds ( ) { super . initializeBounds ( ) ; final Shell dialogShell = getShell ( ) ; if ( enforceMinimumSize ) { final Point computedSize = defaultComputeMinimumSize ( ) ; final Rectangle constrainedBounds = getConstrainedShellBounds ( new Rectangle ( _NUM , _NUM , computedSize . x , computedSize . y ) ) ; minimumSizeEnforcer = new ShellMinimumSizeEnforcer ( dialogShell , constrainedBounds . width , constrainedBounds . height ) ; final String messageFormat = STRING ; final String message = MessageFormat . format ( messageFormat , Integer . toString ( constrainedBounds . width ) , Integer . toString ( constrainedBounds . height ) ) ; log . trace ( message ) ; } if ( resizableDirections != ( SWT . HORIZONTAL | SWT . VERTICAL ) ) { resizeEnforcer = new ShellResizeEnforcer ( dialogShell , resizableDirections ) ; } }
@ Override protected void initializeBounds ( ) { super . initializeBounds ( ) ; final Shell dialogShell = getShell ( ) ; if ( enforceMinimumSize ) { final Point computedSize = defaultComputeMinimumSize ( ) ; final Rectangle constrainedBounds = getConstrainedShellBounds ( new Rectangle ( _NUM , _NUM , computedSize . x , computedSize . y ) ) ; minimumSizeEnforcer = new ShellMinimumSizeEnforcer ( dialogShell , constrainedBounds . width , constrainedBounds . height ) ; final String messageFormat = STRING ; final String message = MessageFormat . format ( messageFormat , Integer . toString ( constrainedBounds . width ) , Integer . toString ( constrainedBounds . height ) ) ; log . trace ( message ) ; } if ( resizableDirections != ( SWT . HORIZONTAL | SWT . VERTICAL ) ) { resizeEnforcer = new ShellResizeEnforcer ( dialogShell , resizableDirections ) ; } }
@ Override protected void initializeBounds ( ) { super . initializeBounds ( ) ; final Shell dialogShell = getShell ( ) ; if ( enforceMinimumSize ) { final Point computedSize = defaultComputeMinimumSize ( ) ; final Rectangle constrainedBounds = getConstrainedShellBounds ( new Rectangle ( _NUM , _NUM , computedSize . x , computedSize . y ) ) ; minimumSizeEnforcer = new ShellMinimumSizeEnforcer ( dialogShell , constrainedBounds . width , constrainedBounds . height ) ; final String messageFormat = STRING ; final String message = MessageFormat . format ( messageFormat , Integer . toString ( constrainedBounds . width ) , Integer . toString ( constrainedBounds . height ) ) ; log . trace ( message ) ; } if ( resizableDirections != ( SWT . HORIZONTAL | SWT . VERTICAL ) ) { resizeEnforcer = new ShellResizeEnforcer ( dialogShell , resizableDirections ) ; } }
@ Override protected void initializeBounds ( ) { super . initializeBounds ( ) ; final Shell dialogShell = getShell ( ) ; if ( enforceMinimumSize ) { final Point computedSize = defaultComputeMinimumSize ( ) ; final Rectangle constrainedBounds = getConstrainedShellBounds ( new Rectangle ( _NUM , _NUM , computedSize . x , computedSize . y ) ) ; minimumSizeEnforcer = new ShellMinimumSizeEnforcer ( dialogShell , constrainedBounds . width , constrainedBounds . height ) ; final String messageFormat = STRING ; final String message = MessageFormat . format ( messageFormat , Integer . toString ( constrainedBounds . width ) , Integer . toString ( constrainedBounds . height ) ) ; log . trace ( message ) ; } if ( resizableDirections != ( SWT . HORIZONTAL | SWT . VERTICAL ) ) { resizeEnforcer = new ShellResizeEnforcer ( dialogShell , resizableDirections ) ; } }
@ Override protected void initializeBounds ( ) { super . initializeBounds ( ) ; final Shell dialogShell = getShell ( ) ; if ( enforceMinimumSize ) { final Point computedSize = defaultComputeMinimumSize ( ) ; final Rectangle constrainedBounds = getConstrainedShellBounds ( new Rectangle ( _NUM , _NUM , computedSize . x , computedSize . y ) ) ; minimumSizeEnforcer = new ShellMinimumSizeEnforcer ( dialogShell , constrainedBounds . width , constrainedBounds . height ) ; final String messageFormat = STRING ; final String message = MessageFormat . format ( messageFormat , Integer . toString ( constrainedBounds . width ) , Integer . toString ( constrainedBounds . height ) ) ; log . trace ( message ) ; } if ( resizableDirections != ( SWT . HORIZONTAL | SWT . VERTICAL ) ) { resizeEnforcer = new ShellResizeEnforcer ( dialogShell , resizableDirections ) ; } }
@ Override protected void initializeBounds ( ) { super . initializeBounds ( ) ; final Shell dialogShell = getShell ( ) ; if ( enforceMinimumSize ) { final Point computedSize = defaultComputeMinimumSize ( ) ; final Rectangle constrainedBounds = getConstrainedShellBounds ( new Rectangle ( _NUM , _NUM , computedSize . x , computedSize . y ) ) ; minimumSizeEnforcer = new ShellMinimumSizeEnforcer ( dialogShell , constrainedBounds . width , constrainedBounds . height ) ; final String messageFormat = STRING ; final String message = MessageFormat . format ( messageFormat , Integer . toString ( constrainedBounds . width ) , Integer . toString ( constrainedBounds . height ) ) ; log . trace ( message ) ; } if ( resizableDirections != ( SWT . HORIZONTAL | SWT . VERTICAL ) ) { resizeEnforcer = new ShellResizeEnforcer ( dialogShell , resizableDirections ) ; } }
private static String toString ( Serializable o ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( baos ) ; oos . writeObject ( o ) ; oos . close ( ) ; return new String ( Base64 . encode ( baos . toByteArray ( ) , Base64 . DEFAULT ) ) ; }
private Token scanFlowScalar ( char style ) { boolean _double ; if ( style == STRING ) { _double = _BOOL ; } else { _double = _BOOL ; } StringBuilder chunks = new StringBuilder ( ) ; Mark startMark = reader . getMark ( ) ; char quote = reader . peek ( ) ; reader . forward ( ) ; chunks . append ( scanFlowScalarNonSpaces ( _double , startMark ) ) ; while ( reader . peek ( ) != quote ) { chunks . append ( scanFlowScalarSpaces ( startMark ) ) ; chunks . append ( scanFlowScalarNonSpaces ( _double , startMark ) ) ; } reader . forward ( ) ; Mark endMark = reader . getMark ( ) ; return new ScalarToken ( chunks . toString ( ) , _BOOL , startMark , endMark , style ) ; }
public void reset ( ) { initialize ( ) ; }
protected Node binaryNumericPromotion ( Node node , TypeMirror exprType ) { node = unbox ( node ) ; if ( ! types . isSameType ( node . getType ( ) , exprType ) ) { Node widened = new WideningConversionNode ( node . getTree ( ) , node , exprType ) ; addToConvertedLookupMap ( widened ) ; insertNodeAfter ( widened , node ) ; return widened ; } else { return node ; } }
protected Node binaryNumericPromotion ( Node node , TypeMirror exprType ) { node = unbox ( node ) ; if ( ! types . isSameType ( node . getType ( ) , exprType ) ) { Node widened = new WideningConversionNode ( node . getTree ( ) , node , exprType ) ; addToConvertedLookupMap ( widened ) ; insertNodeAfter ( widened , node ) ; return widened ; } else { return node ; } }
protected Node binaryNumericPromotion ( Node node , TypeMirror exprType ) { node = unbox ( node ) ; if ( ! types . isSameType ( node . getType ( ) , exprType ) ) { Node widened = new WideningConversionNode ( node . getTree ( ) , node , exprType ) ; addToConvertedLookupMap ( widened ) ; insertNodeAfter ( widened , node ) ; return widened ; } else { return node ; } }
public String encode ( ) { StringBuffer sb = new StringBuffer ( ) ; encode ( sb ) ; return sb . toString ( ) ; }
public String encode ( ) { StringBuffer sb = new StringBuffer ( ) ; encode ( sb ) ; return sb . toString ( ) ; }
String readLiteral ( String source , int ofs , String token ) { return readSubstring ( source , ofs , ofs + token . length ( ) ) ; }
public void skip ( int n ) throws IOException { dis . skip ( n ) ; }
public long time ( int i ) { long offset = _NUM ; for ( int j = indices . length - _NUM ; j >= _NUM ; j -- ) { if ( i >= indices [ j ] ) { offset = offsets [ j ] ; break ; } } return offset + rtimes [ i ] ; }
protected RamlResponse extractResponseFromMethod ( Method method , String responseComment ) { RamlModelFactory ramlModelFactory = RamlModelFactoryOfFactories . createRamlModelFactory ( ) ; RamlResponse response = ramlModelFactory . createRamlResponse ( ) ; String mime = extractMimeTypeFromMethod ( method ) ; RamlMimeType jsonType = ramlModelFactory . createRamlMimeTypeWithMime ( mime ) ; Class < ? > returnType = method . getReturnType ( ) ; Type genericReturnType = method . getGenericReturnType ( ) ; Type inferGenericType = TypeHelper . inferGenericType ( genericReturnType ) ; if ( returnType != null && ( returnType . equals ( DeferredResult . class ) || returnType . equals ( ResponseEntity . class ) ) ) { if ( inferGenericType == null ) { inferGenericType = Object . class ; } if ( inferGenericType instanceof Class ) { returnType = ( Class < ? > ) inferGenericType ; } genericReturnType = inferGenericType ; } jsonType . setSchema ( SchemaHelper . convertClassToJsonSchema ( genericReturnType , responseComment , javaDocs . getJavaDoc ( returnType ) ) ) ; LinkedHashMap < String , RamlMimeType > body = new LinkedHashMap < > ( ) ; body . put ( mime , jsonType ) ; response . setBody ( body ) ; if ( StringUtils . hasText ( responseComment ) ) { response . setDescription ( responseComment ) ; } else { response . setDescription ( STRING ) ; } return response ; }
protected HashEntry createEntry ( HashEntry next , int hashCode , Object key , Object value ) { return new ReferenceEntry ( this , next , hashCode , key , value ) ; }
public Result < Object [ ] > evaluate ( Class < ? > ... concepts ) throws QueryEvaluationException { TupleQueryResult tuple = query . evaluate ( ) ; List < String > bindings = tuple . getBindingNames ( ) ; bindings = bindings . subList ( _NUM , concepts . length ) ; return new ResultImpl ( new ObjectArrayCursor ( manager , tuple , bindings ) ) ; }
public Result < Object [ ] > evaluate ( Class < ? > ... concepts ) throws QueryEvaluationException { TupleQueryResult tuple = query . evaluate ( ) ; List < String > bindings = tuple . getBindingNames ( ) ; bindings = bindings . subList ( _NUM , concepts . length ) ; return new ResultImpl ( new ObjectArrayCursor ( manager , tuple , bindings ) ) ; }
public Result < Object [ ] > evaluate ( Class < ? > ... concepts ) throws QueryEvaluationException { TupleQueryResult tuple = query . evaluate ( ) ; List < String > bindings = tuple . getBindingNames ( ) ; bindings = bindings . subList ( _NUM , concepts . length ) ; return new ResultImpl ( new ObjectArrayCursor ( manager , tuple , bindings ) ) ; }
private Ease overlap ( int l ) { Ease a = new Ease ( ) ; for ( int noa = l ; noa < m_levelNum ; noa ++ ) { for ( int nob = m_levels [ noa ] . m_start ; nob < m_levels [ noa ] . m_end ; nob ++ ) { a . m_amount = m_groups [ nob ] . m_right - m_groups [ nob + _NUM ] . m_left + _NUM ; if ( a . m_amount >= _NUM ) { a . m_amount ++ ; a . m_lev = noa ; a . m_place = nob ; return a ; } } } return null ; }
private Ease overlap ( int l ) { Ease a = new Ease ( ) ; for ( int noa = l ; noa < m_levelNum ; noa ++ ) { for ( int nob = m_levels [ noa ] . m_start ; nob < m_levels [ noa ] . m_end ; nob ++ ) { a . m_amount = m_groups [ nob ] . m_right - m_groups [ nob + _NUM ] . m_left + _NUM ; if ( a . m_amount >= _NUM ) { a . m_amount ++ ; a . m_lev = noa ; a . m_place = nob ; return a ; } } } return null ; }
private Ease overlap ( int l ) { Ease a = new Ease ( ) ; for ( int noa = l ; noa < m_levelNum ; noa ++ ) { for ( int nob = m_levels [ noa ] . m_start ; nob < m_levels [ noa ] . m_end ; nob ++ ) { a . m_amount = m_groups [ nob ] . m_right - m_groups [ nob + _NUM ] . m_left + _NUM ; if ( a . m_amount >= _NUM ) { a . m_amount ++ ; a . m_lev = noa ; a . m_place = nob ; return a ; } } } return null ; }
private void writeJournal ( ParcelFileDescriptor newState , BackupProtos . Journal journal ) { FileOutputStream outStream = null ; try { outStream = new FileOutputStream ( newState . getFileDescriptor ( ) ) ; final byte [ ] journalBytes = writeCheckedBytes ( journal ) ; outStream . write ( journalBytes ) ; outStream . close ( ) ; if ( VERBOSE ) Log . v ( TAG , STRING + journalBytes . length + STRING ) ; } catch ( IOException e ) { Log . w ( TAG , STRING , e ) ; } }
private void writeJournal ( ParcelFileDescriptor newState , BackupProtos . Journal journal ) { FileOutputStream outStream = null ; try { outStream = new FileOutputStream ( newState . getFileDescriptor ( ) ) ; final byte [ ] journalBytes = writeCheckedBytes ( journal ) ; outStream . write ( journalBytes ) ; outStream . close ( ) ; if ( VERBOSE ) Log . v ( TAG , STRING + journalBytes . length + STRING ) ; } catch ( IOException e ) { Log . w ( TAG , STRING , e ) ; } }
private void writeJournal ( ParcelFileDescriptor newState , BackupProtos . Journal journal ) { FileOutputStream outStream = null ; try { outStream = new FileOutputStream ( newState . getFileDescriptor ( ) ) ; final byte [ ] journalBytes = writeCheckedBytes ( journal ) ; outStream . write ( journalBytes ) ; outStream . close ( ) ; if ( VERBOSE ) Log . v ( TAG , STRING + journalBytes . length + STRING ) ; } catch ( IOException e ) { Log . w ( TAG , STRING , e ) ; } }
public void addStep ( final IStep step ) { if ( step == null ) throw new IllegalArgumentException ( ) ; if ( step == this ) throw new IllegalArgumentException ( ) ; steps . add ( step ) ; }
public static String buildFailureOutput ( Throwable cause ) { String message = getMessageFromCause ( cause ) ; return STRING + message ; }
@ Override public boolean shouldCreateDatabaseSchema ( Set < String > createdDatabaseSchemas ) { return hasDatabaseSchema ( ) && ! createdDatabaseSchemas . contains ( getDatabaseSchema ( ) ) ; }
@ Override public boolean shouldCreateDatabaseSchema ( Set < String > createdDatabaseSchemas ) { return hasDatabaseSchema ( ) && ! createdDatabaseSchemas . contains ( getDatabaseSchema ( ) ) ; }
protected void validateHole ( BaseLineStringBuilder shell , BaseLineStringBuilder hole ) { HashSet exterior = Sets . newHashSet ( shell . points ) ; HashSet interior = Sets . newHashSet ( hole . points ) ; exterior . retainAll ( interior ) ; if ( exterior . size ( ) >= _NUM ) { throw new InvalidShapeException ( STRING ) ; } }
protected void validateHole ( BaseLineStringBuilder shell , BaseLineStringBuilder hole ) { HashSet exterior = Sets . newHashSet ( shell . points ) ; HashSet interior = Sets . newHashSet ( hole . points ) ; exterior . retainAll ( interior ) ; if ( exterior . size ( ) >= _NUM ) { throw new InvalidShapeException ( STRING ) ; } }
public void remove ( Rule rule ) { rules . remove ( rule ) ; }
public static String constructQueueNamesRedisKey ( String shardName ) { return String . format ( STRING , PINLATER_QUEUE_NAMES_KEY_PREFIX , shardName ) ; }
public static String constructQueueNamesRedisKey ( String shardName ) { return String . format ( STRING , PINLATER_QUEUE_NAMES_KEY_PREFIX , shardName ) ; }
private byte [ ] createPreviewBuffer ( Size previewSize ) { int bitsPerPixel = ImageFormat . getBitsPerPixel ( ImageFormat . NV21 ) ; long sizeInBits = previewSize . getHeight ( ) * previewSize . getWidth ( ) * bitsPerPixel ; int bufferSize = ( int ) Math . ceil ( sizeInBits / _NUM ) + _NUM ; byte [ ] byteArray = new byte [ bufferSize ] ; ByteBuffer buffer = ByteBuffer . wrap ( byteArray ) ; if ( ! buffer . hasArray ( ) || ( buffer . array ( ) != byteArray ) ) { throw new IllegalStateException ( STRING ) ; } mBytesToByteBuffer . put ( byteArray , buffer ) ; return byteArray ; }
public void stop ( ) { synchronized ( privateInstanceLock ) { if ( connectionAcceptThread == null ) { return ; } } isStopped . set ( _BOOL ) ; try { connectionAcceptThread . interrupt ( ) ; connectionAcceptThread . join ( ) ; } catch ( InterruptedException e ) { } try { serverSocket . close ( ) ; } catch ( IOException e ) { } }
public void startNewAcceptor ( ) { Thread t = AccessController . doPrivileged ( new NewThreadAction ( ConnectionAcceptor . this , STRING + ++ threadNum , _BOOL ) ) ; t . start ( ) ; }
public void finishPainting ( boolean useCache ) { DataBufferInt dataBuffer = new DataBufferInt ( w0 * h0 ) ; int transparency = nativeFinishPainting ( SunWritableRaster . stealData ( dataBuffer , _NUM ) , w0 , h0 ) ; SunWritableRaster . markDirty ( dataBuffer ) ; int [ ] bands = BAND_OFFSETS [ transparency - _NUM ] ; WritableRaster raster = Raster . createPackedRaster ( dataBuffer , w0 , h0 , w0 , bands , null ) ; ColorModel cm = COLOR_MODELS [ transparency - _NUM ] ; Image img = new BufferedImage ( cm , raster , _BOOL , null ) ; if ( useCache ) { cache . setImage ( getClass ( ) , null , w0 , h0 , cacheArgs , img ) ; } graphics . drawImage ( img , x0 , y0 , null ) ; }
public void finishPainting ( boolean useCache ) { DataBufferInt dataBuffer = new DataBufferInt ( w0 * h0 ) ; int transparency = nativeFinishPainting ( SunWritableRaster . stealData ( dataBuffer , _NUM ) , w0 , h0 ) ; SunWritableRaster . markDirty ( dataBuffer ) ; int [ ] bands = BAND_OFFSETS [ transparency - _NUM ] ; WritableRaster raster = Raster . createPackedRaster ( dataBuffer , w0 , h0 , w0 , bands , null ) ; ColorModel cm = COLOR_MODELS [ transparency - _NUM ] ; Image img = new BufferedImage ( cm , raster , _BOOL , null ) ; if ( useCache ) { cache . setImage ( getClass ( ) , null , w0 , h0 , cacheArgs , img ) ; } graphics . drawImage ( img , x0 , y0 , null ) ; }
public void deleteEnvironment ( Environment environment ) throws IOException { String id = environment . getId ( ) ; Environment local = existingEnvironments . remove ( id ) ; if ( null != local ) { Files . deleteIfExists ( pathResolver . getEnvironmentFilePath ( local ) ) ; AgentMappings agentMappings = agentMappingsReference . get ( ) ; if ( checkEnvironments ( agentMappings ) ) { try { saveAgentMappings ( agentMappings , _BOOL ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; } } } }
private final boolean handleBlockedWrite ( ByteBuffer buffer , DistributionMessage msg ) throws ConnectionException { if ( ! addToQueue ( buffer , msg , _BOOL ) ) { return _BOOL ; } else { startNioPusher ( ) ; return _BOOL ; } }
private void onPause ( ) { mSubscription . unsubscribe ( ) ; mDispatchedObservablesHistory . clear ( ) ; }
@ Override public void warn ( String msg ) { if ( logger . isLoggable ( Level . WARNING ) ) { log ( SELF , Level . WARNING , msg , null ) ; } }
public static String toString ( URI uri , Charset encoding ) throws IOException { return toString ( uri . toURL ( ) , Charsets . toCharset ( encoding ) ) ; }
public static String toString ( URI uri , Charset encoding ) throws IOException { return toString ( uri . toURL ( ) , Charsets . toCharset ( encoding ) ) ; }
public Set < Emoticon > findMatchingEmoticons ( String emoteCode ) { Set < Emoticon > found = new HashSet < > ( ) ; found . addAll ( findMatchingEmoticons ( emoteCode , emoticonsByEmoteset . values ( ) ) ) ; found . addAll ( findMatchingEmoticons ( emoteCode , streamEmoticons . values ( ) ) ) ; return found ; }
public Set < Emoticon > findMatchingEmoticons ( String emoteCode ) { Set < Emoticon > found = new HashSet < > ( ) ; found . addAll ( findMatchingEmoticons ( emoteCode , emoticonsByEmoteset . values ( ) ) ) ; found . addAll ( findMatchingEmoticons ( emoteCode , streamEmoticons . values ( ) ) ) ; return found ; }
public StringAttributeRule ( String name , String description , Enum [ ] valid , boolean optional ) { this ( name , description , null , optional , _NUM , Integer . MAX_VALUE ) ; validValues = new ArrayList < String > ( ) ; for ( Enum aValid : valid ) { validValues . add ( aValid . name ( ) ) ; } this . example = null ; }
public DownloadTask ( String url , Path toFile ) { this ( url , toFile , null , null ) ; }
public DownloadTask ( String url , Path toFile ) { this ( url , toFile , null , null ) ; }
public void afterIfPresent ( T id ) { after . add ( id ) ; }
public void afterIfPresent ( T id ) { after . add ( id ) ; }
Field findField ( String name , int lineno , int override ) throws ConfigurationException { int dot = name . lastIndexOf ( STRING ) ; if ( dot < _NUM ) { oops ( STRING + name , lineno , override ) ; } String className = name . substring ( _NUM , dot ) ; Class c = findClass ( className , lineno , override , _BOOL ) ; if ( c == null ) { oops ( STRING + name , lineno , override ) ; } String fieldName = name . substring ( dot + _NUM ) ; checkPackageAccess ( c ) ; try { Field field = c . getField ( fieldName ) ; if ( ! Modifier . isStatic ( field . getModifiers ( ) ) ) { oops ( fieldName + STRING + className , lineno , override ) ; } return field ; } catch ( NoSuchFieldException e ) { oops ( fieldName + STRING + className , lineno , override ) ; return null ; } }
public static boolean isAgree ( FeatureStructure aMergeFs , Map < String , List < FeatureStructure > > aAnnosPerUser ) { for ( String usr : aAnnosPerUser . keySet ( ) ) { boolean agree = _BOOL ; for ( FeatureStructure usrFs : aAnnosPerUser . get ( usr ) ) { if ( isSameAnno ( aMergeFs , usrFs ) ) { if ( ! agree ) { agree = _BOOL ; } else if ( agree ) { return _BOOL ; } } } if ( ! agree ) { return _BOOL ; } } return _BOOL ; }
protected boolean isOutputLineExpected ( final String line , final String [ ] expectedPrefixes , final boolean filePathsAreExpected ) { final String trimmed = line != null ? line . trim ( ) : null ; if ( StringUtils . isNotEmpty ( trimmed ) ) { if ( filePathsAreExpected && isFilePath ( line ) ) { return _BOOL ; } if ( expectedPrefixes != null ) { for ( final String prefix : expectedPrefixes ) { if ( StringUtils . startsWithIgnoreCase ( line , prefix ) ) { return _BOOL ; } } } return _BOOL ; } return _BOOL ; }
protected boolean isOutputLineExpected ( final String line , final String [ ] expectedPrefixes , final boolean filePathsAreExpected ) { final String trimmed = line != null ? line . trim ( ) : null ; if ( StringUtils . isNotEmpty ( trimmed ) ) { if ( filePathsAreExpected && isFilePath ( line ) ) { return _BOOL ; } if ( expectedPrefixes != null ) { for ( final String prefix : expectedPrefixes ) { if ( StringUtils . startsWithIgnoreCase ( line , prefix ) ) { return _BOOL ; } } } return _BOOL ; } return _BOOL ; }
protected boolean isOutputLineExpected ( final String line , final String [ ] expectedPrefixes , final boolean filePathsAreExpected ) { final String trimmed = line != null ? line . trim ( ) : null ; if ( StringUtils . isNotEmpty ( trimmed ) ) { if ( filePathsAreExpected && isFilePath ( line ) ) { return _BOOL ; } if ( expectedPrefixes != null ) { for ( final String prefix : expectedPrefixes ) { if ( StringUtils . startsWithIgnoreCase ( line , prefix ) ) { return _BOOL ; } } } return _BOOL ; } return _BOOL ; }
@ Override protected boolean handleMovement ( final RPEntity entity ) { if ( rand . nextDouble ( ) < probability ) { doDamage ( entity ) ; } return _BOOL ; }
@ Override protected boolean handleMovement ( final RPEntity entity ) { if ( rand . nextDouble ( ) < probability ) { doDamage ( entity ) ; } return _BOOL ; }
private Crumb createFilteredNavigationCrumb ( final PageParameters base , final String key , final String value , final String displayValue , final String locale , final PageParameters pageParameters , final String brandPrefix , final String pricePrefix , final String queryPrefix , final String tagPrefix , final Map < String , I18NModel > attributeCodeName ) { final PageParameters withoutCurrent = wicketUtil . getFilteredRequestParameters ( pageParameters , key , value ) ; String linkName = getLinkNamePrefix ( key , locale , brandPrefix , pricePrefix , queryPrefix , tagPrefix , attributeCodeName ) ; if ( StringUtils . isNotBlank ( linkName ) ) { linkName += STRING + getLinkName ( key , value , displayValue ) ; } else { linkName = getLinkName ( key , value , displayValue ) ; } base . add ( key , value ) ; return new Crumb ( key , linkName , null , new PageParameters ( base ) , withoutCurrent ) ; }
private Crumb createFilteredNavigationCrumb ( final PageParameters base , final String key , final String value , final String displayValue , final String locale , final PageParameters pageParameters , final String brandPrefix , final String pricePrefix , final String queryPrefix , final String tagPrefix , final Map < String , I18NModel > attributeCodeName ) { final PageParameters withoutCurrent = wicketUtil . getFilteredRequestParameters ( pageParameters , key , value ) ; String linkName = getLinkNamePrefix ( key , locale , brandPrefix , pricePrefix , queryPrefix , tagPrefix , attributeCodeName ) ; if ( StringUtils . isNotBlank ( linkName ) ) { linkName += STRING + getLinkName ( key , value , displayValue ) ; } else { linkName = getLinkName ( key , value , displayValue ) ; } base . add ( key , value ) ; return new Crumb ( key , linkName , null , new PageParameters ( base ) , withoutCurrent ) ; }
private Crumb createFilteredNavigationCrumb ( final PageParameters base , final String key , final String value , final String displayValue , final String locale , final PageParameters pageParameters , final String brandPrefix , final String pricePrefix , final String queryPrefix , final String tagPrefix , final Map < String , I18NModel > attributeCodeName ) { final PageParameters withoutCurrent = wicketUtil . getFilteredRequestParameters ( pageParameters , key , value ) ; String linkName = getLinkNamePrefix ( key , locale , brandPrefix , pricePrefix , queryPrefix , tagPrefix , attributeCodeName ) ; if ( StringUtils . isNotBlank ( linkName ) ) { linkName += STRING + getLinkName ( key , value , displayValue ) ; } else { linkName = getLinkName ( key , value , displayValue ) ; } base . add ( key , value ) ; return new Crumb ( key , linkName , null , new PageParameters ( base ) , withoutCurrent ) ; }
public void dump ( Writer out ) throws IOException { out . write ( rootElement . getCanonicalForm ( ) ) ; }
public void dump ( Writer out ) throws IOException { out . write ( rootElement . getCanonicalForm ( ) ) ; }
public void wrap ( final int streamId , final FrameType type , final ByteBuffer data ) { POOL . release ( this . directBuffer ) ; this . directBuffer = POOL . acquireMutableDirectBuffer ( FrameHeaderFlyweight . computeFrameHeaderLength ( type , _NUM , data . remaining ( ) ) ) ; this . length = FrameHeaderFlyweight . encode ( this . directBuffer , offset , streamId , _NUM , type , NULL_BYTEBUFFER , data ) ; }
public boolean isDefault ( String scope , String key ) { synchronized ( mLock ) { String defaultValue = getStringDefault ( key ) ; String value = getString ( scope , key ) ; return value == null ? _BOOL : value . equals ( defaultValue ) ; } }
public PTProperty addProperty ( final PTProperty property ) { if ( properties . contains ( property ) ) { throw new IllegalArgumentException ( STRING + property . getName ( ) + STRING ) ; } properties . add ( property ) ; property . setParentTable ( this ) ; return property ; }
@ Override public TaskBulkRep queryBulkResourceReps ( List < URI > ids ) { Iterator < Task > _dbIterator = _dbClient . queryIterativeObjects ( getResourceClass ( ) , ids ) ; return new TaskBulkRep ( BulkList . wrapping ( _dbIterator , MapTask . getInstance ( ) ) ) ; }
@ Override public TaskBulkRep queryBulkResourceReps ( List < URI > ids ) { Iterator < Task > _dbIterator = _dbClient . queryIterativeObjects ( getResourceClass ( ) , ids ) ; return new TaskBulkRep ( BulkList . wrapping ( _dbIterator , MapTask . getInstance ( ) ) ) ; }
public double clipGradients ( ) { double gscale = _NUM ; if ( clippingEnabled ) { double gg = model . gradientL2norm ( ) ; if ( Double . isNaN ( gg ) || Double . isInfinite ( gg ) ) { throw new RuntimeException ( STRING + gg ) ; } if ( gg > clipThreshold ) { ++ clips ; gscale = clipThreshold / gg ; } } return gscale ; }
public double clipGradients ( ) { double gscale = _NUM ; if ( clippingEnabled ) { double gg = model . gradientL2norm ( ) ; if ( Double . isNaN ( gg ) || Double . isInfinite ( gg ) ) { throw new RuntimeException ( STRING + gg ) ; } if ( gg > clipThreshold ) { ++ clips ; gscale = clipThreshold / gg ; } } return gscale ; }
public void writeUI16 ( int value ) throws IOException { flushBits ( ) ; out . write ( value & _NUM ) ; out . write ( value > > _NUM ) ; bytesWritten += _NUM ; }
public FeatureDefinition subset ( String [ ] featureNamesToDrop ) { List < Integer > featureIndicesToDrop = new ArrayList < Integer > ( ) ; for ( String featureName : featureNamesToDrop ) { int featureIndex ; try { featureIndex = getFeatureIndex ( featureName ) ; featureIndicesToDrop . add ( featureIndex ) ; } catch ( IllegalArgumentException e ) { System . err . println ( STRING + featureName + STRING ) ; } } FeatureDefinition subDefinition = null ; try { ByteArrayOutputStream toMemory = new ByteArrayOutputStream ( ) ; DataOutput output = new DataOutputStream ( toMemory ) ; writeBinaryTo ( output , featureIndicesToDrop ) ; byte [ ] memory = toMemory . toByteArray ( ) ; ByteArrayInputStream fromMemory = new ByteArrayInputStream ( memory ) ; DataInput input = new DataInputStream ( fromMemory ) ; subDefinition = new FeatureDefinition ( input ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } assert this . contains ( subDefinition ) ; return subDefinition ; }
public License ( final String filename , final String text ) { if ( filename == null ) { throw new NullPointerException ( STRING ) ; } if ( filename . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING ) ; } this . filename = filename ; if ( text == null ) { throw new NullPointerException ( STRING ) ; } if ( text . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING ) ; } this . text = text ; }
public License ( final String filename , final String text ) { if ( filename == null ) { throw new NullPointerException ( STRING ) ; } if ( filename . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING ) ; } this . filename = filename ; if ( text == null ) { throw new NullPointerException ( STRING ) ; } if ( text . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING ) ; } this . text = text ; }
public String leftStr ( String str , int length ) { return str . substring ( _NUM , Math . min ( str . length ( ) , length ) ) ; }
public boolean isContainerClass ( String clz ) { return droidSafeContainerClasses . contains ( clz ) ; }
public boolean isContainerClass ( String clz ) { return droidSafeContainerClasses . contains ( clz ) ; }
public boolean isContainerClass ( String clz ) { return droidSafeContainerClasses . contains ( clz ) ; }
public boolean removeShutdownHook ( Thread hook ) { if ( hook == null ) { throw new NullPointerException ( STRING ) ; } if ( shuttingDown ) { throw new IllegalStateException ( STRING ) ; } synchronized ( shutdownHooks ) { return shutdownHooks . remove ( hook ) ; } }
public CorsServiceBuilder allowRequestMethods ( final HttpMethod ... methods ) { requireNonNull ( methods , STRING ) ; for ( int i = _NUM ; i < methods . length ; i ++ ) { if ( methods [ i ] == null ) { throw new NullPointerException ( STRING + i + STRING ) ; } } Collections . addAll ( allowedRequestMethods , methods ) ; return this ; }
public CorsServiceBuilder allowRequestMethods ( final HttpMethod ... methods ) { requireNonNull ( methods , STRING ) ; for ( int i = _NUM ; i < methods . length ; i ++ ) { if ( methods [ i ] == null ) { throw new NullPointerException ( STRING + i + STRING ) ; } } Collections . addAll ( allowedRequestMethods , methods ) ; return this ; }
public static Double evaluateToDouble ( String expression , Map < String , Object > vars ) { Object result = evaluate ( expression , vars ) ; if ( result == null ) { throw new IllegalStateException ( STRING ) ; } if ( ! isNumeric ( String . valueOf ( result ) ) ) { throw new IllegalStateException ( STRING + result + STRING + result . getClass ( ) ) ; } return Double . valueOf ( String . valueOf ( result ) ) ; }
public void removeListeners ( ) { if ( globalListener != null ) { try { InvokerHelper . invokeMethod ( currentObject , STRING , globalListener ) ; } catch ( Exception e ) { } globalListener = null ; } if ( localListener != null ) { try { InvokerHelper . invokeMethod ( currentObject , STRING , new Object [ ] { propertyName , localListener } ) ; } catch ( Exception e ) { } localListener = null ; } if ( syntheticFullBinding != null ) { syntheticFullBinding . unbind ( ) ; } }
private HttpRequestBase buildRequest ( Method method , URI uri ) { switch ( method ) { case GET : return new HttpGet ( uri ) ; default : throw new UnsupportedOperationException ( STRING + method ) ; } }
public static boolean vPoolSpecifiesSnapshots ( final VirtualPool virtualPool ) { if ( virtualPool . getMaxNativeSnapshots ( ) == null ) { return _BOOL ; } return virtualPool . getMaxNativeSnapshots ( ) != MAX_DISABLED ; }
public static boolean vPoolSpecifiesSnapshots ( final VirtualPool virtualPool ) { if ( virtualPool . getMaxNativeSnapshots ( ) == null ) { return _BOOL ; } return virtualPool . getMaxNativeSnapshots ( ) != MAX_DISABLED ; }
@ Nullable public ECKey findOldestKeyAfter ( long timeSecs ) { lock . lock ( ) ; try { ECKey oldest = null ; for ( ECKey key : hashToKeys . values ( ) ) { final long keyTime = key . getCreationTimeSeconds ( ) ; if ( keyTime > timeSecs ) { if ( oldest == null || oldest . getCreationTimeSeconds ( ) > keyTime ) oldest = key ; } } return oldest ; } finally { lock . unlock ( ) ; } }
public MutableString ( final char [ ] a ) { makeCompactMutableString ( a . length ) ; System . arraycopy ( a , _NUM , array , _NUM , array . length ) ; }
public MutableString ( final char [ ] a ) { makeCompactMutableString ( a . length ) ; System . arraycopy ( a , _NUM , array , _NUM , array . length ) ; }
public ColorDifference ( ) { Timer timer = new Timer ( _NUM , this ) ; timer . start ( ) ; setPreferredSize ( new Dimension ( _NUM , _NUM ) ) ; }
@ RpcMethod public void detachDisks ( String vmId , List < String > diskIds , AsyncMethodCallback < Host . AsyncClient . detach_disks_call > handler ) throws RpcException { ensureClient ( ) ; VmDisksDetachRequest vmDisksDetachRequest = new VmDisksDetachRequest ( vmId , diskIds ) ; clientProxy . setTimeout ( DETACH_DISKS_TIMEOUT_MS ) ; logger . info ( STRING , vmId , diskIds , getHostIp ( ) , vmDisksDetachRequest ) ; try { clientProxy . detach_disks ( vmDisksDetachRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
@ RpcMethod public void detachDisks ( String vmId , List < String > diskIds , AsyncMethodCallback < Host . AsyncClient . detach_disks_call > handler ) throws RpcException { ensureClient ( ) ; VmDisksDetachRequest vmDisksDetachRequest = new VmDisksDetachRequest ( vmId , diskIds ) ; clientProxy . setTimeout ( DETACH_DISKS_TIMEOUT_MS ) ; logger . info ( STRING , vmId , diskIds , getHostIp ( ) , vmDisksDetachRequest ) ; try { clientProxy . detach_disks ( vmDisksDetachRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
public void add ( final Sensor sensor ) { Set < Sensor > oldSelection = new HashSet < Sensor > ( selection ) ; boolean rv = selection . add ( sensor ) ; if ( rv ) { fireSelectionChanged ( oldSelection , selection ) ; } }
public void cancelTaskNoException ( Task task ) { try { cancelTask ( task ) ; } catch ( Exception e ) { _log . error ( STRING ) ; } }
public void close ( ) { try { stream . close ( ) ; } catch ( IOException e ) { throw new FormUploadException ( STRING , e ) ; } }
public Activity currentActivity ( ) { Activity activity = activityStack . lastElement ( ) ; return activity ; }
public static synchronized Collection < String > allLocalIps ( ) { List < String > ips = new ArrayList < > ( _NUM ) ; try { Enumeration < NetworkInterface > itfs = NetworkInterface . getNetworkInterfaces ( ) ; if ( itfs != null ) { for ( NetworkInterface itf : asIterable ( itfs ) ) { if ( ! itf . isLoopback ( ) ) { Enumeration < InetAddress > addrs = itf . getInetAddresses ( ) ; for ( InetAddress addr : asIterable ( addrs ) ) { String hostAddr = addr . getHostAddress ( ) ; if ( ! addr . isLoopbackAddress ( ) && ! ips . contains ( hostAddr ) ) ips . add ( hostAddr ) ; } } } } } catch ( SocketException ignore ) { return Collections . emptyList ( ) ; } Collections . sort ( ips ) ; return ips ; }
public static List < String > asStringList ( Collection < ? extends Object > objects ) { List < String > list = new ArrayList < > ( ) ; for ( Object object : objects ) { list . add ( String . valueOf ( object ) ) ; } return list ; }
public static List < String > asStringList ( Collection < ? extends Object > objects ) { List < String > list = new ArrayList < > ( ) ; for ( Object object : objects ) { list . add ( String . valueOf ( object ) ) ; } return list ; }
public static List < String > asStringList ( Collection < ? extends Object > objects ) { List < String > list = new ArrayList < > ( ) ; for ( Object object : objects ) { list . add ( String . valueOf ( object ) ) ; } return list ; }
public static List < String > asStringList ( Collection < ? extends Object > objects ) { List < String > list = new ArrayList < > ( ) ; for ( Object object : objects ) { list . add ( String . valueOf ( object ) ) ; } return list ; }
@ Override protected void onDraw ( Canvas canvas ) { super . onDraw ( canvas ) ; if ( mBitmapCoverImage != null ) canvas . drawBitmap ( mBitmapCoverImage , _NUM , _NUM , mPaintCoverImage ) ; canvas . drawRect ( _NUM , _NUM , mWidth , mHeight , mPaintCoverMask ) ; mDrawableBottomShadow . draw ( canvas ) ; canvas . drawRect ( rectFEmptyProgress , mPaintEmptyProgress ) ; canvas . drawRect ( _NUM , mHeight - mProgressHeight , mCurrentProgressPosition , mHeight , mPaintLoadedProgress ) ; canvas . drawRect ( _NUM , _NUM , mCurrentProgressPosition , mHeight , mPaintProgressMask ) ; mTextPassedDuration = secondsToTime ( mCurrentSeconds ) ; mPaintTextDuration . getTextBounds ( mTextPassedDuration , _NUM , mTextPassedDuration . length ( ) , rectFTextDuration ) ; canvas . drawText ( mTextPassedDuration , mWidth / _NUM , mHeight - mWidth / _NUM - rectFTextDuration . height ( ) , mPaintTextDuration ) ; mTextLeftDuration = secondsToTime ( mMaxSeconds - mCurrentSeconds ) ; mPaintTextDuration . getTextBounds ( mTextLeftDuration , _NUM , mTextLeftDuration . length ( ) , rectFTextDuration ) ; canvas . drawText ( mTextLeftDuration , ( _NUM * mWidth / _NUM ) - rectFTextDuration . width ( ) , mHeight - mWidth / _NUM - rectFTextDuration . height ( ) , mPaintTextDuration ) ; }
public void _testHasAttributeNS1 ( ) throws Throwable { Document doc ; Element element ; boolean state ; NodeList elementList ; doc = ( Document ) load ( STRING , builder ) ; elementList = doc . getElementsByTagNameNS ( STRING , STRING ) ; element = ( Element ) elementList . item ( _NUM ) ; state = element . hasAttributeNS ( STRING , STRING ) ; assertTrue ( STRING , state ) ; }
private boolean isPending ( BlockMirror mirror ) { return ! isInactive ( mirror ) && isNullOrEmpty ( mirror . getSynchronizedInstance ( ) ) ; }
public static String read ( final String filename ) { try { return asString ( new FileInputStream ( new File ( filename ) ) , Charset . defaultCharset ( ) ) ; } catch ( IOException e ) { logger . warn ( STRING , filename , e ) ; return null ; } }
public final void clear ( ) throws IOException { clearInternal ( ) ; recordCount . set ( _NUM ) ; }
public final void clear ( ) throws IOException { clearInternal ( ) ; recordCount . set ( _NUM ) ; }
public boolean hasNext ( ) { return iterator . hasNext ( ) ; }
public boolean hasNext ( ) { return iterator . hasNext ( ) ; }
public boolean hasNext ( ) { return iterator . hasNext ( ) ; }
public boolean hasNext ( ) { return iterator . hasNext ( ) ; }
public void deploy ( String routeId , String routeName , JsonValue routeConfig ) throws RouterHandlerException { Reject . ifNull ( routeName ) ; write . lock ( ) ; try { load ( routeId , routeName , routeConfig . copy ( ) ) ; directoryMonitor . store ( routeId , routeConfig ) ; logger . info ( STRING , routeId , routeName ) ; } catch ( IOException e ) { throw new RouterHandlerException ( format ( STRING , routeId ) , e ) ; } finally { write . unlock ( ) ; } }
public void deploy ( String routeId , String routeName , JsonValue routeConfig ) throws RouterHandlerException { Reject . ifNull ( routeName ) ; write . lock ( ) ; try { load ( routeId , routeName , routeConfig . copy ( ) ) ; directoryMonitor . store ( routeId , routeConfig ) ; logger . info ( STRING , routeId , routeName ) ; } catch ( IOException e ) { throw new RouterHandlerException ( format ( STRING , routeId ) , e ) ; } finally { write . unlock ( ) ; } }
private boolean isRemoteDownloadAllowed ( ) { return tryRepoCnt <= MAX_REPO_RETRIES || System . currentTimeMillis ( ) >= expireTime ; }
private boolean isRemoteDownloadAllowed ( ) { return tryRepoCnt <= MAX_REPO_RETRIES || System . currentTimeMillis ( ) >= expireTime ; }
private boolean isRemoteDownloadAllowed ( ) { return tryRepoCnt <= MAX_REPO_RETRIES || System . currentTimeMillis ( ) >= expireTime ; }
private boolean isRemoteDownloadAllowed ( ) { return tryRepoCnt <= MAX_REPO_RETRIES || System . currentTimeMillis ( ) >= expireTime ; }
private boolean isRemoteDownloadAllowed ( ) { return tryRepoCnt <= MAX_REPO_RETRIES || System . currentTimeMillis ( ) >= expireTime ; }
public void testClose1 ( ) { try { target . close ( ) ; target . next ( ) ; fail ( STRING ) ; } catch ( SQLException e ) { } }
public void testClose1 ( ) { try { target . close ( ) ; target . next ( ) ; fail ( STRING ) ; } catch ( SQLException e ) { } }
public void testClose1 ( ) { try { target . close ( ) ; target . next ( ) ; fail ( STRING ) ; } catch ( SQLException e ) { } }
public void testClose1 ( ) { try { target . close ( ) ; target . next ( ) ; fail ( STRING ) ; } catch ( SQLException e ) { } }
public void testClose1 ( ) { try { target . close ( ) ; target . next ( ) ; fail ( STRING ) ; } catch ( SQLException e ) { } }
public void send ( String name , String value , long timestamp ) throws IOException { metrics . add ( new MetricTuple ( sanitize ( name ) , timestamp , sanitize ( value ) ) ) ; if ( metrics . size ( ) >= batchSize ) { writeMetrics ( ) ; } }
public void send ( String name , String value , long timestamp ) throws IOException { metrics . add ( new MetricTuple ( sanitize ( name ) , timestamp , sanitize ( value ) ) ) ; if ( metrics . size ( ) >= batchSize ) { writeMetrics ( ) ; } }
public DotNode ( int i , int j , Trie trieNode , ArrayList < SuperNode > antSuperNodes , SourcePath srcPath ) { this . i = i ; this . j = j ; this . trieNode = trieNode ; this . antSuperNodes = antSuperNodes ; this . srcPath = srcPath ; }
public MGRSPoint ( ) { DEBUG = logger . isLoggable ( Level . FINE ) ; }
public MGRSPoint ( ) { DEBUG = logger . isLoggable ( Level . FINE ) ; }
public MGRSPoint ( ) { DEBUG = logger . isLoggable ( Level . FINE ) ; }
public static int [ ] createMSBMask ( int bits ) { int m = _NUM , orig = _NUM - bits ; while ( bits -- > _NUM ) { m |= _NUM ; m <<= _NUM ; } while ( -- orig > _NUM ) { m <<= _NUM ; } return new int [ ] { ( m > > _NUM ) & _NUM , ( m > > _NUM ) & _NUM , ( m > > _NUM ) & _NUM , m & _NUM } ; }
public static String byteArrayToHexString ( byte in [ ] , int offset ) { if ( in == null || in . length <= _NUM || offset >= in . length ) return null ; StringBuffer out = new StringBuffer ( in . length * _NUM ) ; for ( int i = offset ; i < in . length ; i ++ ) { out . append ( byteToHexString ( in [ i ] ) ) ; out . append ( STRING ) ; } return out . toString ( ) ; }
@ Override public int compareTo ( DbEntry another ) { if ( itemType == LauncherSettings . Favorites . ITEM_TYPE_APPWIDGET ) { if ( another . itemType == LauncherSettings . Favorites . ITEM_TYPE_APPWIDGET ) { return another . spanY * another . spanX - spanX * spanY ; } else { return - _NUM ; } } else if ( another . itemType == LauncherSettings . Favorites . ITEM_TYPE_APPWIDGET ) { return _NUM ; } else { return Float . compare ( another . weight , weight ) ; } }
public void fillFieldValues ( ) { if ( ! isCreationDialog ) { tfSynapseGroupLabel . setText ( synapseGroup . getLabel ( ) ) ; } else { tfSynapseGroupLabel . setText ( STRING ) ; } }
@ Deprecated public static SourceDataTagQuality fromXML ( Element domElement ) { NodeList fields = domElement . getChildNodes ( ) ; int fieldsCount = fields . getLength ( ) ; String fieldName ; String fieldValueString ; Node fieldNode ; SourceDataTagQuality result = new SourceDataTagQuality ( ) ; for ( int i = _NUM ; i != fieldsCount ; i ++ ) { fieldNode = fields . item ( i ) ; if ( fieldNode . getNodeType ( ) == Node . ELEMENT_NODE ) { fieldName = fieldNode . getNodeName ( ) ; Node fieldValueNode = fieldNode . getFirstChild ( ) ; if ( fieldValueNode != null ) { fieldValueString = fieldValueNode . getNodeValue ( ) ; } else { fieldValueString = STRING ; } if ( fieldName . equals ( XML_ELEMENT_QUALITY_CODE ) ) { short code = Short . parseShort ( fieldValueString ) ; result . qualityCode = SourceDataTagQualityCode . getEnum ( code ) ; } else if ( fieldName . equals ( XML_ELEMENT_QUALITY_DESC ) ) { result . description = fieldValueString ; } } } return result ; }
private void reflectMemberVariablesInFinalButton ( ) { final boolean lastPageReached = ( viewPager . getCurrentItem ( ) + _NUM ) == pages . size ( ) ; final boolean buttonShouldBeInvisible = ! lastPageReached || finalButtonDisabled ; final boolean buttonIsCurrentlyInvisible = finalButton . getVisibility ( ) == View . INVISIBLE ; final boolean shouldUpdateButton = buttonShouldBeInvisible != buttonIsCurrentlyInvisible ; if ( shouldUpdateButton ) { final Animator buttonAnimator = buttonShouldBeInvisible ? buttonAnimatorFactory . newFinalButtonDisappearAnimator ( finalButton ) : buttonAnimatorFactory . newFinalButtonAppearAnimator ( finalButton ) ; if ( buttonShouldBeInvisible ) { disableButton ( buttonAnimator , finalButton ) ; } else { enableButton ( buttonAnimator , finalButton ) ; } } }
public void addFile ( String path ) throws IOException { File newFile = new File ( path ) ; if ( ! newFile . exists ( ) ) { throw new IOException ( STRING + newFile . getAbsolutePath ( ) ) ; } if ( DelphiUtils . acceptFile ( newFile . getAbsolutePath ( ) ) ) { files . add ( newFile ) ; } }
protected double regressionPrediction ( Instance transformedInstance , boolean [ ] selectedAttributes , double [ ] coefficients ) throws Exception { double result = _NUM ; int column = _NUM ; for ( int j = _NUM ; j < transformedInstance . numAttributes ( ) ; j ++ ) { if ( ( m_ClassIndex != j ) && ( selectedAttributes [ j ] ) ) { result += coefficients [ column ] * transformedInstance . value ( j ) ; column ++ ; } } result += coefficients [ column ] ; return result ; }
void processAddOnChanges ( Window caller , AddOnDependencyChecker . AddOnChangesResult changes ) { if ( addonsDialog != null ) { addonsDialog . setDownloadingUpdates ( ) ; } if ( getView ( ) != null ) { Set < AddOn > addOns = new HashSet < > ( changes . getUninstalls ( ) ) ; addOns . addAll ( changes . getOldVersions ( ) ) ; Set < Extension > extensions = new HashSet < > ( ) ; extensions . addAll ( changes . getUnloadExtensions ( ) ) ; extensions . addAll ( changes . getSoftUnloadExtensions ( ) ) ; if ( ! warnUnsavedResourcesOrActiveActions ( caller , addOns , extensions , _BOOL ) ) { return ; } } uninstallAddOns ( caller , changes . getUninstalls ( ) , _BOOL ) ; Set < AddOn > allAddons = new HashSet < > ( changes . getNewVersions ( ) ) ; allAddons . addAll ( changes . getInstalls ( ) ) ; for ( AddOn addOn : allAddons ) { if ( addonsDialog != null ) { addonsDialog . notifyAddOnDownloading ( addOn ) ; } downloadAddOn ( addOn ) ; } }
public void deregister ( UUID transactionId ) throws RepositoryException { synchronized ( primaryCache ) { CacheEntry entry = primaryCache . getIfPresent ( transactionId ) ; if ( entry == null ) { throw new RepositoryException ( STRING + transactionId . toString ( ) + STRING ) ; } else { primaryCache . invalidate ( transactionId ) ; secondaryCache . invalidate ( transactionId ) ; logger . debug ( STRING , transactionId ) ; } } }
public BufferedImage render ( I18nFormat format ) { int imageWidth = LEGEND_TOTAL_WIDTH ; int imageHeight = calculateImageHeight ( ) ; BufferedImage image = new BufferedImage ( imageWidth , imageHeight , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D graphics = ( Graphics2D ) image . getGraphics ( ) ; graphics . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; graphics . translate ( LEGEND_MARGIN_LEFT , _NUM ) ; for ( Legend legend : legends ) { legend . draw ( graphics , format ) ; graphics . translate ( _NUM , LEGEND_MARGIN_BOTTOM ) ; } return image ; }
public BufferedImage render ( I18nFormat format ) { int imageWidth = LEGEND_TOTAL_WIDTH ; int imageHeight = calculateImageHeight ( ) ; BufferedImage image = new BufferedImage ( imageWidth , imageHeight , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D graphics = ( Graphics2D ) image . getGraphics ( ) ; graphics . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; graphics . translate ( LEGEND_MARGIN_LEFT , _NUM ) ; for ( Legend legend : legends ) { legend . draw ( graphics , format ) ; graphics . translate ( _NUM , LEGEND_MARGIN_BOTTOM ) ; } return image ; }
public static boolean isFileExist ( String filePath ) { if ( Handler_String . isBlank ( filePath ) ) { return _BOOL ; } File file = new File ( filePath ) ; return ( file . exists ( ) && file . isFile ( ) ) ; }
public static boolean isFileExist ( String filePath ) { if ( Handler_String . isBlank ( filePath ) ) { return _BOOL ; } File file = new File ( filePath ) ; return ( file . exists ( ) && file . isFile ( ) ) ; }
public void addTurntable ( Point2D pt ) { numLayoutTurntables ++ ; String name = STRING ; boolean duplicate = _BOOL ; while ( duplicate ) { name = STRING + numLayoutTurntables ; if ( finder . findLayoutTurntableByName ( name ) == null ) { duplicate = _BOOL ; } if ( duplicate ) { numLayoutTurntables ++ ; } } LayoutTurntable x = new LayoutTurntable ( name , pt , this ) ; turntableList . add ( x ) ; setDirty ( _BOOL ) ; x . addRay ( _NUM ) ; x . addRay ( _NUM ) ; x . addRay ( _NUM ) ; x . addRay ( _NUM ) ; }
public void addTurntable ( Point2D pt ) { numLayoutTurntables ++ ; String name = STRING ; boolean duplicate = _BOOL ; while ( duplicate ) { name = STRING + numLayoutTurntables ; if ( finder . findLayoutTurntableByName ( name ) == null ) { duplicate = _BOOL ; } if ( duplicate ) { numLayoutTurntables ++ ; } } LayoutTurntable x = new LayoutTurntable ( name , pt , this ) ; turntableList . add ( x ) ; setDirty ( _BOOL ) ; x . addRay ( _NUM ) ; x . addRay ( _NUM ) ; x . addRay ( _NUM ) ; x . addRay ( _NUM ) ; }
void zApplyAllowEmptyDates ( ) { if ( ! hasParent ( ) ) { return ; } LocalDate selectedDate = zGetParentSelectedDate ( ) ; if ( ( ! allowEmptyDates ) && ( selectedDate == null ) ) { LocalDate today = LocalDate . now ( ) ; if ( InternalUtilities . isDateVetoed ( vetoPolicy , today ) ) { throw new RuntimeException ( STRING + STRING + STRING + STRING ) ; } zSetParentSelectedDate ( today ) ; } }
void zApplyAllowEmptyDates ( ) { if ( ! hasParent ( ) ) { return ; } LocalDate selectedDate = zGetParentSelectedDate ( ) ; if ( ( ! allowEmptyDates ) && ( selectedDate == null ) ) { LocalDate today = LocalDate . now ( ) ; if ( InternalUtilities . isDateVetoed ( vetoPolicy , today ) ) { throw new RuntimeException ( STRING + STRING + STRING + STRING ) ; } zSetParentSelectedDate ( today ) ; } }
void zApplyAllowEmptyDates ( ) { if ( ! hasParent ( ) ) { return ; } LocalDate selectedDate = zGetParentSelectedDate ( ) ; if ( ( ! allowEmptyDates ) && ( selectedDate == null ) ) { LocalDate today = LocalDate . now ( ) ; if ( InternalUtilities . isDateVetoed ( vetoPolicy , today ) ) { throw new RuntimeException ( STRING + STRING + STRING + STRING ) ; } zSetParentSelectedDate ( today ) ; } }
void zApplyAllowEmptyDates ( ) { if ( ! hasParent ( ) ) { return ; } LocalDate selectedDate = zGetParentSelectedDate ( ) ; if ( ( ! allowEmptyDates ) && ( selectedDate == null ) ) { LocalDate today = LocalDate . now ( ) ; if ( InternalUtilities . isDateVetoed ( vetoPolicy , today ) ) { throw new RuntimeException ( STRING + STRING + STRING + STRING ) ; } zSetParentSelectedDate ( today ) ; } }
public final static String createHexFingerprint ( String keytype , byte [ ] publickey ) { byte [ ] raw = rawFingerPrint ( STRING , keytype , publickey ) ; return rawToHexFingerprint ( raw ) ; }
@ SuppressLint ( STRING ) public static String replaceUnicodeDigits ( String number ) { StringBuilder normalizedDigits = new StringBuilder ( number . length ( ) ) ; for ( char c : number . toCharArray ( ) ) { int digit = Character . digit ( c , _NUM ) ; if ( digit != - _NUM ) { normalizedDigits . append ( digit ) ; } else { normalizedDigits . append ( c ) ; } } return normalizedDigits . toString ( ) ; }
public static StringBuilder leftShift ( StringBuilder self , Object value ) { self . append ( value ) ; return self ; }
public void addListener ( final ISPARQLUpdateListener l ) { if ( isReadOnly ( ) ) throw new UnsupportedOperationException ( ) ; if ( l == null ) throw new IllegalArgumentException ( ) ; listeners . add ( l ) ; }
private void readButtonActionPerformed ( ) { if ( numUr92 == _NUM ) { scanButtonActionPerformed ( ) ; return ; } swingNameValueField . setForeground ( COLOR_OK ) ; swingChannelValueField . setForeground ( COLOR_OK ) ; swingPasswordValueField . setForeground ( COLOR_OK ) ; swingIdValueField . setForeground ( COLOR_OK ) ; swingNameValueField . setText ( rb . getString ( STRING ) ) ; swingChannelValueField . setText ( rb . getString ( STRING ) ) ; swingPasswordValueField . setText ( rb . getString ( STRING ) ) ; swingIdValueField . setText ( rb . getString ( STRING ) ) ; updateStatusLineMessage ( STRING , COLOR_STATUS_OK ) ; duplexGroupImplementation . queryDuplexGroupIdentity ( ) ; updateStatusLineMessage ( STRING , COLOR_STATUS_OK ) ; }
private void readButtonActionPerformed ( ) { if ( numUr92 == _NUM ) { scanButtonActionPerformed ( ) ; return ; } swingNameValueField . setForeground ( COLOR_OK ) ; swingChannelValueField . setForeground ( COLOR_OK ) ; swingPasswordValueField . setForeground ( COLOR_OK ) ; swingIdValueField . setForeground ( COLOR_OK ) ; swingNameValueField . setText ( rb . getString ( STRING ) ) ; swingChannelValueField . setText ( rb . getString ( STRING ) ) ; swingPasswordValueField . setText ( rb . getString ( STRING ) ) ; swingIdValueField . setText ( rb . getString ( STRING ) ) ; updateStatusLineMessage ( STRING , COLOR_STATUS_OK ) ; duplexGroupImplementation . queryDuplexGroupIdentity ( ) ; updateStatusLineMessage ( STRING , COLOR_STATUS_OK ) ; }
public static String hypenToCamelNotation ( String str ) { if ( isEmpty ( str ) ) return str ; StringBuilder sb = new StringBuilder ( ) ; int len = str . length ( ) ; char c ; for ( int i = _NUM ; i < str . length ( ) ; i ++ ) { c = str . charAt ( i ) ; if ( c == STRING ) { if ( len > ++ i ) sb . append ( Character . toUpperCase ( str . charAt ( i ) ) ) ; } else sb . append ( c ) ; } return sb . toString ( ) ; }
public void doPrintSetup ( ) { doPrint ( ) ; }
public void doPrintSetup ( ) { doPrint ( ) ; }
public void doPrintSetup ( ) { doPrint ( ) ; }
public AuthRequest authenticate ( List discoveries , String returnToUrl ) throws ConsumerException , MessageException { return authenticate ( discoveries , returnToUrl , returnToUrl ) ; }
public AuthRequest authenticate ( List discoveries , String returnToUrl ) throws ConsumerException , MessageException { return authenticate ( discoveries , returnToUrl , returnToUrl ) ; }
public AuthRequest authenticate ( List discoveries , String returnToUrl ) throws ConsumerException , MessageException { return authenticate ( discoveries , returnToUrl , returnToUrl ) ; }
public AuthRequest authenticate ( List discoveries , String returnToUrl ) throws ConsumerException , MessageException { return authenticate ( discoveries , returnToUrl , returnToUrl ) ; }
public AuthRequest authenticate ( List discoveries , String returnToUrl ) throws ConsumerException , MessageException { return authenticate ( discoveries , returnToUrl , returnToUrl ) ; }
public Utf8Constant ( ConstantPool pool , int index , String value ) { super ( pool , index ) ; _value = value ; }
public synchronized boolean readRequestImmediate ( ) { if ( currentWriters == _NUM && writerLocks . size ( ) == _NUM ) { ++ currentReaders ; return _BOOL ; } return _BOOL ; }
public synchronized boolean readRequestImmediate ( ) { if ( currentWriters == _NUM && writerLocks . size ( ) == _NUM ) { ++ currentReaders ; return _BOOL ; } return _BOOL ; }
public synchronized boolean readRequestImmediate ( ) { if ( currentWriters == _NUM && writerLocks . size ( ) == _NUM ) { ++ currentReaders ; return _BOOL ; } return _BOOL ; }
public synchronized boolean readRequestImmediate ( ) { if ( currentWriters == _NUM && writerLocks . size ( ) == _NUM ) { ++ currentReaders ; return _BOOL ; } return _BOOL ; }
public synchronized boolean readRequestImmediate ( ) { if ( currentWriters == _NUM && writerLocks . size ( ) == _NUM ) { ++ currentReaders ; return _BOOL ; } return _BOOL ; }
public synchronized boolean readRequestImmediate ( ) { if ( currentWriters == _NUM && writerLocks . size ( ) == _NUM ) { ++ currentReaders ; return _BOOL ; } return _BOOL ; }
public synchronized boolean readRequestImmediate ( ) { if ( currentWriters == _NUM && writerLocks . size ( ) == _NUM ) { ++ currentReaders ; return _BOOL ; } return _BOOL ; }
public synchronized boolean readRequestImmediate ( ) { if ( currentWriters == _NUM && writerLocks . size ( ) == _NUM ) { ++ currentReaders ; return _BOOL ; } return _BOOL ; }
String headerToString ( ) { String pString = principalsToString ( ) ; if ( pString . length ( ) == _NUM ) { return codebaseToString ( ) ; } else { return codebaseToString ( ) + STRING + pString ; } }
private void loadBinary ( InputStream is ) throws IOException { if ( useNewIO && is instanceof FileInputStream ) { FileInputStream fis = ( FileInputStream ) is ; if ( useIndexing ) { loadBinaryIndex ( new URL ( indexName ) ) ; mapDatabase ( fis ) ; } else { loadMappedBinary ( fis ) ; } } else { DataInputStream dis = new DataInputStream ( new BufferedInputStream ( is ) ) ; loadBinary ( dis ) ; } }
private void loadBinary ( InputStream is ) throws IOException { if ( useNewIO && is instanceof FileInputStream ) { FileInputStream fis = ( FileInputStream ) is ; if ( useIndexing ) { loadBinaryIndex ( new URL ( indexName ) ) ; mapDatabase ( fis ) ; } else { loadMappedBinary ( fis ) ; } } else { DataInputStream dis = new DataInputStream ( new BufferedInputStream ( is ) ) ; loadBinary ( dis ) ; } }
private void loadBinary ( InputStream is ) throws IOException { if ( useNewIO && is instanceof FileInputStream ) { FileInputStream fis = ( FileInputStream ) is ; if ( useIndexing ) { loadBinaryIndex ( new URL ( indexName ) ) ; mapDatabase ( fis ) ; } else { loadMappedBinary ( fis ) ; } } else { DataInputStream dis = new DataInputStream ( new BufferedInputStream ( is ) ) ; loadBinary ( dis ) ; } }
public static License read ( final String license ) { final String trimmedLicense = license . trim ( ) ; if ( sLicenses . containsKey ( trimmedLicense ) ) { return sLicenses . get ( trimmedLicense ) ; } else { throw new IllegalStateException ( String . format ( STRING , trimmedLicense ) ) ; } }
public static License read ( final String license ) { final String trimmedLicense = license . trim ( ) ; if ( sLicenses . containsKey ( trimmedLicense ) ) { return sLicenses . get ( trimmedLicense ) ; } else { throw new IllegalStateException ( String . format ( STRING , trimmedLicense ) ) ; } }
public boolean isAllowCreate ( ) { if ( allowCreate == null ) { return _BOOL ; } return allowCreate . booleanValue ( ) ; }
public synchronized void add ( double x , double y , double value ) { super . add ( x , y ) ; mValue . add ( value ) ; updateRange ( value ) ; }
public void columnAdded ( TableColumnModelEvent e ) { LimeTableColumn addedColumn = getToColumn ( e ) ; LimeTableColumn ltc = addedColumn ; setVisibility ( ltc , _BOOL ) ; TableColumnModel tcm = table . getColumnModel ( ) ; int order = getOrder ( ltc ) ; int current = tcm . getColumnIndex ( ltc . getId ( ) ) ; int max = tcm . getColumnCount ( ) ; if ( order != current ) { stopListening ( ) ; order = Math . min ( order , max - _NUM ) ; tcm . moveColumn ( current , order ) ; for ( current = order + _NUM ; current < max ; current ++ ) { ltc = ( LimeTableColumn ) tcm . getColumn ( current ) ; setOrder ( ltc , current ) ; } for ( Iterator < LimeTableColumn > i = table . getHiddenColumns ( ) ; i . hasNext ( ) ; ) { ltc = i . next ( ) ; current = getOrder ( ltc ) ; if ( current > order ) setOrder ( ltc , current + _NUM ) ; } startListening ( ) ; } if ( listener != null ) listener . columnAdded ( addedColumn , table ) ; save ( ) ; }
boolean checkCameraSize ( CameraOptions cameraId ) { boolean sizeAvailable = _BOOL ; Camera camera = null ; Method method = getCameraOpenMethod ( ) ; if ( method != null ) { try { camera = ( Camera ) method . invoke ( camera , new Object [ ] { cameraId . getValue ( ) } ) ; } catch ( Exception e ) { camera = Camera . open ( ) ; } } else { camera = Camera . open ( ) ; } if ( camera == null ) { return _BOOL ; } Parameters param = camera . getParameters ( ) ; List < Camera . Size > sizes = param . getSupportedPreviewSizes ( ) ; for ( Camera . Size size : sizes ) { if ( ( size . width == H264Config . QVGA_WIDTH && size . height == H264Config . QVGA_HEIGHT ) || ( size . width == H264Config . CIF_WIDTH && size . height == H264Config . CIF_HEIGHT ) || ( size . width == H264Config . VGA_WIDTH && size . height == H264Config . VGA_HEIGHT ) ) { sizeAvailable = _BOOL ; break ; } } camera . release ( ) ; return sizeAvailable ; }
public List < Vector2 > findPathBetween ( Vector2 from , Vector2 to ) throws Exception { resetSearchAlgorithm ( ) ; if ( ! quadTree . isFilled ( from ) || ! quadTree . isFilled ( to ) ) { throw new Exception ( STRING ) ; } from = quadTree . rasterize ( from ) ; to = quadTree . rasterize ( to ) ; goal = new Node ( to ) ; openList . add ( new Node ( from ) ) ; do { Node currentNode = getClosestNode ( ) ; if ( currentNode . equals ( goal ) ) { while ( currentNode . parent != null ) { path . add ( new Vector2 ( currentNode . x , currentNode . y ) ) ; currentNode = currentNode . parent ; } return path ; } openList . remove ( currentNode ) ; closedList . add ( currentNode ) ; expandNode ( currentNode ) ; } while ( ! openList . isEmpty ( ) ) ; throw new Exception ( STRING ) ; }
public List < Vector2 > findPathBetween ( Vector2 from , Vector2 to ) throws Exception { resetSearchAlgorithm ( ) ; if ( ! quadTree . isFilled ( from ) || ! quadTree . isFilled ( to ) ) { throw new Exception ( STRING ) ; } from = quadTree . rasterize ( from ) ; to = quadTree . rasterize ( to ) ; goal = new Node ( to ) ; openList . add ( new Node ( from ) ) ; do { Node currentNode = getClosestNode ( ) ; if ( currentNode . equals ( goal ) ) { while ( currentNode . parent != null ) { path . add ( new Vector2 ( currentNode . x , currentNode . y ) ) ; currentNode = currentNode . parent ; } return path ; } openList . remove ( currentNode ) ; closedList . add ( currentNode ) ; expandNode ( currentNode ) ; } while ( ! openList . isEmpty ( ) ) ; throw new Exception ( STRING ) ; }
public AnnotationMember ( String name , Object val , Class type , Method m ) { this ( name , val ) ; definingMethod = m ; if ( type == int . class ) { elementType = Integer . class ; } else if ( type == boolean . class ) { elementType = Boolean . class ; } else if ( type == char . class ) { elementType = Character . class ; } else if ( type == float . class ) { elementType = Float . class ; } else if ( type == double . class ) { elementType = Double . class ; } else if ( type == long . class ) { elementType = Long . class ; } else if ( type == short . class ) { elementType = Short . class ; } else if ( type == byte . class ) { elementType = Byte . class ; } else { elementType = type ; } }
public AnnotationMember ( String name , Object val , Class type , Method m ) { this ( name , val ) ; definingMethod = m ; if ( type == int . class ) { elementType = Integer . class ; } else if ( type == boolean . class ) { elementType = Boolean . class ; } else if ( type == char . class ) { elementType = Character . class ; } else if ( type == float . class ) { elementType = Float . class ; } else if ( type == double . class ) { elementType = Double . class ; } else if ( type == long . class ) { elementType = Long . class ; } else if ( type == short . class ) { elementType = Short . class ; } else if ( type == byte . class ) { elementType = Byte . class ; } else { elementType = type ; } }
public int value ( ) { return getElement ( _NUM ) & _NUM ; }
public int value ( ) { return getElement ( _NUM ) & _NUM ; }
public int value ( ) { return getElement ( _NUM ) & _NUM ; }
public void test_BSBM_Q1_noSolutions ( ) throws Exception { final TestHelper helper = new TestHelper ( STRING , STRING , new String [ ] { } , STRING ) ; assertSameJoinOrder ( new int [ ] { _NUM , _NUM , _NUM , _NUM , _NUM } , helper ) ; }
public void test_BSBM_Q1_noSolutions ( ) throws Exception { final TestHelper helper = new TestHelper ( STRING , STRING , new String [ ] { } , STRING ) ; assertSameJoinOrder ( new int [ ] { _NUM , _NUM , _NUM , _NUM , _NUM } , helper ) ; }
public static void fail ( String message ) { throw new IllegalStateException ( message == null ? STRING : message ) ; }
public boolean addEntry ( File file ) { if ( file == null ) { log . warning ( STRING ) ; return _BOOL ; } if ( ! file . exists ( ) || file . isDirectory ( ) || ! file . canRead ( ) ) { log . warning ( STRING + file + STRING + file . exists ( ) + STRING + file . isDirectory ( ) ) ; return _BOOL ; } log . fine ( STRING + file ) ; String name = file . getName ( ) ; byte [ ] data = null ; FileInputStream fis = null ; ByteArrayOutputStream os = null ; try { fis = new FileInputStream ( file ) ; os = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ _NUM * _NUM ] ; int length = - _NUM ; while ( ( length = fis . read ( buffer ) ) != - _NUM ) os . write ( buffer , _NUM , length ) ; data = os . toByteArray ( ) ; } catch ( IOException ioe ) { log . log ( Level . SEVERE , STRING , ioe ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException ex ) { log . log ( Level . SEVERE , STRING , ex ) ; } ; } if ( os != null ) { try { os . close ( ) ; } catch ( IOException ex ) { log . log ( Level . SEVERE , STRING , ex ) ; } ; } } return addEntry ( name , data ) ; }
public void call ( String name , List < Object > list ) throws IOException { if ( generator . isExcludingFieldsNamed ( name ) ) { return ; } writeName ( name ) ; writeArray ( list ) ; }
public void error ( XPathContext xctxt , String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { java . lang . String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; if ( null != xctxt ) { ErrorListener eh = xctxt . getErrorListener ( ) ; TransformerException te = new TransformerException ( fmsg , this ) ; eh . fatalError ( te ) ; } }
public void error ( XPathContext xctxt , String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { java . lang . String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; if ( null != xctxt ) { ErrorListener eh = xctxt . getErrorListener ( ) ; TransformerException te = new TransformerException ( fmsg , this ) ; eh . fatalError ( te ) ; } }
public synchronized void flush ( ) throws IOException { if ( closed ) { return ; } flushBuffer ( ) ; out . flush ( ) ; lastActivityTime = System . currentTimeMillis ( ) ; }
public synchronized void flush ( ) throws IOException { if ( closed ) { return ; } flushBuffer ( ) ; out . flush ( ) ; lastActivityTime = System . currentTimeMillis ( ) ; }
public synchronized void flush ( ) throws IOException { if ( closed ) { return ; } flushBuffer ( ) ; out . flush ( ) ; lastActivityTime = System . currentTimeMillis ( ) ; }
private String readFile ( String path , Charset encoding ) throws IOException { byte [ ] encoded = Files . readAllBytes ( Paths . get ( path ) ) ; return new String ( encoded , encoding ) ; }
@ NonNull protected static String sortableTitle ( @ Nullable String title ) { if ( title == null ) { return STRING ; } title = title . toLowerCase ( ) ; if ( title . startsWith ( STRING ) ) { return title . substring ( _NUM ) ; } else if ( title . startsWith ( STRING ) ) { return title . substring ( _NUM ) ; } else { return title ; } }
@ NonNull protected static String sortableTitle ( @ Nullable String title ) { if ( title == null ) { return STRING ; } title = title . toLowerCase ( ) ; if ( title . startsWith ( STRING ) ) { return title . substring ( _NUM ) ; } else if ( title . startsWith ( STRING ) ) { return title . substring ( _NUM ) ; } else { return title ; } }
@ NonNull protected static String sortableTitle ( @ Nullable String title ) { if ( title == null ) { return STRING ; } title = title . toLowerCase ( ) ; if ( title . startsWith ( STRING ) ) { return title . substring ( _NUM ) ; } else if ( title . startsWith ( STRING ) ) { return title . substring ( _NUM ) ; } else { return title ; } }
@ Override public void warn ( String msg , Throwable t ) { if ( logger . isLoggable ( Level . WARNING ) ) { log ( SELF , Level . WARNING , msg , t ) ; } }
public void write ( final IRawStore store ) { if ( addrMetadata != _NUM ) { throw new IllegalStateException ( STRING ) ; } if ( indexUUID == null ) { throw new IllegalStateException ( STRING ) ; } this . addrMetadata = store . write ( ByteBuffer . wrap ( SerializerUtil . serialize ( this ) ) ) ; }
public void write ( final IRawStore store ) { if ( addrMetadata != _NUM ) { throw new IllegalStateException ( STRING ) ; } if ( indexUUID == null ) { throw new IllegalStateException ( STRING ) ; } this . addrMetadata = store . write ( ByteBuffer . wrap ( SerializerUtil . serialize ( this ) ) ) ; }
@ Override public void write ( int b ) { int newcount = count + _NUM ; if ( newcount > buf . length ) { buf = Utils . copyOf ( buf , Math . max ( buf . length << _NUM , newcount ) ) ; } buf [ count ] = ( byte ) b ; count = newcount ; }
public int hashCode ( ) { return pattern . hashCode ( ) ; }
SchemaFuture installHandlers ( XMLReader in , SchemaReceiverImpl sr ) { Handler h = new Handler ( sr ) ; in . setContentHandler ( h ) ; return h ; }
public TaskStackBuilder addParentStack ( ComponentName sourceActivityName ) { final int insertAt = mIntents . size ( ) ; try { Intent parent = NavUtils . getParentActivityIntent ( mSourceContext , sourceActivityName ) ; while ( parent != null ) { mIntents . add ( insertAt , parent ) ; parent = NavUtils . getParentActivityIntent ( mSourceContext , parent . getComponent ( ) ) ; } } catch ( NameNotFoundException e ) { Log . e ( TAG , STRING ) ; throw new IllegalArgumentException ( e ) ; } return this ; }
public TaskStackBuilder addParentStack ( ComponentName sourceActivityName ) { final int insertAt = mIntents . size ( ) ; try { Intent parent = NavUtils . getParentActivityIntent ( mSourceContext , sourceActivityName ) ; while ( parent != null ) { mIntents . add ( insertAt , parent ) ; parent = NavUtils . getParentActivityIntent ( mSourceContext , parent . getComponent ( ) ) ; } } catch ( NameNotFoundException e ) { Log . e ( TAG , STRING ) ; throw new IllegalArgumentException ( e ) ; } return this ; }
BlockId append ( String fileName , IoBuffer buffer ) { try { IoChannel fileChannel = getFileChannel ( fileName ) ; buffer . rewind ( ) ; long newSize = fileChannel . append ( buffer ) ; return new BlockId ( fileName , newSize / BLOCK_SIZE - _NUM ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } }
public void writeTo ( OutputStream os ) throws IOException { DataOutputStream dos = new DataOutputStream ( os ) ; dos . writeInt ( N ) ; dos . writeInt ( q ) ; dos . writeInt ( df ) ; dos . writeInt ( df1 ) ; dos . writeInt ( df2 ) ; dos . writeInt ( df3 ) ; dos . writeInt ( db ) ; dos . writeInt ( dm0 ) ; dos . writeInt ( c ) ; dos . writeInt ( minCallsR ) ; dos . writeInt ( minCallsMask ) ; dos . writeBoolean ( hashSeed ) ; dos . write ( oid ) ; dos . writeBoolean ( sparse ) ; dos . writeBoolean ( fastFp ) ; dos . write ( polyType ) ; dos . writeUTF ( hashAlg . getAlgorithmName ( ) ) ; }
@ HLEFunction ( nid = _NUM , version = _NUM ) public int sceNetApctlAddHandler ( TPointer handler , int handlerArg ) { int uid = SceUidManager . getNewUid ( uidPurpose ) ; ApctlHandler apctlHandler = new ApctlHandler ( uid , handler . getAddress ( ) , handlerArg ) ; apctlHandlers . put ( uid , apctlHandler ) ; return uid ; }
@ Override public void execute ( String ... parameters ) throws IOException { if ( parameters . length < _NUM ) { cio . writeln ( PrintHelp . FEDERATE ) ; } else { LinkedList < String > plist = new LinkedList < String > ( Arrays . asList ( parameters ) ) ; plist . remove ( ) ; boolean distinct = getOptionalParamValue ( plist , STRING , _BOOL ) ; boolean readonly = getOptionalParamValue ( plist , STRING , _BOOL ) ; if ( distinctValues ( plist ) ) { String fedID = plist . pop ( ) ; federate ( distinct , readonly , fedID , plist ) ; } else { cio . writeError ( STRING ) ; } } }
public IMFErrorLoggerImpl ( ) { this . errorObjects = Collections . synchronizedSet ( new HashSet < ErrorLogger . ErrorObject > ( ) ) ; }
public IMFErrorLoggerImpl ( ) { this . errorObjects = Collections . synchronizedSet ( new HashSet < ErrorLogger . ErrorObject > ( ) ) ; }
public IMFErrorLoggerImpl ( ) { this . errorObjects = Collections . synchronizedSet ( new HashSet < ErrorLogger . ErrorObject > ( ) ) ; }
public LinkedList < Diff > diff_main ( String text1 , String text2 ) { return diff_main ( text1 , text2 , _BOOL ) ; }
public LinkedList < Diff > diff_main ( String text1 , String text2 ) { return diff_main ( text1 , text2 , _BOOL ) ; }
public static Element addChildElement ( Element element , String childElementName , Document document ) { Element newElement = document . createElement ( childElementName ) ; element . appendChild ( newElement ) ; return newElement ; }
public static Element addChildElement ( Element element , String childElementName , Document document ) { Element newElement = document . createElement ( childElementName ) ; element . appendChild ( newElement ) ; return newElement ; }
public BytePointer ( String s , String charsetName ) throws UnsupportedEncodingException { this ( s . getBytes ( charsetName ) . length + _NUM ) ; putString ( s , charsetName ) ; }
public BytePointer ( String s , String charsetName ) throws UnsupportedEncodingException { this ( s . getBytes ( charsetName ) . length + _NUM ) ; putString ( s , charsetName ) ; }
public ComputeTaskCancelledException ( Throwable cause ) { this ( cause . getMessage ( ) , cause ) ; }
public static Connection enlistConnection ( XAConnection xacon ) throws GenericTransactionException { if ( xacon == null ) { return null ; } try { XAResource resource = xacon . getXAResource ( ) ; TransactionUtil . enlistResource ( resource ) ; return xacon . getConnection ( ) ; } catch ( SQLException e ) { throw new GenericTransactionException ( STRING , e ) ; } }
public static Connection enlistConnection ( XAConnection xacon ) throws GenericTransactionException { if ( xacon == null ) { return null ; } try { XAResource resource = xacon . getXAResource ( ) ; TransactionUtil . enlistResource ( resource ) ; return xacon . getConnection ( ) ; } catch ( SQLException e ) { throw new GenericTransactionException ( STRING , e ) ; } }
public static Connection enlistConnection ( XAConnection xacon ) throws GenericTransactionException { if ( xacon == null ) { return null ; } try { XAResource resource = xacon . getXAResource ( ) ; TransactionUtil . enlistResource ( resource ) ; return xacon . getConnection ( ) ; } catch ( SQLException e ) { throw new GenericTransactionException ( STRING , e ) ; } }
public static Connection enlistConnection ( XAConnection xacon ) throws GenericTransactionException { if ( xacon == null ) { return null ; } try { XAResource resource = xacon . getXAResource ( ) ; TransactionUtil . enlistResource ( resource ) ; return xacon . getConnection ( ) ; } catch ( SQLException e ) { throw new GenericTransactionException ( STRING , e ) ; } }
private void updateAssociatedTableWithFK ( DataSupport baseObj ) { Map < String , Set < Long > > associatedModelMap = baseObj . getAssociatedModelsMapWithFK ( ) ; ContentValues values = new ContentValues ( ) ; for ( String associatedTableName : associatedModelMap . keySet ( ) ) { values . clear ( ) ; String fkName = getForeignKeyColumnName ( baseObj . getTableName ( ) ) ; values . put ( fkName , baseObj . getBaseObjId ( ) ) ; Set < Long > ids = associatedModelMap . get ( associatedTableName ) ; if ( ids != null && ! ids . isEmpty ( ) ) { mDatabase . update ( associatedTableName , values , getWhereOfIdsWithOr ( ids ) , null ) ; } } }
public java . lang . StringBuilder insert ( int offset , int i ) { return insert ( offset , Integer . toString ( i ) ) ; }
public java . lang . StringBuilder insert ( int offset , int i ) { return insert ( offset , Integer . toString ( i ) ) ; }
public java . lang . StringBuilder insert ( int offset , int i ) { return insert ( offset , Integer . toString ( i ) ) ; }
public void removePropertyChangeListener ( String propertyName , PropertyChangeListener listener ) { if ( listener != null ) { synchronized ( this ) { if ( changeSupport != null ) { changeSupport . removePropertyChangeListener ( propertyName , listener ) ; } } } }
public void removePropertyChangeListener ( String propertyName , PropertyChangeListener listener ) { if ( listener != null ) { synchronized ( this ) { if ( changeSupport != null ) { changeSupport . removePropertyChangeListener ( propertyName , listener ) ; } } } }
public void removePropertyChangeListener ( String propertyName , PropertyChangeListener listener ) { if ( listener != null ) { synchronized ( this ) { if ( changeSupport != null ) { changeSupport . removePropertyChangeListener ( propertyName , listener ) ; } } } }
public static long copy ( InputStream in , OutputStream out , long length ) throws IOException { try { long copied = _NUM ; int len = ( int ) Math . min ( length , Constants . IO_BUFFER_SIZE ) ; byte [ ] buffer = new byte [ len ] ; while ( length > _NUM ) { len = in . read ( buffer , _NUM , len ) ; if ( len < _NUM ) { break ; } if ( out != null ) { out . write ( buffer , _NUM , len ) ; } copied += len ; length -= len ; len = ( int ) Math . min ( length , Constants . IO_BUFFER_SIZE ) ; } return copied ; } catch ( Exception e ) { throw DbException . convertToIOException ( e ) ; } }
public void charactersRaw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( isOutsideDocElem ( ) && XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) return ; String s = new String ( ch , start , length ) ; append ( m_doc . createProcessingInstruction ( STRING , STRING ) ) ; append ( m_doc . createTextNode ( s ) ) ; }
public void charactersRaw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( isOutsideDocElem ( ) && XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) return ; String s = new String ( ch , start , length ) ; append ( m_doc . createProcessingInstruction ( STRING , STRING ) ) ; append ( m_doc . createTextNode ( s ) ) ; }
protected Map < String , RamlMimeType > extractRequestBodyFromMethod ( RamlActionType apiAction , Method method , Map < String , String > parameterComments ) { if ( ! ( doesActionTypeSupportRequestBody ( apiAction ) ) || method . getParameterCount ( ) == _NUM ) { return Collections . emptyMap ( ) ; } String comment = null ; List < ApiParameterMetadata > apiParameters = getApiParameters ( method , _BOOL , _BOOL ) ; if ( apiParameters . size ( ) == _NUM ) { return Collections . emptyMap ( ) ; } Pair < String , RamlMimeType > schemaAndMime = extractRequestBody ( method , parameterComments , comment , apiParameters ) ; return Collections . singletonMap ( schemaAndMime . getFirst ( ) , schemaAndMime . getSecond ( ) ) ; }
protected Map < String , RamlMimeType > extractRequestBodyFromMethod ( RamlActionType apiAction , Method method , Map < String , String > parameterComments ) { if ( ! ( doesActionTypeSupportRequestBody ( apiAction ) ) || method . getParameterCount ( ) == _NUM ) { return Collections . emptyMap ( ) ; } String comment = null ; List < ApiParameterMetadata > apiParameters = getApiParameters ( method , _BOOL , _BOOL ) ; if ( apiParameters . size ( ) == _NUM ) { return Collections . emptyMap ( ) ; } Pair < String , RamlMimeType > schemaAndMime = extractRequestBody ( method , parameterComments , comment , apiParameters ) ; return Collections . singletonMap ( schemaAndMime . getFirst ( ) , schemaAndMime . getSecond ( ) ) ; }
public XMLGrammarPreparser ( SymbolTable symbolTable ) { fSymbolTable = symbolTable ; fLoaders = new Hashtable ( ) ; fErrorReporter = new XMLErrorReporter ( ) ; setLocale ( Locale . getDefault ( ) ) ; fEntityResolver = new XMLEntityManager ( ) ; }
public XMLGrammarPreparser ( SymbolTable symbolTable ) { fSymbolTable = symbolTable ; fLoaders = new Hashtable ( ) ; fErrorReporter = new XMLErrorReporter ( ) ; setLocale ( Locale . getDefault ( ) ) ; fEntityResolver = new XMLEntityManager ( ) ; }
public XMLGrammarPreparser ( SymbolTable symbolTable ) { fSymbolTable = symbolTable ; fLoaders = new Hashtable ( ) ; fErrorReporter = new XMLErrorReporter ( ) ; setLocale ( Locale . getDefault ( ) ) ; fEntityResolver = new XMLEntityManager ( ) ; }
@ Override public void mkDir ( @ NotNull File at ) { try { myIO . mkDir ( getTargetFile ( at ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
@ Override public void mkDir ( @ NotNull File at ) { try { myIO . mkDir ( getTargetFile ( at ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
@ RequestMapping ( value = { STRING , STRING } , method = RequestMethod . DELETE ) @ ResponseBody public RestWrapper delete ( @ PathVariable ( STRING ) String configGroup , @ PathVariable ( STRING ) String key , Principal principal ) { RestWrapper restWrapper = null ; try { GeneralConfig generalConfig = new GeneralConfig ( ) ; generalConfig . setConfigGroup ( configGroup ) ; generalConfig . setKey ( key ) ; GeneralConfigId jpaGeneralConfigId = new GeneralConfigId ( ) ; jpaGeneralConfigId . setConfigGroup ( generalConfig . getConfigGroup ( ) ) ; jpaGeneralConfigId . setGcKey ( generalConfig . getKey ( ) ) ; generalConfigDAO . delete ( jpaGeneralConfigId ) ; restWrapper = new RestWrapper ( null , RestWrapper . OK ) ; LOGGER . info ( STRING + key + STRING + principal . getName ( ) ) ; } catch ( MetadataException e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
protected int hash ( Object key1 , Object key2 ) { int h = _NUM ; if ( key1 != null ) { h ^= key1 . hashCode ( ) ; } if ( key2 != null ) { h ^= key2 . hashCode ( ) ; } h += ~ ( h << _NUM ) ; h ^= ( h > > > _NUM ) ; h += ( h << _NUM ) ; h ^= ( h > > > _NUM ) ; return h ; }
public boolean hasLongColumnInfo ( ) { return this . hasLongColumnInfo ; }
public void defineProperty ( String propertyName , Object value , int attributes ) { checkNotSealed ( propertyName , _NUM ) ; put ( propertyName , this , value ) ; setAttributes ( propertyName , attributes ) ; }
public void defineProperty ( String propertyName , Object value , int attributes ) { checkNotSealed ( propertyName , _NUM ) ; put ( propertyName , this , value ) ; setAttributes ( propertyName , attributes ) ; }
private static String normalizeHelper ( String number , Map < Character , Character > normalizationReplacements , boolean removeNonMatches ) { StringBuilder normalizedNumber = new StringBuilder ( number . length ( ) ) ; for ( int i = _NUM ; i < number . length ( ) ; i ++ ) { char character = number . charAt ( i ) ; Character newDigit = normalizationReplacements . get ( Character . toUpperCase ( character ) ) ; if ( newDigit != null ) { normalizedNumber . append ( newDigit ) ; } else if ( ! removeNonMatches ) { normalizedNumber . append ( character ) ; } } return normalizedNumber . toString ( ) ; }
private static String normalizeHelper ( String number , Map < Character , Character > normalizationReplacements , boolean removeNonMatches ) { StringBuilder normalizedNumber = new StringBuilder ( number . length ( ) ) ; for ( int i = _NUM ; i < number . length ( ) ; i ++ ) { char character = number . charAt ( i ) ; Character newDigit = normalizationReplacements . get ( Character . toUpperCase ( character ) ) ; if ( newDigit != null ) { normalizedNumber . append ( newDigit ) ; } else if ( ! removeNonMatches ) { normalizedNumber . append ( character ) ; } } return normalizedNumber . toString ( ) ; }
private static String normalizeHelper ( String number , Map < Character , Character > normalizationReplacements , boolean removeNonMatches ) { StringBuilder normalizedNumber = new StringBuilder ( number . length ( ) ) ; for ( int i = _NUM ; i < number . length ( ) ; i ++ ) { char character = number . charAt ( i ) ; Character newDigit = normalizationReplacements . get ( Character . toUpperCase ( character ) ) ; if ( newDigit != null ) { normalizedNumber . append ( newDigit ) ; } else if ( ! removeNonMatches ) { normalizedNumber . append ( character ) ; } } return normalizedNumber . toString ( ) ; }
private static String normalizeHelper ( String number , Map < Character , Character > normalizationReplacements , boolean removeNonMatches ) { StringBuilder normalizedNumber = new StringBuilder ( number . length ( ) ) ; for ( int i = _NUM ; i < number . length ( ) ; i ++ ) { char character = number . charAt ( i ) ; Character newDigit = normalizationReplacements . get ( Character . toUpperCase ( character ) ) ; if ( newDigit != null ) { normalizedNumber . append ( newDigit ) ; } else if ( ! removeNonMatches ) { normalizedNumber . append ( character ) ; } } return normalizedNumber . toString ( ) ; }
private static String normalizeHelper ( String number , Map < Character , Character > normalizationReplacements , boolean removeNonMatches ) { StringBuilder normalizedNumber = new StringBuilder ( number . length ( ) ) ; for ( int i = _NUM ; i < number . length ( ) ; i ++ ) { char character = number . charAt ( i ) ; Character newDigit = normalizationReplacements . get ( Character . toUpperCase ( character ) ) ; if ( newDigit != null ) { normalizedNumber . append ( newDigit ) ; } else if ( ! removeNonMatches ) { normalizedNumber . append ( character ) ; } } return normalizedNumber . toString ( ) ; }
synchronized void receive ( int c ) throws IOException { if ( ! connected ) { throw new IOException ( STRING ) ; } else if ( closedByWriter || closedByReader ) { throw new IOException ( STRING ) ; } else if ( readSide != null && ! readSide . isAlive ( ) ) { throw new IOException ( STRING ) ; } writeSide = Thread . currentThread ( ) ; while ( in == out ) { if ( ( readSide != null ) && ! readSide . isAlive ( ) ) { throw new IOException ( STRING ) ; } notifyAll ( ) ; try { wait ( _NUM ) ; } catch ( InterruptedException ex ) { throw new java . io . InterruptedIOException ( ) ; } } if ( in < _NUM ) { in = _NUM ; out = _NUM ; } buffer [ in ++ ] = ( char ) c ; if ( in >= buffer . length ) { in = _NUM ; } }
public void addListener ( final IMemoryListener listener ) { m_listeners . add ( listener ) ; }
private void sched ( TimerTask task , long time , long period ) { if ( time < _NUM ) throw new IllegalArgumentException ( STRING ) ; if ( Math . abs ( period ) > ( Long . MAX_VALUE > > _NUM ) ) period >>= _NUM ; synchronized ( queue ) { if ( ! thread . newTasksMayBeScheduled ) throw new IllegalStateException ( STRING ) ; synchronized ( task . lock ) { if ( task . state != TimerTask . VIRGIN ) throw new IllegalStateException ( STRING ) ; task . nextExecutionTime = time ; task . period = period ; task . state = TimerTask . SCHEDULED ; } queue . add ( task ) ; if ( queue . getMin ( ) == task ) queue . notify ( ) ; } }
@ Override public TemplateDruidQuery withAggregations ( Collection < Aggregation > newAggregations ) { return new TemplateDruidQuery ( newAggregations , postAggregations , nestedQuery , timeGrain ) ; }
public static DistributionConfigImpl produce ( Properties props ) { if ( props != null ) { Object o = props . get ( DS_CONFIG_NAME ) ; if ( o instanceof DistributionConfigImpl ) { return ( DistributionConfigImpl ) o ; } } return new DistributionConfigImpl ( props , _BOOL , _BOOL ) ; }
public void add ( byte [ ] bytes ) { int [ ] hashes = createHashes ( bytes , k , getNewDigestFunction ( ) ) ; for ( int hash : hashes ) bitset . set ( Math . abs ( hash % bitSetSize ) , _BOOL ) ; numberOfAddedElements ++ ; }
public static void showFinishedNotification ( String content , int time , boolean error , Context context , Intent intent ) { if ( context == null ) return ; NotificationManager mNotMan = ( NotificationManager ) context . getSystemService ( Context . NOTIFICATION_SERVICE ) ; int icon = R . drawable . icon ; CharSequence title = String . format ( ( String ) context . getText ( R . string . Utils_DownloadFinishedTitle ) , time ) ; CharSequence ticker = context . getText ( R . string . Utils_DownloadFinishedTicker ) ; CharSequence text = content ; if ( content == null ) text = context . getText ( R . string . Utils_DownloadFinishedText ) ; if ( error ) { icon = R . drawable . icon ; title = context . getText ( R . string . Utils_DownloadErrorTitle ) ; ticker = context . getText ( R . string . Utils_DownloadErrorTicker ) ; } Notification notification = buildNotification ( context , icon , ticker , title , text , _BOOL , intent ) ; mNotMan . notify ( ID_FINISHED , notification ) ; }
DHCrypt ( BigInteger modulus , BigInteger base , SecureRandom random ) { this ( modulus . bitLength ( ) , new DHParameterSpec ( modulus , base ) , random ) ; }
public void testProbabilityValuesFromThePaper ( ) { List < Integer > nodes = new ArrayList < Integer > ( ) ; nodes . add ( _NUM ) ; nodes . add ( _NUM ) ; nodes . add ( _NUM ) ; nodes . add ( _NUM ) ; double unknownProb = _NUM / nodes . size ( ) ; MeetingProbabilitySet mps = new MeetingProbabilitySet ( _NUM , nodes ) ; assertEquals ( unknownProb , mps . getProbFor ( _NUM ) ) ; assertEquals ( unknownProb , mps . getProbFor ( _NUM ) ) ; mps . updateMeetingProbFor ( _NUM ) ; assertEquals ( _NUM , mps . getProbFor ( _NUM ) ) ; assertEquals ( _NUM , mps . getProbFor ( _NUM ) ) ; }
public void testProbabilityValuesFromThePaper ( ) { List < Integer > nodes = new ArrayList < Integer > ( ) ; nodes . add ( _NUM ) ; nodes . add ( _NUM ) ; nodes . add ( _NUM ) ; nodes . add ( _NUM ) ; double unknownProb = _NUM / nodes . size ( ) ; MeetingProbabilitySet mps = new MeetingProbabilitySet ( _NUM , nodes ) ; assertEquals ( unknownProb , mps . getProbFor ( _NUM ) ) ; assertEquals ( unknownProb , mps . getProbFor ( _NUM ) ) ; mps . updateMeetingProbFor ( _NUM ) ; assertEquals ( _NUM , mps . getProbFor ( _NUM ) ) ; assertEquals ( _NUM , mps . getProbFor ( _NUM ) ) ; }
public void testProbabilityValuesFromThePaper ( ) { List < Integer > nodes = new ArrayList < Integer > ( ) ; nodes . add ( _NUM ) ; nodes . add ( _NUM ) ; nodes . add ( _NUM ) ; nodes . add ( _NUM ) ; double unknownProb = _NUM / nodes . size ( ) ; MeetingProbabilitySet mps = new MeetingProbabilitySet ( _NUM , nodes ) ; assertEquals ( unknownProb , mps . getProbFor ( _NUM ) ) ; assertEquals ( unknownProb , mps . getProbFor ( _NUM ) ) ; mps . updateMeetingProbFor ( _NUM ) ; assertEquals ( _NUM , mps . getProbFor ( _NUM ) ) ; assertEquals ( _NUM , mps . getProbFor ( _NUM ) ) ; }
public Element simulate ( final List < Instruction > instructions ) { lock . lock ( ) ; try { returnElement = null ; return simulateInternal ( instructions ) ; } finally { lock . unlock ( ) ; } }
public Element simulate ( final List < Instruction > instructions ) { lock . lock ( ) ; try { returnElement = null ; return simulateInternal ( instructions ) ; } finally { lock . unlock ( ) ; } }
public void actionPerformed ( ActionEvent e ) { File nextPage = ( File ) JOptionPane . showInputDialog ( eezeFrame , STRING , STRING , JOptionPane . PLAIN_MESSAGE , null , testFiles . toArray ( ) , currentDisplayed ) ; try { switchPage ( nextPage , _BOOL ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
public synchronized void addClass ( IdentifierToken t ) { singles . addElement ( t ) ; }
public static void assertThrowsCompletionException ( final Consumer < Void > consumer , final Class < ? > exceptionClass ) { try { consumer . accept ( null ) ; } catch ( final CompletionException completionEx ) { final Throwable ex = completionEx . getCause ( ) ; if ( ex . getClass ( ) == exceptionClass ) { return ; } Assert . fail ( String . format ( STRING , ex . getClass ( ) ) ) ; } Assert . fail ( String . format ( STRING , exceptionClass ) ) ; }
public static void assertThrowsCompletionException ( final Consumer < Void > consumer , final Class < ? > exceptionClass ) { try { consumer . accept ( null ) ; } catch ( final CompletionException completionEx ) { final Throwable ex = completionEx . getCause ( ) ; if ( ex . getClass ( ) == exceptionClass ) { return ; } Assert . fail ( String . format ( STRING , ex . getClass ( ) ) ) ; } Assert . fail ( String . format ( STRING , exceptionClass ) ) ; }
private void putWithValidation ( String key , Object value ) throws BitcoinURIParseException { if ( parameterMap . containsKey ( key ) ) { throw new BitcoinURIParseException ( String . format ( Locale . US , STRING , key ) ) ; } else { parameterMap . put ( key , value ) ; } }
private static void addSingleUnique ( FieldType fieldType , List < String > additionalArgs ) { StringBuilder alterSb = new StringBuilder ( ) ; alterSb . append ( STRING ) ; appendEscapedEntityName ( alterSb , fieldType . getColumnName ( ) ) ; alterSb . append ( STRING ) ; additionalArgs . add ( alterSb . toString ( ) ) ; }
private static void addSingleUnique ( FieldType fieldType , List < String > additionalArgs ) { StringBuilder alterSb = new StringBuilder ( ) ; alterSb . append ( STRING ) ; appendEscapedEntityName ( alterSb , fieldType . getColumnName ( ) ) ; alterSb . append ( STRING ) ; additionalArgs . add ( alterSb . toString ( ) ) ; }
private static ValueLob createBlob ( InputStream in , long length , DataHandler handler ) { try { if ( handler == null ) { byte [ ] data = IOUtils . readBytesAndClose ( in , ( int ) length ) ; return createSmallLob ( Value . BLOB , data ) ; } long remaining = Long . MAX_VALUE ; boolean compress = handler . getLobCompressionAlgorithm ( Value . BLOB ) != null ; if ( length >= _NUM && length < remaining ) { remaining = length ; } int len = getBufferSize ( handler , compress , remaining ) ; byte [ ] buff ; if ( len >= Integer . MAX_VALUE ) { buff = IOUtils . readBytesAndClose ( in , - _NUM ) ; len = buff . length ; } else { buff = DataUtils . newBytes ( len ) ; len = IOUtils . readFully ( in , buff , len ) ; } if ( len <= handler . getMaxLengthInplaceLob ( ) ) { byte [ ] small = DataUtils . newBytes ( len ) ; System . arraycopy ( buff , _NUM , small , _NUM , len ) ; return ValueLob . createSmallLob ( Value . BLOB , small ) ; } ValueLob lob = new ValueLob ( Value . BLOB , null ) ; lob . createFromStream ( buff , len , in , remaining , handler ) ; return lob ; } catch ( IOException e ) { throw DbException . convertIOException ( e , null ) ; } }
public boolean hasOnDisk ( final String key ) { synchronized ( mEntries ) { return mEntries . contains ( sanitizeKey ( key ) ) ; } }
@ Parameterized . Parameters ( name = STRING ) public static Collection < Integer > data ( ) { return Arrays . asList ( _NUM , _NUM ) ; }
@ Parameterized . Parameters ( name = STRING ) public static Collection < Integer > data ( ) { return Arrays . asList ( _NUM , _NUM ) ; }
@ Parameterized . Parameters ( name = STRING ) public static Collection < Integer > data ( ) { return Arrays . asList ( _NUM , _NUM ) ; }
public static void log ( Throwable error , String message , Object ... args ) { if ( loggingEnabled ) { Log . d ( TAG , args . length == _NUM ? message : String . format ( message , args ) , error ) ; } }
public ServiceCall < Void > resetCustomization ( String customizationId ) { Validator . notNull ( customizationId , STRING ) ; RequestBuilder requestBuilder = RequestBuilder . post ( String . format ( PATH_RESET , customizationId ) ) ; return createServiceCall ( requestBuilder . build ( ) , ResponseConverterUtils . getVoid ( ) ) ; }
public ServiceCall < Void > resetCustomization ( String customizationId ) { Validator . notNull ( customizationId , STRING ) ; RequestBuilder requestBuilder = RequestBuilder . post ( String . format ( PATH_RESET , customizationId ) ) ; return createServiceCall ( requestBuilder . build ( ) , ResponseConverterUtils . getVoid ( ) ) ; }
public ServiceCall < Void > resetCustomization ( String customizationId ) { Validator . notNull ( customizationId , STRING ) ; RequestBuilder requestBuilder = RequestBuilder . post ( String . format ( PATH_RESET , customizationId ) ) ; return createServiceCall ( requestBuilder . build ( ) , ResponseConverterUtils . getVoid ( ) ) ; }
@ Override public void execute ( MetricTimeSeries timeSeries , FunctionValueMap functionValueMap ) { if ( timeSeries . size ( ) <= _NUM ) { functionValueMap . add ( this , Double . NaN ) ; return ; } timeSeries . sort ( ) ; double firstValue = timeSeries . getValue ( _NUM ) ; double lastValue = timeSeries . getValue ( timeSeries . size ( ) - _NUM ) ; functionValueMap . add ( this , Math . abs ( firstValue - lastValue ) ) ; }
List < Integer > segmentSizes ( ) { if ( head == null ) return Collections . emptyList ( ) ; List < Integer > result = new ArrayList < > ( ) ; result . add ( head . limit - head . pos ) ; for ( Segment s = head . next ; s != head ; s = s . next ) { result . add ( s . limit - s . pos ) ; } return result ; }
public List < JSONValue > values ( ) { return Collections . unmodifiableList ( values ) ; }
public List < JSONValue > values ( ) { return Collections . unmodifiableList ( values ) ; }
public List < JSONValue > values ( ) { return Collections . unmodifiableList ( values ) ; }
public List < JSONValue > values ( ) { return Collections . unmodifiableList ( values ) ; }
private static String bigIntegerToAsciiString ( final BigInteger bigInteger ) { final byte [ ] byteArray = bigInteger . toByteArray ( ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; for ( int i = _NUM ; i < byteArray . length ; i ++ ) { final char value = ( char ) ( byteArray [ i ] & _NUM ) ; if ( i == _NUM && value == _NUM ) { continue ; } stringBuffer . append ( value ) ; } return stringBuffer . toString ( ) ; }
private static String bigIntegerToAsciiString ( final BigInteger bigInteger ) { final byte [ ] byteArray = bigInteger . toByteArray ( ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; for ( int i = _NUM ; i < byteArray . length ; i ++ ) { final char value = ( char ) ( byteArray [ i ] & _NUM ) ; if ( i == _NUM && value == _NUM ) { continue ; } stringBuffer . append ( value ) ; } return stringBuffer . toString ( ) ; }
private static String bigIntegerToAsciiString ( final BigInteger bigInteger ) { final byte [ ] byteArray = bigInteger . toByteArray ( ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; for ( int i = _NUM ; i < byteArray . length ; i ++ ) { final char value = ( char ) ( byteArray [ i ] & _NUM ) ; if ( i == _NUM && value == _NUM ) { continue ; } stringBuffer . append ( value ) ; } return stringBuffer . toString ( ) ; }
@ Override public synchronized void close ( ) throws SQLException { try { debugCodeCall ( STRING ) ; if ( session == null ) { return ; } CloseWatcher . unregister ( watcher ) ; session . cancel ( ) ; if ( executingStatement != null ) { try { executingStatement . cancel ( ) ; } catch ( NullPointerException e ) { } } synchronized ( session ) { try { if ( ! session . isClosed ( ) ) { try { if ( session . hasPendingTransaction ( ) ) { if ( ! session . isReconnectNeeded ( _BOOL ) ) { try { rollbackInternal ( ) ; } catch ( DbException e ) { if ( e . getErrorCode ( ) != ErrorCode . CONNECTION_BROKEN_1 ) { throw e ; } } } session . afterWriting ( ) ; } closePreparedCommands ( ) ; } finally { session . close ( ) ; } } } finally { session = null ; } } } catch ( Exception e ) { throw logAndConvert ( e ) ; } }
@ Override public synchronized void close ( ) throws SQLException { try { debugCodeCall ( STRING ) ; if ( session == null ) { return ; } CloseWatcher . unregister ( watcher ) ; session . cancel ( ) ; if ( executingStatement != null ) { try { executingStatement . cancel ( ) ; } catch ( NullPointerException e ) { } } synchronized ( session ) { try { if ( ! session . isClosed ( ) ) { try { if ( session . hasPendingTransaction ( ) ) { if ( ! session . isReconnectNeeded ( _BOOL ) ) { try { rollbackInternal ( ) ; } catch ( DbException e ) { if ( e . getErrorCode ( ) != ErrorCode . CONNECTION_BROKEN_1 ) { throw e ; } } } session . afterWriting ( ) ; } closePreparedCommands ( ) ; } finally { session . close ( ) ; } } } finally { session = null ; } } } catch ( Exception e ) { throw logAndConvert ( e ) ; } }
protected void disconnect ( ) { try { traceOperation ( STRING ) ; conn . close ( ) ; } catch ( Exception e ) { traceOperation ( STRING , e ) ; } }
private static boolean isAnArgument ( final String arg ) { return ( arg . startsWith ( STRING ) && ( arg . length ( ) > _NUM ) && ! Character . isDigit ( arg . charAt ( _NUM ) ) ) ; }
private static boolean isAnArgument ( final String arg ) { return ( arg . startsWith ( STRING ) && ( arg . length ( ) > _NUM ) && ! Character . isDigit ( arg . charAt ( _NUM ) ) ) ; }
public static void deleteTabState ( File directory , int tabId , boolean encrypted ) { File file = getTabStateFile ( directory , tabId , encrypted ) ; if ( file . exists ( ) && ! file . delete ( ) ) Log . e ( TAG , STRING + file ) ; }
private Object [ ] resolveParameters ( Executable executable , Optional < Object > target , Object outerInstance , ExtensionContext extensionContext , ExtensionRegistry extensionRegistry ) { Preconditions . notNull ( target , STRING ) ; Parameter [ ] parameters = executable . getParameters ( ) ; Object [ ] values = new Object [ parameters . length ] ; int start = _NUM ; if ( outerInstance != null ) { values [ _NUM ] = outerInstance ; start = _NUM ; } for ( int i = start ; i < parameters . length ; i ++ ) { ParameterContext parameterContext = new DefaultParameterContext ( parameters [ i ] , i , target ) ; values [ i ] = resolveParameter ( parameterContext , executable , extensionContext , extensionRegistry ) ; } return values ; }
public Vector3 ceil ( ) { x = ( float ) Math . ceil ( x ) ; y = ( float ) Math . ceil ( y ) ; z = ( float ) Math . ceil ( z ) ; return this ; }
public void addColumnToDrop ( Column column ) { if ( ! columnsToDrop . contains ( column ) ) { columnsToDrop . add ( column ) ; } }
@ SuppressWarnings ( STRING ) public static < R > R callStaticMethod ( Class < ? > clazz , String methodName , ClassParameter < ? > ... classParameters ) { try { Class < ? > [ ] classes = ClassParameter . getClasses ( classParameters ) ; Object [ ] values = ClassParameter . getValues ( classParameters ) ; Method method = clazz . getDeclaredMethod ( methodName , classes ) ; method . setAccessible ( _BOOL ) ; return ( R ) method . invoke ( null , values ) ; } catch ( InvocationTargetException e ) { if ( e . getTargetException ( ) instanceof RuntimeException ) { throw ( RuntimeException ) e . getTargetException ( ) ; } if ( e . getTargetException ( ) instanceof Error ) { throw ( Error ) e . getTargetException ( ) ; } throw new RuntimeException ( e . getTargetException ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
public WebSocketImpl ( WebSocketListener listener , List < Draft > drafts ) { this ( listener , ( Draft ) null ) ; this . role = Role . SERVER ; if ( drafts == null || drafts . isEmpty ( ) ) { knownDrafts = defaultdraftlist ; } else { knownDrafts = drafts ; } }
@ Override public void write ( DataOutput out ) throws IOException { out . writeLong ( duration ) ; out . writeInt ( getLength ( ) ) ; for ( int i = _NUM ; i < coeffs . length ; i ++ ) { out . writeFloat ( coeffs [ i ] ) ; } }
public double distanceSq ( Vector other ) { return Math . pow ( other . x - x , _NUM ) + Math . pow ( other . y - y , _NUM ) + Math . pow ( other . z - z , _NUM ) ; }
public double linearDistance ( final Vector v ) { return Math . sqrt ( linearDistanceSquared ( v ) ) ; }
@ Override public synchronized void put ( String key , Entry entry ) { pruneIfNeeded ( entry . data . length ) ; File file = getFileForKey ( key ) ; try { FileOutputStream fos = new FileOutputStream ( file ) ; CacheHeader e = new CacheHeader ( key , entry ) ; boolean success = e . writeHeader ( fos ) ; if ( ! success ) { fos . close ( ) ; VolleyLog . d ( STRING , file . getAbsolutePath ( ) ) ; throw new IOException ( ) ; } fos . write ( entry . data ) ; fos . close ( ) ; putEntry ( key , e ) ; return ; } catch ( IOException e ) { } boolean deleted = file . delete ( ) ; if ( ! deleted ) { VolleyLog . d ( STRING , file . getAbsolutePath ( ) ) ; } }
public boolean isComponentPartOfCurrentMenu ( Component c ) { if ( selection . size ( ) > _NUM ) { MenuElement me = selection . elementAt ( _NUM ) ; return isComponentPartOfCurrentMenu ( me , c ) ; } else return _BOOL ; }
public Node popNode ( Class < ? extends Node > cls , String uri ) { synchronized ( nodeStack ) { if ( suppress ) { if ( ! suppressedNodeStack . isEmpty ( ) ) { Node suppressed = popNode ( suppressedNodeStack , cls , uri ) ; if ( suppressed != null ) { return suppressed ; } } else { suppress = _BOOL ; } } return popNode ( nodeStack , cls , uri ) ; } }
@ Override public int read ( ) throws IOException { return fInputStream . read ( ) ; }
@ Override public int read ( ) throws IOException { return fInputStream . read ( ) ; }
@ Override public int read ( ) throws IOException { return fInputStream . read ( ) ; }
@ Override public int read ( ) throws IOException { return fInputStream . read ( ) ; }
@ Override public int read ( ) throws IOException { return fInputStream . read ( ) ; }
public void test_transferTo_couldDelete ( ) throws Exception { writeDataToFile ( fileOfReadOnlyFileChannel ) ; writeDataToFile ( fileOfWriteOnlyFileChannel ) ; readOnlyFileChannel . transferTo ( _NUM , _NUM , writeOnlyFileChannel ) ; readOnlyFileChannel . close ( ) ; writeOnlyFileChannel . close ( ) ; boolean rDel = fileOfReadOnlyFileChannel . delete ( ) ; boolean wDel = fileOfWriteOnlyFileChannel . delete ( ) ; assertTrue ( STRING + readOnlyFileChannel + STRING , rDel ) ; assertTrue ( STRING + writeOnlyFileChannel + STRING , wDel ) ; }
public void test_transferTo_couldDelete ( ) throws Exception { writeDataToFile ( fileOfReadOnlyFileChannel ) ; writeDataToFile ( fileOfWriteOnlyFileChannel ) ; readOnlyFileChannel . transferTo ( _NUM , _NUM , writeOnlyFileChannel ) ; readOnlyFileChannel . close ( ) ; writeOnlyFileChannel . close ( ) ; boolean rDel = fileOfReadOnlyFileChannel . delete ( ) ; boolean wDel = fileOfWriteOnlyFileChannel . delete ( ) ; assertTrue ( STRING + readOnlyFileChannel + STRING , rDel ) ; assertTrue ( STRING + writeOnlyFileChannel + STRING , wDel ) ; }
public String render ( String resourceName , String screenName , boolean asString ) throws GeneralException , IOException , SAXException , ParserConfigurationException { ModelScreen modelScreen = ScreenFactory . getScreenFromLocation ( resourceName , screenName ) ; if ( modelScreen . getUseCache ( ) ) { WidgetContextCacheKey wcck = new WidgetContextCacheKey ( context ) ; String screenCombinedName = resourceName + STRING + screenName ; ScreenCache screenCache = new ScreenCache ( ) ; GenericWidgetOutput gwo = screenCache . get ( screenCombinedName , wcck ) ; if ( gwo == null ) { Writer sw = new StringWriter ( ) ; modelScreen . renderScreenString ( sw , context , screenStringRenderer ) ; gwo = new GenericWidgetOutput ( sw . toString ( ) ) ; screenCache . put ( screenCombinedName , wcck , gwo ) ; if ( asString ) { return gwo . toString ( ) ; } else { writer . append ( gwo . toString ( ) ) ; } } else { if ( asString ) { return gwo . toString ( ) ; } else { writer . append ( gwo . toString ( ) ) ; } } } else { context . put ( STRING , String . valueOf ( renderFormSeqNumber ) ) ; if ( asString ) { Writer sw = new StringWriter ( ) ; modelScreen . renderScreenString ( sw , context , screenStringRenderer ) ; return sw . toString ( ) ; } else { modelScreen . renderScreenString ( writer , context , screenStringRenderer ) ; } } return STRING ; }
public void addSipEventListener ( SipEventListener listener ) { mListeners . add ( listener ) ; }
public boolean element2Locator ( Element e , SimpleLocator l ) { if ( l == null ) return _BOOL ; if ( e instanceof ElementImpl ) { ElementImpl ele = ( ElementImpl ) e ; Document doc = ele . getOwnerDocument ( ) ; String sid = ( String ) fDoc2SystemId . get ( DOMUtil . getRoot ( doc ) ) ; int line = ele . getLineNumber ( ) ; int column = ele . getColumnNumber ( ) ; l . setValues ( sid , sid , line , column , ele . getCharacterOffset ( ) ) ; return _BOOL ; } return _BOOL ; }
public boolean element2Locator ( Element e , SimpleLocator l ) { if ( l == null ) return _BOOL ; if ( e instanceof ElementImpl ) { ElementImpl ele = ( ElementImpl ) e ; Document doc = ele . getOwnerDocument ( ) ; String sid = ( String ) fDoc2SystemId . get ( DOMUtil . getRoot ( doc ) ) ; int line = ele . getLineNumber ( ) ; int column = ele . getColumnNumber ( ) ; l . setValues ( sid , sid , line , column , ele . getCharacterOffset ( ) ) ; return _BOOL ; } return _BOOL ; }
public ForumPostConfig create ( ForumPostConfig config ) { config . addCredentials ( this ) ; String xml = POST ( this . url + STRING , config . toXML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { ForumPostConfig post = new ForumPostConfig ( ) ; post . parseXML ( root ) ; return post ; } catch ( Exception exception ) { this . exception = SDKException . parseFailure ( exception ) ; throw this . exception ; } }
public ForumPostConfig create ( ForumPostConfig config ) { config . addCredentials ( this ) ; String xml = POST ( this . url + STRING , config . toXML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { ForumPostConfig post = new ForumPostConfig ( ) ; post . parseXML ( root ) ; return post ; } catch ( Exception exception ) { this . exception = SDKException . parseFailure ( exception ) ; throw this . exception ; } }
public ForumPostConfig create ( ForumPostConfig config ) { config . addCredentials ( this ) ; String xml = POST ( this . url + STRING , config . toXML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { ForumPostConfig post = new ForumPostConfig ( ) ; post . parseXML ( root ) ; return post ; } catch ( Exception exception ) { this . exception = SDKException . parseFailure ( exception ) ; throw this . exception ; } }
private void savehttpRedLogout ( String lohttpLocation , String lohttpRespLocation , List logList , com . sun . identity . saml2 . jaxb . metadata . ObjectFactory objFact ) throws JAXBException { if ( lohttpLocation != null && lohttpLocation . length ( ) > _NUM ) { SingleLogoutServiceElement slsElemRed = objFact . createSingleLogoutServiceElement ( ) ; slsElemRed . setBinding ( httpRedirectBinding ) ; slsElemRed . setLocation ( lohttpLocation ) ; slsElemRed . setResponseLocation ( lohttpRespLocation ) ; logList . add ( slsElemRed ) ; } }
@ Override public void addTrainingSetListener ( TrainingSetListener tsl ) { m_trainingSetListeners . addElement ( tsl ) ; if ( m_format != null ) { TrainingSetEvent e = new TrainingSetEvent ( this , m_format ) ; tsl . acceptTrainingSet ( e ) ; } }
private static void computeRegions ( Rectangle sourceBounds , Dimension destSize , ImageWriteParam p ) { ImageWriteParam param ; int periodX = _NUM ; int periodY = _NUM ; if ( p != null ) { int [ ] sourceBands = p . getSourceBands ( ) ; if ( sourceBands != null && ( sourceBands . length != _NUM || sourceBands [ _NUM ] != _NUM ) ) { throw new IllegalArgumentException ( STRING ) ; } Rectangle sourceRegion = p . getSourceRegion ( ) ; if ( sourceRegion != null ) { sourceRegion = sourceRegion . intersection ( sourceBounds ) ; sourceBounds . setBounds ( sourceRegion ) ; } int gridX = p . getSubsamplingXOffset ( ) ; int gridY = p . getSubsamplingYOffset ( ) ; sourceBounds . x += gridX ; sourceBounds . y += gridY ; sourceBounds . width -= gridX ; sourceBounds . height -= gridY ; periodX = p . getSourceXSubsampling ( ) ; periodY = p . getSourceYSubsampling ( ) ; } destSize . setSize ( ( sourceBounds . width + periodX - _NUM ) / periodX , ( sourceBounds . height + periodY - _NUM ) / periodY ) ; if ( destSize . width <= _NUM || destSize . height <= _NUM ) { throw new IllegalArgumentException ( STRING ) ; } }
private static void computeRegions ( Rectangle sourceBounds , Dimension destSize , ImageWriteParam p ) { ImageWriteParam param ; int periodX = _NUM ; int periodY = _NUM ; if ( p != null ) { int [ ] sourceBands = p . getSourceBands ( ) ; if ( sourceBands != null && ( sourceBands . length != _NUM || sourceBands [ _NUM ] != _NUM ) ) { throw new IllegalArgumentException ( STRING ) ; } Rectangle sourceRegion = p . getSourceRegion ( ) ; if ( sourceRegion != null ) { sourceRegion = sourceRegion . intersection ( sourceBounds ) ; sourceBounds . setBounds ( sourceRegion ) ; } int gridX = p . getSubsamplingXOffset ( ) ; int gridY = p . getSubsamplingYOffset ( ) ; sourceBounds . x += gridX ; sourceBounds . y += gridY ; sourceBounds . width -= gridX ; sourceBounds . height -= gridY ; periodX = p . getSourceXSubsampling ( ) ; periodY = p . getSourceYSubsampling ( ) ; } destSize . setSize ( ( sourceBounds . width + periodX - _NUM ) / periodX , ( sourceBounds . height + periodY - _NUM ) / periodY ) ; if ( destSize . width <= _NUM || destSize . height <= _NUM ) { throw new IllegalArgumentException ( STRING ) ; } }
public final void test_ROUNDTRIP_GetKeySpecKeyProvider02 ( ) { boolean performed = _BOOL ; for ( int i = _NUM ; i < algName . length ; i ++ ) { for ( int l = _NUM ; l < provider . length ; l ++ ) { if ( provider [ l ] == null ) { continue ; } TestDataGenerator g ; try { g = new TestDataGenerator ( algName [ i ] [ _NUM ] , algName [ i ] [ _NUM ] , privateKeyInfoDamaged , provider [ l ] ) ; } catch ( TestDataGenerator . AllowedFailure allowedFailure ) { continue ; } try { EncryptedPrivateKeyInfo epki ; if ( g . ap ( ) == null ) { epki = new EncryptedPrivateKeyInfo ( algName [ i ] [ _NUM ] , g . ct ( ) ) ; } else { epki = new EncryptedPrivateKeyInfo ( g . ap ( ) , g . ct ( ) ) ; } try { epki . getKeySpec ( g . pubK ( ) == null ? g . k ( ) : g . pubK ( ) , provider [ l ] ) ; fail ( algName [ i ] [ _NUM ] + STRING + algName [ i ] [ _NUM ] ) ; } catch ( InvalidKeyException e ) { } performed = _BOOL ; } catch ( NoSuchAlgorithmException allowedFailure ) { } } } assertTrue ( STRING , performed ) ; }
public final void test_ROUNDTRIP_GetKeySpecKeyProvider02 ( ) { boolean performed = _BOOL ; for ( int i = _NUM ; i < algName . length ; i ++ ) { for ( int l = _NUM ; l < provider . length ; l ++ ) { if ( provider [ l ] == null ) { continue ; } TestDataGenerator g ; try { g = new TestDataGenerator ( algName [ i ] [ _NUM ] , algName [ i ] [ _NUM ] , privateKeyInfoDamaged , provider [ l ] ) ; } catch ( TestDataGenerator . AllowedFailure allowedFailure ) { continue ; } try { EncryptedPrivateKeyInfo epki ; if ( g . ap ( ) == null ) { epki = new EncryptedPrivateKeyInfo ( algName [ i ] [ _NUM ] , g . ct ( ) ) ; } else { epki = new EncryptedPrivateKeyInfo ( g . ap ( ) , g . ct ( ) ) ; } try { epki . getKeySpec ( g . pubK ( ) == null ? g . k ( ) : g . pubK ( ) , provider [ l ] ) ; fail ( algName [ i ] [ _NUM ] + STRING + algName [ i ] [ _NUM ] ) ; } catch ( InvalidKeyException e ) { } performed = _BOOL ; } catch ( NoSuchAlgorithmException allowedFailure ) { } } } assertTrue ( STRING , performed ) ; }
private boolean removeExpiredAttachmentPoints ( List < AttachmentPoint > apList ) { List < AttachmentPoint > expiredAPs = new ArrayList < AttachmentPoint > ( ) ; if ( apList == null ) return _BOOL ; for ( AttachmentPoint ap : apList ) { if ( ap . getLastSeen ( ) + AttachmentPoint . INACTIVITY_INTERVAL < System . currentTimeMillis ( ) ) expiredAPs . add ( ap ) ; } if ( expiredAPs . size ( ) > _NUM ) { apList . removeAll ( expiredAPs ) ; return _BOOL ; } else return _BOOL ; }
private void removePossibleSimpleKey ( ) { SimpleKey key = possibleSimpleKeys . remove ( flowLevel ) ; if ( key != null && key . isRequired ( ) ) { throw new ScannerException ( STRING , key . getMark ( ) , STRING , reader . getMark ( ) ) ; } }
private void removePossibleSimpleKey ( ) { SimpleKey key = possibleSimpleKeys . remove ( flowLevel ) ; if ( key != null && key . isRequired ( ) ) { throw new ScannerException ( STRING , key . getMark ( ) , STRING , reader . getMark ( ) ) ; } }
public static Exception establishCacheIfNeeded ( PrintStream ... progress ) { if ( m_offline ) { return null ; } if ( REP_MIRROR == null ) { establishMirror ( ) ; } Exception problem = null ; if ( INITIAL_CACHE_BUILD_NEEDED ) { for ( PrintStream p : progress ) { p . println ( STRING ) ; } problem = refreshCache ( progress ) ; INITIAL_CACHE_BUILD_NEEDED = _BOOL ; } return problem ; }
public void append ( char [ ] otherChars , int otherOffset , int otherLength ) { int newLen = ref . length + otherLength ; grow ( newLen ) ; System . arraycopy ( otherChars , otherOffset , ref . chars , ref . length , otherLength ) ; ref . length = newLen ; }
public static byte [ ] hash ( String input ) { if ( ! TextUtils . isEmpty ( input ) ) { try { byte [ ] inputBytes = input . getBytes ( STRING ) ; return hash ( inputBytes ) ; } catch ( UnsupportedEncodingException e ) { Log . e ( TAG , STRING + input + STRING + e . getMessage ( ) , e ) ; } } return null ; }
public ArrayFieldVector ( T [ ] v1 , FieldVector < T > v2 ) throws NullArgumentException { MathUtils . checkNotNull ( v1 ) ; MathUtils . checkNotNull ( v2 ) ; field = v2 . getField ( ) ; final T [ ] v2Data = ( v2 instanceof ArrayFieldVector ) ? ( ( ArrayFieldVector < T > ) v2 ) . data : v2 . toArray ( ) ; data = MathArrays . buildArray ( field , v1 . length + v2Data . length ) ; System . arraycopy ( v1 , _NUM , data , _NUM , v1 . length ) ; System . arraycopy ( v2Data , _NUM , data , v1 . length , v2Data . length ) ; }
public ArrayFieldVector ( T [ ] v1 , FieldVector < T > v2 ) throws NullArgumentException { MathUtils . checkNotNull ( v1 ) ; MathUtils . checkNotNull ( v2 ) ; field = v2 . getField ( ) ; final T [ ] v2Data = ( v2 instanceof ArrayFieldVector ) ? ( ( ArrayFieldVector < T > ) v2 ) . data : v2 . toArray ( ) ; data = MathArrays . buildArray ( field , v1 . length + v2Data . length ) ; System . arraycopy ( v1 , _NUM , data , _NUM , v1 . length ) ; System . arraycopy ( v2Data , _NUM , data , v1 . length , v2Data . length ) ; }
public ArrayFieldVector ( T [ ] v1 , FieldVector < T > v2 ) throws NullArgumentException { MathUtils . checkNotNull ( v1 ) ; MathUtils . checkNotNull ( v2 ) ; field = v2 . getField ( ) ; final T [ ] v2Data = ( v2 instanceof ArrayFieldVector ) ? ( ( ArrayFieldVector < T > ) v2 ) . data : v2 . toArray ( ) ; data = MathArrays . buildArray ( field , v1 . length + v2Data . length ) ; System . arraycopy ( v1 , _NUM , data , _NUM , v1 . length ) ; System . arraycopy ( v2Data , _NUM , data , v1 . length , v2Data . length ) ; }
public DSignCsr ( JFrame parent , Spkac spkacCsr , File csrFile , PrivateKey signPrivateKey , KeyPairType signKeyPairType , X509Certificate verificationCertificate , Provider provider ) throws CryptoException { super ( parent , Dialog . ModalityType . DOCUMENT_MODAL ) ; this . spkacCsr = spkacCsr ; this . csrFile = csrFile ; this . signPrivateKey = signPrivateKey ; this . signKeyPairType = signKeyPairType ; this . verificationCertificate = verificationCertificate ; this . provider = provider ; setTitle ( res . getString ( STRING ) ) ; initComponents ( ) ; }
public boolean hasAnyCapability ( String ... capabilities ) { for ( String capability : capabilities ) { if ( hasCapability ( capability ) ) return _BOOL ; } return _BOOL ; }
public boolean hasAnyCapability ( String ... capabilities ) { for ( String capability : capabilities ) { if ( hasCapability ( capability ) ) return _BOOL ; } return _BOOL ; }
public void invoke ( InputStream is , OutputStream os , SerializerFactory serializerFactory ) throws Exception { boolean isDebug = _BOOL ; if ( isDebugInvoke ( ) ) { isDebug = _BOOL ; PrintWriter dbg = createDebugPrintWriter ( ) ; HessianDebugInputStream dIs = new HessianDebugInputStream ( is , dbg ) ; dIs . startTop2 ( ) ; is = dIs ; HessianDebugOutputStream dOs = new HessianDebugOutputStream ( os , dbg ) ; dOs . startTop2 ( ) ; os = dOs ; } HessianInputFactory . HeaderType header = _inputFactory . readHeader ( is ) ; AbstractHessianInput in ; AbstractHessianOutput out ; switch ( header ) { case CALL_1_REPLY_1 : in = _hessianFactory . createHessianInput ( is ) ; out = _hessianFactory . createHessianOutput ( os ) ; break ; case CALL_1_REPLY_2 : in = _hessianFactory . createHessianInput ( is ) ; out = _hessianFactory . createHessian2Output ( os ) ; break ; case HESSIAN_2 : in = _hessianFactory . createHessian2Input ( is ) ; in . readCall ( ) ; out = _hessianFactory . createHessian2Output ( os ) ; break ; default : throw new IllegalStateException ( header + STRING ) ; } if ( serializerFactory != null ) { in . setSerializerFactory ( serializerFactory ) ; out . setSerializerFactory ( serializerFactory ) ; } try { invoke ( _service , in , out ) ; } finally { in . close ( ) ; out . close ( ) ; if ( isDebug ) os . close ( ) ; } }
public void invoke ( InputStream is , OutputStream os , SerializerFactory serializerFactory ) throws Exception { boolean isDebug = _BOOL ; if ( isDebugInvoke ( ) ) { isDebug = _BOOL ; PrintWriter dbg = createDebugPrintWriter ( ) ; HessianDebugInputStream dIs = new HessianDebugInputStream ( is , dbg ) ; dIs . startTop2 ( ) ; is = dIs ; HessianDebugOutputStream dOs = new HessianDebugOutputStream ( os , dbg ) ; dOs . startTop2 ( ) ; os = dOs ; } HessianInputFactory . HeaderType header = _inputFactory . readHeader ( is ) ; AbstractHessianInput in ; AbstractHessianOutput out ; switch ( header ) { case CALL_1_REPLY_1 : in = _hessianFactory . createHessianInput ( is ) ; out = _hessianFactory . createHessianOutput ( os ) ; break ; case CALL_1_REPLY_2 : in = _hessianFactory . createHessianInput ( is ) ; out = _hessianFactory . createHessian2Output ( os ) ; break ; case HESSIAN_2 : in = _hessianFactory . createHessian2Input ( is ) ; in . readCall ( ) ; out = _hessianFactory . createHessian2Output ( os ) ; break ; default : throw new IllegalStateException ( header + STRING ) ; } if ( serializerFactory != null ) { in . setSerializerFactory ( serializerFactory ) ; out . setSerializerFactory ( serializerFactory ) ; } try { invoke ( _service , in , out ) ; } finally { in . close ( ) ; out . close ( ) ; if ( isDebug ) os . close ( ) ; } }
private void flushRight ( ) throws IOException { appendNewlineIfNecessary ( rightBuf , rightColumn ) ; while ( rightBuf . length ( ) != _NUM ) { leftColumn . write ( STRING ) ; outputFullLines ( ) ; } }
private void flushRight ( ) throws IOException { appendNewlineIfNecessary ( rightBuf , rightColumn ) ; while ( rightBuf . length ( ) != _NUM ) { leftColumn . write ( STRING ) ; outputFullLines ( ) ; } }
private void flushRight ( ) throws IOException { appendNewlineIfNecessary ( rightBuf , rightColumn ) ; while ( rightBuf . length ( ) != _NUM ) { leftColumn . write ( STRING ) ; outputFullLines ( ) ; } }
private static void learn ( ) { int listSize = learningQueue . size ( ) ; for ( int i = _NUM ; i < listSize ; i ++ ) { Instance inst = learningQueue . poll ( ) ; if ( inst != null ) learner . trainOnInstance ( inst ) ; } }
public void expireLease ( String leaseId ) throws IllegalStateException { assignableVMs . expireLease ( leaseId ) ; }
public void expireLease ( String leaseId ) throws IllegalStateException { assignableVMs . expireLease ( leaseId ) ; }
public void expireLease ( String leaseId ) throws IllegalStateException { assignableVMs . expireLease ( leaseId ) ; }
public EventExpireThread ( ) { super ( STRING ) ; setDaemon ( _BOOL ) ; }
public static double computeMAD ( double [ ] x , double median ) { for ( int i = _NUM ; i < x . length ; i ++ ) { x [ i ] = Math . abs ( x [ i ] - median ) ; } double mad = QuickSelect . median ( x ) ; if ( ! ( mad > _NUM ) ) { double min = Double . POSITIVE_INFINITY ; for ( double xi : x ) { if ( xi > _NUM && xi < min ) { min = xi ; } } if ( min < Double . POSITIVE_INFINITY ) { mad = min ; } else { mad = _NUM ; } } return mad ; }
public String consumeContent ( boolean required ) throws ParseException { return consume ( null , required ) ; }
private void annotate ( StatementData sdata , String schema , String table , String operation ) { sdata . setOption ( ReplOptionParams . SCHEMA_NAME , schema ) ; if ( table != null ) sdata . setOption ( ReplOptionParams . TABLE_NAME , table ) ; sdata . setOption ( ReplOptionParams . OPERATION_NAME , operation ) ; }
public Builder server ( String server ) { if ( server . endsWith ( STRING ) == _BOOL ) { server = server + STRING ; } this . server = server ; return this ; }
public Builder server ( String server ) { if ( server . endsWith ( STRING ) == _BOOL ) { server = server + STRING ; } this . server = server ; return this ; }
public Builder server ( String server ) { if ( server . endsWith ( STRING ) == _BOOL ) { server = server + STRING ; } this . server = server ; return this ; }
public Builder server ( String server ) { if ( server . endsWith ( STRING ) == _BOOL ) { server = server + STRING ; } this . server = server ; return this ; }
public int indexOf ( final Artist a ) { synchronized ( mArtists ) { return mArtists . indexOf ( a ) ; } }
private boolean before ( long a , long b ) { return a < b ^ a - b > ( MAXIMUM_KEY / _NUM ) ; }
public DockNodeEventHandler ( Node node ) { this . node = node ; }
public DockNodeEventHandler ( Node node ) { this . node = node ; }
public DockNodeEventHandler ( Node node ) { this . node = node ; }
public DockNodeEventHandler ( Node node ) { this . node = node ; }
public DockNodeEventHandler ( Node node ) { this . node = node ; }
public int count ( ) { return incomplete_list . size ( ) ; }
protected char [ ] qname ( boolean ns ) throws Exception { mBuffIdx = - _NUM ; bname ( ns ) ; char chars [ ] = new char [ mBuffIdx + _NUM ] ; System . arraycopy ( mBuff , _NUM , chars , _NUM , mBuffIdx + _NUM ) ; return chars ; }
protected char [ ] qname ( boolean ns ) throws Exception { mBuffIdx = - _NUM ; bname ( ns ) ; char chars [ ] = new char [ mBuffIdx + _NUM ] ; System . arraycopy ( mBuff , _NUM , chars , _NUM , mBuffIdx + _NUM ) ; return chars ; }
protected char [ ] qname ( boolean ns ) throws Exception { mBuffIdx = - _NUM ; bname ( ns ) ; char chars [ ] = new char [ mBuffIdx + _NUM ] ; System . arraycopy ( mBuff , _NUM , chars , _NUM , mBuffIdx + _NUM ) ; return chars ; }
protected char [ ] qname ( boolean ns ) throws Exception { mBuffIdx = - _NUM ; bname ( ns ) ; char chars [ ] = new char [ mBuffIdx + _NUM ] ; System . arraycopy ( mBuff , _NUM , chars , _NUM , mBuffIdx + _NUM ) ; return chars ; }
protected char [ ] qname ( boolean ns ) throws Exception { mBuffIdx = - _NUM ; bname ( ns ) ; char chars [ ] = new char [ mBuffIdx + _NUM ] ; System . arraycopy ( mBuff , _NUM , chars , _NUM , mBuffIdx + _NUM ) ; return chars ; }
protected char [ ] qname ( boolean ns ) throws Exception { mBuffIdx = - _NUM ; bname ( ns ) ; char chars [ ] = new char [ mBuffIdx + _NUM ] ; System . arraycopy ( mBuff , _NUM , chars , _NUM , mBuffIdx + _NUM ) ; return chars ; }
protected char [ ] qname ( boolean ns ) throws Exception { mBuffIdx = - _NUM ; bname ( ns ) ; char chars [ ] = new char [ mBuffIdx + _NUM ] ; System . arraycopy ( mBuff , _NUM , chars , _NUM , mBuffIdx + _NUM ) ; return chars ; }
protected char [ ] qname ( boolean ns ) throws Exception { mBuffIdx = - _NUM ; bname ( ns ) ; char chars [ ] = new char [ mBuffIdx + _NUM ] ; System . arraycopy ( mBuff , _NUM , chars , _NUM , mBuffIdx + _NUM ) ; return chars ; }
@ Override public int hashCode ( ) { final int prime = _NUM ; int result = super . hashCode ( ) ; result = prime * result + ( tenant == null ? _NUM : tenant . hashCode ( ) ) ; return result ; }
@ Override public int hashCode ( ) { final int prime = _NUM ; int result = super . hashCode ( ) ; result = prime * result + ( tenant == null ? _NUM : tenant . hashCode ( ) ) ; return result ; }
@ Override public int hashCode ( ) { final int prime = _NUM ; int result = super . hashCode ( ) ; result = prime * result + ( tenant == null ? _NUM : tenant . hashCode ( ) ) ; return result ; }
@ Override public int hashCode ( ) { final int prime = _NUM ; int result = super . hashCode ( ) ; result = prime * result + ( tenant == null ? _NUM : tenant . hashCode ( ) ) ; return result ; }
@ Override public int hashCode ( ) { final int prime = _NUM ; int result = super . hashCode ( ) ; result = prime * result + ( tenant == null ? _NUM : tenant . hashCode ( ) ) ; return result ; }
@ Override public int hashCode ( ) { final int prime = _NUM ; int result = super . hashCode ( ) ; result = prime * result + ( tenant == null ? _NUM : tenant . hashCode ( ) ) ; return result ; }
private void keepAlive ( ) { Thread current = Thread . currentThread ( ) ; try { heartBeat ( ) ; while ( current == keepAliveThread ) { Thread . sleep ( HEART_BEAT ) ; heartBeat ( ) ; } } catch ( InterruptedException e ) { log . warn ( STRING , e ) ; } }
private void keepAlive ( ) { Thread current = Thread . currentThread ( ) ; try { heartBeat ( ) ; while ( current == keepAliveThread ) { Thread . sleep ( HEART_BEAT ) ; heartBeat ( ) ; } } catch ( InterruptedException e ) { log . warn ( STRING , e ) ; } }
private void keepAlive ( ) { Thread current = Thread . currentThread ( ) ; try { heartBeat ( ) ; while ( current == keepAliveThread ) { Thread . sleep ( HEART_BEAT ) ; heartBeat ( ) ; } } catch ( InterruptedException e ) { log . warn ( STRING , e ) ; } }
public boolean isQuestCompleted ( final String name ) { final String info = getQuest ( name , _NUM ) ; if ( info == null ) { return _BOOL ; } return info . equals ( STRING ) ; }
public boolean isQuestCompleted ( final String name ) { final String info = getQuest ( name , _NUM ) ; if ( info == null ) { return _BOOL ; } return info . equals ( STRING ) ; }
@ Nullable public V removeFirst ( ) { return vals . isEmpty ( ) ? null : vals . removeFirst ( ) ; }
public String write ( ) { StringBuilder result = new StringBuilder ( ) ; for ( Text t : this . components ) { result . append ( t ) ; } return result . toString ( ) ; }
public synchronized Boolean updateAVClientByStreamId ( String streamId , RoomClient rcm ) { try { RoomClient rclUsual = getClientByPublicSID ( rcm . getPublicSID ( ) , _BOOL ) ; if ( rclUsual != null ) { rclUsual . setBroadCastID ( rcm . getBroadCastID ( ) ) ; rclUsual . setAvsettings ( rcm . getAvsettings ( ) ) ; rclUsual . setVHeight ( rcm . getVHeight ( ) ) ; rclUsual . setVWidth ( rcm . getVWidth ( ) ) ; rclUsual . setVX ( rcm . getVX ( ) ) ; rclUsual . setVY ( rcm . getVY ( ) ) ; if ( clientList . containsKey ( rclUsual . getStreamid ( ) ) ) { clientList . put ( rclUsual . getStreamid ( ) , rclUsual ) ; } else { log . debug ( STRING + rclUsual . getStreamid ( ) ) ; } } updateClientByStreamId ( streamId , rcm ) ; } catch ( Exception err ) { log . error ( STRING , err ) ; } return null ; }
public synchronized Boolean updateAVClientByStreamId ( String streamId , RoomClient rcm ) { try { RoomClient rclUsual = getClientByPublicSID ( rcm . getPublicSID ( ) , _BOOL ) ; if ( rclUsual != null ) { rclUsual . setBroadCastID ( rcm . getBroadCastID ( ) ) ; rclUsual . setAvsettings ( rcm . getAvsettings ( ) ) ; rclUsual . setVHeight ( rcm . getVHeight ( ) ) ; rclUsual . setVWidth ( rcm . getVWidth ( ) ) ; rclUsual . setVX ( rcm . getVX ( ) ) ; rclUsual . setVY ( rcm . getVY ( ) ) ; if ( clientList . containsKey ( rclUsual . getStreamid ( ) ) ) { clientList . put ( rclUsual . getStreamid ( ) , rclUsual ) ; } else { log . debug ( STRING + rclUsual . getStreamid ( ) ) ; } } updateClientByStreamId ( streamId , rcm ) ; } catch ( Exception err ) { log . error ( STRING , err ) ; } return null ; }
public synchronized Boolean updateAVClientByStreamId ( String streamId , RoomClient rcm ) { try { RoomClient rclUsual = getClientByPublicSID ( rcm . getPublicSID ( ) , _BOOL ) ; if ( rclUsual != null ) { rclUsual . setBroadCastID ( rcm . getBroadCastID ( ) ) ; rclUsual . setAvsettings ( rcm . getAvsettings ( ) ) ; rclUsual . setVHeight ( rcm . getVHeight ( ) ) ; rclUsual . setVWidth ( rcm . getVWidth ( ) ) ; rclUsual . setVX ( rcm . getVX ( ) ) ; rclUsual . setVY ( rcm . getVY ( ) ) ; if ( clientList . containsKey ( rclUsual . getStreamid ( ) ) ) { clientList . put ( rclUsual . getStreamid ( ) , rclUsual ) ; } else { log . debug ( STRING + rclUsual . getStreamid ( ) ) ; } } updateClientByStreamId ( streamId , rcm ) ; } catch ( Exception err ) { log . error ( STRING , err ) ; } return null ; }
public synchronized Boolean updateAVClientByStreamId ( String streamId , RoomClient rcm ) { try { RoomClient rclUsual = getClientByPublicSID ( rcm . getPublicSID ( ) , _BOOL ) ; if ( rclUsual != null ) { rclUsual . setBroadCastID ( rcm . getBroadCastID ( ) ) ; rclUsual . setAvsettings ( rcm . getAvsettings ( ) ) ; rclUsual . setVHeight ( rcm . getVHeight ( ) ) ; rclUsual . setVWidth ( rcm . getVWidth ( ) ) ; rclUsual . setVX ( rcm . getVX ( ) ) ; rclUsual . setVY ( rcm . getVY ( ) ) ; if ( clientList . containsKey ( rclUsual . getStreamid ( ) ) ) { clientList . put ( rclUsual . getStreamid ( ) , rclUsual ) ; } else { log . debug ( STRING + rclUsual . getStreamid ( ) ) ; } } updateClientByStreamId ( streamId , rcm ) ; } catch ( Exception err ) { log . error ( STRING , err ) ; } return null ; }
@ Override public void handleClick ( int x , int y , PlotRenderingInfo info ) { }
@ Override public void handleClick ( int x , int y , PlotRenderingInfo info ) { }
public void addBlockOrder ( BlockOrder order ) { _savedOrders . add ( order ) ; }
protected void writeQualifiedName ( String nsAlias , String name ) throws IOException { if ( nsAlias != null && nsAlias . length ( ) > _NUM ) { writer . write ( nsAlias ) ; writer . write ( STRING ) ; } writer . write ( name ) ; }
public static DateTime toDateSimple ( String str , TimeZone timeZone ) throws PageException { DateTime dt = toDateSimple ( str , CONVERTING_TYPE_OFFSET , _BOOL , timeZone , null ) ; if ( dt == null ) throw new ExpressionException ( STRING + str + STRING ) ; return dt ; }
public static DateTime toDateSimple ( String str , TimeZone timeZone ) throws PageException { DateTime dt = toDateSimple ( str , CONVERTING_TYPE_OFFSET , _BOOL , timeZone , null ) ; if ( dt == null ) throw new ExpressionException ( STRING + str + STRING ) ; return dt ; }
public void addInvoiceFact ( MFactAcct fact ) { m_facts . add ( fact ) ; }
void removeSession ( GSSessionImpl childSession ) { synchronized ( this ) { sessions . remove ( childSession ) ; childSession = null ; } }
protected List < Item > toItems ( List < Model > models ) { if ( models == null ) { return Collections . emptyList ( ) ; } int size = models . size ( ) ; List < Item > items = new ArrayList < > ( size ) ; for ( int i = _NUM ; i < size ; i ++ ) { items . add ( toItem ( models . get ( i ) ) ) ; } return items ; }
protected List < Item > toItems ( List < Model > models ) { if ( models == null ) { return Collections . emptyList ( ) ; } int size = models . size ( ) ; List < Item > items = new ArrayList < > ( size ) ; for ( int i = _NUM ; i < size ; i ++ ) { items . add ( toItem ( models . get ( i ) ) ) ; } return items ; }
public boolean isEmpty ( ) { return getItemCount ( ) == _NUM ; }
public static void generateListOfModules ( StringBuilder builder ) { Iterator < String > entryIterator = EXTENSIONS_FQN . iterator ( ) ; while ( entryIterator . hasNext ( ) ) { String ginModuleFQN = entryIterator . next ( ) ; String hasComma = entryIterator . hasNext ( ) ? STRING : STRING ; builder . append ( GeneratorUtils . TAB + ginModuleFQN + STRING + hasComma + STRING ) ; } }
public static boolean different ( GenericRecord first , GenericRecord second , List < String > valueFieldNames ) { for ( String valueFieldName : valueFieldNames ) { Object firstValue = first . get ( valueFieldName ) ; Object secondValue = second . get ( valueFieldName ) ; if ( firstValue != null && secondValue != null && ! firstValue . equals ( secondValue ) ) { return _BOOL ; } if ( ( firstValue != null && secondValue == null ) || ( firstValue == null && secondValue != null ) ) { return _BOOL ; } } return _BOOL ; }
public static boolean different ( GenericRecord first , GenericRecord second , List < String > valueFieldNames ) { for ( String valueFieldName : valueFieldNames ) { Object firstValue = first . get ( valueFieldName ) ; Object secondValue = second . get ( valueFieldName ) ; if ( firstValue != null && secondValue != null && ! firstValue . equals ( secondValue ) ) { return _BOOL ; } if ( ( firstValue != null && secondValue == null ) || ( firstValue == null && secondValue != null ) ) { return _BOOL ; } } return _BOOL ; }
public void dispose ( ) { logDebug ( STRING ) ; mSetupDone = _BOOL ; if ( mServiceConn != null ) { logDebug ( STRING ) ; if ( mContext != null && mIsBound ) { mContext . unbindService ( mServiceConn ) ; } } mDisposed = _BOOL ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
public void dispose ( ) { logDebug ( STRING ) ; mSetupDone = _BOOL ; if ( mServiceConn != null ) { logDebug ( STRING ) ; if ( mContext != null && mIsBound ) { mContext . unbindService ( mServiceConn ) ; } } mDisposed = _BOOL ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
public void dispose ( ) { logDebug ( STRING ) ; mSetupDone = _BOOL ; if ( mServiceConn != null ) { logDebug ( STRING ) ; if ( mContext != null && mIsBound ) { mContext . unbindService ( mServiceConn ) ; } } mDisposed = _BOOL ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
public void dispose ( ) { logDebug ( STRING ) ; mSetupDone = _BOOL ; if ( mServiceConn != null ) { logDebug ( STRING ) ; if ( mContext != null && mIsBound ) { mContext . unbindService ( mServiceConn ) ; } } mDisposed = _BOOL ; mContext = null ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; }
public KeyUsageExtension ( ) { extensionId = PKIXExtensions . KeyUsage_Id ; critical = _BOOL ; bitString = new boolean [ _NUM ] ; }
@ Override protected void ensureNumberOfColumns ( int numberOfColumns ) { if ( data . length >= numberOfColumns ) { return ; } int [ ] newData = new int [ numberOfColumns ] ; System . arraycopy ( data , _NUM , newData , _NUM , data . length ) ; data = newData ; }
@ Override protected void ensureNumberOfColumns ( int numberOfColumns ) { if ( data . length >= numberOfColumns ) { return ; } int [ ] newData = new int [ numberOfColumns ] ; System . arraycopy ( data , _NUM , newData , _NUM , data . length ) ; data = newData ; }
public LibUsbException ( final String message , final int errorCode ) { super ( String . format ( STRING , - errorCode , message , LibUsb . strError ( errorCode ) ) ) ; this . errorCode = errorCode ; }
public LibUsbException ( final String message , final int errorCode ) { super ( String . format ( STRING , - errorCode , message , LibUsb . strError ( errorCode ) ) ) ; this . errorCode = errorCode ; }
public LibUsbException ( final String message , final int errorCode ) { super ( String . format ( STRING , - errorCode , message , LibUsb . strError ( errorCode ) ) ) ; this . errorCode = errorCode ; }
protected Object readObjectOverride ( ) throws OptionalDataException , ClassNotFoundException , IOException { if ( input == null ) { return null ; } throw new IOException ( ) ; }
private static InputStream nullInputStream ( ) throws NullPointerException { if ( currentTimeMillis ( ) > _NUM ) { return null ; } throw new NullPointerException ( ) ; }
private static InputStream nullInputStream ( ) throws NullPointerException { if ( currentTimeMillis ( ) > _NUM ) { return null ; } throw new NullPointerException ( ) ; }
@ SideEffectFree protected void printBound ( final String keyWord , final AnnotatedTypeMirror field , final Set < AnnotatedTypeMirror > visiting , final StringBuilder sb ) { if ( ! currentPrintVerboseGenerics && ( field == null || field . getKind ( ) == TypeKind . NULL ) ) { return ; } sb . append ( STRING ) ; sb . append ( keyWord ) ; sb . append ( STRING ) ; if ( field == null ) { sb . append ( STRING ) ; } else if ( field . getKind ( ) != TypeKind . NULL ) { sb . append ( visit ( field , visiting ) ) ; } else { sb . append ( annoFormatter . formatAnnotationString ( field . getAnnotations ( ) , currentPrintInvisibleSetting ) ) ; sb . append ( STRING ) ; } }
@ SideEffectFree protected void printBound ( final String keyWord , final AnnotatedTypeMirror field , final Set < AnnotatedTypeMirror > visiting , final StringBuilder sb ) { if ( ! currentPrintVerboseGenerics && ( field == null || field . getKind ( ) == TypeKind . NULL ) ) { return ; } sb . append ( STRING ) ; sb . append ( keyWord ) ; sb . append ( STRING ) ; if ( field == null ) { sb . append ( STRING ) ; } else if ( field . getKind ( ) != TypeKind . NULL ) { sb . append ( visit ( field , visiting ) ) ; } else { sb . append ( annoFormatter . formatAnnotationString ( field . getAnnotations ( ) , currentPrintInvisibleSetting ) ) ; sb . append ( STRING ) ; } }
public void notifyFailed ( Throwable exception ) throws RuntimeException { exec . shutdownNow ( ) ; LOGGER . error ( exception ) ; throw new RuntimeException ( exception ) ; }
public void loadArgs ( final int arg , final int count ) { int index = getArgIndex ( arg ) ; for ( int i = _NUM ; i < count ; ++ i ) { Type t = argumentTypes [ arg + i ] ; loadInsn ( t , index ) ; index += t . getSize ( ) ; } }
public void loadArgs ( final int arg , final int count ) { int index = getArgIndex ( arg ) ; for ( int i = _NUM ; i < count ; ++ i ) { Type t = argumentTypes [ arg + i ] ; loadInsn ( t , index ) ; index += t . getSize ( ) ; } }
public void loadArgs ( final int arg , final int count ) { int index = getArgIndex ( arg ) ; for ( int i = _NUM ; i < count ; ++ i ) { Type t = argumentTypes [ arg + i ] ; loadInsn ( t , index ) ; index += t . getSize ( ) ; } }
public boolean equals ( Object object ) { if ( this == object ) { return _BOOL ; } else if ( object == null || getClass ( ) != object . getClass ( ) ) { return _BOOL ; } return SSOSessionID . equals ( object ) ; }
public boolean equals ( Object object ) { if ( this == object ) { return _BOOL ; } else if ( object == null || getClass ( ) != object . getClass ( ) ) { return _BOOL ; } return SSOSessionID . equals ( object ) ; }
public boolean equals ( Object object ) { if ( this == object ) { return _BOOL ; } else if ( object == null || getClass ( ) != object . getClass ( ) ) { return _BOOL ; } return SSOSessionID . equals ( object ) ; }
protected void encodeAtom ( OutputStream outStream , byte data [ ] , int offset , int len ) throws IOException { byte a , b = _NUM , c = _NUM ; int c1 , c2 , c3 , c4 ; a = data [ offset ] ; if ( len > _NUM ) { b = data [ offset + _NUM ] ; } if ( len > _NUM ) { c = data [ offset + _NUM ] ; } c1 = ( a > > > _NUM ) & _NUM ; c2 = ( ( a << _NUM ) & _NUM ) | ( ( b > > > _NUM ) & _NUM ) ; c3 = ( ( b << _NUM ) & _NUM ) | ( ( c > > > _NUM ) & _NUM ) ; c4 = c & _NUM ; outStream . write ( c1 + STRING ) ; outStream . write ( c2 + STRING ) ; outStream . write ( c3 + STRING ) ; outStream . write ( c4 + STRING ) ; return ; }
private List < FacetResult > facetsWithSearch ( ) throws IOException { DirectoryReader indexReader = DirectoryReader . open ( indexDir ) ; IndexSearcher searcher = new IndexSearcher ( indexReader ) ; TaxonomyReader taxoReader = new DirectoryTaxonomyReader ( taxoDir ) ; FacetsCollector fc = new FacetsCollector ( ) ; FacetsCollector . search ( searcher , new MatchAllDocsQuery ( ) , _NUM , fc ) ; List < FacetResult > results = new ArrayList < > ( ) ; Facets facets = new FastTaxonomyFacetCounts ( taxoReader , config , fc ) ; results . add ( facets . getTopChildren ( _NUM , STRING ) ) ; results . add ( facets . getTopChildren ( _NUM , STRING ) ) ; indexReader . close ( ) ; taxoReader . close ( ) ; return results ; }
private List < FacetResult > facetsWithSearch ( ) throws IOException { DirectoryReader indexReader = DirectoryReader . open ( indexDir ) ; IndexSearcher searcher = new IndexSearcher ( indexReader ) ; TaxonomyReader taxoReader = new DirectoryTaxonomyReader ( taxoDir ) ; FacetsCollector fc = new FacetsCollector ( ) ; FacetsCollector . search ( searcher , new MatchAllDocsQuery ( ) , _NUM , fc ) ; List < FacetResult > results = new ArrayList < > ( ) ; Facets facets = new FastTaxonomyFacetCounts ( taxoReader , config , fc ) ; results . add ( facets . getTopChildren ( _NUM , STRING ) ) ; results . add ( facets . getTopChildren ( _NUM , STRING ) ) ; indexReader . close ( ) ; taxoReader . close ( ) ; return results ; }
private static void serialize ( DataOutputStream out , MethodGroup [ ] methods ) throws IOException { out . writeInt ( SNAPSHOT_MAGIC ) ; out . writeInt ( SNAPSHOT_PROTOCOL_VERSION ) ; out . writeInt ( SNAPSHOT_TYPE_CALLTRACE ) ; out . writeInt ( sessionId ) ; out . writeLong ( System . currentTimeMillis ( ) ) ; int n = _NUM ; for ( MethodGroup m : methods ) { if ( m . hits > _NUM ) { n ++ ; } } Log . print ( _NUM , STRING + n + STRING ) ; out . writeInt ( n ) ; for ( MethodGroup m : methods ) { if ( m . hits == _NUM ) { continue ; } out . writeInt ( m . globalId & _NUM ) ; out . writeUTF ( m . name ) ; out . writeInt ( m . hits ) ; out . writeLong ( m . netTime ) ; out . writeLong ( m . selfTime ) ; out . writeInt ( m . childCount ) ; for ( int i = _NUM ; i < m . childCount ; i ++ ) { out . writeInt ( m . children [ i ] . globalId & _NUM ) ; out . writeLong ( m . childrenTimes [ i ] ) ; } } }
public ConnectionManagerService ( ) { this ( new ConnectionInfo ( ) ) ; }
public synchronized void load ( ) throws Exception { load ( getConfFileName ( ) ) ; }
private static void writeStringToOutput ( String str , DataOutput out ) throws IOException { out . writeInt ( str . length ( ) ) ; out . writeChars ( str ) ; }
public static int indexOf ( @ NotNull CharSequence buffer , @ NotNull CharSequence pattern , int fromIndex , final int toIndex ) { final int patternLength = pattern . length ( ) ; int limit = toIndex - patternLength + _NUM ; if ( fromIndex < _NUM ) { fromIndex = _NUM ; } SearchLoop : for ( int i = fromIndex ; i < limit ; i ++ ) { for ( int j = _NUM ; j < patternLength ; j ++ ) { if ( pattern . charAt ( j ) != buffer . charAt ( i + j ) ) continue SearchLoop ; } return i ; } return - _NUM ; }
public static int indexOf ( @ NotNull CharSequence buffer , @ NotNull CharSequence pattern , int fromIndex , final int toIndex ) { final int patternLength = pattern . length ( ) ; int limit = toIndex - patternLength + _NUM ; if ( fromIndex < _NUM ) { fromIndex = _NUM ; } SearchLoop : for ( int i = fromIndex ; i < limit ; i ++ ) { for ( int j = _NUM ; j < patternLength ; j ++ ) { if ( pattern . charAt ( j ) != buffer . charAt ( i + j ) ) continue SearchLoop ; } return i ; } return - _NUM ; }
void commit ( ) { for ( MyProperty < ? > p : properties . values ( ) ) { p . commit ( ) ; } }
protected final PermitStatus permitStatus ( ) { if ( permits . get ( ) > _NUM ) return PermitStatus . MAYBE_MORE ; else return unlimited ? PermitStatus . UNLIMITED : PermitStatus . NO_MORE ; }
public static InetAddress longToIp ( long ip ) { try { return InetAddress . getByAddress ( longToNetworkByteOrderArray ( ip ) ) ; } catch ( UnknownHostException e ) { throw new IllegalArgumentException ( STRING + ip ) ; } }
public static InetAddress longToIp ( long ip ) { try { return InetAddress . getByAddress ( longToNetworkByteOrderArray ( ip ) ) ; } catch ( UnknownHostException e ) { throw new IllegalArgumentException ( STRING + ip ) ; } }
public static InetAddress longToIp ( long ip ) { try { return InetAddress . getByAddress ( longToNetworkByteOrderArray ( ip ) ) ; } catch ( UnknownHostException e ) { throw new IllegalArgumentException ( STRING + ip ) ; } }
public void expand ( int level ) { ArrayList < S2CellId > output = new ArrayList < S2CellId > ( ) ; long levelLsb = S2CellId . lowestOnBitForLevel ( level ) ; int i = size ( ) - _NUM ; do { S2CellId id = cellId ( i ) ; if ( id . lowestOnBit ( ) < levelLsb ) { id = id . parent ( level ) ; while ( i > _NUM && id . contains ( cellId ( i - _NUM ) ) ) { -- i ; } } output . add ( id ) ; id . getAllNeighbors ( level , output ) ; } while ( -- i >= _NUM ) ; initSwap ( output ) ; }
public void expand ( int level ) { ArrayList < S2CellId > output = new ArrayList < S2CellId > ( ) ; long levelLsb = S2CellId . lowestOnBitForLevel ( level ) ; int i = size ( ) - _NUM ; do { S2CellId id = cellId ( i ) ; if ( id . lowestOnBit ( ) < levelLsb ) { id = id . parent ( level ) ; while ( i > _NUM && id . contains ( cellId ( i - _NUM ) ) ) { -- i ; } } output . add ( id ) ; id . getAllNeighbors ( level , output ) ; } while ( -- i >= _NUM ) ; initSwap ( output ) ; }
public void expand ( int level ) { ArrayList < S2CellId > output = new ArrayList < S2CellId > ( ) ; long levelLsb = S2CellId . lowestOnBitForLevel ( level ) ; int i = size ( ) - _NUM ; do { S2CellId id = cellId ( i ) ; if ( id . lowestOnBit ( ) < levelLsb ) { id = id . parent ( level ) ; while ( i > _NUM && id . contains ( cellId ( i - _NUM ) ) ) { -- i ; } } output . add ( id ) ; id . getAllNeighbors ( level , output ) ; } while ( -- i >= _NUM ) ; initSwap ( output ) ; }
public void expand ( int level ) { ArrayList < S2CellId > output = new ArrayList < S2CellId > ( ) ; long levelLsb = S2CellId . lowestOnBitForLevel ( level ) ; int i = size ( ) - _NUM ; do { S2CellId id = cellId ( i ) ; if ( id . lowestOnBit ( ) < levelLsb ) { id = id . parent ( level ) ; while ( i > _NUM && id . contains ( cellId ( i - _NUM ) ) ) { -- i ; } } output . add ( id ) ; id . getAllNeighbors ( level , output ) ; } while ( -- i >= _NUM ) ; initSwap ( output ) ; }
public void expand ( int level ) { ArrayList < S2CellId > output = new ArrayList < S2CellId > ( ) ; long levelLsb = S2CellId . lowestOnBitForLevel ( level ) ; int i = size ( ) - _NUM ; do { S2CellId id = cellId ( i ) ; if ( id . lowestOnBit ( ) < levelLsb ) { id = id . parent ( level ) ; while ( i > _NUM && id . contains ( cellId ( i - _NUM ) ) ) { -- i ; } } output . add ( id ) ; id . getAllNeighbors ( level , output ) ; } while ( -- i >= _NUM ) ; initSwap ( output ) ; }
public void expand ( int level ) { ArrayList < S2CellId > output = new ArrayList < S2CellId > ( ) ; long levelLsb = S2CellId . lowestOnBitForLevel ( level ) ; int i = size ( ) - _NUM ; do { S2CellId id = cellId ( i ) ; if ( id . lowestOnBit ( ) < levelLsb ) { id = id . parent ( level ) ; while ( i > _NUM && id . contains ( cellId ( i - _NUM ) ) ) { -- i ; } } output . add ( id ) ; id . getAllNeighbors ( level , output ) ; } while ( -- i >= _NUM ) ; initSwap ( output ) ; }
public void expand ( int level ) { ArrayList < S2CellId > output = new ArrayList < S2CellId > ( ) ; long levelLsb = S2CellId . lowestOnBitForLevel ( level ) ; int i = size ( ) - _NUM ; do { S2CellId id = cellId ( i ) ; if ( id . lowestOnBit ( ) < levelLsb ) { id = id . parent ( level ) ; while ( i > _NUM && id . contains ( cellId ( i - _NUM ) ) ) { -- i ; } } output . add ( id ) ; id . getAllNeighbors ( level , output ) ; } while ( -- i >= _NUM ) ; initSwap ( output ) ; }
public void expand ( int level ) { ArrayList < S2CellId > output = new ArrayList < S2CellId > ( ) ; long levelLsb = S2CellId . lowestOnBitForLevel ( level ) ; int i = size ( ) - _NUM ; do { S2CellId id = cellId ( i ) ; if ( id . lowestOnBit ( ) < levelLsb ) { id = id . parent ( level ) ; while ( i > _NUM && id . contains ( cellId ( i - _NUM ) ) ) { -- i ; } } output . add ( id ) ; id . getAllNeighbors ( level , output ) ; } while ( -- i >= _NUM ) ; initSwap ( output ) ; }
public void expand ( int level ) { ArrayList < S2CellId > output = new ArrayList < S2CellId > ( ) ; long levelLsb = S2CellId . lowestOnBitForLevel ( level ) ; int i = size ( ) - _NUM ; do { S2CellId id = cellId ( i ) ; if ( id . lowestOnBit ( ) < levelLsb ) { id = id . parent ( level ) ; while ( i > _NUM && id . contains ( cellId ( i - _NUM ) ) ) { -- i ; } } output . add ( id ) ; id . getAllNeighbors ( level , output ) ; } while ( -- i >= _NUM ) ; initSwap ( output ) ; }
public void expand ( int level ) { ArrayList < S2CellId > output = new ArrayList < S2CellId > ( ) ; long levelLsb = S2CellId . lowestOnBitForLevel ( level ) ; int i = size ( ) - _NUM ; do { S2CellId id = cellId ( i ) ; if ( id . lowestOnBit ( ) < levelLsb ) { id = id . parent ( level ) ; while ( i > _NUM && id . contains ( cellId ( i - _NUM ) ) ) { -- i ; } } output . add ( id ) ; id . getAllNeighbors ( level , output ) ; } while ( -- i >= _NUM ) ; initSwap ( output ) ; }
public void expand ( int level ) { ArrayList < S2CellId > output = new ArrayList < S2CellId > ( ) ; long levelLsb = S2CellId . lowestOnBitForLevel ( level ) ; int i = size ( ) - _NUM ; do { S2CellId id = cellId ( i ) ; if ( id . lowestOnBit ( ) < levelLsb ) { id = id . parent ( level ) ; while ( i > _NUM && id . contains ( cellId ( i - _NUM ) ) ) { -- i ; } } output . add ( id ) ; id . getAllNeighbors ( level , output ) ; } while ( -- i >= _NUM ) ; initSwap ( output ) ; }
public void expand ( int level ) { ArrayList < S2CellId > output = new ArrayList < S2CellId > ( ) ; long levelLsb = S2CellId . lowestOnBitForLevel ( level ) ; int i = size ( ) - _NUM ; do { S2CellId id = cellId ( i ) ; if ( id . lowestOnBit ( ) < levelLsb ) { id = id . parent ( level ) ; while ( i > _NUM && id . contains ( cellId ( i - _NUM ) ) ) { -- i ; } } output . add ( id ) ; id . getAllNeighbors ( level , output ) ; } while ( -- i >= _NUM ) ; initSwap ( output ) ; }
public void expand ( int level ) { ArrayList < S2CellId > output = new ArrayList < S2CellId > ( ) ; long levelLsb = S2CellId . lowestOnBitForLevel ( level ) ; int i = size ( ) - _NUM ; do { S2CellId id = cellId ( i ) ; if ( id . lowestOnBit ( ) < levelLsb ) { id = id . parent ( level ) ; while ( i > _NUM && id . contains ( cellId ( i - _NUM ) ) ) { -- i ; } } output . add ( id ) ; id . getAllNeighbors ( level , output ) ; } while ( -- i >= _NUM ) ; initSwap ( output ) ; }
public void expand ( int level ) { ArrayList < S2CellId > output = new ArrayList < S2CellId > ( ) ; long levelLsb = S2CellId . lowestOnBitForLevel ( level ) ; int i = size ( ) - _NUM ; do { S2CellId id = cellId ( i ) ; if ( id . lowestOnBit ( ) < levelLsb ) { id = id . parent ( level ) ; while ( i > _NUM && id . contains ( cellId ( i - _NUM ) ) ) { -- i ; } } output . add ( id ) ; id . getAllNeighbors ( level , output ) ; } while ( -- i >= _NUM ) ; initSwap ( output ) ; }
private String excludeDestinationStatement ( String text ) { int idx = - _NUM ; if ( ( idx = text . indexOf ( STRING ) ) != - _NUM ) { text = text . substring ( _NUM , idx ) ; } return text ; }
private String excludeDestinationStatement ( String text ) { int idx = - _NUM ; if ( ( idx = text . indexOf ( STRING ) ) != - _NUM ) { text = text . substring ( _NUM , idx ) ; } return text ; }
private String excludeDestinationStatement ( String text ) { int idx = - _NUM ; if ( ( idx = text . indexOf ( STRING ) ) != - _NUM ) { text = text . substring ( _NUM , idx ) ; } return text ; }
private String excludeDestinationStatement ( String text ) { int idx = - _NUM ; if ( ( idx = text . indexOf ( STRING ) ) != - _NUM ) { text = text . substring ( _NUM , idx ) ; } return text ; }
private String excludeDestinationStatement ( String text ) { int idx = - _NUM ; if ( ( idx = text . indexOf ( STRING ) ) != - _NUM ) { text = text . substring ( _NUM , idx ) ; } return text ; }
private String excludeDestinationStatement ( String text ) { int idx = - _NUM ; if ( ( idx = text . indexOf ( STRING ) ) != - _NUM ) { text = text . substring ( _NUM , idx ) ; } return text ; }
private String excludeDestinationStatement ( String text ) { int idx = - _NUM ; if ( ( idx = text . indexOf ( STRING ) ) != - _NUM ) { text = text . substring ( _NUM , idx ) ; } return text ; }
private String excludeDestinationStatement ( String text ) { int idx = - _NUM ; if ( ( idx = text . indexOf ( STRING ) ) != - _NUM ) { text = text . substring ( _NUM , idx ) ; } return text ; }
private String excludeDestinationStatement ( String text ) { int idx = - _NUM ; if ( ( idx = text . indexOf ( STRING ) ) != - _NUM ) { text = text . substring ( _NUM , idx ) ; } return text ; }
private String excludeDestinationStatement ( String text ) { int idx = - _NUM ; if ( ( idx = text . indexOf ( STRING ) ) != - _NUM ) { text = text . substring ( _NUM , idx ) ; } return text ; }
private String excludeDestinationStatement ( String text ) { int idx = - _NUM ; if ( ( idx = text . indexOf ( STRING ) ) != - _NUM ) { text = text . substring ( _NUM , idx ) ; } return text ; }
private String excludeDestinationStatement ( String text ) { int idx = - _NUM ; if ( ( idx = text . indexOf ( STRING ) ) != - _NUM ) { text = text . substring ( _NUM , idx ) ; } return text ; }
private String excludeDestinationStatement ( String text ) { int idx = - _NUM ; if ( ( idx = text . indexOf ( STRING ) ) != - _NUM ) { text = text . substring ( _NUM , idx ) ; } return text ; }
private String excludeDestinationStatement ( String text ) { int idx = - _NUM ; if ( ( idx = text . indexOf ( STRING ) ) != - _NUM ) { text = text . substring ( _NUM , idx ) ; } return text ; }
private String excludeDestinationStatement ( String text ) { int idx = - _NUM ; if ( ( idx = text . indexOf ( STRING ) ) != - _NUM ) { text = text . substring ( _NUM , idx ) ; } return text ; }
private String appendNationalNumber ( String nationalNumber ) { int prefixBeforeNationalNumberLength = prefixBeforeNationalNumber . length ( ) ; if ( shouldAddSpaceAfterNationalPrefix && prefixBeforeNationalNumberLength > _NUM && prefixBeforeNationalNumber . charAt ( prefixBeforeNationalNumberLength - _NUM ) != SEPARATOR_BEFORE_NATIONAL_NUMBER ) { return new String ( prefixBeforeNationalNumber ) + SEPARATOR_BEFORE_NATIONAL_NUMBER + nationalNumber ; } else { return prefixBeforeNationalNumber + nationalNumber ; } }
private String appendNationalNumber ( String nationalNumber ) { int prefixBeforeNationalNumberLength = prefixBeforeNationalNumber . length ( ) ; if ( shouldAddSpaceAfterNationalPrefix && prefixBeforeNationalNumberLength > _NUM && prefixBeforeNationalNumber . charAt ( prefixBeforeNationalNumberLength - _NUM ) != SEPARATOR_BEFORE_NATIONAL_NUMBER ) { return new String ( prefixBeforeNationalNumber ) + SEPARATOR_BEFORE_NATIONAL_NUMBER + nationalNumber ; } else { return prefixBeforeNationalNumber + nationalNumber ; } }
private void createLocaleEntry ( String val ) { StringTokenizer tok1 = new StringTokenizer ( val , STRING ) ; String localeValue = null ; LinkedList charsetList = null ; while ( tok1 . hasMoreElements ( ) ) { String element = tok1 . nextToken ( ) ; StringTokenizer pairTok = new StringTokenizer ( element , STRING ) ; if ( pairTok . countTokens ( ) == _NUM ) { String key = pairTok . nextToken ( ) ; key = key . trim ( ) ; String value = pairTok . nextToken ( ) ; if ( key . equalsIgnoreCase ( STRING ) ) { localeValue = value . toLowerCase ( ) ; } int charsetCount = _NUM ; if ( key . equalsIgnoreCase ( STRING ) ) { charsetList = new LinkedList ( ) ; StringTokenizer charsetTokenizer = new StringTokenizer ( value , STRING ) ; while ( charsetTokenizer . hasMoreElements ( ) ) { String charsetVal = charsetTokenizer . nextToken ( ) ; charsetList . add ( charsetVal ) ; charsetCount ++ ; } } } } if ( charsetList != null && localeValue != null ) { localeCharset . put ( localeValue , charsetList ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STRING + localeValue + STRING + charsetList ) ; } } }
private void createLocaleEntry ( String val ) { StringTokenizer tok1 = new StringTokenizer ( val , STRING ) ; String localeValue = null ; LinkedList charsetList = null ; while ( tok1 . hasMoreElements ( ) ) { String element = tok1 . nextToken ( ) ; StringTokenizer pairTok = new StringTokenizer ( element , STRING ) ; if ( pairTok . countTokens ( ) == _NUM ) { String key = pairTok . nextToken ( ) ; key = key . trim ( ) ; String value = pairTok . nextToken ( ) ; if ( key . equalsIgnoreCase ( STRING ) ) { localeValue = value . toLowerCase ( ) ; } int charsetCount = _NUM ; if ( key . equalsIgnoreCase ( STRING ) ) { charsetList = new LinkedList ( ) ; StringTokenizer charsetTokenizer = new StringTokenizer ( value , STRING ) ; while ( charsetTokenizer . hasMoreElements ( ) ) { String charsetVal = charsetTokenizer . nextToken ( ) ; charsetList . add ( charsetVal ) ; charsetCount ++ ; } } } } if ( charsetList != null && localeValue != null ) { localeCharset . put ( localeValue , charsetList ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STRING + localeValue + STRING + charsetList ) ; } } }
private void createLocaleEntry ( String val ) { StringTokenizer tok1 = new StringTokenizer ( val , STRING ) ; String localeValue = null ; LinkedList charsetList = null ; while ( tok1 . hasMoreElements ( ) ) { String element = tok1 . nextToken ( ) ; StringTokenizer pairTok = new StringTokenizer ( element , STRING ) ; if ( pairTok . countTokens ( ) == _NUM ) { String key = pairTok . nextToken ( ) ; key = key . trim ( ) ; String value = pairTok . nextToken ( ) ; if ( key . equalsIgnoreCase ( STRING ) ) { localeValue = value . toLowerCase ( ) ; } int charsetCount = _NUM ; if ( key . equalsIgnoreCase ( STRING ) ) { charsetList = new LinkedList ( ) ; StringTokenizer charsetTokenizer = new StringTokenizer ( value , STRING ) ; while ( charsetTokenizer . hasMoreElements ( ) ) { String charsetVal = charsetTokenizer . nextToken ( ) ; charsetList . add ( charsetVal ) ; charsetCount ++ ; } } } } if ( charsetList != null && localeValue != null ) { localeCharset . put ( localeValue , charsetList ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STRING + localeValue + STRING + charsetList ) ; } } }
private void createLocaleEntry ( String val ) { StringTokenizer tok1 = new StringTokenizer ( val , STRING ) ; String localeValue = null ; LinkedList charsetList = null ; while ( tok1 . hasMoreElements ( ) ) { String element = tok1 . nextToken ( ) ; StringTokenizer pairTok = new StringTokenizer ( element , STRING ) ; if ( pairTok . countTokens ( ) == _NUM ) { String key = pairTok . nextToken ( ) ; key = key . trim ( ) ; String value = pairTok . nextToken ( ) ; if ( key . equalsIgnoreCase ( STRING ) ) { localeValue = value . toLowerCase ( ) ; } int charsetCount = _NUM ; if ( key . equalsIgnoreCase ( STRING ) ) { charsetList = new LinkedList ( ) ; StringTokenizer charsetTokenizer = new StringTokenizer ( value , STRING ) ; while ( charsetTokenizer . hasMoreElements ( ) ) { String charsetVal = charsetTokenizer . nextToken ( ) ; charsetList . add ( charsetVal ) ; charsetCount ++ ; } } } } if ( charsetList != null && localeValue != null ) { localeCharset . put ( localeValue , charsetList ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STRING + localeValue + STRING + charsetList ) ; } } }
private void validateBusinessObjectFormatDdlCollectionRequest ( BusinessObjectFormatDdlCollectionRequest businessObjectFormatDdlCollectionRequest ) { Assert . notNull ( businessObjectFormatDdlCollectionRequest , STRING ) ; Assert . isTrue ( ! CollectionUtils . isEmpty ( businessObjectFormatDdlCollectionRequest . getBusinessObjectFormatDdlRequests ( ) ) , STRING ) ; for ( BusinessObjectFormatDdlRequest request : businessObjectFormatDdlCollectionRequest . getBusinessObjectFormatDdlRequests ( ) ) { validateBusinessObjectFormatDdlRequest ( request ) ; } }
private void validateBusinessObjectFormatDdlCollectionRequest ( BusinessObjectFormatDdlCollectionRequest businessObjectFormatDdlCollectionRequest ) { Assert . notNull ( businessObjectFormatDdlCollectionRequest , STRING ) ; Assert . isTrue ( ! CollectionUtils . isEmpty ( businessObjectFormatDdlCollectionRequest . getBusinessObjectFormatDdlRequests ( ) ) , STRING ) ; for ( BusinessObjectFormatDdlRequest request : businessObjectFormatDdlCollectionRequest . getBusinessObjectFormatDdlRequests ( ) ) { validateBusinessObjectFormatDdlRequest ( request ) ; } }
public boolean isReturnBlock ( BasicBlock block ) { return returnBlockSet . get ( block . getLabel ( ) ) ; }
@ Override public boolean connectionAllowed ( String eventName ) { return eventName . equals ( STRING ) || eventName . equals ( STRING ) ; }
@ Override public boolean connectionAllowed ( String eventName ) { return eventName . equals ( STRING ) || eventName . equals ( STRING ) ; }
@ Override public boolean connectionAllowed ( String eventName ) { return eventName . equals ( STRING ) || eventName . equals ( STRING ) ; }
@ Override public boolean connectionAllowed ( String eventName ) { return eventName . equals ( STRING ) || eventName . equals ( STRING ) ; }
public void close ( ) throws IOException { writer . close ( ) ; }
protected Button createOpenButton ( ) { Button ob = new Button ( ) ; ob . setUIID ( STRING ) ; UIManager uim = parent . getUIManager ( ) ; Image i = ( Image ) uim . getThemeImageConstant ( STRING ) ; if ( i != null ) { ob . setIcon ( i ) ; } else { float size = _NUM ; try { size = Float . parseFloat ( uim . getThemeConstant ( STRING , STRING ) ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; } FontImage . setMaterialIcon ( ob , FontImage . MATERIAL_MENU , size ) ; } Image p = ( Image ) uim . getThemeImageConstant ( STRING ) ; if ( p != null ) { ob . setPressedIcon ( p ) ; } return ob ; }
private Class < ? > readNewProxyClassDesc ( ) throws ClassNotFoundException , IOException { int count = input . readInt ( ) ; String [ ] interfaceNames = new String [ count ] ; for ( int i = _NUM ; i < count ; i ++ ) { interfaceNames [ i ] = input . readUTF ( ) ; } Class < ? > proxy = resolveProxyClass ( interfaceNames ) ; discardData ( ) ; return proxy ; }
public static boolean isCraftingSkill ( int skillId ) { Iterator < Integer > it = craftingSkillIds . iterator ( ) ; while ( it . hasNext ( ) ) { if ( it . next ( ) == skillId ) { return _BOOL ; } } return _BOOL ; }
public static boolean isCraftingSkill ( int skillId ) { Iterator < Integer > it = craftingSkillIds . iterator ( ) ; while ( it . hasNext ( ) ) { if ( it . next ( ) == skillId ) { return _BOOL ; } } return _BOOL ; }
protected void merge ( Properties from , Properties to , String what , String where ) { if ( ! from . isEmpty ( ) ) { if ( to == null ) { to = getProperties ( ) ; } PropUtils . copyProperties ( from , to ) ; } else { if ( what != null && DEBUG ) { logger . fine ( STRING + what + STRING + ( where == null ? STRING : ( STRING + where ) ) ) ; } } }
protected void merge ( Properties from , Properties to , String what , String where ) { if ( ! from . isEmpty ( ) ) { if ( to == null ) { to = getProperties ( ) ; } PropUtils . copyProperties ( from , to ) ; } else { if ( what != null && DEBUG ) { logger . fine ( STRING + what + STRING + ( where == null ? STRING : ( STRING + where ) ) ) ; } } }
protected void merge ( Properties from , Properties to , String what , String where ) { if ( ! from . isEmpty ( ) ) { if ( to == null ) { to = getProperties ( ) ; } PropUtils . copyProperties ( from , to ) ; } else { if ( what != null && DEBUG ) { logger . fine ( STRING + what + STRING + ( where == null ? STRING : ( STRING + where ) ) ) ; } } }
protected void merge ( Properties from , Properties to , String what , String where ) { if ( ! from . isEmpty ( ) ) { if ( to == null ) { to = getProperties ( ) ; } PropUtils . copyProperties ( from , to ) ; } else { if ( what != null && DEBUG ) { logger . fine ( STRING + what + STRING + ( where == null ? STRING : ( STRING + where ) ) ) ; } } }
protected void merge ( Properties from , Properties to , String what , String where ) { if ( ! from . isEmpty ( ) ) { if ( to == null ) { to = getProperties ( ) ; } PropUtils . copyProperties ( from , to ) ; } else { if ( what != null && DEBUG ) { logger . fine ( STRING + what + STRING + ( where == null ? STRING : ( STRING + where ) ) ) ; } } }
protected void merge ( Properties from , Properties to , String what , String where ) { if ( ! from . isEmpty ( ) ) { if ( to == null ) { to = getProperties ( ) ; } PropUtils . copyProperties ( from , to ) ; } else { if ( what != null && DEBUG ) { logger . fine ( STRING + what + STRING + ( where == null ? STRING : ( STRING + where ) ) ) ; } } }
protected void merge ( Properties from , Properties to , String what , String where ) { if ( ! from . isEmpty ( ) ) { if ( to == null ) { to = getProperties ( ) ; } PropUtils . copyProperties ( from , to ) ; } else { if ( what != null && DEBUG ) { logger . fine ( STRING + what + STRING + ( where == null ? STRING : ( STRING + where ) ) ) ; } } }
public final int length ( ) { return remaining ( ) ; }
public void testConfigFileDirectory ( ) throws Exception { Properties properties = loadProperties ( STRING ) ; assertEquals ( STRING , properties . getProperty ( STRING ) ) ; }
static String escapeStringForASCII ( String s ) { String out = STRING ; char [ ] cArray = s . toCharArray ( ) ; for ( int i = _NUM ; i < cArray . length ; i ++ ) { char c = cArray [ i ] ; if ( c > _NUM ) { out += STRING ; String hex = Integer . toHexString ( c ) ; while ( hex . length ( ) < _NUM ) hex = STRING + hex ; out += hex ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else { out += c ; } } return out ; }
static String escapeStringForASCII ( String s ) { String out = STRING ; char [ ] cArray = s . toCharArray ( ) ; for ( int i = _NUM ; i < cArray . length ; i ++ ) { char c = cArray [ i ] ; if ( c > _NUM ) { out += STRING ; String hex = Integer . toHexString ( c ) ; while ( hex . length ( ) < _NUM ) hex = STRING + hex ; out += hex ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else if ( c == STRING ) { out += STRING ; } else { out += c ; } } return out ; }
public void done ( RemoteCall call ) throws RemoteException { clientRefLog . log ( Log . BRIEF , STRING ) ; free ( call , _BOOL ) ; try { call . done ( ) ; } catch ( IOException e ) { } }
public void done ( RemoteCall call ) throws RemoteException { clientRefLog . log ( Log . BRIEF , STRING ) ; free ( call , _BOOL ) ; try { call . done ( ) ; } catch ( IOException e ) { } }
public void done ( RemoteCall call ) throws RemoteException { clientRefLog . log ( Log . BRIEF , STRING ) ; free ( call , _BOOL ) ; try { call . done ( ) ; } catch ( IOException e ) { } }
public static SnippetSet parse ( final File file ) throws ParseException { return parse ( fileInputSupplier ( file . getParentFile ( ) ) , file . getName ( ) ) ; }
public static SnippetSet parse ( final File file ) throws ParseException { return parse ( fileInputSupplier ( file . getParentFile ( ) ) , file . getName ( ) ) ; }
public static InputStream tryGzipInput ( InputStream in ) throws IOException { if ( ! in . markSupported ( ) ) { PushbackInputStream pb = new PushbackInputStream ( in , _NUM ) ; in = pb ; byte [ ] magic = { _NUM , _NUM } ; pb . read ( magic ) ; pb . unread ( magic ) ; if ( magic [ _NUM ] == _NUM && magic [ _NUM ] == - _NUM ) { return new GZIPInputStream ( pb ) ; } return in ; } in . mark ( _NUM ) ; boolean isgzip = ( in . read ( ) == _NUM && in . read ( ) == - _NUM ) ; in . reset ( ) ; if ( isgzip ) { in = new GZIPInputStream ( in ) ; } return in ; }
private void loadTile ( String imagePath , int x , int y , int zoomLevel , Projection proj , OMGraphicList list ) { CacheObject ret = load ( imagePath , x , y , zoomLevel , proj ) ; if ( ret == null ) { ret = getEmptyTile ( imagePath , x , y , zoomLevel , proj ) ; } if ( ret != null ) { replaceLeastUsed ( ret ) ; OMGraphic raster = ( OMGraphic ) ret . obj ; if ( raster != null ) { raster . generate ( proj ) ; list . add ( raster ) ; if ( logger . isLoggable ( Level . FINE ) ) { raster . putAttribute ( OMGraphic . TOOLTIP , imagePath ) ; } } } }
private void loadTile ( String imagePath , int x , int y , int zoomLevel , Projection proj , OMGraphicList list ) { CacheObject ret = load ( imagePath , x , y , zoomLevel , proj ) ; if ( ret == null ) { ret = getEmptyTile ( imagePath , x , y , zoomLevel , proj ) ; } if ( ret != null ) { replaceLeastUsed ( ret ) ; OMGraphic raster = ( OMGraphic ) ret . obj ; if ( raster != null ) { raster . generate ( proj ) ; list . add ( raster ) ; if ( logger . isLoggable ( Level . FINE ) ) { raster . putAttribute ( OMGraphic . TOOLTIP , imagePath ) ; } } } }
public static void assumeCurrencySupport ( String ... codes ) { try { for ( String code : codes ) { Currency obj = Currency . getInstance ( code ) ; assertNotNull ( code , obj ) ; } } catch ( IllegalArgumentException e ) { Assume . assumeNoException ( e ) ; } }
public static void assumeCurrencySupport ( String ... codes ) { try { for ( String code : codes ) { Currency obj = Currency . getInstance ( code ) ; assertNotNull ( code , obj ) ; } } catch ( IllegalArgumentException e ) { Assume . assumeNoException ( e ) ; } }
static Field findField ( Object instance , String name ) throws NoSuchFieldException { for ( Class < ? > clazz = instance . getClass ( ) ; clazz != null ; clazz = clazz . getSuperclass ( ) ) { try { Field field = clazz . getDeclaredField ( name ) ; if ( ! field . isAccessible ( ) ) { field . setAccessible ( _BOOL ) ; } return field ; } catch ( NoSuchFieldException e ) { } } throw new NoSuchFieldException ( STRING + name + STRING + instance . getClass ( ) ) ; }
static Field findField ( Object instance , String name ) throws NoSuchFieldException { for ( Class < ? > clazz = instance . getClass ( ) ; clazz != null ; clazz = clazz . getSuperclass ( ) ) { try { Field field = clazz . getDeclaredField ( name ) ; if ( ! field . isAccessible ( ) ) { field . setAccessible ( _BOOL ) ; } return field ; } catch ( NoSuchFieldException e ) { } } throw new NoSuchFieldException ( STRING + name + STRING + instance . getClass ( ) ) ; }
private void checkPermissions ( ) { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { Enumeration < Permission > enum_ = permissions . elements ( ) ; while ( enum_ . hasMoreElements ( ) ) { sm . checkPermission ( enum_ . nextElement ( ) ) ; } } }
private void saveAISChange ( Session session , AkibanInformationSchema newAIS , Collection < String > schemas ) { saveAISChange ( session , newAIS , schemas , Collections . < Integer > emptyList ( ) ) ; }
private void saveAISChange ( Session session , AkibanInformationSchema newAIS , Collection < String > schemas ) { saveAISChange ( session , newAIS , schemas , Collections . < Integer > emptyList ( ) ) ; }
private void saveAISChange ( Session session , AkibanInformationSchema newAIS , Collection < String > schemas ) { saveAISChange ( session , newAIS , schemas , Collections . < Integer > emptyList ( ) ) ; }
private void saveAISChange ( Session session , AkibanInformationSchema newAIS , Collection < String > schemas ) { saveAISChange ( session , newAIS , schemas , Collections . < Integer > emptyList ( ) ) ; }
private void saveAISChange ( Session session , AkibanInformationSchema newAIS , Collection < String > schemas ) { saveAISChange ( session , newAIS , schemas , Collections . < Integer > emptyList ( ) ) ; }
private int determineMaxLevel ( PhyloTree tree ) { return determineMaxLevelRec ( _NUM , tree . getRoot ( ) ) ; }
private Pair < InferenceResult , InferenceResult > inferFromArguments ( final AnnotatedTypeFactory typeFactory , final Set < AFConstraint > afArgumentConstraints , final Set < TypeVariable > targets ) { Set < TUConstraint > tuArgConstraints = afToTuConstraints ( afArgumentConstraints , targets ) ; addConstraintsBetweenTargets ( tuArgConstraints , targets , _BOOL , typeFactory ) ; ConstraintMap argConstraints = constraintMapBuilder . build ( targets , tuArgConstraints , typeFactory ) ; InferenceResult inferredFromArgEqualities = equalitiesSolver . solveEqualities ( targets , argConstraints , typeFactory ) ; Set < TypeVariable > remainingTargets = inferredFromArgEqualities . getRemainingTargets ( targets , _BOOL ) ; InferenceResult fromSupertypes = supertypesSolver . solveFromSupertypes ( remainingTargets , argConstraints , typeFactory ) ; InferenceResult fromSubtypes = subtypesSolver . solveFromSubtypes ( remainingTargets , argConstraints , typeFactory ) ; fromSupertypes . mergeSubordinate ( fromSubtypes ) ; return Pair . of ( inferredFromArgEqualities , fromSupertypes ) ; }
private Pair < InferenceResult , InferenceResult > inferFromArguments ( final AnnotatedTypeFactory typeFactory , final Set < AFConstraint > afArgumentConstraints , final Set < TypeVariable > targets ) { Set < TUConstraint > tuArgConstraints = afToTuConstraints ( afArgumentConstraints , targets ) ; addConstraintsBetweenTargets ( tuArgConstraints , targets , _BOOL , typeFactory ) ; ConstraintMap argConstraints = constraintMapBuilder . build ( targets , tuArgConstraints , typeFactory ) ; InferenceResult inferredFromArgEqualities = equalitiesSolver . solveEqualities ( targets , argConstraints , typeFactory ) ; Set < TypeVariable > remainingTargets = inferredFromArgEqualities . getRemainingTargets ( targets , _BOOL ) ; InferenceResult fromSupertypes = supertypesSolver . solveFromSupertypes ( remainingTargets , argConstraints , typeFactory ) ; InferenceResult fromSubtypes = subtypesSolver . solveFromSubtypes ( remainingTargets , argConstraints , typeFactory ) ; fromSupertypes . mergeSubordinate ( fromSubtypes ) ; return Pair . of ( inferredFromArgEqualities , fromSupertypes ) ; }
public void test_copyStream_fullBlock ( ) throws IOException { final String id = STRING ; final int version = _NUM ; Random r = new Random ( ) ; final byte [ ] expected = new byte [ BLOCK_SIZE ] ; r . nextBytes ( expected ) ; assertEquals ( STRING , expected . length , repo . copyStream ( id , version , new ByteArrayInputStream ( expected ) ) ) ; assertEquals ( STRING , _NUM , repo . getBlockCount ( id , version ) ) ; assertSameIterator ( STRING , new Long [ ] { _NUM } , repo . blocks ( id , version ) ) ; assertEquals ( STRING , expected , read ( repo . inputStream ( id , version ) ) ) ; }
public void test_copyStream_fullBlock ( ) throws IOException { final String id = STRING ; final int version = _NUM ; Random r = new Random ( ) ; final byte [ ] expected = new byte [ BLOCK_SIZE ] ; r . nextBytes ( expected ) ; assertEquals ( STRING , expected . length , repo . copyStream ( id , version , new ByteArrayInputStream ( expected ) ) ) ; assertEquals ( STRING , _NUM , repo . getBlockCount ( id , version ) ) ; assertSameIterator ( STRING , new Long [ ] { _NUM } , repo . blocks ( id , version ) ) ; assertEquals ( STRING , expected , read ( repo . inputStream ( id , version ) ) ) ; }
private void visualizeRTreeEntry ( SVGPlot svgp , Element layer , Projection2D proj , AbstractRStarTree < ? extends N , E , ? > rtree , E entry , int depth ) { SpatialComparable mbr = entry ; if ( settings . fill ) { Element r = SVGHyperCube . drawFilled ( svgp , INDEX + depth , proj , mbr ) ; layer . appendChild ( r ) ; } else { Element r = SVGHyperCube . drawFrame ( svgp , proj , mbr ) ; SVGUtil . setCSSClass ( r , INDEX + depth ) ; layer . appendChild ( r ) ; } if ( ! entry . isLeafEntry ( ) ) { N node = rtree . getNode ( entry ) ; for ( int i = _NUM ; i < node . getNumEntries ( ) ; i ++ ) { E child = node . getEntry ( i ) ; if ( ! child . isLeafEntry ( ) ) { visualizeRTreeEntry ( svgp , layer , proj , rtree , child , depth + _NUM ) ; } } } }
public boolean hasRerolled ( ) { return rerolled ; }
public String addHighlight ( String channel , String comment ) { if ( channel == null || channel . isEmpty ( ) || ! Helper . isRegularChannel ( channel ) ) { return STRING ; } StreamInfo streamInfo = api . getStreamInfo ( Helper . toStream ( channel ) , null ) ; String streamTime = STRING ; if ( streamInfo . isValid ( ) && streamInfo . getOnline ( ) ) { streamTime = DateTime . ago ( streamInfo . getTimeStarted ( ) ) ; } if ( comment == null ) { comment = STRING ; } String line = String . format ( STRING , DateTime . fullDateTime ( ) , channel , streamTime , comment ) ; synchronized ( this ) { if ( streamInfo . getTimeStarted ( ) != lastStreamStartWritten ) { addToFile ( STRING ) ; } boolean success = addToFile ( line ) ; if ( success ) { lastStreamStartWritten = streamInfo . getTimeStarted ( ) ; String shortComment = STRING ; if ( ! comment . isEmpty ( ) ) { shortComment = STRING + StringUtil . shortenTo ( comment , _NUM ) + STRING ; } return STRING + channel + STRING + streamTime + STRING + shortComment ; } return STRING ; } }
public static long memoryUsageOf ( Instrumentation inst , final Object obj ) { return inst . getObjectSize ( obj ) ; }
public static long memoryUsageOf ( Instrumentation inst , final Object obj ) { return inst . getObjectSize ( obj ) ; }
public static long memoryUsageOf ( Instrumentation inst , final Object obj ) { return inst . getObjectSize ( obj ) ; }
protected void parseAndAddMapTileSet ( URL tileSetProperties ) throws IOException , MalformedURLException { Properties descProps = new Properties ( ) ; Logger logger = getLogger ( ) ; logger . info ( STRING ) ; InputStream descURLStream = tileSetProperties . openStream ( ) ; descProps . load ( descURLStream ) ; logger . info ( STRING + tileSetProperties . toString ( ) + STRING + descProps . toString ( ) ) ; MapTileSet mts = createMapTileSetFromProperties ( descProps ) ; if ( mts != null && mts . allGood ( ) ) { String mtsName = mts . getName ( ) ; mapTileSets . put ( mts . getName ( ) , mts ) ; logger . info ( STRING + mtsName + STRING ) ; } descURLStream . close ( ) ; }
public void addTableValueChangeListener ( TableValueChangeListener listener ) { if ( listener == null ) { return ; } m_listeners . add ( listener ) ; }
public GZipOutputStreamRandomAccess ( OutputStream out , int size ) throws IOException { super ( out , new Deflater ( Deflater . DEFAULT_COMPRESSION , _BOOL ) , size , _BOOL ) ; writeHeader ( ) ; crc . reset ( ) ; }
public void start ( long interval , TimeUnit unit ) { if ( ! isValid ( ) ) { return ; } long period = unit . toMillis ( interval ) ; if ( period < _NUM ) { return ; } _profileTask . stop ( ) ; _profileTask . setPeriod ( period ) ; _profileTask . start ( ) ; _state = StateProfile . ACTIVE ; }
public static String hex ( float f ) { return Integer . toHexString ( Float . floatToIntBits ( f ) ) ; }
public static String hex ( float f ) { return Integer . toHexString ( Float . floatToIntBits ( f ) ) ; }
@ Override public synchronized void processConnect ( WebSocketChannel channel , WSURI uri , String [ ] protocols ) { LOG . entering ( CLASS_NAME , STRING , new Object [ ] { uri , protocols } ) ; try { WebSocketNativeChannel nativeChannel = ( WebSocketNativeChannel ) channel ; if ( nativeChannel . getProxy ( ) != null ) { throw new IllegalStateException ( STRING ) ; } Proxy proxy = BridgeUtil . createProxy ( uri . getURI ( ) , this ) ; proxy . setPeer ( channel ) ; nativeChannel . setProxy ( proxy ) ; String [ ] params ; if ( protocols != null ) { String s = STRING ; for ( int i = _NUM ; i < protocols . length ; i ++ ) { if ( i > _NUM ) { s += STRING ; } s += protocols [ i ] ; } params = new String [ ] { STRING , uri . toString ( ) , s , STRING } ; } else { params = new String [ ] { STRING , uri . toString ( ) } ; } proxy . processEvent ( XoaEventKind . CREATE , params ) ; } catch ( Exception e ) { LOG . log ( Level . FINE , STRING + e . getMessage ( ) , e ) ; listener . connectionFailed ( channel , e ) ; } }
private void _schedule ( Activity a , long startTime ) { if ( a . isScheduled ( ) ) { try { notifyAll ( ) ; } catch ( Exception e ) { } return ; } a . setStartTime ( startTime ) ; synchronized ( this ) { m_activities . add ( a ) ; a . setScheduled ( _BOOL ) ; if ( startTime < m_nextTime ) { m_nextTime = startTime ; notify ( ) ; } } }
@ Override protected boolean useTeleportScroll ( final Player player ) { String targetZoneName = null ; int targetX = _NUM ; int targetY = _NUM ; int timeInTurns = _NUM ; final String infoString = getInfoString ( ) ; if ( infoString != null ) { final StringTokenizer st = new StringTokenizer ( infoString ) ; if ( st . countTokens ( ) == _NUM ) { targetZoneName = st . nextToken ( ) ; targetX = Integer . parseInt ( st . nextToken ( ) ) ; targetY = Integer . parseInt ( st . nextToken ( ) ) ; timeInTurns = Integer . parseInt ( st . nextToken ( ) ) ; } else { throw new IllegalArgumentException ( STRING ) ; } } return useTeleportScroll ( player , targetZoneName , targetX , targetY , timeInTurns ) ; }
protected void freeWrapper ( DockWrapper w ) { if ( externalFrameWrappers . remove ( w ) ) { w . freeWrapper ( ) ; return ; } if ( internalFrameWrappers . remove ( w ) ) { w . freeWrapper ( ) ; return ; } if ( north . freeWrapper ( w ) ) { return ; } if ( south . freeWrapper ( w ) ) { return ; } if ( east . freeWrapper ( w ) ) { return ; } if ( west . freeWrapper ( w ) ) { return ; } }
protected void freeWrapper ( DockWrapper w ) { if ( externalFrameWrappers . remove ( w ) ) { w . freeWrapper ( ) ; return ; } if ( internalFrameWrappers . remove ( w ) ) { w . freeWrapper ( ) ; return ; } if ( north . freeWrapper ( w ) ) { return ; } if ( south . freeWrapper ( w ) ) { return ; } if ( east . freeWrapper ( w ) ) { return ; } if ( west . freeWrapper ( w ) ) { return ; } }
public static List < File > walk ( String path ) { LinkedList < File > output = new LinkedList < File > ( ) ; File root = new File ( path ) ; File [ ] list = root . listFiles ( ) ; if ( list == null ) { return output ; } for ( File f : list ) { if ( f . isDirectory ( ) ) { output . addAll ( walk ( f . getAbsolutePath ( ) ) ) ; } else { output . addLast ( f ) ; } } return output ; }
public double distance ( PlaPointInt p_to_point ) { return Math . sqrt ( distance_square ( p_to_point ) ) ; }
public boolean isInstanceOfFollowedByBranch ( ) { return instanceOfFollowedByBranch ; }
public boolean isInstanceOfFollowedByBranch ( ) { return instanceOfFollowedByBranch ; }
public boolean isInstanceOfFollowedByBranch ( ) { return instanceOfFollowedByBranch ; }
public boolean isInstanceOfFollowedByBranch ( ) { return instanceOfFollowedByBranch ; }
public boolean isInstanceOfFollowedByBranch ( ) { return instanceOfFollowedByBranch ; }
public void testEncodingDecodingFullness ( ) { for ( GridClientCacheFlag f : GridClientCacheFlag . values ( ) ) { if ( f == KEEP_BINARIES ) continue ; int bits = GridClientConnection . encodeCacheFlags ( Collections . singleton ( f ) ) ; assertTrue ( bits != _NUM ) ; boolean out = GridCacheCommandHandler . parseCacheFlags ( bits ) ; assertEquals ( out , _BOOL ) ; } }
public void testEncodingDecodingFullness ( ) { for ( GridClientCacheFlag f : GridClientCacheFlag . values ( ) ) { if ( f == KEEP_BINARIES ) continue ; int bits = GridClientConnection . encodeCacheFlags ( Collections . singleton ( f ) ) ; assertTrue ( bits != _NUM ) ; boolean out = GridCacheCommandHandler . parseCacheFlags ( bits ) ; assertEquals ( out , _BOOL ) ; } }
public boolean isAcquired ( ) { return acquireCount . get ( ) > _NUM ; }
String readStartupCommandFile ( String dir , String fname , String canonPath ) { File dotInitFile = new File ( dir , fname ) ; if ( ! dotInitFile . exists ( ) ) { return null ; } String myCanonFile ; try { myCanonFile = dotInitFile . getCanonicalPath ( ) ; } catch ( IOException ee ) { MessageOutput . println ( STRING , dotInitFile . getPath ( ) ) ; return null ; } if ( canonPath == null || ! canonPath . equals ( myCanonFile ) ) { if ( ! readCommandFile ( dotInitFile ) ) { MessageOutput . println ( STRING , dotInitFile . getPath ( ) ) ; } } return myCanonFile ; }
public ArrayList < byte [ ] > encodeBlindedItems ( ) { ArrayList < byte [ ] > r = new ArrayList < byte [ ] > ( blindedItems . size ( ) ) ; for ( BigInteger i : blindedItems ) { r . add ( i . toByteArray ( ) ) ; } return r ; }
public void pause ( ) { pauseTime = System . currentTimeMillis ( ) ; }
public final void closeFallbackOutputStream ( ) throws DataFallbackException { if ( output != null ) { if ( LOG . isDebugEnabled ( ) ) LOG . debug ( STRING + dataFile . getName ( ) ) ; try { output . close ( ) ; } catch ( IOException e ) { throw new DataFallbackException ( e . getMessage ( ) ) ; } finally { output = null ; } } }
protected void deleteControlAction ( int row ) { controlList . remove ( row ) ; lightControlTableModel . fireTableDataChanged ( ) ; lightControlChanged = _BOOL ; }
protected void deleteControlAction ( int row ) { controlList . remove ( row ) ; lightControlTableModel . fireTableDataChanged ( ) ; lightControlChanged = _BOOL ; }
protected abstract ShardOperationResult readShardResult ( StreamInput in ) throws IOException ;
private void mergeDRINode ( Node node ) throws IIOInvalidTreeException { DRIMarkerSegment dri = ( DRIMarkerSegment ) findMarkerSegment ( DRIMarkerSegment . class , _BOOL ) ; if ( dri != null ) { dri . updateFromNativeNode ( node , _BOOL ) ; } else { DRIMarkerSegment newGuy = new DRIMarkerSegment ( node ) ; int firstSOF = findMarkerSegmentPosition ( SOFMarkerSegment . class , _BOOL ) ; int firstSOS = findMarkerSegmentPosition ( SOSMarkerSegment . class , _BOOL ) ; if ( firstSOF != - _NUM ) { markerSequence . add ( firstSOF , newGuy ) ; } else if ( firstSOS != - _NUM ) { markerSequence . add ( firstSOS , newGuy ) ; } else { markerSequence . add ( newGuy ) ; } } }
private void mergeDRINode ( Node node ) throws IIOInvalidTreeException { DRIMarkerSegment dri = ( DRIMarkerSegment ) findMarkerSegment ( DRIMarkerSegment . class , _BOOL ) ; if ( dri != null ) { dri . updateFromNativeNode ( node , _BOOL ) ; } else { DRIMarkerSegment newGuy = new DRIMarkerSegment ( node ) ; int firstSOF = findMarkerSegmentPosition ( SOFMarkerSegment . class , _BOOL ) ; int firstSOS = findMarkerSegmentPosition ( SOSMarkerSegment . class , _BOOL ) ; if ( firstSOF != - _NUM ) { markerSequence . add ( firstSOF , newGuy ) ; } else if ( firstSOS != - _NUM ) { markerSequence . add ( firstSOS , newGuy ) ; } else { markerSequence . add ( newGuy ) ; } } }
private void mergeDRINode ( Node node ) throws IIOInvalidTreeException { DRIMarkerSegment dri = ( DRIMarkerSegment ) findMarkerSegment ( DRIMarkerSegment . class , _BOOL ) ; if ( dri != null ) { dri . updateFromNativeNode ( node , _BOOL ) ; } else { DRIMarkerSegment newGuy = new DRIMarkerSegment ( node ) ; int firstSOF = findMarkerSegmentPosition ( SOFMarkerSegment . class , _BOOL ) ; int firstSOS = findMarkerSegmentPosition ( SOSMarkerSegment . class , _BOOL ) ; if ( firstSOF != - _NUM ) { markerSequence . add ( firstSOF , newGuy ) ; } else if ( firstSOS != - _NUM ) { markerSequence . add ( firstSOS , newGuy ) ; } else { markerSequence . add ( newGuy ) ; } } }
void afterWrite ( Runnable task ) { writeBuffer . add ( task ) ; drainStatus . lazySet ( REQUIRED ) ; tryToDrainBuffers ( ) ; notifyListener ( ) ; }
public void render ( Graphics graphics ) { if ( getNeedToRegenerate ( ) || getNeedToReposition ( ) || ! isVisible ( ) ) { if ( DEBUG ) { logger . fine ( STRING ) ; } return ; } Graphics g = graphics . create ( ) ; if ( colorModel == COLORMODEL_IMAGEICON && ( getWidth ( ) == - _NUM ) ) { logger . fine ( STRING ) ; } if ( g instanceof Graphics2D && renderRotationAngle != null ) { rotate ( ( Graphics2D ) g ) ; } renderImage ( g , bitmap , point1 ) ; if ( isSelected ( ) || logger . isLoggable ( Level . FINER ) ) { renderShape ( g ) ; } renderLabel ( graphics ) ; }
public void testWhenComplete_sourceCompletedNormallyActionFailed ( ) { for ( boolean createIncomplete : new boolean [ ] { _BOOL , _BOOL } ) for ( ExecutionMode m : ExecutionMode . values ( ) ) for ( Integer v1 : new Integer [ ] { _NUM , null } ) { final AtomicInteger a = new AtomicInteger ( _NUM ) ; final CFException ex = new CFException ( ) ; final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; if ( ! createIncomplete ) assertTrue ( f . complete ( v1 ) ) ; final CompletableFuture < Integer > g = m . whenComplete ( f , null ) ; if ( createIncomplete ) assertTrue ( f . complete ( v1 ) ) ; checkCompletedWithWrappedException ( g , ex ) ; checkCompletedNormally ( f , v1 ) ; assertEquals ( _NUM , a . get ( ) ) ; } }
public void testWhenComplete_sourceCompletedNormallyActionFailed ( ) { for ( boolean createIncomplete : new boolean [ ] { _BOOL , _BOOL } ) for ( ExecutionMode m : ExecutionMode . values ( ) ) for ( Integer v1 : new Integer [ ] { _NUM , null } ) { final AtomicInteger a = new AtomicInteger ( _NUM ) ; final CFException ex = new CFException ( ) ; final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; if ( ! createIncomplete ) assertTrue ( f . complete ( v1 ) ) ; final CompletableFuture < Integer > g = m . whenComplete ( f , null ) ; if ( createIncomplete ) assertTrue ( f . complete ( v1 ) ) ; checkCompletedWithWrappedException ( g , ex ) ; checkCompletedNormally ( f , v1 ) ; assertEquals ( _NUM , a . get ( ) ) ; } }
public void testWhenComplete_sourceCompletedNormallyActionFailed ( ) { for ( boolean createIncomplete : new boolean [ ] { _BOOL , _BOOL } ) for ( ExecutionMode m : ExecutionMode . values ( ) ) for ( Integer v1 : new Integer [ ] { _NUM , null } ) { final AtomicInteger a = new AtomicInteger ( _NUM ) ; final CFException ex = new CFException ( ) ; final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; if ( ! createIncomplete ) assertTrue ( f . complete ( v1 ) ) ; final CompletableFuture < Integer > g = m . whenComplete ( f , null ) ; if ( createIncomplete ) assertTrue ( f . complete ( v1 ) ) ; checkCompletedWithWrappedException ( g , ex ) ; checkCompletedNormally ( f , v1 ) ; assertEquals ( _NUM , a . get ( ) ) ; } }
public void testWhenComplete_sourceCompletedNormallyActionFailed ( ) { for ( boolean createIncomplete : new boolean [ ] { _BOOL , _BOOL } ) for ( ExecutionMode m : ExecutionMode . values ( ) ) for ( Integer v1 : new Integer [ ] { _NUM , null } ) { final AtomicInteger a = new AtomicInteger ( _NUM ) ; final CFException ex = new CFException ( ) ; final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; if ( ! createIncomplete ) assertTrue ( f . complete ( v1 ) ) ; final CompletableFuture < Integer > g = m . whenComplete ( f , null ) ; if ( createIncomplete ) assertTrue ( f . complete ( v1 ) ) ; checkCompletedWithWrappedException ( g , ex ) ; checkCompletedNormally ( f , v1 ) ; assertEquals ( _NUM , a . get ( ) ) ; } }
public void showEmpty ( Drawable emptyImageDrawable , String emptyTextTitle , String emptyTextContent ) { switchState ( EMPTY , emptyImageDrawable , emptyTextTitle , emptyTextContent , null , null , Collections . < Integer > emptyList ( ) ) ; }
private boolean removeTask ( Task t , int min ) { for ( int i = tasks . size ( ) ; -- i >= min ; ) { if ( tasks . get ( i ) == t ) { tasks . remove ( i ) ; if ( i < firstPending ) { firstPending -- ; for ( int j = threads . size ( ) ; -- j >= _NUM ; ) { TaskThread thread = threads . get ( j ) ; if ( thread . task == t ) { if ( thread != Thread . currentThread ( ) ) thread . interrupt ( ) ; break ; } } } return _BOOL ; } } return _BOOL ; }
private boolean removeTask ( Task t , int min ) { for ( int i = tasks . size ( ) ; -- i >= min ; ) { if ( tasks . get ( i ) == t ) { tasks . remove ( i ) ; if ( i < firstPending ) { firstPending -- ; for ( int j = threads . size ( ) ; -- j >= _NUM ; ) { TaskThread thread = threads . get ( j ) ; if ( thread . task == t ) { if ( thread != Thread . currentThread ( ) ) thread . interrupt ( ) ; break ; } } } return _BOOL ; } } return _BOOL ; }
private void readObject ( final java . io . ObjectInputStream in ) throws IOException , ClassNotFoundException { timeStamp = in . readLong ( ) ; duration = in . readLong ( ) ; }
public static SnmpEngineId createEngineId ( int port , int iana ) throws UnknownHostException { InetAddress address = null ; address = InetAddress . getLocalHost ( ) ; return createEngineId ( address , port , iana ) ; }
public static SnmpEngineId createEngineId ( int port , int iana ) throws UnknownHostException { InetAddress address = null ; address = InetAddress . getLocalHost ( ) ; return createEngineId ( address , port , iana ) ; }
public static SnmpEngineId createEngineId ( int port , int iana ) throws UnknownHostException { InetAddress address = null ; address = InetAddress . getLocalHost ( ) ; return createEngineId ( address , port , iana ) ; }
public static byte [ ] hash ( byte [ ] data ) { try { MessageDigest md = MessageDigest . getInstance ( STRING ) ; md . update ( data ) ; return md . digest ( ) ; } catch ( Exception e ) { throw new RuntimeException ( STRING + e . getMessage ( ) , e ) ; } }
public Properties toProperties ( ) { Properties properties = new Properties ( ) ; properties . setProperty ( STRING , rack ) ; properties . setProperty ( STRING , dataCenter ) ; return properties ; }
public Properties toProperties ( ) { Properties properties = new Properties ( ) ; properties . setProperty ( STRING , rack ) ; properties . setProperty ( STRING , dataCenter ) ; return properties ; }
public Properties toProperties ( ) { Properties properties = new Properties ( ) ; properties . setProperty ( STRING , rack ) ; properties . setProperty ( STRING , dataCenter ) ; return properties ; }
private void saveProperties ( ) { if ( isDataValid ( ) ) { control . setTrackSlider ( trackBox . isSelected ( ) ) ; control . setSwitchSliderFunction ( functionSwitchSlider . getText ( ) ) ; control . setSpeedController ( _displaySlider ) ; finishEdit ( ) ; } }
public static String toFullClassName ( String symbolicName ) { if ( uriToClassNameMap . containsKey ( symbolicName ) ) return uriToClassNameMap . get ( symbolicName ) ; return symbolicName . replace ( STRING , STRING ) ; }
public static String toFullClassName ( String symbolicName ) { if ( uriToClassNameMap . containsKey ( symbolicName ) ) return uriToClassNameMap . get ( symbolicName ) ; return symbolicName . replace ( STRING , STRING ) ; }
private < S , T > Set < T > extract ( final Collection < S > collection , final Extractor < S , T > extractor ) { final Set < T > values = new HashSet < T > ( collection . size ( ) ) ; for ( final S instance : collection ) { values . add ( extractor . getValue ( instance ) ) ; } return values ; }
private < S , T > Set < T > extract ( final Collection < S > collection , final Extractor < S , T > extractor ) { final Set < T > values = new HashSet < T > ( collection . size ( ) ) ; for ( final S instance : collection ) { values . add ( extractor . getValue ( instance ) ) ; } return values ; }
abstract void startPoll ( int fd , int events ) ;
abstract void startPoll ( int fd , int events ) ;
abstract void startPoll ( int fd , int events ) ;
abstract void startPoll ( int fd , int events ) ;
abstract void startPoll ( int fd , int events ) ;
private SignedRequestsHelper ( ) { }
private SignedRequestsHelper ( ) { }
public void clear ( ) { fullyLock ( ) ; try { for ( Node < E > p , h = head ; ( p = h . next ) != null ; h = p ) { h . next = h ; p . item = null ; } head = last ; if ( count . getAndSet ( _NUM ) >= capacity ) notFull . signal ( ) ; } finally { fullyUnlock ( ) ; } }
public void clear ( ) { fullyLock ( ) ; try { for ( Node < E > p , h = head ; ( p = h . next ) != null ; h = p ) { h . next = h ; p . item = null ; } head = last ; if ( count . getAndSet ( _NUM ) >= capacity ) notFull . signal ( ) ; } finally { fullyUnlock ( ) ; } }
public static MySQLPacket readPacket ( InputStream in ) { return readPacket ( in , _NUM ) ; }
public static MySQLPacket readPacket ( InputStream in ) { return readPacket ( in , _NUM ) ; }
void enterField ( ) { oldContents = val . getText ( ) ; }
public static OMGrid read ( DataInputStream dis ) throws IOException { return read ( dis , null ) ; }
public static OMGrid read ( DataInputStream dis ) throws IOException { return read ( dis , null ) ; }
public static OMGrid read ( DataInputStream dis ) throws IOException { return read ( dis , null ) ; }
public final void testSetSeedbyteArray02 ( ) throws NoSuchFieldException , SecurityException , IllegalAccessException { byte [ ] seed = new byte [ LENGTH ] ; byte [ ] bytes1 = new byte [ LENGTH ] ; byte [ ] bytes2 = new byte [ LENGTH ] ; boolean b ; for ( int i = _NUM ; i < seed . length ; i ++ ) { seed [ i ] = ( byte ) i ; } sr . setSeed ( seed ) ; sr . setSeed ( seed ) ; sr2 . setSeed ( seed ) ; sr . nextBytes ( bytes1 ) ; sr2 . nextBytes ( bytes2 ) ; b = _BOOL ; for ( int j = _NUM ; j < bytes1 . length ; j ++ ) { b &= bytes1 [ j ] == bytes2 [ j ] ; } assertFalse ( STRING , b ) ; }
public final void testSetSeedbyteArray02 ( ) throws NoSuchFieldException , SecurityException , IllegalAccessException { byte [ ] seed = new byte [ LENGTH ] ; byte [ ] bytes1 = new byte [ LENGTH ] ; byte [ ] bytes2 = new byte [ LENGTH ] ; boolean b ; for ( int i = _NUM ; i < seed . length ; i ++ ) { seed [ i ] = ( byte ) i ; } sr . setSeed ( seed ) ; sr . setSeed ( seed ) ; sr2 . setSeed ( seed ) ; sr . nextBytes ( bytes1 ) ; sr2 . nextBytes ( bytes2 ) ; b = _BOOL ; for ( int j = _NUM ; j < bytes1 . length ; j ++ ) { b &= bytes1 [ j ] == bytes2 [ j ] ; } assertFalse ( STRING , b ) ; }
public final void testSetSeedbyteArray02 ( ) throws NoSuchFieldException , SecurityException , IllegalAccessException { byte [ ] seed = new byte [ LENGTH ] ; byte [ ] bytes1 = new byte [ LENGTH ] ; byte [ ] bytes2 = new byte [ LENGTH ] ; boolean b ; for ( int i = _NUM ; i < seed . length ; i ++ ) { seed [ i ] = ( byte ) i ; } sr . setSeed ( seed ) ; sr . setSeed ( seed ) ; sr2 . setSeed ( seed ) ; sr . nextBytes ( bytes1 ) ; sr2 . nextBytes ( bytes2 ) ; b = _BOOL ; for ( int j = _NUM ; j < bytes1 . length ; j ++ ) { b &= bytes1 [ j ] == bytes2 [ j ] ; } assertFalse ( STRING , b ) ; }
public final void testSetSeedbyteArray02 ( ) throws NoSuchFieldException , SecurityException , IllegalAccessException { byte [ ] seed = new byte [ LENGTH ] ; byte [ ] bytes1 = new byte [ LENGTH ] ; byte [ ] bytes2 = new byte [ LENGTH ] ; boolean b ; for ( int i = _NUM ; i < seed . length ; i ++ ) { seed [ i ] = ( byte ) i ; } sr . setSeed ( seed ) ; sr . setSeed ( seed ) ; sr2 . setSeed ( seed ) ; sr . nextBytes ( bytes1 ) ; sr2 . nextBytes ( bytes2 ) ; b = _BOOL ; for ( int j = _NUM ; j < bytes1 . length ; j ++ ) { b &= bytes1 [ j ] == bytes2 [ j ] ; } assertFalse ( STRING , b ) ; }
private String contact ( Context context , EasyCursor c ) { String contact = c . getString ( aliased_ ( SyncsJoinAll . CONTACT_NAME ) ) ; if ( contact == null ) { contact = context . getString ( R . string . non_contact ) ; } return contact ; }
public boolean isTrivial ( Integer complexity ) { int len = payload . length ; if ( ( null == complexity ) || ( len < _NUM ) ) { return _BOOL ; } else if ( ( complexity . intValue ( ) > _NUM ) && ( len > _NUM ) ) { Set < Character > seen = new TreeSet < Character > ( ) ; for ( int i = _NUM ; i < len ; i ++ ) { Character c = Character . valueOf ( this . payload [ i ] ) ; if ( seen . contains ( c ) ) { continue ; } else { seen . add ( c ) ; } } if ( complexity . intValue ( ) <= seen . size ( ) ) { return _BOOL ; } } return _BOOL ; }
@ Override public void process ( Number tuple ) { numList . add ( tuple ) ; }
public void register ( String key , Remote value ) throws RegistryException { try { registry . rebind ( key , value ) ; } catch ( Exception e ) { throw new RegistryException ( STRING + key + STRING , e ) ; } }
public static String printCodePointAsString ( int codePoint ) { StringBuilder builder = new StringBuilder ( _NUM ) ; builder . append ( STRING ) ; try { printStringCodePoint ( builder , codePoint ) ; } catch ( IOException e ) { throw new Error ( e ) ; } builder . append ( STRING ) ; return builder . toString ( ) ; }
public static String printCodePointAsString ( int codePoint ) { StringBuilder builder = new StringBuilder ( _NUM ) ; builder . append ( STRING ) ; try { printStringCodePoint ( builder , codePoint ) ; } catch ( IOException e ) { throw new Error ( e ) ; } builder . append ( STRING ) ; return builder . toString ( ) ; }
public static String printCodePointAsString ( int codePoint ) { StringBuilder builder = new StringBuilder ( _NUM ) ; builder . append ( STRING ) ; try { printStringCodePoint ( builder , codePoint ) ; } catch ( IOException e ) { throw new Error ( e ) ; } builder . append ( STRING ) ; return builder . toString ( ) ; }
@ Override protected void deleteBehind ( final int n , final Iterator < byte [ ] > keys ) { final Lock lock = writeLock ( ) ; lock . lock ( ) ; try { super . deleteBehind ( n , keys ) ; } finally { unlock ( lock ) ; } }
@ Override protected void deleteBehind ( final int n , final Iterator < byte [ ] > keys ) { final Lock lock = writeLock ( ) ; lock . lock ( ) ; try { super . deleteBehind ( n , keys ) ; } finally { unlock ( lock ) ; } }
private static boolean checkName ( EditableResources r , String name ) { for ( String n : r . getResourceNames ( ) ) { if ( n . equals ( name ) ) { return _BOOL ; } } return _BOOL ; }
private static boolean checkName ( EditableResources r , String name ) { for ( String n : r . getResourceNames ( ) ) { if ( n . equals ( name ) ) { return _BOOL ; } } return _BOOL ; }
private static boolean checkName ( EditableResources r , String name ) { for ( String n : r . getResourceNames ( ) ) { if ( n . equals ( name ) ) { return _BOOL ; } } return _BOOL ; }
public BloomFilter ( byte [ ] data , int entries , double error ) throws RuntimeException { if ( entries < _NUM || ( ( _NUM <= error ) || ( error <= errorPrecision ) ) ) { throw new RuntimeException ( STRING ) ; } this . entries = entries ; this . error = error ; bpe = - ( Math . log ( error ) / denom ) ; bits = ( int ) ( ( double ) entries * bpe ) ; bytes = ( bits / _NUM ) + ( bits % _NUM != _NUM ? _NUM : _NUM ) ; if ( data != null ) { if ( bytes != data . length ) { throw new RuntimeException ( String . format ( STRING , bytes , data . length ) ) ; } bf = data ; } else { bf = new byte [ bytes ] ; ; } hashes = ( int ) Math . ceil ( _NUM * bpe ) ; }
public BloomFilter ( byte [ ] data , int entries , double error ) throws RuntimeException { if ( entries < _NUM || ( ( _NUM <= error ) || ( error <= errorPrecision ) ) ) { throw new RuntimeException ( STRING ) ; } this . entries = entries ; this . error = error ; bpe = - ( Math . log ( error ) / denom ) ; bits = ( int ) ( ( double ) entries * bpe ) ; bytes = ( bits / _NUM ) + ( bits % _NUM != _NUM ? _NUM : _NUM ) ; if ( data != null ) { if ( bytes != data . length ) { throw new RuntimeException ( String . format ( STRING , bytes , data . length ) ) ; } bf = data ; } else { bf = new byte [ bytes ] ; ; } hashes = ( int ) Math . ceil ( _NUM * bpe ) ; }
public BloomFilter ( byte [ ] data , int entries , double error ) throws RuntimeException { if ( entries < _NUM || ( ( _NUM <= error ) || ( error <= errorPrecision ) ) ) { throw new RuntimeException ( STRING ) ; } this . entries = entries ; this . error = error ; bpe = - ( Math . log ( error ) / denom ) ; bits = ( int ) ( ( double ) entries * bpe ) ; bytes = ( bits / _NUM ) + ( bits % _NUM != _NUM ? _NUM : _NUM ) ; if ( data != null ) { if ( bytes != data . length ) { throw new RuntimeException ( String . format ( STRING , bytes , data . length ) ) ; } bf = data ; } else { bf = new byte [ bytes ] ; ; } hashes = ( int ) Math . ceil ( _NUM * bpe ) ; }
public BloomFilter ( byte [ ] data , int entries , double error ) throws RuntimeException { if ( entries < _NUM || ( ( _NUM <= error ) || ( error <= errorPrecision ) ) ) { throw new RuntimeException ( STRING ) ; } this . entries = entries ; this . error = error ; bpe = - ( Math . log ( error ) / denom ) ; bits = ( int ) ( ( double ) entries * bpe ) ; bytes = ( bits / _NUM ) + ( bits % _NUM != _NUM ? _NUM : _NUM ) ; if ( data != null ) { if ( bytes != data . length ) { throw new RuntimeException ( String . format ( STRING , bytes , data . length ) ) ; } bf = data ; } else { bf = new byte [ bytes ] ; ; } hashes = ( int ) Math . ceil ( _NUM * bpe ) ; }
public BloomFilter ( byte [ ] data , int entries , double error ) throws RuntimeException { if ( entries < _NUM || ( ( _NUM <= error ) || ( error <= errorPrecision ) ) ) { throw new RuntimeException ( STRING ) ; } this . entries = entries ; this . error = error ; bpe = - ( Math . log ( error ) / denom ) ; bits = ( int ) ( ( double ) entries * bpe ) ; bytes = ( bits / _NUM ) + ( bits % _NUM != _NUM ? _NUM : _NUM ) ; if ( data != null ) { if ( bytes != data . length ) { throw new RuntimeException ( String . format ( STRING , bytes , data . length ) ) ; } bf = data ; } else { bf = new byte [ bytes ] ; ; } hashes = ( int ) Math . ceil ( _NUM * bpe ) ; }
private JarServiceProvider ( ) { }
private JarServiceProvider ( ) { }
public void addChild ( AccessibilityNodeInfo child ) { if ( mChildren == null ) { mChildren = new LinkedList < > ( ) ; } mChildren . add ( child ) ; ( ( ShadowAccessibilityNodeInfo ) ShadowExtractor . extract ( child ) ) . mParent = mRealAccessibilityNodeInfo ; }
protected void printIndent ( StringBuilder ddl ) { ddl . append ( getIndent ( ) ) ; }
protected void printIndent ( StringBuilder ddl ) { ddl . append ( getIndent ( ) ) ; }
private Map < String , Object > parse ( Json json ) { return json . asMap ( ) ; }
public void addLoadConstant ( int k ) { switch ( k ) { case _NUM : add ( ByteCode . ICONST_0 ) ; break ; case _NUM : add ( ByteCode . ICONST_1 ) ; break ; case _NUM : add ( ByteCode . ICONST_2 ) ; break ; case _NUM : add ( ByteCode . ICONST_3 ) ; break ; case _NUM : add ( ByteCode . ICONST_4 ) ; break ; case _NUM : add ( ByteCode . ICONST_5 ) ; break ; default : add ( ByteCode . LDC , itsConstantPool . addConstant ( k ) ) ; break ; } }
private boolean shouldAppendCharsetParam ( String ... propertyValueList ) { if ( ! mShouldAppendCharsetParam ) { return _BOOL ; } for ( String propertyValue : propertyValueList ) { if ( ! VCardUtils . containsOnlyPrintableAscii ( propertyValue ) ) { return _BOOL ; } } return _BOOL ; }
private boolean shouldAppendCharsetParam ( String ... propertyValueList ) { if ( ! mShouldAppendCharsetParam ) { return _BOOL ; } for ( String propertyValue : propertyValueList ) { if ( ! VCardUtils . containsOnlyPrintableAscii ( propertyValue ) ) { return _BOOL ; } } return _BOOL ; }
private boolean shouldAppendCharsetParam ( String ... propertyValueList ) { if ( ! mShouldAppendCharsetParam ) { return _BOOL ; } for ( String propertyValue : propertyValueList ) { if ( ! VCardUtils . containsOnlyPrintableAscii ( propertyValue ) ) { return _BOOL ; } } return _BOOL ; }
private boolean shouldAppendCharsetParam ( String ... propertyValueList ) { if ( ! mShouldAppendCharsetParam ) { return _BOOL ; } for ( String propertyValue : propertyValueList ) { if ( ! VCardUtils . containsOnlyPrintableAscii ( propertyValue ) ) { return _BOOL ; } } return _BOOL ; }
private boolean shouldAppendCharsetParam ( String ... propertyValueList ) { if ( ! mShouldAppendCharsetParam ) { return _BOOL ; } for ( String propertyValue : propertyValueList ) { if ( ! VCardUtils . containsOnlyPrintableAscii ( propertyValue ) ) { return _BOOL ; } } return _BOOL ; }
private boolean shouldAppendCharsetParam ( String ... propertyValueList ) { if ( ! mShouldAppendCharsetParam ) { return _BOOL ; } for ( String propertyValue : propertyValueList ) { if ( ! VCardUtils . containsOnlyPrintableAscii ( propertyValue ) ) { return _BOOL ; } } return _BOOL ; }
private boolean shouldAppendCharsetParam ( String ... propertyValueList ) { if ( ! mShouldAppendCharsetParam ) { return _BOOL ; } for ( String propertyValue : propertyValueList ) { if ( ! VCardUtils . containsOnlyPrintableAscii ( propertyValue ) ) { return _BOOL ; } } return _BOOL ; }
private boolean shouldAppendCharsetParam ( String ... propertyValueList ) { if ( ! mShouldAppendCharsetParam ) { return _BOOL ; } for ( String propertyValue : propertyValueList ) { if ( ! VCardUtils . containsOnlyPrintableAscii ( propertyValue ) ) { return _BOOL ; } } return _BOOL ; }
private boolean shouldAppendCharsetParam ( String ... propertyValueList ) { if ( ! mShouldAppendCharsetParam ) { return _BOOL ; } for ( String propertyValue : propertyValueList ) { if ( ! VCardUtils . containsOnlyPrintableAscii ( propertyValue ) ) { return _BOOL ; } } return _BOOL ; }
private boolean shouldAppendCharsetParam ( String ... propertyValueList ) { if ( ! mShouldAppendCharsetParam ) { return _BOOL ; } for ( String propertyValue : propertyValueList ) { if ( ! VCardUtils . containsOnlyPrintableAscii ( propertyValue ) ) { return _BOOL ; } } return _BOOL ; }
private boolean shouldAppendCharsetParam ( String ... propertyValueList ) { if ( ! mShouldAppendCharsetParam ) { return _BOOL ; } for ( String propertyValue : propertyValueList ) { if ( ! VCardUtils . containsOnlyPrintableAscii ( propertyValue ) ) { return _BOOL ; } } return _BOOL ; }
private boolean shouldAppendCharsetParam ( String ... propertyValueList ) { if ( ! mShouldAppendCharsetParam ) { return _BOOL ; } for ( String propertyValue : propertyValueList ) { if ( ! VCardUtils . containsOnlyPrintableAscii ( propertyValue ) ) { return _BOOL ; } } return _BOOL ; }
private boolean shouldAppendCharsetParam ( String ... propertyValueList ) { if ( ! mShouldAppendCharsetParam ) { return _BOOL ; } for ( String propertyValue : propertyValueList ) { if ( ! VCardUtils . containsOnlyPrintableAscii ( propertyValue ) ) { return _BOOL ; } } return _BOOL ; }
public void encode ( DerOutputStream out ) throws IOException { if ( extensionId == null ) throw new IOException ( STRING ) ; if ( extensionValue == null ) throw new IOException ( STRING ) ; DerOutputStream dos = new DerOutputStream ( ) ; dos . putOID ( extensionId ) ; if ( critical ) dos . putBoolean ( critical ) ; dos . putOctetString ( extensionValue ) ; out . write ( DerValue . tag_Sequence , dos ) ; }
private static Map < String , String > extractKeyValuePairs ( String props , ObjectName mbean ) { Map < String , String > map = new LinkedHashMap < String , String > ( ) ; int eq = props . indexOf ( STRING ) ; while ( eq != - _NUM ) { String key = props . substring ( _NUM , eq ) ; String value = mbean . getKeyProperty ( key ) ; map . put ( key , value ) ; props = props . substring ( key . length ( ) + _NUM + value . length ( ) ) ; if ( props . startsWith ( STRING ) ) { props = props . substring ( _NUM ) ; } eq = props . indexOf ( STRING ) ; } return map ; }
private static Map < String , String > extractKeyValuePairs ( String props , ObjectName mbean ) { Map < String , String > map = new LinkedHashMap < String , String > ( ) ; int eq = props . indexOf ( STRING ) ; while ( eq != - _NUM ) { String key = props . substring ( _NUM , eq ) ; String value = mbean . getKeyProperty ( key ) ; map . put ( key , value ) ; props = props . substring ( key . length ( ) + _NUM + value . length ( ) ) ; if ( props . startsWith ( STRING ) ) { props = props . substring ( _NUM ) ; } eq = props . indexOf ( STRING ) ; } return map ; }
public void addSplitEdges ( List edgeList ) { addEndpoints ( ) ; Iterator it = iterator ( ) ; EdgeIntersection eiPrev = ( EdgeIntersection ) it . next ( ) ; while ( it . hasNext ( ) ) { EdgeIntersection ei = ( EdgeIntersection ) it . next ( ) ; Edge newEdge = createSplitEdge ( eiPrev , ei ) ; edgeList . add ( newEdge ) ; eiPrev = ei ; } }
public void addSplitEdges ( List edgeList ) { addEndpoints ( ) ; Iterator it = iterator ( ) ; EdgeIntersection eiPrev = ( EdgeIntersection ) it . next ( ) ; while ( it . hasNext ( ) ) { EdgeIntersection ei = ( EdgeIntersection ) it . next ( ) ; Edge newEdge = createSplitEdge ( eiPrev , ei ) ; edgeList . add ( newEdge ) ; eiPrev = ei ; } }
public void addSplitEdges ( List edgeList ) { addEndpoints ( ) ; Iterator it = iterator ( ) ; EdgeIntersection eiPrev = ( EdgeIntersection ) it . next ( ) ; while ( it . hasNext ( ) ) { EdgeIntersection ei = ( EdgeIntersection ) it . next ( ) ; Edge newEdge = createSplitEdge ( eiPrev , ei ) ; edgeList . add ( newEdge ) ; eiPrev = ei ; } }
public void addSplitEdges ( List edgeList ) { addEndpoints ( ) ; Iterator it = iterator ( ) ; EdgeIntersection eiPrev = ( EdgeIntersection ) it . next ( ) ; while ( it . hasNext ( ) ) { EdgeIntersection ei = ( EdgeIntersection ) it . next ( ) ; Edge newEdge = createSplitEdge ( eiPrev , ei ) ; edgeList . add ( newEdge ) ; eiPrev = ei ; } }
public void addSplitEdges ( List edgeList ) { addEndpoints ( ) ; Iterator it = iterator ( ) ; EdgeIntersection eiPrev = ( EdgeIntersection ) it . next ( ) ; while ( it . hasNext ( ) ) { EdgeIntersection ei = ( EdgeIntersection ) it . next ( ) ; Edge newEdge = createSplitEdge ( eiPrev , ei ) ; edgeList . add ( newEdge ) ; eiPrev = ei ; } }
public void addSplitEdges ( List edgeList ) { addEndpoints ( ) ; Iterator it = iterator ( ) ; EdgeIntersection eiPrev = ( EdgeIntersection ) it . next ( ) ; while ( it . hasNext ( ) ) { EdgeIntersection ei = ( EdgeIntersection ) it . next ( ) ; Edge newEdge = createSplitEdge ( eiPrev , ei ) ; edgeList . add ( newEdge ) ; eiPrev = ei ; } }
public static boolean saveBitmapToFile ( Bitmap bitmap , String path ) { File file = new File ( path ) ; FileOutputStream fOut ; try { fOut = new FileOutputStream ( file ) ; bitmap . compress ( Bitmap . CompressFormat . JPEG , _NUM , fOut ) ; fOut . flush ( ) ; fOut . close ( ) ; return _BOOL ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return _BOOL ; }
public static boolean saveBitmapToFile ( Bitmap bitmap , String path ) { File file = new File ( path ) ; FileOutputStream fOut ; try { fOut = new FileOutputStream ( file ) ; bitmap . compress ( Bitmap . CompressFormat . JPEG , _NUM , fOut ) ; fOut . flush ( ) ; fOut . close ( ) ; return _BOOL ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return _BOOL ; }
public static String toString ( Collection < ? > collection , String separator ) { boolean first = _BOOL ; StringBuilder b = new StringBuilder ( ) ; for ( Object o : collection ) { if ( first ) { first = _BOOL ; } else { b . append ( separator ) ; } b . append ( o ) ; } return b . toString ( ) ; }
void newEquation ( DF_LatticeCell lhs , DF_Operator operator , DF_LatticeCell op1 , DF_LatticeCell op2 , DF_LatticeCell op3 ) { DF_Equation eq = new DF_Equation ( lhs , operator , op1 , op2 , op3 ) ; equations . addGraphNode ( eq ) ; equations . addGraphNode ( lhs ) ; equations . addGraphNode ( op1 ) ; equations . addGraphNode ( op2 ) ; equations . addGraphNode ( op3 ) ; newEquations . add ( eq ) ; op1 . addUse ( eq ) ; op2 . addUse ( eq ) ; op3 . addUse ( eq ) ; lhs . addDef ( eq ) ; if ( EAGER && eq . evaluate ( ) ) changedCell ( lhs ) ; }
static public Iso639 find ( String lang ) { Iso639 rslt = ( Iso639 ) all . get ( lang ) ; if ( rslt == null ) { if ( lang != null && lang . compareTo ( STRING ) >= _NUM && lang . compareTo ( STRING ) <= _NUM && lang . length ( ) == _NUM ) { return new Iso639 ( STRING , null , lang , lang , LT_LOCAL_USE ) ; } } return rslt ; }
private double calcUtil4Performing ( final double typDuration , final double actualDuration ) { return _NUM * marginalUtilPerformingSec + marginalUtilPerformingSec * typDuration * Math . log ( actualDuration / typDuration ) ; }
private double calcUtil4Performing ( final double typDuration , final double actualDuration ) { return _NUM * marginalUtilPerformingSec + marginalUtilPerformingSec * typDuration * Math . log ( actualDuration / typDuration ) ; }
protected boolean isTransactionInAdvanceOfInstallment ( final int currentInstallmentIndex , final List < LoanRepaymentScheduleInstallment > installments , final LocalDate transactionDate , @ SuppressWarnings ( STRING ) final Money transactionAmount ) { final LoanRepaymentScheduleInstallment currentInstallment = installments . get ( currentInstallmentIndex ) ; return transactionDate . isBefore ( currentInstallment . getDueDate ( ) ) ; }
public void insertSleepTime ( ) { ScriptStep sleepTimeScriptStep = ScriptStepFactory . createSleepTime ( getSleepTime ( ) ) ; steps . add ( getInsertIndex ( ) , sleepTimeScriptStep ) ; sleepTime = STRING ; reindexScriptSteps ( ) ; }
public int size ( ) { return children . size ( ) ; }
SamlFederationHandler ( Map < String , String > attributeMapping , String subjectMapping , String authnContextDelimiter , String authnContext , String sessionIndexMapping , String redirectURI , String logoutURI , String assertionConsumerEndpoint , String sPinitiatedSSOEndpoint , String singleLogoutEndpoint , String singleLogoutEndpointSoap , String sPinitiatedSLOEndpoint ) { this . attributeMapping = Collections . unmodifiableMap ( attributeMapping ) ; this . subjectMapping = subjectMapping ; this . authnContextDelimiter = authnContextDelimiter ; this . authnContext = authnContext ; this . sessionIndexMapping = sessionIndexMapping ; this . redirectURI = redirectURI ; this . logoutURI = logoutURI ; this . assertionConsumerEndpoint = assertionConsumerEndpoint ; this . sPinitiatedSSOEndpoint = sPinitiatedSSOEndpoint ; this . singleLogoutEndpoint = singleLogoutEndpoint ; this . singleLogoutEndpointSoap = singleLogoutEndpointSoap ; this . sPinitiatedSLOEndpoint = sPinitiatedSLOEndpoint ; }
@ Override public void incomingObject ( IAnalyzedInterval analyzedInterval ) throws AdeException { if ( ! m_percentilesWithEmptyIntervals && analyzedInterval . getNumUniqueMessageIds ( ) == _NUM ) { return ; } final double rawScore = calcRawScore ( analyzedInterval ) ; if ( ! SeenHugeLogProb ( analyzedInterval ) ) { m_rawScores . add ( rawScore ) ; ++ m_intervalCount ; } }
@ Override public void incomingObject ( IAnalyzedInterval analyzedInterval ) throws AdeException { if ( ! m_percentilesWithEmptyIntervals && analyzedInterval . getNumUniqueMessageIds ( ) == _NUM ) { return ; } final double rawScore = calcRawScore ( analyzedInterval ) ; if ( ! SeenHugeLogProb ( analyzedInterval ) ) { m_rawScores . add ( rawScore ) ; ++ m_intervalCount ; } }
@ Override public void incomingObject ( IAnalyzedInterval analyzedInterval ) throws AdeException { if ( ! m_percentilesWithEmptyIntervals && analyzedInterval . getNumUniqueMessageIds ( ) == _NUM ) { return ; } final double rawScore = calcRawScore ( analyzedInterval ) ; if ( ! SeenHugeLogProb ( analyzedInterval ) ) { m_rawScores . add ( rawScore ) ; ++ m_intervalCount ; } }
@ Override public void incomingObject ( IAnalyzedInterval analyzedInterval ) throws AdeException { if ( ! m_percentilesWithEmptyIntervals && analyzedInterval . getNumUniqueMessageIds ( ) == _NUM ) { return ; } final double rawScore = calcRawScore ( analyzedInterval ) ; if ( ! SeenHugeLogProb ( analyzedInterval ) ) { m_rawScores . add ( rawScore ) ; ++ m_intervalCount ; } }
@ Override public void incomingObject ( IAnalyzedInterval analyzedInterval ) throws AdeException { if ( ! m_percentilesWithEmptyIntervals && analyzedInterval . getNumUniqueMessageIds ( ) == _NUM ) { return ; } final double rawScore = calcRawScore ( analyzedInterval ) ; if ( ! SeenHugeLogProb ( analyzedInterval ) ) { m_rawScores . add ( rawScore ) ; ++ m_intervalCount ; } }
private void fillXMLAttribute ( Attributes att , int index ) { fillQName ( fAttributeQName , att . getURI ( index ) , att . getLocalName ( index ) , att . getQName ( index ) ) ; String type = att . getType ( index ) ; fAttributes . addAttributeNS ( fAttributeQName , ( type != null ) ? type : XMLSymbols . fCDATASymbol , att . getValue ( index ) ) ; }
public void close ( ) throws IOException { ServerSocketChannel ss = _ss ; _ss = ss ; if ( ss != null ) { try { ss . close ( ) ; } catch ( Exception e ) { } } }
public void ivrZonesetName ( String zonesetName , boolean activate ) throws NetworkDeviceControllerException { ivrZoneName ( _BOOL , zonesetName , activate , _BOOL ) ; }
public void ivrZonesetName ( String zonesetName , boolean activate ) throws NetworkDeviceControllerException { ivrZoneName ( _BOOL , zonesetName , activate , _BOOL ) ; }
public static VolumeGroupRestRep map ( VolumeGroup from ) { if ( from == null ) { return null ; } VolumeGroupRestRep rep = new VolumeGroupRestRep ( ) ; mapDataObjectFields ( from , rep ) ; rep . setDescription ( from . getDescription ( ) ) ; rep . setRoles ( from . getRoles ( ) ) ; rep . setParent ( toRelatedResource ( ResourceTypeEnum . VOLUME_GROUP , from . getParent ( ) ) ) ; rep . setMigrationGroupBy ( from . getMigrationGroupBy ( ) ) ; rep . setMigrationType ( from . getMigrationType ( ) ) ; return rep ; }
public static VolumeGroupRestRep map ( VolumeGroup from ) { if ( from == null ) { return null ; } VolumeGroupRestRep rep = new VolumeGroupRestRep ( ) ; mapDataObjectFields ( from , rep ) ; rep . setDescription ( from . getDescription ( ) ) ; rep . setRoles ( from . getRoles ( ) ) ; rep . setParent ( toRelatedResource ( ResourceTypeEnum . VOLUME_GROUP , from . getParent ( ) ) ) ; rep . setMigrationGroupBy ( from . getMigrationGroupBy ( ) ) ; rep . setMigrationType ( from . getMigrationType ( ) ) ; return rep ; }
public static byte [ ] copyRange ( byte [ ] orig , int from , int to ) { int length = to - from ; byte [ ] result = new byte [ length ] ; int howMuchToCopy = orig . length - from < length ? orig . length - from : length ; System . arraycopy ( orig , from , result , _NUM , howMuchToCopy ) ; return result ; }
@ SuppressWarnings ( STRING ) public UniformGenerator ( Vector < String > values ) { _values = ( Vector < String > ) values . clone ( ) ; _laststring = null ; _gen = new UniformIntegerGenerator ( _NUM , values . size ( ) - _NUM ) ; }
@ SuppressWarnings ( STRING ) public UniformGenerator ( Vector < String > values ) { _values = ( Vector < String > ) values . clone ( ) ; _laststring = null ; _gen = new UniformIntegerGenerator ( _NUM , values . size ( ) - _NUM ) ; }
@ SuppressWarnings ( STRING ) public UniformGenerator ( Vector < String > values ) { _values = ( Vector < String > ) values . clone ( ) ; _laststring = null ; _gen = new UniformIntegerGenerator ( _NUM , values . size ( ) - _NUM ) ; }
@ SuppressWarnings ( STRING ) public UniformGenerator ( Vector < String > values ) { _values = ( Vector < String > ) values . clone ( ) ; _laststring = null ; _gen = new UniformIntegerGenerator ( _NUM , values . size ( ) - _NUM ) ; }
public void terminateServer ( ) { process . destroy ( ) ; }
protected double adjust ( double v ) { switch ( m_scale ) { case Constants . LOG_SCALE : return Math . pow ( _NUM , v ) ; case Constants . SQRT_SCALE : return v * v ; case Constants . LINEAR_SCALE : default : return v ; } }
public static Object [ ] mergeAndExtractParams ( Map < String , ? extends Object > globalConfig , Map < String , ? extends Object > localParams , Collection < String > ignoreParams , Map < String , ExternalResourceDescription > resources ) { Set < String > uniqueParams = new HashSet < > ( ) ; uniqueParams . addAll ( localParams . keySet ( ) ) ; uniqueParams . addAll ( globalConfig . keySet ( ) ) ; if ( ignoreParams != null ) { uniqueParams . removeAll ( ignoreParams ) ; } Object [ ] params = new Object [ resources . size ( ) * _NUM + uniqueParams . size ( ) * _NUM ] ; int i = _NUM ; for ( Entry < String , ExternalResourceDescription > entry : resources . entrySet ( ) ) { params [ i ++ ] = entry . getKey ( ) ; params [ i ++ ] = entry . getValue ( ) ; } for ( String key : uniqueParams ) { params [ i ++ ] = key ; if ( localParams . containsKey ( key ) ) { params [ i ++ ] = CpeBuilderUtils . convertToParameterValue ( localParams . get ( key ) ) ; } else { params [ i ++ ] = CpeBuilderUtils . convertToParameterValue ( globalConfig . get ( key ) ) ; } } return params ; }
public static Object [ ] mergeAndExtractParams ( Map < String , ? extends Object > globalConfig , Map < String , ? extends Object > localParams , Collection < String > ignoreParams , Map < String , ExternalResourceDescription > resources ) { Set < String > uniqueParams = new HashSet < > ( ) ; uniqueParams . addAll ( localParams . keySet ( ) ) ; uniqueParams . addAll ( globalConfig . keySet ( ) ) ; if ( ignoreParams != null ) { uniqueParams . removeAll ( ignoreParams ) ; } Object [ ] params = new Object [ resources . size ( ) * _NUM + uniqueParams . size ( ) * _NUM ] ; int i = _NUM ; for ( Entry < String , ExternalResourceDescription > entry : resources . entrySet ( ) ) { params [ i ++ ] = entry . getKey ( ) ; params [ i ++ ] = entry . getValue ( ) ; } for ( String key : uniqueParams ) { params [ i ++ ] = key ; if ( localParams . containsKey ( key ) ) { params [ i ++ ] = CpeBuilderUtils . convertToParameterValue ( localParams . get ( key ) ) ; } else { params [ i ++ ] = CpeBuilderUtils . convertToParameterValue ( globalConfig . get ( key ) ) ; } } return params ; }
public static Object [ ] mergeAndExtractParams ( Map < String , ? extends Object > globalConfig , Map < String , ? extends Object > localParams , Collection < String > ignoreParams , Map < String , ExternalResourceDescription > resources ) { Set < String > uniqueParams = new HashSet < > ( ) ; uniqueParams . addAll ( localParams . keySet ( ) ) ; uniqueParams . addAll ( globalConfig . keySet ( ) ) ; if ( ignoreParams != null ) { uniqueParams . removeAll ( ignoreParams ) ; } Object [ ] params = new Object [ resources . size ( ) * _NUM + uniqueParams . size ( ) * _NUM ] ; int i = _NUM ; for ( Entry < String , ExternalResourceDescription > entry : resources . entrySet ( ) ) { params [ i ++ ] = entry . getKey ( ) ; params [ i ++ ] = entry . getValue ( ) ; } for ( String key : uniqueParams ) { params [ i ++ ] = key ; if ( localParams . containsKey ( key ) ) { params [ i ++ ] = CpeBuilderUtils . convertToParameterValue ( localParams . get ( key ) ) ; } else { params [ i ++ ] = CpeBuilderUtils . convertToParameterValue ( globalConfig . get ( key ) ) ; } } return params ; }
public static Object [ ] mergeAndExtractParams ( Map < String , ? extends Object > globalConfig , Map < String , ? extends Object > localParams , Collection < String > ignoreParams , Map < String , ExternalResourceDescription > resources ) { Set < String > uniqueParams = new HashSet < > ( ) ; uniqueParams . addAll ( localParams . keySet ( ) ) ; uniqueParams . addAll ( globalConfig . keySet ( ) ) ; if ( ignoreParams != null ) { uniqueParams . removeAll ( ignoreParams ) ; } Object [ ] params = new Object [ resources . size ( ) * _NUM + uniqueParams . size ( ) * _NUM ] ; int i = _NUM ; for ( Entry < String , ExternalResourceDescription > entry : resources . entrySet ( ) ) { params [ i ++ ] = entry . getKey ( ) ; params [ i ++ ] = entry . getValue ( ) ; } for ( String key : uniqueParams ) { params [ i ++ ] = key ; if ( localParams . containsKey ( key ) ) { params [ i ++ ] = CpeBuilderUtils . convertToParameterValue ( localParams . get ( key ) ) ; } else { params [ i ++ ] = CpeBuilderUtils . convertToParameterValue ( globalConfig . get ( key ) ) ; } } return params ; }
public static Object [ ] mergeAndExtractParams ( Map < String , ? extends Object > globalConfig , Map < String , ? extends Object > localParams , Collection < String > ignoreParams , Map < String , ExternalResourceDescription > resources ) { Set < String > uniqueParams = new HashSet < > ( ) ; uniqueParams . addAll ( localParams . keySet ( ) ) ; uniqueParams . addAll ( globalConfig . keySet ( ) ) ; if ( ignoreParams != null ) { uniqueParams . removeAll ( ignoreParams ) ; } Object [ ] params = new Object [ resources . size ( ) * _NUM + uniqueParams . size ( ) * _NUM ] ; int i = _NUM ; for ( Entry < String , ExternalResourceDescription > entry : resources . entrySet ( ) ) { params [ i ++ ] = entry . getKey ( ) ; params [ i ++ ] = entry . getValue ( ) ; } for ( String key : uniqueParams ) { params [ i ++ ] = key ; if ( localParams . containsKey ( key ) ) { params [ i ++ ] = CpeBuilderUtils . convertToParameterValue ( localParams . get ( key ) ) ; } else { params [ i ++ ] = CpeBuilderUtils . convertToParameterValue ( globalConfig . get ( key ) ) ; } } return params ; }
public static Object [ ] mergeAndExtractParams ( Map < String , ? extends Object > globalConfig , Map < String , ? extends Object > localParams , Collection < String > ignoreParams , Map < String , ExternalResourceDescription > resources ) { Set < String > uniqueParams = new HashSet < > ( ) ; uniqueParams . addAll ( localParams . keySet ( ) ) ; uniqueParams . addAll ( globalConfig . keySet ( ) ) ; if ( ignoreParams != null ) { uniqueParams . removeAll ( ignoreParams ) ; } Object [ ] params = new Object [ resources . size ( ) * _NUM + uniqueParams . size ( ) * _NUM ] ; int i = _NUM ; for ( Entry < String , ExternalResourceDescription > entry : resources . entrySet ( ) ) { params [ i ++ ] = entry . getKey ( ) ; params [ i ++ ] = entry . getValue ( ) ; } for ( String key : uniqueParams ) { params [ i ++ ] = key ; if ( localParams . containsKey ( key ) ) { params [ i ++ ] = CpeBuilderUtils . convertToParameterValue ( localParams . get ( key ) ) ; } else { params [ i ++ ] = CpeBuilderUtils . convertToParameterValue ( globalConfig . get ( key ) ) ; } } return params ; }
private static String createBcryptString ( byte [ ] password , byte [ ] salt , int cost ) { StringBuffer sb = new StringBuffer ( _NUM ) ; sb . append ( STRING ) ; sb . append ( version ) ; sb . append ( STRING ) ; sb . append ( cost < _NUM ? ( STRING + cost ) : Integer . toString ( cost ) ) ; sb . append ( STRING ) ; sb . append ( encodeData ( salt ) ) ; byte [ ] key = BCrypt . generate ( password , salt , cost ) ; sb . append ( encodeData ( key ) ) ; return sb . toString ( ) ; }
@ RequestMapping ( value = STRING , method = { RequestMethod . GET , RequestMethod . POST } ) public void ssoSSLDummy ( Locale locale , Model model , @ PathVariable ( value = STRING ) String tenant , HttpServletRequest request , HttpServletResponse response ) throws IOException { logger . info ( STRING + tenant ) ; try { RelyingParty rp = validateRelyingParty ( request , tenant ) ; if ( rp != null ) { logger . info ( STRING + rp . getUrl ( ) ) ; URL rpUrl = new URL ( rp . getUrl ( ) ) ; URL redirectUrl = new URL ( rpUrl . getProtocol ( ) , rpUrl . getHost ( ) , rpUrl . getPort ( ) , STRING ) ; String redirectUrlStr = redirectUrl . toString ( ) + STRING + ssoSSLDummyQueryString ( request ) ; response . sendRedirect ( redirectUrlStr ) ; } else { logger . error ( STRING + tenant + STRING ) ; sendError ( locale , response , STRING ) ; } } catch ( Exception e ) { logger . error ( STRING , e ) ; sendError ( locale , response , e . getLocalizedMessage ( ) ) ; } }
@ RequestMapping ( value = STRING , method = { RequestMethod . GET , RequestMethod . POST } ) public void ssoSSLDummy ( Locale locale , Model model , @ PathVariable ( value = STRING ) String tenant , HttpServletRequest request , HttpServletResponse response ) throws IOException { logger . info ( STRING + tenant ) ; try { RelyingParty rp = validateRelyingParty ( request , tenant ) ; if ( rp != null ) { logger . info ( STRING + rp . getUrl ( ) ) ; URL rpUrl = new URL ( rp . getUrl ( ) ) ; URL redirectUrl = new URL ( rpUrl . getProtocol ( ) , rpUrl . getHost ( ) , rpUrl . getPort ( ) , STRING ) ; String redirectUrlStr = redirectUrl . toString ( ) + STRING + ssoSSLDummyQueryString ( request ) ; response . sendRedirect ( redirectUrlStr ) ; } else { logger . error ( STRING + tenant + STRING ) ; sendError ( locale , response , STRING ) ; } } catch ( Exception e ) { logger . error ( STRING , e ) ; sendError ( locale , response , e . getLocalizedMessage ( ) ) ; } }
@ RequestMapping ( value = STRING , method = { RequestMethod . GET , RequestMethod . POST } ) public void ssoSSLDummy ( Locale locale , Model model , @ PathVariable ( value = STRING ) String tenant , HttpServletRequest request , HttpServletResponse response ) throws IOException { logger . info ( STRING + tenant ) ; try { RelyingParty rp = validateRelyingParty ( request , tenant ) ; if ( rp != null ) { logger . info ( STRING + rp . getUrl ( ) ) ; URL rpUrl = new URL ( rp . getUrl ( ) ) ; URL redirectUrl = new URL ( rpUrl . getProtocol ( ) , rpUrl . getHost ( ) , rpUrl . getPort ( ) , STRING ) ; String redirectUrlStr = redirectUrl . toString ( ) + STRING + ssoSSLDummyQueryString ( request ) ; response . sendRedirect ( redirectUrlStr ) ; } else { logger . error ( STRING + tenant + STRING ) ; sendError ( locale , response , STRING ) ; } } catch ( Exception e ) { logger . error ( STRING , e ) ; sendError ( locale , response , e . getLocalizedMessage ( ) ) ; } }
@ RequestMapping ( value = STRING , method = { RequestMethod . GET , RequestMethod . POST } ) public void ssoSSLDummy ( Locale locale , Model model , @ PathVariable ( value = STRING ) String tenant , HttpServletRequest request , HttpServletResponse response ) throws IOException { logger . info ( STRING + tenant ) ; try { RelyingParty rp = validateRelyingParty ( request , tenant ) ; if ( rp != null ) { logger . info ( STRING + rp . getUrl ( ) ) ; URL rpUrl = new URL ( rp . getUrl ( ) ) ; URL redirectUrl = new URL ( rpUrl . getProtocol ( ) , rpUrl . getHost ( ) , rpUrl . getPort ( ) , STRING ) ; String redirectUrlStr = redirectUrl . toString ( ) + STRING + ssoSSLDummyQueryString ( request ) ; response . sendRedirect ( redirectUrlStr ) ; } else { logger . error ( STRING + tenant + STRING ) ; sendError ( locale , response , STRING ) ; } } catch ( Exception e ) { logger . error ( STRING , e ) ; sendError ( locale , response , e . getLocalizedMessage ( ) ) ; } }
@ RequestMapping ( value = STRING , method = { RequestMethod . GET , RequestMethod . POST } ) public void ssoSSLDummy ( Locale locale , Model model , @ PathVariable ( value = STRING ) String tenant , HttpServletRequest request , HttpServletResponse response ) throws IOException { logger . info ( STRING + tenant ) ; try { RelyingParty rp = validateRelyingParty ( request , tenant ) ; if ( rp != null ) { logger . info ( STRING + rp . getUrl ( ) ) ; URL rpUrl = new URL ( rp . getUrl ( ) ) ; URL redirectUrl = new URL ( rpUrl . getProtocol ( ) , rpUrl . getHost ( ) , rpUrl . getPort ( ) , STRING ) ; String redirectUrlStr = redirectUrl . toString ( ) + STRING + ssoSSLDummyQueryString ( request ) ; response . sendRedirect ( redirectUrlStr ) ; } else { logger . error ( STRING + tenant + STRING ) ; sendError ( locale , response , STRING ) ; } } catch ( Exception e ) { logger . error ( STRING , e ) ; sendError ( locale , response , e . getLocalizedMessage ( ) ) ; } }
@ RequestMapping ( value = STRING , method = { RequestMethod . GET , RequestMethod . POST } ) public void ssoSSLDummy ( Locale locale , Model model , @ PathVariable ( value = STRING ) String tenant , HttpServletRequest request , HttpServletResponse response ) throws IOException { logger . info ( STRING + tenant ) ; try { RelyingParty rp = validateRelyingParty ( request , tenant ) ; if ( rp != null ) { logger . info ( STRING + rp . getUrl ( ) ) ; URL rpUrl = new URL ( rp . getUrl ( ) ) ; URL redirectUrl = new URL ( rpUrl . getProtocol ( ) , rpUrl . getHost ( ) , rpUrl . getPort ( ) , STRING ) ; String redirectUrlStr = redirectUrl . toString ( ) + STRING + ssoSSLDummyQueryString ( request ) ; response . sendRedirect ( redirectUrlStr ) ; } else { logger . error ( STRING + tenant + STRING ) ; sendError ( locale , response , STRING ) ; } } catch ( Exception e ) { logger . error ( STRING , e ) ; sendError ( locale , response , e . getLocalizedMessage ( ) ) ; } }
private AppliedMigration createAppliedSchemaMigration ( ) { return new AppliedMigration ( _NUM , _NUM , MigrationVersion . fromVersion ( Integer . toString ( _NUM ) ) , STRING , MigrationType . SCHEMA , STRING , null , new Date ( ) , STRING , _NUM , _BOOL ) ; }
private AppliedMigration createAppliedSchemaMigration ( ) { return new AppliedMigration ( _NUM , _NUM , MigrationVersion . fromVersion ( Integer . toString ( _NUM ) ) , STRING , MigrationType . SCHEMA , STRING , null , new Date ( ) , STRING , _NUM , _BOOL ) ; }
private void selectSupersededForms ( ) { ListView ls = getListView ( ) ; for ( int idx = _NUM ; idx < mFormList . size ( ) ; idx ++ ) { HashMap < String , String > item = mFormList . get ( idx ) ; if ( isLocalFormSuperseded ( item . get ( FORM_ID_KEY ) , item . get ( FORM_VERSION_KEY ) ) ) { ls . setItemChecked ( idx , _BOOL ) ; } } }
private void selectSupersededForms ( ) { ListView ls = getListView ( ) ; for ( int idx = _NUM ; idx < mFormList . size ( ) ; idx ++ ) { HashMap < String , String > item = mFormList . get ( idx ) ; if ( isLocalFormSuperseded ( item . get ( FORM_ID_KEY ) , item . get ( FORM_VERSION_KEY ) ) ) { ls . setItemChecked ( idx , _BOOL ) ; } } }
private void selectSupersededForms ( ) { ListView ls = getListView ( ) ; for ( int idx = _NUM ; idx < mFormList . size ( ) ; idx ++ ) { HashMap < String , String > item = mFormList . get ( idx ) ; if ( isLocalFormSuperseded ( item . get ( FORM_ID_KEY ) , item . get ( FORM_VERSION_KEY ) ) ) { ls . setItemChecked ( idx , _BOOL ) ; } } }
private void selectSupersededForms ( ) { ListView ls = getListView ( ) ; for ( int idx = _NUM ; idx < mFormList . size ( ) ; idx ++ ) { HashMap < String , String > item = mFormList . get ( idx ) ; if ( isLocalFormSuperseded ( item . get ( FORM_ID_KEY ) , item . get ( FORM_VERSION_KEY ) ) ) { ls . setItemChecked ( idx , _BOOL ) ; } } }
private void selectSupersededForms ( ) { ListView ls = getListView ( ) ; for ( int idx = _NUM ; idx < mFormList . size ( ) ; idx ++ ) { HashMap < String , String > item = mFormList . get ( idx ) ; if ( isLocalFormSuperseded ( item . get ( FORM_ID_KEY ) , item . get ( FORM_VERSION_KEY ) ) ) { ls . setItemChecked ( idx , _BOOL ) ; } } }
private void selectSupersededForms ( ) { ListView ls = getListView ( ) ; for ( int idx = _NUM ; idx < mFormList . size ( ) ; idx ++ ) { HashMap < String , String > item = mFormList . get ( idx ) ; if ( isLocalFormSuperseded ( item . get ( FORM_ID_KEY ) , item . get ( FORM_VERSION_KEY ) ) ) { ls . setItemChecked ( idx , _BOOL ) ; } } }
public void remove ( final Channel channel ) { synchronized ( channels ) { for ( final Iterator chanIter = channels . iterator ( ) ; chanIter . hasNext ( ) ; ) { if ( chanIter . next ( ) == channel ) { chanIter . remove ( ) ; break ; } } } }
public void removeChannelMap ( ChannelMap channelMap ) { if ( mChannelMaps . contains ( channelMap ) ) { int index = mChannelMaps . indexOf ( channelMap ) ; mChannelMaps . remove ( channelMap ) ; fireIntervalRemoved ( this , index , index ) ; broadcast ( new ChannelMapEvent ( channelMap , Event . DELETE ) ) ; } }
public PhoneDurationsImpl ( URL url ) throws IOException { BufferedReader reader ; String line ; phoneDurations = new HashMap ( ) ; reader = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; line = reader . readLine ( ) ; while ( line != null ) { if ( ! line . startsWith ( STRING ) ) { parseAndAdd ( line ) ; } line = reader . readLine ( ) ; } reader . close ( ) ; }
public PhoneDurationsImpl ( URL url ) throws IOException { BufferedReader reader ; String line ; phoneDurations = new HashMap ( ) ; reader = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; line = reader . readLine ( ) ; while ( line != null ) { if ( ! line . startsWith ( STRING ) ) { parseAndAdd ( line ) ; } line = reader . readLine ( ) ; } reader . close ( ) ; }
private static SupportedGroup negotiateNamedCurve ( ClientHello clientHello ) { SupportedGroup result = null ; List < SupportedGroup > preferredGroups = SupportedGroup . getPreferredGroups ( ) ; SupportedEllipticCurvesExtension extension = clientHello . getSupportedEllipticCurvesExtension ( ) ; if ( extension == null ) { if ( ! preferredGroups . isEmpty ( ) ) { result = preferredGroups . get ( _NUM ) ; } } else { for ( Integer preferredGroupId : extension . getSupportedGroupIds ( ) ) { SupportedGroup group = SupportedGroup . fromId ( preferredGroupId ) ; if ( group != null && group . isUsable ( ) && preferredGroups . contains ( group ) ) { result = group ; break ; } } } return result ; }
public CannotFindMethodException ( SootClass clz , SootMethodRef method ) { super ( String . format ( STRING , method , clz ) ) ; }
public static String generateStringFromTemplate ( File templateFile , Map < String , Object > parameters ) { try { Template template = getTemplate ( templateFile ) ; Writable finishedTemplate = template . make ( parameters ) ; return finishedTemplate . toString ( ) ; } catch ( Exception e ) { DocReporter . printError ( STRING + templateFile ) ; DocReporter . printError ( e . getMessage ( ) ) ; throw new RuntimeException ( e ) ; } }
public static String generateStringFromTemplate ( File templateFile , Map < String , Object > parameters ) { try { Template template = getTemplate ( templateFile ) ; Writable finishedTemplate = template . make ( parameters ) ; return finishedTemplate . toString ( ) ; } catch ( Exception e ) { DocReporter . printError ( STRING + templateFile ) ; DocReporter . printError ( e . getMessage ( ) ) ; throw new RuntimeException ( e ) ; } }
public Object extractHardRef ( Object o ) { SoftReference w = ( SoftReference ) o ; if ( w != null ) { return w . get ( ) ; } return null ; }
public void clean ( ObjID [ ] ids , long sequenceNum , VMID vmid , boolean strong ) { for ( ObjID id : ids ) { if ( dgcLog . isLoggable ( Log . VERBOSE ) ) { dgcLog . log ( Log . VERBOSE , STRING + id + STRING + vmid + STRING + strong ) ; } ObjectTable . unreferenced ( id , sequenceNum , vmid , strong ) ; } }
public void clean ( ObjID [ ] ids , long sequenceNum , VMID vmid , boolean strong ) { for ( ObjID id : ids ) { if ( dgcLog . isLoggable ( Log . VERBOSE ) ) { dgcLog . log ( Log . VERBOSE , STRING + id + STRING + vmid + STRING + strong ) ; } ObjectTable . unreferenced ( id , sequenceNum , vmid , strong ) ; } }
public void clean ( ObjID [ ] ids , long sequenceNum , VMID vmid , boolean strong ) { for ( ObjID id : ids ) { if ( dgcLog . isLoggable ( Log . VERBOSE ) ) { dgcLog . log ( Log . VERBOSE , STRING + id + STRING + vmid + STRING + strong ) ; } ObjectTable . unreferenced ( id , sequenceNum , vmid , strong ) ; } }
public void clean ( ObjID [ ] ids , long sequenceNum , VMID vmid , boolean strong ) { for ( ObjID id : ids ) { if ( dgcLog . isLoggable ( Log . VERBOSE ) ) { dgcLog . log ( Log . VERBOSE , STRING + id + STRING + vmid + STRING + strong ) ; } ObjectTable . unreferenced ( id , sequenceNum , vmid , strong ) ; } }
public void clean ( ObjID [ ] ids , long sequenceNum , VMID vmid , boolean strong ) { for ( ObjID id : ids ) { if ( dgcLog . isLoggable ( Log . VERBOSE ) ) { dgcLog . log ( Log . VERBOSE , STRING + id + STRING + vmid + STRING + strong ) ; } ObjectTable . unreferenced ( id , sequenceNum , vmid , strong ) ; } }
public void clean ( ObjID [ ] ids , long sequenceNum , VMID vmid , boolean strong ) { for ( ObjID id : ids ) { if ( dgcLog . isLoggable ( Log . VERBOSE ) ) { dgcLog . log ( Log . VERBOSE , STRING + id + STRING + vmid + STRING + strong ) ; } ObjectTable . unreferenced ( id , sequenceNum , vmid , strong ) ; } }
public void clean ( ObjID [ ] ids , long sequenceNum , VMID vmid , boolean strong ) { for ( ObjID id : ids ) { if ( dgcLog . isLoggable ( Log . VERBOSE ) ) { dgcLog . log ( Log . VERBOSE , STRING + id + STRING + vmid + STRING + strong ) ; } ObjectTable . unreferenced ( id , sequenceNum , vmid , strong ) ; } }
public boolean equalsIgnoreCase ( String string ) { if ( string == this ) { return _BOOL ; } if ( string == null || count != string . count ) { return _BOOL ; } int o1 = offset , o2 = string . offset ; int end = offset + count ; char c1 , c2 ; char [ ] target = string . value ; while ( o1 < end ) { if ( ( c1 = value [ o1 ++ ] ) != ( c2 = target [ o2 ++ ] ) && Character . toUpperCase ( c1 ) != Character . toUpperCase ( c2 ) && Character . toLowerCase ( c1 ) != Character . toLowerCase ( c2 ) ) { return _BOOL ; } } return _BOOL ; }
public static void unregisterFieldPrefix ( final String prefix ) { fieldPrefixes . remove ( prefix ) ; }
public synchronized void insertChunkAuthTag ( int chunkIdx , byte [ ] chunkAuthTag ) throws FileEncryptionException { if ( chunkIdx < _NUM || chunkAuthTag == null || chunkAuthTag . length != CHUNK_AUTH_TAG_LENGTH ) { throw new FileEncryptionException ( STRING ) ; } else { if ( atagList . size ( ) <= chunkIdx ) { atagList . ensureCapacity ( chunkIdx + _NUM ) ; padTo ( atagList , chunkIdx ) ; atagList . add ( chunkIdx , Arrays . copyOf ( chunkAuthTag , CHUNK_AUTH_TAG_LENGTH ) ) ; } else { atagList . set ( chunkIdx , Arrays . copyOf ( chunkAuthTag , CHUNK_AUTH_TAG_LENGTH ) ) ; } } }
public synchronized void insertChunkAuthTag ( int chunkIdx , byte [ ] chunkAuthTag ) throws FileEncryptionException { if ( chunkIdx < _NUM || chunkAuthTag == null || chunkAuthTag . length != CHUNK_AUTH_TAG_LENGTH ) { throw new FileEncryptionException ( STRING ) ; } else { if ( atagList . size ( ) <= chunkIdx ) { atagList . ensureCapacity ( chunkIdx + _NUM ) ; padTo ( atagList , chunkIdx ) ; atagList . add ( chunkIdx , Arrays . copyOf ( chunkAuthTag , CHUNK_AUTH_TAG_LENGTH ) ) ; } else { atagList . set ( chunkIdx , Arrays . copyOf ( chunkAuthTag , CHUNK_AUTH_TAG_LENGTH ) ) ; } } }
public synchronized void insertChunkAuthTag ( int chunkIdx , byte [ ] chunkAuthTag ) throws FileEncryptionException { if ( chunkIdx < _NUM || chunkAuthTag == null || chunkAuthTag . length != CHUNK_AUTH_TAG_LENGTH ) { throw new FileEncryptionException ( STRING ) ; } else { if ( atagList . size ( ) <= chunkIdx ) { atagList . ensureCapacity ( chunkIdx + _NUM ) ; padTo ( atagList , chunkIdx ) ; atagList . add ( chunkIdx , Arrays . copyOf ( chunkAuthTag , CHUNK_AUTH_TAG_LENGTH ) ) ; } else { atagList . set ( chunkIdx , Arrays . copyOf ( chunkAuthTag , CHUNK_AUTH_TAG_LENGTH ) ) ; } } }
public synchronized void insertChunkAuthTag ( int chunkIdx , byte [ ] chunkAuthTag ) throws FileEncryptionException { if ( chunkIdx < _NUM || chunkAuthTag == null || chunkAuthTag . length != CHUNK_AUTH_TAG_LENGTH ) { throw new FileEncryptionException ( STRING ) ; } else { if ( atagList . size ( ) <= chunkIdx ) { atagList . ensureCapacity ( chunkIdx + _NUM ) ; padTo ( atagList , chunkIdx ) ; atagList . add ( chunkIdx , Arrays . copyOf ( chunkAuthTag , CHUNK_AUTH_TAG_LENGTH ) ) ; } else { atagList . set ( chunkIdx , Arrays . copyOf ( chunkAuthTag , CHUNK_AUTH_TAG_LENGTH ) ) ; } } }
public synchronized void insertChunkAuthTag ( int chunkIdx , byte [ ] chunkAuthTag ) throws FileEncryptionException { if ( chunkIdx < _NUM || chunkAuthTag == null || chunkAuthTag . length != CHUNK_AUTH_TAG_LENGTH ) { throw new FileEncryptionException ( STRING ) ; } else { if ( atagList . size ( ) <= chunkIdx ) { atagList . ensureCapacity ( chunkIdx + _NUM ) ; padTo ( atagList , chunkIdx ) ; atagList . add ( chunkIdx , Arrays . copyOf ( chunkAuthTag , CHUNK_AUTH_TAG_LENGTH ) ) ; } else { atagList . set ( chunkIdx , Arrays . copyOf ( chunkAuthTag , CHUNK_AUTH_TAG_LENGTH ) ) ; } } }
public void handleClientCommand ( String type , String [ ] params , Server server , Conversation conversation , IRCService service ) { BaseHandler command = null ; if ( commands . containsKey ( type . toLowerCase ( ) ) ) { command = commands . get ( type . toLowerCase ( ) ) ; } else if ( aliases . containsKey ( type . toLowerCase ( ) ) ) { String commandInCommands = aliases . get ( type . toLowerCase ( ) ) ; command = commands . get ( commandInCommands ) ; } try { command . execute ( params , server , conversation , service ) ; } catch ( CommandException e ) { if ( conversation != null ) { Message errorMessage = new Message ( type + STRING + e . getMessage ( ) ) ; errorMessage . setColor ( Message . COLOR_RED ) ; conversation . addMessage ( errorMessage ) ; Message usageMessage = new Message ( STRING + command . getUsage ( ) ) ; conversation . addMessage ( usageMessage ) ; Intent intent = Broadcast . createConversationIntent ( Broadcast . CONVERSATION_MESSAGE , server . getId ( ) , conversation . getName ( ) ) ; service . sendBroadcast ( intent ) ; } } }
protected void encodeLineSuffix ( OutputStream aStream ) throws IOException { pStream . println ( ) ; }
protected void encodeLineSuffix ( OutputStream aStream ) throws IOException { pStream . println ( ) ; }
protected void encodeLineSuffix ( OutputStream aStream ) throws IOException { pStream . println ( ) ; }
protected void encodeLineSuffix ( OutputStream aStream ) throws IOException { pStream . println ( ) ; }
protected void encodeLineSuffix ( OutputStream aStream ) throws IOException { pStream . println ( ) ; }
@ ExceptionHandler ( ObjectNotFoundException . class ) @ ResponseStatus ( value = HttpStatus . NOT_FOUND ) public @ ResponseBody ErrorResponse resolveDocumentNotFoundException ( ObjectNotFoundException e ) throws IOException { if ( logger . isLoggable ( Level . FINE ) ) logger . fine ( STRING + e . getMessage ( ) ) ; return new ErrorResponse ( new ErrorMessage ( e . getMessage ( ) ) ) ; }
@ ExceptionHandler ( ObjectNotFoundException . class ) @ ResponseStatus ( value = HttpStatus . NOT_FOUND ) public @ ResponseBody ErrorResponse resolveDocumentNotFoundException ( ObjectNotFoundException e ) throws IOException { if ( logger . isLoggable ( Level . FINE ) ) logger . fine ( STRING + e . getMessage ( ) ) ; return new ErrorResponse ( new ErrorMessage ( e . getMessage ( ) ) ) ; }
private void reportExceptionThrow ( Element element , Throwable t ) { if ( element != null ) { logMessage ( STRING , element ) ; } logException ( t ) ; errorMessage ( element , STRING , t , Arrays . toString ( Arrays . copyOf ( t . getStackTrace ( ) , _NUM ) ) ) ; }
private void reportExceptionThrow ( Element element , Throwable t ) { if ( element != null ) { logMessage ( STRING , element ) ; } logException ( t ) ; errorMessage ( element , STRING , t , Arrays . toString ( Arrays . copyOf ( t . getStackTrace ( ) , _NUM ) ) ) ; }
private void reportExceptionThrow ( Element element , Throwable t ) { if ( element != null ) { logMessage ( STRING , element ) ; } logException ( t ) ; errorMessage ( element , STRING , t , Arrays . toString ( Arrays . copyOf ( t . getStackTrace ( ) , _NUM ) ) ) ; }
private void reportExceptionThrow ( Element element , Throwable t ) { if ( element != null ) { logMessage ( STRING , element ) ; } logException ( t ) ; errorMessage ( element , STRING , t , Arrays . toString ( Arrays . copyOf ( t . getStackTrace ( ) , _NUM ) ) ) ; }
public double localScore ( int i ) { double sum = _NUM ; int count = _NUM ; for ( SemBicScore score : semBicScores ) { double _score = score . localScore ( i ) ; if ( ! Double . isNaN ( _score ) ) { sum += _score ; count ++ ; } } return sum / count ; }
public double localScore ( int i ) { double sum = _NUM ; int count = _NUM ; for ( SemBicScore score : semBicScores ) { double _score = score . localScore ( i ) ; if ( ! Double . isNaN ( _score ) ) { sum += _score ; count ++ ; } } return sum / count ; }
public double localScore ( int i ) { double sum = _NUM ; int count = _NUM ; for ( SemBicScore score : semBicScores ) { double _score = score . localScore ( i ) ; if ( ! Double . isNaN ( _score ) ) { sum += _score ; count ++ ; } } return sum / count ; }
public double localScore ( int i ) { double sum = _NUM ; int count = _NUM ; for ( SemBicScore score : semBicScores ) { double _score = score . localScore ( i ) ; if ( ! Double . isNaN ( _score ) ) { sum += _score ; count ++ ; } } return sum / count ; }
public void testConstructorBytesZero ( ) { byte aBytes [ ] = { _NUM , _NUM , _NUM , - _NUM , + _NUM , _NUM , - _NUM } ; byte rBytes [ ] = { _NUM } ; BigInteger aNumber = new BigInteger ( aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , aNumber . signum ( ) ) ; }
public static KindredSnippets [ ] toArray ( ArrayList < KindredSnippets > snippets ) { if ( snippets == null || snippets . isEmpty ( ) ) { return Empty ; } return snippets . toArray ( new KindredSnippets [ snippets . size ( ) ] ) ; }
public static KindredSnippets [ ] toArray ( ArrayList < KindredSnippets > snippets ) { if ( snippets == null || snippets . isEmpty ( ) ) { return Empty ; } return snippets . toArray ( new KindredSnippets [ snippets . size ( ) ] ) ; }
public static KindredSnippets [ ] toArray ( ArrayList < KindredSnippets > snippets ) { if ( snippets == null || snippets . isEmpty ( ) ) { return Empty ; } return snippets . toArray ( new KindredSnippets [ snippets . size ( ) ] ) ; }
public static void doRandomSleepOnFailedLoginAttempt ( AuthenticationInfo authenticationInfo ) { try { if ( authenticationInfo == null ) { authenticationInfo = SecurityHelper . loadAuthenticationInformation ( ) ; } int min = authenticationInfo . getMinWaitOnFailedLogin ( ) ; int max = authenticationInfo . getMaxWaitOnFailedLogin ( ) ; int increment = authenticationInfo . getIncrementStepWaitOnFailedLogin ( ) ; int randomNum = SecurityHelper . getRandomInt ( min , max , increment ) ; logger . info ( MessageFormat . format ( STRING , randomNum ) ) ; if ( randomNum > _NUM ) Thread . sleep ( randomNum ) ; } catch ( InterruptedException e ) { logger . error ( MessageFormat . format ( STRING , e ) ) ; } catch ( ConfigurationException e ) { logger . error ( MessageFormat . format ( STRING , e ) ) ; } }
public static void doRandomSleepOnFailedLoginAttempt ( AuthenticationInfo authenticationInfo ) { try { if ( authenticationInfo == null ) { authenticationInfo = SecurityHelper . loadAuthenticationInformation ( ) ; } int min = authenticationInfo . getMinWaitOnFailedLogin ( ) ; int max = authenticationInfo . getMaxWaitOnFailedLogin ( ) ; int increment = authenticationInfo . getIncrementStepWaitOnFailedLogin ( ) ; int randomNum = SecurityHelper . getRandomInt ( min , max , increment ) ; logger . info ( MessageFormat . format ( STRING , randomNum ) ) ; if ( randomNum > _NUM ) Thread . sleep ( randomNum ) ; } catch ( InterruptedException e ) { logger . error ( MessageFormat . format ( STRING , e ) ) ; } catch ( ConfigurationException e ) { logger . error ( MessageFormat . format ( STRING , e ) ) ; } }
public static void doRandomSleepOnFailedLoginAttempt ( AuthenticationInfo authenticationInfo ) { try { if ( authenticationInfo == null ) { authenticationInfo = SecurityHelper . loadAuthenticationInformation ( ) ; } int min = authenticationInfo . getMinWaitOnFailedLogin ( ) ; int max = authenticationInfo . getMaxWaitOnFailedLogin ( ) ; int increment = authenticationInfo . getIncrementStepWaitOnFailedLogin ( ) ; int randomNum = SecurityHelper . getRandomInt ( min , max , increment ) ; logger . info ( MessageFormat . format ( STRING , randomNum ) ) ; if ( randomNum > _NUM ) Thread . sleep ( randomNum ) ; } catch ( InterruptedException e ) { logger . error ( MessageFormat . format ( STRING , e ) ) ; } catch ( ConfigurationException e ) { logger . error ( MessageFormat . format ( STRING , e ) ) ; } }
private static void expungeStaleExceptions ( ) { for ( Object x ; ( x = exceptionTableRefQueue . poll ( ) ) != null ; ) { if ( x instanceof ExceptionNode ) { int hashCode = ( ( ExceptionNode ) x ) . hashCode ; ExceptionNode [ ] t = exceptionTable ; int i = hashCode & ( t . length - _NUM ) ; ExceptionNode e = t [ i ] ; ExceptionNode pred = null ; while ( e != null ) { ExceptionNode next = e . next ; if ( e == x ) { if ( pred == null ) t [ i ] = next ; else pred . next = next ; break ; } pred = e ; e = next ; } } } }
static private String BYTE_Min ( ) { byte tempValue = Byte . MIN_VALUE ; return String . valueOf ( tempValue ) ; }
protected boolean checkRelations ( CnATreeElement treeElement ) { return _BOOL ; }
protected boolean checkRelations ( CnATreeElement treeElement ) { return _BOOL ; }
protected boolean checkRelations ( CnATreeElement treeElement ) { return _BOOL ; }
protected boolean checkRelations ( CnATreeElement treeElement ) { return _BOOL ; }
protected boolean checkRelations ( CnATreeElement treeElement ) { return _BOOL ; }
protected boolean checkRelations ( CnATreeElement treeElement ) { return _BOOL ; }
public boolean downloadDirectoryExists ( ) { File file = new File ( getAbsoluteDirectoryPath ( ) ) ; return file . exists ( ) ; }
public boolean seek ( ByteBuffer byteBuffer ) { byte [ ] buffer = new byte [ FIELD_TAGID_LENGTH ] ; byteBuffer . get ( buffer , _NUM , FIELD_TAGID_LENGTH ) ; if ( ! ( Arrays . equals ( buffer , TAG_ID ) ) ) { return _BOOL ; } byteBuffer . position ( FIELD_TRACK_INDICATOR_POS ) ; if ( byteBuffer . get ( ) != END_OF_FIELD ) { return _BOOL ; } return byteBuffer . get ( ) != END_OF_FIELD ; }
public boolean seek ( ByteBuffer byteBuffer ) { byte [ ] buffer = new byte [ FIELD_TAGID_LENGTH ] ; byteBuffer . get ( buffer , _NUM , FIELD_TAGID_LENGTH ) ; if ( ! ( Arrays . equals ( buffer , TAG_ID ) ) ) { return _BOOL ; } byteBuffer . position ( FIELD_TRACK_INDICATOR_POS ) ; if ( byteBuffer . get ( ) != END_OF_FIELD ) { return _BOOL ; } return byteBuffer . get ( ) != END_OF_FIELD ; }
public boolean seek ( ByteBuffer byteBuffer ) { byte [ ] buffer = new byte [ FIELD_TAGID_LENGTH ] ; byteBuffer . get ( buffer , _NUM , FIELD_TAGID_LENGTH ) ; if ( ! ( Arrays . equals ( buffer , TAG_ID ) ) ) { return _BOOL ; } byteBuffer . position ( FIELD_TRACK_INDICATOR_POS ) ; if ( byteBuffer . get ( ) != END_OF_FIELD ) { return _BOOL ; } return byteBuffer . get ( ) != END_OF_FIELD ; }
public boolean seek ( ByteBuffer byteBuffer ) { byte [ ] buffer = new byte [ FIELD_TAGID_LENGTH ] ; byteBuffer . get ( buffer , _NUM , FIELD_TAGID_LENGTH ) ; if ( ! ( Arrays . equals ( buffer , TAG_ID ) ) ) { return _BOOL ; } byteBuffer . position ( FIELD_TRACK_INDICATOR_POS ) ; if ( byteBuffer . get ( ) != END_OF_FIELD ) { return _BOOL ; } return byteBuffer . get ( ) != END_OF_FIELD ; }
public void write ( char text [ ] , int offset , int length ) { if ( ( offset < _NUM ) || ( offset > text . length ) || ( length < _NUM ) || ( ( offset + length ) > text . length ) || ( ( offset + length ) < _NUM ) ) { throw new IndexOutOfBoundsException ( ) ; } else if ( length == _NUM ) { return ; } buffer . append ( text , offset , length ) ; }
public static void release ( ) { pcThreadLocal . set ( null ) ; }
public String createRandomFile ( String location ) { Random randomGenerator = new Random ( ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( STRING ) ; Date date = new Date ( ) ; final String filePath = location + dateFormat . format ( date ) + randomGenerator . nextInt ( _NUM ) ; Log . i ( TAG , STRING + location + STRING + filePath ) ; return filePath ; }
public void updateUI ( ) { if ( isAcceptAllFileFilterUsed ( ) ) { removeChoosableFileFilter ( getAcceptAllFileFilter ( ) ) ; } FileChooserUI ui = ( ( FileChooserUI ) UIManager . getUI ( this ) ) ; if ( fileSystemView == null ) { setFileSystemView ( FileSystemView . getFileSystemView ( ) ) ; } setUI ( ui ) ; if ( isAcceptAllFileFilterUsed ( ) ) { addChoosableFileFilter ( getAcceptAllFileFilter ( ) ) ; } }
public void updateUI ( ) { if ( isAcceptAllFileFilterUsed ( ) ) { removeChoosableFileFilter ( getAcceptAllFileFilter ( ) ) ; } FileChooserUI ui = ( ( FileChooserUI ) UIManager . getUI ( this ) ) ; if ( fileSystemView == null ) { setFileSystemView ( FileSystemView . getFileSystemView ( ) ) ; } setUI ( ui ) ; if ( isAcceptAllFileFilterUsed ( ) ) { addChoosableFileFilter ( getAcceptAllFileFilter ( ) ) ; } }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case _NUM : return ARG ; default : return null ; } }
public static void fixTabKeys ( final JComponent component ) { final Set < AWTKeyStroke > forward = new HashSet < AWTKeyStroke > ( component . getFocusTraversalKeys ( KeyboardFocusManager . FORWARD_TRAVERSAL_KEYS ) ) ; forward . add ( KeyStroke . getKeyStroke ( STRING ) ) ; component . setFocusTraversalKeys ( KeyboardFocusManager . FORWARD_TRAVERSAL_KEYS , forward ) ; final Set < AWTKeyStroke > backward = new HashSet < AWTKeyStroke > ( component . getFocusTraversalKeys ( KeyboardFocusManager . BACKWARD_TRAVERSAL_KEYS ) ) ; backward . add ( KeyStroke . getKeyStroke ( STRING ) ) ; component . setFocusTraversalKeys ( KeyboardFocusManager . BACKWARD_TRAVERSAL_KEYS , backward ) ; }
public static void fixTabKeys ( final JComponent component ) { final Set < AWTKeyStroke > forward = new HashSet < AWTKeyStroke > ( component . getFocusTraversalKeys ( KeyboardFocusManager . FORWARD_TRAVERSAL_KEYS ) ) ; forward . add ( KeyStroke . getKeyStroke ( STRING ) ) ; component . setFocusTraversalKeys ( KeyboardFocusManager . FORWARD_TRAVERSAL_KEYS , forward ) ; final Set < AWTKeyStroke > backward = new HashSet < AWTKeyStroke > ( component . getFocusTraversalKeys ( KeyboardFocusManager . BACKWARD_TRAVERSAL_KEYS ) ) ; backward . add ( KeyStroke . getKeyStroke ( STRING ) ) ; component . setFocusTraversalKeys ( KeyboardFocusManager . BACKWARD_TRAVERSAL_KEYS , backward ) ; }
public static void fixTabKeys ( final JComponent component ) { final Set < AWTKeyStroke > forward = new HashSet < AWTKeyStroke > ( component . getFocusTraversalKeys ( KeyboardFocusManager . FORWARD_TRAVERSAL_KEYS ) ) ; forward . add ( KeyStroke . getKeyStroke ( STRING ) ) ; component . setFocusTraversalKeys ( KeyboardFocusManager . FORWARD_TRAVERSAL_KEYS , forward ) ; final Set < AWTKeyStroke > backward = new HashSet < AWTKeyStroke > ( component . getFocusTraversalKeys ( KeyboardFocusManager . BACKWARD_TRAVERSAL_KEYS ) ) ; backward . add ( KeyStroke . getKeyStroke ( STRING ) ) ; component . setFocusTraversalKeys ( KeyboardFocusManager . BACKWARD_TRAVERSAL_KEYS , backward ) ; }
public static void fixTabKeys ( final JComponent component ) { final Set < AWTKeyStroke > forward = new HashSet < AWTKeyStroke > ( component . getFocusTraversalKeys ( KeyboardFocusManager . FORWARD_TRAVERSAL_KEYS ) ) ; forward . add ( KeyStroke . getKeyStroke ( STRING ) ) ; component . setFocusTraversalKeys ( KeyboardFocusManager . FORWARD_TRAVERSAL_KEYS , forward ) ; final Set < AWTKeyStroke > backward = new HashSet < AWTKeyStroke > ( component . getFocusTraversalKeys ( KeyboardFocusManager . BACKWARD_TRAVERSAL_KEYS ) ) ; backward . add ( KeyStroke . getKeyStroke ( STRING ) ) ; component . setFocusTraversalKeys ( KeyboardFocusManager . BACKWARD_TRAVERSAL_KEYS , backward ) ; }
public static void fixTabKeys ( final JComponent component ) { final Set < AWTKeyStroke > forward = new HashSet < AWTKeyStroke > ( component . getFocusTraversalKeys ( KeyboardFocusManager . FORWARD_TRAVERSAL_KEYS ) ) ; forward . add ( KeyStroke . getKeyStroke ( STRING ) ) ; component . setFocusTraversalKeys ( KeyboardFocusManager . FORWARD_TRAVERSAL_KEYS , forward ) ; final Set < AWTKeyStroke > backward = new HashSet < AWTKeyStroke > ( component . getFocusTraversalKeys ( KeyboardFocusManager . BACKWARD_TRAVERSAL_KEYS ) ) ; backward . add ( KeyStroke . getKeyStroke ( STRING ) ) ; component . setFocusTraversalKeys ( KeyboardFocusManager . BACKWARD_TRAVERSAL_KEYS , backward ) ; }
public static < T > long addAndGet ( AtomicLongFieldUpdater < T > updater , T instance , long n ) { for ( ; ; ) { long r = updater . get ( instance ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , n ) ; if ( updater . compareAndSet ( instance , r , u ) ) { return r ; } } }
public void addColumn ( ColumnInfo info ) { WTableColumn tableColumn ; tableColumn = new WTableColumn ( ) ; tableColumn . setHeaderValue ( Util . cleanAmp ( info . getColHeader ( ) ) ) ; setColumnVisibility ( tableColumn , info . getVisibility ( ) ) ; m_tableColumns . add ( tableColumn ) ; return ; }
public void addColumn ( ColumnInfo info ) { WTableColumn tableColumn ; tableColumn = new WTableColumn ( ) ; tableColumn . setHeaderValue ( Util . cleanAmp ( info . getColHeader ( ) ) ) ; setColumnVisibility ( tableColumn , info . getVisibility ( ) ) ; m_tableColumns . add ( tableColumn ) ; return ; }
public void addColumn ( ColumnInfo info ) { WTableColumn tableColumn ; tableColumn = new WTableColumn ( ) ; tableColumn . setHeaderValue ( Util . cleanAmp ( info . getColHeader ( ) ) ) ; setColumnVisibility ( tableColumn , info . getVisibility ( ) ) ; m_tableColumns . add ( tableColumn ) ; return ; }
public void addColumn ( ColumnInfo info ) { WTableColumn tableColumn ; tableColumn = new WTableColumn ( ) ; tableColumn . setHeaderValue ( Util . cleanAmp ( info . getColHeader ( ) ) ) ; setColumnVisibility ( tableColumn , info . getVisibility ( ) ) ; m_tableColumns . add ( tableColumn ) ; return ; }
public StrBuilder ensureCapacity ( int capacity ) { if ( capacity > buffer . length ) { char [ ] old = buffer ; buffer = new char [ capacity * _NUM ] ; System . arraycopy ( old , _NUM , buffer , _NUM , size ) ; } return this ; }
public LogStream printf ( String format , Object ... args ) { if ( ps != null ) { print ( String . format ( format , args ) ) ; } return this ; }
List createPolys ( int nItems , double size , int nPts ) { double overlapPct = _NUM ; int nCells = ( int ) Math . sqrt ( nItems ) ; List geoms = new ArrayList ( ) ; double width = nCells * ( _NUM - overlapPct ) * size ; double height = nCells * _NUM * size ; double xInc = width / nCells ; double yInc = height / nCells ; for ( int i = _NUM ; i < nCells ; i ++ ) { for ( int j = _NUM ; j < nCells ; j ++ ) { Coordinate base = new Coordinate ( i * xInc , j * yInc ) ; Geometry poly = createPoly ( base , size , nPts ) ; geoms . add ( poly ) ; } } return geoms ; }
public Image flipImageVertically ( Image image , boolean maintainOpacity ) { int [ ] rgb = image . getRGB ( ) ; int [ ] newRGB = new int [ rgb . length ] ; int width = image . getWidth ( ) ; int height = image . getHeight ( ) ; for ( int y = _NUM ; y < height ; y ++ ) { for ( int x = _NUM ; x < width ; x ++ ) { newRGB [ x + ( height - y - _NUM ) * width ] = rgb [ x + y * width ] ; } } return EncodedImage . createFromRGB ( newRGB , width , height , ! maintainOpacity ) ; }
public Image flipImageVertically ( Image image , boolean maintainOpacity ) { int [ ] rgb = image . getRGB ( ) ; int [ ] newRGB = new int [ rgb . length ] ; int width = image . getWidth ( ) ; int height = image . getHeight ( ) ; for ( int y = _NUM ; y < height ; y ++ ) { for ( int x = _NUM ; x < width ; x ++ ) { newRGB [ x + ( height - y - _NUM ) * width ] = rgb [ x + y * width ] ; } } return EncodedImage . createFromRGB ( newRGB , width , height , ! maintainOpacity ) ; }
public Diagnostic withUser ( User user ) { this . user = user ; return this ; }
public Diagnostic withUser ( User user ) { this . user = user ; return this ; }
public void addItemAtIndex ( T item , int index ) { if ( index <= items . size ( ) ) { items . add ( index , item ) ; fireDataChangedEvent ( DataChangedListener . ADDED , index ) ; } }
static public SdfMacro decodeInstruction ( SdfBuffer buff ) { SdfMacro m ; if ( ( m = ChannelStart . match ( buff ) ) != null ) { return m ; } else if ( ( m = SdlVersion . match ( buff ) ) != null ) { return m ; } else if ( ( m = SkemeStart . match ( buff ) ) != null ) { return m ; } else if ( ( m = GenerateTrigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = EndSound . match ( buff ) ) != null ) { return m ; } else if ( ( m = DelaySound . match ( buff ) ) != null ) { return m ; } else if ( ( m = SkipOnTrigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = InitiateSound . match ( buff ) ) != null ) { return m ; } else if ( ( m = MaskCompare . match ( buff ) ) != null ) { return m ; } else if ( ( m = LoadModifier . match ( buff ) ) != null ) { return m ; } else if ( ( m = BranchTo . match ( buff ) ) != null ) { return m ; } else if ( ( m = Play . match ( buff ) ) != null ) { return m ; } else if ( ( m = FourByteMacro . match ( buff ) ) != null ) { return m ; } else if ( ( m = TwoByteMacro . match ( buff ) ) != null ) { return m ; } log . warn ( STRING ) ; return null ; }
static public SdfMacro decodeInstruction ( SdfBuffer buff ) { SdfMacro m ; if ( ( m = ChannelStart . match ( buff ) ) != null ) { return m ; } else if ( ( m = SdlVersion . match ( buff ) ) != null ) { return m ; } else if ( ( m = SkemeStart . match ( buff ) ) != null ) { return m ; } else if ( ( m = GenerateTrigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = EndSound . match ( buff ) ) != null ) { return m ; } else if ( ( m = DelaySound . match ( buff ) ) != null ) { return m ; } else if ( ( m = SkipOnTrigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = InitiateSound . match ( buff ) ) != null ) { return m ; } else if ( ( m = MaskCompare . match ( buff ) ) != null ) { return m ; } else if ( ( m = LoadModifier . match ( buff ) ) != null ) { return m ; } else if ( ( m = BranchTo . match ( buff ) ) != null ) { return m ; } else if ( ( m = Play . match ( buff ) ) != null ) { return m ; } else if ( ( m = FourByteMacro . match ( buff ) ) != null ) { return m ; } else if ( ( m = TwoByteMacro . match ( buff ) ) != null ) { return m ; } log . warn ( STRING ) ; return null ; }
static public SdfMacro decodeInstruction ( SdfBuffer buff ) { SdfMacro m ; if ( ( m = ChannelStart . match ( buff ) ) != null ) { return m ; } else if ( ( m = SdlVersion . match ( buff ) ) != null ) { return m ; } else if ( ( m = SkemeStart . match ( buff ) ) != null ) { return m ; } else if ( ( m = GenerateTrigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = EndSound . match ( buff ) ) != null ) { return m ; } else if ( ( m = DelaySound . match ( buff ) ) != null ) { return m ; } else if ( ( m = SkipOnTrigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = InitiateSound . match ( buff ) ) != null ) { return m ; } else if ( ( m = MaskCompare . match ( buff ) ) != null ) { return m ; } else if ( ( m = LoadModifier . match ( buff ) ) != null ) { return m ; } else if ( ( m = BranchTo . match ( buff ) ) != null ) { return m ; } else if ( ( m = Play . match ( buff ) ) != null ) { return m ; } else if ( ( m = FourByteMacro . match ( buff ) ) != null ) { return m ; } else if ( ( m = TwoByteMacro . match ( buff ) ) != null ) { return m ; } log . warn ( STRING ) ; return null ; }
static public SdfMacro decodeInstruction ( SdfBuffer buff ) { SdfMacro m ; if ( ( m = ChannelStart . match ( buff ) ) != null ) { return m ; } else if ( ( m = SdlVersion . match ( buff ) ) != null ) { return m ; } else if ( ( m = SkemeStart . match ( buff ) ) != null ) { return m ; } else if ( ( m = GenerateTrigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = EndSound . match ( buff ) ) != null ) { return m ; } else if ( ( m = DelaySound . match ( buff ) ) != null ) { return m ; } else if ( ( m = SkipOnTrigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = InitiateSound . match ( buff ) ) != null ) { return m ; } else if ( ( m = MaskCompare . match ( buff ) ) != null ) { return m ; } else if ( ( m = LoadModifier . match ( buff ) ) != null ) { return m ; } else if ( ( m = BranchTo . match ( buff ) ) != null ) { return m ; } else if ( ( m = Play . match ( buff ) ) != null ) { return m ; } else if ( ( m = FourByteMacro . match ( buff ) ) != null ) { return m ; } else if ( ( m = TwoByteMacro . match ( buff ) ) != null ) { return m ; } log . warn ( STRING ) ; return null ; }
static public SdfMacro decodeInstruction ( SdfBuffer buff ) { SdfMacro m ; if ( ( m = ChannelStart . match ( buff ) ) != null ) { return m ; } else if ( ( m = SdlVersion . match ( buff ) ) != null ) { return m ; } else if ( ( m = SkemeStart . match ( buff ) ) != null ) { return m ; } else if ( ( m = GenerateTrigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = EndSound . match ( buff ) ) != null ) { return m ; } else if ( ( m = DelaySound . match ( buff ) ) != null ) { return m ; } else if ( ( m = SkipOnTrigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = InitiateSound . match ( buff ) ) != null ) { return m ; } else if ( ( m = MaskCompare . match ( buff ) ) != null ) { return m ; } else if ( ( m = LoadModifier . match ( buff ) ) != null ) { return m ; } else if ( ( m = BranchTo . match ( buff ) ) != null ) { return m ; } else if ( ( m = Play . match ( buff ) ) != null ) { return m ; } else if ( ( m = FourByteMacro . match ( buff ) ) != null ) { return m ; } else if ( ( m = TwoByteMacro . match ( buff ) ) != null ) { return m ; } log . warn ( STRING ) ; return null ; }
static public SdfMacro decodeInstruction ( SdfBuffer buff ) { SdfMacro m ; if ( ( m = ChannelStart . match ( buff ) ) != null ) { return m ; } else if ( ( m = SdlVersion . match ( buff ) ) != null ) { return m ; } else if ( ( m = SkemeStart . match ( buff ) ) != null ) { return m ; } else if ( ( m = GenerateTrigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = EndSound . match ( buff ) ) != null ) { return m ; } else if ( ( m = DelaySound . match ( buff ) ) != null ) { return m ; } else if ( ( m = SkipOnTrigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = InitiateSound . match ( buff ) ) != null ) { return m ; } else if ( ( m = MaskCompare . match ( buff ) ) != null ) { return m ; } else if ( ( m = LoadModifier . match ( buff ) ) != null ) { return m ; } else if ( ( m = BranchTo . match ( buff ) ) != null ) { return m ; } else if ( ( m = Play . match ( buff ) ) != null ) { return m ; } else if ( ( m = FourByteMacro . match ( buff ) ) != null ) { return m ; } else if ( ( m = TwoByteMacro . match ( buff ) ) != null ) { return m ; } log . warn ( STRING ) ; return null ; }
public EventClient ( InetAddress hostAddress , int hostPort , String deviceName , byte iconType , byte [ ] iconData ) throws IOException { hasIcon = _BOOL ; startClient ( hostAddress , hostPort , deviceName , iconType , iconData ) ; }
private void updateWorkAmount ( double workTime ) { if ( workTime <= _NUM ) { currentWorkAmount *= _NUM ; } else { totalTimeTaken += workTime ; completedWorkAmount += currentWorkAmount ; currentWorkAmount = ( int ) Math . ceil ( targetExecutionMs * completedWorkAmount / totalTimeTaken ) ; } }
private void updateWorkAmount ( double workTime ) { if ( workTime <= _NUM ) { currentWorkAmount *= _NUM ; } else { totalTimeTaken += workTime ; completedWorkAmount += currentWorkAmount ; currentWorkAmount = ( int ) Math . ceil ( targetExecutionMs * completedWorkAmount / totalTimeTaken ) ; } }
private void updateWorkAmount ( double workTime ) { if ( workTime <= _NUM ) { currentWorkAmount *= _NUM ; } else { totalTimeTaken += workTime ; completedWorkAmount += currentWorkAmount ; currentWorkAmount = ( int ) Math . ceil ( targetExecutionMs * completedWorkAmount / totalTimeTaken ) ; } }
private void updateWorkAmount ( double workTime ) { if ( workTime <= _NUM ) { currentWorkAmount *= _NUM ; } else { totalTimeTaken += workTime ; completedWorkAmount += currentWorkAmount ; currentWorkAmount = ( int ) Math . ceil ( targetExecutionMs * completedWorkAmount / totalTimeTaken ) ; } }
private void appendType ( Type genericType , final StringBuilder builder ) { builder . append ( getImplName ( genericType , _BOOL ) ) ; }
private void appendType ( Type genericType , final StringBuilder builder ) { builder . append ( getImplName ( genericType , _BOOL ) ) ; }
private void appendType ( Type genericType , final StringBuilder builder ) { builder . append ( getImplName ( genericType , _BOOL ) ) ; }
public boolean boundScroll ( ) { float curScroll = getStackScroll ( ) ; float newScroll = getBoundedStackScroll ( curScroll ) ; if ( Float . compare ( newScroll , curScroll ) != _NUM ) { setStackScroll ( newScroll ) ; return _BOOL ; } return _BOOL ; }
protected void drawMark ( Graphics2D g2 , float x , float y , Color color ) { Rectangle2D bounds = mark . getBounds2D ( ) ; float w = ( float ) bounds . getWidth ( ) ; float h = ( float ) bounds . getHeight ( ) ; x = x - ( w / _NUM ) ; y = y - ( h / _NUM ) ; g2 . translate ( x , y ) ; if ( color == null ) { if ( markFillPaint != null ) { g2 . setPaint ( markFillPaint ) ; g2 . fill ( mark ) ; } } else { g2 . setPaint ( color ) ; g2 . fill ( mark ) ; } g2 . setPaint ( markPaint ) ; g2 . setStroke ( markStroke ) ; g2 . draw ( mark ) ; g2 . translate ( - x , - y ) ; Rectangle2D rect = new Rectangle2D . Float ( x , y , w , h ) ; markBounds . add ( rect ) ; }
protected void drawMark ( Graphics2D g2 , float x , float y , Color color ) { Rectangle2D bounds = mark . getBounds2D ( ) ; float w = ( float ) bounds . getWidth ( ) ; float h = ( float ) bounds . getHeight ( ) ; x = x - ( w / _NUM ) ; y = y - ( h / _NUM ) ; g2 . translate ( x , y ) ; if ( color == null ) { if ( markFillPaint != null ) { g2 . setPaint ( markFillPaint ) ; g2 . fill ( mark ) ; } } else { g2 . setPaint ( color ) ; g2 . fill ( mark ) ; } g2 . setPaint ( markPaint ) ; g2 . setStroke ( markStroke ) ; g2 . draw ( mark ) ; g2 . translate ( - x , - y ) ; Rectangle2D rect = new Rectangle2D . Float ( x , y , w , h ) ; markBounds . add ( rect ) ; }
public static void report ( ) { if ( ! reported . compareAndSet ( _BOOL , _BOOL ) ) { return ; } if ( USE_EPOLL ) { logger . info ( STRING + ( Epoll . isAvailable ( ) ? STRING : STRING + filterCause ( Epoll . unavailabilityCause ( ) ) + STRING ) ) ; } else { logger . info ( STRING ) ; } if ( USE_OPENSSL ) { logger . info ( STRING + ( OpenSsl . isAvailable ( ) ? STRING + OpenSsl . versionString ( ) + STRING + OpenSsl . version ( ) + STRING : STRING + filterCause ( OpenSsl . unavailabilityCause ( ) ) + STRING ) ) ; } else { logger . info ( STRING ) ; } }
public static void report ( ) { if ( ! reported . compareAndSet ( _BOOL , _BOOL ) ) { return ; } if ( USE_EPOLL ) { logger . info ( STRING + ( Epoll . isAvailable ( ) ? STRING : STRING + filterCause ( Epoll . unavailabilityCause ( ) ) + STRING ) ) ; } else { logger . info ( STRING ) ; } if ( USE_OPENSSL ) { logger . info ( STRING + ( OpenSsl . isAvailable ( ) ? STRING + OpenSsl . versionString ( ) + STRING + OpenSsl . version ( ) + STRING : STRING + filterCause ( OpenSsl . unavailabilityCause ( ) ) + STRING ) ) ; } else { logger . info ( STRING ) ; } }
private static DecoratorMap concat ( DecoratorMap ... d_maps ) { return null ; }
private static DecoratorMap concat ( DecoratorMap ... d_maps ) { return null ; }
public static String commit ( String ... args ) { return simpleTag ( STRING , args ) ; }
public static String commit ( String ... args ) { return simpleTag ( STRING , args ) ; }
public static String commit ( String ... args ) { return simpleTag ( STRING , args ) ; }
public final TestSubscriber assertValueCount ( int count ) { String prefix = STRING ; boolean passed = _BOOL ; if ( done . getCount ( ) != _NUM ) { prefix = STRING ; } int s = values . size ( ) ; if ( s != count ) { fail ( prefix , STRING + count + STRING + s , errors ) ; fail ( STRING + count + STRING + s ) ; passed = _BOOL ; } pass ( STRING + count + STRING , passed ) ; return this ; }
public final TestSubscriber assertValueCount ( int count ) { String prefix = STRING ; boolean passed = _BOOL ; if ( done . getCount ( ) != _NUM ) { prefix = STRING ; } int s = values . size ( ) ; if ( s != count ) { fail ( prefix , STRING + count + STRING + s , errors ) ; fail ( STRING + count + STRING + s ) ; passed = _BOOL ; } pass ( STRING + count + STRING , passed ) ; return this ; }
public UnicastThread ( InetAddress host , int port ) throws IOException { super ( STRING ) ; setDaemon ( _BOOL ) ; int backlog = Integer . getInteger ( SystemProperties . LRMI_ACCEPT_BACKLOG , SystemProperties . LRMI_ACCEPT_BACKLOG_DEFUALT ) ; this . host = host ; if ( port == _NUM ) { try { listen = new ServerSocket ( Constants . getDiscoveryPort ( ) , backlog , host ) ; } catch ( IOException e ) { logger . log ( Levels . HANDLED , STRING , e ) ; } } if ( listen == null ) { listen = new ServerSocket ( port , backlog , host ) ; } this . port = listen . getLocalPort ( ) ; }
public UnicastThread ( InetAddress host , int port ) throws IOException { super ( STRING ) ; setDaemon ( _BOOL ) ; int backlog = Integer . getInteger ( SystemProperties . LRMI_ACCEPT_BACKLOG , SystemProperties . LRMI_ACCEPT_BACKLOG_DEFUALT ) ; this . host = host ; if ( port == _NUM ) { try { listen = new ServerSocket ( Constants . getDiscoveryPort ( ) , backlog , host ) ; } catch ( IOException e ) { logger . log ( Levels . HANDLED , STRING , e ) ; } } if ( listen == null ) { listen = new ServerSocket ( port , backlog , host ) ; } this . port = listen . getLocalPort ( ) ; }
public UnicastThread ( InetAddress host , int port ) throws IOException { super ( STRING ) ; setDaemon ( _BOOL ) ; int backlog = Integer . getInteger ( SystemProperties . LRMI_ACCEPT_BACKLOG , SystemProperties . LRMI_ACCEPT_BACKLOG_DEFUALT ) ; this . host = host ; if ( port == _NUM ) { try { listen = new ServerSocket ( Constants . getDiscoveryPort ( ) , backlog , host ) ; } catch ( IOException e ) { logger . log ( Levels . HANDLED , STRING , e ) ; } } if ( listen == null ) { listen = new ServerSocket ( port , backlog , host ) ; } this . port = listen . getLocalPort ( ) ; }
public UnicastThread ( InetAddress host , int port ) throws IOException { super ( STRING ) ; setDaemon ( _BOOL ) ; int backlog = Integer . getInteger ( SystemProperties . LRMI_ACCEPT_BACKLOG , SystemProperties . LRMI_ACCEPT_BACKLOG_DEFUALT ) ; this . host = host ; if ( port == _NUM ) { try { listen = new ServerSocket ( Constants . getDiscoveryPort ( ) , backlog , host ) ; } catch ( IOException e ) { logger . log ( Levels . HANDLED , STRING , e ) ; } } if ( listen == null ) { listen = new ServerSocket ( port , backlog , host ) ; } this . port = listen . getLocalPort ( ) ; }
public void addData ( T data ) { mData . add ( data ) ; notifyItemInserted ( mData . size ( ) ) ; }
@ Override public void putAll ( Map < ? extends K , ? extends V > map ) { ensureCapacity ( map . size ( ) ) ; super . putAll ( map ) ; }
@ Override public void putAll ( Map < ? extends K , ? extends V > map ) { ensureCapacity ( map . size ( ) ) ; super . putAll ( map ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case _NUM : return NAME ; case _NUM : return VALUE ; default : return null ; } }
public static JButton createButton ( final String buttonText , final int mnemonic ) { final JButton newButton = new JButton ( buttonText ) ; newButton . setMnemonic ( mnemonic ) ; newButton . setFont ( defaultMapXMLCreatorFont ) ; newButton . setMargin ( new Insets ( _NUM , _NUM , _NUM , _NUM ) ) ; return newButton ; }
public AlignmentAction ( String nm , int a ) { super ( nm ) ; this . a = a ; }
@ RequestMapping ( value = STRING , method = POST , produces = APPLICATION_JSON_VALUE ) public ResponseEntity < PageResponse < RoleDTO > > findAll ( @ RequestBody PageRequestByExample < RoleDTO > prbe ) throws URISyntaxException { PageResponse < RoleDTO > pageResponse = roleDTOService . findAll ( prbe ) ; return new ResponseEntity < > ( pageResponse , new HttpHeaders ( ) , HttpStatus . OK ) ; }
private void addGlobalAttributesToIntent ( Intent intent ) { if ( ! intent . hasExtra ( Event . ATTRIBUTE_TIME ) ) { insertTimeStamp ( intent ) ; } if ( ! intent . hasExtra ( Event . ATTRIBUTE_LOCATION ) ) { insertLocationData ( intent ) ; } }
public static byte [ ] base64ToBytes ( String base64 ) throws IllegalArgumentException { if ( base64 == null ) { return null ; } try { return Base64 . decode ( base64 , Base64 . NO_WRAP ) ; } catch ( IllegalArgumentException e ) { log . error ( STRING + base64 ) ; return null ; } }
public static byte [ ] base64ToBytes ( String base64 ) throws IllegalArgumentException { if ( base64 == null ) { return null ; } try { return Base64 . decode ( base64 , Base64 . NO_WRAP ) ; } catch ( IllegalArgumentException e ) { log . error ( STRING + base64 ) ; return null ; } }
public void addData ( int position , List < T > data ) { if ( _NUM <= position && position < mData . size ( ) ) { mData . addAll ( position , data ) ; notifyItemInserted ( position ) ; notifyItemRangeChanged ( position , mData . size ( ) - position - data . size ( ) ) ; } else { throw new ArrayIndexOutOfBoundsException ( STRING ) ; } }
public void addData ( int position , List < T > data ) { if ( _NUM <= position && position < mData . size ( ) ) { mData . addAll ( position , data ) ; notifyItemInserted ( position ) ; notifyItemRangeChanged ( position , mData . size ( ) - position - data . size ( ) ) ; } else { throw new ArrayIndexOutOfBoundsException ( STRING ) ; } }
public final void registerViewSystem ( ViewSystem viewSystem ) { viewSystems . add ( viewSystem ) ; }
@ Override public < R , A > CompletableFuture < R > collect ( final Collector < ? super T , A , R > collector ) { return CompletableFuture . supplyAsync ( null ) ; }
public void processUtterance ( Utterance utterance ) throws ProcessException { if ( utterance . getRelation ( Relation . SEGMENT ) == null ) { throw new IllegalStateException ( STRING ) ; } utterance . setObject ( SampleInfo . UTT_NAME , diphoneDatabase . getSampleInfo ( ) ) ; createUnitRelation ( utterance ) ; }
public Bounds windowView ( Bounds rangeBounds ) { Bounds newBounds = new Bounds ( this . start - rangeBounds . start , this . end - rangeBounds . start ) ; if ( ( newBounds . start >= rangeBounds . size ( ) ) || ( newBounds . end <= _NUM ) ) { return null ; } newBounds . start = Math . max ( newBounds . start , _NUM ) ; newBounds . end = Math . min ( newBounds . end , rangeBounds . size ( ) ) ; return newBounds ; }
public Bounds windowView ( Bounds rangeBounds ) { Bounds newBounds = new Bounds ( this . start - rangeBounds . start , this . end - rangeBounds . start ) ; if ( ( newBounds . start >= rangeBounds . size ( ) ) || ( newBounds . end <= _NUM ) ) { return null ; } newBounds . start = Math . max ( newBounds . start , _NUM ) ; newBounds . end = Math . min ( newBounds . end , rangeBounds . size ( ) ) ; return newBounds ; }
public Bounds windowView ( Bounds rangeBounds ) { Bounds newBounds = new Bounds ( this . start - rangeBounds . start , this . end - rangeBounds . start ) ; if ( ( newBounds . start >= rangeBounds . size ( ) ) || ( newBounds . end <= _NUM ) ) { return null ; } newBounds . start = Math . max ( newBounds . start , _NUM ) ; newBounds . end = Math . min ( newBounds . end , rangeBounds . size ( ) ) ; return newBounds ; }
public static void register ( String modelName , IWindModel model , int awesomeness ) { models . put ( modelName , model ) ; if ( modelName . equalsIgnoreCase ( userModelChoice ) ) { awesomeness = Integer . MAX_VALUE ; } if ( awesomeness > best ) { best = awesomeness ; activeModel = model ; } }
private List < Match < T > > sort ( final Map < String , Match < T > > possibleMatches ) { List < String > keys = new ArrayList < > ( possibleMatches . keySet ( ) ) ; Collections . sort ( keys , matchComparator ) ; List < Match < T > > matches1 = new ArrayList < > ( possibleMatches . size ( ) ) ; for ( String key : keys ) { matches1 . add ( possibleMatches . get ( key ) ) ; } return matches1 ; }
private void createProxy ( final Class < L > listenerInterface , final ClassLoader classLoader ) { proxy = listenerInterface . cast ( Proxy . newProxyInstance ( classLoader , new Class [ ] { listenerInterface } , createInvocationHandler ( ) ) ) ; }
@ OnWebSocketConnect public void onConnect ( Session session ) { this . websocketSession = session ; sendUpdate ( this . websocketSession , this . oAuthToken , this . streamType , this . streamQuery , this . streamVersion , this . schemaVersion ) ; }
public void stop ( ) { end_time = System . nanoTime ( ) ; total_time = end_time - start_time ; }
public static String [ ] parseWords ( String tagValue ) { StreamTokenizer tokenizer = makeTokenizer ( tagValue ) ; List < String > wordList = new ArrayList < String > ( ) ; try { while ( tokenizer . nextToken ( ) != StreamTokenizer . TT_EOF ) { if ( tokenizer . sval == null ) { wordList . add ( Character . toString ( ( char ) tokenizer . ttype ) ) ; } else { wordList . add ( tokenizer . sval ) ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( STRING ) ; } return wordList . toArray ( new String [ _NUM ] ) ; }
public AmqpSender ( AmqpSession session , String address , String senderId ) { if ( address != null && address . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING ) ; } this . session = session ; this . address = address ; this . senderId = senderId ; this . userSpecifiedTarget = null ; }
protected void delayForNfs ( ) { if ( nfsDelayMilliseconds > _NUM ) { try { Thread . sleep ( nfsDelayMilliseconds ) ; } catch ( InterruptedException e ) { throw new IllegalStateException ( STRING , e ) ; } } }
protected void delayForNfs ( ) { if ( nfsDelayMilliseconds > _NUM ) { try { Thread . sleep ( nfsDelayMilliseconds ) ; } catch ( InterruptedException e ) { throw new IllegalStateException ( STRING , e ) ; } } }
protected void delayForNfs ( ) { if ( nfsDelayMilliseconds > _NUM ) { try { Thread . sleep ( nfsDelayMilliseconds ) ; } catch ( InterruptedException e ) { throw new IllegalStateException ( STRING , e ) ; } } }
public static void sinAndCos ( double angle , DoubleWrapper sine , DoubleWrapper cosine ) { if ( USE_JDK_MATH ) { sine . value = STRICT_MATH ? StrictMath . sin ( angle ) : Math . sin ( angle ) ; cosine . value = STRICT_MATH ? StrictMath . cos ( angle ) : Math . cos ( angle ) ; return ; } boolean negateResult ; if ( angle < _NUM ) { angle = - angle ; negateResult = _BOOL ; } else { negateResult = _BOOL ; } if ( angle > SIN_COS_MAX_VALUE_FOR_INT_MODULO ) { angle = remainderTwoPi ( angle ) ; if ( angle < _NUM ) { angle += _NUM * Math . PI ; } } int index = ( int ) ( angle * SIN_COS_INDEXER + _NUM ) ; double delta = ( angle - index * SIN_COS_DELTA_HI ) - index * SIN_COS_DELTA_LO ; index &= ( SIN_COS_TABS_SIZE - _NUM ) ; double indexSin = sinTab [ index ] ; double indexCos = cosTab [ index ] ; double result = indexSin + delta * ( indexCos + delta * ( - indexSin * ONE_DIV_F2 + delta * ( - indexCos * ONE_DIV_F3 + delta * indexSin * ONE_DIV_F4 ) ) ) ; sine . value = negateResult ? - result : result ; cosine . value = indexCos + delta * ( - indexSin + delta * ( - indexCos * ONE_DIV_F2 + delta * ( indexSin * ONE_DIV_F3 + delta * indexCos * ONE_DIV_F4 ) ) ) ; }
@ SuppressWarnings ( STRING ) public static < T extends DimensionalItemObject > List < T > asTypedList ( Collection < DimensionalItemObject > collection ) { List < T > list = new ArrayList < > ( ) ; if ( collection != null ) { for ( DimensionalItemObject object : collection ) { list . add ( ( T ) object ) ; } } return list ; }
@ SuppressWarnings ( STRING ) public static < T extends DimensionalItemObject > List < T > asTypedList ( Collection < DimensionalItemObject > collection ) { List < T > list = new ArrayList < > ( ) ; if ( collection != null ) { for ( DimensionalItemObject object : collection ) { list . add ( ( T ) object ) ; } } return list ; }
@ SuppressWarnings ( STRING ) public static < T extends DimensionalItemObject > List < T > asTypedList ( Collection < DimensionalItemObject > collection ) { List < T > list = new ArrayList < > ( ) ; if ( collection != null ) { for ( DimensionalItemObject object : collection ) { list . add ( ( T ) object ) ; } } return list ; }
public DBException ( Exception e , String sql , Object [ ] params ) { this ( e ) ; m_sql = sql ; if ( params != null ) m_params = Arrays . copyOf ( params , params . length ) ; }
private < T > UnaryOperator < T > compose ( UnaryOperator < T > before , UnaryOperator < T > after ) { return null ; }
public boolean isPdfAttachment ( ) { if ( getPO ( ) == null ) return _BOOL ; return m_po . isPdfAttachment ( ) ; }
public boolean isPdfAttachment ( ) { if ( getPO ( ) == null ) return _BOOL ; return m_po . isPdfAttachment ( ) ; }
private void initializeSparseSlider ( ) { sparsitySlider . setMajorTickSpacing ( _NUM ) ; sparsitySlider . setMinorTickSpacing ( _NUM ) ; sparsitySlider . setPaintTicks ( _BOOL ) ; Hashtable < Integer , JLabel > labelTable2 = new Hashtable < Integer , JLabel > ( ) ; labelTable2 . put ( new Integer ( _NUM ) , new JLabel ( STRING ) ) ; labelTable2 . put ( new Integer ( _NUM ) , new JLabel ( STRING ) ) ; sparsitySlider . setLabelTable ( labelTable2 ) ; sparsitySlider . setPaintLabels ( _BOOL ) ; }
public void pushStream ( char [ ] inStream , int inFileid , String name , String inBaseDir , String inEncoding ) { includeStack . push ( new IncludeState ( cursor , line , col , fileid , fileName , baseDir , encoding , stream ) ) ; cursor = _NUM ; line = _NUM ; col = _NUM ; fileid = inFileid ; fileName = name ; baseDir = inBaseDir ; encoding = inEncoding ; stream = inStream ; }
public void runTest ( ) throws Throwable { Document doc ; NodeList elementList ; Node nameNode ; CharacterData child ; doc = ( Document ) load ( STRING , _BOOL ) ; elementList = doc . getElementsByTagName ( STRING ) ; nameNode = elementList . item ( _NUM ) ; child = ( CharacterData ) nameNode . getFirstChild ( ) ; { boolean success = _BOOL ; try { child . insertData ( - _NUM , STRING ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . INDEX_SIZE_ERR ) ; } assertTrue ( STRING , success ) ; } }
public Builder withSystemSecurityManager ( ) { return withSecurityManager ( System . getSecurityManager ( ) ) ; }
public Builder withSystemSecurityManager ( ) { return withSecurityManager ( System . getSecurityManager ( ) ) ; }
public Builder withSystemSecurityManager ( ) { return withSecurityManager ( System . getSecurityManager ( ) ) ; }
boolean parametersAreViewableAs ( MethodType newType , boolean keepInterfaces ) { if ( form == newType . form && form . erasedType == this ) return _BOOL ; if ( ptypes == newType . ptypes ) return _BOOL ; int argc = parameterCount ( ) ; if ( argc != newType . parameterCount ( ) ) return _BOOL ; for ( int i = _NUM ; i < argc ; i ++ ) { if ( ! VerifyType . isNullConversion ( newType . parameterType ( i ) , parameterType ( i ) , keepInterfaces ) ) return _BOOL ; } return _BOOL ; }
private HttpResponse sendRequest ( State state , AndroidHttpClient client , HttpGet request ) throws StopRequest { try { return client . execute ( request ) ; } catch ( IllegalArgumentException ex ) { throw new StopRequest ( DownloaderService . STATUS_HTTP_DATA_ERROR , STRING + ex . toString ( ) , ex ) ; } catch ( IOException ex ) { logNetworkState ( ) ; throw new StopRequest ( getFinalStatusForHttpError ( state ) , STRING + ex . toString ( ) , ex ) ; } }
private HttpResponse sendRequest ( State state , AndroidHttpClient client , HttpGet request ) throws StopRequest { try { return client . execute ( request ) ; } catch ( IllegalArgumentException ex ) { throw new StopRequest ( DownloaderService . STATUS_HTTP_DATA_ERROR , STRING + ex . toString ( ) , ex ) ; } catch ( IOException ex ) { logNetworkState ( ) ; throw new StopRequest ( getFinalStatusForHttpError ( state ) , STRING + ex . toString ( ) , ex ) ; } }
public void testCase17 ( ) { byte aBytes [ ] = { _NUM } ; byte bBytes [ ] = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; byte rBytes [ ] = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; int aSign = _NUM ; int bSign = _NUM ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , result . signum ( ) ) ; }
private ResolvedMigration createAvailableMigration ( int version ) { ResolvedMigration migration = new ResolvedMigration ( ) ; migration . setVersion ( MigrationVersion . fromVersion ( Integer . toString ( version ) ) ) ; migration . setDescription ( STRING ) ; migration . setScript ( STRING ) ; migration . setType ( MigrationType . CQL ) ; return migration ; }
public void treeExpanded ( TreeExpansionEvent event ) { inspectorWindow . updateView ( Director . ALL ) ; }
public void treeExpanded ( TreeExpansionEvent event ) { inspectorWindow . updateView ( Director . ALL ) ; }
public void write ( OutputStream oStream ) throws IOException { byte [ ] array = toByteArray ( ) ; oStream . write ( array ) ; }
void initProgram ( ) { glUseProgram ( this . program ) ; viewProjMatrixUniform = glGetUniformLocation ( this . program , STRING ) ; glUseProgram ( _NUM ) ; }
public ISAACRandom ( ) { setSeed ( System . currentTimeMillis ( ) + System . identityHashCode ( this ) ) ; }
public ISAACRandom ( ) { setSeed ( System . currentTimeMillis ( ) + System . identityHashCode ( this ) ) ; }
public < V > Object [ ] allMeta ( ) { Object [ ] cp ; synchronized ( this ) { cp = Arrays . copyOf ( data , data . length ) ; } return cp ; }
public < V > Object [ ] allMeta ( ) { Object [ ] cp ; synchronized ( this ) { cp = Arrays . copyOf ( data , data . length ) ; } return cp ; }
private void ensureVisibility ( ) { if ( ! isVisible ( ) ) { return ; } setLocation ( getFinalLocation ( ) ) ; }
private void ensureVisibility ( ) { if ( ! isVisible ( ) ) { return ; } setLocation ( getFinalLocation ( ) ) ; }
protected static String readFromFile ( final File file ) throws IOException { final LineNumberReader r = new LineNumberReader ( new FileReader ( file ) ) ; try { final StringBuilder sb = new StringBuilder ( ) ; String s ; while ( ( s = r . readLine ( ) ) != null ) { if ( r . getLineNumber ( ) > _NUM ) sb . append ( STRING ) ; sb . append ( s ) ; } return sb . toString ( ) ; } finally { r . close ( ) ; } }
private void internalGroupSnapCopyToTarget ( StorageSystem storage , BlockSnapshot snapshot , List < URI > snapshotList ) throws Exception { String snapGroupName = snapshot . getReplicationGroupInstance ( ) ; CIMObjectPath targetGroup = _cimPath . getReplicationGroupPath ( storage , snapGroupName ) ; CIMObjectPath settingsState = _helper . getSettingsDefineStateForSourceGroup ( storage , snapshot . getSettingsGroupInstance ( ) ) ; CIMArgument [ ] inArgs = _helper . getVNXCopyToTargetGroupInputArguments ( settingsState , targetGroup ) ; CIMArgument [ ] outArgs = new CIMArgument [ _NUM ] ; _helper . callModifySettingsDefineState ( storage , inArgs , outArgs ) ; List < BlockSnapshot > snapshots = _dbClient . queryObject ( BlockSnapshot . class , snapshotList ) ; for ( BlockSnapshot it : snapshots ) { it . setNeedsCopyToTarget ( _BOOL ) ; } _dbClient . persistObject ( snapshots ) ; }
private void internalGroupSnapCopyToTarget ( StorageSystem storage , BlockSnapshot snapshot , List < URI > snapshotList ) throws Exception { String snapGroupName = snapshot . getReplicationGroupInstance ( ) ; CIMObjectPath targetGroup = _cimPath . getReplicationGroupPath ( storage , snapGroupName ) ; CIMObjectPath settingsState = _helper . getSettingsDefineStateForSourceGroup ( storage , snapshot . getSettingsGroupInstance ( ) ) ; CIMArgument [ ] inArgs = _helper . getVNXCopyToTargetGroupInputArguments ( settingsState , targetGroup ) ; CIMArgument [ ] outArgs = new CIMArgument [ _NUM ] ; _helper . callModifySettingsDefineState ( storage , inArgs , outArgs ) ; List < BlockSnapshot > snapshots = _dbClient . queryObject ( BlockSnapshot . class , snapshotList ) ; for ( BlockSnapshot it : snapshots ) { it . setNeedsCopyToTarget ( _BOOL ) ; } _dbClient . persistObject ( snapshots ) ; }
protected void visitNode ( final Node n , final DijkstraNodeData data , final PseudoRemovePriorityQueue < Node > pendingNodes , final double time , final double cost , final Link outLink ) { data . visit ( outLink , cost , time , getIterationId ( ) ) ; pendingNodes . add ( n , getPriority ( data ) ) ; }
protected void visitNode ( final Node n , final DijkstraNodeData data , final PseudoRemovePriorityQueue < Node > pendingNodes , final double time , final double cost , final Link outLink ) { data . visit ( outLink , cost , time , getIterationId ( ) ) ; pendingNodes . add ( n , getPriority ( data ) ) ; }
private static TilesetGroupAnimationMap createAnimationMap ( ) { final TilesetGroupAnimationMap map = new TilesetGroupAnimationMap ( ) ; final URL url = DataLoader . getResource ( baseFolder + STRING ) ; if ( url != null ) { try { final InputStream in = url . openStream ( ) ; try { map . load ( in ) ; } finally { in . close ( ) ; } } catch ( final IOException ex ) { logger . error ( STRING , ex ) ; } } return map ; }
public Task < Void > unpinInBackground ( String name ) { return unpinAllInBackground ( name , Arrays . asList ( this ) ) ; }
public Task < Void > unpinInBackground ( String name ) { return unpinAllInBackground ( name , Arrays . asList ( this ) ) ; }
public Task < Void > unpinInBackground ( String name ) { return unpinAllInBackground ( name , Arrays . asList ( this ) ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return _BOOL ; } if ( ! ( obj instanceof CandlestickRenderer ) ) { return _BOOL ; } CandlestickRenderer that = ( CandlestickRenderer ) obj ; if ( this . candleWidth != that . candleWidth ) { return _BOOL ; } if ( ! PaintUtilities . equal ( this . upPaint , that . upPaint ) ) { return _BOOL ; } if ( ! PaintUtilities . equal ( this . downPaint , that . downPaint ) ) { return _BOOL ; } if ( this . drawVolume != that . drawVolume ) { return _BOOL ; } if ( this . maxCandleWidthInMilliseconds != that . maxCandleWidthInMilliseconds ) { return _BOOL ; } if ( this . autoWidthMethod != that . autoWidthMethod ) { return _BOOL ; } if ( this . autoWidthFactor != that . autoWidthFactor ) { return _BOOL ; } if ( this . autoWidthGap != that . autoWidthGap ) { return _BOOL ; } if ( this . useOutlinePaint != that . useOutlinePaint ) { return _BOOL ; } if ( ! PaintUtilities . equal ( this . volumePaint , that . volumePaint ) ) { return _BOOL ; } return super . equals ( obj ) ; }
public static boolean isAndroidRuntime ( ) { final String runtime = System . getProperty ( STRING ) ; return runtime != null && runtime . equals ( STRING ) ; }
public static void o ( Z a ) { o ( a , Parameters . OutputFieldWidth , Parameters . OutputFracPlaces ) ; }
public void add ( @ NotNull final ScpOperation operation ) { myOps . add ( operation ) ; }
public void add ( @ NotNull final ScpOperation operation ) { myOps . add ( operation ) ; }
private boolean hasPrefix ( byte [ ] nal ) { if ( nal [ _NUM ] == _NUM && nal [ _NUM ] == _NUM && nal [ _NUM ] == _NUM && nal [ _NUM ] == _NUM ) return _BOOL ; else return _BOOL ; }
private boolean hasPrefix ( byte [ ] nal ) { if ( nal [ _NUM ] == _NUM && nal [ _NUM ] == _NUM && nal [ _NUM ] == _NUM && nal [ _NUM ] == _NUM ) return _BOOL ; else return _BOOL ; }
public Map < GraphNode , GraphNode > buildHiddenNodeMap ( ) { Map < GraphNode , GraphNode > result = Maps . newHashMap ( ) ; for ( CollapseData masterData : collapsedData . values ( ) ) { Collection < GraphNode > masterNodes = Lists . newArrayList ( ) ; masterData . addMemberNodes ( masterNodes ) ; for ( GraphNode childNode : masterNodes ) { result . put ( childNode , masterData . getMasterNode ( ) ) ; } } return result ; }
public Map < GraphNode , GraphNode > buildHiddenNodeMap ( ) { Map < GraphNode , GraphNode > result = Maps . newHashMap ( ) ; for ( CollapseData masterData : collapsedData . values ( ) ) { Collection < GraphNode > masterNodes = Lists . newArrayList ( ) ; masterData . addMemberNodes ( masterNodes ) ; for ( GraphNode childNode : masterNodes ) { result . put ( childNode , masterData . getMasterNode ( ) ) ; } } return result ; }
public Map < GraphNode , GraphNode > buildHiddenNodeMap ( ) { Map < GraphNode , GraphNode > result = Maps . newHashMap ( ) ; for ( CollapseData masterData : collapsedData . values ( ) ) { Collection < GraphNode > masterNodes = Lists . newArrayList ( ) ; masterData . addMemberNodes ( masterNodes ) ; for ( GraphNode childNode : masterNodes ) { result . put ( childNode , masterData . getMasterNode ( ) ) ; } } return result ; }
public Map < GraphNode , GraphNode > buildHiddenNodeMap ( ) { Map < GraphNode , GraphNode > result = Maps . newHashMap ( ) ; for ( CollapseData masterData : collapsedData . values ( ) ) { Collection < GraphNode > masterNodes = Lists . newArrayList ( ) ; masterData . addMemberNodes ( masterNodes ) ; for ( GraphNode childNode : masterNodes ) { result . put ( childNode , masterData . getMasterNode ( ) ) ; } } return result ; }
public void deleteOnQuery ( final TokenFilter filter ) throws CoreTokenException , IllegalArgumentException { filter . addReturnAttribute ( CoreTokenField . TOKEN_ID ) ; ResultHandler < Collection < PartialToken > , CoreTokenException > handler = handlerFactory . getDeleteOnQueryHandler ( ) ; try { attributeQueryWithHandler ( filter , handler ) ; } catch ( CoreTokenException e ) { throw new QueryFailedException ( filter , e ) ; } }
public void deleteOnQuery ( final TokenFilter filter ) throws CoreTokenException , IllegalArgumentException { filter . addReturnAttribute ( CoreTokenField . TOKEN_ID ) ; ResultHandler < Collection < PartialToken > , CoreTokenException > handler = handlerFactory . getDeleteOnQueryHandler ( ) ; try { attributeQueryWithHandler ( filter , handler ) ; } catch ( CoreTokenException e ) { throw new QueryFailedException ( filter , e ) ; } }
public void deleteOnQuery ( final TokenFilter filter ) throws CoreTokenException , IllegalArgumentException { filter . addReturnAttribute ( CoreTokenField . TOKEN_ID ) ; ResultHandler < Collection < PartialToken > , CoreTokenException > handler = handlerFactory . getDeleteOnQueryHandler ( ) ; try { attributeQueryWithHandler ( filter , handler ) ; } catch ( CoreTokenException e ) { throw new QueryFailedException ( filter , e ) ; } }
public void deleteOnQuery ( final TokenFilter filter ) throws CoreTokenException , IllegalArgumentException { filter . addReturnAttribute ( CoreTokenField . TOKEN_ID ) ; ResultHandler < Collection < PartialToken > , CoreTokenException > handler = handlerFactory . getDeleteOnQueryHandler ( ) ; try { attributeQueryWithHandler ( filter , handler ) ; } catch ( CoreTokenException e ) { throw new QueryFailedException ( filter , e ) ; } }
public static void writeStringASCII ( ByteBuf stream , String str ) throws UnsupportedEncodingException { final byte [ ] bytes = str . getBytes ( STRING ) ; stream . writeInt ( str . length ( ) ) ; stream . writeBytes ( bytes ) ; }
public static < T > CombinedDownloadTask < T > single ( DownloadTask < T > task ) { Objects . requireNonNull ( task ) ; return new SingleCombinedTask < T > ( task ) ; }
public void writeResults ( PrintStream out ) { logger . info ( String . format ( STRING , outputFormat . toString ( ) ) ) ; Collections . sort ( effectiveVocabulary , new WordClassComparator ( wordToClass ) ) ; for ( IString word : effectiveVocabulary ) { int assignment = wordToClass . get ( word ) ; if ( outputFormat == OutputFormat . TSV ) { out . printf ( STRING , word . toString ( ) , assignment ) ; } else if ( outputFormat == OutputFormat . SRILM ) { out . printf ( STRING , assignment , word . toString ( ) ) ; } } }
private byte [ ] entityToBytes ( HttpEntity entity ) throws IOException , ServerError { PoolingByteArrayOutputStream bytes = new PoolingByteArrayOutputStream ( mPool , ( int ) entity . getContentLength ( ) ) ; byte [ ] buffer = null ; try { InputStream in = entity . getContent ( ) ; if ( in == null ) { throw new ServerError ( ) ; } buffer = mPool . getBuf ( _NUM ) ; int count ; while ( ( count = in . read ( buffer ) ) != - _NUM ) { bytes . write ( buffer , _NUM , count ) ; } return bytes . toByteArray ( ) ; } finally { try { entity . consumeContent ( ) ; } catch ( IOException e ) { VolleyLog . v ( STRING ) ; } mPool . returnBuf ( buffer ) ; bytes . close ( ) ; } }
@ Ignore @ Test public void testSetBaseURL ( ) throws ParserConfigurationException , SAXException , MalformedURLException { ConfigManager configManager = getConfigManager ( ) ; try { URL baseURL2 = new URL ( STRING ) ; configManager . setBaseUrl ( baseURL2 ) ; fail ( ) ; } catch ( InvalidConfigException e ) { } try { URL baseURL2 = new URL ( STRING ) ; configManager . setBaseUrl ( baseURL2 ) ; fail ( ) ; } catch ( InvalidConfigException e ) { } URL baseURL = new URL ( STRING ) ; configManager . setBaseUrl ( baseURL ) ; assertEquals ( baseURL . toString ( ) , appConfig . getProperty ( AppConfig . BASEURL ) ) ; }
@ Ignore @ Test public void testSetBaseURL ( ) throws ParserConfigurationException , SAXException , MalformedURLException { ConfigManager configManager = getConfigManager ( ) ; try { URL baseURL2 = new URL ( STRING ) ; configManager . setBaseUrl ( baseURL2 ) ; fail ( ) ; } catch ( InvalidConfigException e ) { } try { URL baseURL2 = new URL ( STRING ) ; configManager . setBaseUrl ( baseURL2 ) ; fail ( ) ; } catch ( InvalidConfigException e ) { } URL baseURL = new URL ( STRING ) ; configManager . setBaseUrl ( baseURL ) ; assertEquals ( baseURL . toString ( ) , appConfig . getProperty ( AppConfig . BASEURL ) ) ; }
public String apply ( Instance inst ) { for ( int i = _NUM ; i < m_selectedAtts . length ; i ++ ) { if ( ! inst . isMissing ( m_selectedAtts [ i ] ) ) { String value = inst . stringValue ( m_selectedAtts [ i ] ) ; String result = apply ( value ) ; if ( result != null ) { return result ; } } } return null ; }
public static boolean parseBooleanParam ( String value ) { if ( value == null ) { return _BOOL ; } if ( value . equalsIgnoreCase ( STRING ) || value . equals ( STRING ) ) { return _BOOL ; } return _BOOL ; }
public static int roundToPowerOfTwo ( final int value ) { return _NUM << ( _NUM - Integer . numberOfLeadingZeros ( value - _NUM ) ) ; }
public void animate ( MarkerWithPosition marker , LatLng from , LatLng to ) { lock . lock ( ) ; mAnimationTasks . add ( new AnimationTask ( marker , from , to ) ) ; lock . unlock ( ) ; }
public void animate ( MarkerWithPosition marker , LatLng from , LatLng to ) { lock . lock ( ) ; mAnimationTasks . add ( new AnimationTask ( marker , from , to ) ) ; lock . unlock ( ) ; }
protected void createTripleBuffer ( int width , int height ) { try { tripleBuffer = mxUtils . createBufferedImage ( width , height , null ) ; tripleBufferGraphics = tripleBuffer . createGraphics ( ) ; mxUtils . setAntiAlias ( tripleBufferGraphics , antiAlias , textAntiAlias ) ; repaintTripleBuffer ( null ) ; } catch ( OutOfMemoryError error ) { } }
protected void createTripleBuffer ( int width , int height ) { try { tripleBuffer = mxUtils . createBufferedImage ( width , height , null ) ; tripleBufferGraphics = tripleBuffer . createGraphics ( ) ; mxUtils . setAntiAlias ( tripleBufferGraphics , antiAlias , textAntiAlias ) ; repaintTripleBuffer ( null ) ; } catch ( OutOfMemoryError error ) { } }
protected void validateCurrentTimeBetweenSinceUntil ( FactoryDto factory ) throws BadRequestException { final PoliciesDto policies = factory . getPolicies ( ) ; if ( policies == null ) { return ; } final Long since = policies . getSince ( ) == null ? _NUM : policies . getSince ( ) ; final Long until = policies . getUntil ( ) == null ? _NUM : policies . getUntil ( ) ; if ( since != _NUM && currentTimeMillis ( ) < since ) { throw new BadRequestException ( FactoryConstants . ILLEGAL_FACTORY_BY_SINCE_MESSAGE ) ; } if ( until != _NUM && currentTimeMillis ( ) > until ) { throw new BadRequestException ( FactoryConstants . ILLEGAL_FACTORY_BY_UNTIL_MESSAGE ) ; } }
public static Gas register ( Gas gas ) { if ( gas == null ) { return null ; } registeredGasses . add ( gas ) ; return getGas ( gas . getName ( ) ) ; }
@ Override public int onStartCommand ( Intent intent , int flags , int startId ) { Log_OC . d ( TAG , STRING + startId ) ; if ( ! intent . hasExtra ( EXTRA_ACCOUNT ) || ! intent . hasExtra ( EXTRA_FILE ) ) { Log_OC . e ( TAG , STRING ) ; return START_NOT_STICKY ; } else { final Account account = intent . getParcelableExtra ( EXTRA_ACCOUNT ) ; final OCFile file = intent . getParcelableExtra ( EXTRA_FILE ) ; AbstractList < String > requestedDownloads = new Vector < > ( ) ; try { DownloadFileOperation newDownload = new DownloadFileOperation ( account , file ) ; newDownload . addDatatransferProgressListener ( this ) ; newDownload . addDatatransferProgressListener ( ( FileDownloaderBinder ) mBinder ) ; Pair < String , String > putResult = mPendingDownloads . putIfAbsent ( account , file . getRemotePath ( ) , newDownload ) ; String downloadKey = putResult . first ; requestedDownloads . add ( downloadKey ) ; sendBroadcastNewDownload ( newDownload , putResult . second ) ; } catch ( IllegalArgumentException e ) { Log_OC . e ( TAG , STRING + e . getMessage ( ) ) ; return START_NOT_STICKY ; } if ( requestedDownloads . size ( ) > _NUM ) { Message msg = mServiceHandler . obtainMessage ( ) ; msg . arg1 = startId ; msg . obj = requestedDownloads ; mServiceHandler . sendMessage ( msg ) ; } } return START_NOT_STICKY ; }
@ Override public int onStartCommand ( Intent intent , int flags , int startId ) { Log_OC . d ( TAG , STRING + startId ) ; if ( ! intent . hasExtra ( EXTRA_ACCOUNT ) || ! intent . hasExtra ( EXTRA_FILE ) ) { Log_OC . e ( TAG , STRING ) ; return START_NOT_STICKY ; } else { final Account account = intent . getParcelableExtra ( EXTRA_ACCOUNT ) ; final OCFile file = intent . getParcelableExtra ( EXTRA_FILE ) ; AbstractList < String > requestedDownloads = new Vector < > ( ) ; try { DownloadFileOperation newDownload = new DownloadFileOperation ( account , file ) ; newDownload . addDatatransferProgressListener ( this ) ; newDownload . addDatatransferProgressListener ( ( FileDownloaderBinder ) mBinder ) ; Pair < String , String > putResult = mPendingDownloads . putIfAbsent ( account , file . getRemotePath ( ) , newDownload ) ; String downloadKey = putResult . first ; requestedDownloads . add ( downloadKey ) ; sendBroadcastNewDownload ( newDownload , putResult . second ) ; } catch ( IllegalArgumentException e ) { Log_OC . e ( TAG , STRING + e . getMessage ( ) ) ; return START_NOT_STICKY ; } if ( requestedDownloads . size ( ) > _NUM ) { Message msg = mServiceHandler . obtainMessage ( ) ; msg . arg1 = startId ; msg . obj = requestedDownloads ; mServiceHandler . sendMessage ( msg ) ; } } return START_NOT_STICKY ; }
@ Override public int onStartCommand ( Intent intent , int flags , int startId ) { Log_OC . d ( TAG , STRING + startId ) ; if ( ! intent . hasExtra ( EXTRA_ACCOUNT ) || ! intent . hasExtra ( EXTRA_FILE ) ) { Log_OC . e ( TAG , STRING ) ; return START_NOT_STICKY ; } else { final Account account = intent . getParcelableExtra ( EXTRA_ACCOUNT ) ; final OCFile file = intent . getParcelableExtra ( EXTRA_FILE ) ; AbstractList < String > requestedDownloads = new Vector < > ( ) ; try { DownloadFileOperation newDownload = new DownloadFileOperation ( account , file ) ; newDownload . addDatatransferProgressListener ( this ) ; newDownload . addDatatransferProgressListener ( ( FileDownloaderBinder ) mBinder ) ; Pair < String , String > putResult = mPendingDownloads . putIfAbsent ( account , file . getRemotePath ( ) , newDownload ) ; String downloadKey = putResult . first ; requestedDownloads . add ( downloadKey ) ; sendBroadcastNewDownload ( newDownload , putResult . second ) ; } catch ( IllegalArgumentException e ) { Log_OC . e ( TAG , STRING + e . getMessage ( ) ) ; return START_NOT_STICKY ; } if ( requestedDownloads . size ( ) > _NUM ) { Message msg = mServiceHandler . obtainMessage ( ) ; msg . arg1 = startId ; msg . obj = requestedDownloads ; mServiceHandler . sendMessage ( msg ) ; } } return START_NOT_STICKY ; }
void freeRefCountInfo ( Long address ) { if ( ! trackReferenceCounts ( ) ) return ; List < RefCountChangeInfo > freedInfo = stacktraces . remove ( address ) ; if ( freedInfo == LOCKED ) { MemoryAllocatorImpl . debugLog ( STRING + Long . toHexString ( address ) , _BOOL ) ; } else if ( trackFreedReferenceCounts ( ) ) { if ( freedInfo != null ) { freedStacktraces . put ( address , freedInfo ) ; } else { freedStacktraces . remove ( address ) ; } } }
private void showFilterDialog ( Filter filter ) { int sortOrder = mAdapter . getCount ( ) - _NUM ; if ( filter == null ) { EditFilterActivity . createNewFilter ( getActivity ( ) , sortOrder ) ; } else { EditFilterActivity . editFilter ( getActivity ( ) , filter , sortOrder ) ; } }
public void testEncode ( ) throws StunException { byte [ ] expectedReturn = msgFixture . errCodeTestValue ; errorCodeAttribute . setErrorClass ( MsgFixture . ERROR_CLASS ) ; errorCodeAttribute . setErrorNumber ( MsgFixture . ERROR_NUMBER ) ; errorCodeAttribute . setReasonPhrase ( MsgFixture . REASON_PHRASE ) ; byte [ ] actualReturn = errorCodeAttribute . encode ( ) ; assertTrue ( STRING , Arrays . equals ( expectedReturn , actualReturn ) ) ; }
public void remove ( String key ) { put ( key , null ) ; }
public void remove ( String key ) { put ( key , null ) ; }
public void remove ( String key ) { put ( key , null ) ; }
public void removeRtcpListener ( RtcpEventListener listener ) { listeners . removeElement ( listener ) ; }
public RelationshipBuilder addColumns ( Column fromCol , Column toCol ) { return addColumns ( fromCol . getName ( ) , toCol . getName ( ) ) ; }
private void updateFSExport ( FileShare fsObj , DbClient dbClient , VNXeApiClient apiClient , FileExport newExport ) { _logger . info ( STRING ) ; FSExportMap exports = fsObj . getFsExports ( ) ; if ( exports == null ) { exports = new FSExportMap ( ) ; } VNXeNfsShare nfsShare = apiClient . findNfsShare ( fsObj . getNativeId ( ) , shareName ) ; String nfsShareId = nfsShare . getId ( ) ; newExport . setIsilonId ( nfsShareId ) ; exports . put ( newExport . getFileExportKey ( ) , newExport ) ; fsObj . setFsExports ( exports ) ; updateExportRules ( fsObj . getId ( ) , newExport , dbClient ) ; dbClient . persistObject ( fsObj ) ; }
private void waitForErrors ( WriteStreamOld error , InputStream inputStream , InputStream errorStream ) throws IOException { byte [ ] buffer = new byte [ _NUM ] ; int stderrLen = _NUM ; int stdoutLen = _NUM ; if ( inputStream == null || errorStream == null ) return ; do { if ( ( stderrLen = errorStream . available ( ) ) > _NUM ) { stderrLen = errorStream . read ( buffer , _NUM , buffer . length ) ; if ( stderrLen > _NUM ) { error . write ( buffer , _NUM , stderrLen ) ; continue ; } } if ( ( stdoutLen = inputStream . available ( ) ) > _NUM ) { stdoutLen = inputStream . read ( buffer , _NUM , buffer . length ) ; if ( stdoutLen > _NUM ) { error . write ( buffer , _NUM , stdoutLen ) ; continue ; } } if ( stderrLen < _NUM && stdoutLen < _NUM ) return ; stderrLen = errorStream . read ( buffer , _NUM , buffer . length ) ; if ( stderrLen > _NUM ) { error . write ( buffer , _NUM , stderrLen ) ; continue ; } stdoutLen = inputStream . read ( buffer , _NUM , buffer . length ) ; if ( stdoutLen > _NUM ) { error . write ( buffer , _NUM , stdoutLen ) ; continue ; } } while ( ! _isDead && ( stderrLen >= _NUM || stdoutLen >= _NUM ) ) ; }
public String login ( int AD_Org_ID , int AD_Role_ID , int AD_User_ID ) { Env . setContext ( Env . getCtx ( ) , CTX_IsLiberoEnabled , _BOOL ) ; return null ; }
protected int calculateCycles ( int unitsCycle , BigDecimal qty ) { BigDecimal cycles = qty ; BigDecimal unitsCycleBD = BigDecimal . valueOf ( unitsCycle ) ; if ( unitsCycleBD . signum ( ) > _NUM ) { cycles = qty . divide ( unitsCycleBD , _NUM , RoundingMode . UP ) ; } return cycles . intValue ( ) ; }
public static Comparable [ ] sortCopy ( Comparable [ ] objects ) { int len = objects . length ; Comparable [ ] copy = new Comparable [ len ] ; System . arraycopy ( objects , _NUM , copy , _NUM , len ) ; sort ( copy ) ; return copy ; }
private void queueReadyJobsForExecutionLockedH ( ) { ArraySet < JobStatus > jobs = mJobs . getJobs ( ) ; if ( DEBUG ) { } for ( int i = _NUM ; i < jobs . size ( ) ; i ++ ) { JobStatus job = jobs . valueAt ( i ) ; if ( isReadyToBeExecutedLocked ( job ) ) { if ( DEBUG ) { } mPendingJobs . add ( job ) ; } else if ( isReadyToBeCancelledLocked ( job ) ) { stopJobOnServiceContextLocked ( job ) ; } } if ( DEBUG ) { final int queuedJobs = mPendingJobs . size ( ) ; if ( queuedJobs == _NUM ) { } else { } } }
private void queueReadyJobsForExecutionLockedH ( ) { ArraySet < JobStatus > jobs = mJobs . getJobs ( ) ; if ( DEBUG ) { } for ( int i = _NUM ; i < jobs . size ( ) ; i ++ ) { JobStatus job = jobs . valueAt ( i ) ; if ( isReadyToBeExecutedLocked ( job ) ) { if ( DEBUG ) { } mPendingJobs . add ( job ) ; } else if ( isReadyToBeCancelledLocked ( job ) ) { stopJobOnServiceContextLocked ( job ) ; } } if ( DEBUG ) { final int queuedJobs = mPendingJobs . size ( ) ; if ( queuedJobs == _NUM ) { } else { } } }
private void validateInitiatorData ( Initiator initiator , ExportGroup exportGroup ) { validatePortConnectivity ( exportGroup , Collections . singletonList ( initiator ) ) ; }
public static Http2Headers toNettyHttp2 ( HttpHeaders inputHeaders ) { final Http2Headers outputHeaders = new DefaultHttp2Headers ( _BOOL , inputHeaders . size ( ) ) ; outputHeaders . set ( inputHeaders ) ; outputHeaders . remove ( HttpHeaderNames . CONNECTION ) ; outputHeaders . remove ( HttpHeaderNames . TRANSFER_ENCODING ) ; outputHeaders . remove ( HttpHeaderNames . TRAILER ) ; return outputHeaders ; }
public static Http2Headers toNettyHttp2 ( HttpHeaders inputHeaders ) { final Http2Headers outputHeaders = new DefaultHttp2Headers ( _BOOL , inputHeaders . size ( ) ) ; outputHeaders . set ( inputHeaders ) ; outputHeaders . remove ( HttpHeaderNames . CONNECTION ) ; outputHeaders . remove ( HttpHeaderNames . TRANSFER_ENCODING ) ; outputHeaders . remove ( HttpHeaderNames . TRAILER ) ; return outputHeaders ; }
private String uniquify ( String label ) { return label . replaceAll ( STRING , STRING ) ; }
private String uniquify ( String label ) { return label . replaceAll ( STRING , STRING ) ; }
public static boolean isToshiba ( ) { return sBuildModel . startsWith ( STRING ) ; }
public static boolean isToshiba ( ) { return sBuildModel . startsWith ( STRING ) ; }
public static String removeAll ( String source , String strToRemove ) { int toRemoveIndex = source . indexOf ( strToRemove ) ; if ( toRemoveIndex != - _NUM ) { StringBuilder result = new StringBuilder ( source . length ( ) ) ; int sourceIndex = _NUM ; while ( toRemoveIndex != - _NUM ) { result . append ( source . substring ( sourceIndex , toRemoveIndex ) ) ; sourceIndex = toRemoveIndex + strToRemove . length ( ) ; toRemoveIndex = source . indexOf ( strToRemove , sourceIndex ) ; if ( toRemoveIndex == - _NUM ) { result . append ( source . substring ( sourceIndex , source . length ( ) ) ) ; } } return result . toString ( ) ; } else { return source ; } }
@ Override public Iterator < Database > iterator ( ) { return m_databases . iterator ( ) ; }
private static synchronized String makeDateString ( Date date ) { return sdfDefault . format ( date ) ; }
public Decimal add ( Decimal decimal ) { assertDefined ( ) ; if ( null == m_value ) { if ( null == decimal . getBigDecimalValue ( ) ) { return new Decimal ( SCALE ) ; } else { return new Decimal ( decimal . getBigDecimalValue ( ) , SCALE ) ; } } BigDecimal value = m_value . add ( decimal . getBigDecimalValue ( ) ) ; return new Decimal ( value , SCALE ) ; }
public static void registerInfoListener ( InfoListener l ) { infoListeners . add ( l ) ; }
public static void registerInfoListener ( InfoListener l ) { infoListeners . add ( l ) ; }
public static void registerInfoListener ( InfoListener l ) { infoListeners . add ( l ) ; }
public static void registerInfoListener ( InfoListener l ) { infoListeners . add ( l ) ; }
public static void registerInfoListener ( InfoListener l ) { infoListeners . add ( l ) ; }
public static void registerInfoListener ( InfoListener l ) { infoListeners . add ( l ) ; }
public static void registerInfoListener ( InfoListener l ) { infoListeners . add ( l ) ; }
@ Override public void error ( String msg , Throwable t ) { if ( logger . isLoggable ( Level . SEVERE ) ) { log ( SELF , Level . SEVERE , msg , t ) ; } }
private void skipToEndOfLine ( ) { for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . charAt ( pos ) ; if ( c == STRING || c == STRING ) { pos ++ ; break ; } } }
private void skipToEndOfLine ( ) { for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . charAt ( pos ) ; if ( c == STRING || c == STRING ) { pos ++ ; break ; } } }
public void testMergeOneServletIntoDocumentWithAnotherServlet ( ) throws Exception { String srcXml = STRING + STRING + STRING + STRING + STRING + STRING ; WebXml srcWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( srcXml . getBytes ( STRING ) ) , null ) ; String mergeXml = STRING + STRING + STRING + STRING + STRING + STRING ; WebXml mergeWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( mergeXml . getBytes ( STRING ) ) , null ) ; WebXmlMerger merger = new WebXmlMerger ( srcWebXml ) ; merger . merge ( mergeWebXml ) ; assertTrue ( WebXmlUtils . hasServlet ( srcWebXml , STRING ) ) ; assertTrue ( WebXmlUtils . hasServlet ( srcWebXml , STRING ) ) ; }
private IBuildQueryResult queryBuilds ( final TFSTeamProjectCollection connection , final String buildName , final String teamProject , final BuildStatus status ) { Check . notNull ( connection , STRING ) ; Check . notNullOrEmpty ( buildName , STRING ) ; Check . notNullOrEmpty ( teamProject , STRING ) ; final IBuildServer buildServer = connection . getBuildServer ( ) ; final IBuildDetailSpec buildDetailSpec = buildServer . createBuildDetailSpec ( teamProject ) ; buildDetailSpec . setBuildNumber ( buildName ) ; buildDetailSpec . setInformationTypes ( new String [ ] { InformationTypes . CHECK_IN_OUTCOME } ) ; if ( status != null ) { buildDetailSpec . setStatus ( status ) ; } return buildServer . queryBuilds ( buildDetailSpec ) ; }
private IBuildQueryResult queryBuilds ( final TFSTeamProjectCollection connection , final String buildName , final String teamProject , final BuildStatus status ) { Check . notNull ( connection , STRING ) ; Check . notNullOrEmpty ( buildName , STRING ) ; Check . notNullOrEmpty ( teamProject , STRING ) ; final IBuildServer buildServer = connection . getBuildServer ( ) ; final IBuildDetailSpec buildDetailSpec = buildServer . createBuildDetailSpec ( teamProject ) ; buildDetailSpec . setBuildNumber ( buildName ) ; buildDetailSpec . setInformationTypes ( new String [ ] { InformationTypes . CHECK_IN_OUTCOME } ) ; if ( status != null ) { buildDetailSpec . setStatus ( status ) ; } return buildServer . queryBuilds ( buildDetailSpec ) ; }
public static double bernoullis ( double n , double k , double successProb ) { double combo = MathUtils . combination ( n , k ) ; double q = _NUM - successProb ; return combo * Math . pow ( successProb , k ) * Math . pow ( q , n - k ) ; }
public static double bernoullis ( double n , double k , double successProb ) { double combo = MathUtils . combination ( n , k ) ; double q = _NUM - successProb ; return combo * Math . pow ( successProb , k ) * Math . pow ( q , n - k ) ; }
public static double bernoullis ( double n , double k , double successProb ) { double combo = MathUtils . combination ( n , k ) ; double q = _NUM - successProb ; return combo * Math . pow ( successProb , k ) * Math . pow ( q , n - k ) ; }
private static String removeTrailingSpace ( String raw ) { char c ; int i = raw . length ( ) - _NUM ; for ( ; i >= _NUM ; i -- ) { c = raw . charAt ( i ) ; if ( c != STRING && c != STRING ) { break ; } } return raw . substring ( _NUM , i + _NUM ) ; }
protected Action updateAction ( Action action , String name , String icon , String accel , Character mnemonic ) { Action result ; if ( action == null ) { result = m_Actions . get ( name ) ; return result ; } result = action ; if ( ( name != null ) && ( name . length ( ) > _NUM ) ) result . putValue ( Action . NAME , name ) ; if ( ( icon != null ) && ( icon . length ( ) > _NUM ) ) result . putValue ( Action . SMALL_ICON , ComponentHelper . getImageIcon ( icon ) ) ; if ( ( accel != null ) && ( accel . length ( ) > _NUM ) ) result . putValue ( Action . ACCELERATOR_KEY , KeyStroke . getKeyStroke ( accel ) ) ; if ( mnemonic != null ) result . putValue ( Action . MNEMONIC_KEY , new Integer ( mnemonic . charValue ( ) ) ) ; return result ; }
private Boolean filterExistingItems ( List < PostItem > postItems , PostItem item ) { if ( postItems . contains ( item ) ) { int i = postItems . indexOf ( item ) ; postItems . remove ( i ) ; postItems . add ( i , item ) ; return _BOOL ; } return _BOOL ; }
private Boolean filterExistingItems ( List < PostItem > postItems , PostItem item ) { if ( postItems . contains ( item ) ) { int i = postItems . indexOf ( item ) ; postItems . remove ( i ) ; postItems . add ( i , item ) ; return _BOOL ; } return _BOOL ; }
private Boolean filterExistingItems ( List < PostItem > postItems , PostItem item ) { if ( postItems . contains ( item ) ) { int i = postItems . indexOf ( item ) ; postItems . remove ( i ) ; postItems . add ( i , item ) ; return _BOOL ; } return _BOOL ; }
private Boolean filterExistingItems ( List < PostItem > postItems , PostItem item ) { if ( postItems . contains ( item ) ) { int i = postItems . indexOf ( item ) ; postItems . remove ( i ) ; postItems . add ( i , item ) ; return _BOOL ; } return _BOOL ; }
public static void begin ( ServletRequest request , ServletResponse response , String serviceName , String objectId ) throws ServletException { ServiceContext context = ( ServiceContext ) _localContext . get ( ) ; if ( context == null ) { context = new ServiceContext ( ) ; _localContext . set ( context ) ; } context . _request = request ; context . _response = response ; context . _serviceName = serviceName ; context . _objectId = objectId ; context . _count ++ ; }
public ResultSet executeQuery ( String query ) throws SQLException , NoConnectionException { if ( connection != null ) { Statement st = connection . createStatement ( ) ; return st . executeQuery ( query ) ; } throw new NoConnectionException ( ) ; }
protected double computeStdDev ( Instance inst , Matrix k ) throws Exception { double kappa = m_kernel . eval ( - _NUM , - _NUM , inst ) + m_deltaSquared ; double s = _NUM ; int n = m_L . length ; for ( int i = _NUM ; i < n ; i ++ ) { double t = _NUM ; for ( int j = _NUM ; j < n ; j ++ ) { t -= k . get ( j , _NUM ) * ( i > j ? m_L [ i ] [ j ] : m_L [ j ] [ i ] ) ; } s += t * k . get ( i , _NUM ) ; } double sigma = m_delta ; if ( kappa > s ) { sigma = Math . sqrt ( kappa - s ) ; } return sigma ; }
private static byte [ ] streamToBytes ( InputStream in , int length ) throws IOException { byte [ ] bytes = new byte [ length ] ; int count ; int pos = _NUM ; while ( pos < length && ( ( count = in . read ( bytes , pos , length - pos ) ) != - _NUM ) ) { pos += count ; } if ( pos != length ) { throw new IOException ( STRING + length + STRING + pos + STRING ) ; } return bytes ; }
public static SearchScope valueOf ( final int intValue ) { SearchScope result = null ; if ( _NUM <= intValue && intValue < ELEMENTS . length ) { result = ELEMENTS [ intValue ] ; } if ( result == null ) { result = new SearchScope ( intValue , STRING + intValue + STRING , Enum . UNKNOWN ) ; } return result ; }
public static SearchScope valueOf ( final int intValue ) { SearchScope result = null ; if ( _NUM <= intValue && intValue < ELEMENTS . length ) { result = ELEMENTS [ intValue ] ; } if ( result == null ) { result = new SearchScope ( intValue , STRING + intValue + STRING , Enum . UNKNOWN ) ; } return result ; }
public boolean isPalindrome ( String s ) { if ( s == null || s . length ( ) == _NUM ) { return _BOOL ; } int i = _NUM ; int j = s . length ( ) - _NUM ; s = s . toLowerCase ( ) ; while ( i < j ) { while ( i < j && ! Character . isLetterOrDigit ( s . charAt ( i ) ) ) { i ++ ; } if ( i >= j ) { return _BOOL ; } while ( i < j && ! Character . isLetterOrDigit ( s . charAt ( j ) ) ) { j -- ; } if ( s . charAt ( i ) != s . charAt ( j ) ) { return _BOOL ; } i ++ ; j -- ; } return _BOOL ; }
public boolean isPalindrome ( String s ) { if ( s == null || s . length ( ) == _NUM ) { return _BOOL ; } int i = _NUM ; int j = s . length ( ) - _NUM ; s = s . toLowerCase ( ) ; while ( i < j ) { while ( i < j && ! Character . isLetterOrDigit ( s . charAt ( i ) ) ) { i ++ ; } if ( i >= j ) { return _BOOL ; } while ( i < j && ! Character . isLetterOrDigit ( s . charAt ( j ) ) ) { j -- ; } if ( s . charAt ( i ) != s . charAt ( j ) ) { return _BOOL ; } i ++ ; j -- ; } return _BOOL ; }
public boolean isPalindrome ( String s ) { if ( s == null || s . length ( ) == _NUM ) { return _BOOL ; } int i = _NUM ; int j = s . length ( ) - _NUM ; s = s . toLowerCase ( ) ; while ( i < j ) { while ( i < j && ! Character . isLetterOrDigit ( s . charAt ( i ) ) ) { i ++ ; } if ( i >= j ) { return _BOOL ; } while ( i < j && ! Character . isLetterOrDigit ( s . charAt ( j ) ) ) { j -- ; } if ( s . charAt ( i ) != s . charAt ( j ) ) { return _BOOL ; } i ++ ; j -- ; } return _BOOL ; }
public boolean isPalindrome ( String s ) { if ( s == null || s . length ( ) == _NUM ) { return _BOOL ; } int i = _NUM ; int j = s . length ( ) - _NUM ; s = s . toLowerCase ( ) ; while ( i < j ) { while ( i < j && ! Character . isLetterOrDigit ( s . charAt ( i ) ) ) { i ++ ; } if ( i >= j ) { return _BOOL ; } while ( i < j && ! Character . isLetterOrDigit ( s . charAt ( j ) ) ) { j -- ; } if ( s . charAt ( i ) != s . charAt ( j ) ) { return _BOOL ; } i ++ ; j -- ; } return _BOOL ; }
public boolean isPalindrome ( String s ) { if ( s == null || s . length ( ) == _NUM ) { return _BOOL ; } int i = _NUM ; int j = s . length ( ) - _NUM ; s = s . toLowerCase ( ) ; while ( i < j ) { while ( i < j && ! Character . isLetterOrDigit ( s . charAt ( i ) ) ) { i ++ ; } if ( i >= j ) { return _BOOL ; } while ( i < j && ! Character . isLetterOrDigit ( s . charAt ( j ) ) ) { j -- ; } if ( s . charAt ( i ) != s . charAt ( j ) ) { return _BOOL ; } i ++ ; j -- ; } return _BOOL ; }
public boolean isPalindrome ( String s ) { if ( s == null || s . length ( ) == _NUM ) { return _BOOL ; } int i = _NUM ; int j = s . length ( ) - _NUM ; s = s . toLowerCase ( ) ; while ( i < j ) { while ( i < j && ! Character . isLetterOrDigit ( s . charAt ( i ) ) ) { i ++ ; } if ( i >= j ) { return _BOOL ; } while ( i < j && ! Character . isLetterOrDigit ( s . charAt ( j ) ) ) { j -- ; } if ( s . charAt ( i ) != s . charAt ( j ) ) { return _BOOL ; } i ++ ; j -- ; } return _BOOL ; }
public static CharSequence comments ( String comments ) { return Html . fromHtml ( comments . replace ( STRING , STRING ) ) ; }
public Token next ( ) throws IOException { skipWhitespace ( ) ; int c = reader . read ( ) ; if ( c < _NUM ) { return new Token ( Token . EOF ) ; } else if ( c == STRING ) { return new Token ( Token . EOL ) ; } else if ( c == STRING || c == STRING ) { return munchString ( c ) ; } else if ( c == STRING ) { return maybeComment ( ) ; } else if ( single . get ( c ) ) { return new Token ( Token . SINGLE , String . valueOf ( ( char ) c ) ) ; } else { reader . unread ( c ) ; return parseWord ( ) ; } }
public Wiser ( ) { this . server = new SMTPServer ( new SimpleMessageListenerAdapter ( this ) ) ; }
private static String massageURI ( String uri ) { uri = uri . trim ( ) ; int protocolEnd = uri . indexOf ( STRING ) ; if ( protocolEnd < _NUM ) { uri = STRING + uri ; } else if ( isColonFollowedByPortNumber ( uri , protocolEnd ) ) { uri = STRING + uri ; } return uri ; }
private static String massageURI ( String uri ) { uri = uri . trim ( ) ; int protocolEnd = uri . indexOf ( STRING ) ; if ( protocolEnd < _NUM ) { uri = STRING + uri ; } else if ( isColonFollowedByPortNumber ( uri , protocolEnd ) ) { uri = STRING + uri ; } return uri ; }
private static String massageURI ( String uri ) { uri = uri . trim ( ) ; int protocolEnd = uri . indexOf ( STRING ) ; if ( protocolEnd < _NUM ) { uri = STRING + uri ; } else if ( isColonFollowedByPortNumber ( uri , protocolEnd ) ) { uri = STRING + uri ; } return uri ; }
public static boolean equals ( Collection < ? > actual , Object ... reference ) { final Collection < Object > collection = new HashSet < > ( ) ; Collections . addAll ( collection , reference ) ; if ( actual == collection ) { return _BOOL ; } if ( actual == null ) { return _BOOL ; } if ( actual . size ( ) != collection . size ( ) ) { log . warn ( STRING + actual . size ( ) + STRING + collection . size ( ) ) ; return _BOOL ; } for ( Object object : actual ) { if ( ! collection . contains ( object ) ) { log . warn ( STRING + object ) ; return _BOOL ; } } for ( Object object : collection ) { if ( ! actual . contains ( object ) ) { log . warn ( STRING + object ) ; return _BOOL ; } } return _BOOL ; }
public static boolean equals ( Collection < ? > actual , Object ... reference ) { final Collection < Object > collection = new HashSet < > ( ) ; Collections . addAll ( collection , reference ) ; if ( actual == collection ) { return _BOOL ; } if ( actual == null ) { return _BOOL ; } if ( actual . size ( ) != collection . size ( ) ) { log . warn ( STRING + actual . size ( ) + STRING + collection . size ( ) ) ; return _BOOL ; } for ( Object object : actual ) { if ( ! collection . contains ( object ) ) { log . warn ( STRING + object ) ; return _BOOL ; } } for ( Object object : collection ) { if ( ! actual . contains ( object ) ) { log . warn ( STRING + object ) ; return _BOOL ; } } return _BOOL ; }
public static boolean equals ( Collection < ? > actual , Object ... reference ) { final Collection < Object > collection = new HashSet < > ( ) ; Collections . addAll ( collection , reference ) ; if ( actual == collection ) { return _BOOL ; } if ( actual == null ) { return _BOOL ; } if ( actual . size ( ) != collection . size ( ) ) { log . warn ( STRING + actual . size ( ) + STRING + collection . size ( ) ) ; return _BOOL ; } for ( Object object : actual ) { if ( ! collection . contains ( object ) ) { log . warn ( STRING + object ) ; return _BOOL ; } } for ( Object object : collection ) { if ( ! actual . contains ( object ) ) { log . warn ( STRING + object ) ; return _BOOL ; } } return _BOOL ; }
public static boolean equals ( Collection < ? > actual , Object ... reference ) { final Collection < Object > collection = new HashSet < > ( ) ; Collections . addAll ( collection , reference ) ; if ( actual == collection ) { return _BOOL ; } if ( actual == null ) { return _BOOL ; } if ( actual . size ( ) != collection . size ( ) ) { log . warn ( STRING + actual . size ( ) + STRING + collection . size ( ) ) ; return _BOOL ; } for ( Object object : actual ) { if ( ! collection . contains ( object ) ) { log . warn ( STRING + object ) ; return _BOOL ; } } for ( Object object : collection ) { if ( ! actual . contains ( object ) ) { log . warn ( STRING + object ) ; return _BOOL ; } } return _BOOL ; }
public static boolean equals ( Collection < ? > actual , Object ... reference ) { final Collection < Object > collection = new HashSet < > ( ) ; Collections . addAll ( collection , reference ) ; if ( actual == collection ) { return _BOOL ; } if ( actual == null ) { return _BOOL ; } if ( actual . size ( ) != collection . size ( ) ) { log . warn ( STRING + actual . size ( ) + STRING + collection . size ( ) ) ; return _BOOL ; } for ( Object object : actual ) { if ( ! collection . contains ( object ) ) { log . warn ( STRING + object ) ; return _BOOL ; } } for ( Object object : collection ) { if ( ! actual . contains ( object ) ) { log . warn ( STRING + object ) ; return _BOOL ; } } return _BOOL ; }
private void saveLogFile ( License license , Properties props ) { File logFile = getLogFile ( license ) ; logger . fine ( STRING + props ) ; try { final OutputStream out = new FileOutputStream ( logFile ) ; try { props . store ( out , String . format ( LOG_HEADER , newDate ( ) ) ) ; } finally { out . close ( ) ; } } catch ( IOException ex ) { logger . log ( Level . SEVERE , STRING + logFile . getAbsolutePath ( ) , ex ) ; } }
@ Override public Object deserializeWithType ( JsonParser jp , DeserializationContext ctxt , TypeDeserializer typeDeserializer ) throws IOException , JsonProcessingException { switch ( jp . getCurrentToken ( ) ) { case VALUE_NUMBER_INT : case VALUE_NUMBER_FLOAT : case VALUE_STRING : return deserialize ( jp , ctxt ) ; } return typeDeserializer . deserializeTypedFromScalar ( jp , ctxt ) ; }
@ Override public Object deserializeWithType ( JsonParser jp , DeserializationContext ctxt , TypeDeserializer typeDeserializer ) throws IOException , JsonProcessingException { switch ( jp . getCurrentToken ( ) ) { case VALUE_NUMBER_INT : case VALUE_NUMBER_FLOAT : case VALUE_STRING : return deserialize ( jp , ctxt ) ; } return typeDeserializer . deserializeTypedFromScalar ( jp , ctxt ) ; }
@ Override public Object deserializeWithType ( JsonParser jp , DeserializationContext ctxt , TypeDeserializer typeDeserializer ) throws IOException , JsonProcessingException { switch ( jp . getCurrentToken ( ) ) { case VALUE_NUMBER_INT : case VALUE_NUMBER_FLOAT : case VALUE_STRING : return deserialize ( jp , ctxt ) ; } return typeDeserializer . deserializeTypedFromScalar ( jp , ctxt ) ; }
@ Override public Object deserializeWithType ( JsonParser jp , DeserializationContext ctxt , TypeDeserializer typeDeserializer ) throws IOException , JsonProcessingException { switch ( jp . getCurrentToken ( ) ) { case VALUE_NUMBER_INT : case VALUE_NUMBER_FLOAT : case VALUE_STRING : return deserialize ( jp , ctxt ) ; } return typeDeserializer . deserializeTypedFromScalar ( jp , ctxt ) ; }
public List < InetAddress > discoverHosts ( int udpPort , int timeoutMillis ) { List < InetAddress > hosts = new ArrayList < InetAddress > ( ) ; DatagramSocket socket = null ; try { socket = new DatagramSocket ( ) ; broadcast ( udpPort , socket ) ; socket . setSoTimeout ( timeoutMillis ) ; while ( _BOOL ) { DatagramPacket packet = new DatagramPacket ( new byte [ _NUM ] , _NUM ) ; try { socket . receive ( packet ) ; } catch ( SocketTimeoutException ex ) { if ( INFO ) info ( STRING , STRING ) ; return hosts ; } if ( INFO ) info ( STRING , STRING + packet . getAddress ( ) ) ; hosts . add ( packet . getAddress ( ) ) ; } } catch ( IOException ex ) { if ( ERROR ) error ( STRING , STRING , ex ) ; return hosts ; } finally { if ( socket != null ) socket . close ( ) ; } }
public List < InetAddress > discoverHosts ( int udpPort , int timeoutMillis ) { List < InetAddress > hosts = new ArrayList < InetAddress > ( ) ; DatagramSocket socket = null ; try { socket = new DatagramSocket ( ) ; broadcast ( udpPort , socket ) ; socket . setSoTimeout ( timeoutMillis ) ; while ( _BOOL ) { DatagramPacket packet = new DatagramPacket ( new byte [ _NUM ] , _NUM ) ; try { socket . receive ( packet ) ; } catch ( SocketTimeoutException ex ) { if ( INFO ) info ( STRING , STRING ) ; return hosts ; } if ( INFO ) info ( STRING , STRING + packet . getAddress ( ) ) ; hosts . add ( packet . getAddress ( ) ) ; } } catch ( IOException ex ) { if ( ERROR ) error ( STRING , STRING , ex ) ; return hosts ; } finally { if ( socket != null ) socket . close ( ) ; } }
public List < InetAddress > discoverHosts ( int udpPort , int timeoutMillis ) { List < InetAddress > hosts = new ArrayList < InetAddress > ( ) ; DatagramSocket socket = null ; try { socket = new DatagramSocket ( ) ; broadcast ( udpPort , socket ) ; socket . setSoTimeout ( timeoutMillis ) ; while ( _BOOL ) { DatagramPacket packet = new DatagramPacket ( new byte [ _NUM ] , _NUM ) ; try { socket . receive ( packet ) ; } catch ( SocketTimeoutException ex ) { if ( INFO ) info ( STRING , STRING ) ; return hosts ; } if ( INFO ) info ( STRING , STRING + packet . getAddress ( ) ) ; hosts . add ( packet . getAddress ( ) ) ; } } catch ( IOException ex ) { if ( ERROR ) error ( STRING , STRING , ex ) ; return hosts ; } finally { if ( socket != null ) socket . close ( ) ; } }
protected ASN1Sequence ( ASN1Encodable [ ] array ) { for ( int i = _NUM ; i != array . length ; i ++ ) { seq . addElement ( array [ i ] ) ; } }
protected ASN1Sequence ( ASN1Encodable [ ] array ) { for ( int i = _NUM ; i != array . length ; i ++ ) { seq . addElement ( array [ i ] ) ; } }
protected ASN1Sequence ( ASN1Encodable [ ] array ) { for ( int i = _NUM ; i != array . length ; i ++ ) { seq . addElement ( array [ i ] ) ; } }
private void handleDoneQuery ( final UUID queryId , final Future < Void > doneQueryFuture ) { try { doneQueryFuture . get ( ) ; throw new InterruptedException ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( e ) ; } }
private void handleDoneQuery ( final UUID queryId , final Future < Void > doneQueryFuture ) { try { doneQueryFuture . get ( ) ; throw new InterruptedException ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( e ) ; } }
public boolean equals ( Object o ) { return source . equals ( o ) ; }
public int compare ( RandomAccessData o1 , RandomAccessData o2 , int startOffset ) { if ( o1 == o2 ) { return _NUM ; } if ( o1 == POSITIVE_INFINITY ) { return _NUM ; } if ( o2 == POSITIVE_INFINITY ) { return - _NUM ; } int minBytesLen = Math . min ( o1 . size , o2 . size ) ; for ( int i = startOffset ; i < minBytesLen ; i ++ ) { int b1 = o1 . buffer [ i ] & _NUM ; int b2 = o2 . buffer [ i ] & _NUM ; if ( b1 == b2 ) { continue ; } return b1 - b2 ; } return o1 . size - o2 . size ; }
@ ManagedOperation ( description = STRING ) public void notifyAllTagCacheListeners ( ) { LOGGER . info ( STRING ) ; for ( Long key : controlTagCache . getKeys ( ) ) { controlTagCache . acquireWriteLockOnKey ( key ) ; try { ControlTag controlTag = controlTagCache . getCopy ( key ) ; long eventTime = System . currentTimeMillis ( ) ; controlTagCache . notifyListenerStatusConfirmation ( controlTag , eventTime ) ; } finally { controlTagCache . releaseWriteLockOnKey ( key ) ; } } for ( Long key : dataTagCache . getKeys ( ) ) { dataTagCache . acquireWriteLockOnKey ( key ) ; try { DataTag dataTag = dataTagCache . getCopy ( key ) ; long eventTime = System . currentTimeMillis ( ) ; dataTagCache . notifyListenerStatusConfirmation ( dataTag , eventTime ) ; } finally { dataTagCache . releaseWriteLockOnKey ( key ) ; } } LOGGER . info ( STRING ) ; }
@ ManagedOperation ( description = STRING ) public void notifyAllTagCacheListeners ( ) { LOGGER . info ( STRING ) ; for ( Long key : controlTagCache . getKeys ( ) ) { controlTagCache . acquireWriteLockOnKey ( key ) ; try { ControlTag controlTag = controlTagCache . getCopy ( key ) ; long eventTime = System . currentTimeMillis ( ) ; controlTagCache . notifyListenerStatusConfirmation ( controlTag , eventTime ) ; } finally { controlTagCache . releaseWriteLockOnKey ( key ) ; } } for ( Long key : dataTagCache . getKeys ( ) ) { dataTagCache . acquireWriteLockOnKey ( key ) ; try { DataTag dataTag = dataTagCache . getCopy ( key ) ; long eventTime = System . currentTimeMillis ( ) ; dataTagCache . notifyListenerStatusConfirmation ( dataTag , eventTime ) ; } finally { dataTagCache . releaseWriteLockOnKey ( key ) ; } } LOGGER . info ( STRING ) ; }
@ ManagedOperation ( description = STRING ) public void notifyAllTagCacheListeners ( ) { LOGGER . info ( STRING ) ; for ( Long key : controlTagCache . getKeys ( ) ) { controlTagCache . acquireWriteLockOnKey ( key ) ; try { ControlTag controlTag = controlTagCache . getCopy ( key ) ; long eventTime = System . currentTimeMillis ( ) ; controlTagCache . notifyListenerStatusConfirmation ( controlTag , eventTime ) ; } finally { controlTagCache . releaseWriteLockOnKey ( key ) ; } } for ( Long key : dataTagCache . getKeys ( ) ) { dataTagCache . acquireWriteLockOnKey ( key ) ; try { DataTag dataTag = dataTagCache . getCopy ( key ) ; long eventTime = System . currentTimeMillis ( ) ; dataTagCache . notifyListenerStatusConfirmation ( dataTag , eventTime ) ; } finally { dataTagCache . releaseWriteLockOnKey ( key ) ; } } LOGGER . info ( STRING ) ; }
@ ManagedOperation ( description = STRING ) public void notifyAllTagCacheListeners ( ) { LOGGER . info ( STRING ) ; for ( Long key : controlTagCache . getKeys ( ) ) { controlTagCache . acquireWriteLockOnKey ( key ) ; try { ControlTag controlTag = controlTagCache . getCopy ( key ) ; long eventTime = System . currentTimeMillis ( ) ; controlTagCache . notifyListenerStatusConfirmation ( controlTag , eventTime ) ; } finally { controlTagCache . releaseWriteLockOnKey ( key ) ; } } for ( Long key : dataTagCache . getKeys ( ) ) { dataTagCache . acquireWriteLockOnKey ( key ) ; try { DataTag dataTag = dataTagCache . getCopy ( key ) ; long eventTime = System . currentTimeMillis ( ) ; dataTagCache . notifyListenerStatusConfirmation ( dataTag , eventTime ) ; } finally { dataTagCache . releaseWriteLockOnKey ( key ) ; } } LOGGER . info ( STRING ) ; }
private String [ ] parentKey ( String name , int idx ) { String [ ] parts = name . split ( STRING ) ; if ( idx > parts . length ) return null ; String parent = STRING ; String key = null ; if ( idx < parts . length ) key = parts [ idx ] ; for ( int i = _NUM ; i < idx ; i ++ ) { parent = parent . length ( ) > _NUM ? parent + STRING + parts [ i ] : parts [ i ] ; } return new String [ ] { parent , key } ; }
protected void longKeyPress ( int keyCode ) { }
public Outfit removeOutfit ( final Outfit other ) { int newDetail ; int newHair ; int newHead ; int newDress ; int newBody ; if ( ( detail == null ) || detail . equals ( other . detail ) ) { newDetail = _NUM ; } else { newDetail = detail ; } if ( ( hair == null ) || hair . equals ( other . hair ) ) { newHair = _NUM ; } else { newHair = hair ; } if ( ( head == null ) || head . equals ( other . head ) ) { newHead = _NUM ; } else { newHead = head ; } if ( ( dress == null ) || dress . equals ( other . dress ) ) { newDress = _NUM ; } else { newDress = dress ; } if ( ( body == null ) || body . equals ( other . body ) ) { newBody = _NUM ; } else { newBody = body ; } return new Outfit ( newDetail , newHair , newHead , newDress , newBody ) ; }
public Outfit removeOutfit ( final Outfit other ) { int newDetail ; int newHair ; int newHead ; int newDress ; int newBody ; if ( ( detail == null ) || detail . equals ( other . detail ) ) { newDetail = _NUM ; } else { newDetail = detail ; } if ( ( hair == null ) || hair . equals ( other . hair ) ) { newHair = _NUM ; } else { newHair = hair ; } if ( ( head == null ) || head . equals ( other . head ) ) { newHead = _NUM ; } else { newHead = head ; } if ( ( dress == null ) || dress . equals ( other . dress ) ) { newDress = _NUM ; } else { newDress = dress ; } if ( ( body == null ) || body . equals ( other . body ) ) { newBody = _NUM ; } else { newBody = body ; } return new Outfit ( newDetail , newHair , newHead , newDress , newBody ) ; }
public void addActionListener ( ActionListener newA ) { m_Listeners . add ( newA ) ; }
public static < T extends IIdentifyable > List < T > checkIds ( @ NonNull List < T > items ) { for ( int i = _NUM , size = items . size ( ) ; i < size ; i ++ ) { checkId ( items . get ( i ) ) ; } return items ; }
public static < T extends IIdentifyable > List < T > checkIds ( @ NonNull List < T > items ) { for ( int i = _NUM , size = items . size ( ) ; i < size ; i ++ ) { checkId ( items . get ( i ) ) ; } return items ; }
public static < T extends IIdentifyable > List < T > checkIds ( @ NonNull List < T > items ) { for ( int i = _NUM , size = items . size ( ) ; i < size ; i ++ ) { checkId ( items . get ( i ) ) ; } return items ; }
public static < T extends IIdentifyable > List < T > checkIds ( @ NonNull List < T > items ) { for ( int i = _NUM , size = items . size ( ) ; i < size ; i ++ ) { checkId ( items . get ( i ) ) ; } return items ; }
public static < T extends IIdentifyable > List < T > checkIds ( @ NonNull List < T > items ) { for ( int i = _NUM , size = items . size ( ) ; i < size ; i ++ ) { checkId ( items . get ( i ) ) ; } return items ; }
public void selectInitialValue ( ) { OptionPaneUI ui = getUI ( ) ; if ( ui != null ) { ui . selectInitialValue ( this ) ; } }
public void selectInitialValue ( ) { OptionPaneUI ui = getUI ( ) ; if ( ui != null ) { ui . selectInitialValue ( this ) ; } }
public void selectInitialValue ( ) { OptionPaneUI ui = getUI ( ) ; if ( ui != null ) { ui . selectInitialValue ( this ) ; } }
public static Context createContext ( final Context c , final String path ) throws NamingException { Context crtContext = c ; for ( StringTokenizer st = new StringTokenizer ( path , STRING ) ; st . hasMoreTokens ( ) ; ) { String tok = st . nextToken ( ) ; try { Object o = crtContext . lookup ( tok ) ; if ( ! ( o instanceof Context ) ) { throw new NamingException ( STRING + path + STRING ) ; } crtContext = ( Context ) o ; continue ; } catch ( NameNotFoundException e ) { } crtContext = crtContext . createSubcontext ( tok ) ; } return crtContext ; }
public static Context createContext ( final Context c , final String path ) throws NamingException { Context crtContext = c ; for ( StringTokenizer st = new StringTokenizer ( path , STRING ) ; st . hasMoreTokens ( ) ; ) { String tok = st . nextToken ( ) ; try { Object o = crtContext . lookup ( tok ) ; if ( ! ( o instanceof Context ) ) { throw new NamingException ( STRING + path + STRING ) ; } crtContext = ( Context ) o ; continue ; } catch ( NameNotFoundException e ) { } crtContext = crtContext . createSubcontext ( tok ) ; } return crtContext ; }
@ Override public boolean connectionAllowed ( String eventName ) { return eventName . equals ( STRING ) || eventName . equals ( STRING ) || eventName . equals ( STRING ) ; }
@ Override public boolean connectionAllowed ( String eventName ) { return eventName . equals ( STRING ) || eventName . equals ( STRING ) || eventName . equals ( STRING ) ; }
@ Override public boolean connectionAllowed ( String eventName ) { return eventName . equals ( STRING ) || eventName . equals ( STRING ) || eventName . equals ( STRING ) ; }
@ Override public boolean connectionAllowed ( String eventName ) { return eventName . equals ( STRING ) || eventName . equals ( STRING ) || eventName . equals ( STRING ) ; }
public void putAllWithPrefix ( TungstenProperties props , String prefix ) { TungstenProperties newProps = new TungstenProperties ( ) ; if ( props . isEmpty ( ) ) { newProps . setObject ( prefix , props ) ; } else { for ( String key : props . keyNames ( ) ) { newProps . setObject ( prefix + key , props . getObject ( key ) ) ; } } putAll ( newProps ) ; }
public BackwardsFileStream ( File file ) throws IOException { raf = new RandomAccessFile ( file , STRING ) ; seekPos = raf . length ( ) ; }
public CharSequenceFilter addMatchesPattern ( String regularExpression , int flags ) { mCachedToString = null ; mMatchesPattern . add ( Pattern . compile ( regularExpression , flags ) ) ; return this ; }
@ Override public void keyTyped ( KeyEvent e ) { synchronized ( keyLock ) { keysTyped . addFirst ( e . getKeyChar ( ) ) ; } }
public void addDebugger ( final IDebugger debugger ) { debuggers . add ( Preconditions . checkNotNull ( debugger , STRING ) ) ; for ( final DebuggerProviderListener listener : m_listeners ) { try { listener . debuggerAdded ( this , debugger ) ; } catch ( final Exception exception ) { CUtilityFunctions . logException ( exception ) ; } } }
public int size ( ) { return listeners . size ( ) ; }
public static boolean isAbsoluteURI ( String systemId ) { if ( isWindowsAbsolutePath ( systemId ) ) { return _BOOL ; } final int fragmentIndex = systemId . indexOf ( STRING ) ; final int queryIndex = systemId . indexOf ( STRING ) ; final int slashIndex = systemId . indexOf ( STRING ) ; final int colonIndex = systemId . indexOf ( STRING ) ; int index = systemId . length ( ) - _NUM ; if ( fragmentIndex > _NUM ) index = fragmentIndex ; if ( ( queryIndex > _NUM ) && ( queryIndex < index ) ) index = queryIndex ; if ( ( slashIndex > _NUM ) && ( slashIndex < index ) ) index = slashIndex ; return ( ( colonIndex > _NUM ) && ( colonIndex < index ) ) ; }
public static boolean isAbsoluteURI ( String systemId ) { if ( isWindowsAbsolutePath ( systemId ) ) { return _BOOL ; } final int fragmentIndex = systemId . indexOf ( STRING ) ; final int queryIndex = systemId . indexOf ( STRING ) ; final int slashIndex = systemId . indexOf ( STRING ) ; final int colonIndex = systemId . indexOf ( STRING ) ; int index = systemId . length ( ) - _NUM ; if ( fragmentIndex > _NUM ) index = fragmentIndex ; if ( ( queryIndex > _NUM ) && ( queryIndex < index ) ) index = queryIndex ; if ( ( slashIndex > _NUM ) && ( slashIndex < index ) ) index = slashIndex ; return ( ( colonIndex > _NUM ) && ( colonIndex < index ) ) ; }
public final void onDead ( final Killer killer ) { onDead ( killer , _BOOL ) ; }
public void line ( double x , double y ) { Line line = new Line ( x , y ) ; if ( x < minX ) { minX = x ; } if ( y < minY ) { minY = y ; } if ( x > maxX ) { maxX = x ; } if ( y > maxY ) { maxY = y ; } elements . add ( line ) ; }
protected static String normalizeUrlEnding ( String link ) { if ( link . indexOf ( STRING ) > - _NUM ) link = link . substring ( _NUM , link . indexOf ( STRING ) ) ; if ( link . endsWith ( STRING ) ) link = link . substring ( _NUM , link . length ( ) - _NUM ) ; if ( link . endsWith ( STRING ) ) link = link . substring ( _NUM , link . length ( ) - _NUM ) ; return link ; }
protected static String normalizeUrlEnding ( String link ) { if ( link . indexOf ( STRING ) > - _NUM ) link = link . substring ( _NUM , link . indexOf ( STRING ) ) ; if ( link . endsWith ( STRING ) ) link = link . substring ( _NUM , link . length ( ) - _NUM ) ; if ( link . endsWith ( STRING ) ) link = link . substring ( _NUM , link . length ( ) - _NUM ) ; return link ; }
protected static String normalizeUrlEnding ( String link ) { if ( link . indexOf ( STRING ) > - _NUM ) link = link . substring ( _NUM , link . indexOf ( STRING ) ) ; if ( link . endsWith ( STRING ) ) link = link . substring ( _NUM , link . length ( ) - _NUM ) ; if ( link . endsWith ( STRING ) ) link = link . substring ( _NUM , link . length ( ) - _NUM ) ; return link ; }
private String align ( final String data , final Alignment alignment , final int width ) { final String rawData = data . trim ( ) ; final int padding = width - rawData . length ( ) ; if ( padding <= _NUM ) { return rawData ; } switch ( alignment ) { case RIGHT : return pad ( padding , rawData , _NUM ) ; case LEFT : return pad ( _NUM , rawData , padding ) ; case CENTER : final int paddingBefore = padding / _NUM ; return pad ( paddingBefore , rawData , padding - paddingBefore ) ; default : return STRING ; } }
private boolean checkTimePassed ( FollowerInfo info ) { Integer errorCount = errors . get ( info . stream ) ; if ( errorCount == null ) { errorCount = _NUM ; } if ( System . currentTimeMillis ( ) - info . time > REQUEST_DELAY * _NUM + ( REQUEST_DELAY * _NUM * ( errorCount ) / _NUM ) ) { return _BOOL ; } return _BOOL ; }
private boolean checkTimePassed ( FollowerInfo info ) { Integer errorCount = errors . get ( info . stream ) ; if ( errorCount == null ) { errorCount = _NUM ; } if ( System . currentTimeMillis ( ) - info . time > REQUEST_DELAY * _NUM + ( REQUEST_DELAY * _NUM * ( errorCount ) / _NUM ) ) { return _BOOL ; } return _BOOL ; }
private boolean checkTimePassed ( FollowerInfo info ) { Integer errorCount = errors . get ( info . stream ) ; if ( errorCount == null ) { errorCount = _NUM ; } if ( System . currentTimeMillis ( ) - info . time > REQUEST_DELAY * _NUM + ( REQUEST_DELAY * _NUM * ( errorCount ) / _NUM ) ) { return _BOOL ; } return _BOOL ; }
private boolean checkTimePassed ( FollowerInfo info ) { Integer errorCount = errors . get ( info . stream ) ; if ( errorCount == null ) { errorCount = _NUM ; } if ( System . currentTimeMillis ( ) - info . time > REQUEST_DELAY * _NUM + ( REQUEST_DELAY * _NUM * ( errorCount ) / _NUM ) ) { return _BOOL ; } return _BOOL ; }
public void store ( OutputStream out , String header ) throws IOException { PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( out , STRING ) ) ; String line ; String key ; StringBuffer s = new StringBuffer ( ) ; for ( int i = _NUM ; i < lineData . size ( ) ; i ++ ) { line = ( String ) lineData . get ( i ) ; key = ( String ) keyData . get ( i ) ; if ( key . length ( ) > _NUM ) { formatForOutput ( key , s , _BOOL ) ; s . append ( STRING ) ; formatForOutput ( ( String ) get ( key ) , s , _BOOL ) ; writer . println ( s ) ; } else { writer . println ( line ) ; } } writer . flush ( ) ; }
public void store ( OutputStream out , String header ) throws IOException { PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( out , STRING ) ) ; String line ; String key ; StringBuffer s = new StringBuffer ( ) ; for ( int i = _NUM ; i < lineData . size ( ) ; i ++ ) { line = ( String ) lineData . get ( i ) ; key = ( String ) keyData . get ( i ) ; if ( key . length ( ) > _NUM ) { formatForOutput ( key , s , _BOOL ) ; s . append ( STRING ) ; formatForOutput ( ( String ) get ( key ) , s , _BOOL ) ; writer . println ( s ) ; } else { writer . println ( line ) ; } } writer . flush ( ) ; }
public void store ( OutputStream out , String header ) throws IOException { PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( out , STRING ) ) ; String line ; String key ; StringBuffer s = new StringBuffer ( ) ; for ( int i = _NUM ; i < lineData . size ( ) ; i ++ ) { line = ( String ) lineData . get ( i ) ; key = ( String ) keyData . get ( i ) ; if ( key . length ( ) > _NUM ) { formatForOutput ( key , s , _BOOL ) ; s . append ( STRING ) ; formatForOutput ( ( String ) get ( key ) , s , _BOOL ) ; writer . println ( s ) ; } else { writer . println ( line ) ; } } writer . flush ( ) ; }
public void store ( OutputStream out , String header ) throws IOException { PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( out , STRING ) ) ; String line ; String key ; StringBuffer s = new StringBuffer ( ) ; for ( int i = _NUM ; i < lineData . size ( ) ; i ++ ) { line = ( String ) lineData . get ( i ) ; key = ( String ) keyData . get ( i ) ; if ( key . length ( ) > _NUM ) { formatForOutput ( key , s , _BOOL ) ; s . append ( STRING ) ; formatForOutput ( ( String ) get ( key ) , s , _BOOL ) ; writer . println ( s ) ; } else { writer . println ( line ) ; } } writer . flush ( ) ; }
public static String requestNextMessage ( ) throws InterruptedException { synchronized ( requestLock ) { nextLineRequested = _BOOL ; requestLock . wait ( ) ; nextLineRequested = _BOOL ; return ln ; } }
public void release ( ) { if ( mMediaPlayer != null ) { if ( mMediaPlayer . isPlaying ( ) ) { mMediaPlayer . stop ( ) ; } mMediaPlayer . reset ( ) ; mMediaPlayer . release ( ) ; } mMediaPlayer = null ; }
public void release ( ) { if ( mMediaPlayer != null ) { if ( mMediaPlayer . isPlaying ( ) ) { mMediaPlayer . stop ( ) ; } mMediaPlayer . reset ( ) ; mMediaPlayer . release ( ) ; } mMediaPlayer = null ; }
private void addToTT ( String ttSName , boolean startBR , Object ... ttO ) { if ( startBR == BR ) tooltipString . append ( STRING ) ; if ( ttO != null ) { tooltipString . append ( Messages . getString ( STRING + ttSName , ttO ) ) ; } else { tooltipString . append ( Messages . getString ( STRING + ttSName ) ) ; } }
public void clearOperatorSelection ( ) { this . selectedOperators = Collections . unmodifiableList ( Collections . < Operator > emptyList ( ) ) ; }
public static void dropIndex ( Connection conn , String schema , String table ) throws SQLException { init ( conn ) ; PreparedStatement prep = conn . prepareStatement ( STRING + SCHEMA + STRING ) ; prep . setString ( _NUM , schema ) ; prep . setString ( _NUM , table ) ; int rowCount = prep . executeUpdate ( ) ; if ( rowCount == _NUM ) { return ; } reindex ( conn ) ; }
public static void dropIndex ( Connection conn , String schema , String table ) throws SQLException { init ( conn ) ; PreparedStatement prep = conn . prepareStatement ( STRING + SCHEMA + STRING ) ; prep . setString ( _NUM , schema ) ; prep . setString ( _NUM , table ) ; int rowCount = prep . executeUpdate ( ) ; if ( rowCount == _NUM ) { return ; } reindex ( conn ) ; }
protected int skipWhitespace ( int c ) throws IOException { while ( c == STRING || c == STRING ) { c = reader . read ( ) ; } return c ; }
protected int skipWhitespace ( int c ) throws IOException { while ( c == STRING || c == STRING ) { c = reader . read ( ) ; } return c ; }
public Observable < DriveId > createFile ( DriveFolder folder , File file , String title ) { return createFile ( folder , file , title , MimeTypeMap . getFileExtensionFromUrl ( file . getPath ( ) ) ) ; }
public static int instanceOf ( Object o , Class < ? > c ) { if ( o == null ) return FALSE ; return c . isAssignableFrom ( o . getClass ( ) ) ? TRUE : FALSE ; }
public static int instanceOf ( Object o , Class < ? > c ) { if ( o == null ) return FALSE ; return c . isAssignableFrom ( o . getClass ( ) ) ? TRUE : FALSE ; }
@ Override public byte [ ] fromByteArray ( Slice fragment ) { if ( fragment == null || fragment . buffer == null ) { return null ; } else if ( fragment . offset == _NUM && fragment . length == fragment . buffer . length ) { return fragment . buffer ; } else { byte [ ] buffer = new byte [ fragment . buffer . length ] ; System . arraycopy ( fragment . buffer , fragment . offset , buffer , _NUM , fragment . length ) ; return buffer ; } }
public StateMachine ( State [ ] s ) { for ( int i = _NUM ; i < s . length ; i ++ ) states . addElement ( s [ i ] ) ; }
public StateMachine ( State [ ] s ) { for ( int i = _NUM ; i < s . length ; i ++ ) states . addElement ( s [ i ] ) ; }
public StateMachine ( State [ ] s ) { for ( int i = _NUM ; i < s . length ; i ++ ) states . addElement ( s [ i ] ) ; }
@ Override public synchronized void removeDataSourceListener ( DataSourceListener dsl ) { m_dataListeners . remove ( dsl ) ; }
public void printStackTrace ( PrintStream ps ) { ps . println ( fetchStackTrace ( ) ) ; }
public void printStackTrace ( PrintStream ps ) { ps . println ( fetchStackTrace ( ) ) ; }
public void printStackTrace ( PrintStream ps ) { ps . println ( fetchStackTrace ( ) ) ; }
public void testCase13 ( ) { byte aBytes [ ] = { _NUM , _NUM , - _NUM , _NUM , _NUM , - _NUM , _NUM , - _NUM } ; int aSign = _NUM ; byte rBytes [ ] = { _NUM , _NUM , - _NUM , _NUM , _NUM , - _NUM , _NUM , - _NUM } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = BigInteger . ONE ; BigInteger result = aNumber . divide ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , result . signum ( ) ) ; }
private boolean isShellOnly ( Method method ) { CliMetaData cliMetadata = method . getAnnotation ( CliMetaData . class ) ; return cliMetadata != null && cliMetadata . shellOnly ( ) ; }
public boolean shouldInclude ( final Path path ) { return includeMatchers . size ( ) == _NUM || matches ( path , includeMatchers ) ; }
private void bappend ( char ch ) { try { mBuff [ ++ mBuffIdx ] = ch ; } catch ( Exception exp ) { char buff [ ] = new char [ mBuff . length << _NUM ] ; System . arraycopy ( mBuff , _NUM , buff , _NUM , mBuff . length ) ; mBuff = buff ; mBuff [ mBuffIdx ] = ch ; } }
public static String convertBytesToGBInStr ( Long size ) { if ( size == null ) { return String . format ( STRING ) ; } return String . format ( STRING , ( size / ( double ) GB ) ) ; }
public static String convertBytesToGBInStr ( Long size ) { if ( size == null ) { return String . format ( STRING ) ; } return String . format ( STRING , ( size / ( double ) GB ) ) ; }
public void delete ( String name ) throws CertificateException , IOException { if ( name . equalsIgnoreCase ( NOT_BEFORE ) ) { notBefore = null ; } else if ( name . equalsIgnoreCase ( NOT_AFTER ) ) { notAfter = null ; } else { throw new CertificateException ( STRING + STRING ) ; } encodeThis ( ) ; }
public static String createTestPtTravelTimesAndDistancesCSVFile ( ) { String location = TempDirectoryUtil . createCustomTempDirectory ( STRING ) + STRING ; BufferedWriter bw = IOUtils . getBufferedWriter ( location ) ; try { for ( int origin = _NUM ; origin <= _NUM ; origin ++ ) { for ( int destination = _NUM ; destination <= _NUM ; destination ++ ) { if ( origin == destination ) bw . write ( origin + STRING + destination + STRING + org . matsim . contrib . matsim4urbansim . utils . InternalConstants . NEW_LINE ) ; else bw . write ( origin + STRING + destination + STRING + org . matsim . contrib . matsim4urbansim . utils . InternalConstants . NEW_LINE ) ; } } bw . flush ( ) ; bw . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return location ; }
public static String createTestPtTravelTimesAndDistancesCSVFile ( ) { String location = TempDirectoryUtil . createCustomTempDirectory ( STRING ) + STRING ; BufferedWriter bw = IOUtils . getBufferedWriter ( location ) ; try { for ( int origin = _NUM ; origin <= _NUM ; origin ++ ) { for ( int destination = _NUM ; destination <= _NUM ; destination ++ ) { if ( origin == destination ) bw . write ( origin + STRING + destination + STRING + org . matsim . contrib . matsim4urbansim . utils . InternalConstants . NEW_LINE ) ; else bw . write ( origin + STRING + destination + STRING + org . matsim . contrib . matsim4urbansim . utils . InternalConstants . NEW_LINE ) ; } } bw . flush ( ) ; bw . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return location ; }
public static String createTestPtTravelTimesAndDistancesCSVFile ( ) { String location = TempDirectoryUtil . createCustomTempDirectory ( STRING ) + STRING ; BufferedWriter bw = IOUtils . getBufferedWriter ( location ) ; try { for ( int origin = _NUM ; origin <= _NUM ; origin ++ ) { for ( int destination = _NUM ; destination <= _NUM ; destination ++ ) { if ( origin == destination ) bw . write ( origin + STRING + destination + STRING + org . matsim . contrib . matsim4urbansim . utils . InternalConstants . NEW_LINE ) ; else bw . write ( origin + STRING + destination + STRING + org . matsim . contrib . matsim4urbansim . utils . InternalConstants . NEW_LINE ) ; } } bw . flush ( ) ; bw . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return location ; }
private static List < Ignite > allGrids ( boolean wait ) { List < Ignite > allIgnites = new ArrayList < > ( grids . size ( ) + _NUM ) ; for ( IgniteNamedInstance grid : grids . values ( ) ) { Ignite g = wait ? grid . grid ( ) : grid . gridx ( ) ; if ( g != null ) allIgnites . add ( g ) ; } IgniteNamedInstance dfltGrid0 = dfltGrid ; if ( dfltGrid0 != null ) { IgniteKernal g = wait ? dfltGrid0 . grid ( ) : dfltGrid0 . gridx ( ) ; if ( g != null ) allIgnites . add ( g ) ; } return allIgnites ; }
public static boolean isUnixSocketUri ( @ NotNull URI uri ) { Objects . requireNonNull ( uri , STRING ) ; return UNIX_SOCKET_SCHEME . equals ( uri . getScheme ( ) ) ; }
private void gauss ( int size ) { int start = ( windowFunction . length - size ) / _NUM ; int stop = ( windowFunction . length + size ) / _NUM ; double delta = _NUM / size ; double x = ( _NUM - size ) / _NUM * delta ; double c = - Math . PI * Math . exp ( _NUM ) / _NUM ; double sum = _NUM ; for ( int i = start ; i < stop ; i ++ ) { windowFunction [ i ] = Math . exp ( c * x * x ) ; x += delta ; sum += windowFunction [ i ] ; } for ( int i = start ; i < stop ; i ++ ) windowFunction [ i ] /= sum ; }
public void removeOnTabSelectedListener ( OnTabSelectedListener listener ) { if ( listener != null ) { mListeners . remove ( listener ) ; } }
public static File createTempFile ( ) { File tempFile ; try { tempFile = File . createTempFile ( STRING , STRING ) ; } catch ( Exception e ) { throw new IllegalStateException ( STRING , e ) ; } return tempFile ; }
public final boolean isVbr ( ) { return vbr ; }
public final boolean isVbr ( ) { return vbr ; }
public DNetscapeRevocationUrl ( JDialog parent ) { super ( parent ) ; setTitle ( res . getString ( STRING ) ) ; initComponents ( ) ; }
private boolean selectItem ( int position ) { disMissOrUpdatePopupWindow ( ) ; if ( position >= _NUM && mCacheDataList . size ( ) > position ) { setText ( mCacheDataList . get ( position ) ) ; return _BOOL ; } return _BOOL ; }
public static double numAllConditions ( Instances data ) { double total = _NUM ; Enumeration < Attribute > attEnum = data . enumerateAttributes ( ) ; while ( attEnum . hasMoreElements ( ) ) { Attribute att = attEnum . nextElement ( ) ; if ( att . isNominal ( ) ) { total += att . numValues ( ) ; } else { total += _NUM * data . numDistinctValues ( att ) ; } } return total ; }
public static double numAllConditions ( Instances data ) { double total = _NUM ; Enumeration < Attribute > attEnum = data . enumerateAttributes ( ) ; while ( attEnum . hasMoreElements ( ) ) { Attribute att = attEnum . nextElement ( ) ; if ( att . isNominal ( ) ) { total += att . numValues ( ) ; } else { total += _NUM * data . numDistinctValues ( att ) ; } } return total ; }
public static double numAllConditions ( Instances data ) { double total = _NUM ; Enumeration < Attribute > attEnum = data . enumerateAttributes ( ) ; while ( attEnum . hasMoreElements ( ) ) { Attribute att = attEnum . nextElement ( ) ; if ( att . isNominal ( ) ) { total += att . numValues ( ) ; } else { total += _NUM * data . numDistinctValues ( att ) ; } } return total ; }
public static double numAllConditions ( Instances data ) { double total = _NUM ; Enumeration < Attribute > attEnum = data . enumerateAttributes ( ) ; while ( attEnum . hasMoreElements ( ) ) { Attribute att = attEnum . nextElement ( ) ; if ( att . isNominal ( ) ) { total += att . numValues ( ) ; } else { total += _NUM * data . numDistinctValues ( att ) ; } } return total ; }
public String allocateRoute ( List < BlockOrder > orders ) { if ( _totalAllocated ) { return null ; } if ( orders == null ) { _orders = getBlockOrders ( ) ; } else { _orders = orders ; } _allocated = _BOOL ; _totalAllocated = _BOOL ; String msg = checkInService ( ) ; if ( msg != null ) { _totalAllocated = _BOOL ; return msg ; } OBlock block = getBlockAt ( _NUM ) ; msg = block . allocate ( this ) ; if ( msg != null ) { return msg ; } allocateFromIndex ( _NUM ) ; return null ; }
public static void skipFully ( InputStream in , long bytes ) throws IOException { if ( bytes < _NUM ) { throw new IllegalArgumentException ( STRING + bytes + STRING ) ; } long remaining = bytes ; while ( remaining > _NUM ) { long skipped = in . skip ( remaining ) ; if ( skipped <= _NUM ) { throw new EOFException ( STRING + bytes ) ; } remaining -= skipped ; } }
private void readObject ( ObjectInputStream oos ) throws IOException , ClassNotFoundException { iInstant = ( LocalTime ) oos . readObject ( ) ; DateTimeFieldType type = ( DateTimeFieldType ) oos . readObject ( ) ; iField = type . getField ( iInstant . getChronology ( ) ) ; }
private void readObject ( ObjectInputStream oos ) throws IOException , ClassNotFoundException { iInstant = ( LocalTime ) oos . readObject ( ) ; DateTimeFieldType type = ( DateTimeFieldType ) oos . readObject ( ) ; iField = type . getField ( iInstant . getChronology ( ) ) ; }
public CodeSourceFacade ( final CodeSource codeSource ) { this . location = codeSource . getLocation ( ) ; final Certificate [ ] certificates = codeSource . getCertificates ( ) ; if ( null == certificates || _NUM == certificates . length ) { LOGGER . warning ( String . format ( STRING , codeSource ) ) ; this . firstCertificate = null ; return ; } this . firstCertificate = ( X509Certificate ) certificates [ _NUM ] ; }
private static byte [ ] createFileReq ( byte [ ] command , String path ) { byte [ ] pathContent ; try { pathContent = path . getBytes ( AdbHelper . DEFAULT_ENCODING ) ; } catch ( UnsupportedEncodingException e ) { return null ; } return createFileReq ( command , pathContent ) ; }
public void testScalarsWithTyping ( ) throws Exception { ObjectMapper m = new ObjectMapper ( ) ; String json ; DynamicWrapper result ; json = m . writeValueAsString ( new DynamicWrapper ( Integer . valueOf ( _NUM ) ) ) ; result = m . readValue ( json , DynamicWrapper . class ) ; assertEquals ( Integer . valueOf ( _NUM ) , result . value ) ; json = m . writeValueAsString ( new DynamicWrapper ( STRING ) ) ; result = m . readValue ( json , DynamicWrapper . class ) ; assertEquals ( STRING , result . value ) ; json = m . writeValueAsString ( new DynamicWrapper ( STRING ) ) ; result = m . readValue ( json , DynamicWrapper . class ) ; assertEquals ( STRING , result . value ) ; json = m . writeValueAsString ( new DynamicWrapper ( Boolean . TRUE ) ) ; result = m . readValue ( json , DynamicWrapper . class ) ; assertEquals ( Boolean . TRUE , result . value ) ; json = m . writeValueAsString ( new DynamicWrapper ( Long . valueOf ( _NUM ) ) ) ; result = m . readValue ( json , DynamicWrapper . class ) ; assertEquals ( Long . valueOf ( _NUM ) , result . value ) ; json = m . writeValueAsString ( new DynamicWrapper ( TestEnum . B ) ) ; result = m . readValue ( json , DynamicWrapper . class ) ; assertEquals ( TestEnum . B , result . value ) ; }
public static void main ( String arg [ ] ) { Display display = new Display ( ) ; Shell shell = new Shell ( display ) ; File file = JFileDataStoreChooser . showOpenFile ( STRING , shell ) ; if ( file != null ) { MessageDialog . openInformation ( shell , STRING , STRING + file . getAbsolutePath ( ) ) ; } else { MessageDialog . openInformation ( shell , STRING , STRING ) ; } }
public static void main ( String arg [ ] ) { Display display = new Display ( ) ; Shell shell = new Shell ( display ) ; File file = JFileDataStoreChooser . showOpenFile ( STRING , shell ) ; if ( file != null ) { MessageDialog . openInformation ( shell , STRING , STRING + file . getAbsolutePath ( ) ) ; } else { MessageDialog . openInformation ( shell , STRING , STRING ) ; } }
public TFSRepository connectIfNecessary ( final IProject project ) { Check . notNull ( project , STRING ) ; waitForManagerStartup ( ) ; ProjectRepositoryData projectData ; synchronized ( projectDataLock ) { projectData = projectDataMap . get ( project ) ; if ( projectData == null ) { Boolean shouldConnect = shouldConnect ( project ) ; if ( shouldConnect == null ) { return null ; } projectData = new ProjectRepositoryData ( ) ; projectDataMap . put ( project , projectData ) ; projectClosedSet . remove ( project ) ; if ( shouldConnect . equals ( Boolean . FALSE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . ONLINE ) ) { shouldConnect = Boolean . TRUE ; } else if ( shouldConnect . equals ( Boolean . TRUE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . OFFLINE ) ) { shouldConnect = Boolean . FALSE ; } if ( shouldConnect == Boolean . FALSE ) { projectData . setStatus ( ProjectRepositoryStatus . OFFLINE ) ; return null ; } projectData . setStatus ( ProjectRepositoryStatus . CONNECTING ) ; } else { synchronized ( projectData ) { if ( projectData . getStatus ( ) == ProjectRepositoryStatus . INITIALIZING ) { return null ; } else if ( projectData . getStatus ( ) != ProjectRepositoryStatus . CONNECTING ) { return projectData . getRepository ( ) ; } } } } return connectInternal ( project , _BOOL , projectData ) ; }
public TFSRepository connectIfNecessary ( final IProject project ) { Check . notNull ( project , STRING ) ; waitForManagerStartup ( ) ; ProjectRepositoryData projectData ; synchronized ( projectDataLock ) { projectData = projectDataMap . get ( project ) ; if ( projectData == null ) { Boolean shouldConnect = shouldConnect ( project ) ; if ( shouldConnect == null ) { return null ; } projectData = new ProjectRepositoryData ( ) ; projectDataMap . put ( project , projectData ) ; projectClosedSet . remove ( project ) ; if ( shouldConnect . equals ( Boolean . FALSE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . ONLINE ) ) { shouldConnect = Boolean . TRUE ; } else if ( shouldConnect . equals ( Boolean . TRUE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . OFFLINE ) ) { shouldConnect = Boolean . FALSE ; } if ( shouldConnect == Boolean . FALSE ) { projectData . setStatus ( ProjectRepositoryStatus . OFFLINE ) ; return null ; } projectData . setStatus ( ProjectRepositoryStatus . CONNECTING ) ; } else { synchronized ( projectData ) { if ( projectData . getStatus ( ) == ProjectRepositoryStatus . INITIALIZING ) { return null ; } else if ( projectData . getStatus ( ) != ProjectRepositoryStatus . CONNECTING ) { return projectData . getRepository ( ) ; } } } } return connectInternal ( project , _BOOL , projectData ) ; }
public TFSRepository connectIfNecessary ( final IProject project ) { Check . notNull ( project , STRING ) ; waitForManagerStartup ( ) ; ProjectRepositoryData projectData ; synchronized ( projectDataLock ) { projectData = projectDataMap . get ( project ) ; if ( projectData == null ) { Boolean shouldConnect = shouldConnect ( project ) ; if ( shouldConnect == null ) { return null ; } projectData = new ProjectRepositoryData ( ) ; projectDataMap . put ( project , projectData ) ; projectClosedSet . remove ( project ) ; if ( shouldConnect . equals ( Boolean . FALSE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . ONLINE ) ) { shouldConnect = Boolean . TRUE ; } else if ( shouldConnect . equals ( Boolean . TRUE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . OFFLINE ) ) { shouldConnect = Boolean . FALSE ; } if ( shouldConnect == Boolean . FALSE ) { projectData . setStatus ( ProjectRepositoryStatus . OFFLINE ) ; return null ; } projectData . setStatus ( ProjectRepositoryStatus . CONNECTING ) ; } else { synchronized ( projectData ) { if ( projectData . getStatus ( ) == ProjectRepositoryStatus . INITIALIZING ) { return null ; } else if ( projectData . getStatus ( ) != ProjectRepositoryStatus . CONNECTING ) { return projectData . getRepository ( ) ; } } } } return connectInternal ( project , _BOOL , projectData ) ; }
public TFSRepository connectIfNecessary ( final IProject project ) { Check . notNull ( project , STRING ) ; waitForManagerStartup ( ) ; ProjectRepositoryData projectData ; synchronized ( projectDataLock ) { projectData = projectDataMap . get ( project ) ; if ( projectData == null ) { Boolean shouldConnect = shouldConnect ( project ) ; if ( shouldConnect == null ) { return null ; } projectData = new ProjectRepositoryData ( ) ; projectDataMap . put ( project , projectData ) ; projectClosedSet . remove ( project ) ; if ( shouldConnect . equals ( Boolean . FALSE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . ONLINE ) ) { shouldConnect = Boolean . TRUE ; } else if ( shouldConnect . equals ( Boolean . TRUE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . OFFLINE ) ) { shouldConnect = Boolean . FALSE ; } if ( shouldConnect == Boolean . FALSE ) { projectData . setStatus ( ProjectRepositoryStatus . OFFLINE ) ; return null ; } projectData . setStatus ( ProjectRepositoryStatus . CONNECTING ) ; } else { synchronized ( projectData ) { if ( projectData . getStatus ( ) == ProjectRepositoryStatus . INITIALIZING ) { return null ; } else if ( projectData . getStatus ( ) != ProjectRepositoryStatus . CONNECTING ) { return projectData . getRepository ( ) ; } } } } return connectInternal ( project , _BOOL , projectData ) ; }
public TFSRepository connectIfNecessary ( final IProject project ) { Check . notNull ( project , STRING ) ; waitForManagerStartup ( ) ; ProjectRepositoryData projectData ; synchronized ( projectDataLock ) { projectData = projectDataMap . get ( project ) ; if ( projectData == null ) { Boolean shouldConnect = shouldConnect ( project ) ; if ( shouldConnect == null ) { return null ; } projectData = new ProjectRepositoryData ( ) ; projectDataMap . put ( project , projectData ) ; projectClosedSet . remove ( project ) ; if ( shouldConnect . equals ( Boolean . FALSE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . ONLINE ) ) { shouldConnect = Boolean . TRUE ; } else if ( shouldConnect . equals ( Boolean . TRUE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . OFFLINE ) ) { shouldConnect = Boolean . FALSE ; } if ( shouldConnect == Boolean . FALSE ) { projectData . setStatus ( ProjectRepositoryStatus . OFFLINE ) ; return null ; } projectData . setStatus ( ProjectRepositoryStatus . CONNECTING ) ; } else { synchronized ( projectData ) { if ( projectData . getStatus ( ) == ProjectRepositoryStatus . INITIALIZING ) { return null ; } else if ( projectData . getStatus ( ) != ProjectRepositoryStatus . CONNECTING ) { return projectData . getRepository ( ) ; } } } } return connectInternal ( project , _BOOL , projectData ) ; }
public TFSRepository connectIfNecessary ( final IProject project ) { Check . notNull ( project , STRING ) ; waitForManagerStartup ( ) ; ProjectRepositoryData projectData ; synchronized ( projectDataLock ) { projectData = projectDataMap . get ( project ) ; if ( projectData == null ) { Boolean shouldConnect = shouldConnect ( project ) ; if ( shouldConnect == null ) { return null ; } projectData = new ProjectRepositoryData ( ) ; projectDataMap . put ( project , projectData ) ; projectClosedSet . remove ( project ) ; if ( shouldConnect . equals ( Boolean . FALSE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . ONLINE ) ) { shouldConnect = Boolean . TRUE ; } else if ( shouldConnect . equals ( Boolean . TRUE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . OFFLINE ) ) { shouldConnect = Boolean . FALSE ; } if ( shouldConnect == Boolean . FALSE ) { projectData . setStatus ( ProjectRepositoryStatus . OFFLINE ) ; return null ; } projectData . setStatus ( ProjectRepositoryStatus . CONNECTING ) ; } else { synchronized ( projectData ) { if ( projectData . getStatus ( ) == ProjectRepositoryStatus . INITIALIZING ) { return null ; } else if ( projectData . getStatus ( ) != ProjectRepositoryStatus . CONNECTING ) { return projectData . getRepository ( ) ; } } } } return connectInternal ( project , _BOOL , projectData ) ; }
public TFSRepository connectIfNecessary ( final IProject project ) { Check . notNull ( project , STRING ) ; waitForManagerStartup ( ) ; ProjectRepositoryData projectData ; synchronized ( projectDataLock ) { projectData = projectDataMap . get ( project ) ; if ( projectData == null ) { Boolean shouldConnect = shouldConnect ( project ) ; if ( shouldConnect == null ) { return null ; } projectData = new ProjectRepositoryData ( ) ; projectDataMap . put ( project , projectData ) ; projectClosedSet . remove ( project ) ; if ( shouldConnect . equals ( Boolean . FALSE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . ONLINE ) ) { shouldConnect = Boolean . TRUE ; } else if ( shouldConnect . equals ( Boolean . TRUE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . OFFLINE ) ) { shouldConnect = Boolean . FALSE ; } if ( shouldConnect == Boolean . FALSE ) { projectData . setStatus ( ProjectRepositoryStatus . OFFLINE ) ; return null ; } projectData . setStatus ( ProjectRepositoryStatus . CONNECTING ) ; } else { synchronized ( projectData ) { if ( projectData . getStatus ( ) == ProjectRepositoryStatus . INITIALIZING ) { return null ; } else if ( projectData . getStatus ( ) != ProjectRepositoryStatus . CONNECTING ) { return projectData . getRepository ( ) ; } } } } return connectInternal ( project , _BOOL , projectData ) ; }
public TFSRepository connectIfNecessary ( final IProject project ) { Check . notNull ( project , STRING ) ; waitForManagerStartup ( ) ; ProjectRepositoryData projectData ; synchronized ( projectDataLock ) { projectData = projectDataMap . get ( project ) ; if ( projectData == null ) { Boolean shouldConnect = shouldConnect ( project ) ; if ( shouldConnect == null ) { return null ; } projectData = new ProjectRepositoryData ( ) ; projectDataMap . put ( project , projectData ) ; projectClosedSet . remove ( project ) ; if ( shouldConnect . equals ( Boolean . FALSE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . ONLINE ) ) { shouldConnect = Boolean . TRUE ; } else if ( shouldConnect . equals ( Boolean . TRUE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . OFFLINE ) ) { shouldConnect = Boolean . FALSE ; } if ( shouldConnect == Boolean . FALSE ) { projectData . setStatus ( ProjectRepositoryStatus . OFFLINE ) ; return null ; } projectData . setStatus ( ProjectRepositoryStatus . CONNECTING ) ; } else { synchronized ( projectData ) { if ( projectData . getStatus ( ) == ProjectRepositoryStatus . INITIALIZING ) { return null ; } else if ( projectData . getStatus ( ) != ProjectRepositoryStatus . CONNECTING ) { return projectData . getRepository ( ) ; } } } } return connectInternal ( project , _BOOL , projectData ) ; }
public TFSRepository connectIfNecessary ( final IProject project ) { Check . notNull ( project , STRING ) ; waitForManagerStartup ( ) ; ProjectRepositoryData projectData ; synchronized ( projectDataLock ) { projectData = projectDataMap . get ( project ) ; if ( projectData == null ) { Boolean shouldConnect = shouldConnect ( project ) ; if ( shouldConnect == null ) { return null ; } projectData = new ProjectRepositoryData ( ) ; projectDataMap . put ( project , projectData ) ; projectClosedSet . remove ( project ) ; if ( shouldConnect . equals ( Boolean . FALSE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . ONLINE ) ) { shouldConnect = Boolean . TRUE ; } else if ( shouldConnect . equals ( Boolean . TRUE ) && isAnyProjectOfStatus ( ProjectRepositoryStatus . OFFLINE ) ) { shouldConnect = Boolean . FALSE ; } if ( shouldConnect == Boolean . FALSE ) { projectData . setStatus ( ProjectRepositoryStatus . OFFLINE ) ; return null ; } projectData . setStatus ( ProjectRepositoryStatus . CONNECTING ) ; } else { synchronized ( projectData ) { if ( projectData . getStatus ( ) == ProjectRepositoryStatus . INITIALIZING ) { return null ; } else if ( projectData . getStatus ( ) != ProjectRepositoryStatus . CONNECTING ) { return projectData . getRepository ( ) ; } } } } return connectInternal ( project , _BOOL , projectData ) ; }
@ Override public Void visitType ( TypeElement e , Void p ) { scan ( e . getTypeParameters ( ) , p ) ; checkCamelCase ( e , _BOOL ) ; super . visitType ( e , p ) ; return null ; }
public CharSeq replaceAll ( String regex , String replacement ) { return CharSeq . of ( str . replaceAll ( regex , replacement ) ) ; }
public CharSeq replaceAll ( String regex , String replacement ) { return CharSeq . of ( str . replaceAll ( regex , replacement ) ) ; }
public void addChild ( TreeNode node ) { if ( children == null ) children = new ArrayList < TreeNode > ( ) ; children . add ( node ) ; }
public void addChild ( TreeNode node ) { if ( children == null ) children = new ArrayList < TreeNode > ( ) ; children . add ( node ) ; }
private ObjectAnimator createEnteringImageMatrixAnimator ( ) { Matrix initMatrix = MatrixUtils . getImageMatrix ( mAnimatedImage ) ; initMatrix . getValues ( mInitThumbnailMatrixValues ) ; final Matrix endMatrix = MatrixUtils . getImageMatrix ( mImageTo ) ; Log . v ( TAG , STRING + Arrays . toString ( mInitThumbnailMatrixValues ) ) ; Log . v ( TAG , STRING + initMatrix ) ; Log . v ( TAG , STRING + endMatrix ) ; mAnimatedImage . setScaleType ( ImageView . ScaleType . MATRIX ) ; return ObjectAnimator . ofObject ( mAnimatedImage , MatrixEvaluator . ANIMATED_TRANSFORM_PROPERTY , new MatrixEvaluator ( ) , initMatrix , endMatrix ) ; }
private ObjectAnimator createEnteringImageMatrixAnimator ( ) { Matrix initMatrix = MatrixUtils . getImageMatrix ( mAnimatedImage ) ; initMatrix . getValues ( mInitThumbnailMatrixValues ) ; final Matrix endMatrix = MatrixUtils . getImageMatrix ( mImageTo ) ; Log . v ( TAG , STRING + Arrays . toString ( mInitThumbnailMatrixValues ) ) ; Log . v ( TAG , STRING + initMatrix ) ; Log . v ( TAG , STRING + endMatrix ) ; mAnimatedImage . setScaleType ( ImageView . ScaleType . MATRIX ) ; return ObjectAnimator . ofObject ( mAnimatedImage , MatrixEvaluator . ANIMATED_TRANSFORM_PROPERTY , new MatrixEvaluator ( ) , initMatrix , endMatrix ) ; }
private ObjectAnimator createEnteringImageMatrixAnimator ( ) { Matrix initMatrix = MatrixUtils . getImageMatrix ( mAnimatedImage ) ; initMatrix . getValues ( mInitThumbnailMatrixValues ) ; final Matrix endMatrix = MatrixUtils . getImageMatrix ( mImageTo ) ; Log . v ( TAG , STRING + Arrays . toString ( mInitThumbnailMatrixValues ) ) ; Log . v ( TAG , STRING + initMatrix ) ; Log . v ( TAG , STRING + endMatrix ) ; mAnimatedImage . setScaleType ( ImageView . ScaleType . MATRIX ) ; return ObjectAnimator . ofObject ( mAnimatedImage , MatrixEvaluator . ANIMATED_TRANSFORM_PROPERTY , new MatrixEvaluator ( ) , initMatrix , endMatrix ) ; }
private ObjectAnimator createEnteringImageMatrixAnimator ( ) { Matrix initMatrix = MatrixUtils . getImageMatrix ( mAnimatedImage ) ; initMatrix . getValues ( mInitThumbnailMatrixValues ) ; final Matrix endMatrix = MatrixUtils . getImageMatrix ( mImageTo ) ; Log . v ( TAG , STRING + Arrays . toString ( mInitThumbnailMatrixValues ) ) ; Log . v ( TAG , STRING + initMatrix ) ; Log . v ( TAG , STRING + endMatrix ) ; mAnimatedImage . setScaleType ( ImageView . ScaleType . MATRIX ) ; return ObjectAnimator . ofObject ( mAnimatedImage , MatrixEvaluator . ANIMATED_TRANSFORM_PROPERTY , new MatrixEvaluator ( ) , initMatrix , endMatrix ) ; }
private ObjectAnimator createEnteringImageMatrixAnimator ( ) { Matrix initMatrix = MatrixUtils . getImageMatrix ( mAnimatedImage ) ; initMatrix . getValues ( mInitThumbnailMatrixValues ) ; final Matrix endMatrix = MatrixUtils . getImageMatrix ( mImageTo ) ; Log . v ( TAG , STRING + Arrays . toString ( mInitThumbnailMatrixValues ) ) ; Log . v ( TAG , STRING + initMatrix ) ; Log . v ( TAG , STRING + endMatrix ) ; mAnimatedImage . setScaleType ( ImageView . ScaleType . MATRIX ) ; return ObjectAnimator . ofObject ( mAnimatedImage , MatrixEvaluator . ANIMATED_TRANSFORM_PROPERTY , new MatrixEvaluator ( ) , initMatrix , endMatrix ) ; }
protected boolean isEqualValue ( Object value1 , Object value2 ) { return ( value1 == value2 || value1 . equals ( value2 ) ) ; }
protected boolean isEqualValue ( Object value1 , Object value2 ) { return ( value1 == value2 || value1 . equals ( value2 ) ) ; }
private void restoreIcon ( Key key , byte [ ] buffer , int dataSize ) throws IOException { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base64 . encodeToString ( buffer , _NUM , dataSize , Base64 . NO_WRAP ) ) ; Resource res = unpackProto ( new Resource ( ) , buffer , dataSize ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = BitmapFactory . decodeByteArray ( res . data , _NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; IconCache . preloadIcon ( mContext , ComponentName . unflattenFromString ( key . name ) , icon , res . dpi ) ; }
private void restoreIcon ( Key key , byte [ ] buffer , int dataSize ) throws IOException { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base64 . encodeToString ( buffer , _NUM , dataSize , Base64 . NO_WRAP ) ) ; Resource res = unpackProto ( new Resource ( ) , buffer , dataSize ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = BitmapFactory . decodeByteArray ( res . data , _NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; IconCache . preloadIcon ( mContext , ComponentName . unflattenFromString ( key . name ) , icon , res . dpi ) ; }
private void restoreIcon ( Key key , byte [ ] buffer , int dataSize ) throws IOException { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base64 . encodeToString ( buffer , _NUM , dataSize , Base64 . NO_WRAP ) ) ; Resource res = unpackProto ( new Resource ( ) , buffer , dataSize ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = BitmapFactory . decodeByteArray ( res . data , _NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; IconCache . preloadIcon ( mContext , ComponentName . unflattenFromString ( key . name ) , icon , res . dpi ) ; }
private void restoreIcon ( Key key , byte [ ] buffer , int dataSize ) throws IOException { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base64 . encodeToString ( buffer , _NUM , dataSize , Base64 . NO_WRAP ) ) ; Resource res = unpackProto ( new Resource ( ) , buffer , dataSize ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = BitmapFactory . decodeByteArray ( res . data , _NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; IconCache . preloadIcon ( mContext , ComponentName . unflattenFromString ( key . name ) , icon , res . dpi ) ; }
private void restoreIcon ( Key key , byte [ ] buffer , int dataSize ) throws IOException { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base64 . encodeToString ( buffer , _NUM , dataSize , Base64 . NO_WRAP ) ) ; Resource res = unpackProto ( new Resource ( ) , buffer , dataSize ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = BitmapFactory . decodeByteArray ( res . data , _NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; IconCache . preloadIcon ( mContext , ComponentName . unflattenFromString ( key . name ) , icon , res . dpi ) ; }
static Object newPropertyChangeEvent ( Object source , String prop , Object oldValue , Object newValue ) { try { return propertyEventCtor . newInstance ( source , prop , oldValue , newValue ) ; } catch ( InstantiationException | IllegalAccessException x ) { throw new AssertionError ( x ) ; } catch ( InvocationTargetException x ) { Throwable cause = x . getCause ( ) ; if ( cause instanceof Error ) throw ( Error ) cause ; if ( cause instanceof RuntimeException ) throw ( RuntimeException ) cause ; throw new AssertionError ( x ) ; } }
@ Override public SelectableChannel selectableChannel ( ) { return socketChannel ; }
@ Override public SelectableChannel selectableChannel ( ) { return socketChannel ; }
public static ExecutorServiceCloser of ( ExecutorService executorService ) { return new ExecutorServiceCloser ( executorService , Optional . empty ( ) ) ; }
public static ExecutorServiceCloser of ( ExecutorService executorService ) { return new ExecutorServiceCloser ( executorService , Optional . empty ( ) ) ; }
public static ExecutorServiceCloser of ( ExecutorService executorService ) { return new ExecutorServiceCloser ( executorService , Optional . empty ( ) ) ; }
public static ExecutorServiceCloser of ( ExecutorService executorService ) { return new ExecutorServiceCloser ( executorService , Optional . empty ( ) ) ; }
public void performActions ( ) throws Throwable { for ( Throwing . Runnable action : actions ) { action . run ( ) ; } }
private void showPopupMenu ( final MouseEvent event ) { final int [ ] rows = m_eventTable . getConvertedSelectedRows ( ) ; final List < ITraceEvent > traces = getTraces ( rows ) ; final CEventTableMenu menu = new CEventTableMenu ( m_eventTable , m_model , traces ) ; menu . show ( m_eventTable , event . getX ( ) , event . getY ( ) ) ; }
public void writeExif ( String jpegFileName , String exifOutFileName ) throws FileNotFoundException , IOException { if ( jpegFileName == null || exifOutFileName == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } InputStream is = null ; is = new FileInputStream ( jpegFileName ) ; writeExif ( is , exifOutFileName ) ; is . close ( ) ; }
public void writeExif ( String jpegFileName , String exifOutFileName ) throws FileNotFoundException , IOException { if ( jpegFileName == null || exifOutFileName == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } InputStream is = null ; is = new FileInputStream ( jpegFileName ) ; writeExif ( is , exifOutFileName ) ; is . close ( ) ; }
static public void assertStatementIndicesConsistent ( final AbstractTripleStore db , final int maxerrors ) { if ( log . isInfoEnabled ( ) ) log . info ( STRING ) ; final AtomicInteger nerrs = new AtomicInteger ( _NUM ) ; final int from , to ; if ( db . getSPOKeyArity ( ) == _NUM ) { from = SPOKeyOrder . FIRST_TRIPLE_INDEX ; to = SPOKeyOrder . LAST_TRIPLE_INDEX ; } else { from = SPOKeyOrder . FIRST_QUAD_INDEX ; to = SPOKeyOrder . LAST_QUAD_INDEX ; } for ( int i = from ; i <= to ; i ++ ) { for ( int j = from ; j <= to ; j ++ ) { if ( i <= j ) { continue ; } assertSameStatements ( db , SPOKeyOrder . valueOf ( i ) , SPOKeyOrder . valueOf ( j ) , nerrs , maxerrors ) ; } } assertEquals ( _NUM , nerrs . get ( ) ) ; }
static public void assertStatementIndicesConsistent ( final AbstractTripleStore db , final int maxerrors ) { if ( log . isInfoEnabled ( ) ) log . info ( STRING ) ; final AtomicInteger nerrs = new AtomicInteger ( _NUM ) ; final int from , to ; if ( db . getSPOKeyArity ( ) == _NUM ) { from = SPOKeyOrder . FIRST_TRIPLE_INDEX ; to = SPOKeyOrder . LAST_TRIPLE_INDEX ; } else { from = SPOKeyOrder . FIRST_QUAD_INDEX ; to = SPOKeyOrder . LAST_QUAD_INDEX ; } for ( int i = from ; i <= to ; i ++ ) { for ( int j = from ; j <= to ; j ++ ) { if ( i <= j ) { continue ; } assertSameStatements ( db , SPOKeyOrder . valueOf ( i ) , SPOKeyOrder . valueOf ( j ) , nerrs , maxerrors ) ; } } assertEquals ( _NUM , nerrs . get ( ) ) ; }
@ RpcMethod public void powerVmOp ( String vmId , PowerVmOp op , AsyncMethodCallback < Host . AsyncClient . power_vm_op_call > handler ) throws RpcException { ensureClient ( ) ; PowerVmOpRequest powerVmOpRequest = new PowerVmOpRequest ( vmId , op ) ; clientProxy . setTimeout ( POWER_VM_OP_TIMEOUT_MS ) ; logger . info ( STRING , vmId , getHostIp ( ) , powerVmOpRequest ) ; try { clientProxy . power_vm_op ( powerVmOpRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
@ RpcMethod public void powerVmOp ( String vmId , PowerVmOp op , AsyncMethodCallback < Host . AsyncClient . power_vm_op_call > handler ) throws RpcException { ensureClient ( ) ; PowerVmOpRequest powerVmOpRequest = new PowerVmOpRequest ( vmId , op ) ; clientProxy . setTimeout ( POWER_VM_OP_TIMEOUT_MS ) ; logger . info ( STRING , vmId , getHostIp ( ) , powerVmOpRequest ) ; try { clientProxy . power_vm_op ( powerVmOpRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
@ RpcMethod public void powerVmOp ( String vmId , PowerVmOp op , AsyncMethodCallback < Host . AsyncClient . power_vm_op_call > handler ) throws RpcException { ensureClient ( ) ; PowerVmOpRequest powerVmOpRequest = new PowerVmOpRequest ( vmId , op ) ; clientProxy . setTimeout ( POWER_VM_OP_TIMEOUT_MS ) ; logger . info ( STRING , vmId , getHostIp ( ) , powerVmOpRequest ) ; try { clientProxy . power_vm_op ( powerVmOpRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
public FileConfirmationDialog ( @ Nullable Project project , DialogType dialogType , @ NotNull Path targetPath ) { super ( project ) ; this . dialogType = dialogType ; switch ( dialogType ) { case CONFIRM_OVERWRITE : setTitle ( GctBundle . message ( STRING ) ) ; warningLabel . setText ( GctBundle . message ( STRING ) ) ; break ; case CONFIRM_CREATE_DIR : setTitle ( GctBundle . message ( STRING ) ) ; warningLabel . setText ( GctBundle . message ( STRING ) ) ; break ; case NOT_DIRECTORY_ERROR : setTitle ( GctBundle . message ( STRING ) ) ; warningLabel . setText ( GctBundle . message ( STRING ) ) ; break ; default : throw new AssertionError ( ) ; } pathDisplay . setText ( targetPath . toString ( ) ) ; init ( ) ; }
public void sendMessage ( Message message ) throws NotYetConnectedException { lock . lock ( ) ; try { if ( writeTarget == null ) throw new NotYetConnectedException ( ) ; } finally { lock . unlock ( ) ; } ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; try { serializer . serialize ( message , out ) ; writeTarget . writeBytes ( out . toByteArray ( ) ) ; } catch ( IOException e ) { exceptionCaught ( e ) ; } }
public void sendMessage ( Message message ) throws NotYetConnectedException { lock . lock ( ) ; try { if ( writeTarget == null ) throw new NotYetConnectedException ( ) ; } finally { lock . unlock ( ) ; } ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; try { serializer . serialize ( message , out ) ; writeTarget . writeBytes ( out . toByteArray ( ) ) ; } catch ( IOException e ) { exceptionCaught ( e ) ; } }
public void sendMessage ( Message message ) throws NotYetConnectedException { lock . lock ( ) ; try { if ( writeTarget == null ) throw new NotYetConnectedException ( ) ; } finally { lock . unlock ( ) ; } ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; try { serializer . serialize ( message , out ) ; writeTarget . writeBytes ( out . toByteArray ( ) ) ; } catch ( IOException e ) { exceptionCaught ( e ) ; } }
public void sendMessage ( Message message ) throws NotYetConnectedException { lock . lock ( ) ; try { if ( writeTarget == null ) throw new NotYetConnectedException ( ) ; } finally { lock . unlock ( ) ; } ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; try { serializer . serialize ( message , out ) ; writeTarget . writeBytes ( out . toByteArray ( ) ) ; } catch ( IOException e ) { exceptionCaught ( e ) ; } }
public void sendMessage ( Message message ) throws NotYetConnectedException { lock . lock ( ) ; try { if ( writeTarget == null ) throw new NotYetConnectedException ( ) ; } finally { lock . unlock ( ) ; } ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; try { serializer . serialize ( message , out ) ; writeTarget . writeBytes ( out . toByteArray ( ) ) ; } catch ( IOException e ) { exceptionCaught ( e ) ; } }
public Builder entity ( Entity entity ) { if ( entities == null ) { entities = new ArrayList < Entity > ( ) ; } entities . add ( entity ) ; return this ; }
public static String createNameIdentifier ( ) { String handle = null ; try { byte [ ] handleBytes = new byte [ _NUM ] ; randomGenerator . nextBytes ( handleBytes ) ; handle = Base64 . encode ( handleBytes ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STRING + handle ) ; } } catch ( Exception e ) { debug . message ( STRING + STRING + e . getMessage ( ) ) ; } return handle ; }
public static Bootique app ( Collection < String > args ) { if ( args == null ) { args = Collections . emptyList ( ) ; } return app ( toArray ( Objects . requireNonNull ( args ) ) ) ; }
public static Bootique app ( Collection < String > args ) { if ( args == null ) { args = Collections . emptyList ( ) ; } return app ( toArray ( Objects . requireNonNull ( args ) ) ) ; }
private boolean verifyPaymentAllocateVsHeader ( MPaymentAllocate [ ] pAllocs ) { if ( pAllocs . length > _NUM ) { if ( getC_Charge_ID ( ) > _NUM || getC_Invoice_ID ( ) > _NUM || getC_Order_ID ( ) > _NUM ) return _BOOL ; } return _BOOL ; }
private boolean verifyPaymentAllocateVsHeader ( MPaymentAllocate [ ] pAllocs ) { if ( pAllocs . length > _NUM ) { if ( getC_Charge_ID ( ) > _NUM || getC_Invoice_ID ( ) > _NUM || getC_Order_ID ( ) > _NUM ) return _BOOL ; } return _BOOL ; }
protected void processLine ( String line ) throws IOException { if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + line ) ; } if ( line . startsWith ( STRING ) ) { processGetCommand ( line ) ; } else if ( line . startsWith ( STRING ) ) { Debug . message ( STRING , STRING ) ; handlePost ( ) ; } }
private Method lookupSubstitute ( ) { for ( Method m : declaringClass . getDeclaredMethods ( ) ) { if ( isSubstitute ( m ) ) { return m ; } } throw new GraalError ( STRING , this ) ; }
private static boolean validMethod ( String name ) { int len = name . length ( ) ; if ( len == _NUM ) { return _BOOL ; } char c = name . charAt ( _NUM ) ; if ( ! Character . isJavaIdentifierStart ( c ) && ! ( c == STRING && len > _NUM ) ) { return _BOOL ; } if ( c != STRING && name . charAt ( len - _NUM ) == STRING ) { len -- ; } while ( -- len >= _NUM ) { if ( ! Character . isJavaIdentifierPart ( name . charAt ( len ) ) ) { return _BOOL ; } } return _BOOL ; }
private static boolean validMethod ( String name ) { int len = name . length ( ) ; if ( len == _NUM ) { return _BOOL ; } char c = name . charAt ( _NUM ) ; if ( ! Character . isJavaIdentifierStart ( c ) && ! ( c == STRING && len > _NUM ) ) { return _BOOL ; } if ( c != STRING && name . charAt ( len - _NUM ) == STRING ) { len -- ; } while ( -- len >= _NUM ) { if ( ! Character . isJavaIdentifierPart ( name . charAt ( len ) ) ) { return _BOOL ; } } return _BOOL ; }
private static boolean validMethod ( String name ) { int len = name . length ( ) ; if ( len == _NUM ) { return _BOOL ; } char c = name . charAt ( _NUM ) ; if ( ! Character . isJavaIdentifierStart ( c ) && ! ( c == STRING && len > _NUM ) ) { return _BOOL ; } if ( c != STRING && name . charAt ( len - _NUM ) == STRING ) { len -- ; } while ( -- len >= _NUM ) { if ( ! Character . isJavaIdentifierPart ( name . charAt ( len ) ) ) { return _BOOL ; } } return _BOOL ; }
private Rectangle2D [ ] splitVerticalBar ( RectangularShape bar , double a , double b , double c ) { Rectangle2D [ ] result = new Rectangle2D [ _NUM ] ; double x0 = bar . getMinX ( ) ; double x1 = Math . rint ( x0 + ( bar . getWidth ( ) * a ) ) ; double x2 = Math . rint ( x0 + ( bar . getWidth ( ) * b ) ) ; double x3 = Math . rint ( x0 + ( bar . getWidth ( ) * c ) ) ; result [ _NUM ] = new Rectangle2D . Double ( bar . getMinX ( ) , bar . getMinY ( ) , x1 - x0 , bar . getHeight ( ) ) ; result [ _NUM ] = new Rectangle2D . Double ( x1 , bar . getMinY ( ) , x2 - x1 , bar . getHeight ( ) ) ; result [ _NUM ] = new Rectangle2D . Double ( x2 , bar . getMinY ( ) , x3 - x2 , bar . getHeight ( ) ) ; result [ _NUM ] = new Rectangle2D . Double ( x3 , bar . getMinY ( ) , bar . getMaxX ( ) - x3 , bar . getHeight ( ) ) ; return result ; }
private Rectangle2D [ ] splitVerticalBar ( RectangularShape bar , double a , double b , double c ) { Rectangle2D [ ] result = new Rectangle2D [ _NUM ] ; double x0 = bar . getMinX ( ) ; double x1 = Math . rint ( x0 + ( bar . getWidth ( ) * a ) ) ; double x2 = Math . rint ( x0 + ( bar . getWidth ( ) * b ) ) ; double x3 = Math . rint ( x0 + ( bar . getWidth ( ) * c ) ) ; result [ _NUM ] = new Rectangle2D . Double ( bar . getMinX ( ) , bar . getMinY ( ) , x1 - x0 , bar . getHeight ( ) ) ; result [ _NUM ] = new Rectangle2D . Double ( x1 , bar . getMinY ( ) , x2 - x1 , bar . getHeight ( ) ) ; result [ _NUM ] = new Rectangle2D . Double ( x2 , bar . getMinY ( ) , x3 - x2 , bar . getHeight ( ) ) ; result [ _NUM ] = new Rectangle2D . Double ( x3 , bar . getMinY ( ) , bar . getMaxX ( ) - x3 , bar . getHeight ( ) ) ; return result ; }
private Rectangle2D [ ] splitVerticalBar ( RectangularShape bar , double a , double b , double c ) { Rectangle2D [ ] result = new Rectangle2D [ _NUM ] ; double x0 = bar . getMinX ( ) ; double x1 = Math . rint ( x0 + ( bar . getWidth ( ) * a ) ) ; double x2 = Math . rint ( x0 + ( bar . getWidth ( ) * b ) ) ; double x3 = Math . rint ( x0 + ( bar . getWidth ( ) * c ) ) ; result [ _NUM ] = new Rectangle2D . Double ( bar . getMinX ( ) , bar . getMinY ( ) , x1 - x0 , bar . getHeight ( ) ) ; result [ _NUM ] = new Rectangle2D . Double ( x1 , bar . getMinY ( ) , x2 - x1 , bar . getHeight ( ) ) ; result [ _NUM ] = new Rectangle2D . Double ( x2 , bar . getMinY ( ) , x3 - x2 , bar . getHeight ( ) ) ; result [ _NUM ] = new Rectangle2D . Double ( x3 , bar . getMinY ( ) , bar . getMaxX ( ) - x3 , bar . getHeight ( ) ) ; return result ; }
public void writeField ( String name , int value ) throws java . io . IOException { writeField ( name , Integer . toString ( value ) ) ; }
private EnumDeclaration generateEnum ( ) { final String valueString = STRING ; EnumDeclaration newEnum = new EnumDeclaration ( ModifierSet . PUBLIC , null , getEnumerationClassName ( ) , null , generateEnumConstantDeclarations ( ) , null ) ; FieldDeclaration valueField = new FieldDeclaration ( ModifierSet . addModifier ( ModifierSet . FINAL , ModifierSet . PUBLIC ) , ASTHelper . INT_TYPE , Collections . singletonList ( new VariableDeclarator ( new VariableDeclaratorId ( valueString ) ) ) ) ; ASTHelper . addMember ( newEnum , valueField ) ; ConstructorDeclaration enumConstructor = new ConstructorDeclaration ( _NUM , null , null , name , Collections . singletonList ( ASTHelper . createParameter ( ASTHelper . INT_TYPE , valueString ) ) , null , getDefaultConstructorBlockStatement ( valueString ) ) ; ASTHelper . addMember ( newEnum , enumConstructor ) ; return newEnum ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case _NUM : return VOCAB ; case _NUM : return LAYER_SIZE ; case _NUM : return VECTORS ; default : return null ; } }
public Iterator < E > snapshotIterator ( ) { List < E > l = new LinkedList < E > ( this ) ; return l . iterator ( ) ; }
public Iterator < E > snapshotIterator ( ) { List < E > l = new LinkedList < E > ( this ) ; return l . iterator ( ) ; }
public Iterator < E > snapshotIterator ( ) { List < E > l = new LinkedList < E > ( this ) ; return l . iterator ( ) ; }
public Iterator < E > snapshotIterator ( ) { List < E > l = new LinkedList < E > ( this ) ; return l . iterator ( ) ; }
public Iterator < E > snapshotIterator ( ) { List < E > l = new LinkedList < E > ( this ) ; return l . iterator ( ) ; }
public Iterator < E > snapshotIterator ( ) { List < E > l = new LinkedList < E > ( this ) ; return l . iterator ( ) ; }
public Iterator < E > snapshotIterator ( ) { List < E > l = new LinkedList < E > ( this ) ; return l . iterator ( ) ; }
public Iterator < E > snapshotIterator ( ) { List < E > l = new LinkedList < E > ( this ) ; return l . iterator ( ) ; }
public Iterator < E > snapshotIterator ( ) { List < E > l = new LinkedList < E > ( this ) ; return l . iterator ( ) ; }
public String toString ( ) { return super . toString ( ) + STRING + recordMap . size ( ) + STRING + firstOffset + STRING + releaseBuffer + STRING + prefixWrites + STRING + useChecksum + STRING + bytesWritten ( ) + STRING + remaining ( ) + STRING + m_removed + STRING ; }
protected void showPage ( int page ) { boolean isEmpty = page == PAGE_EMPTY ; Control control = isEmpty ? ( Control ) fEmptyPageLabel : getControl ( ) ; if ( isEmpty ) { setContentDescription ( STRING ) ; clearViewer ( ) ; } fPagebook . showPage ( control ) ; }
@ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( requestCode == REQUEST_CODE_AUTOCOMPLETE ) { if ( resultCode == RESULT_OK ) { Place place = PlaceAutocomplete . getPlace ( this , data ) ; Log . i ( TAG , STRING + place . getName ( ) ) ; mPlaceDetailsText . setText ( formatPlaceDetails ( getResources ( ) , place . getName ( ) , place . getId ( ) , place . getAddress ( ) , place . getPhoneNumber ( ) , place . getWebsiteUri ( ) ) ) ; CharSequence attributions = place . getAttributions ( ) ; if ( ! TextUtils . isEmpty ( attributions ) ) { mPlaceAttribution . setText ( Html . fromHtml ( attributions . toString ( ) ) ) ; } else { mPlaceAttribution . setText ( STRING ) ; } } else if ( resultCode == PlaceAutocomplete . RESULT_ERROR ) { Status status = PlaceAutocomplete . getStatus ( this , data ) ; Log . e ( TAG , STRING + status . toString ( ) ) ; } else if ( resultCode == RESULT_CANCELED ) { } } }
@ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( requestCode == REQUEST_CODE_AUTOCOMPLETE ) { if ( resultCode == RESULT_OK ) { Place place = PlaceAutocomplete . getPlace ( this , data ) ; Log . i ( TAG , STRING + place . getName ( ) ) ; mPlaceDetailsText . setText ( formatPlaceDetails ( getResources ( ) , place . getName ( ) , place . getId ( ) , place . getAddress ( ) , place . getPhoneNumber ( ) , place . getWebsiteUri ( ) ) ) ; CharSequence attributions = place . getAttributions ( ) ; if ( ! TextUtils . isEmpty ( attributions ) ) { mPlaceAttribution . setText ( Html . fromHtml ( attributions . toString ( ) ) ) ; } else { mPlaceAttribution . setText ( STRING ) ; } } else if ( resultCode == PlaceAutocomplete . RESULT_ERROR ) { Status status = PlaceAutocomplete . getStatus ( this , data ) ; Log . e ( TAG , STRING + status . toString ( ) ) ; } else if ( resultCode == RESULT_CANCELED ) { } } }
@ Override public Void call ( ) throws Exception { try { NodeHolder nodeHolder = processDataRows ( dataRows ) ; int indexInNodeHolderArray = ( sequenceNumber - _NUM ) % numberOfCores ; blockletDataHolder . put ( nodeHolder , indexInNodeHolderArray ) ; return null ; } catch ( Throwable throwable ) { consumerExecutorService . shutdownNow ( ) ; resetBlockletProcessingCount ( ) ; throw new CarbonDataWriterException ( throwable . getMessage ( ) ) ; } }
@ Override public Void call ( ) throws Exception { try { NodeHolder nodeHolder = processDataRows ( dataRows ) ; int indexInNodeHolderArray = ( sequenceNumber - _NUM ) % numberOfCores ; blockletDataHolder . put ( nodeHolder , indexInNodeHolderArray ) ; return null ; } catch ( Throwable throwable ) { consumerExecutorService . shutdownNow ( ) ; resetBlockletProcessingCount ( ) ; throw new CarbonDataWriterException ( throwable . getMessage ( ) ) ; } }
final boolean areBoundsValid ( ) { Container cont = getContainer ( ) ; return cont == null || cont . isValid ( ) || cont . getLayout ( ) == null ; }
final boolean areBoundsValid ( ) { Container cont = getContainer ( ) ; return cont == null || cont . isValid ( ) || cont . getLayout ( ) == null ; }
final boolean areBoundsValid ( ) { Container cont = getContainer ( ) ; return cont == null || cont . isValid ( ) || cont . getLayout ( ) == null ; }
final boolean areBoundsValid ( ) { Container cont = getContainer ( ) ; return cont == null || cont . isValid ( ) || cont . getLayout ( ) == null ; }
final boolean areBoundsValid ( ) { Container cont = getContainer ( ) ; return cont == null || cont . isValid ( ) || cont . getLayout ( ) == null ; }
final boolean areBoundsValid ( ) { Container cont = getContainer ( ) ; return cont == null || cont . isValid ( ) || cont . getLayout ( ) == null ; }
final boolean areBoundsValid ( ) { Container cont = getContainer ( ) ; return cont == null || cont . isValid ( ) || cont . getLayout ( ) == null ; }
final private String syntaxDef2SyntaxDesc ( Attributes attrs ) throws NamingException { StringBuffer syntaxDesc = new StringBuffer ( STRING ) ; Attribute attr = null ; int count = _NUM ; attr = attrs . get ( NUMERICOID_ID ) ; if ( attr != null ) { syntaxDesc . append ( writeNumericOID ( attr ) ) ; count ++ ; } else { throw new ConfigurationException ( STRING + STRING ) ; } attr = attrs . get ( DESC_ID ) ; if ( attr != null ) { syntaxDesc . append ( writeQDString ( attr ) ) ; count ++ ; } if ( count < attrs . size ( ) ) { String attrId = null ; for ( NamingEnumeration < ? extends Attribute > ae = attrs . getAll ( ) ; ae . hasMoreElements ( ) ; ) { attr = ae . next ( ) ; attrId = attr . getID ( ) ; if ( attrId . equals ( NUMERICOID_ID ) || attrId . equals ( DESC_ID ) ) { continue ; } else { syntaxDesc . append ( writeQDStrings ( attr ) ) ; } } } syntaxDesc . append ( STRING ) ; return syntaxDesc . toString ( ) ; }
final private String syntaxDef2SyntaxDesc ( Attributes attrs ) throws NamingException { StringBuffer syntaxDesc = new StringBuffer ( STRING ) ; Attribute attr = null ; int count = _NUM ; attr = attrs . get ( NUMERICOID_ID ) ; if ( attr != null ) { syntaxDesc . append ( writeNumericOID ( attr ) ) ; count ++ ; } else { throw new ConfigurationException ( STRING + STRING ) ; } attr = attrs . get ( DESC_ID ) ; if ( attr != null ) { syntaxDesc . append ( writeQDString ( attr ) ) ; count ++ ; } if ( count < attrs . size ( ) ) { String attrId = null ; for ( NamingEnumeration < ? extends Attribute > ae = attrs . getAll ( ) ; ae . hasMoreElements ( ) ; ) { attr = ae . next ( ) ; attrId = attr . getID ( ) ; if ( attrId . equals ( NUMERICOID_ID ) || attrId . equals ( DESC_ID ) ) { continue ; } else { syntaxDesc . append ( writeQDStrings ( attr ) ) ; } } } syntaxDesc . append ( STRING ) ; return syntaxDesc . toString ( ) ; }
public MetadataBlockHeader ( boolean isLastBlock , BlockType blockType , int dataLength ) { ByteBuffer rawdata = ByteBuffer . allocate ( HEADER_LENGTH ) ; this . blockType = blockType ; this . isLastBlock = isLastBlock ; this . dataLength = dataLength ; byte type ; if ( isLastBlock ) { type = ( byte ) ( _NUM | blockType . getId ( ) ) ; } else { type = ( byte ) blockType . getId ( ) ; } rawdata . put ( type ) ; rawdata . put ( ( byte ) ( ( dataLength & _NUM ) > > > _NUM ) ) ; rawdata . put ( ( byte ) ( ( dataLength & _NUM ) > > > _NUM ) ) ; rawdata . put ( ( byte ) ( dataLength & _NUM ) ) ; bytes = new byte [ HEADER_LENGTH ] ; for ( int i = _NUM ; i < HEADER_LENGTH ; i ++ ) { bytes [ i ] = rawdata . get ( i ) ; } }
public MetadataBlockHeader ( boolean isLastBlock , BlockType blockType , int dataLength ) { ByteBuffer rawdata = ByteBuffer . allocate ( HEADER_LENGTH ) ; this . blockType = blockType ; this . isLastBlock = isLastBlock ; this . dataLength = dataLength ; byte type ; if ( isLastBlock ) { type = ( byte ) ( _NUM | blockType . getId ( ) ) ; } else { type = ( byte ) blockType . getId ( ) ; } rawdata . put ( type ) ; rawdata . put ( ( byte ) ( ( dataLength & _NUM ) > > > _NUM ) ) ; rawdata . put ( ( byte ) ( ( dataLength & _NUM ) > > > _NUM ) ) ; rawdata . put ( ( byte ) ( dataLength & _NUM ) ) ; bytes = new byte [ HEADER_LENGTH ] ; for ( int i = _NUM ; i < HEADER_LENGTH ; i ++ ) { bytes [ i ] = rawdata . get ( i ) ; } }
@ Bean public EsSettingsHolder esSettingsHolder ( ) { return new DefaultSettingsHolder ( ) ; }
private RefererLookup lookupReferer ( String refererHost , String refererPath , Boolean includePath ) { RefererLookup referer = ( includePath ) ? referers . get ( refererHost + refererPath ) : referers . get ( refererHost ) ; if ( includePath && referer == null ) { final String [ ] pathElements = refererPath . split ( STRING ) ; if ( pathElements . length > _NUM ) { referer = referers . get ( refererHost + STRING + pathElements [ _NUM ] ) ; } } if ( referer == null ) { final int idx = refererHost . indexOf ( STRING ) ; if ( idx == - _NUM ) { return null ; } else { return lookupReferer ( refererHost . substring ( idx + _NUM ) , refererPath , includePath ) ; } } else { return referer ; } }
private RefererLookup lookupReferer ( String refererHost , String refererPath , Boolean includePath ) { RefererLookup referer = ( includePath ) ? referers . get ( refererHost + refererPath ) : referers . get ( refererHost ) ; if ( includePath && referer == null ) { final String [ ] pathElements = refererPath . split ( STRING ) ; if ( pathElements . length > _NUM ) { referer = referers . get ( refererHost + STRING + pathElements [ _NUM ] ) ; } } if ( referer == null ) { final int idx = refererHost . indexOf ( STRING ) ; if ( idx == - _NUM ) { return null ; } else { return lookupReferer ( refererHost . substring ( idx + _NUM ) , refererPath , includePath ) ; } } else { return referer ; } }
private RefererLookup lookupReferer ( String refererHost , String refererPath , Boolean includePath ) { RefererLookup referer = ( includePath ) ? referers . get ( refererHost + refererPath ) : referers . get ( refererHost ) ; if ( includePath && referer == null ) { final String [ ] pathElements = refererPath . split ( STRING ) ; if ( pathElements . length > _NUM ) { referer = referers . get ( refererHost + STRING + pathElements [ _NUM ] ) ; } } if ( referer == null ) { final int idx = refererHost . indexOf ( STRING ) ; if ( idx == - _NUM ) { return null ; } else { return lookupReferer ( refererHost . substring ( idx + _NUM ) , refererPath , includePath ) ; } } else { return referer ; } }
public void addAll ( final Collection elements ) { adjusting = _BOOL ; Set oldSelection = new HashSet ( selection ) ; boolean rv = selection . addAll ( elements ) ; adjusting = _BOOL ; if ( rv ) { fireSelectionChanged ( oldSelection , selection ) ; } oldSelection = null ; }
public final boolean isSecure ( Socket sock ) throws IllegalArgumentException { if ( sock == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( sock . getClass ( ) != Socket . class ) { throw new IllegalArgumentException ( STRING ) ; } if ( sock . isClosed ( ) ) { throw new IllegalArgumentException ( STRING ) ; } return _BOOL ; }
public final boolean isSecure ( Socket sock ) throws IllegalArgumentException { if ( sock == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( sock . getClass ( ) != Socket . class ) { throw new IllegalArgumentException ( STRING ) ; } if ( sock . isClosed ( ) ) { throw new IllegalArgumentException ( STRING ) ; } return _BOOL ; }
public StaxWriter ( final QNameMap qnameMap , final XMLStreamWriter out , final boolean writeEnclosingDocument , final boolean namespaceRepairingMode , final NameCoder nameCoder ) throws XMLStreamException { super ( nameCoder ) ; this . qnameMap = qnameMap ; this . out = out ; this . writeEnclosingDocument = writeEnclosingDocument ; this . namespaceRepairingMode = namespaceRepairingMode ; if ( writeEnclosingDocument ) { out . writeStartDocument ( ) ; } }
public StaxWriter ( final QNameMap qnameMap , final XMLStreamWriter out , final boolean writeEnclosingDocument , final boolean namespaceRepairingMode , final NameCoder nameCoder ) throws XMLStreamException { super ( nameCoder ) ; this . qnameMap = qnameMap ; this . out = out ; this . writeEnclosingDocument = writeEnclosingDocument ; this . namespaceRepairingMode = namespaceRepairingMode ; if ( writeEnclosingDocument ) { out . writeStartDocument ( ) ; } }
@ ZapApiIgnore public boolean isConfirmRemoveDomainAlwaysInScope ( ) { return this . confirmRemoveDomainAlwaysInScope ; }
public void CL ( int sessionNumber , String clientLine ) { this . maxSessionNumber = Math . max ( this . maxSessionNumber , sessionNumber ) ; testElements . add ( new ClientRequest ( sessionNumber , clientLine ) ) ; }
public void send ( JetstreamMessage msg ) throws Exception { if ( msg == null ) { throw new Exception ( STRING ) ; } Request req = new ZKSendMessageRequest ( this , msg ) ; if ( ! m_requestQueue . offer ( req ) ) LOGGER . warn ( STRING ) ; }
public synchronized List < Call > runningCalls ( ) { List < Call > result = new ArrayList < > ( ) ; result . addAll ( runningSyncCalls ) ; for ( AsyncCall asyncCall : runningAsyncCalls ) { result . add ( asyncCall . get ( ) ) ; } return Collections . unmodifiableList ( result ) ; }
public void removeOverflowCommand ( Command cmd ) { overflowCommands . remove ( cmd ) ; }
public void removeOverflowCommand ( Command cmd ) { overflowCommands . remove ( cmd ) ; }
public void removeOverflowCommand ( Command cmd ) { overflowCommands . remove ( cmd ) ; }
public void remove ( T graphic ) { synchronized ( mLock ) { mGraphics . remove ( graphic ) ; if ( mFirstGraphic != null && mFirstGraphic . equals ( graphic ) ) { mFirstGraphic = null ; } } postInvalidate ( ) ; }
public static Long toLong ( Object o ) throws PageException { if ( o instanceof Long ) return ( Long ) o ; return Long . valueOf ( toLongValue ( o ) ) ; }
public static Long toLong ( Object o ) throws PageException { if ( o instanceof Long ) return ( Long ) o ; return Long . valueOf ( toLongValue ( o ) ) ; }
private void createSingleStyleLegend ( Map < String , Style > styleMap , StyledLayer selectedStyledLayer , Style selectedStyle ) { List < Style > styleList = null ; if ( selectedStyledLayer instanceof NamedLayerImpl ) { NamedLayerImpl namedLayer = ( NamedLayerImpl ) selectedStyledLayer ; styleList = namedLayer . styles ( ) ; } else if ( selectedStyledLayer instanceof UserLayerImpl ) { UserLayerImpl userLayer = ( UserLayerImpl ) selectedStyledLayer ; styleList = userLayer . userStyles ( ) ; } String styleName ; if ( selectedStyle . getName ( ) != null ) { styleName = selectedStyle . getName ( ) ; } else { styleName = String . format ( STRING , styleList . indexOf ( selectedStyle ) ) ; } styleMap . put ( styleName , selectedStyle ) ; }
public EventBean [ ] toArray ( ) { if ( firstEvent == null ) { return new EventBean [ _NUM ] ; } if ( additionalEvents == null ) { return new EventBean [ ] { firstEvent } ; } EventBean [ ] events = new EventBean [ _NUM + additionalEvents . size ( ) ] ; events [ _NUM ] = firstEvent ; int count = _NUM ; for ( EventBean theEvent : additionalEvents ) { events [ count ] = theEvent ; count ++ ; } return events ; }
private void retryFailedInterfaces ( ) { final Level level = multicastInterfacesSpecified ? Level . INFO : Level . FINE ; if ( logger . isLoggable ( level ) ) logger . log ( level , STRING + failedInterfaces . size ( ) + STRING ) ; for ( Iterator < NetworkInterface > i = failedInterfaces . iterator ( ) ; i . hasNext ( ) ; ) { NetworkInterface nic = i . next ( ) ; long startTime = LogHelper . getCurrTimeIfNeeded ( logger , level ) ; try { if ( nic != null ) socket . setNetworkInterface ( nic ) ; socket . joinGroup ( requestAddr ) ; i . remove ( ) ; if ( logger . isLoggable ( level ) ) { String message = nic == null ? STRING : STRING + nic ; LogHelper . logDuration ( logger , level , startTime , message ) ; } } catch ( IOException e ) { if ( logger . isLoggable ( level ) ) { String message = nic == null ? STRING : STRING + nic ; LogHelper . logDuration ( logger , level , startTime , message ) ; } } } }
private void retryFailedInterfaces ( ) { final Level level = multicastInterfacesSpecified ? Level . INFO : Level . FINE ; if ( logger . isLoggable ( level ) ) logger . log ( level , STRING + failedInterfaces . size ( ) + STRING ) ; for ( Iterator < NetworkInterface > i = failedInterfaces . iterator ( ) ; i . hasNext ( ) ; ) { NetworkInterface nic = i . next ( ) ; long startTime = LogHelper . getCurrTimeIfNeeded ( logger , level ) ; try { if ( nic != null ) socket . setNetworkInterface ( nic ) ; socket . joinGroup ( requestAddr ) ; i . remove ( ) ; if ( logger . isLoggable ( level ) ) { String message = nic == null ? STRING : STRING + nic ; LogHelper . logDuration ( logger , level , startTime , message ) ; } } catch ( IOException e ) { if ( logger . isLoggable ( level ) ) { String message = nic == null ? STRING : STRING + nic ; LogHelper . logDuration ( logger , level , startTime , message ) ; } } } }
private static void adjustAbs ( double [ ] array , int lower , int upper ) { int j , k ; double temp ; j = lower ; k = lower * _NUM ; while ( k <= upper ) { if ( ( k < upper ) && ( Math . abs ( array [ k - _NUM ] ) < Math . abs ( array [ k ] ) ) ) { k += _NUM ; } if ( Math . abs ( array [ j - _NUM ] ) < Math . abs ( array [ k - _NUM ] ) ) { temp = array [ j - _NUM ] ; array [ j - _NUM ] = array [ k - _NUM ] ; array [ k - _NUM ] = temp ; } j = k ; k *= _NUM ; } }
private static void adjustAbs ( double [ ] array , int lower , int upper ) { int j , k ; double temp ; j = lower ; k = lower * _NUM ; while ( k <= upper ) { if ( ( k < upper ) && ( Math . abs ( array [ k - _NUM ] ) < Math . abs ( array [ k ] ) ) ) { k += _NUM ; } if ( Math . abs ( array [ j - _NUM ] ) < Math . abs ( array [ k - _NUM ] ) ) { temp = array [ j - _NUM ] ; array [ j - _NUM ] = array [ k - _NUM ] ; array [ k - _NUM ] = temp ; } j = k ; k *= _NUM ; } }
private static void adjustAbs ( double [ ] array , int lower , int upper ) { int j , k ; double temp ; j = lower ; k = lower * _NUM ; while ( k <= upper ) { if ( ( k < upper ) && ( Math . abs ( array [ k - _NUM ] ) < Math . abs ( array [ k ] ) ) ) { k += _NUM ; } if ( Math . abs ( array [ j - _NUM ] ) < Math . abs ( array [ k - _NUM ] ) ) { temp = array [ j - _NUM ] ; array [ j - _NUM ] = array [ k - _NUM ] ; array [ k - _NUM ] = temp ; } j = k ; k *= _NUM ; } }
private static void adjustAbs ( double [ ] array , int lower , int upper ) { int j , k ; double temp ; j = lower ; k = lower * _NUM ; while ( k <= upper ) { if ( ( k < upper ) && ( Math . abs ( array [ k - _NUM ] ) < Math . abs ( array [ k ] ) ) ) { k += _NUM ; } if ( Math . abs ( array [ j - _NUM ] ) < Math . abs ( array [ k - _NUM ] ) ) { temp = array [ j - _NUM ] ; array [ j - _NUM ] = array [ k - _NUM ] ; array [ k - _NUM ] = temp ; } j = k ; k *= _NUM ; } }
private static void adjustAbs ( double [ ] array , int lower , int upper ) { int j , k ; double temp ; j = lower ; k = lower * _NUM ; while ( k <= upper ) { if ( ( k < upper ) && ( Math . abs ( array [ k - _NUM ] ) < Math . abs ( array [ k ] ) ) ) { k += _NUM ; } if ( Math . abs ( array [ j - _NUM ] ) < Math . abs ( array [ k - _NUM ] ) ) { temp = array [ j - _NUM ] ; array [ j - _NUM ] = array [ k - _NUM ] ; array [ k - _NUM ] = temp ; } j = k ; k *= _NUM ; } }
private static void adjustAbs ( double [ ] array , int lower , int upper ) { int j , k ; double temp ; j = lower ; k = lower * _NUM ; while ( k <= upper ) { if ( ( k < upper ) && ( Math . abs ( array [ k - _NUM ] ) < Math . abs ( array [ k ] ) ) ) { k += _NUM ; } if ( Math . abs ( array [ j - _NUM ] ) < Math . abs ( array [ k - _NUM ] ) ) { temp = array [ j - _NUM ] ; array [ j - _NUM ] = array [ k - _NUM ] ; array [ k - _NUM ] = temp ; } j = k ; k *= _NUM ; } }
public void addMapsIdMapping ( DatabaseMapping mapping ) { mapsIdMappings . add ( mapping ) ; }
public void addMapsIdMapping ( DatabaseMapping mapping ) { mapsIdMappings . add ( mapping ) ; }
public void addMapsIdMapping ( DatabaseMapping mapping ) { mapsIdMappings . add ( mapping ) ; }
public void addMapsIdMapping ( DatabaseMapping mapping ) { mapsIdMappings . add ( mapping ) ; }
public void addMapsIdMapping ( DatabaseMapping mapping ) { mapsIdMappings . add ( mapping ) ; }
public void addMapsIdMapping ( DatabaseMapping mapping ) { mapsIdMappings . add ( mapping ) ; }
public void addMapsIdMapping ( DatabaseMapping mapping ) { mapsIdMappings . add ( mapping ) ; }
public void addMapsIdMapping ( DatabaseMapping mapping ) { mapsIdMappings . add ( mapping ) ; }
public ProxySettings addHeader ( String name , String value ) { if ( name == null || name . length ( ) == _NUM ) { return this ; } List < String > list = mHeaders . get ( name ) ; if ( list == null ) { list = new ArrayList < String > ( ) ; mHeaders . put ( name , list ) ; } list . add ( value ) ; return this ; }
public static boolean isNumeric ( TypeMirror type ) { switch ( type . getKind ( ) ) { case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : return _BOOL ; default : return _BOOL ; } }
protected void serialize ( String filename ) { classifier . serializeClassifier ( filename ) ; }
@ Override public void forceRefetch ( String url , WebPage page , boolean asap ) { if ( page . getFetchInterval ( ) > maxInterval ) page . setFetchInterval ( Math . round ( maxInterval * _NUM ) ) ; page . setStatus ( ( int ) CrawlStatus . STATUS_UNFETCHED ) ; page . setRetriesSinceFetch ( _NUM ) ; page . setModifiedTime ( _NUM ) ; if ( asap ) page . setFetchTime ( System . currentTimeMillis ( ) ) ; }
@ Override public void forceRefetch ( String url , WebPage page , boolean asap ) { if ( page . getFetchInterval ( ) > maxInterval ) page . setFetchInterval ( Math . round ( maxInterval * _NUM ) ) ; page . setStatus ( ( int ) CrawlStatus . STATUS_UNFETCHED ) ; page . setRetriesSinceFetch ( _NUM ) ; page . setModifiedTime ( _NUM ) ; if ( asap ) page . setFetchTime ( System . currentTimeMillis ( ) ) ; }
@ Override public void forceRefetch ( String url , WebPage page , boolean asap ) { if ( page . getFetchInterval ( ) > maxInterval ) page . setFetchInterval ( Math . round ( maxInterval * _NUM ) ) ; page . setStatus ( ( int ) CrawlStatus . STATUS_UNFETCHED ) ; page . setRetriesSinceFetch ( _NUM ) ; page . setModifiedTime ( _NUM ) ; if ( asap ) page . setFetchTime ( System . currentTimeMillis ( ) ) ; }
protected void createTestDataFiles ( Path localPath , List < ManifestFile > manifestFiles ) throws Exception { for ( ManifestFile manifestFile : manifestFiles ) { createLocalFile ( localPath . toString ( ) , manifestFile . getFileName ( ) , manifestFile . getFileSizeBytes ( ) ) ; } }
protected void createTestDataFiles ( Path localPath , List < ManifestFile > manifestFiles ) throws Exception { for ( ManifestFile manifestFile : manifestFiles ) { createLocalFile ( localPath . toString ( ) , manifestFile . getFileName ( ) , manifestFile . getFileSizeBytes ( ) ) ; } }
private static void addVerticalSmallSpring ( Path2D . Float path , int x0 , int y1 , int y2 ) { int springHeight = _NUM ; int springWidth = _NUM ; int distance = Math . abs ( y2 - y1 ) ; int numSprings = ( distance / ( springHeight ) ) ; int leftOver = ( distance - ( numSprings * springHeight ) ) / _NUM ; path . lineTo ( x0 , y1 ) ; path . lineTo ( x0 , y1 - leftOver ) ; int count = _NUM ; if ( y1 > y2 ) { for ( int y = y1 - leftOver ; y > y2 + leftOver ; y -= springHeight ) { int x = ( count % _NUM == _NUM ) ? x0 - springWidth : x0 + springWidth ; path . lineTo ( x , y ) ; count ++ ; } } else { for ( int y = y1 + leftOver ; y < y2 - leftOver ; y += springHeight ) { int x = ( count % _NUM == _NUM ) ? x0 - springWidth : x0 + springWidth ; path . lineTo ( x , y ) ; count ++ ; } } path . lineTo ( x0 , y2 + leftOver ) ; path . lineTo ( x0 , y2 ) ; }
void dispatchEvents ( ) { EventInfo eventInfo = null ; synchronized ( this ) { try { if ( eventQueue . size ( ) == _NUM ) { if ( autoClosingClips . size ( ) > _NUM || lineMonitors . size ( ) > _NUM ) { int waitTime = AUTO_CLOSE_TIME ; if ( lineMonitors . size ( ) > _NUM ) { waitTime = LINE_MONITOR_TIME ; } wait ( waitTime ) ; } else { wait ( ) ; } } } catch ( InterruptedException e ) { } if ( eventQueue . size ( ) > _NUM ) { eventInfo = ( EventInfo ) eventQueue . remove ( _NUM ) ; } } if ( eventInfo != null ) { processEvent ( eventInfo ) ; } else { if ( autoClosingClips . size ( ) > _NUM ) { closeAutoClosingClips ( ) ; } if ( lineMonitors . size ( ) > _NUM ) { monitorLines ( ) ; } } }
void dispatchEvents ( ) { EventInfo eventInfo = null ; synchronized ( this ) { try { if ( eventQueue . size ( ) == _NUM ) { if ( autoClosingClips . size ( ) > _NUM || lineMonitors . size ( ) > _NUM ) { int waitTime = AUTO_CLOSE_TIME ; if ( lineMonitors . size ( ) > _NUM ) { waitTime = LINE_MONITOR_TIME ; } wait ( waitTime ) ; } else { wait ( ) ; } } } catch ( InterruptedException e ) { } if ( eventQueue . size ( ) > _NUM ) { eventInfo = ( EventInfo ) eventQueue . remove ( _NUM ) ; } } if ( eventInfo != null ) { processEvent ( eventInfo ) ; } else { if ( autoClosingClips . size ( ) > _NUM ) { closeAutoClosingClips ( ) ; } if ( lineMonitors . size ( ) > _NUM ) { monitorLines ( ) ; } } }
void dispatchEvents ( ) { EventInfo eventInfo = null ; synchronized ( this ) { try { if ( eventQueue . size ( ) == _NUM ) { if ( autoClosingClips . size ( ) > _NUM || lineMonitors . size ( ) > _NUM ) { int waitTime = AUTO_CLOSE_TIME ; if ( lineMonitors . size ( ) > _NUM ) { waitTime = LINE_MONITOR_TIME ; } wait ( waitTime ) ; } else { wait ( ) ; } } } catch ( InterruptedException e ) { } if ( eventQueue . size ( ) > _NUM ) { eventInfo = ( EventInfo ) eventQueue . remove ( _NUM ) ; } } if ( eventInfo != null ) { processEvent ( eventInfo ) ; } else { if ( autoClosingClips . size ( ) > _NUM ) { closeAutoClosingClips ( ) ; } if ( lineMonitors . size ( ) > _NUM ) { monitorLines ( ) ; } } }
void dispatchEvents ( ) { EventInfo eventInfo = null ; synchronized ( this ) { try { if ( eventQueue . size ( ) == _NUM ) { if ( autoClosingClips . size ( ) > _NUM || lineMonitors . size ( ) > _NUM ) { int waitTime = AUTO_CLOSE_TIME ; if ( lineMonitors . size ( ) > _NUM ) { waitTime = LINE_MONITOR_TIME ; } wait ( waitTime ) ; } else { wait ( ) ; } } } catch ( InterruptedException e ) { } if ( eventQueue . size ( ) > _NUM ) { eventInfo = ( EventInfo ) eventQueue . remove ( _NUM ) ; } } if ( eventInfo != null ) { processEvent ( eventInfo ) ; } else { if ( autoClosingClips . size ( ) > _NUM ) { closeAutoClosingClips ( ) ; } if ( lineMonitors . size ( ) > _NUM ) { monitorLines ( ) ; } } }
void dispatchEvents ( ) { EventInfo eventInfo = null ; synchronized ( this ) { try { if ( eventQueue . size ( ) == _NUM ) { if ( autoClosingClips . size ( ) > _NUM || lineMonitors . size ( ) > _NUM ) { int waitTime = AUTO_CLOSE_TIME ; if ( lineMonitors . size ( ) > _NUM ) { waitTime = LINE_MONITOR_TIME ; } wait ( waitTime ) ; } else { wait ( ) ; } } } catch ( InterruptedException e ) { } if ( eventQueue . size ( ) > _NUM ) { eventInfo = ( EventInfo ) eventQueue . remove ( _NUM ) ; } } if ( eventInfo != null ) { processEvent ( eventInfo ) ; } else { if ( autoClosingClips . size ( ) > _NUM ) { closeAutoClosingClips ( ) ; } if ( lineMonitors . size ( ) > _NUM ) { monitorLines ( ) ; } } }
void dispatchEvents ( ) { EventInfo eventInfo = null ; synchronized ( this ) { try { if ( eventQueue . size ( ) == _NUM ) { if ( autoClosingClips . size ( ) > _NUM || lineMonitors . size ( ) > _NUM ) { int waitTime = AUTO_CLOSE_TIME ; if ( lineMonitors . size ( ) > _NUM ) { waitTime = LINE_MONITOR_TIME ; } wait ( waitTime ) ; } else { wait ( ) ; } } } catch ( InterruptedException e ) { } if ( eventQueue . size ( ) > _NUM ) { eventInfo = ( EventInfo ) eventQueue . remove ( _NUM ) ; } } if ( eventInfo != null ) { processEvent ( eventInfo ) ; } else { if ( autoClosingClips . size ( ) > _NUM ) { closeAutoClosingClips ( ) ; } if ( lineMonitors . size ( ) > _NUM ) { monitorLines ( ) ; } } }
void dispatchEvents ( ) { EventInfo eventInfo = null ; synchronized ( this ) { try { if ( eventQueue . size ( ) == _NUM ) { if ( autoClosingClips . size ( ) > _NUM || lineMonitors . size ( ) > _NUM ) { int waitTime = AUTO_CLOSE_TIME ; if ( lineMonitors . size ( ) > _NUM ) { waitTime = LINE_MONITOR_TIME ; } wait ( waitTime ) ; } else { wait ( ) ; } } } catch ( InterruptedException e ) { } if ( eventQueue . size ( ) > _NUM ) { eventInfo = ( EventInfo ) eventQueue . remove ( _NUM ) ; } } if ( eventInfo != null ) { processEvent ( eventInfo ) ; } else { if ( autoClosingClips . size ( ) > _NUM ) { closeAutoClosingClips ( ) ; } if ( lineMonitors . size ( ) > _NUM ) { monitorLines ( ) ; } } }
void dispatchEvents ( ) { EventInfo eventInfo = null ; synchronized ( this ) { try { if ( eventQueue . size ( ) == _NUM ) { if ( autoClosingClips . size ( ) > _NUM || lineMonitors . size ( ) > _NUM ) { int waitTime = AUTO_CLOSE_TIME ; if ( lineMonitors . size ( ) > _NUM ) { waitTime = LINE_MONITOR_TIME ; } wait ( waitTime ) ; } else { wait ( ) ; } } } catch ( InterruptedException e ) { } if ( eventQueue . size ( ) > _NUM ) { eventInfo = ( EventInfo ) eventQueue . remove ( _NUM ) ; } } if ( eventInfo != null ) { processEvent ( eventInfo ) ; } else { if ( autoClosingClips . size ( ) > _NUM ) { closeAutoClosingClips ( ) ; } if ( lineMonitors . size ( ) > _NUM ) { monitorLines ( ) ; } } }
void dispatchEvents ( ) { EventInfo eventInfo = null ; synchronized ( this ) { try { if ( eventQueue . size ( ) == _NUM ) { if ( autoClosingClips . size ( ) > _NUM || lineMonitors . size ( ) > _NUM ) { int waitTime = AUTO_CLOSE_TIME ; if ( lineMonitors . size ( ) > _NUM ) { waitTime = LINE_MONITOR_TIME ; } wait ( waitTime ) ; } else { wait ( ) ; } } } catch ( InterruptedException e ) { } if ( eventQueue . size ( ) > _NUM ) { eventInfo = ( EventInfo ) eventQueue . remove ( _NUM ) ; } } if ( eventInfo != null ) { processEvent ( eventInfo ) ; } else { if ( autoClosingClips . size ( ) > _NUM ) { closeAutoClosingClips ( ) ; } if ( lineMonitors . size ( ) > _NUM ) { monitorLines ( ) ; } } }
void dispatchEvents ( ) { EventInfo eventInfo = null ; synchronized ( this ) { try { if ( eventQueue . size ( ) == _NUM ) { if ( autoClosingClips . size ( ) > _NUM || lineMonitors . size ( ) > _NUM ) { int waitTime = AUTO_CLOSE_TIME ; if ( lineMonitors . size ( ) > _NUM ) { waitTime = LINE_MONITOR_TIME ; } wait ( waitTime ) ; } else { wait ( ) ; } } } catch ( InterruptedException e ) { } if ( eventQueue . size ( ) > _NUM ) { eventInfo = ( EventInfo ) eventQueue . remove ( _NUM ) ; } } if ( eventInfo != null ) { processEvent ( eventInfo ) ; } else { if ( autoClosingClips . size ( ) > _NUM ) { closeAutoClosingClips ( ) ; } if ( lineMonitors . size ( ) > _NUM ) { monitorLines ( ) ; } } }
public void writeByteStream ( ByteArrayOutputStream s ) throws IOException { s . writeTo ( messageOutput ) ; }
protected int numAutoMoves ( ) { return autoMoves . size ( ) ; }
private long offset2PhysicalAddress ( final long offset ) { return offset + headerSize ; }
private long offset2PhysicalAddress ( final long offset ) { return offset + headerSize ; }
private long offset2PhysicalAddress ( final long offset ) { return offset + headerSize ; }
private long offset2PhysicalAddress ( final long offset ) { return offset + headerSize ; }
protected void computePDists ( Relation < O > relation , KNNQuery < O > knn , WritableDoubleDataStore pdists ) { FiniteProgress prdsProgress = LOG . isVerbose ( ) ? new FiniteProgress ( STRING , relation . size ( ) , LOG ) : null ; for ( DBIDIter iditer = relation . iterDBIDs ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { final KNNList neighbors = knn . getKNNForDBID ( iditer , kreach + _NUM ) ; int ks = _NUM ; double ssum = _NUM ; for ( DoubleDBIDListIter neighbor = neighbors . iter ( ) ; neighbor . valid ( ) && ks < kreach ; neighbor . advance ( ) ) { if ( DBIDUtil . equal ( neighbor , iditer ) ) { continue ; } final double d = neighbor . doubleValue ( ) ; ssum += d * d ; ks ++ ; } double pdist = ks > _NUM ? Math . sqrt ( ssum / ks ) : _NUM ; pdists . putDouble ( iditer , pdist ) ; LOG . incrementProcessed ( prdsProgress ) ; } LOG . ensureCompleted ( prdsProgress ) ; }
public void nullifyItem ( String sItem ) { NGramHistogram . put ( sItem , _NUM ) ; }
public static char [ ] ensureCapacity ( final char [ ] array , final int length , final int preserve ) { if ( length > array . length ) { final char t [ ] = new char [ length ] ; System . arraycopy ( array , _NUM , t , _NUM , preserve ) ; return t ; } return array ; }
public static char [ ] ensureCapacity ( final char [ ] array , final int length , final int preserve ) { if ( length > array . length ) { final char t [ ] = new char [ length ] ; System . arraycopy ( array , _NUM , t , _NUM , preserve ) ; return t ; } return array ; }
public static char [ ] ensureCapacity ( final char [ ] array , final int length , final int preserve ) { if ( length > array . length ) { final char t [ ] = new char [ length ] ; System . arraycopy ( array , _NUM , t , _NUM , preserve ) ; return t ; } return array ; }
public void testSingleSentences ( ) throws Exception { BreakIterator expected = BreakIterator . getSentenceInstance ( Locale . ROOT ) ; BreakIterator actual = new WholeBreakIterator ( ) ; assertSameBreaks ( STRING , expected , actual ) ; assertSameBreaks ( STRING , expected , actual ) ; assertSameBreaks ( STRING , expected , actual ) ; assertSameBreaks ( STRING , expected , actual ) ; }
public void testSingleSentences ( ) throws Exception { BreakIterator expected = BreakIterator . getSentenceInstance ( Locale . ROOT ) ; BreakIterator actual = new WholeBreakIterator ( ) ; assertSameBreaks ( STRING , expected , actual ) ; assertSameBreaks ( STRING , expected , actual ) ; assertSameBreaks ( STRING , expected , actual ) ; assertSameBreaks ( STRING , expected , actual ) ; }
public void testSingleSentences ( ) throws Exception { BreakIterator expected = BreakIterator . getSentenceInstance ( Locale . ROOT ) ; BreakIterator actual = new WholeBreakIterator ( ) ; assertSameBreaks ( STRING , expected , actual ) ; assertSameBreaks ( STRING , expected , actual ) ; assertSameBreaks ( STRING , expected , actual ) ; assertSameBreaks ( STRING , expected , actual ) ; }
public void addVirtualMethod ( EncodedMethod method ) { if ( method == null ) { throw new NullPointerException ( STRING ) ; } virtualMethods . add ( method ) ; }
public int minMeetingRooms ( Interval [ ] intervals ) { if ( intervals == null || intervals . length == _NUM ) { return _NUM ; } Arrays . sort ( intervals , null ) ; PriorityQueue < Interval > minHeap = new PriorityQueue < > ( intervals . length , null ) ; for ( Interval i : intervals ) { if ( ! minHeap . isEmpty ( ) && i . start >= minHeap . peek ( ) . end ) { minHeap . poll ( ) ; } minHeap . add ( i ) ; } return minHeap . size ( ) ; }
public int minMeetingRooms ( Interval [ ] intervals ) { if ( intervals == null || intervals . length == _NUM ) { return _NUM ; } Arrays . sort ( intervals , null ) ; PriorityQueue < Interval > minHeap = new PriorityQueue < > ( intervals . length , null ) ; for ( Interval i : intervals ) { if ( ! minHeap . isEmpty ( ) && i . start >= minHeap . peek ( ) . end ) { minHeap . poll ( ) ; } minHeap . add ( i ) ; } return minHeap . size ( ) ; }
public int minMeetingRooms ( Interval [ ] intervals ) { if ( intervals == null || intervals . length == _NUM ) { return _NUM ; } Arrays . sort ( intervals , null ) ; PriorityQueue < Interval > minHeap = new PriorityQueue < > ( intervals . length , null ) ; for ( Interval i : intervals ) { if ( ! minHeap . isEmpty ( ) && i . start >= minHeap . peek ( ) . end ) { minHeap . poll ( ) ; } minHeap . add ( i ) ; } return minHeap . size ( ) ; }
public int minMeetingRooms ( Interval [ ] intervals ) { if ( intervals == null || intervals . length == _NUM ) { return _NUM ; } Arrays . sort ( intervals , null ) ; PriorityQueue < Interval > minHeap = new PriorityQueue < > ( intervals . length , null ) ; for ( Interval i : intervals ) { if ( ! minHeap . isEmpty ( ) && i . start >= minHeap . peek ( ) . end ) { minHeap . poll ( ) ; } minHeap . add ( i ) ; } return minHeap . size ( ) ; }
public int minMeetingRooms ( Interval [ ] intervals ) { if ( intervals == null || intervals . length == _NUM ) { return _NUM ; } Arrays . sort ( intervals , null ) ; PriorityQueue < Interval > minHeap = new PriorityQueue < > ( intervals . length , null ) ; for ( Interval i : intervals ) { if ( ! minHeap . isEmpty ( ) && i . start >= minHeap . peek ( ) . end ) { minHeap . poll ( ) ; } minHeap . add ( i ) ; } return minHeap . size ( ) ; }
@ Override public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { int type = newChild . getNodeType ( ) ; if ( errorChecking ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( ( type == Node . ELEMENT_NODE && docElement != null ) || ( type == Node . DOCUMENT_TYPE_NODE && docType != null ) ) { String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . DOM_DOMAIN , STRING , null ) ; throw new DOMException ( DOMException . HIERARCHY_REQUEST_ERR , msg ) ; } } if ( newChild . getOwnerDocument ( ) == null && newChild instanceof DocumentTypeImpl ) { ( ( DocumentTypeImpl ) newChild ) . ownerDocument = this ; } super . insertBefore ( newChild , refChild ) ; if ( type == Node . ELEMENT_NODE ) { docElement = ( ElementImpl ) newChild ; } else if ( type == Node . DOCUMENT_TYPE_NODE ) { docType = ( DocumentTypeImpl ) newChild ; } return newChild ; }
@ Override public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { int type = newChild . getNodeType ( ) ; if ( errorChecking ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( ( type == Node . ELEMENT_NODE && docElement != null ) || ( type == Node . DOCUMENT_TYPE_NODE && docType != null ) ) { String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . DOM_DOMAIN , STRING , null ) ; throw new DOMException ( DOMException . HIERARCHY_REQUEST_ERR , msg ) ; } } if ( newChild . getOwnerDocument ( ) == null && newChild instanceof DocumentTypeImpl ) { ( ( DocumentTypeImpl ) newChild ) . ownerDocument = this ; } super . insertBefore ( newChild , refChild ) ; if ( type == Node . ELEMENT_NODE ) { docElement = ( ElementImpl ) newChild ; } else if ( type == Node . DOCUMENT_TYPE_NODE ) { docType = ( DocumentTypeImpl ) newChild ; } return newChild ; }
@ Override public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { int type = newChild . getNodeType ( ) ; if ( errorChecking ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( ( type == Node . ELEMENT_NODE && docElement != null ) || ( type == Node . DOCUMENT_TYPE_NODE && docType != null ) ) { String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . DOM_DOMAIN , STRING , null ) ; throw new DOMException ( DOMException . HIERARCHY_REQUEST_ERR , msg ) ; } } if ( newChild . getOwnerDocument ( ) == null && newChild instanceof DocumentTypeImpl ) { ( ( DocumentTypeImpl ) newChild ) . ownerDocument = this ; } super . insertBefore ( newChild , refChild ) ; if ( type == Node . ELEMENT_NODE ) { docElement = ( ElementImpl ) newChild ; } else if ( type == Node . DOCUMENT_TYPE_NODE ) { docType = ( DocumentTypeImpl ) newChild ; } return newChild ; }
@ Override public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { int type = newChild . getNodeType ( ) ; if ( errorChecking ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( ( type == Node . ELEMENT_NODE && docElement != null ) || ( type == Node . DOCUMENT_TYPE_NODE && docType != null ) ) { String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . DOM_DOMAIN , STRING , null ) ; throw new DOMException ( DOMException . HIERARCHY_REQUEST_ERR , msg ) ; } } if ( newChild . getOwnerDocument ( ) == null && newChild instanceof DocumentTypeImpl ) { ( ( DocumentTypeImpl ) newChild ) . ownerDocument = this ; } super . insertBefore ( newChild , refChild ) ; if ( type == Node . ELEMENT_NODE ) { docElement = ( ElementImpl ) newChild ; } else if ( type == Node . DOCUMENT_TYPE_NODE ) { docType = ( DocumentTypeImpl ) newChild ; } return newChild ; }
public boolean textIsPresent ( String courseWareErrorText , String text ) { if ( courseWareErrorText . equals ( text ) ) { return _BOOL ; } else { return _BOOL ; } }
void nodeInsert ( char opcode , int opdata , int insertAt ) { ensure ( RE . nodeSize ) ; System . arraycopy ( instruction , insertAt , instruction , insertAt + RE . nodeSize , lenInstruction - insertAt ) ; instruction [ insertAt ] = opcode ; instruction [ insertAt + RE . offsetOpdata ] = ( char ) opdata ; instruction [ insertAt + RE . offsetNext ] = _NUM ; lenInstruction += RE . nodeSize ; }
void nodeInsert ( char opcode , int opdata , int insertAt ) { ensure ( RE . nodeSize ) ; System . arraycopy ( instruction , insertAt , instruction , insertAt + RE . nodeSize , lenInstruction - insertAt ) ; instruction [ insertAt ] = opcode ; instruction [ insertAt + RE . offsetOpdata ] = ( char ) opdata ; instruction [ insertAt + RE . offsetNext ] = _NUM ; lenInstruction += RE . nodeSize ; }
private void historyAddChanged ( ) { if ( historyTextEdited ) { historyAdd ( getText ( ) ) ; historyTextEdited = _BOOL ; historyPosition = history . size ( ) ; } }
public V remove ( K key ) { if ( key == null ) { throw new NullPointerException ( STRING ) ; } final Iterator < P > it = key . iterator ( ) ; final Stack < Node < P , V > > stack = new Stack < Node < P , V > > ( ) ; Node < P , V > parent = null ; Node < P , V > node = this . root ; while ( it . hasNext ( ) ) { final P keyPart = it . next ( ) ; final Node < P , V > child = node . getChildWithNull ( keyPart ) ; if ( child == null ) { return null ; } else { stack . push ( node ) ; parent = node ; node = child ; } } if ( ! stack . isEmpty ( ) ) { stack . pop ( ) ; } final V result = node . value ; V propagatedValue ; if ( node . isLeaf ) { node . isLeaf = _BOOL ; propagatedValue = updateNode ( parent , node , _BOOL , null ) ; } else { return null ; } Node < P , V > child = null ; while ( ! stack . isEmpty ( ) ) { child = node ; node = parent ; parent = stack . pop ( ) ; node . leafCount -= _NUM ; final boolean updateAfterRemove = ( node . getChildWithNull ( child . keyPart ) == null ) ; propagatedValue = updateNode ( parent , node , updateAfterRemove , propagatedValue ) ; } this . size -= _NUM ; return result ; }
public DIssuerAlternativeName ( JDialog parent , byte [ ] value ) throws IOException { super ( parent ) ; setTitle ( res . getString ( STRING ) ) ; initComponents ( ) ; prepopulateWithValue ( value ) ; }
public T removeItemByPosition ( int position ) { if ( position < mObjects . size ( ) && position != INVALID_POSITION ) { mObjectDeleted = mObjects . remove ( position ) ; mHasDeletedPosition = position ; notifyDataSetChanged ( ) ; return mObjectDeleted ; } else { throw new IndexOutOfBoundsException ( STRING ) ; } }
public static void sort ( long [ ] array , int start , int end ) { DualPivotQuicksort . sort ( array , start , end ) ; }
public void write ( ByteBuffer buffer ) { buffer . put ( _mask ) ; }
public static String bytesToHexString ( byte [ ] bytes ) { StringBuffer buf = new StringBuffer ( bytes . length * _NUM ) ; for ( byte b : bytes ) { String s = Integer . toString ( _NUM & b , _NUM ) ; if ( s . length ( ) < _NUM ) buf . append ( STRING ) ; buf . append ( s ) ; } return buf . toString ( ) ; }
public static Map parseCommandLineArguments ( String [ ] args ) { Map < String , String > result = new HashMap < > ( ) ; String key , value ; for ( int i = _NUM ; i < args . length ; i ++ ) { key = args [ i ] ; if ( key . charAt ( _NUM ) == STRING ) { if ( i + _NUM < args . length ) { value = args [ i + _NUM ] ; if ( value . charAt ( _NUM ) != STRING ) { result . put ( key , value ) ; i ++ ; } else { result . put ( key , null ) ; } } else { result . put ( key , null ) ; } } } return result ; }
public Set < String > addContent ( IndependentDistribution distrib ) { if ( ! paused ) { curState . addToState ( distrib ) ; return update ( ) ; } else { log . info ( STRING + distrib ) ; return Collections . emptySet ( ) ; } }
public Set < String > addContent ( IndependentDistribution distrib ) { if ( ! paused ) { curState . addToState ( distrib ) ; return update ( ) ; } else { log . info ( STRING + distrib ) ; return Collections . emptySet ( ) ; } }
public Set < String > addContent ( IndependentDistribution distrib ) { if ( ! paused ) { curState . addToState ( distrib ) ; return update ( ) ; } else { log . info ( STRING + distrib ) ; return Collections . emptySet ( ) ; } }
public void update ( Graphics g ) { if ( isShowing ( ) ) { if ( ! ( peer instanceof LightweightPeer ) ) { g . clearRect ( _NUM , _NUM , width , height ) ; } paint ( g ) ; } }
public void update ( Graphics g ) { if ( isShowing ( ) ) { if ( ! ( peer instanceof LightweightPeer ) ) { g . clearRect ( _NUM , _NUM , width , height ) ; } paint ( g ) ; } }
public void update ( Graphics g ) { if ( isShowing ( ) ) { if ( ! ( peer instanceof LightweightPeer ) ) { g . clearRect ( _NUM , _NUM , width , height ) ; } paint ( g ) ; } }
public void update ( Graphics g ) { if ( isShowing ( ) ) { if ( ! ( peer instanceof LightweightPeer ) ) { g . clearRect ( _NUM , _NUM , width , height ) ; } paint ( g ) ; } }
public void stop ( ) { if ( ! isRunning ( ) ) { return ; } delayedHandler . removeCallbacksAndMessages ( null ) ; if ( handlerThread != null ) { handlerThread . quit ( ) ; } isRunning = _BOOL ; currentTime = _NUM ; storedTime += System . currentTimeMillis ( ) - startTime ; }
public void stop ( ) { if ( ! isRunning ( ) ) { return ; } delayedHandler . removeCallbacksAndMessages ( null ) ; if ( handlerThread != null ) { handlerThread . quit ( ) ; } isRunning = _BOOL ; currentTime = _NUM ; storedTime += System . currentTimeMillis ( ) - startTime ; }
protected void writeAttribute ( String nsAlias , String name , String value ) throws IOException { writer . write ( STRING ) ; writeQualifiedName ( nsAlias , name ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; if ( value != null ) { writer . write ( StringUtil . xmlEscape ( value ) ) ; } writer . write ( STRING ) ; }
public static void addGlue ( JComponent b , boolean horiz ) { b . add ( horiz ? Box . createHorizontalGlue ( ) : Box . createVerticalGlue ( ) ) ; }
static List < String > union ( List < String > xList , List < String > yList , boolean isSuffix ) { List < String > unionList = new ArrayList < String > ( xList ) ; unionList . addAll ( yList ) ; TranslatorUtils . removeDuplicateAffix ( unionList , isSuffix ) ; return unionList ; }
static List < String > union ( List < String > xList , List < String > yList , boolean isSuffix ) { List < String > unionList = new ArrayList < String > ( xList ) ; unionList . addAll ( yList ) ; TranslatorUtils . removeDuplicateAffix ( unionList , isSuffix ) ; return unionList ; }
private static X509Certificate resolveCertificate ( Element e , String baseURI , StorageResolver storage ) throws KeyResolverException { if ( log . isLoggable ( java . util . logging . Level . FINE ) ) { log . log ( java . util . logging . Level . FINE , STRING + e . getNamespaceURI ( ) + STRING + e . getLocalName ( ) + STRING ) ; } if ( e != null ) { return KeyResolver . getX509Certificate ( e , baseURI , storage ) ; } return null ; }
public String addStepsForRestoreFromFullcopy ( Workflow workflow , String waitFor , URI storage , List < URI > fullcopies , String opId , CloneRestoreCompleter completer ) throws InternalException { Volume firstFullCopy = getDataObject ( Volume . class , fullcopies . get ( _NUM ) , _dbClient ) ; if ( ! firstFullCopy . isVPlexVolume ( _dbClient ) ) { return waitFor ; } BlockObject firstSource = BlockObject . fetch ( _dbClient , firstFullCopy . getAssociatedSourceVolume ( ) ) ; if ( ! NullColumnValueGetter . isNullURI ( firstSource . getConsistencyGroup ( ) ) ) { completer . addConsistencyGroupId ( firstSource . getConsistencyGroup ( ) ) ; } StorageSystem vplexSystem = _dbClient . queryObject ( StorageSystem . class , storage ) ; Workflow . Method restoreFromFullcopyMethod = new Workflow . Method ( RESTORE_FROM_FULLCOPY_METHOD_NAME , storage , fullcopies ) ; waitFor = workflow . createStep ( RESTORE_FROM_FULLCOPY_STEP , STRING , waitFor , storage , vplexSystem . getSystemType ( ) , VPlexDeviceController . class , restoreFromFullcopyMethod , null , null ) ; _log . info ( STRING ) ; return waitFor ; }
public void search ( ) { int to_pop = config . pop_limit ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STRING , to_pop , candidates . size ( ) ) ; for ( Candidate c : candidates ) LOG . debug ( STRING , c ) ; } while ( to_pop > _NUM && ! candidates . isEmpty ( ) ) { Candidate got = candidates . poll ( ) ; if ( got != null ) { addHypothesis ( got ) ; -- to_pop ; for ( Candidate c : got . extend ( ) ) if ( c != null ) { addCandidate ( c ) ; } } } }
public boolean isCellEditable ( int row , int col ) { return _BOOL ; }
public static long count ( Bson q , Class < ? extends Bean > t ) { String collection = MongoHelper . getCollection ( t ) ; if ( ! X . isEmpty ( collection ) ) { return count ( collection , q ) ; } return _NUM ; }
public static long count ( Bson q , Class < ? extends Bean > t ) { String collection = MongoHelper . getCollection ( t ) ; if ( ! X . isEmpty ( collection ) ) { return count ( collection , q ) ; } return _NUM ; }
private static void analyzeHadoopConfiguration ( ) { JobConf job = ConfigurationManager . getCachedJobConf ( ) ; _remoteMRSortMem = ( _NUM * _NUM ) * job . getLong ( MRConfigurationNames . MR_TASK_IO_SORT_MB , _NUM ) ; String javaOpts1 = job . get ( MRConfigurationNames . MR_CHILD_JAVA_OPTS ) ; String javaOpts2 = job . get ( MRConfigurationNames . MR_MAP_JAVA_OPTS , null ) ; String javaOpts3 = job . get ( MRConfigurationNames . MR_REDUCE_JAVA_OPTS , null ) ; if ( javaOpts2 != null ) _remoteJVMMaxMemMap = extractMaxMemoryOpt ( javaOpts2 ) ; else _remoteJVMMaxMemMap = extractMaxMemoryOpt ( javaOpts1 ) ; if ( javaOpts3 != null ) _remoteJVMMaxMemReduce = extractMaxMemoryOpt ( javaOpts3 ) ; else _remoteJVMMaxMemReduce = extractMaxMemoryOpt ( javaOpts1 ) ; String blocksize = job . get ( MRConfigurationNames . DFS_BLOCKSIZE , STRING ) ; _blocksize = Long . parseLong ( blocksize ) ; String framework = job . get ( MRConfigurationNames . MR_FRAMEWORK_NAME ) ; _yarnEnabled = ( framework != null && framework . equals ( STRING ) ) ; _localJT = analyzeLocalMode ( job ) ; }
private static void analyzeHadoopConfiguration ( ) { JobConf job = ConfigurationManager . getCachedJobConf ( ) ; _remoteMRSortMem = ( _NUM * _NUM ) * job . getLong ( MRConfigurationNames . MR_TASK_IO_SORT_MB , _NUM ) ; String javaOpts1 = job . get ( MRConfigurationNames . MR_CHILD_JAVA_OPTS ) ; String javaOpts2 = job . get ( MRConfigurationNames . MR_MAP_JAVA_OPTS , null ) ; String javaOpts3 = job . get ( MRConfigurationNames . MR_REDUCE_JAVA_OPTS , null ) ; if ( javaOpts2 != null ) _remoteJVMMaxMemMap = extractMaxMemoryOpt ( javaOpts2 ) ; else _remoteJVMMaxMemMap = extractMaxMemoryOpt ( javaOpts1 ) ; if ( javaOpts3 != null ) _remoteJVMMaxMemReduce = extractMaxMemoryOpt ( javaOpts3 ) ; else _remoteJVMMaxMemReduce = extractMaxMemoryOpt ( javaOpts1 ) ; String blocksize = job . get ( MRConfigurationNames . DFS_BLOCKSIZE , STRING ) ; _blocksize = Long . parseLong ( blocksize ) ; String framework = job . get ( MRConfigurationNames . MR_FRAMEWORK_NAME ) ; _yarnEnabled = ( framework != null && framework . equals ( STRING ) ) ; _localJT = analyzeLocalMode ( job ) ; }
@ Override public double [ ] [ ] processIds ( DBIDs ids , Relation < ? extends NumberVector > relation ) { final int dim = RelationUtil . dimensionality ( relation ) ; final CovarianceMatrix cmat = new CovarianceMatrix ( dim ) ; final Centroid centroid = Centroid . make ( relation , ids ) ; double maxdist = _NUM ; double stddev = _NUM ; { for ( DBIDIter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { NumberVector obj = relation . get ( iter ) ; double distance = weightDistance . distance ( centroid , obj ) ; stddev += distance * distance ; if ( distance > maxdist ) { maxdist = distance ; } } if ( maxdist == _NUM ) { maxdist = _NUM ; } stddev = Math . sqrt ( stddev / ids . size ( ) ) ; } for ( DBIDIter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { NumberVector obj = relation . get ( iter ) ; double distance = weightDistance . distance ( centroid , obj ) ; double weight = weightfunction . getWeight ( distance , maxdist , stddev ) ; cmat . put ( obj , weight ) ; } return cmat . destroyToNaiveMatrix ( ) ; }
@ Override public double [ ] [ ] processIds ( DBIDs ids , Relation < ? extends NumberVector > relation ) { final int dim = RelationUtil . dimensionality ( relation ) ; final CovarianceMatrix cmat = new CovarianceMatrix ( dim ) ; final Centroid centroid = Centroid . make ( relation , ids ) ; double maxdist = _NUM ; double stddev = _NUM ; { for ( DBIDIter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { NumberVector obj = relation . get ( iter ) ; double distance = weightDistance . distance ( centroid , obj ) ; stddev += distance * distance ; if ( distance > maxdist ) { maxdist = distance ; } } if ( maxdist == _NUM ) { maxdist = _NUM ; } stddev = Math . sqrt ( stddev / ids . size ( ) ) ; } for ( DBIDIter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { NumberVector obj = relation . get ( iter ) ; double distance = weightDistance . distance ( centroid , obj ) ; double weight = weightfunction . getWeight ( distance , maxdist , stddev ) ; cmat . put ( obj , weight ) ; } return cmat . destroyToNaiveMatrix ( ) ; }
@ Override public double [ ] [ ] processIds ( DBIDs ids , Relation < ? extends NumberVector > relation ) { final int dim = RelationUtil . dimensionality ( relation ) ; final CovarianceMatrix cmat = new CovarianceMatrix ( dim ) ; final Centroid centroid = Centroid . make ( relation , ids ) ; double maxdist = _NUM ; double stddev = _NUM ; { for ( DBIDIter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { NumberVector obj = relation . get ( iter ) ; double distance = weightDistance . distance ( centroid , obj ) ; stddev += distance * distance ; if ( distance > maxdist ) { maxdist = distance ; } } if ( maxdist == _NUM ) { maxdist = _NUM ; } stddev = Math . sqrt ( stddev / ids . size ( ) ) ; } for ( DBIDIter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { NumberVector obj = relation . get ( iter ) ; double distance = weightDistance . distance ( centroid , obj ) ; double weight = weightfunction . getWeight ( distance , maxdist , stddev ) ; cmat . put ( obj , weight ) ; } return cmat . destroyToNaiveMatrix ( ) ; }
private void outputFullLines ( ) throws IOException { for ( ; ; ) { int leftLen = leftBuf . indexOf ( STRING ) ; if ( leftLen < _NUM ) { return ; } int rightLen = rightBuf . indexOf ( STRING ) ; if ( rightLen < _NUM ) { return ; } if ( leftLen != _NUM ) { out . write ( leftBuf . substring ( _NUM , leftLen ) ) ; } if ( rightLen != _NUM ) { writeSpaces ( out , leftWidth - leftLen ) ; out . write ( rightBuf . substring ( _NUM , rightLen ) ) ; } out . write ( STRING ) ; leftBuf . delete ( _NUM , leftLen + _NUM ) ; rightBuf . delete ( _NUM , rightLen + _NUM ) ; } }
public static boolean registerCanonicalizer ( final String c14nAlgorithmURI ) { final boolean added = canonicalizers . add ( c14nAlgorithmURI ) ; return added ; }
public int compareTo ( LibPadstack p_other ) { if ( p_other == null ) return _NUM ; return pads_name . compareToIgnoreCase ( p_other . pads_name ) ; }
private void computeRotationTime ( ) { _keyRotationIntervalInMsecs = _maxLifeValuesHolder . computeRotationTimeInMSecs ( ) ; _log . info ( STRING , _keyRotationIntervalInMsecs ) ; }
public HostStateChange ( Host target , URI oldClusterURI ) { this . host = target ; this . oldInitiators = Sets . newHashSet ( ) ; this . newInitiators = Sets . newHashSet ( ) ; this . oldCluster = oldClusterURI ; }
private Response requestHttpGetFromRegistry ( String url ) throws RegistryException { try { Response resp = http . get ( url ) ; if ( resp != null && resp . content != null ) { return resp ; } else { throw new RegistryException ( TYPE . BAD_RESPONSE , STRING ) ; } } catch ( ClassCastException e ) { throw new RegistryException ( TYPE . BAD_RESPONSE , e ) ; } catch ( ConnectException e ) { throw new RegistryException ( TYPE . PROXY , e ) ; } catch ( UnknownHostException e ) { try { http . get ( STRING ) ; } catch ( Exception e1 ) { throw new RegistryException ( TYPE . NO_INTERNET , e1 ) ; } throw new RegistryException ( TYPE . SITE_DOWN , e ) ; } catch ( IOException e ) { throw new RegistryException ( TYPE . IO_ERROR , e ) ; } catch ( URISyntaxException e ) { throw new RegistryException ( TYPE . BAD_REQUEST , STRING + ( ( url != null ) ? url : STRING ) ) ; } }
private Response requestHttpGetFromRegistry ( String url ) throws RegistryException { try { Response resp = http . get ( url ) ; if ( resp != null && resp . content != null ) { return resp ; } else { throw new RegistryException ( TYPE . BAD_RESPONSE , STRING ) ; } } catch ( ClassCastException e ) { throw new RegistryException ( TYPE . BAD_RESPONSE , e ) ; } catch ( ConnectException e ) { throw new RegistryException ( TYPE . PROXY , e ) ; } catch ( UnknownHostException e ) { try { http . get ( STRING ) ; } catch ( Exception e1 ) { throw new RegistryException ( TYPE . NO_INTERNET , e1 ) ; } throw new RegistryException ( TYPE . SITE_DOWN , e ) ; } catch ( IOException e ) { throw new RegistryException ( TYPE . IO_ERROR , e ) ; } catch ( URISyntaxException e ) { throw new RegistryException ( TYPE . BAD_REQUEST , STRING + ( ( url != null ) ? url : STRING ) ) ; } }
private Response requestHttpGetFromRegistry ( String url ) throws RegistryException { try { Response resp = http . get ( url ) ; if ( resp != null && resp . content != null ) { return resp ; } else { throw new RegistryException ( TYPE . BAD_RESPONSE , STRING ) ; } } catch ( ClassCastException e ) { throw new RegistryException ( TYPE . BAD_RESPONSE , e ) ; } catch ( ConnectException e ) { throw new RegistryException ( TYPE . PROXY , e ) ; } catch ( UnknownHostException e ) { try { http . get ( STRING ) ; } catch ( Exception e1 ) { throw new RegistryException ( TYPE . NO_INTERNET , e1 ) ; } throw new RegistryException ( TYPE . SITE_DOWN , e ) ; } catch ( IOException e ) { throw new RegistryException ( TYPE . IO_ERROR , e ) ; } catch ( URISyntaxException e ) { throw new RegistryException ( TYPE . BAD_REQUEST , STRING + ( ( url != null ) ? url : STRING ) ) ; } }
private Response requestHttpGetFromRegistry ( String url ) throws RegistryException { try { Response resp = http . get ( url ) ; if ( resp != null && resp . content != null ) { return resp ; } else { throw new RegistryException ( TYPE . BAD_RESPONSE , STRING ) ; } } catch ( ClassCastException e ) { throw new RegistryException ( TYPE . BAD_RESPONSE , e ) ; } catch ( ConnectException e ) { throw new RegistryException ( TYPE . PROXY , e ) ; } catch ( UnknownHostException e ) { try { http . get ( STRING ) ; } catch ( Exception e1 ) { throw new RegistryException ( TYPE . NO_INTERNET , e1 ) ; } throw new RegistryException ( TYPE . SITE_DOWN , e ) ; } catch ( IOException e ) { throw new RegistryException ( TYPE . IO_ERROR , e ) ; } catch ( URISyntaxException e ) { throw new RegistryException ( TYPE . BAD_REQUEST , STRING + ( ( url != null ) ? url : STRING ) ) ; } }
public static void launchURL ( final URI uri , final String title , String tooltip , String browserId , LaunchMode launchMode ) { Check . notNull ( uri , STRING ) ; if ( ! URISchemeHelper . isOnTrustedUriWhiteList ( uri ) ) { URISchemeHelper . showUnsafeSchemeError ( uri ) ; return ; } if ( launchMode == null ) { launchMode = LaunchMode . USER_PREFERENCE ; } if ( browserId == null ) { browserId = STRING ; } if ( tooltip == null ) { tooltip = STRING ; } final boolean workbenchBrowserMode ; synchronized ( BrowserFacade . class ) { workbenchBrowserMode = useWorkbenchBrowserSupport ; } if ( workbenchBrowserMode ) { try { launchWithWorkbenchBrowserSupport ( uri , title , tooltip , browserId , launchMode ) ; return ; } catch ( final Exception e ) { log . warn ( STRING , e ) ; } } launchInFallbackMode ( uri . toString ( ) , title , tooltip , browserId , launchMode ) ; }
public int numChildren ( ) { return mChildren . size ( ) ; }
private void removeAcked ( ArrayList < RecordInfo > acks ) { for ( RecordInfo info : acks ) { AckDescribe ack = ( AckDescribe ) DescribeJournal . newObjectEncoding ( info , null ) ; HashMap < Long , ReferenceDescribe > referenceDescribeHashMap = messageRefs . get ( info . id ) ; referenceDescribeHashMap . remove ( ack . refEncoding . queueID ) ; if ( referenceDescribeHashMap . size ( ) == _NUM ) { messages . remove ( info . id ) ; messageRefs . remove ( info . id ) ; } } }
private void removeAcked ( ArrayList < RecordInfo > acks ) { for ( RecordInfo info : acks ) { AckDescribe ack = ( AckDescribe ) DescribeJournal . newObjectEncoding ( info , null ) ; HashMap < Long , ReferenceDescribe > referenceDescribeHashMap = messageRefs . get ( info . id ) ; referenceDescribeHashMap . remove ( ack . refEncoding . queueID ) ; if ( referenceDescribeHashMap . size ( ) == _NUM ) { messages . remove ( info . id ) ; messageRefs . remove ( info . id ) ; } } }
public ChessSquare ( Composite parent , ChessBoard chessBoard , int id , boolean isLight ) { super ( parent , SWT . DOUBLE_BUFFERED | SWT . NO_BACKGROUND ) ; board = chessBoard ; this . id = id ; this . isLight = isLight ; addPaintListener ( paintListener ) ; addControlListener ( controlListener ) ; addMouseListener ( mouseListener ) ; addListener ( SWT . MouseWheel , mouseWheelListener ) ; addListener ( SWT . MouseDown , dndListener ) ; addListener ( SWT . MouseUp , dndListener ) ; }
public static double [ ] fromString ( String data , String separator ) { String [ ] split = data . split ( separator ) ; double [ ] ret = new double [ split . length ] ; for ( int i = _NUM ; i < split . length ; i ++ ) { ret [ i ] = Double . parseDouble ( split [ i ] ) ; } return ret ; }
private synchronized boolean shouldGarbageCollectPeer ( Peer peer ) { Date lastSeen = peer . getLastSeen ( ) ; Date now = new Date ( ) ; long msSinceSeen = now . getTime ( ) - lastSeen . getTime ( ) ; return msSinceSeen > PEER_TIMEOUT ; }
private synchronized boolean shouldGarbageCollectPeer ( Peer peer ) { Date lastSeen = peer . getLastSeen ( ) ; Date now = new Date ( ) ; long msSinceSeen = now . getTime ( ) - lastSeen . getTime ( ) ; return msSinceSeen > PEER_TIMEOUT ; }
public boolean isAccepted ( Question q ) { if ( excludeQuestions != null && excludeQuestions . contains ( STRING + q . getQuestionId ( ) + STRING ) ) { return _BOOL ; } if ( filterDupes ) { if ( ! q . isPossibleDuplicate ( ) ) { return _BOOL ; } } if ( closeVotes != null && closeVotes . isFilterActive ( ) ) { if ( ! closeVotes . inRange ( q . getCloseVoteCount ( ) ) ) { return _BOOL ; } } if ( scores != null && scores . isFilterActive ( ) ) { if ( ! scores . inRange ( q . getScore ( ) ) ) { return _BOOL ; } } if ( answerType != null ) { switch ( answerType ) { case CLICK_FROM_ROOMBA : return q . isAlmostRoomba ( ) ; case HAS_ANSWER : return q . getAnswerCount ( ) > _NUM ; case HAS_ACCEPTED_ANSWER : return q . isAnswerAccepted ( ) ; case HAS_NO_ACCEPTED_ANSWER : return ! q . isAnswerAccepted ( ) ; case HAS_NO_ANSWER : return q . getAnswerCount ( ) <= _NUM ; case NO_ROOMBA : return ! q . isRoomba ( ) ; case NO_FILTER : return _BOOL ; } } return _BOOL ; }
public static StringBuffer leftShift ( StringBuffer self , Object value ) { self . append ( value ) ; return self ; }
public static StringBuffer leftShift ( StringBuffer self , Object value ) { self . append ( value ) ; return self ; }
private static void nioCopy ( FileOutputStream fos , FileInputStream fis ) throws IOException { FileChannel outChannel = fos . getChannel ( ) ; FileChannel inChannel = fis . getChannel ( ) ; long length = inChannel . size ( ) ; long offset = _NUM ; while ( _BOOL ) { long remaining = length - offset ; long toTransfer = remaining < MAX_TRANSFER_SIZE ? remaining : MAX_TRANSFER_SIZE ; long transferredBytes = inChannel . transferTo ( offset , toTransfer , outChannel ) ; offset += transferredBytes ; length = inChannel . size ( ) ; if ( offset >= length ) { break ; } } }
public void legacyProcess ( Class clazz , Method m , MethodAppearanceDecision decision ) { if ( m . getDeclaringClass ( ) != Object . class && m . getReturnType ( ) != void . class && m . getParameterTypes ( ) . length == _NUM ) { String mName = m . getName ( ) ; if ( ! looksLikePropertyReadMethod ( mName ) ) { decision . setExposeMethodAs ( null ) ; try { decision . setExposeAsProperty ( new PropertyDescriptor ( mName , clazz , mName , null ) ) ; } catch ( IntrospectionException e ) { throw new RuntimeException ( e ) ; } } } }
public void legacyProcess ( Class clazz , Method m , MethodAppearanceDecision decision ) { if ( m . getDeclaringClass ( ) != Object . class && m . getReturnType ( ) != void . class && m . getParameterTypes ( ) . length == _NUM ) { String mName = m . getName ( ) ; if ( ! looksLikePropertyReadMethod ( mName ) ) { decision . setExposeMethodAs ( null ) ; try { decision . setExposeAsProperty ( new PropertyDescriptor ( mName , clazz , mName , null ) ) ; } catch ( IntrospectionException e ) { throw new RuntimeException ( e ) ; } } } }
public void legacyProcess ( Class clazz , Method m , MethodAppearanceDecision decision ) { if ( m . getDeclaringClass ( ) != Object . class && m . getReturnType ( ) != void . class && m . getParameterTypes ( ) . length == _NUM ) { String mName = m . getName ( ) ; if ( ! looksLikePropertyReadMethod ( mName ) ) { decision . setExposeMethodAs ( null ) ; try { decision . setExposeAsProperty ( new PropertyDescriptor ( mName , clazz , mName , null ) ) ; } catch ( IntrospectionException e ) { throw new RuntimeException ( e ) ; } } } }
public void legacyProcess ( Class clazz , Method m , MethodAppearanceDecision decision ) { if ( m . getDeclaringClass ( ) != Object . class && m . getReturnType ( ) != void . class && m . getParameterTypes ( ) . length == _NUM ) { String mName = m . getName ( ) ; if ( ! looksLikePropertyReadMethod ( mName ) ) { decision . setExposeMethodAs ( null ) ; try { decision . setExposeAsProperty ( new PropertyDescriptor ( mName , clazz , mName , null ) ) ; } catch ( IntrospectionException e ) { throw new RuntimeException ( e ) ; } } } }
private void releaseAllLocks ( ) { synchronized ( read_notify ) { read_notify . notifyAll ( ) ; } synchronized ( write_notify ) { write_notify . notifyAll ( ) ; } synchronized ( state_notify ) { state_notify . notifyAll ( ) ; } }
public ServletBinding ( HttpServletRequest request , HttpServletResponse response , ServletContext context ) { super . setVariable ( STRING , request ) ; super . setVariable ( STRING , response ) ; super . setVariable ( STRING , context ) ; super . setVariable ( STRING , context ) ; super . setVariable ( STRING , request . getSession ( _BOOL ) ) ; Map params = collectParams ( request ) ; super . setVariable ( STRING , params ) ; Map < String , String > headers = new LinkedHashMap < String , String > ( ) ; for ( Enumeration names = request . getHeaderNames ( ) ; names . hasMoreElements ( ) ; ) { String headerName = ( String ) names . nextElement ( ) ; String headerValue = request . getHeader ( headerName ) ; headers . put ( headerName , headerValue ) ; } super . setVariable ( STRING , headers ) ; }
private void addComposedChars ( ) throws ParseException { ComposedCharIter iter = new ComposedCharIter ( ) ; int c ; while ( ( c = iter . next ( ) ) != ComposedCharIter . DONE ) { if ( getCharOrder ( c ) == RBCollationTables . UNMAPPED ) { String s = iter . decomposition ( ) ; if ( s . length ( ) == _NUM ) { int order = getCharOrder ( s . charAt ( _NUM ) ) ; if ( order != RBCollationTables . UNMAPPED ) { addOrder ( c , order ) ; } continue ; } else if ( s . length ( ) == _NUM ) { char ch0 = s . charAt ( _NUM ) ; if ( Character . isHighSurrogate ( ch0 ) ) { int order = getCharOrder ( s . codePointAt ( _NUM ) ) ; if ( order != RBCollationTables . UNMAPPED ) { addOrder ( c , order ) ; } continue ; } } int contractOrder = getContractOrder ( s ) ; if ( contractOrder != RBCollationTables . UNMAPPED ) { addOrder ( c , contractOrder ) ; } else { boolean allThere = _BOOL ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { if ( getCharOrder ( s . charAt ( i ) ) == RBCollationTables . UNMAPPED ) { allThere = _BOOL ; break ; } } if ( allThere ) { addExpandOrder ( c , s , RBCollationTables . UNMAPPED ) ; } } } } }
private void addComposedChars ( ) throws ParseException { ComposedCharIter iter = new ComposedCharIter ( ) ; int c ; while ( ( c = iter . next ( ) ) != ComposedCharIter . DONE ) { if ( getCharOrder ( c ) == RBCollationTables . UNMAPPED ) { String s = iter . decomposition ( ) ; if ( s . length ( ) == _NUM ) { int order = getCharOrder ( s . charAt ( _NUM ) ) ; if ( order != RBCollationTables . UNMAPPED ) { addOrder ( c , order ) ; } continue ; } else if ( s . length ( ) == _NUM ) { char ch0 = s . charAt ( _NUM ) ; if ( Character . isHighSurrogate ( ch0 ) ) { int order = getCharOrder ( s . codePointAt ( _NUM ) ) ; if ( order != RBCollationTables . UNMAPPED ) { addOrder ( c , order ) ; } continue ; } } int contractOrder = getContractOrder ( s ) ; if ( contractOrder != RBCollationTables . UNMAPPED ) { addOrder ( c , contractOrder ) ; } else { boolean allThere = _BOOL ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { if ( getCharOrder ( s . charAt ( i ) ) == RBCollationTables . UNMAPPED ) { allThere = _BOOL ; break ; } } if ( allThere ) { addExpandOrder ( c , s , RBCollationTables . UNMAPPED ) ; } } } } }
private void addComposedChars ( ) throws ParseException { ComposedCharIter iter = new ComposedCharIter ( ) ; int c ; while ( ( c = iter . next ( ) ) != ComposedCharIter . DONE ) { if ( getCharOrder ( c ) == RBCollationTables . UNMAPPED ) { String s = iter . decomposition ( ) ; if ( s . length ( ) == _NUM ) { int order = getCharOrder ( s . charAt ( _NUM ) ) ; if ( order != RBCollationTables . UNMAPPED ) { addOrder ( c , order ) ; } continue ; } else if ( s . length ( ) == _NUM ) { char ch0 = s . charAt ( _NUM ) ; if ( Character . isHighSurrogate ( ch0 ) ) { int order = getCharOrder ( s . codePointAt ( _NUM ) ) ; if ( order != RBCollationTables . UNMAPPED ) { addOrder ( c , order ) ; } continue ; } } int contractOrder = getContractOrder ( s ) ; if ( contractOrder != RBCollationTables . UNMAPPED ) { addOrder ( c , contractOrder ) ; } else { boolean allThere = _BOOL ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { if ( getCharOrder ( s . charAt ( i ) ) == RBCollationTables . UNMAPPED ) { allThere = _BOOL ; break ; } } if ( allThere ) { addExpandOrder ( c , s , RBCollationTables . UNMAPPED ) ; } } } } }
public void cancel ( ) { synchronized ( this ) { if ( performingPrinting ) { userCancelled = _BOOL ; } notify ( ) ; } }
public void cancel ( ) { synchronized ( this ) { if ( performingPrinting ) { userCancelled = _BOOL ; } notify ( ) ; } }
@ Override public void flush ( ) throws IOException { flushBuffer ( ) ; _outputStream . flush ( ) ; }
@ Override public void flush ( ) throws IOException { flushBuffer ( ) ; _outputStream . flush ( ) ; }
@ Override public void flush ( ) throws IOException { flushBuffer ( ) ; _outputStream . flush ( ) ; }
@ Override public void flush ( ) throws IOException { flushBuffer ( ) ; _outputStream . flush ( ) ; }
@ Override public void flush ( ) throws IOException { flushBuffer ( ) ; _outputStream . flush ( ) ; }
@ Override public void flush ( ) throws IOException { flushBuffer ( ) ; _outputStream . flush ( ) ; }
@ Deprecated public static void publishInstallAsync ( final Context context , final String applicationId ) { publishInstallAsync ( context , applicationId , null ) ; }
@ Deprecated public static void publishInstallAsync ( final Context context , final String applicationId ) { publishInstallAsync ( context , applicationId , null ) ; }
@ Deprecated public static void publishInstallAsync ( final Context context , final String applicationId ) { publishInstallAsync ( context , applicationId , null ) ; }
public void testWhenComplete_sourceFailedActionFailed ( ) { for ( boolean createIncomplete : new boolean [ ] { _BOOL , _BOOL } ) for ( ExecutionMode m : ExecutionMode . values ( ) ) { final AtomicInteger a = new AtomicInteger ( _NUM ) ; final CFException ex1 = new CFException ( ) ; final CFException ex2 = new CFException ( ) ; final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; if ( ! createIncomplete ) f . completeExceptionally ( ex1 ) ; final CompletableFuture < Integer > g = m . whenComplete ( f , null ) ; if ( createIncomplete ) f . completeExceptionally ( ex1 ) ; checkCompletedWithWrappedException ( g , ex1 ) ; checkCompletedExceptionally ( f , ex1 ) ; assertEquals ( _NUM , a . get ( ) ) ; } }
public void testWhenComplete_sourceFailedActionFailed ( ) { for ( boolean createIncomplete : new boolean [ ] { _BOOL , _BOOL } ) for ( ExecutionMode m : ExecutionMode . values ( ) ) { final AtomicInteger a = new AtomicInteger ( _NUM ) ; final CFException ex1 = new CFException ( ) ; final CFException ex2 = new CFException ( ) ; final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; if ( ! createIncomplete ) f . completeExceptionally ( ex1 ) ; final CompletableFuture < Integer > g = m . whenComplete ( f , null ) ; if ( createIncomplete ) f . completeExceptionally ( ex1 ) ; checkCompletedWithWrappedException ( g , ex1 ) ; checkCompletedExceptionally ( f , ex1 ) ; assertEquals ( _NUM , a . get ( ) ) ; } }
public void testWhenComplete_sourceFailedActionFailed ( ) { for ( boolean createIncomplete : new boolean [ ] { _BOOL , _BOOL } ) for ( ExecutionMode m : ExecutionMode . values ( ) ) { final AtomicInteger a = new AtomicInteger ( _NUM ) ; final CFException ex1 = new CFException ( ) ; final CFException ex2 = new CFException ( ) ; final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; if ( ! createIncomplete ) f . completeExceptionally ( ex1 ) ; final CompletableFuture < Integer > g = m . whenComplete ( f , null ) ; if ( createIncomplete ) f . completeExceptionally ( ex1 ) ; checkCompletedWithWrappedException ( g , ex1 ) ; checkCompletedExceptionally ( f , ex1 ) ; assertEquals ( _NUM , a . get ( ) ) ; } }
public void testWhenComplete_sourceFailedActionFailed ( ) { for ( boolean createIncomplete : new boolean [ ] { _BOOL , _BOOL } ) for ( ExecutionMode m : ExecutionMode . values ( ) ) { final AtomicInteger a = new AtomicInteger ( _NUM ) ; final CFException ex1 = new CFException ( ) ; final CFException ex2 = new CFException ( ) ; final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; if ( ! createIncomplete ) f . completeExceptionally ( ex1 ) ; final CompletableFuture < Integer > g = m . whenComplete ( f , null ) ; if ( createIncomplete ) f . completeExceptionally ( ex1 ) ; checkCompletedWithWrappedException ( g , ex1 ) ; checkCompletedExceptionally ( f , ex1 ) ; assertEquals ( _NUM , a . get ( ) ) ; } }
public void testWhenComplete_sourceFailedActionFailed ( ) { for ( boolean createIncomplete : new boolean [ ] { _BOOL , _BOOL } ) for ( ExecutionMode m : ExecutionMode . values ( ) ) { final AtomicInteger a = new AtomicInteger ( _NUM ) ; final CFException ex1 = new CFException ( ) ; final CFException ex2 = new CFException ( ) ; final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; if ( ! createIncomplete ) f . completeExceptionally ( ex1 ) ; final CompletableFuture < Integer > g = m . whenComplete ( f , null ) ; if ( createIncomplete ) f . completeExceptionally ( ex1 ) ; checkCompletedWithWrappedException ( g , ex1 ) ; checkCompletedExceptionally ( f , ex1 ) ; assertEquals ( _NUM , a . get ( ) ) ; } }
public void testWhenComplete_sourceFailedActionFailed ( ) { for ( boolean createIncomplete : new boolean [ ] { _BOOL , _BOOL } ) for ( ExecutionMode m : ExecutionMode . values ( ) ) { final AtomicInteger a = new AtomicInteger ( _NUM ) ; final CFException ex1 = new CFException ( ) ; final CFException ex2 = new CFException ( ) ; final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; if ( ! createIncomplete ) f . completeExceptionally ( ex1 ) ; final CompletableFuture < Integer > g = m . whenComplete ( f , null ) ; if ( createIncomplete ) f . completeExceptionally ( ex1 ) ; checkCompletedWithWrappedException ( g , ex1 ) ; checkCompletedExceptionally ( f , ex1 ) ; assertEquals ( _NUM , a . get ( ) ) ; } }
public Differences compare ( final File controlFile , final File testFile ) throws SAXException , IOException { Document control = _parser . parse ( controlFile ) ; Document test = _parser . parse ( testFile ) ; Comparator comparator = new Comparator ( control , test , _config ) ; return comparator . compare ( ) ; }
public Differences compare ( final File controlFile , final File testFile ) throws SAXException , IOException { Document control = _parser . parse ( controlFile ) ; Document test = _parser . parse ( testFile ) ; Comparator comparator = new Comparator ( control , test , _config ) ; return comparator . compare ( ) ; }
public static void dumpWhenSysOutContains ( String trigger ) { System . setOut ( wrapAndDumpWhenContains ( System . out , trigger ) ) ; }
@ Override public List < Period > generateRollingPeriods ( Date date ) { Period period = createPeriod ( date ) ; List < Period > periods = Lists . newArrayList ( ) ; periods . add ( getPreviousPeriod ( period ) ) ; periods . add ( period ) ; return periods ; }
@ Override public List < Period > generateRollingPeriods ( Date date ) { Period period = createPeriod ( date ) ; List < Period > periods = Lists . newArrayList ( ) ; periods . add ( getPreviousPeriod ( period ) ) ; periods . add ( period ) ; return periods ; }
@ Override public List < Period > generateRollingPeriods ( Date date ) { Period period = createPeriod ( date ) ; List < Period > periods = Lists . newArrayList ( ) ; periods . add ( getPreviousPeriod ( period ) ) ; periods . add ( period ) ; return periods ; }
private static boolean contains ( String group , String member ) { String quote = Pattern . quote ( member ) ; Pattern pattern = Pattern . compile ( STRING + quote + STRING + quote + STRING + quote + STRING + STRING + quote + STRING ) ; Matcher matcher = pattern . matcher ( group ) ; return matcher . find ( ) ; }
private static boolean contains ( String group , String member ) { String quote = Pattern . quote ( member ) ; Pattern pattern = Pattern . compile ( STRING + quote + STRING + quote + STRING + quote + STRING + STRING + quote + STRING ) ; Matcher matcher = pattern . matcher ( group ) ; return matcher . find ( ) ; }
public void testMultipleCreators ( ) throws Exception { MultiBean bean = MAPPER . readValue ( STRING , MultiBean . class ) ; assertEquals ( Integer . valueOf ( _NUM ) , bean . value ) ; bean = MAPPER . readValue ( quote ( STRING ) , MultiBean . class ) ; assertEquals ( STRING , bean . value ) ; bean = MAPPER . readValue ( STRING , MultiBean . class ) ; assertEquals ( Double . valueOf ( _NUM ) , bean . value ) ; }
public void testMultipleCreators ( ) throws Exception { MultiBean bean = MAPPER . readValue ( STRING , MultiBean . class ) ; assertEquals ( Integer . valueOf ( _NUM ) , bean . value ) ; bean = MAPPER . readValue ( quote ( STRING ) , MultiBean . class ) ; assertEquals ( STRING , bean . value ) ; bean = MAPPER . readValue ( STRING , MultiBean . class ) ; assertEquals ( Double . valueOf ( _NUM ) , bean . value ) ; }
private static < E > List < TypeAdapter > buildKnownAdapters ( ) { List < TypeAdapter > result = Lists . newArrayList ( ) ; result . add ( new TypeAdapter ( CollapseDataWrapper . class , new CollapseDataWrapperAdapter < E > ( ) ) ) ; result . add ( new TypeAdapter ( CollapseTreeRoot . class , new CollapseTreeRootAdapter < E > ( ) ) ) ; result . add ( new TypeAdapter ( HierarchyRoot . class , new HierarchyRootAdapter ( ) ) ) ; result . add ( new TypeAdapter ( NodeWrapper . class , new NodeWrapperAdapter < E > ( ) ) ) ; result . add ( new TypeAdapter ( NodeWrapperRoot . class , new NodeWrapperRootAdapter < E > ( ) ) ) ; result . add ( new TypeAdapter ( SolitaryRoot . class , new SolitaryRootAdapter ( ) ) ) ; result . add ( new TypeAdapter ( ViewerRoot . class , new ViewerRootAdapter ( ) ) ) ; return result ; }
private static < E > List < TypeAdapter > buildKnownAdapters ( ) { List < TypeAdapter > result = Lists . newArrayList ( ) ; result . add ( new TypeAdapter ( CollapseDataWrapper . class , new CollapseDataWrapperAdapter < E > ( ) ) ) ; result . add ( new TypeAdapter ( CollapseTreeRoot . class , new CollapseTreeRootAdapter < E > ( ) ) ) ; result . add ( new TypeAdapter ( HierarchyRoot . class , new HierarchyRootAdapter ( ) ) ) ; result . add ( new TypeAdapter ( NodeWrapper . class , new NodeWrapperAdapter < E > ( ) ) ) ; result . add ( new TypeAdapter ( NodeWrapperRoot . class , new NodeWrapperRootAdapter < E > ( ) ) ) ; result . add ( new TypeAdapter ( SolitaryRoot . class , new SolitaryRootAdapter ( ) ) ) ; result . add ( new TypeAdapter ( ViewerRoot . class , new ViewerRootAdapter ( ) ) ) ; return result ; }
private static < E > List < TypeAdapter > buildKnownAdapters ( ) { List < TypeAdapter > result = Lists . newArrayList ( ) ; result . add ( new TypeAdapter ( CollapseDataWrapper . class , new CollapseDataWrapperAdapter < E > ( ) ) ) ; result . add ( new TypeAdapter ( CollapseTreeRoot . class , new CollapseTreeRootAdapter < E > ( ) ) ) ; result . add ( new TypeAdapter ( HierarchyRoot . class , new HierarchyRootAdapter ( ) ) ) ; result . add ( new TypeAdapter ( NodeWrapper . class , new NodeWrapperAdapter < E > ( ) ) ) ; result . add ( new TypeAdapter ( NodeWrapperRoot . class , new NodeWrapperRootAdapter < E > ( ) ) ) ; result . add ( new TypeAdapter ( SolitaryRoot . class , new SolitaryRootAdapter ( ) ) ) ; result . add ( new TypeAdapter ( ViewerRoot . class , new ViewerRootAdapter ( ) ) ) ; return result ; }
public void openForWrite ( ) throws EventException { File f = new File ( ConfigUtils . getInitialPropertyExpanded ( m_address . getPathname ( ) ) ) ; try { if ( ! f . exists ( ) ) { f . createNewFile ( ) ; } else { LOGGER . info ( STRING + m_address . getPathname ( ) ) ; } } catch ( IOException ioe ) { throw new EventException ( STRING + m_address . getPathname ( ) + STRING + ioe ) ; } try { m_fos = new FileOutputStream ( f , _BOOL ) ; } catch ( FileNotFoundException fnfe ) { throw new EventException ( STRING + m_address . getPathname ( ) + STRING + fnfe ) ; } }
public void openForWrite ( ) throws EventException { File f = new File ( ConfigUtils . getInitialPropertyExpanded ( m_address . getPathname ( ) ) ) ; try { if ( ! f . exists ( ) ) { f . createNewFile ( ) ; } else { LOGGER . info ( STRING + m_address . getPathname ( ) ) ; } } catch ( IOException ioe ) { throw new EventException ( STRING + m_address . getPathname ( ) + STRING + ioe ) ; } try { m_fos = new FileOutputStream ( f , _BOOL ) ; } catch ( FileNotFoundException fnfe ) { throw new EventException ( STRING + m_address . getPathname ( ) + STRING + fnfe ) ; } }
protected Object readResolve ( ) throws java . io . ObjectStreamException { try { CertificateFactory cf = CertificateFactory . getInstance ( type ) ; return cf . generateCertificate ( new java . io . ByteArrayInputStream ( data ) ) ; } catch ( CertificateException e ) { throw new java . io . NotSerializableException ( STRING + type + STRING + e . getMessage ( ) ) ; } }
public void addHexListener ( final IHexPanelListener listener ) { Preconditions . checkNotNull ( listener , STRING ) ; if ( ! m_listeners . contains ( listener ) ) { m_listeners . add ( listener ) ; } }
public static List < String > splitAtLastBlank ( String s , int width ) { List < String > chunks = new ArrayList < > ( ) ; String tmp = s ; while ( tmp . length ( ) > _NUM ) { int index = findSplitpoint ( tmp , width ) ; chunks . add ( tmp . substring ( _NUM , index ) ) ; while ( index < tmp . length ( ) && tmp . charAt ( index ) == STRING ) { index += _NUM ; } if ( index < tmp . length ( ) && tmp . regionMatches ( index , NEWLINE , _NUM , NEWLINE . length ( ) ) ) { index += NEWLINE . length ( ) ; } if ( index >= tmp . length ( ) ) { break ; } tmp = tmp . substring ( index ) ; } return chunks ; }
public static List < String > splitAtLastBlank ( String s , int width ) { List < String > chunks = new ArrayList < > ( ) ; String tmp = s ; while ( tmp . length ( ) > _NUM ) { int index = findSplitpoint ( tmp , width ) ; chunks . add ( tmp . substring ( _NUM , index ) ) ; while ( index < tmp . length ( ) && tmp . charAt ( index ) == STRING ) { index += _NUM ; } if ( index < tmp . length ( ) && tmp . regionMatches ( index , NEWLINE , _NUM , NEWLINE . length ( ) ) ) { index += NEWLINE . length ( ) ; } if ( index >= tmp . length ( ) ) { break ; } tmp = tmp . substring ( index ) ; } return chunks ; }
public static List < String > splitAtLastBlank ( String s , int width ) { List < String > chunks = new ArrayList < > ( ) ; String tmp = s ; while ( tmp . length ( ) > _NUM ) { int index = findSplitpoint ( tmp , width ) ; chunks . add ( tmp . substring ( _NUM , index ) ) ; while ( index < tmp . length ( ) && tmp . charAt ( index ) == STRING ) { index += _NUM ; } if ( index < tmp . length ( ) && tmp . regionMatches ( index , NEWLINE , _NUM , NEWLINE . length ( ) ) ) { index += NEWLINE . length ( ) ; } if ( index >= tmp . length ( ) ) { break ; } tmp = tmp . substring ( index ) ; } return chunks ; }
synchronized public long transferTo ( final RandomAccessFile out ) throws IOException { final long count = nextOffset . get ( ) ; final FileChannel outChannel = out . getChannel ( ) ; final long toPosition = outChannel . position ( ) ; buffer . limit ( ( int ) count ) ; buffer . position ( _NUM ) ; FileChannelUtility . writeAll ( outChannel , buffer , toPosition ) ; outChannel . position ( toPosition + count ) ; return count ; }
synchronized public long transferTo ( final RandomAccessFile out ) throws IOException { final long count = nextOffset . get ( ) ; final FileChannel outChannel = out . getChannel ( ) ; final long toPosition = outChannel . position ( ) ; buffer . limit ( ( int ) count ) ; buffer . position ( _NUM ) ; FileChannelUtility . writeAll ( outChannel , buffer , toPosition ) ; outChannel . position ( toPosition + count ) ; return count ; }
public static double [ ] randomDoubleArray ( int len , Random r ) { final double [ ] ret = new double [ len ] ; for ( int i = _NUM ; i < len ; i ++ ) { ret [ i ] = r . nextDouble ( ) ; } return ret ; }
private void updateInfoFlowSummaryMap ( MethodModel methodModel , Method method ) { Set < InfoKind > sourcesInfoKinds = method . getSourcesInfoKinds ( ) ; Set < InfoKind > sinkInfoKinds = method . getSinkInfoKinds ( ) ; if ( ! sourcesInfoKinds . isEmpty ( ) && ! sinkInfoKinds . isEmpty ( ) ) { for ( InfoKind sourceInfoKind : sourcesInfoKinds ) { String source = sourceInfoKind . toString ( ) ; Map < String , Set < MethodModel > > sinkMap = infoFlowSummaryMap . get ( source ) ; if ( sinkMap == null ) { sinkMap = new TreeMap < String , Set < MethodModel > > ( ) ; infoFlowSummaryMap . put ( source , sinkMap ) ; } for ( InfoKind sinkInfoKind : sinkInfoKinds ) { String sink = sinkInfoKind . toString ( ) ; Set < MethodModel > methodModels = sinkMap . get ( sink ) ; if ( methodModels == null ) { methodModels = new TreeSet < MethodModel > ( ) ; sinkMap . put ( sink , methodModels ) ; } methodModels . add ( methodModel ) ; } } } }
private void gsave ( ) { GState oldGState = getGState ( ) ; mGStateStack . add ( new GState ( oldGState ) ) ; mPSStream . println ( GSAVE_STR ) ; }
private void gsave ( ) { GState oldGState = getGState ( ) ; mGStateStack . add ( new GState ( oldGState ) ) ; mPSStream . println ( GSAVE_STR ) ; }
private void gsave ( ) { GState oldGState = getGState ( ) ; mGStateStack . add ( new GState ( oldGState ) ) ; mPSStream . println ( GSAVE_STR ) ; }
private void gsave ( ) { GState oldGState = getGState ( ) ; mGStateStack . add ( new GState ( oldGState ) ) ; mPSStream . println ( GSAVE_STR ) ; }
private void gsave ( ) { GState oldGState = getGState ( ) ; mGStateStack . add ( new GState ( oldGState ) ) ; mPSStream . println ( GSAVE_STR ) ; }
private void gsave ( ) { GState oldGState = getGState ( ) ; mGStateStack . add ( new GState ( oldGState ) ) ; mPSStream . println ( GSAVE_STR ) ; }
public void log ( String question , String intent , String confidence , String entity , String convoOutput , String convoId , String retrieveAndRankOutput ) throws Exception { logger . info ( Messages . getString ( STRING ) ) ; Database db = client . database ( STRING , _BOOL ) ; db . save ( new Document ( question , intent , confidence , entity , convoOutput , convoId , retrieveAndRankOutput ) ) ; }
public void log ( String question , String intent , String confidence , String entity , String convoOutput , String convoId , String retrieveAndRankOutput ) throws Exception { logger . info ( Messages . getString ( STRING ) ) ; Database db = client . database ( STRING , _BOOL ) ; db . save ( new Document ( question , intent , confidence , entity , convoOutput , convoId , retrieveAndRankOutput ) ) ; }
private static String buildLogMessage ( String methodName , long loadingTimeDuration ) { StringBuilder message = new StringBuilder ( ) ; message . append ( STRING ) ; message . append ( methodName ) ; message . append ( STRING ) ; message . append ( STRING ) ; message . append ( loadingTimeDuration ) ; message . append ( STRING ) ; message . append ( STRING ) ; return message . toString ( ) ; }
private static List < FixedRecord > createFixedRecords ( int count ) { List < FixedRecord > records = new ArrayList < > ( ) ; for ( int i = _NUM ; i < count ; i ++ ) { records . add ( new FixedRecord ( i ) ) ; } return records ; }
public static long stop ( @ NonNull String key ) { long now = System . currentTimeMillis ( ) ; Map < String , Long > currentMap = map . get ( ) ; Optional < Long > maybePreviousInstant = Optional . with ( currentMap . get ( key ) ) ; if ( maybePreviousInstant . isEmpty ( ) ) { Log . warn ( Timer . class , STRING , key ) ; return _NUM ; } long duration = now - maybePreviousInstant . get ( ) ; currentMap . remove ( key ) ; map . set ( currentMap ) ; return duration ; }
public static DSAPublicKey loadDSAPublicKeyFile ( String uname ) { String filename = ClientConfig . getUserKeysPath ( ) + STRING + uname + STRING ; DSAPublicKey pubKey = null ; FileInputStream fis = null ; try { fis = new FileInputStream ( filename ) ; byte [ ] keyBytes = new byte [ fis . available ( ) ] ; fis . read ( keyBytes ) ; KeyFactory keyFactory = KeyFactory . getInstance ( STRING , STRING ) ; X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec ( keyBytes ) ; pubKey = ( DSAPublicKey ) keyFactory . generatePublic ( pubKeySpec ) ; } catch ( IOException e ) { Logging . error ( e . getMessage ( ) ) ; } catch ( NoSuchAlgorithmException e ) { Logging . error ( e . getMessage ( ) ) ; } catch ( NoSuchProviderException e ) { Logging . error ( e . getMessage ( ) ) ; } catch ( InvalidKeySpecException e ) { Logging . error ( e . getMessage ( ) ) ; } finally { CommonMessaging . close ( fis ) ; } return pubKey ; }
public PushProcessorPipeline build ( List < PushProcessorSupplier > processor_suppliers ) throws Exception { ApiServer api = null ; PushMetricRegistryInstance registry = null ; final List < PushProcessor > processors = new ArrayList < > ( processor_suppliers . size ( ) ) ; try { final EndpointRegistration epr ; if ( epr_ == null ) epr = api = new ApiServer ( api_sockaddr_ ) ; else epr = epr_ ; registry = cfg_ . create ( null , epr ) ; for ( PushProcessorSupplier pps : processor_suppliers ) processors . add ( pps . build ( epr ) ) ; if ( history_ != null ) registry . setHistory ( history_ ) ; if ( api != null ) api . start ( ) ; return new PushProcessorPipeline ( registry , collect_interval_seconds_ , processors ) ; } catch ( Exception ex ) { try { if ( api != null ) api . close ( ) ; } catch ( Exception ex1 ) { ex . addSuppressed ( ex1 ) ; } try { if ( registry != null ) registry . close ( ) ; } catch ( Exception ex1 ) { ex . addSuppressed ( ex1 ) ; } for ( PushProcessor pp : processors ) { try { pp . close ( ) ; } catch ( Exception ex1 ) { ex . addSuppressed ( ex1 ) ; } } throw ex ; } }
public static final void writeIntArrayXml ( int [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . toString ( N ) ) ; for ( int i = _NUM ; i < N ; i ++ ) { out . startTag ( null , STRING ) ; out . attribute ( null , STRING , Integer . toString ( val [ i ] ) ) ; out . endTag ( null , STRING ) ; } out . endTag ( null , STRING ) ; }
public static final void writeIntArrayXml ( int [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . toString ( N ) ) ; for ( int i = _NUM ; i < N ; i ++ ) { out . startTag ( null , STRING ) ; out . attribute ( null , STRING , Integer . toString ( val [ i ] ) ) ; out . endTag ( null , STRING ) ; } out . endTag ( null , STRING ) ; }
public static final void writeIntArrayXml ( int [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . toString ( N ) ) ; for ( int i = _NUM ; i < N ; i ++ ) { out . startTag ( null , STRING ) ; out . attribute ( null , STRING , Integer . toString ( val [ i ] ) ) ; out . endTag ( null , STRING ) ; } out . endTag ( null , STRING ) ; }
public static final void writeIntArrayXml ( int [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . toString ( N ) ) ; for ( int i = _NUM ; i < N ; i ++ ) { out . startTag ( null , STRING ) ; out . attribute ( null , STRING , Integer . toString ( val [ i ] ) ) ; out . endTag ( null , STRING ) ; } out . endTag ( null , STRING ) ; }
static void load ( ) { }
static void load ( ) { }
static void load ( ) { }
static void load ( ) { }
static void load ( ) { }
static void load ( ) { }
public void testSequenceIndexQuery ( ) throws Throwable { ServerStateMachineContext context = mock ( ServerStateMachineContext . class ) ; ServerSessionContext session = new ServerSessionContext ( _NUM , UUID . randomUUID ( ) , mock ( Log . class ) , context , _NUM ) ; AtomicBoolean complete = new AtomicBoolean ( ) ; session . registerIndexQuery ( _NUM , null ) ; assertFalse ( complete . get ( ) ) ; session . setLastApplied ( _NUM ) ; assertFalse ( complete . get ( ) ) ; session . setLastApplied ( _NUM ) ; assertTrue ( complete . get ( ) ) ; }
public void testSequenceIndexQuery ( ) throws Throwable { ServerStateMachineContext context = mock ( ServerStateMachineContext . class ) ; ServerSessionContext session = new ServerSessionContext ( _NUM , UUID . randomUUID ( ) , mock ( Log . class ) , context , _NUM ) ; AtomicBoolean complete = new AtomicBoolean ( ) ; session . registerIndexQuery ( _NUM , null ) ; assertFalse ( complete . get ( ) ) ; session . setLastApplied ( _NUM ) ; assertFalse ( complete . get ( ) ) ; session . setLastApplied ( _NUM ) ; assertTrue ( complete . get ( ) ) ; }
void paint ( Graphics g ) { if ( vert == null || nvert <= _NUM ) { return ; } transform ( ) ; if ( gr == null ) { gr = new Color [ _NUM ] ; for ( int i = _NUM ; i < _NUM ; i ++ ) { int grey = ( int ) ( _NUM * ( _NUM - Math . pow ( i / _NUM , _NUM ) ) ) ; gr [ i ] = new Color ( grey , grey , grey ) ; } } int lg = _NUM ; int lim = ncon ; int c [ ] = con ; int v [ ] = tvert ; if ( lim <= _NUM || nvert <= _NUM ) { return ; } for ( int i = _NUM ; i < lim ; i ++ ) { int T = c [ i ] ; int p1 = ( ( T > > _NUM ) & _NUM ) * _NUM ; int p2 = ( T & _NUM ) * _NUM ; int grey = v [ p1 + _NUM ] + v [ p2 + _NUM ] ; if ( grey < _NUM ) { grey = _NUM ; } if ( grey > _NUM ) { grey = _NUM ; } if ( grey != lg ) { lg = grey ; g . setColor ( gr [ grey ] ) ; } g . drawLine ( v [ p1 ] , v [ p1 + _NUM ] , v [ p2 ] , v [ p2 + _NUM ] ) ; } }
void paint ( Graphics g ) { if ( vert == null || nvert <= _NUM ) { return ; } transform ( ) ; if ( gr == null ) { gr = new Color [ _NUM ] ; for ( int i = _NUM ; i < _NUM ; i ++ ) { int grey = ( int ) ( _NUM * ( _NUM - Math . pow ( i / _NUM , _NUM ) ) ) ; gr [ i ] = new Color ( grey , grey , grey ) ; } } int lg = _NUM ; int lim = ncon ; int c [ ] = con ; int v [ ] = tvert ; if ( lim <= _NUM || nvert <= _NUM ) { return ; } for ( int i = _NUM ; i < lim ; i ++ ) { int T = c [ i ] ; int p1 = ( ( T > > _NUM ) & _NUM ) * _NUM ; int p2 = ( T & _NUM ) * _NUM ; int grey = v [ p1 + _NUM ] + v [ p2 + _NUM ] ; if ( grey < _NUM ) { grey = _NUM ; } if ( grey > _NUM ) { grey = _NUM ; } if ( grey != lg ) { lg = grey ; g . setColor ( gr [ grey ] ) ; } g . drawLine ( v [ p1 ] , v [ p1 + _NUM ] , v [ p2 ] , v [ p2 + _NUM ] ) ; } }
void paint ( Graphics g ) { if ( vert == null || nvert <= _NUM ) { return ; } transform ( ) ; if ( gr == null ) { gr = new Color [ _NUM ] ; for ( int i = _NUM ; i < _NUM ; i ++ ) { int grey = ( int ) ( _NUM * ( _NUM - Math . pow ( i / _NUM , _NUM ) ) ) ; gr [ i ] = new Color ( grey , grey , grey ) ; } } int lg = _NUM ; int lim = ncon ; int c [ ] = con ; int v [ ] = tvert ; if ( lim <= _NUM || nvert <= _NUM ) { return ; } for ( int i = _NUM ; i < lim ; i ++ ) { int T = c [ i ] ; int p1 = ( ( T > > _NUM ) & _NUM ) * _NUM ; int p2 = ( T & _NUM ) * _NUM ; int grey = v [ p1 + _NUM ] + v [ p2 + _NUM ] ; if ( grey < _NUM ) { grey = _NUM ; } if ( grey > _NUM ) { grey = _NUM ; } if ( grey != lg ) { lg = grey ; g . setColor ( gr [ grey ] ) ; } g . drawLine ( v [ p1 ] , v [ p1 + _NUM ] , v [ p2 ] , v [ p2 + _NUM ] ) ; } }
public void consumeDocuments ( String topicName , int count , long timeout , TimeUnit unit , Runnable completion , BiPredicate < String , Document > consumer ) { AtomicLong readCounter = new AtomicLong ( ) ; consumeDocuments ( continueIfNotExpired ( null , timeout , unit ) , completion , Collections . singleton ( topicName ) , null ) ; }
public void consumeDocuments ( String topicName , int count , long timeout , TimeUnit unit , Runnable completion , BiPredicate < String , Document > consumer ) { AtomicLong readCounter = new AtomicLong ( ) ; consumeDocuments ( continueIfNotExpired ( null , timeout , unit ) , completion , Collections . singleton ( topicName ) , null ) ; }
public Enumeration listOptions ( ) { Vector newVector = new Vector ( _NUM ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; return newVector . elements ( ) ; }
public Enumeration listOptions ( ) { Vector newVector = new Vector ( _NUM ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; return newVector . elements ( ) ; }
private Map readCurrentState ( String dn ) { try { return read ( AccessController . doPrivileged ( AdminTokenAction . getInstance ( ) ) , dn ) ; } catch ( SMSException | SSOException e ) { return null ; } }
private Map readCurrentState ( String dn ) { try { return read ( AccessController . doPrivileged ( AdminTokenAction . getInstance ( ) ) , dn ) ; } catch ( SMSException | SSOException e ) { return null ; } }
private Object timedGet ( long nanos ) throws TimeoutException { if ( Thread . interrupted ( ) ) return null ; if ( nanos > _NUM ) { long d = System . nanoTime ( ) + nanos ; long deadline = ( d == _NUM ) ? _NUM : d ; Signaller q = null ; boolean queued = _BOOL ; Object r ; while ( ( r = result ) == null ) { if ( q == null ) { q = new Signaller ( _BOOL , nanos , deadline ) ; if ( Thread . currentThread ( ) instanceof ForkJoinWorkerThread ) ForkJoinPool . helpAsyncBlocker ( defaultExecutor ( ) , q ) ; } else if ( ! queued ) queued = tryPushStack ( q ) ; else if ( q . nanos <= _NUM ) break ; else { try { ForkJoinPool . managedBlock ( q ) ; } catch ( InterruptedException ie ) { q . interrupted = _BOOL ; } if ( q . interrupted ) break ; } } if ( q != null && queued ) { q . thread = null ; if ( r == null ) cleanStack ( ) ; } if ( r != null || ( r = result ) != null ) postComplete ( ) ; if ( r != null || ( q != null && q . interrupted ) ) return r ; } throw new TimeoutException ( ) ; }
public void clearLocalSlots ( int start , int len ) { start += _currentFrameBottom ; System . arraycopy ( m_nulls , _NUM , _stackFrames , start , len ) ; }
public void clearLocalSlots ( int start , int len ) { start += _currentFrameBottom ; System . arraycopy ( m_nulls , _NUM , _stackFrames , start , len ) ; }
public void clearLocalSlots ( int start , int len ) { start += _currentFrameBottom ; System . arraycopy ( m_nulls , _NUM , _stackFrames , start , len ) ; }
public void testAccessAndModificationTimeUpwardsPropagation ( ) throws Exception { create ( igfsSecondary , paths ( DIR , SUBDIR ) , paths ( FILE , FILE2 ) ) ; T2 < Long , Long > timesDir0 = checkParentListingTime ( igfsSecondaryFileSystem , DIR ) ; T2 < Long , Long > timesSubDir0 = checkParentListingTime ( igfsSecondaryFileSystem , SUBDIR ) ; T2 < Long , Long > timesFile0 = checkParentListingTime ( igfsSecondaryFileSystem , FILE ) ; T2 < Long , Long > timesFile20 = checkParentListingTime ( igfsSecondaryFileSystem , FILE2 ) ; Thread . sleep ( _NUM ) ; T2 < Long , Long > timesDir1 = checkParentListingTime ( igfs . asSecondary ( ) , DIR ) ; T2 < Long , Long > timesSubDir1 = checkParentListingTime ( igfs . asSecondary ( ) , SUBDIR ) ; T2 < Long , Long > timesFile1 = checkParentListingTime ( igfs . asSecondary ( ) , FILE ) ; T2 < Long , Long > timesFile21 = checkParentListingTime ( igfs . asSecondary ( ) , FILE2 ) ; assertEquals ( timesDir0 , timesDir1 ) ; assertEquals ( timesSubDir0 , timesSubDir1 ) ; assertEquals ( timesFile0 , timesFile1 ) ; assertEquals ( timesFile20 , timesFile21 ) ; }
protected int drawLabelText ( int textDecoration , boolean rtl , boolean isTickerRunning , boolean endsWith3Points , Object nativeFont , int txtW , int textSpaceW , int shiftText , String text , int x , int y , int fontHeight ) { if ( ( ! isTickerRunning ) || rtl ) { if ( txtW > textSpaceW && textSpaceW > _NUM ) { if ( rtl ) { if ( ( ! isTickerRunning ) && endsWith3Points ) { String points = STRING ; int pointsW = impl . stringWidth ( nativeFont , points ) ; drawString ( nativeFont , points , shiftText + x , y , textDecoration , fontHeight ) ; clipRect ( pointsW + shiftText + x , y , textSpaceW - pointsW , fontHeight ) ; } x = x - txtW + textSpaceW ; } else if ( endsWith3Points ) { String points = STRING ; int index = _NUM ; int widest = impl . charWidth ( nativeFont , STRING ) ; int pointsW = impl . stringWidth ( nativeFont , points ) ; while ( fastCharWidthCheck ( text , index , textSpaceW - pointsW , widest , nativeFont ) && index < text . length ( ) ) { index ++ ; } text = text . substring ( _NUM , Math . min ( text . length ( ) , Math . max ( _NUM , index - _NUM ) ) ) + points ; txtW = impl . stringWidth ( nativeFont , text ) ; } } } drawString ( nativeFont , text , shiftText + x , y , textDecoration , fontHeight ) ; return Math . min ( txtW , textSpaceW ) ; }
@ POST @ Path ( STRING ) @ Produces ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ Consumes ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ CheckPermission ( roles = { Role . SECURITY_ADMIN , Role . RESTRICTED_SECURITY_ADMIN } , blockProxies = _BOOL ) public String rotateIPsecKey ( ) { ipsecMgr . verifyIPsecOpAllowable ( ) ; String version = ipsecMgr . rotateKey ( ) ; auditMgr . recordAuditLog ( null , null , IPSEC_SERVICE_TYPE , OperationTypeEnum . UPDATE_SYSTEM_PROPERTY , System . currentTimeMillis ( ) , AuditLogManager . AUDITLOG_SUCCESS , null , STRING + version ) ; return version ; }
@ POST @ Path ( STRING ) @ Produces ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ Consumes ( { MediaType . APPLICATION_XML , MediaType . APPLICATION_JSON } ) @ CheckPermission ( roles = { Role . SECURITY_ADMIN , Role . RESTRICTED_SECURITY_ADMIN } , blockProxies = _BOOL ) public String rotateIPsecKey ( ) { ipsecMgr . verifyIPsecOpAllowable ( ) ; String version = ipsecMgr . rotateKey ( ) ; auditMgr . recordAuditLog ( null , null , IPSEC_SERVICE_TYPE , OperationTypeEnum . UPDATE_SYSTEM_PROPERTY , System . currentTimeMillis ( ) , AuditLogManager . AUDITLOG_SUCCESS , null , STRING + version ) ; return version ; }
private void validateReference ( Element referentElement ) throws XMLSecurityException { if ( ! XMLUtils . elementIsInSignatureSpace ( referentElement , Constants . _TAG_KEYINFO ) ) { Object exArgs [ ] = { new QName ( referentElement . getNamespaceURI ( ) , referentElement . getLocalName ( ) ) } ; throw new XMLSecurityException ( STRING , exArgs ) ; } KeyInfo referent = new KeyInfo ( referentElement , STRING ) ; if ( referent . containsKeyInfoReference ( ) ) { if ( secureValidation ) { throw new XMLSecurityException ( STRING ) ; } else { throw new XMLSecurityException ( STRING ) ; } } }
public ContentImpl createCompoundPackageContent ( OleBlobImpl blob , String prettyName , String className , String typeName , ByteBuffer blobBb , int dataBlockLen ) { return new CompoundContentImpl ( blob , prettyName , className , typeName , blobBb . position ( ) , dataBlockLen ) ; }
public static boolean isBeforeToday ( Calendar _calendar ) { return _calendar . before ( Calendar . getInstance ( ) ) ; }
private void initializeFontMetrics ( Font font ) { final BufferedImage temporaryImage = new BufferedImage ( _NUM , _NUM , BufferedImage . TYPE_INT_RGB ) ; Graphics2D temporaryGraphics2D = ( Graphics2D ) temporaryImage . getGraphics ( ) ; temporaryGraphics2D . setFont ( font ) ; fontMetrics = temporaryGraphics2D . getFontMetrics ( ) ; fontCharWidth = fontMetrics . getMaxAdvance ( ) ; fontLineHeight = fontMetrics . getHeight ( ) ; }
private boolean announce ( String [ ] groups ) { if ( dataPackets == null || ! lastLocator . equals ( myLocator ) || ! Arrays . equals ( lastGroups , groups ) ) { List < DatagramPacket > packets = new ArrayList < DatagramPacket > ( ) ; Discovery disco ; try { disco = getDiscovery ( multicastAnnouncementConstraints . chooseProtocolVersion ( ) ) ; } catch ( DiscoveryProtocolException e ) { throw new AssertionError ( e ) ; } EncodeIterator ei = disco . encodeMulticastAnnouncement ( new MulticastAnnouncement ( announcementSeqNo ++ , myLocator . getHost ( ) , myLocator . getPort ( ) , groups , myServiceID ) , multicastAnnouncementConstraints . getMulticastMaxPacketSize ( DEFAULT_MAX_PACKET_SIZE ) , multicastAnnouncementConstraints . getUnfulfilledConstraints ( ) ) ; while ( ei . hasNext ( ) ) { try { packets . addAll ( Arrays . asList ( ei . next ( ) ) ) ; } catch ( Exception e ) { logger . log ( ( e instanceof UnsupportedConstraintException ) ? Levels . HANDLED : Level . INFO , STRING + STRING , e ) ; } } lastLocator = myLocator ; lastGroups = groups ; dataPackets = packets . toArray ( new DatagramPacket [ packets . size ( ) ] ) ; } try { send ( dataPackets ) ; } catch ( InterruptedIOException e ) { return _BOOL ; } return _BOOL ; }
private static synchronized String parseQuotedString ( String s ) throws UnsupportedEncodingException , CharacterCodingException { StringBuffer result = new StringBuffer ( ) ; StringCharacterIterator iterator = new StringCharacterIterator ( s ) ; char c = iterator . current ( ) ; while ( iterator . getIndex ( ) < iterator . getEndIndex ( ) ) { switch ( c ) { case STRING : { result . append ( parseEscapedSequence ( iterator ) ) ; break ; } default : { result . append ( c ) ; break ; } } c = iterator . next ( ) ; } return result . toString ( ) ; }
private static synchronized String parseQuotedString ( String s ) throws UnsupportedEncodingException , CharacterCodingException { StringBuffer result = new StringBuffer ( ) ; StringCharacterIterator iterator = new StringCharacterIterator ( s ) ; char c = iterator . current ( ) ; while ( iterator . getIndex ( ) < iterator . getEndIndex ( ) ) { switch ( c ) { case STRING : { result . append ( parseEscapedSequence ( iterator ) ) ; break ; } default : { result . append ( c ) ; break ; } } c = iterator . next ( ) ; } return result . toString ( ) ; }
private static synchronized String parseQuotedString ( String s ) throws UnsupportedEncodingException , CharacterCodingException { StringBuffer result = new StringBuffer ( ) ; StringCharacterIterator iterator = new StringCharacterIterator ( s ) ; char c = iterator . current ( ) ; while ( iterator . getIndex ( ) < iterator . getEndIndex ( ) ) { switch ( c ) { case STRING : { result . append ( parseEscapedSequence ( iterator ) ) ; break ; } default : { result . append ( c ) ; break ; } } c = iterator . next ( ) ; } return result . toString ( ) ; }
static boolean isPossibleFP ( String val ) { final int length = val . length ( ) ; for ( int i = _NUM ; i < length ; ++ i ) { char c = val . charAt ( i ) ; if ( ! ( c >= STRING && c <= STRING || c == STRING || c == STRING || c == STRING || c == STRING || c == STRING ) ) { return _BOOL ; } } return _BOOL ; }
@ Override public Point2D . Double translatePoint ( Point2D . Double p , TranslationDirection dir ) { Point2D . Double p0 = constrainPoint ( ( Point2D . Double ) p . clone ( ) ) ; switch ( dir ) { case NORTH : case NORTH_WEST : case NORTH_EAST : p . y = p0 . y - height ; break ; case SOUTH : case SOUTH_WEST : case SOUTH_EAST : p . y = p0 . y + height ; break ; } switch ( dir ) { case WEST : case NORTH_WEST : case SOUTH_WEST : p . x = p0 . x - width ; break ; case EAST : case NORTH_EAST : case SOUTH_EAST : p . x = p0 . x + width ; break ; } return p ; }
@ Override public Point2D . Double translatePoint ( Point2D . Double p , TranslationDirection dir ) { Point2D . Double p0 = constrainPoint ( ( Point2D . Double ) p . clone ( ) ) ; switch ( dir ) { case NORTH : case NORTH_WEST : case NORTH_EAST : p . y = p0 . y - height ; break ; case SOUTH : case SOUTH_WEST : case SOUTH_EAST : p . y = p0 . y + height ; break ; } switch ( dir ) { case WEST : case NORTH_WEST : case SOUTH_WEST : p . x = p0 . x - width ; break ; case EAST : case NORTH_EAST : case SOUTH_EAST : p . x = p0 . x + width ; break ; } return p ; }
@ Override public Point2D . Double translatePoint ( Point2D . Double p , TranslationDirection dir ) { Point2D . Double p0 = constrainPoint ( ( Point2D . Double ) p . clone ( ) ) ; switch ( dir ) { case NORTH : case NORTH_WEST : case NORTH_EAST : p . y = p0 . y - height ; break ; case SOUTH : case SOUTH_WEST : case SOUTH_EAST : p . y = p0 . y + height ; break ; } switch ( dir ) { case WEST : case NORTH_WEST : case SOUTH_WEST : p . x = p0 . x - width ; break ; case EAST : case NORTH_EAST : case SOUTH_EAST : p . x = p0 . x + width ; break ; } return p ; }
private static CreateVmResponse checkCreateVmResponse ( CreateVmResponse createVmResponse ) throws RpcException { logger . info ( STRING , createVmResponse ) ; switch ( createVmResponse . getResult ( ) ) { case OK : break ; case DISK_NOT_FOUND : throw new DiskNotFoundException ( createVmResponse . getError ( ) ) ; case IMAGE_NOT_FOUND : throw new ImageNotFoundException ( createVmResponse . getError ( ) ) ; case INVALID_RESERVATION : throw new InvalidReservationException ( createVmResponse . getError ( ) ) ; case NETWORK_NOT_FOUND : throw new NetworkNotFoundException ( createVmResponse . getError ( ) ) ; case SYSTEM_ERROR : throw new SystemErrorException ( createVmResponse . getError ( ) ) ; default : throw new RpcException ( String . format ( STRING , createVmResponse . getResult ( ) ) ) ; } return createVmResponse ; }
private void recordLogData ( ) { try { int size = mRecordingData . size ( ) ; if ( size == _NUM ) { return ; } Vector < String > recordingData = new Vector < > ( mRecordingData ) ; File logDir = Constants . getRecordDir ( this ) ; logDir . mkdirs ( ) ; File logFile = new File ( logDir , mRecordingFilename ) ; FileWriter logFileWriter = new FileWriter ( logFile , _BOOL ) ; for ( int i = _NUM ; i < size ; i ++ ) { logFileWriter . append ( recordingData . elementAt ( i ) + STRING ) ; mRecordingData . removeElementAt ( _NUM ) ; } recordingData . removeAllElements ( ) ; logFileWriter . close ( ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , STRING + e . toString ( ) ) ; } }
@ Override public void createConnectionFactory ( String name , boolean ha , boolean useDiscovery , int cfType , String connectors , String bindings ) throws Exception { createConnectionFactory ( name , ha , useDiscovery , cfType , toArray ( connectors ) , toArray ( bindings ) ) ; }
public boolean isDirectlyControlDependentOn ( BasicBlock insBlock , Branch b ) { Set < ControlFlowEdge > incomming = incomingEdgesOf ( insBlock ) ; if ( incomming . size ( ) == _NUM ) { for ( ControlFlowEdge e : incomming ) { if ( ! e . hasControlDependency ( ) && ! e . isExceptionEdge ( ) ) { return isDirectlyControlDependentOn ( getEdgeSource ( e ) , b ) ; } } } boolean isRootDependent = isRootDependent ( insBlock ) ; if ( b == null ) return isRootDependent ; if ( isRootDependent && b != null ) return _BOOL ; for ( ControlFlowEdge e : incomming ) { Branch current = e . getBranchInstruction ( ) ; if ( e . isExceptionEdge ( ) ) { if ( current != null ) throw new IllegalStateException ( STRING ) ; else continue ; } if ( current == null ) continue ; if ( current . equals ( b ) ) return _BOOL ; } return _BOOL ; }
public boolean isDirectlyControlDependentOn ( BasicBlock insBlock , Branch b ) { Set < ControlFlowEdge > incomming = incomingEdgesOf ( insBlock ) ; if ( incomming . size ( ) == _NUM ) { for ( ControlFlowEdge e : incomming ) { if ( ! e . hasControlDependency ( ) && ! e . isExceptionEdge ( ) ) { return isDirectlyControlDependentOn ( getEdgeSource ( e ) , b ) ; } } } boolean isRootDependent = isRootDependent ( insBlock ) ; if ( b == null ) return isRootDependent ; if ( isRootDependent && b != null ) return _BOOL ; for ( ControlFlowEdge e : incomming ) { Branch current = e . getBranchInstruction ( ) ; if ( e . isExceptionEdge ( ) ) { if ( current != null ) throw new IllegalStateException ( STRING ) ; else continue ; } if ( current == null ) continue ; if ( current . equals ( b ) ) return _BOOL ; } return _BOOL ; }
public boolean isDirectlyControlDependentOn ( BasicBlock insBlock , Branch b ) { Set < ControlFlowEdge > incomming = incomingEdgesOf ( insBlock ) ; if ( incomming . size ( ) == _NUM ) { for ( ControlFlowEdge e : incomming ) { if ( ! e . hasControlDependency ( ) && ! e . isExceptionEdge ( ) ) { return isDirectlyControlDependentOn ( getEdgeSource ( e ) , b ) ; } } } boolean isRootDependent = isRootDependent ( insBlock ) ; if ( b == null ) return isRootDependent ; if ( isRootDependent && b != null ) return _BOOL ; for ( ControlFlowEdge e : incomming ) { Branch current = e . getBranchInstruction ( ) ; if ( e . isExceptionEdge ( ) ) { if ( current != null ) throw new IllegalStateException ( STRING ) ; else continue ; } if ( current == null ) continue ; if ( current . equals ( b ) ) return _BOOL ; } return _BOOL ; }
public boolean isDirectlyControlDependentOn ( BasicBlock insBlock , Branch b ) { Set < ControlFlowEdge > incomming = incomingEdgesOf ( insBlock ) ; if ( incomming . size ( ) == _NUM ) { for ( ControlFlowEdge e : incomming ) { if ( ! e . hasControlDependency ( ) && ! e . isExceptionEdge ( ) ) { return isDirectlyControlDependentOn ( getEdgeSource ( e ) , b ) ; } } } boolean isRootDependent = isRootDependent ( insBlock ) ; if ( b == null ) return isRootDependent ; if ( isRootDependent && b != null ) return _BOOL ; for ( ControlFlowEdge e : incomming ) { Branch current = e . getBranchInstruction ( ) ; if ( e . isExceptionEdge ( ) ) { if ( current != null ) throw new IllegalStateException ( STRING ) ; else continue ; } if ( current == null ) continue ; if ( current . equals ( b ) ) return _BOOL ; } return _BOOL ; }
public void renameAttribute ( Attribute att , String name ) { renameAttribute ( att . index ( ) , name ) ; }
public void renameAttribute ( Attribute att , String name ) { renameAttribute ( att . index ( ) , name ) ; }
private void splitBulkRequest ( SnmpPduBulk req , int nonRepeaters , int maxRepetitions , int R ) { for ( Enumeration < SnmpMibAgent > e = mibs . elements ( ) ; e . hasMoreElements ( ) ; ) { final SnmpMibAgent agent = e . nextElement ( ) ; if ( SNMP_ADAPTOR_LOGGER . isLoggable ( Level . FINER ) ) { SNMP_ADAPTOR_LOGGER . logp ( Level . FINER , dbgTag , STRING , STRING + agent + STRING + nonRepeaters + STRING + maxRepetitions + STRING + R ) ; } subs . put ( agent , new SnmpSubBulkRequestHandler ( adaptor , agent , req , nonRepeaters , maxRepetitions , R ) ) ; } }
private void splitBulkRequest ( SnmpPduBulk req , int nonRepeaters , int maxRepetitions , int R ) { for ( Enumeration < SnmpMibAgent > e = mibs . elements ( ) ; e . hasMoreElements ( ) ; ) { final SnmpMibAgent agent = e . nextElement ( ) ; if ( SNMP_ADAPTOR_LOGGER . isLoggable ( Level . FINER ) ) { SNMP_ADAPTOR_LOGGER . logp ( Level . FINER , dbgTag , STRING , STRING + agent + STRING + nonRepeaters + STRING + maxRepetitions + STRING + R ) ; } subs . put ( agent , new SnmpSubBulkRequestHandler ( adaptor , agent , req , nonRepeaters , maxRepetitions , R ) ) ; } }
private void splitBulkRequest ( SnmpPduBulk req , int nonRepeaters , int maxRepetitions , int R ) { for ( Enumeration < SnmpMibAgent > e = mibs . elements ( ) ; e . hasMoreElements ( ) ; ) { final SnmpMibAgent agent = e . nextElement ( ) ; if ( SNMP_ADAPTOR_LOGGER . isLoggable ( Level . FINER ) ) { SNMP_ADAPTOR_LOGGER . logp ( Level . FINER , dbgTag , STRING , STRING + agent + STRING + nonRepeaters + STRING + maxRepetitions + STRING + R ) ; } subs . put ( agent , new SnmpSubBulkRequestHandler ( adaptor , agent , req , nonRepeaters , maxRepetitions , R ) ) ; } }
private void onCacheDataChanged ( ) { if ( mCacheDataList . size ( ) >= _NUM ) { mIconStatus = ICON_SHOW_DROP_DOWN ; } else { mIconStatus = ICON_ABSENT ; } }
public boolean isQueryRunning ( final BoundEntity song ) { synchronized ( mRunningQueries ) { return mRunningQueries . contains ( song ) ; } }
private void fireProcessViewChanged ( ) { for ( ExtendedProcessEditor editor : processEditors . getListeners ( ExtendedProcessEditor . class ) ) { editor . processViewChanged ( process ) ; } }
private void fireProcessViewChanged ( ) { for ( ExtendedProcessEditor editor : processEditors . getListeners ( ExtendedProcessEditor . class ) ) { editor . processViewChanged ( process ) ; } }
public boolean isCustomViewShowing ( ) { return mCustomView != null ; }
public boolean isCustomViewShowing ( ) { return mCustomView != null ; }
public boolean isCustomViewShowing ( ) { return mCustomView != null ; }
private static Map < String , Boolean > readProperties ( Properties props , String keyPrefix ) { Map < String , Boolean > filters = new TreeMap < String , Boolean > ( ) ; int counter = _NUM ; boolean keyFound = _BOOL ; while ( keyFound ) { String property = props . getProperty ( keyPrefix + counter ) ; if ( property != null ) { int pipePos = property . indexOf ( BOOL_SEPARATOR ) ; if ( pipePos >= _NUM ) { String name = property . substring ( _NUM , pipePos ) ; String enabled = property . substring ( pipePos + _NUM ) ; filters . put ( name , Boolean . valueOf ( enabled ) ) ; } else { filters . put ( property , Boolean . TRUE ) ; } counter ++ ; } else { keyFound = _BOOL ; } } return filters ; }
public void testWriteReadEmpty ( ) throws Exception { ByteArrayOutputStream out = new ByteArrayOutputStream ( _NUM ) ; ObjectOutputStream os = new ObjectOutputStream ( out ) ; os . writeObject ( empty ) ; ObjectInputStream is = new ObjectInputStream ( new ByteArrayInputStream ( out . toByteArray ( ) ) ) ; ReplicationPolicy copy = ( ReplicationPolicy ) is . readObject ( ) ; is . close ( ) ; os . close ( ) ; assertTrue ( helper . areEquals ( empty , copy ) ) ; }
public static final void frontEndStatistics ( SpecObj spec ) { }
private static void format ( StringBuffer target , int scale , long intP , long decP ) { if ( decP != _NUM ) { decP += _NUM ; decP /= _NUM ; if ( decP >= tenPowDouble ( scale ) ) { intP ++ ; decP -= tenPow ( scale ) ; } if ( decP != _NUM ) { while ( decP % _NUM == _NUM ) { decP = decP / _NUM ; scale -- ; } } } target . append ( intP ) ; if ( decP != _NUM ) { target . append ( STRING ) ; while ( scale > _NUM && ( scale > _NUM ? decP < tenPowDouble ( -- scale ) : decP < tenPow ( -- scale ) ) ) { target . append ( STRING ) ; } target . append ( decP ) ; } }
private static void format ( StringBuffer target , int scale , long intP , long decP ) { if ( decP != _NUM ) { decP += _NUM ; decP /= _NUM ; if ( decP >= tenPowDouble ( scale ) ) { intP ++ ; decP -= tenPow ( scale ) ; } if ( decP != _NUM ) { while ( decP % _NUM == _NUM ) { decP = decP / _NUM ; scale -- ; } } } target . append ( intP ) ; if ( decP != _NUM ) { target . append ( STRING ) ; while ( scale > _NUM && ( scale > _NUM ? decP < tenPowDouble ( -- scale ) : decP < tenPow ( -- scale ) ) ) { target . append ( STRING ) ; } target . append ( decP ) ; } }
private void highLightMarker ( int index ) { highLightMarker ( markers . get ( index ) ) ; }
@ Override public void onValueSelected ( int pickerIndex , int newValue , boolean autoAdvance ) { if ( pickerIndex == HOUR_INDEX ) { setHour ( newValue , _BOOL ) ; String announcement = String . format ( STRING , newValue ) ; if ( mAllowAutoAdvance && autoAdvance ) { setCurrentItemShowing ( MINUTE_INDEX , _BOOL , _BOOL , _BOOL ) ; announcement += STRING + mSelectMinutes ; } else { mTimePicker . setContentDescription ( mHourPickerDescription + STRING + newValue ) ; } Utils . tryAccessibilityAnnounce ( mTimePicker , announcement ) ; } else if ( pickerIndex == MINUTE_INDEX ) { setMinute ( newValue ) ; mTimePicker . setContentDescription ( mMinutePickerDescription + STRING + newValue ) ; } else if ( pickerIndex == AMPM_INDEX ) { updateAmPmDisplay ( newValue ) ; } else if ( pickerIndex == ENABLE_PICKER_INDEX ) { if ( ! isTypedTimeFullyLegal ( ) ) { mTypedTimes . clear ( ) ; } finishKbMode ( _BOOL ) ; } }
@ HLEFunction ( nid = _NUM , version = _NUM ) public int sceNetResolverStartAtoN ( @ CheckArgument ( STRING ) int rid , int addr , TPointer hostnameAddr , int hostnameLength , int timeout , int retry ) { try { byte [ ] bytes = sceNetInet . internetAddressToBytes ( addr ) ; InetAddress inetAddress = InetAddress . getByAddress ( bytes ) ; String hostName = inetAddress . getHostName ( ) ; hostnameAddr . setStringNZ ( hostnameLength , hostName ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( String . format ( STRING , hostName ) ) ; } } catch ( UnknownHostException e ) { log . error ( e ) ; return SceKernelErrors . ERROR_NET_RESOLVER_INVALID_HOST ; } return _NUM ; }
public static < T > FutureW < T > ofSupplier ( final Supplier < T > s , final Executor ex ) { return FutureW . of ( CompletableFuture . supplyAsync ( s , ex ) ) ; }
public static < T > FutureW < T > ofSupplier ( final Supplier < T > s , final Executor ex ) { return FutureW . of ( CompletableFuture . supplyAsync ( s , ex ) ) ; }
public static < T > FutureW < T > ofSupplier ( final Supplier < T > s , final Executor ex ) { return FutureW . of ( CompletableFuture . supplyAsync ( s , ex ) ) ; }
@ Override public void write ( char c [ ] , int off , int len ) { if ( ( off < _NUM ) || ( off > c . length ) || ( len < _NUM ) || ( ( off + len ) > c . length ) || ( ( off + len ) < _NUM ) ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len == _NUM ) { return ; } int newcount = count + len ; if ( newcount > buf . length ) { buf = Arrays . copyOf ( buf , Math . max ( buf . length << _NUM , newcount ) ) ; } System . arraycopy ( c , off , buf , count , len ) ; count = newcount ; }
private LinkedHashMap < Term , Integer > repeatingTerms ( ) { LinkedHashMap < Term , Integer > tord = new LinkedHashMap < > ( ) ; HashMap < Term , Integer > tcnt = new HashMap < > ( ) ; for ( PhrasePositions pp : phrasePositions ) { for ( Term t : pp . terms ) { Integer cnt0 = tcnt . get ( t ) ; Integer cnt = cnt0 == null ? new Integer ( _NUM ) : new Integer ( _NUM + cnt0 . intValue ( ) ) ; tcnt . put ( t , cnt ) ; if ( cnt == _NUM ) { tord . put ( t , tord . size ( ) ) ; } } } return tord ; }
private LinkedHashMap < Term , Integer > repeatingTerms ( ) { LinkedHashMap < Term , Integer > tord = new LinkedHashMap < > ( ) ; HashMap < Term , Integer > tcnt = new HashMap < > ( ) ; for ( PhrasePositions pp : phrasePositions ) { for ( Term t : pp . terms ) { Integer cnt0 = tcnt . get ( t ) ; Integer cnt = cnt0 == null ? new Integer ( _NUM ) : new Integer ( _NUM + cnt0 . intValue ( ) ) ; tcnt . put ( t , cnt ) ; if ( cnt == _NUM ) { tord . put ( t , tord . size ( ) ) ; } } } return tord ; }
public static synchronized void moveLogsFromLegacyDirIfNecessary ( ) { File sdcardDir = Environment . getExternalStorageDirectory ( ) ; File legacyDir = new File ( sdcardDir , LEGACY_SAVED_LOGS_DIR ) ; if ( legacyDir . exists ( ) && legacyDir . isDirectory ( ) ) { File savedLogsDir = getSavedLogsDirectory ( ) ; for ( File file : legacyDir . listFiles ( ) ) { file . renameTo ( new File ( savedLogsDir , file . getName ( ) ) ) ; } legacyDir . delete ( ) ; } }
public static synchronized void moveLogsFromLegacyDirIfNecessary ( ) { File sdcardDir = Environment . getExternalStorageDirectory ( ) ; File legacyDir = new File ( sdcardDir , LEGACY_SAVED_LOGS_DIR ) ; if ( legacyDir . exists ( ) && legacyDir . isDirectory ( ) ) { File savedLogsDir = getSavedLogsDirectory ( ) ; for ( File file : legacyDir . listFiles ( ) ) { file . renameTo ( new File ( savedLogsDir , file . getName ( ) ) ) ; } legacyDir . delete ( ) ; } }
public static synchronized void moveLogsFromLegacyDirIfNecessary ( ) { File sdcardDir = Environment . getExternalStorageDirectory ( ) ; File legacyDir = new File ( sdcardDir , LEGACY_SAVED_LOGS_DIR ) ; if ( legacyDir . exists ( ) && legacyDir . isDirectory ( ) ) { File savedLogsDir = getSavedLogsDirectory ( ) ; for ( File file : legacyDir . listFiles ( ) ) { file . renameTo ( new File ( savedLogsDir , file . getName ( ) ) ) ; } legacyDir . delete ( ) ; } }
public static synchronized void moveLogsFromLegacyDirIfNecessary ( ) { File sdcardDir = Environment . getExternalStorageDirectory ( ) ; File legacyDir = new File ( sdcardDir , LEGACY_SAVED_LOGS_DIR ) ; if ( legacyDir . exists ( ) && legacyDir . isDirectory ( ) ) { File savedLogsDir = getSavedLogsDirectory ( ) ; for ( File file : legacyDir . listFiles ( ) ) { file . renameTo ( new File ( savedLogsDir , file . getName ( ) ) ) ; } legacyDir . delete ( ) ; } }
public static synchronized void moveLogsFromLegacyDirIfNecessary ( ) { File sdcardDir = Environment . getExternalStorageDirectory ( ) ; File legacyDir = new File ( sdcardDir , LEGACY_SAVED_LOGS_DIR ) ; if ( legacyDir . exists ( ) && legacyDir . isDirectory ( ) ) { File savedLogsDir = getSavedLogsDirectory ( ) ; for ( File file : legacyDir . listFiles ( ) ) { file . renameTo ( new File ( savedLogsDir , file . getName ( ) ) ) ; } legacyDir . delete ( ) ; } }
public boolean contains ( T dataSet ) { for ( int i = _NUM ; i < mDataSets . size ( ) ; i ++ ) { T set = mDataSets . get ( i ) ; if ( set . equals ( dataSet ) ) { return _BOOL ; } } return _BOOL ; }
public boolean contains ( T dataSet ) { for ( int i = _NUM ; i < mDataSets . size ( ) ; i ++ ) { T set = mDataSets . get ( i ) ; if ( set . equals ( dataSet ) ) { return _BOOL ; } } return _BOOL ; }
private void reorderSpinners ( ) { mSpinners . removeAllViews ( ) ; char [ ] order = DateFormat . getDateFormatOrder ( mContext ) ; final int spinnerCount = order . length ; for ( int i = _NUM ; i < spinnerCount ; i ++ ) { switch ( order [ i ] ) { case STRING : mSpinners . addView ( mDaySpinner ) ; setImeOptions ( mDaySpinner , spinnerCount , i ) ; break ; case STRING : mSpinners . addView ( mMonthSpinner ) ; setImeOptions ( mMonthSpinner , spinnerCount , i ) ; break ; case STRING : mSpinners . addView ( mYearSpinner ) ; setImeOptions ( mYearSpinner , spinnerCount , i ) ; break ; default : throw new IllegalArgumentException ( Arrays . toString ( order ) ) ; } } }
public File tmpDir ( ) { String random = String . valueOf ( RANDOM . nextLong ( ) ) ; File dir = tmpFile ( STRING + random ) ; assureDirExists ( dir ) ; return dir ; }
public File tmpDir ( ) { String random = String . valueOf ( RANDOM . nextLong ( ) ) ; File dir = tmpFile ( STRING + random ) ; assureDirExists ( dir ) ; return dir ; }
public File tmpDir ( ) { String random = String . valueOf ( RANDOM . nextLong ( ) ) ; File dir = tmpFile ( STRING + random ) ; assureDirExists ( dir ) ; return dir ; }
public File tmpDir ( ) { String random = String . valueOf ( RANDOM . nextLong ( ) ) ; File dir = tmpFile ( STRING + random ) ; assureDirExists ( dir ) ; return dir ; }
@ RpcMethod public void detachISO ( String vmId , boolean isDeleteFile , AsyncMethodCallback < Host . AsyncClient . detach_iso_call > handler ) throws RpcException { ensureClient ( ) ; DetachISORequest detachISORequest = new DetachISORequest ( vmId ) ; detachISORequest . setDelete_file ( isDeleteFile ) ; clientProxy . setTimeout ( DETACH_ISO_TIMEOUT_MS ) ; logger . info ( STRING , vmId , getHostIp ( ) , detachISORequest ) ; try { clientProxy . detach_iso ( detachISORequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
@ RpcMethod public void detachISO ( String vmId , boolean isDeleteFile , AsyncMethodCallback < Host . AsyncClient . detach_iso_call > handler ) throws RpcException { ensureClient ( ) ; DetachISORequest detachISORequest = new DetachISORequest ( vmId ) ; detachISORequest . setDelete_file ( isDeleteFile ) ; clientProxy . setTimeout ( DETACH_ISO_TIMEOUT_MS ) ; logger . info ( STRING , vmId , getHostIp ( ) , detachISORequest ) ; try { clientProxy . detach_iso ( detachISORequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
public int write ( final Protein protein , final boolean standalone ) throws IOException { checkEntryHierarchy ( ) ; if ( entryHierarchy != null ) { for ( ProteinXref xref : protein . getCrossReferences ( ) ) { final SimpleProtein simpleProtein = SimpleProtein . valueOf ( protein , xref , entryHierarchy ) ; if ( simpleProtein != null ) { final SimpleHash model = buildModelMap ( simpleProtein , entryHierarchy , standalone ) ; Writer writer = null ; try { final Template temp = freeMarkerConfig . getTemplate ( freeMarkerTemplate ) ; checkTempDirectory ( tempDirectory ) ; if ( ! tempDirectory . endsWith ( File . separator ) ) { tempDirectory = tempDirectory + File . separator ; } UrlFriendlyIdGenerator gen = UrlFriendlyIdGenerator . getInstance ( ) ; String urlFriendlyId = gen . generate ( xref . getIdentifier ( ) ) ; final Path newResultFile = Paths . get ( tempDirectory + urlFriendlyId + STRING ) ; resultFiles . add ( newResultFile ) ; writer = Files . newBufferedWriter ( newResultFile , characterSet ) ; temp . process ( model , writer ) ; writer . flush ( ) ; } catch ( TemplateException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } } } } return _NUM ; }
@ SuppressWarnings ( STRING ) private < T > T allowStaticAccessToMember ( T member , boolean staticOnly ) { if ( member == null ) return null ; if ( ! staticOnly ) return member ; boolean isStatic ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; isStatic = Modifier . isStatic ( v . getModifiers ( ) ) ; } else if ( member instanceof List ) { List < MethodNode > list = ( List < MethodNode > ) member ; if ( list . size ( ) == _NUM ) { return ( T ) Collections . singletonList ( allowStaticAccessToMember ( list . get ( _NUM ) , staticOnly ) ) ; } return ( T ) Collections . emptyList ( ) ; } else { MethodNode mn = ( MethodNode ) member ; isStatic = mn . isStatic ( ) ; } if ( staticOnly && ! isStatic ) return null ; return member ; }
@ SuppressWarnings ( STRING ) private < T > T allowStaticAccessToMember ( T member , boolean staticOnly ) { if ( member == null ) return null ; if ( ! staticOnly ) return member ; boolean isStatic ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; isStatic = Modifier . isStatic ( v . getModifiers ( ) ) ; } else if ( member instanceof List ) { List < MethodNode > list = ( List < MethodNode > ) member ; if ( list . size ( ) == _NUM ) { return ( T ) Collections . singletonList ( allowStaticAccessToMember ( list . get ( _NUM ) , staticOnly ) ) ; } return ( T ) Collections . emptyList ( ) ; } else { MethodNode mn = ( MethodNode ) member ; isStatic = mn . isStatic ( ) ; } if ( staticOnly && ! isStatic ) return null ; return member ; }
@ SuppressWarnings ( STRING ) private < T > T allowStaticAccessToMember ( T member , boolean staticOnly ) { if ( member == null ) return null ; if ( ! staticOnly ) return member ; boolean isStatic ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; isStatic = Modifier . isStatic ( v . getModifiers ( ) ) ; } else if ( member instanceof List ) { List < MethodNode > list = ( List < MethodNode > ) member ; if ( list . size ( ) == _NUM ) { return ( T ) Collections . singletonList ( allowStaticAccessToMember ( list . get ( _NUM ) , staticOnly ) ) ; } return ( T ) Collections . emptyList ( ) ; } else { MethodNode mn = ( MethodNode ) member ; isStatic = mn . isStatic ( ) ; } if ( staticOnly && ! isStatic ) return null ; return member ; }
@ SuppressWarnings ( STRING ) private < T > T allowStaticAccessToMember ( T member , boolean staticOnly ) { if ( member == null ) return null ; if ( ! staticOnly ) return member ; boolean isStatic ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; isStatic = Modifier . isStatic ( v . getModifiers ( ) ) ; } else if ( member instanceof List ) { List < MethodNode > list = ( List < MethodNode > ) member ; if ( list . size ( ) == _NUM ) { return ( T ) Collections . singletonList ( allowStaticAccessToMember ( list . get ( _NUM ) , staticOnly ) ) ; } return ( T ) Collections . emptyList ( ) ; } else { MethodNode mn = ( MethodNode ) member ; isStatic = mn . isStatic ( ) ; } if ( staticOnly && ! isStatic ) return null ; return member ; }
@ SuppressWarnings ( STRING ) private < T > T allowStaticAccessToMember ( T member , boolean staticOnly ) { if ( member == null ) return null ; if ( ! staticOnly ) return member ; boolean isStatic ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; isStatic = Modifier . isStatic ( v . getModifiers ( ) ) ; } else if ( member instanceof List ) { List < MethodNode > list = ( List < MethodNode > ) member ; if ( list . size ( ) == _NUM ) { return ( T ) Collections . singletonList ( allowStaticAccessToMember ( list . get ( _NUM ) , staticOnly ) ) ; } return ( T ) Collections . emptyList ( ) ; } else { MethodNode mn = ( MethodNode ) member ; isStatic = mn . isStatic ( ) ; } if ( staticOnly && ! isStatic ) return null ; return member ; }
@ SuppressWarnings ( STRING ) private < T > T allowStaticAccessToMember ( T member , boolean staticOnly ) { if ( member == null ) return null ; if ( ! staticOnly ) return member ; boolean isStatic ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; isStatic = Modifier . isStatic ( v . getModifiers ( ) ) ; } else if ( member instanceof List ) { List < MethodNode > list = ( List < MethodNode > ) member ; if ( list . size ( ) == _NUM ) { return ( T ) Collections . singletonList ( allowStaticAccessToMember ( list . get ( _NUM ) , staticOnly ) ) ; } return ( T ) Collections . emptyList ( ) ; } else { MethodNode mn = ( MethodNode ) member ; isStatic = mn . isStatic ( ) ; } if ( staticOnly && ! isStatic ) return null ; return member ; }
@ SuppressWarnings ( STRING ) private < T > T allowStaticAccessToMember ( T member , boolean staticOnly ) { if ( member == null ) return null ; if ( ! staticOnly ) return member ; boolean isStatic ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; isStatic = Modifier . isStatic ( v . getModifiers ( ) ) ; } else if ( member instanceof List ) { List < MethodNode > list = ( List < MethodNode > ) member ; if ( list . size ( ) == _NUM ) { return ( T ) Collections . singletonList ( allowStaticAccessToMember ( list . get ( _NUM ) , staticOnly ) ) ; } return ( T ) Collections . emptyList ( ) ; } else { MethodNode mn = ( MethodNode ) member ; isStatic = mn . isStatic ( ) ; } if ( staticOnly && ! isStatic ) return null ; return member ; }
@ SuppressWarnings ( STRING ) private < T > T allowStaticAccessToMember ( T member , boolean staticOnly ) { if ( member == null ) return null ; if ( ! staticOnly ) return member ; boolean isStatic ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; isStatic = Modifier . isStatic ( v . getModifiers ( ) ) ; } else if ( member instanceof List ) { List < MethodNode > list = ( List < MethodNode > ) member ; if ( list . size ( ) == _NUM ) { return ( T ) Collections . singletonList ( allowStaticAccessToMember ( list . get ( _NUM ) , staticOnly ) ) ; } return ( T ) Collections . emptyList ( ) ; } else { MethodNode mn = ( MethodNode ) member ; isStatic = mn . isStatic ( ) ; } if ( staticOnly && ! isStatic ) return null ; return member ; }
public boolean contains ( DataSource source ) { return data . contains ( source ) ; }
public static AttribKey forAttribute ( Namespaces inScope , ElKey el , String qname ) { Namespaces ns ; String localName ; int colon = qname . indexOf ( STRING ) ; if ( colon < _NUM ) { ns = el . ns ; localName = qname ; } else { ns = inScope . forAttrName ( el . ns , qname ) ; if ( ns == null ) { return null ; } ns = inScope . forUri ( ns . uri ) ; localName = qname . substring ( colon + _NUM ) ; } return new AttribKey ( el , ns , localName ) ; }
public static AttribKey forAttribute ( Namespaces inScope , ElKey el , String qname ) { Namespaces ns ; String localName ; int colon = qname . indexOf ( STRING ) ; if ( colon < _NUM ) { ns = el . ns ; localName = qname ; } else { ns = inScope . forAttrName ( el . ns , qname ) ; if ( ns == null ) { return null ; } ns = inScope . forUri ( ns . uri ) ; localName = qname . substring ( colon + _NUM ) ; } return new AttribKey ( el , ns , localName ) ; }
public int writeToMessage ( byte [ ] byteArray ) { return writeToMessage ( byteArray , _NUM , byteArray . length ) ; }
public int writeToMessage ( byte [ ] byteArray ) { return writeToMessage ( byteArray , _NUM , byteArray . length ) ; }
public static MethExecutorResult executeInstance ( String receiver , String selector ) { try { Class receiverClass = Class . forName ( receiver ) ; Object target = receiverClass . newInstance ( ) ; Object res = null ; try { Method theMethod = getMethod ( receiverClass , selector , new Class [ _NUM ] ) ; res = theMethod . invoke ( target , new Object [ _NUM ] ) ; return new MethExecutorResult ( res ) ; } catch ( InvocationTargetException invTargEx ) { Throwable targEx = invTargEx . getTargetException ( ) ; if ( targEx == null ) { return new MethExecutorResult ( res ) ; } else { return new MethExecutorResult ( targEx ) ; } } } catch ( VirtualMachineError e ) { SystemFailure . initiateFailure ( e ) ; throw e ; } catch ( Throwable t ) { return new MethExecutorResult ( t ) ; } }
public static MethExecutorResult executeInstance ( String receiver , String selector ) { try { Class receiverClass = Class . forName ( receiver ) ; Object target = receiverClass . newInstance ( ) ; Object res = null ; try { Method theMethod = getMethod ( receiverClass , selector , new Class [ _NUM ] ) ; res = theMethod . invoke ( target , new Object [ _NUM ] ) ; return new MethExecutorResult ( res ) ; } catch ( InvocationTargetException invTargEx ) { Throwable targEx = invTargEx . getTargetException ( ) ; if ( targEx == null ) { return new MethExecutorResult ( res ) ; } else { return new MethExecutorResult ( targEx ) ; } } } catch ( VirtualMachineError e ) { SystemFailure . initiateFailure ( e ) ; throw e ; } catch ( Throwable t ) { return new MethExecutorResult ( t ) ; } }
protected Rect updateFastScrollerBounds ( FastScrollRecyclerView rv , int lastTouchY ) { invalidateRect . set ( backgroundBounds ) ; if ( isVisible ( ) ) { int edgePadding = rv . getMaxScrollbarWidth ( ) ; int bgPadding = ( originalBackgroundSize - textBounds . height ( ) ) / _NUM ; int bgHeight = originalBackgroundSize ; int bgWidth = Math . max ( originalBackgroundSize , textBounds . width ( ) + ( _NUM * bgPadding ) ) ; if ( Utilities . isRtl ( resources ) ) { backgroundBounds . left = rv . getBackgroundPadding ( ) . left + ( _NUM * rv . getMaxScrollbarWidth ( ) ) ; backgroundBounds . right = backgroundBounds . left + bgWidth ; } else { backgroundBounds . right = rv . getWidth ( ) - rv . getBackgroundPadding ( ) . right - ( _NUM * rv . getMaxScrollbarWidth ( ) ) ; backgroundBounds . left = backgroundBounds . right - bgWidth ; } backgroundBounds . top = lastTouchY - ( int ) ( FAST_SCROLL_OVERLAY_Y_OFFSET_FACTOR * bgHeight ) ; backgroundBounds . top = Math . max ( edgePadding , Math . min ( backgroundBounds . top , rv . getHeight ( ) - edgePadding - bgHeight ) ) ; backgroundBounds . bottom = backgroundBounds . top + bgHeight ; } else { backgroundBounds . setEmpty ( ) ; } invalidateRect . union ( backgroundBounds ) ; return invalidateRect ; }
private void changeColumnsType ( List < ColumnModel > columnModelList ) { LogUtil . d ( TAG , STRING ) ; List < String > columnNames = new ArrayList < String > ( ) ; if ( columnModelList != null && ! columnModelList . isEmpty ( ) ) { for ( ColumnModel columnModel : columnModelList ) { columnNames . add ( columnModel . getColumnName ( ) ) ; } } removeColumns ( columnNames ) ; addColumns ( columnModelList ) ; }
private void changeColumnsType ( List < ColumnModel > columnModelList ) { LogUtil . d ( TAG , STRING ) ; List < String > columnNames = new ArrayList < String > ( ) ; if ( columnModelList != null && ! columnModelList . isEmpty ( ) ) { for ( ColumnModel columnModel : columnModelList ) { columnNames . add ( columnModel . getColumnName ( ) ) ; } } removeColumns ( columnNames ) ; addColumns ( columnModelList ) ; }
public static void sort ( byte [ ] a ) { doSort ( a , _NUM , a . length - _NUM ) ; }
public static List < Interval > sliceIntervals ( Interval interval , TimeGrain timeGrain ) { DateTime intervalEnd = interval . getEnd ( ) ; DateTime sliceStart = interval . getStart ( ) ; DateTime periodStart = timeGrain . roundFloor ( sliceStart ) ; if ( ! sliceStart . equals ( periodStart ) ) { LOG . info ( STRING , interval , timeGrain , periodStart ) ; throw new IllegalArgumentException ( STRING + periodStart ) ; } List < Interval > intervalSlices = new ArrayList < > ( ) ; while ( sliceStart . isBefore ( intervalEnd ) ) { DateTime sliceEnd = DateTimeUtils . addTimeGrain ( sliceStart , timeGrain ) ; Interval slicedInterval = new Interval ( sliceStart , sliceEnd ) ; if ( ! interval . contains ( slicedInterval ) ) { LOG . info ( STRING , interval , timeGrain ) ; throw new IllegalArgumentException ( STRING ) ; } intervalSlices . add ( slicedInterval ) ; sliceStart = sliceEnd ; } LOG . debug ( STRING , interval , intervalSlices . size ( ) , timeGrain ) ; return intervalSlices ; }
public static List < Interval > sliceIntervals ( Interval interval , TimeGrain timeGrain ) { DateTime intervalEnd = interval . getEnd ( ) ; DateTime sliceStart = interval . getStart ( ) ; DateTime periodStart = timeGrain . roundFloor ( sliceStart ) ; if ( ! sliceStart . equals ( periodStart ) ) { LOG . info ( STRING , interval , timeGrain , periodStart ) ; throw new IllegalArgumentException ( STRING + periodStart ) ; } List < Interval > intervalSlices = new ArrayList < > ( ) ; while ( sliceStart . isBefore ( intervalEnd ) ) { DateTime sliceEnd = DateTimeUtils . addTimeGrain ( sliceStart , timeGrain ) ; Interval slicedInterval = new Interval ( sliceStart , sliceEnd ) ; if ( ! interval . contains ( slicedInterval ) ) { LOG . info ( STRING , interval , timeGrain ) ; throw new IllegalArgumentException ( STRING ) ; } intervalSlices . add ( slicedInterval ) ; sliceStart = sliceEnd ; } LOG . debug ( STRING , interval , intervalSlices . size ( ) , timeGrain ) ; return intervalSlices ; }
@ Override public InetSocketAddress ipLocal ( ) { SocketChannel s = _channel ; if ( s != null ) { try { return ( InetSocketAddress ) s . getLocalAddress ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } else { return null ; } }
@ Override public InetSocketAddress ipLocal ( ) { SocketChannel s = _channel ; if ( s != null ) { try { return ( InetSocketAddress ) s . getLocalAddress ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } else { return null ; } }
public static boolean isMiddleMouseButton ( MouseEvent anEvent ) { return ( anEvent . getModifiersEx ( ) & InputEvent . BUTTON2_DOWN_MASK ) > _NUM ; }
public static boolean isMiddleMouseButton ( MouseEvent anEvent ) { return ( anEvent . getModifiersEx ( ) & InputEvent . BUTTON2_DOWN_MASK ) > _NUM ; }
private void updateSeekBarsForSpringConfig ( SpringConfig springConfig ) { float tension = ( float ) OrigamiValueConverter . origamiValueFromTension ( springConfig . tension ) ; float tensionRange = MAX_TENSION - MIN_TENSION ; int scaledTension = Math . round ( ( ( tension - MIN_TENSION ) * MAX_SEEKBAR_VAL ) / tensionRange ) ; float friction = ( float ) OrigamiValueConverter . origamiValueFromFriction ( springConfig . friction ) ; float frictionRange = MAX_FRICTION - MIN_FRICTION ; int scaledFriction = Math . round ( ( ( friction - MIN_FRICTION ) * MAX_SEEKBAR_VAL ) / frictionRange ) ; mTensionSeekBar . setProgress ( scaledTension ) ; mFrictionSeekBar . setProgress ( scaledFriction ) ; }
public PainterChain addPainter ( Painter p ) { if ( chain . length != _NUM ) { Painter [ ] newChain = new Painter [ chain . length + _NUM ] ; System . arraycopy ( chain , _NUM , newChain , _NUM , chain . length ) ; newChain [ chain . length ] = p ; return new PainterChain ( newChain ) ; } return new PainterChain ( new Painter [ ] { p } ) ; }
public PainterChain addPainter ( Painter p ) { if ( chain . length != _NUM ) { Painter [ ] newChain = new Painter [ chain . length + _NUM ] ; System . arraycopy ( chain , _NUM , newChain , _NUM , chain . length ) ; newChain [ chain . length ] = p ; return new PainterChain ( newChain ) ; } return new PainterChain ( new Painter [ ] { p } ) ; }
@ Override public String modelName ( ) { return STRING ; }
@ Override public String modelName ( ) { return STRING ; }
@ Override public String modelName ( ) { return STRING ; }
protected void engineInit ( AlgorithmParameterSpec genParamSpec , SecureRandom random ) throws InvalidAlgorithmParameterException { if ( ! ( genParamSpec instanceof DHGenParameterSpec ) ) { throw new InvalidAlgorithmParameterException ( STRING ) ; } DHGenParameterSpec dhParamSpec = ( DHGenParameterSpec ) genParamSpec ; primeSize = dhParamSpec . getPrimeSize ( ) ; try { checkKeySize ( primeSize ) ; } catch ( InvalidParameterException ipe ) { throw new InvalidAlgorithmParameterException ( ipe . getMessage ( ) ) ; } exponentSize = dhParamSpec . getExponentSize ( ) ; if ( exponentSize <= _NUM ) { throw new InvalidAlgorithmParameterException ( STRING ) ; } if ( exponentSize >= primeSize ) { throw new InvalidAlgorithmParameterException ( STRING ) ; } }
protected void engineInit ( AlgorithmParameterSpec genParamSpec , SecureRandom random ) throws InvalidAlgorithmParameterException { if ( ! ( genParamSpec instanceof DHGenParameterSpec ) ) { throw new InvalidAlgorithmParameterException ( STRING ) ; } DHGenParameterSpec dhParamSpec = ( DHGenParameterSpec ) genParamSpec ; primeSize = dhParamSpec . getPrimeSize ( ) ; try { checkKeySize ( primeSize ) ; } catch ( InvalidParameterException ipe ) { throw new InvalidAlgorithmParameterException ( ipe . getMessage ( ) ) ; } exponentSize = dhParamSpec . getExponentSize ( ) ; if ( exponentSize <= _NUM ) { throw new InvalidAlgorithmParameterException ( STRING ) ; } if ( exponentSize >= primeSize ) { throw new InvalidAlgorithmParameterException ( STRING ) ; } }
protected void engineInit ( AlgorithmParameterSpec genParamSpec , SecureRandom random ) throws InvalidAlgorithmParameterException { if ( ! ( genParamSpec instanceof DHGenParameterSpec ) ) { throw new InvalidAlgorithmParameterException ( STRING ) ; } DHGenParameterSpec dhParamSpec = ( DHGenParameterSpec ) genParamSpec ; primeSize = dhParamSpec . getPrimeSize ( ) ; try { checkKeySize ( primeSize ) ; } catch ( InvalidParameterException ipe ) { throw new InvalidAlgorithmParameterException ( ipe . getMessage ( ) ) ; } exponentSize = dhParamSpec . getExponentSize ( ) ; if ( exponentSize <= _NUM ) { throw new InvalidAlgorithmParameterException ( STRING ) ; } if ( exponentSize >= primeSize ) { throw new InvalidAlgorithmParameterException ( STRING ) ; } }
private static int [ ] calculateMultipartSize ( long size ) throws InvalidArgumentException { if ( size > MAX_OBJECT_SIZE ) { throw new InvalidArgumentException ( STRING + size + STRING ) ; } double partSize = Math . ceil ( ( double ) size / MAX_MULTIPART_COUNT ) ; partSize = Math . ceil ( partSize / MIN_MULTIPART_SIZE ) * MIN_MULTIPART_SIZE ; double partCount = Math . ceil ( size / partSize ) ; double lastPartSize = partSize - ( partSize * partCount - size ) ; if ( lastPartSize == _NUM ) { lastPartSize = partSize ; } return new int [ ] { ( int ) partSize , ( int ) partCount , ( int ) lastPartSize } ; }
private static int [ ] calculateMultipartSize ( long size ) throws InvalidArgumentException { if ( size > MAX_OBJECT_SIZE ) { throw new InvalidArgumentException ( STRING + size + STRING ) ; } double partSize = Math . ceil ( ( double ) size / MAX_MULTIPART_COUNT ) ; partSize = Math . ceil ( partSize / MIN_MULTIPART_SIZE ) * MIN_MULTIPART_SIZE ; double partCount = Math . ceil ( size / partSize ) ; double lastPartSize = partSize - ( partSize * partCount - size ) ; if ( lastPartSize == _NUM ) { lastPartSize = partSize ; } return new int [ ] { ( int ) partSize , ( int ) partCount , ( int ) lastPartSize } ; }
public void deleteMetadataEntry ( int i ) { if ( i < metadata . size ( ) ) { metadata . remove ( i ) ; } }
public void removeConsistencyGroupSnapshot ( String consistencyGroupId ) throws Exception { String systemId = getSystemId ( ) ; String uri = ScaleIOConstants . getRemoveConsistencyGroupSnapshotsURI ( systemId ) ; ScaleIORemoveConsistencyGroupSnapshots parm = new ScaleIORemoveConsistencyGroupSnapshots ( ) ; parm . setSnapGroupId ( consistencyGroupId ) ; post ( URI . create ( uri ) , getJsonForEntity ( parm ) ) ; }
public void add ( int position , T item ) { mData . add ( position , item ) ; notifyItemInserted ( position ) ; }
public void testStart ( long c ) { if ( this . isSingleton ) { throw new IllegalStateException ( STRING ) ; } String testName = buildTestNameFromStack ( ) ; testStart ( testName , EnumSet . noneOf ( TestProperty . class ) , c ) ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; mHandler = new Handler ( ) ; setContentView ( R . layout . voice_recognition ) ; Button speakButton = ( Button ) findViewById ( R . id . btn_speak ) ; mList = ( ListView ) findViewById ( R . id . list ) ; mSupportedLanguageView = ( Spinner ) findViewById ( R . id . supported_languages ) ; PackageManager pm = getPackageManager ( ) ; List < ResolveInfo > activities = pm . queryIntentActivities ( new Intent ( RecognizerIntent . ACTION_RECOGNIZE_SPEECH ) , _NUM ) ; if ( activities . size ( ) != _NUM ) { speakButton . setOnClickListener ( this ) ; } else { speakButton . setEnabled ( _BOOL ) ; speakButton . setText ( STRING ) ; } refreshVoiceSettings ( ) ; }
@ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; mHandler = new Handler ( ) ; setContentView ( R . layout . voice_recognition ) ; Button speakButton = ( Button ) findViewById ( R . id . btn_speak ) ; mList = ( ListView ) findViewById ( R . id . list ) ; mSupportedLanguageView = ( Spinner ) findViewById ( R . id . supported_languages ) ; PackageManager pm = getPackageManager ( ) ; List < ResolveInfo > activities = pm . queryIntentActivities ( new Intent ( RecognizerIntent . ACTION_RECOGNIZE_SPEECH ) , _NUM ) ; if ( activities . size ( ) != _NUM ) { speakButton . setOnClickListener ( this ) ; } else { speakButton . setEnabled ( _BOOL ) ; speakButton . setText ( STRING ) ; } refreshVoiceSettings ( ) ; }
public AnnotationDrawer ( final AnnotationsModel model , final ProcessRendererModel rendererModel ) { this . model = model ; this . rendererModel = rendererModel ; this . displayCache = new HashMap < > ( ) ; this . cachedID = new HashMap < > ( ) ; pane = new JEditorPane ( STRING , STRING ) ; pane . setBorder ( null ) ; pane . setOpaque ( _BOOL ) ; }
public boolean validatePassword ( String password , String goodHash ) { return validatePassword ( password . toCharArray ( ) , goodHash ) ; }
public URL findResource ( String name , boolean check ) { Loader loader ; int [ ] cache = getLookupCache ( name ) ; for ( int i = _NUM ; ( loader = getNextLoader ( cache , i ) ) != null ; i ++ ) { URL url = loader . findResource ( name , check ) ; if ( url != null ) { return url ; } } return null ; }
public void pushScope ( ) { if ( fCurrentScope + _NUM == fScope . length ) { int [ ] contextarray = new int [ fScope . length * _NUM ] ; System . arraycopy ( fScope , _NUM , contextarray , _NUM , fScope . length ) ; fScope = contextarray ; } pushContext ( ) ; fScope [ ++ fCurrentScope ] = fCurrentContext ; }
public void pushScope ( ) { if ( fCurrentScope + _NUM == fScope . length ) { int [ ] contextarray = new int [ fScope . length * _NUM ] ; System . arraycopy ( fScope , _NUM , contextarray , _NUM , fScope . length ) ; fScope = contextarray ; } pushContext ( ) ; fScope [ ++ fCurrentScope ] = fCurrentContext ; }
public void pushScope ( ) { if ( fCurrentScope + _NUM == fScope . length ) { int [ ] contextarray = new int [ fScope . length * _NUM ] ; System . arraycopy ( fScope , _NUM , contextarray , _NUM , fScope . length ) ; fScope = contextarray ; } pushContext ( ) ; fScope [ ++ fCurrentScope ] = fCurrentContext ; }
public static long createBookmarksFolderOnce ( Context context , String title , long parentId ) { Long id = chromeBrowserProviderCall ( Long . class , ChromeBrowserProvider . CLIENT_API_CREATE_BOOKMARKS_FOLDER_ONCE , context , argsToBundle ( title , parentId ) ) ; return id != null ? id . longValue ( ) : INVALID_BOOKMARK_ID ; }
public static long createBookmarksFolderOnce ( Context context , String title , long parentId ) { Long id = chromeBrowserProviderCall ( Long . class , ChromeBrowserProvider . CLIENT_API_CREATE_BOOKMARKS_FOLDER_ONCE , context , argsToBundle ( title , parentId ) ) ; return id != null ? id . longValue ( ) : INVALID_BOOKMARK_ID ; }
public static long createBookmarksFolderOnce ( Context context , String title , long parentId ) { Long id = chromeBrowserProviderCall ( Long . class , ChromeBrowserProvider . CLIENT_API_CREATE_BOOKMARKS_FOLDER_ONCE , context , argsToBundle ( title , parentId ) ) ; return id != null ? id . longValue ( ) : INVALID_BOOKMARK_ID ; }
public static long createBookmarksFolderOnce ( Context context , String title , long parentId ) { Long id = chromeBrowserProviderCall ( Long . class , ChromeBrowserProvider . CLIENT_API_CREATE_BOOKMARKS_FOLDER_ONCE , context , argsToBundle ( title , parentId ) ) ; return id != null ? id . longValue ( ) : INVALID_BOOKMARK_ID ; }
public static long createBookmarksFolderOnce ( Context context , String title , long parentId ) { Long id = chromeBrowserProviderCall ( Long . class , ChromeBrowserProvider . CLIENT_API_CREATE_BOOKMARKS_FOLDER_ONCE , context , argsToBundle ( title , parentId ) ) ; return id != null ? id . longValue ( ) : INVALID_BOOKMARK_ID ; }
protected void compareDatasets ( Instances data1 , Instances data2 ) throws Exception { if ( ! data2 . equalHeaders ( data1 ) ) { throw new Exception ( STRING + data2 . equalHeadersMsg ( data1 ) ) ; } if ( ! ( data2 . numInstances ( ) == data1 . numInstances ( ) ) ) { throw new Exception ( STRING ) ; } for ( int i = _NUM ; i < data2 . numInstances ( ) ; i ++ ) { Instance orig = data1 . instance ( i ) ; Instance copy = data2 . instance ( i ) ; for ( int j = _NUM ; j < orig . numAttributes ( ) ; j ++ ) { if ( orig . isMissing ( j ) ) { if ( ! copy . isMissing ( j ) ) { throw new Exception ( STRING ) ; } } else if ( orig . value ( j ) != copy . value ( j ) ) { throw new Exception ( STRING ) ; } if ( orig . weight ( ) != copy . weight ( ) ) { throw new Exception ( STRING ) ; } } } }
public int read ( ) throws IOException { synchronized ( lock ) { char [ ] charArray = new char [ _NUM ] ; if ( read ( charArray , _NUM , _NUM ) != - _NUM ) { return charArray [ _NUM ] ; } return - _NUM ; } }
public static XContentType xContentType ( CharSequence content ) { int length = content . length ( ) < GUESS_HEADER_LENGTH ? content . length ( ) : GUESS_HEADER_LENGTH ; if ( length == _NUM ) { return null ; } char first = content . charAt ( _NUM ) ; if ( first == STRING ) { return XContentType . JSON ; } if ( length > _NUM && first == SmileConstants . HEADER_BYTE_1 && content . charAt ( _NUM ) == SmileConstants . HEADER_BYTE_2 && content . charAt ( _NUM ) == SmileConstants . HEADER_BYTE_3 ) { return XContentType . SMILE ; } if ( length > _NUM && first == STRING && content . charAt ( _NUM ) == STRING && content . charAt ( _NUM ) == STRING ) { return XContentType . YAML ; } for ( int i = _NUM ; i < length ; i ++ ) { char c = content . charAt ( i ) ; if ( c == STRING ) { return XContentType . JSON ; } if ( Character . isWhitespace ( c ) == _BOOL ) { break ; } } return null ; }
@ VisibleForTesting public static String fileName ( String url , String mimeType , String contentDisposition ) { String fileName = URLUtil . guessFileName ( url , contentDisposition , mimeType ) ; int dotIndex = fileName . lastIndexOf ( STRING ) ; if ( mimeType != null && ! mimeType . isEmpty ( ) && dotIndex > _NUM && dotIndex < fileName . length ( ) ) { MimeTypeMap mimeTypeMap = MimeTypeMap . getSingleton ( ) ; String fileRoot = fileName . substring ( _NUM , dotIndex ) ; String fileExtension = fileName . substring ( dotIndex + _NUM ) ; String fileExtensionMimeType = mimeTypeMap . getMimeTypeFromExtension ( fileExtension ) ; if ( mimeType . equals ( fileExtensionMimeType ) ) { fileName = fileRoot + STRING + fileExtension ; } else { String mimeExtension = mimeTypeMap . getExtensionFromMimeType ( mimeType ) ; if ( mimeExtension != null && ! mimeExtension . equals ( fileExtension ) ) { fileName = fileRoot + STRING + mimeExtension ; } } } return fileName ; }
public static void removeImages ( @ NotNull List < String > lines ) { for ( int i = _NUM ; i < lines . size ( ) ; i ++ ) { String newText = removeAllImages ( lines . get ( i ) ) ; lines . set ( i , newText ) ; } }
public static void removeImages ( @ NotNull List < String > lines ) { for ( int i = _NUM ; i < lines . size ( ) ; i ++ ) { String newText = removeAllImages ( lines . get ( i ) ) ; lines . set ( i , newText ) ; } }
public T first ( ) { if ( filter == null ) { List < SearchResultResourceRep > resultRefs = resources . performSearch ( parameters ) ; if ( resultRefs . isEmpty ( ) ) { return null ; } return resources . get ( resultRefs . get ( _NUM ) ) ; } else { List < T > items = run ( ) ; if ( items . isEmpty ( ) ) { return null ; } return items . get ( _NUM ) ; } }
public T first ( ) { if ( filter == null ) { List < SearchResultResourceRep > resultRefs = resources . performSearch ( parameters ) ; if ( resultRefs . isEmpty ( ) ) { return null ; } return resources . get ( resultRefs . get ( _NUM ) ) ; } else { List < T > items = run ( ) ; if ( items . isEmpty ( ) ) { return null ; } return items . get ( _NUM ) ; } }
public void addSlide ( @ NonNull Fragment fragment ) { fragments . add ( fragment ) ; mPagerAdapter . notifyDataSetChanged ( ) ; }
private CipherBox ( ProtocolVersion protocolVersion , BulkCipher bulkCipher , SecretKey key , IvParameterSpec iv , SecureRandom random , boolean encrypt ) throws NoSuchAlgorithmException { try { this . protocolVersion = protocolVersion ; this . cipher = JsseJce . getCipher ( bulkCipher . transformation ) ; this . mode = encrypt ? Cipher . ENCRYPT_MODE : Cipher . DECRYPT_MODE ; if ( random == null ) { random = JsseJce . getSecureRandom ( ) ; } this . random = random ; this . cipherType = bulkCipher . cipherType ; if ( iv == null && bulkCipher . ivSize != _NUM && mode == Cipher . DECRYPT_MODE && protocolVersion . v >= ProtocolVersion . TLS11 . v ) { iv = getFixedMask ( bulkCipher . ivSize ) ; } if ( cipherType == AEAD_CIPHER ) { tagSize = bulkCipher . tagSize ; this . key = key ; fixedIv = iv . getIV ( ) ; if ( fixedIv == null || fixedIv . length != bulkCipher . fixedIvSize ) { throw new RuntimeException ( STRING ) ; } recordIvSize = bulkCipher . ivSize - bulkCipher . fixedIvSize ; } else { this . tagSize = _NUM ; this . fixedIv = new byte [ _NUM ] ; this . recordIvSize = _NUM ; this . key = null ; cipher . init ( mode , key , iv , random ) ; } } catch ( NoSuchAlgorithmException e ) { throw e ; } catch ( Exception e ) { throw new NoSuchAlgorithmException ( STRING + bulkCipher , e ) ; } catch ( ExceptionInInitializerError e ) { throw new NoSuchAlgorithmException ( STRING + bulkCipher , e ) ; } }
public static void writeListOfLongs ( List list , boolean hasLongIDs , DataOutput out ) throws IOException { if ( list == null ) { out . writeInt ( - _NUM ) ; } else { out . writeInt ( list . size ( ) ) ; out . writeBoolean ( hasLongIDs ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Long l = ( Long ) it . next ( ) ; if ( hasLongIDs ) { out . writeLong ( l . longValue ( ) ) ; } else { out . writeInt ( ( int ) l . longValue ( ) ) ; } } } }
public static ObservableStringValue decision ( ObservableBooleanValue condition , ObservableStringValue ifTrue , ObservableStringValue ifFalse ) { StringProperty ret = new SimpleStringProperty ( ) ; condition . addListener ( null ) ; ifTrue . addListener ( null ) ; ifFalse . addListener ( null ) ; ret . set ( condition . get ( ) ? ifTrue . get ( ) : ifFalse . get ( ) ) ; return ret ; }
public static ObservableStringValue decision ( ObservableBooleanValue condition , ObservableStringValue ifTrue , ObservableStringValue ifFalse ) { StringProperty ret = new SimpleStringProperty ( ) ; condition . addListener ( null ) ; ifTrue . addListener ( null ) ; ifFalse . addListener ( null ) ; ret . set ( condition . get ( ) ? ifTrue . get ( ) : ifFalse . get ( ) ) ; return ret ; }
private final File locate ( String name ) { String prefix = STRING ; File sourceFile = null ; int idx = _NUM ; while ( _BOOL ) { if ( ( idx == _NUM ) && ( ToolIO . getUserDir ( ) != null ) ) { sourceFile = new File ( ToolIO . getUserDir ( ) , name ) ; } else { if ( isInJar ( prefix ) ) { InputStream is = cl . getResourceAsStream ( STANDARD_MODULES + name ) ; if ( is != null ) { try { sourceFile = new File ( TMPDIR + File . separator + name ) ; sourceFile . deleteOnExit ( ) ; FileOutputStream fos = new FileOutputStream ( sourceFile ) ; byte buf [ ] = new byte [ _NUM ] ; int len ; while ( ( len = is . read ( buf ) ) > _NUM ) { fos . write ( buf , _NUM , len ) ; } fos . close ( ) ; is . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } else { sourceFile = new File ( prefix + name ) ; } } if ( sourceFile . exists ( ) ) break ; if ( idx >= libraryPaths . length ) break ; prefix = libraryPaths [ idx ++ ] ; } return sourceFile ; }
private final File locate ( String name ) { String prefix = STRING ; File sourceFile = null ; int idx = _NUM ; while ( _BOOL ) { if ( ( idx == _NUM ) && ( ToolIO . getUserDir ( ) != null ) ) { sourceFile = new File ( ToolIO . getUserDir ( ) , name ) ; } else { if ( isInJar ( prefix ) ) { InputStream is = cl . getResourceAsStream ( STANDARD_MODULES + name ) ; if ( is != null ) { try { sourceFile = new File ( TMPDIR + File . separator + name ) ; sourceFile . deleteOnExit ( ) ; FileOutputStream fos = new FileOutputStream ( sourceFile ) ; byte buf [ ] = new byte [ _NUM ] ; int len ; while ( ( len = is . read ( buf ) ) > _NUM ) { fos . write ( buf , _NUM , len ) ; } fos . close ( ) ; is . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } else { sourceFile = new File ( prefix + name ) ; } } if ( sourceFile . exists ( ) ) break ; if ( idx >= libraryPaths . length ) break ; prefix = libraryPaths [ idx ++ ] ; } return sourceFile ; }
private final File locate ( String name ) { String prefix = STRING ; File sourceFile = null ; int idx = _NUM ; while ( _BOOL ) { if ( ( idx == _NUM ) && ( ToolIO . getUserDir ( ) != null ) ) { sourceFile = new File ( ToolIO . getUserDir ( ) , name ) ; } else { if ( isInJar ( prefix ) ) { InputStream is = cl . getResourceAsStream ( STANDARD_MODULES + name ) ; if ( is != null ) { try { sourceFile = new File ( TMPDIR + File . separator + name ) ; sourceFile . deleteOnExit ( ) ; FileOutputStream fos = new FileOutputStream ( sourceFile ) ; byte buf [ ] = new byte [ _NUM ] ; int len ; while ( ( len = is . read ( buf ) ) > _NUM ) { fos . write ( buf , _NUM , len ) ; } fos . close ( ) ; is . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } else { sourceFile = new File ( prefix + name ) ; } } if ( sourceFile . exists ( ) ) break ; if ( idx >= libraryPaths . length ) break ; prefix = libraryPaths [ idx ++ ] ; } return sourceFile ; }
private final File locate ( String name ) { String prefix = STRING ; File sourceFile = null ; int idx = _NUM ; while ( _BOOL ) { if ( ( idx == _NUM ) && ( ToolIO . getUserDir ( ) != null ) ) { sourceFile = new File ( ToolIO . getUserDir ( ) , name ) ; } else { if ( isInJar ( prefix ) ) { InputStream is = cl . getResourceAsStream ( STANDARD_MODULES + name ) ; if ( is != null ) { try { sourceFile = new File ( TMPDIR + File . separator + name ) ; sourceFile . deleteOnExit ( ) ; FileOutputStream fos = new FileOutputStream ( sourceFile ) ; byte buf [ ] = new byte [ _NUM ] ; int len ; while ( ( len = is . read ( buf ) ) > _NUM ) { fos . write ( buf , _NUM , len ) ; } fos . close ( ) ; is . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } else { sourceFile = new File ( prefix + name ) ; } } if ( sourceFile . exists ( ) ) break ; if ( idx >= libraryPaths . length ) break ; prefix = libraryPaths [ idx ++ ] ; } return sourceFile ; }
private final File locate ( String name ) { String prefix = STRING ; File sourceFile = null ; int idx = _NUM ; while ( _BOOL ) { if ( ( idx == _NUM ) && ( ToolIO . getUserDir ( ) != null ) ) { sourceFile = new File ( ToolIO . getUserDir ( ) , name ) ; } else { if ( isInJar ( prefix ) ) { InputStream is = cl . getResourceAsStream ( STANDARD_MODULES + name ) ; if ( is != null ) { try { sourceFile = new File ( TMPDIR + File . separator + name ) ; sourceFile . deleteOnExit ( ) ; FileOutputStream fos = new FileOutputStream ( sourceFile ) ; byte buf [ ] = new byte [ _NUM ] ; int len ; while ( ( len = is . read ( buf ) ) > _NUM ) { fos . write ( buf , _NUM , len ) ; } fos . close ( ) ; is . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } else { sourceFile = new File ( prefix + name ) ; } } if ( sourceFile . exists ( ) ) break ; if ( idx >= libraryPaths . length ) break ; prefix = libraryPaths [ idx ++ ] ; } return sourceFile ; }
private void paintCheckIconSelectedAndMouseOver ( Graphics2D g , int width , int height ) { Shape s = shapeGenerator . createCheckMark ( _NUM , _NUM , width , height ) ; g . setPaint ( iconSelectedMouseOver ) ; g . fill ( s ) ; }
public String makeFieldPrompt ( final String fieldName , final boolean defaultValue ) { return String . format ( STRING , fieldName , defaultValue ) ; }
public void loadToolboxContents ( String toolboxXml ) { loadToolboxContents ( new ByteArrayInputStream ( toolboxXml . getBytes ( ) ) ) ; }
public static void calcTextSize ( Paint paint , String demoText , FSize outputFSize ) { Rect r = mCalcTextSizeRect ; r . set ( _NUM , _NUM , _NUM , _NUM ) ; paint . getTextBounds ( demoText , _NUM , demoText . length ( ) , r ) ; outputFSize . width = r . width ( ) ; outputFSize . height = r . height ( ) ; }
public static void calcTextSize ( Paint paint , String demoText , FSize outputFSize ) { Rect r = mCalcTextSizeRect ; r . set ( _NUM , _NUM , _NUM , _NUM ) ; paint . getTextBounds ( demoText , _NUM , demoText . length ( ) , r ) ; outputFSize . width = r . width ( ) ; outputFSize . height = r . height ( ) ; }
public static InputStream needStream ( String propertyName ) throws NoSuchPropertyException , FileNotFoundException , MaryConfigurationException { MaryProperties . needProperty ( propertyName ) ; return getStream ( propertyName ) ; }
protected Ignite startRemoteGrid ( String gridName , IgniteConfiguration cfg , GridSpringResourceContext ctx ) throws Exception { if ( ctx != null ) throw new UnsupportedOperationException ( STRING ) ; if ( cfg == null ) cfg = optimize ( getConfiguration ( gridName ) ) ; return new IgniteProcessProxy ( cfg , log , grid ( _NUM ) ) ; }
protected Ignite startRemoteGrid ( String gridName , IgniteConfiguration cfg , GridSpringResourceContext ctx ) throws Exception { if ( ctx != null ) throw new UnsupportedOperationException ( STRING ) ; if ( cfg == null ) cfg = optimize ( getConfiguration ( gridName ) ) ; return new IgniteProcessProxy ( cfg , log , grid ( _NUM ) ) ; }
public void addSensorSelectionListener ( final SensorSelectionListener listener ) { listenerList . add ( SensorSelectionListener . class , listener ) ; }
public static void addImageLoader ( ImageLoader loader ) { if ( null != loader && ! IMAGE_LOADERS . contains ( loader ) ) { IMAGE_LOADERS . add ( _NUM , loader ) ; } }
public static void addImageLoader ( ImageLoader loader ) { if ( null != loader && ! IMAGE_LOADERS . contains ( loader ) ) { IMAGE_LOADERS . add ( _NUM , loader ) ; } }
public static void addImageLoader ( ImageLoader loader ) { if ( null != loader && ! IMAGE_LOADERS . contains ( loader ) ) { IMAGE_LOADERS . add ( _NUM , loader ) ; } }
private void addToChart ( Trie trie , int j , boolean isUnary ) { if ( ! isUnary && trie . hasRules ( ) ) { DotNode dotNode = new DotNode ( i , j , trie , new ArrayList < > ( nodeStack ) , null ) ; addToCandidates ( dotNode ) ; } for ( int l = j + _NUM ; l <= sentence . length ( ) ; l ++ ) consume ( trie , j , l ) ; }
private void addToChart ( Trie trie , int j , boolean isUnary ) { if ( ! isUnary && trie . hasRules ( ) ) { DotNode dotNode = new DotNode ( i , j , trie , new ArrayList < > ( nodeStack ) , null ) ; addToCandidates ( dotNode ) ; } for ( int l = j + _NUM ; l <= sentence . length ( ) ; l ++ ) consume ( trie , j , l ) ; }
private void addToChart ( Trie trie , int j , boolean isUnary ) { if ( ! isUnary && trie . hasRules ( ) ) { DotNode dotNode = new DotNode ( i , j , trie , new ArrayList < > ( nodeStack ) , null ) ; addToCandidates ( dotNode ) ; } for ( int l = j + _NUM ; l <= sentence . length ( ) ; l ++ ) consume ( trie , j , l ) ; }
public static int ping ( String url ) throws Exception { URL u = new URL ( url ) ; HttpURLConnection c = ( HttpURLConnection ) u . openConnection ( ) ; c . connect ( ) ; int code = c . getResponseCode ( ) ; log . debug ( STRING + url + STRING + code ) ; c . disconnect ( ) ; return code ; }
public static int ping ( String url ) throws Exception { URL u = new URL ( url ) ; HttpURLConnection c = ( HttpURLConnection ) u . openConnection ( ) ; c . connect ( ) ; int code = c . getResponseCode ( ) ; log . debug ( STRING + url + STRING + code ) ; c . disconnect ( ) ; return code ; }
private void drawYTickMarks ( Graphics g ) { Rectangle plotRect = getPlotRect ( ) ; int xPos = plotRect . x ; NumberFormat nf = NumberFormat . getInstance ( ) ; nf . setMinimumFractionDigits ( _NUM ) ; nf . setMaximumFractionDigits ( _NUM ) ; for ( double d = _NUM ; d <= _NUM ; d += _NUM ) { int yPos = getYPos ( d ) ; g . setColor ( boundaryColor ) ; g . drawLine ( xPos , yPos , xPos + _NUM , yPos ) ; String str = nf . format ( d ) ; int strWid = fm . stringWidth ( str ) ; int strHgt = fm . getAscent ( ) ; g . drawString ( str , xPos - strWid - _NUM , yPos + strHgt / _NUM ) ; } }
public final void removeElementAt ( int i ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + _NUM , m_map , i , m_firstFree ) ; else m_map [ i ] = null ; m_firstFree -- ; }
public final void removeElementAt ( int i ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + _NUM , m_map , i , m_firstFree ) ; else m_map [ i ] = null ; m_firstFree -- ; }
public final void removeElementAt ( int i ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + _NUM , m_map , i , m_firstFree ) ; else m_map [ i ] = null ; m_firstFree -- ; }
public final void removeElementAt ( int i ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + _NUM , m_map , i , m_firstFree ) ; else m_map [ i ] = null ; m_firstFree -- ; }
public final void removeElementAt ( int i ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + _NUM , m_map , i , m_firstFree ) ; else m_map [ i ] = null ; m_firstFree -- ; }
protected abstract List < String > createCommand ( StepInstance stepInstance , String temporaryFileDirectory ) ;
protected abstract List < String > createCommand ( StepInstance stepInstance , String temporaryFileDirectory ) ;
protected abstract List < String > createCommand ( StepInstance stepInstance , String temporaryFileDirectory ) ;
protected abstract List < String > createCommand ( StepInstance stepInstance , String temporaryFileDirectory ) ;
protected abstract List < String > createCommand ( StepInstance stepInstance , String temporaryFileDirectory ) ;
public EncoderTestSuiteBuilder invalid ( int min , int max ) { _invalid . set ( min , max + _NUM ) ; _valid . clear ( min , max + _NUM ) ; _encoded . clear ( min , max + _NUM ) ; return this ; }
public EncoderTestSuiteBuilder invalid ( int min , int max ) { _invalid . set ( min , max + _NUM ) ; _valid . clear ( min , max + _NUM ) ; _encoded . clear ( min , max + _NUM ) ; return this ; }
private void checkCompletion ( ) { for ( Iterator < ComputeTaskFuture < Integer > > iter = futures . iterator ( ) ; iter . hasNext ( ) ; ) { ComputeTaskFuture < Integer > fut = iter . next ( ) ; if ( fut . isDone ( ) ) { try { Integer res = fut . get ( ) ; assert res == params . getJobsCount ( ) : STRING + fut . getTaskSession ( ) . getId ( ) + STRING + res + STRING ; ignite . log ( ) . info ( STRING + fut . getTaskSession ( ) . getId ( ) ) ; } catch ( IgniteFutureCancelledException ignored ) { ignite . log ( ) . info ( STRING + fut . getTaskSession ( ) . getId ( ) ) ; } catch ( IgniteException e ) { ignite . log ( ) . warning ( STRING + fut . getTaskSession ( ) . getId ( ) , e ) ; } finally { iter . remove ( ) ; } } } }
private void checkCompletion ( ) { for ( Iterator < ComputeTaskFuture < Integer > > iter = futures . iterator ( ) ; iter . hasNext ( ) ; ) { ComputeTaskFuture < Integer > fut = iter . next ( ) ; if ( fut . isDone ( ) ) { try { Integer res = fut . get ( ) ; assert res == params . getJobsCount ( ) : STRING + fut . getTaskSession ( ) . getId ( ) + STRING + res + STRING ; ignite . log ( ) . info ( STRING + fut . getTaskSession ( ) . getId ( ) ) ; } catch ( IgniteFutureCancelledException ignored ) { ignite . log ( ) . info ( STRING + fut . getTaskSession ( ) . getId ( ) ) ; } catch ( IgniteException e ) { ignite . log ( ) . warning ( STRING + fut . getTaskSession ( ) . getId ( ) , e ) ; } finally { iter . remove ( ) ; } } } }
public void outputSource ( int module , int line , String s ) { StringBuilder sb = new StringBuilder ( ) ; appendSource ( sb , module , line , s , _BOOL ) ; out ( sb . toString ( ) ) ; }
private synchronized void saveToSettings ( ) { if ( settings != null ) { List < List > dataToSave = new ArrayList < > ( ) ; for ( Hotkey hotkey : hotkeys ) { dataToSave . add ( hotkeyToList ( hotkey ) ) ; } settings . putList ( SETTING_NAME , dataToSave ) ; } }
@ SuppressWarnings ( STRING ) @ Override synchronized public void start ( ) { A . notNull ( springCfgPath , STRING ) ; A . notNull ( cacheName , STRING ) ; A . notNull ( eventTransformerCls , STRING ) ; sinkCounter . start ( ) ; try { if ( ignite == null ) ignite = Ignition . start ( springCfgPath ) ; if ( eventTransformerCls != null && ! eventTransformerCls . isEmpty ( ) ) { Class < ? extends EventTransformer > clazz = ( Class < ? extends EventTransformer < Event , Object , Object > > ) Class . forName ( eventTransformerCls ) ; eventTransformer = clazz . newInstance ( ) ; } } catch ( Exception e ) { log . error ( STRING , e ) ; throw new FlumeException ( STRING , e ) ; } super . start ( ) ; }
public TaskConvertImageToRGBPreview createTaskConvertImageToRGBPreview ( ImageToProcess image , Executor executor , ImageBackend imageBackend , CaptureSession session , Size targetSize , TaskConvertImageToRGBPreview . ThumbnailShape thumbnailShape ) { return new TaskConvertImageToRGBPreview ( image , executor , imageBackend , TaskImageContainer . ProcessingPriority . FAST , session , mTinyThumbnailTargetSize , thumbnailShape ) ; }
public void storeDomainFor ( Variable var , Domain domain ) { if ( ! affectedVariables . contains ( var ) ) { savedDomains . add ( new Pair < Variable , Domain > ( var , domain ) ) ; affectedVariables . add ( var ) ; } }
public void storeDomainFor ( Variable var , Domain domain ) { if ( ! affectedVariables . contains ( var ) ) { savedDomains . add ( new Pair < Variable , Domain > ( var , domain ) ) ; affectedVariables . add ( var ) ; } }
public static void updateMediaNotificationForTab ( Context context , int tabId , boolean audio , boolean video , String fullUrl ) { int mediaType = getMediaType ( audio , video ) ; if ( ! shouldStartService ( context , mediaType , tabId ) ) return ; Intent intent = new Intent ( context , MediaCaptureNotificationService . class ) ; intent . putExtra ( NOTIFICATION_ID_EXTRA , tabId ) ; String baseUrl = fullUrl ; try { URL url = new URL ( fullUrl ) ; baseUrl = url . getProtocol ( ) + STRING + url . getHost ( ) ; } catch ( MalformedURLException e ) { Log . w ( TAG , STRING + fullUrl ) ; } intent . putExtra ( NOTIFICATION_MEDIA_URL_EXTRA , baseUrl ) ; intent . putExtra ( NOTIFICATION_MEDIA_TYPE_EXTRA , mediaType ) ; context . startService ( intent ) ; }
public static void updateMediaNotificationForTab ( Context context , int tabId , boolean audio , boolean video , String fullUrl ) { int mediaType = getMediaType ( audio , video ) ; if ( ! shouldStartService ( context , mediaType , tabId ) ) return ; Intent intent = new Intent ( context , MediaCaptureNotificationService . class ) ; intent . putExtra ( NOTIFICATION_ID_EXTRA , tabId ) ; String baseUrl = fullUrl ; try { URL url = new URL ( fullUrl ) ; baseUrl = url . getProtocol ( ) + STRING + url . getHost ( ) ; } catch ( MalformedURLException e ) { Log . w ( TAG , STRING + fullUrl ) ; } intent . putExtra ( NOTIFICATION_MEDIA_URL_EXTRA , baseUrl ) ; intent . putExtra ( NOTIFICATION_MEDIA_TYPE_EXTRA , mediaType ) ; context . startService ( intent ) ; }
public static void updateMediaNotificationForTab ( Context context , int tabId , boolean audio , boolean video , String fullUrl ) { int mediaType = getMediaType ( audio , video ) ; if ( ! shouldStartService ( context , mediaType , tabId ) ) return ; Intent intent = new Intent ( context , MediaCaptureNotificationService . class ) ; intent . putExtra ( NOTIFICATION_ID_EXTRA , tabId ) ; String baseUrl = fullUrl ; try { URL url = new URL ( fullUrl ) ; baseUrl = url . getProtocol ( ) + STRING + url . getHost ( ) ; } catch ( MalformedURLException e ) { Log . w ( TAG , STRING + fullUrl ) ; } intent . putExtra ( NOTIFICATION_MEDIA_URL_EXTRA , baseUrl ) ; intent . putExtra ( NOTIFICATION_MEDIA_TYPE_EXTRA , mediaType ) ; context . startService ( intent ) ; }
public final boolean beginAtomicTransaction ( Connection connection ) throws AdeException { this . connection = connection ; createdStatements = new ArrayList < Statement > ( ) ; final boolean result = performAtomicTransaction ( ) ; for ( Statement s : createdStatements ) { try { s . close ( ) ; } catch ( SQLException e ) { logger . error ( STRING , e ) ; } } this . connection = null ; return result ; }
public final boolean beginAtomicTransaction ( Connection connection ) throws AdeException { this . connection = connection ; createdStatements = new ArrayList < Statement > ( ) ; final boolean result = performAtomicTransaction ( ) ; for ( Statement s : createdStatements ) { try { s . close ( ) ; } catch ( SQLException e ) { logger . error ( STRING , e ) ; } } this . connection = null ; return result ; }
public final boolean beginAtomicTransaction ( Connection connection ) throws AdeException { this . connection = connection ; createdStatements = new ArrayList < Statement > ( ) ; final boolean result = performAtomicTransaction ( ) ; for ( Statement s : createdStatements ) { try { s . close ( ) ; } catch ( SQLException e ) { logger . error ( STRING , e ) ; } } this . connection = null ; return result ; }
public final boolean beginAtomicTransaction ( Connection connection ) throws AdeException { this . connection = connection ; createdStatements = new ArrayList < Statement > ( ) ; final boolean result = performAtomicTransaction ( ) ; for ( Statement s : createdStatements ) { try { s . close ( ) ; } catch ( SQLException e ) { logger . error ( STRING , e ) ; } } this . connection = null ; return result ; }
public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( xctxt . isSecureProcessing ( ) ) throw new javax . xml . transform . TransformerException ( XPATHMessages . createXPATHMessage ( XPATHErrorResources . ER_EXTENSION_FUNCTION_CANNOT_BE_INVOKED , new Object [ ] { toString ( ) } ) ) ; XObject result ; Vector argVec = new Vector ( ) ; int nArgs = m_argVec . size ( ) ; for ( int i = _NUM ; i < nArgs ; i ++ ) { Expression arg = ( Expression ) m_argVec . elementAt ( i ) ; XObject xobj = arg . execute ( xctxt ) ; xobj . allowDetachToRelease ( _BOOL ) ; argVec . addElement ( xobj ) ; } ExtensionsProvider extProvider = ( ExtensionsProvider ) xctxt . getOwnerObject ( ) ; Object val = extProvider . extFunction ( this , argVec ) ; if ( null != val ) { result = XObject . create ( val , xctxt ) ; } else { result = new XNull ( ) ; } return result ; }
public void testCommonPrefix ( ) { String returned = m_Trie . getCommonPrefix ( ) ; assertEquals ( STRING , _NUM , returned . length ( ) ) ; String expected = STRING ; Trie t = buildTrie ( new String [ ] { m_Data [ _NUM ] , m_Data [ _NUM ] } ) ; returned = t . getCommonPrefix ( ) ; assertEquals ( STRING , expected . length ( ) , returned . length ( ) ) ; }
public static boolean createFolder ( File targetFolder ) { if ( targetFolder . exists ( ) ) { if ( targetFolder . isDirectory ( ) ) return _BOOL ; targetFolder . delete ( ) ; } return targetFolder . mkdirs ( ) ; }
public static String quote ( String s ) { if ( s == null ) return null ; if ( s . length ( ) == _NUM ) return STRING ; StringBuffer b = new StringBuffer ( s . length ( ) + _NUM ) ; quote ( b , s ) ; return b . toString ( ) ; }
private static void conditionalCopy ( final List < NV > anns , final Properties queryHints , final String name ) { if ( queryHints == null ) return ; final Object val = queryHints . getProperty ( name ) ; if ( val != null ) { anns . add ( new NV ( name , val ) ) ; } }
@ Override protected FieldConfigBase createCopy ( FieldConfigBase fieldConfigBase ) { FieldConfigString copy = null ; if ( fieldConfigBase != null ) { copy = new FieldConfigString ( fieldConfigBase . getCommonData ( ) , this . buttonText ) ; } return copy ; }
@ Deprecated public static void assertNotEquals ( String itemName , double notExpected , double actual , double delta ) { try { if ( Double . isInfinite ( notExpected ) && notExpected == actual || Math . abs ( notExpected - actual ) <= delta ) { Assert . fail ( itemName + STRING + notExpected + STRING ) ; } } catch ( AssertionError e ) { Verify . throwMangledException ( e ) ; } }
public void addHeader ( String name , String val ) { mMsgHeader = mMsgHeader + name + STRING + val + mLineDelimiter ; addInternalHeaderFields ( name , val ) ; }
protected int calculateNewPagerPosition ( int newActiveElement ) { newActiveElement ++ ; if ( newActiveElement <= _NUM ) newActiveElement = _NUM ; int pagerActiveElemCenterPosX = mPagerElementActiveSize / _NUM + newActiveElement * mPagerElementLeftMargin + ( newActiveElement - _NUM ) * ( mPagerElementNormalSize + mPagerElementRightMargin ) ; return mRootLayout . getWidth ( ) / _NUM - pagerActiveElemCenterPosX ; }
protected int calculateNewPagerPosition ( int newActiveElement ) { newActiveElement ++ ; if ( newActiveElement <= _NUM ) newActiveElement = _NUM ; int pagerActiveElemCenterPosX = mPagerElementActiveSize / _NUM + newActiveElement * mPagerElementLeftMargin + ( newActiveElement - _NUM ) * ( mPagerElementNormalSize + mPagerElementRightMargin ) ; return mRootLayout . getWidth ( ) / _NUM - pagerActiveElemCenterPosX ; }
protected int calculateNewPagerPosition ( int newActiveElement ) { newActiveElement ++ ; if ( newActiveElement <= _NUM ) newActiveElement = _NUM ; int pagerActiveElemCenterPosX = mPagerElementActiveSize / _NUM + newActiveElement * mPagerElementLeftMargin + ( newActiveElement - _NUM ) * ( mPagerElementNormalSize + mPagerElementRightMargin ) ; return mRootLayout . getWidth ( ) / _NUM - pagerActiveElemCenterPosX ; }
protected int calculateNewPagerPosition ( int newActiveElement ) { newActiveElement ++ ; if ( newActiveElement <= _NUM ) newActiveElement = _NUM ; int pagerActiveElemCenterPosX = mPagerElementActiveSize / _NUM + newActiveElement * mPagerElementLeftMargin + ( newActiveElement - _NUM ) * ( mPagerElementNormalSize + mPagerElementRightMargin ) ; return mRootLayout . getWidth ( ) / _NUM - pagerActiveElemCenterPosX ; }
public boolean isRegistered ( ObjectName name ) { return mbsInterceptor . isRegistered ( name ) ; }
public boolean isCardScanningAvailable ( ) { try { return CardIOActivity . canReadCardWithCamera ( ) ; } catch ( NoClassDefFoundError e ) { return _BOOL ; } }
public boolean isCardScanningAvailable ( ) { try { return CardIOActivity . canReadCardWithCamera ( ) ; } catch ( NoClassDefFoundError e ) { return _BOOL ; } }
public static Revision create ( long revId , String repositoryName ) { return create ( String . valueOf ( revId ) , repositoryName ) ; }
public static Revision create ( long revId , String repositoryName ) { return create ( String . valueOf ( revId ) , repositoryName ) ; }
public static Revision create ( long revId , String repositoryName ) { return create ( String . valueOf ( revId ) , repositoryName ) ; }
public static String toHeaderElement ( String name , String value ) { return OAuth . percentEncode ( name ) + STRING + OAuth . percentEncode ( value ) + STRING ; }
public static String toHeaderElement ( String name , String value ) { return OAuth . percentEncode ( name ) + STRING + OAuth . percentEncode ( value ) + STRING ; }
public HostScsiDisk findLunDisk ( int hlu , Collection < String > sourceNames , Collection < String > targetNames ) { Map < String , HostHostBusAdapter > hbas = getHostBusAdapters ( ) ; String diskKey = null ; for ( HostScsiTopologyInterface adapter : listScsiTopologyInterfaces ( ) ) { HostHostBusAdapter hba = hbas . get ( adapter . getAdapter ( ) ) ; String sourceName = getSourceName ( hba ) ; if ( ! sourceNames . contains ( sourceName ) || ( adapter . getTarget ( ) == null ) ) { continue ; } for ( HostScsiTopologyTarget target : adapter . getTarget ( ) ) { String targetName = getTargetName ( target ) ; if ( ! targetNames . contains ( targetName ) ) { continue ; } HostScsiTopologyLun lun = findLun ( target , hlu ) ; if ( lun != null ) { String key = lun . getScsiLun ( ) ; if ( diskKey == null ) { diskKey = key ; } else if ( ! StringUtils . equals ( diskKey , key ) ) { throw new IllegalArgumentException ( STRING + hlu + STRING + targetNames ) ; } } } } if ( diskKey == null ) { return null ; } HostScsiDisk disk = getScsiDiskByKey ( diskKey ) ; return disk ; }
@ Override public void removeRedisAppKey ( Application application ) { String suffixCloudUnit = application . getSuffixCloudUnitIO ( ) ; JedisPool pool = null ; Jedis jedis = null ; try { pool = new JedisPool ( new JedisPoolConfig ( ) , redisIp , Integer . parseInt ( redisPort ) , _NUM ) ; jedis = pool . getResource ( ) ; String subNameSpace = concatSubNameSpace ( application ) ; String frontend = STRING + subNameSpace + suffixCloudUnit ; jedis . del ( frontend . toLowerCase ( ) ) ; } catch ( JedisConnectionException | UnsupportedEncodingException e ) { logger . error ( STRING , e ) ; } finally { if ( jedis != null ) { pool . destroy ( ) ; } } }
long parseDir ( String line , String path ) throws IOException { int bytesStart = _NUM ; int bytesEnd = _NUM ; int j = line . length ( ) - _NUM ; innerLoop1 : while ( j >= _NUM ) { char c = line . charAt ( j ) ; if ( Character . isDigit ( c ) ) { bytesEnd = j + _NUM ; break innerLoop1 ; } j -- ; } innerLoop2 : while ( j >= _NUM ) { char c = line . charAt ( j ) ; if ( ! Character . isDigit ( c ) && c != STRING && c != STRING ) { bytesStart = j + _NUM ; break innerLoop2 ; } j -- ; } if ( j < _NUM ) { throw new IOException ( STRING + STRING + path + STRING ) ; } StringBuilder buf = new StringBuilder ( line . substring ( bytesStart , bytesEnd ) ) ; for ( int k = _NUM ; k < buf . length ( ) ; k ++ ) { if ( buf . charAt ( k ) == STRING || buf . charAt ( k ) == STRING ) { buf . deleteCharAt ( k -- ) ; } } return parseBytes ( buf . toString ( ) , path ) ; }
public void addWatch ( FileWatcherUpdateInterface parent , Path path ) { if ( path != null ) { try { WatchKey key = path . register ( watchService , StandardWatchEventKinds . ENTRY_CREATE , StandardWatchEventKinds . ENTRY_DELETE , StandardWatchEventKinds . ENTRY_MODIFY ) ; watcherMap . put ( key , parent ) ; } catch ( IOException e ) { } } }
public void remove ( MenuComponent item ) { synchronized ( getTreeLock ( ) ) { int index = items . indexOf ( item ) ; if ( index >= _NUM ) { remove ( index ) ; } } }
public void zoomOrigin ( int oldGridSize , int newGridSize ) { log . trace ( STRING + origin ) ; origin . setLocation ( origin . x * newGridSize / oldGridSize , origin . y * newGridSize / oldGridSize ) ; }
private double avgDistance ( double [ ] centroid , DBIDs objectIDs , Relation < V > database , int dimension ) { Mean avg = new Mean ( ) ; for ( DBIDIter iter = objectIDs . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { V o = database . get ( iter ) ; avg . put ( Math . abs ( centroid [ dimension ] - o . doubleValue ( dimension ) ) ) ; } return avg . getMean ( ) ; }
public static Element addChildElementCDATAValue ( Element element , String childElementName , String childElementValue , Document document ) { Element newElement = addChildElement ( element , childElementName , document ) ; newElement . appendChild ( document . createCDATASection ( childElementValue ) ) ; return newElement ; }
public static Element addChildElementCDATAValue ( Element element , String childElementName , String childElementValue , Document document ) { Element newElement = addChildElement ( element , childElementName , document ) ; newElement . appendChild ( document . createCDATASection ( childElementValue ) ) ; return newElement ; }
public static Element addChildElementCDATAValue ( Element element , String childElementName , String childElementValue , Document document ) { Element newElement = addChildElement ( element , childElementName , document ) ; newElement . appendChild ( document . createCDATASection ( childElementValue ) ) ; return newElement ; }
public static void copyNoClose ( InputStream i , OutputStream o , int bufferSize ) throws IOException { byte [ ] buffer = new byte [ bufferSize ] ; int size = i . read ( buffer ) ; while ( size > - _NUM ) { o . write ( buffer , _NUM , size ) ; size = i . read ( buffer ) ; } }
public static void copyNoClose ( InputStream i , OutputStream o , int bufferSize ) throws IOException { byte [ ] buffer = new byte [ bufferSize ] ; int size = i . read ( buffer ) ; while ( size > - _NUM ) { o . write ( buffer , _NUM , size ) ; size = i . read ( buffer ) ; } }
private void _init ( Configuration conf ) { try { if ( this . id > _NUM ) { DefaultListener d = new DefaultListener ( ) ; d . upgrade ( conf , this ) ; } if ( ! X . isEmpty ( listener ) ) { String name = listener ; if ( name != null ) { try { Class < ? > c = Class . forName ( name , _BOOL , classLoader ) ; Object o = c . newInstance ( ) ; if ( o instanceof IListener ) { log . info ( STRING + name ) ; IListener l = ( IListener ) o ; l . upgrade ( conf , this ) ; l . onStart ( conf , this ) ; } } catch ( Throwable e ) { log . error ( this . name + STRING + name , e ) ; } } } } catch ( Throwable e ) { log . error ( e . getMessage ( ) , e ) ; } }
private void verifyReplicationModeOnDistributedTransactionProcessingConfiguration ( Logger specificLogger ) { if ( _distributedTransactionProcessingConfiguration . isOverriden ( ) ) { if ( specificLogger . isLoggable ( Level . WARNING ) ) specificLogger . log ( Level . WARNING , STRING + MULTI_SOURCE_MODE + STRING ) ; } }
private void verifyReplicationModeOnDistributedTransactionProcessingConfiguration ( Logger specificLogger ) { if ( _distributedTransactionProcessingConfiguration . isOverriden ( ) ) { if ( specificLogger . isLoggable ( Level . WARNING ) ) specificLogger . log ( Level . WARNING , STRING + MULTI_SOURCE_MODE + STRING ) ; } }
private void verifyReplicationModeOnDistributedTransactionProcessingConfiguration ( Logger specificLogger ) { if ( _distributedTransactionProcessingConfiguration . isOverriden ( ) ) { if ( specificLogger . isLoggable ( Level . WARNING ) ) specificLogger . log ( Level . WARNING , STRING + MULTI_SOURCE_MODE + STRING ) ; } }
private void verifyReplicationModeOnDistributedTransactionProcessingConfiguration ( Logger specificLogger ) { if ( _distributedTransactionProcessingConfiguration . isOverriden ( ) ) { if ( specificLogger . isLoggable ( Level . WARNING ) ) specificLogger . log ( Level . WARNING , STRING + MULTI_SOURCE_MODE + STRING ) ; } }
protected void initExceptionHandlers ( boolean isConnected ) { ExceptionHandlers handlers = AppBeans . get ( STRING , ExceptionHandlers . class ) ; if ( isConnected ) { handlers . createByConfiguration ( ) ; } else { handlers . createMinimalSet ( ) ; } }
protected void initExceptionHandlers ( boolean isConnected ) { ExceptionHandlers handlers = AppBeans . get ( STRING , ExceptionHandlers . class ) ; if ( isConnected ) { handlers . createByConfiguration ( ) ; } else { handlers . createMinimalSet ( ) ; } }
private void addPool ( ) { int newNumPools = ( int ) Math . ceil ( numPools * POOL_GROWTH_FACTOR ) ; numPoolsCounter . incr ( newNumPools - numPools ) ; RegularDegreeEdgePool [ ] newEdgePools = new RegularDegreeEdgePool [ newNumPools ] ; int [ ] newPoolDegrees = new int [ newNumPools ] ; System . arraycopy ( readerAccessibleInfo . edgePools , _NUM , newEdgePools , _NUM , readerAccessibleInfo . edgePools . length ) ; System . arraycopy ( readerAccessibleInfo . poolDegrees , _NUM , newPoolDegrees , _NUM , readerAccessibleInfo . poolDegrees . length ) ; readerAccessibleInfo = new ReaderAccessibleInfo ( newEdgePools , newPoolDegrees , readerAccessibleInfo . nodeDegrees ) ; for ( int i = numPools ; i < newNumPools ; i ++ ) { initPool ( i ) ; } numPools = newNumPools ; currentNumEdgesStored = currentNumEdgesStored ; }
private void addPool ( ) { int newNumPools = ( int ) Math . ceil ( numPools * POOL_GROWTH_FACTOR ) ; numPoolsCounter . incr ( newNumPools - numPools ) ; RegularDegreeEdgePool [ ] newEdgePools = new RegularDegreeEdgePool [ newNumPools ] ; int [ ] newPoolDegrees = new int [ newNumPools ] ; System . arraycopy ( readerAccessibleInfo . edgePools , _NUM , newEdgePools , _NUM , readerAccessibleInfo . edgePools . length ) ; System . arraycopy ( readerAccessibleInfo . poolDegrees , _NUM , newPoolDegrees , _NUM , readerAccessibleInfo . poolDegrees . length ) ; readerAccessibleInfo = new ReaderAccessibleInfo ( newEdgePools , newPoolDegrees , readerAccessibleInfo . nodeDegrees ) ; for ( int i = numPools ; i < newNumPools ; i ++ ) { initPool ( i ) ; } numPools = newNumPools ; currentNumEdgesStored = currentNumEdgesStored ; }
private void addPool ( ) { int newNumPools = ( int ) Math . ceil ( numPools * POOL_GROWTH_FACTOR ) ; numPoolsCounter . incr ( newNumPools - numPools ) ; RegularDegreeEdgePool [ ] newEdgePools = new RegularDegreeEdgePool [ newNumPools ] ; int [ ] newPoolDegrees = new int [ newNumPools ] ; System . arraycopy ( readerAccessibleInfo . edgePools , _NUM , newEdgePools , _NUM , readerAccessibleInfo . edgePools . length ) ; System . arraycopy ( readerAccessibleInfo . poolDegrees , _NUM , newPoolDegrees , _NUM , readerAccessibleInfo . poolDegrees . length ) ; readerAccessibleInfo = new ReaderAccessibleInfo ( newEdgePools , newPoolDegrees , readerAccessibleInfo . nodeDegrees ) ; for ( int i = numPools ; i < newNumPools ; i ++ ) { initPool ( i ) ; } numPools = newNumPools ; currentNumEdgesStored = currentNumEdgesStored ; }
boolean ensureProcessSizeFits ( final ExecutionUnit process , final Rectangle2D rect ) { Dimension processSize = model . getProcessSize ( process ) ; if ( processSize == null ) { return _BOOL ; } if ( rect == null ) { return _BOOL ; } boolean needsResize = _BOOL ; double processWidth = processSize . getWidth ( ) * ( _NUM / model . getZoomFactor ( ) ) ; double processHeight = processSize . getHeight ( ) * ( _NUM / model . getZoomFactor ( ) ) ; double width = processWidth ; double height = processHeight ; if ( processSize != null ) { if ( processWidth < rect . getMaxX ( ) + ProcessDrawer . GRID_X_OFFSET ) { double diff = rect . getMaxX ( ) + ProcessDrawer . GRID_X_OFFSET - processWidth ; if ( diff > ProcessDrawer . GRID_X_OFFSET ) { width += diff ; } else { width += ProcessDrawer . GRID_X_OFFSET ; } needsResize = _BOOL ; } if ( processHeight < rect . getMaxY ( ) + ProcessDrawer . GRID_Y_OFFSET ) { double diff = rect . getMaxY ( ) + ProcessDrawer . GRID_Y_OFFSET - processHeight ; if ( diff > ProcessDrawer . GRID_Y_OFFSET ) { height += diff ; } else { height += ProcessDrawer . GRID_Y_OFFSET ; } needsResize = _BOOL ; } if ( needsResize ) { model . setProcessWidth ( process , width ) ; model . setProcessHeight ( process , height ) ; balance ( ) ; model . fireProcessSizeChanged ( ) ; return _BOOL ; } } return _BOOL ; }
public boolean isEmpty ( ) { synchronized ( actions ) { if ( allowToChange ) { return actions . isEmpty ( ) ; } } return _BOOL ; }
public Explanation idfExplain ( CollectionStatistics collectionStats , TermStatistics termStats [ ] ) { final long docCount = collectionStats . docCount ( ) == - _NUM ? collectionStats . maxDoc ( ) : collectionStats . docCount ( ) ; float idf = _NUM ; List < Explanation > subs = new ArrayList < > ( ) ; for ( final TermStatistics stat : termStats ) { final long df = stat . docFreq ( ) ; final float termIdf = idf ( df , docCount ) ; subs . add ( Explanation . match ( termIdf , STRING + df + STRING + docCount + STRING ) ) ; idf += termIdf ; } return Explanation . match ( idf , STRING , subs ) ; }
public Explanation idfExplain ( CollectionStatistics collectionStats , TermStatistics termStats [ ] ) { final long docCount = collectionStats . docCount ( ) == - _NUM ? collectionStats . maxDoc ( ) : collectionStats . docCount ( ) ; float idf = _NUM ; List < Explanation > subs = new ArrayList < > ( ) ; for ( final TermStatistics stat : termStats ) { final long df = stat . docFreq ( ) ; final float termIdf = idf ( df , docCount ) ; subs . add ( Explanation . match ( termIdf , STRING + df + STRING + docCount + STRING ) ) ; idf += termIdf ; } return Explanation . match ( idf , STRING , subs ) ; }
public Explanation idfExplain ( CollectionStatistics collectionStats , TermStatistics termStats [ ] ) { final long docCount = collectionStats . docCount ( ) == - _NUM ? collectionStats . maxDoc ( ) : collectionStats . docCount ( ) ; float idf = _NUM ; List < Explanation > subs = new ArrayList < > ( ) ; for ( final TermStatistics stat : termStats ) { final long df = stat . docFreq ( ) ; final float termIdf = idf ( df , docCount ) ; subs . add ( Explanation . match ( termIdf , STRING + df + STRING + docCount + STRING ) ) ; idf += termIdf ; } return Explanation . match ( idf , STRING , subs ) ; }
public Explanation idfExplain ( CollectionStatistics collectionStats , TermStatistics termStats [ ] ) { final long docCount = collectionStats . docCount ( ) == - _NUM ? collectionStats . maxDoc ( ) : collectionStats . docCount ( ) ; float idf = _NUM ; List < Explanation > subs = new ArrayList < > ( ) ; for ( final TermStatistics stat : termStats ) { final long df = stat . docFreq ( ) ; final float termIdf = idf ( df , docCount ) ; subs . add ( Explanation . match ( termIdf , STRING + df + STRING + docCount + STRING ) ) ; idf += termIdf ; } return Explanation . match ( idf , STRING , subs ) ; }
public void undiscoverable ( BluetoothAdapter adapter ) { int mask = BluetoothReceiver . SCAN_MODE_CONNECTABLE_FLAG ; if ( ! adapter . isEnabled ( ) ) { fail ( STRING ) ; } int scanMode = adapter . getScanMode ( ) ; if ( scanMode == BluetoothAdapter . SCAN_MODE_CONNECTABLE ) { return ; } BluetoothReceiver receiver = getBluetoothReceiver ( mask ) ; assertEquals ( BluetoothAdapter . SCAN_MODE_CONNECTABLE_DISCOVERABLE , scanMode ) ; long start = System . currentTimeMillis ( ) ; assertTrue ( adapter . setScanMode ( BluetoothAdapter . SCAN_MODE_CONNECTABLE ) ) ; while ( System . currentTimeMillis ( ) - start < DISCOVERABLE_UNDISCOVERABLE_TIMEOUT ) { scanMode = adapter . getScanMode ( ) ; if ( scanMode == BluetoothAdapter . SCAN_MODE_CONNECTABLE && ( receiver . getFiredFlags ( ) & mask ) == mask ) { writeOutput ( String . format ( STRING , ( receiver . getCompletedTime ( ) - start ) ) ) ; removeReceiver ( receiver ) ; return ; } sleep ( POLL_TIME ) ; } int firedFlags = receiver . getFiredFlags ( ) ; removeReceiver ( receiver ) ; fail ( String . format ( STRING + STRING , scanMode , BluetoothAdapter . SCAN_MODE_CONNECTABLE , firedFlags , mask ) ) ; }
private void validateReturnType ( MethodDeclaration methodDecl ) { ITypeBinding returnTypeBinding = getReturnTypeBinding ( methodDecl ) ; if ( returnTypeBinding == null ) { return ; } if ( ClientBundleUtilities . isResourceType ( returnTypeBinding ) || ClientBundleUtilities . isClientBundle ( returnTypeBinding ) ) { return ; } result . addProblem ( ClientBundleProblem . createInvalidReturnType ( methodDecl . getReturnType2 ( ) ) ) ; }
private void validateReturnType ( MethodDeclaration methodDecl ) { ITypeBinding returnTypeBinding = getReturnTypeBinding ( methodDecl ) ; if ( returnTypeBinding == null ) { return ; } if ( ClientBundleUtilities . isResourceType ( returnTypeBinding ) || ClientBundleUtilities . isClientBundle ( returnTypeBinding ) ) { return ; } result . addProblem ( ClientBundleProblem . createInvalidReturnType ( methodDecl . getReturnType2 ( ) ) ) ; }
public final void send ( byte [ ] data , boolean useMAC ) throws InterruptedException { if ( useSenderThread ) { if ( ! useMAC ) { Logger . println ( STRING + System . identityHashCode ( data ) ) ; noMACs . add ( System . identityHashCode ( data ) ) ; } if ( ! outQueue . offer ( data ) ) { Logger . println ( STRING + remoteId + STRING ) ; } } else { sendLock . lock ( ) ; sendBytes ( data , useMAC ) ; sendLock . unlock ( ) ; } }
@ Override public synchronized void destroy ( ) { destroyed = _BOOL ; for ( Thread t : workersThreads ) { t . interrupt ( ) ; } notifyAll ( ) ; }
private boolean tryPopup ( final MouseEvent e ) { if ( e . isPopupTrigger ( ) ) { int idx = getIndexForPoint ( e . getX ( ) , e . getY ( ) ) ; if ( idx != - _NUM ) { try { tabbedPane . setSelectedIndex ( idx ) ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { resetTabbedPane ( ) ; tabbedPane . setSelectedIndex ( idx ) ; } } showMenu ( e ) ; return _BOOL ; } return _BOOL ; }
public DefaultExecutors ( final ILogger logger ) { mLogger = logger ; mBackgroundExecutor = ( ThreadPoolExecutor ) Executors . newCachedThreadPool ( ) ; mForegroundExecutor = new SynchronousExecutor ( ) ; }
public void removeMapElementState ( MapElementState [ ] state ) { for ( int i = _NUM ; i < state . length ; ++ i ) { removeMapElementState ( state [ i ] ) ; } }
public SearchBuilder query ( ConditionBuilder < ? , ? > ... builders ) { query . addAll ( Arrays . asList ( builders ) ) ; return this ; }
public void removeDirectoryRecursive ( String dir ) throws IOException { for ( File f : listFiles ( dir ) ) { String name = f . getName ( ) ; if ( f . isDirectory ( ) ) { if ( ! name . equals ( STRING ) && ! name . equals ( STRING ) ) { removeDirectoryRecursive ( dir + STRING + name ) ; } } else { delete ( dir + STRING + name ) ; } } removeDirectory ( dir ) ; }
public void removeDirectoryRecursive ( String dir ) throws IOException { for ( File f : listFiles ( dir ) ) { String name = f . getName ( ) ; if ( f . isDirectory ( ) ) { if ( ! name . equals ( STRING ) && ! name . equals ( STRING ) ) { removeDirectoryRecursive ( dir + STRING + name ) ; } } else { delete ( dir + STRING + name ) ; } } removeDirectory ( dir ) ; }
public void makeImmutable ( ) { if ( mutable && ( authenticatingAuthority != null ) ) { authenticatingAuthority = Collections . unmodifiableList ( authenticatingAuthority ) ; } mutable = _BOOL ; }
public void moveToPreviousDate ( ) { if ( disableAutoDateSelection && userSelectedItem == null ) return ; if ( selectedDateItem != null ) { Calendar cal = Calendar . getInstance ( ) ; cal . set ( selectedDateItem . getYear ( ) , selectedDateItem . getMonth ( ) , selectedDateItem . getDay ( ) ) ; cal . add ( Calendar . DATE , - _NUM ) ; if ( selectedDateItem . getMonth ( ) != cal . get ( Calendar . MONTH ) ) { selectedDateItem . setDay ( cal . get ( Calendar . DAY_OF_MONTH ) ) ; selectedDateItem . setMonth ( cal . get ( Calendar . MONTH ) ) ; selectedDateItem . setYear ( cal . get ( Calendar . YEAR ) ) ; shouldOverrideComputedDate = _BOOL ; moveToPreviousMonth ( ) ; } else { selectedDateItem . setDay ( cal . get ( Calendar . DAY_OF_MONTH ) ) ; selectedDateItem . setMonth ( cal . get ( Calendar . MONTH ) ) ; selectedDateItem . setYear ( cal . get ( Calendar . YEAR ) ) ; monthViewPagerAdapter . setSelectedItem ( selectedDateItem ) ; } } }
public static boolean matchSecret ( String secret ) { return secretSet . remove ( secret ) ; }
public static boolean matchSecret ( String secret ) { return secretSet . remove ( secret ) ; }
public Kernel newKernel ( String name ) { Kernel kernel = getKernelByName ( name ) ; if ( kernel == null && ! name . equals ( NONE ) ) { kernel = new Kernel ( name ) ; Integer oldSize = Integer . valueOf ( _kernelHashTable . size ( ) ) ; _kernelHashTable . put ( name , kernel ) ; setDirtyAndFirePropertyChange ( KERNEL_LISTLENGTH_CHANGED_PROPERTY , oldSize , Integer . valueOf ( _kernelHashTable . size ( ) ) ) ; } return kernel ; }
private static void transferFrom ( FileChannel channel , InputStream in ) throws IOException { ReadableByteChannel readChannel = Channels . newChannel ( in ) ; if ( ! BROKEN_NIO ) { channel . transferFrom ( readChannel , _NUM , MAX_EMPTYDB_SIZE ) ; } else { ByteBuffer bb = ByteBuffer . allocate ( _NUM ) ; while ( readChannel . read ( bb ) >= _NUM ) { bb . flip ( ) ; channel . write ( bb ) ; bb . clear ( ) ; } } }
public int next ( int current ) { for ( int i = current + _NUM ; i < ( arguments != null ? arguments . size ( ) : _NUM ) ; i ++ ) { if ( getArgument ( i ) instanceof MathContainer ) { return i ; } } throw new ArrayIndexOutOfBoundsException ( STRING ) ; }
public void execute ( AbortableTask task ) { AbortingRunnable ar = new AbortingRunnable ( task ) ; tasks . add ( ar ) ; try { exec . execute ( ar ) ; } catch ( RejectedExecutionException e ) { tasks . remove ( ar ) ; throw e ; } }
public void execute ( AbortableTask task ) { AbortingRunnable ar = new AbortingRunnable ( task ) ; tasks . add ( ar ) ; try { exec . execute ( ar ) ; } catch ( RejectedExecutionException e ) { tasks . remove ( ar ) ; throw e ; } }
public void execute ( AbortableTask task ) { AbortingRunnable ar = new AbortingRunnable ( task ) ; tasks . add ( ar ) ; try { exec . execute ( ar ) ; } catch ( RejectedExecutionException e ) { tasks . remove ( ar ) ; throw e ; } }
public static void report ( ) { if ( ! booted ) return ; ControllerThread . report ( ) ; RuntimeMeasurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . hasMoreElements ( ) ; ) { Organizer organizer = e . nextElement ( ) ; organizer . report ( ) ; } if ( options . FINAL_REPORT_LEVEL >= _NUM ) { EdgeCounts . dumpCounts ( ) ; dcg . dumpGraph ( ) ; } if ( options . REPORT_INTERRUPT_STATS ) { VM . sysWriteln ( STRING ) ; VM . sysWriteln ( STRING , RVMThread . timerTicks ) ; VM . sysWriteln ( STRING , controllerClock ) ; VM . sysWriteln ( STRING , ( int ) methodSamples . getTotalNumberOfSamples ( ) ) ; } }
public static void report ( ) { if ( ! booted ) return ; ControllerThread . report ( ) ; RuntimeMeasurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . hasMoreElements ( ) ; ) { Organizer organizer = e . nextElement ( ) ; organizer . report ( ) ; } if ( options . FINAL_REPORT_LEVEL >= _NUM ) { EdgeCounts . dumpCounts ( ) ; dcg . dumpGraph ( ) ; } if ( options . REPORT_INTERRUPT_STATS ) { VM . sysWriteln ( STRING ) ; VM . sysWriteln ( STRING , RVMThread . timerTicks ) ; VM . sysWriteln ( STRING , controllerClock ) ; VM . sysWriteln ( STRING , ( int ) methodSamples . getTotalNumberOfSamples ( ) ) ; } }
public static void report ( ) { if ( ! booted ) return ; ControllerThread . report ( ) ; RuntimeMeasurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . hasMoreElements ( ) ; ) { Organizer organizer = e . nextElement ( ) ; organizer . report ( ) ; } if ( options . FINAL_REPORT_LEVEL >= _NUM ) { EdgeCounts . dumpCounts ( ) ; dcg . dumpGraph ( ) ; } if ( options . REPORT_INTERRUPT_STATS ) { VM . sysWriteln ( STRING ) ; VM . sysWriteln ( STRING , RVMThread . timerTicks ) ; VM . sysWriteln ( STRING , controllerClock ) ; VM . sysWriteln ( STRING , ( int ) methodSamples . getTotalNumberOfSamples ( ) ) ; } }
public static void report ( ) { if ( ! booted ) return ; ControllerThread . report ( ) ; RuntimeMeasurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . hasMoreElements ( ) ; ) { Organizer organizer = e . nextElement ( ) ; organizer . report ( ) ; } if ( options . FINAL_REPORT_LEVEL >= _NUM ) { EdgeCounts . dumpCounts ( ) ; dcg . dumpGraph ( ) ; } if ( options . REPORT_INTERRUPT_STATS ) { VM . sysWriteln ( STRING ) ; VM . sysWriteln ( STRING , RVMThread . timerTicks ) ; VM . sysWriteln ( STRING , controllerClock ) ; VM . sysWriteln ( STRING , ( int ) methodSamples . getTotalNumberOfSamples ( ) ) ; } }
public static void report ( ) { if ( ! booted ) return ; ControllerThread . report ( ) ; RuntimeMeasurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . hasMoreElements ( ) ; ) { Organizer organizer = e . nextElement ( ) ; organizer . report ( ) ; } if ( options . FINAL_REPORT_LEVEL >= _NUM ) { EdgeCounts . dumpCounts ( ) ; dcg . dumpGraph ( ) ; } if ( options . REPORT_INTERRUPT_STATS ) { VM . sysWriteln ( STRING ) ; VM . sysWriteln ( STRING , RVMThread . timerTicks ) ; VM . sysWriteln ( STRING , controllerClock ) ; VM . sysWriteln ( STRING , ( int ) methodSamples . getTotalNumberOfSamples ( ) ) ; } }
public static void report ( ) { if ( ! booted ) return ; ControllerThread . report ( ) ; RuntimeMeasurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . hasMoreElements ( ) ; ) { Organizer organizer = e . nextElement ( ) ; organizer . report ( ) ; } if ( options . FINAL_REPORT_LEVEL >= _NUM ) { EdgeCounts . dumpCounts ( ) ; dcg . dumpGraph ( ) ; } if ( options . REPORT_INTERRUPT_STATS ) { VM . sysWriteln ( STRING ) ; VM . sysWriteln ( STRING , RVMThread . timerTicks ) ; VM . sysWriteln ( STRING , controllerClock ) ; VM . sysWriteln ( STRING , ( int ) methodSamples . getTotalNumberOfSamples ( ) ) ; } }
public static void report ( ) { if ( ! booted ) return ; ControllerThread . report ( ) ; RuntimeMeasurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . hasMoreElements ( ) ; ) { Organizer organizer = e . nextElement ( ) ; organizer . report ( ) ; } if ( options . FINAL_REPORT_LEVEL >= _NUM ) { EdgeCounts . dumpCounts ( ) ; dcg . dumpGraph ( ) ; } if ( options . REPORT_INTERRUPT_STATS ) { VM . sysWriteln ( STRING ) ; VM . sysWriteln ( STRING , RVMThread . timerTicks ) ; VM . sysWriteln ( STRING , controllerClock ) ; VM . sysWriteln ( STRING , ( int ) methodSamples . getTotalNumberOfSamples ( ) ) ; } }
public static void report ( ) { if ( ! booted ) return ; ControllerThread . report ( ) ; RuntimeMeasurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . hasMoreElements ( ) ; ) { Organizer organizer = e . nextElement ( ) ; organizer . report ( ) ; } if ( options . FINAL_REPORT_LEVEL >= _NUM ) { EdgeCounts . dumpCounts ( ) ; dcg . dumpGraph ( ) ; } if ( options . REPORT_INTERRUPT_STATS ) { VM . sysWriteln ( STRING ) ; VM . sysWriteln ( STRING , RVMThread . timerTicks ) ; VM . sysWriteln ( STRING , controllerClock ) ; VM . sysWriteln ( STRING , ( int ) methodSamples . getTotalNumberOfSamples ( ) ) ; } }
public static void report ( ) { if ( ! booted ) return ; ControllerThread . report ( ) ; RuntimeMeasurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . hasMoreElements ( ) ; ) { Organizer organizer = e . nextElement ( ) ; organizer . report ( ) ; } if ( options . FINAL_REPORT_LEVEL >= _NUM ) { EdgeCounts . dumpCounts ( ) ; dcg . dumpGraph ( ) ; } if ( options . REPORT_INTERRUPT_STATS ) { VM . sysWriteln ( STRING ) ; VM . sysWriteln ( STRING , RVMThread . timerTicks ) ; VM . sysWriteln ( STRING , controllerClock ) ; VM . sysWriteln ( STRING , ( int ) methodSamples . getTotalNumberOfSamples ( ) ) ; } }
public void addChild ( Node child ) { childrenList . add ( child ) ; children . put ( child . getClassName ( ) , child ) ; child . setParent ( this ) ; }
public void putAndEnsureCapacity ( long index , int value ) { int segment = ( int ) ( index > > > SEGMENT_BITS ) ; int position = ( int ) ( index & SEGMENT_MASK ) ; if ( segment >= segments . length ) { grow ( segment + _NUM ) ; segments [ segment ] [ position ] = value ; if ( value != _NUM ) numberOfNonZeroEntries ++ ; } else { final int old = segments [ segment ] [ position ] ; if ( old == _NUM ) { if ( value != _NUM ) { segments [ segment ] [ position ] = value ; numberOfNonZeroEntries ++ ; } } else { segments [ segment ] [ position ] = value ; if ( value == _NUM ) numberOfNonZeroEntries -- ; } } maxIndex = Math . max ( maxIndex , index ) ; }
public void putAndEnsureCapacity ( long index , int value ) { int segment = ( int ) ( index > > > SEGMENT_BITS ) ; int position = ( int ) ( index & SEGMENT_MASK ) ; if ( segment >= segments . length ) { grow ( segment + _NUM ) ; segments [ segment ] [ position ] = value ; if ( value != _NUM ) numberOfNonZeroEntries ++ ; } else { final int old = segments [ segment ] [ position ] ; if ( old == _NUM ) { if ( value != _NUM ) { segments [ segment ] [ position ] = value ; numberOfNonZeroEntries ++ ; } } else { segments [ segment ] [ position ] = value ; if ( value == _NUM ) numberOfNonZeroEntries -- ; } } maxIndex = Math . max ( maxIndex , index ) ; }
public void addAll ( @ NonNull List < T > itemList ) { synchronized ( lock ) { if ( items == null ) { items = new ArrayList < > ( ) ; } items . addAll ( itemList ) ; } if ( notifyOnChange ) { if ( items . size ( ) - itemList . size ( ) != _NUM ) { notifyItemRangeChanged ( items . size ( ) - itemList . size ( ) , itemList . size ( ) ) ; } else { notifyDataSetChanged ( ) ; } } }
@ Override void toXML ( StringBuilder xml , int level ) { indent ( xml , level ) ; xml . append ( STRING ) ; xml . append ( NSObject . NEWLINE ) ; for ( NSObject o : set ) { o . toXML ( xml , level + _NUM ) ; xml . append ( NSObject . NEWLINE ) ; } indent ( xml , level ) ; xml . append ( STRING ) ; }
@ Override void toXML ( StringBuilder xml , int level ) { indent ( xml , level ) ; xml . append ( STRING ) ; xml . append ( NSObject . NEWLINE ) ; for ( NSObject o : set ) { o . toXML ( xml , level + _NUM ) ; xml . append ( NSObject . NEWLINE ) ; } indent ( xml , level ) ; xml . append ( STRING ) ; }
public void stateChanged ( ChangeEvent ce ) { currentSize = slider . getValue ( ) * _NUM ; transition . start ( ) ; }
public void stateChanged ( ChangeEvent ce ) { currentSize = slider . getValue ( ) * _NUM ; transition . start ( ) ; }
public void stateChanged ( ChangeEvent ce ) { currentSize = slider . getValue ( ) * _NUM ; transition . start ( ) ; }
public void stateChanged ( ChangeEvent ce ) { currentSize = slider . getValue ( ) * _NUM ; transition . start ( ) ; }
public void stateChanged ( ChangeEvent ce ) { currentSize = slider . getValue ( ) * _NUM ; transition . start ( ) ; }
public BrdLayerStructure ( Collection < DsnLayer > p_layers ) { layers_list = new ArrayList < BrdLayer > ( p_layers . size ( ) ) ; for ( DsnLayer a_layer : p_layers ) { layers_list . add ( new BrdLayer ( a_layer . layer_no , a_layer . name , a_layer . is_signal ) ) ; } Collections . sort ( layers_list ) ; }
public BrdLayerStructure ( Collection < DsnLayer > p_layers ) { layers_list = new ArrayList < BrdLayer > ( p_layers . size ( ) ) ; for ( DsnLayer a_layer : p_layers ) { layers_list . add ( new BrdLayer ( a_layer . layer_no , a_layer . name , a_layer . is_signal ) ) ; } Collections . sort ( layers_list ) ; }
byte [ ] unzip ( final byte [ ] data ) throws IOException { final InputStream input = new ByteArrayInputStream ( data ) ; final byte [ ] buffer = new byte [ _NUM ] ; final ZipInputStream zip = new ZipInputStream ( input ) ; final ByteArrayOutputStream out = new ByteArrayOutputStream ( data . length ) ; int count = _NUM ; if ( zip . getNextEntry ( ) != null ) { while ( ( count = zip . read ( buffer ) ) != - _NUM ) { out . write ( buffer , _NUM , count ) ; } } out . flush ( ) ; zip . close ( ) ; out . close ( ) ; return out . toByteArray ( ) ; }
byte [ ] unzip ( final byte [ ] data ) throws IOException { final InputStream input = new ByteArrayInputStream ( data ) ; final byte [ ] buffer = new byte [ _NUM ] ; final ZipInputStream zip = new ZipInputStream ( input ) ; final ByteArrayOutputStream out = new ByteArrayOutputStream ( data . length ) ; int count = _NUM ; if ( zip . getNextEntry ( ) != null ) { while ( ( count = zip . read ( buffer ) ) != - _NUM ) { out . write ( buffer , _NUM , count ) ; } } out . flush ( ) ; zip . close ( ) ; out . close ( ) ; return out . toByteArray ( ) ; }
byte [ ] unzip ( final byte [ ] data ) throws IOException { final InputStream input = new ByteArrayInputStream ( data ) ; final byte [ ] buffer = new byte [ _NUM ] ; final ZipInputStream zip = new ZipInputStream ( input ) ; final ByteArrayOutputStream out = new ByteArrayOutputStream ( data . length ) ; int count = _NUM ; if ( zip . getNextEntry ( ) != null ) { while ( ( count = zip . read ( buffer ) ) != - _NUM ) { out . write ( buffer , _NUM , count ) ; } } out . flush ( ) ; zip . close ( ) ; out . close ( ) ; return out . toByteArray ( ) ; }
private void findToken ( String query , boolean ignoreCase ) throws IOException { String token ; boolean found = _BOOL ; do { token = readToken ( ) ; if ( ( ignoreCase && token . equalsIgnoreCase ( query ) ) || token . equals ( query ) ) { found = _BOOL ; } } while ( ! found ) ; }
public static String detectPropertiesPath ( ) { String override = System . getProperty ( STRING ) ; if ( override != null ) { return override ; } String jarPath = detectJarPath ( ) ; String propFile = Constants . PROPS_FILE + STRING ; return fixWhitespaces ( getParentDirectory ( jarPath ) + File . separator + propFile ) ; }
private static Map < String , Object > loadZoneInfoMap ( InputStream in ) throws IOException { Map < String , Object > map = new ConcurrentHashMap < String , Object > ( ) ; DataInputStream din = new DataInputStream ( in ) ; try { readZoneInfoMap ( din , map ) ; } finally { try { din . close ( ) ; } catch ( IOException ex ) { } } map . put ( STRING , new SoftReference < DateTimeZone > ( DateTimeZone . UTC ) ) ; return map ; }
void initDemandAndCollectionMap ( final List < String > prepareFieldNames , final Map < String , BigDecimal > demand , final Map < String , BigDecimal > collection , final Map < String , BigDecimal > rebates ) { if ( prepareFieldNames != null && ! prepareFieldNames . isEmpty ( ) ) for ( final String fieldName : prepareFieldNames ) { demand . put ( fieldName , BigDecimal . ZERO ) ; collection . put ( fieldName , BigDecimal . ZERO ) ; rebates . put ( fieldName , BigDecimal . ZERO ) ; } }
void initDemandAndCollectionMap ( final List < String > prepareFieldNames , final Map < String , BigDecimal > demand , final Map < String , BigDecimal > collection , final Map < String , BigDecimal > rebates ) { if ( prepareFieldNames != null && ! prepareFieldNames . isEmpty ( ) ) for ( final String fieldName : prepareFieldNames ) { demand . put ( fieldName , BigDecimal . ZERO ) ; collection . put ( fieldName , BigDecimal . ZERO ) ; rebates . put ( fieldName , BigDecimal . ZERO ) ; } }
public static int [ ] extractArcs ( ASN1ObjectIdentifier oid ) throws InvalidObjectIdException { String oidStr = oid . getId ( ) ; StringTokenizer strTokCnt = new StringTokenizer ( oidStr , STRING , _BOOL ) ; int arcCount = strTokCnt . countTokens ( ) ; StringTokenizer strTok = new StringTokenizer ( oidStr , STRING , _BOOL ) ; boolean expectDelimiter = _BOOL ; int [ ] arcs = new int [ arcCount ] ; int i = _NUM ; while ( strTok . hasMoreTokens ( ) ) { String token = strTok . nextToken ( ) ; if ( expectDelimiter && ( ! token . equals ( STRING ) || ! strTok . hasMoreTokens ( ) ) ) { throw new InvalidObjectIdException ( res . getString ( STRING ) ) ; } else if ( ! expectDelimiter ) { try { arcs [ i ] = Integer . parseInt ( token ) ; if ( arcs [ i ] < _NUM ) { throw new InvalidObjectIdException ( res . getString ( STRING ) ) ; } i ++ ; } catch ( NumberFormatException ex ) { throw new InvalidObjectIdException ( res . getString ( STRING ) ) ; } } expectDelimiter = ! expectDelimiter ; } return arcs ; }
public static void main ( String [ ] args ) { System . setProperty ( STRING , STRING ) ; JFrame frame = new JFrame ( ) ; frame . setContentPane ( new BowlerStudio3dEngine ( ) ) ; frame . setSize ( _NUM , _NUM ) ; frame . setVisible ( _BOOL ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; }
public static void main ( String [ ] args ) { System . setProperty ( STRING , STRING ) ; JFrame frame = new JFrame ( ) ; frame . setContentPane ( new BowlerStudio3dEngine ( ) ) ; frame . setSize ( _NUM , _NUM ) ; frame . setVisible ( _BOOL ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; }
public static void main ( String [ ] args ) { System . setProperty ( STRING , STRING ) ; JFrame frame = new JFrame ( ) ; frame . setContentPane ( new BowlerStudio3dEngine ( ) ) ; frame . setSize ( _NUM , _NUM ) ; frame . setVisible ( _BOOL ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; }
public static void main ( String [ ] args ) { System . setProperty ( STRING , STRING ) ; JFrame frame = new JFrame ( ) ; frame . setContentPane ( new BowlerStudio3dEngine ( ) ) ; frame . setSize ( _NUM , _NUM ) ; frame . setVisible ( _BOOL ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; }
protected void errorMessage ( String msg ) throws IOException { String str = msg + STRING + m_Tokenizer . toString ( ) ; if ( m_Lines > _NUM ) { int line = Integer . parseInt ( str . replaceAll ( STRING , STRING ) ) ; str = str . replaceAll ( STRING , STRING + ( m_Lines + line - _NUM ) ) ; } throw new IOException ( str ) ; }
public void findLongRunningThreads ( DefaultMutableTreeNode root , Map dumpStore , TreePath [ ] paths , int minOccurence , String regex ) { diffDumps ( STRING , root , dumpStore , paths , minOccurence , regex ) ; }
private String preprocessToJs ( byte [ ] loader ) throws Exception { Pair < ArrayList < Integer > , List < Byte > > data = preprocessRop ( loader ) ; List < Long > longList = new ArrayList < > ( ) ; for ( Integer i : data . first ) { longList . add ( i & _NUM ) ; } String payload = TextUtils . join ( STRING , longList ) ; String relocations = TextUtils . join ( STRING , data . second ) ; return String . format ( STRING , payload , relocations ) ; }
private String preprocessToJs ( byte [ ] loader ) throws Exception { Pair < ArrayList < Integer > , List < Byte > > data = preprocessRop ( loader ) ; List < Long > longList = new ArrayList < > ( ) ; for ( Integer i : data . first ) { longList . add ( i & _NUM ) ; } String payload = TextUtils . join ( STRING , longList ) ; String relocations = TextUtils . join ( STRING , data . second ) ; return String . format ( STRING , payload , relocations ) ; }
public Transfer writeBytes ( byte [ ] data ) throws IOException { if ( data == null ) { writeInt ( - _NUM ) ; } else { writeInt ( data . length ) ; out . write ( data ) ; } return this ; }
public void removeListener ( final IRunningQueryListener l ) { if ( l == null ) throw new IllegalArgumentException ( ) ; listeners . remove ( l ) ; }
public void addModel ( String file , Class modelFormat ) { ModelPoolEntry entry = ModelPool . addFile ( file , modelFormat , transformGroup , textureGroup ) ; if ( entry == null ) return ; PositionTextureVertex [ ] verts = Arrays . copyOf ( entry . vertices , entry . vertices . length ) ; TexturedPolygon [ ] poly = Arrays . copyOf ( entry . faces , entry . faces . length ) ; if ( flip ) { for ( TexturedPolygon face : faces ) { face . flipFace ( ) ; } } copyTo ( verts , poly , _BOOL ) ; }
public EsriShapeExport ( OMGraphicList list , Projection proj , String pathToFile ) { setGraphicList ( list ) ; projection = proj ; filePath = pathToFile ; DEBUG = logger . isLoggable ( Level . FINE ) ; }
@ Override public < T > T instance ( InjectionPoint < T > ip ) { Objects . requireNonNull ( ip ) ; Provider < T > provider = provider ( ip ) ; if ( provider != null ) { return provider . get ( ) ; } else { return null ; } }
static MethodHandle linkMethodHandleConstant ( Class < ? > callerClass , int refKind , Class < ? > defc , String name , Object type ) { try { Lookup lookup = IMPL_LOOKUP . in ( callerClass ) ; assert ( refKindIsValid ( refKind ) ) ; return lookup . linkMethodHandleConstant ( ( byte ) refKind , defc , name , type ) ; } catch ( IllegalAccessException ex ) { Throwable cause = ex . getCause ( ) ; if ( cause instanceof AbstractMethodError ) { throw ( AbstractMethodError ) cause ; } else { Error err = new IllegalAccessError ( ex . getMessage ( ) ) ; throw initCauseFrom ( err , ex ) ; } } catch ( NoSuchMethodException ex ) { Error err = new NoSuchMethodError ( ex . getMessage ( ) ) ; throw initCauseFrom ( err , ex ) ; } catch ( NoSuchFieldException ex ) { Error err = new NoSuchFieldError ( ex . getMessage ( ) ) ; throw initCauseFrom ( err , ex ) ; } catch ( ReflectiveOperationException ex ) { Error err = new IncompatibleClassChangeError ( ) ; throw initCauseFrom ( err , ex ) ; } }
static MethodHandle linkMethodHandleConstant ( Class < ? > callerClass , int refKind , Class < ? > defc , String name , Object type ) { try { Lookup lookup = IMPL_LOOKUP . in ( callerClass ) ; assert ( refKindIsValid ( refKind ) ) ; return lookup . linkMethodHandleConstant ( ( byte ) refKind , defc , name , type ) ; } catch ( IllegalAccessException ex ) { Throwable cause = ex . getCause ( ) ; if ( cause instanceof AbstractMethodError ) { throw ( AbstractMethodError ) cause ; } else { Error err = new IllegalAccessError ( ex . getMessage ( ) ) ; throw initCauseFrom ( err , ex ) ; } } catch ( NoSuchMethodException ex ) { Error err = new NoSuchMethodError ( ex . getMessage ( ) ) ; throw initCauseFrom ( err , ex ) ; } catch ( NoSuchFieldException ex ) { Error err = new NoSuchFieldError ( ex . getMessage ( ) ) ; throw initCauseFrom ( err , ex ) ; } catch ( ReflectiveOperationException ex ) { Error err = new IncompatibleClassChangeError ( ) ; throw initCauseFrom ( err , ex ) ; } }
static MethodHandle linkMethodHandleConstant ( Class < ? > callerClass , int refKind , Class < ? > defc , String name , Object type ) { try { Lookup lookup = IMPL_LOOKUP . in ( callerClass ) ; assert ( refKindIsValid ( refKind ) ) ; return lookup . linkMethodHandleConstant ( ( byte ) refKind , defc , name , type ) ; } catch ( IllegalAccessException ex ) { Throwable cause = ex . getCause ( ) ; if ( cause instanceof AbstractMethodError ) { throw ( AbstractMethodError ) cause ; } else { Error err = new IllegalAccessError ( ex . getMessage ( ) ) ; throw initCauseFrom ( err , ex ) ; } } catch ( NoSuchMethodException ex ) { Error err = new NoSuchMethodError ( ex . getMessage ( ) ) ; throw initCauseFrom ( err , ex ) ; } catch ( NoSuchFieldException ex ) { Error err = new NoSuchFieldError ( ex . getMessage ( ) ) ; throw initCauseFrom ( err , ex ) ; } catch ( ReflectiveOperationException ex ) { Error err = new IncompatibleClassChangeError ( ) ; throw initCauseFrom ( err , ex ) ; } }
static MethodHandle linkMethodHandleConstant ( Class < ? > callerClass , int refKind , Class < ? > defc , String name , Object type ) { try { Lookup lookup = IMPL_LOOKUP . in ( callerClass ) ; assert ( refKindIsValid ( refKind ) ) ; return lookup . linkMethodHandleConstant ( ( byte ) refKind , defc , name , type ) ; } catch ( IllegalAccessException ex ) { Throwable cause = ex . getCause ( ) ; if ( cause instanceof AbstractMethodError ) { throw ( AbstractMethodError ) cause ; } else { Error err = new IllegalAccessError ( ex . getMessage ( ) ) ; throw initCauseFrom ( err , ex ) ; } } catch ( NoSuchMethodException ex ) { Error err = new NoSuchMethodError ( ex . getMessage ( ) ) ; throw initCauseFrom ( err , ex ) ; } catch ( NoSuchFieldException ex ) { Error err = new NoSuchFieldError ( ex . getMessage ( ) ) ; throw initCauseFrom ( err , ex ) ; } catch ( ReflectiveOperationException ex ) { Error err = new IncompatibleClassChangeError ( ) ; throw initCauseFrom ( err , ex ) ; } }
static MethodHandle linkMethodHandleConstant ( Class < ? > callerClass , int refKind , Class < ? > defc , String name , Object type ) { try { Lookup lookup = IMPL_LOOKUP . in ( callerClass ) ; assert ( refKindIsValid ( refKind ) ) ; return lookup . linkMethodHandleConstant ( ( byte ) refKind , defc , name , type ) ; } catch ( IllegalAccessException ex ) { Throwable cause = ex . getCause ( ) ; if ( cause instanceof AbstractMethodError ) { throw ( AbstractMethodError ) cause ; } else { Error err = new IllegalAccessError ( ex . getMessage ( ) ) ; throw initCauseFrom ( err , ex ) ; } } catch ( NoSuchMethodException ex ) { Error err = new NoSuchMethodError ( ex . getMessage ( ) ) ; throw initCauseFrom ( err , ex ) ; } catch ( NoSuchFieldException ex ) { Error err = new NoSuchFieldError ( ex . getMessage ( ) ) ; throw initCauseFrom ( err , ex ) ; } catch ( ReflectiveOperationException ex ) { Error err = new IncompatibleClassChangeError ( ) ; throw initCauseFrom ( err , ex ) ; } }
public static Stream < Transaction > streamSelfAndAllTransactions ( final Transaction transaction ) { final List < Transaction > allTransactions = new ArrayList < > ( ) ; allTransactions . add ( transaction ) ; addTransactionsRecursive ( allTransactions , transaction . getChildTransactions ( ) ) ; return allTransactions . stream ( ) ; }
private void initClassPath ( ) { StringBuilder cpath = new StringBuilder ( ) ; String sep = System . getProperty ( STRING ) ; cpath . append ( options . getScratchDir ( ) + sep ) ; String cp = ( String ) context . getAttribute ( Constants . SERVLET_CLASSPATH ) ; if ( cp == null || cp . equals ( STRING ) ) { cp = options . getClassPath ( ) ; } if ( cp != null ) { classpath = cpath . toString ( ) + cp ; } if ( classpath != null ) { try { classpath = URLDecoder . decode ( classpath , STRING ) ; } catch ( UnsupportedEncodingException e ) { if ( log . isLoggable ( Level . FINE ) ) log . log ( Level . FINE , STRING + classpath , e ) ; } } }
private void initClassPath ( ) { StringBuilder cpath = new StringBuilder ( ) ; String sep = System . getProperty ( STRING ) ; cpath . append ( options . getScratchDir ( ) + sep ) ; String cp = ( String ) context . getAttribute ( Constants . SERVLET_CLASSPATH ) ; if ( cp == null || cp . equals ( STRING ) ) { cp = options . getClassPath ( ) ; } if ( cp != null ) { classpath = cpath . toString ( ) + cp ; } if ( classpath != null ) { try { classpath = URLDecoder . decode ( classpath , STRING ) ; } catch ( UnsupportedEncodingException e ) { if ( log . isLoggable ( Level . FINE ) ) log . log ( Level . FINE , STRING + classpath , e ) ; } } }
private void initClassPath ( ) { StringBuilder cpath = new StringBuilder ( ) ; String sep = System . getProperty ( STRING ) ; cpath . append ( options . getScratchDir ( ) + sep ) ; String cp = ( String ) context . getAttribute ( Constants . SERVLET_CLASSPATH ) ; if ( cp == null || cp . equals ( STRING ) ) { cp = options . getClassPath ( ) ; } if ( cp != null ) { classpath = cpath . toString ( ) + cp ; } if ( classpath != null ) { try { classpath = URLDecoder . decode ( classpath , STRING ) ; } catch ( UnsupportedEncodingException e ) { if ( log . isLoggable ( Level . FINE ) ) log . log ( Level . FINE , STRING + classpath , e ) ; } } }
public static double norm2 ( Point2D A , Point2D B ) { return ( A . getX ( ) - B . getX ( ) ) * ( A . getX ( ) - B . getX ( ) ) + ( A . getY ( ) - B . getY ( ) ) * ( A . getY ( ) - B . getY ( ) ) ; }
public List < Statement > wikibaseStyle ( ) { return built ( ) ; }
public List < Statement > wikibaseStyle ( ) { return built ( ) ; }
public XmlGenerator ( StreamProperties props , Writer w , Charset cs , boolean prettyPrint , XmlNamespace defaultNamespace ) { EnumSet < WriterFlags > flags = EnumSet . of ( WriterFlags . WRITE_HEADER ) ; if ( prettyPrint ) { flags . add ( WriterFlags . PRETTY_PRINT ) ; } try { this . xw = new XmlWriter ( w , flags , cs . name ( ) ) ; } catch ( IOException ioe ) { throw new RuntimeException ( STRING , ioe ) ; } this . rootMetadata = props . getRootMetadata ( ) ; this . defaultNamespace = defaultNamespace ; }
public XmlGenerator ( StreamProperties props , Writer w , Charset cs , boolean prettyPrint , XmlNamespace defaultNamespace ) { EnumSet < WriterFlags > flags = EnumSet . of ( WriterFlags . WRITE_HEADER ) ; if ( prettyPrint ) { flags . add ( WriterFlags . PRETTY_PRINT ) ; } try { this . xw = new XmlWriter ( w , flags , cs . name ( ) ) ; } catch ( IOException ioe ) { throw new RuntimeException ( STRING , ioe ) ; } this . rootMetadata = props . getRootMetadata ( ) ; this . defaultNamespace = defaultNamespace ; }
public XmlGenerator ( StreamProperties props , Writer w , Charset cs , boolean prettyPrint , XmlNamespace defaultNamespace ) { EnumSet < WriterFlags > flags = EnumSet . of ( WriterFlags . WRITE_HEADER ) ; if ( prettyPrint ) { flags . add ( WriterFlags . PRETTY_PRINT ) ; } try { this . xw = new XmlWriter ( w , flags , cs . name ( ) ) ; } catch ( IOException ioe ) { throw new RuntimeException ( STRING , ioe ) ; } this . rootMetadata = props . getRootMetadata ( ) ; this . defaultNamespace = defaultNamespace ; }
public List < StorageFile > createStorageFilesFromS3ObjectSummaries ( List < S3ObjectSummary > s3ObjectSummaries ) { List < StorageFile > storageFiles = new ArrayList < > ( ) ; for ( S3ObjectSummary s3ObjectSummary : s3ObjectSummaries ) { storageFiles . add ( new StorageFile ( s3ObjectSummary . getKey ( ) , s3ObjectSummary . getSize ( ) , null ) ) ; } return storageFiles ; }
public static String fixDesc ( String description , Map < String , MappedClass > oldNamestoClasses ) { if ( description == null || description . length ( ) == _NUM || isPrimitive ( description ) ) { return description ; } if ( description . contains ( STRING ) && description . contains ( STRING ) ) { if ( description . startsWith ( STRING ) || ( description . startsWith ( STRING ) || description . startsWith ( STRING ) ) && description . endsWith ( STRING ) ) { String regex = STRING ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( Pattern . quote ( description ) ) ; for ( int i = _NUM ; i < m . groupCount ( ) ; i ++ ) { String found = m . group ( i ) ; description = description . replace ( found , fixDesc ( found , oldNamestoClasses ) ) ; } return description ; } } else { MappedClass mc = oldNamestoClasses . get ( description ) ; if ( mc == null ) { return description ; } return mc . getNewName ( ) ; } return description ; }
static FileChannel newFileChannel ( String pathForWindows , String pathToCheck , Set < ? extends OpenOption > options , long pSecurityDescriptor ) throws WindowsException { Flags flags = Flags . toFlags ( options ) ; if ( ! flags . read && ! flags . write ) { if ( flags . append ) { flags . write = _BOOL ; } else { flags . read = _BOOL ; } } if ( flags . read && flags . append ) throw new IllegalArgumentException ( STRING ) ; if ( flags . append && flags . truncateExisting ) throw new IllegalArgumentException ( STRING ) ; FileDescriptor fdObj = open ( pathForWindows , pathToCheck , flags , pSecurityDescriptor ) ; return FileChannelImpl . open ( fdObj , pathForWindows , flags . read , flags . write , flags . append , null ) ; }
public void mouseMove ( int x , int y , int dx , int dy , int button ) { if ( ( mouseX < _NUM ) || ( Math . abs ( dx ) > _NUM ) || ( Math . abs ( dy ) > _NUM ) ) { dx = _NUM ; dy = _NUM ; } else { dx = x - mouseX ; dy = y - mouseY ; } mouseX = x ; mouseY = y ; switch ( button ) { case _NUM : mouseX = - _NUM ; mouseY = - _NUM ; break ; case _NUM : long now = System . currentTimeMillis ( ) ; long elapsed = now - timestamp ; timestamp = now ; double delta = Math . sqrt ( dx * dx + dy * dy ) ; velocity = ( _NUM * delta / ( _NUM + elapsed ) ) * _NUM + _NUM * velocity ; viewpointNode . drag ( dx , dy ) ; lastDx = dx ; lastDy = dy ; break ; case _NUM : viewpointNode . translateInScreenPlane ( - dx , - dy ) ; break ; case _NUM : viewpointNode . rotate ( dy , dx ) ; break ; } }
public Options resourceDirs ( List < File > value ) { resourceDirs . clear ( ) ; resourceDirs . addAll ( value ) ; return this ; }
@ Override public void beginWindow ( long windowId ) { currentCursor = ( currentCursor + _NUM ) % windowSize ; lastExpiredWindowState = states . get ( currentCursor ) ; states . set ( currentCursor , createWindowState ( ) ) ; }
@ Override public void beginWindow ( long windowId ) { currentCursor = ( currentCursor + _NUM ) % windowSize ; lastExpiredWindowState = states . get ( currentCursor ) ; states . set ( currentCursor , createWindowState ( ) ) ; }
@ Override public void beginWindow ( long windowId ) { currentCursor = ( currentCursor + _NUM ) % windowSize ; lastExpiredWindowState = states . get ( currentCursor ) ; states . set ( currentCursor , createWindowState ( ) ) ; }
@ Override public void beginWindow ( long windowId ) { currentCursor = ( currentCursor + _NUM ) % windowSize ; lastExpiredWindowState = states . get ( currentCursor ) ; states . set ( currentCursor , createWindowState ( ) ) ; }
@ Override public void beginWindow ( long windowId ) { currentCursor = ( currentCursor + _NUM ) % windowSize ; lastExpiredWindowState = states . get ( currentCursor ) ; states . set ( currentCursor , createWindowState ( ) ) ; }
private static void createScript ( ) throws Exception { Class . forName ( STRING ) ; Connection conn = DriverManager . getConnection ( STRING ) ; Statement stat = conn . createStatement ( ) ; stat . execute ( STRING ) ; stat . execute ( STRING ) ; stat . execute ( STRING ) ; stat . close ( ) ; conn . close ( ) ; }
protected long outputOffset ( ) { return _bytesWritten + _outputTail ; }
protected long outputOffset ( ) { return _bytesWritten + _outputTail ; }
public int size ( ) { return readMethods . size ( ) ; }
private String readLine ( InputStream inputStream ) throws IOException { int counter = _NUM ; int increment = _NUM ; int bufferSize = increment ; byte [ ] lineBuffer = new byte [ bufferSize ] ; byte [ ] crlfBuffer = new byte [ _NUM ] ; int crlfCounter = _NUM ; while ( _BOOL ) { char ch ; int i = inputStream . read ( ) ; if ( i == - _NUM ) { throw new IOException ( STRING ) ; } else ch = ( char ) ( i & _NUM ) ; if ( this . maxMessageSize > _NUM ) { this . sizeCounter -- ; if ( this . sizeCounter <= _NUM ) throw new IOException ( STRING ) ; } if ( ch != STRING ) lineBuffer [ counter ++ ] = ( byte ) ( i & _NUM ) ; else if ( counter == _NUM ) crlfBuffer [ crlfCounter ++ ] = ( byte ) STRING ; if ( ch == STRING ) { if ( counter == _NUM && crlfCounter > _NUM ) { crlfBuffer [ crlfCounter ++ ] = ( byte ) STRING ; } break ; } if ( counter == bufferSize ) { byte [ ] tempBuffer = new byte [ bufferSize + increment ] ; System . arraycopy ( ( Object ) lineBuffer , _NUM , ( Object ) tempBuffer , _NUM , bufferSize ) ; bufferSize = bufferSize + increment ; lineBuffer = tempBuffer ; } } if ( counter == _NUM && crlfCounter > _NUM ) { return new String ( crlfBuffer , _NUM , crlfCounter , STRING ) ; } else { return new String ( lineBuffer , _NUM , counter , STRING ) ; } }
private String readLine ( InputStream inputStream ) throws IOException { int counter = _NUM ; int increment = _NUM ; int bufferSize = increment ; byte [ ] lineBuffer = new byte [ bufferSize ] ; byte [ ] crlfBuffer = new byte [ _NUM ] ; int crlfCounter = _NUM ; while ( _BOOL ) { char ch ; int i = inputStream . read ( ) ; if ( i == - _NUM ) { throw new IOException ( STRING ) ; } else ch = ( char ) ( i & _NUM ) ; if ( this . maxMessageSize > _NUM ) { this . sizeCounter -- ; if ( this . sizeCounter <= _NUM ) throw new IOException ( STRING ) ; } if ( ch != STRING ) lineBuffer [ counter ++ ] = ( byte ) ( i & _NUM ) ; else if ( counter == _NUM ) crlfBuffer [ crlfCounter ++ ] = ( byte ) STRING ; if ( ch == STRING ) { if ( counter == _NUM && crlfCounter > _NUM ) { crlfBuffer [ crlfCounter ++ ] = ( byte ) STRING ; } break ; } if ( counter == bufferSize ) { byte [ ] tempBuffer = new byte [ bufferSize + increment ] ; System . arraycopy ( ( Object ) lineBuffer , _NUM , ( Object ) tempBuffer , _NUM , bufferSize ) ; bufferSize = bufferSize + increment ; lineBuffer = tempBuffer ; } } if ( counter == _NUM && crlfCounter > _NUM ) { return new String ( crlfBuffer , _NUM , crlfCounter , STRING ) ; } else { return new String ( lineBuffer , _NUM , counter , STRING ) ; } }
protected void padSelectedTab ( int tabPlacement , int selectedIndex ) { if ( selectedIndex >= _NUM ) { Rectangle selRect = rects [ selectedIndex ] ; Insets padInsets = getSelectedTabPadInsets ( tabPlacement ) ; selRect . x -= padInsets . left ; selRect . width += ( padInsets . left + padInsets . right ) ; selRect . y -= padInsets . top ; selRect . height += ( padInsets . top + padInsets . bottom ) ; } }
protected void padSelectedTab ( int tabPlacement , int selectedIndex ) { if ( selectedIndex >= _NUM ) { Rectangle selRect = rects [ selectedIndex ] ; Insets padInsets = getSelectedTabPadInsets ( tabPlacement ) ; selRect . x -= padInsets . left ; selRect . width += ( padInsets . left + padInsets . right ) ; selRect . y -= padInsets . top ; selRect . height += ( padInsets . top + padInsets . bottom ) ; } }
public static void streamContentToBrowser ( HttpServletResponse response , InputStream in , int length , String contentType , String fileName ) throws IOException { setResponseBrowserProxyNoCache ( response ) ; response . setContentLength ( length ) ; if ( contentType != null ) { response . setContentType ( contentType ) ; } if ( fileName != null ) { response . setHeader ( STRING , STRING + fileName + STRING ) ; } OutputStream out = response . getOutputStream ( ) ; try { streamContent ( out , in , length ) ; } catch ( IOException e ) { out . close ( ) ; throw e ; } out . flush ( ) ; out . close ( ) ; }
public static void streamContentToBrowser ( HttpServletResponse response , InputStream in , int length , String contentType , String fileName ) throws IOException { setResponseBrowserProxyNoCache ( response ) ; response . setContentLength ( length ) ; if ( contentType != null ) { response . setContentType ( contentType ) ; } if ( fileName != null ) { response . setHeader ( STRING , STRING + fileName + STRING ) ; } OutputStream out = response . getOutputStream ( ) ; try { streamContent ( out , in , length ) ; } catch ( IOException e ) { out . close ( ) ; throw e ; } out . flush ( ) ; out . close ( ) ; }
public static void streamContentToBrowser ( HttpServletResponse response , InputStream in , int length , String contentType , String fileName ) throws IOException { setResponseBrowserProxyNoCache ( response ) ; response . setContentLength ( length ) ; if ( contentType != null ) { response . setContentType ( contentType ) ; } if ( fileName != null ) { response . setHeader ( STRING , STRING + fileName + STRING ) ; } OutputStream out = response . getOutputStream ( ) ; try { streamContent ( out , in , length ) ; } catch ( IOException e ) { out . close ( ) ; throw e ; } out . flush ( ) ; out . close ( ) ; }
public static void streamContentToBrowser ( HttpServletResponse response , InputStream in , int length , String contentType , String fileName ) throws IOException { setResponseBrowserProxyNoCache ( response ) ; response . setContentLength ( length ) ; if ( contentType != null ) { response . setContentType ( contentType ) ; } if ( fileName != null ) { response . setHeader ( STRING , STRING + fileName + STRING ) ; } OutputStream out = response . getOutputStream ( ) ; try { streamContent ( out , in , length ) ; } catch ( IOException e ) { out . close ( ) ; throw e ; } out . flush ( ) ; out . close ( ) ; }
public int compareTo ( AppVersion other ) { int result = major - other . major ; if ( result == _NUM ) { result = minor - other . minor ; } if ( result == _NUM ) { result = patch - other . patch ; } if ( result == _NUM && ( milestone > - _NUM || other . milestone > - _NUM ) ) { if ( milestone > - _NUM ) { if ( other . milestone == - _NUM ) { result = - _NUM ; } else { result = milestone - other . milestone ; } } else { if ( other . milestone > - _NUM ) { result = _NUM ; } } } if ( result == _NUM && ! ObjectUtil . nullEquals ( modifier , other . modifier ) ) { if ( modifier == null ) { result = _NUM ; } else if ( other . modifier == null ) { result = - _NUM ; } else { result = modifier . compareToIgnoreCase ( other . modifier ) ; } } return result ; }
public int compareTo ( AppVersion other ) { int result = major - other . major ; if ( result == _NUM ) { result = minor - other . minor ; } if ( result == _NUM ) { result = patch - other . patch ; } if ( result == _NUM && ( milestone > - _NUM || other . milestone > - _NUM ) ) { if ( milestone > - _NUM ) { if ( other . milestone == - _NUM ) { result = - _NUM ; } else { result = milestone - other . milestone ; } } else { if ( other . milestone > - _NUM ) { result = _NUM ; } } } if ( result == _NUM && ! ObjectUtil . nullEquals ( modifier , other . modifier ) ) { if ( modifier == null ) { result = _NUM ; } else if ( other . modifier == null ) { result = - _NUM ; } else { result = modifier . compareToIgnoreCase ( other . modifier ) ; } } return result ; }
public int compareTo ( AppVersion other ) { int result = major - other . major ; if ( result == _NUM ) { result = minor - other . minor ; } if ( result == _NUM ) { result = patch - other . patch ; } if ( result == _NUM && ( milestone > - _NUM || other . milestone > - _NUM ) ) { if ( milestone > - _NUM ) { if ( other . milestone == - _NUM ) { result = - _NUM ; } else { result = milestone - other . milestone ; } } else { if ( other . milestone > - _NUM ) { result = _NUM ; } } } if ( result == _NUM && ! ObjectUtil . nullEquals ( modifier , other . modifier ) ) { if ( modifier == null ) { result = _NUM ; } else if ( other . modifier == null ) { result = - _NUM ; } else { result = modifier . compareToIgnoreCase ( other . modifier ) ; } } return result ; }
public int compareTo ( AppVersion other ) { int result = major - other . major ; if ( result == _NUM ) { result = minor - other . minor ; } if ( result == _NUM ) { result = patch - other . patch ; } if ( result == _NUM && ( milestone > - _NUM || other . milestone > - _NUM ) ) { if ( milestone > - _NUM ) { if ( other . milestone == - _NUM ) { result = - _NUM ; } else { result = milestone - other . milestone ; } } else { if ( other . milestone > - _NUM ) { result = _NUM ; } } } if ( result == _NUM && ! ObjectUtil . nullEquals ( modifier , other . modifier ) ) { if ( modifier == null ) { result = _NUM ; } else if ( other . modifier == null ) { result = - _NUM ; } else { result = modifier . compareToIgnoreCase ( other . modifier ) ; } } return result ; }
public static DayOfWeek asDay ( String day ) { DayOfWeek dayOfWeek = DAYMAP . get ( day . toLowerCase ( ) ) ; if ( dayOfWeek == null ) LOGGER . warn ( STRING , day ) ; return dayOfWeek ; }
public StepsChain then ( Step step ) { steps . add ( step ) ; return this ; }
public static File relativeFile ( File f ) { if ( f . isAbsolute ( ) ) { f = relativeFile ( new File ( STRING ) , f ) ; } return f ; }
public java . lang . StringBuffer append ( java . lang . Object obj ) { internal . append ( obj ) ; return this ; }
public java . lang . StringBuffer append ( java . lang . Object obj ) { internal . append ( obj ) ; return this ; }
public void addCRL ( X509CRLHolder crl ) { crls . add ( crl . toASN1Structure ( ) ) ; }
public void addCRL ( X509CRLHolder crl ) { crls . add ( crl . toASN1Structure ( ) ) ; }
public boolean validation ( ) throws ParallelTaskInvalidException { ParallelTask task = new ParallelTask ( ) ; targetHostMeta = new TargetHostMeta ( targetHosts ) ; task = new ParallelTask ( requestProtocol , concurrency , httpMeta , targetHostMeta , sshMeta , tcpMeta , udpMeta , pingMeta , null , responseContext , replacementVarMapNodeSpecific , replacementVarMap , requestReplacementType , config ) ; boolean valid = _BOOL ; try { valid = task . validateWithFillDefault ( ) ; } catch ( ParallelTaskInvalidException e ) { logger . info ( STRING + e ) ; } return valid ; }
public boolean validation ( ) throws ParallelTaskInvalidException { ParallelTask task = new ParallelTask ( ) ; targetHostMeta = new TargetHostMeta ( targetHosts ) ; task = new ParallelTask ( requestProtocol , concurrency , httpMeta , targetHostMeta , sshMeta , tcpMeta , udpMeta , pingMeta , null , responseContext , replacementVarMapNodeSpecific , replacementVarMap , requestReplacementType , config ) ; boolean valid = _BOOL ; try { valid = task . validateWithFillDefault ( ) ; } catch ( ParallelTaskInvalidException e ) { logger . info ( STRING + e ) ; } return valid ; }
public static boolean urlEqualsHostIgnoreCase ( String endpointUrl , String url ) { try { return urlEqualsHostIgnoreCase ( new URI ( endpointUrl ) , new URI ( url ) ) ; } catch ( URISyntaxException e ) { return _BOOL ; } }
private void addToAccessControlEntries ( Integer objectId , Integer parentId , List < byte [ ] > sids ) throws IOException { if ( sids . isEmpty ( ) ) { collectNewObjectSIDs ( parentId , sids ) ; } TableImpl acEntries = getAccessControlEntries ( ) ; ColumnImpl acmCol = acEntries . getColumn ( ACE_COL_ACM ) ; ColumnImpl inheritCol = acEntries . getColumn ( ACE_COL_F_INHERITABLE ) ; ColumnImpl objIdCol = acEntries . getColumn ( ACE_COL_OBJECT_ID ) ; ColumnImpl sidCol = acEntries . getColumn ( ACE_COL_SID ) ; List < Object [ ] > aceRows = new ArrayList < Object [ ] > ( sids . size ( ) ) ; for ( byte [ ] sid : sids ) { Object [ ] aceRow = new Object [ acEntries . getColumnCount ( ) ] ; acmCol . setRowValue ( aceRow , SYS_FULL_ACCESS_ACM ) ; inheritCol . setRowValue ( aceRow , Boolean . FALSE ) ; objIdCol . setRowValue ( aceRow , objectId ) ; sidCol . setRowValue ( aceRow , sid ) ; aceRows . add ( aceRow ) ; } acEntries . addRows ( aceRows ) ; }
public static double [ ] [ ] random ( int m , int n ) { double [ ] [ ] matres = new double [ m ] [ ] ; for ( int i = _NUM ; i < m ; ++ i ) { matres [ i ] = new double [ n ] ; for ( int j = _NUM ; j < n ; ++ j ) { matres [ i ] [ j ] = Math . random ( ) ; } } return ( matres ) ; }
public boolean exists ( MonKey key ) { return map . containsKey ( key ) ; }
public boolean exists ( MonKey key ) { return map . containsKey ( key ) ; }
public boolean exists ( MonKey key ) { return map . containsKey ( key ) ; }
public boolean exists ( MonKey key ) { return map . containsKey ( key ) ; }
@ Override public String toStringNoWeight ( int afterDecimalPoint ) { StringBuffer text = new StringBuffer ( ) ; for ( int i = _NUM ; i < m_AttValues . length ; i ++ ) { if ( i > _NUM ) { text . append ( STRING ) ; } text . append ( toString ( i , afterDecimalPoint ) ) ; } return text . toString ( ) ; }
@ Override public String toStringNoWeight ( int afterDecimalPoint ) { StringBuffer text = new StringBuffer ( ) ; for ( int i = _NUM ; i < m_AttValues . length ; i ++ ) { if ( i > _NUM ) { text . append ( STRING ) ; } text . append ( toString ( i , afterDecimalPoint ) ) ; } return text . toString ( ) ; }
public String parseDTDMarkup ( ) throws IOException { StringBuilder strBuff = new StringBuilder ( ) ; ch = readCh ( ) ; while ( _BOOL ) { switch ( ch ) { case STRING : ch = readCh ( ) ; return strBuff . toString ( ) ; case - _NUM : error ( STRING ) ; return strBuff . toString ( ) ; case STRING : ln ++ ; ch = readCh ( ) ; lfCount ++ ; break ; case STRING : ch = readCh ( ) ; break ; case STRING : ln ++ ; if ( ( ch = readCh ( ) ) == STRING ) { ch = readCh ( ) ; crlfCount ++ ; } else { crCount ++ ; } break ; default : strBuff . append ( ( char ) ( ch & _NUM ) ) ; ch = readCh ( ) ; break ; } } }
public Config ( ) { this ( null , null , ! DISABLE_PERSIST_BACKUP , ! DISABLE_REGISTER_INTEREST ) ; }
public final int moveMade ( long now , boolean useIncrement ) { stopTimer ( now ) ; ArrayList < TimeControlField > tc = tcData . getTC ( whiteToMove ) ; Pair < Integer , Integer > tcInfo = getCurrentTC ( whiteToMove ) ; int tcIdx = tcInfo . first ; int movesToTc = tcInfo . second ; int remaining = getRemainingTime ( whiteToMove , now ) ; if ( useIncrement ) { remaining += tc . get ( tcIdx ) . increment ; if ( movesToTc == _NUM ) { if ( tcIdx + _NUM < tc . size ( ) ) tcIdx ++ ; remaining += tc . get ( tcIdx ) . timeControl ; } } elapsed = _NUM ; return remaining ; }
public static String print ( Node node , String encoding ) { if ( node == null ) { return null ; } try { TransformerFactory tFactory = TransformerFactory . newInstance ( ) ; Transformer transformer = tFactory . newTransformer ( ) ; transformer . setOutputProperty ( STRING , STRING ) ; transformer . setOutputProperty ( STRING , encoding ) ; DOMSource source = new DOMSource ( node ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( _NUM ) ; StreamResult result = new StreamResult ( os ) ; transformer . transform ( source , result ) ; return os . toString ( encoding ) ; } catch ( Exception e ) { return null ; } }
public HttpCookie ( String name , String value ) { String ntrim = name . trim ( ) ; if ( ! isValidName ( ntrim ) ) { throw new IllegalArgumentException ( STRING + name ) ; } this . name = ntrim ; this . value = value ; }
public void addHeaderView ( View view , int viewHeight , int expandHeight ) { if ( expandHeight != - _NUM ) { mHeaderViewExpandHeight = ScreenUtil . dip2px ( mContext , expandHeight ) ; } mHeaderViews . clear ( ) ; mHeaderView = view ; if ( mHeaderView . getLayoutParams ( ) == null ) { mHeaderView . setLayoutParams ( new LinearLayout . LayoutParams ( LayoutParams . MATCH_PARENT , ScreenUtil . dip2px ( mContext , viewHeight ) ) ) ; } markHeaderViewHeight ( mHeaderView ) ; mHeaderView . getLayoutParams ( ) . height = _NUM ; mHeaderViews . add ( mHeaderView ) ; if ( mAdapter != null ) { if ( ! ( mAdapter instanceof XWrapAdapter ) ) { mAdapter = new XWrapAdapter ( mHeaderViews , mFootViews , mAdapter ) ; } } }
public OpenSAMLTest ( String testName ) throws KeyStoreException , FileNotFoundException , CertificateException , IOException , NoSuchAlgorithmException { super ( testName ) ; PropertyConfigurator . configure ( LOG_FILE ) ; ks = KeyStore . getInstance ( STRING ) ; InputStream is = new FileInputStream ( new File ( path ) ) ; try { ks . load ( is , password ) ; } finally { if ( is != null ) { is . close ( ) ; } } }
public static String readString ( final JSONObject jsonObject , final String key , final boolean required , final boolean notNull ) throws JSONException { if ( required ) { return jsonObject . getString ( key ) ; } if ( notNull && jsonObject . isNull ( key ) ) { throw new JSONException ( String . format ( Locale . US , NULL_VALUE_FORMAT_OBJECT , key ) ) ; } String value = null ; if ( ! jsonObject . isNull ( key ) ) { value = jsonObject . getString ( key ) ; } return value ; }
public boolean addRules ( ArrayList < Rule > ruleList ) { for ( int i = _NUM ; i < ruleList . size ( ) ; i ++ ) { if ( ! super . validRule ( ruleList . get ( i ) ) ) { return _BOOL ; } if ( ! validRule ( ruleList . get ( i ) ) ) { return _BOOL ; } } this . rules = ruleList ; updateVarsAndTerminals ( ) ; return _BOOL ; }
public boolean addRules ( ArrayList < Rule > ruleList ) { for ( int i = _NUM ; i < ruleList . size ( ) ; i ++ ) { if ( ! super . validRule ( ruleList . get ( i ) ) ) { return _BOOL ; } if ( ! validRule ( ruleList . get ( i ) ) ) { return _BOOL ; } } this . rules = ruleList ; updateVarsAndTerminals ( ) ; return _BOOL ; }
public boolean addRules ( ArrayList < Rule > ruleList ) { for ( int i = _NUM ; i < ruleList . size ( ) ; i ++ ) { if ( ! super . validRule ( ruleList . get ( i ) ) ) { return _BOOL ; } if ( ! validRule ( ruleList . get ( i ) ) ) { return _BOOL ; } } this . rules = ruleList ; updateVarsAndTerminals ( ) ; return _BOOL ; }
public Builder ( ) { }
public void displayState ( ) { PrintWriter xout = context . get ( Log . outKey ) ; xout . println ( STRING + fileObjectHistory ) ; xout . println ( STRING + openTypeNames ) ; xout . println ( STRING + generatedSourceNames ) ; xout . println ( STRING + generatedClasses . keySet ( ) ) ; xout . println ( STRING + aggregateGeneratedSourceNames ) ; xout . println ( STRING + aggregateGeneratedClassNames ) ; }
public void displayState ( ) { PrintWriter xout = context . get ( Log . outKey ) ; xout . println ( STRING + fileObjectHistory ) ; xout . println ( STRING + openTypeNames ) ; xout . println ( STRING + generatedSourceNames ) ; xout . println ( STRING + generatedClasses . keySet ( ) ) ; xout . println ( STRING + aggregateGeneratedSourceNames ) ; xout . println ( STRING + aggregateGeneratedClassNames ) ; }
private void relax ( Integer node ) { double timeNow = times . get ( node ) ; int to ; double timeTo ; for ( ScheduleEntry se : oracle . getConnected ( node , timeNow ) ) { to = se . getTo ( ) ; if ( visited . contains ( to ) ) { continue ; } timeTo = se . getTime ( ) + se . getDuration ( ) ; if ( timeTo < times . get ( to ) ) { prevHops . put ( to , se ) ; setTime ( to , timeTo ) ; } } }
public SearchSourceBuilder noFields ( ) { this . fieldNames = Collections . emptyList ( ) ; return this ; }
private static void checkSharedVocabularyChecksumsForPackedGrammars ( final List < PackedGrammar > packed_grammars ) { String previous_checksum = STRING ; for ( PackedGrammar grammar : packed_grammars ) { final String checksum = grammar . computeVocabularyChecksum ( ) ; if ( previous_checksum . isEmpty ( ) ) { previous_checksum = checksum ; } else { if ( ! checksum . equals ( previous_checksum ) ) { throw new RuntimeException ( STRING + STRING ) ; } previous_checksum = checksum ; } } }
private static void checkSharedVocabularyChecksumsForPackedGrammars ( final List < PackedGrammar > packed_grammars ) { String previous_checksum = STRING ; for ( PackedGrammar grammar : packed_grammars ) { final String checksum = grammar . computeVocabularyChecksum ( ) ; if ( previous_checksum . isEmpty ( ) ) { previous_checksum = checksum ; } else { if ( ! checksum . equals ( previous_checksum ) ) { throw new RuntimeException ( STRING + STRING ) ; } previous_checksum = checksum ; } } }
private static void checkSharedVocabularyChecksumsForPackedGrammars ( final List < PackedGrammar > packed_grammars ) { String previous_checksum = STRING ; for ( PackedGrammar grammar : packed_grammars ) { final String checksum = grammar . computeVocabularyChecksum ( ) ; if ( previous_checksum . isEmpty ( ) ) { previous_checksum = checksum ; } else { if ( ! checksum . equals ( previous_checksum ) ) { throw new RuntimeException ( STRING + STRING ) ; } previous_checksum = checksum ; } } }
public void runSessions ( Session [ ] sessions ) throws Exception { this . sessions = sessions ; elementsIterator = testElements . iterator ( ) ; while ( elementsIterator . hasNext ( ) ) { Object obj = elementsIterator . next ( ) ; if ( obj instanceof ProtocolElement ) { ProtocolElement test = ( ProtocolElement ) obj ; test . testProtocol ( sessions , continueAfterFailure ) ; } } }
public void runSessions ( Session [ ] sessions ) throws Exception { this . sessions = sessions ; elementsIterator = testElements . iterator ( ) ; while ( elementsIterator . hasNext ( ) ) { Object obj = elementsIterator . next ( ) ; if ( obj instanceof ProtocolElement ) { ProtocolElement test = ( ProtocolElement ) obj ; test . testProtocol ( sessions , continueAfterFailure ) ; } } }
public void runSessions ( Session [ ] sessions ) throws Exception { this . sessions = sessions ; elementsIterator = testElements . iterator ( ) ; while ( elementsIterator . hasNext ( ) ) { Object obj = elementsIterator . next ( ) ; if ( obj instanceof ProtocolElement ) { ProtocolElement test = ( ProtocolElement ) obj ; test . testProtocol ( sessions , continueAfterFailure ) ; } } }
public void runSessions ( Session [ ] sessions ) throws Exception { this . sessions = sessions ; elementsIterator = testElements . iterator ( ) ; while ( elementsIterator . hasNext ( ) ) { Object obj = elementsIterator . next ( ) ; if ( obj instanceof ProtocolElement ) { ProtocolElement test = ( ProtocolElement ) obj ; test . testProtocol ( sessions , continueAfterFailure ) ; } } }
public void runSessions ( Session [ ] sessions ) throws Exception { this . sessions = sessions ; elementsIterator = testElements . iterator ( ) ; while ( elementsIterator . hasNext ( ) ) { Object obj = elementsIterator . next ( ) ; if ( obj instanceof ProtocolElement ) { ProtocolElement test = ( ProtocolElement ) obj ; test . testProtocol ( sessions , continueAfterFailure ) ; } } }
public void runSessions ( Session [ ] sessions ) throws Exception { this . sessions = sessions ; elementsIterator = testElements . iterator ( ) ; while ( elementsIterator . hasNext ( ) ) { Object obj = elementsIterator . next ( ) ; if ( obj instanceof ProtocolElement ) { ProtocolElement test = ( ProtocolElement ) obj ; test . testProtocol ( sessions , continueAfterFailure ) ; } } }
public static String removeUrlScheme ( String aUrl ) { String urlRetValue = aUrl ; if ( null != aUrl ) { if ( aUrl . startsWith ( HTTP_SCHEME ) ) { urlRetValue = aUrl . substring ( HTTP_SCHEME . length ( ) ) ; } else if ( aUrl . startsWith ( HTTPS_SCHEME ) ) { urlRetValue = aUrl . substring ( HTTPS_SCHEME . length ( ) ) ; } } return urlRetValue ; }
public final long readLong ( ) throws java . io . IOException { readFully ( scratch , _NUM , _NUM ) ; int h = ( ( scratch [ _NUM ] & _NUM ) << _NUM ) | ( ( scratch [ _NUM ] & _NUM ) << _NUM ) | ( ( scratch [ _NUM ] & _NUM ) << _NUM ) | ( ( scratch [ _NUM ] & _NUM ) << _NUM ) ; int l = ( ( scratch [ _NUM ] & _NUM ) << _NUM ) | ( ( scratch [ _NUM ] & _NUM ) << _NUM ) | ( ( scratch [ _NUM ] & _NUM ) << _NUM ) | ( ( scratch [ _NUM ] & _NUM ) << _NUM ) ; return ( ( ( long ) h ) << _NUM ) | ( ( long ) l ) & _NUM ; }
public static void threadWantsSharedResources ( ) { threadWantsOwnResources . set ( Boolean . FALSE ) ; }
public static String forceToString ( Object o ) { try { return objectToString ( o , _BOOL , MAX_ARRAY_ELEMENTS_TO_CONVERT ) ; } catch ( RuntimeException ex ) { return STRING + ex ; } }
public static String forceToString ( Object o ) { try { return objectToString ( o , _BOOL , MAX_ARRAY_ELEMENTS_TO_CONVERT ) ; } catch ( RuntimeException ex ) { return STRING + ex ; } }
public static String forceToString ( Object o ) { try { return objectToString ( o , _BOOL , MAX_ARRAY_ELEMENTS_TO_CONVERT ) ; } catch ( RuntimeException ex ) { return STRING + ex ; } }
public static String forceToString ( Object o ) { try { return objectToString ( o , _BOOL , MAX_ARRAY_ELEMENTS_TO_CONVERT ) ; } catch ( RuntimeException ex ) { return STRING + ex ; } }
public static String forceToString ( Object o ) { try { return objectToString ( o , _BOOL , MAX_ARRAY_ELEMENTS_TO_CONVERT ) ; } catch ( RuntimeException ex ) { return STRING + ex ; } }
public static String forceToString ( Object o ) { try { return objectToString ( o , _BOOL , MAX_ARRAY_ELEMENTS_TO_CONVERT ) ; } catch ( RuntimeException ex ) { return STRING + ex ; } }
public static String forceToString ( Object o ) { try { return objectToString ( o , _BOOL , MAX_ARRAY_ELEMENTS_TO_CONVERT ) ; } catch ( RuntimeException ex ) { return STRING + ex ; } }
public static String forceToString ( Object o ) { try { return objectToString ( o , _BOOL , MAX_ARRAY_ELEMENTS_TO_CONVERT ) ; } catch ( RuntimeException ex ) { return STRING + ex ; } }
public static String forceToString ( Object o ) { try { return objectToString ( o , _BOOL , MAX_ARRAY_ELEMENTS_TO_CONVERT ) ; } catch ( RuntimeException ex ) { return STRING + ex ; } }
public static String forceToString ( Object o ) { try { return objectToString ( o , _BOOL , MAX_ARRAY_ELEMENTS_TO_CONVERT ) ; } catch ( RuntimeException ex ) { return STRING + ex ; } }
final synchronized void releaseSocket ( ) { running = _BOOL ; sender . interrupt ( ) ; outboundMessages . clear ( ) ; if ( socket != null ) { socket . close ( ) ; socket = null ; } maximumTransmissionUnit = _NUM ; }
final synchronized void releaseSocket ( ) { running = _BOOL ; sender . interrupt ( ) ; outboundMessages . clear ( ) ; if ( socket != null ) { socket . close ( ) ; socket = null ; } maximumTransmissionUnit = _NUM ; }
protected void completeCommandline ( Commandline cmd ) { appendVerboseOption ( cmd , verbose ) ; }
protected void completeCommandline ( Commandline cmd ) { appendVerboseOption ( cmd , verbose ) ; }
private void signalAll ( ) { lock . lock ( ) ; try { isDone = _BOOL ; done . signalAll ( ) ; } finally { lock . unlock ( ) ; } }
private void signalAll ( ) { lock . lock ( ) ; try { isDone = _BOOL ; done . signalAll ( ) ; } finally { lock . unlock ( ) ; } }
private void signalAll ( ) { lock . lock ( ) ; try { isDone = _BOOL ; done . signalAll ( ) ; } finally { lock . unlock ( ) ; } }
private void signalAll ( ) { lock . lock ( ) ; try { isDone = _BOOL ; done . signalAll ( ) ; } finally { lock . unlock ( ) ; } }
private void signalAll ( ) { lock . lock ( ) ; try { isDone = _BOOL ; done . signalAll ( ) ; } finally { lock . unlock ( ) ; } }
private int removeNext ( ) { if ( lastUsageDates . isEmpty ( ) ) { return INVALID_SIZE ; } Long oldestUsage = null ; File mostLongUsedFile = null ; Set < Entry < File , Long > > entries = lastUsageDates . entrySet ( ) ; synchronized ( lastUsageDates ) { for ( Entry < File , Long > entry : entries ) { if ( mostLongUsedFile == null ) { mostLongUsedFile = entry . getKey ( ) ; oldestUsage = entry . getValue ( ) ; } else { Long lastValueUsage = entry . getValue ( ) ; if ( lastValueUsage < oldestUsage ) { oldestUsage = lastValueUsage ; mostLongUsedFile = entry . getKey ( ) ; } } } } int fileSize = _NUM ; if ( mostLongUsedFile != null ) { if ( mostLongUsedFile . exists ( ) ) { fileSize = getSize ( mostLongUsedFile ) ; if ( mostLongUsedFile . delete ( ) ) { lastUsageDates . remove ( mostLongUsedFile ) ; } } else { lastUsageDates . remove ( mostLongUsedFile ) ; } } return fileSize ; }
@ SuppressWarnings ( { STRING , STRING } ) private void initColumns ( ) { columns . clear ( ) ; final ArrayList < ColumnId > columnOrder = getColumnOrderFromConfig ( ) ; columnOrder . forEach ( null ) ; }
protected Set < String > readFileToSet ( BufferedReader aReader ) throws IOException { Set < String > words = new HashSet < String > ( ) ; String line ; while ( ( line = aReader . readLine ( ) ) != null ) { words . add ( line . toLowerCase ( ) ) ; } return words ; }
public void testGetCertificateIssuer ( ) { assertNull ( STRING , tbt_crlentry . getCertificateIssuer ( ) ) ; }
public static Area punch ( Area shapeArea , double gap , boolean rounded , Point2D pointPos , Shape pointShape ) { if ( gap <= _NUM || pointPos == null || pointShape == null ) { return shapeArea ; } AffineTransform tx = AffineTransform . getTranslateInstance ( pointPos . getX ( ) , pointPos . getY ( ) ) ; int gapJoin = rounded ? BasicStroke . JOIN_ROUND : BasicStroke . JOIN_MITER ; Area gapArea = GeometryUtils . grow ( tx . createTransformedShape ( pointShape ) , gap , gapJoin , _NUM ) ; shapeArea . subtract ( gapArea ) ; return shapeArea ; }
public static Area punch ( Area shapeArea , double gap , boolean rounded , Point2D pointPos , Shape pointShape ) { if ( gap <= _NUM || pointPos == null || pointShape == null ) { return shapeArea ; } AffineTransform tx = AffineTransform . getTranslateInstance ( pointPos . getX ( ) , pointPos . getY ( ) ) ; int gapJoin = rounded ? BasicStroke . JOIN_ROUND : BasicStroke . JOIN_MITER ; Area gapArea = GeometryUtils . grow ( tx . createTransformedShape ( pointShape ) , gap , gapJoin , _NUM ) ; shapeArea . subtract ( gapArea ) ; return shapeArea ; }
protected void addClassPath ( String classpath ) { if ( classpath == null ) return ; String sep = classpath . indexOf ( STRING ) == - _NUM ? STRING : STRING ; String [ ] parseCp = classpath . split ( sep ) ; for ( String cpEntry : parseCp ) { addEntry ( cpEntry ) ; } }
void caseAction ( NodeRepresentation nodeRep ) { makeProof ( nodeRep , _BOOL , _BOOL ) ; }
static public boolean isSameDay ( Timestamp one , Timestamp two ) { GregorianCalendar calOne = new GregorianCalendar ( ) ; if ( one != null ) calOne . setTimeInMillis ( one . getTime ( ) ) ; GregorianCalendar calTwo = new GregorianCalendar ( ) ; if ( two != null ) calTwo . setTimeInMillis ( two . getTime ( ) ) ; if ( calOne . get ( Calendar . YEAR ) == calTwo . get ( Calendar . YEAR ) && calOne . get ( Calendar . MONTH ) == calTwo . get ( Calendar . MONTH ) && calOne . get ( Calendar . DAY_OF_MONTH ) == calTwo . get ( Calendar . DAY_OF_MONTH ) ) return _BOOL ; return _BOOL ; }
public static final int binarySearch ( Object [ ] a , Object key , Comparator cp , int begin , int end ) { int x1 = begin ; int x2 = end ; int i = x1 + ( x2 - x1 ) / _NUM , c ; while ( x1 < x2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == _NUM ) { return i ; } else if ( c < _NUM ) { x1 = i + _NUM ; } else { x2 = i ; } i = x1 + ( x2 - x1 ) / _NUM ; } return - _NUM * ( i + _NUM ) ; }
public static final int binarySearch ( Object [ ] a , Object key , Comparator cp , int begin , int end ) { int x1 = begin ; int x2 = end ; int i = x1 + ( x2 - x1 ) / _NUM , c ; while ( x1 < x2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == _NUM ) { return i ; } else if ( c < _NUM ) { x1 = i + _NUM ; } else { x2 = i ; } i = x1 + ( x2 - x1 ) / _NUM ; } return - _NUM * ( i + _NUM ) ; }
public static short readUByte ( ByteBuffer buffer ) { byte b = buffer . get ( ) ; return ( short ) ( b & _NUM ) ; }
public static List < ItemStack > consolidateItemStacks ( List < ItemStack > inputStacks ) { List < ItemStack > outputStacks = new ArrayList < ItemStack > ( ) ; for ( ItemStack sourceIS : inputStacks ) { boolean bFound = _BOOL ; for ( ItemStack destIS : outputStacks ) { if ( destIS != null && sourceIS != null && itemStackIngredientsMatch ( destIS , sourceIS ) ) { bFound = _BOOL ; destIS . stackSize += sourceIS . stackSize ; } } if ( ! bFound ) outputStacks . add ( sourceIS . copy ( ) ) ; } return outputStacks ; }
public void init ( boolean encrypting , CipherParameters params ) throws IllegalArgumentException { this . encrypting = encrypting ; if ( params instanceof ParametersWithIV ) { ParametersWithIV ivParam = ( ParametersWithIV ) params ; byte [ ] iv = ivParam . getIV ( ) ; if ( iv . length < IV . length ) { System . arraycopy ( iv , _NUM , IV , IV . length - iv . length , iv . length ) ; for ( int i = _NUM ; i < IV . length - iv . length ; i ++ ) { IV [ i ] = _NUM ; } } else { System . arraycopy ( iv , _NUM , IV , _NUM , IV . length ) ; } reset ( ) ; if ( ivParam . getParameters ( ) != null ) { cipher . init ( _BOOL , ivParam . getParameters ( ) ) ; } } else { reset ( ) ; if ( params != null ) { cipher . init ( _BOOL , params ) ; } } }
public void init ( boolean encrypting , CipherParameters params ) throws IllegalArgumentException { this . encrypting = encrypting ; if ( params instanceof ParametersWithIV ) { ParametersWithIV ivParam = ( ParametersWithIV ) params ; byte [ ] iv = ivParam . getIV ( ) ; if ( iv . length < IV . length ) { System . arraycopy ( iv , _NUM , IV , IV . length - iv . length , iv . length ) ; for ( int i = _NUM ; i < IV . length - iv . length ; i ++ ) { IV [ i ] = _NUM ; } } else { System . arraycopy ( iv , _NUM , IV , _NUM , IV . length ) ; } reset ( ) ; if ( ivParam . getParameters ( ) != null ) { cipher . init ( _BOOL , ivParam . getParameters ( ) ) ; } } else { reset ( ) ; if ( params != null ) { cipher . init ( _BOOL , params ) ; } } }
public static String [ ] grabArgs ( String signature ) { Matcher matcher = sigRE . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . groupCount ( ) != _NUM ) logger . error ( STRING , signature ) ; String args = matcher . group ( _NUM ) ; if ( args . isEmpty ( ) ) return new String [ _NUM ] ; return args . split ( STRING ) ; }
public static float intRoot ( int base , int root ) { float gNew = base / root ; float gOld = _NUM ; int counter = _NUM ; while ( Math . abs ( gOld - gNew ) > _NUM ) { float gPow = floatPow ( gNew , root ) ; while ( Float . isInfinite ( gPow ) ) { gNew = ( gNew + gOld ) / _NUM ; gPow = floatPow ( gNew , root ) ; } counter += _NUM ; gOld = gNew ; gNew = gOld - ( gPow - base ) / ( root * floatPow ( gOld , root - _NUM ) ) ; } return gNew ; }
protected StringPropertyMatcher ( String propertyName , Mode mode , Boolean ignoreCase , String expectedPattern , Function < Issue , String > getActualValue ) { super ( propertyName ) ; this . mode = mode ; this . ignoreCase = Objects . requireNonNull ( ignoreCase ) ; this . expectedPattern = safeGetValue ( expectedPattern ) ; this . getActualValue = Objects . requireNonNull ( getActualValue ) ; }
public synchronized void add ( long [ ] argIds , int argLength ) { if ( length + argLength > data . length ) { long [ ] oldData = data ; data = new long [ argLength + length ] ; System . arraycopy ( oldData , _NUM , data , _NUM , oldData . length ) ; } System . arraycopy ( argIds , _NUM , data , length , argLength ) ; length += argLength ; }
BCRSAPrivateCrtKey ( RSAPrivateCrtKeySpec spec ) { this . modulus = spec . getModulus ( ) ; this . publicExponent = spec . getPublicExponent ( ) ; this . privateExponent = spec . getPrivateExponent ( ) ; this . primeP = spec . getPrimeP ( ) ; this . primeQ = spec . getPrimeQ ( ) ; this . primeExponentP = spec . getPrimeExponentP ( ) ; this . primeExponentQ = spec . getPrimeExponentQ ( ) ; this . crtCoefficient = spec . getCrtCoefficient ( ) ; }
public void write ( JWindow jW ) { if ( page == null ) { newpage ( ) ; } if ( page != null && pagenum >= prFirst ) { int x = x0 ; int y = y0 + ( linenum * lineheight ) ; page . translate ( x , y ) ; jW . setVisible ( _BOOL ) ; jW . printAll ( page ) ; jW . setVisible ( _BOOL ) ; jW . dispose ( ) ; page . translate ( - x , - y ) ; } }
public void write ( JWindow jW ) { if ( page == null ) { newpage ( ) ; } if ( page != null && pagenum >= prFirst ) { int x = x0 ; int y = y0 + ( linenum * lineheight ) ; page . translate ( x , y ) ; jW . setVisible ( _BOOL ) ; jW . printAll ( page ) ; jW . setVisible ( _BOOL ) ; jW . dispose ( ) ; page . translate ( - x , - y ) ; } }
public void write ( JWindow jW ) { if ( page == null ) { newpage ( ) ; } if ( page != null && pagenum >= prFirst ) { int x = x0 ; int y = y0 + ( linenum * lineheight ) ; page . translate ( x , y ) ; jW . setVisible ( _BOOL ) ; jW . printAll ( page ) ; jW . setVisible ( _BOOL ) ; jW . dispose ( ) ; page . translate ( - x , - y ) ; } }
public void write ( JWindow jW ) { if ( page == null ) { newpage ( ) ; } if ( page != null && pagenum >= prFirst ) { int x = x0 ; int y = y0 + ( linenum * lineheight ) ; page . translate ( x , y ) ; jW . setVisible ( _BOOL ) ; jW . printAll ( page ) ; jW . setVisible ( _BOOL ) ; jW . dispose ( ) ; page . translate ( - x , - y ) ; } }
public void write ( JWindow jW ) { if ( page == null ) { newpage ( ) ; } if ( page != null && pagenum >= prFirst ) { int x = x0 ; int y = y0 + ( linenum * lineheight ) ; page . translate ( x , y ) ; jW . setVisible ( _BOOL ) ; jW . printAll ( page ) ; jW . setVisible ( _BOOL ) ; jW . dispose ( ) ; page . translate ( - x , - y ) ; } }
@ Override public boolean implies ( ProtectionDomain pd , Permission p ) { PolicyInfo pi = policyInfo . get ( ) ; ProtectionDomainCache pdMap = pi . getPdMapping ( ) ; PermissionCollection pc = pdMap . get ( pd ) ; if ( pc != null ) { return pc . implies ( p ) ; } pc = getPermissions ( pd ) ; if ( pc == null ) { return _BOOL ; } pdMap . put ( pd , pc ) ; return pc . implies ( p ) ; }
@ Override public boolean implies ( ProtectionDomain pd , Permission p ) { PolicyInfo pi = policyInfo . get ( ) ; ProtectionDomainCache pdMap = pi . getPdMapping ( ) ; PermissionCollection pc = pdMap . get ( pd ) ; if ( pc != null ) { return pc . implies ( p ) ; } pc = getPermissions ( pd ) ; if ( pc == null ) { return _BOOL ; } pdMap . put ( pd , pc ) ; return pc . implies ( p ) ; }
private static List createList ( Object obj0 , Object obj1 ) { List list = new ArrayList ( ) ; list . add ( obj0 ) ; list . add ( obj1 ) ; return list ; }
public static float max ( final float a , final float b ) { if ( a > b ) { return a ; } if ( a < b ) { return b ; } if ( a != b ) { return Float . NaN ; } int bits = Float . floatToRawIntBits ( a ) ; if ( bits == _NUM ) { return b ; } return a ; }
public void removeSwipeListener ( OnSwipeListener listener ) { if ( mListeners == null ) { return ; } mListeners . remove ( listener ) ; }
public Rectangle ( double top , double left , double bottom , double right ) { double width = Math . abs ( right - left ) ; double height = Math . abs ( bottom - top ) ; Point center = new Point ( left + ( width / _NUM ) , top + ( height / _NUM ) ) ; setRect ( new Rect ( ( int ) ( center . x - ( width / _NUM ) ) , ( int ) ( center . y - ( height / _NUM ) ) , ( int ) width , ( int ) height ) ) ; }
public Set < TableId > readAllTableNames ( String [ ] tableTypes ) throws SQLException { return readTableNames ( null , null , null , tableTypes ) ; }
public static Intent createTakePictureIntent ( Activity ctx , Uri savingUri ) { if ( savingUri == null ) { throw new NullPointerException ( STRING ) ; } final List < Intent > cameraIntents = new ArrayList < Intent > ( ) ; final Intent captureIntent = new Intent ( MediaStore . ACTION_IMAGE_CAPTURE ) ; final PackageManager packageManager = ctx . getPackageManager ( ) ; final List < ResolveInfo > listCam = packageManager . queryIntentActivities ( captureIntent , _NUM ) ; for ( ResolveInfo res : listCam ) { final String packageName = res . activityInfo . packageName ; final Intent intent = new Intent ( captureIntent ) ; intent . setComponent ( new ComponentName ( res . activityInfo . packageName , res . activityInfo . name ) ) ; intent . setPackage ( packageName ) ; intent . putExtra ( MediaStore . EXTRA_OUTPUT , savingUri ) ; cameraIntents . add ( intent ) ; } final Intent galleryIntent = new Intent ( ) ; galleryIntent . setType ( STRING ) ; galleryIntent . setAction ( Intent . ACTION_GET_CONTENT ) ; final Intent chooserIntent = Intent . createChooser ( galleryIntent , STRING ) ; chooserIntent . putExtra ( Intent . EXTRA_INITIAL_INTENTS , cameraIntents . toArray ( new Parcelable [ ] { } ) ) ; return chooserIntent ; }
public static Intent createTakePictureIntent ( Activity ctx , Uri savingUri ) { if ( savingUri == null ) { throw new NullPointerException ( STRING ) ; } final List < Intent > cameraIntents = new ArrayList < Intent > ( ) ; final Intent captureIntent = new Intent ( MediaStore . ACTION_IMAGE_CAPTURE ) ; final PackageManager packageManager = ctx . getPackageManager ( ) ; final List < ResolveInfo > listCam = packageManager . queryIntentActivities ( captureIntent , _NUM ) ; for ( ResolveInfo res : listCam ) { final String packageName = res . activityInfo . packageName ; final Intent intent = new Intent ( captureIntent ) ; intent . setComponent ( new ComponentName ( res . activityInfo . packageName , res . activityInfo . name ) ) ; intent . setPackage ( packageName ) ; intent . putExtra ( MediaStore . EXTRA_OUTPUT , savingUri ) ; cameraIntents . add ( intent ) ; } final Intent galleryIntent = new Intent ( ) ; galleryIntent . setType ( STRING ) ; galleryIntent . setAction ( Intent . ACTION_GET_CONTENT ) ; final Intent chooserIntent = Intent . createChooser ( galleryIntent , STRING ) ; chooserIntent . putExtra ( Intent . EXTRA_INITIAL_INTENTS , cameraIntents . toArray ( new Parcelable [ ] { } ) ) ; return chooserIntent ; }
public static Intent createTakePictureIntent ( Activity ctx , Uri savingUri ) { if ( savingUri == null ) { throw new NullPointerException ( STRING ) ; } final List < Intent > cameraIntents = new ArrayList < Intent > ( ) ; final Intent captureIntent = new Intent ( MediaStore . ACTION_IMAGE_CAPTURE ) ; final PackageManager packageManager = ctx . getPackageManager ( ) ; final List < ResolveInfo > listCam = packageManager . queryIntentActivities ( captureIntent , _NUM ) ; for ( ResolveInfo res : listCam ) { final String packageName = res . activityInfo . packageName ; final Intent intent = new Intent ( captureIntent ) ; intent . setComponent ( new ComponentName ( res . activityInfo . packageName , res . activityInfo . name ) ) ; intent . setPackage ( packageName ) ; intent . putExtra ( MediaStore . EXTRA_OUTPUT , savingUri ) ; cameraIntents . add ( intent ) ; } final Intent galleryIntent = new Intent ( ) ; galleryIntent . setType ( STRING ) ; galleryIntent . setAction ( Intent . ACTION_GET_CONTENT ) ; final Intent chooserIntent = Intent . createChooser ( galleryIntent , STRING ) ; chooserIntent . putExtra ( Intent . EXTRA_INITIAL_INTENTS , cameraIntents . toArray ( new Parcelable [ ] { } ) ) ; return chooserIntent ; }
public static void addLifecycleListener ( LifecycleListener l ) { if ( listeners == null ) { listeners = new ArrayList < LifecycleListener > ( ) ; } listeners . add ( l ) ; }
public void clearTickLabelSections ( ) { tickLabelSections . clear ( ) ; fireUpdateEvent ( REDRAW_EVENT ) ; }
@ Override public String [ ] determineColumnConstraints ( ResultProducer rp ) throws Exception { return null ; }
public static String tokenToString ( byte token ) { return ( token == Token . END ) ? STRING : TOKEN_TYPES [ token ] ; }
protected QueryRecyclerAdapter ( Type < E > type ) { setHasStableIds ( _BOOL ) ; proxyProvider = type == null ? null : type . getProxyProvider ( ) ; handler = new Handler ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
protected void rehash ( ) { int oldCapacity = table . length ; CacheEntry oldTable [ ] = table ; int newCapacity = oldCapacity * _NUM + _NUM ; CacheEntry newTable [ ] = new CacheEntry [ newCapacity ] ; threshold = ( int ) ( newCapacity * loadFactor ) ; table = newTable ; for ( int i = oldCapacity ; i -- > _NUM ; ) { for ( CacheEntry old = oldTable [ i ] ; old != null ; ) { CacheEntry e = old ; old = old . next ; if ( e . check ( ) != null ) { int index = ( e . hash & _NUM ) % newCapacity ; e . next = newTable [ index ] ; newTable [ index ] = e ; } else count -- ; } } }
protected void rehash ( ) { int oldCapacity = table . length ; CacheEntry oldTable [ ] = table ; int newCapacity = oldCapacity * _NUM + _NUM ; CacheEntry newTable [ ] = new CacheEntry [ newCapacity ] ; threshold = ( int ) ( newCapacity * loadFactor ) ; table = newTable ; for ( int i = oldCapacity ; i -- > _NUM ; ) { for ( CacheEntry old = oldTable [ i ] ; old != null ; ) { CacheEntry e = old ; old = old . next ; if ( e . check ( ) != null ) { int index = ( e . hash & _NUM ) % newCapacity ; e . next = newTable [ index ] ; newTable [ index ] = e ; } else count -- ; } } }
public Explanation idfExplain ( CollectionStatistics collectionStats , TermStatistics termStats [ ] ) { final long docCount = collectionStats . docCount ( ) == - _NUM ? collectionStats . maxDoc ( ) : collectionStats . docCount ( ) ; float idf = _NUM ; List < Explanation > details = new ArrayList < > ( ) ; for ( final TermStatistics stat : termStats ) { final long df = stat . docFreq ( ) ; final float termIdf = idf ( df , docCount ) ; details . add ( Explanation . match ( termIdf , STRING + df + STRING + docCount + STRING ) ) ; idf += termIdf ; } return Explanation . match ( idf , STRING , details ) ; }
public Explanation idfExplain ( CollectionStatistics collectionStats , TermStatistics termStats [ ] ) { final long docCount = collectionStats . docCount ( ) == - _NUM ? collectionStats . maxDoc ( ) : collectionStats . docCount ( ) ; float idf = _NUM ; List < Explanation > details = new ArrayList < > ( ) ; for ( final TermStatistics stat : termStats ) { final long df = stat . docFreq ( ) ; final float termIdf = idf ( df , docCount ) ; details . add ( Explanation . match ( termIdf , STRING + df + STRING + docCount + STRING ) ) ; idf += termIdf ; } return Explanation . match ( idf , STRING , details ) ; }
public Explanation idfExplain ( CollectionStatistics collectionStats , TermStatistics termStats [ ] ) { final long docCount = collectionStats . docCount ( ) == - _NUM ? collectionStats . maxDoc ( ) : collectionStats . docCount ( ) ; float idf = _NUM ; List < Explanation > details = new ArrayList < > ( ) ; for ( final TermStatistics stat : termStats ) { final long df = stat . docFreq ( ) ; final float termIdf = idf ( df , docCount ) ; details . add ( Explanation . match ( termIdf , STRING + df + STRING + docCount + STRING ) ) ; idf += termIdf ; } return Explanation . match ( idf , STRING , details ) ; }
public Explanation idfExplain ( CollectionStatistics collectionStats , TermStatistics termStats [ ] ) { final long docCount = collectionStats . docCount ( ) == - _NUM ? collectionStats . maxDoc ( ) : collectionStats . docCount ( ) ; float idf = _NUM ; List < Explanation > details = new ArrayList < > ( ) ; for ( final TermStatistics stat : termStats ) { final long df = stat . docFreq ( ) ; final float termIdf = idf ( df , docCount ) ; details . add ( Explanation . match ( termIdf , STRING + df + STRING + docCount + STRING ) ) ; idf += termIdf ; } return Explanation . match ( idf , STRING , details ) ; }
public FileChannelOutputStream ( FileChannel channel , boolean append ) throws IOException { this . channel = channel ; if ( append ) { channel . position ( channel . size ( ) ) ; } else { channel . position ( _NUM ) ; channel . truncate ( _NUM ) ; } }
public FileChannelOutputStream ( FileChannel channel , boolean append ) throws IOException { this . channel = channel ; if ( append ) { channel . position ( channel . size ( ) ) ; } else { channel . position ( _NUM ) ; channel . truncate ( _NUM ) ; } }
public T vertexProcessor ( final BiConsumer < Vertex , Map < String , Object > > vertexProcessor ) { this . vertexProcessor = Optional . ofNullable ( vertexProcessor ) ; return extendingClass . cast ( this ) ; }
public T vertexProcessor ( final BiConsumer < Vertex , Map < String , Object > > vertexProcessor ) { this . vertexProcessor = Optional . ofNullable ( vertexProcessor ) ; return extendingClass . cast ( this ) ; }
public static String selectPreferredMIMEType ( Iterator < String > mimeTypes , HttpServletRequest request ) { List < HeaderElement > acceptElements = getHeaderElements ( request , STRING ) ; if ( acceptElements . isEmpty ( ) ) { if ( mimeTypes . hasNext ( ) ) { return mimeTypes . next ( ) ; } else { return null ; } } String result = null ; HeaderElement matchingAcceptType = null ; double highestQuality = _NUM ; while ( mimeTypes . hasNext ( ) ) { String mimeType = mimeTypes . next ( ) ; HeaderElement acceptType = matchAcceptHeader ( mimeType , acceptElements ) ; if ( acceptType != null ) { double quality = _NUM ; String qualityStr = acceptType . getParameterValue ( STRING ) ; if ( qualityStr != null ) { try { quality = Double . parseDouble ( qualityStr ) ; } catch ( NumberFormatException e ) { } } if ( quality > highestQuality ) { result = mimeType ; matchingAcceptType = acceptType ; highestQuality = quality ; } else if ( quality == highestQuality ) { if ( isMoreSpecificType ( acceptType , matchingAcceptType ) ) { result = mimeType ; matchingAcceptType = acceptType ; } } } } return result ; }
public static String selectPreferredMIMEType ( Iterator < String > mimeTypes , HttpServletRequest request ) { List < HeaderElement > acceptElements = getHeaderElements ( request , STRING ) ; if ( acceptElements . isEmpty ( ) ) { if ( mimeTypes . hasNext ( ) ) { return mimeTypes . next ( ) ; } else { return null ; } } String result = null ; HeaderElement matchingAcceptType = null ; double highestQuality = _NUM ; while ( mimeTypes . hasNext ( ) ) { String mimeType = mimeTypes . next ( ) ; HeaderElement acceptType = matchAcceptHeader ( mimeType , acceptElements ) ; if ( acceptType != null ) { double quality = _NUM ; String qualityStr = acceptType . getParameterValue ( STRING ) ; if ( qualityStr != null ) { try { quality = Double . parseDouble ( qualityStr ) ; } catch ( NumberFormatException e ) { } } if ( quality > highestQuality ) { result = mimeType ; matchingAcceptType = acceptType ; highestQuality = quality ; } else if ( quality == highestQuality ) { if ( isMoreSpecificType ( acceptType , matchingAcceptType ) ) { result = mimeType ; matchingAcceptType = acceptType ; } } } } return result ; }
public synchronized void add ( double minValue , double maxValue ) { super . add ( minValue ) ; mMaxValues . add ( maxValue ) ; }
public boolean isOptional ( final AttributeType attributeType ) { return optionalAttributes . contains ( attributeType ) ; }
protected int doOpcode ( int pos , byte [ ] code ) throws BadBytecode { try { int op = code [ pos ] & _NUM ; if ( op < _NUM ) if ( op < _NUM ) return doOpcode0_53 ( pos , code , op ) ; else return doOpcode54_95 ( pos , code , op ) ; else if ( op < _NUM ) return doOpcode96_147 ( pos , code , op ) ; else return doOpcode148_201 ( pos , code , op ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new BadBytecode ( STRING + e . getMessage ( ) , e ) ; } }
protected int doOpcode ( int pos , byte [ ] code ) throws BadBytecode { try { int op = code [ pos ] & _NUM ; if ( op < _NUM ) if ( op < _NUM ) return doOpcode0_53 ( pos , code , op ) ; else return doOpcode54_95 ( pos , code , op ) ; else if ( op < _NUM ) return doOpcode96_147 ( pos , code , op ) ; else return doOpcode148_201 ( pos , code , op ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new BadBytecode ( STRING + e . getMessage ( ) , e ) ; } }
protected int doOpcode ( int pos , byte [ ] code ) throws BadBytecode { try { int op = code [ pos ] & _NUM ; if ( op < _NUM ) if ( op < _NUM ) return doOpcode0_53 ( pos , code , op ) ; else return doOpcode54_95 ( pos , code , op ) ; else if ( op < _NUM ) return doOpcode96_147 ( pos , code , op ) ; else return doOpcode148_201 ( pos , code , op ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new BadBytecode ( STRING + e . getMessage ( ) , e ) ; } }
protected int doOpcode ( int pos , byte [ ] code ) throws BadBytecode { try { int op = code [ pos ] & _NUM ; if ( op < _NUM ) if ( op < _NUM ) return doOpcode0_53 ( pos , code , op ) ; else return doOpcode54_95 ( pos , code , op ) ; else if ( op < _NUM ) return doOpcode96_147 ( pos , code , op ) ; else return doOpcode148_201 ( pos , code , op ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new BadBytecode ( STRING + e . getMessage ( ) , e ) ; } }
protected int doOpcode ( int pos , byte [ ] code ) throws BadBytecode { try { int op = code [ pos ] & _NUM ; if ( op < _NUM ) if ( op < _NUM ) return doOpcode0_53 ( pos , code , op ) ; else return doOpcode54_95 ( pos , code , op ) ; else if ( op < _NUM ) return doOpcode96_147 ( pos , code , op ) ; else return doOpcode148_201 ( pos , code , op ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new BadBytecode ( STRING + e . getMessage ( ) , e ) ; } }
protected int doOpcode ( int pos , byte [ ] code ) throws BadBytecode { try { int op = code [ pos ] & _NUM ; if ( op < _NUM ) if ( op < _NUM ) return doOpcode0_53 ( pos , code , op ) ; else return doOpcode54_95 ( pos , code , op ) ; else if ( op < _NUM ) return doOpcode96_147 ( pos , code , op ) ; else return doOpcode148_201 ( pos , code , op ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new BadBytecode ( STRING + e . getMessage ( ) , e ) ; } }
protected int doOpcode ( int pos , byte [ ] code ) throws BadBytecode { try { int op = code [ pos ] & _NUM ; if ( op < _NUM ) if ( op < _NUM ) return doOpcode0_53 ( pos , code , op ) ; else return doOpcode54_95 ( pos , code , op ) ; else if ( op < _NUM ) return doOpcode96_147 ( pos , code , op ) ; else return doOpcode148_201 ( pos , code , op ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new BadBytecode ( STRING + e . getMessage ( ) , e ) ; } }
public void testRWBits ( ) { final int bSize = _NUM << _NUM ; final int [ ] bits = new int [ bSize ] ; final int nbits = bSize * _NUM ; for ( int i = _NUM ; i < nbits ; i ++ ) { final int b = RWStore . fndBit ( bits , bSize ) ; assertTrue ( b != - _NUM ) ; assertFalse ( RWStore . tstBit ( bits , b ) ) ; RWStore . setBit ( bits , b ) ; assertTrue ( RWStore . tstBit ( bits , b ) ) ; } assertTrue ( - _NUM == RWStore . fndBit ( bits , bSize ) ) ; for ( int i = _NUM ; i < _NUM * _NUM * _NUM ; i ++ ) { final int b = r . nextInt ( nbits ) ; assertTrue ( RWStore . tstBit ( bits , b ) ) ; RWStore . clrBit ( bits , b ) ; assertFalse ( RWStore . tstBit ( bits , b ) ) ; assertTrue ( b == RWStore . fndBit ( bits , bSize ) ) ; RWStore . setBit ( bits , b ) ; assertTrue ( RWStore . tstBit ( bits , b ) ) ; } assertTrue ( - _NUM == RWStore . fndBit ( bits , bSize ) ) ; }
@ Override public List < Node > generate ( int popSize ) { List < Node > population = new ArrayList < > ( ) ; for ( int i = _NUM ; i < popSize ; ) { Node candidate = grow ( _NUM ) ; if ( candidate . isValid ( ) ) { population . add ( candidate ) ; i ++ ; } } return population ; }
private void createDaySlot ( ArrayList < MAssignmentSlot > list , MAssignmentSlot ma ) { Timestamp start = ma . getStartTime ( ) ; GregorianCalendar calStart = new GregorianCalendar ( ) ; calStart . setTime ( start ) ; calStart . set ( Calendar . HOUR_OF_DAY , _NUM ) ; calStart . set ( Calendar . MINUTE , _NUM ) ; calStart . set ( Calendar . SECOND , _NUM ) ; calStart . set ( Calendar . MILLISECOND , _NUM ) ; Timestamp end = ma . getEndTime ( ) ; GregorianCalendar calEnd = new GregorianCalendar ( ) ; calEnd . setTime ( end ) ; calEnd . set ( Calendar . HOUR_OF_DAY , _NUM ) ; calEnd . set ( Calendar . MINUTE , _NUM ) ; calEnd . set ( Calendar . SECOND , _NUM ) ; calEnd . set ( Calendar . MILLISECOND , _NUM ) ; while ( calStart . before ( calEnd ) ) { Timestamp xStart = new Timestamp ( calStart . getTimeInMillis ( ) ) ; calStart . add ( Calendar . DAY_OF_YEAR , _NUM ) ; Timestamp xEnd = new Timestamp ( calStart . getTimeInMillis ( ) ) ; MAssignmentSlot myMa = new MAssignmentSlot ( xStart , xEnd , ma . getName ( ) , ma . getDescription ( ) , ma . getStatus ( ) ) ; list . add ( myMa ) ; } }
public static < T > List < T > roCopyList ( Collection < T > l ) { return Collections . unmodifiableList ( new ArrayList < > ( l ) ) ; }
public static < T > List < T > roCopyList ( Collection < T > l ) { return Collections . unmodifiableList ( new ArrayList < > ( l ) ) ; }
protected void processWindowEvent ( WindowEvent e ) { super . processWindowEvent ( e ) ; if ( e . getID ( ) == WindowEvent . WINDOW_CLOSING ) { jMenuFileExit_actionPerformed ( null ) ; } }
protected void processWindowEvent ( WindowEvent e ) { super . processWindowEvent ( e ) ; if ( e . getID ( ) == WindowEvent . WINDOW_CLOSING ) { jMenuFileExit_actionPerformed ( null ) ; } }
public SocketAddress start ( ) throws SocketException { running = _BOOL ; server = new DatagramSocket ( ) ; if ( networkMonitor != null ) { server = new MonitorDatagramSocketWrapper ( server , networkMonitor ) ; } SocketAddress socketAddress = server . getLocalSocketAddress ( ) ; thread = new Thread ( this ) ; thread . start ( ) ; return socketAddress ; }
public void addBridgeIdleDebugListener ( NotThreadSafeBridgeIdleDebugListener listener ) { mBridgeIdleListeners . add ( listener ) ; }
public void addBridgeIdleDebugListener ( NotThreadSafeBridgeIdleDebugListener listener ) { mBridgeIdleListeners . add ( listener ) ; }
public void addBridgeIdleDebugListener ( NotThreadSafeBridgeIdleDebugListener listener ) { mBridgeIdleListeners . add ( listener ) ; }
public void fault ( String faultXml ) throws Exception { LOG . trace ( STRING , faultXml ) ; if ( inAttachmentPart ) { endAttachments ( ) ; } mpEncoder . startPart ( TEXT_XML_UTF8 ) ; mpEncoder . write ( faultXml . getBytes ( StandardCharsets . UTF_8 ) ) ; }
public void addParseTemplate ( String parseTemplate ) { parseTemplates . add ( parseTemplate ) ; }
public void addParseTemplate ( String parseTemplate ) { parseTemplates . add ( parseTemplate ) ; }
@ Override public Set < K > keySet ( ) { HashSet < K > set = new HashSet < K > ( ) ; for ( Segment < K , V > s : segments ) { set . addAll ( s . keySet ( ) ) ; } return set ; }
public Subcollection createSubCollection ( final String id , final String name ) { Subcollection subCol = null ; if ( ! collectionMap . containsKey ( id ) ) { subCol = new Subcollection ( id , name , getConf ( ) ) ; collectionMap . put ( id , subCol ) ; } return subCol ; }
@ Override public void flush ( ) throws IOException { synchronized ( lock ) { out . flush ( ) ; } }
@ Override public void flush ( ) throws IOException { synchronized ( lock ) { out . flush ( ) ; } }
@ Override public void flush ( ) throws IOException { synchronized ( lock ) { out . flush ( ) ; } }
static byte [ ] readBytes ( InputStream is , byte [ ] ioBuffer , int maxSize ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; copyBytes ( baos , is , ioBuffer , maxSize ) ; return baos . toByteArray ( ) ; }
static byte [ ] readBytes ( InputStream is , byte [ ] ioBuffer , int maxSize ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; copyBytes ( baos , is , ioBuffer , maxSize ) ; return baos . toByteArray ( ) ; }
protected IssuePropertyMatcherBase ( String propertyName ) { this . propertyName = Objects . requireNonNull ( propertyName ) ; }
protected Object convertValueFromXml ( Class type , Object value ) { if ( value instanceof String && type . isPrimitive ( ) ) { String tmp = ( String ) value ; if ( type . equals ( boolean . class ) ) { if ( tmp . equals ( STRING ) || tmp . equals ( STRING ) ) { tmp = ( tmp . equals ( STRING ) ) ? STRING : STRING ; } value = new Boolean ( tmp ) ; } else if ( type . equals ( char . class ) ) { value = new Character ( tmp . charAt ( _NUM ) ) ; } else if ( type . equals ( byte . class ) ) { value = new Byte ( tmp ) ; } else if ( type . equals ( short . class ) ) { value = new Short ( tmp ) ; } else if ( type . equals ( int . class ) ) { value = new Integer ( tmp ) ; } else if ( type . equals ( long . class ) ) { value = new Long ( tmp ) ; } else if ( type . equals ( float . class ) ) { value = new Float ( tmp ) ; } else if ( type . equals ( double . class ) ) { value = new Double ( tmp ) ; } } return value ; }
protected Object convertValueFromXml ( Class type , Object value ) { if ( value instanceof String && type . isPrimitive ( ) ) { String tmp = ( String ) value ; if ( type . equals ( boolean . class ) ) { if ( tmp . equals ( STRING ) || tmp . equals ( STRING ) ) { tmp = ( tmp . equals ( STRING ) ) ? STRING : STRING ; } value = new Boolean ( tmp ) ; } else if ( type . equals ( char . class ) ) { value = new Character ( tmp . charAt ( _NUM ) ) ; } else if ( type . equals ( byte . class ) ) { value = new Byte ( tmp ) ; } else if ( type . equals ( short . class ) ) { value = new Short ( tmp ) ; } else if ( type . equals ( int . class ) ) { value = new Integer ( tmp ) ; } else if ( type . equals ( long . class ) ) { value = new Long ( tmp ) ; } else if ( type . equals ( float . class ) ) { value = new Float ( tmp ) ; } else if ( type . equals ( double . class ) ) { value = new Double ( tmp ) ; } } return value ; }
protected boolean verifyLimit ( Collection result , int limit , ExecutionContext context ) { if ( limit > _NUM ) { return result . size ( ) == limit ; } return _BOOL ; }
public void append ( final Object value ) { if ( needsComma ) { sb . append ( m_separator ) ; } needsComma = _BOOL ; sb . append ( value ) ; }
@ Override public int startupNewWorker ( ) { final int priority = ( Math . random ( ) < _NUM ) ? _NUM : _NUM ; int actualWorkersStarted = startupNewWorker ( priority ) ; return actualWorkersStarted ; }
@ Override public int startupNewWorker ( ) { final int priority = ( Math . random ( ) < _NUM ) ? _NUM : _NUM ; int actualWorkersStarted = startupNewWorker ( priority ) ; return actualWorkersStarted ; }
@ Override public int startupNewWorker ( ) { final int priority = ( Math . random ( ) < _NUM ) ? _NUM : _NUM ; int actualWorkersStarted = startupNewWorker ( priority ) ; return actualWorkersStarted ; }
@ Override public int startupNewWorker ( ) { final int priority = ( Math . random ( ) < _NUM ) ? _NUM : _NUM ; int actualWorkersStarted = startupNewWorker ( priority ) ; return actualWorkersStarted ; }
@ Override public int startupNewWorker ( ) { final int priority = ( Math . random ( ) < _NUM ) ? _NUM : _NUM ; int actualWorkersStarted = startupNewWorker ( priority ) ; return actualWorkersStarted ; }
public static String join ( String separator , List < String > strings ) { StringBuilder sb = new StringBuilder ( ) ; for ( Iterator < String > iter = strings . iterator ( ) ; iter . hasNext ( ) ; ) { String s = iter . next ( ) ; sb . append ( s ) ; if ( iter . hasNext ( ) ) sb . append ( separator ) ; } return sb . toString ( ) ; }
public static String join ( String separator , List < String > strings ) { StringBuilder sb = new StringBuilder ( ) ; for ( Iterator < String > iter = strings . iterator ( ) ; iter . hasNext ( ) ; ) { String s = iter . next ( ) ; sb . append ( s ) ; if ( iter . hasNext ( ) ) sb . append ( separator ) ; } return sb . toString ( ) ; }
public JsonValue undeploy ( String routeId ) throws RouterHandlerException { write . lock ( ) ; try { JsonValue routeConfig = unload ( routeId ) ; directoryMonitor . delete ( routeId ) ; logger . info ( STRING , routeId ) ; return routeConfig ; } finally { write . unlock ( ) ; } }
public JsonValue undeploy ( String routeId ) throws RouterHandlerException { write . lock ( ) ; try { JsonValue routeConfig = unload ( routeId ) ; directoryMonitor . delete ( routeId ) ; logger . info ( STRING , routeId ) ; return routeConfig ; } finally { write . unlock ( ) ; } }
public boolean removeElement ( Object obj ) { int index = indexOf ( obj ) ; boolean rv = delegate . removeElement ( obj ) ; if ( index >= _NUM ) { fireIntervalRemoved ( this , index , index ) ; } return rv ; }
public static HelpSubCommandHandler create ( SubCommandArgumentParser parser ) throws ArgumentException { return new HelpSubCommandHandler ( parser ) ; }
public String htmlAll ( boolean setIncluded ) { StringBuilder sb = new StringBuilder ( ) ; for ( Node node : nodes ) { sb . append ( setIncluded ? node . getHtml ( ) : node . getInnerHtml ( ) ) ; } return sb . toString ( ) ; }
public void schedule ( TimerTask task , Date when , long period ) { if ( period <= _NUM || when . getTime ( ) < _NUM ) { throw new IllegalArgumentException ( ) ; } long delay = when . getTime ( ) - System . currentTimeMillis ( ) ; scheduleImpl ( task , delay < _NUM ? _NUM : delay , period , _BOOL ) ; }
void scheduleMessageReceived ( NextFilter nextFilter , Object message ) { messageReceivedEventQueue . add ( new IoFilterEvent ( nextFilter , IoEventType . MESSAGE_RECEIVED , session , message ) ) ; }
void scheduleMessageReceived ( NextFilter nextFilter , Object message ) { messageReceivedEventQueue . add ( new IoFilterEvent ( nextFilter , IoEventType . MESSAGE_RECEIVED , session , message ) ) ; }
public void addAll ( T ... items ) { synchronized ( mLock ) { if ( mOriginalValues != null ) { Collections . addAll ( mOriginalValues , items ) ; } else { Collections . addAll ( mObjects , items ) ; } } if ( mNotifyOnChange ) notifyDataSetChanged ( ) ; }
public void addAll ( T ... items ) { synchronized ( mLock ) { if ( mOriginalValues != null ) { Collections . addAll ( mOriginalValues , items ) ; } else { Collections . addAll ( mObjects , items ) ; } } if ( mNotifyOnChange ) notifyDataSetChanged ( ) ; }
protected String convertWord ( String word ) { word = word . toUpperCase ( ) ; if ( ignoreList . contains ( word ) ) { return null ; } return word ; }
public void removeChangeListener ( ChangeListener l ) { if ( listeners == null ) return ; listeners . remove ( l ) ; }
private boolean isInThumbRange ( float touchX , double normalizedThumbValue ) { return Math . abs ( touchX - normalizedToScreen ( normalizedThumbValue ) ) <= thumbHalfWidth ; }
private boolean isInThumbRange ( float touchX , double normalizedThumbValue ) { return Math . abs ( touchX - normalizedToScreen ( normalizedThumbValue ) ) <= thumbHalfWidth ; }
private boolean isInThumbRange ( float touchX , double normalizedThumbValue ) { return Math . abs ( touchX - normalizedToScreen ( normalizedThumbValue ) ) <= thumbHalfWidth ; }
private boolean isInThumbRange ( float touchX , double normalizedThumbValue ) { return Math . abs ( touchX - normalizedToScreen ( normalizedThumbValue ) ) <= thumbHalfWidth ; }
public static Object readObject ( java . sql . ResultSet resultSet , int index ) throws Exception { ObjectInputStream objIn = new ObjectInputStream ( resultSet . getBinaryStream ( index ) ) ; Object obj = objIn . readObject ( ) ; objIn . close ( ) ; return obj ; }
public static Object readObject ( java . sql . ResultSet resultSet , int index ) throws Exception { ObjectInputStream objIn = new ObjectInputStream ( resultSet . getBinaryStream ( index ) ) ; Object obj = objIn . readObject ( ) ; objIn . close ( ) ; return obj ; }
public static StructType convertFrameSchemaToDFSchema ( ValueType [ ] fschema , boolean containsID ) { List < StructField > fields = new ArrayList < StructField > ( ) ; if ( containsID ) fields . add ( DataTypes . createStructField ( RDDConverterUtils . DF_ID_COLUMN , DataTypes . DoubleType , _BOOL ) ) ; int col = _NUM ; for ( ValueType schema : fschema ) { DataType dt = null ; switch ( schema ) { case STRING : dt = DataTypes . StringType ; break ; case DOUBLE : dt = DataTypes . DoubleType ; break ; case INT : dt = DataTypes . LongType ; break ; case BOOLEAN : dt = DataTypes . BooleanType ; break ; default : dt = DataTypes . StringType ; LOG . warn ( STRING + schema . toString ( ) ) ; } fields . add ( DataTypes . createStructField ( STRING + col ++ , dt , _BOOL ) ) ; } return DataTypes . createStructType ( fields ) ; }
private static void closeAndDrain ( DefaultHttpResponse actualRes , HttpResponse deferredRes ) { actualRes . close ( ) ; deferredRes . subscribe ( NoopSubscriber . get ( ) ) ; waitForEventLoop ( ) ; }
private static void closeAndDrain ( DefaultHttpResponse actualRes , HttpResponse deferredRes ) { actualRes . close ( ) ; deferredRes . subscribe ( NoopSubscriber . get ( ) ) ; waitForEventLoop ( ) ; }
private static void closeAndDrain ( DefaultHttpResponse actualRes , HttpResponse deferredRes ) { actualRes . close ( ) ; deferredRes . subscribe ( NoopSubscriber . get ( ) ) ; waitForEventLoop ( ) ; }
private HttpURLConnection openConnectionFollowRedirects ( String urlStr , String authSubToken ) throws MalformedURLException , GeneralSecurityException , IOException { boolean redirectsDone = _BOOL ; HttpURLConnection connection = null ; while ( ! redirectsDone ) { URL url = new URL ( urlStr ) ; connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setRequestProperty ( STRING , STRING ) ; String authHeader = null ; authHeader = AuthSubUtil . formAuthorizationHeader ( authSubToken , Utility . getPrivateKey ( ) , url , STRING ) ; connection . setRequestProperty ( STRING , authHeader ) ; connection . setInstanceFollowRedirects ( _BOOL ) ; int responseCode = connection . getResponseCode ( ) ; if ( responseCode == HttpURLConnection . HTTP_MOVED_PERM || responseCode == HttpURLConnection . HTTP_MOVED_TEMP ) { urlStr = connection . getHeaderField ( STRING ) ; if ( urlStr == null ) { redirectsDone = _BOOL ; } } else { redirectsDone = _BOOL ; } } return connection ; }
private HttpURLConnection openConnectionFollowRedirects ( String urlStr , String authSubToken ) throws MalformedURLException , GeneralSecurityException , IOException { boolean redirectsDone = _BOOL ; HttpURLConnection connection = null ; while ( ! redirectsDone ) { URL url = new URL ( urlStr ) ; connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setRequestProperty ( STRING , STRING ) ; String authHeader = null ; authHeader = AuthSubUtil . formAuthorizationHeader ( authSubToken , Utility . getPrivateKey ( ) , url , STRING ) ; connection . setRequestProperty ( STRING , authHeader ) ; connection . setInstanceFollowRedirects ( _BOOL ) ; int responseCode = connection . getResponseCode ( ) ; if ( responseCode == HttpURLConnection . HTTP_MOVED_PERM || responseCode == HttpURLConnection . HTTP_MOVED_TEMP ) { urlStr = connection . getHeaderField ( STRING ) ; if ( urlStr == null ) { redirectsDone = _BOOL ; } } else { redirectsDone = _BOOL ; } } return connection ; }
private HttpURLConnection openConnectionFollowRedirects ( String urlStr , String authSubToken ) throws MalformedURLException , GeneralSecurityException , IOException { boolean redirectsDone = _BOOL ; HttpURLConnection connection = null ; while ( ! redirectsDone ) { URL url = new URL ( urlStr ) ; connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setRequestProperty ( STRING , STRING ) ; String authHeader = null ; authHeader = AuthSubUtil . formAuthorizationHeader ( authSubToken , Utility . getPrivateKey ( ) , url , STRING ) ; connection . setRequestProperty ( STRING , authHeader ) ; connection . setInstanceFollowRedirects ( _BOOL ) ; int responseCode = connection . getResponseCode ( ) ; if ( responseCode == HttpURLConnection . HTTP_MOVED_PERM || responseCode == HttpURLConnection . HTTP_MOVED_TEMP ) { urlStr = connection . getHeaderField ( STRING ) ; if ( urlStr == null ) { redirectsDone = _BOOL ; } } else { redirectsDone = _BOOL ; } } return connection ; }
public void updateTimersAndEvents ( ProcessDefinitionEntity processDefinition , ProcessDefinitionEntity previousProcessDefinition , ParsedDeployment parsedDeployment ) { Process process = parsedDeployment . getProcessModelForProcessDefinition ( processDefinition ) ; BpmnModel bpmnModel = parsedDeployment . getBpmnModelForProcessDefinition ( processDefinition ) ; eventSubscriptionManager . removeObsoleteMessageEventSubscriptions ( previousProcessDefinition ) ; eventSubscriptionManager . addMessageEventSubscriptions ( processDefinition , process , bpmnModel ) ; eventSubscriptionManager . removeObsoleteSignalEventSubScription ( previousProcessDefinition ) ; eventSubscriptionManager . addSignalEventSubscriptions ( Context . getCommandContext ( ) , processDefinition , process , bpmnModel ) ; timerManager . removeObsoleteTimers ( processDefinition ) ; timerManager . scheduleTimers ( processDefinition , process ) ; }
public void updateTimersAndEvents ( ProcessDefinitionEntity processDefinition , ProcessDefinitionEntity previousProcessDefinition , ParsedDeployment parsedDeployment ) { Process process = parsedDeployment . getProcessModelForProcessDefinition ( processDefinition ) ; BpmnModel bpmnModel = parsedDeployment . getBpmnModelForProcessDefinition ( processDefinition ) ; eventSubscriptionManager . removeObsoleteMessageEventSubscriptions ( previousProcessDefinition ) ; eventSubscriptionManager . addMessageEventSubscriptions ( processDefinition , process , bpmnModel ) ; eventSubscriptionManager . removeObsoleteSignalEventSubScription ( previousProcessDefinition ) ; eventSubscriptionManager . addSignalEventSubscriptions ( Context . getCommandContext ( ) , processDefinition , process , bpmnModel ) ; timerManager . removeObsoleteTimers ( processDefinition ) ; timerManager . scheduleTimers ( processDefinition , process ) ; }
@ SuppressWarnings ( { STRING , STRING } ) private static void mergeSort ( Object [ ] src , Object [ ] dest , int low , int high , int off , Comparator c ) { int length = high - low ; if ( length < INSERTIONSORT_THRESHOLD ) { for ( int i = low ; i < high ; i ++ ) for ( int j = i ; j > low && c . compare ( dest [ j - _NUM ] , dest [ j ] ) > _NUM ; j -- ) swap ( dest , j , j - _NUM ) ; return ; } int destLow = low ; int destHigh = high ; low += off ; high += off ; int mid = ( low + high ) > > > _NUM ; mergeSort ( dest , src , low , mid , - off , c ) ; mergeSort ( dest , src , mid , high , - off , c ) ; if ( c . compare ( src [ mid - _NUM ] , src [ mid ] ) <= _NUM ) { System . arraycopy ( src , low , dest , destLow , length ) ; return ; } for ( int i = destLow , p = low , q = mid ; i < destHigh ; i ++ ) { if ( q >= high || p < mid && c . compare ( src [ p ] , src [ q ] ) <= _NUM ) dest [ i ] = src [ p ++ ] ; else dest [ i ] = src [ q ++ ] ; } }
@ SuppressWarnings ( { STRING , STRING } ) private static void mergeSort ( Object [ ] src , Object [ ] dest , int low , int high , int off , Comparator c ) { int length = high - low ; if ( length < INSERTIONSORT_THRESHOLD ) { for ( int i = low ; i < high ; i ++ ) for ( int j = i ; j > low && c . compare ( dest [ j - _NUM ] , dest [ j ] ) > _NUM ; j -- ) swap ( dest , j , j - _NUM ) ; return ; } int destLow = low ; int destHigh = high ; low += off ; high += off ; int mid = ( low + high ) > > > _NUM ; mergeSort ( dest , src , low , mid , - off , c ) ; mergeSort ( dest , src , mid , high , - off , c ) ; if ( c . compare ( src [ mid - _NUM ] , src [ mid ] ) <= _NUM ) { System . arraycopy ( src , low , dest , destLow , length ) ; return ; } for ( int i = destLow , p = low , q = mid ; i < destHigh ; i ++ ) { if ( q >= high || p < mid && c . compare ( src [ p ] , src [ q ] ) <= _NUM ) dest [ i ] = src [ p ++ ] ; else dest [ i ] = src [ q ++ ] ; } }
@ SuppressWarnings ( { STRING , STRING } ) private static void mergeSort ( Object [ ] src , Object [ ] dest , int low , int high , int off , Comparator c ) { int length = high - low ; if ( length < INSERTIONSORT_THRESHOLD ) { for ( int i = low ; i < high ; i ++ ) for ( int j = i ; j > low && c . compare ( dest [ j - _NUM ] , dest [ j ] ) > _NUM ; j -- ) swap ( dest , j , j - _NUM ) ; return ; } int destLow = low ; int destHigh = high ; low += off ; high += off ; int mid = ( low + high ) > > > _NUM ; mergeSort ( dest , src , low , mid , - off , c ) ; mergeSort ( dest , src , mid , high , - off , c ) ; if ( c . compare ( src [ mid - _NUM ] , src [ mid ] ) <= _NUM ) { System . arraycopy ( src , low , dest , destLow , length ) ; return ; } for ( int i = destLow , p = low , q = mid ; i < destHigh ; i ++ ) { if ( q >= high || p < mid && c . compare ( src [ p ] , src [ q ] ) <= _NUM ) dest [ i ] = src [ p ++ ] ; else dest [ i ] = src [ q ++ ] ; } }
@ SuppressWarnings ( { STRING , STRING } ) private static void mergeSort ( Object [ ] src , Object [ ] dest , int low , int high , int off , Comparator c ) { int length = high - low ; if ( length < INSERTIONSORT_THRESHOLD ) { for ( int i = low ; i < high ; i ++ ) for ( int j = i ; j > low && c . compare ( dest [ j - _NUM ] , dest [ j ] ) > _NUM ; j -- ) swap ( dest , j , j - _NUM ) ; return ; } int destLow = low ; int destHigh = high ; low += off ; high += off ; int mid = ( low + high ) > > > _NUM ; mergeSort ( dest , src , low , mid , - off , c ) ; mergeSort ( dest , src , mid , high , - off , c ) ; if ( c . compare ( src [ mid - _NUM ] , src [ mid ] ) <= _NUM ) { System . arraycopy ( src , low , dest , destLow , length ) ; return ; } for ( int i = destLow , p = low , q = mid ; i < destHigh ; i ++ ) { if ( q >= high || p < mid && c . compare ( src [ p ] , src [ q ] ) <= _NUM ) dest [ i ] = src [ p ++ ] ; else dest [ i ] = src [ q ++ ] ; } }
public void update ( int n , byte [ ] b , int off , int len , ManifestEntryVerifier mev ) throws IOException { if ( n != - _NUM ) { if ( parsingBlockOrSF ) { baos . write ( b , off , n ) ; } else { mev . update ( b , off , n ) ; } } else { processEntry ( mev ) ; } }
public void clear ( ) { if ( mViewTypeCount == _NUM ) { final ArrayList < View > scrap = mCurrentScrap ; final int scrapCount = scrap . size ( ) ; for ( int i = _NUM ; i < scrapCount ; i ++ ) { removeDetachedView ( scrap . remove ( scrapCount - _NUM - i ) , _BOOL ) ; } } else { final int typeCount = mViewTypeCount ; for ( int i = _NUM ; i < typeCount ; i ++ ) { final ArrayList < View > scrap = mScrapViews [ i ] ; final int scrapCount = scrap . size ( ) ; for ( int j = _NUM ; j < scrapCount ; j ++ ) { removeDetachedView ( scrap . remove ( scrapCount - _NUM - j ) , _BOOL ) ; } } } if ( mTransientStateViews != null ) { mTransientStateViews . clear ( ) ; } }
public void testGetVersion30 ( ) throws Exception { String xml = WEBAPP_30_HEADER + STRING ; WebXml webXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( xml . getBytes ( STRING ) ) , getEntityResolver ( ) ) ; assertEquals ( WebXmlVersion . V3_0 , webXml . getVersion ( ) ) ; }
public static < T > Set < T > toSet ( T obj1 , T obj2 ) { Set < T > theSet = new LinkedHashSet < T > ( ) ; theSet . add ( obj1 ) ; theSet . add ( obj2 ) ; return theSet ; }
private FCZoneReference findFCZoneReferenceForVolGroupKey ( URI exportGroupURI , URI volumeURI , String refKey , String [ ] newOrExisting ) { Map < String , FCZoneReference > volRefMap = _networkScheduler . makeExportToReferenceMap ( refKey ) ; String volExportKey = make2UriKey ( volumeURI , exportGroupURI ) ; if ( volRefMap . containsKey ( volExportKey ) ) { FCZoneReference ref = volRefMap . get ( volExportKey ) ; if ( ref != null && ref . getInactive ( ) == _BOOL ) { _log . info ( String . format ( STRING , volumeURI , exportGroupURI , refKey ) ) ; newOrExisting [ _NUM ] = STRING ; return ref ; } } return null ; }
public void remove ( int i ) { if ( ( i >= array . length ) || ( i < _NUM ) ) throw new ArrayIndexOutOfBoundsException ( STRING + i + STRING + array . length ) ; NSObject [ ] newArray = new NSObject [ array . length - _NUM ] ; System . arraycopy ( array , _NUM , newArray , _NUM , i ) ; System . arraycopy ( array , i + _NUM , newArray , i , array . length - i - _NUM ) ; array = newArray ; }
public Name add ( int posn , Rdn comp ) { if ( comp == null ) { throw new NullPointerException ( STRING ) ; } rdns . add ( posn , comp ) ; unparsed = null ; return this ; }
public Name add ( int posn , Rdn comp ) { if ( comp == null ) { throw new NullPointerException ( STRING ) ; } rdns . add ( posn , comp ) ; unparsed = null ; return this ; }
public void sendTamsMessage ( TamsMessage m , TamsListener tl ) { tm = m ; tmq . offer ( tm ) ; if ( tm . isBinary ( ) ) { } else { } sendMessage ( tm , tl ) ; }
public InitialTransition ( State < S , E > target , Action < S , E > action ) { super ( null , target , action != null ? Collections . singleton ( action ) : null , null , TransitionKind . INITIAL , null , null , null ) ; }
public void delete ( String name ) throws IOException { if ( name . equalsIgnoreCase ( DESCRIPTIONS ) ) { accessDescriptions = new ArrayList < AccessDescription > ( ) ; } else { throw new IOException ( STRING + name + STRING + STRING ) ; } encodeThis ( ) ; }
public Set < ? extends AnnotationMirror > greatestLowerBoundsTypeVariable ( Collection < ? extends AnnotationMirror > annos1 , Collection < ? extends AnnotationMirror > annos2 ) { Set < AnnotationMirror > result = AnnotationUtils . createAnnotationSet ( ) ; for ( AnnotationMirror top : getTopAnnotations ( ) ) { AnnotationMirror anno1ForTop = null ; for ( AnnotationMirror anno1 : annos1 ) { if ( isSubtypeTypeVariable ( anno1 , top ) ) { anno1ForTop = anno1 ; } } AnnotationMirror anno2ForTop = null ; for ( AnnotationMirror anno2 : annos2 ) { if ( isSubtypeTypeVariable ( anno2 , top ) ) { anno2ForTop = anno2 ; } } AnnotationMirror t = greatestLowerBoundTypeVariable ( anno1ForTop , anno2ForTop ) ; if ( t != null ) { result . add ( t ) ; } } return result ; }
public Set < ? extends AnnotationMirror > greatestLowerBoundsTypeVariable ( Collection < ? extends AnnotationMirror > annos1 , Collection < ? extends AnnotationMirror > annos2 ) { Set < AnnotationMirror > result = AnnotationUtils . createAnnotationSet ( ) ; for ( AnnotationMirror top : getTopAnnotations ( ) ) { AnnotationMirror anno1ForTop = null ; for ( AnnotationMirror anno1 : annos1 ) { if ( isSubtypeTypeVariable ( anno1 , top ) ) { anno1ForTop = anno1 ; } } AnnotationMirror anno2ForTop = null ; for ( AnnotationMirror anno2 : annos2 ) { if ( isSubtypeTypeVariable ( anno2 , top ) ) { anno2ForTop = anno2 ; } } AnnotationMirror t = greatestLowerBoundTypeVariable ( anno1ForTop , anno2ForTop ) ; if ( t != null ) { result . add ( t ) ; } } return result ; }
public void onTabClosureCommitted ( long time , int id , boolean incognito ) { }
public void onTabClosureCommitted ( long time , int id , boolean incognito ) { }
public RaptorState ( int nStops ) { this . bestTimes = new int [ nStops ] ; this . bestNonTransferTimes = new int [ nStops ] ; Arrays . fill ( bestTimes , RaptorWorker . UNREACHED ) ; Arrays . fill ( bestNonTransferTimes , RaptorWorker . UNREACHED ) ; this . previousPatterns = new int [ nStops ] ; this . previousStop = new int [ nStops ] ; this . transferStop = new int [ nStops ] ; Arrays . fill ( previousPatterns , - _NUM ) ; Arrays . fill ( previousStop , - _NUM ) ; Arrays . fill ( transferStop , - _NUM ) ; this . inVehicleTravelTime = new int [ nStops ] ; this . waitTime = new int [ nStops ] ; this . nonTransferWaitTime = new int [ nStops ] ; this . nonTransferInVehicleTravelTime = new int [ nStops ] ; }
public synchronized void rewindTo ( long time ) { if ( time > currentTrackTime ) throw new IllegalArgumentException ( STRING + time + STRING + currentTrackTime + STRING ) ; time = Math . max ( _NUM , time ) ; time -= time % _NUM ; currentTrackTime = time ; }
public synchronized void rewindTo ( long time ) { if ( time > currentTrackTime ) throw new IllegalArgumentException ( STRING + time + STRING + currentTrackTime + STRING ) ; time = Math . max ( _NUM , time ) ; time -= time % _NUM ; currentTrackTime = time ; }
public synchronized void rewindTo ( long time ) { if ( time > currentTrackTime ) throw new IllegalArgumentException ( STRING + time + STRING + currentTrackTime + STRING ) ; time = Math . max ( _NUM , time ) ; time -= time % _NUM ; currentTrackTime = time ; }
public byte [ ] filter ( byte [ ] buffer , int offset , int len ) { byte [ ] slices = getSlices ( buffer , offset , len ) ; if ( null == slices ) { return null ; } int insertionPoint = findInsertionPoint ( slices ) ; if ( insertionPoint >= _NUM ) { return buffer ; } if ( - _NUM == insertionPoint ) { if ( hasHinting ) { return Arrays . copyOf ( this . rangekeys , this . bounds [ _NUM ] ) ; } else { return null ; } } if ( - nranges - _NUM == insertionPoint ) { if ( hasHinting ) { return EMPTY_BYTE_ARRAY ; } else { return null ; } } if ( - ( insertionPoint + _NUM ) % _NUM == _NUM ) { if ( hasHinting ) { int hintOffset = this . slicesLength * ( - ( insertionPoint + _NUM ) ) ; return Arrays . copyOfRange ( this . rangekeys , hintOffset , this . bounds [ _NUM ] ) ; } else { return null ; } } return buffer ; }
public byte [ ] filter ( byte [ ] buffer , int offset , int len ) { byte [ ] slices = getSlices ( buffer , offset , len ) ; if ( null == slices ) { return null ; } int insertionPoint = findInsertionPoint ( slices ) ; if ( insertionPoint >= _NUM ) { return buffer ; } if ( - _NUM == insertionPoint ) { if ( hasHinting ) { return Arrays . copyOf ( this . rangekeys , this . bounds [ _NUM ] ) ; } else { return null ; } } if ( - nranges - _NUM == insertionPoint ) { if ( hasHinting ) { return EMPTY_BYTE_ARRAY ; } else { return null ; } } if ( - ( insertionPoint + _NUM ) % _NUM == _NUM ) { if ( hasHinting ) { int hintOffset = this . slicesLength * ( - ( insertionPoint + _NUM ) ) ; return Arrays . copyOfRange ( this . rangekeys , hintOffset , this . bounds [ _NUM ] ) ; } else { return null ; } } return buffer ; }
@ Override public Object annotationButton ( final FormObject form ) { final int subtype = form . getParameterConstant ( PdfDictionary . Subtype ) ; if ( subtype == PdfDictionary . Popup ) { return createAnnotationPopup ( form ) ; } if ( ! form . isAppearanceUsed ( ) ) { switch ( subtype ) { case PdfDictionary . Text : return createAnnotationText ( form ) ; case PdfDictionary . FreeText : return createAnnotationFreeText ( form ) ; case PdfDictionary . Highlight : return createAnntoationHighlight ( form ) ; case PdfDictionary . Underline : return createAnnotationUnderline ( form ) ; case PdfDictionary . Ink : return createAnnotationInk ( form ) ; case PdfDictionary . StrickOut : return createAnnotationStrikeOut ( form ) ; } } return setupAnnotationButton ( form ) ; }
public static void backAndForth ( HGSearchResult < ? > rs , int windowSize , int iteration ) { boolean advance = _BOOL ; for ( int i = _NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( windowSize ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new RuntimeException ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new RuntimeException ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( windowSize ) ) ; if ( ! rs . hasNext ( ) ) { back ( rs , random ( windowSize ) ) ; advance = _BOOL ; } } else { back ( rs , random ( windowSize ) ) ; if ( ! rs . hasPrev ( ) ) { forward ( rs , random ( windowSize ) ) ; advance = _BOOL ; } } } }
public static void backAndForth ( HGSearchResult < ? > rs , int windowSize , int iteration ) { boolean advance = _BOOL ; for ( int i = _NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( windowSize ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new RuntimeException ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new RuntimeException ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( windowSize ) ) ; if ( ! rs . hasNext ( ) ) { back ( rs , random ( windowSize ) ) ; advance = _BOOL ; } } else { back ( rs , random ( windowSize ) ) ; if ( ! rs . hasPrev ( ) ) { forward ( rs , random ( windowSize ) ) ; advance = _BOOL ; } } } }
public static void backAndForth ( HGSearchResult < ? > rs , int windowSize , int iteration ) { boolean advance = _BOOL ; for ( int i = _NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( windowSize ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new RuntimeException ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new RuntimeException ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( windowSize ) ) ; if ( ! rs . hasNext ( ) ) { back ( rs , random ( windowSize ) ) ; advance = _BOOL ; } } else { back ( rs , random ( windowSize ) ) ; if ( ! rs . hasPrev ( ) ) { forward ( rs , random ( windowSize ) ) ; advance = _BOOL ; } } } }
public static void backAndForth ( HGSearchResult < ? > rs , int windowSize , int iteration ) { boolean advance = _BOOL ; for ( int i = _NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( windowSize ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new RuntimeException ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new RuntimeException ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( windowSize ) ) ; if ( ! rs . hasNext ( ) ) { back ( rs , random ( windowSize ) ) ; advance = _BOOL ; } } else { back ( rs , random ( windowSize ) ) ; if ( ! rs . hasPrev ( ) ) { forward ( rs , random ( windowSize ) ) ; advance = _BOOL ; } } } }
public static void backAndForth ( HGSearchResult < ? > rs , int windowSize , int iteration ) { boolean advance = _BOOL ; for ( int i = _NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( windowSize ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new RuntimeException ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new RuntimeException ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( windowSize ) ) ; if ( ! rs . hasNext ( ) ) { back ( rs , random ( windowSize ) ) ; advance = _BOOL ; } } else { back ( rs , random ( windowSize ) ) ; if ( ! rs . hasPrev ( ) ) { forward ( rs , random ( windowSize ) ) ; advance = _BOOL ; } } } }
public static void backAndForth ( HGSearchResult < ? > rs , int windowSize , int iteration ) { boolean advance = _BOOL ; for ( int i = _NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( windowSize ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new RuntimeException ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new RuntimeException ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( windowSize ) ) ; if ( ! rs . hasNext ( ) ) { back ( rs , random ( windowSize ) ) ; advance = _BOOL ; } } else { back ( rs , random ( windowSize ) ) ; if ( ! rs . hasPrev ( ) ) { forward ( rs , random ( windowSize ) ) ; advance = _BOOL ; } } } }
public static void backAndForth ( HGSearchResult < ? > rs , int windowSize , int iteration ) { boolean advance = _BOOL ; for ( int i = _NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( windowSize ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new RuntimeException ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new RuntimeException ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( windowSize ) ) ; if ( ! rs . hasNext ( ) ) { back ( rs , random ( windowSize ) ) ; advance = _BOOL ; } } else { back ( rs , random ( windowSize ) ) ; if ( ! rs . hasPrev ( ) ) { forward ( rs , random ( windowSize ) ) ; advance = _BOOL ; } } } }
public static void backAndForth ( HGSearchResult < ? > rs , int windowSize , int iteration ) { boolean advance = _BOOL ; for ( int i = _NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( windowSize ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new RuntimeException ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new RuntimeException ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( windowSize ) ) ; if ( ! rs . hasNext ( ) ) { back ( rs , random ( windowSize ) ) ; advance = _BOOL ; } } else { back ( rs , random ( windowSize ) ) ; if ( ! rs . hasPrev ( ) ) { forward ( rs , random ( windowSize ) ) ; advance = _BOOL ; } } } }
public void waitUntilFree ( ) { while ( isBusy ( ) ) { sendEmptyMessage ( BLANK ) ; lock . lock ( ) ; try { if ( isBusy ( ) ) { busyCondition . await ( ) ; } } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } finally { lock . unlock ( ) ; } } }
void put ( final Object item ) { lbd . add ( item ) ; }
private static int CallStaticIntMethodV ( JNIEnvironment env , int classJREF , int methodID , Address argAddress ) throws Exception { if ( traceJNI ) VM . sysWrite ( STRING ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { Object returnObj = JNIHelpers . invokeWithVarArg ( methodID , argAddress , TypeReference . Int ) ; return Reflection . unwrapInt ( returnObj ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return _NUM ; } }
private static int CallStaticIntMethodV ( JNIEnvironment env , int classJREF , int methodID , Address argAddress ) throws Exception { if ( traceJNI ) VM . sysWrite ( STRING ) ; RuntimeEntrypoints . checkJNICountDownToGC ( ) ; try { Object returnObj = JNIHelpers . invokeWithVarArg ( methodID , argAddress , TypeReference . Int ) ; return Reflection . unwrapInt ( returnObj ) ; } catch ( Throwable unexpected ) { if ( traceJNI ) unexpected . printStackTrace ( System . err ) ; env . recordException ( unexpected ) ; return _NUM ; } }
public static ListMultimap < Category , UnaryRule > loadUnaryRules ( final File file ) throws IOException { final Multimap < Category , UnaryRule > result = HashMultimap . create ( ) ; final Lexicon lexicon = new DefaultLexicon ( ) ; for ( String line : Util . readFile ( file ) ) { if ( line . startsWith ( STRING ) ) { continue ; } line = line . trim ( ) ; if ( line . isEmpty ( ) ) { continue ; } final String [ ] fields = line . split ( STRING ) ; if ( fields . length != _NUM && fields . length != _NUM ) { throw new Error ( STRING + line ) ; } final String from = fields [ _NUM ] ; final String to = fields [ _NUM ] ; final Category cat = Category . make ( Category . valueOf ( to ) , Slash . FWD , Category . valueOf ( from ) ) ; Logic logic ; if ( fields . length == _NUM ) { logic = LogicParser . fromString ( fields [ _NUM ] , cat ) ; } else { logic = lexicon . getEntry ( null , STRING , cat , Coindexation . fromString ( to + STRING + from , - _NUM ) ) ; } result . put ( Category . valueOf ( from ) , new UnaryRule ( result . size ( ) , from , to , logic ) ) ; } return ImmutableListMultimap . copyOf ( result ) ; }
@ Override public UUID sessionId ( ) { if ( sessionId == null ) sessionId = UUID . randomUUID ( ) ; return sessionId ; }
@ Override public UUID sessionId ( ) { if ( sessionId == null ) sessionId = UUID . randomUUID ( ) ; return sessionId ; }
@ Override public UUID sessionId ( ) { if ( sessionId == null ) sessionId = UUID . randomUUID ( ) ; return sessionId ; }
public void test_noResourcesDoesNotWait_predeclareLocks_unboundedQueue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = _NUM ; final int ntasks = _NUM ; properties . setProperty ( TestOptions . CORE_POOL_SIZE , STRING + nthreads ) ; properties . setProperty ( TestOptions . NTASKS , STRING + ntasks ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; final Result result = doComparisonTest ( properties ) ; assertEquals ( STRING , ntasks , Integer . parseInt ( result . get ( STRING ) ) ) ; assertEquals ( STRING , nthreads , Integer . parseInt ( result . get ( STRING ) ) ) ; }
public void test_noResourcesDoesNotWait_predeclareLocks_unboundedQueue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = _NUM ; final int ntasks = _NUM ; properties . setProperty ( TestOptions . CORE_POOL_SIZE , STRING + nthreads ) ; properties . setProperty ( TestOptions . NTASKS , STRING + ntasks ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; final Result result = doComparisonTest ( properties ) ; assertEquals ( STRING , ntasks , Integer . parseInt ( result . get ( STRING ) ) ) ; assertEquals ( STRING , nthreads , Integer . parseInt ( result . get ( STRING ) ) ) ; }
public void test_noResourcesDoesNotWait_predeclareLocks_unboundedQueue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = _NUM ; final int ntasks = _NUM ; properties . setProperty ( TestOptions . CORE_POOL_SIZE , STRING + nthreads ) ; properties . setProperty ( TestOptions . NTASKS , STRING + ntasks ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; final Result result = doComparisonTest ( properties ) ; assertEquals ( STRING , ntasks , Integer . parseInt ( result . get ( STRING ) ) ) ; assertEquals ( STRING , nthreads , Integer . parseInt ( result . get ( STRING ) ) ) ; }
public void test_noResourcesDoesNotWait_predeclareLocks_unboundedQueue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = _NUM ; final int ntasks = _NUM ; properties . setProperty ( TestOptions . CORE_POOL_SIZE , STRING + nthreads ) ; properties . setProperty ( TestOptions . NTASKS , STRING + ntasks ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; final Result result = doComparisonTest ( properties ) ; assertEquals ( STRING , ntasks , Integer . parseInt ( result . get ( STRING ) ) ) ; assertEquals ( STRING , nthreads , Integer . parseInt ( result . get ( STRING ) ) ) ; }
public void test_noResourcesDoesNotWait_predeclareLocks_unboundedQueue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = _NUM ; final int ntasks = _NUM ; properties . setProperty ( TestOptions . CORE_POOL_SIZE , STRING + nthreads ) ; properties . setProperty ( TestOptions . NTASKS , STRING + ntasks ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; final Result result = doComparisonTest ( properties ) ; assertEquals ( STRING , ntasks , Integer . parseInt ( result . get ( STRING ) ) ) ; assertEquals ( STRING , nthreads , Integer . parseInt ( result . get ( STRING ) ) ) ; }
public void test_noResourcesDoesNotWait_predeclareLocks_unboundedQueue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = _NUM ; final int ntasks = _NUM ; properties . setProperty ( TestOptions . CORE_POOL_SIZE , STRING + nthreads ) ; properties . setProperty ( TestOptions . NTASKS , STRING + ntasks ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; final Result result = doComparisonTest ( properties ) ; assertEquals ( STRING , ntasks , Integer . parseInt ( result . get ( STRING ) ) ) ; assertEquals ( STRING , nthreads , Integer . parseInt ( result . get ( STRING ) ) ) ; }
public void test_noResourcesDoesNotWait_predeclareLocks_unboundedQueue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = _NUM ; final int ntasks = _NUM ; properties . setProperty ( TestOptions . CORE_POOL_SIZE , STRING + nthreads ) ; properties . setProperty ( TestOptions . NTASKS , STRING + ntasks ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; final Result result = doComparisonTest ( properties ) ; assertEquals ( STRING , ntasks , Integer . parseInt ( result . get ( STRING ) ) ) ; assertEquals ( STRING , nthreads , Integer . parseInt ( result . get ( STRING ) ) ) ; }
public void test_noResourcesDoesNotWait_predeclareLocks_unboundedQueue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = _NUM ; final int ntasks = _NUM ; properties . setProperty ( TestOptions . CORE_POOL_SIZE , STRING + nthreads ) ; properties . setProperty ( TestOptions . NTASKS , STRING + ntasks ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; final Result result = doComparisonTest ( properties ) ; assertEquals ( STRING , ntasks , Integer . parseInt ( result . get ( STRING ) ) ) ; assertEquals ( STRING , nthreads , Integer . parseInt ( result . get ( STRING ) ) ) ; }
private String read ( ) throws IOException { String line = reader . readLine ( ) ; if ( line == null ) { throw new IOException ( STRING ) ; } for ( Iterator iter = communicationListeners . iterator ( ) ; iter . hasNext ( ) ; ) { FTPCommunicationListener l = ( FTPCommunicationListener ) iter . next ( ) ; l . received ( line ) ; } return line ; }
protected int calcTextWidth ( Paint paint , String demoText ) { Rect r = new Rect ( ) ; paint . getTextBounds ( demoText , _NUM , demoText . length ( ) , r ) ; return r . width ( ) ; }
protected int calcTextWidth ( Paint paint , String demoText ) { Rect r = new Rect ( ) ; paint . getTextBounds ( demoText , _NUM , demoText . length ( ) , r ) ; return r . width ( ) ; }
public SignatureEvaluator ( int suggestedBufferSize , boolean humanReadable ) { this ( suggestedBufferSize , humanReadable , new SignatureRules ( ) ) ; }
public static void forEachToken ( String string , String separator , Procedure < String > procedure ) { for ( StringTokenizer stringTokenizer = new StringTokenizer ( string , separator ) ; stringTokenizer . hasMoreTokens ( ) ; ) { String token = stringTokenizer . nextToken ( ) ; procedure . value ( token ) ; } }
public static void forEachToken ( String string , String separator , Procedure < String > procedure ) { for ( StringTokenizer stringTokenizer = new StringTokenizer ( string , separator ) ; stringTokenizer . hasMoreTokens ( ) ; ) { String token = stringTokenizer . nextToken ( ) ; procedure . value ( token ) ; } }
public final boolean isGoodState ( TLCState state ) { return state . allAssigned ( ) ; }
public static String generateScaleMarkers ( int proteinLength , int maxNumScaleMarkers ) { if ( maxNumScaleMarkers < _NUM ) { maxNumScaleMarkers = _NUM ; } int scale = calcScale ( proteinLength , maxNumScaleMarkers ) ; StringBuilder sb = new StringBuilder ( STRING ) ; int index = _NUM ; int numRemaining = proteinLength ; while ( index <= proteinLength ) { index += scale ; numRemaining -= scale ; sb . append ( STRING ) ; if ( ( numRemaining > _NUM ) && ( numRemaining < scale ) ) { if ( numRemaining < ( scale / _NUM ) ) { sb . append ( proteinLength ) ; break ; } } if ( index >= proteinLength ) { sb . append ( proteinLength ) ; } else { sb . append ( index ) ; } } return sb . toString ( ) ; }
public static String generateScaleMarkers ( int proteinLength , int maxNumScaleMarkers ) { if ( maxNumScaleMarkers < _NUM ) { maxNumScaleMarkers = _NUM ; } int scale = calcScale ( proteinLength , maxNumScaleMarkers ) ; StringBuilder sb = new StringBuilder ( STRING ) ; int index = _NUM ; int numRemaining = proteinLength ; while ( index <= proteinLength ) { index += scale ; numRemaining -= scale ; sb . append ( STRING ) ; if ( ( numRemaining > _NUM ) && ( numRemaining < scale ) ) { if ( numRemaining < ( scale / _NUM ) ) { sb . append ( proteinLength ) ; break ; } } if ( index >= proteinLength ) { sb . append ( proteinLength ) ; } else { sb . append ( index ) ; } } return sb . toString ( ) ; }
public static String generateScaleMarkers ( int proteinLength , int maxNumScaleMarkers ) { if ( maxNumScaleMarkers < _NUM ) { maxNumScaleMarkers = _NUM ; } int scale = calcScale ( proteinLength , maxNumScaleMarkers ) ; StringBuilder sb = new StringBuilder ( STRING ) ; int index = _NUM ; int numRemaining = proteinLength ; while ( index <= proteinLength ) { index += scale ; numRemaining -= scale ; sb . append ( STRING ) ; if ( ( numRemaining > _NUM ) && ( numRemaining < scale ) ) { if ( numRemaining < ( scale / _NUM ) ) { sb . append ( proteinLength ) ; break ; } } if ( index >= proteinLength ) { sb . append ( proteinLength ) ; } else { sb . append ( index ) ; } } return sb . toString ( ) ; }
public void processTransactionTerminated ( TransactionTerminatedEvent transactionTerminatedEvent ) { }
void addIndex ( Index index ) { indexes . add ( index ) ; }
public void add ( final int start , final int end , final byte status ) { final int s = start - mStart ; if ( s < mInterval . length && end > mStart ) { Arrays . fill ( mInterval , Math . max ( s , _NUM ) , Math . min ( end - mStart , mInterval . length ) , status ) ; } }
@ Override public void init ( ) { }
protected static void drawDataPoint ( double x , double y , double xprev , double yprev , int size , int shape , Graphics gx ) { drawDataPoint ( x , y , size , shape , gx ) ; gx . drawLine ( ( int ) x , ( int ) y , ( int ) xprev , ( int ) yprev ) ; }
protected static void drawDataPoint ( double x , double y , double xprev , double yprev , int size , int shape , Graphics gx ) { drawDataPoint ( x , y , size , shape , gx ) ; gx . drawLine ( ( int ) x , ( int ) y , ( int ) xprev , ( int ) yprev ) ; }
protected static void drawDataPoint ( double x , double y , double xprev , double yprev , int size , int shape , Graphics gx ) { drawDataPoint ( x , y , size , shape , gx ) ; gx . drawLine ( ( int ) x , ( int ) y , ( int ) xprev , ( int ) yprev ) ; }
private QueryExp buildQueryExp ( final String pidAttribute , final String [ ] attributes , final Object [ ] values ) { final QueryExp optionalAttributes = buildOptionalQueryExp ( attributes , values ) ; QueryExp constraint ; if ( optionalAttributes != null ) { constraint = Query . and ( optionalAttributes , Query . eq ( Query . attr ( pidAttribute ) , Query . value ( this . pid ) ) ) ; } else { constraint = Query . eq ( Query . attr ( pidAttribute ) , Query . value ( this . pid ) ) ; } return constraint ; }
private QueryExp buildQueryExp ( final String pidAttribute , final String [ ] attributes , final Object [ ] values ) { final QueryExp optionalAttributes = buildOptionalQueryExp ( attributes , values ) ; QueryExp constraint ; if ( optionalAttributes != null ) { constraint = Query . and ( optionalAttributes , Query . eq ( Query . attr ( pidAttribute ) , Query . value ( this . pid ) ) ) ; } else { constraint = Query . eq ( Query . attr ( pidAttribute ) , Query . value ( this . pid ) ) ; } return constraint ; }
private void validateWill ( String dest , Object payload ) { if ( ( dest == null ) || ( payload == null ) ) { throw new IllegalArgumentException ( ) ; } MqttTopic . validate ( dest , _BOOL ) ; }
public RankingImageListProvider inHours ( int hours ) { mTime = Integer . toString ( hours ) + STRING ; return this ; }
public static Position fromRadians ( double latitudeRadians , double longitudeRadians , double altitude ) { Position pos = new Position ( ) ; pos . latitude = Math . toDegrees ( latitudeRadians ) ; pos . longitude = Math . toDegrees ( longitudeRadians ) ; pos . altitude = altitude ; return pos ; }
public void resetNameForHTML ( String newName ) { glyphs . fontName = newName ; glyphs . baseFontName = newName ; }
public void resetNameForHTML ( String newName ) { glyphs . fontName = newName ; glyphs . baseFontName = newName ; }
public void add ( String path ) { deletedFiles . add ( path ) ; }
public void add ( String path ) { deletedFiles . add ( path ) ; }
public void add ( String path ) { deletedFiles . add ( path ) ; }
public static void main ( String [ ] args ) { Timer timer = new Timer ( STRING ) ; Timer overallTimer = new Timer ( STRING ) ; timer . showTimes ( _NUM ) ; overallTimer . start ( ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { timer . start ( ) ; try { Thread . sleep ( i * _NUM ) ; } catch ( InterruptedException e ) { } timer . stop ( _BOOL ) ; } overallTimer . stop ( ) ; timer . showTimes ( overallTimer . getCurrentTime ( ) ) ; overallTimer . showTimes ( ) ; }
public static void main ( String [ ] args ) { Timer timer = new Timer ( STRING ) ; Timer overallTimer = new Timer ( STRING ) ; timer . showTimes ( _NUM ) ; overallTimer . start ( ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { timer . start ( ) ; try { Thread . sleep ( i * _NUM ) ; } catch ( InterruptedException e ) { } timer . stop ( _BOOL ) ; } overallTimer . stop ( ) ; timer . showTimes ( overallTimer . getCurrentTime ( ) ) ; overallTimer . showTimes ( ) ; }
public static void main ( String [ ] args ) { Timer timer = new Timer ( STRING ) ; Timer overallTimer = new Timer ( STRING ) ; timer . showTimes ( _NUM ) ; overallTimer . start ( ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { timer . start ( ) ; try { Thread . sleep ( i * _NUM ) ; } catch ( InterruptedException e ) { } timer . stop ( _BOOL ) ; } overallTimer . stop ( ) ; timer . showTimes ( overallTimer . getCurrentTime ( ) ) ; overallTimer . showTimes ( ) ; }
@ Override protected void sendData ( final OutputStream out ) throws IOException { LOG . trace ( STRING ) ; if ( lengthOfData ( ) == _NUM ) { LOG . debug ( STRING ) ; return ; } final byte [ ] tmp = new byte [ _NUM ] ; final InputStream instream = source . createInputStream ( ) ; try { int len ; while ( ( len = instream . read ( tmp ) ) >= _NUM ) { out . write ( tmp , _NUM , len ) ; } } finally { instream . close ( ) ; } }
@ Override protected void sendData ( final OutputStream out ) throws IOException { LOG . trace ( STRING ) ; if ( lengthOfData ( ) == _NUM ) { LOG . debug ( STRING ) ; return ; } final byte [ ] tmp = new byte [ _NUM ] ; final InputStream instream = source . createInputStream ( ) ; try { int len ; while ( ( len = instream . read ( tmp ) ) >= _NUM ) { out . write ( tmp , _NUM , len ) ; } } finally { instream . close ( ) ; } }
public void generateAddAnimation ( View child , boolean fromMoreCard ) { if ( mIsExpanded && mAnimationsEnabled && ! mChangePositionInProgress ) { mChildrenToAddAnimated . add ( child ) ; if ( fromMoreCard ) { mFromMoreCardAdditions . add ( child ) ; } mNeedsAnimation = _BOOL ; } }
public void stop ( ) { synchronized ( lock ) { schedulerService . shutdownNow ( ) ; state = State . STOPPED ; } }
public void stop ( ) { synchronized ( lock ) { schedulerService . shutdownNow ( ) ; state = State . STOPPED ; } }
public void stop ( ) { synchronized ( lock ) { schedulerService . shutdownNow ( ) ; state = State . STOPPED ; } }
private int matchString ( String text , int start , int field , Map < String , Integer > data , CalendarBuilder calb ) { if ( data != null ) { if ( data instanceof SortedMap ) { for ( String name : data . keySet ( ) ) { if ( text . regionMatches ( _BOOL , start , name , _NUM , name . length ( ) ) ) { calb . set ( field , data . get ( name ) ) ; return start + name . length ( ) ; } } return - start ; } String bestMatch = null ; for ( String name : data . keySet ( ) ) { int length = name . length ( ) ; if ( bestMatch == null || length > bestMatch . length ( ) ) { if ( text . regionMatches ( _BOOL , start , name , _NUM , length ) ) { bestMatch = name ; } } } if ( bestMatch != null ) { calb . set ( field , data . get ( bestMatch ) ) ; return start + bestMatch . length ( ) ; } } return - start ; }
public static String removeBackslashEscapes ( final String s ) { final StringBuilder sb = new StringBuilder ( ) ; for ( int k = _NUM ; k < s . length ( ) ; k ++ ) { final char c = s . charAt ( k ) ; if ( c == STRING ) { if ( ++ k == s . length ( ) ) { break ; } final char d = s . charAt ( k ) ; switch ( d ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; default : sb . append ( d ) ; break ; } } else if ( c == STRING ) { break ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
void processFile ( Resource resource , File file , File destDir ) throws IOException ;
void processFile ( Resource resource , File file , File destDir ) throws IOException ;
void processFile ( Resource resource , File file , File destDir ) throws IOException ;
void processFile ( Resource resource , File file , File destDir ) throws IOException ;
void processFile ( Resource resource , File file , File destDir ) throws IOException ;
void processFile ( Resource resource , File file , File destDir ) throws IOException ;
public void addUnmanagedTargetVolumeToUpdate ( UnManagedVolume volume ) { if ( null == _unmanagedTargetVolumesToUpdate ) { _unmanagedTargetVolumesToUpdate = new ArrayList < UnManagedVolume > ( ) ; } _unmanagedTargetVolumesToUpdate . add ( volume ) ; }
protected final ConfigurationLoader buildConfigurationLoader ( ) { DimensionLoader dimensionLoader = getDimensionLoader ( ) ; TableLoader tableLoader = getTableLoader ( ) ; MetricLoader metricLoader = getMetricLoader ( ) ; return buildConfigurationLoader ( dimensionLoader , metricLoader , tableLoader ) ; }
public long elapsed ( ) { return MILLISECONDS . convert ( System . nanoTime ( ) - _startTimeNanos , NANOSECONDS ) ; }
public void replaceFDViolatingTuplesWithMissing ( ) { for ( String premise : FDs . keySet ( ) ) { ArrayList < Integer > attrIndexes = new ArrayList < Integer > ( ) ; attrIndexes . add ( Integer . parseInt ( premise ) ) ; for ( String RHS : FDs . get ( premise ) ) { attrIndexes . add ( Integer . parseInt ( RHS ) ) ; } setMissingAtIndex ( violated , Util . convertIntegers ( attrIndexes ) ) ; } }
public void replaceFDViolatingTuplesWithMissing ( ) { for ( String premise : FDs . keySet ( ) ) { ArrayList < Integer > attrIndexes = new ArrayList < Integer > ( ) ; attrIndexes . add ( Integer . parseInt ( premise ) ) ; for ( String RHS : FDs . get ( premise ) ) { attrIndexes . add ( Integer . parseInt ( RHS ) ) ; } setMissingAtIndex ( violated , Util . convertIntegers ( attrIndexes ) ) ; } }
public static boolean assertCumulative ( final double [ ] da ) { final double tolerance = _NUM ; Exam . assertTrue ( Utils . realFormatArray ( da ) , da . length > _NUM ) ; double prev = Double . NEGATIVE_INFINITY ; for ( final double d : da ) { Exam . assertTrue ( Utils . realFormat ( d ) , d >= _NUM && d <= ( _NUM + tolerance ) && ! Double . isNaN ( d ) ) ; Exam . assertTrue ( prev <= d ) ; prev = d ; } if ( checkEquals ( _NUM , prev , tolerance ) ) { return _BOOL ; } throw new Exam . ExamException ( Utils . realFormatArray ( da ) ) ; }
public static boolean assertCumulative ( final double [ ] da ) { final double tolerance = _NUM ; Exam . assertTrue ( Utils . realFormatArray ( da ) , da . length > _NUM ) ; double prev = Double . NEGATIVE_INFINITY ; for ( final double d : da ) { Exam . assertTrue ( Utils . realFormat ( d ) , d >= _NUM && d <= ( _NUM + tolerance ) && ! Double . isNaN ( d ) ) ; Exam . assertTrue ( prev <= d ) ; prev = d ; } if ( checkEquals ( _NUM , prev , tolerance ) ) { return _BOOL ; } throw new Exam . ExamException ( Utils . realFormatArray ( da ) ) ; }
public static boolean assertCumulative ( final double [ ] da ) { final double tolerance = _NUM ; Exam . assertTrue ( Utils . realFormatArray ( da ) , da . length > _NUM ) ; double prev = Double . NEGATIVE_INFINITY ; for ( final double d : da ) { Exam . assertTrue ( Utils . realFormat ( d ) , d >= _NUM && d <= ( _NUM + tolerance ) && ! Double . isNaN ( d ) ) ; Exam . assertTrue ( prev <= d ) ; prev = d ; } if ( checkEquals ( _NUM , prev , tolerance ) ) { return _BOOL ; } throw new Exam . ExamException ( Utils . realFormatArray ( da ) ) ; }
public static boolean assertCumulative ( final double [ ] da ) { final double tolerance = _NUM ; Exam . assertTrue ( Utils . realFormatArray ( da ) , da . length > _NUM ) ; double prev = Double . NEGATIVE_INFINITY ; for ( final double d : da ) { Exam . assertTrue ( Utils . realFormat ( d ) , d >= _NUM && d <= ( _NUM + tolerance ) && ! Double . isNaN ( d ) ) ; Exam . assertTrue ( prev <= d ) ; prev = d ; } if ( checkEquals ( _NUM , prev , tolerance ) ) { return _BOOL ; } throw new Exam . ExamException ( Utils . realFormatArray ( da ) ) ; }
private boolean is_obstacle_clearance ( BrdItem curr_item ) { boolean is_obstacle = curr_item . is_obstacle ( this ) ; if ( ! is_obstacle ) return _BOOL ; if ( ! ( this instanceof BrdTracep && curr_item instanceof BrdTracep ) ) return _BOOL ; BrdTracep this_trace = ( BrdTracep ) this ; boolean contact_found = _BOOL ; PlaPoint contact_point = this_trace . corner_first ( ) ; Collection < BrdItem > curr_contacts = this_trace . get_normal_contacts ( contact_point , _BOOL ) ; if ( curr_contacts . contains ( curr_item ) ) contact_found = _BOOL ; if ( ! contact_found ) { contact_point = this_trace . corner_last ( ) ; curr_contacts = this_trace . get_normal_contacts ( contact_point , _BOOL ) ; if ( curr_contacts . contains ( curr_item ) ) contact_found = _BOOL ; } if ( ! contact_found ) return _BOOL ; for ( BrdItem curr_contact : curr_contacts ) { if ( ! ( curr_contact instanceof BrdAbitPin ) ) continue ; if ( curr_contact . shares_net ( this ) && curr_contact . shares_net ( curr_item ) ) return _BOOL ; } return _BOOL ; }
private boolean is_obstacle_clearance ( BrdItem curr_item ) { boolean is_obstacle = curr_item . is_obstacle ( this ) ; if ( ! is_obstacle ) return _BOOL ; if ( ! ( this instanceof BrdTracep && curr_item instanceof BrdTracep ) ) return _BOOL ; BrdTracep this_trace = ( BrdTracep ) this ; boolean contact_found = _BOOL ; PlaPoint contact_point = this_trace . corner_first ( ) ; Collection < BrdItem > curr_contacts = this_trace . get_normal_contacts ( contact_point , _BOOL ) ; if ( curr_contacts . contains ( curr_item ) ) contact_found = _BOOL ; if ( ! contact_found ) { contact_point = this_trace . corner_last ( ) ; curr_contacts = this_trace . get_normal_contacts ( contact_point , _BOOL ) ; if ( curr_contacts . contains ( curr_item ) ) contact_found = _BOOL ; } if ( ! contact_found ) return _BOOL ; for ( BrdItem curr_contact : curr_contacts ) { if ( ! ( curr_contact instanceof BrdAbitPin ) ) continue ; if ( curr_contact . shares_net ( this ) && curr_contact . shares_net ( curr_item ) ) return _BOOL ; } return _BOOL ; }
public void addListener ( Listener aListener ) { if ( aListener == null ) return ; if ( hexEditControl == null ) { if ( listOfStatusChangedListeners == null ) listOfStatusChangedListeners = new ArrayList < > ( ) ; listOfStatusChangedListeners . add ( aListener ) ; } else { hexEditControl . addListener ( SWT . Modify , aListener ) ; } }
@ SuppressWarnings ( STRING ) private Object fromReflectionType ( final Object value ) { FieldDescriptor descriptor = getDescriptor ( ) ; if ( descriptor . isRepeated ( ) ) { if ( descriptor . getJavaType ( ) == FieldDescriptor . JavaType . MESSAGE || descriptor . getJavaType ( ) == FieldDescriptor . JavaType . ENUM ) { final List result = new ArrayList ( ) ; for ( final Object element : ( List ) value ) { result . add ( singularFromReflectionType ( element ) ) ; } return result ; } else { return value ; } } else { return singularFromReflectionType ( value ) ; } }
@ SuppressWarnings ( STRING ) private Object fromReflectionType ( final Object value ) { FieldDescriptor descriptor = getDescriptor ( ) ; if ( descriptor . isRepeated ( ) ) { if ( descriptor . getJavaType ( ) == FieldDescriptor . JavaType . MESSAGE || descriptor . getJavaType ( ) == FieldDescriptor . JavaType . ENUM ) { final List result = new ArrayList ( ) ; for ( final Object element : ( List ) value ) { result . add ( singularFromReflectionType ( element ) ) ; } return result ; } else { return value ; } } else { return singularFromReflectionType ( value ) ; } }
@ SuppressWarnings ( STRING ) private Object fromReflectionType ( final Object value ) { FieldDescriptor descriptor = getDescriptor ( ) ; if ( descriptor . isRepeated ( ) ) { if ( descriptor . getJavaType ( ) == FieldDescriptor . JavaType . MESSAGE || descriptor . getJavaType ( ) == FieldDescriptor . JavaType . ENUM ) { final List result = new ArrayList ( ) ; for ( final Object element : ( List ) value ) { result . add ( singularFromReflectionType ( element ) ) ; } return result ; } else { return value ; } } else { return singularFromReflectionType ( value ) ; } }
@ SuppressWarnings ( STRING ) private Object fromReflectionType ( final Object value ) { FieldDescriptor descriptor = getDescriptor ( ) ; if ( descriptor . isRepeated ( ) ) { if ( descriptor . getJavaType ( ) == FieldDescriptor . JavaType . MESSAGE || descriptor . getJavaType ( ) == FieldDescriptor . JavaType . ENUM ) { final List result = new ArrayList ( ) ; for ( final Object element : ( List ) value ) { result . add ( singularFromReflectionType ( element ) ) ; } return result ; } else { return value ; } } else { return singularFromReflectionType ( value ) ; } }
public void flush ( ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . flush ( ) ; }
public void flush ( ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . flush ( ) ; }
public void flush ( ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . flush ( ) ; }
public void flush ( ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . flush ( ) ; }
@ TruffleBoundary static void exceptionEventForClientInstrument ( EventBinding < ? > b , String eventName , Throwable t ) { assert ! b . isLanguageBinding ( ) ; if ( t instanceof ThreadDeath ) { throw ( ThreadDeath ) t ; } InstrumentClientInstrumenter instrumenter = ( InstrumentClientInstrumenter ) b . getInstrumenter ( ) ; Class < ? > instrumentClass = instrumenter . getInstrumentClass ( ) ; String message = String . format ( STRING , eventName , instrumentClass . getName ( ) , b . getElement ( ) ) ; Exception exception = new Exception ( message , t ) ; PrintStream stream = new PrintStream ( instrumenter . getEnv ( ) . err ( ) ) ; exception . printStackTrace ( stream ) ; }
@ TruffleBoundary static void exceptionEventForClientInstrument ( EventBinding < ? > b , String eventName , Throwable t ) { assert ! b . isLanguageBinding ( ) ; if ( t instanceof ThreadDeath ) { throw ( ThreadDeath ) t ; } InstrumentClientInstrumenter instrumenter = ( InstrumentClientInstrumenter ) b . getInstrumenter ( ) ; Class < ? > instrumentClass = instrumenter . getInstrumentClass ( ) ; String message = String . format ( STRING , eventName , instrumentClass . getName ( ) , b . getElement ( ) ) ; Exception exception = new Exception ( message , t ) ; PrintStream stream = new PrintStream ( instrumenter . getEnv ( ) . err ( ) ) ; exception . printStackTrace ( stream ) ; }
@ TruffleBoundary static void exceptionEventForClientInstrument ( EventBinding < ? > b , String eventName , Throwable t ) { assert ! b . isLanguageBinding ( ) ; if ( t instanceof ThreadDeath ) { throw ( ThreadDeath ) t ; } InstrumentClientInstrumenter instrumenter = ( InstrumentClientInstrumenter ) b . getInstrumenter ( ) ; Class < ? > instrumentClass = instrumenter . getInstrumentClass ( ) ; String message = String . format ( STRING , eventName , instrumentClass . getName ( ) , b . getElement ( ) ) ; Exception exception = new Exception ( message , t ) ; PrintStream stream = new PrintStream ( instrumenter . getEnv ( ) . err ( ) ) ; exception . printStackTrace ( stream ) ; }
void terminatedRequest ( Integer index ) { serversCounters . decrementAndGet ( index ) ; }
@ Override public int following ( int offset ) { CharacterIterator text = getText ( ) ; checkOffset ( offset , text ) ; text . setIndex ( offset ) ; if ( offset == text . getBeginIndex ( ) ) { cachedLastKnownBreak = handleNext ( ) ; return cachedLastKnownBreak ; } int result = cachedLastKnownBreak ; if ( result >= offset || result <= BreakIterator . DONE ) { result = handlePrevious ( ) ; } else { text . setIndex ( result ) ; } while ( result != BreakIterator . DONE && result <= offset ) { result = handleNext ( ) ; } cachedLastKnownBreak = result ; return result ; }
public static Set combineOCs ( Set one , Set two ) { if ( one == null || one . isEmpty ( ) ) { return two ; } if ( two == null || two . isEmpty ( ) ) { return one ; } Set resultSet = new HashSet ( ) ; Iterator itr1 = one . iterator ( ) ; while ( itr1 . hasNext ( ) ) { String value1 = ( String ) itr1 . next ( ) ; resultSet . add ( value1 . toLowerCase ( ) ) ; } Iterator itr2 = two . iterator ( ) ; while ( itr2 . hasNext ( ) ) { String value2 = ( String ) itr2 . next ( ) ; resultSet . add ( value2 . toLowerCase ( ) ) ; } return resultSet ; }
public static Set combineOCs ( Set one , Set two ) { if ( one == null || one . isEmpty ( ) ) { return two ; } if ( two == null || two . isEmpty ( ) ) { return one ; } Set resultSet = new HashSet ( ) ; Iterator itr1 = one . iterator ( ) ; while ( itr1 . hasNext ( ) ) { String value1 = ( String ) itr1 . next ( ) ; resultSet . add ( value1 . toLowerCase ( ) ) ; } Iterator itr2 = two . iterator ( ) ; while ( itr2 . hasNext ( ) ) { String value2 = ( String ) itr2 . next ( ) ; resultSet . add ( value2 . toLowerCase ( ) ) ; } return resultSet ; }
public static Set combineOCs ( Set one , Set two ) { if ( one == null || one . isEmpty ( ) ) { return two ; } if ( two == null || two . isEmpty ( ) ) { return one ; } Set resultSet = new HashSet ( ) ; Iterator itr1 = one . iterator ( ) ; while ( itr1 . hasNext ( ) ) { String value1 = ( String ) itr1 . next ( ) ; resultSet . add ( value1 . toLowerCase ( ) ) ; } Iterator itr2 = two . iterator ( ) ; while ( itr2 . hasNext ( ) ) { String value2 = ( String ) itr2 . next ( ) ; resultSet . add ( value2 . toLowerCase ( ) ) ; } return resultSet ; }
public static Set combineOCs ( Set one , Set two ) { if ( one == null || one . isEmpty ( ) ) { return two ; } if ( two == null || two . isEmpty ( ) ) { return one ; } Set resultSet = new HashSet ( ) ; Iterator itr1 = one . iterator ( ) ; while ( itr1 . hasNext ( ) ) { String value1 = ( String ) itr1 . next ( ) ; resultSet . add ( value1 . toLowerCase ( ) ) ; } Iterator itr2 = two . iterator ( ) ; while ( itr2 . hasNext ( ) ) { String value2 = ( String ) itr2 . next ( ) ; resultSet . add ( value2 . toLowerCase ( ) ) ; } return resultSet ; }
public static Set combineOCs ( Set one , Set two ) { if ( one == null || one . isEmpty ( ) ) { return two ; } if ( two == null || two . isEmpty ( ) ) { return one ; } Set resultSet = new HashSet ( ) ; Iterator itr1 = one . iterator ( ) ; while ( itr1 . hasNext ( ) ) { String value1 = ( String ) itr1 . next ( ) ; resultSet . add ( value1 . toLowerCase ( ) ) ; } Iterator itr2 = two . iterator ( ) ; while ( itr2 . hasNext ( ) ) { String value2 = ( String ) itr2 . next ( ) ; resultSet . add ( value2 . toLowerCase ( ) ) ; } return resultSet ; }
public static Set combineOCs ( Set one , Set two ) { if ( one == null || one . isEmpty ( ) ) { return two ; } if ( two == null || two . isEmpty ( ) ) { return one ; } Set resultSet = new HashSet ( ) ; Iterator itr1 = one . iterator ( ) ; while ( itr1 . hasNext ( ) ) { String value1 = ( String ) itr1 . next ( ) ; resultSet . add ( value1 . toLowerCase ( ) ) ; } Iterator itr2 = two . iterator ( ) ; while ( itr2 . hasNext ( ) ) { String value2 = ( String ) itr2 . next ( ) ; resultSet . add ( value2 . toLowerCase ( ) ) ; } return resultSet ; }
public static Set combineOCs ( Set one , Set two ) { if ( one == null || one . isEmpty ( ) ) { return two ; } if ( two == null || two . isEmpty ( ) ) { return one ; } Set resultSet = new HashSet ( ) ; Iterator itr1 = one . iterator ( ) ; while ( itr1 . hasNext ( ) ) { String value1 = ( String ) itr1 . next ( ) ; resultSet . add ( value1 . toLowerCase ( ) ) ; } Iterator itr2 = two . iterator ( ) ; while ( itr2 . hasNext ( ) ) { String value2 = ( String ) itr2 . next ( ) ; resultSet . add ( value2 . toLowerCase ( ) ) ; } return resultSet ; }
public static Set combineOCs ( Set one , Set two ) { if ( one == null || one . isEmpty ( ) ) { return two ; } if ( two == null || two . isEmpty ( ) ) { return one ; } Set resultSet = new HashSet ( ) ; Iterator itr1 = one . iterator ( ) ; while ( itr1 . hasNext ( ) ) { String value1 = ( String ) itr1 . next ( ) ; resultSet . add ( value1 . toLowerCase ( ) ) ; } Iterator itr2 = two . iterator ( ) ; while ( itr2 . hasNext ( ) ) { String value2 = ( String ) itr2 . next ( ) ; resultSet . add ( value2 . toLowerCase ( ) ) ; } return resultSet ; }
@ Override public void closingOK ( ) { List < AddUserFields . AttributeSpec > specs = new ArrayList < AddUserFields . AttributeSpec > ( ) ; for ( int i = _NUM ; i < m_listModel . size ( ) ; i ++ ) { AddUserFields . AttributeSpec a = ( AddUserFields . AttributeSpec ) m_listModel . elementAt ( i ) ; specs . add ( a ) ; } if ( m_modifyL != null ) { m_modifyL . setModifiedStatus ( AddUserFieldsCustomizer . this , _BOOL ) ; } m_filter . setAttributeSpecs ( specs ) ; }
@ Override public void closingOK ( ) { List < AddUserFields . AttributeSpec > specs = new ArrayList < AddUserFields . AttributeSpec > ( ) ; for ( int i = _NUM ; i < m_listModel . size ( ) ; i ++ ) { AddUserFields . AttributeSpec a = ( AddUserFields . AttributeSpec ) m_listModel . elementAt ( i ) ; specs . add ( a ) ; } if ( m_modifyL != null ) { m_modifyL . setModifiedStatus ( AddUserFieldsCustomizer . this , _BOOL ) ; } m_filter . setAttributeSpecs ( specs ) ; }
@ Override public void closingOK ( ) { List < AddUserFields . AttributeSpec > specs = new ArrayList < AddUserFields . AttributeSpec > ( ) ; for ( int i = _NUM ; i < m_listModel . size ( ) ; i ++ ) { AddUserFields . AttributeSpec a = ( AddUserFields . AttributeSpec ) m_listModel . elementAt ( i ) ; specs . add ( a ) ; } if ( m_modifyL != null ) { m_modifyL . setModifiedStatus ( AddUserFieldsCustomizer . this , _BOOL ) ; } m_filter . setAttributeSpecs ( specs ) ; }
public static char [ ] createMethodSignature ( char [ ] [ ] parameterTypes , char [ ] returnType ) { int parameterTypesLength = parameterTypes . length ; int parameterLength = _NUM ; for ( int i = _NUM ; i < parameterTypesLength ; i ++ ) { parameterLength += parameterTypes [ i ] . length ; } int returnTypeLength = returnType . length ; char [ ] result = new char [ _NUM + parameterLength + _NUM + returnTypeLength ] ; result [ _NUM ] = C_PARAM_START ; int index = _NUM ; for ( int i = _NUM ; i < parameterTypesLength ; i ++ ) { char [ ] parameterType = parameterTypes [ i ] ; int length = parameterType . length ; System . arraycopy ( parameterType , _NUM , result , index , length ) ; index += length ; } result [ index ] = C_PARAM_END ; System . arraycopy ( returnType , _NUM , result , index + _NUM , returnTypeLength ) ; return result ; }
public static String joinStringList ( List < String > strList , String delimit ) { Iterator < String > entries = strList . iterator ( ) ; StringBuilder builder = new StringBuilder ( ) ; while ( entries . hasNext ( ) ) { builder . append ( entries . next ( ) ) ; if ( entries . hasNext ( ) ) { builder . append ( delimit ) ; } } return builder . toString ( ) ; }
public String lookup ( String data ) { Iterator < String > it = map . getPrefixedBy ( data ) ; if ( ! it . hasNext ( ) ) return null ; return it . next ( ) ; }
public String lookup ( String data ) { Iterator < String > it = map . getPrefixedBy ( data ) ; if ( ! it . hasNext ( ) ) return null ; return it . next ( ) ; }
public static String extractUriFromAddress ( String addr ) { String uri = addr ; int index = addr . indexOf ( STRING ) ; if ( index != - _NUM ) { uri = addr . substring ( index + _NUM , addr . indexOf ( STRING , index ) ) ; } return uri ; }
private Set mergeSet ( Set < String > set1 , Set < String > set2 ) { if ( set1 == null || set1 . isEmpty ( ) ) { if ( set2 == null || set2 . isEmpty ( ) ) { return Collections . EMPTY_SET ; } else { return set2 ; } } else { if ( set2 == null || set2 . isEmpty ( ) ) { return set1 ; } else { Set < String > returnSet = new HashSet < String > ( set1 ) ; returnSet . addAll ( set2 ) ; return returnSet ; } } }
private Set mergeSet ( Set < String > set1 , Set < String > set2 ) { if ( set1 == null || set1 . isEmpty ( ) ) { if ( set2 == null || set2 . isEmpty ( ) ) { return Collections . EMPTY_SET ; } else { return set2 ; } } else { if ( set2 == null || set2 . isEmpty ( ) ) { return set1 ; } else { Set < String > returnSet = new HashSet < String > ( set1 ) ; returnSet . addAll ( set2 ) ; return returnSet ; } } }
public boolean removeRow ( int row ) { if ( m_rows . isValidRow ( row ) ) { fireTableEvent ( row , row , TableModelEvent . ALL_COLUMNS , TableModelEvent . DELETE ) ; m_tuples . invalidate ( row ) ; m_rows . releaseRow ( row ) ; for ( Iterator cols = getColumns ( ) ; cols . hasNext ( ) ; ) { Column c = ( Column ) cols . next ( ) ; c . revertToDefault ( row ) ; } return _BOOL ; } return _BOOL ; }
public boolean optBoolean ( int index ) { return optBoolean ( index , _BOOL ) ; }
public static StructuralTypingResult result ( TypeRef left , TypeRef right , List < String > missingMembers , List < String > wrongMembersErrors ) { if ( missingMembers . isEmpty ( ) && wrongMembersErrors . isEmpty ( ) ) { return success ( ) ; } else { String msg = left . getTypeRefAsString ( ) + STRING + right . getTypeRefAsString ( ) + STRING ; if ( ! missingMembers . isEmpty ( ) ) { msg += STRING + missingMembers . get ( _NUM ) ; if ( missingMembers . size ( ) > _NUM ) { msg += STRING + ( missingMembers . size ( ) - _NUM ) + STRING ; } } if ( ! wrongMembersErrors . isEmpty ( ) ) { if ( ! missingMembers . isEmpty ( ) ) { msg += STRING ; } msg += wrongMembersErrors . get ( _NUM ) ; if ( wrongMembersErrors . size ( ) > _NUM ) { msg += STRING + ( wrongMembersErrors . size ( ) - _NUM ) + STRING ; } } return failure ( msg ) ; } }
private Watcher initWatcher ( SolrZkClient zkClient ) { wrappedWatcher = new ProcessStateWatcher ( ) ; return zkClient . wrapWatcher ( wrappedWatcher ) ; }
private Watcher initWatcher ( SolrZkClient zkClient ) { wrappedWatcher = new ProcessStateWatcher ( ) ; return zkClient . wrapWatcher ( wrappedWatcher ) ; }
private Watcher initWatcher ( SolrZkClient zkClient ) { wrappedWatcher = new ProcessStateWatcher ( ) ; return zkClient . wrapWatcher ( wrappedWatcher ) ; }
private Watcher initWatcher ( SolrZkClient zkClient ) { wrappedWatcher = new ProcessStateWatcher ( ) ; return zkClient . wrapWatcher ( wrappedWatcher ) ; }
public static byte [ ] stringToGsm7BitPackedWithHeader ( String data , byte [ ] header , int languageTable , int languageShiftTable ) throws EncodeException { if ( header == null || header . length == _NUM ) { return stringToGsm7BitPacked ( data , languageTable , languageShiftTable ) ; } int headerBits = ( header . length + _NUM ) * _NUM ; int headerSeptets = ( headerBits + _NUM ) / _NUM ; byte [ ] ret = stringToGsm7BitPacked ( data , headerSeptets , _BOOL , languageTable , languageShiftTable ) ; ret [ _NUM ] = ( byte ) header . length ; System . arraycopy ( header , _NUM , ret , _NUM , header . length ) ; return ret ; }
public static byte [ ] stringToGsm7BitPackedWithHeader ( String data , byte [ ] header , int languageTable , int languageShiftTable ) throws EncodeException { if ( header == null || header . length == _NUM ) { return stringToGsm7BitPacked ( data , languageTable , languageShiftTable ) ; } int headerBits = ( header . length + _NUM ) * _NUM ; int headerSeptets = ( headerBits + _NUM ) / _NUM ; byte [ ] ret = stringToGsm7BitPacked ( data , headerSeptets , _BOOL , languageTable , languageShiftTable ) ; ret [ _NUM ] = ( byte ) header . length ; System . arraycopy ( header , _NUM , ret , _NUM , header . length ) ; return ret ; }
public static byte [ ] stringToGsm7BitPackedWithHeader ( String data , byte [ ] header , int languageTable , int languageShiftTable ) throws EncodeException { if ( header == null || header . length == _NUM ) { return stringToGsm7BitPacked ( data , languageTable , languageShiftTable ) ; } int headerBits = ( header . length + _NUM ) * _NUM ; int headerSeptets = ( headerBits + _NUM ) / _NUM ; byte [ ] ret = stringToGsm7BitPacked ( data , headerSeptets , _BOOL , languageTable , languageShiftTable ) ; ret [ _NUM ] = ( byte ) header . length ; System . arraycopy ( header , _NUM , ret , _NUM , header . length ) ; return ret ; }
public static byte [ ] stringToGsm7BitPackedWithHeader ( String data , byte [ ] header , int languageTable , int languageShiftTable ) throws EncodeException { if ( header == null || header . length == _NUM ) { return stringToGsm7BitPacked ( data , languageTable , languageShiftTable ) ; } int headerBits = ( header . length + _NUM ) * _NUM ; int headerSeptets = ( headerBits + _NUM ) / _NUM ; byte [ ] ret = stringToGsm7BitPacked ( data , headerSeptets , _BOOL , languageTable , languageShiftTable ) ; ret [ _NUM ] = ( byte ) header . length ; System . arraycopy ( header , _NUM , ret , _NUM , header . length ) ; return ret ; }
public static byte [ ] stringToGsm7BitPackedWithHeader ( String data , byte [ ] header , int languageTable , int languageShiftTable ) throws EncodeException { if ( header == null || header . length == _NUM ) { return stringToGsm7BitPacked ( data , languageTable , languageShiftTable ) ; } int headerBits = ( header . length + _NUM ) * _NUM ; int headerSeptets = ( headerBits + _NUM ) / _NUM ; byte [ ] ret = stringToGsm7BitPacked ( data , headerSeptets , _BOOL , languageTable , languageShiftTable ) ; ret [ _NUM ] = ( byte ) header . length ; System . arraycopy ( header , _NUM , ret , _NUM , header . length ) ; return ret ; }
public static byte [ ] stringToGsm7BitPackedWithHeader ( String data , byte [ ] header , int languageTable , int languageShiftTable ) throws EncodeException { if ( header == null || header . length == _NUM ) { return stringToGsm7BitPacked ( data , languageTable , languageShiftTable ) ; } int headerBits = ( header . length + _NUM ) * _NUM ; int headerSeptets = ( headerBits + _NUM ) / _NUM ; byte [ ] ret = stringToGsm7BitPacked ( data , headerSeptets , _BOOL , languageTable , languageShiftTable ) ; ret [ _NUM ] = ( byte ) header . length ; System . arraycopy ( header , _NUM , ret , _NUM , header . length ) ; return ret ; }
public static byte [ ] stringToGsm7BitPackedWithHeader ( String data , byte [ ] header , int languageTable , int languageShiftTable ) throws EncodeException { if ( header == null || header . length == _NUM ) { return stringToGsm7BitPacked ( data , languageTable , languageShiftTable ) ; } int headerBits = ( header . length + _NUM ) * _NUM ; int headerSeptets = ( headerBits + _NUM ) / _NUM ; byte [ ] ret = stringToGsm7BitPacked ( data , headerSeptets , _BOOL , languageTable , languageShiftTable ) ; ret [ _NUM ] = ( byte ) header . length ; System . arraycopy ( header , _NUM , ret , _NUM , header . length ) ; return ret ; }
public static byte [ ] stringToGsm7BitPackedWithHeader ( String data , byte [ ] header , int languageTable , int languageShiftTable ) throws EncodeException { if ( header == null || header . length == _NUM ) { return stringToGsm7BitPacked ( data , languageTable , languageShiftTable ) ; } int headerBits = ( header . length + _NUM ) * _NUM ; int headerSeptets = ( headerBits + _NUM ) / _NUM ; byte [ ] ret = stringToGsm7BitPacked ( data , headerSeptets , _BOOL , languageTable , languageShiftTable ) ; ret [ _NUM ] = ( byte ) header . length ; System . arraycopy ( header , _NUM , ret , _NUM , header . length ) ; return ret ; }
public static byte [ ] stringToGsm7BitPackedWithHeader ( String data , byte [ ] header , int languageTable , int languageShiftTable ) throws EncodeException { if ( header == null || header . length == _NUM ) { return stringToGsm7BitPacked ( data , languageTable , languageShiftTable ) ; } int headerBits = ( header . length + _NUM ) * _NUM ; int headerSeptets = ( headerBits + _NUM ) / _NUM ; byte [ ] ret = stringToGsm7BitPacked ( data , headerSeptets , _BOOL , languageTable , languageShiftTable ) ; ret [ _NUM ] = ( byte ) header . length ; System . arraycopy ( header , _NUM , ret , _NUM , header . length ) ; return ret ; }
public static byte [ ] stringToGsm7BitPackedWithHeader ( String data , byte [ ] header , int languageTable , int languageShiftTable ) throws EncodeException { if ( header == null || header . length == _NUM ) { return stringToGsm7BitPacked ( data , languageTable , languageShiftTable ) ; } int headerBits = ( header . length + _NUM ) * _NUM ; int headerSeptets = ( headerBits + _NUM ) / _NUM ; byte [ ] ret = stringToGsm7BitPacked ( data , headerSeptets , _BOOL , languageTable , languageShiftTable ) ; ret [ _NUM ] = ( byte ) header . length ; System . arraycopy ( header , _NUM , ret , _NUM , header . length ) ; return ret ; }
public static synchronized byte [ ] generateNonce ( int length ) throws NoSuchAlgorithmException { if ( random == null ) { random = SecureRandom . getInstance ( STRING ) ; } byte [ ] temp = new byte [ length ] ; random . nextBytes ( temp ) ; return temp ; }
public static synchronized byte [ ] generateNonce ( int length ) throws NoSuchAlgorithmException { if ( random == null ) { random = SecureRandom . getInstance ( STRING ) ; } byte [ ] temp = new byte [ length ] ; random . nextBytes ( temp ) ; return temp ; }
public static synchronized byte [ ] generateNonce ( int length ) throws NoSuchAlgorithmException { if ( random == null ) { random = SecureRandom . getInstance ( STRING ) ; } byte [ ] temp = new byte [ length ] ; random . nextBytes ( temp ) ; return temp ; }
static private byte [ ] classNameToBytes ( String cn ) { return cn . getBytes ( ) ; }
static private byte [ ] classNameToBytes ( String cn ) { return cn . getBytes ( ) ; }
static private byte [ ] classNameToBytes ( String cn ) { return cn . getBytes ( ) ; }
public static void write ( float x ) { write ( Float . floatToRawIntBits ( x ) ) ; }
public static void checkSerializedEquality ( Object object ) { Object object2 = serializeAndRecover ( object ) ; Assert . assertEquals ( STRING , object , object2 ) ; Assert . assertEquals ( STRING , object . hashCode ( ) , object2 . hashCode ( ) ) ; }
public static void checkSerializedEquality ( Object object ) { Object object2 = serializeAndRecover ( object ) ; Assert . assertEquals ( STRING , object , object2 ) ; Assert . assertEquals ( STRING , object . hashCode ( ) , object2 . hashCode ( ) ) ; }
public void defineFillStyle ( Color color2 ) { Color color = color2 ; if ( color == null ) { color = new Color ( _NUM , _NUM , _NUM ) ; } ColorFill fill = new ColorFill ( color ) ; if ( color instanceof AlphaColor ) { hasAlpha = _BOOL ; } elements . add ( fill ) ; }
public void writeBinary ( final PacketOutputStream writeBuffer ) { if ( options . useLegacyDatetimeCode ) calendar = Calendar . getInstance ( ) ; calendar . setTimeInMillis ( ts . getTime ( ) ) ; writeBuffer . writeTimestampLength ( calendar , ts , fractionalSeconds ) ; }
public void writeBinary ( final PacketOutputStream writeBuffer ) { if ( options . useLegacyDatetimeCode ) calendar = Calendar . getInstance ( ) ; calendar . setTimeInMillis ( ts . getTime ( ) ) ; writeBuffer . writeTimestampLength ( calendar , ts , fractionalSeconds ) ; }
public static boolean verifyDestination ( String destination , String location ) { return ( ( location != null ) && ( location . length ( ) != _NUM ) && ( destination != null ) && ( destination . length ( ) != _NUM ) && ( location . equalsIgnoreCase ( destination ) ) ) ; }
protected void startResetExpiredJobsThread ( ) { if ( resetExpiredJobThread == null ) { resetExpiredJobThread = new Thread ( resetExpiredJobsRunnable ) ; } resetExpiredJobThread . start ( ) ; }
public void populateEditText ( String match ) { toggleSearch ( ) ; String text = match . trim ( ) ; setSearchString ( text ) ; search ( text ) ; }
public void populateEditText ( String match ) { toggleSearch ( ) ; String text = match . trim ( ) ; setSearchString ( text ) ; search ( text ) ; }
@ Override public boolean isSupported ( ) { final PackageInfo packageInfo = PackageManagers . getPackageInfo ( activity , UBER_PACKAGE_NAME ) ; return ( packageInfo != null ) && ( packageInfo . versionCode >= MIN_VERSION_SUPPORTED ) && appProtocol . validateSignature ( activity , UBER_PACKAGE_NAME ) ; }
@ Override public boolean isSupported ( ) { final PackageInfo packageInfo = PackageManagers . getPackageInfo ( activity , UBER_PACKAGE_NAME ) ; return ( packageInfo != null ) && ( packageInfo . versionCode >= MIN_VERSION_SUPPORTED ) && appProtocol . validateSignature ( activity , UBER_PACKAGE_NAME ) ; }
public SearchResult current ( ) { return m_reducedResults . isEmpty ( ) ? null : m_reducedResults . get ( m_currentSearchIndex ) ; }
public NtpMessage ( ) { this . mode = _NUM ; this . transmitTimestamp = ( System . currentTimeMillis ( ) / _NUM ) + _NUM ; }
public NtpMessage ( ) { this . mode = _NUM ; this . transmitTimestamp = ( System . currentTimeMillis ( ) / _NUM ) + _NUM ; }
public abstract void doneWithDirectory ( Directory directory ) throws IOException ;
public abstract void doneWithDirectory ( Directory directory ) throws IOException ;
public abstract void doneWithDirectory ( Directory directory ) throws IOException ;
public abstract void doneWithDirectory ( Directory directory ) throws IOException ;
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case _NUM : return STRING_THING ; case _NUM : return CHANGED ; case _NUM : return I32_THING ; case _NUM : return I64_THING ; default : return null ; } }
public void fixConversion ( String rep ) { if ( sHashCode != rep . hashCode ( ) ) throw new RuntimeException ( STRING ) ; if ( s == null ) { s = rep ; } }
public void fixConversion ( String rep ) { if ( sHashCode != rep . hashCode ( ) ) throw new RuntimeException ( STRING ) ; if ( s == null ) { s = rep ; } }
public void fixConversion ( String rep ) { if ( sHashCode != rep . hashCode ( ) ) throw new RuntimeException ( STRING ) ; if ( s == null ) { s = rep ; } }
public void fixConversion ( String rep ) { if ( sHashCode != rep . hashCode ( ) ) throw new RuntimeException ( STRING ) ; if ( s == null ) { s = rep ; } }
public void fixConversion ( String rep ) { if ( sHashCode != rep . hashCode ( ) ) throw new RuntimeException ( STRING ) ; if ( s == null ) { s = rep ; } }
public void fixConversion ( String rep ) { if ( sHashCode != rep . hashCode ( ) ) throw new RuntimeException ( STRING ) ; if ( s == null ) { s = rep ; } }
public void fixConversion ( String rep ) { if ( sHashCode != rep . hashCode ( ) ) throw new RuntimeException ( STRING ) ; if ( s == null ) { s = rep ; } }
public void testBug33734 ( ) throws Exception { Connection testConn = getConnectionWithProps ( STRING ) ; try { testConn . prepareStatement ( STRING ) ; } finally { testConn . close ( ) ; } }
protected void allocResource ( Object resource ) { alloced . add ( resource ) ; }
protected void allocResource ( Object resource ) { alloced . add ( resource ) ; }
protected void allocResource ( Object resource ) { alloced . add ( resource ) ; }
final public int loadUnsigned8 ( int addr ) { return loadUnsigned8 ( addr , AccessSource . CODE ) ; }
public boolean isEmpty ( ) { return ( intervals . length == _NUM ) ; }
public boolean isEmpty ( ) { return ( intervals . length == _NUM ) ; }
public void groupBy ( String column ) throws QueryPlanException { this . groupByColumn = column ; }
public void groupBy ( String column ) throws QueryPlanException { this . groupByColumn = column ; }
public void groupBy ( String column ) throws QueryPlanException { this . groupByColumn = column ; }
private void validateStoragePolicySelection ( StoragePolicySelection storagePolicySelection ) { Assert . notNull ( storagePolicySelection , STRING ) ; businessObjectDataHelper . validateBusinessObjectDataKey ( storagePolicySelection . getBusinessObjectDataKey ( ) , _BOOL , _BOOL ) ; storagePolicyHelper . validateStoragePolicyKey ( storagePolicySelection . getStoragePolicyKey ( ) ) ; Assert . notNull ( storagePolicySelection . getStoragePolicyVersion ( ) , STRING ) ; }
private void validateStoragePolicySelection ( StoragePolicySelection storagePolicySelection ) { Assert . notNull ( storagePolicySelection , STRING ) ; businessObjectDataHelper . validateBusinessObjectDataKey ( storagePolicySelection . getBusinessObjectDataKey ( ) , _BOOL , _BOOL ) ; storagePolicyHelper . validateStoragePolicyKey ( storagePolicySelection . getStoragePolicyKey ( ) ) ; Assert . notNull ( storagePolicySelection . getStoragePolicyVersion ( ) , STRING ) ; }
public IncompleteAnnotationException ( Class < ? extends Annotation > annotationType , String elementName ) { super ( annotationType . getName ( ) + STRING + elementName . toString ( ) ) ; this . annotationType = annotationType ; this . elementName = elementName ; }
public IncompleteAnnotationException ( Class < ? extends Annotation > annotationType , String elementName ) { super ( annotationType . getName ( ) + STRING + elementName . toString ( ) ) ; this . annotationType = annotationType ; this . elementName = elementName ; }
private void putEntry ( String key , CacheHeader entry ) { if ( ! mEntries . containsKey ( key ) ) { mTotalSize += entry . size ; } else { CacheHeader oldEntry = mEntries . get ( key ) ; mTotalSize += ( entry . size - oldEntry . size ) ; } mEntries . put ( key , entry ) ; }
public void doWindowOpen ( ) { doConnect ( ) ; }
@ Override public void actionPerformed ( ActionEvent e ) { FileDialog chooser = new FileDialog ( frame , STRING , FileDialog . SAVE ) ; chooser . setVisible ( _BOOL ) ; if ( chooser . getFile ( ) != null ) { save ( chooser . getDirectory ( ) + File . separator + chooser . getFile ( ) ) ; } }
public void withTransaction ( Closure closure ) throws SQLException { boolean savedCacheConnection = cacheConnection ; cacheConnection = _BOOL ; Connection connection = null ; boolean savedAutoCommit = _BOOL ; try { connection = createConnection ( ) ; savedAutoCommit = connection . getAutoCommit ( ) ; connection . setAutoCommit ( _BOOL ) ; callClosurePossiblyWithConnection ( closure , connection ) ; connection . commit ( ) ; } catch ( SQLException e ) { handleError ( connection , e ) ; throw e ; } catch ( RuntimeException e ) { handleError ( connection , e ) ; throw e ; } catch ( Error e ) { handleError ( connection , e ) ; throw e ; } catch ( Exception e ) { handleError ( connection , e ) ; throw new SQLException ( STRING , e ) ; } finally { if ( connection != null ) { try { connection . setAutoCommit ( savedAutoCommit ) ; } catch ( SQLException e ) { LOG . finest ( STRING + e . getMessage ( ) + STRING ) ; } } cacheConnection = _BOOL ; closeResources ( connection , null ) ; cacheConnection = savedCacheConnection ; if ( dataSource != null && ! cacheConnection ) { useConnection = null ; } } }
public void withTransaction ( Closure closure ) throws SQLException { boolean savedCacheConnection = cacheConnection ; cacheConnection = _BOOL ; Connection connection = null ; boolean savedAutoCommit = _BOOL ; try { connection = createConnection ( ) ; savedAutoCommit = connection . getAutoCommit ( ) ; connection . setAutoCommit ( _BOOL ) ; callClosurePossiblyWithConnection ( closure , connection ) ; connection . commit ( ) ; } catch ( SQLException e ) { handleError ( connection , e ) ; throw e ; } catch ( RuntimeException e ) { handleError ( connection , e ) ; throw e ; } catch ( Error e ) { handleError ( connection , e ) ; throw e ; } catch ( Exception e ) { handleError ( connection , e ) ; throw new SQLException ( STRING , e ) ; } finally { if ( connection != null ) { try { connection . setAutoCommit ( savedAutoCommit ) ; } catch ( SQLException e ) { LOG . finest ( STRING + e . getMessage ( ) + STRING ) ; } } cacheConnection = _BOOL ; closeResources ( connection , null ) ; cacheConnection = savedCacheConnection ; if ( dataSource != null && ! cacheConnection ) { useConnection = null ; } } }
public void withTransaction ( Closure closure ) throws SQLException { boolean savedCacheConnection = cacheConnection ; cacheConnection = _BOOL ; Connection connection = null ; boolean savedAutoCommit = _BOOL ; try { connection = createConnection ( ) ; savedAutoCommit = connection . getAutoCommit ( ) ; connection . setAutoCommit ( _BOOL ) ; callClosurePossiblyWithConnection ( closure , connection ) ; connection . commit ( ) ; } catch ( SQLException e ) { handleError ( connection , e ) ; throw e ; } catch ( RuntimeException e ) { handleError ( connection , e ) ; throw e ; } catch ( Error e ) { handleError ( connection , e ) ; throw e ; } catch ( Exception e ) { handleError ( connection , e ) ; throw new SQLException ( STRING , e ) ; } finally { if ( connection != null ) { try { connection . setAutoCommit ( savedAutoCommit ) ; } catch ( SQLException e ) { LOG . finest ( STRING + e . getMessage ( ) + STRING ) ; } } cacheConnection = _BOOL ; closeResources ( connection , null ) ; cacheConnection = savedCacheConnection ; if ( dataSource != null && ! cacheConnection ) { useConnection = null ; } } }
public void withTransaction ( Closure closure ) throws SQLException { boolean savedCacheConnection = cacheConnection ; cacheConnection = _BOOL ; Connection connection = null ; boolean savedAutoCommit = _BOOL ; try { connection = createConnection ( ) ; savedAutoCommit = connection . getAutoCommit ( ) ; connection . setAutoCommit ( _BOOL ) ; callClosurePossiblyWithConnection ( closure , connection ) ; connection . commit ( ) ; } catch ( SQLException e ) { handleError ( connection , e ) ; throw e ; } catch ( RuntimeException e ) { handleError ( connection , e ) ; throw e ; } catch ( Error e ) { handleError ( connection , e ) ; throw e ; } catch ( Exception e ) { handleError ( connection , e ) ; throw new SQLException ( STRING , e ) ; } finally { if ( connection != null ) { try { connection . setAutoCommit ( savedAutoCommit ) ; } catch ( SQLException e ) { LOG . finest ( STRING + e . getMessage ( ) + STRING ) ; } } cacheConnection = _BOOL ; closeResources ( connection , null ) ; cacheConnection = savedCacheConnection ; if ( dataSource != null && ! cacheConnection ) { useConnection = null ; } } }
public Section ( Location location , Location location2 ) { this . minX = Math . min ( location . getBlockX ( ) , location2 . getBlockX ( ) ) ; this . minY = Math . min ( location . getBlockY ( ) , location2 . getBlockY ( ) ) ; this . minZ = Math . min ( location . getBlockZ ( ) , location2 . getBlockZ ( ) ) ; this . maxX = Math . max ( location . getBlockX ( ) , location2 . getBlockX ( ) ) ; this . maxY = Math . max ( location . getBlockY ( ) , location2 . getBlockY ( ) ) ; this . maxZ = Math . max ( location . getBlockZ ( ) , location2 . getBlockZ ( ) ) ; this . world = location . getWorld ( ) ; }
public Section ( Location location , Location location2 ) { this . minX = Math . min ( location . getBlockX ( ) , location2 . getBlockX ( ) ) ; this . minY = Math . min ( location . getBlockY ( ) , location2 . getBlockY ( ) ) ; this . minZ = Math . min ( location . getBlockZ ( ) , location2 . getBlockZ ( ) ) ; this . maxX = Math . max ( location . getBlockX ( ) , location2 . getBlockX ( ) ) ; this . maxY = Math . max ( location . getBlockY ( ) , location2 . getBlockY ( ) ) ; this . maxZ = Math . max ( location . getBlockZ ( ) , location2 . getBlockZ ( ) ) ; this . world = location . getWorld ( ) ; }
public Section ( Location location , Location location2 ) { this . minX = Math . min ( location . getBlockX ( ) , location2 . getBlockX ( ) ) ; this . minY = Math . min ( location . getBlockY ( ) , location2 . getBlockY ( ) ) ; this . minZ = Math . min ( location . getBlockZ ( ) , location2 . getBlockZ ( ) ) ; this . maxX = Math . max ( location . getBlockX ( ) , location2 . getBlockX ( ) ) ; this . maxY = Math . max ( location . getBlockY ( ) , location2 . getBlockY ( ) ) ; this . maxZ = Math . max ( location . getBlockZ ( ) , location2 . getBlockZ ( ) ) ; this . world = location . getWorld ( ) ; }
public Section ( Location location , Location location2 ) { this . minX = Math . min ( location . getBlockX ( ) , location2 . getBlockX ( ) ) ; this . minY = Math . min ( location . getBlockY ( ) , location2 . getBlockY ( ) ) ; this . minZ = Math . min ( location . getBlockZ ( ) , location2 . getBlockZ ( ) ) ; this . maxX = Math . max ( location . getBlockX ( ) , location2 . getBlockX ( ) ) ; this . maxY = Math . max ( location . getBlockY ( ) , location2 . getBlockY ( ) ) ; this . maxZ = Math . max ( location . getBlockZ ( ) , location2 . getBlockZ ( ) ) ; this . world = location . getWorld ( ) ; }
public static < K > Map < K , Double > normalizeInvert ( Map < K , Double > map ) { Double maxValue = _NUM ; for ( Double v : map . values ( ) ) { if ( v > maxValue ) maxValue = v ; } for ( Map . Entry < K , Double > e : map . entrySet ( ) ) { map . put ( e . getKey ( ) , _NUM - map . get ( e . getKey ( ) ) / maxValue ) ; } return map ; }
private void doNormalCommandLineList ( List < String > commandLineList , List < String > jointOptions , Path classpath ) { commandLineList . add ( STRING ) ; commandLineList . add ( classpath . toString ( ) ) ; if ( jointCompilation ) { commandLineList . add ( STRING ) ; commandLineList . addAll ( jointOptions ) ; } if ( destDir != null ) { commandLineList . add ( STRING ) ; commandLineList . add ( destDir . getPath ( ) ) ; } if ( encoding != null ) { commandLineList . add ( STRING ) ; commandLineList . add ( encoding ) ; } if ( stacktrace ) { commandLineList . add ( STRING ) ; } if ( parameters ) { commandLineList . add ( STRING ) ; } if ( useIndy ) { commandLineList . add ( STRING ) ; } if ( scriptBaseClass != null ) { commandLineList . add ( STRING ) ; commandLineList . add ( scriptBaseClass ) ; } if ( configscript != null ) { commandLineList . add ( STRING ) ; commandLineList . add ( configscript ) ; } }
private void doNormalCommandLineList ( List < String > commandLineList , List < String > jointOptions , Path classpath ) { commandLineList . add ( STRING ) ; commandLineList . add ( classpath . toString ( ) ) ; if ( jointCompilation ) { commandLineList . add ( STRING ) ; commandLineList . addAll ( jointOptions ) ; } if ( destDir != null ) { commandLineList . add ( STRING ) ; commandLineList . add ( destDir . getPath ( ) ) ; } if ( encoding != null ) { commandLineList . add ( STRING ) ; commandLineList . add ( encoding ) ; } if ( stacktrace ) { commandLineList . add ( STRING ) ; } if ( parameters ) { commandLineList . add ( STRING ) ; } if ( useIndy ) { commandLineList . add ( STRING ) ; } if ( scriptBaseClass != null ) { commandLineList . add ( STRING ) ; commandLineList . add ( scriptBaseClass ) ; } if ( configscript != null ) { commandLineList . add ( STRING ) ; commandLineList . add ( configscript ) ; } }
public void removeListener ( SearchListener listener ) { listeners . remove ( listener ) ; }
public static boolean isSignEqual ( Context ctx , String apkFile ) { String packageSign = getInstallPackageSignature ( ctx , ctx . getPackageName ( ) ) ; String apkFileSign = getApkSignature ( apkFile ) ; return TextUtils . equals ( packageSign , apkFileSign ) ; }
public static String toString ( final boolean value ) { return value ? STRING : STRING ; }
public static String toString ( final boolean value ) { return value ? STRING : STRING ; }
public static boolean isEmptyOrBlanks ( String string ) { if ( string == null || string . length ( ) == _NUM ) { return _BOOL ; } for ( int i = _NUM ; i < string . length ( ) ; i ++ ) { char c = string . charAt ( i ) ; if ( ! Character . isWhitespace ( c ) ) { return _BOOL ; } } return _BOOL ; }
public static boolean isEmptyOrBlanks ( String string ) { if ( string == null || string . length ( ) == _NUM ) { return _BOOL ; } for ( int i = _NUM ; i < string . length ( ) ; i ++ ) { char c = string . charAt ( i ) ; if ( ! Character . isWhitespace ( c ) ) { return _BOOL ; } } return _BOOL ; }
@ Override public void close ( ) throws IOException { in . close ( ) ; }
@ Override public void close ( ) throws IOException { in . close ( ) ; }
private void finalizeProjectCreation ( Project project , String visibility ) throws ServerException , ForbiddenException { final ProjectMisc misc = project . getMisc ( ) ; misc . setCreationDate ( System . currentTimeMillis ( ) ) ; misc . save ( ) ; if ( visibility != null ) { project . setVisibility ( visibility ) ; } }
private void finalizeProjectCreation ( Project project , String visibility ) throws ServerException , ForbiddenException { final ProjectMisc misc = project . getMisc ( ) ; misc . setCreationDate ( System . currentTimeMillis ( ) ) ; misc . save ( ) ; if ( visibility != null ) { project . setVisibility ( visibility ) ; } }
public StartListener ( Object resource ) { _resource = resource ; }
public static boolean stringToFile ( final String data , final File targetFile , final boolean doAppend ) { if ( targetFile == null || ! isWritable ( targetFile , _BOOL ) ) { Log . e ( FileUtils . class , STRING ) ; return _BOOL ; } boolean isSucceed = _BOOL ; try { final FileWriter out = new FileWriter ( targetFile , doAppend ) ; out . write ( data ) ; out . flush ( ) ; out . close ( ) ; } catch ( IOException e ) { isSucceed = _BOOL ; } return isSucceed ; }
@ SuppressWarnings ( STRING ) @ Override public void paintIcon ( Component c , Graphics g , int x , int y ) { SeaGlassPainter painter = ( SeaGlassPainter ) UIManager . get ( prefix + STRING + key ) ; if ( painter != null ) { JComponent jc = ( c instanceof JComponent ) ? ( JComponent ) c : null ; Graphics2D gfx = ( Graphics2D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
@ SuppressWarnings ( STRING ) @ Override public void paintIcon ( Component c , Graphics g , int x , int y ) { SeaGlassPainter painter = ( SeaGlassPainter ) UIManager . get ( prefix + STRING + key ) ; if ( painter != null ) { JComponent jc = ( c instanceof JComponent ) ? ( JComponent ) c : null ; Graphics2D gfx = ( Graphics2D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
@ SuppressWarnings ( STRING ) @ Override public void paintIcon ( Component c , Graphics g , int x , int y ) { SeaGlassPainter painter = ( SeaGlassPainter ) UIManager . get ( prefix + STRING + key ) ; if ( painter != null ) { JComponent jc = ( c instanceof JComponent ) ? ( JComponent ) c : null ; Graphics2D gfx = ( Graphics2D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
@ SuppressWarnings ( STRING ) @ Override public void paintIcon ( Component c , Graphics g , int x , int y ) { SeaGlassPainter painter = ( SeaGlassPainter ) UIManager . get ( prefix + STRING + key ) ; if ( painter != null ) { JComponent jc = ( c instanceof JComponent ) ? ( JComponent ) c : null ; Graphics2D gfx = ( Graphics2D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
@ SuppressWarnings ( STRING ) @ Override public void paintIcon ( Component c , Graphics g , int x , int y ) { SeaGlassPainter painter = ( SeaGlassPainter ) UIManager . get ( prefix + STRING + key ) ; if ( painter != null ) { JComponent jc = ( c instanceof JComponent ) ? ( JComponent ) c : null ; Graphics2D gfx = ( Graphics2D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
@ SuppressWarnings ( STRING ) @ Override public void paintIcon ( Component c , Graphics g , int x , int y ) { SeaGlassPainter painter = ( SeaGlassPainter ) UIManager . get ( prefix + STRING + key ) ; if ( painter != null ) { JComponent jc = ( c instanceof JComponent ) ? ( JComponent ) c : null ; Graphics2D gfx = ( Graphics2D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
@ SuppressWarnings ( STRING ) @ Override public void paintIcon ( Component c , Graphics g , int x , int y ) { SeaGlassPainter painter = ( SeaGlassPainter ) UIManager . get ( prefix + STRING + key ) ; if ( painter != null ) { JComponent jc = ( c instanceof JComponent ) ? ( JComponent ) c : null ; Graphics2D gfx = ( Graphics2D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
private String mutator ( String httpRequest , String staticResourceFolder , String payload ) { return httpRequest . replaceFirst ( staticResourceFolder + STRING , payload + STRING ) ; }
private String mutator ( String httpRequest , String staticResourceFolder , String payload ) { return httpRequest . replaceFirst ( staticResourceFolder + STRING , payload + STRING ) ; }
private String mutator ( String httpRequest , String staticResourceFolder , String payload ) { return httpRequest . replaceFirst ( staticResourceFolder + STRING , payload + STRING ) ; }
private static void adjustMappingPairVector ( int col , int incr , Vector < MappingPair > vec ) { int i ; for ( i = _NUM ; ( i < vec . size ( ) ) && ( vec . elementAt ( i ) . col < col ) ; i ++ ) { } if ( i == vec . size ( ) ) { vec . add ( new MappingPair ( col , incr ) ) ; } else if ( vec . elementAt ( i ) . col == col ) { vec . elementAt ( i ) . inc = vec . elementAt ( i ) . inc + incr ; } else { vec . insertElementAt ( new MappingPair ( col , incr ) , i ) ; } }
private static void adjustMappingPairVector ( int col , int incr , Vector < MappingPair > vec ) { int i ; for ( i = _NUM ; ( i < vec . size ( ) ) && ( vec . elementAt ( i ) . col < col ) ; i ++ ) { } if ( i == vec . size ( ) ) { vec . add ( new MappingPair ( col , incr ) ) ; } else if ( vec . elementAt ( i ) . col == col ) { vec . elementAt ( i ) . inc = vec . elementAt ( i ) . inc + incr ; } else { vec . insertElementAt ( new MappingPair ( col , incr ) , i ) ; } }
private static void adjustMappingPairVector ( int col , int incr , Vector < MappingPair > vec ) { int i ; for ( i = _NUM ; ( i < vec . size ( ) ) && ( vec . elementAt ( i ) . col < col ) ; i ++ ) { } if ( i == vec . size ( ) ) { vec . add ( new MappingPair ( col , incr ) ) ; } else if ( vec . elementAt ( i ) . col == col ) { vec . elementAt ( i ) . inc = vec . elementAt ( i ) . inc + incr ; } else { vec . insertElementAt ( new MappingPair ( col , incr ) , i ) ; } }
private static void adjustMappingPairVector ( int col , int incr , Vector < MappingPair > vec ) { int i ; for ( i = _NUM ; ( i < vec . size ( ) ) && ( vec . elementAt ( i ) . col < col ) ; i ++ ) { } if ( i == vec . size ( ) ) { vec . add ( new MappingPair ( col , incr ) ) ; } else if ( vec . elementAt ( i ) . col == col ) { vec . elementAt ( i ) . inc = vec . elementAt ( i ) . inc + incr ; } else { vec . insertElementAt ( new MappingPair ( col , incr ) , i ) ; } }
@ Override public Invocation . Builder accept ( String ... mediaTypes ) { clientRequestContext . setAcceptResponseTypesStr ( Arrays . asList ( mediaTypes ) ) ; return this ; }
@ Override public Invocation . Builder accept ( String ... mediaTypes ) { clientRequestContext . setAcceptResponseTypesStr ( Arrays . asList ( mediaTypes ) ) ; return this ; }
public static String quantityplnoun ( final int quantity , final String noun , final String one ) { final String word = plnoun ( quantity , noun ) ; if ( quantity == _NUM ) { if ( one . equals ( STRING ) ) { return a_noun ( word ) ; } else if ( one . equals ( STRING ) ) { return A_noun ( word ) ; } else if ( one . equals ( STRING ) ) { return word ; } else { return one + STRING + word ; } } else { return Integer . toString ( quantity ) + STRING + plural ( noun ) ; } }
public static String quantityplnoun ( final int quantity , final String noun , final String one ) { final String word = plnoun ( quantity , noun ) ; if ( quantity == _NUM ) { if ( one . equals ( STRING ) ) { return a_noun ( word ) ; } else if ( one . equals ( STRING ) ) { return A_noun ( word ) ; } else if ( one . equals ( STRING ) ) { return word ; } else { return one + STRING + word ; } } else { return Integer . toString ( quantity ) + STRING + plural ( noun ) ; } }
public static String quantityplnoun ( final int quantity , final String noun , final String one ) { final String word = plnoun ( quantity , noun ) ; if ( quantity == _NUM ) { if ( one . equals ( STRING ) ) { return a_noun ( word ) ; } else if ( one . equals ( STRING ) ) { return A_noun ( word ) ; } else if ( one . equals ( STRING ) ) { return word ; } else { return one + STRING + word ; } } else { return Integer . toString ( quantity ) + STRING + plural ( noun ) ; } }
public void invalidateLayout ( Container parent ) { checkParent ( parent ) ; synchronized ( parent . getTreeLock ( ) ) { isValid = _BOOL ; } }
public void invalidateLayout ( Container parent ) { checkParent ( parent ) ; synchronized ( parent . getTreeLock ( ) ) { isValid = _BOOL ; } }
public void invalidateLayout ( Container parent ) { checkParent ( parent ) ; synchronized ( parent . getTreeLock ( ) ) { isValid = _BOOL ; } }
public void invalidateLayout ( Container parent ) { checkParent ( parent ) ; synchronized ( parent . getTreeLock ( ) ) { isValid = _BOOL ; } }
public double linearDistance ( Location location ) { if ( location == null ) { throw new IllegalArgumentException ( Logger . logMessage ( Logger . ERROR , STRING , STRING , STRING ) ) ; } double lat1 = Math . toRadians ( this . latitude ) ; double lon1 = Math . toRadians ( this . longitude ) ; double lat2 = Math . toRadians ( location . latitude ) ; double lon2 = Math . toRadians ( location . longitude ) ; if ( lat1 == lat2 && lon1 == lon2 ) { return _NUM ; } double dLat = lat2 - lat1 ; double dLon = lon2 - lon1 ; if ( Math . abs ( dLon ) > Math . PI ) { dLon = dLon > _NUM ? - ( _NUM * Math . PI - dLon ) : ( _NUM * Math . PI + dLon ) ; } double distanceRadians = Math . sqrt ( dLat * dLat + dLon * dLon ) ; return Double . isNaN ( distanceRadians ) ? _NUM : distanceRadians ; }
public double linearDistance ( Location location ) { if ( location == null ) { throw new IllegalArgumentException ( Logger . logMessage ( Logger . ERROR , STRING , STRING , STRING ) ) ; } double lat1 = Math . toRadians ( this . latitude ) ; double lon1 = Math . toRadians ( this . longitude ) ; double lat2 = Math . toRadians ( location . latitude ) ; double lon2 = Math . toRadians ( location . longitude ) ; if ( lat1 == lat2 && lon1 == lon2 ) { return _NUM ; } double dLat = lat2 - lat1 ; double dLon = lon2 - lon1 ; if ( Math . abs ( dLon ) > Math . PI ) { dLon = dLon > _NUM ? - ( _NUM * Math . PI - dLon ) : ( _NUM * Math . PI + dLon ) ; } double distanceRadians = Math . sqrt ( dLat * dLat + dLon * dLon ) ; return Double . isNaN ( distanceRadians ) ? _NUM : distanceRadians ; }
public double linearDistance ( Location location ) { if ( location == null ) { throw new IllegalArgumentException ( Logger . logMessage ( Logger . ERROR , STRING , STRING , STRING ) ) ; } double lat1 = Math . toRadians ( this . latitude ) ; double lon1 = Math . toRadians ( this . longitude ) ; double lat2 = Math . toRadians ( location . latitude ) ; double lon2 = Math . toRadians ( location . longitude ) ; if ( lat1 == lat2 && lon1 == lon2 ) { return _NUM ; } double dLat = lat2 - lat1 ; double dLon = lon2 - lon1 ; if ( Math . abs ( dLon ) > Math . PI ) { dLon = dLon > _NUM ? - ( _NUM * Math . PI - dLon ) : ( _NUM * Math . PI + dLon ) ; } double distanceRadians = Math . sqrt ( dLat * dLat + dLon * dLon ) ; return Double . isNaN ( distanceRadians ) ? _NUM : distanceRadians ; }
private Record parseResponse ( String response ) throws StageException { Record record = null ; try ( DataParser parser = parserFactory . getParser ( STRING , response ) ) { record = parser . parse ( ) ; if ( conf . dataFormat == DataFormat . TEXT ) { record . set ( record . get ( STRING ) ) ; } } catch ( IOException | DataParserException e ) { errorRecordHandler . onError ( Errors . HTTP_00 , e . toString ( ) , e ) ; } return record ; }
private Record parseResponse ( String response ) throws StageException { Record record = null ; try ( DataParser parser = parserFactory . getParser ( STRING , response ) ) { record = parser . parse ( ) ; if ( conf . dataFormat == DataFormat . TEXT ) { record . set ( record . get ( STRING ) ) ; } } catch ( IOException | DataParserException e ) { errorRecordHandler . onError ( Errors . HTTP_00 , e . toString ( ) , e ) ; } return record ; }
public final boolean contains ( V value ) { if ( GWT . isScript ( ) ) { return jsArray . indexOf ( value ) != - _NUM ; } else { return javaArray . contains ( value ) ; } }
public final boolean contains ( V value ) { if ( GWT . isScript ( ) ) { return jsArray . indexOf ( value ) != - _NUM ; } else { return javaArray . contains ( value ) ; } }
public int Compare ( final String str ) { return ObjectName . compareTo ( str ) ; }
public static URL findResourceBase ( String baseResource , ClassLoader loader ) { URL url = loader . getResource ( baseResource ) ; return findResourceBase ( url , baseResource ) ; }
public static String iterableToCommaSeparatedList ( Iterable < ? > iterable ) { StringBuilder builder = new StringBuilder ( ) ; boolean first = _BOOL ; for ( Object obj : iterable ) { if ( first ) { builder . append ( String . format ( STRING , obj . toString ( ) ) ) ; first = _BOOL ; } else { builder . append ( String . format ( STRING , obj . toString ( ) ) ) ; } } return builder . toString ( ) ; }
public boolean checkReference ( SequencesReader sr , Map < String , Long > sequenceNameMap ) throws IOException { for ( CheckValues cv : mValues ) { if ( ! sequenceNameMap . containsKey ( cv . getSequenceName ( ) ) ) { return _BOOL ; } final long sequenceId = sequenceNameMap . get ( cv . getSequenceName ( ) ) ; for ( int i = _NUM ; i < mChecks . size ( ) ; i ++ ) { final CheckType check = mChecks . get ( i ) ; if ( ! check . checkValue ( sr , sequenceId , cv . getValue ( i ) ) ) { return _BOOL ; } } } return _BOOL ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case _NUM : return TRUE_AS_OF_SECS ; case _NUM : return SOURCE ; case _NUM : return SYSTEM ; default : return null ; } }
public String findToken ( ) { Matcher m ; Pattern p ; switch ( super . getParamName ( ) ) { case REQUEST : p = Pattern . compile ( STRING ) ; break ; case RESPONSE : p = Pattern . compile ( STRING ) ; break ; case ARTIFACT : p = Pattern . compile ( STRING ) ; break ; default : return STRING ; } if ( super . getParsedContent ( ) != null ) { m = p . matcher ( super . getParsedContent ( ) ) ; if ( m . find ( ) ) { return m . group ( _NUM ) ; } } return STRING ; }
protected int makePressColor ( ) { int r = ( this . backgroundColor > > _NUM ) & _NUM ; int g = ( this . backgroundColor > > _NUM ) & _NUM ; int b = ( this . backgroundColor > > _NUM ) & _NUM ; r = ( r - _NUM < _NUM ) ? _NUM : r - _NUM ; g = ( g - _NUM < _NUM ) ? _NUM : g - _NUM ; b = ( b - _NUM < _NUM ) ? _NUM : b - _NUM ; return Color . rgb ( r , g , b ) ; }
public COpenFunctionAction ( final CGraphWindow parent , final IViewContainer container , final INaviFunction function ) { super ( String . format ( STRING , function . getName ( ) ) ) ; Preconditions . checkNotNull ( parent , STRING ) ; Preconditions . checkNotNull ( container , STRING ) ; m_parent = parent ; m_container = container ; m_function = function ; }
private int findCheckpointPosition ( int [ ] cids ) { if ( checkpointPeriod < _NUM ) { return - _NUM ; } if ( cids . length == _NUM ) { throw new IllegalArgumentException ( ) ; } int firstCID = cids [ _NUM ] ; if ( ( firstCID + _NUM ) % checkpointPeriod == _NUM ) { return cidPosition ( cids , firstCID ) ; } else { int nextCkpIndex = ( ( ( firstCID / checkpointPeriod ) + _NUM ) * checkpointPeriod ) - _NUM ; if ( nextCkpIndex <= cids [ cids . length - _NUM ] ) { return cidPosition ( cids , nextCkpIndex ) ; } } return - _NUM ; }
private int findCheckpointPosition ( int [ ] cids ) { if ( checkpointPeriod < _NUM ) { return - _NUM ; } if ( cids . length == _NUM ) { throw new IllegalArgumentException ( ) ; } int firstCID = cids [ _NUM ] ; if ( ( firstCID + _NUM ) % checkpointPeriod == _NUM ) { return cidPosition ( cids , firstCID ) ; } else { int nextCkpIndex = ( ( ( firstCID / checkpointPeriod ) + _NUM ) * checkpointPeriod ) - _NUM ; if ( nextCkpIndex <= cids [ cids . length - _NUM ] ) { return cidPosition ( cids , nextCkpIndex ) ; } } return - _NUM ; }
private int findCheckpointPosition ( int [ ] cids ) { if ( checkpointPeriod < _NUM ) { return - _NUM ; } if ( cids . length == _NUM ) { throw new IllegalArgumentException ( ) ; } int firstCID = cids [ _NUM ] ; if ( ( firstCID + _NUM ) % checkpointPeriod == _NUM ) { return cidPosition ( cids , firstCID ) ; } else { int nextCkpIndex = ( ( ( firstCID / checkpointPeriod ) + _NUM ) * checkpointPeriod ) - _NUM ; if ( nextCkpIndex <= cids [ cids . length - _NUM ] ) { return cidPosition ( cids , nextCkpIndex ) ; } } return - _NUM ; }
private int findCheckpointPosition ( int [ ] cids ) { if ( checkpointPeriod < _NUM ) { return - _NUM ; } if ( cids . length == _NUM ) { throw new IllegalArgumentException ( ) ; } int firstCID = cids [ _NUM ] ; if ( ( firstCID + _NUM ) % checkpointPeriod == _NUM ) { return cidPosition ( cids , firstCID ) ; } else { int nextCkpIndex = ( ( ( firstCID / checkpointPeriod ) + _NUM ) * checkpointPeriod ) - _NUM ; if ( nextCkpIndex <= cids [ cids . length - _NUM ] ) { return cidPosition ( cids , nextCkpIndex ) ; } } return - _NUM ; }
private int findCheckpointPosition ( int [ ] cids ) { if ( checkpointPeriod < _NUM ) { return - _NUM ; } if ( cids . length == _NUM ) { throw new IllegalArgumentException ( ) ; } int firstCID = cids [ _NUM ] ; if ( ( firstCID + _NUM ) % checkpointPeriod == _NUM ) { return cidPosition ( cids , firstCID ) ; } else { int nextCkpIndex = ( ( ( firstCID / checkpointPeriod ) + _NUM ) * checkpointPeriod ) - _NUM ; if ( nextCkpIndex <= cids [ cids . length - _NUM ] ) { return cidPosition ( cids , nextCkpIndex ) ; } } return - _NUM ; }
private int findCheckpointPosition ( int [ ] cids ) { if ( checkpointPeriod < _NUM ) { return - _NUM ; } if ( cids . length == _NUM ) { throw new IllegalArgumentException ( ) ; } int firstCID = cids [ _NUM ] ; if ( ( firstCID + _NUM ) % checkpointPeriod == _NUM ) { return cidPosition ( cids , firstCID ) ; } else { int nextCkpIndex = ( ( ( firstCID / checkpointPeriod ) + _NUM ) * checkpointPeriod ) - _NUM ; if ( nextCkpIndex <= cids [ cids . length - _NUM ] ) { return cidPosition ( cids , nextCkpIndex ) ; } } return - _NUM ; }
private int findCheckpointPosition ( int [ ] cids ) { if ( checkpointPeriod < _NUM ) { return - _NUM ; } if ( cids . length == _NUM ) { throw new IllegalArgumentException ( ) ; } int firstCID = cids [ _NUM ] ; if ( ( firstCID + _NUM ) % checkpointPeriod == _NUM ) { return cidPosition ( cids , firstCID ) ; } else { int nextCkpIndex = ( ( ( firstCID / checkpointPeriod ) + _NUM ) * checkpointPeriod ) - _NUM ; if ( nextCkpIndex <= cids [ cids . length - _NUM ] ) { return cidPosition ( cids , nextCkpIndex ) ; } } return - _NUM ; }
private int findCheckpointPosition ( int [ ] cids ) { if ( checkpointPeriod < _NUM ) { return - _NUM ; } if ( cids . length == _NUM ) { throw new IllegalArgumentException ( ) ; } int firstCID = cids [ _NUM ] ; if ( ( firstCID + _NUM ) % checkpointPeriod == _NUM ) { return cidPosition ( cids , firstCID ) ; } else { int nextCkpIndex = ( ( ( firstCID / checkpointPeriod ) + _NUM ) * checkpointPeriod ) - _NUM ; if ( nextCkpIndex <= cids [ cids . length - _NUM ] ) { return cidPosition ( cids , nextCkpIndex ) ; } } return - _NUM ; }
private int findCheckpointPosition ( int [ ] cids ) { if ( checkpointPeriod < _NUM ) { return - _NUM ; } if ( cids . length == _NUM ) { throw new IllegalArgumentException ( ) ; } int firstCID = cids [ _NUM ] ; if ( ( firstCID + _NUM ) % checkpointPeriod == _NUM ) { return cidPosition ( cids , firstCID ) ; } else { int nextCkpIndex = ( ( ( firstCID / checkpointPeriod ) + _NUM ) * checkpointPeriod ) - _NUM ; if ( nextCkpIndex <= cids [ cids . length - _NUM ] ) { return cidPosition ( cids , nextCkpIndex ) ; } } return - _NUM ; }
private int findCheckpointPosition ( int [ ] cids ) { if ( checkpointPeriod < _NUM ) { return - _NUM ; } if ( cids . length == _NUM ) { throw new IllegalArgumentException ( ) ; } int firstCID = cids [ _NUM ] ; if ( ( firstCID + _NUM ) % checkpointPeriod == _NUM ) { return cidPosition ( cids , firstCID ) ; } else { int nextCkpIndex = ( ( ( firstCID / checkpointPeriod ) + _NUM ) * checkpointPeriod ) - _NUM ; if ( nextCkpIndex <= cids [ cids . length - _NUM ] ) { return cidPosition ( cids , nextCkpIndex ) ; } } return - _NUM ; }
public static void expand ( Rectangle2D r , double amount ) { r . setRect ( r . getX ( ) - amount , r . getY ( ) - amount , r . getWidth ( ) + _NUM * amount , r . getHeight ( ) + _NUM * amount ) ; }
public static void expand ( Rectangle2D r , double amount ) { r . setRect ( r . getX ( ) - amount , r . getY ( ) - amount , r . getWidth ( ) + _NUM * amount , r . getHeight ( ) + _NUM * amount ) ; }
@ Override public MovePath clone ( ) { final MovePath copy = new MovePath ( getGame ( ) , getEntity ( ) ) ; copy . steps = new Vector < MoveStep > ( steps ) ; copy . careful = careful ; return copy ; }
@ Override public MovePath clone ( ) { final MovePath copy = new MovePath ( getGame ( ) , getEntity ( ) ) ; copy . steps = new Vector < MoveStep > ( steps ) ; copy . careful = careful ; return copy ; }
public final void addRequiredImports ( Set < DeclaredTypeName > imports ) { imports . add ( TypeConstants . PROPERTY ) ; imports . add ( TypeConstants . VALUES_STORAGE ) ; imports . add ( getModelSuperclass ( ) ) ; for ( PropertyGenerator generator : propertyGenerators ) { generator . registerRequiredImports ( imports ) ; } addModelSpecificImports ( imports ) ; pluginBundle . addRequiredImports ( imports ) ; }
private void readObject ( ObjectInputStream oos ) throws IOException , ClassNotFoundException { iInstant = ( LocalDate ) oos . readObject ( ) ; DateTimeFieldType type = ( DateTimeFieldType ) oos . readObject ( ) ; iField = type . getField ( iInstant . getChronology ( ) ) ; }
private void readObject ( ObjectInputStream oos ) throws IOException , ClassNotFoundException { iInstant = ( LocalDate ) oos . readObject ( ) ; DateTimeFieldType type = ( DateTimeFieldType ) oos . readObject ( ) ; iField = type . getField ( iInstant . getChronology ( ) ) ; }
protected void addToBottomBox ( Component comp ) { bottomBox . add ( Box . createHorizontalStrut ( bottomStrutWidth ) , bottomBoxIndex ) ; ++ bottomBoxIndex ; bottomBox . add ( comp , bottomBoxIndex ) ; ++ bottomBoxIndex ; }
protected void addToBottomBox ( Component comp ) { bottomBox . add ( Box . createHorizontalStrut ( bottomStrutWidth ) , bottomBoxIndex ) ; ++ bottomBoxIndex ; bottomBox . add ( comp , bottomBoxIndex ) ; ++ bottomBoxIndex ; }
public void testRangeShardMappingKeyLookup ( ) throws Exception { final String globalGroupName = STRING ; final int lowerBounds [ ] = new int [ ] { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; final int lowestLowerBound = _NUM ; Set < ShardIndex > shardIndices = new HashSet < ShardIndex > ( ) ; int shardId = _NUM ; for ( Integer lowerBound : lowerBounds ) { ShardIndex i = new ShardIndex ( String . valueOf ( lowerBound ) , shardId , STRING + shardId ) ; shardId ++ ; shardIndices . add ( i ) ; } ShardMapping mapping = new RangeShardMapping ( _NUM , ShardingType . RANGE , globalGroupName , null , shardIndices ) ; try { mapping . getGroupNameForKey ( String . valueOf ( lowestLowerBound - _NUM ) ) ; fail ( STRING ) ; } catch ( Exception ex ) { } try { mapping . getGroupNameForKey ( String . valueOf ( lowestLowerBound - _NUM ) ) ; fail ( STRING ) ; } catch ( Exception ex ) { } for ( shardId = _NUM ; shardId < lowerBounds . length ; ++ shardId ) { int lowerBound = lowerBounds [ shardId ] ; String groupName = mapping . getGroupNameForKey ( String . valueOf ( lowerBound ) ) ; assertEquals ( STRING + lowerBound , STRING + shardId , groupName ) ; } }
public void testRangeShardMappingKeyLookup ( ) throws Exception { final String globalGroupName = STRING ; final int lowerBounds [ ] = new int [ ] { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; final int lowestLowerBound = _NUM ; Set < ShardIndex > shardIndices = new HashSet < ShardIndex > ( ) ; int shardId = _NUM ; for ( Integer lowerBound : lowerBounds ) { ShardIndex i = new ShardIndex ( String . valueOf ( lowerBound ) , shardId , STRING + shardId ) ; shardId ++ ; shardIndices . add ( i ) ; } ShardMapping mapping = new RangeShardMapping ( _NUM , ShardingType . RANGE , globalGroupName , null , shardIndices ) ; try { mapping . getGroupNameForKey ( String . valueOf ( lowestLowerBound - _NUM ) ) ; fail ( STRING ) ; } catch ( Exception ex ) { } try { mapping . getGroupNameForKey ( String . valueOf ( lowestLowerBound - _NUM ) ) ; fail ( STRING ) ; } catch ( Exception ex ) { } for ( shardId = _NUM ; shardId < lowerBounds . length ; ++ shardId ) { int lowerBound = lowerBounds [ shardId ] ; String groupName = mapping . getGroupNameForKey ( String . valueOf ( lowerBound ) ) ; assertEquals ( STRING + lowerBound , STRING + shardId , groupName ) ; } }
public void testRangeShardMappingKeyLookup ( ) throws Exception { final String globalGroupName = STRING ; final int lowerBounds [ ] = new int [ ] { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; final int lowestLowerBound = _NUM ; Set < ShardIndex > shardIndices = new HashSet < ShardIndex > ( ) ; int shardId = _NUM ; for ( Integer lowerBound : lowerBounds ) { ShardIndex i = new ShardIndex ( String . valueOf ( lowerBound ) , shardId , STRING + shardId ) ; shardId ++ ; shardIndices . add ( i ) ; } ShardMapping mapping = new RangeShardMapping ( _NUM , ShardingType . RANGE , globalGroupName , null , shardIndices ) ; try { mapping . getGroupNameForKey ( String . valueOf ( lowestLowerBound - _NUM ) ) ; fail ( STRING ) ; } catch ( Exception ex ) { } try { mapping . getGroupNameForKey ( String . valueOf ( lowestLowerBound - _NUM ) ) ; fail ( STRING ) ; } catch ( Exception ex ) { } for ( shardId = _NUM ; shardId < lowerBounds . length ; ++ shardId ) { int lowerBound = lowerBounds [ shardId ] ; String groupName = mapping . getGroupNameForKey ( String . valueOf ( lowerBound ) ) ; assertEquals ( STRING + lowerBound , STRING + shardId , groupName ) ; } }
public static String [ ] splitCSV ( String str , String delim ) { if ( str == null || str . isEmpty ( ) ) return new String [ ] { STRING } ; ArrayList < String > tokens = new ArrayList < String > ( ) ; int from = _NUM , to = _NUM ; int len = str . length ( ) ; while ( from < len ) { if ( str . charAt ( from ) == CSV_QUOTE_CHAR && str . indexOf ( CSV_QUOTE_CHAR , from + _NUM ) > _NUM ) { to = str . indexOf ( CSV_QUOTE_CHAR , from + _NUM ) ; while ( to + _NUM < len && str . charAt ( to + _NUM ) == CSV_QUOTE_CHAR ) to = str . indexOf ( CSV_QUOTE_CHAR , to + _NUM ) ; to += _NUM ; } else if ( str . regionMatches ( from , delim , _NUM , delim . length ( ) ) ) { to = from ; } else { to = str . indexOf ( delim , from + _NUM ) ; } to = ( to >= _NUM ) ? to : len ; tokens . add ( str . substring ( from , to ) ) ; from = to + delim . length ( ) ; } if ( from == len ) tokens . add ( STRING ) ; return tokens . toArray ( new String [ _NUM ] ) ; }
public static String [ ] splitCSV ( String str , String delim ) { if ( str == null || str . isEmpty ( ) ) return new String [ ] { STRING } ; ArrayList < String > tokens = new ArrayList < String > ( ) ; int from = _NUM , to = _NUM ; int len = str . length ( ) ; while ( from < len ) { if ( str . charAt ( from ) == CSV_QUOTE_CHAR && str . indexOf ( CSV_QUOTE_CHAR , from + _NUM ) > _NUM ) { to = str . indexOf ( CSV_QUOTE_CHAR , from + _NUM ) ; while ( to + _NUM < len && str . charAt ( to + _NUM ) == CSV_QUOTE_CHAR ) to = str . indexOf ( CSV_QUOTE_CHAR , to + _NUM ) ; to += _NUM ; } else if ( str . regionMatches ( from , delim , _NUM , delim . length ( ) ) ) { to = from ; } else { to = str . indexOf ( delim , from + _NUM ) ; } to = ( to >= _NUM ) ? to : len ; tokens . add ( str . substring ( from , to ) ) ; from = to + delim . length ( ) ; } if ( from == len ) tokens . add ( STRING ) ; return tokens . toArray ( new String [ _NUM ] ) ; }
public void deleteAuthConfiguration ( String realm , Set names ) throws AMConsoleException { StringBuilder errorList = new StringBuilder ( ) ; String message = null ; for ( Iterator i = names . iterator ( ) ; i . hasNext ( ) ; ) { String config = ( String ) i . next ( ) ; message = null ; try { AMAuthConfigUtils . removeNamedConfig ( config , realm , getUserSSOToken ( ) ) ; } catch ( AMConfigurationException e ) { debug . warning ( STRING , e ) ; message = e . getMessage ( ) ; errorList . append ( config ) ; } catch ( SMSException e ) { debug . warning ( STRING , e ) ; message = e . getMessage ( ) ; errorList . append ( config ) ; } catch ( SSOException e ) { debug . warning ( STRING , e ) ; message = e . getMessage ( ) ; errorList . append ( config ) ; } if ( message != null ) { if ( errorList . length ( ) > _NUM ) { errorList . append ( STRING ) ; } } } if ( errorList . length ( ) > _NUM ) { String [ ] tmp = { errorList . toString ( ) , message } ; throw new AMConsoleException ( MessageFormat . format ( getLocalizedString ( STRING ) , ( Object [ ] ) tmp ) ) ; } }
protected TextAnchor calculateTextAnchor ( double angleDegrees ) { TextAnchor ta = TextAnchor . CENTER ; double offset = this . angleOffset ; while ( offset < _NUM ) { offset += _NUM ; } double normalizedAngle = ( ( ( this . counterClockwise ? - _NUM : _NUM ) * angleDegrees ) + offset ) % _NUM ; while ( this . counterClockwise && ( normalizedAngle < _NUM ) ) { normalizedAngle += _NUM ; } if ( normalizedAngle == _NUM ) { ta = TextAnchor . CENTER_LEFT ; } else if ( normalizedAngle > _NUM && normalizedAngle < _NUM ) { ta = TextAnchor . TOP_LEFT ; } else if ( normalizedAngle == _NUM ) { ta = TextAnchor . TOP_CENTER ; } else if ( normalizedAngle > _NUM && normalizedAngle < _NUM ) { ta = TextAnchor . TOP_RIGHT ; } else if ( normalizedAngle == _NUM ) { ta = TextAnchor . CENTER_RIGHT ; } else if ( normalizedAngle > _NUM && normalizedAngle < _NUM ) { ta = TextAnchor . BOTTOM_RIGHT ; } else if ( normalizedAngle == _NUM ) { ta = TextAnchor . BOTTOM_CENTER ; } else if ( normalizedAngle > _NUM && normalizedAngle < _NUM ) { ta = TextAnchor . BOTTOM_LEFT ; } return ta ; }
@ Override public int compare ( PhysicalTable left , PhysicalTable right ) { long leftVolatileDataDuration = getAvailableVolatileDataDuration ( left ) ; long rightVolatileDataDuration = getAvailableVolatileDataDuration ( right ) ; long mostCompleteVolatile = rightVolatileDataDuration - leftVolatileDataDuration ; return ( int ) Math . max ( Math . min ( Integer . MAX_VALUE , mostCompleteVolatile ) , Integer . MIN_VALUE ) ; }
@ Override public int compare ( PhysicalTable left , PhysicalTable right ) { long leftVolatileDataDuration = getAvailableVolatileDataDuration ( left ) ; long rightVolatileDataDuration = getAvailableVolatileDataDuration ( right ) ; long mostCompleteVolatile = rightVolatileDataDuration - leftVolatileDataDuration ; return ( int ) Math . max ( Math . min ( Integer . MAX_VALUE , mostCompleteVolatile ) , Integer . MIN_VALUE ) ; }
private JsonNode parseLanguageResource ( Resource resource ) throws IOException { InputStream stream = resource . asStream ( ) ; if ( stream == null ) return null ; try { JsonNode tree = mapper . readTree ( stream ) ; return tree ; } finally { stream . close ( ) ; } }
private JsonNode parseLanguageResource ( Resource resource ) throws IOException { InputStream stream = resource . asStream ( ) ; if ( stream == null ) return null ; try { JsonNode tree = mapper . readTree ( stream ) ; return tree ; } finally { stream . close ( ) ; } }
private JsonNode parseLanguageResource ( Resource resource ) throws IOException { InputStream stream = resource . asStream ( ) ; if ( stream == null ) return null ; try { JsonNode tree = mapper . readTree ( stream ) ; return tree ; } finally { stream . close ( ) ; } }
public final boolean isCommandBuilderUseful ( ) { return isCommandBuilderUseful ; }
public final boolean isCommandBuilderUseful ( ) { return isCommandBuilderUseful ; }
public final boolean isCommandBuilderUseful ( ) { return isCommandBuilderUseful ; }
public final boolean isCommandBuilderUseful ( ) { return isCommandBuilderUseful ; }
public final boolean isCommandBuilderUseful ( ) { return isCommandBuilderUseful ; }
public final boolean isCommandBuilderUseful ( ) { return isCommandBuilderUseful ; }
private static int encodeValueNum ( int valueNum , boolean isObjectKind ) { assert valueNum > _NUM ; if ( isObjectKind ) { return - valueNum ; } return valueNum ; }
public CTagTreeNodeMenuBuilder ( final JFrame parent , final ZyGraph graph , final ITagManager tagManager , final ITreeNode < CTag > tag ) { m_popupMenu = new JPopupMenu ( ) ; m_popupMenu . add ( CActionProxy . proxy ( new CAddTagToSelectedNodesAction ( parent , graph , tag ) ) ) ; m_popupMenu . add ( new JSeparator ( ) ) ; m_popupMenu . add ( CActionProxy . proxy ( new CRemoveTagFromSelectedNodesAction ( parent , graph , tag ) ) ) ; m_popupMenu . add ( CActionProxy . proxy ( new CRemoveTagFromAllNodesAction ( parent , graph , tag . getObject ( ) ) ) ) ; m_popupMenu . add ( new JSeparator ( ) ) ; m_popupMenu . add ( CActionProxy . proxy ( new CAppendTagAction ( parent , tagManager , tag ) ) ) ; m_popupMenu . add ( CActionProxy . proxy ( new CInsertTagAction ( parent , tagManager , tag ) ) ) ; m_popupMenu . add ( new JSeparator ( ) ) ; m_popupMenu . add ( CActionProxy . proxy ( new CEditTagAction ( parent , tag . getObject ( ) ) ) ) ; m_popupMenu . add ( new JSeparator ( ) ) ; m_popupMenu . add ( CActionProxy . proxy ( new CDeleteTagAction ( parent , tagManager , tag ) ) ) ; m_popupMenu . add ( CActionProxy . proxy ( new CDeleteTagSubtreeAction ( parent , tagManager , tag ) ) ) ; }
protected boolean isIDPProxyEnabled ( FSAuthnRequest authnRequest ) throws FSException { if ( authnRequest . getMinorVersion ( ) != IFSConstants . FF_12_PROTOCOL_MINOR_VERSION ) { return _BOOL ; } FSScoping scoping = authnRequest . getScoping ( ) ; if ( scoping != null && scoping . getProxyCount ( ) == _NUM ) { return _BOOL ; } String enabledString = IDFFMetaUtils . getFirstAttributeValueFromConfig ( spConfig , IFSConstants . ENABLE_IDP_PROXY ) ; if ( enabledString != null && enabledString . equalsIgnoreCase ( STRING ) ) { return _BOOL ; } else { return _BOOL ; } }
protected boolean isIDPProxyEnabled ( FSAuthnRequest authnRequest ) throws FSException { if ( authnRequest . getMinorVersion ( ) != IFSConstants . FF_12_PROTOCOL_MINOR_VERSION ) { return _BOOL ; } FSScoping scoping = authnRequest . getScoping ( ) ; if ( scoping != null && scoping . getProxyCount ( ) == _NUM ) { return _BOOL ; } String enabledString = IDFFMetaUtils . getFirstAttributeValueFromConfig ( spConfig , IFSConstants . ENABLE_IDP_PROXY ) ; if ( enabledString != null && enabledString . equalsIgnoreCase ( STRING ) ) { return _BOOL ; } else { return _BOOL ; } }
public void addRequestHeader ( String key , String value ) { if ( userHeaders == null ) { userHeaders = new Hashtable ( ) ; } if ( key . equalsIgnoreCase ( STRING ) ) { setContentType ( value ) ; } else { userHeaders . put ( key , value ) ; } }
public static boolean anyDimensionHasItems ( Collection < DimensionalObject > dimensions ) { if ( dimensions == null || dimensions . isEmpty ( ) ) { return _BOOL ; } for ( DimensionalObject dim : dimensions ) { if ( dim . hasItems ( ) ) { return _BOOL ; } } return _BOOL ; }
public static boolean anyDimensionHasItems ( Collection < DimensionalObject > dimensions ) { if ( dimensions == null || dimensions . isEmpty ( ) ) { return _BOOL ; } for ( DimensionalObject dim : dimensions ) { if ( dim . hasItems ( ) ) { return _BOOL ; } } return _BOOL ; }
public static boolean anyDimensionHasItems ( Collection < DimensionalObject > dimensions ) { if ( dimensions == null || dimensions . isEmpty ( ) ) { return _BOOL ; } for ( DimensionalObject dim : dimensions ) { if ( dim . hasItems ( ) ) { return _BOOL ; } } return _BOOL ; }
public int read ( String table , String key , Set < String > fields , HashMap < String , ByteIterator > result ) { long st = System . nanoTime ( ) ; int res = _db . read ( table , key , fields , result ) ; long en = System . nanoTime ( ) ; _measurements . measure ( STRING , ( int ) ( ( en - st ) / _NUM ) ) ; _measurements . reportReturnCode ( STRING , res ) ; return res ; }
public int read ( String table , String key , Set < String > fields , HashMap < String , ByteIterator > result ) { long st = System . nanoTime ( ) ; int res = _db . read ( table , key , fields , result ) ; long en = System . nanoTime ( ) ; _measurements . measure ( STRING , ( int ) ( ( en - st ) / _NUM ) ) ; _measurements . reportReturnCode ( STRING , res ) ; return res ; }
public int read ( String table , String key , Set < String > fields , HashMap < String , ByteIterator > result ) { long st = System . nanoTime ( ) ; int res = _db . read ( table , key , fields , result ) ; long en = System . nanoTime ( ) ; _measurements . measure ( STRING , ( int ) ( ( en - st ) / _NUM ) ) ; _measurements . reportReturnCode ( STRING , res ) ; return res ; }
public Filter addAttribute ( String attribute , Object entity ) { put ( attribute , entity ) ; return ( this ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
public static Alert findByNameAndOwner ( EntityManager em , String alertName , PrincipalUser owner ) { requireArgument ( em != null , STRING ) ; requireArgument ( alertName != null && ! alertName . isEmpty ( ) , STRING ) ; requireArgument ( owner != null , STRING ) ; TypedQuery < Alert > query = em . createNamedQuery ( STRING , Alert . class ) ; query . setHint ( STRING , STRING ) ; try { query . setParameter ( STRING , alertName ) ; query . setParameter ( STRING , owner ) ; return query . getSingleResult ( ) ; } catch ( NoResultException ex ) { return null ; } }
public static Alert findByNameAndOwner ( EntityManager em , String alertName , PrincipalUser owner ) { requireArgument ( em != null , STRING ) ; requireArgument ( alertName != null && ! alertName . isEmpty ( ) , STRING ) ; requireArgument ( owner != null , STRING ) ; TypedQuery < Alert > query = em . createNamedQuery ( STRING , Alert . class ) ; query . setHint ( STRING , STRING ) ; try { query . setParameter ( STRING , alertName ) ; query . setParameter ( STRING , owner ) ; return query . getSingleResult ( ) ; } catch ( NoResultException ex ) { return null ; } }
private void enterLinkedModeForPrefix ( IDocument document , ITextViewer viewer , IDOMElement rootElement , String prefix ) throws BadLocationException { int linkedPosSequence = _NUM ; LinkedPosition pos1 = new LinkedPosition ( document , startPosition , prefix . length ( ) , linkedPosSequence ++ ) ; LinkedPosition pos2 = new LinkedPosition ( document , cursorPosition + _NUM , prefix . length ( ) , linkedPosSequence ++ ) ; IDOMElement rootDomElement = ( IDOMElement ) rootElement ; final String xmlnsPrefix = STRING ; String fullPrefixName = xmlnsPrefix + prefix ; IDOMAttr domAttribute = ( IDOMAttr ) rootDomElement . getAttributeNode ( fullPrefixName ) ; LinkedPosition pos3 = new LinkedPosition ( document , domAttribute . getStartOffset ( ) + xmlnsPrefix . length ( ) , prefix . length ( ) , linkedPosSequence ++ ) ; LinkedPositionGroup group = new LinkedPositionGroup ( ) ; group . addPosition ( pos1 ) ; group . addPosition ( pos2 ) ; group . addPosition ( pos3 ) ; LinkedModeModel model = new LinkedModeModel ( ) ; model . addGroup ( group ) ; model . forceInstall ( ) ; LinkedModeUI ui = new LinkedModeUI ( model , viewer ) ; ui . enter ( ) ; wasLinkedModeEntered = _BOOL ; }
public void writeHeaderPart ( AnnotatedOutput out ) { throwIfNotPrepared ( ) ; if ( writeSize == - _NUM ) { throw new RuntimeException ( STRING ) ; } int sz = writeSize ; int offset = ( sz == _NUM ) ? _NUM : getFileOffset ( ) ; String name = getName ( ) ; if ( name == null ) { name = STRING ; } int spaceCount = _NUM - name . length ( ) ; char [ ] spaceArr = new char [ spaceCount ] ; Arrays . fill ( spaceArr , STRING ) ; String spaces = new String ( spaceArr ) ; if ( out . annotates ( ) ) { out . annotate ( _NUM , name + STRING + spaces + Hex . u4 ( sz ) ) ; out . annotate ( _NUM , name + STRING + spaces + Hex . u4 ( offset ) ) ; } out . writeInt ( sz ) ; out . writeInt ( offset ) ; }
public AddWorldParameterDialog ( java . awt . Frame parent , boolean modal , Diagram diagram , Point clickPosition ) { super ( parent , modal ) ; initComponents ( ) ; DefaultComboBoxModel model = new DefaultComboBoxModel ( ) ; for ( UniformBinding binding : UniformBinding . values ( ) ) { model . addElement ( binding ) ; } this . diagram = diagram ; this . clickPosition = clickPosition ; nameField . setModel ( model ) ; }
private static BitmapSampled cropBitmap ( Context context , Uri loadedImageUri , float [ ] points , int degreesRotated , boolean fixAspectRatio , int aspectRatioX , int aspectRatioY , int sampleMulti , Rect rect , int width , int height ) { Bitmap result = null ; int sampleSize ; try { BitmapFactory . Options options = new BitmapFactory . Options ( ) ; options . inSampleSize = sampleSize = sampleMulti * calculateInSampleSizeByReqestedSize ( rect . width ( ) , rect . height ( ) , width , height ) ; Bitmap fullBitmap = decodeImage ( context . getContentResolver ( ) , loadedImageUri , options ) ; if ( fullBitmap != null ) { try { float [ ] points2 = new float [ points . length ] ; System . arraycopy ( points , _NUM , points2 , _NUM , points . length ) ; for ( int i = _NUM ; i < points2 . length ; i ++ ) { points2 [ i ] = points2 [ i ] / options . inSampleSize ; } result = cropBitmap ( fullBitmap , points2 , degreesRotated , fixAspectRatio , aspectRatioX , aspectRatioY ) ; } finally { if ( result != fullBitmap ) { fullBitmap . recycle ( ) ; } } } } catch ( OutOfMemoryError e ) { if ( result != null ) { result . recycle ( ) ; } throw e ; } catch ( Exception e ) { throw new RuntimeException ( STRING + loadedImageUri + STRING + e . getMessage ( ) , e ) ; } return new BitmapSampled ( result , sampleSize ) ; }
private TextClusterData findCluster ( String text , Date timeStamp , boolean isTrace ) throws AdeException { boolean pathsAreOneToken = _BOOL ; if ( m_messageTextPreprocessor != null ) { pathsAreOneToken = m_messageTextPreprocessor . treatPathsAsOneToken ( ) ; } Word [ ] words ; if ( pathsAreOneToken ) { words = LevenshteinTextSummary . prepareStringToken ( text ) ; } else { words = LevenshteinTextSummary . prepareString ( text ) ; } final Iterator < TextClusterData > e = m_clustersData . iterator ( ) ; while ( e . hasNext ( ) ) { final TextClusterData cluster = e . next ( ) ; final String clusterRepresentative = cluster . getTextRepresentative ( ) ; Word [ ] clusterRepresentativeWords ; if ( pathsAreOneToken ) { clusterRepresentativeWords = LevenshteinTextSummary . prepareStringToken ( clusterRepresentative ) ; } else { clusterRepresentativeWords = LevenshteinTextSummary . prepareString ( clusterRepresentative ) ; } final int threshold = m_thresholdSetter . getThreshold ( clusterRepresentativeWords . length , words . length ) ; final boolean areClose = areClose ( clusterRepresentativeWords , words , threshold , isTrace ) ; boolean updatedLastObserved ; if ( areClose ) { updatedLastObserved = cluster . setLastObserved ( timeStamp ) ; e . remove ( ) ; m_clustersData . push ( cluster ) ; if ( m_updateDataStore && updatedLastObserved ) { m_dsTextClustering . updateTextClusterTimeStamp ( cluster . getClusterId ( ) , cluster . getLastObserved ( ) ) ; } return cluster ; } } return null ; }
public void addTracks ( SoundCloudTrack track ) { mTracks . add ( track ) ; }
public void start ( ) { log . info ( STRING , this . name , this . frequencyInSecs ) ; stopped = _BOOL ; Thread drHealthMonitorThread = new Thread ( this ) ; drHealthMonitorThread . setName ( this . name ) ; drHealthMonitorThread . start ( ) ; }
public void clearGesture ( ) { currentGestureActionList . removeAllElements ( ) ; }
public void invalidate ( String group ) { Iterator items = items ( group , ValidatedPredicate . TRUE ) ; while ( items . hasNext ( ) ) { VisualItem item = ( VisualItem ) items . next ( ) ; item . setValidated ( _BOOL ) ; } }
public void invalidate ( String group ) { Iterator items = items ( group , ValidatedPredicate . TRUE ) ; while ( items . hasNext ( ) ) { VisualItem item = ( VisualItem ) items . next ( ) ; item . setValidated ( _BOOL ) ; } }
public void invalidate ( String group ) { Iterator items = items ( group , ValidatedPredicate . TRUE ) ; while ( items . hasNext ( ) ) { VisualItem item = ( VisualItem ) items . next ( ) ; item . setValidated ( _BOOL ) ; } }
public void addListener ( NavigatorListener listener ) { listeners . add ( listener ) ; }
public RuntimeCollector ( Algorithm algorithm , int frequency , ResultFileWriter writer ) { super ( algorithm , frequency , FrequencyType . EVALUATIONS ) ; this . writer = writer ; startTime = System . nanoTime ( ) ; }
public RuntimeCollector ( Algorithm algorithm , int frequency , ResultFileWriter writer ) { super ( algorithm , frequency , FrequencyType . EVALUATIONS ) ; this . writer = writer ; startTime = System . nanoTime ( ) ; }
public static boolean viaEquals ( final X500Principal p1 , final X500Principal p2 ) { return p1 . equals ( p2 ) ; }
public OscWorldComponent ( final String name ) { super ( name ) ; }
public void tryConnect ( ) { try { if ( TextUtils . isEmpty ( AppInfo . btAddress ) ) { return ; } if ( null == mAdapter ) { mAdapter = BluetoothAdapter . getDefaultAdapter ( ) ; } if ( null == mAdapter ) { return ; } if ( null == mBtService ) { mBtService = new BtService ( mContext ) ; } if ( mBtService . getState ( ) != BtService . STATE_CONNECTED ) { if ( ! TextUtils . isEmpty ( AppInfo . btAddress ) ) { BluetoothDevice device = mAdapter . getRemoteDevice ( AppInfo . btAddress ) ; mBtService . connect ( device ) ; return ; } } else { } } catch ( Exception e ) { e . printStackTrace ( ) ; } catch ( Error e ) { e . printStackTrace ( ) ; } }
protected static List < EndpointHelpDto > describeEndpoints ( List < Class < ? extends AbstractResource > > resourceClasses ) { List < EndpointHelpDto > result = new LinkedList < > ( ) ; if ( resourceClasses != null && ! resourceClasses . isEmpty ( ) ) { for ( Class < ? extends AbstractResource > resourceClass : resourceClasses ) { EndpointHelpDto dto = EndpointHelpDto . fromResourceClass ( resourceClass ) ; if ( dto != null ) { result . add ( dto ) ; } } } return result ; }
protected void onProgress ( int itemcount , int size ) { }
protected void onProgress ( int itemcount , int size ) { }
protected void onProgress ( int itemcount , int size ) { }
protected void onProgress ( int itemcount , int size ) { }
public void randomize ( List < CellIndex > cellIndices ) { Random rand = new Random ( ) ; int range = getUpperBound ( ) - getLowerBound ( ) ; for ( CellIndex cellIndex : cellIndices ) { int row = cellIndex . row ; int col = cellIndex . col ; double value = ( rand . nextDouble ( ) * range ) + getLowerBound ( ) ; setLogicalValue ( row , col , value , _BOOL ) ; } fireTableDataChanged ( ) ; }
public OrderByClause add ( String property , boolean isDescending ) { orderByExpressions . add ( new OrderByElement ( Expressions . getPropExpr ( property ) , isDescending ) ) ; return this ; }
public void resultPhoto ( int requestCode , int resultCode , Intent data ) { if ( resultCode == Activity . RESULT_OK ) { if ( requestCode == SELECT_PHOTO ) { this . myPhoto = onSelectFromGalleryResult ( data ) ; } else if ( requestCode == TAKE_PHOTO ) { this . myPhoto = onTakePhotoResult ( ) ; } if ( this . myPhoto != null ) { if ( ifCameraLandScape ( _BOOL ) == LANDSCAPE_CAMERA ) { this . myPhoto = rotateImage ( getMyPhoto ( ) , _NUM ) ; } } } }
default String roleParentName ( String type ) { return String . format ( ROLE_PARENT , type ) ; }
public void startElement ( ) { nss . pushContext ( ) ; inCollectingMode = _BOOL ; }
public static boolean isValidNoColonWWN ( String wwn ) { return wwn != null && wwn . matches ( WWN_NO_COLON_PATTERN ) ; }
public boolean fieldIsTransient ( ) { return Modifier . isTransient ( field . getModifiers ( ) ) ; }
final int fullTryAcquireShared ( Thread current ) { HoldCounter rh = null ; for ( ; ; ) { int c = getState ( ) ; if ( exclusiveCount ( c ) != _NUM ) { if ( getExclusiveOwnerThread ( ) != current ) return - _NUM ; } else if ( readerShouldBlock ( ) ) { if ( firstReader == current ) { } else { if ( rh == null ) { rh = cachedHoldCounter ; if ( rh == null || rh . tid != current . getId ( ) ) { rh = readHolds . get ( ) ; if ( rh . count == _NUM ) readHolds . remove ( ) ; } } if ( rh . count == _NUM ) return - _NUM ; } } if ( sharedCount ( c ) == MAX_COUNT ) throw new Error ( STRING ) ; if ( compareAndSetState ( c , c + SHARED_UNIT ) ) { if ( sharedCount ( c ) == _NUM ) { firstReader = current ; firstReaderHoldCount = _NUM ; } else if ( firstReader == current ) { firstReaderHoldCount ++ ; } else { if ( rh == null ) rh = cachedHoldCounter ; if ( rh == null || rh . tid != current . getId ( ) ) rh = readHolds . get ( ) ; else if ( rh . count == _NUM ) readHolds . set ( rh ) ; rh . count ++ ; cachedHoldCounter = rh ; } return _NUM ; } } }
final int fullTryAcquireShared ( Thread current ) { HoldCounter rh = null ; for ( ; ; ) { int c = getState ( ) ; if ( exclusiveCount ( c ) != _NUM ) { if ( getExclusiveOwnerThread ( ) != current ) return - _NUM ; } else if ( readerShouldBlock ( ) ) { if ( firstReader == current ) { } else { if ( rh == null ) { rh = cachedHoldCounter ; if ( rh == null || rh . tid != current . getId ( ) ) { rh = readHolds . get ( ) ; if ( rh . count == _NUM ) readHolds . remove ( ) ; } } if ( rh . count == _NUM ) return - _NUM ; } } if ( sharedCount ( c ) == MAX_COUNT ) throw new Error ( STRING ) ; if ( compareAndSetState ( c , c + SHARED_UNIT ) ) { if ( sharedCount ( c ) == _NUM ) { firstReader = current ; firstReaderHoldCount = _NUM ; } else if ( firstReader == current ) { firstReaderHoldCount ++ ; } else { if ( rh == null ) rh = cachedHoldCounter ; if ( rh == null || rh . tid != current . getId ( ) ) rh = readHolds . get ( ) ; else if ( rh . count == _NUM ) readHolds . set ( rh ) ; rh . count ++ ; cachedHoldCounter = rh ; } return _NUM ; } } }
final int fullTryAcquireShared ( Thread current ) { HoldCounter rh = null ; for ( ; ; ) { int c = getState ( ) ; if ( exclusiveCount ( c ) != _NUM ) { if ( getExclusiveOwnerThread ( ) != current ) return - _NUM ; } else if ( readerShouldBlock ( ) ) { if ( firstReader == current ) { } else { if ( rh == null ) { rh = cachedHoldCounter ; if ( rh == null || rh . tid != current . getId ( ) ) { rh = readHolds . get ( ) ; if ( rh . count == _NUM ) readHolds . remove ( ) ; } } if ( rh . count == _NUM ) return - _NUM ; } } if ( sharedCount ( c ) == MAX_COUNT ) throw new Error ( STRING ) ; if ( compareAndSetState ( c , c + SHARED_UNIT ) ) { if ( sharedCount ( c ) == _NUM ) { firstReader = current ; firstReaderHoldCount = _NUM ; } else if ( firstReader == current ) { firstReaderHoldCount ++ ; } else { if ( rh == null ) rh = cachedHoldCounter ; if ( rh == null || rh . tid != current . getId ( ) ) rh = readHolds . get ( ) ; else if ( rh . count == _NUM ) readHolds . set ( rh ) ; rh . count ++ ; cachedHoldCounter = rh ; } return _NUM ; } } }
final int fullTryAcquireShared ( Thread current ) { HoldCounter rh = null ; for ( ; ; ) { int c = getState ( ) ; if ( exclusiveCount ( c ) != _NUM ) { if ( getExclusiveOwnerThread ( ) != current ) return - _NUM ; } else if ( readerShouldBlock ( ) ) { if ( firstReader == current ) { } else { if ( rh == null ) { rh = cachedHoldCounter ; if ( rh == null || rh . tid != current . getId ( ) ) { rh = readHolds . get ( ) ; if ( rh . count == _NUM ) readHolds . remove ( ) ; } } if ( rh . count == _NUM ) return - _NUM ; } } if ( sharedCount ( c ) == MAX_COUNT ) throw new Error ( STRING ) ; if ( compareAndSetState ( c , c + SHARED_UNIT ) ) { if ( sharedCount ( c ) == _NUM ) { firstReader = current ; firstReaderHoldCount = _NUM ; } else if ( firstReader == current ) { firstReaderHoldCount ++ ; } else { if ( rh == null ) rh = cachedHoldCounter ; if ( rh == null || rh . tid != current . getId ( ) ) rh = readHolds . get ( ) ; else if ( rh . count == _NUM ) readHolds . set ( rh ) ; rh . count ++ ; cachedHoldCounter = rh ; } return _NUM ; } } }
final int fullTryAcquireShared ( Thread current ) { HoldCounter rh = null ; for ( ; ; ) { int c = getState ( ) ; if ( exclusiveCount ( c ) != _NUM ) { if ( getExclusiveOwnerThread ( ) != current ) return - _NUM ; } else if ( readerShouldBlock ( ) ) { if ( firstReader == current ) { } else { if ( rh == null ) { rh = cachedHoldCounter ; if ( rh == null || rh . tid != current . getId ( ) ) { rh = readHolds . get ( ) ; if ( rh . count == _NUM ) readHolds . remove ( ) ; } } if ( rh . count == _NUM ) return - _NUM ; } } if ( sharedCount ( c ) == MAX_COUNT ) throw new Error ( STRING ) ; if ( compareAndSetState ( c , c + SHARED_UNIT ) ) { if ( sharedCount ( c ) == _NUM ) { firstReader = current ; firstReaderHoldCount = _NUM ; } else if ( firstReader == current ) { firstReaderHoldCount ++ ; } else { if ( rh == null ) rh = cachedHoldCounter ; if ( rh == null || rh . tid != current . getId ( ) ) rh = readHolds . get ( ) ; else if ( rh . count == _NUM ) readHolds . set ( rh ) ; rh . count ++ ; cachedHoldCounter = rh ; } return _NUM ; } } }
private boolean canForcePerform ( String permissionName ) { List < PermissionRule > access = access ( permissionName ) ; List < PermissionRule > overridden = relevant . getOverridden ( permissionName ) ; Set < ProjectRef > allows = new HashSet < > ( ) ; Set < ProjectRef > blocks = new HashSet < > ( ) ; for ( PermissionRule rule : access ) { if ( rule . isBlock ( ) ) { blocks . add ( relevant . getRuleProps ( rule ) ) ; } else if ( rule . getForce ( ) ) { allows . add ( relevant . getRuleProps ( rule ) ) ; } } for ( PermissionRule rule : overridden ) { if ( rule . getForce ( ) ) { blocks . remove ( relevant . getRuleProps ( rule ) ) ; } } blocks . removeAll ( allows ) ; return blocks . isEmpty ( ) && ! allows . isEmpty ( ) ; }
private boolean canForcePerform ( String permissionName ) { List < PermissionRule > access = access ( permissionName ) ; List < PermissionRule > overridden = relevant . getOverridden ( permissionName ) ; Set < ProjectRef > allows = new HashSet < > ( ) ; Set < ProjectRef > blocks = new HashSet < > ( ) ; for ( PermissionRule rule : access ) { if ( rule . isBlock ( ) ) { blocks . add ( relevant . getRuleProps ( rule ) ) ; } else if ( rule . getForce ( ) ) { allows . add ( relevant . getRuleProps ( rule ) ) ; } } for ( PermissionRule rule : overridden ) { if ( rule . getForce ( ) ) { blocks . remove ( relevant . getRuleProps ( rule ) ) ; } } blocks . removeAll ( allows ) ; return blocks . isEmpty ( ) && ! allows . isEmpty ( ) ; }
public static int decodedLength ( String secret ) { checkNotNull ( secret ) ; secret = removeEnd ( removeEnd ( chomp ( secret ) , STRING ) , STRING ) ; return ( secret . length ( ) * _NUM ) / _NUM ; }
private Double readDoubleNumberFromExpression ( String expression ) throws ParsingException { Character c = expression . charAt ( expressionIterator ) ; Double number = getDoubleDigit ( c ) ; while ( ++ expressionIterator < expression . length ( ) ) { c = expression . charAt ( expressionIterator ) ; if ( ! Character . isDigit ( c ) ) { break ; } number *= _NUM ; number += getDoubleDigit ( c ) ; } if ( c == STRING ) { if ( ++ expressionIterator == expression . length ( ) ) { throw new ParsingException ( ILLEGAL_POSITION_IN_EXPRESSION + c ) ; } c = expression . charAt ( expressionIterator ) ; double placeFactor = _NUM ; number += getDoubleDigit ( c ) / placeFactor ; if ( ! Character . isDigit ( c ) ) { throw new ParsingException ( ILLEGAL_POSITION_IN_EXPRESSION + c ) ; } while ( ++ expressionIterator < expression . length ( ) ) { c = expression . charAt ( expressionIterator ) ; if ( ! Character . isDigit ( c ) ) { break ; } placeFactor *= _NUM ; number += getDoubleDigit ( c ) / placeFactor ; } } -- expressionIterator ; return number ; }
static int writeVarLong ( OutputStream out , long x ) throws IOException { int len = _NUM ; while ( ( x & ~ _NUM ) != _NUM ) { out . write ( ( byte ) ( _NUM | ( x & _NUM ) ) ) ; x >>>= _NUM ; len ++ ; } out . write ( ( byte ) x ) ; return ++ len ; }
public void clearImages ( ) { chunks . clear ( ) ; markers . clear ( ) ; redraw ( _BOOL ) ; shift_x = _NUM ; shift_y = _NUM ; zoom_level_pos = _NUM ; zoom_level = _NUM ; }
public void clearImages ( ) { chunks . clear ( ) ; markers . clear ( ) ; redraw ( _BOOL ) ; shift_x = _NUM ; shift_y = _NUM ; zoom_level_pos = _NUM ; zoom_level = _NUM ; }
public static String stripFileProtocol ( String uriString ) { if ( uriString . startsWith ( STRING ) ) { uriString = uriString . substring ( _NUM ) ; } return uriString ; }
public static String stripFileProtocol ( String uriString ) { if ( uriString . startsWith ( STRING ) ) { uriString = uriString . substring ( _NUM ) ; } return uriString ; }
public static String stripFileProtocol ( String uriString ) { if ( uriString . startsWith ( STRING ) ) { uriString = uriString . substring ( _NUM ) ; } return uriString ; }
public static String stripFileProtocol ( String uriString ) { if ( uriString . startsWith ( STRING ) ) { uriString = uriString . substring ( _NUM ) ; } return uriString ; }
void createLoginConfig ( ) { HashMap < String , String > sslConfigOptions = new HashMap < > ( ) ; HashMap < String , String > configOptions = new HashMap < > ( ) ; sslConfigOptions . put ( StubLoginModule . ALLOW_LOGIN_PROPERTY , STRING ) ; sslConfigOptions . put ( StubLoginModule . USERS_PROPERTY , DN_USERNAME ) ; sslConfigOptions . put ( StubLoginModule . GROUPS_PROPERTY , DN_GROUP ) ; AppConfigurationEntry sslConfigEntry = new AppConfigurationEntry ( STRING , AppConfigurationEntry . LoginModuleControlFlag . REQUIRED , sslConfigOptions ) ; configOptions . put ( StubLoginModule . ALLOW_LOGIN_PROPERTY , STRING ) ; configOptions . put ( StubLoginModule . USERS_PROPERTY , INSECURE_USERNAME ) ; configOptions . put ( StubLoginModule . GROUPS_PROPERTY , INSECURE_GROUP ) ; AppConfigurationEntry configEntry = new AppConfigurationEntry ( STRING , AppConfigurationEntry . LoginModuleControlFlag . REQUIRED , configOptions ) ; StubDualJaasConfiguration jaasConfig = new StubDualJaasConfiguration ( configEntry , sslConfigEntry ) ; Configuration . setConfiguration ( jaasConfig ) ; }
private void validateDebugSettings ( ) { verifyDiffCheckBox . setSelected ( controller . isDiffVerificationEnabled ( ) ) ; verifyEncodingCheckBox . setSelected ( controller . isEncodingVerificationEnabled ( ) ) ; statsOutputCheckBox . setSelected ( controller . isStatsOutputEnabled ( ) ) ; boolean flagA = controller . isDiffVerificationEnabled ( ) || controller . isEncodingVerificationEnabled ( ) ; debugOuputCheckBox . setEnabled ( flagA ) ; debugOuputCheckBox . setSelected ( controller . isDebugOutputEnabled ( ) ) ; boolean flagB = controller . isDebugOutputEnabled ( ) ; debugOutputLabel . setEnabled ( flagA && flagB ) ; debugOutputField . setEnabled ( flagA && flagB ) ; }
@ Override public void resetLearning ( ) { this . instancesSeen = _NUM ; this . classInstances = new HashMap < > ( ) ; this . classPrototypes = new HashMap < > ( ) ; this . attributeObservers = new HashMap < > ( ) ; }
@ Override public void onProjectClosed ( ProjectActionEvent event ) { ProjectDescriptor project = event . getProject ( ) ; final String projectTypeId = project . getType ( ) ; boolean isJSProject = projectTypeId . endsWith ( STRING ) ; if ( isJSProject ) { workspaceAgent . removePart ( yeomanPartPresenter ) ; } }
@ Override public void onProjectClosed ( ProjectActionEvent event ) { ProjectDescriptor project = event . getProject ( ) ; final String projectTypeId = project . getType ( ) ; boolean isJSProject = projectTypeId . endsWith ( STRING ) ; if ( isJSProject ) { workspaceAgent . removePart ( yeomanPartPresenter ) ; } }
@ Override public void write ( T value ) throws Exception { marshaller . marshal ( value , os ) ; }
private OkHttpClient copyWithDefaults ( ) { OkHttpClient result = new OkHttpClient ( this ) ; result . proxy = proxy ; result . proxySelector = proxySelector != null ? proxySelector : ProxySelector . getDefault ( ) ; result . cookieHandler = cookieHandler != null ? cookieHandler : CookieHandler . getDefault ( ) ; result . responseCache = responseCache != null ? responseCache : ResponseCache . getDefault ( ) ; result . sslSocketFactory = sslSocketFactory != null ? sslSocketFactory : HttpsURLConnection . getDefaultSSLSocketFactory ( ) ; result . hostnameVerifier = hostnameVerifier != null ? hostnameVerifier : OkHostnameVerifier . INSTANCE ; result . authenticator = authenticator != null ? authenticator : HttpAuthenticator . SYSTEM_DEFAULT ; result . connectionPool = connectionPool != null ? connectionPool : ConnectionPool . getDefault ( ) ; result . followProtocolRedirects = followProtocolRedirects ; result . transports = transports != null ? transports : DEFAULT_TRANSPORTS ; result . connectTimeout = connectTimeout ; result . readTimeout = readTimeout ; return result ; }
private OkHttpClient copyWithDefaults ( ) { OkHttpClient result = new OkHttpClient ( this ) ; result . proxy = proxy ; result . proxySelector = proxySelector != null ? proxySelector : ProxySelector . getDefault ( ) ; result . cookieHandler = cookieHandler != null ? cookieHandler : CookieHandler . getDefault ( ) ; result . responseCache = responseCache != null ? responseCache : ResponseCache . getDefault ( ) ; result . sslSocketFactory = sslSocketFactory != null ? sslSocketFactory : HttpsURLConnection . getDefaultSSLSocketFactory ( ) ; result . hostnameVerifier = hostnameVerifier != null ? hostnameVerifier : OkHostnameVerifier . INSTANCE ; result . authenticator = authenticator != null ? authenticator : HttpAuthenticator . SYSTEM_DEFAULT ; result . connectionPool = connectionPool != null ? connectionPool : ConnectionPool . getDefault ( ) ; result . followProtocolRedirects = followProtocolRedirects ; result . transports = transports != null ? transports : DEFAULT_TRANSPORTS ; result . connectTimeout = connectTimeout ; result . readTimeout = readTimeout ; return result ; }
private OkHttpClient copyWithDefaults ( ) { OkHttpClient result = new OkHttpClient ( this ) ; result . proxy = proxy ; result . proxySelector = proxySelector != null ? proxySelector : ProxySelector . getDefault ( ) ; result . cookieHandler = cookieHandler != null ? cookieHandler : CookieHandler . getDefault ( ) ; result . responseCache = responseCache != null ? responseCache : ResponseCache . getDefault ( ) ; result . sslSocketFactory = sslSocketFactory != null ? sslSocketFactory : HttpsURLConnection . getDefaultSSLSocketFactory ( ) ; result . hostnameVerifier = hostnameVerifier != null ? hostnameVerifier : OkHostnameVerifier . INSTANCE ; result . authenticator = authenticator != null ? authenticator : HttpAuthenticator . SYSTEM_DEFAULT ; result . connectionPool = connectionPool != null ? connectionPool : ConnectionPool . getDefault ( ) ; result . followProtocolRedirects = followProtocolRedirects ; result . transports = transports != null ? transports : DEFAULT_TRANSPORTS ; result . connectTimeout = connectTimeout ; result . readTimeout = readTimeout ; return result ; }
public ComputeTaskTimeoutCheckedException ( Throwable cause ) { this ( cause . getMessage ( ) , cause ) ; }
public void testGetElementsByTagNameNS1 ( ) throws Throwable { Document doc ; Document newDoc ; DocumentType docType = null ; DOMImplementation domImpl ; NodeList childList ; String nullNS = null ; doc = ( Document ) load ( STRING , builder ) ; domImpl = doc . getImplementation ( ) ; newDoc = domImpl . createDocument ( nullNS , STRING , docType ) ; childList = newDoc . getElementsByTagNameNS ( STRING , STRING ) ; assertEquals ( STRING , _NUM , childList . getLength ( ) ) ; }
private Method findFromStringMethod ( Class < ? > cls , boolean searchSuperclasses ) { Method matched = null ; Class < ? > loopCls = cls ; while ( loopCls != null && matched == null ) { Method [ ] methods = loopCls . getDeclaredMethods ( ) ; for ( Method method : methods ) { FromString fromString = method . getAnnotation ( FromString . class ) ; if ( fromString != null ) { if ( matched != null ) { throw new IllegalStateException ( STRING ) ; } matched = method ; } } if ( searchSuperclasses == _BOOL ) { break ; } loopCls = loopCls . getSuperclass ( ) ; } return matched ; }
protected int size ( ) { return document . length ( ) ; }
public TSDataOptimizerTask ( @ NonNull Path destDir ) { this . destDir = destDir ; if ( ! Files . isDirectory ( destDir ) ) throw new IllegalArgumentException ( destDir + STRING ) ; }
public ManagerFactory ( String databaseUrl , ManagerPool pool , long pollPeriod , TimeUnit unit , ConnectionMode mode ) { this . databaseUrl = databaseUrl ; this . pool = pool ; this . pollMs = unit . toMillis ( pollPeriod ) ; this . mode = mode ; tryCreateTables ( ) ; }
public ManagerFactory ( String databaseUrl , ManagerPool pool , long pollPeriod , TimeUnit unit , ConnectionMode mode ) { this . databaseUrl = databaseUrl ; this . pool = pool ; this . pollMs = unit . toMillis ( pollPeriod ) ; this . mode = mode ; tryCreateTables ( ) ; }
boolean cancel ( int propertyConstant ) { if ( ( mPropertyMask & propertyConstant ) != _NUM && mNameValuesHolder != null ) { int count = mNameValuesHolder . size ( ) ; for ( int i = _NUM ; i < count ; ++ i ) { NameValuesHolder nameValuesHolder = mNameValuesHolder . get ( i ) ; if ( nameValuesHolder . mNameConstant == propertyConstant ) { mNameValuesHolder . remove ( i ) ; mPropertyMask &= ~ propertyConstant ; return _BOOL ; } } } return _BOOL ; }
boolean cancel ( int propertyConstant ) { if ( ( mPropertyMask & propertyConstant ) != _NUM && mNameValuesHolder != null ) { int count = mNameValuesHolder . size ( ) ; for ( int i = _NUM ; i < count ; ++ i ) { NameValuesHolder nameValuesHolder = mNameValuesHolder . get ( i ) ; if ( nameValuesHolder . mNameConstant == propertyConstant ) { mNameValuesHolder . remove ( i ) ; mPropertyMask &= ~ propertyConstant ; return _BOOL ; } } } return _BOOL ; }
boolean cancel ( int propertyConstant ) { if ( ( mPropertyMask & propertyConstant ) != _NUM && mNameValuesHolder != null ) { int count = mNameValuesHolder . size ( ) ; for ( int i = _NUM ; i < count ; ++ i ) { NameValuesHolder nameValuesHolder = mNameValuesHolder . get ( i ) ; if ( nameValuesHolder . mNameConstant == propertyConstant ) { mNameValuesHolder . remove ( i ) ; mPropertyMask &= ~ propertyConstant ; return _BOOL ; } } } return _BOOL ; }
@ Override public VolatileImage createBackBuffer ( WComponentPeer peer ) { Component target = ( Component ) peer . getTarget ( ) ; return new SunVolatileImage ( target , target . getWidth ( ) , target . getHeight ( ) , Boolean . TRUE ) ; }
public static Pattern buildStopwordPattern ( Collection < String > stopwords , Boolean caseSensitive ) { StringJoiner sj = new StringJoiner ( STRING ) ; for ( String s : stopwords ) { sj . add ( Pattern . quote ( s ) ) ; } if ( caseSensitive ) { return Pattern . compile ( STRING + sj . toString ( ) + STRING ) ; } else { return Pattern . compile ( STRING + sj . toString ( ) + STRING , Pattern . CASE_INSENSITIVE ) ; } }
private int exceptionEndRange ( int bcIndex ) { int max = bcodes . length ( ) ; if ( startPCs != null ) { for ( int spc : startPCs ) { if ( bcIndex < spc && max > spc ) { max = spc ; } } for ( int epc : endPCs ) { if ( bcIndex < epc && max > epc ) { max = epc ; } } } return max ; }
private int exceptionEndRange ( int bcIndex ) { int max = bcodes . length ( ) ; if ( startPCs != null ) { for ( int spc : startPCs ) { if ( bcIndex < spc && max > spc ) { max = spc ; } } for ( int epc : endPCs ) { if ( bcIndex < epc && max > epc ) { max = epc ; } } } return max ; }
public boolean namespacePublishedToMapgraph ( final String namespace ) throws Exception { assertMapgraphRuntimeAvailable ( ) ; final String repositoryUrl = getSparqlEndpointUrlForNamespaceOrDefault ( namespace ) ; final ConnectOptions opts = newConnectOptions ( repositoryUrl , UUID . randomUUID ( ) , null ) ; JettyResponseListener response = null ; { opts . setAcceptHeader ( STRING ) ; opts . addRequestParam ( MAPGRAPH , CHECK_PUBLISHED ) ; opts . method = STRING ; } try { checkResponseCode ( response = doConnect ( opts ) ) ; final String responseBody = response . getResponseBody ( ) ; return responseBody != null && responseBody . contains ( STRING ) ; } finally { if ( response != null ) response . abort ( ) ; } }
public void clear ( ) { clear ( _BOOL ) ; }
public void close ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache != null ) { try { if ( ! mDiskLruCache . isClosed ( ) ) { mDiskLruCache . close ( ) ; } } catch ( Throwable e ) { LogUtils . e ( e . getMessage ( ) , e ) ; } mDiskLruCache = null ; } } }
public void close ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache != null ) { try { if ( ! mDiskLruCache . isClosed ( ) ) { mDiskLruCache . close ( ) ; } } catch ( Throwable e ) { LogUtils . e ( e . getMessage ( ) , e ) ; } mDiskLruCache = null ; } } }
public void close ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache != null ) { try { if ( ! mDiskLruCache . isClosed ( ) ) { mDiskLruCache . close ( ) ; } } catch ( Throwable e ) { LogUtils . e ( e . getMessage ( ) , e ) ; } mDiskLruCache = null ; } } }
public void close ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache != null ) { try { if ( ! mDiskLruCache . isClosed ( ) ) { mDiskLruCache . close ( ) ; } } catch ( Throwable e ) { LogUtils . e ( e . getMessage ( ) , e ) ; } mDiskLruCache = null ; } } }
public void showError ( Drawable errorImageDrawable , String errorTextTitle , String errorTextContent , String errorButtonText , View . OnClickListener onClickListener ) { switchState ( ERROR , errorImageDrawable , errorTextTitle , errorTextContent , errorButtonText , onClickListener , Collections . < Integer > emptyList ( ) ) ; }
public void showError ( Drawable errorImageDrawable , String errorTextTitle , String errorTextContent , String errorButtonText , View . OnClickListener onClickListener ) { switchState ( ERROR , errorImageDrawable , errorTextTitle , errorTextContent , errorButtonText , onClickListener , Collections . < Integer > emptyList ( ) ) ; }
public void showError ( Drawable errorImageDrawable , String errorTextTitle , String errorTextContent , String errorButtonText , View . OnClickListener onClickListener ) { switchState ( ERROR , errorImageDrawable , errorTextTitle , errorTextContent , errorButtonText , onClickListener , Collections . < Integer > emptyList ( ) ) ; }
public void showError ( Drawable errorImageDrawable , String errorTextTitle , String errorTextContent , String errorButtonText , View . OnClickListener onClickListener ) { switchState ( ERROR , errorImageDrawable , errorTextTitle , errorTextContent , errorButtonText , onClickListener , Collections . < Integer > emptyList ( ) ) ; }
public void showError ( Drawable errorImageDrawable , String errorTextTitle , String errorTextContent , String errorButtonText , View . OnClickListener onClickListener ) { switchState ( ERROR , errorImageDrawable , errorTextTitle , errorTextContent , errorButtonText , onClickListener , Collections . < Integer > emptyList ( ) ) ; }
public static void runInBackground ( Runnable runnable ) { backgroundExecutor . submit ( runnable ) ; }
public static void runInBackground ( Runnable runnable ) { backgroundExecutor . submit ( runnable ) ; }
public static void runInBackground ( Runnable runnable ) { backgroundExecutor . submit ( runnable ) ; }
protected void writeModelFile ( ) throws IOException { modfile = File . createTempFile ( STRING , STRING ) ; try ( OutputStreamWriter fw = new OutputStreamWriter ( new FileOutputStream ( modfile ) , encoding ) ) { JsCompiler . beginWrapper ( fw ) ; fw . write ( STRING ) ; ModelEncoder . encodeModel ( mmg . getModel ( ) , fw ) ; fw . write ( STRING ) ; JsCompiler . endWrapper ( fw ) ; } finally { } }
public static void replaceValue ( ExampleSet exampleSet , Attribute attribute , String oldValue , String newValue ) { if ( ! attribute . isNominal ( ) ) { throw new RuntimeException ( STRING ) ; } NominalMapping mapping = attribute . getMapping ( ) ; if ( oldValue . equals ( STRING ) ) { for ( Example example : exampleSet ) { if ( Double . isNaN ( example . getValue ( attribute ) ) ) { example . setValue ( attribute , mapping . mapString ( newValue ) ) ; } } } else { int oldIndex = mapping . getIndex ( oldValue ) ; if ( oldIndex < _NUM ) { throw new RuntimeException ( STRING ) ; } if ( newValue . equals ( STRING ) ) { for ( Example example : exampleSet ) { int index = mapping . getIndex ( example . getValueAsString ( attribute ) ) ; if ( index == oldIndex ) { example . setValue ( attribute , Double . NaN ) ; } } return ; } int newIndex = mapping . getIndex ( newValue ) ; if ( newIndex >= _NUM ) { for ( Example example : exampleSet ) { int index = mapping . getIndex ( example . getValueAsString ( attribute ) ) ; if ( index == oldIndex ) { example . setValue ( attribute , newIndex ) ; } } } else { mapping . setMapping ( newValue , oldIndex ) ; } } }
LoginProcess startLoginProcess ( LoginProcess loginProcess ) throws AuthLoginException { LoginConfiguration loginConfiguration = loginProcess . getLoginConfiguration ( ) ; HttpServletRequest request = loginConfiguration . getHttpRequest ( ) ; AuthIndexType indexType = loginConfiguration . getIndexType ( ) ; String indexValue = loginConfiguration . getIndexValue ( ) ; AuthenticationContext authContext = loginProcess . getAuthContext ( ) ; if ( indexType != null && indexType . equals ( AuthIndexType . RESOURCE ) ) { Map < String , Set < String > > envMap = coreServicesWrapper . getEnvMap ( request ) ; if ( StringUtils . isBlank ( indexValue ) || Boolean . parseBoolean ( indexValue ) ) { indexValue = coreServicesWrapper . getResourceURL ( request ) ; } authContext . login ( indexType . getIndexType ( ) , indexValue , envMap , null ) ; } else if ( indexType != null && indexType . getIndexType ( ) != null ) { authContext . login ( indexType . getIndexType ( ) , indexValue ) ; } else { authContext . login ( ) ; } try { HttpServletResponse response = loginConfiguration . getHttpResponse ( ) ; coreServicesWrapper . setLbCookie ( authContext . getAuthContext ( ) , request , response ) ; } catch ( AuthException e ) { throw new AuthLoginException ( e ) ; } return loginProcess ; }
LoginProcess startLoginProcess ( LoginProcess loginProcess ) throws AuthLoginException { LoginConfiguration loginConfiguration = loginProcess . getLoginConfiguration ( ) ; HttpServletRequest request = loginConfiguration . getHttpRequest ( ) ; AuthIndexType indexType = loginConfiguration . getIndexType ( ) ; String indexValue = loginConfiguration . getIndexValue ( ) ; AuthenticationContext authContext = loginProcess . getAuthContext ( ) ; if ( indexType != null && indexType . equals ( AuthIndexType . RESOURCE ) ) { Map < String , Set < String > > envMap = coreServicesWrapper . getEnvMap ( request ) ; if ( StringUtils . isBlank ( indexValue ) || Boolean . parseBoolean ( indexValue ) ) { indexValue = coreServicesWrapper . getResourceURL ( request ) ; } authContext . login ( indexType . getIndexType ( ) , indexValue , envMap , null ) ; } else if ( indexType != null && indexType . getIndexType ( ) != null ) { authContext . login ( indexType . getIndexType ( ) , indexValue ) ; } else { authContext . login ( ) ; } try { HttpServletResponse response = loginConfiguration . getHttpResponse ( ) ; coreServicesWrapper . setLbCookie ( authContext . getAuthContext ( ) , request , response ) ; } catch ( AuthException e ) { throw new AuthLoginException ( e ) ; } return loginProcess ; }
public void removeCertByAlias ( String [ ] certAliases ) throws KeyStoreException { if ( certAliases == null ) { return ; } for ( String s : certAliases ) { _keyStore . deleteEntry ( s ) ; } return ; }
public static final boolean executePotentialWork ( final Object data , final ImageView imageView ) { final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask ( imageView ) ; if ( bitmapWorkerTask != null ) { final Object bitmapData = bitmapWorkerTask . mKey ; if ( bitmapData == null || ! bitmapData . equals ( data ) ) { bitmapWorkerTask . cancel ( _BOOL ) ; } else { return _BOOL ; } } return _BOOL ; }
public static final boolean executePotentialWork ( final Object data , final ImageView imageView ) { final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask ( imageView ) ; if ( bitmapWorkerTask != null ) { final Object bitmapData = bitmapWorkerTask . mKey ; if ( bitmapData == null || ! bitmapData . equals ( data ) ) { bitmapWorkerTask . cancel ( _BOOL ) ; } else { return _BOOL ; } } return _BOOL ; }
public static final boolean executePotentialWork ( final Object data , final ImageView imageView ) { final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask ( imageView ) ; if ( bitmapWorkerTask != null ) { final Object bitmapData = bitmapWorkerTask . mKey ; if ( bitmapData == null || ! bitmapData . equals ( data ) ) { bitmapWorkerTask . cancel ( _BOOL ) ; } else { return _BOOL ; } } return _BOOL ; }
public void testMarkSupported ( ) { byte [ ] data = new byte [ ] { - _NUM , - _NUM , - _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; TestInputStream tis = new TestInputStream ( data ) ; CipherInputStream cis = new CipherInputStream ( tis , new NullCipher ( ) ) ; assertFalse ( STRING + STRING , cis . markSupported ( ) ) ; }
private static int findEsdsPosition ( ParsableByteArray parent , int position , int size ) { int childAtomPosition = parent . getPosition ( ) ; while ( childAtomPosition - position < size ) { parent . setPosition ( childAtomPosition ) ; int childAtomSize = parent . readInt ( ) ; Assertions . checkArgument ( childAtomSize > _NUM , STRING ) ; int childType = parent . readInt ( ) ; if ( childType == Atom . TYPE_esds ) { return childAtomPosition ; } childAtomPosition += childAtomSize ; } return - _NUM ; }
public static EnumSet < FacetRangeInclude > parseParam ( final String [ ] param ) { if ( null == param || _NUM == param . length ) return EnumSet . of ( LOWER ) ; final EnumSet < FacetRangeInclude > include = EnumSet . noneOf ( FacetRangeInclude . class ) ; for ( final String o : param ) { include . add ( FacetRangeInclude . get ( o ) ) ; } if ( include . contains ( FacetRangeInclude . ALL ) ) return EnumSet . allOf ( FacetRangeInclude . class ) ; return include ; }
public boolean onInterceptTouchEvent ( MotionEvent ev ) { @ SuppressWarnings ( STRING ) final boolean debug = _BOOL ; if ( debug ) { Log . d ( Launcher . TAG , STRING + ev + STRING + mDragging ) ; } acquireVelocityTrackerAndAddMovement ( ev ) ; final int action = ev . getAction ( ) ; final int [ ] dragLayerPos = getClampedDragLayerPos ( ev . getX ( ) , ev . getY ( ) ) ; final int dragLayerX = dragLayerPos [ _NUM ] ; final int dragLayerY = dragLayerPos [ _NUM ] ; switch ( action ) { case MotionEvent . ACTION_MOVE : break ; case MotionEvent . ACTION_DOWN : mMotionDownX = dragLayerX ; mMotionDownY = dragLayerY ; mLastDropTarget = null ; break ; case MotionEvent . ACTION_UP : mLastTouchUpTime = System . currentTimeMillis ( ) ; if ( mDragging ) { PointF vec = isFlingingToDelete ( mDragObject . dragSource ) ; if ( ! DeleteDropTarget . willAcceptDrop ( mDragObject . dragInfo ) ) { vec = null ; } if ( vec != null ) { dropOnFlingToDeleteTarget ( dragLayerX , dragLayerY , vec ) ; } else { drop ( dragLayerX , dragLayerY ) ; } } endDrag ( ) ; break ; case MotionEvent . ACTION_CANCEL : cancelDrag ( ) ; break ; } return mDragging ; }
public void volumeChange ( ChangeEvent e ) { JSlider v = ( JSlider ) e . getSource ( ) ; log . debug ( STRING + v . getValue ( ) ) ; firePropertyChange ( PropertyChangeID . VOLUME_CHANGE , v . getValue ( ) , v . getValue ( ) ) ; }
@ Override public final int readUnsignedShort ( ) throws IOException { dis . readFully ( work , _NUM , _NUM ) ; return ( ( work [ _NUM ] & _NUM ) << _NUM | ( work [ _NUM ] & _NUM ) ) ; }
@ Override public final int readUnsignedShort ( ) throws IOException { dis . readFully ( work , _NUM , _NUM ) ; return ( ( work [ _NUM ] & _NUM ) << _NUM | ( work [ _NUM ] & _NUM ) ) ; }
@ Override public final int readUnsignedShort ( ) throws IOException { dis . readFully ( work , _NUM , _NUM ) ; return ( ( work [ _NUM ] & _NUM ) << _NUM | ( work [ _NUM ] & _NUM ) ) ; }
private boolean tryIncrement ( AtomicInteger counter , int max ) { while ( _BOOL ) { int count = counter . get ( ) ; if ( count >= max && max != _NUM ) return _BOOL ; if ( counter . compareAndSet ( count , count + _NUM ) ) return _BOOL ; } }
private boolean tryIncrement ( AtomicInteger counter , int max ) { while ( _BOOL ) { int count = counter . get ( ) ; if ( count >= max && max != _NUM ) return _BOOL ; if ( counter . compareAndSet ( count , count + _NUM ) ) return _BOOL ; } }
public List < Order > fetchOrders ( int startIndex ) { try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } return fetchOrders ( startIndex , _NUM ) ; }
public List < Order > fetchOrders ( int startIndex ) { try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } return fetchOrders ( startIndex , _NUM ) ; }
public static boolean matchUserStatus ( String id , User user ) { if ( id . equals ( STRING ) ) { if ( user . isModerator ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isSubscriber ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . hasTurbo ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isAdmin ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isBroadcaster ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isStaff ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isBot ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isGlobalMod ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isAdmin ( ) || user . isBroadcaster ( ) || user . isGlobalMod ( ) || user . isModerator ( ) || user . isStaff ( ) ) { return _BOOL ; } } return _BOOL ; }
public static boolean matchUserStatus ( String id , User user ) { if ( id . equals ( STRING ) ) { if ( user . isModerator ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isSubscriber ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . hasTurbo ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isAdmin ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isBroadcaster ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isStaff ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isBot ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isGlobalMod ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isAdmin ( ) || user . isBroadcaster ( ) || user . isGlobalMod ( ) || user . isModerator ( ) || user . isStaff ( ) ) { return _BOOL ; } } return _BOOL ; }
public static boolean matchUserStatus ( String id , User user ) { if ( id . equals ( STRING ) ) { if ( user . isModerator ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isSubscriber ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . hasTurbo ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isAdmin ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isBroadcaster ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isStaff ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isBot ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isGlobalMod ( ) ) { return _BOOL ; } } else if ( id . equals ( STRING ) ) { if ( user . isAdmin ( ) || user . isBroadcaster ( ) || user . isGlobalMod ( ) || user . isModerator ( ) || user . isStaff ( ) ) { return _BOOL ; } } return _BOOL ; }
@ Override public void addBatch ( String sql ) throws SQLException { try { debugCodeCall ( STRING , sql ) ; checkClosed ( ) ; sql = JdbcConnection . translateSQL ( sql , escapeProcessing ) ; if ( batchCommands == null ) { batchCommands = New . arrayList ( ) ; } batchCommands . add ( sql ) ; } catch ( Exception e ) { throw logAndConvert ( e ) ; } }
public boolean hasDimensionOrFilter ( String key ) { return dimensions . indexOf ( new BaseDimensionalObject ( key ) ) != - _NUM || filters . indexOf ( new BaseDimensionalObject ( key ) ) != - _NUM ; }
public EnumeratedDistribution ( final List < Pair < T , Double > > pmf ) throws MathIllegalArgumentException { singletons = new ArrayList < > ( pmf . size ( ) ) ; final double [ ] probs = new double [ pmf . size ( ) ] ; for ( int i = _NUM ; i < pmf . size ( ) ; i ++ ) { final Pair < T , Double > sample = pmf . get ( i ) ; singletons . add ( sample . getKey ( ) ) ; final double p = sample . getValue ( ) ; probs [ i ] = p ; } probabilities = checkAndNormalize ( probs ) ; cumulativeProbabilities = new double [ probabilities . length ] ; double sum = _NUM ; for ( int i = _NUM ; i < probabilities . length ; i ++ ) { sum += probabilities [ i ] ; cumulativeProbabilities [ i ] = sum ; } }
public EnumeratedDistribution ( final List < Pair < T , Double > > pmf ) throws MathIllegalArgumentException { singletons = new ArrayList < > ( pmf . size ( ) ) ; final double [ ] probs = new double [ pmf . size ( ) ] ; for ( int i = _NUM ; i < pmf . size ( ) ; i ++ ) { final Pair < T , Double > sample = pmf . get ( i ) ; singletons . add ( sample . getKey ( ) ) ; final double p = sample . getValue ( ) ; probs [ i ] = p ; } probabilities = checkAndNormalize ( probs ) ; cumulativeProbabilities = new double [ probabilities . length ] ; double sum = _NUM ; for ( int i = _NUM ; i < probabilities . length ; i ++ ) { sum += probabilities [ i ] ; cumulativeProbabilities [ i ] = sum ; } }
public EnumeratedDistribution ( final List < Pair < T , Double > > pmf ) throws MathIllegalArgumentException { singletons = new ArrayList < > ( pmf . size ( ) ) ; final double [ ] probs = new double [ pmf . size ( ) ] ; for ( int i = _NUM ; i < pmf . size ( ) ; i ++ ) { final Pair < T , Double > sample = pmf . get ( i ) ; singletons . add ( sample . getKey ( ) ) ; final double p = sample . getValue ( ) ; probs [ i ] = p ; } probabilities = checkAndNormalize ( probs ) ; cumulativeProbabilities = new double [ probabilities . length ] ; double sum = _NUM ; for ( int i = _NUM ; i < probabilities . length ; i ++ ) { sum += probabilities [ i ] ; cumulativeProbabilities [ i ] = sum ; } }
public CTagFilterTree ( final ITagManager tagManager ) { super ( new CFilterTreeModel ( tagManager . getRootTag ( ) ) ) ; m_tagManager = tagManager ; setDigIn ( _BOOL ) ; final DefaultTreeCellRenderer renderer = new DefaultTreeCellRenderer ( ) ; renderer . setOpenIcon ( ICON_CONTAINER_TAG ) ; renderer . setClosedIcon ( ICON_CONTAINER_TAG ) ; renderer . setLeafIcon ( ICON_TAG ) ; setCellRenderer ( renderer ) ; setRootVisible ( _BOOL ) ; TreeHelpers . expandAll ( this , _BOOL ) ; tagManager . addListener ( m_tagManagerListener ) ; }
private void calculateSunRotation ( float _offset , Time time , int canvasWidth , int canvasHeight ) { sunPositionX = ( float ) ( canvasWidth / _NUM + ( canvasWidth / _NUM + _NUM ) * Math . cos ( ( _NUM * Math . PI * time . minute / _NUM ) + _offset - Math . PI / _NUM ) ) ; sunPositionY = ( float ) ( canvasHeight / _NUM + ( canvasWidth / _NUM + _NUM ) * Math . sin ( ( _NUM * Math . PI * time . minute / _NUM ) + _offset - Math . PI / _NUM ) ) ; }
private int findSplit ( ArrayDBIDs order , DBIDArrayIter it , DoubleDataStore lambda ) { int split ; if ( minclusters > _NUM ) { split = order . size ( ) > minclusters ? order . size ( ) - minclusters : _NUM ; it . seek ( split ) ; final double stopdist = lambda . doubleValue ( it ) ; for ( it . retract ( ) ; it . valid ( ) && stopdist <= lambda . doubleValue ( it ) ; it . retract ( ) ) { split -- ; } } else if ( ! Double . isNaN ( threshold ) ) { split = order . size ( ) ; it . seek ( split - _NUM ) ; while ( it . valid ( ) && threshold <= lambda . doubleValue ( it ) ) { split -- ; it . retract ( ) ; } } else { split = _NUM ; } return split ; }
private synchronized void rebuildJournal ( ) throws IOException { if ( journalWriter != null ) { journalWriter . close ( ) ; } Writer writer = new BufferedWriter ( new FileWriter ( journalFileTmp ) , IO_BUFFER_SIZE ) ; writer . write ( MAGIC ) ; writer . write ( STRING ) ; writer . write ( VERSION_1 ) ; writer . write ( STRING ) ; writer . write ( Integer . toString ( appVersion ) ) ; writer . write ( STRING ) ; writer . write ( Integer . toString ( valueCount ) ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; for ( Entry entry : lruEntries . values ( ) ) { if ( entry . currentEditor != null ) { writer . write ( DIRTY + STRING + entry . key + STRING ) ; } else { writer . write ( CLEAN + STRING + entry . key + entry . getLengths ( ) + STRING ) ; } } writer . close ( ) ; journalFileTmp . renameTo ( journalFile ) ; journalWriter = new BufferedWriter ( new FileWriter ( journalFile , _BOOL ) , IO_BUFFER_SIZE ) ; }
private synchronized void rebuildJournal ( ) throws IOException { if ( journalWriter != null ) { journalWriter . close ( ) ; } Writer writer = new BufferedWriter ( new FileWriter ( journalFileTmp ) , IO_BUFFER_SIZE ) ; writer . write ( MAGIC ) ; writer . write ( STRING ) ; writer . write ( VERSION_1 ) ; writer . write ( STRING ) ; writer . write ( Integer . toString ( appVersion ) ) ; writer . write ( STRING ) ; writer . write ( Integer . toString ( valueCount ) ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; for ( Entry entry : lruEntries . values ( ) ) { if ( entry . currentEditor != null ) { writer . write ( DIRTY + STRING + entry . key + STRING ) ; } else { writer . write ( CLEAN + STRING + entry . key + entry . getLengths ( ) + STRING ) ; } } writer . close ( ) ; journalFileTmp . renameTo ( journalFile ) ; journalWriter = new BufferedWriter ( new FileWriter ( journalFile , _BOOL ) , IO_BUFFER_SIZE ) ; }
private synchronized void rebuildJournal ( ) throws IOException { if ( journalWriter != null ) { journalWriter . close ( ) ; } Writer writer = new BufferedWriter ( new FileWriter ( journalFileTmp ) , IO_BUFFER_SIZE ) ; writer . write ( MAGIC ) ; writer . write ( STRING ) ; writer . write ( VERSION_1 ) ; writer . write ( STRING ) ; writer . write ( Integer . toString ( appVersion ) ) ; writer . write ( STRING ) ; writer . write ( Integer . toString ( valueCount ) ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; for ( Entry entry : lruEntries . values ( ) ) { if ( entry . currentEditor != null ) { writer . write ( DIRTY + STRING + entry . key + STRING ) ; } else { writer . write ( CLEAN + STRING + entry . key + entry . getLengths ( ) + STRING ) ; } } writer . close ( ) ; journalFileTmp . renameTo ( journalFile ) ; journalWriter = new BufferedWriter ( new FileWriter ( journalFile , _BOOL ) , IO_BUFFER_SIZE ) ; }
protected void revertSetting ( String key ) { KeyPanel kp = keyPanels . get ( key ) ; kp . setValue ( getSetting ( key ) ) ; }
private void checkPriority ( double priority ) { if ( Double . isNaN ( priority ) ) throw new IllegalArgumentException ( priority + STRING ) ; }
private void checkPriority ( double priority ) { if ( Double . isNaN ( priority ) ) throw new IllegalArgumentException ( priority + STRING ) ; }
@ Override public void emit ( AlertStreamEvent event ) { try { queue . put ( event ) ; } catch ( InterruptedException e ) { LOG . error ( e . getMessage ( ) , e ) ; } }
public Cache put ( String host , InetAddress [ ] addresses ) { int policy = getPolicy ( ) ; if ( policy == InetAddressCachePolicy . NEVER ) { return this ; } if ( policy != InetAddressCachePolicy . FOREVER ) { LinkedList < String > expired = new LinkedList < > ( ) ; long now = System . currentTimeMillis ( ) ; for ( String key : cache . keySet ( ) ) { CacheEntry entry = cache . get ( key ) ; if ( entry . expiration >= _NUM && entry . expiration < now ) { expired . add ( key ) ; } else { break ; } } for ( String key : expired ) { cache . remove ( key ) ; } } long expiration ; if ( policy == InetAddressCachePolicy . FOREVER ) { expiration = - _NUM ; } else { expiration = System . currentTimeMillis ( ) + ( policy * _NUM ) ; } CacheEntry entry = new CacheEntry ( addresses , expiration ) ; cache . put ( host , entry ) ; return this ; }
public static void main ( String [ ] args ) { java . net . URL input100 = ClassLoader . getSystemResource ( filename_data100 + STRING ) ; java . net . URL input200 = ClassLoader . getSystemResource ( filename_data200 + STRING ) ; log . info ( STRING ) ; sg100 = SpatialGrid . readFromFile ( input100 . getFile ( ) ) ; sg200 = SpatialGrid . readFromFile ( input200 . getFile ( ) ) ; try { out = new FileWriter ( outputFile ) ; out . write ( STRING ) ; out . write ( STRING ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } log . info ( STRING + filename_data200 + STRING ) ; testOneMethod ( Interpolation . BILINEAR , Double . NaN ) ; testOneMethod ( Interpolation . BICUBIC , Double . NaN ) ; for ( int e = _NUM ; e <= _NUM ; e ++ ) { testOneMethod ( Interpolation . INVERSE_DISTANCE_WEIGHTING , e ) ; } try { out . write ( STRING ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } log . info ( STRING ) ; }
public static void main ( String [ ] args ) { java . net . URL input100 = ClassLoader . getSystemResource ( filename_data100 + STRING ) ; java . net . URL input200 = ClassLoader . getSystemResource ( filename_data200 + STRING ) ; log . info ( STRING ) ; sg100 = SpatialGrid . readFromFile ( input100 . getFile ( ) ) ; sg200 = SpatialGrid . readFromFile ( input200 . getFile ( ) ) ; try { out = new FileWriter ( outputFile ) ; out . write ( STRING ) ; out . write ( STRING ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } log . info ( STRING + filename_data200 + STRING ) ; testOneMethod ( Interpolation . BILINEAR , Double . NaN ) ; testOneMethod ( Interpolation . BICUBIC , Double . NaN ) ; for ( int e = _NUM ; e <= _NUM ; e ++ ) { testOneMethod ( Interpolation . INVERSE_DISTANCE_WEIGHTING , e ) ; } try { out . write ( STRING ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } log . info ( STRING ) ; }
public static void main ( String [ ] args ) { java . net . URL input100 = ClassLoader . getSystemResource ( filename_data100 + STRING ) ; java . net . URL input200 = ClassLoader . getSystemResource ( filename_data200 + STRING ) ; log . info ( STRING ) ; sg100 = SpatialGrid . readFromFile ( input100 . getFile ( ) ) ; sg200 = SpatialGrid . readFromFile ( input200 . getFile ( ) ) ; try { out = new FileWriter ( outputFile ) ; out . write ( STRING ) ; out . write ( STRING ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } log . info ( STRING + filename_data200 + STRING ) ; testOneMethod ( Interpolation . BILINEAR , Double . NaN ) ; testOneMethod ( Interpolation . BICUBIC , Double . NaN ) ; for ( int e = _NUM ; e <= _NUM ; e ++ ) { testOneMethod ( Interpolation . INVERSE_DISTANCE_WEIGHTING , e ) ; } try { out . write ( STRING ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } log . info ( STRING ) ; }
public Range < C > until ( C to ) { Objects . requireNonNull ( to ) ; this . to = to ; toIncluded = _BOOL ; return this ; }
public Range < C > until ( C to ) { Objects . requireNonNull ( to ) ; this . to = to ; toIncluded = _BOOL ; return this ; }
public Range < C > until ( C to ) { Objects . requireNonNull ( to ) ; this . to = to ; toIncluded = _BOOL ; return this ; }
public void add ( Test test ) { tests . add ( test ) ; }
private int calculate8BitChecksum ( String infoString ) { int len = infoString . length ( ) ; if ( ( ( len + _NUM ) / _NUM ) != ( len / _NUM ) ) { return - _NUM ; } int calculatedChecksum = _NUM ; for ( int i = _NUM ; i < len ; i += _NUM ) { calculatedChecksum += Integer . parseInt ( infoString . substring ( i , i + _NUM ) , _NUM ) ; } return ( _NUM & ( _NUM - ( calculatedChecksum & _NUM ) ) ) ; }
private int calculate8BitChecksum ( String infoString ) { int len = infoString . length ( ) ; if ( ( ( len + _NUM ) / _NUM ) != ( len / _NUM ) ) { return - _NUM ; } int calculatedChecksum = _NUM ; for ( int i = _NUM ; i < len ; i += _NUM ) { calculatedChecksum += Integer . parseInt ( infoString . substring ( i , i + _NUM ) , _NUM ) ; } return ( _NUM & ( _NUM - ( calculatedChecksum & _NUM ) ) ) ; }
private int calculate8BitChecksum ( String infoString ) { int len = infoString . length ( ) ; if ( ( ( len + _NUM ) / _NUM ) != ( len / _NUM ) ) { return - _NUM ; } int calculatedChecksum = _NUM ; for ( int i = _NUM ; i < len ; i += _NUM ) { calculatedChecksum += Integer . parseInt ( infoString . substring ( i , i + _NUM ) , _NUM ) ; } return ( _NUM & ( _NUM - ( calculatedChecksum & _NUM ) ) ) ; }
private int calculate8BitChecksum ( String infoString ) { int len = infoString . length ( ) ; if ( ( ( len + _NUM ) / _NUM ) != ( len / _NUM ) ) { return - _NUM ; } int calculatedChecksum = _NUM ; for ( int i = _NUM ; i < len ; i += _NUM ) { calculatedChecksum += Integer . parseInt ( infoString . substring ( i , i + _NUM ) , _NUM ) ; } return ( _NUM & ( _NUM - ( calculatedChecksum & _NUM ) ) ) ; }
private int calculate8BitChecksum ( String infoString ) { int len = infoString . length ( ) ; if ( ( ( len + _NUM ) / _NUM ) != ( len / _NUM ) ) { return - _NUM ; } int calculatedChecksum = _NUM ; for ( int i = _NUM ; i < len ; i += _NUM ) { calculatedChecksum += Integer . parseInt ( infoString . substring ( i , i + _NUM ) , _NUM ) ; } return ( _NUM & ( _NUM - ( calculatedChecksum & _NUM ) ) ) ; }
private int calculate8BitChecksum ( String infoString ) { int len = infoString . length ( ) ; if ( ( ( len + _NUM ) / _NUM ) != ( len / _NUM ) ) { return - _NUM ; } int calculatedChecksum = _NUM ; for ( int i = _NUM ; i < len ; i += _NUM ) { calculatedChecksum += Integer . parseInt ( infoString . substring ( i , i + _NUM ) , _NUM ) ; } return ( _NUM & ( _NUM - ( calculatedChecksum & _NUM ) ) ) ; }
private int calculate8BitChecksum ( String infoString ) { int len = infoString . length ( ) ; if ( ( ( len + _NUM ) / _NUM ) != ( len / _NUM ) ) { return - _NUM ; } int calculatedChecksum = _NUM ; for ( int i = _NUM ; i < len ; i += _NUM ) { calculatedChecksum += Integer . parseInt ( infoString . substring ( i , i + _NUM ) , _NUM ) ; } return ( _NUM & ( _NUM - ( calculatedChecksum & _NUM ) ) ) ; }
private int calculate8BitChecksum ( String infoString ) { int len = infoString . length ( ) ; if ( ( ( len + _NUM ) / _NUM ) != ( len / _NUM ) ) { return - _NUM ; } int calculatedChecksum = _NUM ; for ( int i = _NUM ; i < len ; i += _NUM ) { calculatedChecksum += Integer . parseInt ( infoString . substring ( i , i + _NUM ) , _NUM ) ; } return ( _NUM & ( _NUM - ( calculatedChecksum & _NUM ) ) ) ; }
private int calculate8BitChecksum ( String infoString ) { int len = infoString . length ( ) ; if ( ( ( len + _NUM ) / _NUM ) != ( len / _NUM ) ) { return - _NUM ; } int calculatedChecksum = _NUM ; for ( int i = _NUM ; i < len ; i += _NUM ) { calculatedChecksum += Integer . parseInt ( infoString . substring ( i , i + _NUM ) , _NUM ) ; } return ( _NUM & ( _NUM - ( calculatedChecksum & _NUM ) ) ) ; }
private int calculate8BitChecksum ( String infoString ) { int len = infoString . length ( ) ; if ( ( ( len + _NUM ) / _NUM ) != ( len / _NUM ) ) { return - _NUM ; } int calculatedChecksum = _NUM ; for ( int i = _NUM ; i < len ; i += _NUM ) { calculatedChecksum += Integer . parseInt ( infoString . substring ( i , i + _NUM ) , _NUM ) ; } return ( _NUM & ( _NUM - ( calculatedChecksum & _NUM ) ) ) ; }
private int calculate8BitChecksum ( String infoString ) { int len = infoString . length ( ) ; if ( ( ( len + _NUM ) / _NUM ) != ( len / _NUM ) ) { return - _NUM ; } int calculatedChecksum = _NUM ; for ( int i = _NUM ; i < len ; i += _NUM ) { calculatedChecksum += Integer . parseInt ( infoString . substring ( i , i + _NUM ) , _NUM ) ; } return ( _NUM & ( _NUM - ( calculatedChecksum & _NUM ) ) ) ; }
private int calculate8BitChecksum ( String infoString ) { int len = infoString . length ( ) ; if ( ( ( len + _NUM ) / _NUM ) != ( len / _NUM ) ) { return - _NUM ; } int calculatedChecksum = _NUM ; for ( int i = _NUM ; i < len ; i += _NUM ) { calculatedChecksum += Integer . parseInt ( infoString . substring ( i , i + _NUM ) , _NUM ) ; } return ( _NUM & ( _NUM - ( calculatedChecksum & _NUM ) ) ) ; }
private void addNotificationCategorySeparator ( JPanel panel ) { JSeparator jsep = new JSeparator ( SwingConstants . HORIZONTAL ) ; jsep . setMaximumSize ( new Dimension ( Short . MAX_VALUE , _NUM ) ) ; panel . add ( jsep ) ; }
public static List seriesNameListFromDataArray ( Object [ ] [ ] data ) { int seriesCount = data . length ; List seriesNameList = new java . util . ArrayList ( seriesCount ) ; for ( int i = _NUM ; i < seriesCount ; i ++ ) { seriesNameList . add ( STRING + ( i + _NUM ) ) ; } return seriesNameList ; }
public static String removeStaticAttributeFlag ( String attributeName ) { if ( isStaticAttribute ( attributeName ) ) { return attributeName . substring ( STATIC_QUOTE . length ( ) , attributeName . length ( ) - STATIC_QUOTE . length ( ) ) ; } else { return attributeName ; } }
protected int hash ( Object o ) { int h = o == null ? _NUM : o . hashCode ( ) ; h += ( h << _NUM ) ^ _NUM ; h ^= ( h > > > _NUM ) ; h += ( h << _NUM ) ; h ^= ( h > > > _NUM ) ; h += ( h << _NUM ) + ( h << _NUM ) ; return h ^ ( h > > > _NUM ) ; }
public static String stringToBase64 ( final String data ) { return Base64 . encodeBase64String ( ConversionUtils . stringToArray ( data ) ) ; }
public static String stringToBase64 ( final String data ) { return Base64 . encodeBase64String ( ConversionUtils . stringToArray ( data ) ) ; }
public void buildNetwork ( ) { Neuron firstNeuron = new Neuron ( network , DEFAULT_NEURON_TYPE ) ; List < Neuron > currentLayer = new ArrayList < Neuron > ( ) ; firstNeuron . setPosition ( initialPosition ) ; currentLayer . add ( firstNeuron ) ; int numNeuronsLastLayer = ( int ) Math . pow ( numBrachesPerNeuron , numLayers ) ; double totalSpace = numNeuronsLastLayer * horizontalSpacing ; for ( int layerIndex = _NUM ; layerIndex <= numLayers ; layerIndex ++ ) { List < Neuron > tempList = new ArrayList < Neuron > ( ) ; double layerSpacing = totalSpace / ( int ) Math . pow ( numBrachesPerNeuron , layerIndex ) ; double branchWidth = layerSpacing * ( numBrachesPerNeuron - _NUM ) ; for ( Neuron baseNeuron : currentLayer ) { network . addNeuron ( baseNeuron ) ; double initialXOffset = branchWidth / _NUM ; for ( int j = _NUM ; j < numBrachesPerNeuron ; j ++ ) { Neuron targetNeuron = new Neuron ( network , new LinearRule ( ) ) ; targetNeuron . setLocation ( baseNeuron . getX ( ) - initialXOffset + ( j * layerSpacing ) , initialPosition . y - ( layerIndex * verticalSpacing ) ) ; tempList . add ( targetNeuron ) ; network . addNeuron ( targetNeuron ) ; targetNeuron . setUpdatePriority ( layerIndex ) ; Synapse synapse = new Synapse ( network , baseNeuron , targetNeuron , new StaticSynapseRule ( ) ) ; network . addSynapse ( synapse ) ; } } currentLayer = tempList ; } }
void startScrollingInstance ( ) { if ( log . isLoggable ( PlatformLogger . Level . FINER ) ) { log . finer ( STRING + this ) ; } scroll ( ) ; i_scroller . setScrollbar ( this ) ; i_scroller . start ( ) ; }
void startScrollingInstance ( ) { if ( log . isLoggable ( PlatformLogger . Level . FINER ) ) { log . finer ( STRING + this ) ; } scroll ( ) ; i_scroller . setScrollbar ( this ) ; i_scroller . start ( ) ; }
void startScrollingInstance ( ) { if ( log . isLoggable ( PlatformLogger . Level . FINER ) ) { log . finer ( STRING + this ) ; } scroll ( ) ; i_scroller . setScrollbar ( this ) ; i_scroller . start ( ) ; }
public void resetDuration ( ) { start = System . currentTimeMillis ( ) ; }
public ExtensionUserManagement ( ) { initialize ( ) ; }
private void startupProcessor ( ) { Processor processor = processorRef . get ( ) ; if ( processor == null ) { processor = new Processor ( ) ; if ( processorRef . compareAndSet ( null , processor ) ) { executor . execute ( new NamePreservingRunnable ( processor , threadName ) ) ; } } wakeup ( ) ; }
private void startupProcessor ( ) { Processor processor = processorRef . get ( ) ; if ( processor == null ) { processor = new Processor ( ) ; if ( processorRef . compareAndSet ( null , processor ) ) { executor . execute ( new NamePreservingRunnable ( processor , threadName ) ) ; } } wakeup ( ) ; }
private void startupProcessor ( ) { Processor processor = processorRef . get ( ) ; if ( processor == null ) { processor = new Processor ( ) ; if ( processorRef . compareAndSet ( null , processor ) ) { executor . execute ( new NamePreservingRunnable ( processor , threadName ) ) ; } } wakeup ( ) ; }
private void startupProcessor ( ) { Processor processor = processorRef . get ( ) ; if ( processor == null ) { processor = new Processor ( ) ; if ( processorRef . compareAndSet ( null , processor ) ) { executor . execute ( new NamePreservingRunnable ( processor , threadName ) ) ; } } wakeup ( ) ; }
private void startupProcessor ( ) { Processor processor = processorRef . get ( ) ; if ( processor == null ) { processor = new Processor ( ) ; if ( processorRef . compareAndSet ( null , processor ) ) { executor . execute ( new NamePreservingRunnable ( processor , threadName ) ) ; } } wakeup ( ) ; }
protected static Boolean lock ( String serviceName , Object name ) { DistributedLockService service = DistributedLockService . getServiceNamed ( serviceName ) ; boolean locked = service . lock ( name , _NUM , - _NUM ) ; return Boolean . valueOf ( locked ) ; }
private boolean isContinuationLine ( final String line ) { return line . charAt ( _NUM ) == STRING || line . charAt ( _NUM ) == STRING ; }
private boolean isContinuationLine ( final String line ) { return line . charAt ( _NUM ) == STRING || line . charAt ( _NUM ) == STRING ; }
private boolean isContinuationLine ( final String line ) { return line . charAt ( _NUM ) == STRING || line . charAt ( _NUM ) == STRING ; }
private boolean isContinuationLine ( final String line ) { return line . charAt ( _NUM ) == STRING || line . charAt ( _NUM ) == STRING ; }
private ByteBuffer writeHeaderToBuffer ( int padding , int size ) throws IOException { compression = _BOOL ; ByteBuffer headerBuffer = ByteBuffer . allocate ( TAG_HEADER_LENGTH ) ; headerBuffer . put ( TAG_ID ) ; headerBuffer . put ( getMajorVersion ( ) ) ; headerBuffer . put ( getRevision ( ) ) ; byte flags = ( byte ) _NUM ; if ( unsynchronization ) { flags |= ( byte ) MASK_V22_UNSYNCHRONIZATION ; } if ( compression ) { flags |= ( byte ) MASK_V22_COMPRESSION ; } headerBuffer . put ( flags ) ; headerBuffer . put ( ID3SyncSafeInteger . valueToBuffer ( padding + size ) ) ; headerBuffer . flip ( ) ; return headerBuffer ; }
public Map < String , List < String > > toMultimap ( boolean response ) { Map < String , List < String > > result = new TreeMap < String , List < String > > ( FIELD_NAME_COMPARATOR ) ; for ( int i = _NUM ; i < namesAndValues . size ( ) ; i += _NUM ) { String fieldName = namesAndValues . get ( i ) ; String value = namesAndValues . get ( i + _NUM ) ; List < String > allValues = new ArrayList < String > ( ) ; List < String > otherValues = result . get ( fieldName ) ; if ( otherValues != null ) { allValues . addAll ( otherValues ) ; } allValues . add ( value ) ; result . put ( fieldName , Collections . unmodifiableList ( allValues ) ) ; } if ( response && statusLine != null ) { result . put ( null , Collections . unmodifiableList ( Collections . singletonList ( statusLine ) ) ) ; } else if ( requestLine != null ) { result . put ( null , Collections . unmodifiableList ( Collections . singletonList ( requestLine ) ) ) ; } return Collections . unmodifiableMap ( result ) ; }
public Map < String , List < String > > toMultimap ( boolean response ) { Map < String , List < String > > result = new TreeMap < String , List < String > > ( FIELD_NAME_COMPARATOR ) ; for ( int i = _NUM ; i < namesAndValues . size ( ) ; i += _NUM ) { String fieldName = namesAndValues . get ( i ) ; String value = namesAndValues . get ( i + _NUM ) ; List < String > allValues = new ArrayList < String > ( ) ; List < String > otherValues = result . get ( fieldName ) ; if ( otherValues != null ) { allValues . addAll ( otherValues ) ; } allValues . add ( value ) ; result . put ( fieldName , Collections . unmodifiableList ( allValues ) ) ; } if ( response && statusLine != null ) { result . put ( null , Collections . unmodifiableList ( Collections . singletonList ( statusLine ) ) ) ; } else if ( requestLine != null ) { result . put ( null , Collections . unmodifiableList ( Collections . singletonList ( requestLine ) ) ) ; } return Collections . unmodifiableMap ( result ) ; }
public Map < String , List < String > > toMultimap ( boolean response ) { Map < String , List < String > > result = new TreeMap < String , List < String > > ( FIELD_NAME_COMPARATOR ) ; for ( int i = _NUM ; i < namesAndValues . size ( ) ; i += _NUM ) { String fieldName = namesAndValues . get ( i ) ; String value = namesAndValues . get ( i + _NUM ) ; List < String > allValues = new ArrayList < String > ( ) ; List < String > otherValues = result . get ( fieldName ) ; if ( otherValues != null ) { allValues . addAll ( otherValues ) ; } allValues . add ( value ) ; result . put ( fieldName , Collections . unmodifiableList ( allValues ) ) ; } if ( response && statusLine != null ) { result . put ( null , Collections . unmodifiableList ( Collections . singletonList ( statusLine ) ) ) ; } else if ( requestLine != null ) { result . put ( null , Collections . unmodifiableList ( Collections . singletonList ( requestLine ) ) ) ; } return Collections . unmodifiableMap ( result ) ; }
public Map < String , List < String > > toMultimap ( boolean response ) { Map < String , List < String > > result = new TreeMap < String , List < String > > ( FIELD_NAME_COMPARATOR ) ; for ( int i = _NUM ; i < namesAndValues . size ( ) ; i += _NUM ) { String fieldName = namesAndValues . get ( i ) ; String value = namesAndValues . get ( i + _NUM ) ; List < String > allValues = new ArrayList < String > ( ) ; List < String > otherValues = result . get ( fieldName ) ; if ( otherValues != null ) { allValues . addAll ( otherValues ) ; } allValues . add ( value ) ; result . put ( fieldName , Collections . unmodifiableList ( allValues ) ) ; } if ( response && statusLine != null ) { result . put ( null , Collections . unmodifiableList ( Collections . singletonList ( statusLine ) ) ) ; } else if ( requestLine != null ) { result . put ( null , Collections . unmodifiableList ( Collections . singletonList ( requestLine ) ) ) ; } return Collections . unmodifiableMap ( result ) ; }
public static boolean isProtected ( int mod ) { return Modifier . isProtected ( mod ) ; }
public static boolean isProtected ( int mod ) { return Modifier . isProtected ( mod ) ; }
void acknowledge ( ) throws CommitFailedException { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . fine ( STRING + m_sessionID ) ; } unackedMessages . clear ( ) ; if ( this . m_isQueue && ! isAutoAck ( ) ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STRING + _tx ) ; } commitLocalTransaction ( ) ; } }
void acknowledge ( ) throws CommitFailedException { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . fine ( STRING + m_sessionID ) ; } unackedMessages . clear ( ) ; if ( this . m_isQueue && ! isAutoAck ( ) ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STRING + _tx ) ; } commitLocalTransaction ( ) ; } }
void acknowledge ( ) throws CommitFailedException { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . fine ( STRING + m_sessionID ) ; } unackedMessages . clear ( ) ; if ( this . m_isQueue && ! isAutoAck ( ) ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STRING + _tx ) ; } commitLocalTransaction ( ) ; } }
static boolean isViablePhoneNumber ( String number ) { if ( number . length ( ) < MIN_LENGTH_FOR_NSN ) { return _BOOL ; } Matcher m = VALID_PHONE_NUMBER_PATTERN . matcher ( number ) ; return m . matches ( ) ; }
static boolean isViablePhoneNumber ( String number ) { if ( number . length ( ) < MIN_LENGTH_FOR_NSN ) { return _BOOL ; } Matcher m = VALID_PHONE_NUMBER_PATTERN . matcher ( number ) ; return m . matches ( ) ; }
static boolean isViablePhoneNumber ( String number ) { if ( number . length ( ) < MIN_LENGTH_FOR_NSN ) { return _BOOL ; } Matcher m = VALID_PHONE_NUMBER_PATTERN . matcher ( number ) ; return m . matches ( ) ; }
static boolean isViablePhoneNumber ( String number ) { if ( number . length ( ) < MIN_LENGTH_FOR_NSN ) { return _BOOL ; } Matcher m = VALID_PHONE_NUMBER_PATTERN . matcher ( number ) ; return m . matches ( ) ; }
static boolean isViablePhoneNumber ( String number ) { if ( number . length ( ) < MIN_LENGTH_FOR_NSN ) { return _BOOL ; } Matcher m = VALID_PHONE_NUMBER_PATTERN . matcher ( number ) ; return m . matches ( ) ; }
static boolean isViablePhoneNumber ( String number ) { if ( number . length ( ) < MIN_LENGTH_FOR_NSN ) { return _BOOL ; } Matcher m = VALID_PHONE_NUMBER_PATTERN . matcher ( number ) ; return m . matches ( ) ; }
public void darkerColor ( int factor ) { int color = getColor ( ) ; int r = color > > _NUM & _NUM ; int g = color > > _NUM & _NUM ; int b = color & _NUM ; r = Math . max ( _NUM , r - factor ) ; g = Math . max ( _NUM , g - factor ) ; b = Math . max ( _NUM , b - factor ) ; setColor ( ( ( r << _NUM ) & _NUM ) | ( ( g << _NUM ) & _NUM ) | ( b & _NUM ) ) ; }
protected void configureReader ( XMLReader reader , DefaultHandler handler ) throws DocumentException { SAXHelper . setParserProperty ( reader , SAX_LEXICALHANDLER , handler ) ; SAXHelper . setParserProperty ( reader , SAX_LEXICAL_HANDLER , handler ) ; if ( includeInternalDTDDeclarations || includeExternalDTDDeclarations ) { SAXHelper . setParserProperty ( reader , SAX_DECL_HANDLER , handler ) ; } SAXHelper . setParserFeature ( reader , SAX_NAMESPACES , _BOOL ) ; SAXHelper . setParserFeature ( reader , SAX_NAMESPACE_PREFIXES , _BOOL ) ; SAXHelper . setParserFeature ( reader , SAX_STRING_INTERNING , isStringInternEnabled ( ) ) ; SAXHelper . setParserFeature ( reader , STRING , _BOOL ) ; try { reader . setFeature ( STRING , isValidating ( ) ) ; if ( errorHandler != null ) { reader . setErrorHandler ( errorHandler ) ; } else { reader . setErrorHandler ( handler ) ; } } catch ( Exception e ) { if ( isValidating ( ) ) { throw new DocumentException ( STRING + STRING + reader , e ) ; } } }
public void writeDataToFile ( byte [ ] keyArray , byte [ ] [ ] dataArray , int entryCount , byte [ ] startKey , byte [ ] endKey ) throws CarbonDataWriterException { if ( this . isNewFileCreationRequired ) { updateBlockletFileChannel ( ) ; } int totalMsrArraySize = _NUM ; int currentMsrLenght = _NUM ; int [ ] msrLength = new int [ this . measureCount ] ; for ( int i = _NUM ; i < dataArray . length ; i ++ ) { currentMsrLenght = dataArray [ i ] . length ; totalMsrArraySize += currentMsrLenght ; msrLength [ i ] = currentMsrLenght ; } byte [ ] writableDataArray = new byte [ totalMsrArraySize ] ; int startPosition = _NUM ; for ( int i = _NUM ; i < dataArray . length ; i ++ ) { System . arraycopy ( dataArray [ i ] , _NUM , writableDataArray , startPosition , dataArray [ i ] . length ) ; startPosition += msrLength [ i ] ; } writeDataToFile ( keyArray , writableDataArray , msrLength , entryCount , startKey , endKey ) ; }
public void writeDataToFile ( byte [ ] keyArray , byte [ ] [ ] dataArray , int entryCount , byte [ ] startKey , byte [ ] endKey ) throws CarbonDataWriterException { if ( this . isNewFileCreationRequired ) { updateBlockletFileChannel ( ) ; } int totalMsrArraySize = _NUM ; int currentMsrLenght = _NUM ; int [ ] msrLength = new int [ this . measureCount ] ; for ( int i = _NUM ; i < dataArray . length ; i ++ ) { currentMsrLenght = dataArray [ i ] . length ; totalMsrArraySize += currentMsrLenght ; msrLength [ i ] = currentMsrLenght ; } byte [ ] writableDataArray = new byte [ totalMsrArraySize ] ; int startPosition = _NUM ; for ( int i = _NUM ; i < dataArray . length ; i ++ ) { System . arraycopy ( dataArray [ i ] , _NUM , writableDataArray , startPosition , dataArray [ i ] . length ) ; startPosition += msrLength [ i ] ; } writeDataToFile ( keyArray , writableDataArray , msrLength , entryCount , startKey , endKey ) ; }
public boolean readMessage ( InputStream is , OutboxAmp outbox ) throws IOException { InH3 hIn = _hIn ; if ( is . available ( ) < _NUM ) { return _BOOL ; } try { return readMessage ( hIn , outbox ) ; } finally { } }
public boolean readMessage ( InputStream is , OutboxAmp outbox ) throws IOException { InH3 hIn = _hIn ; if ( is . available ( ) < _NUM ) { return _BOOL ; } try { return readMessage ( hIn , outbox ) ; } finally { } }
public boolean readMessage ( InputStream is , OutboxAmp outbox ) throws IOException { InH3 hIn = _hIn ; if ( is . available ( ) < _NUM ) { return _BOOL ; } try { return readMessage ( hIn , outbox ) ; } finally { } }
public static < T > T first ( List < T > l ) { return l . get ( _NUM ) ; }
public boolean writeCharacteristic ( BluetoothGattCharacteristic characteristic , String value ) { return writeCharacteristic ( characteristic , value . getBytes ( ) ) ; }
private boolean hasSearchableColumns ( ) { boolean retValue = _BOOL ; m_tableName = MQuery . getZoomTableName ( m_columnName ) ; m_keyColumnName = MQuery . getZoomColumnName ( m_columnName ) ; if ( m_columnName . equals ( STRING ) || m_columnName . equals ( STRING ) || m_columnName . equals ( STRING ) || m_columnName . equals ( STRING ) || m_columnName . equals ( STRING ) || m_columnName . equals ( STRING ) || m_columnName . equals ( STRING ) || m_columnName . equals ( STRING ) ) { retValue = _BOOL ; } else { String query = STRING + STRING + STRING + STRING + STRING + STRING + STRING ; PreparedStatement pstmt = null ; ResultSet rs = null ; try { pstmt = DB . prepareStatement ( query , null ) ; pstmt . setString ( _NUM , m_keyColumnName ) ; rs = pstmt . executeQuery ( ) ; if ( rs . next ( ) ) { retValue = _BOOL ; } } catch ( SQLException ex ) { log . log ( Level . SEVERE , query , ex ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } } return retValue ; }
private boolean hasSearchableColumns ( ) { boolean retValue = _BOOL ; m_tableName = MQuery . getZoomTableName ( m_columnName ) ; m_keyColumnName = MQuery . getZoomColumnName ( m_columnName ) ; if ( m_columnName . equals ( STRING ) || m_columnName . equals ( STRING ) || m_columnName . equals ( STRING ) || m_columnName . equals ( STRING ) || m_columnName . equals ( STRING ) || m_columnName . equals ( STRING ) || m_columnName . equals ( STRING ) || m_columnName . equals ( STRING ) ) { retValue = _BOOL ; } else { String query = STRING + STRING + STRING + STRING + STRING + STRING + STRING ; PreparedStatement pstmt = null ; ResultSet rs = null ; try { pstmt = DB . prepareStatement ( query , null ) ; pstmt . setString ( _NUM , m_keyColumnName ) ; rs = pstmt . executeQuery ( ) ; if ( rs . next ( ) ) { retValue = _BOOL ; } } catch ( SQLException ex ) { log . log ( Level . SEVERE , query , ex ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } } return retValue ; }
public void send ( Set recipients , boolean multicast ) throws InterruptedException , ReplyException { final boolean isDebugEnabled = logger . isDebugEnabled ( ) ; if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; recipients = new HashSet ( recipients ) ; DistributedMember me = originDm . getDistributionManagerId ( ) ; if ( recipients . contains ( me ) ) { recipients . remove ( me ) ; } if ( isDebugEnabled ) { logger . debug ( STRING , recipients ) ; } rp = new ReplyProcessor21 ( originDm , recipients ) ; processorId = rp . getProcessorId ( ) ; setRecipients ( recipients ) ; setMulticast ( multicast ) ; Set failures = originDm . putOutgoing ( this ) ; if ( failures != null && failures . size ( ) > _NUM ) { for ( Iterator i = failures . iterator ( ) ; i . hasNext ( ) ; ) { InternalDistributedMember mbr = ( InternalDistributedMember ) i . next ( ) ; if ( isDebugEnabled ) { logger . debug ( STRING , mbr ) ; } } } rp . waitForReplies ( ) ; }
@ Override public boolean remove ( Object o ) { if ( o == null || size == _NUM ) { return _BOOL ; } for ( int i = _NUM ; i < size ; i ++ ) { if ( o . equals ( elements [ i ] ) ) { removeAt ( i ) ; return _BOOL ; } } return _BOOL ; }
public CIDR ( String cidrOrIP ) { String [ ] parts = cidrOrIP . split ( STRING ) ; if ( ( parts . length < _NUM ) || ( parts . length > _NUM ) ) throw new IllegalArgumentException ( cidrOrIP + STRING ) ; bits = ( _NUM == parts . length ) ? _NUM : Short . parseShort ( parts [ _NUM ] ) ; if ( ( bits < _NUM ) || ( bits > _NUM ) ) throw new IllegalArgumentException ( cidrOrIP + STRING + bits + STRING ) ; this . firstIP = toIP ( parts [ _NUM ] ) ; }
public void start ( ) ;
private void hideMainLayoutAndToast ( String text ) { mMainLayout . setVisibility ( View . GONE ) ; mProgressTextView . setVisibility ( View . VISIBLE ) ; mProgressTextView . setText ( text ) ; }
public void addAnimation ( AnimationObject o ) { AnimationObject [ ] n = new AnimationObject [ animations . length + _NUM ] ; System . arraycopy ( animations , _NUM , n , _NUM , animations . length ) ; n [ animations . length ] = o ; animations = n ; }
public void addAnimation ( AnimationObject o ) { AnimationObject [ ] n = new AnimationObject [ animations . length + _NUM ] ; System . arraycopy ( animations , _NUM , n , _NUM , animations . length ) ; n [ animations . length ] = o ; animations = n ; }
public String readString ( ) throws IOException { return dis . readUTF ( ) ; }
public OuterJoinQualifier add ( String propertyLeft , String propertyRight ) { additionalProperties . add ( new PropertyValueExpressionPair ( new PropertyValueExpression ( propertyLeft ) , new PropertyValueExpression ( propertyRight ) ) ) ; return this ; }
public static String encodeQuery ( String url ) { Uri uri = Uri . parse ( url ) ; try { String query = uri . getQuery ( ) ; String encodedQuery = query != null ? URLEncoder . encode ( query , STRING ) : null ; URI tmp = new URI ( uri . getScheme ( ) , uri . getAuthority ( ) , uri . getPath ( ) , null , uri . getFragment ( ) ) ; return tmp + ( encodedQuery != null && encodedQuery . length ( ) > _NUM ? STRING + encodedQuery : STRING ) ; } catch ( UnsupportedEncodingException ignore ) { } catch ( URISyntaxException ignore ) { } return uri . toString ( ) ; }
public void constrain ( int minLeft , int minTop , int maxLeft , int maxTop ) { left = Math . max ( minLeft , Math . min ( left , maxLeft ) ) ; top = Math . max ( minTop , Math . min ( top , maxTop ) ) ; }
private void addPath ( final String path ) { if ( ! myPaths . contains ( path ) ) { myPaths . add ( path ) ; } }
private static void unregisterMbeansFromPropsFile ( MBeanServer mBeanServer ) throws Exception { JamonPropertiesLoader loader = new JamonPropertiesLoader ( ) ; List < String > jamonJmxBeanProperties = loader . getMxBeans ( ) ; Iterator < String > iter = jamonJmxBeanProperties . iterator ( ) ; while ( iter . hasNext ( ) ) { String beanInfo = iter . next ( ) ; MonitorMXBean mXbean = MonitorMXBeanFactory . create ( beanInfo ) ; mBeanServer . unregisterMBean ( MonitorMXBeanFactory . getObjectName ( mXbean ) ) ; MonitorMXBean mXbeanDelta = MonitorMXBeanFactory . createDelta ( beanInfo ) ; mBeanServer . unregisterMBean ( MonitorMXBeanFactory . getDeltaObjectName ( mXbeanDelta ) ) ; } }
private static void unregisterMbeansFromPropsFile ( MBeanServer mBeanServer ) throws Exception { JamonPropertiesLoader loader = new JamonPropertiesLoader ( ) ; List < String > jamonJmxBeanProperties = loader . getMxBeans ( ) ; Iterator < String > iter = jamonJmxBeanProperties . iterator ( ) ; while ( iter . hasNext ( ) ) { String beanInfo = iter . next ( ) ; MonitorMXBean mXbean = MonitorMXBeanFactory . create ( beanInfo ) ; mBeanServer . unregisterMBean ( MonitorMXBeanFactory . getObjectName ( mXbean ) ) ; MonitorMXBean mXbeanDelta = MonitorMXBeanFactory . createDelta ( beanInfo ) ; mBeanServer . unregisterMBean ( MonitorMXBeanFactory . getDeltaObjectName ( mXbeanDelta ) ) ; } }
private static void unregisterMbeansFromPropsFile ( MBeanServer mBeanServer ) throws Exception { JamonPropertiesLoader loader = new JamonPropertiesLoader ( ) ; List < String > jamonJmxBeanProperties = loader . getMxBeans ( ) ; Iterator < String > iter = jamonJmxBeanProperties . iterator ( ) ; while ( iter . hasNext ( ) ) { String beanInfo = iter . next ( ) ; MonitorMXBean mXbean = MonitorMXBeanFactory . create ( beanInfo ) ; mBeanServer . unregisterMBean ( MonitorMXBeanFactory . getObjectName ( mXbean ) ) ; MonitorMXBean mXbeanDelta = MonitorMXBeanFactory . createDelta ( beanInfo ) ; mBeanServer . unregisterMBean ( MonitorMXBeanFactory . getDeltaObjectName ( mXbeanDelta ) ) ; } }
private static void unregisterMbeansFromPropsFile ( MBeanServer mBeanServer ) throws Exception { JamonPropertiesLoader loader = new JamonPropertiesLoader ( ) ; List < String > jamonJmxBeanProperties = loader . getMxBeans ( ) ; Iterator < String > iter = jamonJmxBeanProperties . iterator ( ) ; while ( iter . hasNext ( ) ) { String beanInfo = iter . next ( ) ; MonitorMXBean mXbean = MonitorMXBeanFactory . create ( beanInfo ) ; mBeanServer . unregisterMBean ( MonitorMXBeanFactory . getObjectName ( mXbean ) ) ; MonitorMXBean mXbeanDelta = MonitorMXBeanFactory . createDelta ( beanInfo ) ; mBeanServer . unregisterMBean ( MonitorMXBeanFactory . getDeltaObjectName ( mXbeanDelta ) ) ; } }
private static void unregisterMbeansFromPropsFile ( MBeanServer mBeanServer ) throws Exception { JamonPropertiesLoader loader = new JamonPropertiesLoader ( ) ; List < String > jamonJmxBeanProperties = loader . getMxBeans ( ) ; Iterator < String > iter = jamonJmxBeanProperties . iterator ( ) ; while ( iter . hasNext ( ) ) { String beanInfo = iter . next ( ) ; MonitorMXBean mXbean = MonitorMXBeanFactory . create ( beanInfo ) ; mBeanServer . unregisterMBean ( MonitorMXBeanFactory . getObjectName ( mXbean ) ) ; MonitorMXBean mXbeanDelta = MonitorMXBeanFactory . createDelta ( beanInfo ) ; mBeanServer . unregisterMBean ( MonitorMXBeanFactory . getDeltaObjectName ( mXbeanDelta ) ) ; } }
private static void unregisterMbeansFromPropsFile ( MBeanServer mBeanServer ) throws Exception { JamonPropertiesLoader loader = new JamonPropertiesLoader ( ) ; List < String > jamonJmxBeanProperties = loader . getMxBeans ( ) ; Iterator < String > iter = jamonJmxBeanProperties . iterator ( ) ; while ( iter . hasNext ( ) ) { String beanInfo = iter . next ( ) ; MonitorMXBean mXbean = MonitorMXBeanFactory . create ( beanInfo ) ; mBeanServer . unregisterMBean ( MonitorMXBeanFactory . getObjectName ( mXbean ) ) ; MonitorMXBean mXbeanDelta = MonitorMXBeanFactory . createDelta ( beanInfo ) ; mBeanServer . unregisterMBean ( MonitorMXBeanFactory . getDeltaObjectName ( mXbeanDelta ) ) ; } }
public FPSSurfaceView removeChildAt ( int location ) { DisplayBase removed = mDisplayList . remove ( location ) ; if ( removed != null ) { removed . disable ( ) ; } return this ; }
protected void run ( long elapsedTime ) { Visualization vis = getVisualization ( ) ; if ( vis != null ) { synchronized ( vis ) { run ( getPace ( elapsedTime ) ) ; } } else { s_logger . info ( STRING ) ; run ( getPace ( elapsedTime ) ) ; } }
public void open ( ) throws IOException { writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( filename ) ) ) ; writer . println ( columnNames ) ; }
public void open ( ) throws IOException { writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( filename ) ) ) ; writer . println ( columnNames ) ; }
protected void drawZeroDomainBaseline ( Graphics2D g2 , Rectangle2D area ) { if ( isDomainZeroBaselineVisible ( ) ) { XYItemRenderer r = getRenderer ( ) ; if ( r instanceof AbstractXYItemRenderer ) { AbstractXYItemRenderer renderer = ( AbstractXYItemRenderer ) r ; renderer . drawDomainLine ( g2 , this , getDomainAxis ( ) , area , _NUM , this . domainZeroBaselinePaint , this . domainZeroBaselineStroke ) ; } } }
protected void drawZeroDomainBaseline ( Graphics2D g2 , Rectangle2D area ) { if ( isDomainZeroBaselineVisible ( ) ) { XYItemRenderer r = getRenderer ( ) ; if ( r instanceof AbstractXYItemRenderer ) { AbstractXYItemRenderer renderer = ( AbstractXYItemRenderer ) r ; renderer . drawDomainLine ( g2 , this , getDomainAxis ( ) , area , _NUM , this . domainZeroBaselinePaint , this . domainZeroBaselineStroke ) ; } } }
protected void drawZeroDomainBaseline ( Graphics2D g2 , Rectangle2D area ) { if ( isDomainZeroBaselineVisible ( ) ) { XYItemRenderer r = getRenderer ( ) ; if ( r instanceof AbstractXYItemRenderer ) { AbstractXYItemRenderer renderer = ( AbstractXYItemRenderer ) r ; renderer . drawDomainLine ( g2 , this , getDomainAxis ( ) , area , _NUM , this . domainZeroBaselinePaint , this . domainZeroBaselineStroke ) ; } } }
public static double probOf ( int k , double lambda ) { return Math . exp ( ( k * Math . log ( lambda ) ) - lambda - Functions . logFactorial ( k ) ) ; }
public static JavaRDD < List < Writable > > normalize ( Schema schema , JavaRDD < List < Writable > > data ) { return normalize ( schema , data , _NUM , _NUM , Collections . < String > emptyList ( ) ) ; }
@ Deprecated public static JSONObject parseJson ( String response ) throws JSONException , FacebookError { if ( response . equals ( STRING ) ) { throw new FacebookError ( STRING ) ; } if ( response . equals ( STRING ) ) { response = STRING ; } JSONObject json = new JSONObject ( response ) ; if ( json . has ( STRING ) ) { JSONObject error = json . getJSONObject ( STRING ) ; throw new FacebookError ( error . getString ( STRING ) , error . getString ( STRING ) , _NUM ) ; } if ( json . has ( STRING ) && json . has ( STRING ) ) { throw new FacebookError ( json . getString ( STRING ) , STRING , Integer . parseInt ( json . getString ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new FacebookError ( STRING , STRING , Integer . parseInt ( json . getString ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new FacebookError ( json . getString ( STRING ) ) ; } if ( json . has ( STRING ) ) { throw new FacebookError ( json . getString ( STRING ) ) ; } return json ; }
@ Deprecated public static JSONObject parseJson ( String response ) throws JSONException , FacebookError { if ( response . equals ( STRING ) ) { throw new FacebookError ( STRING ) ; } if ( response . equals ( STRING ) ) { response = STRING ; } JSONObject json = new JSONObject ( response ) ; if ( json . has ( STRING ) ) { JSONObject error = json . getJSONObject ( STRING ) ; throw new FacebookError ( error . getString ( STRING ) , error . getString ( STRING ) , _NUM ) ; } if ( json . has ( STRING ) && json . has ( STRING ) ) { throw new FacebookError ( json . getString ( STRING ) , STRING , Integer . parseInt ( json . getString ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new FacebookError ( STRING , STRING , Integer . parseInt ( json . getString ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new FacebookError ( json . getString ( STRING ) ) ; } if ( json . has ( STRING ) ) { throw new FacebookError ( json . getString ( STRING ) ) ; } return json ; }
@ Deprecated public static JSONObject parseJson ( String response ) throws JSONException , FacebookError { if ( response . equals ( STRING ) ) { throw new FacebookError ( STRING ) ; } if ( response . equals ( STRING ) ) { response = STRING ; } JSONObject json = new JSONObject ( response ) ; if ( json . has ( STRING ) ) { JSONObject error = json . getJSONObject ( STRING ) ; throw new FacebookError ( error . getString ( STRING ) , error . getString ( STRING ) , _NUM ) ; } if ( json . has ( STRING ) && json . has ( STRING ) ) { throw new FacebookError ( json . getString ( STRING ) , STRING , Integer . parseInt ( json . getString ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new FacebookError ( STRING , STRING , Integer . parseInt ( json . getString ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new FacebookError ( json . getString ( STRING ) ) ; } if ( json . has ( STRING ) ) { throw new FacebookError ( json . getString ( STRING ) ) ; } return json ; }
@ Deprecated public static JSONObject parseJson ( String response ) throws JSONException , FacebookError { if ( response . equals ( STRING ) ) { throw new FacebookError ( STRING ) ; } if ( response . equals ( STRING ) ) { response = STRING ; } JSONObject json = new JSONObject ( response ) ; if ( json . has ( STRING ) ) { JSONObject error = json . getJSONObject ( STRING ) ; throw new FacebookError ( error . getString ( STRING ) , error . getString ( STRING ) , _NUM ) ; } if ( json . has ( STRING ) && json . has ( STRING ) ) { throw new FacebookError ( json . getString ( STRING ) , STRING , Integer . parseInt ( json . getString ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new FacebookError ( STRING , STRING , Integer . parseInt ( json . getString ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new FacebookError ( json . getString ( STRING ) ) ; } if ( json . has ( STRING ) ) { throw new FacebookError ( json . getString ( STRING ) ) ; } return json ; }
@ Deprecated public static JSONObject parseJson ( String response ) throws JSONException , FacebookError { if ( response . equals ( STRING ) ) { throw new FacebookError ( STRING ) ; } if ( response . equals ( STRING ) ) { response = STRING ; } JSONObject json = new JSONObject ( response ) ; if ( json . has ( STRING ) ) { JSONObject error = json . getJSONObject ( STRING ) ; throw new FacebookError ( error . getString ( STRING ) , error . getString ( STRING ) , _NUM ) ; } if ( json . has ( STRING ) && json . has ( STRING ) ) { throw new FacebookError ( json . getString ( STRING ) , STRING , Integer . parseInt ( json . getString ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new FacebookError ( STRING , STRING , Integer . parseInt ( json . getString ( STRING ) ) ) ; } if ( json . has ( STRING ) ) { throw new FacebookError ( json . getString ( STRING ) ) ; } if ( json . has ( STRING ) ) { throw new FacebookError ( json . getString ( STRING ) ) ; } return json ; }
public List < T > toList ( ) { @ SuppressWarnings ( STRING ) T [ ] copiedElements = ( T [ ] ) new Object [ numElements ] ; System . arraycopy ( elements , _NUM , copiedElements , _NUM , numElements ) ; return Arrays . asList ( copiedElements ) ; }
public List < T > toList ( ) { @ SuppressWarnings ( STRING ) T [ ] copiedElements = ( T [ ] ) new Object [ numElements ] ; System . arraycopy ( elements , _NUM , copiedElements , _NUM , numElements ) ; return Arrays . asList ( copiedElements ) ; }
protected void onShowConversations ( @ NonNull List < C > conversations ) { if ( DEBUG ) { Log . d ( TAG , STRING + conversations . size ( ) + STRING ) ; } mView . showConversations ( new ArrayList < > ( conversations ) ) ; }
protected void onShowConversations ( @ NonNull List < C > conversations ) { if ( DEBUG ) { Log . d ( TAG , STRING + conversations . size ( ) + STRING ) ; } mView . showConversations ( new ArrayList < > ( conversations ) ) ; }
protected void onShowConversations ( @ NonNull List < C > conversations ) { if ( DEBUG ) { Log . d ( TAG , STRING + conversations . size ( ) + STRING ) ; } mView . showConversations ( new ArrayList < > ( conversations ) ) ; }
private void validateCollectionAttribute ( CollectionAttribute collection , Set < String > allCollections ) { if ( collection == null || allCollections == null ) { return ; } for ( RestMethod restMethod : collection . getMethods ( ) ) { if ( allCollections . contains ( restMethod . getRestFullMethodName ( ) ) ) { aspect . warning ( SimpleLocation . TOPLEVEL , STRING + STRING + STRING + STRING , collection . getFullName ( ) , restMethod . getRestMethodName ( ) ) ; } } }
private void validateCollectionAttribute ( CollectionAttribute collection , Set < String > allCollections ) { if ( collection == null || allCollections == null ) { return ; } for ( RestMethod restMethod : collection . getMethods ( ) ) { if ( allCollections . contains ( restMethod . getRestFullMethodName ( ) ) ) { aspect . warning ( SimpleLocation . TOPLEVEL , STRING + STRING + STRING + STRING , collection . getFullName ( ) , restMethod . getRestMethodName ( ) ) ; } } }
private void validateCollectionAttribute ( CollectionAttribute collection , Set < String > allCollections ) { if ( collection == null || allCollections == null ) { return ; } for ( RestMethod restMethod : collection . getMethods ( ) ) { if ( allCollections . contains ( restMethod . getRestFullMethodName ( ) ) ) { aspect . warning ( SimpleLocation . TOPLEVEL , STRING + STRING + STRING + STRING , collection . getFullName ( ) , restMethod . getRestMethodName ( ) ) ; } } }
public void execute ( String sql ) throws DatabaseException { Statement stmt = null ; try { stmt = connection . createStatement ( ) ; stmt . execute ( sql ) ; } catch ( SQLException e ) { throw ( new DatabaseException ( e ) ) ; } finally { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException e ) { } } } }
public void execute ( String sql ) throws DatabaseException { Statement stmt = null ; try { stmt = connection . createStatement ( ) ; stmt . execute ( sql ) ; } catch ( SQLException e ) { throw ( new DatabaseException ( e ) ) ; } finally { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException e ) { } } } }
public void execute ( String sql ) throws DatabaseException { Statement stmt = null ; try { stmt = connection . createStatement ( ) ; stmt . execute ( sql ) ; } catch ( SQLException e ) { throw ( new DatabaseException ( e ) ) ; } finally { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException e ) { } } } }
public void execute ( String sql ) throws DatabaseException { Statement stmt = null ; try { stmt = connection . createStatement ( ) ; stmt . execute ( sql ) ; } catch ( SQLException e ) { throw ( new DatabaseException ( e ) ) ; } finally { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException e ) { } } } }
private boolean isContained ( TreeNode parent , String [ ] values , int lvl ) { if ( lvl == values . length ) { return _BOOL ; } else if ( lvl > values . length ) { return _BOOL ; } else { Vector < TreeNode > kids = parent . children ; int index = search ( kids , values [ lvl ] ) ; if ( index != - _NUM ) { TreeNode newParent = kids . elementAt ( index ) ; return isContained ( newParent , values , lvl + _NUM ) ; } else { return _BOOL ; } } }
private boolean isContained ( TreeNode parent , String [ ] values , int lvl ) { if ( lvl == values . length ) { return _BOOL ; } else if ( lvl > values . length ) { return _BOOL ; } else { Vector < TreeNode > kids = parent . children ; int index = search ( kids , values [ lvl ] ) ; if ( index != - _NUM ) { TreeNode newParent = kids . elementAt ( index ) ; return isContained ( newParent , values , lvl + _NUM ) ; } else { return _BOOL ; } } }
public static void write ( OMLine line , Link link , LinkProperties props ) throws IOException { switch ( line . getRenderType ( ) ) { case OMLine . RENDERTYPE_LATLON : double [ ] ll = line . getLL ( ) ; LinkLine . write ( ( float ) ll [ _NUM ] , ( float ) ll [ _NUM ] , ( float ) ll [ _NUM ] , ( float ) ll [ _NUM ] , line . getLineType ( ) , line . getNumSegs ( ) , props , link . dos ) ; break ; case OMLine . RENDERTYPE_XY : int [ ] pts = line . getPts ( ) ; LinkLine . write ( pts [ _NUM ] , pts [ _NUM ] , pts [ _NUM ] , pts [ _NUM ] , props , link . dos ) ; break ; case OMLine . RENDERTYPE_OFFSET : ll = line . getLL ( ) ; pts = line . getPts ( ) ; LinkLine . write ( ( float ) ll [ _NUM ] , ( float ) ll [ _NUM ] , pts [ _NUM ] , pts [ _NUM ] , pts [ _NUM ] , pts [ _NUM ] , props , link . dos ) ; break ; default : Debug . error ( STRING ) ; } }
public static Date parse ( String src , String ptrn ) throws java . text . ParseException { java . text . DateFormat format = new java . text . SimpleDateFormat ( ptrn ) ; return format . parse ( src ) ; }
static float logFunc ( float x ) { return _NUM - ( float ) ( Math . pow ( LogBase , reverse ( x ) ) ) / ( LogBase ) ; }
static float logFunc ( float x ) { return _NUM - ( float ) ( Math . pow ( LogBase , reverse ( x ) ) ) / ( LogBase ) ; }
public TaggedInputStream ( InputStream proxy ) { super ( proxy ) ; }
public void put ( ReplDBMSEvent event ) throws InterruptedException , ReplicatorException { queue . put ( event ) ; transactionCount ++ ; if ( logger . isDebugEnabled ( ) ) { if ( transactionCount % _NUM == _NUM ) logger . debug ( STRING + transactionCount + STRING + queue . size ( ) ) ; } }
public boolean equals ( Object o ) { if ( o instanceof DSAMERole ) { DSAMERole role = ( DSAMERole ) o ; return ( subjectRoles . equals ( role . subjectRoles ) ) ; } return ( _BOOL ) ; }
protected < T extends ASTNode > T moveNode ( T oldNode , ASTRewrite rewrite ) { T movedNode ; if ( ASTNodes . isExistingNode ( oldNode ) ) movedNode = ASTNodes . createMoveTarget ( rewrite , oldNode ) ; else movedNode = ASTNodes . copySubtree ( rewrite . getAST ( ) , oldNode ) ; return movedNode ; }
protected < T extends ASTNode > T moveNode ( T oldNode , ASTRewrite rewrite ) { T movedNode ; if ( ASTNodes . isExistingNode ( oldNode ) ) movedNode = ASTNodes . createMoveTarget ( rewrite , oldNode ) ; else movedNode = ASTNodes . copySubtree ( rewrite . getAST ( ) , oldNode ) ; return movedNode ; }
protected < T extends ASTNode > T moveNode ( T oldNode , ASTRewrite rewrite ) { T movedNode ; if ( ASTNodes . isExistingNode ( oldNode ) ) movedNode = ASTNodes . createMoveTarget ( rewrite , oldNode ) ; else movedNode = ASTNodes . copySubtree ( rewrite . getAST ( ) , oldNode ) ; return movedNode ; }
protected < T extends ASTNode > T moveNode ( T oldNode , ASTRewrite rewrite ) { T movedNode ; if ( ASTNodes . isExistingNode ( oldNode ) ) movedNode = ASTNodes . createMoveTarget ( rewrite , oldNode ) ; else movedNode = ASTNodes . copySubtree ( rewrite . getAST ( ) , oldNode ) ; return movedNode ; }
protected < T extends ASTNode > T moveNode ( T oldNode , ASTRewrite rewrite ) { T movedNode ; if ( ASTNodes . isExistingNode ( oldNode ) ) movedNode = ASTNodes . createMoveTarget ( rewrite , oldNode ) ; else movedNode = ASTNodes . copySubtree ( rewrite . getAST ( ) , oldNode ) ; return movedNode ; }
protected < T extends ASTNode > T moveNode ( T oldNode , ASTRewrite rewrite ) { T movedNode ; if ( ASTNodes . isExistingNode ( oldNode ) ) movedNode = ASTNodes . createMoveTarget ( rewrite , oldNode ) ; else movedNode = ASTNodes . copySubtree ( rewrite . getAST ( ) , oldNode ) ; return movedNode ; }
protected < T extends ASTNode > T moveNode ( T oldNode , ASTRewrite rewrite ) { T movedNode ; if ( ASTNodes . isExistingNode ( oldNode ) ) movedNode = ASTNodes . createMoveTarget ( rewrite , oldNode ) ; else movedNode = ASTNodes . copySubtree ( rewrite . getAST ( ) , oldNode ) ; return movedNode ; }
protected < T extends ASTNode > T moveNode ( T oldNode , ASTRewrite rewrite ) { T movedNode ; if ( ASTNodes . isExistingNode ( oldNode ) ) movedNode = ASTNodes . createMoveTarget ( rewrite , oldNode ) ; else movedNode = ASTNodes . copySubtree ( rewrite . getAST ( ) , oldNode ) ; return movedNode ; }
protected < T extends ASTNode > T moveNode ( T oldNode , ASTRewrite rewrite ) { T movedNode ; if ( ASTNodes . isExistingNode ( oldNode ) ) movedNode = ASTNodes . createMoveTarget ( rewrite , oldNode ) ; else movedNode = ASTNodes . copySubtree ( rewrite . getAST ( ) , oldNode ) ; return movedNode ; }
private void createCompositionArea ( ) { synchronized ( compositionAreaLock ) { compositionArea = new CompositionArea ( ) ; if ( compositionAreaOwner != null ) { compositionArea . setHandlerInfo ( compositionAreaOwner , inputMethodContext ) ; } Component client = clientComponent . get ( ) ; if ( client != null ) { InputMethodRequests req = client . getInputMethodRequests ( ) ; if ( req != null && inputMethodContext . useBelowTheSpotInput ( ) ) { setCompositionAreaUndecorated ( _BOOL ) ; } } } }
public static RequestLog copy ( ) { RequestLog current = RLOG . get ( ) ; return new RequestLog ( current ) ; }