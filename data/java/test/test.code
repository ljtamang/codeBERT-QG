public I Index find Index ( String name ) { return find Index ( name , BOOL ) ; }
public I Index find Index ( String name ) { return find Index ( name , BOOL ) ; }
private float y ( Touch State s ) { final float curr To Tan = ( float ) Math . sqrt ( ( s . distance * s . distance ) - ( m Scaled Touch Slop * m Scaled Touch Slop ) ) ; return curr To Tan * ( m Scaled Touch Slop / s . distance ) ; }
public Map Entry Info Key ( Object value , Object key , Reference Queue < Object > queue ) { super ( value , queue ) ; hash Code = hash Code ^ key . hash Code ( ) ; key = key ; }
public Map Entry Info Key ( Object value , Object key , Reference Queue < Object > queue ) { super ( value , queue ) ; hash Code = hash Code ^ key . hash Code ( ) ; key = key ; }
public Map Entry Info Key ( Object value , Object key , Reference Queue < Object > queue ) { super ( value , queue ) ; hash Code = hash Code ^ key . hash Code ( ) ; key = key ; }
public Map Entry Info Key ( Object value , Object key , Reference Queue < Object > queue ) { super ( value , queue ) ; hash Code = hash Code ^ key . hash Code ( ) ; key = key ; }
private static void create Key Store ( ) throws Key Store Exception , IO Exception { if ( s Key Store != null ) { return ; } try { s Key Store = Key Store . get Instance ( get Keystore Type ( ) ) ; synchronized ( Key Store Manager . class ) { s Key Store . load ( null , KEYSTORE PASSWORD . to Char Array ( ) ) ; } save Key Store To File ( s Key Store ) ; } catch ( No Such Algorithm Exception e ) { throw new Key Store Exception ( STRING , e ) ; } catch ( Certificate Exception e ) { throw new Key Store Exception ( STRING , e ) ; } }
private static void create Key Store ( ) throws Key Store Exception , IO Exception { if ( s Key Store != null ) { return ; } try { s Key Store = Key Store . get Instance ( get Keystore Type ( ) ) ; synchronized ( Key Store Manager . class ) { s Key Store . load ( null , KEYSTORE PASSWORD . to Char Array ( ) ) ; } save Key Store To File ( s Key Store ) ; } catch ( No Such Algorithm Exception e ) { throw new Key Store Exception ( STRING , e ) ; } catch ( Certificate Exception e ) { throw new Key Store Exception ( STRING , e ) ; } }
public Julian Date add ( int units , int amount ) { Julian Date date = null ; synchronized ( gc ) { gc . set Time ( get Java Date ( ) ) ; gc . add ( units , amount ) ; date = new Julian Date ( gc . get Time ( ) ) ; } return date ; }
public Julian Date add ( int units , int amount ) { Julian Date date = null ; synchronized ( gc ) { gc . set Time ( get Java Date ( ) ) ; gc . add ( units , amount ) ; date = new Julian Date ( gc . get Time ( ) ) ; } return date ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public void updates ( String type , List < String > ids , Metacat Context metacat Context , Object Node node ) { if ( ids == null || ids . is Empty ( ) ) { return ; } try { RETRY ES PUBLISH . call ( null ) ; } catch ( Exception e ) { log . error ( String . format ( STRING , type , ids ) , e ) ; Counter Wrapper . increment Counter ( STRING ) ; log ( STRING , type , ids . to String ( ) , null , e . get Message ( ) , e , BOOL ) ; } }
public void updates ( String type , List < String > ids , Metacat Context metacat Context , Object Node node ) { if ( ids == null || ids . is Empty ( ) ) { return ; } try { RETRY ES PUBLISH . call ( null ) ; } catch ( Exception e ) { log . error ( String . format ( STRING , type , ids ) , e ) ; Counter Wrapper . increment Counter ( STRING ) ; log ( STRING , type , ids . to String ( ) , null , e . get Message ( ) , e , BOOL ) ; } }
public void updates ( String type , List < String > ids , Metacat Context metacat Context , Object Node node ) { if ( ids == null || ids . is Empty ( ) ) { return ; } try { RETRY ES PUBLISH . call ( null ) ; } catch ( Exception e ) { log . error ( String . format ( STRING , type , ids ) , e ) ; Counter Wrapper . increment Counter ( STRING ) ; log ( STRING , type , ids . to String ( ) , null , e . get Message ( ) , e , BOOL ) ; } }
protected boolean check To Skip Directory ( String name ) { if ( dir Suffix Avoids != null ) { for ( int i = NUM ; i < dir Suffix Avoids . length ; i ++ ) { if ( name . ends With ( dir Suffix Avoids [ i ] ) ) { return BOOL ; } } } if ( dir Suffix Limits != null ) { for ( int i = NUM ; i < dir Suffix Limits . length ; i ++ ) { if ( name . ends With ( dir Suffix Limits [ i ] ) ) { return BOOL ; } } return BOOL ; } return BOOL ; }
@ Override public Enter From Date To To Date Activity . Time Object add ( long time , int val ) { Calendar c = Calendar . get Instance ( ) ; c . set Time In Millis ( time ) ; c . add ( Calendar . MONTH , val ) ; return time Object From Calendar ( c ) ; }
@ Override public Enter From Date To To Date Activity . Time Object add ( long time , int val ) { Calendar c = Calendar . get Instance ( ) ; c . set Time In Millis ( time ) ; c . add ( Calendar . MONTH , val ) ; return time Object From Calendar ( c ) ; }
public void test create 01 ( ) throws Exception { final String namespace 2 = STRING + UUID . random UUID ( ) ; do Test Create ( namespace 2 ) ; }
public void test create 01 ( ) throws Exception { final String namespace 2 = STRING + UUID . random UUID ( ) ; do Test Create ( namespace 2 ) ; }
public void test create 01 ( ) throws Exception { final String namespace 2 = STRING + UUID . random UUID ( ) ; do Test Create ( namespace 2 ) ; }
public void test create 01 ( ) throws Exception { final String namespace 2 = STRING + UUID . random UUID ( ) ; do Test Create ( namespace 2 ) ; }
public void test create 01 ( ) throws Exception { final String namespace 2 = STRING + UUID . random UUID ( ) ; do Test Create ( namespace 2 ) ; }
public void test create 01 ( ) throws Exception { final String namespace 2 = STRING + UUID . random UUID ( ) ; do Test Create ( namespace 2 ) ; }
public void test create 01 ( ) throws Exception { final String namespace 2 = STRING + UUID . random UUID ( ) ; do Test Create ( namespace 2 ) ; }
public void test create 01 ( ) throws Exception { final String namespace 2 = STRING + UUID . random UUID ( ) ; do Test Create ( namespace 2 ) ; }
public void test create 01 ( ) throws Exception { final String namespace 2 = STRING + UUID . random UUID ( ) ; do Test Create ( namespace 2 ) ; }
public static String to String ( final Input Stream is ) throws IO Exception { final Buffered Reader br = new Buffered Reader ( new Input Stream Reader ( is ) ) ; final String Buffer content = new String Buffer ( ) ; String line = br . read Line ( ) ; if ( line != null ) { content . append ( line ) ; while ( ( line = br . read Line ( ) ) != null ) content . append ( STRING + line ) ; } br . close ( ) ; return content . to String ( ) ; }
public void add ( Protocol protocol ) { if ( protocol List != null ) { protocol List . add ( protocol ) ; protocol . init ( user Connection ) ; } else { throw new Null Pointer Exception ( STRING ) ; } }
public void add ( Protocol protocol ) { if ( protocol List != null ) { protocol List . add ( protocol ) ; protocol . init ( user Connection ) ; } else { throw new Null Pointer Exception ( STRING ) ; } }
public void add ( Protocol protocol ) { if ( protocol List != null ) { protocol List . add ( protocol ) ; protocol . init ( user Connection ) ; } else { throw new Null Pointer Exception ( STRING ) ; } }
public void add ( Protocol protocol ) { if ( protocol List != null ) { protocol List . add ( protocol ) ; protocol . init ( user Connection ) ; } else { throw new Null Pointer Exception ( STRING ) ; } }
private boolean is Number ( String string ) { String s = string . trim ( ) ; if ( s . length ( ) < NUM ) return BOOL ; double value = NUM ; try { value = Double . parse Double ( s ) ; } catch ( Number Format Exception e ) { return BOOL ; } return BOOL ; }
private boolean is Number ( String string ) { String s = string . trim ( ) ; if ( s . length ( ) < NUM ) return BOOL ; double value = NUM ; try { value = Double . parse Double ( s ) ; } catch ( Number Format Exception e ) { return BOOL ; } return BOOL ; }
private boolean is Number ( String string ) { String s = string . trim ( ) ; if ( s . length ( ) < NUM ) return BOOL ; double value = NUM ; try { value = Double . parse Double ( s ) ; } catch ( Number Format Exception e ) { return BOOL ; } return BOOL ; }
private void initialize Values ( ) { mn Size = Math . min ( get Measured Height ( ) , get Measured Width ( ) ) ; mn Ring Radius = ( int ) ( mn Size - mn Ring Width ) / NUM ; mn Inner Circle Radius = ( int ) ( mn Size - ( mn Ring Width * NUM ) ) / NUM ; mn View Center = mn Size / NUM ; mn Line Width = STATUS SYMBOL WIDTH PERCENT * mn Size ; }
private void initialize Values ( ) { mn Size = Math . min ( get Measured Height ( ) , get Measured Width ( ) ) ; mn Ring Radius = ( int ) ( mn Size - mn Ring Width ) / NUM ; mn Inner Circle Radius = ( int ) ( mn Size - ( mn Ring Width * NUM ) ) / NUM ; mn View Center = mn Size / NUM ; mn Line Width = STATUS SYMBOL WIDTH PERCENT * mn Size ; }
@ Visible For Testing public static boolean create Gradle Wrapper ( @ Not Null File project Dir Path , @ Not Null String gradle Version ) throws IO Exception { File project Wrapper Dir Path = new File ( project Dir Path , FD GRADLE WRAPPER ) ; if ( ! project Wrapper Dir Path . is Directory ( ) ) { File wrapper Src Dir Path = new File ( Template Manager . get Template Root Folder ( ) , FD GRADLE WRAPPER ) ; if ( ! wrapper Src Dir Path . exists ( ) ) { for ( File root : Template Manager . get Extra Template Root Folders ( ) ) { wrapper Src Dir Path = new File ( root , FD GRADLE WRAPPER ) ; if ( wrapper Src Dir Path . exists ( ) ) { break ; } else { wrapper Src Dir Path = null ; } } } if ( wrapper Src Dir Path == null ) { return BOOL ; } copy Dir Content ( wrapper Src Dir Path , project Dir Path ) ; } File wrapper Properties File = get Gradle Wrapper Properties File Path ( project Dir Path ) ; update Gradle Distribution Url ( gradle Version , wrapper Properties File ) ; return BOOL ; }
@ Visible For Testing public static boolean create Gradle Wrapper ( @ Not Null File project Dir Path , @ Not Null String gradle Version ) throws IO Exception { File project Wrapper Dir Path = new File ( project Dir Path , FD GRADLE WRAPPER ) ; if ( ! project Wrapper Dir Path . is Directory ( ) ) { File wrapper Src Dir Path = new File ( Template Manager . get Template Root Folder ( ) , FD GRADLE WRAPPER ) ; if ( ! wrapper Src Dir Path . exists ( ) ) { for ( File root : Template Manager . get Extra Template Root Folders ( ) ) { wrapper Src Dir Path = new File ( root , FD GRADLE WRAPPER ) ; if ( wrapper Src Dir Path . exists ( ) ) { break ; } else { wrapper Src Dir Path = null ; } } } if ( wrapper Src Dir Path == null ) { return BOOL ; } copy Dir Content ( wrapper Src Dir Path , project Dir Path ) ; } File wrapper Properties File = get Gradle Wrapper Properties File Path ( project Dir Path ) ; update Gradle Distribution Url ( gradle Version , wrapper Properties File ) ; return BOOL ; }
@ Visible For Testing public static boolean create Gradle Wrapper ( @ Not Null File project Dir Path , @ Not Null String gradle Version ) throws IO Exception { File project Wrapper Dir Path = new File ( project Dir Path , FD GRADLE WRAPPER ) ; if ( ! project Wrapper Dir Path . is Directory ( ) ) { File wrapper Src Dir Path = new File ( Template Manager . get Template Root Folder ( ) , FD GRADLE WRAPPER ) ; if ( ! wrapper Src Dir Path . exists ( ) ) { for ( File root : Template Manager . get Extra Template Root Folders ( ) ) { wrapper Src Dir Path = new File ( root , FD GRADLE WRAPPER ) ; if ( wrapper Src Dir Path . exists ( ) ) { break ; } else { wrapper Src Dir Path = null ; } } } if ( wrapper Src Dir Path == null ) { return BOOL ; } copy Dir Content ( wrapper Src Dir Path , project Dir Path ) ; } File wrapper Properties File = get Gradle Wrapper Properties File Path ( project Dir Path ) ; update Gradle Distribution Url ( gradle Version , wrapper Properties File ) ; return BOOL ; }
@ Visible For Testing public static boolean create Gradle Wrapper ( @ Not Null File project Dir Path , @ Not Null String gradle Version ) throws IO Exception { File project Wrapper Dir Path = new File ( project Dir Path , FD GRADLE WRAPPER ) ; if ( ! project Wrapper Dir Path . is Directory ( ) ) { File wrapper Src Dir Path = new File ( Template Manager . get Template Root Folder ( ) , FD GRADLE WRAPPER ) ; if ( ! wrapper Src Dir Path . exists ( ) ) { for ( File root : Template Manager . get Extra Template Root Folders ( ) ) { wrapper Src Dir Path = new File ( root , FD GRADLE WRAPPER ) ; if ( wrapper Src Dir Path . exists ( ) ) { break ; } else { wrapper Src Dir Path = null ; } } } if ( wrapper Src Dir Path == null ) { return BOOL ; } copy Dir Content ( wrapper Src Dir Path , project Dir Path ) ; } File wrapper Properties File = get Gradle Wrapper Properties File Path ( project Dir Path ) ; update Gradle Distribution Url ( gradle Version , wrapper Properties File ) ; return BOOL ; }
@ Override public boolean equals ( final Object o ) { if ( this == o ) return BOOL ; if ( ! ( o instanceof Header ) ) { return BOOL ; } return name . equals ( ( ( Header ) o ) . name ) ; }
@ Override public boolean equals ( final Object o ) { if ( this == o ) return BOOL ; if ( ! ( o instanceof Header ) ) { return BOOL ; } return name . equals ( ( ( Header ) o ) . name ) ; }
@ Override public boolean equals ( final Object o ) { if ( this == o ) return BOOL ; if ( ! ( o instanceof Header ) ) { return BOOL ; } return name . equals ( ( ( Header ) o ) . name ) ; }
public static void write Pem String To File ( File file , String pem Data To Write ) { try { File Utils . write ( file , pem Data To Write ) ; } catch ( IO Exception e ) { throw new Export Exception ( STRING + file . get Name ( ) , e ) ; } }
public Env Var Model ( Environment Manager Interface env Mgr ) { this . env Mgr = env Mgr ; if ( columns . is Empty ( ) ) { columns . add ( Localisation . get String ( Env Var Dlg . class , STRING ) ) ; columns . add ( Localisation . get String ( Env Var Dlg . class , STRING ) ) ; columns . add ( Localisation . get String ( Env Var Dlg . class , STRING ) ) ; } }
public Env Var Model ( Environment Manager Interface env Mgr ) { this . env Mgr = env Mgr ; if ( columns . is Empty ( ) ) { columns . add ( Localisation . get String ( Env Var Dlg . class , STRING ) ) ; columns . add ( Localisation . get String ( Env Var Dlg . class , STRING ) ) ; columns . add ( Localisation . get String ( Env Var Dlg . class , STRING ) ) ; } }
public Bit Vector ( Bit Vector s ) { bits = new int [ s . bits . length ] ; this . nbits = s . nbits ; System . arraycopy ( s . bits , NUM , this . bits , NUM , s . bits . length ) ; }
public Bit Vector ( Bit Vector s ) { bits = new int [ s . bits . length ] ; this . nbits = s . nbits ; System . arraycopy ( s . bits , NUM , this . bits , NUM , s . bits . length ) ; }
void write ( Image Output Stream ios , JPEG Image Writer writer ) throws IO Exception { write ( ios , null , writer ) ; }
void write ( Image Output Stream ios , JPEG Image Writer writer ) throws IO Exception { write ( ios , null , writer ) ; }
void write ( Image Output Stream ios , JPEG Image Writer writer ) throws IO Exception { write ( ios , null , writer ) ; }
@ Suppress Warnings ( STRING ) private Class validate Class ( Client Config cfg ) { Class clazz = null ; try { clazz = Class . for Name ( cfg . get Access Request Handler Classname ( ) ) ; } catch ( final Class Not Found Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } Object inst = null ; try { inst = Injector Holder . get Instance ( clazz ) ; } catch ( Configuration Exception | Provision Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } Access Request Handler handler = null ; try { handler = ( Access Request Handler ) inst ; } catch ( final Class Cast Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } return clazz ; }
@ Suppress Warnings ( STRING ) private Class validate Class ( Client Config cfg ) { Class clazz = null ; try { clazz = Class . for Name ( cfg . get Access Request Handler Classname ( ) ) ; } catch ( final Class Not Found Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } Object inst = null ; try { inst = Injector Holder . get Instance ( clazz ) ; } catch ( Configuration Exception | Provision Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } Access Request Handler handler = null ; try { handler = ( Access Request Handler ) inst ; } catch ( final Class Cast Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } return clazz ; }
@ Suppress Warnings ( STRING ) private Class validate Class ( Client Config cfg ) { Class clazz = null ; try { clazz = Class . for Name ( cfg . get Access Request Handler Classname ( ) ) ; } catch ( final Class Not Found Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } Object inst = null ; try { inst = Injector Holder . get Instance ( clazz ) ; } catch ( Configuration Exception | Provision Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } Access Request Handler handler = null ; try { handler = ( Access Request Handler ) inst ; } catch ( final Class Cast Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } return clazz ; }
@ Suppress Warnings ( STRING ) private Class validate Class ( Client Config cfg ) { Class clazz = null ; try { clazz = Class . for Name ( cfg . get Access Request Handler Classname ( ) ) ; } catch ( final Class Not Found Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } Object inst = null ; try { inst = Injector Holder . get Instance ( clazz ) ; } catch ( Configuration Exception | Provision Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } Access Request Handler handler = null ; try { handler = ( Access Request Handler ) inst ; } catch ( final Class Cast Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } return clazz ; }
void compute Min Max Scroll ( Array List < T > data , boolean launched With Alt Tab , boolean launched From Home ) { m Task Progress Map . clear ( ) ; if ( data . is Empty ( ) ) { m Min Scroll P = m Max Scroll P = NUM ; return ; } int task Height = m Task Rect . height ( ) ; float p At Bottom Of Stack Rect = screen Y To Curve Progress ( m Stack Visible Rect . bottom ) ; float p Within Affiliate Top = screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Within Affiliation Offset ) ; float scale = curve Progress To Scale ( p Within Affiliate Top ) ; int scale Y Offset = ( int ) ( ( ( NUM - scale ) * task Height ) / NUM ) ; p Within Affiliate Top = screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Within Affiliation Offset + scale Y Offset ) ; float p Within Affiliate Offset = p At Bottom Of Stack Rect - p Within Affiliate Top ; float p Between Affiliate Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Between Affiliation Offset ) ; float p Task Height Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - task Height ) ; float p Nav Bar Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - ( m Stack Visible Rect . bottom - m Stack Rect . bottom ) ) ; float p At Back Most Card Top = NUM ; float p At Front Most Card Top = p At Back Most Card Top ; int task Count = data . size ( ) ; for ( int i = NUM ; i < task Count ; i ++ ) { m Task Progress Map . put ( data . get ( i ) , p At Front Most Card Top ) ; if ( i < ( task Count - NUM ) ) { float p Peek = p Between Affiliate Offset ; p At Front Most Card Top += p Peek ; } } m Max Scroll P = p At Front Most Card Top - ( ( NUM - p Task Height Offset - p Nav Bar Offset ) ) ; m Min Scroll P = data . size ( ) == NUM ? Math . max ( m Max Scroll P , NUM ) : NUM ; if ( launched With Alt Tab && launched From Home ) { m Initial Scroll P = m Max Scroll P ; } else { m Initial Scroll P = p At Front Most Card Top - NUM ; } m Initial Scroll P = Math . min ( m Max Scroll P , Math . max ( NUM , m Initial Scroll P ) ) ; }
void compute Min Max Scroll ( Array List < T > data , boolean launched With Alt Tab , boolean launched From Home ) { m Task Progress Map . clear ( ) ; if ( data . is Empty ( ) ) { m Min Scroll P = m Max Scroll P = NUM ; return ; } int task Height = m Task Rect . height ( ) ; float p At Bottom Of Stack Rect = screen Y To Curve Progress ( m Stack Visible Rect . bottom ) ; float p Within Affiliate Top = screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Within Affiliation Offset ) ; float scale = curve Progress To Scale ( p Within Affiliate Top ) ; int scale Y Offset = ( int ) ( ( ( NUM - scale ) * task Height ) / NUM ) ; p Within Affiliate Top = screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Within Affiliation Offset + scale Y Offset ) ; float p Within Affiliate Offset = p At Bottom Of Stack Rect - p Within Affiliate Top ; float p Between Affiliate Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Between Affiliation Offset ) ; float p Task Height Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - task Height ) ; float p Nav Bar Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - ( m Stack Visible Rect . bottom - m Stack Rect . bottom ) ) ; float p At Back Most Card Top = NUM ; float p At Front Most Card Top = p At Back Most Card Top ; int task Count = data . size ( ) ; for ( int i = NUM ; i < task Count ; i ++ ) { m Task Progress Map . put ( data . get ( i ) , p At Front Most Card Top ) ; if ( i < ( task Count - NUM ) ) { float p Peek = p Between Affiliate Offset ; p At Front Most Card Top += p Peek ; } } m Max Scroll P = p At Front Most Card Top - ( ( NUM - p Task Height Offset - p Nav Bar Offset ) ) ; m Min Scroll P = data . size ( ) == NUM ? Math . max ( m Max Scroll P , NUM ) : NUM ; if ( launched With Alt Tab && launched From Home ) { m Initial Scroll P = m Max Scroll P ; } else { m Initial Scroll P = p At Front Most Card Top - NUM ; } m Initial Scroll P = Math . min ( m Max Scroll P , Math . max ( NUM , m Initial Scroll P ) ) ; }
void compute Min Max Scroll ( Array List < T > data , boolean launched With Alt Tab , boolean launched From Home ) { m Task Progress Map . clear ( ) ; if ( data . is Empty ( ) ) { m Min Scroll P = m Max Scroll P = NUM ; return ; } int task Height = m Task Rect . height ( ) ; float p At Bottom Of Stack Rect = screen Y To Curve Progress ( m Stack Visible Rect . bottom ) ; float p Within Affiliate Top = screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Within Affiliation Offset ) ; float scale = curve Progress To Scale ( p Within Affiliate Top ) ; int scale Y Offset = ( int ) ( ( ( NUM - scale ) * task Height ) / NUM ) ; p Within Affiliate Top = screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Within Affiliation Offset + scale Y Offset ) ; float p Within Affiliate Offset = p At Bottom Of Stack Rect - p Within Affiliate Top ; float p Between Affiliate Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Between Affiliation Offset ) ; float p Task Height Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - task Height ) ; float p Nav Bar Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - ( m Stack Visible Rect . bottom - m Stack Rect . bottom ) ) ; float p At Back Most Card Top = NUM ; float p At Front Most Card Top = p At Back Most Card Top ; int task Count = data . size ( ) ; for ( int i = NUM ; i < task Count ; i ++ ) { m Task Progress Map . put ( data . get ( i ) , p At Front Most Card Top ) ; if ( i < ( task Count - NUM ) ) { float p Peek = p Between Affiliate Offset ; p At Front Most Card Top += p Peek ; } } m Max Scroll P = p At Front Most Card Top - ( ( NUM - p Task Height Offset - p Nav Bar Offset ) ) ; m Min Scroll P = data . size ( ) == NUM ? Math . max ( m Max Scroll P , NUM ) : NUM ; if ( launched With Alt Tab && launched From Home ) { m Initial Scroll P = m Max Scroll P ; } else { m Initial Scroll P = p At Front Most Card Top - NUM ; } m Initial Scroll P = Math . min ( m Max Scroll P , Math . max ( NUM , m Initial Scroll P ) ) ; }
void compute Min Max Scroll ( Array List < T > data , boolean launched With Alt Tab , boolean launched From Home ) { m Task Progress Map . clear ( ) ; if ( data . is Empty ( ) ) { m Min Scroll P = m Max Scroll P = NUM ; return ; } int task Height = m Task Rect . height ( ) ; float p At Bottom Of Stack Rect = screen Y To Curve Progress ( m Stack Visible Rect . bottom ) ; float p Within Affiliate Top = screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Within Affiliation Offset ) ; float scale = curve Progress To Scale ( p Within Affiliate Top ) ; int scale Y Offset = ( int ) ( ( ( NUM - scale ) * task Height ) / NUM ) ; p Within Affiliate Top = screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Within Affiliation Offset + scale Y Offset ) ; float p Within Affiliate Offset = p At Bottom Of Stack Rect - p Within Affiliate Top ; float p Between Affiliate Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Between Affiliation Offset ) ; float p Task Height Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - task Height ) ; float p Nav Bar Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - ( m Stack Visible Rect . bottom - m Stack Rect . bottom ) ) ; float p At Back Most Card Top = NUM ; float p At Front Most Card Top = p At Back Most Card Top ; int task Count = data . size ( ) ; for ( int i = NUM ; i < task Count ; i ++ ) { m Task Progress Map . put ( data . get ( i ) , p At Front Most Card Top ) ; if ( i < ( task Count - NUM ) ) { float p Peek = p Between Affiliate Offset ; p At Front Most Card Top += p Peek ; } } m Max Scroll P = p At Front Most Card Top - ( ( NUM - p Task Height Offset - p Nav Bar Offset ) ) ; m Min Scroll P = data . size ( ) == NUM ? Math . max ( m Max Scroll P , NUM ) : NUM ; if ( launched With Alt Tab && launched From Home ) { m Initial Scroll P = m Max Scroll P ; } else { m Initial Scroll P = p At Front Most Card Top - NUM ; } m Initial Scroll P = Math . min ( m Max Scroll P , Math . max ( NUM , m Initial Scroll P ) ) ; }
void compute Min Max Scroll ( Array List < T > data , boolean launched With Alt Tab , boolean launched From Home ) { m Task Progress Map . clear ( ) ; if ( data . is Empty ( ) ) { m Min Scroll P = m Max Scroll P = NUM ; return ; } int task Height = m Task Rect . height ( ) ; float p At Bottom Of Stack Rect = screen Y To Curve Progress ( m Stack Visible Rect . bottom ) ; float p Within Affiliate Top = screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Within Affiliation Offset ) ; float scale = curve Progress To Scale ( p Within Affiliate Top ) ; int scale Y Offset = ( int ) ( ( ( NUM - scale ) * task Height ) / NUM ) ; p Within Affiliate Top = screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Within Affiliation Offset + scale Y Offset ) ; float p Within Affiliate Offset = p At Bottom Of Stack Rect - p Within Affiliate Top ; float p Between Affiliate Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Between Affiliation Offset ) ; float p Task Height Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - task Height ) ; float p Nav Bar Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - ( m Stack Visible Rect . bottom - m Stack Rect . bottom ) ) ; float p At Back Most Card Top = NUM ; float p At Front Most Card Top = p At Back Most Card Top ; int task Count = data . size ( ) ; for ( int i = NUM ; i < task Count ; i ++ ) { m Task Progress Map . put ( data . get ( i ) , p At Front Most Card Top ) ; if ( i < ( task Count - NUM ) ) { float p Peek = p Between Affiliate Offset ; p At Front Most Card Top += p Peek ; } } m Max Scroll P = p At Front Most Card Top - ( ( NUM - p Task Height Offset - p Nav Bar Offset ) ) ; m Min Scroll P = data . size ( ) == NUM ? Math . max ( m Max Scroll P , NUM ) : NUM ; if ( launched With Alt Tab && launched From Home ) { m Initial Scroll P = m Max Scroll P ; } else { m Initial Scroll P = p At Front Most Card Top - NUM ; } m Initial Scroll P = Math . min ( m Max Scroll P , Math . max ( NUM , m Initial Scroll P ) ) ; }
void compute Min Max Scroll ( Array List < T > data , boolean launched With Alt Tab , boolean launched From Home ) { m Task Progress Map . clear ( ) ; if ( data . is Empty ( ) ) { m Min Scroll P = m Max Scroll P = NUM ; return ; } int task Height = m Task Rect . height ( ) ; float p At Bottom Of Stack Rect = screen Y To Curve Progress ( m Stack Visible Rect . bottom ) ; float p Within Affiliate Top = screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Within Affiliation Offset ) ; float scale = curve Progress To Scale ( p Within Affiliate Top ) ; int scale Y Offset = ( int ) ( ( ( NUM - scale ) * task Height ) / NUM ) ; p Within Affiliate Top = screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Within Affiliation Offset + scale Y Offset ) ; float p Within Affiliate Offset = p At Bottom Of Stack Rect - p Within Affiliate Top ; float p Between Affiliate Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Between Affiliation Offset ) ; float p Task Height Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - task Height ) ; float p Nav Bar Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - ( m Stack Visible Rect . bottom - m Stack Rect . bottom ) ) ; float p At Back Most Card Top = NUM ; float p At Front Most Card Top = p At Back Most Card Top ; int task Count = data . size ( ) ; for ( int i = NUM ; i < task Count ; i ++ ) { m Task Progress Map . put ( data . get ( i ) , p At Front Most Card Top ) ; if ( i < ( task Count - NUM ) ) { float p Peek = p Between Affiliate Offset ; p At Front Most Card Top += p Peek ; } } m Max Scroll P = p At Front Most Card Top - ( ( NUM - p Task Height Offset - p Nav Bar Offset ) ) ; m Min Scroll P = data . size ( ) == NUM ? Math . max ( m Max Scroll P , NUM ) : NUM ; if ( launched With Alt Tab && launched From Home ) { m Initial Scroll P = m Max Scroll P ; } else { m Initial Scroll P = p At Front Most Card Top - NUM ; } m Initial Scroll P = Math . min ( m Max Scroll P , Math . max ( NUM , m Initial Scroll P ) ) ; }
void compute Min Max Scroll ( Array List < T > data , boolean launched With Alt Tab , boolean launched From Home ) { m Task Progress Map . clear ( ) ; if ( data . is Empty ( ) ) { m Min Scroll P = m Max Scroll P = NUM ; return ; } int task Height = m Task Rect . height ( ) ; float p At Bottom Of Stack Rect = screen Y To Curve Progress ( m Stack Visible Rect . bottom ) ; float p Within Affiliate Top = screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Within Affiliation Offset ) ; float scale = curve Progress To Scale ( p Within Affiliate Top ) ; int scale Y Offset = ( int ) ( ( ( NUM - scale ) * task Height ) / NUM ) ; p Within Affiliate Top = screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Within Affiliation Offset + scale Y Offset ) ; float p Within Affiliate Offset = p At Bottom Of Stack Rect - p Within Affiliate Top ; float p Between Affiliate Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - m Between Affiliation Offset ) ; float p Task Height Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - task Height ) ; float p Nav Bar Offset = p At Bottom Of Stack Rect - screen Y To Curve Progress ( m Stack Visible Rect . bottom - ( m Stack Visible Rect . bottom - m Stack Rect . bottom ) ) ; float p At Back Most Card Top = NUM ; float p At Front Most Card Top = p At Back Most Card Top ; int task Count = data . size ( ) ; for ( int i = NUM ; i < task Count ; i ++ ) { m Task Progress Map . put ( data . get ( i ) , p At Front Most Card Top ) ; if ( i < ( task Count - NUM ) ) { float p Peek = p Between Affiliate Offset ; p At Front Most Card Top += p Peek ; } } m Max Scroll P = p At Front Most Card Top - ( ( NUM - p Task Height Offset - p Nav Bar Offset ) ) ; m Min Scroll P = data . size ( ) == NUM ? Math . max ( m Max Scroll P , NUM ) : NUM ; if ( launched With Alt Tab && launched From Home ) { m Initial Scroll P = m Max Scroll P ; } else { m Initial Scroll P = p At Front Most Card Top - NUM ; } m Initial Scroll P = Math . min ( m Max Scroll P , Math . max ( NUM , m Initial Scroll P ) ) ; }
private void insert In Order ( Vector list , Mqtt Wire Message new Msg ) { int new Msg Id = new Msg . get Message Id ( ) ; for ( int i = NUM ; i < list . size ( ) ; i ++ ) { Mqtt Wire Message other Msg = ( Mqtt Wire Message ) list . element At ( i ) ; int other Msg Id = other Msg . get Message Id ( ) ; if ( other Msg Id > new Msg Id ) { list . insert Element At ( new Msg , i ) ; return ; } } list . add Element ( new Msg ) ; }
private void insert In Order ( Vector list , Mqtt Wire Message new Msg ) { int new Msg Id = new Msg . get Message Id ( ) ; for ( int i = NUM ; i < list . size ( ) ; i ++ ) { Mqtt Wire Message other Msg = ( Mqtt Wire Message ) list . element At ( i ) ; int other Msg Id = other Msg . get Message Id ( ) ; if ( other Msg Id > new Msg Id ) { list . insert Element At ( new Msg , i ) ; return ; } } list . add Element ( new Msg ) ; }
private void compute Values ( ) { logger . debug ( STRING ) ; Map < N , Set < D > > all Seeds = new Hash Map < N , Set < D > > ( initial Seeds ) ; for ( N unbalanced Ret Site : unbalanced Ret Sites ) { Set < D > seeds = all Seeds . get ( unbalanced Ret Site ) ; if ( seeds == null ) { seeds = new Hash Set < D > ( ) ; all Seeds . put ( unbalanced Ret Site , seeds ) ; } seeds . add ( zero Value ) ; } for ( Entry < N , Set < D > > seed : all Seeds . entry Set ( ) ) { N start Point = seed . get Key ( ) ; for ( D val : seed . get Value ( ) ) { set Val ( start Point , val , value Lattice . bottom Element ( ) ) ; Pair < N , D > super Graph Node = new Pair < N , D > ( start Point , val ) ; schedule Value Processing ( new Value Propagation Task ( super Graph Node ) ) ; } } logger . debug ( STRING ) ; try { executor . await Completion ( ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } Set < N > all Non Call Start Nodes = icfg . all Non Call Start Nodes ( ) ; @ Suppress Warnings ( STRING ) N [ ] non Call Start Nodes Array = ( N [ ] ) new Object [ all Non Call Start Nodes . size ( ) ] ; int i = NUM ; for ( N n : all Non Call Start Nodes ) { non Call Start Nodes Array [ i ] = n ; i ++ ; } for ( int t = NUM ; t < num Threads ; t ++ ) { Value Computation Task task = new Value Computation Task ( non Call Start Nodes Array , t ) ; schedule Value Computation Task ( task ) ; } try { executor . await Completion ( ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } }
private void compute Values ( ) { logger . debug ( STRING ) ; Map < N , Set < D > > all Seeds = new Hash Map < N , Set < D > > ( initial Seeds ) ; for ( N unbalanced Ret Site : unbalanced Ret Sites ) { Set < D > seeds = all Seeds . get ( unbalanced Ret Site ) ; if ( seeds == null ) { seeds = new Hash Set < D > ( ) ; all Seeds . put ( unbalanced Ret Site , seeds ) ; } seeds . add ( zero Value ) ; } for ( Entry < N , Set < D > > seed : all Seeds . entry Set ( ) ) { N start Point = seed . get Key ( ) ; for ( D val : seed . get Value ( ) ) { set Val ( start Point , val , value Lattice . bottom Element ( ) ) ; Pair < N , D > super Graph Node = new Pair < N , D > ( start Point , val ) ; schedule Value Processing ( new Value Propagation Task ( super Graph Node ) ) ; } } logger . debug ( STRING ) ; try { executor . await Completion ( ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } Set < N > all Non Call Start Nodes = icfg . all Non Call Start Nodes ( ) ; @ Suppress Warnings ( STRING ) N [ ] non Call Start Nodes Array = ( N [ ] ) new Object [ all Non Call Start Nodes . size ( ) ] ; int i = NUM ; for ( N n : all Non Call Start Nodes ) { non Call Start Nodes Array [ i ] = n ; i ++ ; } for ( int t = NUM ; t < num Threads ; t ++ ) { Value Computation Task task = new Value Computation Task ( non Call Start Nodes Array , t ) ; schedule Value Computation Task ( task ) ; } try { executor . await Completion ( ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } }
protected final static void init Hard Coded Properties ( Properties p ) { String Tokenizer tokenizer ; tokenizer = new String Tokenizer ( title , STRING ) ; tokenizer . next Token ( ) ; p . put ( Title , tokenizer . next Token ( ) ) ; tokenizer = new String Tokenizer ( version , STRING ) ; tokenizer . next Token ( ) ; p . put ( Version , tokenizer . next Token ( ) ) ; tokenizer = new String Tokenizer ( build , STRING ) ; tokenizer . next Token ( ) ; try { p . put ( Build Date , tokenizer . next Token ( ) ) ; } catch ( No Such Element Exception e ) { } }
protected final static void init Hard Coded Properties ( Properties p ) { String Tokenizer tokenizer ; tokenizer = new String Tokenizer ( title , STRING ) ; tokenizer . next Token ( ) ; p . put ( Title , tokenizer . next Token ( ) ) ; tokenizer = new String Tokenizer ( version , STRING ) ; tokenizer . next Token ( ) ; p . put ( Version , tokenizer . next Token ( ) ) ; tokenizer = new String Tokenizer ( build , STRING ) ; tokenizer . next Token ( ) ; try { p . put ( Build Date , tokenizer . next Token ( ) ) ; } catch ( No Such Element Exception e ) { } }
protected final static void init Hard Coded Properties ( Properties p ) { String Tokenizer tokenizer ; tokenizer = new String Tokenizer ( title , STRING ) ; tokenizer . next Token ( ) ; p . put ( Title , tokenizer . next Token ( ) ) ; tokenizer = new String Tokenizer ( version , STRING ) ; tokenizer . next Token ( ) ; p . put ( Version , tokenizer . next Token ( ) ) ; tokenizer = new String Tokenizer ( build , STRING ) ; tokenizer . next Token ( ) ; try { p . put ( Build Date , tokenizer . next Token ( ) ) ; } catch ( No Such Element Exception e ) { } }
protected final static void init Hard Coded Properties ( Properties p ) { String Tokenizer tokenizer ; tokenizer = new String Tokenizer ( title , STRING ) ; tokenizer . next Token ( ) ; p . put ( Title , tokenizer . next Token ( ) ) ; tokenizer = new String Tokenizer ( version , STRING ) ; tokenizer . next Token ( ) ; p . put ( Version , tokenizer . next Token ( ) ) ; tokenizer = new String Tokenizer ( build , STRING ) ; tokenizer . next Token ( ) ; try { p . put ( Build Date , tokenizer . next Token ( ) ) ; } catch ( No Such Element Exception e ) { } }
@ Subscribe public synchronized void on Step Moved ( Step Moved Event event ) { Platform Impl . run And Wait ( null ) ; }
@ Subscribe public synchronized void on Step Moved ( Step Moved Event event ) { Platform Impl . run And Wait ( null ) ; }
@ Subscribe public synchronized void on Step Moved ( Step Moved Event event ) { Platform Impl . run And Wait ( null ) ; }
@ Subscribe public synchronized void on Step Moved ( Step Moved Event event ) { Platform Impl . run And Wait ( null ) ; }
@ Subscribe public synchronized void on Step Moved ( Step Moved Event event ) { Platform Impl . run And Wait ( null ) ; }
@ Subscribe public synchronized void on Step Moved ( Step Moved Event event ) { Platform Impl . run And Wait ( null ) ; }
public static String replace All ( String source ) { int region Start = NUM ; for ( String entity = get Next Entity ( source , region Start ) ; entity != null ; entity = get Next Entity ( source , region Start ) ) { String replacement = Entity Map . get ( entity ) ; if ( replacement == null ) { region Start += entity . length ( ) ; continue ; } source = source . replace ( entity , replacement ) ; region Start += replacement . length ( ) ; } return source ; }
public static String replace All ( String source ) { int region Start = NUM ; for ( String entity = get Next Entity ( source , region Start ) ; entity != null ; entity = get Next Entity ( source , region Start ) ) { String replacement = Entity Map . get ( entity ) ; if ( replacement == null ) { region Start += entity . length ( ) ; continue ; } source = source . replace ( entity , replacement ) ; region Start += replacement . length ( ) ; } return source ; }
public static String replace All ( String source ) { int region Start = NUM ; for ( String entity = get Next Entity ( source , region Start ) ; entity != null ; entity = get Next Entity ( source , region Start ) ) { String replacement = Entity Map . get ( entity ) ; if ( replacement == null ) { region Start += entity . length ( ) ; continue ; } source = source . replace ( entity , replacement ) ; region Start += replacement . length ( ) ; } return source ; }
@ Override public Action execute ( Percept percept ) { kb . make Percept Sentence ( ( Agent Percept ) percept , t ) ; kb . tell Temporal Physics Sentences ( t ) ; Agent Position current = kb . ask Current Position ( t ) ; Set < Room > safe = kb . ask Safe Rooms ( t ) ; if ( kb . ask Glitter ( t ) ) { Set < Room > goals = new Linked Hash Set < Room > ( ) ; goals . add ( new Room ( NUM , NUM ) ) ; plan . add ( new Grab ( ) ) ; plan . add All ( plan Route ( current , goals , safe ) ) ; plan . add ( new Climb ( ) ) ; } Set < Room > unvisited = kb . ask Unvisited Rooms ( t ) ; if ( plan . is Empty ( ) ) { plan . add All ( plan Route ( current , Set Ops . intersection ( unvisited , safe ) , safe ) ) ; } if ( plan . is Empty ( ) && kb . ask Have Arrow ( t ) ) { Set < Room > possible Wumpus = kb . ask Possible Wumpus Rooms ( t ) ; plan . add All ( plan Shot ( current , possible Wumpus , safe ) ) ; } if ( plan . is Empty ( ) ) { Set < Room > not Unsafe = kb . ask Not Unsafe Rooms ( t ) ; plan . add All ( plan Route ( current , Set Ops . intersection ( unvisited , not Unsafe ) , safe ) ) ; } if ( plan . is Empty ( ) ) { Set < Room > start = new Linked Hash Set < Room > ( ) ; start . add ( new Room ( NUM , NUM ) ) ; plan . add All ( plan Route ( current , start , safe ) ) ; plan . add ( new Climb ( ) ) ; } Action action = plan . remove ( ) ; kb . make Action Sentence ( action , t ) ; t = t + NUM ; return action ; }
@ Override public Action execute ( Percept percept ) { kb . make Percept Sentence ( ( Agent Percept ) percept , t ) ; kb . tell Temporal Physics Sentences ( t ) ; Agent Position current = kb . ask Current Position ( t ) ; Set < Room > safe = kb . ask Safe Rooms ( t ) ; if ( kb . ask Glitter ( t ) ) { Set < Room > goals = new Linked Hash Set < Room > ( ) ; goals . add ( new Room ( NUM , NUM ) ) ; plan . add ( new Grab ( ) ) ; plan . add All ( plan Route ( current , goals , safe ) ) ; plan . add ( new Climb ( ) ) ; } Set < Room > unvisited = kb . ask Unvisited Rooms ( t ) ; if ( plan . is Empty ( ) ) { plan . add All ( plan Route ( current , Set Ops . intersection ( unvisited , safe ) , safe ) ) ; } if ( plan . is Empty ( ) && kb . ask Have Arrow ( t ) ) { Set < Room > possible Wumpus = kb . ask Possible Wumpus Rooms ( t ) ; plan . add All ( plan Shot ( current , possible Wumpus , safe ) ) ; } if ( plan . is Empty ( ) ) { Set < Room > not Unsafe = kb . ask Not Unsafe Rooms ( t ) ; plan . add All ( plan Route ( current , Set Ops . intersection ( unvisited , not Unsafe ) , safe ) ) ; } if ( plan . is Empty ( ) ) { Set < Room > start = new Linked Hash Set < Room > ( ) ; start . add ( new Room ( NUM , NUM ) ) ; plan . add All ( plan Route ( current , start , safe ) ) ; plan . add ( new Climb ( ) ) ; } Action action = plan . remove ( ) ; kb . make Action Sentence ( action , t ) ; t = t + NUM ; return action ; }
private int find Bin ( double value ) { return Fast Math . min ( Fast Math . max ( ( int ) Fast Math . ceil ( ( value - min ) / delta ) - NUM , NUM ) , bin Count - NUM ) ; }
private int find Bin ( double value ) { return Fast Math . min ( Fast Math . max ( ( int ) Fast Math . ceil ( ( value - min ) / delta ) - NUM , NUM ) , bin Count - NUM ) ; }
protected void reopen ( ) throws IO Exception { if ( input Stream != null ) { Debug . message ( STRING , STRING ) ; input Stream . close ( ) ; } input Stream Count = NUM ; }
protected void reopen ( ) throws IO Exception { if ( input Stream != null ) { Debug . message ( STRING , STRING ) ; input Stream . close ( ) ; } input Stream Count = NUM ; }
protected void reopen ( ) throws IO Exception { if ( input Stream != null ) { Debug . message ( STRING , STRING ) ; input Stream . close ( ) ; } input Stream Count = NUM ; }
protected void reopen ( ) throws IO Exception { if ( input Stream != null ) { Debug . message ( STRING , STRING ) ; input Stream . close ( ) ; } input Stream Count = NUM ; }