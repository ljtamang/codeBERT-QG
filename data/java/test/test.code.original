public IIndex findIndex ( String name ) { return findIndex ( name , _BOOL ) ; }
public IIndex findIndex ( String name ) { return findIndex ( name , _BOOL ) ; }
private float y ( TouchState s ) { final float currToTan = ( float ) Math . sqrt ( ( s . distance * s . distance ) - ( mScaledTouchSlop * mScaledTouchSlop ) ) ; return currToTan * ( mScaledTouchSlop / s . distance ) ; }
public MapEntryInfoKey ( Object value , Object key , ReferenceQueue < Object > queue ) { super ( value , queue ) ; _hashCode = _hashCode ^ key . hashCode ( ) ; _key = key ; }
public MapEntryInfoKey ( Object value , Object key , ReferenceQueue < Object > queue ) { super ( value , queue ) ; _hashCode = _hashCode ^ key . hashCode ( ) ; _key = key ; }
public MapEntryInfoKey ( Object value , Object key , ReferenceQueue < Object > queue ) { super ( value , queue ) ; _hashCode = _hashCode ^ key . hashCode ( ) ; _key = key ; }
public MapEntryInfoKey ( Object value , Object key , ReferenceQueue < Object > queue ) { super ( value , queue ) ; _hashCode = _hashCode ^ key . hashCode ( ) ; _key = key ; }
private static void createKeyStore ( ) throws KeyStoreException , IOException { if ( sKeyStore != null ) { return ; } try { sKeyStore = KeyStore . getInstance ( getKeystoreType ( ) ) ; synchronized ( KeyStoreManager . class ) { sKeyStore . load ( null , KEYSTORE_PASSWORD . toCharArray ( ) ) ; } saveKeyStoreToFile ( sKeyStore ) ; } catch ( NoSuchAlgorithmException e ) { throw new KeyStoreException ( STRING , e ) ; } catch ( CertificateException e ) { throw new KeyStoreException ( STRING , e ) ; } }
private static void createKeyStore ( ) throws KeyStoreException , IOException { if ( sKeyStore != null ) { return ; } try { sKeyStore = KeyStore . getInstance ( getKeystoreType ( ) ) ; synchronized ( KeyStoreManager . class ) { sKeyStore . load ( null , KEYSTORE_PASSWORD . toCharArray ( ) ) ; } saveKeyStoreToFile ( sKeyStore ) ; } catch ( NoSuchAlgorithmException e ) { throw new KeyStoreException ( STRING , e ) ; } catch ( CertificateException e ) { throw new KeyStoreException ( STRING , e ) ; } }
public JulianDate add ( int units , int amount ) { JulianDate date = null ; synchronized ( gc ) { gc . setTime ( getJavaDate ( ) ) ; gc . add ( units , amount ) ; date = new JulianDate ( gc . getTime ( ) ) ; } return date ; }
public JulianDate add ( int units , int amount ) { JulianDate date = null ; synchronized ( gc ) { gc . setTime ( getJavaDate ( ) ) ; gc . add ( units , amount ) ; date = new JulianDate ( gc . getTime ( ) ) ; } return date ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public void updates ( String type , List < String > ids , MetacatContext metacatContext , ObjectNode node ) { if ( ids == null || ids . isEmpty ( ) ) { return ; } try { RETRY_ES_PUBLISH . call ( null ) ; } catch ( Exception e ) { log . error ( String . format ( STRING , type , ids ) , e ) ; CounterWrapper . incrementCounter ( STRING ) ; log ( STRING , type , ids . toString ( ) , null , e . getMessage ( ) , e , _BOOL ) ; } }
public void updates ( String type , List < String > ids , MetacatContext metacatContext , ObjectNode node ) { if ( ids == null || ids . isEmpty ( ) ) { return ; } try { RETRY_ES_PUBLISH . call ( null ) ; } catch ( Exception e ) { log . error ( String . format ( STRING , type , ids ) , e ) ; CounterWrapper . incrementCounter ( STRING ) ; log ( STRING , type , ids . toString ( ) , null , e . getMessage ( ) , e , _BOOL ) ; } }
public void updates ( String type , List < String > ids , MetacatContext metacatContext , ObjectNode node ) { if ( ids == null || ids . isEmpty ( ) ) { return ; } try { RETRY_ES_PUBLISH . call ( null ) ; } catch ( Exception e ) { log . error ( String . format ( STRING , type , ids ) , e ) ; CounterWrapper . incrementCounter ( STRING ) ; log ( STRING , type , ids . toString ( ) , null , e . getMessage ( ) , e , _BOOL ) ; } }
protected boolean checkToSkipDirectory ( String name ) { if ( dirSuffixAvoids != null ) { for ( int i = _NUM ; i < dirSuffixAvoids . length ; i ++ ) { if ( name . endsWith ( dirSuffixAvoids [ i ] ) ) { return _BOOL ; } } } if ( dirSuffixLimits != null ) { for ( int i = _NUM ; i < dirSuffixLimits . length ; i ++ ) { if ( name . endsWith ( dirSuffixLimits [ i ] ) ) { return _BOOL ; } } return _BOOL ; } return _BOOL ; }
@ Override public EnterFromDateToToDateActivity . TimeObject add ( long time , int val ) { Calendar c = Calendar . getInstance ( ) ; c . setTimeInMillis ( time ) ; c . add ( Calendar . MONTH , val ) ; return timeObjectFromCalendar ( c ) ; }
@ Override public EnterFromDateToToDateActivity . TimeObject add ( long time , int val ) { Calendar c = Calendar . getInstance ( ) ; c . setTimeInMillis ( time ) ; c . add ( Calendar . MONTH , val ) ; return timeObjectFromCalendar ( c ) ; }
public void test_create01 ( ) throws Exception { final String namespace2 = STRING + UUID . randomUUID ( ) ; doTestCreate ( namespace2 ) ; }
public void test_create01 ( ) throws Exception { final String namespace2 = STRING + UUID . randomUUID ( ) ; doTestCreate ( namespace2 ) ; }
public void test_create01 ( ) throws Exception { final String namespace2 = STRING + UUID . randomUUID ( ) ; doTestCreate ( namespace2 ) ; }
public void test_create01 ( ) throws Exception { final String namespace2 = STRING + UUID . randomUUID ( ) ; doTestCreate ( namespace2 ) ; }
public void test_create01 ( ) throws Exception { final String namespace2 = STRING + UUID . randomUUID ( ) ; doTestCreate ( namespace2 ) ; }
public void test_create01 ( ) throws Exception { final String namespace2 = STRING + UUID . randomUUID ( ) ; doTestCreate ( namespace2 ) ; }
public void test_create01 ( ) throws Exception { final String namespace2 = STRING + UUID . randomUUID ( ) ; doTestCreate ( namespace2 ) ; }
public void test_create01 ( ) throws Exception { final String namespace2 = STRING + UUID . randomUUID ( ) ; doTestCreate ( namespace2 ) ; }
public void test_create01 ( ) throws Exception { final String namespace2 = STRING + UUID . randomUUID ( ) ; doTestCreate ( namespace2 ) ; }
public static String toString ( final InputStream is ) throws IOException { final BufferedReader br = new BufferedReader ( new InputStreamReader ( is ) ) ; final StringBuffer content = new StringBuffer ( ) ; String line = br . readLine ( ) ; if ( line != null ) { content . append ( line ) ; while ( ( line = br . readLine ( ) ) != null ) content . append ( STRING + line ) ; } br . close ( ) ; return content . toString ( ) ; }
public void add ( Protocol protocol ) { if ( protocolList != null ) { protocolList . add ( protocol ) ; protocol . init ( userConnection ) ; } else { throw new NullPointerException ( STRING ) ; } }
public void add ( Protocol protocol ) { if ( protocolList != null ) { protocolList . add ( protocol ) ; protocol . init ( userConnection ) ; } else { throw new NullPointerException ( STRING ) ; } }
public void add ( Protocol protocol ) { if ( protocolList != null ) { protocolList . add ( protocol ) ; protocol . init ( userConnection ) ; } else { throw new NullPointerException ( STRING ) ; } }
public void add ( Protocol protocol ) { if ( protocolList != null ) { protocolList . add ( protocol ) ; protocol . init ( userConnection ) ; } else { throw new NullPointerException ( STRING ) ; } }
private boolean isNumber ( String string ) { String s = string . trim ( ) ; if ( s . length ( ) < _NUM ) return _BOOL ; double value = _NUM ; try { value = Double . parseDouble ( s ) ; } catch ( NumberFormatException e ) { return _BOOL ; } return _BOOL ; }
private boolean isNumber ( String string ) { String s = string . trim ( ) ; if ( s . length ( ) < _NUM ) return _BOOL ; double value = _NUM ; try { value = Double . parseDouble ( s ) ; } catch ( NumberFormatException e ) { return _BOOL ; } return _BOOL ; }
private boolean isNumber ( String string ) { String s = string . trim ( ) ; if ( s . length ( ) < _NUM ) return _BOOL ; double value = _NUM ; try { value = Double . parseDouble ( s ) ; } catch ( NumberFormatException e ) { return _BOOL ; } return _BOOL ; }
private void initializeValues ( ) { mnSize = Math . min ( getMeasuredHeight ( ) , getMeasuredWidth ( ) ) ; mnRingRadius = ( int ) ( mnSize - mnRingWidth ) / _NUM ; mnInnerCircleRadius = ( int ) ( mnSize - ( mnRingWidth * _NUM ) ) / _NUM ; mnViewCenter = mnSize / _NUM ; mnLineWidth = STATUS_SYMBOL_WIDTH_PERCENT * mnSize ; }
private void initializeValues ( ) { mnSize = Math . min ( getMeasuredHeight ( ) , getMeasuredWidth ( ) ) ; mnRingRadius = ( int ) ( mnSize - mnRingWidth ) / _NUM ; mnInnerCircleRadius = ( int ) ( mnSize - ( mnRingWidth * _NUM ) ) / _NUM ; mnViewCenter = mnSize / _NUM ; mnLineWidth = STATUS_SYMBOL_WIDTH_PERCENT * mnSize ; }
@ VisibleForTesting public static boolean createGradleWrapper ( @ NotNull File projectDirPath , @ NotNull String gradleVersion ) throws IOException { File projectWrapperDirPath = new File ( projectDirPath , FD_GRADLE_WRAPPER ) ; if ( ! projectWrapperDirPath . isDirectory ( ) ) { File wrapperSrcDirPath = new File ( TemplateManager . getTemplateRootFolder ( ) , FD_GRADLE_WRAPPER ) ; if ( ! wrapperSrcDirPath . exists ( ) ) { for ( File root : TemplateManager . getExtraTemplateRootFolders ( ) ) { wrapperSrcDirPath = new File ( root , FD_GRADLE_WRAPPER ) ; if ( wrapperSrcDirPath . exists ( ) ) { break ; } else { wrapperSrcDirPath = null ; } } } if ( wrapperSrcDirPath == null ) { return _BOOL ; } copyDirContent ( wrapperSrcDirPath , projectDirPath ) ; } File wrapperPropertiesFile = getGradleWrapperPropertiesFilePath ( projectDirPath ) ; updateGradleDistributionUrl ( gradleVersion , wrapperPropertiesFile ) ; return _BOOL ; }
@ VisibleForTesting public static boolean createGradleWrapper ( @ NotNull File projectDirPath , @ NotNull String gradleVersion ) throws IOException { File projectWrapperDirPath = new File ( projectDirPath , FD_GRADLE_WRAPPER ) ; if ( ! projectWrapperDirPath . isDirectory ( ) ) { File wrapperSrcDirPath = new File ( TemplateManager . getTemplateRootFolder ( ) , FD_GRADLE_WRAPPER ) ; if ( ! wrapperSrcDirPath . exists ( ) ) { for ( File root : TemplateManager . getExtraTemplateRootFolders ( ) ) { wrapperSrcDirPath = new File ( root , FD_GRADLE_WRAPPER ) ; if ( wrapperSrcDirPath . exists ( ) ) { break ; } else { wrapperSrcDirPath = null ; } } } if ( wrapperSrcDirPath == null ) { return _BOOL ; } copyDirContent ( wrapperSrcDirPath , projectDirPath ) ; } File wrapperPropertiesFile = getGradleWrapperPropertiesFilePath ( projectDirPath ) ; updateGradleDistributionUrl ( gradleVersion , wrapperPropertiesFile ) ; return _BOOL ; }
@ VisibleForTesting public static boolean createGradleWrapper ( @ NotNull File projectDirPath , @ NotNull String gradleVersion ) throws IOException { File projectWrapperDirPath = new File ( projectDirPath , FD_GRADLE_WRAPPER ) ; if ( ! projectWrapperDirPath . isDirectory ( ) ) { File wrapperSrcDirPath = new File ( TemplateManager . getTemplateRootFolder ( ) , FD_GRADLE_WRAPPER ) ; if ( ! wrapperSrcDirPath . exists ( ) ) { for ( File root : TemplateManager . getExtraTemplateRootFolders ( ) ) { wrapperSrcDirPath = new File ( root , FD_GRADLE_WRAPPER ) ; if ( wrapperSrcDirPath . exists ( ) ) { break ; } else { wrapperSrcDirPath = null ; } } } if ( wrapperSrcDirPath == null ) { return _BOOL ; } copyDirContent ( wrapperSrcDirPath , projectDirPath ) ; } File wrapperPropertiesFile = getGradleWrapperPropertiesFilePath ( projectDirPath ) ; updateGradleDistributionUrl ( gradleVersion , wrapperPropertiesFile ) ; return _BOOL ; }
@ VisibleForTesting public static boolean createGradleWrapper ( @ NotNull File projectDirPath , @ NotNull String gradleVersion ) throws IOException { File projectWrapperDirPath = new File ( projectDirPath , FD_GRADLE_WRAPPER ) ; if ( ! projectWrapperDirPath . isDirectory ( ) ) { File wrapperSrcDirPath = new File ( TemplateManager . getTemplateRootFolder ( ) , FD_GRADLE_WRAPPER ) ; if ( ! wrapperSrcDirPath . exists ( ) ) { for ( File root : TemplateManager . getExtraTemplateRootFolders ( ) ) { wrapperSrcDirPath = new File ( root , FD_GRADLE_WRAPPER ) ; if ( wrapperSrcDirPath . exists ( ) ) { break ; } else { wrapperSrcDirPath = null ; } } } if ( wrapperSrcDirPath == null ) { return _BOOL ; } copyDirContent ( wrapperSrcDirPath , projectDirPath ) ; } File wrapperPropertiesFile = getGradleWrapperPropertiesFilePath ( projectDirPath ) ; updateGradleDistributionUrl ( gradleVersion , wrapperPropertiesFile ) ; return _BOOL ; }
@ Override public boolean equals ( final Object o ) { if ( this == o ) return _BOOL ; if ( ! ( o instanceof Header ) ) { return _BOOL ; } return name . equals ( ( ( Header ) o ) . name ) ; }
@ Override public boolean equals ( final Object o ) { if ( this == o ) return _BOOL ; if ( ! ( o instanceof Header ) ) { return _BOOL ; } return name . equals ( ( ( Header ) o ) . name ) ; }
@ Override public boolean equals ( final Object o ) { if ( this == o ) return _BOOL ; if ( ! ( o instanceof Header ) ) { return _BOOL ; } return name . equals ( ( ( Header ) o ) . name ) ; }
public static void writePemStringToFile ( File file , String pemDataToWrite ) { try { FileUtils . write ( file , pemDataToWrite ) ; } catch ( IOException e ) { throw new ExportException ( STRING + file . getName ( ) , e ) ; } }
public EnvVarModel ( EnvironmentManagerInterface envMgr ) { this . envMgr = envMgr ; if ( columns . isEmpty ( ) ) { columns . add ( Localisation . getString ( EnvVarDlg . class , STRING ) ) ; columns . add ( Localisation . getString ( EnvVarDlg . class , STRING ) ) ; columns . add ( Localisation . getString ( EnvVarDlg . class , STRING ) ) ; } }
public EnvVarModel ( EnvironmentManagerInterface envMgr ) { this . envMgr = envMgr ; if ( columns . isEmpty ( ) ) { columns . add ( Localisation . getString ( EnvVarDlg . class , STRING ) ) ; columns . add ( Localisation . getString ( EnvVarDlg . class , STRING ) ) ; columns . add ( Localisation . getString ( EnvVarDlg . class , STRING ) ) ; } }
public BitVector ( BitVector s ) { bits = new int [ s . bits . length ] ; this . nbits = s . nbits ; System . arraycopy ( s . bits , _NUM , this . bits , _NUM , s . bits . length ) ; }
public BitVector ( BitVector s ) { bits = new int [ s . bits . length ] ; this . nbits = s . nbits ; System . arraycopy ( s . bits , _NUM , this . bits , _NUM , s . bits . length ) ; }
void write ( ImageOutputStream ios , JPEGImageWriter writer ) throws IOException { write ( ios , null , writer ) ; }
void write ( ImageOutputStream ios , JPEGImageWriter writer ) throws IOException { write ( ios , null , writer ) ; }
void write ( ImageOutputStream ios , JPEGImageWriter writer ) throws IOException { write ( ios , null , writer ) ; }
@ SuppressWarnings ( STRING ) private Class validateClass ( ClientConfig cfg ) { Class clazz = null ; try { clazz = Class . forName ( cfg . getAccessRequestHandlerClassname ( ) ) ; } catch ( final ClassNotFoundException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } Object inst = null ; try { inst = InjectorHolder . getInstance ( clazz ) ; } catch ( ConfigurationException | ProvisionException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } AccessRequestHandler handler = null ; try { handler = ( AccessRequestHandler ) inst ; } catch ( final ClassCastException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } return clazz ; }
@ SuppressWarnings ( STRING ) private Class validateClass ( ClientConfig cfg ) { Class clazz = null ; try { clazz = Class . forName ( cfg . getAccessRequestHandlerClassname ( ) ) ; } catch ( final ClassNotFoundException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } Object inst = null ; try { inst = InjectorHolder . getInstance ( clazz ) ; } catch ( ConfigurationException | ProvisionException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } AccessRequestHandler handler = null ; try { handler = ( AccessRequestHandler ) inst ; } catch ( final ClassCastException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } return clazz ; }
@ SuppressWarnings ( STRING ) private Class validateClass ( ClientConfig cfg ) { Class clazz = null ; try { clazz = Class . forName ( cfg . getAccessRequestHandlerClassname ( ) ) ; } catch ( final ClassNotFoundException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } Object inst = null ; try { inst = InjectorHolder . getInstance ( clazz ) ; } catch ( ConfigurationException | ProvisionException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } AccessRequestHandler handler = null ; try { handler = ( AccessRequestHandler ) inst ; } catch ( final ClassCastException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } return clazz ; }
@ SuppressWarnings ( STRING ) private Class validateClass ( ClientConfig cfg ) { Class clazz = null ; try { clazz = Class . forName ( cfg . getAccessRequestHandlerClassname ( ) ) ; } catch ( final ClassNotFoundException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } Object inst = null ; try { inst = InjectorHolder . getInstance ( clazz ) ; } catch ( ConfigurationException | ProvisionException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } AccessRequestHandler handler = null ; try { handler = ( AccessRequestHandler ) inst ; } catch ( final ClassCastException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } return clazz ; }
void computeMinMaxScroll ( ArrayList < T > data , boolean launchedWithAltTab , boolean launchedFromHome ) { mTaskProgressMap . clear ( ) ; if ( data . isEmpty ( ) ) { mMinScrollP = mMaxScrollP = _NUM ; return ; } int taskHeight = mTaskRect . height ( ) ; float pAtBottomOfStackRect = screenYToCurveProgress ( mStackVisibleRect . bottom ) ; float pWithinAffiliateTop = screenYToCurveProgress ( mStackVisibleRect . bottom - mWithinAffiliationOffset ) ; float scale = curveProgressToScale ( pWithinAffiliateTop ) ; int scaleYOffset = ( int ) ( ( ( _NUM - scale ) * taskHeight ) / _NUM ) ; pWithinAffiliateTop = screenYToCurveProgress ( mStackVisibleRect . bottom - mWithinAffiliationOffset + scaleYOffset ) ; float pWithinAffiliateOffset = pAtBottomOfStackRect - pWithinAffiliateTop ; float pBetweenAffiliateOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - mBetweenAffiliationOffset ) ; float pTaskHeightOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - taskHeight ) ; float pNavBarOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - ( mStackVisibleRect . bottom - mStackRect . bottom ) ) ; float pAtBackMostCardTop = _NUM ; float pAtFrontMostCardTop = pAtBackMostCardTop ; int taskCount = data . size ( ) ; for ( int i = _NUM ; i < taskCount ; i ++ ) { mTaskProgressMap . put ( data . get ( i ) , pAtFrontMostCardTop ) ; if ( i < ( taskCount - _NUM ) ) { float pPeek = pBetweenAffiliateOffset ; pAtFrontMostCardTop += pPeek ; } } mMaxScrollP = pAtFrontMostCardTop - ( ( _NUM - pTaskHeightOffset - pNavBarOffset ) ) ; mMinScrollP = data . size ( ) == _NUM ? Math . max ( mMaxScrollP , _NUM ) : _NUM ; if ( launchedWithAltTab && launchedFromHome ) { mInitialScrollP = mMaxScrollP ; } else { mInitialScrollP = pAtFrontMostCardTop - _NUM ; } mInitialScrollP = Math . min ( mMaxScrollP , Math . max ( _NUM , mInitialScrollP ) ) ; }
void computeMinMaxScroll ( ArrayList < T > data , boolean launchedWithAltTab , boolean launchedFromHome ) { mTaskProgressMap . clear ( ) ; if ( data . isEmpty ( ) ) { mMinScrollP = mMaxScrollP = _NUM ; return ; } int taskHeight = mTaskRect . height ( ) ; float pAtBottomOfStackRect = screenYToCurveProgress ( mStackVisibleRect . bottom ) ; float pWithinAffiliateTop = screenYToCurveProgress ( mStackVisibleRect . bottom - mWithinAffiliationOffset ) ; float scale = curveProgressToScale ( pWithinAffiliateTop ) ; int scaleYOffset = ( int ) ( ( ( _NUM - scale ) * taskHeight ) / _NUM ) ; pWithinAffiliateTop = screenYToCurveProgress ( mStackVisibleRect . bottom - mWithinAffiliationOffset + scaleYOffset ) ; float pWithinAffiliateOffset = pAtBottomOfStackRect - pWithinAffiliateTop ; float pBetweenAffiliateOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - mBetweenAffiliationOffset ) ; float pTaskHeightOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - taskHeight ) ; float pNavBarOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - ( mStackVisibleRect . bottom - mStackRect . bottom ) ) ; float pAtBackMostCardTop = _NUM ; float pAtFrontMostCardTop = pAtBackMostCardTop ; int taskCount = data . size ( ) ; for ( int i = _NUM ; i < taskCount ; i ++ ) { mTaskProgressMap . put ( data . get ( i ) , pAtFrontMostCardTop ) ; if ( i < ( taskCount - _NUM ) ) { float pPeek = pBetweenAffiliateOffset ; pAtFrontMostCardTop += pPeek ; } } mMaxScrollP = pAtFrontMostCardTop - ( ( _NUM - pTaskHeightOffset - pNavBarOffset ) ) ; mMinScrollP = data . size ( ) == _NUM ? Math . max ( mMaxScrollP , _NUM ) : _NUM ; if ( launchedWithAltTab && launchedFromHome ) { mInitialScrollP = mMaxScrollP ; } else { mInitialScrollP = pAtFrontMostCardTop - _NUM ; } mInitialScrollP = Math . min ( mMaxScrollP , Math . max ( _NUM , mInitialScrollP ) ) ; }
void computeMinMaxScroll ( ArrayList < T > data , boolean launchedWithAltTab , boolean launchedFromHome ) { mTaskProgressMap . clear ( ) ; if ( data . isEmpty ( ) ) { mMinScrollP = mMaxScrollP = _NUM ; return ; } int taskHeight = mTaskRect . height ( ) ; float pAtBottomOfStackRect = screenYToCurveProgress ( mStackVisibleRect . bottom ) ; float pWithinAffiliateTop = screenYToCurveProgress ( mStackVisibleRect . bottom - mWithinAffiliationOffset ) ; float scale = curveProgressToScale ( pWithinAffiliateTop ) ; int scaleYOffset = ( int ) ( ( ( _NUM - scale ) * taskHeight ) / _NUM ) ; pWithinAffiliateTop = screenYToCurveProgress ( mStackVisibleRect . bottom - mWithinAffiliationOffset + scaleYOffset ) ; float pWithinAffiliateOffset = pAtBottomOfStackRect - pWithinAffiliateTop ; float pBetweenAffiliateOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - mBetweenAffiliationOffset ) ; float pTaskHeightOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - taskHeight ) ; float pNavBarOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - ( mStackVisibleRect . bottom - mStackRect . bottom ) ) ; float pAtBackMostCardTop = _NUM ; float pAtFrontMostCardTop = pAtBackMostCardTop ; int taskCount = data . size ( ) ; for ( int i = _NUM ; i < taskCount ; i ++ ) { mTaskProgressMap . put ( data . get ( i ) , pAtFrontMostCardTop ) ; if ( i < ( taskCount - _NUM ) ) { float pPeek = pBetweenAffiliateOffset ; pAtFrontMostCardTop += pPeek ; } } mMaxScrollP = pAtFrontMostCardTop - ( ( _NUM - pTaskHeightOffset - pNavBarOffset ) ) ; mMinScrollP = data . size ( ) == _NUM ? Math . max ( mMaxScrollP , _NUM ) : _NUM ; if ( launchedWithAltTab && launchedFromHome ) { mInitialScrollP = mMaxScrollP ; } else { mInitialScrollP = pAtFrontMostCardTop - _NUM ; } mInitialScrollP = Math . min ( mMaxScrollP , Math . max ( _NUM , mInitialScrollP ) ) ; }
void computeMinMaxScroll ( ArrayList < T > data , boolean launchedWithAltTab , boolean launchedFromHome ) { mTaskProgressMap . clear ( ) ; if ( data . isEmpty ( ) ) { mMinScrollP = mMaxScrollP = _NUM ; return ; } int taskHeight = mTaskRect . height ( ) ; float pAtBottomOfStackRect = screenYToCurveProgress ( mStackVisibleRect . bottom ) ; float pWithinAffiliateTop = screenYToCurveProgress ( mStackVisibleRect . bottom - mWithinAffiliationOffset ) ; float scale = curveProgressToScale ( pWithinAffiliateTop ) ; int scaleYOffset = ( int ) ( ( ( _NUM - scale ) * taskHeight ) / _NUM ) ; pWithinAffiliateTop = screenYToCurveProgress ( mStackVisibleRect . bottom - mWithinAffiliationOffset + scaleYOffset ) ; float pWithinAffiliateOffset = pAtBottomOfStackRect - pWithinAffiliateTop ; float pBetweenAffiliateOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - mBetweenAffiliationOffset ) ; float pTaskHeightOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - taskHeight ) ; float pNavBarOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - ( mStackVisibleRect . bottom - mStackRect . bottom ) ) ; float pAtBackMostCardTop = _NUM ; float pAtFrontMostCardTop = pAtBackMostCardTop ; int taskCount = data . size ( ) ; for ( int i = _NUM ; i < taskCount ; i ++ ) { mTaskProgressMap . put ( data . get ( i ) , pAtFrontMostCardTop ) ; if ( i < ( taskCount - _NUM ) ) { float pPeek = pBetweenAffiliateOffset ; pAtFrontMostCardTop += pPeek ; } } mMaxScrollP = pAtFrontMostCardTop - ( ( _NUM - pTaskHeightOffset - pNavBarOffset ) ) ; mMinScrollP = data . size ( ) == _NUM ? Math . max ( mMaxScrollP , _NUM ) : _NUM ; if ( launchedWithAltTab && launchedFromHome ) { mInitialScrollP = mMaxScrollP ; } else { mInitialScrollP = pAtFrontMostCardTop - _NUM ; } mInitialScrollP = Math . min ( mMaxScrollP , Math . max ( _NUM , mInitialScrollP ) ) ; }
void computeMinMaxScroll ( ArrayList < T > data , boolean launchedWithAltTab , boolean launchedFromHome ) { mTaskProgressMap . clear ( ) ; if ( data . isEmpty ( ) ) { mMinScrollP = mMaxScrollP = _NUM ; return ; } int taskHeight = mTaskRect . height ( ) ; float pAtBottomOfStackRect = screenYToCurveProgress ( mStackVisibleRect . bottom ) ; float pWithinAffiliateTop = screenYToCurveProgress ( mStackVisibleRect . bottom - mWithinAffiliationOffset ) ; float scale = curveProgressToScale ( pWithinAffiliateTop ) ; int scaleYOffset = ( int ) ( ( ( _NUM - scale ) * taskHeight ) / _NUM ) ; pWithinAffiliateTop = screenYToCurveProgress ( mStackVisibleRect . bottom - mWithinAffiliationOffset + scaleYOffset ) ; float pWithinAffiliateOffset = pAtBottomOfStackRect - pWithinAffiliateTop ; float pBetweenAffiliateOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - mBetweenAffiliationOffset ) ; float pTaskHeightOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - taskHeight ) ; float pNavBarOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - ( mStackVisibleRect . bottom - mStackRect . bottom ) ) ; float pAtBackMostCardTop = _NUM ; float pAtFrontMostCardTop = pAtBackMostCardTop ; int taskCount = data . size ( ) ; for ( int i = _NUM ; i < taskCount ; i ++ ) { mTaskProgressMap . put ( data . get ( i ) , pAtFrontMostCardTop ) ; if ( i < ( taskCount - _NUM ) ) { float pPeek = pBetweenAffiliateOffset ; pAtFrontMostCardTop += pPeek ; } } mMaxScrollP = pAtFrontMostCardTop - ( ( _NUM - pTaskHeightOffset - pNavBarOffset ) ) ; mMinScrollP = data . size ( ) == _NUM ? Math . max ( mMaxScrollP , _NUM ) : _NUM ; if ( launchedWithAltTab && launchedFromHome ) { mInitialScrollP = mMaxScrollP ; } else { mInitialScrollP = pAtFrontMostCardTop - _NUM ; } mInitialScrollP = Math . min ( mMaxScrollP , Math . max ( _NUM , mInitialScrollP ) ) ; }
void computeMinMaxScroll ( ArrayList < T > data , boolean launchedWithAltTab , boolean launchedFromHome ) { mTaskProgressMap . clear ( ) ; if ( data . isEmpty ( ) ) { mMinScrollP = mMaxScrollP = _NUM ; return ; } int taskHeight = mTaskRect . height ( ) ; float pAtBottomOfStackRect = screenYToCurveProgress ( mStackVisibleRect . bottom ) ; float pWithinAffiliateTop = screenYToCurveProgress ( mStackVisibleRect . bottom - mWithinAffiliationOffset ) ; float scale = curveProgressToScale ( pWithinAffiliateTop ) ; int scaleYOffset = ( int ) ( ( ( _NUM - scale ) * taskHeight ) / _NUM ) ; pWithinAffiliateTop = screenYToCurveProgress ( mStackVisibleRect . bottom - mWithinAffiliationOffset + scaleYOffset ) ; float pWithinAffiliateOffset = pAtBottomOfStackRect - pWithinAffiliateTop ; float pBetweenAffiliateOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - mBetweenAffiliationOffset ) ; float pTaskHeightOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - taskHeight ) ; float pNavBarOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - ( mStackVisibleRect . bottom - mStackRect . bottom ) ) ; float pAtBackMostCardTop = _NUM ; float pAtFrontMostCardTop = pAtBackMostCardTop ; int taskCount = data . size ( ) ; for ( int i = _NUM ; i < taskCount ; i ++ ) { mTaskProgressMap . put ( data . get ( i ) , pAtFrontMostCardTop ) ; if ( i < ( taskCount - _NUM ) ) { float pPeek = pBetweenAffiliateOffset ; pAtFrontMostCardTop += pPeek ; } } mMaxScrollP = pAtFrontMostCardTop - ( ( _NUM - pTaskHeightOffset - pNavBarOffset ) ) ; mMinScrollP = data . size ( ) == _NUM ? Math . max ( mMaxScrollP , _NUM ) : _NUM ; if ( launchedWithAltTab && launchedFromHome ) { mInitialScrollP = mMaxScrollP ; } else { mInitialScrollP = pAtFrontMostCardTop - _NUM ; } mInitialScrollP = Math . min ( mMaxScrollP , Math . max ( _NUM , mInitialScrollP ) ) ; }
void computeMinMaxScroll ( ArrayList < T > data , boolean launchedWithAltTab , boolean launchedFromHome ) { mTaskProgressMap . clear ( ) ; if ( data . isEmpty ( ) ) { mMinScrollP = mMaxScrollP = _NUM ; return ; } int taskHeight = mTaskRect . height ( ) ; float pAtBottomOfStackRect = screenYToCurveProgress ( mStackVisibleRect . bottom ) ; float pWithinAffiliateTop = screenYToCurveProgress ( mStackVisibleRect . bottom - mWithinAffiliationOffset ) ; float scale = curveProgressToScale ( pWithinAffiliateTop ) ; int scaleYOffset = ( int ) ( ( ( _NUM - scale ) * taskHeight ) / _NUM ) ; pWithinAffiliateTop = screenYToCurveProgress ( mStackVisibleRect . bottom - mWithinAffiliationOffset + scaleYOffset ) ; float pWithinAffiliateOffset = pAtBottomOfStackRect - pWithinAffiliateTop ; float pBetweenAffiliateOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - mBetweenAffiliationOffset ) ; float pTaskHeightOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - taskHeight ) ; float pNavBarOffset = pAtBottomOfStackRect - screenYToCurveProgress ( mStackVisibleRect . bottom - ( mStackVisibleRect . bottom - mStackRect . bottom ) ) ; float pAtBackMostCardTop = _NUM ; float pAtFrontMostCardTop = pAtBackMostCardTop ; int taskCount = data . size ( ) ; for ( int i = _NUM ; i < taskCount ; i ++ ) { mTaskProgressMap . put ( data . get ( i ) , pAtFrontMostCardTop ) ; if ( i < ( taskCount - _NUM ) ) { float pPeek = pBetweenAffiliateOffset ; pAtFrontMostCardTop += pPeek ; } } mMaxScrollP = pAtFrontMostCardTop - ( ( _NUM - pTaskHeightOffset - pNavBarOffset ) ) ; mMinScrollP = data . size ( ) == _NUM ? Math . max ( mMaxScrollP , _NUM ) : _NUM ; if ( launchedWithAltTab && launchedFromHome ) { mInitialScrollP = mMaxScrollP ; } else { mInitialScrollP = pAtFrontMostCardTop - _NUM ; } mInitialScrollP = Math . min ( mMaxScrollP , Math . max ( _NUM , mInitialScrollP ) ) ; }
private void insertInOrder ( Vector list , MqttWireMessage newMsg ) { int newMsgId = newMsg . getMessageId ( ) ; for ( int i = _NUM ; i < list . size ( ) ; i ++ ) { MqttWireMessage otherMsg = ( MqttWireMessage ) list . elementAt ( i ) ; int otherMsgId = otherMsg . getMessageId ( ) ; if ( otherMsgId > newMsgId ) { list . insertElementAt ( newMsg , i ) ; return ; } } list . addElement ( newMsg ) ; }
private void insertInOrder ( Vector list , MqttWireMessage newMsg ) { int newMsgId = newMsg . getMessageId ( ) ; for ( int i = _NUM ; i < list . size ( ) ; i ++ ) { MqttWireMessage otherMsg = ( MqttWireMessage ) list . elementAt ( i ) ; int otherMsgId = otherMsg . getMessageId ( ) ; if ( otherMsgId > newMsgId ) { list . insertElementAt ( newMsg , i ) ; return ; } } list . addElement ( newMsg ) ; }
private void computeValues ( ) { logger . debug ( STRING ) ; Map < N , Set < D > > allSeeds = new HashMap < N , Set < D > > ( initialSeeds ) ; for ( N unbalancedRetSite : unbalancedRetSites ) { Set < D > seeds = allSeeds . get ( unbalancedRetSite ) ; if ( seeds == null ) { seeds = new HashSet < D > ( ) ; allSeeds . put ( unbalancedRetSite , seeds ) ; } seeds . add ( zeroValue ) ; } for ( Entry < N , Set < D > > seed : allSeeds . entrySet ( ) ) { N startPoint = seed . getKey ( ) ; for ( D val : seed . getValue ( ) ) { setVal ( startPoint , val , valueLattice . bottomElement ( ) ) ; Pair < N , D > superGraphNode = new Pair < N , D > ( startPoint , val ) ; scheduleValueProcessing ( new ValuePropagationTask ( superGraphNode ) ) ; } } logger . debug ( STRING ) ; try { executor . awaitCompletion ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } Set < N > allNonCallStartNodes = icfg . allNonCallStartNodes ( ) ; @ SuppressWarnings ( STRING ) N [ ] nonCallStartNodesArray = ( N [ ] ) new Object [ allNonCallStartNodes . size ( ) ] ; int i = _NUM ; for ( N n : allNonCallStartNodes ) { nonCallStartNodesArray [ i ] = n ; i ++ ; } for ( int t = _NUM ; t < numThreads ; t ++ ) { ValueComputationTask task = new ValueComputationTask ( nonCallStartNodesArray , t ) ; scheduleValueComputationTask ( task ) ; } try { executor . awaitCompletion ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } }
private void computeValues ( ) { logger . debug ( STRING ) ; Map < N , Set < D > > allSeeds = new HashMap < N , Set < D > > ( initialSeeds ) ; for ( N unbalancedRetSite : unbalancedRetSites ) { Set < D > seeds = allSeeds . get ( unbalancedRetSite ) ; if ( seeds == null ) { seeds = new HashSet < D > ( ) ; allSeeds . put ( unbalancedRetSite , seeds ) ; } seeds . add ( zeroValue ) ; } for ( Entry < N , Set < D > > seed : allSeeds . entrySet ( ) ) { N startPoint = seed . getKey ( ) ; for ( D val : seed . getValue ( ) ) { setVal ( startPoint , val , valueLattice . bottomElement ( ) ) ; Pair < N , D > superGraphNode = new Pair < N , D > ( startPoint , val ) ; scheduleValueProcessing ( new ValuePropagationTask ( superGraphNode ) ) ; } } logger . debug ( STRING ) ; try { executor . awaitCompletion ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } Set < N > allNonCallStartNodes = icfg . allNonCallStartNodes ( ) ; @ SuppressWarnings ( STRING ) N [ ] nonCallStartNodesArray = ( N [ ] ) new Object [ allNonCallStartNodes . size ( ) ] ; int i = _NUM ; for ( N n : allNonCallStartNodes ) { nonCallStartNodesArray [ i ] = n ; i ++ ; } for ( int t = _NUM ; t < numThreads ; t ++ ) { ValueComputationTask task = new ValueComputationTask ( nonCallStartNodesArray , t ) ; scheduleValueComputationTask ( task ) ; } try { executor . awaitCompletion ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } }
protected final static void initHardCodedProperties ( Properties p ) { StringTokenizer tokenizer ; tokenizer = new StringTokenizer ( title , STRING ) ; tokenizer . nextToken ( ) ; p . put ( Title , tokenizer . nextToken ( ) ) ; tokenizer = new StringTokenizer ( version , STRING ) ; tokenizer . nextToken ( ) ; p . put ( Version , tokenizer . nextToken ( ) ) ; tokenizer = new StringTokenizer ( build , STRING ) ; tokenizer . nextToken ( ) ; try { p . put ( BuildDate , tokenizer . nextToken ( ) ) ; } catch ( NoSuchElementException e ) { } }
protected final static void initHardCodedProperties ( Properties p ) { StringTokenizer tokenizer ; tokenizer = new StringTokenizer ( title , STRING ) ; tokenizer . nextToken ( ) ; p . put ( Title , tokenizer . nextToken ( ) ) ; tokenizer = new StringTokenizer ( version , STRING ) ; tokenizer . nextToken ( ) ; p . put ( Version , tokenizer . nextToken ( ) ) ; tokenizer = new StringTokenizer ( build , STRING ) ; tokenizer . nextToken ( ) ; try { p . put ( BuildDate , tokenizer . nextToken ( ) ) ; } catch ( NoSuchElementException e ) { } }
protected final static void initHardCodedProperties ( Properties p ) { StringTokenizer tokenizer ; tokenizer = new StringTokenizer ( title , STRING ) ; tokenizer . nextToken ( ) ; p . put ( Title , tokenizer . nextToken ( ) ) ; tokenizer = new StringTokenizer ( version , STRING ) ; tokenizer . nextToken ( ) ; p . put ( Version , tokenizer . nextToken ( ) ) ; tokenizer = new StringTokenizer ( build , STRING ) ; tokenizer . nextToken ( ) ; try { p . put ( BuildDate , tokenizer . nextToken ( ) ) ; } catch ( NoSuchElementException e ) { } }
protected final static void initHardCodedProperties ( Properties p ) { StringTokenizer tokenizer ; tokenizer = new StringTokenizer ( title , STRING ) ; tokenizer . nextToken ( ) ; p . put ( Title , tokenizer . nextToken ( ) ) ; tokenizer = new StringTokenizer ( version , STRING ) ; tokenizer . nextToken ( ) ; p . put ( Version , tokenizer . nextToken ( ) ) ; tokenizer = new StringTokenizer ( build , STRING ) ; tokenizer . nextToken ( ) ; try { p . put ( BuildDate , tokenizer . nextToken ( ) ) ; } catch ( NoSuchElementException e ) { } }
@ Subscribe public synchronized void onStepMoved ( StepMovedEvent event ) { PlatformImpl . runAndWait ( null ) ; }
@ Subscribe public synchronized void onStepMoved ( StepMovedEvent event ) { PlatformImpl . runAndWait ( null ) ; }
@ Subscribe public synchronized void onStepMoved ( StepMovedEvent event ) { PlatformImpl . runAndWait ( null ) ; }
@ Subscribe public synchronized void onStepMoved ( StepMovedEvent event ) { PlatformImpl . runAndWait ( null ) ; }
@ Subscribe public synchronized void onStepMoved ( StepMovedEvent event ) { PlatformImpl . runAndWait ( null ) ; }
@ Subscribe public synchronized void onStepMoved ( StepMovedEvent event ) { PlatformImpl . runAndWait ( null ) ; }
public static String replaceAll ( String source ) { int regionStart = _NUM ; for ( String entity = getNextEntity ( source , regionStart ) ; entity != null ; entity = getNextEntity ( source , regionStart ) ) { String replacement = EntityMap . get ( entity ) ; if ( replacement == null ) { regionStart += entity . length ( ) ; continue ; } source = source . replace ( entity , replacement ) ; regionStart += replacement . length ( ) ; } return source ; }
public static String replaceAll ( String source ) { int regionStart = _NUM ; for ( String entity = getNextEntity ( source , regionStart ) ; entity != null ; entity = getNextEntity ( source , regionStart ) ) { String replacement = EntityMap . get ( entity ) ; if ( replacement == null ) { regionStart += entity . length ( ) ; continue ; } source = source . replace ( entity , replacement ) ; regionStart += replacement . length ( ) ; } return source ; }
public static String replaceAll ( String source ) { int regionStart = _NUM ; for ( String entity = getNextEntity ( source , regionStart ) ; entity != null ; entity = getNextEntity ( source , regionStart ) ) { String replacement = EntityMap . get ( entity ) ; if ( replacement == null ) { regionStart += entity . length ( ) ; continue ; } source = source . replace ( entity , replacement ) ; regionStart += replacement . length ( ) ; } return source ; }
@ Override public Action execute ( Percept percept ) { kb . makePerceptSentence ( ( AgentPercept ) percept , t ) ; kb . tellTemporalPhysicsSentences ( t ) ; AgentPosition current = kb . askCurrentPosition ( t ) ; Set < Room > safe = kb . askSafeRooms ( t ) ; if ( kb . askGlitter ( t ) ) { Set < Room > goals = new LinkedHashSet < Room > ( ) ; goals . add ( new Room ( _NUM , _NUM ) ) ; plan . add ( new Grab ( ) ) ; plan . addAll ( planRoute ( current , goals , safe ) ) ; plan . add ( new Climb ( ) ) ; } Set < Room > unvisited = kb . askUnvisitedRooms ( t ) ; if ( plan . isEmpty ( ) ) { plan . addAll ( planRoute ( current , SetOps . intersection ( unvisited , safe ) , safe ) ) ; } if ( plan . isEmpty ( ) && kb . askHaveArrow ( t ) ) { Set < Room > possibleWumpus = kb . askPossibleWumpusRooms ( t ) ; plan . addAll ( planShot ( current , possibleWumpus , safe ) ) ; } if ( plan . isEmpty ( ) ) { Set < Room > notUnsafe = kb . askNotUnsafeRooms ( t ) ; plan . addAll ( planRoute ( current , SetOps . intersection ( unvisited , notUnsafe ) , safe ) ) ; } if ( plan . isEmpty ( ) ) { Set < Room > start = new LinkedHashSet < Room > ( ) ; start . add ( new Room ( _NUM , _NUM ) ) ; plan . addAll ( planRoute ( current , start , safe ) ) ; plan . add ( new Climb ( ) ) ; } Action action = plan . remove ( ) ; kb . makeActionSentence ( action , t ) ; t = t + _NUM ; return action ; }
@ Override public Action execute ( Percept percept ) { kb . makePerceptSentence ( ( AgentPercept ) percept , t ) ; kb . tellTemporalPhysicsSentences ( t ) ; AgentPosition current = kb . askCurrentPosition ( t ) ; Set < Room > safe = kb . askSafeRooms ( t ) ; if ( kb . askGlitter ( t ) ) { Set < Room > goals = new LinkedHashSet < Room > ( ) ; goals . add ( new Room ( _NUM , _NUM ) ) ; plan . add ( new Grab ( ) ) ; plan . addAll ( planRoute ( current , goals , safe ) ) ; plan . add ( new Climb ( ) ) ; } Set < Room > unvisited = kb . askUnvisitedRooms ( t ) ; if ( plan . isEmpty ( ) ) { plan . addAll ( planRoute ( current , SetOps . intersection ( unvisited , safe ) , safe ) ) ; } if ( plan . isEmpty ( ) && kb . askHaveArrow ( t ) ) { Set < Room > possibleWumpus = kb . askPossibleWumpusRooms ( t ) ; plan . addAll ( planShot ( current , possibleWumpus , safe ) ) ; } if ( plan . isEmpty ( ) ) { Set < Room > notUnsafe = kb . askNotUnsafeRooms ( t ) ; plan . addAll ( planRoute ( current , SetOps . intersection ( unvisited , notUnsafe ) , safe ) ) ; } if ( plan . isEmpty ( ) ) { Set < Room > start = new LinkedHashSet < Room > ( ) ; start . add ( new Room ( _NUM , _NUM ) ) ; plan . addAll ( planRoute ( current , start , safe ) ) ; plan . add ( new Climb ( ) ) ; } Action action = plan . remove ( ) ; kb . makeActionSentence ( action , t ) ; t = t + _NUM ; return action ; }
private int findBin ( double value ) { return FastMath . min ( FastMath . max ( ( int ) FastMath . ceil ( ( value - min ) / delta ) - _NUM , _NUM ) , binCount - _NUM ) ; }
private int findBin ( double value ) { return FastMath . min ( FastMath . max ( ( int ) FastMath . ceil ( ( value - min ) / delta ) - _NUM , _NUM ) , binCount - _NUM ) ; }
protected void reopen ( ) throws IOException { if ( inputStream != null ) { Debug . message ( STRING , STRING ) ; inputStream . close ( ) ; } inputStreamCount = _NUM ; }
protected void reopen ( ) throws IOException { if ( inputStream != null ) { Debug . message ( STRING , STRING ) ; inputStream . close ( ) ; } inputStreamCount = _NUM ; }
protected void reopen ( ) throws IOException { if ( inputStream != null ) { Debug . message ( STRING , STRING ) ; inputStream . close ( ) ; } inputStreamCount = _NUM ; }
protected void reopen ( ) throws IOException { if ( inputStream != null ) { Debug . message ( STRING , STRING ) ; inputStream . close ( ) ; } inputStreamCount = _NUM ; }