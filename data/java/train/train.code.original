public Object [ ] toArray ( ) { fullyLock ( ) ; try { int size = count . get ( ) ; Object [ ] a = new Object [ size ] ; int k = _NUM ; for ( Node < E > p = head . next ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { fullyUnlock ( ) ; } }
public Object [ ] toArray ( ) { fullyLock ( ) ; try { int size = count . get ( ) ; Object [ ] a = new Object [ size ] ; int k = _NUM ; for ( Node < E > p = head . next ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { fullyUnlock ( ) ; } }
public Object [ ] toArray ( ) { fullyLock ( ) ; try { int size = count . get ( ) ; Object [ ] a = new Object [ size ] ; int k = _NUM ; for ( Node < E > p = head . next ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { fullyUnlock ( ) ; } }
public Object [ ] toArray ( ) { fullyLock ( ) ; try { int size = count . get ( ) ; Object [ ] a = new Object [ size ] ; int k = _NUM ; for ( Node < E > p = head . next ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { fullyUnlock ( ) ; } }
public Object [ ] toArray ( ) { fullyLock ( ) ; try { int size = count . get ( ) ; Object [ ] a = new Object [ size ] ; int k = _NUM ; for ( Node < E > p = head . next ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { fullyUnlock ( ) ; } }
public Object [ ] toArray ( ) { fullyLock ( ) ; try { int size = count . get ( ) ; Object [ ] a = new Object [ size ] ; int k = _NUM ; for ( Node < E > p = head . next ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { fullyUnlock ( ) ; } }
public Object [ ] toArray ( ) { fullyLock ( ) ; try { int size = count . get ( ) ; Object [ ] a = new Object [ size ] ; int k = _NUM ; for ( Node < E > p = head . next ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { fullyUnlock ( ) ; } }
public Object [ ] toArray ( ) { fullyLock ( ) ; try { int size = count . get ( ) ; Object [ ] a = new Object [ size ] ; int k = _NUM ; for ( Node < E > p = head . next ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { fullyUnlock ( ) ; } }
public Object [ ] toArray ( ) { fullyLock ( ) ; try { int size = count . get ( ) ; Object [ ] a = new Object [ size ] ; int k = _NUM ; for ( Node < E > p = head . next ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { fullyUnlock ( ) ; } }
public static void v ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_VERBOSE ) { return ; } if ( args . length > _NUM ) { msg = String . format ( msg , args ) ; } Log . v ( tag , msg ) ; }
public static void v ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_VERBOSE ) { return ; } if ( args . length > _NUM ) { msg = String . format ( msg , args ) ; } Log . v ( tag , msg ) ; }
DatabaseClusterUnit ( ByteBuffer bb ) throws IOException { this . type = bb . getInt ( ) ; this . phone = bb . getInt ( ) ; this . start = bb . getInt ( ) ; this . end = bb . getInt ( ) ; this . prev = bb . getInt ( ) ; this . next = bb . getInt ( ) ; }
DatabaseClusterUnit ( ByteBuffer bb ) throws IOException { this . type = bb . getInt ( ) ; this . phone = bb . getInt ( ) ; this . start = bb . getInt ( ) ; this . end = bb . getInt ( ) ; this . prev = bb . getInt ( ) ; this . next = bb . getInt ( ) ; }
DatabaseClusterUnit ( ByteBuffer bb ) throws IOException { this . type = bb . getInt ( ) ; this . phone = bb . getInt ( ) ; this . start = bb . getInt ( ) ; this . end = bb . getInt ( ) ; this . prev = bb . getInt ( ) ; this . next = bb . getInt ( ) ; }
private List < String > toList ( String [ ] array ) { List < String > ret = new ArrayList < String > ( ) ; if ( array != null && array . length > _NUM ) { ret . addAll ( Arrays . asList ( array ) ) ; } return ret ; }
private List < String > toList ( String [ ] array ) { List < String > ret = new ArrayList < String > ( ) ; if ( array != null && array . length > _NUM ) { ret . addAll ( Arrays . asList ( array ) ) ; } return ret ; }
private List < String > toList ( String [ ] array ) { List < String > ret = new ArrayList < String > ( ) ; if ( array != null && array . length > _NUM ) { ret . addAll ( Arrays . asList ( array ) ) ; } return ret ; }
private List < String > toList ( String [ ] array ) { List < String > ret = new ArrayList < String > ( ) ; if ( array != null && array . length > _NUM ) { ret . addAll ( Arrays . asList ( array ) ) ; } return ret ; }
public void write ( String str , int off , int len ) throws IOException { synchronized ( lock ) { char cbuf [ ] ; if ( len <= WRITE_BUFFER_SIZE ) { if ( writeBuffer == null ) { writeBuffer = new char [ WRITE_BUFFER_SIZE ] ; } cbuf = writeBuffer ; } else { cbuf = new char [ len ] ; } str . getChars ( off , ( off + len ) , cbuf , _NUM ) ; write ( cbuf , _NUM , len ) ; } }
public void write ( String str , int off , int len ) throws IOException { synchronized ( lock ) { char cbuf [ ] ; if ( len <= WRITE_BUFFER_SIZE ) { if ( writeBuffer == null ) { writeBuffer = new char [ WRITE_BUFFER_SIZE ] ; } cbuf = writeBuffer ; } else { cbuf = new char [ len ] ; } str . getChars ( off , ( off + len ) , cbuf , _NUM ) ; write ( cbuf , _NUM , len ) ; } }
private String decodeTitleWikistyle ( String pTitle ) { String encodedTitle = pTitle . replace ( STRING , STRING ) ; return encodedTitle ; }
private String decodeTitleWikistyle ( String pTitle ) { String encodedTitle = pTitle . replace ( STRING , STRING ) ; return encodedTitle ; }
private String decodeTitleWikistyle ( String pTitle ) { String encodedTitle = pTitle . replace ( STRING , STRING ) ; return encodedTitle ; }
private String decodeTitleWikistyle ( String pTitle ) { String encodedTitle = pTitle . replace ( STRING , STRING ) ; return encodedTitle ; }
private XYPlot initializeUpperPlot ( ) { heapMemory = new YIntervalSeriesImproved ( STRING ) ; YIntervalSeriesCollection yintervalseriescollection = new YIntervalSeriesCollection ( ) ; yintervalseriescollection . addSeries ( heapMemory ) ; DeviationRenderer renderer = new DeviationRenderer ( _BOOL , _BOOL ) ; renderer . setBaseShapesVisible ( _BOOL ) ; renderer . setSeriesStroke ( _NUM , new BasicStroke ( _NUM , BasicStroke . CAP_ROUND , BasicStroke . JOIN_ROUND ) ) ; renderer . setSeriesFillPaint ( _NUM , new Color ( _NUM , _NUM , _NUM ) ) ; renderer . setSeriesOutlineStroke ( _NUM , new BasicStroke ( _NUM ) ) ; renderer . setSeriesShape ( _NUM , new Ellipse2D . Double ( - _NUM , - _NUM , _NUM , _NUM ) ) ; renderer . setBaseToolTipGenerator ( new StandardXYToolTipGenerator ( StandardXYToolTipGenerator . DEFAULT_TOOL_TIP_FORMAT , DateFormat . getDateTimeInstance ( ) , NumberFormat . getNumberInstance ( ) ) ) ; final NumberAxis rangeAxis = new NumberAxis ( STRING ) ; rangeAxis . setRangeType ( RangeType . POSITIVE ) ; SystemInformationData systemData = ( SystemInformationData ) dataAccessService . getLastDataObject ( systemTemplate ) ; if ( systemData != null ) { double maxHeapUpperRange ; if ( systemData . getMaxHeapMemorySize ( ) != - _NUM ) { maxHeapUpperRange = systemData . getMaxHeapMemorySize ( ) / _NUM ; } else if ( systemData . getInitHeapMemorySize ( ) != - _NUM ) { maxHeapUpperRange = ( systemData . getInitHeapMemorySize ( ) * _NUM ) / _NUM ; } else { maxHeapUpperRange = _NUM * _NUM * _NUM ; } rangeAxis . setRange ( _NUM , maxHeapUpperRange ) ; rangeAxis . setAutoRangeMinimumSize ( maxHeapUpperRange ) ; } final XYPlot subplot = new XYPlot ( yintervalseriescollection , null , rangeAxis , renderer ) ; subplot . setAxisOffset ( new RectangleInsets ( _NUM , _NUM , _NUM , _NUM ) ) ; subplot . setRangeAxisLocation ( AxisLocation . TOP_OR_LEFT ) ; subplot . setRangeCrosshairVisible ( _BOOL ) ; return subplot ; }
private XYPlot initializeUpperPlot ( ) { heapMemory = new YIntervalSeriesImproved ( STRING ) ; YIntervalSeriesCollection yintervalseriescollection = new YIntervalSeriesCollection ( ) ; yintervalseriescollection . addSeries ( heapMemory ) ; DeviationRenderer renderer = new DeviationRenderer ( _BOOL , _BOOL ) ; renderer . setBaseShapesVisible ( _BOOL ) ; renderer . setSeriesStroke ( _NUM , new BasicStroke ( _NUM , BasicStroke . CAP_ROUND , BasicStroke . JOIN_ROUND ) ) ; renderer . setSeriesFillPaint ( _NUM , new Color ( _NUM , _NUM , _NUM ) ) ; renderer . setSeriesOutlineStroke ( _NUM , new BasicStroke ( _NUM ) ) ; renderer . setSeriesShape ( _NUM , new Ellipse2D . Double ( - _NUM , - _NUM , _NUM , _NUM ) ) ; renderer . setBaseToolTipGenerator ( new StandardXYToolTipGenerator ( StandardXYToolTipGenerator . DEFAULT_TOOL_TIP_FORMAT , DateFormat . getDateTimeInstance ( ) , NumberFormat . getNumberInstance ( ) ) ) ; final NumberAxis rangeAxis = new NumberAxis ( STRING ) ; rangeAxis . setRangeType ( RangeType . POSITIVE ) ; SystemInformationData systemData = ( SystemInformationData ) dataAccessService . getLastDataObject ( systemTemplate ) ; if ( systemData != null ) { double maxHeapUpperRange ; if ( systemData . getMaxHeapMemorySize ( ) != - _NUM ) { maxHeapUpperRange = systemData . getMaxHeapMemorySize ( ) / _NUM ; } else if ( systemData . getInitHeapMemorySize ( ) != - _NUM ) { maxHeapUpperRange = ( systemData . getInitHeapMemorySize ( ) * _NUM ) / _NUM ; } else { maxHeapUpperRange = _NUM * _NUM * _NUM ; } rangeAxis . setRange ( _NUM , maxHeapUpperRange ) ; rangeAxis . setAutoRangeMinimumSize ( maxHeapUpperRange ) ; } final XYPlot subplot = new XYPlot ( yintervalseriescollection , null , rangeAxis , renderer ) ; subplot . setAxisOffset ( new RectangleInsets ( _NUM , _NUM , _NUM , _NUM ) ) ; subplot . setRangeAxisLocation ( AxisLocation . TOP_OR_LEFT ) ; subplot . setRangeCrosshairVisible ( _BOOL ) ; return subplot ; }
SingleTimedScheduler ( ThreadFactory threadFactory ) { ScheduledThreadPoolExecutor e = ( ScheduledThreadPoolExecutor ) Executors . newScheduledThreadPool ( _NUM , threadFactory ) ; e . setRemoveOnCancelPolicy ( _BOOL ) ; executor = e ; }
public void addAttribute ( Object name , Object value ) { table . put ( name , value ) ; }
public void addAttribute ( Object name , Object value ) { table . put ( name , value ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( ) ; newVector . addElement ( new Option ( STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( ) ; newVector . addElement ( new Option ( STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( ) ; newVector . addElement ( new Option ( STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
private byte [ ] [ ] extractIPsAndSubnetMasks ( byte [ ] ipWithSubmask1 , byte [ ] ipWithSubmask2 ) { int ipLength = ipWithSubmask1 . length / _NUM ; byte ip1 [ ] = new byte [ ipLength ] ; byte subnetmask1 [ ] = new byte [ ipLength ] ; System . arraycopy ( ipWithSubmask1 , _NUM , ip1 , _NUM , ipLength ) ; System . arraycopy ( ipWithSubmask1 , ipLength , subnetmask1 , _NUM , ipLength ) ; byte ip2 [ ] = new byte [ ipLength ] ; byte subnetmask2 [ ] = new byte [ ipLength ] ; System . arraycopy ( ipWithSubmask2 , _NUM , ip2 , _NUM , ipLength ) ; System . arraycopy ( ipWithSubmask2 , ipLength , subnetmask2 , _NUM , ipLength ) ; return new byte [ ] [ ] { ip1 , subnetmask1 , ip2 , subnetmask2 } ; }
private byte [ ] [ ] extractIPsAndSubnetMasks ( byte [ ] ipWithSubmask1 , byte [ ] ipWithSubmask2 ) { int ipLength = ipWithSubmask1 . length / _NUM ; byte ip1 [ ] = new byte [ ipLength ] ; byte subnetmask1 [ ] = new byte [ ipLength ] ; System . arraycopy ( ipWithSubmask1 , _NUM , ip1 , _NUM , ipLength ) ; System . arraycopy ( ipWithSubmask1 , ipLength , subnetmask1 , _NUM , ipLength ) ; byte ip2 [ ] = new byte [ ipLength ] ; byte subnetmask2 [ ] = new byte [ ipLength ] ; System . arraycopy ( ipWithSubmask2 , _NUM , ip2 , _NUM , ipLength ) ; System . arraycopy ( ipWithSubmask2 , ipLength , subnetmask2 , _NUM , ipLength ) ; return new byte [ ] [ ] { ip1 , subnetmask1 , ip2 , subnetmask2 } ; }
private void initBackupComponents ( ) throws SpaceComponentsInitializeException { for ( Iterator < ISpaceComponentsHandler > iterator = _componentsHandlers . iterator ( ) ; iterator . hasNext ( ) ; ) { ISpaceComponentsHandler handler = iterator . next ( ) ; if ( ! handler . isRecoverySupported ( ) ) handler . initComponents ( _BOOL ) ; } }
private void initBackupComponents ( ) throws SpaceComponentsInitializeException { for ( Iterator < ISpaceComponentsHandler > iterator = _componentsHandlers . iterator ( ) ; iterator . hasNext ( ) ; ) { ISpaceComponentsHandler handler = iterator . next ( ) ; if ( ! handler . isRecoverySupported ( ) ) handler . initComponents ( _BOOL ) ; } }
public void leave ( MetricReference metricReference ) { Thread threadId = Thread . currentThread ( ) ; leave ( threadId , metricReference ) ; }
public void leave ( MetricReference metricReference ) { Thread threadId = Thread . currentThread ( ) ; leave ( threadId , metricReference ) ; }
public void leave ( MetricReference metricReference ) { Thread threadId = Thread . currentThread ( ) ; leave ( threadId , metricReference ) ; }
public void leave ( MetricReference metricReference ) { Thread threadId = Thread . currentThread ( ) ; leave ( threadId , metricReference ) ; }
public void leave ( MetricReference metricReference ) { Thread threadId = Thread . currentThread ( ) ; leave ( threadId , metricReference ) ; }
public void leave ( MetricReference metricReference ) { Thread threadId = Thread . currentThread ( ) ; leave ( threadId , metricReference ) ; }
public void leave ( MetricReference metricReference ) { Thread threadId = Thread . currentThread ( ) ; leave ( threadId , metricReference ) ; }
public void leave ( MetricReference metricReference ) { Thread threadId = Thread . currentThread ( ) ; leave ( threadId , metricReference ) ; }
public void leave ( MetricReference metricReference ) { Thread threadId = Thread . currentThread ( ) ; leave ( threadId , metricReference ) ; }
private void readCRLF ( ) throws IOException { int cr = in . read ( ) ; int lf = in . read ( ) ; if ( ( cr != STRING ) || ( lf != STRING ) ) { throw new IOException ( STRING + cr + STRING + lf ) ; } }
private void readCRLF ( ) throws IOException { int cr = in . read ( ) ; int lf = in . read ( ) ; if ( ( cr != STRING ) || ( lf != STRING ) ) { throw new IOException ( STRING + cr + STRING + lf ) ; } }
public CoreDescriptor ( CoreContainer container , String name , Path instanceDir , Map < String , String > coreProps ) { this . coreContainer = container ; this . instanceDir = instanceDir ; originalCoreProperties . setProperty ( CORE_NAME , name ) ; Properties containerProperties = container . getContainerProperties ( ) ; name = PropertiesUtil . substituteProperty ( checkPropertyIsNotEmpty ( name , CORE_NAME ) , containerProperties ) ; coreProperties . putAll ( defaultProperties ) ; coreProperties . put ( CORE_NAME , name ) ; for ( String propname : coreProps . keySet ( ) ) { String propvalue = coreProps . get ( propname ) ; if ( isUserDefinedProperty ( propname ) ) originalExtraProperties . put ( propname , propvalue ) ; else originalCoreProperties . put ( propname , propvalue ) ; if ( ! requiredProperties . contains ( propname ) ) coreProperties . setProperty ( propname , PropertiesUtil . substituteProperty ( propvalue , containerProperties ) ) ; } loadExtraProperties ( ) ; buildSubstitutableProperties ( ) ; if ( container . isZooKeeperAware ( ) ) { cloudDesc = new CloudDescriptor ( name , coreProperties , this ) ; } else { cloudDesc = null ; } log . debug ( STRING + coreProperties ) ; }
public CoreDescriptor ( CoreContainer container , String name , Path instanceDir , Map < String , String > coreProps ) { this . coreContainer = container ; this . instanceDir = instanceDir ; originalCoreProperties . setProperty ( CORE_NAME , name ) ; Properties containerProperties = container . getContainerProperties ( ) ; name = PropertiesUtil . substituteProperty ( checkPropertyIsNotEmpty ( name , CORE_NAME ) , containerProperties ) ; coreProperties . putAll ( defaultProperties ) ; coreProperties . put ( CORE_NAME , name ) ; for ( String propname : coreProps . keySet ( ) ) { String propvalue = coreProps . get ( propname ) ; if ( isUserDefinedProperty ( propname ) ) originalExtraProperties . put ( propname , propvalue ) ; else originalCoreProperties . put ( propname , propvalue ) ; if ( ! requiredProperties . contains ( propname ) ) coreProperties . setProperty ( propname , PropertiesUtil . substituteProperty ( propvalue , containerProperties ) ) ; } loadExtraProperties ( ) ; buildSubstitutableProperties ( ) ; if ( container . isZooKeeperAware ( ) ) { cloudDesc = new CloudDescriptor ( name , coreProperties , this ) ; } else { cloudDesc = null ; } log . debug ( STRING + coreProperties ) ; }
public void write ( BufferedImage bimg , String filePath ) throws IOException { File file = new File ( filePath ) ; if ( file . exists ( ) ) { if ( ! file . delete ( ) ) { throw new IOException ( STRING + filePath + STRING + STRING ) ; } } else { if ( ! file . createNewFile ( ) ) { throw new IOException ( STRING + filePath + STRING + STRING ) ; } } OutputStream fos = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; try { write ( bimg , fos ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { } } }
public void write ( BufferedImage bimg , String filePath ) throws IOException { File file = new File ( filePath ) ; if ( file . exists ( ) ) { if ( ! file . delete ( ) ) { throw new IOException ( STRING + filePath + STRING + STRING ) ; } } else { if ( ! file . createNewFile ( ) ) { throw new IOException ( STRING + filePath + STRING + STRING ) ; } } OutputStream fos = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; try { write ( bimg , fos ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { } } }
public void write ( BufferedImage bimg , String filePath ) throws IOException { File file = new File ( filePath ) ; if ( file . exists ( ) ) { if ( ! file . delete ( ) ) { throw new IOException ( STRING + filePath + STRING + STRING ) ; } } else { if ( ! file . createNewFile ( ) ) { throw new IOException ( STRING + filePath + STRING + STRING ) ; } } OutputStream fos = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; try { write ( bimg , fos ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { } } }
public void write ( BufferedImage bimg , String filePath ) throws IOException { File file = new File ( filePath ) ; if ( file . exists ( ) ) { if ( ! file . delete ( ) ) { throw new IOException ( STRING + filePath + STRING + STRING ) ; } } else { if ( ! file . createNewFile ( ) ) { throw new IOException ( STRING + filePath + STRING + STRING ) ; } } OutputStream fos = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; try { write ( bimg , fos ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { } } }
public void write ( BufferedImage bimg , String filePath ) throws IOException { File file = new File ( filePath ) ; if ( file . exists ( ) ) { if ( ! file . delete ( ) ) { throw new IOException ( STRING + filePath + STRING + STRING ) ; } } else { if ( ! file . createNewFile ( ) ) { throw new IOException ( STRING + filePath + STRING + STRING ) ; } } OutputStream fos = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; try { write ( bimg , fos ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { } } }
public void write ( BufferedImage bimg , String filePath ) throws IOException { File file = new File ( filePath ) ; if ( file . exists ( ) ) { if ( ! file . delete ( ) ) { throw new IOException ( STRING + filePath + STRING + STRING ) ; } } else { if ( ! file . createNewFile ( ) ) { throw new IOException ( STRING + filePath + STRING + STRING ) ; } } OutputStream fos = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; try { write ( bimg , fos ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { } } }
public void test_transferTo_couldDelete ( ) throws Exception { writeDataToFile ( fileOfReadOnlyFileChannel ) ; writeDataToFile ( fileOfWriteOnlyFileChannel ) ; readOnlyFileChannel . transferTo ( _NUM , _NUM , writeOnlyFileChannel ) ; readOnlyFileChannel . close ( ) ; writeOnlyFileChannel . close ( ) ; boolean rDel = fileOfReadOnlyFileChannel . delete ( ) ; boolean wDel = fileOfWriteOnlyFileChannel . delete ( ) ; assertTrue ( STRING + readOnlyFileChannel + STRING , rDel ) ; assertTrue ( STRING + writeOnlyFileChannel + STRING , wDel ) ; }
public void test_transferTo_couldDelete ( ) throws Exception { writeDataToFile ( fileOfReadOnlyFileChannel ) ; writeDataToFile ( fileOfWriteOnlyFileChannel ) ; readOnlyFileChannel . transferTo ( _NUM , _NUM , writeOnlyFileChannel ) ; readOnlyFileChannel . close ( ) ; writeOnlyFileChannel . close ( ) ; boolean rDel = fileOfReadOnlyFileChannel . delete ( ) ; boolean wDel = fileOfWriteOnlyFileChannel . delete ( ) ; assertTrue ( STRING + readOnlyFileChannel + STRING , rDel ) ; assertTrue ( STRING + writeOnlyFileChannel + STRING , wDel ) ; }
public void test_transferTo_couldDelete ( ) throws Exception { writeDataToFile ( fileOfReadOnlyFileChannel ) ; writeDataToFile ( fileOfWriteOnlyFileChannel ) ; readOnlyFileChannel . transferTo ( _NUM , _NUM , writeOnlyFileChannel ) ; readOnlyFileChannel . close ( ) ; writeOnlyFileChannel . close ( ) ; boolean rDel = fileOfReadOnlyFileChannel . delete ( ) ; boolean wDel = fileOfWriteOnlyFileChannel . delete ( ) ; assertTrue ( STRING + readOnlyFileChannel + STRING , rDel ) ; assertTrue ( STRING + writeOnlyFileChannel + STRING , wDel ) ; }
public boolean removeName ( String name ) { return m_names . remove ( name ) ; }
public boolean removeName ( String name ) { return m_names . remove ( name ) ; }
private static void popTransactionStartStamp ( Transaction t ) { Map < Transaction , Timestamp > map = suspendedTxStartStamps . get ( ) ; if ( map . size ( ) > _NUM ) { Timestamp stamp = map . remove ( t ) ; if ( stamp != null ) { transactionStartStamp . set ( stamp ) ; } else { Debug . logError ( STRING , module ) ; transactionStartStamp . set ( UtilDateTime . nowTimestamp ( ) ) ; } } }
private static void popTransactionStartStamp ( Transaction t ) { Map < Transaction , Timestamp > map = suspendedTxStartStamps . get ( ) ; if ( map . size ( ) > _NUM ) { Timestamp stamp = map . remove ( t ) ; if ( stamp != null ) { transactionStartStamp . set ( stamp ) ; } else { Debug . logError ( STRING , module ) ; transactionStartStamp . set ( UtilDateTime . nowTimestamp ( ) ) ; } } }
private static void popTransactionStartStamp ( Transaction t ) { Map < Transaction , Timestamp > map = suspendedTxStartStamps . get ( ) ; if ( map . size ( ) > _NUM ) { Timestamp stamp = map . remove ( t ) ; if ( stamp != null ) { transactionStartStamp . set ( stamp ) ; } else { Debug . logError ( STRING , module ) ; transactionStartStamp . set ( UtilDateTime . nowTimestamp ( ) ) ; } } }
private static void popTransactionStartStamp ( Transaction t ) { Map < Transaction , Timestamp > map = suspendedTxStartStamps . get ( ) ; if ( map . size ( ) > _NUM ) { Timestamp stamp = map . remove ( t ) ; if ( stamp != null ) { transactionStartStamp . set ( stamp ) ; } else { Debug . logError ( STRING , module ) ; transactionStartStamp . set ( UtilDateTime . nowTimestamp ( ) ) ; } } }
public static String generateRandomFinNumber ( Delegator delegator , int length , boolean isId ) throws GenericEntityException { if ( length > _NUM ) { length = _NUM ; } Random rand = new Random ( ) ; boolean isValid = _BOOL ; String number = null ; while ( ! isValid ) { number = STRING ; for ( int i = _NUM ; i < length ; i ++ ) { int randInt = rand . nextInt ( _NUM ) ; number = number + randInt ; } if ( isId ) { int check = UtilValidate . getLuhnCheckDigit ( number ) ; number = number + check ; if ( checkFinAccountNumber ( number ) ) { isValid = checkIsNumberInDatabase ( delegator , number ) ; } } else { isValid = _BOOL ; } } return number ; }
public static String generateRandomFinNumber ( Delegator delegator , int length , boolean isId ) throws GenericEntityException { if ( length > _NUM ) { length = _NUM ; } Random rand = new Random ( ) ; boolean isValid = _BOOL ; String number = null ; while ( ! isValid ) { number = STRING ; for ( int i = _NUM ; i < length ; i ++ ) { int randInt = rand . nextInt ( _NUM ) ; number = number + randInt ; } if ( isId ) { int check = UtilValidate . getLuhnCheckDigit ( number ) ; number = number + check ; if ( checkFinAccountNumber ( number ) ) { isValid = checkIsNumberInDatabase ( delegator , number ) ; } } else { isValid = _BOOL ; } } return number ; }
private static String generateRandomString ( ) { final StringBuilder res = new StringBuilder ( ) ; final Random rnd = new SecureRandom ( ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { int pos = ( int ) ( rnd . nextFloat ( ) * CHARS . length ( ) ) ; res . append ( CHARS . charAt ( pos ) ) ; } return res . toString ( ) ; }
private static String generateRandomString ( ) { final StringBuilder res = new StringBuilder ( ) ; final Random rnd = new SecureRandom ( ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { int pos = ( int ) ( rnd . nextFloat ( ) * CHARS . length ( ) ) ; res . append ( CHARS . charAt ( pos ) ) ; } return res . toString ( ) ; }
public void enable ( ) throws IOException { synchronized ( optOutLock ) { if ( isOptOut ( ) ) { properties . setProperty ( STRING , STRING ) ; properties . store ( new FileOutputStream ( configurationFile ) , STRING ) ; } if ( thread == null ) { start ( ) ; } } }
private void refreshMarkers ( ) { removeAll ( ) ; Map markerMap = new HashMap ( ) ; List notices = textArea . getParserNotices ( ) ; for ( Iterator i = notices . iterator ( ) ; i . hasNext ( ) ; ) { ParserNotice notice = ( ParserNotice ) i . next ( ) ; if ( notice . getLevel ( ) <= levelThreshold || ( notice instanceof TaskNotice ) ) { Integer key = new Integer ( notice . getLine ( ) ) ; Marker m = ( Marker ) markerMap . get ( key ) ; if ( m == null ) { m = new Marker ( notice ) ; m . addMouseListener ( listener ) ; markerMap . put ( key , m ) ; add ( m ) ; } else { m . addNotice ( notice ) ; } } } if ( getShowMarkedOccurrences ( ) && textArea . getMarkOccurrences ( ) ) { List occurrences = textArea . getMarkedOccurrences ( ) ; for ( Iterator i = occurrences . iterator ( ) ; i . hasNext ( ) ; ) { DocumentRange range = ( DocumentRange ) i . next ( ) ; int line = _NUM ; try { line = textArea . getLineOfOffset ( range . getStartOffset ( ) ) ; } catch ( BadLocationException ble ) { continue ; } ParserNotice notice = new MarkedOccurrenceNotice ( range ) ; Integer key = new Integer ( line ) ; Marker m = ( Marker ) markerMap . get ( key ) ; if ( m == null ) { m = new Marker ( notice ) ; m . addMouseListener ( listener ) ; markerMap . put ( key , m ) ; add ( m ) ; } else { if ( ! m . containsMarkedOccurence ( ) ) { m . addNotice ( notice ) ; } } } } revalidate ( ) ; repaint ( ) ; }
private void refreshMarkers ( ) { removeAll ( ) ; Map markerMap = new HashMap ( ) ; List notices = textArea . getParserNotices ( ) ; for ( Iterator i = notices . iterator ( ) ; i . hasNext ( ) ; ) { ParserNotice notice = ( ParserNotice ) i . next ( ) ; if ( notice . getLevel ( ) <= levelThreshold || ( notice instanceof TaskNotice ) ) { Integer key = new Integer ( notice . getLine ( ) ) ; Marker m = ( Marker ) markerMap . get ( key ) ; if ( m == null ) { m = new Marker ( notice ) ; m . addMouseListener ( listener ) ; markerMap . put ( key , m ) ; add ( m ) ; } else { m . addNotice ( notice ) ; } } } if ( getShowMarkedOccurrences ( ) && textArea . getMarkOccurrences ( ) ) { List occurrences = textArea . getMarkedOccurrences ( ) ; for ( Iterator i = occurrences . iterator ( ) ; i . hasNext ( ) ; ) { DocumentRange range = ( DocumentRange ) i . next ( ) ; int line = _NUM ; try { line = textArea . getLineOfOffset ( range . getStartOffset ( ) ) ; } catch ( BadLocationException ble ) { continue ; } ParserNotice notice = new MarkedOccurrenceNotice ( range ) ; Integer key = new Integer ( line ) ; Marker m = ( Marker ) markerMap . get ( key ) ; if ( m == null ) { m = new Marker ( notice ) ; m . addMouseListener ( listener ) ; markerMap . put ( key , m ) ; add ( m ) ; } else { if ( ! m . containsMarkedOccurence ( ) ) { m . addNotice ( notice ) ; } } } } revalidate ( ) ; repaint ( ) ; }
private void refreshMarkers ( ) { removeAll ( ) ; Map markerMap = new HashMap ( ) ; List notices = textArea . getParserNotices ( ) ; for ( Iterator i = notices . iterator ( ) ; i . hasNext ( ) ; ) { ParserNotice notice = ( ParserNotice ) i . next ( ) ; if ( notice . getLevel ( ) <= levelThreshold || ( notice instanceof TaskNotice ) ) { Integer key = new Integer ( notice . getLine ( ) ) ; Marker m = ( Marker ) markerMap . get ( key ) ; if ( m == null ) { m = new Marker ( notice ) ; m . addMouseListener ( listener ) ; markerMap . put ( key , m ) ; add ( m ) ; } else { m . addNotice ( notice ) ; } } } if ( getShowMarkedOccurrences ( ) && textArea . getMarkOccurrences ( ) ) { List occurrences = textArea . getMarkedOccurrences ( ) ; for ( Iterator i = occurrences . iterator ( ) ; i . hasNext ( ) ; ) { DocumentRange range = ( DocumentRange ) i . next ( ) ; int line = _NUM ; try { line = textArea . getLineOfOffset ( range . getStartOffset ( ) ) ; } catch ( BadLocationException ble ) { continue ; } ParserNotice notice = new MarkedOccurrenceNotice ( range ) ; Integer key = new Integer ( line ) ; Marker m = ( Marker ) markerMap . get ( key ) ; if ( m == null ) { m = new Marker ( notice ) ; m . addMouseListener ( listener ) ; markerMap . put ( key , m ) ; add ( m ) ; } else { if ( ! m . containsMarkedOccurence ( ) ) { m . addNotice ( notice ) ; } } } } revalidate ( ) ; repaint ( ) ; }
public synchronized int write ( InputStream in ) throws IOException { int readCount = _NUM ; int inBufferPos = count - filledBufferSum ; int n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; while ( n != - _NUM ) { readCount += n ; inBufferPos += n ; count += n ; if ( inBufferPos == currentBuffer . length ) { needNewBuffer ( currentBuffer . length ) ; inBufferPos = _NUM ; } n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; } return readCount ; }
public synchronized int write ( InputStream in ) throws IOException { int readCount = _NUM ; int inBufferPos = count - filledBufferSum ; int n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; while ( n != - _NUM ) { readCount += n ; inBufferPos += n ; count += n ; if ( inBufferPos == currentBuffer . length ) { needNewBuffer ( currentBuffer . length ) ; inBufferPos = _NUM ; } n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; } return readCount ; }
public synchronized int write ( InputStream in ) throws IOException { int readCount = _NUM ; int inBufferPos = count - filledBufferSum ; int n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; while ( n != - _NUM ) { readCount += n ; inBufferPos += n ; count += n ; if ( inBufferPos == currentBuffer . length ) { needNewBuffer ( currentBuffer . length ) ; inBufferPos = _NUM ; } n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; } return readCount ; }
public synchronized int write ( InputStream in ) throws IOException { int readCount = _NUM ; int inBufferPos = count - filledBufferSum ; int n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; while ( n != - _NUM ) { readCount += n ; inBufferPos += n ; count += n ; if ( inBufferPos == currentBuffer . length ) { needNewBuffer ( currentBuffer . length ) ; inBufferPos = _NUM ; } n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; } return readCount ; }
public void printString ( String v , int strOffset , int length ) throws IOException { int offset = _offset ; byte [ ] buffer = _buffer ; for ( int i = _NUM ; i < length ; i ++ ) { if ( SIZE <= offset + _NUM ) { _offset = offset ; flushBuffer ( ) ; offset = _offset ; } char ch = v . charAt ( i + strOffset ) ; if ( ch < _NUM ) buffer [ offset ++ ] = ( byte ) ( ch ) ; else if ( ch < _NUM ) { buffer [ offset ++ ] = ( byte ) ( _NUM + ( ( ch > > _NUM ) & _NUM ) ) ; buffer [ offset ++ ] = ( byte ) ( _NUM + ( ch & _NUM ) ) ; } else { buffer [ offset ++ ] = ( byte ) ( _NUM + ( ( ch > > _NUM ) & _NUM ) ) ; buffer [ offset ++ ] = ( byte ) ( _NUM + ( ( ch > > _NUM ) & _NUM ) ) ; buffer [ offset ++ ] = ( byte ) ( _NUM + ( ch & _NUM ) ) ; } } _offset = offset ; }
static private String decodePercent ( final String str ) throws UnsupportedEncodingException { return URLDecoder . decode ( str , UTF8 ) ; }
static private String decodePercent ( final String str ) throws UnsupportedEncodingException { return URLDecoder . decode ( str , UTF8 ) ; }
private void processResponseHeaders ( State state , InnerState innerState , HttpResponse response ) throws StopRequest { if ( innerState . mContinuingDownload ) { return ; } readResponseHeaders ( state , innerState , response ) ; try { state . mFilename = mService . generateSaveFile ( mInfo . mFileName , mInfo . mTotalBytes ) ; } catch ( DownloaderService . GenerateSaveFileError exc ) { throw new StopRequest ( exc . mStatus , exc . mMessage ) ; } try { state . mStream = new FileOutputStream ( state . mFilename ) ; } catch ( FileNotFoundException exc ) { File pathFile = new File ( Helpers . getSaveFilePath ( mService ) ) ; try { if ( pathFile . mkdirs ( ) ) { state . mStream = new FileOutputStream ( state . mFilename ) ; } } catch ( Exception ex ) { throw new StopRequest ( DownloaderService . STATUS_FILE_ERROR , STRING + exc . toString ( ) , exc ) ; } } if ( Constants . LOGV ) { Log . v ( Constants . TAG , STRING + mInfo . mUri + STRING + state . mFilename ) ; } updateDatabaseFromHeaders ( state , innerState ) ; checkConnectivity ( state ) ; }
private void processResponseHeaders ( State state , InnerState innerState , HttpResponse response ) throws StopRequest { if ( innerState . mContinuingDownload ) { return ; } readResponseHeaders ( state , innerState , response ) ; try { state . mFilename = mService . generateSaveFile ( mInfo . mFileName , mInfo . mTotalBytes ) ; } catch ( DownloaderService . GenerateSaveFileError exc ) { throw new StopRequest ( exc . mStatus , exc . mMessage ) ; } try { state . mStream = new FileOutputStream ( state . mFilename ) ; } catch ( FileNotFoundException exc ) { File pathFile = new File ( Helpers . getSaveFilePath ( mService ) ) ; try { if ( pathFile . mkdirs ( ) ) { state . mStream = new FileOutputStream ( state . mFilename ) ; } } catch ( Exception ex ) { throw new StopRequest ( DownloaderService . STATUS_FILE_ERROR , STRING + exc . toString ( ) , exc ) ; } } if ( Constants . LOGV ) { Log . v ( Constants . TAG , STRING + mInfo . mUri + STRING + state . mFilename ) ; } updateDatabaseFromHeaders ( state , innerState ) ; checkConnectivity ( state ) ; }
protected static Map < String , String > parseSetAttributesAsTextArg ( String text ) { String value = STRING ; String key = STRING ; StringBuilder buffer = new StringBuilder ( ) ; Map < String , String > keyValuePairs = new HashMap < > ( ) ; boolean isInsideQuotes = _BOOL ; for ( int i = _NUM , N = text . length ( ) ; i < N ; ++ i ) { final char c = text . charAt ( i ) ; if ( c == STRING ) { key = buffer . toString ( ) ; buffer . setLength ( _NUM ) ; } else if ( c == STRING ) { if ( isInsideQuotes ) { value = buffer . toString ( ) ; buffer . setLength ( _NUM ) ; } isInsideQuotes = ! isInsideQuotes ; } else if ( c == STRING && ! isInsideQuotes ) { keyValuePairs . put ( key , value ) ; } else { buffer . append ( c ) ; } } if ( ! key . isEmpty ( ) && ! value . isEmpty ( ) ) { keyValuePairs . put ( key , value ) ; } return keyValuePairs ; }
protected static Map < String , String > parseSetAttributesAsTextArg ( String text ) { String value = STRING ; String key = STRING ; StringBuilder buffer = new StringBuilder ( ) ; Map < String , String > keyValuePairs = new HashMap < > ( ) ; boolean isInsideQuotes = _BOOL ; for ( int i = _NUM , N = text . length ( ) ; i < N ; ++ i ) { final char c = text . charAt ( i ) ; if ( c == STRING ) { key = buffer . toString ( ) ; buffer . setLength ( _NUM ) ; } else if ( c == STRING ) { if ( isInsideQuotes ) { value = buffer . toString ( ) ; buffer . setLength ( _NUM ) ; } isInsideQuotes = ! isInsideQuotes ; } else if ( c == STRING && ! isInsideQuotes ) { keyValuePairs . put ( key , value ) ; } else { buffer . append ( c ) ; } } if ( ! key . isEmpty ( ) && ! value . isEmpty ( ) ) { keyValuePairs . put ( key , value ) ; } return keyValuePairs ; }
public ArrayList < ChartSet > prepareEnterAnimation ( ChartView chartView ) { mIsExiting = _BOOL ; return prepareAnimation ( chartView ) ; }
public ArrayList < ChartSet > prepareEnterAnimation ( ChartView chartView ) { mIsExiting = _BOOL ; return prepareAnimation ( chartView ) ; }
public ArrayList < ChartSet > prepareEnterAnimation ( ChartView chartView ) { mIsExiting = _BOOL ; return prepareAnimation ( chartView ) ; }
@ Override public void addVetoableChangeListener ( String name , VetoableChangeListener vcl ) { m_bcSupport . addVetoableChangeListener ( name , vcl ) ; }
@ Override public void addVetoableChangeListener ( String name , VetoableChangeListener vcl ) { m_bcSupport . addVetoableChangeListener ( name , vcl ) ; }
public StringLiteralConcatenation extendsWith ( StringLiteral lit ) { this . sourceEnd = lit . sourceEnd ; final int literalsLength = this . literals . length ; if ( this . counter == literalsLength ) { System . arraycopy ( this . literals , _NUM , this . literals = new StringLiteral [ literalsLength + INITIAL_SIZE ] , _NUM , literalsLength ) ; } int length = this . source . length ; System . arraycopy ( this . source , _NUM , this . source = new char [ length + lit . source . length ] , _NUM , length ) ; System . arraycopy ( lit . source , _NUM , this . source , length , lit . source . length ) ; this . literals [ this . counter ++ ] = lit ; return this ; }
public StringLiteralConcatenation extendsWith ( StringLiteral lit ) { this . sourceEnd = lit . sourceEnd ; final int literalsLength = this . literals . length ; if ( this . counter == literalsLength ) { System . arraycopy ( this . literals , _NUM , this . literals = new StringLiteral [ literalsLength + INITIAL_SIZE ] , _NUM , literalsLength ) ; } int length = this . source . length ; System . arraycopy ( this . source , _NUM , this . source = new char [ length + lit . source . length ] , _NUM , length ) ; System . arraycopy ( lit . source , _NUM , this . source , length , lit . source . length ) ; this . literals [ this . counter ++ ] = lit ; return this ; }
public StrBuilder ensureCapacity ( int capacity ) { if ( capacity > buffer . length ) { char [ ] old = buffer ; buffer = new char [ capacity * _NUM ] ; System . arraycopy ( old , _NUM , buffer , _NUM , size ) ; } return this ; }
public StrBuilder ensureCapacity ( int capacity ) { if ( capacity > buffer . length ) { char [ ] old = buffer ; buffer = new char [ capacity * _NUM ] ; System . arraycopy ( old , _NUM , buffer , _NUM , size ) ; } return this ; }
private void flushFullBuffer ( int minSize ) { flushedBuffers . add ( new LiteralByteString ( buffer ) ) ; flushedBuffersTotalBytes += buffer . length ; int newSize = Math . max ( initialCapacity , Math . max ( minSize , flushedBuffersTotalBytes > > > _NUM ) ) ; buffer = new byte [ newSize ] ; bufferPos = _NUM ; }
private void flushFullBuffer ( int minSize ) { flushedBuffers . add ( new LiteralByteString ( buffer ) ) ; flushedBuffersTotalBytes += buffer . length ; int newSize = Math . max ( initialCapacity , Math . max ( minSize , flushedBuffersTotalBytes > > > _NUM ) ) ; buffer = new byte [ newSize ] ; bufferPos = _NUM ; }
private void flushFullBuffer ( int minSize ) { flushedBuffers . add ( new LiteralByteString ( buffer ) ) ; flushedBuffersTotalBytes += buffer . length ; int newSize = Math . max ( initialCapacity , Math . max ( minSize , flushedBuffersTotalBytes > > > _NUM ) ) ; buffer = new byte [ newSize ] ; bufferPos = _NUM ; }
public static boolean streamToFile ( final InputStream inputStream , final File targetFile , final boolean doAppend ) { if ( inputStream == null || ! isWritable ( targetFile , _BOOL ) ) { Log . e ( FileUtils . class , STRING ) ; return _BOOL ; } boolean isSucceed = _BOOL ; final int buffer_size = _NUM ; OutputStream outputStream = null ; try { outputStream = new FileOutputStream ( targetFile , doAppend ) ; byte [ ] bytes = new byte [ buffer_size ] ; int count = _NUM ; while ( ( count = inputStream . read ( bytes , _NUM , buffer_size ) ) > _NUM ) outputStream . write ( bytes , _NUM , count ) ; isSucceed = _BOOL ; outputStream . flush ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IndexOutOfBoundsException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( outputStream != null ) try { sync ( outputStream ) ; outputStream . close ( ) ; } catch ( IOException e ) { } } return isSucceed ; }
public static boolean streamToFile ( final InputStream inputStream , final File targetFile , final boolean doAppend ) { if ( inputStream == null || ! isWritable ( targetFile , _BOOL ) ) { Log . e ( FileUtils . class , STRING ) ; return _BOOL ; } boolean isSucceed = _BOOL ; final int buffer_size = _NUM ; OutputStream outputStream = null ; try { outputStream = new FileOutputStream ( targetFile , doAppend ) ; byte [ ] bytes = new byte [ buffer_size ] ; int count = _NUM ; while ( ( count = inputStream . read ( bytes , _NUM , buffer_size ) ) > _NUM ) outputStream . write ( bytes , _NUM , count ) ; isSucceed = _BOOL ; outputStream . flush ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IndexOutOfBoundsException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( outputStream != null ) try { sync ( outputStream ) ; outputStream . close ( ) ; } catch ( IOException e ) { } } return isSucceed ; }
private Document signElement ( Document doc , String id , X509Certificate cert , PrivateKey key , String signAlgorithm , String digestAlgorithm ) throws MarshalException , XMLSignatureException { try { XMLSignatureFactory xmlSignatureFactory = XMLSignatureFactory . getInstance ( STRING , new org . jcp . xml . dsig . internal . dom . XMLDSigRI ( ) ) ; List < Transform > transforms = new ArrayList < Transform > ( ) ; Transform enveloped = xmlSignatureFactory . newTransform ( Transforms . TRANSFORM_ENVELOPED_SIGNATURE , ( XMLStructure ) null ) ; transforms . add ( enveloped ) ; Transform c14n = xmlSignatureFactory . newTransform ( Transforms . TRANSFORM_C14N_EXCL_OMIT_COMMENTS , ( XMLStructure ) null ) ; transforms . add ( c14n ) ; Reference ref ; try { ref = xmlSignatureFactory . newReference ( STRING + id , xmlSignatureFactory . newDigestMethod ( digestAlgorithm , null ) , transforms , null , null ) ; } catch ( NoSuchAlgorithmException e ) { ref = xmlSignatureFactory . newReference ( STRING + id , xmlSignatureFactory . newDigestMethod ( DigestMethod . SHA256 , null ) , transforms , null , null ) ; } SignedInfo signedInfo ; try { signedInfo = xmlSignatureFactory . newSignedInfo ( xmlSignatureFactory . newCanonicalizationMethod ( CanonicalizationMethod . EXCLUSIVE , ( C14NMethodParameterSpec ) null ) , xmlSignatureFactory . newSignatureMethod ( signAlgorithm , null ) , Collections . singletonList ( ref ) ) ; } catch ( NoSuchAlgorithmException e ) { signedInfo = xmlSignatureFactory . newSignedInfo ( xmlSignatureFactory . newCanonicalizationMethod ( CanonicalizationMethod . EXCLUSIVE , ( C14NMethodParameterSpec ) null ) , xmlSignatureFactory . newSignatureMethod ( XMLSignature . ALGO_ID_SIGNATURE_RSA_SHA256 , null ) , Collections . singletonList ( ref ) ) ; } KeyInfoFactory keyInfoFactory = xmlSignatureFactory . getKeyInfoFactory ( ) ; List < X509Certificate > x509Content = new ArrayList < > ( ) ; x509Content . add ( cert ) ; X509Data x509Data = keyInfoFactory . newX509Data ( x509Content ) ; KeyInfo keyInfo = keyInfoFactory . newKeyInfo ( Collections . singletonList ( x509Data ) ) ; Element elementToSign = doc . getElementById ( id ) ; NodeList issuerList = elementToSign . getElementsByTagNameNS ( STRING , STRING ) ; Element elementBeforeSignature ; if ( issuerList . getLength ( ) > _NUM ) { elementBeforeSignature = ( Element ) issuerList . item ( _NUM ) ; } else { elementBeforeSignature = elementToSign ; } Element nextElementAfterIssuer = ( Element ) elementBeforeSignature . getNextSibling ( ) ; DOMSignContext domSignContext = new DOMSignContext ( key , elementToSign ) ; domSignContext . setDefaultNamespacePrefix ( STRING ) ; domSignContext . setNextSibling ( nextElementAfterIssuer ) ; javax . xml . crypto . dsig . XMLSignature signature = xmlSignatureFactory . newXMLSignature ( signedInfo , keyInfo ) ; signature . sign ( domSignContext ) ; return doc ; } catch ( InvalidAlgorithmParameterException e ) { e . printStackTrace ( ) ; } catch ( NoSuchAlgorithmException e1 ) { e1 . printStackTrace ( ) ; } return null ; }
public static final void writeByteArrayXml ( byte [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . toString ( N ) ) ; StringBuilder sb = new StringBuilder ( val . length * _NUM ) ; for ( int i = _NUM ; i < N ; i ++ ) { int b = val [ i ] ; int h = b > > _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; h = b & _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; } out . text ( sb . toString ( ) ) ; out . endTag ( null , STRING ) ; }
public static final void writeByteArrayXml ( byte [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . toString ( N ) ) ; StringBuilder sb = new StringBuilder ( val . length * _NUM ) ; for ( int i = _NUM ; i < N ; i ++ ) { int b = val [ i ] ; int h = b > > _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; h = b & _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; } out . text ( sb . toString ( ) ) ; out . endTag ( null , STRING ) ; }
public static final void writeByteArrayXml ( byte [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . toString ( N ) ) ; StringBuilder sb = new StringBuilder ( val . length * _NUM ) ; for ( int i = _NUM ; i < N ; i ++ ) { int b = val [ i ] ; int h = b > > _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; h = b & _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; } out . text ( sb . toString ( ) ) ; out . endTag ( null , STRING ) ; }
public static final void writeByteArrayXml ( byte [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . toString ( N ) ) ; StringBuilder sb = new StringBuilder ( val . length * _NUM ) ; for ( int i = _NUM ; i < N ; i ++ ) { int b = val [ i ] ; int h = b > > _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; h = b & _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; } out . text ( sb . toString ( ) ) ; out . endTag ( null , STRING ) ; }
public static final void writeByteArrayXml ( byte [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . toString ( N ) ) ; StringBuilder sb = new StringBuilder ( val . length * _NUM ) ; for ( int i = _NUM ; i < N ; i ++ ) { int b = val [ i ] ; int h = b > > _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; h = b & _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; } out . text ( sb . toString ( ) ) ; out . endTag ( null , STRING ) ; }
public static synchronized void loadLibrary ( ) { if ( ! libLoaded ) { System . loadLibrary ( STRING ) ; libLoaded = _BOOL ; } }
public static synchronized void loadLibrary ( ) { if ( ! libLoaded ) { System . loadLibrary ( STRING ) ; libLoaded = _BOOL ; } }
public static synchronized void loadLibrary ( ) { if ( ! libLoaded ) { System . loadLibrary ( STRING ) ; libLoaded = _BOOL ; } }
public static synchronized void loadLibrary ( ) { if ( ! libLoaded ) { System . loadLibrary ( STRING ) ; libLoaded = _BOOL ; } }
public void write ( final char chars [ ] , final int start , final int length ) throws java . io . IOException { if ( m_writer != null ) m_writer . write ( chars , start , length ) ; int lengthx3 = ( length << _NUM ) + length ; if ( lengthx3 >= buf_length ) { flushBuffer ( ) ; setBufferSize ( _NUM * lengthx3 ) ; } if ( lengthx3 > buf_length - count ) { flushBuffer ( ) ; } final int n = length + start ; for ( int i = start ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < _NUM ) buf [ count ++ ] = ( byte ) ( c ) ; else if ( c < _NUM ) { buf [ count ++ ] = ( byte ) ( _NUM + ( c > > _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( c & _NUM ) ) ; } else { buf [ count ++ ] = ( byte ) ( _NUM + ( c > > _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( ( c > > _NUM ) & _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( c & _NUM ) ) ; } } }
public void write ( final char chars [ ] , final int start , final int length ) throws java . io . IOException { if ( m_writer != null ) m_writer . write ( chars , start , length ) ; int lengthx3 = ( length << _NUM ) + length ; if ( lengthx3 >= buf_length ) { flushBuffer ( ) ; setBufferSize ( _NUM * lengthx3 ) ; } if ( lengthx3 > buf_length - count ) { flushBuffer ( ) ; } final int n = length + start ; for ( int i = start ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < _NUM ) buf [ count ++ ] = ( byte ) ( c ) ; else if ( c < _NUM ) { buf [ count ++ ] = ( byte ) ( _NUM + ( c > > _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( c & _NUM ) ) ; } else { buf [ count ++ ] = ( byte ) ( _NUM + ( c > > _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( ( c > > _NUM ) & _NUM ) ) ; buf [ count ++ ] = ( byte ) ( _NUM + ( c & _NUM ) ) ; } } }
public static int hashCode ( float [ ] field ) { return field == null || field . length == _NUM ? _NUM : Arrays . hashCode ( field ) ; }
public static int hashCode ( float [ ] field ) { return field == null || field . length == _NUM ? _NUM : Arrays . hashCode ( field ) ; }
public static int hashCode ( float [ ] field ) { return field == null || field . length == _NUM ? _NUM : Arrays . hashCode ( field ) ; }
public static int hashCode ( float [ ] field ) { return field == null || field . length == _NUM ? _NUM : Arrays . hashCode ( field ) ; }
public static int hashCode ( float [ ] field ) { return field == null || field . length == _NUM ? _NUM : Arrays . hashCode ( field ) ; }
private void emitMapPut ( Method method , String fieldName , StringBuilder builder ) { builder . append ( STRING ) ; builder . append ( getMapPutterName ( fieldName ) ) ; builder . append ( STRING ) ; builder . append ( getTypeArgumentImplName ( ( ParameterizedType ) method . getGenericReturnType ( ) , _NUM ) ) ; builder . append ( STRING ) ; builder . append ( getEnsureName ( fieldName ) ) ; builder . append ( STRING ) ; builder . append ( fieldName ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; }
private void emitMapPut ( Method method , String fieldName , StringBuilder builder ) { builder . append ( STRING ) ; builder . append ( getMapPutterName ( fieldName ) ) ; builder . append ( STRING ) ; builder . append ( getTypeArgumentImplName ( ( ParameterizedType ) method . getGenericReturnType ( ) , _NUM ) ) ; builder . append ( STRING ) ; builder . append ( getEnsureName ( fieldName ) ) ; builder . append ( STRING ) ; builder . append ( fieldName ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; }
private Object registeredObjectRead ( int handle ) throws InvalidObjectException { Object res = objectsRead . get ( handle - ObjectStreamConstants . baseWireHandle ) ; if ( res == UNSHARED_OBJ ) { throw new InvalidObjectException ( STRING ) ; } return res ; }
public static void assertSupportedCipherSuites ( Set < String > expected , String [ ] cipherSuites ) { Set < String > remainingCipherSuites = assertValidCipherSuites ( expected , cipherSuites ) ; assertEquals ( STRING , Collections . EMPTY_SET , remainingCipherSuites ) ; assertEquals ( expected . size ( ) , cipherSuites . length ) ; }
public static void assertSupportedCipherSuites ( Set < String > expected , String [ ] cipherSuites ) { Set < String > remainingCipherSuites = assertValidCipherSuites ( expected , cipherSuites ) ; assertEquals ( STRING , Collections . EMPTY_SET , remainingCipherSuites ) ; assertEquals ( expected . size ( ) , cipherSuites . length ) ; }
public static void assertSupportedCipherSuites ( Set < String > expected , String [ ] cipherSuites ) { Set < String > remainingCipherSuites = assertValidCipherSuites ( expected , cipherSuites ) ; assertEquals ( STRING , Collections . EMPTY_SET , remainingCipherSuites ) ; assertEquals ( expected . size ( ) , cipherSuites . length ) ; }
public static void assertSupportedCipherSuites ( Set < String > expected , String [ ] cipherSuites ) { Set < String > remainingCipherSuites = assertValidCipherSuites ( expected , cipherSuites ) ; assertEquals ( STRING , Collections . EMPTY_SET , remainingCipherSuites ) ; assertEquals ( expected . size ( ) , cipherSuites . length ) ; }
public static void assertSupportedCipherSuites ( Set < String > expected , String [ ] cipherSuites ) { Set < String > remainingCipherSuites = assertValidCipherSuites ( expected , cipherSuites ) ; assertEquals ( STRING , Collections . EMPTY_SET , remainingCipherSuites ) ; assertEquals ( expected . size ( ) , cipherSuites . length ) ; }
public static void assertSupportedCipherSuites ( Set < String > expected , String [ ] cipherSuites ) { Set < String > remainingCipherSuites = assertValidCipherSuites ( expected , cipherSuites ) ; assertEquals ( STRING , Collections . EMPTY_SET , remainingCipherSuites ) ; assertEquals ( expected . size ( ) , cipherSuites . length ) ; }
public static void assertSupportedCipherSuites ( Set < String > expected , String [ ] cipherSuites ) { Set < String > remainingCipherSuites = assertValidCipherSuites ( expected , cipherSuites ) ; assertEquals ( STRING , Collections . EMPTY_SET , remainingCipherSuites ) ; assertEquals ( expected . size ( ) , cipherSuites . length ) ; }
@ Override public synchronized boolean equals ( Object object ) { if ( this == object ) { return _BOOL ; } if ( object instanceof List ) { List < ? > list = ( List < ? > ) object ; if ( list . size ( ) != elementCount ) { return _BOOL ; } int index = _NUM ; Iterator < ? > it = list . iterator ( ) ; while ( it . hasNext ( ) ) { Object e1 = elementData [ index ++ ] , e2 = it . next ( ) ; if ( ! ( e1 == null ? e2 == null : e1 . equals ( e2 ) ) ) { return _BOOL ; } } return _BOOL ; } return _BOOL ; }
@ Override public synchronized boolean equals ( Object object ) { if ( this == object ) { return _BOOL ; } if ( object instanceof List ) { List < ? > list = ( List < ? > ) object ; if ( list . size ( ) != elementCount ) { return _BOOL ; } int index = _NUM ; Iterator < ? > it = list . iterator ( ) ; while ( it . hasNext ( ) ) { Object e1 = elementData [ index ++ ] , e2 = it . next ( ) ; if ( ! ( e1 == null ? e2 == null : e1 . equals ( e2 ) ) ) { return _BOOL ; } } return _BOOL ; } return _BOOL ; }
@ Override public synchronized boolean equals ( Object object ) { if ( this == object ) { return _BOOL ; } if ( object instanceof List ) { List < ? > list = ( List < ? > ) object ; if ( list . size ( ) != elementCount ) { return _BOOL ; } int index = _NUM ; Iterator < ? > it = list . iterator ( ) ; while ( it . hasNext ( ) ) { Object e1 = elementData [ index ++ ] , e2 = it . next ( ) ; if ( ! ( e1 == null ? e2 == null : e1 . equals ( e2 ) ) ) { return _BOOL ; } } return _BOOL ; } return _BOOL ; }
@ Override public synchronized boolean equals ( Object object ) { if ( this == object ) { return _BOOL ; } if ( object instanceof List ) { List < ? > list = ( List < ? > ) object ; if ( list . size ( ) != elementCount ) { return _BOOL ; } int index = _NUM ; Iterator < ? > it = list . iterator ( ) ; while ( it . hasNext ( ) ) { Object e1 = elementData [ index ++ ] , e2 = it . next ( ) ; if ( ! ( e1 == null ? e2 == null : e1 . equals ( e2 ) ) ) { return _BOOL ; } } return _BOOL ; } return _BOOL ; }
@ Override public synchronized boolean equals ( Object object ) { if ( this == object ) { return _BOOL ; } if ( object instanceof List ) { List < ? > list = ( List < ? > ) object ; if ( list . size ( ) != elementCount ) { return _BOOL ; } int index = _NUM ; Iterator < ? > it = list . iterator ( ) ; while ( it . hasNext ( ) ) { Object e1 = elementData [ index ++ ] , e2 = it . next ( ) ; if ( ! ( e1 == null ? e2 == null : e1 . equals ( e2 ) ) ) { return _BOOL ; } } return _BOOL ; } return _BOOL ; }
public static boolean contains ( final Type type ) { Set < Type > generatedValues = threadLocal . get ( ) ; return generatedValues . contains ( type ) ; }
private Integer insertAllContacts ( Iterator < String > contactsIter ) { final ArrayList < ContentProviderOperation > batchOperation = new ArrayList < ContentProviderOperation > ( ) ; while ( contactsIter . hasNext ( ) ) addContact ( contactsIter . next ( ) , batchOperation ) ; try { ContentProviderResult [ ] results = mContentResolver . applyBatch ( ContactsContract . AUTHORITY , batchOperation ) ; return results . length / _NUM ; } catch ( RemoteException e ) { e . printStackTrace ( ) ; } catch ( OperationApplicationException e ) { e . printStackTrace ( ) ; } return _NUM ; }
public static Pair < Integer , Boolean > parseInfoFromFilename ( String name ) { try { if ( name . startsWith ( SAVED_TAB_STATE_FILE_PREFIX_INCOGNITO ) ) { int id = Integer . parseInt ( name . substring ( SAVED_TAB_STATE_FILE_PREFIX_INCOGNITO . length ( ) ) ) ; return Pair . create ( id , _BOOL ) ; } else if ( name . startsWith ( SAVED_TAB_STATE_FILE_PREFIX ) ) { int id = Integer . parseInt ( name . substring ( SAVED_TAB_STATE_FILE_PREFIX . length ( ) ) ) ; return Pair . create ( id , _BOOL ) ; } } catch ( NumberFormatException ex ) { } return null ; }
protected void processCloudlet ( SimEvent ev , int type ) { int cloudletId = _NUM ; int userId = _NUM ; int vmId = _NUM ; try { int data [ ] = ( int [ ] ) ev . getData ( ) ; cloudletId = data [ _NUM ] ; userId = data [ _NUM ] ; vmId = data [ _NUM ] ; } catch ( ClassCastException c ) { try { Cloudlet cl = ( Cloudlet ) ev . getData ( ) ; cloudletId = cl . getCloudletId ( ) ; userId = cl . getUserId ( ) ; vmId = cl . getVmId ( ) ; } catch ( Exception e ) { Log . printConcatLine ( super . getName ( ) , STRING ) ; Log . printLine ( e . getMessage ( ) ) ; return ; } } catch ( Exception e ) { Log . printConcatLine ( super . getName ( ) , STRING ) ; Log . printLine ( e . getMessage ( ) ) ; return ; } switch ( type ) { case CloudSimTags . CLOUDLET_CANCEL : processCloudletCancel ( cloudletId , userId , vmId ) ; break ; case CloudSimTags . CLOUDLET_PAUSE : processCloudletPause ( cloudletId , userId , vmId , _BOOL ) ; break ; case CloudSimTags . CLOUDLET_PAUSE_ACK : processCloudletPause ( cloudletId , userId , vmId , _BOOL ) ; break ; case CloudSimTags . CLOUDLET_RESUME : processCloudletResume ( cloudletId , userId , vmId , _BOOL ) ; break ; case CloudSimTags . CLOUDLET_RESUME_ACK : processCloudletResume ( cloudletId , userId , vmId , _BOOL ) ; break ; default : break ; } }
protected void processCloudlet ( SimEvent ev , int type ) { int cloudletId = _NUM ; int userId = _NUM ; int vmId = _NUM ; try { int data [ ] = ( int [ ] ) ev . getData ( ) ; cloudletId = data [ _NUM ] ; userId = data [ _NUM ] ; vmId = data [ _NUM ] ; } catch ( ClassCastException c ) { try { Cloudlet cl = ( Cloudlet ) ev . getData ( ) ; cloudletId = cl . getCloudletId ( ) ; userId = cl . getUserId ( ) ; vmId = cl . getVmId ( ) ; } catch ( Exception e ) { Log . printConcatLine ( super . getName ( ) , STRING ) ; Log . printLine ( e . getMessage ( ) ) ; return ; } } catch ( Exception e ) { Log . printConcatLine ( super . getName ( ) , STRING ) ; Log . printLine ( e . getMessage ( ) ) ; return ; } switch ( type ) { case CloudSimTags . CLOUDLET_CANCEL : processCloudletCancel ( cloudletId , userId , vmId ) ; break ; case CloudSimTags . CLOUDLET_PAUSE : processCloudletPause ( cloudletId , userId , vmId , _BOOL ) ; break ; case CloudSimTags . CLOUDLET_PAUSE_ACK : processCloudletPause ( cloudletId , userId , vmId , _BOOL ) ; break ; case CloudSimTags . CLOUDLET_RESUME : processCloudletResume ( cloudletId , userId , vmId , _BOOL ) ; break ; case CloudSimTags . CLOUDLET_RESUME_ACK : processCloudletResume ( cloudletId , userId , vmId , _BOOL ) ; break ; default : break ; } }
protected void processCloudlet ( SimEvent ev , int type ) { int cloudletId = _NUM ; int userId = _NUM ; int vmId = _NUM ; try { int data [ ] = ( int [ ] ) ev . getData ( ) ; cloudletId = data [ _NUM ] ; userId = data [ _NUM ] ; vmId = data [ _NUM ] ; } catch ( ClassCastException c ) { try { Cloudlet cl = ( Cloudlet ) ev . getData ( ) ; cloudletId = cl . getCloudletId ( ) ; userId = cl . getUserId ( ) ; vmId = cl . getVmId ( ) ; } catch ( Exception e ) { Log . printConcatLine ( super . getName ( ) , STRING ) ; Log . printLine ( e . getMessage ( ) ) ; return ; } } catch ( Exception e ) { Log . printConcatLine ( super . getName ( ) , STRING ) ; Log . printLine ( e . getMessage ( ) ) ; return ; } switch ( type ) { case CloudSimTags . CLOUDLET_CANCEL : processCloudletCancel ( cloudletId , userId , vmId ) ; break ; case CloudSimTags . CLOUDLET_PAUSE : processCloudletPause ( cloudletId , userId , vmId , _BOOL ) ; break ; case CloudSimTags . CLOUDLET_PAUSE_ACK : processCloudletPause ( cloudletId , userId , vmId , _BOOL ) ; break ; case CloudSimTags . CLOUDLET_RESUME : processCloudletResume ( cloudletId , userId , vmId , _BOOL ) ; break ; case CloudSimTags . CLOUDLET_RESUME_ACK : processCloudletResume ( cloudletId , userId , vmId , _BOOL ) ; break ; default : break ; } }
@ Override public synchronized void clear ( ) { File [ ] files = mRootDirectory . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } mEntries . clear ( ) ; mTotalSize = _NUM ; VolleyLog . d ( STRING ) ; }
@ Override public synchronized void clear ( ) { File [ ] files = mRootDirectory . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } mEntries . clear ( ) ; mTotalSize = _NUM ; VolleyLog . d ( STRING ) ; }
@ Override public synchronized void clear ( ) { File [ ] files = mRootDirectory . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } mEntries . clear ( ) ; mTotalSize = _NUM ; VolleyLog . d ( STRING ) ; }
@ Override public synchronized void clear ( ) { File [ ] files = mRootDirectory . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } mEntries . clear ( ) ; mTotalSize = _NUM ; VolleyLog . d ( STRING ) ; }
private void checkForConflictingArguments ( ) throws ArgumentException { throwIfArgumentsConflict ( bindPasswordArg , bindPasswordFileArg ) ; throwIfArgumentsConflict ( trustAllArg , trustStorePathArg ) ; throwIfArgumentsConflict ( trustAllArg , trustStorePasswordArg ) ; throwIfArgumentsConflict ( trustAllArg , trustStorePasswordFileArg ) ; throwIfArgumentsConflict ( trustStorePasswordArg , trustStorePasswordFileArg ) ; throwIfArgumentsConflict ( useStartTLSArg , useSSLArg ) ; if ( trustStorePathArg . isPresent ( ) ) { final String value = trustStorePathArg . getValue ( ) ; if ( ! canReadPath ( value ) ) { final LocalizableMessage message = ERR_CANNOT_READ_TRUSTSTORE . get ( value ) ; throw new ArgumentException ( message ) ; } } if ( keyStorePathArg . isPresent ( ) ) { final String value = keyStorePathArg . getValue ( ) ; if ( ! canReadPath ( value ) ) { final LocalizableMessage message = ERR_CANNOT_READ_KEYSTORE . get ( value ) ; throw new ArgumentException ( message ) ; } } }
@ Override protected void includeProperties ( Set < Property > allProperties ) { super . includeProperties ( allProperties ) ; nodes . forEach ( null ) ; }
@ Override protected void includeProperties ( Set < Property > allProperties ) { super . includeProperties ( allProperties ) ; nodes . forEach ( null ) ; }
public static double doubleFromProperties ( Properties p , String propName , double defaultValue ) { double ret = defaultValue ; String doubleString = p . getProperty ( propName ) ; if ( doubleString != null ) { try { ret = Double . parseDouble ( doubleString . trim ( ) ) ; } catch ( NumberFormatException e ) { ret = defaultValue ; } } return ret ; }
public static double doubleFromProperties ( Properties p , String propName , double defaultValue ) { double ret = defaultValue ; String doubleString = p . getProperty ( propName ) ; if ( doubleString != null ) { try { ret = Double . parseDouble ( doubleString . trim ( ) ) ; } catch ( NumberFormatException e ) { ret = defaultValue ; } } return ret ; }
public static double doubleFromProperties ( Properties p , String propName , double defaultValue ) { double ret = defaultValue ; String doubleString = p . getProperty ( propName ) ; if ( doubleString != null ) { try { ret = Double . parseDouble ( doubleString . trim ( ) ) ; } catch ( NumberFormatException e ) { ret = defaultValue ; } } return ret ; }
public static double doubleFromProperties ( Properties p , String propName , double defaultValue ) { double ret = defaultValue ; String doubleString = p . getProperty ( propName ) ; if ( doubleString != null ) { try { ret = Double . parseDouble ( doubleString . trim ( ) ) ; } catch ( NumberFormatException e ) { ret = defaultValue ; } } return ret ; }
public void addLayer ( Layer layer ) { addLayer ( layer , _NUM , _map . maxZoomLevel ( ) ) ; }
public void addLayer ( Layer layer ) { addLayer ( layer , _NUM , _map . maxZoomLevel ( ) ) ; }
public void addPartnerClickTargets ( Element ... elems ) { if ( elems != null ) { for ( Element e : elems ) { clickTargets . add ( e ) ; } } }
public void addPartnerClickTargets ( Element ... elems ) { if ( elems != null ) { for ( Element e : elems ) { clickTargets . add ( e ) ; } } }
public void addPartnerClickTargets ( Element ... elems ) { if ( elems != null ) { for ( Element e : elems ) { clickTargets . add ( e ) ; } } }
public void addPartnerClickTargets ( Element ... elems ) { if ( elems != null ) { for ( Element e : elems ) { clickTargets . add ( e ) ; } } }
public void addPartnerClickTargets ( Element ... elems ) { if ( elems != null ) { for ( Element e : elems ) { clickTargets . add ( e ) ; } } }
public void addPartnerClickTargets ( Element ... elems ) { if ( elems != null ) { for ( Element e : elems ) { clickTargets . add ( e ) ; } } }
public static void encodeVaxInteger ( OutputStream stream , int value ) throws IOException { stream . write ( _NUM ) ; encodeVaxIntegerWithoutLength ( stream , value ) ; }
public static void encodeVaxInteger ( OutputStream stream , int value ) throws IOException { stream . write ( _NUM ) ; encodeVaxIntegerWithoutLength ( stream , value ) ; }
public static void encodeVaxInteger ( OutputStream stream , int value ) throws IOException { stream . write ( _NUM ) ; encodeVaxIntegerWithoutLength ( stream , value ) ; }
public static GeneralPath cardinalSpline ( GeneralPath p , float pts [ ] , int start , int npoints , float slack , boolean closed , float tx , float ty ) { try { int len = _NUM * npoints ; int end = start + len ; if ( len < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } float dx1 , dy1 , dx2 , dy2 ; if ( closed ) { dx2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; } else { dx2 = pts [ start + _NUM ] - pts [ start ] ; dy2 = pts [ start + _NUM ] - pts [ start + _NUM ] ; } int i ; for ( i = start + _NUM ; i < end - _NUM ; i += _NUM ) { dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ i + _NUM ] - pts [ i - _NUM ] ; dy2 = pts [ i + _NUM ] - pts [ i - _NUM ] ; p . curveTo ( tx + pts [ i - _NUM ] + slack * dx1 , ty + pts [ i - _NUM ] + slack * dy1 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; } if ( closed ) { dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ start ] - pts [ i - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ i - _NUM ] ; p . curveTo ( tx + pts [ i - _NUM ] + slack * dx1 , ty + pts [ i - _NUM ] + slack * dy1 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; p . curveTo ( tx + pts [ end - _NUM ] + slack * dx1 , ty + pts [ end - _NUM ] + slack * dy1 , tx + pts [ _NUM ] - slack * dx2 , ty + pts [ _NUM ] - slack * dy2 , tx + pts [ _NUM ] , ty + pts [ _NUM ] ) ; p . closePath ( ) ; } else { p . curveTo ( tx + pts [ i - _NUM ] + slack * dx2 , ty + pts [ i - _NUM ] + slack * dy2 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; } } catch ( IllegalPathStateException ex ) { } return p ; }
public static GeneralPath cardinalSpline ( GeneralPath p , float pts [ ] , int start , int npoints , float slack , boolean closed , float tx , float ty ) { try { int len = _NUM * npoints ; int end = start + len ; if ( len < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } float dx1 , dy1 , dx2 , dy2 ; if ( closed ) { dx2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; } else { dx2 = pts [ start + _NUM ] - pts [ start ] ; dy2 = pts [ start + _NUM ] - pts [ start + _NUM ] ; } int i ; for ( i = start + _NUM ; i < end - _NUM ; i += _NUM ) { dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ i + _NUM ] - pts [ i - _NUM ] ; dy2 = pts [ i + _NUM ] - pts [ i - _NUM ] ; p . curveTo ( tx + pts [ i - _NUM ] + slack * dx1 , ty + pts [ i - _NUM ] + slack * dy1 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; } if ( closed ) { dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ start ] - pts [ i - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ i - _NUM ] ; p . curveTo ( tx + pts [ i - _NUM ] + slack * dx1 , ty + pts [ i - _NUM ] + slack * dy1 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; p . curveTo ( tx + pts [ end - _NUM ] + slack * dx1 , ty + pts [ end - _NUM ] + slack * dy1 , tx + pts [ _NUM ] - slack * dx2 , ty + pts [ _NUM ] - slack * dy2 , tx + pts [ _NUM ] , ty + pts [ _NUM ] ) ; p . closePath ( ) ; } else { p . curveTo ( tx + pts [ i - _NUM ] + slack * dx2 , ty + pts [ i - _NUM ] + slack * dy2 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; } } catch ( IllegalPathStateException ex ) { } return p ; }
public static GeneralPath cardinalSpline ( GeneralPath p , float pts [ ] , int start , int npoints , float slack , boolean closed , float tx , float ty ) { try { int len = _NUM * npoints ; int end = start + len ; if ( len < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } float dx1 , dy1 , dx2 , dy2 ; if ( closed ) { dx2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; } else { dx2 = pts [ start + _NUM ] - pts [ start ] ; dy2 = pts [ start + _NUM ] - pts [ start + _NUM ] ; } int i ; for ( i = start + _NUM ; i < end - _NUM ; i += _NUM ) { dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ i + _NUM ] - pts [ i - _NUM ] ; dy2 = pts [ i + _NUM ] - pts [ i - _NUM ] ; p . curveTo ( tx + pts [ i - _NUM ] + slack * dx1 , ty + pts [ i - _NUM ] + slack * dy1 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; } if ( closed ) { dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ start ] - pts [ i - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ i - _NUM ] ; p . curveTo ( tx + pts [ i - _NUM ] + slack * dx1 , ty + pts [ i - _NUM ] + slack * dy1 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; p . curveTo ( tx + pts [ end - _NUM ] + slack * dx1 , ty + pts [ end - _NUM ] + slack * dy1 , tx + pts [ _NUM ] - slack * dx2 , ty + pts [ _NUM ] - slack * dy2 , tx + pts [ _NUM ] , ty + pts [ _NUM ] ) ; p . closePath ( ) ; } else { p . curveTo ( tx + pts [ i - _NUM ] + slack * dx2 , ty + pts [ i - _NUM ] + slack * dy2 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; } } catch ( IllegalPathStateException ex ) { } return p ; }
public static GeneralPath cardinalSpline ( GeneralPath p , float pts [ ] , int start , int npoints , float slack , boolean closed , float tx , float ty ) { try { int len = _NUM * npoints ; int end = start + len ; if ( len < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } float dx1 , dy1 , dx2 , dy2 ; if ( closed ) { dx2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; } else { dx2 = pts [ start + _NUM ] - pts [ start ] ; dy2 = pts [ start + _NUM ] - pts [ start + _NUM ] ; } int i ; for ( i = start + _NUM ; i < end - _NUM ; i += _NUM ) { dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ i + _NUM ] - pts [ i - _NUM ] ; dy2 = pts [ i + _NUM ] - pts [ i - _NUM ] ; p . curveTo ( tx + pts [ i - _NUM ] + slack * dx1 , ty + pts [ i - _NUM ] + slack * dy1 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; } if ( closed ) { dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ start ] - pts [ i - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ i - _NUM ] ; p . curveTo ( tx + pts [ i - _NUM ] + slack * dx1 , ty + pts [ i - _NUM ] + slack * dy1 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; p . curveTo ( tx + pts [ end - _NUM ] + slack * dx1 , ty + pts [ end - _NUM ] + slack * dy1 , tx + pts [ _NUM ] - slack * dx2 , ty + pts [ _NUM ] - slack * dy2 , tx + pts [ _NUM ] , ty + pts [ _NUM ] ) ; p . closePath ( ) ; } else { p . curveTo ( tx + pts [ i - _NUM ] + slack * dx2 , ty + pts [ i - _NUM ] + slack * dy2 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; } } catch ( IllegalPathStateException ex ) { } return p ; }
public static GeneralPath cardinalSpline ( GeneralPath p , float pts [ ] , int start , int npoints , float slack , boolean closed , float tx , float ty ) { try { int len = _NUM * npoints ; int end = start + len ; if ( len < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } float dx1 , dy1 , dx2 , dy2 ; if ( closed ) { dx2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; } else { dx2 = pts [ start + _NUM ] - pts [ start ] ; dy2 = pts [ start + _NUM ] - pts [ start + _NUM ] ; } int i ; for ( i = start + _NUM ; i < end - _NUM ; i += _NUM ) { dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ i + _NUM ] - pts [ i - _NUM ] ; dy2 = pts [ i + _NUM ] - pts [ i - _NUM ] ; p . curveTo ( tx + pts [ i - _NUM ] + slack * dx1 , ty + pts [ i - _NUM ] + slack * dy1 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; } if ( closed ) { dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ start ] - pts [ i - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ i - _NUM ] ; p . curveTo ( tx + pts [ i - _NUM ] + slack * dx1 , ty + pts [ i - _NUM ] + slack * dy1 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; p . curveTo ( tx + pts [ end - _NUM ] + slack * dx1 , ty + pts [ end - _NUM ] + slack * dy1 , tx + pts [ _NUM ] - slack * dx2 , ty + pts [ _NUM ] - slack * dy2 , tx + pts [ _NUM ] , ty + pts [ _NUM ] ) ; p . closePath ( ) ; } else { p . curveTo ( tx + pts [ i - _NUM ] + slack * dx2 , ty + pts [ i - _NUM ] + slack * dy2 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; } } catch ( IllegalPathStateException ex ) { } return p ; }
public static GeneralPath cardinalSpline ( GeneralPath p , float pts [ ] , int start , int npoints , float slack , boolean closed , float tx , float ty ) { try { int len = _NUM * npoints ; int end = start + len ; if ( len < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } float dx1 , dy1 , dx2 , dy2 ; if ( closed ) { dx2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; } else { dx2 = pts [ start + _NUM ] - pts [ start ] ; dy2 = pts [ start + _NUM ] - pts [ start + _NUM ] ; } int i ; for ( i = start + _NUM ; i < end - _NUM ; i += _NUM ) { dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ i + _NUM ] - pts [ i - _NUM ] ; dy2 = pts [ i + _NUM ] - pts [ i - _NUM ] ; p . curveTo ( tx + pts [ i - _NUM ] + slack * dx1 , ty + pts [ i - _NUM ] + slack * dy1 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; } if ( closed ) { dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ start ] - pts [ i - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ i - _NUM ] ; p . curveTo ( tx + pts [ i - _NUM ] + slack * dx1 , ty + pts [ i - _NUM ] + slack * dy1 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; p . curveTo ( tx + pts [ end - _NUM ] + slack * dx1 , ty + pts [ end - _NUM ] + slack * dy1 , tx + pts [ _NUM ] - slack * dx2 , ty + pts [ _NUM ] - slack * dy2 , tx + pts [ _NUM ] , ty + pts [ _NUM ] ) ; p . closePath ( ) ; } else { p . curveTo ( tx + pts [ i - _NUM ] + slack * dx2 , ty + pts [ i - _NUM ] + slack * dy2 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; } } catch ( IllegalPathStateException ex ) { } return p ; }
public static GeneralPath cardinalSpline ( GeneralPath p , float pts [ ] , int start , int npoints , float slack , boolean closed , float tx , float ty ) { try { int len = _NUM * npoints ; int end = start + len ; if ( len < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } float dx1 , dy1 , dx2 , dy2 ; if ( closed ) { dx2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; } else { dx2 = pts [ start + _NUM ] - pts [ start ] ; dy2 = pts [ start + _NUM ] - pts [ start + _NUM ] ; } int i ; for ( i = start + _NUM ; i < end - _NUM ; i += _NUM ) { dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ i + _NUM ] - pts [ i - _NUM ] ; dy2 = pts [ i + _NUM ] - pts [ i - _NUM ] ; p . curveTo ( tx + pts [ i - _NUM ] + slack * dx1 , ty + pts [ i - _NUM ] + slack * dy1 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; } if ( closed ) { dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ start ] - pts [ i - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ i - _NUM ] ; p . curveTo ( tx + pts [ i - _NUM ] + slack * dx1 , ty + pts [ i - _NUM ] + slack * dy1 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; dx1 = dx2 ; dy1 = dy2 ; dx2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; dy2 = pts [ start + _NUM ] - pts [ end - _NUM ] ; p . curveTo ( tx + pts [ end - _NUM ] + slack * dx1 , ty + pts [ end - _NUM ] + slack * dy1 , tx + pts [ _NUM ] - slack * dx2 , ty + pts [ _NUM ] - slack * dy2 , tx + pts [ _NUM ] , ty + pts [ _NUM ] ) ; p . closePath ( ) ; } else { p . curveTo ( tx + pts [ i - _NUM ] + slack * dx2 , ty + pts [ i - _NUM ] + slack * dy2 , tx + pts [ i ] - slack * dx2 , ty + pts [ i + _NUM ] - slack * dy2 , tx + pts [ i ] , ty + pts [ i + _NUM ] ) ; } } catch ( IllegalPathStateException ex ) { } return p ; }
public WildcardFileFilter ( String [ ] wildcards , IOCase caseSensitivity ) { if ( wildcards == null ) { throw new IllegalArgumentException ( STRING ) ; } this . wildcards = new String [ wildcards . length ] ; System . arraycopy ( wildcards , _NUM , this . wildcards , _NUM , wildcards . length ) ; this . caseSensitivity = caseSensitivity == null ? IOCase . SENSITIVE : caseSensitivity ; }
public WildcardFileFilter ( String [ ] wildcards , IOCase caseSensitivity ) { if ( wildcards == null ) { throw new IllegalArgumentException ( STRING ) ; } this . wildcards = new String [ wildcards . length ] ; System . arraycopy ( wildcards , _NUM , this . wildcards , _NUM , wildcards . length ) ; this . caseSensitivity = caseSensitivity == null ? IOCase . SENSITIVE : caseSensitivity ; }
public WildcardFileFilter ( String [ ] wildcards , IOCase caseSensitivity ) { if ( wildcards == null ) { throw new IllegalArgumentException ( STRING ) ; } this . wildcards = new String [ wildcards . length ] ; System . arraycopy ( wildcards , _NUM , this . wildcards , _NUM , wildcards . length ) ; this . caseSensitivity = caseSensitivity == null ? IOCase . SENSITIVE : caseSensitivity ; }
private static boolean hasResponseBody ( int requestMethod , int responseCode ) { return requestMethod != Method . HEAD && ! ( HttpStatus . SC_CONTINUE <= responseCode && responseCode < HttpStatus . SC_OK ) && responseCode != HttpStatus . SC_NO_CONTENT && responseCode != HttpStatus . SC_NOT_MODIFIED ; }
private static boolean hasResponseBody ( int requestMethod , int responseCode ) { return requestMethod != Method . HEAD && ! ( HttpStatus . SC_CONTINUE <= responseCode && responseCode < HttpStatus . SC_OK ) && responseCode != HttpStatus . SC_NO_CONTENT && responseCode != HttpStatus . SC_NOT_MODIFIED ; }
private static boolean hasResponseBody ( int requestMethod , int responseCode ) { return requestMethod != Method . HEAD && ! ( HttpStatus . SC_CONTINUE <= responseCode && responseCode < HttpStatus . SC_OK ) && responseCode != HttpStatus . SC_NO_CONTENT && responseCode != HttpStatus . SC_NOT_MODIFIED ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; }
public static void sort ( Object [ ] array , int start , int end ) { ComparableTimSort . sort ( array , start , end ) ; }
private int clampMag ( int value , int absMin , int absMax ) { final int absValue = Math . abs ( value ) ; if ( absValue < absMin ) return _NUM ; if ( absValue > absMax ) return value > _NUM ? absMax : - absMax ; return value ; }
public void rollbackNothingMethod ( String stepId ) { WorkflowStepCompleter . stepSucceded ( stepId ) ; }
public void rollbackNothingMethod ( String stepId ) { WorkflowStepCompleter . stepSucceded ( stepId ) ; }
public void rollbackNothingMethod ( String stepId ) { WorkflowStepCompleter . stepSucceded ( stepId ) ; }
public void add ( Graphic graphic ) { synchronized ( mLock ) { mGraphics . add ( graphic ) ; } postInvalidate ( ) ; }
public void add ( Graphic graphic ) { synchronized ( mLock ) { mGraphics . add ( graphic ) ; } postInvalidate ( ) ; }
private void unshareMain ( ) { int [ ] old = _mainHash ; int len = _mainHash . length ; _mainHash = new int [ len ] ; System . arraycopy ( old , _NUM , _mainHash , _NUM , len ) ; _mainHashShared = _BOOL ; }
private void unshareMain ( ) { int [ ] old = _mainHash ; int len = _mainHash . length ; _mainHash = new int [ len ] ; System . arraycopy ( old , _NUM , _mainHash , _NUM , len ) ; _mainHashShared = _BOOL ; }
private void unshareMain ( ) { int [ ] old = _mainHash ; int len = _mainHash . length ; _mainHash = new int [ len ] ; System . arraycopy ( old , _NUM , _mainHash , _NUM , len ) ; _mainHashShared = _BOOL ; }
private void unshareMain ( ) { int [ ] old = _mainHash ; int len = _mainHash . length ; _mainHash = new int [ len ] ; System . arraycopy ( old , _NUM , _mainHash , _NUM , len ) ; _mainHashShared = _BOOL ; }
private void unshareMain ( ) { int [ ] old = _mainHash ; int len = _mainHash . length ; _mainHash = new int [ len ] ; System . arraycopy ( old , _NUM , _mainHash , _NUM , len ) ; _mainHashShared = _BOOL ; }
public static void writeFile ( final File destination , final List < String > contents ) throws IOException { final BufferedWriter bw = new BufferedWriter ( new FileWriter ( destination ) ) ; try { for ( String line : contents ) { bw . write ( line ) ; bw . newLine ( ) ; } bw . flush ( ) ; } finally { bw . close ( ) ; } }
public static void writeFile ( final File destination , final List < String > contents ) throws IOException { final BufferedWriter bw = new BufferedWriter ( new FileWriter ( destination ) ) ; try { for ( String line : contents ) { bw . write ( line ) ; bw . newLine ( ) ; } bw . flush ( ) ; } finally { bw . close ( ) ; } }
public int transcribe ( IPoint [ ] hull , int offset ) { int idx = offset ; int sz = points . size ( ) ; for ( int i = _NUM ; i < sz ; i ++ ) { hull [ idx ++ ] = points . get ( i ) ; } return idx ; }
public int transcribe ( IPoint [ ] hull , int offset ) { int idx = offset ; int sz = points . size ( ) ; for ( int i = _NUM ; i < sz ; i ++ ) { hull [ idx ++ ] = points . get ( i ) ; } return idx ; }
public int transcribe ( IPoint [ ] hull , int offset ) { int idx = offset ; int sz = points . size ( ) ; for ( int i = _NUM ; i < sz ; i ++ ) { hull [ idx ++ ] = points . get ( i ) ; } return idx ; }
protected void addMapPanelChild ( MapPanelChild mpc ) { add ( ( Component ) mpc , mpc . getPreferredLocation ( ) ) ; }
protected void addMapPanelChild ( MapPanelChild mpc ) { add ( ( Component ) mpc , mpc . getPreferredLocation ( ) ) ; }
private static ResultPoint [ ] findVertices ( BitMatrix matrix , boolean tryHarder ) { int height = matrix . getHeight ( ) ; int width = matrix . getWidth ( ) ; ResultPoint [ ] result = new ResultPoint [ _NUM ] ; boolean found = _BOOL ; int [ ] counters = new int [ START_PATTERN . length ] ; int rowStep = Math . max ( _NUM , height > > ( tryHarder ? _NUM : _NUM ) ) ; for ( int i = _NUM ; i < height ; i += rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , START_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } if ( found ) { found = _BOOL ; for ( int i = height - _NUM ; i > _NUM ; i -= rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , START_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } } counters = new int [ STOP_PATTERN . length ] ; if ( found ) { found = _BOOL ; for ( int i = _NUM ; i < height ; i += rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , STOP_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } } if ( found ) { found = _BOOL ; for ( int i = height - _NUM ; i > _NUM ; i -= rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , STOP_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } } return found ? result : null ; }
private static ResultPoint [ ] findVertices ( BitMatrix matrix , boolean tryHarder ) { int height = matrix . getHeight ( ) ; int width = matrix . getWidth ( ) ; ResultPoint [ ] result = new ResultPoint [ _NUM ] ; boolean found = _BOOL ; int [ ] counters = new int [ START_PATTERN . length ] ; int rowStep = Math . max ( _NUM , height > > ( tryHarder ? _NUM : _NUM ) ) ; for ( int i = _NUM ; i < height ; i += rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , START_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } if ( found ) { found = _BOOL ; for ( int i = height - _NUM ; i > _NUM ; i -= rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , START_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } } counters = new int [ STOP_PATTERN . length ] ; if ( found ) { found = _BOOL ; for ( int i = _NUM ; i < height ; i += rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , STOP_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } } if ( found ) { found = _BOOL ; for ( int i = height - _NUM ; i > _NUM ; i -= rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , STOP_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } } return found ? result : null ; }
private static ResultPoint [ ] findVertices ( BitMatrix matrix , boolean tryHarder ) { int height = matrix . getHeight ( ) ; int width = matrix . getWidth ( ) ; ResultPoint [ ] result = new ResultPoint [ _NUM ] ; boolean found = _BOOL ; int [ ] counters = new int [ START_PATTERN . length ] ; int rowStep = Math . max ( _NUM , height > > ( tryHarder ? _NUM : _NUM ) ) ; for ( int i = _NUM ; i < height ; i += rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , START_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } if ( found ) { found = _BOOL ; for ( int i = height - _NUM ; i > _NUM ; i -= rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , START_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } } counters = new int [ STOP_PATTERN . length ] ; if ( found ) { found = _BOOL ; for ( int i = _NUM ; i < height ; i += rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , STOP_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } } if ( found ) { found = _BOOL ; for ( int i = height - _NUM ; i > _NUM ; i -= rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , STOP_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } } return found ? result : null ; }
private static ResultPoint [ ] findVertices ( BitMatrix matrix , boolean tryHarder ) { int height = matrix . getHeight ( ) ; int width = matrix . getWidth ( ) ; ResultPoint [ ] result = new ResultPoint [ _NUM ] ; boolean found = _BOOL ; int [ ] counters = new int [ START_PATTERN . length ] ; int rowStep = Math . max ( _NUM , height > > ( tryHarder ? _NUM : _NUM ) ) ; for ( int i = _NUM ; i < height ; i += rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , START_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } if ( found ) { found = _BOOL ; for ( int i = height - _NUM ; i > _NUM ; i -= rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , START_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } } counters = new int [ STOP_PATTERN . length ] ; if ( found ) { found = _BOOL ; for ( int i = _NUM ; i < height ; i += rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , STOP_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } } if ( found ) { found = _BOOL ; for ( int i = height - _NUM ; i > _NUM ; i -= rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , STOP_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } } return found ? result : null ; }
private static ResultPoint [ ] findVertices ( BitMatrix matrix , boolean tryHarder ) { int height = matrix . getHeight ( ) ; int width = matrix . getWidth ( ) ; ResultPoint [ ] result = new ResultPoint [ _NUM ] ; boolean found = _BOOL ; int [ ] counters = new int [ START_PATTERN . length ] ; int rowStep = Math . max ( _NUM , height > > ( tryHarder ? _NUM : _NUM ) ) ; for ( int i = _NUM ; i < height ; i += rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , START_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } if ( found ) { found = _BOOL ; for ( int i = height - _NUM ; i > _NUM ; i -= rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , START_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } } counters = new int [ STOP_PATTERN . length ] ; if ( found ) { found = _BOOL ; for ( int i = _NUM ; i < height ; i += rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , STOP_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } } if ( found ) { found = _BOOL ; for ( int i = height - _NUM ; i > _NUM ; i -= rowStep ) { int [ ] loc = findGuardPattern ( matrix , _NUM , i , width , _BOOL , STOP_PATTERN , counters ) ; if ( loc != null ) { result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; result [ _NUM ] = new ResultPoint ( loc [ _NUM ] , i ) ; found = _BOOL ; break ; } } } return found ? result : null ; }
public boolean removeDataSet ( int index ) { if ( index >= mDataSets . size ( ) || index < _NUM ) return _BOOL ; T set = mDataSets . get ( index ) ; return removeDataSet ( set ) ; }
public boolean removeDataSet ( int index ) { if ( index >= mDataSets . size ( ) || index < _NUM ) return _BOOL ; T set = mDataSets . get ( index ) ; return removeDataSet ( set ) ; }
public boolean removeDataSet ( int index ) { if ( index >= mDataSets . size ( ) || index < _NUM ) return _BOOL ; T set = mDataSets . get ( index ) ; return removeDataSet ( set ) ; }
public boolean removeDataSet ( int index ) { if ( index >= mDataSets . size ( ) || index < _NUM ) return _BOOL ; T set = mDataSets . get ( index ) ; return removeDataSet ( set ) ; }
private void upgradePrivileges ( PrivilegeManager pm , String appName , String resourceTypeUUID ) throws UpgradeException { final SearchFilter searchFilter = new SearchFilter ( Privilege . APPLICATION_SEARCH_ATTRIBUTE , appName ) ; try { final List < Privilege > privileges = pm . search ( Collections . singleton ( searchFilter ) ) ; for ( Privilege privilege : privileges ) { if ( StringUtils . isEmpty ( privilege . getResourceTypeUuid ( ) ) ) { upgradePrivilege ( pm , privilege , resourceTypeUUID ) ; } } } catch ( EntitlementException ee ) { throw new UpgradeException ( STRING + appName , ee ) ; } }
private void upgradePrivileges ( PrivilegeManager pm , String appName , String resourceTypeUUID ) throws UpgradeException { final SearchFilter searchFilter = new SearchFilter ( Privilege . APPLICATION_SEARCH_ATTRIBUTE , appName ) ; try { final List < Privilege > privileges = pm . search ( Collections . singleton ( searchFilter ) ) ; for ( Privilege privilege : privileges ) { if ( StringUtils . isEmpty ( privilege . getResourceTypeUuid ( ) ) ) { upgradePrivilege ( pm , privilege , resourceTypeUUID ) ; } } } catch ( EntitlementException ee ) { throw new UpgradeException ( STRING + appName , ee ) ; } }
private void upgradePrivileges ( PrivilegeManager pm , String appName , String resourceTypeUUID ) throws UpgradeException { final SearchFilter searchFilter = new SearchFilter ( Privilege . APPLICATION_SEARCH_ATTRIBUTE , appName ) ; try { final List < Privilege > privileges = pm . search ( Collections . singleton ( searchFilter ) ) ; for ( Privilege privilege : privileges ) { if ( StringUtils . isEmpty ( privilege . getResourceTypeUuid ( ) ) ) { upgradePrivilege ( pm , privilege , resourceTypeUUID ) ; } } } catch ( EntitlementException ee ) { throw new UpgradeException ( STRING + appName , ee ) ; } }
private void flushFullBuffer ( int minSize ) { flushedBuffers . add ( new LiteralByteString ( buffer ) ) ; flushedBuffersTotalBytes += buffer . length ; int newSize = Math . max ( initialCapacity , Math . max ( minSize , flushedBuffersTotalBytes > > > _NUM ) ) ; buffer = new byte [ newSize ] ; bufferPos = _NUM ; }
private void flushFullBuffer ( int minSize ) { flushedBuffers . add ( new LiteralByteString ( buffer ) ) ; flushedBuffersTotalBytes += buffer . length ; int newSize = Math . max ( initialCapacity , Math . max ( minSize , flushedBuffersTotalBytes > > > _NUM ) ) ; buffer = new byte [ newSize ] ; bufferPos = _NUM ; }
private void flushFullBuffer ( int minSize ) { flushedBuffers . add ( new LiteralByteString ( buffer ) ) ; flushedBuffersTotalBytes += buffer . length ; int newSize = Math . max ( initialCapacity , Math . max ( minSize , flushedBuffersTotalBytes > > > _NUM ) ) ; buffer = new byte [ newSize ] ; bufferPos = _NUM ; }
public byte [ ] toByteArray ( String ascii ) { if ( ascii == null ) { return EMPTY_BYTE_ARRAY ; } return fromAscii ( ascii . toCharArray ( ) ) ; }
public byte [ ] toByteArray ( String ascii ) { if ( ascii == null ) { return EMPTY_BYTE_ARRAY ; } return fromAscii ( ascii . toCharArray ( ) ) ; }
public byte [ ] toByteArray ( String ascii ) { if ( ascii == null ) { return EMPTY_BYTE_ARRAY ; } return fromAscii ( ascii . toCharArray ( ) ) ; }
public byte [ ] toByteArray ( String ascii ) { if ( ascii == null ) { return EMPTY_BYTE_ARRAY ; } return fromAscii ( ascii . toCharArray ( ) ) ; }
private PooledByteBuffer readFromDiskCache ( final CacheKey key ) throws IOException { try { FLog . v ( TAG , STRING , key . toString ( ) ) ; final BinaryResource diskCacheResource = mFileCache . getResource ( key ) ; if ( diskCacheResource == null ) { FLog . v ( TAG , STRING , key . toString ( ) ) ; mImageCacheStatsTracker . onDiskCacheMiss ( ) ; return null ; } else { FLog . v ( TAG , STRING , key . toString ( ) ) ; mImageCacheStatsTracker . onDiskCacheHit ( ) ; } PooledByteBuffer byteBuffer ; final InputStream is = diskCacheResource . openStream ( ) ; try { byteBuffer = mPooledByteBufferFactory . newByteBuffer ( is , ( int ) diskCacheResource . size ( ) ) ; } finally { is . close ( ) ; } FLog . v ( TAG , STRING , key . toString ( ) ) ; return byteBuffer ; } catch ( IOException ioe ) { FLog . w ( TAG , ioe , STRING , key . toString ( ) ) ; mImageCacheStatsTracker . onDiskCacheGetFail ( ) ; throw ioe ; } }
public static boolean isRelayStateURLValid ( String metaAlias , String relayState , String role ) { boolean result = _BOOL ; if ( metaAlias != null ) { String realm = SAML2MetaUtils . getRealmByMetaAlias ( metaAlias ) ; try { String hostEntityID = saml2MetaManager . getEntityByMetaAlias ( metaAlias ) ; if ( hostEntityID != null ) { validateRelayStateURL ( realm , hostEntityID , relayState , role ) ; result = _BOOL ; } } catch ( SAML2Exception e ) { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + relayState + STRING + role + STRING + e . getMessage ( ) , e ) ; } result = _BOOL ; } } if ( debug . messageEnabled ( ) ) { debug . message ( STRING + relayState + STRING + role + STRING + result ) ; } return result ; }
public static boolean isRelayStateURLValid ( String metaAlias , String relayState , String role ) { boolean result = _BOOL ; if ( metaAlias != null ) { String realm = SAML2MetaUtils . getRealmByMetaAlias ( metaAlias ) ; try { String hostEntityID = saml2MetaManager . getEntityByMetaAlias ( metaAlias ) ; if ( hostEntityID != null ) { validateRelayStateURL ( realm , hostEntityID , relayState , role ) ; result = _BOOL ; } } catch ( SAML2Exception e ) { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + relayState + STRING + role + STRING + e . getMessage ( ) , e ) ; } result = _BOOL ; } } if ( debug . messageEnabled ( ) ) { debug . message ( STRING + relayState + STRING + role + STRING + result ) ; } return result ; }
static int innerNewVecInsertPos ( int oldPos , int idx , Vector < Insertion > vec ) { if ( vec . size ( ) <= idx ) { return oldPos ; } else { return innerNewVecInsertPos ( newInsertPos ( oldPos , vec . elementAt ( idx ) ) , idx + _NUM , vec ) ; } }
static int innerNewVecInsertPos ( int oldPos , int idx , Vector < Insertion > vec ) { if ( vec . size ( ) <= idx ) { return oldPos ; } else { return innerNewVecInsertPos ( newInsertPos ( oldPos , vec . elementAt ( idx ) ) , idx + _NUM , vec ) ; } }
static int innerNewVecInsertPos ( int oldPos , int idx , Vector < Insertion > vec ) { if ( vec . size ( ) <= idx ) { return oldPos ; } else { return innerNewVecInsertPos ( newInsertPos ( oldPos , vec . elementAt ( idx ) ) , idx + _NUM , vec ) ; } }
@ Override public boolean remove ( Object object ) { return removeElement ( object ) ; }
@ Override public boolean remove ( Object object ) { return removeElement ( object ) ; }
@ Override public boolean remove ( Object object ) { return removeElement ( object ) ; }
@ Override public boolean remove ( Object object ) { return removeElement ( object ) ; }
@ Override public boolean remove ( Object object ) { return removeElement ( object ) ; }
@ Override public boolean remove ( Object object ) { return removeElement ( object ) ; }
@ Override public boolean remove ( Object object ) { return removeElement ( object ) ; }
public static String readTextFile ( String fileName ) throws IOException { byte [ ] buff = readFile ( fileName ) ; String s = new String ( buff ) ; return s ; }
public static String readTextFile ( String fileName ) throws IOException { byte [ ] buff = readFile ( fileName ) ; String s = new String ( buff ) ; return s ; }
public static String readTextFile ( String fileName ) throws IOException { byte [ ] buff = readFile ( fileName ) ; String s = new String ( buff ) ; return s ; }
public void testPreferencesClobbersExistingFiles ( ) throws Exception { File userPrefs = new File ( System . getProperty ( STRING ) + STRING ) ; FileWriter writer = new FileWriter ( userPrefs ) ; writer . write ( STRING ) ; writer . close ( ) ; userPrefs . setReadable ( _BOOL ) ; userPrefs . setWritable ( _BOOL ) ; long oldLength = userPrefs . length ( ) ; Preferences userPreferences = Preferences . userRoot ( ) ; userPreferences . sync ( ) ; userPreferences . put ( STRING , STRING ) ; userPreferences . flush ( ) ; assertTrue ( STRING + userPrefs , userPrefs . exists ( ) ) ; assertTrue ( STRING , oldLength != userPrefs . length ( ) ) ; }
public void testPreferencesClobbersExistingFiles ( ) throws Exception { File userPrefs = new File ( System . getProperty ( STRING ) + STRING ) ; FileWriter writer = new FileWriter ( userPrefs ) ; writer . write ( STRING ) ; writer . close ( ) ; userPrefs . setReadable ( _BOOL ) ; userPrefs . setWritable ( _BOOL ) ; long oldLength = userPrefs . length ( ) ; Preferences userPreferences = Preferences . userRoot ( ) ; userPreferences . sync ( ) ; userPreferences . put ( STRING , STRING ) ; userPreferences . flush ( ) ; assertTrue ( STRING + userPrefs , userPrefs . exists ( ) ) ; assertTrue ( STRING , oldLength != userPrefs . length ( ) ) ; }
public void testPreferencesClobbersExistingFiles ( ) throws Exception { File userPrefs = new File ( System . getProperty ( STRING ) + STRING ) ; FileWriter writer = new FileWriter ( userPrefs ) ; writer . write ( STRING ) ; writer . close ( ) ; userPrefs . setReadable ( _BOOL ) ; userPrefs . setWritable ( _BOOL ) ; long oldLength = userPrefs . length ( ) ; Preferences userPreferences = Preferences . userRoot ( ) ; userPreferences . sync ( ) ; userPreferences . put ( STRING , STRING ) ; userPreferences . flush ( ) ; assertTrue ( STRING + userPrefs , userPrefs . exists ( ) ) ; assertTrue ( STRING , oldLength != userPrefs . length ( ) ) ; }
public void testPreferencesClobbersExistingFiles ( ) throws Exception { File userPrefs = new File ( System . getProperty ( STRING ) + STRING ) ; FileWriter writer = new FileWriter ( userPrefs ) ; writer . write ( STRING ) ; writer . close ( ) ; userPrefs . setReadable ( _BOOL ) ; userPrefs . setWritable ( _BOOL ) ; long oldLength = userPrefs . length ( ) ; Preferences userPreferences = Preferences . userRoot ( ) ; userPreferences . sync ( ) ; userPreferences . put ( STRING , STRING ) ; userPreferences . flush ( ) ; assertTrue ( STRING + userPrefs , userPrefs . exists ( ) ) ; assertTrue ( STRING , oldLength != userPrefs . length ( ) ) ; }
public void testPreferencesClobbersExistingFiles ( ) throws Exception { File userPrefs = new File ( System . getProperty ( STRING ) + STRING ) ; FileWriter writer = new FileWriter ( userPrefs ) ; writer . write ( STRING ) ; writer . close ( ) ; userPrefs . setReadable ( _BOOL ) ; userPrefs . setWritable ( _BOOL ) ; long oldLength = userPrefs . length ( ) ; Preferences userPreferences = Preferences . userRoot ( ) ; userPreferences . sync ( ) ; userPreferences . put ( STRING , STRING ) ; userPreferences . flush ( ) ; assertTrue ( STRING + userPrefs , userPrefs . exists ( ) ) ; assertTrue ( STRING , oldLength != userPrefs . length ( ) ) ; }
public void testPreferencesClobbersExistingFiles ( ) throws Exception { File userPrefs = new File ( System . getProperty ( STRING ) + STRING ) ; FileWriter writer = new FileWriter ( userPrefs ) ; writer . write ( STRING ) ; writer . close ( ) ; userPrefs . setReadable ( _BOOL ) ; userPrefs . setWritable ( _BOOL ) ; long oldLength = userPrefs . length ( ) ; Preferences userPreferences = Preferences . userRoot ( ) ; userPreferences . sync ( ) ; userPreferences . put ( STRING , STRING ) ; userPreferences . flush ( ) ; assertTrue ( STRING + userPrefs , userPrefs . exists ( ) ) ; assertTrue ( STRING , oldLength != userPrefs . length ( ) ) ; }
public void testPreferencesClobbersExistingFiles ( ) throws Exception { File userPrefs = new File ( System . getProperty ( STRING ) + STRING ) ; FileWriter writer = new FileWriter ( userPrefs ) ; writer . write ( STRING ) ; writer . close ( ) ; userPrefs . setReadable ( _BOOL ) ; userPrefs . setWritable ( _BOOL ) ; long oldLength = userPrefs . length ( ) ; Preferences userPreferences = Preferences . userRoot ( ) ; userPreferences . sync ( ) ; userPreferences . put ( STRING , STRING ) ; userPreferences . flush ( ) ; assertTrue ( STRING + userPrefs , userPrefs . exists ( ) ) ; assertTrue ( STRING , oldLength != userPrefs . length ( ) ) ; }
public void testPreferencesClobbersExistingFiles ( ) throws Exception { File userPrefs = new File ( System . getProperty ( STRING ) + STRING ) ; FileWriter writer = new FileWriter ( userPrefs ) ; writer . write ( STRING ) ; writer . close ( ) ; userPrefs . setReadable ( _BOOL ) ; userPrefs . setWritable ( _BOOL ) ; long oldLength = userPrefs . length ( ) ; Preferences userPreferences = Preferences . userRoot ( ) ; userPreferences . sync ( ) ; userPreferences . put ( STRING , STRING ) ; userPreferences . flush ( ) ; assertTrue ( STRING + userPrefs , userPrefs . exists ( ) ) ; assertTrue ( STRING , oldLength != userPrefs . length ( ) ) ; }
public void testPreferencesClobbersExistingFiles ( ) throws Exception { File userPrefs = new File ( System . getProperty ( STRING ) + STRING ) ; FileWriter writer = new FileWriter ( userPrefs ) ; writer . write ( STRING ) ; writer . close ( ) ; userPrefs . setReadable ( _BOOL ) ; userPrefs . setWritable ( _BOOL ) ; long oldLength = userPrefs . length ( ) ; Preferences userPreferences = Preferences . userRoot ( ) ; userPreferences . sync ( ) ; userPreferences . put ( STRING , STRING ) ; userPreferences . flush ( ) ; assertTrue ( STRING + userPrefs , userPrefs . exists ( ) ) ; assertTrue ( STRING , oldLength != userPrefs . length ( ) ) ; }
public void testPreferencesClobbersExistingFiles ( ) throws Exception { File userPrefs = new File ( System . getProperty ( STRING ) + STRING ) ; FileWriter writer = new FileWriter ( userPrefs ) ; writer . write ( STRING ) ; writer . close ( ) ; userPrefs . setReadable ( _BOOL ) ; userPrefs . setWritable ( _BOOL ) ; long oldLength = userPrefs . length ( ) ; Preferences userPreferences = Preferences . userRoot ( ) ; userPreferences . sync ( ) ; userPreferences . put ( STRING , STRING ) ; userPreferences . flush ( ) ; assertTrue ( STRING + userPrefs , userPrefs . exists ( ) ) ; assertTrue ( STRING , oldLength != userPrefs . length ( ) ) ; }
public void testPreferencesClobbersExistingFiles ( ) throws Exception { File userPrefs = new File ( System . getProperty ( STRING ) + STRING ) ; FileWriter writer = new FileWriter ( userPrefs ) ; writer . write ( STRING ) ; writer . close ( ) ; userPrefs . setReadable ( _BOOL ) ; userPrefs . setWritable ( _BOOL ) ; long oldLength = userPrefs . length ( ) ; Preferences userPreferences = Preferences . userRoot ( ) ; userPreferences . sync ( ) ; userPreferences . put ( STRING , STRING ) ; userPreferences . flush ( ) ; assertTrue ( STRING + userPrefs , userPrefs . exists ( ) ) ; assertTrue ( STRING , oldLength != userPrefs . length ( ) ) ; }
public boolean isSrcClass ( SootClass clz ) { return isSrcClass ( clz . getName ( ) ) ; }
public Analyzer saveAnalysis ( File file ) throws IOException { PrintStream ps = null ; try { ps = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( file ) ) ) ; printAnalysis ( ps ) ; } finally { if ( ps != null ) { ps . close ( ) ; } } return this ; }
public Analyzer saveAnalysis ( File file ) throws IOException { PrintStream ps = null ; try { ps = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( file ) ) ) ; printAnalysis ( ps ) ; } finally { if ( ps != null ) { ps . close ( ) ; } } return this ; }
public Analyzer saveAnalysis ( File file ) throws IOException { PrintStream ps = null ; try { ps = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( file ) ) ) ; printAnalysis ( ps ) ; } finally { if ( ps != null ) { ps . close ( ) ; } } return this ; }
public Analyzer saveAnalysis ( File file ) throws IOException { PrintStream ps = null ; try { ps = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( file ) ) ) ; printAnalysis ( ps ) ; } finally { if ( ps != null ) { ps . close ( ) ; } } return this ; }
public Analyzer saveAnalysis ( File file ) throws IOException { PrintStream ps = null ; try { ps = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( file ) ) ) ; printAnalysis ( ps ) ; } finally { if ( ps != null ) { ps . close ( ) ; } } return this ; }
public DNSOutgoing addAnswer ( DNSIncoming in , InetAddress addr , int port , DNSOutgoing out , DNSRecord rec ) throws IOException { DNSOutgoing newOut = out ; if ( newOut == null ) { newOut = new DNSOutgoing ( DNSConstants . FLAGS_QR_RESPONSE | DNSConstants . FLAGS_AA , _BOOL , in . getSenderUDPPayload ( ) ) ; } try { newOut . addAnswer ( in , rec ) ; } catch ( final IOException e ) { newOut . setFlags ( newOut . getFlags ( ) | DNSConstants . FLAGS_TC ) ; newOut . setId ( in . getId ( ) ) ; send ( newOut ) ; newOut = new DNSOutgoing ( DNSConstants . FLAGS_QR_RESPONSE | DNSConstants . FLAGS_AA , _BOOL , in . getSenderUDPPayload ( ) ) ; newOut . addAnswer ( in , rec ) ; } return newOut ; }
public DNSOutgoing addAnswer ( DNSIncoming in , InetAddress addr , int port , DNSOutgoing out , DNSRecord rec ) throws IOException { DNSOutgoing newOut = out ; if ( newOut == null ) { newOut = new DNSOutgoing ( DNSConstants . FLAGS_QR_RESPONSE | DNSConstants . FLAGS_AA , _BOOL , in . getSenderUDPPayload ( ) ) ; } try { newOut . addAnswer ( in , rec ) ; } catch ( final IOException e ) { newOut . setFlags ( newOut . getFlags ( ) | DNSConstants . FLAGS_TC ) ; newOut . setId ( in . getId ( ) ) ; send ( newOut ) ; newOut = new DNSOutgoing ( DNSConstants . FLAGS_QR_RESPONSE | DNSConstants . FLAGS_AA , _BOOL , in . getSenderUDPPayload ( ) ) ; newOut . addAnswer ( in , rec ) ; } return newOut ; }
public DNSOutgoing addAnswer ( DNSIncoming in , InetAddress addr , int port , DNSOutgoing out , DNSRecord rec ) throws IOException { DNSOutgoing newOut = out ; if ( newOut == null ) { newOut = new DNSOutgoing ( DNSConstants . FLAGS_QR_RESPONSE | DNSConstants . FLAGS_AA , _BOOL , in . getSenderUDPPayload ( ) ) ; } try { newOut . addAnswer ( in , rec ) ; } catch ( final IOException e ) { newOut . setFlags ( newOut . getFlags ( ) | DNSConstants . FLAGS_TC ) ; newOut . setId ( in . getId ( ) ) ; send ( newOut ) ; newOut = new DNSOutgoing ( DNSConstants . FLAGS_QR_RESPONSE | DNSConstants . FLAGS_AA , _BOOL , in . getSenderUDPPayload ( ) ) ; newOut . addAnswer ( in , rec ) ; } return newOut ; }
ScheduledFutureTask ( Runnable r , V result , long ns ) { super ( r , result ) ; this . time = ns ; this . period = _NUM ; this . sequenceNumber = sequencer . getAndIncrement ( ) ; }
ScheduledFutureTask ( Runnable r , V result , long ns ) { super ( r , result ) ; this . time = ns ; this . period = _NUM ; this . sequenceNumber = sequencer . getAndIncrement ( ) ; }
public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { append ( m_doc . createComment ( new String ( ch , start , length ) ) ) ; }
public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { append ( m_doc . createComment ( new String ( ch , start , length ) ) ) ; }
public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { append ( m_doc . createComment ( new String ( ch , start , length ) ) ) ; }
public static void sortByValueStable ( int start , int end , double [ ] values , int [ ] indexes ) { sortByValue ( start , end , values , indexes ) ; for ( int i = _NUM ; i < values . length - _NUM ; i ++ ) { double tmp = values [ i ] ; int len = _NUM ; while ( i + len + _NUM < values . length && tmp == values [ i + len + _NUM ] ) len ++ ; if ( len > _NUM ) { Arrays . sort ( indexes , i , i + len + _NUM ) ; i += len ; } } }
public static byte [ ] readFullyNoClose ( InputStream in ) throws IOException { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ _NUM ] ; int count ; while ( ( count = in . read ( buffer ) ) != - _NUM ) { bytes . write ( buffer , _NUM , count ) ; } return bytes . toByteArray ( ) ; }
public static byte [ ] readFullyNoClose ( InputStream in ) throws IOException { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ _NUM ] ; int count ; while ( ( count = in . read ( buffer ) ) != - _NUM ) { bytes . write ( buffer , _NUM , count ) ; } return bytes . toByteArray ( ) ; }
public static byte [ ] readFullyNoClose ( InputStream in ) throws IOException { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ _NUM ] ; int count ; while ( ( count = in . read ( buffer ) ) != - _NUM ) { bytes . write ( buffer , _NUM , count ) ; } return bytes . toByteArray ( ) ; }
@ SuppressWarnings ( STRING ) default T add ( String ... rows ) { requireNonNullElements ( rows ) ; for ( final String row : rows ) { Collections . addAll ( getCode ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ SuppressWarnings ( STRING ) default T add ( String ... rows ) { requireNonNullElements ( rows ) ; for ( final String row : rows ) { Collections . addAll ( getCode ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ SuppressWarnings ( STRING ) default T add ( String ... rows ) { requireNonNullElements ( rows ) ; for ( final String row : rows ) { Collections . addAll ( getCode ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ SuppressWarnings ( STRING ) default T add ( String ... rows ) { requireNonNullElements ( rows ) ; for ( final String row : rows ) { Collections . addAll ( getCode ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ SuppressWarnings ( STRING ) default T add ( String ... rows ) { requireNonNullElements ( rows ) ; for ( final String row : rows ) { Collections . addAll ( getCode ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ SuppressWarnings ( STRING ) default T add ( String ... rows ) { requireNonNullElements ( rows ) ; for ( final String row : rows ) { Collections . addAll ( getCode ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ SuppressWarnings ( STRING ) default T add ( String ... rows ) { requireNonNullElements ( rows ) ; for ( final String row : rows ) { Collections . addAll ( getCode ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ SuppressWarnings ( STRING ) default T add ( String ... rows ) { requireNonNullElements ( rows ) ; for ( final String row : rows ) { Collections . addAll ( getCode ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ SuppressWarnings ( STRING ) default T add ( String ... rows ) { requireNonNullElements ( rows ) ; for ( final String row : rows ) { Collections . addAll ( getCode ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
private static String convertToQuotedString ( String string ) { if ( string == null || string . length ( ) == _NUM ) { return null ; } if ( string . charAt ( _NUM ) == STRING && string . charAt ( string . length ( ) - _NUM ) == STRING ) { return string ; } return STRING + string + STRING ; }
private static String convertToQuotedString ( String string ) { if ( string == null || string . length ( ) == _NUM ) { return null ; } if ( string . charAt ( _NUM ) == STRING && string . charAt ( string . length ( ) - _NUM ) == STRING ) { return string ; } return STRING + string + STRING ; }
private static String convertToQuotedString ( String string ) { if ( string == null || string . length ( ) == _NUM ) { return null ; } if ( string . charAt ( _NUM ) == STRING && string . charAt ( string . length ( ) - _NUM ) == STRING ) { return string ; } return STRING + string + STRING ; }
private static String convertToQuotedString ( String string ) { if ( string == null || string . length ( ) == _NUM ) { return null ; } if ( string . charAt ( _NUM ) == STRING && string . charAt ( string . length ( ) - _NUM ) == STRING ) { return string ; } return STRING + string + STRING ; }
private static String convertToQuotedString ( String string ) { if ( string == null || string . length ( ) == _NUM ) { return null ; } if ( string . charAt ( _NUM ) == STRING && string . charAt ( string . length ( ) - _NUM ) == STRING ) { return string ; } return STRING + string + STRING ; }
public synchronized void stop ( ) { mRun = _BOOL ; if ( mProcess != null ) { mProcess . destroy ( ) ; mProcess = null ; } try { mThread . join ( ) ; } catch ( InterruptedException e ) { } mThread = null ; mCallback = null ; }