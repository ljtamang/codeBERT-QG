public void add ( double x , double y ) { data . add ( x ) ; data . add ( y ) ; minx = Math . min ( minx , x ) ; maxx = Math . max ( maxx , x ) ; miny = Math . min ( miny , y ) ; maxy = Math . max ( maxy , y ) ; }
public void handle Tbl Bootstrap Res Off Button Add Request ( Request Invocation Event event ) throws Model Control Exception { try { Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute ( PROPERTY ATTRIBUTE , ( Hash Map ) values ) ; SM Discovery Bootstrap Ref Off Add View Bean vb = ( SM Discovery Bootstrap Ref Off Add View Bean ) get View Bean ( SM Discovery Bootstrap Ref Off Add View Bean . class ) ; remove Page Session Attribute ( SM Discovery Bootstrap Ref Off Add View Bean . PROPERTY ATTRIBUTE ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; } }
public void handle Tbl Bootstrap Res Off Button Add Request ( Request Invocation Event event ) throws Model Control Exception { try { Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute ( PROPERTY ATTRIBUTE , ( Hash Map ) values ) ; SM Discovery Bootstrap Ref Off Add View Bean vb = ( SM Discovery Bootstrap Ref Off Add View Bean ) get View Bean ( SM Discovery Bootstrap Ref Off Add View Bean . class ) ; remove Page Session Attribute ( SM Discovery Bootstrap Ref Off Add View Bean . PROPERTY ATTRIBUTE ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; } }
public static double volume Union ( Spatial Comparable box 1 , Spatial Comparable box 2 ) { final int dim = assert Same Dimensionality ( box 1 , box 2 ) ; double volume = NUM ; for ( int i = NUM ; i < dim ; i ++ ) { final double min = Math . min ( box 1 . get Min ( i ) , box 2 . get Min ( i ) ) ; final double max = Math . max ( box 1 . get Max ( i ) , box 2 . get Max ( i ) ) ; volume *= ( max - min ) ; } return volume ; }
public void test Set Date int Date ( ) throws SQL Exception { Calendar cal = new Gregorian Calendar ( NUM , NUM , NUM ) ; Date [ ] dates = { new Date ( cal . get Time In Millis ( ) ) , new Date ( Integer . MAX VALUE ) , new Date ( NUM ) } ; Prepared Statement ps = null ; Prepared Statement ps 1 = null ; try { String query = STRING ; ps = conn . prepare Statement ( query ) ; for ( int i = NUM ; i < dates . length ; i ++ ) { ps . set Date ( NUM , dates [ i ] ) ; assert False ( ps . execute ( ) ) ; assert True ( ps . get Update Count ( ) > NUM ) ; } try { ps . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( Exception sqle ) { } ps . close ( ) ; try { ps . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( SQL Exception sqle ) { } String query 1 = STRING ; ps 1 = conn . prepare Statement ( query 1 ) ; try { ps 1 . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( SQL Exception sqle ) { assert Equals ( STRING , sqle . get Message ( ) ) ; } } finally { try { if ( ps != null ) ps . close ( ) ; if ( ps 1 != null ) ps 1 . close ( ) ; } catch ( SQL Exception ee ) { } } }
public void test Set Date int Date ( ) throws SQL Exception { Calendar cal = new Gregorian Calendar ( NUM , NUM , NUM ) ; Date [ ] dates = { new Date ( cal . get Time In Millis ( ) ) , new Date ( Integer . MAX VALUE ) , new Date ( NUM ) } ; Prepared Statement ps = null ; Prepared Statement ps 1 = null ; try { String query = STRING ; ps = conn . prepare Statement ( query ) ; for ( int i = NUM ; i < dates . length ; i ++ ) { ps . set Date ( NUM , dates [ i ] ) ; assert False ( ps . execute ( ) ) ; assert True ( ps . get Update Count ( ) > NUM ) ; } try { ps . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( Exception sqle ) { } ps . close ( ) ; try { ps . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( SQL Exception sqle ) { } String query 1 = STRING ; ps 1 = conn . prepare Statement ( query 1 ) ; try { ps 1 . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( SQL Exception sqle ) { assert Equals ( STRING , sqle . get Message ( ) ) ; } } finally { try { if ( ps != null ) ps . close ( ) ; if ( ps 1 != null ) ps 1 . close ( ) ; } catch ( SQL Exception ee ) { } } }
public void test Set Date int Date ( ) throws SQL Exception { Calendar cal = new Gregorian Calendar ( NUM , NUM , NUM ) ; Date [ ] dates = { new Date ( cal . get Time In Millis ( ) ) , new Date ( Integer . MAX VALUE ) , new Date ( NUM ) } ; Prepared Statement ps = null ; Prepared Statement ps 1 = null ; try { String query = STRING ; ps = conn . prepare Statement ( query ) ; for ( int i = NUM ; i < dates . length ; i ++ ) { ps . set Date ( NUM , dates [ i ] ) ; assert False ( ps . execute ( ) ) ; assert True ( ps . get Update Count ( ) > NUM ) ; } try { ps . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( Exception sqle ) { } ps . close ( ) ; try { ps . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( SQL Exception sqle ) { } String query 1 = STRING ; ps 1 = conn . prepare Statement ( query 1 ) ; try { ps 1 . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( SQL Exception sqle ) { assert Equals ( STRING , sqle . get Message ( ) ) ; } } finally { try { if ( ps != null ) ps . close ( ) ; if ( ps 1 != null ) ps 1 . close ( ) ; } catch ( SQL Exception ee ) { } } }
public void test Set Date int Date ( ) throws SQL Exception { Calendar cal = new Gregorian Calendar ( NUM , NUM , NUM ) ; Date [ ] dates = { new Date ( cal . get Time In Millis ( ) ) , new Date ( Integer . MAX VALUE ) , new Date ( NUM ) } ; Prepared Statement ps = null ; Prepared Statement ps 1 = null ; try { String query = STRING ; ps = conn . prepare Statement ( query ) ; for ( int i = NUM ; i < dates . length ; i ++ ) { ps . set Date ( NUM , dates [ i ] ) ; assert False ( ps . execute ( ) ) ; assert True ( ps . get Update Count ( ) > NUM ) ; } try { ps . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( Exception sqle ) { } ps . close ( ) ; try { ps . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( SQL Exception sqle ) { } String query 1 = STRING ; ps 1 = conn . prepare Statement ( query 1 ) ; try { ps 1 . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( SQL Exception sqle ) { assert Equals ( STRING , sqle . get Message ( ) ) ; } } finally { try { if ( ps != null ) ps . close ( ) ; if ( ps 1 != null ) ps 1 . close ( ) ; } catch ( SQL Exception ee ) { } } }
public void test Set Date int Date ( ) throws SQL Exception { Calendar cal = new Gregorian Calendar ( NUM , NUM , NUM ) ; Date [ ] dates = { new Date ( cal . get Time In Millis ( ) ) , new Date ( Integer . MAX VALUE ) , new Date ( NUM ) } ; Prepared Statement ps = null ; Prepared Statement ps 1 = null ; try { String query = STRING ; ps = conn . prepare Statement ( query ) ; for ( int i = NUM ; i < dates . length ; i ++ ) { ps . set Date ( NUM , dates [ i ] ) ; assert False ( ps . execute ( ) ) ; assert True ( ps . get Update Count ( ) > NUM ) ; } try { ps . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( Exception sqle ) { } ps . close ( ) ; try { ps . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( SQL Exception sqle ) { } String query 1 = STRING ; ps 1 = conn . prepare Statement ( query 1 ) ; try { ps 1 . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( SQL Exception sqle ) { assert Equals ( STRING , sqle . get Message ( ) ) ; } } finally { try { if ( ps != null ) ps . close ( ) ; if ( ps 1 != null ) ps 1 . close ( ) ; } catch ( SQL Exception ee ) { } } }
public boolean contains Baf Body ( ) { Iterator < Soot Method > method It = method Iterator ( ) ; while ( method It . has Next ( ) ) { Soot Method m = method It . next ( ) ; if ( m . has Active Body ( ) && m . get Active Body ( ) instanceof soot . baf . Baf Body ) { return BOOL ; } } return BOOL ; }
public boolean contains Baf Body ( ) { Iterator < Soot Method > method It = method Iterator ( ) ; while ( method It . has Next ( ) ) { Soot Method m = method It . next ( ) ; if ( m . has Active Body ( ) && m . get Active Body ( ) instanceof soot . baf . Baf Body ) { return BOOL ; } } return BOOL ; }
private Socket connect ( String host , String port String ) throws IO Exception { int port = NUM ; Socket sock = null ; boolean DEBUG = Debug . debugging ( STRING ) ; try { port = Integer . parse Int ( port String , NUM ) ; } catch ( Number Format Exception e ) { if ( DEBUG ) Debug . output ( STRING + host + STRING + port String ) ; throw new IO Exception ( STRING + port String ) ; } if ( DEBUG ) Debug . output ( STRING + host + STRING + port ) ; try { sock = new Socket ( host , port ) ; } catch ( IO Exception e ) { if ( sock != null ) sock . close ( ) ; if ( DEBUG ) { Debug . output ( STRING + host + STRING + port + STRING + e ) ; } throw e ; } return sock ; }
private Socket connect ( String host , String port String ) throws IO Exception { int port = NUM ; Socket sock = null ; boolean DEBUG = Debug . debugging ( STRING ) ; try { port = Integer . parse Int ( port String , NUM ) ; } catch ( Number Format Exception e ) { if ( DEBUG ) Debug . output ( STRING + host + STRING + port String ) ; throw new IO Exception ( STRING + port String ) ; } if ( DEBUG ) Debug . output ( STRING + host + STRING + port ) ; try { sock = new Socket ( host , port ) ; } catch ( IO Exception e ) { if ( sock != null ) sock . close ( ) ; if ( DEBUG ) { Debug . output ( STRING + host + STRING + port + STRING + e ) ; } throw e ; } return sock ; }
public void remove Cancel Listener ( Action Listener a ) { m cancel But . remove Action Listener ( a ) ; }
public void add Primer ( String module Filename , String extended Module Name ) { tla Buffer . append ( Resource Helper . get Extending Module Content ( module Filename , extended Module Name ) ) ; }
public void add Primer ( String module Filename , String extended Module Name ) { tla Buffer . append ( Resource Helper . get Extending Module Content ( module Filename , extended Module Name ) ) ; }
protected void validate State ( State current ) { Validation Utils . validate State ( current ) ; check Not Null ( current . execution State , STRING ) ; check Is Positive Number ( current . triggers Success , STRING ) ; check Is Positive Number ( current . triggers Error , STRING ) ; }
public static String find Edit Table ( String tables ) { if ( ! String Utils . is Empty ( tables ) ) { int spacepos = tables . index Of ( STRING ) ; int commapos = tables . index Of ( STRING ) ; if ( spacepos > NUM && ( spacepos < commapos || commapos < NUM ) ) { return tables . substring ( NUM , spacepos ) ; } else if ( commapos > NUM && ( commapos < spacepos || spacepos < NUM ) ) { return tables . substring ( NUM , commapos ) ; } return tables ; } else { throw new Illegal State Exception ( STRING ) ; } }
private void write Object ( java . io . Object Output Stream oos ) throws java . io . IO Exception { synchronized ( principals ) { oos . default Write Object ( ) ; } }
private void write Object ( java . io . Object Output Stream oos ) throws java . io . IO Exception { synchronized ( principals ) { oos . default Write Object ( ) ; } }
public void add Query Execute Listener ( Query Execute Listener l ) { m Query Execute Listeners . add ( l ) ; }
public static Request new Status Update Request ( Session session , String message , Graph Place place , List < Graph User > tags , Callback callback ) { List < String > tag Ids = null ; if ( tags != null ) { tag Ids = new Array List < String > ( tags . size ( ) ) ; for ( Graph User tag : tags ) { tag Ids . add ( tag . get Id ( ) ) ; } } String place Id = place == null ? null : place . get Id ( ) ; return new Status Update Request ( session , message , place Id , tag Ids , callback ) ; }
public static Request new Status Update Request ( Session session , String message , Graph Place place , List < Graph User > tags , Callback callback ) { List < String > tag Ids = null ; if ( tags != null ) { tag Ids = new Array List < String > ( tags . size ( ) ) ; for ( Graph User tag : tags ) { tag Ids . add ( tag . get Id ( ) ) ; } } String place Id = place == null ? null : place . get Id ( ) ; return new Status Update Request ( session , message , place Id , tag Ids , callback ) ; }
public static Request new Status Update Request ( Session session , String message , Graph Place place , List < Graph User > tags , Callback callback ) { List < String > tag Ids = null ; if ( tags != null ) { tag Ids = new Array List < String > ( tags . size ( ) ) ; for ( Graph User tag : tags ) { tag Ids . add ( tag . get Id ( ) ) ; } } String place Id = place == null ? null : place . get Id ( ) ; return new Status Update Request ( session , message , place Id , tag Ids , callback ) ; }
public boolean equals ( Object object ) { if ( this == object ) { return BOOL ; } else if ( object instanceof Namespace ) { Namespace that = ( Namespace ) object ; if ( hash Code ( ) == that . hash Code ( ) ) { return uri . equals ( that . get URI ( ) ) && prefix . equals ( that . get Prefix ( ) ) ; } } return BOOL ; }
private static Path 2 D create Top Tab Shape ( int x , int y , int w , int h , double r Top , boolean add Bottom ) { Path 2 D path = new Path 2 D . Double ( ) ; path . append ( new Line 2 D . Double ( x , y + h - NUM , x , y + r Top ) , BOOL ) ; Quad Curve 2 D curve = new Quad Curve 2 D . Double ( x , y + r Top , x , y , x + r Top , y ) ; path . append ( curve , BOOL ) ; path . append ( new Line 2 D . Double ( x + r Top , y , x + w - r Top , y ) , BOOL ) ; curve = new Quad Curve 2 D . Double ( x + w - r Top , y , x + w , y , x + w , y + r Top ) ; path . append ( curve , BOOL ) ; path . append ( new Line 2 D . Double ( x + w , y + r Top , x + w , y + h ) , BOOL ) ; if ( add Bottom ) { path . append ( new Line 2 D . Double ( x + w , y + h - NUM , x , y + h - NUM ) , BOOL ) ; } return path ; }
void resize ( int new Capacity ) { Entry [ ] old Table = table ; int old Capacity = old Table . length ; if ( old Capacity == MAXIMUM CAPACITY ) { threshold = Integer . MAX VALUE ; return ; } Entry [ ] new Table = new Entry [ new Capacity ] ; transfer ( new Table ) ; table = new Table ; threshold = ( int ) ( new Capacity * load Factor ) ; }
void resize ( int new Capacity ) { Entry [ ] old Table = table ; int old Capacity = old Table . length ; if ( old Capacity == MAXIMUM CAPACITY ) { threshold = Integer . MAX VALUE ; return ; } Entry [ ] new Table = new Entry [ new Capacity ] ; transfer ( new Table ) ; table = new Table ; threshold = ( int ) ( new Capacity * load Factor ) ; }
void resize ( int new Capacity ) { Entry [ ] old Table = table ; int old Capacity = old Table . length ; if ( old Capacity == MAXIMUM CAPACITY ) { threshold = Integer . MAX VALUE ; return ; } Entry [ ] new Table = new Entry [ new Capacity ] ; transfer ( new Table ) ; table = new Table ; threshold = ( int ) ( new Capacity * load Factor ) ; }
void resize ( int new Capacity ) { Entry [ ] old Table = table ; int old Capacity = old Table . length ; if ( old Capacity == MAXIMUM CAPACITY ) { threshold = Integer . MAX VALUE ; return ; } Entry [ ] new Table = new Entry [ new Capacity ] ; transfer ( new Table ) ; table = new Table ; threshold = ( int ) ( new Capacity * load Factor ) ; }
void resize ( int new Capacity ) { Entry [ ] old Table = table ; int old Capacity = old Table . length ; if ( old Capacity == MAXIMUM CAPACITY ) { threshold = Integer . MAX VALUE ; return ; } Entry [ ] new Table = new Entry [ new Capacity ] ; transfer ( new Table ) ; table = new Table ; threshold = ( int ) ( new Capacity * load Factor ) ; }
void resize ( int new Capacity ) { Entry [ ] old Table = table ; int old Capacity = old Table . length ; if ( old Capacity == MAXIMUM CAPACITY ) { threshold = Integer . MAX VALUE ; return ; } Entry [ ] new Table = new Entry [ new Capacity ] ; transfer ( new Table ) ; table = new Table ; threshold = ( int ) ( new Capacity * load Factor ) ; }
void resize ( int new Capacity ) { Entry [ ] old Table = table ; int old Capacity = old Table . length ; if ( old Capacity == MAXIMUM CAPACITY ) { threshold = Integer . MAX VALUE ; return ; } Entry [ ] new Table = new Entry [ new Capacity ] ; transfer ( new Table ) ; table = new Table ; threshold = ( int ) ( new Capacity * load Factor ) ; }
void resize ( int new Capacity ) { Entry [ ] old Table = table ; int old Capacity = old Table . length ; if ( old Capacity == MAXIMUM CAPACITY ) { threshold = Integer . MAX VALUE ; return ; } Entry [ ] new Table = new Entry [ new Capacity ] ; transfer ( new Table ) ; table = new Table ; threshold = ( int ) ( new Capacity * load Factor ) ; }
void resize ( int new Capacity ) { Entry [ ] old Table = table ; int old Capacity = old Table . length ; if ( old Capacity == MAXIMUM CAPACITY ) { threshold = Integer . MAX VALUE ; return ; } Entry [ ] new Table = new Entry [ new Capacity ] ; transfer ( new Table ) ; table = new Table ; threshold = ( int ) ( new Capacity * load Factor ) ; }
public static float parse Float ( String s ) { if ( POSITIVE INFINITY . equals ( s ) ) { return Float . POSITIVE INFINITY ; } else if ( NEGATIVE INFINITY . equals ( s ) ) { return Float . NEGATIVE INFINITY ; } else if ( Na N . equals ( s ) ) { return Float . Na N ; } else { s = trim Plus Sign ( s ) ; return Float . parse Float ( s ) ; } }
public void fill Polygon ( Polygon p ) { g . fill Polygon ( p ) ; }
public void add Server ( Server Openssl server ) { server List . add ( server ) ; }
private boolean render Output ( Node node , Internal Context Adapter context , Writer writer ) throws IO Exception , Method Invocation Exception , Resource Not Found Exception { String arg = STRING ; if ( node == null ) { rsvc . error ( STRING ) ; return BOOL ; } Object value = node . value ( context ) ; if ( value == null ) { rsvc . error ( STRING ) ; return BOOL ; } arg = value . to String ( ) ; Resource resource = null ; try { resource = rsvc . get Content ( arg , get Input Encoding ( context ) ) ; } catch ( Resource Not Found Exception rnfe ) { rsvc . error ( STRING + arg + STRING + context . get Current Template Name ( ) + STRING + get Line ( ) + STRING + get Column ( ) + STRING ) ; throw rnfe ; } catch ( Exception e ) { rsvc . error ( STRING + arg + STRING + context . get Current Template Name ( ) + STRING + get Line ( ) + STRING + get Column ( ) + STRING + e ) ; } if ( resource == null ) return BOOL ; writer . write ( ( String ) resource . get Data ( ) ) ; return BOOL ; }
@ Suppress Warnings ( STRING ) private Class validate Class ( Client Config cfg ) { Class clazz = null ; try { clazz = Class . for Name ( cfg . get Access Request Handler Classname ( ) ) ; } catch ( final Class Not Found Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } Object inst = null ; try { inst = Injector Holder . get Instance ( clazz ) ; } catch ( Configuration Exception | Provision Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } Access Request Handler handler = null ; try { handler = ( Access Request Handler ) inst ; } catch ( final Class Cast Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } return clazz ; }
@ Suppress Warnings ( STRING ) private Class validate Class ( Client Config cfg ) { Class clazz = null ; try { clazz = Class . for Name ( cfg . get Access Request Handler Classname ( ) ) ; } catch ( final Class Not Found Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } Object inst = null ; try { inst = Injector Holder . get Instance ( clazz ) ; } catch ( Configuration Exception | Provision Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } Access Request Handler handler = null ; try { handler = ( Access Request Handler ) inst ; } catch ( final Class Cast Exception e ) { LOG . error ( STRING + cfg . get Access Request Handler Classname ( ) + STRING + cfg . get Name ( ) + STRING , e ) ; return null ; } return clazz ; }
public Zip Entry ( String name ) { if ( name == null ) { throw new Null Pointer Exception ( ) ; } if ( name . length ( ) > NUM ) { throw new Illegal Argument Exception ( STRING ) ; } this . name = name ; }
public void train ( Map Category Values , String s Suggested Category , String s Final Category ) { if ( Category Values == null ) Category Values = new Hash Map ( ) ; if ( Category Values . size ( ) > NUM ) v Previous Decisions . add ( new Decision Support ( Category Values , s Suggested Category , s Final Category ) ) ; }
public void train ( Map Category Values , String s Suggested Category , String s Final Category ) { if ( Category Values == null ) Category Values = new Hash Map ( ) ; if ( Category Values . size ( ) > NUM ) v Previous Decisions . add ( new Decision Support ( Category Values , s Suggested Category , s Final Category ) ) ; }
@ Override protected void force Insert Attribute At ( int position ) { int index = locate Index ( position ) ; m Num Attributes ++ ; if ( ( index >= NUM ) && ( m Indices [ index ] == position ) ) { int [ ] temp Indices = new int [ m Indices . length + NUM ] ; System . arraycopy ( m Indices , NUM , temp Indices , NUM , index ) ; temp Indices [ index ] = position ; for ( int i = index ; i < m Indices . length ; i ++ ) { temp Indices [ i + NUM ] = m Indices [ i ] + NUM ; } m Indices = temp Indices ; } else { int [ ] temp Indices = new int [ m Indices . length + NUM ] ; System . arraycopy ( m Indices , NUM , temp Indices , NUM , index + NUM ) ; temp Indices [ index + NUM ] = position ; for ( int i = index + NUM ; i < m Indices . length ; i ++ ) { temp Indices [ i + NUM ] = m Indices [ i ] + NUM ; } m Indices = temp Indices ; } }
@ Override protected void force Insert Attribute At ( int position ) { int index = locate Index ( position ) ; m Num Attributes ++ ; if ( ( index >= NUM ) && ( m Indices [ index ] == position ) ) { int [ ] temp Indices = new int [ m Indices . length + NUM ] ; System . arraycopy ( m Indices , NUM , temp Indices , NUM , index ) ; temp Indices [ index ] = position ; for ( int i = index ; i < m Indices . length ; i ++ ) { temp Indices [ i + NUM ] = m Indices [ i ] + NUM ; } m Indices = temp Indices ; } else { int [ ] temp Indices = new int [ m Indices . length + NUM ] ; System . arraycopy ( m Indices , NUM , temp Indices , NUM , index + NUM ) ; temp Indices [ index + NUM ] = position ; for ( int i = index + NUM ; i < m Indices . length ; i ++ ) { temp Indices [ i + NUM ] = m Indices [ i ] + NUM ; } m Indices = temp Indices ; } }
public static boolean can Be Randomized ( Class clazz ) { return Class Utils . is Primitive Or Wrapper ( clazz ) || clazz . equals ( String . class ) || clazz . equals ( I Discord Client . class ) ; }
public void on Start ( String src File , String target File , long total Bytes ) ;
public static byte [ ] gzip ( String input ) { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; GZIP Output Stream gzos = null ; try { gzos = new GZIP Output Stream ( baos ) ; gzos . write ( input . get Bytes ( STRING ) ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } finally { if ( gzos != null ) try { gzos . close ( ) ; } catch ( IO Exception ignore ) { } } return baos . to Byte Array ( ) ; }
public static byte [ ] gzip ( String input ) { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; GZIP Output Stream gzos = null ; try { gzos = new GZIP Output Stream ( baos ) ; gzos . write ( input . get Bytes ( STRING ) ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } finally { if ( gzos != null ) try { gzos . close ( ) ; } catch ( IO Exception ignore ) { } } return baos . to Byte Array ( ) ; }
public void test Database Driver Properties User And Password Property Override DS User And Password ( ) { String driver Property String = STRING ; Properties props = new Properties ( ) ; props . set Property ( Datasource Property Set . USERNAME , STRING ) ; props . set Property ( Datasource Property Set . PASSWORD , STRING ) ; props . set Property ( Datasource Property Set . CONNECTION PROPERTIES , driver Property String ) ; Data Source ds = data Source Converter . from Properties ( props ) ; assert Equals ( STRING , ds . get Username ( ) ) ; assert Equals ( STRING , ds . get Password ( ) ) ; }
public static String to String ( URL url , Charset encoding ) throws IO Exception { Input Stream input Stream = url . open Stream ( ) ; try { return to String ( input Stream , encoding ) ; } finally { input Stream . close ( ) ; } }
public static String to String ( URL url , Charset encoding ) throws IO Exception { Input Stream input Stream = url . open Stream ( ) ; try { return to String ( input Stream , encoding ) ; } finally { input Stream . close ( ) ; } }
boolean page Scroll ( int direction ) { int next Page = - NUM ; boolean down = BOOL ; if ( direction == FOCUS UP ) { next Page = Math . max ( NUM , m Selected Position - get Child Count ( ) - NUM ) ; } else if ( direction == FOCUS DOWN ) { next Page = Math . min ( m Item Count - NUM , m Selected Position + get Child Count ( ) - NUM ) ; down = BOOL ; } if ( next Page >= NUM ) { int position = look For Selectable Position ( next Page , down ) ; if ( position >= NUM ) { m Layout Mode = LAYOUT SPECIFIC ; m Specific Left = get Padding Left ( ) + get Horizontal Fading Edge Length ( ) ; if ( down && position > m Item Count - get Child Count ( ) ) { m Layout Mode = LAYOUT FORCE RIGHT ; } if ( ! down && position < get Child Count ( ) ) { m Layout Mode = LAYOUT FORCE LEFT ; } set Selection Int ( position ) ; invoke On Item Scroll Listener ( ) ; if ( ! awaken Scroll Bars ( ) ) { invalidate ( ) ; } return BOOL ; } } return BOOL ; }
boolean page Scroll ( int direction ) { int next Page = - NUM ; boolean down = BOOL ; if ( direction == FOCUS UP ) { next Page = Math . max ( NUM , m Selected Position - get Child Count ( ) - NUM ) ; } else if ( direction == FOCUS DOWN ) { next Page = Math . min ( m Item Count - NUM , m Selected Position + get Child Count ( ) - NUM ) ; down = BOOL ; } if ( next Page >= NUM ) { int position = look For Selectable Position ( next Page , down ) ; if ( position >= NUM ) { m Layout Mode = LAYOUT SPECIFIC ; m Specific Left = get Padding Left ( ) + get Horizontal Fading Edge Length ( ) ; if ( down && position > m Item Count - get Child Count ( ) ) { m Layout Mode = LAYOUT FORCE RIGHT ; } if ( ! down && position < get Child Count ( ) ) { m Layout Mode = LAYOUT FORCE LEFT ; } set Selection Int ( position ) ; invoke On Item Scroll Listener ( ) ; if ( ! awaken Scroll Bars ( ) ) { invalidate ( ) ; } return BOOL ; } } return BOOL ; }
boolean page Scroll ( int direction ) { int next Page = - NUM ; boolean down = BOOL ; if ( direction == FOCUS UP ) { next Page = Math . max ( NUM , m Selected Position - get Child Count ( ) - NUM ) ; } else if ( direction == FOCUS DOWN ) { next Page = Math . min ( m Item Count - NUM , m Selected Position + get Child Count ( ) - NUM ) ; down = BOOL ; } if ( next Page >= NUM ) { int position = look For Selectable Position ( next Page , down ) ; if ( position >= NUM ) { m Layout Mode = LAYOUT SPECIFIC ; m Specific Left = get Padding Left ( ) + get Horizontal Fading Edge Length ( ) ; if ( down && position > m Item Count - get Child Count ( ) ) { m Layout Mode = LAYOUT FORCE RIGHT ; } if ( ! down && position < get Child Count ( ) ) { m Layout Mode = LAYOUT FORCE LEFT ; } set Selection Int ( position ) ; invoke On Item Scroll Listener ( ) ; if ( ! awaken Scroll Bars ( ) ) { invalidate ( ) ; } return BOOL ; } } return BOOL ; }
public boolean matches ( Inventory Crafting crafting , World world ) { final List < Item Stack > recipe List = new Array List < Item Stack > ( this . recipe Items ) ; for ( int i = NUM ; i < NUM ; ++ i ) { for ( int j = NUM ; j < NUM ; ++ j ) { final Item Stack actual = crafting . get Stack In Row And Column ( j , i ) ; if ( actual != null ) { boolean flag = BOOL ; final Iterator < Item Stack > iterator = recipe List . iterator ( ) ; while ( iterator . has Next ( ) ) { final Item Stack expected = iterator . next ( ) ; if ( comparator . equals ( expected , actual ) ) { flag = BOOL ; recipe List . remove ( expected ) ; break ; } } if ( ! flag ) { return BOOL ; } } } } return recipe List . is Empty ( ) ; }
public Update Log Entry add File ( Json Value file ) { files . add ( file ) ; return this ; }
public Analyzer add ( String name , Nondominated Population result ) { List < Nondominated Population > list = data . get ( name ) ; if ( list == null ) { list = new Array List < Nondominated Population > ( ) ; data . put ( name , list ) ; } list . add ( result ) ; return this ; }
public Analyzer add ( String name , Nondominated Population result ) { List < Nondominated Population > list = data . get ( name ) ; if ( list == null ) { list = new Array List < Nondominated Population > ( ) ; data . put ( name , list ) ; } list . add ( result ) ; return this ; }
public void adjust Zoom From Mouse Wheel ( int rot ) { Projection projection = get Projection ( ) ; if ( projection == null ) { return ; } set User Has Changed Scale ( BOOL ) ; Point 2 D minutes Pnt 0 = projection . inverse ( NUM , NUM ) ; Point 2 D minutes Pnt 1 = projection . inverse ( NUM , NUM ) ; double minutes Per Pixel = minutes Pnt 1 . get X ( ) - minutes Pnt 0 . get X ( ) ; double min Selection Width Minutes = minutes Per Pixel * slider Point Half Width * NUM ; double selection Width Pixels = selection Width Minutes / minutes Per Pixel ; double multiplier = selection Width Pixels / NUM ; selection Width Minutes += rot * minutes Per Pixel * multiplier ; if ( selection Width Minutes < min Selection Width Minutes ) { selection Width Minutes = min Selection Width Minutes ; } if ( selection Width Minutes > max Selection Width Minutes ) { selection Width Minutes = max Selection Width Minutes ; } update Timeline ( ) ; do Prepare ( ) ; }
@ Override public void add Relations ( Task task , Iterable < Object Id > project Ids , String field Name ) { List < Project > new Project List = new Linked List < > ( ) ; Iterable < Project > projects To Add = project Repository . find All ( project Ids , null ) ; projects To Add . for Each ( null ) ; try { if ( Property Utils . get Property ( task , field Name ) != null ) { Iterable < Project > projects = ( Iterable < Project > ) Property Utils . get Property ( task , field Name ) ; projects . for Each ( null ) ; } } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } try { Property Utils . set Property ( task , field Name , new Project List ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } task Repository . save ( task ) ; }
@ Override public void add Relations ( Task task , Iterable < Object Id > project Ids , String field Name ) { List < Project > new Project List = new Linked List < > ( ) ; Iterable < Project > projects To Add = project Repository . find All ( project Ids , null ) ; projects To Add . for Each ( null ) ; try { if ( Property Utils . get Property ( task , field Name ) != null ) { Iterable < Project > projects = ( Iterable < Project > ) Property Utils . get Property ( task , field Name ) ; projects . for Each ( null ) ; } } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } try { Property Utils . set Property ( task , field Name , new Project List ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } task Repository . save ( task ) ; }
@ Override public void add Relations ( Task task , Iterable < Object Id > project Ids , String field Name ) { List < Project > new Project List = new Linked List < > ( ) ; Iterable < Project > projects To Add = project Repository . find All ( project Ids , null ) ; projects To Add . for Each ( null ) ; try { if ( Property Utils . get Property ( task , field Name ) != null ) { Iterable < Project > projects = ( Iterable < Project > ) Property Utils . get Property ( task , field Name ) ; projects . for Each ( null ) ; } } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } try { Property Utils . set Property ( task , field Name , new Project List ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } task Repository . save ( task ) ; }
@ Override public void add Relations ( Task task , Iterable < Object Id > project Ids , String field Name ) { List < Project > new Project List = new Linked List < > ( ) ; Iterable < Project > projects To Add = project Repository . find All ( project Ids , null ) ; projects To Add . for Each ( null ) ; try { if ( Property Utils . get Property ( task , field Name ) != null ) { Iterable < Project > projects = ( Iterable < Project > ) Property Utils . get Property ( task , field Name ) ; projects . for Each ( null ) ; } } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } try { Property Utils . set Property ( task , field Name , new Project List ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } task Repository . save ( task ) ; }
@ Override public void add Relations ( Task task , Iterable < Object Id > project Ids , String field Name ) { List < Project > new Project List = new Linked List < > ( ) ; Iterable < Project > projects To Add = project Repository . find All ( project Ids , null ) ; projects To Add . for Each ( null ) ; try { if ( Property Utils . get Property ( task , field Name ) != null ) { Iterable < Project > projects = ( Iterable < Project > ) Property Utils . get Property ( task , field Name ) ; projects . for Each ( null ) ; } } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } try { Property Utils . set Property ( task , field Name , new Project List ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } task Repository . save ( task ) ; }
@ Override public void add Relations ( Task task , Iterable < Object Id > project Ids , String field Name ) { List < Project > new Project List = new Linked List < > ( ) ; Iterable < Project > projects To Add = project Repository . find All ( project Ids , null ) ; projects To Add . for Each ( null ) ; try { if ( Property Utils . get Property ( task , field Name ) != null ) { Iterable < Project > projects = ( Iterable < Project > ) Property Utils . get Property ( task , field Name ) ; projects . for Each ( null ) ; } } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } try { Property Utils . set Property ( task , field Name , new Project List ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } task Repository . save ( task ) ; }
@ Override public void add Relations ( Task task , Iterable < Object Id > project Ids , String field Name ) { List < Project > new Project List = new Linked List < > ( ) ; Iterable < Project > projects To Add = project Repository . find All ( project Ids , null ) ; projects To Add . for Each ( null ) ; try { if ( Property Utils . get Property ( task , field Name ) != null ) { Iterable < Project > projects = ( Iterable < Project > ) Property Utils . get Property ( task , field Name ) ; projects . for Each ( null ) ; } } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } try { Property Utils . set Property ( task , field Name , new Project List ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } task Repository . save ( task ) ; }
public synchronized byte [ ] to Byte Array ( ) { int remaining = count ; if ( remaining == NUM ) { return EMPTY BYTE ARRAY ; } byte newbuf [ ] = new byte [ remaining ] ; int pos = NUM ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; System . arraycopy ( buf , NUM , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == NUM ) { break ; } } return newbuf ; }
public double calculate Value ( double log ) { return Math . pow ( this . base , log ) ; }
@ Override public void write Entity Ref ( String name ) throws XML Stream Exception { throw new Unsupported Operation Exception ( STRING ) ; }
@ Override public void write Entity Ref ( String name ) throws XML Stream Exception { throw new Unsupported Operation Exception ( STRING ) ; }
@ Override public void write Entity Ref ( String name ) throws XML Stream Exception { throw new Unsupported Operation Exception ( STRING ) ; }
@ Override public void write Entity Ref ( String name ) throws XML Stream Exception { throw new Unsupported Operation Exception ( STRING ) ; }
private Default Mutable Tree Node iparent ( int AD Client ID , int M Product ID , int PP Product BOM ID ) { Default Mutable Tree Node parent = new Default Mutable Tree Node ( Integer . to String ( M Product ID ) + STRING + Integer . to String ( PP Product BOM ID ) ) ; String sql = STRING + STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , m trx Name ) ; DB . set Parameters ( pstmt , new Object [ ] { BOOL , AD Client ID , M Product ID } ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { if ( rs . get Row ( ) > NUM ) { tableproduct . clear ( ) ; tableproduct . put ( M Product ID , PP Product BOM ID ) ; } Default Mutable Tree Node bom = icomponent ( AD Client ID , rs . get Int ( NUM ) , M Product ID , parent ) ; if ( bom != null ) { parent . add ( bom ) ; } } } catch ( SQL Exception e ) { throw new DB Exception ( e , sql ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return parent ; }
public void flush ( ) { if ( ps != null ) { if ( line Buffer . length ( ) != NUM ) { flush Line ( BOOL ) ; } ps . flush ( ) ; } }
@ Suppress Lint ( STRING ) public static String save Media Into Downloads ( Context context , File src File , String filename , String mime Type ) { String full File Path = save File Into ( src File , Environment . DIRECTORY DOWNLOADS , filename ) ; if ( android . os . Build . VERSION . SDK INT >= Build . VERSION CODES . HONEYCOMB ) { if ( null != full File Path ) { Download Manager download Manager = ( Download Manager ) context . get System Service ( Context . DOWNLOAD SERVICE ) ; try { File file = new File ( full File Path ) ; download Manager . add Completed Download ( file . get Name ( ) , file . get Name ( ) , BOOL , mime Type , file . get Absolute Path ( ) , file . length ( ) , BOOL ) ; } catch ( Exception e ) { Log . e ( LOG TAG , STRING + e . get Message ( ) ) ; } } } return full File Path ; }
public void calc Welzl ( Float Buffer points ) { if ( center == null ) { center = new Vector 3 f ( ) ; } Float Buffer buf = Buffer Utils . create Float Buffer ( points . limit ( ) ) ; points . rewind ( ) ; buf . put ( points ) ; buf . flip ( ) ; recurse Mini ( buf , buf . limit ( ) / NUM , NUM , NUM ) ; }
public void calc Welzl ( Float Buffer points ) { if ( center == null ) { center = new Vector 3 f ( ) ; } Float Buffer buf = Buffer Utils . create Float Buffer ( points . limit ( ) ) ; points . rewind ( ) ; buf . put ( points ) ; buf . flip ( ) ; recurse Mini ( buf , buf . limit ( ) / NUM , NUM , NUM ) ; }
public void calc Welzl ( Float Buffer points ) { if ( center == null ) { center = new Vector 3 f ( ) ; } Float Buffer buf = Buffer Utils . create Float Buffer ( points . limit ( ) ) ; points . rewind ( ) ; buf . put ( points ) ; buf . flip ( ) ; recurse Mini ( buf , buf . limit ( ) / NUM , NUM , NUM ) ; }
public void calc Welzl ( Float Buffer points ) { if ( center == null ) { center = new Vector 3 f ( ) ; } Float Buffer buf = Buffer Utils . create Float Buffer ( points . limit ( ) ) ; points . rewind ( ) ; buf . put ( points ) ; buf . flip ( ) ; recurse Mini ( buf , buf . limit ( ) / NUM , NUM , NUM ) ; }
static Type [ ] map Key And Value Types ( Type context , Class < ? > context Raw Type ) { if ( context == Properties . class ) return new Type [ ] { String . class , String . class } ; Type map Type = get Supertype ( context , context Raw Type , Map . class ) ; if ( map Type instanceof Parameterized Type ) { Parameterized Type map Parameterized Type = ( Parameterized Type ) map Type ; return map Parameterized Type . get Actual Type Arguments ( ) ; } return new Type [ ] { Object . class , Object . class } ; }
static Type [ ] map Key And Value Types ( Type context , Class < ? > context Raw Type ) { if ( context == Properties . class ) return new Type [ ] { String . class , String . class } ; Type map Type = get Supertype ( context , context Raw Type , Map . class ) ; if ( map Type instanceof Parameterized Type ) { Parameterized Type map Parameterized Type = ( Parameterized Type ) map Type ; return map Parameterized Type . get Actual Type Arguments ( ) ; } return new Type [ ] { Object . class , Object . class } ; }
public void add Addendum ( String word , String part Of Speech , String [ ] phones ) { String pos = fix Part Of Speech ( part Of Speech ) ; if ( ! parts Of Speech . contains ( pos ) ) { parts Of Speech . add ( pos ) ; } addenda . put ( word + pos , phones ) ; }
public boolean equals ( Object object ) { if ( ! ( object instanceof Object Instance ) ) { return BOOL ; } Object Instance val = ( Object Instance ) object ; if ( ! name . equals ( val . get Object Name ( ) ) ) return BOOL ; if ( class Name == null ) return ( val . get Class Name ( ) == null ) ; return class Name . equals ( val . get Class Name ( ) ) ; }
public J Panel create Legend Panel ( ) { J Panel legend Panel = new J Panel ( ) ; legend Panel . set Layout ( new Grid Layout ( NUM , NUM ) ) ; legend Panel . add ( get Legend Panel ( ) ) ; J Panel symbol Tree Panel = get Symbol Tree ( ) ; legend Panel . add ( symbol Tree Panel ) ; return legend Panel ; }
@ Pre Persist public void pre Persist ( ) { lock Time = System . current Time Millis ( ) ; }
@ Pre Persist public void pre Persist ( ) { lock Time = System . current Time Millis ( ) ; }
protected void assert Sender Config ( String config ) throws Exception { context = new Class Path Xml Application Context ( config ) ; consumer = ( Spring Consumer ) context . get Bean ( STRING ) ; assert True ( STRING , consumer != null ) ; consumer . start ( ) ; producer = ( Spring Producer ) context . get Bean ( STRING ) ; assert True ( STRING , producer != null ) ; consumer . flush Messages ( ) ; producer . start ( ) ; consumer . wait For Messages To Arrive ( producer . get Message Count ( ) ) ; List < Message > messages = consumer . flush Messages ( ) ; LOG . info ( STRING ) ; for ( Message message : messages ) { LOG . info ( STRING + message ) ; } assert Equals ( STRING , producer . get Message Count ( ) , messages . size ( ) ) ; }
protected void assert Sender Config ( String config ) throws Exception { context = new Class Path Xml Application Context ( config ) ; consumer = ( Spring Consumer ) context . get Bean ( STRING ) ; assert True ( STRING , consumer != null ) ; consumer . start ( ) ; producer = ( Spring Producer ) context . get Bean ( STRING ) ; assert True ( STRING , producer != null ) ; consumer . flush Messages ( ) ; producer . start ( ) ; consumer . wait For Messages To Arrive ( producer . get Message Count ( ) ) ; List < Message > messages = consumer . flush Messages ( ) ; LOG . info ( STRING ) ; for ( Message message : messages ) { LOG . info ( STRING + message ) ; } assert Equals ( STRING , producer . get Message Count ( ) , messages . size ( ) ) ; }
public boolean should Ignore For Stats ( Soot Class clz ) { return STATS IGNORE SOOTCLASSES . contains ( clz ) ; }
public void delete Observers ( ) { observers . clear ( ) ; }
public void delete Observers ( ) { observers . clear ( ) ; }
public void delete Observers ( ) { observers . clear ( ) ; }
public void delete Observers ( ) { observers . clear ( ) ; }
public void delete Observers ( ) { observers . clear ( ) ; }
public static Map append Element To Map ( String key , Set values , Map to Map ) { if ( ( key != null ) && ( values != null ) && ( ! values . is Empty ( ) ) && ( to Map != null ) ) { Set previous Values = ( Set ) to Map . get ( key ) ; if ( ( previous Values != null ) && ( ! previous Values . is Empty ( ) ) ) { previous Values . add All ( values ) ; } else { to Map . put ( key , values ) ; } } return to Map ; }
public static byte [ ] hex To Array ( final String data ) throws Conversion Exception { try { return Hex . decode Hex ( data . to Char Array ( ) ) ; } catch ( Decoder Exception e ) { throw new Conversion Exception ( STRING , e ) ; } }
public static byte [ ] hex To Array ( final String data ) throws Conversion Exception { try { return Hex . decode Hex ( data . to Char Array ( ) ) ; } catch ( Decoder Exception e ) { throw new Conversion Exception ( STRING , e ) ; } }
private void add VNX Failed Subscription ( String storage System URI ) { if ( String Utils . is Not Empty ( storage System URI ) ) { FAILED VNXFILE SUBSCRIPTION . add ( storage System URI ) ; } }
private void add VNX Failed Subscription ( String storage System URI ) { if ( String Utils . is Not Empty ( storage System URI ) ) { FAILED VNXFILE SUBSCRIPTION . add ( storage System URI ) ; } }
private void add VNX Failed Subscription ( String storage System URI ) { if ( String Utils . is Not Empty ( storage System URI ) ) { FAILED VNXFILE SUBSCRIPTION . add ( storage System URI ) ; } }
static String escape String For ASCII ( String s ) { String Builder out = new String Builder ( ) ; char [ ] c Array = s . to Char Array ( ) ; for ( int i = NUM ; i < c Array . length ; i ++ ) { char c = c Array [ i ] ; if ( c > NUM ) { out . append ( STRING ) ; String hex = Integer . to Hex String ( c ) ; while ( hex . length ( ) < NUM ) hex = STRING + hex ; out . append ( hex ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else { out . append ( c ) ; } } return out . to String ( ) ; }
static String escape String For ASCII ( String s ) { String Builder out = new String Builder ( ) ; char [ ] c Array = s . to Char Array ( ) ; for ( int i = NUM ; i < c Array . length ; i ++ ) { char c = c Array [ i ] ; if ( c > NUM ) { out . append ( STRING ) ; String hex = Integer . to Hex String ( c ) ; while ( hex . length ( ) < NUM ) hex = STRING + hex ; out . append ( hex ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else { out . append ( c ) ; } } return out . to String ( ) ; }
public static Map < Integer , String > generate Map Of Value Name Integer ( Class < ? > clazz ) { Map < Integer , String > values Name = new Hash Map < > ( ) ; try { for ( Field field : clazz . get Fields ( ) ) { values Name . put ( ( Integer ) field . get ( int . class ) , field . get Name ( ) ) ; } } catch ( Illegal Access Exception e ) { e . print Stack Trace ( ) ; } return values Name ; }
public static Map < Integer , String > generate Map Of Value Name Integer ( Class < ? > clazz ) { Map < Integer , String > values Name = new Hash Map < > ( ) ; try { for ( Field field : clazz . get Fields ( ) ) { values Name . put ( ( Integer ) field . get ( int . class ) , field . get Name ( ) ) ; } } catch ( Illegal Access Exception e ) { e . print Stack Trace ( ) ; } return values Name ; }
public static Map < Integer , String > generate Map Of Value Name Integer ( Class < ? > clazz ) { Map < Integer , String > values Name = new Hash Map < > ( ) ; try { for ( Field field : clazz . get Fields ( ) ) { values Name . put ( ( Integer ) field . get ( int . class ) , field . get Name ( ) ) ; } } catch ( Illegal Access Exception e ) { e . print Stack Trace ( ) ; } return values Name ; }
private JMX Connector connect ( String host , int port ) { try { if ( ! is Node Available ( host ) ) { log . info ( STRING , host ) ; throw new Illegal State Exception ( STRING ) ; } log . debug ( STRING , host , port ) ; String connector Address = String . format ( service Url , host , port ) ; JMX Service URL jmx Url = new JMX Service URL ( connector Address ) ; return JMX Connector Factory . connect ( jmx Url ) ; } catch ( Malformed URL Exception e ) { log . error ( String . format ( STRING , host , port ) , e ) ; throw new Illegal State Exception ( STRING ) ; } catch ( IO Exception e ) { log . error ( String . format ( STRING , host , port ) , e ) ; throw new Illegal State Exception ( STRING + host ) ; } }
private static String strip Whitespace ( final String mosname ) { final String Buffer sb = new String Buffer ( ) ; final int size = mosname . length ( ) ; for ( int i = NUM ; i < size ; i ++ ) { final char ch = mosname . char At ( i ) ; if ( ! Character . is Whitespace ( ch ) ) { sb . append ( ch ) ; } } return sb . to String ( ) ; }
private static String strip Whitespace ( final String mosname ) { final String Buffer sb = new String Buffer ( ) ; final int size = mosname . length ( ) ; for ( int i = NUM ; i < size ; i ++ ) { final char ch = mosname . char At ( i ) ; if ( ! Character . is Whitespace ( ch ) ) { sb . append ( ch ) ; } } return sb . to String ( ) ; }
public void delete Sub Group Containers ( Set group Containers ) throws AM Exception , SSO Exception { Iterator iter = group Containers . iterator ( ) ; while ( iter . has Next ( ) ) { String group Container DN = ( String ) iter . next ( ) ; AM Group Container group Container = new AM Group Container Impl ( token , group Container DN ) ; group Container . delete ( ) ; } }
public void delete Sub Group Containers ( Set group Containers ) throws AM Exception , SSO Exception { Iterator iter = group Containers . iterator ( ) ; while ( iter . has Next ( ) ) { String group Container DN = ( String ) iter . next ( ) ; AM Group Container group Container = new AM Group Container Impl ( token , group Container DN ) ; group Container . delete ( ) ; } }
private UI Component new Instance ( Tree Node n ) throws Faces Exception { if ( LOGGER . is Loggable ( Level . FINEST ) ) { LOGGER . log ( Level . FINEST , STRING , n . component Type ) ; } try { Class < ? > t = ( ( class Map != null ) ? class Map . get ( n . component Type ) : null ) ; if ( t == null ) { t = Util . load Class ( n . component Type , n ) ; if ( t != null && class Map != null ) { class Map . put ( n . component Type , t ) ; } else { if ( ! is Development Mode ) { throw new Null Pointer Exception ( ) ; } } } assert ( t != null ) ; UI Component c = ( UI Component ) t . new Instance ( ) ; c . set Id ( n . id ) ; return c ; } catch ( Class Not Found Exception | Null Pointer Exception | Instantiation Exception | Illegal Access Exception e ) { throw new Faces Exception ( e ) ; } }
private static int determine Consecutive Text Count ( Char Sequence msg , int startpos ) { int len = msg . length ( ) ; int idx = startpos ; while ( idx < len ) { char ch = msg . char At ( idx ) ; int numeric Count = NUM ; while ( numeric Count < NUM && is Digit ( ch ) && idx < len ) { numeric Count ++ ; idx ++ ; if ( idx < len ) { ch = msg . char At ( idx ) ; } } if ( numeric Count >= NUM ) { return idx - startpos - numeric Count ; } if ( numeric Count > NUM ) { continue ; } ch = msg . char At ( idx ) ; if ( ! is Text ( ch ) ) { break ; } idx ++ ; } return idx - startpos ; }
private static void show Preference Window ( final GUI Factory current GUI ) { properties = current GUI . get Properties ( ) ; init ( current GUI ) ; load Settings ( ) ; border Pane . set Left ( setup Side Nav Bar ( ) ) ; border Pane . set Center ( get General Content ( ) ) ; border Pane . set Bottom ( setup Bottom Bar ( current GUI ) ) ; preference Dialog = new FX Dialog ( null , Modality . APPLICATION MODAL , border Pane , NUM , NUM ) ; preference Dialog . set Title ( Messages . get Message ( STRING ) ) ; preference Dialog . show ( ) ; }
private static byte [ ] generate Seed ( ) { try { Byte Array Output Stream seed Buffer = new Byte Array Output Stream ( ) ; Data Output Stream seed Buffer Out = new Data Output Stream ( seed Buffer ) ; seed Buffer Out . write Long ( System . current Time Millis ( ) ) ; seed Buffer Out . write Long ( System . nano Time ( ) ) ; seed Buffer Out . write ( BUILD FINGERPRINT AND DEVICE SERIAL ) ; seed Buffer Out . close ( ) ; return seed Buffer . to Byte Array ( ) ; } catch ( IO Exception e ) { throw new Security Exception ( STRING , e ) ; } }
public < T > T param 2 PO ( Class < T > type , Object param , T po , User current User ) throws Exception { Long created By ; Long last Modified By ; Field id Field = type . get Declared Field ( Commons Constant . ID ) ; id Field . set Accessible ( BOOL ) ; Field created By Field = type . get Declared Field ( Commons Constant . CREATED BY ) ; created By Field . set Accessible ( BOOL ) ; Field last Modified By Field = type . get Declared Field ( Commons Constant . LAST MODIFIED BY ) ; last Modified By Field . set Accessible ( BOOL ) ; Field last Modified Date Field = type . get Declared Field ( Commons Constant . LAST MODIFIED DATE ) ; last Modified Date Field . set Accessible ( BOOL ) ; Date now = new Date ( ) ; if ( id Field . get ( po ) == null ) { created By = current User . get Id ( ) ; last Modified By = created By ; } else { created By = ( Long ) created By Field . get ( po ) ; last Modified By = current User . get Id ( ) ; } Bean Utils . copy Properties Ignore Null ( param , po ) ; created By Field . set ( po , created By ) ; last Modified By Field . set ( po , last Modified By ) ; last Modified Date Field . set ( po , now ) ; return po ; }
public < T > T param 2 PO ( Class < T > type , Object param , T po , User current User ) throws Exception { Long created By ; Long last Modified By ; Field id Field = type . get Declared Field ( Commons Constant . ID ) ; id Field . set Accessible ( BOOL ) ; Field created By Field = type . get Declared Field ( Commons Constant . CREATED BY ) ; created By Field . set Accessible ( BOOL ) ; Field last Modified By Field = type . get Declared Field ( Commons Constant . LAST MODIFIED BY ) ; last Modified By Field . set Accessible ( BOOL ) ; Field last Modified Date Field = type . get Declared Field ( Commons Constant . LAST MODIFIED DATE ) ; last Modified Date Field . set Accessible ( BOOL ) ; Date now = new Date ( ) ; if ( id Field . get ( po ) == null ) { created By = current User . get Id ( ) ; last Modified By = created By ; } else { created By = ( Long ) created By Field . get ( po ) ; last Modified By = current User . get Id ( ) ; } Bean Utils . copy Properties Ignore Null ( param , po ) ; created By Field . set ( po , created By ) ; last Modified By Field . set ( po , last Modified By ) ; last Modified Date Field . set ( po , now ) ; return po ; }
default long now ( Time Unit unit ) { return unit . convert ( System . current Time Millis ( ) , Time Unit . MILLISECONDS ) ; }
private void schedule Timeout Requests Timer ( ) { Pending Request next Request = get Next Timeouting Pending Request ( ) ; if ( next Request == null ) { cancel Timeout Pending Request Task ( ) ; } else { Timer Task task = timeout Pending Requests Task . get ( ) ; if ( task == null || task . scheduled Execution Time ( ) > next Request . timeout Time ) { cancel Timeout Pending Request Task ( ) ; task = Timer Util . schedule ( timer , timeout Run , executor , next Request . timeout Time ) ; if ( ! timeout Pending Requests Task . compare And Set ( null , task ) ) task . cancel ( ) ; } } }
private void schedule Timeout Requests Timer ( ) { Pending Request next Request = get Next Timeouting Pending Request ( ) ; if ( next Request == null ) { cancel Timeout Pending Request Task ( ) ; } else { Timer Task task = timeout Pending Requests Task . get ( ) ; if ( task == null || task . scheduled Execution Time ( ) > next Request . timeout Time ) { cancel Timeout Pending Request Task ( ) ; task = Timer Util . schedule ( timer , timeout Run , executor , next Request . timeout Time ) ; if ( ! timeout Pending Requests Task . compare And Set ( null , task ) ) task . cancel ( ) ; } } }
private final double pre Distance VM ( Number Vector v , Spatial Comparable mbr , final int start , final int end ) { double agg = NUM ; for ( int d = start ; d < end ; d ++ ) { final double value = v . double Value ( d ) , min = mbr . get Min ( d ) ; double delta = min - value ; if ( delta < NUM ) { delta = value - mbr . get Max ( d ) ; } if ( delta > NUM ) { agg += Math . pow ( delta , p ) ; } } return agg ; }
private final double pre Distance VM ( Number Vector v , Spatial Comparable mbr , final int start , final int end ) { double agg = NUM ; for ( int d = start ; d < end ; d ++ ) { final double value = v . double Value ( d ) , min = mbr . get Min ( d ) ; double delta = min - value ; if ( delta < NUM ) { delta = value - mbr . get Max ( d ) ; } if ( delta > NUM ) { agg += Math . pow ( delta , p ) ; } } return agg ; }
public void generate Partition ( Instances data ) throws Exception { if ( m Classifier instanceof Partition Generator ) build Classifier ( data ) ; else throw new Exception ( STRING + get Classifier Spec ( ) + STRING ) ; }
public void generate Partition ( Instances data ) throws Exception { if ( m Classifier instanceof Partition Generator ) build Classifier ( data ) ; else throw new Exception ( STRING + get Classifier Spec ( ) + STRING ) ; }
public void generate Partition ( Instances data ) throws Exception { if ( m Classifier instanceof Partition Generator ) build Classifier ( data ) ; else throw new Exception ( STRING + get Classifier Spec ( ) + STRING ) ; }
public static Rotate Bitmap Result rotate Bitmap By Exif ( Bitmap bitmap , Context context , Uri uri ) { try { File file = get File From Uri ( context , uri ) ; if ( file . exists ( ) ) { Exif Interface ei = new Exif Interface ( file . get Absolute Path ( ) ) ; return rotate Bitmap By Exif ( bitmap , ei ) ; } } catch ( Exception ignored ) { } return new Rotate Bitmap Result ( bitmap , NUM ) ; }
public static Rotate Bitmap Result rotate Bitmap By Exif ( Bitmap bitmap , Context context , Uri uri ) { try { File file = get File From Uri ( context , uri ) ; if ( file . exists ( ) ) { Exif Interface ei = new Exif Interface ( file . get Absolute Path ( ) ) ; return rotate Bitmap By Exif ( bitmap , ei ) ; } } catch ( Exception ignored ) { } return new Rotate Bitmap Result ( bitmap , NUM ) ; }
public void select Tab ( String group Key ) { if ( group Keys To Tab Index Map . contains Key ( group Key ) ) { set Selected Index ( group Keys To Tab Index Map . get ( group Key ) ) ; } }
static boolean char Equals Ignore Case ( char c1 , char c2 ) { return c1 == c2 || Character . to Upper Case ( c1 ) == Character . to Upper Case ( c2 ) || Character . to Lower Case ( c1 ) == Character . to Lower Case ( c2 ) ; }
static boolean char Equals Ignore Case ( char c1 , char c2 ) { return c1 == c2 || Character . to Upper Case ( c1 ) == Character . to Upper Case ( c2 ) || Character . to Lower Case ( c1 ) == Character . to Lower Case ( c2 ) ; }
public void add Details Loaded Listener ( @ Not Null Runnable runnable ) { my Loading Finished Listeners . add ( runnable ) ; }
public void add Details Loaded Listener ( @ Not Null Runnable runnable ) { my Loading Finished Listeners . add ( runnable ) ; }
public static void write All ( Output Stream stream , Object [ ] o ) throws Exception { Object Output Stream oos ; int i ; if ( ! ( stream instanceof Buffered Output Stream ) ) { stream = new Buffered Output Stream ( stream ) ; } oos = new Object Output Stream ( stream ) ; for ( i = NUM ; i < o . length ; i ++ ) { oos . write Object ( o [ i ] ) ; } oos . flush ( ) ; oos . close ( ) ; }
@ Override public Packing Plan pack ( ) { Map < Integer , List < Instance Id > > ffd Allocation = get FFD Allocation ( ) ; Map < String , Long > ram Map = Topology Utils . get Component Ram Map Config ( topology ) ; Set < Packing Plan . Container Plan > container Plans = Packing Utils . build Container Plans ( ffd Allocation , ram Map , this . default Instance Resources , this . padding Percentage ) ; return new Packing Plan ( topology . get Id ( ) , container Plans ) ; }
public void add Separator ( ) { m Table Contents . add ( SEPARATOR ) ; }
public void verify Annotation ( String method Name , String annotation Name ) throws Exception { Class clazz = Class . for Name ( class Name ) ; Method method = clazz . get Declared Method ( method Name ) ; Class annotation Clazz = Class . for Name ( annotation Name ) ; java . lang . annotation . Annotation annotation = method . get Annotation ( annotation Clazz ) ; Assert . assert Not Null ( annotation ) ; }
public void verify Annotation ( String method Name , String annotation Name ) throws Exception { Class clazz = Class . for Name ( class Name ) ; Method method = clazz . get Declared Method ( method Name ) ; Class annotation Clazz = Class . for Name ( annotation Name ) ; java . lang . annotation . Annotation annotation = method . get Annotation ( annotation Clazz ) ; Assert . assert Not Null ( annotation ) ; }
public void write Hex ( Writer w ) throws IO Exception , Memory File Addressing Format Exception { write Hex ( w , NUM ) ; }
public void write Hex ( Writer w ) throws IO Exception , Memory File Addressing Format Exception { write Hex ( w , NUM ) ; }
public void write Hex ( Writer w ) throws IO Exception , Memory File Addressing Format Exception { write Hex ( w , NUM ) ; }
public void write Header ( ) throws IO Exception { FLV Header flv Header = new FLV Header ( ) ; flv Header . set Flag Audio ( BOOL ) ; flv Header . set Flag Video ( BOOL ) ; Byte Buffer header = Byte Buffer . allocate ( HEADER LENGTH + NUM ) ; flv Header . write ( header ) ; file . set Length ( HEADER LENGTH + NUM ) ; if ( header . has Array ( ) ) { log . debug ( STRING ) ; file . write ( header . array ( ) ) ; } else { log . debug ( STRING ) ; byte [ ] tmp = new byte [ HEADER LENGTH + NUM ] ; header . get ( tmp ) ; file . write ( tmp ) ; } bytes Written = file . length ( ) ; header . clear ( ) ; }
public void add Additional Symbol Class ( FXG Symbol Class symbol Class ) { if ( additional Symbol Classes == null ) additional Symbol Classes = new Array List < FXG Symbol Class > ( ) ; additional Symbol Classes . add ( symbol Class ) ; }
public void add Additional Symbol Class ( FXG Symbol Class symbol Class ) { if ( additional Symbol Classes == null ) additional Symbol Classes = new Array List < FXG Symbol Class > ( ) ; additional Symbol Classes . add ( symbol Class ) ; }
public void add Additional Symbol Class ( FXG Symbol Class symbol Class ) { if ( additional Symbol Classes == null ) additional Symbol Classes = new Array List < FXG Symbol Class > ( ) ; additional Symbol Classes . add ( symbol Class ) ; }
public void add Vetoable Change Listener ( String property Name , Vetoable Change Listener in vcl ) { bean Context Child Support . add Vetoable Change Listener ( property Name , in vcl ) ; }
public void add Vetoable Change Listener ( String property Name , Vetoable Change Listener in vcl ) { bean Context Child Support . add Vetoable Change Listener ( property Name , in vcl ) ; }
public void add Vetoable Change Listener ( String property Name , Vetoable Change Listener in vcl ) { bean Context Child Support . add Vetoable Change Listener ( property Name , in vcl ) ; }
public void add Vetoable Change Listener ( String property Name , Vetoable Change Listener in vcl ) { bean Context Child Support . add Vetoable Change Listener ( property Name , in vcl ) ; }
public void add Vetoable Change Listener ( String property Name , Vetoable Change Listener in vcl ) { bean Context Child Support . add Vetoable Change Listener ( property Name , in vcl ) ; }
public void add Vetoable Change Listener ( String property Name , Vetoable Change Listener in vcl ) { bean Context Child Support . add Vetoable Change Listener ( property Name , in vcl ) ; }
public void add Vetoable Change Listener ( String property Name , Vetoable Change Listener in vcl ) { bean Context Child Support . add Vetoable Change Listener ( property Name , in vcl ) ; }
public void add Vetoable Change Listener ( String property Name , Vetoable Change Listener in vcl ) { bean Context Child Support . add Vetoable Change Listener ( property Name , in vcl ) ; }
protected int map Drag Operation From Modifiers ( Mouse Event e ) { int mods = e . get Modifiers Ex ( ) ; int btns = mods & Button Mask ; if ( ! ( btns == Input Event . BUTTON 1 DOWN MASK || btns == Input Event . BUTTON 2 DOWN MASK || btns == Input Event . BUTTON 3 DOWN MASK ) ) { return Dn D Constants . ACTION NONE ; } return Sun Drag Source Context Peer . convert Modifiers To Drop Action ( mods , get Source Actions ( ) ) ; }
public void remove Group ( String group ) throws Object Lacks Exception { assert Contains ( group ) ; groups . remove ( group ) ; }
private void add Reference ( final int source Position , final int reference Position ) { if ( src And Ref Positions == null ) { src And Ref Positions = new int [ NUM ] ; } if ( reference Count >= src And Ref Positions . length ) { int [ ] a = new int [ src And Ref Positions . length + NUM ] ; System . arraycopy ( src And Ref Positions , NUM , a , NUM , src And Ref Positions . length ) ; src And Ref Positions = a ; } src And Ref Positions [ reference Count ++ ] = source Position ; src And Ref Positions [ reference Count ++ ] = reference Position ; }
private void add Reference ( final int source Position , final int reference Position ) { if ( src And Ref Positions == null ) { src And Ref Positions = new int [ NUM ] ; } if ( reference Count >= src And Ref Positions . length ) { int [ ] a = new int [ src And Ref Positions . length + NUM ] ; System . arraycopy ( src And Ref Positions , NUM , a , NUM , src And Ref Positions . length ) ; src And Ref Positions = a ; } src And Ref Positions [ reference Count ++ ] = source Position ; src And Ref Positions [ reference Count ++ ] = reference Position ; }
private void add Reference ( final int source Position , final int reference Position ) { if ( src And Ref Positions == null ) { src And Ref Positions = new int [ NUM ] ; } if ( reference Count >= src And Ref Positions . length ) { int [ ] a = new int [ src And Ref Positions . length + NUM ] ; System . arraycopy ( src And Ref Positions , NUM , a , NUM , src And Ref Positions . length ) ; src And Ref Positions = a ; } src And Ref Positions [ reference Count ++ ] = source Position ; src And Ref Positions [ reference Count ++ ] = reference Position ; }
private void add Reference ( final int source Position , final int reference Position ) { if ( src And Ref Positions == null ) { src And Ref Positions = new int [ NUM ] ; } if ( reference Count >= src And Ref Positions . length ) { int [ ] a = new int [ src And Ref Positions . length + NUM ] ; System . arraycopy ( src And Ref Positions , NUM , a , NUM , src And Ref Positions . length ) ; src And Ref Positions = a ; } src And Ref Positions [ reference Count ++ ] = source Position ; src And Ref Positions [ reference Count ++ ] = reference Position ; }
public void processed ( String source Id , String target Id , boolean link Existed , String link Id , boolean link Created , Situation situation , Recon Action action ) { String id ; if ( phase == Phase . SOURCE ) { id = source Id ; } else { id = target Id ; } parent Stat . processed ( source Id , target Id , link Existed , link Id , link Created , situation , action ) ; if ( id != null ) { processed Entries . increment And Get ( ) ; if ( situation != null ) { List < String > situation Ids = ids . get ( situation ) ; if ( situation Ids != null ) { situation Ids . add ( id ) ; } } } }
public void processed ( String source Id , String target Id , boolean link Existed , String link Id , boolean link Created , Situation situation , Recon Action action ) { String id ; if ( phase == Phase . SOURCE ) { id = source Id ; } else { id = target Id ; } parent Stat . processed ( source Id , target Id , link Existed , link Id , link Created , situation , action ) ; if ( id != null ) { processed Entries . increment And Get ( ) ; if ( situation != null ) { List < String > situation Ids = ids . get ( situation ) ; if ( situation Ids != null ) { situation Ids . add ( id ) ; } } } }
private boolean open For Writing ( ) { File root = new File ( Properties . CTG DIR ) ; if ( root . exists ( ) ) { if ( root . is Directory ( ) ) { if ( ! root . can Write ( ) ) { logger . error ( STRING + root . get Absolute Path ( ) ) ; return BOOL ; } } else { boolean deleted = root . delete ( ) ; if ( ! deleted ) { logger . error ( STRING + root + STRING ) ; return BOOL ; } else { if ( ! root . mkdirs ( ) ) { logger . error ( STRING + root . get Absolute Path ( ) ) ; return BOOL ; } } } } else { if ( ! root . mkdirs ( ) ) { logger . error ( STRING + root . get Absolute Path ( ) ) ; return BOOL ; } } File tests Folder = get Best Test Folder ( ) ; if ( ! tests Folder . exists ( ) ) { if ( ! tests Folder . mkdirs ( ) ) { logger . error ( STRING + tests Folder . get Absolute Path ( ) ) ; return BOOL ; } } File seed Folder = get Seed In Folder ( ) ; if ( ! seed Folder . exists ( ) ) { if ( ! seed Folder . mkdirs ( ) ) { logger . error ( STRING + seed Folder . get Absolute Path ( ) ) ; } } return BOOL ; }
public static void cleanup Cache ( ) { for ( Soft Reference < Replaceable Bitmap Drawable > reference : s Image Cache . values ( ) ) { final Replaceable Bitmap Drawable drawable = reference . get ( ) ; if ( drawable != null ) drawable . set Callback ( null ) ; } }
public static void cleanup Cache ( ) { for ( Soft Reference < Replaceable Bitmap Drawable > reference : s Image Cache . values ( ) ) { final Replaceable Bitmap Drawable drawable = reference . get ( ) ; if ( drawable != null ) drawable . set Callback ( null ) ; } }
private void handle Hovering ( int x , int y ) { handle Cell Hover ( x , y ) ; if ( column Headers Visible ) { handle Hover On Column Header ( x , y ) ; } }
private void handle Hovering ( int x , int y ) { handle Cell Hover ( x , y ) ; if ( column Headers Visible ) { handle Hover On Column Header ( x , y ) ; } }
private void handle Hovering ( int x , int y ) { handle Cell Hover ( x , y ) ; if ( column Headers Visible ) { handle Hover On Column Header ( x , y ) ; } }
private void handle Hovering ( int x , int y ) { handle Cell Hover ( x , y ) ; if ( column Headers Visible ) { handle Hover On Column Header ( x , y ) ; } }
private static byte [ ] bitmap To Byte ( Bitmap b ) { if ( b == null ) { return null ; } Byte Array Output Stream o = new Byte Array Output Stream ( ) ; b . compress ( Bitmap . Compress Format . PNG , NUM , o ) ; return o . to Byte Array ( ) ; }
private static byte [ ] bitmap To Byte ( Bitmap b ) { if ( b == null ) { return null ; } Byte Array Output Stream o = new Byte Array Output Stream ( ) ; b . compress ( Bitmap . Compress Format . PNG , NUM , o ) ; return o . to Byte Array ( ) ; }
public static String strip Version From Rest Name ( String rest Name ) { Preconditions . check Not Null ( rest Name ) ; String version = extract Default Major Version From Rest Name ( rest Name ) ; String [ ] segs = rest Name . split ( STRING ) ; if ( segs . length > NUM ) { version = version + STRING ; } return rest Name . starts With ( version ) ? rest Name . substring ( version . length ( ) ) : rest Name ; }
public static String strip Version From Rest Name ( String rest Name ) { Preconditions . check Not Null ( rest Name ) ; String version = extract Default Major Version From Rest Name ( rest Name ) ; String [ ] segs = rest Name . split ( STRING ) ; if ( segs . length > NUM ) { version = version + STRING ; } return rest Name . starts With ( version ) ? rest Name . substring ( version . length ( ) ) : rest Name ; }
public static String strip Version From Rest Name ( String rest Name ) { Preconditions . check Not Null ( rest Name ) ; String version = extract Default Major Version From Rest Name ( rest Name ) ; String [ ] segs = rest Name . split ( STRING ) ; if ( segs . length > NUM ) { version = version + STRING ; } return rest Name . starts With ( version ) ? rest Name . substring ( version . length ( ) ) : rest Name ; }
public static byte [ ] to Unsigned Byte Array ( Big Integer bi ) { if ( bi == null ) { return null ; } byte [ ] bb = bi . to Byte Array ( ) ; if ( bb [ NUM ] == NUM ) { byte [ ] no Zero = new byte [ bb . length - NUM ] ; System . arraycopy ( bb , NUM , no Zero , NUM , no Zero . length ) ; return no Zero ; } else { return bb ; } }
public static byte [ ] to Unsigned Byte Array ( Big Integer bi ) { if ( bi == null ) { return null ; } byte [ ] bb = bi . to Byte Array ( ) ; if ( bb [ NUM ] == NUM ) { byte [ ] no Zero = new byte [ bb . length - NUM ] ; System . arraycopy ( bb , NUM , no Zero , NUM , no Zero . length ) ; return no Zero ; } else { return bb ; } }
public static byte [ ] to Unsigned Byte Array ( Big Integer bi ) { if ( bi == null ) { return null ; } byte [ ] bb = bi . to Byte Array ( ) ; if ( bb [ NUM ] == NUM ) { byte [ ] no Zero = new byte [ bb . length - NUM ] ; System . arraycopy ( bb , NUM , no Zero , NUM , no Zero . length ) ; return no Zero ; } else { return bb ; } }
public static byte [ ] to Unsigned Byte Array ( Big Integer bi ) { if ( bi == null ) { return null ; } byte [ ] bb = bi . to Byte Array ( ) ; if ( bb [ NUM ] == NUM ) { byte [ ] no Zero = new byte [ bb . length - NUM ] ; System . arraycopy ( bb , NUM , no Zero , NUM , no Zero . length ) ; return no Zero ; } else { return bb ; } }
public static byte [ ] to Unsigned Byte Array ( Big Integer bi ) { if ( bi == null ) { return null ; } byte [ ] bb = bi . to Byte Array ( ) ; if ( bb [ NUM ] == NUM ) { byte [ ] no Zero = new byte [ bb . length - NUM ] ; System . arraycopy ( bb , NUM , no Zero , NUM , no Zero . length ) ; return no Zero ; } else { return bb ; } }
public void on Complete ( final Consumer < On Complete > fn ) { this . for X Of = fn ; if ( done ) { fn . accept ( build On Complete ( ) ) ; } }
@ Override public synchronized void clear ( ) { File [ ] files = m Root Directory . list Files ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } m Entries . clear ( ) ; Volley Log . d ( STRING ) ; }
@ Override public synchronized void clear ( ) { File [ ] files = m Root Directory . list Files ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } m Entries . clear ( ) ; Volley Log . d ( STRING ) ; }
public static Bitmap make Round User Picture ( Bitmap bitmap ) { if ( bitmap == null ) return null ; Bitmap output = Bitmap . create Bitmap ( bitmap . get Width ( ) , bitmap . get Height ( ) , Config . ARGB 8888 ) ; Canvas canvas = new Canvas ( output ) ; final Paint paint = new Paint ( ) ; final Rect rect = new Rect ( NUM , NUM , bitmap . get Width ( ) , bitmap . get Height ( ) ) ; canvas . draw ARGB ( NUM , NUM , NUM , NUM ) ; paint . set Anti Alias ( BOOL ) ; paint . set Color ( NUM ) ; canvas . draw Circle ( bitmap . get Width ( ) * NUM , bitmap . get Height ( ) * NUM , bitmap . get Width ( ) * NUM , paint ) ; paint . set Xfermode ( new Porter Duff Xfermode ( Porter Duff . Mode . SRC IN ) ) ; canvas . draw Bitmap ( bitmap , rect , rect , paint ) ; return output ; }
public static Bitmap make Round User Picture ( Bitmap bitmap ) { if ( bitmap == null ) return null ; Bitmap output = Bitmap . create Bitmap ( bitmap . get Width ( ) , bitmap . get Height ( ) , Config . ARGB 8888 ) ; Canvas canvas = new Canvas ( output ) ; final Paint paint = new Paint ( ) ; final Rect rect = new Rect ( NUM , NUM , bitmap . get Width ( ) , bitmap . get Height ( ) ) ; canvas . draw ARGB ( NUM , NUM , NUM , NUM ) ; paint . set Anti Alias ( BOOL ) ; paint . set Color ( NUM ) ; canvas . draw Circle ( bitmap . get Width ( ) * NUM , bitmap . get Height ( ) * NUM , bitmap . get Width ( ) * NUM , paint ) ; paint . set Xfermode ( new Porter Duff Xfermode ( Porter Duff . Mode . SRC IN ) ) ; canvas . draw Bitmap ( bitmap , rect , rect , paint ) ; return output ; }
@ Override public int process Image ( String name , final int data Pointer , final Pdf Object X Object ) throws Pdf Exception { String key = null ; if ( Image Commands . reject Superimposed Images ) { key = ( ( int ) gs . CTM [ NUM ] [ NUM ] ) + STRING + ( ( int ) gs . CTM [ NUM ] [ NUM ] ) + STRING + ( ( int ) gs . CTM [ NUM ] [ NUM ] ) + STRING + ( ( int ) gs . CTM [ NUM ] [ NUM ] ) + STRING + ( ( int ) gs . CTM [ NUM ] [ NUM ] ) + STRING + ( ( int ) gs . CTM [ NUM ] [ NUM ] ) ; } try { if ( System . get Property ( STRING ) == null ) { process X Image ( name , name , key , X Object ) ; } } catch ( final Error e ) { Log Writer . write Log ( STRING + e . get Message ( ) ) ; parser Options . images Processed Fully = BOOL ; error Tracker . add Page Failure Message ( STRING + e + STRING ) ; } catch ( final Exception e ) { Log Writer . write Log ( STRING + e ) ; parser Options . images Processed Fully = BOOL ; error Tracker . add Page Failure Message ( STRING + e + STRING ) ; } return data Pointer ; }
@ Override public int process Image ( String name , final int data Pointer , final Pdf Object X Object ) throws Pdf Exception { String key = null ; if ( Image Commands . reject Superimposed Images ) { key = ( ( int ) gs . CTM [ NUM ] [ NUM ] ) + STRING + ( ( int ) gs . CTM [ NUM ] [ NUM ] ) + STRING + ( ( int ) gs . CTM [ NUM ] [ NUM ] ) + STRING + ( ( int ) gs . CTM [ NUM ] [ NUM ] ) + STRING + ( ( int ) gs . CTM [ NUM ] [ NUM ] ) + STRING + ( ( int ) gs . CTM [ NUM ] [ NUM ] ) ; } try { if ( System . get Property ( STRING ) == null ) { process X Image ( name , name , key , X Object ) ; } } catch ( final Error e ) { Log Writer . write Log ( STRING + e . get Message ( ) ) ; parser Options . images Processed Fully = BOOL ; error Tracker . add Page Failure Message ( STRING + e + STRING ) ; } catch ( final Exception e ) { Log Writer . write Log ( STRING + e ) ; parser Options . images Processed Fully = BOOL ; error Tracker . add Page Failure Message ( STRING + e + STRING ) ; } return data Pointer ; }
protected void write Raw ( final String text ) { write Indent ( ) ; try { final int length = text != null ? text . length ( ) : NULL TEXT . length ( ) ; writer . write ( text ) ; column += length ; if ( text == null ) { return ; } boolean new Line Seen = BOOL ; for ( int i = NUM ; i < length ; i ++ ) { if ( text . char At ( i ) == STRING ) { line ++ ; column = NUM ; new Line Seen = BOOL ; } else if ( new Line Seen ) { column ++ ; } } } catch ( IO Exception e ) { throw new Undeclared Throwable Exception ( e ) ; } }
public static int previous Clear Bit ( long v , int start ) { if ( start < NUM || start >= Long . SIZE ) { return - NUM ; } long cur = ~ v & ( LONG ALL BITS > > > start ) ; if ( cur == NUM ) { return - NUM ; } return Long . SIZE - NUM - Long . number Of Trailing Zeros ( cur ) ; }
public int hash Code ( ) { return alignment ^ leader ^ Math . round ( position ) ; }
public int hash Code ( ) { return alignment ^ leader ^ Math . round ( position ) ; }
public void close ( ) throws IO Exception { if ( ! closed ) { try { if ( ! eof ) { exhaust Input Stream ( this ) ; } } finally { eof = BOOL ; closed = BOOL ; } } }
public void close ( ) throws IO Exception { if ( ! closed ) { try { if ( ! eof ) { exhaust Input Stream ( this ) ; } } finally { eof = BOOL ; closed = BOOL ; } } }
public void close ( ) throws IO Exception { if ( ! closed ) { try { if ( ! eof ) { exhaust Input Stream ( this ) ; } } finally { eof = BOOL ; closed = BOOL ; } } }
public void close ( ) throws IO Exception { if ( ! closed ) { try { if ( ! eof ) { exhaust Input Stream ( this ) ; } } finally { eof = BOOL ; closed = BOOL ; } } }
public void close ( ) throws IO Exception { if ( ! closed ) { try { if ( ! eof ) { exhaust Input Stream ( this ) ; } } finally { eof = BOOL ; closed = BOOL ; } } }
public void close ( ) throws IO Exception { if ( ! closed ) { try { if ( ! eof ) { exhaust Input Stream ( this ) ; } } finally { eof = BOOL ; closed = BOOL ; } } }
private Image create Packed Image 8 ( ) throws IO Exception { int size = input . read Byte ( ) & NUM ; if ( size == NUM ) { size = NUM ; } int [ ] palette = new int [ size ] ; int plen = palette . length ; for ( int iter = NUM ; iter < plen ; iter ++ ) { palette [ iter ] = input . read Int ( ) ; } int width = input . read Short ( ) ; int height = input . read Short ( ) ; byte [ ] data = new byte [ width * height ] ; input . read Fully ( data , NUM , data . length ) ; return Image . create Indexed ( width , height , palette , data ) ; }
private void add Sessions Registration Listener ( final Third Party Registration Listener listener ) { synchronized ( this ) { if ( ( null != listener ) && ( m Third Party Registration Listeners . index Of ( listener ) == - NUM ) ) { m Third Party Registration Listeners . add ( listener ) ; } } }
public void remove Operations ( Operation operation , Object token ) { if ( is Running ) { if ( operation Handler Thread Handler == null ) return ; operation Handler Thread Handler . remove Callbacks ( new Android Operation ( this , operation ) , token ) ; } else { operation Queue . remove ( new Android Operation ( this , operation , Android Operation . Type . NORMAL , token , NUM ) ) ; } }
public static String trim ( String s , boolean leading , boolean trailing , String sp ) { char space = ( sp == null || sp . length ( ) < NUM ) ? STRING : sp . char At ( NUM ) ; if ( leading ) { int len = s . length ( ) , i = NUM ; while ( i < len && s . char At ( i ) == space ) { i ++ ; } s = ( i == NUM ) ? s : s . substring ( i ) ; } if ( trailing ) { int end Index = s . length ( ) - NUM ; int i = end Index ; while ( i >= NUM && s . char At ( i ) == space ) { i -- ; } s = i == end Index ? s : s . substring ( NUM , i + NUM ) ; } return s ; }
public void mark ( int read Ahead Limit ) throws IO Exception { if ( stream != null ) { stream . mark ( read Ahead Limit ) ; } else { reader . mark ( read Ahead Limit ) ; } }
public static double normalize Radians ( double r ) { if ( r < NUM && r >= - TWO PI ) return r + TWO PI ; if ( r >= TWO PI && r < FOUR PI ) return r - TWO PI ; if ( r >= NUM && r < TWO PI ) return r ; r -= TWO PI * Math . floor ( r * TWO PI INVERSE ) ; if ( r < NUM ) r += TWO PI ; return r ; }
@ Override public void perform On Background ( final Runnable runnable ) { m Logger . log Debug ( STRING + m Background Executor . get Active Count ( ) ) ; m Background Executor . execute ( runnable ) ; }
@ Override public void perform On Background ( final Runnable runnable ) { m Logger . log Debug ( STRING + m Background Executor . get Active Count ( ) ) ; m Background Executor . execute ( runnable ) ; }
private void load Matrix ( final Matrix matrix , final File file ) throws IO Exception { final Iterator < String > lines = Util . read File Line By Line ( file ) ; int row = NUM ; while ( lines . has Next ( ) ) { final String line = lines . next ( ) ; final String [ ] fields = line . split ( STRING ) ; for ( int i = NUM ; i < fields . length ; i ++ ) { matrix . set ( row , i , Double . value Of ( fields [ i ] ) ) ; } row ++ ; } }
public int hash Code ( ) { int hash = addr Type . hash Code ( ) ; for ( int i = NUM ; i < buf . length ; i ++ ) { hash += buf [ i ] ; } return hash ; }
public int hash Code ( ) { int hash = addr Type . hash Code ( ) ; for ( int i = NUM ; i < buf . length ; i ++ ) { hash += buf [ i ] ; } return hash ; }
public int hash Code ( ) { int hash = addr Type . hash Code ( ) ; for ( int i = NUM ; i < buf . length ; i ++ ) { hash += buf [ i ] ; } return hash ; }
public int hash Code ( ) { int hash = addr Type . hash Code ( ) ; for ( int i = NUM ; i < buf . length ; i ++ ) { hash += buf [ i ] ; } return hash ; }
public int hash Code ( ) { int hash = addr Type . hash Code ( ) ; for ( int i = NUM ; i < buf . length ; i ++ ) { hash += buf [ i ] ; } return hash ; }
public synchronized Object co entry pause ( int this Coroutine ) throws java . lang . No Such Method Exception { if ( ! m active I Ds . get ( this Coroutine ) ) throw new java . lang . No Such Method Exception ( ) ; while ( m next Coroutine != this Coroutine ) { try { wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { } } return m yield ; }
public synchronized Object co entry pause ( int this Coroutine ) throws java . lang . No Such Method Exception { if ( ! m active I Ds . get ( this Coroutine ) ) throw new java . lang . No Such Method Exception ( ) ; while ( m next Coroutine != this Coroutine ) { try { wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { } } return m yield ; }
public synchronized Object co entry pause ( int this Coroutine ) throws java . lang . No Such Method Exception { if ( ! m active I Ds . get ( this Coroutine ) ) throw new java . lang . No Such Method Exception ( ) ; while ( m next Coroutine != this Coroutine ) { try { wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { } } return m yield ; }
public synchronized Object co entry pause ( int this Coroutine ) throws java . lang . No Such Method Exception { if ( ! m active I Ds . get ( this Coroutine ) ) throw new java . lang . No Such Method Exception ( ) ; while ( m next Coroutine != this Coroutine ) { try { wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { } } return m yield ; }
public synchronized Object co entry pause ( int this Coroutine ) throws java . lang . No Such Method Exception { if ( ! m active I Ds . get ( this Coroutine ) ) throw new java . lang . No Such Method Exception ( ) ; while ( m next Coroutine != this Coroutine ) { try { wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { } } return m yield ; }
public synchronized Object co entry pause ( int this Coroutine ) throws java . lang . No Such Method Exception { if ( ! m active I Ds . get ( this Coroutine ) ) throw new java . lang . No Such Method Exception ( ) ; while ( m next Coroutine != this Coroutine ) { try { wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { } } return m yield ; }
public synchronized Object co entry pause ( int this Coroutine ) throws java . lang . No Such Method Exception { if ( ! m active I Ds . get ( this Coroutine ) ) throw new java . lang . No Such Method Exception ( ) ; while ( m next Coroutine != this Coroutine ) { try { wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { } } return m yield ; }
public synchronized Object co entry pause ( int this Coroutine ) throws java . lang . No Such Method Exception { if ( ! m active I Ds . get ( this Coroutine ) ) throw new java . lang . No Such Method Exception ( ) ; while ( m next Coroutine != this Coroutine ) { try { wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { } } return m yield ; }
public synchronized Object co entry pause ( int this Coroutine ) throws java . lang . No Such Method Exception { if ( ! m active I Ds . get ( this Coroutine ) ) throw new java . lang . No Such Method Exception ( ) ; while ( m next Coroutine != this Coroutine ) { try { wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { } } return m yield ; }
public synchronized Object co entry pause ( int this Coroutine ) throws java . lang . No Such Method Exception { if ( ! m active I Ds . get ( this Coroutine ) ) throw new java . lang . No Such Method Exception ( ) ; while ( m next Coroutine != this Coroutine ) { try { wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { } } return m yield ; }
public synchronized Object co entry pause ( int this Coroutine ) throws java . lang . No Such Method Exception { if ( ! m active I Ds . get ( this Coroutine ) ) throw new java . lang . No Such Method Exception ( ) ; while ( m next Coroutine != this Coroutine ) { try { wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { } } return m yield ; }
public synchronized Object co entry pause ( int this Coroutine ) throws java . lang . No Such Method Exception { if ( ! m active I Ds . get ( this Coroutine ) ) throw new java . lang . No Such Method Exception ( ) ; while ( m next Coroutine != this Coroutine ) { try { wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { } } return m yield ; }
public synchronized Object co entry pause ( int this Coroutine ) throws java . lang . No Such Method Exception { if ( ! m active I Ds . get ( this Coroutine ) ) throw new java . lang . No Such Method Exception ( ) ; while ( m next Coroutine != this Coroutine ) { try { wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { } } return m yield ; }
public synchronized Object co entry pause ( int this Coroutine ) throws java . lang . No Such Method Exception { if ( ! m active I Ds . get ( this Coroutine ) ) throw new java . lang . No Such Method Exception ( ) ; while ( m next Coroutine != this Coroutine ) { try { wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { } } return m yield ; }
public void test Invoke Any 4 ( ) throws Throwable { Count Down Latch latch = new Count Down Latch ( NUM ) ; Executor Service e = new Fork Join Pool ( NUM ) ; Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; List < Callable < String > > l = new Array List < Callable < String > > ( ) ; l . add ( latch Awaiting String Task ( latch ) ) ; l . add ( null ) ; try { e . invoke Any ( l ) ; should Throw ( ) ; } catch ( Null Pointer Exception success ) { } latch . count Down ( ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public void test Invoke Any 4 ( ) throws Throwable { Count Down Latch latch = new Count Down Latch ( NUM ) ; Executor Service e = new Fork Join Pool ( NUM ) ; Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; List < Callable < String > > l = new Array List < Callable < String > > ( ) ; l . add ( latch Awaiting String Task ( latch ) ) ; l . add ( null ) ; try { e . invoke Any ( l ) ; should Throw ( ) ; } catch ( Null Pointer Exception success ) { } latch . count Down ( ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public void test Invoke Any 4 ( ) throws Throwable { Count Down Latch latch = new Count Down Latch ( NUM ) ; Executor Service e = new Fork Join Pool ( NUM ) ; Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; List < Callable < String > > l = new Array List < Callable < String > > ( ) ; l . add ( latch Awaiting String Task ( latch ) ) ; l . add ( null ) ; try { e . invoke Any ( l ) ; should Throw ( ) ; } catch ( Null Pointer Exception success ) { } latch . count Down ( ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public synchronized T remove Next Hatched If Available ( ) { T o = get Next Hatched If Available ( ) ; if ( o == null ) return null ; order List . remove First ( ) ; hatch Map . remove ( o ) ; notify All ( ) ; return o ; }
public synchronized T remove Next Hatched If Available ( ) { T o = get Next Hatched If Available ( ) ; if ( o == null ) return null ; order List . remove First ( ) ; hatch Map . remove ( o ) ; notify All ( ) ; return o ; }
@ Inject private void init ( Node Runner Descriptor Provider descriptor Provider ) { if ( ! runner Registry . is Registered ( Node Runner . ID ) ) { runner Registry . register ( descriptor Provider . get ( ) ) ; } }
@ Inject private void init ( Node Runner Descriptor Provider descriptor Provider ) { if ( ! runner Registry . is Registered ( Node Runner . ID ) ) { runner Registry . register ( descriptor Provider . get ( ) ) ; } }
@ Inject private void init ( Node Runner Descriptor Provider descriptor Provider ) { if ( ! runner Registry . is Registered ( Node Runner . ID ) ) { runner Registry . register ( descriptor Provider . get ( ) ) ; } }
@ Override public void write ( String str , int off , int len ) { int newcount = count + len ; if ( newcount > buf . length ) { buf = Arrays . copy Of ( buf , Math . max ( buf . length << NUM , newcount ) ) ; } str . get Chars ( off , off + len , buf , count ) ; count = newcount ; }
private static void build Name Line ( final I Navi Function Node node , final Zy Label Content content , final boolean show Function Information ) { final I Navi Function function = node . get Function ( ) ; String information String = STRING ; if ( function . get Basic Block Count ( ) > NUM ) { final String Builder builder = new String Builder ( ) ; builder . append ( STRING ) ; builder . append ( function . get Basic Block Count ( ) ) ; builder . append ( STRING ) ; if ( function . get Basic Block Count ( ) > NUM ) { builder . append ( STRING ) ; } if ( function . get Edge Count ( ) > NUM ) { builder . append ( STRING ) ; builder . append ( function . get Edge Count ( ) ) ; builder . append ( STRING ) ; if ( function . get Edge Count ( ) > NUM ) { builder . append ( STRING ) ; } } builder . append ( STRING ) ; information String = builder . to String ( ) ; } final Zy Line Content name Line = new Zy Line Content ( function . get Name ( ) + information String , NORMAL FONT , null ) ; content . add Line Content ( name Line ) ; }
private int calculated Weighted Value ( mx Graph Abstract Hierarchy Cell current Cell , Collection < mx Graph Abstract Hierarchy Cell > collection ) { int total Weight = NUM ; Iterator < mx Graph Abstract Hierarchy Cell > iter = collection . iterator ( ) ; while ( iter . has Next ( ) ) { mx Graph Abstract Hierarchy Cell cell = iter . next ( ) ; if ( current Cell . is Vertex ( ) && cell . is Vertex ( ) ) { total Weight ++ ; } else if ( current Cell . is Edge ( ) && cell . is Edge ( ) ) { total Weight += NUM ; } else { total Weight += NUM ; } } return total Weight ; }
private int calculated Weighted Value ( mx Graph Abstract Hierarchy Cell current Cell , Collection < mx Graph Abstract Hierarchy Cell > collection ) { int total Weight = NUM ; Iterator < mx Graph Abstract Hierarchy Cell > iter = collection . iterator ( ) ; while ( iter . has Next ( ) ) { mx Graph Abstract Hierarchy Cell cell = iter . next ( ) ; if ( current Cell . is Vertex ( ) && cell . is Vertex ( ) ) { total Weight ++ ; } else if ( current Cell . is Edge ( ) && cell . is Edge ( ) ) { total Weight += NUM ; } else { total Weight += NUM ; } } return total Weight ; }
public void changed Update ( Document Event e ) { m Apply Button . set Enabled ( is Valid Format ( ) ) ; }
private static final void wait For Editor To Be Active ( I Editor Part internal File Editor , I Workbench Page page ) { long start = System . current Time Millis ( ) ; long end = start ; do { end = System . current Time Millis ( ) ; } while ( page . get Active Editor ( ) != internal File Editor && ( end - start ) < NUM ) ; if ( page . get Active Editor ( ) != internal File Editor ) logger . warn ( STRING ) ; }
public static Properties read Properties ( Class clazz ) { return read Properties ( clazz . get Name ( ) ) ; }
protected Background Task ( long timeout , Time Unit time Unit ) { this . owner Frame = null ; this . timeout Milliseconds = time Unit . to Millis ( timeout ) ; }
protected Background Task ( long timeout , Time Unit time Unit ) { this . owner Frame = null ; this . timeout Milliseconds = time Unit . to Millis ( timeout ) ; }
public void verify Bean Property Exist ( String property Name ) throws Exception { Class clazz = Class . for Name ( class Name ) ; String getter Method Name = generate Getter Method Name ( property Name ) ; verify Method Exist ( getter Method Name ) ; String setter Method Name = generate Setter Method Name ( property Name ) ; verify Method Exist ( setter Method Name ) ; }
public void verify Bean Property Exist ( String property Name ) throws Exception { Class clazz = Class . for Name ( class Name ) ; String getter Method Name = generate Getter Method Name ( property Name ) ; verify Method Exist ( getter Method Name ) ; String setter Method Name = generate Setter Method Name ( property Name ) ; verify Method Exist ( setter Method Name ) ; }
public void update Successful Query Timestamp ( ) { create User If Null ( ) ; user Entity . set Property ( STRING , System . current Time Millis ( ) ) ; service . put ( user Entity ) ; }
public static void clear Time Of Day ( Calendar calendar ) { calendar . set ( Calendar . MILLISECOND , NUM ) ; calendar . set ( Calendar . SECOND , NUM ) ; calendar . set ( Calendar . MINUTE , NUM ) ; calendar . set ( Calendar . HOUR OF DAY , NUM ) ; }
public static Hash Provider best ( Hash Parameters params ) { return best ( params , Enum Set . of ( Hash Support . STATEFUL ) ) ; }
public static Hash Provider best ( Hash Parameters params ) { return best ( params , Enum Set . of ( Hash Support . STATEFUL ) ) ; }
public void test Get Colors By Level ( ) { try { for ( String color Level : Material Palettes . NON ACCENT COLOR LEVELS ) { List < Integer > colors = Material Palettes . get Colors By Level ( color Level ) ; assert Equals ( Material Palettes . ALL COLOR NAMES . length , colors . size ( ) ) ; } } catch ( Illegal Access Exception iae ) { fail ( ) ; } try { for ( String color Level : Material Palettes . ACCENT COLOR LEVELS ) { List < Integer > colors = Material Palettes . get Colors By Level ( color Level ) ; assert Equals ( Material Palettes . COLORS WITH ACCENT NAMES . length , colors . size ( ) ) ; } } catch ( Illegal Access Exception iae ) { fail ( ) ; } try { List < Integer > colors = Material Palettes . get Colors By Name ( STRING ) ; fail ( ) ; } catch ( Illegal Argument Exception iae ) { } catch ( Illegal Access Exception iae 1 ) { fail ( ) ; } try { List < Integer > colors = Material Palettes . get Colors By Level ( null ) ; fail ( ) ; } catch ( Illegal Argument Exception iae ) { } catch ( Illegal Access Exception iae 1 ) { fail ( ) ; } }
public void test Get Colors By Level ( ) { try { for ( String color Level : Material Palettes . NON ACCENT COLOR LEVELS ) { List < Integer > colors = Material Palettes . get Colors By Level ( color Level ) ; assert Equals ( Material Palettes . ALL COLOR NAMES . length , colors . size ( ) ) ; } } catch ( Illegal Access Exception iae ) { fail ( ) ; } try { for ( String color Level : Material Palettes . ACCENT COLOR LEVELS ) { List < Integer > colors = Material Palettes . get Colors By Level ( color Level ) ; assert Equals ( Material Palettes . COLORS WITH ACCENT NAMES . length , colors . size ( ) ) ; } } catch ( Illegal Access Exception iae ) { fail ( ) ; } try { List < Integer > colors = Material Palettes . get Colors By Name ( STRING ) ; fail ( ) ; } catch ( Illegal Argument Exception iae ) { } catch ( Illegal Access Exception iae 1 ) { fail ( ) ; } try { List < Integer > colors = Material Palettes . get Colors By Level ( null ) ; fail ( ) ; } catch ( Illegal Argument Exception iae ) { } catch ( Illegal Access Exception iae 1 ) { fail ( ) ; } }
public void test Get Colors By Level ( ) { try { for ( String color Level : Material Palettes . NON ACCENT COLOR LEVELS ) { List < Integer > colors = Material Palettes . get Colors By Level ( color Level ) ; assert Equals ( Material Palettes . ALL COLOR NAMES . length , colors . size ( ) ) ; } } catch ( Illegal Access Exception iae ) { fail ( ) ; } try { for ( String color Level : Material Palettes . ACCENT COLOR LEVELS ) { List < Integer > colors = Material Palettes . get Colors By Level ( color Level ) ; assert Equals ( Material Palettes . COLORS WITH ACCENT NAMES . length , colors . size ( ) ) ; } } catch ( Illegal Access Exception iae ) { fail ( ) ; } try { List < Integer > colors = Material Palettes . get Colors By Name ( STRING ) ; fail ( ) ; } catch ( Illegal Argument Exception iae ) { } catch ( Illegal Access Exception iae 1 ) { fail ( ) ; } try { List < Integer > colors = Material Palettes . get Colors By Level ( null ) ; fail ( ) ; } catch ( Illegal Argument Exception iae ) { } catch ( Illegal Access Exception iae 1 ) { fail ( ) ; } }
public void test Get Colors By Level ( ) { try { for ( String color Level : Material Palettes . NON ACCENT COLOR LEVELS ) { List < Integer > colors = Material Palettes . get Colors By Level ( color Level ) ; assert Equals ( Material Palettes . ALL COLOR NAMES . length , colors . size ( ) ) ; } } catch ( Illegal Access Exception iae ) { fail ( ) ; } try { for ( String color Level : Material Palettes . ACCENT COLOR LEVELS ) { List < Integer > colors = Material Palettes . get Colors By Level ( color Level ) ; assert Equals ( Material Palettes . COLORS WITH ACCENT NAMES . length , colors . size ( ) ) ; } } catch ( Illegal Access Exception iae ) { fail ( ) ; } try { List < Integer > colors = Material Palettes . get Colors By Name ( STRING ) ; fail ( ) ; } catch ( Illegal Argument Exception iae ) { } catch ( Illegal Access Exception iae 1 ) { fail ( ) ; } try { List < Integer > colors = Material Palettes . get Colors By Level ( null ) ; fail ( ) ; } catch ( Illegal Argument Exception iae ) { } catch ( Illegal Access Exception iae 1 ) { fail ( ) ; } }
public void test Get Colors By Level ( ) { try { for ( String color Level : Material Palettes . NON ACCENT COLOR LEVELS ) { List < Integer > colors = Material Palettes . get Colors By Level ( color Level ) ; assert Equals ( Material Palettes . ALL COLOR NAMES . length , colors . size ( ) ) ; } } catch ( Illegal Access Exception iae ) { fail ( ) ; } try { for ( String color Level : Material Palettes . ACCENT COLOR LEVELS ) { List < Integer > colors = Material Palettes . get Colors By Level ( color Level ) ; assert Equals ( Material Palettes . COLORS WITH ACCENT NAMES . length , colors . size ( ) ) ; } } catch ( Illegal Access Exception iae ) { fail ( ) ; } try { List < Integer > colors = Material Palettes . get Colors By Name ( STRING ) ; fail ( ) ; } catch ( Illegal Argument Exception iae ) { } catch ( Illegal Access Exception iae 1 ) { fail ( ) ; } try { List < Integer > colors = Material Palettes . get Colors By Level ( null ) ; fail ( ) ; } catch ( Illegal Argument Exception iae ) { } catch ( Illegal Access Exception iae 1 ) { fail ( ) ; } }
public void failover Copy ( RP Copy Request Params copy To Failover To ) throws Recover Point Exception { String bookmark Name = copy To Failover To . get Bookmark Name ( ) ; Date apit Time = copy To Failover To . get Apit Time ( ) ; if ( bookmark Name != null ) { logger . info ( STRING + bookmark Name ) ; } else if ( apit Time != null ) { logger . info ( STRING + apit Time . to String ( ) ) ; } else { logger . info ( STRING ) ; } Recover Point Image Management Utils image Manager = new Recover Point Image Management Utils ( ) ; image Manager . enable Copy Image ( functional API , copy To Failover To , BOOL ) ; }
public double length To Java 2 D ( double length , Rectangle 2 D area , Rectangle Edge edge ) { double zero = value To Java 2 D ( NUM , area , edge ) ; double l = value To Java 2 D ( length , area , edge ) ; return Math . abs ( l - zero ) ; }
public double length To Java 2 D ( double length , Rectangle 2 D area , Rectangle Edge edge ) { double zero = value To Java 2 D ( NUM , area , edge ) ; double l = value To Java 2 D ( length , area , edge ) ; return Math . abs ( l - zero ) ; }
public static void o ( Zmat A ) { o ( A , Parameters . Output Field Width , Parameters . Output Frac Places ) ; }
@ Override public Generator < I Line Segment > construct ( String [ ] args ) { return new Grid Generator ( Double . value Of ( args [ NUM ] ) , Double . value Of ( args [ NUM ] ) ) ; }
@ Skip Validation public DCB Display Info prepare Display Info ( ) { DCB Display Info dcb Disp Info = new DCB Display Info ( ) ; LOGGER . debug ( STRING ) ; List < String > reason Category Codes = new Array List < String > ( ) ; reason Category Codes . add ( Property Tax Constants . REASON CATEGORY CODE TAX ) ; reason Category Codes . add ( Property Tax Constants . REASON CATEGORY CODE PENALTY ) ; reason Category Codes . add ( Property Tax Constants . REASON CATEGORY CODE FINES ) ; reason Category Codes . add ( Property Tax Constants . REASON CATEGORY CODE ADVANCE ) ; dcb Disp Info . set Reason Category Codes ( reason Category Codes ) ; List < String > reason List = new Array List < String > ( ) ; reason List . add All ( ORDERED DEMAND RSNS LIST ) ; reason List . remove ( Property Tax Constants . DEMANDRSN CODE ADVANCE ) ; dcb Disp Info . set Reason Master Codes ( reason List ) ; LOGGER . debug ( STRING + dcb Disp Info ) ; LOGGER . debug ( STRING + ( reason List != null ? reason List . size ( ) : ZERO ) ) ; LOGGER . debug ( STRING ) ; return dcb Disp Info ; }
@ Skip Validation public DCB Display Info prepare Display Info ( ) { DCB Display Info dcb Disp Info = new DCB Display Info ( ) ; LOGGER . debug ( STRING ) ; List < String > reason Category Codes = new Array List < String > ( ) ; reason Category Codes . add ( Property Tax Constants . REASON CATEGORY CODE TAX ) ; reason Category Codes . add ( Property Tax Constants . REASON CATEGORY CODE PENALTY ) ; reason Category Codes . add ( Property Tax Constants . REASON CATEGORY CODE FINES ) ; reason Category Codes . add ( Property Tax Constants . REASON CATEGORY CODE ADVANCE ) ; dcb Disp Info . set Reason Category Codes ( reason Category Codes ) ; List < String > reason List = new Array List < String > ( ) ; reason List . add All ( ORDERED DEMAND RSNS LIST ) ; reason List . remove ( Property Tax Constants . DEMANDRSN CODE ADVANCE ) ; dcb Disp Info . set Reason Master Codes ( reason List ) ; LOGGER . debug ( STRING + dcb Disp Info ) ; LOGGER . debug ( STRING + ( reason List != null ? reason List . size ( ) : ZERO ) ) ; LOGGER . debug ( STRING ) ; return dcb Disp Info ; }
@ Skip Validation public DCB Display Info prepare Display Info ( ) { DCB Display Info dcb Disp Info = new DCB Display Info ( ) ; LOGGER . debug ( STRING ) ; List < String > reason Category Codes = new Array List < String > ( ) ; reason Category Codes . add ( Property Tax Constants . REASON CATEGORY CODE TAX ) ; reason Category Codes . add ( Property Tax Constants . REASON CATEGORY CODE PENALTY ) ; reason Category Codes . add ( Property Tax Constants . REASON CATEGORY CODE FINES ) ; reason Category Codes . add ( Property Tax Constants . REASON CATEGORY CODE ADVANCE ) ; dcb Disp Info . set Reason Category Codes ( reason Category Codes ) ; List < String > reason List = new Array List < String > ( ) ; reason List . add All ( ORDERED DEMAND RSNS LIST ) ; reason List . remove ( Property Tax Constants . DEMANDRSN CODE ADVANCE ) ; dcb Disp Info . set Reason Master Codes ( reason List ) ; LOGGER . debug ( STRING + dcb Disp Info ) ; LOGGER . debug ( STRING + ( reason List != null ? reason List . size ( ) : ZERO ) ) ; LOGGER . debug ( STRING ) ; return dcb Disp Info ; }
public Polynomial Function add ( final Polynomial Function p ) { final int low Length = Fast Math . min ( coefficients . length , p . coefficients . length ) ; final int high Length = Fast Math . max ( coefficients . length , p . coefficients . length ) ; double [ ] new Coefficients = new double [ high Length ] ; for ( int i = NUM ; i < low Length ; ++ i ) { new Coefficients [ i ] = coefficients [ i ] + p . coefficients [ i ] ; } System . arraycopy ( ( coefficients . length < p . coefficients . length ) ? p . coefficients : coefficients , low Length , new Coefficients , low Length , high Length - low Length ) ; return new Polynomial Function ( new Coefficients ) ; }
public Simple String [ ] split ( final char delim ) { List < Simple String > all = null ; byte low = ( byte ) ( delim & NUM ) ; byte high = ( byte ) ( delim > > NUM & NUM ) ; int las Pos = NUM ; for ( int i = NUM ; i < data . length ; i += NUM ) { if ( data [ i ] == low && data [ i + NUM ] == high ) { byte [ ] bytes = new byte [ i - las Pos ] ; System . arraycopy ( data , las Pos , bytes , NUM , bytes . length ) ; las Pos = i + NUM ; if ( all == null ) { all = new Array List < > ( NUM ) ; } all . add ( new Simple String ( bytes ) ) ; } } if ( all == null ) { return new Simple String [ ] { this } ; } else { byte [ ] bytes = new byte [ data . length - las Pos ] ; System . arraycopy ( data , las Pos , bytes , NUM , bytes . length ) ; all . add ( new Simple String ( bytes ) ) ; Simple String [ ] parts = new Simple String [ all . size ( ) ] ; return all . to Array ( parts ) ; } }
public Simple String [ ] split ( final char delim ) { List < Simple String > all = null ; byte low = ( byte ) ( delim & NUM ) ; byte high = ( byte ) ( delim > > NUM & NUM ) ; int las Pos = NUM ; for ( int i = NUM ; i < data . length ; i += NUM ) { if ( data [ i ] == low && data [ i + NUM ] == high ) { byte [ ] bytes = new byte [ i - las Pos ] ; System . arraycopy ( data , las Pos , bytes , NUM , bytes . length ) ; las Pos = i + NUM ; if ( all == null ) { all = new Array List < > ( NUM ) ; } all . add ( new Simple String ( bytes ) ) ; } } if ( all == null ) { return new Simple String [ ] { this } ; } else { byte [ ] bytes = new byte [ data . length - las Pos ] ; System . arraycopy ( data , las Pos , bytes , NUM , bytes . length ) ; all . add ( new Simple String ( bytes ) ) ; Simple String [ ] parts = new Simple String [ all . size ( ) ] ; return all . to Array ( parts ) ; } }
public static List < String > file List ( String directory Path , boolean include Full Path ) { List < String > file List = new Array List < String > ( ) ; String dir = directory Path . substring ( NUM , directory Path . last Index Of ( File . separator ) ) ; String pattern = String Utils . substring After Last ( directory Path , File . separator ) ; File directory = new File ( dir ) ; if ( directory . is Directory ( ) ) { File [ ] files = directory . list Files ( ) ; for ( int i = NUM ; i < files . length ; i ++ ) { File f = files [ i ] ; if ( f . is File ( ) ) { String file Name = f . get Name ( ) ; String full Path = dir + File . separator + file Name ; if ( file Name . matches ( convert Glob To Reg Ex ( pattern ) ) ) { if ( include Full Path ) { file List . add ( full Path ) ; } else { file List . add ( file Name ) ; } } } } } return file List ; }
public static List < String > file List ( String directory Path , boolean include Full Path ) { List < String > file List = new Array List < String > ( ) ; String dir = directory Path . substring ( NUM , directory Path . last Index Of ( File . separator ) ) ; String pattern = String Utils . substring After Last ( directory Path , File . separator ) ; File directory = new File ( dir ) ; if ( directory . is Directory ( ) ) { File [ ] files = directory . list Files ( ) ; for ( int i = NUM ; i < files . length ; i ++ ) { File f = files [ i ] ; if ( f . is File ( ) ) { String file Name = f . get Name ( ) ; String full Path = dir + File . separator + file Name ; if ( file Name . matches ( convert Glob To Reg Ex ( pattern ) ) ) { if ( include Full Path ) { file List . add ( full Path ) ; } else { file List . add ( file Name ) ; } } } } } return file List ; }
public Search Source Builder aggregation ( Abstract Aggregation Builder aggregation ) { if ( aggregations == null ) { aggregations = new Array List < > ( ) ; } aggregations . add ( aggregation ) ; return this ; }
public static < E extends Identifiable > E find By Primary Key ( Entity Manager em , Big Integer id , Class < E > type ) { require Argument ( em != null , STRING ) ; require Argument ( id != null && id . compare To ( ZERO ) > NUM , STRING ) ; require Argument ( type != null , STRING ) ; Typed Query < E > query = em . create Named Query ( STRING , type ) ; query . set Hint ( STRING , STRING ) ; try { query . set Parameter ( STRING , id ) ; query . set Parameter ( STRING , BOOL ) ; return query . get Single Result ( ) ; } catch ( No Result Exception ex ) { return null ; } }
public static < E extends Identifiable > E find By Primary Key ( Entity Manager em , Big Integer id , Class < E > type ) { require Argument ( em != null , STRING ) ; require Argument ( id != null && id . compare To ( ZERO ) > NUM , STRING ) ; require Argument ( type != null , STRING ) ; Typed Query < E > query = em . create Named Query ( STRING , type ) ; query . set Hint ( STRING , STRING ) ; try { query . set Parameter ( STRING , id ) ; query . set Parameter ( STRING , BOOL ) ; return query . get Single Result ( ) ; } catch ( No Result Exception ex ) { return null ; } }
public void add Element ( Ast Node element ) { assert Not Null ( element ) ; if ( elements == null ) elements = new Array List < Ast Node > ( ) ; elements . add ( element ) ; element . set Parent ( this ) ; }
public void add Element ( Ast Node element ) { assert Not Null ( element ) ; if ( elements == null ) elements = new Array List < Ast Node > ( ) ; elements . add ( element ) ; element . set Parent ( this ) ; }
public long cstime ( ) { return Long . parse Long ( fields [ NUM ] ) ; }
public static final void write List Xml ( List val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int n = val . size ( ) ; int i = NUM ; while ( i < n ) { write Value Xml ( val . get ( i ) , null , out ) ; i ++ ; } out . end Tag ( null , STRING ) ; }
public static final void write List Xml ( List val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int n = val . size ( ) ; int i = NUM ; while ( i < n ) { write Value Xml ( val . get ( i ) , null , out ) ; i ++ ; } out . end Tag ( null , STRING ) ; }
public static final void write List Xml ( List val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int n = val . size ( ) ; int i = NUM ; while ( i < n ) { write Value Xml ( val . get ( i ) , null , out ) ; i ++ ; } out . end Tag ( null , STRING ) ; }
public static final void write List Xml ( List val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int n = val . size ( ) ; int i = NUM ; while ( i < n ) { write Value Xml ( val . get ( i ) , null , out ) ; i ++ ; } out . end Tag ( null , STRING ) ; }
protected void parse Member Name ( final String [ ] args ) { for ( String arg : args ) { if ( ! ( arg . starts With ( OPTION PREFIX ) || Command . is Command ( arg ) ) ) { set Member Name ( arg ) ; break ; } } }
protected void parse Member Name ( final String [ ] args ) { for ( String arg : args ) { if ( ! ( arg . starts With ( OPTION PREFIX ) || Command . is Command ( arg ) ) ) { set Member Name ( arg ) ; break ; } } }
protected void calc Positions ( ) { for ( int index = NUM ; index < vertex Array . length ; index ++ ) { if ( is Moveable [ index ] ) { double delta Length = Math . sqrt ( disp X [ index ] * disp X [ index ] + disp Y [ index ] * disp Y [ index ] ) ; if ( delta Length < NUM ) { delta Length = NUM ; } double new X Disp = disp X [ index ] / delta Length * Math . min ( delta Length , temperature ) ; double new Y Disp = disp Y [ index ] / delta Length * Math . min ( delta Length , temperature ) ; disp X [ index ] = NUM ; disp Y [ index ] = NUM ; cell Location [ index ] [ NUM ] += new X Disp ; cell Location [ index ] [ NUM ] += new Y Disp ; } } }
protected void calc Positions ( ) { for ( int index = NUM ; index < vertex Array . length ; index ++ ) { if ( is Moveable [ index ] ) { double delta Length = Math . sqrt ( disp X [ index ] * disp X [ index ] + disp Y [ index ] * disp Y [ index ] ) ; if ( delta Length < NUM ) { delta Length = NUM ; } double new X Disp = disp X [ index ] / delta Length * Math . min ( delta Length , temperature ) ; double new Y Disp = disp Y [ index ] / delta Length * Math . min ( delta Length , temperature ) ; disp X [ index ] = NUM ; disp Y [ index ] = NUM ; cell Location [ index ] [ NUM ] += new X Disp ; cell Location [ index ] [ NUM ] += new Y Disp ; } } }
public static Arguments parse Args ( final String args ) { Map < String , String > parsed = new Hash Map < > ( ) ; for ( String arg Pair : args . split ( STRING ) ) { String [ ] tokens = arg Pair . split ( STRING ) ; if ( tokens . length != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } parsed . put ( tokens [ NUM ] , tokens [ NUM ] ) ; } for ( String required Arg : REQUIRED ) { if ( ! parsed . contains Key ( required Arg ) ) { throw new Illegal Argument Exception ( String . format ( STRING , required Arg ) ) ; } } return new Arguments ( parsed ) ; }
public static Arguments parse Args ( final String args ) { Map < String , String > parsed = new Hash Map < > ( ) ; for ( String arg Pair : args . split ( STRING ) ) { String [ ] tokens = arg Pair . split ( STRING ) ; if ( tokens . length != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } parsed . put ( tokens [ NUM ] , tokens [ NUM ] ) ; } for ( String required Arg : REQUIRED ) { if ( ! parsed . contains Key ( required Arg ) ) { throw new Illegal Argument Exception ( String . format ( STRING , required Arg ) ) ; } } return new Arguments ( parsed ) ; }
public boolean unregister Client ( Unregister Profile profile , Server Config utils , Context context , API Result Call Back api Result Callback ) throws Android Agent Exception { String Builder end Point = new String Builder ( ) ; end Point . append ( utils . get API Server URL ( context ) ) ; end Point . append ( Constants . DYNAMIC CLIENT REGISTER ENDPOINT ) ; end Point . append ( STRING + USER ID + STRING + profile . get User Id ( ) ) ; end Point . append ( STRING + CONSUMER KEY + STRING + profile . get Consumer Key ( ) ) ; end Point . append ( STRING + APPLICATION NAME + STRING + profile . get Application Name ( ) ) ; End Point Info end Point Info = new End Point Info ( ) ; end Point Info . set Http Method ( org . wso 2 . emm . agent . proxy . utils . Constants . HTTP METHODS . DELETE ) ; end Point Info . set End Point ( end Point . to String ( ) ) ; send Request ( end Point Info , api Result Callback , Constants . DYNAMIC CLIENT UNREGISTER REQUEST CODE ) ; return BOOL ; }
private boolean peer Exists ( String id ) { if ( id == null ) return BOOL ; for ( Peer peer : peer List ) { if ( id . equals ( peer . get Peer Id ( ) ) ) { return BOOL ; } } return BOOL ; }
public void test Set Issuers Ljava util Collection ( ) { X509 CRL Selector selector = new X509 CRL Selector ( ) ; X500 Principal iss 1 = new X500 Principal ( STRING ) ; X500 Principal iss 2 = new X500 Principal ( STRING ) ; X500 Principal iss 3 = new X500 Principal ( STRING ) ; Test CRL crl 1 = new Test CRL ( iss 1 ) ; Test CRL crl 2 = new Test CRL ( iss 2 ) ; Test CRL crl 3 = new Test CRL ( iss 3 ) ; selector . set Issuers ( null ) ; assert True ( STRING , selector . match ( crl 1 ) && selector . match ( crl 2 ) ) ; Array List < X500 Principal > issuers = new Array List < X500 Principal > ( NUM ) ; issuers . add ( iss 1 ) ; issuers . add ( iss 2 ) ; selector . set Issuers ( issuers ) ; assert True ( STRING , selector . match ( crl 1 ) && selector . match ( crl 2 ) ) ; assert False ( STRING , selector . match ( crl 3 ) ) ; issuers . add ( iss 3 ) ; assert False ( STRING + STRING , selector . match ( crl 3 ) ) ; }
public void test Set Issuers Ljava util Collection ( ) { X509 CRL Selector selector = new X509 CRL Selector ( ) ; X500 Principal iss 1 = new X500 Principal ( STRING ) ; X500 Principal iss 2 = new X500 Principal ( STRING ) ; X500 Principal iss 3 = new X500 Principal ( STRING ) ; Test CRL crl 1 = new Test CRL ( iss 1 ) ; Test CRL crl 2 = new Test CRL ( iss 2 ) ; Test CRL crl 3 = new Test CRL ( iss 3 ) ; selector . set Issuers ( null ) ; assert True ( STRING , selector . match ( crl 1 ) && selector . match ( crl 2 ) ) ; Array List < X500 Principal > issuers = new Array List < X500 Principal > ( NUM ) ; issuers . add ( iss 1 ) ; issuers . add ( iss 2 ) ; selector . set Issuers ( issuers ) ; assert True ( STRING , selector . match ( crl 1 ) && selector . match ( crl 2 ) ) ; assert False ( STRING , selector . match ( crl 3 ) ) ; issuers . add ( iss 3 ) ; assert False ( STRING + STRING , selector . match ( crl 3 ) ) ; }
public void test Set Issuers Ljava util Collection ( ) { X509 CRL Selector selector = new X509 CRL Selector ( ) ; X500 Principal iss 1 = new X500 Principal ( STRING ) ; X500 Principal iss 2 = new X500 Principal ( STRING ) ; X500 Principal iss 3 = new X500 Principal ( STRING ) ; Test CRL crl 1 = new Test CRL ( iss 1 ) ; Test CRL crl 2 = new Test CRL ( iss 2 ) ; Test CRL crl 3 = new Test CRL ( iss 3 ) ; selector . set Issuers ( null ) ; assert True ( STRING , selector . match ( crl 1 ) && selector . match ( crl 2 ) ) ; Array List < X500 Principal > issuers = new Array List < X500 Principal > ( NUM ) ; issuers . add ( iss 1 ) ; issuers . add ( iss 2 ) ; selector . set Issuers ( issuers ) ; assert True ( STRING , selector . match ( crl 1 ) && selector . match ( crl 2 ) ) ; assert False ( STRING , selector . match ( crl 3 ) ) ; issuers . add ( iss 3 ) ; assert False ( STRING + STRING , selector . match ( crl 3 ) ) ; }
public void test Set Issuers Ljava util Collection ( ) { X509 CRL Selector selector = new X509 CRL Selector ( ) ; X500 Principal iss 1 = new X500 Principal ( STRING ) ; X500 Principal iss 2 = new X500 Principal ( STRING ) ; X500 Principal iss 3 = new X500 Principal ( STRING ) ; Test CRL crl 1 = new Test CRL ( iss 1 ) ; Test CRL crl 2 = new Test CRL ( iss 2 ) ; Test CRL crl 3 = new Test CRL ( iss 3 ) ; selector . set Issuers ( null ) ; assert True ( STRING , selector . match ( crl 1 ) && selector . match ( crl 2 ) ) ; Array List < X500 Principal > issuers = new Array List < X500 Principal > ( NUM ) ; issuers . add ( iss 1 ) ; issuers . add ( iss 2 ) ; selector . set Issuers ( issuers ) ; assert True ( STRING , selector . match ( crl 1 ) && selector . match ( crl 2 ) ) ; assert False ( STRING , selector . match ( crl 3 ) ) ; issuers . add ( iss 3 ) ; assert False ( STRING + STRING , selector . match ( crl 3 ) ) ; }
public void test Set Issuers Ljava util Collection ( ) { X509 CRL Selector selector = new X509 CRL Selector ( ) ; X500 Principal iss 1 = new X500 Principal ( STRING ) ; X500 Principal iss 2 = new X500 Principal ( STRING ) ; X500 Principal iss 3 = new X500 Principal ( STRING ) ; Test CRL crl 1 = new Test CRL ( iss 1 ) ; Test CRL crl 2 = new Test CRL ( iss 2 ) ; Test CRL crl 3 = new Test CRL ( iss 3 ) ; selector . set Issuers ( null ) ; assert True ( STRING , selector . match ( crl 1 ) && selector . match ( crl 2 ) ) ; Array List < X500 Principal > issuers = new Array List < X500 Principal > ( NUM ) ; issuers . add ( iss 1 ) ; issuers . add ( iss 2 ) ; selector . set Issuers ( issuers ) ; assert True ( STRING , selector . match ( crl 1 ) && selector . match ( crl 2 ) ) ; assert False ( STRING , selector . match ( crl 3 ) ) ; issuers . add ( iss 3 ) ; assert False ( STRING + STRING , selector . match ( crl 3 ) ) ; }
private String liveness ( ) { boolean is Closed = BOOL ; try { if ( is Closed ( ) ) { is Closed = BOOL ; } } catch ( SQL Exception s ) { is Closed = BOOL ; } if ( is Closed ) { return STRING ; } return STRING ; }
public Type 1 Font ( String platname , Object native Names , boolean created Copy ) throws Font Format Exception { super ( platname , native Names ) ; font Rank = Font 2 D . TYPE 1 RANK ; checked Natives = BOOL ; try { verify ( ) ; } catch ( Throwable t ) { if ( created Copy ) { T1 Disposer Record ref = new T1 Disposer Record ( platname ) ; Disposer . add Object Record ( buffer Ref , ref ) ; buffer Ref = null ; } if ( t instanceof Font Format Exception ) { throw ( Font Format Exception ) t ; } else { throw new Font Format Exception ( STRING ) ; } } }
public static Vector < String > find ( Class < ? > cls , String [ ] pkgnames ) { Vector < String > result ; int i ; Hash Set < String > names ; result = new Vector < String > ( ) ; names = new Hash Set < String > ( ) ; for ( i = NUM ; i < pkgnames . length ; i ++ ) { names . add All ( find ( cls , pkgnames [ i ] ) ) ; } result . add All ( names ) ; Collections . sort ( result , new String Compare ( ) ) ; return result ; }
public static Vector < String > find ( Class < ? > cls , String [ ] pkgnames ) { Vector < String > result ; int i ; Hash Set < String > names ; result = new Vector < String > ( ) ; names = new Hash Set < String > ( ) ; for ( i = NUM ; i < pkgnames . length ; i ++ ) { names . add All ( find ( cls , pkgnames [ i ] ) ) ; } result . add All ( names ) ; Collections . sort ( result , new String Compare ( ) ) ; return result ; }
private boolean can Be Narrowing Primitive Conversion ( Type Mirror type ) { Type Mirror unboxed Type = Types Utils . is Boxed Primitive ( type ) ? types . unboxed Type ( type ) : type ; Type Kind unboxed Kind = unboxed Type . get Kind ( ) ; return unboxed Kind == Type Kind . BYTE || unboxed Kind == Type Kind . SHORT || unboxed Kind == Type Kind . CHAR ; }
private boolean can Be Narrowing Primitive Conversion ( Type Mirror type ) { Type Mirror unboxed Type = Types Utils . is Boxed Primitive ( type ) ? types . unboxed Type ( type ) : type ; Type Kind unboxed Kind = unboxed Type . get Kind ( ) ; return unboxed Kind == Type Kind . BYTE || unboxed Kind == Type Kind . SHORT || unboxed Kind == Type Kind . CHAR ; }
public void mark Error Login ( String client IP ) { if ( is Disabled ( ) ) { return ; } if ( null != client IP && ! client IP . is Empty ( ) ) { String zk Path = get Zk Path ( client IP ) ; Inter Process Lock lock = null ; try { lock = coordinator . get Lock ( INVALID LOGIN CLEANER LOCK ) ; lock . acquire ( ) ; log . debug ( STRING ) ; Invalid Logins inv Logins = ( Invalid Logins ) dist Data Manager . get Data ( zk Path , BOOL ) ; if ( null == inv Logins ) { dist Data Manager . create Node ( zk Path , BOOL ) ; inv Logins = new Invalid Logins ( client IP , get Current Time In Mins ( ) , NUM ) ; log . debug ( STRING , client IP ) ; } else { inv Logins . increment Error Login Count ( ) ; } inv Logins . set Last Access Time In Long ( get Current Time In Mins ( ) ) ; log . debug ( STRING , client IP ) ; dist Data Manager . put Data ( zk Path , inv Logins ) ; } catch ( Exception ex ) { log . error ( STRING , client IP , ex ) ; } finally { if ( lock != null ) { try { lock . release ( ) ; } catch ( Exception ex ) { log . error ( STRING , ex ) ; } } } } else { log . error ( STRING ) ; } return ; }
public void mark Error Login ( String client IP ) { if ( is Disabled ( ) ) { return ; } if ( null != client IP && ! client IP . is Empty ( ) ) { String zk Path = get Zk Path ( client IP ) ; Inter Process Lock lock = null ; try { lock = coordinator . get Lock ( INVALID LOGIN CLEANER LOCK ) ; lock . acquire ( ) ; log . debug ( STRING ) ; Invalid Logins inv Logins = ( Invalid Logins ) dist Data Manager . get Data ( zk Path , BOOL ) ; if ( null == inv Logins ) { dist Data Manager . create Node ( zk Path , BOOL ) ; inv Logins = new Invalid Logins ( client IP , get Current Time In Mins ( ) , NUM ) ; log . debug ( STRING , client IP ) ; } else { inv Logins . increment Error Login Count ( ) ; } inv Logins . set Last Access Time In Long ( get Current Time In Mins ( ) ) ; log . debug ( STRING , client IP ) ; dist Data Manager . put Data ( zk Path , inv Logins ) ; } catch ( Exception ex ) { log . error ( STRING , client IP , ex ) ; } finally { if ( lock != null ) { try { lock . release ( ) ; } catch ( Exception ex ) { log . error ( STRING , ex ) ; } } } } else { log . error ( STRING ) ; } return ; }
public static Lng Lat normalize Lng Lat ( Lng Lat p1 ) { if ( p1 . longitude < Util . MIN LON || p1 . longitude > Util . MAX LON ) { int wraps = ( int ) Math . floor ( ( p1 . longitude - Util . MIN LON ) / Util . LON PER WORLD ) ; p1 . longitude -= wraps * Util . LON PER WORLD ; } return p1 ; }
public static Lng Lat normalize Lng Lat ( Lng Lat p1 ) { if ( p1 . longitude < Util . MIN LON || p1 . longitude > Util . MAX LON ) { int wraps = ( int ) Math . floor ( ( p1 . longitude - Util . MIN LON ) / Util . LON PER WORLD ) ; p1 . longitude -= wraps * Util . LON PER WORLD ; } return p1 ; }
public static Lng Lat normalize Lng Lat ( Lng Lat p1 ) { if ( p1 . longitude < Util . MIN LON || p1 . longitude > Util . MAX LON ) { int wraps = ( int ) Math . floor ( ( p1 . longitude - Util . MIN LON ) / Util . LON PER WORLD ) ; p1 . longitude -= wraps * Util . LON PER WORLD ; } return p1 ; }
public static Object serialize Clone ( final Object obj ) throws IO Exception , Class Not Found Exception { Byte Array Output Stream mem Out = new Byte Array Output Stream ( ) ; Object Output Stream obj Out = new Object Output Stream ( mem Out ) ; obj Out . write Object ( obj ) ; obj Out . close ( ) ; Byte Array Input Stream src = new Byte Array Input Stream ( mem Out . to Byte Array ( ) ) ; Object Input Stream obj Is = new Object Input Stream ( src ) ; return obj Is . read Object ( ) ; }
public static Object serialize Clone ( final Object obj ) throws IO Exception , Class Not Found Exception { Byte Array Output Stream mem Out = new Byte Array Output Stream ( ) ; Object Output Stream obj Out = new Object Output Stream ( mem Out ) ; obj Out . write Object ( obj ) ; obj Out . close ( ) ; Byte Array Input Stream src = new Byte Array Input Stream ( mem Out . to Byte Array ( ) ) ; Object Input Stream obj Is = new Object Input Stream ( src ) ; return obj Is . read Object ( ) ; }
public static boolean delete Directory Subdirectories ( String root Directory ) { if ( ( root Directory == null ) ) { return BOOL ; } boolean did Successfully Delete All Directories = BOOL ; try { List < File > files = get List Of Files In A Directory ( root Directory ) ; for ( File file : files ) { if ( file . is Directory ( ) ) { boolean delete Success = delete Directory And Contents ( file ) ; if ( ! delete Success ) { logger . debug ( STRING + file . get Absolute Path ( ) ) ; did Successfully Delete All Directories = BOOL ; } } } } catch ( Exception e ) { logger . debug ( e . to String ( ) + System . line Separator ( ) + Stack Trace . get String From Stack Trace ( e ) ) ; return BOOL ; } return did Successfully Delete All Directories ; }
public void write Field ( final String name , final double value ) throws java . io . IO Exception { write Field ( name , Double . to String ( value ) ) ; }
private long start Wait ( ) { return System . nano Time ( ) ; }
private void initialize ( URI p other ) { m scheme = p other . get Scheme ( ) ; m userinfo = p other . get Userinfo ( ) ; m host = p other . get Host ( ) ; m port = p other . get Port ( ) ; m path = p other . get Path ( ) ; m query String = p other . get Query String ( ) ; m fragment = p other . get Fragment ( ) ; }
Edge Map < Block > find Loops ( Deque < Block > code , Map < Block , Block > idom , Set Map < Block , Edge > pred ) { Edge Map < Block > loops = new Edge Map < Block > ( ) ; for ( Block b : code ) for ( Edge s : b . succ ( ) ) if ( is Loop ( s , idom ) ) { verbose Status ( STRING + s ) ; Block h = s . to ; Set < Block > loop = loops . get ( h ) ; Set < Block > work = new Tree Set < Block > ( ) ; for ( Edge p : pred . get ( h ) ) { if ( is Loop ( p , idom ) && ! loop . contains ( p . from ) && p . from != h ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } while ( ! work . is Empty ( ) ) { Block x = get Block ( work ) ; for ( Edge p : pred . get ( x ) ) { if ( p . from != h && ! loop . contains ( p . from ) ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } } } return loops ; }
Edge Map < Block > find Loops ( Deque < Block > code , Map < Block , Block > idom , Set Map < Block , Edge > pred ) { Edge Map < Block > loops = new Edge Map < Block > ( ) ; for ( Block b : code ) for ( Edge s : b . succ ( ) ) if ( is Loop ( s , idom ) ) { verbose Status ( STRING + s ) ; Block h = s . to ; Set < Block > loop = loops . get ( h ) ; Set < Block > work = new Tree Set < Block > ( ) ; for ( Edge p : pred . get ( h ) ) { if ( is Loop ( p , idom ) && ! loop . contains ( p . from ) && p . from != h ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } while ( ! work . is Empty ( ) ) { Block x = get Block ( work ) ; for ( Edge p : pred . get ( x ) ) { if ( p . from != h && ! loop . contains ( p . from ) ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } } } return loops ; }
Edge Map < Block > find Loops ( Deque < Block > code , Map < Block , Block > idom , Set Map < Block , Edge > pred ) { Edge Map < Block > loops = new Edge Map < Block > ( ) ; for ( Block b : code ) for ( Edge s : b . succ ( ) ) if ( is Loop ( s , idom ) ) { verbose Status ( STRING + s ) ; Block h = s . to ; Set < Block > loop = loops . get ( h ) ; Set < Block > work = new Tree Set < Block > ( ) ; for ( Edge p : pred . get ( h ) ) { if ( is Loop ( p , idom ) && ! loop . contains ( p . from ) && p . from != h ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } while ( ! work . is Empty ( ) ) { Block x = get Block ( work ) ; for ( Edge p : pred . get ( x ) ) { if ( p . from != h && ! loop . contains ( p . from ) ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } } } return loops ; }
Edge Map < Block > find Loops ( Deque < Block > code , Map < Block , Block > idom , Set Map < Block , Edge > pred ) { Edge Map < Block > loops = new Edge Map < Block > ( ) ; for ( Block b : code ) for ( Edge s : b . succ ( ) ) if ( is Loop ( s , idom ) ) { verbose Status ( STRING + s ) ; Block h = s . to ; Set < Block > loop = loops . get ( h ) ; Set < Block > work = new Tree Set < Block > ( ) ; for ( Edge p : pred . get ( h ) ) { if ( is Loop ( p , idom ) && ! loop . contains ( p . from ) && p . from != h ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } while ( ! work . is Empty ( ) ) { Block x = get Block ( work ) ; for ( Edge p : pred . get ( x ) ) { if ( p . from != h && ! loop . contains ( p . from ) ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } } } return loops ; }
Edge Map < Block > find Loops ( Deque < Block > code , Map < Block , Block > idom , Set Map < Block , Edge > pred ) { Edge Map < Block > loops = new Edge Map < Block > ( ) ; for ( Block b : code ) for ( Edge s : b . succ ( ) ) if ( is Loop ( s , idom ) ) { verbose Status ( STRING + s ) ; Block h = s . to ; Set < Block > loop = loops . get ( h ) ; Set < Block > work = new Tree Set < Block > ( ) ; for ( Edge p : pred . get ( h ) ) { if ( is Loop ( p , idom ) && ! loop . contains ( p . from ) && p . from != h ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } while ( ! work . is Empty ( ) ) { Block x = get Block ( work ) ; for ( Edge p : pred . get ( x ) ) { if ( p . from != h && ! loop . contains ( p . from ) ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } } } return loops ; }
Edge Map < Block > find Loops ( Deque < Block > code , Map < Block , Block > idom , Set Map < Block , Edge > pred ) { Edge Map < Block > loops = new Edge Map < Block > ( ) ; for ( Block b : code ) for ( Edge s : b . succ ( ) ) if ( is Loop ( s , idom ) ) { verbose Status ( STRING + s ) ; Block h = s . to ; Set < Block > loop = loops . get ( h ) ; Set < Block > work = new Tree Set < Block > ( ) ; for ( Edge p : pred . get ( h ) ) { if ( is Loop ( p , idom ) && ! loop . contains ( p . from ) && p . from != h ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } while ( ! work . is Empty ( ) ) { Block x = get Block ( work ) ; for ( Edge p : pred . get ( x ) ) { if ( p . from != h && ! loop . contains ( p . from ) ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } } } return loops ; }
public synchronized void insert Audio ( String inputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , byte [ ] audio ) throws SQL Exception { if ( inputtype == null || locale == null || voice == null || inputtext == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( lookup Audio ( inputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; Prepared Statement st = connection . prepare Statement ( query ) ; st . set String ( NUM , inputtext ) ; st . set Bytes ( NUM , audio ) ; st . execute Update ( ) ; st . close ( ) ; }
public synchronized void insert Audio ( String inputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , byte [ ] audio ) throws SQL Exception { if ( inputtype == null || locale == null || voice == null || inputtext == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( lookup Audio ( inputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; Prepared Statement st = connection . prepare Statement ( query ) ; st . set String ( NUM , inputtext ) ; st . set Bytes ( NUM , audio ) ; st . execute Update ( ) ; st . close ( ) ; }
private List < Entry > read Feed ( Xml Pull Parser parser ) throws Xml Pull Parser Exception , IO Exception , Parse Exception { List < Entry > entries = new Array List < > ( ) ; parser . require ( Xml Pull Parser . START TAG , ns , STRING ) ; while ( parser . next ( ) != Xml Pull Parser . END TAG ) { if ( parser . get Event Type ( ) != Xml Pull Parser . START TAG ) { continue ; } String name = parser . get Name ( ) ; if ( name . equals ( STRING ) ) { entries . add ( read Entry ( parser ) ) ; } else { skip ( parser ) ; } } return entries ; }
public Stemmed String ( Char Sequence orig , String stemmed ) { str Orig = orig . to String ( ) ; str Stemmed = stemmed ; }
protected static double calc Sigma From Mu ( double mu ) { double sigma = Math . sqrt ( mu ) ; if ( sigma < NUM ) { sigma = NUM ; } return sigma ; }
protected static double calc Sigma From Mu ( double mu ) { double sigma = Math . sqrt ( mu ) ; if ( sigma < NUM ) { sigma = NUM ; } return sigma ; }
protected static double calc Sigma From Mu ( double mu ) { double sigma = Math . sqrt ( mu ) ; if ( sigma < NUM ) { sigma = NUM ; } return sigma ; }
public Interval Category Tool Tip Generator ( ) { super ( DEFAULT TOOL TIP FORMAT STRING , Number Format . get Instance ( ) ) ; }
public static String strip ( String s ) { return s . replace All ( STRING , STRING ) ; }
public static String strip ( String s ) { return s . replace All ( STRING , STRING ) ; }
public static String strip ( String s ) { return s . replace All ( STRING , STRING ) ; }
public static String strip ( String s ) { return s . replace All ( STRING , STRING ) ; }
public static String strip ( String s ) { return s . replace All ( STRING , STRING ) ; }
public static String strip ( String s ) { return s . replace All ( STRING , STRING ) ; }
@ Override public void trim ( Memory Trim Type trim Type ) { Array List < Entry < K , V > > old Entries ; final double trim Ratio = m Cache Trim Strategy . get Trim Ratio ( trim Type ) ; synchronized ( this ) { int target Cache Size = ( int ) ( m Cached Entries . get Size In Bytes ( ) * ( NUM - trim Ratio ) ) ; int target Eviction Queue Size = Math . max ( NUM , target Cache Size - get In Use Size In Bytes ( ) ) ; old Entries = trim Exclusively Owned Entries ( Integer . MAX VALUE , target Eviction Queue Size ) ; make Orphans ( old Entries ) ; } maybe Close ( old Entries ) ; maybe Notify Exclusive Entry Removal ( old Entries ) ; maybe Update Cache Params ( ) ; maybe Evict Entries ( ) ; }
public Block Swapper ( World world , Entity Player player , Item Stack truncator , Block Pos orig Coords , int range , boolean leaves ) { this . world = world ; this . player = player ; this . truncator = truncator ; this . origin = orig Coords ; this . range = range ; this . treat Leaves Special = leaves ; this . candidate Queue = new Priority Queue < > ( ) ; this . completed Coords = new Hash Set < > ( ) ; candidate Queue . offer ( new Swap Candidate ( this . origin , this . range ) ) ; }
public static double create Double Setting ( final Map < String , String > raw Settings , final String setting Name , final double default Value ) { final String setting String = raw Settings . get ( setting Name ) ; if ( setting String == null ) { return default Value ; } else { try { return Double . parse Double ( setting String ) ; } catch ( final Number Format Exception exception ) { C Utility Functions . log Exception ( exception ) ; return default Value ; } } }
public List < Linear Constraint > normalize Constraints ( Collection < Linear Constraint > original Constraints ) { List < Linear Constraint > normalized = new Array List < Linear Constraint > ( original Constraints . size ( ) ) ; for ( Linear Constraint constraint : original Constraints ) { normalized . add ( normalize ( constraint ) ) ; } return normalized ; }
public List < Linear Constraint > normalize Constraints ( Collection < Linear Constraint > original Constraints ) { List < Linear Constraint > normalized = new Array List < Linear Constraint > ( original Constraints . size ( ) ) ; for ( Linear Constraint constraint : original Constraints ) { normalized . add ( normalize ( constraint ) ) ; } return normalized ; }
private Parsed current Parsed ( ) { return parsed . get ( parsed . size ( ) - NUM ) ; }
@ Override protected String extract Key ( final String name ) { final String key = unescape ( name . substring ( NUM , name . length ( ) - NUM ) ) ; return key . equals ( STRING ) ? null : key ; }
@ Override protected String extract Key ( final String name ) { final String key = unescape ( name . substring ( NUM , name . length ( ) - NUM ) ) ; return key . equals ( STRING ) ? null : key ; }
@ Override protected String extract Key ( final String name ) { final String key = unescape ( name . substring ( NUM , name . length ( ) - NUM ) ) ; return key . equals ( STRING ) ? null : key ; }
private void draw Guide Line ( @ Non Null Canvas canvas ) { float offset = ( float ) ( m Radius / Math . sqrt ( NUM ) ) ; float top Left Point X = m Center Point X - offset ; float top Left Point Y = m Center Point Y - offset ; float top Right Point X = m Center Point X + offset ; float bottom Left Point Y = m Center Point Y + offset ; canvas . draw Line ( top Left Point X , top Left Point Y , top Right Point X , top Left Point Y , m Guide Line Paint ) ; canvas . draw Line ( m Center Point X - m Radius , m Center Point Y , m Center Point X + m Radius , m Center Point Y , m Guide Line Paint ) ; canvas . draw Line ( top Left Point X , bottom Left Point Y , top Right Point X , bottom Left Point Y , m Guide Line Paint ) ; canvas . draw Line ( top Left Point X , top Left Point Y , top Left Point X , bottom Left Point Y , m Guide Line Paint ) ; canvas . draw Line ( m Center Point X , m Center Point Y - m Radius , m Center Point X , m Center Point Y + m Radius , m Guide Line Paint ) ; canvas . draw Line ( top Right Point X , top Left Point Y , top Right Point X , bottom Left Point Y , m Guide Line Paint ) ; }
public void write Timer Report ( XML Writer writer ) { writer . write Open Tag ( STRING ) ; writer . write Open Tag ( STRING , new Attribute . Default < String > ( STRING , STRING ) ) ; writer . write I Dref ( STRING , STRING ) ; writer . write Close Tag ( STRING ) ; writer . write Close Tag ( STRING ) ; }
@ Override default Completable Future < Optional Int > max Int ( final To Int Function < ? super T > fn ) { return Completable Future . supply Async ( null , get Exec ( ) ) ; }
public final static int read Raw Until ( final String Builder out , final String in , final int start , final char end ) { int pos = start ; while ( pos < in . length ( ) ) { final char ch = in . char At ( pos ) ; if ( ch == end ) { break ; } out . append ( ch ) ; pos ++ ; } return ( pos == in . length ( ) ) ? - NUM : pos ; }
public void handle Tbl Supported Container Button Add Request ( Request Invocation Event event ) throws Model Control Exception { try { Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute ( PROPERTY ATTRIBUTE , ( Hash Map ) values ) ; WSPP Service Supported Container Add View Bean vb = ( WSPP Service Supported Container Add View Bean ) get View Bean ( WSPP Service Supported Container Add View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; forward To ( ) ; } }
public void handle Tbl Supported Container Button Add Request ( Request Invocation Event event ) throws Model Control Exception { try { Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute ( PROPERTY ATTRIBUTE , ( Hash Map ) values ) ; WSPP Service Supported Container Add View Bean vb = ( WSPP Service Supported Container Add View Bean ) get View Bean ( WSPP Service Supported Container Add View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; forward To ( ) ; } }
public boolean init ( Step Meta Interface smi , Step Data Interface sdi ) { this . meta = ( ( Sort Key Step Meta ) smi ) ; this . data = ( ( Sort Key Step Data ) sdi ) ; return super . init ( smi , sdi ) ; }
public boolean init ( Step Meta Interface smi , Step Data Interface sdi ) { this . meta = ( ( Sort Key Step Meta ) smi ) ; this . data = ( ( Sort Key Step Data ) sdi ) ; return super . init ( smi , sdi ) ; }
public boolean init ( Step Meta Interface smi , Step Data Interface sdi ) { this . meta = ( ( Sort Key Step Meta ) smi ) ; this . data = ( ( Sort Key Step Data ) sdi ) ; return super . init ( smi , sdi ) ; }
public boolean init ( Step Meta Interface smi , Step Data Interface sdi ) { this . meta = ( ( Sort Key Step Meta ) smi ) ; this . data = ( ( Sort Key Step Data ) sdi ) ; return super . init ( smi , sdi ) ; }
public boolean init ( Step Meta Interface smi , Step Data Interface sdi ) { this . meta = ( ( Sort Key Step Meta ) smi ) ; this . data = ( ( Sort Key Step Data ) sdi ) ; return super . init ( smi , sdi ) ; }
public static List < List < File > > find Java Files Per Directory ( File parent , String ... dir Names ) { List < List < File > > files Per Directory = new Array List < > ( ) ; for ( String dir Name : dir Names ) { File dir = new File ( parent , dir Name ) ; if ( dir . is Directory ( ) ) { files Per Directory . add All ( find Java Test Files In Directory ( dir ) ) ; } } return files Per Directory ; }
public static List < List < File > > find Java Files Per Directory ( File parent , String ... dir Names ) { List < List < File > > files Per Directory = new Array List < > ( ) ; for ( String dir Name : dir Names ) { File dir = new File ( parent , dir Name ) ; if ( dir . is Directory ( ) ) { files Per Directory . add All ( find Java Test Files In Directory ( dir ) ) ; } } return files Per Directory ; }
private Hash Map < String , String > read Config ( String config Path ) throws Exception { log . debug ( STRING + config Path ) ; File config File = new File ( config Path ) ; if ( ! config File . is File ( ) ) return null ; Config Reader reader = new Config Reader ( ) ; reader . read Config ( config Path ) ; return reader . get Config Map ( ) ; }
public void fill Default Values ( ) { tf Activation Probability . set Text ( Double . to String ( PROTOTYPE RESPONDER . get Activation Probability ( ) ) ) ; tf Response Value . set Text ( Double . to String ( PROTOTYPE RESPONDER . get Activation Probability ( ) ) ) ; }
public void fill Default Values ( ) { tf Activation Probability . set Text ( Double . to String ( PROTOTYPE RESPONDER . get Activation Probability ( ) ) ) ; tf Response Value . set Text ( Double . to String ( PROTOTYPE RESPONDER . get Activation Probability ( ) ) ) ; }
protected Date compute ( double value ) { if ( Double . is Na N ( value ) ) { return null ; } long date Long = ( long ) value ; Date date = new Date ( date Long ) ; Calendar cal = Calendar . get Instance ( ) ; cal . set Time ( date ) ; return cal . get Time ( ) ; }
public void roll ( int field , int value ) { boolean increment = value >= NUM ; int count = increment ? value : - value ; for ( int i = NUM ; i < count ; i ++ ) { roll ( field , increment ) ; } }
public Sabres Query ( Class < T > clazz ) { this . clazz = clazz ; name = clazz . get Simple Name ( ) ; inner Queries = null ; }
public Sabres Query ( Class < T > clazz ) { this . clazz = clazz ; name = clazz . get Simple Name ( ) ; inner Queries = null ; }
private void draw Auto Hit ( Graphics g , Coords hex ) { int base X = ( hex . get X ( ) * ( hex Side [ zoom ] + hex Side By Sin 30 [ zoom ] ) ) + left Margin + hex Side [ zoom ] ; int base Y = ( ( ( NUM * hex . get Y ( ) ) + NUM + ( hex . get X ( ) % NUM ) ) * hex Side By Cos 30 [ zoom ] ) + top Margin ; Color alt = g . get Color ( ) ; g . set Color ( Color . RED ) ; g . draw Oval ( base X - ( unit Size - NUM ) , base Y - ( unit Size - NUM ) , ( NUM * unit Size ) - NUM , ( NUM * unit Size ) - NUM ) ; g . draw Line ( base X - unit Size - NUM , base Y , ( base X - unit Size ) + NUM , base Y ) ; g . draw Line ( base X + unit Size + NUM , base Y , ( base X + unit Size ) - NUM , base Y ) ; g . draw Line ( base X , base Y - unit Size - NUM , base X , ( base Y - unit Size ) + NUM ) ; g . draw Line ( base X , base Y + unit Size + NUM , base X , ( base Y + unit Size ) - NUM ) ; g . set Color ( alt ) ; }
private void draw Auto Hit ( Graphics g , Coords hex ) { int base X = ( hex . get X ( ) * ( hex Side [ zoom ] + hex Side By Sin 30 [ zoom ] ) ) + left Margin + hex Side [ zoom ] ; int base Y = ( ( ( NUM * hex . get Y ( ) ) + NUM + ( hex . get X ( ) % NUM ) ) * hex Side By Cos 30 [ zoom ] ) + top Margin ; Color alt = g . get Color ( ) ; g . set Color ( Color . RED ) ; g . draw Oval ( base X - ( unit Size - NUM ) , base Y - ( unit Size - NUM ) , ( NUM * unit Size ) - NUM , ( NUM * unit Size ) - NUM ) ; g . draw Line ( base X - unit Size - NUM , base Y , ( base X - unit Size ) + NUM , base Y ) ; g . draw Line ( base X + unit Size + NUM , base Y , ( base X + unit Size ) - NUM , base Y ) ; g . draw Line ( base X , base Y - unit Size - NUM , base X , ( base Y - unit Size ) + NUM ) ; g . draw Line ( base X , base Y + unit Size + NUM , base X , ( base Y + unit Size ) - NUM ) ; g . set Color ( alt ) ; }
private void add Facility To Hash Map ( Activity Facility Impl facility ) { Id < Link > facility Link = get Closest Link ( facility ) ; assure Hash Map Initialized For Link ( facility Link ) ; Array List < Activity Facility Impl > list = link Facility Mapping . get ( facility Link ) ; list . add ( facility ) ; }
private void add Facility To Hash Map ( Activity Facility Impl facility ) { Id < Link > facility Link = get Closest Link ( facility ) ; assure Hash Map Initialized For Link ( facility Link ) ; Array List < Activity Facility Impl > list = link Facility Mapping . get ( facility Link ) ; list . add ( facility ) ; }
public String to String ( ) { String Buffer result = new String Buffer ( ip Address . to String ( ) ) ; result . append ( STRING ) ; result . append ( extended Network Prefix ) ; return result . to String ( ) ; }
private boolean can Access ( ) { if ( Binder . get Calling Pid ( ) == Process . my Pid ( ) ) { return BOOL ; } else { return Preferences Utils . get Boolean ( get Context ( ) , R . string . allow access key , Preferences Utils . ALLOW ACCESS DEFAULT ) ; } }
private boolean can Access ( ) { if ( Binder . get Calling Pid ( ) == Process . my Pid ( ) ) { return BOOL ; } else { return Preferences Utils . get Boolean ( get Context ( ) , R . string . allow access key , Preferences Utils . ALLOW ACCESS DEFAULT ) ; } }
private static String fix Import Statement ( String import Statement On Demand ) { if ( import Statement On Demand . ends With ( STRING ) ) { return import Statement On Demand . substring ( NUM , import Statement On Demand . length ( ) - NUM ) ; } else { boolean has Classname = String Util . has Upper Case Char ( import Statement On Demand ) ; if ( has Classname ) { int pos = import Statement On Demand . last Index Of ( STRING ) ; return import Statement On Demand . substring ( NUM , pos ) ; } else { return import Statement On Demand ; } } }
private static String fix Import Statement ( String import Statement On Demand ) { if ( import Statement On Demand . ends With ( STRING ) ) { return import Statement On Demand . substring ( NUM , import Statement On Demand . length ( ) - NUM ) ; } else { boolean has Classname = String Util . has Upper Case Char ( import Statement On Demand ) ; if ( has Classname ) { int pos = import Statement On Demand . last Index Of ( STRING ) ; return import Statement On Demand . substring ( NUM , pos ) ; } else { return import Statement On Demand ; } } }
private static String fix Import Statement ( String import Statement On Demand ) { if ( import Statement On Demand . ends With ( STRING ) ) { return import Statement On Demand . substring ( NUM , import Statement On Demand . length ( ) - NUM ) ; } else { boolean has Classname = String Util . has Upper Case Char ( import Statement On Demand ) ; if ( has Classname ) { int pos = import Statement On Demand . last Index Of ( STRING ) ; return import Statement On Demand . substring ( NUM , pos ) ; } else { return import Statement On Demand ; } } }
public static boolean confirm Action ( String i18 n Key , String property Key , Object ... arguments ) { String prop Value = Parameter Service . get Parameter Value ( property Key ) ; if ( prop Value != null ) { if ( prop Value . equals ( VALUE TRUE ) ) { return BOOL ; } else if ( prop Value . equals ( VALUE FALSE ) ) { return BOOL ; } } Decision Remembering Confirm Dialog d = new Decision Remembering Confirm Dialog ( i18 n Key , property Key , Dialog Type . CONFIRM , arguments ) ; d . set Visible ( BOOL ) ; return d . confirmed ; }
public static boolean confirm Action ( String i18 n Key , String property Key , Object ... arguments ) { String prop Value = Parameter Service . get Parameter Value ( property Key ) ; if ( prop Value != null ) { if ( prop Value . equals ( VALUE TRUE ) ) { return BOOL ; } else if ( prop Value . equals ( VALUE FALSE ) ) { return BOOL ; } } Decision Remembering Confirm Dialog d = new Decision Remembering Confirm Dialog ( i18 n Key , property Key , Dialog Type . CONFIRM , arguments ) ; d . set Visible ( BOOL ) ; return d . confirmed ; }
public static boolean confirm Action ( String i18 n Key , String property Key , Object ... arguments ) { String prop Value = Parameter Service . get Parameter Value ( property Key ) ; if ( prop Value != null ) { if ( prop Value . equals ( VALUE TRUE ) ) { return BOOL ; } else if ( prop Value . equals ( VALUE FALSE ) ) { return BOOL ; } } Decision Remembering Confirm Dialog d = new Decision Remembering Confirm Dialog ( i18 n Key , property Key , Dialog Type . CONFIRM , arguments ) ; d . set Visible ( BOOL ) ; return d . confirmed ; }
private boolean remove ( final int row , final int col Index ) { boolean copied = BOOL ; final int last Index = this . max Indices [ row ] - NUM ; if ( last Index > NUM && last Index != col Index ) { System . arraycopy ( this . cols [ row ] , col Index + NUM , this . cols [ row ] , col Index , last Index - col Index ) ; System . arraycopy ( this . values [ row ] , col Index + NUM , this . values [ row ] , col Index , last Index - col Index ) ; copied = BOOL ; } if ( last Index >= NUM ) { this . cols [ row ] [ last Index ] = NUM ; this . values [ row ] [ last Index ] = NUM ; } -- this . max Indices [ row ] ; return copied ; }
private boolean remove ( final int row , final int col Index ) { boolean copied = BOOL ; final int last Index = this . max Indices [ row ] - NUM ; if ( last Index > NUM && last Index != col Index ) { System . arraycopy ( this . cols [ row ] , col Index + NUM , this . cols [ row ] , col Index , last Index - col Index ) ; System . arraycopy ( this . values [ row ] , col Index + NUM , this . values [ row ] , col Index , last Index - col Index ) ; copied = BOOL ; } if ( last Index >= NUM ) { this . cols [ row ] [ last Index ] = NUM ; this . values [ row ] [ last Index ] = NUM ; } -- this . max Indices [ row ] ; return copied ; }
@ Override public double cos ( int step ) { step = Math . abs ( step ) % steps ; if ( step < costable . length ) { return costable [ step ] ; } if ( step > halfsteps ) { step = steps - step ; if ( step < costable . length ) { return costable [ step ] ; } } step = halfsteps - step ; return - costable [ step ] ; }
@ Override public double cos ( int step ) { step = Math . abs ( step ) % steps ; if ( step < costable . length ) { return costable [ step ] ; } if ( step > halfsteps ) { step = steps - step ; if ( step < costable . length ) { return costable [ step ] ; } } step = halfsteps - step ; return - costable [ step ] ; }
public void add ( Event Bean the Event ) { if ( the Event == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( first Event == null ) { first Event = the Event ; return ; } if ( additional Events == null ) { additional Events = new Array Deque < Event Bean > ( ) ; } additional Events . add ( the Event ) ; }
public void create ROC Plot Dialog ( ROC Data data ) { ROC Chart Plotter plotter = new ROC Chart Plotter ( ) ; plotter . add ROC Data ( STRING , data ) ; J Dialog dialog = new J Dialog ( ) ; dialog . set Title ( STRING ) ; dialog . add ( plotter ) ; dialog . set Size ( NUM , NUM ) ; dialog . set Location Relative To ( null ) ; dialog . set Visible ( BOOL ) ; }
public void create ROC Plot Dialog ( ROC Data data ) { ROC Chart Plotter plotter = new ROC Chart Plotter ( ) ; plotter . add ROC Data ( STRING , data ) ; J Dialog dialog = new J Dialog ( ) ; dialog . set Title ( STRING ) ; dialog . add ( plotter ) ; dialog . set Size ( NUM , NUM ) ; dialog . set Location Relative To ( null ) ; dialog . set Visible ( BOOL ) ; }
public void create ROC Plot Dialog ( ROC Data data ) { ROC Chart Plotter plotter = new ROC Chart Plotter ( ) ; plotter . add ROC Data ( STRING , data ) ; J Dialog dialog = new J Dialog ( ) ; dialog . set Title ( STRING ) ; dialog . add ( plotter ) ; dialog . set Size ( NUM , NUM ) ; dialog . set Location Relative To ( null ) ; dialog . set Visible ( BOOL ) ; }
@ Override public synchronized boolean add ( E object ) { if ( element Count == element Data . length ) { grow By One ( ) ; } element Data [ element Count ++ ] = object ; mod Count ++ ; return BOOL ; }
@ Override public synchronized boolean add ( E object ) { if ( element Count == element Data . length ) { grow By One ( ) ; } element Data [ element Count ++ ] = object ; mod Count ++ ; return BOOL ; }
private void write Flow Pair ( Flow Pair pair , Document document , Element parent Element ) { Element flow Pair = document . create Element ( STRING ) ; parent Element . append Child ( flow Pair ) ; write Domain Spec ( pair . get First Domain ( ) , document , flow Pair ) ; write Domain Spec ( pair . get Second Domain ( ) , document , flow Pair ) ; }
public String create Random Bytes ( int byte Num ) { byte [ ] secret Bytes = new byte [ byte Num ] ; secure Random . next Bytes ( secret Bytes ) ; return Base 64 . encode ( secret Bytes ) ; }
public String create Random Bytes ( int byte Num ) { byte [ ] secret Bytes = new byte [ byte Num ] ; secure Random . next Bytes ( secret Bytes ) ; return Base 64 . encode ( secret Bytes ) ; }
public void write Exif ( byte [ ] jpeg , String exif Out File Name ) throws File Not Found Exception , IO Exception { if ( jpeg == null || exif Out File Name == null ) { throw new Illegal Argument Exception ( NULL ARGUMENT STRING ) ; } Output Stream s = null ; s = get Exif Writer Stream ( exif Out File Name ) ; s . write ( jpeg , NUM , jpeg . length ) ; s . flush ( ) ; s . close ( ) ; }
public void write Exif ( byte [ ] jpeg , String exif Out File Name ) throws File Not Found Exception , IO Exception { if ( jpeg == null || exif Out File Name == null ) { throw new Illegal Argument Exception ( NULL ARGUMENT STRING ) ; } Output Stream s = null ; s = get Exif Writer Stream ( exif Out File Name ) ; s . write ( jpeg , NUM , jpeg . length ) ; s . flush ( ) ; s . close ( ) ; }
public void write Exif ( byte [ ] jpeg , String exif Out File Name ) throws File Not Found Exception , IO Exception { if ( jpeg == null || exif Out File Name == null ) { throw new Illegal Argument Exception ( NULL ARGUMENT STRING ) ; } Output Stream s = null ; s = get Exif Writer Stream ( exif Out File Name ) ; s . write ( jpeg , NUM , jpeg . length ) ; s . flush ( ) ; s . close ( ) ; }
public void write Int ( int value ) throws IO Exception { check Write Primitive Types ( ) ; primitive Types . write Int ( value ) ; }
public void test Value Of Double Neg ( ) { double a = - NUM ; Big Decimal result = Big Decimal . value Of ( a ) ; String res = STRING ; int res Scale = NUM ; assert Equals ( STRING , res , result . to String ( ) ) ; assert Equals ( STRING , res Scale , result . scale ( ) ) ; }
private void walk Parse Tree ( List < Swift Base Listener > listeners , Top Level Context tree ) { Parse Tree Walker walker = new Parse Tree Walker ( ) ; listeners . for Each ( null ) ; }
public static byte check Range ( Object value , Comparable < Object > min Limit , Comparable < Object > max Limit ) { byte ret Val = RC WITHIN RANGE ; if ( min Limit != null && min Limit . compare To ( value ) > NUM ) ret Val |= RC BELOW RANGE ; if ( max Limit != null && max Limit . compare To ( value ) < NUM ) ret Val |= RC ABOVE RANGE ; return ( ret Val ) ; }
@ Override public String to String ( ) { synchronized ( lock ) { return buf . to String ( ) ; } }
public void insert Update ( Document Event changes , Shape a , View Factory f ) { update Children ( changes , a ) ; Rectangle alloc = ( ( a != null ) && is Allocation Valid ( ) ) ? get Inside Allocation ( a ) : null ; int pos = changes . get Offset ( ) ; View v = get View At Position ( pos , alloc ) ; if ( v != null ) v . insert Update ( changes , alloc , f ) ; }
public void insert Update ( Document Event changes , Shape a , View Factory f ) { update Children ( changes , a ) ; Rectangle alloc = ( ( a != null ) && is Allocation Valid ( ) ) ? get Inside Allocation ( a ) : null ; int pos = changes . get Offset ( ) ; View v = get View At Position ( pos , alloc ) ; if ( v != null ) v . insert Update ( changes , alloc , f ) ; }
public void insert Update ( Document Event changes , Shape a , View Factory f ) { update Children ( changes , a ) ; Rectangle alloc = ( ( a != null ) && is Allocation Valid ( ) ) ? get Inside Allocation ( a ) : null ; int pos = changes . get Offset ( ) ; View v = get View At Position ( pos , alloc ) ; if ( v != null ) v . insert Update ( changes , alloc , f ) ; }
public void insert Update ( Document Event changes , Shape a , View Factory f ) { update Children ( changes , a ) ; Rectangle alloc = ( ( a != null ) && is Allocation Valid ( ) ) ? get Inside Allocation ( a ) : null ; int pos = changes . get Offset ( ) ; View v = get View At Position ( pos , alloc ) ; if ( v != null ) v . insert Update ( changes , alloc , f ) ; }
private void remove Cabooses And Cars With Fred And Save Final Destination ( ) throws Build Failed Exception { add Line ( build Report , SEVEN , BLANK LINE ) ; add Line ( build Report , SEVEN , Bundle . get Message ( STRING ) ) ; for ( car Index = NUM ; car Index < car List . size ( ) ; car Index ++ ) { Car car = car List . get ( car Index ) ; if ( car . is Caboose ( ) || car . has Fred ( ) ) { add Line ( build Report , SEVEN , Message Format . format ( Bundle . get Message ( STRING ) , new Object [ ] { car . to String ( ) , car . get Type Name ( ) , ( car . get Location Name ( ) + STRING + car . get Track Name ( ) ) } ) ) ; if ( car . get Track ( ) == depart Stage Track ) { throw new Build Failed Exception ( STRING ) ; } car List . remove ( car ) ; car Index -- ; } car . set Previous Final Destination ( car . get Final Destination ( ) ) ; car . set Previous Final Destination Track ( car . get Final Destination Track ( ) ) ; car . set Previous Schedule Id ( car . get Schedule Item Id ( ) ) ; } }
private void remove Cabooses And Cars With Fred And Save Final Destination ( ) throws Build Failed Exception { add Line ( build Report , SEVEN , BLANK LINE ) ; add Line ( build Report , SEVEN , Bundle . get Message ( STRING ) ) ; for ( car Index = NUM ; car Index < car List . size ( ) ; car Index ++ ) { Car car = car List . get ( car Index ) ; if ( car . is Caboose ( ) || car . has Fred ( ) ) { add Line ( build Report , SEVEN , Message Format . format ( Bundle . get Message ( STRING ) , new Object [ ] { car . to String ( ) , car . get Type Name ( ) , ( car . get Location Name ( ) + STRING + car . get Track Name ( ) ) } ) ) ; if ( car . get Track ( ) == depart Stage Track ) { throw new Build Failed Exception ( STRING ) ; } car List . remove ( car ) ; car Index -- ; } car . set Previous Final Destination ( car . get Final Destination ( ) ) ; car . set Previous Final Destination Track ( car . get Final Destination Track ( ) ) ; car . set Previous Schedule Id ( car . get Schedule Item Id ( ) ) ; } }
private void remove Cabooses And Cars With Fred And Save Final Destination ( ) throws Build Failed Exception { add Line ( build Report , SEVEN , BLANK LINE ) ; add Line ( build Report , SEVEN , Bundle . get Message ( STRING ) ) ; for ( car Index = NUM ; car Index < car List . size ( ) ; car Index ++ ) { Car car = car List . get ( car Index ) ; if ( car . is Caboose ( ) || car . has Fred ( ) ) { add Line ( build Report , SEVEN , Message Format . format ( Bundle . get Message ( STRING ) , new Object [ ] { car . to String ( ) , car . get Type Name ( ) , ( car . get Location Name ( ) + STRING + car . get Track Name ( ) ) } ) ) ; if ( car . get Track ( ) == depart Stage Track ) { throw new Build Failed Exception ( STRING ) ; } car List . remove ( car ) ; car Index -- ; } car . set Previous Final Destination ( car . get Final Destination ( ) ) ; car . set Previous Final Destination Track ( car . get Final Destination Track ( ) ) ; car . set Previous Schedule Id ( car . get Schedule Item Id ( ) ) ; } }
private boolean safe Equals ( Object o1 , Object o2 ) { if ( o1 == null && o2 == null ) return BOOL ; if ( o1 == null ) return BOOL ; if ( o2 == null ) return BOOL ; return o1 . equals ( o2 ) ; }
public void reset ( ) { System . arraycopy ( COLOR SCHEME . m Default Colors , NUM , m Current Colors , NUM , Text Style . NUM INDEXED COLORS ) ; }
public void reset ( ) { System . arraycopy ( COLOR SCHEME . m Default Colors , NUM , m Current Colors , NUM , Text Style . NUM INDEXED COLORS ) ; }
protected Boolean compute ( double value ) { if ( Double . is Na N ( value ) ) { return BOOL ; } else { return BOOL ; } }
@ Override public void write ( byte [ ] buf , int offset , int length , boolean is End ) throws IO Exception { while ( length > NUM ) { if ( tail == null ) { add Buffer ( Temp Buffer . create ( ) ) ; } else if ( tail . buffer ( ) . length <= tail . length ( ) ) { add Buffer ( Temp Buffer . create ( ) ) ; } Temp Buffer tail = tail ; int sublen = Math . min ( length , tail . buffer ( ) . length - tail . length ( ) ) ; System . arraycopy ( buf , offset , tail . buffer ( ) , tail . length ( ) , sublen ) ; length -= sublen ; offset += sublen ; tail . length ( tail . length ( ) + sublen ) ; } }
public static boolean is Windows Nt 4 ( ) { return os Name . index Of ( STRING ) > - NUM && os Version . equals ( STRING ) ; }
public static boolean is Windows Nt 4 ( ) { return os Name . index Of ( STRING ) > - NUM && os Version . equals ( STRING ) ; }
private void compute Duration ( ) { duration = System . current Time Millis ( ) - start ; total duration += duration ; }
public Bloom Filter ( double false Positive Probability , int expected Number Of Elements ) { this ( Math . ceil ( - ( Math . log ( false Positive Probability ) / Math . log ( NUM ) ) ) / Math . log ( NUM ) , expected Number Of Elements , ( int ) Math . ceil ( - ( Math . log ( false Positive Probability ) / Math . log ( NUM ) ) ) ) ; }
public Bloom Filter ( double false Positive Probability , int expected Number Of Elements ) { this ( Math . ceil ( - ( Math . log ( false Positive Probability ) / Math . log ( NUM ) ) ) / Math . log ( NUM ) , expected Number Of Elements , ( int ) Math . ceil ( - ( Math . log ( false Positive Probability ) / Math . log ( NUM ) ) ) ) ; }
public void exit ( ) { shutting Down = BOOL ; save Settings ( BOOL ) ; log All Viewerstats ( ) ; c . disconnect ( ) ; franker Face Z . disconnect Ws ( ) ; pubsub . disconnect ( ) ; g . clean Up ( ) ; chat Log . close ( ) ; System . exit ( NUM ) ; }
private static byte [ ] read Bytes ( final Client Reader input Stream , final int length ) throws IO Exception { final Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; final byte [ ] data = new byte [ length ] ; int read = NUM ; while ( read < length ) { final int retval = input Stream . read ( data , NUM , length - read ) ; baos . write ( data , NUM , retval ) ; read += retval ; } return baos . to Byte Array ( ) ; }
public void test Moment With Invalid Type Error Handling ( ) { String xml = STRING ; xml += create Start Mission Xml ( STRING , STRING ) ; xml += create Start Moment Xml ( STRING , STRING ) ; xml += create Next Moment Xml ( STRING ) ; xml += create Length Minutes Xml ( NUM ) ; xml += create End Moment Xml ( ) ; xml += create End Mission Xml ( ) ; Input Stream moment Input Stream = new Byte Array Input Stream ( xml . get Bytes ( ) ) ; m Mission = new Mission ( m Mission Data ) ; boolean did Mission Parse Fail = BOOL ; try { m Mission . read Moments ( moment Input Stream ) ; } catch ( Mission Parse Exception e ) { did Mission Parse Fail = BOOL ; } Assert . assert Equals ( BOOL , did Mission Parse Fail ) ; }
public void test Moment With Invalid Type Error Handling ( ) { String xml = STRING ; xml += create Start Mission Xml ( STRING , STRING ) ; xml += create Start Moment Xml ( STRING , STRING ) ; xml += create Next Moment Xml ( STRING ) ; xml += create Length Minutes Xml ( NUM ) ; xml += create End Moment Xml ( ) ; xml += create End Mission Xml ( ) ; Input Stream moment Input Stream = new Byte Array Input Stream ( xml . get Bytes ( ) ) ; m Mission = new Mission ( m Mission Data ) ; boolean did Mission Parse Fail = BOOL ; try { m Mission . read Moments ( moment Input Stream ) ; } catch ( Mission Parse Exception e ) { did Mission Parse Fail = BOOL ; } Assert . assert Equals ( BOOL , did Mission Parse Fail ) ; }
public void test Moment With Invalid Type Error Handling ( ) { String xml = STRING ; xml += create Start Mission Xml ( STRING , STRING ) ; xml += create Start Moment Xml ( STRING , STRING ) ; xml += create Next Moment Xml ( STRING ) ; xml += create Length Minutes Xml ( NUM ) ; xml += create End Moment Xml ( ) ; xml += create End Mission Xml ( ) ; Input Stream moment Input Stream = new Byte Array Input Stream ( xml . get Bytes ( ) ) ; m Mission = new Mission ( m Mission Data ) ; boolean did Mission Parse Fail = BOOL ; try { m Mission . read Moments ( moment Input Stream ) ; } catch ( Mission Parse Exception e ) { did Mission Parse Fail = BOOL ; } Assert . assert Equals ( BOOL , did Mission Parse Fail ) ; }
private void add Task To NPC ( final int idx ) { final String state = points . get ( idx ) ; final Speaker NPC npc = npcs . get ( state ) ; npc . add ( Conversation States . ATTENDING , Arrays . as List ( STRING , STRING , STRING ) , new System Property Condition ( STRING ) , Conversation States . ATTENDING , null , new Paper Chase Point ( idx ) ) ; if ( NPC IDLE . contains ( state ) ) { npc . add ( Conversation States . ANY , Arrays . as List ( STRING , STRING , STRING ) , new System Property Condition ( STRING ) , Conversation States . ANY , null , new Paper Chase Point ( idx ) ) ; } }
private void add Task To NPC ( final int idx ) { final String state = points . get ( idx ) ; final Speaker NPC npc = npcs . get ( state ) ; npc . add ( Conversation States . ATTENDING , Arrays . as List ( STRING , STRING , STRING ) , new System Property Condition ( STRING ) , Conversation States . ATTENDING , null , new Paper Chase Point ( idx ) ) ; if ( NPC IDLE . contains ( state ) ) { npc . add ( Conversation States . ANY , Arrays . as List ( STRING , STRING , STRING ) , new System Property Condition ( STRING ) , Conversation States . ANY , null , new Paper Chase Point ( idx ) ) ; } }
private void add Task To NPC ( final int idx ) { final String state = points . get ( idx ) ; final Speaker NPC npc = npcs . get ( state ) ; npc . add ( Conversation States . ATTENDING , Arrays . as List ( STRING , STRING , STRING ) , new System Property Condition ( STRING ) , Conversation States . ATTENDING , null , new Paper Chase Point ( idx ) ) ; if ( NPC IDLE . contains ( state ) ) { npc . add ( Conversation States . ANY , Arrays . as List ( STRING , STRING , STRING ) , new System Property Condition ( STRING ) , Conversation States . ANY , null , new Paper Chase Point ( idx ) ) ; } }
private void insert COM Marker Segment ( COM Marker Segment new Guy ) { int last COM = find Marker Segment Position ( COM Marker Segment . class , BOOL ) ; boolean has JFIF = ( find Marker Segment ( JFIF Marker Segment . class , BOOL ) != null ) ; int first Adobe = find Marker Segment Position ( Adobe Marker Segment . class , BOOL ) ; if ( last COM != - NUM ) { marker Sequence . add ( last COM + NUM , new Guy ) ; } else if ( has JFIF ) { marker Sequence . add ( NUM , new Guy ) ; } else if ( first Adobe != - NUM ) { marker Sequence . add ( first Adobe + NUM , new Guy ) ; } else { marker Sequence . add ( NUM , new Guy ) ; } }
private void insert COM Marker Segment ( COM Marker Segment new Guy ) { int last COM = find Marker Segment Position ( COM Marker Segment . class , BOOL ) ; boolean has JFIF = ( find Marker Segment ( JFIF Marker Segment . class , BOOL ) != null ) ; int first Adobe = find Marker Segment Position ( Adobe Marker Segment . class , BOOL ) ; if ( last COM != - NUM ) { marker Sequence . add ( last COM + NUM , new Guy ) ; } else if ( has JFIF ) { marker Sequence . add ( NUM , new Guy ) ; } else if ( first Adobe != - NUM ) { marker Sequence . add ( first Adobe + NUM , new Guy ) ; } else { marker Sequence . add ( NUM , new Guy ) ; } }
private void insert COM Marker Segment ( COM Marker Segment new Guy ) { int last COM = find Marker Segment Position ( COM Marker Segment . class , BOOL ) ; boolean has JFIF = ( find Marker Segment ( JFIF Marker Segment . class , BOOL ) != null ) ; int first Adobe = find Marker Segment Position ( Adobe Marker Segment . class , BOOL ) ; if ( last COM != - NUM ) { marker Sequence . add ( last COM + NUM , new Guy ) ; } else if ( has JFIF ) { marker Sequence . add ( NUM , new Guy ) ; } else if ( first Adobe != - NUM ) { marker Sequence . add ( first Adobe + NUM , new Guy ) ; } else { marker Sequence . add ( NUM , new Guy ) ; } }
private void insert COM Marker Segment ( COM Marker Segment new Guy ) { int last COM = find Marker Segment Position ( COM Marker Segment . class , BOOL ) ; boolean has JFIF = ( find Marker Segment ( JFIF Marker Segment . class , BOOL ) != null ) ; int first Adobe = find Marker Segment Position ( Adobe Marker Segment . class , BOOL ) ; if ( last COM != - NUM ) { marker Sequence . add ( last COM + NUM , new Guy ) ; } else if ( has JFIF ) { marker Sequence . add ( NUM , new Guy ) ; } else if ( first Adobe != - NUM ) { marker Sequence . add ( first Adobe + NUM , new Guy ) ; } else { marker Sequence . add ( NUM , new Guy ) ; } }
private void insert COM Marker Segment ( COM Marker Segment new Guy ) { int last COM = find Marker Segment Position ( COM Marker Segment . class , BOOL ) ; boolean has JFIF = ( find Marker Segment ( JFIF Marker Segment . class , BOOL ) != null ) ; int first Adobe = find Marker Segment Position ( Adobe Marker Segment . class , BOOL ) ; if ( last COM != - NUM ) { marker Sequence . add ( last COM + NUM , new Guy ) ; } else if ( has JFIF ) { marker Sequence . add ( NUM , new Guy ) ; } else if ( first Adobe != - NUM ) { marker Sequence . add ( first Adobe + NUM , new Guy ) ; } else { marker Sequence . add ( NUM , new Guy ) ; } }
private void insert COM Marker Segment ( COM Marker Segment new Guy ) { int last COM = find Marker Segment Position ( COM Marker Segment . class , BOOL ) ; boolean has JFIF = ( find Marker Segment ( JFIF Marker Segment . class , BOOL ) != null ) ; int first Adobe = find Marker Segment Position ( Adobe Marker Segment . class , BOOL ) ; if ( last COM != - NUM ) { marker Sequence . add ( last COM + NUM , new Guy ) ; } else if ( has JFIF ) { marker Sequence . add ( NUM , new Guy ) ; } else if ( first Adobe != - NUM ) { marker Sequence . add ( first Adobe + NUM , new Guy ) ; } else { marker Sequence . add ( NUM , new Guy ) ; } }
private Input Stream Reader create Reader ( Input Stream is , String encoding ) throws Unsupported Encoding Exception { Input Stream Reader r ; if ( encoding != null ) { r = new Input Stream Reader ( is , encoding ) ; } else { r = new Input Stream Reader ( is ) ; } return r ; }
protected Action Argument Value [ ] read Argument Values ( Node List node List , Action Argument [ ] args ) throws Action Exception { List < Node > nodes = get Matching Nodes ( node List , args ) ; Action Argument Value [ ] values = new Action Argument Value [ args . length ] ; for ( int i = NUM ; i < args . length ; i ++ ) { Action Argument arg = args [ i ] ; Node node = find Action Argument Node ( nodes , arg ) ; if ( node == null ) { throw new Action Exception ( Error Code . ARGUMENT VALUE INVALID , STRING + arg . get Name ( ) + STRING ) ; } log . fine ( STRING + arg . get Name ( ) ) ; String value = XML Util . get Text Content ( node ) ; values [ i ] = create Value ( arg , value ) ; } return values ; }
public synchronized void remove ( I Audio Provider provider ) { providers . remove ( provider ) ; }
public void sort ( ) { throw If Immutable ( ) ; if ( ! sorted ) { Arrays . sort ( values , NUM , size ) ; sorted = BOOL ; } }
public void sort ( ) { throw If Immutable ( ) ; if ( ! sorted ) { Arrays . sort ( values , NUM , size ) ; sorted = BOOL ; } }
public String ncg Summary Str ( ) { if ( ncg . home Score > ncg . away Score ) { return ncg . home Team . name + STRING + ncg . home Team . wins + STRING + ncg . home Team . losses + STRING + STRING + ncg . away Team . name + STRING + ncg . away Team . wins + STRING + ncg . away Team . losses + STRING + ncg . home Score + STRING + ncg . away Score + STRING ; } else { return ncg . away Team . name + STRING + ncg . away Team . wins + STRING + ncg . away Team . losses + STRING + STRING + ncg . home Team . name + STRING + ncg . home Team . wins + STRING + ncg . home Team . losses + STRING + ncg . away Score + STRING + ncg . home Score + STRING ; } }
public String ncg Summary Str ( ) { if ( ncg . home Score > ncg . away Score ) { return ncg . home Team . name + STRING + ncg . home Team . wins + STRING + ncg . home Team . losses + STRING + STRING + ncg . away Team . name + STRING + ncg . away Team . wins + STRING + ncg . away Team . losses + STRING + ncg . home Score + STRING + ncg . away Score + STRING ; } else { return ncg . away Team . name + STRING + ncg . away Team . wins + STRING + ncg . away Team . losses + STRING + STRING + ncg . home Team . name + STRING + ncg . home Team . wins + STRING + ncg . home Team . losses + STRING + ncg . away Score + STRING + ncg . home Score + STRING ; } }
public static String Buffer replace Str Str ( final String Buffer string , final String old Pattern , final String new Pattern ) { if ( ( string == null ) || ( old Pattern == null ) || old Pattern . equals ( STRING ) || ( new Pattern == null ) ) { return string ; } final String Buffer replaced = new String Buffer ( ) ; int start Idx = NUM ; int idx Old ; while ( ( idx Old = string . index Of ( old Pattern , start Idx ) ) >= NUM ) { replaced . append ( string . substring ( start Idx , idx Old ) ) ; replaced . append ( new Pattern ) ; start Idx = idx Old + old Pattern . length ( ) ; } replaced . append ( string . substring ( start Idx ) ) ; return replaced ; }
public static String Buffer replace Str Str ( final String Buffer string , final String old Pattern , final String new Pattern ) { if ( ( string == null ) || ( old Pattern == null ) || old Pattern . equals ( STRING ) || ( new Pattern == null ) ) { return string ; } final String Buffer replaced = new String Buffer ( ) ; int start Idx = NUM ; int idx Old ; while ( ( idx Old = string . index Of ( old Pattern , start Idx ) ) >= NUM ) { replaced . append ( string . substring ( start Idx , idx Old ) ) ; replaced . append ( new Pattern ) ; start Idx = idx Old + old Pattern . length ( ) ; } replaced . append ( string . substring ( start Idx ) ) ; return replaced ; }
public static String Buffer replace Str Str ( final String Buffer string , final String old Pattern , final String new Pattern ) { if ( ( string == null ) || ( old Pattern == null ) || old Pattern . equals ( STRING ) || ( new Pattern == null ) ) { return string ; } final String Buffer replaced = new String Buffer ( ) ; int start Idx = NUM ; int idx Old ; while ( ( idx Old = string . index Of ( old Pattern , start Idx ) ) >= NUM ) { replaced . append ( string . substring ( start Idx , idx Old ) ) ; replaced . append ( new Pattern ) ; start Idx = idx Old + old Pattern . length ( ) ; } replaced . append ( string . substring ( start Idx ) ) ; return replaced ; }
public static String Buffer replace Str Str ( final String Buffer string , final String old Pattern , final String new Pattern ) { if ( ( string == null ) || ( old Pattern == null ) || old Pattern . equals ( STRING ) || ( new Pattern == null ) ) { return string ; } final String Buffer replaced = new String Buffer ( ) ; int start Idx = NUM ; int idx Old ; while ( ( idx Old = string . index Of ( old Pattern , start Idx ) ) >= NUM ) { replaced . append ( string . substring ( start Idx , idx Old ) ) ; replaced . append ( new Pattern ) ; start Idx = idx Old + old Pattern . length ( ) ; } replaced . append ( string . substring ( start Idx ) ) ; return replaced ; }
public void apply Pattern ( String pattern ) { this . pattern = pattern ; if ( pattern Tokens != null ) { pattern Tokens . clear ( ) ; pattern Tokens = null ; } }
public Timestamp recalculate Estimated Completion Date ( Long priority , Timestamp start Date ) { if ( exist ( ) ) { get Production Run Routing Tasks ( ) ; if ( quantity == null ) get Quantity ( ) ; Timestamp end Date = null ; for ( Iterator < Generic Value > iter = production Run Routing Tasks . iterator ( ) ; iter . has Next ( ) ; ) { Generic Value routing Task = iter . next ( ) ; if ( priority . compare To ( routing Task . get Long ( STRING ) ) <= NUM ) { long total Time = Production Run . get Estimated Task Time ( routing Task , quantity , dispatcher ) ; end Date = Tech Data Services . add Forward ( Tech Data Services . get Tech Data Calendar ( routing Task ) , start Date , total Time ) ; routing Task . set ( STRING , start Date ) ; routing Task . set ( STRING , end Date ) ; start Date = end Date ; } } return end Date ; } else { return null ; } }
public Timestamp recalculate Estimated Completion Date ( Long priority , Timestamp start Date ) { if ( exist ( ) ) { get Production Run Routing Tasks ( ) ; if ( quantity == null ) get Quantity ( ) ; Timestamp end Date = null ; for ( Iterator < Generic Value > iter = production Run Routing Tasks . iterator ( ) ; iter . has Next ( ) ; ) { Generic Value routing Task = iter . next ( ) ; if ( priority . compare To ( routing Task . get Long ( STRING ) ) <= NUM ) { long total Time = Production Run . get Estimated Task Time ( routing Task , quantity , dispatcher ) ; end Date = Tech Data Services . add Forward ( Tech Data Services . get Tech Data Calendar ( routing Task ) , start Date , total Time ) ; routing Task . set ( STRING , start Date ) ; routing Task . set ( STRING , end Date ) ; start Date = end Date ; } } return end Date ; } else { return null ; } }
public Timestamp recalculate Estimated Completion Date ( Long priority , Timestamp start Date ) { if ( exist ( ) ) { get Production Run Routing Tasks ( ) ; if ( quantity == null ) get Quantity ( ) ; Timestamp end Date = null ; for ( Iterator < Generic Value > iter = production Run Routing Tasks . iterator ( ) ; iter . has Next ( ) ; ) { Generic Value routing Task = iter . next ( ) ; if ( priority . compare To ( routing Task . get Long ( STRING ) ) <= NUM ) { long total Time = Production Run . get Estimated Task Time ( routing Task , quantity , dispatcher ) ; end Date = Tech Data Services . add Forward ( Tech Data Services . get Tech Data Calendar ( routing Task ) , start Date , total Time ) ; routing Task . set ( STRING , start Date ) ; routing Task . set ( STRING , end Date ) ; start Date = end Date ; } } return end Date ; } else { return null ; } }
public Timestamp recalculate Estimated Completion Date ( Long priority , Timestamp start Date ) { if ( exist ( ) ) { get Production Run Routing Tasks ( ) ; if ( quantity == null ) get Quantity ( ) ; Timestamp end Date = null ; for ( Iterator < Generic Value > iter = production Run Routing Tasks . iterator ( ) ; iter . has Next ( ) ; ) { Generic Value routing Task = iter . next ( ) ; if ( priority . compare To ( routing Task . get Long ( STRING ) ) <= NUM ) { long total Time = Production Run . get Estimated Task Time ( routing Task , quantity , dispatcher ) ; end Date = Tech Data Services . add Forward ( Tech Data Services . get Tech Data Calendar ( routing Task ) , start Date , total Time ) ; routing Task . set ( STRING , start Date ) ; routing Task . set ( STRING , end Date ) ; start Date = end Date ; } } return end Date ; } else { return null ; } }
public Timestamp recalculate Estimated Completion Date ( Long priority , Timestamp start Date ) { if ( exist ( ) ) { get Production Run Routing Tasks ( ) ; if ( quantity == null ) get Quantity ( ) ; Timestamp end Date = null ; for ( Iterator < Generic Value > iter = production Run Routing Tasks . iterator ( ) ; iter . has Next ( ) ; ) { Generic Value routing Task = iter . next ( ) ; if ( priority . compare To ( routing Task . get Long ( STRING ) ) <= NUM ) { long total Time = Production Run . get Estimated Task Time ( routing Task , quantity , dispatcher ) ; end Date = Tech Data Services . add Forward ( Tech Data Services . get Tech Data Calendar ( routing Task ) , start Date , total Time ) ; routing Task . set ( STRING , start Date ) ; routing Task . set ( STRING , end Date ) ; start Date = end Date ; } } return end Date ; } else { return null ; } }
public Timestamp recalculate Estimated Completion Date ( Long priority , Timestamp start Date ) { if ( exist ( ) ) { get Production Run Routing Tasks ( ) ; if ( quantity == null ) get Quantity ( ) ; Timestamp end Date = null ; for ( Iterator < Generic Value > iter = production Run Routing Tasks . iterator ( ) ; iter . has Next ( ) ; ) { Generic Value routing Task = iter . next ( ) ; if ( priority . compare To ( routing Task . get Long ( STRING ) ) <= NUM ) { long total Time = Production Run . get Estimated Task Time ( routing Task , quantity , dispatcher ) ; end Date = Tech Data Services . add Forward ( Tech Data Services . get Tech Data Calendar ( routing Task ) , start Date , total Time ) ; routing Task . set ( STRING , start Date ) ; routing Task . set ( STRING , end Date ) ; start Date = end Date ; } } return end Date ; } else { return null ; } }
public void close ( ) throws java . io . IO Exception { flush Buffer ( ) ; m os . close ( ) ; }
public void close ( ) throws java . io . IO Exception { flush Buffer ( ) ; m os . close ( ) ; }
public void close ( ) throws java . io . IO Exception { flush Buffer ( ) ; m os . close ( ) ; }
public void close ( ) throws java . io . IO Exception { flush Buffer ( ) ; m os . close ( ) ; }
public void close ( ) throws java . io . IO Exception { flush Buffer ( ) ; m os . close ( ) ; }
public void close ( ) throws java . io . IO Exception { flush Buffer ( ) ; m os . close ( ) ; }
default Literal to Literal ( final Object value ) { final Value Factory vf = Defaults . VF ; if ( value instanceof Float ) { return vf . create Literal ( ( Float ) value ) ; } else if ( value instanceof Double ) { return vf . create Literal ( ( Double ) value ) ; } else if ( value instanceof Integer ) { return vf . create Literal ( ( Integer ) value ) ; } else if ( value instanceof Long ) { return vf . create Literal ( ( Long ) value ) ; } else if ( value instanceof Boolean ) { return vf . create Literal ( ( Boolean ) value ) ; } else if ( value instanceof Short ) { return vf . create Literal ( ( Short ) value ) ; } else if ( value instanceof Byte ) { return vf . create Literal ( ( Byte ) value ) ; } else if ( value instanceof String ) { return vf . create Literal ( ( String ) value ) ; } else { throw new Illegal Argument Exception ( String . format ( STRING , value ) ) ; } }
public void add Thumbnail Change Listener ( Thumbnail Change Listener listener ) { if ( ! m Listeners . contains ( listener ) ) { m Listeners . add ( listener ) ; } }
public Boolean check If Provider Supports Compression Operations ( Storage System storage System ) { String version Substring = null ; if ( storage System . check If Vmax 3 ( ) && storage System . get Using Smis 80 ( ) ) { try { Storage Provider storage Provider = db Client . query Object ( Storage Provider . class , storage System . get Active Provider URI ( ) ) ; String provider Version = storage Provider . get Version String ( ) ; version Substring = provider Version . split ( STRING ) [ NUM ] ; } catch ( Exception e ) { log . error ( STRING , storage System . get Label ( ) , storage System . get Id ( ) ) ; return BOOL ; } } if ( Null Column Value Getter . is Null Value ( version Substring ) || ! ( Integer . parse Int ( version Substring ) > NUM ) ) { String err Msg = String . format ( STRING , storage System . get Serial Number ( ) ) ; log . error ( err Msg ) ; return BOOL ; } return BOOL ; }
public Boolean check If Provider Supports Compression Operations ( Storage System storage System ) { String version Substring = null ; if ( storage System . check If Vmax 3 ( ) && storage System . get Using Smis 80 ( ) ) { try { Storage Provider storage Provider = db Client . query Object ( Storage Provider . class , storage System . get Active Provider URI ( ) ) ; String provider Version = storage Provider . get Version String ( ) ; version Substring = provider Version . split ( STRING ) [ NUM ] ; } catch ( Exception e ) { log . error ( STRING , storage System . get Label ( ) , storage System . get Id ( ) ) ; return BOOL ; } } if ( Null Column Value Getter . is Null Value ( version Substring ) || ! ( Integer . parse Int ( version Substring ) > NUM ) ) { String err Msg = String . format ( STRING , storage System . get Serial Number ( ) ) ; log . error ( err Msg ) ; return BOOL ; } return BOOL ; }
@ Override public String choose Server Alias ( final String key Type , final Principal [ ] issuers , final Socket socket ) { if ( key Manager != null ) { return key Manager . choose Server Alias ( key Type , issuers , socket ) ; } return null ; }
protected I Multi Point nearest ( double [ ] raw Target , double min [ ] ) { I Multi Point result = null ; double d = shorter ( raw Target , min [ NUM ] ) ; if ( d >= NUM && d < min [ NUM ] ) { min [ NUM ] = d ; result = point ; } double dp = Math . abs ( coord - raw Target [ dimension - NUM ] ) ; I Multi Point new Result = null ; int num Dbl Rec = NUM ; if ( dp < min [ NUM ] ) { if ( above != null ) { num Dbl Rec ++ ; new Result = above . nearest ( raw Target , min ) ; if ( new Result != null ) { result = new Result ; } } if ( below != null ) { num Dbl Rec ++ ; new Result = below . nearest ( raw Target , min ) ; if ( new Result != null ) { result = new Result ; } } if ( num Dbl Rec == NUM ) { num Double Recursions ++ ; } else if ( num Dbl Rec == NUM ) { num Recursions ++ ; } } else { num Recursions ++ ; if ( raw Target [ dimension - NUM ] < coord ) { if ( below != null ) { new Result = below . nearest ( raw Target , min ) ; } } else { if ( above != null ) { new Result = above . nearest ( raw Target , min ) ; } } if ( new Result != null ) { return new Result ; } } return result ; }
public static double max ( double [ ] a ) { double max = Double . NEGATIVE INFINITY ; for ( int i = NUM ; i < a . length ; i ++ ) { if ( Double . is Na N ( a [ i ] ) ) return Double . Na N ; if ( a [ i ] > max ) max = a [ i ] ; } return max ; }
public static double max ( double [ ] a ) { double max = Double . NEGATIVE INFINITY ; for ( int i = NUM ; i < a . length ; i ++ ) { if ( Double . is Na N ( a [ i ] ) ) return Double . Na N ; if ( a [ i ] > max ) max = a [ i ] ; } return max ; }
@ Nullable public EC Key find Key From Pub Hash ( byte [ ] pubkey Hash ) { lock . lock ( ) ; try { for ( EC Key key : keychain ) { if ( Arrays . equals ( key . get Pub Key Hash ( ) , pubkey Hash ) ) return key ; } return null ; } finally { lock . unlock ( ) ; } }
@ Nullable public EC Key find Key From Pub Hash ( byte [ ] pubkey Hash ) { lock . lock ( ) ; try { for ( EC Key key : keychain ) { if ( Arrays . equals ( key . get Pub Key Hash ( ) , pubkey Hash ) ) return key ; } return null ; } finally { lock . unlock ( ) ; } }
@ Nullable public EC Key find Key From Pub Hash ( byte [ ] pubkey Hash ) { lock . lock ( ) ; try { for ( EC Key key : keychain ) { if ( Arrays . equals ( key . get Pub Key Hash ( ) , pubkey Hash ) ) return key ; } return null ; } finally { lock . unlock ( ) ; } }
@ Nullable public EC Key find Key From Pub Hash ( byte [ ] pubkey Hash ) { lock . lock ( ) ; try { for ( EC Key key : keychain ) { if ( Arrays . equals ( key . get Pub Key Hash ( ) , pubkey Hash ) ) return key ; } return null ; } finally { lock . unlock ( ) ; } }
@ Nullable public EC Key find Key From Pub Hash ( byte [ ] pubkey Hash ) { lock . lock ( ) ; try { for ( EC Key key : keychain ) { if ( Arrays . equals ( key . get Pub Key Hash ( ) , pubkey Hash ) ) return key ; } return null ; } finally { lock . unlock ( ) ; } }
@ Override public void close ( ) throws IO Exception { while ( in != null ) { next Stream ( ) ; } e = null ; }
@ Override public void close ( ) throws IO Exception { while ( in != null ) { next Stream ( ) ; } e = null ; }
public static String from Generic Tag ( Tag tag ) { switch ( tag . get Type ( ) ) { case BYTE : return from Tag ( ( Byte Tag ) tag ) ; case BYTE ARRAY : return from Tag ( ( Byte Array Tag ) tag ) ; case COMPOUND : return from Tag ( ( Compound Tag ) tag ) ; case DOUBLE : return from Tag ( ( Double Tag ) tag ) ; case FLOAT : return from Tag ( ( Float Tag ) tag ) ; case INT : return from Tag ( ( Int Tag ) tag ) ; case INT ARRAY : return from Tag ( ( Int Array Tag ) tag ) ; case LIST : return from Tag ( ( List Tag ) tag ) ; case LONG : return from Tag ( ( Long Tag ) tag ) ; case SHORT : return from Tag ( ( Short Tag ) tag ) ; case STRING : return from Tag ( ( String Tag ) tag ) ; } return null ; }
public static int choose At Least For On Measure ( int min Value , int measure Spec ) { int spec Mode = Measure Spec . get Mode ( measure Spec ) ; int spec Size = Measure Spec . get Size ( measure Spec ) ; if ( spec Mode == Measure Spec . EXACTLY || spec Mode == Measure Spec . AT MOST && min Value > spec Size ) return spec Size ; return min Value ; }
public void test Add And Sum MT ( ) throws Throwable { final int incs = NUM ; final int nthreads = NUM ; final Executor Service pool = Executors . new Cached Thread Pool ( ) ; Long Adder a = new Long Adder ( ) ; Cyclic Barrier barrier = new Cyclic Barrier ( nthreads + NUM ) ; for ( int i = NUM ; i < nthreads ; ++ i ) pool . execute ( new Adder Task ( a , barrier , incs ) ) ; barrier . await ( ) ; barrier . await ( ) ; long total = ( long ) nthreads * incs ; long sum = a . sum ( ) ; assert Equals ( sum , total ) ; pool . shutdown ( ) ; }
public void test Add And Sum MT ( ) throws Throwable { final int incs = NUM ; final int nthreads = NUM ; final Executor Service pool = Executors . new Cached Thread Pool ( ) ; Long Adder a = new Long Adder ( ) ; Cyclic Barrier barrier = new Cyclic Barrier ( nthreads + NUM ) ; for ( int i = NUM ; i < nthreads ; ++ i ) pool . execute ( new Adder Task ( a , barrier , incs ) ) ; barrier . await ( ) ; barrier . await ( ) ; long total = ( long ) nthreads * incs ; long sum = a . sum ( ) ; assert Equals ( sum , total ) ; pool . shutdown ( ) ; }
public void add User Message Listener ( User Message Listener user Message Listener ) { user Message Listeners . add ( user Message Listener ) ; }
private < T extends CWL Resource > T look For Resource ( CWL Resource Type type , Class < T > clazz ) { List < T > resources = look For Resources ( type , clazz ) ; return resources != null && resources . size ( ) > NUM ? resources . get ( NUM ) : null ; }
private < T extends CWL Resource > T look For Resource ( CWL Resource Type type , Class < T > clazz ) { List < T > resources = look For Resources ( type , clazz ) ; return resources != null && resources . size ( ) > NUM ? resources . get ( NUM ) : null ; }
public synchronized boolean has Alert ( Alert alert ) { if ( alerts == null ) { return BOOL ; } return alerts . contains ( alert ) ; }
public Data Buffer ( final byte [ ] buffer , final int offset , final int length ) { byte Buffer = Byte Buffer . wrap ( buffer ) ; byte Buffer . order ( Byte Order . LITTLE ENDIAN ) ; byte Buffer . position ( offset ) ; }
public synchronized Native Tcp register Incoming Tcp Connection ( String origin Addr , int origin Port , String dest Addr , int dest Port ) { End Point Info origin = new End Point Info ( origin Addr , origin Port , Connection Type . TCP ) ; End Point Info dest = new End Point Info ( dest Addr , dest Port , Connection Type . TCP ) ; Queue < Native Tcp > queue = incoming Connections . get ( dest ) ; if ( queue == null ) { queue = new Concurrent Linked Queue < > ( ) ; incoming Connections . put ( dest , queue ) ; } Native Tcp connection = new Native Tcp ( dest , origin ) ; queue . add ( connection ) ; return connection ; }
public synchronized Native Tcp register Incoming Tcp Connection ( String origin Addr , int origin Port , String dest Addr , int dest Port ) { End Point Info origin = new End Point Info ( origin Addr , origin Port , Connection Type . TCP ) ; End Point Info dest = new End Point Info ( dest Addr , dest Port , Connection Type . TCP ) ; Queue < Native Tcp > queue = incoming Connections . get ( dest ) ; if ( queue == null ) { queue = new Concurrent Linked Queue < > ( ) ; incoming Connections . put ( dest , queue ) ; } Native Tcp connection = new Native Tcp ( dest , origin ) ; queue . add ( connection ) ; return connection ; }
public synchronized Native Tcp register Incoming Tcp Connection ( String origin Addr , int origin Port , String dest Addr , int dest Port ) { End Point Info origin = new End Point Info ( origin Addr , origin Port , Connection Type . TCP ) ; End Point Info dest = new End Point Info ( dest Addr , dest Port , Connection Type . TCP ) ; Queue < Native Tcp > queue = incoming Connections . get ( dest ) ; if ( queue == null ) { queue = new Concurrent Linked Queue < > ( ) ; incoming Connections . put ( dest , queue ) ; } Native Tcp connection = new Native Tcp ( dest , origin ) ; queue . add ( connection ) ; return connection ; }
public synchronized Native Tcp register Incoming Tcp Connection ( String origin Addr , int origin Port , String dest Addr , int dest Port ) { End Point Info origin = new End Point Info ( origin Addr , origin Port , Connection Type . TCP ) ; End Point Info dest = new End Point Info ( dest Addr , dest Port , Connection Type . TCP ) ; Queue < Native Tcp > queue = incoming Connections . get ( dest ) ; if ( queue == null ) { queue = new Concurrent Linked Queue < > ( ) ; incoming Connections . put ( dest , queue ) ; } Native Tcp connection = new Native Tcp ( dest , origin ) ; queue . add ( connection ) ; return connection ; }
public void flush ( ) { write Data Block ( ) ; }
public Piloting Roll Data check Maneuver ( Move Step step , Entity Movement Type overall Move Type ) { Piloting Roll Data roll = get Base Piloting Roll ( overall Move Type ) ; if ( ( step == null ) || ( step . get Type ( ) != Move Step Type . MANEUVER ) ) { roll . add Modifier ( Target Roll . CHECK FALSE , STRING ) ; return roll ; } boolean side Slip Mod = ( this instanceof Conv Fighter ) && is VSTOL ( ) ; roll . append ( new Piloting Roll Data ( get Id ( ) , Maneuver Type . get Mod ( step . get Maneuver Type ( ) , side Slip Mod ) , Maneuver Type . get Type Name ( step . get Maneuver Type ( ) ) + STRING ) ) ; return roll ; }
public Piloting Roll Data check Maneuver ( Move Step step , Entity Movement Type overall Move Type ) { Piloting Roll Data roll = get Base Piloting Roll ( overall Move Type ) ; if ( ( step == null ) || ( step . get Type ( ) != Move Step Type . MANEUVER ) ) { roll . add Modifier ( Target Roll . CHECK FALSE , STRING ) ; return roll ; } boolean side Slip Mod = ( this instanceof Conv Fighter ) && is VSTOL ( ) ; roll . append ( new Piloting Roll Data ( get Id ( ) , Maneuver Type . get Mod ( step . get Maneuver Type ( ) , side Slip Mod ) , Maneuver Type . get Type Name ( step . get Maneuver Type ( ) ) + STRING ) ) ; return roll ; }
private void sort Units To Move ( final List < Unit > units , final Route route ) { if ( units == null || units . is Empty ( ) ) { return ; } else if ( route == null ) { final Exception null Route Error = ( new Illegal Argument Exception ( STRING ) ) ; Client Logger . log Quietly ( STRING , null Route Error ) ; } final Comparator < Unit > unit Comparator ; if ( route . is Unload ( ) && Match . some Match ( units , Matches . Unit Is Land ) ) { unit Comparator = Unit Comparator . get Unloadable Units Comparator ( units , route , get Unit Owner ( units ) ) ; } else { unit Comparator = Unit Comparator . get Movable Units Comparator ( units , route ) ; } Collections . sort ( units , unit Comparator ) ; }
public Object [ ] to Array ( ) { return al . to Array ( ) ; }
public Object [ ] to Array ( ) { return al . to Array ( ) ; }
public Object [ ] to Array ( ) { return al . to Array ( ) ; }
public Object [ ] to Array ( ) { return al . to Array ( ) ; }
public Object [ ] to Array ( ) { return al . to Array ( ) ; }
public Object [ ] to Array ( ) { return al . to Array ( ) ; }
public Object [ ] to Array ( ) { return al . to Array ( ) ; }
public Object [ ] to Array ( ) { return al . to Array ( ) ; }
public Object [ ] to Array ( ) { return al . to Array ( ) ; }
public Object [ ] to Array ( ) { return al . to Array ( ) ; }
public Object [ ] to Array ( ) { return al . to Array ( ) ; }
public Object [ ] to Array ( ) { return al . to Array ( ) ; }
public void write To File ( String file Name ) throws IO Exception { write ( new File Output Stream ( file Name ) ) ; }
public void stop ( ) { m Cancel = BOOL ; if ( m Running . compare And Set ( BOOL , BOOL ) ) { if ( m Sample Dispatcher Task != null ) { m Thread Pool Manager . cancel ( m Sample Dispatcher Task ) ; m Sample Dispatcher Task = null ; m Filled Buffers . clear ( ) ; } } }
public static File write Tmp File ( final String prefix , final String suffix , final boolean delete On Exit , final List < String > args ) throws IO Exception { final File tmp File = File . create Temp File ( prefix , suffix ) ; if ( delete On Exit ) { tmp File . delete On Exit ( ) ; } write File ( tmp File , args ) ; return tmp File ; }
@ Suppress Warnings ( STRING ) protected Object read Resolve ( ) throws Object Stream Exception { try { Class message Class = Class . for Name ( message Class Name ) ; Method new Builder = message Class . get Method ( STRING ) ; Message Lite . Builder builder = ( Message Lite . Builder ) new Builder . invoke ( null ) ; builder . merge From ( as Bytes ) ; return builder . build Partial ( ) ; } catch ( Class Not Found Exception e ) { throw new Runtime Exception ( STRING , e ) ; } catch ( No Such Method Exception e ) { throw new Runtime Exception ( STRING , e ) ; } catch ( Illegal Access Exception e ) { throw new Runtime Exception ( STRING , e ) ; } catch ( Invocation Target Exception e ) { throw new Runtime Exception ( STRING , e . get Cause ( ) ) ; } catch ( Invalid Protocol Buffer Exception e ) { throw new Runtime Exception ( STRING , e ) ; } }
@ Suppress Warnings ( STRING ) protected Object read Resolve ( ) throws Object Stream Exception { try { Class message Class = Class . for Name ( message Class Name ) ; Method new Builder = message Class . get Method ( STRING ) ; Message Lite . Builder builder = ( Message Lite . Builder ) new Builder . invoke ( null ) ; builder . merge From ( as Bytes ) ; return builder . build Partial ( ) ; } catch ( Class Not Found Exception e ) { throw new Runtime Exception ( STRING , e ) ; } catch ( No Such Method Exception e ) { throw new Runtime Exception ( STRING , e ) ; } catch ( Illegal Access Exception e ) { throw new Runtime Exception ( STRING , e ) ; } catch ( Invocation Target Exception e ) { throw new Runtime Exception ( STRING , e . get Cause ( ) ) ; } catch ( Invalid Protocol Buffer Exception e ) { throw new Runtime Exception ( STRING , e ) ; } }
public void switch Setup ( ) { int ret Val ; ret Val = m Setup File Chooser . show Open Dialog ( this ) ; if ( ret Val != J File Chooser . APPROVE OPTION ) { return ; } m Db Utils . initialize ( m Setup File Chooser . get Selected File ( ) ) ; m URL = m Db Utils . get Database URL ( ) ; m User = m Db Utils . get Username ( ) ; m Password = m Db Utils . get Password ( ) ; m Text URL . set Text ( m URL ) ; }
public void switch Setup ( ) { int ret Val ; ret Val = m Setup File Chooser . show Open Dialog ( this ) ; if ( ret Val != J File Chooser . APPROVE OPTION ) { return ; } m Db Utils . initialize ( m Setup File Chooser . get Selected File ( ) ) ; m URL = m Db Utils . get Database URL ( ) ; m User = m Db Utils . get Username ( ) ; m Password = m Db Utils . get Password ( ) ; m Text URL . set Text ( m URL ) ; }
public boolean has Single Element ( ) { return m Selected Widgets . size ( ) == NUM ; }
public boolean has Single Element ( ) { return m Selected Widgets . size ( ) == NUM ; }
public void add ( char [ ] keyword , byte id ) { int key = get String Map Key ( keyword ) ; loop : for ( char ch : keyword ) { if ( ! Character . is Letter Or Digit ( ch ) ) { for ( int j = NUM ; j < no Word Sep . length ( ) ; j ++ ) { if ( no Word Sep . char At ( j ) == ch ) continue loop ; } no Word Sep . append ( ch ) ; } } map [ key ] = new Keyword ( keyword , id , map [ key ] ) ; }
@ Override public void write ( byte [ ] buffer , int offset , int length ) throws IO Exception { crc = Crc 64 . generate ( crc , buffer , offset , length ) ; next . write ( buffer , offset , length ) ; }
@ Override protected void add To Frontier ( Node node ) { if ( ! explored . contains ( node . get State ( ) ) ) { frontier . add ( node ) ; update Metrics ( frontier . size ( ) ) ; } }
@ Override protected void add To Frontier ( Node node ) { if ( ! explored . contains ( node . get State ( ) ) ) { frontier . add ( node ) ; update Metrics ( frontier . size ( ) ) ; } }
@ Override protected void add To Frontier ( Node node ) { if ( ! explored . contains ( node . get State ( ) ) ) { frontier . add ( node ) ; update Metrics ( frontier . size ( ) ) ; } }
public String canonicalize ( String simple URL ) { String result URL = simple URL ; if ( simple URL . starts With ( STRING ) ) { result URL = STRING + simple URL ; } else if ( simple URL . starts With ( STRING ) ) { result URL = STRING + simple URL ; } else if ( simple URL . starts With ( STRING ) ) { result URL = STRING + simple URL ; } else if ( ! has Protocol Name ( simple URL ) ) { if ( is Simple Host Name ( simple URL ) ) { simple URL = STRING + simple URL + STRING ; } result URL = STRING + simple URL ; } return result URL ; }
public String canonicalize ( String simple URL ) { String result URL = simple URL ; if ( simple URL . starts With ( STRING ) ) { result URL = STRING + simple URL ; } else if ( simple URL . starts With ( STRING ) ) { result URL = STRING + simple URL ; } else if ( simple URL . starts With ( STRING ) ) { result URL = STRING + simple URL ; } else if ( ! has Protocol Name ( simple URL ) ) { if ( is Simple Host Name ( simple URL ) ) { simple URL = STRING + simple URL + STRING ; } result URL = STRING + simple URL ; } return result URL ; }
public String canonicalize ( String simple URL ) { String result URL = simple URL ; if ( simple URL . starts With ( STRING ) ) { result URL = STRING + simple URL ; } else if ( simple URL . starts With ( STRING ) ) { result URL = STRING + simple URL ; } else if ( simple URL . starts With ( STRING ) ) { result URL = STRING + simple URL ; } else if ( ! has Protocol Name ( simple URL ) ) { if ( is Simple Host Name ( simple URL ) ) { simple URL = STRING + simple URL + STRING ; } result URL = STRING + simple URL ; } return result URL ; }
static public String normalize WWN ( String wwn ) { String result = wwn ; if ( wwn != null && ! wwn . is Empty ( ) ) { result = wwn . replace All ( STRING , STRING ) ; result = result . to Upper Case ( ) ; } return result ; }
static public String normalize WWN ( String wwn ) { String result = wwn ; if ( wwn != null && ! wwn . is Empty ( ) ) { result = wwn . replace All ( STRING , STRING ) ; result = result . to Upper Case ( ) ; } return result ; }
private void write Domain Pair ( Dom Pair pair , Document document , Element parent Element ) { Element dom Pair = document . create Element ( STRING ) ; parent Element . append Child ( dom Pair ) ; write Domain Spec ( pair . get First Domain ( ) , document , dom Pair ) ; write Domain Spec ( pair . get Second Domain ( ) , document , dom Pair ) ; }
public static Bitmap load Bitmap With Backouts ( Context context , Uri source Uri , int sample Size ) { boolean no Bitmap = BOOL ; int num tries = NUM ; if ( sample Size <= NUM ) { sample Size = NUM ; } Bitmap bmap = null ; while ( no Bitmap ) { try { bmap = load Downsampled Bitmap ( context , source Uri , sample Size ) ; no Bitmap = BOOL ; } catch ( java . lang . Out Of Memory Error e ) { if ( ++ num tries >= BITMAP LOAD BACKOUT ATTEMPTS ) { throw e ; } bmap = null ; System . gc ( ) ; sample Size *= NUM ; } } return bmap ; }
public static Bitmap load Bitmap With Backouts ( Context context , Uri source Uri , int sample Size ) { boolean no Bitmap = BOOL ; int num tries = NUM ; if ( sample Size <= NUM ) { sample Size = NUM ; } Bitmap bmap = null ; while ( no Bitmap ) { try { bmap = load Downsampled Bitmap ( context , source Uri , sample Size ) ; no Bitmap = BOOL ; } catch ( java . lang . Out Of Memory Error e ) { if ( ++ num tries >= BITMAP LOAD BACKOUT ATTEMPTS ) { throw e ; } bmap = null ; System . gc ( ) ; sample Size *= NUM ; } } return bmap ; }
public static Bitmap load Bitmap With Backouts ( Context context , Uri source Uri , int sample Size ) { boolean no Bitmap = BOOL ; int num tries = NUM ; if ( sample Size <= NUM ) { sample Size = NUM ; } Bitmap bmap = null ; while ( no Bitmap ) { try { bmap = load Downsampled Bitmap ( context , source Uri , sample Size ) ; no Bitmap = BOOL ; } catch ( java . lang . Out Of Memory Error e ) { if ( ++ num tries >= BITMAP LOAD BACKOUT ATTEMPTS ) { throw e ; } bmap = null ; System . gc ( ) ; sample Size *= NUM ; } } return bmap ; }
public static Bitmap load Bitmap With Backouts ( Context context , Uri source Uri , int sample Size ) { boolean no Bitmap = BOOL ; int num tries = NUM ; if ( sample Size <= NUM ) { sample Size = NUM ; } Bitmap bmap = null ; while ( no Bitmap ) { try { bmap = load Downsampled Bitmap ( context , source Uri , sample Size ) ; no Bitmap = BOOL ; } catch ( java . lang . Out Of Memory Error e ) { if ( ++ num tries >= BITMAP LOAD BACKOUT ATTEMPTS ) { throw e ; } bmap = null ; System . gc ( ) ; sample Size *= NUM ; } } return bmap ; }
public static Bitmap load Bitmap With Backouts ( Context context , Uri source Uri , int sample Size ) { boolean no Bitmap = BOOL ; int num tries = NUM ; if ( sample Size <= NUM ) { sample Size = NUM ; } Bitmap bmap = null ; while ( no Bitmap ) { try { bmap = load Downsampled Bitmap ( context , source Uri , sample Size ) ; no Bitmap = BOOL ; } catch ( java . lang . Out Of Memory Error e ) { if ( ++ num tries >= BITMAP LOAD BACKOUT ATTEMPTS ) { throw e ; } bmap = null ; System . gc ( ) ; sample Size *= NUM ; } } return bmap ; }
private static void learn ( ) { int list Size = learning Queue . size ( ) ; LOG . info ( STRING + list Size ) ; for ( int i = NUM ; i < list Size ; i ++ ) { Instance inst = learning Queue . poll ( ) ; if ( inst != null ) learner . train On Instance ( inst ) ; } }
private void handle Server URL Change ( String new Server URL ) { this . coordinator Server URL = new Server URL ; log . info ( STRING + new Server URL ) ; }
private void handle Server URL Change ( String new Server URL ) { this . coordinator Server URL = new Server URL ; log . info ( STRING + new Server URL ) ; }
private void handle Server URL Change ( String new Server URL ) { this . coordinator Server URL = new Server URL ; log . info ( STRING + new Server URL ) ; }
public void receive ( float new Sample ) { m Buffer . set ( m Buffer Pointer , new Sample ) ; m Buffer Pointer ++ ; if ( m Buffer Pointer >= m Buffer Size ) { m Buffer Pointer = NUM ; } float accumulator = NUM ; accumulator += m Coefficients [ m Center Coefficient ] * m Buffer . get ( m Index Map [ m Buffer Pointer ] [ m Center Coefficient Map Index ] ) ; for ( int x = NUM ; x < m Center Coefficient Map Index ; x += NUM ) { accumulator += m Coefficients [ x ] * ( m Buffer . get ( m Index Map [ m Buffer Pointer ] [ x ] ) + m Buffer . get ( m Index Map [ m Buffer Pointer ] [ x + NUM ] ) ) ; } if ( m Listener != null ) { m Listener . receive ( ( float ) ( accumulator * m Gain ) ) ; } }
public void receive ( float new Sample ) { m Buffer . set ( m Buffer Pointer , new Sample ) ; m Buffer Pointer ++ ; if ( m Buffer Pointer >= m Buffer Size ) { m Buffer Pointer = NUM ; } float accumulator = NUM ; accumulator += m Coefficients [ m Center Coefficient ] * m Buffer . get ( m Index Map [ m Buffer Pointer ] [ m Center Coefficient Map Index ] ) ; for ( int x = NUM ; x < m Center Coefficient Map Index ; x += NUM ) { accumulator += m Coefficients [ x ] * ( m Buffer . get ( m Index Map [ m Buffer Pointer ] [ x ] ) + m Buffer . get ( m Index Map [ m Buffer Pointer ] [ x + NUM ] ) ) ; } if ( m Listener != null ) { m Listener . receive ( ( float ) ( accumulator * m Gain ) ) ; } }
public void subtract Amount ( final String amount ) { subtract Amount ( Integer . parse Int ( amount ) ) ; }
public void subtract Amount ( final String amount ) { subtract Amount ( Integer . parse Int ( amount ) ) ; }
public static final void print Current Thread Cpu Time ( ) { print Thread Cpu Time ( Thread . current Thread ( ) ) ; }
public static final void print Current Thread Cpu Time ( ) { print Thread Cpu Time ( Thread . current Thread ( ) ) ; }
public static final void print Current Thread Cpu Time ( ) { print Thread Cpu Time ( Thread . current Thread ( ) ) ; }
public void add ( final T object ) { m Objects . add ( object ) ; notify Item Inserted ( get Item Count ( ) - NUM ) ; }
public void add ( final T object ) { m Objects . add ( object ) ; notify Item Inserted ( get Item Count ( ) - NUM ) ; }
@ Override public Request Methods Request Condition combine ( Request Methods Request Condition other ) { Set < Request Method > set = new Linked Hash Set < > ( this . methods ) ; set . add All ( other . methods ) ; return new Request Methods Request Condition ( set ) ; }
@ Override public synchronized void add Data Source Listener ( Data Source Listener dsl ) { m data Source Listeners . add Element ( dsl ) ; if ( m format != null ) { Data Set Event e = new Data Set Event ( this , m format ) ; dsl . accept Data Set ( e ) ; } }
public Integer Constant add Integer ( int value ) { Integer Constant entry = get Integer By Value ( value ) ; if ( entry != null ) return entry ; entry = new Integer Constant ( this , entries . size ( ) , value ) ; add Constant ( entry ) ; return entry ; }
private static int rail ( int val ) { return val > NUM ? NUM : val ; }
private static int rail ( int val ) { return val > NUM ? NUM : val ; }
private static int rail ( int val ) { return val > NUM ? NUM : val ; }
private static int rail ( int val ) { return val > NUM ? NUM : val ; }
private static int rail ( int val ) { return val > NUM ? NUM : val ; }
public static void split File Path ( String source Path , List < String > partitions Files , String separator ) { if ( String Utils . is Not Empty ( source Path ) ) { String [ ] files = source Path . split ( separator ) ; for ( String file : files ) { partitions Files . add ( file ) ; } } }
public Lucene 70 Codec ( Mode mode ) { super ( STRING ) ; this . stored Fields Format = new Lucene 50 Stored Fields Format ( Objects . require Non Null ( mode ) ) ; }
public Lucene 70 Codec ( Mode mode ) { super ( STRING ) ; this . stored Fields Format = new Lucene 50 Stored Fields Format ( Objects . require Non Null ( mode ) ) ; }
protected void reorder App Deployments After Configuration Version ( Element domain ) { List < Element > app Deployments = xml Tool . select Elements Matching X Path ( STRING , domain ) ; for ( Element app Deployment : app Deployments ) { domain . remove Child ( app Deployment ) ; } Element configuration Version = xml Tool . select Element Matching X Path ( STRING , domain ) ; Node before = null ; Node List children = domain . get Child Nodes ( ) ; for ( int i = NUM ; i < children . get Length ( ) ; i ++ ) { if ( configuration Version . equals ( children . item ( i ) ) && i < children . get Length ( ) - NUM ) { before = children . item ( i + NUM ) ; } } if ( before != null ) { for ( Element app Deployment : app Deployments ) { domain . insert Before ( app Deployment , before ) ; } } else { for ( Element app Deployment : app Deployments ) { domain . append Child ( app Deployment ) ; } } }
protected void reorder App Deployments After Configuration Version ( Element domain ) { List < Element > app Deployments = xml Tool . select Elements Matching X Path ( STRING , domain ) ; for ( Element app Deployment : app Deployments ) { domain . remove Child ( app Deployment ) ; } Element configuration Version = xml Tool . select Element Matching X Path ( STRING , domain ) ; Node before = null ; Node List children = domain . get Child Nodes ( ) ; for ( int i = NUM ; i < children . get Length ( ) ; i ++ ) { if ( configuration Version . equals ( children . item ( i ) ) && i < children . get Length ( ) - NUM ) { before = children . item ( i + NUM ) ; } } if ( before != null ) { for ( Element app Deployment : app Deployments ) { domain . insert Before ( app Deployment , before ) ; } } else { for ( Element app Deployment : app Deployments ) { domain . append Child ( app Deployment ) ; } } }
protected void reorder App Deployments After Configuration Version ( Element domain ) { List < Element > app Deployments = xml Tool . select Elements Matching X Path ( STRING , domain ) ; for ( Element app Deployment : app Deployments ) { domain . remove Child ( app Deployment ) ; } Element configuration Version = xml Tool . select Element Matching X Path ( STRING , domain ) ; Node before = null ; Node List children = domain . get Child Nodes ( ) ; for ( int i = NUM ; i < children . get Length ( ) ; i ++ ) { if ( configuration Version . equals ( children . item ( i ) ) && i < children . get Length ( ) - NUM ) { before = children . item ( i + NUM ) ; } } if ( before != null ) { for ( Element app Deployment : app Deployments ) { domain . insert Before ( app Deployment , before ) ; } } else { for ( Element app Deployment : app Deployments ) { domain . append Child ( app Deployment ) ; } } }
protected void reorder App Deployments After Configuration Version ( Element domain ) { List < Element > app Deployments = xml Tool . select Elements Matching X Path ( STRING , domain ) ; for ( Element app Deployment : app Deployments ) { domain . remove Child ( app Deployment ) ; } Element configuration Version = xml Tool . select Element Matching X Path ( STRING , domain ) ; Node before = null ; Node List children = domain . get Child Nodes ( ) ; for ( int i = NUM ; i < children . get Length ( ) ; i ++ ) { if ( configuration Version . equals ( children . item ( i ) ) && i < children . get Length ( ) - NUM ) { before = children . item ( i + NUM ) ; } } if ( before != null ) { for ( Element app Deployment : app Deployments ) { domain . insert Before ( app Deployment , before ) ; } } else { for ( Element app Deployment : app Deployments ) { domain . append Child ( app Deployment ) ; } } }
public synchronized void zoom ( final Point 2 D p , double scale ) { m itransform . transform ( p , m tmp Point ) ; zoom Abs ( m tmp Point , scale ) ; }
public synchronized void zoom ( final Point 2 D p , double scale ) { m itransform . transform ( p , m tmp Point ) ; zoom Abs ( m tmp Point , scale ) ; }
public boolean close Connection ( ) throws SQL Exception { if ( connection == null ) { return BOOL ; } connection . close ( ) ; connection = null ; return BOOL ; }
public void stop ( ) { running = BOOL ; }
public int num Squares 1 ( int n ) { while ( n % NUM == NUM ) n /= NUM ; if ( n % NUM == NUM ) return NUM ; for ( int a = NUM ; a * a <= n ; a ++ ) { int b = ( int ) Math . sqrt ( n - a * a ) ; if ( a * a + b * b == n ) { return NUM + ( a > NUM ? NUM : NUM ) ; } } return NUM ; }
public int num Squares 1 ( int n ) { while ( n % NUM == NUM ) n /= NUM ; if ( n % NUM == NUM ) return NUM ; for ( int a = NUM ; a * a <= n ; a ++ ) { int b = ( int ) Math . sqrt ( n - a * a ) ; if ( a * a + b * b == n ) { return NUM + ( a > NUM ? NUM : NUM ) ; } } return NUM ; }
public int num Squares 1 ( int n ) { while ( n % NUM == NUM ) n /= NUM ; if ( n % NUM == NUM ) return NUM ; for ( int a = NUM ; a * a <= n ; a ++ ) { int b = ( int ) Math . sqrt ( n - a * a ) ; if ( a * a + b * b == n ) { return NUM + ( a > NUM ? NUM : NUM ) ; } } return NUM ; }
public int num Squares 1 ( int n ) { while ( n % NUM == NUM ) n /= NUM ; if ( n % NUM == NUM ) return NUM ; for ( int a = NUM ; a * a <= n ; a ++ ) { int b = ( int ) Math . sqrt ( n - a * a ) ; if ( a * a + b * b == n ) { return NUM + ( a > NUM ? NUM : NUM ) ; } } return NUM ; }
public void on Exceeded Database Quota ( String url , String database Identifier , long current Quota , long estimated Size , long total Used Quota , Web Storage . Quota Updater quota Updater ) { if ( LOGV ENABLED ) { Log . v ( LOGTAG , STRING + url + STRING + database Identifier + STRING + current Quota + STRING + total Used Quota + STRING ) ; } long total Unused Quota = m Global Limit - total Used Quota - m App Cache Max Size ; if ( total Unused Quota <= NUM ) { if ( total Used Quota > NUM ) { schedule Out Of Space Notification ( ) ; } quota Updater . update Quota ( current Quota ) ; if ( LOGV ENABLED ) { Log . v ( LOGTAG , STRING ) ; } return ; } long new Origin Quota = current Quota ; if ( new Origin Quota == NUM ) { if ( total Unused Quota >= estimated Size ) { new Origin Quota = estimated Size ; } else { if ( LOGV ENABLED ) { Log . v ( LOGTAG , STRING + STRING + STRING + estimated Size + STRING + total Unused Quota ) ; } new Origin Quota = NUM ; } } else { long quota Increase = estimated Size == NUM ? Math . min ( QUOTA INCREASE STEP , total Unused Quota ) : estimated Size ; new Origin Quota += quota Increase ; if ( quota Increase > total Unused Quota ) { new Origin Quota = current Quota ; } } quota Updater . update Quota ( new Origin Quota ) ; if ( LOGV ENABLED ) { Log . v ( LOGTAG , STRING + new Origin Quota ) ; } }
public void on Exceeded Database Quota ( String url , String database Identifier , long current Quota , long estimated Size , long total Used Quota , Web Storage . Quota Updater quota Updater ) { if ( LOGV ENABLED ) { Log . v ( LOGTAG , STRING + url + STRING + database Identifier + STRING + current Quota + STRING + total Used Quota + STRING ) ; } long total Unused Quota = m Global Limit - total Used Quota - m App Cache Max Size ; if ( total Unused Quota <= NUM ) { if ( total Used Quota > NUM ) { schedule Out Of Space Notification ( ) ; } quota Updater . update Quota ( current Quota ) ; if ( LOGV ENABLED ) { Log . v ( LOGTAG , STRING ) ; } return ; } long new Origin Quota = current Quota ; if ( new Origin Quota == NUM ) { if ( total Unused Quota >= estimated Size ) { new Origin Quota = estimated Size ; } else { if ( LOGV ENABLED ) { Log . v ( LOGTAG , STRING + STRING + STRING + estimated Size + STRING + total Unused Quota ) ; } new Origin Quota = NUM ; } } else { long quota Increase = estimated Size == NUM ? Math . min ( QUOTA INCREASE STEP , total Unused Quota ) : estimated Size ; new Origin Quota += quota Increase ; if ( quota Increase > total Unused Quota ) { new Origin Quota = current Quota ; } } quota Updater . update Quota ( new Origin Quota ) ; if ( LOGV ENABLED ) { Log . v ( LOGTAG , STRING + new Origin Quota ) ; } }
private static int array Index ( int i ) { return ( i > > SHIFT PER WORD ) ; }
private static int array Index ( int i ) { return ( i > > SHIFT PER WORD ) ; }
public boolean cancel Transfer ( String username , String submission ID ) { if ( cancel Upload ( username , submission ID ) ) return BOOL ; return cancel Download ( username , submission ID ) ; }
public void merge ( Rectangle other ) { int old X 2 = get X 2 ( ) ; int old Y 2 = get Y 2 ( ) ; set X ( Math . min ( get X ( ) , other . get X ( ) ) ) ; set Y ( Math . min ( get Y ( ) , other . get Y ( ) ) ) ; set Width ( Math . max ( old X 2 , other . get X 2 ( ) ) - get X ( ) ) ; set Height ( Math . max ( old Y 2 , other . get Y 2 ( ) ) - get Y ( ) ) ; }
public void add All Listeners ( Property Change Listener listener , Object new Object , Set update Set ) { add Listeners ( listener , new Object , update Set ) ; if ( ( children != null ) && ( children . length > NUM ) ) { try { Object new Value = null ; if ( new Object != null ) { update Set . add ( new Object ) ; new Value = extract New Value ( new Object ) ; } for ( Bind Path child : children ) { child . add All Listeners ( listener , new Value , update Set ) ; } } catch ( Exception e ) { e . print Stack Trace ( System . out ) ; } } }
public void add All Listeners ( Property Change Listener listener , Object new Object , Set update Set ) { add Listeners ( listener , new Object , update Set ) ; if ( ( children != null ) && ( children . length > NUM ) ) { try { Object new Value = null ; if ( new Object != null ) { update Set . add ( new Object ) ; new Value = extract New Value ( new Object ) ; } for ( Bind Path child : children ) { child . add All Listeners ( listener , new Value , update Set ) ; } } catch ( Exception e ) { e . print Stack Trace ( System . out ) ; } } }
protected final void init Statistics ( String who , String [ ] header Lines ) throws Ade Exception { set Stats File Path ( ) ; if ( stats File Path == null ) { throw new Ade Internal Exception ( STRING ) ; } append Stat String ( SPACER ) ; append Stat String ( String . format ( STRING , current Time Stamp ( ) , who ) ) ; append Stat String ( SPACER ) ; for ( int i = NUM ; i < header Lines . length ; i ++ ) { append Stat String ( header Lines [ i ] ) ; } append Stat String ( SPACER ) ; }
protected final void init Statistics ( String who , String [ ] header Lines ) throws Ade Exception { set Stats File Path ( ) ; if ( stats File Path == null ) { throw new Ade Internal Exception ( STRING ) ; } append Stat String ( SPACER ) ; append Stat String ( String . format ( STRING , current Time Stamp ( ) , who ) ) ; append Stat String ( SPACER ) ; for ( int i = NUM ; i < header Lines . length ; i ++ ) { append Stat String ( header Lines [ i ] ) ; } append Stat String ( SPACER ) ; }
public boolean is Numerically Identical ( final Plane p ) { if ( Math . abs ( this . y * p . z - this . z * p . y ) >= MINIMUM RESOLUTION ) return BOOL ; if ( Math . abs ( this . z * p . x - this . x * p . z ) >= MINIMUM RESOLUTION ) return BOOL ; if ( Math . abs ( this . x * p . y - this . y * p . x ) >= MINIMUM RESOLUTION ) return BOOL ; final double denom = NUM / ( p . x * p . x + p . y * p . y + p . z * p . z ) ; return evaluate Is Zero ( - p . x * p . D * denom , - p . y * p . D * denom , - p . z * p . D * denom ) ; }
public boolean is Numerically Identical ( final Plane p ) { if ( Math . abs ( this . y * p . z - this . z * p . y ) >= MINIMUM RESOLUTION ) return BOOL ; if ( Math . abs ( this . z * p . x - this . x * p . z ) >= MINIMUM RESOLUTION ) return BOOL ; if ( Math . abs ( this . x * p . y - this . y * p . x ) >= MINIMUM RESOLUTION ) return BOOL ; final double denom = NUM / ( p . x * p . x + p . y * p . y + p . z * p . z ) ; return evaluate Is Zero ( - p . x * p . D * denom , - p . y * p . D * denom , - p . z * p . D * denom ) ; }
public void remove Value From Domain ( Variable var , Object value ) { Domain curr Domain = get Domain ( var ) ; List < Object > values = new Array List < Object > ( curr Domain . size ( ) ) ; for ( Object v : curr Domain ) if ( ! v . equals ( value ) ) values . add ( v ) ; set Domain ( var , new Domain ( values ) ) ; }
public void remove Value From Domain ( Variable var , Object value ) { Domain curr Domain = get Domain ( var ) ; List < Object > values = new Array List < Object > ( curr Domain . size ( ) ) ; for ( Object v : curr Domain ) if ( ! v . equals ( value ) ) values . add ( v ) ; set Domain ( var , new Domain ( values ) ) ; }
public void remove Value From Domain ( Variable var , Object value ) { Domain curr Domain = get Domain ( var ) ; List < Object > values = new Array List < Object > ( curr Domain . size ( ) ) ; for ( Object v : curr Domain ) if ( ! v . equals ( value ) ) values . add ( v ) ; set Domain ( var , new Domain ( values ) ) ; }
protected Postgres Messages read Message ( boolean has Type ) throws IO Exception { Postgres Messages type ; int code = - NUM ; if ( has Type ) { try { before Idle ( ) ; while ( BOOL ) { try { code = data Input . read ( ) ; } catch ( Socket Timeout Exception ex ) { idle ( ) ; continue ; } if ( ! Postgres Messages . read Type Correct ( code ) ) { throw new IO Exception ( STRING + ( char ) code ) ; } type = Postgres Messages . message Type ( code ) ; break ; } } finally { after Idle ( ) ; } } else { type = Postgres Messages . STARTUP MESSAGE TYPE ; code = NUM ; } if ( code < NUM ) return Postgres Messages . EOF TYPE ; recv Tap . in ( ) ; try { int count = NUM ; if ( code > NUM ) count ++ ; int len = data Input . read Int ( ) ; if ( ( len < NUM ) || ( len > type . max Size ( ) ) ) throw new IO Exception ( String . format ( STRING , len ) ) ; count += len ; len -= NUM ; try { raw Message Input = new byte [ len ] ; data Input . read Fully ( raw Message Input , NUM , len ) ; message Input = new Data Input Stream ( new Byte Array Input Stream ( raw Message Input ) ) ; } catch ( Out Of Memory Error ex ) { throw new IO Exception ( String . format ( STRING , len ) ) ; } bytes Read ( count ) ; return type ; } finally { recv Tap . out ( ) ; } }
@ Override public int hash Code ( ) { int my Position = position ; int hash = NUM ; while ( my Position < limit ) { hash = hash + Float . float To Int Bits ( get ( my Position ++ ) ) ; } return hash ; }
@ Override public int hash Code ( ) { int my Position = position ; int hash = NUM ; while ( my Position < limit ) { hash = hash + Float . float To Int Bits ( get ( my Position ++ ) ) ; } return hash ; }
@ Override public int hash Code ( ) { int my Position = position ; int hash = NUM ; while ( my Position < limit ) { hash = hash + Float . float To Int Bits ( get ( my Position ++ ) ) ; } return hash ; }
@ Override public int hash Code ( ) { int my Position = position ; int hash = NUM ; while ( my Position < limit ) { hash = hash + Float . float To Int Bits ( get ( my Position ++ ) ) ; } return hash ; }
public static double compute New Priority sigmoid Fraction Of Friends ( double priority , int shared Friends , int my Friends ) { double trust Multiplier = sigmoid ( shared Friends / ( double ) my Friends , NUM , NUM ) ; trust Multiplier = trust Multiplier + get Gaussian ( MEAN , VAR ) ; trust Multiplier = Math . min ( trust Multiplier , NUM ) ; trust Multiplier = Math . max ( trust Multiplier , NUM ) ; if ( shared Friends == NUM ) { trust Multiplier = EPSILON TRUST ; } return priority * trust Multiplier ; }
public static double compute New Priority sigmoid Fraction Of Friends ( double priority , int shared Friends , int my Friends ) { double trust Multiplier = sigmoid ( shared Friends / ( double ) my Friends , NUM , NUM ) ; trust Multiplier = trust Multiplier + get Gaussian ( MEAN , VAR ) ; trust Multiplier = Math . min ( trust Multiplier , NUM ) ; trust Multiplier = Math . max ( trust Multiplier , NUM ) ; if ( shared Friends == NUM ) { trust Multiplier = EPSILON TRUST ; } return priority * trust Multiplier ; }
public void add Builder Set ( Builder builer ) { relations . add All ( builer . relations ) ; }
public void add Builder Set ( Builder builer ) { relations . add All ( builer . relations ) ; }
@ Post Construct public void init ( ) { LOGGER . trace ( STRING ) ; cluster Cache . acquire Write Lock On Key ( LAST ALIVE TIMER CHECK INITIALISATION KEY ) ; try { if ( ! cluster Cache . has Key ( LAST ALIVE TIMER CHECK INITIALISATION KEY ) ) { cluster Cache . put ( LAST ALIVE TIMER CHECK INITIALISATION KEY , BOOL ) ; cluster Cache . put ( LAST ALIVE TIMER CHECK LONG , Long . value Of ( NUM ) ) ; } } finally { cluster Cache . release Write Lock On Key ( LAST ALIVE TIMER CHECK INITIALISATION KEY ) ; } LOGGER . trace ( STRING ) ; }
public static void simulate RPU ( Logic Circuit lc , Gate Library gate library , Args options ) { Array List < Gate > logic and output gates = new Array List < Gate > ( ) ; logic and output gates . add All ( lc . get logic gates ( ) ) ; logic and output gates . add All ( lc . get output gates ( ) ) ; for ( Gate gate : logic and output gates ) { gate . set unvisited ( BOOL ) ; } for ( Gate gate : logic and output gates ) { Evaluate . simulate RPU ( gate , gate library , options ) ; } }
public static void simulate RPU ( Logic Circuit lc , Gate Library gate library , Args options ) { Array List < Gate > logic and output gates = new Array List < Gate > ( ) ; logic and output gates . add All ( lc . get logic gates ( ) ) ; logic and output gates . add All ( lc . get output gates ( ) ) ; for ( Gate gate : logic and output gates ) { gate . set unvisited ( BOOL ) ; } for ( Gate gate : logic and output gates ) { Evaluate . simulate RPU ( gate , gate library , options ) ; } }
public static int put Byte Buffer ( byte [ ] bytes , int offset , Byte Buffer buf ) { int len = buf . remaining ( ) ; buf . get ( bytes , offset , len ) ; return offset + len ; }
public void add Attribute ( Google Base Attribute Id attribute Id , Gm Attribute . Importance importance ) { if ( attribute Ids . contains ( attribute Id ) ) { throw new Illegal Argument Exception ( STRING + STRING + attribute Id ) ; } attributes . add ( new Gm Attribute ( attribute Id , importance ) ) ; attribute Ids . add ( attribute Id ) ; }
public void add Attribute ( Google Base Attribute Id attribute Id , Gm Attribute . Importance importance ) { if ( attribute Ids . contains ( attribute Id ) ) { throw new Illegal Argument Exception ( STRING + STRING + attribute Id ) ; } attributes . add ( new Gm Attribute ( attribute Id , importance ) ) ; attribute Ids . add ( attribute Id ) ; }
public void add Attribute ( Google Base Attribute Id attribute Id , Gm Attribute . Importance importance ) { if ( attribute Ids . contains ( attribute Id ) ) { throw new Illegal Argument Exception ( STRING + STRING + attribute Id ) ; } attributes . add ( new Gm Attribute ( attribute Id , importance ) ) ; attribute Ids . add ( attribute Id ) ; }
public void add Attribute ( Google Base Attribute Id attribute Id , Gm Attribute . Importance importance ) { if ( attribute Ids . contains ( attribute Id ) ) { throw new Illegal Argument Exception ( STRING + STRING + attribute Id ) ; } attributes . add ( new Gm Attribute ( attribute Id , importance ) ) ; attribute Ids . add ( attribute Id ) ; }
public void add Attribute ( Google Base Attribute Id attribute Id , Gm Attribute . Importance importance ) { if ( attribute Ids . contains ( attribute Id ) ) { throw new Illegal Argument Exception ( STRING + STRING + attribute Id ) ; } attributes . add ( new Gm Attribute ( attribute Id , importance ) ) ; attribute Ids . add ( attribute Id ) ; }
public void add Attribute ( Google Base Attribute Id attribute Id , Gm Attribute . Importance importance ) { if ( attribute Ids . contains ( attribute Id ) ) { throw new Illegal Argument Exception ( STRING + STRING + attribute Id ) ; } attributes . add ( new Gm Attribute ( attribute Id , importance ) ) ; attribute Ids . add ( attribute Id ) ; }
public Standard XYZ Tool Tip Generator ( ) { this ( DEFAULT TOOL TIP FORMAT , Number Format . get Number Instance ( ) , Number Format . get Number Instance ( ) , Number Format . get Number Instance ( ) ) ; }
public Standard XYZ Tool Tip Generator ( ) { this ( DEFAULT TOOL TIP FORMAT , Number Format . get Number Instance ( ) , Number Format . get Number Instance ( ) , Number Format . get Number Instance ( ) ) ; }
public Standard XYZ Tool Tip Generator ( ) { this ( DEFAULT TOOL TIP FORMAT , Number Format . get Number Instance ( ) , Number Format . get Number Instance ( ) , Number Format . get Number Instance ( ) ) ; }
Web Session create New Session ( String host Addr ) { String new Id ; do { new Id = generate Session Id ( ) ; } while ( sessions . get ( new Id ) != null ) ; Web Session session = new Web Session ( this ) ; session . last Access = System . current Time Millis ( ) ; session . put ( STRING , new Id ) ; session . put ( STRING , host Addr ) ; session . put ( STRING , DEFAULT LANGUAGE ) ; session . put ( STRING , STRING ) ; session . put ( STRING , STRING ) ; sessions . put ( new Id , session ) ; read Translations ( session , DEFAULT LANGUAGE ) ; return get Session ( new Id ) ; }
private void create Workbook JXL ( ) throws Biff Exception , IO Exception { File file = get File ( ) ; Workbook Settings workbook Settings = new Workbook Settings ( ) ; if ( encoding != null ) { workbook Settings . set Encoding ( encoding . name ( ) ) ; } workbook JXL = Workbook . get Workbook ( file , workbook Settings ) ; }
private void commit Comment Note ( String review Commit Hash , Review Comment comment ) { try ( Git Note Writer < Review Comment > writer = Git Note Writer . create Note Writer ( review Commit Hash , repo , author , COMMENTS REF ) ) { comment . set Timestamp ( System . current Time Millis ( ) / NUM ) ; comment . set Author ( author . get Email Address ( ) ) ; List < Review Comment > comments = new Array List < Review Comment > ( ) ; comments . add ( comment ) ; writer . create ( STRING + review Commit Hash , comments ) ; } }
private void commit Comment Note ( String review Commit Hash , Review Comment comment ) { try ( Git Note Writer < Review Comment > writer = Git Note Writer . create Note Writer ( review Commit Hash , repo , author , COMMENTS REF ) ) { comment . set Timestamp ( System . current Time Millis ( ) / NUM ) ; comment . set Author ( author . get Email Address ( ) ) ; List < Review Comment > comments = new Array List < Review Comment > ( ) ; comments . add ( comment ) ; writer . create ( STRING + review Commit Hash , comments ) ; } }
public Domain Editor Kit ( ) { xml View Factory = new Xml View Factory ( ) ; }
public Generic Table Handler ( Json Value table Config , String db Schema Name , Json Value queries Config , Json Value commands Config , int max Batch Size , SQL Exception Handler sql Exception Handler ) { cfg = Generic Table Config . parse ( table Config ) ; this . main Table Name = cfg . main Table Name ; this . prop Table Name = cfg . properties Table Name ; this . db Schema Name = db Schema Name ; if ( max Batch Size < NUM ) { this . max Batch Size = NUM ; } else { this . max Batch Size = max Batch Size ; } if ( sql Exception Handler == null ) { this . sql Exception Handler = new Default SQL Exception Handler ( ) ; } else { this . sql Exception Handler = sql Exception Handler ; } queries = new Table Queries ( this , main Table Name , prop Table Name , db Schema Name , get Searchable Length ( ) , new Generic Query Result Mapper ( ) ) ; query Map = Collections . unmodifiable Map ( initialize Query Map ( ) ) ; queries . set Configured Queries ( queries Config , commands Config , query Map ) ; enable Batching = ( this . max Batch Size > NUM ) ; if ( enable Batching ) { logger . info ( STRING , this . max Batch Size ) ; } else { logger . info ( STRING ) ; } }
public Generic Table Handler ( Json Value table Config , String db Schema Name , Json Value queries Config , Json Value commands Config , int max Batch Size , SQL Exception Handler sql Exception Handler ) { cfg = Generic Table Config . parse ( table Config ) ; this . main Table Name = cfg . main Table Name ; this . prop Table Name = cfg . properties Table Name ; this . db Schema Name = db Schema Name ; if ( max Batch Size < NUM ) { this . max Batch Size = NUM ; } else { this . max Batch Size = max Batch Size ; } if ( sql Exception Handler == null ) { this . sql Exception Handler = new Default SQL Exception Handler ( ) ; } else { this . sql Exception Handler = sql Exception Handler ; } queries = new Table Queries ( this , main Table Name , prop Table Name , db Schema Name , get Searchable Length ( ) , new Generic Query Result Mapper ( ) ) ; query Map = Collections . unmodifiable Map ( initialize Query Map ( ) ) ; queries . set Configured Queries ( queries Config , commands Config , query Map ) ; enable Batching = ( this . max Batch Size > NUM ) ; if ( enable Batching ) { logger . info ( STRING , this . max Batch Size ) ; } else { logger . info ( STRING ) ; } }
public Generic Table Handler ( Json Value table Config , String db Schema Name , Json Value queries Config , Json Value commands Config , int max Batch Size , SQL Exception Handler sql Exception Handler ) { cfg = Generic Table Config . parse ( table Config ) ; this . main Table Name = cfg . main Table Name ; this . prop Table Name = cfg . properties Table Name ; this . db Schema Name = db Schema Name ; if ( max Batch Size < NUM ) { this . max Batch Size = NUM ; } else { this . max Batch Size = max Batch Size ; } if ( sql Exception Handler == null ) { this . sql Exception Handler = new Default SQL Exception Handler ( ) ; } else { this . sql Exception Handler = sql Exception Handler ; } queries = new Table Queries ( this , main Table Name , prop Table Name , db Schema Name , get Searchable Length ( ) , new Generic Query Result Mapper ( ) ) ; query Map = Collections . unmodifiable Map ( initialize Query Map ( ) ) ; queries . set Configured Queries ( queries Config , commands Config , query Map ) ; enable Batching = ( this . max Batch Size > NUM ) ; if ( enable Batching ) { logger . info ( STRING , this . max Batch Size ) ; } else { logger . info ( STRING ) ; } }
public Generic Table Handler ( Json Value table Config , String db Schema Name , Json Value queries Config , Json Value commands Config , int max Batch Size , SQL Exception Handler sql Exception Handler ) { cfg = Generic Table Config . parse ( table Config ) ; this . main Table Name = cfg . main Table Name ; this . prop Table Name = cfg . properties Table Name ; this . db Schema Name = db Schema Name ; if ( max Batch Size < NUM ) { this . max Batch Size = NUM ; } else { this . max Batch Size = max Batch Size ; } if ( sql Exception Handler == null ) { this . sql Exception Handler = new Default SQL Exception Handler ( ) ; } else { this . sql Exception Handler = sql Exception Handler ; } queries = new Table Queries ( this , main Table Name , prop Table Name , db Schema Name , get Searchable Length ( ) , new Generic Query Result Mapper ( ) ) ; query Map = Collections . unmodifiable Map ( initialize Query Map ( ) ) ; queries . set Configured Queries ( queries Config , commands Config , query Map ) ; enable Batching = ( this . max Batch Size > NUM ) ; if ( enable Batching ) { logger . info ( STRING , this . max Batch Size ) ; } else { logger . info ( STRING ) ; } }
public Generic Table Handler ( Json Value table Config , String db Schema Name , Json Value queries Config , Json Value commands Config , int max Batch Size , SQL Exception Handler sql Exception Handler ) { cfg = Generic Table Config . parse ( table Config ) ; this . main Table Name = cfg . main Table Name ; this . prop Table Name = cfg . properties Table Name ; this . db Schema Name = db Schema Name ; if ( max Batch Size < NUM ) { this . max Batch Size = NUM ; } else { this . max Batch Size = max Batch Size ; } if ( sql Exception Handler == null ) { this . sql Exception Handler = new Default SQL Exception Handler ( ) ; } else { this . sql Exception Handler = sql Exception Handler ; } queries = new Table Queries ( this , main Table Name , prop Table Name , db Schema Name , get Searchable Length ( ) , new Generic Query Result Mapper ( ) ) ; query Map = Collections . unmodifiable Map ( initialize Query Map ( ) ) ; queries . set Configured Queries ( queries Config , commands Config , query Map ) ; enable Batching = ( this . max Batch Size > NUM ) ; if ( enable Batching ) { logger . info ( STRING , this . max Batch Size ) ; } else { logger . info ( STRING ) ; } }
public Generic Table Handler ( Json Value table Config , String db Schema Name , Json Value queries Config , Json Value commands Config , int max Batch Size , SQL Exception Handler sql Exception Handler ) { cfg = Generic Table Config . parse ( table Config ) ; this . main Table Name = cfg . main Table Name ; this . prop Table Name = cfg . properties Table Name ; this . db Schema Name = db Schema Name ; if ( max Batch Size < NUM ) { this . max Batch Size = NUM ; } else { this . max Batch Size = max Batch Size ; } if ( sql Exception Handler == null ) { this . sql Exception Handler = new Default SQL Exception Handler ( ) ; } else { this . sql Exception Handler = sql Exception Handler ; } queries = new Table Queries ( this , main Table Name , prop Table Name , db Schema Name , get Searchable Length ( ) , new Generic Query Result Mapper ( ) ) ; query Map = Collections . unmodifiable Map ( initialize Query Map ( ) ) ; queries . set Configured Queries ( queries Config , commands Config , query Map ) ; enable Batching = ( this . max Batch Size > NUM ) ; if ( enable Batching ) { logger . info ( STRING , this . max Batch Size ) ; } else { logger . info ( STRING ) ; } }
public Generic Table Handler ( Json Value table Config , String db Schema Name , Json Value queries Config , Json Value commands Config , int max Batch Size , SQL Exception Handler sql Exception Handler ) { cfg = Generic Table Config . parse ( table Config ) ; this . main Table Name = cfg . main Table Name ; this . prop Table Name = cfg . properties Table Name ; this . db Schema Name = db Schema Name ; if ( max Batch Size < NUM ) { this . max Batch Size = NUM ; } else { this . max Batch Size = max Batch Size ; } if ( sql Exception Handler == null ) { this . sql Exception Handler = new Default SQL Exception Handler ( ) ; } else { this . sql Exception Handler = sql Exception Handler ; } queries = new Table Queries ( this , main Table Name , prop Table Name , db Schema Name , get Searchable Length ( ) , new Generic Query Result Mapper ( ) ) ; query Map = Collections . unmodifiable Map ( initialize Query Map ( ) ) ; queries . set Configured Queries ( queries Config , commands Config , query Map ) ; enable Batching = ( this . max Batch Size > NUM ) ; if ( enable Batching ) { logger . info ( STRING , this . max Batch Size ) ; } else { logger . info ( STRING ) ; } }
public double norm ( ) { return Math . sqrt ( x * x + y * y + z * z ) ; }
private List < Solution > normalize ( Population population ) { List < Solution > result = new Array List < Solution > ( ) ; double [ ] min = new double [ problem . get Number Of Objectives ( ) ] ; double [ ] max = new double [ problem . get Number Of Objectives ( ) ] ; Arrays . fill ( min , Double . POSITIVE INFINITY ) ; Arrays . fill ( max , Double . NEGATIVE INFINITY ) ; for ( Solution solution : population ) { for ( int i = NUM ; i < problem . get Number Of Objectives ( ) ; i ++ ) { min [ i ] = Math . min ( min [ i ] , solution . get Objective ( i ) ) ; max [ i ] = Math . max ( max [ i ] , solution . get Objective ( i ) ) ; } } for ( Solution solution : population ) { Solution new Solution = solution . copy ( ) ; for ( int i = NUM ; i < problem . get Number Of Objectives ( ) ; i ++ ) { new Solution . set Objective ( i , ( max [ i ] - ( new Solution . get Objective ( i ) - min [ i ] ) + offset ) / ( max [ i ] - min [ i ] ) ) ; } result . add ( new Solution ) ; } return result ; }
private static Object run ( String expr , Map < String , Object > variables ) { Stellar Processor processor = new Stellar Processor ( ) ; Object ret = processor . parse ( expr , null , Stellar Functions . FUNCTION RESOLVER ( ) , Context . EMPTY CONTEXT ( ) ) ; byte [ ] raw = Ser De Utils . to Bytes ( ret ) ; Object actual = Ser De Utils . from Bytes ( raw , Object . class ) ; if ( ret instanceof Statistics Provider ) { Statistics Provider left = ( Statistics Provider ) ret ; Statistics Provider right = ( Statistics Provider ) actual ; tolerant Assert Equals ( null , left , right ) ; tolerant Assert Equals ( null , left , right , NUM ) ; tolerant Assert Equals ( null , left , right , NUM ) ; tolerant Assert Equals ( null , left , right , NUM ) ; tolerant Assert Equals ( null , left , right , NUM ) ; tolerant Assert Equals ( null , left , right , NUM ) ; tolerant Assert Equals ( null , left , right , NUM ) ; tolerant Assert Equals ( null , left , right , NUM ) ; tolerant Assert Equals ( null , left , right , NUM ) ; tolerant Assert Equals ( null , left , right , NUM ) ; tolerant Assert Equals ( null , left , right , NUM ) ; tolerant Assert Equals ( null , left , right , NUM ) ; for ( double d = NUM ; d < NUM ; d += NUM ) { final double pctile = d ; tolerant Assert Equals ( null , left , right , NUM ) ; } } return ret ; }
public Property XML Builder ( Service Schema service Schema , AM Model model , Set attribute Schemas ) throws SMS Exception , SSO Exception { this . model = model ; this . service Name = service Schema . get Service Name ( ) ; get Service Resource Bundle ( service Schema ) ; if ( service Bundle != null ) { map Type To Attribute Schema = new Hash Map ( attribute Schemas . size ( ) * NUM ) ; map Type To Attribute Schema . put ( NULL TYPE , attribute Schemas ) ; } }
public Property XML Builder ( Service Schema service Schema , AM Model model , Set attribute Schemas ) throws SMS Exception , SSO Exception { this . model = model ; this . service Name = service Schema . get Service Name ( ) ; get Service Resource Bundle ( service Schema ) ; if ( service Bundle != null ) { map Type To Attribute Schema = new Hash Map ( attribute Schemas . size ( ) * NUM ) ; map Type To Attribute Schema . put ( NULL TYPE , attribute Schemas ) ; } }
private void basic Invalidate ( final Entry Event Impl event , boolean invoke Callbacks ) throws Entry Not Found Exception { basic Invalidate ( event , invoke Callbacks , BOOL ) ; }
private HTTPS Properties create Permissive HTTPS Properties ( ) throws Exception { SSL Context sc = null ; sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trusting Trust Manager , new Secure Random ( ) ) ; return new HTTPS Properties ( trusting Host Verifier , sc ) ; }
private HTTPS Properties create Permissive HTTPS Properties ( ) throws Exception { SSL Context sc = null ; sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trusting Trust Manager , new Secure Random ( ) ) ; return new HTTPS Properties ( trusting Host Verifier , sc ) ; }
private HTTPS Properties create Permissive HTTPS Properties ( ) throws Exception { SSL Context sc = null ; sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trusting Trust Manager , new Secure Random ( ) ) ; return new HTTPS Properties ( trusting Host Verifier , sc ) ; }
private HTTPS Properties create Permissive HTTPS Properties ( ) throws Exception { SSL Context sc = null ; sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trusting Trust Manager , new Secure Random ( ) ) ; return new HTTPS Properties ( trusting Host Verifier , sc ) ; }
private HTTPS Properties create Permissive HTTPS Properties ( ) throws Exception { SSL Context sc = null ; sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trusting Trust Manager , new Secure Random ( ) ) ; return new HTTPS Properties ( trusting Host Verifier , sc ) ; }
protected void expand Capacity ( ) { String [ ] new Array = new String [ array . length << NUM ] ; System . arraycopy ( array , NUM , new Array , NUM , index ) ; array = new Array ; }
private float [ ] [ ] do Polar Fill Correction ( float [ ] xpoints , float [ ] ypoints , int y1 ) { float [ ] [ ] ret = new float [ NUM ] [ ] ; int len = xpoints . length ; float [ ] alt xpts = new float [ len + NUM ] ; float [ ] alt ypts = new float [ len + NUM ] ; System . arraycopy ( xpoints , NUM , alt xpts , NUM , len ) ; System . arraycopy ( ypoints , NUM , alt ypts , NUM , len ) ; alt xpts [ len ] = alt xpts [ len - NUM ] ; alt xpts [ len + NUM ] = alt xpts [ NUM ] ; alt ypts [ len ] = y1 ; alt ypts [ len + NUM ] = alt ypts [ len ] ; ret [ NUM ] = alt xpts ; ret [ NUM ] = alt ypts ; return ret ; }
public long count ( ) { return count . get ( ) ; }
public Driver Task expand Volume ( Storage Volume storage Volume , long new Capacity ) { Driver Task task = new Dell SC Driver Task ( STRING ) ; try { Storage Center API api = connection Manager . get Connection ( storage Volume . get Storage System Id ( ) ) ; Sc Volume sc Vol = api . expand Volume ( storage Volume . get Native Id ( ) , Size Util . byte To Meg ( new Capacity ) ) ; storage Volume . set Provisioned Capacity ( Size Util . size Str To Bytes ( sc Vol . configured Size ) ) ; task . set Status ( Task Status . READY ) ; LOG . info ( STRING , sc Vol . name ) ; } catch ( Dell SC Driver Exception | Storage Center API Exception dex ) { String error = String . format ( STRING , storage Volume . get Display Name ( ) , dex ) ; LOG . error ( error ) ; task . set Message ( error ) ; task . set Status ( Task Status . FAILED ) ; } return task ; }
public static Sequences Reader create Sequences Reader ( final Sequence Data Source source ) throws IO Exception { final List < byte [ ] > data = new Array List < > ( ) ; final List < String > labels = new Array List < > ( ) ; final List < Long > counts = new Array List < > ( ) ; int min = Integer . MAX VALUE ; int max = Integer . MIN VALUE ; while ( source . next Sequence ( ) ) { final byte [ ] b = new byte [ source . current Length ( ) ] ; System . arraycopy ( source . sequence Data ( ) , NUM , b , NUM , source . current Length ( ) ) ; data . add ( b ) ; labels . add ( source . name ( ) ) ; counts . add ( ( long ) source . current Length ( ) ) ; min = Math . min ( min , source . current Length ( ) ) ; max = Math . max ( max , source . current Length ( ) ) ; } final byte [ ] [ ] data Array = data . to Array ( new byte [ data . size ( ) ] [ ] ) ; final String [ ] labels Array = labels . to Array ( new String [ labels . size ( ) ] ) ; return new Compressed Memory Sequences Reader ( data Array , labels Array , Array Utils . as Long Array ( counts ) , min , max , source . type ( ) ) ; }
public static String java Escape ( String s ) { String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; switch ( c ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; default : sb . append ( c ) ; } } return sb . to String ( ) ; }
public Statement is Not Null ( ) { statement . append ( STRING ) ; return this ; }
public void add Option ( String name , String value ) { if ( options == null ) options = new Linked List < Repl Option > ( ) ; options . add ( new Repl Option ( name , value ) ) ; }
public void add Option ( String name , String value ) { if ( options == null ) options = new Linked List < Repl Option > ( ) ; options . add ( new Repl Option ( name , value ) ) ; }
public void add Option ( String name , String value ) { if ( options == null ) options = new Linked List < Repl Option > ( ) ; options . add ( new Repl Option ( name , value ) ) ; }
protected void uncheck ( ) { checkmark . set Attribute ( SVG Constants . SVG STYLE ATTRIBUTE , SVG Constants . CSS DISPLAY PROPERTY + STRING + SVG Constants . CSS NONE VALUE ) ; checked = BOOL ; fire Switch Event ( new Change Event ( SVG Checkbox . this ) ) ; }
protected void uncheck ( ) { checkmark . set Attribute ( SVG Constants . SVG STYLE ATTRIBUTE , SVG Constants . CSS DISPLAY PROPERTY + STRING + SVG Constants . CSS NONE VALUE ) ; checked = BOOL ; fire Switch Event ( new Change Event ( SVG Checkbox . this ) ) ; }
public Solr Config ( ) throws Parser Configuration Exception , IO Exception , SAX Exception { this ( ( Solr Resource Loader ) null , DEFAULT CONF FILE , null ) ; }
protected String format ( Object o ) { return o . to String ( ) ; }
protected String format ( Object o ) { return o . to String ( ) ; }
public void register ( Grid Cache Ttl Manager mgr ) { synchronized ( mux ) { if ( cleanup Worker == null ) start Cleanup Worker ( ) ; mgrs . add ( mgr ) ; } }
public void alias ( final String name , final Class < ? > type , final Class < ? > default Implementation ) { alias ( name , type ) ; add Default Implementation ( default Implementation , type ) ; }
public void alias ( final String name , final Class < ? > type , final Class < ? > default Implementation ) { alias ( name , type ) ; add Default Implementation ( default Implementation , type ) ; }
@ Override public void fill Oval ( int x , int y , int width , int height ) { set State To Local ( ) ; m printstream . println ( x Transform ( x Scale ( x ) ) + STRING + y Transform ( y Scale ( y ) ) + STRING + x Scale ( width ) + STRING + y Scale ( height ) + STRING ) ; }
public void add Mech Display Listener ( Mech Display Listener listener ) { event Listeners . add ( listener ) ; }
public void add Mech Display Listener ( Mech Display Listener listener ) { event Listeners . add ( listener ) ; }
public void add Mech Display Listener ( Mech Display Listener listener ) { event Listeners . add ( listener ) ; }
private void populate Time Fields ( ) { left Store . set Time Fields ( time Field Str . split ( STRING ) [ NUM ] ) ; right Store . set Time Fields ( time Field Str . split ( STRING ) [ NUM ] ) ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof Rule ) ) { return BOOL ; } Rule other = ( Rule ) o ; if ( get LHS ( ) != other . get LHS ( ) ) { return BOOL ; } if ( ! Arrays . equals ( get French ( ) , other . get French ( ) ) ) { return BOOL ; } return Arrays . equals ( target , other . get English ( ) ) ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof Rule ) ) { return BOOL ; } Rule other = ( Rule ) o ; if ( get LHS ( ) != other . get LHS ( ) ) { return BOOL ; } if ( ! Arrays . equals ( get French ( ) , other . get French ( ) ) ) { return BOOL ; } return Arrays . equals ( target , other . get English ( ) ) ; }
public Sided Plane ( final double pX , final double pY , final double pZ , final Vector A , final Vector B ) { super ( A , B ) ; sig Num = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sig Num == NUM ) throw new Illegal Argument Exception ( STRING ) ; }
public Sided Plane ( final double pX , final double pY , final double pZ , final Vector A , final Vector B ) { super ( A , B ) ; sig Num = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sig Num == NUM ) throw new Illegal Argument Exception ( STRING ) ; }
public Sided Plane ( final double pX , final double pY , final double pZ , final Vector A , final Vector B ) { super ( A , B ) ; sig Num = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sig Num == NUM ) throw new Illegal Argument Exception ( STRING ) ; }
public Sided Plane ( final double pX , final double pY , final double pZ , final Vector A , final Vector B ) { super ( A , B ) ; sig Num = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sig Num == NUM ) throw new Illegal Argument Exception ( STRING ) ; }
public void test Local Instances deterministic ( ) { Matsim Random . reset ( ) ; Random local 1 a = Matsim Random . get Local Instance ( ) ; Random local 1 b = Matsim Random . get Local Instance ( ) ; Matsim Random . reset ( ) ; Random local 2 a = Matsim Random . get Local Instance ( ) ; Random local 2 b = Matsim Random . get Local Instance ( ) ; assert Equal Random Number Generators ( local 1 a , local 2 a ) ; assert Equal Random Number Generators ( local 1 b , local 2 b ) ; }
public void test Local Instances deterministic ( ) { Matsim Random . reset ( ) ; Random local 1 a = Matsim Random . get Local Instance ( ) ; Random local 1 b = Matsim Random . get Local Instance ( ) ; Matsim Random . reset ( ) ; Random local 2 a = Matsim Random . get Local Instance ( ) ; Random local 2 b = Matsim Random . get Local Instance ( ) ; assert Equal Random Number Generators ( local 1 a , local 2 a ) ; assert Equal Random Number Generators ( local 1 b , local 2 b ) ; }
public void test Local Instances deterministic ( ) { Matsim Random . reset ( ) ; Random local 1 a = Matsim Random . get Local Instance ( ) ; Random local 1 b = Matsim Random . get Local Instance ( ) ; Matsim Random . reset ( ) ; Random local 2 a = Matsim Random . get Local Instance ( ) ; Random local 2 b = Matsim Random . get Local Instance ( ) ; assert Equal Random Number Generators ( local 1 a , local 2 a ) ; assert Equal Random Number Generators ( local 1 b , local 2 b ) ; }
public void load ( File Location loc , String default Enc ) throws IO Exception { this . loc = loc ; if ( loc . is Local ( ) && ! loc . is Local And Exists ( ) ) { this . char Set = default Enc != null ? default Enc : get Default Encoding ( ) ; return ; } Unicode Reader ur = new Unicode Reader ( loc . get Input Stream ( ) , default Enc ) ; char Set = ur . get Encoding ( ) ; Document doc = get Document ( ) ; doc . remove Document Listener ( this ) ; Buffered Reader r = new Buffered Reader ( ur ) ; try { read ( r , null ) ; } finally { doc . add Document Listener ( this ) ; r . close ( ) ; } }
public void start Auto Scroll ( String increment ) { this . auto Scrolling = BOOL ; this . auto Scroll Increment = increment ; }
public void start Auto Scroll ( String increment ) { this . auto Scrolling = BOOL ; this . auto Scroll Increment = increment ; }
public void add Termination Script ( String pathname ) { termination Scripts . add ( pathname ) ; set Dirty And Fire Property Change ( STRING , pathname , null ) ; }
public void add Termination Script ( String pathname ) { termination Scripts . add ( pathname ) ; set Dirty And Fire Property Change ( STRING , pathname , null ) ; }
public static Literal parse Literal ( String n Triples Literal , Value Factory value Factory ) throws Illegal Argument Exception { if ( n Triples Literal . starts With ( STRING ) ) { int end Label Idx = find End Of Label ( n Triples Literal ) ; if ( end Label Idx != - NUM ) { int start Lang Idx = n Triples Literal . index Of ( STRING , end Label Idx ) ; int start Dt Idx = n Triples Literal . index Of ( STRING , end Label Idx ) ; if ( start Lang Idx != - NUM && start Dt Idx != - NUM ) { throw new Illegal Argument Exception ( STRING ) ; } String label = n Triples Literal . substring ( NUM , end Label Idx ) ; label = unescape String ( label ) ; if ( start Lang Idx != - NUM ) { String language = n Triples Literal . substring ( start Lang Idx + NUM ) ; return value Factory . create Literal ( label , language ) ; } else if ( start Dt Idx != - NUM ) { String datatype = n Triples Literal . substring ( start Dt Idx + NUM ) ; IRI dt URI = parse URI ( datatype , value Factory ) ; return value Factory . create Literal ( label , dt URI ) ; } else { return value Factory . create Literal ( label ) ; } } } throw new Illegal Argument Exception ( STRING + n Triples Literal ) ; }
public static Literal parse Literal ( String n Triples Literal , Value Factory value Factory ) throws Illegal Argument Exception { if ( n Triples Literal . starts With ( STRING ) ) { int end Label Idx = find End Of Label ( n Triples Literal ) ; if ( end Label Idx != - NUM ) { int start Lang Idx = n Triples Literal . index Of ( STRING , end Label Idx ) ; int start Dt Idx = n Triples Literal . index Of ( STRING , end Label Idx ) ; if ( start Lang Idx != - NUM && start Dt Idx != - NUM ) { throw new Illegal Argument Exception ( STRING ) ; } String label = n Triples Literal . substring ( NUM , end Label Idx ) ; label = unescape String ( label ) ; if ( start Lang Idx != - NUM ) { String language = n Triples Literal . substring ( start Lang Idx + NUM ) ; return value Factory . create Literal ( label , language ) ; } else if ( start Dt Idx != - NUM ) { String datatype = n Triples Literal . substring ( start Dt Idx + NUM ) ; IRI dt URI = parse URI ( datatype , value Factory ) ; return value Factory . create Literal ( label , dt URI ) ; } else { return value Factory . create Literal ( label ) ; } } } throw new Illegal Argument Exception ( STRING + n Triples Literal ) ; }
public static Literal parse Literal ( String n Triples Literal , Value Factory value Factory ) throws Illegal Argument Exception { if ( n Triples Literal . starts With ( STRING ) ) { int end Label Idx = find End Of Label ( n Triples Literal ) ; if ( end Label Idx != - NUM ) { int start Lang Idx = n Triples Literal . index Of ( STRING , end Label Idx ) ; int start Dt Idx = n Triples Literal . index Of ( STRING , end Label Idx ) ; if ( start Lang Idx != - NUM && start Dt Idx != - NUM ) { throw new Illegal Argument Exception ( STRING ) ; } String label = n Triples Literal . substring ( NUM , end Label Idx ) ; label = unescape String ( label ) ; if ( start Lang Idx != - NUM ) { String language = n Triples Literal . substring ( start Lang Idx + NUM ) ; return value Factory . create Literal ( label , language ) ; } else if ( start Dt Idx != - NUM ) { String datatype = n Triples Literal . substring ( start Dt Idx + NUM ) ; IRI dt URI = parse URI ( datatype , value Factory ) ; return value Factory . create Literal ( label , dt URI ) ; } else { return value Factory . create Literal ( label ) ; } } } throw new Illegal Argument Exception ( STRING + n Triples Literal ) ; }
private void print To Host ( String host , int port , byte [ ] cmds ) throws IO Exception { log . debug ( STRING , host , port ) ; try ( Socket socket = new Socket ( host , port ) ; Data Output Stream out = new Data Output Stream ( socket . get Output Stream ( ) ) ) { out . write ( cmds ) ; } }
private void print To Host ( String host , int port , byte [ ] cmds ) throws IO Exception { log . debug ( STRING , host , port ) ; try ( Socket socket = new Socket ( host , port ) ; Data Output Stream out = new Data Output Stream ( socket . get Output Stream ( ) ) ) { out . write ( cmds ) ; } }
private void print To Host ( String host , int port , byte [ ] cmds ) throws IO Exception { log . debug ( STRING , host , port ) ; try ( Socket socket = new Socket ( host , port ) ; Data Output Stream out = new Data Output Stream ( socket . get Output Stream ( ) ) ) { out . write ( cmds ) ; } }
private void print To Host ( String host , int port , byte [ ] cmds ) throws IO Exception { log . debug ( STRING , host , port ) ; try ( Socket socket = new Socket ( host , port ) ; Data Output Stream out = new Data Output Stream ( socket . get Output Stream ( ) ) ) { out . write ( cmds ) ; } }
private void print To Host ( String host , int port , byte [ ] cmds ) throws IO Exception { log . debug ( STRING , host , port ) ; try ( Socket socket = new Socket ( host , port ) ; Data Output Stream out = new Data Output Stream ( socket . get Output Stream ( ) ) ) { out . write ( cmds ) ; } }
private void print To Host ( String host , int port , byte [ ] cmds ) throws IO Exception { log . debug ( STRING , host , port ) ; try ( Socket socket = new Socket ( host , port ) ; Data Output Stream out = new Data Output Stream ( socket . get Output Stream ( ) ) ) { out . write ( cmds ) ; } }
private void print To Host ( String host , int port , byte [ ] cmds ) throws IO Exception { log . debug ( STRING , host , port ) ; try ( Socket socket = new Socket ( host , port ) ; Data Output Stream out = new Data Output Stream ( socket . get Output Stream ( ) ) ) { out . write ( cmds ) ; } }
private View find Current Center View ( ) { float center X = get Width ( ) / NUM ; float view Half Width = settings . get View Width Px ( ) / NUM ; View nearest To Center View = null ; int nearest Delta X = NUM ; View item ; int center X View ; for ( int count = get Child Count ( ) , i = NUM ; i < count ; i ++ ) { item = get Child At ( i ) ; center X View = ( int ) ( get Decorated Left ( item ) + view Half Width ) ; if ( nearest To Center View == null || Math . abs ( nearest Delta X ) > Math . abs ( center X - center X View ) ) { nearest To Center View = item ; nearest Delta X = ( int ) ( center X - center X View ) ; } } return nearest To Center View ; }
private View find Current Center View ( ) { float center X = get Width ( ) / NUM ; float view Half Width = settings . get View Width Px ( ) / NUM ; View nearest To Center View = null ; int nearest Delta X = NUM ; View item ; int center X View ; for ( int count = get Child Count ( ) , i = NUM ; i < count ; i ++ ) { item = get Child At ( i ) ; center X View = ( int ) ( get Decorated Left ( item ) + view Half Width ) ; if ( nearest To Center View == null || Math . abs ( nearest Delta X ) > Math . abs ( center X - center X View ) ) { nearest To Center View = item ; nearest Delta X = ( int ) ( center X - center X View ) ; } } return nearest To Center View ; }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( bayes Im == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( bayes Im == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( bayes Im == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( bayes Im == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( bayes Im == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( bayes Im == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( bayes Im == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( bayes Im == null ) { throw new Null Pointer Exception ( ) ; } }
@ Override protected Change configure Cache Object ( Sub Equipment sub Equipment , Properties properties ) { Sub Equipment Cache Object sub Equipment Cache Object = ( Sub Equipment Cache Object ) sub Equipment ; Equipment Configuration Update update = set Common Properties ( sub Equipment , properties ) ; String tmp Str = properties . get Property ( STRING ) ; if ( tmp Str == null ) { tmp Str = properties . get Property ( STRING ) ; } if ( tmp Str != null ) { try { sub Equipment Cache Object . set Parent Id ( Long . value Of ( tmp Str ) ) ; } catch ( Number Format Exception e ) { throw new Configuration Exception ( Configuration Exception . INVALID PARAMETER VALUE , STRING + tmp Str ) ; } } return update ; }
public Activation Group Impl ( Activation Group ID id , Marshalled Object < ? > data ) throws Remote Exception { super ( id ) ; group ID = id ; unexport Object ( this , BOOL ) ; RMI Server Socket Factory ssf = new Server Socket Factory Impl ( ) ; Unicast Remote Object . export Object ( this , NUM , null , ssf ) ; if ( System . get Security Manager ( ) == null ) { try { System . set Security Manager ( new Security Manager ( ) ) ; } catch ( Exception e ) { throw new Remote Exception ( STRING , e ) ; } } }
private static String unescape Path Component ( String name ) { return name . replace All ( STRING , STRING ) ; }
private static String unescape Path Component ( String name ) { return name . replace All ( STRING , STRING ) ; }
private static String unescape Path Component ( String name ) { return name . replace All ( STRING , STRING ) ; }
private static String unescape Path Component ( String name ) { return name . replace All ( STRING , STRING ) ; }
private static String unescape Path Component ( String name ) { return name . replace All ( STRING , STRING ) ; }
public void table Changed ( Table Model Event e ) { initialize Sort Indices ( ) ; if ( is Sorted ( ) ) sort ( m Sort Column , m Sort Ascending ) ; fire Table Changed ( e ) ; }
public void table Changed ( Table Model Event e ) { initialize Sort Indices ( ) ; if ( is Sorted ( ) ) sort ( m Sort Column , m Sort Ascending ) ; fire Table Changed ( e ) ; }
public void table Changed ( Table Model Event e ) { initialize Sort Indices ( ) ; if ( is Sorted ( ) ) sort ( m Sort Column , m Sort Ascending ) ; fire Table Changed ( e ) ; }
private void add Minimized Section ( Composite parent , Form Toolkit toolkit , String section Title , int num Colums ) { Section section = toolkit . create Section ( parent , Expandable Composite . TITLE BAR | Expandable Composite . TWISTIE ) ; section . set Text ( section Title ) ; section . set Layout Data ( new Grid Data ( SWT . FILL , SWT . FILL , BOOL , BOOL ) ) ; Composite section Composite = toolkit . create Composite ( section ) ; Grid Layout grid Layout = new Grid Layout ( num Colums , BOOL ) ; grid Layout . margin Left = NUM ; grid Layout . margin Top = NUM ; section Composite . set Layout ( grid Layout ) ; section . set Client ( section Composite ) ; if ( ! minimized Sections . contains Key ( section Title ) ) { minimized Sections . put ( section Title , section Composite ) ; } }
private void add Minimized Section ( Composite parent , Form Toolkit toolkit , String section Title , int num Colums ) { Section section = toolkit . create Section ( parent , Expandable Composite . TITLE BAR | Expandable Composite . TWISTIE ) ; section . set Text ( section Title ) ; section . set Layout Data ( new Grid Data ( SWT . FILL , SWT . FILL , BOOL , BOOL ) ) ; Composite section Composite = toolkit . create Composite ( section ) ; Grid Layout grid Layout = new Grid Layout ( num Colums , BOOL ) ; grid Layout . margin Left = NUM ; grid Layout . margin Top = NUM ; section Composite . set Layout ( grid Layout ) ; section . set Client ( section Composite ) ; if ( ! minimized Sections . contains Key ( section Title ) ) { minimized Sections . put ( section Title , section Composite ) ; } }
private void add Minimized Section ( Composite parent , Form Toolkit toolkit , String section Title , int num Colums ) { Section section = toolkit . create Section ( parent , Expandable Composite . TITLE BAR | Expandable Composite . TWISTIE ) ; section . set Text ( section Title ) ; section . set Layout Data ( new Grid Data ( SWT . FILL , SWT . FILL , BOOL , BOOL ) ) ; Composite section Composite = toolkit . create Composite ( section ) ; Grid Layout grid Layout = new Grid Layout ( num Colums , BOOL ) ; grid Layout . margin Left = NUM ; grid Layout . margin Top = NUM ; section Composite . set Layout ( grid Layout ) ; section . set Client ( section Composite ) ; if ( ! minimized Sections . contains Key ( section Title ) ) { minimized Sections . put ( section Title , section Composite ) ; } }
public void add UI ( Component component , int buffer , int width , int height ) { if ( field Panel != null ) { int last X = - NUM ; for ( Component c : field Panel . get Components ( ) ) { int x = c . get X ( ) + c . get Width ( ) ; if ( x > last X ) { last X = x ; } } component . set Bounds ( last X + buffer , NUM , width , height ) ; field Panel . add ( component ) ; } }
private void calc Coordinates ( final float x , final float [ ] [ ] Trm , float char Spacing ) { final float [ ] [ ] trm = new float [ NUM ] [ NUM ] ; for ( int xx = NUM ; xx < NUM ; xx ++ ) { System . arraycopy ( Trm [ xx ] , NUM , trm [ xx ] , NUM , NUM ) ; } x1 = x ; x2 = trm [ NUM ] [ NUM ] - ( char Spacing * trm [ NUM ] [ NUM ] ) ; if ( glyph Data . is Horizontal ( ) ) { if ( trm [ NUM ] [ NUM ] < NUM ) { x1 = x + trm [ NUM ] [ NUM ] - ( char Spacing * trm [ NUM ] [ NUM ] ) ; x2 = trm [ NUM ] [ NUM ] ; } else if ( trm [ NUM ] [ NUM ] > NUM ) { x1 = x ; x2 = trm [ NUM ] [ NUM ] ; } } else if ( trm [ NUM ] [ NUM ] > NUM ) { x1 = trm [ NUM ] [ NUM ] ; x2 = x + trm [ NUM ] [ NUM ] - ( char Spacing * trm [ NUM ] [ NUM ] ) ; } else if ( trm [ NUM ] [ NUM ] < NUM ) { x2 = trm [ NUM ] [ NUM ] ; x1 = x + trm [ NUM ] [ NUM ] - ( char Spacing * trm [ NUM ] [ NUM ] ) ; } }
private void calc Coordinates ( final float x , final float [ ] [ ] Trm , float char Spacing ) { final float [ ] [ ] trm = new float [ NUM ] [ NUM ] ; for ( int xx = NUM ; xx < NUM ; xx ++ ) { System . arraycopy ( Trm [ xx ] , NUM , trm [ xx ] , NUM , NUM ) ; } x1 = x ; x2 = trm [ NUM ] [ NUM ] - ( char Spacing * trm [ NUM ] [ NUM ] ) ; if ( glyph Data . is Horizontal ( ) ) { if ( trm [ NUM ] [ NUM ] < NUM ) { x1 = x + trm [ NUM ] [ NUM ] - ( char Spacing * trm [ NUM ] [ NUM ] ) ; x2 = trm [ NUM ] [ NUM ] ; } else if ( trm [ NUM ] [ NUM ] > NUM ) { x1 = x ; x2 = trm [ NUM ] [ NUM ] ; } } else if ( trm [ NUM ] [ NUM ] > NUM ) { x1 = trm [ NUM ] [ NUM ] ; x2 = x + trm [ NUM ] [ NUM ] - ( char Spacing * trm [ NUM ] [ NUM ] ) ; } else if ( trm [ NUM ] [ NUM ] < NUM ) { x2 = trm [ NUM ] [ NUM ] ; x1 = x + trm [ NUM ] [ NUM ] - ( char Spacing * trm [ NUM ] [ NUM ] ) ; } }
private static void analyze New String Set Contains Old String Set Values ( String Set a , String Set b , String name , Hash Map < String , Change > changes ) { if ( a != null ) { Iterator < String > iter = a . iterator ( ) ; while ( iter . has Next ( ) ) { String val = iter . next ( ) ; if ( b != null && b . contains ( val ) ) { continue ; } String key = name + STRING + val ; Change change = new Change ( key , val , null , name ) ; changes . put ( key , change ) ; } } else if ( a == null && b != null ) { String key = name ; Change change = new Change ( key , null , NOT NULL , name ) ; changes . put ( key , change ) ; } }
private static void analyze New String Set Contains Old String Set Values ( String Set a , String Set b , String name , Hash Map < String , Change > changes ) { if ( a != null ) { Iterator < String > iter = a . iterator ( ) ; while ( iter . has Next ( ) ) { String val = iter . next ( ) ; if ( b != null && b . contains ( val ) ) { continue ; } String key = name + STRING + val ; Change change = new Change ( key , val , null , name ) ; changes . put ( key , change ) ; } } else if ( a == null && b != null ) { String key = name ; Change change = new Change ( key , null , NOT NULL , name ) ; changes . put ( key , change ) ; } }
private static void analyze New String Set Contains Old String Set Values ( String Set a , String Set b , String name , Hash Map < String , Change > changes ) { if ( a != null ) { Iterator < String > iter = a . iterator ( ) ; while ( iter . has Next ( ) ) { String val = iter . next ( ) ; if ( b != null && b . contains ( val ) ) { continue ; } String key = name + STRING + val ; Change change = new Change ( key , val , null , name ) ; changes . put ( key , change ) ; } } else if ( a == null && b != null ) { String key = name ; Change change = new Change ( key , null , NOT NULL , name ) ; changes . put ( key , change ) ; } }
public void add ( final Position Change Listener listener ) { listeners . add ( listener ) ; }
public int add Output ( ) { int index = outputs . size ( ) ; outputs . add ( Functions . discard ( ) ) ; output Context . add ( DEFAULT OUTPUT CONTEXT ) ; return index ; }
public int add Output ( ) { int index = outputs . size ( ) ; outputs . add ( Functions . discard ( ) ) ; output Context . add ( DEFAULT OUTPUT CONTEXT ) ; return index ; }
public int add Output ( ) { int index = outputs . size ( ) ; outputs . add ( Functions . discard ( ) ) ; output Context . add ( DEFAULT OUTPUT CONTEXT ) ; return index ; }
public void clear Account Disabled State ( ) { operations . add ( Password Policy State Operation Type . CLEAR ACCOUNT DISABLED STATE ) ; }
private void add ( int [ ] ngram , long value , long [ ] [ ] funcs ) { if ( ngram == null ) return ; int q Value = quantize ( value ) ; for ( int i = NUM ; i <= q Value ; i ++ ) { int hash = hash Ngram ( ngram , NUM , ngram . length , i ) ; bf . add ( hash , funcs ) ; } }
private void add ( int [ ] ngram , long value , long [ ] [ ] funcs ) { if ( ngram == null ) return ; int q Value = quantize ( value ) ; for ( int i = NUM ; i <= q Value ; i ++ ) { int hash = hash Ngram ( ngram , NUM , ngram . length , i ) ; bf . add ( hash , funcs ) ; } }
private void add ( int [ ] ngram , long value , long [ ] [ ] funcs ) { if ( ngram == null ) return ; int q Value = quantize ( value ) ; for ( int i = NUM ; i <= q Value ; i ++ ) { int hash = hash Ngram ( ngram , NUM , ngram . length , i ) ; bf . add ( hash , funcs ) ; } }
private void add ( int [ ] ngram , long value , long [ ] [ ] funcs ) { if ( ngram == null ) return ; int q Value = quantize ( value ) ; for ( int i = NUM ; i <= q Value ; i ++ ) { int hash = hash Ngram ( ngram , NUM , ngram . length , i ) ; bf . add ( hash , funcs ) ; } }
public < T extends Enum < T > > T consume Enum ( String name , boolean required , Class < T > enum Class , T default Value ) throws Parse Exception { String value = consume ( name , required ) ; if ( value == null ) { return default Value ; } try { return Enum . value Of ( enum Class , value . to Upper Case ( ) ) ; } catch ( Illegal Argument Exception e ) { Parse Exception pe = new Parse Exception ( Core Error Domain . ERR . invalid Attribute Value , e ) ; pe . set Internal Reason ( STRING + name + STRING ) ; throw pe ; } }
public void stop ( ) { duration += System . current Time Millis ( ) - start ; }
public static String clear Event ( Http Servlet Request request , Http Servlet Response response ) { String err Msg = STRING ; Locale locale = Util Http . get Locale ( request ) ; Security security = ( Security ) request . get Attribute ( STRING ) ; if ( ! security . has Permission ( STRING , request . get Session ( ) ) ) { err Msg = Util Properties . get Message ( Util Cache Events . err resource , STRING , locale ) + STRING ; request . set Attribute ( STRING , err Msg ) ; return STRING ; } String name = request . get Parameter ( STRING ) ; if ( name == null ) { err Msg = Util Properties . get Message ( Util Cache Events . err resource , STRING , locale ) + STRING ; request . set Attribute ( STRING , err Msg ) ; return STRING ; } Util Cache < ? , ? > util Cache = Util Cache . find Cache ( name ) ; if ( util Cache != null ) { util Cache . clear ( ) ; err Msg = Util Properties . get Message ( Util Cache Events . err resource , STRING , Util Misc . to Map ( STRING , name ) , locale ) + STRING ; request . set Attribute ( STRING , err Msg ) ; } else { err Msg = Util Properties . get Message ( Util Cache Events . err resource , STRING , Util Misc . to Map ( STRING , name ) , locale ) + STRING ; request . set Attribute ( STRING , err Msg ) ; return STRING ; } return STRING ; }
public static String clear Event ( Http Servlet Request request , Http Servlet Response response ) { String err Msg = STRING ; Locale locale = Util Http . get Locale ( request ) ; Security security = ( Security ) request . get Attribute ( STRING ) ; if ( ! security . has Permission ( STRING , request . get Session ( ) ) ) { err Msg = Util Properties . get Message ( Util Cache Events . err resource , STRING , locale ) + STRING ; request . set Attribute ( STRING , err Msg ) ; return STRING ; } String name = request . get Parameter ( STRING ) ; if ( name == null ) { err Msg = Util Properties . get Message ( Util Cache Events . err resource , STRING , locale ) + STRING ; request . set Attribute ( STRING , err Msg ) ; return STRING ; } Util Cache < ? , ? > util Cache = Util Cache . find Cache ( name ) ; if ( util Cache != null ) { util Cache . clear ( ) ; err Msg = Util Properties . get Message ( Util Cache Events . err resource , STRING , Util Misc . to Map ( STRING , name ) , locale ) + STRING ; request . set Attribute ( STRING , err Msg ) ; } else { err Msg = Util Properties . get Message ( Util Cache Events . err resource , STRING , Util Misc . to Map ( STRING , name ) , locale ) + STRING ; request . set Attribute ( STRING , err Msg ) ; return STRING ; } return STRING ; }
public String assign Provider Audio Socket ( Abstract Provider Connection connection ) { String socket = connection . get Audio Socket Name ( ) ; if ( socket == null ) { socket = STRING + connection . get Provider Name ( ) + STRING + System . current Time Millis ( ) ; if ( connection . create Audio Socket ( m Native Hub , socket ) ) { Log . i ( TAG , STRING + connection . get Provider Name ( ) ) ; } else { Log . w ( TAG , STRING + connection . get Provider Name ( ) ) ; } } return socket ; }
public void circle ( double x , double y , double r ) { if ( r < NUM ) throw new Illegal Argument Exception ( STRING ) ; double xs = scale X ( x ) ; double ys = scale Y ( y ) ; double ws = factor X ( NUM * r ) ; double hs = factor Y ( NUM * r ) ; if ( ws <= NUM && hs <= NUM ) pixel ( x , y ) ; else offscreen . draw ( new Ellipse 2 D . Double ( xs - ws / NUM , ys - hs / NUM , ws , hs ) ) ; draw ( ) ; }
public void refresh ( Cloud Object [ ] objects , Cloud Response < Integer > response ) { refresh Impl ( objects , response ) ; }
public void refresh ( Cloud Object [ ] objects , Cloud Response < Integer > response ) { refresh Impl ( objects , response ) ; }
public void refresh ( Cloud Object [ ] objects , Cloud Response < Integer > response ) { refresh Impl ( objects , response ) ; }
public static void send Wake On Lan ( @ Non Null String ip Str , @ Non Null String mac Str , int port , int timeout Millis , int packets ) throws IO Exception , Illegal Argument Exception { if ( ip Str == null ) throw new Illegal Argument Exception ( STRING ) ; if ( mac Str == null ) throw new Illegal Argument Exception ( STRING ) ; if ( port <= NUM || port > NUM ) throw new Illegal Argument Exception ( STRING + port ) ; if ( packets <= NUM ) throw new Illegal Argument Exception ( STRING + packets ) ; byte [ ] mac Bytes = get Mac Bytes ( mac Str ) ; byte [ ] bytes = new byte [ NUM + NUM * mac Bytes . length ] ; for ( int i = NUM ; i < NUM ; i ++ ) { bytes [ i ] = ( byte ) NUM ; } for ( int i = NUM ; i < bytes . length ; i += mac Bytes . length ) { System . arraycopy ( mac Bytes , NUM , bytes , i , mac Bytes . length ) ; } Inet Address address = Inet Address . get By Name ( ip Str ) ; Datagram Packet packet = new Datagram Packet ( bytes , bytes . length , address , port ) ; for ( int i = NUM ; i < packets ; i ++ ) { Datagram Socket socket = new Datagram Socket ( ) ; socket . set So Timeout ( timeout Millis ) ; socket . send ( packet ) ; socket . close ( ) ; } }
public static void sort Fields ( Field Binding [ ] sorted Fields , int left , int right ) { Arrays . sort ( sorted Fields , left , right , FIELD COMPARATOR ) ; }
public static void sort Fields ( Field Binding [ ] sorted Fields , int left , int right ) { Arrays . sort ( sorted Fields , left , right , FIELD COMPARATOR ) ; }
protected void write Non HTML Attributes ( Attribute Set attr ) throws IO Exception { String style = STRING ; String separator = STRING ; if ( in Font Tag ( ) && font Attributes . is Equal ( attr ) ) { return ; } boolean first = BOOL ; Color color = ( Color ) attr . get Attribute ( Style Constants . Foreground ) ; if ( color != null ) { style += STRING + css . style Constants Value To CSS Value ( ( Style Constants ) Style Constants . Foreground , color ) ; first = BOOL ; } Integer size = ( Integer ) attr . get Attribute ( Style Constants . Font Size ) ; if ( size != null ) { if ( ! first ) { style += separator ; } style += STRING + size . int Value ( ) + STRING ; first = BOOL ; } String family = ( String ) attr . get Attribute ( Style Constants . Font Family ) ; if ( family != null ) { if ( ! first ) { style += separator ; } style += STRING + family ; first = BOOL ; } if ( style . length ( ) > NUM ) { if ( font Mask != NUM ) { write End Mask ( font Mask ) ; font Mask = NUM ; } start Span Tag ( style ) ; font Attributes = attr ; } else if ( font Attributes != null ) { write End Mask ( font Mask ) ; font Mask = NUM ; end Span Tag ( ) ; } }
protected void write Non HTML Attributes ( Attribute Set attr ) throws IO Exception { String style = STRING ; String separator = STRING ; if ( in Font Tag ( ) && font Attributes . is Equal ( attr ) ) { return ; } boolean first = BOOL ; Color color = ( Color ) attr . get Attribute ( Style Constants . Foreground ) ; if ( color != null ) { style += STRING + css . style Constants Value To CSS Value ( ( Style Constants ) Style Constants . Foreground , color ) ; first = BOOL ; } Integer size = ( Integer ) attr . get Attribute ( Style Constants . Font Size ) ; if ( size != null ) { if ( ! first ) { style += separator ; } style += STRING + size . int Value ( ) + STRING ; first = BOOL ; } String family = ( String ) attr . get Attribute ( Style Constants . Font Family ) ; if ( family != null ) { if ( ! first ) { style += separator ; } style += STRING + family ; first = BOOL ; } if ( style . length ( ) > NUM ) { if ( font Mask != NUM ) { write End Mask ( font Mask ) ; font Mask = NUM ; } start Span Tag ( style ) ; font Attributes = attr ; } else if ( font Attributes != null ) { write End Mask ( font Mask ) ; font Mask = NUM ; end Span Tag ( ) ; } }
protected void write Non HTML Attributes ( Attribute Set attr ) throws IO Exception { String style = STRING ; String separator = STRING ; if ( in Font Tag ( ) && font Attributes . is Equal ( attr ) ) { return ; } boolean first = BOOL ; Color color = ( Color ) attr . get Attribute ( Style Constants . Foreground ) ; if ( color != null ) { style += STRING + css . style Constants Value To CSS Value ( ( Style Constants ) Style Constants . Foreground , color ) ; first = BOOL ; } Integer size = ( Integer ) attr . get Attribute ( Style Constants . Font Size ) ; if ( size != null ) { if ( ! first ) { style += separator ; } style += STRING + size . int Value ( ) + STRING ; first = BOOL ; } String family = ( String ) attr . get Attribute ( Style Constants . Font Family ) ; if ( family != null ) { if ( ! first ) { style += separator ; } style += STRING + family ; first = BOOL ; } if ( style . length ( ) > NUM ) { if ( font Mask != NUM ) { write End Mask ( font Mask ) ; font Mask = NUM ; } start Span Tag ( style ) ; font Attributes = attr ; } else if ( font Attributes != null ) { write End Mask ( font Mask ) ; font Mask = NUM ; end Span Tag ( ) ; } }
protected void write Non HTML Attributes ( Attribute Set attr ) throws IO Exception { String style = STRING ; String separator = STRING ; if ( in Font Tag ( ) && font Attributes . is Equal ( attr ) ) { return ; } boolean first = BOOL ; Color color = ( Color ) attr . get Attribute ( Style Constants . Foreground ) ; if ( color != null ) { style += STRING + css . style Constants Value To CSS Value ( ( Style Constants ) Style Constants . Foreground , color ) ; first = BOOL ; } Integer size = ( Integer ) attr . get Attribute ( Style Constants . Font Size ) ; if ( size != null ) { if ( ! first ) { style += separator ; } style += STRING + size . int Value ( ) + STRING ; first = BOOL ; } String family = ( String ) attr . get Attribute ( Style Constants . Font Family ) ; if ( family != null ) { if ( ! first ) { style += separator ; } style += STRING + family ; first = BOOL ; } if ( style . length ( ) > NUM ) { if ( font Mask != NUM ) { write End Mask ( font Mask ) ; font Mask = NUM ; } start Span Tag ( style ) ; font Attributes = attr ; } else if ( font Attributes != null ) { write End Mask ( font Mask ) ; font Mask = NUM ; end Span Tag ( ) ; } }
protected abstract boolean resolve Request ( Cluster State state , Request request , Action Listener < Response > listener ) ;
protected abstract boolean resolve Request ( Cluster State state , Request request , Action Listener < Response > listener ) ;
protected abstract boolean resolve Request ( Cluster State state , Request request , Action Listener < Response > listener ) ;
protected abstract boolean resolve Request ( Cluster State state , Request request , Action Listener < Response > listener ) ;
protected abstract boolean resolve Request ( Cluster State state , Request request , Action Listener < Response > listener ) ;
protected abstract boolean resolve Request ( Cluster State state , Request request , Action Listener < Response > listener ) ;
public void add Total Result Count Cookie ( Workbench Request req , Http Servlet Response resp , int value ) { add Cookie ( req , resp , STRING , String . value Of ( value ) ) ; }
public void init Disk Cache ( ) { synchronized ( m Disk Cache Lock ) { if ( m Disk Lru Cache == null || m Disk Lru Cache . is Closed ( ) ) { File disk Cache Dir = m Cache Params . disk Cache Dir ; if ( m Cache Params . disk Cache Enabled && disk Cache Dir != null ) { if ( ! disk Cache Dir . exists ( ) ) { disk Cache Dir . mkdirs ( ) ; } if ( get Usable Space ( disk Cache Dir ) > m Cache Params . disk Cache Size ) { try { m Disk Lru Cache = Disk Lru Cache . open ( disk Cache Dir , NUM , NUM , m Cache Params . disk Cache Size ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IO Exception e ) { m Cache Params . disk Cache Dir = null ; Log . e ( TAG , STRING + e ) ; } } } } m Disk Cache Starting = BOOL ; m Disk Cache Lock . notify All ( ) ; } }
public void init Disk Cache ( ) { synchronized ( m Disk Cache Lock ) { if ( m Disk Lru Cache == null || m Disk Lru Cache . is Closed ( ) ) { File disk Cache Dir = m Cache Params . disk Cache Dir ; if ( m Cache Params . disk Cache Enabled && disk Cache Dir != null ) { if ( ! disk Cache Dir . exists ( ) ) { disk Cache Dir . mkdirs ( ) ; } if ( get Usable Space ( disk Cache Dir ) > m Cache Params . disk Cache Size ) { try { m Disk Lru Cache = Disk Lru Cache . open ( disk Cache Dir , NUM , NUM , m Cache Params . disk Cache Size ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IO Exception e ) { m Cache Params . disk Cache Dir = null ; Log . e ( TAG , STRING + e ) ; } } } } m Disk Cache Starting = BOOL ; m Disk Cache Lock . notify All ( ) ; } }
public void init Disk Cache ( ) { synchronized ( m Disk Cache Lock ) { if ( m Disk Lru Cache == null || m Disk Lru Cache . is Closed ( ) ) { File disk Cache Dir = m Cache Params . disk Cache Dir ; if ( m Cache Params . disk Cache Enabled && disk Cache Dir != null ) { if ( ! disk Cache Dir . exists ( ) ) { disk Cache Dir . mkdirs ( ) ; } if ( get Usable Space ( disk Cache Dir ) > m Cache Params . disk Cache Size ) { try { m Disk Lru Cache = Disk Lru Cache . open ( disk Cache Dir , NUM , NUM , m Cache Params . disk Cache Size ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IO Exception e ) { m Cache Params . disk Cache Dir = null ; Log . e ( TAG , STRING + e ) ; } } } } m Disk Cache Starting = BOOL ; m Disk Cache Lock . notify All ( ) ; } }
public void init Disk Cache ( ) { synchronized ( m Disk Cache Lock ) { if ( m Disk Lru Cache == null || m Disk Lru Cache . is Closed ( ) ) { File disk Cache Dir = m Cache Params . disk Cache Dir ; if ( m Cache Params . disk Cache Enabled && disk Cache Dir != null ) { if ( ! disk Cache Dir . exists ( ) ) { disk Cache Dir . mkdirs ( ) ; } if ( get Usable Space ( disk Cache Dir ) > m Cache Params . disk Cache Size ) { try { m Disk Lru Cache = Disk Lru Cache . open ( disk Cache Dir , NUM , NUM , m Cache Params . disk Cache Size ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IO Exception e ) { m Cache Params . disk Cache Dir = null ; Log . e ( TAG , STRING + e ) ; } } } } m Disk Cache Starting = BOOL ; m Disk Cache Lock . notify All ( ) ; } }
public void init Disk Cache ( ) { synchronized ( m Disk Cache Lock ) { if ( m Disk Lru Cache == null || m Disk Lru Cache . is Closed ( ) ) { File disk Cache Dir = m Cache Params . disk Cache Dir ; if ( m Cache Params . disk Cache Enabled && disk Cache Dir != null ) { if ( ! disk Cache Dir . exists ( ) ) { disk Cache Dir . mkdirs ( ) ; } if ( get Usable Space ( disk Cache Dir ) > m Cache Params . disk Cache Size ) { try { m Disk Lru Cache = Disk Lru Cache . open ( disk Cache Dir , NUM , NUM , m Cache Params . disk Cache Size ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IO Exception e ) { m Cache Params . disk Cache Dir = null ; Log . e ( TAG , STRING + e ) ; } } } } m Disk Cache Starting = BOOL ; m Disk Cache Lock . notify All ( ) ; } }
public void init Disk Cache ( ) { synchronized ( m Disk Cache Lock ) { if ( m Disk Lru Cache == null || m Disk Lru Cache . is Closed ( ) ) { File disk Cache Dir = m Cache Params . disk Cache Dir ; if ( m Cache Params . disk Cache Enabled && disk Cache Dir != null ) { if ( ! disk Cache Dir . exists ( ) ) { disk Cache Dir . mkdirs ( ) ; } if ( get Usable Space ( disk Cache Dir ) > m Cache Params . disk Cache Size ) { try { m Disk Lru Cache = Disk Lru Cache . open ( disk Cache Dir , NUM , NUM , m Cache Params . disk Cache Size ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IO Exception e ) { m Cache Params . disk Cache Dir = null ; Log . e ( TAG , STRING + e ) ; } } } } m Disk Cache Starting = BOOL ; m Disk Cache Lock . notify All ( ) ; } }
public void init Disk Cache ( ) { synchronized ( m Disk Cache Lock ) { if ( m Disk Lru Cache == null || m Disk Lru Cache . is Closed ( ) ) { File disk Cache Dir = m Cache Params . disk Cache Dir ; if ( m Cache Params . disk Cache Enabled && disk Cache Dir != null ) { if ( ! disk Cache Dir . exists ( ) ) { disk Cache Dir . mkdirs ( ) ; } if ( get Usable Space ( disk Cache Dir ) > m Cache Params . disk Cache Size ) { try { m Disk Lru Cache = Disk Lru Cache . open ( disk Cache Dir , NUM , NUM , m Cache Params . disk Cache Size ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IO Exception e ) { m Cache Params . disk Cache Dir = null ; Log . e ( TAG , STRING + e ) ; } } } } m Disk Cache Starting = BOOL ; m Disk Cache Lock . notify All ( ) ; } }
public void init Disk Cache ( ) { synchronized ( m Disk Cache Lock ) { if ( m Disk Lru Cache == null || m Disk Lru Cache . is Closed ( ) ) { File disk Cache Dir = m Cache Params . disk Cache Dir ; if ( m Cache Params . disk Cache Enabled && disk Cache Dir != null ) { if ( ! disk Cache Dir . exists ( ) ) { disk Cache Dir . mkdirs ( ) ; } if ( get Usable Space ( disk Cache Dir ) > m Cache Params . disk Cache Size ) { try { m Disk Lru Cache = Disk Lru Cache . open ( disk Cache Dir , NUM , NUM , m Cache Params . disk Cache Size ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IO Exception e ) { m Cache Params . disk Cache Dir = null ; Log . e ( TAG , STRING + e ) ; } } } } m Disk Cache Starting = BOOL ; m Disk Cache Lock . notify All ( ) ; } }
public void init Disk Cache ( ) { synchronized ( m Disk Cache Lock ) { if ( m Disk Lru Cache == null || m Disk Lru Cache . is Closed ( ) ) { File disk Cache Dir = m Cache Params . disk Cache Dir ; if ( m Cache Params . disk Cache Enabled && disk Cache Dir != null ) { if ( ! disk Cache Dir . exists ( ) ) { disk Cache Dir . mkdirs ( ) ; } if ( get Usable Space ( disk Cache Dir ) > m Cache Params . disk Cache Size ) { try { m Disk Lru Cache = Disk Lru Cache . open ( disk Cache Dir , NUM , NUM , m Cache Params . disk Cache Size ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IO Exception e ) { m Cache Params . disk Cache Dir = null ; Log . e ( TAG , STRING + e ) ; } } } } m Disk Cache Starting = BOOL ; m Disk Cache Lock . notify All ( ) ; } }
public void init Disk Cache ( ) { synchronized ( m Disk Cache Lock ) { if ( m Disk Lru Cache == null || m Disk Lru Cache . is Closed ( ) ) { File disk Cache Dir = m Cache Params . disk Cache Dir ; if ( m Cache Params . disk Cache Enabled && disk Cache Dir != null ) { if ( ! disk Cache Dir . exists ( ) ) { disk Cache Dir . mkdirs ( ) ; } if ( get Usable Space ( disk Cache Dir ) > m Cache Params . disk Cache Size ) { try { m Disk Lru Cache = Disk Lru Cache . open ( disk Cache Dir , NUM , NUM , m Cache Params . disk Cache Size ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IO Exception e ) { m Cache Params . disk Cache Dir = null ; Log . e ( TAG , STRING + e ) ; } } } } m Disk Cache Starting = BOOL ; m Disk Cache Lock . notify All ( ) ; } }
public static Json Object http Get ( Closeable Http Client http Client , URI uri ) throws Client Protocol Exception , IO Exception , Illegal State Exception , Http Exception { Http Get http Get = new Http Get ( uri ) ; try ( Closeable Http Response response = http Client . execute ( http Get ) ) { return Utility Functions . parse HTTP Response ( response , uri . to String ( ) ) ; } catch ( Client Protocol Exception e ) { throw e ; } }
public Date Parser ( ) { this ( Date Format . get Date Instance ( Date Format . SHORT ) ) ; }
public synchronized void draw ( final Graphics 2 D gfx , final float x , final float y ) { if ( ! is Empty ( ) ) { m text Layout . draw ( gfx , x , y ) ; for ( final C Highlighting highlighting : new Array List < C Highlighting > ( m highlighting ) ) { final double bp X = ( x + highlighting . get Start ( ) ) - NUM ; final double bp Y = ( y - m char Height ) + NUM ; final double bp W = highlighting . get End ( ) + NUM ; final double bp H = m char Height - NUM ; draw Highlighting ( gfx , bp X , bp Y , bp W , bp H , highlighting . get Color ( ) ) ; } } }
public static OS Type calculate OS ( ) { String os Name = System . get Property ( STRING ) ; os Name = os Name . to Lower Case ( Locale . ENGLISH ) ; if ( os Name . starts With ( STRING ) ) { return OS Type . APPLE ; } if ( os Name . starts With ( STRING ) ) { return OS Type . WINDOWS ; } if ( os Name . starts With ( STRING ) ) { return OS Type . LINUX ; } if ( os Name . starts With ( STRING ) ) { return OS Type . SUN ; } return OS Type . UNKNOWN ; }
public Set create Assignable Dynamic Groups ( Set group Names ) throws AM Exception , SSO Exception { Iterator iter = group Names . iterator ( ) ; Set groups = new Hash Set ( ) ; while ( iter . has Next ( ) ) { String group DN = AM Naming Attr Manager . get Naming Attr ( GROUP ) + STRING + ( ( String ) iter . next ( ) ) + STRING + entry DN ; AM Assignable Dynamic Group Impl group Impl = new AM Assignable Dynamic Group Impl ( token , group DN ) ; group Impl . create ( ) ; groups . add ( group Impl ) ; } return groups ; }
public Set create Assignable Dynamic Groups ( Set group Names ) throws AM Exception , SSO Exception { Iterator iter = group Names . iterator ( ) ; Set groups = new Hash Set ( ) ; while ( iter . has Next ( ) ) { String group DN = AM Naming Attr Manager . get Naming Attr ( GROUP ) + STRING + ( ( String ) iter . next ( ) ) + STRING + entry DN ; AM Assignable Dynamic Group Impl group Impl = new AM Assignable Dynamic Group Impl ( token , group DN ) ; group Impl . create ( ) ; groups . add ( group Impl ) ; } return groups ; }
public static String JQ ( String request ) throws Exception { int query Start Pos = request . index Of ( STRING ) ; String query ; String path ; if ( - NUM == query Start Pos ) { query = STRING ; path = request ; } else { query = request . substring ( query Start Pos + NUM ) ; path = request . substring ( NUM , query Start Pos ) ; } query = set Param ( query , STRING , STRING ) ; request = path + STRING + set Param ( query , STRING , STRING ) ; String response ; boolean failed = BOOL ; try { response = rest Test Harness . query ( request ) ; failed = BOOL ; } finally { if ( failed ) { log . error ( STRING + request ) ; } } return response ; }
public static String JQ ( String request ) throws Exception { int query Start Pos = request . index Of ( STRING ) ; String query ; String path ; if ( - NUM == query Start Pos ) { query = STRING ; path = request ; } else { query = request . substring ( query Start Pos + NUM ) ; path = request . substring ( NUM , query Start Pos ) ; } query = set Param ( query , STRING , STRING ) ; request = path + STRING + set Param ( query , STRING , STRING ) ; String response ; boolean failed = BOOL ; try { response = rest Test Harness . query ( request ) ; failed = BOOL ; } finally { if ( failed ) { log . error ( STRING + request ) ; } } return response ; }
public No Duplicate Value Global Constraint ( Abstract Parameter < ? , ? > ... parameters ) { this . parameters = Arrays . as List ( parameters ) ; }
public void send Shield Frame ( Shield Frame frame , boolean wait If In A Callback ) { if ( frame == null ) throw new Null Pointer Exception ( STRING ) ; if ( ! is Connected ( ) ) { on Error ( One Sheeld Error . DEVICE NOT CONNECTED ) ; return ; } else if ( is Updating Firmware ( ) ) { on Error ( One Sheeld Error . FIRMWARE UPDATE IN PROGRESS ) ; return ; } if ( ! wait If In A Callback ) { send Frame ( frame ) ; return ; } boolean in A Callback ; synchronized ( arduino Callbacks Lock ) { in A Callback = is In A Callback ; } if ( in A Callback ) { queued Frames . add ( frame ) ; } else { if ( queued Frames . is Empty ( ) ) { send Frame ( frame ) ; } else { queued Frames . add ( frame ) ; } } }
public Font Sizer ( Font Sizer source ) { restore ( source ) ; }
@ Before public void initialize Test Directories ( ) { logger . debug ( STRING ) ; String test Id = test Id Watcher . get Test Id ( ) ; File base Dir = get Base Dir ( ) ; File resources Dir = new File ( base Dir , TEST RESOURCES DIR ) ; source Test Dir = new File ( resources Dir , test Id ) ; target Test Dir = new File ( base Dir , TEST RESOURCES TARGET DIR + test Id ) ; logger . debug ( STRING ) ; try { File Utils . delete Directory ( target Test Dir ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING + target Test Dir . get Absolute Path ( ) , e ) ; } target Test Dir . mkdirs ( ) ; }
@ Before public void initialize Test Directories ( ) { logger . debug ( STRING ) ; String test Id = test Id Watcher . get Test Id ( ) ; File base Dir = get Base Dir ( ) ; File resources Dir = new File ( base Dir , TEST RESOURCES DIR ) ; source Test Dir = new File ( resources Dir , test Id ) ; target Test Dir = new File ( base Dir , TEST RESOURCES TARGET DIR + test Id ) ; logger . debug ( STRING ) ; try { File Utils . delete Directory ( target Test Dir ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING + target Test Dir . get Absolute Path ( ) , e ) ; } target Test Dir . mkdirs ( ) ; }
@ Before public void initialize Test Directories ( ) { logger . debug ( STRING ) ; String test Id = test Id Watcher . get Test Id ( ) ; File base Dir = get Base Dir ( ) ; File resources Dir = new File ( base Dir , TEST RESOURCES DIR ) ; source Test Dir = new File ( resources Dir , test Id ) ; target Test Dir = new File ( base Dir , TEST RESOURCES TARGET DIR + test Id ) ; logger . debug ( STRING ) ; try { File Utils . delete Directory ( target Test Dir ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING + target Test Dir . get Absolute Path ( ) , e ) ; } target Test Dir . mkdirs ( ) ; }
@ Before public void initialize Test Directories ( ) { logger . debug ( STRING ) ; String test Id = test Id Watcher . get Test Id ( ) ; File base Dir = get Base Dir ( ) ; File resources Dir = new File ( base Dir , TEST RESOURCES DIR ) ; source Test Dir = new File ( resources Dir , test Id ) ; target Test Dir = new File ( base Dir , TEST RESOURCES TARGET DIR + test Id ) ; logger . debug ( STRING ) ; try { File Utils . delete Directory ( target Test Dir ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING + target Test Dir . get Absolute Path ( ) , e ) ; } target Test Dir . mkdirs ( ) ; }
public static String create Temp File ( final String ... lines ) throws Exception { final File f = File . create Temp File ( STRING , STRING ) ; f . delete On Exit ( ) ; try ( final File Writer w = new File Writer ( f ) ) { for ( final String s : lines ) { w . write ( s + System . get Property ( STRING ) ) ; } } return f . get Absolute Path ( ) ; }
public static String create Temp File ( final String ... lines ) throws Exception { final File f = File . create Temp File ( STRING , STRING ) ; f . delete On Exit ( ) ; try ( final File Writer w = new File Writer ( f ) ) { for ( final String s : lines ) { w . write ( s + System . get Property ( STRING ) ) ; } } return f . get Absolute Path ( ) ; }
public static byte [ ] create Nonce ( int bytes ) { LOGGER . debug ( STRING , bytes ) ; byte [ ] nonce = new byte [ bytes ] ; random . next Bytes ( nonce ) ; return nonce ; }
public void reset FPS Calculations ( ) { first System Time = System Clock . elapsed Realtime ( ) ; time To Update = first System Time + NUM ; number Of Frames = NUM ; }
public void reset FPS Calculations ( ) { first System Time = System Clock . elapsed Realtime ( ) ; time To Update = first System Time + NUM ; number Of Frames = NUM ; }
public void reset FPS Calculations ( ) { first System Time = System Clock . elapsed Realtime ( ) ; time To Update = first System Time + NUM ; number Of Frames = NUM ; }
public void remove Restriction List ( Node n ) { while ( ! node Causing Restriction . empty ( ) && node Causing Restriction . peek ( ) == n ) { neighbour Lists . pop ( ) ; node Causing Restriction . pop ( ) ; } }
private boolean is Member MX Bean Found ( final Collection < Object Name > object Names ) { return ! ( object Names == null || object Names . is Empty ( ) ) ; }
private boolean is Member MX Bean Found ( final Collection < Object Name > object Names ) { return ! ( object Names == null || object Names . is Empty ( ) ) ; }
public void add Range Axis Config ( Range Axis Config range Axis ) { add Range Axis Config ( range Axis Configs . size ( ) , range Axis ) ; }
public void stop ( ) { synchronized ( this ) { m Stopped = BOOL ; if ( m Listener Thread == null ) { return ; } } m Listener Thread . interrupt ( ) ; try { if ( m Server Socket != null ) { m Server Socket . close ( ) ; } } catch ( IO Exception e ) { } }
public void stop ( ) { synchronized ( this ) { m Stopped = BOOL ; if ( m Listener Thread == null ) { return ; } } m Listener Thread . interrupt ( ) ; try { if ( m Server Socket != null ) { m Server Socket . close ( ) ; } } catch ( IO Exception e ) { } }
private static int determine Type ( byte [ ] bytes ) { int offset = NUM ; if ( bytes . length >= NUM && ( bytes [ NUM ] & NUM ) == NUM && ( bytes [ NUM ] & NUM ) == NUM && ( bytes [ NUM ] & NUM ) == NUM ) { offset += NUM ; } while ( offset < bytes . length && bytes [ offset ] == STRING || bytes [ offset ] == STRING || bytes [ offset ] == STRING || bytes [ offset ] == STRING || bytes [ offset ] == STRING ) { offset ++ ; } return determine Type ( new String ( bytes , offset , Math . min ( NUM , bytes . length - offset ) ) ) ; }
@ Safe Varargs public static < T > Supplier < T > randomly Select ( T first , T ... additional ) { if ( additional == null || additional . length == NUM ) return null ; Random rng = new Random ( System . current Time Millis ( ) ) ; int max = additional . length + NUM ; return null ; }
@ Safe Varargs public static < T > Supplier < T > randomly Select ( T first , T ... additional ) { if ( additional == null || additional . length == NUM ) return null ; Random rng = new Random ( System . current Time Millis ( ) ) ; int max = additional . length + NUM ; return null ; }
@ Safe Varargs public static < T > Supplier < T > randomly Select ( T first , T ... additional ) { if ( additional == null || additional . length == NUM ) return null ; Random rng = new Random ( System . current Time Millis ( ) ) ; int max = additional . length + NUM ; return null ; }
@ Safe Varargs public static < T > Supplier < T > randomly Select ( T first , T ... additional ) { if ( additional == null || additional . length == NUM ) return null ; Random rng = new Random ( System . current Time Millis ( ) ) ; int max = additional . length + NUM ; return null ; }
@ Safe Varargs public static < T > Supplier < T > randomly Select ( T first , T ... additional ) { if ( additional == null || additional . length == NUM ) return null ; Random rng = new Random ( System . current Time Millis ( ) ) ; int max = additional . length + NUM ; return null ; }
public Content Proposal Adapter ( Control control , I Control Content Adapter control Content Adapter , I Content Proposal Provider proposal Provider , Key Stroke key Stroke , char [ ] auto Activation Characters ) { super ( ) ; Assert . is Not Null ( control ) ; Assert . is Not Null ( control Content Adapter ) ; this . control = control ; this . control Content Adapter = control Content Adapter ; this . proposal Provider = proposal Provider ; this . trigger Key Stroke = key Stroke ; if ( auto Activation Characters != null ) { this . auto Activate String = new String ( auto Activation Characters ) ; } add Control Listener ( control ) ; }
public Content Proposal Adapter ( Control control , I Control Content Adapter control Content Adapter , I Content Proposal Provider proposal Provider , Key Stroke key Stroke , char [ ] auto Activation Characters ) { super ( ) ; Assert . is Not Null ( control ) ; Assert . is Not Null ( control Content Adapter ) ; this . control = control ; this . control Content Adapter = control Content Adapter ; this . proposal Provider = proposal Provider ; this . trigger Key Stroke = key Stroke ; if ( auto Activation Characters != null ) { this . auto Activate String = new String ( auto Activation Characters ) ; } add Control Listener ( control ) ; }
public Content Proposal Adapter ( Control control , I Control Content Adapter control Content Adapter , I Content Proposal Provider proposal Provider , Key Stroke key Stroke , char [ ] auto Activation Characters ) { super ( ) ; Assert . is Not Null ( control ) ; Assert . is Not Null ( control Content Adapter ) ; this . control = control ; this . control Content Adapter = control Content Adapter ; this . proposal Provider = proposal Provider ; this . trigger Key Stroke = key Stroke ; if ( auto Activation Characters != null ) { this . auto Activate String = new String ( auto Activation Characters ) ; } add Control Listener ( control ) ; }
public static Mime Type from File Name ( final String file Name ) { final String in Lower Case Name = file Name . to Lower Case ( ) ; final String file Extension = get File Extension ( in Lower Case Name ) ; final Mime Type mime Type = file Extensions . get ( file Extension ) ; if ( mime Type != null ) { return mime Type ; } return BINARY ; }
@ Visible For Testing protected static void update Boot Disk Capacity ( List < Attached Disk Create Spec > disks , Image Entity image , List < Throwable > warnings ) throws Invalid Vm Disks Spec Exception , Invalid Image State Exception { for ( Attached Disk Create Spec disk : disks ) { if ( disk . is Boot Disk ( ) ) { if ( image . get Size ( ) == null ) { throw new Invalid Image State Exception ( STRING + image . get Id ( ) + STRING ) ; } if ( disk . get Capacity Gb ( ) != null ) { warnings . add ( new Invalid Vm Disks Spec Exception ( STRING ) ) ; } disk . set Capacity Gb ( ( int ) ( image . get Size ( ) / GB TO BYTE CONVERSION RATIO ) ) ; return ; } } throw new Invalid Vm Disks Spec Exception ( STRING ) ; }
@ Visible For Testing protected static void update Boot Disk Capacity ( List < Attached Disk Create Spec > disks , Image Entity image , List < Throwable > warnings ) throws Invalid Vm Disks Spec Exception , Invalid Image State Exception { for ( Attached Disk Create Spec disk : disks ) { if ( disk . is Boot Disk ( ) ) { if ( image . get Size ( ) == null ) { throw new Invalid Image State Exception ( STRING + image . get Id ( ) + STRING ) ; } if ( disk . get Capacity Gb ( ) != null ) { warnings . add ( new Invalid Vm Disks Spec Exception ( STRING ) ) ; } disk . set Capacity Gb ( ( int ) ( image . get Size ( ) / GB TO BYTE CONVERSION RATIO ) ) ; return ; } } throw new Invalid Vm Disks Spec Exception ( STRING ) ; }
@ Visible For Testing protected static void update Boot Disk Capacity ( List < Attached Disk Create Spec > disks , Image Entity image , List < Throwable > warnings ) throws Invalid Vm Disks Spec Exception , Invalid Image State Exception { for ( Attached Disk Create Spec disk : disks ) { if ( disk . is Boot Disk ( ) ) { if ( image . get Size ( ) == null ) { throw new Invalid Image State Exception ( STRING + image . get Id ( ) + STRING ) ; } if ( disk . get Capacity Gb ( ) != null ) { warnings . add ( new Invalid Vm Disks Spec Exception ( STRING ) ) ; } disk . set Capacity Gb ( ( int ) ( image . get Size ( ) / GB TO BYTE CONVERSION RATIO ) ) ; return ; } } throw new Invalid Vm Disks Spec Exception ( STRING ) ; }
@ Override public Enumeration < String > enumerate Requests ( ) { Vector < String > new Vector = new Vector < String > ( NUM ) ; if ( m evaluate Thread != null ) { new Vector . add Element ( STRING ) ; } return new Vector . elements ( ) ; }
public Resources Poet add Typed Array ( String name , @ Not Null List < String > values ) { Element element = document . create Element ( STRING ) ; element . set Attribute ( STRING , name ) ; for ( String value : values ) { Element value Element = document . create Element ( STRING ) ; value Element . append Child ( document . create Text Node ( value ) ) ; element . append Child ( value Element ) ; } resource Element . append Child ( element ) ; return this ; }
protected Snmp Cached Data update Cached Datas ( Object user Data ) { final String [ ] path = Jvm Runtime Impl . get Boot Class Path ( user Data ) ; final long time = System . current Time Millis ( ) ; final int len = path . length ; Snmp Oid indexes [ ] = new Snmp Oid [ len ] ; for ( int i = NUM ; i < len ; i ++ ) { indexes [ i ] = new Snmp Oid ( i + NUM ) ; } return new Snmp Cached Data ( time , indexes , path ) ; }
protected Snmp Cached Data update Cached Datas ( Object user Data ) { final String [ ] path = Jvm Runtime Impl . get Boot Class Path ( user Data ) ; final long time = System . current Time Millis ( ) ; final int len = path . length ; Snmp Oid indexes [ ] = new Snmp Oid [ len ] ; for ( int i = NUM ; i < len ; i ++ ) { indexes [ i ] = new Snmp Oid ( i + NUM ) ; } return new Snmp Cached Data ( time , indexes , path ) ; }
private Optional < Icicle Redis Response > execute Lua Script ( final Redis redis , final long batch Size ) { List < String > args = Arrays . as List ( String . value Of ( MAX SEQUENCE ) , String . value Of ( MIN LOGICAL SHARD ID ) , String . value Of ( MAX LOGICAL SHARD ID ) , String . value Of ( batch Size ) ) ; return redis . eval Lua Script ( lua Script Sha , args ) ; }
private Optional < Icicle Redis Response > execute Lua Script ( final Redis redis , final long batch Size ) { List < String > args = Arrays . as List ( String . value Of ( MAX SEQUENCE ) , String . value Of ( MIN LOGICAL SHARD ID ) , String . value Of ( MAX LOGICAL SHARD ID ) , String . value Of ( batch Size ) ) ; return redis . eval Lua Script ( lua Script Sha , args ) ; }
public void remove Ignored View ( View v ) { m Ignored Views . remove ( v ) ; }
@ Override public void render Forms Onto G 2 In Headless ( final Object raw , final int page Index , final Map components To Ignore , final Form Factory form Factory ) { if ( forms Ordered == null || forms Ordered [ page Index ] == null ) { return ; } this . components To Ignore = components To Ignore ; Form Object form Object ; final boolean is Printing = form Factory != null ; final Graphics 2 D g2 = ( Graphics 2 D ) raw ; final Affine Transform default Af = g2 . get Transform ( ) ; final Affine Transform aff = g2 . get Transform ( ) ; aff . scale ( NUM , NUM ) ; g2 . set Transform ( aff ) ; for ( final Form Object next Val : forms Ordered [ page Index ] ) { if ( next Val != null ) { form Object = next Val ; final boolean [ ] flags = form Object . get Characteristics ( ) ; if ( ( ( flags [ NUM ] || ( is Printing && ! flags [ NUM ] ) ) ) ) { continue ; } render Component ( g2 , form Object , is Printing ) ; } } g2 . set Transform ( default Af ) ; }
public static byte [ ] [ ] split ( final byte [ ] bytes , final int split Index ) { if ( split Index < NUM || bytes . length < split Index ) { throw new Illegal Argument Exception ( STRING ) ; } final byte [ ] lhs = new byte [ split Index ] ; final byte [ ] rhs = new byte [ bytes . length - split Index ] ; System . arraycopy ( bytes , NUM , lhs , NUM , lhs . length ) ; System . arraycopy ( bytes , split Index , rhs , NUM , rhs . length ) ; return new byte [ ] [ ] { lhs , rhs } ; }
public static byte [ ] [ ] split ( final byte [ ] bytes , final int split Index ) { if ( split Index < NUM || bytes . length < split Index ) { throw new Illegal Argument Exception ( STRING ) ; } final byte [ ] lhs = new byte [ split Index ] ; final byte [ ] rhs = new byte [ bytes . length - split Index ] ; System . arraycopy ( bytes , NUM , lhs , NUM , lhs . length ) ; System . arraycopy ( bytes , split Index , rhs , NUM , rhs . length ) ; return new byte [ ] [ ] { lhs , rhs } ; }
public final void init ( final String current key ) { key = current key + System . current Time Millis ( ) ; final File f = new File ( temp dir ) ; if ( ! f . exists ( ) ) { f . mkdirs ( ) ; } }
public final void init ( final String current key ) { key = current key + System . current Time Millis ( ) ; final File f = new File ( temp dir ) ; if ( ! f . exists ( ) ) { f . mkdirs ( ) ; } }
public final void init ( final String current key ) { key = current key + System . current Time Millis ( ) ; final File f = new File ( temp dir ) ; if ( ! f . exists ( ) ) { f . mkdirs ( ) ; } }
private void update Version ( ) { prop . put ( STRING + old Version , STRING ) ; prop . put ( STRING + new Version , STRING ) ; prop . put ( STRING + old Version , new Version ) ; }
private void ensure Size ( ) { if ( children == EMPTY CHILDREN ) { children = new FP Node [ NUM ] ; return ; } int newsize = children . length == NUM ? INITIAL SIZE : ( children . length << NUM ) ; children = Arrays . copy Of ( children , newsize ) ; }
private void ensure Size ( ) { if ( children == EMPTY CHILDREN ) { children = new FP Node [ NUM ] ; return ; } int newsize = children . length == NUM ? INITIAL SIZE : ( children . length << NUM ) ; children = Arrays . copy Of ( children , newsize ) ; }
public < T > T to Nova ( Object native Object ) { Objects . require Non Null ( native Object ) ; Native Converter converter = find Converter ( native Converters , native Object ) ; if ( converter == null ) { throw new Native Exception ( STRING + native Object + STRING + native Object . get Class ( ) + STRING ) ; } return ( T ) converter . to Nova ( native Object ) ; }
public < T > T to Nova ( Object native Object ) { Objects . require Non Null ( native Object ) ; Native Converter converter = find Converter ( native Converters , native Object ) ; if ( converter == null ) { throw new Native Exception ( STRING + native Object + STRING + native Object . get Class ( ) + STRING ) ; } return ( T ) converter . to Nova ( native Object ) ; }
public < T > T to Nova ( Object native Object ) { Objects . require Non Null ( native Object ) ; Native Converter converter = find Converter ( native Converters , native Object ) ; if ( converter == null ) { throw new Native Exception ( STRING + native Object + STRING + native Object . get Class ( ) + STRING ) ; } return ( T ) converter . to Nova ( native Object ) ; }
private static void add To BG ( Abstract Button button , Container cont , Button Group bg ) { bg . add ( button ) ; cont . add ( button ) ; }
private void compute Implicit Forward Dependences Use ( Register r , Dep Graph Node dest Node ) { Dep Graph Node source Node = get Dep Graph Node ( r ) ; if ( source Node != null ) { for ( Enumeration < Register > e = Generic Physical Def Use . enumerate ( Generic Physical Def Use . get Mask TSP Defs ( ) , ir ) ; e . has More Elements ( ) ; ) { Register r2 = e . next Element ( ) ; if ( r == r2 ) { source Node . insert Out Edge ( dest Node , REG MAY DEF ) ; return ; } } source Node . insert Out Edge ( dest Node , REG TRUE ) ; } }
public boolean add Row ( Table Entry entry ) { try { int row = list . size ( ) ; list . add ( entry ) ; fire Table Rows Inserted ( row , row ) ; } catch ( Exception e ) { return BOOL ; } return BOOL ; }
public void read Data ( Data Input din ) throws IO Exception { reference = din . read Unsigned Short ( ) ; and Mask = din . read Unsigned Short ( ) ; or Mask = din . read Unsigned Short ( ) ; }
public void read Data ( Data Input din ) throws IO Exception { reference = din . read Unsigned Short ( ) ; and Mask = din . read Unsigned Short ( ) ; or Mask = din . read Unsigned Short ( ) ; }
public D Netscape Ca Revocation Url ( J Dialog parent ) { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; }
private static String eliminate Spaces ( final String ¢ ) { return Essence . of ( ¢ ) ; }
public static String report ( ) { String Builder sb = new String Builder ( ) ; for ( Tap tap : dispatches Copy ( ) ) { int length = sb . length ( ) ; tap . append Report ( null , sb ) ; if ( sb . length ( ) > length ) { sb . append ( NEW LINE ) ; } } String result = sb . to String ( ) ; LOG . debug ( STRING + NEW LINE + NEW LINE + result + NEW LINE ) ; return result ; }
public static String report ( ) { String Builder sb = new String Builder ( ) ; for ( Tap tap : dispatches Copy ( ) ) { int length = sb . length ( ) ; tap . append Report ( null , sb ) ; if ( sb . length ( ) > length ) { sb . append ( NEW LINE ) ; } } String result = sb . to String ( ) ; LOG . debug ( STRING + NEW LINE + NEW LINE + result + NEW LINE ) ; return result ; }
public static String report ( ) { String Builder sb = new String Builder ( ) ; for ( Tap tap : dispatches Copy ( ) ) { int length = sb . length ( ) ; tap . append Report ( null , sb ) ; if ( sb . length ( ) > length ) { sb . append ( NEW LINE ) ; } } String result = sb . to String ( ) ; LOG . debug ( STRING + NEW LINE + NEW LINE + result + NEW LINE ) ; return result ; }
public static String report ( ) { String Builder sb = new String Builder ( ) ; for ( Tap tap : dispatches Copy ( ) ) { int length = sb . length ( ) ; tap . append Report ( null , sb ) ; if ( sb . length ( ) > length ) { sb . append ( NEW LINE ) ; } } String result = sb . to String ( ) ; LOG . debug ( STRING + NEW LINE + NEW LINE + result + NEW LINE ) ; return result ; }
@ Step ( STRING ) public static void assert Element Is Visible After ( Augmented Functions driver , By by , int timeout In Seconds ) { Preconditions . check Not Null ( driver ) ; Preconditions . check Not Null ( by ) ; try { driver . find Elements Visible After ( by , timeout In Seconds ) ; } catch ( Timeout Exception e ) { throw new Assertion Error ( String . format ( STRING , by , timeout In Seconds ) , e ) ; } }
@ Step ( STRING ) public static void assert Element Is Visible After ( Augmented Functions driver , By by , int timeout In Seconds ) { Preconditions . check Not Null ( driver ) ; Preconditions . check Not Null ( by ) ; try { driver . find Elements Visible After ( by , timeout In Seconds ) ; } catch ( Timeout Exception e ) { throw new Assertion Error ( String . format ( STRING , by , timeout In Seconds ) , e ) ; } }
public final static byte [ ] successor ( final byte [ ] key ) { final int keylen = key . length ; final byte [ ] tmp = new byte [ keylen + NUM ] ; System . arraycopy ( key , NUM , tmp , NUM , keylen ) ; return tmp ; }
public final static byte [ ] successor ( final byte [ ] key ) { final int keylen = key . length ; final byte [ ] tmp = new byte [ keylen + NUM ] ; System . arraycopy ( key , NUM , tmp , NUM , keylen ) ; return tmp ; }
public final static byte [ ] successor ( final byte [ ] key ) { final int keylen = key . length ; final byte [ ] tmp = new byte [ keylen + NUM ] ; System . arraycopy ( key , NUM , tmp , NUM , keylen ) ; return tmp ; }
@ Inline public static void to UTF 8 ( String s , Byte Buffer b ) { int result index = NUM ; for ( int i = NUM , n = s . length ( ) ; i < n ; ++ i ) { char c = s . char At ( i ) ; if ( ( ( ! WRITE PSEUDO UTF 8 ) || ( c >= NUM ) ) && ( c <= NUM ) ) { b . put ( ( byte ) c ) ; } else if ( c > NUM ) { b . put ( ( byte ) ( NUM | ( byte ) ( c > > NUM ) ) ) ; b . put ( ( byte ) ( NUM | ( ( c & NUM ) > > NUM ) ) ) ; b . put ( ( byte ) ( NUM | ( c & NUM ) ) ) ; } else { b . put ( ( byte ) ( NUM | ( byte ) ( c > > NUM ) ) ) ; b . put ( ( byte ) ( NUM | ( c & NUM ) ) ) ; } } }
private void update Design ( Data Set Design data Set Design , I Connection conn , String query Text ) throws Oda Exception { I Query query = conn . new Query ( null ) ; query . prepare ( query Text ) ; query . set Property ( Query . PROP SETUP QUERY TEXT , get Setup Query Text ( ) ) ; try { I Result Set Meta Data md = query . get Meta Data ( ) ; update Result Set Design ( md , data Set Design ) ; } catch ( Oda Exception e ) { data Set Design . set Result Sets ( null ) ; e . print Stack Trace ( ) ; } try { I Parameter Meta Data param Md = query . get Parameter Meta Data ( ) ; update Parameter Design ( param Md , data Set Design ) ; } catch ( Oda Exception ex ) { data Set Design . set Parameters ( null ) ; ex . print Stack Trace ( ) ; } }
public static DB Handler acquire DB ( ) throws GB Exception { try { if ( db Lock . try Lock ( NUM , Time Unit . SECONDS ) ) { return lock Handler ; } } catch ( Interrupted Exception ex ) { Log . i ( TAG , STRING ) ; } throw new GB Exception ( STRING ) ; }
public static DB Handler acquire DB ( ) throws GB Exception { try { if ( db Lock . try Lock ( NUM , Time Unit . SECONDS ) ) { return lock Handler ; } } catch ( Interrupted Exception ex ) { Log . i ( TAG , STRING ) ; } throw new GB Exception ( STRING ) ; }
public static DB Handler acquire DB ( ) throws GB Exception { try { if ( db Lock . try Lock ( NUM , Time Unit . SECONDS ) ) { return lock Handler ; } } catch ( Interrupted Exception ex ) { Log . i ( TAG , STRING ) ; } throw new GB Exception ( STRING ) ; }
public static DB Handler acquire DB ( ) throws GB Exception { try { if ( db Lock . try Lock ( NUM , Time Unit . SECONDS ) ) { return lock Handler ; } } catch ( Interrupted Exception ex ) { Log . i ( TAG , STRING ) ; } throw new GB Exception ( STRING ) ; }
public static DB Handler acquire DB ( ) throws GB Exception { try { if ( db Lock . try Lock ( NUM , Time Unit . SECONDS ) ) { return lock Handler ; } } catch ( Interrupted Exception ex ) { Log . i ( TAG , STRING ) ; } throw new GB Exception ( STRING ) ; }
public static DB Handler acquire DB ( ) throws GB Exception { try { if ( db Lock . try Lock ( NUM , Time Unit . SECONDS ) ) { return lock Handler ; } } catch ( Interrupted Exception ex ) { Log . i ( TAG , STRING ) ; } throw new GB Exception ( STRING ) ; }
public static DB Handler acquire DB ( ) throws GB Exception { try { if ( db Lock . try Lock ( NUM , Time Unit . SECONDS ) ) { return lock Handler ; } } catch ( Interrupted Exception ex ) { Log . i ( TAG , STRING ) ; } throw new GB Exception ( STRING ) ; }
public static DB Handler acquire DB ( ) throws GB Exception { try { if ( db Lock . try Lock ( NUM , Time Unit . SECONDS ) ) { return lock Handler ; } } catch ( Interrupted Exception ex ) { Log . i ( TAG , STRING ) ; } throw new GB Exception ( STRING ) ; }
public static DB Handler acquire DB ( ) throws GB Exception { try { if ( db Lock . try Lock ( NUM , Time Unit . SECONDS ) ) { return lock Handler ; } } catch ( Interrupted Exception ex ) { Log . i ( TAG , STRING ) ; } throw new GB Exception ( STRING ) ; }
public String move Back ( ) { Check . is True ( current Index > NUM , STRING ) ; current Index -- ; return history . get ( current Index ) ; }
public String move Back ( ) { Check . is True ( current Index > NUM , STRING ) ; current Index -- ; return history . get ( current Index ) ; }
public void close ( ) { assert Not Null ( client ) ; client . set Connection Status ( Connection Change Event . Status . DISCONNECTED ) ; if ( input Thread != null ) input Thread . end ( ) ; if ( heartbeat Thread != null ) heartbeat Thread . end ( ) ; if ( output Executor != null ) output Executor . shutdown Now ( ) ; try { if ( channel != null ) channel . close ( ) ; if ( socket != null ) socket . close ( ) ; } catch ( Exception e ) { } }
private void generate Chunks For Schema ( String schema Name ) { try { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + schema Name ) ; Array List < Table > tables From Schema = connection . get Tables ( schema Name , BOOL , BOOL ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + tables From Schema ) ; if ( tables From Schema != null && tables From Schema . size ( ) > NUM ) { for ( Table table : tables From Schema ) { generate Chunks For Table ( table , - NUM , null ) ; } } } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
public String leave DTD ( ) throws IO Exception { if ( writer == dtd Writer ) { flush Line ( BOOL ) ; writer = doc Writer ; return dtd Writer . to String ( ) ; } return null ; }
public String leave DTD ( ) throws IO Exception { if ( writer == dtd Writer ) { flush Line ( BOOL ) ; writer = doc Writer ; return dtd Writer . to String ( ) ; } return null ; }
public String leave DTD ( ) throws IO Exception { if ( writer == dtd Writer ) { flush Line ( BOOL ) ; writer = doc Writer ; return dtd Writer . to String ( ) ; } return null ; }
public String leave DTD ( ) throws IO Exception { if ( writer == dtd Writer ) { flush Line ( BOOL ) ; writer = doc Writer ; return dtd Writer . to String ( ) ; } return null ; }
public String leave DTD ( ) throws IO Exception { if ( writer == dtd Writer ) { flush Line ( BOOL ) ; writer = doc Writer ; return dtd Writer . to String ( ) ; } return null ; }
private Locus Info create Next Uncovered Locus Info ( final Locus stop Before Locus ) { while ( last Reference Sequence <= stop Before Locus . get Sequence Index ( ) && last Reference Sequence <= reference Sequence Mask . get Max Sequence Index ( ) ) { if ( last Reference Sequence == stop Before Locus . get Sequence Index ( ) && last Position + NUM >= stop Before Locus . get Position ( ) ) { return null ; } final int nextbit = reference Sequence Mask . next Position ( last Reference Sequence , last Position ) ; if ( nextbit == - NUM ) { if ( last Reference Sequence == stop Before Locus . get Sequence Index ( ) ) { last Position = stop Before Locus . get Position ( ) ; return null ; } last Reference Sequence ++ ; last Position = NUM ; } else if ( last Reference Sequence < stop Before Locus . get Sequence Index ( ) || nextbit < stop Before Locus . get Position ( ) ) { last Position = nextbit ; return new Locus Info ( get Reference Sequence ( last Reference Sequence ) , last Position ) ; } else if ( nextbit >= stop Before Locus . get Position ( ) ) { return null ; } } return null ; }
public static void stop Most Recent Timer ( ) { try { stop Timing ( RLOG . get ( ) . most Recent Timer . name ) ; } catch ( Null Pointer Exception ignored ) { LOG . warn ( STRING ) ; } }
public static void wait ( Object lock , long timeout ) { try { synchronized ( lock ) { lock . wait ( timeout ) ; } } catch ( Interrupted Exception e ) { } }
public static < E > List < E > as List ( Iterable < E > iterable ) { if ( iterable instanceof List ) { return ( List < E > ) iterable ; } List < E > result = new Array List < E > ( ) ; for ( E e : iterable ) { result . add ( e ) ; } return result ; }
public static < E > List < E > as List ( Iterable < E > iterable ) { if ( iterable instanceof List ) { return ( List < E > ) iterable ; } List < E > result = new Array List < E > ( ) ; for ( E e : iterable ) { result . add ( e ) ; } return result ; }
@ Override public String next String ( ) { return Integer . to String ( next Int ( ) ) ; }
public static int hex ( String hex ) { if ( hex . char At ( NUM ) == HEX PREFIX ) hex = hex . substring ( NUM ) ; if ( hex . length ( ) > NUM ) { int rgb = Integer . parse Int ( hex . substring ( NUM ) , NUM ) ; int alpha = Integer . parse Int ( hex . substring ( NUM , NUM ) , NUM ) ; return Color Lib . set Alpha ( rgb , alpha ) ; } else { return set Alpha ( Integer . parse Int ( hex , NUM ) , NUM ) ; } }
public static int hex ( String hex ) { if ( hex . char At ( NUM ) == HEX PREFIX ) hex = hex . substring ( NUM ) ; if ( hex . length ( ) > NUM ) { int rgb = Integer . parse Int ( hex . substring ( NUM ) , NUM ) ; int alpha = Integer . parse Int ( hex . substring ( NUM , NUM ) , NUM ) ; return Color Lib . set Alpha ( rgb , alpha ) ; } else { return set Alpha ( Integer . parse Int ( hex , NUM ) , NUM ) ; } }
public static int hex ( String hex ) { if ( hex . char At ( NUM ) == HEX PREFIX ) hex = hex . substring ( NUM ) ; if ( hex . length ( ) > NUM ) { int rgb = Integer . parse Int ( hex . substring ( NUM ) , NUM ) ; int alpha = Integer . parse Int ( hex . substring ( NUM , NUM ) , NUM ) ; return Color Lib . set Alpha ( rgb , alpha ) ; } else { return set Alpha ( Integer . parse Int ( hex , NUM ) , NUM ) ; } }
public static int hex ( String hex ) { if ( hex . char At ( NUM ) == HEX PREFIX ) hex = hex . substring ( NUM ) ; if ( hex . length ( ) > NUM ) { int rgb = Integer . parse Int ( hex . substring ( NUM ) , NUM ) ; int alpha = Integer . parse Int ( hex . substring ( NUM , NUM ) , NUM ) ; return Color Lib . set Alpha ( rgb , alpha ) ; } else { return set Alpha ( Integer . parse Int ( hex , NUM ) , NUM ) ; } }
public static int hex ( String hex ) { if ( hex . char At ( NUM ) == HEX PREFIX ) hex = hex . substring ( NUM ) ; if ( hex . length ( ) > NUM ) { int rgb = Integer . parse Int ( hex . substring ( NUM ) , NUM ) ; int alpha = Integer . parse Int ( hex . substring ( NUM , NUM ) , NUM ) ; return Color Lib . set Alpha ( rgb , alpha ) ; } else { return set Alpha ( Integer . parse Int ( hex , NUM ) , NUM ) ; } }
public static int hex ( String hex ) { if ( hex . char At ( NUM ) == HEX PREFIX ) hex = hex . substring ( NUM ) ; if ( hex . length ( ) > NUM ) { int rgb = Integer . parse Int ( hex . substring ( NUM ) , NUM ) ; int alpha = Integer . parse Int ( hex . substring ( NUM , NUM ) , NUM ) ; return Color Lib . set Alpha ( rgb , alpha ) ; } else { return set Alpha ( Integer . parse Int ( hex , NUM ) , NUM ) ; } }
public static int hex ( String hex ) { if ( hex . char At ( NUM ) == HEX PREFIX ) hex = hex . substring ( NUM ) ; if ( hex . length ( ) > NUM ) { int rgb = Integer . parse Int ( hex . substring ( NUM ) , NUM ) ; int alpha = Integer . parse Int ( hex . substring ( NUM , NUM ) , NUM ) ; return Color Lib . set Alpha ( rgb , alpha ) ; } else { return set Alpha ( Integer . parse Int ( hex , NUM ) , NUM ) ; } }
public static int hex ( String hex ) { if ( hex . char At ( NUM ) == HEX PREFIX ) hex = hex . substring ( NUM ) ; if ( hex . length ( ) > NUM ) { int rgb = Integer . parse Int ( hex . substring ( NUM ) , NUM ) ; int alpha = Integer . parse Int ( hex . substring ( NUM , NUM ) , NUM ) ; return Color Lib . set Alpha ( rgb , alpha ) ; } else { return set Alpha ( Integer . parse Int ( hex , NUM ) , NUM ) ; } }
public Code Position add Position Choice ( int index , String entry , String prefix , Properties props ) { Code Scheme cs = ( Code Scheme ) super . add Position Choice ( index , entry , prefix , props ) ; prefix = Prop Utils . get Scoped Property Prefix ( prefix ) + entry + STRING ; String next = props . get Property ( prefix + Next Property ) ; if ( next != null ) { String next Class Name = props . get Property ( next + STRING ) ; if ( next Class Name != null ) { Code Position cp = ( Code Position ) Component Factory . create ( next Class Name ) ; if ( DEBUG ) { Debug . output ( STRING + next + STRING + next Class Name ) ; } if ( cp != null ) { cs . next Position = cp ; cp . parse Positions ( next , props ) ; } } else { if ( DEBUG ) { Debug . output ( STRING + next + STRING + next Class Name ) ; } } } cs . default Symbol Code = props . get Property ( prefix + Default Symbol Code Property ) ; cs . hierarchy Addition = props . get Property ( prefix + Hierarchy Code Addition Property , STRING ) ; return cs ; }
protected void load History ( ) { int size ; int i ; String cmd ; size = Integer . parse Int ( PROPERTIES . get Property ( STRING , STRING ) ) ; m Command History . clear ( ) ; for ( i = NUM ; i < size ; i ++ ) { cmd = PROPERTIES . get Property ( STRING + i , STRING ) ; if ( cmd . length ( ) != NUM ) { m Command History . add ( cmd ) ; } else { break ; } } m History Pos = m Command History . size ( ) ; }
protected int execute Prepare ( Table table , List < Column > columns , String SQL , boolean keep , int type ) throws SQL Exception { int bind No = NUM ; Prepared Statement statement = null ; int affected Rows = NUM ; try { statement = db Conn . prepare Statement ( SQL ) ; for ( Column c : columns ) { set Column Value ( statement , bind No , c ) ; bind No ++ ; } affected Rows = statement . execute Update ( ) ; } finally { if ( statement != null && ! keep ) { statement . close ( ) ; statement = null ; } } if ( keep && type > - NUM ) table . set Statement ( type , statement ) ; return affected Rows ; }
protected int execute Prepare ( Table table , List < Column > columns , String SQL , boolean keep , int type ) throws SQL Exception { int bind No = NUM ; Prepared Statement statement = null ; int affected Rows = NUM ; try { statement = db Conn . prepare Statement ( SQL ) ; for ( Column c : columns ) { set Column Value ( statement , bind No , c ) ; bind No ++ ; } affected Rows = statement . execute Update ( ) ; } finally { if ( statement != null && ! keep ) { statement . close ( ) ; statement = null ; } } if ( keep && type > - NUM ) table . set Statement ( type , statement ) ; return affected Rows ; }
protected int execute Prepare ( Table table , List < Column > columns , String SQL , boolean keep , int type ) throws SQL Exception { int bind No = NUM ; Prepared Statement statement = null ; int affected Rows = NUM ; try { statement = db Conn . prepare Statement ( SQL ) ; for ( Column c : columns ) { set Column Value ( statement , bind No , c ) ; bind No ++ ; } affected Rows = statement . execute Update ( ) ; } finally { if ( statement != null && ! keep ) { statement . close ( ) ; statement = null ; } } if ( keep && type > - NUM ) table . set Statement ( type , statement ) ; return affected Rows ; }
public final void flush Batch ( ) throws SQL Exception { if ( m ps != null && m batch Count > NUM ) { m ps . execute Batch ( ) ; m batch Count = NUM ; } }
public final void flush Batch ( ) throws SQL Exception { if ( m ps != null && m batch Count > NUM ) { m ps . execute Batch ( ) ; m batch Count = NUM ; } }
public final void flush Batch ( ) throws SQL Exception { if ( m ps != null && m batch Count > NUM ) { m ps . execute Batch ( ) ; m batch Count = NUM ; } }
protected static DNS Task Starter new DNS Task Starter ( Jm DNS Impl jm DNS Impl ) { DNS Task Starter instance = null ; Class Delegate delegate = database Class Delegate . get ( ) ; if ( delegate != null ) { instance = delegate . new DNS Task Starter ( jm DNS Impl ) ; } return ( instance != null ? instance : new DNS Task Starter Impl ( jm DNS Impl ) ) ; }
public void substitute Header ( int state , String header ) throws Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > state Length ) { throw new Auth Login Exception ( bundle Name , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = get Callback ( state ) ; if ( ext . length <= NUM ) { throw new Auth Login Exception ( bundle Name , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != NUM ) ) { Page Properties Callback pc = ( Page Properties Callback ) ( ( Callback [ ] ) internal . get ( state - NUM ) ) [ NUM ] ; pc . set Header ( header ) ; } }
public void substitute Header ( int state , String header ) throws Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > state Length ) { throw new Auth Login Exception ( bundle Name , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = get Callback ( state ) ; if ( ext . length <= NUM ) { throw new Auth Login Exception ( bundle Name , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != NUM ) ) { Page Properties Callback pc = ( Page Properties Callback ) ( ( Callback [ ] ) internal . get ( state - NUM ) ) [ NUM ] ; pc . set Header ( header ) ; } }
public void substitute Header ( int state , String header ) throws Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > state Length ) { throw new Auth Login Exception ( bundle Name , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = get Callback ( state ) ; if ( ext . length <= NUM ) { throw new Auth Login Exception ( bundle Name , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != NUM ) ) { Page Properties Callback pc = ( Page Properties Callback ) ( ( Callback [ ] ) internal . get ( state - NUM ) ) [ NUM ] ; pc . set Header ( header ) ; } }
public void substitute Header ( int state , String header ) throws Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > state Length ) { throw new Auth Login Exception ( bundle Name , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = get Callback ( state ) ; if ( ext . length <= NUM ) { throw new Auth Login Exception ( bundle Name , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != NUM ) ) { Page Properties Callback pc = ( Page Properties Callback ) ( ( Callback [ ] ) internal . get ( state - NUM ) ) [ NUM ] ; pc . set Header ( header ) ; } }
public void substitute Header ( int state , String header ) throws Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > state Length ) { throw new Auth Login Exception ( bundle Name , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = get Callback ( state ) ; if ( ext . length <= NUM ) { throw new Auth Login Exception ( bundle Name , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != NUM ) ) { Page Properties Callback pc = ( Page Properties Callback ) ( ( Callback [ ] ) internal . get ( state - NUM ) ) [ NUM ] ; pc . set Header ( header ) ; } }
public void substitute Header ( int state , String header ) throws Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > state Length ) { throw new Auth Login Exception ( bundle Name , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = get Callback ( state ) ; if ( ext . length <= NUM ) { throw new Auth Login Exception ( bundle Name , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != NUM ) ) { Page Properties Callback pc = ( Page Properties Callback ) ( ( Callback [ ] ) internal . get ( state - NUM ) ) [ NUM ] ; pc . set Header ( header ) ; } }
public void substitute Header ( int state , String header ) throws Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > state Length ) { throw new Auth Login Exception ( bundle Name , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = get Callback ( state ) ; if ( ext . length <= NUM ) { throw new Auth Login Exception ( bundle Name , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != NUM ) ) { Page Properties Callback pc = ( Page Properties Callback ) ( ( Callback [ ] ) internal . get ( state - NUM ) ) [ NUM ] ; pc . set Header ( header ) ; } }
public void substitute Header ( int state , String header ) throws Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > state Length ) { throw new Auth Login Exception ( bundle Name , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = get Callback ( state ) ; if ( ext . length <= NUM ) { throw new Auth Login Exception ( bundle Name , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != NUM ) ) { Page Properties Callback pc = ( Page Properties Callback ) ( ( Callback [ ] ) internal . get ( state - NUM ) ) [ NUM ] ; pc . set Header ( header ) ; } }
public void substitute Header ( int state , String header ) throws Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > state Length ) { throw new Auth Login Exception ( bundle Name , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = get Callback ( state ) ; if ( ext . length <= NUM ) { throw new Auth Login Exception ( bundle Name , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != NUM ) ) { Page Properties Callback pc = ( Page Properties Callback ) ( ( Callback [ ] ) internal . get ( state - NUM ) ) [ NUM ] ; pc . set Header ( header ) ; } }
public void substitute Header ( int state , String header ) throws Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > state Length ) { throw new Auth Login Exception ( bundle Name , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = get Callback ( state ) ; if ( ext . length <= NUM ) { throw new Auth Login Exception ( bundle Name , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != NUM ) ) { Page Properties Callback pc = ( Page Properties Callback ) ( ( Callback [ ] ) internal . get ( state - NUM ) ) [ NUM ] ; pc . set Header ( header ) ; } }
private void decrement Copy Field Target Count ( Schema Field dest ) { Integer count = copy Field Target Counts . get ( dest ) ; assert count != null ; if ( count <= NUM ) { copy Field Target Counts . remove ( dest ) ; } else { copy Field Target Counts . put ( dest , count - NUM ) ; } }
private void decrement Copy Field Target Count ( Schema Field dest ) { Integer count = copy Field Target Counts . get ( dest ) ; assert count != null ; if ( count <= NUM ) { copy Field Target Counts . remove ( dest ) ; } else { copy Field Target Counts . put ( dest , count - NUM ) ; } }
public void test empty Journal ( ) throws IO Exception , Interrupted Exception , Execution Exception { final File out = File . create Temp File ( get Name ( ) , Options . JNL ) ; try { final Journal src = get Store ( get Properties ( ) ) ; try { try { final Future < Journal > f = src . compact ( out ) ; final Journal new Journal = f . get ( ) ; try { new Journal . destroy ( ) ; } finally { fail ( STRING + Illegal Argument Exception . class ) ; } } catch ( Illegal Argument Exception ex ) { log . info ( STRING + ex ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
public void test empty Journal ( ) throws IO Exception , Interrupted Exception , Execution Exception { final File out = File . create Temp File ( get Name ( ) , Options . JNL ) ; try { final Journal src = get Store ( get Properties ( ) ) ; try { try { final Future < Journal > f = src . compact ( out ) ; final Journal new Journal = f . get ( ) ; try { new Journal . destroy ( ) ; } finally { fail ( STRING + Illegal Argument Exception . class ) ; } } catch ( Illegal Argument Exception ex ) { log . info ( STRING + ex ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
public void test empty Journal ( ) throws IO Exception , Interrupted Exception , Execution Exception { final File out = File . create Temp File ( get Name ( ) , Options . JNL ) ; try { final Journal src = get Store ( get Properties ( ) ) ; try { try { final Future < Journal > f = src . compact ( out ) ; final Journal new Journal = f . get ( ) ; try { new Journal . destroy ( ) ; } finally { fail ( STRING + Illegal Argument Exception . class ) ; } } catch ( Illegal Argument Exception ex ) { log . info ( STRING + ex ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
public void add Ssl Port ( String new Ssl Port ) { String new Ssl Ports = String Utils . add To List ( new Ssl Port , get Ssl Ports ( ) , NUM ) ; set Ssl Ports ( new Ssl Ports ) ; }
public void add Ssl Port ( String new Ssl Port ) { String new Ssl Ports = String Utils . add To List ( new Ssl Port , get Ssl Ports ( ) , NUM ) ; set Ssl Ports ( new Ssl Ports ) ; }
public static boolean is Security Manager Enabled ( ) { return System . get Security Manager ( ) != null ; }
private void capture Different String ( String old String , String new String , Map < String , String > map , String app Name ) { Reject . if Null ( app Name ) ; Reject . if Null ( map ) ; if ( old String == null ? new String != null : ! old String . equals ( new String ) ) { map . put ( app Name , new String ) ; } }
public void push ( final double value ) { long bits = Double . double To Long Bits ( value ) ; if ( bits == NUM || bits == NUM ) { mv . visit Insn ( Opcodes . DCONST 0 + ( int ) value ) ; } else { mv . visit Ldc Insn ( new Double ( value ) ) ; } }
public void push ( final double value ) { long bits = Double . double To Long Bits ( value ) ; if ( bits == NUM || bits == NUM ) { mv . visit Insn ( Opcodes . DCONST 0 + ( int ) value ) ; } else { mv . visit Ldc Insn ( new Double ( value ) ) ; } }
public void push ( final double value ) { long bits = Double . double To Long Bits ( value ) ; if ( bits == NUM || bits == NUM ) { mv . visit Insn ( Opcodes . DCONST 0 + ( int ) value ) ; } else { mv . visit Ldc Insn ( new Double ( value ) ) ; } }
protected void fill Sample Database ( Connection conn ) throws SQL Exception { info ( STRING ) ; Prepared Statement org Stmt = conn . prepare Statement ( STRING ) ; for ( int i = NUM ; i < ORGANIZATION CNT ; i ++ ) { org Stmt . set Int ( NUM , i ) ; org Stmt . set String ( NUM , STRING + i ) ; org Stmt . set String ( NUM , STRING + i % NUM ) ; org Stmt . add Batch ( ) ; } org Stmt . execute Batch ( ) ; U . close Quiet ( org Stmt ) ; conn . commit ( ) ; Prepared Statement prn Stmt = conn . prepare Statement ( STRING ) ; Random rnd = new Random ( ) ; for ( int i = NUM ; i < PERSON CNT ; i ++ ) { prn Stmt . set Int ( NUM , i ) ; prn Stmt . set Int ( NUM , i % NUM ) ; prn Stmt . set Date ( NUM , Date . value Of ( String . format ( STRING , NUM + rnd . next Int ( NUM ) , NUM + rnd . next Int ( NUM ) , NUM + rnd . next Int ( NUM ) ) ) ) ; prn Stmt . set String ( NUM , STRING + i ) ; prn Stmt . add Batch ( ) ; } prn Stmt . execute Batch ( ) ; conn . commit ( ) ; U . close Quiet ( prn Stmt ) ; info ( STRING ) ; }
public void action Performed ( Action Event ae ) { String cmd = ae . get Action Command ( ) ; if ( cmd == Timer Status . TIMER FORWARD ) { time Handler . set Clock Direction ( NUM ) ; time Handler . start Clock ( ) ; } else if ( cmd == Timer Status . TIMER BACKWARD ) { time Handler . set Clock Direction ( - NUM ) ; time Handler . start Clock ( ) ; } else if ( cmd == Timer Status . TIMER STEP BACKWARD ) { time Handler . step Backward ( ) ; } else if ( cmd == Timer Status . TIMER STEP FORWARD ) { time Handler . step Forward ( ) ; } else if ( cmd == Timer Status . TIMER STOPPED ) { time Handler . stop Clock ( ) ; } }
public void action Performed ( Action Event ae ) { String cmd = ae . get Action Command ( ) ; if ( cmd == Timer Status . TIMER FORWARD ) { time Handler . set Clock Direction ( NUM ) ; time Handler . start Clock ( ) ; } else if ( cmd == Timer Status . TIMER BACKWARD ) { time Handler . set Clock Direction ( - NUM ) ; time Handler . start Clock ( ) ; } else if ( cmd == Timer Status . TIMER STEP BACKWARD ) { time Handler . step Backward ( ) ; } else if ( cmd == Timer Status . TIMER STEP FORWARD ) { time Handler . step Forward ( ) ; } else if ( cmd == Timer Status . TIMER STOPPED ) { time Handler . stop Clock ( ) ; } }
private double to Double ( IXML Element elem , String value ) throws IO Exception { return to Double ( elem , value , NUM , Double . MIN VALUE , Double . MAX VALUE ) ; }
public static byte [ ] bitmap To Byte ( Bitmap b ) { if ( b == null ) { return null ; } Byte Array Output Stream o = new Byte Array Output Stream ( ) ; b . compress ( Bitmap . Compress Format . PNG , NUM , o ) ; return o . to Byte Array ( ) ; }
public static byte [ ] bitmap To Byte ( Bitmap b ) { if ( b == null ) { return null ; } Byte Array Output Stream o = new Byte Array Output Stream ( ) ; b . compress ( Bitmap . Compress Format . PNG , NUM , o ) ; return o . to Byte Array ( ) ; }
public Process ( final File file , final Progress Listener progress Listener ) throws IO Exception , XML Exception { this . process Location = new File Process Location ( file ) ; init Context ( ) ; Reader in = null ; try { in = new Input Stream Reader ( new File Input Stream ( file ) , STRING ) ; read Process ( in , progress Listener ) ; } catch ( IO Exception e ) { throw e ; } finally { if ( in != null ) { in . close ( ) ; } } }
private void update Status ( ) { String status Text ; if ( ! game . is Terminal ( curr State ) ) { String to Move = ( String ) game . get Player ( curr State ) ; status Text = STRING + to Move ; status Bar . set Foreground ( to Move . equals ( STRING ) ? Color . RED : Color . YELLOW ) ; } else { String winner = null ; for ( int i = NUM ; i < NUM ; i ++ ) if ( game . get Utility ( curr State , game . get Players ( ) [ i ] ) == NUM ) winner = game . get Players ( ) [ i ] ; if ( winner != null ) status Text = STRING + winner + STRING ; else status Text = STRING ; status Bar . set Foreground ( Color . WHITE ) ; } if ( search Metrics != null ) status Text += STRING + search Metrics ; status Bar . set Text ( status Text ) ; }
public String to String ( ) { String result = m Param Char + STRING + m Lower + STRING ; switch ( ( int ) ( m Lower - m Upper + NUM ) ) { case NUM : result += STRING ; break ; case NUM : result += STRING ; break ; default : result += m Upper ; break ; } result += STRING + m Steps ; if ( m Round Param ) { result += STRING ; } return result ; }
public static boolean expression Is True ( double left Side , Operator operator , double right Side ) { final String expression = left Side + operator . get Mathematical Operator ( ) + right Side ; return expression Is True ( expression ) ; }
public void test Merge One Servlet Into Empty Document ( ) throws Exception { String src Xml = STRING ; Web Xml src Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( src Xml . get Bytes ( STRING ) ) , null ) ; String merge Xml = STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml merge Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( merge Xml . get Bytes ( STRING ) ) , null ) ; Web Xml Merger merger = new Web Xml Merger ( src Web Xml ) ; merger . merge ( merge Web Xml ) ; assert True ( Web Xml Utils . has Servlet ( src Web Xml , STRING ) ) ; }
public void sign ( Auth Success auth Success ) throws Server Exception , Association Exception { String handle = auth Success . get Handle ( ) ; Association assoc = shared Associations . load ( handle ) ; if ( assoc == null ) assoc = private Associations . load ( handle ) ; if ( assoc == null ) throw new Server Exception ( STRING + handle ) ; auth Success . set Signature ( assoc . sign ( auth Success . get Signed Text ( ) ) ) ; }
public void sign ( Auth Success auth Success ) throws Server Exception , Association Exception { String handle = auth Success . get Handle ( ) ; Association assoc = shared Associations . load ( handle ) ; if ( assoc == null ) assoc = private Associations . load ( handle ) ; if ( assoc == null ) throw new Server Exception ( STRING + handle ) ; auth Success . set Signature ( assoc . sign ( auth Success . get Signed Text ( ) ) ) ; }
private synchronized void read Object ( java . io . Object Input Stream s ) throws IO Exception , Class Not Found Exception { Get Field gf = s . read Fields ( ) ; String protocol = ( String ) gf . get ( STRING , null ) ; if ( get URL Stream Handler ( protocol ) == null ) { throw new IO Exception ( STRING + protocol ) ; } String host = ( String ) gf . get ( STRING , null ) ; int port = gf . get ( STRING , - NUM ) ; String authority = ( String ) gf . get ( STRING , null ) ; String file = ( String ) gf . get ( STRING , null ) ; String ref = ( String ) gf . get ( STRING , null ) ; int hash Code = gf . get ( STRING , - NUM ) ; if ( authority == null && ( ( host != null && host . length ( ) > NUM ) || port != - NUM ) ) { if ( host == null ) host = STRING ; authority = ( port == - NUM ) ? host : host + STRING + port ; } temp State = new Url Deserialized State ( protocol , host , port , authority , file , ref , hash Code ) ; }
private synchronized void read Object ( java . io . Object Input Stream s ) throws IO Exception , Class Not Found Exception { Get Field gf = s . read Fields ( ) ; String protocol = ( String ) gf . get ( STRING , null ) ; if ( get URL Stream Handler ( protocol ) == null ) { throw new IO Exception ( STRING + protocol ) ; } String host = ( String ) gf . get ( STRING , null ) ; int port = gf . get ( STRING , - NUM ) ; String authority = ( String ) gf . get ( STRING , null ) ; String file = ( String ) gf . get ( STRING , null ) ; String ref = ( String ) gf . get ( STRING , null ) ; int hash Code = gf . get ( STRING , - NUM ) ; if ( authority == null && ( ( host != null && host . length ( ) > NUM ) || port != - NUM ) ) { if ( host == null ) host = STRING ; authority = ( port == - NUM ) ? host : host + STRING + port ; } temp State = new Url Deserialized State ( protocol , host , port , authority , file , ref , hash Code ) ; }
private synchronized void read Object ( java . io . Object Input Stream s ) throws IO Exception , Class Not Found Exception { Get Field gf = s . read Fields ( ) ; String protocol = ( String ) gf . get ( STRING , null ) ; if ( get URL Stream Handler ( protocol ) == null ) { throw new IO Exception ( STRING + protocol ) ; } String host = ( String ) gf . get ( STRING , null ) ; int port = gf . get ( STRING , - NUM ) ; String authority = ( String ) gf . get ( STRING , null ) ; String file = ( String ) gf . get ( STRING , null ) ; String ref = ( String ) gf . get ( STRING , null ) ; int hash Code = gf . get ( STRING , - NUM ) ; if ( authority == null && ( ( host != null && host . length ( ) > NUM ) || port != - NUM ) ) { if ( host == null ) host = STRING ; authority = ( port == - NUM ) ? host : host + STRING + port ; } temp State = new Url Deserialized State ( protocol , host , port , authority , file , ref , hash Code ) ; }
public static String remove Quotation Marks If Needed ( String str ) { if ( str . starts With ( STRING ) && str . ends With ( STRING ) ) return str . substring ( NUM , str . length ( ) - NUM ) ; return str ; }
public static String remove Quotation Marks If Needed ( String str ) { if ( str . starts With ( STRING ) && str . ends With ( STRING ) ) return str . substring ( NUM , str . length ( ) - NUM ) ; return str ; }
private static String pad Left ( String s , int min Length ) { return String . format ( STRING + min Length + STRING , s ) ; }
private static String pad Left ( String s , int min Length ) { return String . format ( STRING + min Length + STRING , s ) ; }
@ Override boolean equals ( Object obj ) ;
@ Override boolean equals ( Object obj ) ;
private void on Main Content Scrolled ( int current Y , int delta Y ) { if ( delta Y > action Bar Auto Hide Sensitivity ) { delta Y = action Bar Auto Hide Sensitivity ; } else if ( delta Y < - action Bar Auto Hide Sensitivity ) { delta Y = - action Bar Auto Hide Sensitivity ; } if ( Math . signum ( delta Y ) * Math . signum ( action Bar Auto Hide Signal ) < NUM ) { action Bar Auto Hide Signal = delta Y ; } else { action Bar Auto Hide Signal += delta Y ; } boolean should Show = current Y < action Bar Auto Hide Min Y || ( action Bar Auto Hide Signal <= - action Bar Auto Hide Sensitivity ) ; auto Show Or Hide Action Bar ( should Show ) ; }
private void on Main Content Scrolled ( int current Y , int delta Y ) { if ( delta Y > action Bar Auto Hide Sensitivity ) { delta Y = action Bar Auto Hide Sensitivity ; } else if ( delta Y < - action Bar Auto Hide Sensitivity ) { delta Y = - action Bar Auto Hide Sensitivity ; } if ( Math . signum ( delta Y ) * Math . signum ( action Bar Auto Hide Signal ) < NUM ) { action Bar Auto Hide Signal = delta Y ; } else { action Bar Auto Hide Signal += delta Y ; } boolean should Show = current Y < action Bar Auto Hide Min Y || ( action Bar Auto Hide Signal <= - action Bar Auto Hide Sensitivity ) ; auto Show Or Hide Action Bar ( should Show ) ; }
private void on Main Content Scrolled ( int current Y , int delta Y ) { if ( delta Y > action Bar Auto Hide Sensitivity ) { delta Y = action Bar Auto Hide Sensitivity ; } else if ( delta Y < - action Bar Auto Hide Sensitivity ) { delta Y = - action Bar Auto Hide Sensitivity ; } if ( Math . signum ( delta Y ) * Math . signum ( action Bar Auto Hide Signal ) < NUM ) { action Bar Auto Hide Signal = delta Y ; } else { action Bar Auto Hide Signal += delta Y ; } boolean should Show = current Y < action Bar Auto Hide Min Y || ( action Bar Auto Hide Signal <= - action Bar Auto Hide Sensitivity ) ; auto Show Or Hide Action Bar ( should Show ) ; }
private void on Main Content Scrolled ( int current Y , int delta Y ) { if ( delta Y > action Bar Auto Hide Sensitivity ) { delta Y = action Bar Auto Hide Sensitivity ; } else if ( delta Y < - action Bar Auto Hide Sensitivity ) { delta Y = - action Bar Auto Hide Sensitivity ; } if ( Math . signum ( delta Y ) * Math . signum ( action Bar Auto Hide Signal ) < NUM ) { action Bar Auto Hide Signal = delta Y ; } else { action Bar Auto Hide Signal += delta Y ; } boolean should Show = current Y < action Bar Auto Hide Min Y || ( action Bar Auto Hide Signal <= - action Bar Auto Hide Sensitivity ) ; auto Show Or Hide Action Bar ( should Show ) ; }
private void on Main Content Scrolled ( int current Y , int delta Y ) { if ( delta Y > action Bar Auto Hide Sensitivity ) { delta Y = action Bar Auto Hide Sensitivity ; } else if ( delta Y < - action Bar Auto Hide Sensitivity ) { delta Y = - action Bar Auto Hide Sensitivity ; } if ( Math . signum ( delta Y ) * Math . signum ( action Bar Auto Hide Signal ) < NUM ) { action Bar Auto Hide Signal = delta Y ; } else { action Bar Auto Hide Signal += delta Y ; } boolean should Show = current Y < action Bar Auto Hide Min Y || ( action Bar Auto Hide Signal <= - action Bar Auto Hide Sensitivity ) ; auto Show Or Hide Action Bar ( should Show ) ; }
@ Suppress Warnings ( STRING ) public Rhythm Overlay inflate Overlay ( String config String ) { List < String > config Strings = Arrays . as List ( config String . split ( STRING ) ) ; return inflate Overlay Internal ( config Strings , Collections . EMPTY MAP , NUM ) ; }
@ Suppress Warnings ( STRING ) public Rhythm Overlay inflate Overlay ( String config String ) { List < String > config Strings = Arrays . as List ( config String . split ( STRING ) ) ; return inflate Overlay Internal ( config Strings , Collections . EMPTY MAP , NUM ) ; }
private List < File > find Duplicate Files ( List < File > files ) { Hash Set < File > source File Set = new Hash Set < > ( ) ; List < File > duplicate Files = new Array List < > ( ) ; for ( File file : files ) { if ( ! source File Set . contains ( file ) ) { source File Set . add ( file ) ; } else { duplicate Files . add ( file ) ; } } return duplicate Files ; }
private List < File > find Duplicate Files ( List < File > files ) { Hash Set < File > source File Set = new Hash Set < > ( ) ; List < File > duplicate Files = new Array List < > ( ) ; for ( File file : files ) { if ( ! source File Set . contains ( file ) ) { source File Set . add ( file ) ; } else { duplicate Files . add ( file ) ; } } return duplicate Files ; }
private void add Nodes SF ( Collection < MPP Order Node > list , int PP Order Node ID , int AD Client ID ) { final MPP Order Node node = get Node ( PP Order Node ID , AD Client ID ) ; if ( node != null ) { if ( ! list . contains ( node ) ) { list . add ( node ) ; } Array List < Integer > next Nodes = new Array List < Integer > ( ) ; for ( MPP Order Node Next next : node . get Transitions ( AD Client ID ) ) { final MPP Order Node child = get Node ( next . get PP Order Next ID ( ) , AD Client ID ) ; if ( child != null ) { if ( ! list . contains ( child ) ) { list . add ( child ) ; next Nodes . add ( next . get PP Order Next ID ( ) ) ; } else { log . save Error ( STRING , STRING + node + STRING + child ) ; } } } for ( int pp Order Next ID : next Nodes ) { add Nodes SF ( list , pp Order Next ID , AD Client ID ) ; } } }
private void add Nodes SF ( Collection < MPP Order Node > list , int PP Order Node ID , int AD Client ID ) { final MPP Order Node node = get Node ( PP Order Node ID , AD Client ID ) ; if ( node != null ) { if ( ! list . contains ( node ) ) { list . add ( node ) ; } Array List < Integer > next Nodes = new Array List < Integer > ( ) ; for ( MPP Order Node Next next : node . get Transitions ( AD Client ID ) ) { final MPP Order Node child = get Node ( next . get PP Order Next ID ( ) , AD Client ID ) ; if ( child != null ) { if ( ! list . contains ( child ) ) { list . add ( child ) ; next Nodes . add ( next . get PP Order Next ID ( ) ) ; } else { log . save Error ( STRING , STRING + node + STRING + child ) ; } } } for ( int pp Order Next ID : next Nodes ) { add Nodes SF ( list , pp Order Next ID , AD Client ID ) ; } } }
void visit And Transform ( Template Element [ ] element Buffer , Template Transform Model transform , Map args ) throws Template Exception , IO Exception { try { Writer tw = transform . get Writer ( out , args ) ; if ( tw == null ) tw = EMPTY BODY WRITER ; Transform Control tc = tw instanceof Transform Control ? ( Transform Control ) tw : null ; Writer prev Out = out ; out = tw ; try { if ( tc == null || tc . on Start ( ) != Transform Control . SKIP BODY ) { do { visit ( element Buffer ) ; } while ( tc != null && tc . after Body ( ) == Transform Control . REPEAT EVALUATION ) ; } } catch ( Throwable t ) { try { if ( tc != null ) { tc . on Error ( t ) ; } else { throw t ; } } catch ( Template Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( Runtime Exception e ) { throw e ; } catch ( Error e ) { throw e ; } catch ( Throwable e ) { throw new Undeclared Throwable Exception ( e ) ; } } finally { out = prev Out ; tw . close ( ) ; } } catch ( Template Exception te ) { handle Template Exception ( te ) ; } }
public void add Update Listener ( Preference Update Listener listener ) { update Listeners . add ( listener ) ; }
public void add Update Listener ( Preference Update Listener listener ) { update Listeners . add ( listener ) ; }
public void add Update Listener ( Preference Update Listener listener ) { update Listeners . add ( listener ) ; }
protected Paint create Horizontal Gradient ( Shape s , Four Colors colors ) { Rectangle 2 D bounds = s . get Bounds 2 D ( ) ; float x = ( float ) bounds . get X ( ) ; float y = ( float ) bounds . get Y ( ) ; float w = ( float ) bounds . get Width ( ) ; float h = ( float ) bounds . get Height ( ) ; return create Gradient ( x , ( NUM * h ) + y , x + w , ( NUM * h ) + y , new float [ ] { NUM , NUM , NUM , NUM } , new Color [ ] { colors . top , colors . upper Mid , colors . lower Mid , colors . bottom } ) ; }
public void add Attachment ( URI url ) { if ( url == null ) return ; if ( m attachments == null ) m attachments = new Array List < Object > ( ) ; m attachments . add ( url ) ; }
private Map < Member , String [ ] > inspect Class ( Class < ? > clazz ) { Input Stream is = clazz . get Resource As Stream ( Class Utils . get Class File Name ( clazz ) ) ; if ( is == null ) { if ( LOGGER . is Debug Enabled ( ) ) { LOGGER . debug ( STRING + clazz + STRING ) ; } return NO DEBUG INFO MAP ; } try { Class Reader class Reader = new Class Reader ( is ) ; Map < Member , String [ ] > map = new Concurrent Hash Map < Member , String [ ] > ( ) ; class Reader . accept ( new Parameter Name Discovering Visitor ( clazz , map ) , BOOL ) ; return map ; } catch ( IO Exception ex ) { if ( LOGGER . is Debug Enabled ( ) ) { LOGGER . debug ( STRING + clazz + STRING , ex ) ; } } finally { try { is . close ( ) ; } catch ( IO Exception ex ) { } } return NO DEBUG INFO MAP ; }
private Map < Member , String [ ] > inspect Class ( Class < ? > clazz ) { Input Stream is = clazz . get Resource As Stream ( Class Utils . get Class File Name ( clazz ) ) ; if ( is == null ) { if ( LOGGER . is Debug Enabled ( ) ) { LOGGER . debug ( STRING + clazz + STRING ) ; } return NO DEBUG INFO MAP ; } try { Class Reader class Reader = new Class Reader ( is ) ; Map < Member , String [ ] > map = new Concurrent Hash Map < Member , String [ ] > ( ) ; class Reader . accept ( new Parameter Name Discovering Visitor ( clazz , map ) , BOOL ) ; return map ; } catch ( IO Exception ex ) { if ( LOGGER . is Debug Enabled ( ) ) { LOGGER . debug ( STRING + clazz + STRING , ex ) ; } } finally { try { is . close ( ) ; } catch ( IO Exception ex ) { } } return NO DEBUG INFO MAP ; }
private Map < Member , String [ ] > inspect Class ( Class < ? > clazz ) { Input Stream is = clazz . get Resource As Stream ( Class Utils . get Class File Name ( clazz ) ) ; if ( is == null ) { if ( LOGGER . is Debug Enabled ( ) ) { LOGGER . debug ( STRING + clazz + STRING ) ; } return NO DEBUG INFO MAP ; } try { Class Reader class Reader = new Class Reader ( is ) ; Map < Member , String [ ] > map = new Concurrent Hash Map < Member , String [ ] > ( ) ; class Reader . accept ( new Parameter Name Discovering Visitor ( clazz , map ) , BOOL ) ; return map ; } catch ( IO Exception ex ) { if ( LOGGER . is Debug Enabled ( ) ) { LOGGER . debug ( STRING + clazz + STRING , ex ) ; } } finally { try { is . close ( ) ; } catch ( IO Exception ex ) { } } return NO DEBUG INFO MAP ; }
private Map < Member , String [ ] > inspect Class ( Class < ? > clazz ) { Input Stream is = clazz . get Resource As Stream ( Class Utils . get Class File Name ( clazz ) ) ; if ( is == null ) { if ( LOGGER . is Debug Enabled ( ) ) { LOGGER . debug ( STRING + clazz + STRING ) ; } return NO DEBUG INFO MAP ; } try { Class Reader class Reader = new Class Reader ( is ) ; Map < Member , String [ ] > map = new Concurrent Hash Map < Member , String [ ] > ( ) ; class Reader . accept ( new Parameter Name Discovering Visitor ( clazz , map ) , BOOL ) ; return map ; } catch ( IO Exception ex ) { if ( LOGGER . is Debug Enabled ( ) ) { LOGGER . debug ( STRING + clazz + STRING , ex ) ; } } finally { try { is . close ( ) ; } catch ( IO Exception ex ) { } } return NO DEBUG INFO MAP ; }
public static String add Query Param ( String path , String key , String value ) { return path + ( path . contains ( STRING ) ? STRING : STRING ) + key + STRING + value ; }
public static String add Query Param ( String path , String key , String value ) { return path + ( path . contains ( STRING ) ? STRING : STRING ) + key + STRING + value ; }
public void add File ( File file ) { add Entry ( file . get Path ( ) ) ; }
public void add File ( File file ) { add Entry ( file . get Path ( ) ) ; }
public void add File ( File file ) { add Entry ( file . get Path ( ) ) ; }
public void clear On Page Change Listeners ( ) { if ( m On Page Change Listeners != null ) { m On Page Change Listeners . clear ( ) ; } }
public I Directable Viewer add Viewer ( I Directable Viewer viewer ) { if ( viewer instanceof Main Viewer ) this . viewer = ( Main Viewer ) viewer ; viewers . add ( viewer ) ; director Listeners . add ( viewer ) ; Project Manager . project Window Changed ( this , viewer , BOOL ) ; return viewer ; }
protected void enqueue UI Operation ( UI Operation operation ) { m Operations . add ( operation ) ; }
protected void enqueue UI Operation ( UI Operation operation ) { m Operations . add ( operation ) ; }
protected void enqueue UI Operation ( UI Operation operation ) { m Operations . add ( operation ) ; }
protected void enqueue UI Operation ( UI Operation operation ) { m Operations . add ( operation ) ; }
protected void enqueue UI Operation ( UI Operation operation ) { m Operations . add ( operation ) ; }
public Git Conflict Exception ( String message ) { super ( message ) ; }
public Hierarchical Class Label ( String name , Pattern regex , String separator ) { super ( ) ; this . separator Pattern = regex ; this . separator String = separator ; String [ ] levelwise Strings = separator Pattern . split ( name ) ; this . levelwise Names = new Comparable < ? > [ levelwise Strings . length ] ; for ( int i = NUM ; i < levelwise Strings . length ; i ++ ) { try { levelwise Names [ i ] = Integer . value Of ( levelwise Strings [ i ] ) ; } catch ( Number Format Exception e ) { levelwise Names [ i ] = levelwise Strings [ i ] ; } } }
public Hierarchical Class Label ( String name , Pattern regex , String separator ) { super ( ) ; this . separator Pattern = regex ; this . separator String = separator ; String [ ] levelwise Strings = separator Pattern . split ( name ) ; this . levelwise Names = new Comparable < ? > [ levelwise Strings . length ] ; for ( int i = NUM ; i < levelwise Strings . length ; i ++ ) { try { levelwise Names [ i ] = Integer . value Of ( levelwise Strings [ i ] ) ; } catch ( Number Format Exception e ) { levelwise Names [ i ] = levelwise Strings [ i ] ; } } }
public Hierarchical Class Label ( String name , Pattern regex , String separator ) { super ( ) ; this . separator Pattern = regex ; this . separator String = separator ; String [ ] levelwise Strings = separator Pattern . split ( name ) ; this . levelwise Names = new Comparable < ? > [ levelwise Strings . length ] ; for ( int i = NUM ; i < levelwise Strings . length ; i ++ ) { try { levelwise Names [ i ] = Integer . value Of ( levelwise Strings [ i ] ) ; } catch ( Number Format Exception e ) { levelwise Names [ i ] = levelwise Strings [ i ] ; } } }
public Hierarchical Class Label ( String name , Pattern regex , String separator ) { super ( ) ; this . separator Pattern = regex ; this . separator String = separator ; String [ ] levelwise Strings = separator Pattern . split ( name ) ; this . levelwise Names = new Comparable < ? > [ levelwise Strings . length ] ; for ( int i = NUM ; i < levelwise Strings . length ; i ++ ) { try { levelwise Names [ i ] = Integer . value Of ( levelwise Strings [ i ] ) ; } catch ( Number Format Exception e ) { levelwise Names [ i ] = levelwise Strings [ i ] ; } } }
public static boolean is Input Stream GZIP Compressed ( final Pushback Input Stream input Stream ) throws IO Exception { if ( input Stream == null ) return BOOL ; byte [ ] signature = new byte [ NUM ] ; int count = NUM ; try { while ( count < NUM ) { int read Count = input Stream . read ( signature , count , NUM - count ) ; if ( read Count < NUM ) return BOOL ; count = count + read Count ; } } finally { input Stream . unread ( signature , NUM , count ) ; } int stream Header = ( ( int ) signature [ NUM ] & NUM ) | ( ( signature [ NUM ] << NUM ) & NUM ) ; return GZIP Input Stream . GZIP MAGIC == stream Header ; }
public void rotated Loot Pot ( World world , Random rand , int x , int y , int z , int offset X , int offset Y , int offset Z , int rotation , int min , int max , int chance ) { x -= width / NUM ; z -= depth / NUM ; if ( rand . next Int ( chance ) == NUM ) return ; switch ( rotation ) { case NUM : generate Loot Pot ( world , rand , new Block Pos ( x + offset X , y + offset Y , z + offset Z ) , min , max , Loot Table Registry . DUNGEON POT LOOT ) ; break ; case NUM : generate Loot Pot ( world , rand , new Block Pos ( x + offset Z , y + offset Y , z + depth - offset X - NUM ) , min , max , Loot Table Registry . DUNGEON POT LOOT ) ; break ; case NUM : generate Loot Pot ( world , rand , new Block Pos ( x + width - offset X - NUM , y + offset Y , z + depth - offset Z - NUM ) , min , max , Loot Table Registry . DUNGEON POT LOOT ) ; break ; case NUM : generate Loot Pot ( world , rand , new Block Pos ( x + width - offset Z - NUM , y + offset Y , z + offset X ) , min , max , Loot Table Registry . DUNGEON POT LOOT ) ; break ; } }
public void rotated Loot Pot ( World world , Random rand , int x , int y , int z , int offset X , int offset Y , int offset Z , int rotation , int min , int max , int chance ) { x -= width / NUM ; z -= depth / NUM ; if ( rand . next Int ( chance ) == NUM ) return ; switch ( rotation ) { case NUM : generate Loot Pot ( world , rand , new Block Pos ( x + offset X , y + offset Y , z + offset Z ) , min , max , Loot Table Registry . DUNGEON POT LOOT ) ; break ; case NUM : generate Loot Pot ( world , rand , new Block Pos ( x + offset Z , y + offset Y , z + depth - offset X - NUM ) , min , max , Loot Table Registry . DUNGEON POT LOOT ) ; break ; case NUM : generate Loot Pot ( world , rand , new Block Pos ( x + width - offset X - NUM , y + offset Y , z + depth - offset Z - NUM ) , min , max , Loot Table Registry . DUNGEON POT LOOT ) ; break ; case NUM : generate Loot Pot ( world , rand , new Block Pos ( x + width - offset Z - NUM , y + offset Y , z + offset X ) , min , max , Loot Table Registry . DUNGEON POT LOOT ) ; break ; } }
public void rotated Loot Pot ( World world , Random rand , int x , int y , int z , int offset X , int offset Y , int offset Z , int rotation , int min , int max , int chance ) { x -= width / NUM ; z -= depth / NUM ; if ( rand . next Int ( chance ) == NUM ) return ; switch ( rotation ) { case NUM : generate Loot Pot ( world , rand , new Block Pos ( x + offset X , y + offset Y , z + offset Z ) , min , max , Loot Table Registry . DUNGEON POT LOOT ) ; break ; case NUM : generate Loot Pot ( world , rand , new Block Pos ( x + offset Z , y + offset Y , z + depth - offset X - NUM ) , min , max , Loot Table Registry . DUNGEON POT LOOT ) ; break ; case NUM : generate Loot Pot ( world , rand , new Block Pos ( x + width - offset X - NUM , y + offset Y , z + depth - offset Z - NUM ) , min , max , Loot Table Registry . DUNGEON POT LOOT ) ; break ; case NUM : generate Loot Pot ( world , rand , new Block Pos ( x + width - offset Z - NUM , y + offset Y , z + offset X ) , min , max , Loot Table Registry . DUNGEON POT LOOT ) ; break ; } }
public static boolean has Visible Children ( Action Group group , Presentation Factory factory , Action Manager action Manager , Perspective Manager perspective Manager ) { Action Event event = new Action Event ( factory . get Presentation ( group ) , action Manager , perspective Manager ) ; for ( Action an Action : group . get Children ( event ) ) { if ( an Action == null ) { Log . error ( Utils . class , STRING + group + STRING + factory . get Presentation ( group ) ) ; continue ; } if ( an Action instanceof Separator ) { continue ; } final Presentation presentation = factory . get Presentation ( an Action ) ; an Action . update ( new Action Event ( presentation , action Manager , perspective Manager ) ) ; if ( an Action instanceof Action Group ) { Action Group child Group = ( Action Group ) an Action ; if ( child Group . is Popup ( ) ) { if ( ! presentation . is Visible ( ) ) { continue ; } } if ( has Visible Children ( child Group , factory , action Manager , perspective Manager ) ) { return BOOL ; } } else if ( presentation . is Visible ( ) ) { return BOOL ; } } return BOOL ; }
public static boolean has Visible Children ( Action Group group , Presentation Factory factory , Action Manager action Manager , Perspective Manager perspective Manager ) { Action Event event = new Action Event ( factory . get Presentation ( group ) , action Manager , perspective Manager ) ; for ( Action an Action : group . get Children ( event ) ) { if ( an Action == null ) { Log . error ( Utils . class , STRING + group + STRING + factory . get Presentation ( group ) ) ; continue ; } if ( an Action instanceof Separator ) { continue ; } final Presentation presentation = factory . get Presentation ( an Action ) ; an Action . update ( new Action Event ( presentation , action Manager , perspective Manager ) ) ; if ( an Action instanceof Action Group ) { Action Group child Group = ( Action Group ) an Action ; if ( child Group . is Popup ( ) ) { if ( ! presentation . is Visible ( ) ) { continue ; } } if ( has Visible Children ( child Group , factory , action Manager , perspective Manager ) ) { return BOOL ; } } else if ( presentation . is Visible ( ) ) { return BOOL ; } } return BOOL ; }
@ Override public synchronized void add Training Set Listener ( Training Set Listener tsl ) { m training Listeners . add Element ( tsl ) ; }
public void execute Statement ( String statement ) throws SQL Exception , No Connection Exception { if ( connection != null ) { Statement st = connection . create Statement ( ) ; st . execute ( statement ) ; } else throw new No Connection Exception ( ) ; }
public void delete ( String name ) throws IO Exception { if ( name . equals Ignore Case ( VERSION ) ) { version = V1 ; } else { throw new IO Exception ( STRING + STRING ) ; } }
public void add ( Dimensional Node dn ) { if ( in Progress ) { throw new Concurrent Modification Exception ( STRING ) ; } nodes . add ( dn ) ; }
public Datepicker Combo ( final Composite parent , final int style ) { this ( parent , style , Date Format . get Date Time Instance ( ) ) ; }
public Datepicker Combo ( final Composite parent , final int style ) { this ( parent , style , Date Format . get Date Time Instance ( ) ) ; }
public Datepicker Combo ( final Composite parent , final int style ) { this ( parent , style , Date Format . get Date Time Instance ( ) ) ; }
public Datepicker Combo ( final Composite parent , final int style ) { this ( parent , style , Date Format . get Date Time Instance ( ) ) ; }
public Datepicker Combo ( final Composite parent , final int style ) { this ( parent , style , Date Format . get Date Time Instance ( ) ) ; }
private void check For Missed Scans ( ) { Date Time now = now ( ) ; for ( Scheduled Daily Scan Upload scheduled Scan : scheduled Scans ) { Date Time start Check Interval = now . minus Minutes ( NUM ) ; Interval missed Interval = new Interval ( start Check Interval , now ) ; Date Time scheduled Time = scheduled Scan . get Next Execution Time After ( start Check Interval ) ; if ( missed Interval . contains ( scheduled Time ) ) { log . info ( STRING , scheduled Time ) ; try { start Scheduled Scan ( scheduled Scan , scheduled Time ) ; } catch ( Repeat Scan Exception e ) { log . info ( STRING , scheduled Time ) ; } catch ( Scan Execution Time Exception e ) { log . info ( STRING , scheduled Time ) ; } } } }
private void check For Missed Scans ( ) { Date Time now = now ( ) ; for ( Scheduled Daily Scan Upload scheduled Scan : scheduled Scans ) { Date Time start Check Interval = now . minus Minutes ( NUM ) ; Interval missed Interval = new Interval ( start Check Interval , now ) ; Date Time scheduled Time = scheduled Scan . get Next Execution Time After ( start Check Interval ) ; if ( missed Interval . contains ( scheduled Time ) ) { log . info ( STRING , scheduled Time ) ; try { start Scheduled Scan ( scheduled Scan , scheduled Time ) ; } catch ( Repeat Scan Exception e ) { log . info ( STRING , scheduled Time ) ; } catch ( Scan Execution Time Exception e ) { log . info ( STRING , scheduled Time ) ; } } } }
private void check For Missed Scans ( ) { Date Time now = now ( ) ; for ( Scheduled Daily Scan Upload scheduled Scan : scheduled Scans ) { Date Time start Check Interval = now . minus Minutes ( NUM ) ; Interval missed Interval = new Interval ( start Check Interval , now ) ; Date Time scheduled Time = scheduled Scan . get Next Execution Time After ( start Check Interval ) ; if ( missed Interval . contains ( scheduled Time ) ) { log . info ( STRING , scheduled Time ) ; try { start Scheduled Scan ( scheduled Scan , scheduled Time ) ; } catch ( Repeat Scan Exception e ) { log . info ( STRING , scheduled Time ) ; } catch ( Scan Execution Time Exception e ) { log . info ( STRING , scheduled Time ) ; } } } }
private void check For Missed Scans ( ) { Date Time now = now ( ) ; for ( Scheduled Daily Scan Upload scheduled Scan : scheduled Scans ) { Date Time start Check Interval = now . minus Minutes ( NUM ) ; Interval missed Interval = new Interval ( start Check Interval , now ) ; Date Time scheduled Time = scheduled Scan . get Next Execution Time After ( start Check Interval ) ; if ( missed Interval . contains ( scheduled Time ) ) { log . info ( STRING , scheduled Time ) ; try { start Scheduled Scan ( scheduled Scan , scheduled Time ) ; } catch ( Repeat Scan Exception e ) { log . info ( STRING , scheduled Time ) ; } catch ( Scan Execution Time Exception e ) { log . info ( STRING , scheduled Time ) ; } } } }
private void check For Missed Scans ( ) { Date Time now = now ( ) ; for ( Scheduled Daily Scan Upload scheduled Scan : scheduled Scans ) { Date Time start Check Interval = now . minus Minutes ( NUM ) ; Interval missed Interval = new Interval ( start Check Interval , now ) ; Date Time scheduled Time = scheduled Scan . get Next Execution Time After ( start Check Interval ) ; if ( missed Interval . contains ( scheduled Time ) ) { log . info ( STRING , scheduled Time ) ; try { start Scheduled Scan ( scheduled Scan , scheduled Time ) ; } catch ( Repeat Scan Exception e ) { log . info ( STRING , scheduled Time ) ; } catch ( Scan Execution Time Exception e ) { log . info ( STRING , scheduled Time ) ; } } } }
private void check For Missed Scans ( ) { Date Time now = now ( ) ; for ( Scheduled Daily Scan Upload scheduled Scan : scheduled Scans ) { Date Time start Check Interval = now . minus Minutes ( NUM ) ; Interval missed Interval = new Interval ( start Check Interval , now ) ; Date Time scheduled Time = scheduled Scan . get Next Execution Time After ( start Check Interval ) ; if ( missed Interval . contains ( scheduled Time ) ) { log . info ( STRING , scheduled Time ) ; try { start Scheduled Scan ( scheduled Scan , scheduled Time ) ; } catch ( Repeat Scan Exception e ) { log . info ( STRING , scheduled Time ) ; } catch ( Scan Execution Time Exception e ) { log . info ( STRING , scheduled Time ) ; } } } }
protected void create Grid ( ) { grid . clear ( ) ; for ( int r = NUM ; r <= rows ; ++ r ) { grid . add ( new Line Segment ( left Margin , graph Height - ( bottom Margin + r * pixels Per Y Tic ) , left Margin + width , graph Height - ( bottom Margin + r * pixels Per Y Tic ) ) ) ; } for ( int c = NUM ; c <= cols ; ++ c ) { grid . add ( new Line Segment ( left Margin + c * pixels Per X Tic , graph Height - bottom Margin , left Margin + c * pixels Per X Tic , graph Height - ( bottom Margin + height ) ) ) ; } }
private String create File Name ( ) { String file Name = url . get Path ( ) ; if ( file Name . starts With ( STRING ) ) { file Name = file Name . substring ( NUM ) ; } else if ( file Name . starts With ( STRING ) ) { file Name = file Name . substring ( NUM ) ; } return file Name ; }
protected void request Stream Info ( String stream ) { String url = STRING + stream ; if ( attempt Request ( url , stream ) ) { Twitch Api Request request = new Twitch Api Request ( this , Request Type . STREAM , url ) ; executor . execute ( request ) ; } }
public int add ( T dl , int row ) { list . add ( row , dl ) ; fire Table Rows Inserted ( row , row ) ; return row ; }
public int add ( T dl , int row ) { list . add ( row , dl ) ; fire Table Rows Inserted ( row , row ) ; return row ; }
public int add ( T dl , int row ) { list . add ( row , dl ) ; fire Table Rows Inserted ( row , row ) ; return row ; }
public int add ( T dl , int row ) { list . add ( row , dl ) ; fire Table Rows Inserted ( row , row ) ; return row ; }
public int add ( T dl , int row ) { list . add ( row , dl ) ; fire Table Rows Inserted ( row , row ) ; return row ; }
public int add ( T dl , int row ) { list . add ( row , dl ) ; fire Table Rows Inserted ( row , row ) ; return row ; }
public Alloc Location Model ( Source Location Tag line , I Alloc Node node ) { this ( line . get Clz ( ) , line . get Line ( ) , node ) ; }
protected List < Position > as Position List ( Lat Lon ... locations ) { List < Position > positions = new Array List < Position > ( locations . length ) ; for ( Lat Lon loc : locations ) { positions . add ( new Position ( loc , NUM ) ) ; } return positions ; }
public synchronized void remove Discovery Listener ( Discovery Listener l ) { if ( terminated ) { throw new Illegal State Exception ( STRING ) ; } int index = listeners . index Of ( l ) ; if ( index != - NUM ) listeners . remove ( index ) ; }
public synchronized void remove Discovery Listener ( Discovery Listener l ) { if ( terminated ) { throw new Illegal State Exception ( STRING ) ; } int index = listeners . index Of ( l ) ; if ( index != - NUM ) listeners . remove ( index ) ; }
public synchronized void remove Discovery Listener ( Discovery Listener l ) { if ( terminated ) { throw new Illegal State Exception ( STRING ) ; } int index = listeners . index Of ( l ) ; if ( index != - NUM ) listeners . remove ( index ) ; }
public synchronized void remove Discovery Listener ( Discovery Listener l ) { if ( terminated ) { throw new Illegal State Exception ( STRING ) ; } int index = listeners . index Of ( l ) ; if ( index != - NUM ) listeners . remove ( index ) ; }
public synchronized void remove Discovery Listener ( Discovery Listener l ) { if ( terminated ) { throw new Illegal State Exception ( STRING ) ; } int index = listeners . index Of ( l ) ; if ( index != - NUM ) listeners . remove ( index ) ; }
private String stack Trace Str ( final Throwable error ) { if ( error == null ) { return STRING ; } String Writer sw = new String Writer ( ) ; Print Writer pw = new Print Writer ( sw ) ; error . print Stack Trace ( pw ) ; pw . close ( ) ; return sw . to String ( ) ; }
private String stack Trace Str ( final Throwable error ) { if ( error == null ) { return STRING ; } String Writer sw = new String Writer ( ) ; Print Writer pw = new Print Writer ( sw ) ; error . print Stack Trace ( pw ) ; pw . close ( ) ; return sw . to String ( ) ; }
private String stack Trace Str ( final Throwable error ) { if ( error == null ) { return STRING ; } String Writer sw = new String Writer ( ) ; Print Writer pw = new Print Writer ( sw ) ; error . print Stack Trace ( pw ) ; pw . close ( ) ; return sw . to String ( ) ; }
private String stack Trace Str ( final Throwable error ) { if ( error == null ) { return STRING ; } String Writer sw = new String Writer ( ) ; Print Writer pw = new Print Writer ( sw ) ; error . print Stack Trace ( pw ) ; pw . close ( ) ; return sw . to String ( ) ; }
private String stack Trace Str ( final Throwable error ) { if ( error == null ) { return STRING ; } String Writer sw = new String Writer ( ) ; Print Writer pw = new Print Writer ( sw ) ; error . print Stack Trace ( pw ) ; pw . close ( ) ; return sw . to String ( ) ; }
public Test find Test ( List < String > suite Names , String test Class Name , String test Name , boolean insert If Missing ) { if ( suite Names . size ( ) <= NUM ) { Test Case test Case = get Test Case ( test Class Name ) ; return test Case . find Test ( test Name , insert If Missing ) ; } else { String root Name = suite Names . remove ( NUM ) ; Test Suite suite = get Test Suite ( root Name ) ; return suite . find Test ( suite Names , test Class Name , test Name , insert If Missing ) ; } }
@ Override public void visit ( Mapping m , int line , int col , int next Line , int next Col ) throws IO Exception { if ( previous Line != line ) { previous Column = NUM ; } if ( line != next Line || col != next Col ) { if ( line < max Line ) { if ( previous Line == line ) { out . append ( STRING ) ; } write Entry ( m , col ) ; previous Line = line ; previous Column = col ; } else { Preconditions . check State ( m == null ) ; } } for ( int i = line ; i <= next Line && i < max Line ; i ++ ) { if ( i == next Line ) { break ; } close Line ( BOOL ) ; open Line ( BOOL ) ; } }
public boolean cancel ( boolean force ) throws Unexecuted Invoke Exception { if ( future == null ) { throw new Unexecuted Invoke Exception ( this ) ; } return cancel ( BOOL ) ; }
public boolean cancel ( boolean force ) throws Unexecuted Invoke Exception { if ( future == null ) { throw new Unexecuted Invoke Exception ( this ) ; } return cancel ( BOOL ) ; }
public boolean cancel ( boolean force ) throws Unexecuted Invoke Exception { if ( future == null ) { throw new Unexecuted Invoke Exception ( this ) ; } return cancel ( BOOL ) ; }
public boolean cancel ( boolean force ) throws Unexecuted Invoke Exception { if ( future == null ) { throw new Unexecuted Invoke Exception ( this ) ; } return cancel ( BOOL ) ; }
private Platform Job next Closure Job ( Platform Abstract Task task , Binary Raw Reader Ex reader ) { return platform Ctx . create Closure Job ( task , reader . read Long ( ) , reader . read Object Detached ( ) ) ; }
public void add Data Row ( Data Row data Row ) { data Row . trim ( ) ; data List . add ( data Row ) ; data Row . ensure Number Of Columns ( columns ) ; }
public void add Data Row ( Data Row data Row ) { data Row . trim ( ) ; data List . add ( data Row ) ; data Row . ensure Number Of Columns ( columns ) ; }
public void add Hostkeys ( char [ ] known Hosts Data ) throws IO Exception { initialize ( known Hosts Data ) ; }
public void add Hostkeys ( char [ ] known Hosts Data ) throws IO Exception { initialize ( known Hosts Data ) ; }
private int ensure Height Grid Aligned ( int height ) { float grid Overhang = height % FOUR DIP ; if ( grid Overhang != NUM ) { extra Bottom Padding = ( int ) ( FOUR DIP - Math . ceil ( grid Overhang ) ) ; } return extra Bottom Padding ; }
boolean add Complement ( Owl Class c ) { return complementary Classes . add ( c ) ; }
public void write Server ( String server ) throws IO Exception { write Header ( Http Writer . SERVER , server ) ; }
private int compare Date ( Date v1 , Date v2 ) { return v1 . compare To ( v2 ) * - NUM ; }
private int compare Date ( Date v1 , Date v2 ) { return v1 . compare To ( v2 ) * - NUM ; }
private int compare Date ( Date v1 , Date v2 ) { return v1 . compare To ( v2 ) * - NUM ; }
private int compare Date ( Date v1 , Date v2 ) { return v1 . compare To ( v2 ) * - NUM ; }
void query Read Result ( Prepared Statement prep ) throws SQL Exception { Result Set rs = prep . execute Query ( ) ; Result Set Meta Data meta = rs . get Meta Data ( ) ; int column Count = meta . get Column Count ( ) ; while ( rs . next ( ) ) { for ( int i = NUM ; i < column Count ; i ++ ) { rs . get String ( i + NUM ) ; } } }
void query Read Result ( Prepared Statement prep ) throws SQL Exception { Result Set rs = prep . execute Query ( ) ; Result Set Meta Data meta = rs . get Meta Data ( ) ; int column Count = meta . get Column Count ( ) ; while ( rs . next ( ) ) { for ( int i = NUM ; i < column Count ; i ++ ) { rs . get String ( i + NUM ) ; } } }
public Sms Console Service Config ( ) { Document doc = parse Document ( CONFIG FILENAME ) ; config Services ( doc ) ; hidden Services = Collections . unmodifiable Set ( services . get ( HIDDEN SERVICES ) ) ; }
public Sms Console Service Config ( ) { Document doc = parse Document ( CONFIG FILENAME ) ; config Services ( doc ) ; hidden Services = Collections . unmodifiable Set ( services . get ( HIDDEN SERVICES ) ) ; }
public Sms Console Service Config ( ) { Document doc = parse Document ( CONFIG FILENAME ) ; config Services ( doc ) ; hidden Services = Collections . unmodifiable Set ( services . get ( HIDDEN SERVICES ) ) ; }
protected abstract String read Optional String Impl ( final String label ) ;
long parse Bytes ( String free Space , String path ) throws IO Exception { try { long bytes = Long . parse Long ( free Space ) ; if ( bytes < NUM ) { throw new IO Exception ( STRING + DF + STRING + STRING + path + STRING ) ; } return bytes ; } catch ( Number Format Exception ex ) { throw new IO Exception With Cause ( STRING + DF + STRING + STRING + path + STRING , ex ) ; } }
private List < Map < String , Object > > type Parameters ( List < Type Parameter > tpl , Declaration from ) { if ( tpl != null && ! tpl . is Empty ( ) ) { List < Map < String , Object > > l = new Array List < > ( tpl . size ( ) ) ; for ( Type Parameter tp : tpl ) { l . add ( type Parameter Map ( tp , from ) ) ; } return l ; } return null ; }
public static boolean is Class Literal Possible ( Class Node class Node ) { return Modifier . is Public ( class Node . get Modifiers ( ) ) ; }
public static boolean is Class Literal Possible ( Class Node class Node ) { return Modifier . is Public ( class Node . get Modifiers ( ) ) ; }
private String parse String ( final String s , final char separator , final Atomic Reference < String > value ) { final String Builder sb = new String Builder ( s . length ( ) ) ; int separator Index = - NUM ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { if ( s . char At ( i ) == separator && i + NUM < s . length ( ) && s . char At ( i + NUM ) == separator ) { sb . append ( separator ) ; i ++ ; continue ; } if ( s . char At ( i ) == separator ) { separator Index = i ; break ; } sb . append ( s . char At ( i ) ) ; } value . set ( sb . to String ( ) ) ; if ( separator Index != - NUM && separator Index != s . length ( ) - NUM ) { return s . substring ( separator Index + NUM ) ; } else { return STRING ; } }
private String parse String ( final String s , final char separator , final Atomic Reference < String > value ) { final String Builder sb = new String Builder ( s . length ( ) ) ; int separator Index = - NUM ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { if ( s . char At ( i ) == separator && i + NUM < s . length ( ) && s . char At ( i + NUM ) == separator ) { sb . append ( separator ) ; i ++ ; continue ; } if ( s . char At ( i ) == separator ) { separator Index = i ; break ; } sb . append ( s . char At ( i ) ) ; } value . set ( sb . to String ( ) ) ; if ( separator Index != - NUM && separator Index != s . length ( ) - NUM ) { return s . substring ( separator Index + NUM ) ; } else { return STRING ; } }
private String parse String ( final String s , final char separator , final Atomic Reference < String > value ) { final String Builder sb = new String Builder ( s . length ( ) ) ; int separator Index = - NUM ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { if ( s . char At ( i ) == separator && i + NUM < s . length ( ) && s . char At ( i + NUM ) == separator ) { sb . append ( separator ) ; i ++ ; continue ; } if ( s . char At ( i ) == separator ) { separator Index = i ; break ; } sb . append ( s . char At ( i ) ) ; } value . set ( sb . to String ( ) ) ; if ( separator Index != - NUM && separator Index != s . length ( ) - NUM ) { return s . substring ( separator Index + NUM ) ; } else { return STRING ; } }
private String parse String ( final String s , final char separator , final Atomic Reference < String > value ) { final String Builder sb = new String Builder ( s . length ( ) ) ; int separator Index = - NUM ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { if ( s . char At ( i ) == separator && i + NUM < s . length ( ) && s . char At ( i + NUM ) == separator ) { sb . append ( separator ) ; i ++ ; continue ; } if ( s . char At ( i ) == separator ) { separator Index = i ; break ; } sb . append ( s . char At ( i ) ) ; } value . set ( sb . to String ( ) ) ; if ( separator Index != - NUM && separator Index != s . length ( ) - NUM ) { return s . substring ( separator Index + NUM ) ; } else { return STRING ; } }
private String parse String ( final String s , final char separator , final Atomic Reference < String > value ) { final String Builder sb = new String Builder ( s . length ( ) ) ; int separator Index = - NUM ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { if ( s . char At ( i ) == separator && i + NUM < s . length ( ) && s . char At ( i + NUM ) == separator ) { sb . append ( separator ) ; i ++ ; continue ; } if ( s . char At ( i ) == separator ) { separator Index = i ; break ; } sb . append ( s . char At ( i ) ) ; } value . set ( sb . to String ( ) ) ; if ( separator Index != - NUM && separator Index != s . length ( ) - NUM ) { return s . substring ( separator Index + NUM ) ; } else { return STRING ; } }
private void update Last Refresh Time ( ) { this . last Refresh Time = System . current Time Millis ( ) ; LOGGER . debug ( STRING , last Refresh Time ) ; }
private void update Last Refresh Time ( ) { this . last Refresh Time = System . current Time Millis ( ) ; LOGGER . debug ( STRING , last Refresh Time ) ; }
public Vector rotate XY ( final double angle ) { return rotate XY ( Math . sin ( angle ) , Math . cos ( angle ) ) ; }
public static String to String ( int value ) { return Integer . to String ( value ) ; }
private double calculate Single Trait Likelihood ( Contrasted Trait Node contrast Node ) { Simple Tree contrast Tree = new Simple Tree ( contrast Node ) ; double s2 = NUM ; double sss Contrast = NUM ; double slog CV = NUM ; for ( int i = NUM ; i < contrast Tree . get Internal Node Count ( ) ; i ++ ) { Contrasted Trait Node ct Node = ( Contrasted Trait Node ) contrast Tree . get Internal Node ( i ) ; double contrast = ct Node . get Trait Contrasts ( ) [ NUM ] ; double cv = ct Node . get Contrast Variance ( ) ; sss Contrast += ( contrast * contrast ) / cv ; slog CV += Math . log ( cv ) ; if ( ct Node . is Root ( ) ) { slog CV += Math . log ( ct Node . get Node Variance ( ) ) ; } } double tl = NUM ; for ( int i = NUM ; i < contrast Tree . get Node Count ( ) ; i ++ ) { Node Ref node = contrast Tree . get Node ( i ) ; if ( ! contrast Tree . is Root ( node ) ) { tl += contrast Tree . get Branch Length ( node ) ; } } s2 = sss Contrast / contrast Tree . get Internal Node Count ( ) ; int n = contrast Tree . get Internal Node Count ( ) + NUM ; double log L = n * Math . log ( NUM * Math . PI * s2 ) ; log L += slog CV ; log L += sss Contrast / s2 ; log L = - log L / NUM ; return log L ; }
@ Suppress Warnings ( STRING ) public static void add Extra Encoding ( String name , I Extra Encoding enc ) { synchronized ( extra Encodings ) { extra Encodings . put ( name . to Lower Case ( ) , enc ) ; } }
public void shuffle ( Random rand ) { for ( int i = pos ; i -- > NUM ; ) { swap ( i , rand . next Int ( i ) ) ; } }
public void shuffle ( Random rand ) { for ( int i = pos ; i -- > NUM ; ) { swap ( i , rand . next Int ( i ) ) ; } }
public Set < String > has Revisions ( Collection < Change > candidates ) { Update Builder b = new Update Builder ( get Revisions ) ; String Builder values = new String Builder ( ) ; for ( Change entry : candidates ) { values . append ( STRING + uris . entity ( ) + entry . entity Id ( ) + STRING + entry . revision ( ) + STRING ) ; } b . bind ( STRING , values . to String ( ) ) ; b . bind Uri ( STRING , Schema Dot Org . VERSION ) ; return result To Set ( query ( b . to String ( ) ) , STRING ) ; }
public Set < String > has Revisions ( Collection < Change > candidates ) { Update Builder b = new Update Builder ( get Revisions ) ; String Builder values = new String Builder ( ) ; for ( Change entry : candidates ) { values . append ( STRING + uris . entity ( ) + entry . entity Id ( ) + STRING + entry . revision ( ) + STRING ) ; } b . bind ( STRING , values . to String ( ) ) ; b . bind Uri ( STRING , Schema Dot Org . VERSION ) ; return result To Set ( query ( b . to String ( ) ) , STRING ) ; }
public Set < String > has Revisions ( Collection < Change > candidates ) { Update Builder b = new Update Builder ( get Revisions ) ; String Builder values = new String Builder ( ) ; for ( Change entry : candidates ) { values . append ( STRING + uris . entity ( ) + entry . entity Id ( ) + STRING + entry . revision ( ) + STRING ) ; } b . bind ( STRING , values . to String ( ) ) ; b . bind Uri ( STRING , Schema Dot Org . VERSION ) ; return result To Set ( query ( b . to String ( ) ) , STRING ) ; }
public Set < String > has Revisions ( Collection < Change > candidates ) { Update Builder b = new Update Builder ( get Revisions ) ; String Builder values = new String Builder ( ) ; for ( Change entry : candidates ) { values . append ( STRING + uris . entity ( ) + entry . entity Id ( ) + STRING + entry . revision ( ) + STRING ) ; } b . bind ( STRING , values . to String ( ) ) ; b . bind Uri ( STRING , Schema Dot Org . VERSION ) ; return result To Set ( query ( b . to String ( ) ) , STRING ) ; }
public Set < String > has Revisions ( Collection < Change > candidates ) { Update Builder b = new Update Builder ( get Revisions ) ; String Builder values = new String Builder ( ) ; for ( Change entry : candidates ) { values . append ( STRING + uris . entity ( ) + entry . entity Id ( ) + STRING + entry . revision ( ) + STRING ) ; } b . bind ( STRING , values . to String ( ) ) ; b . bind Uri ( STRING , Schema Dot Org . VERSION ) ; return result To Set ( query ( b . to String ( ) ) , STRING ) ; }
public Set < String > has Revisions ( Collection < Change > candidates ) { Update Builder b = new Update Builder ( get Revisions ) ; String Builder values = new String Builder ( ) ; for ( Change entry : candidates ) { values . append ( STRING + uris . entity ( ) + entry . entity Id ( ) + STRING + entry . revision ( ) + STRING ) ; } b . bind ( STRING , values . to String ( ) ) ; b . bind Uri ( STRING , Schema Dot Org . VERSION ) ; return result To Set ( query ( b . to String ( ) ) , STRING ) ; }
public Set < String > has Revisions ( Collection < Change > candidates ) { Update Builder b = new Update Builder ( get Revisions ) ; String Builder values = new String Builder ( ) ; for ( Change entry : candidates ) { values . append ( STRING + uris . entity ( ) + entry . entity Id ( ) + STRING + entry . revision ( ) + STRING ) ; } b . bind ( STRING , values . to String ( ) ) ; b . bind Uri ( STRING , Schema Dot Org . VERSION ) ; return result To Set ( query ( b . to String ( ) ) , STRING ) ; }
public long cardinality ( ) { switch ( type ) { case EMPTY : return NUM ; case EXPLICIT : return explicit Storage . size ( ) ; case SPARSE : return ( long ) Math . ceil ( sparse Probabilistic Algorithm Cardinality ( ) ) ; case FULL : return ( long ) Math . ceil ( full Probabilistic Algorithm Cardinality ( ) ) ; default : throw new Runtime Exception ( STRING + type ) ; } }
private static int limited Levenshtein ( final String str 1 , final String str 2 , int idx 1 , int idx 2 , final int limit ) { while ( BOOL ) { if ( idx 1 == str 1 . length ( ) ) { return str 2 . length ( ) - idx 2 ; } else if ( idx 2 == str 2 . length ( ) ) { return str 1 . length ( ) - idx 1 ; } else if ( str 1 . char At ( idx 1 ) != str 2 . char At ( idx 2 ) ) { if ( limit < NUM ) { return NUM ; } else { return NUM + best Lim Lev ( str 1 , str 2 , idx 1 , idx 2 , limit - NUM ) ; } } ++ idx 1 ; ++ idx 2 ; } }
private static int limited Levenshtein ( final String str 1 , final String str 2 , int idx 1 , int idx 2 , final int limit ) { while ( BOOL ) { if ( idx 1 == str 1 . length ( ) ) { return str 2 . length ( ) - idx 2 ; } else if ( idx 2 == str 2 . length ( ) ) { return str 1 . length ( ) - idx 1 ; } else if ( str 1 . char At ( idx 1 ) != str 2 . char At ( idx 2 ) ) { if ( limit < NUM ) { return NUM ; } else { return NUM + best Lim Lev ( str 1 , str 2 , idx 1 , idx 2 , limit - NUM ) ; } } ++ idx 1 ; ++ idx 2 ; } }
private static int limited Levenshtein ( final String str 1 , final String str 2 , int idx 1 , int idx 2 , final int limit ) { while ( BOOL ) { if ( idx 1 == str 1 . length ( ) ) { return str 2 . length ( ) - idx 2 ; } else if ( idx 2 == str 2 . length ( ) ) { return str 1 . length ( ) - idx 1 ; } else if ( str 1 . char At ( idx 1 ) != str 2 . char At ( idx 2 ) ) { if ( limit < NUM ) { return NUM ; } else { return NUM + best Lim Lev ( str 1 , str 2 , idx 1 , idx 2 , limit - NUM ) ; } } ++ idx 1 ; ++ idx 2 ; } }
private static int limited Levenshtein ( final String str 1 , final String str 2 , int idx 1 , int idx 2 , final int limit ) { while ( BOOL ) { if ( idx 1 == str 1 . length ( ) ) { return str 2 . length ( ) - idx 2 ; } else if ( idx 2 == str 2 . length ( ) ) { return str 1 . length ( ) - idx 1 ; } else if ( str 1 . char At ( idx 1 ) != str 2 . char At ( idx 2 ) ) { if ( limit < NUM ) { return NUM ; } else { return NUM + best Lim Lev ( str 1 , str 2 , idx 1 , idx 2 , limit - NUM ) ; } } ++ idx 1 ; ++ idx 2 ; } }
private static int limited Levenshtein ( final String str 1 , final String str 2 , int idx 1 , int idx 2 , final int limit ) { while ( BOOL ) { if ( idx 1 == str 1 . length ( ) ) { return str 2 . length ( ) - idx 2 ; } else if ( idx 2 == str 2 . length ( ) ) { return str 1 . length ( ) - idx 1 ; } else if ( str 1 . char At ( idx 1 ) != str 2 . char At ( idx 2 ) ) { if ( limit < NUM ) { return NUM ; } else { return NUM + best Lim Lev ( str 1 , str 2 , idx 1 , idx 2 , limit - NUM ) ; } } ++ idx 1 ; ++ idx 2 ; } }
private Tuple < Message , Connection > try Other Messages ( ) { List < Tuple < Message , Connection > > messages = new Array List < Tuple < Message , Connection > > ( ) ; Collection < Message > msg Collection = get Message Collection ( ) ; for ( Connection con : get Connections ( ) ) { DTN Host other = con . get Other Node ( get Host ( ) ) ; Prophet V 2 Router oth Router = ( Prophet V 2 Router ) other . get Router ( ) ; if ( oth Router . is Transferring ( ) ) { continue ; } for ( Message m : msg Collection ) { if ( oth Router . has Message ( m . get Id ( ) ) ) { continue ; } if ( ( oth Router . get Pred For ( m . get To ( ) ) >= get Pred For ( m . get To ( ) ) ) ) { messages . add ( new Tuple < Message , Connection > ( m , con ) ) ; } } } if ( messages . size ( ) == NUM ) { return null ; } Collections . sort ( messages , new Tuple Comparator ( ) ) ; return try Messages For Connected ( messages ) ; }
public static void put Object ( final Byte Buffer buffer , Serializable o ) { try ( Byte Array Output Stream bos = new Byte Array Output Stream ( ) ) { try ( Object Output oout = new Object Output Stream ( bos ) ) { oout . write Object ( o ) ; byte [ ] lane Bytes = bos . to Byte Array ( ) ; buffer . put Int ( lane Bytes . length ) ; for ( int i = NUM ; i < lane Bytes . length ; i ++ ) { buffer . put ( lane Bytes [ i ] ) ; } } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
public static void put Object ( final Byte Buffer buffer , Serializable o ) { try ( Byte Array Output Stream bos = new Byte Array Output Stream ( ) ) { try ( Object Output oout = new Object Output Stream ( bos ) ) { oout . write Object ( o ) ; byte [ ] lane Bytes = bos . to Byte Array ( ) ; buffer . put Int ( lane Bytes . length ) ; for ( int i = NUM ; i < lane Bytes . length ; i ++ ) { buffer . put ( lane Bytes [ i ] ) ; } } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
public static void put Object ( final Byte Buffer buffer , Serializable o ) { try ( Byte Array Output Stream bos = new Byte Array Output Stream ( ) ) { try ( Object Output oout = new Object Output Stream ( bos ) ) { oout . write Object ( o ) ; byte [ ] lane Bytes = bos . to Byte Array ( ) ; buffer . put Int ( lane Bytes . length ) ; for ( int i = NUM ; i < lane Bytes . length ; i ++ ) { buffer . put ( lane Bytes [ i ] ) ; } } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
public String rename Entry ( SSO Token token , int object Type , String entry DN , String new Name , boolean delete Old Name ) throws AM Exception { String new DN = super . rename Entry ( token , object Type , entry DN , new Name , delete Old Name ) ; String old DN = LDAP Utils . format To RFC ( entry DN ) ; Cache Block cb = ( Cache Block ) sdk Cache . remove ( old DN ) ; new DN = LDAP Utils . format To RFC ( new DN ) ; sdk Cache . put ( new DN , cb ) ; return new DN ; }
public Tv Show Update Datasource Task ( String datasource ) { super ( BUNDLE . get String ( STRING ) + STRING + datasource + STRING ) ; tv Show List = Tv Show List . get Instance ( ) ; data Sources = new Array List < > ( NUM ) ; data Sources . add ( datasource ) ; }
public Tv Show Update Datasource Task ( String datasource ) { super ( BUNDLE . get String ( STRING ) + STRING + datasource + STRING ) ; tv Show List = Tv Show List . get Instance ( ) ; data Sources = new Array List < > ( NUM ) ; data Sources . add ( datasource ) ; }
public void copy Resource ( String resource Name , File dest File , Filter Chain filter Chain , String encoding ) throws IO Exception { copy Resource ( resource Name , dest File . get Path ( ) , default File Handler , filter Chain , encoding ) ; }
protected Set convert List To Set ( List list ) { Set s = new Hash Set ( ) ; Iterator it = list . iterator ( ) ; while ( it . has Next ( ) ) { s . add ( it . next ( ) ) ; } return s ; }
protected Set convert List To Set ( List list ) { Set s = new Hash Set ( ) ; Iterator it = list . iterator ( ) ; while ( it . has Next ( ) ) { s . add ( it . next ( ) ) ; } return s ; }
public Site Monitor ( String [ ] url List ) { site Url List = url List ; }
public int position ( ) { return buff . position ( ) ; }
public J Rak Lib Client ( Logger logger , String server IP , int server Port ) { if ( server Port < NUM || server Port > NUM ) { throw new Illegal Argument Exception ( STRING ) ; } this . logger = logger ; this . server Endpoint = new Inet Socket Address ( server IP , server Port ) ; external Queue = new Linked List < > ( ) ; internal Queue = new Linked List < > ( ) ; start ( ) ; }
void remove Ripple ( Ripple ripple ) { final Ripple [ ] ripples = m Exiting Ripples ; final int count = m Exiting Ripples Count ; final int index = get Ripple Index ( ripple ) ; if ( index >= NUM ) { System . arraycopy ( ripples , index + NUM , ripples , index , count - ( index + NUM ) ) ; ripples [ count - NUM ] = null ; m Exiting Ripples Count -- ; invalidate Self ( ) ; } }
public final Parallel Flux < T > do After Terminate ( Runnable after Terminate ) { Objects . require Non Null ( after Terminate , STRING ) ; return do On Signal ( this , null , null , null , null , after Terminate , null , null , null ) ; }
protected static int read Fully ( Reader reader , char [ ] buf , int length ) throws IO Exception { int num Chars Read = NUM ; while ( num Chars Read < length ) { int count = reader . read ( buf , num Chars Read , length - num Chars Read ) ; if ( count < NUM ) { break ; } num Chars Read += count ; } return num Chars Read ; }
public static String convert To Title ( int n ) { if ( n <= NUM ) return STRING ; String Builder title = new String Builder ( ) ; while ( n > NUM ) { n -- ; int r = n % NUM ; title . insert ( NUM , ( char ) ( STRING + r ) ) ; n = n / NUM ; } return title . to String ( ) ; }
public static String convert To Title ( int n ) { if ( n <= NUM ) return STRING ; String Builder title = new String Builder ( ) ; while ( n > NUM ) { n -- ; int r = n % NUM ; title . insert ( NUM , ( char ) ( STRING + r ) ) ; n = n / NUM ; } return title . to String ( ) ; }
public static String convert To Title ( int n ) { if ( n <= NUM ) return STRING ; String Builder title = new String Builder ( ) ; while ( n > NUM ) { n -- ; int r = n % NUM ; title . insert ( NUM , ( char ) ( STRING + r ) ) ; n = n / NUM ; } return title . to String ( ) ; }
private String construct ISCSI Names Query ( String system Id , List < Host Storage Domain > hsd List , String model ) { Map < String , Object > attribute Map = new Hash Map < String , Object > ( ) ; Storage Array array = new Storage Array ( system Id ) ; Add add Op = new Add ( HDS Constants . ISCSI NAME FOR HSD TARGET ) ; attribute Map . put ( HDS Constants . STORAGEARRAY , array ) ; attribute Map . put ( HDS Constants . ADD , add Op ) ; attribute Map . put ( HDS Constants . MODEL , model ) ; attribute Map . put ( HDS Constants . HOSTGROUP LIST , hsd List ) ; String add WWN Query = Input XML Generation Client . get Input XML String ( HDS Constants . BATCH ADD WWN TO HSD OP , attribute Map , HDS Constants . HITACHI INPUT XML CONTEXT FILE , HDS Constants . HITACHI SMOOKS CONFIG FILE ) ; return add WWN Query ; }
private String construct ISCSI Names Query ( String system Id , List < Host Storage Domain > hsd List , String model ) { Map < String , Object > attribute Map = new Hash Map < String , Object > ( ) ; Storage Array array = new Storage Array ( system Id ) ; Add add Op = new Add ( HDS Constants . ISCSI NAME FOR HSD TARGET ) ; attribute Map . put ( HDS Constants . STORAGEARRAY , array ) ; attribute Map . put ( HDS Constants . ADD , add Op ) ; attribute Map . put ( HDS Constants . MODEL , model ) ; attribute Map . put ( HDS Constants . HOSTGROUP LIST , hsd List ) ; String add WWN Query = Input XML Generation Client . get Input XML String ( HDS Constants . BATCH ADD WWN TO HSD OP , attribute Map , HDS Constants . HITACHI INPUT XML CONTEXT FILE , HDS Constants . HITACHI SMOOKS CONFIG FILE ) ; return add WWN Query ; }
public void test Weakly Consistent Iteration ( ) { final Linked Blocking Queue q = new Linked Blocking Queue ( NUM ) ; q . add ( one ) ; q . add ( two ) ; q . add ( three ) ; for ( Iterator it = q . iterator ( ) ; it . has Next ( ) ; ) { q . remove ( ) ; it . next ( ) ; } assert Equals ( NUM , q . size ( ) ) ; }
public void test Weakly Consistent Iteration ( ) { final Linked Blocking Queue q = new Linked Blocking Queue ( NUM ) ; q . add ( one ) ; q . add ( two ) ; q . add ( three ) ; for ( Iterator it = q . iterator ( ) ; it . has Next ( ) ; ) { q . remove ( ) ; it . next ( ) ; } assert Equals ( NUM , q . size ( ) ) ; }
public void test Weakly Consistent Iteration ( ) { final Linked Blocking Queue q = new Linked Blocking Queue ( NUM ) ; q . add ( one ) ; q . add ( two ) ; q . add ( three ) ; for ( Iterator it = q . iterator ( ) ; it . has Next ( ) ; ) { q . remove ( ) ; it . next ( ) ; } assert Equals ( NUM , q . size ( ) ) ; }
@ Override public void layer Moved ( final Map Layer List Event event ) { redraw Base Image = BOOL ; if ( ! is Disposed ( ) ) redraw ( ) ; }
public static Color disable ( Color color ) { int alpha = color . get Alpha ( ) ; alpha /= NUM ; return new Color ( ( color . get RGB ( ) & NUM ) | ( alpha << NUM ) , BOOL ) ; }
public void test Find Spring Active Directory ( ) { Ldap Proxy proxy = get Ldap AD ( ) ; List result = null ; try { result = proxy . find ( get Ldap Search VO ( STRING , Ldap Constants . NO SEARCH LIMIT , null , null , null , Ldap Scope Constants . SCOPE SUBTREE ) ) ; } catch ( Exception e ) { } assert Not Null ( result ) ; assert Equals ( NUM , result . size ( ) ) ; }
protected void assert View Has Text ( int view Id , String text ) { String view Text = text Of View ( view Id ) ; at ( STRING + view Text + STRING + text , view Text . contains ( text ) ) ; }
public static String strip Url ( String url ) { if ( url == null ) return null ; Matcher m = STRIP URL PATTERN . matcher ( url ) ; if ( m . matches ( ) ) { return m . group ( NUM ) ; } else { return url ; } }
public static String strip Url ( String url ) { if ( url == null ) return null ; Matcher m = STRIP URL PATTERN . matcher ( url ) ; if ( m . matches ( ) ) { return m . group ( NUM ) ; } else { return url ; } }
public static String strip Url ( String url ) { if ( url == null ) return null ; Matcher m = STRIP URL PATTERN . matcher ( url ) ; if ( m . matches ( ) ) { return m . group ( NUM ) ; } else { return url ; } }
protected void process Ping Request ( Sim Event ev ) { Info Packet pkt = ( Info Packet ) ev . get Data ( ) ; pkt . set Tag ( Cloud Sim Tags . INFOPKT RETURN ) ; pkt . set Dest Id ( pkt . get Src Id ( ) ) ; send Now ( pkt . get Src Id ( ) , Cloud Sim Tags . INFOPKT RETURN , pkt ) ; }
public boolean is Pure JAAS Module Present ( final String config Name , final Configuration configuration ) throws Auth Login Exception { if ( enforce JAAS Thread ) { return BOOL ; } if ( null == configuration ) { return BOOL ; } final App Configuration Entry [ ] entries = configuration . get App Configuration Entry ( config Name ) ; if ( entries == null ) { throw new Auth Login Exception ( STRING , AM Auth Error Code . AUTH CONFIG NOT FOUND , null ) ; } for ( App Configuration Entry entry : entries ) { String class Name = entry . get Login Module Name ( ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + class Name ) ; } if ( is Pure JAAS Module ( class Name ) ) { return BOOL ; } else if ( ! is IS Module ( class Name ) ) { categorise Module Class From Classname ( class Name ) ; if ( is Pure JAAS Module ( class Name ) ) { return BOOL ; } } } return BOOL ; }
public boolean is Pure JAAS Module Present ( final String config Name , final Configuration configuration ) throws Auth Login Exception { if ( enforce JAAS Thread ) { return BOOL ; } if ( null == configuration ) { return BOOL ; } final App Configuration Entry [ ] entries = configuration . get App Configuration Entry ( config Name ) ; if ( entries == null ) { throw new Auth Login Exception ( STRING , AM Auth Error Code . AUTH CONFIG NOT FOUND , null ) ; } for ( App Configuration Entry entry : entries ) { String class Name = entry . get Login Module Name ( ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + class Name ) ; } if ( is Pure JAAS Module ( class Name ) ) { return BOOL ; } else if ( ! is IS Module ( class Name ) ) { categorise Module Class From Classname ( class Name ) ; if ( is Pure JAAS Module ( class Name ) ) { return BOOL ; } } } return BOOL ; }
@ Ignore ( STRING ) @ Test public void test Concurrent Events On Empty Region ( ) { version Test Concurrent Events On Empty Region ( ) ; }
@ Ignore ( STRING ) @ Test public void test Concurrent Events On Empty Region ( ) { version Test Concurrent Events On Empty Region ( ) ; }
@ Ignore ( STRING ) @ Test public void test Concurrent Events On Empty Region ( ) { version Test Concurrent Events On Empty Region ( ) ; }
@ Ignore ( STRING ) @ Test public void test Concurrent Events On Empty Region ( ) { version Test Concurrent Events On Empty Region ( ) ; }
@ Ignore ( STRING ) @ Test public void test Concurrent Events On Empty Region ( ) { version Test Concurrent Events On Empty Region ( ) ; }
@ Ignore ( STRING ) @ Test public void test Concurrent Events On Empty Region ( ) { version Test Concurrent Events On Empty Region ( ) ; }
public Matrix 3 ( Matrix 3 matrix ) { if ( matrix == null ) { throw new Illegal Argument Exception ( Logger . log Message ( Logger . ERROR , STRING , STRING , STRING ) ) ; } System . arraycopy ( matrix . m , NUM , this . m , NUM , NUM ) ; }
public Parameter Type File ( String key , String description , boolean optional , String [ ] extensions ) { super ( key , description , null ) ; set Optional ( optional ) ; this . extensions = extensions ; }
public Parameter Type File ( String key , String description , boolean optional , String [ ] extensions ) { super ( key , description , null ) ; set Optional ( optional ) ; this . extensions = extensions ; }
public void write To ( byte [ ] bytes , int offset ) throws IO Exception { flush ( ) ; final long end = file . length ; long pos = NUM ; int buffer = NUM ; int bytes Upto = offset ; while ( pos < end ) { int length = BUFFER SIZE ; long next Pos = pos + length ; if ( next Pos > end ) { length = ( int ) ( end - pos ) ; } System . arraycopy ( file . get Buffer ( buffer ++ ) , NUM , bytes , bytes Upto , length ) ; bytes Upto += length ; pos = next Pos ; } }
public void add Selection Listener ( Explorer Selection Listener listener ) { selection Listeners . add ( listener ) ; }
public void add Selection Listener ( Explorer Selection Listener listener ) { selection Listeners . add ( listener ) ; }
public void add Selection Listener ( Explorer Selection Listener listener ) { selection Listeners . add ( listener ) ; }
private void update Next Clock ( final Pseudo TCP Base tcp , final Object lock ) { try { long now = Pseudo TCP Base . now ( ) ; synchronized ( tcp ) { tcp . notify Clock ( now ) ; } long interval ; synchronized ( tcp ) { interval = tcp . get Next Clock ( Pseudo TCP Base . now ( ) ) ; } if ( logger . is Loggable ( Level . FINEST ) ) { logger . log ( Level . FINEST , tcp . debug Name + STRING + interval ) ; } if ( interval < NUM ) { if ( interval == - NUM ) { interval = NUM ; } else { return ; } } synchronized ( lock ) { lock . wait ( interval ) ; } } catch ( Interrupted Exception ex ) { } }
public ECIES Key Encapsulation ( Derivation Function kdf , Secure Random rnd ) { this . kdf = kdf ; this . rnd = rnd ; this . Cofactor Mode = BOOL ; this . Old Cofactor Mode = BOOL ; this . Single Hash Mode = BOOL ; }
@ Deprecated public void add Prefix NS Mapping ( String prefix , String ns URI ) { if ( ns URI . length ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( prefix . length ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( prefix . equals ( NO NS PREFIX ) ) { throw new Illegal Argument Exception ( STRING + prefix + STRING ) ; } if ( prefix To Namespace URI Lookup . contains Key ( prefix ) ) { throw new Illegal Argument Exception ( STRING + prefix + STRING ) ; } if ( namespace URI To Prefix Lookup . contains Key ( ns URI ) ) { throw new Illegal Argument Exception ( STRING + ns URI + STRING ) ; } if ( prefix . equals ( DEFAULT NAMESPACE PREFIX ) ) { this . default NS = ns URI ; } else { prefix To Namespace URI Lookup . put ( prefix , ns URI ) ; namespace URI To Prefix Lookup . put ( ns URI , prefix ) ; } }
public static Optional < String > package Name ( String long Name ) { if ( long Name . contains ( STRING ) ) { return Optional . of ( long Name . substring ( NUM , long Name . last Index Of ( STRING ) ) ) ; } else { return Optional . empty ( ) ; } }
@ Override public void after Authorize Success ( O Auth 2 Request o2 request , Request request , Response response ) { Series < Cookie Setting > cookies Set In This Response = response . get Cookie Settings ( ) ; Cookie Setting login Hint Cookie Setting = cookies Set In This Response . get First ( LOGIN HINT COOKIE ) ; if ( login Hint Cookie Setting != null && login Hint Cookie Setting . get Max Age ( ) != NUM ) { cookies Set In This Response . remove First ( LOGIN HINT COOKIE ) ; } remove Cookie ( request , response ) ; }
@ Override public void after Authorize Success ( O Auth 2 Request o2 request , Request request , Response response ) { Series < Cookie Setting > cookies Set In This Response = response . get Cookie Settings ( ) ; Cookie Setting login Hint Cookie Setting = cookies Set In This Response . get First ( LOGIN HINT COOKIE ) ; if ( login Hint Cookie Setting != null && login Hint Cookie Setting . get Max Age ( ) != NUM ) { cookies Set In This Response . remove First ( LOGIN HINT COOKIE ) ; } remove Cookie ( request , response ) ; }
@ Override public void after Authorize Success ( O Auth 2 Request o2 request , Request request , Response response ) { Series < Cookie Setting > cookies Set In This Response = response . get Cookie Settings ( ) ; Cookie Setting login Hint Cookie Setting = cookies Set In This Response . get First ( LOGIN HINT COOKIE ) ; if ( login Hint Cookie Setting != null && login Hint Cookie Setting . get Max Age ( ) != NUM ) { cookies Set In This Response . remove First ( LOGIN HINT COOKIE ) ; } remove Cookie ( request , response ) ; }
@ Override public void after Authorize Success ( O Auth 2 Request o2 request , Request request , Response response ) { Series < Cookie Setting > cookies Set In This Response = response . get Cookie Settings ( ) ; Cookie Setting login Hint Cookie Setting = cookies Set In This Response . get First ( LOGIN HINT COOKIE ) ; if ( login Hint Cookie Setting != null && login Hint Cookie Setting . get Max Age ( ) != NUM ) { cookies Set In This Response . remove First ( LOGIN HINT COOKIE ) ; } remove Cookie ( request , response ) ; }
private float over Scroll Up ( int delta Y , int range ) { delta Y = Math . max ( delta Y , NUM ) ; float current Top Amount = get Current Over Scroll Amount ( BOOL ) ; float new Top Amount = current Top Amount - delta Y ; if ( current Top Amount > NUM ) { set Over Scroll Amount ( new Top Amount , BOOL , BOOL ) ; } float scroll Amount = new Top Amount < NUM ? - new Top Amount : NUM ; float new Scroll Y = m Own Scroll Y + scroll Amount ; if ( new Scroll Y > range ) { if ( ! m Expanded In This Motion ) { float current Bottom Pixels = get Current Over Scrolled Pixels ( BOOL ) ; set Over Scrolled Pixels ( current Bottom Pixels + new Scroll Y - range , BOOL , BOOL ) ; } m Own Scroll Y = range ; scroll Amount = NUM ; } return scroll Amount ; }
public void service ( Mail mail ) { try { log ( mail . get Name ( ) + STRING ) ; Mime Message message = mail . get Message ( ) ; Hash Set < Name Value Pair > pairs = get Name Value Pairs ( message ) ; log ( mail . get Name ( ) + STRING + pairs . size ( ) + STRING ) ; String result = http Post ( pairs ) ; if ( pass Through ) { add Header ( mail , BOOL , result ) ; } else { mail . set State ( Mail . GHOST ) ; } } catch ( javax . mail . Messaging Exception me ) { log ( me . get Message ( ) ) ; add Header ( mail , BOOL , me . get Message ( ) ) ; } catch ( IO Exception e ) { log ( e . get Message ( ) ) ; add Header ( mail , BOOL , e . get Message ( ) ) ; } }
public void add Extension Namespace ( String uri , Extension Handler ext NS ) { m extension Function Namespaces . put ( uri , ext NS ) ; }
public void add Extension Namespace ( String uri , Extension Handler ext NS ) { m extension Function Namespaces . put ( uri , ext NS ) ; }
public void add Extension Namespace ( String uri , Extension Handler ext NS ) { m extension Function Namespaces . put ( uri , ext NS ) ; }
public void add Extension Namespace ( String uri , Extension Handler ext NS ) { m extension Function Namespaces . put ( uri , ext NS ) ; }
public Component Manager ( Collection < Sequence > general Seeds ) { Set < Sequence > seed Set = new Linked Hash Set < > ( general Seeds . size ( ) ) ; seed Set . add All ( general Seeds ) ; this . gral Seeds = Collections . unmodifiable Set ( seed Set ) ; gral Components = new Sequence Collection ( seed Set ) ; }
public void record State ( Dialogue State state , String name ) { if ( frame != null ) { state Monitor Tab . record State ( state , name ) ; } }
public void record State ( Dialogue State state , String name ) { if ( frame != null ) { state Monitor Tab . record State ( state , name ) ; } }
public void record State ( Dialogue State state , String name ) { if ( frame != null ) { state Monitor Tab . record State ( state , name ) ; } }
private void update ( Tuple input ) { JSON Object message = ( JSON Object ) input . get Value By Field ( STRING ) ; try { Map < String , String > expressions = profile Config . get Update ( ) ; expressions . for Each ( null ) ; } catch ( Parse Exception e ) { String msg = format ( STRING , e . get Message ( ) , measurement . get Profile Name ( ) , measurement . get Entity ( ) ) ; throw new Parse Exception ( msg , e ) ; } }
private static int global Error Handler ( long display , long event ptr ) { if ( noisy Awt Handler ) { Xlib Wrapper . Print X Error Event ( display , event ptr ) ; } X Error Event event = new X Error Event ( event ptr ) ; saved error = event ; try { if ( current error handler != null ) { return current error handler . handle Error ( display , event ) ; } else { return SAVED XERROR HANDLER ( display , event ) ; } } catch ( Throwable z ) { log . fine ( STRING , z ) ; } return NUM ; }
protected void parse And Add ( List list , String line ) { try { String Tokenizer tokenizer = new String Tokenizer ( line , STRING ) ; String feature = tokenizer . next Token ( ) ; float start = Float . parse Float ( tokenizer . next Token ( ) ) ; float mid = Float . parse Float ( tokenizer . next Token ( ) ) ; float end = Float . parse Float ( tokenizer . next Token ( ) ) ; String type = tokenizer . next Token ( ) ; if ( type . equals ( STRING ) ) { type = null ; } list . add ( new F0 Model Term ( feature , start , mid , end , type ) ) ; } catch ( No Such Element Exception nsee ) { throw new Error ( STRING + nsee . get Message ( ) ) ; } catch ( Number Format Exception nfe ) { throw new Error ( STRING + nfe . get Message ( ) ) ; } }
public void union ( Clip c ) { if ( status == INVALID ) return ; if ( status == EMPTY ) { set Clip ( c ) ; status = INUSE ; return ; } clip [ NUM ] = Math . min ( clip [ NUM ] , c . clip [ NUM ] ) ; clip [ NUM ] = Math . min ( clip [ NUM ] , c . clip [ NUM ] ) ; clip [ NUM ] = Math . max ( clip [ NUM ] , c . clip [ NUM ] ) ; clip [ NUM ] = Math . max ( clip [ NUM ] , c . clip [ NUM ] ) ; }
public boolean is Equivalent ( Transaction transaction ) { return m Id . equals ( transaction . m Id ) ; }
@ Override public void write ( byte b [ ] ) throws IO Exception { for ( Output Stream stream : outs ) stream . write ( b ) ; }
private File calc Parent Tree ( ) { File parent Tree = tree File . get Parent File ( ) ; if ( null == parent Tree ) { return null ; } if ( tree File . is Absolute ( ) && ( null == parent Tree . get Parent File ( ) ) ) { return null ; } return parent Tree ; }
private File calc Parent Tree ( ) { File parent Tree = tree File . get Parent File ( ) ; if ( null == parent Tree ) { return null ; } if ( tree File . is Absolute ( ) && ( null == parent Tree . get Parent File ( ) ) ) { return null ; } return parent Tree ; }
private File calc Parent Tree ( ) { File parent Tree = tree File . get Parent File ( ) ; if ( null == parent Tree ) { return null ; } if ( tree File . is Absolute ( ) && ( null == parent Tree . get Parent File ( ) ) ) { return null ; } return parent Tree ; }
private File calc Parent Tree ( ) { File parent Tree = tree File . get Parent File ( ) ; if ( null == parent Tree ) { return null ; } if ( tree File . is Absolute ( ) && ( null == parent Tree . get Parent File ( ) ) ) { return null ; } return parent Tree ; }
private File calc Parent Tree ( ) { File parent Tree = tree File . get Parent File ( ) ; if ( null == parent Tree ) { return null ; } if ( tree File . is Absolute ( ) && ( null == parent Tree . get Parent File ( ) ) ) { return null ; } return parent Tree ; }
void parse ( ) throws IO Exception { while ( BOOL ) { final String line = m In . read Line ( ) ; if ( line == null ) { break ; } final String msg = line ( line ) ; if ( msg != null ) { error ( STRING + line + LS + msg ) ; } } end ( ) ; }
public static String quote ( String input ) { if ( input . contains ( STRING ) ) { return STRING + input + STRING ; } else { return input ; } }
public static String quote ( String input ) { if ( input . contains ( STRING ) ) { return STRING + input + STRING ; } else { return input ; } }
private List < Constraint < ? > > build Query ( Path Condition pc , int condition Index ) { Path Condition negated Path Condition = pc . negate ( condition Index ) ; List < Constraint < ? > > query = negated Path Condition . get Constraints ( ) ; List < Constraint < ? > > simplified query = reduce ( query ) ; return simplified query ; }
public Random Filter ( final double minimum Value , final double maximum Value ) { if ( minimum Value > maximum Value ) { throw new Illegal Argument Exception ( STRING ) ; } this . minimum Value = minimum Value ; this . maximum Value = maximum Value ; difference = Math . abs ( this . maximum Value - this . minimum Value ) ; random = new Random ( ) ; }
public static boolean is File Exist ( String file Path , File Type file Type , boolean perform File Check ) throws IO Exception { file Path = file Path . replace ( STRING , STRING ) ; switch ( file Type ) { case HDFS : case VIEWFS : Path path = new Path ( file Path ) ; File System fs = path . get File System ( configuration ) ; if ( perform File Check ) { return fs . exists ( path ) && fs . is File ( path ) ; } else { return fs . exists ( path ) ; } case LOCAL : default : File default File = new File ( file Path ) ; if ( perform File Check ) { return default File . exists ( ) && default File . is File ( ) ; } else { return default File . exists ( ) ; } } }
public T Sink < String > send String ( T Stream < String > stream ) { Objects . require Non Null ( stream , STRING ) ; return send Text ( stream , null ) ; }
public T Sink < String > send String ( T Stream < String > stream ) { Objects . require Non Null ( stream , STRING ) ; return send Text ( stream , null ) ; }
public void unbind Tree ( Container ui ) { int component Count = ui . get Component Count ( ) ; for ( int iter = NUM ; iter < component Count ; iter ++ ) { Component c = ui . get Component At ( iter ) ; if ( c instanceof Container ) { unbind Tree ( ( Container ) c ) ; continue ; } String bind = c . get Cloud Bound Property ( ) ; if ( bind != null && bind . length ( ) > NUM ) { String attribute Name = c . get Cloud Destination Property ( ) ; if ( attribute Name != null ) { unbind Property ( c , bind ) ; } } } }
public boolean show Notice In Server Window ( ) { return preferences . get Boolean ( resources . get String ( R . string . key notice server window ) , Boolean . parse Boolean ( resources . get String ( R . string . default notice server window ) ) ) ; }
public boolean show Notice In Server Window ( ) { return preferences . get Boolean ( resources . get String ( R . string . key notice server window ) , Boolean . parse Boolean ( resources . get String ( R . string . default notice server window ) ) ) ; }
protected Doc Writer create Writer ( final M Basic Table table , final Document document , final Output Stream out ) throws Document Exception { final Pdf Writer writer = Pdf Writer . get Instance ( document , out ) ; if ( table . get Name ( ) != null ) { final Header Footer header = new Header Footer ( new Phrase ( table . get Name ( ) ) , BOOL ) ; header . set Alignment ( Element . ALIGN LEFT ) ; header . set Border ( Rectangle . NO BORDER ) ; document . set Header ( header ) ; document . add Title ( table . get Name ( ) ) ; } writer . set Page Event ( new Advanced Page Number Events ( ) ) ; return writer ; }
protected Doc Writer create Writer ( final M Basic Table table , final Document document , final Output Stream out ) throws Document Exception { final Pdf Writer writer = Pdf Writer . get Instance ( document , out ) ; if ( table . get Name ( ) != null ) { final Header Footer header = new Header Footer ( new Phrase ( table . get Name ( ) ) , BOOL ) ; header . set Alignment ( Element . ALIGN LEFT ) ; header . set Border ( Rectangle . NO BORDER ) ; document . set Header ( header ) ; document . add Title ( table . get Name ( ) ) ; } writer . set Page Event ( new Advanced Page Number Events ( ) ) ; return writer ; }
protected Doc Writer create Writer ( final M Basic Table table , final Document document , final Output Stream out ) throws Document Exception { final Pdf Writer writer = Pdf Writer . get Instance ( document , out ) ; if ( table . get Name ( ) != null ) { final Header Footer header = new Header Footer ( new Phrase ( table . get Name ( ) ) , BOOL ) ; header . set Alignment ( Element . ALIGN LEFT ) ; header . set Border ( Rectangle . NO BORDER ) ; document . set Header ( header ) ; document . add Title ( table . get Name ( ) ) ; } writer . set Page Event ( new Advanced Page Number Events ( ) ) ; return writer ; }
private static void stopping Animation ( Thread me ) { final Fetcher Info info = Fetcher Info . get Fetcher Info ( ) ; synchronized ( info . wait List ) { int index = - NUM ; for ( int i = NUM ; i < info . fetchers . length ; i ++ ) { if ( info . fetchers [ i ] == me ) { return ; } if ( info . fetchers [ i ] == null ) { index = i ; } } if ( index >= NUM ) { info . fetchers [ index ] = me ; info . num Fetchers ++ ; me . set Name ( STRING + index ) ; return ; } } }
private static void stopping Animation ( Thread me ) { final Fetcher Info info = Fetcher Info . get Fetcher Info ( ) ; synchronized ( info . wait List ) { int index = - NUM ; for ( int i = NUM ; i < info . fetchers . length ; i ++ ) { if ( info . fetchers [ i ] == me ) { return ; } if ( info . fetchers [ i ] == null ) { index = i ; } } if ( index >= NUM ) { info . fetchers [ index ] = me ; info . num Fetchers ++ ; me . set Name ( STRING + index ) ; return ; } } }
private static void stopping Animation ( Thread me ) { final Fetcher Info info = Fetcher Info . get Fetcher Info ( ) ; synchronized ( info . wait List ) { int index = - NUM ; for ( int i = NUM ; i < info . fetchers . length ; i ++ ) { if ( info . fetchers [ i ] == me ) { return ; } if ( info . fetchers [ i ] == null ) { index = i ; } } if ( index >= NUM ) { info . fetchers [ index ] = me ; info . num Fetchers ++ ; me . set Name ( STRING + index ) ; return ; } } }
public static Double Vector rchisq ( int n , double ncp , Random random ) { Double Vector v = new Double Vector ( n ) ; double mean = Math . sqrt ( ncp ) ; double x ; for ( int i = NUM ; i < n ; i ++ ) { x = random . next Gaussian ( ) + mean ; v . set ( i , x * x ) ; } return v ; }
@ Override public Service Host start ( ) throws Throwable { super . start ( ) ; start Default Core Services Synchronously ( ) ; super . start Service ( new Root Namespace Service ( ) ) ; super . start Service ( new Sample Service With Shared Custom Ui ( ) ) ; super . start Service ( new Sample Factory Service With Custom Ui ( ) ) ; super . start Factory ( new Sample Simple Echo Service ( ) ) ; super . start Factory ( new Sample Previous Echo Service ( ) ) ; super . start Factory ( new Example Service ( ) ) ; super . start Factory ( new Example Task Service ( ) ) ; super . start Service ( new Ui Service ( ) ) ; start Swagger Descriptor Service ( ) ; return this ; }
@ Override public Service Host start ( ) throws Throwable { super . start ( ) ; start Default Core Services Synchronously ( ) ; super . start Service ( new Root Namespace Service ( ) ) ; super . start Service ( new Sample Service With Shared Custom Ui ( ) ) ; super . start Service ( new Sample Factory Service With Custom Ui ( ) ) ; super . start Factory ( new Sample Simple Echo Service ( ) ) ; super . start Factory ( new Sample Previous Echo Service ( ) ) ; super . start Factory ( new Example Service ( ) ) ; super . start Factory ( new Example Task Service ( ) ) ; super . start Service ( new Ui Service ( ) ) ; start Swagger Descriptor Service ( ) ; return this ; }
protected void read ( long offset , byte [ ] b ) throws IO Exception { rafile . seek ( offset ) ; if ( rafile . read ( b ) != b . length ) { throw new IO Exception ( STRING + get Path ( ) ) ; } }
public Schedule new Schedule ( String name ) { Schedule schedule = get Schedule By Name ( name ) ; if ( schedule == null ) { id ++ ; schedule = new Schedule ( Integer . to String ( id ) , name ) ; Integer old Size = Integer . value Of ( schedule Hash Table . size ( ) ) ; schedule Hash Table . put ( schedule . get Id ( ) , schedule ) ; set Dirty And Fire Property Change ( LISTLENGTH CHANGED PROPERTY , old Size , Integer . value Of ( schedule Hash Table . size ( ) ) ) ; } return schedule ; }
public Schedule new Schedule ( String name ) { Schedule schedule = get Schedule By Name ( name ) ; if ( schedule == null ) { id ++ ; schedule = new Schedule ( Integer . to String ( id ) , name ) ; Integer old Size = Integer . value Of ( schedule Hash Table . size ( ) ) ; schedule Hash Table . put ( schedule . get Id ( ) , schedule ) ; set Dirty And Fire Property Change ( LISTLENGTH CHANGED PROPERTY , old Size , Integer . value Of ( schedule Hash Table . size ( ) ) ) ; } return schedule ; }
public boolean accept Filename Identical ( String file Name ) { return accept Identical ( null , file Name ) ; }
public boolean accept Filename Identical ( String file Name ) { return accept Identical ( null , file Name ) ; }
public boolean accept Filename Identical ( String file Name ) { return accept Identical ( null , file Name ) ; }
public Container add Child ( @ Non Null Display Object Display Object ) { if ( m Fps != DEFAULT FPS ) { Display Object . set Up ( m Fps ) ; } m Display List . add ( Display Object ) ; return this ; }
private static int java Script Unescape Helper ( String s , int i , String Builder sb ) { if ( i >= s . length ( ) ) { throw new Illegal Argument Exception ( STRING + s + STRING ) ; } char c = s . char At ( i ++ ) ; switch ( c ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : case STRING : case STRING : case STRING : sb . append ( c ) ; break ; case STRING : String hex Code ; try { hex Code = s . substring ( i , i + NUM ) ; } catch ( Index Out Of Bounds Exception ioobe ) { throw new Illegal Argument Exception ( STRING + s . substring ( i ) + STRING + i + STRING + s + STRING ) ; } int unicode Value ; try { unicode Value = Integer . parse Int ( hex Code , NUM ) ; } catch ( Number Format Exception nfe ) { throw new Illegal Argument Exception ( STRING + hex Code + STRING + i + STRING + s + STRING ) ; } sb . append ( ( char ) unicode Value ) ; i += NUM ; break ; default : throw new Illegal Argument Exception ( STRING + c + STRING + i + STRING + s + STRING ) ; } return i ; }
private static int java Script Unescape Helper ( String s , int i , String Builder sb ) { if ( i >= s . length ( ) ) { throw new Illegal Argument Exception ( STRING + s + STRING ) ; } char c = s . char At ( i ++ ) ; switch ( c ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : case STRING : case STRING : case STRING : sb . append ( c ) ; break ; case STRING : String hex Code ; try { hex Code = s . substring ( i , i + NUM ) ; } catch ( Index Out Of Bounds Exception ioobe ) { throw new Illegal Argument Exception ( STRING + s . substring ( i ) + STRING + i + STRING + s + STRING ) ; } int unicode Value ; try { unicode Value = Integer . parse Int ( hex Code , NUM ) ; } catch ( Number Format Exception nfe ) { throw new Illegal Argument Exception ( STRING + hex Code + STRING + i + STRING + s + STRING ) ; } sb . append ( ( char ) unicode Value ) ; i += NUM ; break ; default : throw new Illegal Argument Exception ( STRING + c + STRING + i + STRING + s + STRING ) ; } return i ; }
public void load ( Input Stream is , boolean do Substitutions ) throws IO Exception { Properties props = new Properties ( ) ; props . load ( is ) ; if ( do Substitutions ) substitute System Values ( props ) ; load ( props ) ; props = null ; }
public void load ( Input Stream is , boolean do Substitutions ) throws IO Exception { Properties props = new Properties ( ) ; props . load ( is ) ; if ( do Substitutions ) substitute System Values ( props ) ; load ( props ) ; props = null ; }
public static void sleep ( ) { try { Thread . sleep ( Long . MAX VALUE ) ; } catch ( Interrupted Exception iex ) { } }
public static void sleep ( ) { try { Thread . sleep ( Long . MAX VALUE ) ; } catch ( Interrupted Exception iex ) { } }
public static void sleep ( ) { try { Thread . sleep ( Long . MAX VALUE ) ; } catch ( Interrupted Exception iex ) { } }
Location Collection enable Break ( Source File f , int line , int isolate Id ) throws Not Connected Exception { Location Collection col = new Location Collection ( ) ; boolean single Swf Breakpoint = m file Info . is Swf Filter On ( ) ; Swf Info swf = m file Info . get Swf Filter ( ) ; if ( single Swf Breakpoint ) { Location l = null ; try { l = find And Enable Break ( swf , f , line ) ; } catch ( In Progress Exception e ) { if ( Trace . error ) Trace . trace ( ( ( swf == null ) ? STRING : swf . get Url ( ) ) + STRING + f . get Name ( ) + STRING + line + STRING ) ; } col . add ( l ) ; } else { Swf Info [ ] swfs = m file Info . get Swfs ( isolate Id ) ; for ( Swf Info swf 1 : swfs ) { swf = swf 1 ; if ( swf != null ) { Location l = null ; try { l = find And Enable Break ( swf , f , line ) ; } catch ( In Progress Exception e ) { if ( Trace . error ) Trace . trace ( ( swf . get Url ( ) ) + STRING + f . get Name ( ) + STRING + line + STRING ) ; } if ( l != null ) col . add ( l ) ; } } } return col ; }
Location Collection enable Break ( Source File f , int line , int isolate Id ) throws Not Connected Exception { Location Collection col = new Location Collection ( ) ; boolean single Swf Breakpoint = m file Info . is Swf Filter On ( ) ; Swf Info swf = m file Info . get Swf Filter ( ) ; if ( single Swf Breakpoint ) { Location l = null ; try { l = find And Enable Break ( swf , f , line ) ; } catch ( In Progress Exception e ) { if ( Trace . error ) Trace . trace ( ( ( swf == null ) ? STRING : swf . get Url ( ) ) + STRING + f . get Name ( ) + STRING + line + STRING ) ; } col . add ( l ) ; } else { Swf Info [ ] swfs = m file Info . get Swfs ( isolate Id ) ; for ( Swf Info swf 1 : swfs ) { swf = swf 1 ; if ( swf != null ) { Location l = null ; try { l = find And Enable Break ( swf , f , line ) ; } catch ( In Progress Exception e ) { if ( Trace . error ) Trace . trace ( ( swf . get Url ( ) ) + STRING + f . get Name ( ) + STRING + line + STRING ) ; } if ( l != null ) col . add ( l ) ; } } } return col ; }
Location Collection enable Break ( Source File f , int line , int isolate Id ) throws Not Connected Exception { Location Collection col = new Location Collection ( ) ; boolean single Swf Breakpoint = m file Info . is Swf Filter On ( ) ; Swf Info swf = m file Info . get Swf Filter ( ) ; if ( single Swf Breakpoint ) { Location l = null ; try { l = find And Enable Break ( swf , f , line ) ; } catch ( In Progress Exception e ) { if ( Trace . error ) Trace . trace ( ( ( swf == null ) ? STRING : swf . get Url ( ) ) + STRING + f . get Name ( ) + STRING + line + STRING ) ; } col . add ( l ) ; } else { Swf Info [ ] swfs = m file Info . get Swfs ( isolate Id ) ; for ( Swf Info swf 1 : swfs ) { swf = swf 1 ; if ( swf != null ) { Location l = null ; try { l = find And Enable Break ( swf , f , line ) ; } catch ( In Progress Exception e ) { if ( Trace . error ) Trace . trace ( ( swf . get Url ( ) ) + STRING + f . get Name ( ) + STRING + line + STRING ) ; } if ( l != null ) col . add ( l ) ; } } } return col ; }
Location Collection enable Break ( Source File f , int line , int isolate Id ) throws Not Connected Exception { Location Collection col = new Location Collection ( ) ; boolean single Swf Breakpoint = m file Info . is Swf Filter On ( ) ; Swf Info swf = m file Info . get Swf Filter ( ) ; if ( single Swf Breakpoint ) { Location l = null ; try { l = find And Enable Break ( swf , f , line ) ; } catch ( In Progress Exception e ) { if ( Trace . error ) Trace . trace ( ( ( swf == null ) ? STRING : swf . get Url ( ) ) + STRING + f . get Name ( ) + STRING + line + STRING ) ; } col . add ( l ) ; } else { Swf Info [ ] swfs = m file Info . get Swfs ( isolate Id ) ; for ( Swf Info swf 1 : swfs ) { swf = swf 1 ; if ( swf != null ) { Location l = null ; try { l = find And Enable Break ( swf , f , line ) ; } catch ( In Progress Exception e ) { if ( Trace . error ) Trace . trace ( ( swf . get Url ( ) ) + STRING + f . get Name ( ) + STRING + line + STRING ) ; } if ( l != null ) col . add ( l ) ; } } } return col ; }
Location Collection enable Break ( Source File f , int line , int isolate Id ) throws Not Connected Exception { Location Collection col = new Location Collection ( ) ; boolean single Swf Breakpoint = m file Info . is Swf Filter On ( ) ; Swf Info swf = m file Info . get Swf Filter ( ) ; if ( single Swf Breakpoint ) { Location l = null ; try { l = find And Enable Break ( swf , f , line ) ; } catch ( In Progress Exception e ) { if ( Trace . error ) Trace . trace ( ( ( swf == null ) ? STRING : swf . get Url ( ) ) + STRING + f . get Name ( ) + STRING + line + STRING ) ; } col . add ( l ) ; } else { Swf Info [ ] swfs = m file Info . get Swfs ( isolate Id ) ; for ( Swf Info swf 1 : swfs ) { swf = swf 1 ; if ( swf != null ) { Location l = null ; try { l = find And Enable Break ( swf , f , line ) ; } catch ( In Progress Exception e ) { if ( Trace . error ) Trace . trace ( ( swf . get Url ( ) ) + STRING + f . get Name ( ) + STRING + line + STRING ) ; } if ( l != null ) col . add ( l ) ; } } } return col ; }
public Auth Properties Model Impl ( Http Servlet Request req , Map map ) { super ( req , map ) ; current Realm = ( String ) map . get ( AM Admin Constants . CURRENT REALM ) ; if ( current Realm == null ) { current Realm = STRING ; } }
private static void add 2 ( Collection < String > src , String line ) { src . add ( TAB 2 + line ) ; }
public byte [ ] to Byte Array ( ) { byte b [ ] = new byte [ NUM ] ; Byte Buffer bb = Byte Buffer . wrap ( b ) ; bb . put Int ( time ) ; bb . put Int ( machine ) ; bb . put Int ( inc ) ; return b ; }
public char read ( ) { if ( pos >= length ) { throw new String Index Out Of Bounds Exception ( ) ; } return source . char At ( pos ++ ) ; }
public char read ( ) { if ( pos >= length ) { throw new String Index Out Of Bounds Exception ( ) ; } return source . char At ( pos ++ ) ; }
public char read ( ) { if ( pos >= length ) { throw new String Index Out Of Bounds Exception ( ) ; } return source . char At ( pos ++ ) ; }
public char read ( ) { if ( pos >= length ) { throw new String Index Out Of Bounds Exception ( ) ; } return source . char At ( pos ++ ) ; }
public char read ( ) { if ( pos >= length ) { throw new String Index Out Of Bounds Exception ( ) ; } return source . char At ( pos ++ ) ; }
public static boolean is Caller Valid ( String class Name ) { if ( ! check Caller ) { return ( BOOL ) ; } String parent Class = get Parent Class ( class Name ) ; for ( int i = NUM ; i < VALID PACKAGES . length ; i ++ ) { if ( parent Class . starts With ( VALID PACKAGES [ i ] ) ) { return ( BOOL ) ; } } for ( int i = NUM ; i < VALID CLASSES . length ; i ++ ) { if ( parent Class . equals ( VALID CLASSES [ i ] ) ) { return ( BOOL ) ; } } return ( BOOL ) ; }
public static boolean is Caller Valid ( String class Name ) { if ( ! check Caller ) { return ( BOOL ) ; } String parent Class = get Parent Class ( class Name ) ; for ( int i = NUM ; i < VALID PACKAGES . length ; i ++ ) { if ( parent Class . starts With ( VALID PACKAGES [ i ] ) ) { return ( BOOL ) ; } } for ( int i = NUM ; i < VALID CLASSES . length ; i ++ ) { if ( parent Class . equals ( VALID CLASSES [ i ] ) ) { return ( BOOL ) ; } } return ( BOOL ) ; }
public static boolean is Caller Valid ( String class Name ) { if ( ! check Caller ) { return ( BOOL ) ; } String parent Class = get Parent Class ( class Name ) ; for ( int i = NUM ; i < VALID PACKAGES . length ; i ++ ) { if ( parent Class . starts With ( VALID PACKAGES [ i ] ) ) { return ( BOOL ) ; } } for ( int i = NUM ; i < VALID CLASSES . length ; i ++ ) { if ( parent Class . equals ( VALID CLASSES [ i ] ) ) { return ( BOOL ) ; } } return ( BOOL ) ; }
public static boolean is Caller Valid ( String class Name ) { if ( ! check Caller ) { return ( BOOL ) ; } String parent Class = get Parent Class ( class Name ) ; for ( int i = NUM ; i < VALID PACKAGES . length ; i ++ ) { if ( parent Class . starts With ( VALID PACKAGES [ i ] ) ) { return ( BOOL ) ; } } for ( int i = NUM ; i < VALID CLASSES . length ; i ++ ) { if ( parent Class . equals ( VALID CLASSES [ i ] ) ) { return ( BOOL ) ; } } return ( BOOL ) ; }
public void test Case 6 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = - NUM ; int b Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
private Object read New Long String ( boolean unshared ) throws IO Exception { long length = input . read Long ( ) ; Object result = input . decode UTF ( ( int ) length ) ; if ( enable Resolve ) { result = resolve Object ( result ) ; } register Object Read ( result , next Handle ( ) , unshared ) ; return result ; }
@ Override public Audio Input Stream synthesise One Section ( String festival Utt , Voice voice ) throws IO Exception { write Relation Files ( festival Utt ) ; File audio File = new File ( festival Dir . get Path ( ) + File . separator + STRING ) ; String festival Voice Cmd = STRING + voice . get Name ( ) + STRING ; Audio Input Stream sound = festival Synthesise ( audio File , festival Voice Cmd ) ; return sound ; }
public String write Data File ( ) throws Data File Exception { Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; write Data File ( bos ) ; String out String = bos . to String ( ) ; try { if ( bos != null ) bos . close ( ) ; } catch ( IO Exception e ) { Debug . log Warning ( e , module ) ; } return out String ; }
public String write Data File ( ) throws Data File Exception { Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; write Data File ( bos ) ; String out String = bos . to String ( ) ; try { if ( bos != null ) bos . close ( ) ; } catch ( IO Exception e ) { Debug . log Warning ( e , module ) ; } return out String ; }
@ Safe Varargs public final Token < Token Type > expect ( Token Type ... expected ) throws Simple Parser Exception { if ( has Type ( expected ) ) return this ; throw new Simple Parser Exception ( line , column , STRING + Arrays . to String ( expected ) + STRING + to String ( ) ) ; }
@ Safe Varargs public final Token < Token Type > expect ( Token Type ... expected ) throws Simple Parser Exception { if ( has Type ( expected ) ) return this ; throw new Simple Parser Exception ( line , column , STRING + Arrays . to String ( expected ) + STRING + to String ( ) ) ; }
public boolean authenticate ( final Odd Callback < Auth Token > callback ) { synchronized ( sync Lock ) { if ( is Expired ( ) ) { return BOOL ; } if ( ! authenticating ) { authenticating = BOOL ; timer = new Timer ( ) ; Timer Task task = get Poll Task ( callback ) ; timer . schedule ( task , new Date ( ) , interval ) ; Timer Task expired Task = get Expired Task ( callback ) ; timer . schedule ( expired Task , expiration Date ) ; } return BOOL ; } }
public boolean authenticate ( final Odd Callback < Auth Token > callback ) { synchronized ( sync Lock ) { if ( is Expired ( ) ) { return BOOL ; } if ( ! authenticating ) { authenticating = BOOL ; timer = new Timer ( ) ; Timer Task task = get Poll Task ( callback ) ; timer . schedule ( task , new Date ( ) , interval ) ; Timer Task expired Task = get Expired Task ( callback ) ; timer . schedule ( expired Task , expiration Date ) ; } return BOOL ; } }
public boolean authenticate ( final Odd Callback < Auth Token > callback ) { synchronized ( sync Lock ) { if ( is Expired ( ) ) { return BOOL ; } if ( ! authenticating ) { authenticating = BOOL ; timer = new Timer ( ) ; Timer Task task = get Poll Task ( callback ) ; timer . schedule ( task , new Date ( ) , interval ) ; Timer Task expired Task = get Expired Task ( callback ) ; timer . schedule ( expired Task , expiration Date ) ; } return BOOL ; } }
public boolean authenticate ( final Odd Callback < Auth Token > callback ) { synchronized ( sync Lock ) { if ( is Expired ( ) ) { return BOOL ; } if ( ! authenticating ) { authenticating = BOOL ; timer = new Timer ( ) ; Timer Task task = get Poll Task ( callback ) ; timer . schedule ( task , new Date ( ) , interval ) ; Timer Task expired Task = get Expired Task ( callback ) ; timer . schedule ( expired Task , expiration Date ) ; } return BOOL ; } }
public static int convert To Color Int ( String argb ) throws Number Format Exception { if ( argb . starts With ( STRING ) ) { argb = argb . replace ( STRING , STRING ) ; } int alpha = - NUM , red = - NUM , green = - NUM , blue = - NUM ; if ( argb . length ( ) == NUM ) { alpha = Integer . parse Int ( argb . substring ( NUM , NUM ) , NUM ) ; red = Integer . parse Int ( argb . substring ( NUM , NUM ) , NUM ) ; green = Integer . parse Int ( argb . substring ( NUM , NUM ) , NUM ) ; blue = Integer . parse Int ( argb . substring ( NUM , NUM ) , NUM ) ; } else if ( argb . length ( ) == NUM ) { alpha = NUM ; red = Integer . parse Int ( argb . substring ( NUM , NUM ) , NUM ) ; green = Integer . parse Int ( argb . substring ( NUM , NUM ) , NUM ) ; blue = Integer . parse Int ( argb . substring ( NUM , NUM ) , NUM ) ; } return Color . argb ( alpha , red , green , blue ) ; }
public static String timestamp ( ) { Calendar calendar = Calendar . get Instance ( ) ; return STRING + calendar . get ( Calendar . YEAR ) + calendar . get ( Calendar . MONTH ) + calendar . get ( Calendar . DAY OF MONTH ) + calendar . get ( Calendar . HOUR ) + calendar . get ( Calendar . MINUTE ) + calendar . get ( Calendar . SECOND ) ; }
public static String timestamp ( ) { Calendar calendar = Calendar . get Instance ( ) ; return STRING + calendar . get ( Calendar . YEAR ) + calendar . get ( Calendar . MONTH ) + calendar . get ( Calendar . DAY OF MONTH ) + calendar . get ( Calendar . HOUR ) + calendar . get ( Calendar . MINUTE ) + calendar . get ( Calendar . SECOND ) ; }
public static String timestamp ( ) { Calendar calendar = Calendar . get Instance ( ) ; return STRING + calendar . get ( Calendar . YEAR ) + calendar . get ( Calendar . MONTH ) + calendar . get ( Calendar . DAY OF MONTH ) + calendar . get ( Calendar . HOUR ) + calendar . get ( Calendar . MINUTE ) + calendar . get ( Calendar . SECOND ) ; }
public double local Score ( int i ) { double sum = NUM ; for ( B Deu Score score : scores ) { sum += score . local Score ( i ) ; } return sum / scores . size ( ) ; }
public double local Score ( int i ) { double sum = NUM ; for ( B Deu Score score : scores ) { sum += score . local Score ( i ) ; } return sum / scores . size ( ) ; }
public double local Score ( int i ) { double sum = NUM ; for ( B Deu Score score : scores ) { sum += score . local Score ( i ) ; } return sum / scores . size ( ) ; }
public double local Score ( int i ) { double sum = NUM ; for ( B Deu Score score : scores ) { sum += score . local Score ( i ) ; } return sum / scores . size ( ) ; }
protected boolean is Relevant ( String term ) { return term . length ( ) >= NUM && matches ( character Pattern , term ) ; }
protected boolean is Relevant ( String term ) { return term . length ( ) >= NUM && matches ( character Pattern , term ) ; }
protected boolean is Relevant ( String term ) { return term . length ( ) >= NUM && matches ( character Pattern , term ) ; }
public void put String ( String s ) { ensure Capacity ( ( s . length ( ) * NUM ) + NUM ) ; System . arraycopy ( s . get Bytes ( ) , NUM , this . byte Buffer , this . position , s . length ( ) ) ; this . position += s . length ( ) ; this . byte Buffer [ this . position ++ ] = NUM ; }
protected void select Previous Possible Value ( ) { int si = list Box . get Selected Index ( ) ; if ( si > NUM ) { list Box . set Selected Index ( si - NUM ) ; list Box . ensure Index Is Visible ( si - NUM ) ; } }
protected void select Previous Possible Value ( ) { int si = list Box . get Selected Index ( ) ; if ( si > NUM ) { list Box . set Selected Index ( si - NUM ) ; list Box . ensure Index Is Visible ( si - NUM ) ; } }
protected void select Previous Possible Value ( ) { int si = list Box . get Selected Index ( ) ; if ( si > NUM ) { list Box . set Selected Index ( si - NUM ) ; list Box . ensure Index Is Visible ( si - NUM ) ; } }
protected void select Previous Possible Value ( ) { int si = list Box . get Selected Index ( ) ; if ( si > NUM ) { list Box . set Selected Index ( si - NUM ) ; list Box . ensure Index Is Visible ( si - NUM ) ; } }
private void make Multi Traversal ( ) { Optional < String > role A = roletypes . get ( NUM ) ; String player A = roleplayers . get ( NUM ) ; Optional < String > role B = roletypes . get ( NUM ) ; String player B = roleplayers . get ( NUM ) ; multi Traversal = Multi Traversal . create ( new Fragment Impl ( null , Fragment Priority . EDGE RELATION , player A , player B ) , new Fragment Impl ( null , Fragment Priority . EDGE RELATION , player B , player A ) ) ; }
private void make Multi Traversal ( ) { Optional < String > role A = roletypes . get ( NUM ) ; String player A = roleplayers . get ( NUM ) ; Optional < String > role B = roletypes . get ( NUM ) ; String player B = roleplayers . get ( NUM ) ; multi Traversal = Multi Traversal . create ( new Fragment Impl ( null , Fragment Priority . EDGE RELATION , player A , player B ) , new Fragment Impl ( null , Fragment Priority . EDGE RELATION , player B , player A ) ) ; }
private void make Multi Traversal ( ) { Optional < String > role A = roletypes . get ( NUM ) ; String player A = roleplayers . get ( NUM ) ; Optional < String > role B = roletypes . get ( NUM ) ; String player B = roleplayers . get ( NUM ) ; multi Traversal = Multi Traversal . create ( new Fragment Impl ( null , Fragment Priority . EDGE RELATION , player A , player B ) , new Fragment Impl ( null , Fragment Priority . EDGE RELATION , player B , player A ) ) ; }
private static void add Jdbc Fields ( Document doc , Node parent , String name , Collection < Pojo Field > fields ) { if ( ! fields . is Empty ( ) ) { Element prop = add Property ( doc , parent , name , null ) ; Element list = add Element ( doc , prop , STRING ) ; for ( Pojo Field field : fields ) { Element item = add Bean ( doc , list , Jdbc Type Field . class ) ; Element db Type = add Property ( doc , item , STRING , null ) ; add Element ( doc , db Type , STRING , STRING , STRING + field . db Type Name ( ) ) ; add Property ( doc , item , STRING , field . db Name ( ) ) ; add Property ( doc , item , STRING , field . java Type Name ( ) ) ; add Property ( doc , item , STRING , field . java Name ( ) ) ; } } }
public String generate Unique Name ( String name , boolean add Name ) { while ( m Used Names . contains Key ( name . to Lower Case ( ) ) ) { Matcher matcher = m Reg Ex . matcher ( name ) ; if ( matcher . matches ( ) ) { name = matcher . group ( NUM ) + ( Integer . parse Int ( matcher . group ( NUM ) ) + NUM ) ; } else { name = name + STRING ; } } if ( add Name ) { m Used Names . put ( name . to Lower Case ( ) , STRING ) ; notify Changed ( ) ; } return name . to Lower Case ( ) ; }
protected void compute Parameters ( ) { if ( m Sum Of Weights > NUM ) { m Mean = m Sum Of Values / m Sum Of Weights ; double std Dev = Math . sqrt ( Math . abs ( m Sum Of Values Sq - m Mean * m Sum Of Values ) / m Sum Of Weights ) ; if ( std Dev > NUM ) { m Standard Dev = Math . max ( m Precision / ( NUM * NUM ) , std Dev ) ; } } }
final public Mutable String to Upper Case ( ) { int n = length ( ) ; final char [ ] a = array ; while ( n -- != NUM ) a [ n ] = Character . to Upper Case ( a [ n ] ) ; changed ( ) ; return this ; }
public void add Action Listener ( Action Listener new Listener ) { m listeners . add ( new Listener ) ; }
private void marker With Colored Icon ( Google Map google Map , Lat Lng lat Lng , String public Id , String hex Color ) { Marker Options options = new Marker Options ( ) ; options . position ( lat Lng ) ; int color = Color . parse Color ( hex Color ) ; float [ ] hsv = new float [ NUM ] ; Color . color To HSV ( color , hsv ) ; float hue = hsv [ NUM ] ; options . icon ( Bitmap Descriptor Factory . default Marker ( hue ) ) ; Marker marker = google Map . add Marker ( options ) ; public Marker Ids . put ( marker . get Id ( ) , public Id ) ; }
private void marker With Colored Icon ( Google Map google Map , Lat Lng lat Lng , String public Id , String hex Color ) { Marker Options options = new Marker Options ( ) ; options . position ( lat Lng ) ; int color = Color . parse Color ( hex Color ) ; float [ ] hsv = new float [ NUM ] ; Color . color To HSV ( color , hsv ) ; float hue = hsv [ NUM ] ; options . icon ( Bitmap Descriptor Factory . default Marker ( hue ) ) ; Marker marker = google Map . add Marker ( options ) ; public Marker Ids . put ( marker . get Id ( ) , public Id ) ; }
public Default Heat Map Dataset ( int x Samples , int y Samples , double min X , double max X , double min Y , double max Y ) { if ( x Samples < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( y Samples < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( min X ) || Double . is Na N ( min X ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( max X ) || Double . is Na N ( max X ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( min Y ) || Double . is Na N ( min Y ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( max Y ) || Double . is Na N ( max Y ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . x Samples = x Samples ; this . y Samples = y Samples ; this . min X = min X ; this . max X = max X ; this . min Y = min Y ; this . max Y = max Y ; this . z Values = new double [ x Samples ] [ ] ; for ( int x = NUM ; x < x Samples ; x ++ ) { this . z Values [ x ] = new double [ y Samples ] ; } }
public Default Heat Map Dataset ( int x Samples , int y Samples , double min X , double max X , double min Y , double max Y ) { if ( x Samples < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( y Samples < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( min X ) || Double . is Na N ( min X ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( max X ) || Double . is Na N ( max X ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( min Y ) || Double . is Na N ( min Y ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( max Y ) || Double . is Na N ( max Y ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . x Samples = x Samples ; this . y Samples = y Samples ; this . min X = min X ; this . max X = max X ; this . min Y = min Y ; this . max Y = max Y ; this . z Values = new double [ x Samples ] [ ] ; for ( int x = NUM ; x < x Samples ; x ++ ) { this . z Values [ x ] = new double [ y Samples ] ; } }
public Default Heat Map Dataset ( int x Samples , int y Samples , double min X , double max X , double min Y , double max Y ) { if ( x Samples < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( y Samples < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( min X ) || Double . is Na N ( min X ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( max X ) || Double . is Na N ( max X ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( min Y ) || Double . is Na N ( min Y ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( max Y ) || Double . is Na N ( max Y ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . x Samples = x Samples ; this . y Samples = y Samples ; this . min X = min X ; this . max X = max X ; this . min Y = min Y ; this . max Y = max Y ; this . z Values = new double [ x Samples ] [ ] ; for ( int x = NUM ; x < x Samples ; x ++ ) { this . z Values [ x ] = new double [ y Samples ] ; } }
public Default Heat Map Dataset ( int x Samples , int y Samples , double min X , double max X , double min Y , double max Y ) { if ( x Samples < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( y Samples < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( min X ) || Double . is Na N ( min X ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( max X ) || Double . is Na N ( max X ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( min Y ) || Double . is Na N ( min Y ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( max Y ) || Double . is Na N ( max Y ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . x Samples = x Samples ; this . y Samples = y Samples ; this . min X = min X ; this . max X = max X ; this . min Y = min Y ; this . max Y = max Y ; this . z Values = new double [ x Samples ] [ ] ; for ( int x = NUM ; x < x Samples ; x ++ ) { this . z Values [ x ] = new double [ y Samples ] ; } }
private synchronized void add Lock ( File Lock lock ) throws Overlapping File Lock Exception { long lock End = lock . position ( ) + lock . size ( ) ; for ( File Lock existing Lock : locks ) { if ( existing Lock . position ( ) > lock End ) { break ; } if ( existing Lock . overlaps ( lock . position ( ) , lock . size ( ) ) ) { throw new Overlapping File Lock Exception ( ) ; } } locks . add ( lock ) ; }
private synchronized void add Lock ( File Lock lock ) throws Overlapping File Lock Exception { long lock End = lock . position ( ) + lock . size ( ) ; for ( File Lock existing Lock : locks ) { if ( existing Lock . position ( ) > lock End ) { break ; } if ( existing Lock . overlaps ( lock . position ( ) , lock . size ( ) ) ) { throw new Overlapping File Lock Exception ( ) ; } } locks . add ( lock ) ; }
private synchronized void add Lock ( File Lock lock ) throws Overlapping File Lock Exception { long lock End = lock . position ( ) + lock . size ( ) ; for ( File Lock existing Lock : locks ) { if ( existing Lock . position ( ) > lock End ) { break ; } if ( existing Lock . overlaps ( lock . position ( ) , lock . size ( ) ) ) { throw new Overlapping File Lock Exception ( ) ; } } locks . add ( lock ) ; }
private synchronized void add Lock ( File Lock lock ) throws Overlapping File Lock Exception { long lock End = lock . position ( ) + lock . size ( ) ; for ( File Lock existing Lock : locks ) { if ( existing Lock . position ( ) > lock End ) { break ; } if ( existing Lock . overlaps ( lock . position ( ) , lock . size ( ) ) ) { throw new Overlapping File Lock Exception ( ) ; } } locks . add ( lock ) ; }
private synchronized void add Lock ( File Lock lock ) throws Overlapping File Lock Exception { long lock End = lock . position ( ) + lock . size ( ) ; for ( File Lock existing Lock : locks ) { if ( existing Lock . position ( ) > lock End ) { break ; } if ( existing Lock . overlaps ( lock . position ( ) , lock . size ( ) ) ) { throw new Overlapping File Lock Exception ( ) ; } } locks . add ( lock ) ; }
void release Object ( long object , boolean dissociate ) { if ( dissociate ) { try { port Dissociate ( port , PORT SOURCE FILE , object ) ; } catch ( Unix Exception x ) { } } long name = unsafe . get Address ( object + OFFSET FO NAME ) ; unsafe . free Memory ( name ) ; unsafe . free Memory ( object ) ; }
public static String sub String ( String string , int begin Index , int length ) { if ( string == null ) { return null ; } final int end Index = begin Index + length ; if ( begin Index >= string . length ( ) ) { return EMPTY ; } if ( end Index > string . length ( ) ) { return string . substring ( begin Index , string . length ( ) ) ; } return string . substring ( begin Index , end Index ) ; }
public static int copy ( Input Stream in , Output Stream out ) throws IO Exception { Assert . not Null ( in , STRING ) ; Assert . not Null ( out , STRING ) ; int byte Count = NUM ; byte [ ] buffer = new byte [ BUFFER SIZE ] ; int bytes Read = - NUM ; while ( ( bytes Read = in . read ( buffer ) ) != - NUM ) { out . write ( buffer , NUM , bytes Read ) ; byte Count += bytes Read ; } out . flush ( ) ; return byte Count ; }
public static int copy ( Input Stream in , Output Stream out ) throws IO Exception { Assert . not Null ( in , STRING ) ; Assert . not Null ( out , STRING ) ; int byte Count = NUM ; byte [ ] buffer = new byte [ BUFFER SIZE ] ; int bytes Read = - NUM ; while ( ( bytes Read = in . read ( buffer ) ) != - NUM ) { out . write ( buffer , NUM , bytes Read ) ; byte Count += bytes Read ; } out . flush ( ) ; return byte Count ; }
public static int copy ( Input Stream in , Output Stream out ) throws IO Exception { Assert . not Null ( in , STRING ) ; Assert . not Null ( out , STRING ) ; int byte Count = NUM ; byte [ ] buffer = new byte [ BUFFER SIZE ] ; int bytes Read = - NUM ; while ( ( bytes Read = in . read ( buffer ) ) != - NUM ) { out . write ( buffer , NUM , bytes Read ) ; byte Count += bytes Read ; } out . flush ( ) ; return byte Count ; }
public Host create Host ( String name , File app Base ) { return new Host ( invoke ( embedded Create Host , name , app Base . get Absolute Path ( ) ) ) ; }
protected String check Heap ( ) { if ( comparator == null ) { for ( int i = NUM ; i < size ; i ++ ) { final int parent = ( i - NUM ) > > > NUM ; @ Suppress Warnings ( STRING ) Comparable < Object > po = ( Comparable < Object > ) queue [ parent ] ; if ( po . compare To ( queue [ i ] ) > NUM ) { return STRING + parent + STRING + queue [ parent ] + STRING + i + STRING + queue [ i ] ; } } } else { for ( int i = NUM ; i < size ; i ++ ) { final int parent = ( i - NUM ) > > > NUM ; if ( comparator . compare ( queue [ parent ] , queue [ i ] ) > NUM ) { return STRING + parent + STRING + queue [ parent ] + STRING + i + STRING + queue [ i ] ; } } } return null ; }
@ Override public void run ( ) { try { handle Alarm ( ) ; } catch ( Throwable e ) { log . log ( Level . WARNING , e . to String ( ) , e ) ; } finally { is Running = BOOL ; running Alarm Count . decrement And Get ( ) ; } }
public Builder add In Collection Item Clause ( String collection Field Name , Collection < String > item Names ) { String collection Item Field Name = Query Specification . build Collection Item Name ( collection Field Name ) ; return add In Clause ( collection Item Field Name , item Names ) ; }
public Builder add In Collection Item Clause ( String collection Field Name , Collection < String > item Names ) { String collection Item Field Name = Query Specification . build Collection Item Name ( collection Field Name ) ; return add In Clause ( collection Item Field Name , item Names ) ; }
public Set < Long > key Set ( ) { Hash Set < Long > set = new Hash Set < Long > ( ) ; for ( Segment < V > s : segments ) { set . add All ( s . key Set ( ) ) ; } return set ; }
public static void stop ( String [ ] args ) { LOG . info ( STRING ) ; System . exit ( NUM ) ; }
public static void to String ( Iterator < ? > iter , String separator , String Builder sb ) { while ( iter . has Next ( ) ) { sb . append ( iter . next ( ) ) ; if ( iter . has Next ( ) ) { sb . append ( separator ) ; } } }
public boolean is Buffer Result Set To Local Temp ( ) { return buffer Result Set To Local Temp ; }
public boolean is Buffer Result Set To Local Temp ( ) { return buffer Result Set To Local Temp ; }
protected void create User Dict Settings ( Preference Group user Dict Group ) { final Activity activity = get Activity ( ) ; user Dict Group . remove All ( ) ; final Tree Set < String > locale List = User Dictionary List . get User Dictionary Locales Set ( activity ) ; if ( locale List . is Empty ( ) ) { user Dict Group . add Preference ( create User Dictionary Preference ( null , activity ) ) ; } else { for ( String locale : locale List ) { user Dict Group . add Preference ( create User Dictionary Preference ( locale , activity ) ) ; } } }
protected void create User Dict Settings ( Preference Group user Dict Group ) { final Activity activity = get Activity ( ) ; user Dict Group . remove All ( ) ; final Tree Set < String > locale List = User Dictionary List . get User Dictionary Locales Set ( activity ) ; if ( locale List . is Empty ( ) ) { user Dict Group . add Preference ( create User Dictionary Preference ( null , activity ) ) ; } else { for ( String locale : locale List ) { user Dict Group . add Preference ( create User Dictionary Preference ( locale , activity ) ) ; } } }
protected void create User Dict Settings ( Preference Group user Dict Group ) { final Activity activity = get Activity ( ) ; user Dict Group . remove All ( ) ; final Tree Set < String > locale List = User Dictionary List . get User Dictionary Locales Set ( activity ) ; if ( locale List . is Empty ( ) ) { user Dict Group . add Preference ( create User Dictionary Preference ( null , activity ) ) ; } else { for ( String locale : locale List ) { user Dict Group . add Preference ( create User Dictionary Preference ( locale , activity ) ) ; } } }
private static boolean add To Evaluator ( Array Deque < Filter Value Set Param > remaining Parameters , Filter Handle filter Callback , Event Evaluator event Evaluator , Array Deque < Event Type Index Builder Index Lookupable Pair > tree Path Info , Filter Service Granular Lock Factory lock Factory ) { if ( event Evaluator instanceof Filter Handle Set Node ) { Filter Handle Set Node node = ( Filter Handle Set Node ) event Evaluator ; add To Node ( remaining Parameters , filter Callback , node , tree Path Info , lock Factory ) ; return BOOL ; } Filter Param Index Base next Index = ( Filter Param Index Base ) event Evaluator ; Filter Value Set Param parameter = Index Helper . find Parameter ( remaining Parameters , next Index ) ; if ( parameter != null ) { remaining Parameters . remove ( parameter ) ; tree Path Info . add ( new Event Type Index Builder Index Lookupable Pair ( next Index , parameter . get Filter For Value ( ) ) ) ; add To Index ( remaining Parameters , filter Callback , next Index , parameter . get Filter For Value ( ) , tree Path Info , lock Factory ) ; return BOOL ; } return BOOL ; }
public Cookie ( final String domain , final String name , final String value , final String path , final int max Age , final boolean secure ) { this ( domain , name , value , path , null , secure ) ; if ( max Age < - NUM ) { throw new Illegal Argument Exception ( STRING + Integer . to String ( max Age ) ) ; } if ( max Age >= NUM ) { set Expiry Date ( new Date ( System . current Time Millis ( ) + max Age * NUM ) ) ; } }
public List < Json Object > execute Parametrized Statement ( String statement , List < String > parameter Names , List < Object > parameter Values ) { Json Object named Params = Json Object . create ( ) ; for ( int param = NUM ; param < parameter Names . size ( ) ; param ++ ) { named Params . put ( parameter Names . get ( param ) , parameter Values . get ( param ) ) ; } Parameterized N 1 ql Query query = N1 ql Query . parameterized ( statement , named Params ) ; return execute Query ( query ) ; }
public static String grep Minus V ( String val , String pattern ) { return grep Inner ( val , pattern , BOOL ) ; }
private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; if ( policy == null ) { throw new Invalid Object Exception ( STRING ) ; } if ( classpath == null ) { throw new Invalid Object Exception ( STRING ) ; } if ( log == null ) { throw new Invalid Object Exception ( STRING ) ; } if ( server Options == null ) { throw new Invalid Object Exception ( STRING ) ; } if ( server Properties == null ) { throw new Invalid Object Exception ( STRING ) ; } if ( host == null ) { throw new Invalid Object Exception ( STRING ) ; } if ( port <= NUM ) { throw new Invalid Object Exception ( STRING + port ) ; } }
long purge ( final int sample Size ) { final int limit = Math . min ( sample Size , get Num Active ( ) ) ; int num Samples = NUM ; int i = NUM ; final long [ ] samples = new long [ limit ] ; while ( num Samples < limit ) { if ( is Active ( i ) ) { samples [ num Samples ] = values [ i ] ; num Samples ++ ; } i ++ ; } final long val = Quick Select . select ( samples , NUM , num Samples - NUM , limit / NUM ) ; adjust All Values By ( - NUM * val ) ; keep Only Positive Counts ( ) ; return val ; }
long purge ( final int sample Size ) { final int limit = Math . min ( sample Size , get Num Active ( ) ) ; int num Samples = NUM ; int i = NUM ; final long [ ] samples = new long [ limit ] ; while ( num Samples < limit ) { if ( is Active ( i ) ) { samples [ num Samples ] = values [ i ] ; num Samples ++ ; } i ++ ; } final long val = Quick Select . select ( samples , NUM , num Samples - NUM , limit / NUM ) ; adjust All Values By ( - NUM * val ) ; keep Only Positive Counts ( ) ; return val ; }
long purge ( final int sample Size ) { final int limit = Math . min ( sample Size , get Num Active ( ) ) ; int num Samples = NUM ; int i = NUM ; final long [ ] samples = new long [ limit ] ; while ( num Samples < limit ) { if ( is Active ( i ) ) { samples [ num Samples ] = values [ i ] ; num Samples ++ ; } i ++ ; } final long val = Quick Select . select ( samples , NUM , num Samples - NUM , limit / NUM ) ; adjust All Values By ( - NUM * val ) ; keep Only Positive Counts ( ) ; return val ; }
long purge ( final int sample Size ) { final int limit = Math . min ( sample Size , get Num Active ( ) ) ; int num Samples = NUM ; int i = NUM ; final long [ ] samples = new long [ limit ] ; while ( num Samples < limit ) { if ( is Active ( i ) ) { samples [ num Samples ] = values [ i ] ; num Samples ++ ; } i ++ ; } final long val = Quick Select . select ( samples , NUM , num Samples - NUM , limit / NUM ) ; adjust All Values By ( - NUM * val ) ; keep Only Positive Counts ( ) ; return val ; }
long purge ( final int sample Size ) { final int limit = Math . min ( sample Size , get Num Active ( ) ) ; int num Samples = NUM ; int i = NUM ; final long [ ] samples = new long [ limit ] ; while ( num Samples < limit ) { if ( is Active ( i ) ) { samples [ num Samples ] = values [ i ] ; num Samples ++ ; } i ++ ; } final long val = Quick Select . select ( samples , NUM , num Samples - NUM , limit / NUM ) ; adjust All Values By ( - NUM * val ) ; keep Only Positive Counts ( ) ; return val ; }
long purge ( final int sample Size ) { final int limit = Math . min ( sample Size , get Num Active ( ) ) ; int num Samples = NUM ; int i = NUM ; final long [ ] samples = new long [ limit ] ; while ( num Samples < limit ) { if ( is Active ( i ) ) { samples [ num Samples ] = values [ i ] ; num Samples ++ ; } i ++ ; } final long val = Quick Select . select ( samples , NUM , num Samples - NUM , limit / NUM ) ; adjust All Values By ( - NUM * val ) ; keep Only Positive Counts ( ) ; return val ; }
long purge ( final int sample Size ) { final int limit = Math . min ( sample Size , get Num Active ( ) ) ; int num Samples = NUM ; int i = NUM ; final long [ ] samples = new long [ limit ] ; while ( num Samples < limit ) { if ( is Active ( i ) ) { samples [ num Samples ] = values [ i ] ; num Samples ++ ; } i ++ ; } final long val = Quick Select . select ( samples , NUM , num Samples - NUM , limit / NUM ) ; adjust All Values By ( - NUM * val ) ; keep Only Positive Counts ( ) ; return val ; }
long purge ( final int sample Size ) { final int limit = Math . min ( sample Size , get Num Active ( ) ) ; int num Samples = NUM ; int i = NUM ; final long [ ] samples = new long [ limit ] ; while ( num Samples < limit ) { if ( is Active ( i ) ) { samples [ num Samples ] = values [ i ] ; num Samples ++ ; } i ++ ; } final long val = Quick Select . select ( samples , NUM , num Samples - NUM , limit / NUM ) ; adjust All Values By ( - NUM * val ) ; keep Only Positive Counts ( ) ; return val ; }
abstract public Path Impl scheme Walk ( String user Path , Map < String , Object > new Attributes , String new Path , int offset ) ;
OF Channel Handler ( @ Nonnull IOF Switch Manager switch Manager , @ Nonnull I New OF Connection Listener new Connection Listener , @ Nonnull Channel Pipeline pipeline , @ Nonnull I Debug Counter Service debug Counters , @ Nonnull Timer timer ) { Preconditions . check Not Null ( switch Manager , STRING ) ; Preconditions . check Not Null ( new Connection Listener , STRING ) ; Preconditions . check Not Null ( pipeline , STRING ) ; Preconditions . check Not Null ( timer , STRING ) ; Preconditions . check Not Null ( debug Counters , STRING ) ; this . pipeline = pipeline ; this . debug Counters = debug Counters ; this . new Connection Listener = new Connection Listener ; this . counters = switch Manager . get Counters ( ) ; this . state = new Init State ( ) ; this . timer = timer ; log . debug ( STRING , String . format ( STRING , System . identity Hash Code ( this ) ) ) ; }
public long object Field Offset ( Field field ) { if ( Modifier . is Static ( field . get Modifiers ( ) ) ) { throw new Illegal Argument Exception ( STRING ) ; } return object Field Offset 0 ( field ) ; }
public long object Field Offset ( Field field ) { if ( Modifier . is Static ( field . get Modifiers ( ) ) ) { throw new Illegal Argument Exception ( STRING ) ; } return object Field Offset 0 ( field ) ; }
public long object Field Offset ( Field field ) { if ( Modifier . is Static ( field . get Modifiers ( ) ) ) { throw new Illegal Argument Exception ( STRING ) ; } return object Field Offset 0 ( field ) ; }
public void notify app updated ( String package name ) { Installed App app = Installed App . find app ( package name ) ; if ( app == null ) { return ; } final int pos = installed apps . index Of ( app ) ; if ( pos != - NUM ) { installed apps . remove ( pos ) ; installed apps . add ( pos , app ) ; notify Item Changed ( pos ) ; } if ( app . is update available ( ) && ! app . has notified ( ) ) { app . set has notified ( BOOL ) ; app . save ( ) ; } }
public void notify app updated ( String package name ) { Installed App app = Installed App . find app ( package name ) ; if ( app == null ) { return ; } final int pos = installed apps . index Of ( app ) ; if ( pos != - NUM ) { installed apps . remove ( pos ) ; installed apps . add ( pos , app ) ; notify Item Changed ( pos ) ; } if ( app . is update available ( ) && ! app . has notified ( ) ) { app . set has notified ( BOOL ) ; app . save ( ) ; } }
protected void engine Update ( byte b ) throws Signature Exception { message Digest . update ( b ) ; needs Reset = BOOL ; }
public void add Strategic Target ( String target ) { if ( String Util . is Null Or Empty ( target ) ) { return ; } strategic Building Targets . add ( target ) ; }
public void add Strategic Target ( String target ) { if ( String Util . is Null Or Empty ( target ) ) { return ; } strategic Building Targets . add ( target ) ; }
public void add Strategic Target ( String target ) { if ( String Util . is Null Or Empty ( target ) ) { return ; } strategic Building Targets . add ( target ) ; }
public void end Drawing ( GL 10 gl ) { gl . gl Disable ( GL 10 . GL ALPHA TEST ) ; gl . gl Matrix Mode ( GL 10 . GL PROJECTION ) ; gl . gl Pop Matrix ( ) ; gl . gl Matrix Mode ( GL 10 . GL MODELVIEW ) ; gl . gl Pop Matrix ( ) ; gl . gl Disable ( GL 10 . GL TEXTURE 2D ) ; gl . gl Color 4 x ( Fixed Point . ONE , Fixed Point . ONE , Fixed Point . ONE , Fixed Point . ONE ) ; }
private void Legends ( List < String > legends list , List < Integer > color code list ) { text Paint . set Color ( Color . BLACK ) ; text Paint . set Text Size ( NUM ) ; int left = ( int ) ( graphwidth * NUM ) ; for ( int i = NUM ; i < legends list . size ( ) ; i ++ ) { String label = legends list . get ( i ) ; float text width = text Paint . measure Text ( label , NUM , label . length ( ) ) ; int color = color code list . get ( i ) ; if ( ! ( ( graphwidth - legend Left ) > ( text width + NUM ) ) ) { legend Top -= NUM ; legend Left = left ; } add Legends ( canvas , color , legend Top , legend Left , legend Right , legend Bottom , label ) ; legend Left += ( ( int ) text width + NUM ) ; } }
@ Override public void write External ( Object Output out ) throws IO Exception { String tid = get Thread Mapping ( ) ; out . write Object ( tid ) ; out . write Object ( this . user Transaction Server Lookup Name ) ; out . write Object ( this . initial Context Factory ) ; out . write Object ( this . provider Url ) ; out . write Int ( this . timeout ) ; }
@ Override public void write External ( Object Output out ) throws IO Exception { String tid = get Thread Mapping ( ) ; out . write Object ( tid ) ; out . write Object ( this . user Transaction Server Lookup Name ) ; out . write Object ( this . initial Context Factory ) ; out . write Object ( this . provider Url ) ; out . write Int ( this . timeout ) ; }
public boolean is Valid Number ( Phone Number number ) { String region Code = get Region Code For Number ( number ) ; return is Valid Number For Region ( number , region Code ) ; }
public boolean is Valid Number ( Phone Number number ) { String region Code = get Region Code For Number ( number ) ; return is Valid Number For Region ( number , region Code ) ; }
private Ascii Img Cache ( final Dimension character Image Size , final Map < Character , Grayscale Matrix > image Cache , final char [ ] characters ) { this . character Image Size = character Image Size ; this . image Cache = image Cache ; }
protected void collect Super Type Names ( Reference Binding binding , char [ ] [ ] path ) { Reference Binding superclass = binding . superclass ( ) ; if ( path != null && superclass != null ) { boolean same Package = add If Same Package ( superclass . compound Name , path ) ; if ( ! same Package ) path = null ; } if ( superclass != null ) { add To Result ( superclass . compound Name ) ; collect Super Type Names ( superclass , path ) ; } Reference Binding [ ] interfaces = binding . super Interfaces ( ) ; if ( interfaces != null ) { for ( int i = NUM ; i < interfaces . length ; i ++ ) { Reference Binding interface Binding = interfaces [ i ] ; add To Result ( interface Binding . compound Name ) ; collect Super Type Names ( interface Binding , path ) ; } } }
public Note Comment ( Note note , String text , String nickname , int uid , String action , Date timestamp ) { this . note = note ; this . text = text . replace All ( STRING , STRING ) ; this . nickname = nickname . replace All ( STRING , STRING ) ; this . uid = uid ; this . action = action ; this . timestamp = timestamp ; }
@ Override public boolean lock ( ) { try { if ( ! File Factory . is File Exist ( location , File Factory . get File Type ( tmp Path ) ) ) { File Factory . mkdirs ( location , File Factory . get File Type ( tmp Path ) ) ; } String lock File Path = location + Carbon Common Constants . FILE SEPARATOR + lock File ; if ( ! File Factory . is File Exist ( lock File Path , File Factory . get File Type ( location ) ) ) { File Factory . create New Lock File ( lock File Path , File Factory . get File Type ( location ) ) ; } file Output Stream = new File Output Stream ( lock File Path ) ; channel = file Output Stream . get Channel ( ) ; try { file Lock = channel . try Lock ( ) ; } catch ( Overlapping File Lock Exception e ) { return BOOL ; } if ( null != file Lock ) { return BOOL ; } else { return BOOL ; } } catch ( IO Exception e ) { return BOOL ; } }
static int resize Stamp ( int n ) { return Integer . number Of Leading Zeros ( n ) | ( NUM << ( RESIZE STAMP BITS - NUM ) ) ; }
public static void write Short ( Data Output out , short v ) throws IO Exception { out . write Byte ( ( NUM & v ) ) ; out . write Byte ( ( NUM & ( v > > > NUM ) ) ) ; }
@ Override protected void tear Down ( ) throws Exception { try { take Screen Shot ( ) ; } catch ( Throwable throwable ) { throwable . print Stack Trace ( ) ; } super . tear Down ( ) ; }
@ Override protected void tear Down ( ) throws Exception { try { take Screen Shot ( ) ; } catch ( Throwable throwable ) { throwable . print Stack Trace ( ) ; } super . tear Down ( ) ; }
public DTED Locator ( ) { super ( ) ; if ( logger . is Loggable ( Level . FINE ) ) { DEBUG = BOOL ; } set Callback ( this ) ; }
public DTED Locator ( ) { super ( ) ; if ( logger . is Loggable ( Level . FINE ) ) { DEBUG = BOOL ; } set Callback ( this ) ; }
public DTED Locator ( ) { super ( ) ; if ( logger . is Loggable ( Level . FINE ) ) { DEBUG = BOOL ; } set Callback ( this ) ; }
@ Override public void characters ( char [ ] chars , int start , int length ) throws SAX Exception { element Text . append ( chars , start , length ) ; }
public static long persian To Julian ( long year , int month , int day ) { return NUM * ( ( ceil ( year - NUM , NUM ) + NUM ) - NUM ) + ( ( long ) Math . floor ( ( NUM * ( ceil ( year - NUM , NUM ) + NUM ) - NUM ) / NUM ) ) + ( Persian Calendar Constants . PERSIAN EPOCH - NUM ) + NUM * ( ( long ) Math . floor ( ( year - NUM ) / NUM ) ) + ( month < NUM ? NUM * month : NUM * month + NUM ) + day ; }
public static long persian To Julian ( long year , int month , int day ) { return NUM * ( ( ceil ( year - NUM , NUM ) + NUM ) - NUM ) + ( ( long ) Math . floor ( ( NUM * ( ceil ( year - NUM , NUM ) + NUM ) - NUM ) / NUM ) ) + ( Persian Calendar Constants . PERSIAN EPOCH - NUM ) + NUM * ( ( long ) Math . floor ( ( year - NUM ) / NUM ) ) + ( month < NUM ? NUM * month : NUM * month + NUM ) + day ; }
public static long persian To Julian ( long year , int month , int day ) { return NUM * ( ( ceil ( year - NUM , NUM ) + NUM ) - NUM ) + ( ( long ) Math . floor ( ( NUM * ( ceil ( year - NUM , NUM ) + NUM ) - NUM ) / NUM ) ) + ( Persian Calendar Constants . PERSIAN EPOCH - NUM ) + NUM * ( ( long ) Math . floor ( ( year - NUM ) / NUM ) ) + ( month < NUM ? NUM * month : NUM * month + NUM ) + day ; }
private void ensure Capacity ( int desired Long Count ) { if ( desired Long Count <= bits . length ) { return ; } int new Length = Math . max ( desired Long Count , bits . length * NUM ) ; long [ ] new Bits = new long [ new Length ] ; System . arraycopy ( bits , NUM , new Bits , NUM , long Count ) ; this . bits = new Bits ; }
private void ensure Capacity ( int desired Long Count ) { if ( desired Long Count <= bits . length ) { return ; } int new Length = Math . max ( desired Long Count , bits . length * NUM ) ; long [ ] new Bits = new long [ new Length ] ; System . arraycopy ( bits , NUM , new Bits , NUM , long Count ) ; this . bits = new Bits ; }
public Document Fragment parse Fragment ( ) throws Parse Exception { return parse Fragment ( make Document ( find Doctype ( ) , null , dom Impl ) ) ; }
public Document Fragment parse Fragment ( ) throws Parse Exception { return parse Fragment ( make Document ( find Doctype ( ) , null , dom Impl ) ) ; }
public Document Fragment parse Fragment ( ) throws Parse Exception { return parse Fragment ( make Document ( find Doctype ( ) , null , dom Impl ) ) ; }
public Document Fragment parse Fragment ( ) throws Parse Exception { return parse Fragment ( make Document ( find Doctype ( ) , null , dom Impl ) ) ; }
public static int [ ] convert Selection To Model ( J Table table ) { int [ ] selected = table . get Selected Rows ( ) ; for ( int i = NUM ; i < selected . length ; i ++ ) { selected [ i ] = table . convert Row Index To Model ( selected [ i ] ) ; } return selected ; }
public static int [ ] convert Selection To Model ( J Table table ) { int [ ] selected = table . get Selected Rows ( ) ; for ( int i = NUM ; i < selected . length ; i ++ ) { selected [ i ] = table . convert Row Index To Model ( selected [ i ] ) ; } return selected ; }
@ Override public Completable Future < Boolean > all Match ( final Predicate < ? super T > predicate ) { return Completable Future . supply Async ( null , exec ) ; }
public static String read From Stream ( Input Stream is ) { Input Stream Reader isr ; try { isr = new Input Stream Reader ( is , STRING ) ; Buffered Reader br = new Buffered Reader ( isr ) ; String Builder sb = new String Builder ( ) ; String line ; while ( ( line = br . read Line ( ) ) != null ) { sb . append ( line ) ; sb . append ( STRING ) ; } br . close ( ) ; return sb . to String ( ) ; } catch ( Unsupported Encoding Exception e ) { return null ; } catch ( IO Exception e ) { return null ; } }
protected static String escape Dot ( String identifier To Escape ) { int indexof = identifier To Escape . index Of ( STRING ) ; if ( indexof == - NUM ) { return identifier To Escape ; } String Builder builder = new String Builder ( ) ; for ( int i = NUM ; i < identifier To Escape . length ( ) ; i ++ ) { char c = identifier To Escape . char At ( i ) ; if ( c != STRING ) { builder . append ( c ) ; continue ; } if ( i > NUM ) { if ( identifier To Escape . char At ( i - NUM ) == STRING ) { builder . append ( STRING ) ; continue ; } } builder . append ( STRING ) ; builder . append ( STRING ) ; } return builder . to String ( ) ; }
protected void finish Adding ( ) { no More Adding = BOOL ; work Space = null ; storage Space = null ; word Counts = null ; final int [ ] frqs = new int [ dimension Size ] ; for ( int i = NUM ; i < term Document Frequencys . length ( ) ; i ++ ) frqs [ i ] = term Document Frequencys . get ( i ) ; weighting . set Weight ( vectors , Int List . unmodifiable View ( frqs , dimension Size ) ) ; for ( Sparse Vector vec : vectors ) weighting . apply To ( vec ) ; term Document Frequencys = null ; }
protected void finish Adding ( ) { no More Adding = BOOL ; work Space = null ; storage Space = null ; word Counts = null ; final int [ ] frqs = new int [ dimension Size ] ; for ( int i = NUM ; i < term Document Frequencys . length ( ) ; i ++ ) frqs [ i ] = term Document Frequencys . get ( i ) ; weighting . set Weight ( vectors , Int List . unmodifiable View ( frqs , dimension Size ) ) ; for ( Sparse Vector vec : vectors ) weighting . apply To ( vec ) ; term Document Frequencys = null ; }
private List < String > read Lines ( final Buffered Reader reader ) throws IO Exception { final List < String > lines = new Array List < > ( ) ; String line ; for ( int line Number = NUM ; ( line = reader . read Line ( ) ) != null ; line Number ++ ) { if ( line . starts With ( STRING ) ) { final int last Line Index = lines . size ( ) - NUM ; final String previous Line = lines . get ( last Line Index ) ; if ( lines . is Empty ( ) || previous Line . is Empty ( ) ) { throw Decode Exception . fatal Error ( ERR TEMPLATE FILE INVALID LEADING SPACE . get ( line Number , line ) ) ; } lines . set ( last Line Index , previous Line + line . substring ( NUM ) ) ; } else { lines . add ( line ) ; } } return lines ; }
public static String to HEX String ( String input ) { String hex Tab = STRING ; String Builder output = new String Builder ( ) ; int x ; for ( int i = NUM ; i < input . length ( ) ; i ++ ) { x = char Code At ( input , i ) ; output . append ( hex Tab . char At ( ( x > > > NUM ) & NUM ) ) ; output . append ( hex Tab . char At ( x & NUM ) ) ; } return output . to String ( ) ; }
private static double parse Double Value ( String parse String , String open Tag , String close Tag , Data Type Validation Exception exception ) throws Data Type Validation Exception { String tag Value ; tag Value = parse String Value ( parse String , open Tag , close Tag , exception ) ; double double Value ; try { double Value = Double . parse Double ( tag Value ) ; } catch ( Number Format Exception e ) { throw e ; } return double Value ; }
private static double parse Double Value ( String parse String , String open Tag , String close Tag , Data Type Validation Exception exception ) throws Data Type Validation Exception { String tag Value ; tag Value = parse String Value ( parse String , open Tag , close Tag , exception ) ; double double Value ; try { double Value = Double . parse Double ( tag Value ) ; } catch ( Number Format Exception e ) { throw e ; } return double Value ; }
protected static List < Property Value Expression > to Property Expressions ( String ... properties ) { List < Property Value Expression > expr = new Array List < Property Value Expression > ( ) ; for ( String property : properties ) { expr . add ( get Prop Expr ( property ) ) ; } return expr ; }
protected static List < Property Value Expression > to Property Expressions ( String ... properties ) { List < Property Value Expression > expr = new Array List < Property Value Expression > ( ) ; for ( String property : properties ) { expr . add ( get Prop Expr ( property ) ) ; } return expr ; }
@ Request Mapping ( value = STRING , method = POST , produces = APPLICATION JSON VALUE ) public Response Entity < Page Response < User DTO > > find All ( @ Request Body Page Request By Example < User DTO > prbe ) throws URI Syntax Exception { Page Response < User DTO > page Response = user DTO Service . find All ( prbe ) ; return new Response Entity < > ( page Response , new Http Headers ( ) , Http Status . OK ) ; }
@ Request Mapping ( value = STRING , method = POST , produces = APPLICATION JSON VALUE ) public Response Entity < Page Response < User DTO > > find All ( @ Request Body Page Request By Example < User DTO > prbe ) throws URI Syntax Exception { Page Response < User DTO > page Response = user DTO Service . find All ( prbe ) ; return new Response Entity < > ( page Response , new Http Headers ( ) , Http Status . OK ) ; }
@ Request Mapping ( value = STRING , method = POST , produces = APPLICATION JSON VALUE ) public Response Entity < Page Response < User DTO > > find All ( @ Request Body Page Request By Example < User DTO > prbe ) throws URI Syntax Exception { Page Response < User DTO > page Response = user DTO Service . find All ( prbe ) ; return new Response Entity < > ( page Response , new Http Headers ( ) , Http Status . OK ) ; }
public void add Image Download Task ( Runnable task ) { if ( image Download Executor == null || image Download Executor . is Shutdown ( ) ) { image Download Executor = create Image Download Executor ( ) ; } image Download Executor . execute ( task ) ; }
public static List < String > find Best Trail Match ( List < List < String > > trails , List < String > match Trail , boolean contain Full Trail , boolean exact ) { List < String > best = null ; int part Matches = NUM ; for ( List < String > candidate Trail : trails ) { int candidate Part Matches = NUM ; Iterator < String > candidate It = candidate Trail . iterator ( ) ; Iterator < String > match It = match Trail . iterator ( ) ; while ( candidate It . has Next ( ) && match It . has Next ( ) ) { String candidate Part = candidate It . next ( ) ; String match Part = match It . next ( ) ; if ( candidate Part . equals ( match Part ) ) { candidate Part Matches ++ ; } else { break ; } } if ( candidate Part Matches == match Trail . size ( ) && match Trail . size ( ) == candidate Trail . size ( ) ) { return candidate Trail ; } else { if ( candidate Part Matches > part Matches ) { part Matches = candidate Part Matches ; best = candidate Trail ; } } } if ( exact ) { return null ; } else { if ( contain Full Trail ) { if ( part Matches >= match Trail . size ( ) ) { return best ; } else { return null ; } } else { return best ; } } }
public static List < String > find Best Trail Match ( List < List < String > > trails , List < String > match Trail , boolean contain Full Trail , boolean exact ) { List < String > best = null ; int part Matches = NUM ; for ( List < String > candidate Trail : trails ) { int candidate Part Matches = NUM ; Iterator < String > candidate It = candidate Trail . iterator ( ) ; Iterator < String > match It = match Trail . iterator ( ) ; while ( candidate It . has Next ( ) && match It . has Next ( ) ) { String candidate Part = candidate It . next ( ) ; String match Part = match It . next ( ) ; if ( candidate Part . equals ( match Part ) ) { candidate Part Matches ++ ; } else { break ; } } if ( candidate Part Matches == match Trail . size ( ) && match Trail . size ( ) == candidate Trail . size ( ) ) { return candidate Trail ; } else { if ( candidate Part Matches > part Matches ) { part Matches = candidate Part Matches ; best = candidate Trail ; } } } if ( exact ) { return null ; } else { if ( contain Full Trail ) { if ( part Matches >= match Trail . size ( ) ) { return best ; } else { return null ; } } else { return best ; } } }
public static List < String > find Best Trail Match ( List < List < String > > trails , List < String > match Trail , boolean contain Full Trail , boolean exact ) { List < String > best = null ; int part Matches = NUM ; for ( List < String > candidate Trail : trails ) { int candidate Part Matches = NUM ; Iterator < String > candidate It = candidate Trail . iterator ( ) ; Iterator < String > match It = match Trail . iterator ( ) ; while ( candidate It . has Next ( ) && match It . has Next ( ) ) { String candidate Part = candidate It . next ( ) ; String match Part = match It . next ( ) ; if ( candidate Part . equals ( match Part ) ) { candidate Part Matches ++ ; } else { break ; } } if ( candidate Part Matches == match Trail . size ( ) && match Trail . size ( ) == candidate Trail . size ( ) ) { return candidate Trail ; } else { if ( candidate Part Matches > part Matches ) { part Matches = candidate Part Matches ; best = candidate Trail ; } } } if ( exact ) { return null ; } else { if ( contain Full Trail ) { if ( part Matches >= match Trail . size ( ) ) { return best ; } else { return null ; } } else { return best ; } } }
public static int index Of Ignore Case ( String src , String sub S , int start Index ) { return index Of Ignore Case ( src , sub S , start Index , src . length ( ) ) ; }
public static int index Of Ignore Case ( String src , String sub S , int start Index ) { return index Of Ignore Case ( src , sub S , start Index , src . length ( ) ) ; }
public static int index Of Ignore Case ( String src , String sub S , int start Index ) { return index Of Ignore Case ( src , sub S , start Index , src . length ( ) ) ; }
public static int index Of Ignore Case ( String src , String sub S , int start Index ) { return index Of Ignore Case ( src , sub S , start Index , src . length ( ) ) ; }
public static int index Of Ignore Case ( String src , String sub S , int start Index ) { return index Of Ignore Case ( src , sub S , start Index , src . length ( ) ) ; }
public static int index Of Ignore Case ( String src , String sub S , int start Index ) { return index Of Ignore Case ( src , sub S , start Index , src . length ( ) ) ; }
private Date parse Date ( String date String ) throws Parse Exception { java . util . Date parsed Date = Date Field . parse ( date String ) ; if ( parsed Date == null ) return null ; return new Date ( parsed Date . get Time ( ) ) ; }
public java . lang . String Buffer insert ( int offset , double d ) { internal . insert ( offset , d ) ; return this ; }
public java . lang . String Buffer insert ( int offset , double d ) { internal . insert ( offset , d ) ; return this ; }
public java . lang . String Buffer insert ( int offset , double d ) { internal . insert ( offset , d ) ; return this ; }
public Sequence Template Parameter Context add Sequence Parameter ( Sequence Type seq Type , Sequence UUID uuid , Sequence Context Parameters param Name , String param Value ) { init Sequence ( seq Type , uuid ) ; do Add Parameter ( seq Type , uuid , param Name , param Value ) ; return this ; }
public C Abstract Operator Panel ( ) { super ( new Border Layout ( ) ) ; final J Panel main Panel = new J Panel ( new Border Layout ( ) ) ; main Panel . set Border ( new Titled Border ( get Border Title ( ) ) ) ; final J Panel info Panel = new J Panel ( new Border Layout ( ) ) ; info Panel . set Border ( new Empty Border ( NUM , NUM , NUM , NUM ) ) ; m info Field . set Background ( info Panel . get Background ( ) ) ; m info Field . set Line Wrap ( BOOL ) ; m info Field . set Wrap Style Word ( BOOL ) ; m info Field . set Editable ( BOOL ) ; info Panel . add ( m info Field , Border Layout . CENTER ) ; main Panel . add ( info Panel , Border Layout . CENTER ) ; add ( main Panel , Border Layout . CENTER ) ; }
protected void override Default Strategy Map ( final Map < String , S > map ) { }
protected void override Default Strategy Map ( final Map < String , S > map ) { }
protected void override Default Strategy Map ( final Map < String , S > map ) { }
protected void override Default Strategy Map ( final Map < String , S > map ) { }
public static void columns For ( Result Set result Set , Table Editor editor ) throws SQL Exception { List < Column > columns = new Array List < > ( ) ; columns For ( result Set , null ) ; editor . set Columns ( columns ) ; }
public static void columns For ( Result Set result Set , Table Editor editor ) throws SQL Exception { List < Column > columns = new Array List < > ( ) ; columns For ( result Set , null ) ; editor . set Columns ( columns ) ; }
@ React Method public void r Delete All ( Callback error Callback , Callback success Callback ) { try { Array List < Integer > ids = m Notification Manager . get I Ds ( ) ; for ( Integer id : ids ) { try { m Notification Manager . delete ( id ) ; } catch ( Exception e ) { Log . e ( STRING , STRING + Log . get Stack Trace String ( e ) ) ; } } success Callback . invoke ( ) ; } catch ( Exception e ) { error Callback . invoke ( e . get Message ( ) ) ; Log . e ( STRING , STRING + Log . get Stack Trace String ( e ) ) ; } }
public static void clear Rect ( Graphics 2 D g , Rectangle rect , Color background ) { if ( background != null ) { g . set Color ( background ) ; g . fill Rect ( rect . x , rect . y , rect . width , rect . height ) ; } else { g . set Composite ( Alpha Composite . get Instance ( Alpha Composite . CLEAR , NUM ) ) ; g . fill Rect ( rect . x , rect . y , rect . width , rect . height ) ; g . set Composite ( Alpha Composite . Src Over ) ; } }
public static void clear Rect ( Graphics 2 D g , Rectangle rect , Color background ) { if ( background != null ) { g . set Color ( background ) ; g . fill Rect ( rect . x , rect . y , rect . width , rect . height ) ; } else { g . set Composite ( Alpha Composite . get Instance ( Alpha Composite . CLEAR , NUM ) ) ; g . fill Rect ( rect . x , rect . y , rect . width , rect . height ) ; g . set Composite ( Alpha Composite . Src Over ) ; } }
public static void clear Rect ( Graphics 2 D g , Rectangle rect , Color background ) { if ( background != null ) { g . set Color ( background ) ; g . fill Rect ( rect . x , rect . y , rect . width , rect . height ) ; } else { g . set Composite ( Alpha Composite . get Instance ( Alpha Composite . CLEAR , NUM ) ) ; g . fill Rect ( rect . x , rect . y , rect . width , rect . height ) ; g . set Composite ( Alpha Composite . Src Over ) ; } }
public int edge Index ( Triangulation Point p1 , Triangulation Point p2 ) { if ( points [ NUM ] == p1 ) { if ( points [ NUM ] == p2 ) { return NUM ; } else if ( points [ NUM ] == p2 ) { return NUM ; } } else if ( points [ NUM ] == p1 ) { if ( points [ NUM ] == p2 ) { return NUM ; } else if ( points [ NUM ] == p2 ) { return NUM ; } } else if ( points [ NUM ] == p1 ) { if ( points [ NUM ] == p2 ) { return NUM ; } else if ( points [ NUM ] == p2 ) { return NUM ; } } return - NUM ; }
public int edge Index ( Triangulation Point p1 , Triangulation Point p2 ) { if ( points [ NUM ] == p1 ) { if ( points [ NUM ] == p2 ) { return NUM ; } else if ( points [ NUM ] == p2 ) { return NUM ; } } else if ( points [ NUM ] == p1 ) { if ( points [ NUM ] == p2 ) { return NUM ; } else if ( points [ NUM ] == p2 ) { return NUM ; } } else if ( points [ NUM ] == p1 ) { if ( points [ NUM ] == p2 ) { return NUM ; } else if ( points [ NUM ] == p2 ) { return NUM ; } } return - NUM ; }
public int edge Index ( Triangulation Point p1 , Triangulation Point p2 ) { if ( points [ NUM ] == p1 ) { if ( points [ NUM ] == p2 ) { return NUM ; } else if ( points [ NUM ] == p2 ) { return NUM ; } } else if ( points [ NUM ] == p1 ) { if ( points [ NUM ] == p2 ) { return NUM ; } else if ( points [ NUM ] == p2 ) { return NUM ; } } else if ( points [ NUM ] == p1 ) { if ( points [ NUM ] == p2 ) { return NUM ; } else if ( points [ NUM ] == p2 ) { return NUM ; } } return - NUM ; }
public static int compare Canonical Decimals ( String dec 1 , String dec 2 ) { if ( dec 1 . equals ( dec 2 ) ) { return NUM ; } if ( dec 1 . char At ( NUM ) == STRING && dec 2 . char At ( NUM ) != STRING ) { return - NUM ; } if ( dec 2 . char At ( NUM ) == STRING && dec 1 . char At ( NUM ) != STRING ) { return NUM ; } int dot Idx 1 = dec 1 . index Of ( STRING ) ; int dot Idx 2 = dec 2 . index Of ( STRING ) ; int result = dot Idx 1 - dot Idx 2 ; if ( result == NUM ) { for ( int i = NUM ; result == NUM && i < dot Idx 1 ; i ++ ) { result = dec 1 . char At ( i ) - dec 2 . char At ( i ) ; } int dec 1 Length = dec 1 . length ( ) ; int dec 2 Length = dec 2 . length ( ) ; int last Idx = dec 1 Length <= dec 2 Length ? dec 1 Length : dec 2 Length ; for ( int i = dot Idx 1 + NUM ; result == NUM && i < last Idx ; i ++ ) { result = dec 1 . char At ( i ) - dec 2 . char At ( i ) ; } if ( result == NUM ) { result = dec 1 Length - dec 2 Length ; } } if ( dec 1 . char At ( NUM ) == STRING ) { result = - result ; } return result ; }
public static int compare Canonical Decimals ( String dec 1 , String dec 2 ) { if ( dec 1 . equals ( dec 2 ) ) { return NUM ; } if ( dec 1 . char At ( NUM ) == STRING && dec 2 . char At ( NUM ) != STRING ) { return - NUM ; } if ( dec 2 . char At ( NUM ) == STRING && dec 1 . char At ( NUM ) != STRING ) { return NUM ; } int dot Idx 1 = dec 1 . index Of ( STRING ) ; int dot Idx 2 = dec 2 . index Of ( STRING ) ; int result = dot Idx 1 - dot Idx 2 ; if ( result == NUM ) { for ( int i = NUM ; result == NUM && i < dot Idx 1 ; i ++ ) { result = dec 1 . char At ( i ) - dec 2 . char At ( i ) ; } int dec 1 Length = dec 1 . length ( ) ; int dec 2 Length = dec 2 . length ( ) ; int last Idx = dec 1 Length <= dec 2 Length ? dec 1 Length : dec 2 Length ; for ( int i = dot Idx 1 + NUM ; result == NUM && i < last Idx ; i ++ ) { result = dec 1 . char At ( i ) - dec 2 . char At ( i ) ; } if ( result == NUM ) { result = dec 1 Length - dec 2 Length ; } } if ( dec 1 . char At ( NUM ) == STRING ) { result = - result ; } return result ; }
public Pointer to Dense Matrix ( cusparse Handle cusparse Handle , cublas Handle cublas Handle , int rows , int cols ) throws DML Runtime Exception { long size = rows * cols * Sizeof . DOUBLE ; Pointer A = J Cuda Object . allocate ( size ) ; cusparse Dcsr 2 dense ( cusparse Handle , rows , cols , descr , val , row Ptr , col Ind , A , rows ) ; return A ; }
public Pointer to Dense Matrix ( cusparse Handle cusparse Handle , cublas Handle cublas Handle , int rows , int cols ) throws DML Runtime Exception { long size = rows * cols * Sizeof . DOUBLE ; Pointer A = J Cuda Object . allocate ( size ) ; cusparse Dcsr 2 dense ( cusparse Handle , rows , cols , descr , val , row Ptr , col Ind , A , rows ) ; return A ; }
protected int create Step Instances For Job ( String job Id , Map < String , String > parameters ) { int step Instances Created Count = NUM ; Job job = jobs . get Job By Id ( job Id ) ; final Map < Step , List < Step Instance > > step To Step Instances = new Hash Map < > ( ) ; for ( Step step : job . get Steps ( ) ) { step Instances Created Count ++ ; Step Instance step Instance = new Step Instance ( step ) ; step Instance . add Parameters ( parameters ) ; List < Step Instance > mapped Step Instance = step To Step Instances . get ( step ) ; if ( mapped Step Instance == null ) { mapped Step Instance = new Array List < > ( ) ; step To Step Instances . put ( step , mapped Step Instance ) ; } mapped Step Instance . add ( step Instance ) ; } add Dependencies And Store ( step To Step Instances ) ; return step Instances Created Count ; }
public static String extract Collection From Path ( String path ) { String extracted Collection Name = null ; String path Modified = remove From End Of String ( path , SLASH ) ; String [ ] path Segments = path Modified . split ( STRING ) ; if ( path Segments . length > NUM ) { extracted Collection Name = path Segments [ path Segments . length - NUM ] ; } return extracted Collection Name ; }
private int [ ] pick Auto Detected Local Address ( ) throws IO Exception { Inet Address address Obj = Inet Address . get Local Host ( ) ; byte [ ] addr = address Obj . get Address ( ) ; int b1 = addr [ NUM ] & NUM ; int b2 = addr [ NUM ] & NUM ; int b3 = addr [ NUM ] & NUM ; int b4 = addr [ NUM ] & NUM ; int [ ] ret = { b1 , b2 , b3 , b4 } ; return ret ; }
private int [ ] pick Auto Detected Local Address ( ) throws IO Exception { Inet Address address Obj = Inet Address . get Local Host ( ) ; byte [ ] addr = address Obj . get Address ( ) ; int b1 = addr [ NUM ] & NUM ; int b2 = addr [ NUM ] & NUM ; int b3 = addr [ NUM ] & NUM ; int b4 = addr [ NUM ] & NUM ; int [ ] ret = { b1 , b2 , b3 , b4 } ; return ret ; }
private String read Node Address ( ) { String addr = STRING ; addr = node Addr Field . get Text ( ) ; if ( addr . equals ( STRING ) || addr . equals ( STRING ) || addr . equals ( STRING ) ) { addr = node Addr 64 Field . get Text ( ) ; } return ( addr ) ; }
private byte [ ] read Payload Column ( Result Set rows , int column Index ) throws SQL Exception { String str ; byte [ ] payload = EMPTY DATA ; switch ( options . content Data Type ) { case Collection Descriptor . CLOB CONTENT : case Collection Descriptor . CHAR CONTENT : str = rows . get String ( column Index ) ; if ( str != null ) payload = str . get Bytes ( Byte Array . DEFAULT CHARSET ) ; break ; case Collection Descriptor . NCLOB CONTENT : case Collection Descriptor . NCHAR CONTENT : str = rows . get N String ( column Index ) ; if ( str != null ) payload = str . get Bytes ( Byte Array . DEFAULT CHARSET ) ; break ; case Collection Descriptor . BLOB CONTENT : case Collection Descriptor . RAW CONTENT : payload = rows . get Bytes ( column Index ) ; break ; } return ( payload ) ; }
public boolean add To Active List ( Download Info Runnable download Info Runnable ) { return active List Has Room ( ) && m Active List . add ( download Info Runnable ) ; }
public Builder with Accept Backlog ( int accept Backlog ) { properties . set Property ( Netty Options . ACCEPT BACKLOG , String . value Of ( Assert . arg Not ( accept Backlog , accept Backlog <= NUM , STRING ) ) ) ; return this ; }
public Builder with Accept Backlog ( int accept Backlog ) { properties . set Property ( Netty Options . ACCEPT BACKLOG , String . value Of ( Assert . arg Not ( accept Backlog , accept Backlog <= NUM , STRING ) ) ) ; return this ; }
protected int [ ] split Sentence ( String sentence ) { String [ ] w = sentence . split ( STRING ) ; int [ ] words = new int [ w . length ] ; for ( int i = NUM ; i < w . length ; i ++ ) words [ i ] = Vocabulary . id ( w [ i ] ) ; return words ; }
public boolean is In Group ( Visual Item item , String group ) { if ( ALL ITEMS . equals ( group ) ) { return BOOL ; } if ( item . get Group ( ) == group ) { return BOOL ; } Tuple Set tset = get Group ( group ) ; return ( tset == null ? BOOL : tset . contains Tuple ( item ) ) ; }
public boolean is In Group ( Visual Item item , String group ) { if ( ALL ITEMS . equals ( group ) ) { return BOOL ; } if ( item . get Group ( ) == group ) { return BOOL ; } Tuple Set tset = get Group ( group ) ; return ( tset == null ? BOOL : tset . contains Tuple ( item ) ) ; }
public void remove Value ( Value value ) { action Values . remove ( value ) ; action Values As Array = null ; }
public synchronized Base Type create Pointer Type ( final Base Type base Type ) throws Couldnt Save Data Exception { Preconditions . check Not Null ( base Type , STRING ) ; if ( base Type . pointed To By ( ) != null ) { return base Type . pointed To By ( ) ; } else { final String new Type Name = Base Type . get Pointer Type Name ( base Type , base Type . get Pointer Level ( ) + NUM ) ; final Base Type new Type = instantiate Type ( new Type Name , get Default Pointer Size ( ) , BOOL , base Type , Base Type Category . POINTER ) ; notify Type Added ( new Type ) ; return new Type ; } }
public synchronized Base Type create Pointer Type ( final Base Type base Type ) throws Couldnt Save Data Exception { Preconditions . check Not Null ( base Type , STRING ) ; if ( base Type . pointed To By ( ) != null ) { return base Type . pointed To By ( ) ; } else { final String new Type Name = Base Type . get Pointer Type Name ( base Type , base Type . get Pointer Level ( ) + NUM ) ; final Base Type new Type = instantiate Type ( new Type Name , get Default Pointer Size ( ) , BOOL , base Type , Base Type Category . POINTER ) ; notify Type Added ( new Type ) ; return new Type ; } }
public synchronized Base Type create Pointer Type ( final Base Type base Type ) throws Couldnt Save Data Exception { Preconditions . check Not Null ( base Type , STRING ) ; if ( base Type . pointed To By ( ) != null ) { return base Type . pointed To By ( ) ; } else { final String new Type Name = Base Type . get Pointer Type Name ( base Type , base Type . get Pointer Level ( ) + NUM ) ; final Base Type new Type = instantiate Type ( new Type Name , get Default Pointer Size ( ) , BOOL , base Type , Base Type Category . POINTER ) ; notify Type Added ( new Type ) ; return new Type ; } }
public synchronized Base Type create Pointer Type ( final Base Type base Type ) throws Couldnt Save Data Exception { Preconditions . check Not Null ( base Type , STRING ) ; if ( base Type . pointed To By ( ) != null ) { return base Type . pointed To By ( ) ; } else { final String new Type Name = Base Type . get Pointer Type Name ( base Type , base Type . get Pointer Level ( ) + NUM ) ; final Base Type new Type = instantiate Type ( new Type Name , get Default Pointer Size ( ) , BOOL , base Type , Base Type Category . POINTER ) ; notify Type Added ( new Type ) ; return new Type ; } }
public synchronized Base Type create Pointer Type ( final Base Type base Type ) throws Couldnt Save Data Exception { Preconditions . check Not Null ( base Type , STRING ) ; if ( base Type . pointed To By ( ) != null ) { return base Type . pointed To By ( ) ; } else { final String new Type Name = Base Type . get Pointer Type Name ( base Type , base Type . get Pointer Level ( ) + NUM ) ; final Base Type new Type = instantiate Type ( new Type Name , get Default Pointer Size ( ) , BOOL , base Type , Base Type Category . POINTER ) ; notify Type Added ( new Type ) ; return new Type ; } }
private I Expression Description add ( final String key , final I Expression Description expr ) { Facet f = new Facet ( key , expr ) ; Facet [ ] ff = new Facet [ facets . length + NUM ] ; System . arraycopy ( facets , NUM , ff , NUM , facets . length ) ; facets = ff ; facets [ facets . length - NUM ] = f ; return expr ; }
private I Expression Description add ( final String key , final I Expression Description expr ) { Facet f = new Facet ( key , expr ) ; Facet [ ] ff = new Facet [ facets . length + NUM ] ; System . arraycopy ( facets , NUM , ff , NUM , facets . length ) ; facets = ff ; facets [ facets . length - NUM ] = f ; return expr ; }
private I Expression Description add ( final String key , final I Expression Description expr ) { Facet f = new Facet ( key , expr ) ; Facet [ ] ff = new Facet [ facets . length + NUM ] ; System . arraycopy ( facets , NUM , ff , NUM , facets . length ) ; facets = ff ; facets [ facets . length - NUM ] = f ; return expr ; }
private I Expression Description add ( final String key , final I Expression Description expr ) { Facet f = new Facet ( key , expr ) ; Facet [ ] ff = new Facet [ facets . length + NUM ] ; System . arraycopy ( facets , NUM , ff , NUM , facets . length ) ; facets = ff ; facets [ facets . length - NUM ] = f ; return expr ; }
public void remove All Plugins ( ) { Iterator < Abstract Plugin > iter = all Plugins . iterator ( ) ; while ( iter . has Next ( ) ) { Abstract Plugin plugin = ( Abstract Plugin ) iter . next ( ) ; plugin . remove Plugin Observer ( this ) ; active Plugins . remove ( plugin ) ; iter . remove ( ) ; } }
public final Test Suite build ( ) { root Suite = new Test Suite ( get Suite Name ( ) ) ; current Classname = null ; try { for ( Test Method test : test Grouping . get Tests ( ) ) { if ( satisfies All Predicates ( test ) ) { add Test ( test ) ; } } if ( test Cases . size ( ) > NUM ) { for ( Test Case test Case : test Cases ) { if ( satisfies All Predicates ( new Test Method ( test Case ) ) ) { add Test ( test Case ) ; } } } } catch ( Exception exception ) { Log . i ( STRING , STRING , exception ) ; Test Suite suite = new Test Suite ( get Suite Name ( ) ) ; suite . add Test ( new Failed To Create Tests ( exception ) ) ; return suite ; } return root Suite ; }
public final Test Suite build ( ) { root Suite = new Test Suite ( get Suite Name ( ) ) ; current Classname = null ; try { for ( Test Method test : test Grouping . get Tests ( ) ) { if ( satisfies All Predicates ( test ) ) { add Test ( test ) ; } } if ( test Cases . size ( ) > NUM ) { for ( Test Case test Case : test Cases ) { if ( satisfies All Predicates ( new Test Method ( test Case ) ) ) { add Test ( test Case ) ; } } } } catch ( Exception exception ) { Log . i ( STRING , STRING , exception ) ; Test Suite suite = new Test Suite ( get Suite Name ( ) ) ; suite . add Test ( new Failed To Create Tests ( exception ) ) ; return suite ; } return root Suite ; }
public final Test Suite build ( ) { root Suite = new Test Suite ( get Suite Name ( ) ) ; current Classname = null ; try { for ( Test Method test : test Grouping . get Tests ( ) ) { if ( satisfies All Predicates ( test ) ) { add Test ( test ) ; } } if ( test Cases . size ( ) > NUM ) { for ( Test Case test Case : test Cases ) { if ( satisfies All Predicates ( new Test Method ( test Case ) ) ) { add Test ( test Case ) ; } } } } catch ( Exception exception ) { Log . i ( STRING , STRING , exception ) ; Test Suite suite = new Test Suite ( get Suite Name ( ) ) ; suite . add Test ( new Failed To Create Tests ( exception ) ) ; return suite ; } return root Suite ; }
public final Test Suite build ( ) { root Suite = new Test Suite ( get Suite Name ( ) ) ; current Classname = null ; try { for ( Test Method test : test Grouping . get Tests ( ) ) { if ( satisfies All Predicates ( test ) ) { add Test ( test ) ; } } if ( test Cases . size ( ) > NUM ) { for ( Test Case test Case : test Cases ) { if ( satisfies All Predicates ( new Test Method ( test Case ) ) ) { add Test ( test Case ) ; } } } } catch ( Exception exception ) { Log . i ( STRING , STRING , exception ) ; Test Suite suite = new Test Suite ( get Suite Name ( ) ) ; suite . add Test ( new Failed To Create Tests ( exception ) ) ; return suite ; } return root Suite ; }
public boolean is Enum Constant ( ) { return ( get Modifiers ( ) & Modifier . ENUM ) != NUM ; }
private Boolean has State Specific Attributes ( Node node ) { for ( Iterator < Q Name > attributes = node . get Attribute Names ( ) ; attributes != null && attributes . has Next ( ) ; ) { Q Name qname = attributes . next ( ) ; String local Part = qname . get Local Part ( ) ; if ( Text Parser . is Scoped Name ( local Part ) ) return BOOL ; } return BOOL ; }
private Boolean has State Specific Attributes ( Node node ) { for ( Iterator < Q Name > attributes = node . get Attribute Names ( ) ; attributes != null && attributes . has Next ( ) ; ) { Q Name qname = attributes . next ( ) ; String local Part = qname . get Local Part ( ) ; if ( Text Parser . is Scoped Name ( local Part ) ) return BOOL ; } return BOOL ; }
private Boolean has State Specific Attributes ( Node node ) { for ( Iterator < Q Name > attributes = node . get Attribute Names ( ) ; attributes != null && attributes . has Next ( ) ; ) { Q Name qname = attributes . next ( ) ; String local Part = qname . get Local Part ( ) ; if ( Text Parser . is Scoped Name ( local Part ) ) return BOOL ; } return BOOL ; }
public Open DJ Upgrader ( Embedded Open DJ Backup Manager backup Manager , String install Root , Servlet Context servlet Ctx ) { this . backup Manager = backup Manager ; this . install Root = install Root ; this . servlet Ctx = servlet Ctx ; this . upgrade Marker = new File ( install Root + STRING ) ; this . new Version = read New Version ( ) ; Open DJ Version current Version = read Current Version ( ) ; if ( upgrade Marker . exists ( ) && new Version . equals ( current Version ) ) { this . current Version = read Version From File ( upgrade Marker ) ; } else { this . current Version = current Version ; } }
public Daylight Condition ( final Daylight Phase ... daylight Phases ) { super ( ) ; this . daylight Phases = Arrays . as List ( daylight Phases ) ; }
public void test Example Keystore Path ( ) { assert Not Null ( STRING + STRING + STRING , SSL Test Config . TEST KEYSTORE ) ; }
public void test Example Keystore Path ( ) { assert Not Null ( STRING + STRING + STRING , SSL Test Config . TEST KEYSTORE ) ; }
public void test Example Keystore Path ( ) { assert Not Null ( STRING + STRING + STRING , SSL Test Config . TEST KEYSTORE ) ; }
public void test Example Keystore Path ( ) { assert Not Null ( STRING + STRING + STRING , SSL Test Config . TEST KEYSTORE ) ; }
public void test Example Keystore Path ( ) { assert Not Null ( STRING + STRING + STRING , SSL Test Config . TEST KEYSTORE ) ; }
public void test Example Keystore Path ( ) { assert Not Null ( STRING + STRING + STRING , SSL Test Config . TEST KEYSTORE ) ; }
public void test Example Keystore Path ( ) { assert Not Null ( STRING + STRING + STRING , SSL Test Config . TEST KEYSTORE ) ; }
public void test Example Keystore Path ( ) { assert Not Null ( STRING + STRING + STRING , SSL Test Config . TEST KEYSTORE ) ; }
private void handle Auto Numbers For Add ( Object [ ] row , Write Row State write Row State ) throws IO Exception { if ( auto Num Columns . is Empty ( ) ) { return ; } boolean enable Insert = is Allow Auto Number Insert ( ) ; write Row State . reset Auto Number ( ) ; for ( Column Impl col : auto Num Columns ) { Object in Row Value = get Input Auto Number Row Value ( enable Insert , col , row ) ; Column Impl . Auto Number Generator auto Num Gen = col . get Auto Number Generator ( ) ; Object row Value = ( ( in Row Value == null ) ? auto Num Gen . get Next ( write Row State ) : auto Num Gen . handle Insert ( write Row State , in Row Value ) ) ; col . set Row Value ( row , row Value ) ; } }
private boolean process Removed Node ( final I Navi View Node node ) { if ( node instanceof I Navi Code Node ) { final I Navi Code Node cnode = ( I Navi Code Node ) node ; try { final I Navi Function target Function = cnode . get Parent Function ( ) ; if ( m node Counter . contains Key ( target Function ) ) { final int new Counter = m node Counter . get ( target Function ) - NUM ; if ( new Counter == NUM ) { m node Counter . remove ( target Function ) ; final Set < C Cross Reference > to Delete = new Hash Set < C Cross Reference > ( ) ; for ( final C Cross Reference reference : m cross References ) { if ( reference . get Called Function ( ) == target Function ) { to Delete . add ( reference ) ; } } m cross References . remove All ( to Delete ) ; return BOOL ; } else { m node Counter . put ( target Function , new Counter ) ; } } } catch ( final Maybe Null Exception exception ) { } } return BOOL ; }
private boolean process Removed Node ( final I Navi View Node node ) { if ( node instanceof I Navi Code Node ) { final I Navi Code Node cnode = ( I Navi Code Node ) node ; try { final I Navi Function target Function = cnode . get Parent Function ( ) ; if ( m node Counter . contains Key ( target Function ) ) { final int new Counter = m node Counter . get ( target Function ) - NUM ; if ( new Counter == NUM ) { m node Counter . remove ( target Function ) ; final Set < C Cross Reference > to Delete = new Hash Set < C Cross Reference > ( ) ; for ( final C Cross Reference reference : m cross References ) { if ( reference . get Called Function ( ) == target Function ) { to Delete . add ( reference ) ; } } m cross References . remove All ( to Delete ) ; return BOOL ; } else { m node Counter . put ( target Function , new Counter ) ; } } } catch ( final Maybe Null Exception exception ) { } } return BOOL ; }
private boolean process Removed Node ( final I Navi View Node node ) { if ( node instanceof I Navi Code Node ) { final I Navi Code Node cnode = ( I Navi Code Node ) node ; try { final I Navi Function target Function = cnode . get Parent Function ( ) ; if ( m node Counter . contains Key ( target Function ) ) { final int new Counter = m node Counter . get ( target Function ) - NUM ; if ( new Counter == NUM ) { m node Counter . remove ( target Function ) ; final Set < C Cross Reference > to Delete = new Hash Set < C Cross Reference > ( ) ; for ( final C Cross Reference reference : m cross References ) { if ( reference . get Called Function ( ) == target Function ) { to Delete . add ( reference ) ; } } m cross References . remove All ( to Delete ) ; return BOOL ; } else { m node Counter . put ( target Function , new Counter ) ; } } } catch ( final Maybe Null Exception exception ) { } } return BOOL ; }
public static Window window For Word In Position ( int window Size , int word Pos , List < String > sentence ) { List < String > window = new Array List < > ( ) ; List < String > only Tokens = new Array List < > ( ) ; int context Size = ( int ) Math . floor ( ( window Size - NUM ) / NUM ) ; for ( int i = word Pos - context Size ; i <= word Pos + context Size ; i ++ ) { if ( i < NUM ) window . add ( STRING ) ; else if ( i >= sentence . size ( ) ) window . add ( STRING ) ; else { only Tokens . add ( sentence . get ( i ) ) ; window . add ( sentence . get ( i ) ) ; } } String whole Sentence = String Utils . join ( sentence ) ; String window 2 = String Utils . join ( only Tokens ) ; int begin = whole Sentence . index Of ( window 2 ) ; int end = begin + window 2 . length ( ) ; return new Window ( window , begin , end ) ; }
public static < T > I List < T > create ( final I Type t , final Stream < T > stream ) { return ( I List < T > ) stream . collect ( TO GAMA LIST ) ; }
public static < T > I List < T > create ( final I Type t , final Stream < T > stream ) { return ( I List < T > ) stream . collect ( TO GAMA LIST ) ; }
public static < T > I List < T > create ( final I Type t , final Stream < T > stream ) { return ( I List < T > ) stream . collect ( TO GAMA LIST ) ; }
void update Entity Config ( String realm , String cot Name , String protocol Type , Set trusted Providers ) throws COT Exception { if ( protocol Type . equals Ignore Case ( COT Constants . IDFF ) ) { update IDFF Entity Config ( realm , cot Name , trusted Providers ) ; } else if ( protocol Type . equals Ignore Case ( COT Constants . SAML 2 ) ) { update SAML 2 Entity Config ( realm , cot Name , trusted Providers ) ; } else if ( protocol Type . equals Ignore Case ( COT Constants . WS FED ) ) { update WS Fed Entity Config ( realm , cot Name , trusted Providers ) ; } else { String [ ] args = { protocol Type } ; throw new COT Exception ( STRING , args ) ; } }
void update Entity Config ( String realm , String cot Name , String protocol Type , Set trusted Providers ) throws COT Exception { if ( protocol Type . equals Ignore Case ( COT Constants . IDFF ) ) { update IDFF Entity Config ( realm , cot Name , trusted Providers ) ; } else if ( protocol Type . equals Ignore Case ( COT Constants . SAML 2 ) ) { update SAML 2 Entity Config ( realm , cot Name , trusted Providers ) ; } else if ( protocol Type . equals Ignore Case ( COT Constants . WS FED ) ) { update WS Fed Entity Config ( realm , cot Name , trusted Providers ) ; } else { String [ ] args = { protocol Type } ; throw new COT Exception ( STRING , args ) ; } }
void update Entity Config ( String realm , String cot Name , String protocol Type , Set trusted Providers ) throws COT Exception { if ( protocol Type . equals Ignore Case ( COT Constants . IDFF ) ) { update IDFF Entity Config ( realm , cot Name , trusted Providers ) ; } else if ( protocol Type . equals Ignore Case ( COT Constants . SAML 2 ) ) { update SAML 2 Entity Config ( realm , cot Name , trusted Providers ) ; } else if ( protocol Type . equals Ignore Case ( COT Constants . WS FED ) ) { update WS Fed Entity Config ( realm , cot Name , trusted Providers ) ; } else { String [ ] args = { protocol Type } ; throw new COT Exception ( STRING , args ) ; } }
void update Entity Config ( String realm , String cot Name , String protocol Type , Set trusted Providers ) throws COT Exception { if ( protocol Type . equals Ignore Case ( COT Constants . IDFF ) ) { update IDFF Entity Config ( realm , cot Name , trusted Providers ) ; } else if ( protocol Type . equals Ignore Case ( COT Constants . SAML 2 ) ) { update SAML 2 Entity Config ( realm , cot Name , trusted Providers ) ; } else if ( protocol Type . equals Ignore Case ( COT Constants . WS FED ) ) { update WS Fed Entity Config ( realm , cot Name , trusted Providers ) ; } else { String [ ] args = { protocol Type } ; throw new COT Exception ( STRING , args ) ; } }
private void add One Source Token To TLA ( String str , Region region ) { if ( region == null ) { add One Token To TLA ( str ) ; return ; } int begin Col = tlacode Next Line . length ( ) ; int end Col = begin Col + str . length ( ) ; mapping Vector Next Line . add Element ( new Mapping Object . Source Token ( begin Col , end Col , region ) ) ; tlacode Next Line = tlacode Next Line + str ; }
public synchronized boolean verify And Advance State ( Byte new Step ) { logger . debug ( STRING , node . get Node Id ( ) , Z Wave Security Command Class . command To String ( new Step ) , Z Wave Security Command Class . command To String ( current Step ) ) ; if ( ! INIT COMMAND ORDER LIST . contains ( new Step ) ) { return BOOL ; } if ( INIT COMMAND ORDER LIST . index Of ( new Step ) > NUM ) { int current Index = INIT COMMAND ORDER LIST . index Of ( current Step ) ; int new Index = INIT COMMAND ORDER LIST . index Of ( new Step ) ; if ( new Index != current Index && new Index - current Index > NUM ) { if ( HALT ON IMPROPER ORDER ) { set Error State ( String . format ( STRING , node . get Node Id ( ) , Z Wave Security Command Class . command To String ( current Step ) , Z Wave Security Command Class . command To String ( new Step ) ) ) ; return BOOL ; } else { logger . warn ( STRING , node . get Node Id ( ) , Z Wave Security Command Class . command To String ( current Step ) , Z Wave Security Command Class . command To String ( new Step ) ) ; } } } current Step = new Step ; return BOOL ; }
public synchronized boolean verify And Advance State ( Byte new Step ) { logger . debug ( STRING , node . get Node Id ( ) , Z Wave Security Command Class . command To String ( new Step ) , Z Wave Security Command Class . command To String ( current Step ) ) ; if ( ! INIT COMMAND ORDER LIST . contains ( new Step ) ) { return BOOL ; } if ( INIT COMMAND ORDER LIST . index Of ( new Step ) > NUM ) { int current Index = INIT COMMAND ORDER LIST . index Of ( current Step ) ; int new Index = INIT COMMAND ORDER LIST . index Of ( new Step ) ; if ( new Index != current Index && new Index - current Index > NUM ) { if ( HALT ON IMPROPER ORDER ) { set Error State ( String . format ( STRING , node . get Node Id ( ) , Z Wave Security Command Class . command To String ( current Step ) , Z Wave Security Command Class . command To String ( new Step ) ) ) ; return BOOL ; } else { logger . warn ( STRING , node . get Node Id ( ) , Z Wave Security Command Class . command To String ( current Step ) , Z Wave Security Command Class . command To String ( new Step ) ) ; } } } current Step = new Step ; return BOOL ; }
public synchronized boolean verify And Advance State ( Byte new Step ) { logger . debug ( STRING , node . get Node Id ( ) , Z Wave Security Command Class . command To String ( new Step ) , Z Wave Security Command Class . command To String ( current Step ) ) ; if ( ! INIT COMMAND ORDER LIST . contains ( new Step ) ) { return BOOL ; } if ( INIT COMMAND ORDER LIST . index Of ( new Step ) > NUM ) { int current Index = INIT COMMAND ORDER LIST . index Of ( current Step ) ; int new Index = INIT COMMAND ORDER LIST . index Of ( new Step ) ; if ( new Index != current Index && new Index - current Index > NUM ) { if ( HALT ON IMPROPER ORDER ) { set Error State ( String . format ( STRING , node . get Node Id ( ) , Z Wave Security Command Class . command To String ( current Step ) , Z Wave Security Command Class . command To String ( new Step ) ) ) ; return BOOL ; } else { logger . warn ( STRING , node . get Node Id ( ) , Z Wave Security Command Class . command To String ( current Step ) , Z Wave Security Command Class . command To String ( new Step ) ) ; } } } current Step = new Step ; return BOOL ; }
public void add Object Detail ( KML Object Detail object Detail ) { elements . add ( object Detail ) ; }
private int create Folder ( ) { if ( m New Directory Name != null && m Selected Dir != null && m Selected Dir . can Write ( ) ) { File new Dir = new File ( m Selected Dir , m New Directory Name ) ; if ( ! new Dir . exists ( ) ) { boolean result = new Dir . mkdir ( ) ; if ( result ) { change Directory ( new Dir ) ; return R . string . create folder success ; } else { return R . string . create folder error ; } } else { return R . string . create folder error already exists ; } } else if ( m Selected Dir != null && ! m Selected Dir . can Write ( ) ) { return R . string . create folder error no write access ; } else { return R . string . create folder error ; } }
public char read LE Char ( ) throws IO Exception { int byte 1 = in . read ( ) ; int byte 2 = in . read ( ) ; if ( byte 2 == - NUM ) throw new EOF Exception ( ) ; return ( char ) ( ( byte 2 << NUM ) + byte 1 ) ; }
protected void update Values ( ) { synchronized ( workers ) { if ( prev . length == curr . length ) { System . arraycopy ( curr , NUM , prev , NUM , prev . length ) ; all Threads Data data = new all Threads Data ( ) ; data . set Iterations ( curr ) ; data = read Values ( data ) ; curr = data . get Iterations ( ) ; total Response Time = data . get Total Response Times ( ) ; response Time Std Dev = data . get Response Time Std Dev ( ) ; } else { prev = curr ; all Threads Data data = new all Threads Data ( ) ; data . set Iterations ( curr ) ; data = read Values ( ( all Threads Data ) null ) ; curr = data . get Iterations ( ) ; total Response Time = data . get Total Response Times ( ) ; response Time Std Dev = data . get Response Time Std Dev ( ) ; } prev Measurement Time = curr Measurement Time ; curr Measurement Time = System . current Time Millis ( ) ; } }
protected void update Values ( ) { synchronized ( workers ) { if ( prev . length == curr . length ) { System . arraycopy ( curr , NUM , prev , NUM , prev . length ) ; all Threads Data data = new all Threads Data ( ) ; data . set Iterations ( curr ) ; data = read Values ( data ) ; curr = data . get Iterations ( ) ; total Response Time = data . get Total Response Times ( ) ; response Time Std Dev = data . get Response Time Std Dev ( ) ; } else { prev = curr ; all Threads Data data = new all Threads Data ( ) ; data . set Iterations ( curr ) ; data = read Values ( ( all Threads Data ) null ) ; curr = data . get Iterations ( ) ; total Response Time = data . get Total Response Times ( ) ; response Time Std Dev = data . get Response Time Std Dev ( ) ; } prev Measurement Time = curr Measurement Time ; curr Measurement Time = System . current Time Millis ( ) ; } }
protected void update Values ( ) { synchronized ( workers ) { if ( prev . length == curr . length ) { System . arraycopy ( curr , NUM , prev , NUM , prev . length ) ; all Threads Data data = new all Threads Data ( ) ; data . set Iterations ( curr ) ; data = read Values ( data ) ; curr = data . get Iterations ( ) ; total Response Time = data . get Total Response Times ( ) ; response Time Std Dev = data . get Response Time Std Dev ( ) ; } else { prev = curr ; all Threads Data data = new all Threads Data ( ) ; data . set Iterations ( curr ) ; data = read Values ( ( all Threads Data ) null ) ; curr = data . get Iterations ( ) ; total Response Time = data . get Total Response Times ( ) ; response Time Std Dev = data . get Response Time Std Dev ( ) ; } prev Measurement Time = curr Measurement Time ; curr Measurement Time = System . current Time Millis ( ) ; } }
protected void update Values ( ) { synchronized ( workers ) { if ( prev . length == curr . length ) { System . arraycopy ( curr , NUM , prev , NUM , prev . length ) ; all Threads Data data = new all Threads Data ( ) ; data . set Iterations ( curr ) ; data = read Values ( data ) ; curr = data . get Iterations ( ) ; total Response Time = data . get Total Response Times ( ) ; response Time Std Dev = data . get Response Time Std Dev ( ) ; } else { prev = curr ; all Threads Data data = new all Threads Data ( ) ; data . set Iterations ( curr ) ; data = read Values ( ( all Threads Data ) null ) ; curr = data . get Iterations ( ) ; total Response Time = data . get Total Response Times ( ) ; response Time Std Dev = data . get Response Time Std Dev ( ) ; } prev Measurement Time = curr Measurement Time ; curr Measurement Time = System . current Time Millis ( ) ; } }
public void add ( Symbol symbol ) { symbols . add ( symbol ) ; }
private static void percent Encoder ( final String url Element , final String Builder encoded Buffer ) { Reject . if Null ( url Element ) ; for ( int count = NUM ; count < url Element . length ( ) ; count ++ ) { final char c = url Element . char At ( count ) ; if ( VALID CHARS . contains ( c ) ) { encoded Buffer . append ( c ) ; } else { encoded Buffer . append ( PERCENT ENCODING CHAR ) ; encoded Buffer . append ( Integer . to Hex String ( c ) ) ; } } }
public boolean has Active Tasks ( ) { boolean does Have Tasks = BOOL ; synchronized ( async Tasks ) { if ( async Tasks . is Empty ( ) ) return BOOL ; Iterator < Runnable Scheduled Future < ? > > i = async Tasks . iterator ( ) ; while ( i . has Next ( ) ) { Runnable Scheduled Future < ? > task = i . next ( ) ; if ( task . is Done ( ) ) i . remove ( ) ; else does Have Tasks = BOOL ; } } return does Have Tasks ; }
public boolean has Active Tasks ( ) { boolean does Have Tasks = BOOL ; synchronized ( async Tasks ) { if ( async Tasks . is Empty ( ) ) return BOOL ; Iterator < Runnable Scheduled Future < ? > > i = async Tasks . iterator ( ) ; while ( i . has Next ( ) ) { Runnable Scheduled Future < ? > task = i . next ( ) ; if ( task . is Done ( ) ) i . remove ( ) ; else does Have Tasks = BOOL ; } } return does Have Tasks ; }
static String handle Illegal Character In Result ( final String result ) { String temp Result = result ; if ( temp Result != null && temp Result . contains ( STRING ) ) { temp Result = temp Result . replace All ( STRING , STRING ) ; } return temp Result ; }
private Web Target create Web Target ( String rest Path , Map < String , String > query Params ) { Web Target web Target ; try { URI u = new URI ( this . base URI + STRING + rest Path ) ; Client client = creater Rest Client ( ) ; web Target = client . target ( u ) ; if ( query Params != null && ! query Params . is Empty ( ) ) { for ( Map . Entry < String , String > entry : query Params . entry Set ( ) ) { if ( entry . get Key ( ) != null && entry . get Value ( ) != null ) { LOG . debug ( STRING , entry . get Key ( ) , entry . get Value ( ) ) ; web Target = web Target . query Param ( entry . get Key ( ) , entry . get Value ( ) ) ; } } } } catch ( Exception e ) { LOG . error ( STRING , e ) ; return null ; } return web Target ; }
protected void remove From Marked Position ( ) { System . arraycopy ( buffer , read pos , buffer , marked pos , read pos end - read pos ) ; read pos end -= ( read pos - marked pos ) ; read pos = marked pos ; }
protected void remove From Marked Position ( ) { System . arraycopy ( buffer , read pos , buffer , marked pos , read pos end - read pos ) ; read pos end -= ( read pos - marked pos ) ; read pos = marked pos ; }
protected void remove From Marked Position ( ) { System . arraycopy ( buffer , read pos , buffer , marked pos , read pos end - read pos ) ; read pos end -= ( read pos - marked pos ) ; read pos = marked pos ; }
public void add Workspace Component Listener ( final Workspace Component Listener listener ) { workspace Component Listeners . add ( listener ) ; }
public static double heap Size ( Iterable < Cluster Node > nodes , int precision ) { double heap = NUM ; for ( Cluster Node n : nodes Per Jvm ( nodes ) ) { Cluster Metrics m = n . metrics ( ) ; heap += Math . max ( m . get Heap Memory Initialized ( ) , m . get Heap Memory Maximum ( ) ) ; } return rounded Heap Size ( heap , precision ) ; }
public void generate ( Batch Environment env , Class Definition cdef , File dest Dir ) { Remote Class remote Class = Remote Class . for Class ( env , cdef ) ; if ( remote Class == null ) return ; RMI Generator gen ; try { gen = new RMI Generator ( env , cdef , dest Dir , remote Class , version ) ; } catch ( Class Not Found e ) { env . error ( NUM , STRING , e . name ) ; return ; } gen . generate ( ) ; }
@ Override public synchronized void close ( ) throws IO Exception { buffer = null ; is Closed = BOOL ; notify All ( ) ; }
@ Override public synchronized void close ( ) throws IO Exception { buffer = null ; is Closed = BOOL ; notify All ( ) ; }
@ Override public synchronized void close ( ) throws IO Exception { buffer = null ; is Closed = BOOL ; notify All ( ) ; }
@ Override public synchronized void close ( ) throws IO Exception { buffer = null ; is Closed = BOOL ; notify All ( ) ; }
private void write ( Coordinate [ ] coords , Writer writer , int level ) throws IO Exception { start Line ( level , writer ) ; start Geom Tag ( GML Constants . GML COORDINATES , null , writer ) ; int dim = NUM ; if ( coords . length > NUM ) { if ( ! ( Double . is Na N ( coords [ NUM ] . z ) ) ) dim = NUM ; } boolean is New Line = BOOL ; for ( int i = NUM ; i < coords . length ; i ++ ) { if ( is New Line ) { start Line ( level + NUM , writer ) ; is New Line = BOOL ; } if ( dim == NUM ) { writer . write ( STRING + coords [ i ] . x ) ; writer . write ( coordinate Separator ) ; writer . write ( STRING + coords [ i ] . y ) ; } else if ( dim == NUM ) { writer . write ( STRING + coords [ i ] . x ) ; writer . write ( coordinate Separator ) ; writer . write ( STRING + coords [ i ] . y ) ; writer . write ( coordinate Separator ) ; writer . write ( STRING + coords [ i ] . z ) ; } writer . write ( tuple Separator ) ; if ( ( i + NUM ) % max Coordinates Per Line == NUM && i < coords . length - NUM ) { writer . write ( STRING ) ; is New Line = BOOL ; } } if ( ! is New Line ) writer . write ( STRING ) ; start Line ( level , writer ) ; end Geom Tag ( GML Constants . GML COORDINATES , writer ) ; }
public static String serialise ( Node node ) { try { DOM Implementation Registry registry = DOM Implementation Registry . new Instance ( ) ; DOM Implementation LS ls Impl = ( DOM Implementation LS ) registry . get DOM Implementation ( STRING ) ; LS Serializer serializer = ls Impl . create LS Serializer ( ) ; return serializer . write To String ( node ) ; } catch ( Exception e ) { log . fine ( STRING + e ) ; return STRING ; } }
public void add Attribute ( Attribute attribute ) { regular Attributes . add ( attribute ) ; }
public void add Attribute ( Attribute attribute ) { regular Attributes . add ( attribute ) ; }
public J Run 4 x Configuration Builder ( ) { try { Document Builder Factory dom Factory = Document Builder Factory . new Instance ( ) ; builder = dom Factory . new Document Builder ( ) ; } catch ( Exception e ) { throw new Cargo Exception ( STRING , e ) ; } }
public Byte Buffer put ( byte [ ] src , int src Offset , int byte Count ) { J Transc Arrays . check Offset And Count ( src . length , src Offset , byte Count ) ; if ( byte Count > remaining ( ) ) { throw new Buffer Overflow Exception ( ) ; } for ( int i = src Offset ; i < src Offset + byte Count ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public Byte Buffer put ( byte [ ] src , int src Offset , int byte Count ) { J Transc Arrays . check Offset And Count ( src . length , src Offset , byte Count ) ; if ( byte Count > remaining ( ) ) { throw new Buffer Overflow Exception ( ) ; } for ( int i = src Offset ; i < src Offset + byte Count ; ++ i ) { put ( src [ i ] ) ; } return this ; }
default String resource Name ( String table Name , String type ) { return String . format ( RESOURCE NAME , table Name , type ) ; }
public void init ( ) { if ( ! initialized ) { super . init ( ) ; detect Panel = new Detection Panel ( this ) ; J Panel panel = new J Panel ( ) ; panel . set Layout ( new Box Layout ( panel , Box Layout . Y AXIS ) ) ; panel . add ( Box . create Vertical Glue ( ) ) ; panel . add ( detect Panel ) ; add ( panel , NUM ) ; } }
private void copy AC Ls ( List < Un Managed Cifs Share ACL > orig ACL List , List < Cifs Share ACL > share ACL List , File Share fileshare ) { Cifs Share ACL share ACL = null ; for ( Un Managed Cifs Share ACL orig ACL : orig ACL List ) { share ACL = new Cifs Share ACL ( ) ; share ACL . set Id ( URI Util . create Id ( Cifs Share ACL . class ) ) ; share ACL . set User ( orig ACL . get User ( ) ) ; share ACL . set Permission ( orig ACL . get Permission ( ) ) ; share ACL . set Share Name ( orig ACL . get Share Name ( ) ) ; share ACL . set File System Id ( fileshare . get Id ( ) ) ; share ACL List . add ( share ACL ) ; logger . info ( STRING , share ACL . to String ( ) ) ; } }
private void copy AC Ls ( List < Un Managed Cifs Share ACL > orig ACL List , List < Cifs Share ACL > share ACL List , File Share fileshare ) { Cifs Share ACL share ACL = null ; for ( Un Managed Cifs Share ACL orig ACL : orig ACL List ) { share ACL = new Cifs Share ACL ( ) ; share ACL . set Id ( URI Util . create Id ( Cifs Share ACL . class ) ) ; share ACL . set User ( orig ACL . get User ( ) ) ; share ACL . set Permission ( orig ACL . get Permission ( ) ) ; share ACL . set Share Name ( orig ACL . get Share Name ( ) ) ; share ACL . set File System Id ( fileshare . get Id ( ) ) ; share ACL List . add ( share ACL ) ; logger . info ( STRING , share ACL . to String ( ) ) ; } }
public void ensure Additional Capacity ( final int size ) { final int new Count = visible . position ( ) + size ; if ( new Count > visible . capacity ( ) ) { final Byte Buffer new Byte Buffer = Byte Buffer . allocate ( Math . max ( visible . capacity ( ) << NUM , new Count ) ) ; visible . flip ( ) ; visible = new Byte Buffer . put ( visible ) ; } }
public void ensure Additional Capacity ( final int size ) { final int new Count = visible . position ( ) + size ; if ( new Count > visible . capacity ( ) ) { final Byte Buffer new Byte Buffer = Byte Buffer . allocate ( Math . max ( visible . capacity ( ) << NUM , new Count ) ) ; visible . flip ( ) ; visible = new Byte Buffer . put ( visible ) ; } }
public URI ( String p scheme , String p host , String p path , String p query String , String p fragment ) throws Malformed URI Exception { this ( p scheme , null , p host , - NUM , p path , p query String , p fragment ) ; }
public URI ( String p scheme , String p host , String p path , String p query String , String p fragment ) throws Malformed URI Exception { this ( p scheme , null , p host , - NUM , p path , p query String , p fragment ) ; }
public Jdk 14 Logger ( String name ) { this . jdk Logger = Logger . get Logger ( name ) ; }
public static Color derive With Alpha ( Color color , int alpha ) { return new Color ( color . get Red ( ) , color . get Green ( ) , color . get Blue ( ) , alpha ) ; }
public void paint Component ( Graphics g ) { int x = PADDING ; int y = PADDING ; g . draw Image ( picture , x , y , scale W , scale H , null ) ; x += scale W + PADDING ; g . draw Image ( picture , x , y , x + scale W , y + scale H , NUM , NUM , picture . get Width ( ) , picture . get Height ( ) , null ) ; x += scale W + PADDING ; Graphics 2 D g2 d = ( Graphics 2 D ) g . create ( ) ; g2 d . translate ( x , y ) ; g2 d . scale ( SCALE FACTOR , SCALE FACTOR ) ; g2 d . draw Image ( picture , NUM , NUM , null ) ; g2 d . dispose ( ) ; x += scale W + PADDING ; g2 d = ( Graphics 2 D ) g . create ( ) ; Affine Transform at = new Affine Transform ( ) ; at . translate ( x , y ) ; at . scale ( SCALE FACTOR , SCALE FACTOR ) ; g2 d . draw Image ( picture , at , null ) ; g2 d . dispose ( ) ; x += scale W + PADDING ; Image scaled Img = picture . get Scaled Instance ( scale W , scale H , Image . SCALE DEFAULT ) ; g . draw Image ( scaled Img , x , y , null ) ; }
public void paint Component ( Graphics g ) { int x = PADDING ; int y = PADDING ; g . draw Image ( picture , x , y , scale W , scale H , null ) ; x += scale W + PADDING ; g . draw Image ( picture , x , y , x + scale W , y + scale H , NUM , NUM , picture . get Width ( ) , picture . get Height ( ) , null ) ; x += scale W + PADDING ; Graphics 2 D g2 d = ( Graphics 2 D ) g . create ( ) ; g2 d . translate ( x , y ) ; g2 d . scale ( SCALE FACTOR , SCALE FACTOR ) ; g2 d . draw Image ( picture , NUM , NUM , null ) ; g2 d . dispose ( ) ; x += scale W + PADDING ; g2 d = ( Graphics 2 D ) g . create ( ) ; Affine Transform at = new Affine Transform ( ) ; at . translate ( x , y ) ; at . scale ( SCALE FACTOR , SCALE FACTOR ) ; g2 d . draw Image ( picture , at , null ) ; g2 d . dispose ( ) ; x += scale W + PADDING ; Image scaled Img = picture . get Scaled Instance ( scale W , scale H , Image . SCALE DEFAULT ) ; g . draw Image ( scaled Img , x , y , null ) ; }
public void paint Component ( Graphics g ) { int x = PADDING ; int y = PADDING ; g . draw Image ( picture , x , y , scale W , scale H , null ) ; x += scale W + PADDING ; g . draw Image ( picture , x , y , x + scale W , y + scale H , NUM , NUM , picture . get Width ( ) , picture . get Height ( ) , null ) ; x += scale W + PADDING ; Graphics 2 D g2 d = ( Graphics 2 D ) g . create ( ) ; g2 d . translate ( x , y ) ; g2 d . scale ( SCALE FACTOR , SCALE FACTOR ) ; g2 d . draw Image ( picture , NUM , NUM , null ) ; g2 d . dispose ( ) ; x += scale W + PADDING ; g2 d = ( Graphics 2 D ) g . create ( ) ; Affine Transform at = new Affine Transform ( ) ; at . translate ( x , y ) ; at . scale ( SCALE FACTOR , SCALE FACTOR ) ; g2 d . draw Image ( picture , at , null ) ; g2 d . dispose ( ) ; x += scale W + PADDING ; Image scaled Img = picture . get Scaled Instance ( scale W , scale H , Image . SCALE DEFAULT ) ; g . draw Image ( scaled Img , x , y , null ) ; }
public void paint Component ( Graphics g ) { int x = PADDING ; int y = PADDING ; g . draw Image ( picture , x , y , scale W , scale H , null ) ; x += scale W + PADDING ; g . draw Image ( picture , x , y , x + scale W , y + scale H , NUM , NUM , picture . get Width ( ) , picture . get Height ( ) , null ) ; x += scale W + PADDING ; Graphics 2 D g2 d = ( Graphics 2 D ) g . create ( ) ; g2 d . translate ( x , y ) ; g2 d . scale ( SCALE FACTOR , SCALE FACTOR ) ; g2 d . draw Image ( picture , NUM , NUM , null ) ; g2 d . dispose ( ) ; x += scale W + PADDING ; g2 d = ( Graphics 2 D ) g . create ( ) ; Affine Transform at = new Affine Transform ( ) ; at . translate ( x , y ) ; at . scale ( SCALE FACTOR , SCALE FACTOR ) ; g2 d . draw Image ( picture , at , null ) ; g2 d . dispose ( ) ; x += scale W + PADDING ; Image scaled Img = picture . get Scaled Instance ( scale W , scale H , Image . SCALE DEFAULT ) ; g . draw Image ( scaled Img , x , y , null ) ; }
public void paint Component ( Graphics g ) { int x = PADDING ; int y = PADDING ; g . draw Image ( picture , x , y , scale W , scale H , null ) ; x += scale W + PADDING ; g . draw Image ( picture , x , y , x + scale W , y + scale H , NUM , NUM , picture . get Width ( ) , picture . get Height ( ) , null ) ; x += scale W + PADDING ; Graphics 2 D g2 d = ( Graphics 2 D ) g . create ( ) ; g2 d . translate ( x , y ) ; g2 d . scale ( SCALE FACTOR , SCALE FACTOR ) ; g2 d . draw Image ( picture , NUM , NUM , null ) ; g2 d . dispose ( ) ; x += scale W + PADDING ; g2 d = ( Graphics 2 D ) g . create ( ) ; Affine Transform at = new Affine Transform ( ) ; at . translate ( x , y ) ; at . scale ( SCALE FACTOR , SCALE FACTOR ) ; g2 d . draw Image ( picture , at , null ) ; g2 d . dispose ( ) ; x += scale W + PADDING ; Image scaled Img = picture . get Scaled Instance ( scale W , scale H , Image . SCALE DEFAULT ) ; g . draw Image ( scaled Img , x , y , null ) ; }
public void paint Component ( Graphics g ) { int x = PADDING ; int y = PADDING ; g . draw Image ( picture , x , y , scale W , scale H , null ) ; x += scale W + PADDING ; g . draw Image ( picture , x , y , x + scale W , y + scale H , NUM , NUM , picture . get Width ( ) , picture . get Height ( ) , null ) ; x += scale W + PADDING ; Graphics 2 D g2 d = ( Graphics 2 D ) g . create ( ) ; g2 d . translate ( x , y ) ; g2 d . scale ( SCALE FACTOR , SCALE FACTOR ) ; g2 d . draw Image ( picture , NUM , NUM , null ) ; g2 d . dispose ( ) ; x += scale W + PADDING ; g2 d = ( Graphics 2 D ) g . create ( ) ; Affine Transform at = new Affine Transform ( ) ; at . translate ( x , y ) ; at . scale ( SCALE FACTOR , SCALE FACTOR ) ; g2 d . draw Image ( picture , at , null ) ; g2 d . dispose ( ) ; x += scale W + PADDING ; Image scaled Img = picture . get Scaled Instance ( scale W , scale H , Image . SCALE DEFAULT ) ; g . draw Image ( scaled Img , x , y , null ) ; }
public void paint Component ( Graphics g ) { int x = PADDING ; int y = PADDING ; g . draw Image ( picture , x , y , scale W , scale H , null ) ; x += scale W + PADDING ; g . draw Image ( picture , x , y , x + scale W , y + scale H , NUM , NUM , picture . get Width ( ) , picture . get Height ( ) , null ) ; x += scale W + PADDING ; Graphics 2 D g2 d = ( Graphics 2 D ) g . create ( ) ; g2 d . translate ( x , y ) ; g2 d . scale ( SCALE FACTOR , SCALE FACTOR ) ; g2 d . draw Image ( picture , NUM , NUM , null ) ; g2 d . dispose ( ) ; x += scale W + PADDING ; g2 d = ( Graphics 2 D ) g . create ( ) ; Affine Transform at = new Affine Transform ( ) ; at . translate ( x , y ) ; at . scale ( SCALE FACTOR , SCALE FACTOR ) ; g2 d . draw Image ( picture , at , null ) ; g2 d . dispose ( ) ; x += scale W + PADDING ; Image scaled Img = picture . get Scaled Instance ( scale W , scale H , Image . SCALE DEFAULT ) ; g . draw Image ( scaled Img , x , y , null ) ; }
public static Element [ ] add Element ( Element element , Element ... elements ) { Element [ ] new Elements = new Element [ elements . length + NUM ] ; new Elements [ NUM ] = element ; System . arraycopy ( elements , NUM , new Elements , NUM , elements . length ) ; return new Elements ; }
public static Element [ ] add Element ( Element element , Element ... elements ) { Element [ ] new Elements = new Element [ elements . length + NUM ] ; new Elements [ NUM ] = element ; System . arraycopy ( elements , NUM , new Elements , NUM , elements . length ) ; return new Elements ; }
public void test Compute Classpath For Simple Project ( ) throws Core Exception { add And Create Source Entry ( java Project A , SRC DIR NAME , null ) ; List < File > actual Cp = get List Of Files ( GWT Compile Runner . compute Classpath ( java Project A ) ) ; List < File > expected Cp = new Array List < File > ( ) ; expected Cp . add ( get File ( java Project A . get Project ( ) , SRC DIR NAME ) ) ; expected Cp . add ( get Output Of Project ( java Project A ) ) ; assert Equals ( expected Cp , actual Cp ) ; }
public static Temp Path create File ( ) throws IO Exception { return wrap ( Files . create Temp File ( PREFIX , SUFFIX ) ) ; }
public static Temp Path create File ( ) throws IO Exception { return wrap ( Files . create Temp File ( PREFIX , SUFFIX ) ) ; }
public final int update And Get ( Int Unary Operator update Function ) { int prev , next ; do { prev = get ( ) ; next = update Function . apply As Int ( prev ) ; } while ( ! compare And Set ( prev , next ) ) ; return next ; }
public final int update And Get ( Int Unary Operator update Function ) { int prev , next ; do { prev = get ( ) ; next = update Function . apply As Int ( prev ) ; } while ( ! compare And Set ( prev , next ) ) ; return next ; }
public final int update And Get ( Int Unary Operator update Function ) { int prev , next ; do { prev = get ( ) ; next = update Function . apply As Int ( prev ) ; } while ( ! compare And Set ( prev , next ) ) ; return next ; }
public final int update And Get ( Int Unary Operator update Function ) { int prev , next ; do { prev = get ( ) ; next = update Function . apply As Int ( prev ) ; } while ( ! compare And Set ( prev , next ) ) ; return next ; }
public void add Common Header ( ) { add Line ( VERSION LINE ) ; final Calendar cal = Calendar . get Instance ( ) ; final Simple Date Format sdf = new Simple Date Format ( STRING ) ; add Line ( META STRING + STRING + sdf . format ( cal . get Time ( ) ) ) ; add Line ( META STRING + STRING + Environment . get Version ( ) ) ; add Run Info ( ) ; }
public void add Common Header ( ) { add Line ( VERSION LINE ) ; final Calendar cal = Calendar . get Instance ( ) ; final Simple Date Format sdf = new Simple Date Format ( STRING ) ; add Line ( META STRING + STRING + sdf . format ( cal . get Time ( ) ) ) ; add Line ( META STRING + STRING + Environment . get Version ( ) ) ; add Run Info ( ) ; }
public void add Common Header ( ) { add Line ( VERSION LINE ) ; final Calendar cal = Calendar . get Instance ( ) ; final Simple Date Format sdf = new Simple Date Format ( STRING ) ; add Line ( META STRING + STRING + sdf . format ( cal . get Time ( ) ) ) ; add Line ( META STRING + STRING + Environment . get Version ( ) ) ; add Run Info ( ) ; }
public void generate Random Network ( ) throws Exception { if ( m other Bayes Net == null ) { Init ( m n Nr Of Nodes , m n Cardinality ) ; generate Random Network Structure ( m n Nr Of Nodes , m n Nr Of Arcs ) ; generate Random Distributions ( m n Nr Of Nodes , m n Cardinality ) ; } else { m n Nr Of Nodes = m other Bayes Net . get Nr Of Nodes ( ) ; m Parent Sets = m other Bayes Net . get Parent Sets ( ) ; m Distributions = m other Bayes Net . get Distributions ( ) ; random = new Random ( m n Seed ) ; Array List < Attribute > att Info = new Array List < Attribute > ( m n Nr Of Nodes ) ; for ( int i Node = NUM ; i Node < m n Nr Of Nodes ; i Node ++ ) { int n Values = m other Bayes Net . get Cardinality ( i Node ) ; Array List < String > nom Strings = new Array List < String > ( n Values + NUM ) ; for ( int i Value = NUM ; i Value < n Values ; i Value ++ ) { nom Strings . add ( m other Bayes Net . get Node Value ( i Node , i Value ) ) ; } Attribute att = new Attribute ( m other Bayes Net . get Node Name ( i Node ) , nom Strings ) ; att Info . add ( att ) ; } m Instances = new Instances ( m other Bayes Net . get Name ( ) , att Info , NUM ) ; m Instances . set Class Index ( m n Nr Of Nodes - NUM ) ; } }
public void generate Random Network ( ) throws Exception { if ( m other Bayes Net == null ) { Init ( m n Nr Of Nodes , m n Cardinality ) ; generate Random Network Structure ( m n Nr Of Nodes , m n Nr Of Arcs ) ; generate Random Distributions ( m n Nr Of Nodes , m n Cardinality ) ; } else { m n Nr Of Nodes = m other Bayes Net . get Nr Of Nodes ( ) ; m Parent Sets = m other Bayes Net . get Parent Sets ( ) ; m Distributions = m other Bayes Net . get Distributions ( ) ; random = new Random ( m n Seed ) ; Array List < Attribute > att Info = new Array List < Attribute > ( m n Nr Of Nodes ) ; for ( int i Node = NUM ; i Node < m n Nr Of Nodes ; i Node ++ ) { int n Values = m other Bayes Net . get Cardinality ( i Node ) ; Array List < String > nom Strings = new Array List < String > ( n Values + NUM ) ; for ( int i Value = NUM ; i Value < n Values ; i Value ++ ) { nom Strings . add ( m other Bayes Net . get Node Value ( i Node , i Value ) ) ; } Attribute att = new Attribute ( m other Bayes Net . get Node Name ( i Node ) , nom Strings ) ; att Info . add ( att ) ; } m Instances = new Instances ( m other Bayes Net . get Name ( ) , att Info , NUM ) ; m Instances . set Class Index ( m n Nr Of Nodes - NUM ) ; } }
@ Override @ Transactional public void logout ( Http Servlet Request request , Http Servlet Response response , Authentication authentication ) { String remember Me Cookie = extract Remember Me Cookie ( request ) ; if ( remember Me Cookie != null && remember Me Cookie . length ( ) != NUM ) { try { String [ ] cookie Tokens = decode Cookie ( remember Me Cookie ) ; Persistent Token token = get Persistent Token ( cookie Tokens ) ; persistent Token Repository . delete ( token ) ; } catch ( Invalid Cookie Exception ice ) { log . info ( STRING ) ; } catch ( Remember Me Authentication Exception rmae ) { log . debug ( STRING ) ; } } super . logout ( request , response , authentication ) ; }
@ Override @ Transactional public void logout ( Http Servlet Request request , Http Servlet Response response , Authentication authentication ) { String remember Me Cookie = extract Remember Me Cookie ( request ) ; if ( remember Me Cookie != null && remember Me Cookie . length ( ) != NUM ) { try { String [ ] cookie Tokens = decode Cookie ( remember Me Cookie ) ; Persistent Token token = get Persistent Token ( cookie Tokens ) ; persistent Token Repository . delete ( token ) ; } catch ( Invalid Cookie Exception ice ) { log . info ( STRING ) ; } catch ( Remember Me Authentication Exception rmae ) { log . debug ( STRING ) ; } } super . logout ( request , response , authentication ) ; }
@ Override @ Transactional public void logout ( Http Servlet Request request , Http Servlet Response response , Authentication authentication ) { String remember Me Cookie = extract Remember Me Cookie ( request ) ; if ( remember Me Cookie != null && remember Me Cookie . length ( ) != NUM ) { try { String [ ] cookie Tokens = decode Cookie ( remember Me Cookie ) ; Persistent Token token = get Persistent Token ( cookie Tokens ) ; persistent Token Repository . delete ( token ) ; } catch ( Invalid Cookie Exception ice ) { log . info ( STRING ) ; } catch ( Remember Me Authentication Exception rmae ) { log . debug ( STRING ) ; } } super . logout ( request , response , authentication ) ; }
@ Override @ Transactional public void logout ( Http Servlet Request request , Http Servlet Response response , Authentication authentication ) { String remember Me Cookie = extract Remember Me Cookie ( request ) ; if ( remember Me Cookie != null && remember Me Cookie . length ( ) != NUM ) { try { String [ ] cookie Tokens = decode Cookie ( remember Me Cookie ) ; Persistent Token token = get Persistent Token ( cookie Tokens ) ; persistent Token Repository . delete ( token ) ; } catch ( Invalid Cookie Exception ice ) { log . info ( STRING ) ; } catch ( Remember Me Authentication Exception rmae ) { log . debug ( STRING ) ; } } super . logout ( request , response , authentication ) ; }
private static void write Dng Bytes And Close ( Image image , Total Capture Result capture Result , Camera Characteristics characteristics , File dng File ) { try ( Dng Creator dng Creator = new Dng Creator ( characteristics , capture Result ) ; File Output Stream output Stream = new File Output Stream ( dng File ) ) { dng Creator . write Image ( output Stream , image ) ; output Stream . close ( ) ; image . close ( ) ; } catch ( IO Exception e ) { Log . e ( TAG , STRING , e ) ; return ; } Log . i ( TAG , STRING + dng File . get Absolute Path ( ) ) ; }
public static Spannable create Spannable From Text With Template ( String text , Char Sequence inner Template ) { Spannable String result = new Spannable String ( text ) ; if ( inner Template instanceof Spanned ) { int index = text . index Of ( inner Template . to String ( ) ) ; if ( index >= NUM ) { copy Spans ( result , ( Spanned ) inner Template , index ) ; } } return result ; }
public static Spannable create Spannable From Text With Template ( String text , Char Sequence inner Template ) { Spannable String result = new Spannable String ( text ) ; if ( inner Template instanceof Spanned ) { int index = text . index Of ( inner Template . to String ( ) ) ; if ( index >= NUM ) { copy Spans ( result , ( Spanned ) inner Template , index ) ; } } return result ; }
public static Spannable create Spannable From Text With Template ( String text , Char Sequence inner Template ) { Spannable String result = new Spannable String ( text ) ; if ( inner Template instanceof Spanned ) { int index = text . index Of ( inner Template . to String ( ) ) ; if ( index >= NUM ) { copy Spans ( result , ( Spanned ) inner Template , index ) ; } } return result ; }
@ Override public Enter From Date To To Date Activity . Time Object add ( long time , int val ) { Calendar c = Calendar . get Instance ( ) ; c . set Time In Millis ( time ) ; c . add ( Calendar . MONTH , val ) ; return time Object From Calendar ( c ) ; }
public void acquire ( ) { int n = ref Count . increment And Get ( ) ; }
void set Text ( byte [ ] text ) { this . text = text ; this . props = null ; }
private void kick Off ( Team offense ) { if ( game Time <= NUM ) return ; else { if ( game Time < NUM && ( ( game Poss && ( away Score - home Score ) <= NUM && ( away Score - home Score ) > NUM ) || ( ! game Poss && ( home Score - away Score ) <= NUM && ( home Score - away Score ) > NUM ) ) ) { if ( offense . get K ( NUM ) . rat Kick Fum * Math . random ( ) > NUM || Math . random ( ) < NUM ) { game Event Log += get Event Prefix ( ) + offense . abbr + STRING + offense . get K ( NUM ) . name + STRING + offense . abbr + STRING ; } else { game Event Log += get Event Prefix ( ) + offense . abbr + STRING + offense . get K ( NUM ) . name + STRING ; game Poss = ! game Poss ; } game Yard Line = NUM ; game Down = NUM ; game Yards Need = NUM ; game Time -= NUM + NUM * Math . random ( ) ; } else { game Yard Line = ( int ) ( NUM - ( offense . get K ( NUM ) . rat Kick Pow + NUM - NUM * Math . random ( ) ) ) ; if ( game Yard Line <= NUM ) game Yard Line = NUM ; game Down = NUM ; game Yards Need = NUM ; game Poss = ! game Poss ; } game Time -= NUM * Math . random ( ) ; } }
private void kick Off ( Team offense ) { if ( game Time <= NUM ) return ; else { if ( game Time < NUM && ( ( game Poss && ( away Score - home Score ) <= NUM && ( away Score - home Score ) > NUM ) || ( ! game Poss && ( home Score - away Score ) <= NUM && ( home Score - away Score ) > NUM ) ) ) { if ( offense . get K ( NUM ) . rat Kick Fum * Math . random ( ) > NUM || Math . random ( ) < NUM ) { game Event Log += get Event Prefix ( ) + offense . abbr + STRING + offense . get K ( NUM ) . name + STRING + offense . abbr + STRING ; } else { game Event Log += get Event Prefix ( ) + offense . abbr + STRING + offense . get K ( NUM ) . name + STRING ; game Poss = ! game Poss ; } game Yard Line = NUM ; game Down = NUM ; game Yards Need = NUM ; game Time -= NUM + NUM * Math . random ( ) ; } else { game Yard Line = ( int ) ( NUM - ( offense . get K ( NUM ) . rat Kick Pow + NUM - NUM * Math . random ( ) ) ) ; if ( game Yard Line <= NUM ) game Yard Line = NUM ; game Down = NUM ; game Yards Need = NUM ; game Poss = ! game Poss ; } game Time -= NUM * Math . random ( ) ; } }
private void shrink Value Set ( int max Size ) { if ( value Set != null ) { if ( value Set . size ( ) > max Size ) { Set < String > new Set = new Tree Set < String > ( ) ; Iterator < String > i = value Set . iterator ( ) ; int count = NUM ; while ( i . has Next ( ) && count < max Size ) { new Set . add ( i . next ( ) ) ; count ++ ; } this . value Set = new Set ; value Set Relation = value Set Relation . merge ( Set Relation . SUPERSET ) ; if ( owner != null ) { owner . set Nominal Data Was Shrinked ( BOOL ) ; } } } }
public static void put Char LE ( long addr , char val ) { if ( UNALIGNED ) UNSAFE . put Char ( addr , Character . reverse Bytes ( val ) ) ; else put Char By Byte ( addr , val , BOOL ) ; }
public Http Request content Length ( final int value ) { connection . set Fixed Length Streaming Mode ( value ) ; return this ; }
protected void purge ( ) { Reference reference = queue . poll ( ) ; while ( reference != null ) { purge ( reference ) ; reference = queue . poll ( ) ; } }
protected void purge ( ) { Reference reference = queue . poll ( ) ; while ( reference != null ) { purge ( reference ) ; reference = queue . poll ( ) ; } }
public D Issuer Alternative Name ( J Dialog parent ) { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; }
public String phonemise ( String text , String pos , String Builder g2 p Method ) { String result = userdict Lookup ( text , pos ) ; if ( result != null ) { g2 p Method . append ( STRING ) ; return result ; } result = lexicon Lookup ( text , pos ) ; if ( result != null ) { g2 p Method . append ( STRING ) ; return result ; } String normalised = Mary Utils . normalise Unicode Letters ( text , get Locale ( ) ) ; if ( ! normalised . equals ( text ) ) { result = userdict Lookup ( normalised , pos ) ; if ( result != null ) { g2 p Method . append ( STRING ) ; return result ; } result = lexicon Lookup ( normalised , pos ) ; if ( result != null ) { g2 p Method . append ( STRING ) ; return result ; } } String phones = lts . predict Pronunciation ( text ) ; result = lts . syllabify ( phones ) ; if ( result != null ) { g2 p Method . append ( STRING ) ; return result ; } return null ; }
@ Request Mapping ( value = STRING , method = Request Method . DELETE ) @ Response Body public Rest Wrapper delete ( @ Path Variable ( STRING ) Integer workflow Id , Principal principal ) { Rest Wrapper rest Wrapper = null ; try { workflow Type DAO . delete ( workflow Id ) ; rest Wrapper = new Rest Wrapper ( null , Rest Wrapper . OK ) ; LOGGER . info ( STRING + workflow Id + STRING + principal . get Name ( ) ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
@ Request Mapping ( value = STRING , method = Request Method . DELETE ) @ Response Body public Rest Wrapper delete ( @ Path Variable ( STRING ) Integer workflow Id , Principal principal ) { Rest Wrapper rest Wrapper = null ; try { workflow Type DAO . delete ( workflow Id ) ; rest Wrapper = new Rest Wrapper ( null , Rest Wrapper . OK ) ; LOGGER . info ( STRING + workflow Id + STRING + principal . get Name ( ) ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
protected abstract void body ( ) throws Interrupted Exception , Ignite Interrupted Checked Exception ;
protected abstract void body ( ) throws Interrupted Exception , Ignite Interrupted Checked Exception ;
private Visor Node Suppressed Errors Job ( Map < UUID , Long > arg , boolean debug ) { super ( arg , debug ) ; }
protected Size Requirements calculate Minor Axis Requirements ( int axis , Size Requirements r ) { long min = NUM ; long pref = NUM ; long max = NUM ; multi Row Cells = BOOL ; int n = get View Count ( ) ; for ( int i = NUM ; i < n ; i ++ ) { View v = get View ( i ) ; if ( get Rows Occupied ( v ) > NUM ) { multi Row Cells = BOOL ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . get Minimum Span ( axis ) , min ) ; pref = Math . max ( ( int ) v . get Preferred Span ( axis ) , pref ) ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } } if ( r == null ) { r = new Size Requirements ( ) ; r . alignment = NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected Size Requirements calculate Minor Axis Requirements ( int axis , Size Requirements r ) { long min = NUM ; long pref = NUM ; long max = NUM ; multi Row Cells = BOOL ; int n = get View Count ( ) ; for ( int i = NUM ; i < n ; i ++ ) { View v = get View ( i ) ; if ( get Rows Occupied ( v ) > NUM ) { multi Row Cells = BOOL ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . get Minimum Span ( axis ) , min ) ; pref = Math . max ( ( int ) v . get Preferred Span ( axis ) , pref ) ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } } if ( r == null ) { r = new Size Requirements ( ) ; r . alignment = NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected Size Requirements calculate Minor Axis Requirements ( int axis , Size Requirements r ) { long min = NUM ; long pref = NUM ; long max = NUM ; multi Row Cells = BOOL ; int n = get View Count ( ) ; for ( int i = NUM ; i < n ; i ++ ) { View v = get View ( i ) ; if ( get Rows Occupied ( v ) > NUM ) { multi Row Cells = BOOL ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . get Minimum Span ( axis ) , min ) ; pref = Math . max ( ( int ) v . get Preferred Span ( axis ) , pref ) ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } } if ( r == null ) { r = new Size Requirements ( ) ; r . alignment = NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected Size Requirements calculate Minor Axis Requirements ( int axis , Size Requirements r ) { long min = NUM ; long pref = NUM ; long max = NUM ; multi Row Cells = BOOL ; int n = get View Count ( ) ; for ( int i = NUM ; i < n ; i ++ ) { View v = get View ( i ) ; if ( get Rows Occupied ( v ) > NUM ) { multi Row Cells = BOOL ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . get Minimum Span ( axis ) , min ) ; pref = Math . max ( ( int ) v . get Preferred Span ( axis ) , pref ) ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } } if ( r == null ) { r = new Size Requirements ( ) ; r . alignment = NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected Size Requirements calculate Minor Axis Requirements ( int axis , Size Requirements r ) { long min = NUM ; long pref = NUM ; long max = NUM ; multi Row Cells = BOOL ; int n = get View Count ( ) ; for ( int i = NUM ; i < n ; i ++ ) { View v = get View ( i ) ; if ( get Rows Occupied ( v ) > NUM ) { multi Row Cells = BOOL ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . get Minimum Span ( axis ) , min ) ; pref = Math . max ( ( int ) v . get Preferred Span ( axis ) , pref ) ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } } if ( r == null ) { r = new Size Requirements ( ) ; r . alignment = NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected Size Requirements calculate Minor Axis Requirements ( int axis , Size Requirements r ) { long min = NUM ; long pref = NUM ; long max = NUM ; multi Row Cells = BOOL ; int n = get View Count ( ) ; for ( int i = NUM ; i < n ; i ++ ) { View v = get View ( i ) ; if ( get Rows Occupied ( v ) > NUM ) { multi Row Cells = BOOL ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . get Minimum Span ( axis ) , min ) ; pref = Math . max ( ( int ) v . get Preferred Span ( axis ) , pref ) ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } } if ( r == null ) { r = new Size Requirements ( ) ; r . alignment = NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected Size Requirements calculate Minor Axis Requirements ( int axis , Size Requirements r ) { long min = NUM ; long pref = NUM ; long max = NUM ; multi Row Cells = BOOL ; int n = get View Count ( ) ; for ( int i = NUM ; i < n ; i ++ ) { View v = get View ( i ) ; if ( get Rows Occupied ( v ) > NUM ) { multi Row Cells = BOOL ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . get Minimum Span ( axis ) , min ) ; pref = Math . max ( ( int ) v . get Preferred Span ( axis ) , pref ) ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } } if ( r == null ) { r = new Size Requirements ( ) ; r . alignment = NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected Size Requirements calculate Minor Axis Requirements ( int axis , Size Requirements r ) { long min = NUM ; long pref = NUM ; long max = NUM ; multi Row Cells = BOOL ; int n = get View Count ( ) ; for ( int i = NUM ; i < n ; i ++ ) { View v = get View ( i ) ; if ( get Rows Occupied ( v ) > NUM ) { multi Row Cells = BOOL ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . get Minimum Span ( axis ) , min ) ; pref = Math . max ( ( int ) v . get Preferred Span ( axis ) , pref ) ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } } if ( r == null ) { r = new Size Requirements ( ) ; r . alignment = NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected Size Requirements calculate Minor Axis Requirements ( int axis , Size Requirements r ) { long min = NUM ; long pref = NUM ; long max = NUM ; multi Row Cells = BOOL ; int n = get View Count ( ) ; for ( int i = NUM ; i < n ; i ++ ) { View v = get View ( i ) ; if ( get Rows Occupied ( v ) > NUM ) { multi Row Cells = BOOL ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . get Minimum Span ( axis ) , min ) ; pref = Math . max ( ( int ) v . get Preferred Span ( axis ) , pref ) ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } } if ( r == null ) { r = new Size Requirements ( ) ; r . alignment = NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected Size Requirements calculate Minor Axis Requirements ( int axis , Size Requirements r ) { long min = NUM ; long pref = NUM ; long max = NUM ; multi Row Cells = BOOL ; int n = get View Count ( ) ; for ( int i = NUM ; i < n ; i ++ ) { View v = get View ( i ) ; if ( get Rows Occupied ( v ) > NUM ) { multi Row Cells = BOOL ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . get Minimum Span ( axis ) , min ) ; pref = Math . max ( ( int ) v . get Preferred Span ( axis ) , pref ) ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } } if ( r == null ) { r = new Size Requirements ( ) ; r . alignment = NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected Size Requirements calculate Minor Axis Requirements ( int axis , Size Requirements r ) { long min = NUM ; long pref = NUM ; long max = NUM ; multi Row Cells = BOOL ; int n = get View Count ( ) ; for ( int i = NUM ; i < n ; i ++ ) { View v = get View ( i ) ; if ( get Rows Occupied ( v ) > NUM ) { multi Row Cells = BOOL ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . get Minimum Span ( axis ) , min ) ; pref = Math . max ( ( int ) v . get Preferred Span ( axis ) , pref ) ; max = Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } } if ( r == null ) { r = new Size Requirements ( ) ; r . alignment = NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
public static Tc Feature create ( Class < ? extends Resource > feature Name , Object ... parameters ) { String id = feature Name . get Simple Name ( ) + System . nano Time ( ) ; List < Object > params = get Parameter As String ( parameters ) ; params . add ( Feature Extractor Resource Impl Base . PARAM UNIQUE EXTRACTOR NAME ) ; params . add ( id ) ; Tc Feature tc Feature = new Tc Feature ( feature Name , id , params . to Array ( ) ) ; return tc Feature ; }
public void close ( ) { Preconditions . check State ( channel != null , STRING ) ; try { if ( channel . is Open ( ) ) channel . close ( ) ; } catch ( IO Exception e ) { LOGGER . error ( STRING , path , e ) ; } finally { channel = null ; } }
public void init Presentation ( ) { create Help Window ( ) ; }
public void init Presentation ( ) { create Help Window ( ) ; }
public void init Presentation ( ) { create Help Window ( ) ; }
private static boolean match ( Char Sequence string , Char Sequence pattern , int s Ndx , int p Ndx ) { int p Len = pattern . length ( ) ; if ( p Len == NUM ) { if ( pattern . char At ( NUM ) == STRING ) { return BOOL ; } } int s Len = string . length ( ) ; boolean next Is Not Wildcard = BOOL ; while ( BOOL ) { if ( ( s Ndx >= s Len ) == BOOL ) { while ( ( p Ndx < p Len ) && ( pattern . char At ( p Ndx ) == STRING ) ) { p Ndx ++ ; } return p Ndx >= p Len ; } if ( p Ndx >= p Len ) { return BOOL ; } char p = pattern . char At ( p Ndx ) ; if ( next Is Not Wildcard == BOOL ) { if ( p == STRING ) { p Ndx ++ ; next Is Not Wildcard = BOOL ; continue ; } if ( p == STRING ) { s Ndx ++ ; p Ndx ++ ; continue ; } if ( p == STRING ) { char p Next = NUM ; if ( p Ndx + NUM < p Len ) { p Next = pattern . char At ( p Ndx + NUM ) ; } if ( p Next == STRING ) { p Ndx ++ ; continue ; } int i ; p Ndx ++ ; for ( i = string . length ( ) ; i >= s Ndx ; i -- ) { if ( match ( string , pattern , i , p Ndx ) == BOOL ) { return BOOL ; } } return BOOL ; } } else { next Is Not Wildcard = BOOL ; } if ( p != string . char At ( s Ndx ) ) { return BOOL ; } s Ndx ++ ; p Ndx ++ ; } }
public Background Painter ( Image image , boolean fixed , boolean tile ) { m img = image ; Media Tracker mt = new Media Tracker ( new Container ( ) ) ; mt . add Image ( m img , NUM ) ; try { mt . wait For ID ( NUM ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } mt . remove Image ( m img , NUM ) ; m fixed = fixed ; m tiled = tile ; }
public Trust Source add ( File trusted CA Pem File ) { if ( trusted CA Pem File == null ) { throw new Illegal Argument Exception ( STRING ) ; } String pem File Contents ; try { pem File Contents = Files . to String ( trusted CA Pem File , Charset . for Name ( STRING ) ) ; } catch ( IO Exception e ) { throw new Unchecked IO Exception ( STRING + trusted CA Pem File . get Absolute Path ( ) , e ) ; } return add ( pem File Contents ) ; }
public Trust Source add ( File trusted CA Pem File ) { if ( trusted CA Pem File == null ) { throw new Illegal Argument Exception ( STRING ) ; } String pem File Contents ; try { pem File Contents = Files . to String ( trusted CA Pem File , Charset . for Name ( STRING ) ) ; } catch ( IO Exception e ) { throw new Unchecked IO Exception ( STRING + trusted CA Pem File . get Absolute Path ( ) , e ) ; } return add ( pem File Contents ) ; }
public Trust Source add ( File trusted CA Pem File ) { if ( trusted CA Pem File == null ) { throw new Illegal Argument Exception ( STRING ) ; } String pem File Contents ; try { pem File Contents = Files . to String ( trusted CA Pem File , Charset . for Name ( STRING ) ) ; } catch ( IO Exception e ) { throw new Unchecked IO Exception ( STRING + trusted CA Pem File . get Absolute Path ( ) , e ) ; } return add ( pem File Contents ) ; }
public Trust Source add ( File trusted CA Pem File ) { if ( trusted CA Pem File == null ) { throw new Illegal Argument Exception ( STRING ) ; } String pem File Contents ; try { pem File Contents = Files . to String ( trusted CA Pem File , Charset . for Name ( STRING ) ) ; } catch ( IO Exception e ) { throw new Unchecked IO Exception ( STRING + trusted CA Pem File . get Absolute Path ( ) , e ) ; } return add ( pem File Contents ) ; }
public Trust Source add ( File trusted CA Pem File ) { if ( trusted CA Pem File == null ) { throw new Illegal Argument Exception ( STRING ) ; } String pem File Contents ; try { pem File Contents = Files . to String ( trusted CA Pem File , Charset . for Name ( STRING ) ) ; } catch ( IO Exception e ) { throw new Unchecked IO Exception ( STRING + trusted CA Pem File . get Absolute Path ( ) , e ) ; } return add ( pem File Contents ) ; }
public Trust Source add ( File trusted CA Pem File ) { if ( trusted CA Pem File == null ) { throw new Illegal Argument Exception ( STRING ) ; } String pem File Contents ; try { pem File Contents = Files . to String ( trusted CA Pem File , Charset . for Name ( STRING ) ) ; } catch ( IO Exception e ) { throw new Unchecked IO Exception ( STRING + trusted CA Pem File . get Absolute Path ( ) , e ) ; } return add ( pem File Contents ) ; }
public Trust Source add ( File trusted CA Pem File ) { if ( trusted CA Pem File == null ) { throw new Illegal Argument Exception ( STRING ) ; } String pem File Contents ; try { pem File Contents = Files . to String ( trusted CA Pem File , Charset . for Name ( STRING ) ) ; } catch ( IO Exception e ) { throw new Unchecked IO Exception ( STRING + trusted CA Pem File . get Absolute Path ( ) , e ) ; } return add ( pem File Contents ) ; }
public Trust Source add ( File trusted CA Pem File ) { if ( trusted CA Pem File == null ) { throw new Illegal Argument Exception ( STRING ) ; } String pem File Contents ; try { pem File Contents = Files . to String ( trusted CA Pem File , Charset . for Name ( STRING ) ) ; } catch ( IO Exception e ) { throw new Unchecked IO Exception ( STRING + trusted CA Pem File . get Absolute Path ( ) , e ) ; } return add ( pem File Contents ) ; }
public void parse Command Line ( String [ ] args ) { String language = DEFAULT LANGUAGE ; String country = DEFAULT COUNTRY ; if ( args != null ) { for ( String arg : args ) { if ( arg . starts With ( ARG STRING ) ) { String locale = arg . substring ( ARG STRING . length ( ) ) ; String [ ] components = locale . split ( STRING ) ; if ( components . length == NUM ) { language = components [ NUM ] ; country = components [ NUM ] ; } } } } current Locale = new Locale ( language , country ) ; }
public void run ( ) throws Exception { Logger log = Logger Factory . get Logger ( Remote Server Example . class ) ; Scheduler Factory sf = new Std Scheduler Factory ( ) ; Scheduler sched = sf . get Scheduler ( ) ; log . info ( STRING ) ; log . info ( STRING ) ; log . info ( STRING ) ; sched . start ( ) ; log . info ( STRING ) ; log . info ( STRING ) ; try { Thread . sleep ( NUM * NUM ) ; } catch ( Exception e ) { } log . info ( STRING ) ; sched . shutdown ( BOOL ) ; log . info ( STRING ) ; Scheduler Meta Data meta Data = sched . get Meta Data ( ) ; log . info ( STRING + meta Data . get Number Of Jobs Executed ( ) + STRING ) ; }
public void run ( ) throws Exception { Logger log = Logger Factory . get Logger ( Remote Server Example . class ) ; Scheduler Factory sf = new Std Scheduler Factory ( ) ; Scheduler sched = sf . get Scheduler ( ) ; log . info ( STRING ) ; log . info ( STRING ) ; log . info ( STRING ) ; sched . start ( ) ; log . info ( STRING ) ; log . info ( STRING ) ; try { Thread . sleep ( NUM * NUM ) ; } catch ( Exception e ) { } log . info ( STRING ) ; sched . shutdown ( BOOL ) ; log . info ( STRING ) ; Scheduler Meta Data meta Data = sched . get Meta Data ( ) ; log . info ( STRING + meta Data . get Number Of Jobs Executed ( ) + STRING ) ; }
private void write Statement ( ) throws RDF Handler Exception , IO Exception { Statement st = statement Queue . remove ( ) ; int subj Id = get Value Id ( st . get Subject ( ) ) ; int pred Id = get Value Id ( st . get Predicate ( ) ) ; int obj Id = get Value Id ( st . get Object ( ) ) ; int context Id = get Value Id ( st . get Context ( ) ) ; dec Value Freq ( st . get Subject ( ) ) ; dec Value Freq ( st . get Predicate ( ) ) ; dec Value Freq ( st . get Object ( ) ) ; dec Value Freq ( st . get Context ( ) ) ; out . write Byte ( STATEMENT ) ; write Value Or Id ( st . get Subject ( ) , subj Id ) ; write Value Or Id ( st . get Predicate ( ) , pred Id ) ; write Value Or Id ( st . get Object ( ) , obj Id ) ; write Value Or Id ( st . get Context ( ) , context Id ) ; }
private static Hash Map < String , Field > build Field Cache ( Class < ? > cls ) { final Hash Map < String , Field > cache = new Hash Map < > ( ) ; final List < Field > fields = get All Fields ( cls ) ; for ( Field fld : fields ) { String name = null ; final Reference ref Ann = fld . get Annotation ( Reference . class ) ; if ( ref Ann != null ) name = select Column Name ( ref Ann , fld ) ; if ( name == null ) { final Column col Ann = fld . get Annotation ( Column . class ) ; if ( col Ann != null ) name = select Column Name ( col Ann , fld ) ; } if ( name == null ) continue ; cache . put ( name , fld ) ; } return cache ; }
private static Hash Map < String , Field > build Field Cache ( Class < ? > cls ) { final Hash Map < String , Field > cache = new Hash Map < > ( ) ; final List < Field > fields = get All Fields ( cls ) ; for ( Field fld : fields ) { String name = null ; final Reference ref Ann = fld . get Annotation ( Reference . class ) ; if ( ref Ann != null ) name = select Column Name ( ref Ann , fld ) ; if ( name == null ) { final Column col Ann = fld . get Annotation ( Column . class ) ; if ( col Ann != null ) name = select Column Name ( col Ann , fld ) ; } if ( name == null ) continue ; cache . put ( name , fld ) ; } return cache ; }
private double inner Product ( Instance i1 , Instance i2 ) throws Exception { double result = NUM ; int n1 = i1 . num Values ( ) ; int n2 = i2 . num Values ( ) ; int class Index = m Train . class Index ( ) ; for ( int p1 = NUM , p2 = NUM ; p1 < n1 && p2 < n2 ; ) { int ind 1 = i1 . index ( p1 ) ; int ind 2 = i2 . index ( p2 ) ; if ( ind 1 == ind 2 ) { if ( ind 1 != class Index ) { result += i1 . value Sparse ( p1 ) * i2 . value Sparse ( p2 ) ; } p1 ++ ; p2 ++ ; } else if ( ind 1 > ind 2 ) { p2 ++ ; } else { p1 ++ ; } } result += NUM ; if ( m Exponent != NUM ) { return Math . pow ( result , m Exponent ) ; } else { return result ; } }
private static J Free Chart create Chart ( ) { Number [ ] [ ] data = new Integer [ ] [ ] { { new Integer ( - NUM ) , new Integer ( - NUM ) } , { new Integer ( - NUM ) , new Integer ( NUM ) } , { new Integer ( NUM ) , new Integer ( NUM ) } } ; Category Dataset dataset = Dataset Utilities . create Category Dataset ( STRING , STRING , data ) ; return Chart Factory . create Stacked Bar Chart 3 D ( STRING , STRING , STRING , dataset , Plot Orientation . HORIZONTAL , BOOL , BOOL , BOOL ) ; }
@ Override public boolean contains Key ( Object key ) { if ( key == null ) { return entry For Null Key != null ; } int hash = key . hash Code ( ) ; hash ^= ( hash > > > NUM ) ^ ( hash > > > NUM ) ; hash ^= ( hash > > > NUM ) ^ ( hash > > > NUM ) ; Hash Map Entry < K , V > [ ] tab = table ; for ( Hash Map Entry < K , V > e = tab [ hash & ( tab . length - NUM ) ] ; e != null ; e = e . next ) { K e Key = e . key ; if ( e Key == key || ( e . hash == hash && key . equals ( e Key ) ) ) { return BOOL ; } } return BOOL ; }
@ Override public boolean contains Key ( Object key ) { if ( key == null ) { return entry For Null Key != null ; } int hash = key . hash Code ( ) ; hash ^= ( hash > > > NUM ) ^ ( hash > > > NUM ) ; hash ^= ( hash > > > NUM ) ^ ( hash > > > NUM ) ; Hash Map Entry < K , V > [ ] tab = table ; for ( Hash Map Entry < K , V > e = tab [ hash & ( tab . length - NUM ) ] ; e != null ; e = e . next ) { K e Key = e . key ; if ( e Key == key || ( e . hash == hash && key . equals ( e Key ) ) ) { return BOOL ; } } return BOOL ; }
static void append Lang Item ( XMP Node array Node , String item Lang , String item Value ) throws XMP Exception { XMP Node new Item = new XMP Node ( ARRAY ITEM NAME , item Value , null ) ; XMP Node lang Qual = new XMP Node ( XML LANG , item Lang , null ) ; new Item . add Qualifier ( lang Qual ) ; if ( ! X DEFAULT . equals ( lang Qual . get Value ( ) ) ) { array Node . add Child ( new Item ) ; } else { array Node . add Child ( NUM , new Item ) ; } }
@ Override public void increment Access Count ( ) { access Count . increment And Get ( ) ; }
@ Override public void increment Access Count ( ) { access Count . increment And Get ( ) ; }
@ Override public void increment Access Count ( ) { access Count . increment And Get ( ) ; }
@ Override public void increment Access Count ( ) { access Count . increment And Get ( ) ; }
@ Override public void increment Access Count ( ) { access Count . increment And Get ( ) ; }
@ Override public void increment Access Count ( ) { access Count . increment And Get ( ) ; }
My DC Receiver ( Direct Channel Listener up ) { up Call = up ; }
My DC Receiver ( Direct Channel Listener up ) { up Call = up ; }
My DC Receiver ( Direct Channel Listener up ) { up Call = up ; }
My DC Receiver ( Direct Channel Listener up ) { up Call = up ; }
My DC Receiver ( Direct Channel Listener up ) { up Call = up ; }
My DC Receiver ( Direct Channel Listener up ) { up Call = up ; }
My DC Receiver ( Direct Channel Listener up ) { up Call = up ; }
My DC Receiver ( Direct Channel Listener up ) { up Call = up ; }
My DC Receiver ( Direct Channel Listener up ) { up Call = up ; }
My DC Receiver ( Direct Channel Listener up ) { up Call = up ; }
public void mouse Released ( final Mouse Event mouse Event ) { if ( drawing Walls ) { set Wall Point 2 ( mouse Event . get Point ( ) ) ; dragging Point = null ; } }
public static String [ ] add String To Array ( String [ ] array , String str ) { if ( Object Utils . is Empty ( array ) ) { return new String [ ] { str } ; } String [ ] new Arr = new String [ array . length + NUM ] ; System . arraycopy ( array , NUM , new Arr , NUM , array . length ) ; new Arr [ array . length ] = str ; return new Arr ; }
public static String [ ] add String To Array ( String [ ] array , String str ) { if ( Object Utils . is Empty ( array ) ) { return new String [ ] { str } ; } String [ ] new Arr = new String [ array . length + NUM ] ; System . arraycopy ( array , NUM , new Arr , NUM , array . length ) ; new Arr [ array . length ] = str ; return new Arr ; }
protected void process Owning Mapping Keys ( One To One Mapping mapping ) { if ( derives Id ( ) ) { process Foreign Key Relationship ( mapping ) ; if ( has Maps Id ( ) ) { process Maps Id ( mapping ) ; } else { process Id ( mapping ) ; } } else if ( is One To One Primary Key Relationship ( ) ) { process One To One Primary Key Relationship ( mapping ) ; } else if ( has Join Table ( ) ) { mapping . set Relation Table Mechanism ( new Relation Table Mechanism ( ) ) ; process Join Table ( mapping , mapping . get Relation Table Mechanism ( ) , get Join Table Metadata ( ) ) ; } else { process Foreign Key Relationship ( mapping ) ; } }
public static boolean git Global Config ( final Atomic Reference < String > path ) { final String Global Config File Name = STRING ; path . set ( null ) ; String global Path = Path . combine ( Environment . get Folder Path ( Environment . Special Folder . User Profile ) , Global Config File Name ) ; if ( Path . file Exists ( global Path ) ) { path . set ( global Path ) ; } return path . get ( ) != null ; }
public void create Log Panel ( ) { if ( log Panel == null ) { Text Box t = new Text Box ( STRING , null , NUM , Text Field . ANY ) ; t . add Command ( cancel ) ; t . set Command Listener ( this ) ; log Panel = t ; } }
public void create Log Panel ( ) { if ( log Panel == null ) { Text Box t = new Text Box ( STRING , null , NUM , Text Field . ANY ) ; t . add Command ( cancel ) ; t . set Command Listener ( this ) ; log Panel = t ; } }
public void create Log Panel ( ) { if ( log Panel == null ) { Text Box t = new Text Box ( STRING , null , NUM , Text Field . ANY ) ; t . add Command ( cancel ) ; t . set Command Listener ( this ) ; log Panel = t ; } }
public void create Log Panel ( ) { if ( log Panel == null ) { Text Box t = new Text Box ( STRING , null , NUM , Text Field . ANY ) ; t . add Command ( cancel ) ; t . set Command Listener ( this ) ; log Panel = t ; } }
public List < C > instantiate Classes ( Parameterization config ) { config = config . descend ( this ) ; List < C > instances = new Array List < > ( ) ; if ( get Value ( ) == null ) { config . report Error ( new Unused Parameter Exception ( STRING + get Name ( ) + STRING ) ) ; return instances ; } for ( Class < ? extends C > cls : get Value ( ) ) { try { C instance = Class Generics Util . try Instantiate ( restriction Class , cls , config ) ; instances . add ( instance ) ; } catch ( Exception e ) { config . report Error ( new Wrong Parameter Value Exception ( this , cls . get Name ( ) , e ) ) ; } } return instances ; }
public List < C > instantiate Classes ( Parameterization config ) { config = config . descend ( this ) ; List < C > instances = new Array List < > ( ) ; if ( get Value ( ) == null ) { config . report Error ( new Unused Parameter Exception ( STRING + get Name ( ) + STRING ) ) ; return instances ; } for ( Class < ? extends C > cls : get Value ( ) ) { try { C instance = Class Generics Util . try Instantiate ( restriction Class , cls , config ) ; instances . add ( instance ) ; } catch ( Exception e ) { config . report Error ( new Wrong Parameter Value Exception ( this , cls . get Name ( ) , e ) ) ; } } return instances ; }
public List < C > instantiate Classes ( Parameterization config ) { config = config . descend ( this ) ; List < C > instances = new Array List < > ( ) ; if ( get Value ( ) == null ) { config . report Error ( new Unused Parameter Exception ( STRING + get Name ( ) + STRING ) ) ; return instances ; } for ( Class < ? extends C > cls : get Value ( ) ) { try { C instance = Class Generics Util . try Instantiate ( restriction Class , cls , config ) ; instances . add ( instance ) ; } catch ( Exception e ) { config . report Error ( new Wrong Parameter Value Exception ( this , cls . get Name ( ) , e ) ) ; } } return instances ; }
public List < C > instantiate Classes ( Parameterization config ) { config = config . descend ( this ) ; List < C > instances = new Array List < > ( ) ; if ( get Value ( ) == null ) { config . report Error ( new Unused Parameter Exception ( STRING + get Name ( ) + STRING ) ) ; return instances ; } for ( Class < ? extends C > cls : get Value ( ) ) { try { C instance = Class Generics Util . try Instantiate ( restriction Class , cls , config ) ; instances . add ( instance ) ; } catch ( Exception e ) { config . report Error ( new Wrong Parameter Value Exception ( this , cls . get Name ( ) , e ) ) ; } } return instances ; }
public List < C > instantiate Classes ( Parameterization config ) { config = config . descend ( this ) ; List < C > instances = new Array List < > ( ) ; if ( get Value ( ) == null ) { config . report Error ( new Unused Parameter Exception ( STRING + get Name ( ) + STRING ) ) ; return instances ; } for ( Class < ? extends C > cls : get Value ( ) ) { try { C instance = Class Generics Util . try Instantiate ( restriction Class , cls , config ) ; instances . add ( instance ) ; } catch ( Exception e ) { config . report Error ( new Wrong Parameter Value Exception ( this , cls . get Name ( ) , e ) ) ; } } return instances ; }
public void run ( ) { if ( is Transient ) { throw new Runtime Exception ( STRING ) ; } lock . lock ( ) ; try { final long begin = System . current Time Millis ( ) ; final int i = ( int ) snapshot Count % NUM ; final File file = new File ( data Dir , BASENAME + i + EXT ) ; if ( ! data Dir . exists ( ) ) { if ( ! data Dir . mkdirs ( ) && ! data Dir . mkdirs ( ) ) { throw new Runtime Exception ( STRING + data Dir ) ; } } final long entry Count ; synchronized ( commit Time Index ) { entry Count = Snapshot Helper . write ( commit Time Index , file ) ; } snapshot Count ++ ; final long elapsed = System . current Time Millis ( ) - begin ; log . warn ( STRING + snapshot Count + STRING + entry Count + STRING + file + STRING + elapsed ) ; } catch ( Throwable t ) { log . error ( t . get Message ( ) , t ) ; return ; } finally { lock . unlock ( ) ; } }
public void run ( ) { if ( is Transient ) { throw new Runtime Exception ( STRING ) ; } lock . lock ( ) ; try { final long begin = System . current Time Millis ( ) ; final int i = ( int ) snapshot Count % NUM ; final File file = new File ( data Dir , BASENAME + i + EXT ) ; if ( ! data Dir . exists ( ) ) { if ( ! data Dir . mkdirs ( ) && ! data Dir . mkdirs ( ) ) { throw new Runtime Exception ( STRING + data Dir ) ; } } final long entry Count ; synchronized ( commit Time Index ) { entry Count = Snapshot Helper . write ( commit Time Index , file ) ; } snapshot Count ++ ; final long elapsed = System . current Time Millis ( ) - begin ; log . warn ( STRING + snapshot Count + STRING + entry Count + STRING + file + STRING + elapsed ) ; } catch ( Throwable t ) { log . error ( t . get Message ( ) , t ) ; return ; } finally { lock . unlock ( ) ; } }
public static void remove Object At Offset ( Object [ ] source Array , Object [ ] destination Array , int offset ) { System . arraycopy ( source Array , NUM , destination Array , NUM , offset ) ; System . arraycopy ( source Array , offset + NUM , destination Array , offset , source Array . length - offset - NUM ) ; }
protected Json Deserializer < Object > find Subclass Deserializer ( Deserialization Context ctxt , Object bean , Token Buffer unknown Tokens ) throws IO Exception , Json Processing Exception { Json Deserializer < Object > sub Deser ; synchronized ( this ) { sub Deser = ( sub Deserializers == null ) ? null : sub Deserializers . get ( new Class Key ( bean . get Class ( ) ) ) ; } if ( sub Deser != null ) { return sub Deser ; } Deserializer Provider deser Prov = ctxt . get Deserializer Provider ( ) ; if ( deser Prov != null ) { Java Type type = ctxt . construct Type ( bean . get Class ( ) ) ; sub Deser = deser Prov . find Value Deserializer ( ctxt . get Config ( ) , type , property ) ; if ( sub Deser != null ) { synchronized ( this ) { if ( sub Deserializers == null ) { sub Deserializers = new Hash Map < Class Key , Json Deserializer < Object > > ( ) ; ; } sub Deserializers . put ( new Class Key ( bean . get Class ( ) ) , sub Deser ) ; } } } return sub Deser ; }
protected Json Deserializer < Object > find Subclass Deserializer ( Deserialization Context ctxt , Object bean , Token Buffer unknown Tokens ) throws IO Exception , Json Processing Exception { Json Deserializer < Object > sub Deser ; synchronized ( this ) { sub Deser = ( sub Deserializers == null ) ? null : sub Deserializers . get ( new Class Key ( bean . get Class ( ) ) ) ; } if ( sub Deser != null ) { return sub Deser ; } Deserializer Provider deser Prov = ctxt . get Deserializer Provider ( ) ; if ( deser Prov != null ) { Java Type type = ctxt . construct Type ( bean . get Class ( ) ) ; sub Deser = deser Prov . find Value Deserializer ( ctxt . get Config ( ) , type , property ) ; if ( sub Deser != null ) { synchronized ( this ) { if ( sub Deserializers == null ) { sub Deserializers = new Hash Map < Class Key , Json Deserializer < Object > > ( ) ; ; } sub Deserializers . put ( new Class Key ( bean . get Class ( ) ) , sub Deser ) ; } } } return sub Deser ; }
protected Json Deserializer < Object > find Subclass Deserializer ( Deserialization Context ctxt , Object bean , Token Buffer unknown Tokens ) throws IO Exception , Json Processing Exception { Json Deserializer < Object > sub Deser ; synchronized ( this ) { sub Deser = ( sub Deserializers == null ) ? null : sub Deserializers . get ( new Class Key ( bean . get Class ( ) ) ) ; } if ( sub Deser != null ) { return sub Deser ; } Deserializer Provider deser Prov = ctxt . get Deserializer Provider ( ) ; if ( deser Prov != null ) { Java Type type = ctxt . construct Type ( bean . get Class ( ) ) ; sub Deser = deser Prov . find Value Deserializer ( ctxt . get Config ( ) , type , property ) ; if ( sub Deser != null ) { synchronized ( this ) { if ( sub Deserializers == null ) { sub Deserializers = new Hash Map < Class Key , Json Deserializer < Object > > ( ) ; ; } sub Deserializers . put ( new Class Key ( bean . get Class ( ) ) , sub Deser ) ; } } } return sub Deser ; }
public Lib Usb Exception ( final int error Code ) { super ( String . format ( STRING , - error Code , Lib Usb . str Error ( error Code ) ) ) ; this . error Code = error Code ; }
public Lib Usb Exception ( final int error Code ) { super ( String . format ( STRING , - error Code , Lib Usb . str Error ( error Code ) ) ) ; this . error Code = error Code ; }
private Iterable < Fragment Constructor > create Constructors ( ) { return Collections . unmodifiable List ( Arrays . as List ( new Biome Data Constructor ( Resolution . QUARTER ) , new End Islands Constructor ( ) , new Image Constructor ( Resolution . QUARTER , Layer Ids . BACKGROUND ) , new Image Constructor ( Resolution . CHUNK , Layer Ids . SLIME ) ) ) ; }
public static double [ ] expand Array D ( int buffer Size , double [ ] current Array ) { if ( current Array == null ) { return new double [ buffer Size * NUM ] ; } int length = current Array . length ; double [ ] ret = new double [ length + buffer Size * NUM ] ; System . arraycopy ( current Array , NUM , ret , NUM , length ) ; return ret ; }
public static double [ ] expand Array D ( int buffer Size , double [ ] current Array ) { if ( current Array == null ) { return new double [ buffer Size * NUM ] ; } int length = current Array . length ; double [ ] ret = new double [ length + buffer Size * NUM ] ; System . arraycopy ( current Array , NUM , ret , NUM , length ) ; return ret ; }
public static double [ ] expand Array D ( int buffer Size , double [ ] current Array ) { if ( current Array == null ) { return new double [ buffer Size * NUM ] ; } int length = current Array . length ; double [ ] ret = new double [ length + buffer Size * NUM ] ; System . arraycopy ( current Array , NUM , ret , NUM , length ) ; return ret ; }
public void free ( Array < T > objects ) { for ( int i = NUM , n = Math . min ( objects . size , max - free Objects . size ) ; i < n ; i ++ ) free Objects . add ( objects . get ( i ) ) ; }
public void populate Edit Text ( Array List < String > matches ) { toggle Search ( ) ; String text = STRING ; for ( int x = NUM ; x < matches . size ( ) ; x ++ ) { text = text + matches . get ( x ) + STRING ; } text = text . trim ( ) ; set Search String ( text ) ; search ( text ) ; }
public void populate Edit Text ( Array List < String > matches ) { toggle Search ( ) ; String text = STRING ; for ( int x = NUM ; x < matches . size ( ) ; x ++ ) { text = text + matches . get ( x ) + STRING ; } text = text . trim ( ) ; set Search String ( text ) ; search ( text ) ; }
private String reset Preferred IDP Cookie ( String existing Cookie Value , String to Add Cookie Value , boolean b Is SAML 2 ) { String Buffer return Cookie = new String Buffer ( ) ; String encoded Cookie To Add = Base 64 . encode ( generate Succinct ID ( to Add Cookie Value , b Is SAML 2 ) ) ; String Tokenizer st = new String Tokenizer ( existing Cookie Value , IDP Discovery Constants . PREFERRED COOKIE SEPERATOR ) ; while ( st . has More Tokens ( ) ) { String cur Idp String = ( String ) st . next Token ( ) ; if ( cur Idp String . equals ( encoded Cookie To Add ) ) { continue ; } else { return Cookie . append ( cur Idp String + STRING ) ; } } return Cookie . append ( encoded Cookie To Add ) ; return return Cookie . to String ( ) ; }
private String reset Preferred IDP Cookie ( String existing Cookie Value , String to Add Cookie Value , boolean b Is SAML 2 ) { String Buffer return Cookie = new String Buffer ( ) ; String encoded Cookie To Add = Base 64 . encode ( generate Succinct ID ( to Add Cookie Value , b Is SAML 2 ) ) ; String Tokenizer st = new String Tokenizer ( existing Cookie Value , IDP Discovery Constants . PREFERRED COOKIE SEPERATOR ) ; while ( st . has More Tokens ( ) ) { String cur Idp String = ( String ) st . next Token ( ) ; if ( cur Idp String . equals ( encoded Cookie To Add ) ) { continue ; } else { return Cookie . append ( cur Idp String + STRING ) ; } } return Cookie . append ( encoded Cookie To Add ) ; return return Cookie . to String ( ) ; }
public static Pair < String , String > parse Title And Date In Brackets ( String title ) { if ( title == null ) return new Pair < > ( null , null ) ; Pattern p = Pattern . compile ( STRING , Pattern . CASE INSENSITIVE ) ; Matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { return new Pair < > ( m . group ( NUM ) , m . group ( NUM ) ) ; } return new Pair < > ( title , null ) ; }
public static Pair < String , String > parse Title And Date In Brackets ( String title ) { if ( title == null ) return new Pair < > ( null , null ) ; Pattern p = Pattern . compile ( STRING , Pattern . CASE INSENSITIVE ) ; Matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { return new Pair < > ( m . group ( NUM ) , m . group ( NUM ) ) ; } return new Pair < > ( title , null ) ; }
public static Pair < String , String > parse Title And Date In Brackets ( String title ) { if ( title == null ) return new Pair < > ( null , null ) ; Pattern p = Pattern . compile ( STRING , Pattern . CASE INSENSITIVE ) ; Matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { return new Pair < > ( m . group ( NUM ) , m . group ( NUM ) ) ; } return new Pair < > ( title , null ) ; }
public static Pair < String , String > parse Title And Date In Brackets ( String title ) { if ( title == null ) return new Pair < > ( null , null ) ; Pattern p = Pattern . compile ( STRING , Pattern . CASE INSENSITIVE ) ; Matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { return new Pair < > ( m . group ( NUM ) , m . group ( NUM ) ) ; } return new Pair < > ( title , null ) ; }
public static Pair < String , String > parse Title And Date In Brackets ( String title ) { if ( title == null ) return new Pair < > ( null , null ) ; Pattern p = Pattern . compile ( STRING , Pattern . CASE INSENSITIVE ) ; Matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { return new Pair < > ( m . group ( NUM ) , m . group ( NUM ) ) ; } return new Pair < > ( title , null ) ; }
public void write ( byte [ ] b , int off , int len ) { if ( Sys Properties . CHECK && ( len < NUM || len % Constants . FILE BLOCK SIZE != NUM ) ) { Db Exception . throw Internal Error ( STRING + name + STRING + len ) ; } check Writing Allowed ( ) ; check Power Off ( ) ; try { File Utils . write Fully ( file , Byte Buffer . wrap ( b , off , len ) ) ; } catch ( IO Exception e ) { close File Silently ( ) ; throw Db Exception . convert IO Exception ( e , name ) ; } file Pos += len ; file Length = Math . max ( file Pos , file Length ) ; }
private void write Keystore ( File config Defaults ) throws IO Exception { File keystore XML = new File ( config Defaults , STRING ) ; Print Stream writer = Server Config Utils . open ( keystore XML ) ; writer . print ( STRING ) ; writer . print ( gen Password ( ) ) ; writer . println ( STRING ) ; Server Config Utils . close ( writer ) ; }
private void write Keystore ( File config Defaults ) throws IO Exception { File keystore XML = new File ( config Defaults , STRING ) ; Print Stream writer = Server Config Utils . open ( keystore XML ) ; writer . print ( STRING ) ; writer . print ( gen Password ( ) ) ; writer . println ( STRING ) ; Server Config Utils . close ( writer ) ; }
private void write Keystore ( File config Defaults ) throws IO Exception { File keystore XML = new File ( config Defaults , STRING ) ; Print Stream writer = Server Config Utils . open ( keystore XML ) ; writer . print ( STRING ) ; writer . print ( gen Password ( ) ) ; writer . println ( STRING ) ; Server Config Utils . close ( writer ) ; }
private void write Keystore ( File config Defaults ) throws IO Exception { File keystore XML = new File ( config Defaults , STRING ) ; Print Stream writer = Server Config Utils . open ( keystore XML ) ; writer . print ( STRING ) ; writer . print ( gen Password ( ) ) ; writer . println ( STRING ) ; Server Config Utils . close ( writer ) ; }
private void write Keystore ( File config Defaults ) throws IO Exception { File keystore XML = new File ( config Defaults , STRING ) ; Print Stream writer = Server Config Utils . open ( keystore XML ) ; writer . print ( STRING ) ; writer . print ( gen Password ( ) ) ; writer . println ( STRING ) ; Server Config Utils . close ( writer ) ; }
private void write Keystore ( File config Defaults ) throws IO Exception { File keystore XML = new File ( config Defaults , STRING ) ; Print Stream writer = Server Config Utils . open ( keystore XML ) ; writer . print ( STRING ) ; writer . print ( gen Password ( ) ) ; writer . println ( STRING ) ; Server Config Utils . close ( writer ) ; }
public Refactoring Session Transformer ( final boolean projects ) { f Projects = projects ; }
protected void draw Linear Fill ( Canvas c , I Line Data Set data Set , Transformer trans , X Bounds bounds ) { final Path filled = m Generate Filled Path Buffer ; final int starting Index = bounds . min Index ; final int ending Index = bounds . index Range + bounds . min Index ; final int index Interval = NUM ; int current Start Index = NUM ; int current End Index = index Interval ; int iterations = NUM ; do { current Start Index = starting Index + ( iterations * index Interval ) ; current End Index = current Start Index + index Interval ; current End Index = current End Index > ending Index ? ending Index : current End Index ; if ( current Start Index <= current End Index ) { generate Filled Path ( data Set , current Start Index , current End Index , filled ) ; trans . path Value To Pixel ( filled ) ; final Drawable drawable = data Set . get Fill Drawable ( ) ; if ( drawable != null ) { draw Filled Path ( c , filled , drawable ) ; } else { draw Filled Path ( c , filled , data Set . get Fill Color ( ) , data Set . get Fill Alpha ( ) ) ; } } iterations ++ ; } while ( current Start Index <= current End Index ) ; }
protected void draw Linear Fill ( Canvas c , I Line Data Set data Set , Transformer trans , X Bounds bounds ) { final Path filled = m Generate Filled Path Buffer ; final int starting Index = bounds . min Index ; final int ending Index = bounds . index Range + bounds . min Index ; final int index Interval = NUM ; int current Start Index = NUM ; int current End Index = index Interval ; int iterations = NUM ; do { current Start Index = starting Index + ( iterations * index Interval ) ; current End Index = current Start Index + index Interval ; current End Index = current End Index > ending Index ? ending Index : current End Index ; if ( current Start Index <= current End Index ) { generate Filled Path ( data Set , current Start Index , current End Index , filled ) ; trans . path Value To Pixel ( filled ) ; final Drawable drawable = data Set . get Fill Drawable ( ) ; if ( drawable != null ) { draw Filled Path ( c , filled , drawable ) ; } else { draw Filled Path ( c , filled , data Set . get Fill Color ( ) , data Set . get Fill Alpha ( ) ) ; } } iterations ++ ; } while ( current Start Index <= current End Index ) ; }
@ Override public void write External ( Object Output out ) throws IO Exception { int dim = get Dimensionality ( ) ; out . write Int ( dim ) ; for ( double a Min : min ) { out . write Double ( a Min ) ; } for ( double a Max : max ) { out . write Double ( a Max ) ; } }
private void populate Sub Domain Hierarchy Lazy ( Space space , Dimension Index root , Axis axis , Array List < Dimension Index > result , I Domain type ) throws Interrupted Exception , Scope Exception { Object adapter = type . get Adapter ( Domain . class ) ; if ( adapter != null && adapter instanceof Domain ) { Domain target = ( Domain ) adapter ; logger . info ( STRING + target . to String ( ) + STRING + space . to String ( ) ) ; Axis source = axis ; try { Dimension Index self = new Dimension Index ( null , source ) ; subdomains . add ( self ) ; } catch ( Dimension Store Exception e ) { logger . error ( STRING + target . to String ( ) + STRING + space . to String ( ) ) ; } } else { logger . error ( STRING ) ; if ( ! dimension Index In List ( result , axis ) ) { result . add ( Dimension Index Creation Utils . create Invalid Index ( root , axis , STRING ) ) ; } } }
private void populate Sub Domain Hierarchy Lazy ( Space space , Dimension Index root , Axis axis , Array List < Dimension Index > result , I Domain type ) throws Interrupted Exception , Scope Exception { Object adapter = type . get Adapter ( Domain . class ) ; if ( adapter != null && adapter instanceof Domain ) { Domain target = ( Domain ) adapter ; logger . info ( STRING + target . to String ( ) + STRING + space . to String ( ) ) ; Axis source = axis ; try { Dimension Index self = new Dimension Index ( null , source ) ; subdomains . add ( self ) ; } catch ( Dimension Store Exception e ) { logger . error ( STRING + target . to String ( ) + STRING + space . to String ( ) ) ; } } else { logger . error ( STRING ) ; if ( ! dimension Index In List ( result , axis ) ) { result . add ( Dimension Index Creation Utils . create Invalid Index ( root , axis , STRING ) ) ; } } }
private void populate Sub Domain Hierarchy Lazy ( Space space , Dimension Index root , Axis axis , Array List < Dimension Index > result , I Domain type ) throws Interrupted Exception , Scope Exception { Object adapter = type . get Adapter ( Domain . class ) ; if ( adapter != null && adapter instanceof Domain ) { Domain target = ( Domain ) adapter ; logger . info ( STRING + target . to String ( ) + STRING + space . to String ( ) ) ; Axis source = axis ; try { Dimension Index self = new Dimension Index ( null , source ) ; subdomains . add ( self ) ; } catch ( Dimension Store Exception e ) { logger . error ( STRING + target . to String ( ) + STRING + space . to String ( ) ) ; } } else { logger . error ( STRING ) ; if ( ! dimension Index In List ( result , axis ) ) { result . add ( Dimension Index Creation Utils . create Invalid Index ( root , axis , STRING ) ) ; } } }
private void populate Sub Domain Hierarchy Lazy ( Space space , Dimension Index root , Axis axis , Array List < Dimension Index > result , I Domain type ) throws Interrupted Exception , Scope Exception { Object adapter = type . get Adapter ( Domain . class ) ; if ( adapter != null && adapter instanceof Domain ) { Domain target = ( Domain ) adapter ; logger . info ( STRING + target . to String ( ) + STRING + space . to String ( ) ) ; Axis source = axis ; try { Dimension Index self = new Dimension Index ( null , source ) ; subdomains . add ( self ) ; } catch ( Dimension Store Exception e ) { logger . error ( STRING + target . to String ( ) + STRING + space . to String ( ) ) ; } } else { logger . error ( STRING ) ; if ( ! dimension Index In List ( result , axis ) ) { result . add ( Dimension Index Creation Utils . create Invalid Index ( root , axis , STRING ) ) ; } } }
public List simulate ( ) { List [ ] val = new List [ NUM ] ; for ( int i = NUM ; i >= NUM ; i -- ) { Village v = forward [ i ] ; if ( v != null ) { val [ i ] = v . simulate ( ) ; } } for ( int i = NUM ; i >= NUM ; i -- ) { List l = val [ i ] ; if ( l != null ) { for ( Enumeration e = l . elements ( ) ; e . has More Elements ( ) ; ) { Patient p = ( Patient ) e . next Element ( ) ; hospital . put In Hospital ( p ) ; } } } hospital . check Patients Inside ( returned ) ; List up = hospital . check Patients Assess ( this ) ; hospital . check Patients Waiting ( ) ; Patient p = generate Patient ( ) ; if ( p != null ) { hospital . put In Hospital ( p ) ; } return up ; }
private void end Current Begin New Window ( ) throws Interrupted Exception { queue . put ( new End Window Tuple ( base Seconds | window Id ) ) ; if ( ++ check Point Window Count == checkpoint Count ) { queue . put ( new Tuple ( Message Type . CHECKPOINT , base Seconds | window Id ) ) ; check Point Window Count = NUM ; } if ( window Id == MAX WINDOW ID ) { advance Window ( ) ; run ( ) ; } else { advance Window ( ) ; queue . put ( new Tuple ( Message Type . BEGIN WINDOW , base Seconds | window Id ) ) ; } }
public Function Table Model ( ) { column List . add ( Localisation . get String ( Function Table Model . class , STRING ) ) ; column List . add ( Localisation . get String ( Function Table Model . class , STRING ) ) ; column List . add ( Localisation . get String ( Function Table Model . class , STRING ) ) ; column List . add ( Localisation . get String ( Function Table Model . class , STRING ) ) ; }
public static boolean compare Signatures ( String plain Signature , String generic Signature ) { Generic Signature Parser plain Parser = new Generic Signature Parser ( plain Signature ) ; Generic Signature Parser generic Parser = new Generic Signature Parser ( generic Signature ) ; if ( plain Parser . get Num Parameters ( ) != generic Parser . get Num Parameters ( ) ) { return BOOL ; } return BOOL ; }
private int insert Unassigned Group ( ) throws SQL Exception { Prepared Statement group Statement ; final int ruleid = insert Unassigned Rule ( ) ; final int evaluation Order = get Num Of Groups ( ) + NUM ; String unassigned Group Sql Statement = STRING + GROUPS TABLE + STRING + STRING + STRING ; unassigned Group Sql Statement = String . format ( unassigned Group Sql Statement , UNASSIGNED GROUP , UNASSIGNED GROUP TYPE , UNASSIGNED DATA TYPE , ruleid , evaluation Order ) ; group Statement = prepare Statement ( unassigned Group Sql Statement , new String [ ] { STRING } ) ; group Statement . execute ( ) ; return get Internal Id ( group Statement ) ; }
private int insert Unassigned Group ( ) throws SQL Exception { Prepared Statement group Statement ; final int ruleid = insert Unassigned Rule ( ) ; final int evaluation Order = get Num Of Groups ( ) + NUM ; String unassigned Group Sql Statement = STRING + GROUPS TABLE + STRING + STRING + STRING ; unassigned Group Sql Statement = String . format ( unassigned Group Sql Statement , UNASSIGNED GROUP , UNASSIGNED GROUP TYPE , UNASSIGNED DATA TYPE , ruleid , evaluation Order ) ; group Statement = prepare Statement ( unassigned Group Sql Statement , new String [ ] { STRING } ) ; group Statement . execute ( ) ; return get Internal Id ( group Statement ) ; }
private int insert Unassigned Group ( ) throws SQL Exception { Prepared Statement group Statement ; final int ruleid = insert Unassigned Rule ( ) ; final int evaluation Order = get Num Of Groups ( ) + NUM ; String unassigned Group Sql Statement = STRING + GROUPS TABLE + STRING + STRING + STRING ; unassigned Group Sql Statement = String . format ( unassigned Group Sql Statement , UNASSIGNED GROUP , UNASSIGNED GROUP TYPE , UNASSIGNED DATA TYPE , ruleid , evaluation Order ) ; group Statement = prepare Statement ( unassigned Group Sql Statement , new String [ ] { STRING } ) ; group Statement . execute ( ) ; return get Internal Id ( group Statement ) ; }
private int insert Unassigned Group ( ) throws SQL Exception { Prepared Statement group Statement ; final int ruleid = insert Unassigned Rule ( ) ; final int evaluation Order = get Num Of Groups ( ) + NUM ; String unassigned Group Sql Statement = STRING + GROUPS TABLE + STRING + STRING + STRING ; unassigned Group Sql Statement = String . format ( unassigned Group Sql Statement , UNASSIGNED GROUP , UNASSIGNED GROUP TYPE , UNASSIGNED DATA TYPE , ruleid , evaluation Order ) ; group Statement = prepare Statement ( unassigned Group Sql Statement , new String [ ] { STRING } ) ; group Statement . execute ( ) ; return get Internal Id ( group Statement ) ; }
private int insert Unassigned Group ( ) throws SQL Exception { Prepared Statement group Statement ; final int ruleid = insert Unassigned Rule ( ) ; final int evaluation Order = get Num Of Groups ( ) + NUM ; String unassigned Group Sql Statement = STRING + GROUPS TABLE + STRING + STRING + STRING ; unassigned Group Sql Statement = String . format ( unassigned Group Sql Statement , UNASSIGNED GROUP , UNASSIGNED GROUP TYPE , UNASSIGNED DATA TYPE , ruleid , evaluation Order ) ; group Statement = prepare Statement ( unassigned Group Sql Statement , new String [ ] { STRING } ) ; group Statement . execute ( ) ; return get Internal Id ( group Statement ) ; }
private int insert Unassigned Group ( ) throws SQL Exception { Prepared Statement group Statement ; final int ruleid = insert Unassigned Rule ( ) ; final int evaluation Order = get Num Of Groups ( ) + NUM ; String unassigned Group Sql Statement = STRING + GROUPS TABLE + STRING + STRING + STRING ; unassigned Group Sql Statement = String . format ( unassigned Group Sql Statement , UNASSIGNED GROUP , UNASSIGNED GROUP TYPE , UNASSIGNED DATA TYPE , ruleid , evaluation Order ) ; group Statement = prepare Statement ( unassigned Group Sql Statement , new String [ ] { STRING } ) ; group Statement . execute ( ) ; return get Internal Id ( group Statement ) ; }
private int insert Unassigned Group ( ) throws SQL Exception { Prepared Statement group Statement ; final int ruleid = insert Unassigned Rule ( ) ; final int evaluation Order = get Num Of Groups ( ) + NUM ; String unassigned Group Sql Statement = STRING + GROUPS TABLE + STRING + STRING + STRING ; unassigned Group Sql Statement = String . format ( unassigned Group Sql Statement , UNASSIGNED GROUP , UNASSIGNED GROUP TYPE , UNASSIGNED DATA TYPE , ruleid , evaluation Order ) ; group Statement = prepare Statement ( unassigned Group Sql Statement , new String [ ] { STRING } ) ; group Statement . execute ( ) ; return get Internal Id ( group Statement ) ; }
private int insert Unassigned Group ( ) throws SQL Exception { Prepared Statement group Statement ; final int ruleid = insert Unassigned Rule ( ) ; final int evaluation Order = get Num Of Groups ( ) + NUM ; String unassigned Group Sql Statement = STRING + GROUPS TABLE + STRING + STRING + STRING ; unassigned Group Sql Statement = String . format ( unassigned Group Sql Statement , UNASSIGNED GROUP , UNASSIGNED GROUP TYPE , UNASSIGNED DATA TYPE , ruleid , evaluation Order ) ; group Statement = prepare Statement ( unassigned Group Sql Statement , new String [ ] { STRING } ) ; group Statement . execute ( ) ; return get Internal Id ( group Statement ) ; }
private int insert Unassigned Group ( ) throws SQL Exception { Prepared Statement group Statement ; final int ruleid = insert Unassigned Rule ( ) ; final int evaluation Order = get Num Of Groups ( ) + NUM ; String unassigned Group Sql Statement = STRING + GROUPS TABLE + STRING + STRING + STRING ; unassigned Group Sql Statement = String . format ( unassigned Group Sql Statement , UNASSIGNED GROUP , UNASSIGNED GROUP TYPE , UNASSIGNED DATA TYPE , ruleid , evaluation Order ) ; group Statement = prepare Statement ( unassigned Group Sql Statement , new String [ ] { STRING } ) ; group Statement . execute ( ) ; return get Internal Id ( group Statement ) ; }
private int insert Unassigned Group ( ) throws SQL Exception { Prepared Statement group Statement ; final int ruleid = insert Unassigned Rule ( ) ; final int evaluation Order = get Num Of Groups ( ) + NUM ; String unassigned Group Sql Statement = STRING + GROUPS TABLE + STRING + STRING + STRING ; unassigned Group Sql Statement = String . format ( unassigned Group Sql Statement , UNASSIGNED GROUP , UNASSIGNED GROUP TYPE , UNASSIGNED DATA TYPE , ruleid , evaluation Order ) ; group Statement = prepare Statement ( unassigned Group Sql Statement , new String [ ] { STRING } ) ; group Statement . execute ( ) ; return get Internal Id ( group Statement ) ; }
public void add ( String name , Object ... args ) { list . add ( Parameterization . create ( name , args ) ) ; }
Default Shell Folder ( Shell Folder parent , File f ) { super ( parent , f . get Absolute Path ( ) ) ; }
public Char Sequence sub Sequence ( int start , int end ) { return substring ( start , end ) ; }
public Char Sequence sub Sequence ( int start , int end ) { return substring ( start , end ) ; }
public Char Sequence sub Sequence ( int start , int end ) { return substring ( start , end ) ; }
public Char Sequence sub Sequence ( int start , int end ) { return substring ( start , end ) ; }
public void write Field ( final String name , final char value ) throws java . io . IO Exception { write Field ( name , Character . to String ( value ) ) ; }
static double mypdf ( double value , double shape , double scale ) { return Math . exp ( ( shape - NUM ) * Math . log ( value ) - value / scale - Gamma Function . log Gamma ( shape ) - shape * Math . log ( scale ) ) ; }
static double mypdf ( double value , double shape , double scale ) { return Math . exp ( ( shape - NUM ) * Math . log ( value ) - value / scale - Gamma Function . log Gamma ( shape ) - shape * Math . log ( scale ) ) ; }
public boolean is Reflected Edge ( Stmt Edge < Soot Method > e ) { return reflected Edges . contains ( e ) ; }
public void test Constructor Sign Bytes Positive 1 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM } ; int a Sign = NUM ; byte r Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
public void test Constructor Sign Bytes Positive 1 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM } ; int a Sign = NUM ; byte r Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
public void test Constructor Sign Bytes Positive 1 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM } ; int a Sign = NUM ; byte r Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
public static String extract Group Name ( String group Name ) { Pattern p = Pattern . compile ( STRING ) ; Matcher matcher = p . matcher ( group Name ) ; if ( matcher . matches ( ) ) { return matcher . group ( NUM ) ; } return group Name ; }
public static String extract Group Name ( String group Name ) { Pattern p = Pattern . compile ( STRING ) ; Matcher matcher = p . matcher ( group Name ) ; if ( matcher . matches ( ) ) { return matcher . group ( NUM ) ; } return group Name ; }
protected Class find Class ( String name ) throws Class Not Found Exception { Class Manager Impl bcm = ( Class Manager Impl ) get Class Manager ( ) ; Class Loader cl = bcm . get Loader For Class ( name ) ; Class c ; if ( cl != null && cl != this ) try { return cl . load Class ( name ) ; } catch ( Class Not Found Exception e ) { throw new Class Not Found Exception ( STRING + e ) ; } if ( get UR Ls ( ) . length > NUM ) try { return super . find Class ( name ) ; } catch ( Class Not Found Exception e ) { } cl = bcm . get Base Loader ( ) ; if ( cl != null && cl != this ) try { return cl . load Class ( name ) ; } catch ( Class Not Found Exception e ) { } return bcm . plain Class For Name ( name ) ; }
@ Override public int following ( int offset ) { Character Iterator text = get Text ( ) ; check Offset ( offset , text ) ; if ( cached Break Positions == null || offset < cached Break Positions [ NUM ] || offset >= cached Break Positions [ cached Break Positions . length - NUM ] ) { cached Break Positions = null ; return super . following ( offset ) ; } else { position In Cache = NUM ; while ( position In Cache < cached Break Positions . length && offset >= cached Break Positions [ position In Cache ] ) { ++ position In Cache ; } text . set Index ( cached Break Positions [ position In Cache ] ) ; return text . get Index ( ) ; } }
@ Override public int following ( int offset ) { Character Iterator text = get Text ( ) ; check Offset ( offset , text ) ; if ( cached Break Positions == null || offset < cached Break Positions [ NUM ] || offset >= cached Break Positions [ cached Break Positions . length - NUM ] ) { cached Break Positions = null ; return super . following ( offset ) ; } else { position In Cache = NUM ; while ( position In Cache < cached Break Positions . length && offset >= cached Break Positions [ position In Cache ] ) { ++ position In Cache ; } text . set Index ( cached Break Positions [ position In Cache ] ) ; return text . get Index ( ) ; } }
public boolean user Has Given Role In Any Tenant ( Storage OS User user , Role ... roles ) { if ( user Has Given Role ( user , URI . create ( user . get Tenant Id ( ) ) , roles ) ) { return BOOL ; } Map < String , Collection < String > > all Subtenant Roles = null ; for ( Role role : roles ) { if ( is Role Tenant Level ( role . to String ( ) ) ) { if ( all Subtenant Roles == null ) { all Subtenant Roles = get Subtenant Roles For User ( user ) ; } for ( Collection < String > subtenant Roles : all Subtenant Roles . values ( ) ) { if ( subtenant Roles . contains ( role . to String ( ) ) ) { return BOOL ; } } } } return BOOL ; }
public boolean user Has Given Role In Any Tenant ( Storage OS User user , Role ... roles ) { if ( user Has Given Role ( user , URI . create ( user . get Tenant Id ( ) ) , roles ) ) { return BOOL ; } Map < String , Collection < String > > all Subtenant Roles = null ; for ( Role role : roles ) { if ( is Role Tenant Level ( role . to String ( ) ) ) { if ( all Subtenant Roles == null ) { all Subtenant Roles = get Subtenant Roles For User ( user ) ; } for ( Collection < String > subtenant Roles : all Subtenant Roles . values ( ) ) { if ( subtenant Roles . contains ( role . to String ( ) ) ) { return BOOL ; } } } } return BOOL ; }
private void simulate Store ( final Store Instruction instruction ) { final int index = instruction . get Number ( ) ; final Element element To Store = runtime Stack . pop ( ) ; if ( element To Store instanceof Method Handle ) merge Method Handle Store ( index , ( Method Handle ) element To Store ) ; else merge Element Store ( index , instruction . get Variable Type ( ) , element To Store ) ; }
private Visor Cache Metrics Collector Job ( Ignite Bi Tuple < Boolean , Collection < String > > arg , boolean debug ) { super ( arg , debug ) ; }
private static int escape ( char [ ] cc , char c , int index ) { cc [ index ++ ] = STRING ; cc [ index ++ ] = Character . for Digit ( ( c > > NUM ) & NUM , NUM ) ; cc [ index ++ ] = Character . for Digit ( c & NUM , NUM ) ; return index ; }
public void store New Package Order ( ) { List < String > package List = new Array List < String > ( ) ; for ( App Info act App : m Installed Apps ) { package List . add ( act App . package Name ) ; } m Settings . set Package Order ( package List ) ; }
public void store New Package Order ( ) { List < String > package List = new Array List < String > ( ) ; for ( App Info act App : m Installed Apps ) { package List . add ( act App . package Name ) ; } m Settings . set Package Order ( package List ) ; }
private String note To String ( Repository repo , Note note ) throws Missing Object Exception , IO Exception , Unsupported Encoding Exception { Object Loader loader = repo . open ( note . get Data ( ) ) ; Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; loader . copy To ( baos ) ; return new String ( baos . to Byte Array ( ) , STRING ) ; }
private String note To String ( Repository repo , Note note ) throws Missing Object Exception , IO Exception , Unsupported Encoding Exception { Object Loader loader = repo . open ( note . get Data ( ) ) ; Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; loader . copy To ( baos ) ; return new String ( baos . to Byte Array ( ) , STRING ) ; }
private void update Statistics ( ) { long current Time = System . current Time Millis ( ) ; double diff Time = current Time - last Time ; double diff Seed = current Seed - last Seed ; double diff NFE = current NFE - last NFE ; double percent Change = ( diff Seed + ( diff NFE / max NFE ) ) / total Seeds ; if ( ( diff Time > NUM ) && ( percent Change > NUM ) ) { statistics . add Value ( diff Time / percent Change ) ; last Time = current Time ; last Seed = current Seed ; last NFE = current NFE ; } }
private void update Statistics ( ) { long current Time = System . current Time Millis ( ) ; double diff Time = current Time - last Time ; double diff Seed = current Seed - last Seed ; double diff NFE = current NFE - last NFE ; double percent Change = ( diff Seed + ( diff NFE / max NFE ) ) / total Seeds ; if ( ( diff Time > NUM ) && ( percent Change > NUM ) ) { statistics . add Value ( diff Time / percent Change ) ; last Time = current Time ; last Seed = current Seed ; last NFE = current NFE ; } }
private void update Statistics ( ) { long current Time = System . current Time Millis ( ) ; double diff Time = current Time - last Time ; double diff Seed = current Seed - last Seed ; double diff NFE = current NFE - last NFE ; double percent Change = ( diff Seed + ( diff NFE / max NFE ) ) / total Seeds ; if ( ( diff Time > NUM ) && ( percent Change > NUM ) ) { statistics . add Value ( diff Time / percent Change ) ; last Time = current Time ; last Seed = current Seed ; last NFE = current NFE ; } }
@ Suppress Warnings ( STRING ) public Long Map ( int initial Capacity , float load Factor ) { if ( initial Capacity < NUM ) throw new Illegal Argument Exception ( STRING + initial Capacity ) ; if ( initial Capacity > NUM << NUM ) throw new Illegal Argument Exception ( STRING + initial Capacity ) ; capacity = next Power Of Two ( initial Capacity ) ; if ( load Factor <= NUM ) throw new Illegal Argument Exception ( STRING + load Factor ) ; this . load Factor = load Factor ; threshold = ( int ) ( capacity * load Factor ) ; mask = capacity - NUM ; hash Shift = NUM - Long . number Of Trailing Zeros ( capacity ) ; stash Capacity = Math . max ( NUM , ( int ) Math . ceil ( Math . log ( capacity ) ) * NUM ) ; push Iterations = Math . max ( Math . min ( capacity , NUM ) , ( int ) Math . sqrt ( capacity ) / NUM ) ; key Table = new long [ capacity + stash Capacity ] ; value Table = ( V [ ] ) new Object [ key Table . length ] ; }
@ Suppress Warnings ( STRING ) public Long Map ( int initial Capacity , float load Factor ) { if ( initial Capacity < NUM ) throw new Illegal Argument Exception ( STRING + initial Capacity ) ; if ( initial Capacity > NUM << NUM ) throw new Illegal Argument Exception ( STRING + initial Capacity ) ; capacity = next Power Of Two ( initial Capacity ) ; if ( load Factor <= NUM ) throw new Illegal Argument Exception ( STRING + load Factor ) ; this . load Factor = load Factor ; threshold = ( int ) ( capacity * load Factor ) ; mask = capacity - NUM ; hash Shift = NUM - Long . number Of Trailing Zeros ( capacity ) ; stash Capacity = Math . max ( NUM , ( int ) Math . ceil ( Math . log ( capacity ) ) * NUM ) ; push Iterations = Math . max ( Math . min ( capacity , NUM ) , ( int ) Math . sqrt ( capacity ) / NUM ) ; key Table = new long [ capacity + stash Capacity ] ; value Table = ( V [ ] ) new Object [ key Table . length ] ; }
@ Suppress Warnings ( STRING ) public Long Map ( int initial Capacity , float load Factor ) { if ( initial Capacity < NUM ) throw new Illegal Argument Exception ( STRING + initial Capacity ) ; if ( initial Capacity > NUM << NUM ) throw new Illegal Argument Exception ( STRING + initial Capacity ) ; capacity = next Power Of Two ( initial Capacity ) ; if ( load Factor <= NUM ) throw new Illegal Argument Exception ( STRING + load Factor ) ; this . load Factor = load Factor ; threshold = ( int ) ( capacity * load Factor ) ; mask = capacity - NUM ; hash Shift = NUM - Long . number Of Trailing Zeros ( capacity ) ; stash Capacity = Math . max ( NUM , ( int ) Math . ceil ( Math . log ( capacity ) ) * NUM ) ; push Iterations = Math . max ( Math . min ( capacity , NUM ) , ( int ) Math . sqrt ( capacity ) / NUM ) ; key Table = new long [ capacity + stash Capacity ] ; value Table = ( V [ ] ) new Object [ key Table . length ] ; }
@ Suppress Warnings ( STRING ) public Long Map ( int initial Capacity , float load Factor ) { if ( initial Capacity < NUM ) throw new Illegal Argument Exception ( STRING + initial Capacity ) ; if ( initial Capacity > NUM << NUM ) throw new Illegal Argument Exception ( STRING + initial Capacity ) ; capacity = next Power Of Two ( initial Capacity ) ; if ( load Factor <= NUM ) throw new Illegal Argument Exception ( STRING + load Factor ) ; this . load Factor = load Factor ; threshold = ( int ) ( capacity * load Factor ) ; mask = capacity - NUM ; hash Shift = NUM - Long . number Of Trailing Zeros ( capacity ) ; stash Capacity = Math . max ( NUM , ( int ) Math . ceil ( Math . log ( capacity ) ) * NUM ) ; push Iterations = Math . max ( Math . min ( capacity , NUM ) , ( int ) Math . sqrt ( capacity ) / NUM ) ; key Table = new long [ capacity + stash Capacity ] ; value Table = ( V [ ] ) new Object [ key Table . length ] ; }
public final Completable Future < Partition Receiver > create Receiver ( final String consumer Group Name , final String partition Id , final String starting Offset , boolean offset Inclusive ) throws Service Bus Exception { return Partition Receiver . create ( this . underlying Factory , this . event Hub Name , consumer Group Name , partition Id , starting Offset , offset Inclusive , null , Partition Receiver . NULL EPOCH , BOOL ) ; }
public final Completable Future < Partition Receiver > create Receiver ( final String consumer Group Name , final String partition Id , final String starting Offset , boolean offset Inclusive ) throws Service Bus Exception { return Partition Receiver . create ( this . underlying Factory , this . event Hub Name , consumer Group Name , partition Id , starting Offset , offset Inclusive , null , Partition Receiver . NULL EPOCH , BOOL ) ; }
public final Completable Future < Partition Receiver > create Receiver ( final String consumer Group Name , final String partition Id , final String starting Offset , boolean offset Inclusive ) throws Service Bus Exception { return Partition Receiver . create ( this . underlying Factory , this . event Hub Name , consumer Group Name , partition Id , starting Offset , offset Inclusive , null , Partition Receiver . NULL EPOCH , BOOL ) ; }
public String put Image ( String the Folder , String the Image Name , Bitmap the Bitmap ) { if ( the Folder == null || the Image Name == null || the Bitmap == null ) return null ; this . DEFAULT APP IMAGEDATA DIRECTORY = the Folder ; String m Full Path = setup Full Path ( the Image Name ) ; if ( ! m Full Path . equals ( STRING ) ) { last Image Path = m Full Path ; save Bitmap ( m Full Path , the Bitmap ) ; } return m Full Path ; }
public boolean required Resource Name ( Policy policy , String realm Name , String name ) { get Svc Type Name To Actions Map ( policy , realm Name ) ; return required Resource Name Service . contains ( name ) ; }
public boolean required Resource Name ( Policy policy , String realm Name , String name ) { get Svc Type Name To Actions Map ( policy , realm Name ) ; return required Resource Name Service . contains ( name ) ; }
public Cursor new Cursor ( String store Name ) throws Unknown Store Exception { I Store < Byte Array , byte [ ] > store = get Store ( store Name ) ; int cursor Id = rpc Service . get Transaction Id ( ) ; Cursor cursor = new Cursor ( cursor Id , store . entries ( ) ) ; cursor Map . put ( Integer . value Of ( cursor Id ) , cursor ) ; return cursor ; }
public String validation For Bifurcation ( final Property Impl property Model , final Basic Property basic Property , final String reason ) { final List < Property Status Values > children = property Status Values DAO . get Property Status Values By Reference Basic Property ( basic Property ) ; final Boolean parent Bifurcated = is Property Bifurcated ( basic Property ) ; final Boolean children Created = ! children . is Empty ( ) ; String error Msg = null ; if ( PROPERTY MODIFY REASON BIFURCATE . equals Ignore Case ( reason ) ) { if ( parent Bifurcated && ! children Created ) error Msg = STRING ; } else if ( PROPERTY MODIFY REASON ADD OR ALTER . equals Ignore Case ( reason ) ) { if ( ! children Created ) { if ( parent Bifurcated ) error Msg = STRING ; } else if ( ! parent Bifurcated ) error Msg = STRING ; } else if ( PROP CREATE RSN BIFUR . equals ( reason ) ) if ( parent Bifurcated ) get Latest History Property ( basic Property . get Upic No ( ) ) ; else basic Property . get Active Property ( ) ; return error Msg ; }
public Short Component Raster ( Sample Model sample Model , Point origin ) { this ( sample Model , sample Model . create Data Buffer ( ) , new Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
public Short Component Raster ( Sample Model sample Model , Point origin ) { this ( sample Model , sample Model . create Data Buffer ( ) , new Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
public static String indent ( int indent ) { String Buffer s = new String Buffer ( ) ; for ( int i = NUM ; i < indent ; i ++ ) { s . append ( STRING ) ; } return s . to String ( ) ; }
private void check Outdated Movie Details ( Cursor cursor ) { if ( has Issued Outdated Refresh ) return ; cursor . move To First ( ) ; long last Updated = cursor . get Long ( Movie Details Query . UPDATED ) ; if ( System . current Time Millis ( ) > last Updated + Settings . DB UPDATE INTERVAL ) { has Issued Outdated Refresh = BOOL ; start Sync ( BOOL ) ; } }
private void check Outdated Movie Details ( Cursor cursor ) { if ( has Issued Outdated Refresh ) return ; cursor . move To First ( ) ; long last Updated = cursor . get Long ( Movie Details Query . UPDATED ) ; if ( System . current Time Millis ( ) > last Updated + Settings . DB UPDATE INTERVAL ) { has Issued Outdated Refresh = BOOL ; start Sync ( BOOL ) ; } }
private Pie Data generate Data Pie ( int cnt ) { Array List < Entry > entries = new Array List < Entry > ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { entries . add ( new Entry ( ( int ) ( Math . random ( ) * NUM ) + NUM , i ) ) ; } Pie Data Set d = new Pie Data Set ( entries , STRING ) ; d . set Slice Space ( NUM ) ; d . set Colors ( Color Template . VORDIPLOM COLORS ) ; Pie Data cd = new Pie Data ( get Quarters ( ) , d ) ; return cd ; }
public String node Label ( ) { String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; sb . append ( Formatter . convert ( alpha ) ) ; sb . append ( STRING ) ; sb . append ( Formatter . convert ( beta ) ) ; if ( set ) { sb . append ( STRING ) ; sb . append ( Formatter . convert ( value ) ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
public String node Label ( ) { String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; sb . append ( Formatter . convert ( alpha ) ) ; sb . append ( STRING ) ; sb . append ( Formatter . convert ( beta ) ) ; if ( set ) { sb . append ( STRING ) ; sb . append ( Formatter . convert ( value ) ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
public String node Label ( ) { String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; sb . append ( Formatter . convert ( alpha ) ) ; sb . append ( STRING ) ; sb . append ( Formatter . convert ( beta ) ) ; if ( set ) { sb . append ( STRING ) ; sb . append ( Formatter . convert ( value ) ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
public String node Label ( ) { String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; sb . append ( Formatter . convert ( alpha ) ) ; sb . append ( STRING ) ; sb . append ( Formatter . convert ( beta ) ) ; if ( set ) { sb . append ( STRING ) ; sb . append ( Formatter . convert ( value ) ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
public char [ ] read Password ( ) { synchronized ( CONSOLE LOCK ) { int previous State = set Echo ( BOOL , NUM ) ; try { String password = read Line ( ) ; writer . println ( ) ; return ( password == null ) ? null : password . to Char Array ( ) ; } finally { set Echo ( BOOL , previous State ) ; } } }
public static void delete File Tree With Retry ( Path dir ) throws IO Exception { IO Exception ioe = null ; final List < IO Exception > excs = delete File Tree Unchecked ( dir ) ; if ( ! excs . is Empty ( ) ) { ioe = excs . remove ( NUM ) ; for ( IO Exception x : excs ) ioe . add Suppressed ( x ) ; } if ( ioe != null ) throw ioe ; }
public Messages ( String name ) { this ( ( Messages ) null , name ) ; }
public Messages ( String name ) { this ( ( Messages ) null , name ) ; }
public String to String ( ) { return label . to String ( ) ; }
public String to String ( ) { return label . to String ( ) ; }
public String to String ( ) { return label . to String ( ) ; }
public String to String ( ) { return label . to String ( ) ; }
public Str Builder delete First ( String str ) { int len = ( str == null ? NUM : str . length ( ) ) ; if ( len > NUM ) { int index = index Of ( str , NUM ) ; if ( index >= NUM ) { delete Impl ( index , index + len , len ) ; } } return this ; }
public Str Builder delete First ( String str ) { int len = ( str == null ? NUM : str . length ( ) ) ; if ( len > NUM ) { int index = index Of ( str , NUM ) ; if ( index >= NUM ) { delete Impl ( index , index + len , len ) ; } } return this ; }
public Str Builder delete First ( String str ) { int len = ( str == null ? NUM : str . length ( ) ) ; if ( len > NUM ) { int index = index Of ( str , NUM ) ; if ( index >= NUM ) { delete Impl ( index , index + len , len ) ; } } return this ; }
public void add ( long start , long end , Sequence Name Locus region ) { if ( m Size == m Starts . length ) { final int new Len = m Starts . length * NUM / NUM + NUM ; m Starts = Arrays . copy Of ( m Starts , new Len ) ; m Ends = Arrays . copy Of ( m Ends , new Len ) ; m Regions = Arrays . copy Of ( m Regions , new Len ) ; } m Starts [ m Size ] = start ; m Ends [ m Size ] = end ; m Regions [ m Size ] = region ; m Size ++ ; }
public static String date To Header String ( Date dat ) { Simple Date Format fmt = new Simple Date Format ( HTTP FORMAT , Locale . US ) ; fmt . set Time Zone ( GMT ZONE ) ; return ( fmt . format ( dat ) ) ; }
public static String date To Header String ( Date dat ) { Simple Date Format fmt = new Simple Date Format ( HTTP FORMAT , Locale . US ) ; fmt . set Time Zone ( GMT ZONE ) ; return ( fmt . format ( dat ) ) ; }
public void add Mouse Listener ( Global Mouse Listener listener ) { listeners . add ( listener ) ; }
private static long free Space Calculation ( String path ) { Stat Fs stat = new Stat Fs ( path ) ; long block Size = stat . get Block Size ( ) ; long available Blocks = stat . get Available Blocks ( ) ; return available Blocks * block Size / NUM ; }
public static List < URI > ensure One Snapshot Per Replication Group ( List < URI > snapshot UR Is , Db Client db Client ) { List < URI > filtered Snapshot UR Is = new Array List < > ( ) ; Set < String > replication Groups = new Hash Set < > ( ) ; Iterator < Block Snapshot > snapshot Iter = db Client . query Iterative Objects ( Block Snapshot . class , snapshot UR Is ) ; while ( snapshot Iter . has Next ( ) ) { Block Snapshot snapshot = snapshot Iter . next ( ) ; String rep Grp Instance = snapshot . get Replication Group Instance ( ) ; if ( replication Groups . contains ( rep Grp Instance ) ) { continue ; } replication Groups . add ( rep Grp Instance ) ; filtered Snapshot UR Is . add ( snapshot . get Id ( ) ) ; } return filtered Snapshot UR Is ; }
public MV Map < K , V > open Version ( long version ) { if ( read Only ) { throw Data Utils . new Unsupported Operation Exception ( STRING + STRING ) ; } Data Utils . check Argument ( version >= create Version , STRING , version , create Version ) ; Page newest = null ; Page r = root ; if ( version >= r . get Version ( ) && ( version == write Version || r . get Version ( ) >= NUM || version <= create Version || store . get File Store ( ) == null ) ) { newest = r ; } else { Page last = old Roots . peek First ( ) ; if ( last == null || version < last . get Version ( ) ) { return store . open Map Version ( version , id , this ) ; } Iterator < Page > it = old Roots . iterator ( ) ; while ( it . has Next ( ) ) { Page p = it . next ( ) ; if ( p . get Version ( ) > version ) { break ; } last = p ; } newest = last ; } MV Map < K , V > m = open Read Only ( ) ; m . root = newest ; return m ; }
@ Suppress Lint ( STRING ) public Long Hash Set ( Long Hash Set map ) { m mask = map . m mask ; m fill Factor = map . m fill Factor ; m threshold = map . m threshold ; m size = map . m size ; m has Free Key = map . m has Free Key ; if ( Build . VERSION . SDK INT >= Build . VERSION CODES . GINGERBREAD ) { m data = Arrays . copy Of ( map . m data , map . m data . length ) ; } else { m data = new long [ map . m data . length ] ; System . arraycopy ( map . m data , NUM , m data , NUM , m data . length ) ; } }
@ Override public boolean equals ( Object o ) { if ( o == null ) { return BOOL ; } if ( ! ( o instanceof Collection ) ) { return BOOL ; } final Collection < ? > other = ( Collection < ? > ) o ; final Iterator < ? > self iter = iterator ( ) ; final Iterator < ? > othr iter = other . iterator ( ) ; while ( self iter . has Next ( ) && othr iter . has Next ( ) ) { if ( ! Objects . equals ( self iter . next ( ) , othr iter . next ( ) ) ) return BOOL ; } return ! ( self iter . has Next ( ) || othr iter . has Next ( ) ) ; }
@ Override public boolean equals ( Object o ) { if ( o == null ) { return BOOL ; } if ( ! ( o instanceof Collection ) ) { return BOOL ; } final Collection < ? > other = ( Collection < ? > ) o ; final Iterator < ? > self iter = iterator ( ) ; final Iterator < ? > othr iter = other . iterator ( ) ; while ( self iter . has Next ( ) && othr iter . has Next ( ) ) { if ( ! Objects . equals ( self iter . next ( ) , othr iter . next ( ) ) ) return BOOL ; } return ! ( self iter . has Next ( ) || othr iter . has Next ( ) ) ; }
@ Override public boolean equals ( Object o ) { if ( o == null ) { return BOOL ; } if ( ! ( o instanceof Collection ) ) { return BOOL ; } final Collection < ? > other = ( Collection < ? > ) o ; final Iterator < ? > self iter = iterator ( ) ; final Iterator < ? > othr iter = other . iterator ( ) ; while ( self iter . has Next ( ) && othr iter . has Next ( ) ) { if ( ! Objects . equals ( self iter . next ( ) , othr iter . next ( ) ) ) return BOOL ; } return ! ( self iter . has Next ( ) || othr iter . has Next ( ) ) ; }
@ Override public boolean equals ( Object o ) { if ( o == null ) { return BOOL ; } if ( ! ( o instanceof Collection ) ) { return BOOL ; } final Collection < ? > other = ( Collection < ? > ) o ; final Iterator < ? > self iter = iterator ( ) ; final Iterator < ? > othr iter = other . iterator ( ) ; while ( self iter . has Next ( ) && othr iter . has Next ( ) ) { if ( ! Objects . equals ( self iter . next ( ) , othr iter . next ( ) ) ) return BOOL ; } return ! ( self iter . has Next ( ) || othr iter . has Next ( ) ) ; }
@ Override public boolean equals ( Object o ) { if ( o == null ) { return BOOL ; } if ( ! ( o instanceof Collection ) ) { return BOOL ; } final Collection < ? > other = ( Collection < ? > ) o ; final Iterator < ? > self iter = iterator ( ) ; final Iterator < ? > othr iter = other . iterator ( ) ; while ( self iter . has Next ( ) && othr iter . has Next ( ) ) { if ( ! Objects . equals ( self iter . next ( ) , othr iter . next ( ) ) ) return BOOL ; } return ! ( self iter . has Next ( ) || othr iter . has Next ( ) ) ; }
@ Override public boolean equals ( Object o ) { if ( o == null ) { return BOOL ; } if ( ! ( o instanceof Collection ) ) { return BOOL ; } final Collection < ? > other = ( Collection < ? > ) o ; final Iterator < ? > self iter = iterator ( ) ; final Iterator < ? > othr iter = other . iterator ( ) ; while ( self iter . has Next ( ) && othr iter . has Next ( ) ) { if ( ! Objects . equals ( self iter . next ( ) , othr iter . next ( ) ) ) return BOOL ; } return ! ( self iter . has Next ( ) || othr iter . has Next ( ) ) ; }
@ Override public boolean equals ( Object o ) { if ( o == null ) { return BOOL ; } if ( ! ( o instanceof Collection ) ) { return BOOL ; } final Collection < ? > other = ( Collection < ? > ) o ; final Iterator < ? > self iter = iterator ( ) ; final Iterator < ? > othr iter = other . iterator ( ) ; while ( self iter . has Next ( ) && othr iter . has Next ( ) ) { if ( ! Objects . equals ( self iter . next ( ) , othr iter . next ( ) ) ) return BOOL ; } return ! ( self iter . has Next ( ) || othr iter . has Next ( ) ) ; }
public Mock Response clear Headers ( ) { headers . clear ( ) ; return this ; }
public static boolean point Outside Pref Size ( J Table table , int row , int column , Point p ) { if ( table . convert Column Index To Model ( column ) != NUM || row == - NUM ) { return BOOL ; } Table Cell Renderer tcr = table . get Cell Renderer ( row , column ) ; Object value = table . get Value At ( row , column ) ; Component cell = tcr . get Table Cell Renderer Component ( table , value , BOOL , BOOL , row , column ) ; Dimension item Size = cell . get Preferred Size ( ) ; Rectangle cell Bounds = table . get Cell Rect ( row , column , BOOL ) ; cell Bounds . width = item Size . width ; cell Bounds . height = item Size . height ; assert ( p . x >= cell Bounds . x && p . y >= cell Bounds . y ) ; return p . x > cell Bounds . x + cell Bounds . width || p . y > cell Bounds . y + cell Bounds . height ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING + get Stemmer List ( NUM , STRING ) , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING + get Stemmer List ( NUM , STRING ) , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
private void paint Upper Thumb ( Graphics g ) { Rectangle knob Bounds = upper Thumb Rect ; int w = knob Bounds . width ; int h = knob Bounds . height ; Graphics 2 D g2 d = ( Graphics 2 D ) g . create ( ) ; Shape thumb Shape = create Thumb Shape ( w - NUM , h - NUM , BOOL ) ; g2 d . set Rendering Hint ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; g2 d . translate ( knob Bounds . x , knob Bounds . y ) ; g2 d . set Color ( Color . LIGHT GRAY ) ; g2 d . fill ( thumb Shape ) ; g2 d . set Color ( Color . GRAY ) ; g2 d . draw ( thumb Shape ) ; g2 d . dispose ( ) ; }
private void paint Upper Thumb ( Graphics g ) { Rectangle knob Bounds = upper Thumb Rect ; int w = knob Bounds . width ; int h = knob Bounds . height ; Graphics 2 D g2 d = ( Graphics 2 D ) g . create ( ) ; Shape thumb Shape = create Thumb Shape ( w - NUM , h - NUM , BOOL ) ; g2 d . set Rendering Hint ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; g2 d . translate ( knob Bounds . x , knob Bounds . y ) ; g2 d . set Color ( Color . LIGHT GRAY ) ; g2 d . fill ( thumb Shape ) ; g2 d . set Color ( Color . GRAY ) ; g2 d . draw ( thumb Shape ) ; g2 d . dispose ( ) ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
public static boolean save ( File file , String content ) { boolean result ; Buffered Writer writer ; writer = null ; try { writer = new Buffered Writer ( new File Writer ( file ) ) ; writer . write ( content ) ; writer . flush ( ) ; result = BOOL ; } catch ( Exception e ) { e . print Stack Trace ( ) ; result = BOOL ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( Exception e ) { } } } return result ; }
public void add Model ( Navigation Model other ) { for ( Group group : other . get Groups ( ) ) { add Group ( group ) ; } for ( View view : other . get Views ( ) ) { add View ( view ) ; } }
public void add Model ( Navigation Model other ) { for ( Group group : other . get Groups ( ) ) { add Group ( group ) ; } for ( View view : other . get Views ( ) ) { add View ( view ) ; } }
public void add Model ( Navigation Model other ) { for ( Group group : other . get Groups ( ) ) { add Group ( group ) ; } for ( View view : other . get Views ( ) ) { add View ( view ) ; } }
public static Digital Output digital Output ( int port ) { return dio Registrar . fetch ( port , Digital Output . class , null ) ; }
public static String normalize Request Uri ( Http Servlet Request http Request ) { String ret Val = http Request . get Request URI ( ) ; String context Path = http Request . get Context Path ( ) ; if ( ret Val . starts With ( context Path ) ) { ret Val = ret Val . substring ( context Path . length ( ) ) ; } String servlet Path = http Request . get Servlet Path ( ) ; if ( ret Val . starts With ( servlet Path ) ) { ret Val = ret Val . substring ( servlet Path . length ( ) ) ; } return ret Val ; }
public static String normalize Request Uri ( Http Servlet Request http Request ) { String ret Val = http Request . get Request URI ( ) ; String context Path = http Request . get Context Path ( ) ; if ( ret Val . starts With ( context Path ) ) { ret Val = ret Val . substring ( context Path . length ( ) ) ; } String servlet Path = http Request . get Servlet Path ( ) ; if ( ret Val . starts With ( servlet Path ) ) { ret Val = ret Val . substring ( servlet Path . length ( ) ) ; } return ret Val ; }
public static String normalize Request Uri ( Http Servlet Request http Request ) { String ret Val = http Request . get Request URI ( ) ; String context Path = http Request . get Context Path ( ) ; if ( ret Val . starts With ( context Path ) ) { ret Val = ret Val . substring ( context Path . length ( ) ) ; } String servlet Path = http Request . get Servlet Path ( ) ; if ( ret Val . starts With ( servlet Path ) ) { ret Val = ret Val . substring ( servlet Path . length ( ) ) ; } return ret Val ; }
public static String normalize Request Uri ( Http Servlet Request http Request ) { String ret Val = http Request . get Request URI ( ) ; String context Path = http Request . get Context Path ( ) ; if ( ret Val . starts With ( context Path ) ) { ret Val = ret Val . substring ( context Path . length ( ) ) ; } String servlet Path = http Request . get Servlet Path ( ) ; if ( ret Val . starts With ( servlet Path ) ) { ret Val = ret Val . substring ( servlet Path . length ( ) ) ; } return ret Val ; }
public static String normalize Request Uri ( Http Servlet Request http Request ) { String ret Val = http Request . get Request URI ( ) ; String context Path = http Request . get Context Path ( ) ; if ( ret Val . starts With ( context Path ) ) { ret Val = ret Val . substring ( context Path . length ( ) ) ; } String servlet Path = http Request . get Servlet Path ( ) ; if ( ret Val . starts With ( servlet Path ) ) { ret Val = ret Val . substring ( servlet Path . length ( ) ) ; } return ret Val ; }
public static String normalize Request Uri ( Http Servlet Request http Request ) { String ret Val = http Request . get Request URI ( ) ; String context Path = http Request . get Context Path ( ) ; if ( ret Val . starts With ( context Path ) ) { ret Val = ret Val . substring ( context Path . length ( ) ) ; } String servlet Path = http Request . get Servlet Path ( ) ; if ( ret Val . starts With ( servlet Path ) ) { ret Val = ret Val . substring ( servlet Path . length ( ) ) ; } return ret Val ; }
public static String normalize Request Uri ( Http Servlet Request http Request ) { String ret Val = http Request . get Request URI ( ) ; String context Path = http Request . get Context Path ( ) ; if ( ret Val . starts With ( context Path ) ) { ret Val = ret Val . substring ( context Path . length ( ) ) ; } String servlet Path = http Request . get Servlet Path ( ) ; if ( ret Val . starts With ( servlet Path ) ) { ret Val = ret Val . substring ( servlet Path . length ( ) ) ; } return ret Val ; }
public static String normalize Request Uri ( Http Servlet Request http Request ) { String ret Val = http Request . get Request URI ( ) ; String context Path = http Request . get Context Path ( ) ; if ( ret Val . starts With ( context Path ) ) { ret Val = ret Val . substring ( context Path . length ( ) ) ; } String servlet Path = http Request . get Servlet Path ( ) ; if ( ret Val . starts With ( servlet Path ) ) { ret Val = ret Val . substring ( servlet Path . length ( ) ) ; } return ret Val ; }
public boolean remove All ( ) { lock . lock ( ) ; try { if ( cookie Jar . is Empty ( ) ) { return BOOL ; } cookie Jar . clear ( ) ; domain Index . clear ( ) ; uri Index . clear ( ) ; } finally { lock . unlock ( ) ; } return BOOL ; }
public boolean remove All ( ) { lock . lock ( ) ; try { if ( cookie Jar . is Empty ( ) ) { return BOOL ; } cookie Jar . clear ( ) ; domain Index . clear ( ) ; uri Index . clear ( ) ; } finally { lock . unlock ( ) ; } return BOOL ; }
public void add ( double x , double y ) { if ( len == data . length ) { data = Arrays . copy Of ( data , len << NUM ) ; } data [ len ++ ] = x ; data [ len ++ ] = y ; minx = Math . min ( minx , x ) ; maxx = Math . max ( maxx , x ) ; miny = Math . min ( miny , y ) ; maxy = Math . max ( maxy , y ) ; }
public void make Immutable ( ) { if ( ! mutable ) { return ; } mutable = BOOL ; if ( ( content != null ) && ( ! content . is Empty ( ) ) ) { content = Collections . unmodifiable List ( content ) ; } }
private void skip Entry ( ) throws Parsing Exception , IO Exception { while ( lookahead != STRING ) { switch ( lookahead ) { case Stream Tokenizer . TT NUMBER : throw new Parsing Exception ( st . lineno ( ) , STRING , Resources Mgr . get String ( STRING ) + String . value Of ( st . nval ) ) ; case Stream Tokenizer . TT EOF : throw new Parsing Exception ( Resources Mgr . get String ( STRING ) ) ; default : lookahead = st . next Token ( ) ; } } }
private void skip Entry ( ) throws Parsing Exception , IO Exception { while ( lookahead != STRING ) { switch ( lookahead ) { case Stream Tokenizer . TT NUMBER : throw new Parsing Exception ( st . lineno ( ) , STRING , Resources Mgr . get String ( STRING ) + String . value Of ( st . nval ) ) ; case Stream Tokenizer . TT EOF : throw new Parsing Exception ( Resources Mgr . get String ( STRING ) ) ; default : lookahead = st . next Token ( ) ; } } }
private void skip Entry ( ) throws Parsing Exception , IO Exception { while ( lookahead != STRING ) { switch ( lookahead ) { case Stream Tokenizer . TT NUMBER : throw new Parsing Exception ( st . lineno ( ) , STRING , Resources Mgr . get String ( STRING ) + String . value Of ( st . nval ) ) ; case Stream Tokenizer . TT EOF : throw new Parsing Exception ( Resources Mgr . get String ( STRING ) ) ; default : lookahead = st . next Token ( ) ; } } }
public void write Line ( float [ ] column ) { String str = Float . to String ( column [ NUM ] ) ; for ( int i = NUM ; i < column . length ; ++ i ) { str += STRING + column [ i ] ; } writer . println ( str ) ; }
public static void send Current Warning ( Object source , Throwable e ) { Warning System warning = get Current ( ) ; if ( warning != null ) warning . send Warning ( source , e ) ; else { e . print Stack Trace ( ) ; log . log ( Level . WARNING , e . to String ( ) , e ) ; } }
void start Prediction ( ) { time Stamp = System . current Time Millis ( ) ; }
public void remove Tracking Icon ( Object tag ) { if ( tracking Icons != null && tracking Icons . remove ( tag ) ) { repaint ( ) ; } }
protected void flag To Remove From Maintenance Queue ( Node Port Tuple npt ) { if ( to Remove From Maintenance Queue . contains ( npt ) == BOOL ) { to Remove From Maintenance Queue . add ( npt ) ; } }
protected String read String UTF 16 Z ( int addr ) { if ( addr == NUM ) { return null ; } I Memory Reader memory Reader = Memory Reader . get Memory Reader ( addr , NUM ) ; String Builder s = new String Builder ( ) ; while ( BOOL ) { int char 16 = memory Reader . read Next ( ) ; if ( char 16 == NUM ) { break ; } byte [ ] bytes = new byte [ NUM ] ; bytes [ NUM ] = ( byte ) char 16 ; bytes [ NUM ] = ( byte ) ( char 16 > > NUM ) ; s . append ( new String ( bytes , charset 16 ) ) ; } return s . to String ( ) ; }
public synchronized void accessed ( Object object ) { history List . remove ( object ) ; history List . add ( object ) ; }
private void calculate C ( ) { int length = m Specification . get Extrema Count ( ) - NUM ; m Ideal Frequency Response = new double [ length ] ; double sign = NUM ; for ( int k = NUM ; k < length ; k ++ ) { if ( k < m Extremal Indices . size ( ) ) { int index = m Extremal Indices . get ( k ) ; m Ideal Frequency Response [ k ] = m Grid . get Desired Response ( ) [ index ] - ( sign * m Delta / m Grid . get Weight ( ) [ index ] ) ; sign = - sign ; } } }
private void calculate C ( ) { int length = m Specification . get Extrema Count ( ) - NUM ; m Ideal Frequency Response = new double [ length ] ; double sign = NUM ; for ( int k = NUM ; k < length ; k ++ ) { if ( k < m Extremal Indices . size ( ) ) { int index = m Extremal Indices . get ( k ) ; m Ideal Frequency Response [ k ] = m Grid . get Desired Response ( ) [ index ] - ( sign * m Delta / m Grid . get Weight ( ) [ index ] ) ; sign = - sign ; } } }
private Response do RSET ( SMTP Session session , String argument ) { if ( ( argument == null ) || ( argument . length ( ) == NUM ) ) { session . reset State ( ) ; return OK ; } else { return SYNTAX ERROR ; } }
private static boolean has Pano Prefix ( Context context , Uri src ) { String name = get True Filename ( context , src ) ; return name != null && name . starts With ( PREFIX PANO ) ; }
private static boolean has Pano Prefix ( Context context , Uri src ) { String name = get True Filename ( context , src ) ; return name != null && name . starts With ( PREFIX PANO ) ; }
public final void add Path ( @ Not Null Android Studio Wizard Path path ) { my Paths . add ( path ) ; path . attach To Wizard ( this ) ; my Path List Iterator = new Path Iterator ( my Paths ) ; }
public static Logger log ( ) { if ( nervous system == null ) nervous system = new Logger ( STRING , Logger . ATTR TIME | Logger . ATTR COLOR ) ; return nervous system ; }
private void init Scrollbar ( ) { m scrollbar . add Adjustment Listener ( m listener ) ; m bottom Scrollbar . add Adjustment Listener ( m listener ) ; add ( m scrollbar , Border Layout . EAST ) ; add ( m bottom Scrollbar , Border Layout . SOUTH ) ; }
private void init Scrollbar ( ) { m scrollbar . add Adjustment Listener ( m listener ) ; m bottom Scrollbar . add Adjustment Listener ( m listener ) ; add ( m scrollbar , Border Layout . EAST ) ; add ( m bottom Scrollbar , Border Layout . SOUTH ) ; }
PBES 1 Core ( String cipher Alg ) throws No Such Algorithm Exception , No Such Padding Exception { algo = cipher Alg ; if ( algo . equals ( STRING ) ) { cipher = new Cipher Core ( new DES Crypt ( ) , DES Constants . DES BLOCK SIZE ) ; } else if ( algo . equals ( STRING ) ) { cipher = new Cipher Core ( new DE Sede Crypt ( ) , DES Constants . DES BLOCK SIZE ) ; } else { throw new No Such Algorithm Exception ( STRING + STRING + algo ) ; } cipher . set Mode ( STRING ) ; cipher . set Padding ( STRING ) ; md = Message Digest . get Instance ( STRING ) ; }
PBES 1 Core ( String cipher Alg ) throws No Such Algorithm Exception , No Such Padding Exception { algo = cipher Alg ; if ( algo . equals ( STRING ) ) { cipher = new Cipher Core ( new DES Crypt ( ) , DES Constants . DES BLOCK SIZE ) ; } else if ( algo . equals ( STRING ) ) { cipher = new Cipher Core ( new DE Sede Crypt ( ) , DES Constants . DES BLOCK SIZE ) ; } else { throw new No Such Algorithm Exception ( STRING + STRING + algo ) ; } cipher . set Mode ( STRING ) ; cipher . set Padding ( STRING ) ; md = Message Digest . get Instance ( STRING ) ; }
public abstract boolean can User Initiate Move From ( int square Id ) ;
public abstract boolean can User Initiate Move From ( int square Id ) ;
public static byte [ ] encrypt Password ( final String password , final byte [ ] seed ) throws No Such Algorithm Exception { if ( password == null || password . equals ( STRING ) ) { return new byte [ NUM ] ; } final Message Digest message Digest = Message Digest . get Instance ( STRING ) ; final byte [ ] stage 1 = message Digest . digest ( password . get Bytes ( ) ) ; message Digest . reset ( ) ; final byte [ ] stage 2 = message Digest . digest ( stage 1 ) ; message Digest . reset ( ) ; message Digest . update ( seed ) ; message Digest . update ( stage 2 ) ; final byte [ ] digest = message Digest . digest ( ) ; final byte [ ] return Bytes = new byte [ digest . length ] ; for ( int i = NUM ; i < digest . length ; i ++ ) { return Bytes [ i ] = ( byte ) ( stage 1 [ i ] ^ digest [ i ] ) ; } return return Bytes ; }
public static byte [ ] encrypt Password ( final String password , final byte [ ] seed ) throws No Such Algorithm Exception { if ( password == null || password . equals ( STRING ) ) { return new byte [ NUM ] ; } final Message Digest message Digest = Message Digest . get Instance ( STRING ) ; final byte [ ] stage 1 = message Digest . digest ( password . get Bytes ( ) ) ; message Digest . reset ( ) ; final byte [ ] stage 2 = message Digest . digest ( stage 1 ) ; message Digest . reset ( ) ; message Digest . update ( seed ) ; message Digest . update ( stage 2 ) ; final byte [ ] digest = message Digest . digest ( ) ; final byte [ ] return Bytes = new byte [ digest . length ] ; for ( int i = NUM ; i < digest . length ; i ++ ) { return Bytes [ i ] = ( byte ) ( stage 1 [ i ] ^ digest [ i ] ) ; } return return Bytes ; }
public static byte [ ] encrypt Password ( final String password , final byte [ ] seed ) throws No Such Algorithm Exception { if ( password == null || password . equals ( STRING ) ) { return new byte [ NUM ] ; } final Message Digest message Digest = Message Digest . get Instance ( STRING ) ; final byte [ ] stage 1 = message Digest . digest ( password . get Bytes ( ) ) ; message Digest . reset ( ) ; final byte [ ] stage 2 = message Digest . digest ( stage 1 ) ; message Digest . reset ( ) ; message Digest . update ( seed ) ; message Digest . update ( stage 2 ) ; final byte [ ] digest = message Digest . digest ( ) ; final byte [ ] return Bytes = new byte [ digest . length ] ; for ( int i = NUM ; i < digest . length ; i ++ ) { return Bytes [ i ] = ( byte ) ( stage 1 [ i ] ^ digest [ i ] ) ; } return return Bytes ; }
public static byte [ ] encrypt Password ( final String password , final byte [ ] seed ) throws No Such Algorithm Exception { if ( password == null || password . equals ( STRING ) ) { return new byte [ NUM ] ; } final Message Digest message Digest = Message Digest . get Instance ( STRING ) ; final byte [ ] stage 1 = message Digest . digest ( password . get Bytes ( ) ) ; message Digest . reset ( ) ; final byte [ ] stage 2 = message Digest . digest ( stage 1 ) ; message Digest . reset ( ) ; message Digest . update ( seed ) ; message Digest . update ( stage 2 ) ; final byte [ ] digest = message Digest . digest ( ) ; final byte [ ] return Bytes = new byte [ digest . length ] ; for ( int i = NUM ; i < digest . length ; i ++ ) { return Bytes [ i ] = ( byte ) ( stage 1 [ i ] ^ digest [ i ] ) ; } return return Bytes ; }
public static byte [ ] encrypt Password ( final String password , final byte [ ] seed ) throws No Such Algorithm Exception { if ( password == null || password . equals ( STRING ) ) { return new byte [ NUM ] ; } final Message Digest message Digest = Message Digest . get Instance ( STRING ) ; final byte [ ] stage 1 = message Digest . digest ( password . get Bytes ( ) ) ; message Digest . reset ( ) ; final byte [ ] stage 2 = message Digest . digest ( stage 1 ) ; message Digest . reset ( ) ; message Digest . update ( seed ) ; message Digest . update ( stage 2 ) ; final byte [ ] digest = message Digest . digest ( ) ; final byte [ ] return Bytes = new byte [ digest . length ] ; for ( int i = NUM ; i < digest . length ; i ++ ) { return Bytes [ i ] = ( byte ) ( stage 1 [ i ] ^ digest [ i ] ) ; } return return Bytes ; }
public static byte [ ] encrypt Password ( final String password , final byte [ ] seed ) throws No Such Algorithm Exception { if ( password == null || password . equals ( STRING ) ) { return new byte [ NUM ] ; } final Message Digest message Digest = Message Digest . get Instance ( STRING ) ; final byte [ ] stage 1 = message Digest . digest ( password . get Bytes ( ) ) ; message Digest . reset ( ) ; final byte [ ] stage 2 = message Digest . digest ( stage 1 ) ; message Digest . reset ( ) ; message Digest . update ( seed ) ; message Digest . update ( stage 2 ) ; final byte [ ] digest = message Digest . digest ( ) ; final byte [ ] return Bytes = new byte [ digest . length ] ; for ( int i = NUM ; i < digest . length ; i ++ ) { return Bytes [ i ] = ( byte ) ( stage 1 [ i ] ^ digest [ i ] ) ; } return return Bytes ; }
public static boolean is Same Event ( Calendar Event Model model , Calendar Event Model original Model ) { if ( original Model == null ) { return BOOL ; } if ( model . m Calendar Id != original Model . m Calendar Id ) { return BOOL ; } if ( model . m Id != original Model . m Id ) { return BOOL ; } return BOOL ; }
public static boolean is Same Event ( Calendar Event Model model , Calendar Event Model original Model ) { if ( original Model == null ) { return BOOL ; } if ( model . m Calendar Id != original Model . m Calendar Id ) { return BOOL ; } if ( model . m Id != original Model . m Id ) { return BOOL ; } return BOOL ; }
public static boolean is Same Event ( Calendar Event Model model , Calendar Event Model original Model ) { if ( original Model == null ) { return BOOL ; } if ( model . m Calendar Id != original Model . m Calendar Id ) { return BOOL ; } if ( model . m Id != original Model . m Id ) { return BOOL ; } return BOOL ; }
public static boolean is Same Event ( Calendar Event Model model , Calendar Event Model original Model ) { if ( original Model == null ) { return BOOL ; } if ( model . m Calendar Id != original Model . m Calendar Id ) { return BOOL ; } if ( model . m Id != original Model . m Id ) { return BOOL ; } return BOOL ; }
public static boolean is Same Event ( Calendar Event Model model , Calendar Event Model original Model ) { if ( original Model == null ) { return BOOL ; } if ( model . m Calendar Id != original Model . m Calendar Id ) { return BOOL ; } if ( model . m Id != original Model . m Id ) { return BOOL ; } return BOOL ; }
public static boolean is Same Event ( Calendar Event Model model , Calendar Event Model original Model ) { if ( original Model == null ) { return BOOL ; } if ( model . m Calendar Id != original Model . m Calendar Id ) { return BOOL ; } if ( model . m Id != original Model . m Id ) { return BOOL ; } return BOOL ; }
public static boolean is Same Event ( Calendar Event Model model , Calendar Event Model original Model ) { if ( original Model == null ) { return BOOL ; } if ( model . m Calendar Id != original Model . m Calendar Id ) { return BOOL ; } if ( model . m Id != original Model . m Id ) { return BOOL ; } return BOOL ; }
public void add Entry ( Entry e , int data Set Index ) { if ( e == null || data Set Index < NUM || data Set Index >= m Data Sets . size ( ) ) return ; I Data Set set = m Data Sets . get ( data Set Index ) ; if ( ! set . add Entry ( e ) ) return ; calc Min Max ( e , set . get Axis Dependency ( ) ) ; }
public void add Entry ( Entry e , int data Set Index ) { if ( e == null || data Set Index < NUM || data Set Index >= m Data Sets . size ( ) ) return ; I Data Set set = m Data Sets . get ( data Set Index ) ; if ( ! set . add Entry ( e ) ) return ; calc Min Max ( e , set . get Axis Dependency ( ) ) ; }
protected void add Name Definer ( Psi Element definer ) { my Definers . add ( definer ) ; }
protected void Build FD Array Used ( int Font ) { int [ ] FD Select = fonts [ Font ] . FD Select ; for ( Integer glyphs In List 1 : glyphs In List ) { int glyph = ( int ) glyphs In List 1 ; int FD = FD Select [ glyph ] ; FD Array Used . add ( FD ) ; } }
protected void Build FD Array Used ( int Font ) { int [ ] FD Select = fonts [ Font ] . FD Select ; for ( Integer glyphs In List 1 : glyphs In List ) { int glyph = ( int ) glyphs In List 1 ; int FD = FD Select [ glyph ] ; FD Array Used . add ( FD ) ; } }
public static String remove Last ( String input , int amount ) { if ( input . length ( ) >= amount ) { return input . substring ( NUM , input . length ( ) - amount ) ; } else { return input ; } }
protected File List files ( String dir ) { File List list = new File List ( ) ; add Files ( list , new File ( dir ) ) ; return list ; }
private static String [ ] split Components ( String str ) { List < String > l = new Array List < > ( ) ; int last = NUM ; int depth = NUM ; char [ ] chars = str . to Char Array ( ) ; for ( int i = NUM ; i < chars . length ; i ++ ) { switch ( chars [ i ] ) { case STRING : depth ++ ; break ; case STRING : depth -- ; break ; case STRING : if ( depth == NUM ) { String s = str . substring ( last , i ) ; l . add ( s ) ; last = i + NUM ; } break ; default : } } String s = str . substring ( last ) ; if ( s . length ( ) != NUM ) { l . add ( s ) ; } String [ ] rc = new String [ l . size ( ) ] ; l . to Array ( rc ) ; return rc ; }
private Property Mapping populate Property Mapping ( Extension Property ep ) { Property Mapping pm = mapping . get Field ( ep . get Qualname ( ) ) ; if ( pm == null ) { pm = new Property Mapping ( ) ; } pm . set Term ( ep ) ; return pm ; }
private Property Mapping populate Property Mapping ( Extension Property ep ) { Property Mapping pm = mapping . get Field ( ep . get Qualname ( ) ) ; if ( pm == null ) { pm = new Property Mapping ( ) ; } pm . set Term ( ep ) ; return pm ; }
public boolean load Properties ( URL url , Properties props ) { try { Input Stream props In = url . open Stream ( ) ; props . load ( props In ) ; return BOOL ; } catch ( java . io . IO Exception e ) { return BOOL ; } }
public boolean load Properties ( URL url , Properties props ) { try { Input Stream props In = url . open Stream ( ) ; props . load ( props In ) ; return BOOL ; } catch ( java . io . IO Exception e ) { return BOOL ; } }
public final void write ( String s ) throws IO Exception { write ( s , NUM , s . length ( ) ) ; }
public final void write ( String s ) throws IO Exception { write ( s , NUM , s . length ( ) ) ; }
public final void write ( String s ) throws IO Exception { write ( s , NUM , s . length ( ) ) ; }
protected long write Coded Values ( final Prefix Coder coder , final I Raba raba , final Byte 2 Symbol byte 2 symbol , final long [ ] coded Value Offset , final Output Bit Stream obs ) throws IO Exception { final int nvalues = raba . size ( ) ; if ( coded Value Offset != null ) { if ( coded Value Offset . length != nvalues + NUM ) throw new Illegal Argument Exception ( ) ; } long bits Written = NUM ; for ( int i = NUM ; i < nvalues ; i ++ ) { if ( coded Value Offset != null ) coded Value Offset [ i ] = bits Written ; final byte [ ] a = raba . get ( i ) ; if ( a != null ) { for ( byte b : a ) { final int symbol = byte 2 symbol . byte 2 symbol ( b ) ; if ( symbol == - NUM ) throw new Unsupported Operation Exception ( STRING + b ) ; bits Written += coder . encode ( symbol , obs ) ; } } } if ( coded Value Offset != null ) coded Value Offset [ nvalues ] = bits Written ; if ( log . is Debug Enabled ( ) ) log . debug ( STRING + Arrays . to String ( coded Value Offset ) ) ; return bits Written ; }
Grid Memcached Message ( ) { }
@ edu . umd . cs . findbugs . annotations . Suppress FB Warnings ( value = STRING , justification = STRING ) protected void purge Stream ( @ Nonnull java . io . Input Stream serial Stream ) throws java . io . IO Exception { int count = serial Stream . available ( ) ; log . debug ( STRING + count + STRING ) ; while ( count > NUM ) { serial Stream . skip ( count ) ; count = serial Stream . available ( ) ; } }
public void select Track ( int index ) { selected Track Index = index ; Exposed Track selected Track = tracks . get ( selected Track Index ) ; selected Variant Index = selected Track . default Variant Index ; variants = selected Track . variants ; variant Playlists = new Hls Media Playlist [ variants . length ] ; variant Last Playlist Load Times Ms = new long [ variants . length ] ; variant Blacklist Times = new long [ variants . length ] ; }
public void put ( int key , E value ) { int i = Container Helpers . binary Search ( m Keys , m Size , key ) ; if ( i >= NUM ) { m Values [ i ] = value ; } else { i = ~ i ; if ( i < m Size && m Values [ i ] == DELETED ) { m Keys [ i ] = key ; m Values [ i ] = value ; return ; } if ( m Garbage && m Size >= m Keys . length ) { gc ( ) ; i = ~ Container Helpers . binary Search ( m Keys , m Size , key ) ; } if ( m Size >= m Keys . length ) { int n = Array Utils . ideal Int Array Size ( m Size + NUM ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( m Keys , NUM , nkeys , NUM , m Keys . length ) ; System . arraycopy ( m Values , NUM , nvalues , NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } if ( m Size - i != NUM ) { System . arraycopy ( m Keys , i , m Keys , i + NUM , m Size - i ) ; System . arraycopy ( m Values , i , m Values , i + NUM , m Size - i ) ; } m Keys [ i ] = key ; m Values [ i ] = value ; m Size ++ ; } }
public static void delete Files ( File [ ] files , boolean wait ) { File Delete Task task = new File Delete Task ( files ) ; if ( wait ) task . run ( ) ; else { Thread t = new Thread ( task ) ; t . start ( ) ; } }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL ; } if ( ! super . equals ( obj ) ) { return BOOL ; } if ( ! ( obj instanceof Waterfall Bar Renderer ) ) { return BOOL ; } Waterfall Bar Renderer that = ( Waterfall Bar Renderer ) obj ; if ( ! Paint Utilities . equal ( this . first Bar Paint , that . first Bar Paint ) ) { return BOOL ; } if ( ! Paint Utilities . equal ( this . last Bar Paint , that . last Bar Paint ) ) { return BOOL ; } if ( ! Paint Utilities . equal ( this . positive Bar Paint , that . positive Bar Paint ) ) { return BOOL ; } if ( ! Paint Utilities . equal ( this . negative Bar Paint , that . negative Bar Paint ) ) { return BOOL ; } return BOOL ; }
protected static String timestr ( long time val , long total time ) { boolean neg ; long ms = NUM ; long sec = NUM ; long percent 10 ; String pad ; neg = time val < NUM ; if ( neg ) time val = - time val ; ms = time val % NUM ; sec = time val / NUM ; if ( sec < NUM ) pad = STRING ; else if ( sec < NUM ) pad = STRING ; else if ( sec < NUM ) pad = STRING ; else pad = STRING ; percent 10 = ( time val * NUM ) / total time ; return ( neg ? STRING : STRING ) + pad + sec + STRING + ( ( ms % NUM ) / NUM ) + ( ( ms % NUM ) / NUM ) + ( ms % NUM ) + STRING + STRING + percent 10 / NUM + STRING + percent 10 % NUM + STRING ; }
protected static String timestr ( long time val , long total time ) { boolean neg ; long ms = NUM ; long sec = NUM ; long percent 10 ; String pad ; neg = time val < NUM ; if ( neg ) time val = - time val ; ms = time val % NUM ; sec = time val / NUM ; if ( sec < NUM ) pad = STRING ; else if ( sec < NUM ) pad = STRING ; else if ( sec < NUM ) pad = STRING ; else pad = STRING ; percent 10 = ( time val * NUM ) / total time ; return ( neg ? STRING : STRING ) + pad + sec + STRING + ( ( ms % NUM ) / NUM ) + ( ( ms % NUM ) / NUM ) + ( ms % NUM ) + STRING + STRING + percent 10 / NUM + STRING + percent 10 % NUM + STRING ; }
protected static String timestr ( long time val , long total time ) { boolean neg ; long ms = NUM ; long sec = NUM ; long percent 10 ; String pad ; neg = time val < NUM ; if ( neg ) time val = - time val ; ms = time val % NUM ; sec = time val / NUM ; if ( sec < NUM ) pad = STRING ; else if ( sec < NUM ) pad = STRING ; else if ( sec < NUM ) pad = STRING ; else pad = STRING ; percent 10 = ( time val * NUM ) / total time ; return ( neg ? STRING : STRING ) + pad + sec + STRING + ( ( ms % NUM ) / NUM ) + ( ( ms % NUM ) / NUM ) + ( ms % NUM ) + STRING + STRING + percent 10 / NUM + STRING + percent 10 % NUM + STRING ; }
private void merge Released ( List < Segment > segments , List < Offset Predicate > predicates , Segment compact Segment ) { for ( int i = NUM ; i < segments . size ( ) ; i ++ ) { merge Released Entries ( segments . get ( i ) , predicates . get ( i ) , compact Segment ) ; } }
private void merge Released ( List < Segment > segments , List < Offset Predicate > predicates , Segment compact Segment ) { for ( int i = NUM ; i < segments . size ( ) ; i ++ ) { merge Released Entries ( segments . get ( i ) , predicates . get ( i ) , compact Segment ) ; } }
public DOM Test Document Builder Factory new Instance ( Document Builder Setting [ ] new Settings ) throws DOM Test Incompatible Exception { if ( new Settings == null ) { return this ; } Document Builder Setting [ ] merged Settings = merge Settings ( new Settings ) ; return new Batik Test Document Builder Factory ( merged Settings ) ; }
private void build PTR ( ) { double [ ] temp row ; double [ ] [ ] PTRA ; int k ; Pivot Transform pt ; PTR = Matrix . identity ( n , n ) ; PTRA = PTR . get Array ( ) ; k = pivot Transform Queue . size ( ) ; while ( k -- > NUM ) { pt = pivot Transform Queue . remove Last ( ) ; temp row = PTRA [ pt . pos 1 ] ; PTRA [ pt . pos 1 ] = PTRA [ pt . pos 2 ] ; PTRA [ pt . pos 2 ] = temp row ; } }
private void build PTR ( ) { double [ ] temp row ; double [ ] [ ] PTRA ; int k ; Pivot Transform pt ; PTR = Matrix . identity ( n , n ) ; PTRA = PTR . get Array ( ) ; k = pivot Transform Queue . size ( ) ; while ( k -- > NUM ) { pt = pivot Transform Queue . remove Last ( ) ; temp row = PTRA [ pt . pos 1 ] ; PTRA [ pt . pos 1 ] = PTRA [ pt . pos 2 ] ; PTRA [ pt . pos 2 ] = temp row ; } }
private void build PTR ( ) { double [ ] temp row ; double [ ] [ ] PTRA ; int k ; Pivot Transform pt ; PTR = Matrix . identity ( n , n ) ; PTRA = PTR . get Array ( ) ; k = pivot Transform Queue . size ( ) ; while ( k -- > NUM ) { pt = pivot Transform Queue . remove Last ( ) ; temp row = PTRA [ pt . pos 1 ] ; PTRA [ pt . pos 1 ] = PTRA [ pt . pos 2 ] ; PTRA [ pt . pos 2 ] = temp row ; } }
private void build PTR ( ) { double [ ] temp row ; double [ ] [ ] PTRA ; int k ; Pivot Transform pt ; PTR = Matrix . identity ( n , n ) ; PTRA = PTR . get Array ( ) ; k = pivot Transform Queue . size ( ) ; while ( k -- > NUM ) { pt = pivot Transform Queue . remove Last ( ) ; temp row = PTRA [ pt . pos 1 ] ; PTRA [ pt . pos 1 ] = PTRA [ pt . pos 2 ] ; PTRA [ pt . pos 2 ] = temp row ; } }
private void build PTR ( ) { double [ ] temp row ; double [ ] [ ] PTRA ; int k ; Pivot Transform pt ; PTR = Matrix . identity ( n , n ) ; PTRA = PTR . get Array ( ) ; k = pivot Transform Queue . size ( ) ; while ( k -- > NUM ) { pt = pivot Transform Queue . remove Last ( ) ; temp row = PTRA [ pt . pos 1 ] ; PTRA [ pt . pos 1 ] = PTRA [ pt . pos 2 ] ; PTRA [ pt . pos 2 ] = temp row ; } }
protected abstract Collection < Communication Summary Statistics > do Get Communication Summary Statistics ( String tenant Id , Criteria criteria ) ;
protected void update Radio Links ( ) { m Set Test But . set Enabled ( m Test Split But . is Selected ( ) ) ; if ( ( m Set Test Frame != null ) && ( ! m Test Split But . is Selected ( ) ) ) { m Set Test Frame . set Visible ( BOOL ) ; } m Percent Text . set Enabled ( m Percent But . is Selected ( ) ) ; m Percent Lab . set Enabled ( m Percent But . is Selected ( ) ) ; m Class Combo . set Enabled ( m Classes To Clusters But . is Selected ( ) ) ; update Capabilities Filter ( m Clusterer Editor . get Capabilities Filter ( ) ) ; }
protected Point 2 D correct ( Point 2 D anchor , Rectangle 2 D bounds ) { if ( anchor == null ) return anchor ; double x = anchor . get X ( ) , y = anchor . get Y ( ) ; double x1 = bounds . get Min X ( ) , y1 = bounds . get Min Y ( ) ; double x2 = bounds . get Max X ( ) , y2 = bounds . get Max Y ( ) ; x = ( x < x1 ? x1 : ( x > x2 ? x2 : x ) ) ; y = ( y < y1 ? y1 : ( y > y2 ? y2 : y ) ) ; m tmp . set Location ( x , y ) ; return m tmp ; }
protected Point 2 D correct ( Point 2 D anchor , Rectangle 2 D bounds ) { if ( anchor == null ) return anchor ; double x = anchor . get X ( ) , y = anchor . get Y ( ) ; double x1 = bounds . get Min X ( ) , y1 = bounds . get Min Y ( ) ; double x2 = bounds . get Max X ( ) , y2 = bounds . get Max Y ( ) ; x = ( x < x1 ? x1 : ( x > x2 ? x2 : x ) ) ; y = ( y < y1 ? y1 : ( y > y2 ? y2 : y ) ) ; m tmp . set Location ( x , y ) ; return m tmp ; }
private List < String > replace Dot In Mustache Keys ( final List < String > mustache Keys ) { final List < String > fixed Mustache Keys = new Array List < > ( ) ; for ( String mustache Key : mustache Keys ) { fixed Mustache Keys . add ( mustache Key . replace ( STRING , STRING ) ) ; } return fixed Mustache Keys ; }
private List < String > replace Dot In Mustache Keys ( final List < String > mustache Keys ) { final List < String > fixed Mustache Keys = new Array List < > ( ) ; for ( String mustache Key : mustache Keys ) { fixed Mustache Keys . add ( mustache Key . replace ( STRING , STRING ) ) ; } return fixed Mustache Keys ; }
private List < String > replace Dot In Mustache Keys ( final List < String > mustache Keys ) { final List < String > fixed Mustache Keys = new Array List < > ( ) ; for ( String mustache Key : mustache Keys ) { fixed Mustache Keys . add ( mustache Key . replace ( STRING , STRING ) ) ; } return fixed Mustache Keys ; }
private List < String > replace Dot In Mustache Keys ( final List < String > mustache Keys ) { final List < String > fixed Mustache Keys = new Array List < > ( ) ; for ( String mustache Key : mustache Keys ) { fixed Mustache Keys . add ( mustache Key . replace ( STRING , STRING ) ) ; } return fixed Mustache Keys ; }
public Printf Format ( String fmt Arg ) throws Illegal Argument Exception { this ( Locale . get Default ( ) , fmt Arg ) ; }
public Printf Format ( String fmt Arg ) throws Illegal Argument Exception { this ( Locale . get Default ( ) , fmt Arg ) ; }
public Gamma Fitness Function ( int genome Length , double alpha , double beta , int state Size , boolean random Fittest ) { Gamma Distribution gamma = new Gamma Distribution ( beta , alpha ) ; fitness = new double [ genome Length ] [ state Size ] ; fittest = new byte [ genome Length ] ; int fitpos = NUM ; for ( int i = NUM ; i < genome Length ; i ++ ) { if ( random Fittest ) { fitpos = Math Utils . next Int ( state Size ) ; } fitness [ i ] [ fitpos ] = NUM ; fittest [ i ] = ( byte ) fitpos ; for ( int j = NUM ; j < state Size ; j ++ ) { if ( j != fitpos ) { double prob = Math . round ( Math Utils . next Double ( ) * NUM ) / NUM ; while ( ( prob <= NUM ) || ( prob >= NUM ) ) { prob = Math . round ( Math Utils . next Double ( ) * NUM ) / NUM ; } fitness [ i ] [ j ] = Math . max ( NUM , NUM - gamma . quantile ( prob ) ) ; } } } }
private void show Time Sending Strategy Validation Message ( ) { sending Value Decoration . set Description Text ( STRING ) ; }
public final T end ( int i ) { while ( i -- > NUM && ! tag Stack . is Empty ( ) ) { end ( ) ; } return get Self ( ) ; }
protected void subscribe Stop ( String name Value ) throws Throwable { URI observer Uri = URI . create ( observer Service Uri For Stop ) ; wait For Subscription To Appear ( observer Uri , EXAMPLES SUBSCRIPTIONS ) ; verify Notification ( name Value , observer Uri ) ; Js Executor . execute Synchronously ( null ) ; wait For Subscription To Disappear ( observer Uri , EXAMPLES SUBSCRIPTIONS ) ; }
protected void subscribe Stop ( String name Value ) throws Throwable { URI observer Uri = URI . create ( observer Service Uri For Stop ) ; wait For Subscription To Appear ( observer Uri , EXAMPLES SUBSCRIPTIONS ) ; verify Notification ( name Value , observer Uri ) ; Js Executor . execute Synchronously ( null ) ; wait For Subscription To Disappear ( observer Uri , EXAMPLES SUBSCRIPTIONS ) ; }
protected void subscribe Stop ( String name Value ) throws Throwable { URI observer Uri = URI . create ( observer Service Uri For Stop ) ; wait For Subscription To Appear ( observer Uri , EXAMPLES SUBSCRIPTIONS ) ; verify Notification ( name Value , observer Uri ) ; Js Executor . execute Synchronously ( null ) ; wait For Subscription To Disappear ( observer Uri , EXAMPLES SUBSCRIPTIONS ) ; }
@ Namespace Permission ( fields = STRING , permissions = Namespace Permission Enum . READ ) private void mock Method ( String namespace ) { }
public Month Date Format ( Locale locale , int chars ) { this ( Time Zone . get Default ( ) , locale , chars , BOOL , BOOL ) ; }
public boolean does Not Distribute ( ) { return BOOL ; }
public boolean does Not Distribute ( ) { return BOOL ; }
public boolean does Not Distribute ( ) { return BOOL ; }
protected final void accept Annotations ( final Method Visitor mv ) { int n = visible Type Annotations == null ? NUM : visible Type Annotations . size ( ) ; for ( int i = NUM ; i < n ; ++ i ) { Type Annotation Node an = visible Type Annotations . get ( i ) ; an . accept ( mv . visit Insn Annotation ( an . type Ref , an . type Path , an . desc , BOOL ) ) ; } n = invisible Type Annotations == null ? NUM : invisible Type Annotations . size ( ) ; for ( int i = NUM ; i < n ; ++ i ) { Type Annotation Node an = invisible Type Annotations . get ( i ) ; an . accept ( mv . visit Insn Annotation ( an . type Ref , an . type Path , an . desc , BOOL ) ) ; } }
protected final void accept Annotations ( final Method Visitor mv ) { int n = visible Type Annotations == null ? NUM : visible Type Annotations . size ( ) ; for ( int i = NUM ; i < n ; ++ i ) { Type Annotation Node an = visible Type Annotations . get ( i ) ; an . accept ( mv . visit Insn Annotation ( an . type Ref , an . type Path , an . desc , BOOL ) ) ; } n = invisible Type Annotations == null ? NUM : invisible Type Annotations . size ( ) ; for ( int i = NUM ; i < n ; ++ i ) { Type Annotation Node an = invisible Type Annotations . get ( i ) ; an . accept ( mv . visit Insn Annotation ( an . type Ref , an . type Path , an . desc , BOOL ) ) ; } }
protected final void accept Annotations ( final Method Visitor mv ) { int n = visible Type Annotations == null ? NUM : visible Type Annotations . size ( ) ; for ( int i = NUM ; i < n ; ++ i ) { Type Annotation Node an = visible Type Annotations . get ( i ) ; an . accept ( mv . visit Insn Annotation ( an . type Ref , an . type Path , an . desc , BOOL ) ) ; } n = invisible Type Annotations == null ? NUM : invisible Type Annotations . size ( ) ; for ( int i = NUM ; i < n ; ++ i ) { Type Annotation Node an = invisible Type Annotations . get ( i ) ; an . accept ( mv . visit Insn Annotation ( an . type Ref , an . type Path , an . desc , BOOL ) ) ; } }
public static int next Set Bit ( long [ ] v , int start ) { int wordindex = start > > > LONG LOG 2 SIZE ; if ( wordindex >= v . length ) { return - NUM ; } long cur = v [ wordindex ] & ( LONG ALL BITS << start ) ; for ( ; ; ) { if ( cur != NUM ) { return ( wordindex * Long . SIZE ) + Long . number Of Trailing Zeros ( cur ) ; } wordindex ++ ; if ( wordindex == v . length ) { return - NUM ; } cur = v [ wordindex ] ; } }
public boolean on Death ( ) { attack Target = null ; return next Mod != null && next Mod . on Death ( ) ; }
public String encode ( Byte Buffer a Buffer ) { byte [ ] buf = get Bytes ( a Buffer ) ; return encode ( buf ) ; }
public String encode ( Byte Buffer a Buffer ) { byte [ ] buf = get Bytes ( a Buffer ) ; return encode ( buf ) ; }
public String encode ( Byte Buffer a Buffer ) { byte [ ] buf = get Bytes ( a Buffer ) ; return encode ( buf ) ; }
public String encode ( Byte Buffer a Buffer ) { byte [ ] buf = get Bytes ( a Buffer ) ; return encode ( buf ) ; }
public String encode ( Byte Buffer a Buffer ) { byte [ ] buf = get Bytes ( a Buffer ) ; return encode ( buf ) ; }
public String encode ( Byte Buffer a Buffer ) { byte [ ] buf = get Bytes ( a Buffer ) ; return encode ( buf ) ; }
public String encode ( Byte Buffer a Buffer ) { byte [ ] buf = get Bytes ( a Buffer ) ; return encode ( buf ) ; }
public String encode ( Byte Buffer a Buffer ) { byte [ ] buf = get Bytes ( a Buffer ) ; return encode ( buf ) ; }
public void prepare Filter ( float transition ) { try { method . invoke ( filter , new Object [ ] { new Float ( transition ) } ) ; } catch ( Exception e ) { throw new Illegal Argument Exception ( STRING + property ) ; } }
public void prepare Filter ( float transition ) { try { method . invoke ( filter , new Object [ ] { new Float ( transition ) } ) ; } catch ( Exception e ) { throw new Illegal Argument Exception ( STRING + property ) ; } }
public void prepare Filter ( float transition ) { try { method . invoke ( filter , new Object [ ] { new Float ( transition ) } ) ; } catch ( Exception e ) { throw new Illegal Argument Exception ( STRING + property ) ; } }
public void prepare Filter ( float transition ) { try { method . invoke ( filter , new Object [ ] { new Float ( transition ) } ) ; } catch ( Exception e ) { throw new Illegal Argument Exception ( STRING + property ) ; } }
public void prepare Filter ( float transition ) { try { method . invoke ( filter , new Object [ ] { new Float ( transition ) } ) ; } catch ( Exception e ) { throw new Illegal Argument Exception ( STRING + property ) ; } }
public void prepare Filter ( float transition ) { try { method . invoke ( filter , new Object [ ] { new Float ( transition ) } ) ; } catch ( Exception e ) { throw new Illegal Argument Exception ( STRING + property ) ; } }
private static int [ ] [ ] successors ( final List < Vector 3 D > vertices , final List < int [ ] > facets , final int [ ] [ ] references ) { final int [ ] [ ] successors = new int [ vertices . size ( ) ] [ references [ NUM ] . length ] ; for ( final int [ ] s : successors ) { Arrays . fill ( s , - NUM ) ; } for ( int v = NUM ; v < vertices . size ( ) ; ++ v ) { for ( int k = NUM ; k < successors [ v ] . length && references [ v ] [ k ] >= NUM ; ++ k ) { final int [ ] facet = facets . get ( references [ v ] [ k ] ) ; int i = NUM ; while ( i < facet . length && facet [ i ] != v ) { ++ i ; } successors [ v ] [ k ] = facet [ ( i + NUM ) % facet . length ] ; for ( int l = NUM ; l < k ; ++ l ) { if ( successors [ v ] [ l ] == successors [ v ] [ k ] ) { final Vector 3 D start = vertices . get ( v ) ; final Vector 3 D end = vertices . get ( successors [ v ] [ k ] ) ; throw new Math Illegal Argument Exception ( Localized Geometry Formats . FACET ORIENTATION MISMATCH , start . get X ( ) , start . get Y ( ) , start . get Z ( ) , end . get X ( ) , end . get Y ( ) , end . get Z ( ) ) ; } } } } return successors ; }
public int expand All ( int level ) { int expanded = NUM ; for ( int i = NUM ; i < m Items . size ( ) ; i ++ ) { T item = get Item ( i ) ; if ( is Expandable ( item ) ) { I Expandable expandable = ( I Expandable ) item ; if ( expandable . get Expansion Level ( ) <= level && expand ( i , BOOL , BOOL ) > NUM ) { expanded ++ ; } } } return expanded ; }
Number Strategy ( final int field ) { this . field = field ; }
Number Strategy ( final int field ) { this . field = field ; }
public static final void write List Xml ( List val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int N = val . size ( ) ; int i = NUM ; while ( i < N ) { write Value Xml ( val . get ( i ) , null , out ) ; i ++ ; } out . end Tag ( null , STRING ) ; }
public static final void write List Xml ( List val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int N = val . size ( ) ; int i = NUM ; while ( i < N ) { write Value Xml ( val . get ( i ) , null , out ) ; i ++ ; } out . end Tag ( null , STRING ) ; }
public static final void write List Xml ( List val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int N = val . size ( ) ; int i = NUM ; while ( i < N ) { write Value Xml ( val . get ( i ) , null , out ) ; i ++ ; } out . end Tag ( null , STRING ) ; }
public static final void write List Xml ( List val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int N = val . size ( ) ; int i = NUM ; while ( i < N ) { write Value Xml ( val . get ( i ) , null , out ) ; i ++ ; } out . end Tag ( null , STRING ) ; }
public boolean can Load ( Entity unit , boolean check Elev ) { if ( this instanceof Infantry ) { return BOOL ; } if ( ! unit . is Enemy Of ( this ) ) { Enumeration < Transporter > iter = transports . elements ( ) ; while ( iter . has More Elements ( ) ) { Transporter next = iter . next Element ( ) ; if ( next . can Load ( unit ) && ( ! check Elev || ( unit . get Elevation ( ) == get Elevation ( ) ) ) ) { return BOOL ; } } } return BOOL ; }
public static Workspace Component deserialize Workspace Component ( final Class < ? > clazz , final String name , final Input Stream input , final String format ) { try { Method method = clazz . get Method ( STRING , Input Stream . class , String . class , String . class ) ; Workspace Component wc = ( Workspace Component ) method . invoke ( null , input , name , format ) ; wc . set Changed Since Last Save ( BOOL ) ; return wc ; } catch ( Runtime Exception e ) { throw e ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
public static boolean is Atomic Update ( final Add Update Command cmd ) { Solr Input Document sdoc = cmd . get Solr Input Document ( ) ; for ( Solr Input Field sif : sdoc . values ( ) ) { if ( sif . get Value ( ) instanceof Map ) { return BOOL ; } } return BOOL ; }
public static boolean is Atomic Update ( final Add Update Command cmd ) { Solr Input Document sdoc = cmd . get Solr Input Document ( ) ; for ( Solr Input Field sif : sdoc . values ( ) ) { if ( sif . get Value ( ) instanceof Map ) { return BOOL ; } } return BOOL ; }
public static boolean is Atomic Update ( final Add Update Command cmd ) { Solr Input Document sdoc = cmd . get Solr Input Document ( ) ; for ( Solr Input Field sif : sdoc . values ( ) ) { if ( sif . get Value ( ) instanceof Map ) { return BOOL ; } } return BOOL ; }
public static boolean is Atomic Update ( final Add Update Command cmd ) { Solr Input Document sdoc = cmd . get Solr Input Document ( ) ; for ( Solr Input Field sif : sdoc . values ( ) ) { if ( sif . get Value ( ) instanceof Map ) { return BOOL ; } } return BOOL ; }
public static java . lang . Integer value Of ( java . lang . String s , int radix ) throws java . lang . Number Format Exception { return new Integer ( parse Int ( s , radix ) ) ; }
public static < T extends Entity > T create ( Cursor cursor , Class < T > cls , String ... projection ) { try { T entity = cls . new Instance ( ) ; Field [ ] fields = new Field [ projection . length ] ; for ( int i = NUM , size = projection . length ; i < size ; i ++ ) { fields [ i ] = get Column Field ( projection [ i ] , entity ) ; } return create ( entity , cursor , cls , fields ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return null ; } }
public static void write ( Input Stream in , Output Stream out , boolean close Both ) throws IO Exception { byte [ ] buff = new byte [ NUM ] ; int read = NUM ; while ( ( read = in . read ( buff ) ) > NUM ) { out . write ( buff , NUM , read ) ; } out . flush ( ) ; if ( close Both ) { safe Close Streams ( in , out ) ; } }
@ Override public boolean supports Authentication ( ) { if ( DEBUG . message Enabled ( ) ) { DEBUG . message ( STRING ) ; } return BOOL ; }
public final static int write Security Buffer And Update Pointer ( Byte Array Output Stream baos , short len , int pointer ) throws IO Exception { baos . write ( write Security Buffer ( len , pointer ) ) ; return pointer + len ; }
public final static int write Security Buffer And Update Pointer ( Byte Array Output Stream baos , short len , int pointer ) throws IO Exception { baos . write ( write Security Buffer ( len , pointer ) ) ; return pointer + len ; }
public final static int write Security Buffer And Update Pointer ( Byte Array Output Stream baos , short len , int pointer ) throws IO Exception { baos . write ( write Security Buffer ( len , pointer ) ) ; return pointer + len ; }
public final static int write Security Buffer And Update Pointer ( Byte Array Output Stream baos , short len , int pointer ) throws IO Exception { baos . write ( write Security Buffer ( len , pointer ) ) ; return pointer + len ; }
static public int cancel Operation ( int token ) { int canceled = NUM ; synchronized ( s Work Queue ) { Iterator < Operation Info > it = s Work Queue . iterator ( ) ; while ( it . has Next ( ) ) { if ( it . next ( ) . token == token ) { it . remove ( ) ; ++ canceled ; } } } if ( Async Query Service . local LOGV ) { Log . d ( TAG , STRING + token + STRING + canceled ) ; } return canceled ; }
static public int cancel Operation ( int token ) { int canceled = NUM ; synchronized ( s Work Queue ) { Iterator < Operation Info > it = s Work Queue . iterator ( ) ; while ( it . has Next ( ) ) { if ( it . next ( ) . token == token ) { it . remove ( ) ; ++ canceled ; } } } if ( Async Query Service . local LOGV ) { Log . d ( TAG , STRING + token + STRING + canceled ) ; } return canceled ; }
@ Override protected void stop Service ( ) { Thread t = keep Alive Thread ; keep Alive Thread = null ; if ( t != null ) { t . interrupt ( ) ; } }
protected double now ( ) { return System . current Time Millis ( ) ; }
default Properties as Properties ( ) { return as Properties ( null ) ; }
public static String [ ] to String Array ( Enumeration < String > enumeration ) { if ( enumeration == null ) { return null ; } List < String > list = Collections . list ( enumeration ) ; return list . to Array ( new String [ list . size ( ) ] ) ; }
public static String [ ] to String Array ( Enumeration < String > enumeration ) { if ( enumeration == null ) { return null ; } List < String > list = Collections . list ( enumeration ) ; return list . to Array ( new String [ list . size ( ) ] ) ; }
public final static boolean is Potential Zip Archive ( String name ) { int last Dot = name . last Index Of ( STRING ) ; if ( last Dot == - NUM ) { return BOOL ; } if ( name . last Index Of ( File . separator Char ) > last Dot ) { return BOOL ; } int length = name . length ( ) ; int extension Length = length - last Dot - NUM ; if ( extension Length == EXTENSION java . length ( ) ) { for ( int i = extension Length - NUM ; i >= NUM ; i -- ) { if ( Character . to Lower Case ( name . char At ( length - extension Length + i ) ) != EXTENSION java . char At ( i ) ) { break ; } if ( i == NUM ) { return BOOL ; } } } if ( extension Length == EXTENSION class . length ( ) ) { for ( int i = extension Length - NUM ; i >= NUM ; i -- ) { if ( Character . to Lower Case ( name . char At ( length - extension Length + i ) ) != EXTENSION class . char At ( i ) ) { return BOOL ; } } return BOOL ; } return BOOL ; }
public Csv Writer put ( int index , String value ) throws Csv Exception { if ( disposition == null ) { disposition = new Hash Map < Character , Disposition > ( NUM ) ; for ( char c : escaped Chars . to Char Array ( ) ) { disposition . put ( c , Disposition . escape ) ; } for ( char c : suppressed Chars . to Char Array ( ) ) { disposition . put ( c , Disposition . suppress ) ; } } if ( row == null ) { int size = get Width ( ) ; row = new Array List < String > ( size ) ; for ( int i = NUM ; i < size ; i ++ ) row . add ( null ) ; col Count = NUM ; } if ( index < NUM || index > row . size ( ) ) { throw new Csv Exception ( STRING + index + STRING + value + STRING + row . size ( ) ) ; } int array Index = index - NUM ; if ( row . get ( array Index ) != null ) { throw new Csv Exception ( STRING + index + STRING + row . get ( array Index ) + STRING + value + STRING ) ; } if ( value == null ) { if ( this . null Policy == Null Policy . empty String ) value = process String ( STRING ) ; else if ( null Policy == Null Policy . skip ) value = null ; else value = null Value ; } else { value = process String ( value ) ; } row . set ( array Index , value ) ; col Count ++ ; return this ; }
void add ( int start , int end ) { final Map . Entry < Integer , Integer > floor = m Intervals . floor Entry ( start ) ; final Map . Entry < Integer , Integer > end Floor = m Intervals . lower Entry ( end ) ; final int actual Start ; final int actual End ; if ( floor != null && start >= floor . get Key ( ) && end <= floor . get Value ( ) ) { return ; } if ( floor == null || start > floor . get Value ( ) ) { actual Start = start ; } else { actual Start = Math . min ( floor . get Key ( ) , start ) ; } if ( end Floor == null ) { actual End = end ; } else { actual End = Math . max ( end Floor . get Value ( ) , end ) ; } remove Contained By ( actual Start , actual End ) ; m Intervals . put ( actual Start , actual End ) ; }
protected Integer column Index ( Map < String , Integer > load Col Idxs , String db Name ) { Integer col Idx = load Col Idxs . get ( db Name . to Upper Case ( ) ) ; if ( col Idx == null ) throw new Illegal State Exception ( STRING + db Name ) ; return col Idx ; }
protected Integer column Index ( Map < String , Integer > load Col Idxs , String db Name ) { Integer col Idx = load Col Idxs . get ( db Name . to Upper Case ( ) ) ; if ( col Idx == null ) throw new Illegal State Exception ( STRING + db Name ) ; return col Idx ; }
@ Suppress Warnings ( STRING ) public void load ( byte [ ] data ) throws Exception { if ( data == null ) { return ; } if ( schema Validator != null ) { try ( Input Stream in = new Byte Array Input Stream ( data ) ) { validate Schema With Validator ( in ) ; } } try ( Input Stream in = new Byte Array Input Stream ( data ) ) { Unmarshaller unmarshaller = jaxb Ctx . create Unmarshaller ( ) ; root = ( JAXB Element < T > ) unmarshaller . unmarshal ( in ) ; conf Type = root . get Value ( ) ; } }
private static Float Buffer allocate Texture Buffer ( float u , float v ) { float texturepoints [ ] = { NUM , NUM , NUM , v , u , NUM , u , v } ; Byte Buffer byte Buffer = Byte Buffer . allocate Direct ( texturepoints . length * SIZEOF FLOAT ) ; byte Buffer . order ( Byte Order . native Order ( ) ) ; Float Buffer tex Buffer = byte Buffer . as Float Buffer ( ) ; tex Buffer . put ( texturepoints ) ; tex Buffer . position ( NUM ) ; return tex Buffer ; }
private List < Validation Error > validate ( ) { List < Validation Error > errors = Lists . new Array List ( ) ; Module module = get Module ( ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Module ( module ) ) ; Android Facet facet = null ; if ( module != null ) { facet = Android Facet . get Instance ( module ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Facet ( facet , module ) ) ; } errors . add All ( config State . validate ( facet ) ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Label ( get Label ( ) , configuration . get Project ( ) , Kind . ANDROID BINARY ) ) ; return errors ; }
private List < Validation Error > validate ( ) { List < Validation Error > errors = Lists . new Array List ( ) ; Module module = get Module ( ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Module ( module ) ) ; Android Facet facet = null ; if ( module != null ) { facet = Android Facet . get Instance ( module ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Facet ( facet , module ) ) ; } errors . add All ( config State . validate ( facet ) ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Label ( get Label ( ) , configuration . get Project ( ) , Kind . ANDROID BINARY ) ) ; return errors ; }
private List < Validation Error > validate ( ) { List < Validation Error > errors = Lists . new Array List ( ) ; Module module = get Module ( ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Module ( module ) ) ; Android Facet facet = null ; if ( module != null ) { facet = Android Facet . get Instance ( module ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Facet ( facet , module ) ) ; } errors . add All ( config State . validate ( facet ) ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Label ( get Label ( ) , configuration . get Project ( ) , Kind . ANDROID BINARY ) ) ; return errors ; }
private List < Validation Error > validate ( ) { List < Validation Error > errors = Lists . new Array List ( ) ; Module module = get Module ( ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Module ( module ) ) ; Android Facet facet = null ; if ( module != null ) { facet = Android Facet . get Instance ( module ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Facet ( facet , module ) ) ; } errors . add All ( config State . validate ( facet ) ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Label ( get Label ( ) , configuration . get Project ( ) , Kind . ANDROID BINARY ) ) ; return errors ; }
private List < Validation Error > validate ( ) { List < Validation Error > errors = Lists . new Array List ( ) ; Module module = get Module ( ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Module ( module ) ) ; Android Facet facet = null ; if ( module != null ) { facet = Android Facet . get Instance ( module ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Facet ( facet , module ) ) ; } errors . add All ( config State . validate ( facet ) ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Label ( get Label ( ) , configuration . get Project ( ) , Kind . ANDROID BINARY ) ) ; return errors ; }
private List < Validation Error > validate ( ) { List < Validation Error > errors = Lists . new Array List ( ) ; Module module = get Module ( ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Module ( module ) ) ; Android Facet facet = null ; if ( module != null ) { facet = Android Facet . get Instance ( module ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Facet ( facet , module ) ) ; } errors . add All ( config State . validate ( facet ) ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Label ( get Label ( ) , configuration . get Project ( ) , Kind . ANDROID BINARY ) ) ; return errors ; }
private List < Validation Error > validate ( ) { List < Validation Error > errors = Lists . new Array List ( ) ; Module module = get Module ( ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Module ( module ) ) ; Android Facet facet = null ; if ( module != null ) { facet = Android Facet . get Instance ( module ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Facet ( facet , module ) ) ; } errors . add All ( config State . validate ( facet ) ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Label ( get Label ( ) , configuration . get Project ( ) , Kind . ANDROID BINARY ) ) ; return errors ; }
private List < Validation Error > validate ( ) { List < Validation Error > errors = Lists . new Array List ( ) ; Module module = get Module ( ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Module ( module ) ) ; Android Facet facet = null ; if ( module != null ) { facet = Android Facet . get Instance ( module ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Facet ( facet , module ) ) ; } errors . add All ( config State . validate ( facet ) ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Label ( get Label ( ) , configuration . get Project ( ) , Kind . ANDROID BINARY ) ) ; return errors ; }
private List < Validation Error > validate ( ) { List < Validation Error > errors = Lists . new Array List ( ) ; Module module = get Module ( ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Module ( module ) ) ; Android Facet facet = null ; if ( module != null ) { facet = Android Facet . get Instance ( module ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Facet ( facet , module ) ) ; } errors . add All ( config State . validate ( facet ) ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Label ( get Label ( ) , configuration . get Project ( ) , Kind . ANDROID BINARY ) ) ; return errors ; }
private static byte [ ] generate Multipart Boundary ( ) { final Random rand = new Random ( ) ; final byte [ ] bytes = new byte [ rand . next Int ( NUM ) + NUM ] ; for ( int i = NUM ; i < bytes . length ; i ++ ) { bytes [ i ] = MULTIPART CHARS [ rand . next Int ( MULTIPART CHARS . length ) ] ; } return bytes ; }
public static HTTP Response delete ( URL url , String username , String password , long timeout , boolean redirect , String charset , String useragent , Proxy Data proxy , lucee . commons . net . http . Header [ ] headers ) throws IO Exception { Http Delete delete = new Http Delete ( url . to External Form ( ) ) ; return invoke ( url , delete , username , password , timeout , redirect , charset , useragent , proxy , headers , null ) ; }
public void render ( Graphics 2 D g , Shape shape ) { render ( g , shape , BOOL ) ; }
public void render ( Graphics 2 D g , Shape shape ) { render ( g , shape , BOOL ) ; }
public static final String remove Query String ( final String path ) { return path . replace First ( STRING , String Utils . EMPTY ) ; }
private static boolean check Instance Ids Returned From AWS ( int number Of Instance , List < String > instance Ids ) { if ( instance Ids == null || instance Ids . size ( ) == NUM ) { return BOOL ; } return ( instance Ids . size ( ) == number Of Instance ) ; }
private static boolean check Instance Ids Returned From AWS ( int number Of Instance , List < String > instance Ids ) { if ( instance Ids == null || instance Ids . size ( ) == NUM ) { return BOOL ; } return ( instance Ids . size ( ) == number Of Instance ) ; }
public static Features Config from Xml ( final Input Stream to Convert ) throws JAXB Exception { Unmarshaller string Unmarshaller = get Unmarshaller ( ) ; return ( Features Config ) string Unmarshaller . unmarshal ( to Convert ) ; }
public static Features Config from Xml ( final Input Stream to Convert ) throws JAXB Exception { Unmarshaller string Unmarshaller = get Unmarshaller ( ) ; return ( Features Config ) string Unmarshaller . unmarshal ( to Convert ) ; }
public static String to Date String ( java . util . Date date , String format ) { if ( date == null ) return STRING ; Simple Date Format date Format = null ; if ( format != null ) { date Format = new Simple Date Format ( format ) ; } else { date Format = new Simple Date Format ( ) ; } Calendar calendar = Calendar . get Instance ( ) ; calendar . set Time ( date ) ; return date Format . format ( date ) ; }
@ Override public Trie reduce ( Reduce by ) { List < Trie > h = new Array List < > ( ) ; for ( Trie trie : tries ) h . add ( trie . reduce ( by ) ) ; Multi Trie 2 m = new Multi Trie 2 ( forward ) ; m . tries = h ; return m ; }
@ Override public Trie reduce ( Reduce by ) { List < Trie > h = new Array List < > ( ) ; for ( Trie trie : tries ) h . add ( trie . reduce ( by ) ) ; Multi Trie 2 m = new Multi Trie 2 ( forward ) ; m . tries = h ; return m ; }
@ Override public Trie reduce ( Reduce by ) { List < Trie > h = new Array List < > ( ) ; for ( Trie trie : tries ) h . add ( trie . reduce ( by ) ) ; Multi Trie 2 m = new Multi Trie 2 ( forward ) ; m . tries = h ; return m ; }
public Classifier Reference ( Qualified Name qualified Name , URI uri ) { this . classifier Name = qualified Name . get Last Segment ( ) ; List < String > front Segments = qualified Name . get Segments ( ) ; if ( front Segments . size ( ) > NUM ) { String Joiner joiner = new String Joiner ( N4 JS Qualified Name Converter . DELIMITER ) ; for ( String segment : front Segments . sub List ( NUM , front Segments . size ( ) - NUM ) ) { joiner . add ( segment ) ; } this . classifier Module Specifier = joiner . to String ( ) ; } else { this . classifier Module Specifier = STRING ; } this . uri = uri ; }
public Classifier Reference ( Qualified Name qualified Name , URI uri ) { this . classifier Name = qualified Name . get Last Segment ( ) ; List < String > front Segments = qualified Name . get Segments ( ) ; if ( front Segments . size ( ) > NUM ) { String Joiner joiner = new String Joiner ( N4 JS Qualified Name Converter . DELIMITER ) ; for ( String segment : front Segments . sub List ( NUM , front Segments . size ( ) - NUM ) ) { joiner . add ( segment ) ; } this . classifier Module Specifier = joiner . to String ( ) ; } else { this . classifier Module Specifier = STRING ; } this . uri = uri ; }
public Histogram ( Range With Count ... items ) { this ( Arrays . stream ( items ) ) ; }
public void component Resized ( Component Event e ) { J Scroll Bar bar = get Vertical Scroll Bar ( ) ; int incr = ( int ) ( get Size ( ) . get Height ( ) - ( bar . get Unit Increment ( NUM ) * NUM ) ) ; get Vertical Scroll Bar ( ) . set Block Increment ( incr ) ; }
public Notification Set parse XML ( ) { if ( document == null ) { return null ; } Element notif Set Elem = document . get Document Element ( ) ; Notification Set notification Set = new Notification Set ( ) ; set Notification Set Attributes ( notif Set Elem , notification Set ) ; Node List notifs = notif Set Elem . get Elements By Tag Name ( STRING ) ; if ( notifs == null ) { return notification Set ; } int node Len = notifs . get Length ( ) ; for ( int i = NUM ; i < node Len ; i ++ ) { notification Set . add Notification ( parse Notification Element ( ( Element ) notifs . item ( i ) ) ) ; } return notification Set ; }
public Notification Set parse XML ( ) { if ( document == null ) { return null ; } Element notif Set Elem = document . get Document Element ( ) ; Notification Set notification Set = new Notification Set ( ) ; set Notification Set Attributes ( notif Set Elem , notification Set ) ; Node List notifs = notif Set Elem . get Elements By Tag Name ( STRING ) ; if ( notifs == null ) { return notification Set ; } int node Len = notifs . get Length ( ) ; for ( int i = NUM ; i < node Len ; i ++ ) { notification Set . add Notification ( parse Notification Element ( ( Element ) notifs . item ( i ) ) ) ; } return notification Set ; }
public Notification Set parse XML ( ) { if ( document == null ) { return null ; } Element notif Set Elem = document . get Document Element ( ) ; Notification Set notification Set = new Notification Set ( ) ; set Notification Set Attributes ( notif Set Elem , notification Set ) ; Node List notifs = notif Set Elem . get Elements By Tag Name ( STRING ) ; if ( notifs == null ) { return notification Set ; } int node Len = notifs . get Length ( ) ; for ( int i = NUM ; i < node Len ; i ++ ) { notification Set . add Notification ( parse Notification Element ( ( Element ) notifs . item ( i ) ) ) ; } return notification Set ; }
public List < Integer > diff Ways To Compute ( String input ) { List < Integer > res = new Linked List < > ( ) ; for ( int i = NUM ; i < input . length ( ) ; i ++ ) { char c = input . char At ( i ) ; if ( c == STRING || c == STRING || c == STRING ) { List < Integer > left = diff Ways To Compute ( input . substring ( NUM , i ) ) ; List < Integer > right = diff Ways To Compute ( input . substring ( i + NUM , input . length ( ) ) ) ; for ( int j = NUM ; j < left . size ( ) ; j ++ ) { for ( int k = NUM ; k < right . size ( ) ; k ++ ) { res . add ( calculate ( c , left . get ( j ) , right . get ( k ) ) ) ; } } } } if ( res . size ( ) == NUM ) { res . add ( Integer . parse Int ( input ) ) ; } return res ; }
public List < Integer > diff Ways To Compute ( String input ) { List < Integer > res = new Linked List < > ( ) ; for ( int i = NUM ; i < input . length ( ) ; i ++ ) { char c = input . char At ( i ) ; if ( c == STRING || c == STRING || c == STRING ) { List < Integer > left = diff Ways To Compute ( input . substring ( NUM , i ) ) ; List < Integer > right = diff Ways To Compute ( input . substring ( i + NUM , input . length ( ) ) ) ; for ( int j = NUM ; j < left . size ( ) ; j ++ ) { for ( int k = NUM ; k < right . size ( ) ; k ++ ) { res . add ( calculate ( c , left . get ( j ) , right . get ( k ) ) ) ; } } } } if ( res . size ( ) == NUM ) { res . add ( Integer . parse Int ( input ) ) ; } return res ; }
@ Override public void draw Background ( Graphics 2 D g2 , Rectangle 2 D area ) { fill Background ( g2 , area , this . orientation ) ; draw Background Image ( g2 , area ) ; }
@ Override public void draw Background ( Graphics 2 D g2 , Rectangle 2 D area ) { fill Background ( g2 , area , this . orientation ) ; draw Background Image ( g2 , area ) ; }
@ Override public void draw Background ( Graphics 2 D g2 , Rectangle 2 D area ) { fill Background ( g2 , area , this . orientation ) ; draw Background Image ( g2 , area ) ; }
@ Override public void draw Background ( Graphics 2 D g2 , Rectangle 2 D area ) { fill Background ( g2 , area , this . orientation ) ; draw Background Image ( g2 , area ) ; }
public static int calc R Len ( int diff ) { return ( int ) Math . round ( NUM * Math . log ( rand . next Int ( diff + NUM ) + NUM ) + rand . next Int ( NUM ) ) ; }
private static String unsigned To String ( int value ) { if ( value >= NUM ) { return Integer . to String ( value ) ; } else { return Long . to String ( ( value ) & NUM ) ; } }
private boolean send Message To Default Callback ( final Plugin Result message ) { if ( js Default Callback == null ) { default Callback Stored Results . add ( message ) ; return BOOL ; } message . set Keep Callback ( BOOL ) ; js Default Callback . send Plugin Result ( message ) ; return BOOL ; }
private boolean send Message To Default Callback ( final Plugin Result message ) { if ( js Default Callback == null ) { default Callback Stored Results . add ( message ) ; return BOOL ; } message . set Keep Callback ( BOOL ) ; js Default Callback . send Plugin Result ( message ) ; return BOOL ; }
private boolean send Message To Default Callback ( final Plugin Result message ) { if ( js Default Callback == null ) { default Callback Stored Results . add ( message ) ; return BOOL ; } message . set Keep Callback ( BOOL ) ; js Default Callback . send Plugin Result ( message ) ; return BOOL ; }
Type Declaration declaring Type ( ) ;
public void log Equals ( ) { for ( int i = NUM ; i < A . length ; i ++ ) for ( int j = NUM ; j < A [ i ] . length ; j ++ ) A [ i ] [ j ] = Math . log ( A [ i ] [ j ] ) ; }
public void log Equals ( ) { for ( int i = NUM ; i < A . length ; i ++ ) for ( int j = NUM ; j < A [ i ] . length ; j ++ ) A [ i ] [ j ] = Math . log ( A [ i ] [ j ] ) ; }
public void log Equals ( ) { for ( int i = NUM ; i < A . length ; i ++ ) for ( int j = NUM ; j < A [ i ] . length ; j ++ ) A [ i ] [ j ] = Math . log ( A [ i ] [ j ] ) ; }
public void log Equals ( ) { for ( int i = NUM ; i < A . length ; i ++ ) for ( int j = NUM ; j < A [ i ] . length ; j ++ ) A [ i ] [ j ] = Math . log ( A [ i ] [ j ] ) ; }
public void log Equals ( ) { for ( int i = NUM ; i < A . length ; i ++ ) for ( int j = NUM ; j < A [ i ] . length ; j ++ ) A [ i ] [ j ] = Math . log ( A [ i ] [ j ] ) ; }
private void server Client Message ( ) throws Exception { Ignite ignite = grid ( SERVER NODE IDX ) ; Cluster Group grp = ignite . cluster ( ) . for Clients ( ) ; assert grp . nodes ( ) . size ( ) > NUM ; register Listener And Send Messages ( ignite , grp ) ; }
private void server Client Message ( ) throws Exception { Ignite ignite = grid ( SERVER NODE IDX ) ; Cluster Group grp = ignite . cluster ( ) . for Clients ( ) ; assert grp . nodes ( ) . size ( ) > NUM ; register Listener And Send Messages ( ignite , grp ) ; }
private void server Client Message ( ) throws Exception { Ignite ignite = grid ( SERVER NODE IDX ) ; Cluster Group grp = ignite . cluster ( ) . for Clients ( ) ; assert grp . nodes ( ) . size ( ) > NUM ; register Listener And Send Messages ( ignite , grp ) ; }
private void add Connection Descendants ( Collection < Connection > connections , List < Object Permission . Type > permissions ) throws Guacamole Exception { if ( connections . is Empty ( ) ) return ; Collection < String > identifiers = new Array List < String > ( ) ; for ( Connection connection : connections ) identifiers . add All ( connection . get Sharing Profile Identifiers ( ) ) ; if ( permissions != null && ! permissions . is Empty ( ) ) identifiers = sharing Profile Permissions . get Accessible Objects ( permissions , identifiers ) ; if ( ! identifiers . is Empty ( ) ) { Collection < Sharing Profile > sharing Profiles = sharing Profile Directory . get All ( identifiers ) ; add Sharing Profiles ( sharing Profiles ) ; } }
private void add Connection Descendants ( Collection < Connection > connections , List < Object Permission . Type > permissions ) throws Guacamole Exception { if ( connections . is Empty ( ) ) return ; Collection < String > identifiers = new Array List < String > ( ) ; for ( Connection connection : connections ) identifiers . add All ( connection . get Sharing Profile Identifiers ( ) ) ; if ( permissions != null && ! permissions . is Empty ( ) ) identifiers = sharing Profile Permissions . get Accessible Objects ( permissions , identifiers ) ; if ( ! identifiers . is Empty ( ) ) { Collection < Sharing Profile > sharing Profiles = sharing Profile Directory . get All ( identifiers ) ; add Sharing Profiles ( sharing Profiles ) ; } }
private void add Connection Descendants ( Collection < Connection > connections , List < Object Permission . Type > permissions ) throws Guacamole Exception { if ( connections . is Empty ( ) ) return ; Collection < String > identifiers = new Array List < String > ( ) ; for ( Connection connection : connections ) identifiers . add All ( connection . get Sharing Profile Identifiers ( ) ) ; if ( permissions != null && ! permissions . is Empty ( ) ) identifiers = sharing Profile Permissions . get Accessible Objects ( permissions , identifiers ) ; if ( ! identifiers . is Empty ( ) ) { Collection < Sharing Profile > sharing Profiles = sharing Profile Directory . get All ( identifiers ) ; add Sharing Profiles ( sharing Profiles ) ; } }
private void add Connection Descendants ( Collection < Connection > connections , List < Object Permission . Type > permissions ) throws Guacamole Exception { if ( connections . is Empty ( ) ) return ; Collection < String > identifiers = new Array List < String > ( ) ; for ( Connection connection : connections ) identifiers . add All ( connection . get Sharing Profile Identifiers ( ) ) ; if ( permissions != null && ! permissions . is Empty ( ) ) identifiers = sharing Profile Permissions . get Accessible Objects ( permissions , identifiers ) ; if ( ! identifiers . is Empty ( ) ) { Collection < Sharing Profile > sharing Profiles = sharing Profile Directory . get All ( identifiers ) ; add Sharing Profiles ( sharing Profiles ) ; } }
private static Map < String , Schema Object Mapping DTO > populate Object Schema ( Collection < Identity Store Object Mapping > object Mappings ) throws DTO Mapper Exception { Map < String , Schema Object Mapping DTO > object Schema Mappings = new Hash Map < String , Schema Object Mapping DTO > ( ) ; try { for ( Identity Store Object Mapping object Mapping : object Mappings ) { String object Id = object Mapping . get Object Id ( ) ; String object Class = object Mapping . get Object Class ( ) ; Map < String , String > attribute Mappings = new Hash Map < String , String > ( ) ; for ( Identity Store Attribute Mapping attribute Mapping : object Mapping . get Attribute Mappings ( ) ) { attribute Mappings . put ( attribute Mapping . get Attribute Id ( ) , attribute Mapping . get Attribute Name ( ) ) ; } object Schema Mappings . put ( object Id , new Schema Object Mapping DTO ( object Class , attribute Mappings ) ) ; } } catch ( Exception ex ) { throw new DTO Mapper Exception ( STRING ) ; } return object Schema Mappings ; }
private static Map < String , Schema Object Mapping DTO > populate Object Schema ( Collection < Identity Store Object Mapping > object Mappings ) throws DTO Mapper Exception { Map < String , Schema Object Mapping DTO > object Schema Mappings = new Hash Map < String , Schema Object Mapping DTO > ( ) ; try { for ( Identity Store Object Mapping object Mapping : object Mappings ) { String object Id = object Mapping . get Object Id ( ) ; String object Class = object Mapping . get Object Class ( ) ; Map < String , String > attribute Mappings = new Hash Map < String , String > ( ) ; for ( Identity Store Attribute Mapping attribute Mapping : object Mapping . get Attribute Mappings ( ) ) { attribute Mappings . put ( attribute Mapping . get Attribute Id ( ) , attribute Mapping . get Attribute Name ( ) ) ; } object Schema Mappings . put ( object Id , new Schema Object Mapping DTO ( object Class , attribute Mappings ) ) ; } } catch ( Exception ex ) { throw new DTO Mapper Exception ( STRING ) ; } return object Schema Mappings ; }
private static Map < String , Schema Object Mapping DTO > populate Object Schema ( Collection < Identity Store Object Mapping > object Mappings ) throws DTO Mapper Exception { Map < String , Schema Object Mapping DTO > object Schema Mappings = new Hash Map < String , Schema Object Mapping DTO > ( ) ; try { for ( Identity Store Object Mapping object Mapping : object Mappings ) { String object Id = object Mapping . get Object Id ( ) ; String object Class = object Mapping . get Object Class ( ) ; Map < String , String > attribute Mappings = new Hash Map < String , String > ( ) ; for ( Identity Store Attribute Mapping attribute Mapping : object Mapping . get Attribute Mappings ( ) ) { attribute Mappings . put ( attribute Mapping . get Attribute Id ( ) , attribute Mapping . get Attribute Name ( ) ) ; } object Schema Mappings . put ( object Id , new Schema Object Mapping DTO ( object Class , attribute Mappings ) ) ; } } catch ( Exception ex ) { throw new DTO Mapper Exception ( STRING ) ; } return object Schema Mappings ; }
private static Map < String , Schema Object Mapping DTO > populate Object Schema ( Collection < Identity Store Object Mapping > object Mappings ) throws DTO Mapper Exception { Map < String , Schema Object Mapping DTO > object Schema Mappings = new Hash Map < String , Schema Object Mapping DTO > ( ) ; try { for ( Identity Store Object Mapping object Mapping : object Mappings ) { String object Id = object Mapping . get Object Id ( ) ; String object Class = object Mapping . get Object Class ( ) ; Map < String , String > attribute Mappings = new Hash Map < String , String > ( ) ; for ( Identity Store Attribute Mapping attribute Mapping : object Mapping . get Attribute Mappings ( ) ) { attribute Mappings . put ( attribute Mapping . get Attribute Id ( ) , attribute Mapping . get Attribute Name ( ) ) ; } object Schema Mappings . put ( object Id , new Schema Object Mapping DTO ( object Class , attribute Mappings ) ) ; } } catch ( Exception ex ) { throw new DTO Mapper Exception ( STRING ) ; } return object Schema Mappings ; }
private static Map < String , Schema Object Mapping DTO > populate Object Schema ( Collection < Identity Store Object Mapping > object Mappings ) throws DTO Mapper Exception { Map < String , Schema Object Mapping DTO > object Schema Mappings = new Hash Map < String , Schema Object Mapping DTO > ( ) ; try { for ( Identity Store Object Mapping object Mapping : object Mappings ) { String object Id = object Mapping . get Object Id ( ) ; String object Class = object Mapping . get Object Class ( ) ; Map < String , String > attribute Mappings = new Hash Map < String , String > ( ) ; for ( Identity Store Attribute Mapping attribute Mapping : object Mapping . get Attribute Mappings ( ) ) { attribute Mappings . put ( attribute Mapping . get Attribute Id ( ) , attribute Mapping . get Attribute Name ( ) ) ; } object Schema Mappings . put ( object Id , new Schema Object Mapping DTO ( object Class , attribute Mappings ) ) ; } } catch ( Exception ex ) { throw new DTO Mapper Exception ( STRING ) ; } return object Schema Mappings ; }
public static void delete Directory Quickly ( File dir ) throws IO Exception { if ( ! dir . exists ( ) ) { return ; } final File to = new File ( dir . get Absolute Path ( ) + System . current Time Millis ( ) ) ; dir . rename To ( to ) ; if ( ! dir . exists ( ) ) { dir . mkdirs ( ) ; } if ( to . exists ( ) ) { String delete Cmd = STRING + to ; Runtime runtime = Runtime . get Runtime ( ) ; try { Process process = runtime . exec ( delete Cmd ) ; process . wait For ( ) ; } catch ( IO Exception e ) { } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } } if ( ! to . exists ( ) ) { return ; } delete Directory Recursively ( to ) ; if ( to . exists ( ) ) { to . delete ( ) ; } }
public static String transform All Line Separators ( String text ) { Pattern crlf = Pattern . compile ( STRING ) ; Matcher m = crlf . matcher ( text ) ; if ( m . find ( ) ) { text = m . replace All ( STRING ) ; } return text ; }
public static String transform All Line Separators ( String text ) { Pattern crlf = Pattern . compile ( STRING ) ; Matcher m = crlf . matcher ( text ) ; if ( m . find ( ) ) { text = m . replace All ( STRING ) ; } return text ; }
public static String transform All Line Separators ( String text ) { Pattern crlf = Pattern . compile ( STRING ) ; Matcher m = crlf . matcher ( text ) ; if ( m . find ( ) ) { text = m . replace All ( STRING ) ; } return text ; }
public static String transform All Line Separators ( String text ) { Pattern crlf = Pattern . compile ( STRING ) ; Matcher m = crlf . matcher ( text ) ; if ( m . find ( ) ) { text = m . replace All ( STRING ) ; } return text ; }
protected < T > void run Tasks Concurrent ( final List < Abstract Task < T > > tasks ) throws Interrupted Exception { assert resource Manager . overflow Tasks Concurrent >= NUM ; try { final List < Future < T > > futures = resource Manager . get Concurrency Manager ( ) . invoke All ( tasks , resource Manager . overflow Timeout , Time Unit . MILLISECONDS ) ; final Iterator < Abstract Task < T > > titr = tasks . iterator ( ) ; for ( Future < ? extends Object > f : futures ) { final Abstract Task < T > task = titr . next ( ) ; get Future For Task ( f , task , NUM , Time Unit . NANOSECONDS ) ; } } finally { } }
public void bind Key Store ( final Key Store Service key Store Service ) { this . key Store = key Store Service ; }
public void bind Key Store ( final Key Store Service key Store Service ) { this . key Store = key Store Service ; }
public void register Callback Handler ( SMS Object Listener change Listener ) throws SMS Exception { object Listener = change Listener ; if ( ! notification Initialized ) { String notification Flag = System Properties . get ( NOTIFICATION PROPERTY , STRING ) ; if ( notification Flag . equals Ignore Case ( STRING ) ) { try { URL url = Webtop Naming . get Notification URL ( ) ; PLL Client . add Notification Handler ( JAXRPC Util . SMS SERVICE , new SMS Notification Handler ( ) ) ; client . send ( STRING , url . to String ( ) , null , null ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + url ) ; } } catch ( Exception e ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STRING + STRING + e . get Message ( ) + STRING ) ; } start Polling Thread If Enabled ( get Cache Polling Interval ( ) ) ; } } else { start Polling Thread If Enabled ( get Cache Polling Interval ( ) ) ; } notification Initialized = BOOL ; } }
public I Variable [ ] extract Robot Debug Variables ( final int stack Trace Id , final Map < String , Object > new Variables ) { final Robot Debug Variables Context current Variables Context = find Current Variables Context ( stack Trace Id ) ; Map < String , I Variable > previous Variables Map = init Previous Variables State ( current Variables Context ) ; final Map < String , I Variable > non Global Variables Map = new Linked Hash Map < > ( ) ; if ( previous Variables Map == null ) { init New Non Global Variables ( new Variables , non Global Variables Map ) ; } else { init Variables Comparing With Previous State ( new Variables , previous Variables Map , non Global Variables Map ) ; } final Linked List < I Variable > current Variables List = create Current Variables List ( non Global Variables Map ) ; save Current Variables State ( stack Trace Id , current Variables Context , non Global Variables Map ) ; return current Variables List . to Array ( new I Variable [ current Variables List . size ( ) ] ) ; }
public I Variable [ ] extract Robot Debug Variables ( final int stack Trace Id , final Map < String , Object > new Variables ) { final Robot Debug Variables Context current Variables Context = find Current Variables Context ( stack Trace Id ) ; Map < String , I Variable > previous Variables Map = init Previous Variables State ( current Variables Context ) ; final Map < String , I Variable > non Global Variables Map = new Linked Hash Map < > ( ) ; if ( previous Variables Map == null ) { init New Non Global Variables ( new Variables , non Global Variables Map ) ; } else { init Variables Comparing With Previous State ( new Variables , previous Variables Map , non Global Variables Map ) ; } final Linked List < I Variable > current Variables List = create Current Variables List ( non Global Variables Map ) ; save Current Variables State ( stack Trace Id , current Variables Context , non Global Variables Map ) ; return current Variables List . to Array ( new I Variable [ current Variables List . size ( ) ] ) ; }
public I Variable [ ] extract Robot Debug Variables ( final int stack Trace Id , final Map < String , Object > new Variables ) { final Robot Debug Variables Context current Variables Context = find Current Variables Context ( stack Trace Id ) ; Map < String , I Variable > previous Variables Map = init Previous Variables State ( current Variables Context ) ; final Map < String , I Variable > non Global Variables Map = new Linked Hash Map < > ( ) ; if ( previous Variables Map == null ) { init New Non Global Variables ( new Variables , non Global Variables Map ) ; } else { init Variables Comparing With Previous State ( new Variables , previous Variables Map , non Global Variables Map ) ; } final Linked List < I Variable > current Variables List = create Current Variables List ( non Global Variables Map ) ; save Current Variables State ( stack Trace Id , current Variables Context , non Global Variables Map ) ; return current Variables List . to Array ( new I Variable [ current Variables List . size ( ) ] ) ; }
public I Variable [ ] extract Robot Debug Variables ( final int stack Trace Id , final Map < String , Object > new Variables ) { final Robot Debug Variables Context current Variables Context = find Current Variables Context ( stack Trace Id ) ; Map < String , I Variable > previous Variables Map = init Previous Variables State ( current Variables Context ) ; final Map < String , I Variable > non Global Variables Map = new Linked Hash Map < > ( ) ; if ( previous Variables Map == null ) { init New Non Global Variables ( new Variables , non Global Variables Map ) ; } else { init Variables Comparing With Previous State ( new Variables , previous Variables Map , non Global Variables Map ) ; } final Linked List < I Variable > current Variables List = create Current Variables List ( non Global Variables Map ) ; save Current Variables State ( stack Trace Id , current Variables Context , non Global Variables Map ) ; return current Variables List . to Array ( new I Variable [ current Variables List . size ( ) ] ) ; }
public I Variable [ ] extract Robot Debug Variables ( final int stack Trace Id , final Map < String , Object > new Variables ) { final Robot Debug Variables Context current Variables Context = find Current Variables Context ( stack Trace Id ) ; Map < String , I Variable > previous Variables Map = init Previous Variables State ( current Variables Context ) ; final Map < String , I Variable > non Global Variables Map = new Linked Hash Map < > ( ) ; if ( previous Variables Map == null ) { init New Non Global Variables ( new Variables , non Global Variables Map ) ; } else { init Variables Comparing With Previous State ( new Variables , previous Variables Map , non Global Variables Map ) ; } final Linked List < I Variable > current Variables List = create Current Variables List ( non Global Variables Map ) ; save Current Variables State ( stack Trace Id , current Variables Context , non Global Variables Map ) ; return current Variables List . to Array ( new I Variable [ current Variables List . size ( ) ] ) ; }
public I Variable [ ] extract Robot Debug Variables ( final int stack Trace Id , final Map < String , Object > new Variables ) { final Robot Debug Variables Context current Variables Context = find Current Variables Context ( stack Trace Id ) ; Map < String , I Variable > previous Variables Map = init Previous Variables State ( current Variables Context ) ; final Map < String , I Variable > non Global Variables Map = new Linked Hash Map < > ( ) ; if ( previous Variables Map == null ) { init New Non Global Variables ( new Variables , non Global Variables Map ) ; } else { init Variables Comparing With Previous State ( new Variables , previous Variables Map , non Global Variables Map ) ; } final Linked List < I Variable > current Variables List = create Current Variables List ( non Global Variables Map ) ; save Current Variables State ( stack Trace Id , current Variables Context , non Global Variables Map ) ; return current Variables List . to Array ( new I Variable [ current Variables List . size ( ) ] ) ; }
public I Variable [ ] extract Robot Debug Variables ( final int stack Trace Id , final Map < String , Object > new Variables ) { final Robot Debug Variables Context current Variables Context = find Current Variables Context ( stack Trace Id ) ; Map < String , I Variable > previous Variables Map = init Previous Variables State ( current Variables Context ) ; final Map < String , I Variable > non Global Variables Map = new Linked Hash Map < > ( ) ; if ( previous Variables Map == null ) { init New Non Global Variables ( new Variables , non Global Variables Map ) ; } else { init Variables Comparing With Previous State ( new Variables , previous Variables Map , non Global Variables Map ) ; } final Linked List < I Variable > current Variables List = create Current Variables List ( non Global Variables Map ) ; save Current Variables State ( stack Trace Id , current Variables Context , non Global Variables Map ) ; return current Variables List . to Array ( new I Variable [ current Variables List . size ( ) ] ) ; }
Eval Thread ( Context Info context Info ) { super ( null ) ; this . context Info = context Info ; set Daemon ( BOOL ) ; }
public Thread Queue ( ) { q Threads = new Linked List ( ) ; }
public Thread Queue ( ) { q Threads = new Linked List ( ) ; }
private static void generate Events ( ) throws Exception { String region Name = Region . SEPARATOR + REGION NAME ; Region region = cache . get Region ( region Name ) ; for ( int i = NUM ; i < TOTAL PUTS ; i ++ ) { region . put ( STRING + i , STRING + i ) ; } Thread . sleep ( DISPATCHER SLOWSTART TIME + NUM ) ; for ( int i = NUM ; i < NUM ; i ++ ) { region . put ( LAST KEY , STRING ) ; } }
private static void generate Events ( ) throws Exception { String region Name = Region . SEPARATOR + REGION NAME ; Region region = cache . get Region ( region Name ) ; for ( int i = NUM ; i < TOTAL PUTS ; i ++ ) { region . put ( STRING + i , STRING + i ) ; } Thread . sleep ( DISPATCHER SLOWSTART TIME + NUM ) ; for ( int i = NUM ; i < NUM ; i ++ ) { region . put ( LAST KEY , STRING ) ; } }
private static void generate Events ( ) throws Exception { String region Name = Region . SEPARATOR + REGION NAME ; Region region = cache . get Region ( region Name ) ; for ( int i = NUM ; i < TOTAL PUTS ; i ++ ) { region . put ( STRING + i , STRING + i ) ; } Thread . sleep ( DISPATCHER SLOWSTART TIME + NUM ) ; for ( int i = NUM ; i < NUM ; i ++ ) { region . put ( LAST KEY , STRING ) ; } }
private static void generate Events ( ) throws Exception { String region Name = Region . SEPARATOR + REGION NAME ; Region region = cache . get Region ( region Name ) ; for ( int i = NUM ; i < TOTAL PUTS ; i ++ ) { region . put ( STRING + i , STRING + i ) ; } Thread . sleep ( DISPATCHER SLOWSTART TIME + NUM ) ; for ( int i = NUM ; i < NUM ; i ++ ) { region . put ( LAST KEY , STRING ) ; } }
private static void generate Events ( ) throws Exception { String region Name = Region . SEPARATOR + REGION NAME ; Region region = cache . get Region ( region Name ) ; for ( int i = NUM ; i < TOTAL PUTS ; i ++ ) { region . put ( STRING + i , STRING + i ) ; } Thread . sleep ( DISPATCHER SLOWSTART TIME + NUM ) ; for ( int i = NUM ; i < NUM ; i ++ ) { region . put ( LAST KEY , STRING ) ; } }
private static void generate Events ( ) throws Exception { String region Name = Region . SEPARATOR + REGION NAME ; Region region = cache . get Region ( region Name ) ; for ( int i = NUM ; i < TOTAL PUTS ; i ++ ) { region . put ( STRING + i , STRING + i ) ; } Thread . sleep ( DISPATCHER SLOWSTART TIME + NUM ) ; for ( int i = NUM ; i < NUM ; i ++ ) { region . put ( LAST KEY , STRING ) ; } }
private static void generate Events ( ) throws Exception { String region Name = Region . SEPARATOR + REGION NAME ; Region region = cache . get Region ( region Name ) ; for ( int i = NUM ; i < TOTAL PUTS ; i ++ ) { region . put ( STRING + i , STRING + i ) ; } Thread . sleep ( DISPATCHER SLOWSTART TIME + NUM ) ; for ( int i = NUM ; i < NUM ; i ++ ) { region . put ( LAST KEY , STRING ) ; } }
protected void add To GUI ( J Panel gui , J Text Field b , String cmd ) { b . set Action Command ( cmd ) ; b . add Action Listener ( this ) ; gui . add ( b ) ; }
private Op Enum ( String name ) { this . name = name ; map . put ( name , this ) ; }
private void history Add ( String text ) { if ( ! text . is Empty ( ) ) { history . remove ( text ) ; history . add ( text ) ; } }
private void history Add ( String text ) { if ( ! text . is Empty ( ) ) { history . remove ( text ) ; history . add ( text ) ; } }
private void history Add ( String text ) { if ( ! text . is Empty ( ) ) { history . remove ( text ) ; history . add ( text ) ; } }
public static Attribute attribute From Annotation Value ( Processing Environment env , Executable Element meth , Annotation Value av ) { return av . accept ( new Attribute Creator ( env , meth ) , null ) ; }
private < T extends Draft 3 Resource > T look For Resource ( Draft 3 Resource Type type , Class < T > clazz ) { List < T > resources = look For Resources ( type , clazz ) ; return resources != null && resources . size ( ) > NUM ? resources . get ( NUM ) : null ; }
private < T extends Draft 3 Resource > T look For Resource ( Draft 3 Resource Type type , Class < T > clazz ) { List < T > resources = look For Resources ( type , clazz ) ; return resources != null && resources . size ( ) > NUM ? resources . get ( NUM ) : null ; }
public void enable ( ) { if ( this . task Id == - NUM ) { start ( ) ; } }
public static String trim And Convert Empty To Null ( String str ) { if ( str == null ) { return null ; } String new Str = str . trim ( ) ; if ( new Str . length ( ) < NUM ) { return null ; } return new Str ; }
public static String trim And Convert Empty To Null ( String str ) { if ( str == null ) { return null ; } String new Str = str . trim ( ) ; if ( new Str . length ( ) < NUM ) { return null ; } return new Str ; }
public static String trim And Convert Empty To Null ( String str ) { if ( str == null ) { return null ; } String new Str = str . trim ( ) ; if ( new Str . length ( ) < NUM ) { return null ; } return new Str ; }
public void deregister ( Train train ) { if ( train == null ) { return ; } train . dispose ( ) ; Integer old Size = Integer . value Of ( train Hash Table . size ( ) ) ; train Hash Table . remove ( train . get Id ( ) ) ; set Dirty And Fire Property Change ( LISTLENGTH CHANGED PROPERTY , old Size , Integer . value Of ( train Hash Table . size ( ) ) ) ; }
public void deregister ( Train train ) { if ( train == null ) { return ; } train . dispose ( ) ; Integer old Size = Integer . value Of ( train Hash Table . size ( ) ) ; train Hash Table . remove ( train . get Id ( ) ) ; set Dirty And Fire Property Change ( LISTLENGTH CHANGED PROPERTY , old Size , Integer . value Of ( train Hash Table . size ( ) ) ) ; }
public void deregister ( Train train ) { if ( train == null ) { return ; } train . dispose ( ) ; Integer old Size = Integer . value Of ( train Hash Table . size ( ) ) ; train Hash Table . remove ( train . get Id ( ) ) ; set Dirty And Fire Property Change ( LISTLENGTH CHANGED PROPERTY , old Size , Integer . value Of ( train Hash Table . size ( ) ) ) ; }
protected void remove Range ( int from Index , int to Index ) { mod Count ++ ; int num Moved = element Count - to Index ; System . arraycopy ( element Data , to Index , element Data , from Index , num Moved ) ; int new Element Count = element Count - ( to Index - from Index ) ; while ( element Count != new Element Count ) element Data [ -- element Count ] = null ; }
protected void remove Range ( int from Index , int to Index ) { mod Count ++ ; int num Moved = element Count - to Index ; System . arraycopy ( element Data , to Index , element Data , from Index , num Moved ) ; int new Element Count = element Count - ( to Index - from Index ) ; while ( element Count != new Element Count ) element Data [ -- element Count ] = null ; }
protected void remove Range ( int from Index , int to Index ) { mod Count ++ ; int num Moved = element Count - to Index ; System . arraycopy ( element Data , to Index , element Data , from Index , num Moved ) ; int new Element Count = element Count - ( to Index - from Index ) ; while ( element Count != new Element Count ) element Data [ -- element Count ] = null ; }
protected void remove Range ( int from Index , int to Index ) { mod Count ++ ; int num Moved = element Count - to Index ; System . arraycopy ( element Data , to Index , element Data , from Index , num Moved ) ; int new Element Count = element Count - ( to Index - from Index ) ; while ( element Count != new Element Count ) element Data [ -- element Count ] = null ; }
public void update ( String ws Id , long activity Time ) { if ( expire Period > NUM ) { active Workspaces . put ( ws Id , activity Time + expire Period ) ; } }
private void run Read Test ( byte [ ] input , Compression Mode mode ) throws IO Exception { run Read Test ( input , mode , mode ) ; }
private void run Read Test ( byte [ ] input , Compression Mode mode ) throws IO Exception { run Read Test ( input , mode , mode ) ; }
private void run Read Test ( byte [ ] input , Compression Mode mode ) throws IO Exception { run Read Test ( input , mode , mode ) ; }
public R params To Multipart Entity ( ) { try { m Http Entity = create Multipart Entity ( BOOL ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } return ( R ) this ; }
public R params To Multipart Entity ( ) { try { m Http Entity = create Multipart Entity ( BOOL ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } return ( R ) this ; }
private static native int mlockall ( int flags ) ;
private static native int mlockall ( int flags ) ;
private static native int mlockall ( int flags ) ;
public static int try Parse Int ( String to Parse , String default Value ) { int result ; try { result = Integer . parse Int ( to Parse ) ; } catch ( Number Format Exception ex ) { result = Integer . parse Int ( default Value ) ; } return result ; }
public static int try Parse Int ( String to Parse , String default Value ) { int result ; try { result = Integer . parse Int ( to Parse ) ; } catch ( Number Format Exception ex ) { result = Integer . parse Int ( default Value ) ; } return result ; }
public static int try Parse Int ( String to Parse , String default Value ) { int result ; try { result = Integer . parse Int ( to Parse ) ; } catch ( Number Format Exception ex ) { result = Integer . parse Int ( default Value ) ; } return result ; }
public static int try Parse Int ( String to Parse , String default Value ) { int result ; try { result = Integer . parse Int ( to Parse ) ; } catch ( Number Format Exception ex ) { result = Integer . parse Int ( default Value ) ; } return result ; }
private void release ( ) { pages . clear ( ) ; pages rendered . clear ( ) ; error = null ; is Working = BOOL ; file name = null ; file = null ; if ( ring Progress Dialog != null ) { ring Progress Dialog . dismiss ( ) ; ring Progress Dialog = null ; } }
public void register Code Node Context Menu Extension ( final I Code Node Extension extension ) { Preconditions . check Not Null ( extension , STRING ) ; m code Node Extensions . add ( extension ) ; }
public void register Code Node Context Menu Extension ( final I Code Node Extension extension ) { Preconditions . check Not Null ( extension , STRING ) ; m code Node Extensions . add ( extension ) ; }
private int [ ] merge Estimators ( Hyper Log Log Plus other ) { other . merge Temp List ( ) ; int [ ] tmp = other . get Sparse Set ( ) ; merge Temp List ( ) ; int [ ] set = sparse Set ; List < Integer > new Set = new Array List < Integer > ( ) ; int seti = NUM ; int tmpi = NUM ; while ( seti < set . length || tmpi < tmp . length ) { if ( seti >= set . length ) { new Set . add ( tmp [ tmpi ++ ] ) ; } else if ( tmpi >= tmp . length ) { new Set . add ( set [ seti ++ ] ) ; } else { int set Val = set [ seti ] ; int tmp Val = tmp [ tmpi ] ; if ( get Sparse Index ( set Val ) == get Sparse Index ( tmp Val ) ) { new Set . add ( Math . min ( set Val , tmp Val ) ) ; tmpi ++ ; seti ++ ; } else if ( get Sparse Index ( set Val ) < get Sparse Index ( tmp Val ) ) { new Set . add ( set Val ) ; seti ++ ; } else { new Set . add ( tmp Val ) ; tmpi ++ ; } } } return to Int Array ( new Set ) ; }
private int [ ] merge Estimators ( Hyper Log Log Plus other ) { other . merge Temp List ( ) ; int [ ] tmp = other . get Sparse Set ( ) ; merge Temp List ( ) ; int [ ] set = sparse Set ; List < Integer > new Set = new Array List < Integer > ( ) ; int seti = NUM ; int tmpi = NUM ; while ( seti < set . length || tmpi < tmp . length ) { if ( seti >= set . length ) { new Set . add ( tmp [ tmpi ++ ] ) ; } else if ( tmpi >= tmp . length ) { new Set . add ( set [ seti ++ ] ) ; } else { int set Val = set [ seti ] ; int tmp Val = tmp [ tmpi ] ; if ( get Sparse Index ( set Val ) == get Sparse Index ( tmp Val ) ) { new Set . add ( Math . min ( set Val , tmp Val ) ) ; tmpi ++ ; seti ++ ; } else if ( get Sparse Index ( set Val ) < get Sparse Index ( tmp Val ) ) { new Set . add ( set Val ) ; seti ++ ; } else { new Set . add ( tmp Val ) ; tmpi ++ ; } } } return to Int Array ( new Set ) ; }
private int [ ] merge Estimators ( Hyper Log Log Plus other ) { other . merge Temp List ( ) ; int [ ] tmp = other . get Sparse Set ( ) ; merge Temp List ( ) ; int [ ] set = sparse Set ; List < Integer > new Set = new Array List < Integer > ( ) ; int seti = NUM ; int tmpi = NUM ; while ( seti < set . length || tmpi < tmp . length ) { if ( seti >= set . length ) { new Set . add ( tmp [ tmpi ++ ] ) ; } else if ( tmpi >= tmp . length ) { new Set . add ( set [ seti ++ ] ) ; } else { int set Val = set [ seti ] ; int tmp Val = tmp [ tmpi ] ; if ( get Sparse Index ( set Val ) == get Sparse Index ( tmp Val ) ) { new Set . add ( Math . min ( set Val , tmp Val ) ) ; tmpi ++ ; seti ++ ; } else if ( get Sparse Index ( set Val ) < get Sparse Index ( tmp Val ) ) { new Set . add ( set Val ) ; seti ++ ; } else { new Set . add ( tmp Val ) ; tmpi ++ ; } } } return to Int Array ( new Set ) ; }
private int [ ] merge Estimators ( Hyper Log Log Plus other ) { other . merge Temp List ( ) ; int [ ] tmp = other . get Sparse Set ( ) ; merge Temp List ( ) ; int [ ] set = sparse Set ; List < Integer > new Set = new Array List < Integer > ( ) ; int seti = NUM ; int tmpi = NUM ; while ( seti < set . length || tmpi < tmp . length ) { if ( seti >= set . length ) { new Set . add ( tmp [ tmpi ++ ] ) ; } else if ( tmpi >= tmp . length ) { new Set . add ( set [ seti ++ ] ) ; } else { int set Val = set [ seti ] ; int tmp Val = tmp [ tmpi ] ; if ( get Sparse Index ( set Val ) == get Sparse Index ( tmp Val ) ) { new Set . add ( Math . min ( set Val , tmp Val ) ) ; tmpi ++ ; seti ++ ; } else if ( get Sparse Index ( set Val ) < get Sparse Index ( tmp Val ) ) { new Set . add ( set Val ) ; seti ++ ; } else { new Set . add ( tmp Val ) ; tmpi ++ ; } } } return to Int Array ( new Set ) ; }
private int [ ] merge Estimators ( Hyper Log Log Plus other ) { other . merge Temp List ( ) ; int [ ] tmp = other . get Sparse Set ( ) ; merge Temp List ( ) ; int [ ] set = sparse Set ; List < Integer > new Set = new Array List < Integer > ( ) ; int seti = NUM ; int tmpi = NUM ; while ( seti < set . length || tmpi < tmp . length ) { if ( seti >= set . length ) { new Set . add ( tmp [ tmpi ++ ] ) ; } else if ( tmpi >= tmp . length ) { new Set . add ( set [ seti ++ ] ) ; } else { int set Val = set [ seti ] ; int tmp Val = tmp [ tmpi ] ; if ( get Sparse Index ( set Val ) == get Sparse Index ( tmp Val ) ) { new Set . add ( Math . min ( set Val , tmp Val ) ) ; tmpi ++ ; seti ++ ; } else if ( get Sparse Index ( set Val ) < get Sparse Index ( tmp Val ) ) { new Set . add ( set Val ) ; seti ++ ; } else { new Set . add ( tmp Val ) ; tmpi ++ ; } } } return to Int Array ( new Set ) ; }
private int [ ] merge Estimators ( Hyper Log Log Plus other ) { other . merge Temp List ( ) ; int [ ] tmp = other . get Sparse Set ( ) ; merge Temp List ( ) ; int [ ] set = sparse Set ; List < Integer > new Set = new Array List < Integer > ( ) ; int seti = NUM ; int tmpi = NUM ; while ( seti < set . length || tmpi < tmp . length ) { if ( seti >= set . length ) { new Set . add ( tmp [ tmpi ++ ] ) ; } else if ( tmpi >= tmp . length ) { new Set . add ( set [ seti ++ ] ) ; } else { int set Val = set [ seti ] ; int tmp Val = tmp [ tmpi ] ; if ( get Sparse Index ( set Val ) == get Sparse Index ( tmp Val ) ) { new Set . add ( Math . min ( set Val , tmp Val ) ) ; tmpi ++ ; seti ++ ; } else if ( get Sparse Index ( set Val ) < get Sparse Index ( tmp Val ) ) { new Set . add ( set Val ) ; seti ++ ; } else { new Set . add ( tmp Val ) ; tmpi ++ ; } } } return to Int Array ( new Set ) ; }
private Object execute Plus ( Page Context pc , SQL sql , Query qr , Z Expression expression , int row ) throws Page Exception { Object left = execute Exp ( pc , sql , qr , expression . get Operand ( NUM ) , row ) ; Object right = execute Exp ( pc , sql , qr , expression . get Operand ( NUM ) , row ) ; try { return new Double ( Caster . to Double Value ( left ) + Caster . to Double Value ( right ) ) ; } catch ( Page Exception e ) { return Caster . to String ( left ) + Caster . to String ( right ) ; } }
public void add Sub Node ( final Nav Node sub Node ) { sub Nodes . add ( sub Node ) ; sub Node . set Parent ( this ) ; Collections . sort ( sub Nodes , NODE COMPARATOR ) ; }
private void handle Service Bound H ( ) { if ( m Verb != VERB BINDING ) { close And Cleanup Job H ( BOOL ) ; return ; } if ( m Cancelled . get ( ) ) { close And Cleanup Job H ( BOOL ) ; return ; } try { m Verb = VERB STARTING ; schedule Op Time Out ( ) ; service . start Job ( m Params ) ; } catch ( Remote Exception e ) { e . print Stack Trace ( ) ; } }
public double normalized Kernel ( char [ ] s , char [ ] t ) { double k1 = unnormalized Kernel ( s , s ) ; double k2 = unnormalized Kernel ( t , t ) ; double norm Term = Math . sqrt ( k1 * k2 ) ; return unnormalized Kernel ( s , t ) / norm Term ; }
public double normalized Kernel ( char [ ] s , char [ ] t ) { double k1 = unnormalized Kernel ( s , s ) ; double k2 = unnormalized Kernel ( t , t ) ; double norm Term = Math . sqrt ( k1 * k2 ) ; return unnormalized Kernel ( s , t ) / norm Term ; }
@ Override public void dispose ( ) { if ( receive Thread != null ) { receive Thread . interrupt ( ) ; try { receive Thread . join ( ) ; } catch ( Interrupted Exception e ) { } receive Thread = null ; } if ( serial Port != null ) { serial Port . close ( ) ; serial Port = null ; } logger . info ( STRING ) ; super . dispose ( ) ; }
static protected String [ ] split Line CSV ( String line ) { char [ ] c = line . to Char Array ( ) ; int rough = NUM ; boolean quote = BOOL ; for ( int i = NUM ; i < c . length ; i ++ ) { if ( ! quote && ( c [ i ] == STRING ) ) { rough ++ ; } else if ( c [ i ] == STRING ) { quote = ! quote ; } } String [ ] pieces = new String [ rough ] ; int piece Count = NUM ; int offset = NUM ; while ( offset < c . length ) { int start = offset ; int stop = next Comma ( c , offset ) ; offset = stop + NUM ; if ( c [ start ] == STRING && c [ stop - NUM ] == STRING ) { start ++ ; stop -- ; } int i = start ; int ii = start ; while ( i < stop ) { if ( c [ i ] == STRING ) { i ++ ; } if ( i != ii ) { c [ ii ] = c [ i ] ; } i ++ ; ii ++ ; } String s = new String ( c , start , ii - start ) ; pieces [ piece Count ++ ] = s ; } for ( int i = piece Count ; i < pieces . length ; i ++ ) { pieces [ i ] = STRING ; } return pieces ; }
private void handle Prepared Statement Cluster Error ( Throwable e ) { int hnd Num = prep Statement Handlers Cnt . increment And Get ( ) ; try { synchronized ( prep Statement Handlers Cnt ) { if ( hnd Num != NUM ) { log . warning ( STRING , e ) ; return ; } log . warning ( STRING , e ) ; refresh ( ) ; log . warning ( STRING ) ; } } finally { if ( hnd Num == NUM ) prep Statement Handlers Cnt . set ( - NUM ) ; } }
public Document create ( String database , String table , String json ) throws Index Parse Exception { verify Table ( database , table ) ; Document doc = new Document ( ) ; doc . set Table ( database , table ) ; doc . set Object As String ( json ) ; doc . set Uuid ( UUID . random UUID ( ) ) ; Validation Engine . validate And Throw ( doc ) ; try { Document created = doc Repo . create ( doc ) ; notify All Plugins ( Notifier Plugin . Mutate Type . CREATE , created ) ; return created ; } catch ( Runtime Exception e ) { if ( e . get Cause ( ) != null && e . get Cause ( ) instanceof Index Parse Exception ) { throw ( Index Parse Exception ) e . get Cause ( ) ; } else { throw e ; } } }
public String query ( String handler , Solr Query Request req ) throws Exception { try ( Solr Core core = get Core Inc ( ) ) { Solr Query Response rsp = new Solr Query Response ( ) ; Solr Request Info . set Request Info ( new Solr Request Info ( req , rsp ) ) ; core . execute ( core . get Request Handler ( handler ) , req , rsp ) ; if ( rsp . get Exception ( ) != null ) { throw rsp . get Exception ( ) ; } String Writer sw = new String Writer ( NUM ) ; Query Response Writer response Writer = core . get Query Response Writer ( req ) ; response Writer . write ( sw , req , rsp ) ; req . close ( ) ; return sw . to String ( ) ; } finally { req . close ( ) ; Solr Request Info . clear Request Info ( ) ; } }
public String query ( String handler , Solr Query Request req ) throws Exception { try ( Solr Core core = get Core Inc ( ) ) { Solr Query Response rsp = new Solr Query Response ( ) ; Solr Request Info . set Request Info ( new Solr Request Info ( req , rsp ) ) ; core . execute ( core . get Request Handler ( handler ) , req , rsp ) ; if ( rsp . get Exception ( ) != null ) { throw rsp . get Exception ( ) ; } String Writer sw = new String Writer ( NUM ) ; Query Response Writer response Writer = core . get Query Response Writer ( req ) ; response Writer . write ( sw , req , rsp ) ; req . close ( ) ; return sw . to String ( ) ; } finally { req . close ( ) ; Solr Request Info . clear Request Info ( ) ; } }
public String query ( String handler , Solr Query Request req ) throws Exception { try ( Solr Core core = get Core Inc ( ) ) { Solr Query Response rsp = new Solr Query Response ( ) ; Solr Request Info . set Request Info ( new Solr Request Info ( req , rsp ) ) ; core . execute ( core . get Request Handler ( handler ) , req , rsp ) ; if ( rsp . get Exception ( ) != null ) { throw rsp . get Exception ( ) ; } String Writer sw = new String Writer ( NUM ) ; Query Response Writer response Writer = core . get Query Response Writer ( req ) ; response Writer . write ( sw , req , rsp ) ; req . close ( ) ; return sw . to String ( ) ; } finally { req . close ( ) ; Solr Request Info . clear Request Info ( ) ; } }
public String query ( String handler , Solr Query Request req ) throws Exception { try ( Solr Core core = get Core Inc ( ) ) { Solr Query Response rsp = new Solr Query Response ( ) ; Solr Request Info . set Request Info ( new Solr Request Info ( req , rsp ) ) ; core . execute ( core . get Request Handler ( handler ) , req , rsp ) ; if ( rsp . get Exception ( ) != null ) { throw rsp . get Exception ( ) ; } String Writer sw = new String Writer ( NUM ) ; Query Response Writer response Writer = core . get Query Response Writer ( req ) ; response Writer . write ( sw , req , rsp ) ; req . close ( ) ; return sw . to String ( ) ; } finally { req . close ( ) ; Solr Request Info . clear Request Info ( ) ; } }
public void store Device Type Certificate ( String path , String secret , String device Type Id ) throws Key Store Exception { char [ ] secret As Chars = secret . to Char Array ( ) ; Certificate certificate = null ; Key key = null ; try { Key Store temp Key Store = load ( STRING , path , secret As Chars ) ; String alias = STRING ; key = temp Key Store . get Key ( alias , secret As Chars ) ; certificate = temp Key Store . get Certificate ( alias ) ; } catch ( Key Store Exception | No Such Algorithm Exception | Unrecoverable Key Exception e ) { throw new Key Store Exception ( STRING , e ) ; } store Certificate ( STRING , certificate , key ) ; }
public byte [ ] decrypt Mac Key ( String enc Mac Key Base 64 , String server Public Key Base 64 ) throws Association Exception { byte [ ] hzz = get Digested ZZ ( server Public Key Base 64 ) ; byte [ ] enc Mac Key = Base 64 . decode Base 64 ( enc Mac Key Base 64 . get Bytes ( ) ) ; if ( hzz . length != enc Mac Key . length ) throw new Association Exception ( STRING ) ; byte [ ] mac Key = new byte [ hzz . length ] ; for ( int i = NUM ; i < hzz . length ; i ++ ) { byte b1 = hzz [ i ] ; byte b2 = enc Mac Key [ i ] ; mac Key [ i ] = ( byte ) ( b1 ^ b2 ) ; } if ( DEBUG ) log . debug ( STRING + new String ( Base 64 . encode Base 64 ( mac Key ) ) ) ; return mac Key ; }
public byte [ ] decrypt Mac Key ( String enc Mac Key Base 64 , String server Public Key Base 64 ) throws Association Exception { byte [ ] hzz = get Digested ZZ ( server Public Key Base 64 ) ; byte [ ] enc Mac Key = Base 64 . decode Base 64 ( enc Mac Key Base 64 . get Bytes ( ) ) ; if ( hzz . length != enc Mac Key . length ) throw new Association Exception ( STRING ) ; byte [ ] mac Key = new byte [ hzz . length ] ; for ( int i = NUM ; i < hzz . length ; i ++ ) { byte b1 = hzz [ i ] ; byte b2 = enc Mac Key [ i ] ; mac Key [ i ] = ( byte ) ( b1 ^ b2 ) ; } if ( DEBUG ) log . debug ( STRING + new String ( Base 64 . encode Base 64 ( mac Key ) ) ) ; return mac Key ; }
public int no Of Tabs ( ) { return m cur Win Tab . get Tab Count ( ) ; }
default < T > void for Each Matching Field Name With Boolean ( String regex , Bi Consumer < String , Boolean > function ) { for Each Matching Field Name With Boolean ( Pattern . compile ( regex ) , NUM , function ) ; }
public boolean connect ( final String address ) { if ( is Scanning ) scan Le Device ( BOOL ) ; close ( ) ; if ( m Bluetooth Adapter == null || address == null ) { Log . w ( TAG , STRING ) ; return BOOL ; } if ( m Bluetooth Gatt != null && m Bluetooth Device Address != null && address . equals ( m Bluetooth Device Address ) ) { Log . d ( TAG , STRING ) ; if ( m Bluetooth Gatt . connect ( ) ) { m Conn State = STATE CONNECTING ; return BOOL ; } else { return BOOL ; } } final Bluetooth Device device = m Bluetooth Adapter . get Remote Device ( address ) ; if ( device == null ) { Log . w ( TAG , STRING ) ; return BOOL ; } m Bluetooth Gatt = device . connect Gatt ( this , BOOL , m Gatt Callback ) ; Log . d ( TAG , STRING ) ; m Bluetooth Device Address = address ; m Conn State = STATE CONNECTING ; return BOOL ; }
public boolean connect ( final String address ) { if ( is Scanning ) scan Le Device ( BOOL ) ; close ( ) ; if ( m Bluetooth Adapter == null || address == null ) { Log . w ( TAG , STRING ) ; return BOOL ; } if ( m Bluetooth Gatt != null && m Bluetooth Device Address != null && address . equals ( m Bluetooth Device Address ) ) { Log . d ( TAG , STRING ) ; if ( m Bluetooth Gatt . connect ( ) ) { m Conn State = STATE CONNECTING ; return BOOL ; } else { return BOOL ; } } final Bluetooth Device device = m Bluetooth Adapter . get Remote Device ( address ) ; if ( device == null ) { Log . w ( TAG , STRING ) ; return BOOL ; } m Bluetooth Gatt = device . connect Gatt ( this , BOOL , m Gatt Callback ) ; Log . d ( TAG , STRING ) ; m Bluetooth Device Address = address ; m Conn State = STATE CONNECTING ; return BOOL ; }
public < T extends JC Tree > void print Exprs ( List < T > trees , String sep ) throws IO Exception { if ( trees . non Empty ( ) ) { print Expr ( trees . head ) ; for ( List < T > l = trees . tail ; l . non Empty ( ) ; l = l . tail ) { print ( sep ) ; if ( sep . ends With ( STRING ) ) { align ( ) ; } print Expr ( l . head ) ; } } }
public < T extends JC Tree > void print Exprs ( List < T > trees , String sep ) throws IO Exception { if ( trees . non Empty ( ) ) { print Expr ( trees . head ) ; for ( List < T > l = trees . tail ; l . non Empty ( ) ; l = l . tail ) { print ( sep ) ; if ( sep . ends With ( STRING ) ) { align ( ) ; } print Expr ( l . head ) ; } } }
public Argument Exception ( final Localizable Message message ) { super ( String . value Of ( message ) ) ; this . message = message ; }
final boolean do Advance ( ) { if ( buffer == null ) { if ( finished ) return BOOL ; init ( ) ; init Partial Traversal State ( ) ; next To Consume = NUM ; buffer Sink . begin ( spliterator . get Exact Size If Known ( ) ) ; return fill Buffer ( ) ; } else { ++ next To Consume ; boolean has Next = next To Consume < buffer . count ( ) ; if ( ! has Next ) { next To Consume = NUM ; buffer . clear ( ) ; has Next = fill Buffer ( ) ; } return has Next ; } }
public static Path create Temp File ( String prefix , String suffix ) throws IO Exception { Path temp Dir Path = Paths . get ( System Properties . get Temp Files Path ( ) ) ; return create Temp File ( temp Dir Path , prefix , suffix ) ; }
public static Path create Temp File ( String prefix , String suffix ) throws IO Exception { Path temp Dir Path = Paths . get ( System Properties . get Temp Files Path ( ) ) ; return create Temp File ( temp Dir Path , prefix , suffix ) ; }
private String print D Format ( short x ) { return print D Format ( Short . to String ( x ) ) ; }
private String print D Format ( short x ) { return print D Format ( Short . to String ( x ) ) ; }
private String print D Format ( short x ) { return print D Format ( Short . to String ( x ) ) ; }
private String print D Format ( short x ) { return print D Format ( Short . to String ( x ) ) ; }
private String print D Format ( short x ) { return print D Format ( Short . to String ( x ) ) ; }
private String print D Format ( short x ) { return print D Format ( Short . to String ( x ) ) ; }
public boolean remove Entry From Cache ( I Entry Holder entry Holder ) { return remove Entry From Cache ( entry Holder , BOOL , BOOL , null , Recent Delete Codes . NONE ) ; }
public void find End Block ( ) throws IO Exception { try { String token ; do { token = read Token ( STRING ) ; } while ( ! token . equals Ignore Case ( STRING ) && ! token . equals Ignore Case ( STRING ) ) ; } catch ( EOF Exception e ) { } next Block = UNKNOWN BLOCK ; }
public static String determine Initial Check Out Page ( Shopping Cart cart ) { String page = DEFAULT INIT CHECKOUT PAGE ; if ( cart == null ) return page ; if ( ! cart . shipping Applies ( ) ) { cart . set All Shipment Method Type Id ( STRING ) ; cart . set All Carrier Party Id ( STRING ) ; page = STRING ; } return page ; }
public static String determine Initial Check Out Page ( Shopping Cart cart ) { String page = DEFAULT INIT CHECKOUT PAGE ; if ( cart == null ) return page ; if ( ! cart . shipping Applies ( ) ) { cart . set All Shipment Method Type Id ( STRING ) ; cart . set All Carrier Party Id ( STRING ) ; page = STRING ; } return page ; }
public static String determine Initial Check Out Page ( Shopping Cart cart ) { String page = DEFAULT INIT CHECKOUT PAGE ; if ( cart == null ) return page ; if ( ! cart . shipping Applies ( ) ) { cart . set All Shipment Method Type Id ( STRING ) ; cart . set All Carrier Party Id ( STRING ) ; page = STRING ; } return page ; }
public static String determine Initial Check Out Page ( Shopping Cart cart ) { String page = DEFAULT INIT CHECKOUT PAGE ; if ( cart == null ) return page ; if ( ! cart . shipping Applies ( ) ) { cart . set All Shipment Method Type Id ( STRING ) ; cart . set All Carrier Party Id ( STRING ) ; page = STRING ; } return page ; }
public static String determine Initial Check Out Page ( Shopping Cart cart ) { String page = DEFAULT INIT CHECKOUT PAGE ; if ( cart == null ) return page ; if ( ! cart . shipping Applies ( ) ) { cart . set All Shipment Method Type Id ( STRING ) ; cart . set All Carrier Party Id ( STRING ) ; page = STRING ; } return page ; }
public static String convert ID 3 v 23 Genre To Generic ( String value ) { if ( value . contains ( STRING ) && value . last Index Of ( STRING ) < value . length ( ) - NUM ) { return check Bracketed ( value . substring ( NUM , value . last Index Of ( STRING ) ) ) + STRING + value . substring ( value . last Index Of ( STRING ) + NUM ) ; } else { return check Bracketed ( value ) ; } }
public static String convert ID 3 v 23 Genre To Generic ( String value ) { if ( value . contains ( STRING ) && value . last Index Of ( STRING ) < value . length ( ) - NUM ) { return check Bracketed ( value . substring ( NUM , value . last Index Of ( STRING ) ) ) + STRING + value . substring ( value . last Index Of ( STRING ) + NUM ) ; } else { return check Bracketed ( value ) ; } }
public static String convert ID 3 v 23 Genre To Generic ( String value ) { if ( value . contains ( STRING ) && value . last Index Of ( STRING ) < value . length ( ) - NUM ) { return check Bracketed ( value . substring ( NUM , value . last Index Of ( STRING ) ) ) + STRING + value . substring ( value . last Index Of ( STRING ) + NUM ) ; } else { return check Bracketed ( value ) ; } }
public boolean remove Child ( SMS Flat File Tree Node node , String base Dir ) { boolean removed = BOOL ; for ( Iterator i = children . iterator ( ) ; ( i . has Next ( ) ) && ! removed ; ) { SMS Flat File Tree Node c = ( SMS Flat File Tree Node ) i . next ( ) ; if ( c . equals ( node ) ) { i . remove ( ) ; node . clear ( base Dir ) ; removed = BOOL ; } } return removed ; }
public boolean starts With ( String str ) { if ( str == null ) { return BOOL ; } int len = str . length ( ) ; if ( len == NUM ) { return BOOL ; } if ( len > size ) { return BOOL ; } for ( int i = NUM ; i < len ; i ++ ) { if ( buffer [ i ] != str . char At ( i ) ) { return BOOL ; } } return BOOL ; }
protected void initialize With Plugin Metrics ( ) { m plugin Metrics . clear ( ) ; List < Abstract Evaluation Metric > plugin Metrics = m eval . get Plugin Metrics ( ) ; if ( plugin Metrics != null && plugin Metrics . size ( ) > NUM ) { for ( Abstract Evaluation Metric m : plugin Metrics ) { List < String > stat Names = m . get Statistic Names ( ) ; for ( String s : stat Names ) { m plugin Metrics . put ( s . to Lower Case ( ) , m ) ; } } } }
public void test Case 8 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Bytes ) ; Big Integer b Number = new Big Integer ( b Bytes ) ; Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
@ Override public void agg ( Object new Val ) { if ( new Val instanceof byte [ ] ) { Byte Buffer buffer = Byte Buffer . wrap ( ( byte [ ] ) new Val ) ; buffer . rewind ( ) ; while ( buffer . has Remaining ( ) ) { byte [ ] value Byte = new byte [ buffer . get Int ( ) ] ; buffer . get ( value Byte ) ; Big Decimal value Big Decimal = Data Type Util . byte To Big Decimal ( value Byte ) ; agg Val = agg Val . add ( value Big Decimal ) ; count += buffer . get Double ( ) ; first Time = BOOL ; } return ; } if ( first Time ) { agg Val = ( Big Decimal ) new Val ; first Time = BOOL ; } else { agg Val = agg Val . add ( ( Big Decimal ) new Val ) ; } count ++ ; }
@ Override public void agg ( Object new Val ) { if ( new Val instanceof byte [ ] ) { Byte Buffer buffer = Byte Buffer . wrap ( ( byte [ ] ) new Val ) ; buffer . rewind ( ) ; while ( buffer . has Remaining ( ) ) { byte [ ] value Byte = new byte [ buffer . get Int ( ) ] ; buffer . get ( value Byte ) ; Big Decimal value Big Decimal = Data Type Util . byte To Big Decimal ( value Byte ) ; agg Val = agg Val . add ( value Big Decimal ) ; count += buffer . get Double ( ) ; first Time = BOOL ; } return ; } if ( first Time ) { agg Val = ( Big Decimal ) new Val ; first Time = BOOL ; } else { agg Val = agg Val . add ( ( Big Decimal ) new Val ) ; } count ++ ; }
@ Override public void agg ( Object new Val ) { if ( new Val instanceof byte [ ] ) { Byte Buffer buffer = Byte Buffer . wrap ( ( byte [ ] ) new Val ) ; buffer . rewind ( ) ; while ( buffer . has Remaining ( ) ) { byte [ ] value Byte = new byte [ buffer . get Int ( ) ] ; buffer . get ( value Byte ) ; Big Decimal value Big Decimal = Data Type Util . byte To Big Decimal ( value Byte ) ; agg Val = agg Val . add ( value Big Decimal ) ; count += buffer . get Double ( ) ; first Time = BOOL ; } return ; } if ( first Time ) { agg Val = ( Big Decimal ) new Val ; first Time = BOOL ; } else { agg Val = agg Val . add ( ( Big Decimal ) new Val ) ; } count ++ ; }
@ Override public void agg ( Object new Val ) { if ( new Val instanceof byte [ ] ) { Byte Buffer buffer = Byte Buffer . wrap ( ( byte [ ] ) new Val ) ; buffer . rewind ( ) ; while ( buffer . has Remaining ( ) ) { byte [ ] value Byte = new byte [ buffer . get Int ( ) ] ; buffer . get ( value Byte ) ; Big Decimal value Big Decimal = Data Type Util . byte To Big Decimal ( value Byte ) ; agg Val = agg Val . add ( value Big Decimal ) ; count += buffer . get Double ( ) ; first Time = BOOL ; } return ; } if ( first Time ) { agg Val = ( Big Decimal ) new Val ; first Time = BOOL ; } else { agg Val = agg Val . add ( ( Big Decimal ) new Val ) ; } count ++ ; }
public < T > T guard ( final Callable < T > r ) throws Exception { inc Thread ( ) ; try { return r . call ( ) ; } finally { dec Thread ( ) ; } }
public < T > T guard ( final Callable < T > r ) throws Exception { inc Thread ( ) ; try { return r . call ( ) ; } finally { dec Thread ( ) ; } }
public < T > T guard ( final Callable < T > r ) throws Exception { inc Thread ( ) ; try { return r . call ( ) ; } finally { dec Thread ( ) ; } }
public void focus Gained ( Focus Event e ) { combo Box . repaint ( ) ; }
public void focus Gained ( Focus Event e ) { combo Box . repaint ( ) ; }
public void focus Gained ( Focus Event e ) { combo Box . repaint ( ) ; }
private void before Name ( ) throws IO Exception { int context = peek ( ) ; if ( context == NONEMPTY OBJECT ) { out . write ( STRING ) ; } else if ( context != EMPTY OBJECT ) { throw new Illegal State Exception ( STRING ) ; } newline ( ) ; replace Top ( DANGLING NAME ) ; }
private void before Name ( ) throws IO Exception { int context = peek ( ) ; if ( context == NONEMPTY OBJECT ) { out . write ( STRING ) ; } else if ( context != EMPTY OBJECT ) { throw new Illegal State Exception ( STRING ) ; } newline ( ) ; replace Top ( DANGLING NAME ) ; }
public static Time convert Time ( Value value , Calendar calendar ) { if ( value == Value Null . INSTANCE ) { return null ; } Value Time t = ( Value Time ) value . convert To ( Value . TIME ) ; Calendar cal = ( Calendar ) calendar . clone ( ) ; cal . clear ( ) ; cal . set Lenient ( BOOL ) ; long nanos = t . get Nanos ( ) ; long millis = nanos / NUM ; nanos -= millis * NUM ; long s = millis / NUM ; millis -= s * NUM ; long m = s / NUM ; s -= m * NUM ; long h = m / NUM ; m -= h * NUM ; set Calendar Fields ( cal , NUM , NUM , NUM , ( int ) h , ( int ) m , ( int ) s , ( int ) millis ) ; long ms = cal . get Time In Millis ( ) ; return new Time ( ms ) ; }
private Concurrent Skip List Map . Node < K , V > hi Node ( ) { if ( hi == null ) return m . find Last ( ) ; else if ( hi Inclusive ) return m . find Near ( hi , LT | EQ ) ; else return m . find Near ( hi , LT ) ; }
private Concurrent Skip List Map . Node < K , V > hi Node ( ) { if ( hi == null ) return m . find Last ( ) ; else if ( hi Inclusive ) return m . find Near ( hi , LT | EQ ) ; else return m . find Near ( hi , LT ) ; }
private Concurrent Skip List Map . Node < K , V > hi Node ( ) { if ( hi == null ) return m . find Last ( ) ; else if ( hi Inclusive ) return m . find Near ( hi , LT | EQ ) ; else return m . find Near ( hi , LT ) ; }
public void save MRU ( ) { if ( mru . changed ) { try { Object Output Stream out = new Object Output Stream ( new File Output Stream ( new File ( directory , MRUFILE ) ) ) ; out . write Object ( mru ) ; out . close ( ) ; } catch ( Exception e ) { Log . e ( STRING , STRING , e ) ; } } }
public String display Node With Instrumentation ( Node node ) { if ( node == null ) { return STRING ; } final String Builder sb = new String Builder ( ) ; sb . append ( display Node Name ( node ) ) ; sb . append ( STRING ) ; sb . append ( display Tags ( node ) ) ; if ( node . get Parent ( ) instanceof Wrapper Node ) { sb . append ( STRING ) ; } sb . append ( STRING ) ; sb . append ( display Source Info ( node ) ) ; return sb . to String ( ) ; }
public String display Node With Instrumentation ( Node node ) { if ( node == null ) { return STRING ; } final String Builder sb = new String Builder ( ) ; sb . append ( display Node Name ( node ) ) ; sb . append ( STRING ) ; sb . append ( display Tags ( node ) ) ; if ( node . get Parent ( ) instanceof Wrapper Node ) { sb . append ( STRING ) ; } sb . append ( STRING ) ; sb . append ( display Source Info ( node ) ) ; return sb . to String ( ) ; }
public String display Node With Instrumentation ( Node node ) { if ( node == null ) { return STRING ; } final String Builder sb = new String Builder ( ) ; sb . append ( display Node Name ( node ) ) ; sb . append ( STRING ) ; sb . append ( display Tags ( node ) ) ; if ( node . get Parent ( ) instanceof Wrapper Node ) { sb . append ( STRING ) ; } sb . append ( STRING ) ; sb . append ( display Source Info ( node ) ) ; return sb . to String ( ) ; }
public Multimap < String , String > load Relations ( DB Transaction transaction , String charname ) throws SQL Exception { Hash Multimap < String , String > map = Hash Multimap . create ( ) ; String query = STRING ; Map < String , Object > params = new Hash Map < String , Object > ( ) ; params . put ( STRING , charname ) ; Result Set result Set = transaction . query ( query , params ) ; while ( result Set . next ( ) ) { map . put ( result Set . get String ( NUM ) , result Set . get String ( NUM ) ) ; } return map ; }
public Multimap < String , String > load Relations ( DB Transaction transaction , String charname ) throws SQL Exception { Hash Multimap < String , String > map = Hash Multimap . create ( ) ; String query = STRING ; Map < String , Object > params = new Hash Map < String , Object > ( ) ; params . put ( STRING , charname ) ; Result Set result Set = transaction . query ( query , params ) ; while ( result Set . next ( ) ) { map . put ( result Set . get String ( NUM ) , result Set . get String ( NUM ) ) ; } return map ; }
private static String remove Sub Trailers ( String decoded Subject ) { int sub String Start = NUM ; int sub String End = decoded Subject . length ( ) ; int original Size = decoded Subject . length ( ) ; int cur Pos = original Size - NUM ; while ( BOOL ) { char c = decoded Subject . char At ( cur Pos -- ) ; if ( c == WS ) { sub String End -- ; } else { if ( sub String End > FWD PARENS . length ( ) && decoded Subject . ends With ( FWD PARENS ) ) { sub String End -= FWD PARENS . length ( ) ; } break ; } } decoded Subject = decoded Subject . substring ( sub String Start , sub String End ) ; return decoded Subject ; }
@ Suppress Warnings ( STRING ) public Iterator < Node > xpath Iterator ( String xpath ) { List < Node > nodes = XML Util . select Nodes ( document , xpath ) ; return nodes . iterator ( ) ; }
@ Suppress Warnings ( STRING ) public Iterator < Node > xpath Iterator ( String xpath ) { List < Node > nodes = XML Util . select Nodes ( document , xpath ) ; return nodes . iterator ( ) ; }
private void roll Back Vpool On Vplex Backend Volume ( Volume volume , List < Volume > volumes To Update , Db Client db Client , URI old Vpool URI ) { Volume backend Src = V Plex Util . get VPLEX Backend Volume ( volume , BOOL , db Client , BOOL ) ; if ( backend Src != null ) { log . info ( STRING , backend Src . get Id ( ) , backend Src . get Label ( ) ) ; backend Src . set Virtual Pool ( old Vpool URI ) ; log . info ( STRING , old Vpool URI ) ; volumes To Update . add ( backend Src ) ; Volume backend Ha = V Plex Util . get VPLEX Backend Volume ( volume , BOOL , db Client , BOOL ) ; if ( backend Ha != null ) { log . info ( STRING , backend Ha . get Id ( ) , backend Ha . get Label ( ) ) ; Virtual Pool old Vpool Obj = db Client . query Object ( Virtual Pool . class , old Vpool URI ) ; Virtual Pool old HA Vpool = Virtual Pool . get HAV Pool ( old Vpool Obj , db Client ) ; if ( old HA Vpool == null ) { old HA Vpool = old Vpool Obj ; } backend Ha . set Virtual Pool ( old HA Vpool . get Id ( ) ) ; log . info ( STRING , old HA Vpool . get Id ( ) ) ; volumes To Update . add ( backend Ha ) ; } } }
private void roll Back Vpool On Vplex Backend Volume ( Volume volume , List < Volume > volumes To Update , Db Client db Client , URI old Vpool URI ) { Volume backend Src = V Plex Util . get VPLEX Backend Volume ( volume , BOOL , db Client , BOOL ) ; if ( backend Src != null ) { log . info ( STRING , backend Src . get Id ( ) , backend Src . get Label ( ) ) ; backend Src . set Virtual Pool ( old Vpool URI ) ; log . info ( STRING , old Vpool URI ) ; volumes To Update . add ( backend Src ) ; Volume backend Ha = V Plex Util . get VPLEX Backend Volume ( volume , BOOL , db Client , BOOL ) ; if ( backend Ha != null ) { log . info ( STRING , backend Ha . get Id ( ) , backend Ha . get Label ( ) ) ; Virtual Pool old Vpool Obj = db Client . query Object ( Virtual Pool . class , old Vpool URI ) ; Virtual Pool old HA Vpool = Virtual Pool . get HAV Pool ( old Vpool Obj , db Client ) ; if ( old HA Vpool == null ) { old HA Vpool = old Vpool Obj ; } backend Ha . set Virtual Pool ( old HA Vpool . get Id ( ) ) ; log . info ( STRING , old HA Vpool . get Id ( ) ) ; volumes To Update . add ( backend Ha ) ; } } }
private void roll Back Vpool On Vplex Backend Volume ( Volume volume , List < Volume > volumes To Update , Db Client db Client , URI old Vpool URI ) { Volume backend Src = V Plex Util . get VPLEX Backend Volume ( volume , BOOL , db Client , BOOL ) ; if ( backend Src != null ) { log . info ( STRING , backend Src . get Id ( ) , backend Src . get Label ( ) ) ; backend Src . set Virtual Pool ( old Vpool URI ) ; log . info ( STRING , old Vpool URI ) ; volumes To Update . add ( backend Src ) ; Volume backend Ha = V Plex Util . get VPLEX Backend Volume ( volume , BOOL , db Client , BOOL ) ; if ( backend Ha != null ) { log . info ( STRING , backend Ha . get Id ( ) , backend Ha . get Label ( ) ) ; Virtual Pool old Vpool Obj = db Client . query Object ( Virtual Pool . class , old Vpool URI ) ; Virtual Pool old HA Vpool = Virtual Pool . get HAV Pool ( old Vpool Obj , db Client ) ; if ( old HA Vpool == null ) { old HA Vpool = old Vpool Obj ; } backend Ha . set Virtual Pool ( old HA Vpool . get Id ( ) ) ; log . info ( STRING , old HA Vpool . get Id ( ) ) ; volumes To Update . add ( backend Ha ) ; } } }
public Date Time Parser Bucket ( long instant Local , Chronology chrono , Locale locale , Integer pivot Year , int default Year ) { super ( ) ; chrono = Date Time Utils . get Chronology ( chrono ) ; i Millis = instant Local ; i Zone = chrono . get Zone ( ) ; i Chrono = chrono . with UTC ( ) ; i Locale = ( locale == null ? Locale . get Default ( ) : locale ) ; i Pivot Year = pivot Year ; i Default Year = default Year ; }
private void build Rev Call Graph ( ) { rev call graph = new Hash Map < Integer , Linked List < Cg Edge > > ( ) ; for ( int i = NUM ; i < n func ; ++ i ) { Cg Edge p = call graph [ i ] ; while ( p != null ) { Linked List < Cg Edge > list = rev call graph . get ( p . t ) ; if ( list == null ) { list = new Linked List < Cg Edge > ( ) ; rev call graph . put ( p . t , list ) ; } list . add ( p ) ; p = p . next ; } } }
public void mark Tokens ( int line Index , Token Handler token Handler ) { Segment seg = new Segment ( ) ; if ( line Index < NUM || line Index >= line Mgr . get Line Count ( ) ) throw new Array Index Out Of Bounds Exception ( STRING + line Mgr . get Line Count ( ) + STRING + line Index ) ; int first Invalid Line Context = line Mgr . get First Invalid Line Context ( ) ; int start ; if ( first Invalid Line Context == - NUM ) { start = line Index ; } else { start = Math . min ( first Invalid Line Context , line Index ) ; } Token Marker . Line Context old Context = null ; Token Marker . Line Context context = null ; for ( int i = start ; i <= line Index ; i ++ ) { get Line Text ( i , seg ) ; old Context = line Mgr . get Line Context ( i ) ; Token Marker . Line Context prev Context = ( ( i == NUM ) ? null : line Mgr . get Line Context ( i - NUM ) ) ; Token Handler token Handler = i == line Index ? token Handler : Dummy Token Handler . INSTANCE ; context = mark Tokens ( seg , prev Context , token Handler ) ; line Mgr . set Line Context ( i , context ) ; } int line Count = line Mgr . get Line Count ( ) ; if ( line Count - NUM == line Index ) line Mgr . set First Invalid Line Context ( - NUM ) ; else if ( old Context != context ) line Mgr . set First Invalid Line Context ( line Index + NUM ) ; else if ( first Invalid Line Context == - NUM ) ; else { line Mgr . set First Invalid Line Context ( Math . max ( first Invalid Line Context , line Index + NUM ) ) ; } }
public void add Condition ( Data Table Filter Condition condition ) { if ( condition == null ) { return ; } condition Stack . add ( condition ) ; set Selected Indices ( update Selection ( ) ) ; inform Data Table Filtered Listener ( ) ; }
private Form Body body From Map ( Map < String , String > map ) { Form Body . Builder form Body = new Form Body . Builder ( ) ; if ( map != null ) { for ( final Map . Entry < String , String > entry Set : map . entry Set ( ) ) { if ( entry Set . get Value ( ) != null ) { form Body . add ( entry Set . get Key ( ) , entry Set . get Value ( ) ) ; } } } return form Body . build ( ) ; }
private void create Press Image View ( View v , int x , int y ) { m Window Layout Params = new Window Manager . Layout Params ( ) ; m Window Layout Params . gravity = Gravity . TOP | Gravity . LEFT ; m Window Layout Params . x = x - m Point 2 Item Left + m Offset 2 Left ; m Window Layout Params . y = y - m Point 2 Item Top + m Offset 2 Top - m Status Height ; m Window Layout Params . alpha = NUM ; m Window Layout Params . width = Window Manager . Layout Params . WRAP CONTENT ; m Window Layout Params . height = Window Manager . Layout Params . WRAP CONTENT ; m Window Layout Params . flags = Window Manager . Layout Params . FLAG NOT FOCUSABLE | Window Manager . Layout Params . FLAG NOT TOUCHABLE ; m Drag Image View = new Image View ( get Context ( ) ) ; v . set Drawing Cache Enabled ( BOOL ) ; Bitmap bitmap = Bitmap . create Bitmap ( v . get Drawing Cache ( ) ) ; m Drag Image View . set Image Bitmap ( bitmap ) ; v . destroy Drawing Cache ( ) ; m Window Manager . add View ( m Drag Image View , m Window Layout Params ) ; }
private List < String > missingcloaks 2 ( final Player player , final boolean hash ) { String done Text 2 = player . get Quest ( QUEST SLOT ) ; final List < String > needed Copy 2 = new Linked List < String > ( NEEDEDCLOAKS 2 ) ; if ( done Text 2 == null ) { done Text 2 = STRING ; } final List < String > done 2 = Arrays . as List ( done Text 2 . split ( STRING ) ) ; needed Copy 2 . remove All ( done 2 ) ; if ( hash ) { final List < String > result 2 = new Linked List < String > ( ) ; for ( final String cloak : needed Copy 2 ) { result 2 . add ( STRING + cloak ) ; } return result 2 ; } return needed Copy 2 ; }
private List < String > missingcloaks 2 ( final Player player , final boolean hash ) { String done Text 2 = player . get Quest ( QUEST SLOT ) ; final List < String > needed Copy 2 = new Linked List < String > ( NEEDEDCLOAKS 2 ) ; if ( done Text 2 == null ) { done Text 2 = STRING ; } final List < String > done 2 = Arrays . as List ( done Text 2 . split ( STRING ) ) ; needed Copy 2 . remove All ( done 2 ) ; if ( hash ) { final List < String > result 2 = new Linked List < String > ( ) ; for ( final String cloak : needed Copy 2 ) { result 2 . add ( STRING + cloak ) ; } return result 2 ; } return needed Copy 2 ; }
private List < String > missingcloaks 2 ( final Player player , final boolean hash ) { String done Text 2 = player . get Quest ( QUEST SLOT ) ; final List < String > needed Copy 2 = new Linked List < String > ( NEEDEDCLOAKS 2 ) ; if ( done Text 2 == null ) { done Text 2 = STRING ; } final List < String > done 2 = Arrays . as List ( done Text 2 . split ( STRING ) ) ; needed Copy 2 . remove All ( done 2 ) ; if ( hash ) { final List < String > result 2 = new Linked List < String > ( ) ; for ( final String cloak : needed Copy 2 ) { result 2 . add ( STRING + cloak ) ; } return result 2 ; } return needed Copy 2 ; }
@ Deprecated public static List < Integer > range ( int from Incl , int to Excl ) { A . ensure ( from Incl >= NUM , STRING ) ; A . ensure ( to Excl >= NUM , STRING ) ; A . ensure ( to Excl >= from Incl , STRING ) ; if ( to Excl == from Incl ) return Collections . empty List ( ) ; List < Integer > list = new Array List < > ( to Excl - from Incl ) ; for ( int i = from Incl ; i < to Excl ; i ++ ) list . add ( i ) ; return list ; }
@ Deprecated public static List < Integer > range ( int from Incl , int to Excl ) { A . ensure ( from Incl >= NUM , STRING ) ; A . ensure ( to Excl >= NUM , STRING ) ; A . ensure ( to Excl >= from Incl , STRING ) ; if ( to Excl == from Incl ) return Collections . empty List ( ) ; List < Integer > list = new Array List < > ( to Excl - from Incl ) ; for ( int i = from Incl ; i < to Excl ; i ++ ) list . add ( i ) ; return list ; }
@ Deprecated public static List < Integer > range ( int from Incl , int to Excl ) { A . ensure ( from Incl >= NUM , STRING ) ; A . ensure ( to Excl >= NUM , STRING ) ; A . ensure ( to Excl >= from Incl , STRING ) ; if ( to Excl == from Incl ) return Collections . empty List ( ) ; List < Integer > list = new Array List < > ( to Excl - from Incl ) ; for ( int i = from Incl ; i < to Excl ; i ++ ) list . add ( i ) ; return list ; }
public static void create And Show Table Demo Frame ( ) { J Frame frame = new J Frame ( STRING + Internal Utilities . get Project Version String ( ) ) ; frame . set Default Close Operation ( J Frame . DISPOSE ON CLOSE ) ; Table Editors Demo table Demo Panel = new Table Editors Demo ( ) ; frame . set Content Pane ( table Demo Panel ) ; table Demo Panel . set Opaque ( BOOL ) ; frame . pack ( ) ; frame . set Size ( new Dimension ( NUM , NUM ) ) ; frame . set Location Relative To ( null ) ; frame . set Visible ( BOOL ) ; }
public static void create And Show Table Demo Frame ( ) { J Frame frame = new J Frame ( STRING + Internal Utilities . get Project Version String ( ) ) ; frame . set Default Close Operation ( J Frame . DISPOSE ON CLOSE ) ; Table Editors Demo table Demo Panel = new Table Editors Demo ( ) ; frame . set Content Pane ( table Demo Panel ) ; table Demo Panel . set Opaque ( BOOL ) ; frame . pack ( ) ; frame . set Size ( new Dimension ( NUM , NUM ) ) ; frame . set Location Relative To ( null ) ; frame . set Visible ( BOOL ) ; }
protected void validate Parameters ( final Row Value parameters ) throws SQL Exception { final Row Descriptor parameter Descriptor = get Parameter Descriptor ( ) ; final int expected Size = parameter Descriptor != null ? parameter Descriptor . get Count ( ) : NUM ; final int actual Size = parameters . get Count ( ) ; if ( actual Size != expected Size ) { throw new SQL Non Transient Exception ( String . format ( STRING , expected Size , actual Size ) , STRING ) ; } for ( int field Index = NUM ; field Index < actual Size ; field Index ++ ) { Field Value field Value = parameters . get Field Value ( field Index ) ; if ( field Value == null || ! field Value . is Initialized ( ) ) { throw new SQL Transient Exception ( String . format ( STRING , field Index + NUM ) , STRING ) ; } } }
protected void validate Parameters ( final Row Value parameters ) throws SQL Exception { final Row Descriptor parameter Descriptor = get Parameter Descriptor ( ) ; final int expected Size = parameter Descriptor != null ? parameter Descriptor . get Count ( ) : NUM ; final int actual Size = parameters . get Count ( ) ; if ( actual Size != expected Size ) { throw new SQL Non Transient Exception ( String . format ( STRING , expected Size , actual Size ) , STRING ) ; } for ( int field Index = NUM ; field Index < actual Size ; field Index ++ ) { Field Value field Value = parameters . get Field Value ( field Index ) ; if ( field Value == null || ! field Value . is Initialized ( ) ) { throw new SQL Transient Exception ( String . format ( STRING , field Index + NUM ) , STRING ) ; } } }
public static boolean matches Url ( final Http Servlet Request request , final String path ) { final Pattern pattern = Pattern . compile ( STRING + path + STRING , Pattern . CASE INSENSITIVE ) ; if ( request . get Request URI ( ) != null ) { final Matcher m = pattern . matcher ( request . get Request URI ( ) ) ; return m . matches ( ) ; } return BOOL ; }
public static boolean matches Url ( final Http Servlet Request request , final String path ) { final Pattern pattern = Pattern . compile ( STRING + path + STRING , Pattern . CASE INSENSITIVE ) ; if ( request . get Request URI ( ) != null ) { final Matcher m = pattern . matcher ( request . get Request URI ( ) ) ; return m . matches ( ) ; } return BOOL ; }
public String serialize ( Page Context pc , Object object , boolean serialize Query By Columns ) throws Converter Exception { String Builder sb = new String Builder ( ) ; serialize ( pc , null , object , sb , serialize Query By Columns , new Hash Set < Object > ( ) ) ; return sb . to String ( ) ; }
public Static SE Tof Ints ( int [ ] keys ) { a = new int [ keys . length ] ; for ( int i = NUM ; i < keys . length ; i ++ ) a [ i ] = keys [ i ] ; Arrays . sort ( a ) ; for ( int i = NUM ; i < a . length ; i ++ ) if ( a [ i ] == a [ i - NUM ] ) throw new Illegal Argument Exception ( STRING ) ; }
public boolean handle Long Click ( View v , float x , float y ) { synchronized ( action Mode Callback Lock ) { if ( ( current Action Mode Callback instanceof Path Creation Action Mode Callback ) ) { Log . d ( STRING , STRING ) ; return BOOL ; } } v . perform Haptic Feedback ( Haptic Feedback Constants . LONG PRESS ) ; if ( main . start Support Action Mode ( new Long Click Action Mode Callback ( x , y ) ) == null ) { main . start Support Action Mode ( new Path Creation Action Mode Callback ( x , y ) ) ; } return BOOL ; }
public boolean handle Long Click ( View v , float x , float y ) { synchronized ( action Mode Callback Lock ) { if ( ( current Action Mode Callback instanceof Path Creation Action Mode Callback ) ) { Log . d ( STRING , STRING ) ; return BOOL ; } } v . perform Haptic Feedback ( Haptic Feedback Constants . LONG PRESS ) ; if ( main . start Support Action Mode ( new Long Click Action Mode Callback ( x , y ) ) == null ) { main . start Support Action Mode ( new Path Creation Action Mode Callback ( x , y ) ) ; } return BOOL ; }
@ Override public Instances define Data Format ( ) throws Exception { Random random = new Random ( get Seed ( ) ) ; set Random ( random ) ; Instances dataset ; Array List < Attribute > attributes = new Array List < Attribute > ( NUM ) ; Attribute attribute ; boolean class Flag = get Class Flag ( ) ; Array List < String > class Values = null ; if ( class Flag ) { class Values = new Array List < String > ( m Num Clusters ) ; } for ( int i = NUM ; i < get Num Attributes ( ) ; i ++ ) { attribute = new Attribute ( STRING + i ) ; attributes . add ( attribute ) ; } if ( class Flag ) { for ( int i = NUM ; i < m Num Clusters ; i ++ ) { class Values . add ( STRING + i ) ; } attribute = new Attribute ( STRING , class Values ) ; attributes . add ( attribute ) ; } dataset = new Instances ( get Relation Name To Use ( ) , attributes , NUM ) ; if ( class Flag ) { dataset . set Class Index ( get Num Attributes ( ) ) ; } Instances format = new Instances ( dataset , NUM ) ; set Dataset Format ( format ) ; m Cluster List = define Clusters ( random ) ; return dataset ; }
private void write Csv File ( String filename , int number Of Lines After Header ) { Buffered Writer bw = IO Utils . get Buffered Writer ( filename ) ; try { for ( int i = NUM ; i < number Of Lines After Header ; i ++ ) { bw . write ( STRING ) ; bw . new Line ( ) ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; fail ( STRING + filename ) ; } finally { try { bw . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; fail ( STRING + filename ) ; } } }
private void write Csv File ( String filename , int number Of Lines After Header ) { Buffered Writer bw = IO Utils . get Buffered Writer ( filename ) ; try { for ( int i = NUM ; i < number Of Lines After Header ; i ++ ) { bw . write ( STRING ) ; bw . new Line ( ) ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; fail ( STRING + filename ) ; } finally { try { bw . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; fail ( STRING + filename ) ; } } }
private void write Csv File ( String filename , int number Of Lines After Header ) { Buffered Writer bw = IO Utils . get Buffered Writer ( filename ) ; try { for ( int i = NUM ; i < number Of Lines After Header ; i ++ ) { bw . write ( STRING ) ; bw . new Line ( ) ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; fail ( STRING + filename ) ; } finally { try { bw . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; fail ( STRING + filename ) ; } } }
private void write Csv File ( String filename , int number Of Lines After Header ) { Buffered Writer bw = IO Utils . get Buffered Writer ( filename ) ; try { for ( int i = NUM ; i < number Of Lines After Header ; i ++ ) { bw . write ( STRING ) ; bw . new Line ( ) ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; fail ( STRING + filename ) ; } finally { try { bw . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; fail ( STRING + filename ) ; } } }
private boolean map Pattern Elem Pos ( int nesting , boolean is Start , boolean is Attr Name ) { if ( NUM == nesting ) { if ( m pattern Map Size >= m pattern Map . length ) { int pattern Map [ ] = m pattern Map ; int len = m pattern Map . length ; m pattern Map = new int [ m pattern Map Size + NUM ] ; System . arraycopy ( pattern Map , NUM , m pattern Map , NUM , len ) ; } if ( ! is Start ) { m pattern Map [ m pattern Map Size - NUM ] -= TARGETEXTRA ; } m pattern Map [ m pattern Map Size ] = ( m compiler . get Token Queue Size ( ) - ( is Attr Name ? NUM : NUM ) ) + TARGETEXTRA ; m pattern Map Size ++ ; is Start = BOOL ; } return is Start ; }
default boolean is Immutable ( ) { return BOOL ; }
default boolean is Immutable ( ) { return BOOL ; }
default boolean is Immutable ( ) { return BOOL ; }
private float [ ] calculate Shift To Position B Box Of Points At ( float left , float top , List < Point > points ) { double min X = Double . MAX VALUE ; double max Y = - Double . MAX VALUE ; for ( Point point : points ) { min X = Math . min ( point . get X ( ) , min X ) ; max Y = Math . max ( point . get Y ( ) , max Y ) ; } float dx = ( float ) ( left - min X ) ; float dy = ( float ) ( top - max Y ) ; return new float [ ] { dx , dy } ; }
private float [ ] calculate Shift To Position B Box Of Points At ( float left , float top , List < Point > points ) { double min X = Double . MAX VALUE ; double max Y = - Double . MAX VALUE ; for ( Point point : points ) { min X = Math . min ( point . get X ( ) , min X ) ; max Y = Math . max ( point . get Y ( ) , max Y ) ; } float dx = ( float ) ( left - min X ) ; float dy = ( float ) ( top - max Y ) ; return new float [ ] { dx , dy } ; }
public List < Map < String , Object > > query ( String sql ) { try { return query ( stat . execute Query ( sql ) ) ; } catch ( SQL Exception e ) { throw convert ( e ) ; } }
public float [ ] evaluate ( String input File Name ) { Java RDD < String > lines = jsc . text File ( input File Name ) ; Data Frame dataset = create Data Frame ( lines . collect ( ) ) ; return evaluate ( dataset ) ; }
public float [ ] evaluate ( String input File Name ) { Java RDD < String > lines = jsc . text File ( input File Name ) ; Data Frame dataset = create Data Frame ( lines . collect ( ) ) ; return evaluate ( dataset ) ; }
public Multiway Pool Builder < K , R > expire After Write ( long duration , Time Unit unit ) { check State ( expire After Write Nanos == UNSET INT , STRING , expire After Write Nanos ) ; check Argument ( duration >= NUM , STRING , duration , unit ) ; expire After Write Nanos = unit . to Nanos ( duration ) ; return this ; }
public Multiway Pool Builder < K , R > expire After Write ( long duration , Time Unit unit ) { check State ( expire After Write Nanos == UNSET INT , STRING , expire After Write Nanos ) ; check Argument ( duration >= NUM , STRING , duration , unit ) ; expire After Write Nanos = unit . to Nanos ( duration ) ; return this ; }
public Multiway Pool Builder < K , R > expire After Write ( long duration , Time Unit unit ) { check State ( expire After Write Nanos == UNSET INT , STRING , expire After Write Nanos ) ; check Argument ( duration >= NUM , STRING , duration , unit ) ; expire After Write Nanos = unit . to Nanos ( duration ) ; return this ; }
public static Class Name generate Migration Name ( String package Name , Schema from , Schema to ) { return Class Name . get ( package Name , String . format ( Locale . US , STRING , from . get Version ( ) , to . get Version ( ) ) ) ; }
@ Override @ Suppress Forbidden ( reason = STRING ) public void activate Options ( ) { if ( follow ) { if ( target . equals ( SYSTEM ERR ) ) { set Writer ( create Writer ( new System Err Stream ( ) ) ) ; } else { set Writer ( create Writer ( new System Out Stream ( ) ) ) ; } } else { if ( target . equals ( SYSTEM ERR ) ) { set Writer ( create Writer ( System . err ) ) ; } else { set Writer ( create Writer ( System . out ) ) ; } } super . activate Options ( ) ; }
public static String find Preferred IDP ( String realm , Http Servlet Request request ) { if ( request == null ) { return null ; } String succinct ID = request . get Parameter ( IFS Constants . PROVIDER ID KEY ) ; if ( ( succinct ID == null ) || succinct ID . length ( ) == NUM ) { debug . message ( STRING ) ; return null ; } succinct ID = succinct ID . trim ( ) ; String preferred Succinct Id = null ; String Tokenizer st = new String Tokenizer ( succinct ID , STRING ) ; while ( st . has More Tokens ( ) ) { preferred Succinct Id = st . next Token ( ) ; if ( ( preferred Succinct Id . length ( ) < NUM ) && st . has More Tokens ( ) ) { preferred Succinct Id = preferred Succinct Id + STRING + st . next Token ( ) ; } } preferred Succinct Id = SAML Utils . byte Array To String ( Base 64 . decode ( preferred Succinct Id ) ) ; return get Provider ID From Succinct ID ( realm , preferred Succinct Id ) ; }
public static int find Minutes In Reminder List ( Array List < Integer > values , int minutes ) { int index = values . index Of ( minutes ) ; if ( index == - NUM ) { Log . e ( TAG , STRING + minutes + STRING ) ; return NUM ; } return index ; }
static public final float cos Deg ( float degrees ) { return Sin . table [ ( int ) ( ( degrees + NUM ) * deg To Index ) & SIN MASK ] ; }
public Object save ( Object entity ) { Object key = Property Utils . get Property Value ( entity , repository Metadata . get Identifier Property ( ) ) ; log . info ( STRING + key ) ; if ( key == null && key Generator != null ) { log . info ( STRING ) ; key = key Generator . generate ( ) ; log . debug ( STRING + key ) ; Property Utils . set Property Value ( entity , repository Metadata . get Identifier Property ( ) , key ) ; } if ( key == null ) { log . warn ( STRING ) ; } data Store . save ( ( Serializable ) key , entity ) ; return entity ; }
public Object save ( Object entity ) { Object key = Property Utils . get Property Value ( entity , repository Metadata . get Identifier Property ( ) ) ; log . info ( STRING + key ) ; if ( key == null && key Generator != null ) { log . info ( STRING ) ; key = key Generator . generate ( ) ; log . debug ( STRING + key ) ; Property Utils . set Property Value ( entity , repository Metadata . get Identifier Property ( ) , key ) ; } if ( key == null ) { log . warn ( STRING ) ; } data Store . save ( ( Serializable ) key , entity ) ; return entity ; }
public int read Golomb ( int divisor ) throws IO Exception { int q = NUM ; while ( read Bit ( MAX PROBABILITY / NUM ) ) { q ++ ; } int bit = NUM - Integer . number Of Leading Zeros ( divisor - NUM ) ; int r = NUM ; if ( bit >= NUM ) { int cut Off = ( NUM << bit ) - divisor ; for ( ; bit > NUM ; bit -- ) { r = ( r << NUM ) + ( read Bit ( MAX PROBABILITY / NUM ) ? NUM : NUM ) ; } if ( r >= cut Off ) { r = ( r << NUM ) + ( read Bit ( MAX PROBABILITY / NUM ) ? NUM : NUM ) - cut Off ; } } return q * divisor + r ; }
public void not ( ) { mv . visit Insn ( Opcodes . ICONST 1 ) ; mv . visit Insn ( Opcodes . IXOR ) ; }
protected void copy Response Entity ( Http Response proxy Response , Http Servlet Response servlet Response ) throws IO Exception { Http Entity entity = proxy Response . get Entity ( ) ; if ( entity != null ) { Output Stream servlet Output Stream = servlet Response . get Output Stream ( ) ; entity . write To ( servlet Output Stream ) ; } }
@ Suppress Warnings ( STRING ) private void relax Viterbi Rule ( Unary Rule ur , short int State 1 , short [ ] [ ] int Sub States 1 , short int State 2 , short [ ] [ ] int Sub States 2 ) { throw new Error ( STRING ) ; }
@ Suppress Warnings ( STRING ) private void relax Viterbi Rule ( Unary Rule ur , short int State 1 , short [ ] [ ] int Sub States 1 , short int State 2 , short [ ] [ ] int Sub States 2 ) { throw new Error ( STRING ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return PATH ; case NUM : return BLOCK SIZE BYTES ; case NUM : return TOTAL LBA BLOCKS ; case NUM : return TOTAL SPACE ; default : return null ; } }
private static String canonize Type String ( String str ) { String canon = str . trim ( ) ; canon = canon . replace All ( STRING , STRING ) ; canon = canon . replace All ( STRING , STRING ) ; canon = canon . replace All ( STRING , STRING ) ; canon = canon . replace All ( STRING , STRING ) ; canon = canon . replace All ( STRING , STRING ) ; canon = canon . replace All ( STRING , STRING ) ; return canon ; }
private static String canonize Type String ( String str ) { String canon = str . trim ( ) ; canon = canon . replace All ( STRING , STRING ) ; canon = canon . replace All ( STRING , STRING ) ; canon = canon . replace All ( STRING , STRING ) ; canon = canon . replace All ( STRING , STRING ) ; canon = canon . replace All ( STRING , STRING ) ; canon = canon . replace All ( STRING , STRING ) ; return canon ; }
private static String canonize Type String ( String str ) { String canon = str . trim ( ) ; canon = canon . replace All ( STRING , STRING ) ; canon = canon . replace All ( STRING , STRING ) ; canon = canon . replace All ( STRING , STRING ) ; canon = canon . replace All ( STRING , STRING ) ; canon = canon . replace All ( STRING , STRING ) ; canon = canon . replace All ( STRING , STRING ) ; return canon ; }
private static Intent create Call Activity Intent ( Context context , URL Span [ ] url Spans ) { Telephony Manager tm = ( Telephony Manager ) context . get System Service ( Context . TELEPHONY SERVICE ) ; if ( tm . get Phone Type ( ) == Telephony Manager . PHONE TYPE NONE ) { return null ; } for ( int span i = NUM ; span i < url Spans . length ; span i ++ ) { URL Span url Span = url Spans [ span i ] ; String url String = url Span . get URL ( ) ; if ( url String . starts With ( TEL PREFIX ) ) { Intent call Intent = new Intent ( Intent . ACTION DIAL , Uri . parse ( url String ) ) ; call Intent . add Flags ( Intent . FLAG ACTIVITY NEW TASK ) ; return call Intent ; } } return null ; }
private static Intent create Call Activity Intent ( Context context , URL Span [ ] url Spans ) { Telephony Manager tm = ( Telephony Manager ) context . get System Service ( Context . TELEPHONY SERVICE ) ; if ( tm . get Phone Type ( ) == Telephony Manager . PHONE TYPE NONE ) { return null ; } for ( int span i = NUM ; span i < url Spans . length ; span i ++ ) { URL Span url Span = url Spans [ span i ] ; String url String = url Span . get URL ( ) ; if ( url String . starts With ( TEL PREFIX ) ) { Intent call Intent = new Intent ( Intent . ACTION DIAL , Uri . parse ( url String ) ) ; call Intent . add Flags ( Intent . FLAG ACTIVITY NEW TASK ) ; return call Intent ; } } return null ; }
private static Intent create Call Activity Intent ( Context context , URL Span [ ] url Spans ) { Telephony Manager tm = ( Telephony Manager ) context . get System Service ( Context . TELEPHONY SERVICE ) ; if ( tm . get Phone Type ( ) == Telephony Manager . PHONE TYPE NONE ) { return null ; } for ( int span i = NUM ; span i < url Spans . length ; span i ++ ) { URL Span url Span = url Spans [ span i ] ; String url String = url Span . get URL ( ) ; if ( url String . starts With ( TEL PREFIX ) ) { Intent call Intent = new Intent ( Intent . ACTION DIAL , Uri . parse ( url String ) ) ; call Intent . add Flags ( Intent . FLAG ACTIVITY NEW TASK ) ; return call Intent ; } } return null ; }
private Array List < Individuum > initial Population ( int popsize ) { Array List < Individuum > population = new Array List < > ( popsize ) ; for ( int i = NUM ; i < popsize ; i ++ ) { short [ ] gene = new short [ dim ] ; Arrays . fill ( gene , DONT CARE ) ; int count Dim = k ; while ( count Dim > NUM ) { int z = random . next Int ( dim ) ; if ( gene [ z ] != DONT CARE ) { continue ; } gene [ z ] = ( short ) ( random . next Int ( phi ) + GENE OFFSET ) ; count Dim -- ; } population . add ( make Individuum ( gene ) ) ; } return population ; }
private void handle Incoming Message ( Serial Message incoming Message ) { logger . debug ( incoming Message . to String ( ) ) ; try { switch ( incoming Message . get Message Type ( ) ) { case Request : handle Incoming Request Message ( incoming Message ) ; break ; case Response : handle Incoming Response Message ( incoming Message ) ; break ; default : logger . warn ( STRING , incoming Message . get Message Type ( ) ) ; } } catch ( Z Wave Serial Message Exception e ) { logger . error ( STRING , e . get Message ( ) ) ; } }
private void handle Incoming Message ( Serial Message incoming Message ) { logger . debug ( incoming Message . to String ( ) ) ; try { switch ( incoming Message . get Message Type ( ) ) { case Request : handle Incoming Request Message ( incoming Message ) ; break ; case Response : handle Incoming Response Message ( incoming Message ) ; break ; default : logger . warn ( STRING , incoming Message . get Message Type ( ) ) ; } } catch ( Z Wave Serial Message Exception e ) { logger . error ( STRING , e . get Message ( ) ) ; } }
private void handle Incoming Message ( Serial Message incoming Message ) { logger . debug ( incoming Message . to String ( ) ) ; try { switch ( incoming Message . get Message Type ( ) ) { case Request : handle Incoming Request Message ( incoming Message ) ; break ; case Response : handle Incoming Response Message ( incoming Message ) ; break ; default : logger . warn ( STRING , incoming Message . get Message Type ( ) ) ; } } catch ( Z Wave Serial Message Exception e ) { logger . error ( STRING , e . get Message ( ) ) ; } }
protected void default Sort ( Comparator < ? super T > comparator ) { Collections . sort ( this , comparator ) ; }
@ Override public int [ ] unrank ( ) { if ( k == NUM ) return new int [ NUM ] ; int [ ] combi = new int [ k ] ; long rank = count - NUM - current Index ; long e = ( n - k ) * count / n ; int t = n - k + NUM ; int m = k ; int p = n - NUM ; do { if ( e <= rank ) { combi [ k - m ] = n - t - m + NUM ; if ( e > NUM ) { rank = rank - e ; e = m * e / p ; } m -- ; p -- ; } else { e = ( p - m ) * e / p ; t -- ; p -- ; } } while ( m > NUM ) ; return combi ; }
@ Override public int [ ] unrank ( ) { if ( k == NUM ) return new int [ NUM ] ; int [ ] combi = new int [ k ] ; long rank = count - NUM - current Index ; long e = ( n - k ) * count / n ; int t = n - k + NUM ; int m = k ; int p = n - NUM ; do { if ( e <= rank ) { combi [ k - m ] = n - t - m + NUM ; if ( e > NUM ) { rank = rank - e ; e = m * e / p ; } m -- ; p -- ; } else { e = ( p - m ) * e / p ; t -- ; p -- ; } } while ( m > NUM ) ; return combi ; }
@ Override public int [ ] unrank ( ) { if ( k == NUM ) return new int [ NUM ] ; int [ ] combi = new int [ k ] ; long rank = count - NUM - current Index ; long e = ( n - k ) * count / n ; int t = n - k + NUM ; int m = k ; int p = n - NUM ; do { if ( e <= rank ) { combi [ k - m ] = n - t - m + NUM ; if ( e > NUM ) { rank = rank - e ; e = m * e / p ; } m -- ; p -- ; } else { e = ( p - m ) * e / p ; t -- ; p -- ; } } while ( m > NUM ) ; return combi ; }
public String find Match ( Pattern pattern , String text ) { return find Match ( pattern , text , NUM ) ; }
public String find Match ( Pattern pattern , String text ) { return find Match ( pattern , text , NUM ) ; }
protected Request Handle send Request ( Default Http Client client , Http Context http Context , Http Uri Request uri Request , String content Type , Response Handler Interface response Handler , Context context ) { if ( content Type != null ) { uri Request . set Header ( STRING , content Type ) ; } response Handler . set Request Headers ( uri Request . get All Headers ( ) ) ; response Handler . set Request URI ( uri Request . get URI ( ) ) ; Future < ? > request = thread Pool . submit ( new Async Http Request ( client , http Context , uri Request , response Handler ) ) ; if ( context != null ) { List < Weak Reference < Future < ? > > > request List = request Map . get ( context ) ; if ( request List == null ) { request List = new Linked List < Weak Reference < Future < ? > > > ( ) ; request Map . put ( context , request List ) ; } request List . add ( new Weak Reference < Future < ? > > ( request ) ) ; } return new Request Handle ( request ) ; }
public final void open Fallback Input Stream ( ) throws Data Fallback Exception { if ( input Buf == null ) { if ( LOG . is Debug Enabled ( ) ) LOG . debug ( STRING + data File . get Name ( ) + STRING ) ; try { set Input ( new Buffered Reader ( new File Reader ( data File ) ) ) ; } catch ( IO Exception e ) { throw new Data Fallback Exception ( e . get Message ( ) ) ; } } }
void push Back ( ) throws IO Exception { iis . seek ( iis . get Stream Position ( ) - buf Avail ) ; buf Avail = NUM ; buf Ptr = NUM ; }
protected void draw Point ( Graphics 2 D g , Plotter Point point , Color Provider color Provider , int mid X , int mid Y , double radius ) { int x = mid X ; int y = mid Y ; x += ( int ) ( point . get X ( ) * radius * scale ) ; y -= ( int ) ( point . get Y ( ) * radius * scale ) ; Color point Color = Color . red ; if ( color Column != - NUM ) { point Color = color Provider . get Point Color ( point . get Color ( ) ) ; } draw Point ( g , x , y , point Color , point . get Border Color ( ) ) ; }
public static void clear ( String throttling Point Name ) { set Throttling Point Rates ( throttling Point Name , Collections . EMPTY MAP ) ; }
public static void clear ( String throttling Point Name ) { set Throttling Point Rates ( throttling Point Name , Collections . EMPTY MAP ) ; }
@ Override protected void prepare Block ( ) { double [ ] frame = get Next Frame ( ) ; if ( frame == null ) return ; int frame Length = frame Provider . get Frame Length Samples ( ) ; if ( processor != null ) processor . apply Inline ( frame , NUM , frame Length ) ; if ( output Window != null ) output Window . apply Inline ( frame , NUM , frame Length ) ; if ( memory . length < frame Length ) { double [ ] old Memory = memory ; memory = new double [ frame Length ] ; System . arraycopy ( old Memory , NUM , memory , NUM , old Memory . length ) ; } for ( int i = NUM ; i < frame Length ; i ++ ) { memory [ i ] += frame [ i ] ; } }
@ Override protected void prepare Block ( ) { double [ ] frame = get Next Frame ( ) ; if ( frame == null ) return ; int frame Length = frame Provider . get Frame Length Samples ( ) ; if ( processor != null ) processor . apply Inline ( frame , NUM , frame Length ) ; if ( output Window != null ) output Window . apply Inline ( frame , NUM , frame Length ) ; if ( memory . length < frame Length ) { double [ ] old Memory = memory ; memory = new double [ frame Length ] ; System . arraycopy ( old Memory , NUM , memory , NUM , old Memory . length ) ; } for ( int i = NUM ; i < frame Length ; i ++ ) { memory [ i ] += frame [ i ] ; } }
@ Suppress Warnings ( STRING ) public < R > Simple React Stream < R > from ( final Collection < R > collection ) { return from ( collection . stream ( ) ) ; }
@ Suppress Warnings ( STRING ) public < R > Simple React Stream < R > from ( final Collection < R > collection ) { return from ( collection . stream ( ) ) ; }
@ Suppress Warnings ( STRING ) public < R > Simple React Stream < R > from ( final Collection < R > collection ) { return from ( collection . stream ( ) ) ; }
protected Region create Ack Region ( boolean mirror , boolean conflate ) throws Cache Exception { final Attributes Factory factory = new Attributes Factory ( ) ; factory . set Scope ( Scope . DISTRIBUTED ACK ) ; if ( mirror ) { factory . set Data Policy ( Data Policy . REPLICATE ) ; } if ( conflate ) { factory . set Enable Async Conflation ( BOOL ) ; } final Region r = create Root Region ( STRING , factory . create ( ) ) ; return r ; }
@ Override public Query new Prefix Query ( String text ) { if ( settings . lowercase Expanded Terms ( ) ) { text = text . to Lower Case ( settings . locale ( ) ) ; } Boolean Query . Builder bq = new Boolean Query . Builder ( ) ; bq . set Disable Coord ( BOOL ) ; for ( Map . Entry < String , Float > entry : weights . entry Set ( ) ) { try { if ( settings . analyze Wildcard ( ) ) { Query analyzed Query = new Possibly Analyzed Query ( entry . get Key ( ) , text ) ; analyzed Query . set Boost ( entry . get Value ( ) ) ; bq . add ( analyzed Query , Boolean Clause . Occur . SHOULD ) ; } else { Prefix Query prefix = new Prefix Query ( new Term ( entry . get Key ( ) , text ) ) ; prefix . set Boost ( entry . get Value ( ) ) ; bq . add ( prefix , Boolean Clause . Occur . SHOULD ) ; } } catch ( Runtime Exception e ) { return rethrow Unless Lenient ( e ) ; } } return super . simplify ( bq . build ( ) ) ; }
@ Override public Query new Prefix Query ( String text ) { if ( settings . lowercase Expanded Terms ( ) ) { text = text . to Lower Case ( settings . locale ( ) ) ; } Boolean Query . Builder bq = new Boolean Query . Builder ( ) ; bq . set Disable Coord ( BOOL ) ; for ( Map . Entry < String , Float > entry : weights . entry Set ( ) ) { try { if ( settings . analyze Wildcard ( ) ) { Query analyzed Query = new Possibly Analyzed Query ( entry . get Key ( ) , text ) ; analyzed Query . set Boost ( entry . get Value ( ) ) ; bq . add ( analyzed Query , Boolean Clause . Occur . SHOULD ) ; } else { Prefix Query prefix = new Prefix Query ( new Term ( entry . get Key ( ) , text ) ) ; prefix . set Boost ( entry . get Value ( ) ) ; bq . add ( prefix , Boolean Clause . Occur . SHOULD ) ; } } catch ( Runtime Exception e ) { return rethrow Unless Lenient ( e ) ; } } return super . simplify ( bq . build ( ) ) ; }
public static void check Duplicated Value ( List < Executable Element > elements , Class clazz ) { Set < String > values = new Hash Set < > ( ) ; for ( Executable Element method : elements ) { List < String > value = get Value From Annotation ( method , clazz ) ; if ( ! values . add All ( value ) ) { throw new Duplicated Value Exception ( value , method , clazz ) ; } } }
public static void check Duplicated Value ( List < Executable Element > elements , Class clazz ) { Set < String > values = new Hash Set < > ( ) ; for ( Executable Element method : elements ) { List < String > value = get Value From Annotation ( method , clazz ) ; if ( ! values . add All ( value ) ) { throw new Duplicated Value Exception ( value , method , clazz ) ; } } }
public static void check Duplicated Value ( List < Executable Element > elements , Class clazz ) { Set < String > values = new Hash Set < > ( ) ; for ( Executable Element method : elements ) { List < String > value = get Value From Annotation ( method , clazz ) ; if ( ! values . add All ( value ) ) { throw new Duplicated Value Exception ( value , method , clazz ) ; } } }
public static Calendar next ( Calendar self ) { Calendar result = ( Calendar ) self . clone ( ) ; result . add ( Calendar . DAY OF YEAR , NUM ) ; return result ; }
public void init ( String component Name ) throws Log Exception { access Logger = ( com . sun . identity . log . Logger ) Logger . get Logger ( component Name + STRING ) ; error Logger = ( com . sun . identity . log . Logger ) Logger . get Logger ( component Name + STRING ) ; try { msg Provider = Message Provider Factory . get Provider ( component Name ) ; } catch ( IO Exception e ) { debug . error ( STRING , e ) ; } }
public void read Data ( Data Input din ) throws IO Exception { int length = get Data Length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { din . read Byte ( ) ; } }
public void read Data ( Data Input din ) throws IO Exception { int length = get Data Length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { din . read Byte ( ) ; } }
public static Command create Append Text If Absent To File Command ( Path path To File , String text To Append , String check If Text Present Regex ) { return create Command ( get Append Text To File Command ( path To File , text To Append , check If Text Present Regex , BOOL ) ) ; }
public static Command create Append Text If Absent To File Command ( Path path To File , String text To Append , String check If Text Present Regex ) { return create Command ( get Append Text To File Command ( path To File , text To Append , check If Text Present Regex , BOOL ) ) ; }
@ Override public void store ( Data Output os ) throws IO Exception { super . store ( os ) ; }
public Uma Pending Request read Pending Request ( String id ) throws Resource Exception { try { return store . read ( id ) ; } catch ( Not Found Exception e ) { throw new org . forgerock . json . resource . Not Found Exception ( STRING + id + STRING , e ) ; } catch ( Server Exception e ) { throw new Internal Server Error Exception ( STRING + id , e ) ; } }
private void load Events ( ) throws XML Stream Exception { if ( ! xml Event Reader . has Next ( ) ) { done = BOOL ; return ; } XML Event event = xml Event Reader . next Event ( ) ; event = event Transformer . transform ( event ) ; xml Write Stream . reset ( ) ; xml Event Writer . add ( event ) ; xml Event Writer . flush ( ) ; xml In Stream = new Byte Array Input Stream ( xml Write Stream . to Byte Array ( ) ) ; }
void generate ( Xml Writer w ) throws IO Exception { List < Xml Writer . Attribute > attrs = null ; if ( count > NUM ) { attrs = Collections . singleton List ( new Xml Writer . Attribute ( STRING , Integer . to String ( count ) ) ) ; } w . simple Element ( Google Base Namespaces . GM , STRING , attrs , value ) ; }
@ Fluent public < T > Job on ( String event , Handler < Message < T > > handler ) { logger . debug ( STRING + Kue . get Certain Job Address ( event , this ) ) ; event Bus . consumer ( Kue . get Certain Job Address ( event , this ) , handler ) ; return this ; }
@ Fluent public < T > Job on ( String event , Handler < Message < T > > handler ) { logger . debug ( STRING + Kue . get Certain Job Address ( event , this ) ) ; event Bus . consumer ( Kue . get Certain Job Address ( event , this ) , handler ) ; return this ; }
protected Size Requirements calculate Major Axis Requirements ( int axis , Size Requirements r ) { Size Requirements req = super . calculate Major Axis Requirements ( axis , r ) ; req . maximum = Integer . MAX VALUE ; return req ; }
protected Size Requirements calculate Major Axis Requirements ( int axis , Size Requirements r ) { Size Requirements req = super . calculate Major Axis Requirements ( axis , r ) ; req . maximum = Integer . MAX VALUE ; return req ; }
protected Size Requirements calculate Major Axis Requirements ( int axis , Size Requirements r ) { Size Requirements req = super . calculate Major Axis Requirements ( axis , r ) ; req . maximum = Integer . MAX VALUE ; return req ; }
protected Size Requirements calculate Major Axis Requirements ( int axis , Size Requirements r ) { Size Requirements req = super . calculate Major Axis Requirements ( axis , r ) ; req . maximum = Integer . MAX VALUE ; return req ; }
protected Size Requirements calculate Major Axis Requirements ( int axis , Size Requirements r ) { Size Requirements req = super . calculate Major Axis Requirements ( axis , r ) ; req . maximum = Integer . MAX VALUE ; return req ; }
protected Size Requirements calculate Major Axis Requirements ( int axis , Size Requirements r ) { Size Requirements req = super . calculate Major Axis Requirements ( axis , r ) ; req . maximum = Integer . MAX VALUE ; return req ; }
protected Size Requirements calculate Major Axis Requirements ( int axis , Size Requirements r ) { Size Requirements req = super . calculate Major Axis Requirements ( axis , r ) ; req . maximum = Integer . MAX VALUE ; return req ; }
protected Size Requirements calculate Major Axis Requirements ( int axis , Size Requirements r ) { Size Requirements req = super . calculate Major Axis Requirements ( axis , r ) ; req . maximum = Integer . MAX VALUE ; return req ; }
protected Size Requirements calculate Major Axis Requirements ( int axis , Size Requirements r ) { Size Requirements req = super . calculate Major Axis Requirements ( axis , r ) ; req . maximum = Integer . MAX VALUE ; return req ; }
protected Size Requirements calculate Major Axis Requirements ( int axis , Size Requirements r ) { Size Requirements req = super . calculate Major Axis Requirements ( axis , r ) ; req . maximum = Integer . MAX VALUE ; return req ; }
protected Size Requirements calculate Major Axis Requirements ( int axis , Size Requirements r ) { Size Requirements req = super . calculate Major Axis Requirements ( axis , r ) ; req . maximum = Integer . MAX VALUE ; return req ; }
public Commitment commit ( byte [ ] message ) { if ( message . length > byte Length / NUM ) { throw new Data Length Exception ( STRING ) ; } byte [ ] w = new byte [ byte Length - message . length ] ; random . next Bytes ( w ) ; return new Commitment ( w , calculate Commitment ( w , message ) ) ; }
@ Override public Variable Set initializeforward LV ( Variable Set active In ) throws Language Exception { for ( Statement s : statements ) { s . initializeforward LV ( active In ) ; Variable Set read = s . variables Read ( ) ; Variable Set updated = s . variables Updated ( ) ; if ( s instanceof While Statement || s instanceof If Statement || s instanceof For Statement ) { raise Validate Error ( STRING , BOOL ) ; } if ( read != null ) { for ( String var : read . get Variable Names ( ) ) { if ( ! updated . contains Variable ( var ) ) { gen . add Variable ( var , read . get Variable ( var ) ) ; } } } read . add Variables ( read ) ; updated . add Variables ( updated ) ; if ( updated != null ) { for ( String var : updated . get Variable Names ( ) ) { kill . add Variable ( var , updated . get Variable ( var ) ) ; } } } live Out = new Variable Set ( ) ; live Out . add Variables ( active In ) ; live Out . add Variables ( updated ) ; return live Out ; }
@ Override public Variable Set initializeforward LV ( Variable Set active In ) throws Language Exception { for ( Statement s : statements ) { s . initializeforward LV ( active In ) ; Variable Set read = s . variables Read ( ) ; Variable Set updated = s . variables Updated ( ) ; if ( s instanceof While Statement || s instanceof If Statement || s instanceof For Statement ) { raise Validate Error ( STRING , BOOL ) ; } if ( read != null ) { for ( String var : read . get Variable Names ( ) ) { if ( ! updated . contains Variable ( var ) ) { gen . add Variable ( var , read . get Variable ( var ) ) ; } } } read . add Variables ( read ) ; updated . add Variables ( updated ) ; if ( updated != null ) { for ( String var : updated . get Variable Names ( ) ) { kill . add Variable ( var , updated . get Variable ( var ) ) ; } } } live Out = new Variable Set ( ) ; live Out . add Variables ( active In ) ; live Out . add Variables ( updated ) ; return live Out ; }
@ Override public Variable Set initializeforward LV ( Variable Set active In ) throws Language Exception { for ( Statement s : statements ) { s . initializeforward LV ( active In ) ; Variable Set read = s . variables Read ( ) ; Variable Set updated = s . variables Updated ( ) ; if ( s instanceof While Statement || s instanceof If Statement || s instanceof For Statement ) { raise Validate Error ( STRING , BOOL ) ; } if ( read != null ) { for ( String var : read . get Variable Names ( ) ) { if ( ! updated . contains Variable ( var ) ) { gen . add Variable ( var , read . get Variable ( var ) ) ; } } } read . add Variables ( read ) ; updated . add Variables ( updated ) ; if ( updated != null ) { for ( String var : updated . get Variable Names ( ) ) { kill . add Variable ( var , updated . get Variable ( var ) ) ; } } } live Out = new Variable Set ( ) ; live Out . add Variables ( active In ) ; live Out . add Variables ( updated ) ; return live Out ; }
@ Override public Variable Set initializeforward LV ( Variable Set active In ) throws Language Exception { for ( Statement s : statements ) { s . initializeforward LV ( active In ) ; Variable Set read = s . variables Read ( ) ; Variable Set updated = s . variables Updated ( ) ; if ( s instanceof While Statement || s instanceof If Statement || s instanceof For Statement ) { raise Validate Error ( STRING , BOOL ) ; } if ( read != null ) { for ( String var : read . get Variable Names ( ) ) { if ( ! updated . contains Variable ( var ) ) { gen . add Variable ( var , read . get Variable ( var ) ) ; } } } read . add Variables ( read ) ; updated . add Variables ( updated ) ; if ( updated != null ) { for ( String var : updated . get Variable Names ( ) ) { kill . add Variable ( var , updated . get Variable ( var ) ) ; } } } live Out = new Variable Set ( ) ; live Out . add Variables ( active In ) ; live Out . add Variables ( updated ) ; return live Out ; }
public String int Value To String Value ( Integer int Val ) { if ( int Val == null ) return null ; final String enum String = enum Int To String Map . get ( int Val ) ; if ( enum String != null ) return enum String ; return DEFAULT VALUE . to String ( ) ; }
public void add To TDA ( String file ) { tda Panel . add Dump File ( file ) ; }
public void remove Temporary Maps ( Bit Field object Ids ) { for ( String map Name : store . get Map Names ( ) ) { if ( map Name . starts With ( STRING ) ) { MV Map < ? , ? > map = store . open Map ( map Name ) ; store . remove Map ( map ) ; } else if ( map Name . starts With ( STRING ) || map Name . starts With ( STRING ) ) { int id = Integer . parse Int ( map Name . substring ( NUM + map Name . index Of ( STRING ) ) ) ; if ( ! object Ids . get ( id ) ) { Value Data Type key Type = new Value Data Type ( null , null , null ) ; Value Data Type value Type = new Value Data Type ( null , null , null ) ; Transaction t = transaction Store . begin ( ) ; Transaction Map < ? , ? > m = t . open Map ( map Name , key Type , value Type ) ; transaction Store . remove Map ( m ) ; t . commit ( ) ; } } } }
public void reset ( ) throws IO Exception { m structure = null ; m Buffer = null ; set Retrieval ( NONE ) ; if ( m File != null ) { set File ( new File ( m File ) ) ; } else if ( ( m URL != null ) && ! m URL . equals ( STRING ) ) { set URL ( m URL ) ; } }
public static long pop array ( long [ ] arr , int word Offset , int num Words ) { long pop Count = NUM ; for ( int i = word Offset , end = word Offset + num Words ; i < end ; ++ i ) { pop Count += Long . bit Count ( arr [ i ] ) ; } return pop Count ; }
@ Override public String to String ( ) { String Buffer buff = new String Buffer ( ) ; if ( m correlations == null ) { buff . append ( STRING ) ; } else { buff . append ( STRING ) ; if ( m detailed Output && m detailed Output Buff . length ( ) > NUM ) { buff . append ( STRING ) ; buff . append ( m detailed Output Buff ) ; } } return buff . to String ( ) ; }
public static void un Register Client App ( Context context ) throws App Catalog Exception { String server IP = Preference . get String ( context , Constants . Preference Flag . IP ) ; if ( server IP != null && ! server IP . is Empty ( ) ) { String application Name = Preference . get String ( context , Constants . CLIENT NAME ) ; String consumer Key = Preference . get String ( context , Constants . CLIENT ID ) ; String user Id = Preference . get String ( context , Constants . USERNAME ) ; if ( application Name != null && ! application Name . is Empty ( ) && consumer Key != null && ! consumer Key . is Empty ( ) && user Id != null && ! user Id . is Empty ( ) ) { Unregister Profile profile = new Unregister Profile ( ) ; profile . set Application Name ( application Name ) ; profile . set Consumer Key ( consumer Key ) ; profile . set User Id ( user Id ) ; Server Config utils = new Server Config ( ) ; utils . set Server IP ( server IP ) ; Dynamic Client Manager dynamic Client Manager = new Dynamic Client Manager ( ) ; boolean is Unregistered = dynamic Client Manager . unregister Client ( profile , utils , context ) ; if ( ! is Unregistered ) { Log . e ( TAG , STRING ) ; } } else { Log . e ( TAG , STRING ) ; } } else { Log . e ( TAG , STRING ) ; } }
public String quote String ( String str ) { String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; if ( String Utils . is Not Blank ( str ) ) { sb . append ( escape Quotes ( str ) ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
public String quote String ( String str ) { String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; if ( String Utils . is Not Blank ( str ) ) { sb . append ( escape Quotes ( str ) ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
public static boolean is Native Code Loaded ( ) { return Native Code Loader . is Native Code Loaded ( ) ; }
public void audit Access Denied ( String resource , String action , String authz Module , SSO Token token ) { init ( ) ; if ( authz Logger != null && msg Provider != null ) { final Log Record record = msg Provider . create Log Record ( STRING , new String [ ] { STRING + resource , action , authz Module } , token ) ; if ( record != null ) { authz Logger . log ( record , Access Controller . do Privileged ( Admin Token Action . get Instance ( ) ) ) ; } } }
public void audit Access Denied ( String resource , String action , String authz Module , SSO Token token ) { init ( ) ; if ( authz Logger != null && msg Provider != null ) { final Log Record record = msg Provider . create Log Record ( STRING , new String [ ] { STRING + resource , action , authz Module } , token ) ; if ( record != null ) { authz Logger . log ( record , Access Controller . do Privileged ( Admin Token Action . get Instance ( ) ) ) ; } } }
public Module Handle add Module ( String module Name , String session Key ) { String sanitized Module Name = generate Unique Name If Null Or Empty ( module Name , STRING ) ; Module Handle module Handle = new Module Handle ( sanitized Module Name , session Key ) ; synchronized ( private Instance Lock ) { modules . add ( module Handle ) ; } set Terminated ( BOOL ) ; return module Handle ; }
private boolean select ID ( int node ID , boolean show ) { if ( m root == null ) return BOOL ; log . config ( STRING + node ID + STRING + show + STRING + m root ) ; M Tree Node node = m root . find Node ( node ID ) ; if ( node != null ) { Tree Path tree Path = new Tree Path ( node . get Path ( ) ) ; log . config ( STRING + node + STRING + tree Path . to String ( ) ) ; tree . set Selection Path ( tree Path ) ; if ( show ) { tree . make Visible ( tree Path ) ; tree . scroll Path To Visible ( tree Path ) ; } return BOOL ; } log . info ( STRING + node ID ) ; return BOOL ; }
private boolean select ID ( int node ID , boolean show ) { if ( m root == null ) return BOOL ; log . config ( STRING + node ID + STRING + show + STRING + m root ) ; M Tree Node node = m root . find Node ( node ID ) ; if ( node != null ) { Tree Path tree Path = new Tree Path ( node . get Path ( ) ) ; log . config ( STRING + node + STRING + tree Path . to String ( ) ) ; tree . set Selection Path ( tree Path ) ; if ( show ) { tree . make Visible ( tree Path ) ; tree . scroll Path To Visible ( tree Path ) ; } return BOOL ; } log . info ( STRING + node ID ) ; return BOOL ; }
private boolean select ID ( int node ID , boolean show ) { if ( m root == null ) return BOOL ; log . config ( STRING + node ID + STRING + show + STRING + m root ) ; M Tree Node node = m root . find Node ( node ID ) ; if ( node != null ) { Tree Path tree Path = new Tree Path ( node . get Path ( ) ) ; log . config ( STRING + node + STRING + tree Path . to String ( ) ) ; tree . set Selection Path ( tree Path ) ; if ( show ) { tree . make Visible ( tree Path ) ; tree . scroll Path To Visible ( tree Path ) ; } return BOOL ; } log . info ( STRING + node ID ) ; return BOOL ; }
private Node < K , V > find Predecessor ( Comparable < ? super K > key ) { if ( key == null ) throw new Null Pointer Exception ( ) ; for ( ; ; ) { Index < K , V > q = head ; Index < K , V > r = q . right ; for ( ; ; ) { if ( r != null ) { Node < K , V > n = r . node ; K k = n . key ; if ( n . value == null ) { if ( ! q . unlink ( r ) ) break ; r = q . right ; continue ; } if ( key . compare To ( k ) > NUM ) { q = r ; r = r . right ; continue ; } } Index < K , V > d = q . down ; if ( d != null ) { q = d ; r = d . right ; } else return q . node ; } } }
private Node < K , V > find Predecessor ( Comparable < ? super K > key ) { if ( key == null ) throw new Null Pointer Exception ( ) ; for ( ; ; ) { Index < K , V > q = head ; Index < K , V > r = q . right ; for ( ; ; ) { if ( r != null ) { Node < K , V > n = r . node ; K k = n . key ; if ( n . value == null ) { if ( ! q . unlink ( r ) ) break ; r = q . right ; continue ; } if ( key . compare To ( k ) > NUM ) { q = r ; r = r . right ; continue ; } } Index < K , V > d = q . down ; if ( d != null ) { q = d ; r = d . right ; } else return q . node ; } } }
public static String format Time ( long time ) { Simple Date Format sdf = new Simple Date Format ( STRING ) ; Calendar c = Calendar . get Instance ( ) ; c . set Time In Millis ( time * NUM ) ; return sdf . format ( c . get Time ( ) ) ; }
public void update Access Time ( ) { attributes . set Last Accessed Time ( System . current Time Millis ( ) ) ; }
public void update Access Time ( ) { attributes . set Last Accessed Time ( System . current Time Millis ( ) ) ; }
public boolean no Version Received From Server ( ) { return version Tag == null && region . concurrency Checks Enabled && region . get Server Proxy ( ) != null && ! op . is Local ( ) && ! is Origin Remote ( ) ; }
public void add Engineer ( String engineer Name ) { if ( engineer Name . length ( ) <= NUM ) { return ; } engineers . add ( engineer Name ) ; engineers Table . refresh ( BOOL ) ; migration Task . add Engineers ( engineer Name ) ; }
public void add Engineer ( String engineer Name ) { if ( engineer Name . length ( ) <= NUM ) { return ; } engineers . add ( engineer Name ) ; engineers Table . refresh ( BOOL ) ; migration Task . add Engineers ( engineer Name ) ; }
public void add Engineer ( String engineer Name ) { if ( engineer Name . length ( ) <= NUM ) { return ; } engineers . add ( engineer Name ) ; engineers Table . refresh ( BOOL ) ; migration Task . add Engineers ( engineer Name ) ; }
@ Override public long free Memory ( long window Id ) throws IO Exception { long size = key Stream . data Size Up To Window ( window Id ) + value Stream . data Size Up To Window ( window Id ) ; windows For Free Memory . add ( window Id ) ; return size ; }
@ Override public long free Memory ( long window Id ) throws IO Exception { long size = key Stream . data Size Up To Window ( window Id ) + value Stream . data Size Up To Window ( window Id ) ; windows For Free Memory . add ( window Id ) ; return size ; }
public void close ( ) throws IO Exception { raf . close ( ) ; }
@ Not Null default B append ( @ Not Null Char Sequence cs ) throws Buffer Overflow Exception { return append ( cs , NUM , cs . length ( ) ) ; }
public static Binding as Binding ( final Query Solution map ) { if ( map != null ) { Binding Hash Map result = new Binding Hash Map ( ) ; Iterator < String > var Names = map . var Names ( ) ; while ( var Names . has Next ( ) ) { String var Name = var Names . next ( ) ; RDF Node node = map . get ( var Name ) ; if ( node != null ) { result . add ( Var . alloc ( var Name ) , node . as Node ( ) ) ; } } return result ; } else { return null ; } }
public List < File > generated Files ( ) { return Collections . unmodifiable List ( generated Files ) ; }
public static void allow Item For Recycling ( Object stack ) { recycling Allowed . add ( Api Utils . convert To Valid Recipe Input ( stack ) ) ; }
public static void allow Item For Recycling ( Object stack ) { recycling Allowed . add ( Api Utils . convert To Valid Recipe Input ( stack ) ) ; }
private void reset Blocklet Processing Count ( ) { blocklet Processing Count . set ( NUM ) ; }
public String to String ( ) { String Buffer buf = new String Buffer ( NODE + STRING + get Feature ( ) + STRING + OPERAND MATCHES ) ; buf . append ( get Value String ( ) + STRING ) ; buf . append ( Integer . to String ( qtrue ) + STRING ) ; buf . append ( Integer . to String ( qfalse ) ) ; return buf . to String ( ) ; }
void load Items Into Slots ( final Player player ) { final String [ ] slots Items = { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; try { for ( final String slot Name : slots Items ) { if ( ! player . has Slot ( slot Name ) ) { continue ; } final RP Slot slot = player . get Slot ( slot Name ) ; final Player Slot new Slot ; if ( slot Name . equals ( STRING ) ) { new Slot = new Player Keyring Slot ( slot Name ) ; } else if ( slot Name . equals ( STRING ) ) { new Slot = new Player Trade Slot ( slot Name ) ; } else { new Slot = new Player Slot ( slot Name ) ; } load Slot Content ( player , slot , new Slot ) ; } for ( final Banks bank : Banks . values ( ) ) { final RP Slot slot = player . get Slot ( bank . get Slot Name ( ) ) ; final Player Slot new Slot = new Bank Slot ( bank ) ; load Slot Content ( player , slot , new Slot ) ; } } catch ( final Runtime Exception e ) { logger . error ( STRING , e ) ; } }
public LZMA Input Stream ( Input Stream in , int memory Limit ) throws IO Exception { Data Input Stream in Data = new Data Input Stream ( in ) ; byte props Byte = in Data . read Byte ( ) ; int dict Size = NUM ; for ( int i = NUM ; i < NUM ; ++ i ) dict Size |= in Data . read Unsigned Byte ( ) << ( NUM * i ) ; long uncomp Size = NUM ; for ( int i = NUM ; i < NUM ; ++ i ) uncomp Size |= ( long ) in Data . read Unsigned Byte ( ) << ( NUM * i ) ; int memory Needed = get Memory Usage ( dict Size , props Byte ) ; if ( memory Limit != - NUM && memory Needed > memory Limit ) throw new Memory Limit Exception ( memory Needed , memory Limit ) ; initialize ( in , uncomp Size , props Byte , dict Size , null ) ; }
public static Pair < int [ ] , double [ ] > convert ( Set < Feature > features , Lexicon lexicon , boolean training Mode ) { T Int Double Hash Map f Map = new T Int Double Hash Map ( features . size ( ) ) ; for ( Feature feature : features ) { final int feature Id = Feature Utilities . get Feature Id ( lexicon , training Mode , feature ) ; if ( feature Id < NUM ) continue ; double value = feature . get Value ( ) + f Map . get ( feature Id ) ; f Map . put ( feature Id , value ) ; } int [ ] ids Original = f Map . keys ( ) ; int [ ] ids = new int [ ids Original . length ] ; System . arraycopy ( ids Original , NUM , ids , NUM , ids . length ) ; Arrays . sort ( ids ) ; double [ ] vals = new double [ f Map . size ( ) ] ; int count = NUM ; for ( int key : ids ) { vals [ count ++ ] = f Map . get ( key ) ; } return new Pair < > ( ids , vals ) ; }
public static Pair < int [ ] , double [ ] > convert ( Set < Feature > features , Lexicon lexicon , boolean training Mode ) { T Int Double Hash Map f Map = new T Int Double Hash Map ( features . size ( ) ) ; for ( Feature feature : features ) { final int feature Id = Feature Utilities . get Feature Id ( lexicon , training Mode , feature ) ; if ( feature Id < NUM ) continue ; double value = feature . get Value ( ) + f Map . get ( feature Id ) ; f Map . put ( feature Id , value ) ; } int [ ] ids Original = f Map . keys ( ) ; int [ ] ids = new int [ ids Original . length ] ; System . arraycopy ( ids Original , NUM , ids , NUM , ids . length ) ; Arrays . sort ( ids ) ; double [ ] vals = new double [ f Map . size ( ) ] ; int count = NUM ; for ( int key : ids ) { vals [ count ++ ] = f Map . get ( key ) ; } return new Pair < > ( ids , vals ) ; }
public static Pair < int [ ] , double [ ] > convert ( Set < Feature > features , Lexicon lexicon , boolean training Mode ) { T Int Double Hash Map f Map = new T Int Double Hash Map ( features . size ( ) ) ; for ( Feature feature : features ) { final int feature Id = Feature Utilities . get Feature Id ( lexicon , training Mode , feature ) ; if ( feature Id < NUM ) continue ; double value = feature . get Value ( ) + f Map . get ( feature Id ) ; f Map . put ( feature Id , value ) ; } int [ ] ids Original = f Map . keys ( ) ; int [ ] ids = new int [ ids Original . length ] ; System . arraycopy ( ids Original , NUM , ids , NUM , ids . length ) ; Arrays . sort ( ids ) ; double [ ] vals = new double [ f Map . size ( ) ] ; int count = NUM ; for ( int key : ids ) { vals [ count ++ ] = f Map . get ( key ) ; } return new Pair < > ( ids , vals ) ; }
public int parse ( String argv [ ] ) throws IO Exception , Help Requested Exception { return parse ( argv , BOOL ) ; }
public int parse ( String argv [ ] ) throws IO Exception , Help Requested Exception { return parse ( argv , BOOL ) ; }
public Z21 Message ( byte [ ] a , int l ) { super ( String . value Of ( a ) ) ; set Binary ( BOOL ) ; }
public Z21 Message ( byte [ ] a , int l ) { super ( String . value Of ( a ) ) ; set Binary ( BOOL ) ; }
public boolean matches ( Function function , String id ) { return m Function == function && mID != null && id != null && id . matches ( mID . replace ( STRING , STRING ) ) ; }
public boolean matches ( Function function , String id ) { return m Function == function && mID != null && id != null && id . matches ( mID . replace ( STRING , STRING ) ) ; }
public void insert Bitmap ( final Buffered Image bitmap , final int x , final int y , final int xx , final int yy , final Filter Mode filter ) { insert Bitmap ( bitmap , x , y , bitmap . get RGB ( xx , yy ) , filter ) ; }
public void insert Bitmap ( final Buffered Image bitmap , final int x , final int y , final int xx , final int yy , final Filter Mode filter ) { insert Bitmap ( bitmap , x , y , bitmap . get RGB ( xx , yy ) , filter ) ; }
public void insert Bitmap ( final Buffered Image bitmap , final int x , final int y , final int xx , final int yy , final Filter Mode filter ) { insert Bitmap ( bitmap , x , y , bitmap . get RGB ( xx , yy ) , filter ) ; }
public void insert Bitmap ( final Buffered Image bitmap , final int x , final int y , final int xx , final int yy , final Filter Mode filter ) { insert Bitmap ( bitmap , x , y , bitmap . get RGB ( xx , yy ) , filter ) ; }
public void create Connection ( Network Interface another Interface ) { if ( ! is Connected ( another Interface ) && ( this != another Interface ) ) { Connection con = new VBR Connection ( this . host , this , another Interface . get Host ( ) , another Interface ) ; connect ( con , another Interface ) ; } }
public void create Connection ( Network Interface another Interface ) { if ( ! is Connected ( another Interface ) && ( this != another Interface ) ) { Connection con = new VBR Connection ( this . host , this , another Interface . get Host ( ) , another Interface ) ; connect ( con , another Interface ) ; } }
public void create Connection ( Network Interface another Interface ) { if ( ! is Connected ( another Interface ) && ( this != another Interface ) ) { Connection con = new VBR Connection ( this . host , this , another Interface . get Host ( ) , another Interface ) ; connect ( con , another Interface ) ; } }
protected E Object create Initial Model ( ) { E Class e Class = ( E Class ) eip Package . get E Classifier ( initial Object Creation Page . get Initial Object Name ( ) ) ; E Object root Object = eip Factory . create ( e Class ) ; return root Object ; }
public void remove Drag Event Handlers ( ) { node . remove Event Handler ( Touch Event . ANY , touch Handler ) ; node . remove Event Handler ( Mouse Event . ANY , mouse Handler ) ; }
@ Ui Thread public void collapse Parent ( int parent Position ) { collapse Parent ( m Parent List . get ( parent Position ) ) ; }
@ Ui Thread public void collapse Parent ( int parent Position ) { collapse Parent ( m Parent List . get ( parent Position ) ) ; }
public void add Listener ( Connectable Device Listener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }
public void add Listener ( Connectable Device Listener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }
public void add Listener ( Connectable Device Listener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }
public void add Listener ( Connectable Device Listener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }
public Ids Query ( Class < T > type , Object [ ] ids , Object routing , Query Result Type query Result Type ) { this ( type . get Name ( ) , ids , routing , null , query Result Type ) ; }
public Ids Query ( Class < T > type , Object [ ] ids , Object routing , Query Result Type query Result Type ) { this ( type . get Name ( ) , ids , routing , null , query Result Type ) ; }
public Ids Query ( Class < T > type , Object [ ] ids , Object routing , Query Result Type query Result Type ) { this ( type . get Name ( ) , ids , routing , null , query Result Type ) ; }
@ Override public void reset References ( ) { refs . clear ( ) ; }
public @ Non Null Charge Request . Builder auto Return ( long timeout , Time Unit unit ) { long auto Return Millis ; if ( timeout != Register Api . AUTO RETURN NO TIMEOUT ) { auto Return Millis = unit . to Millis ( timeout ) ; non Null ( unit , STRING ) ; if ( auto Return Millis < Register Api . AUTO RETURN TIMEOUT MIN MILLIS ) { throw new Illegal Argument Exception ( STRING + Register Api . AUTO RETURN TIMEOUT MIN MILLIS ) ; } if ( auto Return Millis > Register Api . AUTO RETURN TIMEOUT MAX MILLIS ) { throw new Illegal Argument Exception ( STRING + Register Api . AUTO RETURN TIMEOUT MAX MILLIS ) ; } } else { auto Return Millis = Register Api . AUTO RETURN NO TIMEOUT ; } this . auto Return Millis = auto Return Millis ; return this ; }
protected void install Keyboard Actions ( mx Graph Component graph Component ) { Input Map input Map = get Input Map ( J Component . WHEN ANCESTOR OF FOCUSED COMPONENT ) ; Swing Utilities . replace UI Input Map ( graph Component , J Component . WHEN ANCESTOR OF FOCUSED COMPONENT , input Map ) ; input Map = get Input Map ( J Component . WHEN FOCUSED ) ; Swing Utilities . replace UI Input Map ( graph Component , J Component . WHEN FOCUSED , input Map ) ; Swing Utilities . replace UI Action Map ( graph Component , create Action Map ( ) ) ; }
private void register End ( final String prefix Singular , final String prefix Plural , final String end String ) { prefix End List . add ( new Prefix Entry ( end String , prefix Singular , prefix Plural ) ) ; register Prefix ( prefix Singular , prefix Plural ) ; }
private void register End ( final String prefix Singular , final String prefix Plural , final String end String ) { prefix End List . add ( new Prefix Entry ( end String , prefix Singular , prefix Plural ) ) ; register Prefix ( prefix Singular , prefix Plural ) ; }
public void remove ( Individual individual ) { individuals . remove ( individual ) ; }
@ Suppress Warnings ( STRING ) private static String parse Gwt Rpc Method Name ( Input Stream stream , String char Encoding ) { try { final Scanner scanner ; if ( char Encoding == null ) { scanner = new Scanner ( stream ) ; } else { scanner = new Scanner ( stream , char Encoding ) ; } scanner . use Delimiter ( GWT RPC SEPARATOR CHAR PATTERN ) ; scanner . next ( ) ; scanner . next ( ) ; scanner . next ( ) ; scanner . next ( ) ; scanner . next ( ) ; scanner . next ( ) ; return STRING + scanner . next ( ) ; } catch ( final No Such Element Exception e ) { LOG . debug ( STRING , e ) ; return null ; } }
private void change Announcement ( Player active Player , String announcement ) { if ( legion Restrictions . can Change Announcement ( active Player . get Legion Member ( ) , announcement ) ) { Legion legion = active Player . get Legion ( ) ; Timestamp current Time = new Timestamp ( System . current Time Millis ( ) ) ; store New Announcement ( legion . get Legion Id ( ) , current Time , announcement ) ; legion . add Announcement To List ( current Time , announcement ) ; Packet Send Utility . send Packet ( active Player , SM SYSTEM MESSAGE . STR GUILD WRITE NOTICE DONE ) ; Packet Send Utility . broadcast Packet To Legion ( legion , new SM LEGION EDIT ( NUM , ( int ) ( System . current Time Millis ( ) / NUM ) , announcement ) ) ; } }
private void change Announcement ( Player active Player , String announcement ) { if ( legion Restrictions . can Change Announcement ( active Player . get Legion Member ( ) , announcement ) ) { Legion legion = active Player . get Legion ( ) ; Timestamp current Time = new Timestamp ( System . current Time Millis ( ) ) ; store New Announcement ( legion . get Legion Id ( ) , current Time , announcement ) ; legion . add Announcement To List ( current Time , announcement ) ; Packet Send Utility . send Packet ( active Player , SM SYSTEM MESSAGE . STR GUILD WRITE NOTICE DONE ) ; Packet Send Utility . broadcast Packet To Legion ( legion , new SM LEGION EDIT ( NUM , ( int ) ( System . current Time Millis ( ) / NUM ) , announcement ) ) ; } }
private void change Announcement ( Player active Player , String announcement ) { if ( legion Restrictions . can Change Announcement ( active Player . get Legion Member ( ) , announcement ) ) { Legion legion = active Player . get Legion ( ) ; Timestamp current Time = new Timestamp ( System . current Time Millis ( ) ) ; store New Announcement ( legion . get Legion Id ( ) , current Time , announcement ) ; legion . add Announcement To List ( current Time , announcement ) ; Packet Send Utility . send Packet ( active Player , SM SYSTEM MESSAGE . STR GUILD WRITE NOTICE DONE ) ; Packet Send Utility . broadcast Packet To Legion ( legion , new SM LEGION EDIT ( NUM , ( int ) ( System . current Time Millis ( ) / NUM ) , announcement ) ) ; } }
private void change Announcement ( Player active Player , String announcement ) { if ( legion Restrictions . can Change Announcement ( active Player . get Legion Member ( ) , announcement ) ) { Legion legion = active Player . get Legion ( ) ; Timestamp current Time = new Timestamp ( System . current Time Millis ( ) ) ; store New Announcement ( legion . get Legion Id ( ) , current Time , announcement ) ; legion . add Announcement To List ( current Time , announcement ) ; Packet Send Utility . send Packet ( active Player , SM SYSTEM MESSAGE . STR GUILD WRITE NOTICE DONE ) ; Packet Send Utility . broadcast Packet To Legion ( legion , new SM LEGION EDIT ( NUM , ( int ) ( System . current Time Millis ( ) / NUM ) , announcement ) ) ; } }
public void create WS Fed Provider ( String realm , String entity Id , Map values ) throws AM Console Exception { try { List < String > meta Aliases = get Federation Alias ( values , Meta Template Parameters . P WS FED ALIASES ) ; Set < String > duplicate Check = new Hash Set < String > ( meta Aliases ) ; if ( duplicate Check . size ( ) < meta Aliases . size ( ) ) { throw new AM Console Exception ( get Localized String ( STRING ) ) ; } WS Federation Meta Manager meta Manager = new WS Federation Meta Manager ( ) ; meta Manager . validate Meta Alias For New Entity ( realm , meta Aliases ) ; String metadata = Create WS Fed Meta Data Template . create Standard Meta Template ( entity Id , values , request URL ) ; String extended Data = Create WS Fed Meta Data Template . create Extended Meta Template ( entity Id , values ) ; Federation Element elt = ( Federation Element ) WS Federation Meta Utils . convert String To JAXB ( metadata ) ; String federation ID = elt . get Federation ID ( ) ; if ( federation ID == null ) { federation ID = WS Federation Constants . DEFAULT FEDERATION ID ; } meta Manager . create Federation ( realm , elt ) ; Federation Config Element cfg = ( Federation Config Element ) WS Federation Meta Utils . convert String To JAXB ( extended Data ) ; meta Manager . create Entity Config ( realm , cfg ) ; } catch ( WS Federation Meta Exception ex ) { throw new AM Console Exception ( ex . get Message ( ) ) ; } catch ( JAXB Exception ex ) { throw new AM Console Exception ( ex . get Message ( ) ) ; } catch ( Certificate Encoding Exception ex ) { throw new AM Console Exception ( ex . get Message ( ) ) ; } }
private int parse Current Number ( Byte Buf buffer ) { int number = NUM ; int reader Index = buffer . reader Index ( ) ; byte b = NUM ; while ( BOOL ) { if ( ! buffer . is Readable ( ) ) return Integer . MIN VALUE ; b = buffer . read Byte ( ) ; if ( Character . is Digit ( b ) ) { number = number * NUM + ( int ) ( b - STRING ) ; reader Index ++ ; } else { buffer . reader Index ( reader Index ) ; break ; } } return number ; }
private String pop And Encode As Js ( ) { synchronized ( this ) { int length = queue . size ( ) ; if ( length == NUM ) { return null ; } int total Payload Len = NUM ; int num Messages To Send = NUM ; for ( Js Message message : queue ) { int message Size = message . calculate Encoded Length ( ) + NUM ; if ( num Messages To Send > NUM && total Payload Len + message Size > MAX PAYLOAD SIZE && MAX PAYLOAD SIZE > NUM ) { break ; } total Payload Len += message Size ; num Messages To Send += NUM ; } boolean will Send All Messages = num Messages To Send == queue . size ( ) ; String Builder sb = new String Builder ( total Payload Len + ( will Send All Messages ? NUM : NUM ) ) ; for ( int i = NUM ; i < num Messages To Send ; ++ i ) { Js Message message = queue . remove First ( ) ; if ( will Send All Messages && ( i + NUM == num Messages To Send ) ) { message . encode As Js Message ( sb ) ; } else { sb . append ( STRING ) ; message . encode As Js Message ( sb ) ; sb . append ( STRING ) ; } } if ( ! will Send All Messages ) { sb . append ( STRING ) ; } for ( int i = will Send All Messages ? NUM : NUM ; i < num Messages To Send ; ++ i ) { sb . append ( STRING ) ; } String ret = sb . to String ( ) ; return ret ; } }
public Enumeration < String > enumerate Measures ( ) { Vector < String > result = new Vector < String > ( ) ; result . add Element ( STRING ) ; result . add Element ( STRING ) ; return result . elements ( ) ; }
public Enumeration < String > enumerate Measures ( ) { Vector < String > result = new Vector < String > ( ) ; result . add Element ( STRING ) ; result . add Element ( STRING ) ; return result . elements ( ) ; }
private void add To Search Criteria Parameter Map ( String key , String value ) { if ( search Criteria Parameter Map . contains Key ( key ) ) { Array List < String > array List = search Criteria Parameter Map . get ( key ) ; array List . add ( value ) ; search Criteria Parameter Map . put ( key , array List ) ; } else { Array List < String > array List = new Array List < > ( ) ; array List . add ( value ) ; search Criteria Parameter Map . put ( key , array List ) ; } }
private boolean exposed ( int modifiers ) { return NUM != ( modifiers & ( Modifier . PUBLIC | Modifier . PROTECTED ) ) ; }
private boolean exposed ( int modifiers ) { return NUM != ( modifiers & ( Modifier . PUBLIC | Modifier . PROTECTED ) ) ; }
static double compute Final Sum ( double [ ] summands ) { double tmp = summands [ NUM ] + summands [ NUM ] ; double simple Sum = summands [ summands . length - NUM ] ; if ( Double . is Na N ( tmp ) && Double . is Infinite ( simple Sum ) ) { return simple Sum ; } else { return tmp ; } }
static double compute Final Sum ( double [ ] summands ) { double tmp = summands [ NUM ] + summands [ NUM ] ; double simple Sum = summands [ summands . length - NUM ] ; if ( Double . is Na N ( tmp ) && Double . is Infinite ( simple Sum ) ) { return simple Sum ; } else { return tmp ; } }
static double compute Final Sum ( double [ ] summands ) { double tmp = summands [ NUM ] + summands [ NUM ] ; double simple Sum = summands [ summands . length - NUM ] ; if ( Double . is Na N ( tmp ) && Double . is Infinite ( simple Sum ) ) { return simple Sum ; } else { return tmp ; } }
static double compute Final Sum ( double [ ] summands ) { double tmp = summands [ NUM ] + summands [ NUM ] ; double simple Sum = summands [ summands . length - NUM ] ; if ( Double . is Na N ( tmp ) && Double . is Infinite ( simple Sum ) ) { return simple Sum ; } else { return tmp ; } }
private boolean check If Volume Size Exceeding Pool Size ( CIM Argument [ ] in Args , CIM Argument [ ] out Args ) { if ( get Volume Size ( in Args ) > get Volume Size ( out Args ) ) { return BOOL ; } return BOOL ; }
private boolean check If Volume Size Exceeding Pool Size ( CIM Argument [ ] in Args , CIM Argument [ ] out Args ) { if ( get Volume Size ( in Args ) > get Volume Size ( out Args ) ) { return BOOL ; } return BOOL ; }
public int size ( ) { return cache . size ( ) ; }
private int delete All Contacts ( Iterator < String > contacts Iter ) { int total Contacts Deleted = NUM ; while ( contacts Iter . has Next ( ) ) total Contacts Deleted += delete Contact ( contacts Iter . next ( ) ) ; return total Contacts Deleted ; }
private void update Title ( int selected ) { if ( m Action Mode != null ) { if ( m Title Provider != null ) m Action Mode . set Title ( m Title Provider . get Title ( selected ) ) ; else m Action Mode . set Title ( String . value Of ( selected ) ) ; } }
private void update Title ( int selected ) { if ( m Action Mode != null ) { if ( m Title Provider != null ) m Action Mode . set Title ( m Title Provider . get Title ( selected ) ) ; else m Action Mode . set Title ( String . value Of ( selected ) ) ; } }
public float indexer Score ( String url , Nutch Document doc , Web Page row , float init Score ) { return ( float ) Math . pow ( row . get Score ( ) , score Power ) * init Score ; }
public abstract void on Pin Set ( String pin ) ;
public abstract void on Pin Set ( String pin ) ;
public Label ( String tag ) { id = tag . intern ( ) ; opc = opc label ; operand = null ; }
public Label ( String tag ) { id = tag . intern ( ) ; opc = opc label ; operand = null ; }
private void log ( I Status status ) { Resources Plugin . log ( status ) ; }
private void log ( I Status status ) { Resources Plugin . log ( status ) ; }
protected List < Decompounded Word > make Split ( String a Word ) { List < Decompounded Word > result = new Array List < Decompounded Word > ( ) ; for ( int i = NUM ; i < a Word . length ( ) ; i ++ ) { String left Word = a Word . substring ( NUM , i + NUM ) ; String right Word = a Word . substring ( i + NUM ) ; boolean left Good = dict . contains ( left Word ) && left Word . length ( ) >= min Word Length ; boolean right Good = right Word . length ( ) > min Rest Length || right Word . length ( ) == NUM ; if ( left Good && right Good ) { Decompounded Word split = Decompounded Word . create From String ( left Word + STRING + right Word ) ; split . set Split Pos ( i ) ; result . add ( split ) ; } for ( String morpheme : morphemes . get All ( ) ) { try { String left Without Morpheme = left Word . substring ( NUM , left Word . length ( ) - morpheme . length ( ) ) ; if ( left Word . ends With ( morpheme ) && dict . contains ( left Without Morpheme ) && right Good ) { Decompounded Word split = Decompounded Word . create From String ( left Without Morpheme + STRING + morpheme + STRING + right Word ) ; split . set Split Pos ( i ) ; result . add ( split ) ; } } catch ( String Index Out Of Bounds Exception e ) { continue ; } } } return result ; }
public void add ( Individual individual ) { individuals . add ( individual ) ; }
public static void sort ( Object [ ] array , int start , int end ) { Comparable Tim Sort . sort ( array , start , end ) ; }
private void run ( ) { try { Thread current = Thread . current Thread ( ) ; char [ ] buf = new char [ NUM ] ; for ( int len = in . read ( buf ) ; len != - NUM ; len = in . read ( buf ) ) { append ( buf , NUM , len ) ; if ( current != thread ) { break ; } } } catch ( IO Exception e ) { logger . error ( e . get Message ( ) , e ) ; } trace ( STRING ) ; }
private static Boolean is Valid IPV 4 ( final String ip Address ) { boolean status = BOOL ; if ( String Utils . is Not Empty ( ip Address ) ) { status = Inet Address Utils . is I Pv 4 Address ( ip Address ) ; } return status ; }
private static Boolean is Valid IPV 4 ( final String ip Address ) { boolean status = BOOL ; if ( String Utils . is Not Empty ( ip Address ) ) { status = Inet Address Utils . is I Pv 4 Address ( ip Address ) ; } return status ; }
public void read Data ( Data Input din ) throws IO Exception { status = din . read Byte ( ) & NUM ; }
static private < S > long write SP Os ( final Abstract Triple Store database , final Abstract Triple Store statement Store , final SPO [ ] stmts , final int num Stmts , final I Written SPO Array callback ) { final I Chunked Ordered Iterator < ISPO > itr = new Chunked Array Iterator < ISPO > ( num Stmts , stmts , null ) ; final Abstract Triple Store sink = statement Store != null ? statement Store : database ; if ( log . is Info Enabled ( ) ) { log . info ( STRING + num Stmts + STRING + ( statement Store != null ? STRING : STRING ) ) ; if ( DEBUG ) { for ( int i = NUM ; i < num Stmts ; i ++ ) { log . debug ( STRING + stmts [ i ] ) ; } } } final long nwritten = database . add Statements ( sink , BOOL , itr , null ) ; if ( callback != null ) { callback . did Write SP Os ( stmts , num Stmts ) ; } return nwritten ; }
public int last ( ) { return prev ( arguments != null ? arguments . size ( ) : NUM ) ; }
public Multi Map Impl ( int max Capacity ) { max Capacity = max Capacity ; int size = NUM ; keys = ( K [ ] ) new Object [ size ] ; values = ( List < V > [ ] ) new List [ size ] ; size = NUM ; }
public List < Instruction > reduce Instructions ( final List < Instruction > instructions ) { lock . lock ( ) ; try { this . instructions = instructions ; stack Size Simulator . build Stack Sizes ( instructions ) ; return reduce Instructions Internal ( instructions ) ; } finally { lock . unlock ( ) ; } }
public void action Performed ( Action Event e ) { boolean ok ; int ret Val ; if ( ! check Modified ( ) ) return ; ret Val = m File Chooser . show Open Dialog ( File Scripting Panel . this ) ; if ( ret Val != J File Chooser . APPROVE OPTION ) return ; ok = m Script . open ( m File Chooser . get Selected File ( ) ) ; m Text Code . set Caret Position ( NUM ) ; if ( ! ok ) J Option Pane . show Message Dialog ( File Scripting Panel . this , STRING + m File Chooser . get Selected File ( ) + STRING ) ; notify Title Updated Listeners ( new Title Updated Event ( File Scripting Panel . this ) ) ; }
public Arbitrary Length Path Node ( final Term Node left , final Term Node right , final Var Node t Var Left , final Var Node t Var Right , final long lower Bound , final long upper Bound ) { this ( new B Op [ ] { new Join Group Node ( ) } , NV . as Map ( new NV ( Annotations . LEFT TERM , left ) , new NV ( Annotations . RIGHT TERM , right ) , new NV ( Annotations . TRANSITIVITY VAR LEFT , t Var Left ) , new NV ( Annotations . TRANSITIVITY VAR RIGHT , t Var Right ) , new NV ( Annotations . DROP VARS , new Array List < Var Node > ( ) ) , new NV ( Annotations . LOWER BOUND , lower Bound ) , new NV ( Annotations . UPPER BOUND , upper Bound ) ) ) ; final Set < Var Node > drop Vars = new Linked Hash Set < > ( ) ; drop Vars . add ( t Var Left ) ; drop Vars . add ( t Var Right ) ; set Property ( Annotations . DROP VARS , drop Vars ) ; }
protected final void add Worker ( Worker Thread worker ) { synchronized ( workers ) { workers . add ( worker ) ; } }
protected final void add Worker ( Worker Thread worker ) { synchronized ( workers ) { workers . add ( worker ) ; } }
protected void update Combo Boxes Load Change ( ) { if ( auto Track Check Box . is Selected ( ) ) { update Location Track Combo Box ( ) ; } if ( auto Destination Track Check Box . is Selected ( ) ) { update Destination Track Combo Box ( ) ; } if ( auto Final Dest Track Check Box . is Selected ( ) ) { update Final Destination ( ) ; } }
protected void update Combo Boxes Load Change ( ) { if ( auto Track Check Box . is Selected ( ) ) { update Location Track Combo Box ( ) ; } if ( auto Destination Track Check Box . is Selected ( ) ) { update Destination Track Combo Box ( ) ; } if ( auto Final Dest Track Check Box . is Selected ( ) ) { update Final Destination ( ) ; } }
protected void update Combo Boxes Load Change ( ) { if ( auto Track Check Box . is Selected ( ) ) { update Location Track Combo Box ( ) ; } if ( auto Destination Track Check Box . is Selected ( ) ) { update Destination Track Combo Box ( ) ; } if ( auto Final Dest Track Check Box . is Selected ( ) ) { update Final Destination ( ) ; } }
private void update Column Maps ( int column Index ) { delete Column Index From Maps ( column Index ) ; add Column To Columns Maps ( column Index , column Meta Data . get ( column Index ) ) ; }
private void update Column Maps ( int column Index ) { delete Column Index From Maps ( column Index ) ; add Column To Columns Maps ( column Index , column Meta Data . get ( column Index ) ) ; }
public Polling Scan Disk Space Monitor ( Set < Path > watch Paths , long polling Interval Millis ) { this . watch Paths = Collections . unmodifiable Set ( new Hash Set < > ( watch Paths ) ) ; this . polling Interval Millis = polling Interval Millis ; }
public Polling Scan Disk Space Monitor ( Set < Path > watch Paths , long polling Interval Millis ) { this . watch Paths = Collections . unmodifiable Set ( new Hash Set < > ( watch Paths ) ) ; this . polling Interval Millis = polling Interval Millis ; }
public Polling Scan Disk Space Monitor ( Set < Path > watch Paths , long polling Interval Millis ) { this . watch Paths = Collections . unmodifiable Set ( new Hash Set < > ( watch Paths ) ) ; this . polling Interval Millis = polling Interval Millis ; }
public int next Int ( ) { return next ( NUM ) ; }
public int next Int ( ) { return next ( NUM ) ; }
public int next Int ( ) { return next ( NUM ) ; }
public int next Int ( ) { return next ( NUM ) ; }
public int next Int ( ) { return next ( NUM ) ; }
public int next Int ( ) { return next ( NUM ) ; }
protected void record Selected ( int key ) { return ; }
protected void record Selected ( int key ) { return ; }
protected abstract void perform Extra Setup On Deployable ( Object webapp ) throws Exception ;
protected abstract void perform Extra Setup On Deployable ( Object webapp ) throws Exception ;
protected abstract void perform Extra Setup On Deployable ( Object webapp ) throws Exception ;
public Connection next ( String method ) throws IO Exception { for ( Connection pooled ; ( pooled = pool . get ( address ) ) != null ; ) { if ( method . equals ( STRING ) || pooled . is Readable ( ) ) return pooled ; pooled . close ( ) ; } if ( ! has Next Tls Mode ( ) ) { if ( ! has Next Inet Socket Address ( ) ) { if ( ! has Next Proxy ( ) ) { if ( ! has Next Postponed ( ) ) { throw new No Such Element Exception ( ) ; } return new Connection ( next Postponed ( ) ) ; } last Proxy = next Proxy ( ) ; reset Next Inet Socket Address ( last Proxy ) ; } last Inet Socket Address = next Inet Socket Address ( ) ; reset Next Tls Mode ( ) ; } boolean modern Tls = next Tls Mode ( ) == TLS MODE MODERN ; Route route = new Route ( address , last Proxy , last Inet Socket Address , modern Tls ) ; if ( route Database . should Postpone ( route ) ) { postponed Routes . add ( route ) ; return next ( method ) ; } return new Connection ( route ) ; }
@ Override public void write External ( Object Output out ) throws IO Exception { super . write External ( out ) ; out . write Int ( DBID Util . as Integer ( routing Object ID ) ) ; out . write Double ( parent Distance ) ; out . write Double ( covering Radius ) ; }
public Transformer Exception ( Throwable e ) { super ( e . to String ( ) ) ; this . contained Exception = e ; this . locator = null ; }
public Transformer Exception ( Throwable e ) { super ( e . to String ( ) ) ; this . contained Exception = e ; this . locator = null ; }
public Transformer Exception ( Throwable e ) { super ( e . to String ( ) ) ; this . contained Exception = e ; this . locator = null ; }
public void delete ( SSO Token token , String obj Name ) throws SMS Exception , SSO Exception { if ( ( obj Name == null ) || ( obj Name . length ( ) == NUM ) ) { throw new Illegal Argument Exception ( STRING ) ; } String obj Key = obj Name . to Lower Case ( ) ; String filepath = null ; mRW Lock . read Request ( ) ; try { filepath = m Name Map . get Property ( obj Key ) ; if ( ( filepath == null ) && m Debug . message Enabled ( ) ) { m Debug . message ( STRING + obj Name + STRING ) ; } } finally { mRW Lock . read Done ( ) ; } if ( filepath != null ) { mRW Lock . write Request ( ) ; try { filepath = m Name Map . get Property ( obj Key ) ; if ( filepath == null ) { if ( m Debug . message Enabled ( ) ) { m Debug . message ( STRING + obj Name + STRING ) ; } } else { File filehandle = new File ( filepath ) ; File parent Dir = filehandle . get Parent File ( ) ; delete Dir ( parent Dir ) ; obj Name = obj Name . to Lower Case ( ) ; Enumeration keys Enum = m Name Map . keys ( ) ; while ( keys Enum . has More Elements ( ) ) { String key = ( String ) keys Enum . next Element ( ) ; if ( key . ends With ( obj Name ) ) { m Name Map . remove ( key ) ; } } save Properties ( m Name Map , m Name Map Handle , null ) ; } } finally { mRW Lock . write Done ( ) ; } } }
public void add ( Attr attr ) { if ( attr == null ) return ; Attr attr 1 = find Attribute ( attr . get Name ( ) ) ; if ( attr 1 == null ) { attrs . add ( attr ) ; } else { attr 1 . add Values ( attr . get String Values ( ) ) ; } }
public void test Merge One Filter Into Document With Multiple Filters ( ) throws Exception { String src Xml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml src Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( src Xml . get Bytes ( STRING ) ) , null ) ; String merge Xml = STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml merge Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( merge Xml . get Bytes ( STRING ) ) , null ) ; Web Xml Merger merger = new Web Xml Merger ( src Web Xml ) ; merger . merge Filters ( merge Web Xml ) ; List < String > filter Names = Web Xml Utils . get Filter Names ( src Web Xml ) ; assert Equals ( NUM , filter Names . size ( ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; }
public void test Merge One Filter Into Document With Multiple Filters ( ) throws Exception { String src Xml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml src Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( src Xml . get Bytes ( STRING ) ) , null ) ; String merge Xml = STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml merge Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( merge Xml . get Bytes ( STRING ) ) , null ) ; Web Xml Merger merger = new Web Xml Merger ( src Web Xml ) ; merger . merge Filters ( merge Web Xml ) ; List < String > filter Names = Web Xml Utils . get Filter Names ( src Web Xml ) ; assert Equals ( NUM , filter Names . size ( ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; }
public void test Merge One Filter Into Document With Multiple Filters ( ) throws Exception { String src Xml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml src Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( src Xml . get Bytes ( STRING ) ) , null ) ; String merge Xml = STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml merge Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( merge Xml . get Bytes ( STRING ) ) , null ) ; Web Xml Merger merger = new Web Xml Merger ( src Web Xml ) ; merger . merge Filters ( merge Web Xml ) ; List < String > filter Names = Web Xml Utils . get Filter Names ( src Web Xml ) ; assert Equals ( NUM , filter Names . size ( ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; }
public void test Merge One Filter Into Document With Multiple Filters ( ) throws Exception { String src Xml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml src Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( src Xml . get Bytes ( STRING ) ) , null ) ; String merge Xml = STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml merge Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( merge Xml . get Bytes ( STRING ) ) , null ) ; Web Xml Merger merger = new Web Xml Merger ( src Web Xml ) ; merger . merge Filters ( merge Web Xml ) ; List < String > filter Names = Web Xml Utils . get Filter Names ( src Web Xml ) ; assert Equals ( NUM , filter Names . size ( ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; }
void record Access ( Hash Entry < K , V > header , Eviction Policy eviction Policy ) { wait For Modify Permition ( header ) ; remove ( ) ; add Before ( ( Hash Entry < K , V > ) eviction Policy . record Access ( header , this ) ) ; access Count ++ ; last Accessed Time = System . current Time Millis ( ) ; grand Modify And Clone All Permition ( header ) ; }
void record Access ( Hash Entry < K , V > header , Eviction Policy eviction Policy ) { wait For Modify Permition ( header ) ; remove ( ) ; add Before ( ( Hash Entry < K , V > ) eviction Policy . record Access ( header , this ) ) ; access Count ++ ; last Accessed Time = System . current Time Millis ( ) ; grand Modify And Clone All Permition ( header ) ; }
private int reconcile Put Permits ( ) { put Permits += take Side Put Permits ; take Side Put Permits = NUM ; return put Permits ; }
private Collection Processing Engine build CPE ( ) throws Baleen Exception { if ( collection Reader == null ) { throw new Baleen Exception ( STRING ) ; } Map < String , Analysis Engine Description > analysis Engines = new Linked Hash Map < > ( ) ; analysis Engines . put All ( annotators ) ; analysis Engines . put All ( consumers ) ; if ( analysis Engines . is Empty ( ) ) { throw new Baleen Exception ( STRING ) ; } Analysis Engine Description cpe A Es = null ; try { List < String > names = new Array List < > ( ) ; names . add All ( analysis Engines . key Set ( ) ) ; List < Analysis Engine Description > engines = new Array List < > ( ) ; engines . add All ( analysis Engines . values ( ) ) ; cpe A Es = Analysis Engine Factory . create Engine Description ( engines , names , null , null , null ) ; } catch ( Resource Initialization Exception rie ) { throw new Baleen Exception ( STRING , rie ) ; } org . apache . uima . fit . cpe . Cpe Builder builder = new org . apache . uima . fit . cpe . Cpe Builder ( ) ; try { builder . set Reader ( collection Reader ) ; builder . set Analysis Engine ( cpe A Es ) ; } catch ( Exception e ) { throw new Baleen Exception ( STRING , e ) ; } try { return builder . create Cpe ( null ) ; } catch ( Exception e ) { throw new Baleen Exception ( STRING , e ) ; } }
private Collection Processing Engine build CPE ( ) throws Baleen Exception { if ( collection Reader == null ) { throw new Baleen Exception ( STRING ) ; } Map < String , Analysis Engine Description > analysis Engines = new Linked Hash Map < > ( ) ; analysis Engines . put All ( annotators ) ; analysis Engines . put All ( consumers ) ; if ( analysis Engines . is Empty ( ) ) { throw new Baleen Exception ( STRING ) ; } Analysis Engine Description cpe A Es = null ; try { List < String > names = new Array List < > ( ) ; names . add All ( analysis Engines . key Set ( ) ) ; List < Analysis Engine Description > engines = new Array List < > ( ) ; engines . add All ( analysis Engines . values ( ) ) ; cpe A Es = Analysis Engine Factory . create Engine Description ( engines , names , null , null , null ) ; } catch ( Resource Initialization Exception rie ) { throw new Baleen Exception ( STRING , rie ) ; } org . apache . uima . fit . cpe . Cpe Builder builder = new org . apache . uima . fit . cpe . Cpe Builder ( ) ; try { builder . set Reader ( collection Reader ) ; builder . set Analysis Engine ( cpe A Es ) ; } catch ( Exception e ) { throw new Baleen Exception ( STRING , e ) ; } try { return builder . create Cpe ( null ) ; } catch ( Exception e ) { throw new Baleen Exception ( STRING , e ) ; } }
public void insert ( Transaction transaction ) { LOG . debug ( STRING + transaction ) ; if ( ! transaction . is Empty ( ) ) { List < Transaction > tail = new Array List < > ( m Transactions . size ( ) + NUM ) ; m Transactions . drain To ( tail ) ; m Transactions . add ( transaction ) ; m Transactions . add All ( tail ) ; } }
public void insert ( Transaction transaction ) { LOG . debug ( STRING + transaction ) ; if ( ! transaction . is Empty ( ) ) { List < Transaction > tail = new Array List < > ( m Transactions . size ( ) + NUM ) ; m Transactions . drain To ( tail ) ; m Transactions . add ( transaction ) ; m Transactions . add All ( tail ) ; } }
public void insert ( Transaction transaction ) { LOG . debug ( STRING + transaction ) ; if ( ! transaction . is Empty ( ) ) { List < Transaction > tail = new Array List < > ( m Transactions . size ( ) + NUM ) ; m Transactions . drain To ( tail ) ; m Transactions . add ( transaction ) ; m Transactions . add All ( tail ) ; } }
public static Properties filter Properties ( Properties properties , String prefix ) { Properties ret = new Properties ( ) ; if ( properties != null && prefix != null ) { prefix = prefix . ends With ( STRING ) ? prefix : prefix + STRING ; for ( String name : properties . string Property Names ( ) ) { String new Name = remove Leading Dots ( name ) ; if ( new Name . starts With ( prefix ) ) { new Name = new Name . length ( ) > prefix . length ( ) ? new Name . substring ( prefix . length ( ) ) : STRING ; new Name = remove Leading Dots ( new Name ) ; if ( new Name . length ( ) > NUM ) { ret . set Property ( new Name , properties . get Property ( name ) ) ; } } } } return ret ; }
private void read Glyph Names ( int base ) { if ( base == NUM ) { glyphnames = new int [ NUM ] ; for ( int i = NUM ; i < glyphnames . length ; i ++ ) { glyphnames [ i ] = i ; } return ; } else if ( base == NUM ) { glyphnames = Font Support . type 1 C Expert Charset ; return ; } else if ( base == NUM ) { glyphnames = Font Support . type 1 C Expert Sub Charset ; return ; } glyphnames = new int [ nglyphs ] ; glyphnames [ NUM ] = NUM ; pos = base ; int t = read Byte ( ) ; if ( t == NUM ) { for ( int i = NUM ; i < nglyphs ; i ++ ) { glyphnames [ i ] = read Int ( NUM ) ; } } else if ( t == NUM ) { int n = NUM ; while ( n < nglyphs ) { int sid = read Int ( NUM ) ; int range = read Byte ( ) + NUM ; for ( int i = NUM ; i < range ; i ++ ) { glyphnames [ n ++ ] = sid ++ ; } } } else if ( t == NUM ) { int n = NUM ; while ( n < nglyphs ) { int sid = read Int ( NUM ) ; int range = read Int ( NUM ) + NUM ; for ( int i = NUM ; i < range ; i ++ ) { glyphnames [ n ++ ] = sid ++ ; } } } }
private double extremum alpha n ( int n , double [ ] alpha ) { if ( vec . double Value ( n ) == NUM ) { return Math Util . HALFPI ; } double tan = NUM ; for ( int j = n + NUM ; j < vec . get Dimensionality ( ) ; j ++ ) { double alpha j = j == vec . get Dimensionality ( ) - NUM ? NUM : alpha [ j ] ; tan += vec . double Value ( j ) * sinus Product ( n + NUM , j , alpha ) * Math . cos ( alpha j ) ; } tan /= vec . double Value ( n ) ; double alpha n = Math . atan ( tan ) ; if ( alpha n < NUM ) { alpha n = Math . PI + alpha n ; } return alpha n ; }
private double extremum alpha n ( int n , double [ ] alpha ) { if ( vec . double Value ( n ) == NUM ) { return Math Util . HALFPI ; } double tan = NUM ; for ( int j = n + NUM ; j < vec . get Dimensionality ( ) ; j ++ ) { double alpha j = j == vec . get Dimensionality ( ) - NUM ? NUM : alpha [ j ] ; tan += vec . double Value ( j ) * sinus Product ( n + NUM , j , alpha ) * Math . cos ( alpha j ) ; } tan /= vec . double Value ( n ) ; double alpha n = Math . atan ( tan ) ; if ( alpha n < NUM ) { alpha n = Math . PI + alpha n ; } return alpha n ; }
@ Override public Dimension preferred Layout Size ( Container parent ) { Dimension rd , mbd ; Insets i = root Pane . get Insets ( ) ; Container content Pane = root Pane . get Content Pane ( ) ; J Menu Bar menu Bar = root Pane . get J Menu Bar ( ) ; if ( content Pane . is Visible ( ) ) { rd = content Pane . get Preferred Size ( ) ; } else { rd = new Dimension ( NUM , content Pane . get Preferred Size ( ) . height ) ; } if ( menu Bar != null && menu Bar . is Visible ( ) ) { mbd = menu Bar . get Preferred Size ( ) ; } else { mbd = new Dimension ( NUM , NUM ) ; } return new Dimension ( Math . max ( rd . width , mbd . width ) + i . left + i . right , rd . height + mbd . height + i . top + i . bottom ) ; }
@ Override public Dimension preferred Layout Size ( Container parent ) { Dimension rd , mbd ; Insets i = root Pane . get Insets ( ) ; Container content Pane = root Pane . get Content Pane ( ) ; J Menu Bar menu Bar = root Pane . get J Menu Bar ( ) ; if ( content Pane . is Visible ( ) ) { rd = content Pane . get Preferred Size ( ) ; } else { rd = new Dimension ( NUM , content Pane . get Preferred Size ( ) . height ) ; } if ( menu Bar != null && menu Bar . is Visible ( ) ) { mbd = menu Bar . get Preferred Size ( ) ; } else { mbd = new Dimension ( NUM , NUM ) ; } return new Dimension ( Math . max ( rd . width , mbd . width ) + i . left + i . right , rd . height + mbd . height + i . top + i . bottom ) ; }
public void test Will Reset X Path After Recursion ( ) throws Exception { Xpp Dom dom 1 = Xpp Factory . build Dom ( STRING ) ; Xpp Dom dom 2 = Xpp Factory . build Dom ( STRING ) ; assert Equals ( - NUM , comparator . compare ( dom 1 , dom 2 ) ) ; assert Equals ( STRING , xpath . get ( ) ) ; assert Equals ( NUM , comparator . compare ( dom 2 , dom 1 ) ) ; assert Equals ( STRING , xpath . get ( ) ) ; }
public void test Will Reset X Path After Recursion ( ) throws Exception { Xpp Dom dom 1 = Xpp Factory . build Dom ( STRING ) ; Xpp Dom dom 2 = Xpp Factory . build Dom ( STRING ) ; assert Equals ( - NUM , comparator . compare ( dom 1 , dom 2 ) ) ; assert Equals ( STRING , xpath . get ( ) ) ; assert Equals ( NUM , comparator . compare ( dom 2 , dom 1 ) ) ; assert Equals ( STRING , xpath . get ( ) ) ; }
public void test Will Reset X Path After Recursion ( ) throws Exception { Xpp Dom dom 1 = Xpp Factory . build Dom ( STRING ) ; Xpp Dom dom 2 = Xpp Factory . build Dom ( STRING ) ; assert Equals ( - NUM , comparator . compare ( dom 1 , dom 2 ) ) ; assert Equals ( STRING , xpath . get ( ) ) ; assert Equals ( NUM , comparator . compare ( dom 2 , dom 1 ) ) ; assert Equals ( STRING , xpath . get ( ) ) ; }
public List < Value Box > add Argument Hotspots ( String signature , int arg ) { List < Value Box > sig Spots = String Analysis . get Argument Expressions ( signature , arg ) ; return add Argument Hotspots ( signature , arg , sig Spots ) ; }
public void test Case 14 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = - NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public static String convert Resource Path To Class Name ( String resource Path ) { Assert . not Null ( resource Path , STRING ) ; return resource Path . replace ( STRING , STRING ) ; }
public static int to Int Value ( String str ) throws Expression Exception { return ( int ) to Double Value ( str , BOOL ) ; }
public static void create Dirs ( File target ) throws Ade Usage Exception { if ( ! target . exists ( ) && ! target . mkdirs ( ) && ! target . exists ( ) ) { throw new Ade Usage Exception ( STRING + target . get Path ( ) ) ; } }
public Request Handle put ( String url , Response Handler Interface response Handler ) { return put ( null , url , null , response Handler ) ; }
public Request Handle put ( String url , Response Handler Interface response Handler ) { return put ( null , url , null , response Handler ) ; }
public Request Handle put ( String url , Response Handler Interface response Handler ) { return put ( null , url , null , response Handler ) ; }
public Text Editor indent ( int spaces ) { String Buffer sb = new String Buffer ( spaces ) ; for ( int i = NUM ; i < spaces ; i ++ ) { sb . append ( STRING ) ; } return replace All ( STRING , sb . to String ( ) ) ; }
public Text Editor indent ( int spaces ) { String Buffer sb = new String Buffer ( spaces ) ; for ( int i = NUM ; i < spaces ; i ++ ) { sb . append ( STRING ) ; } return replace All ( STRING , sb . to String ( ) ) ; }
public Char Buffer append ( double d ) { return append ( String . value Of ( d ) ) ; }
public void add Phone Number ( Phone Number Entity phone Number ) { phone Numbers . add ( phone Number ) ; }
public static void put Unsigned Byte ( Byte Buffer bb , short v , int offset ) { bb . put ( offset , ( byte ) ( v & NUM ) ) ; }
public Projected Stream add View ( String namespace , String name , List < Expression > parameters ) { views . add ( View . create ( namespace , name , parameters ) ) ; return this ; }
public G Path Result parse ( final File file ) throws IO Exception , SAX Exception { final File Input Stream fis = new File Input Stream ( file ) ; final Input Source input = new Input Source ( fis ) ; input . set System Id ( STRING + file . get Absolute Path ( ) ) ; try { return parse ( input ) ; } finally { fis . close ( ) ; } }
public G Path Result parse ( final File file ) throws IO Exception , SAX Exception { final File Input Stream fis = new File Input Stream ( file ) ; final Input Source input = new Input Source ( fis ) ; input . set System Id ( STRING + file . get Absolute Path ( ) ) ; try { return parse ( input ) ; } finally { fis . close ( ) ; } }
public void update Strength Of Wins ( ) { int str Wins = NUM ; for ( int i = NUM ; i < NUM ; ++ i ) { Game g = game Schedule . get ( i ) ; if ( g . home Team == this ) { str Wins += Math . pow ( NUM - g . away Team . rank Team Poll Score , NUM ) ; } else { str Wins += Math . pow ( NUM - g . home Team . rank Team Poll Score , NUM ) ; } } team Strength Of Wins = str Wins / NUM ; for ( Team t : game Wins Against ) { team Strength Of Wins += Math . pow ( t . wins , NUM ) ; } }
public static int read Var Int ( Byte Buffer buff ) { int b = buff . get ( ) ; if ( b >= NUM ) { return b ; } return read Var Int Rest ( buff , b ) ; }
protected void load Chars ( Abstract MR Reply msg , Data Input Stream istream ) throws IO Exception { int i ; for ( i = NUM ; i < msg . max Size ( ) ; i ++ ) { byte char 1 = read Byte Protected ( istream ) ; if ( flush Receive Chars ) { log . warn ( STRING , msg . to String ( ) ) ; msg . flush ( ) ; i = NUM ; flush Receive Chars = BOOL ; } if ( can Receive ( ) ) { msg . set Element ( i , char 1 ) ; if ( end Of Message ( msg ) ) { break ; } } else { i -- ; log . error ( STRING , Integer . to Hex String ( char 1 ) ) ; } } }
protected void load Chars ( Abstract MR Reply msg , Data Input Stream istream ) throws IO Exception { int i ; for ( i = NUM ; i < msg . max Size ( ) ; i ++ ) { byte char 1 = read Byte Protected ( istream ) ; if ( flush Receive Chars ) { log . warn ( STRING , msg . to String ( ) ) ; msg . flush ( ) ; i = NUM ; flush Receive Chars = BOOL ; } if ( can Receive ( ) ) { msg . set Element ( i , char 1 ) ; if ( end Of Message ( msg ) ) { break ; } } else { i -- ; log . error ( STRING , Integer . to Hex String ( char 1 ) ) ; } } }
public static < T > Task < T > from ( Completion Stage < T > stage ) { if ( stage instanceof Task ) { return ( Task < T > ) stage ; } final Task < T > t = new Task < > ( ) ; stage . handle ( null ) ; return t ; }
@ Override protected Instance process ( Instance instance ) throws Exception { return ( Instance ) instance . copy ( ) ; }
@ Override protected Instance process ( Instance instance ) throws Exception { return ( Instance ) instance . copy ( ) ; }
@ Override protected Instance process ( Instance instance ) throws Exception { return ( Instance ) instance . copy ( ) ; }
public void stop ( boolean hide ) { if ( hide ) { set Visible ( BOOL ) ; } timer . stop ( ) ; }
public void stop ( boolean hide ) { if ( hide ) { set Visible ( BOOL ) ; } timer . stop ( ) ; }
public void stop ( boolean hide ) { if ( hide ) { set Visible ( BOOL ) ; } timer . stop ( ) ; }
public void stop ( boolean hide ) { if ( hide ) { set Visible ( BOOL ) ; } timer . stop ( ) ; }
public List < ? > range ( Value begin , Value end ) { List < Object > results = new Array List < Object > ( ) ; Key [ ] element Keys = get Element Keys ( ) ; if ( element Keys != null && element Keys . length > NUM ) { List < Record > records = fetch Sub Records ( element Keys ) ; for ( Record record : records ) { if ( record != null && filter Bin By Range ( record , List Element Bin Name , begin , end ) ) { results . add ( record . get Value ( List Element Bin Name ) ) ; } } } return results ; }
public static int rand Gaussian ( final int mean , final int sd ) { return ( int ) ( rand . next Gaussian ( ) * sd + mean ) ; }
@ Request Mapping ( value = STRING ) public void metadata Error ( Locale locale , @ Path Variable ( value = STRING ) String tenant , Http Servlet Response response ) throws IO Exception { logger . info ( STRING , locale . to String ( ) , tenant ) ; metadata Default Tenant Binding Error ( locale , response ) ; }
static boolean internal Put ( @ Non Null String key , @ Non Null Object object ) { try { Output Stream Writer osw = new Output Stream Writer ( m Cache . open Stream ( key ) ) ; m Gson . to Json ( object , osw ) ; osw . close ( ) ; return BOOL ; } catch ( Exception e ) { return BOOL ; } }
static int measure Indentation Units ( I Document document , int line Of Invocation Offset , int line Offset , I Java Project project ) throws Bad Location Exception { Map < ? , ? > options = project . get Options ( BOOL ) ; String line Text = document . get ( line Offset , document . get Line Length ( line Of Invocation Offset ) ) ; int indentation Units = Indent Manipulation . measure Indent Units ( line Text , Indent Manipulation . get Tab Width ( options ) , Indent Manipulation . get Indent Width ( options ) ) ; return indentation Units ; }
private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; i18 n = Environment . get I 18 n ( ) ; bean Context Child Support = new Bean Context Child Support ( this ) ; }
public void add Range Restriction ( String Column Name , Object Code , Object Code to ) { Restriction r = new Restriction ( Column Name , Code , Code to , null , null , null , BOOL , NUM ) ; m list . add ( r ) ; }
public String to Json ( ) { String Builder result = new String Builder ( ) ; result . append ( STRING ) ; boolean not The First = BOOL ; List < ? > entries = get All Parentless Entries ( ) ; for ( Object entry Uncasted : entries ) { Entry entry = ( Entry ) entry Uncasted ; if ( not The First ) { result . append ( STRING ) ; } append Indentation ( NUM , result ) ; result . append ( Json Builder . quote ( entry . get Id ( ) ) ) ; result . append ( STRING ) ; to Json Entry Helper ( entry , result , NUM , BOOL , BOOL ) ; not The First = BOOL ; } result . append ( STRING ) ; return result . to String ( ) ; }
public String to Json ( ) { String Builder result = new String Builder ( ) ; result . append ( STRING ) ; boolean not The First = BOOL ; List < ? > entries = get All Parentless Entries ( ) ; for ( Object entry Uncasted : entries ) { Entry entry = ( Entry ) entry Uncasted ; if ( not The First ) { result . append ( STRING ) ; } append Indentation ( NUM , result ) ; result . append ( Json Builder . quote ( entry . get Id ( ) ) ) ; result . append ( STRING ) ; to Json Entry Helper ( entry , result , NUM , BOOL , BOOL ) ; not The First = BOOL ; } result . append ( STRING ) ; return result . to String ( ) ; }
private static void write File ( File file , List < String > lines ) throws IO Exception { if ( ! file . exists ( ) ) file . create New File ( ) ; File Writer fw = new File Writer ( file ) ; Buffered Writer Bw = new Buffered Writer ( fw ) ; Print Writer pw = new Print Writer ( Bw ) ; for ( String line : lines ) pw . println ( line ) ; Bw . close ( ) ; fw . close ( ) ; pw . close ( ) ; }
public void remove Mouse Mode ( String id ) { for ( Map Mouse Mode med : mouse Modes ) { if ( id . equals ( med . get ID ( ) ) ) { remove Mouse Mode ( med ) ; break ; } } }
public void remove Mouse Mode ( String id ) { for ( Map Mouse Mode med : mouse Modes ) { if ( id . equals ( med . get ID ( ) ) ) { remove Mouse Mode ( med ) ; break ; } } }
public void calculate Derived ( ) { mean = Double . Na N ; std Dev = Double . Na N ; if ( count > NUM ) { mean = sum / count ; std Dev = Double . POSITIVE INFINITY ; if ( count > NUM ) { std Dev = sum Sq - ( sum * sum ) / count ; std Dev /= ( count - NUM ) ; if ( std Dev < NUM ) { std Dev = NUM ; } std Dev = Math . sqrt ( std Dev ) ; } } }
public void calculate Derived ( ) { mean = Double . Na N ; std Dev = Double . Na N ; if ( count > NUM ) { mean = sum / count ; std Dev = Double . POSITIVE INFINITY ; if ( count > NUM ) { std Dev = sum Sq - ( sum * sum ) / count ; std Dev /= ( count - NUM ) ; if ( std Dev < NUM ) { std Dev = NUM ; } std Dev = Math . sqrt ( std Dev ) ; } } }
public void calculate Derived ( ) { mean = Double . Na N ; std Dev = Double . Na N ; if ( count > NUM ) { mean = sum / count ; std Dev = Double . POSITIVE INFINITY ; if ( count > NUM ) { std Dev = sum Sq - ( sum * sum ) / count ; std Dev /= ( count - NUM ) ; if ( std Dev < NUM ) { std Dev = NUM ; } std Dev = Math . sqrt ( std Dev ) ; } } }
public void calculate Derived ( ) { mean = Double . Na N ; std Dev = Double . Na N ; if ( count > NUM ) { mean = sum / count ; std Dev = Double . POSITIVE INFINITY ; if ( count > NUM ) { std Dev = sum Sq - ( sum * sum ) / count ; std Dev /= ( count - NUM ) ; if ( std Dev < NUM ) { std Dev = NUM ; } std Dev = Math . sqrt ( std Dev ) ; } } }
public void calculate Derived ( ) { mean = Double . Na N ; std Dev = Double . Na N ; if ( count > NUM ) { mean = sum / count ; std Dev = Double . POSITIVE INFINITY ; if ( count > NUM ) { std Dev = sum Sq - ( sum * sum ) / count ; std Dev /= ( count - NUM ) ; if ( std Dev < NUM ) { std Dev = NUM ; } std Dev = Math . sqrt ( std Dev ) ; } } }
public void calculate Derived ( ) { mean = Double . Na N ; std Dev = Double . Na N ; if ( count > NUM ) { mean = sum / count ; std Dev = Double . POSITIVE INFINITY ; if ( count > NUM ) { std Dev = sum Sq - ( sum * sum ) / count ; std Dev /= ( count - NUM ) ; if ( std Dev < NUM ) { std Dev = NUM ; } std Dev = Math . sqrt ( std Dev ) ; } } }
public void calculate Derived ( ) { mean = Double . Na N ; std Dev = Double . Na N ; if ( count > NUM ) { mean = sum / count ; std Dev = Double . POSITIVE INFINITY ; if ( count > NUM ) { std Dev = sum Sq - ( sum * sum ) / count ; std Dev /= ( count - NUM ) ; if ( std Dev < NUM ) { std Dev = NUM ; } std Dev = Math . sqrt ( std Dev ) ; } } }
public void calculate Derived ( ) { mean = Double . Na N ; std Dev = Double . Na N ; if ( count > NUM ) { mean = sum / count ; std Dev = Double . POSITIVE INFINITY ; if ( count > NUM ) { std Dev = sum Sq - ( sum * sum ) / count ; std Dev /= ( count - NUM ) ; if ( std Dev < NUM ) { std Dev = NUM ; } std Dev = Math . sqrt ( std Dev ) ; } } }
public void calculate Derived ( ) { mean = Double . Na N ; std Dev = Double . Na N ; if ( count > NUM ) { mean = sum / count ; std Dev = Double . POSITIVE INFINITY ; if ( count > NUM ) { std Dev = sum Sq - ( sum * sum ) / count ; std Dev /= ( count - NUM ) ; if ( std Dev < NUM ) { std Dev = NUM ; } std Dev = Math . sqrt ( std Dev ) ; } } }
public void calculate Derived ( ) { mean = Double . Na N ; std Dev = Double . Na N ; if ( count > NUM ) { mean = sum / count ; std Dev = Double . POSITIVE INFINITY ; if ( count > NUM ) { std Dev = sum Sq - ( sum * sum ) / count ; std Dev /= ( count - NUM ) ; if ( std Dev < NUM ) { std Dev = NUM ; } std Dev = Math . sqrt ( std Dev ) ; } } }
private void weighted Median ( int iteration , mx Graph Hierarchy Model model ) { boolean downward Sweep = ( iteration % NUM == NUM ) ; if ( downward Sweep ) { for ( int j = model . max Rank - NUM ; j >= NUM ; j -- ) { median Rank ( j , downward Sweep ) ; } } else { for ( int j = NUM ; j < model . max Rank ; j ++ ) { median Rank ( j , downward Sweep ) ; } } }
public Vector ( double comp [ ] ) throws Negative Array Size Exception { int n = comp . length ; if ( n <= NUM ) throw new Negative Array Size Exception ( STRING ) ; components = new double [ n ] ; System . arraycopy ( comp , NUM , components , NUM , n ) ; }
public static Sorted Set < String > extract Outcome Labels From Feature Vector Files ( File ... files ) throws IO Exception { Sorted Set < String > result = new Tree Set < > ( ) ; for ( File file : files ) { result . add All ( extract Outcome Labels ( file ) ) ; } return result ; }
private void display Popup Menu ( final Mouse Event event ) { final int selected Index = get Selection Index ( event ) ; if ( selected Index != - NUM ) { final J Popup Menu popup Menu = get Popup Menu ( event . get X ( ) , event . get Y ( ) , selected Index ) ; if ( popup Menu != null ) { popup Menu . show ( this , event . get X ( ) , event . get Y ( ) ) ; } } }
protected void add Tags ( E data , Builder builder ) { Platform Ident platform Ident = cached Data Service . get Platform Ident For Id ( data . get Platform Ident ( ) ) ; builder . tag ( Series . TAG AGENT ID , String . value Of ( data . get Platform Ident ( ) ) ) ; if ( null != platform Ident ) { builder . tag ( Series . TAG AGENT NAME , platform Ident . get Agent Name ( ) ) ; } }
protected void add Tags ( E data , Builder builder ) { Platform Ident platform Ident = cached Data Service . get Platform Ident For Id ( data . get Platform Ident ( ) ) ; builder . tag ( Series . TAG AGENT ID , String . value Of ( data . get Platform Ident ( ) ) ) ; if ( null != platform Ident ) { builder . tag ( Series . TAG AGENT NAME , platform Ident . get Agent Name ( ) ) ; } }
protected void add Tags ( E data , Builder builder ) { Platform Ident platform Ident = cached Data Service . get Platform Ident For Id ( data . get Platform Ident ( ) ) ; builder . tag ( Series . TAG AGENT ID , String . value Of ( data . get Platform Ident ( ) ) ) ; if ( null != platform Ident ) { builder . tag ( Series . TAG AGENT NAME , platform Ident . get Agent Name ( ) ) ; } }
public void add ( String marble ) { if ( marble . contains ( STRING ) ) { String [ ] temp = marble . split ( STRING ) ; marble = temp [ NUM ] ; Object Mapper mapper = new Object Mapper ( ) ; try { arg Map = mapper . read Value ( temp [ NUM ] , new Type Reference < Map < String , Map < String , String > > > ( ) { } ) ; } catch ( Exception e ) { Console Utils . error ( STRING ) ; } } if ( marble . contains ( STRING ) || marble . contains ( STRING ) ) { ps . on Next ( create Observable ( marble ) ) ; } else { ps . on Next ( create Hot Observable ( marble ) ) ; } }
public void add ( String marble ) { if ( marble . contains ( STRING ) ) { String [ ] temp = marble . split ( STRING ) ; marble = temp [ NUM ] ; Object Mapper mapper = new Object Mapper ( ) ; try { arg Map = mapper . read Value ( temp [ NUM ] , new Type Reference < Map < String , Map < String , String > > > ( ) { } ) ; } catch ( Exception e ) { Console Utils . error ( STRING ) ; } } if ( marble . contains ( STRING ) || marble . contains ( STRING ) ) { ps . on Next ( create Observable ( marble ) ) ; } else { ps . on Next ( create Hot Observable ( marble ) ) ; } }
public void add ( String marble ) { if ( marble . contains ( STRING ) ) { String [ ] temp = marble . split ( STRING ) ; marble = temp [ NUM ] ; Object Mapper mapper = new Object Mapper ( ) ; try { arg Map = mapper . read Value ( temp [ NUM ] , new Type Reference < Map < String , Map < String , String > > > ( ) { } ) ; } catch ( Exception e ) { Console Utils . error ( STRING ) ; } } if ( marble . contains ( STRING ) || marble . contains ( STRING ) ) { ps . on Next ( create Observable ( marble ) ) ; } else { ps . on Next ( create Hot Observable ( marble ) ) ; } }
public void add ( String marble ) { if ( marble . contains ( STRING ) ) { String [ ] temp = marble . split ( STRING ) ; marble = temp [ NUM ] ; Object Mapper mapper = new Object Mapper ( ) ; try { arg Map = mapper . read Value ( temp [ NUM ] , new Type Reference < Map < String , Map < String , String > > > ( ) { } ) ; } catch ( Exception e ) { Console Utils . error ( STRING ) ; } } if ( marble . contains ( STRING ) || marble . contains ( STRING ) ) { ps . on Next ( create Observable ( marble ) ) ; } else { ps . on Next ( create Hot Observable ( marble ) ) ; } }
public void add ( String marble ) { if ( marble . contains ( STRING ) ) { String [ ] temp = marble . split ( STRING ) ; marble = temp [ NUM ] ; Object Mapper mapper = new Object Mapper ( ) ; try { arg Map = mapper . read Value ( temp [ NUM ] , new Type Reference < Map < String , Map < String , String > > > ( ) { } ) ; } catch ( Exception e ) { Console Utils . error ( STRING ) ; } } if ( marble . contains ( STRING ) || marble . contains ( STRING ) ) { ps . on Next ( create Observable ( marble ) ) ; } else { ps . on Next ( create Hot Observable ( marble ) ) ; } }
public Projection create ( Properties props ) throws Projection Exception { try { Lat Lon Point llp = convert To LLP ( ( Point 2 D ) props . get ( Projection Factory . CENTER ) ) ; float scale = Prop Utils . float From Properties ( props , Projection Factory . SCALE , NUM ) ; int height = Prop Utils . int From Properties ( props , Projection Factory . HEIGHT , NUM ) ; int width = Prop Utils . int From Properties ( props , Projection Factory . WIDTH , NUM ) ; double central meridian = Prop Utils . double From Properties ( props , Central Meridian Property , central Meridian ) ; double sp one = Prop Utils . double From Properties ( props , Standard Parallel One Property , standard Parallel 1 ) ; double sp two = Prop Utils . double From Properties ( props , Standard Parallel Two Property , standard Parallel 2 ) ; double rl = Prop Utils . double From Properties ( props , Reference Latitude Property , reference Latitude ) ; double fe = Prop Utils . double From Properties ( props , False Easting Property , false Easting ) ; double fn = Prop Utils . double From Properties ( props , False Northing Property , false Northing ) ; Ellipsoid ellps = ( Ellipsoid ) props . get ( Projection Factory . DATUM ) ; return new Lambert Conformal ( llp , scale , width , height , central meridian , sp one , sp two , rl , fe , fn , ellps ) ; } catch ( Exception e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + e . get Message ( ) ) ; } } throw new Projection Exception ( STRING ) ; }
public Projection create ( Properties props ) throws Projection Exception { try { Lat Lon Point llp = convert To LLP ( ( Point 2 D ) props . get ( Projection Factory . CENTER ) ) ; float scale = Prop Utils . float From Properties ( props , Projection Factory . SCALE , NUM ) ; int height = Prop Utils . int From Properties ( props , Projection Factory . HEIGHT , NUM ) ; int width = Prop Utils . int From Properties ( props , Projection Factory . WIDTH , NUM ) ; double central meridian = Prop Utils . double From Properties ( props , Central Meridian Property , central Meridian ) ; double sp one = Prop Utils . double From Properties ( props , Standard Parallel One Property , standard Parallel 1 ) ; double sp two = Prop Utils . double From Properties ( props , Standard Parallel Two Property , standard Parallel 2 ) ; double rl = Prop Utils . double From Properties ( props , Reference Latitude Property , reference Latitude ) ; double fe = Prop Utils . double From Properties ( props , False Easting Property , false Easting ) ; double fn = Prop Utils . double From Properties ( props , False Northing Property , false Northing ) ; Ellipsoid ellps = ( Ellipsoid ) props . get ( Projection Factory . DATUM ) ; return new Lambert Conformal ( llp , scale , width , height , central meridian , sp one , sp two , rl , fe , fn , ellps ) ; } catch ( Exception e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + e . get Message ( ) ) ; } } throw new Projection Exception ( STRING ) ; }
public synchronized void write To ( final Output Stream out ) throws IO Exception { int remaining = this . count ; for ( byte [ ] buf : this . buffers ) { int c = Math . min ( buf . length , remaining ) ; out . write ( buf , NUM , c ) ; remaining -= c ; if ( remaining == NUM ) { break ; } } }
public Location ( double latitude , double longitude , int x Offset , int y Offset , String name , OM Graphic location Marker ) { set Location ( latitude , longitude , x Offset , y Offset ) ; this . name = name ; if ( logger . is Loggable ( Level . FINER ) ) { logger . finer ( STRING + latitude + STRING + longitude + STRING + x + STRING + y + STRING + name + STRING ) ; } if ( location Marker == null ) { location = new OM Point ( lat , lon , x Offset , y Offset ) ; } else { location = location Marker ; } label = new OM Text ( lat , lon , x Offset , y Offset , name , OM Text . JUSTIFY LEFT ) ; }
public static void unbind References ( View view ) { try { if ( view != null ) { view . destroy Drawing Cache ( ) ; unbind View References ( view ) ; if ( view instanceof View Group ) { unbind View Group References ( ( View Group ) view ) ; } } } catch ( Throwable e ) { } }
private void update Backend Volume ( Block Consistency Group cg , Volume backend Volume , Db Client db Client ) { if ( backend Volume != null ) { String backend CG = cg . get Cg Name On Storage System ( backend Volume . get Storage Controller ( ) ) ; if ( backend CG != null && ! backend CG . is Empty ( ) ) { log . info ( STRING , backend Volume . get Label ( ) , backend CG ) ; backend Volume . set Replication Group Instance ( backend CG ) ; db Client . update Object ( backend Volume ) ; } } }
public void test Purge ( ) throws Exception { List < Memory File > files = new Array List < Memory File > ( ) ; try { while ( BOOL ) { Memory File new File = new Memory File ( STRING , NUM ) ; new File . allow Purging ( BOOL ) ; new File . write Bytes ( test String , NUM , NUM , test String . length ) ; files . add ( new File ) ; for ( Memory File file : files ) { try { file . read Bytes ( test String , NUM , NUM , test String . length ) ; } catch ( IO Exception e ) { return ; } } } } finally { for ( Memory File file To Close : files ) { file To Close . close ( ) ; } } }
public void test Purge ( ) throws Exception { List < Memory File > files = new Array List < Memory File > ( ) ; try { while ( BOOL ) { Memory File new File = new Memory File ( STRING , NUM ) ; new File . allow Purging ( BOOL ) ; new File . write Bytes ( test String , NUM , NUM , test String . length ) ; files . add ( new File ) ; for ( Memory File file : files ) { try { file . read Bytes ( test String , NUM , NUM , test String . length ) ; } catch ( IO Exception e ) { return ; } } } } finally { for ( Memory File file To Close : files ) { file To Close . close ( ) ; } } }
public static List < String > change Case ( List < String > list ) { if ( list != null ) { List < String > result = new Array List < String > ( ) ; for ( String element : list ) { result . add ( change Case ( element ) ) ; } return result ; } return null ; }
public static List < String > change Case ( List < String > list ) { if ( list != null ) { List < String > result = new Array List < String > ( ) ; for ( String element : list ) { result . add ( change Case ( element ) ) ; } return result ; } return null ; }
public static List < String > change Case ( List < String > list ) { if ( list != null ) { List < String > result = new Array List < String > ( ) ; for ( String element : list ) { result . add ( change Case ( element ) ) ; } return result ; } return null ; }
public static List < String > change Case ( List < String > list ) { if ( list != null ) { List < String > result = new Array List < String > ( ) ; for ( String element : list ) { result . add ( change Case ( element ) ) ; } return result ; } return null ; }
public static List < String > change Case ( List < String > list ) { if ( list != null ) { List < String > result = new Array List < String > ( ) ; for ( String element : list ) { result . add ( change Case ( element ) ) ; } return result ; } return null ; }
public static < T > Delayed Action Queue < T > create ( Delayed Action Listener < T > listener , long delay ) { Delayed Action Queue < T > q = new Delayed Action Queue < > ( listener , delay ) ; q . start ( ) ; return q ; }
public Plain Sasl Authenticator ( final Vertx vertx ) { this . vertx = Objects . require Non Null ( vertx ) ; }
public void add All ( T [ ] items ) { if ( m Event Delegate != null ) m Event Delegate . add Data ( items == null ? NUM : items . length ) ; if ( items != null && items . length != NUM ) { synchronized ( m Lock ) { Collections . add All ( m Objects , items ) ; } } int data Count = items == null ? NUM : items . length ; if ( m Observer != null ) m Observer . on Item Range Inserted ( get Count ( ) - data Count + NUM , data Count ) ; if ( m Notify On Change ) notify Item Range Inserted ( headers . size ( ) + get Count ( ) - data Count + NUM , data Count ) ; log ( STRING + ( ( headers . size ( ) + get Count ( ) - data Count + NUM ) + STRING + ( data Count ) ) ) ; }
public void add All ( T [ ] items ) { if ( m Event Delegate != null ) m Event Delegate . add Data ( items == null ? NUM : items . length ) ; if ( items != null && items . length != NUM ) { synchronized ( m Lock ) { Collections . add All ( m Objects , items ) ; } } int data Count = items == null ? NUM : items . length ; if ( m Observer != null ) m Observer . on Item Range Inserted ( get Count ( ) - data Count + NUM , data Count ) ; if ( m Notify On Change ) notify Item Range Inserted ( headers . size ( ) + get Count ( ) - data Count + NUM , data Count ) ; log ( STRING + ( ( headers . size ( ) + get Count ( ) - data Count + NUM ) + STRING + ( data Count ) ) ) ; }
public static void write Result File ( String filename , Map < String , List < Query Response JSON > > result Map ) throws IO Exception { try ( Buffered Writer bw = new Buffered Writer ( new File Writer ( new File ( filename ) ) ) ) { for ( Entry < String , List < Query Response JSON > > entry : result Map . entry Set ( ) ) { for ( Query Response JSON hit JSON : entry . get Value ( ) ) { bw . write ( hit JSON . get JSON String ( ) ) ; bw . new Line ( ) ; } } } }
public static void write Result File ( String filename , Map < String , List < Query Response JSON > > result Map ) throws IO Exception { try ( Buffered Writer bw = new Buffered Writer ( new File Writer ( new File ( filename ) ) ) ) { for ( Entry < String , List < Query Response JSON > > entry : result Map . entry Set ( ) ) { for ( Query Response JSON hit JSON : entry . get Value ( ) ) { bw . write ( hit JSON . get JSON String ( ) ) ; bw . new Line ( ) ; } } } }
protected void start Download ( int blocks ) { if ( blocks > NUM ) log . info ( STRING + blocks + STRING + ( blocks > NUM ? STRING : STRING ) ) ; }
private static void check Permission ( ) throws Security Exception { Security Manager sm = System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission ( new Joda Time Permission ( STRING ) ) ; } }
void add Child Link ( HTML Link child Link ) { if ( child Links == null ) { child Links = new Vector ( ) ; } child Links . add Element ( child Link ) ; }
static final int advance Probe ( int probe ) { probe ^= probe << NUM ; probe ^= probe > > > NUM ; probe ^= probe << NUM ; UNSAFE . put Int ( Thread . current Thread ( ) , PROBE , probe ) ; return probe ; }
public static Packet to Packet ( byte [ ] octets ) { int packet Len = octets [ NUM ] & NUM ; packet Len |= ( ( octets [ NUM ] << NUM ) & NUM ) ; return to Packet ( Byte Buffer . wrap ( octets , NUM , packet Len ) ) ; }
public void remove Default Value ( String value ) throws SMS Exception , SSO Exception { Set default Values = get Default Values ( ) ; if ( default Values != Collections . EMPTY SET ) { default Values . remove ( value ) ; update Default Values ( default Values ) ; } }
public C Results Table Model ( final Object [ ] [ ] data , final String [ ] column Names ) { super ( data , column Names ) ; }
public void add String To Table ( final byte [ ] old String , final byte new String ) { final int length = old String . length ; final byte [ ] string = new byte [ length + NUM ] ; System . arraycopy ( old String , NUM , string , NUM , length ) ; string [ length ] = new String ; add String To Table ( string ) ; }
static boolean is Exist ( String lib Name , int version ) { String file = target So File ( lib Name , version ) ; File a = new File ( file ) ; return a . exists ( ) ; }
public Forum Post Config update ( Forum Post Config config ) { config . add Credentials ( this ) ; String xml = POST ( this . url + STRING , config . to XML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { config = new Forum Post Config ( ) ; config . parse XML ( root ) ; return config ; } catch ( Exception exception ) { this . exception = SDK Exception . parse Failure ( exception ) ; throw this . exception ; } }
public synchronized void remove Listener ( Object listener ) { if ( listeners != null ) { listeners . remove ( listener ) ; } }
private void load Translations Cache If Empty ( ) { if ( translation Cache . is Empty ( ) ) { for ( Object Translation translation : translations ) { if ( translation . get Locale ( ) != null && translation . get Property ( ) != null && ! String Utils . is Empty ( translation . get Value ( ) ) ) { String key = Object Translation . get Cache Key ( translation . get Locale ( ) , translation . get Property ( ) ) ; translation Cache . put ( key , translation . get Value ( ) ) ; } } } }
public static List < String > read Lines ( File file ) throws IO Exception { return read Lines ( file , Charset . default Charset ( ) ) ; }
public static List < String > read Lines ( File file ) throws IO Exception { return read Lines ( file , Charset . default Charset ( ) ) ; }
private Record Buffer < R > on Take Success ( Record Buffer < R > buffer , long elapsed ) { queued Records -= buffer . size Records ( ) ; queued Bytes -= buffer . size Bytes With Overhead ( ) ; check Pending Records ( ) ; total Taken Buffers . increment And Get ( ) ; not Full . signal ( ) ; return buffer ; }
private Record Buffer < R > on Take Success ( Record Buffer < R > buffer , long elapsed ) { queued Records -= buffer . size Records ( ) ; queued Bytes -= buffer . size Bytes With Overhead ( ) ; check Pending Records ( ) ; total Taken Buffers . increment And Get ( ) ; not Full . signal ( ) ; return buffer ; }
private Record Buffer < R > on Take Success ( Record Buffer < R > buffer , long elapsed ) { queued Records -= buffer . size Records ( ) ; queued Bytes -= buffer . size Bytes With Overhead ( ) ; check Pending Records ( ) ; total Taken Buffers . increment And Get ( ) ; not Full . signal ( ) ; return buffer ; }
public Script Builder data ( byte [ ] data ) { if ( data . length == NUM ) return small Num ( NUM ) ; else return data ( chunks . size ( ) , data ) ; }
public Script Builder data ( byte [ ] data ) { if ( data . length == NUM ) return small Num ( NUM ) ; else return data ( chunks . size ( ) , data ) ; }
private void adjust Min Pref For Spanning Comps ( Dim Constraint [ ] specs , Float [ ] def Push , Flow Size Spec fss , Array List < Linked Dim Group > [ ] groups Lists ) { for ( int r = groups Lists . length - NUM ; r >= NUM ; r -- ) { Array List < Linked Dim Group > groups = groups Lists [ r ] ; for ( Linked Dim Group group : groups ) { if ( group . span == NUM ) continue ; int [ ] sizes = group . get Min Pref Max ( ) ; for ( int s = Layout Util . MIN ; s <= Layout Util . PREF ; s ++ ) { int c Size = sizes [ s ] ; if ( c Size == Layout Util . NOT SET ) continue ; int row Size = NUM ; int s Ix = ( r << NUM ) + NUM ; int len = Math . min ( ( group . span << NUM ) , fss . sizes . length - s Ix ) - NUM ; for ( int j = s Ix ; j < s Ix + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz != Layout Util . NOT SET ) row Size += sz ; } if ( row Size < c Size && len > NUM ) { for ( int eagerness = NUM , new Row Size = NUM ; eagerness < NUM && new Row Size < c Size ; eagerness ++ ) new Row Size = fss . expand Sizes ( specs , def Push , c Size , s Ix , len , s , eagerness ) ; } } } } }
private void adjust Min Pref For Spanning Comps ( Dim Constraint [ ] specs , Float [ ] def Push , Flow Size Spec fss , Array List < Linked Dim Group > [ ] groups Lists ) { for ( int r = groups Lists . length - NUM ; r >= NUM ; r -- ) { Array List < Linked Dim Group > groups = groups Lists [ r ] ; for ( Linked Dim Group group : groups ) { if ( group . span == NUM ) continue ; int [ ] sizes = group . get Min Pref Max ( ) ; for ( int s = Layout Util . MIN ; s <= Layout Util . PREF ; s ++ ) { int c Size = sizes [ s ] ; if ( c Size == Layout Util . NOT SET ) continue ; int row Size = NUM ; int s Ix = ( r << NUM ) + NUM ; int len = Math . min ( ( group . span << NUM ) , fss . sizes . length - s Ix ) - NUM ; for ( int j = s Ix ; j < s Ix + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz != Layout Util . NOT SET ) row Size += sz ; } if ( row Size < c Size && len > NUM ) { for ( int eagerness = NUM , new Row Size = NUM ; eagerness < NUM && new Row Size < c Size ; eagerness ++ ) new Row Size = fss . expand Sizes ( specs , def Push , c Size , s Ix , len , s , eagerness ) ; } } } } }
private void adjust Min Pref For Spanning Comps ( Dim Constraint [ ] specs , Float [ ] def Push , Flow Size Spec fss , Array List < Linked Dim Group > [ ] groups Lists ) { for ( int r = groups Lists . length - NUM ; r >= NUM ; r -- ) { Array List < Linked Dim Group > groups = groups Lists [ r ] ; for ( Linked Dim Group group : groups ) { if ( group . span == NUM ) continue ; int [ ] sizes = group . get Min Pref Max ( ) ; for ( int s = Layout Util . MIN ; s <= Layout Util . PREF ; s ++ ) { int c Size = sizes [ s ] ; if ( c Size == Layout Util . NOT SET ) continue ; int row Size = NUM ; int s Ix = ( r << NUM ) + NUM ; int len = Math . min ( ( group . span << NUM ) , fss . sizes . length - s Ix ) - NUM ; for ( int j = s Ix ; j < s Ix + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz != Layout Util . NOT SET ) row Size += sz ; } if ( row Size < c Size && len > NUM ) { for ( int eagerness = NUM , new Row Size = NUM ; eagerness < NUM && new Row Size < c Size ; eagerness ++ ) new Row Size = fss . expand Sizes ( specs , def Push , c Size , s Ix , len , s , eagerness ) ; } } } } }
private void adjust Min Pref For Spanning Comps ( Dim Constraint [ ] specs , Float [ ] def Push , Flow Size Spec fss , Array List < Linked Dim Group > [ ] groups Lists ) { for ( int r = groups Lists . length - NUM ; r >= NUM ; r -- ) { Array List < Linked Dim Group > groups = groups Lists [ r ] ; for ( Linked Dim Group group : groups ) { if ( group . span == NUM ) continue ; int [ ] sizes = group . get Min Pref Max ( ) ; for ( int s = Layout Util . MIN ; s <= Layout Util . PREF ; s ++ ) { int c Size = sizes [ s ] ; if ( c Size == Layout Util . NOT SET ) continue ; int row Size = NUM ; int s Ix = ( r << NUM ) + NUM ; int len = Math . min ( ( group . span << NUM ) , fss . sizes . length - s Ix ) - NUM ; for ( int j = s Ix ; j < s Ix + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz != Layout Util . NOT SET ) row Size += sz ; } if ( row Size < c Size && len > NUM ) { for ( int eagerness = NUM , new Row Size = NUM ; eagerness < NUM && new Row Size < c Size ; eagerness ++ ) new Row Size = fss . expand Sizes ( specs , def Push , c Size , s Ix , len , s , eagerness ) ; } } } } }
public void remove Mapping ( String virtual ) throws Expression Exception , Security Exception { check Write Access ( ) ; remove Mapping ( virtual ) ; }
public void optimize ( ) { for ( int i = operations . size ( ) - NUM ; i >= NUM ; i -- ) { Operation o = operations . get ( i ) ; if ( o instanceof Clear Operation ) { while ( i > NUM ) { operations . remove ( i ) ; i -- ; } return ; } } }
public void optimize ( ) { for ( int i = operations . size ( ) - NUM ; i >= NUM ; i -- ) { Operation o = operations . get ( i ) ; if ( o instanceof Clear Operation ) { while ( i > NUM ) { operations . remove ( i ) ; i -- ; } return ; } } }
public void optimize ( ) { for ( int i = operations . size ( ) - NUM ; i >= NUM ; i -- ) { Operation o = operations . get ( i ) ; if ( o instanceof Clear Operation ) { while ( i > NUM ) { operations . remove ( i ) ; i -- ; } return ; } } }
public Msrp Session create Msrp Client Session ( String remote Host , int remote Port , String remote Msrp Path , Msrp Event Listener listener , String fingerprint ) { if ( logger . is Activated ( ) ) { logger . info ( STRING + remote Host + STRING + remote Port ) ; } m Msrp Session = new Msrp Session ( m Rcs Settings ) ; m Msrp Session . set From ( get Local Msrp Path ( ) ) ; m Msrp Session . set To ( remote Msrp Path ) ; Msrp Connection connection = new Msrp Client Connection ( m Msrp Session , remote Host , remote Port , m Secured , fingerprint ) ; m Msrp Session . set Connection ( connection ) ; m Msrp Session . add Msrp Event Listener ( listener ) ; return m Msrp Session ; }
static private String INT Max ( ) { int temp Value = Integer . MAX VALUE ; return String . value Of ( temp Value ) ; }
public void write External ( Object Output out ) throws IO Exception { out . write Float ( x ) ; out . write Float ( y ) ; }
@ Suppress Warnings ( STRING ) private void validate And Populate ( Boolean allow Non Upn Format ) throws Invalid Token Exception { JAXB Element < Assertion Type > jaxb Parser Result = null ; try { Unmarshaller unmarshaller = jaxb Context . create Unmarshaller ( ) ; unmarshaller . set Schema ( SAML SCHEMA ) ; jaxb Parser Result = ( JAXB Element < Assertion Type > ) unmarshaller . unmarshal ( parsed Token ) ; } catch ( JAXB Exception e ) { log . info ( PARSING TOKEN ERROR MSG , e ) ; throw new Malformed Token Exception ( PARSING TOKEN ERROR MSG , e ) ; } Assertion Type assertion = jaxb Parser Result . get Value ( ) ; parse Assertion Attributes ( assertion ) ; parse Conditions ( assertion . get Conditions ( ) , allow Non Upn Format ) ; parse Subject ( assertion . get Subject ( ) ) ; parse Issuer ( assertion . get Issuer ( ) ) ; parse Authn Statement ( assertion . get Authn Statement Or Attribute Statement ( ) ) ; if ( assertion . get Authn Statement Or Attribute Statement ( ) != null ) { parse Attribute Statement ( assertion . get Authn Statement Or Attribute Statement ( ) ) ; } if ( assertion . get Advice ( ) != null ) { parse Advice ( assertion . get Advice ( ) ) ; } log . debug ( STRING ) ; }
@ Suppress Warnings ( STRING ) private void validate And Populate ( Boolean allow Non Upn Format ) throws Invalid Token Exception { JAXB Element < Assertion Type > jaxb Parser Result = null ; try { Unmarshaller unmarshaller = jaxb Context . create Unmarshaller ( ) ; unmarshaller . set Schema ( SAML SCHEMA ) ; jaxb Parser Result = ( JAXB Element < Assertion Type > ) unmarshaller . unmarshal ( parsed Token ) ; } catch ( JAXB Exception e ) { log . info ( PARSING TOKEN ERROR MSG , e ) ; throw new Malformed Token Exception ( PARSING TOKEN ERROR MSG , e ) ; } Assertion Type assertion = jaxb Parser Result . get Value ( ) ; parse Assertion Attributes ( assertion ) ; parse Conditions ( assertion . get Conditions ( ) , allow Non Upn Format ) ; parse Subject ( assertion . get Subject ( ) ) ; parse Issuer ( assertion . get Issuer ( ) ) ; parse Authn Statement ( assertion . get Authn Statement Or Attribute Statement ( ) ) ; if ( assertion . get Authn Statement Or Attribute Statement ( ) != null ) { parse Attribute Statement ( assertion . get Authn Statement Or Attribute Statement ( ) ) ; } if ( assertion . get Advice ( ) != null ) { parse Advice ( assertion . get Advice ( ) ) ; } log . debug ( STRING ) ; }
private void write Attr ( String name , String val ) throws IO Exception { write Attr ( name , val , BOOL ) ; }
private void write Attr ( String name , String val ) throws IO Exception { write Attr ( name , val , BOOL ) ; }
private void write Attr ( String name , String val ) throws IO Exception { write Attr ( name , val , BOOL ) ; }
@ Synchronized ( STRING ) @ Suppress Warnings ( STRING ) public C create Channel ( @ Non Null String name ) { C chan = ( C ) bot Factory . create Channel ( bot , name ) ; channel Name Map . put ( name . to Lower Case ( locale ) , chan ) ; return chan ; }
@ Synchronized ( STRING ) @ Suppress Warnings ( STRING ) public C create Channel ( @ Non Null String name ) { C chan = ( C ) bot Factory . create Channel ( bot , name ) ; channel Name Map . put ( name . to Lower Case ( locale ) , chan ) ; return chan ; }
public int add JSON ( JSON Object j , Table table ) { if ( ! m Db . below Mem Threshold ( ) ) { Log . e ( LOGTAG , STRING ) ; return DB OUT OF MEMORY ERROR ; } final String table Name = table . get Name ( ) ; Cursor c = null ; int count = DB UPDATE ERROR ; synchronized ( m Db ) { try { final SQ Lite Database db = m Db . get Writable Database ( ) ; final Content Values cv = new Content Values ( ) ; cv . put ( KEY DATA , j . to String ( ) ) ; cv . put ( KEY CREATED AT , System . current Time Millis ( ) ) ; db . insert ( table Name , null , cv ) ; c = db . raw Query ( STRING + table Name , null ) ; c . move To First ( ) ; count = c . get Int ( NUM ) ; } catch ( final SQ Lite Exception e ) { Log . e ( LOGTAG , STRING + table Name + STRING , e ) ; if ( c != null ) { c . close ( ) ; c = null ; } init DB ( ) ; } catch ( final Illegal State Exception e ) { Log . e ( LOGTAG , STRING + table Name + STRING , e ) ; if ( c != null ) { c . close ( ) ; c = null ; } init DB ( ) ; } finally { if ( c != null ) { c . close ( ) ; } m Db . close ( ) ; } } return count ; }
public int add JSON ( JSON Object j , Table table ) { if ( ! m Db . below Mem Threshold ( ) ) { Log . e ( LOGTAG , STRING ) ; return DB OUT OF MEMORY ERROR ; } final String table Name = table . get Name ( ) ; Cursor c = null ; int count = DB UPDATE ERROR ; synchronized ( m Db ) { try { final SQ Lite Database db = m Db . get Writable Database ( ) ; final Content Values cv = new Content Values ( ) ; cv . put ( KEY DATA , j . to String ( ) ) ; cv . put ( KEY CREATED AT , System . current Time Millis ( ) ) ; db . insert ( table Name , null , cv ) ; c = db . raw Query ( STRING + table Name , null ) ; c . move To First ( ) ; count = c . get Int ( NUM ) ; } catch ( final SQ Lite Exception e ) { Log . e ( LOGTAG , STRING + table Name + STRING , e ) ; if ( c != null ) { c . close ( ) ; c = null ; } init DB ( ) ; } catch ( final Illegal State Exception e ) { Log . e ( LOGTAG , STRING + table Name + STRING , e ) ; if ( c != null ) { c . close ( ) ; c = null ; } init DB ( ) ; } finally { if ( c != null ) { c . close ( ) ; } m Db . close ( ) ; } } return count ; }
@ Requires Permission ( PERMISSION ) @ Override public boolean request Send ( ) { Activity activity = m Activity . get ( ) ; if ( activity == null ) return BOOL ; if ( Log . is Loggable ( Log . VERBOSE ) ) Log . v ( STRING ) ; if ( check Self Permission ( activity , PERMISSION ) != Package Manager . PERMISSION GRANTED ) { request Permissions ( activity , new String [ ] { PERMISSION } , PERMISSION REQUEST CODE ) ; return BOOL ; } return get Fresh Location ( new Sender Location Listener ( this ) ) ; }
public synchronized void stop ( ) throws No Such Object Exception { if ( is Running ( ) ) { is Running = ! Unicast Remote Object . unexport Object ( registry , BOOL ) ; } }
public synchronized void stop ( ) throws No Such Object Exception { if ( is Running ( ) ) { is Running = ! Unicast Remote Object . unexport Object ( registry , BOOL ) ; } }
public synchronized void stop ( ) throws No Such Object Exception { if ( is Running ( ) ) { is Running = ! Unicast Remote Object . unexport Object ( registry , BOOL ) ; } }
void find Classes Deriving From ( String super name , Map < String , Class Reader > zip Classes , Map < String , Class Reader > in Out Found ) throws Log Abort Exception { Class Reader super clazz = find Class ( super name , zip Classes , in Out Found ) ; for ( Entry < String , Class Reader > entry : zip Classes . entry Set ( ) ) { String class Name = entry . get Key ( ) ; if ( super name . equals ( class Name ) ) { continue ; } Class Reader class Reader = entry . get Value ( ) ; Class Reader parent cr = class Reader ; while ( parent cr != null ) { String parent name = internal To Binary Class Name ( parent cr . get Super Name ( ) ) ; if ( parent name == null ) { break ; } else if ( super name . equals ( parent name ) ) { in Out Found . put ( class Name , class Reader ) ; break ; } parent cr = zip Classes . get ( parent name ) ; } } }
void find Classes Deriving From ( String super name , Map < String , Class Reader > zip Classes , Map < String , Class Reader > in Out Found ) throws Log Abort Exception { Class Reader super clazz = find Class ( super name , zip Classes , in Out Found ) ; for ( Entry < String , Class Reader > entry : zip Classes . entry Set ( ) ) { String class Name = entry . get Key ( ) ; if ( super name . equals ( class Name ) ) { continue ; } Class Reader class Reader = entry . get Value ( ) ; Class Reader parent cr = class Reader ; while ( parent cr != null ) { String parent name = internal To Binary Class Name ( parent cr . get Super Name ( ) ) ; if ( parent name == null ) { break ; } else if ( super name . equals ( parent name ) ) { in Out Found . put ( class Name , class Reader ) ; break ; } parent cr = zip Classes . get ( parent name ) ; } } }
void find Classes Deriving From ( String super name , Map < String , Class Reader > zip Classes , Map < String , Class Reader > in Out Found ) throws Log Abort Exception { Class Reader super clazz = find Class ( super name , zip Classes , in Out Found ) ; for ( Entry < String , Class Reader > entry : zip Classes . entry Set ( ) ) { String class Name = entry . get Key ( ) ; if ( super name . equals ( class Name ) ) { continue ; } Class Reader class Reader = entry . get Value ( ) ; Class Reader parent cr = class Reader ; while ( parent cr != null ) { String parent name = internal To Binary Class Name ( parent cr . get Super Name ( ) ) ; if ( parent name == null ) { break ; } else if ( super name . equals ( parent name ) ) { in Out Found . put ( class Name , class Reader ) ; break ; } parent cr = zip Classes . get ( parent name ) ; } } }
public Create Request ( Content Format content Format , int object Id , Collection < Lw M 2 m Resource > resources ) { this ( content Format , object Id , resources . to Array ( new Lw M 2 m Resource [ resources . size ( ) ] ) ) ; }
private static void save Pgr ( Dispatch Context dctx , Generic Value pgr ) { Map < String , Generic Value > context = Util Misc . < String , Generic Value > to Map ( STRING , pgr ) ; Local Dispatcher dispatcher = dctx . get Dispatcher ( ) ; Delegator delegator = dctx . get Delegator ( ) ; try { dispatcher . add Rollback Service ( STRING , context , BOOL ) ; delegator . create ( pgr ) ; } catch ( Exception e ) { Debug . log Error ( e , module ) ; } }
public void add Imported Files ( File xml File ) { if ( xml File . exists ( ) ) { imported Files . add ( xml File ) ; } else { imported Files . add ( new File ( STRING + xml File ) ) ; } }
public static Transaction round Trip Transaction ( Network Parameters params , Transaction tx ) throws IO Exception , Protocol Exception { Bitcoin Serializer bs = new Bitcoin Serializer ( params ) ; Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; bs . serialize ( tx , bos ) ; return ( Transaction ) bs . deserialize ( Byte Buffer . wrap ( bos . to Byte Array ( ) ) ) ; }
public static Transaction round Trip Transaction ( Network Parameters params , Transaction tx ) throws IO Exception , Protocol Exception { Bitcoin Serializer bs = new Bitcoin Serializer ( params ) ; Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; bs . serialize ( tx , bos ) ; return ( Transaction ) bs . deserialize ( Byte Buffer . wrap ( bos . to Byte Array ( ) ) ) ; }
private static void fill ( DT Sweep Context tcx , Advancing Front Node node ) { Delaunay Triangle triangle = new Delaunay Triangle ( node . prev . point , node . point , node . next . point ) ; triangle . mark Neighbor ( node . prev . triangle ) ; triangle . mark Neighbor ( node . triangle ) ; tcx . add To List ( triangle ) ; node . prev . next = node . next ; node . next . prev = node . prev ; tcx . remove Node ( node ) ; if ( ! legalize ( tcx , triangle ) ) { tcx . map Triangle To Nodes ( triangle ) ; } }
private static void fill ( DT Sweep Context tcx , Advancing Front Node node ) { Delaunay Triangle triangle = new Delaunay Triangle ( node . prev . point , node . point , node . next . point ) ; triangle . mark Neighbor ( node . prev . triangle ) ; triangle . mark Neighbor ( node . triangle ) ; tcx . add To List ( triangle ) ; node . prev . next = node . next ; node . next . prev = node . prev ; tcx . remove Node ( node ) ; if ( ! legalize ( tcx , triangle ) ) { tcx . map Triangle To Nodes ( triangle ) ; } }
public Int Stream Ex remove ( Int Predicate predicate ) { return filter ( predicate . negate ( ) ) ; }
public Int Stream Ex remove ( Int Predicate predicate ) { return filter ( predicate . negate ( ) ) ; }
public static String extract Host Id ( String host Id ) { Assert Util . assert Not Null ( host Id , STRING ) ; int idx = host Id . index Of ( HOST ID TENANT SEPARATOR ) ; String id = host Id ; if ( idx != - NUM ) { id = host Id . substring ( idx + HOST ID TENANT SEPARATOR . length ( ) ) ; } return id ; }
public void remove ( Predicate filter ) { for ( Int Iterator ii = rows ( filter ) ; ii . has Next ( ) ; ) remove Row ( ii . next Int ( ) ) ; }
public void remove ( Predicate filter ) { for ( Int Iterator ii = rows ( filter ) ; ii . has Next ( ) ; ) remove Row ( ii . next Int ( ) ) ; }
public void has Valid Annotations ( ) { assert That Annotated Class Has Valid I 18 n ( ) ; assert That Annotated Class Has Annotated Methods ( ) ; assert That All Schemas Are Valid ( ) ; }
public void has Valid Annotations ( ) { assert That Annotated Class Has Valid I 18 n ( ) ; assert That Annotated Class Has Annotated Methods ( ) ; assert That All Schemas Are Valid ( ) ; }
public void has Valid Annotations ( ) { assert That Annotated Class Has Valid I 18 n ( ) ; assert That Annotated Class Has Annotated Methods ( ) ; assert That All Schemas Are Valid ( ) ; }
public void has Valid Annotations ( ) { assert That Annotated Class Has Valid I 18 n ( ) ; assert That Annotated Class Has Annotated Methods ( ) ; assert That All Schemas Are Valid ( ) ; }
private Class Signature load Class From Jigsaw ( String classname ) throws IO Exception { if ( method Class get Module == null || method Module get Name == null ) { return null ; } final Class < ? > clazz ; final String module Name ; try { clazz = Class . for Name ( classname , BOOL , loader ) ; final Object module = method Class get Module . invoke ( clazz ) ; module Name = ( String ) method Module get Name . invoke ( module ) ; } catch ( Exception e ) { return null ; } return new Class Signature ( clazz , Asm Utils . is Runtime Module ( module Name ) ) ; }
public final V update And Get ( Unary Operator < V > update Function ) { V prev , next ; do { prev = get ( ) ; next = update Function . apply ( prev ) ; } while ( ! compare And Set ( prev , next ) ) ; return next ; }
public final V update And Get ( Unary Operator < V > update Function ) { V prev , next ; do { prev = get ( ) ; next = update Function . apply ( prev ) ; } while ( ! compare And Set ( prev , next ) ) ; return next ; }
public final V update And Get ( Unary Operator < V > update Function ) { V prev , next ; do { prev = get ( ) ; next = update Function . apply ( prev ) ; } while ( ! compare And Set ( prev , next ) ) ; return next ; }
public final V update And Get ( Unary Operator < V > update Function ) { V prev , next ; do { prev = get ( ) ; next = update Function . apply ( prev ) ; } while ( ! compare And Set ( prev , next ) ) ; return next ; }
protected void update Ports ( ) { if ( ! is Changing ) { is Changing = BOOL ; boolean first = BOOL ; T found Disconnected = null ; Iterator < T > i = managed Ports . iterator ( ) ; while ( i . has Next ( ) ) { T port = i . next ( ) ; if ( ! port . is Connected ( ) && ! port . is Locked ( ) ) { if ( first ) { found Disconnected = port ; first = BOOL ; } else { if ( min Number == NUM ) { delete Port ( port ) ; i . remove ( ) ; } } } } if ( ( found Disconnected == null ) || ( managed Ports . size ( ) < min Number ) ) { do { managed Ports . add ( create Port ( ) ) ; } while ( managed Ports . size ( ) < min Number ) ; } else { if ( min Number == NUM ) { managed Ports . remove ( found Disconnected ) ; managed Ports . add ( found Disconnected ) ; ports . push Down ( found Disconnected ) ; } } fix Names ( ) ; is Changing = BOOL ; } }
void add To Emebedded CSS ( CSS Element css Element ) { if ( embedded CSS == null ) { embedded CSS = new Vector ( ) ; } embedded CSS . add Element ( css Element ) ; }
void add To Emebedded CSS ( CSS Element css Element ) { if ( embedded CSS == null ) { embedded CSS = new Vector ( ) ; } embedded CSS . add Element ( css Element ) ; }
void add To Emebedded CSS ( CSS Element css Element ) { if ( embedded CSS == null ) { embedded CSS = new Vector ( ) ; } embedded CSS . add Element ( css Element ) ; }
String binary To Internal Class Name ( String class Name ) { if ( class Name == null ) { return null ; } else { return class Name . replace ( STRING , STRING ) ; } }
String binary To Internal Class Name ( String class Name ) { if ( class Name == null ) { return null ; } else { return class Name . replace ( STRING , STRING ) ; } }
String binary To Internal Class Name ( String class Name ) { if ( class Name == null ) { return null ; } else { return class Name . replace ( STRING , STRING ) ; } }
String binary To Internal Class Name ( String class Name ) { if ( class Name == null ) { return null ; } else { return class Name . replace ( STRING , STRING ) ; } }
String binary To Internal Class Name ( String class Name ) { if ( class Name == null ) { return null ; } else { return class Name . replace ( STRING , STRING ) ; } }
protected void process View Events ( Source Printer printer ) { process History Changed Evt ( printer ) ; process Closing Evt ( printer ) ; process Close Evt ( printer ) ; process Resized Evt ( printer ) ; process Load Evt ( printer ) ; process Unload Evt ( printer ) ; process Activate Evt ( printer ) ; process Deactivate Evt ( printer ) ; }
public void interrupt ( ) { Thread t = m thread Var . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m thread Var . clear ( ) ; }
public void interrupt ( ) { Thread t = m thread Var . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m thread Var . clear ( ) ; }
public void interrupt ( ) { Thread t = m thread Var . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m thread Var . clear ( ) ; }
public void interrupt ( ) { Thread t = m thread Var . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m thread Var . clear ( ) ; }
public void interrupt ( ) { Thread t = m thread Var . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m thread Var . clear ( ) ; }
public void interrupt ( ) { Thread t = m thread Var . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m thread Var . clear ( ) ; }
public void interrupt ( ) { Thread t = m thread Var . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m thread Var . clear ( ) ; }
public void interrupt ( ) { Thread t = m thread Var . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m thread Var . clear ( ) ; }
public void interrupt ( ) { Thread t = m thread Var . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m thread Var . clear ( ) ; }
public static Search Pattern create Or Pattern ( Search Pattern left Pattern , Search Pattern right Pattern ) { return new Or Pattern ( left Pattern , right Pattern ) ; }
public static Search Pattern create Or Pattern ( Search Pattern left Pattern , Search Pattern right Pattern ) { return new Or Pattern ( left Pattern , right Pattern ) ; }
@ Override public void end CDATA ( ) throws IO Exception { close Start If Necessary ( ) ; writer . write ( STRING ) ; writing Cdata = BOOL ; }
private static byte [ ] expand ( byte [ ] d ) { Inflater inflater = new Inflater ( ) ; inflater . set Input ( d ) ; Byte Array Output Stream out = new Byte Array Output Stream ( d . length ) ; byte [ ] buffer = new byte [ NUM ] ; try { while ( ! inflater . finished ( ) ) { int count = inflater . inflate ( buffer ) ; out . write ( buffer , NUM , count ) ; } inflater . end ( ) ; } catch ( Exception e ) { throw new Illegal Argument Exception ( e ) ; } return out . to Byte Array ( ) ; }
public void clear Moving Points ( ) { moving Points . clear ( ) ; sprite Count Label . set Text ( Integer . to String ( moving Points . size ( ) ) ) ; do Prepare ( ) ; stop Timer ( ) ; }
public void remove Legend ( ) { remove ( plot Legend ) ; }
public void test encode decode 0bits stress ( ) { final Random r = new Random ( ) ; final Term Id Encoder encoder = new Term Id Encoder ( NUM ) ; for ( int i = NUM ; i < NUM ; i ++ ) { final long v0 = r . next Long ( ) ; if ( v0 == NUM ) { continue ; } final long v1 = encoder . encode ( v0 ) ; final long v2 = encoder . encode 2 ( v0 ) ; assert True ( v1 == v2 ) ; if ( v0 != v1 ) fail ( encoder , v0 , v1 ) ; } }
public static String strip Prefix ( String str , String prefix ) { return str . starts With ( prefix ) ? str . substring ( prefix . length ( ) ) : null ; }
public static Process Builder rtl Sdr Snif ( String dir , String frequency , String gain , String samplerate ) { Process Builder pb = new Process Builder ( STRING , STRING , frequency , STRING , gain , frequency + STRING , STRING , samplerate ) ; pb . directory ( new File ( dir ) ) ; return pb ; }
public static Process Builder rtl Sdr Snif ( String dir , String frequency , String gain , String samplerate ) { Process Builder pb = new Process Builder ( STRING , STRING , frequency , STRING , gain , frequency + STRING , STRING , samplerate ) ; pb . directory ( new File ( dir ) ) ; return pb ; }
public String reverse Words ( String s ) { if ( s == null || s . length ( ) == NUM ) return STRING ; String res = STRING ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; if ( c == STRING ) continue ; else { String Builder word = new String Builder ( ) ; while ( i < s . length ( ) ) { c = s . char At ( i ) ; if ( c == STRING ) break ; word . append ( c ) ; i ++ ; } res = res . length ( ) == NUM ? word . to String ( ) : word . to String ( ) + STRING + res ; i -- ; } } return res ; }
public String reverse Words ( String s ) { if ( s == null || s . length ( ) == NUM ) return STRING ; String res = STRING ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; if ( c == STRING ) continue ; else { String Builder word = new String Builder ( ) ; while ( i < s . length ( ) ) { c = s . char At ( i ) ; if ( c == STRING ) break ; word . append ( c ) ; i ++ ; } res = res . length ( ) == NUM ? word . to String ( ) : word . to String ( ) + STRING + res ; i -- ; } } return res ; }
public String reverse Words ( String s ) { if ( s == null || s . length ( ) == NUM ) return STRING ; String res = STRING ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; if ( c == STRING ) continue ; else { String Builder word = new String Builder ( ) ; while ( i < s . length ( ) ) { c = s . char At ( i ) ; if ( c == STRING ) break ; word . append ( c ) ; i ++ ; } res = res . length ( ) == NUM ? word . to String ( ) : word . to String ( ) + STRING + res ; i -- ; } } return res ; }
public String reverse Words ( String s ) { if ( s == null || s . length ( ) == NUM ) return STRING ; String res = STRING ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; if ( c == STRING ) continue ; else { String Builder word = new String Builder ( ) ; while ( i < s . length ( ) ) { c = s . char At ( i ) ; if ( c == STRING ) break ; word . append ( c ) ; i ++ ; } res = res . length ( ) == NUM ? word . to String ( ) : word . to String ( ) + STRING + res ; i -- ; } } return res ; }
public String reverse Words ( String s ) { if ( s == null || s . length ( ) == NUM ) return STRING ; String res = STRING ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; if ( c == STRING ) continue ; else { String Builder word = new String Builder ( ) ; while ( i < s . length ( ) ) { c = s . char At ( i ) ; if ( c == STRING ) break ; word . append ( c ) ; i ++ ; } res = res . length ( ) == NUM ? word . to String ( ) : word . to String ( ) + STRING + res ; i -- ; } } return res ; }
public String reverse Words ( String s ) { if ( s == null || s . length ( ) == NUM ) return STRING ; String res = STRING ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; if ( c == STRING ) continue ; else { String Builder word = new String Builder ( ) ; while ( i < s . length ( ) ) { c = s . char At ( i ) ; if ( c == STRING ) break ; word . append ( c ) ; i ++ ; } res = res . length ( ) == NUM ? word . to String ( ) : word . to String ( ) + STRING + res ; i -- ; } } return res ; }
public static boolean bool Value ( String prop Name , boolean dflt ) { String sys Prop = get Property ( prop Name ) ; return ( sys Prop != null && ! sys Prop . is Empty ( ) ) ? Boolean . get Boolean ( sys Prop ) : dflt ; }
public static String after ( String s , String token ) { if ( s == null ) { return null ; } int i = s . index Of ( token ) ; if ( i == - NUM ) { return s ; } return s . substring ( i + token . length ( ) ) ; }
public static File Footer convert File Footer ( List < Blocklet Info Columnar > info List , int num Cols , int [ ] cardinalities , List < Column Schema > column Schema List , Segment Properties segment Properties ) throws IO Exception { Segment Info segment Info = new Segment Info ( ) ; segment Info . set Num cols ( column Schema List . size ( ) ) ; segment Info . set Column cardinalities ( Carbon Util . convert To Integer List ( cardinalities ) ) ; File Footer footer = new File Footer ( ) ; footer . set Num rows ( get Total Number Of Rows ( info List ) ) ; footer . set Segment info ( segment Info ) ; for ( Blocklet Info Columnar info : info List ) { footer . add To Blocklet index list ( get Blocklet Index ( info ) ) ; } footer . set Table columns ( column Schema List ) ; for ( Blocklet Info Columnar info : info List ) { footer . add To Blocklet info list ( get Blocklet Info ( info , column Schema List , segment Properties ) ) ; } return footer ; }
public static File Footer convert File Footer ( List < Blocklet Info Columnar > info List , int num Cols , int [ ] cardinalities , List < Column Schema > column Schema List , Segment Properties segment Properties ) throws IO Exception { Segment Info segment Info = new Segment Info ( ) ; segment Info . set Num cols ( column Schema List . size ( ) ) ; segment Info . set Column cardinalities ( Carbon Util . convert To Integer List ( cardinalities ) ) ; File Footer footer = new File Footer ( ) ; footer . set Num rows ( get Total Number Of Rows ( info List ) ) ; footer . set Segment info ( segment Info ) ; for ( Blocklet Info Columnar info : info List ) { footer . add To Blocklet index list ( get Blocklet Index ( info ) ) ; } footer . set Table columns ( column Schema List ) ; for ( Blocklet Info Columnar info : info List ) { footer . add To Blocklet info list ( get Blocklet Info ( info , column Schema List , segment Properties ) ) ; } return footer ; }
@ Override public Connection Protocol new Connection ( Connection Tcp conn Tcp ) { return new Connection Http ( this , conn Tcp , sequence . increment And Get ( ) ) ; }
public void check Can Build List ( ) { if ( listeners . is Empty ( ) ) { if ( sys Name List != null ) { deregister ( ) ; sys Name List = null ; } can Build List = BOOL ; } }
public void check Can Build List ( ) { if ( listeners . is Empty ( ) ) { if ( sys Name List != null ) { deregister ( ) ; sys Name List = null ; } can Build List = BOOL ; } }
public void check Can Build List ( ) { if ( listeners . is Empty ( ) ) { if ( sys Name List != null ) { deregister ( ) ; sys Name List = null ; } can Build List = BOOL ; } }
public void check Can Build List ( ) { if ( listeners . is Empty ( ) ) { if ( sys Name List != null ) { deregister ( ) ; sys Name List = null ; } can Build List = BOOL ; } }
public void initialize ( ) { load Helpers = new Linked List < Class Load Helper > ( ) ; load Helpers . add ( new Loading Loader Class Load Helper ( ) ) ; load Helpers . add ( new Simple Class Load Helper ( ) ) ; load Helpers . add ( new Thread Context Class Load Helper ( ) ) ; load Helpers . add ( new Init Thread Context Class Load Helper ( ) ) ; for ( Class Load Helper load Helper : load Helpers ) { load Helper . initialize ( ) ; } }
public void initialize ( ) { load Helpers = new Linked List < Class Load Helper > ( ) ; load Helpers . add ( new Loading Loader Class Load Helper ( ) ) ; load Helpers . add ( new Simple Class Load Helper ( ) ) ; load Helpers . add ( new Thread Context Class Load Helper ( ) ) ; load Helpers . add ( new Init Thread Context Class Load Helper ( ) ) ; for ( Class Load Helper load Helper : load Helpers ) { load Helper . initialize ( ) ; } }
public void initialize ( ) { load Helpers = new Linked List < Class Load Helper > ( ) ; load Helpers . add ( new Loading Loader Class Load Helper ( ) ) ; load Helpers . add ( new Simple Class Load Helper ( ) ) ; load Helpers . add ( new Thread Context Class Load Helper ( ) ) ; load Helpers . add ( new Init Thread Context Class Load Helper ( ) ) ; for ( Class Load Helper load Helper : load Helpers ) { load Helper . initialize ( ) ; } }
public void initialize ( ) { load Helpers = new Linked List < Class Load Helper > ( ) ; load Helpers . add ( new Loading Loader Class Load Helper ( ) ) ; load Helpers . add ( new Simple Class Load Helper ( ) ) ; load Helpers . add ( new Thread Context Class Load Helper ( ) ) ; load Helpers . add ( new Init Thread Context Class Load Helper ( ) ) ; for ( Class Load Helper load Helper : load Helpers ) { load Helper . initialize ( ) ; } }
public void initialize ( ) { load Helpers = new Linked List < Class Load Helper > ( ) ; load Helpers . add ( new Loading Loader Class Load Helper ( ) ) ; load Helpers . add ( new Simple Class Load Helper ( ) ) ; load Helpers . add ( new Thread Context Class Load Helper ( ) ) ; load Helpers . add ( new Init Thread Context Class Load Helper ( ) ) ; for ( Class Load Helper load Helper : load Helpers ) { load Helper . initialize ( ) ; } }
public void initialize ( ) { load Helpers = new Linked List < Class Load Helper > ( ) ; load Helpers . add ( new Loading Loader Class Load Helper ( ) ) ; load Helpers . add ( new Simple Class Load Helper ( ) ) ; load Helpers . add ( new Thread Context Class Load Helper ( ) ) ; load Helpers . add ( new Init Thread Context Class Load Helper ( ) ) ; for ( Class Load Helper load Helper : load Helpers ) { load Helper . initialize ( ) ; } }
private void write Delay ( ) { try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { fail ( STRING ) ; } }
private void write Delay ( ) { try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { fail ( STRING ) ; } }
private void write Delay ( ) { try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { fail ( STRING ) ; } }
private static void record Compilation ( byte compiler , int BC Length , int MC Length , double comp Time ) { total Methods [ compiler ] ++ ; total MC Length [ compiler ] += MC Length ; total Comp Time [ compiler ] += comp Time ; if ( compiler != JNI COMPILER ) { total BC Length [ compiler ] += BC Length ; double rate = BC Length / comp Time ; if ( VM . fully Booted ) { total Log Of Rates [ compiler ] += Math . log ( rate ) ; total Log Value Methods [ compiler ] ++ ; } } }
int add Vert ( float x , float y , float z ) { int i = nvert ; if ( i >= maxvert ) { if ( vert == null ) { maxvert = NUM ; vert = new float [ maxvert * NUM ] ; } else { maxvert *= NUM ; float nv [ ] = new float [ maxvert * NUM ] ; System . arraycopy ( vert , NUM , nv , NUM , vert . length ) ; vert = nv ; } } i *= NUM ; vert [ i ] = x ; vert [ i + NUM ] = y ; vert [ i + NUM ] = z ; return nvert ++ ; }
protected void paint Cell ( Graphics g , int row , Rectangle row Bounds , List Cell Renderer cell Renderer , List Model data Model , List Selection Model sel Model , int lead Index ) { Object value = data Model . get Element At ( row ) ; boolean cell Has Focus = list . has Focus ( ) && ( row == lead Index ) ; boolean is Selected = sel Model . is Selected Index ( row ) ; Component renderer Component = cell Renderer . get List Cell Renderer Component ( list , value , row , is Selected , cell Has Focus ) ; int cx = row Bounds . x ; int cy = row Bounds . y ; int cw = row Bounds . width ; int ch = row Bounds . height ; if ( is File List ) { int w = Math . min ( cw , renderer Component . get Preferred Size ( ) . width + NUM ) ; if ( ! is Left To Right ) { cx += ( cw - w ) ; } cw = w ; } renderer Pane . paint Component ( g , renderer Component , list , cx , cy , cw , ch , BOOL ) ; }
protected void paint Cell ( Graphics g , int row , Rectangle row Bounds , List Cell Renderer cell Renderer , List Model data Model , List Selection Model sel Model , int lead Index ) { Object value = data Model . get Element At ( row ) ; boolean cell Has Focus = list . has Focus ( ) && ( row == lead Index ) ; boolean is Selected = sel Model . is Selected Index ( row ) ; Component renderer Component = cell Renderer . get List Cell Renderer Component ( list , value , row , is Selected , cell Has Focus ) ; int cx = row Bounds . x ; int cy = row Bounds . y ; int cw = row Bounds . width ; int ch = row Bounds . height ; if ( is File List ) { int w = Math . min ( cw , renderer Component . get Preferred Size ( ) . width + NUM ) ; if ( ! is Left To Right ) { cx += ( cw - w ) ; } cw = w ; } renderer Pane . paint Component ( g , renderer Component , list , cx , cy , cw , ch , BOOL ) ; }
protected void paint Cell ( Graphics g , int row , Rectangle row Bounds , List Cell Renderer cell Renderer , List Model data Model , List Selection Model sel Model , int lead Index ) { Object value = data Model . get Element At ( row ) ; boolean cell Has Focus = list . has Focus ( ) && ( row == lead Index ) ; boolean is Selected = sel Model . is Selected Index ( row ) ; Component renderer Component = cell Renderer . get List Cell Renderer Component ( list , value , row , is Selected , cell Has Focus ) ; int cx = row Bounds . x ; int cy = row Bounds . y ; int cw = row Bounds . width ; int ch = row Bounds . height ; if ( is File List ) { int w = Math . min ( cw , renderer Component . get Preferred Size ( ) . width + NUM ) ; if ( ! is Left To Right ) { cx += ( cw - w ) ; } cw = w ; } renderer Pane . paint Component ( g , renderer Component , list , cx , cy , cw , ch , BOOL ) ; }
protected void paint Cell ( Graphics g , int row , Rectangle row Bounds , List Cell Renderer cell Renderer , List Model data Model , List Selection Model sel Model , int lead Index ) { Object value = data Model . get Element At ( row ) ; boolean cell Has Focus = list . has Focus ( ) && ( row == lead Index ) ; boolean is Selected = sel Model . is Selected Index ( row ) ; Component renderer Component = cell Renderer . get List Cell Renderer Component ( list , value , row , is Selected , cell Has Focus ) ; int cx = row Bounds . x ; int cy = row Bounds . y ; int cw = row Bounds . width ; int ch = row Bounds . height ; if ( is File List ) { int w = Math . min ( cw , renderer Component . get Preferred Size ( ) . width + NUM ) ; if ( ! is Left To Right ) { cx += ( cw - w ) ; } cw = w ; } renderer Pane . paint Component ( g , renderer Component , list , cx , cy , cw , ch , BOOL ) ; }
protected void handle Special Substitution ( String replace , String replace With , int start Pos , String description ) { super . handle Special Substitution ( replace , replace With , start Pos , description ) ; if ( replace . equals ( STRING ) ) { if ( replace With . char At ( NUM ) == STRING ) { error ( STRING , start Pos , description ) ; } dictionary Expression = replace With ; dictionary Chars = Char Set . parse String ( replace With ) ; } }
protected void handle Special Substitution ( String replace , String replace With , int start Pos , String description ) { super . handle Special Substitution ( replace , replace With , start Pos , description ) ; if ( replace . equals ( STRING ) ) { if ( replace With . char At ( NUM ) == STRING ) { error ( STRING , start Pos , description ) ; } dictionary Expression = replace With ; dictionary Chars = Char Set . parse String ( replace With ) ; } }
protected void handle Special Substitution ( String replace , String replace With , int start Pos , String description ) { super . handle Special Substitution ( replace , replace With , start Pos , description ) ; if ( replace . equals ( STRING ) ) { if ( replace With . char At ( NUM ) == STRING ) { error ( STRING , start Pos , description ) ; } dictionary Expression = replace With ; dictionary Chars = Char Set . parse String ( replace With ) ; } }
protected void handle Special Substitution ( String replace , String replace With , int start Pos , String description ) { super . handle Special Substitution ( replace , replace With , start Pos , description ) ; if ( replace . equals ( STRING ) ) { if ( replace With . char At ( NUM ) == STRING ) { error ( STRING , start Pos , description ) ; } dictionary Expression = replace With ; dictionary Chars = Char Set . parse String ( replace With ) ; } }
protected void handle Special Substitution ( String replace , String replace With , int start Pos , String description ) { super . handle Special Substitution ( replace , replace With , start Pos , description ) ; if ( replace . equals ( STRING ) ) { if ( replace With . char At ( NUM ) == STRING ) { error ( STRING , start Pos , description ) ; } dictionary Expression = replace With ; dictionary Chars = Char Set . parse String ( replace With ) ; } }
private void r Move To ( float dx , float dy ) { dx += m Last X ; dy += m Last Y ; m Path . move To ( m Last X = dx , m Last Y = dy ) ; }
private void r Move To ( float dx , float dy ) { dx += m Last X ; dy += m Last Y ; m Path . move To ( m Last X = dx , m Last Y = dy ) ; }
public Parameter Type Variable 2 make Declared Parameter Type Variable ( I Method Binding method Binding , int parameter Index , I Compilation Unit cu ) { if ( method Binding == null ) return null ; Parameter Type Variable 2 cv = make Parameter Type Variable ( method Binding , parameter Index ) ; if ( cv == null ) return null ; cv . set Compilation Unit ( cu ) ; return cv ; }
public Parameter Type Variable 2 make Declared Parameter Type Variable ( I Method Binding method Binding , int parameter Index , I Compilation Unit cu ) { if ( method Binding == null ) return null ; Parameter Type Variable 2 cv = make Parameter Type Variable ( method Binding , parameter Index ) ; if ( cv == null ) return null ; cv . set Compilation Unit ( cu ) ; return cv ; }
public Parameter Type Variable 2 make Declared Parameter Type Variable ( I Method Binding method Binding , int parameter Index , I Compilation Unit cu ) { if ( method Binding == null ) return null ; Parameter Type Variable 2 cv = make Parameter Type Variable ( method Binding , parameter Index ) ; if ( cv == null ) return null ; cv . set Compilation Unit ( cu ) ; return cv ; }
public static byte [ ] gzip ( String input ) { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; GZIP Output Stream gzos = null ; try { gzos = new GZIP Output Stream ( baos ) ; gzos . write ( input . get Bytes ( STRING ) ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } finally { if ( gzos != null ) try { gzos . close ( ) ; } catch ( IO Exception ignored ) { } } return baos . to Byte Array ( ) ; }
public static byte [ ] gzip ( String input ) { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; GZIP Output Stream gzos = null ; try { gzos = new GZIP Output Stream ( baos ) ; gzos . write ( input . get Bytes ( STRING ) ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } finally { if ( gzos != null ) try { gzos . close ( ) ; } catch ( IO Exception ignored ) { } } return baos . to Byte Array ( ) ; }
public static void ensure OSX Compatible ( ) { File nnn AAAAA = new File ( DCIM , STRING ) ; if ( ! ( nnn AAAAA . exists ( ) || nnn AAAAA . mkdirs ( ) ) ) { Log . e ( TAG , STRING + nnn AAAAA . get Path ( ) ) ; } }
public static void ensure OSX Compatible ( ) { File nnn AAAAA = new File ( DCIM , STRING ) ; if ( ! ( nnn AAAAA . exists ( ) || nnn AAAAA . mkdirs ( ) ) ) { Log . e ( TAG , STRING + nnn AAAAA . get Path ( ) ) ; } }
public boolean on Intercept Touch Event ( Motion Event ev ) { @ Suppress Warnings ( STRING ) final boolean debug = BOOL ; if ( debug ) { Log . d ( Launcher . TAG , STRING + ev + STRING + m Dragging ) ; } if ( m Is Accessible Drag ) { return BOOL ; } acquire Velocity Tracker And Add Movement ( ev ) ; final int action = ev . get Action ( ) ; final int [ ] drag Layer Pos = get Clamped Drag Layer Pos ( ev . get X ( ) , ev . get Y ( ) ) ; final int drag Layer X = drag Layer Pos [ NUM ] ; final int drag Layer Y = drag Layer Pos [ NUM ] ; switch ( action ) { case Motion Event . ACTION MOVE : break ; case Motion Event . ACTION DOWN : m Motion Down X = drag Layer X ; m Motion Down Y = drag Layer Y ; m Last Drop Target = null ; break ; case Motion Event . ACTION UP : m Last Touch Up Time = System . current Time Millis ( ) ; if ( m Dragging ) { Point F vec = is Flinging To Delete ( m Drag Object . drag Source ) ; if ( ! Delete Drop Target . supports Drop ( m Drag Object . drag Info ) ) { vec = null ; } if ( vec != null ) { drop On Fling To Delete Target ( drag Layer X , drag Layer Y , vec ) ; } else { drop ( drag Layer X , drag Layer Y ) ; } } end Drag ( ) ; break ; case Motion Event . ACTION CANCEL : cancel Drag ( ) ; break ; } return m Dragging ; }
private static int index Of Segment Name ( String filename ) { int idx = filename . index Of ( STRING , NUM ) ; if ( idx == - NUM ) { idx = filename . index Of ( STRING ) ; } return idx ; }
public void check Is Allocated ( ) { int original Bits = Addressable Memory Manager . read Int Volatile ( this . memory Address + REF COUNT OFFSET ) ; if ( ( original Bits & MAGIC MASK ) != MAGIC NUMBER ) { throw new Illegal State Exception ( STRING + Integer . to Hex String ( original Bits ) ) ; } }
public long file Size ( String path ) throws Illegal State Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception { synchronized ( lock ) { if ( ! connected ) { throw new Illegal State Exception ( STRING ) ; } if ( ! authenticated ) { throw new Illegal State Exception ( STRING ) ; } communication . send FTP Command ( STRING ) ; FTP Reply r = communication . read FTP Reply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new FTP Exception ( r ) ; } communication . send FTP Command ( STRING + path ) ; r = communication . read FTP Reply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new FTP Exception ( r ) ; } String [ ] messages = r . get Messages ( ) ; if ( messages . length != NUM ) { throw new FTP Illegal Reply Exception ( ) ; } else { try { return Long . parse Long ( messages [ NUM ] ) ; } catch ( Throwable t ) { throw new FTP Illegal Reply Exception ( ) ; } } } }
public boolean is Running ( ) { return running ; }
public boolean is Running ( ) { return running ; }
public static void check For Remaining Options ( String [ ] options ) throws Exception { int illegal Options Found = NUM ; String Buffer text = new String Buffer ( ) ; if ( options == null ) { return ; } for ( String option : options ) { if ( option . length ( ) > NUM ) { illegal Options Found ++ ; text . append ( option + STRING ) ; } } if ( illegal Options Found > NUM ) { throw new Exception ( STRING + text ) ; } }
public static void check For Remaining Options ( String [ ] options ) throws Exception { int illegal Options Found = NUM ; String Buffer text = new String Buffer ( ) ; if ( options == null ) { return ; } for ( String option : options ) { if ( option . length ( ) > NUM ) { illegal Options Found ++ ; text . append ( option + STRING ) ; } } if ( illegal Options Found > NUM ) { throw new Exception ( STRING + text ) ; } }
public boolean remove ( Change change ) { Assert . is Not Null ( change ) ; boolean result = f Changes . remove ( change ) ; if ( result ) { change . set Parent ( null ) ; } return result ; }
protected Boolean Val ( boolean b ) { this . b = b ; }
protected Boolean Val ( boolean b ) { this . b = b ; }
protected Boolean Val ( boolean b ) { this . b = b ; }
public boolean is Parent ( File folder , File file ) { if ( folder == null || file == null ) { return BOOL ; } else if ( folder instanceof Shell Folder ) { File parent = file . get Parent File ( ) ; if ( parent != null && parent . equals ( folder ) ) { return BOOL ; } File [ ] children = get Files ( folder , BOOL ) ; for ( File child : children ) { if ( file . equals ( child ) ) { return BOOL ; } } return BOOL ; } else { return folder . equals ( file . get Parent File ( ) ) ; } }
public void remove Positions ( Collection < Integer > positions ) { Array List < Integer > positions List = new Array List < Integer > ( positions ) ; Collections . sort ( positions List ) ; Collections . reverse ( positions List ) ; for ( int position : positions List ) { m Items . remove ( position ) ; } notify Data Set Changed ( ) ; }
public Http Json Post Request ( final Serializable Entity entity ) { this ( Json Serializer . serialize To Json ( entity ) ) ; }
public static Xml Attribute to Xml Attribute ( Class < ? > clazz , Field field ) { J Map j Map = field . get Annotation ( J Map . class ) ; Simply Attribute [ ] target Attributes = to Target Attributes ( j Map . attributes ( ) ) ; String get = null , set = null ; J Map Accessor j Map Accessor = Annotation . get Field Accessors ( clazz , field ) ; if ( ! is Null ( j Map Accessor ) ) { get = j Map Accessor . get ( ) ; set = j Map Accessor . set ( ) ; } return to Xml Attribute ( field . get Name ( ) , new Value ( j Map . value ( ) ) , get , set , target Attributes , j Map . classes ( ) ) ; }
public static final String long To Hex String ( long a ) { String Buffer sb = new String Buffer ( NUM ) ; for ( int i = NUM ; i < NUM ; i ++ ) sb . append ( NIBBLE [ ( int ) ( a > > > ( NUM - NUM * i ) ) & NUM ] ) ; return sb . to String ( ) ; }
public void make Immutable ( ) { mutable = BOOL ; if ( authn Context Class Ref != null ) { authn Context Class Ref = Collections . unmodifiable List ( authn Context Class Ref ) ; } if ( authn Context Decl Ref != null ) { authn Context Decl Ref = Collections . unmodifiable List ( authn Context Decl Ref ) ; } return ; }
protected int [ ] dummy Color Inscribed Data Circle From Yuv Image ( Image Proxy img , int subsample ) { log Wrapper ( STRING ) ; int w = img . get Width ( ) / subsample ; int h = img . get Height ( ) / subsample ; int r = inscribed Circle Radius ( w , h ) ; int len = r * r * NUM ; int [ ] colors = new int [ len ] ; for ( int i = NUM ; i < len ; i ++ ) { int x = i % ( NUM * r ) ; int y = i / ( NUM * r ) ; colors [ i ] = ( NUM << NUM ) | ( ( x & NUM ) << NUM ) | ( ( y & NUM ) << NUM ) ; } return colors ; }
protected int [ ] dummy Color Inscribed Data Circle From Yuv Image ( Image Proxy img , int subsample ) { log Wrapper ( STRING ) ; int w = img . get Width ( ) / subsample ; int h = img . get Height ( ) / subsample ; int r = inscribed Circle Radius ( w , h ) ; int len = r * r * NUM ; int [ ] colors = new int [ len ] ; for ( int i = NUM ; i < len ; i ++ ) { int x = i % ( NUM * r ) ; int y = i / ( NUM * r ) ; colors [ i ] = ( NUM << NUM ) | ( ( x & NUM ) << NUM ) | ( ( y & NUM ) << NUM ) ; } return colors ; }
protected int [ ] dummy Color Inscribed Data Circle From Yuv Image ( Image Proxy img , int subsample ) { log Wrapper ( STRING ) ; int w = img . get Width ( ) / subsample ; int h = img . get Height ( ) / subsample ; int r = inscribed Circle Radius ( w , h ) ; int len = r * r * NUM ; int [ ] colors = new int [ len ] ; for ( int i = NUM ; i < len ; i ++ ) { int x = i % ( NUM * r ) ; int y = i / ( NUM * r ) ; colors [ i ] = ( NUM << NUM ) | ( ( x & NUM ) << NUM ) | ( ( y & NUM ) << NUM ) ; } return colors ; }
protected int [ ] dummy Color Inscribed Data Circle From Yuv Image ( Image Proxy img , int subsample ) { log Wrapper ( STRING ) ; int w = img . get Width ( ) / subsample ; int h = img . get Height ( ) / subsample ; int r = inscribed Circle Radius ( w , h ) ; int len = r * r * NUM ; int [ ] colors = new int [ len ] ; for ( int i = NUM ; i < len ; i ++ ) { int x = i % ( NUM * r ) ; int y = i / ( NUM * r ) ; colors [ i ] = ( NUM << NUM ) | ( ( x & NUM ) << NUM ) | ( ( y & NUM ) << NUM ) ; } return colors ; }
protected int [ ] dummy Color Inscribed Data Circle From Yuv Image ( Image Proxy img , int subsample ) { log Wrapper ( STRING ) ; int w = img . get Width ( ) / subsample ; int h = img . get Height ( ) / subsample ; int r = inscribed Circle Radius ( w , h ) ; int len = r * r * NUM ; int [ ] colors = new int [ len ] ; for ( int i = NUM ; i < len ; i ++ ) { int x = i % ( NUM * r ) ; int y = i / ( NUM * r ) ; colors [ i ] = ( NUM << NUM ) | ( ( x & NUM ) << NUM ) | ( ( y & NUM ) << NUM ) ; } return colors ; }
@ Override public void remove Property Change Listener ( Property Change Listener pcl ) { m pc Support . remove Property Change Listener ( pcl ) ; }
public void rm ( String file Or Dir ) { String Builder buf = new String Builder ( ) ; String command = String . format ( Image Server Dialog Properties . get String ( STRING ) , file Or Dir ) ; send Wait For ( command , default Timeout , prompts , buf ) ; log . debug ( buf . to String ( ) ) ; }
public void rm ( String file Or Dir ) { String Builder buf = new String Builder ( ) ; String command = String . format ( Image Server Dialog Properties . get String ( STRING ) , file Or Dir ) ; send Wait For ( command , default Timeout , prompts , buf ) ; log . debug ( buf . to String ( ) ) ; }
public static String [ ] to Role ( Object o Roles ) throws Page Exception { if ( o Roles instanceof String ) { o Roles = List Util . list To Array Remove Empty ( o Roles . to String ( ) , STRING ) ; } if ( o Roles instanceof Array ) { Array arr Roles = ( Array ) o Roles ; String [ ] roles = new String [ arr Roles . size ( ) ] ; for ( int i = NUM ; i < roles . length ; i ++ ) { roles [ i ] = Caster . to String ( arr Roles . get ( i + NUM , STRING ) ) ; } return roles ; } throw new Application Exception ( STRING ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return MAP FIELD ; default : return null ; } }
private static boolean is Ancestor ( Class Loader first , Class Loader second ) { Class Loader acl = first ; do { acl = acl . get Parent ( ) ; if ( second == acl ) { return BOOL ; } } while ( acl != null ) ; return BOOL ; }
private static boolean is Ancestor ( Class Loader first , Class Loader second ) { Class Loader acl = first ; do { acl = acl . get Parent ( ) ; if ( second == acl ) { return BOOL ; } } while ( acl != null ) ; return BOOL ; }
public void remove Notify ( ) { synchronized ( get Tree Lock ( ) ) { List Peer peer = ( List Peer ) this . peer ; if ( peer != null ) { selected = peer . get Selected Indexes ( ) ; } super . remove Notify ( ) ; } }
public void remove Notify ( ) { synchronized ( get Tree Lock ( ) ) { List Peer peer = ( List Peer ) this . peer ; if ( peer != null ) { selected = peer . get Selected Indexes ( ) ; } super . remove Notify ( ) ; } }
public void remove Notify ( ) { synchronized ( get Tree Lock ( ) ) { List Peer peer = ( List Peer ) this . peer ; if ( peer != null ) { selected = peer . get Selected Indexes ( ) ; } super . remove Notify ( ) ; } }
public void remove Notify ( ) { synchronized ( get Tree Lock ( ) ) { List Peer peer = ( List Peer ) this . peer ; if ( peer != null ) { selected = peer . get Selected Indexes ( ) ; } super . remove Notify ( ) ; } }
public void remove Notify ( ) { synchronized ( get Tree Lock ( ) ) { List Peer peer = ( List Peer ) this . peer ; if ( peer != null ) { selected = peer . get Selected Indexes ( ) ; } super . remove Notify ( ) ; } }
public void remove Notify ( ) { synchronized ( get Tree Lock ( ) ) { List Peer peer = ( List Peer ) this . peer ; if ( peer != null ) { selected = peer . get Selected Indexes ( ) ; } super . remove Notify ( ) ; } }
public J Hex View ( ) { for ( int i = NUM ; i < m colored Ranges . length ; i ++ ) { m colored Ranges [ i ] = new Colored Range Manager ( ) ; } set Focusable ( BOOL ) ; set Layout ( new Border Layout ( ) ) ; set Font ( m font ) ; init Listeners ( ) ; init Hotkeys ( ) ; init Scrollbar ( ) ; img = new Buffered Image ( ( get Width ( ) + NUM ) - m scrollbar . get Width ( ) , ( get Height ( ) + NUM ) - m horizontal Scrollbar . get Height ( ) , Buffered Image . TYPE INT RGB ) ; buffer Graphics = img . get Graphics ( ) ; update Offset View Width ( ) ; set Enabled ( BOOL ) ; }
public void text ( String str , float x , float y ) { if ( text Font == null ) { default Font Or Death ( STRING ) ; } int length = str . length ( ) ; if ( length > text Buffer . length ) { text Buffer = new char [ length + NUM ] ; } str . get Chars ( NUM , length , text Buffer , NUM ) ; float high = NUM ; for ( int i = NUM ; i < length ; i ++ ) { if ( text Buffer [ i ] == STRING ) { high += text Leading ; } } if ( text Align Y == CENTER ) { y += ( text Ascent ( ) - high ) / NUM ; } else if ( text Align Y == TOP ) { y += text Ascent ( ) ; } else if ( text Align Y == BOTTOM ) { y -= text Descent ( ) + high ; } int start = NUM ; int index = NUM ; while ( index < length ) { if ( text Buffer [ index ] == STRING ) { text Line Align Impl ( text Buffer , start , index , x , y ) ; start = index + NUM ; y += text Leading ; } index ++ ; } if ( start < length ) { text Line Align Impl ( text Buffer , start , index , x , y ) ; } }
public D View Cert Csr Pem ( J Frame parent , String title , X509 Certificate cert ) throws Crypto Exception { super ( parent , title , Dialog . Modality Type . DOCUMENT MODAL ) ; this . cert = cert ; init Components ( ) ; }
protected void load raw characters ( String Builder sb ) throws IO Exception { int c = read char ( ) ; for ( ; ; ) { c = read char ( ) ; switch ( c ) { case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 1 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 2 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 3 : continue ; case - NUM : return ; default : if ( ! Ion Token Consts X . is 7 bit Value ( c ) ) { c = read large char sequence ( c ) ; } } if ( Ion UTF 8 . needs Surrogate Encoding ( c ) ) { sb . append ( Ion UTF 8 . high Surrogate ( c ) ) ; c = Ion UTF 8 . low Surrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load raw characters ( String Builder sb ) throws IO Exception { int c = read char ( ) ; for ( ; ; ) { c = read char ( ) ; switch ( c ) { case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 1 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 2 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 3 : continue ; case - NUM : return ; default : if ( ! Ion Token Consts X . is 7 bit Value ( c ) ) { c = read large char sequence ( c ) ; } } if ( Ion UTF 8 . needs Surrogate Encoding ( c ) ) { sb . append ( Ion UTF 8 . high Surrogate ( c ) ) ; c = Ion UTF 8 . low Surrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load raw characters ( String Builder sb ) throws IO Exception { int c = read char ( ) ; for ( ; ; ) { c = read char ( ) ; switch ( c ) { case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 1 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 2 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 3 : continue ; case - NUM : return ; default : if ( ! Ion Token Consts X . is 7 bit Value ( c ) ) { c = read large char sequence ( c ) ; } } if ( Ion UTF 8 . needs Surrogate Encoding ( c ) ) { sb . append ( Ion UTF 8 . high Surrogate ( c ) ) ; c = Ion UTF 8 . low Surrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load raw characters ( String Builder sb ) throws IO Exception { int c = read char ( ) ; for ( ; ; ) { c = read char ( ) ; switch ( c ) { case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 1 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 2 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 3 : continue ; case - NUM : return ; default : if ( ! Ion Token Consts X . is 7 bit Value ( c ) ) { c = read large char sequence ( c ) ; } } if ( Ion UTF 8 . needs Surrogate Encoding ( c ) ) { sb . append ( Ion UTF 8 . high Surrogate ( c ) ) ; c = Ion UTF 8 . low Surrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load raw characters ( String Builder sb ) throws IO Exception { int c = read char ( ) ; for ( ; ; ) { c = read char ( ) ; switch ( c ) { case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 1 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 2 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 3 : continue ; case - NUM : return ; default : if ( ! Ion Token Consts X . is 7 bit Value ( c ) ) { c = read large char sequence ( c ) ; } } if ( Ion UTF 8 . needs Surrogate Encoding ( c ) ) { sb . append ( Ion UTF 8 . high Surrogate ( c ) ) ; c = Ion UTF 8 . low Surrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load raw characters ( String Builder sb ) throws IO Exception { int c = read char ( ) ; for ( ; ; ) { c = read char ( ) ; switch ( c ) { case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 1 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 2 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 3 : continue ; case - NUM : return ; default : if ( ! Ion Token Consts X . is 7 bit Value ( c ) ) { c = read large char sequence ( c ) ; } } if ( Ion UTF 8 . needs Surrogate Encoding ( c ) ) { sb . append ( Ion UTF 8 . high Surrogate ( c ) ) ; c = Ion UTF 8 . low Surrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load raw characters ( String Builder sb ) throws IO Exception { int c = read char ( ) ; for ( ; ; ) { c = read char ( ) ; switch ( c ) { case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 1 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 2 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 3 : continue ; case - NUM : return ; default : if ( ! Ion Token Consts X . is 7 bit Value ( c ) ) { c = read large char sequence ( c ) ; } } if ( Ion UTF 8 . needs Surrogate Encoding ( c ) ) { sb . append ( Ion UTF 8 . high Surrogate ( c ) ) ; c = Ion UTF 8 . low Surrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load raw characters ( String Builder sb ) throws IO Exception { int c = read char ( ) ; for ( ; ; ) { c = read char ( ) ; switch ( c ) { case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 1 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 2 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 3 : continue ; case - NUM : return ; default : if ( ! Ion Token Consts X . is 7 bit Value ( c ) ) { c = read large char sequence ( c ) ; } } if ( Ion UTF 8 . needs Surrogate Encoding ( c ) ) { sb . append ( Ion UTF 8 . high Surrogate ( c ) ) ; c = Ion UTF 8 . low Surrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load raw characters ( String Builder sb ) throws IO Exception { int c = read char ( ) ; for ( ; ; ) { c = read char ( ) ; switch ( c ) { case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 1 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 2 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 3 : continue ; case - NUM : return ; default : if ( ! Ion Token Consts X . is 7 bit Value ( c ) ) { c = read large char sequence ( c ) ; } } if ( Ion UTF 8 . needs Surrogate Encoding ( c ) ) { sb . append ( Ion UTF 8 . high Surrogate ( c ) ) ; c = Ion UTF 8 . low Surrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load raw characters ( String Builder sb ) throws IO Exception { int c = read char ( ) ; for ( ; ; ) { c = read char ( ) ; switch ( c ) { case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 1 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 2 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 3 : continue ; case - NUM : return ; default : if ( ! Ion Token Consts X . is 7 bit Value ( c ) ) { c = read large char sequence ( c ) ; } } if ( Ion UTF 8 . needs Surrogate Encoding ( c ) ) { sb . append ( Ion UTF 8 . high Surrogate ( c ) ) ; c = Ion UTF 8 . low Surrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load raw characters ( String Builder sb ) throws IO Exception { int c = read char ( ) ; for ( ; ; ) { c = read char ( ) ; switch ( c ) { case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 1 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 2 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 3 : continue ; case - NUM : return ; default : if ( ! Ion Token Consts X . is 7 bit Value ( c ) ) { c = read large char sequence ( c ) ; } } if ( Ion UTF 8 . needs Surrogate Encoding ( c ) ) { sb . append ( Ion UTF 8 . high Surrogate ( c ) ) ; c = Ion UTF 8 . low Surrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load raw characters ( String Builder sb ) throws IO Exception { int c = read char ( ) ; for ( ; ; ) { c = read char ( ) ; switch ( c ) { case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 1 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 2 : case Character Sequence . CHAR SEQ ESCAPED NEWLINE SEQUENCE 3 : continue ; case - NUM : return ; default : if ( ! Ion Token Consts X . is 7 bit Value ( c ) ) { c = read large char sequence ( c ) ; } } if ( Ion UTF 8 . needs Surrogate Encoding ( c ) ) { sb . append ( Ion UTF 8 . high Surrogate ( c ) ) ; c = Ion UTF 8 . low Surrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
public static Gradient Paint make Red Paint ( final double width , final double height ) { return new Gradient Paint ( NUM , NUM , new Color ( NUM , NUM , NUM ) , ( float ) width / NUM , ( float ) height / NUM , new Color ( NUM , NUM , NUM ) , BOOL ) ; }
@ Nullable private static String read Xml File ( @ Nullable URL url ) { String xml File Content = null ; if ( url != null ) { try { xml File Content = Url Util . load Text ( url ) ; } catch ( IO Exception e ) { LOG . error ( e ) ; } } return xml File Content ; }
@ Nullable private static String read Xml File ( @ Nullable URL url ) { String xml File Content = null ; if ( url != null ) { try { xml File Content = Url Util . load Text ( url ) ; } catch ( IO Exception e ) { LOG . error ( e ) ; } } return xml File Content ; }
public void remove Event Listener ( Rcs Service Registration Listener listener ) throws Rcs Service Not Available Exception , Rcs Generic Exception { if ( m Api == null ) { throw new Rcs Service Not Available Exception ( ) ; } try { Weak Reference < I Rcs Service Registration Listener > weak Ref = m Registration Listeners . remove ( listener ) ; if ( weak Ref == null ) { return ; } I Rcs Service Registration Listener rcs Listener = weak Ref . get ( ) ; if ( rcs Listener != null ) { call Api Method ( STRING , rcs Listener , I Rcs Service Registration Listener . class ) ; } } catch ( Exception e ) { throw new Rcs Generic Exception ( e ) ; } }
private void select File ( int title Msg , int button Msg , String settings Name , String default Dir , int dialog , int result ) { set Auto Mode ( Auto Mode . OFF ) ; String action = STRING ; Intent i = new Intent ( action ) ; String current File = settings . get String ( settings Name , STRING ) ; String sep = File . separator ; if ( ! current File . contains ( sep ) ) current File = Environment . get External Storage Directory ( ) + sep + default Dir + sep + current File ; i . set Data ( Uri . from File ( new File ( current File ) ) ) ; i . put Extra ( STRING , get String ( title Msg ) ) ; i . put Extra ( STRING , get String ( button Msg ) ) ; try { start Activity For Result ( i , result ) ; } catch ( Activity Not Found Exception e ) { remove Dialog ( dialog ) ; show Dialog ( dialog ) ; } }
public static Insert Into Clause create ( String stream Name , String [ ] columns , Stream Selector stream Selector ) { if ( stream Selector == Stream Selector . RSTREAM ISTREAM BOTH ) { throw new Illegal Argument Exception ( STRING ) ; } return new Insert Into Clause ( stream Name , Arrays . as List ( columns ) , stream Selector ) ; }
public static String normalize Path ( String path ) { return path . replace ( File . separator Char , STRING ) ; }
public void delete Selection ( Array List < Integer > nodes ) { for ( int i = NUM ; i < nodes . size ( ) ; i ++ ) { for ( int j = i + NUM ; j < nodes . size ( ) ; j ++ ) { if ( nodes . get ( i ) > nodes . get ( j ) ) { int h = nodes . get ( i ) ; nodes . set ( i , nodes . get ( j ) ) ; nodes . set ( j , h ) ; } } } if ( m b Needs Undo Action ) { add Undo Action ( new Delete Selection Action ( nodes ) ) ; } boolean b Needs Undo Action = m b Needs Undo Action ; m b Needs Undo Action = BOOL ; try { for ( int i Node = nodes . size ( ) - NUM ; i Node >= NUM ; i Node -- ) { delete Node ( nodes . get ( i Node ) ) ; } } catch ( Exception e ) { e . print Stack Trace ( ) ; } m b Needs Undo Action = b Needs Undo Action ; }
public void add Update Listener ( Animator Update Listener listener ) { if ( m Update Listeners == null ) { m Update Listeners = new Array List < Animator Update Listener > ( ) ; } m Update Listeners . add ( listener ) ; }
public void add Update Listener ( Animator Update Listener listener ) { if ( m Update Listeners == null ) { m Update Listeners = new Array List < Animator Update Listener > ( ) ; } m Update Listeners . add ( listener ) ; }
public void add Update Listener ( Animator Update Listener listener ) { if ( m Update Listeners == null ) { m Update Listeners = new Array List < Animator Update Listener > ( ) ; } m Update Listeners . add ( listener ) ; }
public void add Update Listener ( Animator Update Listener listener ) { if ( m Update Listeners == null ) { m Update Listeners = new Array List < Animator Update Listener > ( ) ; } m Update Listeners . add ( listener ) ; }
public void add Update Listener ( Animator Update Listener listener ) { if ( m Update Listeners == null ) { m Update Listeners = new Array List < Animator Update Listener > ( ) ; } m Update Listeners . add ( listener ) ; }
public void add Update Listener ( Animator Update Listener listener ) { if ( m Update Listeners == null ) { m Update Listeners = new Array List < Animator Update Listener > ( ) ; } m Update Listeners . add ( listener ) ; }
public void add Update Listener ( Animator Update Listener listener ) { if ( m Update Listeners == null ) { m Update Listeners = new Array List < Animator Update Listener > ( ) ; } m Update Listeners . add ( listener ) ; }
public static String grab Name ( String signature ) { Matcher matcher = sig RE . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . group Count ( ) != NUM ) logger . error ( STRING , signature ) ; return matcher . group ( NUM ) ; }
public static Calendar create Calendar Instance ( Date date ) { Calendar calendar = new Gregorian Calendar ( ) ; calendar . set Time ( date ) ; clear Time Of Day ( calendar ) ; return calendar ; }
public JSON Array add ( String value ) { values . add ( JSON . value ( value ) ) ; return this ; }
public static int next Set Bit ( long v , int start ) { if ( start >= Long . SIZE ) { return - NUM ; } long cur = v & ( LONG ALL BITS << start ) ; if ( cur == NUM ) { return - NUM ; } return Long . number Of Trailing Zeros ( cur ) ; }
public static void do Fake Entity Explosion ( Entity Player entityplayer ) { World world = entityplayer . world Obj ; world . spawn Particle ( STRING , entityplayer . pos X , entityplayer . pos Y , entityplayer . pos Z , NUM , NUM , NUM ) ; world . play Sound At Entity ( entityplayer , STRING , NUM , NUM ) ; }
public static void do Fake Entity Explosion ( Entity Player entityplayer ) { World world = entityplayer . world Obj ; world . spawn Particle ( STRING , entityplayer . pos X , entityplayer . pos Y , entityplayer . pos Z , NUM , NUM , NUM ) ; world . play Sound At Entity ( entityplayer , STRING , NUM , NUM ) ; }
public static void do Fake Entity Explosion ( Entity Player entityplayer ) { World world = entityplayer . world Obj ; world . spawn Particle ( STRING , entityplayer . pos X , entityplayer . pos Y , entityplayer . pos Z , NUM , NUM , NUM ) ; world . play Sound At Entity ( entityplayer , STRING , NUM , NUM ) ; }
public Weak Table ( ) { if ( DEBUG != null ) DEBUG . println ( STRING ) ; table = new Hash Map ( ) ; ref Queue = new Reference Queue ( ) ; }
public String dump ( ) { String Builder buffer = new String Builder ( ) ; for ( int row = NUM ; row < get Row Count ( ) ; row ++ ) { buffer . append ( timestamps [ row ] ) ; buffer . append ( STRING ) ; for ( int ds Index = NUM ; ds Index < get Column Count ( ) ; ds Index ++ ) { buffer . append ( Util . format Double ( values [ ds Index ] [ row ] , BOOL ) ) ; buffer . append ( STRING ) ; } buffer . append ( STRING ) ; } return buffer . to String ( ) ; }
public boolean contains Instruction ( Instruction Handle handle ) { Iterator < Instruction Handle > i = instruction Iterator ( ) ; while ( i . has Next ( ) ) { if ( i . next ( ) == handle ) { return BOOL ; } } return BOOL ; }
public boolean contains Instruction ( Instruction Handle handle ) { Iterator < Instruction Handle > i = instruction Iterator ( ) ; while ( i . has Next ( ) ) { if ( i . next ( ) == handle ) { return BOOL ; } } return BOOL ; }
public static void skip Fully ( Input Stream in , long skip ) throws IO Exception { try { while ( skip > NUM ) { long skipped = in . skip ( skip ) ; if ( skipped <= NUM ) { throw new EOF Exception ( ) ; } skip -= skipped ; } } catch ( Exception e ) { throw Db Exception . convert To IO Exception ( e ) ; } }
private byte [ ] decode ( Der Input Stream in ) throws IO Exception { Der Value val = in . get Der Value ( ) ; byte [ ] der Encoding = val . to Byte Array ( ) ; der Encoding [ NUM ] = Der Value . tag Set Of ; Der Input Stream der In = new Der Input Stream ( der Encoding ) ; Der Value [ ] der Vals = der In . get Set ( NUM , BOOL ) ; PKCS 9 Attribute attrib ; Object Identifier oid ; boolean reuse Encoding = BOOL ; for ( int i = NUM ; i < der Vals . length ; i ++ ) { try { attrib = new PKCS 9 Attribute ( der Vals [ i ] ) ; } catch ( Parsing Exception e ) { if ( ignore Unsupported Attributes ) { reuse Encoding = BOOL ; continue ; } else { throw e ; } } oid = attrib . get OID ( ) ; if ( attributes . get ( oid ) != null ) throw new IO Exception ( STRING + oid ) ; if ( permitted Attributes != null && ! permitted Attributes . contains Key ( oid ) ) throw new IO Exception ( STRING + oid + STRING ) ; attributes . put ( oid , attrib ) ; } return reuse Encoding ? der Encoding : generate Der Encoding ( ) ; }
public int attributes Size ( ) { return attributes . size ( ) ; }
public boolean create Bookmark Rollback Step ( String step Id ) { Workflow Step Completer . step Executing ( step Id ) ; log . info ( String . format ( STRING , step Id ) ) ; Workflow Step Completer . step Succeded ( step Id ) ; return BOOL ; }
public boolean create Bookmark Rollback Step ( String step Id ) { Workflow Step Completer . step Executing ( step Id ) ; log . info ( String . format ( STRING , step Id ) ) ; Workflow Step Completer . step Succeded ( step Id ) ; return BOOL ; }
public boolean create Bookmark Rollback Step ( String step Id ) { Workflow Step Completer . step Executing ( step Id ) ; log . info ( String . format ( STRING , step Id ) ) ; Workflow Step Completer . step Succeded ( step Id ) ; return BOOL ; }
public synchronized void remove Incremental Classifier Listener ( Incremental Classifier Listener cl ) { m incremental Classifier Listeners . remove ( cl ) ; }
void unexecute NS Decls ( Transformer Impl transformer ) throws Transformer Exception { unexecute NS Decls ( transformer , null ) ; }
void unexecute NS Decls ( Transformer Impl transformer ) throws Transformer Exception { unexecute NS Decls ( transformer , null ) ; }
public static Output Stream left Shift ( Output Stream self , Input Stream in ) throws IO Exception { byte [ ] buf = new byte [ NUM ] ; while ( BOOL ) { int count = in . read ( buf , NUM , buf . length ) ; if ( count == - NUM ) break ; if ( count == NUM ) { Thread . yield ( ) ; continue ; } self . write ( buf , NUM , count ) ; } self . flush ( ) ; return self ; }
private void add Exclude Class Node ( Document Node inline Document Node , Node component Root ) { Meta Data Node inline Exclude Node = new Meta Data Node ( component Root . get Namespace ( ) , component Root . get Local Part ( ) , NUM ) ; inline Exclude Node . image = component Root . image ; CDATA Node exclude Text Node = new CDATA Node ( ) ; exclude Text Node . image = STRING ; inline Exclude Node . add Child ( exclude Text Node ) ; inline Document Node . add Child ( inline Exclude Node ) ; }
private void assign Cluster Nums ( int [ ] cl num ) throws Exception { if ( m children != null && m children . size ( ) < NUM ) { throw new Exception ( STRING ) ; } m cluster Num = cl num [ NUM ] ; cl num [ NUM ] ++ ; if ( m children != null ) { for ( int i = NUM ; i < m children . size ( ) ; i ++ ) { C Node child = m children . get ( i ) ; child . assign Cluster Nums ( cl num ) ; } } }
public View create ( Element elem ) { Document doc = elem . get Document ( ) ; Object i18 n Flag = doc . get Property ( STRING ) ; if ( ( i18 n Flag != null ) && i18 n Flag . equals ( Boolean . TRUE ) ) { return create I 18 N ( elem ) ; } else { return new Wrapped Plain View ( elem ) ; } }
public void add ( final Extension < ? , ? > extension ) { if ( extension . get Extension Type ( ) != Extension . Extension Type . IMMUTABLE && extension . get Extension Type ( ) != Extension . Extension Type . MUTABLE ) { return ; } add ( new Extension Info ( extension ) , extension . get Extension Type ( ) ) ; }
final void send Help ( ) { Array List < String > help = help ( ) ; if ( help . is Empty ( ) ) { return ; } Xmpp Msg msg = new Xmpp Msg ( ) ; msg . add String Array ( help . to Array ( new String [ help . size ( ) ] ) ) ; send ( msg ) ; }
final void send Help ( ) { Array List < String > help = help ( ) ; if ( help . is Empty ( ) ) { return ; } Xmpp Msg msg = new Xmpp Msg ( ) ; msg . add String Array ( help . to Array ( new String [ help . size ( ) ] ) ) ; send ( msg ) ; }
final void send Help ( ) { Array List < String > help = help ( ) ; if ( help . is Empty ( ) ) { return ; } Xmpp Msg msg = new Xmpp Msg ( ) ; msg . add String Array ( help . to Array ( new String [ help . size ( ) ] ) ) ; send ( msg ) ; }
public void add Memory Listener ( final I Memory Listener listener ) { Preconditions . check Not Null ( listener , STRING ) ; m listeners . add ( listener ) ; }
private synchronized void write To Output Stream ( int one Byte ) { if ( m Closed ) { return ; } try { m Output Stream . write ( one Byte ) ; report Decoded Size If Applicable ( ) ; } catch ( IO Exception e ) { handle IO Exception Writing To Stream ( e ) ; } }
private synchronized void write To Output Stream ( int one Byte ) { if ( m Closed ) { return ; } try { m Output Stream . write ( one Byte ) ; report Decoded Size If Applicable ( ) ; } catch ( IO Exception e ) { handle IO Exception Writing To Stream ( e ) ; } }
private synchronized void write To Output Stream ( int one Byte ) { if ( m Closed ) { return ; } try { m Output Stream . write ( one Byte ) ; report Decoded Size If Applicable ( ) ; } catch ( IO Exception e ) { handle IO Exception Writing To Stream ( e ) ; } }
private synchronized void write To Output Stream ( int one Byte ) { if ( m Closed ) { return ; } try { m Output Stream . write ( one Byte ) ; report Decoded Size If Applicable ( ) ; } catch ( IO Exception e ) { handle IO Exception Writing To Stream ( e ) ; } }
private synchronized void write To Output Stream ( int one Byte ) { if ( m Closed ) { return ; } try { m Output Stream . write ( one Byte ) ; report Decoded Size If Applicable ( ) ; } catch ( IO Exception e ) { handle IO Exception Writing To Stream ( e ) ; } }
private synchronized void write To Output Stream ( int one Byte ) { if ( m Closed ) { return ; } try { m Output Stream . write ( one Byte ) ; report Decoded Size If Applicable ( ) ; } catch ( IO Exception e ) { handle IO Exception Writing To Stream ( e ) ; } }
public void add Criteria ( Criteria other Criteria ) { if ( other Criteria instanceof Advanced Criteria || other Criteria instanceof Criterion ) { throw new Illegal Argument Exception ( STRING + STRING ) ; } Map other Map = other Criteria . get Values ( ) ; Set other Keys = other Map . key Set ( ) ; for ( Iterator i = other Keys . iterator ( ) ; i . has Next ( ) ; ) { String field = ( String ) i . next ( ) ; Object value = other Map . get ( field ) ; JSO Helper . set Attribute ( js Obj , field , value ) ; } }
protected boolean update Attachment Point ( ) { boolean moved = BOOL ; this . old A Ps = attachment Points ; if ( attachment Points == null || attachment Points . is Empty ( ) ) return BOOL ; List < Attachment Point > ap List = new Array List < Attachment Point > ( ) ; if ( attachment Points != null ) ap List . add All ( attachment Points ) ; Map < Long , Attachment Point > new Map = get AP Map ( ap List ) ; if ( new Map == null || new Map . size ( ) != ap List . size ( ) ) { moved = BOOL ; } if ( moved ) { log . info ( STRING , attachment Points , new Map ) ; List < Attachment Point > new AP List = new Array List < Attachment Point > ( ) ; if ( new Map != null ) new AP List . add All ( new Map . values ( ) ) ; this . attachment Points = new AP List ; } return moved ; }
protected boolean update Attachment Point ( ) { boolean moved = BOOL ; this . old A Ps = attachment Points ; if ( attachment Points == null || attachment Points . is Empty ( ) ) return BOOL ; List < Attachment Point > ap List = new Array List < Attachment Point > ( ) ; if ( attachment Points != null ) ap List . add All ( attachment Points ) ; Map < Long , Attachment Point > new Map = get AP Map ( ap List ) ; if ( new Map == null || new Map . size ( ) != ap List . size ( ) ) { moved = BOOL ; } if ( moved ) { log . info ( STRING , attachment Points , new Map ) ; List < Attachment Point > new AP List = new Array List < Attachment Point > ( ) ; if ( new Map != null ) new AP List . add All ( new Map . values ( ) ) ; this . attachment Points = new AP List ; } return moved ; }
protected boolean update Attachment Point ( ) { boolean moved = BOOL ; this . old A Ps = attachment Points ; if ( attachment Points == null || attachment Points . is Empty ( ) ) return BOOL ; List < Attachment Point > ap List = new Array List < Attachment Point > ( ) ; if ( attachment Points != null ) ap List . add All ( attachment Points ) ; Map < Long , Attachment Point > new Map = get AP Map ( ap List ) ; if ( new Map == null || new Map . size ( ) != ap List . size ( ) ) { moved = BOOL ; } if ( moved ) { log . info ( STRING , attachment Points , new Map ) ; List < Attachment Point > new AP List = new Array List < Attachment Point > ( ) ; if ( new Map != null ) new AP List . add All ( new Map . values ( ) ) ; this . attachment Points = new AP List ; } return moved ; }
protected boolean update Attachment Point ( ) { boolean moved = BOOL ; this . old A Ps = attachment Points ; if ( attachment Points == null || attachment Points . is Empty ( ) ) return BOOL ; List < Attachment Point > ap List = new Array List < Attachment Point > ( ) ; if ( attachment Points != null ) ap List . add All ( attachment Points ) ; Map < Long , Attachment Point > new Map = get AP Map ( ap List ) ; if ( new Map == null || new Map . size ( ) != ap List . size ( ) ) { moved = BOOL ; } if ( moved ) { log . info ( STRING , attachment Points , new Map ) ; List < Attachment Point > new AP List = new Array List < Attachment Point > ( ) ; if ( new Map != null ) new AP List . add All ( new Map . values ( ) ) ; this . attachment Points = new AP List ; } return moved ; }
@ Override public Iterator < Jdbc Row > iterator ( ) { return row List . iterator ( ) ; }
@ Override public Iterator < Jdbc Row > iterator ( ) { return row List . iterator ( ) ; }
public boolean move To Next ( ) { try { return rs . next ( ) ; } catch ( SQL Exception e ) { LOG . warn ( STRING , e ) ; } return BOOL ; }
public boolean move To Next ( ) { try { return rs . next ( ) ; } catch ( SQL Exception e ) { LOG . warn ( STRING , e ) ; } return BOOL ; }
private void add Internal Header Fields ( String name , String value ) { String key = name . to Upper Case ( ) ; Vector < String > v = get Headers ( key ) ; if ( v == null ) { v = new Vector < > ( ) ; m Header Fields . put ( key , v ) ; } if ( value != null ) { v . add ( value ) ; } else { m Header Fields . remove ( key ) ; } }
public void add Child ( Base Assembly Node child Node ) { child Node . parent Node = this ; child Nodes . add ( child Node ) ; }
@ Override public void write ( Data Output out ) throws IO Exception { out . write Long ( duration ) ; out . write Int ( get Length ( ) ) ; for ( int i = NUM ; i < quantized Coeffs . length ; i ++ ) { out . write Short ( quantized Coeffs [ i ] ) ; } out . write ( quantized Residual ) ; }
public void add Firmware Update Callback ( One Sheeld Firmware Update Callback firmware Update Callback ) { if ( firmware Update Callback != null && ! firmware Update Callbacks . contains ( firmware Update Callback ) ) firmware Update Callbacks . add ( firmware Update Callback ) ; }
double percent To Aprox Y ( Rectangle 2 D . Double area ) { return percent Y * area . get Height ( ) ; }
public void write ( String record ) throws IO Exception { Chunk ch = current Chunk ( ) ; boolean has New Line = record . ends With ( STRING ) ; int raw Bytes To Write = record . length ( ) ; if ( ! has New Line ) { raw Bytes To Write += NUM ; } if ( ( ch . raw Bytes + raw Bytes To Write ) > chunk Threshold ) { finish Chunk ( ) ; init Chunk Writer ( ) ; Chunk new Ch = new Chunk ( ) ; new Ch . first Offset = ch . first Offset + ch . num Records ; new Ch . byte Offset = ch . byte Offset + ch . compressed Byte Length ; chunks . add ( new Ch ) ; ch = new Ch ; } writer . append ( record ) ; if ( ! has New Line ) { writer . new Line ( ) ; } ch . raw Bytes += raw Bytes To Write ; ch . num Records ++ ; }
public void write ( String record ) throws IO Exception { Chunk ch = current Chunk ( ) ; boolean has New Line = record . ends With ( STRING ) ; int raw Bytes To Write = record . length ( ) ; if ( ! has New Line ) { raw Bytes To Write += NUM ; } if ( ( ch . raw Bytes + raw Bytes To Write ) > chunk Threshold ) { finish Chunk ( ) ; init Chunk Writer ( ) ; Chunk new Ch = new Chunk ( ) ; new Ch . first Offset = ch . first Offset + ch . num Records ; new Ch . byte Offset = ch . byte Offset + ch . compressed Byte Length ; chunks . add ( new Ch ) ; ch = new Ch ; } writer . append ( record ) ; if ( ! has New Line ) { writer . new Line ( ) ; } ch . raw Bytes += raw Bytes To Write ; ch . num Records ++ ; }
public static String format ( Date date ) { Date Format date Format = new Simple Date Format ( Date Field . FORMAT ) ; return date == null ? null : date Format . format ( date ) ; }
public int size ( ) { return m map . size ( ) ; }
public int size ( ) { return m map . size ( ) ; }
public int size ( ) { return m map . size ( ) ; }
public int size ( ) { return m map . size ( ) ; }
public int size ( ) { return m map . size ( ) ; }
public int size ( ) { return m map . size ( ) ; }
public Closeable Animated Bitmap ( List < Bitmap > bitmaps , List < Integer > durations , Resource Releaser < Bitmap > resource Releaser ) { Preconditions . check Not Null ( bitmaps ) ; Preconditions . check State ( bitmaps . size ( ) >= NUM , STRING ) ; m Bitmaps = new Array List < > ( bitmaps . size ( ) ) ; m Bitmap References = new Array List < > ( bitmaps . size ( ) ) ; for ( Bitmap bitmap : bitmaps ) { m Bitmap References . add ( Closeable Reference . of ( bitmap , resource Releaser ) ) ; m Bitmaps . add ( bitmap ) ; } m Durations = Preconditions . check Not Null ( durations ) ; Preconditions . check State ( m Durations . size ( ) == m Bitmaps . size ( ) , STRING ) ; }
private Map < Byte , Long List > pick Top Social Proofs ( Small Array Based Long To Double Map [ ] social Proofs , byte [ ] valid Social Proofs , int max Social Proof Size ) { Map < Byte , Long List > results = new Hash Map < Byte , Long List > ( ) ; int length = valid Social Proofs . length ; for ( int i = NUM ; i < length ; i ++ ) { Small Array Based Long To Double Map social Proof = social Proofs [ valid Social Proofs [ i ] ] ; if ( social Proof != null ) { if ( social Proof . size ( ) > NUM ) { social Proof . sort ( ) ; } social Proof . trim ( max Social Proof Size ) ; results . put ( ( byte ) i , new Long Array List ( social Proof . keys ( ) ) ) ; } } return results ; }
private void add Neurons ( ) { double number = Utils . double Parsable ( num Neurons ) ; if ( ! Double . is Na N ( number ) ) { number = ( int ) number ; Network net = network Panel . get Network ( ) ; for ( int i = NUM ; i < number ; i ++ ) { added Neurons . add ( new Neuron ( net , base Neuron ) ) ; } network Panel . add Neurons To Panel ( added Neurons , select Layout . get Current Layout ( ) ) ; } }
private void validate Names ( Label label , Parameter parameter ) throws Exception { String [ ] options = label . get Names ( ) ; String name = parameter . get Name ( ) ; if ( ! contains ( options , name ) ) { String require = label . get Name ( ) ; if ( name != require ) { if ( name == null || require == null ) { throw new Constructor Exception ( STRING , label , name , parameter ) ; } if ( ! name . equals ( require ) ) { throw new Constructor Exception ( STRING , label , name , parameter ) ; } } } }
private void validate Names ( Label label , Parameter parameter ) throws Exception { String [ ] options = label . get Names ( ) ; String name = parameter . get Name ( ) ; if ( ! contains ( options , name ) ) { String require = label . get Name ( ) ; if ( name != require ) { if ( name == null || require == null ) { throw new Constructor Exception ( STRING , label , name , parameter ) ; } if ( ! name . equals ( require ) ) { throw new Constructor Exception ( STRING , label , name , parameter ) ; } } } }
private void validate Names ( Label label , Parameter parameter ) throws Exception { String [ ] options = label . get Names ( ) ; String name = parameter . get Name ( ) ; if ( ! contains ( options , name ) ) { String require = label . get Name ( ) ; if ( name != require ) { if ( name == null || require == null ) { throw new Constructor Exception ( STRING , label , name , parameter ) ; } if ( ! name . equals ( require ) ) { throw new Constructor Exception ( STRING , label , name , parameter ) ; } } } }
private void clear Dictionary Cache ( ) { Map < String , Dictionary > dictionary Caches = surrogate Key Gen . get Dictionary Caches ( ) ; List < Dictionary > reverse Dictionaries = new Array List < > ( dictionary Caches . values ( ) ) ; for ( int i = NUM ; i < reverse Dictionaries . size ( ) ; i ++ ) { Dictionary dictionary = reverse Dictionaries . get ( i ) ; dictionary . clear ( ) ; } }
private void clear Dictionary Cache ( ) { Map < String , Dictionary > dictionary Caches = surrogate Key Gen . get Dictionary Caches ( ) ; List < Dictionary > reverse Dictionaries = new Array List < > ( dictionary Caches . values ( ) ) ; for ( int i = NUM ; i < reverse Dictionaries . size ( ) ; i ++ ) { Dictionary dictionary = reverse Dictionaries . get ( i ) ; dictionary . clear ( ) ; } }
public boolean ends With ( final String str ) { if ( str == null ) { return BOOL ; } final int len = str . length ( ) ; if ( len == NUM ) { return BOOL ; } if ( len > size ) { return BOOL ; } int pos = size - len ; for ( int i = NUM ; i < len ; i ++ , pos ++ ) { if ( buffer [ pos ] != str . char At ( i ) ) { return BOOL ; } } return BOOL ; }
public boolean ends With ( final String str ) { if ( str == null ) { return BOOL ; } final int len = str . length ( ) ; if ( len == NUM ) { return BOOL ; } if ( len > size ) { return BOOL ; } int pos = size - len ; for ( int i = NUM ; i < len ; i ++ , pos ++ ) { if ( buffer [ pos ] != str . char At ( i ) ) { return BOOL ; } } return BOOL ; }
public int [ ] value Array ( int [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new int [ count ] ; } System . arraycopy ( values , NUM , array , NUM , count ) ; return array ; }
public int [ ] value Array ( int [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new int [ count ] ; } System . arraycopy ( values , NUM , array , NUM , count ) ; return array ; }
public int [ ] value Array ( int [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new int [ count ] ; } System . arraycopy ( values , NUM , array , NUM , count ) ; return array ; }
public Object apply ( String source , int line No , int column No , Object func Body , Vector param Names , Vector arguments ) throws BSF Exception { Object object = eval ( source , line No , column No , func Body ) ; if ( object instanceof Closure ) { Closure closure = ( Closure ) object ; return closure . call ( arguments . to Array ( ) ) ; } return object ; }
@ Override public void on Draw ( Canvas canvas ) { m Last Draw Time Ms = System . current Time Millis ( ) ; super . on Draw ( canvas ) ; }
@ Override public void on Draw ( Canvas canvas ) { m Last Draw Time Ms = System . current Time Millis ( ) ; super . on Draw ( canvas ) ; }
@ Override public Partition Key Group delete Partition Key Group ( Partition Key Group Key partition Key Group Key ) { partition Key Group Helper . validate Partition Key Group Key ( partition Key Group Key ) ; Partition Key Group Entity partition Key Group Entity = partition Key Group Dao Helper . get Partition Key Group Entity ( partition Key Group Key ) ; if ( business Object Format Dao . get Business Object Format Count ( partition Key Group Entity ) > NUM ) { throw new Illegal Argument Exception ( String . format ( STRING , partition Key Group Key . get Partition Key Group Name ( ) ) ) ; } partition Key Group Dao . delete ( partition Key Group Entity ) ; return create Partition Key Group From Entity ( partition Key Group Entity ) ; }
private boolean evict ( ) { while ( is Overflow ( ) ) { Node < K , V > node = sentinel . get Next ( ) ; if ( node == sentinel ) { return BOOL ; } else if ( policy . on Evict ( this , node ) ) { if ( data . remove ( node . get Key ( ) , new Identity ( node ) ) ) { length . decrement And Get ( ) ; node . remove ( ) ; listener . on Eviction ( node . get Key ( ) , node . get Value ( ) ) ; return BOOL ; } } } return BOOL ; }
public Zone Offset Transition next Transition ( Instant instant ) { if ( savings Instant Transitions . length == NUM ) { return null ; } long epoch Sec = instant . get Epoch Second ( ) ; if ( epoch Sec >= savings Instant Transitions [ savings Instant Transitions . length - NUM ] ) { if ( last Rules . length == NUM ) { return null ; } int year = find Year ( epoch Sec , wall Offsets [ wall Offsets . length - NUM ] ) ; Zone Offset Transition [ ] trans Array = find Transition Array ( year ) ; for ( Zone Offset Transition trans : trans Array ) { if ( epoch Sec < trans . to Epoch Second ( ) ) { return trans ; } } if ( year < Year . MAX VALUE ) { trans Array = find Transition Array ( year + NUM ) ; return trans Array [ NUM ] ; } return null ; } int index = Arrays . binary Search ( savings Instant Transitions , epoch Sec ) ; if ( index < NUM ) { index = - index - NUM ; } else { index += NUM ; } return new Zone Offset Transition ( savings Instant Transitions [ index ] , wall Offsets [ index ] , wall Offsets [ index + NUM ] ) ; }
public Zone Offset Transition next Transition ( Instant instant ) { if ( savings Instant Transitions . length == NUM ) { return null ; } long epoch Sec = instant . get Epoch Second ( ) ; if ( epoch Sec >= savings Instant Transitions [ savings Instant Transitions . length - NUM ] ) { if ( last Rules . length == NUM ) { return null ; } int year = find Year ( epoch Sec , wall Offsets [ wall Offsets . length - NUM ] ) ; Zone Offset Transition [ ] trans Array = find Transition Array ( year ) ; for ( Zone Offset Transition trans : trans Array ) { if ( epoch Sec < trans . to Epoch Second ( ) ) { return trans ; } } if ( year < Year . MAX VALUE ) { trans Array = find Transition Array ( year + NUM ) ; return trans Array [ NUM ] ; } return null ; } int index = Arrays . binary Search ( savings Instant Transitions , epoch Sec ) ; if ( index < NUM ) { index = - index - NUM ; } else { index += NUM ; } return new Zone Offset Transition ( savings Instant Transitions [ index ] , wall Offsets [ index ] , wall Offsets [ index + NUM ] ) ; }
public Zone Offset Transition next Transition ( Instant instant ) { if ( savings Instant Transitions . length == NUM ) { return null ; } long epoch Sec = instant . get Epoch Second ( ) ; if ( epoch Sec >= savings Instant Transitions [ savings Instant Transitions . length - NUM ] ) { if ( last Rules . length == NUM ) { return null ; } int year = find Year ( epoch Sec , wall Offsets [ wall Offsets . length - NUM ] ) ; Zone Offset Transition [ ] trans Array = find Transition Array ( year ) ; for ( Zone Offset Transition trans : trans Array ) { if ( epoch Sec < trans . to Epoch Second ( ) ) { return trans ; } } if ( year < Year . MAX VALUE ) { trans Array = find Transition Array ( year + NUM ) ; return trans Array [ NUM ] ; } return null ; } int index = Arrays . binary Search ( savings Instant Transitions , epoch Sec ) ; if ( index < NUM ) { index = - index - NUM ; } else { index += NUM ; } return new Zone Offset Transition ( savings Instant Transitions [ index ] , wall Offsets [ index ] , wall Offsets [ index + NUM ] ) ; }
public Zone Offset Transition next Transition ( Instant instant ) { if ( savings Instant Transitions . length == NUM ) { return null ; } long epoch Sec = instant . get Epoch Second ( ) ; if ( epoch Sec >= savings Instant Transitions [ savings Instant Transitions . length - NUM ] ) { if ( last Rules . length == NUM ) { return null ; } int year = find Year ( epoch Sec , wall Offsets [ wall Offsets . length - NUM ] ) ; Zone Offset Transition [ ] trans Array = find Transition Array ( year ) ; for ( Zone Offset Transition trans : trans Array ) { if ( epoch Sec < trans . to Epoch Second ( ) ) { return trans ; } } if ( year < Year . MAX VALUE ) { trans Array = find Transition Array ( year + NUM ) ; return trans Array [ NUM ] ; } return null ; } int index = Arrays . binary Search ( savings Instant Transitions , epoch Sec ) ; if ( index < NUM ) { index = - index - NUM ; } else { index += NUM ; } return new Zone Offset Transition ( savings Instant Transitions [ index ] , wall Offsets [ index ] , wall Offsets [ index + NUM ] ) ; }
public Zone Offset Transition next Transition ( Instant instant ) { if ( savings Instant Transitions . length == NUM ) { return null ; } long epoch Sec = instant . get Epoch Second ( ) ; if ( epoch Sec >= savings Instant Transitions [ savings Instant Transitions . length - NUM ] ) { if ( last Rules . length == NUM ) { return null ; } int year = find Year ( epoch Sec , wall Offsets [ wall Offsets . length - NUM ] ) ; Zone Offset Transition [ ] trans Array = find Transition Array ( year ) ; for ( Zone Offset Transition trans : trans Array ) { if ( epoch Sec < trans . to Epoch Second ( ) ) { return trans ; } } if ( year < Year . MAX VALUE ) { trans Array = find Transition Array ( year + NUM ) ; return trans Array [ NUM ] ; } return null ; } int index = Arrays . binary Search ( savings Instant Transitions , epoch Sec ) ; if ( index < NUM ) { index = - index - NUM ; } else { index += NUM ; } return new Zone Offset Transition ( savings Instant Transitions [ index ] , wall Offsets [ index ] , wall Offsets [ index + NUM ] ) ; }
public Zone Offset Transition next Transition ( Instant instant ) { if ( savings Instant Transitions . length == NUM ) { return null ; } long epoch Sec = instant . get Epoch Second ( ) ; if ( epoch Sec >= savings Instant Transitions [ savings Instant Transitions . length - NUM ] ) { if ( last Rules . length == NUM ) { return null ; } int year = find Year ( epoch Sec , wall Offsets [ wall Offsets . length - NUM ] ) ; Zone Offset Transition [ ] trans Array = find Transition Array ( year ) ; for ( Zone Offset Transition trans : trans Array ) { if ( epoch Sec < trans . to Epoch Second ( ) ) { return trans ; } } if ( year < Year . MAX VALUE ) { trans Array = find Transition Array ( year + NUM ) ; return trans Array [ NUM ] ; } return null ; } int index = Arrays . binary Search ( savings Instant Transitions , epoch Sec ) ; if ( index < NUM ) { index = - index - NUM ; } else { index += NUM ; } return new Zone Offset Transition ( savings Instant Transitions [ index ] , wall Offsets [ index ] , wall Offsets [ index + NUM ] ) ; }
public Zone Offset Transition next Transition ( Instant instant ) { if ( savings Instant Transitions . length == NUM ) { return null ; } long epoch Sec = instant . get Epoch Second ( ) ; if ( epoch Sec >= savings Instant Transitions [ savings Instant Transitions . length - NUM ] ) { if ( last Rules . length == NUM ) { return null ; } int year = find Year ( epoch Sec , wall Offsets [ wall Offsets . length - NUM ] ) ; Zone Offset Transition [ ] trans Array = find Transition Array ( year ) ; for ( Zone Offset Transition trans : trans Array ) { if ( epoch Sec < trans . to Epoch Second ( ) ) { return trans ; } } if ( year < Year . MAX VALUE ) { trans Array = find Transition Array ( year + NUM ) ; return trans Array [ NUM ] ; } return null ; } int index = Arrays . binary Search ( savings Instant Transitions , epoch Sec ) ; if ( index < NUM ) { index = - index - NUM ; } else { index += NUM ; } return new Zone Offset Transition ( savings Instant Transitions [ index ] , wall Offsets [ index ] , wall Offsets [ index + NUM ] ) ; }
public Zone Offset Transition next Transition ( Instant instant ) { if ( savings Instant Transitions . length == NUM ) { return null ; } long epoch Sec = instant . get Epoch Second ( ) ; if ( epoch Sec >= savings Instant Transitions [ savings Instant Transitions . length - NUM ] ) { if ( last Rules . length == NUM ) { return null ; } int year = find Year ( epoch Sec , wall Offsets [ wall Offsets . length - NUM ] ) ; Zone Offset Transition [ ] trans Array = find Transition Array ( year ) ; for ( Zone Offset Transition trans : trans Array ) { if ( epoch Sec < trans . to Epoch Second ( ) ) { return trans ; } } if ( year < Year . MAX VALUE ) { trans Array = find Transition Array ( year + NUM ) ; return trans Array [ NUM ] ; } return null ; } int index = Arrays . binary Search ( savings Instant Transitions , epoch Sec ) ; if ( index < NUM ) { index = - index - NUM ; } else { index += NUM ; } return new Zone Offset Transition ( savings Instant Transitions [ index ] , wall Offsets [ index ] , wall Offsets [ index + NUM ] ) ; }
public Zone Offset Transition next Transition ( Instant instant ) { if ( savings Instant Transitions . length == NUM ) { return null ; } long epoch Sec = instant . get Epoch Second ( ) ; if ( epoch Sec >= savings Instant Transitions [ savings Instant Transitions . length - NUM ] ) { if ( last Rules . length == NUM ) { return null ; } int year = find Year ( epoch Sec , wall Offsets [ wall Offsets . length - NUM ] ) ; Zone Offset Transition [ ] trans Array = find Transition Array ( year ) ; for ( Zone Offset Transition trans : trans Array ) { if ( epoch Sec < trans . to Epoch Second ( ) ) { return trans ; } } if ( year < Year . MAX VALUE ) { trans Array = find Transition Array ( year + NUM ) ; return trans Array [ NUM ] ; } return null ; } int index = Arrays . binary Search ( savings Instant Transitions , epoch Sec ) ; if ( index < NUM ) { index = - index - NUM ; } else { index += NUM ; } return new Zone Offset Transition ( savings Instant Transitions [ index ] , wall Offsets [ index ] , wall Offsets [ index + NUM ] ) ; }
public boolean ignore User Profile ( ) { String profile = null ; try { profile = sso Token . get Property ( IS Auth Constants . USER PROFILE ) ; } catch ( SSO Exception e ) { debug . warning ( STRING , e ) ; } return ( ( profile != null ) && profile . equals ( IS Auth Constants . IGNORE ) ) ; }
public boolean ignore User Profile ( ) { String profile = null ; try { profile = sso Token . get Property ( IS Auth Constants . USER PROFILE ) ; } catch ( SSO Exception e ) { debug . warning ( STRING , e ) ; } return ( ( profile != null ) && profile . equals ( IS Auth Constants . IGNORE ) ) ; }
public boolean ignore User Profile ( ) { String profile = null ; try { profile = sso Token . get Property ( IS Auth Constants . USER PROFILE ) ; } catch ( SSO Exception e ) { debug . warning ( STRING , e ) ; } return ( ( profile != null ) && profile . equals ( IS Auth Constants . IGNORE ) ) ; }
public void add Entry ( Entry e , int data Set Index ) { if ( m Data Sets . size ( ) > data Set Index && data Set Index >= NUM ) { float val = e . get Val ( ) ; mY Val Count += NUM ; mY Value Sum += val ; if ( mY Max < val ) mY Max = val ; if ( mY Min > val ) mY Min = val ; T set = m Data Sets . get ( data Set Index ) ; if ( set != null ) { if ( set . get Axis Dependency ( ) == Axis Dependency . LEFT ) { if ( m Left Axis Max < e . get Val ( ) ) m Left Axis Max = e . get Val ( ) ; if ( m Left Axis Min > e . get Val ( ) ) m Left Axis Min = e . get Val ( ) ; } else { if ( m Right Axis Max < e . get Val ( ) ) m Right Axis Max = e . get Val ( ) ; if ( m Right Axis Min > e . get Val ( ) ) m Right Axis Min = e . get Val ( ) ; } handle Empty Axis ( get First Left ( ) , get First Right ( ) ) ; set . add Entry ( e ) ; } } else { Log . e ( STRING , STRING ) ; } }
public void add Entry ( Entry e , int data Set Index ) { if ( m Data Sets . size ( ) > data Set Index && data Set Index >= NUM ) { float val = e . get Val ( ) ; mY Val Count += NUM ; mY Value Sum += val ; if ( mY Max < val ) mY Max = val ; if ( mY Min > val ) mY Min = val ; T set = m Data Sets . get ( data Set Index ) ; if ( set != null ) { if ( set . get Axis Dependency ( ) == Axis Dependency . LEFT ) { if ( m Left Axis Max < e . get Val ( ) ) m Left Axis Max = e . get Val ( ) ; if ( m Left Axis Min > e . get Val ( ) ) m Left Axis Min = e . get Val ( ) ; } else { if ( m Right Axis Max < e . get Val ( ) ) m Right Axis Max = e . get Val ( ) ; if ( m Right Axis Min > e . get Val ( ) ) m Right Axis Min = e . get Val ( ) ; } handle Empty Axis ( get First Left ( ) , get First Right ( ) ) ; set . add Entry ( e ) ; } } else { Log . e ( STRING , STRING ) ; } }
@ Override default Completable Future < Optional Double > average Int ( final To Int Function < ? super T > fn ) { return Completable Future . supply Async ( null , get Exec ( ) ) ; }
public static String remove Formatting ( String line ) { int length = line . length ( ) ; String Builder buffer = new String Builder ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char ch = line . char At ( i ) ; if ( ch != STRING && ch != STRING && ch != STRING && ch != STRING ) buffer . append ( ch ) ; } return buffer . to String ( ) ; }
public static Request new Upload Video Request ( Session session , File file , Callback callback ) throws File Not Found Exception { Parcel File Descriptor descriptor = Parcel File Descriptor . open ( file , Parcel File Descriptor . MODE READ ONLY ) ; Bundle parameters = new Bundle ( NUM ) ; parameters . put Parcelable ( file . get Name ( ) , descriptor ) ; return new Request ( session , MY VIDEOS , parameters , Http Method . POST , callback ) ; }
public static Request new Upload Video Request ( Session session , File file , Callback callback ) throws File Not Found Exception { Parcel File Descriptor descriptor = Parcel File Descriptor . open ( file , Parcel File Descriptor . MODE READ ONLY ) ; Bundle parameters = new Bundle ( NUM ) ; parameters . put Parcelable ( file . get Name ( ) , descriptor ) ; return new Request ( session , MY VIDEOS , parameters , Http Method . POST , callback ) ; }
public static Request new Upload Video Request ( Session session , File file , Callback callback ) throws File Not Found Exception { Parcel File Descriptor descriptor = Parcel File Descriptor . open ( file , Parcel File Descriptor . MODE READ ONLY ) ; Bundle parameters = new Bundle ( NUM ) ; parameters . put Parcelable ( file . get Name ( ) , descriptor ) ; return new Request ( session , MY VIDEOS , parameters , Http Method . POST , callback ) ; }
public static Request new Upload Video Request ( Session session , File file , Callback callback ) throws File Not Found Exception { Parcel File Descriptor descriptor = Parcel File Descriptor . open ( file , Parcel File Descriptor . MODE READ ONLY ) ; Bundle parameters = new Bundle ( NUM ) ; parameters . put Parcelable ( file . get Name ( ) , descriptor ) ; return new Request ( session , MY VIDEOS , parameters , Http Method . POST , callback ) ; }
public static Request new Upload Video Request ( Session session , File file , Callback callback ) throws File Not Found Exception { Parcel File Descriptor descriptor = Parcel File Descriptor . open ( file , Parcel File Descriptor . MODE READ ONLY ) ; Bundle parameters = new Bundle ( NUM ) ; parameters . put Parcelable ( file . get Name ( ) , descriptor ) ; return new Request ( session , MY VIDEOS , parameters , Http Method . POST , callback ) ; }
private void remove OMA Download From Shared Prefs ( long download Id ) { Set < String > oma Downloads = get Stored Download Info ( PENDING OMA DOWNLOADS ) ; for ( String oma Download : oma Downloads ) { OMA Entry entry = OMA Entry . parse OMA Entry ( oma Download ) ; if ( entry . m Download Id == download Id ) { oma Downloads . remove ( oma Download ) ; store Download Info ( PENDING OMA DOWNLOADS , oma Downloads ) ; return ; } } }
public static void write Statistics ( T Double Object Hash Map < Descriptive Statistics > stats Map , String key Label , String file ) throws IO Exception { double [ ] keys = stats Map . keys ( ) ; Arrays . sort ( keys ) ; Buffered Writer writer = new Buffered Writer ( new File Writer ( file ) ) ; writer . write ( key Label ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . new Line ( ) ; for ( double key : keys ) { Descriptive Statistics stats = stats Map . get ( key ) ; writer . write ( String . value Of ( key ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get Mean ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get Percentile ( NUM ) ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get Min ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get Max ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get N ( ) ) ) ; writer . new Line ( ) ; } writer . close ( ) ; }
public static void write Statistics ( T Double Object Hash Map < Descriptive Statistics > stats Map , String key Label , String file ) throws IO Exception { double [ ] keys = stats Map . keys ( ) ; Arrays . sort ( keys ) ; Buffered Writer writer = new Buffered Writer ( new File Writer ( file ) ) ; writer . write ( key Label ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . new Line ( ) ; for ( double key : keys ) { Descriptive Statistics stats = stats Map . get ( key ) ; writer . write ( String . value Of ( key ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get Mean ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get Percentile ( NUM ) ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get Min ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get Max ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get N ( ) ) ) ; writer . new Line ( ) ; } writer . close ( ) ; }
public static void write Statistics ( T Double Object Hash Map < Descriptive Statistics > stats Map , String key Label , String file ) throws IO Exception { double [ ] keys = stats Map . keys ( ) ; Arrays . sort ( keys ) ; Buffered Writer writer = new Buffered Writer ( new File Writer ( file ) ) ; writer . write ( key Label ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . new Line ( ) ; for ( double key : keys ) { Descriptive Statistics stats = stats Map . get ( key ) ; writer . write ( String . value Of ( key ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get Mean ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get Percentile ( NUM ) ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get Min ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get Max ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get N ( ) ) ) ; writer . new Line ( ) ; } writer . close ( ) ; }
public Class File Reader ( Class Analysis Stats analysis Stats ) { this . analysis Stats = analysis Stats ; }
public void debug Print ( String name , Print Stream out ) throws Ade Exception { if ( name != null ) { out . println ( STRING + name + STRING + get LL Max ( ) ) ; } if ( m point Scores != null && ! m point Scores . is Empty ( ) ) { for ( Entry < Integer , Double > point Score : m point Scores . entry Set ( ) ) { out . println ( STRING + point Score . get Key ( ) + STRING + point Score . get Value ( ) ) ; } out . println ( STRING + - m log Half ) ; } }
public static byte [ ] decode ( String s ) throws java . io . IO Exception { return decode ( s , NO OPTIONS ) ; }
@ Override public Client Socket open If Live ( ) { if ( state . is Closed ( ) ) { return null ; } Client Socket stream = open Recycle ( ) ; if ( stream != null ) return stream ; long now = Current Time . current Time ( ) ; if ( is Failed ( now ) ) return null ; else if ( state == State . FAIL && starting Count . get ( ) > NUM ) { return null ; } return connect ( ) ; }
public void init Without J Unit For Fixture ( Class fixture , Method method ) { this . test Class = fixture ; this . test Method Name = method . get Name ( ) ; }
public void init Without J Unit For Fixture ( Class fixture , Method method ) { this . test Class = fixture ; this . test Method Name = method . get Name ( ) ; }
public void init Without J Unit For Fixture ( Class fixture , Method method ) { this . test Class = fixture ; this . test Method Name = method . get Name ( ) ; }
private static boolean has Attr ( Svc Reg reg , Entry Class eclass , int fldidx , Object value ) { Entry Rep [ ] sets = reg . item . attribute Sets ; for ( int i = sets . length ; -- i >= NUM ; ) { Entry Rep set = sets [ i ] ; if ( eclass . is Assignable From ( set . eclass ) && ( ( value == null && set . fields [ fldidx ] == null ) || ( value != null && value . equals ( set . fields [ fldidx ] ) ) ) ) return BOOL ; } return BOOL ; }
private static boolean has Attr ( Svc Reg reg , Entry Class eclass , int fldidx , Object value ) { Entry Rep [ ] sets = reg . item . attribute Sets ; for ( int i = sets . length ; -- i >= NUM ; ) { Entry Rep set = sets [ i ] ; if ( eclass . is Assignable From ( set . eclass ) && ( ( value == null && set . fields [ fldidx ] == null ) || ( value != null && value . equals ( set . fields [ fldidx ] ) ) ) ) return BOOL ; } return BOOL ; }
private Rrd Entry request Empty ( String path ) throws Interrupted Exception , IO Exception { Rrd Entry ref = wait Empty ( path ) ; ref . count = NUM ; return ref ; }
public void delete ( int ... indices ) { int [ ] idx 2 = indices . clone ( ) ; if ( idx 2 . length > NUM ) { Arrays . sort ( idx 2 ) ; for ( int i = idx 2 . length - NUM ; i >= NUM ; i -- ) { items . remove ( idx 2 [ i ] ) ; } fire Table Rows Deleted ( idx 2 [ NUM ] , idx 2 [ idx 2 . length - NUM ] ) ; } }
public void audit Callhome ( Operation Type Enum audit Type , String operational Status , String description , Object ... descparams ) { audit Mgr . record Audit Log ( null , null , EVENT SERVICE TYPE , audit Type , System . current Time Millis ( ) , operational Status , description , descparams ) ; }
private void insert Used Context Prefixes ( ) { int unknown Prefixes Count = unknown Prefixes In XML Literal . size ( ) ; if ( unknown Prefixes Count > NUM ) { String Builder context Prefixes = new String Builder ( NUM ) ; Element Info top Element = peek Stack ( ) ; for ( int i = NUM ; i < unknown Prefixes Count ; i ++ ) { String prefix = unknown Prefixes In XML Literal . get ( i ) ; String namespace = top Element . get Namespace ( prefix ) ; if ( namespace != null ) { append Namespace Decl ( context Prefixes , prefix , namespace ) ; } } int end Of First Start Tag = char Buf . index Of ( STRING ) ; char Buf . insert ( end Of First Start Tag , context Prefixes . to String ( ) ) ; } unknown Prefixes In XML Literal . clear ( ) ; }
private void insert Used Context Prefixes ( ) { int unknown Prefixes Count = unknown Prefixes In XML Literal . size ( ) ; if ( unknown Prefixes Count > NUM ) { String Builder context Prefixes = new String Builder ( NUM ) ; Element Info top Element = peek Stack ( ) ; for ( int i = NUM ; i < unknown Prefixes Count ; i ++ ) { String prefix = unknown Prefixes In XML Literal . get ( i ) ; String namespace = top Element . get Namespace ( prefix ) ; if ( namespace != null ) { append Namespace Decl ( context Prefixes , prefix , namespace ) ; } } int end Of First Start Tag = char Buf . index Of ( STRING ) ; char Buf . insert ( end Of First Start Tag , context Prefixes . to String ( ) ) ; } unknown Prefixes In XML Literal . clear ( ) ; }
public static Number Format make Number Format ( int digits ) { switch ( digits ) { case NUM : return NF 0 ; case NUM : return NF 2 ; case NUM : return NF 3 ; case NUM : return NF 4 ; case NUM : return NF 6 ; case NUM : return NF 8 ; } final Number Format nf = Number Format . get Instance ( Locale . US ) ; nf . set Maximum Fraction Digits ( digits ) ; nf . set Minimum Fraction Digits ( digits ) ; nf . set Grouping Used ( BOOL ) ; return nf ; }
private Map < Long , Pair < String , Long > > recover Pending Large Messages ( ) throws Exception { Map < Long , Pair < String , Long > > large Messages = new Hash Map < > ( ) ; List < String > filenames = large Messages Factory . list Files ( STRING ) ; List < Long > id List = new Array List < > ( ) ; for ( String filename : filenames ) { Long id = get Large Message Id From Filename ( filename ) ; if ( ! large Messages To Delete . contains ( id ) ) { id List . add ( id ) ; Sequential File seq File = large Messages Factory . create Sequential File ( filename ) ; long size = seq File . size ( ) ; large Messages . put ( id , new Pair < > ( filename , size ) ) ; } } return large Messages ; }
public Trie Node find ( String word ) { return ( word . length ( ) < NUM ? null : find ( word , root , NUM ) ) ; }
public Trie Node find ( String word ) { return ( word . length ( ) < NUM ? null : find ( word , root , NUM ) ) ; }
public Trie Node find ( String word ) { return ( word . length ( ) < NUM ? null : find ( word , root , NUM ) ) ; }
private void put Parameters From S 3 ( String s3 Bucket Name , String s3 Object Key , Map < String , Object > parameters ) { if ( s3 Bucket Name != null && s3 Object Key != null ) { S3 File Transfer Request Params Dto s3 File Transfer Request Params Dto = storage Helper . get S 3 File Transfer Request Params Dto ( ) ; Properties properties = s3 Dao . get Properties ( s3 Bucket Name , s3 Object Key , s3 File Transfer Request Params Dto ) ; parameters . put All ( java Properties Helper . to Map ( properties ) ) ; } }
private void put Parameters From S 3 ( String s3 Bucket Name , String s3 Object Key , Map < String , Object > parameters ) { if ( s3 Bucket Name != null && s3 Object Key != null ) { S3 File Transfer Request Params Dto s3 File Transfer Request Params Dto = storage Helper . get S 3 File Transfer Request Params Dto ( ) ; Properties properties = s3 Dao . get Properties ( s3 Bucket Name , s3 Object Key , s3 File Transfer Request Params Dto ) ; parameters . put All ( java Properties Helper . to Map ( properties ) ) ; } }
private void put Parameters From S 3 ( String s3 Bucket Name , String s3 Object Key , Map < String , Object > parameters ) { if ( s3 Bucket Name != null && s3 Object Key != null ) { S3 File Transfer Request Params Dto s3 File Transfer Request Params Dto = storage Helper . get S 3 File Transfer Request Params Dto ( ) ; Properties properties = s3 Dao . get Properties ( s3 Bucket Name , s3 Object Key , s3 File Transfer Request Params Dto ) ; parameters . put All ( java Properties Helper . to Map ( properties ) ) ; } }
protected void add Scalar Dimension ( int i ) { for ( Dimension dimension : dimension List ) { if ( dimension . get Dimension ( ) == i ) { return ; } } dimension List . add ( new Dimension ( i ) ) ; }
public static String obtain Lock ( Entity Manager em , long expiration , long type , String note ) { Entity Transaction tx = null ; try { long now = System . current Time Millis ( ) ; tx = em . get Transaction ( ) ; tx . begin ( ) ; Global Interlock lock = find And Refresh Lock ( em , type ) ; if ( lock != null && now - lock . lock Time > expiration ) { em . remove ( lock ) ; em . flush ( ) ; } tx . commit ( ) ; } catch ( Exception ex ) { LOGGER . warn ( STRING , type , ex . get Message ( ) ) ; LOGGER . debug ( ex . get Message ( ) , ex ) ; if ( tx != null && tx . is Active ( ) ) { tx . rollback ( ) ; } } try { tx = em . get Transaction ( ) ; tx . begin ( ) ; Global Interlock lock = em . merge ( new Global Interlock ( type , note ) ) ; em . flush ( ) ; tx . commit ( ) ; return Long . to Hex String ( lock . lock Time ) ; } catch ( Exception ex ) { throw new Global Interlock Exception ( STRING + type + STRING , ex ) ; } finally { if ( tx != null && tx . is Active ( ) ) { tx . rollback ( ) ; } } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public void projection Changed ( Projection Event e ) { Projection new Proj = e . get Projection ( ) ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( new Proj != null ? new Proj . to String ( ) : STRING ) ; } if ( new Proj != null && ( projection == null || ( ! projection . equals ( new Proj ) ) ) ) { set Projection ( ( Projection ) new Proj . make Clone ( ) ) ; Object source = e . get Source ( ) ; if ( source instanceof Component ) { proj Component = ( Component ) source ; } } }
public void projection Changed ( Projection Event e ) { Projection new Proj = e . get Projection ( ) ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( new Proj != null ? new Proj . to String ( ) : STRING ) ; } if ( new Proj != null && ( projection == null || ( ! projection . equals ( new Proj ) ) ) ) { set Projection ( ( Projection ) new Proj . make Clone ( ) ) ; Object source = e . get Source ( ) ; if ( source instanceof Component ) { proj Component = ( Component ) source ; } } }
public static String Bin To Char ( String bin ) { char value [ ] = new char [ bin . length ( ) / NUM ] ; int bin Length = value . length ; for ( int i = NUM ; i < bin Length ; i ++ ) value [ i ] = ( char ) Integer . parse Int ( bin . substring ( NUM * i , NUM * i + NUM ) , NUM ) ; return new String ( value ) ; }
public static String Bin To Char ( String bin ) { char value [ ] = new char [ bin . length ( ) / NUM ] ; int bin Length = value . length ; for ( int i = NUM ; i < bin Length ; i ++ ) value [ i ] = ( char ) Integer . parse Int ( bin . substring ( NUM * i , NUM * i + NUM ) , NUM ) ; return new String ( value ) ; }
public void on Restore Instance State ( Bundle saved Instance State ) { m Selected Positions . add All ( saved Instance State . get Integer Array List ( TAG ) ) ; Log . d ( TAG , STRING + m Selected Positions ) ; }
public boolean is Adjacent ( Cell c ) { if ( equals ( c ) ) return BOOL ; if ( col == c . col ) { return ( Math . abs ( row - c . row ) == NUM ) ; } if ( row == c . row ) { return ( Math . abs ( col - c . col ) == NUM ) ; } return BOOL ; }
public boolean is Adjacent ( Cell c ) { if ( equals ( c ) ) return BOOL ; if ( col == c . col ) { return ( Math . abs ( row - c . row ) == NUM ) ; } if ( row == c . row ) { return ( Math . abs ( col - c . col ) == NUM ) ; } return BOOL ; }
private boolean yy refill ( ) throws java . io . IO Exception { if ( yy reader == null ) return BOOL ; if ( yy start Read > NUM ) { System . arraycopy ( yy buffer , yy start Read , yy buffer , NUM , yy end Read - yy start Read ) ; yy end Read -= yy start Read ; yy current Pos -= yy start Read ; yy marked Pos -= yy start Read ; yy pushback Pos -= yy start Read ; yy start Read = NUM ; } if ( yy current Pos >= yy buffer . length ) { char new Buffer [ ] = new char [ yy current Pos * NUM ] ; System . arraycopy ( yy buffer , NUM , new Buffer , NUM , yy buffer . length ) ; yy buffer = new Buffer ; } int num Read = yy reader . read ( yy buffer , yy end Read , yy buffer . length - yy end Read ) ; if ( num Read < NUM ) { return BOOL ; } else { yy end Read += num Read ; return BOOL ; } }
private void stop Drag ( Motion Event ev ) { m Touch Mode = TOUCH MODE IDLE ; boolean commit Change = ev . get Action ( ) == Motion Event . ACTION UP && is Enabled ( ) ; cancel Super Touch ( ev ) ; if ( commit Change ) { boolean new State ; m Velocity Tracker . compute Current Velocity ( NUM ) ; float xvel = m Velocity Tracker . get X Velocity ( ) ; if ( Math . abs ( xvel ) > m Min Fling Velocity ) { new State = xvel > NUM ; } else { new State = get Target Checked State ( ) ; } animate Thumb To Checked State ( new State ) ; } else { animate Thumb To Checked State ( is Checked ( ) ) ; } }
private void stop Drag ( Motion Event ev ) { m Touch Mode = TOUCH MODE IDLE ; boolean commit Change = ev . get Action ( ) == Motion Event . ACTION UP && is Enabled ( ) ; cancel Super Touch ( ev ) ; if ( commit Change ) { boolean new State ; m Velocity Tracker . compute Current Velocity ( NUM ) ; float xvel = m Velocity Tracker . get X Velocity ( ) ; if ( Math . abs ( xvel ) > m Min Fling Velocity ) { new State = xvel > NUM ; } else { new State = get Target Checked State ( ) ; } animate Thumb To Checked State ( new State ) ; } else { animate Thumb To Checked State ( is Checked ( ) ) ; } }
public final Entry add Entry ( Position input Position , Position output Position ) { Entry entry = new Entry ( input Position , output Position ) ; entries . add ( entry ) ; return entry ; }
public final Entry add Entry ( Position input Position , Position output Position ) { Entry entry = new Entry ( input Position , output Position ) ; entries . add ( entry ) ; return entry ; }
public static int find URI Split Index ( String uri ) { int uri Length = uri . length ( ) ; int i = uri Length - NUM ; while ( i >= NUM ) { char c = uri . char At ( i ) ; if ( c == STRING || c == STRING || ! XML Util . is NC Name Char ( c ) ) { break ; } i -- ; } i ++ ; while ( i < uri Length ) { char c = uri . char At ( i ) ; if ( c == STRING || XML Util . is Letter ( c ) ) { break ; } i ++ ; } if ( i == uri Length ) { i = - NUM ; } return i ; }
public static int find URI Split Index ( String uri ) { int uri Length = uri . length ( ) ; int i = uri Length - NUM ; while ( i >= NUM ) { char c = uri . char At ( i ) ; if ( c == STRING || c == STRING || ! XML Util . is NC Name Char ( c ) ) { break ; } i -- ; } i ++ ; while ( i < uri Length ) { char c = uri . char At ( i ) ; if ( c == STRING || XML Util . is Letter ( c ) ) { break ; } i ++ ; } if ( i == uri Length ) { i = - NUM ; } return i ; }
public static int find URI Split Index ( String uri ) { int uri Length = uri . length ( ) ; int i = uri Length - NUM ; while ( i >= NUM ) { char c = uri . char At ( i ) ; if ( c == STRING || c == STRING || ! XML Util . is NC Name Char ( c ) ) { break ; } i -- ; } i ++ ; while ( i < uri Length ) { char c = uri . char At ( i ) ; if ( c == STRING || XML Util . is Letter ( c ) ) { break ; } i ++ ; } if ( i == uri Length ) { i = - NUM ; } return i ; }
public static String real Format Array ( final double [ ] x ) { final String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; for ( int i = NUM ; i < x . length ; i ++ ) { if ( i > NUM ) { sb . append ( STRING ) ; } sb . append ( real Format ( x [ i ] ) ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
private void close Connection ( Session session , Guacamole Status guac status ) { try { int code = guac status . get Web Socket Code ( ) ; String message = Integer . to String ( guac status . get Guacamole Status Code ( ) ) ; session . close ( new Close Status ( code , message ) ) ; } catch ( IO Exception e ) { logger . debug ( STRING , e ) ; } }
private void close Connection ( Session session , Guacamole Status guac status ) { try { int code = guac status . get Web Socket Code ( ) ; String message = Integer . to String ( guac status . get Guacamole Status Code ( ) ) ; session . close ( new Close Status ( code , message ) ) ; } catch ( IO Exception e ) { logger . debug ( STRING , e ) ; } }
private void close Connection ( Session session , Guacamole Status guac status ) { try { int code = guac status . get Web Socket Code ( ) ; String message = Integer . to String ( guac status . get Guacamole Status Code ( ) ) ; session . close ( new Close Status ( code , message ) ) ; } catch ( IO Exception e ) { logger . debug ( STRING , e ) ; } }
public static String file Name Clean ( String s ) { char [ ] chars = s . to Char Array ( ) ; String Builder sb = new String Builder ( ) ; for ( char c : chars ) { if ( ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c == STRING ) ) { sb . append ( c ) ; } else { if ( c == STRING || c == STRING ) { sb . append ( STRING ) ; } else { sb . append ( STRING + ( int ) c + STRING ) ; } } } return sb . to String ( ) ; }
public static String file Name Clean ( String s ) { char [ ] chars = s . to Char Array ( ) ; String Builder sb = new String Builder ( ) ; for ( char c : chars ) { if ( ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c == STRING ) ) { sb . append ( c ) ; } else { if ( c == STRING || c == STRING ) { sb . append ( STRING ) ; } else { sb . append ( STRING + ( int ) c + STRING ) ; } } } return sb . to String ( ) ; }
private Child Node Descriptor insert Type ( final Default Mutable Tree Node parent Node , final Base Type base Type , final int index ) { final Base Type Tree Node new Node = new Base Type Tree Node ( base Type ) ; parent Node . insert ( new Node , index ) ; create Type Nodes ( new Node , base Type ) ; return new Child Node Descriptor ( new Node , index ) ; }
private Child Node Descriptor insert Type ( final Default Mutable Tree Node parent Node , final Base Type base Type , final int index ) { final Base Type Tree Node new Node = new Base Type Tree Node ( base Type ) ; parent Node . insert ( new Node , index ) ; create Type Nodes ( new Node , base Type ) ; return new Child Node Descriptor ( new Node , index ) ; }
private Child Node Descriptor insert Type ( final Default Mutable Tree Node parent Node , final Base Type base Type , final int index ) { final Base Type Tree Node new Node = new Base Type Tree Node ( base Type ) ; parent Node . insert ( new Node , index ) ; create Type Nodes ( new Node , base Type ) ; return new Child Node Descriptor ( new Node , index ) ; }
public synchronized void add ( Result result , Object payload , String suffix ) { Date date ; date = new Date ( ) ; m Results . put ( date , result ) ; m Payloads . put ( date , payload ) ; m Suffixes . put ( date , suffix ) ; m Ordered . add ( date ) ; }
private void check State ( ) throws Illegal State Exception { if ( consonants == null ) { throw new Illegal State Exception ( STRING ) ; } if ( vowels == null ) { throw new Illegal State Exception ( STRING ) ; } if ( consonants . size ( ) == NUM ) { throw new Illegal State Exception ( STRING ) ; } if ( vowels . size ( ) == NUM ) { throw new Illegal State Exception ( STRING ) ; } }
private void check State ( ) throws Illegal State Exception { if ( consonants == null ) { throw new Illegal State Exception ( STRING ) ; } if ( vowels == null ) { throw new Illegal State Exception ( STRING ) ; } if ( consonants . size ( ) == NUM ) { throw new Illegal State Exception ( STRING ) ; } if ( vowels . size ( ) == NUM ) { throw new Illegal State Exception ( STRING ) ; } }
public void add Volumes To Consistency Group ( String cg Name , List < String > virtual Volume Names ) throws V Plex Api Exception { s logger . info ( STRING , base URI ) ; cg Mgr . add Volumes To Consistency Group ( cg Name , virtual Volume Names ) ; }
protected void select Renderables ( Draw Context dc ) { Array List < Graticule Tile > tile List = get Visible Tiles ( dc ) ; if ( tile List . size ( ) > NUM ) { for ( Graticule Tile gz : tile List ) { gz . select Renderables ( dc ) ; } } }
public void reset ( ) { local Deque . clear ( ) ; local Deque . push ( new Frame Path ( ) ) ; }
public void reset ( ) { local Deque . clear ( ) ; local Deque . push ( new Frame Path ( ) ) ; }
public static Explanation no Match ( String description , Explanation ... details ) { return new Explanation ( BOOL , NUM , description , Arrays . as List ( details ) ) ; }
public Ids Query ( Class < T > type , Object [ ] ids ) { this ( type . get Name ( ) , ids , null , null , Query Result Type . DEFAULT ) ; }
public Ids Query ( Class < T > type , Object [ ] ids ) { this ( type . get Name ( ) , ids , null , null , Query Result Type . DEFAULT ) ; }
public Ids Query ( Class < T > type , Object [ ] ids ) { this ( type . get Name ( ) , ids , null , null , Query Result Type . DEFAULT ) ; }
public static String unqualify ( String qualified Name , char separator ) { return qualified Name . substring ( qualified Name . last Index Of ( separator ) + NUM ) ; }
public String replace ( final Map < String , String > params ) { final String Builder r = new String Builder ( ) ; for ( final Format f : pattern Ops ) { f . format ( r , params ) ; } return r . to String ( ) ; }
boolean configuring ( ) { return configuring > NUM ; }
boolean configuring ( ) { return configuring > NUM ; }
boolean configuring ( ) { return configuring > NUM ; }
@ Override public List refresh Ticks ( Graphics 2 D g2 , Axis State state , Rectangle 2 D data Area , Rectangle Edge edge ) { List ticks = null ; if ( Rectangle Edge . is Top Or Bottom ( edge ) ) { ticks = refresh Ticks Horizontal ( g2 , data Area , edge ) ; } else if ( Rectangle Edge . is Left Or Right ( edge ) ) { ticks = refresh Ticks Vertical ( g2 , data Area , edge ) ; } return ticks ; }
@ Override public List refresh Ticks ( Graphics 2 D g2 , Axis State state , Rectangle 2 D data Area , Rectangle Edge edge ) { List ticks = null ; if ( Rectangle Edge . is Top Or Bottom ( edge ) ) { ticks = refresh Ticks Horizontal ( g2 , data Area , edge ) ; } else if ( Rectangle Edge . is Left Or Right ( edge ) ) { ticks = refresh Ticks Vertical ( g2 , data Area , edge ) ; } return ticks ; }
public static boolean is Repeat Char ( char ch ) { return null != repeat Char Hash Table . get ( STRING + ch ) ; }
public static boolean is Repeat Char ( char ch ) { return null != repeat Char Hash Table . get ( STRING + ch ) ; }
public static boolean is Repeat Char ( char ch ) { return null != repeat Char Hash Table . get ( STRING + ch ) ; }
public static boolean is Repeat Char ( char ch ) { return null != repeat Char Hash Table . get ( STRING + ch ) ; }
public static boolean is Repeat Char ( char ch ) { return null != repeat Char Hash Table . get ( STRING + ch ) ; }
public static boolean is Repeat Char ( char ch ) { return null != repeat Char Hash Table . get ( STRING + ch ) ; }
public static boolean is Repeat Char ( char ch ) { return null != repeat Char Hash Table . get ( STRING + ch ) ; }
public static boolean is Repeat Char ( char ch ) { return null != repeat Char Hash Table . get ( STRING + ch ) ; }
public void load PDF ( final String input ) { if ( input == null ) { return ; } scale = NUM ; PD Ffile = input ; file Loc . set Text ( PD Ffile ) ; if ( input . starts With ( STRING ) ) { open File ( null , input , BOOL ) ; } else { open File ( new File ( input ) , null , BOOL ) ; } }
public void load PDF ( final String input ) { if ( input == null ) { return ; } scale = NUM ; PD Ffile = input ; file Loc . set Text ( PD Ffile ) ; if ( input . starts With ( STRING ) ) { open File ( null , input , BOOL ) ; } else { open File ( new File ( input ) , null , BOOL ) ; } }
public Artifact ( final String group , final String artifact , final String version ) { if ( group == null || group . is Empty ( ) ) throw new Illegal Argument Exception ( STRING ) ; if ( artifact == null || artifact . is Empty ( ) ) throw new Illegal Argument Exception ( STRING ) ; if ( version == null || version . is Empty ( ) ) throw new Illegal Argument Exception ( STRING ) ; this . group = group ; this . artifact = artifact ; this . version = version ; }
public static double loss ( double pred , double y , double c ) { final double x = y - pred ; if ( Math . abs ( x ) <= c ) return x * x * NUM ; else return c * ( Math . abs ( x ) - c / NUM ) ; }
private void add One Line Of TLA ( String line ) { if ( tlacode . size ( ) != mapping Vector . size ( ) ) { Pcal Debug . Report Bug ( STRING ) ; } end Current Line Of TLA ( ) ; if ( line . length ( ) == NUM ) { mapping Vector . add Element ( new Vector ( NUM ) ) ; tlacode . add Element ( STRING ) ; return ; } add One Token To TLA ( line ) ; end Current Line Of TLA ( ) ; }
public T Message read Message Begin ( ) throws T Exception { byte protocol Id = read Byte ( ) ; if ( protocol Id != PROTOCOL ID ) { throw new T Protocol Exception ( STRING + Integer . to Hex String ( PROTOCOL ID ) + STRING + Integer . to Hex String ( protocol Id ) ) ; } byte version And Type = read Byte ( ) ; byte version = ( byte ) ( version And Type & VERSION MASK ) ; if ( version != VERSION ) { throw new T Protocol Exception ( STRING + VERSION + STRING + version ) ; } byte type = ( byte ) ( ( version And Type > > TYPE SHIFT AMOUNT ) & TYPE BITS ) ; int seqid = read Varint 32 ( ) ; String message Name = read String ( ) ; return new T Message ( message Name , type , seqid ) ; }
private void double Capacity ( ) { int p = head ; int n = elements . length ; int r = n - p ; int new Capacity = n << NUM ; if ( new Capacity < NUM ) throw new Illegal State Exception ( STRING ) ; Object [ ] a = new Object [ new Capacity ] ; System . arraycopy ( elements , p , a , NUM , r ) ; System . arraycopy ( elements , NUM , a , r , p ) ; elements = a ; head = NUM ; tail = n ; }
public void add Element ( E element ) { int index = delegate . size ( ) ; delegate . add Element ( element ) ; fire Interval Added ( this , index , index ) ; }
public String remove Reference Header From Blast Match ( String blast Text ) { int index = blast Text . index Of ( STRING ) ; if ( index == - NUM ) index = blast Text . index Of ( STRING ) ; if ( index > NUM ) return blast Text . substring ( index ) ; else return blast Text ; }
public static Element find ( Node parent , String name ) { Node List list = parent . get Child Nodes ( ) ; for ( int i = NUM ; i < list . get Length ( ) ; i ++ ) { Node n = list . item ( i ) ; if ( n instanceof Element ) { Element e = ( Element ) n ; if ( name . equals ( e . get Attribute ( STRING ) ) ) { return e ; } } Element r = find ( n , name ) ; if ( r != null ) { return r ; } } return null ; }
public void add Method ( Mapped Member mm ) { methods . add ( mm ) ; }
public void add Method ( Mapped Member mm ) { methods . add ( mm ) ; }
public void remove Change Listener ( Change Listener cl ) { listeners . remove ( cl ) ; }
public Macro ( File file ) throws EOF Exception , File Not Found Exception , IO Exception { Document Builder Factory dbf = Document Builder Factory . new Instance ( ) ; Document Builder db = null ; Document doc = null ; try { db = dbf . new Document Builder ( ) ; Input Source is = new Input Source ( new Unicode Reader ( new File Input Stream ( file ) , FILE ENCODING ) ) ; is . set Encoding ( FILE ENCODING ) ; doc = db . parse ( is ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; String desc = e . get Message ( ) ; if ( desc == null ) { desc = e . to String ( ) ; } throw new IO Exception ( STRING + desc ) ; } macro Records = new Array List ( ) ; boolean parsed OK = initialize From XML File ( doc . get Document Element ( ) ) ; if ( parsed OK == BOOL ) { name = null ; macro Records . clear ( ) ; macro Records = null ; throw new IO Exception ( STRING ) ; } }
public static Path create Temp File In Same Dir ( String file Name ) throws IO Exception { Path target = Paths . get ( file Name ) ; Path parent Path = target . get Parent ( ) ; return Default Filepaths . create Temp File ( parent Path , null , null ) ; }
public static Path create Temp File In Same Dir ( String file Name ) throws IO Exception { Path target = Paths . get ( file Name ) ; Path parent Path = target . get Parent ( ) ; return Default Filepaths . create Temp File ( parent Path , null , null ) ; }
public static Path create Temp File In Same Dir ( String file Name ) throws IO Exception { Path target = Paths . get ( file Name ) ; Path parent Path = target . get Parent ( ) ; return Default Filepaths . create Temp File ( parent Path , null , null ) ; }
public static Path create Temp File In Same Dir ( String file Name ) throws IO Exception { Path target = Paths . get ( file Name ) ; Path parent Path = target . get Parent ( ) ; return Default Filepaths . create Temp File ( parent Path , null , null ) ; }
public static Path create Temp File In Same Dir ( String file Name ) throws IO Exception { Path target = Paths . get ( file Name ) ; Path parent Path = target . get Parent ( ) ; return Default Filepaths . create Temp File ( parent Path , null , null ) ; }
public static Path create Temp File In Same Dir ( String file Name ) throws IO Exception { Path target = Paths . get ( file Name ) ; Path parent Path = target . get Parent ( ) ; return Default Filepaths . create Temp File ( parent Path , null , null ) ; }
protected void check Bug Instance ( Bug Instance bug Instance ) { for ( Iterator < Bug Annotation > i = bug Instance . annotation Iterator ( ) ; i . has Next ( ) ; ) { Bug Annotation bug Annotation = i . next ( ) ; if ( bug Annotation instanceof Package Member Annotation ) { Package Member Annotation pkg Member = ( Package Member Annotation ) bug Annotation ; if ( pkg Member . get Source Lines ( ) == null ) { throw new Illegal State Exception ( STRING + pkg Member + STRING ) ; } } } }
public void test filter 001 ( ) throws IO Exception { final File basefile = File . create Temp File ( get Name ( ) , STRING ) ; try { final String basename = basefile . to String ( ) ; final Name And Extension Filter log Filter = new Name And Extension Filter ( basename , STRING ) ; assert Same Files ( new File [ ] { } , log Filter . get Files ( ) ) ; } finally { basefile . delete ( ) ; } }
public void test filter 001 ( ) throws IO Exception { final File basefile = File . create Temp File ( get Name ( ) , STRING ) ; try { final String basename = basefile . to String ( ) ; final Name And Extension Filter log Filter = new Name And Extension Filter ( basename , STRING ) ; assert Same Files ( new File [ ] { } , log Filter . get Files ( ) ) ; } finally { basefile . delete ( ) ; } }
public void test filter 001 ( ) throws IO Exception { final File basefile = File . create Temp File ( get Name ( ) , STRING ) ; try { final String basename = basefile . to String ( ) ; final Name And Extension Filter log Filter = new Name And Extension Filter ( basename , STRING ) ; assert Same Files ( new File [ ] { } , log Filter . get Files ( ) ) ; } finally { basefile . delete ( ) ; } }
public static int find Non Mark Nor Other Character ( String text , int column ) { if ( column + NUM >= text . length ( ) ) { return text . length ( ) + NUM ; } Match Result match = Reg Exp Utils . find Match After Index ( Unicode Utils . regexp Not Mark Or Other Excluding Tab And Newline , text , column ) ; if ( match == null ) { return text . length ( ) + NUM ; } else { return match . get Index ( ) ; } }
public char [ ] to Char Array ( ) { if ( size == NUM ) { return Array Utils . EMPTY CHAR ARRAY ; } final char chars [ ] = new char [ size ] ; System . arraycopy ( buffer , NUM , chars , NUM , size ) ; return chars ; }
public char [ ] to Char Array ( ) { if ( size == NUM ) { return Array Utils . EMPTY CHAR ARRAY ; } final char chars [ ] = new char [ size ] ; System . arraycopy ( buffer , NUM , chars , NUM , size ) ; return chars ; }
public static Big Int [ ] read Array Of Size Big Ints ( Input Stream in ) throws IO Exception { Vector A = new Vector ( ) ; int i = NUM ; try { do { A . add Element ( read Size Big Int ( in ) ) ; i ++ ; } while ( BOOL ) ; } catch ( IO Exception e ) { } Big Int [ ] bA = new Big Int [ i ] ; for ( int j = NUM ; j < i ; j ++ ) bA [ j ] = ( Big Int ) A . element At ( j ) ; return bA ; }
public boolean check Parity ( ) { int len = get Num Data Elements ( ) ; int chksum = NUM ; int loop ; for ( loop = NUM ; loop < len - NUM ; loop ++ ) { chksum ^= get Element ( loop ) ; } return ( ( chksum & NUM ) == get Element ( len - NUM ) ) ; }
public boolean check Parity ( ) { int len = get Num Data Elements ( ) ; int chksum = NUM ; int loop ; for ( loop = NUM ; loop < len - NUM ; loop ++ ) { chksum ^= get Element ( loop ) ; } return ( ( chksum & NUM ) == get Element ( len - NUM ) ) ; }
public void add ( double radians [ ] ) { ESRI Poly new Poly = new ESRI Poly . ESRI Float Poly ( radians ) ; int num Parts = polygons . length ; ESRI Poly old Polys [ ] = polygons ; polygons = new ESRI Poly [ num Parts + NUM ] ; System . arraycopy ( old Polys , NUM , polygons , NUM , num Parts ) ; polygons [ num Parts ] = new Poly ; int len = radians . length ; for ( int i = NUM ; i < len ; i += NUM ) { bounds . add Point ( Proj Math . rad To Deg ( radians [ i + NUM ] ) , Proj Math . rad To Deg ( radians [ i ] ) ) ; } }
public Button Bubble ( Window owner , String next Dockable Key , Aligned Side preferred Alignment , String i18 n Key , String button Key To Attach , boolean add Listener , boolean listen To Perspective , J Button [ ] buttons To Add , Object ... arguments ) { super ( owner , preferred Alignment , i18 n Key , next Dockable Key , buttons To Add , arguments ) ; if ( preferred Alignment != Aligned Side . MIDDLE ) { this . button Key = button Key To Attach ; this . add Listener = add Listener ; if ( button Key == null || button Key . equals ( STRING ) ) { throw new Illegal Argument Exception ( STRING ) ; } else { this . button = Bubble Window . find Button ( button Key , owner ) ; } } set Add Perspective Listener ( listen To Perspective ) ; super . paint ( BOOL ) ; }
private void add Preference Options ( final List < String > opts , I Preference Store store ) { String arg Str = store . get String ( Checker Preferences . PREF CHECKER ARGS ) ; List < Option Line > optionlines = Option Line . parse Options ( arg Str ) ; for ( final Option Line opt Line : optionlines ) { if ( opt Line . is Active ( ) ) { opts . add ( opt Line . get Argument ( ) ) ; } } }
private void add Preference Options ( final List < String > opts , I Preference Store store ) { String arg Str = store . get String ( Checker Preferences . PREF CHECKER ARGS ) ; List < Option Line > optionlines = Option Line . parse Options ( arg Str ) ; for ( final Option Line opt Line : optionlines ) { if ( opt Line . is Active ( ) ) { opts . add ( opt Line . get Argument ( ) ) ; } } }
public String build User ( ) { return properties . get Property ( STRING ) ; }
public static void finish Mock Sleep ( ) { if ( mock Sleep Queue != null ) { mock Sleep Queue . offer ( BOOL ) ; } }
public static void finish Mock Sleep ( ) { if ( mock Sleep Queue != null ) { mock Sleep Queue . offer ( BOOL ) ; } }
public static void finish Mock Sleep ( ) { if ( mock Sleep Queue != null ) { mock Sleep Queue . offer ( BOOL ) ; } }
public static void finish Mock Sleep ( ) { if ( mock Sleep Queue != null ) { mock Sleep Queue . offer ( BOOL ) ; } }
public static final Set < Emoticon > filter By Type ( Set < Emoticon > emotes , Emoticon . Type type ) { Set < Emoticon > filtered = new Hash Set < > ( ) ; for ( Emoticon emote : emotes ) { if ( emote . type == type ) { filtered . add ( emote ) ; } } return filtered ; }
protected void tear Down ( ) throws Exception { stun Stack . remove Socket ( client Address ) ; stun Stack . remove Socket ( server Address ) ; client Sock . close ( ) ; server Sock . close ( ) ; request Collector = null ; response Collector = null ; System . set Property ( Stack Properties . PROPAGATE RECEIVED RETRANSMISSIONS , STRING ) ; System . set Property ( Stack Properties . KEEP CRANS AFTER A RESPONSE , STRING ) ; System . set Property ( Stack Properties . MAX CTRAN RETRANSMISSIONS , STRING ) ; System . set Property ( Stack Properties . MAX CTRAN RETRANS TIMER , STRING ) ; System . set Property ( Stack Properties . FIRST CTRAN RETRANS AFTER , STRING ) ; super . tear Down ( ) ; }
public void action Performed ( Action Event ae ) { long current Time = System . nano Time ( ) / NUM ; long total Time = current Time - anim Start Time ; if ( total Time > animation Duration ) { anim Start Time = current Time ; } float fraction = ( float ) total Time / animation Duration ; fraction = Math . min ( NUM , fraction ) ; int red = ( int ) ( fraction * end Color . get Red ( ) + ( NUM - fraction ) * start Color . get Red ( ) ) ; int green = ( int ) ( fraction * end Color . get Green ( ) + ( NUM - fraction ) * start Color . get Green ( ) ) ; int blue = ( int ) ( fraction * end Color . get Blue ( ) + ( NUM - fraction ) * start Color . get Blue ( ) ) ; current Color = new Color ( red , green , blue ) ; repaint ( ) ; }
public void remove Tab Stop ( int stop ) { tabstops . remove ( stop ) ; }
public boolean has Next ( ) { if ( deal > NUM ) { sc . close ( ) ; } return ( deal <= NUM ) ; }
public boolean has Next ( ) { if ( deal > NUM ) { sc . close ( ) ; } return ( deal <= NUM ) ; }
public static void write Binary File ( final File file , final byte [ ] data ) throws IO Exception { try ( File Output Stream fos = new File Output Stream ( file ) ) { fos . write ( data ) ; } }
public static Date Time to Date Simple ( String str , short converting Type , boolean also Month String , Time Zone time Zone ) throws Page Exception { Date Time dt = to Date Simple ( str , converting Type , also Month String , time Zone , null ) ; if ( dt == null ) throw new Expression Exception ( STRING ) ; return dt ; }
public static Date Time to Date Simple ( String str , short converting Type , boolean also Month String , Time Zone time Zone ) throws Page Exception { Date Time dt = to Date Simple ( str , converting Type , also Month String , time Zone , null ) ; if ( dt == null ) throw new Expression Exception ( STRING ) ; return dt ; }
public void remove Sensor ( Sensor sensor ) { data . remove ( sensor ) ; fire Table Data Changed ( ) ; }
public Visor Log File ( File file ) { this ( file . get Absolute Path ( ) , file . length ( ) , file . last Modified ( ) ) ; }
public boolean remove ( String to Remove ) { String result = m Used Names . remove ( to Remove . to Lower Case ( ) ) ; if ( result != null ) { notify Changed ( ) ; return BOOL ; } return BOOL ; }
private IP Address compute Mask From Network Prefix ( int prefix ) { String Builder str = new String Builder ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { if ( i < prefix ) { str . append ( STRING ) ; } else { str . append ( STRING ) ; } } String decimal String = to Decimal String ( str . to String ( ) ) ; return new IP Address ( decimal String ) ; }
public void update Throughput ( long current Time ) { throughput Calculation Lock . lock ( ) ; try { int interval = ( int ) ( current Time - last Throughput Calculation Time ) ; long min Interval = get Throughput Calculation Interval In Millis ( ) ; if ( ( min Interval == NUM ) || ( interval < min Interval ) ) { return ; } long read Bytes = this . read Bytes ; long written Bytes = this . written Bytes ; long read Messages = this . read Messages ; long written Messages = this . written Messages ; read Bytes Throughput = ( read Bytes - last Read Bytes ) * NUM / interval ; written Bytes Throughput = ( written Bytes - last Written Bytes ) * NUM / interval ; read Messages Throughput = ( read Messages - last Read Messages ) * NUM / interval ; written Messages Throughput = ( written Messages - last Written Messages ) * NUM / interval ; if ( read Bytes Throughput > largest Read Bytes Throughput ) { largest Read Bytes Throughput = read Bytes Throughput ; } if ( written Bytes Throughput > largest Written Bytes Throughput ) { largest Written Bytes Throughput = written Bytes Throughput ; } if ( read Messages Throughput > largest Read Messages Throughput ) { largest Read Messages Throughput = read Messages Throughput ; } if ( written Messages Throughput > largest Written Messages Throughput ) { largest Written Messages Throughput = written Messages Throughput ; } last Read Bytes = read Bytes ; last Written Bytes = written Bytes ; last Read Messages = read Messages ; last Written Messages = written Messages ; last Throughput Calculation Time = current Time ; } finally { throughput Calculation Lock . unlock ( ) ; } }
void strip Non Compiled Nodes ( Node n , Set < String > files To Compile ) { for ( Node child : n . children ( ) ) { if ( ! files To Compile . contains ( child . get Source File Name ( ) ) ) { child . detach From Parent ( ) ; } } }
public void sort ( Comparator < ? super Log Line > comparator ) { this . m Comparator = comparator ; Collections . sort ( m Objects , comparator ) ; if ( m Notify On Change ) notify Data Set Changed ( ) ; }
boolean should EDT Sleep ( ) { Form current = impl . get Current Form ( ) ; return ( ( current == null || ( ! current . has Animations ( ) ) ) && ( animation Queue == null || animation Queue . size ( ) == NUM ) && input Event Stack Pointer == NUM && ( ! impl . has Pending Paints ( ) ) && has No Serial Calls Pending ( ) && ! key Repeat Charged && ! long Pointer Charged ) || ( is Minimized ( ) && has No Serial Calls Pending ( ) ) ; }
boolean should EDT Sleep ( ) { Form current = impl . get Current Form ( ) ; return ( ( current == null || ( ! current . has Animations ( ) ) ) && ( animation Queue == null || animation Queue . size ( ) == NUM ) && input Event Stack Pointer == NUM && ( ! impl . has Pending Paints ( ) ) && has No Serial Calls Pending ( ) && ! key Repeat Charged && ! long Pointer Charged ) || ( is Minimized ( ) && has No Serial Calls Pending ( ) ) ; }
public double evaluate ( Vector Instance x , double [ ] y ) throws Exception { double dot Prod = x . dot Product ( y ) ; return Math . pow ( m gamma * dot Prod + m coef 0 , m degree ) ; }
public void init Combos ( ) { add Combination Values ( STRING , new Object [ ] { STRING , STRING } ) ; add Combination Values ( STRING , new Object [ ] { Integer . value Of ( Delivery Mode . NON PERSISTENT ) , Integer . value Of ( Delivery Mode . PERSISTENT ) } ) ; add Combination Values ( STRING , new Object [ ] { Byte . value Of ( Active MQ Destination . QUEUE TYPE ) } ) ; }
public void init Combos ( ) { add Combination Values ( STRING , new Object [ ] { STRING , STRING } ) ; add Combination Values ( STRING , new Object [ ] { Integer . value Of ( Delivery Mode . NON PERSISTENT ) , Integer . value Of ( Delivery Mode . PERSISTENT ) } ) ; add Combination Values ( STRING , new Object [ ] { Byte . value Of ( Active MQ Destination . QUEUE TYPE ) } ) ; }
public double approximation Distance PAA ( double [ ] ts , int win Size , int paa Size , double norm Threshold ) throws Exception { double res Distance = NUM ; int window Counter = NUM ; double points Per Window = ( double ) win Size / ( double ) paa Size ; for ( int i = NUM ; i < ts . length - win Size + NUM ; i ++ ) { double [ ] subseries = Arrays . copy Of Range ( ts , i , i + win Size ) ; if ( ts Processor . st Dev ( subseries ) > norm Threshold ) { subseries = ts Processor . znorm ( subseries , norm Threshold ) ; } double [ ] paa = ts Processor . paa ( subseries , paa Size ) ; window Counter ++ ; double subsequence Distance = NUM ; for ( int j = NUM ; j < subseries . length ; j ++ ) { int paa Idx = ( int ) Math . floor ( ( ( double ) j + NUM ) / ( double ) points Per Window ) ; if ( paa Idx < NUM ) { paa Idx = NUM ; } if ( paa Idx > paa . length ) { paa Idx = paa . length - NUM ; } subsequence Distance = subsequence Distance + ed . distance ( paa [ paa Idx ] , subseries [ j ] ) ; } res Distance = res Distance + subsequence Distance / subseries . length ; } return res Distance / ( double ) window Counter ; }
private T cache Miss ( final NT nt ) { T resource = null ; final Atomic Reference < I Index Manager > found On = new Atomic Reference < I Index Manager > ( ) ; final Properties properties = locate Resource ( nt . get Name ( ) , nt . get Timestamp ( ) , found On ) ; if ( properties == null ) { if ( delegate != null ) { if ( INFO ) { log . info ( STRING + nt ) ; } resource = delegate . locate ( nt . get Name ( ) , nt . get Timestamp ( ) ) ; if ( resource != null ) { if ( INFO ) { log . info ( STRING + resource ) ; } return resource ; } } return null ; } if ( log . is Debug Enabled ( ) ) { log . debug ( properties . to String ( ) ) ; } final String class Name = properties . get Property ( Relation Schema . CLASS ) ; if ( class Name == null ) { return null ; } final Class < ? extends T > cls ; try { cls = ( Class < ? extends T > ) Class . for Name ( class Name ) ; } catch ( Class Not Found Exception e ) { throw new Runtime Exception ( e ) ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + cls . get Name ( ) ) ; } resource = new Instance ( cls , found On . get ( ) , nt , properties ) ; return resource ; }
static public void pack Int ( Data Output out , int value ) throws IO Exception { int shift = ( value & ~ NUM ) ; if ( shift != NUM ) { shift = NUM - Integer . number Of Leading Zeros ( value ) ; shift -= shift % NUM ; while ( shift != NUM ) { out . write Byte ( ( byte ) ( ( value > > > shift ) & NUM ) ) ; shift -= NUM ; } } out . write Byte ( ( byte ) ( ( value & NUM ) | NUM ) ) ; }
static public void pack Int ( Data Output out , int value ) throws IO Exception { int shift = ( value & ~ NUM ) ; if ( shift != NUM ) { shift = NUM - Integer . number Of Leading Zeros ( value ) ; shift -= shift % NUM ; while ( shift != NUM ) { out . write Byte ( ( byte ) ( ( value > > > shift ) & NUM ) ) ; shift -= NUM ; } } out . write Byte ( ( byte ) ( ( value & NUM ) | NUM ) ) ; }
static public void pack Int ( Data Output out , int value ) throws IO Exception { int shift = ( value & ~ NUM ) ; if ( shift != NUM ) { shift = NUM - Integer . number Of Leading Zeros ( value ) ; shift -= shift % NUM ; while ( shift != NUM ) { out . write Byte ( ( byte ) ( ( value > > > shift ) & NUM ) ) ; shift -= NUM ; } } out . write Byte ( ( byte ) ( ( value & NUM ) | NUM ) ) ; }
private void print Arguments ( List < Expression > args , Object arg ) { printer . print ( STRING ) ; if ( args != null ) { for ( Iterator < Expression > i = args . iterator ( ) ; i . has Next ( ) ; ) { Expression e = i . next ( ) ; e . accept ( this , arg ) ; if ( i . has Next ( ) ) { printer . print ( STRING ) ; } } } printer . print ( STRING ) ; }
private void print Arguments ( List < Expression > args , Object arg ) { printer . print ( STRING ) ; if ( args != null ) { for ( Iterator < Expression > i = args . iterator ( ) ; i . has Next ( ) ; ) { Expression e = i . next ( ) ; e . accept ( this , arg ) ; if ( i . has Next ( ) ) { printer . print ( STRING ) ; } } } printer . print ( STRING ) ; }
public Section Model vend Section ( int page ) { Paged Mock Loader . Section Model section Model = new Paged Mock Loader . Section Model ( STRING + Integer . to String ( page ) ) ; for ( int j = NUM ; j < NUM ; j ++ ) { section Model . add Item ( new Paged Mock Loader . Item Model ( STRING + Integer . to String ( j ) ) ) ; } return section Model ; }
public Section Model vend Section ( int page ) { Paged Mock Loader . Section Model section Model = new Paged Mock Loader . Section Model ( STRING + Integer . to String ( page ) ) ; for ( int j = NUM ; j < NUM ; j ++ ) { section Model . add Item ( new Paged Mock Loader . Item Model ( STRING + Integer . to String ( j ) ) ) ; } return section Model ; }
public final static < T > Stream < T > completable Future To Stream ( final Completable Future < T > future ) { return Stream . of ( future . join ( ) ) ; }
public static boolean delete Files And Dirs Recursive ( final String file ) { if ( Text Utils . is Empty ( file ) ) { Log . e ( File Utils . class , STRING ) ; return BOOL ; } return delete Files And Dirs Recursive ( new File ( file ) ) ; }
public static boolean delete Files And Dirs Recursive ( final String file ) { if ( Text Utils . is Empty ( file ) ) { Log . e ( File Utils . class , STRING ) ; return BOOL ; } return delete Files And Dirs Recursive ( new File ( file ) ) ; }
public static boolean delete Files And Dirs Recursive ( final String file ) { if ( Text Utils . is Empty ( file ) ) { Log . e ( File Utils . class , STRING ) ; return BOOL ; } return delete Files And Dirs Recursive ( new File ( file ) ) ; }
public void test concurrent modification update ( ) { final B Tree btree ; { btree = B Tree . create ( new Simple Memory Raw Store ( ) , new Index Metadata ( UUID . random UUID ( ) ) ) ; btree . insert ( NUM , STRING ) ; btree . insert ( NUM , STRING ) ; btree . insert ( NUM , STRING ) ; } { I Tuple Cursor 2 < String > cursor = new Cursor ( btree ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . seek ( NUM ) ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . tuple ( ) ) ; btree . insert ( NUM , STRING ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . tuple ( ) ) ; } }
public void test concurrent modification update ( ) { final B Tree btree ; { btree = B Tree . create ( new Simple Memory Raw Store ( ) , new Index Metadata ( UUID . random UUID ( ) ) ) ; btree . insert ( NUM , STRING ) ; btree . insert ( NUM , STRING ) ; btree . insert ( NUM , STRING ) ; } { I Tuple Cursor 2 < String > cursor = new Cursor ( btree ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . seek ( NUM ) ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . tuple ( ) ) ; btree . insert ( NUM , STRING ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . tuple ( ) ) ; } }
public void test concurrent modification update ( ) { final B Tree btree ; { btree = B Tree . create ( new Simple Memory Raw Store ( ) , new Index Metadata ( UUID . random UUID ( ) ) ) ; btree . insert ( NUM , STRING ) ; btree . insert ( NUM , STRING ) ; btree . insert ( NUM , STRING ) ; } { I Tuple Cursor 2 < String > cursor = new Cursor ( btree ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . seek ( NUM ) ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . tuple ( ) ) ; btree . insert ( NUM , STRING ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . tuple ( ) ) ; } }
private File create Temp File ( String suffix ) throws IO Exception { String prefix = STRING ; if ( ! Strings . is Null Or Empty ( get Name ( ) ) ) { prefix += get Name ( ) + STRING ; } File tmp = File . create Temp File ( prefix , suffix ) ; to Cleanup . add ( tmp ) ; return tmp ; }
private File create Temp File ( String suffix ) throws IO Exception { String prefix = STRING ; if ( ! Strings . is Null Or Empty ( get Name ( ) ) ) { prefix += get Name ( ) + STRING ; } File tmp = File . create Temp File ( prefix , suffix ) ; to Cleanup . add ( tmp ) ; return tmp ; }
private File create Temp File ( String suffix ) throws IO Exception { String prefix = STRING ; if ( ! Strings . is Null Or Empty ( get Name ( ) ) ) { prefix += get Name ( ) + STRING ; } File tmp = File . create Temp File ( prefix , suffix ) ; to Cleanup . add ( tmp ) ; return tmp ; }
public static int visit ( int x ) { last Visited = x ; return x ; }
private void add Registration Req ( Socket Channel sock Ch ) { offer Balanced ( new Nio Operation Future ( sock Ch ) ) ; }
private void add Registration Req ( Socket Channel sock Ch ) { offer Balanced ( new Nio Operation Future ( sock Ch ) ) ; }
private void add Registration Req ( Socket Channel sock Ch ) { offer Balanced ( new Nio Operation Future ( sock Ch ) ) ; }
@ Nullable E await Match ( int start ) { for ( int step = NUM , total Spins = NUM ; ( step < ARENA LENGTH ) && ( total Spins < SPINS ) ; step ++ ) { int index = ( start + step ) & ARENA MASK ; Atomic Reference < Object > slot = arena [ index ] ; Object found = slot . get ( ) ; if ( found == FREE ) { if ( slot . compare And Set ( FREE , WAITER ) ) { int slot Spins = NUM ; for ( ; ; ) { found = slot . get ( ) ; if ( ( found != WAITER ) && slot . compare And Set ( found , FREE ) ) { @ Suppress Warnings ( STRING ) E e = ( E ) found ; return e ; } else if ( ( slot Spins >= SPINS PER STEP ) && ( found == WAITER ) && ( slot . compare And Set ( WAITER , FREE ) ) ) { total Spins += slot Spins ; break ; } slot Spins ++ ; } } } else if ( ( found != WAITER ) && slot . compare And Set ( found , FREE ) ) { @ Suppress Warnings ( STRING ) E e = ( E ) found ; return e ; } } return null ; }
@ Nullable E await Match ( int start ) { for ( int step = NUM , total Spins = NUM ; ( step < ARENA LENGTH ) && ( total Spins < SPINS ) ; step ++ ) { int index = ( start + step ) & ARENA MASK ; Atomic Reference < Object > slot = arena [ index ] ; Object found = slot . get ( ) ; if ( found == FREE ) { if ( slot . compare And Set ( FREE , WAITER ) ) { int slot Spins = NUM ; for ( ; ; ) { found = slot . get ( ) ; if ( ( found != WAITER ) && slot . compare And Set ( found , FREE ) ) { @ Suppress Warnings ( STRING ) E e = ( E ) found ; return e ; } else if ( ( slot Spins >= SPINS PER STEP ) && ( found == WAITER ) && ( slot . compare And Set ( WAITER , FREE ) ) ) { total Spins += slot Spins ; break ; } slot Spins ++ ; } } } else if ( ( found != WAITER ) && slot . compare And Set ( found , FREE ) ) { @ Suppress Warnings ( STRING ) E e = ( E ) found ; return e ; } } return null ; }
@ Nullable E await Match ( int start ) { for ( int step = NUM , total Spins = NUM ; ( step < ARENA LENGTH ) && ( total Spins < SPINS ) ; step ++ ) { int index = ( start + step ) & ARENA MASK ; Atomic Reference < Object > slot = arena [ index ] ; Object found = slot . get ( ) ; if ( found == FREE ) { if ( slot . compare And Set ( FREE , WAITER ) ) { int slot Spins = NUM ; for ( ; ; ) { found = slot . get ( ) ; if ( ( found != WAITER ) && slot . compare And Set ( found , FREE ) ) { @ Suppress Warnings ( STRING ) E e = ( E ) found ; return e ; } else if ( ( slot Spins >= SPINS PER STEP ) && ( found == WAITER ) && ( slot . compare And Set ( WAITER , FREE ) ) ) { total Spins += slot Spins ; break ; } slot Spins ++ ; } } } else if ( ( found != WAITER ) && slot . compare And Set ( found , FREE ) ) { @ Suppress Warnings ( STRING ) E e = ( E ) found ; return e ; } } return null ; }
@ Nullable E await Match ( int start ) { for ( int step = NUM , total Spins = NUM ; ( step < ARENA LENGTH ) && ( total Spins < SPINS ) ; step ++ ) { int index = ( start + step ) & ARENA MASK ; Atomic Reference < Object > slot = arena [ index ] ; Object found = slot . get ( ) ; if ( found == FREE ) { if ( slot . compare And Set ( FREE , WAITER ) ) { int slot Spins = NUM ; for ( ; ; ) { found = slot . get ( ) ; if ( ( found != WAITER ) && slot . compare And Set ( found , FREE ) ) { @ Suppress Warnings ( STRING ) E e = ( E ) found ; return e ; } else if ( ( slot Spins >= SPINS PER STEP ) && ( found == WAITER ) && ( slot . compare And Set ( WAITER , FREE ) ) ) { total Spins += slot Spins ; break ; } slot Spins ++ ; } } } else if ( ( found != WAITER ) && slot . compare And Set ( found , FREE ) ) { @ Suppress Warnings ( STRING ) E e = ( E ) found ; return e ; } } return null ; }
@ Nullable E await Match ( int start ) { for ( int step = NUM , total Spins = NUM ; ( step < ARENA LENGTH ) && ( total Spins < SPINS ) ; step ++ ) { int index = ( start + step ) & ARENA MASK ; Atomic Reference < Object > slot = arena [ index ] ; Object found = slot . get ( ) ; if ( found == FREE ) { if ( slot . compare And Set ( FREE , WAITER ) ) { int slot Spins = NUM ; for ( ; ; ) { found = slot . get ( ) ; if ( ( found != WAITER ) && slot . compare And Set ( found , FREE ) ) { @ Suppress Warnings ( STRING ) E e = ( E ) found ; return e ; } else if ( ( slot Spins >= SPINS PER STEP ) && ( found == WAITER ) && ( slot . compare And Set ( WAITER , FREE ) ) ) { total Spins += slot Spins ; break ; } slot Spins ++ ; } } } else if ( ( found != WAITER ) && slot . compare And Set ( found , FREE ) ) { @ Suppress Warnings ( STRING ) E e = ( E ) found ; return e ; } } return null ; }
@ Nullable E await Match ( int start ) { for ( int step = NUM , total Spins = NUM ; ( step < ARENA LENGTH ) && ( total Spins < SPINS ) ; step ++ ) { int index = ( start + step ) & ARENA MASK ; Atomic Reference < Object > slot = arena [ index ] ; Object found = slot . get ( ) ; if ( found == FREE ) { if ( slot . compare And Set ( FREE , WAITER ) ) { int slot Spins = NUM ; for ( ; ; ) { found = slot . get ( ) ; if ( ( found != WAITER ) && slot . compare And Set ( found , FREE ) ) { @ Suppress Warnings ( STRING ) E e = ( E ) found ; return e ; } else if ( ( slot Spins >= SPINS PER STEP ) && ( found == WAITER ) && ( slot . compare And Set ( WAITER , FREE ) ) ) { total Spins += slot Spins ; break ; } slot Spins ++ ; } } } else if ( ( found != WAITER ) && slot . compare And Set ( found , FREE ) ) { @ Suppress Warnings ( STRING ) E e = ( E ) found ; return e ; } } return null ; }
public static final String hash Key For Disk ( final String key ) { String cache Key ; try { final Message Digest digest = Message Digest . get Instance ( STRING ) ; digest . update ( key . get Bytes ( ) ) ; cache Key = bytes To Hex String ( digest . digest ( ) ) ; } catch ( final No Such Algorithm Exception e ) { cache Key = String . value Of ( key . hash Code ( ) ) ; } return cache Key ; }
public static final String hash Key For Disk ( final String key ) { String cache Key ; try { final Message Digest digest = Message Digest . get Instance ( STRING ) ; digest . update ( key . get Bytes ( ) ) ; cache Key = bytes To Hex String ( digest . digest ( ) ) ; } catch ( final No Such Algorithm Exception e ) { cache Key = String . value Of ( key . hash Code ( ) ) ; } return cache Key ; }
public void send Request Vote Request ( boolean is Prevote ) throws Gondola Exception { if ( ! enabled || master Id >= NUM ) { return ; } if ( ! is Prevote ) { current Term ++ ; voted For = - NUM ; save ( current Term , member Id ) ; voted For = member Id ; } prevotes Only = is Prevote ; Message message = pool . checkout ( ) ; try { save Queue . get Latest ( saved Rid ) ; message . request Vote Request ( member Id , current Term , is Prevote , saved Rid ) ; peers . for Each ( null ) ; } finally { message . release ( ) ; } prevote Ts = clock . now ( ) + ( long ) ( ( Math . random ( ) * prevote Period ) ) ; if ( ! is Prevote ) { prevote Ts += election Timeout ; } }
public Client Properties Builder with Proxy Host Name ( String proxy Host Name ) { properties . set Property ( CLIENT SERVICE PROXY HOST NAME , proxy Host Name ) ; return this ; }
public Client Properties Builder with Proxy Host Name ( String proxy Host Name ) { properties . set Property ( CLIENT SERVICE PROXY HOST NAME , proxy Host Name ) ; return this ; }
public Specification Runner Builder sections ( String [ ] param Sections ) { Collections . add All ( this . sections , param Sections ) ; return this ; }
public Specification Runner Builder sections ( String [ ] param Sections ) { Collections . add All ( this . sections , param Sections ) ; return this ; }
public Specification Runner Builder sections ( String [ ] param Sections ) { Collections . add All ( this . sections , param Sections ) ; return this ; }
public Specification Runner Builder sections ( String [ ] param Sections ) { Collections . add All ( this . sections , param Sections ) ; return this ; }
public Specification Runner Builder sections ( String [ ] param Sections ) { Collections . add All ( this . sections , param Sections ) ; return this ; }
private void show Popup Menu ( final Mouse Event event ) { final Icon Node selected Node = ( Icon Node ) Tree Helpers . get Node At ( references Table , event . get X ( ) , event . get Y ( ) ) ; if ( selected Node != null ) { final J Popup Menu menu = create Popup Menu ( selected Node ) ; if ( menu != null ) { menu . show ( references Table , event . get X ( ) , event . get Y ( ) ) ; } } }
public HTML Strip Char Filter Factory ( Map < String , String > args ) { super ( args ) ; escaped Tags = get Set ( args , STRING ) ; if ( ! args . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING + args ) ; } }
public static long current Time ( ) { if ( test Time > NUM ) return test Time ; else return System . current Time Millis ( ) ; }
public void on Call Back ( Bundle bundle ) { Message msg = m Handler . obtain Message ( bundle . get Int ( Fm Radio Listener . CALLBACK FLAG ) ) ; msg . set Data ( bundle ) ; m Handler . send Message ( msg ) ; }
public static Shopping Cart make Shopping List Cart ( Local Dispatcher dispatcher , Generic Value shopping List , Locale locale ) { return make Shopping List Cart ( null , dispatcher , shopping List , locale ) ; }
private String Builder create Indent ( int indent ) { String Builder one Indent = create Indent ( ) ; String Builder ret = new String Builder ( ) ; while ( indent -- > NUM ) { ret . append ( one Indent ) ; } return ret ; }
private String Builder create Indent ( int indent ) { String Builder one Indent = create Indent ( ) ; String Builder ret = new String Builder ( ) ; while ( indent -- > NUM ) { ret . append ( one Indent ) ; } return ret ; }
private String Builder create Indent ( int indent ) { String Builder one Indent = create Indent ( ) ; String Builder ret = new String Builder ( ) ; while ( indent -- > NUM ) { ret . append ( one Indent ) ; } return ret ; }
public static Low Memory Watcher register ( @ Not Null Runnable runnable ) { return new Low Memory Watcher ( runnable ) ; }
@ Transactional ( read Only = BOOL ) public Bag Count [ ] check Filtered Bag Counts ( String filter Text ) { Typed Query < Bag Count > query = my EM . create Named Query ( STRING , Bag Count . class ) ; query . set Parameter ( STRING , filter Text ) ; List < Bag Count > results = query . get Result List ( ) ; return results . to Array ( new Bag Count [ results . size ( ) ] ) ; }
@ Transactional ( read Only = BOOL ) public Bag Count [ ] check Filtered Bag Counts ( String filter Text ) { Typed Query < Bag Count > query = my EM . create Named Query ( STRING , Bag Count . class ) ; query . set Parameter ( STRING , filter Text ) ; List < Bag Count > results = query . get Result List ( ) ; return results . to Array ( new Bag Count [ results . size ( ) ] ) ; }
public void dup 2 X 1 ( ) { mv . visit Insn ( Opcodes . DUP 2 X1 ) ; }
@ Override public boolean has Delta ( ) { return is Dirty ; }
@ Override public boolean has Delta ( ) { return is Dirty ; }
public static double abs 1 ( Z z ) { return Math . abs ( z . re ) + Math . abs ( z . im ) ; }
public static int read Bytes ( Input Stream in , byte [ ] byte Array ) throws IO Exception { int total Bytes Read = NUM ; int bytes Read = in . read ( byte Array ) ; while ( bytes Read >= NUM ) { total Bytes Read += bytes Read ; if ( total Bytes Read == byte Array . length ) { break ; } bytes Read = in . read ( byte Array , total Bytes Read , byte Array . length - total Bytes Read ) ; } return total Bytes Read ; }
public static int read Bytes ( Input Stream in , byte [ ] byte Array ) throws IO Exception { int total Bytes Read = NUM ; int bytes Read = in . read ( byte Array ) ; while ( bytes Read >= NUM ) { total Bytes Read += bytes Read ; if ( total Bytes Read == byte Array . length ) { break ; } bytes Read = in . read ( byte Array , total Bytes Read , byte Array . length - total Bytes Read ) ; } return total Bytes Read ; }
public static int read Bytes ( Input Stream in , byte [ ] byte Array ) throws IO Exception { int total Bytes Read = NUM ; int bytes Read = in . read ( byte Array ) ; while ( bytes Read >= NUM ) { total Bytes Read += bytes Read ; if ( total Bytes Read == byte Array . length ) { break ; } bytes Read = in . read ( byte Array , total Bytes Read , byte Array . length - total Bytes Read ) ; } return total Bytes Read ; }
public static int read Bytes ( Input Stream in , byte [ ] byte Array ) throws IO Exception { int total Bytes Read = NUM ; int bytes Read = in . read ( byte Array ) ; while ( bytes Read >= NUM ) { total Bytes Read += bytes Read ; if ( total Bytes Read == byte Array . length ) { break ; } bytes Read = in . read ( byte Array , total Bytes Read , byte Array . length - total Bytes Read ) ; } return total Bytes Read ; }
public static int read Bytes ( Input Stream in , byte [ ] byte Array ) throws IO Exception { int total Bytes Read = NUM ; int bytes Read = in . read ( byte Array ) ; while ( bytes Read >= NUM ) { total Bytes Read += bytes Read ; if ( total Bytes Read == byte Array . length ) { break ; } bytes Read = in . read ( byte Array , total Bytes Read , byte Array . length - total Bytes Read ) ; } return total Bytes Read ; }
public static Object constraint ( S Layout ... flags ) { Enum Set < S Layout > obj = Enum Set . none Of ( S Layout . class ) ; for ( S Layout flag : flags ) { obj . add ( flag ) ; } return obj ; }
public static int color ( Color c ) { return c . get RGB ( ) ; }
public Selection Builder reset ( ) { m Table = null ; m Group By = null ; m Having = null ; m Selection . set Length ( NUM ) ; m Selection Args . clear ( ) ; return this ; }
public Vec sorted Copy ( ) { double [ ] array Copy = array Copy ( ) ; Arrays . sort ( array Copy ) ; return new Dense Vector ( array Copy ) ; }
public Vec sorted Copy ( ) { double [ ] array Copy = array Copy ( ) ; Arrays . sort ( array Copy ) ; return new Dense Vector ( array Copy ) ; }
public boolean is Standard Module ( String module Name ) { return BOOL ; }
public boolean is Standard Module ( String module Name ) { return BOOL ; }
public boolean is Standard Module ( String module Name ) { return BOOL ; }
public boolean is Standard Module ( String module Name ) { return BOOL ; }
public boolean is Standard Module ( String module Name ) { return BOOL ; }
public boolean is Standard Module ( String module Name ) { return BOOL ; }
public C Function Selection Tree ( final I Database database , final I Action Provider action Provider ) { Preconditions . check Not Null ( database , STRING ) ; Preconditions . check Not Null ( action Provider , STRING ) ; final Default Tree Model model = new Default Tree Model ( null ) ; set Model ( model ) ; set Root Visible ( BOOL ) ; model . set Root ( new C Root Node ( database , model , action Provider ) ) ; set Cell Renderer ( new Icon Node Renderer ( ) ) ; add Mouse Listener ( new Internal Mouse Listener ( ) ) ; }
public static Long to Long ( char c ) { return Long . value Of ( to Long Value ( c ) ) ; }
protected void close Channel ( Socket Channel channel ) { if ( channel == null ) return ; Socket socket = channel . socket ( ) ; try { socket . shutdown Input ( ) ; socket . shutdown Output ( ) ; socket . close ( ) ; } catch ( IO Exception ex ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING , ex ) ; } } finally { try { channel . close ( ) ; } catch ( IO Exception ex ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING , ex ) ; } } } }
public void clear ( ) { cart Item Map . clear ( ) ; total Price = Big Decimal . ZERO ; total Quantity = NUM ; }
public static int send Char ( byte tx Char ) throws IO Exception { log . trace ( String . format ( STRING , ( byte ) tx Char ) ) ; int result = send Char ( serial Port Descriptor , ( char ) tx Char ) ; if ( result < NUM ) { throw new IO Exception ( String . format ( STRING , result ) ) ; } return result ; }
protected static final int inch As Pixel ( double in , int dpi ) { return ( int ) Math . round ( dpi * in ) ; }
public Future < Sync Reply > send Request ( int xid , Sync Message request ) throws Remote Store Exception { ensure Connected ( ) ; Remote Sync Future future = new Remote Sync Future ( xid , connection Generation ) ; future Map . put ( Integer . value Of ( xid ) , future ) ; if ( future Map . size ( ) > MAX PENDING REQUESTS ) { synchronized ( future Notify ) { while ( future Map . size ( ) > MAX PENDING REQUESTS ) { try { future Notify . wait ( ) ; } catch ( Interrupted Exception e ) { throw new Remote Store Exception ( STRING , e ) ; } } } } channel . write And Flush ( request ) ; return future ; }
public Future < Sync Reply > send Request ( int xid , Sync Message request ) throws Remote Store Exception { ensure Connected ( ) ; Remote Sync Future future = new Remote Sync Future ( xid , connection Generation ) ; future Map . put ( Integer . value Of ( xid ) , future ) ; if ( future Map . size ( ) > MAX PENDING REQUESTS ) { synchronized ( future Notify ) { while ( future Map . size ( ) > MAX PENDING REQUESTS ) { try { future Notify . wait ( ) ; } catch ( Interrupted Exception e ) { throw new Remote Store Exception ( STRING , e ) ; } } } } channel . write And Flush ( request ) ; return future ; }
public Future < Sync Reply > send Request ( int xid , Sync Message request ) throws Remote Store Exception { ensure Connected ( ) ; Remote Sync Future future = new Remote Sync Future ( xid , connection Generation ) ; future Map . put ( Integer . value Of ( xid ) , future ) ; if ( future Map . size ( ) > MAX PENDING REQUESTS ) { synchronized ( future Notify ) { while ( future Map . size ( ) > MAX PENDING REQUESTS ) { try { future Notify . wait ( ) ; } catch ( Interrupted Exception e ) { throw new Remote Store Exception ( STRING , e ) ; } } } } channel . write And Flush ( request ) ; return future ; }
public Future < Sync Reply > send Request ( int xid , Sync Message request ) throws Remote Store Exception { ensure Connected ( ) ; Remote Sync Future future = new Remote Sync Future ( xid , connection Generation ) ; future Map . put ( Integer . value Of ( xid ) , future ) ; if ( future Map . size ( ) > MAX PENDING REQUESTS ) { synchronized ( future Notify ) { while ( future Map . size ( ) > MAX PENDING REQUESTS ) { try { future Notify . wait ( ) ; } catch ( Interrupted Exception e ) { throw new Remote Store Exception ( STRING , e ) ; } } } } channel . write And Flush ( request ) ; return future ; }
public Future < Sync Reply > send Request ( int xid , Sync Message request ) throws Remote Store Exception { ensure Connected ( ) ; Remote Sync Future future = new Remote Sync Future ( xid , connection Generation ) ; future Map . put ( Integer . value Of ( xid ) , future ) ; if ( future Map . size ( ) > MAX PENDING REQUESTS ) { synchronized ( future Notify ) { while ( future Map . size ( ) > MAX PENDING REQUESTS ) { try { future Notify . wait ( ) ; } catch ( Interrupted Exception e ) { throw new Remote Store Exception ( STRING , e ) ; } } } } channel . write And Flush ( request ) ; return future ; }
public Respoke Client create Client ( Context app Context ) { context = app Context ; Respoke Client new Client = new Respoke Client ( ) ; instances . add ( new Client ) ; return new Client ; }
public Respoke Client create Client ( Context app Context ) { context = app Context ; Respoke Client new Client = new Respoke Client ( ) ; instances . add ( new Client ) ; return new Client ; }
public Respoke Client create Client ( Context app Context ) { context = app Context ; Respoke Client new Client = new Respoke Client ( ) ; instances . add ( new Client ) ; return new Client ; }
public Respoke Client create Client ( Context app Context ) { context = app Context ; Respoke Client new Client = new Respoke Client ( ) ; instances . add ( new Client ) ; return new Client ; }
public Respoke Client create Client ( Context app Context ) { context = app Context ; Respoke Client new Client = new Respoke Client ( ) ; instances . add ( new Client ) ; return new Client ; }
public Respoke Client create Client ( Context app Context ) { context = app Context ; Respoke Client new Client = new Respoke Client ( ) ; instances . add ( new Client ) ; return new Client ; }
public Respoke Client create Client ( Context app Context ) { context = app Context ; Respoke Client new Client = new Respoke Client ( ) ; instances . add ( new Client ) ; return new Client ; }
public Respoke Client create Client ( Context app Context ) { context = app Context ; Respoke Client new Client = new Respoke Client ( ) ; instances . add ( new Client ) ; return new Client ; }
public void reset ( ) { if ( my Watcher != null ) { my Watcher . stop ( ) ; } initialize ( ) ; }
public void reset ( ) { if ( my Watcher != null ) { my Watcher . stop ( ) ; } initialize ( ) ; }
public void reset ( ) { if ( my Watcher != null ) { my Watcher . stop ( ) ; } initialize ( ) ; }
private void sleep Past Refresh Interval ( ) throws Exception { logger . debug ( STRING + REFRESH INTERVAL SECS + STRING ) ; Thread . sleep ( REFRESH INTERVAL SECS * NUM ) ; }
private void sleep Past Refresh Interval ( ) throws Exception { logger . debug ( STRING + REFRESH INTERVAL SECS + STRING ) ; Thread . sleep ( REFRESH INTERVAL SECS * NUM ) ; }
@ Override public void on Click ( Dialog Interface dialog , int which ) { m Listener . on New Sequence Dialog Accept ( edit Text . get Text ( ) ) ; }
@ Override protected void open Visible Instances ( Instances insts ) throws Exception { super . open Visible Instances ( insts ) ; set ROC String ( STRING + Utils . double To String ( Threshold Curve . get ROC Area ( insts ) , NUM ) + STRING ) ; set Border Text ( ) ; }
private void do Delete ( Script Step step ) { if ( aggregator Editor . is Aggregator ( step ) ) { Script Step step Pair = aggregator Editor . get Aggregator Pair ( step ) ; steps . remove ( step Pair ) ; search Bean . remove From Search Match ( step Pair ) ; } steps . remove ( step ) ; search Bean . remove From Search Match ( step ) ; reindex Script Steps ( ) ; }
protected boolean is Whitespace ( char ch ) { return ( ( ch == STRING ) || Character . is Space Char ( ch ) ) ; }
protected boolean is Whitespace ( char ch ) { return ( ( ch == STRING ) || Character . is Space Char ( ch ) ) ; }
protected boolean is Whitespace ( char ch ) { return ( ( ch == STRING ) || Character . is Space Char ( ch ) ) ; }
protected boolean is Whitespace ( char ch ) { return ( ( ch == STRING ) || Character . is Space Char ( ch ) ) ; }
protected boolean is Whitespace ( char ch ) { return ( ( ch == STRING ) || Character . is Space Char ( ch ) ) ; }
public void write To File ( File filename ) throws IO Exception { File Utils . string To File ( m Text . to String ( ) , filename ) ; }
public static String find Edit Table ( String tables ) { if ( ! Sql Utils . is Empty ( tables ) ) { int spacepos = tables . index Of ( STRING ) ; int commapos = tables . index Of ( STRING ) ; if ( spacepos > NUM && ( spacepos < commapos || commapos < NUM ) ) { return tables . substring ( NUM , spacepos ) ; } else if ( commapos > NUM && ( commapos < spacepos || spacepos < NUM ) ) { return tables . substring ( NUM , commapos ) ; } return tables ; } else { throw new Illegal State Exception ( STRING ) ; } }
private byte [ ] update No Dictionary Start And End Key ( byte [ ] key ) { if ( key . length == NUM ) { return key ; } Byte Buffer buffer = Byte Buffer . wrap ( key , NUM , key . length - NUM ) ; Byte Buffer output = Byte Buffer . allocate ( key . length - NUM ) ; short number Of Byte To Stor Length = NUM ; for ( int i = NUM ; i < number Of No Dictionary Column ; i ++ ) { output . put Short ( ( short ) ( buffer . get Short ( ) - number Of Byte To Stor Length ) ) ; } while ( buffer . has Remaining ( ) ) { output . put ( buffer . get ( ) ) ; } output . rewind ( ) ; return output . array ( ) ; }
private byte [ ] update No Dictionary Start And End Key ( byte [ ] key ) { if ( key . length == NUM ) { return key ; } Byte Buffer buffer = Byte Buffer . wrap ( key , NUM , key . length - NUM ) ; Byte Buffer output = Byte Buffer . allocate ( key . length - NUM ) ; short number Of Byte To Stor Length = NUM ; for ( int i = NUM ; i < number Of No Dictionary Column ; i ++ ) { output . put Short ( ( short ) ( buffer . get Short ( ) - number Of Byte To Stor Length ) ) ; } while ( buffer . has Remaining ( ) ) { output . put ( buffer . get ( ) ) ; } output . rewind ( ) ; return output . array ( ) ; }
public void test File Directory ( ) throws Exception { Properties properties = load Properties ( STRING ) ; assert Equals ( STRING , properties . get Property ( STRING ) ) ; }
public void add Tables ( Collection < Table > tables ) { for ( Iterator < Table > it = tables . iterator ( ) ; it . has Next ( ) ; ) { add Table ( ( Table ) it . next ( ) ) ; } }
private void compute Default Filters ( File indicator File , Json Object json Obj ) { default Filters = new Array List < Filter > ( ) ; Json Array filter Array = Utils . get Field Value As Array ( json Obj , STRING ) ; if ( filter Array != null ) { Set < String > filter Fields = Utils . get All Filter Fields ( json Obj ) ; for ( int i = NUM ; i < filter Array . size ( ) ; i ++ ) { Json Element filter Elt = filter Array . get ( i ) ; Filter filter ; try { filter = Filter . parse ( filter Elt , filter Fields ) ; default Filters . add ( filter ) ; } catch ( Filter Parse Exception e ) { String title = STRING ; String msg = STRING + indicator File ; Droidsafe Plugin Utilities . show Error ( title , msg , e ) ; ; e . print Stack Trace ( ) ; } } } }
public void record ( int time sec ) { this . count ++ ; this . total time sec += time sec ; if ( this . min time sec < NUM ) this . min time sec = time sec ; else this . min time sec = Math . min ( this . min time sec , time sec ) ; this . max time sec = Math . max ( this . max time sec , time sec ) ; }
public void record ( int time sec ) { this . count ++ ; this . total time sec += time sec ; if ( this . min time sec < NUM ) this . min time sec = time sec ; else this . min time sec = Math . min ( this . min time sec , time sec ) ; this . max time sec = Math . max ( this . max time sec , time sec ) ; }
public void test To Big Integer Pos 1 ( ) { String a = STRING ; Big Integer b Number = new Big Integer ( STRING ) ; Big Decimal a Number = new Big Decimal ( a ) ; Big Integer result = a Number . to Big Integer ( ) ; assert True ( STRING , result . equals ( b Number ) ) ; }
public void test Number To String Locale ( ) { Locale default Locale = Locale . get Default ( ) ; Locale . set Default ( Locale . US ) ; Number Converter converter = make Converter ( ) ; converter . set Use Locale Format ( BOOL ) ; assert Equals ( STRING + numbers [ NUM ] , STRING , converter . convert ( String . class , numbers [ NUM ] ) ) ; assert Equals ( STRING + numbers [ NUM ] , STRING , converter . convert ( String . class , numbers [ NUM ] ) ) ; converter . set Locale ( Locale . GERMAN ) ; assert Equals ( STRING + numbers [ NUM ] , STRING , converter . convert ( String . class , numbers [ NUM ] ) ) ; assert Equals ( STRING + numbers [ NUM ] , STRING , converter . convert ( String . class , numbers [ NUM ] ) ) ; Locale . set Default ( default Locale ) ; }
public Mersenne Twister ( ) { mt = new int [ N ] ; set Seed ( System . current Time Millis ( ) + System . identity Hash Code ( this ) ) ; }
public Mersenne Twister ( ) { mt = new int [ N ] ; set Seed ( System . current Time Millis ( ) + System . identity Hash Code ( this ) ) ; }
public void begin Display ( Display Event event ) throws Model Control Exception { super . begin Display ( event ) ; Server Site Model model = ( Server Site Model ) get Model ( ) ; String server Name = ( String ) get Page Session Attribute ( PG ATTR SERVER NAME ) ; Object [ ] param = { server Name } ; pt Model . set Page Title Text ( Message Format . format ( model . get Localized String ( STRING ) , param ) ) ; set Display Field Value ( STRING , Message Format . format ( model . get Localized String ( STRING ) , param ) ) ; }
public static void reconcile Export Groups HL Us ( Db Client db Client , Export Group export Group ) { List < String > eg Volumes Without HL Us = find Volumes Without HL Us ( export Group ) ; if ( ! eg Volumes Without HL Us . is Empty ( ) ) { for ( Export Mask this Mask : Export Mask Utils . get Export Masks ( db Client , export Group ) ) { Iterator < String > volume Iter = eg Volumes Without HL Us . iterator ( ) ; while ( volume Iter . has Next ( ) ) { URI volume URI = URI . create ( volume Iter . next ( ) ) ; if ( this Mask . has Volume ( volume URI ) ) { String hlu = this Mask . return Volume HLU ( volume URI ) ; if ( hlu != Export Group . LUN UNASSIGNED DECIMAL STR ) { log . info ( String . format ( STRING , export Group . get Label ( ) , export Group . get Id ( ) , volume URI , hlu ) ) ; export Group . add Volume ( volume URI , Integer . value Of ( hlu ) ) ; volume Iter . remove ( ) ; } } } } } }
public static void reconcile Export Groups HL Us ( Db Client db Client , Export Group export Group ) { List < String > eg Volumes Without HL Us = find Volumes Without HL Us ( export Group ) ; if ( ! eg Volumes Without HL Us . is Empty ( ) ) { for ( Export Mask this Mask : Export Mask Utils . get Export Masks ( db Client , export Group ) ) { Iterator < String > volume Iter = eg Volumes Without HL Us . iterator ( ) ; while ( volume Iter . has Next ( ) ) { URI volume URI = URI . create ( volume Iter . next ( ) ) ; if ( this Mask . has Volume ( volume URI ) ) { String hlu = this Mask . return Volume HLU ( volume URI ) ; if ( hlu != Export Group . LUN UNASSIGNED DECIMAL STR ) { log . info ( String . format ( STRING , export Group . get Label ( ) , export Group . get Id ( ) , volume URI , hlu ) ) ; export Group . add Volume ( volume URI , Integer . value Of ( hlu ) ) ; volume Iter . remove ( ) ; } } } } } }
public static void reconcile Export Groups HL Us ( Db Client db Client , Export Group export Group ) { List < String > eg Volumes Without HL Us = find Volumes Without HL Us ( export Group ) ; if ( ! eg Volumes Without HL Us . is Empty ( ) ) { for ( Export Mask this Mask : Export Mask Utils . get Export Masks ( db Client , export Group ) ) { Iterator < String > volume Iter = eg Volumes Without HL Us . iterator ( ) ; while ( volume Iter . has Next ( ) ) { URI volume URI = URI . create ( volume Iter . next ( ) ) ; if ( this Mask . has Volume ( volume URI ) ) { String hlu = this Mask . return Volume HLU ( volume URI ) ; if ( hlu != Export Group . LUN UNASSIGNED DECIMAL STR ) { log . info ( String . format ( STRING , export Group . get Label ( ) , export Group . get Id ( ) , volume URI , hlu ) ) ; export Group . add Volume ( volume URI , Integer . value Of ( hlu ) ) ; volume Iter . remove ( ) ; } } } } } }
private Object execute Stellar ( String expression ) { Object result = null ; try { result = executor . execute ( expression ) ; } catch ( Throwable t ) { write Line ( ERROR PROMPT + t . get Message ( ) ) ; t . print Stack Trace ( ) ; } return result ; }
protected Key Factory ( Key Factory Spi key Fac Spi , Provider provider , String algorithm ) { this . spi = key Fac Spi ; this . provider = provider ; this . algorithm = algorithm ; }
private static Query Task build Registry Query By Group ( String tenant Link ) { Query group Clause = Query Util . add Tenant Group And User Clause ( tenant Link ) ; return build Registry Query ( group Clause ) ; }
public synchronized void new Pixels ( int x , int y , int w , int h , boolean framenotify ) { if ( animating ) { if ( fullbuffers ) { x = y = NUM ; w = width ; h = height ; } else { if ( x < NUM ) { w += x ; x = NUM ; } if ( x + w > width ) { w = width - x ; } if ( y < NUM ) { h += y ; y = NUM ; } if ( y + h > height ) { h = height - y ; } } if ( ( w <= NUM || h <= NUM ) && ! framenotify ) { return ; } Enumeration enum = the Consumers . elements ( ) ; while ( enum . has More Elements ( ) ) { Image Consumer ic = ( Image Consumer ) enum . next Element ( ) ; if ( w > NUM && h > NUM ) { send Pixels ( ic , x , y , w , h ) ; } if ( framenotify && is Consumer ( ic ) ) { ic . image Complete ( Image Consumer . SINGLEFRAMEDONE ) ; } } } }
public synchronized void new Pixels ( int x , int y , int w , int h , boolean framenotify ) { if ( animating ) { if ( fullbuffers ) { x = y = NUM ; w = width ; h = height ; } else { if ( x < NUM ) { w += x ; x = NUM ; } if ( x + w > width ) { w = width - x ; } if ( y < NUM ) { h += y ; y = NUM ; } if ( y + h > height ) { h = height - y ; } } if ( ( w <= NUM || h <= NUM ) && ! framenotify ) { return ; } Enumeration enum = the Consumers . elements ( ) ; while ( enum . has More Elements ( ) ) { Image Consumer ic = ( Image Consumer ) enum . next Element ( ) ; if ( w > NUM && h > NUM ) { send Pixels ( ic , x , y , w , h ) ; } if ( framenotify && is Consumer ( ic ) ) { ic . image Complete ( Image Consumer . SINGLEFRAMEDONE ) ; } } } }
public synchronized void new Pixels ( int x , int y , int w , int h , boolean framenotify ) { if ( animating ) { if ( fullbuffers ) { x = y = NUM ; w = width ; h = height ; } else { if ( x < NUM ) { w += x ; x = NUM ; } if ( x + w > width ) { w = width - x ; } if ( y < NUM ) { h += y ; y = NUM ; } if ( y + h > height ) { h = height - y ; } } if ( ( w <= NUM || h <= NUM ) && ! framenotify ) { return ; } Enumeration enum = the Consumers . elements ( ) ; while ( enum . has More Elements ( ) ) { Image Consumer ic = ( Image Consumer ) enum . next Element ( ) ; if ( w > NUM && h > NUM ) { send Pixels ( ic , x , y , w , h ) ; } if ( framenotify && is Consumer ( ic ) ) { ic . image Complete ( Image Consumer . SINGLEFRAMEDONE ) ; } } } }
public synchronized void new Pixels ( int x , int y , int w , int h , boolean framenotify ) { if ( animating ) { if ( fullbuffers ) { x = y = NUM ; w = width ; h = height ; } else { if ( x < NUM ) { w += x ; x = NUM ; } if ( x + w > width ) { w = width - x ; } if ( y < NUM ) { h += y ; y = NUM ; } if ( y + h > height ) { h = height - y ; } } if ( ( w <= NUM || h <= NUM ) && ! framenotify ) { return ; } Enumeration enum = the Consumers . elements ( ) ; while ( enum . has More Elements ( ) ) { Image Consumer ic = ( Image Consumer ) enum . next Element ( ) ; if ( w > NUM && h > NUM ) { send Pixels ( ic , x , y , w , h ) ; } if ( framenotify && is Consumer ( ic ) ) { ic . image Complete ( Image Consumer . SINGLEFRAMEDONE ) ; } } } }
public synchronized void new Pixels ( int x , int y , int w , int h , boolean framenotify ) { if ( animating ) { if ( fullbuffers ) { x = y = NUM ; w = width ; h = height ; } else { if ( x < NUM ) { w += x ; x = NUM ; } if ( x + w > width ) { w = width - x ; } if ( y < NUM ) { h += y ; y = NUM ; } if ( y + h > height ) { h = height - y ; } } if ( ( w <= NUM || h <= NUM ) && ! framenotify ) { return ; } Enumeration enum = the Consumers . elements ( ) ; while ( enum . has More Elements ( ) ) { Image Consumer ic = ( Image Consumer ) enum . next Element ( ) ; if ( w > NUM && h > NUM ) { send Pixels ( ic , x , y , w , h ) ; } if ( framenotify && is Consumer ( ic ) ) { ic . image Complete ( Image Consumer . SINGLEFRAMEDONE ) ; } } } }
public float length ( int u , int v ) { if ( u == v ) return NUM ; else return NUM / ( v - u ) ; }
public float length ( int u , int v ) { if ( u == v ) return NUM ; else return NUM / ( v - u ) ; }
@ Override public String to String ( ) { return Message Format . format ( STRING + STRING + STRING , get LDAP Filter ( ) , String Utils . join ( requested Attributes , STRING ) ) ; }
private void add Error Message ( String message ) { if ( message != null ) { m error Messages . append ( message ) ; } m error Messages . append ( STRING ) ; }
static boolean analyze Predicate ( Compiler compiler , int op Pos , int step Type ) throws javax . xml . transform . Transformer Exception { int arg Len ; switch ( step Type ) { case Op Codes . OP VARIABLE : case Op Codes . OP EXTFUNCTION : case Op Codes . OP FUNCTION : case Op Codes . OP GROUP : arg Len = compiler . get Arg Length ( op Pos ) ; break ; default : arg Len = compiler . get Arg Length Of Step ( op Pos ) ; } int pos = compiler . get First Predicate Op Pos ( op Pos ) ; int n Predicates = compiler . count Predicates ( pos ) ; return ( n Predicates > NUM ) ? BOOL : BOOL ; }
static boolean analyze Predicate ( Compiler compiler , int op Pos , int step Type ) throws javax . xml . transform . Transformer Exception { int arg Len ; switch ( step Type ) { case Op Codes . OP VARIABLE : case Op Codes . OP EXTFUNCTION : case Op Codes . OP FUNCTION : case Op Codes . OP GROUP : arg Len = compiler . get Arg Length ( op Pos ) ; break ; default : arg Len = compiler . get Arg Length Of Step ( op Pos ) ; } int pos = compiler . get First Predicate Op Pos ( op Pos ) ; int n Predicates = compiler . count Predicates ( pos ) ; return ( n Predicates > NUM ) ? BOOL : BOOL ; }
static boolean analyze Predicate ( Compiler compiler , int op Pos , int step Type ) throws javax . xml . transform . Transformer Exception { int arg Len ; switch ( step Type ) { case Op Codes . OP VARIABLE : case Op Codes . OP EXTFUNCTION : case Op Codes . OP FUNCTION : case Op Codes . OP GROUP : arg Len = compiler . get Arg Length ( op Pos ) ; break ; default : arg Len = compiler . get Arg Length Of Step ( op Pos ) ; } int pos = compiler . get First Predicate Op Pos ( op Pos ) ; int n Predicates = compiler . count Predicates ( pos ) ; return ( n Predicates > NUM ) ? BOOL : BOOL ; }
public static int index Of That Starts With ( List < String > list , String starts With , int start Index ) { for ( int i = start Index ; i < list . size ( ) ; i ++ ) { String cur Str = list . get ( i ) ; if ( cur Str != null && cur Str . starts With ( starts With ) ) { return i ; } } return - NUM ; }
public Type Name ( String full Name , String nickname , String pattern , Type Name ... inner Type Names ) { this . top Level Alias = Type Alias . create ( full Name , nickname ) ; this . pattern = pattern ; this . inner Type Names = Arrays . as List ( inner Type Names ) ; }
public Type Name ( String full Name , String nickname , String pattern , Type Name ... inner Type Names ) { this . top Level Alias = Type Alias . create ( full Name , nickname ) ; this . pattern = pattern ; this . inner Type Names = Arrays . as List ( inner Type Names ) ; }
public static Color parse Color From Properties ( Properties p , String prop Name , String dfault ) throws Number Format Exception { String color String = p . get Property ( prop Name , dfault ) ; return parse Color ( color String , BOOL ) ; }
private List < Entity > list Network ( Entity e , boolean planned ) { List < Entity > nova Network Members = new Linked List < Entity > ( ) ; List < Entity > nova Units = get My Nova Units ( ) ; for ( Entity ent : nova Units ) { if ( planned ) { if ( ent . get New Round Nova Network String ( ) == e . get New Round Nova Network String ( ) ) { nova Network Members . add ( ent ) ; } } else { if ( ent . get C 3 Net Id ( ) == e . get C 3 Net Id ( ) ) { nova Network Members . add ( ent ) ; } } } return nova Network Members ; }
public RDFXML Writer ( Output Stream out ) { this ( new Output Stream Writer ( out , Charset . for Name ( STRING ) ) ) ; }
final boolean nonfair Try Acquire ( int acquires ) { final Thread current = Thread . current Thread ( ) ; int c = get State ( ) ; if ( c == NUM ) { if ( compare And Set State ( NUM , acquires ) ) { set Exclusive Owner Thread ( current ) ; return BOOL ; } } else if ( current == get Exclusive Owner Thread ( ) ) { int nextc = c + acquires ; if ( nextc < NUM ) throw new Error ( STRING ) ; set State ( nextc ) ; return BOOL ; } return BOOL ; }
final boolean nonfair Try Acquire ( int acquires ) { final Thread current = Thread . current Thread ( ) ; int c = get State ( ) ; if ( c == NUM ) { if ( compare And Set State ( NUM , acquires ) ) { set Exclusive Owner Thread ( current ) ; return BOOL ; } } else if ( current == get Exclusive Owner Thread ( ) ) { int nextc = c + acquires ; if ( nextc < NUM ) throw new Error ( STRING ) ; set State ( nextc ) ; return BOOL ; } return BOOL ; }
final boolean nonfair Try Acquire ( int acquires ) { final Thread current = Thread . current Thread ( ) ; int c = get State ( ) ; if ( c == NUM ) { if ( compare And Set State ( NUM , acquires ) ) { set Exclusive Owner Thread ( current ) ; return BOOL ; } } else if ( current == get Exclusive Owner Thread ( ) ) { int nextc = c + acquires ; if ( nextc < NUM ) throw new Error ( STRING ) ; set State ( nextc ) ; return BOOL ; } return BOOL ; }
final boolean nonfair Try Acquire ( int acquires ) { final Thread current = Thread . current Thread ( ) ; int c = get State ( ) ; if ( c == NUM ) { if ( compare And Set State ( NUM , acquires ) ) { set Exclusive Owner Thread ( current ) ; return BOOL ; } } else if ( current == get Exclusive Owner Thread ( ) ) { int nextc = c + acquires ; if ( nextc < NUM ) throw new Error ( STRING ) ; set State ( nextc ) ; return BOOL ; } return BOOL ; }
public static void d ( String tag , String msg , Object ... args ) { if ( s Level > LEVEL DEBUG ) { return ; } if ( args . length > NUM ) { msg = String . format ( msg , args ) ; } Log . d ( tag , msg ) ; }
public long next Action Millis ( long now , long next Retry Time Millis ) { for ( File Download Info info : downloads ) { long individual Retry Time Millis = get Next Action Millis For ( now , info ) ; next Retry Time Millis = Math . min ( individual Retry Time Millis , next Retry Time Millis ) ; } return next Retry Time Millis ; }
private final boolean validate Client Packet ( Byte Buffer buf ) { return buf . get Short ( NUM ) == ~ buf . get Short ( NUM ) && buf . get ( NUM ) == static Client Packet Code ; }
private boolean check Validation ( final Source Data Tag current Source Data Tag , final Value Update update ) { if ( ! is Timestamp Valid ( current Source Data Tag , update ) ) { return BOOL ; } if ( ! is Convertible ( current Source Data Tag , update ) ) { return BOOL ; } if ( is Number ( current Source Data Tag . get Data Type ( ) ) && ! is In Range ( current Source Data Tag , update ) ) { return BOOL ; } return BOOL ; }
private boolean check Validation ( final Source Data Tag current Source Data Tag , final Value Update update ) { if ( ! is Timestamp Valid ( current Source Data Tag , update ) ) { return BOOL ; } if ( ! is Convertible ( current Source Data Tag , update ) ) { return BOOL ; } if ( is Number ( current Source Data Tag . get Data Type ( ) ) && ! is In Range ( current Source Data Tag , update ) ) { return BOOL ; } return BOOL ; }
protected void initialize ( ) { List < Add User Fields . Attribute Spec > specs = m filter . get Attribute Specs ( ) ; m list Model = new Default List Model ( ) ; m list . set Model ( m list Model ) ; if ( specs . size ( ) > NUM ) { m up But . set Enabled ( BOOL ) ; m down But . set Enabled ( BOOL ) ; for ( Add User Fields . Attribute Spec s : specs ) { Add User Fields . Attribute Spec spec Copy = new Add User Fields . Attribute Spec ( s . to String Internal ( ) ) ; m list Model . add Element ( spec Copy ) ; } m list . repaint ( ) ; } else { m name Field . set Enabled ( BOOL ) ; m type Field . set Enabled ( BOOL ) ; m date Format Field . set Enabled ( BOOL ) ; m value Field . set Enabled ( BOOL ) ; } }
public static Bsh Class Manager create Class Manager ( Interpreter interpreter ) { Bsh Class Manager manager ; if ( Capabilities . class Exists ( STRING ) && Capabilities . class Exists ( STRING ) && Capabilities . class Exists ( STRING ) ) try { Class clas = Class . for Name ( STRING ) ; manager = ( Bsh Class Manager ) clas . new Instance ( ) ; } catch ( Exception e ) { throw new Interpreter Error ( STRING + e ) ; } else manager = new Bsh Class Manager ( ) ; if ( interpreter == null ) interpreter = new Interpreter ( ) ; manager . declaring Interpreter = interpreter ; return manager ; }
public static Bsh Class Manager create Class Manager ( Interpreter interpreter ) { Bsh Class Manager manager ; if ( Capabilities . class Exists ( STRING ) && Capabilities . class Exists ( STRING ) && Capabilities . class Exists ( STRING ) ) try { Class clas = Class . for Name ( STRING ) ; manager = ( Bsh Class Manager ) clas . new Instance ( ) ; } catch ( Exception e ) { throw new Interpreter Error ( STRING + e ) ; } else manager = new Bsh Class Manager ( ) ; if ( interpreter == null ) interpreter = new Interpreter ( ) ; manager . declaring Interpreter = interpreter ; return manager ; }
@ Post Construct public void init ( ) { Iterator < Validator Factory > iterator = validator Factory Instance . iterator ( ) ; if ( iterator . has Next ( ) ) { this . validator Factory = iterator . next ( ) ; } else { log . warning ( STRING ) ; this . validator Factory = Validation . build Default Validator Factory ( ) ; } }
@ Post Construct public void init ( ) { Iterator < Validator Factory > iterator = validator Factory Instance . iterator ( ) ; if ( iterator . has Next ( ) ) { this . validator Factory = iterator . next ( ) ; } else { log . warning ( STRING ) ; this . validator Factory = Validation . build Default Validator Factory ( ) ; } }
@ Post Construct public void init ( ) { Iterator < Validator Factory > iterator = validator Factory Instance . iterator ( ) ; if ( iterator . has Next ( ) ) { this . validator Factory = iterator . next ( ) ; } else { log . warning ( STRING ) ; this . validator Factory = Validation . build Default Validator Factory ( ) ; } }
@ Post Construct public void init ( ) { Iterator < Validator Factory > iterator = validator Factory Instance . iterator ( ) ; if ( iterator . has Next ( ) ) { this . validator Factory = iterator . next ( ) ; } else { log . warning ( STRING ) ; this . validator Factory = Validation . build Default Validator Factory ( ) ; } }
public static String join ( String separator , Iterable < ? > elements ) { String Builder sb = new String Builder ( ) ; for ( Iterator < ? > i = elements . iterator ( ) ; i . has Next ( ) ; ) { sb . append ( i . next ( ) ) ; if ( i . has Next ( ) && separator != null ) { sb . append ( separator ) ; } } return sb . to String ( ) ; }
private void emit Trigger If All Blocks Received ( File Metadata file Metadata , Map < Long , Block Metadata . File Block Metadata > received Blocks Metadata ) { String file Path = file Metadata . get File Path ( ) ; if ( received Blocks Metadata . size ( ) != file Metadata . get Number Of Blocks ( ) ) { file Metadata Map . put ( file Path , file Metadata ) ; } else { Set < Long > received Blocks = received Blocks Metadata . key Set ( ) ; boolean block Missing = BOOL ; if ( ! file Metadata . is Directory ( ) ) { for ( long block Id : file Metadata . get Block Ids ( ) ) { if ( ! received Blocks . contains ( block Id ) ) { block Missing = BOOL ; } } } if ( ! block Missing ) { long file Processing Time = System . current Time Millis ( ) - file Metadata . get Discover Time ( ) ; List < Stitch Block > output Blocks = construct Output Block Metadata List ( file Metadata ) ; Output File Metadata output File Metadata = new Output File Metadata ( file Metadata , output Blocks ) ; trigger . emit ( output File Metadata ) ; LOG . debug ( STRING , file Metadata . get File Path ( ) , file Processing Time ) ; file Metadata Map . remove ( file Path ) ; } } }
public long time Millis ( ) { return ( ( perf . high Res Counter ( ) * TO MILLISECONDS ) / TICKS PER SECOND ) ; }
public static boolean is In Jail ( final Player inmate ) { final Stendhal RP Zone zone = inmate . get Zone ( ) ; if ( ( zone != null ) && zone . equals ( jailzone ) ) { for ( final Rectangle cell Block : cell Blocks ) { if ( cell Block . contains ( inmate . get X ( ) , inmate . get Y ( ) ) ) { return BOOL ; } } } return BOOL ; }
public static boolean is In Jail ( final Player inmate ) { final Stendhal RP Zone zone = inmate . get Zone ( ) ; if ( ( zone != null ) && zone . equals ( jailzone ) ) { for ( final Rectangle cell Block : cell Blocks ) { if ( cell Block . contains ( inmate . get X ( ) , inmate . get Y ( ) ) ) { return BOOL ; } } } return BOOL ; }
public static String [ ] parse Delimited List ( String list , char delimiter ) { String delim = STRING + delimiter ; String Tokenizer st = new String Tokenizer ( list + delim + STRING , delim , BOOL ) ; Array List < String > v = new Array List < String > ( ) ; String last Token = STRING ; String word = STRING ; while ( st . has More Tokens ( ) ) { String tok = st . next Token ( ) ; if ( last Token != null ) { if ( tok . equals ( delim ) ) { word = word + last Token ; if ( last Token . equals ( delim ) ) tok = null ; } else { if ( ! word . equals ( STRING ) ) v . add ( word ) ; word = STRING ; } } last Token = tok ; } return v . to Array ( new String [ NUM ] ) ; }
public static String [ ] parse Delimited List ( String list , char delimiter ) { String delim = STRING + delimiter ; String Tokenizer st = new String Tokenizer ( list + delim + STRING , delim , BOOL ) ; Array List < String > v = new Array List < String > ( ) ; String last Token = STRING ; String word = STRING ; while ( st . has More Tokens ( ) ) { String tok = st . next Token ( ) ; if ( last Token != null ) { if ( tok . equals ( delim ) ) { word = word + last Token ; if ( last Token . equals ( delim ) ) tok = null ; } else { if ( ! word . equals ( STRING ) ) v . add ( word ) ; word = STRING ; } } last Token = tok ; } return v . to Array ( new String [ NUM ] ) ; }
public String default Value As String ( ) { Object default Value = default Value ( ) ; return default Value != null ? default Value . to String ( ) : null ; }
public static void expand Letters ( String letters , Word Relation word Relation , Item token Item ) { letters = letters . to Lower Case ( ) ; char c ; for ( int i = NUM ; i < letters . length ( ) ; i ++ ) { c = letters . char At ( i ) ; if ( is Digit ( c ) ) { word Relation . add Word ( token Item , digit 2 num [ c - STRING ] ) ; } else if ( letters . equals ( STRING ) ) { word Relation . add Word ( token Item , STRING ) ; } else { word Relation . add Word ( token Item , String . value Of ( c ) ) ; } } }
public void add Transform ( Data Transform transform ) { transform Source . add ( transform ) ; }
public void add Transform ( Data Transform transform ) { transform Source . add ( transform ) ; }
public void add Transform ( Data Transform transform ) { transform Source . add ( transform ) ; }
public void add Transform ( Data Transform transform ) { transform Source . add ( transform ) ; }
@ Suppress Warnings ( STRING ) private Object to Reflection Type ( final Object value ) { Field Descriptor descriptor = get Descriptor ( ) ; if ( descriptor . is Repeated ( ) ) { if ( descriptor . get Java Type ( ) == Field Descriptor . Java Type . ENUM ) { final List result = new Array List ( ) ; for ( final Object element : ( List ) value ) { result . add ( singular To Reflection Type ( element ) ) ; } return result ; } else { return value ; } } else { return singular To Reflection Type ( value ) ; } }
@ Suppress Warnings ( STRING ) private Object to Reflection Type ( final Object value ) { Field Descriptor descriptor = get Descriptor ( ) ; if ( descriptor . is Repeated ( ) ) { if ( descriptor . get Java Type ( ) == Field Descriptor . Java Type . ENUM ) { final List result = new Array List ( ) ; for ( final Object element : ( List ) value ) { result . add ( singular To Reflection Type ( element ) ) ; } return result ; } else { return value ; } } else { return singular To Reflection Type ( value ) ; } }
@ Suppress Warnings ( STRING ) private Object to Reflection Type ( final Object value ) { Field Descriptor descriptor = get Descriptor ( ) ; if ( descriptor . is Repeated ( ) ) { if ( descriptor . get Java Type ( ) == Field Descriptor . Java Type . ENUM ) { final List result = new Array List ( ) ; for ( final Object element : ( List ) value ) { result . add ( singular To Reflection Type ( element ) ) ; } return result ; } else { return value ; } } else { return singular To Reflection Type ( value ) ; } }
@ Suppress Warnings ( STRING ) private Object to Reflection Type ( final Object value ) { Field Descriptor descriptor = get Descriptor ( ) ; if ( descriptor . is Repeated ( ) ) { if ( descriptor . get Java Type ( ) == Field Descriptor . Java Type . ENUM ) { final List result = new Array List ( ) ; for ( final Object element : ( List ) value ) { result . add ( singular To Reflection Type ( element ) ) ; } return result ; } else { return value ; } } else { return singular To Reflection Type ( value ) ; } }
List < Isilon Event > filter Events ( List < Isilon Event > events ) { long most Recent Timestamp = latest Time Threshold ; List < Isilon Event > filtered Events = new Array List < Isilon Event > ( ) ; for ( Isilon Event event : events ) { long latest Time = event . get Latest Time ( ) ; if ( latest Time > latest Time Threshold ) { filtered Events . add ( event ) ; if ( latest Time > most Recent Timestamp ) { most Recent Timestamp = latest Time ; } } } most Recent Timestamp In Polling Cycle = most Recent Timestamp ; return filtered Events ; }
public Linked Hash Set ( Collection < ? extends E > c ) { super ( Math . max ( NUM * c . size ( ) , NUM ) , NUM , BOOL ) ; add All ( c ) ; }
protected void replace ( final String param Text , final String new Text ) { int loc = builder . index Of ( param Text ) ; while ( loc >= NUM ) { builder . replace ( loc , loc + param Text . length ( ) , new Text ) ; loc = builder . index Of ( param Text ) ; } }
public void test copy Stream nearly Full Block ( ) throws IO Exception { final String id = STRING ; final int version = NUM ; Random r = new Random ( ) ; final byte [ ] expected = new byte [ BLOCK SIZE - NUM ] ; r . next Bytes ( expected ) ; assert Equals ( STRING , expected . length , repo . copy Stream ( id , version , new Byte Array Input Stream ( expected ) ) ) ; assert Equals ( STRING , NUM , repo . get Block Count ( id , version ) ) ; assert Same Iterator ( STRING , new Long [ ] { NUM } , repo . blocks ( id , version ) ) ; assert Equals ( STRING , expected , read ( repo . input Stream ( id , version ) ) ) ; }
public void test copy Stream nearly Full Block ( ) throws IO Exception { final String id = STRING ; final int version = NUM ; Random r = new Random ( ) ; final byte [ ] expected = new byte [ BLOCK SIZE - NUM ] ; r . next Bytes ( expected ) ; assert Equals ( STRING , expected . length , repo . copy Stream ( id , version , new Byte Array Input Stream ( expected ) ) ) ; assert Equals ( STRING , NUM , repo . get Block Count ( id , version ) ) ; assert Same Iterator ( STRING , new Long [ ] { NUM } , repo . blocks ( id , version ) ) ; assert Equals ( STRING , expected , read ( repo . input Stream ( id , version ) ) ) ; }
public void merge Pre Condition ( ) { if ( pre Condition != null && condition Block != null ) { List < Insn Node > cond Insns = condition Block . get Instructions ( ) ; List < Insn Node > pre Cond Insns = pre Condition . get Instructions ( ) ; pre Cond Insns . add All ( cond Insns ) ; cond Insns . clear ( ) ; cond Insns . add All ( pre Cond Insns ) ; pre Cond Insns . clear ( ) ; pre Condition = null ; } }
public void merge Pre Condition ( ) { if ( pre Condition != null && condition Block != null ) { List < Insn Node > cond Insns = condition Block . get Instructions ( ) ; List < Insn Node > pre Cond Insns = pre Condition . get Instructions ( ) ; pre Cond Insns . add All ( cond Insns ) ; cond Insns . clear ( ) ; cond Insns . add All ( pre Cond Insns ) ; pre Cond Insns . clear ( ) ; pre Condition = null ; } }
private void enlage If Needed ( int i ) { while ( end + i > array . length ) array = Arrays . copy Of ( array , Math . max ( array . length * NUM , NUM ) ) ; }
public void start ( ) { Thread thread = new Thread ( this ) ; if ( m pi != null ) thread . set Name ( m pi . get Title ( ) + STRING + m pi . get AD P Instance ID ( ) ) ; thread . start ( ) ; }
public void start ( ) { Thread thread = new Thread ( this ) ; if ( m pi != null ) thread . set Name ( m pi . get Title ( ) + STRING + m pi . get AD P Instance ID ( ) ) ; thread . start ( ) ; }
protected Transferable create Transferable ( J Component comp ) { export Comp = ( J Text Component ) comp ; should Remove = BOOL ; p0 = export Comp . get Selection Start ( ) ; p1 = export Comp . get Selection End ( ) ; return ( p0 != p1 ) ? ( new Text Transferable ( export Comp , p0 , p1 ) ) : null ; }
public void add Communication Listener ( FTP Communication Listener listener ) { synchronized ( lock ) { communication Listeners . add ( listener ) ; if ( communication != null ) { communication . add Communication Listener ( listener ) ; } } }
public void add Entitlement ( Entitlement Entity entitlement ) { entitlements . add ( entitlement ) ; }
public void register Input ( String var Name , ML Matrix df ) throws DML Runtime Exception { register Input ( var Name , ML Matrix . get RDD Lazily ( df ) , df . mc ) ; }
public void register Input ( String var Name , ML Matrix df ) throws DML Runtime Exception { register Input ( var Name , ML Matrix . get RDD Lazily ( df ) , df . mc ) ; }
public void register Input ( String var Name , ML Matrix df ) throws DML Runtime Exception { register Input ( var Name , ML Matrix . get RDD Lazily ( df ) , df . mc ) ; }
public void error ( Level level , String message Id , String data [ ] , Object session , Map props ) throws Log Exception { if ( is Error Loggable ( level ) ) { Log Record lr = new Log Record ( level , format Message ( message Id , data , session ) ) ; error Logger . log ( lr ) ; } }
public void error ( Level level , String message Id , String data [ ] , Object session , Map props ) throws Log Exception { if ( is Error Loggable ( level ) ) { Log Record lr = new Log Record ( level , format Message ( message Id , data , session ) ) ; error Logger . log ( lr ) ; } }
public Set < P > generate Cloud ( int N ) { Set < P > samples = new Linked Hash Set < P > ( ) ; Integer [ ] indexes = new Integer [ N ] ; for ( int i = NUM ; i < N ; i ++ ) { samples . add ( map . random Pose ( ) ) ; indexes [ i ] = i ; } sample Indexes = new Rand Var ( SAMPLE INDEXES NAME , new Finite Integer Domain ( indexes ) ) ; return samples ; }
public Set < P > generate Cloud ( int N ) { Set < P > samples = new Linked Hash Set < P > ( ) ; Integer [ ] indexes = new Integer [ N ] ; for ( int i = NUM ; i < N ; i ++ ) { samples . add ( map . random Pose ( ) ) ; indexes [ i ] = i ; } sample Indexes = new Rand Var ( SAMPLE INDEXES NAME , new Finite Integer Domain ( indexes ) ) ; return samples ; }
private void update Preview ( ) { Color new Color = chooser . get Color ( ) ; if ( type == FOREGROUND ) { preview . update ( new Color , secondary Color ) ; } else { preview . update ( secondary Color , new Color ) ; } }
private void navigate To Child ( String starts With ) { Tree Path current Path = tree . get Selection Path ( ) ; Default Mutable Tree Node dump Node = ( Default Mutable Tree Node ) current Path . get Last Path Component ( ) ; Enumeration childs = dump Node . children ( ) ; Tree Path search Path = null ; while ( ( search Path == null ) && childs . has More Elements ( ) ) { Default Mutable Tree Node child = ( Default Mutable Tree Node ) childs . next Element ( ) ; String name = child . to String ( ) ; if ( name != null && name . starts With ( starts With ) ) { search Path = new Tree Path ( child . get Path ( ) ) ; } } if ( search Path != null ) { tree . make Visible ( search Path ) ; tree . set Selection Path ( search Path ) ; tree . scroll Path To Visible ( search Path ) ; } }
protected void save Language ( String language ) { f Language Scope . push ( f Depth ) ; f Language Stack . push ( language ) ; }
private boolean local Equals ( Abstraction other ) { if ( source Context == null ) { if ( other . source Context != null ) return BOOL ; } else if ( ! source Context . equals ( other . source Context ) ) return BOOL ; if ( activation Unit == null ) { if ( other . activation Unit != null ) return BOOL ; } else if ( ! activation Unit . equals ( other . activation Unit ) ) return BOOL ; if ( this . exception Thrown != other . exception Thrown ) return BOOL ; if ( postdominators == null ) { if ( other . postdominators != null ) return BOOL ; } else if ( ! postdominators . equals ( other . postdominators ) ) return BOOL ; if ( this . depends On Cut AP != other . depends On Cut AP ) return BOOL ; if ( this . is Implicit != other . is Implicit ) return BOOL ; return BOOL ; }
private boolean local Equals ( Abstraction other ) { if ( source Context == null ) { if ( other . source Context != null ) return BOOL ; } else if ( ! source Context . equals ( other . source Context ) ) return BOOL ; if ( activation Unit == null ) { if ( other . activation Unit != null ) return BOOL ; } else if ( ! activation Unit . equals ( other . activation Unit ) ) return BOOL ; if ( this . exception Thrown != other . exception Thrown ) return BOOL ; if ( postdominators == null ) { if ( other . postdominators != null ) return BOOL ; } else if ( ! postdominators . equals ( other . postdominators ) ) return BOOL ; if ( this . depends On Cut AP != other . depends On Cut AP ) return BOOL ; if ( this . is Implicit != other . is Implicit ) return BOOL ; return BOOL ; }
private boolean local Equals ( Abstraction other ) { if ( source Context == null ) { if ( other . source Context != null ) return BOOL ; } else if ( ! source Context . equals ( other . source Context ) ) return BOOL ; if ( activation Unit == null ) { if ( other . activation Unit != null ) return BOOL ; } else if ( ! activation Unit . equals ( other . activation Unit ) ) return BOOL ; if ( this . exception Thrown != other . exception Thrown ) return BOOL ; if ( postdominators == null ) { if ( other . postdominators != null ) return BOOL ; } else if ( ! postdominators . equals ( other . postdominators ) ) return BOOL ; if ( this . depends On Cut AP != other . depends On Cut AP ) return BOOL ; if ( this . is Implicit != other . is Implicit ) return BOOL ; return BOOL ; }
protected void collapse Parent List Item ( Parent Wrapper parent Wrapper , int parent Index , boolean collapse Triggered By List Item Click ) { if ( parent Wrapper . is Expanded ( ) ) { parent Wrapper . set Expanded ( BOOL ) ; List < ? > child Item List = parent Wrapper . get Child Item List ( ) ; if ( child Item List != null ) { int child List Item Count = child Item List . size ( ) ; for ( int i = child List Item Count - NUM ; i >= NUM ; i -- ) { m Item List . remove ( parent Index + i + NUM ) ; } notify Item Range Removed ( parent Index + NUM , child List Item Count ) ; } if ( collapse Triggered By List Item Click && m Expand Collapse Listener != null ) { int expanded Count Before Position = get Expanded Item Count ( parent Index ) ; m Expand Collapse Listener . on List Item Collapsed ( parent Index - expanded Count Before Position ) ; } } }
protected void collapse Parent List Item ( Parent Wrapper parent Wrapper , int parent Index , boolean collapse Triggered By List Item Click ) { if ( parent Wrapper . is Expanded ( ) ) { parent Wrapper . set Expanded ( BOOL ) ; List < ? > child Item List = parent Wrapper . get Child Item List ( ) ; if ( child Item List != null ) { int child List Item Count = child Item List . size ( ) ; for ( int i = child List Item Count - NUM ; i >= NUM ; i -- ) { m Item List . remove ( parent Index + i + NUM ) ; } notify Item Range Removed ( parent Index + NUM , child List Item Count ) ; } if ( collapse Triggered By List Item Click && m Expand Collapse Listener != null ) { int expanded Count Before Position = get Expanded Item Count ( parent Index ) ; m Expand Collapse Listener . on List Item Collapsed ( parent Index - expanded Count Before Position ) ; } } }
protected void collapse Parent List Item ( Parent Wrapper parent Wrapper , int parent Index , boolean collapse Triggered By List Item Click ) { if ( parent Wrapper . is Expanded ( ) ) { parent Wrapper . set Expanded ( BOOL ) ; List < ? > child Item List = parent Wrapper . get Child Item List ( ) ; if ( child Item List != null ) { int child List Item Count = child Item List . size ( ) ; for ( int i = child List Item Count - NUM ; i >= NUM ; i -- ) { m Item List . remove ( parent Index + i + NUM ) ; } notify Item Range Removed ( parent Index + NUM , child List Item Count ) ; } if ( collapse Triggered By List Item Click && m Expand Collapse Listener != null ) { int expanded Count Before Position = get Expanded Item Count ( parent Index ) ; m Expand Collapse Listener . on List Item Collapsed ( parent Index - expanded Count Before Position ) ; } } }
public static byte [ ] concat ( final byte [ ] ... arrays ) { int len = NUM ; for ( final byte [ ] arr : arrays ) { len += arr . length ; } final byte [ ] result = new byte [ len ] ; int pos = NUM ; for ( final byte [ ] arr : arrays ) { System . arraycopy ( arr , NUM , result , pos , arr . length ) ; pos += arr . length ; } return result ; }
private static String [ ] select File Command ( File file ) { String path = null ; try { path = file . get Canonical Path ( ) ; } catch ( IO Exception err ) { path = file . get Absolute Path ( ) ; } String [ ] command = new String [ ] { STRING , STRING , STRING + path + STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; return command ; }
private static String [ ] select File Command ( File file ) { String path = null ; try { path = file . get Canonical Path ( ) ; } catch ( IO Exception err ) { path = file . get Absolute Path ( ) ; } String [ ] command = new String [ ] { STRING , STRING , STRING + path + STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; return command ; }
public void add ( T item ) { items . add ( item ) ; }
public Popup Image ( final String image , final String title , final String caption ) { put ( Actions . ACTION , Actions . LOOK CLOSELY ) ; this . image = image ; if ( ! image . starts With ( STRING ) && ! image . starts With ( STRING ) ) { this . image = STRING + image ; } this . title = title ; this . caption = caption ; }
public Host Multipath Info Logical Unit Policy create Multipath Policy ( String name ) { if ( String Utils . equals Ignore Case ( name , VMW PSP FIXED ) ) { Host Multipath Info Fixed Logical Unit Policy policy = new Host Multipath Info Fixed Logical Unit Policy ( ) ; policy . set Policy ( name ) ; policy . set Prefer ( STRING ) ; return policy ; } else { Host Multipath Info Logical Unit Policy policy = new Host Multipath Info Logical Unit Policy ( ) ; policy . set Policy ( name ) ; return policy ; } }
protected void new Line ( Print Writer file ) { file . println ( BLANK LINE ) ; }
private void try correct net ( Brd Item p item ) { if ( ! ( p item instanceof Brd Tracep ) ) return ; Brd Tracep curr trace = ( Brd Tracep ) p item ; Set < Brd Item > contacts = curr trace . get normal contacts ( curr trace . corner first ( ) , BOOL ) ; contacts . add All ( curr trace . get normal contacts ( curr trace . corner last ( ) , BOOL ) ) ; int corrected net no = NUM ; for ( Brd Item curr contact : contacts ) { if ( curr contact . net count ( ) == NUM ) { corrected net no = curr contact . get net no ( NUM ) ; break ; } } if ( corrected net no != NUM ) { p item . set net no ( corrected net no ) ; } }
public static byte [ ] unwrap VCF ( File source File , File tmp File ) throws File Not Found Exception , IO Exception { Zip Archive Input Stream in = null ; File Output Stream fos = null ; String hmac String = null ; try { in = new Zip Archive Input Stream ( new File Input Stream ( source File ) ) ; Archive Entry entry ; in . get Next Entry ( ) ; fos = new File Output Stream ( tmp File ) ; IO Utils . copy ( in , fos ) ; entry = in . get Next Entry ( ) ; hmac String = entry . get Name ( ) ; return Utils . hex To Bytes ( hmac String ) ; } catch ( String Index Out Of Bounds Exception e ) { logger . error ( STRING + hmac String + STRING , e ) ; throw e ; } catch ( Exception e ) { logger . error ( STRING , e ) ; throw e ; } finally { if ( fos != null ) { fos . flush ( ) ; fos . close ( ) ; } if ( in != null ) { in . close ( ) ; } } }
public static byte [ ] unwrap VCF ( File source File , File tmp File ) throws File Not Found Exception , IO Exception { Zip Archive Input Stream in = null ; File Output Stream fos = null ; String hmac String = null ; try { in = new Zip Archive Input Stream ( new File Input Stream ( source File ) ) ; Archive Entry entry ; in . get Next Entry ( ) ; fos = new File Output Stream ( tmp File ) ; IO Utils . copy ( in , fos ) ; entry = in . get Next Entry ( ) ; hmac String = entry . get Name ( ) ; return Utils . hex To Bytes ( hmac String ) ; } catch ( String Index Out Of Bounds Exception e ) { logger . error ( STRING + hmac String + STRING , e ) ; throw e ; } catch ( Exception e ) { logger . error ( STRING , e ) ; throw e ; } finally { if ( fos != null ) { fos . flush ( ) ; fos . close ( ) ; } if ( in != null ) { in . close ( ) ; } } }
public static byte [ ] unwrap VCF ( File source File , File tmp File ) throws File Not Found Exception , IO Exception { Zip Archive Input Stream in = null ; File Output Stream fos = null ; String hmac String = null ; try { in = new Zip Archive Input Stream ( new File Input Stream ( source File ) ) ; Archive Entry entry ; in . get Next Entry ( ) ; fos = new File Output Stream ( tmp File ) ; IO Utils . copy ( in , fos ) ; entry = in . get Next Entry ( ) ; hmac String = entry . get Name ( ) ; return Utils . hex To Bytes ( hmac String ) ; } catch ( String Index Out Of Bounds Exception e ) { logger . error ( STRING + hmac String + STRING , e ) ; throw e ; } catch ( Exception e ) { logger . error ( STRING , e ) ; throw e ; } finally { if ( fos != null ) { fos . flush ( ) ; fos . close ( ) ; } if ( in != null ) { in . close ( ) ; } } }
public static byte [ ] unwrap VCF ( File source File , File tmp File ) throws File Not Found Exception , IO Exception { Zip Archive Input Stream in = null ; File Output Stream fos = null ; String hmac String = null ; try { in = new Zip Archive Input Stream ( new File Input Stream ( source File ) ) ; Archive Entry entry ; in . get Next Entry ( ) ; fos = new File Output Stream ( tmp File ) ; IO Utils . copy ( in , fos ) ; entry = in . get Next Entry ( ) ; hmac String = entry . get Name ( ) ; return Utils . hex To Bytes ( hmac String ) ; } catch ( String Index Out Of Bounds Exception e ) { logger . error ( STRING + hmac String + STRING , e ) ; throw e ; } catch ( Exception e ) { logger . error ( STRING , e ) ; throw e ; } finally { if ( fos != null ) { fos . flush ( ) ; fos . close ( ) ; } if ( in != null ) { in . close ( ) ; } } }
public static byte [ ] unwrap VCF ( File source File , File tmp File ) throws File Not Found Exception , IO Exception { Zip Archive Input Stream in = null ; File Output Stream fos = null ; String hmac String = null ; try { in = new Zip Archive Input Stream ( new File Input Stream ( source File ) ) ; Archive Entry entry ; in . get Next Entry ( ) ; fos = new File Output Stream ( tmp File ) ; IO Utils . copy ( in , fos ) ; entry = in . get Next Entry ( ) ; hmac String = entry . get Name ( ) ; return Utils . hex To Bytes ( hmac String ) ; } catch ( String Index Out Of Bounds Exception e ) { logger . error ( STRING + hmac String + STRING , e ) ; throw e ; } catch ( Exception e ) { logger . error ( STRING , e ) ; throw e ; } finally { if ( fos != null ) { fos . flush ( ) ; fos . close ( ) ; } if ( in != null ) { in . close ( ) ; } } }
public static String to Hex String ( byte [ ] bytes ) { if ( bytes == null ) return STRING ; int i ; String ret = STRING ; String tmp ; for ( i = NUM ; i < bytes . length ; i ++ ) { if ( i > NUM ) ret += STRING ; tmp = Integer . to Hex String ( U8 . f ( bytes [ i ] ) ) ; if ( tmp . length ( ) == NUM ) ret += STRING ; ret += tmp ; } return ret ; }
public void add Directory Set ( Context context , String path ) { Tiny DB tinydb = new Tiny DB ( context ) ; Array List < String > file = tinydb . get List String ( STRING ) ; file . add ( path ) ; tinydb . put List String ( STRING , file ) ; }
public void add Directory Set ( Context context , String path ) { Tiny DB tinydb = new Tiny DB ( context ) ; Array List < String > file = tinydb . get List String ( STRING ) ; file . add ( path ) ; tinydb . put List String ( STRING , file ) ; }
public Held Locks Token refresh ( long expiration Date Ms ) { return new Held Locks Token ( token Id , client , creation Date Ms , expiration Date Ms , lock Map , lock Timeout , version Id ) ; }
public Held Locks Token refresh ( long expiration Date Ms ) { return new Held Locks Token ( token Id , client , creation Date Ms , expiration Date Ms , lock Map , lock Timeout , version Id ) ; }
public Held Locks Token refresh ( long expiration Date Ms ) { return new Held Locks Token ( token Id , client , creation Date Ms , expiration Date Ms , lock Map , lock Timeout , version Id ) ; }
private static synchronized String format And Parse ( Simple Date Format format Date , Simple Date Format parse Date , String text ) { try { Date date = parse Date . parse ( text ) ; String result = format Date . format ( date ) ; return result ; } catch ( Parse Exception e ) { logger . warning ( STRING + text ) ; } return STRING ; }
public void write LE Char ( int c ) throws IO Exception { out . write ( c & NUM ) ; out . write ( ( c > > > NUM ) & NUM ) ; written += NUM ; }
public void write LE Char ( int c ) throws IO Exception { out . write ( c & NUM ) ; out . write ( ( c > > > NUM ) & NUM ) ; written += NUM ; }
public void curve To ( float c0 X , float c0 Y , float c1 X , float c1 Y , float x , float y ) { m Points . add ( Path Point . curve To ( c0 X , c0 Y , c1 X , c1 Y , x , y ) ) ; }
public void curve To ( float c0 X , float c0 Y , float c1 X , float c1 Y , float x , float y ) { m Points . add ( Path Point . curve To ( c0 X , c0 Y , c1 X , c1 Y , x , y ) ) ; }
public void curve To ( float c0 X , float c0 Y , float c1 X , float c1 Y , float x , float y ) { m Points . add ( Path Point . curve To ( c0 X , c0 Y , c1 X , c1 Y , x , y ) ) ; }
public void curve To ( float c0 X , float c0 Y , float c1 X , float c1 Y , float x , float y ) { m Points . add ( Path Point . curve To ( c0 X , c0 Y , c1 X , c1 Y , x , y ) ) ; }
@ Override public boolean connection Allowed ( String event Name ) { if ( event Name . equals ( STRING ) && m listenees . contains Key ( event Name ) ) { return BOOL ; } return BOOL ; }
@ Override public boolean connection Allowed ( String event Name ) { if ( event Name . equals ( STRING ) && m listenees . contains Key ( event Name ) ) { return BOOL ; } return BOOL ; }
@ Override public boolean connection Allowed ( String event Name ) { if ( event Name . equals ( STRING ) && m listenees . contains Key ( event Name ) ) { return BOOL ; } return BOOL ; }
public void end ( String namespace , String name ) { UI Component uic = ( UI Component ) digester . peek ( ) ; if ( uic instanceof UI Form ) { root = ( UI Component ) digester . peek ( digester . get Count ( ) - NUM ) ; } }
public static terminal find ( int indx ) { Integer the indx = new Integer ( indx ) ; return ( terminal ) all by index . get ( the indx ) ; }
public Address Lookup ( String server Url , String serial No , String password ) { this . server Url = server Url . trim ( ) ; this . client ID = serial No . trim ( ) ; this . access Code = password . trim ( ) ; }
public void send Load Game ( File f ) { precognition . reset Game ( ) ; super . send Load Game ( f ) ; }
private void download Update Prop ( final boolean initial Download ) { if ( boot Prop != null ) { server Folder = boot Prop . get Property ( STRING , Client Game Configuration . get ( STRING ) ) + STRING ; String update Properties File = boot Prop . get Property ( STRING , server Folder + STRING ) ; final Http Client http Client = new Http Client ( update Properties File , initial Download ) ; update Prop = http Client . fetch Properties ( ) ; if ( update Prop != null && update Prop . contains Key ( STRING ) ) { return ; } } String update Properties File = Client Game Configuration . get ( STRING ) + STRING ; Http Client http Client = new Http Client ( update Properties File , initial Download ) ; update Prop = http Client . fetch Properties ( ) ; if ( update Prop != null && update Prop . contains Key ( STRING ) ) { return ; } update Properties File = Client Game Configuration . get ( STRING ) + STRING ; http Client = new Http Client ( update Properties File , initial Download ) ; update Prop = http Client . fetch Properties ( ) ; }
private void download Update Prop ( final boolean initial Download ) { if ( boot Prop != null ) { server Folder = boot Prop . get Property ( STRING , Client Game Configuration . get ( STRING ) ) + STRING ; String update Properties File = boot Prop . get Property ( STRING , server Folder + STRING ) ; final Http Client http Client = new Http Client ( update Properties File , initial Download ) ; update Prop = http Client . fetch Properties ( ) ; if ( update Prop != null && update Prop . contains Key ( STRING ) ) { return ; } } String update Properties File = Client Game Configuration . get ( STRING ) + STRING ; Http Client http Client = new Http Client ( update Properties File , initial Download ) ; update Prop = http Client . fetch Properties ( ) ; if ( update Prop != null && update Prop . contains Key ( STRING ) ) { return ; } update Properties File = Client Game Configuration . get ( STRING ) + STRING ; http Client = new Http Client ( update Properties File , initial Download ) ; update Prop = http Client . fetch Properties ( ) ; }
List Based Token Stream ( Attribute Source attribute Source , List < Attribute Source > tokens ) { super ( attribute Source . get Attribute Factory ( ) ) ; this . tokens = tokens ; add Attributes ( attribute Source ) ; }
List Based Token Stream ( Attribute Source attribute Source , List < Attribute Source > tokens ) { super ( attribute Source . get Attribute Factory ( ) ) ; this . tokens = tokens ; add Attributes ( attribute Source ) ; }
List Based Token Stream ( Attribute Source attribute Source , List < Attribute Source > tokens ) { super ( attribute Source . get Attribute Factory ( ) ) ; this . tokens = tokens ; add Attributes ( attribute Source ) ; }
public static Cipher Parameters make PBE Mac Parameters ( BCPBE Key pbe Key , Algorithm Parameter Spec spec ) { if ( ( spec == null ) || ! ( spec instanceof PBE Parameter Spec ) ) { throw new Illegal Argument Exception ( STRING ) ; } PBE Parameter Spec pbe Param = ( PBE Parameter Spec ) spec ; PBE Parameters Generator generator = make PBE Generator ( pbe Key . get Type ( ) , pbe Key . get Digest ( ) ) ; byte [ ] key = pbe Key . get Encoded ( ) ; Cipher Parameters param ; if ( pbe Key . should Try Wrong PKCS 12 ( ) ) { key = new byte [ NUM ] ; } generator . init ( key , pbe Param . get Salt ( ) , pbe Param . get Iteration Count ( ) ) ; param = generator . generate Derived Mac Parameters ( pbe Key . get Key Size ( ) ) ; for ( int i = NUM ; i != key . length ; i ++ ) { key [ i ] = NUM ; } return param ; }
public static Cipher Parameters make PBE Mac Parameters ( BCPBE Key pbe Key , Algorithm Parameter Spec spec ) { if ( ( spec == null ) || ! ( spec instanceof PBE Parameter Spec ) ) { throw new Illegal Argument Exception ( STRING ) ; } PBE Parameter Spec pbe Param = ( PBE Parameter Spec ) spec ; PBE Parameters Generator generator = make PBE Generator ( pbe Key . get Type ( ) , pbe Key . get Digest ( ) ) ; byte [ ] key = pbe Key . get Encoded ( ) ; Cipher Parameters param ; if ( pbe Key . should Try Wrong PKCS 12 ( ) ) { key = new byte [ NUM ] ; } generator . init ( key , pbe Param . get Salt ( ) , pbe Param . get Iteration Count ( ) ) ; param = generator . generate Derived Mac Parameters ( pbe Key . get Key Size ( ) ) ; for ( int i = NUM ; i != key . length ; i ++ ) { key [ i ] = NUM ; } return param ; }
public XML Document add To Prolog ( Concrete Element element ) { prolog . add Element ( element ) ; return ( this ) ; }
public XML Document add To Prolog ( Concrete Element element ) { prolog . add Element ( element ) ; return ( this ) ; }
@ Override public Map < String , Set < URI > > find Export Masks ( Storage System storage , List < String > initiator Names , boolean must Have All Ports ) throws Device Controller Exception { log . info ( STRING , storage . get Label ( ) ) ; Map < String , Set < URI > > result = new Hash Map < String , Set < URI > > ( ) ; List < Initiator > initiators = new Array List < Initiator > ( ) ; for ( String name : initiator Names ) { initiators . add ( Export Utils . get Initiator ( Initiator . to Port Network Id ( name ) , db Client ) ) ; } if ( rest API Helper . is Clustered Host ( storage , initiators ) ) { log . debug ( STRING , storage . get Label ( ) ) ; result = rest API Helper . find REST Export Masks ( storage , initiator Names , must Have All Ports ) ; } else { log . debug ( STRING , storage . get Label ( ) ) ; result = find SMIS Export Masks ( storage , initiator Names , must Have All Ports ) ; } log . info ( STRING , storage . get Label ( ) ) ; return result ; }
@ Override public Map < String , Set < URI > > find Export Masks ( Storage System storage , List < String > initiator Names , boolean must Have All Ports ) throws Device Controller Exception { log . info ( STRING , storage . get Label ( ) ) ; Map < String , Set < URI > > result = new Hash Map < String , Set < URI > > ( ) ; List < Initiator > initiators = new Array List < Initiator > ( ) ; for ( String name : initiator Names ) { initiators . add ( Export Utils . get Initiator ( Initiator . to Port Network Id ( name ) , db Client ) ) ; } if ( rest API Helper . is Clustered Host ( storage , initiators ) ) { log . debug ( STRING , storage . get Label ( ) ) ; result = rest API Helper . find REST Export Masks ( storage , initiator Names , must Have All Ports ) ; } else { log . debug ( STRING , storage . get Label ( ) ) ; result = find SMIS Export Masks ( storage , initiator Names , must Have All Ports ) ; } log . info ( STRING , storage . get Label ( ) ) ; return result ; }
@ Override public Map < String , Set < URI > > find Export Masks ( Storage System storage , List < String > initiator Names , boolean must Have All Ports ) throws Device Controller Exception { log . info ( STRING , storage . get Label ( ) ) ; Map < String , Set < URI > > result = new Hash Map < String , Set < URI > > ( ) ; List < Initiator > initiators = new Array List < Initiator > ( ) ; for ( String name : initiator Names ) { initiators . add ( Export Utils . get Initiator ( Initiator . to Port Network Id ( name ) , db Client ) ) ; } if ( rest API Helper . is Clustered Host ( storage , initiators ) ) { log . debug ( STRING , storage . get Label ( ) ) ; result = rest API Helper . find REST Export Masks ( storage , initiator Names , must Have All Ports ) ; } else { log . debug ( STRING , storage . get Label ( ) ) ; result = find SMIS Export Masks ( storage , initiator Names , must Have All Ports ) ; } log . info ( STRING , storage . get Label ( ) ) ; return result ; }
@ Override public Map < String , Set < URI > > find Export Masks ( Storage System storage , List < String > initiator Names , boolean must Have All Ports ) throws Device Controller Exception { log . info ( STRING , storage . get Label ( ) ) ; Map < String , Set < URI > > result = new Hash Map < String , Set < URI > > ( ) ; List < Initiator > initiators = new Array List < Initiator > ( ) ; for ( String name : initiator Names ) { initiators . add ( Export Utils . get Initiator ( Initiator . to Port Network Id ( name ) , db Client ) ) ; } if ( rest API Helper . is Clustered Host ( storage , initiators ) ) { log . debug ( STRING , storage . get Label ( ) ) ; result = rest API Helper . find REST Export Masks ( storage , initiator Names , must Have All Ports ) ; } else { log . debug ( STRING , storage . get Label ( ) ) ; result = find SMIS Export Masks ( storage , initiator Names , must Have All Ports ) ; } log . info ( STRING , storage . get Label ( ) ) ; return result ; }
private Environment Variable Manager ( ) { populate ( ) ; }
public static void write File ( I File file , final File Output output , I Progress Monitor monitor ) throws Core Exception { try { Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; output . write File ( bos ) ; Byte Array Input Stream bis = new Byte Array Input Stream ( bos . to Byte Array ( ) ) ; if ( ! file . exists ( ) ) { mkdirs ( file , monitor ) ; file . create ( bis , BOOL , monitor ) ; } else { file . set Contents ( bis , BOOL , BOOL , monitor ) ; } } catch ( IO Exception e ) { I Status status = Findbugs Plugin . create Error Status ( STRING + output . get Task Description ( ) , e ) ; throw new Core Exception ( status ) ; } }
public static void write File ( I File file , final File Output output , I Progress Monitor monitor ) throws Core Exception { try { Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; output . write File ( bos ) ; Byte Array Input Stream bis = new Byte Array Input Stream ( bos . to Byte Array ( ) ) ; if ( ! file . exists ( ) ) { mkdirs ( file , monitor ) ; file . create ( bis , BOOL , monitor ) ; } else { file . set Contents ( bis , BOOL , BOOL , monitor ) ; } } catch ( IO Exception e ) { I Status status = Findbugs Plugin . create Error Status ( STRING + output . get Task Description ( ) , e ) ; throw new Core Exception ( status ) ; } }
private boolean line outside update box ( Pla Point Float p 1 , Pla Point Float p 2 , double p update offset , Shape Tile Box p update box ) { if ( p 1 == null || p 2 == null ) { return BOOL ; } if ( Math . max ( p 1 . v x , p 2 . v x ) < p update box . box ll . v x - p update offset ) { return BOOL ; } if ( Math . max ( p 1 . v y , p 2 . v y ) < p update box . box ll . v y - p update offset ) { return BOOL ; } if ( Math . min ( p 1 . v x , p 2 . v x ) > p update box . box ur . v x + p update offset ) { return BOOL ; } if ( Math . min ( p 1 . v y , p 2 . v y ) > p update box . box ur . v y + p update offset ) { return BOOL ; } return BOOL ; }
private boolean line outside update box ( Pla Point Float p 1 , Pla Point Float p 2 , double p update offset , Shape Tile Box p update box ) { if ( p 1 == null || p 2 == null ) { return BOOL ; } if ( Math . max ( p 1 . v x , p 2 . v x ) < p update box . box ll . v x - p update offset ) { return BOOL ; } if ( Math . max ( p 1 . v y , p 2 . v y ) < p update box . box ll . v y - p update offset ) { return BOOL ; } if ( Math . min ( p 1 . v x , p 2 . v x ) > p update box . box ur . v x + p update offset ) { return BOOL ; } if ( Math . min ( p 1 . v y , p 2 . v y ) > p update box . box ur . v y + p update offset ) { return BOOL ; } return BOOL ; }
private boolean line outside update box ( Pla Point Float p 1 , Pla Point Float p 2 , double p update offset , Shape Tile Box p update box ) { if ( p 1 == null || p 2 == null ) { return BOOL ; } if ( Math . max ( p 1 . v x , p 2 . v x ) < p update box . box ll . v x - p update offset ) { return BOOL ; } if ( Math . max ( p 1 . v y , p 2 . v y ) < p update box . box ll . v y - p update offset ) { return BOOL ; } if ( Math . min ( p 1 . v x , p 2 . v x ) > p update box . box ur . v x + p update offset ) { return BOOL ; } if ( Math . min ( p 1 . v y , p 2 . v y ) > p update box . box ur . v y + p update offset ) { return BOOL ; } return BOOL ; }
private boolean line outside update box ( Pla Point Float p 1 , Pla Point Float p 2 , double p update offset , Shape Tile Box p update box ) { if ( p 1 == null || p 2 == null ) { return BOOL ; } if ( Math . max ( p 1 . v x , p 2 . v x ) < p update box . box ll . v x - p update offset ) { return BOOL ; } if ( Math . max ( p 1 . v y , p 2 . v y ) < p update box . box ll . v y - p update offset ) { return BOOL ; } if ( Math . min ( p 1 . v x , p 2 . v x ) > p update box . box ur . v x + p update offset ) { return BOOL ; } if ( Math . min ( p 1 . v y , p 2 . v y ) > p update box . box ur . v y + p update offset ) { return BOOL ; } return BOOL ; }
private boolean line outside update box ( Pla Point Float p 1 , Pla Point Float p 2 , double p update offset , Shape Tile Box p update box ) { if ( p 1 == null || p 2 == null ) { return BOOL ; } if ( Math . max ( p 1 . v x , p 2 . v x ) < p update box . box ll . v x - p update offset ) { return BOOL ; } if ( Math . max ( p 1 . v y , p 2 . v y ) < p update box . box ll . v y - p update offset ) { return BOOL ; } if ( Math . min ( p 1 . v x , p 2 . v x ) > p update box . box ur . v x + p update offset ) { return BOOL ; } if ( Math . min ( p 1 . v y , p 2 . v y ) > p update box . box ur . v y + p update offset ) { return BOOL ; } return BOOL ; }
private boolean line outside update box ( Pla Point Float p 1 , Pla Point Float p 2 , double p update offset , Shape Tile Box p update box ) { if ( p 1 == null || p 2 == null ) { return BOOL ; } if ( Math . max ( p 1 . v x , p 2 . v x ) < p update box . box ll . v x - p update offset ) { return BOOL ; } if ( Math . max ( p 1 . v y , p 2 . v y ) < p update box . box ll . v y - p update offset ) { return BOOL ; } if ( Math . min ( p 1 . v x , p 2 . v x ) > p update box . box ur . v x + p update offset ) { return BOOL ; } if ( Math . min ( p 1 . v y , p 2 . v y ) > p update box . box ur . v y + p update offset ) { return BOOL ; } return BOOL ; }
@ Override public String to String ( ) { return text . to String ( ) ; }
private void recursive Delete ( final File f ) { if ( f . is Directory ( ) ) { final File [ ] children = f . list Files ( ) ; for ( int i = NUM ; i < children . length ; i ++ ) { recursive Delete ( children [ i ] ) ; } } if ( log . is Info Enabled ( ) ) log . info ( STRING + f ) ; if ( f . exists ( ) && ! f . delete ( ) ) { log . warn ( STRING + f ) ; } }
protected String Builder siblings ( Entry Hierarchy Data sibling , boolean is Popup ) throws IO Exception { String Builder siblings = new String Builder ( ) ; final Simple Entry included Entry = entry Data Matched ( sibling ) ; if ( included Entry != null ) { append Entry ( included Entry , siblings , is Popup ) ; } siblings . append ( children ( sibling ) ) ; if ( included Entry != null ) { siblings . append ( STRING ) ; } return siblings ; }
protected String Builder siblings ( Entry Hierarchy Data sibling , boolean is Popup ) throws IO Exception { String Builder siblings = new String Builder ( ) ; final Simple Entry included Entry = entry Data Matched ( sibling ) ; if ( included Entry != null ) { append Entry ( included Entry , siblings , is Popup ) ; } siblings . append ( children ( sibling ) ) ; if ( included Entry != null ) { siblings . append ( STRING ) ; } return siblings ; }
protected String Builder siblings ( Entry Hierarchy Data sibling , boolean is Popup ) throws IO Exception { String Builder siblings = new String Builder ( ) ; final Simple Entry included Entry = entry Data Matched ( sibling ) ; if ( included Entry != null ) { append Entry ( included Entry , siblings , is Popup ) ; } siblings . append ( children ( sibling ) ) ; if ( included Entry != null ) { siblings . append ( STRING ) ; } return siblings ; }
protected String Builder siblings ( Entry Hierarchy Data sibling , boolean is Popup ) throws IO Exception { String Builder siblings = new String Builder ( ) ; final Simple Entry included Entry = entry Data Matched ( sibling ) ; if ( included Entry != null ) { append Entry ( included Entry , siblings , is Popup ) ; } siblings . append ( children ( sibling ) ) ; if ( included Entry != null ) { siblings . append ( STRING ) ; } return siblings ; }
public static int compare ( Date left , boolean right ) { return compare ( left , right ? NUM : NUM ) ; }
@ Override public void do Run Keys ( int run ) throws Exception { Object [ ] template = determine Template ( run ) ; String [ ] new Key = new String [ template . length - NUM ] ; System . arraycopy ( template , NUM , new Key , NUM , m Key Index ) ; System . arraycopy ( template , m Key Index + NUM , new Key , m Key Index , template . length - m Key Index - NUM ) ; m Result Listener . accept Result ( this , new Key , null ) ; }
public int count Array ( String [ ] array ) { return array . length ; }
public void send ( byte [ ] data , int id ) { boolean is First Packet = ( packets . size ( ) == NUM ) ; packets . add ( data ) ; ids . add ( id ) ; if ( is First Packet ) { schedule Send Task ( BOOL ) ; } Log . d ( TAG , STRING + id + STRING + packets . size ( ) + STRING ) ; }
public void send ( byte [ ] data , int id ) { boolean is First Packet = ( packets . size ( ) == NUM ) ; packets . add ( data ) ; ids . add ( id ) ; if ( is First Packet ) { schedule Send Task ( BOOL ) ; } Log . d ( TAG , STRING + id + STRING + packets . size ( ) + STRING ) ; }
public void send ( byte [ ] data , int id ) { boolean is First Packet = ( packets . size ( ) == NUM ) ; packets . add ( data ) ; ids . add ( id ) ; if ( is First Packet ) { schedule Send Task ( BOOL ) ; } Log . d ( TAG , STRING + id + STRING + packets . size ( ) + STRING ) ; }
public Str Builder replace ( int start Index , int end Index , String replace Str ) { end Index = validate Range ( start Index , end Index ) ; int insert Len = ( replace Str == null ? NUM : replace Str . length ( ) ) ; replace Impl ( start Index , end Index , end Index - start Index , replace Str , insert Len ) ; return this ; }
public void add Observer ( Observer observer ) { if ( observer == null ) { throw new Null Pointer Exception ( STRING ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public void add Observer ( Observer observer ) { if ( observer == null ) { throw new Null Pointer Exception ( STRING ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public void add Observer ( Observer observer ) { if ( observer == null ) { throw new Null Pointer Exception ( STRING ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public String extract classname ( String fullname ) { return fullname . replace First ( STRING , STRING ) ; }
public String extract classname ( String fullname ) { return fullname . replace First ( STRING , STRING ) ; }
public void append ( Char Sequence s ) { text . append ( s ) ; }
public Pdf Array ( Pdf Object obj ) { this ( ) ; list . add ( obj ) ; }
public Pdf Array ( Pdf Object obj ) { this ( ) ; list . add ( obj ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return ID ; case NUM : return UID ; default : return null ; } }
public static boolean is Right Mouse Button ( Mouse Event an Event ) { return ( ( an Event . get Modifiers Ex ( ) & Input Event . BUTTON 3 DOWN MASK ) != NUM || an Event . get Button ( ) == Mouse Event . BUTTON 3 ) ; }
public static boolean is Right Mouse Button ( Mouse Event an Event ) { return ( ( an Event . get Modifiers Ex ( ) & Input Event . BUTTON 3 DOWN MASK ) != NUM || an Event . get Button ( ) == Mouse Event . BUTTON 3 ) ; }
public void flush ( ) throws IO Exception { if ( out == null ) { out . flush ( ) ; } }
public Validator add Submit Buttons ( Component ... cmp ) { boolean is V = is Valid ( ) ; for ( Component c : cmp ) { submit Buttons . add ( c ) ; c . set Enabled ( is V ) ; } return this ; }
public Validator add Submit Buttons ( Component ... cmp ) { boolean is V = is Valid ( ) ; for ( Component c : cmp ) { submit Buttons . add ( c ) ; c . set Enabled ( is V ) ; } return this ; }
public Validator add Submit Buttons ( Component ... cmp ) { boolean is V = is Valid ( ) ; for ( Component c : cmp ) { submit Buttons . add ( c ) ; c . set Enabled ( is V ) ; } return this ; }
public Validator add Submit Buttons ( Component ... cmp ) { boolean is V = is Valid ( ) ; for ( Component c : cmp ) { submit Buttons . add ( c ) ; c . set Enabled ( is V ) ; } return this ; }
public Validator add Submit Buttons ( Component ... cmp ) { boolean is V = is Valid ( ) ; for ( Component c : cmp ) { submit Buttons . add ( c ) ; c . set Enabled ( is V ) ; } return this ; }
private Map < String , File Entry > read Entries ( byte [ ] segment ID , Directory dir , String entries File Name ) throws IO Exception { Map < String , File Entry > mapping = null ; try ( Checksum Index Input entries Stream = dir . open Checksum Input ( entries File Name , IO Context . READONCE ) ) { Throwable prior E = null ; try { version = Codec Util . check Index Header ( entries Stream , Lucene 50 Compound Format . ENTRY CODEC , Lucene 50 Compound Format . VERSION START , Lucene 50 Compound Format . VERSION CURRENT , segment ID , STRING ) ; final int num Entries = entries Stream . read V Int ( ) ; mapping = new Hash Map < > ( num Entries ) ; for ( int i = NUM ; i < num Entries ; i ++ ) { final File Entry file Entry = new File Entry ( ) ; final String id = entries Stream . read String ( ) ; File Entry previous = mapping . put ( id , file Entry ) ; if ( previous != null ) { throw new Corrupt Index Exception ( STRING + id + STRING , entries Stream ) ; } file Entry . offset = entries Stream . read Long ( ) ; file Entry . length = entries Stream . read Long ( ) ; } } catch ( Throwable exception ) { prior E = exception ; } finally { Codec Util . check Footer ( entries Stream , prior E ) ; } } return Collections . unmodifiable Map ( mapping ) ; }
private Map < String , File Entry > read Entries ( byte [ ] segment ID , Directory dir , String entries File Name ) throws IO Exception { Map < String , File Entry > mapping = null ; try ( Checksum Index Input entries Stream = dir . open Checksum Input ( entries File Name , IO Context . READONCE ) ) { Throwable prior E = null ; try { version = Codec Util . check Index Header ( entries Stream , Lucene 50 Compound Format . ENTRY CODEC , Lucene 50 Compound Format . VERSION START , Lucene 50 Compound Format . VERSION CURRENT , segment ID , STRING ) ; final int num Entries = entries Stream . read V Int ( ) ; mapping = new Hash Map < > ( num Entries ) ; for ( int i = NUM ; i < num Entries ; i ++ ) { final File Entry file Entry = new File Entry ( ) ; final String id = entries Stream . read String ( ) ; File Entry previous = mapping . put ( id , file Entry ) ; if ( previous != null ) { throw new Corrupt Index Exception ( STRING + id + STRING , entries Stream ) ; } file Entry . offset = entries Stream . read Long ( ) ; file Entry . length = entries Stream . read Long ( ) ; } } catch ( Throwable exception ) { prior E = exception ; } finally { Codec Util . check Footer ( entries Stream , prior E ) ; } } return Collections . unmodifiable Map ( mapping ) ; }
@ Override public void add Attribute ( String name , float value ) { String str = Float . to String ( value ) ; if ( str . ends With ( STRING ) ) str = str . substring ( NUM , str . length ( ) - NUM ) ; current . set Attribute ( name , str ) ; }
protected abstract void bind Item ( Data Bound View Holder < T > holder , int position , List < Object > payloads ) ;
public static String wrap ( String s , int n ) { String Buffer b = new String Buffer ( ) ; boolean wrap Pending = BOOL ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { if ( i % n == NUM && i > NUM ) { wrap Pending = BOOL ; } char c = s . char At ( i ) ; if ( wrap Pending && c == STRING ) { b . append ( STRING ) ; wrap Pending = BOOL ; } else { b . append ( c ) ; } } return b . to String ( ) ; }
public static String wrap ( String s , int n ) { String Buffer b = new String Buffer ( ) ; boolean wrap Pending = BOOL ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { if ( i % n == NUM && i > NUM ) { wrap Pending = BOOL ; } char c = s . char At ( i ) ; if ( wrap Pending && c == STRING ) { b . append ( STRING ) ; wrap Pending = BOOL ; } else { b . append ( c ) ; } } return b . to String ( ) ; }
public boolean match ( String requested URL , Collection < String > patterns , boolean wildcard ) throws Malformed URL Exception { boolean result = BOOL ; String pattern Lower ; for ( String pattern : patterns ) { pattern Lower = pattern . to Lower Case ( ) ; requested URL = resource Name . canonicalize ( requested URL ) ; if ( pattern Lower . starts With ( STRING ) ) { pattern = resource Name . canonicalize ( pattern ) ; } if ( DEBUG . message Enabled ( ) ) { DEBUG . message ( STRING + requested URL + STRING + pattern ) ; } Resource Match res = resource Name . compare ( requested URL , pattern , wildcard ) ; if ( res == Resource Match . WILDCARD MATCH || res == Resource Match . EXACT MATCH ) { if ( DEBUG . message Enabled ( ) ) { DEBUG . message ( STRING + requested URL + STRING + pattern + STRING + res ) ; } result = BOOL ; break ; } } return result ; }
public static Intent open Directory Browser ( Context context , Uri default Path , String title ) { return open Directory Browser ( context , default Path , title , BOOL ) ; }
public static Intent open Directory Browser ( Context context , Uri default Path , String title ) { return open Directory Browser ( context , default Path , title , BOOL ) ; }
public Script Builder add Chunk ( int index , Script Chunk chunk ) { chunks . add ( index , chunk ) ; return this ; }
public Script Builder add Chunk ( int index , Script Chunk chunk ) { chunks . add ( index , chunk ) ; return this ; }
public Select Clause add ( Expression expression ) { select List . add ( new Select Clause Expression ( expression ) ) ; return this ; }
public static String no Quote ( String input ) { if ( input . contains ( STRING ) ) { throw new Illegal Argument Exception ( STRING + input + STRING ) ; } else { return input ; } }
public static String no Quote ( String input ) { if ( input . contains ( STRING ) ) { throw new Illegal Argument Exception ( STRING + input + STRING ) ; } else { return input ; } }
private void add Arg ( String key , Object value ) { if ( request Arguments == null ) { request Arguments = new Hashtable ( ) ; } if ( value == null || key == null ) { return ; } if ( post ) { set Write Request ( BOOL ) ; } request Arguments . put ( key , value ) ; }
public synchronized String lookup Text ( String inputtype , String outputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext ) throws SQL Exception { if ( inputtype == null || outputtype == null || locale == null || voice == null || inputtext == null ) { throw new Null Pointer Exception ( STRING ) ; } String outputtext = null ; String query = STRING + inputtype + STRING + outputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; Prepared Statement st = connection . prepare Statement ( query ) ; st . set String ( NUM , inputtext ) ; Result Set results = st . execute Query ( ) ; if ( results . next ( ) ) { outputtext = results . get String ( NUM ) ; } st . close ( ) ; return outputtext ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
public CC Timer ( Object t , String s , float seconds ) { target = t ; selector = s ; interval = seconds ; elapsed = - NUM ; try { Class < ? > cls = target . get Class ( ) ; invocation = cls . get Method ( s , Float . TYPE ) ; } catch ( No Such Method Exception e ) { e . print Stack Trace ( ) ; } }
public int size ( ) { return m sets . size ( ) ; }
public static String build Scenario ( String url ) { if ( url == null ) { return null ; } String Builder strb = new String Builder ( ) ; strb . append ( build Header ( ) ) ; strb . append ( build Get Step ( url ) ) ; strb . append ( build Footer ( ) ) ; return strb . to String ( ) ; }
public void write ( Pdf Document document ) throws IO Exception { set Xfa Form ( this , document ) ; }
public Source Call Chain Info ( Soot Method m , Stmt s , String type ) { this . type = type ; this . link = STRING ; this . method = m ; this . stmt = s ; calls = NUM ; if ( type . equals ( STRING ) ) syscalls = NUM ; }
private void update Textured ( ) { paint Textured = ( root . get Client Property ( UNIFIED TOOLBAR LOOK ) == Boolean . TRUE ) ; if ( paint Textured && Platform Utils . is Mac ( ) ) { if ( root . is Valid ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } root . put Client Property ( STRING , Boolean . TRUE ) ; Look And Feel . install Property ( ( J Component ) root . get Content Pane ( ) , STRING , Boolean . FALSE ) ; } else { root . put Client Property ( STRING , null ) ; } }
@ Override public Completable Future < Optional < T > > reduce ( final Binary Operator < T > accumulator ) { return Completable Future . supply Async ( null ) ; }
public static String byte Array To Hex String ( final byte in [ ] ) { final String pseudo [ ] = { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; if ( in == null || in . length <= NUM ) { return STRING ; } final String Builder out = new String Builder ( in . length * NUM ) ; for ( final byte b : in ) { byte ch = ( byte ) ( b & NUM ) ; ch = ( byte ) ( ch > > > NUM ) ; ch = ( byte ) ( ch & NUM ) ; out . append ( pseudo [ ( int ) ch ] ) ; ch = ( byte ) ( b & NUM ) ; out . append ( pseudo [ ( int ) ch ] ) ; } return out . to String ( ) ; }
public static String byte Array To Hex String ( final byte in [ ] ) { final String pseudo [ ] = { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; if ( in == null || in . length <= NUM ) { return STRING ; } final String Builder out = new String Builder ( in . length * NUM ) ; for ( final byte b : in ) { byte ch = ( byte ) ( b & NUM ) ; ch = ( byte ) ( ch > > > NUM ) ; ch = ( byte ) ( ch & NUM ) ; out . append ( pseudo [ ( int ) ch ] ) ; ch = ( byte ) ( b & NUM ) ; out . append ( pseudo [ ( int ) ch ] ) ; } return out . to String ( ) ; }
public static String byte Array To Hex String ( final byte in [ ] ) { final String pseudo [ ] = { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; if ( in == null || in . length <= NUM ) { return STRING ; } final String Builder out = new String Builder ( in . length * NUM ) ; for ( final byte b : in ) { byte ch = ( byte ) ( b & NUM ) ; ch = ( byte ) ( ch > > > NUM ) ; ch = ( byte ) ( ch & NUM ) ; out . append ( pseudo [ ( int ) ch ] ) ; ch = ( byte ) ( b & NUM ) ; out . append ( pseudo [ ( int ) ch ] ) ; } return out . to String ( ) ; }
public static void assert Label ( String name , String text ) { if ( verbose ) { log ( STRING + name + STRING + text + STRING ) ; } Label l = ( Label ) find By Name ( name ) ; assert Bool ( l != null , STRING + text ) ; assert Bool ( text == l . get Text ( ) || text . equals ( l . get Text ( ) ) , name + STRING + text ) ; }
public static void assert Label ( String name , String text ) { if ( verbose ) { log ( STRING + name + STRING + text + STRING ) ; } Label l = ( Label ) find By Name ( name ) ; assert Bool ( l != null , STRING + text ) ; assert Bool ( text == l . get Text ( ) || text . equals ( l . get Text ( ) ) , name + STRING + text ) ; }
public static void assert Label ( String name , String text ) { if ( verbose ) { log ( STRING + name + STRING + text + STRING ) ; } Label l = ( Label ) find By Name ( name ) ; assert Bool ( l != null , STRING + text ) ; assert Bool ( text == l . get Text ( ) || text . equals ( l . get Text ( ) ) , name + STRING + text ) ; }
public void add Focus Group ( String group , Tuple Set tset ) { check Group Exists ( group ) ; m focus . put ( group , tset ) ; }
public Creature calculate Next Creature ( final int quest Level ) { final List < Creature > possible Creatures To Spawn = new Array List < Creature > ( ) ; int last Level = NUM ; for ( final Creature creature : sorted Creatures ) { if ( creature . get Level ( ) > quest Level ) { break ; } if ( creature . get Level ( ) > last Level ) { possible Creatures To Spawn . clear ( ) ; last Level = creature . get Level ( ) ; } possible Creatures To Spawn . add ( creature ) ; } Creature creature To Spawn = null ; if ( possible Creatures To Spawn . size ( ) == NUM ) { creature To Spawn = sorted Creatures . get ( sorted Creatures . size ( ) - NUM ) ; } else { Collections . shuffle ( possible Creatures To Spawn ) ; creature To Spawn = possible Creatures To Spawn . get ( NUM ) ; } return creature To Spawn ; }
private String multiple Selector String ( int current Number , int individual Total , int total Number ) { Number Sequencer tmp Sequencer = new Number Sequencer ( total Number ) ; tmp Sequencer . set Current Number ( current Number ) ; String Builder selector String = new String Builder ( ) ; for ( int i = NUM ; i < individual Total ; i ++ ) { selector String . append ( single Selector String ( tmp Sequencer . next Number ( ) ) ) ; if ( i > NUM ) { selector String . append ( STRING ) ; } } return selector String . to String ( ) ; }
private String multiple Selector String ( int current Number , int individual Total , int total Number ) { Number Sequencer tmp Sequencer = new Number Sequencer ( total Number ) ; tmp Sequencer . set Current Number ( current Number ) ; String Builder selector String = new String Builder ( ) ; for ( int i = NUM ; i < individual Total ; i ++ ) { selector String . append ( single Selector String ( tmp Sequencer . next Number ( ) ) ) ; if ( i > NUM ) { selector String . append ( STRING ) ; } } return selector String . to String ( ) ; }
private String multiple Selector String ( int current Number , int individual Total , int total Number ) { Number Sequencer tmp Sequencer = new Number Sequencer ( total Number ) ; tmp Sequencer . set Current Number ( current Number ) ; String Builder selector String = new String Builder ( ) ; for ( int i = NUM ; i < individual Total ; i ++ ) { selector String . append ( single Selector String ( tmp Sequencer . next Number ( ) ) ) ; if ( i > NUM ) { selector String . append ( STRING ) ; } } return selector String . to String ( ) ; }
protected double calculate Bar W 0 ( Category Plot plot , Plot Orientation orientation , Rectangle 2 D data Area , Category Axis domain Axis , Category Item Renderer State state , int row , int column ) { double space ; if ( orientation == Plot Orientation . HORIZONTAL ) { space = data Area . get Height ( ) ; } else { space = data Area . get Width ( ) ; } double bar W 0 = domain Axis . get Category Start ( column , get Column Count ( ) , data Area , plot . get Domain Axis Edge ( ) ) ; int series Count = state . get Visible Series Count ( ) >= NUM ? state . get Visible Series Count ( ) : get Row Count ( ) ; int category Count = get Column Count ( ) ; if ( series Count > NUM ) { double series Gap = space * get Item Margin ( ) / ( category Count * ( series Count - NUM ) ) ; double series W = calculate Series Width ( space , domain Axis , category Count , series Count ) ; bar W 0 = bar W 0 + row * ( series W + series Gap ) + ( series W / NUM ) - ( state . get Bar Width ( ) / NUM ) ; } else { bar W 0 = domain Axis . get Category Middle ( column , get Column Count ( ) , data Area , plot . get Domain Axis Edge ( ) ) - state . get Bar Width ( ) / NUM ; } return bar W 0 ; }
public void test Get Namespace URI 2 ( ) throws Throwable { Document doc ; Node List element List ; Element test Addr ; Attr addr Attr ; String attr Namespace URI ; doc = ( Document ) load ( STRING , builder ) ; element List = doc . get Elements By Tag Name ( STRING ) ; test Addr = ( Element ) element List . item ( NUM ) ; assert Not Null ( STRING , test Addr ) ; addr Attr = test Addr . get Attribute Node NS ( STRING , STRING ) ; attr Namespace URI = addr Attr . get Namespace URI ( ) ; assert Equals ( STRING , STRING , attr Namespace URI ) ; }
public static int random Int ( int lower Than ) { return RANDOM . next Int ( lower Than ) ; }
public void add Default Version ( Version new Default , boolean include Implied ) { Array List < Version > new Defaults = new Array List < Version > ( default Versions ) ; if ( include Implied ) { merge Versions ( new Defaults , new Default . get Implied Versions ( ) ) ; } else { merge Versions ( new Defaults , new Default ) ; } default Versions = Collections . unmodifiable List ( new Defaults ) ; }
public void add Default Version ( Version new Default , boolean include Implied ) { Array List < Version > new Defaults = new Array List < Version > ( default Versions ) ; if ( include Implied ) { merge Versions ( new Defaults , new Default . get Implied Versions ( ) ) ; } else { merge Versions ( new Defaults , new Default ) ; } default Versions = Collections . unmodifiable List ( new Defaults ) ; }
public void add Default Version ( Version new Default , boolean include Implied ) { Array List < Version > new Defaults = new Array List < Version > ( default Versions ) ; if ( include Implied ) { merge Versions ( new Defaults , new Default . get Implied Versions ( ) ) ; } else { merge Versions ( new Defaults , new Default ) ; } default Versions = Collections . unmodifiable List ( new Defaults ) ; }
public Search Builder filter ( Condition Builder < ? , ? > ... builders ) { filter . add All ( Arrays . as List ( builders ) ) ; return this ; }
public abstract String create Query String ( Projection p ) ;
public abstract String create Query String ( Projection p ) ;
public void add Prefix ( String prefix , String namespace URI ) { log . log ( Level . FINE , STRING , new Object [ ] { prefix , namespace URI } ) ; if ( prefix == null || namespace URI == null ) { throw new Illegal Argument Exception ( STRING ) ; } prefix To Namespace . put ( prefix , namespace URI ) ; Set < String > prefixes = namespace To Prefix . get ( namespace URI ) ; if ( prefixes == null ) { prefixes = new Hash Set < String > ( ) ; } prefixes . add ( prefix ) ; namespace To Prefix . put ( namespace URI , prefixes ) ; }
public static void write Histogram ( T Double Double Hash Map distr , String filename ) throws File Not Found Exception , IO Exception { Buffered Writer a Writer = IO Utils . get Buffered Writer ( filename ) ; a Writer . write ( STRING ) ; a Writer . new Line ( ) ; double [ ] keys = distr . keys ( ) ; Arrays . sort ( keys ) ; for ( double key : keys ) { a Writer . write ( String . value Of ( key ) ) ; a Writer . write ( STRING ) ; a Writer . write ( String . value Of ( distr . get ( key ) ) ) ; a Writer . new Line ( ) ; } a Writer . close ( ) ; }
public static void write Histogram ( T Double Double Hash Map distr , String filename ) throws File Not Found Exception , IO Exception { Buffered Writer a Writer = IO Utils . get Buffered Writer ( filename ) ; a Writer . write ( STRING ) ; a Writer . new Line ( ) ; double [ ] keys = distr . keys ( ) ; Arrays . sort ( keys ) ; for ( double key : keys ) { a Writer . write ( String . value Of ( key ) ) ; a Writer . write ( STRING ) ; a Writer . write ( String . value Of ( distr . get ( key ) ) ) ; a Writer . new Line ( ) ; } a Writer . close ( ) ; }
public static void write Histogram ( T Double Double Hash Map distr , String filename ) throws File Not Found Exception , IO Exception { Buffered Writer a Writer = IO Utils . get Buffered Writer ( filename ) ; a Writer . write ( STRING ) ; a Writer . new Line ( ) ; double [ ] keys = distr . keys ( ) ; Arrays . sort ( keys ) ; for ( double key : keys ) { a Writer . write ( String . value Of ( key ) ) ; a Writer . write ( STRING ) ; a Writer . write ( String . value Of ( distr . get ( key ) ) ) ; a Writer . new Line ( ) ; } a Writer . close ( ) ; }
public static void write Histogram ( T Double Double Hash Map distr , String filename ) throws File Not Found Exception , IO Exception { Buffered Writer a Writer = IO Utils . get Buffered Writer ( filename ) ; a Writer . write ( STRING ) ; a Writer . new Line ( ) ; double [ ] keys = distr . keys ( ) ; Arrays . sort ( keys ) ; for ( double key : keys ) { a Writer . write ( String . value Of ( key ) ) ; a Writer . write ( STRING ) ; a Writer . write ( String . value Of ( distr . get ( key ) ) ) ; a Writer . new Line ( ) ; } a Writer . close ( ) ; }
public void exec ( String description , String [ ] base Command ) throws Backup Exception { exec ( description , base Command , null , null , null , BOOL , BOOL ) ; }
@ Override public Alarm Event evaluate ( Alarm Point alarm , String trigger ) { if ( trigger . equals ( Alarm Point . TRIGGER ACTIVATE ) ) { return activation ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER DEACTIVATE ) ) { return deactivation ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER ACKNOWLEDGE ) ) { return acknowledge ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER BLOCK ) ) { return block ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER UNBLOCK ) ) { return unblock ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER ENABLE ) ) { return enable ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER DISABLE ) ) { return disable ( alarm ) ; } else { throw new Illegal Argument Exception ( STRING + trigger + STRING ) ; } }
@ Override public Alarm Event evaluate ( Alarm Point alarm , String trigger ) { if ( trigger . equals ( Alarm Point . TRIGGER ACTIVATE ) ) { return activation ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER DEACTIVATE ) ) { return deactivation ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER ACKNOWLEDGE ) ) { return acknowledge ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER BLOCK ) ) { return block ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER UNBLOCK ) ) { return unblock ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER ENABLE ) ) { return enable ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER DISABLE ) ) { return disable ( alarm ) ; } else { throw new Illegal Argument Exception ( STRING + trigger + STRING ) ; } }
public void write Batch ( ) throws IO Exception { if ( get Retrieval ( ) == INCREMENTAL ) throw new IO Exception ( STRING ) ; if ( get Instances ( ) == null ) throw new IO Exception ( STRING ) ; set Retrieval ( BATCH ) ; if ( m objectstream == null ) throw new IO Exception ( STRING ) ; set Write Mode ( WRITE ) ; m objectstream . write Object ( get Instances ( ) ) ; m objectstream . flush ( ) ; m objectstream . close ( ) ; set Write Mode ( WAIT ) ; reset Writer ( ) ; set Write Mode ( CANCEL ) ; }
V Plex Consistency Group Info find Consistency Group ( String cg Name , List < V Plex Cluster Info > cluster Info List , boolean fetch Atts ) throws V Plex Api Exception { return find Consistency Group ( cg Name , cluster Info List , fetch Atts , BOOL ) ; }
public void write Exif ( Input Stream jpeg Stream , Output Stream exif Out Stream ) throws IO Exception { if ( jpeg Stream == null || exif Out Stream == null ) { throw new Illegal Argument Exception ( NULL ARGUMENT STRING ) ; } Output Stream s = get Exif Writer Stream ( exif Out Stream ) ; do Exif Stream IO ( jpeg Stream , s ) ; s . flush ( ) ; }
public void write Exif ( Input Stream jpeg Stream , Output Stream exif Out Stream ) throws IO Exception { if ( jpeg Stream == null || exif Out Stream == null ) { throw new Illegal Argument Exception ( NULL ARGUMENT STRING ) ; } Output Stream s = get Exif Writer Stream ( exif Out Stream ) ; do Exif Stream IO ( jpeg Stream , s ) ; s . flush ( ) ; }
public void write Exif ( Input Stream jpeg Stream , Output Stream exif Out Stream ) throws IO Exception { if ( jpeg Stream == null || exif Out Stream == null ) { throw new Illegal Argument Exception ( NULL ARGUMENT STRING ) ; } Output Stream s = get Exif Writer Stream ( exif Out Stream ) ; do Exif Stream IO ( jpeg Stream , s ) ; s . flush ( ) ; }
public void search ( ) { perform Search ( ) ; }
public void search ( ) { perform Search ( ) ; }
public static Class Node [ ] make ( Class [ ] classes ) { Class Node [ ] cns = new Class Node [ classes . length ] ; for ( int i = NUM ; i < cns . length ; i ++ ) { cns [ i ] = make ( classes [ i ] ) ; } return cns ; }
private void init ( Tuple input ) { profile Config = ( Profile Config ) input . get Value By Field ( STRING ) ; measurement = new Profile Measurement ( profile Config . get Profile ( ) , input . get String By Field ( STRING ) , get Timestamp ( ) , period Duration Millis , Time Unit . MILLISECONDS ) ; try { JSON Object message = ( JSON Object ) input . get Value By Field ( STRING ) ; Map < String , String > expressions = profile Config . get Init ( ) ; expressions . for Each ( null ) ; } catch ( Parse Exception e ) { String msg = format ( STRING , e . get Message ( ) , measurement . get Profile Name ( ) , measurement . get Entity ( ) ) ; throw new Parse Exception ( msg , e ) ; } }
public Configurable Jta Platform ( Transaction Manager tm , User Transaction ut ) { Assert . not Null ( tm , STRING ) ; this . transaction Manager = tm ; this . user Transaction = ( ut != null ? ut : new User Transaction Adapter ( tm ) ) ; }
public String ( byte [ ] data , String encoding ) throws Unsupported Encoding Exception { this ( data , NUM , data . length , encoding ) ; }
public void delete ( Job Notification current Notification ) { for ( int i = notifications . size ( ) ; -- i >= NUM ; ) { if ( notifications . get ( i ) == current Notification ) { notifications . remove ( i ) ; break ; } } }
public void delete ( Job Notification current Notification ) { for ( int i = notifications . size ( ) ; -- i >= NUM ; ) { if ( notifications . get ( i ) == current Notification ) { notifications . remove ( i ) ; break ; } } }
public void delete ( Job Notification current Notification ) { for ( int i = notifications . size ( ) ; -- i >= NUM ; ) { if ( notifications . get ( i ) == current Notification ) { notifications . remove ( i ) ; break ; } } }
public void delete ( Job Notification current Notification ) { for ( int i = notifications . size ( ) ; -- i >= NUM ; ) { if ( notifications . get ( i ) == current Notification ) { notifications . remove ( i ) ; break ; } } }
@ Override public Request < String > logs ( Project Reference project Reference , long task Id ) { List < Dummy Builder Status > statuses = available Builder Statuses . get ( project Reference . name ( ) ) ; if ( statuses != null && ! statuses . is Empty ( ) ) { for ( Dummy Builder Status builder Status : statuses ) { if ( task Id == builder Status . task Id ( ) ) { return new Dummy Request < > ( builder Status . get Log ( ) ) ; } } } return new Dummy Request < > ( null ) ; }
public void checkin Connection ( DB Connection Wrapper conn ) { if ( conn == null ) return ; conn . set Current Statement ( null ) ; conn . set Inuse ( BOOL ) ; }
public void checkin Connection ( DB Connection Wrapper conn ) { if ( conn == null ) return ; conn . set Current Statement ( null ) ; conn . set Inuse ( BOOL ) ; }
public void consume Integers ( String topic Name , int count , long timeout , Time Unit unit , Runnable completion , Bi Predicate < String , Integer > consumer ) { Atomic Long read Counter = new Atomic Long ( ) ; consume Integers ( continue If Not Expired ( null , timeout , unit ) , completion , Collections . singleton ( topic Name ) , null ) ; }
public void consume Integers ( String topic Name , int count , long timeout , Time Unit unit , Runnable completion , Bi Predicate < String , Integer > consumer ) { Atomic Long read Counter = new Atomic Long ( ) ; consume Integers ( continue If Not Expired ( null , timeout , unit ) , completion , Collections . singleton ( topic Name ) , null ) ; }
public void encode ( Der Output Stream out ) throws IO Exception { Der Output Stream tagged = new Der Output Stream ( ) ; if ( ( full Name != null ) || ( relative Name != null ) ) { Der Output Stream distribution Point = new Der Output Stream ( ) ; if ( full Name != null ) { Der Output Stream der Out = new Der Output Stream ( ) ; full Name . encode ( der Out ) ; distribution Point . write Implicit ( Der Value . create Tag ( Der Value . TAG CONTEXT , BOOL , TAG FULL NAME ) , der Out ) ; } else if ( relative Name != null ) { Der Output Stream der Out = new Der Output Stream ( ) ; relative Name . encode ( der Out ) ; distribution Point . write Implicit ( Der Value . create Tag ( Der Value . TAG CONTEXT , BOOL , TAG REL NAME ) , der Out ) ; } tagged . write ( Der Value . create Tag ( Der Value . TAG CONTEXT , BOOL , TAG DIST PT ) , distribution Point ) ; } if ( reason Flags != null ) { Der Output Stream reasons = new Der Output Stream ( ) ; Bit Array rf = new Bit Array ( reason Flags ) ; reasons . put Truncated Unaligned Bit String ( rf ) ; tagged . write Implicit ( Der Value . create Tag ( Der Value . TAG CONTEXT , BOOL , TAG REASONS ) , reasons ) ; } if ( crl Issuer != null ) { Der Output Stream issuer = new Der Output Stream ( ) ; crl Issuer . encode ( issuer ) ; tagged . write Implicit ( Der Value . create Tag ( Der Value . TAG CONTEXT , BOOL , TAG ISSUER ) , issuer ) ; } out . write ( Der Value . tag Sequence , tagged ) ; }
public void test Prepared Properties Not Contain Old Values ( ) throws Exception { String namespace = STRING ; Properties properties = new Properties ( ) ; properties . put ( Remote Repository . OPTION CREATE KB NAMESPACE , namespace ) ; properties . put ( STRING + Remote Repository . DEFAULT NAMESPACE + STRING , STRING ) ; properties . put ( STRING + Remote Repository . DEFAULT NAMESPACE + STRING , STRING ) ; final Properties p = m mgr . get Prepared Properties ( namespace , properties ) ; assert False ( p . contains Key ( STRING + Remote Repository . DEFAULT NAMESPACE + STRING ) ) ; assert False ( p . contains Key ( STRING + Remote Repository . DEFAULT NAMESPACE + STRING ) ) ; }
public void test Prepared Properties Not Contain Old Values ( ) throws Exception { String namespace = STRING ; Properties properties = new Properties ( ) ; properties . put ( Remote Repository . OPTION CREATE KB NAMESPACE , namespace ) ; properties . put ( STRING + Remote Repository . DEFAULT NAMESPACE + STRING , STRING ) ; properties . put ( STRING + Remote Repository . DEFAULT NAMESPACE + STRING , STRING ) ; final Properties p = m mgr . get Prepared Properties ( namespace , properties ) ; assert False ( p . contains Key ( STRING + Remote Repository . DEFAULT NAMESPACE + STRING ) ) ; assert False ( p . contains Key ( STRING + Remote Repository . DEFAULT NAMESPACE + STRING ) ) ; }
public void test Prepared Properties Not Contain Old Values ( ) throws Exception { String namespace = STRING ; Properties properties = new Properties ( ) ; properties . put ( Remote Repository . OPTION CREATE KB NAMESPACE , namespace ) ; properties . put ( STRING + Remote Repository . DEFAULT NAMESPACE + STRING , STRING ) ; properties . put ( STRING + Remote Repository . DEFAULT NAMESPACE + STRING , STRING ) ; final Properties p = m mgr . get Prepared Properties ( namespace , properties ) ; assert False ( p . contains Key ( STRING + Remote Repository . DEFAULT NAMESPACE + STRING ) ) ; assert False ( p . contains Key ( STRING + Remote Repository . DEFAULT NAMESPACE + STRING ) ) ; }
private Grid Cache Version min Version ( Iterable < Ignite Tx Entry > entries , Grid Cache Version min , Ignite Internal Tx tx ) { for ( Ignite Tx Entry tx Entry : entries ) { Grid Cache Entry Ex cached = tx Entry . cached ( ) ; assert tx Entry . is Read ( ) || ! cached . obsolete ( tx . xid Version ( ) ) : STRING + cached + STRING + tx + STRING ; for ( Grid Cache Mvcc Candidate cand : cached . remote Mvcc Snapshot ( ) ) if ( min == null || cand . version ( ) . is Less ( min ) ) min = cand . version ( ) ; } return min ; }
private Grid Cache Version min Version ( Iterable < Ignite Tx Entry > entries , Grid Cache Version min , Ignite Internal Tx tx ) { for ( Ignite Tx Entry tx Entry : entries ) { Grid Cache Entry Ex cached = tx Entry . cached ( ) ; assert tx Entry . is Read ( ) || ! cached . obsolete ( tx . xid Version ( ) ) : STRING + cached + STRING + tx + STRING ; for ( Grid Cache Mvcc Candidate cand : cached . remote Mvcc Snapshot ( ) ) if ( min == null || cand . version ( ) . is Less ( min ) ) min = cand . version ( ) ; } return min ; }
private Grid Cache Version min Version ( Iterable < Ignite Tx Entry > entries , Grid Cache Version min , Ignite Internal Tx tx ) { for ( Ignite Tx Entry tx Entry : entries ) { Grid Cache Entry Ex cached = tx Entry . cached ( ) ; assert tx Entry . is Read ( ) || ! cached . obsolete ( tx . xid Version ( ) ) : STRING + cached + STRING + tx + STRING ; for ( Grid Cache Mvcc Candidate cand : cached . remote Mvcc Snapshot ( ) ) if ( min == null || cand . version ( ) . is Less ( min ) ) min = cand . version ( ) ; } return min ; }
private Grid Cache Version min Version ( Iterable < Ignite Tx Entry > entries , Grid Cache Version min , Ignite Internal Tx tx ) { for ( Ignite Tx Entry tx Entry : entries ) { Grid Cache Entry Ex cached = tx Entry . cached ( ) ; assert tx Entry . is Read ( ) || ! cached . obsolete ( tx . xid Version ( ) ) : STRING + cached + STRING + tx + STRING ; for ( Grid Cache Mvcc Candidate cand : cached . remote Mvcc Snapshot ( ) ) if ( min == null || cand . version ( ) . is Less ( min ) ) min = cand . version ( ) ; } return min ; }
private Grid Cache Version min Version ( Iterable < Ignite Tx Entry > entries , Grid Cache Version min , Ignite Internal Tx tx ) { for ( Ignite Tx Entry tx Entry : entries ) { Grid Cache Entry Ex cached = tx Entry . cached ( ) ; assert tx Entry . is Read ( ) || ! cached . obsolete ( tx . xid Version ( ) ) : STRING + cached + STRING + tx + STRING ; for ( Grid Cache Mvcc Candidate cand : cached . remote Mvcc Snapshot ( ) ) if ( min == null || cand . version ( ) . is Less ( min ) ) min = cand . version ( ) ; } return min ; }
private Grid Cache Version min Version ( Iterable < Ignite Tx Entry > entries , Grid Cache Version min , Ignite Internal Tx tx ) { for ( Ignite Tx Entry tx Entry : entries ) { Grid Cache Entry Ex cached = tx Entry . cached ( ) ; assert tx Entry . is Read ( ) || ! cached . obsolete ( tx . xid Version ( ) ) : STRING + cached + STRING + tx + STRING ; for ( Grid Cache Mvcc Candidate cand : cached . remote Mvcc Snapshot ( ) ) if ( min == null || cand . version ( ) . is Less ( min ) ) min = cand . version ( ) ; } return min ; }
private Grid Cache Version min Version ( Iterable < Ignite Tx Entry > entries , Grid Cache Version min , Ignite Internal Tx tx ) { for ( Ignite Tx Entry tx Entry : entries ) { Grid Cache Entry Ex cached = tx Entry . cached ( ) ; assert tx Entry . is Read ( ) || ! cached . obsolete ( tx . xid Version ( ) ) : STRING + cached + STRING + tx + STRING ; for ( Grid Cache Mvcc Candidate cand : cached . remote Mvcc Snapshot ( ) ) if ( min == null || cand . version ( ) . is Less ( min ) ) min = cand . version ( ) ; } return min ; }
public void add Certificate ( Burp Certificate burp Certificate ) { root Node . add ( new Default Mutable Tree Node ( burp Certificate ) ) ; }
public Ldap User Token ( Authentication auth , String default Authority ) { this ( auth , new Granted Authority Impl ( default Authority ) ) ; }
protected static String resolve Snapshot Name ( Snapshot snapshot ) { String persisted Name = resolve Name ( snapshot , null ) ; if ( persisted Name != null ) return persisted Name ; File file = snapshot . get File ( ) ; if ( file == null ) return snapshot . to String ( ) ; String file Name = file . get Name ( ) ; Snapshot Category category = snapshot . get Category ( ) ; String name = STRING + category . get Prefix ( ) + STRING + file Name ; if ( category . is Snapshot ( file ) ) { String time Stamp = category . get Time Stamp ( file Name ) ; if ( time Stamp != null ) name = STRING + category . get Prefix ( ) + STRING + time Stamp ; } return name ; }
private void init Handler ( Content Handler ch ) throws SAX Exception { if ( locator != null ) ch . set Document Locator ( locator ) ; ch . start Document ( ) ; for ( Prefix Mapping pm = prefix Mapping ; pm != null ; pm = pm . parent ) ch . start Prefix Mapping ( pm . prefix , pm . uri ) ; }
private void init Handler ( Content Handler ch ) throws SAX Exception { if ( locator != null ) ch . set Document Locator ( locator ) ; ch . start Document ( ) ; for ( Prefix Mapping pm = prefix Mapping ; pm != null ; pm = pm . parent ) ch . start Prefix Mapping ( pm . prefix , pm . uri ) ; }
private void init Handler ( Content Handler ch ) throws SAX Exception { if ( locator != null ) ch . set Document Locator ( locator ) ; ch . start Document ( ) ; for ( Prefix Mapping pm = prefix Mapping ; pm != null ; pm = pm . parent ) ch . start Prefix Mapping ( pm . prefix , pm . uri ) ; }
private void init Handler ( Content Handler ch ) throws SAX Exception { if ( locator != null ) ch . set Document Locator ( locator ) ; ch . start Document ( ) ; for ( Prefix Mapping pm = prefix Mapping ; pm != null ; pm = pm . parent ) ch . start Prefix Mapping ( pm . prefix , pm . uri ) ; }
private void init Handler ( Content Handler ch ) throws SAX Exception { if ( locator != null ) ch . set Document Locator ( locator ) ; ch . start Document ( ) ; for ( Prefix Mapping pm = prefix Mapping ; pm != null ; pm = pm . parent ) ch . start Prefix Mapping ( pm . prefix , pm . uri ) ; }
private void init Handler ( Content Handler ch ) throws SAX Exception { if ( locator != null ) ch . set Document Locator ( locator ) ; ch . start Document ( ) ; for ( Prefix Mapping pm = prefix Mapping ; pm != null ; pm = pm . parent ) ch . start Prefix Mapping ( pm . prefix , pm . uri ) ; }
private void init Handler ( Content Handler ch ) throws SAX Exception { if ( locator != null ) ch . set Document Locator ( locator ) ; ch . start Document ( ) ; for ( Prefix Mapping pm = prefix Mapping ; pm != null ; pm = pm . parent ) ch . start Prefix Mapping ( pm . prefix , pm . uri ) ; }
private void init Handler ( Content Handler ch ) throws SAX Exception { if ( locator != null ) ch . set Document Locator ( locator ) ; ch . start Document ( ) ; for ( Prefix Mapping pm = prefix Mapping ; pm != null ; pm = pm . parent ) ch . start Prefix Mapping ( pm . prefix , pm . uri ) ; }
private void init Handler ( Content Handler ch ) throws SAX Exception { if ( locator != null ) ch . set Document Locator ( locator ) ; ch . start Document ( ) ; for ( Prefix Mapping pm = prefix Mapping ; pm != null ; pm = pm . parent ) ch . start Prefix Mapping ( pm . prefix , pm . uri ) ; }
public void warning ( SAX Parse Exception exception ) throws SAX Exception { }
static public Big Decimal convert ( Properties ctx , int C UOM ID , int C UOM To ID , Big Decimal qty ) { if ( qty == null || qty . compare To ( Env . ZERO ) == NUM || C UOM ID == C UOM To ID ) return qty ; Big Decimal ret Value = get Rate ( ctx , C UOM ID , C UOM To ID ) ; if ( ret Value != null ) { MUOM uom = MUOM . get ( ctx , C UOM To ID ) ; if ( uom != null ) return uom . round ( ret Value . multiply ( qty ) , BOOL ) ; return ret Value . multiply ( qty ) ; } return null ; }
static public Big Decimal convert ( Properties ctx , int C UOM ID , int C UOM To ID , Big Decimal qty ) { if ( qty == null || qty . compare To ( Env . ZERO ) == NUM || C UOM ID == C UOM To ID ) return qty ; Big Decimal ret Value = get Rate ( ctx , C UOM ID , C UOM To ID ) ; if ( ret Value != null ) { MUOM uom = MUOM . get ( ctx , C UOM To ID ) ; if ( uom != null ) return uom . round ( ret Value . multiply ( qty ) , BOOL ) ; return ret Value . multiply ( qty ) ; } return null ; }
public boolean add Value ( Value v ) { return values . add ( v ) ; }
private static byte [ ] to Byte Array ( Input Stream input Stream ) throws IO Exception { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; byte buffer [ ] = new byte [ NUM ] ; while ( BOOL ) { int read = input Stream . read ( buffer ) ; if ( read == - NUM ) { break ; } baos . write ( buffer , NUM , read ) ; } return baos . to Byte Array ( ) ; }
public Infocard Invocation ( Open ID Token Type token Type ) { required Claims . add ( Open ID Token Type . OPENID CLAIM ) ; token Type = token Type ; if ( DEBUG ) log . debug ( STRING + token Type + STRING ) ; }
protected Mac ( Mac Spi mac Spi , Provider provider , String algorithm ) { this . spi = mac Spi ; this . provider = provider ; this . algorithm = algorithm ; service Iterator = null ; lock = null ; }
public static Input Stream to Input Stream ( Char Sequence input ) { return to Input Stream ( input . to String ( ) ) ; }
public static Input Stream to Input Stream ( Char Sequence input ) { return to Input Stream ( input . to String ( ) ) ; }
public void register ( Automation automation ) { Integer old Size = Integer . value Of ( automation Hash Table . size ( ) ) ; automation Hash Table . put ( automation . get Id ( ) , automation ) ; int id = Integer . parse Int ( automation . get Id ( ) ) ; if ( id > id ) { id = id ; } set Dirty And Fire Property Change ( LISTLENGTH CHANGED PROPERTY , old Size , Integer . value Of ( automation Hash Table . size ( ) ) ) ; }
public void register ( Automation automation ) { Integer old Size = Integer . value Of ( automation Hash Table . size ( ) ) ; automation Hash Table . put ( automation . get Id ( ) , automation ) ; int id = Integer . parse Int ( automation . get Id ( ) ) ; if ( id > id ) { id = id ; } set Dirty And Fire Property Change ( LISTLENGTH CHANGED PROPERTY , old Size , Integer . value Of ( automation Hash Table . size ( ) ) ) ; }
public void register ( Automation automation ) { Integer old Size = Integer . value Of ( automation Hash Table . size ( ) ) ; automation Hash Table . put ( automation . get Id ( ) , automation ) ; int id = Integer . parse Int ( automation . get Id ( ) ) ; if ( id > id ) { id = id ; } set Dirty And Fire Property Change ( LISTLENGTH CHANGED PROPERTY , old Size , Integer . value Of ( automation Hash Table . size ( ) ) ) ; }
private void update State View ( int it Count , Collection < Individual < Double > > gen ) { Platform . run Later ( null ) ; sim Pane Ctrl . wait After Step ( ) ; }
private void update State View ( int it Count , Collection < Individual < Double > > gen ) { Platform . run Later ( null ) ; sim Pane Ctrl . wait After Step ( ) ; }
public void install ( J Editor Pane c ) { c . add Caret Listener ( input Attribute Updater ) ; c . add Property Change Listener ( input Attribute Updater ) ; Caret caret = c . get Caret ( ) ; if ( caret != null ) { input Attribute Updater . update Input Attributes ( caret . get Dot ( ) , caret . get Mark ( ) , c ) ; } }
public Name join ( Name rhs ) { List < Name Piece > new Piece List = new Array List < > ( ) ; new Piece List . add All ( name Pieces ) ; new Piece List . add All ( rhs . name Pieces ) ; return new Name ( new Piece List ) ; }
public Name join ( Name rhs ) { List < Name Piece > new Piece List = new Array List < > ( ) ; new Piece List . add All ( name Pieces ) ; new Piece List . add All ( rhs . name Pieces ) ; return new Name ( new Piece List ) ; }
public Object remove ( Object key ) { process Queue ( ) ; return map . remove ( Key . create ( key , null ) ) ; }
protected static Property Descriptor [ ] introspect ( Class clazz ) { Bean Info bean Info ; try { bean Info = Introspector . get Bean Info ( clazz ) ; } catch ( Introspection Exception e ) { return ( new Property Descriptor [ NUM ] ) ; } return bean Info . get Property Descriptors ( ) ; }
protected static Property Descriptor [ ] introspect ( Class clazz ) { Bean Info bean Info ; try { bean Info = Introspector . get Bean Info ( clazz ) ; } catch ( Introspection Exception e ) { return ( new Property Descriptor [ NUM ] ) ; } return bean Info . get Property Descriptors ( ) ; }
protected static Property Descriptor [ ] introspect ( Class clazz ) { Bean Info bean Info ; try { bean Info = Introspector . get Bean Info ( clazz ) ; } catch ( Introspection Exception e ) { return ( new Property Descriptor [ NUM ] ) ; } return bean Info . get Property Descriptors ( ) ; }
public static long scale Large Timestamp ( long timestamp , long multiplier , long divisor ) { if ( divisor >= multiplier && ( divisor % multiplier ) == NUM ) { long division Factor = divisor / multiplier ; return timestamp / division Factor ; } else if ( divisor < multiplier && ( multiplier % divisor ) == NUM ) { long multiplication Factor = multiplier / divisor ; return timestamp * multiplication Factor ; } else { double multiplication Factor = ( double ) multiplier / divisor ; return ( long ) ( timestamp * multiplication Factor ) ; } }
public static long scale Large Timestamp ( long timestamp , long multiplier , long divisor ) { if ( divisor >= multiplier && ( divisor % multiplier ) == NUM ) { long division Factor = divisor / multiplier ; return timestamp / division Factor ; } else if ( divisor < multiplier && ( multiplier % divisor ) == NUM ) { long multiplication Factor = multiplier / divisor ; return timestamp * multiplication Factor ; } else { double multiplication Factor = ( double ) multiplier / divisor ; return ( long ) ( timestamp * multiplication Factor ) ; } }
public void add Metadata Entry ( String value ) { metadata . add ( value . replace All ( STRING , STRING ) ) ; }
public void on Ready ( Runnable runnable ) { runnable . run ( ) ; }
public void on Ready ( Runnable runnable ) { runnable . run ( ) ; }
public void on Ready ( Runnable runnable ) { runnable . run ( ) ; }
public static < I , M , E extends Exception > Set < M > transform Set ( final Collection < I > values , final Function < I , M , E > mapper ) throws E { Reject . if Null ( values , mapper ) ; final Set < M > new Set = new Hash Set < M > ( values . size ( ) ) ; for ( I value : values ) { new Set . add ( mapper . apply ( value ) ) ; } return new Set ; }
public static List < Entry > load Entries From File ( String path ) { File sdcard = Environment . get External Storage Directory ( ) ; File file = new File ( sdcard , path ) ; List < Entry > entries = new Array List < Entry > ( ) ; try { @ Suppress Warnings ( STRING ) Buffered Reader br = new Buffered Reader ( new File Reader ( file ) ) ; String line ; while ( ( line = br . read Line ( ) ) != null ) { String [ ] split = line . split ( STRING ) ; if ( split . length <= NUM ) { entries . add ( new Entry ( Float . parse Float ( split [ NUM ] ) , Integer . parse Int ( split [ NUM ] ) ) ) ; } else { float [ ] vals = new float [ split . length - NUM ] ; for ( int i = NUM ; i < vals . length ; i ++ ) { vals [ i ] = Float . parse Float ( split [ i ] ) ; } entries . add ( new Bar Entry ( Integer . parse Int ( split [ split . length - NUM ] ) , vals ) ) ; } } } catch ( IO Exception e ) { Log . e ( LOG , e . to String ( ) ) ; } return entries ; }
public static String escape Quoted Switch ( String value ) { return value . replace All ( STRING , STRING ) ; }
public static String escape Quoted Switch ( String value ) { return value . replace All ( STRING , STRING ) ; }
public static String escape Quoted Switch ( String value ) { return value . replace All ( STRING , STRING ) ; }
public Query Failed Exception ( Connection connection , DN dn , Filter filter , Throwable cause ) { super ( Message Format . format ( STRING + STRING + STRING + STRING , dn , connection , filter ) , cause ) ; }
public Rectangle ( Double x , Double y , Double width , Double height ) { this ( ( int ) Math . round ( x ) , ( int ) Math . round ( y ) , ( int ) Math . round ( width ) , ( int ) Math . round ( height ) ) ; }
public Rectangle ( Double x , Double y , Double width , Double height ) { this ( ( int ) Math . round ( x ) , ( int ) Math . round ( y ) , ( int ) Math . round ( width ) , ( int ) Math . round ( height ) ) ; }
public Rectangle ( Double x , Double y , Double width , Double height ) { this ( ( int ) Math . round ( x ) , ( int ) Math . round ( y ) , ( int ) Math . round ( width ) , ( int ) Math . round ( height ) ) ; }
public static Connection Factory new Failover Connection Pool ( Set < LDAPURL > servers , String username , char [ ] password , int max Size , int heart Beat Interval , String heart Beat Time Unit , Options ldap Options ) { List < Connection Factory > factories = new Array List < Connection Factory > ( servers . size ( ) ) ; for ( LDAPURL ldapurl : servers ) { Connection Factory cf = Connections . new Fixed Connection Pool ( new Connection Factory ( ldapurl , username , password , heart Beat Interval , heart Beat Time Unit , ldap Options ) , max Size ) ; factories . add ( cf ) ; } return load Balance Factories ( factories ) ; }
public static String time Until ( final int seconds , final boolean force Seconds ) { final String Builder sbuf = new String Builder ( ) ; time Until ( sbuf , seconds , force Seconds ) ; return sbuf . to String ( ) ; }
public static String time Until ( final int seconds , final boolean force Seconds ) { final String Builder sbuf = new String Builder ( ) ; time Until ( sbuf , seconds , force Seconds ) ; return sbuf . to String ( ) ; }
public static String time Until ( final int seconds , final boolean force Seconds ) { final String Builder sbuf = new String Builder ( ) ; time Until ( sbuf , seconds , force Seconds ) ; return sbuf . to String ( ) ; }
private List < Resource > find Imported Resources ( final String resource Uri , final String css Content ) throws IO Exception { final List < Resource > imports = new Array List < Resource > ( ) ; final String css = css Content ; final List < String > found Imports = find Imports ( css ) ; for ( final String import Url : found Imports ) { final Resource imported Resource = create Imported Resource ( resource Uri , import Url ) ; if ( imports . contains ( imported Resource ) ) { LOG . debug ( STRING , imported Resource ) ; } else { imports . add ( imported Resource ) ; on Import Detected ( imported Resource . get Uri ( ) ) ; } } return imports ; }
private List < Resource > find Imported Resources ( final String resource Uri , final String css Content ) throws IO Exception { final List < Resource > imports = new Array List < Resource > ( ) ; final String css = css Content ; final List < String > found Imports = find Imports ( css ) ; for ( final String import Url : found Imports ) { final Resource imported Resource = create Imported Resource ( resource Uri , import Url ) ; if ( imports . contains ( imported Resource ) ) { LOG . debug ( STRING , imported Resource ) ; } else { imports . add ( imported Resource ) ; on Import Detected ( imported Resource . get Uri ( ) ) ; } } return imports ; }
public long time ( ) { return System . current Time Millis ( ) ; }
int bounded Index Of ( String string , char search , int start , int end ) { int ret Value = string . index Of ( search , start ) ; if ( ret Value >= end ) { return - NUM ; } return ret Value ; }
int bounded Index Of ( String string , char search , int start , int end ) { int ret Value = string . index Of ( search , start ) ; if ( ret Value >= end ) { return - NUM ; } return ret Value ; }
int bounded Index Of ( String string , char search , int start , int end ) { int ret Value = string . index Of ( search , start ) ; if ( ret Value >= end ) { return - NUM ; } return ret Value ; }
public byte [ ] calculate HMAC SHA 256 ( byte [ ] input , byte [ ] key , int length ) { byte [ ] output = null ; try { hmac SHA 256 . init ( new Secret Key Spec ( key , NUM , length , STRING ) ) ; output = hmac SHA 256 . do Final ( input ) ; } catch ( Invalid Key Exception e ) { log . error ( STRING , e ) ; } return output ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public void test Constructor Ljava lang String Ljava text Decimal Format Symbols ( ) { try { Decimal Format Symbols dfs = new Decimal Format Symbols ( Locale . CANADA ) ; Decimal Format format 1 = new Decimal Format ( STRING , dfs ) ; Decimal Format format 2 = new Decimal Format ( ) ; format 2 . apply Pattern ( STRING ) ; format 2 . set Decimal Format Symbols ( dfs ) ; assert True ( STRING , format 2 . equals ( format 1 ) ) ; assert True ( STRING , ! format 1 . equals ( new Decimal Format ( STRING , new Decimal Format Symbols ( Locale . CHINA ) ) ) ) ; try { new Decimal Format ( STRING , ( Decimal Format Symbols ) null ) ; fail ( STRING ) ; } catch ( Null Pointer Exception e ) { } try { new Decimal Format ( null , new Decimal Format Symbols ( ) ) ; fail ( STRING ) ; } catch ( Null Pointer Exception e ) { } try { new Decimal Format ( null , ( Decimal Format Symbols ) null ) ; fail ( STRING ) ; } catch ( Null Pointer Exception e ) { } try { new Decimal Format ( STRING , new Decimal Format Symbols ( ) ) ; fail ( STRING ) ; } catch ( Illegal Argument Exception e ) { } } catch ( Exception e ) { fail ( STRING + e . to String ( ) ) ; } }
public final < V extends Enum < V > & Pagination Filter Property > boolean test ( T object , Class < V > enum Type ) { if ( String Utils . is Blank ( filter ) ) { return BOOL ; } else if ( filter . contains ( SEPARATOR ) ) { if ( String Utils . contains None ( String Utils . substring Before ( filter , SEPARATOR ) , DELIMITER ) ) { return test Fields ( object , enum Type ) ; } return test Fields ( object , enum Type ) && test Fulltext ( object , enum Type ) ; } return test Fulltext ( object , enum Type ) ; }
public void add ( double value ) { if ( Double . is Na N ( value ) ) { return ; } int index = find Insert Index ( value ) ; if ( index == - NUM ) { values . add ( value ) ; } else { values . add ( index , value ) ; } }
public static long parse Long ( java . lang . String s ) throws java . lang . Number Format Exception { return parse Long ( s , NUM ) ; }
public static long parse Long ( java . lang . String s ) throws java . lang . Number Format Exception { return parse Long ( s , NUM ) ; }
public static long parse Long ( java . lang . String s ) throws java . lang . Number Format Exception { return parse Long ( s , NUM ) ; }
public static void register Default Resolvers ( ) { synchronized ( resolver List ) { resolver List . add ( new Resource Resolver ( new Resolver Fragment ( ) ) ) ; resolver List . add ( new Resource Resolver ( new Resolver Local Filesystem ( ) ) ) ; resolver List . add ( new Resource Resolver ( new Resolver X Pointer ( ) ) ) ; resolver List . add ( new Resource Resolver ( new Resolver Direct HTTP ( ) ) ) ; } }
protected static Long convert Timepoint To Bucketing Long ( Date timepoint To Be Converted ) { if ( timepoint To Be Converted == null ) { return null ; } Long to Return = timepoint To Be Converted . get Time ( ) - Primary Index Bucket Generator Impl . TIMEPOINT MIN ; if ( to Return < NUM ) { return NUM ; } else if ( to Return > Primary Index Bucket Generator Impl . TIMEPOINT MAX ) { return Primary Index Bucket Generator Impl . TIMEPOINT MAX ; } else { return to Return ; } }
protected static Long convert Timepoint To Bucketing Long ( Date timepoint To Be Converted ) { if ( timepoint To Be Converted == null ) { return null ; } Long to Return = timepoint To Be Converted . get Time ( ) - Primary Index Bucket Generator Impl . TIMEPOINT MIN ; if ( to Return < NUM ) { return NUM ; } else if ( to Return > Primary Index Bucket Generator Impl . TIMEPOINT MAX ) { return Primary Index Bucket Generator Impl . TIMEPOINT MAX ; } else { return to Return ; } }
protected static Long convert Timepoint To Bucketing Long ( Date timepoint To Be Converted ) { if ( timepoint To Be Converted == null ) { return null ; } Long to Return = timepoint To Be Converted . get Time ( ) - Primary Index Bucket Generator Impl . TIMEPOINT MIN ; if ( to Return < NUM ) { return NUM ; } else if ( to Return > Primary Index Bucket Generator Impl . TIMEPOINT MAX ) { return Primary Index Bucket Generator Impl . TIMEPOINT MAX ; } else { return to Return ; } }
protected static Long convert Timepoint To Bucketing Long ( Date timepoint To Be Converted ) { if ( timepoint To Be Converted == null ) { return null ; } Long to Return = timepoint To Be Converted . get Time ( ) - Primary Index Bucket Generator Impl . TIMEPOINT MIN ; if ( to Return < NUM ) { return NUM ; } else if ( to Return > Primary Index Bucket Generator Impl . TIMEPOINT MAX ) { return Primary Index Bucket Generator Impl . TIMEPOINT MAX ; } else { return to Return ; } }
@ Override public String run ( String [ ] args ) { if ( args . length == NUM ) { String help = STRING ; help += STRING ; help += STRING ; help += STRING ; help += STRING ; help += STRING ; return help ; } try { if ( args . length > NUM ) { String cmd = args [ NUM ] ; if ( cmd == STRING ) { if ( args . length > NUM ) { int id = Integer . parse Int ( args [ NUM ] ) ; return str List Network ( id , BOOL ) ; } else { return str List Networks ( BOOL ) ; } } else if ( cmd == STRING ) { if ( args . length > NUM ) { int id 1 = Integer . parse Int ( args [ NUM ] ) ; int id 2 = Integer . parse Int ( args [ NUM ] ) ; int id 3 = Integer . parse Int ( args [ NUM ] ) ; return str Link 3 ( id 1 , id 2 , id 3 ) ; } else if ( args . length > NUM ) { int id 1 = Integer . parse Int ( args [ NUM ] ) ; int id 2 = Integer . parse Int ( args [ NUM ] ) ; return str Link 2 ( id 1 , id 2 ) ; } } else if ( cmd == STRING ) { if ( args . length > NUM ) { int id = Integer . parse Int ( args [ NUM ] ) ; return str Unlink ID ( id ) ; } else { return str Unlink All ( ) ; } } return STRING ; } } catch ( Number Format Exception nfe ) { } catch ( Null Pointer Exception npe ) { } catch ( Index Out Of Bounds Exception ioobe ) { } return STRING ; }
@ Override public String run ( String [ ] args ) { if ( args . length == NUM ) { String help = STRING ; help += STRING ; help += STRING ; help += STRING ; help += STRING ; help += STRING ; return help ; } try { if ( args . length > NUM ) { String cmd = args [ NUM ] ; if ( cmd == STRING ) { if ( args . length > NUM ) { int id = Integer . parse Int ( args [ NUM ] ) ; return str List Network ( id , BOOL ) ; } else { return str List Networks ( BOOL ) ; } } else if ( cmd == STRING ) { if ( args . length > NUM ) { int id 1 = Integer . parse Int ( args [ NUM ] ) ; int id 2 = Integer . parse Int ( args [ NUM ] ) ; int id 3 = Integer . parse Int ( args [ NUM ] ) ; return str Link 3 ( id 1 , id 2 , id 3 ) ; } else if ( args . length > NUM ) { int id 1 = Integer . parse Int ( args [ NUM ] ) ; int id 2 = Integer . parse Int ( args [ NUM ] ) ; return str Link 2 ( id 1 , id 2 ) ; } } else if ( cmd == STRING ) { if ( args . length > NUM ) { int id = Integer . parse Int ( args [ NUM ] ) ; return str Unlink ID ( id ) ; } else { return str Unlink All ( ) ; } } return STRING ; } } catch ( Number Format Exception nfe ) { } catch ( Null Pointer Exception npe ) { } catch ( Index Out Of Bounds Exception ioobe ) { } return STRING ; }
public long read U Bits ( int num Bits ) throws IO Exception { if ( num Bits == NUM ) { return NUM ; } int bits Left = num Bits ; long result = NUM ; if ( bit Pos == NUM ) { bit Buf = in . read ( ) ; bit Pos = NUM ; bytes Read ++ ; } while ( BOOL ) { int shift = bits Left - bit Pos ; if ( shift > NUM ) { result |= bit Buf << shift ; bits Left -= bit Pos ; bit Buf = in . read ( ) ; bit Pos = NUM ; bytes Read ++ ; } else { result |= bit Buf > > - shift ; bit Pos -= bits Left ; bit Buf &= NUM > > ( NUM - bit Pos ) ; return result ; } } }
void send Message To Handler With Controller Reset ( List < OF Message > messages ) throws Exception { verify ( controller ) ; reset ( controller ) ; send Message To Handler No Controller Reset ( messages ) ; }
void send Message To Handler With Controller Reset ( List < OF Message > messages ) throws Exception { verify ( controller ) ; reset ( controller ) ; send Message To Handler No Controller Reset ( messages ) ; }
void send Message To Handler With Controller Reset ( List < OF Message > messages ) throws Exception { verify ( controller ) ; reset ( controller ) ; send Message To Handler No Controller Reset ( messages ) ; }
void send Message To Handler With Controller Reset ( List < OF Message > messages ) throws Exception { verify ( controller ) ; reset ( controller ) ; send Message To Handler No Controller Reset ( messages ) ; }
public void read Moments ( Input Stream mission Stream ) throws Mission Parse Exception { Mission Parser . parse Mission ( mission Stream , this ) ; }
public void read Moments ( Input Stream mission Stream ) throws Mission Parse Exception { Mission Parser . parse Mission ( mission Stream , this ) ; }
public void read Moments ( Input Stream mission Stream ) throws Mission Parse Exception { Mission Parser . parse Mission ( mission Stream , this ) ; }
private void ensure Tuple Array ( int row ) { int nrows = Math . max ( m table . get Row Count ( ) , row + NUM ) ; if ( m tuples == null ) { m tuples = new Table Tuple [ nrows ] ; } else if ( m tuples . length < nrows ) { int capacity = Math . max ( ( NUM * m tuples . length ) / NUM + NUM , nrows ) ; Table Tuple [ ] tuples = new Table Tuple [ capacity ] ; System . arraycopy ( m tuples , NUM , tuples , NUM , m tuples . length ) ; m tuples = tuples ; } }
private void load Binary ( Data Input Stream dis ) throws IO Exception { int size ; if ( dis . read Int ( ) != MAGIC ) { throw new Error ( STRING ) ; } if ( dis . read Int ( ) != VERSION ) { throw new Error ( STRING ) ; } sample Rate = dis . read Int ( ) ; num Channels = dis . read Int ( ) ; lpc Min = dis . read Float ( ) ; lpc Range = dis . read Float ( ) ; size = dis . read Int ( ) ; for ( int i = NUM ; i < size ; i ++ ) { Diphone diphone = Diphone . load Binary ( dis ) ; add ( diphone ) ; } }
public static Optional < Object [ ] > remove ( final String key To Remove , final Object ... key Values ) { return Element Helper . remove ( ( Object ) key To Remove , key Values ) ; }
public static Optional < Object [ ] > remove ( final String key To Remove , final Object ... key Values ) { return Element Helper . remove ( ( Object ) key To Remove , key Values ) ; }
public static Optional < Object [ ] > remove ( final String key To Remove , final Object ... key Values ) { return Element Helper . remove ( ( Object ) key To Remove , key Values ) ; }
public static Optional < Object [ ] > remove ( final String key To Remove , final Object ... key Values ) { return Element Helper . remove ( ( Object ) key To Remove , key Values ) ; }
public static Optional < Object [ ] > remove ( final String key To Remove , final Object ... key Values ) { return Element Helper . remove ( ( Object ) key To Remove , key Values ) ; }
public static Optional < Object [ ] > remove ( final String key To Remove , final Object ... key Values ) { return Element Helper . remove ( ( Object ) key To Remove , key Values ) ; }
public static Optional < Object [ ] > remove ( final String key To Remove , final Object ... key Values ) { return Element Helper . remove ( ( Object ) key To Remove , key Values ) ; }
public void polar ( double magnitude , double direction , double rotation ) { magnitude = speed Limiter . apply As Double ( magnitude ) * SQRT OF TWO ; double dir In Rad = ( direction + NUM ) * Math . PI / NUM ; double cos D = Math . cos ( dir In Rad ) ; double sin D = Math . sin ( dir In Rad ) ; double wheel Speeds [ ] = new double [ NUMBER OF MOTORS ] ; wheel Speeds [ LEFT FRONT ] = ( sin D * magnitude + rotation ) ; wheel Speeds [ RIGHT FRONT ] = ( cos D * magnitude - rotation ) ; wheel Speeds [ LEFT REAR ] = ( cos D * magnitude + rotation ) ; wheel Speeds [ RIGHT REAR ] = ( sin D * magnitude - rotation ) ; normalize ( wheel Speeds ) ; scale ( wheel Speeds , OUTPUT SCALE FACTOR ) ; left Front . set Speed ( wheel Speeds [ LEFT FRONT ] ) ; left Rear . set Speed ( wheel Speeds [ LEFT REAR ] ) ; right Front . set Speed ( wheel Speeds [ RIGHT FRONT ] ) ; right Rear . set Speed ( wheel Speeds [ RIGHT REAR ] ) ; }
public void polar ( double magnitude , double direction , double rotation ) { magnitude = speed Limiter . apply As Double ( magnitude ) * SQRT OF TWO ; double dir In Rad = ( direction + NUM ) * Math . PI / NUM ; double cos D = Math . cos ( dir In Rad ) ; double sin D = Math . sin ( dir In Rad ) ; double wheel Speeds [ ] = new double [ NUMBER OF MOTORS ] ; wheel Speeds [ LEFT FRONT ] = ( sin D * magnitude + rotation ) ; wheel Speeds [ RIGHT FRONT ] = ( cos D * magnitude - rotation ) ; wheel Speeds [ LEFT REAR ] = ( cos D * magnitude + rotation ) ; wheel Speeds [ RIGHT REAR ] = ( sin D * magnitude - rotation ) ; normalize ( wheel Speeds ) ; scale ( wheel Speeds , OUTPUT SCALE FACTOR ) ; left Front . set Speed ( wheel Speeds [ LEFT FRONT ] ) ; left Rear . set Speed ( wheel Speeds [ LEFT REAR ] ) ; right Front . set Speed ( wheel Speeds [ RIGHT FRONT ] ) ; right Rear . set Speed ( wheel Speeds [ RIGHT REAR ] ) ; }
public void polar ( double magnitude , double direction , double rotation ) { magnitude = speed Limiter . apply As Double ( magnitude ) * SQRT OF TWO ; double dir In Rad = ( direction + NUM ) * Math . PI / NUM ; double cos D = Math . cos ( dir In Rad ) ; double sin D = Math . sin ( dir In Rad ) ; double wheel Speeds [ ] = new double [ NUMBER OF MOTORS ] ; wheel Speeds [ LEFT FRONT ] = ( sin D * magnitude + rotation ) ; wheel Speeds [ RIGHT FRONT ] = ( cos D * magnitude - rotation ) ; wheel Speeds [ LEFT REAR ] = ( cos D * magnitude + rotation ) ; wheel Speeds [ RIGHT REAR ] = ( sin D * magnitude - rotation ) ; normalize ( wheel Speeds ) ; scale ( wheel Speeds , OUTPUT SCALE FACTOR ) ; left Front . set Speed ( wheel Speeds [ LEFT FRONT ] ) ; left Rear . set Speed ( wheel Speeds [ LEFT REAR ] ) ; right Front . set Speed ( wheel Speeds [ RIGHT FRONT ] ) ; right Rear . set Speed ( wheel Speeds [ RIGHT REAR ] ) ; }
public void polar ( double magnitude , double direction , double rotation ) { magnitude = speed Limiter . apply As Double ( magnitude ) * SQRT OF TWO ; double dir In Rad = ( direction + NUM ) * Math . PI / NUM ; double cos D = Math . cos ( dir In Rad ) ; double sin D = Math . sin ( dir In Rad ) ; double wheel Speeds [ ] = new double [ NUMBER OF MOTORS ] ; wheel Speeds [ LEFT FRONT ] = ( sin D * magnitude + rotation ) ; wheel Speeds [ RIGHT FRONT ] = ( cos D * magnitude - rotation ) ; wheel Speeds [ LEFT REAR ] = ( cos D * magnitude + rotation ) ; wheel Speeds [ RIGHT REAR ] = ( sin D * magnitude - rotation ) ; normalize ( wheel Speeds ) ; scale ( wheel Speeds , OUTPUT SCALE FACTOR ) ; left Front . set Speed ( wheel Speeds [ LEFT FRONT ] ) ; left Rear . set Speed ( wheel Speeds [ LEFT REAR ] ) ; right Front . set Speed ( wheel Speeds [ RIGHT FRONT ] ) ; right Rear . set Speed ( wheel Speeds [ RIGHT REAR ] ) ; }
public void add Connection ( Connection connection ) { if ( connection == null ) throw new Illegal Argument Exception ( STRING ) ; synchronized ( connections Lock ) { Connection [ ] new Connections = new Connection [ connections . length + NUM ] ; new Connections [ NUM ] = connection ; System . arraycopy ( connections , NUM , new Connections , NUM , connections . length ) ; connections = new Connections ; } connection . add Listener ( invoke Listener ) ; if ( TRACE ) trace ( STRING , STRING + connection ) ; }
public synchronized void wait For Submitted Tasks ( ) throws Interrupted Exception { while ( current Task Count . get ( ) > NUM ) { wait For Single Task ( ) ; } }
public synchronized void wait For Submitted Tasks ( ) throws Interrupted Exception { while ( current Task Count . get ( ) > NUM ) { wait For Single Task ( ) ; } }
@ Suppress Warnings ( STRING ) void remove Box ( Value Box vb ) { if ( vb == null ) return ; if ( boxes == vb ) { boxes = null ; } else if ( boxes instanceof List ) { List < Value Box > list = ( List < Value Box > ) boxes ; list . remove ( vb ) ; } }
public void reset ( ) { Metamodel . reset Module Manager ( ) ; }
public void reset ( ) { Metamodel . reset Module Manager ( ) ; }
public void reset ( ) { Metamodel . reset Module Manager ( ) ; }
public Shape screen To Chart Shape ( Shape s ) { General Path p = new General Path ( ) ; Transform t = Transform . make Identity ( ) ; if ( current Transform != null ) { t . concatenate ( current Transform . get Inverse ( ) ) ; } t . translate ( - get Absolute X ( ) , - get Absolute Y ( ) ) ; p . append ( s . get Path Iterator ( t ) , BOOL ) ; return p ; }
public Shape screen To Chart Shape ( Shape s ) { General Path p = new General Path ( ) ; Transform t = Transform . make Identity ( ) ; if ( current Transform != null ) { t . concatenate ( current Transform . get Inverse ( ) ) ; } t . translate ( - get Absolute X ( ) , - get Absolute Y ( ) ) ; p . append ( s . get Path Iterator ( t ) , BOOL ) ; return p ; }
public void write ( Image c , Component i ) { if ( page == null ) { newpage ( ) ; } int x = x0 + width - ( c . get Width ( null ) * NUM / NUM + charwidth ) ; int y = y0 + ( linenum * lineheight ) + lineascent ; if ( page != null && pagenum >= pr First ) { page . draw Image ( c , x , y , c . get Width ( null ) * NUM / NUM , c . get Height ( null ) * NUM / NUM , null ) ; } }
public void test Division Knuth One Digit By One Digit ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , - NUM } ; byte b Bytes [ ] = { NUM , - NUM , - NUM , - NUM } ; int a Sign = NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . divide ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }
public void test Division Knuth One Digit By One Digit ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , - NUM } ; byte b Bytes [ ] = { NUM , - NUM , - NUM , - NUM } ; int a Sign = NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . divide ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }
private static void throw Bounds ( ) { throw new Index Out Of Bounds Exception ( STRING ) ; }
private static void throw Bounds ( ) { throw new Index Out Of Bounds Exception ( STRING ) ; }
private static void create And Show GUI ( ) { J Frame frame = new J Frame ( STRING ) ; frame . set Default Close Operation ( J Frame . EXIT ON CLOSE ) ; frame . add ( new Tool Bar Demo 2 ( ) ) ; frame . pack ( ) ; frame . set Visible ( BOOL ) ; }
private static void create And Show GUI ( ) { J Frame frame = new J Frame ( STRING ) ; frame . set Default Close Operation ( J Frame . EXIT ON CLOSE ) ; frame . add ( new Tool Bar Demo 2 ( ) ) ; frame . pack ( ) ; frame . set Visible ( BOOL ) ; }
static void write UTF ( Output Stream out , String str ) throws IO Exception { for ( int i = NUM , len = str . length ( ) ; i < len ; i ++ ) { int c = str . char At ( i ) ; if ( ( c >= NUM ) && ( c <= NUM ) ) { out . write ( c ) ; } else { if ( c > NUM ) { out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; } else { out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; } } } }
Date Time Formatter to Formatter ( Resolver Style resolver Style , Chronology chrono ) { return to Formatter ( Locale . get Default ( Locale . Category . FORMAT ) , resolver Style , chrono ) ; }
Date Time Formatter to Formatter ( Resolver Style resolver Style , Chronology chrono ) { return to Formatter ( Locale . get Default ( Locale . Category . FORMAT ) , resolver Style , chrono ) ; }
Date Time Formatter to Formatter ( Resolver Style resolver Style , Chronology chrono ) { return to Formatter ( Locale . get Default ( Locale . Category . FORMAT ) , resolver Style , chrono ) ; }
public Integer to Integer ( ) { return Integer . value Of ( int Value ( ) ) ; }
public boolean equals ( Object o ) { return map . equals ( o ) ; }
protected void populate Client ( String client Name , Properties props ) throws Invalid Properties Format Exception { String name = props . get Property ( client Name + NAME SUFFIX ) ; String attr List = props . get Property ( client Name + ATTRIBUTE SUFFIX ) ; String Tokenizer st = new String Tokenizer ( attr List , COMMA ) ; Map attributes = new Hash Map ( ) ; Set attribute Values = null ; while ( st . has More Tokens ( ) ) { attribute Values = new Hash Set ( ) ; String entry = st . next Token ( ) ; String attr Name = entry . substring ( NUM , entry . index Of ( EQUALS ) ) ; String attr Value = entry . substring ( entry . index Of ( EQUALS ) + NUM ) ; attribute Values . add ( attr Value ) ; attributes . put ( attr Name , attribute Values ) ; } clients . put ( name , new Client ( name , attributes ) ) ; clients Data . put ( name , attributes ) ; }
public void reset ( ) throws Security Exception { check Permission ( ) ; synchronized ( this ) { props = new Properties ( ) ; initialized Global Handlers = BOOL ; } for ( Logger Context cx : contexts ( ) ) { Enumeration < String > enum = cx . get Logger Names ( ) ; while ( enum . has More Elements ( ) ) { String name = enum . next Element ( ) ; Logger logger = cx . find Logger ( name ) ; if ( logger != null ) { reset Logger ( logger ) ; } } } }
public void reset ( ) throws Security Exception { check Permission ( ) ; synchronized ( this ) { props = new Properties ( ) ; initialized Global Handlers = BOOL ; } for ( Logger Context cx : contexts ( ) ) { Enumeration < String > enum = cx . get Logger Names ( ) ; while ( enum . has More Elements ( ) ) { String name = enum . next Element ( ) ; Logger logger = cx . find Logger ( name ) ; if ( logger != null ) { reset Logger ( logger ) ; } } } }
public void reset ( ) throws Security Exception { check Permission ( ) ; synchronized ( this ) { props = new Properties ( ) ; initialized Global Handlers = BOOL ; } for ( Logger Context cx : contexts ( ) ) { Enumeration < String > enum = cx . get Logger Names ( ) ; while ( enum . has More Elements ( ) ) { String name = enum . next Element ( ) ; Logger logger = cx . find Logger ( name ) ; if ( logger != null ) { reset Logger ( logger ) ; } } } }
public void reset ( ) throws Security Exception { check Permission ( ) ; synchronized ( this ) { props = new Properties ( ) ; initialized Global Handlers = BOOL ; } for ( Logger Context cx : contexts ( ) ) { Enumeration < String > enum = cx . get Logger Names ( ) ; while ( enum . has More Elements ( ) ) { String name = enum . next Element ( ) ; Logger logger = cx . find Logger ( name ) ; if ( logger != null ) { reset Logger ( logger ) ; } } } }
public void on Drawer Closed ( View view ) { super . on Drawer Closed ( view ) ; update Action Bar Title And Home Button ( null ) ; invalidate Options Menu ( ) ; }
public void on Drawer Closed ( View view ) { super . on Drawer Closed ( view ) ; update Action Bar Title And Home Button ( null ) ; invalidate Options Menu ( ) ; }
public void on Drawer Closed ( View view ) { super . on Drawer Closed ( view ) ; update Action Bar Title And Home Button ( null ) ; invalidate Options Menu ( ) ; }
public static Event Bean [ ] flatten ( Array Deque < Event Bean [ ] > event Vector ) { if ( event Vector . is Empty ( ) ) { return null ; } if ( event Vector . size ( ) == NUM ) { return event Vector . get First ( ) ; } int total Elements = NUM ; for ( Event Bean [ ] arr : event Vector ) { if ( arr != null ) { total Elements += arr . length ; } } if ( total Elements == NUM ) { return null ; } Event Bean [ ] result = new Event Bean [ total Elements ] ; int dest Pos = NUM ; for ( Event Bean [ ] arr : event Vector ) { if ( arr != null ) { System . arraycopy ( arr , NUM , result , dest Pos , arr . length ) ; dest Pos += arr . length ; } } return result ; }
public static Event Bean [ ] flatten ( Array Deque < Event Bean [ ] > event Vector ) { if ( event Vector . is Empty ( ) ) { return null ; } if ( event Vector . size ( ) == NUM ) { return event Vector . get First ( ) ; } int total Elements = NUM ; for ( Event Bean [ ] arr : event Vector ) { if ( arr != null ) { total Elements += arr . length ; } } if ( total Elements == NUM ) { return null ; } Event Bean [ ] result = new Event Bean [ total Elements ] ; int dest Pos = NUM ; for ( Event Bean [ ] arr : event Vector ) { if ( arr != null ) { System . arraycopy ( arr , NUM , result , dest Pos , arr . length ) ; dest Pos += arr . length ; } } return result ; }
public static Event Bean [ ] flatten ( Array Deque < Event Bean [ ] > event Vector ) { if ( event Vector . is Empty ( ) ) { return null ; } if ( event Vector . size ( ) == NUM ) { return event Vector . get First ( ) ; } int total Elements = NUM ; for ( Event Bean [ ] arr : event Vector ) { if ( arr != null ) { total Elements += arr . length ; } } if ( total Elements == NUM ) { return null ; } Event Bean [ ] result = new Event Bean [ total Elements ] ; int dest Pos = NUM ; for ( Event Bean [ ] arr : event Vector ) { if ( arr != null ) { System . arraycopy ( arr , NUM , result , dest Pos , arr . length ) ; dest Pos += arr . length ; } } return result ; }
public static Event Bean [ ] flatten ( Array Deque < Event Bean [ ] > event Vector ) { if ( event Vector . is Empty ( ) ) { return null ; } if ( event Vector . size ( ) == NUM ) { return event Vector . get First ( ) ; } int total Elements = NUM ; for ( Event Bean [ ] arr : event Vector ) { if ( arr != null ) { total Elements += arr . length ; } } if ( total Elements == NUM ) { return null ; } Event Bean [ ] result = new Event Bean [ total Elements ] ; int dest Pos = NUM ; for ( Event Bean [ ] arr : event Vector ) { if ( arr != null ) { System . arraycopy ( arr , NUM , result , dest Pos , arr . length ) ; dest Pos += arr . length ; } } return result ; }
public void insert ( Event Bean the Event ) { events . add ( the Event ) ; Event Bean [ ] old Events = null ; if ( events . size ( ) > depth ) { old Events = new Event Bean [ ] { events . remove ( NUM ) } ; } for ( View child : child Views ) { child . update ( new Event Bean [ ] { the Event } , old Events ) ; } }
protected void draw Axis Line ( Graphics 2 D g2 , double cursor , Rectangle 2 D data Area , Rectangle Edge edge ) { Line 2 D axis Line = null ; double x = data Area . get X ( ) ; double y = data Area . get Y ( ) ; if ( edge == Rectangle Edge . TOP ) { axis Line = new Line 2 D . Double ( x , cursor , data Area . get Max X ( ) , cursor ) ; } else if ( edge == Rectangle Edge . BOTTOM ) { axis Line = new Line 2 D . Double ( x , cursor , data Area . get Max X ( ) , cursor ) ; } else if ( edge == Rectangle Edge . LEFT ) { axis Line = new Line 2 D . Double ( cursor , y , cursor , data Area . get Max Y ( ) ) ; } else if ( edge == Rectangle Edge . RIGHT ) { axis Line = new Line 2 D . Double ( cursor , y , cursor , data Area . get Max Y ( ) ) ; } g2 . set Paint ( this . axis Line Paint ) ; g2 . set Stroke ( this . axis Line Stroke ) ; Object saved = g2 . get Rendering Hint ( Rendering Hints . KEY STROKE CONTROL ) ; g2 . set Rendering Hint ( Rendering Hints . KEY STROKE CONTROL , Rendering Hints . VALUE STROKE NORMALIZE ) ; g2 . draw ( axis Line ) ; g2 . set Rendering Hint ( Rendering Hints . KEY STROKE CONTROL , saved ) ; }
protected void draw Axis Line ( Graphics 2 D g2 , double cursor , Rectangle 2 D data Area , Rectangle Edge edge ) { Line 2 D axis Line = null ; double x = data Area . get X ( ) ; double y = data Area . get Y ( ) ; if ( edge == Rectangle Edge . TOP ) { axis Line = new Line 2 D . Double ( x , cursor , data Area . get Max X ( ) , cursor ) ; } else if ( edge == Rectangle Edge . BOTTOM ) { axis Line = new Line 2 D . Double ( x , cursor , data Area . get Max X ( ) , cursor ) ; } else if ( edge == Rectangle Edge . LEFT ) { axis Line = new Line 2 D . Double ( cursor , y , cursor , data Area . get Max Y ( ) ) ; } else if ( edge == Rectangle Edge . RIGHT ) { axis Line = new Line 2 D . Double ( cursor , y , cursor , data Area . get Max Y ( ) ) ; } g2 . set Paint ( this . axis Line Paint ) ; g2 . set Stroke ( this . axis Line Stroke ) ; Object saved = g2 . get Rendering Hint ( Rendering Hints . KEY STROKE CONTROL ) ; g2 . set Rendering Hint ( Rendering Hints . KEY STROKE CONTROL , Rendering Hints . VALUE STROKE NORMALIZE ) ; g2 . draw ( axis Line ) ; g2 . set Rendering Hint ( Rendering Hints . KEY STROKE CONTROL , saved ) ; }
@ Override public Calendar next ( ) { if ( spot . equals ( end Final ) ) { throw new No Such Element Exception ( ) ; } spot . add ( Calendar . DATE , NUM ) ; return ( Calendar ) spot . clone ( ) ; }
public Object eval ( final String script ) throws Script Exception { return eval ( script , get Context ( ) ) ; }
public Object eval ( final String script ) throws Script Exception { return eval ( script , get Context ( ) ) ; }
public Object eval ( final String script ) throws Script Exception { return eval ( script , get Context ( ) ) ; }
public void remove Statement ( String statement Name ) { rw Lock . acquire Write Lock ( ) ; try { removed Statement Names . add ( statement Name ) ; if ( removed Statement Names . size ( ) > NUM ) { for ( int i = NUM ; i <= current Last Element ; i ++ ) { if ( removed Statement Names . contains ( statement Names [ i ] ) ) { statement Names [ i ] = null ; } } removed Statement Names . clear ( ) ; } } finally { rw Lock . release Write Lock ( ) ; } }
public void remove Statement ( String statement Name ) { rw Lock . acquire Write Lock ( ) ; try { removed Statement Names . add ( statement Name ) ; if ( removed Statement Names . size ( ) > NUM ) { for ( int i = NUM ; i <= current Last Element ; i ++ ) { if ( removed Statement Names . contains ( statement Names [ i ] ) ) { statement Names [ i ] = null ; } } removed Statement Names . clear ( ) ; } } finally { rw Lock . release Write Lock ( ) ; } }
public static String byte Array To Json String ( byte [ ] bytes ) { String Builder sb = new String Builder ( bytes . length * NUM ) ; for ( byte b : bytes ) { if ( b >= NUM && b < NUM ) { char c = ( char ) b ; if ( c != STRING && c != STRING && c != STRING ) { sb . append ( c ) ; continue ; } } sb . append ( String . format ( STRING , b ) ) ; } return sb . to String ( ) ; }
public static String byte Array To Json String ( byte [ ] bytes ) { String Builder sb = new String Builder ( bytes . length * NUM ) ; for ( byte b : bytes ) { if ( b >= NUM && b < NUM ) { char c = ( char ) b ; if ( c != STRING && c != STRING && c != STRING ) { sb . append ( c ) ; continue ; } } sb . append ( String . format ( STRING , b ) ) ; } return sb . to String ( ) ; }
public static String byte Array To Json String ( byte [ ] bytes ) { String Builder sb = new String Builder ( bytes . length * NUM ) ; for ( byte b : bytes ) { if ( b >= NUM && b < NUM ) { char c = ( char ) b ; if ( c != STRING && c != STRING && c != STRING ) { sb . append ( c ) ; continue ; } } sb . append ( String . format ( STRING , b ) ) ; } return sb . to String ( ) ; }
public static String byte Array To Json String ( byte [ ] bytes ) { String Builder sb = new String Builder ( bytes . length * NUM ) ; for ( byte b : bytes ) { if ( b >= NUM && b < NUM ) { char c = ( char ) b ; if ( c != STRING && c != STRING && c != STRING ) { sb . append ( c ) ; continue ; } } sb . append ( String . format ( STRING , b ) ) ; } return sb . to String ( ) ; }
public static Rich Text rich ( String format , Object ... params ) { Validate . not Null ( format , STRING ) ; Validate . not Null ( params , STRING ) ; return rich ( String . format ( format , params ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public String pop And Encode ( boolean from Online Event ) { synchronized ( this ) { if ( active Bridge Mode == null ) { return null ; } active Bridge Mode . notify Of Flush ( this , from Online Event ) ; if ( queue . is Empty ( ) ) { return null ; } int total Payload Len = NUM ; int num Messages To Send = NUM ; for ( Js Message message : queue ) { int message Size = calculate Packed Message Length ( message ) ; if ( num Messages To Send > NUM && total Payload Len + message Size > MAX PAYLOAD SIZE && MAX PAYLOAD SIZE > NUM ) { break ; } total Payload Len += message Size ; num Messages To Send += NUM ; } String Builder sb = new String Builder ( total Payload Len ) ; for ( int i = NUM ; i < num Messages To Send ; ++ i ) { Js Message message = queue . remove First ( ) ; pack Message ( message , sb ) ; } if ( ! queue . is Empty ( ) ) { sb . append ( STRING ) ; } String ret = sb . to String ( ) ; return ret ; } }
protected synchronized void on Send Rejected ( Record Buffer < R > buffer ) { logger . trace ( STRING , name ( ) , buffer ) ; total Rejected Send Tasks . increment And Get ( ) ; throttler . on Send Rejected ( ) ; queue Buffer For Retry ( buffer ) ; }
protected synchronized void on Send Rejected ( Record Buffer < R > buffer ) { logger . trace ( STRING , name ( ) , buffer ) ; total Rejected Send Tasks . increment And Get ( ) ; throttler . on Send Rejected ( ) ; queue Buffer For Retry ( buffer ) ; }
public void add Child ( Tree Structure tree Struct ) { Util . not Null ( STRING , tree Struct ) ; if ( children == null ) { children = new Array List < Tree Structure > ( ) ; } children . add ( tree Struct ) ; }
public void add Child ( Tree Structure tree Struct ) { Util . not Null ( STRING , tree Struct ) ; if ( children == null ) { children = new Array List < Tree Structure > ( ) ; } children . add ( tree Struct ) ; }
public void remove UI Nodes ( Node ... nodes ) { for ( Node node : nodes ) remove UI Node ( node ) ; }
public Timestamp Validity State ( Data Input is ) throws IO Exception { my Timestamp = is . read Long ( ) ; }
void add ( Thread t ) { synchronized ( this ) { if ( destroyed ) { throw new Illegal Thread State Exception ( ) ; } if ( threads == null ) { threads = new Thread [ NUM ] ; } else if ( nthreads == threads . length ) { threads = Arrays . copy Of ( threads , nthreads * NUM ) ; } threads [ nthreads ] = t ; nthreads ++ ; n Unstarted Threads -- ; } }
void add ( Thread t ) { synchronized ( this ) { if ( destroyed ) { throw new Illegal Thread State Exception ( ) ; } if ( threads == null ) { threads = new Thread [ NUM ] ; } else if ( nthreads == threads . length ) { threads = Arrays . copy Of ( threads , nthreads * NUM ) ; } threads [ nthreads ] = t ; nthreads ++ ; n Unstarted Threads -- ; } }
void add ( Thread t ) { synchronized ( this ) { if ( destroyed ) { throw new Illegal Thread State Exception ( ) ; } if ( threads == null ) { threads = new Thread [ NUM ] ; } else if ( nthreads == threads . length ) { threads = Arrays . copy Of ( threads , nthreads * NUM ) ; } threads [ nthreads ] = t ; nthreads ++ ; n Unstarted Threads -- ; } }
public void add Header ( String line ) { header . add ( line ) ; }
protected boolean do Start ( ) { if ( ! lifecycle . is Active ( ) ) { return BOOL ; } if ( ! is Enable ( ) ) { return BOOL ; } int starting Count = starting Count . get And Increment ( ) ; int thread Count = thread Count . get ( ) + starting Count ; if ( thread Max < thread Count ) { starting Count . decrement And Get ( ) ; on Thread Max ( ) ; return BOOL ; } else if ( is Idle Too Low ( starting Count ) ) { return BOOL ; } else { starting Count . decrement And Get ( ) ; return BOOL ; } }
protected boolean do Start ( ) { if ( ! lifecycle . is Active ( ) ) { return BOOL ; } if ( ! is Enable ( ) ) { return BOOL ; } int starting Count = starting Count . get And Increment ( ) ; int thread Count = thread Count . get ( ) + starting Count ; if ( thread Max < thread Count ) { starting Count . decrement And Get ( ) ; on Thread Max ( ) ; return BOOL ; } else if ( is Idle Too Low ( starting Count ) ) { return BOOL ; } else { starting Count . decrement And Get ( ) ; return BOOL ; } }
protected void transform Page ( View view , float position ) { int page Width = view . get Width ( ) ; if ( position < - NUM ) { view . set Alpha ( NUM ) ; } else if ( position <= NUM ) { view . set Alpha ( NUM ) ; if ( virtual Pos > NUM ) { view . set Translation X ( page Width * - position * NUM ) ; } else { view . set Translation X ( NUM ) ; } float scale Factor = MIN SCALE + ( NUM - MIN SCALE ) * ( NUM - Math . abs ( position ) ) ; view . set Scale X ( scale Factor ) ; view . set Scale Y ( scale Factor ) ; } else if ( position <= NUM ) { view . set Alpha ( NUM - position ) ; view . set Translation X ( page Width * - position ) ; float scale Factor = MIN SCALE + ( NUM - MIN SCALE ) * ( NUM - Math . abs ( position ) ) ; view . set Scale X ( scale Factor ) ; view . set Scale Y ( scale Factor ) ; } else { view . set Alpha ( NUM ) ; } }
protected void transform Page ( View view , float position ) { int page Width = view . get Width ( ) ; if ( position < - NUM ) { view . set Alpha ( NUM ) ; } else if ( position <= NUM ) { view . set Alpha ( NUM ) ; if ( virtual Pos > NUM ) { view . set Translation X ( page Width * - position * NUM ) ; } else { view . set Translation X ( NUM ) ; } float scale Factor = MIN SCALE + ( NUM - MIN SCALE ) * ( NUM - Math . abs ( position ) ) ; view . set Scale X ( scale Factor ) ; view . set Scale Y ( scale Factor ) ; } else if ( position <= NUM ) { view . set Alpha ( NUM - position ) ; view . set Translation X ( page Width * - position ) ; float scale Factor = MIN SCALE + ( NUM - MIN SCALE ) * ( NUM - Math . abs ( position ) ) ; view . set Scale X ( scale Factor ) ; view . set Scale Y ( scale Factor ) ; } else { view . set Alpha ( NUM ) ; } }
protected void transform Page ( View view , float position ) { int page Width = view . get Width ( ) ; if ( position < - NUM ) { view . set Alpha ( NUM ) ; } else if ( position <= NUM ) { view . set Alpha ( NUM ) ; if ( virtual Pos > NUM ) { view . set Translation X ( page Width * - position * NUM ) ; } else { view . set Translation X ( NUM ) ; } float scale Factor = MIN SCALE + ( NUM - MIN SCALE ) * ( NUM - Math . abs ( position ) ) ; view . set Scale X ( scale Factor ) ; view . set Scale Y ( scale Factor ) ; } else if ( position <= NUM ) { view . set Alpha ( NUM - position ) ; view . set Translation X ( page Width * - position ) ; float scale Factor = MIN SCALE + ( NUM - MIN SCALE ) * ( NUM - Math . abs ( position ) ) ; view . set Scale X ( scale Factor ) ; view . set Scale Y ( scale Factor ) ; } else { view . set Alpha ( NUM ) ; } }
public Action Node ( String node Id ) { super ( node Id ) ; action Values = new Hash Set < Value > ( ) ; sampler = new Random ( ) ; action Values . add ( Value Factory . none ( ) ) ; }
public Action Node ( String node Id ) { super ( node Id ) ; action Values = new Hash Set < Value > ( ) ; sampler = new Random ( ) ; action Values . add ( Value Factory . none ( ) ) ; }
public Key Uri ( String uri , byte [ ] address , int port ) { if ( uri == null ) { throw new Null Pointer Exception ( STRING ) ; } else if ( address == null ) { throw new Null Pointer Exception ( STRING ) ; } else if ( port < NUM || port > MAX PORT NO ) { throw new Illegal Argument Exception ( STRING ) ; } else { this . uri = uri ; this . address = address ; this . port = port ; this . hash = ( port * NUM + uri . hash Code ( ) ) * NUM + Arrays . hash Code ( address ) ; } }
public static byte [ ] copy ( byte [ ] bytes ) { if ( bytes == null ) return null ; byte [ ] result = new byte [ bytes . length ] ; System . arraycopy ( bytes , NUM , result , NUM , bytes . length ) ; return result ; }
public static byte [ ] copy ( byte [ ] bytes ) { if ( bytes == null ) return null ; byte [ ] result = new byte [ bytes . length ] ; System . arraycopy ( bytes , NUM , result , NUM , bytes . length ) ; return result ; }
private List < Column Dictionary Chunk > read Dictionary File ( long dictionary Start Offset , int dictionary Chunk Count To Be Read ) throws IO Exception { List < Column Dictionary Chunk > dictionary Chunks = new Array List < Column Dictionary Chunk > ( dictionary Chunk Count To Be Read ) ; dictionary File Reader . set Read Offset ( dictionary Start Offset ) ; while ( dictionary File Reader . has Next ( ) && dictionary Chunks . size ( ) != dictionary Chunk Count To Be Read ) { dictionary Chunks . add ( ( Column Dictionary Chunk ) dictionary File Reader . read ( ) ) ; } return dictionary Chunks ; }
private List < Column Dictionary Chunk > read Dictionary File ( long dictionary Start Offset , int dictionary Chunk Count To Be Read ) throws IO Exception { List < Column Dictionary Chunk > dictionary Chunks = new Array List < Column Dictionary Chunk > ( dictionary Chunk Count To Be Read ) ; dictionary File Reader . set Read Offset ( dictionary Start Offset ) ; while ( dictionary File Reader . has Next ( ) && dictionary Chunks . size ( ) != dictionary Chunk Count To Be Read ) { dictionary Chunks . add ( ( Column Dictionary Chunk ) dictionary File Reader . read ( ) ) ; } return dictionary Chunks ; }
static void put Entity Descriptor ( String realm , String entity Id , Entity Descriptor Element descriptor ) { String cache Key = build Cache Key ( realm , entity Id ) ; if ( descriptor != null ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + cache Key ) ; } descriptor Cache . put ( cache Key , descriptor ) ; } else { if ( debug . message Enabled ( ) ) { debug . message ( STRING + cache Key ) ; } descriptor Cache . remove ( cache Key ) ; config Cache . remove ( cache Key ) ; } }
static void put Entity Descriptor ( String realm , String entity Id , Entity Descriptor Element descriptor ) { String cache Key = build Cache Key ( realm , entity Id ) ; if ( descriptor != null ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + cache Key ) ; } descriptor Cache . put ( cache Key , descriptor ) ; } else { if ( debug . message Enabled ( ) ) { debug . message ( STRING + cache Key ) ; } descriptor Cache . remove ( cache Key ) ; config Cache . remove ( cache Key ) ; } }
static boolean less Equal ( Object v1 , Object v2 ) { v1 = maybe Convert To String ( v1 ) ; v2 = maybe Convert To String ( v2 ) ; if ( Objects . equals ( v1 , v2 ) ) { return BOOL ; } return less ( v1 , v2 ) ; }
private String read Nfc Error Msg ( Byte Buffer reply ) throws IO Exception { int error Type = reply . get Int ( ) ; int error Code = reply . get Int ( ) ; int msg Len = reply . get Int ( ) ; if ( msg Len == NUM ) { return STRING ; } Byte Buffer msg Buffer = Byte Buffer . allocate ( msg Len ) ; read Fully ( msg Buffer ) ; String error Msg = new String ( msg Buffer . array ( ) , NUM , msg Len - NUM , Charsets . US ASCII ) ; return String . format ( STRING , error Type , error Code , error Msg ) ; }
public void update ( byte [ ] input , int offset , int len ) { if ( input == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( input . length - offset < len ) { throw new Illegal Argument Exception ( STRING ) ; } engine Update ( input , offset , len ) ; state = IN PROGRESS ; }
public void update ( byte [ ] input , int offset , int len ) { if ( input == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( input . length - offset < len ) { throw new Illegal Argument Exception ( STRING ) ; } engine Update ( input , offset , len ) ; state = IN PROGRESS ; }
public void update ( byte [ ] input , int offset , int len ) { if ( input == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( input . length - offset < len ) { throw new Illegal Argument Exception ( STRING ) ; } engine Update ( input , offset , len ) ; state = IN PROGRESS ; }
private static void edge Split Predecessors ( Ssa Method result ) { Array List < Ssa Basic Block > blocks = result . get Blocks ( ) ; for ( int i = blocks . size ( ) - NUM ; i >= NUM ; i -- ) { Ssa Basic Block block = blocks . get ( i ) ; if ( node Needs Unique Predecessor ( block ) ) { block . insert New Predecessor ( ) ; } } }
private static void edge Split Predecessors ( Ssa Method result ) { Array List < Ssa Basic Block > blocks = result . get Blocks ( ) ; for ( int i = blocks . size ( ) - NUM ; i >= NUM ; i -- ) { Ssa Basic Block block = blocks . get ( i ) ; if ( node Needs Unique Predecessor ( block ) ) { block . insert New Predecessor ( ) ; } } }
public static String read Fully ( final Reader reader ) throws IO Exception { try { final String Writer writer = new String Writer ( ) ; final char [ ] buffer = new char [ NUM ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM ) { writer . write ( buffer , NUM , count ) ; } return writer . to String ( ) ; } finally { reader . close ( ) ; } }
private static void add Id ( final String Builder buf , final byte [ ] id ) { buf . append ( STRING ) ; boolean backslash = BOOL ; for ( final byte b : id ) { buf . append ( ( char ) ( b & NUM ) ) ; if ( b == STRING && backslash ) { buf . append ( STRING ) ; } else { backslash = b == STRING ; } } buf . append ( STRING ) ; }
public Shape create Scroll Button Together Decrease ( int x , int y , int w , int h ) { path . reset ( ) ; path . move To ( x + w , y ) ; path . line To ( x + w , y + h ) ; path . line To ( x , y + h ) ; add Scroll Gap Path ( x , y , w , h , BOOL ) ; path . close Path ( ) ; return path ; }
public Shape create Scroll Button Together Decrease ( int x , int y , int w , int h ) { path . reset ( ) ; path . move To ( x + w , y ) ; path . line To ( x + w , y + h ) ; path . line To ( x , y + h ) ; add Scroll Gap Path ( x , y , w , h , BOOL ) ; path . close Path ( ) ; return path ; }
public Shape create Scroll Button Together Decrease ( int x , int y , int w , int h ) { path . reset ( ) ; path . move To ( x + w , y ) ; path . line To ( x + w , y + h ) ; path . line To ( x , y + h ) ; add Scroll Gap Path ( x , y , w , h , BOOL ) ; path . close Path ( ) ; return path ; }
public Byte Array Data Provider ( byte [ ] bytes ) { this . bytes = Arrays . copy Of ( bytes , bytes . length ) ; }
public void put ( int data ) { if ( m Buffer . capacity ( ) < ( m Length + NUM ) ) { expand Buffer ( m Length + ADDITIONAL BUFFER SIZE ) ; } m Buffer . put ( ( byte ) data ) ; ++ m Length ; }
public void put ( int data ) { if ( m Buffer . capacity ( ) < ( m Length + NUM ) ) { expand Buffer ( m Length + ADDITIONAL BUFFER SIZE ) ; } m Buffer . put ( ( byte ) data ) ; ++ m Length ; }
public static void put Short ( Byte Buffer bb , int value ) { bb . put Short ( ( short ) ( value & NUM ) ) ; }
public static I Package Fragment Root add Source Container ( I Java Project jproject , String container Name , I Path [ ] inclusion Filters , I Path [ ] exclusion Filters , String output Location ) throws Core Exception { I Project project = jproject . get Project ( ) ; I Container container = null ; if ( container Name == null || container Name . length ( ) == NUM ) { container = project ; } else { I Folder folder = project . get Folder ( container Name ) ; if ( ! folder . exists ( ) ) { Core Utility . create Folder ( folder , BOOL , BOOL , null ) ; } container = folder ; } I Package Fragment Root root = jproject . get Package Fragment Root ( container ) ; I Path output Path = null ; if ( output Location != null ) { I Folder folder = project . get Folder ( output Location ) ; if ( ! folder . exists ( ) ) { Core Utility . create Folder ( folder , BOOL , BOOL , null ) ; } output Path = folder . get Full Path ( ) ; } I Classpath Entry cpe = Java Core . new Source Entry ( root . get Path ( ) , inclusion Filters , exclusion Filters , output Path ) ; add To Classpath ( jproject , cpe ) ; return root ; }
public static double deviation ( Iterator tuples , String field ) { return deviation ( tuples , field , Data Lib . mean ( tuples , field ) ) ; }
public static double deviation ( Iterator tuples , String field ) { return deviation ( tuples , field , Data Lib . mean ( tuples , field ) ) ; }
public static double deviation ( Iterator tuples , String field ) { return deviation ( tuples , field , Data Lib . mean ( tuples , field ) ) ; }
public static double deviation ( Iterator tuples , String field ) { return deviation ( tuples , field , Data Lib . mean ( tuples , field ) ) ; }
protected void handle Auto Draw ( ) { if ( is Tool Item Selected ( Tool Bar Item Key . AUTO DRAW ) ) { on Auto Draw ( ) ; } }
protected void handle Auto Draw ( ) { if ( is Tool Item Selected ( Tool Bar Item Key . AUTO DRAW ) ) { on Auto Draw ( ) ; } }
protected void handle Auto Draw ( ) { if ( is Tool Item Selected ( Tool Bar Item Key . AUTO DRAW ) ) { on Auto Draw ( ) ; } }
protected void handle Auto Draw ( ) { if ( is Tool Item Selected ( Tool Bar Item Key . AUTO DRAW ) ) { on Auto Draw ( ) ; } }
protected void handle Auto Draw ( ) { if ( is Tool Item Selected ( Tool Bar Item Key . AUTO DRAW ) ) { on Auto Draw ( ) ; } }
private void write Object ( Object Output Stream output Stream ) throws IO Exception { output Stream . default Write Object ( ) ; do Write Object ( output Stream ) ; }
private void write Object ( Object Output Stream output Stream ) throws IO Exception { output Stream . default Write Object ( ) ; do Write Object ( output Stream ) ; }
private void write Object ( Object Output Stream output Stream ) throws IO Exception { output Stream . default Write Object ( ) ; do Write Object ( output Stream ) ; }
public void go Back ( ) { ensure Wizard Is Running ( ) ; if ( my Prev Steps . empty ( ) ) { throw new Illegal State Exception ( STRING ) ; } Model Wizard Step curr Step = my Steps . get ( my Curr Index ) ; if ( ! curr Step . can Go Back ( ) ) { throw new Illegal State Exception ( STRING ) ; } my Curr Index = my Steps . index Of ( my Prev Steps . pop ( ) ) ; update Navigation Properties ( ) ; show Current Step ( ) ; }
public static void pretty Print Videos ( List < You Tube Video > videos ) { Log . d ( TAG , STRING ) ; Log . d ( TAG , STRING + videos . size ( ) ) ; Log . d ( TAG , STRING ) ; Iterator < You Tube Video > playlist Entries = videos . iterator ( ) ; while ( playlist Entries . has Next ( ) ) { You Tube Video playlist Item = playlist Entries . next ( ) ; Log . d ( TAG , STRING + playlist Item . get Title ( ) ) ; Log . d ( TAG , STRING + playlist Item . get Id ( ) ) ; Log . d ( TAG , STRING + playlist Item . get Duration ( ) ) ; Log . d ( TAG , STRING + playlist Item . get Thumbnail URL ( ) ) ; Log . d ( TAG , STRING ) ; } }
public Document create Document ( ) throws Parser Configuration Exception { if ( document Builder == null ) { document Builder = document Builder Factory . new Document Builder ( ) ; } return document Builder . new Document ( ) ; }
private void update Chart ( ) { main Panel . remove All ( ) ; Grid Bag Constraints constraints = new Grid Bag Constraints ( ) ; constraints . fill = Grid Bag Constraints . BOTH ; constraints . gridx = NUM ; constraints . gridy = NUM ; constraints . gridwidth = NUM ; constraints . weightx = NUM ; constraints . weighty = NUM ; constraints . anchor = Grid Bag Constraints . CENTER ; J Panel chart Panel = create Chart Panel ( ) ; chart Panel . set Opaque ( BOOL ) ; chart Panel . set Background ( Color And Font Constants . BACKGROUND COLOR ) ; chart Panel . set Foreground ( Color And Font Constants . TEXT COLOR ) ; main Panel . add ( chart Panel , constraints ) ; }
public static void assert Serialization Equals ( final String witness , final Object obj , final int [ ] skip , final int end Compare ) throws Exception { Byte Array Output Stream mem Out = new Byte Array Output Stream ( ) ; Object Output Stream obj Out = new Object Output Stream ( mem Out ) ; obj Out . write Object ( obj ) ; obj Out . close ( ) ; assert Stream Equals ( witness , mem Out . to Byte Array ( ) , skip , end Compare ) ; }
public static void assert Serialization Equals ( final String witness , final Object obj , final int [ ] skip , final int end Compare ) throws Exception { Byte Array Output Stream mem Out = new Byte Array Output Stream ( ) ; Object Output Stream obj Out = new Object Output Stream ( mem Out ) ; obj Out . write Object ( obj ) ; obj Out . close ( ) ; assert Stream Equals ( witness , mem Out . to Byte Array ( ) , skip , end Compare ) ; }
public static void assert Serialization Equals ( final String witness , final Object obj , final int [ ] skip , final int end Compare ) throws Exception { Byte Array Output Stream mem Out = new Byte Array Output Stream ( ) ; Object Output Stream obj Out = new Object Output Stream ( mem Out ) ; obj Out . write Object ( obj ) ; obj Out . close ( ) ; assert Stream Equals ( witness , mem Out . to Byte Array ( ) , skip , end Compare ) ; }
public static void assert Serialization Equals ( final String witness , final Object obj , final int [ ] skip , final int end Compare ) throws Exception { Byte Array Output Stream mem Out = new Byte Array Output Stream ( ) ; Object Output Stream obj Out = new Object Output Stream ( mem Out ) ; obj Out . write Object ( obj ) ; obj Out . close ( ) ; assert Stream Equals ( witness , mem Out . to Byte Array ( ) , skip , end Compare ) ; }
public int compare ( File file 1 , File file 2 ) { return case Sensitivity . check Compare To ( file 1 . get Path ( ) , file 2 . get Path ( ) ) ; }
protected void new Equation ( DF Lattice Cell lhs , DF Operator operator , DF Lattice Cell op 1 ) { DF Equation eq = new DF Equation ( lhs , operator , op 1 ) ; equations . add Graph Node ( eq ) ; equations . add Graph Node ( lhs ) ; equations . add Graph Node ( op 1 ) ; new Equations . add ( eq ) ; op 1 . add Use ( eq ) ; lhs . add Def ( eq ) ; if ( EAGER && eq . evaluate ( ) ) changed Cell ( lhs ) ; }
public J Combo Box < String > matching Combo Box ( String road Name , String road Number , String consist Number , String eng 1 Address , String eng 2 Address , String eng 3 Address , String eng 4 Address , String eng 5 Address , String eng 6 Address , String id ) { List < Nce Consist Roster Entry > l = matching List ( road Name , road Number , consist Number , eng 1 Address , eng 2 Address , eng 3 Address , eng 4 Address , eng 5 Address , eng 6 Address , id ) ; J Combo Box < String > b = new J Combo Box < String > ( ) ; for ( int i = NUM ; i < l . size ( ) ; i ++ ) { Nce Consist Roster Entry r = list . get ( i ) ; b . add Item ( r . title String ( ) ) ; } return b ; }
public J Combo Box < String > matching Combo Box ( String road Name , String road Number , String consist Number , String eng 1 Address , String eng 2 Address , String eng 3 Address , String eng 4 Address , String eng 5 Address , String eng 6 Address , String id ) { List < Nce Consist Roster Entry > l = matching List ( road Name , road Number , consist Number , eng 1 Address , eng 2 Address , eng 3 Address , eng 4 Address , eng 5 Address , eng 6 Address , id ) ; J Combo Box < String > b = new J Combo Box < String > ( ) ; for ( int i = NUM ; i < l . size ( ) ; i ++ ) { Nce Consist Roster Entry r = list . get ( i ) ; b . add Item ( r . title String ( ) ) ; } return b ; }
public J Combo Box < String > matching Combo Box ( String road Name , String road Number , String consist Number , String eng 1 Address , String eng 2 Address , String eng 3 Address , String eng 4 Address , String eng 5 Address , String eng 6 Address , String id ) { List < Nce Consist Roster Entry > l = matching List ( road Name , road Number , consist Number , eng 1 Address , eng 2 Address , eng 3 Address , eng 4 Address , eng 5 Address , eng 6 Address , id ) ; J Combo Box < String > b = new J Combo Box < String > ( ) ; for ( int i = NUM ; i < l . size ( ) ; i ++ ) { Nce Consist Roster Entry r = list . get ( i ) ; b . add Item ( r . title String ( ) ) ; } return b ; }
public Dependency Graph find Longest Call Chain ( ) { int depth = NUM ; Dependency Graph deepest = null ; for ( Object dep : vertices . key Set ( ) ) { int its Depth = get Depth ( dep ) ; if ( its Depth > depth ) { deepest = get Sub Graph ( dep ) ; depth = its Depth ; } } return deepest ; }
public Dependency Graph find Longest Call Chain ( ) { int depth = NUM ; Dependency Graph deepest = null ; for ( Object dep : vertices . key Set ( ) ) { int its Depth = get Depth ( dep ) ; if ( its Depth > depth ) { deepest = get Sub Graph ( dep ) ; depth = its Depth ; } } return deepest ; }
public Dependency Graph find Longest Call Chain ( ) { int depth = NUM ; Dependency Graph deepest = null ; for ( Object dep : vertices . key Set ( ) ) { int its Depth = get Depth ( dep ) ; if ( its Depth > depth ) { deepest = get Sub Graph ( dep ) ; depth = its Depth ; } } return deepest ; }
public Dependency Graph find Longest Call Chain ( ) { int depth = NUM ; Dependency Graph deepest = null ; for ( Object dep : vertices . key Set ( ) ) { int its Depth = get Depth ( dep ) ; if ( its Depth > depth ) { deepest = get Sub Graph ( dep ) ; depth = its Depth ; } } return deepest ; }
public Dependency Graph find Longest Call Chain ( ) { int depth = NUM ; Dependency Graph deepest = null ; for ( Object dep : vertices . key Set ( ) ) { int its Depth = get Depth ( dep ) ; if ( its Depth > depth ) { deepest = get Sub Graph ( dep ) ; depth = its Depth ; } } return deepest ; }
public Dependency Graph find Longest Call Chain ( ) { int depth = NUM ; Dependency Graph deepest = null ; for ( Object dep : vertices . key Set ( ) ) { int its Depth = get Depth ( dep ) ; if ( its Depth > depth ) { deepest = get Sub Graph ( dep ) ; depth = its Depth ; } } return deepest ; }
public Dependency Graph find Longest Call Chain ( ) { int depth = NUM ; Dependency Graph deepest = null ; for ( Object dep : vertices . key Set ( ) ) { int its Depth = get Depth ( dep ) ; if ( its Depth > depth ) { deepest = get Sub Graph ( dep ) ; depth = its Depth ; } } return deepest ; }
private static void scrape Link ( String episode URL , int episode Num , Series series ) { String Builder episode Text Buffer = new String Builder ( STRING + episode Num + STRING ) ; String episode Text ; URL url ; Input Stream is = null ; Buffered Reader br ; String line ; try { url = new URL ( episode URL ) ; is = url . open Stream ( ) ; br = new Buffered Reader ( new Input Stream Reader ( is ) ) ; while ( ( line = br . read Line ( ) ) != null ) { episode Text Buffer . append ( line ) ; episode Text Buffer . append ( STRING ) ; } } catch ( IO Exception ioe ) { ioe . print Stack Trace ( ) ; } finally { try { if ( is != null ) is . close ( ) ; } catch ( IO Exception ioe ) { } } episode Text = episode Text Buffer . to String ( ) ; episode Text = episode Text . replace All ( STRING , STRING ) ; episode Text = episode Text . replace All ( STRING , STRING ) ; episode Text = episode Text . replace All ( STRING , STRING ) ; episode Text = episode Text . replace All ( STRING , STRING ) ; episode Text = episode Text . replace ( STRING , STRING ) ; episode Text = episode Text . replace All ( STRING , STRING ) ; episode Text = episode Text . replace All ( STRING , STRING ) ; episode Text = episode Text . replace All ( STRING , STRING ) ; save Episode ( episode Text , episode Num , series ) ; }
private void update Action Mode Menu ( boolean do Not Close Activity ) { if ( m Action Mode Callback != null && m Activity != null && ! m Activity . is Finishing ( ) ) { if ( m Items . size ( ) > NUM && m Action Mode == null ) { m Action Mode = m Activity . start Support Action Mode ( m Action Mode Callback ) ; } if ( m Items . size ( ) == NUM && m Action Mode != null ) { Action Mode action Mode = m Action Mode ; m Action Mode = null ; action Mode . finish ( ) ; } if ( m Action Mode != null ) { m Action Mode . invalidate ( ) ; } } }
public static EWMA one Minute EWMA ( ) { return new EWMA ( M1 ALPHA , NUM , Time Unit . SECONDS ) ; }
public static EWMA one Minute EWMA ( ) { return new EWMA ( M1 ALPHA , NUM , Time Unit . SECONDS ) ; }
public static List < String > split ( String str , String delim ) { List < String > split List = null ; String Tokenizer st = null ; if ( str == null ) return split List ; if ( delim != null ) st = new String Tokenizer ( str , delim ) ; else st = new String Tokenizer ( str ) ; if ( st != null && st . has More Tokens ( ) ) { split List = new Linked List < String > ( ) ; while ( st . has More Tokens ( ) ) split List . add ( st . next Token ( ) ) ; } return split List ; }
public static List < String > split ( String str , String delim ) { List < String > split List = null ; String Tokenizer st = null ; if ( str == null ) return split List ; if ( delim != null ) st = new String Tokenizer ( str , delim ) ; else st = new String Tokenizer ( str ) ; if ( st != null && st . has More Tokens ( ) ) { split List = new Linked List < String > ( ) ; while ( st . has More Tokens ( ) ) split List . add ( st . next Token ( ) ) ; } return split List ; }
protected long current Time ( ) { return System . current Time Millis ( ) ; }
private boolean try Queue Current Buffer ( long elapsed Waiting ) { if ( current Buffer . is Empty ( ) ) return BOOL ; if ( is Open && never Pub Queue . size ( ) < never Pub Capacity ) { never Pub Queue . add ( current Buffer ) ; total Queued Records . add And Get ( current Buffer . size Records ( ) ) ; total Queued Buffers . increment And Get ( ) ; on Queue Buffer Success ( current Buffer , elapsed Waiting ) ; current Buffer = new Record Buffer < > ( flow ) ; return BOOL ; } else if ( elapsed Waiting > NUM ) { on Queue Buffer Timeout ( current Buffer , elapsed Waiting ) ; return BOOL ; } else return BOOL ; }
private boolean try Queue Current Buffer ( long elapsed Waiting ) { if ( current Buffer . is Empty ( ) ) return BOOL ; if ( is Open && never Pub Queue . size ( ) < never Pub Capacity ) { never Pub Queue . add ( current Buffer ) ; total Queued Records . add And Get ( current Buffer . size Records ( ) ) ; total Queued Buffers . increment And Get ( ) ; on Queue Buffer Success ( current Buffer , elapsed Waiting ) ; current Buffer = new Record Buffer < > ( flow ) ; return BOOL ; } else if ( elapsed Waiting > NUM ) { on Queue Buffer Timeout ( current Buffer , elapsed Waiting ) ; return BOOL ; } else return BOOL ; }
private boolean try Queue Current Buffer ( long elapsed Waiting ) { if ( current Buffer . is Empty ( ) ) return BOOL ; if ( is Open && never Pub Queue . size ( ) < never Pub Capacity ) { never Pub Queue . add ( current Buffer ) ; total Queued Records . add And Get ( current Buffer . size Records ( ) ) ; total Queued Buffers . increment And Get ( ) ; on Queue Buffer Success ( current Buffer , elapsed Waiting ) ; current Buffer = new Record Buffer < > ( flow ) ; return BOOL ; } else if ( elapsed Waiting > NUM ) { on Queue Buffer Timeout ( current Buffer , elapsed Waiting ) ; return BOOL ; } else return BOOL ; }
public void do Get ( Http Servlet Request request , Http Servlet Response response ) throws Servlet Exception , IO Exception { long time = System . current Time Millis ( ) ; request . get Session ( BOOL ) ; String url = get Target URL ( request ) ; if ( ! response . is Committed ( ) ) response . send Redirect ( url ) ; response . flush Buffer ( ) ; log . fine ( STRING + url ) ; save Click ( request , url ) ; log . fine ( url + STRING + ( System . current Time Millis ( ) - time ) + STRING ) ; }
public void do Get ( Http Servlet Request request , Http Servlet Response response ) throws Servlet Exception , IO Exception { long time = System . current Time Millis ( ) ; request . get Session ( BOOL ) ; String url = get Target URL ( request ) ; if ( ! response . is Committed ( ) ) response . send Redirect ( url ) ; response . flush Buffer ( ) ; log . fine ( STRING + url ) ; save Click ( request , url ) ; log . fine ( url + STRING + ( System . current Time Millis ( ) - time ) + STRING ) ; }
public void do Get ( Http Servlet Request request , Http Servlet Response response ) throws Servlet Exception , IO Exception { long time = System . current Time Millis ( ) ; request . get Session ( BOOL ) ; String url = get Target URL ( request ) ; if ( ! response . is Committed ( ) ) response . send Redirect ( url ) ; response . flush Buffer ( ) ; log . fine ( STRING + url ) ; save Click ( request , url ) ; log . fine ( url + STRING + ( System . current Time Millis ( ) - time ) + STRING ) ; }
@ Suppress Warnings ( STRING ) protected final void ensure Capacity ( long target Size ) { long capacity = capacity ( ) ; if ( target Size > capacity ) { inflate Spine ( ) ; for ( int i = spine Index + NUM ; target Size > capacity ; i ++ ) { if ( i >= spine . length ) { int new Spine Size = spine . length * NUM ; spine = Arrays . copy Of ( spine , new Spine Size ) ; prior Element Count = Arrays . copy Of ( prior Element Count , new Spine Size ) ; } int next Chunk Size = chunk Size ( i ) ; spine [ i ] = ( E [ ] ) new Object [ next Chunk Size ] ; prior Element Count [ i ] = prior Element Count [ i - NUM ] + spine [ i - NUM ] . length ; capacity += next Chunk Size ; } } }
@ Suppress Warnings ( STRING ) protected final void ensure Capacity ( long target Size ) { long capacity = capacity ( ) ; if ( target Size > capacity ) { inflate Spine ( ) ; for ( int i = spine Index + NUM ; target Size > capacity ; i ++ ) { if ( i >= spine . length ) { int new Spine Size = spine . length * NUM ; spine = Arrays . copy Of ( spine , new Spine Size ) ; prior Element Count = Arrays . copy Of ( prior Element Count , new Spine Size ) ; } int next Chunk Size = chunk Size ( i ) ; spine [ i ] = ( E [ ] ) new Object [ next Chunk Size ] ; prior Element Count [ i ] = prior Element Count [ i - NUM ] + spine [ i - NUM ] . length ; capacity += next Chunk Size ; } } }
@ Suppress Warnings ( STRING ) protected final void ensure Capacity ( long target Size ) { long capacity = capacity ( ) ; if ( target Size > capacity ) { inflate Spine ( ) ; for ( int i = spine Index + NUM ; target Size > capacity ; i ++ ) { if ( i >= spine . length ) { int new Spine Size = spine . length * NUM ; spine = Arrays . copy Of ( spine , new Spine Size ) ; prior Element Count = Arrays . copy Of ( prior Element Count , new Spine Size ) ; } int next Chunk Size = chunk Size ( i ) ; spine [ i ] = ( E [ ] ) new Object [ next Chunk Size ] ; prior Element Count [ i ] = prior Element Count [ i - NUM ] + spine [ i - NUM ] . length ; capacity += next Chunk Size ; } } }
@ Suppress Warnings ( STRING ) protected final void ensure Capacity ( long target Size ) { long capacity = capacity ( ) ; if ( target Size > capacity ) { inflate Spine ( ) ; for ( int i = spine Index + NUM ; target Size > capacity ; i ++ ) { if ( i >= spine . length ) { int new Spine Size = spine . length * NUM ; spine = Arrays . copy Of ( spine , new Spine Size ) ; prior Element Count = Arrays . copy Of ( prior Element Count , new Spine Size ) ; } int next Chunk Size = chunk Size ( i ) ; spine [ i ] = ( E [ ] ) new Object [ next Chunk Size ] ; prior Element Count [ i ] = prior Element Count [ i - NUM ] + spine [ i - NUM ] . length ; capacity += next Chunk Size ; } } }
public Polygon ( Polygon Point [ ] points ) { this ( Arrays . as List ( points ) ) ; }
public static Zmat uzmat ( int m , int n ) throws Jampack Exception { Zmat zm = new Zmat ( m , n ) ; for ( int i = NUM ; i < m ; i ++ ) { for ( int j = NUM ; j < n ; j ++ ) { zm . re [ i ] [ j ] = R . next Double ( ) ; zm . im [ i ] [ j ] = R . next Double ( ) ; } } return zm ; }
public void updated ( ) { current Color = Html Colors . decode ( get Setting Value ( ) ) ; secondary Color = Html Colors . decode ( base Color ) ; Color foreground Color ; Color background Color ; if ( type == FOREGROUND ) { foreground Color = current Color ; background Color = secondary Color ; } else { foreground Color = secondary Color ; background Color = current Color ; } preview . set Foreground ( foreground Color ) ; preview . set Background ( background Color ) ; }
public void updated ( ) { current Color = Html Colors . decode ( get Setting Value ( ) ) ; secondary Color = Html Colors . decode ( base Color ) ; Color foreground Color ; Color background Color ; if ( type == FOREGROUND ) { foreground Color = current Color ; background Color = secondary Color ; } else { foreground Color = secondary Color ; background Color = current Color ; } preview . set Foreground ( foreground Color ) ; preview . set Background ( background Color ) ; }
public void add All ( Json Array array ) { elements . add All ( array . elements ) ; }
@ Override protected void delete Last ( final byte [ ] key ) { final Lock lock = write Lock ( ) ; lock . lock ( ) ; try { super . delete Last ( key ) ; } finally { unlock ( lock ) ; } }
@ Override protected void delete Last ( final byte [ ] key ) { final Lock lock = write Lock ( ) ; lock . lock ( ) ; try { super . delete Last ( key ) ; } finally { unlock ( lock ) ; } }
public int size ( ) { return sentences . size ( ) ; }
public static void print Raw Lines ( Print Writer writer , String msg ) { int nl ; while ( ( nl = msg . index Of ( STRING ) ) != - NUM ) { writer . println ( msg . substring ( NUM , nl ) ) ; msg = msg . substring ( nl + NUM ) ; } if ( msg . length ( ) != NUM ) writer . println ( msg ) ; }
public float read Float ( ) throws IO Exception { return dis . read Float ( ) ; }
public static String create Mangled Name ( Source source , String path , boolean str Type , Map < String , Object > attrs , String prefix ) { String Builder buf = new String Builder ( NUM ) ; if ( prefix != null ) buf . append ( prefix ) ; int hash = attrs . hash Code ( ) ; String mime Type = ( String ) attrs . get ( Transcoder . MIMETYPE ) ; Virtual File f = null ; if ( path != null ) { buf . append ( path ) ; f = source . resolve ( path ) ; if ( f != null ) hash ^= f . hash Code ( ) ; } else if ( mime Type != null ) { buf . append ( mime Type ) ; } String symbol = ( String ) attrs . get ( Transcoder . SYMBOL ) ; if ( symbol != null ) { buf . append ( STRING ) ; buf . append ( symbol ) ; } if ( str Type ) { buf . append ( STRING ) ; } return create Mangled Name ( buf . to String ( ) , hash ) ; }
public static String create Mangled Name ( Source source , String path , boolean str Type , Map < String , Object > attrs , String prefix ) { String Builder buf = new String Builder ( NUM ) ; if ( prefix != null ) buf . append ( prefix ) ; int hash = attrs . hash Code ( ) ; String mime Type = ( String ) attrs . get ( Transcoder . MIMETYPE ) ; Virtual File f = null ; if ( path != null ) { buf . append ( path ) ; f = source . resolve ( path ) ; if ( f != null ) hash ^= f . hash Code ( ) ; } else if ( mime Type != null ) { buf . append ( mime Type ) ; } String symbol = ( String ) attrs . get ( Transcoder . SYMBOL ) ; if ( symbol != null ) { buf . append ( STRING ) ; buf . append ( symbol ) ; } if ( str Type ) { buf . append ( STRING ) ; } return create Mangled Name ( buf . to String ( ) , hash ) ; }
public void test park Until 2 ( ) throws Exception { Cyclic Barrier barrier = new Cyclic Barrier ( NUM ) ; Parker parker = new Parker ( barrier , BOOL , NUM ) ; Thread parker Thread = new Thread ( parker ) ; Thread waiter Thread = new Thread ( new Wait And Unpark ( barrier , NUM , parker Thread ) ) ; parker Thread . start ( ) ; waiter Thread . start ( ) ; parker . assert Duration Is In Range ( NUM ) ; waiter Thread . join ( ) ; parker Thread . join ( ) ; }
public void test park Until 2 ( ) throws Exception { Cyclic Barrier barrier = new Cyclic Barrier ( NUM ) ; Parker parker = new Parker ( barrier , BOOL , NUM ) ; Thread parker Thread = new Thread ( parker ) ; Thread waiter Thread = new Thread ( new Wait And Unpark ( barrier , NUM , parker Thread ) ) ; parker Thread . start ( ) ; waiter Thread . start ( ) ; parker . assert Duration Is In Range ( NUM ) ; waiter Thread . join ( ) ; parker Thread . join ( ) ; }
public void test park Until 2 ( ) throws Exception { Cyclic Barrier barrier = new Cyclic Barrier ( NUM ) ; Parker parker = new Parker ( barrier , BOOL , NUM ) ; Thread parker Thread = new Thread ( parker ) ; Thread waiter Thread = new Thread ( new Wait And Unpark ( barrier , NUM , parker Thread ) ) ; parker Thread . start ( ) ; waiter Thread . start ( ) ; parker . assert Duration Is In Range ( NUM ) ; waiter Thread . join ( ) ; parker Thread . join ( ) ; }
protected Stream < Relation > create Meshed Relations ( final J Cas j Cas , final Interaction interaction , final Collection < Entity > collection ) { final List < Relation > relations = new Linked List < > ( ) ; List < Entity > entities ; if ( collection instanceof List ) { entities = ( List < Entity > ) collection ; } else { entities = new Array List < > ( collection ) ; } final List Iterator < Entity > outer = entities . list Iterator ( ) ; while ( outer . has Next ( ) ) { final Entity source = outer . next ( ) ; final List Iterator < Entity > inner = entities . list Iterator ( outer . next Index ( ) ) ; while ( inner . has Next ( ) ) { final Entity target = inner . next ( ) ; relations . add ( create Relation ( j Cas , interaction , source , target ) ) ; } } return relations . stream ( ) ; }
protected Message Digest ( String algorithm ) { this . algorithm = algorithm ; }
public static long current Time Millis ( ) { if ( mock Time != null ) return mock Time . get Time ( ) ; else return System . current Time Millis ( ) ; }
public void new Array ( final Type type ) { int typ ; switch ( type . get Sort ( ) ) { case Type . BOOLEAN : typ = Opcodes . T BOOLEAN ; break ; case Type . CHAR : typ = Opcodes . T CHAR ; break ; case Type . BYTE : typ = Opcodes . T BYTE ; break ; case Type . SHORT : typ = Opcodes . T SHORT ; break ; case Type . INT : typ = Opcodes . T INT ; break ; case Type . FLOAT : typ = Opcodes . T FLOAT ; break ; case Type . LONG : typ = Opcodes . T LONG ; break ; case Type . DOUBLE : typ = Opcodes . T DOUBLE ; break ; default : type Insn ( Opcodes . ANEWARRAY , type ) ; return ; } mv . visit Int Insn ( Opcodes . NEWARRAY , typ ) ; }
public void show Times ( long overall ) { show Times Short ( overall ) ; }
public final boolean is clearance compensation used ( ) { return compensated clearance class no > NUM ; }
public static Map < String , Page > load Pages ( String folder Path ) { Map < String , Page > page Table = new Hashtable < String , Page > ( ) ; Page curr Page ; File [ ] list Of Files ; wlf = new Wiki Link Finder ( ) ; File folder = new File ( folder Path ) ; if ( folder . exists ( ) && folder . is Directory ( ) ) { list Of Files = folder . list Files ( ) ; } else { return null ; } for ( int i = NUM ; i < list Of Files . length ; i ++ ) { File curr File = list Of Files [ i ] ; if ( curr File . is File ( ) ) { curr Page = wiki Page From File ( folder , curr File ) ; page Table . put ( curr Page . get Location ( ) , curr Page ) ; } } return page Table = determine All Inlinks ( page Table ) ; }
public static Map < String , Page > load Pages ( String folder Path ) { Map < String , Page > page Table = new Hashtable < String , Page > ( ) ; Page curr Page ; File [ ] list Of Files ; wlf = new Wiki Link Finder ( ) ; File folder = new File ( folder Path ) ; if ( folder . exists ( ) && folder . is Directory ( ) ) { list Of Files = folder . list Files ( ) ; } else { return null ; } for ( int i = NUM ; i < list Of Files . length ; i ++ ) { File curr File = list Of Files [ i ] ; if ( curr File . is File ( ) ) { curr Page = wiki Page From File ( folder , curr File ) ; page Table . put ( curr Page . get Location ( ) , curr Page ) ; } } return page Table = determine All Inlinks ( page Table ) ; }
public static Map < String , Page > load Pages ( String folder Path ) { Map < String , Page > page Table = new Hashtable < String , Page > ( ) ; Page curr Page ; File [ ] list Of Files ; wlf = new Wiki Link Finder ( ) ; File folder = new File ( folder Path ) ; if ( folder . exists ( ) && folder . is Directory ( ) ) { list Of Files = folder . list Files ( ) ; } else { return null ; } for ( int i = NUM ; i < list Of Files . length ; i ++ ) { File curr File = list Of Files [ i ] ; if ( curr File . is File ( ) ) { curr Page = wiki Page From File ( folder , curr File ) ; page Table . put ( curr Page . get Location ( ) , curr Page ) ; } } return page Table = determine All Inlinks ( page Table ) ; }
public static Map < String , Page > load Pages ( String folder Path ) { Map < String , Page > page Table = new Hashtable < String , Page > ( ) ; Page curr Page ; File [ ] list Of Files ; wlf = new Wiki Link Finder ( ) ; File folder = new File ( folder Path ) ; if ( folder . exists ( ) && folder . is Directory ( ) ) { list Of Files = folder . list Files ( ) ; } else { return null ; } for ( int i = NUM ; i < list Of Files . length ; i ++ ) { File curr File = list Of Files [ i ] ; if ( curr File . is File ( ) ) { curr Page = wiki Page From File ( folder , curr File ) ; page Table . put ( curr Page . get Location ( ) , curr Page ) ; } } return page Table = determine All Inlinks ( page Table ) ; }
public void send FTP Command ( String command ) throws IO Exception { writer . write Line ( command ) ; for ( Iterator iter = communication Listeners . iterator ( ) ; iter . has Next ( ) ; ) { FTP Communication Listener l = ( FTP Communication Listener ) iter . next ( ) ; l . sent ( command ) ; } }
protected void populate Blob ( int id , byte [ ] base Content , int required Size ) throws SQL Exception { Connection con = get Connection Via Driver Manager ( ) ; Callable Statement cstmt = null ; try { cstmt = con . prepare Call ( EXECUTE FILL BINARY BLOB ) ; cstmt . set Int ( NUM , id ) ; cstmt . set Bytes ( NUM , base Content ) ; cstmt . set Int ( NUM , required Size ) ; cstmt . execute ( ) ; } finally { close Quietly ( cstmt ) ; close Quietly ( con ) ; } }
public void touch ( ) { touch = System . current Time Millis ( ) ; if ( worker != null ) { worker . touch ( ) ; } }
public void touch ( ) { touch = System . current Time Millis ( ) ; if ( worker != null ) { worker . touch ( ) ; } }
public void touch ( ) { touch = System . current Time Millis ( ) ; if ( worker != null ) { worker . touch ( ) ; } }
public void write All ( Result Set rs , boolean include Column Names ) throws SQL Exception , IO Exception { if ( include Column Names ) { write Column Names ( rs ) ; } while ( rs . next ( ) ) { write Next ( result Service . get Column Values ( rs ) ) ; } }
protected void shuffle Test And Training Set Together ( ) { Array List l Overall = new Array List ( Test Files . size ( ) + Training Files . size ( ) ) ; l Overall . add All ( Training Files ) ; l Overall . add All ( Test Files ) ; utils . shuffle List ( l Overall ) ; Test Files . clear ( ) ; Training Files . clear ( ) ; Test Files . add All ( l Overall . sub List ( NUM , Test Files . size ( ) ) ) ; Training Files . add All ( l Overall . sub List ( Test Files . size ( ) , l Overall . size ( ) ) ) ; }
protected void shuffle Test And Training Set Together ( ) { Array List l Overall = new Array List ( Test Files . size ( ) + Training Files . size ( ) ) ; l Overall . add All ( Training Files ) ; l Overall . add All ( Test Files ) ; utils . shuffle List ( l Overall ) ; Test Files . clear ( ) ; Training Files . clear ( ) ; Test Files . add All ( l Overall . sub List ( NUM , Test Files . size ( ) ) ) ; Training Files . add All ( l Overall . sub List ( Test Files . size ( ) , l Overall . size ( ) ) ) ; }
protected void shuffle Test And Training Set Together ( ) { Array List l Overall = new Array List ( Test Files . size ( ) + Training Files . size ( ) ) ; l Overall . add All ( Training Files ) ; l Overall . add All ( Test Files ) ; utils . shuffle List ( l Overall ) ; Test Files . clear ( ) ; Training Files . clear ( ) ; Test Files . add All ( l Overall . sub List ( NUM , Test Files . size ( ) ) ) ; Training Files . add All ( l Overall . sub List ( Test Files . size ( ) , l Overall . size ( ) ) ) ; }
protected void shuffle Test And Training Set Together ( ) { Array List l Overall = new Array List ( Test Files . size ( ) + Training Files . size ( ) ) ; l Overall . add All ( Training Files ) ; l Overall . add All ( Test Files ) ; utils . shuffle List ( l Overall ) ; Test Files . clear ( ) ; Training Files . clear ( ) ; Test Files . add All ( l Overall . sub List ( NUM , Test Files . size ( ) ) ) ; Training Files . add All ( l Overall . sub List ( Test Files . size ( ) , l Overall . size ( ) ) ) ; }
public Category ( Wikipedia wiki , String p Name ) throws Wiki Api Exception { if ( p Name == null || p Name . length ( ) == NUM ) { throw new Wiki Page Not Found Exception ( ) ; } this . wiki = wiki ; cat DAO = new Category DAO ( wiki ) ; Title cat Title = new Title ( p Name ) ; create Category ( cat Title ) ; }
private double find Angle ( Point origin Point , Point target Point ) { int x1 = origin Point . x ; int y1 = origin Point . y ; int x2 = target Point . x ; int y2 = target Point . y ; double angle = NUM ; double offset = NUM ; double side A = x2 - x1 ; double side B = NUM ; if ( y1 >= y2 ) { side B = y1 - y2 ; offset = Math . to Radians ( - NUM ) ; } else { side B = - ( y2 - y1 ) ; offset = Math . to Radians ( NUM ) ; } if ( side B == NUM ) { return angle ; } angle = Math . atan ( side A / side B ) ; return angle + offset ; }
@ Override public final Object put ( String key , Object value ) { return set ( key , value ) ; }
public void on Accuracy Changed ( Sensor sensor , int accuracy ) { if ( sensor . get Type ( ) != Sensor . TYPE ACCELEROMETER ) { return ; } if ( this . status == Accel Listener . STOPPED ) { return ; } this . accuracy = accuracy ; }
private Buffered Image to Buffered Image ( final Image image ) { if ( image instanceof Buffered Image ) { return ( Buffered Image ) image ; } if ( image instanceof Volatile Image ) { Volatile Image volatile Image = ( Volatile Image ) image ; return volatile Image . get Snapshot ( ) ; } Graphics Environment graphics Environment = Graphics Environment . get Local Graphics Environment ( ) ; Graphics Device graphics Device = graphics Environment . get Default Screen Device ( ) ; Graphics Configuration graphics Configuration = graphics Device . get Default Configuration ( ) ; Buffered Image buffered Image = graphics Configuration . create Compatible Image ( image . get Width ( null ) , image . get Height ( null ) ) ; Graphics 2 D g = buffered Image . create Graphics ( ) ; g . draw Image ( image , NUM , NUM , null ) ; g . dispose ( ) ; return buffered Image ; }
public long [ ] read Long Array ( final int items , final JBBP Byte Order byte Order ) throws IO Exception { int pos = NUM ; if ( items < NUM ) { long [ ] buffer = new long [ INITIAL ARRAY BUFFER SIZE ] ; while ( has Available Data ( ) ) { final long next = read Long ( byte Order ) ; if ( buffer . length == pos ) { final long [ ] newbuffer = new long [ buffer . length << NUM ] ; System . arraycopy ( buffer , NUM , newbuffer , NUM , buffer . length ) ; buffer = newbuffer ; } buffer [ pos ++ ] = next ; } if ( buffer . length == pos ) { return buffer ; } final long [ ] result = new long [ pos ] ; System . arraycopy ( buffer , NUM , result , NUM , pos ) ; return result ; } else { final long [ ] buffer = new long [ items ] ; for ( int i = NUM ; i < items ; i ++ ) { buffer [ i ] = read Long ( byte Order ) ; } return buffer ; } }
public static String extract Full Stack Trace ( Throwable e ) { String Writer string Writer = new String Writer ( ) ; Print Writer print Writer = new Print Writer ( string Writer ) ; e . print Stack Trace ( print Writer ) ; return string Writer . to String ( ) ; }
public Byte Banded Raster ( Sample Model sample Model , Data Buffer data Buffer , Point origin ) { this ( sample Model , data Buffer , new Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
private void check Alter Partial Converters ( ) throws Security Exception { Security Manager sm = System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission ( new Joda Time Permission ( STRING ) ) ; } }
@ Override public boolean is Modified ( ) { if ( dependency List . is Modified ( ) ) { return BOOL ; } synchronized ( path List ) { new Path List . clear ( ) ; load Paths ( new Path List ) ; Collections . sort ( new Path List ) ; return ! new Path List . equals ( path List ) ; } }
@ Override public boolean is Modified ( ) { if ( dependency List . is Modified ( ) ) { return BOOL ; } synchronized ( path List ) { new Path List . clear ( ) ; load Paths ( new Path List ) ; Collections . sort ( new Path List ) ; return ! new Path List . equals ( path List ) ; } }
@ Override public boolean is Modified ( ) { if ( dependency List . is Modified ( ) ) { return BOOL ; } synchronized ( path List ) { new Path List . clear ( ) ; load Paths ( new Path List ) ; Collections . sort ( new Path List ) ; return ! new Path List . equals ( path List ) ; } }
private void init Vocoder ( int mcep order , int mcep vsize , HMM Data hts Data ) { stage = hts Data . get Stage ( ) ; gamma = hts Data . get Gamma ( ) ; use log gain = hts Data . get Use Log Gain ( ) ; fprd = hts Data . get Fperiod ( ) ; rate = hts Data . get Rate ( ) ; rand = new Random ( SEED ) ; C = new double [ mcep order ] ; CC = new double [ mcep order ] ; CINC = new double [ mcep order ] ; if ( stage == NUM ) { int vector size = ( mcep vsize * ( NUM + PADEORDER ) + NUM * PADEORDER + NUM ) - ( NUM * ( mcep order ) ) ; D1 = new double [ vector size ] ; pt 2 = ( NUM * ( PADEORDER + NUM ) ) + ( PADEORDER * ( mcep order + NUM ) ) ; for ( int i = PADEORDER ; i >= NUM ; i -- ) pt 3 [ i ] = ( NUM * ( PADEORDER + NUM ) ) + ( ( i - NUM ) * ( mcep order + NUM ) ) ; } else { int vector size = ( ( mcep vsize + NUM ) * ( stage + NUM ) ) - ( NUM * ( mcep order ) ) ; D1 = new double [ vector size ] ; } p1 = - NUM ; pc = NUM ; }
public void scroll To Open ( ) { if ( current Inner Status == Inner Status . OPENED ) { return ; } if ( max Offset == min Offset ) { return ; } int dy = - get Scroll Y ( ) - max Offset ; if ( dy == NUM ) { return ; } current Inner Status = Inner Status . SCROLLING ; int duration = MIN SCROLL DURATION + Math . abs ( ( MAX SCROLL DURATION - MIN SCROLL DURATION ) * dy / ( max Offset - min Offset ) ) ; scroller . start Scroll ( NUM , get Scroll Y ( ) , NUM , dy , duration ) ; invalidate ( ) ; }
public static double [ ] concatenate ( double [ ] [ ] vectors ) { int num Vectors = vectors . length ; int length = vectors [ NUM ] . length ; double [ ] concat = new double [ num Vectors * length ] ; for ( int i = NUM ; i < vectors . length ; i ++ ) { System . arraycopy ( vectors [ i ] , NUM , concat , i * length , length ) ; } return concat ; }
public synchronized void push Layer Event ( int layer Event Type , Layer [ ] layers ) { if ( synchronous ) { fire Layer ( layer Event Type , layers ) ; } else { events . add ( new Set Layer Runnable ( layer Event Type , layers ) ) ; if ( t == null || ! t . is Alive ( ) ) { Set Layer Runnable runnable = pop Layer Event ( ) ; if ( runnable != null ) { t = new Thread ( runnable ) ; t . start ( ) ; } } } }
public synchronized void push Layer Event ( int layer Event Type , Layer [ ] layers ) { if ( synchronous ) { fire Layer ( layer Event Type , layers ) ; } else { events . add ( new Set Layer Runnable ( layer Event Type , layers ) ) ; if ( t == null || ! t . is Alive ( ) ) { Set Layer Runnable runnable = pop Layer Event ( ) ; if ( runnable != null ) { t = new Thread ( runnable ) ; t . start ( ) ; } } } }
public synchronized void push Layer Event ( int layer Event Type , Layer [ ] layers ) { if ( synchronous ) { fire Layer ( layer Event Type , layers ) ; } else { events . add ( new Set Layer Runnable ( layer Event Type , layers ) ) ; if ( t == null || ! t . is Alive ( ) ) { Set Layer Runnable runnable = pop Layer Event ( ) ; if ( runnable != null ) { t = new Thread ( runnable ) ; t . start ( ) ; } } } }
public synchronized void push Layer Event ( int layer Event Type , Layer [ ] layers ) { if ( synchronous ) { fire Layer ( layer Event Type , layers ) ; } else { events . add ( new Set Layer Runnable ( layer Event Type , layers ) ) ; if ( t == null || ! t . is Alive ( ) ) { Set Layer Runnable runnable = pop Layer Event ( ) ; if ( runnable != null ) { t = new Thread ( runnable ) ; t . start ( ) ; } } } }
public synchronized void push Layer Event ( int layer Event Type , Layer [ ] layers ) { if ( synchronous ) { fire Layer ( layer Event Type , layers ) ; } else { events . add ( new Set Layer Runnable ( layer Event Type , layers ) ) ; if ( t == null || ! t . is Alive ( ) ) { Set Layer Runnable runnable = pop Layer Event ( ) ; if ( runnable != null ) { t = new Thread ( runnable ) ; t . start ( ) ; } } } }
public static void write Padded Integer ( Writer out , long value , int size ) throws IO Exception { int int Value = ( int ) value ; if ( int Value == value ) { write Padded Integer ( out , int Value , size ) ; } else if ( size <= NUM ) { out . write ( Long . to String ( value ) ) ; } else { if ( value < NUM ) { out . write ( STRING ) ; if ( value != Long . MIN VALUE ) { value = - value ; } else { for ( ; size > NUM ; size -- ) { out . write ( STRING ) ; } out . write ( STRING ) ; return ; } } int digits = ( int ) ( Math . log ( value ) / LOG 10 ) + NUM ; for ( ; size > digits ; size -- ) { out . write ( STRING ) ; } out . write ( Long . to String ( value ) ) ; } }
public void remove Nodes From Partition ( List < I Group Member Node > nodes To Remove ) { for ( final I Group Member Node node To Remove : nodes To Remove ) { if ( node To Remove != null ) { if ( ! non Optional Non Minus Nodes . remove ( node To Remove ) ) { if ( node To Remove . equals ( optional Or Minus ) ) { optional Or Minus = null ; } } } } recompute Definitely Produced ( ) ; }
public void remove Nodes From Partition ( List < I Group Member Node > nodes To Remove ) { for ( final I Group Member Node node To Remove : nodes To Remove ) { if ( node To Remove != null ) { if ( ! non Optional Non Minus Nodes . remove ( node To Remove ) ) { if ( node To Remove . equals ( optional Or Minus ) ) { optional Or Minus = null ; } } } } recompute Definitely Produced ( ) ; }
public static String type Name ( String cls Name ) { int package End = cls Name . last Index Of ( STRING ) ; if ( package End >= NUM && package End < cls Name . length ( ) - NUM ) cls Name = cls Name . substring ( package End + NUM ) ; if ( cls Name . ends With ( STRING ) ) { cls Name = cls Name . substring ( NUM , cls Name . length ( ) - NUM ) + STRING ; } int parent End = cls Name . last Index Of ( STRING ) ; if ( parent End >= NUM ) cls Name = cls Name . substring ( parent End + NUM ) ; return cls Name ; }
public static String type Name ( String cls Name ) { int package End = cls Name . last Index Of ( STRING ) ; if ( package End >= NUM && package End < cls Name . length ( ) - NUM ) cls Name = cls Name . substring ( package End + NUM ) ; if ( cls Name . ends With ( STRING ) ) { cls Name = cls Name . substring ( NUM , cls Name . length ( ) - NUM ) + STRING ; } int parent End = cls Name . last Index Of ( STRING ) ; if ( parent End >= NUM ) cls Name = cls Name . substring ( parent End + NUM ) ; return cls Name ; }
public Utf 8 Constant add UTF 8 ( String value ) { Utf 8 Constant entry = get UTF 8 ( value ) ; if ( entry != null ) return entry ; entry = new Utf 8 Constant ( this , entries . size ( ) , value ) ; add Constant ( entry ) ; return entry ; }
public static URL [ ] find Resource Bases ( String base Resource , Class Loader loader ) { Array List < URL > list = new Array List < URL > ( ) ; try { Enumeration < URL > urls = loader . get Resources ( base Resource ) ; while ( urls . has More Elements ( ) ) { URL url = urls . next Element ( ) ; list . add ( find Resource Base ( url , base Resource ) ) ; } } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } return list . to Array ( new URL [ list . size ( ) ] ) ; }
@ Override public Image create Accelerated Image ( Component target , int width , int height ) { Color Model model = get Color Model ( Transparency . OPAQUE ) ; Writable Raster wr = model . create Compatible Writable Raster ( width , height ) ; return new Off Screen Image ( target , model , wr , model . is Alpha Premultiplied ( ) ) ; }
public final Sequence extend ( Typed Operation operation , Variable ... inputs ) { return extend ( operation , Arrays . as List ( inputs ) ) ; }
public boolean is Empty ( ) { return nodes . is Empty ( ) ; }
public boolean is Empty ( ) { return nodes . is Empty ( ) ; }
public boolean is Empty ( ) { return nodes . is Empty ( ) ; }
public final Parallel Flux < T > do On Complete ( Runnable on Complete ) { Objects . require Non Null ( on Complete , STRING ) ; return do On Signal ( this , null , null , null , on Complete , null , null , null , null ) ; }
public final Parallel Flux < T > do On Complete ( Runnable on Complete ) { Objects . require Non Null ( on Complete , STRING ) ; return do On Signal ( this , null , null , null , on Complete , null , null , null , null ) ; }
static < T > Lazy Future Stream < T > of ( final T value ) { return lazy Future Stream ( ( Stream ) Seq . of ( value ) ) ; }
static < T > Lazy Future Stream < T > of ( final T value ) { return lazy Future Stream ( ( Stream ) Seq . of ( value ) ) ; }
static < T > Lazy Future Stream < T > of ( final T value ) { return lazy Future Stream ( ( Stream ) Seq . of ( value ) ) ; }
public int size ( ) { return rules . size ( ) ; }
public void add Email ( Ngn Email . Email Type type , String value , String description ) { m Emails . add ( new Ngn Email ( type , value , description ) ) ; }
public Element make Element ( Document document ) { Element elem = SVG Util . svg Element ( document , SVG Constants . SVG PATH TAG ) ; elem . set Attribute ( SVG Constants . SVG D ATTRIBUTE , buf . to String ( ) ) ; return elem ; }
public Analyzer save Analysis ( File file ) throws IO Exception { Print Stream ps = null ; try { ps = new Print Stream ( new Buffered Output Stream ( new File Output Stream ( file ) ) ) ; print Analysis ( ps ) ; } finally { if ( ps != null ) { ps . close ( ) ; } } return this ; }
public Analyzer save Analysis ( File file ) throws IO Exception { Print Stream ps = null ; try { ps = new Print Stream ( new Buffered Output Stream ( new File Output Stream ( file ) ) ) ; print Analysis ( ps ) ; } finally { if ( ps != null ) { ps . close ( ) ; } } return this ; }
public Analyzer save Analysis ( File file ) throws IO Exception { Print Stream ps = null ; try { ps = new Print Stream ( new Buffered Output Stream ( new File Output Stream ( file ) ) ) ; print Analysis ( ps ) ; } finally { if ( ps != null ) { ps . close ( ) ; } } return this ; }
public static String to Match Value ( Object value ) { if ( value == null ) { return null ; } else if ( value instanceof String ) { return ( String ) value ; } else if ( value instanceof Boolean ) { return to Match Value ( ( boolean ) value ) ; } else if ( value instanceof URI ) { return to Match Value ( ( URI ) value ) ; } else if ( value instanceof Enum ) { return to Match Value ( ( Enum < ? > ) value ) ; } else { return value . to String ( ) ; } }
public static String to Match Value ( Object value ) { if ( value == null ) { return null ; } else if ( value instanceof String ) { return ( String ) value ; } else if ( value instanceof Boolean ) { return to Match Value ( ( boolean ) value ) ; } else if ( value instanceof URI ) { return to Match Value ( ( URI ) value ) ; } else if ( value instanceof Enum ) { return to Match Value ( ( Enum < ? > ) value ) ; } else { return value . to String ( ) ; } }
public static String to Match Value ( Object value ) { if ( value == null ) { return null ; } else if ( value instanceof String ) { return ( String ) value ; } else if ( value instanceof Boolean ) { return to Match Value ( ( boolean ) value ) ; } else if ( value instanceof URI ) { return to Match Value ( ( URI ) value ) ; } else if ( value instanceof Enum ) { return to Match Value ( ( Enum < ? > ) value ) ; } else { return value . to String ( ) ; } }
public void write ( String filename ) { logger . info ( STRING ) ; try { open File ( filename ) ; write Xml Head ( ) ; start Carriers ( this . writer ) ; for ( Carrier carrier : carriers ) { start Carrier ( carrier , this . writer ) ; write Vehicles And Their Types ( carrier , this . writer ) ; write Shipments ( carrier , this . writer ) ; write Services ( carrier , this . writer ) ; write Plans ( carrier , this . writer ) ; end Carrier ( this . writer ) ; } end Carriers ( this . writer ) ; close ( ) ; logger . info ( STRING ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; logger . error ( e ) ; System . exit ( NUM ) ; } }
String checksum ( byte [ ] filebytes ) ;
public Feature ( ) { id = random . next Long ( ) ; }
@ Override public void validate ( final Cookie cookie , final Cookie Origin origin ) throws Malformed Cookie Exception { if ( cookie == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( origin == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( cookie instanceof Cookie 2 ) { final Cookie 2 cookie 2 = ( Cookie 2 ) cookie ; final int port = origin . get Port ( ) ; if ( cookie 2 . is Port Attribute Specified ( ) ) { if ( ! port Match ( port , cookie 2 . get Ports ( ) ) ) { throw new Malformed Cookie Exception ( STRING + STRING ) ; } } } }
@ Override public void validate ( final Cookie cookie , final Cookie Origin origin ) throws Malformed Cookie Exception { if ( cookie == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( origin == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( cookie instanceof Cookie 2 ) { final Cookie 2 cookie 2 = ( Cookie 2 ) cookie ; final int port = origin . get Port ( ) ; if ( cookie 2 . is Port Attribute Specified ( ) ) { if ( ! port Match ( port , cookie 2 . get Ports ( ) ) ) { throw new Malformed Cookie Exception ( STRING + STRING ) ; } } } }
public List < Gsm Service Parameter > create Process Parameter For Organization ( Integer org Id ) { init Graph ( org Id ) ; List < Cn A Tree Element > right Element List = get Right Hand Elements ( org Id ) ; List < Cn A Tree Element > left Element List = get Left Hand Elements ( org Id ) ; if ( LOG . is Info Enabled ( ) ) { LOG . info ( right Element List . size ( ) + STRING ) ; LOG . info ( left Element List . size ( ) + STRING ) ; } List < Gsm Service Parameter > all Parameter List = new Linked List < Gsm Service Parameter > ( ) ; for ( Cn A Tree Element control Group : right Element List ) { for ( Cn A Tree Element left Element : left Element List ) { List < Execution Impl > process List = find Processes ( left Element , control Group ) ; if ( process List != null && ! process List . is Empty ( ) ) { delete Processes ( process List ) ; } List < Gsm Service Parameter > parameter List = create Parameter ( left Element , control Group ) ; String uuid Org = load Org Uuid ( org Id ) ; for ( Gsm Service Parameter parameter : parameter List ) { parameter . set Uuid Org ( uuid Org ) ; all Parameter List . add ( parameter ) ; } } } if ( LOG . is Info Enabled ( ) ) { LOG . info ( all Parameter List . size ( ) + STRING ) ; } return all Parameter List ; }
public static boolean is Valid ( Timestamp valid From , Timestamp valid To , Timestamp test Date ) { if ( test Date == null ) return BOOL ; if ( valid From == null && valid To == null ) return BOOL ; if ( valid From != null && valid From . after ( test Date ) ) return BOOL ; if ( valid To != null && valid To . before ( test Date ) ) return BOOL ; return BOOL ; }
private List < Rule > read Rules ( Reader reader ) throws IO Exception , Illegal Argument Exception { Buffered Reader in = new Buffered Reader ( reader ) ; List < Rule > rules = new Array List < Rule > ( ) ; String line ; while ( ( line = in . read Line ( ) ) != null ) { if ( line . length ( ) == NUM ) { continue ; } line = line . trim ( ) ; char first = line . char At ( NUM ) ; boolean sign = BOOL ; switch ( first ) { case STRING : sign = BOOL ; break ; case STRING : sign = BOOL ; break ; case STRING : case STRING : case STRING : continue ; default : throw new IO Exception ( STRING + line ) ; } String regex = line . substring ( NUM ) ; if ( LOG . is Trace Enabled ( ) ) { LOG . trace ( STRING + regex + STRING ) ; } Rule rule = create Rule ( sign , regex ) ; rules . add ( rule ) ; } return rules ; }
public static final String to String ( String str ) { if ( str == null ) return STRING ; Byte Array Output Stream buffer = new Byte Array Output Stream ( ) ; to Byte Array ( buffer , str ) ; return buffer . to String ( ) ; }
public static final String to String ( String str ) { if ( str == null ) return STRING ; Byte Array Output Stream buffer = new Byte Array Output Stream ( ) ; to Byte Array ( buffer , str ) ; return buffer . to String ( ) ; }
public static final String to String ( String str ) { if ( str == null ) return STRING ; Byte Array Output Stream buffer = new Byte Array Output Stream ( ) ; to Byte Array ( buffer , str ) ; return buffer . to String ( ) ; }
public static final String to String ( String str ) { if ( str == null ) return STRING ; Byte Array Output Stream buffer = new Byte Array Output Stream ( ) ; to Byte Array ( buffer , str ) ; return buffer . to String ( ) ; }
public static final String to String ( String str ) { if ( str == null ) return STRING ; Byte Array Output Stream buffer = new Byte Array Output Stream ( ) ; to Byte Array ( buffer , str ) ; return buffer . to String ( ) ; }
private void update ( final Alive Timer alive Timer ) { alive Timer . set Active ( BOOL ) ; alive Timer . set Last Update ( System . current Time Millis ( ) ) ; if ( LOGGER . is Debug Enabled ( ) ) { String Buffer str = new String Buffer ( STRING ) ; str . append ( Alive Timer . ALIVE TYPE PROCESS + STRING ) ; str . append ( alive Timer . get Related Name ( ) ) ; str . append ( STRING ) ; LOGGER . debug ( str . to String ( ) ) ; } }
private void update ( final Alive Timer alive Timer ) { alive Timer . set Active ( BOOL ) ; alive Timer . set Last Update ( System . current Time Millis ( ) ) ; if ( LOGGER . is Debug Enabled ( ) ) { String Buffer str = new String Buffer ( STRING ) ; str . append ( Alive Timer . ALIVE TYPE PROCESS + STRING ) ; str . append ( alive Timer . get Related Name ( ) ) ; str . append ( STRING ) ; LOGGER . debug ( str . to String ( ) ) ; } }
private Edit Mode ( final String name , final String cursor Name ) { Toolkit toolkit = Toolkit . get Default Toolkit ( ) ; Image image = Resource Manager . get Image ( cursor Name ) ; if ( name . equals ( STRING ) ) { this . cursor = Cursor . get Default Cursor ( ) ; } else { this . cursor = toolkit . create Custom Cursor ( image , CENTER POINT , name ) ; } }
public void add Row ( Workspace Component component ) { data . add ( component ) ; fire Table Structure Changed ( ) ; }
public Can Prot ( ) { for ( int i = NUM ; i < get Msg Parameters ( ) . length ; i ++ ) { int conv Id = get Msg Parameters ( ) [ i ] [ FLD ID CONV ] ; Integer param Id = Integer . value Of ( i ) ; Integer can Id = get Msg Parameters ( ) [ i ] [ FLD ID CANID ] ; Vector < Integer > param List = can Msg Map . get ( can Id ) ; if ( param List == null ) param List = new Vector < Integer > ( ) ; param List . add ( param Id ) ; can Msg Map . put ( can Id , param List ) ; Ecu Data Pv pid Data = new Ecu Data Pv ( ) ; pid Data . put ( Ecu Data Pv . FID PID , param Id ) ; pid Data . put ( Ecu Data Pv . FID DESCRIPT , get Msg Descriptors ( ) [ i ] ) ; pid Data . put ( Ecu Data Pv . FID UNITS , Conversions . get Units ( conv Id ) ) ; pid Data . put ( Ecu Data Pv . FID VALUE , Float . value Of ( NUM ) ) ; pid Data . put ( Ecu Data Pv . FID FORMAT , STRING + get Msg Parameters ( ) [ i ] [ FLD ID DECIMALS ] + STRING ) ; pid Data . put ( Ecu Data Pv . FID CNVID , Integer . value Of ( get Msg Parameters ( ) [ i ] [ FLD ID CONV ] ) ) ; Can Pvs . put ( param Id , pid Data ) ; } }
private void initialize Function ( Stellar Function function , String function Name ) { try { if ( ! function . is Initialized ( ) ) { function . initialize ( context ) ; } } catch ( Throwable t ) { String error = format ( STRING , function Name ) ; throw new Parse Exception ( error , t ) ; } }
public static double similarity ( String s1 , String s2 ) { String longer = s1 , shorter = s2 ; if ( s1 . length ( ) < s2 . length ( ) ) { longer = s2 ; shorter = s1 ; } int longer Length = longer . length ( ) ; if ( longer Length == NUM ) { return NUM ; } return ( longer Length - edit Distance ( longer , shorter ) ) / ( double ) longer Length ; }
byte dir Type Forward ( ) { last Char = text . char At ( char Index ) ; if ( Character . is High Surrogate ( last Char ) ) { int code Point = Character . code Point At ( text , char Index ) ; char Index += Character . char Count ( code Point ) ; return Character . get Directionality ( code Point ) ; } char Index ++ ; byte dir Type = get Cached Directionality ( last Char ) ; if ( is Html ) { if ( last Char == STRING ) { dir Type = skip Tag Forward ( ) ; } else if ( last Char == STRING ) { dir Type = skip Entity Forward ( ) ; } } return dir Type ; }
byte dir Type Forward ( ) { last Char = text . char At ( char Index ) ; if ( Character . is High Surrogate ( last Char ) ) { int code Point = Character . code Point At ( text , char Index ) ; char Index += Character . char Count ( code Point ) ; return Character . get Directionality ( code Point ) ; } char Index ++ ; byte dir Type = get Cached Directionality ( last Char ) ; if ( is Html ) { if ( last Char == STRING ) { dir Type = skip Tag Forward ( ) ; } else if ( last Char == STRING ) { dir Type = skip Entity Forward ( ) ; } } return dir Type ; }
public static Key Pair create EC Key Pair ( String name ) throws IO Exception { try { EC Gen Parameter Spec ec Spec = new EC Gen Parameter Spec ( name ) ; Key Pair Generator key Gen = Key Pair Generator . get Instance ( STRING ) ; key Gen . initialize ( ec Spec , new Secure Random ( ) ) ; return key Gen . generate Key Pair ( ) ; } catch ( No Such Algorithm Exception | Invalid Algorithm Parameter Exception ex ) { throw new IO Exception ( ex ) ; } }
private void init ( ) throws Ade Exception { db Properties Initialized = BOOL ; final Properties prop = new Properties ( ) ; try ( File Input Stream fis = new File Input Stream ( properties File Name ) ) { prop . load ( fis ) ; db URL = prop . get Property ( DATABASE URL PARAM ) ; db Driver = prop . get Property ( DATABASE DRIVER PARAM ) ; db User Name = prop . get Property ( DATABASE USER PARAM ) ; db User Password = prop . get Property ( DATABASE PASSWORD PARAM ) ; if ( db URL != null ) { db Properties Initialized = BOOL ; db URL = db URL . trim ( ) ; db Name = parse DB Name ( ) ; } if ( db Driver != null ) { db Driver = db Driver . trim ( ) ; } else { db Properties Initialized = BOOL ; } if ( db User Name != null ) { db User Name = db User Name . trim ( ) ; } if ( db User Password != null ) { db User Password = db User Password . trim ( ) ; } } catch ( File Not Found Exception e ) { throw new Ade Ext Usage Exception ( STRING + properties File Name + STRING , e ) ; } catch ( IO Exception e ) { throw new Ade Ext Usage Exception ( STRING + properties File Name + STRING , e ) ; } catch ( Exception e ) { throw new Ade Ext Usage Exception ( STRING + properties File Name + STRING , e ) ; } }
public static boolean maybe Emtpy ( Reg Exp re ) { Reg Exp 2 r ; switch ( re . type ) { case sym . BAR : { r = ( Reg Exp 2 ) re ; return maybe Emtpy ( r . r1 ) || maybe Emtpy ( r . r2 ) ; } case sym . CONCAT : { r = ( Reg Exp 2 ) re ; return maybe Emtpy ( r . r1 ) && maybe Emtpy ( r . r2 ) ; } case sym . STAR : case sym . QUESTION : return BOOL ; case sym . PLUS : { Reg Exp 1 r1 = ( Reg Exp 1 ) re ; return maybe Emtpy ( ( Reg Exp ) r1 . content ) ; } case sym . CCLASS : case sym . CCLASSNOT : case sym . CHAR : case sym . CHAR I : return BOOL ; case sym . STRING : case sym . STRING I : { String content = ( String ) ( ( Reg Exp 1 ) re ) . content ; return content . length ( ) == NUM ; } case sym . TILDE : return BOOL ; case sym . BANG : { Reg Exp 1 r1 = ( Reg Exp 1 ) re ; return ! maybe Emtpy ( ( Reg Exp ) r1 . content ) ; } case sym . MACROUSE : return maybe Emtpy ( macros . get Definition ( ( String ) ( ( Reg Exp 1 ) re ) . content ) ) ; } throw new Error ( STRING + re . type + STRING + re ) ; }
public static boolean maybe Emtpy ( Reg Exp re ) { Reg Exp 2 r ; switch ( re . type ) { case sym . BAR : { r = ( Reg Exp 2 ) re ; return maybe Emtpy ( r . r1 ) || maybe Emtpy ( r . r2 ) ; } case sym . CONCAT : { r = ( Reg Exp 2 ) re ; return maybe Emtpy ( r . r1 ) && maybe Emtpy ( r . r2 ) ; } case sym . STAR : case sym . QUESTION : return BOOL ; case sym . PLUS : { Reg Exp 1 r1 = ( Reg Exp 1 ) re ; return maybe Emtpy ( ( Reg Exp ) r1 . content ) ; } case sym . CCLASS : case sym . CCLASSNOT : case sym . CHAR : case sym . CHAR I : return BOOL ; case sym . STRING : case sym . STRING I : { String content = ( String ) ( ( Reg Exp 1 ) re ) . content ; return content . length ( ) == NUM ; } case sym . TILDE : return BOOL ; case sym . BANG : { Reg Exp 1 r1 = ( Reg Exp 1 ) re ; return ! maybe Emtpy ( ( Reg Exp ) r1 . content ) ; } case sym . MACROUSE : return maybe Emtpy ( macros . get Definition ( ( String ) ( ( Reg Exp 1 ) re ) . content ) ) ; } throw new Error ( STRING + re . type + STRING + re ) ; }
public synchronized void add Property Change Listener ( Property Change Listener l ) { pcs . add Property Change Listener ( l ) ; }
public synchronized void add Property Change Listener ( Property Change Listener l ) { pcs . add Property Change Listener ( l ) ; }
private void calculate Window Proportions ( final int slots ) { int width = ( int ) Math . sqrt ( slots ) ; while ( slots % width != NUM ) { width -- ; if ( width <= NUM ) { logger . error ( STRING + slots ) ; width = NUM ; } } slot Window Width = width ; slot Window Height = slots / width ; }
default Type Declaration as Type ( ) { throw new Unsupported Operation Exception ( String . format ( STRING , this ) ) ; }
public Box Renderer ( String url , int width ) { this ( url , url , width , NO HEIGHT ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return BONK ; default : return null ; } }
public void close ( ) { if ( null != input Stream Reader ) { Carbon Util . close Streams ( input Stream Reader ) ; } }
public void close ( ) { if ( null != input Stream Reader ) { Carbon Util . close Streams ( input Stream Reader ) ; } }
protected static boolean network Monitor Exist ( String nw Mon Name ) { String class Method = STRING ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + STRING + nw Mon Name ) ; } if ( ( nw Mon Name == null ) || ( nw Mon Name . length ( ) == NUM ) ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING ) ; } return BOOL ; } Set < String > ntw Stats = Network Monitor . get Instance Names ( ) ; String ss = nw Mon Name . to Lower Case ( ) ; if ( ntw Stats . contains ( ss ) ) { return BOOL ; } else { return BOOL ; } }
protected static boolean network Monitor Exist ( String nw Mon Name ) { String class Method = STRING ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + STRING + nw Mon Name ) ; } if ( ( nw Mon Name == null ) || ( nw Mon Name . length ( ) == NUM ) ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING ) ; } return BOOL ; } Set < String > ntw Stats = Network Monitor . get Instance Names ( ) ; String ss = nw Mon Name . to Lower Case ( ) ; if ( ntw Stats . contains ( ss ) ) { return BOOL ; } else { return BOOL ; } }
protected static boolean network Monitor Exist ( String nw Mon Name ) { String class Method = STRING ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + STRING + nw Mon Name ) ; } if ( ( nw Mon Name == null ) || ( nw Mon Name . length ( ) == NUM ) ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING ) ; } return BOOL ; } Set < String > ntw Stats = Network Monitor . get Instance Names ( ) ; String ss = nw Mon Name . to Lower Case ( ) ; if ( ntw Stats . contains ( ss ) ) { return BOOL ; } else { return BOOL ; } }
protected String de Stress ( String phone ) { String ret Phone = phone ; if ( is Stressed ( phone ) ) { ret Phone = phone . substring ( NUM , phone . length ( ) - NUM ) ; } return ret Phone ; }
protected String de Stress ( String phone ) { String ret Phone = phone ; if ( is Stressed ( phone ) ) { ret Phone = phone . substring ( NUM , phone . length ( ) - NUM ) ; } return ret Phone ; }
protected String de Stress ( String phone ) { String ret Phone = phone ; if ( is Stressed ( phone ) ) { ret Phone = phone . substring ( NUM , phone . length ( ) - NUM ) ; } return ret Phone ; }
public Builder delay ( long duration , Time Unit time Unit ) { this . delay = time Unit . to Seconds ( duration ) ; return this ; }
public Builder delay ( long duration , Time Unit time Unit ) { this . delay = time Unit . to Seconds ( duration ) ; return this ; }
public Sms Mms Message should Notify ( ) { Sms Mms Message message ; for ( int i = NUM ; i < messages . size ( ) ; i ++ ) { message = messages . get ( i ) ; if ( message . should Notify ( ) ) { return message ; } } return null ; }
public void add Association ( int node , int endpoint ) { if ( is Associated ( node , endpoint ) ) { return ; } Z Wave Association new Association = new Z Wave Association ( node , endpoint ) ; associations . add ( new Association ) ; }
public static XML Table Definition load ( Element definition ) { XML Table Definition answer = new XML Table Definition ( ) ; answer . set Row Expression ( definition . attribute Value ( STRING ) ) ; for ( Iterator < Element > iter = definition . element Iterator ( STRING ) ; iter . has Next ( ) ; ) { Element element = iter . next ( ) ; String expression = element . attribute Value ( STRING ) ; String name = element . get Text ( ) ; String type Name = element . attribute Value ( STRING , STRING ) ; String column X Path = element . attribute Value ( STRING ) ; int type = XML Table Column Definition . parse Type ( type Name ) ; if ( column X Path != null ) { answer . add Column With X Path Name ( column X Path , expression , type ) ; } else { answer . add Column ( name , expression , type ) ; } } return answer ; }
public static XML Table Definition load ( Element definition ) { XML Table Definition answer = new XML Table Definition ( ) ; answer . set Row Expression ( definition . attribute Value ( STRING ) ) ; for ( Iterator < Element > iter = definition . element Iterator ( STRING ) ; iter . has Next ( ) ; ) { Element element = iter . next ( ) ; String expression = element . attribute Value ( STRING ) ; String name = element . get Text ( ) ; String type Name = element . attribute Value ( STRING , STRING ) ; String column X Path = element . attribute Value ( STRING ) ; int type = XML Table Column Definition . parse Type ( type Name ) ; if ( column X Path != null ) { answer . add Column With X Path Name ( column X Path , expression , type ) ; } else { answer . add Column ( name , expression , type ) ; } } return answer ; }
private void show Tag User Fragment ( String wall Id , String wall User Id , String tag Count ) { if ( is Attached ( ) ) { final Intent tag User Activity Intent = new Intent ( get Activity ( ) , Tag User Activity . class ) ; tag User Activity Intent . put Extra ( App Constants . Keys . WALL ID , wall Id ) ; tag User Activity Intent . put Extra ( App Constants . Keys . USER ID , wall User Id ) ; tag User Activity Intent . put Extra ( App Constants . Keys . TAG USER COUNT , Integer . parse Int ( tag Count ) ) ; start Activity ( tag User Activity Intent ) ; } }
public static boolean is Valid Template ( String template ) { template = template . trim ( ) ; if ( template . index Of ( STRING ) == - NUM ) { return BOOL ; } String s = template . trim ( ) ; if ( s . last Index Of ( STRING ) != s . length ( ) - NUM ) { return BOOL ; } if ( get Method Signature ( template ) == null ) { return BOOL ; } if ( get Method Body ( template ) == null ) { return BOOL ; } return BOOL ; }
static Unix Stream < String > echo ( final String input ) { Objects . require Non Null ( input , STRING ) ; return new Unix Stream Impl < > ( Stream . of ( input ) ) ; }
static Unix Stream < String > echo ( final String input ) { Objects . require Non Null ( input , STRING ) ; return new Unix Stream Impl < > ( Stream . of ( input ) ) ; }
private List < String > check Config List ( Configuration config , String name ) { String peer I Ps = config . get Config ( name ) ; Array List < String > peers = new Array List < String > ( ) ; if ( peer I Ps != null ) { for ( String ip : String Utils . split ( peer I Ps , STRING ) ) { peers . add ( ip ) ; } } return peers ; }
public static int make Word ( int hibyte , int lowbyte ) { int hi = NUM & hibyte ; int low = NUM & lowbyte ; return ( ( hi << NUM ) | low ) ; }
private void warning ( String msg , Throwable th ) { warning ( msg ) ; th . print Stack Trace ( ) ; }
public K auth ( Activity act , String type , String account ) { if ( android . os . Build . VERSION . SDK INT >= NUM && type . starts With ( STRING ) ) { ah = new Google Handle ( act , type , account ) ; } return self ( ) ; }
public K auth ( Activity act , String type , String account ) { if ( android . os . Build . VERSION . SDK INT >= NUM && type . starts With ( STRING ) ) { ah = new Google Handle ( act , type , account ) ; } return self ( ) ; }
public void refresh Storage ( List < Host System > hosts ) { if ( ! hosts . is Empty ( ) ) { execute ( new Refresh Storage ( hosts ) ) ; } }
public void sync ( ) { try { file . force ( BOOL ) ; } catch ( IO Exception e ) { close File Silently ( ) ; throw Db Exception . convert IO Exception ( e , name ) ; } }
public void sync ( ) { try { file . force ( BOOL ) ; } catch ( IO Exception e ) { close File Silently ( ) ; throw Db Exception . convert IO Exception ( e , name ) ; } }
public void sync ( ) { try { file . force ( BOOL ) ; } catch ( IO Exception e ) { close File Silently ( ) ; throw Db Exception . convert IO Exception ( e , name ) ; } }
public int hash Code ( ) { if ( myhash == - NUM ) { if ( timestamp == null ) { myhash = signer Cert Path . hash Code ( ) ; } else { myhash = signer Cert Path . hash Code ( ) + timestamp . hash Code ( ) ; } } return myhash ; }
@ After Class public void stop Jetty ( ) throws Exception { server . stop ( ) ; }
@ After Class public void stop Jetty ( ) throws Exception { server . stop ( ) ; }
private AFTP Client action Remove ( ) throws IO Exception , Page Exception { required ( STRING , item ) ; AFTP Client client = get Client ( ) ; client . delete File ( item ) ; write Cfftp ( client ) ; return client ; }
public D Open Pkcs 11 Key Store ( J Frame parent ) { super ( parent , Dialog . Modality Type . DOCUMENT MODAL ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; }
protected String escape Attribute Entities ( String text ) { char quote = format . get Attribute Quote Character ( ) ; char [ ] block = null ; int i ; int last = NUM ; int size = text . length ( ) ; for ( i = NUM ; i < size ; i ++ ) { String entity = null ; char c = text . char At ( i ) ; switch ( c ) { case STRING : entity = STRING ; break ; case STRING : entity = STRING ; break ; case STRING : if ( quote == STRING ) { entity = STRING ; } break ; case STRING : if ( quote == STRING ) { entity = STRING ; } break ; case STRING : entity = STRING ; break ; case STRING : case STRING : case STRING : break ; default : if ( ( c < NUM ) || should Encode Char ( c ) ) { entity = STRING + ( int ) c + STRING ; } break ; } if ( entity != null ) { if ( block == null ) { block = text . to Char Array ( ) ; } buffer . append ( block , last , i - last ) ; buffer . append ( entity ) ; last = i + NUM ; } } if ( last == NUM ) { return text ; } if ( last < size ) { if ( block == null ) { block = text . to Char Array ( ) ; } buffer . append ( block , last , i - last ) ; } String answer = buffer . to String ( ) ; buffer . set Length ( NUM ) ; return answer ; }
protected String escape Attribute Entities ( String text ) { char quote = format . get Attribute Quote Character ( ) ; char [ ] block = null ; int i ; int last = NUM ; int size = text . length ( ) ; for ( i = NUM ; i < size ; i ++ ) { String entity = null ; char c = text . char At ( i ) ; switch ( c ) { case STRING : entity = STRING ; break ; case STRING : entity = STRING ; break ; case STRING : if ( quote == STRING ) { entity = STRING ; } break ; case STRING : if ( quote == STRING ) { entity = STRING ; } break ; case STRING : entity = STRING ; break ; case STRING : case STRING : case STRING : break ; default : if ( ( c < NUM ) || should Encode Char ( c ) ) { entity = STRING + ( int ) c + STRING ; } break ; } if ( entity != null ) { if ( block == null ) { block = text . to Char Array ( ) ; } buffer . append ( block , last , i - last ) ; buffer . append ( entity ) ; last = i + NUM ; } } if ( last == NUM ) { return text ; } if ( last < size ) { if ( block == null ) { block = text . to Char Array ( ) ; } buffer . append ( block , last , i - last ) ; } String answer = buffer . to String ( ) ; buffer . set Length ( NUM ) ; return answer ; }
protected String escape Attribute Entities ( String text ) { char quote = format . get Attribute Quote Character ( ) ; char [ ] block = null ; int i ; int last = NUM ; int size = text . length ( ) ; for ( i = NUM ; i < size ; i ++ ) { String entity = null ; char c = text . char At ( i ) ; switch ( c ) { case STRING : entity = STRING ; break ; case STRING : entity = STRING ; break ; case STRING : if ( quote == STRING ) { entity = STRING ; } break ; case STRING : if ( quote == STRING ) { entity = STRING ; } break ; case STRING : entity = STRING ; break ; case STRING : case STRING : case STRING : break ; default : if ( ( c < NUM ) || should Encode Char ( c ) ) { entity = STRING + ( int ) c + STRING ; } break ; } if ( entity != null ) { if ( block == null ) { block = text . to Char Array ( ) ; } buffer . append ( block , last , i - last ) ; buffer . append ( entity ) ; last = i + NUM ; } } if ( last == NUM ) { return text ; } if ( last < size ) { if ( block == null ) { block = text . to Char Array ( ) ; } buffer . append ( block , last , i - last ) ; } String answer = buffer . to String ( ) ; buffer . set Length ( NUM ) ; return answer ; }
protected String escape Attribute Entities ( String text ) { char quote = format . get Attribute Quote Character ( ) ; char [ ] block = null ; int i ; int last = NUM ; int size = text . length ( ) ; for ( i = NUM ; i < size ; i ++ ) { String entity = null ; char c = text . char At ( i ) ; switch ( c ) { case STRING : entity = STRING ; break ; case STRING : entity = STRING ; break ; case STRING : if ( quote == STRING ) { entity = STRING ; } break ; case STRING : if ( quote == STRING ) { entity = STRING ; } break ; case STRING : entity = STRING ; break ; case STRING : case STRING : case STRING : break ; default : if ( ( c < NUM ) || should Encode Char ( c ) ) { entity = STRING + ( int ) c + STRING ; } break ; } if ( entity != null ) { if ( block == null ) { block = text . to Char Array ( ) ; } buffer . append ( block , last , i - last ) ; buffer . append ( entity ) ; last = i + NUM ; } } if ( last == NUM ) { return text ; } if ( last < size ) { if ( block == null ) { block = text . to Char Array ( ) ; } buffer . append ( block , last , i - last ) ; } String answer = buffer . to String ( ) ; buffer . set Length ( NUM ) ; return answer ; }
private void prepend Decrement ( Basic Block bb , IR ir ) { if ( DEBUG ) VM . sys Write ( STRING + bb + STRING ) ; Register Operand use = cbs Reg . copy RO ( ) ; Register Operand def = use . copy U 2 D ( ) ; Instruction inc = Binary . create ( INT ADD , def , use , IR Tools . IC ( - NUM ) ) ; bb . prepend Instruction ( inc ) ; }
void add Indifferent Algorithm ( String algorithm ) { indifferent Algorithms . add ( algorithm ) ; }
private boolean coord Is Calendar Cell ( float y ) { return y > cell Height ; }
public OCSP No Check Extension ( Boolean critical , Object value ) throws IO Exception { this . extension Id = PKIX Extensions . OCSP No Check Id ; this . critical = critical . boolean Value ( ) ; this . extension Value = new byte [ NUM ] ; }
private static Shape generate Donut ( double x , double y , double inner Radius , double outer Radius ) { Area a1 = new Area ( new Ellipse 2 D . Double ( x , y , outer Radius , outer Radius ) ) ; double inner Offset = ( outer Radius - inner Radius ) / NUM ; Area a2 = new Area ( new Ellipse 2 D . Double ( x + inner Offset , y + inner Offset , inner Radius , inner Radius ) ) ; a1 . subtract ( a2 ) ; return a1 ; }
private static Shape generate Donut ( double x , double y , double inner Radius , double outer Radius ) { Area a1 = new Area ( new Ellipse 2 D . Double ( x , y , outer Radius , outer Radius ) ) ; double inner Offset = ( outer Radius - inner Radius ) / NUM ; Area a2 = new Area ( new Ellipse 2 D . Double ( x + inner Offset , y + inner Offset , inner Radius , inner Radius ) ) ; a1 . subtract ( a2 ) ; return a1 ; }
protected String fetch Native Id ( String native Guid ) { String [ ] token = native Guid . split ( VNX File Constants . PLUS SEPERATOR ) ; return token [ token . length - NUM ] ; }
public static void write As PNG ( Drawable drawable , int w , int h , File file ) throws File Not Found Exception , IO Exception { Buffered Image image = new Buffered Image ( w , h , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D g2 = image . create Graphics ( ) ; drawable . draw ( g2 , new Rectangle ( w , h ) ) ; Output Stream out = new Buffered Output Stream ( new File Output Stream ( file ) ) ; try { Image IO . write ( image , STRING , out ) ; } finally { out . close ( ) ; } }
private void calculate Sizes ( ) { this . preffered Size = new Dimension ( ) ; final Buffered Image image = new Buffered Image ( NUM , NUM , Buffered Image . TYPE INT RGB ) ; final Graphics 2 D g2 d = image . create Graphics ( ) ; g2 d . set Font ( font ) ; final Font Metrics metrics = g2 d . get Font Metrics ( ) ; this . line Height = metrics . get Height ( ) ; this . preffered Size . height = this . line Height * NUM ; for ( String s : text ) { preffered Size . width = Math . max ( preffered Size . width , metrics . string Width ( s ) ) ; } this . preffered Size . width = preffered Size . width + NUM * metrics . string Width ( STRING ) ; }
private static List < String > extract Text Items ( ) { List < String > ret List = new Array List < String > ( ) ; S File Chooser chooser = new S File Chooser ( get Dictionary Directory ( ) , STRING , STRING ) ; chooser . add Extension ( STRING ) ; File the File = chooser . show Open Dialog ( ) ; if ( the File != null ) { Scanner scanner ; try { scanner = new Scanner ( new File Reader ( the File ) ) ; try { while ( scanner . has Next Line ( ) ) { Scanner line Scan = new Scanner ( scanner . next Line ( ) ) ; while ( line Scan . has Next ( ) ) { String word = line Scan . next ( ) ; ret List . add ( word ) ; } } } finally { scanner . close ( ) ; set Dictionary Directory ( chooser . get Current Location ( ) ) ; } } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; } } return ret List ; }
public static void remove Permission Recursive ( Path path , Posix File Permission permission ) throws IO Exception { change Permissions Recursive ( path , Permission Change . REMOVE , Collections . singleton ( permission ) ) ; }
protected void do Validate Zero Long File ( String path , String filename , long size , boolean check Contents ) { File in File = new File ( path , filename ) ; Data Input Stream in Stream = null ; Log . i ( LOG TAG , STRING + filename + STRING + path ) ; try { in Stream = new Data Input Stream ( new File Input Stream ( in File ) ) ; if ( check Contents ) { for ( long i = NUM ; i < size ; ++ i ) { if ( in Stream . read Long ( ) != NUM ) { fail ( STRING + filename ) ; } } } if ( in Stream != null ) { in Stream . close ( ) ; } Log . i ( LOG TAG , STRING + filename + STRING + size + STRING ) ; } catch ( IO Exception e ) { fail ( STRING + in File + STRING + e . to String ( ) ) ; } }
@ Caller Sensitive public static final void clear Cache ( ) { clear Cache ( get Loader ( Reflection . get Caller Class ( ) ) ) ; }
private void split Current Label ( Label alternate Successor , List < Label > catch Labels ) { Label new Label = new Label ( ) ; adopt ( new Label ) ; current Label . primary Successor = new Label ; current Label . alternate Successor = alternate Successor ; current Label . catch Labels = catch Labels ; current Label = new Label ; current Label . marked = BOOL ; }
public boolean remove ( Object o ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { for ( Tenant Queue q : qs . values ( ) ) { if ( q . remove ( o ) ) return BOOL ; } return BOOL ; } finally { lock . unlock ( ) ; } }
public Pcal Sym Tab ( AST ast ) throws Pcal Sym Tab Exception { symtab = new Vector ( ) ; iPC = null ; disambiguate Report = new Vector ( ) ; procs = new Vector ( ) ; processes = new Vector ( ) ; error Report = STRING ; Insert Sym ( GLOBAL , STRING , STRING , STRING , NUM , NUM ) ; Extract Sym ( ast , STRING ) ; if ( error Report . length ( ) > NUM ) throw new Pcal Sym Tab Exception ( error Report ) ; }
public Pcal Sym Tab ( AST ast ) throws Pcal Sym Tab Exception { symtab = new Vector ( ) ; iPC = null ; disambiguate Report = new Vector ( ) ; procs = new Vector ( ) ; processes = new Vector ( ) ; error Report = STRING ; Insert Sym ( GLOBAL , STRING , STRING , STRING , NUM , NUM ) ; Extract Sym ( ast , STRING ) ; if ( error Report . length ( ) > NUM ) throw new Pcal Sym Tab Exception ( error Report ) ; }
public Pcal Sym Tab ( AST ast ) throws Pcal Sym Tab Exception { symtab = new Vector ( ) ; iPC = null ; disambiguate Report = new Vector ( ) ; procs = new Vector ( ) ; processes = new Vector ( ) ; error Report = STRING ; Insert Sym ( GLOBAL , STRING , STRING , STRING , NUM , NUM ) ; Extract Sym ( ast , STRING ) ; if ( error Report . length ( ) > NUM ) throw new Pcal Sym Tab Exception ( error Report ) ; }
public static int inet Address To Int ( Inet Address inet Addr ) throws Illegal Argument Exception { byte [ ] addr = inet Addr . get Address ( ) ; if ( addr . length != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } return ( ( addr [ NUM ] & NUM ) << NUM ) | ( ( addr [ NUM ] & NUM ) << NUM ) | ( ( addr [ NUM ] & NUM ) << NUM ) | ( addr [ NUM ] & NUM ) ; }
public static Object extract Type Checked ( List < Object > args , int i , Class clazz , Function < List < Object > , Object > extract Func ) { if ( args . size ( ) < i + NUM ) { return null ; } else if ( clazz . is Instance ( args . get ( i ) ) ) { return extract Func . apply ( args ) ; } else { return null ; } }
@ Suppress Warnings ( STRING ) public List < Boundary > populate Area ( final Long ward Id ) { Hierarchy Type h Type = heirarchy Type Service . get Hierarchy Type By Name ( hierarchy Type Name ) ; ; List < Boundary > area List = new Linked List < Boundary > ( ) ; final Boundary Type child Boundary Type = boundary Type Service . get Boundary Type By Name And Hierarchy Type ( STRING , h Type ) ; final Boundary parent Boundary = boundary Service . get Boundary By Id ( ward Id ) ; area List = new Linked List ( cross Heirarchy Service . get Cross Hierarchy Childrens ( parent Boundary , child Boundary Type ) ) ; LOGGER . info ( STRING + area List . to String ( ) ) ; return area List ; }
@ Suppress Warnings ( STRING ) public List < Boundary > populate Area ( final Long ward Id ) { Hierarchy Type h Type = heirarchy Type Service . get Hierarchy Type By Name ( hierarchy Type Name ) ; ; List < Boundary > area List = new Linked List < Boundary > ( ) ; final Boundary Type child Boundary Type = boundary Type Service . get Boundary Type By Name And Hierarchy Type ( STRING , h Type ) ; final Boundary parent Boundary = boundary Service . get Boundary By Id ( ward Id ) ; area List = new Linked List ( cross Heirarchy Service . get Cross Hierarchy Childrens ( parent Boundary , child Boundary Type ) ) ; LOGGER . info ( STRING + area List . to String ( ) ) ; return area List ; }
private static Request new Status Update Request ( Session session , String message , String place Id , List < String > tag Ids , Callback callback ) { Bundle parameters = new Bundle ( ) ; parameters . put String ( STRING , message ) ; if ( place Id != null ) { parameters . put String ( STRING , place Id ) ; } if ( tag Ids != null && tag Ids . size ( ) > NUM ) { String tags = Text Utils . join ( STRING , tag Ids ) ; parameters . put String ( STRING , tags ) ; } return new Request ( session , MY FEED , parameters , Http Method . POST , callback ) ; }
private static Request new Status Update Request ( Session session , String message , String place Id , List < String > tag Ids , Callback callback ) { Bundle parameters = new Bundle ( ) ; parameters . put String ( STRING , message ) ; if ( place Id != null ) { parameters . put String ( STRING , place Id ) ; } if ( tag Ids != null && tag Ids . size ( ) > NUM ) { String tags = Text Utils . join ( STRING , tag Ids ) ; parameters . put String ( STRING , tags ) ; } return new Request ( session , MY FEED , parameters , Http Method . POST , callback ) ; }
private static Request new Status Update Request ( Session session , String message , String place Id , List < String > tag Ids , Callback callback ) { Bundle parameters = new Bundle ( ) ; parameters . put String ( STRING , message ) ; if ( place Id != null ) { parameters . put String ( STRING , place Id ) ; } if ( tag Ids != null && tag Ids . size ( ) > NUM ) { String tags = Text Utils . join ( STRING , tag Ids ) ; parameters . put String ( STRING , tags ) ; } return new Request ( session , MY FEED , parameters , Http Method . POST , callback ) ; }
public Router Handler ( final Route Builder builder , final Directory Monitor directory Monitor ) { this . builder = builder ; this . directory Monitor = directory Monitor ; Read Write Lock lock = new Reentrant Read Write Lock ( ) ; this . read = lock . read Lock ( ) ; this . write = lock . write Lock ( ) ; }
public Router Handler ( final Route Builder builder , final Directory Monitor directory Monitor ) { this . builder = builder ; this . directory Monitor = directory Monitor ; Read Write Lock lock = new Reentrant Read Write Lock ( ) ; this . read = lock . read Lock ( ) ; this . write = lock . write Lock ( ) ; }
public Case Builder when ( Object when , Object then ) { if ( ended ) { throw new Illegal State Exception ( STRING ) ; } if ( whens == null ) { whens = new Array List < > ( ) ; thens = new Array List < > ( ) ; } whens . add ( when ) ; thens . add ( then ) ; return this ; }
public static void show Image ( Capture Type capture Type , Image View image View , Uri file Uri ) { if ( image View == null ) { throw new Runtime Exception ( STRING ) ; } if ( file Uri == null ) { throw new Null Pointer Exception ( STRING ) ; } try { image View . set Image Bitmap ( capture Type == Capture Type . CAPTURED FROM CAMERA ? get Captured Image As Bitmap ( file Uri ) : get Selected Image As Bitmap ( file Uri ) ) ; } catch ( Null Pointer Exception e ) { Log . e ( TAG , STRING ) ; Log . e ( TAG , e . get Localized Message ( ) ) ; } }
public void add To Blacklist ( Host Address host Address ) { if ( host Address != null && ! is Explicit Closed ( ) ) { blacklist . put If Absent ( host Address , System . nano Time ( ) ) ; } }
public void add To Blacklist ( Host Address host Address ) { if ( host Address != null && ! is Explicit Closed ( ) ) { blacklist . put If Absent ( host Address , System . nano Time ( ) ) ; } }
public void add To Blacklist ( Host Address host Address ) { if ( host Address != null && ! is Explicit Closed ( ) ) { blacklist . put If Absent ( host Address , System . nano Time ( ) ) ; } }
public void add To Blacklist ( Host Address host Address ) { if ( host Address != null && ! is Explicit Closed ( ) ) { blacklist . put If Absent ( host Address , System . nano Time ( ) ) ; } }
public void add To Blacklist ( Host Address host Address ) { if ( host Address != null && ! is Explicit Closed ( ) ) { blacklist . put If Absent ( host Address , System . nano Time ( ) ) ; } }
public void add To Blacklist ( Host Address host Address ) { if ( host Address != null && ! is Explicit Closed ( ) ) { blacklist . put If Absent ( host Address , System . nano Time ( ) ) ; } }
private String generate Storage Port Key ( Storage HA Domain vplex Director , String object Name ) { return String . format ( STRING , vplex Director . get Native Guid ( ) , object Name ) ; }
public Constraint Violation Exception ( Server Managed Object < ? > managed Object , Localizable Message message ) { this ( managed Object , Collections . singleton ( message ) ) ; }
private void create Info Window ( ) { info Window = new J Window ( Swing Utilities . get Window Ancestor ( text Field ) ) ; info Label = new J Label ( ) ; info Window . add ( info Label ) ; J Panel content Pane = ( J Panel ) info Window . get Content Pane ( ) ; Border border = Border Factory . create Compound Border ( Border Factory . create Line Border ( Color . GRAY ) , Border Factory . create Empty Border ( NUM , NUM , NUM , NUM ) ) ; content Pane . set Border ( border ) ; content Pane . set Background ( Html Colors . decode ( STRING ) ) ; info Label . set Font ( text Field . get Font ( ) ) ; containing Window = Swing Utilities . get Window Ancestor ( text Field ) ; if ( containing Window != null ) { containing Window . add Component Listener ( component Listener ) ; } text Field . add Component Listener ( component Listener ) ; }
public static Class to Reference Class ( Class c ) { if ( c . is Primitive ( ) ) { if ( c == boolean . class ) return Boolean . class ; if ( c == byte . class ) return Byte . class ; if ( c == short . class ) return Short . class ; if ( c == char . class ) return Character . class ; if ( c == int . class ) return Integer . class ; if ( c == long . class ) return Long . class ; if ( c == float . class ) return Float . class ; if ( c == double . class ) return Double . class ; } return c ; }
public static void write String To File ( File file , String data , Charset encoding , boolean append ) throws IO Exception { Output Stream out = null ; try { out = open Output Stream ( file , append ) ; IO Utils . write ( data , out , encoding ) ; out . close ( ) ; } finally { IO Utils . close Quietly ( out ) ; } }
public static void write String To File ( File file , String data , Charset encoding , boolean append ) throws IO Exception { Output Stream out = null ; try { out = open Output Stream ( file , append ) ; IO Utils . write ( data , out , encoding ) ; out . close ( ) ; } finally { IO Utils . close Quietly ( out ) ; } }
public static void write String To File ( File file , String data , Charset encoding , boolean append ) throws IO Exception { Output Stream out = null ; try { out = open Output Stream ( file , append ) ; IO Utils . write ( data , out , encoding ) ; out . close ( ) ; } finally { IO Utils . close Quietly ( out ) ; } }
public static List < Response > execute Batch And Wait ( Request ... requests ) { Validate . not Null ( requests , STRING ) ; return execute Batch And Wait ( Arrays . as List ( requests ) ) ; }
public Core Token Exception ( int error Code , Object [ ] params , int http Status Code ) { this . error Code = error Code ; this . params = params ; this . http Status Code = http Status Code ; this . message = get Localized Message ( Locale . get Default ( ) ) ; }
public static void gc ( ) { if ( started Gc ) { force Gc = BOOL ; gc Should Loop = BOOL ; } start GC Thread ( ) ; synchronized ( LOCK ) { LOCK . notify ( ) ; } try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception er ) { } }
public static void gc ( ) { if ( started Gc ) { force Gc = BOOL ; gc Should Loop = BOOL ; } start GC Thread ( ) ; synchronized ( LOCK ) { LOCK . notify ( ) ; } try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception er ) { } }
public static void gc ( ) { if ( started Gc ) { force Gc = BOOL ; gc Should Loop = BOOL ; } start GC Thread ( ) ; synchronized ( LOCK ) { LOCK . notify ( ) ; } try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception er ) { } }
public static void gc ( ) { if ( started Gc ) { force Gc = BOOL ; gc Should Loop = BOOL ; } start GC Thread ( ) ; synchronized ( LOCK ) { LOCK . notify ( ) ; } try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception er ) { } }
public static void gc ( ) { if ( started Gc ) { force Gc = BOOL ; gc Should Loop = BOOL ; } start GC Thread ( ) ; synchronized ( LOCK ) { LOCK . notify ( ) ; } try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception er ) { } }
public static void gc ( ) { if ( started Gc ) { force Gc = BOOL ; gc Should Loop = BOOL ; } start GC Thread ( ) ; synchronized ( LOCK ) { LOCK . notify ( ) ; } try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception er ) { } }
private String apply Replacement ( final Bidi Map replacement , String contents ) { for ( Object key : replacement . key Set ( ) ) { String attribute Name = ( String ) key ; String attribute Initials = ( String ) replacement . get ( key ) ; contents = contents . replace All ( JSON Serialisation . json Attribute Name ( attribute Name ) , JSON Serialisation . json Attribute Name ( attribute Initials ) ) ; } return contents ; }
public void add Listener ( @ Not Null Perspective Type Listener listener ) { listeners . add ( listener ) ; }
public void show ( ) { app Window . set Visible ( BOOL ) ; if ( Ide Finder . get OS ( ) == OS . MAC OS X ) { try { Apple Native Look . go ( ) ; } catch ( Throwable ignore ) { } } }
public boolean add ( final T item ) { final Adapter Transaction add Transaction = new Add Transaction < > ( this , item ) ; final boolean success = add Transaction . perform ( ) ; m Transactions . offer ( add Transaction ) ; return success ; }
public OS Ref ( String ref ) throws Illegal Argument Exception { char char 1 = ref . char At ( NUM ) ; char char 2 = ref . char At ( NUM ) ; int east = Integer . parse Int ( ref . substring ( NUM , NUM ) ) * NUM ; int north = Integer . parse Int ( ref . substring ( NUM , NUM ) ) * NUM ; if ( char 1 == STRING ) { north += NUM ; } else if ( char 1 == STRING ) { north += NUM ; } else if ( char 1 == STRING ) { north += NUM ; east += NUM ; } else if ( char 1 == STRING ) { east += NUM ; } int char 2 ord = char 2 ; if ( char 2 ord > NUM ) char 2 ord -- ; double nx = ( ( char 2 ord - NUM ) % NUM ) * NUM ; double ny = ( NUM - Math . floor ( ( char 2 ord - NUM ) / NUM ) ) * NUM ; easting = east + nx ; northing = north + ny ; }
public OS Ref ( String ref ) throws Illegal Argument Exception { char char 1 = ref . char At ( NUM ) ; char char 2 = ref . char At ( NUM ) ; int east = Integer . parse Int ( ref . substring ( NUM , NUM ) ) * NUM ; int north = Integer . parse Int ( ref . substring ( NUM , NUM ) ) * NUM ; if ( char 1 == STRING ) { north += NUM ; } else if ( char 1 == STRING ) { north += NUM ; } else if ( char 1 == STRING ) { north += NUM ; east += NUM ; } else if ( char 1 == STRING ) { east += NUM ; } int char 2 ord = char 2 ; if ( char 2 ord > NUM ) char 2 ord -- ; double nx = ( ( char 2 ord - NUM ) % NUM ) * NUM ; double ny = ( NUM - Math . floor ( ( char 2 ord - NUM ) / NUM ) ) * NUM ; easting = east + nx ; northing = north + ny ; }
public OS Ref ( String ref ) throws Illegal Argument Exception { char char 1 = ref . char At ( NUM ) ; char char 2 = ref . char At ( NUM ) ; int east = Integer . parse Int ( ref . substring ( NUM , NUM ) ) * NUM ; int north = Integer . parse Int ( ref . substring ( NUM , NUM ) ) * NUM ; if ( char 1 == STRING ) { north += NUM ; } else if ( char 1 == STRING ) { north += NUM ; } else if ( char 1 == STRING ) { north += NUM ; east += NUM ; } else if ( char 1 == STRING ) { east += NUM ; } int char 2 ord = char 2 ; if ( char 2 ord > NUM ) char 2 ord -- ; double nx = ( ( char 2 ord - NUM ) % NUM ) * NUM ; double ny = ( NUM - Math . floor ( ( char 2 ord - NUM ) / NUM ) ) * NUM ; easting = east + nx ; northing = north + ny ; }
public OS Ref ( String ref ) throws Illegal Argument Exception { char char 1 = ref . char At ( NUM ) ; char char 2 = ref . char At ( NUM ) ; int east = Integer . parse Int ( ref . substring ( NUM , NUM ) ) * NUM ; int north = Integer . parse Int ( ref . substring ( NUM , NUM ) ) * NUM ; if ( char 1 == STRING ) { north += NUM ; } else if ( char 1 == STRING ) { north += NUM ; } else if ( char 1 == STRING ) { north += NUM ; east += NUM ; } else if ( char 1 == STRING ) { east += NUM ; } int char 2 ord = char 2 ; if ( char 2 ord > NUM ) char 2 ord -- ; double nx = ( ( char 2 ord - NUM ) % NUM ) * NUM ; double ny = ( NUM - Math . floor ( ( char 2 ord - NUM ) / NUM ) ) * NUM ; easting = east + nx ; northing = north + ny ; }
public Double Buffer put ( double [ ] src , int src Offset , int double Count ) { Arrays . check Offset And Count ( src . length , src Offset , double Count ) ; if ( double Count > remaining ( ) ) { throw new Buffer Overflow Exception ( ) ; } for ( int i = src Offset ; i < src Offset + double Count ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public Double Buffer put ( double [ ] src , int src Offset , int double Count ) { Arrays . check Offset And Count ( src . length , src Offset , double Count ) ; if ( double Count > remaining ( ) ) { throw new Buffer Overflow Exception ( ) ; } for ( int i = src Offset ; i < src Offset + double Count ; ++ i ) { put ( src [ i ] ) ; } return this ; }
protected static String quote SQL ( Object data , int type ) throws SQL Exception { if ( data == null ) { return STRING ; } switch ( type ) { case Types . BIT : case Types . BOOLEAN : case Types . INTEGER : case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . NUMERIC : case Types . REAL : case Types . SMALLINT : case Types . TINYINT : return data . to String ( ) ; case Types . DATE : case Types . TIME : case Types . TIMESTAMP : case Types . LONGVARCHAR : case Types . CHAR : case Types . VARCHAR : return quote String ( data . to String ( ) ) ; case Types . VARBINARY : case Types . LONGVARBINARY : case Types . BINARY : if ( data instanceof UUID ) { return STRING + data . to String ( ) + STRING ; } return STRING + String Utils . convert Bytes To Hex ( ( byte [ ] ) data ) + STRING ; case Types . CLOB : case Types . JAVA OBJECT : case Types . OTHER : case Types . BLOB : case Types . STRUCT : case Types . REF : case Types . NULL : case Types . ARRAY : case Types . DATALINK : case Types . DISTINCT : throw throw Exception ( STRING + type ) ; default : return STRING ; } }
protected void process Mouse Event ( Mouse Event e ) { if ( my Inplace Component != null && ( Mouse Event . MOUSE PRESSED == e . get ID ( ) || Mouse Event . MOUSE RELEASED == e . get ID ( ) ) ) { finish Editing ( BOOL ) ; } super . process Mouse Event ( e ) ; }
protected void process Mouse Event ( Mouse Event e ) { if ( my Inplace Component != null && ( Mouse Event . MOUSE PRESSED == e . get ID ( ) || Mouse Event . MOUSE RELEASED == e . get ID ( ) ) ) { finish Editing ( BOOL ) ; } super . process Mouse Event ( e ) ; }
public void rotate Z ( double theta ) { Matrix 3 D tmp = new Matrix 3 D ( ) ; double c = Math . cos ( theta ) ; double s = Math . sin ( theta ) ; tmp . set ( NUM , NUM , c ) ; tmp . set ( NUM , NUM , - s ) ; tmp . set ( NUM , NUM , s ) ; tmp . set ( NUM , NUM , c ) ; pre Multiply ( tmp ) ; }
public int size ( ) { return m snapshot List . size ( ) ; }
public Table sample ( double proportion ) { int table Count = ( int ) Math . round ( row Count ( ) * proportion ) ; Selection table 1 Selection = new Bitmap Backed Selection ( ) ; int [ ] selected Records = generate Uniform Bitmap ( table Count , row Count ( ) ) ; for ( int selected Record : selected Records ) { table 1 Selection . add ( selected Record ) ; } return select Where ( table 1 Selection ) ; }
public void print Len String ( String v ) throws IO Exception { if ( v == null ) { os . write ( NUM ) ; os . write ( NUM ) ; } else { int len = v . length ( ) ; os . write ( len > > NUM ) ; os . write ( len ) ; print String ( v , NUM , len ) ; } }
public void add Phone Number ( Phone Type type , String number , String description ) { final Ngn Phone Number phone Number = new Ngn Phone Number ( type , number , description ) ; if ( type == Phone Type . MOBILE ) { m Phone Numbers . add ( NUM , phone Number ) ; } else { m Phone Numbers . add ( phone Number ) ; } }
public void publish ( final String queue Name , final String routing Key , final String message ) { if ( ( m Channel != null ) && m Channel . is Open ( ) ) { try { m Channel . basic Publish ( queue Name , routing Key , null , message . get Bytes ( HTTP . UTF 8 ) ) ; } catch ( final Unsupported Encoding Exception e ) { e . print Stack Trace ( ) ; } catch ( final IO Exception e ) { e . print Stack Trace ( ) ; } } }
protected void add Numeric Train Class ( double class Value , double weight ) { if ( class Value > m Max Target ) { m Max Target = class Value ; } if ( class Value < m Min Target ) { m Min Target = class Value ; } if ( m Train Class Vals == null ) { m Train Class Vals = new double [ NUM ] ; m Train Class Weights = new double [ NUM ] ; } if ( m Num Train Class Vals == m Train Class Vals . length ) { double [ ] temp = new double [ m Train Class Vals . length * NUM ] ; System . arraycopy ( m Train Class Vals , NUM , temp , NUM , m Train Class Vals . length ) ; m Train Class Vals = temp ; temp = new double [ m Train Class Weights . length * NUM ] ; System . arraycopy ( m Train Class Weights , NUM , temp , NUM , m Train Class Weights . length ) ; m Train Class Weights = temp ; } m Train Class Vals [ m Num Train Class Vals ] = class Value ; m Train Class Weights [ m Num Train Class Vals ] = weight ; m Num Train Class Vals ++ ; }
protected void add Numeric Train Class ( double class Value , double weight ) { if ( class Value > m Max Target ) { m Max Target = class Value ; } if ( class Value < m Min Target ) { m Min Target = class Value ; } if ( m Train Class Vals == null ) { m Train Class Vals = new double [ NUM ] ; m Train Class Weights = new double [ NUM ] ; } if ( m Num Train Class Vals == m Train Class Vals . length ) { double [ ] temp = new double [ m Train Class Vals . length * NUM ] ; System . arraycopy ( m Train Class Vals , NUM , temp , NUM , m Train Class Vals . length ) ; m Train Class Vals = temp ; temp = new double [ m Train Class Weights . length * NUM ] ; System . arraycopy ( m Train Class Weights , NUM , temp , NUM , m Train Class Weights . length ) ; m Train Class Weights = temp ; } m Train Class Vals [ m Num Train Class Vals ] = class Value ; m Train Class Weights [ m Num Train Class Vals ] = weight ; m Num Train Class Vals ++ ; }
public JC Diagnostic create ( Diagnostic Type kind , Diagnostic Source source , Diagnostic Position pos , String key , Object ... args ) { return create ( kind , null , Enum Set . none Of ( Diagnostic Flag . class ) , source , pos , key , args ) ; }
public JC Diagnostic create ( Diagnostic Type kind , Diagnostic Source source , Diagnostic Position pos , String key , Object ... args ) { return create ( kind , null , Enum Set . none Of ( Diagnostic Flag . class ) , source , pos , key , args ) ; }
public JC Diagnostic create ( Diagnostic Type kind , Diagnostic Source source , Diagnostic Position pos , String key , Object ... args ) { return create ( kind , null , Enum Set . none Of ( Diagnostic Flag . class ) , source , pos , key , args ) ; }
public Select Plan ( Plan p , Predicate pred ) { this . p = p ; this . pred = pred ; hist = pred Histogram ( p . histogram ( ) , pred ) ; }
public Select Plan ( Plan p , Predicate pred ) { this . p = p ; this . pred = pred ; hist = pred Histogram ( p . histogram ( ) , pred ) ; }
public Select Plan ( Plan p , Predicate pred ) { this . p = p ; this . pred = pred ; hist = pred Histogram ( p . histogram ( ) , pred ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL ; } if ( ! ( obj instanceof XY Step Area Renderer ) ) { return BOOL ; } XY Step Area Renderer that = ( XY Step Area Renderer ) obj ; if ( this . show Outline != that . show Outline ) { return BOOL ; } if ( this . shapes Visible != that . shapes Visible ) { return BOOL ; } if ( this . shapes Filled != that . shapes Filled ) { return BOOL ; } if ( this . plot Area != that . plot Area ) { return BOOL ; } if ( this . range Base != that . range Base ) { return BOOL ; } if ( this . step Point != that . step Point ) { return BOOL ; } return super . equals ( obj ) ; }
public static double abs ( Z z ) { double are , aim , rho ; are = Math . abs ( z . re ) ; aim = Math . abs ( z . im ) ; if ( are + aim == NUM ) return NUM ; if ( are >= aim ) { rho = aim / are ; return are * Math . sqrt ( NUM + rho * rho ) ; } else { rho = are / aim ; return aim * Math . sqrt ( NUM + rho * rho ) ; } }
private String can Claim Draw ( Position pos , long [ ] pos Hash List , int pos Hash List Size , Move move ) { String draw Str = STRING ; if ( Search . can Claim Draw 50 ( pos ) ) { draw Str = STRING ; } else if ( Search . can Claim Draw Rep ( pos , pos Hash List , pos Hash List Size , pos Hash List Size ) ) { draw Str = STRING ; } else { String str Move = Text IO . move To String ( pos , move , BOOL ) ; pos Hash List [ pos Hash List Size ++ ] = pos . zobrist Hash ( ) ; Undo Info ui = new Undo Info ( ) ; pos . make Move ( move , ui ) ; if ( Search . can Claim Draw 50 ( pos ) ) { draw Str = STRING + str Move ; } else if ( Search . can Claim Draw Rep ( pos , pos Hash List , pos Hash List Size , pos Hash List Size ) ) { draw Str = STRING + str Move ; } pos . un Make Move ( move , ui ) ; } return draw Str ; }
private static void replace Alt Special Instructions ( ) { fill Instruction Map ( NUM , NUM , new Fr Instruction ( Instruction Format . D , NUM , NUM , STRING , STRING , STRING , Instruction . Flow Type . NONE , BOOL , BOOL , andccr U 8 Simulation Code ) ) ; fill Instruction Map ( NUM , NUM , new Fr Instruction ( Instruction Format . D , NUM , NUM , STRING , STRING , STRING , Instruction . Flow Type . NONE , BOOL , BOOL , stilm U 8 Simulation Code ) ) ; fill Instruction Map ( NUM , NUM , new Fr Instruction ( Instruction Format . D , NUM , NUM , STRING , STRING , STRING , Instruction . Flow Type . NONE , BOOL , BOOL , orccr U 8 Simulation Code ) ) ; fill Instruction Map ( NUM , NUM , new Fr Instruction ( Instruction Format . D , NUM , NUM , STRING , STRING , STRING , Instruction . Flow Type . NONE , BOOL , BOOL , addsp S 10 Simulation Code ) ) ; }
private static void replace Alt Special Instructions ( ) { fill Instruction Map ( NUM , NUM , new Fr Instruction ( Instruction Format . D , NUM , NUM , STRING , STRING , STRING , Instruction . Flow Type . NONE , BOOL , BOOL , andccr U 8 Simulation Code ) ) ; fill Instruction Map ( NUM , NUM , new Fr Instruction ( Instruction Format . D , NUM , NUM , STRING , STRING , STRING , Instruction . Flow Type . NONE , BOOL , BOOL , stilm U 8 Simulation Code ) ) ; fill Instruction Map ( NUM , NUM , new Fr Instruction ( Instruction Format . D , NUM , NUM , STRING , STRING , STRING , Instruction . Flow Type . NONE , BOOL , BOOL , orccr U 8 Simulation Code ) ) ; fill Instruction Map ( NUM , NUM , new Fr Instruction ( Instruction Format . D , NUM , NUM , STRING , STRING , STRING , Instruction . Flow Type . NONE , BOOL , BOOL , addsp S 10 Simulation Code ) ) ; }
private static void replace Alt Special Instructions ( ) { fill Instruction Map ( NUM , NUM , new Fr Instruction ( Instruction Format . D , NUM , NUM , STRING , STRING , STRING , Instruction . Flow Type . NONE , BOOL , BOOL , andccr U 8 Simulation Code ) ) ; fill Instruction Map ( NUM , NUM , new Fr Instruction ( Instruction Format . D , NUM , NUM , STRING , STRING , STRING , Instruction . Flow Type . NONE , BOOL , BOOL , stilm U 8 Simulation Code ) ) ; fill Instruction Map ( NUM , NUM , new Fr Instruction ( Instruction Format . D , NUM , NUM , STRING , STRING , STRING , Instruction . Flow Type . NONE , BOOL , BOOL , orccr U 8 Simulation Code ) ) ; fill Instruction Map ( NUM , NUM , new Fr Instruction ( Instruction Format . D , NUM , NUM , STRING , STRING , STRING , Instruction . Flow Type . NONE , BOOL , BOOL , addsp S 10 Simulation Code ) ) ; }
private void create Border Color ( ) { this . border Color = new RGB ( Math . min ( this . color . red * NUM , NUM ) , Math . min ( this . color . green * NUM , NUM ) , Math . min ( this . color . blue * NUM , NUM ) ) ; }
public static String encode Url ( String url ) { Uri uri = Uri . parse ( url ) ; try { Map < String , List < String > > split Query = split Query ( uri ) ; String Builder encoded Query = new String Builder ( ) ; for ( String key : split Query . key Set ( ) ) { for ( String value : split Query . get ( key ) ) { if ( encoded Query . length ( ) > NUM ) { encoded Query . append ( STRING ) ; } encoded Query . append ( key + STRING + URL Encoder . encode ( value , STRING ) ) ; } } String query String = encoded Query != null && encoded Query . length ( ) > NUM ? STRING + encoded Query : STRING ; URI base Uri = new URI ( uri . get Scheme ( ) , uri . get Authority ( ) , uri . get Path ( ) , null , uri . get Fragment ( ) ) ; return base Uri + query String ; } catch ( Unsupported Encoding Exception ignore ) { } catch ( URI Syntax Exception ignore ) { } return uri . to String ( ) ; }
public static void send Temp File ( String filename , Http Servlet Response response ) throws IO Exception { File file = new File ( System . get Property ( STRING ) , filename ) ; Servlet Utilities . send Temp File ( file , response ) ; }
private Synchronization local Pop Synchronization ( ) { Synchronization ret = null ; if ( ! synchronizations . is Empty ( ) ) ret = synchronizations . pop ( ) ; return ret ; }
private Synchronization local Pop Synchronization ( ) { Synchronization ret = null ; if ( ! synchronizations . is Empty ( ) ) ret = synchronizations . pop ( ) ; return ret ; }
final void invoke Setter ( String name , M setter , Object target , Object arg , Object cookie ) throws M Bean Exception , Reflection Exception , Invalid Attribute Value Exception { try { invoke M 2 ( setter , target , new Object [ ] { arg } , cookie ) ; } catch ( Illegal Access Exception e ) { throw new Reflection Exception ( e , e . to String ( ) ) ; } catch ( Runtime Exception e ) { maybe Invalid Parameter ( name , setter , arg , cookie ) ; throw e ; } catch ( Invocation Target Exception e ) { maybe Invalid Parameter ( name , setter , arg , cookie ) ; unwrap Invocation Target Exception ( e ) ; } }
final void invoke Setter ( String name , M setter , Object target , Object arg , Object cookie ) throws M Bean Exception , Reflection Exception , Invalid Attribute Value Exception { try { invoke M 2 ( setter , target , new Object [ ] { arg } , cookie ) ; } catch ( Illegal Access Exception e ) { throw new Reflection Exception ( e , e . to String ( ) ) ; } catch ( Runtime Exception e ) { maybe Invalid Parameter ( name , setter , arg , cookie ) ; throw e ; } catch ( Invocation Target Exception e ) { maybe Invalid Parameter ( name , setter , arg , cookie ) ; unwrap Invocation Target Exception ( e ) ; } }
final void invoke Setter ( String name , M setter , Object target , Object arg , Object cookie ) throws M Bean Exception , Reflection Exception , Invalid Attribute Value Exception { try { invoke M 2 ( setter , target , new Object [ ] { arg } , cookie ) ; } catch ( Illegal Access Exception e ) { throw new Reflection Exception ( e , e . to String ( ) ) ; } catch ( Runtime Exception e ) { maybe Invalid Parameter ( name , setter , arg , cookie ) ; throw e ; } catch ( Invocation Target Exception e ) { maybe Invalid Parameter ( name , setter , arg , cookie ) ; unwrap Invocation Target Exception ( e ) ; } }
public static boolean is File Valid ( @ Nullable File file ) { return file != null && file . exists ( ) ; }
public static boolean is File Valid ( @ Nullable File file ) { return file != null && file . exists ( ) ; }
public static boolean is File Valid ( @ Nullable File file ) { return file != null && file . exists ( ) ; }
public static int read Ints ( final File f , final Long Index a , final long offset , final long addend ) throws IO Exception { return read Ints ( f , NUM , ( int ) f . length ( ) / NUM , a , offset , addend ) ; }
public static boolean same Date ( Calendar cal , Date selected Date ) { Calendar selected Cal = Calendar . get Instance ( ) ; selected Cal . set Time ( selected Date ) ; return cal . get ( Calendar . MONTH ) == selected Cal . get ( Calendar . MONTH ) && cal . get ( Calendar . YEAR ) == selected Cal . get ( Calendar . YEAR ) && cal . get ( Calendar . DAY OF MONTH ) == selected Cal . get ( Calendar . DAY OF MONTH ) ; }
public static boolean same Date ( Calendar cal , Date selected Date ) { Calendar selected Cal = Calendar . get Instance ( ) ; selected Cal . set Time ( selected Date ) ; return cal . get ( Calendar . MONTH ) == selected Cal . get ( Calendar . MONTH ) && cal . get ( Calendar . YEAR ) == selected Cal . get ( Calendar . YEAR ) && cal . get ( Calendar . DAY OF MONTH ) == selected Cal . get ( Calendar . DAY OF MONTH ) ; }
public static Result sudo ( long timeout , String ... args ) { return sudo ( timeout , null , args ) ; }
public static Result sudo ( long timeout , String ... args ) { return sudo ( timeout , null , args ) ; }
public static Result sudo ( long timeout , String ... args ) { return sudo ( timeout , null , args ) ; }
protected Point 2 D calculate Range Marker Text Anchor Point ( Graphics 2 D g2 , Plot Orientation orientation , Rectangle 2 D data Area , Rectangle 2 D marker Area , Rectangle Insets marker Offset , Length Adjustment Type label Offset Type , Rectangle Anchor anchor ) { Rectangle 2 D anchor Rect = null ; if ( orientation == Plot Orientation . HORIZONTAL ) { anchor Rect = marker Offset . create Adjusted Rectangle ( marker Area , label Offset Type , Length Adjustment Type . CONTRACT ) ; } else if ( orientation == Plot Orientation . VERTICAL ) { anchor Rect = marker Offset . create Adjusted Rectangle ( marker Area , Length Adjustment Type . CONTRACT , label Offset Type ) ; } return Rectangle Anchor . coordinates ( anchor Rect , anchor ) ; }
void save Async ( Column Entity entity , Duration ttl , Consumer < Column Entity > call Back ) throws Execute Async Query Exception , Unsupported Operation Exception ;
private static int find End Of Label ( String n Triples Literal ) { boolean previous Was Backslash = BOOL ; for ( int i = NUM ; i < n Triples Literal . length ( ) ; i ++ ) { char c = n Triples Literal . char At ( i ) ; if ( c == STRING && ! previous Was Backslash ) { return i ; } else if ( c == STRING && ! previous Was Backslash ) { previous Was Backslash = BOOL ; } else if ( previous Was Backslash ) { previous Was Backslash = BOOL ; } } return - NUM ; }
private static int find End Of Label ( String n Triples Literal ) { boolean previous Was Backslash = BOOL ; for ( int i = NUM ; i < n Triples Literal . length ( ) ; i ++ ) { char c = n Triples Literal . char At ( i ) ; if ( c == STRING && ! previous Was Backslash ) { return i ; } else if ( c == STRING && ! previous Was Backslash ) { previous Was Backslash = BOOL ; } else if ( previous Was Backslash ) { previous Was Backslash = BOOL ; } } return - NUM ; }
public int size ( ) { synchronized ( events List ) { return events List . size ( ) ; } }
public Prefix File Filter ( String [ ] prefixes , IO Case case Sensitivity ) { if ( prefixes == null ) { throw new Illegal Argument Exception ( STRING ) ; } this . prefixes = new String [ prefixes . length ] ; System . arraycopy ( prefixes , NUM , this . prefixes , NUM , prefixes . length ) ; this . case Sensitivity = case Sensitivity == null ? IO Case . SENSITIVE : case Sensitivity ; }
public Prefix File Filter ( String [ ] prefixes , IO Case case Sensitivity ) { if ( prefixes == null ) { throw new Illegal Argument Exception ( STRING ) ; } this . prefixes = new String [ prefixes . length ] ; System . arraycopy ( prefixes , NUM , this . prefixes , NUM , prefixes . length ) ; this . case Sensitivity = case Sensitivity == null ? IO Case . SENSITIVE : case Sensitivity ; }
protected void check Colortable ( Rpf Frame frame , Rpf Frame Entry frame Entry , Rpf Toc Entry entry , int toc Number , int entry Number ) { if ( BOOL ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING ) ; Debug . output ( STRING + entry . Cib ) ; } colortable . set From ( frame . get Colortable ( ) ) ; colortable . set Cib ( entry . Cib ) ; colortable . set ATOC Indexes ( toc Number , entry Number ) ; colortable . zone = entry . zone ; colortable . series Code = entry . info . series Code ; } if ( view Attributes != null ) { colortable . set Opaqueness ( view Attributes . opaqueness ) ; } }
public void add Missing Columns ( String trx Name ) { int total = NUM ; String sql = STRING + STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , trx Name ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) total += add Missing Columns ( new M Print Format ( m ctx , rs , trx Name ) ) ; } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } log . info ( STRING + total ) ; }
public Url Parser ( String url ) throws Malformed URL Exception { if ( url != null && url . length ( ) > NUM ) { int ppos = url . index Of ( STRING ) ; if ( ppos >= NUM ) { protocol = url . substring ( NUM , ppos ) ; url = url . substring ( ppos + NUM ) ; } String hostport ; ppos = url . index Of ( STRING ) ; if ( ppos >= NUM ) { hostport = url . substring ( NUM , ppos ) ; path = url . substring ( ppos + NUM ) ; } else { hostport = url ; } ppos = hostport . index Of ( STRING ) ; if ( ppos >= NUM ) { host = hostport . substring ( NUM , ppos ) ; String port String = hostport . substring ( ppos + NUM ) ; try { this . port = Integer . parse Int ( port String ) ; } catch ( Number Format Exception e ) { logger . trace ( STRING , e ) ; throw new Malformed URL Exception ( STRING + port String ) ; } } else { host = hostport ; } } else { throw new Malformed URL Exception ( STRING ) ; } }
private JSON Array request All File Systems ( ) throws IO Exception , JSON Exception { JSON Array ret = new JSON Array ( ) ; for ( Filesystem fs : filesystems ) { ret . put ( fs . get Root Entry ( ) ) ; } return ret ; }
private JSON Array request All File Systems ( ) throws IO Exception , JSON Exception { JSON Array ret = new JSON Array ( ) ; for ( Filesystem fs : filesystems ) { ret . put ( fs . get Root Entry ( ) ) ; } return ret ; }
public synchronized void add Session ( MX Session session ) { m Login Storage . add Credentials ( session . get Homeserver Config ( ) ) ; synchronized ( LOG TAG ) { mMX Sessions . add ( session ) ; } }
public static String convert To Box ( String s ) { String temp = s . replace All ( STRING , STRING ) ; if ( temp . ends With ( STRING ) ) { temp = temp . substring ( NUM , temp . length ( ) - NUM ) + STRING ; } temp = temp . replace All ( STRING , STRING ) ; return Word Utils . capitalize Fully ( temp ) ; }
public List < Pdf Object > sub List ( int from Index , int to Index ) { return list . sub List ( from Index , to Index ) ; }
public List < Pdf Object > sub List ( int from Index , int to Index ) { return list . sub List ( from Index , to Index ) ; }
public boolean is Safe Mode ( ) { return this . safe Mode ; }
public boolean is Safe Mode ( ) { return this . safe Mode ; }
public void delete Item ( int position ) { if ( ! is Data List Empty ( ) && position >= NUM && position < m Data List . size ( ) ) { m Data List . remove ( position ) ; notify Item Removed ( position ) ; } }
public void delete Item ( int position ) { if ( ! is Data List Empty ( ) && position >= NUM && position < m Data List . size ( ) ) { m Data List . remove ( position ) ; notify Item Removed ( position ) ; } }
private Assertion Error create Comparison Failure ( String class Name , String expected , String actual ) throws Exception { Class < ? > clazz = Class . for Name ( class Name ) ; Constructor < ? > constructor = clazz . get Constructor ( String . class , String . class , String . class ) ; return ( Assertion Error ) constructor . new Instance ( STRING , expected , actual ) ; }
public Temporal OM Scaling Icon ( Object id , int render Type , boolean interpolate , Image Icon ii , float base Scale ) { this ( id , render Type , interpolate ) ; set Width ( ii . get Icon Width ( ) ) ; set Height ( ii . get Icon Height ( ) ) ; set Color Model ( OM Raster Object . COLORMODEL IMAGEICON ) ; set Image ( ii . get Image ( ) ) ; set Base Scale ( base Scale ) ; }
public void add Tag ( final Tag tag , final boolean pre Select ) { if ( ! m Displayed Tags . contains ( tag ) ) { m Displayed Tags . add ( tag ) ; } if ( pre Select && ! m Selected Tags . contains ( tag . id ) ) { m Selected Tags . add ( tag . id ) ; } if ( ! m Tag View Map . contains Key ( tag ) ) { add Tag To View ( tag ) ; } }
public Id < Dg Crossing Node > convert Node Id 2 Not Expanded Crossing Node Id ( Id < Node > node Id ) { String id String = node Id . to String ( ) ; return id Pool . create Id ( id String , Dg Crossing Node . class ) ; }
public Id < Dg Crossing Node > convert Node Id 2 Not Expanded Crossing Node Id ( Id < Node > node Id ) { String id String = node Id . to String ( ) ; return id Pool . create Id ( id String , Dg Crossing Node . class ) ; }
public Id < Dg Crossing Node > convert Node Id 2 Not Expanded Crossing Node Id ( Id < Node > node Id ) { String id String = node Id . to String ( ) ; return id Pool . create Id ( id String , Dg Crossing Node . class ) ; }
public Id < Dg Crossing Node > convert Node Id 2 Not Expanded Crossing Node Id ( Id < Node > node Id ) { String id String = node Id . to String ( ) ; return id Pool . create Id ( id String , Dg Crossing Node . class ) ; }
@ Override public void update Text Views ( Recharge recharge ) { unit Type Text View . set Text ( recharge . get Units ( ) ) ; unit Value Text View . set Text ( String . value Of ( recharge . get Current Amount ( ) ) ) ; cost Text View . set Text ( Currency . localize ( recharge . get Current Cost ( ) , BOOL ) ) ; recharge Name . set Text ( recharge . get Title ( ) ) ; confirmation Text View . set Text ( STRING + recharge . get Current Amount ( ) + STRING + recharge . get Units ( ) + STRING ) ; if ( recharge . get Current Amount ( ) == recharge . get Initial Amount ( ) ) { down Arrow . set Visibility ( View . INVISIBLE ) ; } else { down Arrow . set Visibility ( View . VISIBLE ) ; } }
@ Override public void update Text Views ( Recharge recharge ) { unit Type Text View . set Text ( recharge . get Units ( ) ) ; unit Value Text View . set Text ( String . value Of ( recharge . get Current Amount ( ) ) ) ; cost Text View . set Text ( Currency . localize ( recharge . get Current Cost ( ) , BOOL ) ) ; recharge Name . set Text ( recharge . get Title ( ) ) ; confirmation Text View . set Text ( STRING + recharge . get Current Amount ( ) + STRING + recharge . get Units ( ) + STRING ) ; if ( recharge . get Current Amount ( ) == recharge . get Initial Amount ( ) ) { down Arrow . set Visibility ( View . INVISIBLE ) ; } else { down Arrow . set Visibility ( View . VISIBLE ) ; } }
@ Override public void update Text Views ( Recharge recharge ) { unit Type Text View . set Text ( recharge . get Units ( ) ) ; unit Value Text View . set Text ( String . value Of ( recharge . get Current Amount ( ) ) ) ; cost Text View . set Text ( Currency . localize ( recharge . get Current Cost ( ) , BOOL ) ) ; recharge Name . set Text ( recharge . get Title ( ) ) ; confirmation Text View . set Text ( STRING + recharge . get Current Amount ( ) + STRING + recharge . get Units ( ) + STRING ) ; if ( recharge . get Current Amount ( ) == recharge . get Initial Amount ( ) ) { down Arrow . set Visibility ( View . INVISIBLE ) ; } else { down Arrow . set Visibility ( View . VISIBLE ) ; } }
@ Override public void on Incoming Chat Request ( Incoming Chat Request Event event ) throws Exception { Receive Chat chat = event . accept ( ) ; String line ; while ( ( line = chat . read Line ( ) ) != null ) if ( line . equals Ignore Case ( STRING ) ) { chat . close ( ) ; break ; } else { int line Length = line . length ( ) ; chat . send Line ( STRING + line + STRING + line Length + STRING ) ; } }
@ Override public void on Incoming Chat Request ( Incoming Chat Request Event event ) throws Exception { Receive Chat chat = event . accept ( ) ; String line ; while ( ( line = chat . read Line ( ) ) != null ) if ( line . equals Ignore Case ( STRING ) ) { chat . close ( ) ; break ; } else { int line Length = line . length ( ) ; chat . send Line ( STRING + line + STRING + line Length + STRING ) ; } }
@ Override public void on Incoming Chat Request ( Incoming Chat Request Event event ) throws Exception { Receive Chat chat = event . accept ( ) ; String line ; while ( ( line = chat . read Line ( ) ) != null ) if ( line . equals Ignore Case ( STRING ) ) { chat . close ( ) ; break ; } else { int line Length = line . length ( ) ; chat . send Line ( STRING + line + STRING + line Length + STRING ) ; } }
@ Override public void on Incoming Chat Request ( Incoming Chat Request Event event ) throws Exception { Receive Chat chat = event . accept ( ) ; String line ; while ( ( line = chat . read Line ( ) ) != null ) if ( line . equals Ignore Case ( STRING ) ) { chat . close ( ) ; break ; } else { int line Length = line . length ( ) ; chat . send Line ( STRING + line + STRING + line Length + STRING ) ; } }
@ Override public void on Incoming Chat Request ( Incoming Chat Request Event event ) throws Exception { Receive Chat chat = event . accept ( ) ; String line ; while ( ( line = chat . read Line ( ) ) != null ) if ( line . equals Ignore Case ( STRING ) ) { chat . close ( ) ; break ; } else { int line Length = line . length ( ) ; chat . send Line ( STRING + line + STRING + line Length + STRING ) ; } }
@ Override public void on Incoming Chat Request ( Incoming Chat Request Event event ) throws Exception { Receive Chat chat = event . accept ( ) ; String line ; while ( ( line = chat . read Line ( ) ) != null ) if ( line . equals Ignore Case ( STRING ) ) { chat . close ( ) ; break ; } else { int line Length = line . length ( ) ; chat . send Line ( STRING + line + STRING + line Length + STRING ) ; } }
@ Override public void on Incoming Chat Request ( Incoming Chat Request Event event ) throws Exception { Receive Chat chat = event . accept ( ) ; String line ; while ( ( line = chat . read Line ( ) ) != null ) if ( line . equals Ignore Case ( STRING ) ) { chat . close ( ) ; break ; } else { int line Length = line . length ( ) ; chat . send Line ( STRING + line + STRING + line Length + STRING ) ; } }
public static boolean check In Round ( float sx , float sy , float r , float x , float y , float offset ) { return Math . sqrt ( ( sx - x + offset ) * ( sx - x + offset ) + ( sy - y + offset ) * ( sy - y + offset ) ) < r ; }
public static boolean check In Round ( float sx , float sy , float r , float x , float y , float offset ) { return Math . sqrt ( ( sx - x + offset ) * ( sx - x + offset ) + ( sy - y + offset ) * ( sy - y + offset ) ) < r ; }
protected void add Resource ( List defaults , String bundle Name ) { Resource Bundle bundle = Resource Bundle . get Bundle ( bundle Name ) ; for ( Enumeration keys = bundle . get Keys ( ) ; keys . has More Elements ( ) ; ) { String key = ( String ) keys . next Element ( ) ; defaults . add ( key ) ; defaults . add ( bundle . get Object ( key ) ) ; } }
private static boolean intersects One Of ( final Rectangle 2 D r , final Collection < ? extends Shape > shapes ) { if ( shapes . is Empty ( ) ) { return BOOL ; } for ( final Shape item : shapes ) { if ( item . intersects ( r ) ) { return BOOL ; } } return BOOL ; }
private static boolean intersects One Of ( final Rectangle 2 D r , final Collection < ? extends Shape > shapes ) { if ( shapes . is Empty ( ) ) { return BOOL ; } for ( final Shape item : shapes ) { if ( item . intersects ( r ) ) { return BOOL ; } } return BOOL ; }
public static Script create Multi Sig Output Script ( int threshold , List < EC Key > pubkeys ) { check Argument ( threshold > NUM ) ; check Argument ( threshold <= pubkeys . size ( ) ) ; check Argument ( pubkeys . size ( ) <= NUM ) ; Script Builder builder = new Script Builder ( ) ; builder . small Num ( threshold ) ; for ( EC Key key : pubkeys ) { builder . data ( key . get Pub Key ( ) ) ; } builder . small Num ( pubkeys . size ( ) ) ; builder . op ( OP CHECKMULTISIG ) ; return builder . build ( ) ; }
public static Script create Multi Sig Output Script ( int threshold , List < EC Key > pubkeys ) { check Argument ( threshold > NUM ) ; check Argument ( threshold <= pubkeys . size ( ) ) ; check Argument ( pubkeys . size ( ) <= NUM ) ; Script Builder builder = new Script Builder ( ) ; builder . small Num ( threshold ) ; for ( EC Key key : pubkeys ) { builder . data ( key . get Pub Key ( ) ) ; } builder . small Num ( pubkeys . size ( ) ) ; builder . op ( OP CHECKMULTISIG ) ; return builder . build ( ) ; }
public static Script create Multi Sig Output Script ( int threshold , List < EC Key > pubkeys ) { check Argument ( threshold > NUM ) ; check Argument ( threshold <= pubkeys . size ( ) ) ; check Argument ( pubkeys . size ( ) <= NUM ) ; Script Builder builder = new Script Builder ( ) ; builder . small Num ( threshold ) ; for ( EC Key key : pubkeys ) { builder . data ( key . get Pub Key ( ) ) ; } builder . small Num ( pubkeys . size ( ) ) ; builder . op ( OP CHECKMULTISIG ) ; return builder . build ( ) ; }
public double distance ( Double Vector v ) { double delta X = v . x - x , delta Y = v . y - y , delta Z = v . z - z ; return Math . sqrt ( delta X * delta X + delta Y * delta Y + delta Z * delta Z ) ; }
@ Override public List < Source Record > poll ( ) throws Interrupted Exception { List < Source Record > records = new Array List < > ( ) ; Mqtt Message Processor message = m Queue . take ( ) ; log . debug ( STRING , m Mqtt Client Id , m Kafka Topic ) ; Collections . add All ( records , message . get Records ( m Kafka Topic ) ) ; return records ; }
@ Override public boolean apply Rules ( Map < URI , Map < URI , Integer > > initiators To Volumes ) { return apply Volumes To Masks Using Rules ( context . storage , context . export Group , context . masks To Update With Volumes , initiators To Volumes , context . export Mask To Policy , context . masks To Update With Initiators , context . partial Masks , context . token ) ; }
@ Override public boolean apply Rules ( Map < URI , Map < URI , Integer > > initiators To Volumes ) { return apply Volumes To Masks Using Rules ( context . storage , context . export Group , context . masks To Update With Volumes , initiators To Volumes , context . export Mask To Policy , context . masks To Update With Initiators , context . partial Masks , context . token ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
private void play Scale For Menu ( Menu menu ) { final int size = menu . size ( ) ; if ( size <= NUM ) { return ; } m Feedback Controller . play Auditory ( SCALES [ Math . min ( size - NUM , NUM ) ] ) ; }
@ Non Null static String to Hex String ( @ Nullable final byte [ ] src ) { if ( src == null ) { return STRING ; } final String Builder buffer = new String Builder ( ) ; buffer . append ( STRING ) ; boolean need Comma = BOOL ; for ( final byte src Byte : src ) { if ( need Comma ) { buffer . append ( STRING ) ; } buffer . append ( String . format ( STRING , src Byte & NUM ) ) ; need Comma = BOOL ; } buffer . append ( STRING ) ; return buffer . to String ( ) ; }
public void clear ( String class Name ) throws Remote Exception , Transaction Exception , Unusable Entry Exception { remote Space Proxy . clear ( create Template ( class Name ) , null ) ; }
public void dispose ( ) { clear Listeners ( ) ; if ( attributes != null ) { attributes . clear ( ) ; } removed ( null ) ; }
public void dispose ( ) { clear Listeners ( ) ; if ( attributes != null ) { attributes . clear ( ) ; } removed ( null ) ; }
public void dispose ( ) { clear Listeners ( ) ; if ( attributes != null ) { attributes . clear ( ) ; } removed ( null ) ; }
public UCI Best Move stop ( ) { if ( ! is Connected ( ) ) { throw new Illegal State Exception ( STRING ) ; } if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( STRING ) ; } UCI Best Move result = null ; synchronized ( stop Synch ) { if ( ! is Processing Go ( ) ) { result = last Best Move ; last Best Move = null ; } else { long total Sleep Time = NUM ; send ( STRING ) ; while ( go Runnable != null && total Sleep Time < NUM ) { try { Thread . sleep ( NUM ) ; total Sleep Time += NUM ; } catch ( Interrupted Exception ie ) { } } result = last Best Move ; last Best Move = null ; } } return result ; }
public void upload ( File file , long restart At , FTP Data Transfer Listener listener ) throws Illegal State Exception , File Not Found Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception , FTP Data Transfer Exception , FTP Aborted Exception { if ( ! file . exists ( ) ) { throw new File Not Found Exception ( file . get Absolute Path ( ) ) ; } Input Stream input Stream = null ; try { input Stream = new File Input Stream ( file ) ; } catch ( IO Exception e ) { throw new FTP Data Transfer Exception ( e ) ; } try { upload ( file . get Name ( ) , input Stream , restart At , restart At , listener ) ; } catch ( Illegal State Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( FTP Illegal Reply Exception e ) { throw e ; } catch ( FTP Exception e ) { throw e ; } catch ( FTP Data Transfer Exception e ) { throw e ; } catch ( FTP Aborted Exception e ) { throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void upload ( File file , long restart At , FTP Data Transfer Listener listener ) throws Illegal State Exception , File Not Found Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception , FTP Data Transfer Exception , FTP Aborted Exception { if ( ! file . exists ( ) ) { throw new File Not Found Exception ( file . get Absolute Path ( ) ) ; } Input Stream input Stream = null ; try { input Stream = new File Input Stream ( file ) ; } catch ( IO Exception e ) { throw new FTP Data Transfer Exception ( e ) ; } try { upload ( file . get Name ( ) , input Stream , restart At , restart At , listener ) ; } catch ( Illegal State Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( FTP Illegal Reply Exception e ) { throw e ; } catch ( FTP Exception e ) { throw e ; } catch ( FTP Data Transfer Exception e ) { throw e ; } catch ( FTP Aborted Exception e ) { throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void upload ( File file , long restart At , FTP Data Transfer Listener listener ) throws Illegal State Exception , File Not Found Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception , FTP Data Transfer Exception , FTP Aborted Exception { if ( ! file . exists ( ) ) { throw new File Not Found Exception ( file . get Absolute Path ( ) ) ; } Input Stream input Stream = null ; try { input Stream = new File Input Stream ( file ) ; } catch ( IO Exception e ) { throw new FTP Data Transfer Exception ( e ) ; } try { upload ( file . get Name ( ) , input Stream , restart At , restart At , listener ) ; } catch ( Illegal State Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( FTP Illegal Reply Exception e ) { throw e ; } catch ( FTP Exception e ) { throw e ; } catch ( FTP Data Transfer Exception e ) { throw e ; } catch ( FTP Aborted Exception e ) { throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void upload ( File file , long restart At , FTP Data Transfer Listener listener ) throws Illegal State Exception , File Not Found Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception , FTP Data Transfer Exception , FTP Aborted Exception { if ( ! file . exists ( ) ) { throw new File Not Found Exception ( file . get Absolute Path ( ) ) ; } Input Stream input Stream = null ; try { input Stream = new File Input Stream ( file ) ; } catch ( IO Exception e ) { throw new FTP Data Transfer Exception ( e ) ; } try { upload ( file . get Name ( ) , input Stream , restart At , restart At , listener ) ; } catch ( Illegal State Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( FTP Illegal Reply Exception e ) { throw e ; } catch ( FTP Exception e ) { throw e ; } catch ( FTP Data Transfer Exception e ) { throw e ; } catch ( FTP Aborted Exception e ) { throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void upload ( File file , long restart At , FTP Data Transfer Listener listener ) throws Illegal State Exception , File Not Found Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception , FTP Data Transfer Exception , FTP Aborted Exception { if ( ! file . exists ( ) ) { throw new File Not Found Exception ( file . get Absolute Path ( ) ) ; } Input Stream input Stream = null ; try { input Stream = new File Input Stream ( file ) ; } catch ( IO Exception e ) { throw new FTP Data Transfer Exception ( e ) ; } try { upload ( file . get Name ( ) , input Stream , restart At , restart At , listener ) ; } catch ( Illegal State Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( FTP Illegal Reply Exception e ) { throw e ; } catch ( FTP Exception e ) { throw e ; } catch ( FTP Data Transfer Exception e ) { throw e ; } catch ( FTP Aborted Exception e ) { throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void upload ( File file , long restart At , FTP Data Transfer Listener listener ) throws Illegal State Exception , File Not Found Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception , FTP Data Transfer Exception , FTP Aborted Exception { if ( ! file . exists ( ) ) { throw new File Not Found Exception ( file . get Absolute Path ( ) ) ; } Input Stream input Stream = null ; try { input Stream = new File Input Stream ( file ) ; } catch ( IO Exception e ) { throw new FTP Data Transfer Exception ( e ) ; } try { upload ( file . get Name ( ) , input Stream , restart At , restart At , listener ) ; } catch ( Illegal State Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( FTP Illegal Reply Exception e ) { throw e ; } catch ( FTP Exception e ) { throw e ; } catch ( FTP Data Transfer Exception e ) { throw e ; } catch ( FTP Aborted Exception e ) { throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void upload ( File file , long restart At , FTP Data Transfer Listener listener ) throws Illegal State Exception , File Not Found Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception , FTP Data Transfer Exception , FTP Aborted Exception { if ( ! file . exists ( ) ) { throw new File Not Found Exception ( file . get Absolute Path ( ) ) ; } Input Stream input Stream = null ; try { input Stream = new File Input Stream ( file ) ; } catch ( IO Exception e ) { throw new FTP Data Transfer Exception ( e ) ; } try { upload ( file . get Name ( ) , input Stream , restart At , restart At , listener ) ; } catch ( Illegal State Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( FTP Illegal Reply Exception e ) { throw e ; } catch ( FTP Exception e ) { throw e ; } catch ( FTP Data Transfer Exception e ) { throw e ; } catch ( FTP Aborted Exception e ) { throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void add Attribute ( String uri , String local Name , String raw Name , String type , String value , boolean XSL Attribute ) throws SAX Exception { if ( m elem Context . m start Tag Open ) { ensure Prefix Is Declared ( uri , raw Name ) ; add Attribute Always ( uri , local Name , raw Name , type , value , BOOL ) ; } }
public static boolean is Folder Exist ( String directory Path ) { if ( String Utils . is Blank ( directory Path ) ) { return BOOL ; } File dire = new File ( directory Path ) ; return ( dire . exists ( ) && dire . is Directory ( ) ) ; }
public static boolean is Folder Exist ( String directory Path ) { if ( String Utils . is Blank ( directory Path ) ) { return BOOL ; } File dire = new File ( directory Path ) ; return ( dire . exists ( ) && dire . is Directory ( ) ) ; }
public static boolean is File Type Supported ( int file Type ) { List providers = get Midi File Writers ( ) ; for ( int i = NUM ; i < providers . size ( ) ; i ++ ) { Midi File Writer writer = ( Midi File Writer ) providers . get ( i ) ; if ( writer . is File Type Supported ( file Type ) ) { return BOOL ; } } return BOOL ; }
public static boolean is File Type Supported ( int file Type ) { List providers = get Midi File Writers ( ) ; for ( int i = NUM ; i < providers . size ( ) ; i ++ ) { Midi File Writer writer = ( Midi File Writer ) providers . get ( i ) ; if ( writer . is File Type Supported ( file Type ) ) { return BOOL ; } } return BOOL ; }
public static < T > Set < String > convert List To String ( Collection < T > values , int max Count ) { Set < String > ret = new Hash Set < > ( ) ; if ( values == null || values . is Empty ( ) ) return ret ; String Builder sb = new String Builder ( ) ; int count = NUM ; for ( T t : values ) { sb . append ( t ) ; if ( count == max Count ) { ret . add ( sb . substring ( NUM , sb . length ( ) - NUM ) ) ; sb = new String Builder ( ) ; count = NUM ; } else { sb . append ( STRING ) ; count ++ ; } } if ( sb . length ( ) > NUM ) ret . add ( sb . substring ( NUM , sb . length ( ) - NUM ) ) ; return ret ; }
public static boolean is Drawable Image ( String image Path ) { return image Path . starts With ( STRING ) ; }
public static boolean is Drawable Image ( String image Path ) { return image Path . starts With ( STRING ) ; }
private static void accumulate ( Vector ranges , int lb , int ub ) { if ( lb <= ub ) { ranges . add ( new int [ ] { lb , ub } ) ; for ( int j = ranges . size ( ) - NUM ; j >= NUM ; -- j ) { int [ ] rangea = ( int [ ] ) ranges . element At ( j ) ; int lba = rangea [ NUM ] ; int uba = rangea [ NUM ] ; int [ ] rangeb = ( int [ ] ) ranges . element At ( j + NUM ) ; int lbb = rangeb [ NUM ] ; int ubb = rangeb [ NUM ] ; if ( Math . max ( lba , lbb ) - Math . min ( uba , ubb ) <= NUM ) { ranges . set Element At ( new int [ ] { Math . min ( lba , lbb ) , Math . max ( uba , ubb ) } , j ) ; ranges . remove ( j + NUM ) ; } else if ( lba > lbb ) { ranges . set Element At ( rangeb , j ) ; ranges . set Element At ( rangea , j + NUM ) ; } else { break ; } } } }
public void alter ( Instance instance , Transform matrix , Alpha Transform cxform , int ratio ) { Placement placement = new Placement ( instance , matrix , cxform , null , ratio , - NUM , frame Number , BOOL , BOOL , null ) ; placements . add ( placement ) ; }
public void alter ( Instance instance , Transform matrix , Alpha Transform cxform , int ratio ) { Placement placement = new Placement ( instance , matrix , cxform , null , ratio , - NUM , frame Number , BOOL , BOOL , null ) ; placements . add ( placement ) ; }
public void alter ( Instance instance , Transform matrix , Alpha Transform cxform , int ratio ) { Placement placement = new Placement ( instance , matrix , cxform , null , ratio , - NUM , frame Number , BOOL , BOOL , null ) ; placements . add ( placement ) ; }
public static String generate Native Guid ( Storage System device , String unique Id , String type ) { String type Str = STRING ; if ( OBJECT TYPE SET . contains ( type ) ) { type Str = type ; } return String . format ( STRING , device Type Map . get ( device . get System Type ( ) ) , device . get Serial Number ( ) , type Str , unique Id ) ; }
public Query Builder < C , F > return These Attributes ( Collection < Core Token Field > return Fields ) { Reject . if True ( return Fields == null || return Fields . is Empty ( ) ) ; Set < String > fields = new Hash Set < String > ( ) ; for ( Core Token Field field : return Fields ) { fields . add ( field . to String ( ) ) ; } return set Return Attributes ( fields ) ; }
public Query Builder < C , F > return These Attributes ( Collection < Core Token Field > return Fields ) { Reject . if True ( return Fields == null || return Fields . is Empty ( ) ) ; Set < String > fields = new Hash Set < String > ( ) ; for ( Core Token Field field : return Fields ) { fields . add ( field . to String ( ) ) ; } return set Return Attributes ( fields ) ; }
public String [ ] headers ( final String name ) { final Map < String , List < String > > headers = headers ( ) ; if ( headers == null || headers . is Empty ( ) ) return EMPTY STRINGS ; final List < String > values = headers . get ( name ) ; if ( values != null && ! values . is Empty ( ) ) return values . to Array ( new String [ values . size ( ) ] ) ; else return EMPTY STRINGS ; }
private Result Points And Transitions transitions Between ( Result Point from , Result Point to ) { int from X = ( int ) from . get X ( ) ; int from Y = ( int ) from . get Y ( ) ; int to X = ( int ) to . get X ( ) ; int to Y = ( int ) to . get Y ( ) ; boolean steep = Math . abs ( to Y - from Y ) > Math . abs ( to X - from X ) ; if ( steep ) { int temp = from X ; from X = from Y ; from Y = temp ; temp = to X ; to X = to Y ; to Y = temp ; } int dx = Math . abs ( to X - from X ) ; int dy = Math . abs ( to Y - from Y ) ; int error = - dx / NUM ; int ystep = from Y < to Y ? NUM : - NUM ; int xstep = from X < to X ? NUM : - NUM ; int transitions = NUM ; boolean in Black = image . get ( steep ? from Y : from X , steep ? from X : from Y ) ; for ( int x = from X , y = from Y ; x != to X ; x += xstep ) { boolean is Black = image . get ( steep ? y : x , steep ? x : y ) ; if ( is Black != in Black ) { transitions ++ ; in Black = is Black ; } error += dy ; if ( error > NUM ) { if ( y == to Y ) { break ; } y += ystep ; error -= dx ; } } return new Result Points And Transitions ( from , to , transitions ) ; }
private Result Points And Transitions transitions Between ( Result Point from , Result Point to ) { int from X = ( int ) from . get X ( ) ; int from Y = ( int ) from . get Y ( ) ; int to X = ( int ) to . get X ( ) ; int to Y = ( int ) to . get Y ( ) ; boolean steep = Math . abs ( to Y - from Y ) > Math . abs ( to X - from X ) ; if ( steep ) { int temp = from X ; from X = from Y ; from Y = temp ; temp = to X ; to X = to Y ; to Y = temp ; } int dx = Math . abs ( to X - from X ) ; int dy = Math . abs ( to Y - from Y ) ; int error = - dx / NUM ; int ystep = from Y < to Y ? NUM : - NUM ; int xstep = from X < to X ? NUM : - NUM ; int transitions = NUM ; boolean in Black = image . get ( steep ? from Y : from X , steep ? from X : from Y ) ; for ( int x = from X , y = from Y ; x != to X ; x += xstep ) { boolean is Black = image . get ( steep ? y : x , steep ? x : y ) ; if ( is Black != in Black ) { transitions ++ ; in Black = is Black ; } error += dy ; if ( error > NUM ) { if ( y == to Y ) { break ; } y += ystep ; error -= dx ; } } return new Result Points And Transitions ( from , to , transitions ) ; }
public void write Double ( double value ) throws IO Exception { check Write Primitive Types ( ) ; primitive Types . write Double ( value ) ; }
public static List < String > bytes To String List ( byte [ ] bytes ) { List < String > lines = new Array List < String > ( ) ; if ( bytes == null ) { return lines ; } Buffered Reader r = null ; try { r = new Buffered Reader ( new Input Stream Reader ( new Byte Array Input Stream ( bytes ) , STRING ) ) ; } catch ( Unsupported Encoding Exception e ) { throw new Runtime Exception ( e ) ; } try { try { for ( String line = r . read Line ( ) ; line != null ; line = r . read Line ( ) ) { lines . add ( line ) ; } } finally { r . close ( ) ; } } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } return lines ; }
public static List < String > bytes To String List ( byte [ ] bytes ) { List < String > lines = new Array List < String > ( ) ; if ( bytes == null ) { return lines ; } Buffered Reader r = null ; try { r = new Buffered Reader ( new Input Stream Reader ( new Byte Array Input Stream ( bytes ) , STRING ) ) ; } catch ( Unsupported Encoding Exception e ) { throw new Runtime Exception ( e ) ; } try { try { for ( String line = r . read Line ( ) ; line != null ; line = r . read Line ( ) ) { lines . add ( line ) ; } } finally { r . close ( ) ; } } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } return lines ; }
public static List < String > bytes To String List ( byte [ ] bytes ) { List < String > lines = new Array List < String > ( ) ; if ( bytes == null ) { return lines ; } Buffered Reader r = null ; try { r = new Buffered Reader ( new Input Stream Reader ( new Byte Array Input Stream ( bytes ) , STRING ) ) ; } catch ( Unsupported Encoding Exception e ) { throw new Runtime Exception ( e ) ; } try { try { for ( String line = r . read Line ( ) ; line != null ; line = r . read Line ( ) ) { lines . add ( line ) ; } } finally { r . close ( ) ; } } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } return lines ; }
public static List < String > bytes To String List ( byte [ ] bytes ) { List < String > lines = new Array List < String > ( ) ; if ( bytes == null ) { return lines ; } Buffered Reader r = null ; try { r = new Buffered Reader ( new Input Stream Reader ( new Byte Array Input Stream ( bytes ) , STRING ) ) ; } catch ( Unsupported Encoding Exception e ) { throw new Runtime Exception ( e ) ; } try { try { for ( String line = r . read Line ( ) ; line != null ; line = r . read Line ( ) ) { lines . add ( line ) ; } } finally { r . close ( ) ; } } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } return lines ; }
public static List < String > bytes To String List ( byte [ ] bytes ) { List < String > lines = new Array List < String > ( ) ; if ( bytes == null ) { return lines ; } Buffered Reader r = null ; try { r = new Buffered Reader ( new Input Stream Reader ( new Byte Array Input Stream ( bytes ) , STRING ) ) ; } catch ( Unsupported Encoding Exception e ) { throw new Runtime Exception ( e ) ; } try { try { for ( String line = r . read Line ( ) ; line != null ; line = r . read Line ( ) ) { lines . add ( line ) ; } } finally { r . close ( ) ; } } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } return lines ; }
public void add ( I Status status ) { Assert . is Legal ( status != null ) ; I Status [ ] result = new I Status [ children . length + NUM ] ; System . arraycopy ( children , NUM , result , NUM , children . length ) ; result [ result . length - NUM ] = status ; children = result ; int new Sev = status . get Severity ( ) ; if ( new Sev > get Severity ( ) ) { set Severity ( new Sev ) ; } }
public void add Src Class ( Soot Class clz ) { src Classes . add ( clz . get Name ( ) ) ; }
private void on HP Change ( final int amount ) { if ( User . squared Distance To ( x , y ) < HEARING DISTANCE SQ ) { if ( amount > NUM ) { add Text Indicator ( STRING + amount , Notification Type . POSITIVE ) ; } else { add Text Indicator ( String . value Of ( amount ) , Notification Type . NEGATIVE ) ; } } }
public static String reverse Url ( URL url ) { String host = url . get Host ( ) ; String file = url . get File ( ) ; String protocol = url . get Protocol ( ) ; int port = url . get Port ( ) ; String Builder buf = new String Builder ( ) ; reverse Append Splits ( host , buf ) ; buf . append ( STRING ) ; buf . append ( protocol ) ; if ( port != - NUM ) { buf . append ( STRING ) ; buf . append ( port ) ; } if ( file . length ( ) > NUM && STRING != file . char At ( NUM ) ) { buf . append ( STRING ) ; } buf . append ( file ) ; return buf . to String ( ) ; }
public static boolean is Samsung Galaxy Mini ( ) { return s Build Model . equals Ignore Case ( STRING ) ; }
public static boolean is Samsung Galaxy Mini ( ) { return s Build Model . equals Ignore Case ( STRING ) ; }
private void append To Buf ( char [ ] ch , int start , int end ) { if ( start == end ) { return ; } int needed Buf Len = pos + ( end - start ) ; if ( needed Buf Len > buf . length ) { char [ ] new Buf = new char [ needed Buf Len ] ; System . arraycopy ( buf , NUM , new Buf , NUM , pos ) ; if ( buf Holder == null ) { buf Holder = buf ; } buf = new Buf ; } System . arraycopy ( ch , start , buf , pos , end - start ) ; pos += ( end - start ) ; }
public static String html Escape ( String input ) { Param Checks . null Not Permitted ( input , STRING ) ; String Builder result = new String Builder ( ) ; int length = input . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = input . char At ( i ) ; if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else { result . append ( c ) ; } } return result . to String ( ) ; }
public static String html Escape ( String input ) { Param Checks . null Not Permitted ( input , STRING ) ; String Builder result = new String Builder ( ) ; int length = input . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = input . char At ( i ) ; if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else { result . append ( c ) ; } } return result . to String ( ) ; }
public Raw Public Key Identity ( Public Key key ) { if ( key == null ) { throw new Null Pointer Exception ( STRING ) ; } else { this . public Key = key ; create Named Information Uri ( public Key . get Encoded ( ) ) ; } }
public static String vocab String ( ) { String Writer sw = new String Writer ( Vocabulary . system Size ( ) * NUM ) ; try { system Index . save To Writer ( sw ) ; return sw . to String ( ) ; } catch ( IO Exception e ) { logger . error ( STRING ) ; } return STRING ; }
public static String random Regexpish String ( Random r ) { return random Regexpish String ( r , NUM ) ; }
public static String random Regexpish String ( Random r ) { return random Regexpish String ( r , NUM ) ; }
public static String random Regexpish String ( Random r ) { return random Regexpish String ( r , NUM ) ; }
public static String random Regexpish String ( Random r ) { return random Regexpish String ( r , NUM ) ; }
public static void copy ( File src , File dst ) throws IO Exception { if ( src . is Directory ( ) ) { ensure Directory Exists ( dst ) ; String [ ] files List = src . list ( ) ; for ( String file : files List ) { File src File = new File ( src , file ) ; File dest File = new File ( dst , file ) ; copy ( src File , dest File ) ; } } else { copy File ( src , dst ) ; } }
public Resources Poet add Integer Array ( String name , @ Not Null List < Integer > values ) { Array List < String > integers = new Array List < > ( ) ; for ( Integer value : values ) { integers . add ( String . value Of ( value ) ) ; } add Integer Array Strings ( name , integers ) ; return this ; }
public synchronized void return Buf ( byte [ ] buf ) { if ( buf == null || buf . length > m Size Limit ) { return ; } m Buffers By Last Use . add ( buf ) ; int pos = Collections . binary Search ( m Buffers By Size , buf , BUF COMPARATOR ) ; if ( pos < NUM ) { pos = - pos - NUM ; } m Buffers By Size . add ( pos , buf ) ; m Current Size += buf . length ; trim ( ) ; }
public synchronized void return Buf ( byte [ ] buf ) { if ( buf == null || buf . length > m Size Limit ) { return ; } m Buffers By Last Use . add ( buf ) ; int pos = Collections . binary Search ( m Buffers By Size , buf , BUF COMPARATOR ) ; if ( pos < NUM ) { pos = - pos - NUM ; } m Buffers By Size . add ( pos , buf ) ; m Current Size += buf . length ; trim ( ) ; }
public synchronized void return Buf ( byte [ ] buf ) { if ( buf == null || buf . length > m Size Limit ) { return ; } m Buffers By Last Use . add ( buf ) ; int pos = Collections . binary Search ( m Buffers By Size , buf , BUF COMPARATOR ) ; if ( pos < NUM ) { pos = - pos - NUM ; } m Buffers By Size . add ( pos , buf ) ; m Current Size += buf . length ; trim ( ) ; }
public void prepend ( Char Sequence s ) { text . insert ( NUM , s ) ; }
public static String to Hex ( byte [ ] data ) { try { return new String ( Hex . encode ( data ) , STRING ) ; } catch ( Unsupported Encoding Exception e ) { } return null ; }
public Feature Vector read Feature Vector ( int current Unit Index , Data Input input ) throws IO Exception { byte [ ] bytes = new byte [ num Byte Features ] ; input . read Fully ( bytes ) ; short [ ] shorts = new short [ num Short Features ] ; for ( int i = NUM ; i < shorts . length ; i ++ ) { shorts [ i ] = input . read Short ( ) ; } float [ ] floats = new float [ num Continuous Features ] ; for ( int i = NUM ; i < floats . length ; i ++ ) { floats [ i ] = input . read Float ( ) ; } return new Feature Vector ( bytes , shorts , floats , current Unit Index ) ; }
public Feature Vector read Feature Vector ( int current Unit Index , Data Input input ) throws IO Exception { byte [ ] bytes = new byte [ num Byte Features ] ; input . read Fully ( bytes ) ; short [ ] shorts = new short [ num Short Features ] ; for ( int i = NUM ; i < shorts . length ; i ++ ) { shorts [ i ] = input . read Short ( ) ; } float [ ] floats = new float [ num Continuous Features ] ; for ( int i = NUM ; i < floats . length ; i ++ ) { floats [ i ] = input . read Float ( ) ; } return new Feature Vector ( bytes , shorts , floats , current Unit Index ) ; }
public static boolean symbol Needs Quoting ( Char Sequence symbol , boolean quote Operators ) { int length = symbol . length ( ) ; if ( length == NUM ) { throw new Empty Symbol Exception ( ) ; } if ( ! is Identifier Keyword ( symbol ) ) { char c = symbol . char At ( NUM ) ; if ( ! quote Operators && is Operator Part ( c ) ) { for ( int ii = NUM ; ii < length ; ii ++ ) { c = symbol . char At ( ii ) ; if ( ! is Operator Part ( c ) ) { return BOOL ; } } return BOOL ; } else if ( is Identifier Start ( c ) ) { for ( int ii = NUM ; ii < length ; ii ++ ) { c = symbol . char At ( ii ) ; if ( ( c == STRING || c < NUM || c > NUM ) || ! is Identifier Part ( c ) ) { return BOOL ; } } return BOOL ; } } return BOOL ; }
public static boolean symbol Needs Quoting ( Char Sequence symbol , boolean quote Operators ) { int length = symbol . length ( ) ; if ( length == NUM ) { throw new Empty Symbol Exception ( ) ; } if ( ! is Identifier Keyword ( symbol ) ) { char c = symbol . char At ( NUM ) ; if ( ! quote Operators && is Operator Part ( c ) ) { for ( int ii = NUM ; ii < length ; ii ++ ) { c = symbol . char At ( ii ) ; if ( ! is Operator Part ( c ) ) { return BOOL ; } } return BOOL ; } else if ( is Identifier Start ( c ) ) { for ( int ii = NUM ; ii < length ; ii ++ ) { c = symbol . char At ( ii ) ; if ( ( c == STRING || c < NUM || c > NUM ) || ! is Identifier Part ( c ) ) { return BOOL ; } } return BOOL ; } } return BOOL ; }
public void send Bye Packet ( ) { Vector < Rtcp Sdes Packet > repvec = makereports ( ) ; Rtcp Packet [ ] packets = new Rtcp Packet [ repvec . size ( ) + NUM ] ; repvec . copy Into ( packets ) ; int ssrc [ ] = { rtcp Session . SSRC } ; Rtcp Bye Packet rtcpbyepacket = new Rtcp Bye Packet ( ssrc , null ) ; packets [ packets . length - NUM ] = rtcpbyepacket ; Rtcp Compound Packet cp = new Rtcp Compound Packet ( packets ) ; rtcp Session . get My Source ( ) . active Sender = BOOL ; transmit ( cp ) ; }
public void modify Leaf Block ( Block Id blk ) { lock Tbl . x Lock ( blk , tx Num ) ; writen Index Blks . add ( blk ) ; }
public boolean is Same As ( Product Version other ) { return version . compare To ( other . version ) == NUM && revision . equals ( other . revision ) ; }
public static boolean is Empty ( Automaton a ) { if ( a . get Num States ( ) == NUM ) { return BOOL ; } if ( a . is Accept ( NUM ) == BOOL && a . get Num Transitions ( NUM ) == NUM ) { return BOOL ; } if ( a . is Accept ( NUM ) == BOOL ) { return BOOL ; } Linked List < Integer > work List = new Linked List < > ( ) ; Bit Set seen = new Bit Set ( a . get Num States ( ) ) ; work List . add ( NUM ) ; seen . set ( NUM ) ; Transition t = new Transition ( ) ; while ( work List . is Empty ( ) == BOOL ) { int state = work List . remove First ( ) ; if ( a . is Accept ( state ) ) { return BOOL ; } int count = a . init Transition ( state , t ) ; for ( int i = NUM ; i < count ; i ++ ) { a . get Next Transition ( t ) ; if ( seen . get ( t . dest ) == BOOL ) { work List . add ( t . dest ) ; seen . set ( t . dest ) ; } } } return BOOL ; }
public static boolean is Empty ( Automaton a ) { if ( a . get Num States ( ) == NUM ) { return BOOL ; } if ( a . is Accept ( NUM ) == BOOL && a . get Num Transitions ( NUM ) == NUM ) { return BOOL ; } if ( a . is Accept ( NUM ) == BOOL ) { return BOOL ; } Linked List < Integer > work List = new Linked List < > ( ) ; Bit Set seen = new Bit Set ( a . get Num States ( ) ) ; work List . add ( NUM ) ; seen . set ( NUM ) ; Transition t = new Transition ( ) ; while ( work List . is Empty ( ) == BOOL ) { int state = work List . remove First ( ) ; if ( a . is Accept ( state ) ) { return BOOL ; } int count = a . init Transition ( state , t ) ; for ( int i = NUM ; i < count ; i ++ ) { a . get Next Transition ( t ) ; if ( seen . get ( t . dest ) == BOOL ) { work List . add ( t . dest ) ; seen . set ( t . dest ) ; } } } return BOOL ; }
public static String if Null Or Empty ( final String original , final String default String ) { Reject . if Null ( default String , STRING ) ; return ( original == null || original . is Empty ( ) ) ? default String : original ; }
private Workflow . Method create Attach Mirror Method ( URI vplex URI , URI vplex Volume URI , URI mirror Volume URI , URI cg URI , String detach Step Id ) { return new Workflow . Method ( ATTACH MIRROR METHOD NAME , vplex URI , vplex Volume URI , mirror Volume URI , cg URI , detach Step Id ) ; }
private Workflow . Method create Attach Mirror Method ( URI vplex URI , URI vplex Volume URI , URI mirror Volume URI , URI cg URI , String detach Step Id ) { return new Workflow . Method ( ATTACH MIRROR METHOD NAME , vplex URI , vplex Volume URI , mirror Volume URI , cg URI , detach Step Id ) ; }
public static final int binary Search ( Object [ ] a , Object key , Comparator cp ) { int x1 = NUM ; int x2 = a . length ; int i = x2 / NUM , c ; while ( x1 < x2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == NUM ) { return i ; } else if ( c < NUM ) { x1 = i + NUM ; } else { x2 = i ; } i = x1 + ( x2 - x1 ) / NUM ; } return - NUM * ( i + NUM ) ; }
public static final int binary Search ( Object [ ] a , Object key , Comparator cp ) { int x1 = NUM ; int x2 = a . length ; int i = x2 / NUM , c ; while ( x1 < x2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == NUM ) { return i ; } else if ( c < NUM ) { x1 = i + NUM ; } else { x2 = i ; } i = x1 + ( x2 - x1 ) / NUM ; } return - NUM * ( i + NUM ) ; }
public List < Storage File > create Storage Files From Entities ( Collection < Storage File Entity > storage File Entities ) { List < Storage File > storage Files = new Array List < > ( ) ; for ( Storage File Entity storage File Entity : storage File Entities ) { storage Files . add ( create Storage File From Entity ( storage File Entity ) ) ; } return storage Files ; }
private void convergence Step ( final Vec [ ] xit , int i , final boolean [ ] converged , final int [ ] designations , final Vec scratch , final Kernel Function k ) { double denom = NUM ; Vec x Cur = xit [ i ] ; List < ? extends Vec Paired < Vec Paired < Vec , Integer > , Double > > contrib = mkde . get Nearby Raw ( x Cur ) ; if ( contrib . size ( ) == NUM ) { converged [ i ] = BOOL ; designations [ i ] = - NUM ; } else { scratch . zero Out ( ) ; for ( Vec Paired < Vec Paired < Vec , Integer > , Double > v : contrib ) { double g = - k . k Prime ( v . get Pair ( ) ) ; denom += g ; scratch . mutable Add ( g , v ) ; } scratch . mutable Divide ( denom ) ; if ( Math . abs ( scratch . p Norm Dist ( NUM , x Cur ) ) < NUM ) converged [ i ] = BOOL ; scratch . copy To ( x Cur ) ; } }
private void convergence Step ( final Vec [ ] xit , int i , final boolean [ ] converged , final int [ ] designations , final Vec scratch , final Kernel Function k ) { double denom = NUM ; Vec x Cur = xit [ i ] ; List < ? extends Vec Paired < Vec Paired < Vec , Integer > , Double > > contrib = mkde . get Nearby Raw ( x Cur ) ; if ( contrib . size ( ) == NUM ) { converged [ i ] = BOOL ; designations [ i ] = - NUM ; } else { scratch . zero Out ( ) ; for ( Vec Paired < Vec Paired < Vec , Integer > , Double > v : contrib ) { double g = - k . k Prime ( v . get Pair ( ) ) ; denom += g ; scratch . mutable Add ( g , v ) ; } scratch . mutable Divide ( denom ) ; if ( Math . abs ( scratch . p Norm Dist ( NUM , x Cur ) ) < NUM ) converged [ i ] = BOOL ; scratch . copy To ( x Cur ) ; } }
private void convergence Step ( final Vec [ ] xit , int i , final boolean [ ] converged , final int [ ] designations , final Vec scratch , final Kernel Function k ) { double denom = NUM ; Vec x Cur = xit [ i ] ; List < ? extends Vec Paired < Vec Paired < Vec , Integer > , Double > > contrib = mkde . get Nearby Raw ( x Cur ) ; if ( contrib . size ( ) == NUM ) { converged [ i ] = BOOL ; designations [ i ] = - NUM ; } else { scratch . zero Out ( ) ; for ( Vec Paired < Vec Paired < Vec , Integer > , Double > v : contrib ) { double g = - k . k Prime ( v . get Pair ( ) ) ; denom += g ; scratch . mutable Add ( g , v ) ; } scratch . mutable Divide ( denom ) ; if ( Math . abs ( scratch . p Norm Dist ( NUM , x Cur ) ) < NUM ) converged [ i ] = BOOL ; scratch . copy To ( x Cur ) ; } }
private void convergence Step ( final Vec [ ] xit , int i , final boolean [ ] converged , final int [ ] designations , final Vec scratch , final Kernel Function k ) { double denom = NUM ; Vec x Cur = xit [ i ] ; List < ? extends Vec Paired < Vec Paired < Vec , Integer > , Double > > contrib = mkde . get Nearby Raw ( x Cur ) ; if ( contrib . size ( ) == NUM ) { converged [ i ] = BOOL ; designations [ i ] = - NUM ; } else { scratch . zero Out ( ) ; for ( Vec Paired < Vec Paired < Vec , Integer > , Double > v : contrib ) { double g = - k . k Prime ( v . get Pair ( ) ) ; denom += g ; scratch . mutable Add ( g , v ) ; } scratch . mutable Divide ( denom ) ; if ( Math . abs ( scratch . p Norm Dist ( NUM , x Cur ) ) < NUM ) converged [ i ] = BOOL ; scratch . copy To ( x Cur ) ; } }
@ Override public void write ( byte [ ] buffer , int offset , int length ) { try { Output Stream os = os ; if ( os != null ) { os . write ( buffer , offset , length ) ; } } catch ( Exception e ) { log . log ( Level . FINER , e . to String ( ) , e ) ; } }
public void add Collector ( Collector collector ) { collectors . add ( collector ) ; }
public void add Collector ( Collector collector ) { collectors . add ( collector ) ; }
public void insert ( final Object e Key , final Object element , final int position ) { element Order . add ( position , e Key ) ; elements . put ( e Key , element ) ; }
public void insert ( final Object e Key , final Object element , final int position ) { element Order . add ( position , e Key ) ; elements . put ( e Key , element ) ; }
public static Predicate < String > grep ( final String pattern ) { Objects . require Non Null ( pattern , STRING ) ; return contains ( pattern ) ; }
public static Predicate < String > grep ( final String pattern ) { Objects . require Non Null ( pattern , STRING ) ; return contains ( pattern ) ; }
public static Predicate < String > grep ( final String pattern ) { Objects . require Non Null ( pattern , STRING ) ; return contains ( pattern ) ; }
public static Predicate < String > grep ( final String pattern ) { Objects . require Non Null ( pattern , STRING ) ; return contains ( pattern ) ; }
public Date Time Formatter Builder append ( Date Time Formatter formatter ) { Objects . require Non Null ( formatter , STRING ) ; append Internal ( formatter . to Printer Parser ( BOOL ) ) ; return this ; }
public Date Time Formatter Builder append ( Date Time Formatter formatter ) { Objects . require Non Null ( formatter , STRING ) ; append Internal ( formatter . to Printer Parser ( BOOL ) ) ; return this ; }
public final < U > Parallel Flux < U > map ( Function < ? super T , ? extends U > mapper ) { Objects . require Non Null ( mapper , STRING ) ; return on Assembly ( new Parallel Unordered Map < > ( this , mapper ) ) ; }
public boolean is In Net ( String host , String pattern , String mask ) { host = dns Resolve ( host ) ; if ( host == null || host . length ( ) == NUM ) { return BOOL ; } long lhost = parse Ip Address To Long ( host ) ; long lpattern = parse Ip Address To Long ( pattern ) ; long lmask = parse Ip Address To Long ( mask ) ; return ( lhost & lmask ) == lpattern ; }
public boolean is In Net ( String host , String pattern , String mask ) { host = dns Resolve ( host ) ; if ( host == null || host . length ( ) == NUM ) { return BOOL ; } long lhost = parse Ip Address To Long ( host ) ; long lpattern = parse Ip Address To Long ( pattern ) ; long lmask = parse Ip Address To Long ( mask ) ; return ( lhost & lmask ) == lpattern ; }
public boolean is In Net ( String host , String pattern , String mask ) { host = dns Resolve ( host ) ; if ( host == null || host . length ( ) == NUM ) { return BOOL ; } long lhost = parse Ip Address To Long ( host ) ; long lpattern = parse Ip Address To Long ( pattern ) ; long lmask = parse Ip Address To Long ( mask ) ; return ( lhost & lmask ) == lpattern ; }
public static void UF 1 ( double [ ] x , double [ ] f , int nx ) { int count 1 = NUM ; int count 2 = NUM ; double sum 1 = NUM ; double sum 2 = NUM ; double yj ; for ( int j = NUM ; j <= nx ; j ++ ) { yj = x [ j - NUM ] - Math . sin ( NUM * PI * x [ NUM ] + j * PI / nx ) ; yj = yj * yj ; if ( j % NUM == NUM ) { sum 2 += yj ; count 2 ++ ; } else { sum 1 += yj ; count 1 ++ ; } } f [ NUM ] = x [ NUM ] + NUM * sum 1 / ( double ) count 1 ; f [ NUM ] = NUM - Math . sqrt ( x [ NUM ] ) + NUM * sum 2 / ( double ) count 2 ; }
private void check Points ( Collection < Cache . Entry < Integer , Enemy Camp > > res , String ... points ) { Set < String > set = new Hash Set < > ( Arrays . as List ( points ) ) ; assert Equals ( set . size ( ) , res . size ( ) ) ; for ( Cache . Entry < Integer , Enemy Camp > e : res ) assert True ( set . remove ( e . get Value ( ) . name ) ) ; }
private void check Points ( Collection < Cache . Entry < Integer , Enemy Camp > > res , String ... points ) { Set < String > set = new Hash Set < > ( Arrays . as List ( points ) ) ; assert Equals ( set . size ( ) , res . size ( ) ) ; for ( Cache . Entry < Integer , Enemy Camp > e : res ) assert True ( set . remove ( e . get Value ( ) . name ) ) ; }
public void remove ( final DL Item item ) { check Widget ( ) ; if ( item == null ) { SWT . error ( SWT . ERROR NULL ARGUMENT ) ; } if ( ! items . contains ( item ) ) { SWT . error ( SWT . ERROR INVALID ARGUMENT ) ; } items . remove ( item ) ; redraw Tables ( ) ; }
@ Override public String to String ( ) { String Builder result = new String Builder ( limit - position ) ; for ( int i = position ; i < limit ; i ++ ) { result . append ( get ( i ) ) ; } return result . to String ( ) ; }
@ Override public String to String ( ) { String Builder result = new String Builder ( limit - position ) ; for ( int i = position ; i < limit ; i ++ ) { result . append ( get ( i ) ) ; } return result . to String ( ) ; }
public void connection Lost ( java . lang . Throwable cause ) { int rc = - NUM ; led . set Amber ( ) ; led . set Flash ( ) ; set Title Text ( STRING ) ; synchronized ( this ) { write Logln ( STRING + mqtt . get Server URI ( ) ) ; } try { while ( ( rc == - NUM ) && connected ) { try { synchronized ( conn Lost Wait ) { conn Lost Wait . wait ( NUM ) ; } } catch ( Interrupted Exception iex ) { } synchronized ( this ) { if ( connected ) { write Log ( STRING ) ; try { connect ( mqtt . get Server URI ( ) , options Comp . is Persistence Selected ( ) ) ; rc = NUM ; } catch ( Mqtt Exception mqte ) { rc = - NUM ; } if ( rc == - NUM ) { write Logln ( STRING ) ; } else { write Logln ( STRING ) ; } } } } set Title Text ( STRING ) ; } catch ( Exception ex ) { set Title Text ( STRING ) ; ex . print Stack Trace ( ) ; disconnect ( ) ; } finally { if ( led . is Flashing ( ) ) { led . set Flash ( ) ; } } if ( connected ) { led . set Green ( ) ; set Connected ( BOOL ) ; } else { led . set Red ( ) ; set Connected ( BOOL ) ; } }
public void connection Lost ( java . lang . Throwable cause ) { int rc = - NUM ; led . set Amber ( ) ; led . set Flash ( ) ; set Title Text ( STRING ) ; synchronized ( this ) { write Logln ( STRING + mqtt . get Server URI ( ) ) ; } try { while ( ( rc == - NUM ) && connected ) { try { synchronized ( conn Lost Wait ) { conn Lost Wait . wait ( NUM ) ; } } catch ( Interrupted Exception iex ) { } synchronized ( this ) { if ( connected ) { write Log ( STRING ) ; try { connect ( mqtt . get Server URI ( ) , options Comp . is Persistence Selected ( ) ) ; rc = NUM ; } catch ( Mqtt Exception mqte ) { rc = - NUM ; } if ( rc == - NUM ) { write Logln ( STRING ) ; } else { write Logln ( STRING ) ; } } } } set Title Text ( STRING ) ; } catch ( Exception ex ) { set Title Text ( STRING ) ; ex . print Stack Trace ( ) ; disconnect ( ) ; } finally { if ( led . is Flashing ( ) ) { led . set Flash ( ) ; } } if ( connected ) { led . set Green ( ) ; set Connected ( BOOL ) ; } else { led . set Red ( ) ; set Connected ( BOOL ) ; } }
public void connection Lost ( java . lang . Throwable cause ) { int rc = - NUM ; led . set Amber ( ) ; led . set Flash ( ) ; set Title Text ( STRING ) ; synchronized ( this ) { write Logln ( STRING + mqtt . get Server URI ( ) ) ; } try { while ( ( rc == - NUM ) && connected ) { try { synchronized ( conn Lost Wait ) { conn Lost Wait . wait ( NUM ) ; } } catch ( Interrupted Exception iex ) { } synchronized ( this ) { if ( connected ) { write Log ( STRING ) ; try { connect ( mqtt . get Server URI ( ) , options Comp . is Persistence Selected ( ) ) ; rc = NUM ; } catch ( Mqtt Exception mqte ) { rc = - NUM ; } if ( rc == - NUM ) { write Logln ( STRING ) ; } else { write Logln ( STRING ) ; } } } } set Title Text ( STRING ) ; } catch ( Exception ex ) { set Title Text ( STRING ) ; ex . print Stack Trace ( ) ; disconnect ( ) ; } finally { if ( led . is Flashing ( ) ) { led . set Flash ( ) ; } } if ( connected ) { led . set Green ( ) ; set Connected ( BOOL ) ; } else { led . set Red ( ) ; set Connected ( BOOL ) ; } }
public void connection Lost ( java . lang . Throwable cause ) { int rc = - NUM ; led . set Amber ( ) ; led . set Flash ( ) ; set Title Text ( STRING ) ; synchronized ( this ) { write Logln ( STRING + mqtt . get Server URI ( ) ) ; } try { while ( ( rc == - NUM ) && connected ) { try { synchronized ( conn Lost Wait ) { conn Lost Wait . wait ( NUM ) ; } } catch ( Interrupted Exception iex ) { } synchronized ( this ) { if ( connected ) { write Log ( STRING ) ; try { connect ( mqtt . get Server URI ( ) , options Comp . is Persistence Selected ( ) ) ; rc = NUM ; } catch ( Mqtt Exception mqte ) { rc = - NUM ; } if ( rc == - NUM ) { write Logln ( STRING ) ; } else { write Logln ( STRING ) ; } } } } set Title Text ( STRING ) ; } catch ( Exception ex ) { set Title Text ( STRING ) ; ex . print Stack Trace ( ) ; disconnect ( ) ; } finally { if ( led . is Flashing ( ) ) { led . set Flash ( ) ; } } if ( connected ) { led . set Green ( ) ; set Connected ( BOOL ) ; } else { led . set Red ( ) ; set Connected ( BOOL ) ; } }
public void connection Lost ( java . lang . Throwable cause ) { int rc = - NUM ; led . set Amber ( ) ; led . set Flash ( ) ; set Title Text ( STRING ) ; synchronized ( this ) { write Logln ( STRING + mqtt . get Server URI ( ) ) ; } try { while ( ( rc == - NUM ) && connected ) { try { synchronized ( conn Lost Wait ) { conn Lost Wait . wait ( NUM ) ; } } catch ( Interrupted Exception iex ) { } synchronized ( this ) { if ( connected ) { write Log ( STRING ) ; try { connect ( mqtt . get Server URI ( ) , options Comp . is Persistence Selected ( ) ) ; rc = NUM ; } catch ( Mqtt Exception mqte ) { rc = - NUM ; } if ( rc == - NUM ) { write Logln ( STRING ) ; } else { write Logln ( STRING ) ; } } } } set Title Text ( STRING ) ; } catch ( Exception ex ) { set Title Text ( STRING ) ; ex . print Stack Trace ( ) ; disconnect ( ) ; } finally { if ( led . is Flashing ( ) ) { led . set Flash ( ) ; } } if ( connected ) { led . set Green ( ) ; set Connected ( BOOL ) ; } else { led . set Red ( ) ; set Connected ( BOOL ) ; } }
public static void write Image To Ppm ( int [ ] [ ] image , String ppm File Name ) throws IO Exception { try ( Buffered Writer ppm Out = new Buffered Writer ( new File Writer ( ppm File Name ) ) ) { int rows = image . length ; int cols = image [ NUM ] . length ; ppm Out . write ( STRING ) ; ppm Out . write ( STRING + rows + STRING + cols + STRING ) ; for ( int [ ] an Image : image ) { String Builder s = new String Builder ( ) ; for ( int j = NUM ; j < cols ; j ++ ) { s . append ( an Image [ j ] + STRING + an Image [ j ] + STRING + an Image [ j ] + STRING ) ; } ppm Out . write ( s . to String ( ) ) ; } } }
public void remove ( Request Filter filter ) { filters . remove ( filter ) ; }
public void test Case 3 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = - NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public void configure Local Services ( ) { client Memo . set Ln Traffic Controller ( this ) ; client Memo . configure Command Station ( Ln Command Station Type . COMMAND STATION DCS 100 , BOOL , BOOL ) ; client Memo . configure Managers ( ) ; }
public static Streamable < Integer > from Int Stream ( final Int Stream stream ) { Objects . require Non Null ( stream ) ; return from Stream ( Reactive Seq . from Int Stream ( stream ) ) ; }
public void on New Data ( byte [ ] data ) ;
public String add Import ( String namespace ) { imports . add ( namespace ) ; return STRING ; }
public static boolean do Check Point ( ) { if ( force Chkpt ) { force Chkpt = BOOL ; return BOOL ; } if ( chkpt Duration == NUM ) { return BOOL ; } long now = System . current Time Millis ( ) ; if ( now - last Chkpt >= TLC Globals . chkpt Duration ) { last Chkpt = now ; return BOOL ; } return BOOL ; }
protected final void switch State ( final Transaction State new State ) throws SQL Exception { synchronized ( get Synchronization Object ( ) ) { final Transaction State current State = state ; if ( current State == new State ) return ; if ( current State . is Valid Transition ( new State ) ) { state = new State ; transaction Listener Dispatcher . transaction State Changed ( this , new State , current State ) ; } else { throw new SQL Exception ( String . format ( STRING , new State , current State ) ) ; } } }
protected final void switch State ( final Transaction State new State ) throws SQL Exception { synchronized ( get Synchronization Object ( ) ) { final Transaction State current State = state ; if ( current State == new State ) return ; if ( current State . is Valid Transition ( new State ) ) { state = new State ; transaction Listener Dispatcher . transaction State Changed ( this , new State , current State ) ; } else { throw new SQL Exception ( String . format ( STRING , new State , current State ) ) ; } } }
public void clear ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { for ( Node < E > f = first ; f != null ; ) { f . item = null ; Node < E > n = f . next ; f . prev = null ; f . next = null ; f = n ; } first = last = null ; count = NUM ; not Full . signal All ( ) ; } finally { lock . unlock ( ) ; } }
public void clear ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { for ( Node < E > f = first ; f != null ; ) { f . item = null ; Node < E > n = f . next ; f . prev = null ; f . next = null ; f = n ; } first = last = null ; count = NUM ; not Full . signal All ( ) ; } finally { lock . unlock ( ) ; } }
@ Override public boolean accept ( File file ) { String name = file . get Name ( ) ; for ( String wildcard : wildcards ) { if ( Filename Utils . wildcard Match ( name , wildcard , case Sensitivity ) ) { return BOOL ; } } return BOOL ; }
@ Override public boolean accept ( File file ) { String name = file . get Name ( ) ; for ( String wildcard : wildcards ) { if ( Filename Utils . wildcard Match ( name , wildcard , case Sensitivity ) ) { return BOOL ; } } return BOOL ; }
public void query Sorted ( String type , int index , boolean ascending , int page , int limit , int visibility Scope , Cloud Response < Cloud Object [ ] > response ) { try { query Impl ( type , null , NUM , page , limit , visibility Scope , NUM , index , ascending , BOOL , BOOL , response ) ; } catch ( Cloud Exception e ) { response . on Error ( e ) ; } }
public void save Pois From Assets ( ) { List < Poi > pois = poi Asset Loader . load Pois From Assets ( ) ; Timber . d ( STRING , pois . size ( ) ) ; for ( Poi poi : pois ) { Timber . d ( STRING , poi ) ; save Poi ( poi ) ; Timber . d ( STRING ) ; } }
public static int write String ( Data Output out , String s ) throws IO Exception { Byte Buffer bytes = encode ( s ) ; int length = bytes . limit ( ) ; Writable Utils . write V Int ( out , length ) ; out . write ( bytes . array ( ) , NUM , length ) ; return length ; }
Builder add Lenient ( String line ) { int index = line . index Of ( STRING , NUM ) ; if ( index != - NUM ) { return add Lenient ( line . substring ( NUM , index ) , line . substring ( index + NUM ) ) ; } else if ( line . starts With ( STRING ) ) { return add Lenient ( STRING , line . substring ( NUM ) ) ; } else { return add Lenient ( STRING , line ) ; } }
Builder add Lenient ( String line ) { int index = line . index Of ( STRING , NUM ) ; if ( index != - NUM ) { return add Lenient ( line . substring ( NUM , index ) , line . substring ( index + NUM ) ) ; } else if ( line . starts With ( STRING ) ) { return add Lenient ( STRING , line . substring ( NUM ) ) ; } else { return add Lenient ( STRING , line ) ; } }
public static void prepend Resource Source ( Resource Source source ) { ALL RESOURCE SOURCES . add First ( source ) ; }
public static void prepend Resource Source ( Resource Source source ) { ALL RESOURCE SOURCES . add First ( source ) ; }
@ Override public String generate Device Specific Export Mask Add Initiators Workflow ( Workflow workflow , String zoning Group Id , Storage System storage , Export Group export Group , Export Mask mask , List < URI > volumes , List < URI > new Initiators , String token ) throws Exception { Set < URI > volume UR Is = new Hash Set < URI > ( ) ; if ( volumes != null ) { volume UR Is . add All ( volumes ) ; } return generate Export Mask Add Initiators Workflow ( workflow , null , storage , export Group , mask , new Initiators , volume UR Is , token ) ; }
@ Override public String generate Device Specific Export Mask Add Initiators Workflow ( Workflow workflow , String zoning Group Id , Storage System storage , Export Group export Group , Export Mask mask , List < URI > volumes , List < URI > new Initiators , String token ) throws Exception { Set < URI > volume UR Is = new Hash Set < URI > ( ) ; if ( volumes != null ) { volume UR Is . add All ( volumes ) ; } return generate Export Mask Add Initiators Workflow ( workflow , null , storage , export Group , mask , new Initiators , volume UR Is , token ) ; }
public void run ( ) { while ( BOOL ) { Runnable r = null ; synchronized ( queue ) { while ( queue . is Empty ( ) ) { try { queue . wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { e . print Stack Trace ( ) ; } } r = queue . remove ( queue . size ( ) - NUM ) ; } try { r . run ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } } }
public void run ( ) { while ( BOOL ) { Runnable r = null ; synchronized ( queue ) { while ( queue . is Empty ( ) ) { try { queue . wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { e . print Stack Trace ( ) ; } } r = queue . remove ( queue . size ( ) - NUM ) ; } try { r . run ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } } }
public void run ( ) { while ( BOOL ) { Runnable r = null ; synchronized ( queue ) { while ( queue . is Empty ( ) ) { try { queue . wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { e . print Stack Trace ( ) ; } } r = queue . remove ( queue . size ( ) - NUM ) ; } try { r . run ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } } }
public void run ( ) { while ( BOOL ) { Runnable r = null ; synchronized ( queue ) { while ( queue . is Empty ( ) ) { try { queue . wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { e . print Stack Trace ( ) ; } } r = queue . remove ( queue . size ( ) - NUM ) ; } try { r . run ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } } }
public void run ( ) { while ( BOOL ) { Runnable r = null ; synchronized ( queue ) { while ( queue . is Empty ( ) ) { try { queue . wait ( ) ; } catch ( java . lang . Interrupted Exception e ) { e . print Stack Trace ( ) ; } } r = queue . remove ( queue . size ( ) - NUM ) ; } try { r . run ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } } }
@ Override public boolean has Antds ( ) { if ( m Antds == null ) { return BOOL ; } else { return ( m Antds . size ( ) > NUM ) ; } }
private Object handle Direct Invocation ( final Method invoked Method , final Object [ ] args ) throws Throwable { return invoked Method . invoke ( user Impl , args ) ; }
private Object handle Direct Invocation ( final Method invoked Method , final Object [ ] args ) throws Throwable { return invoked Method . invoke ( user Impl , args ) ; }
private Object handle Direct Invocation ( final Method invoked Method , final Object [ ] args ) throws Throwable { return invoked Method . invoke ( user Impl , args ) ; }
private static void add Horizontal Small Spring ( Path 2 D . Float path , int y0 , int x1 , int x2 ) { int spring Height = NUM ; int spring Width = NUM ; int distance = Math . abs ( x2 - x1 ) ; int num Springs = ( distance / ( spring Height ) ) ; int left Over = ( distance - ( num Springs * spring Height ) ) / NUM ; path . line To ( x1 , y0 ) ; path . line To ( x1 - left Over , y0 - left Over ) ; int count = NUM ; if ( x1 > x2 ) { for ( int x = x1 - left Over ; x > x2 + left Over ; x -= spring Height ) { int y = ( count % NUM == NUM ) ? y0 - spring Width : y0 + spring Width ; path . line To ( x , y ) ; count ++ ; } } else { for ( int x = x1 + left Over ; x < x2 - left Over ; x += spring Height ) { int y = ( count % NUM == NUM ) ? y0 - spring Width : y0 + spring Width ; path . line To ( x , y ) ; count ++ ; } } path . line To ( x2 + left Over , y0 ) ; path . line To ( x2 , y0 ) ; }
private static void add Horizontal Small Spring ( Path 2 D . Float path , int y0 , int x1 , int x2 ) { int spring Height = NUM ; int spring Width = NUM ; int distance = Math . abs ( x2 - x1 ) ; int num Springs = ( distance / ( spring Height ) ) ; int left Over = ( distance - ( num Springs * spring Height ) ) / NUM ; path . line To ( x1 , y0 ) ; path . line To ( x1 - left Over , y0 - left Over ) ; int count = NUM ; if ( x1 > x2 ) { for ( int x = x1 - left Over ; x > x2 + left Over ; x -= spring Height ) { int y = ( count % NUM == NUM ) ? y0 - spring Width : y0 + spring Width ; path . line To ( x , y ) ; count ++ ; } } else { for ( int x = x1 + left Over ; x < x2 - left Over ; x += spring Height ) { int y = ( count % NUM == NUM ) ? y0 - spring Width : y0 + spring Width ; path . line To ( x , y ) ; count ++ ; } } path . line To ( x2 + left Over , y0 ) ; path . line To ( x2 , y0 ) ; }
private static void store As Type With Signatures Import ( String str Type To Import , @ Nullable Function obj Scope , Php Index obj Index , Hash Set < String > obj Types Set ) { if ( str Type To Import . contains ( STRING ) ) { for ( String str One Type : str Type To Import . split ( STRING ) ) { store As Type With Signatures Import ( Types . get Type ( str One Type ) , obj Scope , obj Index , obj Types Set ) ; } return ; } if ( String Util . is Empty ( str Type To Import ) || str Type To Import . equals ( STRING ) ) { return ; } if ( str Type To Import . contains ( STRING ) ) { Type From Signature Resolving Util . resolve Signature ( str Type To Import , obj Scope , obj Index , obj Types Set ) ; return ; } obj Types Set . add ( Types . get Type ( str Type To Import ) ) ; }
public void fill ( Shape s ) { m Graphics . fill ( s ) ; }
public void fill ( Shape s ) { m Graphics . fill ( s ) ; }
public static Map < String , String > parse Named Parameters ( String tag Value ) { Map < String , String > param Map = new Linked Hash Map < String , String > ( ) ; Stream Tokenizer tokenizer = make Tokenizer ( tag Value ) ; try { while ( tokenizer . next Token ( ) == Stream Tokenizer . TT WORD ) { String key = tokenizer . sval ; if ( tokenizer . next Token ( ) != STRING ) { break ; } switch ( tokenizer . next Token ( ) ) { case Stream Tokenizer . TT WORD : case STRING : case STRING : param Map . put ( key , tokenizer . sval ) ; default : break ; } } } catch ( IO Exception e ) { } return param Map ; }
public D View Asn 1 Dump ( J Dialog parent , X509 CRL crl ) throws Asn 1 Exception , IO Exception { super ( res . get String ( STRING ) ) ; this . crl = crl ; init Components ( ) ; }
public D View Asn 1 Dump ( J Dialog parent , X509 CRL crl ) throws Asn 1 Exception , IO Exception { super ( res . get String ( STRING ) ) ; this . crl = crl ; init Components ( ) ; }
public D View Asn 1 Dump ( J Dialog parent , X509 CRL crl ) throws Asn 1 Exception , IO Exception { super ( res . get String ( STRING ) ) ; this . crl = crl ; init Components ( ) ; }
public static Client Exception adapt Input Exception ( final Throwable cause ) { return new Client Exception ( Return Code . ERROR USER DATA , ERR CONSOLE INPUT ERROR . get ( cause . get Message ( ) ) , cause ) ; }
public static int [ ] random Permutation ( final int [ ] out , Random random ) { for ( int i = out . length - NUM ; i > NUM ; i -- ) { int ri = random . next Int ( i + NUM ) ; int tmp = out [ ri ] ; out [ ri ] = out [ i ] ; out [ i ] = tmp ; } return out ; }
static Uri create Rcs Contact If Needed ( Context context , Contact Id contact Id ) throws Remote Exception , Operation Application Exception { int phone Id = get Contact Id Of Address Book ( context , contact Id ) ; if ( phone Id != INVALID CONTACT ID ) { return Content Uris . with Appended Id ( Contacts Contract . Contacts . CONTENT URI , phone Id ) ; } Content Values values = new Content Values ( ) ; values . put Null ( Contacts Contract . Contacts . DISPLAY NAME ) ; values . put ( Phone . NUMBER , contact Id . to String ( ) ) ; values . put ( Phone . TYPE , Phone . TYPE MOBILE ) ; return create Contact ( context , values ) ; }
static Uri create Rcs Contact If Needed ( Context context , Contact Id contact Id ) throws Remote Exception , Operation Application Exception { int phone Id = get Contact Id Of Address Book ( context , contact Id ) ; if ( phone Id != INVALID CONTACT ID ) { return Content Uris . with Appended Id ( Contacts Contract . Contacts . CONTENT URI , phone Id ) ; } Content Values values = new Content Values ( ) ; values . put Null ( Contacts Contract . Contacts . DISPLAY NAME ) ; values . put ( Phone . NUMBER , contact Id . to String ( ) ) ; values . put ( Phone . TYPE , Phone . TYPE MOBILE ) ; return create Contact ( context , values ) ; }
public void serialize ( K Xml Serializer serializer ) throws IO Exception { serializer . start Tag ( ns , TAG ) ; serialize Attribute ( serializer , NAME ATTR , m Name ) ; serialize Attribute ( serializer , APP PACKAGE NAME ATTR , m App Package Name ) ; serialize Attribute ( serializer , DIGEST ATTR , get Digest ( ) ) ; if ( SIGNATURE TEST PKG . equals ( m Name ) ) { serializer . attribute ( ns , STRING , STRING ) ; } m Suite Root . serialize ( serializer ) ; serializer . end Tag ( ns , TAG ) ; }
public void add Warning ( Warning w ) { warnings . add ( w ) ; }
public int add Item ( String label , float value , int color ) { Item it = new Item ( ) ; it . m Label = label ; it . m Color = color ; it . m Value = value ; it . m Highlight = Color . argb ( NUM , Math . min ( ( int ) ( m Highlight Strength * ( float ) Color . red ( color ) ) , NUM ) , Math . min ( ( int ) ( m Highlight Strength * ( float ) Color . green ( color ) ) , NUM ) , Math . min ( ( int ) ( m Highlight Strength * ( float ) Color . blue ( color ) ) , NUM ) ) ; m Total += value ; m Data . add ( it ) ; on Data Changed ( ) ; return m Data . size ( ) - NUM ; }
public int add Item ( String label , float value , int color ) { Item it = new Item ( ) ; it . m Label = label ; it . m Color = color ; it . m Value = value ; it . m Highlight = Color . argb ( NUM , Math . min ( ( int ) ( m Highlight Strength * ( float ) Color . red ( color ) ) , NUM ) , Math . min ( ( int ) ( m Highlight Strength * ( float ) Color . green ( color ) ) , NUM ) , Math . min ( ( int ) ( m Highlight Strength * ( float ) Color . blue ( color ) ) , NUM ) ) ; m Total += value ; m Data . add ( it ) ; on Data Changed ( ) ; return m Data . size ( ) - NUM ; }
public int add Item ( String label , float value , int color ) { Item it = new Item ( ) ; it . m Label = label ; it . m Color = color ; it . m Value = value ; it . m Highlight = Color . argb ( NUM , Math . min ( ( int ) ( m Highlight Strength * ( float ) Color . red ( color ) ) , NUM ) , Math . min ( ( int ) ( m Highlight Strength * ( float ) Color . green ( color ) ) , NUM ) , Math . min ( ( int ) ( m Highlight Strength * ( float ) Color . blue ( color ) ) , NUM ) ) ; m Total += value ; m Data . add ( it ) ; on Data Changed ( ) ; return m Data . size ( ) - NUM ; }
public static Class unbox Type ( Class wrapper Type ) { Class c = ( Class ) wrapper Map . get ( wrapper Type ) ; if ( c != null ) return c ; throw new Interpreter Error ( STRING + wrapper Type ) ; }
public void test park For 2 ( ) throws Exception { Cyclic Barrier barrier = new Cyclic Barrier ( NUM ) ; Parker parker = new Parker ( barrier , BOOL , NUM ) ; Thread parker Thread = new Thread ( parker ) ; Thread waiter Thread = new Thread ( new Wait And Unpark ( barrier , NUM , parker Thread ) ) ; parker Thread . start ( ) ; waiter Thread . start ( ) ; parker . assert Duration Is In Range ( NUM ) ; waiter Thread . join ( ) ; parker Thread . join ( ) ; }
public void test park For 2 ( ) throws Exception { Cyclic Barrier barrier = new Cyclic Barrier ( NUM ) ; Parker parker = new Parker ( barrier , BOOL , NUM ) ; Thread parker Thread = new Thread ( parker ) ; Thread waiter Thread = new Thread ( new Wait And Unpark ( barrier , NUM , parker Thread ) ) ; parker Thread . start ( ) ; waiter Thread . start ( ) ; parker . assert Duration Is In Range ( NUM ) ; waiter Thread . join ( ) ; parker Thread . join ( ) ; }
public void test park For 2 ( ) throws Exception { Cyclic Barrier barrier = new Cyclic Barrier ( NUM ) ; Parker parker = new Parker ( barrier , BOOL , NUM ) ; Thread parker Thread = new Thread ( parker ) ; Thread waiter Thread = new Thread ( new Wait And Unpark ( barrier , NUM , parker Thread ) ) ; parker Thread . start ( ) ; waiter Thread . start ( ) ; parker . assert Duration Is In Range ( NUM ) ; waiter Thread . join ( ) ; parker Thread . join ( ) ; }
public Dialogue Importer import Dialogue ( String dialogue File ) { List < Dialogue State > turns = XML Dialogue Reader . extract Dialogue ( dialogue File ) ; Dialogue Importer importer = new Dialogue Importer ( this , turns ) ; importer . start ( ) ; return importer ; }
public Dialogue Importer import Dialogue ( String dialogue File ) { List < Dialogue State > turns = XML Dialogue Reader . extract Dialogue ( dialogue File ) ; Dialogue Importer importer = new Dialogue Importer ( this , turns ) ; importer . start ( ) ; return importer ; }
public boolean has Set ( String name ) { return m map . contains Key ( name ) ; }
public boolean has Set ( String name ) { return m map . contains Key ( name ) ; }
public Ignite Uuid affinity Key ( long block Off , boolean include Moved ) { if ( ranges == null ) return null ; assert ! ranges . is Empty ( ) ; int left Idx = NUM , right Idx = ranges . size ( ) - NUM ; Igfs File Affinity Range left Range = ranges . get ( left Idx ) ; Igfs File Affinity Range right Range = ranges . get ( right Idx ) ; if ( left Range . less ( block Off ) ) return null ; if ( left Range . belongs ( block Off ) ) return left Range . status ( ) != RANGE STATUS MOVED ? left Range . affinity Key ( ) : include Moved ? left Range . affinity Key ( ) : null ; if ( right Range . greater ( block Off ) ) return null ; if ( right Range . belongs ( block Off ) ) return right Range . status ( ) != RANGE STATUS MOVED ? right Range . affinity Key ( ) : include Moved ? left Range . affinity Key ( ) : null ; while ( right Idx - left Idx > NUM ) { int mid Idx = ( left Idx + right Idx ) / NUM ; Igfs File Affinity Range mid Range = ranges . get ( mid Idx ) ; if ( mid Range . belongs ( block Off ) ) return mid Range . status ( ) != RANGE STATUS MOVED ? mid Range . affinity Key ( ) : include Moved ? left Range . affinity Key ( ) : null ; if ( mid Range . less ( block Off ) ) right Idx = mid Idx ; else { assert mid Range . greater ( block Off ) ; left Idx = mid Idx ; } } return null ; }
private String find Last String Assignment ( Stmt stmt , Local local , Bi Di Interprocedural CFG < Unit , Soot Method > cfg ) { if ( stmt instanceof Assign Stmt ) { Assign Stmt assign = ( Assign Stmt ) stmt ; if ( assign . get Left Op ( ) == local ) { if ( assign . get Right Op ( ) instanceof String Constant ) return ( ( String Constant ) assign . get Right Op ( ) ) . value ; } } for ( Unit pred : cfg . get Preds Of ( stmt ) ) { if ( ! ( pred instanceof Stmt ) ) continue ; String last Assignment = find Last String Assignment ( ( Stmt ) pred , local , cfg ) ; if ( last Assignment != null ) return last Assignment ; } return null ; }
private String find Last String Assignment ( Stmt stmt , Local local , Bi Di Interprocedural CFG < Unit , Soot Method > cfg ) { if ( stmt instanceof Assign Stmt ) { Assign Stmt assign = ( Assign Stmt ) stmt ; if ( assign . get Left Op ( ) == local ) { if ( assign . get Right Op ( ) instanceof String Constant ) return ( ( String Constant ) assign . get Right Op ( ) ) . value ; } } for ( Unit pred : cfg . get Preds Of ( stmt ) ) { if ( ! ( pred instanceof Stmt ) ) continue ; String last Assignment = find Last String Assignment ( ( Stmt ) pred , local , cfg ) ; if ( last Assignment != null ) return last Assignment ; } return null ; }
private void register Changed Resource Parent ( I Resource changed Resource ) throws Team Exception { I Container parent = changed Resource . get Parent ( ) ; if ( parent == null ) return ; if ( remote Sync State Store . get Bytes ( parent ) == null ) { remote Sync State Store . set Bytes ( parent , DUMMY SYNC BYTES ) ; register Changed Resource Parent ( parent ) ; } }
private void register Changed Resource Parent ( I Resource changed Resource ) throws Team Exception { I Container parent = changed Resource . get Parent ( ) ; if ( parent == null ) return ; if ( remote Sync State Store . get Bytes ( parent ) == null ) { remote Sync State Store . set Bytes ( parent , DUMMY SYNC BYTES ) ; register Changed Resource Parent ( parent ) ; } }
private void register Changed Resource Parent ( I Resource changed Resource ) throws Team Exception { I Container parent = changed Resource . get Parent ( ) ; if ( parent == null ) return ; if ( remote Sync State Store . get Bytes ( parent ) == null ) { remote Sync State Store . set Bytes ( parent , DUMMY SYNC BYTES ) ; register Changed Resource Parent ( parent ) ; } }
private void register Changed Resource Parent ( I Resource changed Resource ) throws Team Exception { I Container parent = changed Resource . get Parent ( ) ; if ( parent == null ) return ; if ( remote Sync State Store . get Bytes ( parent ) == null ) { remote Sync State Store . set Bytes ( parent , DUMMY SYNC BYTES ) ; register Changed Resource Parent ( parent ) ; } }
private void register Changed Resource Parent ( I Resource changed Resource ) throws Team Exception { I Container parent = changed Resource . get Parent ( ) ; if ( parent == null ) return ; if ( remote Sync State Store . get Bytes ( parent ) == null ) { remote Sync State Store . set Bytes ( parent , DUMMY SYNC BYTES ) ; register Changed Resource Parent ( parent ) ; } }
public < T extends PO > PO Result Set < T > scroll ( ) throws DB Exception { String sql = build SQL ( null , BOOL ) ; Prepared Statement pstmt = null ; Result Set rs = null ; PO Result Set < T > rs PO = null ; try { pstmt = DB . prepare Statement ( sql , trx Name ) ; rs = create Result Set ( pstmt ) ; rs PO = new PO Result Set < T > ( table , pstmt , rs , trx Name ) ; rs PO . set Close On Error ( BOOL ) ; return rs PO ; } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; throw new DB Exception ( e , sql ) ; } finally { if ( rs PO == null ) { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } } }
public < T extends PO > PO Result Set < T > scroll ( ) throws DB Exception { String sql = build SQL ( null , BOOL ) ; Prepared Statement pstmt = null ; Result Set rs = null ; PO Result Set < T > rs PO = null ; try { pstmt = DB . prepare Statement ( sql , trx Name ) ; rs = create Result Set ( pstmt ) ; rs PO = new PO Result Set < T > ( table , pstmt , rs , trx Name ) ; rs PO . set Close On Error ( BOOL ) ; return rs PO ; } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; throw new DB Exception ( e , sql ) ; } finally { if ( rs PO == null ) { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } } }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return NOTE ID ; case NUM : return CLASS NAME ; case NUM : return INTERPRETER CONTEXT ; default : return null ; } }
public void delete ( String name ) throws IO Exception { if ( name . equals Ignore Case ( KEY ID ) ) { id = null ; } else { throw new IO Exception ( STRING + STRING ) ; } encode This ( ) ; }
public static boolean can Translate ( String unlocalized String ) { if ( I18 n . has Key ( unlocalized String ) ) return BOOL ; else { if ( UNLOCALIZED STRINGS . size ( ) < NUM && ! UNLOCALIZED STRINGS . contains ( unlocalized String ) ) UNLOCALIZED STRINGS . add ( unlocalized String ) ; return BOOL ; } }
public static boolean can Translate ( String unlocalized String ) { if ( I18 n . has Key ( unlocalized String ) ) return BOOL ; else { if ( UNLOCALIZED STRINGS . size ( ) < NUM && ! UNLOCALIZED STRINGS . contains ( unlocalized String ) ) UNLOCALIZED STRINGS . add ( unlocalized String ) ; return BOOL ; } }
public void add Tab Stop ( int stop ) { bounds Check ( stop ) ; tabstops . add ( stop ) ; }
public void test Get Owner Element 1 ( ) throws Throwable { Document doc ; Node List address List ; Node test Node ; Named Node Map attributes ; Attr domestic Attr ; Element element Node ; String name ; doc = ( Document ) load ( STRING , builder ) ; address List = doc . get Elements By Tag Name ( STRING ) ; test Node = address List . item ( NUM ) ; attributes = test Node . get Attributes ( ) ; domestic Attr = ( Attr ) attributes . get Named Item ( STRING ) ; element Node = domestic Attr . get Owner Element ( ) ; name = element Node . get Node Name ( ) ; assert Equals ( STRING , STRING , name ) ; }
protected void serialize Attribute ( Tag Node tag Node , Writer writer , String att Name , String att Value ) throws IO Exception { if ( ! is Forbidden Attribute ( tag Node , att Name , att Value ) ) { writer . write ( STRING + att Name + STRING + escape Xml ( att Value ) + STRING ) ; } }
protected void serialize Attribute ( Tag Node tag Node , Writer writer , String att Name , String att Value ) throws IO Exception { if ( ! is Forbidden Attribute ( tag Node , att Name , att Value ) ) { writer . write ( STRING + att Name + STRING + escape Xml ( att Value ) + STRING ) ; } }
@ Rpc Method public void place ( Resource resource , Async Method Callback < Host . Async Client . place call > handler ) throws Rpc Exception { ensure Client ( ) ; Place Request place Request = new Place Request ( resource ) ; client Proxy . set Timeout ( PLACE TIMEOUT MS ) ; logger . debug ( STRING , resource , get Host Ip ( ) , place Request ) ; try { client Proxy . place ( place Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Deprecated public static void put IANA 2 Java Mapping ( String iana Encoding , String java Encoding ) { fIANA 2 Java Map . put ( iana Encoding , java Encoding ) ; }
public Compact Hash Set ( Collection < E > c ) { this ( c . size ( ) ) ; add All ( c ) ; }
public Compact Hash Set ( Collection < E > c ) { this ( c . size ( ) ) ; add All ( c ) ; }
public void disconnect ( ) throws IO Exception { socket . disconnect ( ) ; }
public < U > Simple React Stream < Double > from ( final Double Stream stream ) { return from ( stream . boxed ( ) ) ; }
public static Neural Network read From ( String filename ) throws IO Exception , Class Not Found Exception { Object Input Stream ois = new Object Input Stream ( new File Input Stream ( filename ) ) ; Neural Network net = ( Neural Network ) ois . read Object ( ) ; ois . close ( ) ; return net ; }
public static String hash ( String string ) { try { Message Digest sha 1 = Message Digest . get Instance ( STRING ) ; sha 1 . update ( string . get Bytes ( STRING ) ) ; return Base 64 . encode ( sha 1 . digest ( ) ) ; } catch ( Exception ex ) { Debug debug = Debug . get Instance ( STRING ) ; if ( debug . warning Enabled ( ) ) { debug . warning ( STRING , ex ) ; } return null ; } }
public void keep Only ( Set < I Var Abstraction > useful Pointers ) { Set < I Var Abstraction > reps = new Hash Set < I Var Abstraction > ( ) ; for ( I Var Abstraction pn : useful Pointers ) { reps . add ( pn . get Representative ( ) ) ; } useful Pointers . add All ( reps ) ; reps = null ; for ( I Var Abstraction pn : pointers ) { if ( ! useful Pointers . contains ( pn ) ) pn . delete All ( ) ; } System . gc ( ) ; }
private void mark As Incomplete ( VM vm ) throws IO Exception { File backup Dir = get Backup Dir For Member ( get Baseline Dir ( ) , get Member Id ( vm ) ) ; assert True ( backup Dir . exists ( ) ) ; File incomplete = new File ( backup Dir , Backup Manager . INCOMPLETE BACKUP ) ; incomplete . create New File ( ) ; }
private boolean is Load More ( ) { return m Next Load Enable && page Size != - NUM && m Request Load More Listener != null && m Data . size ( ) >= page Size ; }
public void test Failed Stage ( ) { CF Exception ex = new CF Exception ( ) ; Completion Stage < Integer > f = Completable Future . failed Stage ( ex ) ; Atomic Integer x = new Atomic Integer ( NUM ) ; Atomic Reference < Throwable > r = new Atomic Reference < Throwable > ( ) ; f . when Complete ( null ) ; assert Equals ( x . get ( ) , NUM ) ; assert Equals ( r . get ( ) , ex ) ; }
public void test Failed Stage ( ) { CF Exception ex = new CF Exception ( ) ; Completion Stage < Integer > f = Completable Future . failed Stage ( ex ) ; Atomic Integer x = new Atomic Integer ( NUM ) ; Atomic Reference < Throwable > r = new Atomic Reference < Throwable > ( ) ; f . when Complete ( null ) ; assert Equals ( x . get ( ) , NUM ) ; assert Equals ( r . get ( ) , ex ) ; }
public void test Failed Stage ( ) { CF Exception ex = new CF Exception ( ) ; Completion Stage < Integer > f = Completable Future . failed Stage ( ex ) ; Atomic Integer x = new Atomic Integer ( NUM ) ; Atomic Reference < Throwable > r = new Atomic Reference < Throwable > ( ) ; f . when Complete ( null ) ; assert Equals ( x . get ( ) , NUM ) ; assert Equals ( r . get ( ) , ex ) ; }
public int [ ] intersect ( int [ ] nums 1 , int [ ] nums 2 ) { Map < Integer , Integer > count = new Hash Map < > ( ) ; for ( int n : nums 1 ) { count . put ( n , count . contains Key ( n ) ? count . get ( n ) + NUM : NUM ) ; } List < Integer > intersections = new Array List < > ( Math . min ( nums 1 . length , nums 2 . length ) ) ; for ( int n : nums 2 ) { if ( count . contains Key ( n ) ) { intersections . add ( n ) ; count . put ( n , count . get ( n ) - NUM ) ; if ( count . get ( n ) == NUM ) count . remove ( n ) ; } } int [ ] res = new int [ intersections . size ( ) ] ; for ( int i = NUM ; i < intersections . size ( ) ; i ++ ) { res [ i ] = intersections . get ( i ) ; } return res ; }
public int [ ] intersect ( int [ ] nums 1 , int [ ] nums 2 ) { Map < Integer , Integer > count = new Hash Map < > ( ) ; for ( int n : nums 1 ) { count . put ( n , count . contains Key ( n ) ? count . get ( n ) + NUM : NUM ) ; } List < Integer > intersections = new Array List < > ( Math . min ( nums 1 . length , nums 2 . length ) ) ; for ( int n : nums 2 ) { if ( count . contains Key ( n ) ) { intersections . add ( n ) ; count . put ( n , count . get ( n ) - NUM ) ; if ( count . get ( n ) == NUM ) count . remove ( n ) ; } } int [ ] res = new int [ intersections . size ( ) ] ; for ( int i = NUM ; i < intersections . size ( ) ; i ++ ) { res [ i ] = intersections . get ( i ) ; } return res ; }
public int [ ] intersect ( int [ ] nums 1 , int [ ] nums 2 ) { Map < Integer , Integer > count = new Hash Map < > ( ) ; for ( int n : nums 1 ) { count . put ( n , count . contains Key ( n ) ? count . get ( n ) + NUM : NUM ) ; } List < Integer > intersections = new Array List < > ( Math . min ( nums 1 . length , nums 2 . length ) ) ; for ( int n : nums 2 ) { if ( count . contains Key ( n ) ) { intersections . add ( n ) ; count . put ( n , count . get ( n ) - NUM ) ; if ( count . get ( n ) == NUM ) count . remove ( n ) ; } } int [ ] res = new int [ intersections . size ( ) ] ; for ( int i = NUM ; i < intersections . size ( ) ; i ++ ) { res [ i ] = intersections . get ( i ) ; } return res ; }
public int [ ] intersect ( int [ ] nums 1 , int [ ] nums 2 ) { Map < Integer , Integer > count = new Hash Map < > ( ) ; for ( int n : nums 1 ) { count . put ( n , count . contains Key ( n ) ? count . get ( n ) + NUM : NUM ) ; } List < Integer > intersections = new Array List < > ( Math . min ( nums 1 . length , nums 2 . length ) ) ; for ( int n : nums 2 ) { if ( count . contains Key ( n ) ) { intersections . add ( n ) ; count . put ( n , count . get ( n ) - NUM ) ; if ( count . get ( n ) == NUM ) count . remove ( n ) ; } } int [ ] res = new int [ intersections . size ( ) ] ; for ( int i = NUM ; i < intersections . size ( ) ; i ++ ) { res [ i ] = intersections . get ( i ) ; } return res ; }
private void persist Un Managed Export Masks ( List < Un Managed Export Mask > un Managed Export Masks To Create , List < Un Managed Export Mask > un Managed Export Masks To Update , boolean flush ) { if ( null != un Managed Export Masks To Create ) { if ( flush || ( un Managed Export Masks To Create . size ( ) >= BATCH SIZE ) ) { partition Manager . insert In Batches ( un Managed Export Masks To Create , BATCH SIZE , db Client , UNMANAGED EXPORT MASK ) ; un Managed Export Masks To Create . clear ( ) ; } } if ( null != un Managed Export Masks To Update ) { if ( flush || ( un Managed Export Masks To Update . size ( ) >= BATCH SIZE ) ) { partition Manager . update In Batches ( un Managed Export Masks To Update , BATCH SIZE , db Client , UNMANAGED EXPORT MASK ) ; un Managed Export Masks To Update . clear ( ) ; } } }
public void add Run Configuration ( Project project , String name , Properties properties ) { try { J2 SE Project Configurations . create Configuration Files ( project , name , properties , null ) ; } catch ( IO Exception ex ) { Exceptions . print Stack Trace ( ex ) ; } catch ( Illegal Argument Exception ex ) { Exceptions . print Stack Trace ( ex ) ; } }
public void write Bytes ( final byte [ ] bytes ) { if ( bytes == null ) return ; if ( current Bit Index < Byte . SIZE - NUM ) { for ( int i = NUM ; i < bytes . length ; i ++ ) { write ( bytes [ i ] , Byte . SIZE ) ; } } else { byte Stream . write ( bytes , NUM , bytes . length ) ; } }
private void show Next Super Toast ( ) { final Super Activity Toast super Activity Toast = m List . peek ( ) ; if ( m List . is Empty ( ) || super Activity Toast . get Activity ( ) == null ) { return ; } if ( ! super Activity Toast . is Showing ( ) ) { final Message message = obtain Message ( Messages . DISPLAY ) ; message . obj = super Activity Toast ; send Message ( message ) ; } }
private void show Next Super Toast ( ) { final Super Activity Toast super Activity Toast = m List . peek ( ) ; if ( m List . is Empty ( ) || super Activity Toast . get Activity ( ) == null ) { return ; } if ( ! super Activity Toast . is Showing ( ) ) { final Message message = obtain Message ( Messages . DISPLAY ) ; message . obj = super Activity Toast ; send Message ( message ) ; } }
protected void pre Update Menu ( ) { }
private void save Sorted Pom File ( final String sorted Xml ) { file Util . save Pom File ( sorted Xml ) ; log . info ( STRING + pom File . get Absolute Path ( ) ) ; }
@ Deprecated protected Partitioner . Partition < Abstract Kafka Input Operator < K > > create Partition ( Set < Kafka Partition > p Ids , Map < Kafka Partition , Long > init Offsets , @ Suppress Warnings ( STRING ) Collection < Window Data Manager > new Managers ) { return create Partition ( p Ids , init Offsets ) ; }
public static void write String Fixed Size ( final Data Output out , String s , int size ) throws IO Exception { byte [ ] b = to Bytes ( s ) ; if ( b . length > size ) { throw new IO Exception ( STRING + b . length + STRING + to String Binary ( b ) + STRING + size ) ; } out . write Bytes ( s ) ; for ( int i = NUM ; i < size - s . length ( ) ; ++ i ) out . write Byte ( NUM ) ; }
public boolean contains ( Json Element element ) { return elements . contains ( element ) ; }
private static List < Object > array To List ( final Object array ) { if ( array instanceof Object [ ] ) return Arrays . as List ( ( Object [ ] ) array ) ; List < Object > result = new Array List < Object > ( ) ; if ( array instanceof int [ ] ) for ( int value : ( int [ ] ) array ) result . add ( value ) ; else if ( array instanceof boolean [ ] ) for ( boolean value : ( boolean [ ] ) array ) result . add ( value ) ; else if ( array instanceof long [ ] ) for ( long value : ( long [ ] ) array ) result . add ( value ) ; else if ( array instanceof float [ ] ) for ( float value : ( float [ ] ) array ) result . add ( value ) ; else if ( array instanceof double [ ] ) for ( double value : ( double [ ] ) array ) result . add ( value ) ; else if ( array instanceof short [ ] ) for ( short value : ( short [ ] ) array ) result . add ( value ) ; else if ( array instanceof byte [ ] ) for ( byte value : ( byte [ ] ) array ) result . add ( value ) ; else if ( array instanceof char [ ] ) for ( char value : ( char [ ] ) array ) result . add ( value ) ; return result ; }
private static List < Object > array To List ( final Object array ) { if ( array instanceof Object [ ] ) return Arrays . as List ( ( Object [ ] ) array ) ; List < Object > result = new Array List < Object > ( ) ; if ( array instanceof int [ ] ) for ( int value : ( int [ ] ) array ) result . add ( value ) ; else if ( array instanceof boolean [ ] ) for ( boolean value : ( boolean [ ] ) array ) result . add ( value ) ; else if ( array instanceof long [ ] ) for ( long value : ( long [ ] ) array ) result . add ( value ) ; else if ( array instanceof float [ ] ) for ( float value : ( float [ ] ) array ) result . add ( value ) ; else if ( array instanceof double [ ] ) for ( double value : ( double [ ] ) array ) result . add ( value ) ; else if ( array instanceof short [ ] ) for ( short value : ( short [ ] ) array ) result . add ( value ) ; else if ( array instanceof byte [ ] ) for ( byte value : ( byte [ ] ) array ) result . add ( value ) ; else if ( array instanceof char [ ] ) for ( char value : ( char [ ] ) array ) result . add ( value ) ; return result ; }
private static List < Object > array To List ( final Object array ) { if ( array instanceof Object [ ] ) return Arrays . as List ( ( Object [ ] ) array ) ; List < Object > result = new Array List < Object > ( ) ; if ( array instanceof int [ ] ) for ( int value : ( int [ ] ) array ) result . add ( value ) ; else if ( array instanceof boolean [ ] ) for ( boolean value : ( boolean [ ] ) array ) result . add ( value ) ; else if ( array instanceof long [ ] ) for ( long value : ( long [ ] ) array ) result . add ( value ) ; else if ( array instanceof float [ ] ) for ( float value : ( float [ ] ) array ) result . add ( value ) ; else if ( array instanceof double [ ] ) for ( double value : ( double [ ] ) array ) result . add ( value ) ; else if ( array instanceof short [ ] ) for ( short value : ( short [ ] ) array ) result . add ( value ) ; else if ( array instanceof byte [ ] ) for ( byte value : ( byte [ ] ) array ) result . add ( value ) ; else if ( array instanceof char [ ] ) for ( char value : ( char [ ] ) array ) result . add ( value ) ; return result ; }
public int compare Swapped To ( Int Double Pair other ) { int fdiff = Double . compare ( this . second , other . second ) ; if ( fdiff != NUM ) { return fdiff ; } return this . first - other . first ; }
public void close Running App ( String device ID , String app package ) throws Interrupted Exception , IO Exception { cmd . run Command ( STRING + device ID + STRING + app package ) ; }
public synchronized void animate Pan ( double dx , double dy , long duration ) { double panx = dx / m transform . get Scale X ( ) ; double pany = dy / m transform . get Scale Y ( ) ; animate Pan Abs ( panx , pany , duration ) ; }
public synchronized void animate Pan ( double dx , double dy , long duration ) { double panx = dx / m transform . get Scale X ( ) ; double pany = dy / m transform . get Scale Y ( ) ; animate Pan Abs ( panx , pany , duration ) ; }
public synchronized void animate Pan ( double dx , double dy , long duration ) { double panx = dx / m transform . get Scale X ( ) ; double pany = dy / m transform . get Scale Y ( ) ; animate Pan Abs ( panx , pany , duration ) ; }
protected boolean check ( T item ) { return BOOL ; }
protected boolean check ( T item ) { return BOOL ; }
protected boolean check ( T item ) { return BOOL ; }
protected boolean check ( T item ) { return BOOL ; }
protected boolean check ( T item ) { return BOOL ; }
public String graph ( ) throws Exception { String Buffer text = new String Buffer ( ) ; assign I Ds ( - NUM ) ; assign Leaf Model Numbers ( NUM ) ; text . append ( STRING ) ; if ( m is Leaf ) { text . append ( STRING + m id + STRING + m leaf Model Num + STRING + get Model Parameters ( ) + STRING + STRING ) ; text . append ( STRING ) ; } else { text . append ( STRING + m id + STRING + Utils . back Quote Chars ( m local Model . left Side ( m train ) ) + STRING ) ; text . append ( STRING ) ; graph Tree ( text ) ; } return text . to String ( ) + STRING ; }
public String graph ( ) throws Exception { String Buffer text = new String Buffer ( ) ; assign I Ds ( - NUM ) ; assign Leaf Model Numbers ( NUM ) ; text . append ( STRING ) ; if ( m is Leaf ) { text . append ( STRING + m id + STRING + m leaf Model Num + STRING + get Model Parameters ( ) + STRING + STRING ) ; text . append ( STRING ) ; } else { text . append ( STRING + m id + STRING + Utils . back Quote Chars ( m local Model . left Side ( m train ) ) + STRING ) ; text . append ( STRING ) ; graph Tree ( text ) ; } return text . to String ( ) + STRING ; }
public void assure Buffer Capacity ( final int len ) { while ( len > buffer . remaining ( ) ) { int new Capacity = Math . max ( ( int ) ( len + buffer . position ( ) * BIG SIZE INCREASE ) , ( int ) ( ( buffer . capacity ( ) > NUM ) ? buffer . capacity ( ) * BIG SIZE INCREASE : buffer . capacity ( ) * NORMAL INCREASE ) ) ; increase ( new Capacity ) ; } }
public void assure Buffer Capacity ( final int len ) { while ( len > buffer . remaining ( ) ) { int new Capacity = Math . max ( ( int ) ( len + buffer . position ( ) * BIG SIZE INCREASE ) , ( int ) ( ( buffer . capacity ( ) > NUM ) ? buffer . capacity ( ) * BIG SIZE INCREASE : buffer . capacity ( ) * NORMAL INCREASE ) ) ; increase ( new Capacity ) ; } }
public static final String trim Front ( String str ) { int position = NUM ; while ( ( position < str . length ( ) ) && Character . is Whitespace ( str . char At ( position ) ) ) { position ++ ; } return str . substring ( position , str . length ( ) ) ; }
public static String calculate Discount Percent ( Context context , double price , double discount Price ) { int percent ; if ( discount Price >= price ) { percent = NUM ; } else { percent = ( int ) Math . round ( NUM - ( ( discount Price / price ) * NUM ) ) ; } return String . format ( context . get String ( R . string . format price discount percents ) , percent ) ; }
private static int string To Hash ( String s ) { int len = s . length ( ) ; int hash 2 = NUM ; int hash = len ; hash <<= NUM ; hash += s . char At ( NUM ) - NUM ; int j = len ; for ( int i = NUM ; i < NUM && j > NUM ; i ++ ) { j -- ; hash <<= NUM ; hash += s . char At ( j ) - NUM ; hash 2 <<= NUM ; hash 2 += s . char At ( i ) - NUM ; } return hash ^ hash 2 ; }
private static int string To Hash ( String s ) { int len = s . length ( ) ; int hash 2 = NUM ; int hash = len ; hash <<= NUM ; hash += s . char At ( NUM ) - NUM ; int j = len ; for ( int i = NUM ; i < NUM && j > NUM ; i ++ ) { j -- ; hash <<= NUM ; hash += s . char At ( j ) - NUM ; hash 2 <<= NUM ; hash 2 += s . char At ( i ) - NUM ; } return hash ^ hash 2 ; }
public void write ( final String filename ) { Print Stream stream ; try { stream = new Print Stream ( new File ( filename ) ) ; } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; return ; } write ( stream ) ; stream . close ( ) ; }
private String lookup Local Address ( ) { long timeout = NUM * NUM ; long expire Time = Current Time . current Time ( ) + timeout ; String address ; while ( ( address = allocate Local Address ( ) ) == null && Current Time . current Time ( ) < expire Time ) { try { Thread . sleep ( NUM ) ; } catch ( Exception e ) { } } if ( address == null ) { throw new Config Exception ( L . l ( STRING + STRING + STRING , server Bartender . get Id ( ) , server Bartender . get Address ( ) ) ) ; } return address ; }
private String lookup Local Address ( ) { long timeout = NUM * NUM ; long expire Time = Current Time . current Time ( ) + timeout ; String address ; while ( ( address = allocate Local Address ( ) ) == null && Current Time . current Time ( ) < expire Time ) { try { Thread . sleep ( NUM ) ; } catch ( Exception e ) { } } if ( address == null ) { throw new Config Exception ( L . l ( STRING + STRING + STRING , server Bartender . get Id ( ) , server Bartender . get Address ( ) ) ) ; } return address ; }
private String lookup Local Address ( ) { long timeout = NUM * NUM ; long expire Time = Current Time . current Time ( ) + timeout ; String address ; while ( ( address = allocate Local Address ( ) ) == null && Current Time . current Time ( ) < expire Time ) { try { Thread . sleep ( NUM ) ; } catch ( Exception e ) { } } if ( address == null ) { throw new Config Exception ( L . l ( STRING + STRING + STRING , server Bartender . get Id ( ) , server Bartender . get Address ( ) ) ) ; } return address ; }
private String lookup Local Address ( ) { long timeout = NUM * NUM ; long expire Time = Current Time . current Time ( ) + timeout ; String address ; while ( ( address = allocate Local Address ( ) ) == null && Current Time . current Time ( ) < expire Time ) { try { Thread . sleep ( NUM ) ; } catch ( Exception e ) { } } if ( address == null ) { throw new Config Exception ( L . l ( STRING + STRING + STRING , server Bartender . get Id ( ) , server Bartender . get Address ( ) ) ) ; } return address ; }
public Config ( Saml Authority Configuration saml Authority Config , Token Restrictions token Restrictions , Collection < List < Certificate > > valid Certs , long clock Tolerance , Collection < IDP Config > in External Idps ) { Validate . not Null ( saml Authority Config ) ; Validate . not Null ( token Restrictions ) ; Validate . not Empty ( valid Certs ) ; List < Certificate > authority Cert = saml Authority Config . get Signing Certificate Chain ( ) ; boolean authority Cert In Valid Certs = BOOL ; for ( List < Certificate > current Chain : valid Certs ) { Validate . not Empty ( current Chain ) ; Validate . no Null Elements ( current Chain ) ; if ( ! authority Cert In Valid Certs && current Chain . equals ( authority Cert ) ) { authority Cert In Valid Certs = BOOL ; } } Validate . is True ( authority Cert In Valid Certs , STRING ) ; Validate . is True ( clock Tolerance >= NUM ) ; this . saml Authority Config = saml Authority Config ; this . valid Certs = valid Certs ; this . clock Tolerance = clock Tolerance ; this . token Restrictions = token Restrictions ; Hash Map < String , IDP Config > idps Set = new Hash Map < String , IDP Config > ( ) ; if ( in External Idps != null ) { for ( IDP Config conf : in External Idps ) { if ( conf != null ) { idps Set . put ( conf . get Entity ID ( ) , conf ) ; } } } this . external Idps = Collections . unmodifiable Map ( idps Set ) ; }
void add Edge ( Method Parameter in , Method Parameter out ) { Set < Method Parameter > outs = graph . get ( in ) ; if ( outs == null ) { outs = new Hash Set < > ( ) ; graph . put ( in , outs ) ; } outs . add ( out ) ; }
public C Action About ( final J Frame parent ) { super ( String . format ( STRING , Constants . PROJECT NAME ) ) ; m parent = Preconditions . check Not Null ( parent , STRING ) ; put Value ( MNEMONIC KEY , ( int ) STRING ) ; }
public static long pause ( final long sleep Time MS ) { final long start Time = System . current Time Millis ( ) ; do { try { final long sleep Time = sleep Time MS - ( System . current Time Millis ( ) - start Time ) ; Thread . sleep ( sleep Time > NUM ? sleep Time : NUM ) ; } catch ( Interrupted Exception e ) { } } while ( ( System . current Time Millis ( ) - start Time ) < sleep Time MS ) ; return System . current Time Millis ( ) - start Time ; }
public byte [ ] digest ( ) { byte [ ] result = engine Digest ( ) ; state = INITIAL ; return result ; }
public byte [ ] digest ( ) { byte [ ] result = engine Digest ( ) ; state = INITIAL ; return result ; }
public void add Move To Beginning ( Register Spec result , Register Spec source ) { if ( result . get Reg ( ) == source . get Reg ( ) ) { return ; } Register Spec List sources = Register Spec List . make ( source ) ; Normal Ssa Insn to Add = new Normal Ssa Insn ( new Plain Insn ( Rops . op Move ( result . get Type ( ) ) , Source Position . NO INFO , result , sources ) , this ) ; insns . add ( get Count Phi Insns ( ) , to Add ) ; moves From Phis At Beginning ++ ; }
public void add Move To Beginning ( Register Spec result , Register Spec source ) { if ( result . get Reg ( ) == source . get Reg ( ) ) { return ; } Register Spec List sources = Register Spec List . make ( source ) ; Normal Ssa Insn to Add = new Normal Ssa Insn ( new Plain Insn ( Rops . op Move ( result . get Type ( ) ) , Source Position . NO INFO , result , sources ) , this ) ; insns . add ( get Count Phi Insns ( ) , to Add ) ; moves From Phis At Beginning ++ ; }
public static String to Gml ( final I Directed Graph < ? , ? extends I Graph Edge < ? > > graph ) { Preconditions . check Not Null ( graph , STRING ) ; final String Builder sb = new String Builder ( ) ; sb . append ( STRING + STRING ) ; int current Id = NUM ; final Map < Object , Integer > node Map = new Hash Map < > ( ) ; for ( final Object node : graph . get Nodes ( ) ) { sb . append ( STRING + STRING + STRING + STRING ) ; sb . append ( current Id ) ; sb . append ( STRING ) ; sb . append ( node ) ; sb . append ( STRING + STRING ) ; node Map . put ( node , current Id ) ; ++ current Id ; } for ( final I Graph Edge < ? > edge : graph . get Edges ( ) ) { sb . append ( STRING + STRING + STRING ) ; sb . append ( node Map . get ( edge . get Source ( ) ) ) ; sb . append ( STRING + STRING ) ; sb . append ( node Map . get ( edge . get Target ( ) ) ) ; sb . append ( STRING + STRING + STRING + STRING + STRING + STRING + STRING ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
public static String to Gml ( final I Directed Graph < ? , ? extends I Graph Edge < ? > > graph ) { Preconditions . check Not Null ( graph , STRING ) ; final String Builder sb = new String Builder ( ) ; sb . append ( STRING + STRING ) ; int current Id = NUM ; final Map < Object , Integer > node Map = new Hash Map < > ( ) ; for ( final Object node : graph . get Nodes ( ) ) { sb . append ( STRING + STRING + STRING + STRING ) ; sb . append ( current Id ) ; sb . append ( STRING ) ; sb . append ( node ) ; sb . append ( STRING + STRING ) ; node Map . put ( node , current Id ) ; ++ current Id ; } for ( final I Graph Edge < ? > edge : graph . get Edges ( ) ) { sb . append ( STRING + STRING + STRING ) ; sb . append ( node Map . get ( edge . get Source ( ) ) ) ; sb . append ( STRING + STRING ) ; sb . append ( node Map . get ( edge . get Target ( ) ) ) ; sb . append ( STRING + STRING + STRING + STRING + STRING + STRING + STRING ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
public void add Custom Sash Form Listener ( I Custom Sash Form Listener listener ) { if ( custom Sash Form Listeners == null ) custom Sash Form Listeners = new Array List ( ) ; custom Sash Form Listeners . add ( listener ) ; }
public void add Custom Sash Form Listener ( I Custom Sash Form Listener listener ) { if ( custom Sash Form Listeners == null ) custom Sash Form Listeners = new Array List ( ) ; custom Sash Form Listeners . add ( listener ) ; }
protected boolean connect Input ( Neural Connection i , int n ) { if ( ! super . connect Input ( i , n ) ) { return BOOL ; } m weights [ m num Inputs ] = m random . next Double ( ) * NUM - NUM ; m change In Weights [ m num Inputs ] = NUM ; return BOOL ; }
protected boolean connect Input ( Neural Connection i , int n ) { if ( ! super . connect Input ( i , n ) ) { return BOOL ; } m weights [ m num Inputs ] = m random . next Double ( ) * NUM - NUM ; m change In Weights [ m num Inputs ] = NUM ; return BOOL ; }
protected boolean connect Input ( Neural Connection i , int n ) { if ( ! super . connect Input ( i , n ) ) { return BOOL ; } m weights [ m num Inputs ] = m random . next Double ( ) * NUM - NUM ; m change In Weights [ m num Inputs ] = NUM ; return BOOL ; }
@ Override public Completable Future < Optional < T > > find Any ( ) { return Completable Future . supply Async ( null , exec ) ; }
public void add Key ( Key key ) { keys . add ( key ) ; }
public Blaze Value Factory value Factory ( ) { return vf ; }
public Blaze Value Factory value Factory ( ) { return vf ; }
public void load Class ( Class < ? > cls ) { try { class Loader . load Class ( cls . get Name ( ) ) ; } catch ( Class Not Found Exception e ) { Log Context . debug ( STRING + cls + STRING ) ; } }
public void load Class ( Class < ? > cls ) { try { class Loader . load Class ( cls . get Name ( ) ) ; } catch ( Class Not Found Exception e ) { Log Context . debug ( STRING + cls + STRING ) ; } }
public void load Class ( Class < ? > cls ) { try { class Loader . load Class ( cls . get Name ( ) ) ; } catch ( Class Not Found Exception e ) { Log Context . debug ( STRING + cls + STRING ) ; } }
public void load Class ( Class < ? > cls ) { try { class Loader . load Class ( cls . get Name ( ) ) ; } catch ( Class Not Found Exception e ) { Log Context . debug ( STRING + cls + STRING ) ; } }
protected String Template ( String str ) { this . string = str ; whole = ( str . length ( ) != NUM || ! String Utils . is Delimiter ( str . char At ( NUM ) ) ) ; }
Initial Image Operation ( Distributed Region region , Region Map entries ) { this . region = region ; this . entries = entries ; }
public boolean delete Ship Load Name ( String load ) { if ( ! ship Load List . contains ( load ) ) { return BOOL ; } ship Load List . remove ( load ) ; log . debug ( STRING , get Name ( ) , load ) ; set Dirty And Fire Property Change ( LOADS CHANGED PROPERTY , ship Load List . size ( ) + NUM , ship Load List . size ( ) ) ; return BOOL ; }
public void clear Password Changed By Required Time ( ) { operations . add ( Password Policy State Operation Type . CLEAR PASSWORD CHANGED BY REQUIRED TIME ) ; }
public void clear Password Changed By Required Time ( ) { operations . add ( Password Policy State Operation Type . CLEAR PASSWORD CHANGED BY REQUIRED TIME ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
private void reset Attempts ( ) { for ( final Political Action Attachment paa : Political Action Attachment . get Political Action Attachments ( m player ) ) { paa . reset Attempts ( get Bridge ( ) ) ; } }
private void reset Attempts ( ) { for ( final Political Action Attachment paa : Political Action Attachment . get Political Action Attachments ( m player ) ) { paa . reset Attempts ( get Bridge ( ) ) ; } }
private void reset Attempts ( ) { for ( final Political Action Attachment paa : Political Action Attachment . get Political Action Attachments ( m player ) ) { paa . reset Attempts ( get Bridge ( ) ) ; } }
private void calculate Optimal Width And Height ( ) { if ( state == State . DEFAULT || get Width ( ) == NUM ) { return ; } float max Width = get Width ( ) , max Height = get Height ( ) ; float w = page Width , h = page Height ; float ratio = w / h ; w = max Width ; h = ( float ) Math . floor ( max Width / ratio ) ; if ( h > max Height ) { h = max Height ; w = ( float ) Math . floor ( max Height * ratio ) ; } optimal Page Width = w ; optimal Page Height = h ; }
private void calculate Optimal Width And Height ( ) { if ( state == State . DEFAULT || get Width ( ) == NUM ) { return ; } float max Width = get Width ( ) , max Height = get Height ( ) ; float w = page Width , h = page Height ; float ratio = w / h ; w = max Width ; h = ( float ) Math . floor ( max Width / ratio ) ; if ( h > max Height ) { h = max Height ; w = ( float ) Math . floor ( max Height * ratio ) ; } optimal Page Width = w ; optimal Page Height = h ; }
public static void show Message Box ( final String message , boolean button Visible ) { if ( MESSAGE BOX == null ) init Message Box ( ) ; MESSAGE BOX . set Visible ( BOOL ) ; MESSAGE LABEL . set Text ( message ) ; MESSAGE OK BUTTON . set Visible ( button Visible ) ; MESSAGE BOX . set Visible ( BOOL ) ; }
public static void show Message Box ( final String message , boolean button Visible ) { if ( MESSAGE BOX == null ) init Message Box ( ) ; MESSAGE BOX . set Visible ( BOOL ) ; MESSAGE LABEL . set Text ( message ) ; MESSAGE OK BUTTON . set Visible ( button Visible ) ; MESSAGE BOX . set Visible ( BOOL ) ; }
void update Feature Counts ( int [ ] translation Ids , List < List < Rich Translation < I String , String > > > nbest Lists ) { for ( int i = NUM ; i < translation Ids . length ; i ++ ) { Set < String > features = new Hash Set < String > ( ) ; for ( Rich Translation < I String , String > trans : nbest Lists . get ( i ) ) { for ( Feature Value < String > f : trans . features ) { features . add ( f . name ) ; } } synchronized ( clipped Feature Index ) { for ( String f Name : features ) { Set < Integer > ids = clipped Feature Index . get ( f Name ) ; if ( ids == null ) { ids = new Tree Set < Integer > ( ) ; clipped Feature Index . put ( f Name , ids ) ; } if ( ids . size ( ) < min Feature Count ) { ids . add ( translation Ids [ i ] ) ; } } } } }
public void reload ( ) { if ( m Original Geometry != null ) { if ( ! m Original Geometry . is Valid ( ) ) { m Original Geometry . reload ( ) ; } copy From Geometry 3 D ( m Original Geometry ) ; } create Buffers ( ) ; }
public void reload ( ) { if ( m Original Geometry != null ) { if ( ! m Original Geometry . is Valid ( ) ) { m Original Geometry . reload ( ) ; } copy From Geometry 3 D ( m Original Geometry ) ; } create Buffers ( ) ; }
public void reload ( ) { if ( m Original Geometry != null ) { if ( ! m Original Geometry . is Valid ( ) ) { m Original Geometry . reload ( ) ; } copy From Geometry 3 D ( m Original Geometry ) ; } create Buffers ( ) ; }
public void reload ( ) { if ( m Original Geometry != null ) { if ( ! m Original Geometry . is Valid ( ) ) { m Original Geometry . reload ( ) ; } copy From Geometry 3 D ( m Original Geometry ) ; } create Buffers ( ) ; }
public void hookup Stats ( Statistics Factory f , String name ) { if ( this . stats == null ) { this . stats = f . create Atomic Statistics ( type , name ) ; set Locator Count ( known locators . get ( ) ) ; set Server Count ( endpoints known . get ( ) ) ; set Locator Requests ( requests to locator . get ( ) ) ; set Locator Responses ( responses from locator . get ( ) ) ; set Server Load Updates ( server Load Updates . get ( ) ) ; } }
public void hookup Stats ( Statistics Factory f , String name ) { if ( this . stats == null ) { this . stats = f . create Atomic Statistics ( type , name ) ; set Locator Count ( known locators . get ( ) ) ; set Server Count ( endpoints known . get ( ) ) ; set Locator Requests ( requests to locator . get ( ) ) ; set Locator Responses ( responses from locator . get ( ) ) ; set Server Load Updates ( server Load Updates . get ( ) ) ; } }
public void hookup Stats ( Statistics Factory f , String name ) { if ( this . stats == null ) { this . stats = f . create Atomic Statistics ( type , name ) ; set Locator Count ( known locators . get ( ) ) ; set Server Count ( endpoints known . get ( ) ) ; set Locator Requests ( requests to locator . get ( ) ) ; set Locator Responses ( responses from locator . get ( ) ) ; set Server Load Updates ( server Load Updates . get ( ) ) ; } }
public boolean is Source Modified ( Resource resource ) { boolean modified = BOOL ; String file Name = resource . get Name ( ) ; String path = ( String ) template Paths . get ( file Name ) ; File current File = null ; for ( int i = NUM ; current File == null && i < paths . size ( ) ; i ++ ) { String test Path = ( String ) paths . get ( i ) ; File test File = new File ( test Path , file Name ) ; if ( test File . can Read ( ) ) { current File = test File ; } } File file = new File ( path , file Name ) ; if ( current File == null || ! file . exists ( ) ) { } else if ( current File . equals ( file ) && file . can Read ( ) ) { modified = ( file . last Modified ( ) != resource . get Last Modified ( ) ) ; } return modified ; }
public void tag Define Text Field ( int field Id , String field Name , String initial Text , Rect boundary , int flags , Alpha Color text Color , int alignment , int font Id , int font Size , int char Limit , int left Margin , int right Margin , int indentation , int line Spacing ) throws IO Exception { if ( initial Text != null ) { output . println ( initial Text ) ; } }
public void tag Define Text Field ( int field Id , String field Name , String initial Text , Rect boundary , int flags , Alpha Color text Color , int alignment , int font Id , int font Size , int char Limit , int left Margin , int right Margin , int indentation , int line Spacing ) throws IO Exception { if ( initial Text != null ) { output . println ( initial Text ) ; } }
public static void recycle Nodes ( Collection < Accessibility Node Info Compat > nodes ) { if ( nodes == null ) { return ; } for ( Accessibility Node Info Compat node : nodes ) { if ( node != null ) { node . recycle ( ) ; } } nodes . clear ( ) ; }
private boolean disconnect ( ) { if ( ! done ) { debug ( STRING ) ; } boolean clean = BOOL ; debug ( STRING ) ; debug ( STRING ) ; put ( new Event ( E Type . KILLSENDER ) ) ; while ( sending Thread != null && sending Thread . is Alive ( ) ) { try { sending Thread . join ( ) ; } catch ( Interrupted Exception e ) { } } try { pclient . shutdown Input ( ) ; pclient . shutdown Output ( ) ; debug ( STRING ) ; } catch ( Exception e ) { clean = BOOL ; } try { oos . close ( ) ; ois . close ( ) ; debug ( STRING ) ; } catch ( Exception e ) { clean = BOOL ; } try { pclient . close ( ) ; debug ( STRING ) ; } catch ( Exception e ) { clean = BOOL ; } if ( is Server ) { try { pserver . close ( ) ; debug ( STRING ) ; } catch ( Exception e ) { clean = BOOL ; } } ois = null ; oos = null ; pclient = null ; pserver = null ; debug ( clean ? STRING : STRING ) ; return clean ; }
public static String encode Password ( String password , String algorithm ) { byte [ ] unencoded Password = password . get Bytes ( ) ; Message Digest md = null ; try { md = Message Digest . get Instance ( algorithm ) ; } catch ( Exception e ) { log . error ( STRING + e ) ; return password ; } md . reset ( ) ; md . update ( unencoded Password ) ; byte [ ] encoded Password = md . digest ( ) ; String Buffer buf = new String Buffer ( ) ; for ( byte an Encoded Password : encoded Password ) { if ( ( an Encoded Password & NUM ) < NUM ) { buf . append ( STRING ) ; } buf . append ( Long . to String ( an Encoded Password & NUM , NUM ) ) ; } return buf . to String ( ) ; }
public static String encode Password ( String password , String algorithm ) { byte [ ] unencoded Password = password . get Bytes ( ) ; Message Digest md = null ; try { md = Message Digest . get Instance ( algorithm ) ; } catch ( Exception e ) { log . error ( STRING + e ) ; return password ; } md . reset ( ) ; md . update ( unencoded Password ) ; byte [ ] encoded Password = md . digest ( ) ; String Buffer buf = new String Buffer ( ) ; for ( byte an Encoded Password : encoded Password ) { if ( ( an Encoded Password & NUM ) < NUM ) { buf . append ( STRING ) ; } buf . append ( Long . to String ( an Encoded Password & NUM , NUM ) ) ; } return buf . to String ( ) ; }
public int generate ( byte [ ] output , byte [ ] additional Input , boolean prediction Resistant ) { int number Of Bits = output . length * NUM ; if ( number Of Bits > MAX BITS REQUEST ) { throw new Illegal Argument Exception ( STRING + MAX BITS REQUEST ) ; } if ( reseed Counter > RESEED MAX ) { return - NUM ; } if ( prediction Resistant ) { reseed ( additional Input ) ; additional Input = null ; } if ( additional Input != null ) { hmac DRBG Update ( additional Input ) ; } byte [ ] rv = new byte [ output . length ] ; int m = output . length / V . length ; h Mac . init ( new Key Parameter ( K ) ) ; for ( int i = NUM ; i < m ; i ++ ) { h Mac . update ( V , NUM , V . length ) ; h Mac . do Final ( V , NUM ) ; System . arraycopy ( V , NUM , rv , i * V . length , V . length ) ; } if ( m * V . length < rv . length ) { h Mac . update ( V , NUM , V . length ) ; h Mac . do Final ( V , NUM ) ; System . arraycopy ( V , NUM , rv , m * V . length , rv . length - ( m * V . length ) ) ; } hmac DRBG Update ( additional Input ) ; reseed Counter ++ ; System . arraycopy ( rv , NUM , output , NUM , output . length ) ; return number Of Bits ; }
public SSL Socket Factory build SSL Socket Factory ( ) throws Key Store Exception { SSL Context ssl Context = null ; try { Key Manager Factory key Manager Factory = Key Manager Factory . get Instance ( Key Manager Factory . get Default Algorithm ( ) ) ; key Manager Factory . init ( key Store , SSL KEYSTORE SECRET ) ; Key Manager [ ] key Managers = key Manager Factory . get Key Managers ( ) ; Trust Manager [ ] trust Managers = new Trust Manager [ ] { create Trust Manager From Default JDK Trust Store ( ) } ; ssl Context = SSL Context . get Instance ( STRING ) ; ssl Context . init ( key Managers , trust Managers , null ) ; SSL Context . set Default ( ssl Context ) ; } catch ( General Security Exception | IO Exception e ) { throw new Key Store Exception ( STRING , e ) ; } return ssl Context . get Socket Factory ( ) ; }
private String compute Replacement String ( ) { int proposal Kind = f Proposal . get Kind ( ) ; String qualified Type Name = null ; char [ ] qualified Type = null ; if ( proposal Kind == Completion Proposal . TYPE IMPORT ) { qualified Type = f Proposal . get Signature ( ) ; qualified Type Name = String . value Of ( Signature . to Char Array ( qualified Type ) ) ; } else if ( proposal Kind == Completion Proposal . METHOD IMPORT || proposal Kind == Completion Proposal . FIELD IMPORT ) { qualified Type = Signature . get Type Erasure ( f Proposal . get Declaration Signature ( ) ) ; qualified Type Name = String . value Of ( Signature . to Char Array ( qualified Type ) ) ; } else { Assert . is True ( BOOL ) ; } f Import Rewrite = create Import Rewrite ( ) ; if ( f Import Rewrite != null ) { if ( proposal Kind == Completion Proposal . TYPE IMPORT ) { String simple Type = f Import Rewrite . add Import ( qualified Type Name , f Import Context ) ; if ( f Parent Proposal Kind == Completion Proposal . METHOD REF ) { return simple Type + STRING ; } } else { String res = f Import Rewrite . add Static Import ( qualified Type Name , String . value Of ( f Proposal . get Name ( ) ) , proposal Kind == Completion Proposal . FIELD IMPORT , f Import Context ) ; int dot = res . last Index Of ( STRING ) ; if ( dot != - NUM ) { String type Name = f Import Rewrite . add Import ( res . substring ( NUM , dot ) , f Import Context ) ; return type Name + STRING ; } } return STRING ; } return qualified Type Name + STRING ; }
@ Suppress Warnings ( STRING ) public synchronized Object handle Data ( Map data , int action , boolean allow Child Events ) { Object result = null ; if ( data . contains Key ( get Key Attribute ( ) ) ) { boolean old Allow Events = allow Events ; allow Events = allow Child Events ; Process Var dataset = ( Process Var ) get ( data . get ( get Key Attribute ( ) ) ) ; if ( dataset == null ) { dataset = new Process Var ( ) ; dataset . set Key Attribute ( get Key Attribute ( ) ) ; } dataset . put All ( data , action , allow Child Events ) ; allow Events = old Allow Events ; result = put ( dataset . get Key Value ( ) , dataset , action ) ; } return ( result ) ; }
@ Suppress Warnings ( STRING ) public synchronized Object handle Data ( Map data , int action , boolean allow Child Events ) { Object result = null ; if ( data . contains Key ( get Key Attribute ( ) ) ) { boolean old Allow Events = allow Events ; allow Events = allow Child Events ; Process Var dataset = ( Process Var ) get ( data . get ( get Key Attribute ( ) ) ) ; if ( dataset == null ) { dataset = new Process Var ( ) ; dataset . set Key Attribute ( get Key Attribute ( ) ) ; } dataset . put All ( data , action , allow Child Events ) ; allow Events = old Allow Events ; result = put ( dataset . get Key Value ( ) , dataset , action ) ; } return ( result ) ; }
private Variable Reference add Primitive ( Test Case test , Primitive Statement < ? > old , int position ) throws Construction Failed Exception { logger . debug ( STRING ) ; Statement st = old . clone ( test ) ; return test . add Statement ( st , position ) ; }
private Variable Reference add Primitive ( Test Case test , Primitive Statement < ? > old , int position ) throws Construction Failed Exception { logger . debug ( STRING ) ; Statement st = old . clone ( test ) ; return test . add Statement ( st , position ) ; }
public Plain Text Converter ( ) { Simple Wiki Configuration config = null ; try { config = new Simple Wiki Configuration ( Wiki Constants . SWEBLE CONFIG ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } catch ( JAXB Exception e ) { e . print Stack Trace ( ) ; } this . config = config ; this . wrap Col = Integer . MAX VALUE ; this . enumerate Sections = BOOL ; }
public Plain Text Converter ( ) { Simple Wiki Configuration config = null ; try { config = new Simple Wiki Configuration ( Wiki Constants . SWEBLE CONFIG ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } catch ( JAXB Exception e ) { e . print Stack Trace ( ) ; } this . config = config ; this . wrap Col = Integer . MAX VALUE ; this . enumerate Sections = BOOL ; }
@ Suppress Warnings ( STRING ) private String next Literal ( boolean assign Offsets Only ) throws IO Exception { String Builder builder = null ; value Pos = - NUM ; value Length = NUM ; int i = NUM ; find Non Literal Character : while ( BOOL ) { for ( ; pos + i < limit ; i ++ ) { switch ( buffer [ pos + i ] ) { case STRING : case STRING : case STRING : case STRING : case STRING : check Lenient ( ) ; case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : break find Non Literal Character ; } } if ( i < buffer . length ) { if ( fill Buffer ( i + NUM ) ) { continue ; } else { buffer [ limit ] = STRING ; break ; } } if ( builder == null ) { builder = new String Builder ( ) ; } builder . append ( buffer , pos , i ) ; value Length += i ; pos += i ; i = NUM ; if ( ! fill Buffer ( NUM ) ) { break ; } } String result ; if ( assign Offsets Only && builder == null ) { value Pos = pos ; result = null ; } else if ( skipping ) { result = STRING ; } else if ( builder == null ) { result = string Pool . get ( buffer , pos , i ) ; } else { builder . append ( buffer , pos , i ) ; result = builder . to String ( ) ; } value Length += i ; pos += i ; return result ; }
@ Suppress Warnings ( STRING ) private String next Literal ( boolean assign Offsets Only ) throws IO Exception { String Builder builder = null ; value Pos = - NUM ; value Length = NUM ; int i = NUM ; find Non Literal Character : while ( BOOL ) { for ( ; pos + i < limit ; i ++ ) { switch ( buffer [ pos + i ] ) { case STRING : case STRING : case STRING : case STRING : case STRING : check Lenient ( ) ; case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : break find Non Literal Character ; } } if ( i < buffer . length ) { if ( fill Buffer ( i + NUM ) ) { continue ; } else { buffer [ limit ] = STRING ; break ; } } if ( builder == null ) { builder = new String Builder ( ) ; } builder . append ( buffer , pos , i ) ; value Length += i ; pos += i ; i = NUM ; if ( ! fill Buffer ( NUM ) ) { break ; } } String result ; if ( assign Offsets Only && builder == null ) { value Pos = pos ; result = null ; } else if ( skipping ) { result = STRING ; } else if ( builder == null ) { result = string Pool . get ( buffer , pos , i ) ; } else { builder . append ( buffer , pos , i ) ; result = builder . to String ( ) ; } value Length += i ; pos += i ; return result ; }
@ Suppress Warnings ( STRING ) private String next Literal ( boolean assign Offsets Only ) throws IO Exception { String Builder builder = null ; value Pos = - NUM ; value Length = NUM ; int i = NUM ; find Non Literal Character : while ( BOOL ) { for ( ; pos + i < limit ; i ++ ) { switch ( buffer [ pos + i ] ) { case STRING : case STRING : case STRING : case STRING : case STRING : check Lenient ( ) ; case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : break find Non Literal Character ; } } if ( i < buffer . length ) { if ( fill Buffer ( i + NUM ) ) { continue ; } else { buffer [ limit ] = STRING ; break ; } } if ( builder == null ) { builder = new String Builder ( ) ; } builder . append ( buffer , pos , i ) ; value Length += i ; pos += i ; i = NUM ; if ( ! fill Buffer ( NUM ) ) { break ; } } String result ; if ( assign Offsets Only && builder == null ) { value Pos = pos ; result = null ; } else if ( skipping ) { result = STRING ; } else if ( builder == null ) { result = string Pool . get ( buffer , pos , i ) ; } else { builder . append ( buffer , pos , i ) ; result = builder . to String ( ) ; } value Length += i ; pos += i ; return result ; }
@ Suppress Warnings ( STRING ) private String next Literal ( boolean assign Offsets Only ) throws IO Exception { String Builder builder = null ; value Pos = - NUM ; value Length = NUM ; int i = NUM ; find Non Literal Character : while ( BOOL ) { for ( ; pos + i < limit ; i ++ ) { switch ( buffer [ pos + i ] ) { case STRING : case STRING : case STRING : case STRING : case STRING : check Lenient ( ) ; case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : break find Non Literal Character ; } } if ( i < buffer . length ) { if ( fill Buffer ( i + NUM ) ) { continue ; } else { buffer [ limit ] = STRING ; break ; } } if ( builder == null ) { builder = new String Builder ( ) ; } builder . append ( buffer , pos , i ) ; value Length += i ; pos += i ; i = NUM ; if ( ! fill Buffer ( NUM ) ) { break ; } } String result ; if ( assign Offsets Only && builder == null ) { value Pos = pos ; result = null ; } else if ( skipping ) { result = STRING ; } else if ( builder == null ) { result = string Pool . get ( buffer , pos , i ) ; } else { builder . append ( buffer , pos , i ) ; result = builder . to String ( ) ; } value Length += i ; pos += i ; return result ; }
protected int inverse Translate Row ( int row ) { if ( enabled ) { return Arrays . binary Search ( row Map , row ) ; } else { return row ; } }
@ Override public boolean is File Modified ( long file Time Stamp , long end Offset ) { boolean is File Modified = BOOL ; if ( get Last Modified Time ( ) > file Time Stamp || get Size ( ) > end Offset ) { is File Modified = BOOL ; } return is File Modified ; }
public void add Feature Processor ( String name , Feature Processor fp ) { feature Processors . put ( name , fp ) ; }
public static String [ ] split String Into Array ( String value ) { String [ ] values = new String [ NUM ] ; if ( value != null && value . length ( ) > NUM ) { if ( value . index Of ( CIM Constants . COMMA SEPERATOR ) != - NUM ) { values = value . split ( STRING ) ; } else { values = new String [ NUM ] ; values [ NUM ] = value ; } } return values ; }
public static String [ ] split String Into Array ( String value ) { String [ ] values = new String [ NUM ] ; if ( value != null && value . length ( ) > NUM ) { if ( value . index Of ( CIM Constants . COMMA SEPERATOR ) != - NUM ) { values = value . split ( STRING ) ; } else { values = new String [ NUM ] ; values [ NUM ] = value ; } } return values ; }
Rules ( Workspace workspace ) { this . root = workspace . get Root ( ) ; this . team Hook = workspace . get Team Hook ( ) ; workspace . add Lifecycle Listener ( this ) ; }
final public static boolean is Multibyte Charset ( String java Encoding Name ) { return MULTIBYTE ENCODINGS . contains ( java Encoding Name . to Upper Case ( Locale . ENGLISH ) ) ; }
private boolean is Date Format String ( String string ) { if ( string . length ( ) < NUM ) { return BOOL ; } final int str Length = string . length ( ) ; final char start Char = string . char At ( NUM ) ; final char end Char = string . char At ( str Length - NUM ) ; if ( start Char == STRING || end Char == STRING ) { return BOOL ; } else if ( Character . is Letter ( start Char ) && string . char At ( NUM ) == STRING ) { return BOOL ; } final Matcher date Format Matcher = DATE FORMAT PATTERN . matcher ( string ) ; return date Format Matcher . find ( ) ; }
public void connect ( ) { connect ( this . log Writer ) ; }
public DD pow ( int exp ) { if ( exp == NUM ) return value Of ( NUM ) ; DD r = new DD ( this ) ; DD s = value Of ( NUM ) ; int n = Math . abs ( exp ) ; if ( n > NUM ) { while ( n > NUM ) { if ( n % NUM == NUM ) { s . self Multiply ( r ) ; } n /= NUM ; if ( n > NUM ) r = r . sqr ( ) ; } } else { s = r ; } if ( exp < NUM ) return s . reciprocal ( ) ; return s ; }
public DD pow ( int exp ) { if ( exp == NUM ) return value Of ( NUM ) ; DD r = new DD ( this ) ; DD s = value Of ( NUM ) ; int n = Math . abs ( exp ) ; if ( n > NUM ) { while ( n > NUM ) { if ( n % NUM == NUM ) { s . self Multiply ( r ) ; } n /= NUM ; if ( n > NUM ) r = r . sqr ( ) ; } } else { s = r ; } if ( exp < NUM ) return s . reciprocal ( ) ; return s ; }
public Wall Force ( float grav Const , float x1 , float y1 , float x2 , float y2 ) { params = new float [ ] { grav Const } ; min Values = new float [ ] { DEFAULT MIN GRAV CONSTANT } ; max Values = new float [ ] { DEFAULT MAX GRAV CONSTANT } ; this . x1 = x1 ; this . y1 = y1 ; this . x2 = x2 ; this . y2 = y2 ; dx = x2 - x1 ; dy = y2 - y1 ; float r = ( float ) Math . sqrt ( dx * dx + dy * dy ) ; if ( dx != NUM ) dx /= r ; if ( dy != NUM ) dy /= r ; }
public ID 3 v 23 Frame ( Byte Buffer byte Buffer , String logging Filename ) throws Invalid Frame Exception , Invalid Data Type Exception { set Logging Filename ( logging Filename ) ; read ( byte Buffer ) ; }
public static String compute Qualified Widget Type Name ( Node widget Node ) { if ( widget Node . get Node Type ( ) != Node . ELEMENT NODE ) { return null ; } String type Name = widget Node . get Local Name ( ) ; if ( type Name . length ( ) == NUM || Character . is Lower Case ( type Name . char At ( NUM ) ) ) { return null ; } String package Name = Ui Binder Utilities . get Package Name ( widget Node . get Namespace URI ( ) ) ; return package Name != null ? Java Utilities . get Qualified Type Name ( type Name , package Name ) : null ; }
public Expirer ( ) { expirer Thread = new Thread ( this , STRING + expirer Count ++ ) ; expirer Thread . set Daemon ( BOOL ) ; }
protected void ensure Route Consecutivity ( ) { boolean de Allocate Rest Of Route = BOOL ; for ( int i = idx Current Order + NUM ; i < orders . size ( ) ; i ++ ) { log . debug ( train Name + STRING + i ) ; Block Order bo = get Block Order At ( i ) ; O Block block = bo . get Block ( ) ; if ( ! block . is Allocated To ( this ) || ( block . get State ( ) & O Block . OCCUPIED ) != NUM ) { de Allocate Rest Of Route = BOOL ; } if ( de Allocate Rest Of Route ) { if ( block . is Allocated To ( this ) ) { log . info ( train Name + STRING + block . get Display Name ( ) + STRING ) ; block . de Allocate ( this ) ; } } } }
protected void ensure Route Consecutivity ( ) { boolean de Allocate Rest Of Route = BOOL ; for ( int i = idx Current Order + NUM ; i < orders . size ( ) ; i ++ ) { log . debug ( train Name + STRING + i ) ; Block Order bo = get Block Order At ( i ) ; O Block block = bo . get Block ( ) ; if ( ! block . is Allocated To ( this ) || ( block . get State ( ) & O Block . OCCUPIED ) != NUM ) { de Allocate Rest Of Route = BOOL ; } if ( de Allocate Rest Of Route ) { if ( block . is Allocated To ( this ) ) { log . info ( train Name + STRING + block . get Display Name ( ) + STRING ) ; block . de Allocate ( this ) ; } } } }
protected void ensure Route Consecutivity ( ) { boolean de Allocate Rest Of Route = BOOL ; for ( int i = idx Current Order + NUM ; i < orders . size ( ) ; i ++ ) { log . debug ( train Name + STRING + i ) ; Block Order bo = get Block Order At ( i ) ; O Block block = bo . get Block ( ) ; if ( ! block . is Allocated To ( this ) || ( block . get State ( ) & O Block . OCCUPIED ) != NUM ) { de Allocate Rest Of Route = BOOL ; } if ( de Allocate Rest Of Route ) { if ( block . is Allocated To ( this ) ) { log . info ( train Name + STRING + block . get Display Name ( ) + STRING ) ; block . de Allocate ( this ) ; } } } }
protected void ensure Route Consecutivity ( ) { boolean de Allocate Rest Of Route = BOOL ; for ( int i = idx Current Order + NUM ; i < orders . size ( ) ; i ++ ) { log . debug ( train Name + STRING + i ) ; Block Order bo = get Block Order At ( i ) ; O Block block = bo . get Block ( ) ; if ( ! block . is Allocated To ( this ) || ( block . get State ( ) & O Block . OCCUPIED ) != NUM ) { de Allocate Rest Of Route = BOOL ; } if ( de Allocate Rest Of Route ) { if ( block . is Allocated To ( this ) ) { log . info ( train Name + STRING + block . get Display Name ( ) + STRING ) ; block . de Allocate ( this ) ; } } } }
protected void ensure Route Consecutivity ( ) { boolean de Allocate Rest Of Route = BOOL ; for ( int i = idx Current Order + NUM ; i < orders . size ( ) ; i ++ ) { log . debug ( train Name + STRING + i ) ; Block Order bo = get Block Order At ( i ) ; O Block block = bo . get Block ( ) ; if ( ! block . is Allocated To ( this ) || ( block . get State ( ) & O Block . OCCUPIED ) != NUM ) { de Allocate Rest Of Route = BOOL ; } if ( de Allocate Rest Of Route ) { if ( block . is Allocated To ( this ) ) { log . info ( train Name + STRING + block . get Display Name ( ) + STRING ) ; block . de Allocate ( this ) ; } } } }
protected void ensure Route Consecutivity ( ) { boolean de Allocate Rest Of Route = BOOL ; for ( int i = idx Current Order + NUM ; i < orders . size ( ) ; i ++ ) { log . debug ( train Name + STRING + i ) ; Block Order bo = get Block Order At ( i ) ; O Block block = bo . get Block ( ) ; if ( ! block . is Allocated To ( this ) || ( block . get State ( ) & O Block . OCCUPIED ) != NUM ) { de Allocate Rest Of Route = BOOL ; } if ( de Allocate Rest Of Route ) { if ( block . is Allocated To ( this ) ) { log . info ( train Name + STRING + block . get Display Name ( ) + STRING ) ; block . de Allocate ( this ) ; } } } }
protected void ensure Route Consecutivity ( ) { boolean de Allocate Rest Of Route = BOOL ; for ( int i = idx Current Order + NUM ; i < orders . size ( ) ; i ++ ) { log . debug ( train Name + STRING + i ) ; Block Order bo = get Block Order At ( i ) ; O Block block = bo . get Block ( ) ; if ( ! block . is Allocated To ( this ) || ( block . get State ( ) & O Block . OCCUPIED ) != NUM ) { de Allocate Rest Of Route = BOOL ; } if ( de Allocate Rest Of Route ) { if ( block . is Allocated To ( this ) ) { log . info ( train Name + STRING + block . get Display Name ( ) + STRING ) ; block . de Allocate ( this ) ; } } } }
protected void ensure Route Consecutivity ( ) { boolean de Allocate Rest Of Route = BOOL ; for ( int i = idx Current Order + NUM ; i < orders . size ( ) ; i ++ ) { log . debug ( train Name + STRING + i ) ; Block Order bo = get Block Order At ( i ) ; O Block block = bo . get Block ( ) ; if ( ! block . is Allocated To ( this ) || ( block . get State ( ) & O Block . OCCUPIED ) != NUM ) { de Allocate Rest Of Route = BOOL ; } if ( de Allocate Rest Of Route ) { if ( block . is Allocated To ( this ) ) { log . info ( train Name + STRING + block . get Display Name ( ) + STRING ) ; block . de Allocate ( this ) ; } } } }
protected void ensure Route Consecutivity ( ) { boolean de Allocate Rest Of Route = BOOL ; for ( int i = idx Current Order + NUM ; i < orders . size ( ) ; i ++ ) { log . debug ( train Name + STRING + i ) ; Block Order bo = get Block Order At ( i ) ; O Block block = bo . get Block ( ) ; if ( ! block . is Allocated To ( this ) || ( block . get State ( ) & O Block . OCCUPIED ) != NUM ) { de Allocate Rest Of Route = BOOL ; } if ( de Allocate Rest Of Route ) { if ( block . is Allocated To ( this ) ) { log . info ( train Name + STRING + block . get Display Name ( ) + STRING ) ; block . de Allocate ( this ) ; } } } }
protected void ensure Route Consecutivity ( ) { boolean de Allocate Rest Of Route = BOOL ; for ( int i = idx Current Order + NUM ; i < orders . size ( ) ; i ++ ) { log . debug ( train Name + STRING + i ) ; Block Order bo = get Block Order At ( i ) ; O Block block = bo . get Block ( ) ; if ( ! block . is Allocated To ( this ) || ( block . get State ( ) & O Block . OCCUPIED ) != NUM ) { de Allocate Rest Of Route = BOOL ; } if ( de Allocate Rest Of Route ) { if ( block . is Allocated To ( this ) ) { log . info ( train Name + STRING + block . get Display Name ( ) + STRING ) ; block . de Allocate ( this ) ; } } } }
public static UUID time Based ( ) { return new UUID ( make MSB ( get Current Timestamp ( ) ) , CLOCK SEQ AND NODE ) ; }
public boolean is Empty ( ) { return filter . is Empty ( ) && query . is Empty ( ) && sort . is Empty ( ) ; }
public boolean is Empty ( ) { return filter . is Empty ( ) && query . is Empty ( ) && sort . is Empty ( ) ; }
public boolean is Empty ( ) { return filter . is Empty ( ) && query . is Empty ( ) && sort . is Empty ( ) ; }
public boolean is Empty ( ) { return filter . is Empty ( ) && query . is Empty ( ) && sort . is Empty ( ) ; }
public void draw String ( final Graphics g , final J Component c , final String text , final int underlined Char , final int x , final int y , final boolean is Enabled , final boolean is Selected ) { char lc , uc ; int index = - NUM , lci , uci ; if ( underlined Char != STRING ) { uc = Character . to Upper Case ( ( char ) underlined Char ) ; lc = Character . to Lower Case ( ( char ) underlined Char ) ; uci = text . index Of ( uc ) ; lci = text . index Of ( lc ) ; if ( uci == - NUM ) index = lci ; else if ( lci == - NUM ) index = uci ; else index = ( lci < uci ) ? lci : uci ; } Swing Utilities 2 . draw String Underline Char At ( c , g , text , index , x , y ) ; }
public void draw String ( final Graphics g , final J Component c , final String text , final int underlined Char , final int x , final int y , final boolean is Enabled , final boolean is Selected ) { char lc , uc ; int index = - NUM , lci , uci ; if ( underlined Char != STRING ) { uc = Character . to Upper Case ( ( char ) underlined Char ) ; lc = Character . to Lower Case ( ( char ) underlined Char ) ; uci = text . index Of ( uc ) ; lci = text . index Of ( lc ) ; if ( uci == - NUM ) index = lci ; else if ( lci == - NUM ) index = uci ; else index = ( lci < uci ) ? lci : uci ; } Swing Utilities 2 . draw String Underline Char At ( c , g , text , index , x , y ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
private void log ( Log Entry Type type , String tag , String message ) { if ( type . ordinal ( ) >= m Log Level . ordinal ( ) ) { Log Entry log Entry = new Log Entry ( type , tag , message ) ; log Entry . write To Log Cat ( ) ; m Entry List . add ( log Entry ) ; } }
private double distance D 2 ( double [ ] f , double d1 ) { return Math . sqrt ( Math . pow ( norm Vector ( f ) , NUM ) - Math . pow ( d1 , NUM ) ) ; }
@ Override public final String to String ( ) { String Builder cab = new String Builder ( NUM + get Hop Count ( ) * NUM ) ; cab . append ( STRING ) ; if ( this . local Address != null ) { cab . append ( this . local Address ) ; cab . append ( STRING ) ; } cab . append ( STRING ) ; if ( this . tunnelled == Tunnel Type . TUNNELLED ) cab . append ( STRING ) ; if ( this . layered == Layer Type . LAYERED ) cab . append ( STRING ) ; if ( this . secure ) cab . append ( STRING ) ; cab . append ( STRING ) ; if ( this . proxy Chain != null ) { for ( Http Host a Proxy Chain : this . proxy Chain ) { cab . append ( a Proxy Chain ) ; cab . append ( STRING ) ; } } cab . append ( this . target Host ) ; cab . append ( STRING ) ; return cab . to String ( ) ; }
public static Date updated ( Date self , Map < Object , Integer > updates ) { Calendar cal = Calendar . get Instance ( ) ; cal . set Time ( self ) ; set ( cal , updates ) ; return cal . get Time ( ) ; }
public static Date updated ( Date self , Map < Object , Integer > updates ) { Calendar cal = Calendar . get Instance ( ) ; cal . set Time ( self ) ; set ( cal , updates ) ; return cal . get Time ( ) ; }
protected final void unregister Data Source ( Data Source removed ) { unregister Data Sources ( Collections . singleton ( removed ) ) ; }
public static String del I ( String id ) { return Test Harness . delete By Id ( id ) ; }
public int receive From Data Socket ( byte [ ] buf ) { int bytes Read ; if ( data Socket == null ) { Log . i ( TAG , STRING ) ; return - NUM ; } if ( ! data Socket . is Connected ( ) ) { Log . i ( TAG , STRING ) ; return - NUM ; } Input Stream in ; try { in = data Socket . get Input Stream ( ) ; while ( ( bytes Read = in . read ( buf , NUM , buf . length ) ) == NUM ) { } if ( bytes Read == - NUM ) { return - NUM ; } } catch ( IO Exception e ) { Log . i ( TAG , STRING ) ; return NUM ; } local Data Socket . report Traffic ( bytes Read ) ; return bytes Read ; }
public int receive From Data Socket ( byte [ ] buf ) { int bytes Read ; if ( data Socket == null ) { Log . i ( TAG , STRING ) ; return - NUM ; } if ( ! data Socket . is Connected ( ) ) { Log . i ( TAG , STRING ) ; return - NUM ; } Input Stream in ; try { in = data Socket . get Input Stream ( ) ; while ( ( bytes Read = in . read ( buf , NUM , buf . length ) ) == NUM ) { } if ( bytes Read == - NUM ) { return - NUM ; } } catch ( IO Exception e ) { Log . i ( TAG , STRING ) ; return NUM ; } local Data Socket . report Traffic ( bytes Read ) ; return bytes Read ; }
public void add New Spawn Map ( Spawn Map spawn Map ) { if ( templates == null ) { templates = new Array List < Spawn Map > ( ) ; } templates . add ( spawn Map ) ; }
public void add New Spawn Map ( Spawn Map spawn Map ) { if ( templates == null ) { templates = new Array List < Spawn Map > ( ) ; } templates . add ( spawn Map ) ; }
public static void create Path ( String path , boolean must Create ) throws IO Exception { File fpath = new File ( path ) ; if ( fpath . exists ( ) && must Create ) throw new IO Exception ( path + STRING ) ; else if ( ! fpath . mkdirs ( ) ) throw new IO Exception ( STRING + path ) ; }
public void add Exception Message ( Exception Message exception Message ) { m exception Messages . add Element ( exception Message ) ; Enumeration < Exception Context > enumeration ; enumeration = m exception Contexts . elements ( ) ; while ( enumeration . has More Elements ( ) ) { add Exception Context ( enumeration . next Element ( ) ) ; } }
protected void Create Charset ( Offset Item charset Ref , int nglyphs ) { Output List . add Last ( new Marker Item ( charset Ref ) ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( new U Int 16 Item ( ( char ) NUM ) ) ; Output List . add Last ( new U Int 16 Item ( ( char ) ( nglyphs - NUM ) ) ) ; }
protected void Create Charset ( Offset Item charset Ref , int nglyphs ) { Output List . add Last ( new Marker Item ( charset Ref ) ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( new U Int 16 Item ( ( char ) NUM ) ) ; Output List . add Last ( new U Int 16 Item ( ( char ) ( nglyphs - NUM ) ) ) ; }
protected void Create Charset ( Offset Item charset Ref , int nglyphs ) { Output List . add Last ( new Marker Item ( charset Ref ) ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( new U Int 16 Item ( ( char ) NUM ) ) ; Output List . add Last ( new U Int 16 Item ( ( char ) ( nglyphs - NUM ) ) ) ; }
protected void Create Charset ( Offset Item charset Ref , int nglyphs ) { Output List . add Last ( new Marker Item ( charset Ref ) ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM ) ) ; Output List . add Last ( new U Int 16 Item ( ( char ) NUM ) ) ; Output List . add Last ( new U Int 16 Item ( ( char ) ( nglyphs - NUM ) ) ) ; }
public Itinerary ( Street Segment street Segment , int access Index , Zoned Date Time from Time Date ZD ) { transfers = NUM ; waiting Time = NUM ; walk Time = duration = street Segment . duration ; distance = street Segment . distance ; transit Time = NUM ; start Time = from Time Date ZD ; end Time = from Time Date ZD . plus Seconds ( street Segment . duration ) ; Point To Point Connection point To Point Connection = new Point To Point Connection ( access Index ) ; connection = point To Point Connection ; }
public Itinerary ( Street Segment street Segment , int access Index , Zoned Date Time from Time Date ZD ) { transfers = NUM ; waiting Time = NUM ; walk Time = duration = street Segment . duration ; distance = street Segment . distance ; transit Time = NUM ; start Time = from Time Date ZD ; end Time = from Time Date ZD . plus Seconds ( street Segment . duration ) ; Point To Point Connection point To Point Connection = new Point To Point Connection ( access Index ) ; connection = point To Point Connection ; }
private static boolean is Retina ( ) { if ( System Info . is Apple Jvm ) { return has Apple Retina Device ( ) ; } if ( System Info . is Mac ) { Graphics Environment e = Graphics Environment . get Local Graphics Environment ( ) ; Graphics Device [ ] devices = e . get Screen Devices ( ) ; for ( Graphics Device device : devices ) { if ( is Oracle Mac Retina Device ( device ) ) { return BOOL ; } } } return BOOL ; }
private static boolean is Retina ( ) { if ( System Info . is Apple Jvm ) { return has Apple Retina Device ( ) ; } if ( System Info . is Mac ) { Graphics Environment e = Graphics Environment . get Local Graphics Environment ( ) ; Graphics Device [ ] devices = e . get Screen Devices ( ) ; for ( Graphics Device device : devices ) { if ( is Oracle Mac Retina Device ( device ) ) { return BOOL ; } } } return BOOL ; }
protected static < T > void add Items ( Collection < T > collection , T [ ] elements ) { if ( elements != null ) { for ( T element : elements ) { collection . add ( element ) ; } } }
public Iterator < F > filter Iterator ( ) { return new Iterator Wrapper ( m Filters . iterator ( ) ) ; }
public Iterator < F > filter Iterator ( ) { return new Iterator Wrapper ( m Filters . iterator ( ) ) ; }
public Observable < Api . Info > info ( String username ) { return api . info ( username , null ) ; }
public final void try Claim Draw ( String str ) { if ( str . starts With ( STRING ) ) { String draw Cmd = str . substring ( str . index Of ( STRING ) + NUM ) ; handle Draw Cmd ( draw Cmd , BOOL ) ; } }
public final void try Claim Draw ( String str ) { if ( str . starts With ( STRING ) ) { String draw Cmd = str . substring ( str . index Of ( STRING ) + NUM ) ; handle Draw Cmd ( draw Cmd , BOOL ) ; } }
public final void try Claim Draw ( String str ) { if ( str . starts With ( STRING ) ) { String draw Cmd = str . substring ( str . index Of ( STRING ) + NUM ) ; handle Draw Cmd ( draw Cmd , BOOL ) ; } }
public File Write Stream ( File Output Stream fos ) { super ( null , fos ) ; os = fos ; }
public void add Subscription ( String subscription Channel , int stream Id , Fragment Handler fragment Handler ) { if ( ! has Subscription For Channel ( subscription Channel ) ) { debug ( STRING , subscription Channel ) ; Subscription subscription = aeron . add Subscription ( subscription Channel , stream Id ) ; debug ( STRING , subscription Channel ) ; Subscription Group subscription Group = new Subscription Group ( subscription Channel , subscription , fragment Handler ) ; subscription Groups . add ( subscription Group ) ; debug ( STRING , subscription Channel ) ; } else { debug ( STRING , subscription Channel ) ; } }
private void add To Circle Of Trust ( Base Config Type config , String realm , String entity Id ) { String class Method = STRING ; try { if ( config != null ) { Map attr = IDFF Meta Utils . get Attributes ( config ) ; List cot Attr = ( List ) attr . get ( COT Constants . COT LIST ) ; List cot List = new Array List ( cot Attr ) ; if ( ( cot List != null ) && ! cot List . is Empty ( ) ) { for ( Iterator iter = cot List . iterator ( ) ; iter . has Next ( ) ; ) { String cot Name = ( String ) iter . next ( ) ; try { cot Manager . add Circle Of Trust Member ( realm , cot Name , COT Constants . IDFF , entity Id ) ; } catch ( COT Exception ce ) { debug . error ( class Method + cot Name + STRING ) ; } } } } } catch ( Exception e ) { debug . error ( class Method + STRING + entity Id + STRING , e ) ; } }
public int add Missing Columns ( M Print Format pf ) { log . config ( pf . to String ( ) ) ; String sql = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; int counter = NUM ; try { pstmt = DB . prepare Statement ( sql , pf . get Trx Name ( ) ) ; pstmt . set Int ( NUM , pf . get AD Print Format ID ( ) ) ; pstmt . set Int ( NUM , pf . get AD Table ID ( ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { int AD Column ID = rs . get Int ( NUM ) ; String Column Name = rs . get String ( NUM ) ; M Print Format Item pfi = M Print Format Item . create From Column ( pf , AD Column ID , NUM ) ; if ( pfi . get ID ( ) != NUM ) log . fine ( STRING + ++ counter + STRING + Column Name ) ; else log . warning ( STRING + Column Name ) ; } } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( counter == NUM ) log . fine ( STRING ) ; else log . fine ( STRING + counter ) ; return counter ; }
public Jar Class Loader [ ] deploy ( final String jar Names [ ] , final byte [ ] [ ] jar Bytes ) throws IO Exception , Class Not Found Exception { Jar Class Loader [ ] jar Class Loaders = new Jar Class Loader [ jar Names . length ] ; verify Writable Deploy Directory ( ) ; lock . lock ( ) ; try { for ( int i = NUM ; i < jar Names . length ; i ++ ) { if ( ! Jar Class Loader . is Valid Jar Content ( jar Bytes [ i ] ) ) { throw new Illegal Argument Exception ( STRING + jar Names [ i ] ) ; } } for ( int i = NUM ; i < jar Names . length ; i ++ ) { jar Class Loaders [ i ] = deploy Without Registering ( jar Names [ i ] , jar Bytes [ i ] ) ; } for ( Jar Class Loader jar Class Loader : jar Class Loaders ) { if ( jar Class Loader != null ) { jar Class Loader . load Classes And Register Functions ( ) ; } } } finally { lock . unlock ( ) ; } return jar Class Loaders ; }
public final boolean execute ( ) throws SQL Exception { return m ps . execute ( ) ; }
private void add To Set ( Object Xml Persist persist , I File file , String set Name ) throws IO Exception , Core Exception { Collection < Graph Edge Matcher Descriptor > update Set = load Edge Matchers ( persist , file ) ; persist Updated Bundle ( persist , file , update Set , set Name ) ; }
public static Object normalize Int And Long Values ( String data , Data Type actual Data Type ) { if ( null == data ) { return null ; } try { Object parsed Value = null ; switch ( actual Data Type ) { case INT : parsed Value = Integer . parse Int ( data ) ; break ; case LONG : parsed Value = Long . parse Long ( data ) ; break ; default : return data ; } if ( null != parsed Value ) { return data ; } return null ; } catch ( Number Format Exception ex ) { return null ; } }
public static Object normalize Int And Long Values ( String data , Data Type actual Data Type ) { if ( null == data ) { return null ; } try { Object parsed Value = null ; switch ( actual Data Type ) { case INT : parsed Value = Integer . parse Int ( data ) ; break ; case LONG : parsed Value = Long . parse Long ( data ) ; break ; default : return data ; } if ( null != parsed Value ) { return data ; } return null ; } catch ( Number Format Exception ex ) { return null ; } }
public static Object normalize Int And Long Values ( String data , Data Type actual Data Type ) { if ( null == data ) { return null ; } try { Object parsed Value = null ; switch ( actual Data Type ) { case INT : parsed Value = Integer . parse Int ( data ) ; break ; case LONG : parsed Value = Long . parse Long ( data ) ; break ; default : return data ; } if ( null != parsed Value ) { return data ; } return null ; } catch ( Number Format Exception ex ) { return null ; } }
public static Object normalize Int And Long Values ( String data , Data Type actual Data Type ) { if ( null == data ) { return null ; } try { Object parsed Value = null ; switch ( actual Data Type ) { case INT : parsed Value = Integer . parse Int ( data ) ; break ; case LONG : parsed Value = Long . parse Long ( data ) ; break ; default : return data ; } if ( null != parsed Value ) { return data ; } return null ; } catch ( Number Format Exception ex ) { return null ; } }
public static Object normalize Int And Long Values ( String data , Data Type actual Data Type ) { if ( null == data ) { return null ; } try { Object parsed Value = null ; switch ( actual Data Type ) { case INT : parsed Value = Integer . parse Int ( data ) ; break ; case LONG : parsed Value = Long . parse Long ( data ) ; break ; default : return data ; } if ( null != parsed Value ) { return data ; } return null ; } catch ( Number Format Exception ex ) { return null ; } }
public static Object normalize Int And Long Values ( String data , Data Type actual Data Type ) { if ( null == data ) { return null ; } try { Object parsed Value = null ; switch ( actual Data Type ) { case INT : parsed Value = Integer . parse Int ( data ) ; break ; case LONG : parsed Value = Long . parse Long ( data ) ; break ; default : return data ; } if ( null != parsed Value ) { return data ; } return null ; } catch ( Number Format Exception ex ) { return null ; } }
public Iterable < Notification > skip ( @ Nonnull final Iterable < Notification > notifications , final long start Id , final boolean inclusive , final int limit Size ) { Objects . require Non Null ( notifications ) ; final int position = index Of ( notifications , start Id ) ; if ( position == - NUM ) { return Iterables . limit ( notifications , limit Size ) ; } if ( inclusive ) { return Iterables . limit ( Iterables . skip ( notifications , position ) , limit Size ) ; } return Iterables . limit ( Iterables . skip ( notifications , position + NUM ) , limit Size ) ; }
public Statement Metric [ ] flush Metrics ( ) { rw Lock . acquire Write Lock ( ) ; try { boolean is Empty = BOOL ; if ( current Last Element == - NUM ) { is Empty = BOOL ; } if ( is Report Inactive ) { for ( int i = NUM ; i <= current Last Element ; i ++ ) { if ( statement Names [ i ] != null ) { metrics [ i ] = new Statement Metric ( engine URI , statement Names [ i ] ) ; } } } if ( ( current Last Element > - NUM ) && ( ! removed Statement Names . is Empty ( ) ) ) { for ( int i = NUM ; i <= current Last Element ; i ++ ) { if ( removed Statement Names . contains ( statement Names [ i ] ) ) { statement Names [ i ] = null ; } } } while ( ( current Last Element != - NUM ) && ( statement Names [ current Last Element ] == null ) ) { current Last Element -- ; } if ( is Empty ) { return null ; } Statement Metric [ ] new Metrics = new Statement Metric [ metrics . length ] ; Statement Metric [ ] old Metrics = metrics ; metrics = new Metrics ; return old Metrics ; } finally { rw Lock . release Write Lock ( ) ; } }
public Statement Metric [ ] flush Metrics ( ) { rw Lock . acquire Write Lock ( ) ; try { boolean is Empty = BOOL ; if ( current Last Element == - NUM ) { is Empty = BOOL ; } if ( is Report Inactive ) { for ( int i = NUM ; i <= current Last Element ; i ++ ) { if ( statement Names [ i ] != null ) { metrics [ i ] = new Statement Metric ( engine URI , statement Names [ i ] ) ; } } } if ( ( current Last Element > - NUM ) && ( ! removed Statement Names . is Empty ( ) ) ) { for ( int i = NUM ; i <= current Last Element ; i ++ ) { if ( removed Statement Names . contains ( statement Names [ i ] ) ) { statement Names [ i ] = null ; } } } while ( ( current Last Element != - NUM ) && ( statement Names [ current Last Element ] == null ) ) { current Last Element -- ; } if ( is Empty ) { return null ; } Statement Metric [ ] new Metrics = new Statement Metric [ metrics . length ] ; Statement Metric [ ] old Metrics = metrics ; metrics = new Metrics ; return old Metrics ; } finally { rw Lock . release Write Lock ( ) ; } }
public Statement Metric [ ] flush Metrics ( ) { rw Lock . acquire Write Lock ( ) ; try { boolean is Empty = BOOL ; if ( current Last Element == - NUM ) { is Empty = BOOL ; } if ( is Report Inactive ) { for ( int i = NUM ; i <= current Last Element ; i ++ ) { if ( statement Names [ i ] != null ) { metrics [ i ] = new Statement Metric ( engine URI , statement Names [ i ] ) ; } } } if ( ( current Last Element > - NUM ) && ( ! removed Statement Names . is Empty ( ) ) ) { for ( int i = NUM ; i <= current Last Element ; i ++ ) { if ( removed Statement Names . contains ( statement Names [ i ] ) ) { statement Names [ i ] = null ; } } } while ( ( current Last Element != - NUM ) && ( statement Names [ current Last Element ] == null ) ) { current Last Element -- ; } if ( is Empty ) { return null ; } Statement Metric [ ] new Metrics = new Statement Metric [ metrics . length ] ; Statement Metric [ ] old Metrics = metrics ; metrics = new Metrics ; return old Metrics ; } finally { rw Lock . release Write Lock ( ) ; } }
protected Properties create Properties ( URL location ) throws IO Exception { Input Stream is = null ; if ( location != null ) { is = location . open Stream ( ) ; } Properties tmp Properties = new Properties ( ) ; if ( is != null ) { tmp Properties . load ( is ) ; } return tmp Properties ; }
protected Properties create Properties ( URL location ) throws IO Exception { Input Stream is = null ; if ( location != null ) { is = location . open Stream ( ) ; } Properties tmp Properties = new Properties ( ) ; if ( is != null ) { tmp Properties . load ( is ) ; } return tmp Properties ; }
protected Properties create Properties ( URL location ) throws IO Exception { Input Stream is = null ; if ( location != null ) { is = location . open Stream ( ) ; } Properties tmp Properties = new Properties ( ) ; if ( is != null ) { tmp Properties . load ( is ) ; } return tmp Properties ; }
public D Authority Key Identifier ( J Dialog parent , Public Key authority Public Key , X500 Name authority Cert Name , Big Integer authority Cert Serial Number ) { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; this . authority Public Key = authority Public Key ; init Components ( ) ; prepopulate With Authority Cert Details ( authority Cert Name , authority Cert Serial Number ) ; }
protected void reset ( ) throws XNI Exception { int count = f Components . size ( ) ; for ( int i = NUM ; i < count ; i ++ ) { XML Component c = ( XML Component ) f Components . get ( i ) ; c . reset ( this ) ; } }
protected void reset ( ) throws XNI Exception { int count = f Components . size ( ) ; for ( int i = NUM ; i < count ; i ++ ) { XML Component c = ( XML Component ) f Components . get ( i ) ; c . reset ( this ) ; } }
protected void reset ( ) throws XNI Exception { int count = f Components . size ( ) ; for ( int i = NUM ; i < count ; i ++ ) { XML Component c = ( XML Component ) f Components . get ( i ) ; c . reset ( this ) ; } }
public void unlock ( final T tx ) { if ( DEBUG ) log . debug ( STRING ) ; lock . lock ( ) ; if ( DEBUG ) log . debug ( STRING ) ; try { assert Not Dead ( ) ; assert Owns Lock ( tx ) ; if ( queue . remove ( ) != tx ) { throw new Assertion Error ( ) ; } if ( waits For != null ) { final Iterator < T > itr = queue . iterator ( ) ; synchronized ( waits For ) { while ( itr . has Next ( ) ) { final T pending Tx = itr . next ( ) ; try { waits For . remove Edge ( pending Tx , tx ) ; } catch ( Throwable t ) { log . warn ( t . get Message ( ) , t ) ; } } } } if ( queue . is Empty ( ) ) { if ( INFO ) log . info ( STRING ) ; return ; } if ( INFO ) log . info ( STRING ) ; available . signal All ( ) ; } finally { lock . unlock ( ) ; if ( DEBUG ) log . debug ( STRING ) ; } }
private void convert And Fill Byte Buffer List To Byte Array List ( List < byte [ ] > dictionary Values , List < Byte Buffer > dictionary Value Buffer List ) { for ( Byte Buffer buffer : dictionary Value Buffer List ) { int length = buffer . limit ( ) ; byte [ ] value = new byte [ length ] ; buffer . get ( value , NUM , value . length ) ; dictionary Values . add ( value ) ; } }
public void remove Header ( Header header ) { if ( header == null ) { return ; } headers . remove ( header ) ; }
public boolean remove Entry ( Entry e , int data Set Index ) { if ( e == null || data Set Index >= m Data Sets . size ( ) ) return BOOL ; I Data Set set = m Data Sets . get ( data Set Index ) ; if ( set != null ) { boolean removed = set . remove Entry ( e ) ; if ( removed ) { calc Min Max ( ) ; } return removed ; } return BOOL ; }
public static Request Security Token Response parse XML ( String xml ) throws WS Federation Exception { Document doc = XML Utils . to DOM Document ( xml , debug ) ; Element root = doc . get Document Element ( ) ; return new Request Security Token Response ( root ) ; }
public static Request Security Token Response parse XML ( String xml ) throws WS Federation Exception { Document doc = XML Utils . to DOM Document ( xml , debug ) ; Element root = doc . get Document Element ( ) ; return new Request Security Token Response ( root ) ; }
public static Request Security Token Response parse XML ( String xml ) throws WS Federation Exception { Document doc = XML Utils . to DOM Document ( xml , debug ) ; Element root = doc . get Document Element ( ) ; return new Request Security Token Response ( root ) ; }
protected static @ Not Null String convert Map To Groovy Source ( @ Not Null Map < String , Object > map ) { String Builder sb = new String Builder ( ) ; for ( Map . Entry < String , Object > entry : map . entry Set ( ) ) { if ( sb . length ( ) > NUM ) { sb . append ( STRING ) ; } sb . append ( entry . get Key ( ) ) ; sb . append ( STRING ) ; sb . append ( convert Value To Groovy Source ( entry . get Value ( ) ) ) ; } return sb . to String ( ) ; }
protected static @ Not Null String convert Map To Groovy Source ( @ Not Null Map < String , Object > map ) { String Builder sb = new String Builder ( ) ; for ( Map . Entry < String , Object > entry : map . entry Set ( ) ) { if ( sb . length ( ) > NUM ) { sb . append ( STRING ) ; } sb . append ( entry . get Key ( ) ) ; sb . append ( STRING ) ; sb . append ( convert Value To Groovy Source ( entry . get Value ( ) ) ) ; } return sb . to String ( ) ; }
public static Builder create Builder ( Abstract Managed Object Definition < ? , ? > d , String property Name ) { return new Builder ( d , property Name ) ; }
public static int fuzzy Compare ( double a , double b , double tolerance ) { if ( tolerance < NUM ) throw new Illegal Argument Exception ( STRING ) ; double difference = a - b ; return ( Math . abs ( difference ) <= tolerance ? NUM : ( difference > NUM ? NUM : - NUM ) ) ; }
private Hash Map < String , byte [ ] > read Chars ( byte [ ] d ) { Hash Map < String , byte [ ] > hm = new Hash Map < String , byte [ ] > ( ) ; int i = find Slash Name ( d , STRING ) ; if ( i < NUM ) { return hm ; } PS Parser psp = new PS Parser ( d , i ) ; while ( BOOL ) { String s = psp . read Thing ( ) ; char c = s . char At ( NUM ) ; if ( c == STRING ) { int len = Integer . parse Int ( psp . read Thing ( ) ) ; String go = psp . read Thing ( ) ; if ( go . equals ( STRING ) || go . equals ( STRING ) ) { psp . set Loc ( psp . get Loc ( ) + NUM ) ; byte [ ] line = psp . get N Encoded Bytes ( len , password , len IV ) ; hm . put ( s . substring ( NUM ) , line ) ; } } else if ( s . equals ( STRING ) ) { break ; } } return hm ; }
private int parse Encryption Context ( final byte [ ] b , final int off ) throws Parse Exception { final int len = b . length - off ; if ( len >= encryption Context Len ) { encryption Context = Arrays . copy Of Range ( b , off , off + encryption Context Len ) ; return encryption Context Len ; } else { throw new Parse Exception ( STRING ) ; } }
private String print O Format ( int x ) { String sx = null ; if ( x == Integer . MIN VALUE ) sx = STRING ; else if ( x < NUM ) { String t = Integer . to String ( ( ~ ( - x - NUM ) ) ^ Integer . MIN VALUE , NUM ) ; switch ( t . length ( ) ) { case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t . substring ( NUM ) ; break ; } } else sx = Integer . to String ( x , NUM ) ; return print O Format ( sx ) ; }
private String print O Format ( int x ) { String sx = null ; if ( x == Integer . MIN VALUE ) sx = STRING ; else if ( x < NUM ) { String t = Integer . to String ( ( ~ ( - x - NUM ) ) ^ Integer . MIN VALUE , NUM ) ; switch ( t . length ( ) ) { case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t . substring ( NUM ) ; break ; } } else sx = Integer . to String ( x , NUM ) ; return print O Format ( sx ) ; }
private Movie Set Chooser Model ( ) { set Name ( BUNDLE . get String ( STRING ) ) ; }
protected void fill Path ( ) { mPS Stream . println ( m Fill Op Str ) ; }
public void read ( Input Stream in ) throws IO Exception { IXML Parser parser ; try { parser = XML Parser Factory . create Default XML Parser ( ) ; } catch ( Exception ex ) { Internal Error e = new Internal Error ( STRING ) ; e . init Cause ( ex ) ; throw e ; } IXML Reader reader = new Std XML Reader ( in ) ; parser . set Reader ( reader ) ; IXML Element document ; try { document = ( IXML Element ) parser . parse ( ) ; } catch ( XML Exception ex ) { IO Exception e = new IO Exception ( ex . get Message ( ) ) ; e . init Cause ( ex ) ; throw e ; } read ( document ) ; }
public byte [ ] encrypt ( byte [ ] data ) throws Crypto Exception { try { byte [ ] ciphertext ; if ( use Explicit Iv ) { ciphertext = Array Converter . concatenate ( encrypt Iv . get IV ( ) , encrypt Cipher . do Final ( data ) ) ; } else { encrypt Cipher . init ( Cipher . ENCRYPT MODE , encrypt Key , encrypt Iv ) ; ciphertext = encrypt Cipher . do Final ( data ) ; encrypt Iv = new Iv Parameter Spec ( Arrays . copy Of Range ( ciphertext , ciphertext . length - decrypt Cipher . get Block Size ( ) , ciphertext . length ) ) ; } return ciphertext ; } catch ( Bad Padding Exception | Illegal Block Size Exception | Invalid Algorithm Parameter Exception | Invalid Key Exception ex ) { throw new Crypto Exception ( ex ) ; } }
public byte [ ] encrypt ( byte [ ] data ) throws Crypto Exception { try { byte [ ] ciphertext ; if ( use Explicit Iv ) { ciphertext = Array Converter . concatenate ( encrypt Iv . get IV ( ) , encrypt Cipher . do Final ( data ) ) ; } else { encrypt Cipher . init ( Cipher . ENCRYPT MODE , encrypt Key , encrypt Iv ) ; ciphertext = encrypt Cipher . do Final ( data ) ; encrypt Iv = new Iv Parameter Spec ( Arrays . copy Of Range ( ciphertext , ciphertext . length - decrypt Cipher . get Block Size ( ) , ciphertext . length ) ) ; } return ciphertext ; } catch ( Bad Padding Exception | Illegal Block Size Exception | Invalid Algorithm Parameter Exception | Invalid Key Exception ex ) { throw new Crypto Exception ( ex ) ; } }
public boolean has Sub Attributes ( ) { return sub Attributes != null && ! sub Attributes . is Empty ( ) ; }
public String crop ( String string ) { if ( ( null == string ) || ( string . length ( ) <= effective String Length ) ) { return string ; } if ( effective String Length == NUM ) { return STRING ; } String cropped = string . substring ( NUM , effective String Length ) ; if ( USE TRAILING DOTS ) { cropped = append Trailing Dots ( cropped ) ; } return cropped ; }
public void filled Polygon ( double [ ] x , double [ ] y ) { int n = x . length ; General Path path = new General Path ( ) ; path . move To ( ( float ) scale X ( x [ NUM ] ) , ( float ) scale Y ( y [ NUM ] ) ) ; for ( int i = NUM ; i < n ; i ++ ) path . line To ( ( float ) scale X ( x [ i ] ) , ( float ) scale Y ( y [ i ] ) ) ; path . close Path ( ) ; offscreen . fill ( path ) ; draw ( ) ; }
public void filled Polygon ( double [ ] x , double [ ] y ) { int n = x . length ; General Path path = new General Path ( ) ; path . move To ( ( float ) scale X ( x [ NUM ] ) , ( float ) scale Y ( y [ NUM ] ) ) ; for ( int i = NUM ; i < n ; i ++ ) path . line To ( ( float ) scale X ( x [ i ] ) , ( float ) scale Y ( y [ i ] ) ) ; path . close Path ( ) ; offscreen . fill ( path ) ; draw ( ) ; }
@ Transactional public void delete ( T persistent Object ) { if ( ! entity Manager . contains ( persistent Object ) ) { persistent Object = entity Manager . merge ( persistent Object ) ; } entity Manager . remove ( persistent Object ) ; }
public void reload ( String path ) throws Tomcat Manager Exception , IO Exception { invoke ( STRING + URL Encoder . encode ( path , this . charset ) ) ; }
public void reload ( String path ) throws Tomcat Manager Exception , IO Exception { invoke ( STRING + URL Encoder . encode ( path , this . charset ) ) ; }
public void dont Display Metrics ( List < String > metrics Not To Display ) { for ( String s : metrics Not To Display ) { m metrics To Display . remove ( s . to Lower Case ( ) ) ; } }
public void clear Cache ( ) { if ( m Memory Cache != null ) { m Memory Cache . evict All ( ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } synchronized ( m Disk Cache Lock ) { m Disk Cache Starting = BOOL ; if ( m Disk Lru Cache != null && ! m Disk Lru Cache . is Closed ( ) ) { try { m Disk Lru Cache . delete ( ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( IO Exception e ) { Log . e ( TAG , STRING + e ) ; } m Disk Lru Cache = null ; init Disk Cache ( ) ; } } }
public void clear Cache ( ) { if ( m Memory Cache != null ) { m Memory Cache . evict All ( ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } synchronized ( m Disk Cache Lock ) { m Disk Cache Starting = BOOL ; if ( m Disk Lru Cache != null && ! m Disk Lru Cache . is Closed ( ) ) { try { m Disk Lru Cache . delete ( ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( IO Exception e ) { Log . e ( TAG , STRING + e ) ; } m Disk Lru Cache = null ; init Disk Cache ( ) ; } } }
public void clear Cache ( ) { if ( m Memory Cache != null ) { m Memory Cache . evict All ( ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } synchronized ( m Disk Cache Lock ) { m Disk Cache Starting = BOOL ; if ( m Disk Lru Cache != null && ! m Disk Lru Cache . is Closed ( ) ) { try { m Disk Lru Cache . delete ( ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( IO Exception e ) { Log . e ( TAG , STRING + e ) ; } m Disk Lru Cache = null ; init Disk Cache ( ) ; } } }
public void clear Cache ( ) { if ( m Memory Cache != null ) { m Memory Cache . evict All ( ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } synchronized ( m Disk Cache Lock ) { m Disk Cache Starting = BOOL ; if ( m Disk Lru Cache != null && ! m Disk Lru Cache . is Closed ( ) ) { try { m Disk Lru Cache . delete ( ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( IO Exception e ) { Log . e ( TAG , STRING + e ) ; } m Disk Lru Cache = null ; init Disk Cache ( ) ; } } }
public T peek ( ) { if ( heap . size ( ) > NUM ) return heap . element At ( TOP ) ; else return null ; }
public void add Request ( Action Request request , Limited Queue Info queue Info ) { String request Id = Penn Station . request Action ( request , queue Info ) ; synchronized ( this ) { m Last Request Id By Type . put ( request . type ( ) , request Id ) ; m Request Ids . add ( request Id ) ; } }
public void add Request ( Action Request request , Limited Queue Info queue Info ) { String request Id = Penn Station . request Action ( request , queue Info ) ; synchronized ( this ) { m Last Request Id By Type . put ( request . type ( ) , request Id ) ; m Request Ids . add ( request Id ) ; } }
public void add Request ( Action Request request , Limited Queue Info queue Info ) { String request Id = Penn Station . request Action ( request , queue Info ) ; synchronized ( this ) { m Last Request Id By Type . put ( request . type ( ) , request Id ) ; m Request Ids . add ( request Id ) ; } }
public Type lub ( List < Type > ts ) { return lub ( ts . to Array ( new Type [ ts . length ( ) ] ) ) ; }
public Str Builder insert ( final int index , final Object obj ) { if ( obj == null ) { return insert ( index , null Text ) ; } return insert ( index , obj . to String ( ) ) ; }
private String match ( Pattern re ) { if ( index >= input . length ( ) ) { return null ; } Matcher matcher = re . matcher ( input ) ; matcher . region ( index , input . length ( ) ) ; boolean m = matcher . find ( ) ; if ( m ) { index = matcher . end ( ) ; return matcher . group ( ) ; } else { return null ; } }
private String match ( Pattern re ) { if ( index >= input . length ( ) ) { return null ; } Matcher matcher = re . matcher ( input ) ; matcher . region ( index , input . length ( ) ) ; boolean m = matcher . find ( ) ; if ( m ) { index = matcher . end ( ) ; return matcher . group ( ) ; } else { return null ; } }
public final boolean is Same Size ( final Matrix matrix ) { return this . num Rows == matrix . num Rows && this . num Cols == matrix . num Cols ; }
public final boolean is Same Size ( final Matrix matrix ) { return this . num Rows == matrix . num Rows && this . num Cols == matrix . num Cols ; }
public static void append ( Path file , Writer writer , String charset ) throws IO Exception { append Buffered ( file , writer , charset , BOOL ) ; }
public static void append ( Path file , Writer writer , String charset ) throws IO Exception { append Buffered ( file , writer , charset , BOOL ) ; }
public static void append ( Path file , Writer writer , String charset ) throws IO Exception { append Buffered ( file , writer , charset , BOOL ) ; }
public static String make Simple Doc ( String ... fields And Values ) { try { String Writer w = new String Writer ( ) ; w . append ( STRING ) ; for ( int i = NUM ; i < fields And Values . length ; i += NUM ) { XML . write XML ( w , STRING , fields And Values [ i + NUM ] , STRING , fields And Values [ i ] ) ; } w . append ( STRING ) ; return w . to String ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING , e ) ; } }
public static String make Simple Doc ( String ... fields And Values ) { try { String Writer w = new String Writer ( ) ; w . append ( STRING ) ; for ( int i = NUM ; i < fields And Values . length ; i += NUM ) { XML . write XML ( w , STRING , fields And Values [ i + NUM ] , STRING , fields And Values [ i ] ) ; } w . append ( STRING ) ; return w . to String ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING , e ) ; } }
public static String make Simple Doc ( String ... fields And Values ) { try { String Writer w = new String Writer ( ) ; w . append ( STRING ) ; for ( int i = NUM ; i < fields And Values . length ; i += NUM ) { XML . write XML ( w , STRING , fields And Values [ i + NUM ] , STRING , fields And Values [ i ] ) ; } w . append ( STRING ) ; return w . to String ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING , e ) ; } }
public void close ( ) { this . closed = BOOL ; }
public void close ( ) { this . closed = BOOL ; }
public static Indexed Image load ( byte [ ] data ) { try { Data Input Stream input = new Data Input Stream ( new Byte Array Input Stream ( data ) ) ; int width = input . read Short ( ) ; int height = input . read Short ( ) ; int [ ] palette = new int [ input . read Byte ( ) & NUM ] ; int plen = palette . length ; for ( int iter = NUM ; iter < plen ; iter ++ ) { palette [ iter ] = input . read Int ( ) ; } byte [ ] arr = new byte [ width * height ] ; input . read Fully ( arr ) ; return new Indexed Image ( width , height , palette , arr ) ; } catch ( IO Exception ex ) { ex . print Stack Trace ( ) ; return null ; } }
public static Indexed Image load ( byte [ ] data ) { try { Data Input Stream input = new Data Input Stream ( new Byte Array Input Stream ( data ) ) ; int width = input . read Short ( ) ; int height = input . read Short ( ) ; int [ ] palette = new int [ input . read Byte ( ) & NUM ] ; int plen = palette . length ; for ( int iter = NUM ; iter < plen ; iter ++ ) { palette [ iter ] = input . read Int ( ) ; } byte [ ] arr = new byte [ width * height ] ; input . read Fully ( arr ) ; return new Indexed Image ( width , height , palette , arr ) ; } catch ( IO Exception ex ) { ex . print Stack Trace ( ) ; return null ; } }
public static Indexed Image load ( byte [ ] data ) { try { Data Input Stream input = new Data Input Stream ( new Byte Array Input Stream ( data ) ) ; int width = input . read Short ( ) ; int height = input . read Short ( ) ; int [ ] palette = new int [ input . read Byte ( ) & NUM ] ; int plen = palette . length ; for ( int iter = NUM ; iter < plen ; iter ++ ) { palette [ iter ] = input . read Int ( ) ; } byte [ ] arr = new byte [ width * height ] ; input . read Fully ( arr ) ; return new Indexed Image ( width , height , palette , arr ) ; } catch ( IO Exception ex ) { ex . print Stack Trace ( ) ; return null ; } }
public static Indexed Image load ( byte [ ] data ) { try { Data Input Stream input = new Data Input Stream ( new Byte Array Input Stream ( data ) ) ; int width = input . read Short ( ) ; int height = input . read Short ( ) ; int [ ] palette = new int [ input . read Byte ( ) & NUM ] ; int plen = palette . length ; for ( int iter = NUM ; iter < plen ; iter ++ ) { palette [ iter ] = input . read Int ( ) ; } byte [ ] arr = new byte [ width * height ] ; input . read Fully ( arr ) ; return new Indexed Image ( width , height , palette , arr ) ; } catch ( IO Exception ex ) { ex . print Stack Trace ( ) ; return null ; } }
public static int prob Round ( double value , Random rand ) { if ( value >= NUM ) { double lower = Math . floor ( value ) ; double prob = value - lower ; if ( rand . next Double ( ) < prob ) { return ( int ) lower + NUM ; } else { return ( int ) lower ; } } else { double lower = Math . floor ( Math . abs ( value ) ) ; double prob = Math . abs ( value ) - lower ; if ( rand . next Double ( ) < prob ) { return - ( ( int ) lower + NUM ) ; } else { return - ( int ) lower ; } } }
public static int prob Round ( double value , Random rand ) { if ( value >= NUM ) { double lower = Math . floor ( value ) ; double prob = value - lower ; if ( rand . next Double ( ) < prob ) { return ( int ) lower + NUM ; } else { return ( int ) lower ; } } else { double lower = Math . floor ( Math . abs ( value ) ) ; double prob = Math . abs ( value ) - lower ; if ( rand . next Double ( ) < prob ) { return - ( ( int ) lower + NUM ) ; } else { return - ( int ) lower ; } } }
public static int prob Round ( double value , Random rand ) { if ( value >= NUM ) { double lower = Math . floor ( value ) ; double prob = value - lower ; if ( rand . next Double ( ) < prob ) { return ( int ) lower + NUM ; } else { return ( int ) lower ; } } else { double lower = Math . floor ( Math . abs ( value ) ) ; double prob = Math . abs ( value ) - lower ; if ( rand . next Double ( ) < prob ) { return - ( ( int ) lower + NUM ) ; } else { return - ( int ) lower ; } } }
public static int prob Round ( double value , Random rand ) { if ( value >= NUM ) { double lower = Math . floor ( value ) ; double prob = value - lower ; if ( rand . next Double ( ) < prob ) { return ( int ) lower + NUM ; } else { return ( int ) lower ; } } else { double lower = Math . floor ( Math . abs ( value ) ) ; double prob = Math . abs ( value ) - lower ; if ( rand . next Double ( ) < prob ) { return - ( ( int ) lower + NUM ) ; } else { return - ( int ) lower ; } } }
public static int prob Round ( double value , Random rand ) { if ( value >= NUM ) { double lower = Math . floor ( value ) ; double prob = value - lower ; if ( rand . next Double ( ) < prob ) { return ( int ) lower + NUM ; } else { return ( int ) lower ; } } else { double lower = Math . floor ( Math . abs ( value ) ) ; double prob = Math . abs ( value ) - lower ; if ( rand . next Double ( ) < prob ) { return - ( ( int ) lower + NUM ) ; } else { return - ( int ) lower ; } } }
private void validate SQL Fields ( ) { boolean flag = controller . is Enable SQL Database Output ( ) ; enable SQL Database Connection . set Selected ( flag ) ; sql Host Label . set Enabled ( flag ) ; sql Host Field . set Enabled ( flag ) ; sql Database Label . set Enabled ( flag ) ; sql Database Field . set Enabled ( flag ) ; sql User Label . set Enabled ( flag ) ; sql User Field . set Enabled ( flag ) ; sql Password Label . set Enabled ( flag ) ; sql Password Field . set Enabled ( flag ) ; enable Zip Encoding Check Box . set Enabled ( flag ) ; }
public void test Bug 68307 ( ) throws Exception { create Function ( STRING , STRING ) ; create Procedure ( STRING , STRING ) ; Database Meta Data test Db Meta Data = conn . get Meta Data ( ) ; check Function Column Type For Bug 68307 ( STRING , test Db Meta Data ) ; check Procedure Column Type For Bug 68307 ( STRING , test Db Meta Data ) ; Connection conn Use IS = get Connection With Props ( STRING ) ; test Db Meta Data = conn Use IS . get Meta Data ( ) ; check Function Column Type For Bug 68307 ( STRING , test Db Meta Data ) ; check Procedure Column Type For Bug 68307 ( STRING , test Db Meta Data ) ; conn Use IS . close ( ) ; }
public void test Bug 68307 ( ) throws Exception { create Function ( STRING , STRING ) ; create Procedure ( STRING , STRING ) ; Database Meta Data test Db Meta Data = conn . get Meta Data ( ) ; check Function Column Type For Bug 68307 ( STRING , test Db Meta Data ) ; check Procedure Column Type For Bug 68307 ( STRING , test Db Meta Data ) ; Connection conn Use IS = get Connection With Props ( STRING ) ; test Db Meta Data = conn Use IS . get Meta Data ( ) ; check Function Column Type For Bug 68307 ( STRING , test Db Meta Data ) ; check Procedure Column Type For Bug 68307 ( STRING , test Db Meta Data ) ; conn Use IS . close ( ) ; }
private static void output Setting ( String setting ) { if ( out != null && ! written Settings . contains ( setting ) ) { if ( written Settings . size ( ) == NUM ) { out . println ( STRING + ( run Index + NUM ) ) ; } out . println ( setting ) ; written Settings . add ( setting ) ; } }
private void bounds Changed ( ) { if ( run Later Pending ) return ; run Later Pending = BOOL ; Platform . run Later ( null ) ; }
private void bounds Changed ( ) { if ( run Later Pending ) return ; run Later Pending = BOOL ; Platform . run Later ( null ) ; }
synchronized boolean is Attached ( Monitor monitor To Find ) { return monitors . contains ( monitor To Find ) ; }
public static String normalize ( Char Sequence src , Form form ) { return Normalizer Base . normalize ( src . to String ( ) , form ) ; }
public static String normalize ( Char Sequence src , Form form ) { return Normalizer Base . normalize ( src . to String ( ) , form ) ; }
public void add ( Resource Collection rc ) { class Files . add ( rc ) ; }
private void emit Ensure Collection ( Method method , String field Name , String Builder builder ) { builder . append ( STRING ) ; builder . append ( get Ensure Name ( field Name ) ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( field Name ) ; builder . append ( STRING ) ; builder . append ( field Name ) ; builder . append ( STRING ) ; builder . append ( get Impl Name ( method . get Generic Return Type ( ) , BOOL ) ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; }
private void emit Ensure Collection ( Method method , String field Name , String Builder builder ) { builder . append ( STRING ) ; builder . append ( get Ensure Name ( field Name ) ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( field Name ) ; builder . append ( STRING ) ; builder . append ( field Name ) ; builder . append ( STRING ) ; builder . append ( get Impl Name ( method . get Generic Return Type ( ) , BOOL ) ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; }
public void remove ( int i ) { individuals . remove ( i ) ; }
public static String keep Cart Updated ( Http Servlet Request request , Http Servlet Response response ) { Local Dispatcher dispatcher = ( Local Dispatcher ) request . get Attribute ( STRING ) ; Http Session session = request . get Session ( ) ; Shopping Cart cart = get Cart Object ( request ) ; if ( cart . get User Login ( ) == null ) { Generic Value user Login = ( Generic Value ) session . get Attribute ( STRING ) ; if ( user Login != null ) { try { cart . set User Login ( user Login , dispatcher ) ; } catch ( Cart Item Modify Exception e ) { Debug . log Warning ( e , module ) ; } } } if ( cart . get Auto User Login ( ) == null ) { Generic Value auto User Login = ( Generic Value ) session . get Attribute ( STRING ) ; if ( auto User Login != null ) { if ( cart . get User Login ( ) == null ) { try { cart . set Auto User Login ( auto User Login , dispatcher ) ; } catch ( Cart Item Modify Exception e ) { Debug . log Warning ( e , module ) ; } } else { cart . set Auto User Login ( auto User Login ) ; } } } Locale locale = Util Http . get Locale ( request ) ; if ( cart . get Locale ( ) == null || ! locale . equals ( cart . get Locale ( ) ) ) { cart . set Locale ( locale ) ; } return STRING ; }
public void read Data ( Data Input input ) throws IO Exception { read Reference = input . read Unsigned Short ( ) ; read Count = input . read Unsigned Short ( ) ; write Reference = input . read Unsigned Short ( ) ; write Count = input . read Unsigned Short ( ) ; int byte Count = input . read Unsigned Byte ( ) ; if ( non Word Data Handler == null ) { byte buffer [ ] = new byte [ byte Count ] ; input . read Fully ( buffer , NUM , byte Count ) ; int offset = NUM ; registers = new Register [ write Count ] ; for ( int register = NUM ; register < write Count ; register ++ ) { registers [ register ] = new Simple Register ( buffer [ offset ] , buffer [ offset + NUM ] ) ; offset += NUM ; } } else { non Word Data Handler . read Data ( input , write Reference , write Count ) ; } }
public void read Data ( Data Input input ) throws IO Exception { read Reference = input . read Unsigned Short ( ) ; read Count = input . read Unsigned Short ( ) ; write Reference = input . read Unsigned Short ( ) ; write Count = input . read Unsigned Short ( ) ; int byte Count = input . read Unsigned Byte ( ) ; if ( non Word Data Handler == null ) { byte buffer [ ] = new byte [ byte Count ] ; input . read Fully ( buffer , NUM , byte Count ) ; int offset = NUM ; registers = new Register [ write Count ] ; for ( int register = NUM ; register < write Count ; register ++ ) { registers [ register ] = new Simple Register ( buffer [ offset ] , buffer [ offset + NUM ] ) ; offset += NUM ; } } else { non Word Data Handler . read Data ( input , write Reference , write Count ) ; } }
public Set < Def Use Coverage Test Fitness > determine Def Use Pairs ( ) { Set < Def Use Coverage Test Fitness > r = pre Analyze Methods ( ) ; for ( CCFG Method Entry Node public Method Entry : ccfg . public Methods ) { if ( analyzed Methods . contains ( public Method Entry ) ) { continue ; } if ( public Method Entry . get Entry Instruction ( ) == null ) throw new Illegal State Exception ( STRING ) ; r . add All ( determine Intra Inter Method Pairs ( public Method Entry ) ) ; } r . add All ( create Intra Class Pairs ( ) ) ; free Memory ( ) ; return r ; }
public Set < Def Use Coverage Test Fitness > determine Def Use Pairs ( ) { Set < Def Use Coverage Test Fitness > r = pre Analyze Methods ( ) ; for ( CCFG Method Entry Node public Method Entry : ccfg . public Methods ) { if ( analyzed Methods . contains ( public Method Entry ) ) { continue ; } if ( public Method Entry . get Entry Instruction ( ) == null ) throw new Illegal State Exception ( STRING ) ; r . add All ( determine Intra Inter Method Pairs ( public Method Entry ) ) ; } r . add All ( create Intra Class Pairs ( ) ) ; free Memory ( ) ; return r ; }
public Set < Def Use Coverage Test Fitness > determine Def Use Pairs ( ) { Set < Def Use Coverage Test Fitness > r = pre Analyze Methods ( ) ; for ( CCFG Method Entry Node public Method Entry : ccfg . public Methods ) { if ( analyzed Methods . contains ( public Method Entry ) ) { continue ; } if ( public Method Entry . get Entry Instruction ( ) == null ) throw new Illegal State Exception ( STRING ) ; r . add All ( determine Intra Inter Method Pairs ( public Method Entry ) ) ; } r . add All ( create Intra Class Pairs ( ) ) ; free Memory ( ) ; return r ; }
public Set < Def Use Coverage Test Fitness > determine Def Use Pairs ( ) { Set < Def Use Coverage Test Fitness > r = pre Analyze Methods ( ) ; for ( CCFG Method Entry Node public Method Entry : ccfg . public Methods ) { if ( analyzed Methods . contains ( public Method Entry ) ) { continue ; } if ( public Method Entry . get Entry Instruction ( ) == null ) throw new Illegal State Exception ( STRING ) ; r . add All ( determine Intra Inter Method Pairs ( public Method Entry ) ) ; } r . add All ( create Intra Class Pairs ( ) ) ; free Memory ( ) ; return r ; }
public Set < Def Use Coverage Test Fitness > determine Def Use Pairs ( ) { Set < Def Use Coverage Test Fitness > r = pre Analyze Methods ( ) ; for ( CCFG Method Entry Node public Method Entry : ccfg . public Methods ) { if ( analyzed Methods . contains ( public Method Entry ) ) { continue ; } if ( public Method Entry . get Entry Instruction ( ) == null ) throw new Illegal State Exception ( STRING ) ; r . add All ( determine Intra Inter Method Pairs ( public Method Entry ) ) ; } r . add All ( create Intra Class Pairs ( ) ) ; free Memory ( ) ; return r ; }
public Set < Def Use Coverage Test Fitness > determine Def Use Pairs ( ) { Set < Def Use Coverage Test Fitness > r = pre Analyze Methods ( ) ; for ( CCFG Method Entry Node public Method Entry : ccfg . public Methods ) { if ( analyzed Methods . contains ( public Method Entry ) ) { continue ; } if ( public Method Entry . get Entry Instruction ( ) == null ) throw new Illegal State Exception ( STRING ) ; r . add All ( determine Intra Inter Method Pairs ( public Method Entry ) ) ; } r . add All ( create Intra Class Pairs ( ) ) ; free Memory ( ) ; return r ; }
public Set < Def Use Coverage Test Fitness > determine Def Use Pairs ( ) { Set < Def Use Coverage Test Fitness > r = pre Analyze Methods ( ) ; for ( CCFG Method Entry Node public Method Entry : ccfg . public Methods ) { if ( analyzed Methods . contains ( public Method Entry ) ) { continue ; } if ( public Method Entry . get Entry Instruction ( ) == null ) throw new Illegal State Exception ( STRING ) ; r . add All ( determine Intra Inter Method Pairs ( public Method Entry ) ) ; } r . add All ( create Intra Class Pairs ( ) ) ; free Memory ( ) ; return r ; }
public void add Subpath ( Subpath subpath ) { subpaths . add ( subpath ) ; current Point = subpath . get Last Point ( ) ; }
static Object value Of ( final Class < ? > type , final String str ) { if ( ! is Valid Enum ( type ) ) { return null ; } try { final String value Of Method = STRING ; final Method m = type . get Method ( value Of Method , String . class ) ; if ( ! Modifier . is Static ( m . get Modifiers ( ) ) ) { return null ; } final Class < ? > return Type = m . get Return Type ( ) ; if ( ! type . is Assignable From ( return Type ) ) { return null ; } return m . invoke ( null , str ) ; } catch ( final No Such Method Exception | Invocation Target Exception | Illegal Access Exception e ) { throw new Runtime Exception ( e ) ; } }
protected int offset Val ( String mask String ) { int offset = NUM ; for ( int i = NUM ; i < mask String . length ( ) ; i ++ ) { if ( mask String . char At ( i ) == STRING ) { offset = mask String . length ( ) - NUM - i ; } } return offset ; }
protected int offset Val ( String mask String ) { int offset = NUM ; for ( int i = NUM ; i < mask String . length ( ) ; i ++ ) { if ( mask String . char At ( i ) == STRING ) { offset = mask String . length ( ) - NUM - i ; } } return offset ; }
protected int offset Val ( String mask String ) { int offset = NUM ; for ( int i = NUM ; i < mask String . length ( ) ; i ++ ) { if ( mask String . char At ( i ) == STRING ) { offset = mask String . length ( ) - NUM - i ; } } return offset ; }
protected int offset Val ( String mask String ) { int offset = NUM ; for ( int i = NUM ; i < mask String . length ( ) ; i ++ ) { if ( mask String . char At ( i ) == STRING ) { offset = mask String . length ( ) - NUM - i ; } } return offset ; }
protected int offset Val ( String mask String ) { int offset = NUM ; for ( int i = NUM ; i < mask String . length ( ) ; i ++ ) { if ( mask String . char At ( i ) == STRING ) { offset = mask String . length ( ) - NUM - i ; } } return offset ; }
protected int offset Val ( String mask String ) { int offset = NUM ; for ( int i = NUM ; i < mask String . length ( ) ; i ++ ) { if ( mask String . char At ( i ) == STRING ) { offset = mask String . length ( ) - NUM - i ; } } return offset ; }
protected int offset Val ( String mask String ) { int offset = NUM ; for ( int i = NUM ; i < mask String . length ( ) ; i ++ ) { if ( mask String . char At ( i ) == STRING ) { offset = mask String . length ( ) - NUM - i ; } } return offset ; }
protected int offset Val ( String mask String ) { int offset = NUM ; for ( int i = NUM ; i < mask String . length ( ) ; i ++ ) { if ( mask String . char At ( i ) == STRING ) { offset = mask String . length ( ) - NUM - i ; } } return offset ; }
protected int offset Val ( String mask String ) { int offset = NUM ; for ( int i = NUM ; i < mask String . length ( ) ; i ++ ) { if ( mask String . char At ( i ) == STRING ) { offset = mask String . length ( ) - NUM - i ; } } return offset ; }
protected int offset Val ( String mask String ) { int offset = NUM ; for ( int i = NUM ; i < mask String . length ( ) ; i ++ ) { if ( mask String . char At ( i ) == STRING ) { offset = mask String . length ( ) - NUM - i ; } } return offset ; }
@ Suppress Warnings ( STRING ) public void add Surrogate Ids ( Collection < Ignite Uuid > col ) { if ( surrogate Ids == null ) { surrogate Ids = new Ignite Uuid [ ids . length ] ; for ( int i = last Existing Idx + NUM ; i < surrogate Ids . length ; i ++ ) surrogate Ids [ i ] = Ignite Uuid . random Uuid ( ) ; } for ( int i = last Existing Idx + NUM ; i < surrogate Ids . length ; i ++ ) col . add ( surrogate Ids [ i ] ) ; }
@ Suppress Warnings ( STRING ) public void add Surrogate Ids ( Collection < Ignite Uuid > col ) { if ( surrogate Ids == null ) { surrogate Ids = new Ignite Uuid [ ids . length ] ; for ( int i = last Existing Idx + NUM ; i < surrogate Ids . length ; i ++ ) surrogate Ids [ i ] = Ignite Uuid . random Uuid ( ) ; } for ( int i = last Existing Idx + NUM ; i < surrogate Ids . length ; i ++ ) col . add ( surrogate Ids [ i ] ) ; }
public static void UF 5 ( double [ ] x , double [ ] f , int nx ) { int count 1 = NUM ; int count 2 = NUM ; double sum 1 = NUM ; double sum 2 = NUM ; double yj ; double hj ; double N = NUM ; double E = NUM ; for ( int j = NUM ; j <= nx ; j ++ ) { yj = x [ j - NUM ] - Math . sin ( NUM * PI * x [ NUM ] + j * PI / nx ) ; hj = NUM * yj * yj - Math . cos ( NUM * PI * yj ) + NUM ; if ( j % NUM == NUM ) { sum 2 += hj ; count 2 ++ ; } else { sum 1 += hj ; count 1 ++ ; } } hj = ( NUM / N + E ) * Math . abs ( Math . sin ( NUM * N * PI * x [ NUM ] ) ) ; f [ NUM ] = x [ NUM ] + hj + NUM * sum 1 / ( double ) count 1 ; f [ NUM ] = NUM - x [ NUM ] + hj + NUM * sum 2 / ( double ) count 2 ; }
private String make Header ( boolean ok ) { String header = STRING ; if ( ok ) { header += STRING ; } else { header += STRING ; } header += STRING ; header += STRING ; return header ; }
public void ensure Capacity ( int mincap ) { if ( mincap > array . length ) { int newcap = ( ( array . length * NUM ) > > NUM ) + NUM ; int [ ] olddata = array ; array = new int [ newcap < mincap ? mincap : newcap ] ; System . arraycopy ( olddata , NUM , array , NUM , size ) ; } }
private float compute Overscroll Percent ( ) { if ( m Over Scroll Offset >= NUM ) { return m Over Scroll Offset / m Max Over Scroll ; } else { return m Over Scroll Offset / m Max Under Scroll ; } }
private float compute Overscroll Percent ( ) { if ( m Over Scroll Offset >= NUM ) { return m Over Scroll Offset / m Max Over Scroll ; } else { return m Over Scroll Offset / m Max Under Scroll ; } }
private float compute Overscroll Percent ( ) { if ( m Over Scroll Offset >= NUM ) { return m Over Scroll Offset / m Max Over Scroll ; } else { return m Over Scroll Offset / m Max Under Scroll ; } }
public void on Tab Closing ( long time , int tab Id ) { }
public void on Tab Closing ( long time , int tab Id ) { }
public Point 2 D either ( ) { return best 1 ; }
public Point 2 D either ( ) { return best 1 ; }
public static String Goto Next Non Space ( Vector input Vec , Int Pair cur Loc ) { boolean found = BOOL ; while ( ( ! found ) && cur Loc . one < input Vec . size ( ) ) { String line = ( String ) input Vec . element At ( cur Loc . one ) ; while ( ( ! found ) && cur Loc . two < line . length ( ) ) { if ( line . char At ( cur Loc . two ) == STRING ) { cur Loc . two ++ ; } else { found = BOOL ; } } if ( ! found ) { cur Loc . one ++ ; cur Loc . two = NUM ; } } if ( cur Loc . one < input Vec . size ( ) ) { return ( String ) input Vec . element At ( cur Loc . one ) ; } return STRING ; }
public boolean evaluate ( Map record ) { Object rec Val = record . get ( key Field ) ; return op . evaluate ( this . val , rec Val ) ; }
public boolean evaluate ( Map record ) { Object rec Val = record . get ( key Field ) ; return op . evaluate ( this . val , rec Val ) ; }
public boolean evaluate ( Map record ) { Object rec Val = record . get ( key Field ) ; return op . evaluate ( this . val , rec Val ) ; }
public boolean evaluate ( Map record ) { Object rec Val = record . get ( key Field ) ; return op . evaluate ( this . val , rec Val ) ; }
public static Value Java Time ( ) { int t = ( int ) System . current Time Millis ( ) ; return Int Value . gen ( t & NUM ) ; }
public static Value Java Time ( ) { int t = ( int ) System . current Time Millis ( ) ; return Int Value . gen ( t & NUM ) ; }
private static List < Command > load Rewrites ( Content Resolver content Resolver , Uri uri ) throws IO Exception { Input Stream input Stream = content Resolver . open Input Stream ( uri ) ; List < Command > commands = new Array List < > ( ) ; if ( input Stream != null ) { Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( input Stream ) ) ; String line ; while ( ( line = reader . read Line ( ) ) != null ) { add Line ( commands , line ) ; } input Stream . close ( ) ; } return commands ; }
private static List < Command > load Rewrites ( Content Resolver content Resolver , Uri uri ) throws IO Exception { Input Stream input Stream = content Resolver . open Input Stream ( uri ) ; List < Command > commands = new Array List < > ( ) ; if ( input Stream != null ) { Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( input Stream ) ) ; String line ; while ( ( line = reader . read Line ( ) ) != null ) { add Line ( commands , line ) ; } input Stream . close ( ) ; } return commands ; }
public Political Action Attachment wait For Political Action ( final boolean first Run , final I Politics Delegate i Politics Delegate ) { m first Run = first Run ; m valid Political Actions = new Array List < > ( i Politics Delegate . get Valid Actions ( ) ) ; Collections . sort ( m valid Political Actions , new Political Action Comparator ( get Current Player ( ) , get Data ( ) ) ) ; if ( m first Run && m valid Political Actions . is Empty ( ) ) { return null ; } else { if ( m first Run ) { Clip Player . play ( Sound Path . CLIP PHASE POLITICS , get Current Player ( ) ) ; } Swing Utilities . invoke Later ( null ) ; } wait For Release ( ) ; return m choice ; }
public Political Action Attachment wait For Political Action ( final boolean first Run , final I Politics Delegate i Politics Delegate ) { m first Run = first Run ; m valid Political Actions = new Array List < > ( i Politics Delegate . get Valid Actions ( ) ) ; Collections . sort ( m valid Political Actions , new Political Action Comparator ( get Current Player ( ) , get Data ( ) ) ) ; if ( m first Run && m valid Political Actions . is Empty ( ) ) { return null ; } else { if ( m first Run ) { Clip Player . play ( Sound Path . CLIP PHASE POLITICS , get Current Player ( ) ) ; } Swing Utilities . invoke Later ( null ) ; } wait For Release ( ) ; return m choice ; }
private String normalize Resource Name ( String s Name ) { return s Name . replace ( STRING , STRING ) ; }
private String normalize Resource Name ( String s Name ) { return s Name . replace ( STRING , STRING ) ; }
public boolean is Modified Now ( ) { boolean is Modified = class Loader . is Modified Now ( ) ; if ( is Modified ) log . fine ( STRING ) ; return is Modified ; }
public boolean is Modified Now ( ) { boolean is Modified = class Loader . is Modified Now ( ) ; if ( is Modified ) log . fine ( STRING ) ; return is Modified ; }
public Payment ( Result Set result ) throws SQL Exception { id = result . get Int ( STRING ) ; channel Id Receiver = result . get Int ( STRING ) ; channel Id Sender = result . get Int ( STRING ) ; amount = result . get Long ( STRING ) ; fee = result . get Long ( STRING ) ; phase Sender = result . get Int ( STRING ) ; phase Receiver = result . get Int ( STRING ) ; include In Receiver Channel = Tools . int To Bool ( result . get Int ( STRING ) ) ; include In Sender Channel = Tools . int To Bool ( result . get Int ( STRING ) ) ; include In Receiver Channel Temp = Tools . int To Bool ( result . get Int ( STRING ) ) ; include In Sender Channel Temp = Tools . int To Bool ( result . get Int ( STRING ) ) ; secret Hash = result . get Bytes ( STRING ) ; secret = result . get Bytes ( STRING ) ; timestamp Added Receiver = result . get Int ( STRING ) ; timestamp Added Sender = result . get Int ( STRING ) ; timestamp Settled Receiver = result . get Int ( STRING ) ; timestamp Settled Sender = result . get Int ( STRING ) ; version Added Receiver = result . get Int ( STRING ) ; version Added Sender = result . get Int ( STRING ) ; version Settled Receiver = result . get Int ( STRING ) ; version Settled Sender = result . get Int ( STRING ) ; }
private static String add Key ( List < Optional < Account Ssh Key > > keys , String pub ) { Account Ssh Key . Id key Id = new Account Ssh Key . Id ( new Account . Id ( NUM ) , keys . size ( ) + NUM ) ; Account Ssh Key key = new Account Ssh Key ( key Id , pub ) ; keys . add ( Optional . of ( key ) ) ; return key . get Ssh Public Key ( ) + STRING ; }
@ Override protected void on Measure ( int width Measure Spec , int height Measure Spec ) { set Measured Dimension ( ( int ) Math . min ( Measure Spec . get Size ( width Measure Spec ) , half Width * NUM ) , ( int ) Math . min ( Measure Spec . get Size ( height Measure Spec ) , height ) ) ; }
public static void put String ( String property , String val ) { SIMBRAIN PREFERENCES . put ( property , val ) ; }
public void create Chart Print Job ( ) { Printer Job job = Printer Job . get Printer Job ( ) ; Page Format pf = job . default Page ( ) ; Page Format pf 2 = job . page Dialog ( pf ) ; if ( pf 2 != pf ) { job . set Printable ( this , pf 2 ) ; if ( job . print Dialog ( ) ) { try { job . print ( ) ; } catch ( Printer Exception e ) { J Option Pane . show Message Dialog ( this , e ) ; } } } }
private static void merge ( Object Node tree , Object Node override Tree ) { Iterator < String > field Names = override Tree . field Names ( ) ; while ( field Names . has Next ( ) ) { String field Name = field Names . next ( ) ; Json Node primary Value = tree . get ( field Name ) ; Json Node backup Value = override Tree . get ( field Name ) ; if ( primary Value == null ) { if ( backup Value != null ) { tree . set ( field Name , backup Value ) ; } } else if ( backup Value . is Null ( ) ) { tree . remove ( field Name ) ; } else if ( primary Value . is Object ( ) && backup Value . is Object ( ) ) { merge ( ( Object Node ) primary Value , ( Object Node ) backup Value . deep Copy ( ) ) ; } else { tree . set ( field Name , override Tree . get ( field Name ) ) ; } } }
private static void merge ( Object Node tree , Object Node override Tree ) { Iterator < String > field Names = override Tree . field Names ( ) ; while ( field Names . has Next ( ) ) { String field Name = field Names . next ( ) ; Json Node primary Value = tree . get ( field Name ) ; Json Node backup Value = override Tree . get ( field Name ) ; if ( primary Value == null ) { if ( backup Value != null ) { tree . set ( field Name , backup Value ) ; } } else if ( backup Value . is Null ( ) ) { tree . remove ( field Name ) ; } else if ( primary Value . is Object ( ) && backup Value . is Object ( ) ) { merge ( ( Object Node ) primary Value , ( Object Node ) backup Value . deep Copy ( ) ) ; } else { tree . set ( field Name , override Tree . get ( field Name ) ) ; } } }
private static void merge ( Object Node tree , Object Node override Tree ) { Iterator < String > field Names = override Tree . field Names ( ) ; while ( field Names . has Next ( ) ) { String field Name = field Names . next ( ) ; Json Node primary Value = tree . get ( field Name ) ; Json Node backup Value = override Tree . get ( field Name ) ; if ( primary Value == null ) { if ( backup Value != null ) { tree . set ( field Name , backup Value ) ; } } else if ( backup Value . is Null ( ) ) { tree . remove ( field Name ) ; } else if ( primary Value . is Object ( ) && backup Value . is Object ( ) ) { merge ( ( Object Node ) primary Value , ( Object Node ) backup Value . deep Copy ( ) ) ; } else { tree . set ( field Name , override Tree . get ( field Name ) ) ; } } }
private static void merge ( Object Node tree , Object Node override Tree ) { Iterator < String > field Names = override Tree . field Names ( ) ; while ( field Names . has Next ( ) ) { String field Name = field Names . next ( ) ; Json Node primary Value = tree . get ( field Name ) ; Json Node backup Value = override Tree . get ( field Name ) ; if ( primary Value == null ) { if ( backup Value != null ) { tree . set ( field Name , backup Value ) ; } } else if ( backup Value . is Null ( ) ) { tree . remove ( field Name ) ; } else if ( primary Value . is Object ( ) && backup Value . is Object ( ) ) { merge ( ( Object Node ) primary Value , ( Object Node ) backup Value . deep Copy ( ) ) ; } else { tree . set ( field Name , override Tree . get ( field Name ) ) ; } } }
@ Override public String create Initial Load Sql For ( Node node , Trigger Router trigger , Table table , Trigger History trigger History , Channel channel , String override Select Sql ) { String sql = super . create Initial Load Sql For ( node , trigger , table , trigger History , channel , override Select Sql ) ; sql = sql . replace ( STRING , STRING ) ; return sql ; }
@ Override public String create Initial Load Sql For ( Node node , Trigger Router trigger , Table table , Trigger History trigger History , Channel channel , String override Select Sql ) { String sql = super . create Initial Load Sql For ( node , trigger , table , trigger History , channel , override Select Sql ) ; sql = sql . replace ( STRING , STRING ) ; return sql ; }
@ Override public String create Initial Load Sql For ( Node node , Trigger Router trigger , Table table , Trigger History trigger History , Channel channel , String override Select Sql ) { String sql = super . create Initial Load Sql For ( node , trigger , table , trigger History , channel , override Select Sql ) ; sql = sql . replace ( STRING , STRING ) ; return sql ; }
@ Override public String create Initial Load Sql For ( Node node , Trigger Router trigger , Table table , Trigger History trigger History , Channel channel , String override Select Sql ) { String sql = super . create Initial Load Sql For ( node , trigger , table , trigger History , channel , override Select Sql ) ; sql = sql . replace ( STRING , STRING ) ; return sql ; }
@ Override public String create Initial Load Sql For ( Node node , Trigger Router trigger , Table table , Trigger History trigger History , Channel channel , String override Select Sql ) { String sql = super . create Initial Load Sql For ( node , trigger , table , trigger History , channel , override Select Sql ) ; sql = sql . replace ( STRING , STRING ) ; return sql ; }
public static Vector 3 pow ( Vector 3 o , double power ) { return new Vector 3 ( Math . pow ( o . x , power ) , Math . pow ( o . y , power ) , Math . pow ( o . z , power ) ) ; }
default void remove Attribute Modifiers ( final Iterable < Attribute Modifier > modifiers ) { modifiers . for Each ( null ) ; }
public void start ( Stage stage ) throws Exception { stage . set Scene ( new Scene ( new My Demo Pane ( ) ) ) ; stage . set Title ( STRING ) ; stage . set Width ( NUM ) ; stage . set Height ( NUM ) ; stage . show ( ) ; }
private void reverse Transactions ( Array List < Data Store > restore List , Throwable cause ) { for ( Data Store data Store : restore List ) { try ( Data Store Transaction transaction = data Store . begin Transaction ( ) ) { List < Object > list = dirty Objects . get ( data Store ) ; for ( Object dirty Object : list == null ? Collections . empty List ( ) : list ) { Object cloned = cloned Objects . get ( dirty Object ) ; if ( cloned == NEWLY CREATED OBJECT ) { transaction . delete ( dirty Object ) ; } else { transaction . save ( cloned ) ; } } transaction . commit ( ) ; } catch ( Runtime Exception | IO Exception e ) { cause . add Suppressed ( e ) ; } } }
public void run Test ( ) throws Throwable { Document doc ; Node List em List ; Node em Node ; Character Data em Text ; boolean has Child ; doc = ( Document ) load ( STRING , BOOL ) ; em List = doc . get Elements By Tag Name ( STRING ) ; em Node = em List . item ( NUM ) ; em Text = ( Character Data ) em Node . get First Child ( ) ; has Child = em Text . has Child Nodes ( ) ; assert False ( STRING , has Child ) ; }
private void snip Out Entry ( Entry entry , final Entry parent , boolean remove Parent Relationship ) { final String previous Id = entry . get Previous Sibling Id ( ) ; if ( previous Id != null ) { final Entry previous = get Entry By Id ( previous Id ) ; previous . set Next Sibling Id ( entry . get Next Sibling Id ( ) ) ; } else { parent . set First Child Id ( entry . get Next Sibling Id ( ) ) ; } final String next Id = entry . get Next Sibling Id ( ) ; if ( next Id != null ) { final Entry next = get Entry By Id ( next Id ) ; next . set Previous Sibling Id ( previous Id ) ; } else { parent . set Last Child Id ( previous Id ) ; } }
private void snip Out Entry ( Entry entry , final Entry parent , boolean remove Parent Relationship ) { final String previous Id = entry . get Previous Sibling Id ( ) ; if ( previous Id != null ) { final Entry previous = get Entry By Id ( previous Id ) ; previous . set Next Sibling Id ( entry . get Next Sibling Id ( ) ) ; } else { parent . set First Child Id ( entry . get Next Sibling Id ( ) ) ; } final String next Id = entry . get Next Sibling Id ( ) ; if ( next Id != null ) { final Entry next = get Entry By Id ( next Id ) ; next . set Previous Sibling Id ( previous Id ) ; } else { parent . set Last Child Id ( previous Id ) ; } }
private void snip Out Entry ( Entry entry , final Entry parent , boolean remove Parent Relationship ) { final String previous Id = entry . get Previous Sibling Id ( ) ; if ( previous Id != null ) { final Entry previous = get Entry By Id ( previous Id ) ; previous . set Next Sibling Id ( entry . get Next Sibling Id ( ) ) ; } else { parent . set First Child Id ( entry . get Next Sibling Id ( ) ) ; } final String next Id = entry . get Next Sibling Id ( ) ; if ( next Id != null ) { final Entry next = get Entry By Id ( next Id ) ; next . set Previous Sibling Id ( previous Id ) ; } else { parent . set Last Child Id ( previous Id ) ; } }
public Column Table ( Object [ ] arrays , int [ ] sizes ) throws Table Exception { setup ( arrays , sizes ) ; }
public void test Exceptionally exceptional Completion Action Failed ( ) { for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) { final Atomic Integer a = new Atomic Integer ( NUM ) ; final CF Exception ex 1 = new CF Exception ( ) ; final CF Exception ex 2 = new CF Exception ( ) ; final Completable Future < Integer > f = new Completable Future < > ( ) ; if ( ! create Incomplete ) f . complete Exceptionally ( ex 1 ) ; final Completable Future < Integer > g = f . exceptionally ( null ) ; if ( create Incomplete ) f . complete Exceptionally ( ex 1 ) ; check Completed With Wrapped Exception ( g , ex 2 ) ; check Completed Exceptionally ( f , ex 1 ) ; assert Equals ( NUM , a . get ( ) ) ; } }
public void test Exceptionally exceptional Completion Action Failed ( ) { for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) { final Atomic Integer a = new Atomic Integer ( NUM ) ; final CF Exception ex 1 = new CF Exception ( ) ; final CF Exception ex 2 = new CF Exception ( ) ; final Completable Future < Integer > f = new Completable Future < > ( ) ; if ( ! create Incomplete ) f . complete Exceptionally ( ex 1 ) ; final Completable Future < Integer > g = f . exceptionally ( null ) ; if ( create Incomplete ) f . complete Exceptionally ( ex 1 ) ; check Completed With Wrapped Exception ( g , ex 2 ) ; check Completed Exceptionally ( f , ex 1 ) ; assert Equals ( NUM , a . get ( ) ) ; } }
@ Suppress Lint ( STRING ) public Abstract Android Keystore Secret Key Wrapper ( Context context , String alias ) throws General Security Exception { m Alias = alias ; m Cipher = Cipher . get Instance ( get Transformation ( ) ) ; m Context = context . get Application Context ( ) ; }
@ Suppress Lint ( STRING ) public Abstract Android Keystore Secret Key Wrapper ( Context context , String alias ) throws General Security Exception { m Alias = alias ; m Cipher = Cipher . get Instance ( get Transformation ( ) ) ; m Context = context . get Application Context ( ) ; }
@ Suppress Lint ( STRING ) public Abstract Android Keystore Secret Key Wrapper ( Context context , String alias ) throws General Security Exception { m Alias = alias ; m Cipher = Cipher . get Instance ( get Transformation ( ) ) ; m Context = context . get Application Context ( ) ; }
public void notify Unlock Input ( ) { if ( locked ) { synchronized ( director Listeners ) { I Director Listener [ ] listeners = director Listeners . to Array ( new I Director Listener [ director Listeners . size ( ) ] ) ; for ( I Director Listener director Listener : listeners ) { if ( director Listener != this ) director Listener . unlock User Input ( ) ; } } } locked = BOOL ; }
public Image flip Image Horizontally ( Image image , boolean maintain Opacity ) { int [ ] rgb = image . get RGB ( ) ; int [ ] new RGB = new int [ rgb . length ] ; int width = image . get Width ( ) ; int height = image . get Height ( ) ; for ( int y = NUM ; y < height ; y ++ ) { for ( int x = NUM ; x < width ; x ++ ) { new RGB [ ( width - x - NUM ) + y * width ] = rgb [ x + y * width ] ; } } return Encoded Image . create From RGB ( new RGB , width , height , ! maintain Opacity ) ; }
public Image flip Image Horizontally ( Image image , boolean maintain Opacity ) { int [ ] rgb = image . get RGB ( ) ; int [ ] new RGB = new int [ rgb . length ] ; int width = image . get Width ( ) ; int height = image . get Height ( ) ; for ( int y = NUM ; y < height ; y ++ ) { for ( int x = NUM ; x < width ; x ++ ) { new RGB [ ( width - x - NUM ) + y * width ] = rgb [ x + y * width ] ; } } return Encoded Image . create From RGB ( new RGB , width , height , ! maintain Opacity ) ; }
@ Override public synchronized void add Training Set Listener ( Training Set Listener tsl ) { m listeners . add Element ( tsl ) ; }
@ Override public int read ( ) throws IO Exception { return m Input Stream . read ( ) ; }
public Register Description ( final String name , final int size , final boolean editable ) { this . name = Preconditions . check Not Null ( name , STRING ) ; if ( ! is Valid Size ( size ) ) { throw new Illegal Argument Exception ( String . format ( STRING , size ) ) ; } byte Size = size ; is Editable = editable ; }
private void post Init View Pager ( ) { try { Class < ? > viewpager = View Pager . class ; Field scroller = viewpager . get Declared Field ( STRING ) ; scroller . set Accessible ( BOOL ) ; Field interpolator = viewpager . get Declared Field ( STRING ) ; interpolator . set Accessible ( BOOL ) ; m Scroller = new Scroller Custom Duration ( get Context ( ) , ( Interpolator ) interpolator . get ( null ) ) ; scroller . set ( this , m Scroller ) ; } catch ( Exception e ) { } }
private void post Init View Pager ( ) { try { Class < ? > viewpager = View Pager . class ; Field scroller = viewpager . get Declared Field ( STRING ) ; scroller . set Accessible ( BOOL ) ; Field interpolator = viewpager . get Declared Field ( STRING ) ; interpolator . set Accessible ( BOOL ) ; m Scroller = new Scroller Custom Duration ( get Context ( ) , ( Interpolator ) interpolator . get ( null ) ) ; scroller . set ( this , m Scroller ) ; } catch ( Exception e ) { } }
public static String xmlize ( String s ) { s = s . replace All ( STRING , STRING ) ; s = s . replace All ( STRING , STRING ) ; s = s . replace All ( STRING , STRING ) ; s = s . replace All ( STRING , STRING ) ; int char Count = s . length ( ) ; for ( int iter = NUM ; iter < char Count ; iter ++ ) { char c = s . char At ( iter ) ; if ( c > NUM ) { String Builder b = new String Builder ( ) ; for ( int counter = NUM ; counter < char Count ; counter ++ ) { c = s . char At ( counter ) ; if ( c > NUM ) { b . append ( STRING ) ; b . append ( Integer . to Hex String ( c ) ) ; b . append ( STRING ) ; } else { b . append ( c ) ; } } return b . to String ( ) ; } } return s ; }
public final boolean content Equals ( java . lang . Char Sequence csq ) { if ( csq . length ( ) != length ) return BOOL ; for ( int i = NUM ; i < length ; ) { char c = high [ i > > B1 ] [ i & M1 ] ; if ( csq . char At ( i ++ ) != c ) return BOOL ; } return BOOL ; }
public final boolean content Equals ( java . lang . Char Sequence csq ) { if ( csq . length ( ) != length ) return BOOL ; for ( int i = NUM ; i < length ; ) { char c = high [ i > > B1 ] [ i & M1 ] ; if ( csq . char At ( i ++ ) != c ) return BOOL ; } return BOOL ; }
public boolean write Header ( Output Stream os ) { try { IO Utils . write Int ( os , CACHE MAGIC ) ; IO Utils . write String ( os , key ) ; IO Utils . write String ( os , etag == null ? STRING : etag ) ; IO Utils . write Long ( os , server Date ) ; IO Utils . write Long ( os , last Modified ) ; IO Utils . write Long ( os , ttl ) ; IO Utils . write Long ( os , soft Ttl ) ; IO Utils . write String String Map ( response Headers , os ) ; os . flush ( ) ; return BOOL ; } catch ( IO Exception e ) { Volley Log . d ( STRING , e . to String ( ) ) ; return BOOL ; } }
protected Array List < Array List < DBI Ds > > build Ranges ( Relation < V > relation ) { final int dim = Relation Util . dimensionality ( relation ) ; final int size = relation . size ( ) ; final Array List < Array List < DBI Ds > > ranges = new Array List < > ( ) ; Array Modifiable DBI Ds ids = DBID Util . new Array ( relation . get DBI Ds ( ) ) ; Sort DBI Ds By Single Dimension sorter = new Sort DBI Ds By Single Dimension ( relation ) ; final double part = size * NUM / phi ; for ( int d = NUM ; d < dim ; d ++ ) { sorter . set Dimension ( d ) ; ids . sort ( sorter ) ; Array List < DBI Ds > dimranges = new Array List < > ( phi + NUM ) ; int start = NUM ; DBID Array Iter iter = ids . iter ( ) ; for ( int r = NUM ; r <= phi ; r ++ ) { int end = ( r < phi ) ? ( int ) ( part * r ) : size ; Array Modifiable DBI Ds currange = DBID Util . new Array ( end - start ) ; for ( iter . seek ( start ) ; iter . get Offset ( ) < end ; iter . advance ( ) ) { currange . add ( iter ) ; } start = end ; dimranges . add ( currange ) ; } ranges . add ( dimranges ) ; } return ranges ; }
private void update Host State ( Operation operation , State host State , Agent State agent State ) { if ( host State . agent State != agent State ) { State patch State = new State ( ) ; patch State . agent State = agent State ; Service Utils . log Info ( this , STRING + host State . host Address + STRING + host State . agent State + STRING + STRING + agent State ) ; Task Utils . send Self Patch ( this , patch State ) ; } if ( operation != null ) { operation . complete ( ) ; } }
private void update Host State ( Operation operation , State host State , Agent State agent State ) { if ( host State . agent State != agent State ) { State patch State = new State ( ) ; patch State . agent State = agent State ; Service Utils . log Info ( this , STRING + host State . host Address + STRING + host State . agent State + STRING + STRING + agent State ) ; Task Utils . send Self Patch ( this , patch State ) ; } if ( operation != null ) { operation . complete ( ) ; } }
private void errors To HTML ( Errors errors , Print Writer writer ) { if ( errors != null && errors . has Errors ( ) ) { writer . print ( STRING ) ; for ( final String text : errors . get Texts ( ) ) { writer . print ( STRING ) ; writer . print ( String Escape Utils . escape Html 4 ( text ) ) ; writer . print ( STRING ) ; } writer . print ( STRING ) ; } }
final protected < T > T configure Impl ( Class < T > type ) throws Config Exception { try { T value = type . new Instance ( ) ; Inject Context context = null ; inject Top ( value , context ) ; return value ; } catch ( Runtime Exception e ) { throw e ; } catch ( Exception e ) { throw Config Exception . wrap ( e ) ; } }
public void add Handler ( Handler handler ) throws Security Exception { handler . get Class ( ) ; check Permission ( ) ; handlers . add ( handler ) ; }
public void add Handler ( Handler handler ) throws Security Exception { handler . get Class ( ) ; check Permission ( ) ; handlers . add ( handler ) ; }
public void add Handler ( Handler handler ) throws Security Exception { handler . get Class ( ) ; check Permission ( ) ; handlers . add ( handler ) ; }
public void add Handler ( Handler handler ) throws Security Exception { handler . get Class ( ) ; check Permission ( ) ; handlers . add ( handler ) ; }
public void add Handler ( Handler handler ) throws Security Exception { handler . get Class ( ) ; check Permission ( ) ; handlers . add ( handler ) ; }
public void add Handler ( Handler handler ) throws Security Exception { handler . get Class ( ) ; check Permission ( ) ; handlers . add ( handler ) ; }
public void remove All Emails ( ) { emails . clear ( ) ; }
public void remove All Emails ( ) { emails . clear ( ) ; }
void emit Next ( Object n ) { if ( ! fast Path ) { synchronized ( this ) { first = BOOL ; if ( emitting ) { if ( queue == null ) { queue = new Array List < Object > ( ) ; } queue . add ( n ) ; return ; } } fast Path = BOOL ; } Notification Lite . accept ( actual , n ) ; }
void emit Next ( Object n ) { if ( ! fast Path ) { synchronized ( this ) { first = BOOL ; if ( emitting ) { if ( queue == null ) { queue = new Array List < Object > ( ) ; } queue . add ( n ) ; return ; } } fast Path = BOOL ; } Notification Lite . accept ( actual , n ) ; }
void update Waiting Commands ( ) { int index = commit Index ; if ( is Leader ( ) ) { Core Cmd ccmd = wait Queue . peek ( ) ; while ( ccmd != null && ccmd . index <= index ) { latency . tail ( ccmd . index ) ; ccmd . update ( Command . STATUS OK , leader Id ) ; wait Queue . poll ( ) ; ccmd = wait Queue . peek ( ) ; } } save Queue . get Latest ( saved Rid ) ; index = Math . min ( commit Index , saved Rid . index ) ; commit Queue . update Commit Index ( index ) ; }
void update Waiting Commands ( ) { int index = commit Index ; if ( is Leader ( ) ) { Core Cmd ccmd = wait Queue . peek ( ) ; while ( ccmd != null && ccmd . index <= index ) { latency . tail ( ccmd . index ) ; ccmd . update ( Command . STATUS OK , leader Id ) ; wait Queue . poll ( ) ; ccmd = wait Queue . peek ( ) ; } } save Queue . get Latest ( saved Rid ) ; index = Math . min ( commit Index , saved Rid . index ) ; commit Queue . update Commit Index ( index ) ; }
public static String to String ( final URL url , final Charset encoding ) throws IO Exception { Input Stream input Stream = url . open Stream ( ) ; try { return IO Utils . to String ( input Stream , encoding ) ; } finally { input Stream . close ( ) ; } }
public static String to String ( final URL url , final Charset encoding ) throws IO Exception { Input Stream input Stream = url . open Stream ( ) ; try { return IO Utils . to String ( input Stream , encoding ) ; } finally { input Stream . close ( ) ; } }
public static void write Text File ( String directory , String filename , String data , boolean overwrite ) { try { File f ; f = Util . create File On Device ( directory , filename , overwrite ) ; File Writer fw = new File Writer ( f . get Absolute File ( ) ) ; Buffered Writer bw = new Buffered Writer ( fw ) ; bw . write ( data ) ; bw . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
public static void write Text File ( String directory , String filename , String data , boolean overwrite ) { try { File f ; f = Util . create File On Device ( directory , filename , overwrite ) ; File Writer fw = new File Writer ( f . get Absolute File ( ) ) ; Buffered Writer bw = new Buffered Writer ( fw ) ; bw . write ( data ) ; bw . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
private static J Free Chart create Chart ( ) { XY Series series 1 = new XY Series ( STRING ) ; series 1 . add ( NUM , NUM ) ; series 1 . add ( NUM , NUM ) ; series 1 . add ( NUM , NUM ) ; Interval XY Dataset dataset = new XY Bar Dataset ( new XY Series Collection ( series 1 ) , NUM ) ; return Chart Factory . create XY Bar Chart ( STRING , STRING , BOOL , STRING , dataset ) ; }
public static List < String > filter Tags ( List < Language Range > priority List , Collection < String > tags , Filtering Mode mode ) { return Locale Matcher . filter Tags ( priority List , tags , mode ) ; }
public static List < String > filter Tags ( List < Language Range > priority List , Collection < String > tags , Filtering Mode mode ) { return Locale Matcher . filter Tags ( priority List , tags , mode ) ; }
public static List < String > filter Tags ( List < Language Range > priority List , Collection < String > tags , Filtering Mode mode ) { return Locale Matcher . filter Tags ( priority List , tags , mode ) ; }
public static PSQL Exception extract PSQL Exception ( Throwable exception ) { while ( exception != null ) { if ( exception instanceof PSQL Exception ) { return ( PSQL Exception ) exception ; } exception = exception . get Cause ( ) ; } return null ; }
public static PSQL Exception extract PSQL Exception ( Throwable exception ) { while ( exception != null ) { if ( exception instanceof PSQL Exception ) { return ( PSQL Exception ) exception ; } exception = exception . get Cause ( ) ; } return null ; }
public long to Epoch Second ( ) { return transition . to Epoch Second ( offset Before ) ; }
private static void add Leaf With Non Existing Parents ( Spatial root , Spatial leaf ) { if ( ! ( root instanceof Node ) ) { logger . log ( Level . WARNING , STRING , new Object [ ] { leaf . get Name ( ) , root . get Name ( ) } ) ; return ; } for ( Spatial s = leaf ; s . get Parent ( ) != null ; s = s . get Parent ( ) ) { Spatial parent = s . get Parent ( ) ; Spatial other = find Tagged Spatial ( root , parent ) ; if ( other == null ) { continue ; } if ( other instanceof Node ) { logger . log ( Level . INFO , STRING , new Object [ ] { s , other , root , leaf } ) ; for ( Spatial spt = leaf ; spt != parent ; spt = spt . get Parent ( ) ) { spt . set User Data ( ORIGINAL NAME , spt . get Name ( ) ) ; spt . set User Data ( ORIGINAL PATH , get Spatial Path ( spt ) ) ; spt = spt . get Parent ( ) ; } Node other Node = ( Node ) other ; other Node . attach Child ( s ) ; logger . log ( Log Level . USERINFO , STRING , new Object [ ] { other . get Name ( ) , leaf . get Name ( ) } ) ; return ; } else { logger . log ( Level . WARNING , STRING , new Object [ ] { leaf , other , root } ) ; } } logger . log ( Level . WARNING , STRING , leaf . get Name ( ) ) ; }
private void stop Watchdog ( ) { if ( watchdog != null ) { watchdog . shutdown Now ( ) ; watchdog = null ; } }
public void test Constructor String Radix 10 Negative ( ) { String value = STRING ; int radix = NUM ; byte r Bytes [ ] = { - NUM , NUM , NUM , NUM , - NUM , NUM , - NUM , NUM } ; Big Integer a Number = new Big Integer ( value , radix ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , a Number . signum ( ) ) ; }
public void run Asserts ( List < Step > list , int size , Boolean need Assignee ) { assert Equals ( size , list . size ( ) ) ; for ( int i = NUM ; i < size ; i ++ ) { run Asserts ( list . get ( i ) , i , need Assignee ) ; } }
public void run Asserts ( List < Step > list , int size , Boolean need Assignee ) { assert Equals ( size , list . size ( ) ) ; for ( int i = NUM ; i < size ; i ++ ) { run Asserts ( list . get ( i ) , i , need Assignee ) ; } }
public void connect ( String view ) { try { reader = new Net Map Reader ( server , port , this , view ) ; reader . start ( ) ; if ( server Panel != null ) { server Addr Field . set Enabled ( BOOL ) ; server Port Field . set Enabled ( BOOL ) ; control Button . set Text ( Server Disconnect Cmd ) ; control Button . set Action Command ( Server Disconnect Cmd ) ; } } catch ( IO Exception e ) { Debug . message ( STRING , STRING + e ) ; disconnect ( ) ; } }
public static EC Public Key Parameters read EC Parameters With Public Key ( Input Stream input ) throws IO Exception { EC Domain Parameters domain Parameters = read EC Parameters ( input ) ; int length = input . read ( ) ; byte [ ] point = new byte [ length ] ; input . read ( point ) ; short [ ] point Formats = convert Point Formats ( EC Point Format . values ( ) ) ; return Tls ECC Utils . deserialize EC Public Key ( point Formats , domain Parameters , point ) ; }
public static EC Public Key Parameters read EC Parameters With Public Key ( Input Stream input ) throws IO Exception { EC Domain Parameters domain Parameters = read EC Parameters ( input ) ; int length = input . read ( ) ; byte [ ] point = new byte [ length ] ; input . read ( point ) ; short [ ] point Formats = convert Point Formats ( EC Point Format . values ( ) ) ; return Tls ECC Utils . deserialize EC Public Key ( point Formats , domain Parameters , point ) ; }
public static EC Public Key Parameters read EC Parameters With Public Key ( Input Stream input ) throws IO Exception { EC Domain Parameters domain Parameters = read EC Parameters ( input ) ; int length = input . read ( ) ; byte [ ] point = new byte [ length ] ; input . read ( point ) ; short [ ] point Formats = convert Point Formats ( EC Point Format . values ( ) ) ; return Tls ECC Utils . deserialize EC Public Key ( point Formats , domain Parameters , point ) ; }
public int convert To Pixels ( float dip Count ) { return Math . round ( impl . convert To Pixels ( ( int ) ( dip Count * NUM ) , BOOL ) / NUM ) ; }
public int convert To Pixels ( float dip Count ) { return Math . round ( impl . convert To Pixels ( ( int ) ( dip Count * NUM ) , BOOL ) / NUM ) ; }
public int read ( ) throws IO Exception { int b = in . read ( ) ; if ( b != - NUM ) { cksum . update ( b ) ; } return b ; }
public void quit ( ) { if ( ! is Connected ( ) ) { return ; } if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( STRING ) ; } send ( STRING ) ; try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception ie ) { } disconnect ( ) ; }
public void quit ( ) { if ( ! is Connected ( ) ) { return ; } if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( STRING ) ; } send ( STRING ) ; try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception ie ) { } disconnect ( ) ; }
public void close ( ) throws IO Exception { socket . close ( ) ; }
public void close ( ) throws IO Exception { socket . close ( ) ; }
public void close ( ) throws IO Exception { socket . close ( ) ; }
public void close ( ) throws IO Exception { socket . close ( ) ; }
public Concurrent Coap Resource ( String name ) { super ( name ) ; this . threads = get Available Processors ( ) ; set Executor ( Executors . new Fixed Thread Pool ( threads , new Utils . Named Thread Factory ( STRING + name + STRING ) ) ) ; }
public Builder ( final Input Stream input stream , Traffic Direction direction ) throws Illegal Argument Exception { if ( input stream == null ) { throw new Illegal Argument Exception ( STRING ) ; } this . wrapped Stream = input stream ; if ( direction == null ) { throw new Illegal Argument Exception ( STRING ) ; } this . direction = direction ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Boolean ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Boolean ) obj ) . value == value ; }
public static void prepare Data ( Instances data ) throws Exception { String doptions [ ] = null ; try { doptions = ML Utils . get Dataset Options ( data ) ; } catch ( Exception e ) { throw new Exception ( STRING , e ) ; } try { int c = ( Utils . get Option Pos ( STRING , doptions ) >= NUM ) ? Integer . parse Int ( Utils . get Option ( STRING , doptions ) ) : Integer . parse Int ( Utils . get Option ( STRING , doptions ) ) ; if ( c < NUM ) { c = - c ; data = F . mulan 2 meka ( data , c ) ; } data . set Class Index ( c ) ; } catch ( Exception e ) { throw new Exception ( STRING + STRING + STRING + STRING + data . relation Name ( ) + STRING + STRING + STRING + STRING , e ) ; } }
public Task < Void > unpin In Background ( ) { return unpin All In Background ( DEFAULT PIN , Arrays . as List ( this ) ) ; }
public Task < Void > unpin In Background ( ) { return unpin All In Background ( DEFAULT PIN , Arrays . as List ( this ) ) ; }
public Task < Void > unpin In Background ( ) { return unpin All In Background ( DEFAULT PIN , Arrays . as List ( this ) ) ; }
@ Override public String to String ( ) { return node Id + STRING + action Values . to String ( ) ; }
@ Override public String to String ( ) { return node Id + STRING + action Values . to String ( ) ; }
private static int append Intersection Type Signature ( char [ ] string , int start , boolean fully Qualify Type Names , String Buffer buffer ) { if ( start >= string . length - NUM ) { throw new Illegal Argument Exception ( ) ; } char c = string [ start ] ; if ( c != C INTERSECTION ) { throw new Illegal Argument Exception ( ) ; } start = append Class Type Signature ( string , start + NUM , fully Qualify Type Names , buffer ) ; if ( start < string . length - NUM ) { start ++ ; if ( string [ start ] != C COLON ) { throw new Illegal Argument Exception ( STRING ) ; } while ( string [ start ] == C COLON ) { buffer . append ( STRING ) ; start = append Class Type Signature ( string , start + NUM , fully Qualify Type Names , buffer ) ; if ( start == string . length - NUM ) { return start ; } else if ( start > string . length - NUM ) { throw new Illegal Argument Exception ( STRING ) ; } start ++ ; } } return start ; }
private static int append Intersection Type Signature ( char [ ] string , int start , boolean fully Qualify Type Names , String Buffer buffer ) { if ( start >= string . length - NUM ) { throw new Illegal Argument Exception ( ) ; } char c = string [ start ] ; if ( c != C INTERSECTION ) { throw new Illegal Argument Exception ( ) ; } start = append Class Type Signature ( string , start + NUM , fully Qualify Type Names , buffer ) ; if ( start < string . length - NUM ) { start ++ ; if ( string [ start ] != C COLON ) { throw new Illegal Argument Exception ( STRING ) ; } while ( string [ start ] == C COLON ) { buffer . append ( STRING ) ; start = append Class Type Signature ( string , start + NUM , fully Qualify Type Names , buffer ) ; if ( start == string . length - NUM ) { return start ; } else if ( start > string . length - NUM ) { throw new Illegal Argument Exception ( STRING ) ; } start ++ ; } } return start ; }
private static int append Intersection Type Signature ( char [ ] string , int start , boolean fully Qualify Type Names , String Buffer buffer ) { if ( start >= string . length - NUM ) { throw new Illegal Argument Exception ( ) ; } char c = string [ start ] ; if ( c != C INTERSECTION ) { throw new Illegal Argument Exception ( ) ; } start = append Class Type Signature ( string , start + NUM , fully Qualify Type Names , buffer ) ; if ( start < string . length - NUM ) { start ++ ; if ( string [ start ] != C COLON ) { throw new Illegal Argument Exception ( STRING ) ; } while ( string [ start ] == C COLON ) { buffer . append ( STRING ) ; start = append Class Type Signature ( string , start + NUM , fully Qualify Type Names , buffer ) ; if ( start == string . length - NUM ) { return start ; } else if ( start > string . length - NUM ) { throw new Illegal Argument Exception ( STRING ) ; } start ++ ; } } return start ; }
private static int append Intersection Type Signature ( char [ ] string , int start , boolean fully Qualify Type Names , String Buffer buffer ) { if ( start >= string . length - NUM ) { throw new Illegal Argument Exception ( ) ; } char c = string [ start ] ; if ( c != C INTERSECTION ) { throw new Illegal Argument Exception ( ) ; } start = append Class Type Signature ( string , start + NUM , fully Qualify Type Names , buffer ) ; if ( start < string . length - NUM ) { start ++ ; if ( string [ start ] != C COLON ) { throw new Illegal Argument Exception ( STRING ) ; } while ( string [ start ] == C COLON ) { buffer . append ( STRING ) ; start = append Class Type Signature ( string , start + NUM , fully Qualify Type Names , buffer ) ; if ( start == string . length - NUM ) { return start ; } else if ( start > string . length - NUM ) { throw new Illegal Argument Exception ( STRING ) ; } start ++ ; } } return start ; }
public Wrapping String Builder append ( final String s ) { final int end = s . length ( ) ; for ( int i = NUM ; i < end ; i ++ ) { append ( s . char At ( i ) ) ; } return this ; }
public void handle Window Focus Event ( boolean parent Window Active ) { this . parent Window Active = parent Window Active ; synchronized ( class Lock ) { if ( ! parent Window Active ) { this . browser Window Focused Applet = global Focused Window ; } if ( parent Window Active && global Focused Window != this && is Parent Window Changed ( ) ) { global Focused Window = ( this . browser Window Focused Applet != null ) ? this . browser Window Focused Applet : this ; } } if ( global Focused Window == this && parent Window Active ) { responder . handle Window Focus Event ( parent Window Active , null ) ; } }
public void handle Window Focus Event ( boolean parent Window Active ) { this . parent Window Active = parent Window Active ; synchronized ( class Lock ) { if ( ! parent Window Active ) { this . browser Window Focused Applet = global Focused Window ; } if ( parent Window Active && global Focused Window != this && is Parent Window Changed ( ) ) { global Focused Window = ( this . browser Window Focused Applet != null ) ? this . browser Window Focused Applet : this ; } } if ( global Focused Window == this && parent Window Active ) { responder . handle Window Focus Event ( parent Window Active , null ) ; } }
public void handle Window Focus Event ( boolean parent Window Active ) { this . parent Window Active = parent Window Active ; synchronized ( class Lock ) { if ( ! parent Window Active ) { this . browser Window Focused Applet = global Focused Window ; } if ( parent Window Active && global Focused Window != this && is Parent Window Changed ( ) ) { global Focused Window = ( this . browser Window Focused Applet != null ) ? this . browser Window Focused Applet : this ; } } if ( global Focused Window == this && parent Window Active ) { responder . handle Window Focus Event ( parent Window Active , null ) ; } }
public void handle Window Focus Event ( boolean parent Window Active ) { this . parent Window Active = parent Window Active ; synchronized ( class Lock ) { if ( ! parent Window Active ) { this . browser Window Focused Applet = global Focused Window ; } if ( parent Window Active && global Focused Window != this && is Parent Window Changed ( ) ) { global Focused Window = ( this . browser Window Focused Applet != null ) ? this . browser Window Focused Applet : this ; } } if ( global Focused Window == this && parent Window Active ) { responder . handle Window Focus Event ( parent Window Active , null ) ; } }
public void handle Window Focus Event ( boolean parent Window Active ) { this . parent Window Active = parent Window Active ; synchronized ( class Lock ) { if ( ! parent Window Active ) { this . browser Window Focused Applet = global Focused Window ; } if ( parent Window Active && global Focused Window != this && is Parent Window Changed ( ) ) { global Focused Window = ( this . browser Window Focused Applet != null ) ? this . browser Window Focused Applet : this ; } } if ( global Focused Window == this && parent Window Active ) { responder . handle Window Focus Event ( parent Window Active , null ) ; } }
public void handle Window Focus Event ( boolean parent Window Active ) { this . parent Window Active = parent Window Active ; synchronized ( class Lock ) { if ( ! parent Window Active ) { this . browser Window Focused Applet = global Focused Window ; } if ( parent Window Active && global Focused Window != this && is Parent Window Changed ( ) ) { global Focused Window = ( this . browser Window Focused Applet != null ) ? this . browser Window Focused Applet : this ; } } if ( global Focused Window == this && parent Window Active ) { responder . handle Window Focus Event ( parent Window Active , null ) ; } }
public void handle Window Focus Event ( boolean parent Window Active ) { this . parent Window Active = parent Window Active ; synchronized ( class Lock ) { if ( ! parent Window Active ) { this . browser Window Focused Applet = global Focused Window ; } if ( parent Window Active && global Focused Window != this && is Parent Window Changed ( ) ) { global Focused Window = ( this . browser Window Focused Applet != null ) ? this . browser Window Focused Applet : this ; } } if ( global Focused Window == this && parent Window Active ) { responder . handle Window Focus Event ( parent Window Active , null ) ; } }
public void handle Window Focus Event ( boolean parent Window Active ) { this . parent Window Active = parent Window Active ; synchronized ( class Lock ) { if ( ! parent Window Active ) { this . browser Window Focused Applet = global Focused Window ; } if ( parent Window Active && global Focused Window != this && is Parent Window Changed ( ) ) { global Focused Window = ( this . browser Window Focused Applet != null ) ? this . browser Window Focused Applet : this ; } } if ( global Focused Window == this && parent Window Active ) { responder . handle Window Focus Event ( parent Window Active , null ) ; } }
public static String [ ] line To Array ( String line ) { String [ ] split Array ; split Array = line . split ( STRING ) ; return split Array ; }
public void delete Last ( ) { final int codes Size = m Codes . size ( ) ; if ( codes Size > NUM ) { m Codes . remove ( codes Size - NUM ) ; final int last Pos = m Typed Word . length ( ) - NUM ; char last = m Typed Word . char At ( last Pos ) ; m Typed Word . delete Char At ( last Pos ) ; if ( Character . is Upper Case ( last ) ) m Caps Count -- ; } }
public void delete Last ( ) { final int codes Size = m Codes . size ( ) ; if ( codes Size > NUM ) { m Codes . remove ( codes Size - NUM ) ; final int last Pos = m Typed Word . length ( ) - NUM ; char last = m Typed Word . char At ( last Pos ) ; m Typed Word . delete Char At ( last Pos ) ; if ( Character . is Upper Case ( last ) ) m Caps Count -- ; } }
private Client create Server Client ( ) { Client client = new Client ( ) ; client . name = STRING ; client . registration Token = SENDER ID + STRING ; client . profile Picture Url = STRING ; return client ; }
protected boolean remove If Present Estimate ( Estimate Map Key key , Load Estimate Task task ) { return estimate Map . remove ( key , task ) ; }
protected boolean remove If Present Estimate ( Estimate Map Key key , Load Estimate Task task ) { return estimate Map . remove ( key , task ) ; }
public SDP Announce Parser ( String message ) { int start = NUM ; String line = null ; if ( message == null ) return ; sdp Message = new Vector ( ) ; String sdp Announce = message . trim ( ) + STRING ; while ( start < sdp Announce . length ( ) ) { int lf Pos = sdp Announce . index Of ( STRING , start ) ; int cr Pos = sdp Announce . index Of ( STRING , start ) ; if ( lf Pos >= NUM && cr Pos < NUM ) { line = sdp Announce . substring ( start , lf Pos ) ; start = lf Pos + NUM ; } else if ( lf Pos < NUM && cr Pos >= NUM ) { line = sdp Announce . substring ( start , cr Pos ) ; start = cr Pos + NUM ; } else if ( lf Pos >= NUM && cr Pos >= NUM ) { if ( lf Pos > cr Pos ) { line = sdp Announce . substring ( start , cr Pos ) ; if ( lf Pos == cr Pos + NUM ) { start = lf Pos + NUM ; } else { start = cr Pos + NUM ; } } else { line = sdp Announce . substring ( start , lf Pos ) ; if ( cr Pos == lf Pos + NUM ) { start = cr Pos + NUM ; } else { start = lf Pos + NUM ; } } } else if ( lf Pos < NUM && cr Pos < NUM ) { break ; } sdp Message . add Element ( line ) ; } }
public static J Panel create Error Component ( String error ) { J Panel panel = new J Panel ( new Border Layout ( ) ) ; J Label label = new J Label ( error , ERROR ICON , Swing Constants . CENTER ) ; panel . add ( label , Border Layout . CENTER ) ; return panel ; }
public static J Panel create Error Component ( String error ) { J Panel panel = new J Panel ( new Border Layout ( ) ) ; J Label label = new J Label ( error , ERROR ICON , Swing Constants . CENTER ) ; panel . add ( label , Border Layout . CENTER ) ; return panel ; }
public static J Panel create Error Component ( String error ) { J Panel panel = new J Panel ( new Border Layout ( ) ) ; J Label label = new J Label ( error , ERROR ICON , Swing Constants . CENTER ) ; panel . add ( label , Border Layout . CENTER ) ; return panel ; }
private void reset ( ) { is Content = BOOL ; finished = BOOL ; }
private void reset ( ) { is Content = BOOL ; finished = BOOL ; }
@ Target Api ( Build . VERSION CODES . HONEYCOMB ) private static void choose Preview Size ( Camera . Parameters parms , int width , int height ) { List < Camera . Size > previews = parms . get Supported Preview Sizes ( ) ; for ( Camera . Size size : previews ) { if ( size . width == width && size . height == height ) { parms . set Preview Size ( width , height ) ; if ( Cfg . DEBUG ) { Check . log ( TAG + STRING ) ; } return ; } } Camera . Size best = get Best Preview Size ( parms , width , height ) ; if ( best != null ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + best . width + STRING + best . height ) ; } } if ( best != null ) { Log . w ( TAG , STRING + width + STRING + height ) ; parms . set Preview Size ( best . width , best . height ) ; } }
@ Target Api ( Build . VERSION CODES . HONEYCOMB ) private static void choose Preview Size ( Camera . Parameters parms , int width , int height ) { List < Camera . Size > previews = parms . get Supported Preview Sizes ( ) ; for ( Camera . Size size : previews ) { if ( size . width == width && size . height == height ) { parms . set Preview Size ( width , height ) ; if ( Cfg . DEBUG ) { Check . log ( TAG + STRING ) ; } return ; } } Camera . Size best = get Best Preview Size ( parms , width , height ) ; if ( best != null ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + best . width + STRING + best . height ) ; } } if ( best != null ) { Log . w ( TAG , STRING + width + STRING + height ) ; parms . set Preview Size ( best . width , best . height ) ; } }
@ Target Api ( Build . VERSION CODES . HONEYCOMB ) private static void choose Preview Size ( Camera . Parameters parms , int width , int height ) { List < Camera . Size > previews = parms . get Supported Preview Sizes ( ) ; for ( Camera . Size size : previews ) { if ( size . width == width && size . height == height ) { parms . set Preview Size ( width , height ) ; if ( Cfg . DEBUG ) { Check . log ( TAG + STRING ) ; } return ; } } Camera . Size best = get Best Preview Size ( parms , width , height ) ; if ( best != null ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + best . width + STRING + best . height ) ; } } if ( best != null ) { Log . w ( TAG , STRING + width + STRING + height ) ; parms . set Preview Size ( best . width , best . height ) ; } }
@ Target Api ( Build . VERSION CODES . HONEYCOMB ) private static void choose Preview Size ( Camera . Parameters parms , int width , int height ) { List < Camera . Size > previews = parms . get Supported Preview Sizes ( ) ; for ( Camera . Size size : previews ) { if ( size . width == width && size . height == height ) { parms . set Preview Size ( width , height ) ; if ( Cfg . DEBUG ) { Check . log ( TAG + STRING ) ; } return ; } } Camera . Size best = get Best Preview Size ( parms , width , height ) ; if ( best != null ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + best . width + STRING + best . height ) ; } } if ( best != null ) { Log . w ( TAG , STRING + width + STRING + height ) ; parms . set Preview Size ( best . width , best . height ) ; } }
@ Target Api ( Build . VERSION CODES . HONEYCOMB ) private static void choose Preview Size ( Camera . Parameters parms , int width , int height ) { List < Camera . Size > previews = parms . get Supported Preview Sizes ( ) ; for ( Camera . Size size : previews ) { if ( size . width == width && size . height == height ) { parms . set Preview Size ( width , height ) ; if ( Cfg . DEBUG ) { Check . log ( TAG + STRING ) ; } return ; } } Camera . Size best = get Best Preview Size ( parms , width , height ) ; if ( best != null ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + best . width + STRING + best . height ) ; } } if ( best != null ) { Log . w ( TAG , STRING + width + STRING + height ) ; parms . set Preview Size ( best . width , best . height ) ; } }
@ Target Api ( Build . VERSION CODES . HONEYCOMB ) private static void choose Preview Size ( Camera . Parameters parms , int width , int height ) { List < Camera . Size > previews = parms . get Supported Preview Sizes ( ) ; for ( Camera . Size size : previews ) { if ( size . width == width && size . height == height ) { parms . set Preview Size ( width , height ) ; if ( Cfg . DEBUG ) { Check . log ( TAG + STRING ) ; } return ; } } Camera . Size best = get Best Preview Size ( parms , width , height ) ; if ( best != null ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + best . width + STRING + best . height ) ; } } if ( best != null ) { Log . w ( TAG , STRING + width + STRING + height ) ; parms . set Preview Size ( best . width , best . height ) ; } }
public static boolean string To Boolean Value ( String str ) throws Expression Exception { str = String Util . to Lower Case ( str . trim ( ) ) ; if ( str . equals ( STRING ) || str . equals ( STRING ) ) return BOOL ; else if ( str . equals ( STRING ) || str . equals ( STRING ) ) return BOOL ; throw new Caster Exception ( STRING + str + STRING ) ; }
public final float tan FOV ( ) { return ( ( float ) Math . tan ( Math . to Radians ( fov Y * NUM ) ) ) ; }
public static String string Default Value ( String bytes ) { return new String ( bytes . get Bytes ( ISO 8859 1 ) , Internal Nano . UTF 8 ) ; }
public static String string Default Value ( String bytes ) { return new String ( bytes . get Bytes ( ISO 8859 1 ) , Internal Nano . UTF 8 ) ; }
public static String string Default Value ( String bytes ) { return new String ( bytes . get Bytes ( ISO 8859 1 ) , Internal Nano . UTF 8 ) ; }
public static String string Default Value ( String bytes ) { return new String ( bytes . get Bytes ( ISO 8859 1 ) , Internal Nano . UTF 8 ) ; }
public static String string Default Value ( String bytes ) { return new String ( bytes . get Bytes ( ISO 8859 1 ) , Internal Nano . UTF 8 ) ; }
public static String string Default Value ( String bytes ) { return new String ( bytes . get Bytes ( ISO 8859 1 ) , Internal Nano . UTF 8 ) ; }
public static String string Default Value ( String bytes ) { return new String ( bytes . get Bytes ( ISO 8859 1 ) , Internal Nano . UTF 8 ) ; }
public static String string Default Value ( String bytes ) { return new String ( bytes . get Bytes ( ISO 8859 1 ) , Internal Nano . UTF 8 ) ; }
public static String string Default Value ( String bytes ) { return new String ( bytes . get Bytes ( ISO 8859 1 ) , Internal Nano . UTF 8 ) ; }
public static String string Default Value ( String bytes ) { return new String ( bytes . get Bytes ( ISO 8859 1 ) , Internal Nano . UTF 8 ) ; }
public static String string Default Value ( String bytes ) { return new String ( bytes . get Bytes ( ISO 8859 1 ) , Internal Nano . UTF 8 ) ; }
public static String string Default Value ( String bytes ) { return new String ( bytes . get Bytes ( ISO 8859 1 ) , Internal Nano . UTF 8 ) ; }
public static String string Default Value ( String bytes ) { return new String ( bytes . get Bytes ( ISO 8859 1 ) , Internal Nano . UTF 8 ) ; }
public static String string Default Value ( String bytes ) { return new String ( bytes . get Bytes ( ISO 8859 1 ) , Internal Nano . UTF 8 ) ; }
@ Override public void operator Exported ( final Operator op , final Element op Element ) { Rectangle 2 D bounds = lookup Operator Rectangle ( op ) ; if ( bounds != null ) { op Element . set Attribute ( XML ATTRIBUTE X POSITION , STRING + ( int ) bounds . get X ( ) ) ; op Element . set Attribute ( XML ATTRIBUTE Y POSITION , STRING + ( int ) bounds . get Y ( ) ) ; op Element . set Attribute ( XML ATTRIBUTE WIDTH , STRING + ( int ) bounds . get Width ( ) ) ; op Element . set Attribute ( XML ATTRIBUTE HEIGHT , STRING + ( int ) bounds . get Height ( ) ) ; } }
private void notify All Entity ( ) { Log . print Concat Line ( super . get Name ( ) , STRING ) ; signal Shutdown ( res List ) ; signal Shutdown ( gis List ) ; res List . clear ( ) ; gis List . clear ( ) ; }
private void notify All Entity ( ) { Log . print Concat Line ( super . get Name ( ) , STRING ) ; signal Shutdown ( res List ) ; signal Shutdown ( gis List ) ; res List . clear ( ) ; gis List . clear ( ) ; }
@ Override public void resume Locking ( ) { check Destroyed ( ) ; try { unlock ( SUSPEND LOCKING TOKEN ) ; } catch ( Illegal State Exception e ) { check Destroyed ( ) ; throw e ; } }
public synchronized void remove Batch Association Rules Listener ( Batch Association Rules Listener al ) { m rules Listeners . remove ( al ) ; }
public final void close ( Ls Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } log . debug ( STRING + close Packet + STRING ) ; pending Close = BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
public final void close ( Ls Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } log . debug ( STRING + close Packet + STRING ) ; pending Close = BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
public final void close ( Ls Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } log . debug ( STRING + close Packet + STRING ) ; pending Close = BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
public final void close ( Ls Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } log . debug ( STRING + close Packet + STRING ) ; pending Close = BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
public final void close ( Ls Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } log . debug ( STRING + close Packet + STRING ) ; pending Close = BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
public final void close ( Ls Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } log . debug ( STRING + close Packet + STRING ) ; pending Close = BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
public final void close ( Ls Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } log . debug ( STRING + close Packet + STRING ) ; pending Close = BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
final public void do Local Abort ( ) { abort ( ) ; }
final public void do Local Abort ( ) { abort ( ) ; }
final public void do Local Abort ( ) { abort ( ) ; }
private void handle Html Search Quotations ( Page Wrapper page Wrapper , Request And Response request And Response , String query , String pane Id ) throws IO Exception , Servlet Exception { page Wrapper . add Page Intro Text ( servlet Text . intro Text Search Quotations ( BOOL ) , servlet Text . intro Text Search Quotations ( BOOL ) ) ; try { final String Builder result = new String Builder ( ) ; User query User = null ; if ( null != ( query User = can User See Users Data ( request And Response , BOOL ) ) ) { final Results Paginator paginator = new Results Paginator ( request And Response , servlet Text . sentence There Were No Matches ( ) , result , servlet Text ) ; try { final List < ? > results = db Logic . search Entries For User By Quotation ( query User . get Id ( ) , query , paginator . get Start Position ( ) , paginator . get Max Results ( ) ) ; entry List To Html And Json ( pane Id , result , paginator , results ) ; } catch ( Empty Query Exception e ) { request And Response . print ( servlet Text . error Need Longer Query ( ) ) ; } } db Logic . commit ( ) ; request And Response . print ( result . to String ( ) ) ; } catch ( final Persistence Exception e ) { request And Response . print ( servlet Text . error Internal Database ( ) ) ; } }
public static String to Stream ( String channel ) { if ( channel == null ) { return null ; } if ( channel . starts With ( STRING ) ) { return channel . substring ( NUM ) ; } return channel ; }
public long next ( ) { long result = - NUM ; if ( cache < NUM && buffer Elements > NUM ) { result = get Next From Buffer ( ) ; buffer Elements -- ; } else { result = cache ; cache = - NUM ; } if ( ! cs . is Empty ( ) ) { long first = cs . first ( ) ; if ( result > first || result == - NUM ) { cs . remove ( first ) ; cache = result ; result = first ; } } if ( result == - NUM ) { throw new No Such Element Exception ( ) ; } Assert . check ( previous < result , EC . GENERAL ) ; previous = result ; read Elements ++ ; return result ; }
public long next ( ) { long result = - NUM ; if ( cache < NUM && buffer Elements > NUM ) { result = get Next From Buffer ( ) ; buffer Elements -- ; } else { result = cache ; cache = - NUM ; } if ( ! cs . is Empty ( ) ) { long first = cs . first ( ) ; if ( result > first || result == - NUM ) { cs . remove ( first ) ; cache = result ; result = first ; } } if ( result == - NUM ) { throw new No Such Element Exception ( ) ; } Assert . check ( previous < result , EC . GENERAL ) ; previous = result ; read Elements ++ ; return result ; }
public Platform Exception ( Throwable cause ) { this ( cause . get Message ( ) , cause ) ; }
public void add Action ( String action ) { Object [ ] args = new String [ NUM ] ; Simple Date Format sdf = new Simple Date Format ( context . get String ( R . string . date Format ) ) ; args [ NUM ] = sdf . format ( new Date ( ) ) ; String timestamp = context . get String ( R . string . timestamp , args ) ; history . add ( action + timestamp ) ; notify Listeners ( new Property Change Event ( this , Activity Constants . history Property , null , null ) ) ; }
public Instances string Free Structure ( ) { Array List < Attribute > new Atts = new Array List < Attribute > ( ) ; for ( Attribute att : m Attributes ) { if ( att . type ( ) == Attribute . STRING ) { new Atts . add ( new Attribute ( att . name ( ) , ( List < String > ) null , att . index ( ) ) ) ; } else if ( att . type ( ) == Attribute . RELATIONAL ) { new Atts . add ( new Attribute ( att . name ( ) , new Instances ( att . relation ( ) , NUM ) , att . index ( ) ) ) ; } } if ( new Atts . size ( ) == NUM ) { return new Instances ( this , NUM ) ; } Array List < Attribute > atts = Utils . cast ( m Attributes . clone ( ) ) ; for ( Attribute att : new Atts ) { atts . set ( att . index ( ) , att ) ; } Instances result = new Instances ( this , NUM ) ; result . m Attributes = atts ; return result ; }
public Instances string Free Structure ( ) { Array List < Attribute > new Atts = new Array List < Attribute > ( ) ; for ( Attribute att : m Attributes ) { if ( att . type ( ) == Attribute . STRING ) { new Atts . add ( new Attribute ( att . name ( ) , ( List < String > ) null , att . index ( ) ) ) ; } else if ( att . type ( ) == Attribute . RELATIONAL ) { new Atts . add ( new Attribute ( att . name ( ) , new Instances ( att . relation ( ) , NUM ) , att . index ( ) ) ) ; } } if ( new Atts . size ( ) == NUM ) { return new Instances ( this , NUM ) ; } Array List < Attribute > atts = Utils . cast ( m Attributes . clone ( ) ) ; for ( Attribute att : new Atts ) { atts . set ( att . index ( ) , att ) ; } Instances result = new Instances ( this , NUM ) ; result . m Attributes = atts ; return result ; }
public Instances string Free Structure ( ) { Array List < Attribute > new Atts = new Array List < Attribute > ( ) ; for ( Attribute att : m Attributes ) { if ( att . type ( ) == Attribute . STRING ) { new Atts . add ( new Attribute ( att . name ( ) , ( List < String > ) null , att . index ( ) ) ) ; } else if ( att . type ( ) == Attribute . RELATIONAL ) { new Atts . add ( new Attribute ( att . name ( ) , new Instances ( att . relation ( ) , NUM ) , att . index ( ) ) ) ; } } if ( new Atts . size ( ) == NUM ) { return new Instances ( this , NUM ) ; } Array List < Attribute > atts = Utils . cast ( m Attributes . clone ( ) ) ; for ( Attribute att : new Atts ) { atts . set ( att . index ( ) , att ) ; } Instances result = new Instances ( this , NUM ) ; result . m Attributes = atts ; return result ; }
public Instances string Free Structure ( ) { Array List < Attribute > new Atts = new Array List < Attribute > ( ) ; for ( Attribute att : m Attributes ) { if ( att . type ( ) == Attribute . STRING ) { new Atts . add ( new Attribute ( att . name ( ) , ( List < String > ) null , att . index ( ) ) ) ; } else if ( att . type ( ) == Attribute . RELATIONAL ) { new Atts . add ( new Attribute ( att . name ( ) , new Instances ( att . relation ( ) , NUM ) , att . index ( ) ) ) ; } } if ( new Atts . size ( ) == NUM ) { return new Instances ( this , NUM ) ; } Array List < Attribute > atts = Utils . cast ( m Attributes . clone ( ) ) ; for ( Attribute att : new Atts ) { atts . set ( att . index ( ) , att ) ; } Instances result = new Instances ( this , NUM ) ; result . m Attributes = atts ; return result ; }
private static float snap Percent ( float percent ) { int value = ( int ) ( percent * NUM ) ; int slope = NUM ; if ( Math . abs ( value - NUM ) <= slope ) { value = NUM ; } if ( Math . abs ( value - NUM ) <= slope ) { value = NUM ; } if ( Math . abs ( value - NUM ) <= slope ) { value = NUM ; } if ( Math . abs ( value - NUM ) <= slope ) { value = NUM ; } if ( Math . abs ( value - NUM ) <= slope ) { value = NUM ; } return ( value / NUM ) ; }
private static float snap Percent ( float percent ) { int value = ( int ) ( percent * NUM ) ; int slope = NUM ; if ( Math . abs ( value - NUM ) <= slope ) { value = NUM ; } if ( Math . abs ( value - NUM ) <= slope ) { value = NUM ; } if ( Math . abs ( value - NUM ) <= slope ) { value = NUM ; } if ( Math . abs ( value - NUM ) <= slope ) { value = NUM ; } if ( Math . abs ( value - NUM ) <= slope ) { value = NUM ; } return ( value / NUM ) ; }
public static void append ( Readable Date Time t , String Builder s ) { s . append ( t . get Year ( ) ) ; append Two Digits ( t . get Month Of Year ( ) , s ) ; append Two Digits ( t . get Day Of Month ( ) , s ) ; s . append ( STRING ) ; append Two Digits ( t . get Hour Of Day ( ) , s ) ; s . append ( STRING ) ; append Two Digits ( t . get Minute Of Hour ( ) , s ) ; s . append ( STRING ) ; append Two Digits ( t . get Second Of Minute ( ) , s ) ; s . append ( STRING ) ; append Three Digits ( t . get Millis Of Second ( ) , s ) ; }
public void update Trigger Data Member ( Boolean trigger Data Member ) throws Security Exception { check Write Access ( ) ; boolean has Access = Config Web Util . has Access ( config , Security Manager . TYPE SETTING ) ; if ( ! has Access ) throw new Security Exception ( STRING ) ; Element scope = get Root Element ( STRING ) ; scope . set Attribute ( STRING , Caster . to String ( trigger Data Member , STRING ) ) ; }
private void build Dom Tree ( ) { int sz Nodes = nodes . size ( ) ; for ( int i = NUM ; i < sz Nodes ; i ++ ) { Dom Info info = dom Infos [ i ] ; if ( info . idom == - NUM ) continue ; Ssa Basic Block dom Parent = nodes . get ( info . idom ) ; dom Parent . add Dom Child ( nodes . get ( i ) ) ; } }
private void build Dom Tree ( ) { int sz Nodes = nodes . size ( ) ; for ( int i = NUM ; i < sz Nodes ; i ++ ) { Dom Info info = dom Infos [ i ] ; if ( info . idom == - NUM ) continue ; Ssa Basic Block dom Parent = nodes . get ( info . idom ) ; dom Parent . add Dom Child ( nodes . get ( i ) ) ; } }
private void build Dom Tree ( ) { int sz Nodes = nodes . size ( ) ; for ( int i = NUM ; i < sz Nodes ; i ++ ) { Dom Info info = dom Infos [ i ] ; if ( info . idom == - NUM ) continue ; Ssa Basic Block dom Parent = nodes . get ( info . idom ) ; dom Parent . add Dom Child ( nodes . get ( i ) ) ; } }
private static void add Digest ( Message Digest digest , String string ) { if ( string == null ) return ; int len = string . length ( ) ; for ( int i = NUM ; i < len ; i ++ ) { int ch = string . char At ( i ) ; if ( ch < NUM ) digest . update ( ( byte ) ch ) ; else if ( ch < NUM ) { digest . update ( ( byte ) ( NUM + ( ch > > NUM ) ) ) ; digest . update ( ( byte ) ( NUM + ( ch & NUM ) ) ) ; } else { digest . update ( ( byte ) ( NUM + ( ch > > NUM ) ) ) ; digest . update ( ( byte ) ( NUM + ( ( ch > > NUM ) & NUM ) ) ) ; digest . update ( ( byte ) ( NUM + ( ch & NUM ) ) ) ; } } }
private static void add Digest ( Message Digest digest , String string ) { if ( string == null ) return ; int len = string . length ( ) ; for ( int i = NUM ; i < len ; i ++ ) { int ch = string . char At ( i ) ; if ( ch < NUM ) digest . update ( ( byte ) ch ) ; else if ( ch < NUM ) { digest . update ( ( byte ) ( NUM + ( ch > > NUM ) ) ) ; digest . update ( ( byte ) ( NUM + ( ch & NUM ) ) ) ; } else { digest . update ( ( byte ) ( NUM + ( ch > > NUM ) ) ) ; digest . update ( ( byte ) ( NUM + ( ( ch > > NUM ) & NUM ) ) ) ; digest . update ( ( byte ) ( NUM + ( ch & NUM ) ) ) ; } } }
public static < T > List < T > create Proxies ( Optional < SSL Socket Factory > ssl Socket Factory , Collection < String > endpoint Uris , Class < T > type ) { List < T > ret = Lists . new Array List With Capacity ( endpoint Uris . size ( ) ) ; for ( String uri : endpoint Uris ) { ret . add ( create Proxy ( ssl Socket Factory , uri , type ) ) ; } return ret ; }
protected void to String ( final String Builder sb ) { if ( init View ) { sb . append ( STRING + range Count ) ; sb . append ( STRING + partition Count ) ; sb . append ( STRING + adjusted Nominal Shard Size ) ; sb . append ( STRING + percent Of Split ) ; sb . append ( STRING + tail Split ) ; } }
public String to XML ( final X Stream xstream , final Object obj ) throws Object Stream Exception { final Writer writer = new String Writer ( ) ; try { to XML ( xstream , obj , writer ) ; } catch ( final Object Stream Exception e ) { throw e ; } catch ( final IO Exception e ) { throw new Stream Exception ( STRING , e ) ; } return writer . to String ( ) ; }
public void add To Classification ( Integer class Id , int size , List < Long > positions ) throws IO Exception { number Of Classes ++ ; classification Index Tmp File Writer . write Int ( class Id ) ; if ( size == positions . size ( ) ) classification Index Tmp File Writer . write Int ( size ) ; else { classification Index Tmp File Writer . write Int ( - size ) ; classification Index Tmp File Writer . write Int ( positions . size ( ) ) ; } if ( positions . size ( ) > NUM ) { classification Index Tmp File Writer . write Long ( io . get Position ( ) ) ; for ( Long pos : positions ) { io . write Long ( pos ) ; } } else { classification Index Tmp File Writer . write Long ( - NUM ) ; } }
public static File download File From ( Release release ) throws IO Exception { File file = new File ( Naming Utils . build Name From ( release ) ) ; if ( ! file . exists ( ) ) { obtain New Jar From ( release , file ) ; } return file ; }
public static File download File From ( Release release ) throws IO Exception { File file = new File ( Naming Utils . build Name From ( release ) ) ; if ( ! file . exists ( ) ) { obtain New Jar From ( release , file ) ; } return file ; }
public static File download File From ( Release release ) throws IO Exception { File file = new File ( Naming Utils . build Name From ( release ) ) ; if ( ! file . exists ( ) ) { obtain New Jar From ( release , file ) ; } return file ; }
public static File download File From ( Release release ) throws IO Exception { File file = new File ( Naming Utils . build Name From ( release ) ) ; if ( ! file . exists ( ) ) { obtain New Jar From ( release , file ) ; } return file ; }
public static File download File From ( Release release ) throws IO Exception { File file = new File ( Naming Utils . build Name From ( release ) ) ; if ( ! file . exists ( ) ) { obtain New Jar From ( release , file ) ; } return file ; }
public static File download File From ( Release release ) throws IO Exception { File file = new File ( Naming Utils . build Name From ( release ) ) ; if ( ! file . exists ( ) ) { obtain New Jar From ( release , file ) ; } return file ; }
public static void add Custom Attributes ( XML Stream Reader xtr , Base Element element , List < Extension Attribute > ... black Lists ) { for ( int i = NUM ; i < xtr . get Attribute Count ( ) ; i ++ ) { Extension Attribute extension Attribute = new Extension Attribute ( ) ; extension Attribute . set Name ( xtr . get Attribute Local Name ( i ) ) ; extension Attribute . set Value ( xtr . get Attribute Value ( i ) ) ; if ( String Utils . is Not Empty ( xtr . get Attribute Namespace ( i ) ) ) { extension Attribute . set Namespace ( xtr . get Attribute Namespace ( i ) ) ; } if ( String Utils . is Not Empty ( xtr . get Attribute Prefix ( i ) ) ) { extension Attribute . set Namespace Prefix ( xtr . get Attribute Prefix ( i ) ) ; } if ( ! is Blacklisted ( extension Attribute , black Lists ) ) { element . add Attribute ( extension Attribute ) ; } } }
@ Override public void connection Lost ( Throwable cause ) { on Disconnect ( BOOL ) ; }
public < T > T create ( Class < T > service , T Protocol Factory protocol Factory , Scheduler subscrib Scheduler , Interceptor ... interceptors ) { if ( ! service . is Interface ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } return ( T ) Proxy . new Proxy Instance ( service . get Class Loader ( ) , new Class < ? > [ ] { service } , new Client ( protocol Factory , subscrib Scheduler , interceptors ) ) ; }
public < T > T create ( Class < T > service , T Protocol Factory protocol Factory , Scheduler subscrib Scheduler , Interceptor ... interceptors ) { if ( ! service . is Interface ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } return ( T ) Proxy . new Proxy Instance ( service . get Class Loader ( ) , new Class < ? > [ ] { service } , new Client ( protocol Factory , subscrib Scheduler , interceptors ) ) ; }
public static void apply ( Collection coll , Function func ) { for ( Iterator i = coll . iterator ( ) ; i . has Next ( ) ; ) { func . execute ( i . next ( ) ) ; } }
public static void apply ( Collection coll , Function func ) { for ( Iterator i = coll . iterator ( ) ; i . has Next ( ) ; ) { func . execute ( i . next ( ) ) ; } }
public static void apply ( Collection coll , Function func ) { for ( Iterator i = coll . iterator ( ) ; i . has Next ( ) ; ) { func . execute ( i . next ( ) ) ; } }
public static void apply ( Collection coll , Function func ) { for ( Iterator i = coll . iterator ( ) ; i . has Next ( ) ; ) { func . execute ( i . next ( ) ) ; } }
public Optional < Oba User Data Item > load Item ( final Oba User Data Item table Item ) { Dynamo DB Mapper mapper = create Dynamo DB Mapper ( ) ; Oba User Data Item item = mapper . load ( table Item ) ; return Optional . of Nullable ( item ) ; }
public Optional < Oba User Data Item > load Item ( final Oba User Data Item table Item ) { Dynamo DB Mapper mapper = create Dynamo DB Mapper ( ) ; Oba User Data Item item = mapper . load ( table Item ) ; return Optional . of Nullable ( item ) ; }
public Optional < Oba User Data Item > load Item ( final Oba User Data Item table Item ) { Dynamo DB Mapper mapper = create Dynamo DB Mapper ( ) ; Oba User Data Item item = mapper . load ( table Item ) ; return Optional . of Nullable ( item ) ; }
private void sleep ( long sleeptime ) { try { Thread . sleep ( sleeptime ) ; } catch ( Interrupted Exception e ) { } }
void remove ( String input Fragment Str , String format Fragment ) { if ( input Fragment Str != null && input Str . length ( ) >= input Fragment Str . length ( ) ) { input Str = input Str . substring ( input Fragment Str . length ( ) ) ; } if ( format Fragment != null && format Str . length ( ) >= format Fragment . length ( ) ) { format Str = format Str . substring ( format Fragment . length ( ) ) ; } }
private List < String > missing Food ( final Player player , final boolean hash ) { final List < String > result = new Linked List < String > ( ) ; String done Text = player . get Quest ( QUEST SLOT ) ; if ( done Text == null ) { done Text = STRING ; } final List < String > done = Arrays . as List ( done Text . split ( STRING ) ) ; for ( String ingredient : NEEDED FOOD ) { if ( ! done . contains ( ingredient ) ) { if ( hash ) { ingredient = STRING + ingredient ; } result . add ( ingredient ) ; } } return result ; }
private List < String > missing Food ( final Player player , final boolean hash ) { final List < String > result = new Linked List < String > ( ) ; String done Text = player . get Quest ( QUEST SLOT ) ; if ( done Text == null ) { done Text = STRING ; } final List < String > done = Arrays . as List ( done Text . split ( STRING ) ) ; for ( String ingredient : NEEDED FOOD ) { if ( ! done . contains ( ingredient ) ) { if ( hash ) { ingredient = STRING + ingredient ; } result . add ( ingredient ) ; } } return result ; }
private List < String > missing Food ( final Player player , final boolean hash ) { final List < String > result = new Linked List < String > ( ) ; String done Text = player . get Quest ( QUEST SLOT ) ; if ( done Text == null ) { done Text = STRING ; } final List < String > done = Arrays . as List ( done Text . split ( STRING ) ) ; for ( String ingredient : NEEDED FOOD ) { if ( ! done . contains ( ingredient ) ) { if ( hash ) { ingredient = STRING + ingredient ; } result . add ( ingredient ) ; } } return result ; }
private List < String > missing Food ( final Player player , final boolean hash ) { final List < String > result = new Linked List < String > ( ) ; String done Text = player . get Quest ( QUEST SLOT ) ; if ( done Text == null ) { done Text = STRING ; } final List < String > done = Arrays . as List ( done Text . split ( STRING ) ) ; for ( String ingredient : NEEDED FOOD ) { if ( ! done . contains ( ingredient ) ) { if ( hash ) { ingredient = STRING + ingredient ; } result . add ( ingredient ) ; } } return result ; }
private static boolean check For Subtree ( @ Not Null Log Hierarchy Node tree , @ Not Null String relative Branch , @ Not Null String local URL ) { final Linked List < Log Hierarchy Node > queue = new Linked List < Log Hierarchy Node > ( ) ; queue . add Last ( tree ) ; while ( ! queue . is Empty ( ) ) { final Log Hierarchy Node element = queue . remove First ( ) ; Progress Manager . check Canceled ( ) ; if ( check For Entry ( element . get Me ( ) , local URL , relative Branch ) ) return BOOL ; queue . add All ( element . get Children ( ) ) ; } return BOOL ; }
public void add Issuer ( X500 Principal issuer ) { if ( issuer == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( issuer Names == null ) { issuer Names = new Array List < String > ( ) ; } String name = issuer . get Name ( X500 Principal . CANONICAL ) ; if ( ! issuer Names . contains ( name ) ) { issuer Names . add ( name ) ; } if ( issuer Principals == null ) { issuer Principals = new Array List < X500 Principal > ( issuer Names . size ( ) ) ; } int size = issuer Names . size ( ) - NUM ; for ( int i = issuer Principals . size ( ) ; i < size ; i ++ ) { issuer Principals . add ( new X500 Principal ( issuer Names . get ( i ) ) ) ; } issuer Principals . add ( issuer ) ; }
public void add Issuer ( X500 Principal issuer ) { if ( issuer == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( issuer Names == null ) { issuer Names = new Array List < String > ( ) ; } String name = issuer . get Name ( X500 Principal . CANONICAL ) ; if ( ! issuer Names . contains ( name ) ) { issuer Names . add ( name ) ; } if ( issuer Principals == null ) { issuer Principals = new Array List < X500 Principal > ( issuer Names . size ( ) ) ; } int size = issuer Names . size ( ) - NUM ; for ( int i = issuer Principals . size ( ) ; i < size ; i ++ ) { issuer Principals . add ( new X500 Principal ( issuer Names . get ( i ) ) ) ; } issuer Principals . add ( issuer ) ; }
public void add Issuer ( X500 Principal issuer ) { if ( issuer == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( issuer Names == null ) { issuer Names = new Array List < String > ( ) ; } String name = issuer . get Name ( X500 Principal . CANONICAL ) ; if ( ! issuer Names . contains ( name ) ) { issuer Names . add ( name ) ; } if ( issuer Principals == null ) { issuer Principals = new Array List < X500 Principal > ( issuer Names . size ( ) ) ; } int size = issuer Names . size ( ) - NUM ; for ( int i = issuer Principals . size ( ) ; i < size ; i ++ ) { issuer Principals . add ( new X500 Principal ( issuer Names . get ( i ) ) ) ; } issuer Principals . add ( issuer ) ; }
@ Override public void end Window ( ) { if ( current Window Id > window Data Manager . get Largest Completed Window ( ) ) { synchronized ( lock ) { try { Message msg ; while ( ( msg = holding Buffer . poll ( ) ) != null ) { process Message ( msg ) ; emit Count ++ ; last Msg = msg ; } window Data Manager . save ( current Window Recovery State , current Window Id ) ; current Window Recovery State . clear ( ) ; if ( last Msg != null ) { acknowledge ( ) ; } pending Ack . clear ( ) ; } catch ( Throwable t ) { Throwables . propagate ( t ) ; } } emit Count = NUM ; } else if ( current Window Id < window Data Manager . get Largest Completed Window ( ) ) { pending Ack . clear ( ) ; } context . set Counters ( counters ) ; }
@ Override public void end Window ( ) { if ( current Window Id > window Data Manager . get Largest Completed Window ( ) ) { synchronized ( lock ) { try { Message msg ; while ( ( msg = holding Buffer . poll ( ) ) != null ) { process Message ( msg ) ; emit Count ++ ; last Msg = msg ; } window Data Manager . save ( current Window Recovery State , current Window Id ) ; current Window Recovery State . clear ( ) ; if ( last Msg != null ) { acknowledge ( ) ; } pending Ack . clear ( ) ; } catch ( Throwable t ) { Throwables . propagate ( t ) ; } } emit Count = NUM ; } else if ( current Window Id < window Data Manager . get Largest Completed Window ( ) ) { pending Ack . clear ( ) ; } context . set Counters ( counters ) ; }
@ Override public void end Window ( ) { if ( current Window Id > window Data Manager . get Largest Completed Window ( ) ) { synchronized ( lock ) { try { Message msg ; while ( ( msg = holding Buffer . poll ( ) ) != null ) { process Message ( msg ) ; emit Count ++ ; last Msg = msg ; } window Data Manager . save ( current Window Recovery State , current Window Id ) ; current Window Recovery State . clear ( ) ; if ( last Msg != null ) { acknowledge ( ) ; } pending Ack . clear ( ) ; } catch ( Throwable t ) { Throwables . propagate ( t ) ; } } emit Count = NUM ; } else if ( current Window Id < window Data Manager . get Largest Completed Window ( ) ) { pending Ack . clear ( ) ; } context . set Counters ( counters ) ; }
@ Override public void end Window ( ) { if ( current Window Id > window Data Manager . get Largest Completed Window ( ) ) { synchronized ( lock ) { try { Message msg ; while ( ( msg = holding Buffer . poll ( ) ) != null ) { process Message ( msg ) ; emit Count ++ ; last Msg = msg ; } window Data Manager . save ( current Window Recovery State , current Window Id ) ; current Window Recovery State . clear ( ) ; if ( last Msg != null ) { acknowledge ( ) ; } pending Ack . clear ( ) ; } catch ( Throwable t ) { Throwables . propagate ( t ) ; } } emit Count = NUM ; } else if ( current Window Id < window Data Manager . get Largest Completed Window ( ) ) { pending Ack . clear ( ) ; } context . set Counters ( counters ) ; }
@ Override public void end Window ( ) { if ( current Window Id > window Data Manager . get Largest Completed Window ( ) ) { synchronized ( lock ) { try { Message msg ; while ( ( msg = holding Buffer . poll ( ) ) != null ) { process Message ( msg ) ; emit Count ++ ; last Msg = msg ; } window Data Manager . save ( current Window Recovery State , current Window Id ) ; current Window Recovery State . clear ( ) ; if ( last Msg != null ) { acknowledge ( ) ; } pending Ack . clear ( ) ; } catch ( Throwable t ) { Throwables . propagate ( t ) ; } } emit Count = NUM ; } else if ( current Window Id < window Data Manager . get Largest Completed Window ( ) ) { pending Ack . clear ( ) ; } context . set Counters ( counters ) ; }
public static String edge Type To String ( @ Type int edge Type ) { switch ( edge Type ) { case FALL THROUGH EDGE : return STRING ; case IFCMP EDGE : return STRING ; case SWITCH EDGE : return STRING ; case SWITCH DEFAULT EDGE : return STRING ; case JSR EDGE : return STRING ; case RET EDGE : return STRING ; case GOTO EDGE : return STRING ; case RETURN EDGE : return STRING ; case UNHANDLED EXCEPTION EDGE : return STRING ; case HANDLED EXCEPTION EDGE : return STRING ; case START EDGE : return STRING ; case BACKEDGE TARGET EDGE : return STRING ; case BACKEDGE SOURCE EDGE : return STRING ; case EXIT EDGE : return STRING ; } throw new Illegal State Exception ( STRING + edge Type ) ; }
public static String edge Type To String ( @ Type int edge Type ) { switch ( edge Type ) { case FALL THROUGH EDGE : return STRING ; case IFCMP EDGE : return STRING ; case SWITCH EDGE : return STRING ; case SWITCH DEFAULT EDGE : return STRING ; case JSR EDGE : return STRING ; case RET EDGE : return STRING ; case GOTO EDGE : return STRING ; case RETURN EDGE : return STRING ; case UNHANDLED EXCEPTION EDGE : return STRING ; case HANDLED EXCEPTION EDGE : return STRING ; case START EDGE : return STRING ; case BACKEDGE TARGET EDGE : return STRING ; case BACKEDGE SOURCE EDGE : return STRING ; case EXIT EDGE : return STRING ; } throw new Illegal State Exception ( STRING + edge Type ) ; }
static public J Menu help Menu ( J Menu Bar menu Bar , String ref , boolean direct ) { J Menu help Menu = make Help Menu ( ref , direct ) ; menu Bar . add ( help Menu ) ; return help Menu ; }
private I Piece create Piece ( Context ctx , Scope parent , Foreign Key foreign Key ) throws Scope Exception , SQL Scope Exception { List < Expression AST > joins = new Linked List < Expression AST > ( ) ; for ( Key Pair pair : foreign Key . get Keys ( ) ) { joins . add ( Expression Maker . EQUAL ( new Column Reference ( pair . get Primary ( ) ) , new Column Reference ( pair . get Exported ( ) ) ) ) ; } if ( joins . size ( ) == NUM ) { return create Piece ( ctx , parent , joins . get ( NUM ) ) ; } else if ( joins . size ( ) > NUM ) { return create Piece ( ctx , parent , Expression Maker . AND ( joins ) ) ; } else { throw new Scope Exception ( STRING + foreign Key . get Name ( ) + STRING + foreign Key . get Foreign Table ( ) + STRING + foreign Key . get Primary Table ( ) ) ; } }
public synchronized void add Recent Item ( T item ) { item = from String ( to String ( item ) ) ; if ( m Recent Items . size ( ) > NUM ) { if ( item . equals ( m Recent Items . get ( NUM ) ) ) return ; } m Recent Items . remove ( item ) ; m Recent Items . add ( NUM , item ) ; while ( m Recent Items . size ( ) > m Max Count ) m Recent Items . remove ( m Recent Items . size ( ) - NUM ) ; if ( m Ignore Changes ) return ; write Props ( ) ; update Menu ( ) ; notify Recent Item Listeners Of Add ( item ) ; }
protected Object skip Project Package Fragment Root ( I Package Fragment Root root ) { if ( is Project Package Fragment Root ( root ) ) return root . get Parent ( ) ; return root ; }
protected Object skip Project Package Fragment Root ( I Package Fragment Root root ) { if ( is Project Package Fragment Root ( root ) ) return root . get Parent ( ) ; return root ; }
public void remove From Dragging Connections ( Block root Block ) { if ( m Pending Drag == null ) { return ; } m Temp Connections . clear ( ) ; root Block . get All Connections Recursive ( m Temp Connections ) ; for ( int i = NUM ; i < m Temp Connections . size ( ) ; i ++ ) { Connection conn = m Temp Connections . get ( i ) ; m Dragged Connections . remove ( conn ) ; conn . set Drag Mode ( BOOL ) ; } }
public void remove From Dragging Connections ( Block root Block ) { if ( m Pending Drag == null ) { return ; } m Temp Connections . clear ( ) ; root Block . get All Connections Recursive ( m Temp Connections ) ; for ( int i = NUM ; i < m Temp Connections . size ( ) ; i ++ ) { Connection conn = m Temp Connections . get ( i ) ; m Dragged Connections . remove ( conn ) ; conn . set Drag Mode ( BOOL ) ; } }
public void remove From Dragging Connections ( Block root Block ) { if ( m Pending Drag == null ) { return ; } m Temp Connections . clear ( ) ; root Block . get All Connections Recursive ( m Temp Connections ) ; for ( int i = NUM ; i < m Temp Connections . size ( ) ; i ++ ) { Connection conn = m Temp Connections . get ( i ) ; m Dragged Connections . remove ( conn ) ; conn . set Drag Mode ( BOOL ) ; } }
public void remove From Dragging Connections ( Block root Block ) { if ( m Pending Drag == null ) { return ; } m Temp Connections . clear ( ) ; root Block . get All Connections Recursive ( m Temp Connections ) ; for ( int i = NUM ; i < m Temp Connections . size ( ) ; i ++ ) { Connection conn = m Temp Connections . get ( i ) ; m Dragged Connections . remove ( conn ) ; conn . set Drag Mode ( BOOL ) ; } }
public static void main ( String [ ] args ) { int result ; Print Writer out = new Print Writer ( new Output Stream Writer ( System . out , UTF 8 ) ) ; Print Writer err = new Print Writer ( new Output Stream Writer ( System . err , UTF 8 ) ) ; try { Main formatter = new Main ( out , err , System . in ) ; result = formatter . format ( args ) ; } catch ( Usage Exception e ) { err . print ( e . get Message ( ) ) ; result = NUM ; } finally { err . flush ( ) ; out . flush ( ) ; } System . exit ( result ) ; }
public static String reverse Url ( String url String ) throws Malformed URL Exception { return reverse Url ( new URL ( url String ) ) ; }
public static String concatenate ( String [ ] lines , String delimiter ) { String Buffer buffer = new String Buffer ( ) ; for ( int i = NUM ; i < lines . length ; i ++ ) { if ( i > NUM ) buffer . append ( delimiter ) ; buffer . append ( lines [ i ] ) ; } return buffer . to String ( ) ; }
public static String concatenate ( String [ ] lines , String delimiter ) { String Buffer buffer = new String Buffer ( ) ; for ( int i = NUM ; i < lines . length ; i ++ ) { if ( i > NUM ) buffer . append ( delimiter ) ; buffer . append ( lines [ i ] ) ; } return buffer . to String ( ) ; }
public static String concatenate ( String [ ] lines , String delimiter ) { String Buffer buffer = new String Buffer ( ) ; for ( int i = NUM ; i < lines . length ; i ++ ) { if ( i > NUM ) buffer . append ( delimiter ) ; buffer . append ( lines [ i ] ) ; } return buffer . to String ( ) ; }
public static String concatenate ( String [ ] lines , String delimiter ) { String Buffer buffer = new String Buffer ( ) ; for ( int i = NUM ; i < lines . length ; i ++ ) { if ( i > NUM ) buffer . append ( delimiter ) ; buffer . append ( lines [ i ] ) ; } return buffer . to String ( ) ; }
public Json Object remove ( String name ) { if ( name == null ) { throw new Null Pointer Exception ( STRING ) ; } int index = index Of ( name ) ; if ( index != - NUM ) { table . remove ( index ) ; names . remove ( index ) ; values . remove ( index ) ; } return this ; }
public Json Object remove ( String name ) { if ( name == null ) { throw new Null Pointer Exception ( STRING ) ; } int index = index Of ( name ) ; if ( index != - NUM ) { table . remove ( index ) ; names . remove ( index ) ; values . remove ( index ) ; } return this ; }
public Json Object remove ( String name ) { if ( name == null ) { throw new Null Pointer Exception ( STRING ) ; } int index = index Of ( name ) ; if ( index != - NUM ) { table . remove ( index ) ; names . remove ( index ) ; values . remove ( index ) ; } return this ; }
public Json Object remove ( String name ) { if ( name == null ) { throw new Null Pointer Exception ( STRING ) ; } int index = index Of ( name ) ; if ( index != - NUM ) { table . remove ( index ) ; names . remove ( index ) ; values . remove ( index ) ; } return this ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
@ Override public boolean use Buffer Per Window ( ) { return ! Win 32 Graphics Environment . is DWM Composition Enabled ( ) ; }
public boolean read Bit ( ) throws IO Exception { if ( bit Field == - NUM ) { bit Field = in . read ( ) ; if ( bit Field == - NUM ) { throw new EOF Exception ( ) ; } mask = NUM ; } boolean bit = ( bit Field & mask ) != NUM ; if ( ( mask <<= NUM ) == NUM ) { bit Field = - NUM ; } return bit ; }
public boolean read Bit ( ) throws IO Exception { if ( bit Field == - NUM ) { bit Field = in . read ( ) ; if ( bit Field == - NUM ) { throw new EOF Exception ( ) ; } mask = NUM ; } boolean bit = ( bit Field & mask ) != NUM ; if ( ( mask <<= NUM ) == NUM ) { bit Field = - NUM ; } return bit ; }
public static Word [ ] prepare String Token ( String str ) { if ( str == null ) { return new Word [ NUM ] ; } final Array List < Word > str With Delim = new Array List < Word > ( ) ; split Word By Space ( str , str With Delim ) ; final Word [ ] to Ret = new Word [ Math . min ( str With Delim . size ( ) , MAX NUM WORDS ) ] ; for ( int i = NUM ; i < Math . min ( str With Delim . size ( ) , MAX NUM WORDS ) ; i ++ ) { to Ret [ i ] = str With Delim . get ( i ) ; } return to Ret ; }
public void validation State Changed ( K key , Validation State new State ) { Set < Validation State > states = validation Error States . get ( key ) ; if ( new State . is Valid ( ) ) { if ( null == states ) { states = Collections . empty Set ( ) ; } boolean removed = states . remove ( new State ) ; if ( removed ) { if ( states . is Empty ( ) ) { hide Message ( key ) ; } else { show Message ( key , states ) ; } notify Upstream ( key , states ) ; } } else { if ( null == states ) { states = new Hash Set < > ( ) ; validation Error States . put ( key , states ) ; } states . remove ( new State ) ; states . add ( new State ) ; show Message ( key , states ) ; notify Upstream ( key , states ) ; } }
public static String replace Characters ( final Conversion Method conversion Method , final String input , final int from Character , final int to Character , final String wrap ) { String converted Text = input ; for ( int i = from Character ; i <= to Character ; i ++ ) { final String character To Replace = new String ( Character . to Chars ( i ) ) ; if ( wrap != null ) { converted Text = converted Text . replace ( character To Replace , wrap + convert Text ( conversion Method , character To Replace ) + wrap ) ; } else { converted Text = converted Text . replace ( character To Replace , convert Text ( conversion Method , character To Replace ) ) ; } } return converted Text ; }
public static String replace Characters ( final Conversion Method conversion Method , final String input , final int from Character , final int to Character , final String wrap ) { String converted Text = input ; for ( int i = from Character ; i <= to Character ; i ++ ) { final String character To Replace = new String ( Character . to Chars ( i ) ) ; if ( wrap != null ) { converted Text = converted Text . replace ( character To Replace , wrap + convert Text ( conversion Method , character To Replace ) + wrap ) ; } else { converted Text = converted Text . replace ( character To Replace , convert Text ( conversion Method , character To Replace ) ) ; } } return converted Text ; }
public static String replace Characters ( final Conversion Method conversion Method , final String input , final int from Character , final int to Character , final String wrap ) { String converted Text = input ; for ( int i = from Character ; i <= to Character ; i ++ ) { final String character To Replace = new String ( Character . to Chars ( i ) ) ; if ( wrap != null ) { converted Text = converted Text . replace ( character To Replace , wrap + convert Text ( conversion Method , character To Replace ) + wrap ) ; } else { converted Text = converted Text . replace ( character To Replace , convert Text ( conversion Method , character To Replace ) ) ; } } return converted Text ; }
public static Collection < Debugger Exception > merge Exceptions Settings ( final Debug Target Settings target , final Collection < Debugger Exception > exceptions , final int debugger Id ) throws Couldnt Load Data Exception { final Map < Long , Debugger Exception > exceptions Map = get Exceptions Map ( exceptions ) ; for ( final Debugger Exception dbg Exception : exceptions ) { final String setting = target . read Setting ( Debugger Exception . get Setting Key ( dbg Exception , debugger Id ) ) ; if ( setting != null ) { final Debugger Exception Handling Action handling Action = Debugger Exception Handling Action . convert To Handling Action ( Integer . value Of ( setting ) ) ; final Debugger Exception new Exception = new Debugger Exception ( dbg Exception . get Exception Name ( ) , dbg Exception . get Exception Code ( ) , handling Action ) ; exceptions Map . put ( dbg Exception . get Exception Code ( ) , new Exception ) ; } } return exceptions Map . values ( ) ; }
public void insert ( Cell cell ) ;
@ Deprecated public static boolean encode ( final String s , final String encoding , Bit Set safe Octets , boolean plus For Space , Appendable out ) throws Unsupported Encoding Exception , IO Exception { byte [ ] data = s . get Bytes ( encoding ) ; boolean contains Space = BOOL ; int output Length = NUM ; for ( int i = NUM ; i < data . length ; i ++ ) { int c = data [ i ] ; if ( c < NUM ) c += NUM ; if ( safe Octets . get ( c ) ) { out . append ( ( char ) c ) ; output Length += NUM ; } else if ( plus For Space && ( c == STRING ) ) { contains Space = BOOL ; out . append ( STRING ) ; output Length += NUM ; } else { out . append ( STRING ) ; out . append ( HEX DIGITS [ c > > NUM ] ) ; out . append ( HEX DIGITS [ c & NUM ] ) ; output Length += NUM ; } } return contains Space || ( output Length != s . length ( ) ) ; }
void recover Messages ( ) throws Rollback Failed Exception { if ( m is Queue ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING ) ; } unacked Messages . clear ( ) ; if ( ! is Auto Ack ( ) ) { rollback Local Transaction ( ) ; } } else { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING ) ; } unacked Messages . add All ( recover Messages ) ; Linked List < Message Queue Element > temp = unacked Messages ; recover Messages . clear ( ) ; unacked Messages = recover Messages ; recover Messages = temp ; } }
void recover Messages ( ) throws Rollback Failed Exception { if ( m is Queue ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING ) ; } unacked Messages . clear ( ) ; if ( ! is Auto Ack ( ) ) { rollback Local Transaction ( ) ; } } else { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING ) ; } unacked Messages . add All ( recover Messages ) ; Linked List < Message Queue Element > temp = unacked Messages ; recover Messages . clear ( ) ; unacked Messages = recover Messages ; recover Messages = temp ; } }
void recover Messages ( ) throws Rollback Failed Exception { if ( m is Queue ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING ) ; } unacked Messages . clear ( ) ; if ( ! is Auto Ack ( ) ) { rollback Local Transaction ( ) ; } } else { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING ) ; } unacked Messages . add All ( recover Messages ) ; Linked List < Message Queue Element > temp = unacked Messages ; recover Messages . clear ( ) ; unacked Messages = recover Messages ; recover Messages = temp ; } }
public char char At ( int index ) { return to String . char At ( index ) ; }
public char char At ( int index ) { return to String . char At ( index ) ; }
public void test Empty Sub List ( ) { final Range range = create Range ( NUM , NUM ) ; List sub List = range . sub List ( NUM , NUM ) ; assert Equals ( STRING , NUM , sub List . size ( ) ) ; sub List = range . sub List ( NUM , NUM ) ; assert Equals ( STRING , NUM , sub List . size ( ) ) ; }
public synchronized void add ( String property ) { String [ ] values = tokenize ( property ) ; if ( m Root . value == null ) { m Root . value = values [ NUM ] ; } build Branch ( m Root , values , NUM ) ; }
Operand pop ( Register s ) { Stack < Operand > stack = get ( s ) ; if ( stack == null ) { throw new Optimizing Compiler Exception ( STRING ) ; } else { return stack . pop ( ) ; } }
public static void write ( File file , NS Object root ) throws IO Exception { Output Stream out = new File Output Stream ( file ) ; write ( out , root ) ; out . close ( ) ; }
public static byte [ ] hmac MD 5 ( byte [ ] data , byte [ ] key ) throws Exception { byte [ ] ipad = new byte [ NUM ] ; byte [ ] opad = new byte [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { if ( i < key . length ) { ipad [ i ] = ( byte ) ( key [ i ] ^ NUM ) ; opad [ i ] = ( byte ) ( key [ i ] ^ NUM ) ; } else { ipad [ i ] = NUM ; opad [ i ] = NUM ; } } byte [ ] content = new byte [ data . length + NUM ] ; System . arraycopy ( ipad , NUM , content , NUM , NUM ) ; System . arraycopy ( data , NUM , content , NUM , data . length ) ; Message Digest md 5 = Message Digest . get Instance ( STRING ) ; data = md 5 . digest ( content ) ; content = new byte [ data . length + NUM ] ; System . arraycopy ( opad , NUM , content , NUM , NUM ) ; System . arraycopy ( data , NUM , content , NUM , data . length ) ; return md 5 . digest ( content ) ; }
public static byte [ ] hmac MD 5 ( byte [ ] data , byte [ ] key ) throws Exception { byte [ ] ipad = new byte [ NUM ] ; byte [ ] opad = new byte [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { if ( i < key . length ) { ipad [ i ] = ( byte ) ( key [ i ] ^ NUM ) ; opad [ i ] = ( byte ) ( key [ i ] ^ NUM ) ; } else { ipad [ i ] = NUM ; opad [ i ] = NUM ; } } byte [ ] content = new byte [ data . length + NUM ] ; System . arraycopy ( ipad , NUM , content , NUM , NUM ) ; System . arraycopy ( data , NUM , content , NUM , data . length ) ; Message Digest md 5 = Message Digest . get Instance ( STRING ) ; data = md 5 . digest ( content ) ; content = new byte [ data . length + NUM ] ; System . arraycopy ( opad , NUM , content , NUM , NUM ) ; System . arraycopy ( data , NUM , content , NUM , data . length ) ; return md 5 . digest ( content ) ; }
public static byte [ ] hmac MD 5 ( byte [ ] data , byte [ ] key ) throws Exception { byte [ ] ipad = new byte [ NUM ] ; byte [ ] opad = new byte [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { if ( i < key . length ) { ipad [ i ] = ( byte ) ( key [ i ] ^ NUM ) ; opad [ i ] = ( byte ) ( key [ i ] ^ NUM ) ; } else { ipad [ i ] = NUM ; opad [ i ] = NUM ; } } byte [ ] content = new byte [ data . length + NUM ] ; System . arraycopy ( ipad , NUM , content , NUM , NUM ) ; System . arraycopy ( data , NUM , content , NUM , data . length ) ; Message Digest md 5 = Message Digest . get Instance ( STRING ) ; data = md 5 . digest ( content ) ; content = new byte [ data . length + NUM ] ; System . arraycopy ( opad , NUM , content , NUM , NUM ) ; System . arraycopy ( data , NUM , content , NUM , data . length ) ; return md 5 . digest ( content ) ; }
protected abstract void add File ( String relative Filename ) throws Command Exception ;
protected abstract void add File ( String relative Filename ) throws Command Exception ;
private static void assert Not Empty ( String message , String string ) { assert Not Null ( message , string ) ; assert False ( message , string . equals ( STRING ) ) ; }
public boolean is Down ( ) { if ( m Local Path != null && m Local Path . length ( ) > NUM ) { File file = new File ( m Local Path ) ; return ( file . exists ( ) ) ; } return BOOL ; }
public boolean is Down ( ) { if ( m Local Path != null && m Local Path . length ( ) > NUM ) { File file = new File ( m Local Path ) ; return ( file . exists ( ) ) ; } return BOOL ; }
public boolean is Down ( ) { if ( m Local Path != null && m Local Path . length ( ) > NUM ) { File file = new File ( m Local Path ) ; return ( file . exists ( ) ) ; } return BOOL ; }
public boolean is Down ( ) { if ( m Local Path != null && m Local Path . length ( ) > NUM ) { File file = new File ( m Local Path ) ; return ( file . exists ( ) ) ; } return BOOL ; }
private void add Event From Property ( String evt , Hadoop Job Info info , String prop Name ) { String val = info . property ( prop Name ) ; if ( ! F . is Empty ( val ) ) { try { evts . add ( new T2 < > ( evt + STRING + node Id , Long . parse Long ( val ) ) ) ; } catch ( Number Format Exception e ) { throw new Illegal State Exception ( STRING + val + STRING + prop Name + STRING , e ) ; } } }
@ Android Only ( STRING + STRING ) public void test Set Max CRL Number Ljava math Big Integer ( ) { X509 CRL Selector selector = new X509 CRL Selector ( ) ; Big Integer max CRL = new Big Integer ( STRING ) ; Test CRL crl = new Test CRL ( max CRL ) ; selector . set Max CRL Number ( null ) ; assert True ( STRING , selector . match ( crl ) ) ; selector . set Max CRL Number ( max CRL ) ; assert True ( STRING , selector . match ( crl ) ) ; selector . set Max CRL Number ( new Big Integer ( STRING ) ) ; assert False ( STRING , selector . match ( crl ) ) ; }
@ Android Only ( STRING + STRING ) public void test Set Max CRL Number Ljava math Big Integer ( ) { X509 CRL Selector selector = new X509 CRL Selector ( ) ; Big Integer max CRL = new Big Integer ( STRING ) ; Test CRL crl = new Test CRL ( max CRL ) ; selector . set Max CRL Number ( null ) ; assert True ( STRING , selector . match ( crl ) ) ; selector . set Max CRL Number ( max CRL ) ; assert True ( STRING , selector . match ( crl ) ) ; selector . set Max CRL Number ( new Big Integer ( STRING ) ) ; assert False ( STRING , selector . match ( crl ) ) ; }
@ Android Only ( STRING + STRING ) public void test Set Max CRL Number Ljava math Big Integer ( ) { X509 CRL Selector selector = new X509 CRL Selector ( ) ; Big Integer max CRL = new Big Integer ( STRING ) ; Test CRL crl = new Test CRL ( max CRL ) ; selector . set Max CRL Number ( null ) ; assert True ( STRING , selector . match ( crl ) ) ; selector . set Max CRL Number ( max CRL ) ; assert True ( STRING , selector . match ( crl ) ) ; selector . set Max CRL Number ( new Big Integer ( STRING ) ) ; assert False ( STRING , selector . match ( crl ) ) ; }
private static String search Directories ( final File [ ] paths , final String [ ] exe Names ) { for ( final File path : paths ) { if ( path . exists ( ) ) { for ( final File sub Directory : path . list Files ( ) ) { if ( String Utils . starts With ( sub Directory . get Name ( ) , TF DIRECTORY PREFIX ) && sub Directory . is Directory ( ) ) { final String verified Path = check Tf Path ( sub Directory . get Path ( ) , exe Names ) ; if ( verified Path != null ) { return verified Path ; } } } } } return null ; }
public void encode ( final Active MQ Buffer buffer ) { buffer . write String ( name ) ; buffer . write String ( factory Class Name ) ; buffer . write Int ( params == null ? NUM : params . size ( ) ) ; if ( params != null ) { encode Map ( buffer , params ) ; } if ( extra Props != null ) { encode Map ( buffer , extra Props ) ; } }
@ Override protected void draw Status Bar ( final Graphics 2 D g2 d , final int x , final int y , final int width ) { draw Title ( g2 d , x , y + NUM , width ) ; Composite comp = g2 d . get Composite ( ) ; if ( ignored && ! entity . is Ghost Mode ( ) ) { g2 d . set Composite ( Alpha Composite . Src Atop ) ; draw H Pbar ( g2 d , x , y + NUM , width ) ; g2 d . set Composite ( comp ) ; } else { draw H Pbar ( g2 d , x , y + NUM , width ) ; } }
private Test Entry convert To Test Entry ( Entry entry ) { String value = entry . get Note Or Title ( ) ; if ( value == null && entry . is Root ( ) ) { value = STRING ; } final Test Entry test Entry = new Test Entry ( value , entry . get Id ( ) ) ; final Array List < Entry > children Entries = get Children In Order ( entry ) ; final Array List < Test Entry > children Test Entries = new Array List < Test Entry > ( ) ; for ( final Entry child Entry : children Entries ) { children Test Entries . add ( convert To Test Entry ( child Entry ) ) ; } if ( ! children Test Entries . is Empty ( ) ) { test Entry . set Children ( children Test Entries . to Array ( new Test Entry [ children Test Entries . size ( ) ] ) ) ; } return test Entry ; }
private Test Entry convert To Test Entry ( Entry entry ) { String value = entry . get Note Or Title ( ) ; if ( value == null && entry . is Root ( ) ) { value = STRING ; } final Test Entry test Entry = new Test Entry ( value , entry . get Id ( ) ) ; final Array List < Entry > children Entries = get Children In Order ( entry ) ; final Array List < Test Entry > children Test Entries = new Array List < Test Entry > ( ) ; for ( final Entry child Entry : children Entries ) { children Test Entries . add ( convert To Test Entry ( child Entry ) ) ; } if ( ! children Test Entries . is Empty ( ) ) { test Entry . set Children ( children Test Entries . to Array ( new Test Entry [ children Test Entries . size ( ) ] ) ) ; } return test Entry ; }
private void update Font ( String family , int style , int size ) { console . set Font ( new Font ( family , style , size ) ) ; }
public int read Word ( ) throws IO Exception { length += NUM ; int k1 = in . read ( ) ; if ( k1 < NUM ) return NUM ; return ( k1 + ( in . read ( ) << NUM ) ) & NUM ; }
public JSON Buffer append Key Value ( Object key , Object val ) { if ( stack . empty ( ) || stack . peek ( ) != Operand . HASH ) { throw new JSON Exception ( STRING ) ; } add Quoted String ( key ) ; buffer . append ( STRING ) ; if ( val instanceof Double ) { buffer . append ( val . to String ( ) ) ; } else if ( val instanceof Integer ) { buffer . append ( val . to String ( ) ) ; } else { add Quoted String ( val ) ; } buffer . append ( STRING ) ; return this ; }
@ Override public float generator Sort Value ( String url , Web Page row , float init Sort ) throws Scoring Filter Exception { for ( Scoring Filter filter : filters ) { init Sort = filter . generator Sort Value ( url , row , init Sort ) ; } return init Sort ; }
public void force Merge ( int max Segment Count ) throws IO Exception { Lucene Test Case . maybe Change Live Index Writer Config ( r , w . get Config ( ) ) ; w . force Merge ( max Segment Count ) ; }
public Pending Change prepare Add Row ( Object [ ] row , Row Id Impl row Id , Pending Change next Change ) throws IO Exception { return prepare Add Row ( row , row Id , new Add Row Pending Change ( next Change ) ) ; }
private void create Element ( Document doc , Element parent Element , String element Name , Color value ) { Element element = doc . create Element ( element Name ) ; element . append Child ( doc . create Text Node ( Colour Utils . from Colour ( value ) ) ) ; parent Element . append Child ( element ) ; }
public static < T > String join ( T [ ] array , String separator ) { return join ( Arrays . as List ( array ) , separator ) ; }
protected static void isort ( int level [ ] , float BC [ ] ) { float temp ; int temp 2 ; for ( int i = NUM ; i < BC . length - NUM ; i ++ ) { int j = i ; temp = BC [ j + NUM ] ; temp 2 = level [ j + NUM ] ; if ( temp == NUM ) { continue ; } int prej = j + NUM ; while ( j > - NUM && ( temp < BC [ j ] || BC [ j ] == NUM ) ) { if ( BC [ j ] == NUM ) { j -- ; continue ; } else { BC [ prej ] = BC [ j ] ; level [ prej ] = level [ j ] ; prej = j ; j -- ; } } BC [ prej ] = temp ; level [ prej ] = temp 2 ; } }
protected static void isort ( int level [ ] , float BC [ ] ) { float temp ; int temp 2 ; for ( int i = NUM ; i < BC . length - NUM ; i ++ ) { int j = i ; temp = BC [ j + NUM ] ; temp 2 = level [ j + NUM ] ; if ( temp == NUM ) { continue ; } int prej = j + NUM ; while ( j > - NUM && ( temp < BC [ j ] || BC [ j ] == NUM ) ) { if ( BC [ j ] == NUM ) { j -- ; continue ; } else { BC [ prej ] = BC [ j ] ; level [ prej ] = level [ j ] ; prej = j ; j -- ; } } BC [ prej ] = temp ; level [ prej ] = temp 2 ; } }
protected static void isort ( int level [ ] , float BC [ ] ) { float temp ; int temp 2 ; for ( int i = NUM ; i < BC . length - NUM ; i ++ ) { int j = i ; temp = BC [ j + NUM ] ; temp 2 = level [ j + NUM ] ; if ( temp == NUM ) { continue ; } int prej = j + NUM ; while ( j > - NUM && ( temp < BC [ j ] || BC [ j ] == NUM ) ) { if ( BC [ j ] == NUM ) { j -- ; continue ; } else { BC [ prej ] = BC [ j ] ; level [ prej ] = level [ j ] ; prej = j ; j -- ; } } BC [ prej ] = temp ; level [ prej ] = temp 2 ; } }
protected static void isort ( int level [ ] , float BC [ ] ) { float temp ; int temp 2 ; for ( int i = NUM ; i < BC . length - NUM ; i ++ ) { int j = i ; temp = BC [ j + NUM ] ; temp 2 = level [ j + NUM ] ; if ( temp == NUM ) { continue ; } int prej = j + NUM ; while ( j > - NUM && ( temp < BC [ j ] || BC [ j ] == NUM ) ) { if ( BC [ j ] == NUM ) { j -- ; continue ; } else { BC [ prej ] = BC [ j ] ; level [ prej ] = level [ j ] ; prej = j ; j -- ; } } BC [ prej ] = temp ; level [ prej ] = temp 2 ; } }
protected static void isort ( int level [ ] , float BC [ ] ) { float temp ; int temp 2 ; for ( int i = NUM ; i < BC . length - NUM ; i ++ ) { int j = i ; temp = BC [ j + NUM ] ; temp 2 = level [ j + NUM ] ; if ( temp == NUM ) { continue ; } int prej = j + NUM ; while ( j > - NUM && ( temp < BC [ j ] || BC [ j ] == NUM ) ) { if ( BC [ j ] == NUM ) { j -- ; continue ; } else { BC [ prej ] = BC [ j ] ; level [ prej ] = level [ j ] ; prej = j ; j -- ; } } BC [ prej ] = temp ; level [ prej ] = temp 2 ; } }
protected static void isort ( int level [ ] , float BC [ ] ) { float temp ; int temp 2 ; for ( int i = NUM ; i < BC . length - NUM ; i ++ ) { int j = i ; temp = BC [ j + NUM ] ; temp 2 = level [ j + NUM ] ; if ( temp == NUM ) { continue ; } int prej = j + NUM ; while ( j > - NUM && ( temp < BC [ j ] || BC [ j ] == NUM ) ) { if ( BC [ j ] == NUM ) { j -- ; continue ; } else { BC [ prej ] = BC [ j ] ; level [ prej ] = level [ j ] ; prej = j ; j -- ; } } BC [ prej ] = temp ; level [ prej ] = temp 2 ; } }
public String to Property String ( Resource data ) { Properties properties = to Properties ( data ) ; return Property Utils . join On Pipe ( Property Utils . to Map ( properties ) ) ; }
public void check And Replace Old Property Names ( Link Properties props ) { check And Replace Old Property Name ( props , LPC OLD LINECOLOR , LPC LINECOLOR ) ; check And Replace Old Property Name ( props , LPC OLD LINESTYLE , LPC LINESTYLE ) ; check And Replace Old Property Name ( props , LPC OLD HIGHLIGHTCOLOR , LPC HIGHLIGHTCOLOR ) ; check And Replace Old Property Name ( props , LPC OLD FILLCOLOR , LPC FILLCOLOR ) ; check And Replace Old Property Name ( props , LPC OLD FILLPATTERN , LPC FILLPATTERN ) ; check And Replace Old Property Name ( props , LPC OLD LINEWIDTH , LPC LINEWIDTH ) ; check And Replace Old Property Name ( props , LPC OLD LINKTEXTSTRING , LPC LINKTEXTSTRING ) ; check And Replace Old Property Name ( props , LPC OLD LINKTEXTFONT , LPC LINKTEXTFONT ) ; }
public void check And Replace Old Property Names ( Link Properties props ) { check And Replace Old Property Name ( props , LPC OLD LINECOLOR , LPC LINECOLOR ) ; check And Replace Old Property Name ( props , LPC OLD LINESTYLE , LPC LINESTYLE ) ; check And Replace Old Property Name ( props , LPC OLD HIGHLIGHTCOLOR , LPC HIGHLIGHTCOLOR ) ; check And Replace Old Property Name ( props , LPC OLD FILLCOLOR , LPC FILLCOLOR ) ; check And Replace Old Property Name ( props , LPC OLD FILLPATTERN , LPC FILLPATTERN ) ; check And Replace Old Property Name ( props , LPC OLD LINEWIDTH , LPC LINEWIDTH ) ; check And Replace Old Property Name ( props , LPC OLD LINKTEXTSTRING , LPC LINKTEXTSTRING ) ; check And Replace Old Property Name ( props , LPC OLD LINKTEXTFONT , LPC LINKTEXTFONT ) ; }
public static String compact Hex ( byte [ ] bytes ) { String Builder sb = new String Builder ( ) ; for ( byte b : bytes ) { sb . append ( hex ( b ) ) ; } return sb . to String ( ) ; }
public static String compact Hex ( byte [ ] bytes ) { String Builder sb = new String Builder ( ) ; for ( byte b : bytes ) { sb . append ( hex ( b ) ) ; } return sb . to String ( ) ; }
private synchronized void enumerate String Properties ( Hashtable < String , String > h ) { if ( defaults != null ) { defaults . enumerate String Properties ( h ) ; } for ( Enumeration < ? > e = keys ( ) ; e . has More Elements ( ) ; ) { Object k = e . next Element ( ) ; Object v = get ( k ) ; if ( k instanceof String && v instanceof String ) { h . put ( ( String ) k , ( String ) v ) ; } } }
private synchronized void enumerate String Properties ( Hashtable < String , String > h ) { if ( defaults != null ) { defaults . enumerate String Properties ( h ) ; } for ( Enumeration < ? > e = keys ( ) ; e . has More Elements ( ) ; ) { Object k = e . next Element ( ) ; Object v = get ( k ) ; if ( k instanceof String && v instanceof String ) { h . put ( ( String ) k , ( String ) v ) ; } } }
public double calc Point To Line Distance ( Entry start Entry , Entry end Entry , Entry entry Point ) { float x Diff End Start = ( float ) end Entry . get X Index ( ) - ( float ) start Entry . get X Index ( ) ; float x Diff Entry Start = ( float ) entry Point . get X Index ( ) - ( float ) start Entry . get X Index ( ) ; double normal Length = Math . sqrt ( ( x Diff End Start ) * ( x Diff End Start ) + ( end Entry . get Val ( ) - start Entry . get Val ( ) ) * ( end Entry . get Val ( ) - start Entry . get Val ( ) ) ) ; return Math . abs ( ( x Diff Entry Start ) * ( end Entry . get Val ( ) - start Entry . get Val ( ) ) - ( entry Point . get Val ( ) - start Entry . get Val ( ) ) * ( x Diff End Start ) ) / normal Length ; }
private void perform Frame Tasks ( ) { synchronized ( m Frame Task Queue ) { A Frame Task task = m Frame Task Queue . poll ( ) ; while ( task != null ) { task . run ( ) ; task = m Frame Task Queue . poll ( ) ; } } }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Float ) obj ) . value == value ; }
public long remove Index ( int index ) { if ( index >= size ) throw new Index Out Of Bounds Exception ( String . value Of ( index ) ) ; long [ ] items = this . items ; long value = items [ index ] ; size -- ; if ( ordered ) System . arraycopy ( items , index + NUM , items , index , size - index ) ; else items [ index ] = items [ size ] ; return value ; }
public long remove Index ( int index ) { if ( index >= size ) throw new Index Out Of Bounds Exception ( String . value Of ( index ) ) ; long [ ] items = this . items ; long value = items [ index ] ; size -- ; if ( ordered ) System . arraycopy ( items , index + NUM , items , index , size - index ) ; else items [ index ] = items [ size ] ; return value ; }
private void update Goods ( ) { m Goods Text View . set Text ( String . format ( STRING , m Goods ) ) ; }
public void remove Decorator ( final Operator Draw Decorator decorator ) { if ( decorator == null ) { throw new Illegal Argument Exception ( STRING ) ; } operator Decorators . remove ( decorator ) ; }
public static File to File ( Java File Object java File Object ) { return new File ( java File Object . get Name ( ) ) ; }
public static String join ( final Iterator < ? > iterator , final String separator ) { if ( iterator == null ) { return null ; } if ( ! iterator . has Next ( ) ) { return STRING ; } final Object first = iterator . next ( ) ; if ( ! iterator . has Next ( ) ) { return first == null ? null : first . to String ( ) ; } final String Builder buf = new String Builder ( NUM ) ; if ( first != null ) { buf . append ( first ) ; } while ( iterator . has Next ( ) ) { if ( separator != null ) { buf . append ( separator ) ; } final Object obj = iterator . next ( ) ; if ( obj != null ) { buf . append ( obj ) ; } } return buf . to String ( ) ; }
public static boolean is Empty ( String str ) { return Text Utils . is Empty ( str ) || str . equals Ignore Case ( STRING ) ; }
@ Override public void draw ( Canvas canvas ) { Point F detect Left Position = m Left Position ; Point F detect Right Position = m Right Position ; if ( ( detect Left Position == null ) || ( detect Right Position == null ) ) { return ; } Point F left Position = new Point F ( translate X ( detect Left Position . x ) , translate Y ( detect Left Position . y ) ) ; Point F right Position = new Point F ( translate X ( detect Right Position . x ) , translate Y ( detect Right Position . y ) ) ; float distance = ( float ) Math . sqrt ( Math . pow ( right Position . x - left Position . x , NUM ) + Math . pow ( right Position . y - left Position . y , NUM ) ) ; float eye Radius = EYE RADIUS PROPORTION * distance ; float iris Radius = IRIS RADIUS PROPORTION * distance ; Point F left Iris Position = m Left Physics . next Iris Position ( left Position , eye Radius , iris Radius ) ; draw Eye ( canvas , left Position , eye Radius , left Iris Position , iris Radius , m Left Open ) ; Point F right Iris Position = m Right Physics . next Iris Position ( right Position , eye Radius , iris Radius ) ; draw Eye ( canvas , right Position , eye Radius , right Iris Position , iris Radius , m Right Open ) ; }
@ Override public void draw ( Canvas canvas ) { Point F detect Left Position = m Left Position ; Point F detect Right Position = m Right Position ; if ( ( detect Left Position == null ) || ( detect Right Position == null ) ) { return ; } Point F left Position = new Point F ( translate X ( detect Left Position . x ) , translate Y ( detect Left Position . y ) ) ; Point F right Position = new Point F ( translate X ( detect Right Position . x ) , translate Y ( detect Right Position . y ) ) ; float distance = ( float ) Math . sqrt ( Math . pow ( right Position . x - left Position . x , NUM ) + Math . pow ( right Position . y - left Position . y , NUM ) ) ; float eye Radius = EYE RADIUS PROPORTION * distance ; float iris Radius = IRIS RADIUS PROPORTION * distance ; Point F left Iris Position = m Left Physics . next Iris Position ( left Position , eye Radius , iris Radius ) ; draw Eye ( canvas , left Position , eye Radius , left Iris Position , iris Radius , m Left Open ) ; Point F right Iris Position = m Right Physics . next Iris Position ( right Position , eye Radius , iris Radius ) ; draw Eye ( canvas , right Position , eye Radius , right Iris Position , iris Radius , m Right Open ) ; }
@ Override public void draw ( Canvas canvas ) { Point F detect Left Position = m Left Position ; Point F detect Right Position = m Right Position ; if ( ( detect Left Position == null ) || ( detect Right Position == null ) ) { return ; } Point F left Position = new Point F ( translate X ( detect Left Position . x ) , translate Y ( detect Left Position . y ) ) ; Point F right Position = new Point F ( translate X ( detect Right Position . x ) , translate Y ( detect Right Position . y ) ) ; float distance = ( float ) Math . sqrt ( Math . pow ( right Position . x - left Position . x , NUM ) + Math . pow ( right Position . y - left Position . y , NUM ) ) ; float eye Radius = EYE RADIUS PROPORTION * distance ; float iris Radius = IRIS RADIUS PROPORTION * distance ; Point F left Iris Position = m Left Physics . next Iris Position ( left Position , eye Radius , iris Radius ) ; draw Eye ( canvas , left Position , eye Radius , left Iris Position , iris Radius , m Left Open ) ; Point F right Iris Position = m Right Physics . next Iris Position ( right Position , eye Radius , iris Radius ) ; draw Eye ( canvas , right Position , eye Radius , right Iris Position , iris Radius , m Right Open ) ; }
@ Override public void draw ( Canvas canvas ) { Point F detect Left Position = m Left Position ; Point F detect Right Position = m Right Position ; if ( ( detect Left Position == null ) || ( detect Right Position == null ) ) { return ; } Point F left Position = new Point F ( translate X ( detect Left Position . x ) , translate Y ( detect Left Position . y ) ) ; Point F right Position = new Point F ( translate X ( detect Right Position . x ) , translate Y ( detect Right Position . y ) ) ; float distance = ( float ) Math . sqrt ( Math . pow ( right Position . x - left Position . x , NUM ) + Math . pow ( right Position . y - left Position . y , NUM ) ) ; float eye Radius = EYE RADIUS PROPORTION * distance ; float iris Radius = IRIS RADIUS PROPORTION * distance ; Point F left Iris Position = m Left Physics . next Iris Position ( left Position , eye Radius , iris Radius ) ; draw Eye ( canvas , left Position , eye Radius , left Iris Position , iris Radius , m Left Open ) ; Point F right Iris Position = m Right Physics . next Iris Position ( right Position , eye Radius , iris Radius ) ; draw Eye ( canvas , right Position , eye Radius , right Iris Position , iris Radius , m Right Open ) ; }
@ Override public void draw ( Canvas canvas ) { Point F detect Left Position = m Left Position ; Point F detect Right Position = m Right Position ; if ( ( detect Left Position == null ) || ( detect Right Position == null ) ) { return ; } Point F left Position = new Point F ( translate X ( detect Left Position . x ) , translate Y ( detect Left Position . y ) ) ; Point F right Position = new Point F ( translate X ( detect Right Position . x ) , translate Y ( detect Right Position . y ) ) ; float distance = ( float ) Math . sqrt ( Math . pow ( right Position . x - left Position . x , NUM ) + Math . pow ( right Position . y - left Position . y , NUM ) ) ; float eye Radius = EYE RADIUS PROPORTION * distance ; float iris Radius = IRIS RADIUS PROPORTION * distance ; Point F left Iris Position = m Left Physics . next Iris Position ( left Position , eye Radius , iris Radius ) ; draw Eye ( canvas , left Position , eye Radius , left Iris Position , iris Radius , m Left Open ) ; Point F right Iris Position = m Right Physics . next Iris Position ( right Position , eye Radius , iris Radius ) ; draw Eye ( canvas , right Position , eye Radius , right Iris Position , iris Radius , m Right Open ) ; }
public static void refresh GOE Properties ( ) { Class Discovery . clear Class Cache ( ) ; Generic Properties Creator . regenerate Global Output Properties ( ) ; Generic Object Editor . determine Classes ( ) ; Converter Utils . initialize ( ) ; Knowledge Flow App . dispose Singleton ( ) ; Knowledge Flow App . re Initialize ( ) ; }
public static void refresh GOE Properties ( ) { Class Discovery . clear Class Cache ( ) ; Generic Properties Creator . regenerate Global Output Properties ( ) ; Generic Object Editor . determine Classes ( ) ; Converter Utils . initialize ( ) ; Knowledge Flow App . dispose Singleton ( ) ; Knowledge Flow App . re Initialize ( ) ; }
private stendhal ( ) { }
protected Carbon Dictionary Column Meta Chunk read Last Chunk From Dictionary Metadata File ( Dictionary Column Unique Identifier dictionary Column Unique Identifier ) throws IO Exception { Dictionary Service dict Service = Carbon Common Factory . get Dictionary Service ( ) ; Carbon Dictionary Metadata Reader column Metadata Reader Impl = dict Service . get Dictionary Metadata Reader ( dictionary Column Unique Identifier . get Carbon Table Identifier ( ) , dictionary Column Unique Identifier . get Column Identifier ( ) , carbon Store Path ) ; Carbon Dictionary Column Meta Chunk carbon Dictionary Column Meta Chunk = null ; try { carbon Dictionary Column Meta Chunk = column Metadata Reader Impl . read Last Entry Of Dictionary Meta Chunk ( ) ; } finally { column Metadata Reader Impl . close ( ) ; } return carbon Dictionary Column Meta Chunk ; }
protected Carbon Dictionary Column Meta Chunk read Last Chunk From Dictionary Metadata File ( Dictionary Column Unique Identifier dictionary Column Unique Identifier ) throws IO Exception { Dictionary Service dict Service = Carbon Common Factory . get Dictionary Service ( ) ; Carbon Dictionary Metadata Reader column Metadata Reader Impl = dict Service . get Dictionary Metadata Reader ( dictionary Column Unique Identifier . get Carbon Table Identifier ( ) , dictionary Column Unique Identifier . get Column Identifier ( ) , carbon Store Path ) ; Carbon Dictionary Column Meta Chunk carbon Dictionary Column Meta Chunk = null ; try { carbon Dictionary Column Meta Chunk = column Metadata Reader Impl . read Last Entry Of Dictionary Meta Chunk ( ) ; } finally { column Metadata Reader Impl . close ( ) ; } return carbon Dictionary Column Meta Chunk ; }
private Rectangle 2 D draw Fill ( Graphics 2 D g2 , Rectangle 2 D area ) { Rectangle 2 D filled Area = ( Rectangle 2 D ) area . clone ( ) ; filled Area = trim Margin ( filled Area ) ; filled Area = trim Border ( filled Area ) ; area = trim Padding ( area ) ; g2 . set Paint ( this . fill Paint ) ; g2 . fill ( filled Area ) ; draw Border ( g2 , filled Area ) ; return filled Area ; }
private Rectangle 2 D draw Fill ( Graphics 2 D g2 , Rectangle 2 D area ) { Rectangle 2 D filled Area = ( Rectangle 2 D ) area . clone ( ) ; filled Area = trim Margin ( filled Area ) ; filled Area = trim Border ( filled Area ) ; area = trim Padding ( area ) ; g2 . set Paint ( this . fill Paint ) ; g2 . fill ( filled Area ) ; draw Border ( g2 , filled Area ) ; return filled Area ; }
public void write To File And Parse JSON ( ) throws IO Exception , Ade Exception { file Writer . write ( json Group Object . to String ( ) ) ; file Writer . flush ( ) ; json Group Parser . parse JSON ( json File ) ; }
public void write To File And Parse JSON ( ) throws IO Exception , Ade Exception { file Writer . write ( json Group Object . to String ( ) ) ; file Writer . flush ( ) ; json Group Parser . parse JSON ( json File ) ; }
@ Transactional public long create Pre Approved Voucher From Bill For PJV ( final int bill Id , final List < Pre Approved Voucher > voucherdetail List , final List < Pre Approved Voucher > sub Ledger List ) throws Application Runtime Exception { String voucher Status = null ; long vh = - NUM ; try { final List v Status List = app Config Values Service . get Config Values By Module And Key ( STRING , STRING ) ; if ( ! v Status List . is Empty ( ) && v Status List . size ( ) == NUM ) { final App Config Values app Val = ( App Config Values ) v Status List . get ( NUM ) ; voucher Status = app Val . get Value ( ) ; } else throw new Application Runtime Exception ( STRING + MISSINGMSG ) ; vh = create Voucher . create Voucher From Bill For PJV ( bill Id , voucher Status , voucherdetail List , sub Ledger List ) ; } catch ( final Exception e ) { LOGGER . error ( e . get Message ( ) ) ; throw new Application Runtime Exception ( e . get Message ( ) ) ; } return vh ; }
@ Transactional public long create Pre Approved Voucher From Bill For PJV ( final int bill Id , final List < Pre Approved Voucher > voucherdetail List , final List < Pre Approved Voucher > sub Ledger List ) throws Application Runtime Exception { String voucher Status = null ; long vh = - NUM ; try { final List v Status List = app Config Values Service . get Config Values By Module And Key ( STRING , STRING ) ; if ( ! v Status List . is Empty ( ) && v Status List . size ( ) == NUM ) { final App Config Values app Val = ( App Config Values ) v Status List . get ( NUM ) ; voucher Status = app Val . get Value ( ) ; } else throw new Application Runtime Exception ( STRING + MISSINGMSG ) ; vh = create Voucher . create Voucher From Bill For PJV ( bill Id , voucher Status , voucherdetail List , sub Ledger List ) ; } catch ( final Exception e ) { LOGGER . error ( e . get Message ( ) ) ; throw new Application Runtime Exception ( e . get Message ( ) ) ; } return vh ; }
protected void show Models ( Epoxy Model < ? > ... models ) { show Models ( Arrays . as List ( models ) ) ; }
protected void show Models ( Epoxy Model < ? > ... models ) { show Models ( Arrays . as List ( models ) ) ; }
public final int begin Line ( ) { return this . b Line ; }
public static boolean is Static ( int mod ) { return Modifier . is Static ( mod ) ; }
public static boolean is Static ( int mod ) { return Modifier . is Static ( mod ) ; }
public final Collection < To > map ( Collection < From > entities ) { final Collection < To > result = new Array List < > ( entities . size ( ) ) ; for ( From from : entities ) { result . add ( map ( from ) ) ; } return result ; }
public final Collection < To > map ( Collection < From > entities ) { final Collection < To > result = new Array List < > ( entities . size ( ) ) ; for ( From from : entities ) { result . add ( map ( from ) ) ; } return result ; }
public Object execute Script ( final Script script , final Script Context context ) { final Script Engine engine = script Engine Provider . get Script Engine ( script . get Type ( ) ) ; return execute Script ( script , engine , context ) ; }
public Object execute Script ( final Script script , final Script Context context ) { final Script Engine engine = script Engine Provider . get Script Engine ( script . get Type ( ) ) ; return execute Script ( script , engine , context ) ; }
private void update Ideal Point ( Solution solution ) { for ( int i = NUM ; i < solution . get Number Of Objectives ( ) ; i ++ ) { ideal Point [ i ] = Math . min ( ideal Point [ i ] , solution . get Objective ( i ) ) ; } }
private void update Ideal Point ( Solution solution ) { for ( int i = NUM ; i < solution . get Number Of Objectives ( ) ; i ++ ) { ideal Point [ i ] = Math . min ( ideal Point [ i ] , solution . get Objective ( i ) ) ; } }
private double to Double ( IXML Element elem , String value , double default Value , double min , double max ) throws IO Exception { try { double d = Double . value Of ( value ) ; return Math . max ( Math . min ( d , max ) , min ) ; } catch ( Number Format Exception e ) { return default Value ; } }
private void add Notify ( Array List notifies , Map groups Map , boolean discard ) { synchronized ( pending Notifies ) { pending Notifies . add Last ( new Notify Task ( notifies , groups Map , discard ) ) ; if ( notifier Thread == null ) { notifier Thread = new Notifier ( ) ; notifier Thread . start ( ) ; } } }
private void add Notify ( Array List notifies , Map groups Map , boolean discard ) { synchronized ( pending Notifies ) { pending Notifies . add Last ( new Notify Task ( notifies , groups Map , discard ) ) ; if ( notifier Thread == null ) { notifier Thread = new Notifier ( ) ; notifier Thread . start ( ) ; } } }
public static void log ( ) { Request Log current = RLOG . get ( ) ; if ( current . info == null ) { LOG . warn ( STRING ) ; return ; } LOG . info ( export ( ) ) ; current . clear ( ) ; }
public static void log ( ) { Request Log current = RLOG . get ( ) ; if ( current . info == null ) { LOG . warn ( STRING ) ; return ; } LOG . info ( export ( ) ) ; current . clear ( ) ; }
public void current State ( long state , Model current Model ) { current State = state ; if ( loggers != null ) { for ( Logger logger : loggers ) { logger . log ( state ) ; } } }
static void put Entity Config ( String realm , String entity Id , Entity Config Element config ) { String cache Key = build Cache Key ( realm , entity Id ) ; if ( config != null ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + cache Key ) ; } config Cache . put ( cache Key , config ) ; } else { if ( debug . message Enabled ( ) ) { debug . message ( STRING + cache Key ) ; } config Cache . remove ( cache Key ) ; } }
static void put Entity Config ( String realm , String entity Id , Entity Config Element config ) { String cache Key = build Cache Key ( realm , entity Id ) ; if ( config != null ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + cache Key ) ; } config Cache . put ( cache Key , config ) ; } else { if ( debug . message Enabled ( ) ) { debug . message ( STRING + cache Key ) ; } config Cache . remove ( cache Key ) ; } }
public void add Listener ( Listener listener ) { if ( listener == null ) { throw new Illegal Argument Exception ( STRING ) ; } listeners . add ( listener ) ; }
public void add Listener ( Listener listener ) { if ( listener == null ) { throw new Illegal Argument Exception ( STRING ) ; } listeners . add ( listener ) ; }
public void add Listener ( Listener listener ) { if ( listener == null ) { throw new Illegal Argument Exception ( STRING ) ; } listeners . add ( listener ) ; }
@ Suppress Warnings ( STRING ) public List < Object > split By Lists ( String text , boolean recurse ) { List < Object > text List = new Array List < > ( ) ; String remain Text = text ; msg Handler . log Debug ( STRING + STRING + STRING ) ; while ( BOOL ) { Map < String , Object > list Info = find Parse Bullet List ( remain Text , BOOL ) ; if ( list Info == null ) { break ; } int start Index = ( int ) list Info . get ( STRING ) ; int end Index = ( int ) list Info . get ( STRING ) ; if ( start Index > NUM ) { text List . add ( remain Text . substring ( NUM , start Index ) ) ; } if ( recurse ) { List < Object > parsed Items = new Array List < > ( ) ; List < Object > item Texts = ( List < Object > ) list Info . get ( STRING ) ; if ( item Texts != null && ! item Texts . is Empty ( ) ) { for ( Object item Entry : item Texts ) { String item Text = ( String ) item Entry ; List < Object > parsed Item List = split By Structural Elems ( item Text ) ; parsed Items . add ( parsed Item List ) ; } } list Info . put ( STRING , parsed Items ) ; } text List . add ( list Info ) ; remain Text = remain Text . substring ( end Index ) ; } if ( ! remain Text . is Empty ( ) ) { text List . add ( remain Text ) ; } msg Handler . log Debug ( STRING + text List . size ( ) ) ; return text List ; }
public static int find Global Peak Location ( float [ ] data ) { float max = Float . Na N ; int imax = - NUM ; for ( int i = NUM ; i < data . length ; i ++ ) { if ( Float . is Na N ( data [ i ] ) ) continue ; if ( Float . is Na N ( max ) || data [ i ] > max ) { max = data [ i ] ; imax = i ; } } return imax ; }
public static int find Global Peak Location ( float [ ] data ) { float max = Float . Na N ; int imax = - NUM ; for ( int i = NUM ; i < data . length ; i ++ ) { if ( Float . is Na N ( data [ i ] ) ) continue ; if ( Float . is Na N ( max ) || data [ i ] > max ) { max = data [ i ] ; imax = i ; } } return imax ; }
public Component Definition add Alias ( @ Not Null String text ) { if ( aliases == null ) { aliases = new Array List < String > ( ) ; } aliases . add ( text ) ; return this ; }
public Component Definition add Alias ( @ Not Null String text ) { if ( aliases == null ) { aliases = new Array List < String > ( ) ; } aliases . add ( text ) ; return this ; }
private static Class < ? > class For Param ( String param ) { Class < ? > r ; if ( param . equals ( STRING ) ) { r = int . class ; } else if ( param . equals ( STRING ) ) { r = long . class ; } else if ( param . equals ( STRING ) ) { r = byte . class ; } else if ( param . equals ( STRING ) ) { r = short . class ; } else if ( param . equals ( STRING ) ) { r = char . class ; } else if ( param . equals ( STRING ) ) { r = boolean . class ; } else try { r = Class . for Name ( param ) ; } catch ( Class Not Found Exception e ) { try { r = Class . for Name ( STRING + param ) ; } catch ( Class Not Found Exception f ) { throw new Runtime Exception ( e ) ; } } return r ; }
private static String strip Leading Slash ( String name ) { if ( name . length ( ) < NUM || name . char At ( NUM ) != STRING ) { return name ; } return name . substring ( NUM ) ; }
public static < T > Byte String serialize ( final String template Name , T object ) { String Writer template Results = new String Writer ( ) ; try { final Template template = configuration . get Template ( template Name ) ; template . process ( object , template Results ) ; } catch ( Exception e ) { throw Throwables . propagate ( e ) ; } return Byte String . encode Utf 8 ( template Results . to String ( ) ) ; }
public static < T > Byte String serialize ( final String template Name , T object ) { String Writer template Results = new String Writer ( ) ; try { final Template template = configuration . get Template ( template Name ) ; template . process ( object , template Results ) ; } catch ( Exception e ) { throw Throwables . propagate ( e ) ; } return Byte String . encode Utf 8 ( template Results . to String ( ) ) ; }
private void add Menu Bar ( ) { final J Menu menu = new J Menu ( STRING ) ; final J Menu Item copy Item = new J Menu Item ( C Action Proxy . proxy ( new C Action Copy All Reil Code ( m text Area ) ) ) ; menu . add ( copy Item ) ; final J Menu Bar menu Bar = new J Menu Bar ( ) ; menu Bar . add ( menu ) ; set J Menu Bar ( menu Bar ) ; }
public boolean draw Image ( Image img , Affine Transform xform , Image Observer obs ) { return m Graphics . draw Image ( img , xform , obs ) ; }
public boolean draw Image ( Image img , Affine Transform xform , Image Observer obs ) { return m Graphics . draw Image ( img , xform , obs ) ; }
public boolean draw Image ( Image img , Affine Transform xform , Image Observer obs ) { return m Graphics . draw Image ( img , xform , obs ) ; }
public void add Auth Policy ( String policy Uri ) { String policies = get Auth Policies ( ) ; if ( policies == null || AUTH POLICY NONE . equals ( policies ) ) set Auth Policies ( policy Uri ) ; else set Auth Policies ( policies + STRING + policy Uri ) ; }
public boolean remove Entry ( int x Index , int data Set Index ) { if ( data Set Index >= m Data Sets . size ( ) ) return BOOL ; T data Set = m Data Sets . get ( data Set Index ) ; Entry e = data Set . get Entry For X Index ( x Index ) ; return remove Entry ( e , data Set Index ) ; }
public boolean remove Entry ( int x Index , int data Set Index ) { if ( data Set Index >= m Data Sets . size ( ) ) return BOOL ; T data Set = m Data Sets . get ( data Set Index ) ; Entry e = data Set . get Entry For X Index ( x Index ) ; return remove Entry ( e , data Set Index ) ; }
public boolean remove Entry ( int x Index , int data Set Index ) { if ( data Set Index >= m Data Sets . size ( ) ) return BOOL ; T data Set = m Data Sets . get ( data Set Index ) ; Entry e = data Set . get Entry For X Index ( x Index ) ; return remove Entry ( e , data Set Index ) ; }
public static void train Epochs ( Classification Data Set data Set , Updateable Classifier to Train , int epochs ) { if ( epochs < NUM ) throw new Illegal Argument Exception ( STRING ) ; to Train . set Up ( data Set . get Categories ( ) , data Set . get Num Numerical Vars ( ) , data Set . get Predicting ( ) ) ; Int List random Order = new Int List ( data Set . get Sample Size ( ) ) ; List Utils . add Range ( random Order , NUM , data Set . get Sample Size ( ) , NUM ) ; for ( int epoch = NUM ; epoch < epochs ; epoch ++ ) { Collections . shuffle ( random Order ) ; for ( int i : random Order ) to Train . update ( data Set . get Data Point ( i ) , data Set . get Data Point Category ( i ) ) ; } }
public static void train Epochs ( Classification Data Set data Set , Updateable Classifier to Train , int epochs ) { if ( epochs < NUM ) throw new Illegal Argument Exception ( STRING ) ; to Train . set Up ( data Set . get Categories ( ) , data Set . get Num Numerical Vars ( ) , data Set . get Predicting ( ) ) ; Int List random Order = new Int List ( data Set . get Sample Size ( ) ) ; List Utils . add Range ( random Order , NUM , data Set . get Sample Size ( ) , NUM ) ; for ( int epoch = NUM ; epoch < epochs ; epoch ++ ) { Collections . shuffle ( random Order ) ; for ( int i : random Order ) to Train . update ( data Set . get Data Point ( i ) , data Set . get Data Point Category ( i ) ) ; } }
public static void train Epochs ( Classification Data Set data Set , Updateable Classifier to Train , int epochs ) { if ( epochs < NUM ) throw new Illegal Argument Exception ( STRING ) ; to Train . set Up ( data Set . get Categories ( ) , data Set . get Num Numerical Vars ( ) , data Set . get Predicting ( ) ) ; Int List random Order = new Int List ( data Set . get Sample Size ( ) ) ; List Utils . add Range ( random Order , NUM , data Set . get Sample Size ( ) , NUM ) ; for ( int epoch = NUM ; epoch < epochs ; epoch ++ ) { Collections . shuffle ( random Order ) ; for ( int i : random Order ) to Train . update ( data Set . get Data Point ( i ) , data Set . get Data Point Category ( i ) ) ; } }
public void close ( ) { if ( ! is Open ) return ; Log . d ( TAG , STRING ) ; loading Lock . lock ( ) ; try { save ( ) ; if ( save File Stream != null ) { Saving Helper . close ( save File Stream ) ; save File Stream = null ; } saving Disabled = BOOL ; is Open = BOOL ; Log . i ( TAG , STRING ) ; } finally { loading Lock . unlock ( ) ; } }
public void close ( ) { if ( ! is Open ) return ; Log . d ( TAG , STRING ) ; loading Lock . lock ( ) ; try { save ( ) ; if ( save File Stream != null ) { Saving Helper . close ( save File Stream ) ; save File Stream = null ; } saving Disabled = BOOL ; is Open = BOOL ; Log . i ( TAG , STRING ) ; } finally { loading Lock . unlock ( ) ; } }
public static boolean is Non Public Proxy Class ( Class < ? > cls ) { String name = cls . get Name ( ) ; int i = name . last Index Of ( STRING ) ; String pkg = ( i != - NUM ) ? name . substring ( NUM , i ) : STRING ; return Proxy . is Proxy Class ( cls ) && ! pkg . equals ( PROXY PACKAGE ) ; }
public static boolean is Non Public Proxy Class ( Class < ? > cls ) { String name = cls . get Name ( ) ; int i = name . last Index Of ( STRING ) ; String pkg = ( i != - NUM ) ? name . substring ( NUM , i ) : STRING ; return Proxy . is Proxy Class ( cls ) && ! pkg . equals ( PROXY PACKAGE ) ; }
public static String empty To Null ( String s ) { if ( s == null ) return null ; return s . length ( ) == NUM ? null : s ; }
public static String empty To Null ( String s ) { if ( s == null ) return null ; return s . length ( ) == NUM ? null : s ; }
Test Environment ( System Test Environment system Test Environment , Path working Dir , Path source Dir , Path class Dir , Path jacoco Dir ) { this . system Test Environment = system Test Environment ; this . working Dir = working Dir ; this . source Dir = source Dir ; this . class Dir = class Dir ; this . jacoco Dir = jacoco Dir ; this . test Class Path = system Test Environment . classpath + STRING + class Dir . to String ( ) ; }
public void log Message ( SIP Message message , String from , String to , String status , boolean sender ) { log Message ( message , from , to , status , sender , System . current Time Millis ( ) ) ; }
public void log Message ( SIP Message message , String from , String to , String status , boolean sender ) { log Message ( message , from , to , status , sender , System . current Time Millis ( ) ) ; }
protected J Popup Menu create Popup Menu ( boolean properties , boolean save , boolean print , boolean zoom ) { return create Popup Menu ( properties , BOOL , save , print , zoom ) ; }
private String to String ( Unit u ) { if ( u == null ) return STRING ; if ( u instanceof Goto Stmt ) { Goto Stmt goto stmt = ( Goto Stmt ) u ; return String . format ( STRING , lnums . get ( goto stmt . get Target ( ) ) , lnums . get ( u ) ) ; } else if ( u instanceof If Stmt ) { If Stmt if stmt = ( If Stmt ) u ; return String . format ( STRING , if stmt . get Condition ( ) , lnums . get ( if stmt . get Target ( ) ) , lnums . get ( u ) ) ; } else return String . format ( STRING , u , lnums . get ( u ) ) ; }
private String to String ( Unit u ) { if ( u == null ) return STRING ; if ( u instanceof Goto Stmt ) { Goto Stmt goto stmt = ( Goto Stmt ) u ; return String . format ( STRING , lnums . get ( goto stmt . get Target ( ) ) , lnums . get ( u ) ) ; } else if ( u instanceof If Stmt ) { If Stmt if stmt = ( If Stmt ) u ; return String . format ( STRING , if stmt . get Condition ( ) , lnums . get ( if stmt . get Target ( ) ) , lnums . get ( u ) ) ; } else return String . format ( STRING , u , lnums . get ( u ) ) ; }
private String to String ( Unit u ) { if ( u == null ) return STRING ; if ( u instanceof Goto Stmt ) { Goto Stmt goto stmt = ( Goto Stmt ) u ; return String . format ( STRING , lnums . get ( goto stmt . get Target ( ) ) , lnums . get ( u ) ) ; } else if ( u instanceof If Stmt ) { If Stmt if stmt = ( If Stmt ) u ; return String . format ( STRING , if stmt . get Condition ( ) , lnums . get ( if stmt . get Target ( ) ) , lnums . get ( u ) ) ; } else return String . format ( STRING , u , lnums . get ( u ) ) ; }
private String to String ( Unit u ) { if ( u == null ) return STRING ; if ( u instanceof Goto Stmt ) { Goto Stmt goto stmt = ( Goto Stmt ) u ; return String . format ( STRING , lnums . get ( goto stmt . get Target ( ) ) , lnums . get ( u ) ) ; } else if ( u instanceof If Stmt ) { If Stmt if stmt = ( If Stmt ) u ; return String . format ( STRING , if stmt . get Condition ( ) , lnums . get ( if stmt . get Target ( ) ) , lnums . get ( u ) ) ; } else return String . format ( STRING , u , lnums . get ( u ) ) ; }
private void update Overscroll Animation ( final int scrolled Offset ) { if ( m Edge Glow Left == null || m Edge Glow Right == null ) return ; int next Scroll Position = m Current X + scrolled Offset ; if ( m Fling Tracker == null || m Fling Tracker . is Finished ( ) ) { if ( next Scroll Position < NUM ) { int overscroll = Math . abs ( scrolled Offset ) ; m Edge Glow Left . on Pull ( ( float ) overscroll / get Render Width ( ) ) ; if ( ! m Edge Glow Right . is Finished ( ) ) { m Edge Glow Right . on Release ( ) ; } } else if ( next Scroll Position > m Max X ) { int overscroll = Math . abs ( scrolled Offset ) ; m Edge Glow Right . on Pull ( ( float ) overscroll / get Render Width ( ) ) ; if ( ! m Edge Glow Left . is Finished ( ) ) { m Edge Glow Left . on Release ( ) ; } } } }
Job load Preview ( Future Callback < Pair < Omni Build Environment , Omni Gradle Build > > result Handler , List < Progress Listener > listeners ) ;
public Entity Query filter By Date ( Timestamp moment , String ... filter By Field Name ) { this . filter By Date = BOOL ; this . filter By Date Moment = moment ; if ( filter By Field Name . length % NUM != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } this . filter By Field Names = Arrays . as List ( filter By Field Name ) ; return this ; }
public Entity Query filter By Date ( Timestamp moment , String ... filter By Field Name ) { this . filter By Date = BOOL ; this . filter By Date Moment = moment ; if ( filter By Field Name . length % NUM != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } this . filter By Field Names = Arrays . as List ( filter By Field Name ) ; return this ; }
public Entity Query filter By Date ( Timestamp moment , String ... filter By Field Name ) { this . filter By Date = BOOL ; this . filter By Date Moment = moment ; if ( filter By Field Name . length % NUM != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } this . filter By Field Names = Arrays . as List ( filter By Field Name ) ; return this ; }
public void clear Image ( ) { clear Image Int ( ) ; m Crop Overlay View . set Initial Crop Window Rect ( null ) ; }
public D Generating Key Pair ( J Frame parent , Key Pair Type key Pair Type , int key Size , Provider provider ) { super ( parent , Dialog . Modality Type . DOCUMENT MODAL ) ; this . key Pair Type = key Pair Type ; this . key Size = key Size ; this . provider = provider ; init Components ( ) ; }
protected void create Triple Buffer ( int width , int height ) { try { triple Buffer = mx Utils . create Buffered Image ( width , height , null ) ; triple Buffer Graphics = triple Buffer . create Graphics ( ) ; repaint Triple Buffer ( null ) ; } catch ( Out Of Memory Error error ) { } }
protected void create Triple Buffer ( int width , int height ) { try { triple Buffer = mx Utils . create Buffered Image ( width , height , null ) ; triple Buffer Graphics = triple Buffer . create Graphics ( ) ; repaint Triple Buffer ( null ) ; } catch ( Out Of Memory Error error ) { } }
private void test Advance Past Next Sync Marker At ( int position , int size ) throws IO Exception { byte sentinel = ( byte ) NUM ; byte [ ] marker = new byte [ ] { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte [ ] haystack = create Haystack ( marker , position , size ) ; Pushback Input Stream stream = new Pushback Input Stream ( new Byte Array Input Stream ( haystack ) , marker . length ) ; if ( position + marker . length < size ) { haystack [ position + marker . length ] = sentinel ; assert Equals ( position + marker . length , Avro Reader . advance Past Next Sync Marker ( stream , marker ) ) ; assert Equals ( sentinel , ( byte ) stream . read ( ) ) ; } else { assert Equals ( size , Avro Reader . advance Past Next Sync Marker ( stream , marker ) ) ; assert Equals ( - NUM , stream . read ( ) ) ; } }
private void test Advance Past Next Sync Marker At ( int position , int size ) throws IO Exception { byte sentinel = ( byte ) NUM ; byte [ ] marker = new byte [ ] { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte [ ] haystack = create Haystack ( marker , position , size ) ; Pushback Input Stream stream = new Pushback Input Stream ( new Byte Array Input Stream ( haystack ) , marker . length ) ; if ( position + marker . length < size ) { haystack [ position + marker . length ] = sentinel ; assert Equals ( position + marker . length , Avro Reader . advance Past Next Sync Marker ( stream , marker ) ) ; assert Equals ( sentinel , ( byte ) stream . read ( ) ) ; } else { assert Equals ( size , Avro Reader . advance Past Next Sync Marker ( stream , marker ) ) ; assert Equals ( - NUM , stream . read ( ) ) ; } }
public List < Product > scroll Cart Of User ( final User user , final int skip , final int top ) { if ( user == null ) return Collections . empty List ( ) ; Product Cart cart = get Cart Of User ( user ) ; if ( cart == null ) return Collections . empty List ( ) ; return set To Limited List ( cart . get Products ( ) , skip , top ) ; }
public List < Product > scroll Cart Of User ( final User user , final int skip , final int top ) { if ( user == null ) return Collections . empty List ( ) ; Product Cart cart = get Cart Of User ( user ) ; if ( cart == null ) return Collections . empty List ( ) ; return set To Limited List ( cart . get Products ( ) , skip , top ) ; }
public List < Product > scroll Cart Of User ( final User user , final int skip , final int top ) { if ( user == null ) return Collections . empty List ( ) ; Product Cart cart = get Cart Of User ( user ) ; if ( cart == null ) return Collections . empty List ( ) ; return set To Limited List ( cart . get Products ( ) , skip , top ) ; }
protected void show Info ( String msg ) { if ( msg == null ) msg = STRING ; m Label Info . set Text ( msg ) ; }
protected void show Info ( String msg ) { if ( msg == null ) msg = STRING ; m Label Info . set Text ( msg ) ; }
protected void show Info ( String msg ) { if ( msg == null ) msg = STRING ; m Label Info . set Text ( msg ) ; }
public static String droidsafe Output File ( I Project project , String file Name ) { String output Dir = get Project Output Dir ( project ) ; String full Path = output Dir + File . separator + file Name ; return full Path ; }
public static String droidsafe Output File ( I Project project , String file Name ) { String output Dir = get Project Output Dir ( project ) ; String full Path = output Dir + File . separator + file Name ; return full Path ; }
private double do Acquire ( double permits To Acquire , double current Time ) { while ( BOOL ) { read Rate . lock ( ) ; try { double permit Release Rate = this . permits Per Second ; double clock Delta = permits To Acquire / permit Release Rate ; double lowest Allowed Clock = current Time - backlog Size ; double current Clock = clock . get ( ) ; double next Clock = current Clock + clock Delta ; if ( next Clock < lowest Allowed Clock ) next Clock = lowest Allowed Clock ; if ( clock . compare And Set ( current Clock , next Clock ) ) { if ( next Clock > current Time ) return permit Release Rate * ( next Clock - current Time ) ; else return NUM ; } } finally { read Rate . unlock ( ) ; } } }
private double do Acquire ( double permits To Acquire , double current Time ) { while ( BOOL ) { read Rate . lock ( ) ; try { double permit Release Rate = this . permits Per Second ; double clock Delta = permits To Acquire / permit Release Rate ; double lowest Allowed Clock = current Time - backlog Size ; double current Clock = clock . get ( ) ; double next Clock = current Clock + clock Delta ; if ( next Clock < lowest Allowed Clock ) next Clock = lowest Allowed Clock ; if ( clock . compare And Set ( current Clock , next Clock ) ) { if ( next Clock > current Time ) return permit Release Rate * ( next Clock - current Time ) ; else return NUM ; } } finally { read Rate . unlock ( ) ; } } }
@ Override public void disconnection Notification ( String event Name , Object source ) { if ( source == m first Input ) { m first Input = null ; m first Input Connection Type = STRING ; } else if ( source == m second Input ) { m second Input = null ; m second Input Connection Type = STRING ; } if ( m first Input != null && m second Input != null ) { if ( m first Input Connection Type . length ( ) > NUM || m second Input Connection Type . length ( ) > NUM ) { if ( ! m first Input Connection Type . equals ( STRING ) && ! m second Input Connection Type . equals ( STRING ) ) { m incoming Batch Connections = BOOL ; } else { m incoming Batch Connections = BOOL ; } } else { m incoming Batch Connections = BOOL ; } } }
public void add CP Item ( CP cp ) { String uniq = cp . get Uniq ( ) ; CP intern ; if ( ( intern = ( CP ) ( cpe . get ( uniq ) ) ) == null ) { cpe . put ( uniq , cp ) ; cp . resolve ( this ) ; } }
public void add CP Item ( CP cp ) { String uniq = cp . get Uniq ( ) ; CP intern ; if ( ( intern = ( CP ) ( cpe . get ( uniq ) ) ) == null ) { cpe . put ( uniq , cp ) ; cp . resolve ( this ) ; } }
public void add CP Item ( CP cp ) { String uniq = cp . get Uniq ( ) ; CP intern ; if ( ( intern = ( CP ) ( cpe . get ( uniq ) ) ) == null ) { cpe . put ( uniq , cp ) ; cp . resolve ( this ) ; } }
public void add CP Item ( CP cp ) { String uniq = cp . get Uniq ( ) ; CP intern ; if ( ( intern = ( CP ) ( cpe . get ( uniq ) ) ) == null ) { cpe . put ( uniq , cp ) ; cp . resolve ( this ) ; } }
public void add CP Item ( CP cp ) { String uniq = cp . get Uniq ( ) ; CP intern ; if ( ( intern = ( CP ) ( cpe . get ( uniq ) ) ) == null ) { cpe . put ( uniq , cp ) ; cp . resolve ( this ) ; } }
public static void put 3 Byte Int ( Byte Buffer buffer , int val , Byte Order order ) { int pos = buffer . position ( ) ; put 3 Byte Int ( buffer , val , pos , order ) ; buffer . position ( pos + NUM ) ; }
Iterator < Heap Variable < Object > > enumerate Exposed Heap Variables ( ) { Array List < Heap Variable < Object > > v = new Array List < Heap Variable < Object > > ( ) ; for ( Iterator < Heap Variable < Object > > e = get Heap Variables ( ) ; e . has Next ( ) ; ) { Heap Variable < Object > H = e . next ( ) ; if ( is Exposed On Exit ( H ) ) { v . add ( H ) ; } } return v . iterator ( ) ; }
Iterator < Heap Variable < Object > > enumerate Exposed Heap Variables ( ) { Array List < Heap Variable < Object > > v = new Array List < Heap Variable < Object > > ( ) ; for ( Iterator < Heap Variable < Object > > e = get Heap Variables ( ) ; e . has Next ( ) ; ) { Heap Variable < Object > H = e . next ( ) ; if ( is Exposed On Exit ( H ) ) { v . add ( H ) ; } } return v . iterator ( ) ; }
public void add ( final Conversation States state , final String trigger String , final Chat Condition condition , boolean secondary , final Conversation States next State , final String reply , final Chat Action action ) { Collection < Expression > trigger Expressions = create Unique Trigger Expressions ( state , Arrays . as List ( trigger String ) , null , condition , reply , action ) ; add ( trigger Expressions , state , condition , secondary , next State , reply , action ) ; }
public void pre Deregister ( ) throws Exception { try { close ( ) ; if ( ! sequencer . try Acquire ( ) ) throw new Illegal State Exception ( STRING ) ; try { unregister Scanners ( ) ; unregister Configs ( ) ; unregister Result Log Manager ( ) ; } finally { sequencer . release ( ) ; } } catch ( Exception x ) { LOG . log ( Level . FINEST , STRING + x , x ) ; throw x ; } }
public void pre Deregister ( ) throws Exception { try { close ( ) ; if ( ! sequencer . try Acquire ( ) ) throw new Illegal State Exception ( STRING ) ; try { unregister Scanners ( ) ; unregister Configs ( ) ; unregister Result Log Manager ( ) ; } finally { sequencer . release ( ) ; } } catch ( Exception x ) { LOG . log ( Level . FINEST , STRING + x , x ) ; throw x ; } }
public void pre Deregister ( ) throws Exception { try { close ( ) ; if ( ! sequencer . try Acquire ( ) ) throw new Illegal State Exception ( STRING ) ; try { unregister Scanners ( ) ; unregister Configs ( ) ; unregister Result Log Manager ( ) ; } finally { sequencer . release ( ) ; } } catch ( Exception x ) { LOG . log ( Level . FINEST , STRING + x , x ) ; throw x ; } }
protected boolean is File Specifying Module Specifier ( String specifier ) { return specifier . length ( ) > NUM && specifier . char At ( specifier . length ( ) - NUM ) != I Path . SEPARATOR ; }
protected boolean is File Specifying Module Specifier ( String specifier ) { return specifier . length ( ) > NUM && specifier . char At ( specifier . length ( ) - NUM ) != I Path . SEPARATOR ; }
public Sms Message Sender ( Context context , String [ ] dests , String msg Text , long thread Id ) { m Context = context ; m Message Text = msg Text ; m Number Of Dests = dests . length ; m Dests = new String [ m Number Of Dests ] ; System . arraycopy ( dests , NUM , m Dests , NUM , m Number Of Dests ) ; m Timestamp = System . current Time Millis ( ) ; m Thread Id = thread Id ; m Service Center = get Outgoing Service Center ( m Thread Id ) ; Shared Preferences m Prefs = Preference Manager . get Default Shared Preferences ( m Context ) ; split Message = m Prefs . get Boolean ( m Context . get String ( R . string . pref split message key ) , DEFAULT SPLIT MESSAGE ) ; request Delivery Report = m Prefs . get Boolean ( m Context . get String ( R . string . pref delivery report key ) , DEFAULT DELIVERY REPORT MODE ) ; }
private void handle Html Search Accounts ( Page Wrapper page Wrapper , Request And Response request And Response , String query , String pane Id ) throws IO Exception , Servlet Exception { page Wrapper . add Page Intro Text ( servlet Text . intro Text Search Users ( ) , null ) ; if ( ! is User An Admin ( request And Response ) ) { request And Response . print ( servlet Text . error Page Not Allowed ( ) ) ; } else { try { final String Builder result = new String Builder ( ) ; final User user = db Logic . get User By User Name ( query . to Lower Case ( ) ) ; if ( user == null ) { result . append ( servlet Text . sentence There Were No Matches ( ) ) ; } else { start Item List ( result , pane Id ) ; add User Html ( user , result , NUM , pane Id ) ; finish Item List ( result ) ; } db Logic . commit ( ) ; request And Response . print ( result . to String ( ) ) ; } catch ( final Persistence Exception e ) { request And Response . print ( servlet Text . error Internal Database ( ) ) ; } } }
private void handle Html Search Accounts ( Page Wrapper page Wrapper , Request And Response request And Response , String query , String pane Id ) throws IO Exception , Servlet Exception { page Wrapper . add Page Intro Text ( servlet Text . intro Text Search Users ( ) , null ) ; if ( ! is User An Admin ( request And Response ) ) { request And Response . print ( servlet Text . error Page Not Allowed ( ) ) ; } else { try { final String Builder result = new String Builder ( ) ; final User user = db Logic . get User By User Name ( query . to Lower Case ( ) ) ; if ( user == null ) { result . append ( servlet Text . sentence There Were No Matches ( ) ) ; } else { start Item List ( result , pane Id ) ; add User Html ( user , result , NUM , pane Id ) ; finish Item List ( result ) ; } db Logic . commit ( ) ; request And Response . print ( result . to String ( ) ) ; } catch ( final Persistence Exception e ) { request And Response . print ( servlet Text . error Internal Database ( ) ) ; } } }
private void handle Html Search Accounts ( Page Wrapper page Wrapper , Request And Response request And Response , String query , String pane Id ) throws IO Exception , Servlet Exception { page Wrapper . add Page Intro Text ( servlet Text . intro Text Search Users ( ) , null ) ; if ( ! is User An Admin ( request And Response ) ) { request And Response . print ( servlet Text . error Page Not Allowed ( ) ) ; } else { try { final String Builder result = new String Builder ( ) ; final User user = db Logic . get User By User Name ( query . to Lower Case ( ) ) ; if ( user == null ) { result . append ( servlet Text . sentence There Were No Matches ( ) ) ; } else { start Item List ( result , pane Id ) ; add User Html ( user , result , NUM , pane Id ) ; finish Item List ( result ) ; } db Logic . commit ( ) ; request And Response . print ( result . to String ( ) ) ; } catch ( final Persistence Exception e ) { request And Response . print ( servlet Text . error Internal Database ( ) ) ; } } }
private void auto Request Mods ( ) { if ( ! c . auto Request Mods Enabled ( ) ) { return ; } Set < String > joined Channels = c . get Joined Channels ( ) ; for ( String channel : joined Channels ) { if ( ! mods Already Requested . contains ( channel ) ) { LOGGER . info ( STRING + channel ) ; mods Already Requested . add ( channel ) ; request Mods Silent ( channel ) ; return ; } } }
private void auto Request Mods ( ) { if ( ! c . auto Request Mods Enabled ( ) ) { return ; } Set < String > joined Channels = c . get Joined Channels ( ) ; for ( String channel : joined Channels ) { if ( ! mods Already Requested . contains ( channel ) ) { LOGGER . info ( STRING + channel ) ; mods Already Requested . add ( channel ) ; request Mods Silent ( channel ) ; return ; } } }
public void trim ( ) { objects . trim To Size ( ) ; }
public Builder add Target Elements ( Element ... additional Targets ) { for ( int i = NUM ; i < additional Targets . length ; i ++ ) { target Elements . add ( additional Targets [ i ] ) ; } return this ; }
private String resize Image ( String an Image Url , String filename , Image Size src Image Size , Image Size dst Image Size , int rotation Angle ) { String image Url = an Image Url ; try { if ( null != dst Image Size ) { File Input Stream image Stream = new File Input Stream ( new File ( filename ) ) ; Input Stream resize Bitmap Stream = null ; try { resize Bitmap Stream = Image Utils . resize Image ( image Stream , - NUM , ( src Image Size . m Width + dst Image Size . m Width - NUM ) / dst Image Size . m Width , NUM ) ; } catch ( Out Of Memory Error ex ) { Log . e ( LOG TAG , STRING + ex . get Message ( ) ) ; } catch ( Exception e ) { Log . e ( LOG TAG , STRING + e . get Message ( ) ) ; } if ( null != resize Bitmap Stream ) { String bitmap URL = m Medias Cache . save Media ( resize Bitmap Stream , null , Common Activity Utils . MIME TYPE JPEG ) ; if ( null != bitmap URL ) { image Url = bitmap URL ; } resize Bitmap Stream . close ( ) ; } } if ( NUM != rotation Angle ) { Image Utils . rotate Image ( m Vector Room Activity , image Url , rotation Angle , m Medias Cache ) ; } } catch ( Exception e ) { Log . e ( LOG TAG , STRING + e . get Message ( ) ) ; } return image Url ; }
@ Deprecated public Shapeless Recipe add Ingredient ( int count , Material ingredient , int rawdata ) { Validate . is True ( ingredients . size ( ) + count <= NUM , STRING ) ; if ( rawdata == - NUM ) { rawdata = Short . MAX VALUE ; } while ( count -- > NUM ) { ingredients . add ( new Item Stack ( ingredient , NUM , ( short ) rawdata ) ) ; } return this ; }
protected void fill Context Defaults ( Context context ) { context . put ( STRING , instance ) ; context . put ( STRING , get Output Path ( ) ) ; }
public static Select Clause create ( Stream Selector stream Selector , String ... property Names ) { List < Select Clause Element > select List = new Array List < Select Clause Element > ( ) ; for ( String name : property Names ) { select List . add ( new Select Clause Expression ( new Property Value Expression ( name ) ) ) ; } return new Select Clause ( stream Selector , select List ) ; }
void prepare For Close ( Local Region region , Disk Region dr ) { if ( dr . is Backup ( ) ) { force Flush ( ) ; } }
void prepare For Close ( Local Region region , Disk Region dr ) { if ( dr . is Backup ( ) ) { force Flush ( ) ; } }
void prepare For Close ( Local Region region , Disk Region dr ) { if ( dr . is Backup ( ) ) { force Flush ( ) ; } }
private int measure Height ( ) { int day Of Week = calendar . get ( Calendar . DAY OF WEEK ) ; int days Of Month = days Of Current Month ( ) ; int n = - NUM ; if ( day Of Week >= NUM && day Of Week <= NUM ) { n = days Of Month - ( NUM - day Of Week + NUM ) ; } else if ( day Of Week == NUM ) { n = days Of Month - NUM ; } int lines = NUM + n / NUM + ( n % NUM == NUM ? NUM : NUM ) ; return ( int ) ( cell Height * lines ) ; }
public char reverse Map ( short glyph ID ) { Short result = glyph Lookup . get ( new Short ( glyph ID ) ) ; if ( result == null ) { return STRING ; } return ( char ) result . short Value ( ) ; }
@ Override protected void create Handshake Bytes ( ) { handshake Bytes = new byte [ Constants . HANDSHAKE SIZE ] ; handshake Bytes [ NUM ] = NUM ; handshake Bytes [ NUM ] = NUM ; handshake Bytes [ NUM ] = NUM ; handshake Bytes [ NUM ] = NUM ; handshake Bytes [ NUM ] = NUM ; handshake Bytes [ NUM ] = NUM ; handshake Bytes [ NUM ] = NUM ; handshake Bytes [ NUM ] = NUM ; byte [ ] rnd Bytes = new byte [ Constants . HANDSHAKE SIZE - NUM ] ; random . next Bytes ( rnd Bytes ) ; System . arraycopy ( rnd Bytes , NUM , handshake Bytes , NUM , ( Constants . HANDSHAKE SIZE - NUM ) ) ; }
Chrono Local Date Time < D > to Local Date Time ( ) ;
Chrono Local Date Time < D > to Local Date Time ( ) ;
Chrono Local Date Time < D > to Local Date Time ( ) ;
private static void add ( Map < String , List < Object > > map , String key , Object value ) { List < Object > values = map . get ( key ) ; if ( values == null ) { map . put ( key , values = new Array List < Object > ( NUM ) ) ; } values . add ( value ) ; }
@ Override public void apply ( Nexus Stream Parser np ) throws Exception { np . match Ignore Case ( get Syntax ( ) ) ; if ( get Parent ( ) instanceof Overlap Graph Viewer ) { final Overlap Graph Viewer overlap Graph Viewer = ( Overlap Graph Viewer ) get Parent ( ) ; final Graph View graph View = overlap Graph Viewer . get Graph View ( ) ; final Node Map < String > node 2 Read Name Map = overlap Graph Viewer . get Node 2 Read Name Map ( ) ; final Set < String > previous Selection = Project Manager . get Previously Selected Node Labels ( ) ; if ( previous Selection . size ( ) > NUM ) { Graph graph = graph View . get Graph ( ) ; Node Set to Select = new Node Set ( graph ) ; for ( Node v = graph . get First Node ( ) ; v != null ; v = graph . get Next Node ( v ) ) { String label = node 2 Read Name Map . get ( v ) ; if ( label != null && previous Selection . contains ( label ) ) to Select . add ( v ) ; } if ( to Select . size ( ) > NUM ) { graph View . set Selected ( to Select , BOOL ) ; graph View . repaint ( ) ; } } } }
public void add Tab Fragment ( Tab Fragment tab Fragment ) { fragment List . add ( tab Fragment ) ; }
void display Error Dialog ( Window w , Throwable t ) { if ( t instanceof No Display Exception ) { return ; } display Error Dialog ( w , t . to String ( ) ) ; }
public void invert Selected Relations ( ) { I Selection selection = viewer . get Selection ( ) ; if ( ! ( selection instanceof I Structured Selection ) ) { return ; } I Structured Selection structured Selection = ( I Structured Selection ) selection ; Collection < Relation > inverse = compute Inverse Relations ( get Table Relations ( ) , structured Selection ) ; Structured Selection next Selection = new Structured Selection ( inverse . to Array ( ) ) ; viewer . set Selection ( next Selection , BOOL ) ; }
public void notify Exited ( final Active Entity entity , final int old X , final int old Y ) { Rectangle 2 D e Area ; e Area = entity . get Area ( old X , old Y ) ; for ( final Movement Listener l : movement Listeners ) { Rectangle 2 D area = l . get Area ( ) ; if ( area . intersects ( e Area ) ) { l . on Exited ( entity , this , old X , old Y ) ; } } }
public static Instances load Dataset ( String options [ ] , char T ) throws Exception { Instances D = null ; String filename = Utils . get Option ( T , options ) ; if ( filename == null || filename . is Empty ( ) ) throw new Exception ( STRING ) ; File file = new File ( filename ) ; if ( ! file . exists ( ) ) throw new Exception ( STRING + filename ) ; if ( file . is Directory ( ) ) throw new Exception ( STRING + filename + STRING ) ; try { Data Source source = new Data Source ( filename ) ; D = source . get Data Set ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; throw new Exception ( STRING + filename + STRING ) ; } return D ; }
public static Instances load Dataset ( String options [ ] , char T ) throws Exception { Instances D = null ; String filename = Utils . get Option ( T , options ) ; if ( filename == null || filename . is Empty ( ) ) throw new Exception ( STRING ) ; File file = new File ( filename ) ; if ( ! file . exists ( ) ) throw new Exception ( STRING + filename ) ; if ( file . is Directory ( ) ) throw new Exception ( STRING + filename + STRING ) ; try { Data Source source = new Data Source ( filename ) ; D = source . get Data Set ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; throw new Exception ( STRING + filename + STRING ) ; } return D ; }
public void apply ( ) { set Speed Map ( ) ; set N Xdata ( ) ; }
public void apply ( ) { set Speed Map ( ) ; set N Xdata ( ) ; }
public static boolean find Option ( String name , List < String > args , boolean remove ) { int idx = args . index Of ( name ) ; if ( idx >= NUM ) { if ( remove ) { args . remove ( idx ) ; } return BOOL ; } return BOOL ; }
public static boolean find Option ( String name , List < String > args , boolean remove ) { int idx = args . index Of ( name ) ; if ( idx >= NUM ) { if ( remove ) { args . remove ( idx ) ; } return BOOL ; } return BOOL ; }
private void render Operator Background ( final Operator operator , final Graphics 2 D g2 ) { Rectangle 2 D frame = model . get Operator Rect ( operator ) ; if ( frame == null ) { return ; } Round Rectangle 2 D background = new Round Rectangle 2 D . Double ( frame . get X ( ) - NUM , frame . get Y ( ) - NUM , frame . get Width ( ) + NUM , frame . get Height ( ) + NUM , OPERATOR BG CORNER , OPERATOR BG CORNER ) ; g2 . set Color ( Color . WHITE ) ; g2 . fill ( background ) ; Rectangle 2 D name Bounds = OPERATOR FONT . get String Bounds ( operator . get Name ( ) , g2 . get Font Render Context ( ) ) ; if ( name Bounds . get Width ( ) > frame . get Width ( ) ) { double relevant Width = Math . min ( name Bounds . get Width ( ) , frame . get Width ( ) * MAX HEADER RATIO ) ; double offset = ( frame . get Width ( ) - relevant Width ) / NUM ; int x = ( int ) ( frame . get X ( ) + offset ) ; int padding = NUM ; Round Rectangle 2 D name Background = new Round Rectangle 2 D . Double ( ( int ) Math . min ( frame . get X ( ) - padding , x - padding ) , frame . get Y ( ) - NUM , relevant Width + NUM * padding , Process Renderer Model . HEADER HEIGHT + NUM , OPERATOR BG CORNER , OPERATOR BG CORNER ) ; g2 . fill ( name Background ) ; } render Ports Background ( operator . get Input Ports ( ) , g2 ) ; render Ports Background ( operator . get Output Ports ( ) , g2 ) ; }
public void do Insertion Sort ( String [ ] names , int [ ] values ) { int i , j , t ; String temp = STRING ; for ( i = NUM ; i < values . length ; i ++ ) { j = i ; t = values [ j ] ; temp = names [ j ] ; while ( j > NUM && values [ j - NUM ] > t ) { values [ j ] = values [ j - NUM ] ; names [ j ] = names [ j - NUM ] ; j -- ; } values [ j ] = t ; names [ j ] = temp ; } }
public void do Insertion Sort ( String [ ] names , int [ ] values ) { int i , j , t ; String temp = STRING ; for ( i = NUM ; i < values . length ; i ++ ) { j = i ; t = values [ j ] ; temp = names [ j ] ; while ( j > NUM && values [ j - NUM ] > t ) { values [ j ] = values [ j - NUM ] ; names [ j ] = names [ j - NUM ] ; j -- ; } values [ j ] = t ; names [ j ] = temp ; } }
public void do Insertion Sort ( String [ ] names , int [ ] values ) { int i , j , t ; String temp = STRING ; for ( i = NUM ; i < values . length ; i ++ ) { j = i ; t = values [ j ] ; temp = names [ j ] ; while ( j > NUM && values [ j - NUM ] > t ) { values [ j ] = values [ j - NUM ] ; names [ j ] = names [ j - NUM ] ; j -- ; } values [ j ] = t ; names [ j ] = temp ; } }
public static int convert String To Time Seconds ( String time ) { int result = NUM ; if ( time . ends With ( STRING ) ) { int hours To Add = Integer . value Of ( String Utils . remove ( time , STRING ) ) ; result = ( NUM * NUM ) * hours To Add ; } else if ( time . ends With ( STRING ) ) { int mins To Add = Integer . value Of ( String Utils . remove ( time , STRING ) ) ; result = NUM * mins To Add ; } else if ( time . ends With ( STRING ) ) { int secs To Add = Integer . value Of ( String Utils . remove ( time , STRING ) ) ; result = secs To Add ; } return result ; }
public static String deflate ( String previous , String current ) { if ( previous == null ) return current ; String Builder buf = new String Builder ( ) ; int start 1 = NUM ; int start 2 = NUM ; while ( start 1 < previous . length ( ) && start 2 < current . length ( ) ) { int end 1 = start 1 ; int end 2 = start 2 ; while ( end 1 <= previous . length ( ) && end 2 <= current . length ( ) ) { int c1 = ( end 1 < previous . length ( ) ? previous . char At ( end 1 ) : STRING ) ; int c2 = ( end 2 < current . length ( ) ? current . char At ( end 2 ) : STRING ) ; if ( c1 == c2 ) { if ( c1 == STRING ) { buf . append ( STRING ) ; break ; } else { end 1 ++ ; end 2 ++ ; } } else { while ( end 1 < previous . length ( ) && previous . char At ( end 1 ) != STRING ) { end 1 ++ ; } while ( end 2 < current . length ( ) && current . char At ( end 2 ) != STRING ) { end 2 ++ ; } for ( int i = start 2 ; i < end 2 ; i ++ ) buf . append ( current . char At ( i ) ) ; break ; } } start 1 = end 1 + NUM ; start 2 = end 2 + NUM ; if ( start 2 < current . length ( ) ) buf . append ( STRING ) ; } return buf . to String ( ) ; }
protected Resource Loader License Locator ( final Charset charset , final String ... license Files ) { if ( license Files == null || license Files . length == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( charset == null ) { throw new Null Pointer Exception ( STRING ) ; } this . license Files = new Array List < String > ( Arrays . as List ( license Files ) ) ; this . charset = charset ; }
protected Resource Loader License Locator ( final Charset charset , final String ... license Files ) { if ( license Files == null || license Files . length == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( charset == null ) { throw new Null Pointer Exception ( STRING ) ; } this . license Files = new Array List < String > ( Arrays . as List ( license Files ) ) ; this . charset = charset ; }
protected Resource Loader License Locator ( final Charset charset , final String ... license Files ) { if ( license Files == null || license Files . length == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( charset == null ) { throw new Null Pointer Exception ( STRING ) ; } this . license Files = new Array List < String > ( Arrays . as List ( license Files ) ) ; this . charset = charset ; }
public List < Ivr Zone > show Active Ivr Zone ( ) throws Network Device Controller Exception { return show Ivr Zones ( BOOL ) ; }
public synchronized void return Log Cursor ( Log Cursor log Cursor ) { log Cursor . set Loaned ( BOOL ) ; }
@ Nullable public Pki Verification Data verify Pki ( ) { return pki Verification Data ; }
public synchronized void clear Screen Messages ( ) { talogging . set Text ( STRING ) ; }
public synchronized void clear Screen Messages ( ) { talogging . set Text ( STRING ) ; }
public long length ( byte [ ] id ) { Byte Buffer id Buffer = Byte Buffer . wrap ( id ) ; long length = NUM ; while ( id Buffer . has Remaining ( ) ) { switch ( id Buffer . get ( ) ) { case NUM : int len = Data Utils . read Var Int ( id Buffer ) ; id Buffer . position ( id Buffer . position ( ) + len ) ; length += len ; break ; case NUM : length += Data Utils . read Var Int ( id Buffer ) ; Data Utils . read Var Long ( id Buffer ) ; break ; case NUM : length += Data Utils . read Var Long ( id Buffer ) ; Data Utils . read Var Long ( id Buffer ) ; break ; default : throw Data Utils . new Illegal Argument Exception ( STRING , Arrays . to String ( id ) ) ; } } return length ; }
public static Remote export Object ( Remote obj ) throws Remote Exception { int port = NUM ; port += Randomness . next Int ( NUM ) ; final int TRIES = NUM ; for ( int i = NUM ; i < TRIES ; i ++ ) { try { int candidate Port = port + i ; return Unicast Remote Object . export Object ( obj , candidate Port ) ; } catch ( Remote Exception e ) { } } return Unicast Remote Object . export Object ( obj , port ) ; }
public static Remote export Object ( Remote obj ) throws Remote Exception { int port = NUM ; port += Randomness . next Int ( NUM ) ; final int TRIES = NUM ; for ( int i = NUM ; i < TRIES ; i ++ ) { try { int candidate Port = port + i ; return Unicast Remote Object . export Object ( obj , candidate Port ) ; } catch ( Remote Exception e ) { } } return Unicast Remote Object . export Object ( obj , port ) ; }
public static Remote export Object ( Remote obj ) throws Remote Exception { int port = NUM ; port += Randomness . next Int ( NUM ) ; final int TRIES = NUM ; for ( int i = NUM ; i < TRIES ; i ++ ) { try { int candidate Port = port + i ; return Unicast Remote Object . export Object ( obj , candidate Port ) ; } catch ( Remote Exception e ) { } } return Unicast Remote Object . export Object ( obj , port ) ; }
public static Remote export Object ( Remote obj ) throws Remote Exception { int port = NUM ; port += Randomness . next Int ( NUM ) ; final int TRIES = NUM ; for ( int i = NUM ; i < TRIES ; i ++ ) { try { int candidate Port = port + i ; return Unicast Remote Object . export Object ( obj , candidate Port ) ; } catch ( Remote Exception e ) { } } return Unicast Remote Object . export Object ( obj , port ) ; }
public static Remote export Object ( Remote obj ) throws Remote Exception { int port = NUM ; port += Randomness . next Int ( NUM ) ; final int TRIES = NUM ; for ( int i = NUM ; i < TRIES ; i ++ ) { try { int candidate Port = port + i ; return Unicast Remote Object . export Object ( obj , candidate Port ) ; } catch ( Remote Exception e ) { } } return Unicast Remote Object . export Object ( obj , port ) ; }
public static Remote export Object ( Remote obj ) throws Remote Exception { int port = NUM ; port += Randomness . next Int ( NUM ) ; final int TRIES = NUM ; for ( int i = NUM ; i < TRIES ; i ++ ) { try { int candidate Port = port + i ; return Unicast Remote Object . export Object ( obj , candidate Port ) ; } catch ( Remote Exception e ) { } } return Unicast Remote Object . export Object ( obj , port ) ; }
public static void write ( File file , Char Sequence data ) throws IO Exception { write ( file , data , Charset . default Charset ( ) , BOOL ) ; }
public static void write ( File file , Char Sequence data ) throws IO Exception { write ( file , data , Charset . default Charset ( ) , BOOL ) ; }
public static void write ( File file , Char Sequence data ) throws IO Exception { write ( file , data , Charset . default Charset ( ) , BOOL ) ; }
public static void write ( File file , Char Sequence data ) throws IO Exception { write ( file , data , Charset . default Charset ( ) , BOOL ) ; }
public static void write ( File file , Char Sequence data ) throws IO Exception { write ( file , data , Charset . default Charset ( ) , BOOL ) ; }
public static String multiply ( Char Sequence self , Number factor ) { int size = factor . int Value ( ) ; if ( size == NUM ) return STRING ; else if ( size < NUM ) { throw new Illegal Argument Exception ( STRING + size ) ; } String Builder answer = new String Builder ( self ) ; for ( int i = NUM ; i < size ; i ++ ) { answer . append ( self ) ; } return answer . to String ( ) ; }
public static String encode Java Opts ( String java Opts ) { String java Opts Base 64 = Datatype Converter . print Base 64 Binary ( java Opts . get Bytes ( Charset . for Name ( STRING ) ) ) ; return String . format ( STRING , java Opts Base 64 . replace ( STRING , STRING ) ) ; }
public static < T > boolean contains Duplicates ( List < T > list , Comparator < T > comparator ) { Collections . sort ( list , comparator ) ; T previous = null ; for ( T entry : list ) { if ( previous != null && previous . equals ( entry ) ) { return BOOL ; } previous = entry ; } return BOOL ; }
public static < T > boolean contains Duplicates ( List < T > list , Comparator < T > comparator ) { Collections . sort ( list , comparator ) ; T previous = null ; for ( T entry : list ) { if ( previous != null && previous . equals ( entry ) ) { return BOOL ; } previous = entry ; } return BOOL ; }
public static < T > boolean contains Duplicates ( List < T > list , Comparator < T > comparator ) { Collections . sort ( list , comparator ) ; T previous = null ; for ( T entry : list ) { if ( previous != null && previous . equals ( entry ) ) { return BOOL ; } previous = entry ; } return BOOL ; }
public static String repeat Character ( char c , int repetitions ) { String Builder s = new String Builder ( repetitions ) ; for ( int i = NUM ; i < repetitions ; i ++ ) { s . append ( c ) ; } return s . to String ( ) ; }
@ Override public List < Period > generate Last 5 Years ( Date date ) { Calendar calendar = get Calendar ( ) ; Date Time Unit date Time Unit = create Local Date Unit Instance ( date ) ; date Time Unit = calendar . minus Years ( date Time Unit , NUM ) ; date Time Unit . set Day ( NUM ) ; date Time Unit . set Month ( NUM ) ; List < Period > periods = Lists . new Array List ( ) ; for ( int i = NUM ; i < NUM ; ++ i ) { periods . add ( create Period ( date Time Unit , calendar ) ) ; date Time Unit = calendar . plus Years ( date Time Unit , NUM ) ; } return periods ; }
@ Override public List < Period > generate Last 5 Years ( Date date ) { Calendar calendar = get Calendar ( ) ; Date Time Unit date Time Unit = create Local Date Unit Instance ( date ) ; date Time Unit = calendar . minus Years ( date Time Unit , NUM ) ; date Time Unit . set Day ( NUM ) ; date Time Unit . set Month ( NUM ) ; List < Period > periods = Lists . new Array List ( ) ; for ( int i = NUM ; i < NUM ; ++ i ) { periods . add ( create Period ( date Time Unit , calendar ) ) ; date Time Unit = calendar . plus Years ( date Time Unit , NUM ) ; } return periods ; }
public void update Parameters From ( SQ Lite Database Configuration other ) { if ( other == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( ! path . equals ( other . path ) ) { throw new Illegal Argument Exception ( STRING + STRING ) ; } open Flags = other . open Flags ; max Sql Cache Size = other . max Sql Cache Size ; locale = other . locale ; foreign Key Constraints Enabled = other . foreign Key Constraints Enabled ; custom Functions . clear ( ) ; custom Functions . add All ( other . custom Functions ) ; }
public String to String ( Object obj ) { return obj . to String ( ) ; }
@ Override public void add Property Change Listener ( String property Name , Property Change Listener listener ) { property Change Support . add Property Change Listener ( property Name , listener ) ; }
@ Override public void write ( Buffer buffer , boolean is End ) throws IO Exception { if ( s == null ) { buffer . free ( ) ; return ; } try { needs Flush = BOOL ; if ( buffer . is Direct ( ) ) { total Write Bytes += buffer . length ( ) ; s . write ( buffer . direct ( ) ) ; return ; } total Write Bytes += buffer . length ( ) ; while ( buffer . length ( ) > NUM ) { write Buffer . clear ( ) ; buffer . read ( write Buffer ) ; write Buffer . flip ( ) ; s . write ( write Buffer ) ; } } catch ( IO Exception e ) { IO Exception exn = Client Disconnect Exception . create ( this + STRING + e , e ) ; try { close ( ) ; } catch ( IO Exception e1 ) { } throw exn ; } finally { buffer . free ( ) ; } }
protected void handle Hover Event ( Event evt ) { if ( evt . get Target ( ) instanceof Element ) { Element e = ( Element ) evt . get Target ( ) ; Node next = e . get Next Sibling ( ) ; if ( next instanceof Element ) { toggle Tooltip ( ( Element ) next , evt . get Type ( ) ) ; } else { Logging Util . warning ( STRING ) ; } } else { Logging Util . warning ( STRING ) ; } }
public void remove App Offer ( Offer offer ) { int index To Remove = get Index ( offer ) ; if ( index To Remove != - NUM ) { app Offers . remove ( index To Remove ) ; notify Data Set Changed ( ) ; } }
public void remove App Offer ( Offer offer ) { int index To Remove = get Index ( offer ) ; if ( index To Remove != - NUM ) { app Offers . remove ( index To Remove ) ; notify Data Set Changed ( ) ; } }
public static void pipe All ( Input Stream in Str , Output Stream out Str ) throws IO Exception { byte [ ] bs = new byte [ BUFFER SIZE ] ; int num Read ; while ( ( num Read = in Str . read ( bs , NUM , bs . length ) ) >= NUM ) { out Str . write ( bs , NUM , num Read ) ; } }
public static Vector 3 ceil ( Vector 3 o ) { return new Vector 3 ( Math . ceil ( o . x ) , Math . ceil ( o . y ) , Math . ceil ( o . z ) ) ; }
public static Character to Character ( Object o , Character default Value ) { if ( o instanceof Character ) return ( Character ) o ; if ( default Value != null ) return new Character ( to Char Value ( o , default Value . char Value ( ) ) ) ; char res = to Char Value ( o , Character . MIN VALUE ) ; if ( res == Character . MIN VALUE ) return default Value ; return new Character ( res ) ; }
public static Character to Character ( Object o , Character default Value ) { if ( o instanceof Character ) return ( Character ) o ; if ( default Value != null ) return new Character ( to Char Value ( o , default Value . char Value ( ) ) ) ; char res = to Char Value ( o , Character . MIN VALUE ) ; if ( res == Character . MIN VALUE ) return default Value ; return new Character ( res ) ; }
public Transferable Data Item ( Node Interface destination Tree Node , Tree Path path ) { if ( ( destination Tree Node != null ) && ( path != null ) ) { Map < Node Interface , Tree Path > selected Data = new Linked Hash Map < Node Interface , Tree Path > ( ) ; selected Data . put ( destination Tree Node , path ) ; internal Populate ( selected Data ) ; } }
private synchronized void pause Track Data Hub ( ) { if ( track Data Hub != null ) { track Data Hub . unregister Track Data Listener ( this ) ; } track Data Hub = null ; }
public static String [ ] concatenate String Arrays ( String [ ] array 1 , String [ ] array 2 ) { if ( Object Utils . is Empty ( array 1 ) ) { return array 2 ; } if ( Object Utils . is Empty ( array 2 ) ) { return array 1 ; } String [ ] new Arr = new String [ array 1 . length + array 2 . length ] ; System . arraycopy ( array 1 , NUM , new Arr , NUM , array 1 . length ) ; System . arraycopy ( array 2 , NUM , new Arr , array 1 . length , array 2 . length ) ; return new Arr ; }
public static String [ ] concatenate String Arrays ( String [ ] array 1 , String [ ] array 2 ) { if ( Object Utils . is Empty ( array 1 ) ) { return array 2 ; } if ( Object Utils . is Empty ( array 2 ) ) { return array 1 ; } String [ ] new Arr = new String [ array 1 . length + array 2 . length ] ; System . arraycopy ( array 1 , NUM , new Arr , NUM , array 1 . length ) ; System . arraycopy ( array 2 , NUM , new Arr , array 1 . length , array 2 . length ) ; return new Arr ; }
private static boolean caseless Compare ( char a , char b ) { return Character . to Lower Case ( a ) == Character . to Lower Case ( b ) ; }
public void start ( ) { if ( SHOW LOGS ) Logger . v ( TAG , STRING ) ; synchronized ( m State ) { if ( SHOW LOGS ) Logger . v ( TAG , STRING + m State ) ; switch ( m State . get ( ) ) { case IDLE : case INITIALIZED : case PREPARING : case STARTED : throw new Illegal State Exception ( STRING + m State ) ; case STOPPED : case PLAYBACK COMPLETED : case PREPARED : case PAUSED : if ( SHOW LOGS ) Logger . v ( TAG , STRING + m State + STRING ) ; m Media Player . start ( ) ; start Position Update Notifier ( ) ; m State . set ( State . STARTED ) ; break ; case ERROR : case END : throw new Illegal State Exception ( STRING + m State ) ; } } if ( SHOW LOGS ) Logger . v ( TAG , STRING ) ; }
public void start ( ) { if ( SHOW LOGS ) Logger . v ( TAG , STRING ) ; synchronized ( m State ) { if ( SHOW LOGS ) Logger . v ( TAG , STRING + m State ) ; switch ( m State . get ( ) ) { case IDLE : case INITIALIZED : case PREPARING : case STARTED : throw new Illegal State Exception ( STRING + m State ) ; case STOPPED : case PLAYBACK COMPLETED : case PREPARED : case PAUSED : if ( SHOW LOGS ) Logger . v ( TAG , STRING + m State + STRING ) ; m Media Player . start ( ) ; start Position Update Notifier ( ) ; m State . set ( State . STARTED ) ; break ; case ERROR : case END : throw new Illegal State Exception ( STRING + m State ) ; } } if ( SHOW LOGS ) Logger . v ( TAG , STRING ) ; }
public void start ( ) { if ( SHOW LOGS ) Logger . v ( TAG , STRING ) ; synchronized ( m State ) { if ( SHOW LOGS ) Logger . v ( TAG , STRING + m State ) ; switch ( m State . get ( ) ) { case IDLE : case INITIALIZED : case PREPARING : case STARTED : throw new Illegal State Exception ( STRING + m State ) ; case STOPPED : case PLAYBACK COMPLETED : case PREPARED : case PAUSED : if ( SHOW LOGS ) Logger . v ( TAG , STRING + m State + STRING ) ; m Media Player . start ( ) ; start Position Update Notifier ( ) ; m State . set ( State . STARTED ) ; break ; case ERROR : case END : throw new Illegal State Exception ( STRING + m State ) ; } } if ( SHOW LOGS ) Logger . v ( TAG , STRING ) ; }
private void remove All Hotkeys ( ) { remove Hotkeys ( main . get Root Pane ( ) ) ; for ( J Dialog popout : popouts . key Set ( ) ) { remove Hotkeys ( popout . get Root Pane ( ) ) ; } remove Global Hotkeys ( ) ; remove Hotkeys From Actions ( ) ; }
public void write ( char chars [ ] , int start , int length ) throws java . io . IO Exception { int n = length + start ; for ( int i = start ; i < n ; i ++ ) { m os . write ( chars [ i ] ) ; } }
static char process Char Literal ( String entity ) throws IO Exception , XML Parse Exception { if ( entity . char At ( NUM ) == STRING ) { entity = entity . substring ( NUM , entity . length ( ) - NUM ) ; return ( char ) Integer . parse Int ( entity , NUM ) ; } else { entity = entity . substring ( NUM , entity . length ( ) - NUM ) ; return ( char ) Integer . parse Int ( entity , NUM ) ; } }
protected boolean parse Line Internal ( ) { int i = NUM ; for ( ; tokenizer . valid ( ) ; tokenizer . advance ( ) , i ++ ) { if ( ! is Label Column ( i ) && ! tokenizer . is Quoted ( ) ) { try { attributes . add ( tokenizer . get Double ( ) ) ; continue ; } catch ( Number Format Exception e ) { } } String lbl = tokenizer . get Stripped Substring ( ) ; if ( lbl . length ( ) > NUM ) { haslabels = BOOL ; lbl = unique . add Or Get ( lbl ) ; labels . add ( lbl ) ; } } if ( curvec == null && attributes . size == NUM ) { columnnames = new Array List < > ( labels ) ; haslabels = BOOL ; curvec = null ; curlbl = null ; labels . clear ( ) ; return BOOL ; } curvec = create Vector ( ) ; curlbl = Label List . make ( labels ) ; attributes . clear ( ) ; labels . clear ( ) ; return BOOL ; }
public void add ( Schedulable Event event ) { synchronized ( lock ) { Fast Event Queue list = m Event Buffer . get ( event . get Timestamp ( ) ) ; if ( list == null ) { long lowest Time = m Event Buffer . is Empty ( ) ? Long . MAX VALUE : m Event Buffer . first Key ( ) ; list = new Fast Event Queue ( event ) ; m Event Buffer . put ( event . get Timestamp ( ) , list ) ; if ( event . get Timestamp ( ) < lowest Time ) { lock . notify ( ) ; } } else { list . add ( event ) ; } } }
public Mersenne Twister RNG ( final byte [ ] seed ) { if ( seed == null || seed . length != SEED SIZE BYTES ) { throw new Illegal Argument Exception ( STRING ) ; } this . seed = seed . clone ( ) ; final int [ ] seed Ints = convert Bytes To Ints ( this . seed ) ; mt [ NUM ] = BOOTSTRAP SEED ; for ( mt Index = NUM ; mt Index < N ; mt Index ++ ) { mt [ mt Index ] = BOOTSTRAP FACTOR * ( mt [ mt Index - NUM ] ^ mt [ mt Index - NUM ] > > > NUM ) + mt Index ; } int i = NUM ; int j = NUM ; for ( int k = Math . max ( N , seed Ints . length ) ; k > NUM ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( mt [ i - NUM ] ^ mt [ i - NUM ] > > > NUM ) * SEED FACTOR 1 ) + seed Ints [ j ] + j ; i ++ ; j ++ ; if ( i >= N ) { mt [ NUM ] = mt [ N - NUM ] ; i = NUM ; } if ( j >= seed Ints . length ) { j = NUM ; } } for ( int k = N - NUM ; k > NUM ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( mt [ i - NUM ] ^ mt [ i - NUM ] > > > NUM ) * SEED FACTOR 2 ) - i ; i ++ ; if ( i >= N ) { mt [ NUM ] = mt [ N - NUM ] ; i = NUM ; } } mt [ NUM ] = UPPER MASK ; }
public static synchronized void init ( Configuration conf ) { String server = conf . get String ( STRING , X . EMPTY ) ; if ( server . starts With ( MEMCACHED ) ) { cache System = Mem Cache . create ( conf ) ; } else if ( server . starts With ( REDIS ) ) { cache System = Redis Cache . create ( conf ) ; } else { log . debug ( STRING ) ; cache System = File Cache . create ( conf ) ; } GROUP = conf . get String ( STRING , STRING ) + STRING ; }
public static synchronized void init ( Configuration conf ) { String server = conf . get String ( STRING , X . EMPTY ) ; if ( server . starts With ( MEMCACHED ) ) { cache System = Mem Cache . create ( conf ) ; } else if ( server . starts With ( REDIS ) ) { cache System = Redis Cache . create ( conf ) ; } else { log . debug ( STRING ) ; cache System = File Cache . create ( conf ) ; } GROUP = conf . get String ( STRING , STRING ) + STRING ; }
public Char Buffer ( String string , int offset , int length ) { int capacity = Math . max ( length , MIN CAPACITY ) ; init ( new char [ capacity ] , NUM , length ) ; string . get Chars ( offset , length , buffer ( ) , NUM ) ; }
public Properties read Settings ( ) { Properties result = new Properties ( ) ; result . set Property ( this . http Env , this . http Proxy ) ; result . set Property ( this . https Env , this . https Proxy ) ; result . set Property ( this . ftp Env , this . ftp Proxy ) ; result . set Property ( this . no Proxy Env , this . no Proxy ) ; return result ; }
public Properties read Settings ( ) { Properties result = new Properties ( ) ; result . set Property ( this . http Env , this . http Proxy ) ; result . set Property ( this . https Env , this . https Proxy ) ; result . set Property ( this . ftp Env , this . ftp Proxy ) ; result . set Property ( this . no Proxy Env , this . no Proxy ) ; return result ; }
public static < U extends Object , S extends Service < U > > boolean launch Service By Class ( Class < ? extends S > c , U user , Frame owner ) { boolean success = BOOL ; S ret = null ; for ( Service < ? > s : SERVICE TO USER MAP . key Set ( ) ) { if ( c . is Instance ( s ) ) { s . pull To Front ( ) ; return BOOL ; } } try { ret = c . new Instance ( ) ; SERVICE TO USER MAP . put ( ret , user ) ; ret . setup GUI ( owner ) ; ret . launch ( ) ; success = BOOL ; } catch ( Instantiation Exception | Illegal Access Exception e ) { LOG . severe ( STRING + e . get Message ( ) ) ; } return success ; }
public static final java . lang . String read UTF ( java . io . Data Input in ) throws java . io . IO Exception { return decode UTF ( in . read Unsigned Short ( ) , in ) ; }
public static final java . lang . String read UTF ( java . io . Data Input in ) throws java . io . IO Exception { return decode UTF ( in . read Unsigned Short ( ) , in ) ; }
static void remove So If Exit ( String lib Name , int version ) { String file = target So File ( lib Name , version ) ; File a = new File ( file ) ; if ( a . exists ( ) ) { a . delete ( ) ; } }
public static final Object [ ] resize ( Object [ ] a , int size ) { if ( a . length >= size ) return a ; Object [ ] b = new Object [ size ] ; System . arraycopy ( a , NUM , b , NUM , a . length ) ; return b ; }
public static final Object [ ] resize ( Object [ ] a , int size ) { if ( a . length >= size ) return a ; Object [ ] b = new Object [ size ] ; System . arraycopy ( a , NUM , b , NUM , a . length ) ; return b ; }
public void add Observer ( Notification Observer observer ) { observers . add ( observer ) ; }
public Char Seq replace First ( String regex , String replacement ) { return Char Seq . of ( str . replace First ( regex , replacement ) ) ; }
public Char Seq replace First ( String regex , String replacement ) { return Char Seq . of ( str . replace First ( regex , replacement ) ) ; }
public static Cert Chain Key Pair generate Signed For Client ( String fqdn , X509 Certificate issuer Certificate , Private Key issuer Private Key ) { try { return generate Certificate And Sign ( fqdn , issuer Certificate , issuer Private Key , get Client Extensions ( ) ) ; } catch ( Cert IO Exception | Certificate Exception | Operator Creation Exception e ) { throw new Runtime Exception ( String . format ( STRING , e . get Message ( ) ) , e ) ; } }
public static String create Selector From Address ( String address ) { String Builder string Builder = new String Builder ( ) ; if ( ! address . contains ( STRING ) ) { if ( address . starts With ( STRING ) ) { string Builder . append ( Management Helper . HDR ADDRESS + STRING + address . substring ( NUM , address . length ( ) ) + STRING ) ; } else { string Builder . append ( Management Helper . HDR ADDRESS + STRING + address + STRING ) ; } return string Builder . to String ( ) ; } return build Selector From Array ( address . split ( STRING ) ) ; }
public static String create Selector From Address ( String address ) { String Builder string Builder = new String Builder ( ) ; if ( ! address . contains ( STRING ) ) { if ( address . starts With ( STRING ) ) { string Builder . append ( Management Helper . HDR ADDRESS + STRING + address . substring ( NUM , address . length ( ) ) + STRING ) ; } else { string Builder . append ( Management Helper . HDR ADDRESS + STRING + address + STRING ) ; } return string Builder . to String ( ) ; } return build Selector From Array ( address . split ( STRING ) ) ; }
public Connect Uri Manager ( List < String > connect Uri ) throws THL Exception { this . uri List = connect Uri ; if ( connect Uri . size ( ) == NUM ) { throw new THL Exception ( STRING ) ; } }
public boolean create XML ( Stream Result result ) { try { DOM Source source = new DOM Source ( get Document ( ) ) ; Transformer Factory t Factory = Transformer Factory . new Instance ( ) ; Transformer transformer = t Factory . new Transformer ( ) ; transformer . set Output Property ( Output Keys . ENCODING , STRING ) ; transformer . set Output Property ( Output Keys . INDENT , STRING ) ; transformer . transform ( source , result ) ; } catch ( Exception e ) { log . log ( Level . SEVERE , STRING , e ) ; return BOOL ; } return BOOL ; }
public boolean create XML ( Stream Result result ) { try { DOM Source source = new DOM Source ( get Document ( ) ) ; Transformer Factory t Factory = Transformer Factory . new Instance ( ) ; Transformer transformer = t Factory . new Transformer ( ) ; transformer . set Output Property ( Output Keys . ENCODING , STRING ) ; transformer . set Output Property ( Output Keys . INDENT , STRING ) ; transformer . transform ( source , result ) ; } catch ( Exception e ) { log . log ( Level . SEVERE , STRING , e ) ; return BOOL ; } return BOOL ; }
protected Class < Druid Query Builder > build Druid Query Builder ( ) { return Druid Query Builder . class ; }
protected Class < Druid Query Builder > build Druid Query Builder ( ) { return Druid Query Builder . class ; }
protected void init Batch Buffer ( ) { try { if ( ! is Incremental ( ) ) { m Batch Buffer = m Loader . get Data Set ( ) ; } else { m Batch Buffer = null ; } } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
private static byte [ ] lm Response ( byte [ ] hash , byte [ ] challenge ) throws Exception { byte [ ] key Bytes = new byte [ NUM ] ; System . arraycopy ( hash , NUM , key Bytes , NUM , NUM ) ; Key low Key = create DES Key ( key Bytes , NUM ) ; Key middle Key = create DES Key ( key Bytes , NUM ) ; Key high Key = create DES Key ( key Bytes , NUM ) ; Cipher des = Cipher . get Instance ( STRING ) ; des . init ( Cipher . ENCRYPT MODE , low Key ) ; byte [ ] low Response = des . do Final ( challenge ) ; des . init ( Cipher . ENCRYPT MODE , middle Key ) ; byte [ ] middle Response = des . do Final ( challenge ) ; des . init ( Cipher . ENCRYPT MODE , high Key ) ; byte [ ] high Response = des . do Final ( challenge ) ; byte [ ] lm Response = new byte [ NUM ] ; System . arraycopy ( low Response , NUM , lm Response , NUM , NUM ) ; System . arraycopy ( middle Response , NUM , lm Response , NUM , NUM ) ; System . arraycopy ( high Response , NUM , lm Response , NUM , NUM ) ; return lm Response ; }
public boolean read Boolean ( ) throws IO Exception { return primitive Types . read Boolean ( ) ; }
protected void print Identifier ( String identifier , String Builder ddl ) { ddl . append ( get Delimited Identifier ( identifier ) ) ; }
public void install Linear Models ( ) throws Exception { Evaluation node Model Eval ; if ( m is Leaf ) { build Linear Model ( m indices ) ; } else { if ( m left != null ) { m left . install Linear Models ( ) ; } if ( m right != null ) { m right . install Linear Models ( ) ; } build Linear Model ( m indices ) ; } node Model Eval = new Evaluation ( m instances ) ; node Model Eval . evaluate Model ( m node Model , m instances ) ; m root Mean Squared Error = node Model Eval . root Mean Squared Error ( ) ; if ( ! m save Instances ) { m instances = new Instances ( m instances , NUM ) ; } }
public void install Linear Models ( ) throws Exception { Evaluation node Model Eval ; if ( m is Leaf ) { build Linear Model ( m indices ) ; } else { if ( m left != null ) { m left . install Linear Models ( ) ; } if ( m right != null ) { m right . install Linear Models ( ) ; } build Linear Model ( m indices ) ; } node Model Eval = new Evaluation ( m instances ) ; node Model Eval . evaluate Model ( m node Model , m instances ) ; m root Mean Squared Error = node Model Eval . root Mean Squared Error ( ) ; if ( ! m save Instances ) { m instances = new Instances ( m instances , NUM ) ; } }
public void install Linear Models ( ) throws Exception { Evaluation node Model Eval ; if ( m is Leaf ) { build Linear Model ( m indices ) ; } else { if ( m left != null ) { m left . install Linear Models ( ) ; } if ( m right != null ) { m right . install Linear Models ( ) ; } build Linear Model ( m indices ) ; } node Model Eval = new Evaluation ( m instances ) ; node Model Eval . evaluate Model ( m node Model , m instances ) ; m root Mean Squared Error = node Model Eval . root Mean Squared Error ( ) ; if ( ! m save Instances ) { m instances = new Instances ( m instances , NUM ) ; } }
public void install Linear Models ( ) throws Exception { Evaluation node Model Eval ; if ( m is Leaf ) { build Linear Model ( m indices ) ; } else { if ( m left != null ) { m left . install Linear Models ( ) ; } if ( m right != null ) { m right . install Linear Models ( ) ; } build Linear Model ( m indices ) ; } node Model Eval = new Evaluation ( m instances ) ; node Model Eval . evaluate Model ( m node Model , m instances ) ; m root Mean Squared Error = node Model Eval . root Mean Squared Error ( ) ; if ( ! m save Instances ) { m instances = new Instances ( m instances , NUM ) ; } }
public void install Linear Models ( ) throws Exception { Evaluation node Model Eval ; if ( m is Leaf ) { build Linear Model ( m indices ) ; } else { if ( m left != null ) { m left . install Linear Models ( ) ; } if ( m right != null ) { m right . install Linear Models ( ) ; } build Linear Model ( m indices ) ; } node Model Eval = new Evaluation ( m instances ) ; node Model Eval . evaluate Model ( m node Model , m instances ) ; m root Mean Squared Error = node Model Eval . root Mean Squared Error ( ) ; if ( ! m save Instances ) { m instances = new Instances ( m instances , NUM ) ; } }
public void install Linear Models ( ) throws Exception { Evaluation node Model Eval ; if ( m is Leaf ) { build Linear Model ( m indices ) ; } else { if ( m left != null ) { m left . install Linear Models ( ) ; } if ( m right != null ) { m right . install Linear Models ( ) ; } build Linear Model ( m indices ) ; } node Model Eval = new Evaluation ( m instances ) ; node Model Eval . evaluate Model ( m node Model , m instances ) ; m root Mean Squared Error = node Model Eval . root Mean Squared Error ( ) ; if ( ! m save Instances ) { m instances = new Instances ( m instances , NUM ) ; } }
public static String create Handler Request Path ( final Cache Key cache Key , final Http Servlet Request request ) { final String handler Query Path = get Request Handler Path ( cache Key . get Group Name ( ) , cache Key . get Type ( ) ) ; return request . get Servlet Path ( ) + handler Query Path ; }
public static String create Handler Request Path ( final Cache Key cache Key , final Http Servlet Request request ) { final String handler Query Path = get Request Handler Path ( cache Key . get Group Name ( ) , cache Key . get Type ( ) ) ; return request . get Servlet Path ( ) + handler Query Path ; }
public static String create Handler Request Path ( final Cache Key cache Key , final Http Servlet Request request ) { final String handler Query Path = get Request Handler Path ( cache Key . get Group Name ( ) , cache Key . get Type ( ) ) ; return request . get Servlet Path ( ) + handler Query Path ; }
public static boolean is Windows 7 ( ) { return os Name . index Of ( STRING ) > - NUM && os Version . equals ( STRING ) ; }
public Buffered Image create Compatible Image ( int width , int height ) { Writable Raster wr = raster . create Compatible Writable Raster ( width , height ) ; return new Buffered Image ( model , wr , model . is Alpha Premultiplied ( ) , null ) ; }
public Buffered Image create Compatible Image ( int width , int height ) { Writable Raster wr = raster . create Compatible Writable Raster ( width , height ) ; return new Buffered Image ( model , wr , model . is Alpha Premultiplied ( ) , null ) ; }
public Buffered Image create Compatible Image ( int width , int height ) { Writable Raster wr = raster . create Compatible Writable Raster ( width , height ) ; return new Buffered Image ( model , wr , model . is Alpha Premultiplied ( ) , null ) ; }
public Buffered Image create Compatible Image ( int width , int height ) { Writable Raster wr = raster . create Compatible Writable Raster ( width , height ) ; return new Buffered Image ( model , wr , model . is Alpha Premultiplied ( ) , null ) ; }
public boolean add All ( int index , Collection < ? extends E > c ) { range Check For Add ( index ) ; Object [ ] a = c . to Array ( ) ; int num New = a . length ; ensure Capacity ( size + num New ) ; int num Moved = size - index ; if ( num Moved > NUM ) { System . arraycopy ( element Data , index , element Data , index + num New , num Moved ) ; } System . arraycopy ( a , NUM , element Data , index , num New ) ; size += num New ; return num New != NUM ; }
public boolean add All ( int index , Collection < ? extends E > c ) { range Check For Add ( index ) ; Object [ ] a = c . to Array ( ) ; int num New = a . length ; ensure Capacity ( size + num New ) ; int num Moved = size - index ; if ( num Moved > NUM ) { System . arraycopy ( element Data , index , element Data , index + num New , num Moved ) ; } System . arraycopy ( a , NUM , element Data , index , num New ) ; size += num New ; return num New != NUM ; }
public boolean add All ( int index , Collection < ? extends E > c ) { range Check For Add ( index ) ; Object [ ] a = c . to Array ( ) ; int num New = a . length ; ensure Capacity ( size + num New ) ; int num Moved = size - index ; if ( num Moved > NUM ) { System . arraycopy ( element Data , index , element Data , index + num New , num Moved ) ; } System . arraycopy ( a , NUM , element Data , index , num New ) ; size += num New ; return num New != NUM ; }
@ Override public byte [ ] first Token ( ) { return one Token ; }
public static boolean load Native Library ( ) { try { Log . i ( TAG , STRING + LIBRARY NAME ) ; System . load Library ( STRING ) ; System . load Library ( LIBRARY NAME ) ; } catch ( Exception e ) { Log . e ( TAG , STRING + e . to String ( ) ) ; return BOOL ; } return BOOL ; }
default Value remove ( Optional < ? extends Char Sequence > name ) { return name . is Present ( ) ? remove ( name . get ( ) ) : null ; }
public E poll ( ) { if ( is Empty ( ) ) { return null ; } E result = elements [ NUM ] ; remove At ( NUM ) ; return result ; }
protected Query finish Query ( Boolean Query . Builder in , boolean all Terms Required ) { return in . build ( ) ; }
protected Query finish Query ( Boolean Query . Builder in , boolean all Terms Required ) { return in . build ( ) ; }
protected Query finish Query ( Boolean Query . Builder in , boolean all Terms Required ) { return in . build ( ) ; }
protected Query finish Query ( Boolean Query . Builder in , boolean all Terms Required ) { return in . build ( ) ; }
public VS Decoder Pane ( VS Decoder Frame p ) { super ( ) ; parent = p ; decoder mgr = VS Decoder Manager . instance ( ) ; }
public Bit Vector ( Bit Vector s ) { bits = new int [ s . bits . length ] ; this . nbits = s . nbits ; System . arraycopy ( s . bits , NUM , this . bits , NUM , s . bits . length ) ; }
private void fire Event ( final I Running Query q ) { if ( q == null ) throw new Illegal Argument Exception ( ) ; if ( listeners . is Empty ( ) ) { return ; } final I Running Query Listener [ ] a = listeners . to Array ( new I Running Query Listener [ NUM ] ) ; for ( I Running Query Listener l : a ) { final I Running Query Listener listener = l ; try { listener . notify ( q ) ; } catch ( Throwable t ) { if ( Inner Cause . is Inner Cause ( t , Interrupted Exception . class ) ) { throw new Runtime Exception ( t ) ; } log . error ( t , t ) ; } } }
public static Multisig Aggregate Modification Transaction create Multisig Modification ( ) { return new Multisig Aggregate Modification Transaction ( Time Instant . ZERO , Utils . generate Random Account ( ) , Collections . singleton List ( new Multisig Cosignatory Modification ( Multisig Modification Type . Add Cosignatory , Utils . generate Random Account ( ) ) ) ) ; }
private static Double read Amf Double ( Parsable Byte Array data ) { return Double . long Bits To Double ( data . read Long ( ) ) ; }
@ Override public void init ( int mode , Key key , Algorithm Parameter Spec params ) throws Invalid Key Exception , Invalid Algorithm Parameter Exception { Utils . check Not Null ( key ) ; Utils . check Not Null ( params ) ; cipher . init ( mode , key , params ) ; }
@ Override public void init ( int mode , Key key , Algorithm Parameter Spec params ) throws Invalid Key Exception , Invalid Algorithm Parameter Exception { Utils . check Not Null ( key ) ; Utils . check Not Null ( params ) ; cipher . init ( mode , key , params ) ; }
public static Geo Time Serie fillticks ( Geo Time Serie gts , long location , long elevation , Object value , long [ ] ticks ) { Geo Time Serie filled = gts . clone ( ) ; if ( null == value || GTS Helper . is Bucketized ( filled ) ) { return filled ; } long [ ] gticks = filled . values > NUM ? Arrays . copy Of ( filled . ticks , filled . values ) : new long [ NUM ] ; Arrays . sort ( gticks ) ; Arrays . sort ( ticks ) ; int gtsidx = NUM ; int tickidx = NUM ; int nvalues = filled . values ; while ( gtsidx < nvalues ) { long tick = gticks [ gtsidx ] ; while ( tickidx < ticks . length && ticks [ tickidx ] < tick ) { GTS Helper . set Value ( filled , ticks [ tickidx ] , location , elevation , value , BOOL ) ; tickidx ++ ; } gtsidx ++ ; } while ( tickidx < ticks . length ) { GTS Helper . set Value ( filled , ticks [ tickidx ] , location , elevation , value , BOOL ) ; tickidx ++ ; } return filled ; }
public static boolean is Distributed Cache Used ( String str ) { String [ ] parts = str . split ( Instruction . INSTRUCTION DELIM ) ; for ( String inst : parts ) { String opcode = get Op Code ( inst ) ; if ( opcode . equals Ignore Case ( Append M . OPCODE ) || opcode . equals Ignore Case ( Map Mult . OPCODE ) || opcode . equals Ignore Case ( Map Mult Chain . OPCODE ) || opcode . equals Ignore Case ( PMMJ . OPCODE ) || opcode . equals Ignore Case ( U Agg Outer Chain . OPCODE ) || opcode . equals Ignore Case ( Grouped Aggregate M . OPCODE ) || is Dist Quaternary Opcode ( opcode ) || Binary M . is Opcode ( opcode ) ) { return BOOL ; } } return BOOL ; }
public static boolean is Distributed Cache Used ( String str ) { String [ ] parts = str . split ( Instruction . INSTRUCTION DELIM ) ; for ( String inst : parts ) { String opcode = get Op Code ( inst ) ; if ( opcode . equals Ignore Case ( Append M . OPCODE ) || opcode . equals Ignore Case ( Map Mult . OPCODE ) || opcode . equals Ignore Case ( Map Mult Chain . OPCODE ) || opcode . equals Ignore Case ( PMMJ . OPCODE ) || opcode . equals Ignore Case ( U Agg Outer Chain . OPCODE ) || opcode . equals Ignore Case ( Grouped Aggregate M . OPCODE ) || is Dist Quaternary Opcode ( opcode ) || Binary M . is Opcode ( opcode ) ) { return BOOL ; } } return BOOL ; }
public Component find By Name ( String name , Component root Component ) { Component c = ( Component ) root Component . get Client Property ( STRING + name + STRING ) ; if ( c == null ) { Container new Root = get Root Ancestor ( root Component ) ; if ( new Root != null && root Component != new Root ) { return find By Name ( name , new Root ) ; } } return c ; }
public Component find By Name ( String name , Component root Component ) { Component c = ( Component ) root Component . get Client Property ( STRING + name + STRING ) ; if ( c == null ) { Container new Root = get Root Ancestor ( root Component ) ; if ( new Root != null && root Component != new Root ) { return find By Name ( name , new Root ) ; } } return c ; }
@ Override public void on Bind View Holder ( Movie View Holder holder , int position ) { Movie movie = movies . get ( position ) ; holder . set Movie ( movie ) ; }
@ Override public void on Bind View Holder ( Movie View Holder holder , int position ) { Movie movie = movies . get ( position ) ; holder . set Movie ( movie ) ; }
public static void show Window ( Window window ) { window . set Visible ( BOOL ) ; if ( window instanceof Frame ) { Frame f = ( Frame ) window ; int state = f . get Extended State ( ) ; if ( ( state & Frame . ICONIFIED ) > NUM ) f . set Extended State ( state & ~ Frame . ICONIFIED ) ; } window . to Front ( ) ; }
@ Override public int hash Code ( ) { return Objects . hash ( id , version , update Site ) ; }
private float calculate Base Page Target Y ( Panel State expanded State ) { if ( ! is Fullscreen Size Panel ( ) ) return NUM ; final float selection Y = m Base Page Selection Y Px * m Px To Dp ; final float expanded Height = get Panel Height From State ( expanded State ) - m Search Bar Padding Top ; final float fullscreen Height = get Fullscreen Height ( ) ; final float available Height = fullscreen Height - expanded Height ; float offset = - selection Y + available Height / NUM ; offset = Math . min ( offset , NUM ) ; if ( m Is Toolbar Showing ) offset -= m Toolbar Height ; offset = Math . max ( offset , - expanded Height ) ; return offset ; }
private float calculate Base Page Target Y ( Panel State expanded State ) { if ( ! is Fullscreen Size Panel ( ) ) return NUM ; final float selection Y = m Base Page Selection Y Px * m Px To Dp ; final float expanded Height = get Panel Height From State ( expanded State ) - m Search Bar Padding Top ; final float fullscreen Height = get Fullscreen Height ( ) ; final float available Height = fullscreen Height - expanded Height ; float offset = - selection Y + available Height / NUM ; offset = Math . min ( offset , NUM ) ; if ( m Is Toolbar Showing ) offset -= m Toolbar Height ; offset = Math . max ( offset , - expanded Height ) ; return offset ; }
private float calculate Base Page Target Y ( Panel State expanded State ) { if ( ! is Fullscreen Size Panel ( ) ) return NUM ; final float selection Y = m Base Page Selection Y Px * m Px To Dp ; final float expanded Height = get Panel Height From State ( expanded State ) - m Search Bar Padding Top ; final float fullscreen Height = get Fullscreen Height ( ) ; final float available Height = fullscreen Height - expanded Height ; float offset = - selection Y + available Height / NUM ; offset = Math . min ( offset , NUM ) ; if ( m Is Toolbar Showing ) offset -= m Toolbar Height ; offset = Math . max ( offset , - expanded Height ) ; return offset ; }
public JOSM Tolerant Fast XML Parser ( Sink sink , XML Stream Reader reader , boolean enable Date Parsing ) { this . sink = sink ; this . enable Date Parsing = enable Date Parsing ; this . reader = reader ; if ( enable Date Parsing ) { timestamp Format = new Xml Timestamp Format ( ) ; } else { Calendar calendar ; calendar = Calendar . get Instance ( ) ; calendar . set ( Calendar . MILLISECOND , NUM ) ; dummy Timestamp Container = new Simple Timestamp Container ( calendar . get Time ( ) ) ; } member Type Parser = new Member Type Parser ( ) ; }
public boolean is Tab Associated With Non Destroyed Activity ( boolean is Incognito , int tab Id ) { List < Weak Reference < Activity > > activities = Application Status . get Running Activities ( ) ; for ( Weak Reference < Activity > ref : activities ) { Activity activity = ref . get ( ) ; if ( activity != null && is Valid Activity ( is Incognito , activity . get Intent ( ) ) && get Tab Id From Intent ( activity . get Intent ( ) ) == tab Id && ! is Activity Destroyed ( activity ) ) { return BOOL ; } } return BOOL ; }
public boolean is Tab Associated With Non Destroyed Activity ( boolean is Incognito , int tab Id ) { List < Weak Reference < Activity > > activities = Application Status . get Running Activities ( ) ; for ( Weak Reference < Activity > ref : activities ) { Activity activity = ref . get ( ) ; if ( activity != null && is Valid Activity ( is Incognito , activity . get Intent ( ) ) && get Tab Id From Intent ( activity . get Intent ( ) ) == tab Id && ! is Activity Destroyed ( activity ) ) { return BOOL ; } } return BOOL ; }
public boolean is Tab Associated With Non Destroyed Activity ( boolean is Incognito , int tab Id ) { List < Weak Reference < Activity > > activities = Application Status . get Running Activities ( ) ; for ( Weak Reference < Activity > ref : activities ) { Activity activity = ref . get ( ) ; if ( activity != null && is Valid Activity ( is Incognito , activity . get Intent ( ) ) && get Tab Id From Intent ( activity . get Intent ( ) ) == tab Id && ! is Activity Destroyed ( activity ) ) { return BOOL ; } } return BOOL ; }
public boolean is Tab Associated With Non Destroyed Activity ( boolean is Incognito , int tab Id ) { List < Weak Reference < Activity > > activities = Application Status . get Running Activities ( ) ; for ( Weak Reference < Activity > ref : activities ) { Activity activity = ref . get ( ) ; if ( activity != null && is Valid Activity ( is Incognito , activity . get Intent ( ) ) && get Tab Id From Intent ( activity . get Intent ( ) ) == tab Id && ! is Activity Destroyed ( activity ) ) { return BOOL ; } } return BOOL ; }
public boolean is Tab Associated With Non Destroyed Activity ( boolean is Incognito , int tab Id ) { List < Weak Reference < Activity > > activities = Application Status . get Running Activities ( ) ; for ( Weak Reference < Activity > ref : activities ) { Activity activity = ref . get ( ) ; if ( activity != null && is Valid Activity ( is Incognito , activity . get Intent ( ) ) && get Tab Id From Intent ( activity . get Intent ( ) ) == tab Id && ! is Activity Destroyed ( activity ) ) { return BOOL ; } } return BOOL ; }
public boolean is Tab Associated With Non Destroyed Activity ( boolean is Incognito , int tab Id ) { List < Weak Reference < Activity > > activities = Application Status . get Running Activities ( ) ; for ( Weak Reference < Activity > ref : activities ) { Activity activity = ref . get ( ) ; if ( activity != null && is Valid Activity ( is Incognito , activity . get Intent ( ) ) && get Tab Id From Intent ( activity . get Intent ( ) ) == tab Id && ! is Activity Destroyed ( activity ) ) { return BOOL ; } } return BOOL ; }
public Byte Interleaved Raster ( Sample Model sample Model , Point origin ) { this ( sample Model , sample Model . create Data Buffer ( ) , new Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
public Byte Interleaved Raster ( Sample Model sample Model , Point origin ) { this ( sample Model , sample Model . create Data Buffer ( ) , new Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
public void apply Outlier Treatment ( double [ ] values ) throws Exception { for ( int i = NUM ; i < m mining Meta . size ( ) ; i ++ ) { Mining Field Meta Info mfi = m mining Meta . get ( i ) ; values [ i ] = mfi . apply Outlier Treatment ( values [ i ] ) ; } }
public void mark Key For Preload ( int idx ) { if ( preload Keys == null ) preload Keys = new Bit Set ( ) ; preload Keys . set ( idx , BOOL ) ; }
@ Override public int read ( char [ ] array , int offset , int length ) { if ( idx >= char Sequence . length ( ) ) { return - NUM ; } if ( array == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( length < NUM || offset < NUM || offset + length > array . length ) { throw new Index Out Of Bounds Exception ( STRING + array . length + STRING + offset + STRING + length ) ; } int count = NUM ; for ( int i = NUM ; i < length ; i ++ ) { int c = read ( ) ; if ( c == - NUM ) { return count ; } array [ offset + i ] = ( char ) c ; count ++ ; } return count ; }
public void write ( Color c , String s ) throws IO Exception { if ( page != null ) { page . set Color ( c ) ; } write ( s ) ; if ( page != null ) { page . set Color ( color ) ; } }
public void write ( Color c , String s ) throws IO Exception { if ( page != null ) { page . set Color ( c ) ; } write ( s ) ; if ( page != null ) { page . set Color ( color ) ; } }
public void write ( Color c , String s ) throws IO Exception { if ( page != null ) { page . set Color ( c ) ; } write ( s ) ; if ( page != null ) { page . set Color ( color ) ; } }
public void write ( Color c , String s ) throws IO Exception { if ( page != null ) { page . set Color ( c ) ; } write ( s ) ; if ( page != null ) { page . set Color ( color ) ; } }
private int adjust For Cache ( final int pointer ) { if ( font Data == null || pointer < offset || pointer >= ( offset + block Size - NUM ) ) { try { font File . seek ( pointer ) ; font Data = new byte [ block Size ] ; font File . read ( font Data ) ; } catch ( final IO Exception e ) { Log Writer . write Log ( STRING + e . get Message ( ) ) ; } offset = pointer ; } return pointer - offset ; }
private int adjust For Cache ( final int pointer ) { if ( font Data == null || pointer < offset || pointer >= ( offset + block Size - NUM ) ) { try { font File . seek ( pointer ) ; font Data = new byte [ block Size ] ; font File . read ( font Data ) ; } catch ( final IO Exception e ) { Log Writer . write Log ( STRING + e . get Message ( ) ) ; } offset = pointer ; } return pointer - offset ; }
public static J Panel create Horizontal Panel ( String title ) { J Panel panel = new J Panel ( ) ; panel . set Layout ( new Grid Layout ( NUM , NUM ) ) ; if ( title != null ) { panel . set Border ( Border Factory . create Titled Border ( Border Factory . create Etched Border ( ) , title ) ) ; } else { panel . set Border ( Border Factory . create Etched Border ( ) ) ; } return panel ; }
public static J Panel create Horizontal Panel ( String title ) { J Panel panel = new J Panel ( ) ; panel . set Layout ( new Grid Layout ( NUM , NUM ) ) ; if ( title != null ) { panel . set Border ( Border Factory . create Titled Border ( Border Factory . create Etched Border ( ) , title ) ) ; } else { panel . set Border ( Border Factory . create Etched Border ( ) ) ; } return panel ; }
public static J Panel create Horizontal Panel ( String title ) { J Panel panel = new J Panel ( ) ; panel . set Layout ( new Grid Layout ( NUM , NUM ) ) ; if ( title != null ) { panel . set Border ( Border Factory . create Titled Border ( Border Factory . create Etched Border ( ) , title ) ) ; } else { panel . set Border ( Border Factory . create Etched Border ( ) ) ; } return panel ; }
protected boolean apply Filter ( Node node , int node Type ) { if ( f Filter != null && ( f What To Show Filter & node Type ) != NUM ) { short code = f Filter . accept Node ( node ) ; switch ( code ) { case Node Filter . FILTER REJECT : case Node Filter . FILTER SKIP : return BOOL ; default : } } return BOOL ; }
public void add To Consolitated Msg ( final String message ) { if ( consolidated Message != null && consolidated Message . length ( ) > NUM ) { consolidated Message = consolidated Message + STRING ; } consolidated Message = consolidated Message + message ; }
public void add To Consolitated Msg ( final String message ) { if ( consolidated Message != null && consolidated Message . length ( ) > NUM ) { consolidated Message = consolidated Message + STRING ; } consolidated Message = consolidated Message + message ; }
public void add To Consolitated Msg ( final String message ) { if ( consolidated Message != null && consolidated Message . length ( ) > NUM ) { consolidated Message = consolidated Message + STRING ; } consolidated Message = consolidated Message + message ; }
public void add To Consolitated Msg ( final String message ) { if ( consolidated Message != null && consolidated Message . length ( ) > NUM ) { consolidated Message = consolidated Message + STRING ; } consolidated Message = consolidated Message + message ; }
public static Boolean can String Be Inline Encoded ( String skey ) { if ( skey . length ( ) > get Max Inline String Key ( MAX LONGS USED FOR STRING KEY , BOOL ) ) { return null ; } if ( is Byte Encoding Ok ( skey ) ) { return Boolean . TRUE ; } else { if ( skey . length ( ) > get Max Inline String Key ( MAX LONGS USED FOR STRING KEY , BOOL ) ) { return null ; } else { return Boolean . FALSE ; } } }
public void close ( Result Set rs ) { if ( rs != null ) { try { rs . close ( ) ; } catch ( SQL Exception e ) { } } }
public void close ( Result Set rs ) { if ( rs != null ) { try { rs . close ( ) ; } catch ( SQL Exception e ) { } } }
private void init Parameter Removal Lists ( ) { parameter to remove for all request = new Array List < > ( ) ; parameter to remove after initial request = new Array List < > ( ) ; parameter to remove for all request . add ( EXPAND PARAM ) ; parameter to remove after initial request . add All ( parameter to remove for all request ) ; parameter to remove after initial request . add ( STRING ) ; parameter to remove after initial request . add ( STRING ) ; }
@ Override public long read ( Byte Buffer buffer ) { long value = buffer . get Int ( ) ; return value ; }
@ Override public void put All ( Map < ? extends K , ? extends V > m ) { try Presize ( m . size ( ) ) ; for ( Map . Entry < ? extends K , ? extends V > e : m . entry Set ( ) ) put Val ( e . get Key ( ) , e . get Value ( ) , BOOL ) ; }
@ Override public void put All ( Map < ? extends K , ? extends V > m ) { try Presize ( m . size ( ) ) ; for ( Map . Entry < ? extends K , ? extends V > e : m . entry Set ( ) ) put Val ( e . get Key ( ) , e . get Value ( ) , BOOL ) ; }
public void sort ( ) { if ( ! sorted ) { Collections . sort ( samples ) ; sorted = BOOL ; } }
public int file Write ( long handle , byte [ ] buffer , int offset , int count ) { if ( ( offset | count ) < NUM || offset > buffer . length || buffer . length - offset < count ) { throw new Array Index Out Of Bounds Exception ( STRING + buffer . length + STRING + offset + STRING + count ) ; } if ( count == NUM ) { return NUM ; } byte [ ] data = buffer ; if ( offset > NUM ) { data = new byte [ count ] ; System . arraycopy ( buffer , offset , data , NUM , count ) ; } Int Out bytes Written Out = new Int Out ( ) ; try { check Result ( Lib I Mobile Device . afc file write ( get Ref ( ) , handle , data , count , bytes Written Out ) ) ; int bytes Written = bytes Written Out . get Value ( ) ; return bytes Written ; } finally { bytes Written Out . delete ( ) ; } }
public void write Golomb ( int divisor , int value ) throws IO Exception { int q = value / divisor ; for ( int i = NUM ; i < q ; i ++ ) { write Bit ( BOOL , MAX PROBABILITY / NUM ) ; } write Bit ( BOOL , MAX PROBABILITY / NUM ) ; int r = value - q * divisor ; int bit = NUM - Integer . number Of Leading Zeros ( divisor - NUM ) ; if ( r < ( ( NUM << bit ) - divisor ) ) { bit -- ; } else { r += ( NUM << bit ) - divisor ; } for ( ; bit >= NUM ; bit -- ) { write Bit ( ( ( r > > > bit ) & NUM ) == NUM , MAX PROBABILITY / NUM ) ; } }
void mouse Dragged In Track ( final Mouse Event e ) { move To Mouse ( e ) ; }
public void stop ( ) throws Interrupted Exception { stopped = BOOL ; if ( thd != null ) { try { logger . info ( STRING ) ; socket Service . close ( ) ; thd . interrupt ( ) ; thd . join ( ) ; thd = null ; } catch ( Interrupted Exception e ) { logger . info ( STRING + e ) ; throw e ; } } }
public void stop ( ) throws Interrupted Exception { stopped = BOOL ; if ( thd != null ) { try { logger . info ( STRING ) ; socket Service . close ( ) ; thd . interrupt ( ) ; thd . join ( ) ; thd = null ; } catch ( Interrupted Exception e ) { logger . info ( STRING + e ) ; throw e ; } } }
public void stop ( ) throws Interrupted Exception { stopped = BOOL ; if ( thd != null ) { try { logger . info ( STRING ) ; socket Service . close ( ) ; thd . interrupt ( ) ; thd . join ( ) ; thd = null ; } catch ( Interrupted Exception e ) { logger . info ( STRING + e ) ; throw e ; } } }
public Stash Row Iterable ( ) { initial Iterator = create Stash Row Iterator ( ) ; try { initial Iterator . has Next ( ) ; open Iterators . add ( initial Iterator ) ; } catch ( Exception e ) { try { Closeables . close ( initial Iterator , BOOL ) ; } catch ( IO Exception e2 ) { } throw Throwables . propagate ( e ) ; } }
public Stash Row Iterable ( ) { initial Iterator = create Stash Row Iterator ( ) ; try { initial Iterator . has Next ( ) ; open Iterators . add ( initial Iterator ) ; } catch ( Exception e ) { try { Closeables . close ( initial Iterator , BOOL ) ; } catch ( IO Exception e2 ) { } throw Throwables . propagate ( e ) ; } }
public void add KMZ Writer Listener ( KMZ Writer Listener listener ) { writer Listeners . add ( listener ) ; }
public void add KMZ Writer Listener ( KMZ Writer Listener listener ) { writer Listeners . add ( listener ) ; }
public void add KMZ Writer Listener ( KMZ Writer Listener listener ) { writer Listeners . add ( listener ) ; }
public static < T > List < T > to List ( T obj 1 , T obj 2 , T obj 3 ) { List < T > list = new Linked List < T > ( ) ; list . add ( obj 1 ) ; list . add ( obj 2 ) ; list . add ( obj 3 ) ; return list ; }
public Date roll Date ( Date base ) { return roll Date ( base , Time Zone . get Default ( ) ) ; }
final protected void start Query ( final I Chunk Message < I Binding Set > msg ) { if ( ! controller ) throw new Unsupported Operation Exception ( ERR NOT CONTROLLER ) ; if ( msg == null ) throw new Illegal Argument Exception ( ) ; if ( ! query Id . equals ( msg . get Query Id ( ) ) ) throw new Illegal Argument Exception ( ) ; lock . lock ( ) ; try { run State . start Query ( msg ) ; } catch ( Timeout Exception ex ) { halt ( ex ) ; } finally { lock . unlock ( ) ; } }
public boolean validate State Transition ( ) { Log . v ( LOG TAG , String . format ( STRING , print States ( ) ) ) ; switch ( m Transition Direction ) { case DO NOTHING : Log . v ( LOG TAG , STRING ) ; return validate Network States ( ) ; case TO CONNECTION : Log . v ( LOG TAG , STRING ) ; return validate Network Connection ( ) ; case TO DISCONNECTION : Log . v ( LOG TAG , STRING ) ; return validate Network Disconnection ( ) ; default : Log . e ( LOG TAG , STRING ) ; return BOOL ; } }
public void add Key ( Key Code key Code ) { key Strokes . add ( key Code ) ; }
private void keep Annotated ( Path path ) throws File Not Found Exception { for ( Class Path Element element : path . get Elements ( ) ) { for Clazz : for ( String name : element . list ( ) ) { if ( name . ends With ( CLASS EXTENSION ) ) { Direct Class File clazz = path . get Class ( name ) ; if ( has Runtime Visible Annotation ( clazz ) ) { files To Keep . add ( name ) ; } else { Method List methods = clazz . get Methods ( ) ; for ( int i = NUM ; i < methods . size ( ) ; i ++ ) { if ( has Runtime Visible Annotation ( methods . get ( i ) ) ) { files To Keep . add ( name ) ; continue for Clazz ; } } Field List fields = clazz . get Fields ( ) ; for ( int i = NUM ; i < fields . size ( ) ; i ++ ) { if ( has Runtime Visible Annotation ( fields . get ( i ) ) ) { files To Keep . add ( name ) ; continue for Clazz ; } } } } } } }
protected List < Evaluation Statistics > filter ( List < Evaluation Statistics > stats ) { Instances data ; Instances filtered ; Filter filter ; try { data = to Instances ( stats ) ; filter = Filter . make Copy ( m Filter ) ; filter . set Input Format ( data ) ; filtered = Filter . use Filter ( data , filter ) ; stats = from Instances ( filtered ) ; } catch ( Exception e ) { handle Exception ( STRING , e ) ; } return stats ; }
public JK Namespace ( final String url , final String prefix ) { logger . info ( String . format ( STRING , url , prefix ) ) ; this . url = url ; this . prefix = prefix ; }
public void prep Read Pane ( boolean only Changes ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING , only Changes ) ; } just Changes = only Changes ; if ( is Cv Table Pane ) { set Cv List From Table ( ) ; } enable Buttons ( BOOL ) ; if ( just Changes == BOOL ) { read Changes Button . set Enabled ( BOOL ) ; read Changes Button . set Selected ( BOOL ) ; } else { read All Button . set Selected ( BOOL ) ; read All Button . set Enabled ( BOOL ) ; } if ( container . is Busy ( ) == BOOL ) { container . enable Buttons ( BOOL ) ; } set To Read ( just Changes , BOOL ) ; var List Index = NUM ; cv List Iterator = cv List . iterator ( ) ; indexed Cv List Index = NUM ; }
public void prep Read Pane ( boolean only Changes ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING , only Changes ) ; } just Changes = only Changes ; if ( is Cv Table Pane ) { set Cv List From Table ( ) ; } enable Buttons ( BOOL ) ; if ( just Changes == BOOL ) { read Changes Button . set Enabled ( BOOL ) ; read Changes Button . set Selected ( BOOL ) ; } else { read All Button . set Selected ( BOOL ) ; read All Button . set Enabled ( BOOL ) ; } if ( container . is Busy ( ) == BOOL ) { container . enable Buttons ( BOOL ) ; } set To Read ( just Changes , BOOL ) ; var List Index = NUM ; cv List Iterator = cv List . iterator ( ) ; indexed Cv List Index = NUM ; }
public void prep Read Pane ( boolean only Changes ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING , only Changes ) ; } just Changes = only Changes ; if ( is Cv Table Pane ) { set Cv List From Table ( ) ; } enable Buttons ( BOOL ) ; if ( just Changes == BOOL ) { read Changes Button . set Enabled ( BOOL ) ; read Changes Button . set Selected ( BOOL ) ; } else { read All Button . set Selected ( BOOL ) ; read All Button . set Enabled ( BOOL ) ; } if ( container . is Busy ( ) == BOOL ) { container . enable Buttons ( BOOL ) ; } set To Read ( just Changes , BOOL ) ; var List Index = NUM ; cv List Iterator = cv List . iterator ( ) ; indexed Cv List Index = NUM ; }
public void prep Read Pane ( boolean only Changes ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING , only Changes ) ; } just Changes = only Changes ; if ( is Cv Table Pane ) { set Cv List From Table ( ) ; } enable Buttons ( BOOL ) ; if ( just Changes == BOOL ) { read Changes Button . set Enabled ( BOOL ) ; read Changes Button . set Selected ( BOOL ) ; } else { read All Button . set Selected ( BOOL ) ; read All Button . set Enabled ( BOOL ) ; } if ( container . is Busy ( ) == BOOL ) { container . enable Buttons ( BOOL ) ; } set To Read ( just Changes , BOOL ) ; var List Index = NUM ; cv List Iterator = cv List . iterator ( ) ; indexed Cv List Index = NUM ; }
public void prep Read Pane ( boolean only Changes ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING , only Changes ) ; } just Changes = only Changes ; if ( is Cv Table Pane ) { set Cv List From Table ( ) ; } enable Buttons ( BOOL ) ; if ( just Changes == BOOL ) { read Changes Button . set Enabled ( BOOL ) ; read Changes Button . set Selected ( BOOL ) ; } else { read All Button . set Selected ( BOOL ) ; read All Button . set Enabled ( BOOL ) ; } if ( container . is Busy ( ) == BOOL ) { container . enable Buttons ( BOOL ) ; } set To Read ( just Changes , BOOL ) ; var List Index = NUM ; cv List Iterator = cv List . iterator ( ) ; indexed Cv List Index = NUM ; }
public void prep Read Pane ( boolean only Changes ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING , only Changes ) ; } just Changes = only Changes ; if ( is Cv Table Pane ) { set Cv List From Table ( ) ; } enable Buttons ( BOOL ) ; if ( just Changes == BOOL ) { read Changes Button . set Enabled ( BOOL ) ; read Changes Button . set Selected ( BOOL ) ; } else { read All Button . set Selected ( BOOL ) ; read All Button . set Enabled ( BOOL ) ; } if ( container . is Busy ( ) == BOOL ) { container . enable Buttons ( BOOL ) ; } set To Read ( just Changes , BOOL ) ; var List Index = NUM ; cv List Iterator = cv List . iterator ( ) ; indexed Cv List Index = NUM ; }
public void prep Read Pane ( boolean only Changes ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING , only Changes ) ; } just Changes = only Changes ; if ( is Cv Table Pane ) { set Cv List From Table ( ) ; } enable Buttons ( BOOL ) ; if ( just Changes == BOOL ) { read Changes Button . set Enabled ( BOOL ) ; read Changes Button . set Selected ( BOOL ) ; } else { read All Button . set Selected ( BOOL ) ; read All Button . set Enabled ( BOOL ) ; } if ( container . is Busy ( ) == BOOL ) { container . enable Buttons ( BOOL ) ; } set To Read ( just Changes , BOOL ) ; var List Index = NUM ; cv List Iterator = cv List . iterator ( ) ; indexed Cv List Index = NUM ; }
public void prep Read Pane ( boolean only Changes ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING , only Changes ) ; } just Changes = only Changes ; if ( is Cv Table Pane ) { set Cv List From Table ( ) ; } enable Buttons ( BOOL ) ; if ( just Changes == BOOL ) { read Changes Button . set Enabled ( BOOL ) ; read Changes Button . set Selected ( BOOL ) ; } else { read All Button . set Selected ( BOOL ) ; read All Button . set Enabled ( BOOL ) ; } if ( container . is Busy ( ) == BOOL ) { container . enable Buttons ( BOOL ) ; } set To Read ( just Changes , BOOL ) ; var List Index = NUM ; cv List Iterator = cv List . iterator ( ) ; indexed Cv List Index = NUM ; }
public void prep Read Pane ( boolean only Changes ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING , only Changes ) ; } just Changes = only Changes ; if ( is Cv Table Pane ) { set Cv List From Table ( ) ; } enable Buttons ( BOOL ) ; if ( just Changes == BOOL ) { read Changes Button . set Enabled ( BOOL ) ; read Changes Button . set Selected ( BOOL ) ; } else { read All Button . set Selected ( BOOL ) ; read All Button . set Enabled ( BOOL ) ; } if ( container . is Busy ( ) == BOOL ) { container . enable Buttons ( BOOL ) ; } set To Read ( just Changes , BOOL ) ; var List Index = NUM ; cv List Iterator = cv List . iterator ( ) ; indexed Cv List Index = NUM ; }
public void prep Read Pane ( boolean only Changes ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING , only Changes ) ; } just Changes = only Changes ; if ( is Cv Table Pane ) { set Cv List From Table ( ) ; } enable Buttons ( BOOL ) ; if ( just Changes == BOOL ) { read Changes Button . set Enabled ( BOOL ) ; read Changes Button . set Selected ( BOOL ) ; } else { read All Button . set Selected ( BOOL ) ; read All Button . set Enabled ( BOOL ) ; } if ( container . is Busy ( ) == BOOL ) { container . enable Buttons ( BOOL ) ; } set To Read ( just Changes , BOOL ) ; var List Index = NUM ; cv List Iterator = cv List . iterator ( ) ; indexed Cv List Index = NUM ; }
public void prep Read Pane ( boolean only Changes ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING , only Changes ) ; } just Changes = only Changes ; if ( is Cv Table Pane ) { set Cv List From Table ( ) ; } enable Buttons ( BOOL ) ; if ( just Changes == BOOL ) { read Changes Button . set Enabled ( BOOL ) ; read Changes Button . set Selected ( BOOL ) ; } else { read All Button . set Selected ( BOOL ) ; read All Button . set Enabled ( BOOL ) ; } if ( container . is Busy ( ) == BOOL ) { container . enable Buttons ( BOOL ) ; } set To Read ( just Changes , BOOL ) ; var List Index = NUM ; cv List Iterator = cv List . iterator ( ) ; indexed Cv List Index = NUM ; }
public void prep Read Pane ( boolean only Changes ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING , only Changes ) ; } just Changes = only Changes ; if ( is Cv Table Pane ) { set Cv List From Table ( ) ; } enable Buttons ( BOOL ) ; if ( just Changes == BOOL ) { read Changes Button . set Enabled ( BOOL ) ; read Changes Button . set Selected ( BOOL ) ; } else { read All Button . set Selected ( BOOL ) ; read All Button . set Enabled ( BOOL ) ; } if ( container . is Busy ( ) == BOOL ) { container . enable Buttons ( BOOL ) ; } set To Read ( just Changes , BOOL ) ; var List Index = NUM ; cv List Iterator = cv List . iterator ( ) ; indexed Cv List Index = NUM ; }
public static void clean Up Custom Temp Directories ( ) { if ( temp Directory List != null ) { log . info ( STRING ) ; try { for ( File temp File : temp Directory List ) if ( temp File . exists ( ) ) { log . info ( STRING + temp File . get Canonical Path ( ) ) ; delete Directory ( temp File ) ; } temp Directory List . clear ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } else log . info ( STRING ) ; log . info ( STRING ) ; }
public void clear All Watchers ( ) { synchronized ( watchers ) { watchers . clear ( ) ; } }
public boolean draw Image ( Image img , Affine Transform xform , Image Observer obs ) { if ( img == null ) { return BOOL ; } m Drawing Area . add Infinite ( ) ; m Print Metrics . draw Image ( this , img ) ; return m Graphics . draw Image ( img , xform , obs ) ; }
public boolean draw Image ( Image img , Affine Transform xform , Image Observer obs ) { if ( img == null ) { return BOOL ; } m Drawing Area . add Infinite ( ) ; m Print Metrics . draw Image ( this , img ) ; return m Graphics . draw Image ( img , xform , obs ) ; }
public boolean draw Image ( Image img , Affine Transform xform , Image Observer obs ) { if ( img == null ) { return BOOL ; } m Drawing Area . add Infinite ( ) ; m Print Metrics . draw Image ( this , img ) ; return m Graphics . draw Image ( img , xform , obs ) ; }
private static void draw Chunk ( Image image , Graphics g , boolean stretch , int dx 1 , int dy 1 , int dx 2 , int dy 2 , int sx 1 , int sy 1 , int sx 2 , int sy 2 , boolean x Direction ) { if ( dx 2 - dx 1 <= NUM || dy 2 - dy 1 <= NUM || sx 2 - sx 1 <= NUM || sy 2 - sy 1 <= NUM ) { return ; } if ( stretch ) { g . draw Image ( image , dx 1 , dy 1 , dx 2 , dy 2 , sx 1 , sy 1 , sx 2 , sy 2 , null ) ; } else { int x Size = sx 2 - sx 1 ; int y Size = sy 2 - sy 1 ; int delta X ; int delta Y ; if ( x Direction ) { delta X = x Size ; delta Y = NUM ; } else { delta X = NUM ; delta Y = y Size ; } while ( dx 1 < dx 2 && dy 1 < dy 2 ) { int new DX 2 = Math . min ( dx 2 , dx 1 + x Size ) ; int new DY 2 = Math . min ( dy 2 , dy 1 + y Size ) ; g . draw Image ( image , dx 1 , dy 1 , new DX 2 , new DY 2 , sx 1 , sy 1 , sx 1 + new DX 2 - dx 1 , sy 1 + new DY 2 - dy 1 , null ) ; dx 1 += delta X ; dy 1 += delta Y ; } } }
public Byte Column ( int nrows , int capacity , byte default Value ) { super ( byte . class , new Byte ( default Value ) ) ; if ( capacity < nrows ) { throw new Illegal Argument Exception ( STRING ) ; } m values = new byte [ capacity ] ; Arrays . fill ( m values , default Value ) ; m size = nrows ; }
public void print Map ( Hash Map < String , Hash Map < String , Hash Set < Integer > > > map ) { map . for Each ( null ) ; }
public void print Map ( Hash Map < String , Hash Map < String , Hash Set < Integer > > > map ) { map . for Each ( null ) ; }
public void test Submit Callable ( ) throws Throwable { Executor Service e = new Fork Join Pool ( NUM ) ; Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; Future < String > future = e . submit ( new String Task ( ) ) ; assert Same ( TEST STRING , future . get ( ) ) ; assert True ( future . is Done ( ) ) ; assert False ( future . is Cancelled ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public void write Header ( ) { ps . println ( STRING ) ; ps . println ( STRING ) ; ps . println ( STRING ) ; ps . println ( STRING ) ; ps . println ( STRING ) ; ps . println ( STRING ) ; ps . println ( STRING ) ; }
public Sparse Integer Vector ( T Int Double Map values , int dimensionality ) throws Illegal Argument Exception { if ( values . size ( ) > dimensionality ) { throw new Illegal Argument Exception ( STRING ) ; } this . indexes = new int [ values . size ( ) ] ; this . values = new int [ values . size ( ) ] ; { T Int Double Iterator iter = values . iterator ( ) ; for ( int i = NUM ; iter . has Next ( ) ; i ++ ) { iter . advance ( ) ; this . indexes [ i ] = iter . key ( ) ; } Arrays . sort ( this . indexes ) ; } { for ( int i = NUM ; i < values . size ( ) ; i ++ ) { this . values [ i ] = ( int ) values . get ( this . indexes [ i ] ) ; } } this . dimensionality = dimensionality ; final int maxdim = get Max Dim ( ) ; if ( maxdim > dimensionality ) { throw new Illegal Argument Exception ( STRING + dimensionality + STRING + maxdim + STRING ) ; } }
public static void create Dir ( File target ) throws Ade Usage Exception { if ( ! target . exists ( ) && ! target . mkdir ( ) ) { throw new Ade Usage Exception ( STRING + target . get Path ( ) ) ; } }
public static void create Dir ( File target ) throws Ade Usage Exception { if ( ! target . exists ( ) && ! target . mkdir ( ) ) { throw new Ade Usage Exception ( STRING + target . get Path ( ) ) ; } }
public void mark ( int readlimit ) { in . mark ( readlimit ) ; if ( in . mark Supported ( ) ) bytes Left At Mark = bytes Left ; }
public void mark ( int readlimit ) { in . mark ( readlimit ) ; if ( in . mark Supported ( ) ) bytes Left At Mark = bytes Left ; }
public void mark ( int readlimit ) { in . mark ( readlimit ) ; if ( in . mark Supported ( ) ) bytes Left At Mark = bytes Left ; }
public void mark ( int readlimit ) { in . mark ( readlimit ) ; if ( in . mark Supported ( ) ) bytes Left At Mark = bytes Left ; }
public void mark ( int readlimit ) { in . mark ( readlimit ) ; if ( in . mark Supported ( ) ) bytes Left At Mark = bytes Left ; }
public void mark ( int readlimit ) { in . mark ( readlimit ) ; if ( in . mark Supported ( ) ) bytes Left At Mark = bytes Left ; }
public void mark ( int readlimit ) { in . mark ( readlimit ) ; if ( in . mark Supported ( ) ) bytes Left At Mark = bytes Left ; }
protected static Long convert String To Buckecting Long ( String string To Be Converted ) { if ( string To Be Converted == null || string To Be Converted . equals ( STRING ) ) { return null ; } byte [ ] byte String = string To Be Converted . get Bytes ( ) ; if ( byte String . length < NUM ) { byte [ ] new Byte String = new byte [ NUM ] ; for ( int i = NUM ; i < new Byte String . length ; i ++ ) { if ( i < byte String . length ) { new Byte String [ i ] = byte String [ i ] ; } else { new Byte String [ i ] = NUM ; } } byte String = new Byte String ; } Byte Buffer bb = Byte Buffer . wrap ( byte String ) ; long byte Method = bb . get Long ( ) ; byte Method = Math . abs ( byte Method ) ; return byte Method ; }
protected static Long convert String To Buckecting Long ( String string To Be Converted ) { if ( string To Be Converted == null || string To Be Converted . equals ( STRING ) ) { return null ; } byte [ ] byte String = string To Be Converted . get Bytes ( ) ; if ( byte String . length < NUM ) { byte [ ] new Byte String = new byte [ NUM ] ; for ( int i = NUM ; i < new Byte String . length ; i ++ ) { if ( i < byte String . length ) { new Byte String [ i ] = byte String [ i ] ; } else { new Byte String [ i ] = NUM ; } } byte String = new Byte String ; } Byte Buffer bb = Byte Buffer . wrap ( byte String ) ; long byte Method = bb . get Long ( ) ; byte Method = Math . abs ( byte Method ) ; return byte Method ; }
protected static Long convert String To Buckecting Long ( String string To Be Converted ) { if ( string To Be Converted == null || string To Be Converted . equals ( STRING ) ) { return null ; } byte [ ] byte String = string To Be Converted . get Bytes ( ) ; if ( byte String . length < NUM ) { byte [ ] new Byte String = new byte [ NUM ] ; for ( int i = NUM ; i < new Byte String . length ; i ++ ) { if ( i < byte String . length ) { new Byte String [ i ] = byte String [ i ] ; } else { new Byte String [ i ] = NUM ; } } byte String = new Byte String ; } Byte Buffer bb = Byte Buffer . wrap ( byte String ) ; long byte Method = bb . get Long ( ) ; byte Method = Math . abs ( byte Method ) ; return byte Method ; }
protected static Long convert String To Buckecting Long ( String string To Be Converted ) { if ( string To Be Converted == null || string To Be Converted . equals ( STRING ) ) { return null ; } byte [ ] byte String = string To Be Converted . get Bytes ( ) ; if ( byte String . length < NUM ) { byte [ ] new Byte String = new byte [ NUM ] ; for ( int i = NUM ; i < new Byte String . length ; i ++ ) { if ( i < byte String . length ) { new Byte String [ i ] = byte String [ i ] ; } else { new Byte String [ i ] = NUM ; } } byte String = new Byte String ; } Byte Buffer bb = Byte Buffer . wrap ( byte String ) ; long byte Method = bb . get Long ( ) ; byte Method = Math . abs ( byte Method ) ; return byte Method ; }
protected static Long convert String To Buckecting Long ( String string To Be Converted ) { if ( string To Be Converted == null || string To Be Converted . equals ( STRING ) ) { return null ; } byte [ ] byte String = string To Be Converted . get Bytes ( ) ; if ( byte String . length < NUM ) { byte [ ] new Byte String = new byte [ NUM ] ; for ( int i = NUM ; i < new Byte String . length ; i ++ ) { if ( i < byte String . length ) { new Byte String [ i ] = byte String [ i ] ; } else { new Byte String [ i ] = NUM ; } } byte String = new Byte String ; } Byte Buffer bb = Byte Buffer . wrap ( byte String ) ; long byte Method = bb . get Long ( ) ; byte Method = Math . abs ( byte Method ) ; return byte Method ; }
public Event do Wait Timeout ( long timeout ) { Event e = null ; long towait = NUM ; long endtime = - NUM ; boolean usetimeout = ( timeout > NUM ) ; if ( usetimeout ) { endtime = System . nano Time ( ) + timeout * NUM * NUM ; } if ( network Thread . get Done ( ) ) return null ; while ( e == null ) { if ( usetimeout ) { towait = ( endtime - System . nano Time ( ) ) ; if ( towait <= NUM ) { break ; } } else { if ( timeout == NUM ) { return latest Events . poll ( ) ; } } try { if ( usetimeout ) { e = latest Events . poll ( towait , Time Unit . NANOSECONDS ) ; } else { e = latest Events . take ( ) ; } } catch ( Interrupted Exception e1 ) { } if ( e != null && e . t == E Type . KILLSENDER ) { return null ; } if ( network Thread . get Done ( ) ) return null ; } return e ; }
public void init Structure ( ) throws Exception { int n Attribute = NUM ; for ( int i Order = NUM ; i Order < m Instances . num Attributes ( ) ; i Order ++ ) { if ( n Attribute == m Instances . class Index ( ) ) { n Attribute ++ ; } } m Parent Sets = new Parent Set [ m Instances . num Attributes ( ) ] ; for ( int i Attribute = NUM ; i Attribute < m Instances . num Attributes ( ) ; i Attribute ++ ) { m Parent Sets [ i Attribute ] = new Parent Set ( m Instances . num Attributes ( ) ) ; } }
public Project Association ( ) { super ( NUM , NUM ) ; }
private double parse Double ( String value , String setting ) { double number ; int multiplier = get Multiplier ( value ) ; if ( multiplier > NUM ) { value = value . replace All ( STRING , STRING ) ; } try { number = Double . parse Double ( value ) * multiplier ; } catch ( Number Format Exception e ) { throw new Settings Error ( STRING + value + STRING + setting + STRING + e . get Message ( ) ) ; } return number ; }
private void send Buffer ( ) throws IO Exception { buf . flip ( ) ; send ( buf , buf . remaining ( ) ) ; buf = null ; }
private void refresh Directory ( ) { if ( m Selected Dir != null ) { change Directory ( m Selected Dir ) ; } }
private void refresh Directory ( ) { if ( m Selected Dir != null ) { change Directory ( m Selected Dir ) ; } }
public static void banner ( Logger logger , Class < ? > clazz , String method Name , String text ) { String string = clazz . get Simple Name ( ) + STRING + method Name ; if ( text != null ) { string += STRING + text ; } logger . info ( STRING ) ; logger . info ( STRING ) ; logger . info ( STRING + string ) ; logger . info ( STRING ) ; }
public static void banner ( Logger logger , Class < ? > clazz , String method Name , String text ) { String string = clazz . get Simple Name ( ) + STRING + method Name ; if ( text != null ) { string += STRING + text ; } logger . info ( STRING ) ; logger . info ( STRING ) ; logger . info ( STRING + string ) ; logger . info ( STRING ) ; }
public static boolean is Volatile ( int mod ) { return Modifier . is Volatile ( mod ) ; }
public static boolean is Volatile ( int mod ) { return Modifier . is Volatile ( mod ) ; }
Mutable Attribute Set current Text Attributes ( ) { Mutable Attribute Set attributes = new Simple Attribute Set ( character Attributes ) ; Integer fontnum ; Integer state Item ; fontnum = ( Integer ) parser State . get ( STRING ) ; String font Family ; if ( fontnum != null ) font Family = font Table . get ( fontnum ) ; else font Family = null ; if ( font Family != null ) Style Constants . set Font Family ( attributes , font Family ) ; else attributes . remove Attribute ( Style Constants . Font Family ) ; if ( color Table != null ) { state Item = ( Integer ) parser State . get ( STRING ) ; if ( state Item != null ) { Color fg = color Table [ state Item . int Value ( ) ] ; Style Constants . set Foreground ( attributes , fg ) ; } else { attributes . remove Attribute ( Style Constants . Foreground ) ; } } if ( color Table != null ) { state Item = ( Integer ) parser State . get ( STRING ) ; if ( state Item != null ) { Color bg = color Table [ state Item . int Value ( ) ] ; attributes . add Attribute ( Style Constants . Background , bg ) ; } else { attributes . remove Attribute ( Style Constants . Background ) ; } } Style character Style = ( Style ) parser State . get ( STRING ) ; if ( character Style != null ) attributes . set Resolve Parent ( character Style ) ; return attributes ; }
Mutable Attribute Set current Text Attributes ( ) { Mutable Attribute Set attributes = new Simple Attribute Set ( character Attributes ) ; Integer fontnum ; Integer state Item ; fontnum = ( Integer ) parser State . get ( STRING ) ; String font Family ; if ( fontnum != null ) font Family = font Table . get ( fontnum ) ; else font Family = null ; if ( font Family != null ) Style Constants . set Font Family ( attributes , font Family ) ; else attributes . remove Attribute ( Style Constants . Font Family ) ; if ( color Table != null ) { state Item = ( Integer ) parser State . get ( STRING ) ; if ( state Item != null ) { Color fg = color Table [ state Item . int Value ( ) ] ; Style Constants . set Foreground ( attributes , fg ) ; } else { attributes . remove Attribute ( Style Constants . Foreground ) ; } } if ( color Table != null ) { state Item = ( Integer ) parser State . get ( STRING ) ; if ( state Item != null ) { Color bg = color Table [ state Item . int Value ( ) ] ; attributes . add Attribute ( Style Constants . Background , bg ) ; } else { attributes . remove Attribute ( Style Constants . Background ) ; } } Style character Style = ( Style ) parser State . get ( STRING ) ; if ( character Style != null ) attributes . set Resolve Parent ( character Style ) ; return attributes ; }
public void add Generator ( Distribution gen ) { if ( trans != null ) { throw new Abort Exception ( STRING ) ; } axes . add ( gen ) ; dim ++ ; }
public void add Generator ( Distribution gen ) { if ( trans != null ) { throw new Abort Exception ( STRING ) ; } axes . add ( gen ) ; dim ++ ; }
public void add Permission ( Permission Type permission ) { added Permissions . add ( permission ) ; }
private void load Profile ( String user Id , String name ) { final Intent user Profile Intent = new Intent ( get Activity ( ) , User Profile Activity . class ) ; user Profile Intent . put Extra ( App Constants . Keys . USER ID , user Id ) ; user Profile Intent . put Extra ( App Constants . Keys . USER NAME , name ) ; user Profile Intent . put Extra ( App Constants . Keys . SERVICE SCREEN TYPE , App Constants . Service Screen Type . PROFILE ) ; start Activity ( user Profile Intent ) ; }
private void load Profile ( String user Id , String name ) { final Intent user Profile Intent = new Intent ( get Activity ( ) , User Profile Activity . class ) ; user Profile Intent . put Extra ( App Constants . Keys . USER ID , user Id ) ; user Profile Intent . put Extra ( App Constants . Keys . USER NAME , name ) ; user Profile Intent . put Extra ( App Constants . Keys . SERVICE SCREEN TYPE , App Constants . Service Screen Type . PROFILE ) ; start Activity ( user Profile Intent ) ; }
static public Unique String resolve Synonym ( Unique String name ) { Operator n = ( Operator ) Definition Table . get ( name ) ; if ( n == null ) return name ; else return n . get Identifier ( ) ; }
public boolean is Running ( ) { if ( process == null ) { return BOOL ; } try { process . exit Value ( ) ; return BOOL ; } catch ( Illegal Thread State Exception e ) { } return BOOL ; }
public void run ( ) { try { while ( BOOL ) { Reference ref = queue . remove ( ) ; ref . clear ( ) ; synchronized ( refs ) { refs . remove ( ref ) ; if ( refs . is Empty ( ) ) { reaper = null ; return ; } } } } catch ( Interrupted Exception e ) { } }
public void run ( ) { try { while ( BOOL ) { Reference ref = queue . remove ( ) ; ref . clear ( ) ; synchronized ( refs ) { refs . remove ( ref ) ; if ( refs . is Empty ( ) ) { reaper = null ; return ; } } } } catch ( Interrupted Exception e ) { } }
private void write ( char [ ] plain ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . write ( plain ) ; }
private void write ( char [ ] plain ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . write ( plain ) ; }
private void write ( char [ ] plain ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . write ( plain ) ; }
private void write ( char [ ] plain ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . write ( plain ) ; }
private void write ( char [ ] plain ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . write ( plain ) ; }
public boolean is Satisfied By ( final Date date ) { final Calendar test Date Cal = Calendar . get Instance ( get Time Zone ( ) ) ; test Date Cal . set Time ( date ) ; test Date Cal . set ( Calendar . MILLISECOND , NUM ) ; final Date original Date = test Date Cal . get Time ( ) ; test Date Cal . add ( Calendar . SECOND , - NUM ) ; final Date time After = get Time After ( test Date Cal . get Time ( ) ) ; return time After != null && time After . equals ( original Date ) ; }
public boolean is Satisfied By ( final Date date ) { final Calendar test Date Cal = Calendar . get Instance ( get Time Zone ( ) ) ; test Date Cal . set Time ( date ) ; test Date Cal . set ( Calendar . MILLISECOND , NUM ) ; final Date original Date = test Date Cal . get Time ( ) ; test Date Cal . add ( Calendar . SECOND , - NUM ) ; final Date time After = get Time After ( test Date Cal . get Time ( ) ) ; return time After != null && time After . equals ( original Date ) ; }
public boolean is Satisfied By ( final Date date ) { final Calendar test Date Cal = Calendar . get Instance ( get Time Zone ( ) ) ; test Date Cal . set Time ( date ) ; test Date Cal . set ( Calendar . MILLISECOND , NUM ) ; final Date original Date = test Date Cal . get Time ( ) ; test Date Cal . add ( Calendar . SECOND , - NUM ) ; final Date time After = get Time After ( test Date Cal . get Time ( ) ) ; return time After != null && time After . equals ( original Date ) ; }
public boolean is Satisfied By ( final Date date ) { final Calendar test Date Cal = Calendar . get Instance ( get Time Zone ( ) ) ; test Date Cal . set Time ( date ) ; test Date Cal . set ( Calendar . MILLISECOND , NUM ) ; final Date original Date = test Date Cal . get Time ( ) ; test Date Cal . add ( Calendar . SECOND , - NUM ) ; final Date time After = get Time After ( test Date Cal . get Time ( ) ) ; return time After != null && time After . equals ( original Date ) ; }
public static void cleanup Dir ( String dir Path , List < String > childdirs ) throws IO Exception { if ( childdirs == null || childdirs . size ( ) == NUM ) File Utils . clean Directory ( new File ( dir Path ) ) ; else { for ( String cdir : childdirs ) File Utils . clean Directory ( new File ( dir Path + STRING + cdir ) ) ; } }
public void print Stack Trace ( Print Writer pw ) { pw . println ( fetch Stack Trace ( ) ) ; }
public void print Stack Trace ( Print Writer pw ) { pw . println ( fetch Stack Trace ( ) ) ; }
public void print Stack Trace ( Print Writer pw ) { pw . println ( fetch Stack Trace ( ) ) ; }
public void add ( On Click Wrapper on Click Wrapper ) { on Click Wrapper List . add ( on Click Wrapper ) ; }
public void add ( On Click Wrapper on Click Wrapper ) { on Click Wrapper List . add ( on Click Wrapper ) ; }
public void add ( On Click Wrapper on Click Wrapper ) { on Click Wrapper List . add ( on Click Wrapper ) ; }
public Abstract Request ( One Drive API api , URL url , String method ) { this . api = api ; this . url = Objects . require Non Null ( url ) ; this . method = Objects . require Non Null ( method ) ; this . headers = new Array List < > ( ) ; add Header ( STRING , STRING ) ; add Header ( STRING , STRING ) ; }
public Abstract Request ( One Drive API api , URL url , String method ) { this . api = api ; this . url = Objects . require Non Null ( url ) ; this . method = Objects . require Non Null ( method ) ; this . headers = new Array List < > ( ) ; add Header ( STRING , STRING ) ; add Header ( STRING , STRING ) ; }
public Abstract Request ( One Drive API api , URL url , String method ) { this . api = api ; this . url = Objects . require Non Null ( url ) ; this . method = Objects . require Non Null ( method ) ; this . headers = new Array List < > ( ) ; add Header ( STRING , STRING ) ; add Header ( STRING , STRING ) ; }
@ Override public void close ( ) throws IO Exception { synchronized ( lock ) { if ( ! is Closed ( ) ) { in . close ( ) ; buf = null ; } } }
@ Override public void close ( ) throws IO Exception { synchronized ( lock ) { if ( ! is Closed ( ) ) { in . close ( ) ; buf = null ; } } }
@ Override public void close ( ) throws IO Exception { synchronized ( lock ) { if ( ! is Closed ( ) ) { in . close ( ) ; buf = null ; } } }
@ Override public void close ( ) throws IO Exception { synchronized ( lock ) { if ( ! is Closed ( ) ) { in . close ( ) ; buf = null ; } } }
public C Debugger History Synchronizer ( final C Debug Perspective Model model , final J Text Pane area ) { m model = model ; m area = area ; m area . set Enabled ( BOOL ) ; model . add Listener ( m perspective Listener ) ; m history String Builder . add Listener ( m builder Listener ) ; }
Double nmea Lon To Decimal ( String nmea ) throws Number Format Exception { int deg = Integer . parse Int ( nmea . substring ( NUM , NUM ) ) ; Double min = Double . parse Double ( nmea . substring ( NUM ) ) ; return deg + min / NUM ; }
Double nmea Lon To Decimal ( String nmea ) throws Number Format Exception { int deg = Integer . parse Int ( nmea . substring ( NUM , NUM ) ) ; Double min = Double . parse Double ( nmea . substring ( NUM ) ) ; return deg + min / NUM ; }
@ Rpc Method public void finalize Image ( String image Id , String datastore , String tmp Image Path , Async Method Callback < Host . Async Client . finalize image call > handler ) throws Rpc Exception { ensure Client ( ) ; Finalize Image Request finalize Image Request = new Finalize Image Request ( ) ; finalize Image Request . set Image id ( image Id ) ; finalize Image Request . set Datastore ( datastore ) ; finalize Image Request . set Tmp image path ( tmp Image Path ) ; client Proxy . set Timeout ( FINALIZE IMAGE TIMEOUT MS ) ; logger . info ( STRING , get Host Ip ( ) , finalize Image Request ) ; try { client Proxy . finalize image ( finalize Image Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Rpc Method public void finalize Image ( String image Id , String datastore , String tmp Image Path , Async Method Callback < Host . Async Client . finalize image call > handler ) throws Rpc Exception { ensure Client ( ) ; Finalize Image Request finalize Image Request = new Finalize Image Request ( ) ; finalize Image Request . set Image id ( image Id ) ; finalize Image Request . set Datastore ( datastore ) ; finalize Image Request . set Tmp image path ( tmp Image Path ) ; client Proxy . set Timeout ( FINALIZE IMAGE TIMEOUT MS ) ; logger . info ( STRING , get Host Ip ( ) , finalize Image Request ) ; try { client Proxy . finalize image ( finalize Image Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Rpc Method public void finalize Image ( String image Id , String datastore , String tmp Image Path , Async Method Callback < Host . Async Client . finalize image call > handler ) throws Rpc Exception { ensure Client ( ) ; Finalize Image Request finalize Image Request = new Finalize Image Request ( ) ; finalize Image Request . set Image id ( image Id ) ; finalize Image Request . set Datastore ( datastore ) ; finalize Image Request . set Tmp image path ( tmp Image Path ) ; client Proxy . set Timeout ( FINALIZE IMAGE TIMEOUT MS ) ; logger . info ( STRING , get Host Ip ( ) , finalize Image Request ) ; try { client Proxy . finalize image ( finalize Image Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Rpc Method public void finalize Image ( String image Id , String datastore , String tmp Image Path , Async Method Callback < Host . Async Client . finalize image call > handler ) throws Rpc Exception { ensure Client ( ) ; Finalize Image Request finalize Image Request = new Finalize Image Request ( ) ; finalize Image Request . set Image id ( image Id ) ; finalize Image Request . set Datastore ( datastore ) ; finalize Image Request . set Tmp image path ( tmp Image Path ) ; client Proxy . set Timeout ( FINALIZE IMAGE TIMEOUT MS ) ; logger . info ( STRING , get Host Ip ( ) , finalize Image Request ) ; try { client Proxy . finalize image ( finalize Image Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Rpc Method public void finalize Image ( String image Id , String datastore , String tmp Image Path , Async Method Callback < Host . Async Client . finalize image call > handler ) throws Rpc Exception { ensure Client ( ) ; Finalize Image Request finalize Image Request = new Finalize Image Request ( ) ; finalize Image Request . set Image id ( image Id ) ; finalize Image Request . set Datastore ( datastore ) ; finalize Image Request . set Tmp image path ( tmp Image Path ) ; client Proxy . set Timeout ( FINALIZE IMAGE TIMEOUT MS ) ; logger . info ( STRING , get Host Ip ( ) , finalize Image Request ) ; try { client Proxy . finalize image ( finalize Image Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
private Point add Point ( Polygon arrow , Rectangle rect , int pos , boolean from ) { int x = rect . x ; int y = rect . y ; Point point = null ; if ( pos == Swing Constants . TOP ) { x += rect . width / NUM ; if ( from ) { arrow . add Point ( x - NUM , y ) ; arrow . add Point ( x + NUM , y ) ; } else arrow . add Point ( x , y ) ; point = new Point ( x , y - NUM ) ; } else if ( pos == Swing Constants . RIGHT ) { x += rect . width ; y += rect . height / NUM ; if ( from ) { arrow . add Point ( x , y - NUM ) ; arrow . add Point ( x , y + NUM ) ; } else arrow . add Point ( x , y ) ; point = new Point ( x + NUM , y ) ; } else if ( pos == Swing Constants . LEFT ) { y += rect . height / NUM ; if ( from ) { arrow . add Point ( x , y - NUM ) ; arrow . add Point ( x , y + NUM ) ; } else arrow . add Point ( x , y ) ; point = new Point ( x - NUM , y ) ; } else { x += rect . width / NUM ; y += rect . height ; if ( from ) { arrow . add Point ( x - NUM , y ) ; arrow . add Point ( x + NUM , y ) ; } else arrow . add Point ( x , y ) ; point = new Point ( x , y + NUM ) ; } return point ; }
public void add Members ( String universal Id , Set names ) throws AM Console Exception { if ( ( names == null ) || names . is Empty ( ) ) { throw new AM Console Exception ( STRING ) ; } SSO Token sso Token = get User SSO Token ( ) ; String current Id = STRING ; try { AM Identity amid = Id Utils . get Identity ( sso Token , universal Id ) ; String [ ] params = new String [ NUM ] ; params [ NUM ] = universal Id ; for ( Iterator iter = names . iterator ( ) ; iter . has Next ( ) ; ) { String id = ( String ) iter . next ( ) ; AM Identity amidentity = Id Utils . get Identity ( sso Token , id ) ; current Id = id ; params [ NUM ] = id ; log Event ( STRING , params ) ; amid . add Member ( amidentity ) ; log Event ( STRING , params ) ; } } catch ( SSO Exception e ) { String [ ] params Ex = { universal Id , current Id , get Error String ( e ) } ; log Event ( STRING , params Ex ) ; debug . warning ( STRING , e ) ; throw new AM Console Exception ( get Error String ( e ) ) ; } catch ( Id Repo Exception e ) { String [ ] params Ex = { universal Id , current Id , get Error String ( e ) } ; log Event ( STRING , params Ex ) ; debug . warning ( STRING , e ) ; throw new AM Console Exception ( get Error String ( e ) ) ; } }
public boolean reset Unread Counts ( int a Section ) { boolean ret Code = BOOL ; Array List < Room Summary > summaries List = m Summary List By Group Position . get ( a Section ) ; if ( null != summaries List ) { for ( int summary Idx = NUM ; summary Idx < summaries List . size ( ) ; summary Idx ++ ) { ret Code |= reset Unread Count ( a Section , summary Idx ) ; } } else { Log . w ( DBG CLASS NAME , STRING + a Section + STRING ) ; } return ret Code ; }
public boolean reset Unread Counts ( int a Section ) { boolean ret Code = BOOL ; Array List < Room Summary > summaries List = m Summary List By Group Position . get ( a Section ) ; if ( null != summaries List ) { for ( int summary Idx = NUM ; summary Idx < summaries List . size ( ) ; summary Idx ++ ) { ret Code |= reset Unread Count ( a Section , summary Idx ) ; } } else { Log . w ( DBG CLASS NAME , STRING + a Section + STRING ) ; } return ret Code ; }
@ Override public void event Happened ( Map Event event ) { if ( event . get Type ( ) == Map Event . Type . MAP CLEARED || event . get Type ( ) == Map Event . Type . MAP NEW ) { entity Finder = null ; update Results ( BOOL ) ; } }
@ Override public void restore Snapshot ( Block Snapshot snapshot , Volume parent Volume , String sync Direction , String task Id ) { Block Orchestration Controller controller = get Controller ( Block Orchestration Controller . class , Block Orchestration Controller . BLOCK ORCHESTRATION DEVICE ) ; controller . restore Volume ( snapshot . get Storage Controller ( ) , parent Volume . get Pool ( ) , parent Volume . get Id ( ) , snapshot . get Id ( ) , sync Direction , task Id ) ; }
public static long period End ( long now , long period ) { Local Date Time time = Local Date Time . of Epoch Second ( now / NUM , NUM , Zone Offset . UTC ) ; long end Time = period End ( now , period , time ) ; return end Time ; }
public static Vec mean Vector ( Data Set data Set ) { Dense Vector dv = new Dense Vector ( data Set . get Num Numerical Vars ( ) ) ; mean Vector ( dv , data Set ) ; return dv ; }
public Command Line Files ( String list File Flag , String single Input Flag , File Constraint ... constraints ) { this ( list File Flag , single Input Flag ) ; m Constraints . add All ( Arrays . as List ( constraints ) ) ; }
private static Paint darker Linear Gradient Paint ( Linear Gradient Paint paint ) { final Color [ ] paint Colors = paint . get Colors ( ) ; for ( int i = NUM ; i < paint Colors . length ; i ++ ) { paint Colors [ i ] = darker ( paint Colors [ i ] ) ; } return new Linear Gradient Paint ( paint . get Start Point ( ) , paint . get End Point ( ) , paint . get Fractions ( ) , paint Colors , paint . get Cycle Method ( ) , paint . get Color Space ( ) , paint . get Transform ( ) ) ; }
Parse Result ( Throwable throwable ) { this ( Optional . empty ( ) , singleton List ( new Problem ( throwable . get Message ( ) , Optional . empty ( ) , Optional . of ( throwable ) ) ) , Optional . empty ( ) , Optional . empty ( ) ) ; }
Parse Result ( Throwable throwable ) { this ( Optional . empty ( ) , singleton List ( new Problem ( throwable . get Message ( ) , Optional . empty ( ) , Optional . of ( throwable ) ) ) , Optional . empty ( ) , Optional . empty ( ) ) ; }
Log create Log From Class Name ( String class Label ) throws Exception { Class < ? > clazz = Class . for Name ( log Class Name ) ; @ Suppress Warnings ( STRING ) Constructor < Log > constructor = ( Constructor < Log > ) clazz . get Constructor ( String . class ) ; return constructor . new Instance ( class Label ) ; }
Log create Log From Class Name ( String class Label ) throws Exception { Class < ? > clazz = Class . for Name ( log Class Name ) ; @ Suppress Warnings ( STRING ) Constructor < Log > constructor = ( Constructor < Log > ) clazz . get Constructor ( String . class ) ; return constructor . new Instance ( class Label ) ; }
public static String to String ( Byte Buffer bb ) { return bb == null ? null : to String ( bb . array ( ) , bb . array Offset ( ) + bb . position ( ) , bb . remaining ( ) ) ; }
public static String to String ( Byte Buffer bb ) { return bb == null ? null : to String ( bb . array ( ) , bb . array Offset ( ) + bb . position ( ) , bb . remaining ( ) ) ; }
protected boolean is Valid Default Value ( String default Spec , int type Code ) { return ( default Spec != null ) && ( ( default Spec . length ( ) > NUM ) || ( ! Type Map . is Numeric Type ( type Code ) && ! Type Map . is Date Time Type ( type Code ) ) ) ; }
protected boolean is Valid Default Value ( String default Spec , int type Code ) { return ( default Spec != null ) && ( ( default Spec . length ( ) > NUM ) || ( ! Type Map . is Numeric Type ( type Code ) && ! Type Map . is Date Time Type ( type Code ) ) ) ; }
private String schema ( @ Nullable String space ) { return empty If Null ( space 2 schema . get ( empty If Null ( space ) ) ) ; }
private static int detect Texture Pack Format ( File zipfile ) throws IO Exception { Zip Input Stream zis = null ; try { zis = new Zip Input Stream ( new File Input Stream ( zipfile ) ) ; boolean found Assets Dir = BOOL ; boolean found Blocks Dir = BOOL ; boolean found Terrain Png = BOOL ; Zip Entry entry = null ; while ( ( entry = zis . get Next Entry ( ) ) != null ) { String entry Name = entry . get Name ( ) ; if ( entry Name . starts With ( STRING ) ) found Assets Dir = BOOL ; else if ( entry Name . starts With ( STRING ) ) found Blocks Dir = BOOL ; else if ( entry Name . equals ( STRING ) ) found Terrain Png = BOOL ; } return found Assets Dir ? FORMAT 1 6 : found Blocks Dir ? FORMAT 1 5 : found Terrain Png ? FORMAT PRE 1 5 : FORMAT INVALID ; } finally { if ( zis != null ) zis . close ( ) ; } }
public static boolean has Element Child ( Node node ) { Node List nl = node . get Child Nodes ( ) ; Node child = null ; int length = nl . get Length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { child = nl . item ( i ) ; if ( child . get Node Type ( ) == Node . ELEMENT NODE ) { return BOOL ; } } return BOOL ; }
public static Reactive Seq < Integer > range ( final int start , final int end ) { final Reversing Range Int Spliterator range = new Reversing Range Int Spliterator ( start , end , BOOL ) ; return Stream Utils . reactive Seq ( Stream Support . stream ( range , BOOL ) , Optional . of Nullable ( range ) ) ; }
public static Reactive Seq < Integer > range ( final int start , final int end ) { final Reversing Range Int Spliterator range = new Reversing Range Int Spliterator ( start , end , BOOL ) ; return Stream Utils . reactive Seq ( Stream Support . stream ( range , BOOL ) , Optional . of Nullable ( range ) ) ; }
public static Reactive Seq < Integer > range ( final int start , final int end ) { final Reversing Range Int Spliterator range = new Reversing Range Int Spliterator ( start , end , BOOL ) ; return Stream Utils . reactive Seq ( Stream Support . stream ( range , BOOL ) , Optional . of Nullable ( range ) ) ; }
public static Reactive Seq < Integer > range ( final int start , final int end ) { final Reversing Range Int Spliterator range = new Reversing Range Int Spliterator ( start , end , BOOL ) ; return Stream Utils . reactive Seq ( Stream Support . stream ( range , BOOL ) , Optional . of Nullable ( range ) ) ; }
public void remove All I Narc Pods ( ) { i Narc Pods . clear ( ) ; }
public static int hash ( String key , int bit Size , String input , String hash Type ) { int bit Limited Hash ; try { Message Digest md = Message Digest . get Instance ( hash Type ) ; byte [ ] array = md . digest ( input . get Bytes ( ) ) ; int hash Int = from Byte Array ( array ) ; bit Limited Hash = hash Int ; if ( bit Size < NUM ) { bit Limited Hash = ( NUM > > > ( NUM - bit Size ) ) & hash Int ; } logger . debug ( STRING + hash Int + STRING + bit Limited Hash ) ; } catch ( No Such Algorithm Exception e ) { logger . info ( e . to String ( ) ) ; bit Limited Hash = hash ( key , bit Size , input ) ; } return bit Limited Hash ; }
public boolean add Agent ( I Moving Agent agent ) { if ( ! agents . contains ( agent ) ) { agents . add ( agent ) ; if ( agent instanceof Hive ) { hives . add ( ( Hive ) agent ) ; } if ( agent instanceof Food Source ) { food Sources . add ( ( Food Source ) agent ) ; } if ( agent instanceof Obstacle ) obstacles . add ( ( Obstacle ) agent ) ; double r = agent . get Sphere Radius ( ) ; if ( r > max Agent Sphere Radius ) max Agent Sphere Radius = r ; return BOOL ; } return BOOL ; }
public boolean add Agent ( I Moving Agent agent ) { if ( ! agents . contains ( agent ) ) { agents . add ( agent ) ; if ( agent instanceof Hive ) { hives . add ( ( Hive ) agent ) ; } if ( agent instanceof Food Source ) { food Sources . add ( ( Food Source ) agent ) ; } if ( agent instanceof Obstacle ) obstacles . add ( ( Obstacle ) agent ) ; double r = agent . get Sphere Radius ( ) ; if ( r > max Agent Sphere Radius ) max Agent Sphere Radius = r ; return BOOL ; } return BOOL ; }
public boolean add Agent ( I Moving Agent agent ) { if ( ! agents . contains ( agent ) ) { agents . add ( agent ) ; if ( agent instanceof Hive ) { hives . add ( ( Hive ) agent ) ; } if ( agent instanceof Food Source ) { food Sources . add ( ( Food Source ) agent ) ; } if ( agent instanceof Obstacle ) obstacles . add ( ( Obstacle ) agent ) ; double r = agent . get Sphere Radius ( ) ; if ( r > max Agent Sphere Radius ) max Agent Sphere Radius = r ; return BOOL ; } return BOOL ; }
public boolean add Agent ( I Moving Agent agent ) { if ( ! agents . contains ( agent ) ) { agents . add ( agent ) ; if ( agent instanceof Hive ) { hives . add ( ( Hive ) agent ) ; } if ( agent instanceof Food Source ) { food Sources . add ( ( Food Source ) agent ) ; } if ( agent instanceof Obstacle ) obstacles . add ( ( Obstacle ) agent ) ; double r = agent . get Sphere Radius ( ) ; if ( r > max Agent Sphere Radius ) max Agent Sphere Radius = r ; return BOOL ; } return BOOL ; }
public static byte [ ] from Bit Set ( Schema schema , Bit Set value ) { return value . to Byte Array ( ) ; }
public static byte [ ] from Bit Set ( Schema schema , Bit Set value ) { return value . to Byte Array ( ) ; }
public static void left Shift ( Object Output Stream self , Object value ) throws IO Exception { self . write Object ( value ) ; }
protected void write Progress ( String msg ) { }
public Builder add Generator Loader ( Generator Loader g Loader ) { if ( loaders == null ) { loaders = new Array List < Generator Loader > ( ) ; } if ( g Loader != null ) { loaders . add ( g Loader ) ; } return this ; }
public Builder add Generator Loader ( Generator Loader g Loader ) { if ( loaders == null ) { loaders = new Array List < Generator Loader > ( ) ; } if ( g Loader != null ) { loaders . add ( g Loader ) ; } return this ; }
private void add Finally ( Array List return List , Stmnt finally Block ) throws Compile Error { Bytecode bc = bytecode ; int n = return List . size ( ) ; for ( int i = NUM ; i < n ; ++ i ) { final int [ ] ret = ( int [ ] ) return List . get ( i ) ; int pc = ret [ NUM ] ; bc . write 16 bit ( pc , bc . current Pc ( ) - pc + NUM ) ; Return Hook hook = new Jsr Hook 2 ( this , ret ) ; finally Block . accept ( this ) ; hook . remove ( this ) ; if ( ! has Returned ) { bc . add Opcode ( Opcode . GOTO ) ; bc . add Index ( pc + NUM - bc . current Pc ( ) ) ; } } }
public void test Merge One Servlet With One Mapping Into Empty Document ( ) throws Exception { String src Xml = STRING ; Web Xml src Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( src Xml . get Bytes ( STRING ) ) , null ) ; String merge Xml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml merge Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( merge Xml . get Bytes ( STRING ) ) , null ) ; Web Xml Merger merger = new Web Xml Merger ( src Web Xml ) ; merger . merge ( merge Web Xml ) ; assert True ( Web Xml Utils . has Servlet ( src Web Xml , STRING ) ) ; List < String > servlet Mappings = Web Xml Utils . get Servlet Mappings ( src Web Xml , STRING ) ; assert Equals ( NUM , servlet Mappings . size ( ) ) ; assert Equals ( STRING , servlet Mappings . get ( NUM ) ) ; }
public String pop And Encode As Js ( ) { synchronized ( this ) { int length = queue . size ( ) ; if ( length == NUM ) { return null ; } int total Payload Len = NUM ; int num Messages To Send = NUM ; for ( Js Message message : queue ) { int message Size = message . calculate Encoded Length ( ) + NUM ; if ( num Messages To Send > NUM && total Payload Len + message Size > MAX PAYLOAD SIZE && MAX PAYLOAD SIZE > NUM ) { break ; } total Payload Len += message Size ; num Messages To Send += NUM ; } boolean will Send All Messages = num Messages To Send == queue . size ( ) ; String Builder sb = new String Builder ( total Payload Len + ( will Send All Messages ? NUM : NUM ) ) ; for ( int i = NUM ; i < num Messages To Send ; ++ i ) { Js Message message = queue . remove First ( ) ; if ( will Send All Messages && ( i + NUM == num Messages To Send ) ) { message . encode As Js Message ( sb ) ; } else { sb . append ( STRING ) ; message . encode As Js Message ( sb ) ; sb . append ( STRING ) ; } } if ( ! will Send All Messages ) { sb . append ( STRING ) ; } for ( int i = will Send All Messages ? NUM : NUM ; i < num Messages To Send ; ++ i ) { sb . append ( STRING ) ; } String ret = sb . to String ( ) ; return ret ; } }
public Service Call < Translation Result > translate ( final String text , final String model Id ) { return translate ( Collections . singleton List ( text ) , model Id ) ; }
public Service Call < Translation Result > translate ( final String text , final String model Id ) { return translate ( Collections . singleton List ( text ) , model Id ) ; }
@ Override public void write ( char [ ] cbuf , int off , int len ) throws IO Exception { if ( len <= NUM ) { return ; } if ( chars Since Newline > NUM ) { if ( cbuf [ off ] != CARRIAGE RETURN ) { super . write ( NEWLINEC , NUM , NEWLINEC . length ) ; chars Since Newline = NUM ; } else { int nonnl = count Non Newline ( cbuf , off + NUM , len - NUM ) ; if ( nonnl < chars Since Newline ) { super . write ( CARRIAGE RETURN ) ; while ( chars Since Newline > NUM ) { final int n = Math . min ( chars Since Newline , WHITESPACE . length ( ) ) ; super . write ( WHITESPACE , NUM , n ) ; chars Since Newline -= n ; } } else { chars Since Newline = NUM ; } } } chars Since Newline = tailing Non Newline ( cbuf , off , len ) ; super . write ( cbuf , off , len ) ; flush ( ) ; }
@ Override public void write ( char [ ] cbuf , int off , int len ) throws IO Exception { if ( len <= NUM ) { return ; } if ( chars Since Newline > NUM ) { if ( cbuf [ off ] != CARRIAGE RETURN ) { super . write ( NEWLINEC , NUM , NEWLINEC . length ) ; chars Since Newline = NUM ; } else { int nonnl = count Non Newline ( cbuf , off + NUM , len - NUM ) ; if ( nonnl < chars Since Newline ) { super . write ( CARRIAGE RETURN ) ; while ( chars Since Newline > NUM ) { final int n = Math . min ( chars Since Newline , WHITESPACE . length ( ) ) ; super . write ( WHITESPACE , NUM , n ) ; chars Since Newline -= n ; } } else { chars Since Newline = NUM ; } } } chars Since Newline = tailing Non Newline ( cbuf , off , len ) ; super . write ( cbuf , off , len ) ; flush ( ) ; }
@ Override public void write ( char [ ] cbuf , int off , int len ) throws IO Exception { if ( len <= NUM ) { return ; } if ( chars Since Newline > NUM ) { if ( cbuf [ off ] != CARRIAGE RETURN ) { super . write ( NEWLINEC , NUM , NEWLINEC . length ) ; chars Since Newline = NUM ; } else { int nonnl = count Non Newline ( cbuf , off + NUM , len - NUM ) ; if ( nonnl < chars Since Newline ) { super . write ( CARRIAGE RETURN ) ; while ( chars Since Newline > NUM ) { final int n = Math . min ( chars Since Newline , WHITESPACE . length ( ) ) ; super . write ( WHITESPACE , NUM , n ) ; chars Since Newline -= n ; } } else { chars Since Newline = NUM ; } } } chars Since Newline = tailing Non Newline ( cbuf , off , len ) ; super . write ( cbuf , off , len ) ; flush ( ) ; }
protected void process ( Iterator < I Path ID > csv Sorted , Iterator < I Path ID > db Sorted ) { I Path ID db = get Next ( db Sorted ) ; String db Path = get Name Without Ext ( db ) ; I Path ID csv = get Next ( csv Sorted ) ; String csv Path = get Name Without Ext ( csv ) ; boolean found = BOOL ; while ( ( db Path != null ) && ( csv Path != null ) ) { int compare Result = db Path . compare To ( csv Path ) ; if ( compare Result == NUM ) { process ( csv , db . get ID ( ) ) ; csv = get Next ( csv Sorted ) ; csv Path = get Name Without Ext ( csv ) ; found = BOOL ; } else if ( compare Result < NUM ) { db = get Next ( csv Sorted ) ; db Path = get Name Without Ext ( db ) ; } else { if ( ! found ) { process ( csv , null ) ; } csv = get Next ( csv Sorted ) ; csv Path = get Name Without Ext ( csv ) ; found = BOOL ; } } }
@ Override public void update After Delete ( int old Ncol , Header hdr ) throws Fits Exception { hdr . add Value ( NAXIS 1 , this . row Len ) ; }
@ Override public void update After Delete ( int old Ncol , Header hdr ) throws Fits Exception { hdr . add Value ( NAXIS 1 , this . row Len ) ; }
public static int convert SRG Bto Linear RGB ( int color ) { float input , output ; input = color / NUM ; if ( input <= NUM ) { output = input / NUM ; } else { output = ( float ) Math . pow ( ( input + NUM ) / NUM , NUM ) ; } return Math . round ( output * NUM ) ; }
public static int convert SRG Bto Linear RGB ( int color ) { float input , output ; input = color / NUM ; if ( input <= NUM ) { output = input / NUM ; } else { output = ( float ) Math . pow ( ( input + NUM ) / NUM , NUM ) ; } return Math . round ( output * NUM ) ; }
public static final int binary Search ( Object [ ] a , Object key , Comparator cp , int length ) { int x1 = NUM ; int x2 = length ; int i = x2 / NUM , c ; while ( x1 < x2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == NUM ) { return i ; } else if ( c < NUM ) { x1 = i + NUM ; } else { x2 = i ; } i = x1 + ( x2 - x1 ) / NUM ; } return - NUM * ( i + NUM ) ; }
public static final int binary Search ( Object [ ] a , Object key , Comparator cp , int length ) { int x1 = NUM ; int x2 = length ; int i = x2 / NUM , c ; while ( x1 < x2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == NUM ) { return i ; } else if ( c < NUM ) { x1 = i + NUM ; } else { x2 = i ; } i = x1 + ( x2 - x1 ) / NUM ; } return - NUM * ( i + NUM ) ; }
public static final int binary Search ( Object [ ] a , Object key , Comparator cp , int length ) { int x1 = NUM ; int x2 = length ; int i = x2 / NUM , c ; while ( x1 < x2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == NUM ) { return i ; } else if ( c < NUM ) { x1 = i + NUM ; } else { x2 = i ; } i = x1 + ( x2 - x1 ) / NUM ; } return - NUM * ( i + NUM ) ; }
public static Boolean is Lock Grantor ( String service Name ) { D Lock Service service = ( D Lock Service ) Distributed Lock Service . get Service Named ( service Name ) ; assert Not Null ( service ) ; Boolean result = Boolean . value Of ( service . is Lock Grantor ( ) ) ; log Info ( STRING + result ) ; return result ; }
protected void reset XML 11 ( ) throws XNI Exception { int count = fXML 11 Components . size ( ) ; for ( int i = NUM ; i < count ; i ++ ) { XML Component c = ( XML Component ) fXML 11 Components . get ( i ) ; c . reset ( this ) ; } }
protected void reset XML 11 ( ) throws XNI Exception { int count = fXML 11 Components . size ( ) ; for ( int i = NUM ; i < count ; i ++ ) { XML Component c = ( XML Component ) fXML 11 Components . get ( i ) ; c . reset ( this ) ; } }
private static String pad Right ( String s , int min Length ) { return String . format ( STRING + min Length + STRING , s ) ; }
private Chart Span < Integer > calculate All Pairs Shortest Path ( ) { Chart Span < Integer > distance = new Chart Span < > ( nodes . size ( ) - NUM , Integer . MAX VALUE ) ; distance . set Diagonal ( NUM ) ; for ( Node < Value > tail : nodes ) { for ( Arc < Value > arc : tail . get Outgoing Arcs ( ) ) { Node < Value > head = arc . get Head ( ) ; distance . set ( tail . id ( ) , head . id ( ) , NUM ) ; } } int size = nodes . size ( ) ; for ( int width = NUM ; width <= size ; width ++ ) { for ( int i = NUM ; i < size - width ; i ++ ) { int j = i + width ; for ( int k = i + NUM ; k < j ; k ++ ) { distance . set ( i , j , Math . min ( distance . get ( i , j ) , distance . get ( i , k ) + distance . get ( k , j ) ) ) ; } } } return distance ; }
private Chart Span < Integer > calculate All Pairs Shortest Path ( ) { Chart Span < Integer > distance = new Chart Span < > ( nodes . size ( ) - NUM , Integer . MAX VALUE ) ; distance . set Diagonal ( NUM ) ; for ( Node < Value > tail : nodes ) { for ( Arc < Value > arc : tail . get Outgoing Arcs ( ) ) { Node < Value > head = arc . get Head ( ) ; distance . set ( tail . id ( ) , head . id ( ) , NUM ) ; } } int size = nodes . size ( ) ; for ( int width = NUM ; width <= size ; width ++ ) { for ( int i = NUM ; i < size - width ; i ++ ) { int j = i + width ; for ( int k = i + NUM ; k < j ; k ++ ) { distance . set ( i , j , Math . min ( distance . get ( i , j ) , distance . get ( i , k ) + distance . get ( k , j ) ) ) ; } } } return distance ; }
private SSL Engine Result unwrap ( ) throws SSL Exception { if ( app Buffer == null ) { app Buffer = Io Buffer . allocate ( in Net Buffer . remaining ( ) ) ; } else { app Buffer . expand ( in Net Buffer . remaining ( ) ) ; } SSL Engine Result res ; Status status = null ; Handshake Status handshake Status = null ; do { res = ssl Engine . unwrap ( in Net Buffer . buf ( ) , app Buffer . buf ( ) ) ; status = res . get Status ( ) ; handshake Status = res . get Handshake Status ( ) ; if ( status == Status . BUFFER OVERFLOW ) { app Buffer . capacity ( app Buffer . capacity ( ) << NUM ) ; app Buffer . limit ( app Buffer . capacity ( ) ) ; continue ; } } while ( ( ( status == Status . OK ) || ( status == Status . BUFFER OVERFLOW ) ) && ( ( handshake Status == Handshake Status . NOT HANDSHAKING ) || ( handshake Status == Handshake Status . NEED UNWRAP ) ) ) ; return res ; }
public Timer ( ) { start Time = System . current Time Millis ( ) ; running = BOOL ; }
public void add Listener ( Search Listener listener ) { listeners . add ( listener ) ; }
protected Panel State find Nearest Panel State From Height ( float desired Panel Height ) { Panel State closest Panel State = Panel State . CLOSED ; float smallest Height Diff = Float . POSITIVE INFINITY ; for ( Panel State state : Panel State . values ( ) ) { if ( ! is Valid State ( state ) ) { continue ; } if ( ! is Fullscreen Size Panel ( ) && state == Panel State . EXPANDED ) { continue ; } float height = get Panel Height From State ( state ) ; float height Diff = Math . abs ( desired Panel Height - height ) ; if ( height Diff < smallest Height Diff ) { closest Panel State = state ; smallest Height Diff = height Diff ; } } return closest Panel State ; }
protected Panel State find Nearest Panel State From Height ( float desired Panel Height ) { Panel State closest Panel State = Panel State . CLOSED ; float smallest Height Diff = Float . POSITIVE INFINITY ; for ( Panel State state : Panel State . values ( ) ) { if ( ! is Valid State ( state ) ) { continue ; } if ( ! is Fullscreen Size Panel ( ) && state == Panel State . EXPANDED ) { continue ; } float height = get Panel Height From State ( state ) ; float height Diff = Math . abs ( desired Panel Height - height ) ; if ( height Diff < smallest Height Diff ) { closest Panel State = state ; smallest Height Diff = height Diff ; } } return closest Panel State ; }
protected Panel State find Nearest Panel State From Height ( float desired Panel Height ) { Panel State closest Panel State = Panel State . CLOSED ; float smallest Height Diff = Float . POSITIVE INFINITY ; for ( Panel State state : Panel State . values ( ) ) { if ( ! is Valid State ( state ) ) { continue ; } if ( ! is Fullscreen Size Panel ( ) && state == Panel State . EXPANDED ) { continue ; } float height = get Panel Height From State ( state ) ; float height Diff = Math . abs ( desired Panel Height - height ) ; if ( height Diff < smallest Height Diff ) { closest Panel State = state ; smallest Height Diff = height Diff ; } } return closest Panel State ; }
public static File show Open File ( File Data Store Factory Spi format , Shell parent ) { return show Open File ( format , null , parent ) ; }
protected void process Instance ( Instance instance ) { if ( m current Inst < m Sample Size ) { m sub Sample [ m current Inst ] = ( Instance ) instance . copy ( ) ; } else { double r = m random . next Double ( ) ; if ( r < ( ( double ) m Sample Size / ( double ) m current Inst ) ) { r = m random . next Double ( ) ; int replace = ( int ) ( m Sample Size * r ) ; m sub Sample [ replace ] = ( Instance ) instance . copy ( ) ; } } m current Inst ++ ; }
protected void process Instance ( Instance instance ) { if ( m current Inst < m Sample Size ) { m sub Sample [ m current Inst ] = ( Instance ) instance . copy ( ) ; } else { double r = m random . next Double ( ) ; if ( r < ( ( double ) m Sample Size / ( double ) m current Inst ) ) { r = m random . next Double ( ) ; int replace = ( int ) ( m Sample Size * r ) ; m sub Sample [ replace ] = ( Instance ) instance . copy ( ) ; } } m current Inst ++ ; }
protected void pre Execute ( ) { clear From Cursor ( ) ; if ( cursor >= NUM && cursor <= selections . size ( ) ) { I Selection selection = selection Provider . get Selection ( ) ; selections . add ( cursor , selection ) ; } }
protected void pre Execute ( ) { clear From Cursor ( ) ; if ( cursor >= NUM && cursor <= selections . size ( ) ) { I Selection selection = selection Provider . get Selection ( ) ; selections . add ( cursor , selection ) ; } }
public static Sail create Sail ( final Properties props , final String file , final Option ... args ) { final List < Option > options = args != null ? Arrays . as List ( args ) : new Linked List < Option > ( ) ; check Args ( file , options ) ; if ( file != null ) { props . set Property ( STRING , file ) ; props . set Property ( STRING , STRING ) ; } else { props . set Property ( STRING , STRING ) ; } if ( options . contains ( Option . Inference ) ) { props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; } else { props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; } props . set Property ( STRING , String . value Of ( options . contains ( Option . Text Index ) ) ) ; props . set Property ( STRING , String . value Of ( options . contains ( Option . RDR ) ) ) ; props . set Property ( STRING , String . value Of ( options . contains ( Option . Quads ) ) ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; final Sail sail = get Sail Provider Instance ( props ) ; return sail ; }
public static Sail create Sail ( final Properties props , final String file , final Option ... args ) { final List < Option > options = args != null ? Arrays . as List ( args ) : new Linked List < Option > ( ) ; check Args ( file , options ) ; if ( file != null ) { props . set Property ( STRING , file ) ; props . set Property ( STRING , STRING ) ; } else { props . set Property ( STRING , STRING ) ; } if ( options . contains ( Option . Inference ) ) { props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; } else { props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; } props . set Property ( STRING , String . value Of ( options . contains ( Option . Text Index ) ) ) ; props . set Property ( STRING , String . value Of ( options . contains ( Option . RDR ) ) ) ; props . set Property ( STRING , String . value Of ( options . contains ( Option . Quads ) ) ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; final Sail sail = get Sail Provider Instance ( props ) ; return sail ; }
public static Sail create Sail ( final Properties props , final String file , final Option ... args ) { final List < Option > options = args != null ? Arrays . as List ( args ) : new Linked List < Option > ( ) ; check Args ( file , options ) ; if ( file != null ) { props . set Property ( STRING , file ) ; props . set Property ( STRING , STRING ) ; } else { props . set Property ( STRING , STRING ) ; } if ( options . contains ( Option . Inference ) ) { props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; } else { props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; } props . set Property ( STRING , String . value Of ( options . contains ( Option . Text Index ) ) ) ; props . set Property ( STRING , String . value Of ( options . contains ( Option . RDR ) ) ) ; props . set Property ( STRING , String . value Of ( options . contains ( Option . Quads ) ) ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; final Sail sail = get Sail Provider Instance ( props ) ; return sail ; }
public static double calculate Contrast Ratio ( double lum 1 , double lum 2 ) { if ( ( lum 1 < NUM ) || ( lum 2 < NUM ) ) { throw new Illegal Argument Exception ( STRING ) ; } return ( Math . max ( lum 1 , lum 2 ) + NUM ) / ( Math . min ( lum 1 , lum 2 ) + NUM ) ; }
public String handle Word ( String a Word ) { Matcher m = condition Pattern . matcher ( a Word ) ; if ( m != null && m . matches ( ) ) { if ( type . equals ( Affix Type . PREFIX ) ) { return handle Prefix ( a Word ) ; } else if ( type . equals ( Affix Type . SUFFIX ) ) { return handle Suffix ( a Word ) ; } } return null ; }
private static void autofit ( Text View view , Text Paint paint , float min Text Size , float max Text Size , int max Lines , float precision ) { if ( max Lines <= NUM || max Lines == Integer . MAX VALUE ) { return ; } int target Width = view . get Width ( ) - view . get Padding Left ( ) - view . get Padding Right ( ) ; if ( target Width <= NUM ) { return ; } Char Sequence text = view . get Text ( ) ; Transformation Method method = view . get Transformation Method ( ) ; if ( method != null ) { text = method . get Transformation ( text , view ) ; } Context context = view . get Context ( ) ; Resources r = Resources . get System ( ) ; Display Metrics display Metrics ; float size = max Text Size ; float high = size ; float low = NUM ; if ( context != null ) { r = context . get Resources ( ) ; } display Metrics = r . get Display Metrics ( ) ; paint . set ( view . get Paint ( ) ) ; paint . set Text Size ( size ) ; if ( ( max Lines == NUM && paint . measure Text ( text , NUM , text . length ( ) ) > target Width ) || get Line Count ( text , paint , size , target Width , display Metrics ) > max Lines ) { size = get Autofit Text Size ( text , paint , target Width , max Lines , low , high , precision , display Metrics ) ; } if ( size < min Text Size ) { size = min Text Size ; } view . set Text Size ( Typed Value . COMPLEX UNIT PX , size ) ; }
public Pair < Solr Core , Solr Core > replicate To Destination ( Solr Core bestsrc Core , Solr Core destination Core ) throws Exception { Pair < Solr Core , Solr Core > replication Request Pair = null ; try { Solr Interaction Utils . replicate Index ( destination Core . host , destination Core . name , bestsrc Core . host , bestsrc Core . name ) ; String full Replication = STRING ; String replicator = String . format ( full Replication , destination Core . host , Solr Interaction Utils . DEFAULT SOLR PORT , destination Core . name , bestsrc Core . host , Solr Interaction Utils . DEFAULT SOLR PORT , bestsrc Core . name ) ; logger . info ( STRING + replicator ) ; replication Request Pair = new Pair < Solr Core , Solr Core > ( destination Core , bestsrc Core ) ; logger . info ( STRING + destination Core . host + STRING + destination Core . name + STRING + bestsrc Core . host + STRING + bestsrc Core . name ) ; } catch ( Exception e ) { logger . info ( STRING + destination Core . host + STRING + bestsrc Core . host ) ; if ( ! replicator Config . should Skip Replication Failures ( ) ) { throw new Replication Failure Exception ( STRING + destination Core . host + STRING + bestsrc Core . host ) ; } } return replication Request Pair ; }
public Pair < Solr Core , Solr Core > replicate To Destination ( Solr Core bestsrc Core , Solr Core destination Core ) throws Exception { Pair < Solr Core , Solr Core > replication Request Pair = null ; try { Solr Interaction Utils . replicate Index ( destination Core . host , destination Core . name , bestsrc Core . host , bestsrc Core . name ) ; String full Replication = STRING ; String replicator = String . format ( full Replication , destination Core . host , Solr Interaction Utils . DEFAULT SOLR PORT , destination Core . name , bestsrc Core . host , Solr Interaction Utils . DEFAULT SOLR PORT , bestsrc Core . name ) ; logger . info ( STRING + replicator ) ; replication Request Pair = new Pair < Solr Core , Solr Core > ( destination Core , bestsrc Core ) ; logger . info ( STRING + destination Core . host + STRING + destination Core . name + STRING + bestsrc Core . host + STRING + bestsrc Core . name ) ; } catch ( Exception e ) { logger . info ( STRING + destination Core . host + STRING + bestsrc Core . host ) ; if ( ! replicator Config . should Skip Replication Failures ( ) ) { throw new Replication Failure Exception ( STRING + destination Core . host + STRING + bestsrc Core . host ) ; } } return replication Request Pair ; }
private void enlarge Capacity ( int key ) { int diff = off Count - offset ; int min Capacity = Math . max ( arr . length , key + offset + diff + NUM ) ; if ( min Capacity > arr . length ) { int old Capacity = arr . length ; int new Capacity = old Capacity + ( old Capacity > > NUM ) ; if ( new Capacity - min Capacity < NUM ) new Capacity = min Capacity ; if ( new Capacity - MAX ARRAY SIZE > NUM ) new Capacity = huge Capacity ( min Capacity ) ; arr = Arrays . copy Of ( arr , new Capacity ) ; } }
private void enlarge Capacity ( int key ) { int diff = off Count - offset ; int min Capacity = Math . max ( arr . length , key + offset + diff + NUM ) ; if ( min Capacity > arr . length ) { int old Capacity = arr . length ; int new Capacity = old Capacity + ( old Capacity > > NUM ) ; if ( new Capacity - min Capacity < NUM ) new Capacity = min Capacity ; if ( new Capacity - MAX ARRAY SIZE > NUM ) new Capacity = huge Capacity ( min Capacity ) ; arr = Arrays . copy Of ( arr , new Capacity ) ; } }
@ Override public int compare To ( Projected Energy o ) { return Double . compare ( projected Energy , o . projected Energy ) ; }
@ Override public void compute ( ) { Spliterator < P IN > rs = spliterator , ls ; long size Estimate = rs . estimate Size ( ) ; long size Threshold = get Target Size ( size Estimate ) ; boolean fork Right = BOOL ; @ Suppress Warnings ( STRING ) K task = ( K ) this ; Atomic Reference < R > sr = shared Result ; R result ; while ( ( result = sr . get ( ) ) == null ) { if ( task . task Canceled ( ) ) { result = task . get Empty Result ( ) ; break ; } if ( size Estimate <= size Threshold || ( ls = rs . try Split ( ) ) == null ) { result = task . do Leaf ( ) ; break ; } K left Child , right Child , task To Fork ; task . left Child = left Child = task . make Child ( ls ) ; task . right Child = right Child = task . make Child ( rs ) ; task . set Pending Count ( NUM ) ; if ( fork Right ) { fork Right = BOOL ; rs = ls ; task = left Child ; task To Fork = right Child ; } else { fork Right = BOOL ; task = right Child ; task To Fork = left Child ; } task To Fork . fork ( ) ; size Estimate = rs . estimate Size ( ) ; } task . set Local Result ( result ) ; task . try Complete ( ) ; }
@ Override public void compute ( ) { Spliterator < P IN > rs = spliterator , ls ; long size Estimate = rs . estimate Size ( ) ; long size Threshold = get Target Size ( size Estimate ) ; boolean fork Right = BOOL ; @ Suppress Warnings ( STRING ) K task = ( K ) this ; Atomic Reference < R > sr = shared Result ; R result ; while ( ( result = sr . get ( ) ) == null ) { if ( task . task Canceled ( ) ) { result = task . get Empty Result ( ) ; break ; } if ( size Estimate <= size Threshold || ( ls = rs . try Split ( ) ) == null ) { result = task . do Leaf ( ) ; break ; } K left Child , right Child , task To Fork ; task . left Child = left Child = task . make Child ( ls ) ; task . right Child = right Child = task . make Child ( rs ) ; task . set Pending Count ( NUM ) ; if ( fork Right ) { fork Right = BOOL ; rs = ls ; task = left Child ; task To Fork = right Child ; } else { fork Right = BOOL ; task = right Child ; task To Fork = left Child ; } task To Fork . fork ( ) ; size Estimate = rs . estimate Size ( ) ; } task . set Local Result ( result ) ; task . try Complete ( ) ; }
@ Override public void compute ( ) { Spliterator < P IN > rs = spliterator , ls ; long size Estimate = rs . estimate Size ( ) ; long size Threshold = get Target Size ( size Estimate ) ; boolean fork Right = BOOL ; @ Suppress Warnings ( STRING ) K task = ( K ) this ; Atomic Reference < R > sr = shared Result ; R result ; while ( ( result = sr . get ( ) ) == null ) { if ( task . task Canceled ( ) ) { result = task . get Empty Result ( ) ; break ; } if ( size Estimate <= size Threshold || ( ls = rs . try Split ( ) ) == null ) { result = task . do Leaf ( ) ; break ; } K left Child , right Child , task To Fork ; task . left Child = left Child = task . make Child ( ls ) ; task . right Child = right Child = task . make Child ( rs ) ; task . set Pending Count ( NUM ) ; if ( fork Right ) { fork Right = BOOL ; rs = ls ; task = left Child ; task To Fork = right Child ; } else { fork Right = BOOL ; task = right Child ; task To Fork = left Child ; } task To Fork . fork ( ) ; size Estimate = rs . estimate Size ( ) ; } task . set Local Result ( result ) ; task . try Complete ( ) ; }
public void test Insert 1 ( ) throws SQL Exception { Database Creator . fill Parent Table ( conn ) ; Database Creator . fill FK Strict Table ( conn ) ; Database Creator . fill FK Cascade Table ( conn ) ; statement . execute ( STRING + Database Creator . FKSTRICT TABLE + STRING ) ; statement . execute ( STRING + Database Creator . FKCASCADE TABLE + STRING ) ; }
public static String java Name To Db Name ( String java Name ) { if ( java Name == null ) return null ; if ( java Name . length ( ) <= NUM ) return STRING ; String Builder db Name = new String Builder ( ) ; db Name . append ( Character . to Upper Case ( java Name . char At ( NUM ) ) ) ; int name Pos = NUM ; while ( name Pos < java Name . length ( ) ) { char cur Char = java Name . char At ( name Pos ) ; if ( Character . is Upper Case ( cur Char ) ) db Name . append ( STRING ) ; db Name . append ( Character . to Upper Case ( cur Char ) ) ; name Pos ++ ; } return db Name . to String ( ) ; }
public static String java Name To Db Name ( String java Name ) { if ( java Name == null ) return null ; if ( java Name . length ( ) <= NUM ) return STRING ; String Builder db Name = new String Builder ( ) ; db Name . append ( Character . to Upper Case ( java Name . char At ( NUM ) ) ) ; int name Pos = NUM ; while ( name Pos < java Name . length ( ) ) { char cur Char = java Name . char At ( name Pos ) ; if ( Character . is Upper Case ( cur Char ) ) db Name . append ( STRING ) ; db Name . append ( Character . to Upper Case ( cur Char ) ) ; name Pos ++ ; } return db Name . to String ( ) ; }
public static String java Name To Db Name ( String java Name ) { if ( java Name == null ) return null ; if ( java Name . length ( ) <= NUM ) return STRING ; String Builder db Name = new String Builder ( ) ; db Name . append ( Character . to Upper Case ( java Name . char At ( NUM ) ) ) ; int name Pos = NUM ; while ( name Pos < java Name . length ( ) ) { char cur Char = java Name . char At ( name Pos ) ; if ( Character . is Upper Case ( cur Char ) ) db Name . append ( STRING ) ; db Name . append ( Character . to Upper Case ( cur Char ) ) ; name Pos ++ ; } return db Name . to String ( ) ; }
public static String java Name To Db Name ( String java Name ) { if ( java Name == null ) return null ; if ( java Name . length ( ) <= NUM ) return STRING ; String Builder db Name = new String Builder ( ) ; db Name . append ( Character . to Upper Case ( java Name . char At ( NUM ) ) ) ; int name Pos = NUM ; while ( name Pos < java Name . length ( ) ) { char cur Char = java Name . char At ( name Pos ) ; if ( Character . is Upper Case ( cur Char ) ) db Name . append ( STRING ) ; db Name . append ( Character . to Upper Case ( cur Char ) ) ; name Pos ++ ; } return db Name . to String ( ) ; }
@ Override public synchronized void clear ( ) { File [ ] files = m Root Directory . list Files ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } m Entries . clear ( ) ; m Total Size = NUM ; Volley Log . d ( STRING ) ; }
@ Override public synchronized void clear ( ) { File [ ] files = m Root Directory . list Files ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } m Entries . clear ( ) ; m Total Size = NUM ; Volley Log . d ( STRING ) ; }
public static String minus ( Char Sequence self , Object target ) { String s = self . to String ( ) ; String text = Default Groovy Methods . to String ( target ) ; int index = s . index Of ( text ) ; if ( index == - NUM ) return s ; int end = index + text . length ( ) ; if ( s . length ( ) > end ) { return s . substring ( NUM , index ) + s . substring ( end ) ; } return s . substring ( NUM , index ) ; }
public static String minus ( Char Sequence self , Object target ) { String s = self . to String ( ) ; String text = Default Groovy Methods . to String ( target ) ; int index = s . index Of ( text ) ; if ( index == - NUM ) return s ; int end = index + text . length ( ) ; if ( s . length ( ) > end ) { return s . substring ( NUM , index ) + s . substring ( end ) ; } return s . substring ( NUM , index ) ; }
public static String minus ( Char Sequence self , Object target ) { String s = self . to String ( ) ; String text = Default Groovy Methods . to String ( target ) ; int index = s . index Of ( text ) ; if ( index == - NUM ) return s ; int end = index + text . length ( ) ; if ( s . length ( ) > end ) { return s . substring ( NUM , index ) + s . substring ( end ) ; } return s . substring ( NUM , index ) ; }
public static Map < String , Object > update Data Resource And Text ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Map < String , Object > this Result = update Data Resource Method ( dctx , context ) ; if ( this Result . get ( Model Service . RESPONSE MESSAGE ) != null ) { return Service Util . return Error ( ( String ) this Result . get ( Model Service . ERROR MESSAGE ) ) ; } String data Resource Type Id = ( String ) context . get ( STRING ) ; if ( data Resource Type Id != null && data Resource Type Id . equals ( STRING ) ) { this Result = update Electronic Text ( dctx , context ) ; if ( this Result . get ( Model Service . RESPONSE MESSAGE ) != null ) { return Service Util . return Error ( ( String ) this Result . get ( Model Service . ERROR MESSAGE ) ) ; } } return Service Util . return Success ( ) ; }
public void start ( ) throws IO Exception { this . is Running = BOOL ; Thread thread = new Thread ( this ) ; thread . set Daemon ( BOOL ) ; thread . set Name ( STRING ) ; thread . set Priority ( Thread . MAX PRIORITY ) ; thread . start ( ) ; }
public Iterator < Tcp Discovery Abstract Message > iterator ( ) { return new Skip Iterator ( ) ; }
private void add List Parameter ( Daemon Parameters parameters , String parameter Name , List < String > list ) { int i = NUM ; if ( list == null || list . size ( ) == NUM ) { return ; } String Builder list JSON = new String Builder ( ) ; list JSON . append ( STRING ) ; for ( String item : list ) { if ( i != NUM ) { list JSON . append ( STRING ) ; } list JSON . append ( STRING + item + STRING ) ; i ++ ; } list JSON . append ( STRING ) ; parameters . set Parameter ( parameter Name , list JSON . to String ( ) ) ; }
public boolean hle Kernel Un Register Callback ( int callback Type , int cbid ) { boolean found = BOOL ; for ( Sce Kernel Thread Info thread : thread Map . values ( ) ) { Registered Callbacks registered Callbacks = thread . get Registered Callbacks ( callback Type ) ; psp Base Callback callback = registered Callbacks . get Callback Info By Uid ( cbid ) ; if ( callback != null ) { found = BOOL ; if ( registered Callbacks . is Callback Ready ( callback ) ) { log . warn ( STRING + callback Type + STRING ) ; } registered Callbacks . remove Callback ( callback ) ; break ; } } if ( ! found ) { log . warn ( STRING + callback Type + STRING + Integer . to Hex String ( cbid ) + STRING ) ; } return found ; }
protected void compute Tabs That Fit In Composite ( ) { tabs That Fit In Composite = Math . round ( ( get Size ( ) . y - NUM ) / get Tab Height ( ) ) ; if ( tabs That Fit In Composite <= NUM ) { tabs That Fit In Composite = NUM ; } }
protected void compute Tabs That Fit In Composite ( ) { tabs That Fit In Composite = Math . round ( ( get Size ( ) . y - NUM ) / get Tab Height ( ) ) ; if ( tabs That Fit In Composite <= NUM ) { tabs That Fit In Composite = NUM ; } }
protected void compute Tabs That Fit In Composite ( ) { tabs That Fit In Composite = Math . round ( ( get Size ( ) . y - NUM ) / get Tab Height ( ) ) ; if ( tabs That Fit In Composite <= NUM ) { tabs That Fit In Composite = NUM ; } }
public static String dump ( final Config Descriptor descriptor ) { return String . format ( STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING , descriptor . b Length ( ) , descriptor . b Descriptor Type ( ) , descriptor . w Total Length ( ) & NUM , descriptor . b Num Interfaces ( ) & NUM , descriptor . b Configuration Value ( ) & NUM , descriptor . i Configuration ( ) & NUM , String . format ( STRING , descriptor . bm Attributes ( ) & NUM ) , ( ( descriptor . bm Attributes ( ) & NUM ) == NUM ) ? STRING : STRING , ( ( descriptor . bm Attributes ( ) & NUM ) == NUM ) ? STRING : String . format ( STRING ) , ( descriptor . b Max Power ( ) & NUM ) * NUM ) ; }
public static Block Mirror check If Block Mirror Exists In DB ( String mirror Native Guid , Db Client db Client ) { List < Block Mirror > active Mirrors = Custom Query Utility . get Active Block Mirror By Native Guid ( db Client , mirror Native Guid ) ; Iterator < Block Mirror > mirror Itr = active Mirrors . iterator ( ) ; return mirror Itr . has Next ( ) ? mirror Itr . next ( ) : null ; }
public static Block Mirror check If Block Mirror Exists In DB ( String mirror Native Guid , Db Client db Client ) { List < Block Mirror > active Mirrors = Custom Query Utility . get Active Block Mirror By Native Guid ( db Client , mirror Native Guid ) ; Iterator < Block Mirror > mirror Itr = active Mirrors . iterator ( ) ; return mirror Itr . has Next ( ) ? mirror Itr . next ( ) : null ; }
public char [ ] expand Current Segment ( ) { char [ ] curr = current Segment ; int len = curr . length ; int new Len = ( len == MAX SEGMENT LEN ) ? ( MAX SEGMENT LEN + NUM ) : Math . min ( MAX SEGMENT LEN , len + ( len > > NUM ) ) ; current Segment = char Array ( new Len ) ; System . arraycopy ( curr , NUM , current Segment , NUM , len ) ; return current Segment ; }
public char [ ] expand Current Segment ( ) { char [ ] curr = current Segment ; int len = curr . length ; int new Len = ( len == MAX SEGMENT LEN ) ? ( MAX SEGMENT LEN + NUM ) : Math . min ( MAX SEGMENT LEN , len + ( len > > NUM ) ) ; current Segment = char Array ( new Len ) ; System . arraycopy ( curr , NUM , current Segment , NUM , len ) ; return current Segment ; }
private static Date Time Formatter create Formatter For Style ( String style ) { if ( style == null || style . length ( ) != NUM ) { throw new Illegal Argument Exception ( STRING + style ) ; } int date Style = select Style ( style . char At ( NUM ) ) ; int time Style = select Style ( style . char At ( NUM ) ) ; if ( date Style == NONE && time Style == NONE ) { throw new Illegal Argument Exception ( STRING ) ; } return create Formatter For Style Index ( date Style , time Style ) ; }
private static Date Time Formatter create Formatter For Style ( String style ) { if ( style == null || style . length ( ) != NUM ) { throw new Illegal Argument Exception ( STRING + style ) ; } int date Style = select Style ( style . char At ( NUM ) ) ; int time Style = select Style ( style . char At ( NUM ) ) ; if ( date Style == NONE && time Style == NONE ) { throw new Illegal Argument Exception ( STRING ) ; } return create Formatter For Style Index ( date Style , time Style ) ; }
private static String format List ( String [ ] string List , String list Pattern , String list Composition Pattern ) { if ( list Pattern == null || list Composition Pattern == null ) { String Builder result = new String Builder ( ) ; for ( int i = NUM ; i < string List . length ; ++ i ) { if ( i > NUM ) { result . append ( STRING ) ; } result . append ( string List [ i ] ) ; } return result . to String ( ) ; } if ( string List . length > NUM ) { Message Format format = new Message Format ( list Composition Pattern ) ; string List = compose List ( format , string List ) ; } Object [ ] args = new Object [ string List . length + NUM ] ; System . arraycopy ( string List , NUM , args , NUM , string List . length ) ; args [ NUM ] = new Integer ( string List . length ) ; Message Format format = new Message Format ( list Pattern ) ; return format . format ( args ) ; }
public static Configuration load ( Input Stream stream ) throws IO Exception { try { Properties properties = new Properties ( ) ; properties . load ( stream ) ; return from ( properties ) ; } finally { stream . close ( ) ; } }
public static Configuration load ( Input Stream stream ) throws IO Exception { try { Properties properties = new Properties ( ) ; properties . load ( stream ) ; return from ( properties ) ; } finally { stream . close ( ) ; } }
private void perform Drag ( float x ) { float delta X = last Motion X - x ; last Motion X = x ; if ( virtual Pos == NUM ) { if ( delta X < NUM ) { delta X = - delta X ; reverse Pos = BOOL ; } else { reverse Pos = BOOL ; } } else if ( virtual Pos > NUM ) { delta X = - delta X ; reverse Pos = BOOL ; } else { reverse Pos = BOOL ; } float old Scroll X = get Scroll X ( ) ; float scroll X = old Scroll X + delta X ; final int width = get Client Width ( ) ; float left Bound = NUM ; float right Bound = width * last Offset ; final Item Info current Item = info For Position ( this . current Item ) ; final Item Info last Item = items . get ( items . size ( ) - NUM ) ; if ( current Item != null ) { left Bound = current Item . offset * width ; } if ( last Item . position != pager Adapter . get Count ( ) - NUM ) { right Bound = last Item . offset * width ; } if ( scroll X < left Bound ) { scroll X = left Bound ; } else if ( scroll X > right Bound ) { scroll X = right Bound ; } last Motion X += scroll X - ( int ) scroll X ; scroll To ( ( int ) scroll X , get Scroll Y ( ) ) ; page Scrolled ( ( int ) scroll X ) ; }
private void perform Drag ( float x ) { float delta X = last Motion X - x ; last Motion X = x ; if ( virtual Pos == NUM ) { if ( delta X < NUM ) { delta X = - delta X ; reverse Pos = BOOL ; } else { reverse Pos = BOOL ; } } else if ( virtual Pos > NUM ) { delta X = - delta X ; reverse Pos = BOOL ; } else { reverse Pos = BOOL ; } float old Scroll X = get Scroll X ( ) ; float scroll X = old Scroll X + delta X ; final int width = get Client Width ( ) ; float left Bound = NUM ; float right Bound = width * last Offset ; final Item Info current Item = info For Position ( this . current Item ) ; final Item Info last Item = items . get ( items . size ( ) - NUM ) ; if ( current Item != null ) { left Bound = current Item . offset * width ; } if ( last Item . position != pager Adapter . get Count ( ) - NUM ) { right Bound = last Item . offset * width ; } if ( scroll X < left Bound ) { scroll X = left Bound ; } else if ( scroll X > right Bound ) { scroll X = right Bound ; } last Motion X += scroll X - ( int ) scroll X ; scroll To ( ( int ) scroll X , get Scroll Y ( ) ) ; page Scrolled ( ( int ) scroll X ) ; }
protected Object evaluate Single ( List elements , String expr ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new Array List ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . has Next ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof Structured Content ) { if ( ( o = evaluate Single ( ( Structured Content ) o , expr ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM ) { return ( Structured Content ) array . get ( NUM ) ; } return array ; }
protected Object evaluate Single ( List elements , String expr ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new Array List ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . has Next ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof Structured Content ) { if ( ( o = evaluate Single ( ( Structured Content ) o , expr ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM ) { return ( Structured Content ) array . get ( NUM ) ; } return array ; }
protected Object evaluate Single ( List elements , String expr ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new Array List ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . has Next ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof Structured Content ) { if ( ( o = evaluate Single ( ( Structured Content ) o , expr ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM ) { return ( Structured Content ) array . get ( NUM ) ; } return array ; }
protected Object evaluate Single ( List elements , String expr ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new Array List ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . has Next ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof Structured Content ) { if ( ( o = evaluate Single ( ( Structured Content ) o , expr ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM ) { return ( Structured Content ) array . get ( NUM ) ; } return array ; }
protected Object evaluate Single ( List elements , String expr ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new Array List ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . has Next ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof Structured Content ) { if ( ( o = evaluate Single ( ( Structured Content ) o , expr ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM ) { return ( Structured Content ) array . get ( NUM ) ; } return array ; }
private synchronized void update Container XML ( ) throws IO Exception , Parser Configuration Exception { synchronized ( lock ) { if ( container Entry == null ) return ; } if ( m Container File != null && ! m Container File . exists ( ) ) { m Container File . create New File ( ) ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + m Container File + STRING + container Name + STRING ) ; } } Document Builder Factory factory = Document Builder Factory . new Instance ( ) ; Document Builder builder = factory . new Document Builder ( ) ; m container File Document = builder . new Document ( ) ; m root Container Element = m container File Document . create Element ( container Name ) ; m root Space Element = m container File Document . create Element ( SPACE TAG ) ; m root Container Element . append Child ( m root Space Element ) ; synchronized ( lock ) { if ( container Entry != null ) update Container XML Tree ( container Entry . get Name ( ) , container Entry . get Space Attributes ( ) ) ; } save State ( ) ; }
public static int create With Id Generation ( Connection connection , String raw Sql Query , Object ... parameters ) throws SQL Exception { Prepared Statement stmt = null ; Result Set rs = null ; try { stmt = connection . prepare Statement ( raw Sql Query , Statement . RETURN GENERATED KEYS ) ; for ( int index = NUM ; index < parameters . length ; index ++ ) { Jdbc Utils . bind Parameter ( stmt , index + NUM , parameters [ index ] ) ; } stmt . execute Update ( ) ; rs = stmt . get Generated Keys ( ) ; rs . next ( ) ; return rs . get Int ( NUM ) ; } finally { Jdbc Utils . close Result Set ( rs ) ; Jdbc Utils . close Statement ( stmt ) ; } }
private String Builder generate Parameters ( ) { String Builder parameters = new String Builder ( ) ; if ( filter Map == null && expand Parameters == null ) { return parameters ; } parameters . append ( STRING ) ; int filter Parameter Counter = NUM ; if ( filter Map != null && ! filter Map . is Empty ( ) ) { parameters . append ( FILTER PREFIX ) ; for ( Map . Entry < String , String > filter Entry : filter Map . entry Set ( ) ) { parameters . append ( String . format ( STRING , filter Entry . get Key ( ) , filter Entry . get Value ( ) ) ) ; if ( ++ filter Parameter Counter < filter Map . size ( ) ) { parameters . append ( STRING ) ; } } if ( expand Parameters != null ) { parameters . append ( STRING ) ; } } if ( expand Parameters != null ) { parameters . append ( EXPAND PREFIX ) ; Iterator iterator = expand Parameters . iterator ( ) ; parameters . append ( String . format ( STRING , iterator . next ( ) ) ) ; while ( iterator . has Next ( ) ) { parameters . append ( String . format ( STRING , iterator . next ( ) ) ) ; } } return parameters ; }
private String Builder generate Parameters ( ) { String Builder parameters = new String Builder ( ) ; if ( filter Map == null && expand Parameters == null ) { return parameters ; } parameters . append ( STRING ) ; int filter Parameter Counter = NUM ; if ( filter Map != null && ! filter Map . is Empty ( ) ) { parameters . append ( FILTER PREFIX ) ; for ( Map . Entry < String , String > filter Entry : filter Map . entry Set ( ) ) { parameters . append ( String . format ( STRING , filter Entry . get Key ( ) , filter Entry . get Value ( ) ) ) ; if ( ++ filter Parameter Counter < filter Map . size ( ) ) { parameters . append ( STRING ) ; } } if ( expand Parameters != null ) { parameters . append ( STRING ) ; } } if ( expand Parameters != null ) { parameters . append ( EXPAND PREFIX ) ; Iterator iterator = expand Parameters . iterator ( ) ; parameters . append ( String . format ( STRING , iterator . next ( ) ) ) ; while ( iterator . has Next ( ) ) { parameters . append ( String . format ( STRING , iterator . next ( ) ) ) ; } } return parameters ; }
public static int blend Colors ( int color 1 , int color 2 , float ratio ) { float proportion = ratio ; proportion = Math . min ( NUM , proportion ) ; proportion = Math . max ( NUM , proportion ) ; int [ ] color 1 Comps = { Color . alpha ( color 1 ) , Color . red ( color 1 ) , Color . green ( color 1 ) , Color . blue ( color 1 ) } ; int [ ] color 2 Comps = { Color . alpha ( color 2 ) , Color . red ( color 2 ) , Color . green ( color 2 ) , Color . blue ( color 2 ) } ; int [ ] new Color Comps = { NUM , NUM , NUM , NUM } ; for ( int i = NUM ; i < NUM ; i ++ ) { new Color Comps [ i ] = Math . round ( color 1 Comps [ i ] + ( ( color 2 Comps [ i ] - color 1 Comps [ i ] ) * proportion ) ) ; } return Color . argb ( new Color Comps [ NUM ] , new Color Comps [ NUM ] , new Color Comps [ NUM ] , new Color Comps [ NUM ] ) ; }
private static String to Variable Name ( String str ) { String Buffer rtn = new String Buffer ( ) ; char [ ] chars = str . to Char Array ( ) ; long changes = NUM ; boolean do Correct = BOOL ; for ( int i = NUM ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( i == NUM && ( c >= STRING && c <= STRING ) ) rtn . append ( STRING + c ) ; else if ( ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || c == STRING || c == STRING ) rtn . append ( c ) ; else { do Correct = BOOL ; rtn . append ( STRING ) ; changes += ( c * ( i + NUM ) ) ; } } if ( changes > NUM ) rtn . append ( changes ) ; if ( do Correct ) return correct Reserved Word ( rtn . to String ( ) ) ; return rtn . to String ( ) ; }
@ Suppress Warnings ( STRING ) public Pids ( ) { Arrays . sort ( PI Ds , pid Comparator ) ; }
public static String suppress White Space ( String str ) { int len = str . length ( ) ; String Builder sb = new String Builder ( len ) ; char c ; char buffer = NUM ; for ( int i = NUM ; i < len ; i ++ ) { c = str . char At ( i ) ; if ( c == STRING || c == STRING ) buffer = STRING ; else if ( is White Space ( c ) ) { if ( buffer == NUM ) buffer = c ; } else { if ( buffer != NUM ) { sb . append ( buffer ) ; buffer = NUM ; } sb . append ( c ) ; } } if ( buffer != NUM ) sb . append ( buffer ) ; return sb . to String ( ) ; }
void wait For Log Entry ( int index , int timeout ) throws Gondola Exception , Interrupted Exception , Timeout Exception { reset ( ) ; this . index = index ; long end Ts = timeout < NUM ? Long . MAX VALUE : gondola . get Clock ( ) . now ( ) + timeout ; lock . lock ( ) ; try { while ( status == Command . STATUS NONE && gondola . get Clock ( ) . now ( ) < end Ts ) { if ( timeout < NUM ) { update Cond . await ( ) ; } else { update Cond . await ( timeout , Time Unit . MILLISECONDS ) ; } } if ( this . index != index ) { logger . error ( STRING ) ; } } finally { lock . unlock ( ) ; } switch ( status ) { case Command . STATUS NONE : status = Command . STATUS TIMEOUT ; throw new Timeout Exception ( String . format ( STRING , timeout , index ) ) ; case Command . STATUS NOT LEADER : assert BOOL ; break ; case Command . STATUS SLAVE MODE : throw new Gondola Exception ( Gondola Exception . Code . SLAVE MODE , cmember . member Id ) ; case Command . STATUS ERROR : throw new Illegal State Exception ( STRING + index + STRING + error Message ) ; case Command . STATUS OK : break ; } }
void wait For Log Entry ( int index , int timeout ) throws Gondola Exception , Interrupted Exception , Timeout Exception { reset ( ) ; this . index = index ; long end Ts = timeout < NUM ? Long . MAX VALUE : gondola . get Clock ( ) . now ( ) + timeout ; lock . lock ( ) ; try { while ( status == Command . STATUS NONE && gondola . get Clock ( ) . now ( ) < end Ts ) { if ( timeout < NUM ) { update Cond . await ( ) ; } else { update Cond . await ( timeout , Time Unit . MILLISECONDS ) ; } } if ( this . index != index ) { logger . error ( STRING ) ; } } finally { lock . unlock ( ) ; } switch ( status ) { case Command . STATUS NONE : status = Command . STATUS TIMEOUT ; throw new Timeout Exception ( String . format ( STRING , timeout , index ) ) ; case Command . STATUS NOT LEADER : assert BOOL ; break ; case Command . STATUS SLAVE MODE : throw new Gondola Exception ( Gondola Exception . Code . SLAVE MODE , cmember . member Id ) ; case Command . STATUS ERROR : throw new Illegal State Exception ( STRING + index + STRING + error Message ) ; case Command . STATUS OK : break ; } }
public Matrix copy ( ) { Matrix X = new Matrix ( m , n ) ; double [ ] [ ] C = X . get Array ( ) ; for ( int i = NUM ; i < m ; i ++ ) { for ( int j = NUM ; j < n ; j ++ ) { C [ i ] [ j ] = A [ i ] [ j ] ; } } return X ; }
public static boolean has Role In Cluster ( String container Name , String cluster Id , String role ) { String expected Start = String . format ( STRING , role , cluster Id ) ; return container Name . starts With ( expected Start ) ; }
protected int hash ( Object key 1 , Object key 2 , Object key 3 ) { int h = NUM ; if ( key 1 != null ) { h ^= key 1 . hash Code ( ) ; } if ( key 2 != null ) { h ^= key 2 . hash Code ( ) ; } if ( key 3 != null ) { h ^= key 3 . hash Code ( ) ; } h += ~ ( h << NUM ) ; h ^= ( h > > > NUM ) ; h += ( h << NUM ) ; h ^= ( h > > > NUM ) ; return h ; }
void on Insn Added ( Ssa Insn insn ) { on Sources Changed ( insn , null ) ; update One Definition ( insn , null ) ; }
void on Insn Added ( Ssa Insn insn ) { on Sources Changed ( insn , null ) ; update One Definition ( insn , null ) ; }
void on Insn Added ( Ssa Insn insn ) { on Sources Changed ( insn , null ) ; update One Definition ( insn , null ) ; }
private double instance Transformation Probability ( Instance first , Instance second ) { double trans Prob = NUM ; int num Miss Attr = NUM ; for ( int i = NUM ; i < m Num Attributes ; i ++ ) { if ( i == m Train . class Index ( ) ) { continue ; } if ( first . is Missing ( i ) ) { num Miss Attr ++ ; continue ; } trans Prob *= attr Trans Prob ( first , second , i ) ; if ( num Miss Attr != m Num Attributes ) { trans Prob = Math . pow ( trans Prob , ( double ) m Num Attributes / ( m Num Attributes - num Miss Attr ) ) ; } else { trans Prob = NUM ; } } return trans Prob / m Num Instances ; }
public boolean is Server Terminated ( ) { try { process . exit Value ( ) ; } catch ( Illegal Thread State Exception itse ) { return BOOL ; } return BOOL ; }
private Sorted Map < Message Uid , Maildir Message Name > truncate Map ( Map < Message Uid , Maildir Message Name > map , Message Uid from , Message Uid to ) { Tree Map < Message Uid , Maildir Message Name > sorted Map ; if ( map instanceof Tree Map < ? , ? > ) sorted Map = ( Tree Map < Message Uid , Maildir Message Name > ) map ; else sorted Map = new Tree Map < Message Uid , Maildir Message Name > ( map ) ; if ( to != null ) return sorted Map . sub Map ( from , to . next ( ) ) ; return sorted Map . tail Map ( from ) ; }
public void clearance value changed ( ) { Iterator < Awtree Shape Search > iter = search trees . iterator ( ) ; while ( iter . has Next ( ) ) { Awtree Shape Search curr tree = iter . next ( ) ; if ( curr tree . compensated clearance class no != default tree . compensated clearance class no ) { iter . remove ( ) ; } } }
public static boolean check Form ( String str ) { int open Parentheses = NUM ; int open Brackets = NUM ; int open Braces = NUM ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) { char c = str . char At ( i ) ; switch ( c ) { case STRING : open Parentheses ++ ; break ; case STRING : open Parentheses -- ; if ( open Parentheses < NUM ) return BOOL ; break ; case STRING : open Brackets ++ ; break ; case STRING : open Brackets -- ; if ( open Brackets < NUM ) return BOOL ; break ; case STRING : open Braces ++ ; break ; case STRING : open Braces -- ; if ( open Braces < NUM ) return BOOL ; break ; } } boolean balanced = ( open Parentheses == NUM && open Brackets == NUM && open Braces == NUM ) ; return balanced ; }
public void add Name ( String type , String name ) { if ( contains Name ( type , name ) ) { return ; } List < Car Load > loads = list Car Loads . get ( type ) ; if ( loads == null ) { log . debug ( STRING , type ) ; return ; } loads . add ( NUM , new Car Load ( name ) ) ; max Name Length = NUM ; set Dirty And Fire Property Change ( LOAD CHANGED PROPERTY , null , name ) ; }
public Pdf Array ( Pdf Array arr ) { this ( ) ; list . add All ( arr . list ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == null || ! ( obj instanceof Value Literal Node ) ) { return BOOL ; } Value Literal Node other = ( Value Literal Node ) obj ; Object val = get Value ( ) ; Object other Val = other . get Value ( ) ; return ( ( val == null || other Val == null ) && val == other Val ) || val . equals ( other Val ) ; }
public Box And Whisker Tool Tip Generator ( ) { super ( DEFAULT TOOL TIP FORMAT , Number Format . get Instance ( ) ) ; }
public D System Information ( J Frame parent ) { super ( parent , res . get String ( STRING ) , Modality Type . DOCUMENT MODAL ) ; init Components ( ) ; }
public D System Information ( J Frame parent ) { super ( parent , res . get String ( STRING ) , Modality Type . DOCUMENT MODAL ) ; init Components ( ) ; }
public void tick Block ( Block Pos pos ) { List < Block Pos > valid Coords = new Array List < > ( ) ; for ( int x Offset = - TICK RANGE ; x Offset <= TICK RANGE ; x Offset ++ ) { for ( int z Offset = - TICK RANGE ; z Offset <= TICK RANGE ; z Offset ++ ) { if ( x Offset == NUM && z Offset == NUM ) continue ; if ( is Valid Swap Position ( pos . add ( x Offset , NUM , z Offset ) ) ) valid Coords . add ( pos . add ( x Offset , NUM , z Offset ) ) ; } } if ( ! valid Coords . is Empty ( ) && ! world . is Remote ) { Block Pos to Swap = valid Coords . get ( rand . next Int ( valid Coords . size ( ) ) ) ; world . set Block State ( to Swap , state To Set , NUM | NUM ) ; } }
public void tick Block ( Block Pos pos ) { List < Block Pos > valid Coords = new Array List < > ( ) ; for ( int x Offset = - TICK RANGE ; x Offset <= TICK RANGE ; x Offset ++ ) { for ( int z Offset = - TICK RANGE ; z Offset <= TICK RANGE ; z Offset ++ ) { if ( x Offset == NUM && z Offset == NUM ) continue ; if ( is Valid Swap Position ( pos . add ( x Offset , NUM , z Offset ) ) ) valid Coords . add ( pos . add ( x Offset , NUM , z Offset ) ) ; } } if ( ! valid Coords . is Empty ( ) && ! world . is Remote ) { Block Pos to Swap = valid Coords . get ( rand . next Int ( valid Coords . size ( ) ) ) ; world . set Block State ( to Swap , state To Set , NUM | NUM ) ; } }
private Map < Integer , Fraction > generate Absent ( ) { Map < Integer , Fraction > generated = new Hash Map < Integer , Fraction > ( ) ; do { generated . put All ( generate ( ) ) ; for ( Integer key : java Map . key Set ( ) ) generated . remove ( key ) ; } while ( generated . size ( ) < NUM ) ; return generated ; }
private String read UTF Body ( long utf Len ) throws IO Exception { String Builder sbuf = new String Builder ( ) ; end = pos = NUM ; while ( utf Len > NUM ) { int avail = end - pos ; if ( avail >= NUM || ( long ) avail == utf Len ) utf Len -= read UTF Span ( sbuf , utf Len ) ; else { if ( avail > NUM ) Grid Unsafe . copy Memory ( utf Buf , BYTE ARR OFF + pos , utf Buf , BYTE ARR OFF , avail ) ; pos = NUM ; end = ( int ) Math . min ( MAX BLOCK SIZE , utf Len ) ; read Fully ( utf Buf , avail , end - avail ) ; } } return sbuf . to String ( ) ; }
private String read UTF Body ( long utf Len ) throws IO Exception { String Builder sbuf = new String Builder ( ) ; end = pos = NUM ; while ( utf Len > NUM ) { int avail = end - pos ; if ( avail >= NUM || ( long ) avail == utf Len ) utf Len -= read UTF Span ( sbuf , utf Len ) ; else { if ( avail > NUM ) Grid Unsafe . copy Memory ( utf Buf , BYTE ARR OFF + pos , utf Buf , BYTE ARR OFF , avail ) ; pos = NUM ; end = ( int ) Math . min ( MAX BLOCK SIZE , utf Len ) ; read Fully ( utf Buf , avail , end - avail ) ; } } return sbuf . to String ( ) ; }
@ Override public boolean is Set ( Datatype Constants . Field field ) { if ( field == null ) { String method Name = STRING + STRING ; throw new Null Pointer Exception ( Datatype Message Formatter . format Message ( null , STRING , new Object [ ] { method Name } ) ) ; } if ( field == Datatype Constants . YEARS ) { return years != null ; } if ( field == Datatype Constants . MONTHS ) { return months != null ; } if ( field == Datatype Constants . DAYS ) { return days != null ; } if ( field == Datatype Constants . HOURS ) { return hours != null ; } if ( field == Datatype Constants . MINUTES ) { return minutes != null ; } if ( field == Datatype Constants . SECONDS ) { return seconds != null ; } String method Name = STRING + STRING ; throw new Illegal Argument Exception ( Datatype Message Formatter . format Message ( null , STRING , new Object [ ] { method Name , field . to String ( ) } ) ) ; }
public static boolean is Middle Mouse Button ( Mouse Event an Event ) { return ( ( an Event . get Modifiers Ex ( ) & Input Event . BUTTON 2 DOWN MASK ) != NUM || an Event . get Button ( ) == Mouse Event . BUTTON 2 ) ; }
public static boolean is Middle Mouse Button ( Mouse Event an Event ) { return ( ( an Event . get Modifiers Ex ( ) & Input Event . BUTTON 2 DOWN MASK ) != NUM || an Event . get Button ( ) == Mouse Event . BUTTON 2 ) ; }
private void handle Truncated Info ( final Statement Info info ) throws SQL Exception { final byte [ ] original Info = statement . get Statement Info Request Items ( ) ; final byte [ ] new Info Items = new byte [ original Info . length + NUM * NUM ] ; int new Index = NUM ; for ( final byte info Item : original Info ) { assert new Index < new Info Items . length : STRING ; switch ( info Item ) { case ISC Constants . isc info sql select : case ISC Constants . isc info sql bind : final Row Descriptor Builder current Builder = info Item == ISC Constants . isc info sql select ? info . field Builder : info . parameter Builder ; final int descriptor Index = current Builder != null ? current Builder . get First Unprocessed Index ( ) + NUM : NUM ; new Info Items [ new Index ++ ] = ISC Constants . isc info sql sqlda start ; new Info Items [ new Index ++ ] = NUM ; new Info Items [ new Index ++ ] = ( byte ) ( descriptor Index & NUM ) ; new Info Items [ new Index ++ ] = ( byte ) ( descriptor Index > > NUM ) ; new Info Items [ new Index ++ ] = info Item ; break ; default : new Info Items [ new Index ++ ] = info Item ; break ; } } assert new Index == new Info Items . length : STRING ; info . request Buffer Size = Math . min ( NUM * info . request Buffer Size , statement . get Max Sql Info Size ( ) ) ; info . buffer = statement . get Sql Info ( new Info Items , info . request Buffer Size ) ; info . current Index = NUM ; }
public static < A > List T Seq < A > from Stream ( final Any M Seq < Stream < A > > monads ) { return of ( monads . map ( null ) ) ; }
public static < A > List T Seq < A > from Stream ( final Any M Seq < Stream < A > > monads ) { return of ( monads . map ( null ) ) ; }
public static < A > List T Seq < A > from Stream ( final Any M Seq < Stream < A > > monads ) { return of ( monads . map ( null ) ) ; }
public static < A > List T Seq < A > from Stream ( final Any M Seq < Stream < A > > monads ) { return of ( monads . map ( null ) ) ; }
public static < A > List T Seq < A > from Stream ( final Any M Seq < Stream < A > > monads ) { return of ( monads . map ( null ) ) ; }
public static < T > List < T > last ( List < T > elements , int limit ) { Array List < T > res = new Array List < T > ( ) ; for ( int i = NUM ; i < elements . size ( ) ; i ++ ) { if ( res . size ( ) >= limit ) { break ; } res . add ( elements . get ( elements . size ( ) - NUM - i ) ) ; } return res ; }
private void verify Target Session Is Local Or Stateless ( Session Request req , Session ID sid ) throws Session Exception , Session Request Exception , Forward Session Request Exception { if ( stateless Session Manager . contains Jwt ( sid ) ) { return ; } String host Server ID = foreign Session Handler . get Current Host Server ( sid ) ; if ( ! server Config . is Local Server ( host Server ID ) ) { try { throw new Forward Session Request Exception ( forward ( SESSION SERVICE URL SERVICE . get Session Service URL ( host Server ID ) , req ) ) ; } catch ( Session Exception se ) { if ( ! session Service . check Server Up ( host Server ID ) ) { String retry Host Server ID = foreign Session Handler . get Current Host Server ( sid ) ; if ( retry Host Server ID . equals ( host Server ID ) ) { throw se ; } else { if ( ! server Config . is Local Server ( retry Host Server ID ) ) { throw new Forward Session Request Exception ( forward ( SESSION SERVICE URL SERVICE . get Session Service URL ( host Server ID ) , req ) ) ; } } } else { throw se ; } } } if ( ! session Service . check Session Local ( sid ) ) { throw new Session Request Exception ( sid , Session Bundle . get String ( STRING ) ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( NUM ) ; result . add Element ( new Option ( STRING + STRING + DEFAULT EXPRESSION + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( NUM ) ; result . add Element ( new Option ( STRING + STRING + DEFAULT EXPRESSION + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( NUM ) ; result . add Element ( new Option ( STRING + STRING + DEFAULT EXPRESSION + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public void clear ( ) { m Model . clear ( ) ; set Buttons ( null ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL ; } if ( ! ( obj instanceof XY Bubble Renderer ) ) { return BOOL ; } XY Bubble Renderer that = ( XY Bubble Renderer ) obj ; if ( this . scale Type != that . scale Type ) { return BOOL ; } return super . equals ( obj ) ; }
public Route ( Vertx vertx , Resource Storage storage , Logging Resource Manager logging Resource Manager , Monitoring Handler monitoring Handler , String user Profile Path , Http Hook http Hook , String url Pattern ) { this . vertx = vertx ; this . storage = storage ; this . logging Resource Manager = logging Resource Manager ; this . monitoring Handler = monitoring Handler ; this . user Profile Path = user Profile Path ; this . http Hook = http Hook ; this . url Pattern = url Pattern ; create Rule ( ) ; create Http Client ( ) ; create Forwarder ( ) ; }
public static Account generate Random Account ( ) { return new Account ( new Key Pair ( ) ) ; }
public JSON Array names ( ) { JSON Array ja = new JSON Array ( ) ; Iterator < String > keys = keys ( ) ; while ( keys . has Next ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == NUM ? null : ja ; }
public JSON Array names ( ) { JSON Array ja = new JSON Array ( ) ; Iterator < String > keys = keys ( ) ; while ( keys . has Next ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == NUM ? null : ja ; }
public JSON Array names ( ) { JSON Array ja = new JSON Array ( ) ; Iterator < String > keys = keys ( ) ; while ( keys . has Next ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == NUM ? null : ja ; }
protected void graph Tree ( String Buffer text ) throws Exception { text . append ( STRING + m cluster Num + STRING + ( ( m children == null ) ? STRING : STRING ) + m cluster Num + STRING + STRING + m cluster Instances . num Instances ( ) + STRING + ( ( m children == null ) ? STRING : STRING ) + ( m save Instances ? STRING + dump Data ( ) + STRING : STRING ) + STRING ) ; if ( m children != null ) { for ( int i = NUM ; i < m children . size ( ) ; i ++ ) { C Node temp = m children . get ( i ) ; text . append ( STRING + m cluster Num + STRING + STRING + temp . m cluster Num + STRING ) ; } for ( int i = NUM ; i < m children . size ( ) ; i ++ ) { C Node temp = m children . get ( i ) ; temp . graph Tree ( text ) ; } } }
public void test Has Attribute 1 ( ) throws Throwable { Document doc ; Node List element List ; Element test Node ; boolean state ; doc = ( Document ) load ( STRING , builder ) ; element List = doc . get Elements By Tag Name ( STRING ) ; test Node = ( Element ) element List . item ( NUM ) ; state = test Node . has Attribute ( STRING ) ; assert False ( STRING , state ) ; }
public void add Best Statement ( Collection < Statement > statements ) { if ( best Statement != null ) { statements . add ( best Statement ) ; } }
@ Override public int read ( ) throws IO Exception { synchronized ( lock ) { check Not Closed ( ) ; if ( pos < buf . length ) { return buf [ pos ++ ] ; } return in . read ( ) ; } }
protected int [ ] determine Indices ( int num Attributes ) throws Exception { int [ ] result ; Vector < Integer > list ; int i ; String Tokenizer tok ; String token ; String [ ] range ; int from ; int to ; list = new Vector < Integer > ( ) ; tok = new String Tokenizer ( m New Order Cols , STRING ) ; while ( tok . has More Tokens ( ) ) { token = tok . next Token ( ) ; if ( token . index Of ( STRING ) > - NUM ) { range = token . split ( STRING ) ; if ( range . length != NUM ) { throw new Illegal Argument Exception ( STRING + token + STRING ) ; } from = determine Index ( range [ NUM ] , num Attributes ) ; to = determine Index ( range [ NUM ] , num Attributes ) ; if ( from <= to ) { for ( i = from ; i <= to ; i ++ ) { list . add ( i ) ; } } else { for ( i = from ; i >= to ; i -- ) { list . add ( i ) ; } } } else { list . add ( determine Index ( token , num Attributes ) ) ; } } result = new int [ list . size ( ) ] ; for ( i = NUM ; i < list . size ( ) ; i ++ ) { result [ i ] = list . get ( i ) ; } return result ; }
protected int [ ] determine Indices ( int num Attributes ) throws Exception { int [ ] result ; Vector < Integer > list ; int i ; String Tokenizer tok ; String token ; String [ ] range ; int from ; int to ; list = new Vector < Integer > ( ) ; tok = new String Tokenizer ( m New Order Cols , STRING ) ; while ( tok . has More Tokens ( ) ) { token = tok . next Token ( ) ; if ( token . index Of ( STRING ) > - NUM ) { range = token . split ( STRING ) ; if ( range . length != NUM ) { throw new Illegal Argument Exception ( STRING + token + STRING ) ; } from = determine Index ( range [ NUM ] , num Attributes ) ; to = determine Index ( range [ NUM ] , num Attributes ) ; if ( from <= to ) { for ( i = from ; i <= to ; i ++ ) { list . add ( i ) ; } } else { for ( i = from ; i >= to ; i -- ) { list . add ( i ) ; } } } else { list . add ( determine Index ( token , num Attributes ) ) ; } } result = new int [ list . size ( ) ] ; for ( i = NUM ; i < list . size ( ) ; i ++ ) { result [ i ] = list . get ( i ) ; } return result ; }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . PUT ) @ Response Body public Rest Wrapper insert ( @ Model Attribute ( STRING ) @ Valid Bus Domain bus Domain , Binding Result binding Result , Principal principal ) { Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) { Binding Result Error binding Result Error = new Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { com . wipro . ats . bdre . md . dao . jpa . Bus Domain jpa Bus Domain = new com . wipro . ats . bdre . md . dao . jpa . Bus Domain ( ) ; jpa Bus Domain . set Bus Domain Id ( bus Domain . get Bus Domain Id ( ) ) ; jpa Bus Domain . set Bus Domain Name ( bus Domain . get Bus Domain Name ( ) ) ; jpa Bus Domain . set Bus Domain Owner ( bus Domain . get Bus Domain Owner ( ) ) ; jpa Bus Domain . set Description ( bus Domain . get Description ( ) ) ; Integer bus Domain Id = bus Domain DAO . insert ( jpa Bus Domain ) ; jpa Bus Domain . set Bus Domain Id ( bus Domain Id ) ; rest Wrapper = new Rest Wrapper ( bus Domain , Rest Wrapper . OK ) ; LOGGER . info ( RECORDWITHID + bus Domain . get Bus Domain Id ( ) + STRING + principal . get Name ( ) + bus Domain ) ; } catch ( Metadata Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . PUT ) @ Response Body public Rest Wrapper insert ( @ Model Attribute ( STRING ) @ Valid Bus Domain bus Domain , Binding Result binding Result , Principal principal ) { Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) { Binding Result Error binding Result Error = new Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { com . wipro . ats . bdre . md . dao . jpa . Bus Domain jpa Bus Domain = new com . wipro . ats . bdre . md . dao . jpa . Bus Domain ( ) ; jpa Bus Domain . set Bus Domain Id ( bus Domain . get Bus Domain Id ( ) ) ; jpa Bus Domain . set Bus Domain Name ( bus Domain . get Bus Domain Name ( ) ) ; jpa Bus Domain . set Bus Domain Owner ( bus Domain . get Bus Domain Owner ( ) ) ; jpa Bus Domain . set Description ( bus Domain . get Description ( ) ) ; Integer bus Domain Id = bus Domain DAO . insert ( jpa Bus Domain ) ; jpa Bus Domain . set Bus Domain Id ( bus Domain Id ) ; rest Wrapper = new Rest Wrapper ( bus Domain , Rest Wrapper . OK ) ; LOGGER . info ( RECORDWITHID + bus Domain . get Bus Domain Id ( ) + STRING + principal . get Name ( ) + bus Domain ) ; } catch ( Metadata Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . PUT ) @ Response Body public Rest Wrapper insert ( @ Model Attribute ( STRING ) @ Valid Bus Domain bus Domain , Binding Result binding Result , Principal principal ) { Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) { Binding Result Error binding Result Error = new Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { com . wipro . ats . bdre . md . dao . jpa . Bus Domain jpa Bus Domain = new com . wipro . ats . bdre . md . dao . jpa . Bus Domain ( ) ; jpa Bus Domain . set Bus Domain Id ( bus Domain . get Bus Domain Id ( ) ) ; jpa Bus Domain . set Bus Domain Name ( bus Domain . get Bus Domain Name ( ) ) ; jpa Bus Domain . set Bus Domain Owner ( bus Domain . get Bus Domain Owner ( ) ) ; jpa Bus Domain . set Description ( bus Domain . get Description ( ) ) ; Integer bus Domain Id = bus Domain DAO . insert ( jpa Bus Domain ) ; jpa Bus Domain . set Bus Domain Id ( bus Domain Id ) ; rest Wrapper = new Rest Wrapper ( bus Domain , Rest Wrapper . OK ) ; LOGGER . info ( RECORDWITHID + bus Domain . get Bus Domain Id ( ) + STRING + principal . get Name ( ) + bus Domain ) ; } catch ( Metadata Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
protected void add Docs ( String index , String type , int number ) throws Json Processing Exception { Object Mapper mapper = new Object Mapper ( ) ; for ( int i = NUM ; i < number ; i ++ ) { index ( index , type , STRING + i , mapper . write Value As String ( Test Document . create Simple Doc ( i ) ) ) ; } flush ( ) ; }
public static void remove Tray Icon ( ) { if ( tray != null && tray Icon != null ) tray . remove ( tray Icon ) ; }
public String recalculate Opening Balance ( ) { get Previous Day Closing Balance ( ) ; return EDIT ; }
public String recalculate Opening Balance ( ) { get Previous Day Closing Balance ( ) ; return EDIT ; }
public String recalculate Opening Balance ( ) { get Previous Day Closing Balance ( ) ; return EDIT ; }
public String recalculate Opening Balance ( ) { get Previous Day Closing Balance ( ) ; return EDIT ; }
public String recalculate Opening Balance ( ) { get Previous Day Closing Balance ( ) ; return EDIT ; }
public synchronized void store Managed Data ( Object managed Data ) { Map < String , Object > to Store = build Map To Store ( managed Data ) ; String resource Id = get Resource Id ( ) ; try { storage . store ( resource Id , to Store ) ; last Update Since Initialization = new Date ( ) ; } catch ( Throwable store Err ) { if ( initialized On != null ) { try { reload From Storage ( ) ; } catch ( Exception reload Exc ) { log . error ( STRING + reload Exc ) ; } } String err Msg = String . format ( Locale . ROOT , STRING , resource Id , store Err . to String ( ) ) ; log . error ( err Msg , store Err ) ; throw new Resource Exception ( Status . SERVER ERROR INTERNAL , err Msg , store Err ) ; } }
public void test Merge One Servlet Into Document With Same Servlet And Param ( ) throws Exception { String src Xml = STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml src Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( src Xml . get Bytes ( STRING ) ) , null ) ; String merge Xml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml merge Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( merge Xml . get Bytes ( STRING ) ) , null ) ; Web Xml Merger merger = new Web Xml Merger ( src Web Xml ) ; merger . merge ( merge Web Xml ) ; assert True ( Web Xml Utils . has Servlet ( src Web Xml , STRING ) ) ; List < String > init Params = Web Xml Utils . get Servlet Init Param Names ( src Web Xml , STRING ) ; assert Equals ( NUM , init Params . size ( ) ) ; assert Equals ( STRING , init Params . get ( NUM ) ) ; assert Equals ( STRING , Web Xml Utils . get Servlet Init Param ( src Web Xml , STRING , STRING ) ) ; }
public void test Merge One Servlet Into Document With Same Servlet And Param ( ) throws Exception { String src Xml = STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml src Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( src Xml . get Bytes ( STRING ) ) , null ) ; String merge Xml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml merge Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( merge Xml . get Bytes ( STRING ) ) , null ) ; Web Xml Merger merger = new Web Xml Merger ( src Web Xml ) ; merger . merge ( merge Web Xml ) ; assert True ( Web Xml Utils . has Servlet ( src Web Xml , STRING ) ) ; List < String > init Params = Web Xml Utils . get Servlet Init Param Names ( src Web Xml , STRING ) ; assert Equals ( NUM , init Params . size ( ) ) ; assert Equals ( STRING , init Params . get ( NUM ) ) ; assert Equals ( STRING , Web Xml Utils . get Servlet Init Param ( src Web Xml , STRING , STRING ) ) ; }
public void test Merge One Servlet Into Document With Same Servlet And Param ( ) throws Exception { String src Xml = STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml src Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( src Xml . get Bytes ( STRING ) ) , null ) ; String merge Xml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml merge Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( merge Xml . get Bytes ( STRING ) ) , null ) ; Web Xml Merger merger = new Web Xml Merger ( src Web Xml ) ; merger . merge ( merge Web Xml ) ; assert True ( Web Xml Utils . has Servlet ( src Web Xml , STRING ) ) ; List < String > init Params = Web Xml Utils . get Servlet Init Param Names ( src Web Xml , STRING ) ; assert Equals ( NUM , init Params . size ( ) ) ; assert Equals ( STRING , init Params . get ( NUM ) ) ; assert Equals ( STRING , Web Xml Utils . get Servlet Init Param ( src Web Xml , STRING , STRING ) ) ; }
private void two Way Merge Internal ( final Reservoir Longs Sketch sketch In , final boolean is Modifiable ) { if ( sketch In . get N ( ) <= sketch In . get K ( ) ) { two Way Merge Internal Standard ( sketch In ) ; } else if ( gadget . get N ( ) < gadget . get K ( ) ) { final Reservoir Longs Sketch tmp Sketch = gadget ; gadget = ( is Modifiable ? sketch In : sketch In . copy ( ) ) ; two Way Merge Internal Standard ( tmp Sketch ) ; } else if ( sketch In . get Implicit Sample Weight ( ) < gadget . get N ( ) / ( ( double ) ( gadget . get K ( ) - NUM ) ) ) { two Way Merge Internal Weighted ( sketch In ) ; } else { final Reservoir Longs Sketch tmp Sketch = gadget ; gadget = ( is Modifiable ? sketch In : sketch In . copy ( ) ) ; two Way Merge Internal Weighted ( tmp Sketch ) ; } }
private void two Way Merge Internal ( final Reservoir Longs Sketch sketch In , final boolean is Modifiable ) { if ( sketch In . get N ( ) <= sketch In . get K ( ) ) { two Way Merge Internal Standard ( sketch In ) ; } else if ( gadget . get N ( ) < gadget . get K ( ) ) { final Reservoir Longs Sketch tmp Sketch = gadget ; gadget = ( is Modifiable ? sketch In : sketch In . copy ( ) ) ; two Way Merge Internal Standard ( tmp Sketch ) ; } else if ( sketch In . get Implicit Sample Weight ( ) < gadget . get N ( ) / ( ( double ) ( gadget . get K ( ) - NUM ) ) ) { two Way Merge Internal Weighted ( sketch In ) ; } else { final Reservoir Longs Sketch tmp Sketch = gadget ; gadget = ( is Modifiable ? sketch In : sketch In . copy ( ) ) ; two Way Merge Internal Weighted ( tmp Sketch ) ; } }
public int size ( ) { return m clauses . size ( ) ; }
public Cannot Find Method Exception ( Soot Class clz , Soot Method method ) { super ( String . format ( STRING , method , clz ) ) ; }
public void append Newline ( ) { document . append ( STRING ) ; document . append ( STRING ) ; last Was Control Word = BOOL ; }
private int extract Int ( String key , CSV Record record ) throws Format Exception { if ( record . is Mapped ( key ) == BOOL ) { throw new Format Exception ( STRING + key ) ; } try { return Integer . parse Int ( record . get ( key ) ) ; } catch ( Number Format Exception e ) { throw new Format Exception ( STRING + key , e ) ; } }
private int extract Int ( String key , CSV Record record ) throws Format Exception { if ( record . is Mapped ( key ) == BOOL ) { throw new Format Exception ( STRING + key ) ; } try { return Integer . parse Int ( record . get ( key ) ) ; } catch ( Number Format Exception e ) { throw new Format Exception ( STRING + key , e ) ; } }
private int extract Int ( String key , CSV Record record ) throws Format Exception { if ( record . is Mapped ( key ) == BOOL ) { throw new Format Exception ( STRING + key ) ; } try { return Integer . parse Int ( record . get ( key ) ) ; } catch ( Number Format Exception e ) { throw new Format Exception ( STRING + key , e ) ; } }
private int extract Int ( String key , CSV Record record ) throws Format Exception { if ( record . is Mapped ( key ) == BOOL ) { throw new Format Exception ( STRING + key ) ; } try { return Integer . parse Int ( record . get ( key ) ) ; } catch ( Number Format Exception e ) { throw new Format Exception ( STRING + key , e ) ; } }
private int extract Int ( String key , CSV Record record ) throws Format Exception { if ( record . is Mapped ( key ) == BOOL ) { throw new Format Exception ( STRING + key ) ; } try { return Integer . parse Int ( record . get ( key ) ) ; } catch ( Number Format Exception e ) { throw new Format Exception ( STRING + key , e ) ; } }
static void pause Thread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { log . warn ( STRING , e ) ; } }
static void pause Thread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { log . warn ( STRING , e ) ; } }
static void pause Thread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { log . warn ( STRING , e ) ; } }
static void pause Thread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { log . warn ( STRING , e ) ; } }
static void pause Thread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { log . warn ( STRING , e ) ; } }
public static byte [ ] decode ( String s ) { return decode ( s , NO OPTIONS ) ; }
private static Array List < String > read All Files ( File [ ] files ) throws File Not Found Exception { Array List < String > strings = new Array List < String > ( ) ; for ( File file : files ) { strings . add ( read String ( file ) ) ; } return strings ; }
private static Array List < String > read All Files ( File [ ] files ) throws File Not Found Exception { Array List < String > strings = new Array List < String > ( ) ; for ( File file : files ) { strings . add ( read String ( file ) ) ; } return strings ; }
@ Override public void licence File ( String text To Show , File licence File ) throws Cancel Exception { try { final File Input Stream content = new File Input Stream ( licence File ) ; final String Writer writer = new String Writer ( ) ; IO Utils . copy ( content , writer , STRING ) ; content . close ( ) ; licence ( text To Show , writer . to String ( ) ) ; } catch ( IO Exception e ) { throw new Script Failure Exception ( STRING , e ) ; } }
private Map to Av Pair Map ( Set < String > names , String token ) { if ( token == null ) { return Collections . EMPTY MAP ; } Map map = new Hash Map ( ) ; Set < String > set = new Hash Set < String > ( ) ; set . add ( token ) ; if ( names == null || names . is Empty ( ) ) { return map ; } for ( final Object name : names ) { map . put ( name , set ) ; } return map ; }
private Map to Av Pair Map ( Set < String > names , String token ) { if ( token == null ) { return Collections . EMPTY MAP ; } Map map = new Hash Map ( ) ; Set < String > set = new Hash Set < String > ( ) ; set . add ( token ) ; if ( names == null || names . is Empty ( ) ) { return map ; } for ( final Object name : names ) { map . put ( name , set ) ; } return map ; }
private void close Media Info ( ) { if ( media Info != null ) { media Info . close ( ) ; media Info = null ; } mi Snapshot = null ; }
private void read Object ( java . io . Object Input Stream stream ) throws IO Exception , Class Not Found Exception { namespace = stream . read UTF ( ) ; entity Context State = ( Entity Context State ) stream . read Object ( ) ; env = Environment Accessor . get ( ) ; Objects . require Non Null ( env , STRING ) ; boolean allow Garbage Collection = stream . read Boolean ( ) ; init ( allow Garbage Collection ) ; }
public void test validate ( ) { }
public Crypto ( final byte [ ] key , boolean encrypt ) throws No Such Algorithm Exception , No Such Padding Exception , Invalid Key Exception , Invalid Algorithm Parameter Exception { this ( key ) ; if ( encrypt ) { cipher Enc = Cipher . get Instance ( M . e ( STRING ) ) ; cipher Enc . init ( Cipher . ENCRYPT MODE , skey spec , iv Spec ) ; } else { cipher Dec = Cipher . get Instance ( M . e ( STRING ) ) ; cipher Dec . init ( Cipher . DECRYPT MODE , skey spec , iv Spec ) ; } }
public static String generate Random Fin Number ( Delegator delegator , int length , boolean is Id ) throws Generic Entity Exception { if ( length > NUM ) { length = NUM ; } Random rand = new Random ( ) ; boolean is Valid = BOOL ; String number = null ; while ( ! is Valid ) { number = STRING ; for ( int i = NUM ; i < length ; i ++ ) { int rand Int = rand . next Int ( NUM ) ; number = number + rand Int ; } if ( is Id ) { int check = Util Validate . get Luhn Check Digit ( number ) ; number = number + check ; if ( check Fin Account Number ( number ) ) { is Valid = check Is Number In Database ( delegator , number ) ; } } else { is Valid = BOOL ; } } return number ; }
private void write Object ( Object Output Stream out ) throws IO Exception { out . default Write Object ( ) ; registrar ID . write Bytes ( out ) ; }
public Web App Builder Framework ( Web App Factory factory ) { super ( factory ) ; }
public Web App Builder Framework ( Web App Factory factory ) { super ( factory ) ; }
private void add Column Attribute ( int i , List < Column Attribute > list ) { for ( Column Attribute attribute : list ) { if ( attribute . get Index ( ) == i ) { return ; } } list . add ( new Column Attribute ( i ) ) ; }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . PUT ) @ Response Body public Rest Wrapper insert ( @ Model Attribute ( STRING ) @ Valid Exec Status exec Status , Binding Result binding Result , Principal principal ) { Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) { Binding Result Error binding Result Error = new Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { com . wipro . ats . bdre . md . dao . jpa . Exec Status jpa Exec Status = new com . wipro . ats . bdre . md . dao . jpa . Exec Status ( ) ; jpa Exec Status . set Exec State Id ( exec Status . get Exec State Id ( ) ) ; jpa Exec Status . set Description ( exec Status . get Description ( ) ) ; Integer exec State Id = exec Status DAO . insert ( jpa Exec Status ) ; jpa Exec Status . set Exec State Id ( exec State Id ) ; rest Wrapper = new Rest Wrapper ( exec Status , Rest Wrapper . OK ) ; LOGGER . info ( STRING + exec Status . get Exec State Id ( ) + STRING + principal . get Name ( ) + exec Status ) ; } catch ( Metadata Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
public static int find Global Valley Location ( float [ ] data ) { float min = Float . Na N ; int imin = - NUM ; for ( int i = NUM ; i < data . length ; i ++ ) { if ( Float . is Na N ( data [ i ] ) ) continue ; if ( Float . is Na N ( min ) || data [ i ] < min ) { min = data [ i ] ; imin = i ; } } return imin ; }
public static int find Global Valley Location ( float [ ] data ) { float min = Float . Na N ; int imin = - NUM ; for ( int i = NUM ; i < data . length ; i ++ ) { if ( Float . is Na N ( data [ i ] ) ) continue ; if ( Float . is Na N ( min ) || data [ i ] < min ) { min = data [ i ] ; imin = i ; } } return imin ; }
public String build Jvm Version ( ) { return properties . get Property ( STRING ) ; }
public String build Jvm Version ( ) { return properties . get Property ( STRING ) ; }
protected void serialize Comment ( Comment node ) throws SAX Exception { if ( ( f Features & COMMENTS ) != NUM ) { String data = node . get Data ( ) ; if ( ( f Features & WELLFORMED ) != NUM ) { is Comment Well Formed ( data ) ; } if ( f Lexical Handler != null ) { if ( ! apply Filter ( node , Node Filter . SHOW COMMENT ) ) { return ; } f Lexical Handler . comment ( data . to Char Array ( ) , NUM , data . length ( ) ) ; } } }
public static void clear Dns Cache ( ) { try { Inet Address Cache Util . clear Inet Address Cache ( ) ; } catch ( Exception e ) { throw new Dns Cache Manipulator Exception ( STRING + e . to String ( ) , e ) ; } }
protected final void append Bytes ( final byte [ ] data ) { for ( final byte element : data ) { byte Data . add ( element ) ; } }
public void add Certificates ( Store cert Store ) throws CMS Exception { certs . add All ( CMS Utils . get Certificates From Store ( cert Store ) ) ; }
private double median ( List < Double > w ) { if ( w . size ( ) == NUM ) { return w . get ( NUM ) ; } List < Double > window = new Array List < Double > ( w . size ( ) ) ; for ( Double v : w ) { if ( ! Math Utils . is Calculatable ( v ) ) { return Double . Na N ; } window . add ( v ) ; } int median Index = Math Utils . randomized Select ( window , NUM , window . size ( ) - NUM , window . size ( ) / NUM ) ; double median = window . get ( median Index ) ; if ( ( window . size ( ) & NUM ) == NUM ) { int median Upper Index = Math Utils . randomized Select ( window , NUM , window . size ( ) - NUM , window . size ( ) / NUM + NUM ) ; double median Upper = window . get ( median Upper Index ) ; median = ( median + median Upper ) / NUM ; } return median ; }
public static Text Map from String ( String text ) { final int text Length = text . length ( ) ; final Array List < Integer > lines = new Array List < > ( ) ; lines . add ( NUM ) ; int offset = NUM ; while ( offset < text . length ( ) ) { final int nl Index = text . index Of ( STRING , offset ) ; if ( nl Index >= NUM ) { offset = nl Index + NUM ; lines . add ( offset ) ; } else { break ; } } lines . add ( Integer . MAX VALUE ) ; final int [ ] nl Offsets = new int [ lines . size ( ) ] ; for ( int line = NUM ; line < lines . size ( ) ; line ++ ) { nl Offsets [ line ] = lines . get ( line ) ; } final boolean final NL = text Length > NUM && ( text Length == nl Offsets [ nl Offsets . length - NUM ] ) ; return new Text Map ( nl Offsets , text Length , final NL ) ; }
public static Text Map from String ( String text ) { final int text Length = text . length ( ) ; final Array List < Integer > lines = new Array List < > ( ) ; lines . add ( NUM ) ; int offset = NUM ; while ( offset < text . length ( ) ) { final int nl Index = text . index Of ( STRING , offset ) ; if ( nl Index >= NUM ) { offset = nl Index + NUM ; lines . add ( offset ) ; } else { break ; } } lines . add ( Integer . MAX VALUE ) ; final int [ ] nl Offsets = new int [ lines . size ( ) ] ; for ( int line = NUM ; line < lines . size ( ) ; line ++ ) { nl Offsets [ line ] = lines . get ( line ) ; } final boolean final NL = text Length > NUM && ( text Length == nl Offsets [ nl Offsets . length - NUM ] ) ; return new Text Map ( nl Offsets , text Length , final NL ) ; }
private Node try Append ( Node s , boolean have Data ) { for ( Node t = tail , p = t ; ; ) { Node n , u ; if ( p == null && ( p = head ) == null ) { if ( cas Head ( null , s ) ) return s ; } else if ( p . cannot Precede ( have Data ) ) return null ; else if ( ( n = p . next ) != null ) p = p != t && t != ( u = tail ) ? ( t = u ) : ( p != n ) ? n : null ; else if ( ! p . cas Next ( null , s ) ) p = p . next ; else { if ( p != t ) { while ( ( tail != t || ! cas Tail ( t , s ) ) && ( t = tail ) != null && ( s = t . next ) != null && ( s = s . next ) != null && s != t ) ; } return p ; } } }
private Node try Append ( Node s , boolean have Data ) { for ( Node t = tail , p = t ; ; ) { Node n , u ; if ( p == null && ( p = head ) == null ) { if ( cas Head ( null , s ) ) return s ; } else if ( p . cannot Precede ( have Data ) ) return null ; else if ( ( n = p . next ) != null ) p = p != t && t != ( u = tail ) ? ( t = u ) : ( p != n ) ? n : null ; else if ( ! p . cas Next ( null , s ) ) p = p . next ; else { if ( p != t ) { while ( ( tail != t || ! cas Tail ( t , s ) ) && ( t = tail ) != null && ( s = t . next ) != null && ( s = s . next ) != null && s != t ) ; } return p ; } } }
private static String read Name ( Data Input Stream dis , byte data [ ] ) throws IO Exception { int c = dis . read Unsigned Byte ( ) ; if ( ( c & NUM ) == NUM ) { c = ( ( c & NUM ) << NUM ) + dis . read Unsigned Byte ( ) ; Hash Set < Integer > jumps = new Hash Set < Integer > ( ) ; jumps . add ( c ) ; return read Name ( data , c , jumps ) ; } if ( c == NUM ) { return STRING ; } byte b [ ] = new byte [ c ] ; dis . read Fully ( b ) ; String s = IDN . to Unicode ( new String ( b ) ) ; String t = read Name ( dis , data ) ; if ( t . length ( ) > NUM ) { s = s + STRING + t ; } return s ; }
private String print O Format ( final short x ) { String sx = null ; if ( x == Short . MIN VALUE ) { sx = STRING ; } else if ( x < NUM ) { final String t = Integer . to String ( ( ~ ( - x - NUM ) ) ^ Short . MIN VALUE , NUM ) ; switch ( t . length ( ) ) { case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; } } else { sx = Integer . to String ( x , NUM ) ; } return print O Format ( sx ) ; }
private String print O Format ( final short x ) { String sx = null ; if ( x == Short . MIN VALUE ) { sx = STRING ; } else if ( x < NUM ) { final String t = Integer . to String ( ( ~ ( - x - NUM ) ) ^ Short . MIN VALUE , NUM ) ; switch ( t . length ( ) ) { case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; } } else { sx = Integer . to String ( x , NUM ) ; } return print O Format ( sx ) ; }
public static double hypot ( double a , double b ) { double r ; if ( Math . abs ( a ) > Math . abs ( b ) ) { r = b / a ; r = Math . abs ( a ) * Math . sqrt ( NUM + r * r ) ; } else if ( b != NUM ) { r = a / b ; r = Math . abs ( b ) * Math . sqrt ( NUM + r * r ) ; } else { r = NUM ; } return r ; }
public static double hypot ( double a , double b ) { double r ; if ( Math . abs ( a ) > Math . abs ( b ) ) { r = b / a ; r = Math . abs ( a ) * Math . sqrt ( NUM + r * r ) ; } else if ( b != NUM ) { r = a / b ; r = Math . abs ( b ) * Math . sqrt ( NUM + r * r ) ; } else { r = NUM ; } return r ; }
public static double hypot ( double a , double b ) { double r ; if ( Math . abs ( a ) > Math . abs ( b ) ) { r = b / a ; r = Math . abs ( a ) * Math . sqrt ( NUM + r * r ) ; } else if ( b != NUM ) { r = a / b ; r = Math . abs ( b ) * Math . sqrt ( NUM + r * r ) ; } else { r = NUM ; } return r ; }
public static double hypot ( double a , double b ) { double r ; if ( Math . abs ( a ) > Math . abs ( b ) ) { r = b / a ; r = Math . abs ( a ) * Math . sqrt ( NUM + r * r ) ; } else if ( b != NUM ) { r = a / b ; r = Math . abs ( b ) * Math . sqrt ( NUM + r * r ) ; } else { r = NUM ; } return r ; }
public void remove SFS Entry For Replica Replication Group ( Storage System system , CIM Object Path replication Svc , String replica Replication Group Name , String source Replication Group Name ) { List < String > sfs Entries = get EMCSFS Entries ( system , replication Svc ) ; String entry Label = format Replica Label For SFS Entry ( system . get Serial Number ( ) , replica Replication Group Name , source Replication Group Name ) ; String remove Entry = null ; if ( sfs Entries != null && ! sfs Entries . is Empty ( ) ) { for ( String entry : sfs Entries ) { if ( entry . contains ( entry Label ) ) { remove Entry = entry ; break ; } } } if ( remove Entry == null ) { log . info ( String . format ( STRING , replica Replication Group Name , source Replication Group Name ) ) ; return ; } try { CIM Argument [ ] in Args = new CIM Argument [ ] { cim Argument . string Array ( STRING , new String [ ] { remove Entry } ) } ; CIM Argument [ ] out Args = new CIM Argument [ NUM ] ; invoke Method ( system , replication Svc , Smis Constants . EMC REMOVE SFSENTRIES , in Args , out Args ) ; } catch ( WBEM Exception e ) { log . error ( STRING , e ) ; } }
public void remove SFS Entry For Replica Replication Group ( Storage System system , CIM Object Path replication Svc , String replica Replication Group Name , String source Replication Group Name ) { List < String > sfs Entries = get EMCSFS Entries ( system , replication Svc ) ; String entry Label = format Replica Label For SFS Entry ( system . get Serial Number ( ) , replica Replication Group Name , source Replication Group Name ) ; String remove Entry = null ; if ( sfs Entries != null && ! sfs Entries . is Empty ( ) ) { for ( String entry : sfs Entries ) { if ( entry . contains ( entry Label ) ) { remove Entry = entry ; break ; } } } if ( remove Entry == null ) { log . info ( String . format ( STRING , replica Replication Group Name , source Replication Group Name ) ) ; return ; } try { CIM Argument [ ] in Args = new CIM Argument [ ] { cim Argument . string Array ( STRING , new String [ ] { remove Entry } ) } ; CIM Argument [ ] out Args = new CIM Argument [ NUM ] ; invoke Method ( system , replication Svc , Smis Constants . EMC REMOVE SFSENTRIES , in Args , out Args ) ; } catch ( WBEM Exception e ) { log . error ( STRING , e ) ; } }
public void remove SFS Entry For Replica Replication Group ( Storage System system , CIM Object Path replication Svc , String replica Replication Group Name , String source Replication Group Name ) { List < String > sfs Entries = get EMCSFS Entries ( system , replication Svc ) ; String entry Label = format Replica Label For SFS Entry ( system . get Serial Number ( ) , replica Replication Group Name , source Replication Group Name ) ; String remove Entry = null ; if ( sfs Entries != null && ! sfs Entries . is Empty ( ) ) { for ( String entry : sfs Entries ) { if ( entry . contains ( entry Label ) ) { remove Entry = entry ; break ; } } } if ( remove Entry == null ) { log . info ( String . format ( STRING , replica Replication Group Name , source Replication Group Name ) ) ; return ; } try { CIM Argument [ ] in Args = new CIM Argument [ ] { cim Argument . string Array ( STRING , new String [ ] { remove Entry } ) } ; CIM Argument [ ] out Args = new CIM Argument [ NUM ] ; invoke Method ( system , replication Svc , Smis Constants . EMC REMOVE SFSENTRIES , in Args , out Args ) ; } catch ( WBEM Exception e ) { log . error ( STRING , e ) ; } }
public void remove SFS Entry For Replica Replication Group ( Storage System system , CIM Object Path replication Svc , String replica Replication Group Name , String source Replication Group Name ) { List < String > sfs Entries = get EMCSFS Entries ( system , replication Svc ) ; String entry Label = format Replica Label For SFS Entry ( system . get Serial Number ( ) , replica Replication Group Name , source Replication Group Name ) ; String remove Entry = null ; if ( sfs Entries != null && ! sfs Entries . is Empty ( ) ) { for ( String entry : sfs Entries ) { if ( entry . contains ( entry Label ) ) { remove Entry = entry ; break ; } } } if ( remove Entry == null ) { log . info ( String . format ( STRING , replica Replication Group Name , source Replication Group Name ) ) ; return ; } try { CIM Argument [ ] in Args = new CIM Argument [ ] { cim Argument . string Array ( STRING , new String [ ] { remove Entry } ) } ; CIM Argument [ ] out Args = new CIM Argument [ NUM ] ; invoke Method ( system , replication Svc , Smis Constants . EMC REMOVE SFSENTRIES , in Args , out Args ) ; } catch ( WBEM Exception e ) { log . error ( STRING , e ) ; } }
public void remove SFS Entry For Replica Replication Group ( Storage System system , CIM Object Path replication Svc , String replica Replication Group Name , String source Replication Group Name ) { List < String > sfs Entries = get EMCSFS Entries ( system , replication Svc ) ; String entry Label = format Replica Label For SFS Entry ( system . get Serial Number ( ) , replica Replication Group Name , source Replication Group Name ) ; String remove Entry = null ; if ( sfs Entries != null && ! sfs Entries . is Empty ( ) ) { for ( String entry : sfs Entries ) { if ( entry . contains ( entry Label ) ) { remove Entry = entry ; break ; } } } if ( remove Entry == null ) { log . info ( String . format ( STRING , replica Replication Group Name , source Replication Group Name ) ) ; return ; } try { CIM Argument [ ] in Args = new CIM Argument [ ] { cim Argument . string Array ( STRING , new String [ ] { remove Entry } ) } ; CIM Argument [ ] out Args = new CIM Argument [ NUM ] ; invoke Method ( system , replication Svc , Smis Constants . EMC REMOVE SFSENTRIES , in Args , out Args ) ; } catch ( WBEM Exception e ) { log . error ( STRING , e ) ; } }
public void remove SFS Entry For Replica Replication Group ( Storage System system , CIM Object Path replication Svc , String replica Replication Group Name , String source Replication Group Name ) { List < String > sfs Entries = get EMCSFS Entries ( system , replication Svc ) ; String entry Label = format Replica Label For SFS Entry ( system . get Serial Number ( ) , replica Replication Group Name , source Replication Group Name ) ; String remove Entry = null ; if ( sfs Entries != null && ! sfs Entries . is Empty ( ) ) { for ( String entry : sfs Entries ) { if ( entry . contains ( entry Label ) ) { remove Entry = entry ; break ; } } } if ( remove Entry == null ) { log . info ( String . format ( STRING , replica Replication Group Name , source Replication Group Name ) ) ; return ; } try { CIM Argument [ ] in Args = new CIM Argument [ ] { cim Argument . string Array ( STRING , new String [ ] { remove Entry } ) } ; CIM Argument [ ] out Args = new CIM Argument [ NUM ] ; invoke Method ( system , replication Svc , Smis Constants . EMC REMOVE SFSENTRIES , in Args , out Args ) ; } catch ( WBEM Exception e ) { log . error ( STRING , e ) ; } }
private void load Latest Extension Versions ( ) { try { List < Extension > all = registry Manager . get Extensions ( ) ; if ( ! all . is Empty ( ) ) { set Latest Extension Versions ( get Latest Versions ( all ) ) ; } } catch ( Registry Exception e ) { String msg = Registry Exception . log Registry Exception ( e . get Type ( ) , this ) ; warnings . add Startup Error ( msg ) ; LOG . error ( msg ) ; msg = get Text ( STRING , new String [ ] { cfg . get Registry Url ( ) } ) ; warnings . add Startup Error ( msg ) ; LOG . error ( msg ) ; } finally { if ( get Latest Extension Versions ( ) == null ) { set Latest Extension Versions ( new Array List < Extension > ( ) ) ; } } }
public boolean needs Render ( Renderer renderer ) { boolean do Draw = needs Render . get And Set ( BOOL ) ; return ( do Draw ) ; }
public boolean needs Render ( Renderer renderer ) { boolean do Draw = needs Render . get And Set ( BOOL ) ; return ( do Draw ) ; }
public void delete ( URI resource Uri , String etag ) throws IO Exception , Service Exception { delete ( resource Uri . to URL ( ) , etag ) ; }
public void delete ( URI resource Uri , String etag ) throws IO Exception , Service Exception { delete ( resource Uri . to URL ( ) , etag ) ; }
public void delete ( URI resource Uri , String etag ) throws IO Exception , Service Exception { delete ( resource Uri . to URL ( ) , etag ) ; }
@ Override public void end Document ( ) throws SAX Exception { if ( resource != null ) { resource . add All Resource ( js Vector ) ; for ( Object object : resource . get Resource Set ( ) ) { Resource r = ( Resource ) object ; if ( r . get Resource ( ) != null ) { parser . set Resource ( ( Resource ) r ) ; parser . run ( ) ; js Set . add ( parser . get Result ( ) ) ; } } } }
boolean destroy Volume ( boolean force ) { Na Element elem = new Na Element ( STRING ) ; elem . add New Child ( STRING , Boolean . to String ( force ) ) ; elem . add New Child ( STRING , name ) ; try { server . invoke Elem ( elem ) ; return BOOL ; } catch ( Exception e ) { String msg = STRING + name ; log . error ( msg , e ) ; throw new Net App Exception ( msg , e ) ; } }
boolean destroy Volume ( boolean force ) { Na Element elem = new Na Element ( STRING ) ; elem . add New Child ( STRING , Boolean . to String ( force ) ) ; elem . add New Child ( STRING , name ) ; try { server . invoke Elem ( elem ) ; return BOOL ; } catch ( Exception e ) { String msg = STRING + name ; log . error ( msg , e ) ; throw new Net App Exception ( msg , e ) ; } }
public static Request Security Token Response parse XML ( Input Stream is ) throws WS Federation Exception { Document doc = XML Utils . to DOM Document ( is , debug ) ; Element root = doc . get Document Element ( ) ; return new Request Security Token Response ( root ) ; }
@ Override public void on Draw Frame ( GL 10 gl 10 ) { GLES 20 . gl Clear Color ( NUM , NUM , NUM , NUM ) ; GLES 20 . gl Clear ( GLES 20 . GL COLOR BUFFER BIT | GLES 20 . GL DEPTH BUFFER BIT ) ; GLES 20 . gl Enable ( GLES 20 . GL DEPTH TEST ) ; GLES 20 . gl Enable ( GLES 20 . GL CULL FACE ) ; long current Time Millis = System . current Time Millis ( ) ; update With Delta ( current Time Millis - last Time Millis ) ; last Time Millis = current Time Millis ; }
@ Override public void on Draw Frame ( GL 10 gl 10 ) { GLES 20 . gl Clear Color ( NUM , NUM , NUM , NUM ) ; GLES 20 . gl Clear ( GLES 20 . GL COLOR BUFFER BIT | GLES 20 . GL DEPTH BUFFER BIT ) ; GLES 20 . gl Enable ( GLES 20 . GL DEPTH TEST ) ; GLES 20 . gl Enable ( GLES 20 . GL CULL FACE ) ; long current Time Millis = System . current Time Millis ( ) ; update With Delta ( current Time Millis - last Time Millis ) ; last Time Millis = current Time Millis ; }
public static void create OPUS Directories ( Config config ) { log . info ( STRING ) ; Urban Sim Parameter Config Module V 3 module = M4 U Config Utils . get Urban Sim Parameter Config And Possibly Convert ( config ) ; File temp File = new File ( module . get Opus Home ( ) ) ; temp File . mkdirs ( ) ; temp File = new File ( module . get MAT Sim 4 Opus ( ) ) ; temp File . mkdirs ( ) ; temp File = new File ( module . get MAT Sim 4 Opus Output ( ) ) ; temp File . mkdirs ( ) ; temp File = new File ( module . get MAT Sim 4 Opus Temp ( ) ) ; temp File . mkdirs ( ) ; temp File = new File ( module . get MAT Sim 4 Opus Config ( ) ) ; temp File . mkdirs ( ) ; log . info ( STRING ) ; }
public static void create OPUS Directories ( Config config ) { log . info ( STRING ) ; Urban Sim Parameter Config Module V 3 module = M4 U Config Utils . get Urban Sim Parameter Config And Possibly Convert ( config ) ; File temp File = new File ( module . get Opus Home ( ) ) ; temp File . mkdirs ( ) ; temp File = new File ( module . get MAT Sim 4 Opus ( ) ) ; temp File . mkdirs ( ) ; temp File = new File ( module . get MAT Sim 4 Opus Output ( ) ) ; temp File . mkdirs ( ) ; temp File = new File ( module . get MAT Sim 4 Opus Temp ( ) ) ; temp File . mkdirs ( ) ; temp File = new File ( module . get MAT Sim 4 Opus Config ( ) ) ; temp File . mkdirs ( ) ; log . info ( STRING ) ; }
public static String replace Element Text ( String xml File , String tag Name , String value , boolean all , boolean overwrite ) throws DOM Exception { Map elements = new Hash Map ( ) ; elements . put ( tag Name , value ) ; return replace Element Text ( xml File , elements , all , overwrite ) ; }
public static String replace Element Text ( String xml File , String tag Name , String value , boolean all , boolean overwrite ) throws DOM Exception { Map elements = new Hash Map ( ) ; elements . put ( tag Name , value ) ; return replace Element Text ( xml File , elements , all , overwrite ) ; }
public static String replace Element Text ( String xml File , String tag Name , String value , boolean all , boolean overwrite ) throws DOM Exception { Map elements = new Hash Map ( ) ; elements . put ( tag Name , value ) ; return replace Element Text ( xml File , elements , all , overwrite ) ; }
public static String replace Element Text ( String xml File , String tag Name , String value , boolean all , boolean overwrite ) throws DOM Exception { Map elements = new Hash Map ( ) ; elements . put ( tag Name , value ) ; return replace Element Text ( xml File , elements , all , overwrite ) ; }
public static boolean ensure Inlinability ( Soot Method target , Stmt to Inline , Soot Method container , String modifier Options ) { if ( ! Inliner Safety Manager . can Safely Inline Into ( target , to Inline , container ) ) { return BOOL ; } if ( ! Access Manager . ensure Access ( container , target , modifier Options ) ) { return BOOL ; } if ( ! check Special Inline Restrictions ( container , target , modifier Options ) ) { return BOOL ; } if ( ! check Access Restrictions ( container , target , modifier Options ) ) { return BOOL ; } return BOOL ; }
public static boolean ensure Inlinability ( Soot Method target , Stmt to Inline , Soot Method container , String modifier Options ) { if ( ! Inliner Safety Manager . can Safely Inline Into ( target , to Inline , container ) ) { return BOOL ; } if ( ! Access Manager . ensure Access ( container , target , modifier Options ) ) { return BOOL ; } if ( ! check Special Inline Restrictions ( container , target , modifier Options ) ) { return BOOL ; } if ( ! check Access Restrictions ( container , target , modifier Options ) ) { return BOOL ; } return BOOL ; }
public static boolean ensure Inlinability ( Soot Method target , Stmt to Inline , Soot Method container , String modifier Options ) { if ( ! Inliner Safety Manager . can Safely Inline Into ( target , to Inline , container ) ) { return BOOL ; } if ( ! Access Manager . ensure Access ( container , target , modifier Options ) ) { return BOOL ; } if ( ! check Special Inline Restrictions ( container , target , modifier Options ) ) { return BOOL ; } if ( ! check Access Restrictions ( container , target , modifier Options ) ) { return BOOL ; } return BOOL ; }
public Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int [ ] band List ) { if ( x < this . min X ) { throw new Raster Format Exception ( STRING ) ; } if ( y < this . min Y ) { throw new Raster Format Exception ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . min X + this . width ) ) { throw new Raster Format Exception ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . min Y + this . height ) ) { throw new Raster Format Exception ( STRING ) ; } Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new Short Component Raster ( sm , data Buffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
public Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int [ ] band List ) { if ( x < this . min X ) { throw new Raster Format Exception ( STRING ) ; } if ( y < this . min Y ) { throw new Raster Format Exception ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . min X + this . width ) ) { throw new Raster Format Exception ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . min Y + this . height ) ) { throw new Raster Format Exception ( STRING ) ; } Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new Short Component Raster ( sm , data Buffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
public Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int [ ] band List ) { if ( x < this . min X ) { throw new Raster Format Exception ( STRING ) ; } if ( y < this . min Y ) { throw new Raster Format Exception ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . min X + this . width ) ) { throw new Raster Format Exception ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . min Y + this . height ) ) { throw new Raster Format Exception ( STRING ) ; } Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new Short Component Raster ( sm , data Buffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
public Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int [ ] band List ) { if ( x < this . min X ) { throw new Raster Format Exception ( STRING ) ; } if ( y < this . min Y ) { throw new Raster Format Exception ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . min X + this . width ) ) { throw new Raster Format Exception ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . min Y + this . height ) ) { throw new Raster Format Exception ( STRING ) ; } Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new Short Component Raster ( sm , data Buffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
public Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int [ ] band List ) { if ( x < this . min X ) { throw new Raster Format Exception ( STRING ) ; } if ( y < this . min Y ) { throw new Raster Format Exception ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . min X + this . width ) ) { throw new Raster Format Exception ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . min Y + this . height ) ) { throw new Raster Format Exception ( STRING ) ; } Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new Short Component Raster ( sm , data Buffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
public Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int [ ] band List ) { if ( x < this . min X ) { throw new Raster Format Exception ( STRING ) ; } if ( y < this . min Y ) { throw new Raster Format Exception ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . min X + this . width ) ) { throw new Raster Format Exception ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . min Y + this . height ) ) { throw new Raster Format Exception ( STRING ) ; } Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new Short Component Raster ( sm , data Buffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
public void clear Logcat ( @ Not Null I Device device , @ Not Null Project project ) { synchronized ( my Lock ) { Executor Service executor = my Executors . get ( device ) ; if ( executor != null ) { stop Receiving ( device ) ; executor . submit ( null ) ; start Receiving ( device ) ; } } }
public static void print Help ( Print Stream out ) { check Not Null ( out ) ; out . println ( STRING ) ; Set < Class < ? extends Pipeline Options > > sorted Options = new Tree Set < > ( Class Name Comparator . INSTANCE ) ; sorted Options . add All ( REGISTERED OPTIONS ) ; for ( Class < ? extends Pipeline Options > kls : sorted Options ) { out . format ( STRING , kls . get Name ( ) ) ; } out . format ( STRING + STRING + STRING ) ; }
public static void print Help ( Print Stream out ) { check Not Null ( out ) ; out . println ( STRING ) ; Set < Class < ? extends Pipeline Options > > sorted Options = new Tree Set < > ( Class Name Comparator . INSTANCE ) ; sorted Options . add All ( REGISTERED OPTIONS ) ; for ( Class < ? extends Pipeline Options > kls : sorted Options ) { out . format ( STRING , kls . get Name ( ) ) ; } out . format ( STRING + STRING + STRING ) ; }
public static void print Help ( Print Stream out ) { check Not Null ( out ) ; out . println ( STRING ) ; Set < Class < ? extends Pipeline Options > > sorted Options = new Tree Set < > ( Class Name Comparator . INSTANCE ) ; sorted Options . add All ( REGISTERED OPTIONS ) ; for ( Class < ? extends Pipeline Options > kls : sorted Options ) { out . format ( STRING , kls . get Name ( ) ) ; } out . format ( STRING + STRING + STRING ) ; }
private void compute Tip Visible Bounds ( ) { Rectangle r = tip Window . get Bounds ( ) ; Point p = r . get Location ( ) ; Swing Utilities . convert Point From Screen ( p , text Area ) ; r . set Location ( p ) ; tip Visible Bounds . set Bounds ( r . x , r . y - NUM , r . width , r . height + NUM * NUM ) ; }
private void compute Tip Visible Bounds ( ) { Rectangle r = tip Window . get Bounds ( ) ; Point p = r . get Location ( ) ; Swing Utilities . convert Point From Screen ( p , text Area ) ; r . set Location ( p ) ; tip Visible Bounds . set Bounds ( r . x , r . y - NUM , r . width , r . height + NUM * NUM ) ; }
private void compute Tip Visible Bounds ( ) { Rectangle r = tip Window . get Bounds ( ) ; Point p = r . get Location ( ) ; Swing Utilities . convert Point From Screen ( p , text Area ) ; r . set Location ( p ) ; tip Visible Bounds . set Bounds ( r . x , r . y - NUM , r . width , r . height + NUM * NUM ) ; }
private void compute Tip Visible Bounds ( ) { Rectangle r = tip Window . get Bounds ( ) ; Point p = r . get Location ( ) ; Swing Utilities . convert Point From Screen ( p , text Area ) ; r . set Location ( p ) ; tip Visible Bounds . set Bounds ( r . x , r . y - NUM , r . width , r . height + NUM * NUM ) ; }
private void compute Tip Visible Bounds ( ) { Rectangle r = tip Window . get Bounds ( ) ; Point p = r . get Location ( ) ; Swing Utilities . convert Point From Screen ( p , text Area ) ; r . set Location ( p ) ; tip Visible Bounds . set Bounds ( r . x , r . y - NUM , r . width , r . height + NUM * NUM ) ; }
public static long find Number ( String str , int offset ) throws Tag Exception { if ( str == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ( offset < NUM ) || ( offset >= str . length ( ) ) ) { throw new Index Out Of Bounds Exception ( STRING + offset + STRING + str . length ( ) ) ; } int i ; int j ; long num ; i = offset ; while ( i < str . length ( ) ) { if ( ( ( str . char At ( i ) >= STRING ) && ( str . char At ( i ) <= STRING ) ) || ( str . char At ( i ) == STRING ) ) { break ; } i ++ ; } j = i + NUM ; while ( j < str . length ( ) ) { if ( ( ( str . char At ( j ) < STRING ) || ( str . char At ( j ) > STRING ) ) ) { break ; } j ++ ; } if ( ( j <= str . length ( ) ) && ( j > i ) ) { num = Long . parse Long ( str . substring ( i , j ) ) ; } else { throw new Tag Exception ( STRING + str ) ; } return num ; }
public void render Roads ( OM Graphic List gl , boolean force New ) { for ( Enumeration e = roads . elements ( ) ; e . has More Elements ( ) ; ) { Road road = ( Road ) e . next Element ( ) ; if ( road . get First Intersection ( ) == this ) road . render ( gl , force New ) ; } }
public void render Roads ( OM Graphic List gl , boolean force New ) { for ( Enumeration e = roads . elements ( ) ; e . has More Elements ( ) ; ) { Road road = ( Road ) e . next Element ( ) ; if ( road . get First Intersection ( ) == this ) road . render ( gl , force New ) ; } }
private void check For Conflicting Arguments ( ) throws Argument Exception { throw If Arguments Conflict ( bind Password Arg , bind Password File Arg ) ; throw If Arguments Conflict ( trust All Arg , trust Store Path Arg ) ; throw If Arguments Conflict ( trust All Arg , trust Store Password Arg ) ; throw If Arguments Conflict ( trust All Arg , trust Store Password File Arg ) ; throw If Arguments Conflict ( trust Store Password Arg , trust Store Password File Arg ) ; throw If Arguments Conflict ( use Start TLS Arg , use SSL Arg ) ; if ( trust Store Path Arg . is Present ( ) ) { final String value = trust Store Path Arg . get Value ( ) ; if ( ! can Read Path ( value ) ) { final Localizable Message message = ERR CANNOT READ TRUSTSTORE . get ( value ) ; throw new Argument Exception ( message ) ; } } if ( key Store Path Arg . is Present ( ) ) { final String value = key Store Path Arg . get Value ( ) ; if ( ! can Read Path ( value ) ) { final Localizable Message message = ERR CANNOT READ KEYSTORE . get ( value ) ; throw new Argument Exception ( message ) ; } } }
private boolean check Convergence ( Collection < Individuum > pop ) { if ( pop . is Empty ( ) ) { return BOOL ; } int [ ] [ ] occur = new int [ dim ] [ phi + NUM ] ; for ( Individuum ind : pop ) { short [ ] gene = ind . get Gene ( ) ; for ( int d = NUM ; d < dim ; d ++ ) { if ( gene [ d ] == DONT CARE ) { occur [ d ] [ NUM ] += NUM ; continue ; } int val = gene [ d ] - GENE OFFSET ; if ( val < NUM || val >= phi ) { LOG . warning ( STRING + val + STRING + ind . to String ( ) ) ; continue ; } occur [ d ] [ val + NUM ] += NUM ; } } int conv = ( int ) Math . floor ( pop . size ( ) * CONVERGENCE ) ; if ( LOG . is Debugging Fine ( ) ) { LOG . debug Fine ( STRING + conv + STRING + pop . size ( ) + STRING ) ; } for ( int d = NUM ; d < dim ; d ++ ) { boolean converged = BOOL ; for ( int val = NUM ; val <= phi ; val ++ ) { if ( occur [ d ] [ val ] >= conv ) { converged = BOOL ; break ; } } if ( ! converged ) { return BOOL ; } } return BOOL ; }
private void create Scene Vao ( ) { int vao = gl Gen Vertex Arrays ( ) ; int vbo = gl Gen Buffers ( ) ; gl Bind Vertex Array ( vao ) ; gl Bind Buffer ( GL ARRAY BUFFER , vbo ) ; long buffer Size = NUM * ( NUM + NUM ) * mesh . num Vertices ; long normals Offset = NUM * NUM * mesh . num Vertices ; gl Buffer Data ( GL ARRAY BUFFER , buffer Size , GL STATIC DRAW ) ; gl Buffer Sub Data ( GL ARRAY BUFFER , NUM , mesh . positions ) ; gl Buffer Sub Data ( GL ARRAY BUFFER , normals Offset , mesh . normals ) ; gl Enable Vertex Attrib Array ( NUM ) ; gl Vertex Attrib Pointer ( NUM , NUM , GL FLOAT , BOOL , NUM , NUM ) ; gl Enable Vertex Attrib Array ( NUM ) ; gl Vertex Attrib Pointer ( NUM , NUM , GL FLOAT , BOOL , NUM , normals Offset ) ; gl Bind Buffer ( GL ARRAY BUFFER , NUM ) ; gl Bind Vertex Array ( NUM ) ; this . vao Scene = vao ; }
public static boolean valid System Name Config ( String system Name , char type ) { if ( ! valid System Name Format ( system Name , type ) ) { return BOOL ; } return BOOL ; }
public static boolean valid System Name Config ( String system Name , char type ) { if ( ! valid System Name Format ( system Name , type ) ) { return BOOL ; } return BOOL ; }
public static boolean valid System Name Config ( String system Name , char type ) { if ( ! valid System Name Format ( system Name , type ) ) { return BOOL ; } return BOOL ; }
public Entity Query where ( Entity Condition ... entity Condition ) { this . where Entity Condition = Entity Condition . make Condition ( Arrays . as List ( entity Condition ) ) ; return this ; }
public Entity Query where ( Entity Condition ... entity Condition ) { this . where Entity Condition = Entity Condition . make Condition ( Arrays . as List ( entity Condition ) ) ; return this ; }
protected void extend Element ( Element e ) { }
protected void extend Element ( Element e ) { }
public static I Proposal Computer new Ui Field Attribute Proposal Computer ( Content Assist Request content Assist Request ) { IDOM Node node = ( IDOM Node ) content Assist Request . get Node ( ) ; if ( node . get Node Type ( ) != IDOM Node . ELEMENT NODE ) { return null ; } if ( Xml Utilities . get Attribute ( node , Ui Binder Constants . UI BINDER FIELD ATTRIBUTE NAME , BOOL , Ui Binder Constants . UI BINDER XML NAMESPACE ) != null ) { return null ; } boolean is Widget = Ui Binder Xml Model Utilities . compute Qualified Widget Type Name ( node ) != null ; boolean is Likely Html Element = node . get Namespace URI ( ) == null ; if ( ! ( is Widget || is Likely Html Element ) ) { return null ; } return create Static Text Proposal Computer For Ui Attribute ( Ui Binder Constants . UI BINDER FIELD ATTRIBUTE NAME , node , content Assist Request ) ; }
public static void check Argument ( boolean expression , @ Nullable Object error Message ) { if ( ! expression ) { throw new Illegal Argument Exception ( String . value Of ( error Message ) ) ; } }
public static void check Argument ( boolean expression , @ Nullable Object error Message ) { if ( ! expression ) { throw new Illegal Argument Exception ( String . value Of ( error Message ) ) ; } }
public static void check Argument ( boolean expression , @ Nullable Object error Message ) { if ( ! expression ) { throw new Illegal Argument Exception ( String . value Of ( error Message ) ) ; } }
@ Suppress Warnings ( STRING ) private < T > T read By Class ( Buffer Input < ? > buffer ) { String name = buffer . read UTF 8 ( ) ; if ( whitelist Required . get ( ) ) throw new Serialization Exception ( STRING + name ) ; Class < T > type = ( Class < T > ) types . get ( name ) ; if ( type == null ) { try { type = ( Class < T > ) Class . for Name ( name ) ; if ( type == null ) throw new Serialization Exception ( STRING ) ; types . put ( name , type ) ; } catch ( Class Not Found Exception e ) { throw new Serialization Exception ( STRING + name , e ) ; } } Type Serializer < T > serializer = get Serializer ( type ) ; if ( serializer == null ) throw new Serialization Exception ( STRING + name ) ; return serializer . read ( type , buffer , this ) ; }
protected void generate Document Children ( Element root , Document doc , Tree delphi Node ) { if ( root == null || doc == null ) { return ; } for ( int i = NUM ; i < delphi Node . get Child Count ( ) ; ++ i ) { Tree child Node = delphi Node . get Child ( i ) ; String processed Name = process Node Name ( child Node ) ; Element child = null ; try { child = doc . create Element ( processed Name ) ; } catch ( DOM Exception e ) { child = doc . create Element ( STRING ) ; } child . set Text Content ( child Node . get Text ( ) ) ; child . set Attribute ( STRING , String . value Of ( child Node . get Line ( ) ) ) ; child . set Attribute ( STRING , String . value Of ( child Node . get Char Position In Line ( ) ) ) ; child . set Attribute ( STRING , STRING ) ; child . set Attribute ( STRING , STRING ) ; child . set Attribute ( STRING , STRING ) ; child . set Attribute ( STRING , String . value Of ( child Node . get Type ( ) ) ) ; root . append Child ( child ) ; generate Document Children ( child , doc , child Node ) ; } }
default < V > Generator < V > and Then ( Function < ? super T , ? extends V > after ) { Objects . require Non Null ( after ) ; return null ; }
default < V > Generator < V > and Then ( Function < ? super T , ? extends V > after ) { Objects . require Non Null ( after ) ; return null ; }
public static boolean is Currently Final ( RVM Method callee , boolean search Subclasses ) { RVM Class klass = callee . get Declaring Class ( ) ; if ( klass . is Interface ( ) ) { return BOOL ; } RVM Class [ ] sub Classes = klass . get Sub Classes ( ) ; if ( sub Classes . length == NUM ) { return BOOL ; } else if ( search Subclasses ) { Stack < RVM Class > s = new Stack < RVM Class > ( ) ; for ( RVM Class sub Class 1 : sub Classes ) { s . push ( sub Class 1 ) ; } while ( ! s . is Empty ( ) ) { RVM Class sub Class = s . pop ( ) ; if ( sub Class . find Declared Method ( callee . get Name ( ) , callee . get Descriptor ( ) ) != null ) { return BOOL ; } sub Classes = sub Class . get Sub Classes ( ) ; for ( RVM Class sub Class 1 : sub Classes ) { s . push ( sub Class 1 ) ; } } return BOOL ; } else { return BOOL ; } }
public static boolean is Currently Final ( RVM Method callee , boolean search Subclasses ) { RVM Class klass = callee . get Declaring Class ( ) ; if ( klass . is Interface ( ) ) { return BOOL ; } RVM Class [ ] sub Classes = klass . get Sub Classes ( ) ; if ( sub Classes . length == NUM ) { return BOOL ; } else if ( search Subclasses ) { Stack < RVM Class > s = new Stack < RVM Class > ( ) ; for ( RVM Class sub Class 1 : sub Classes ) { s . push ( sub Class 1 ) ; } while ( ! s . is Empty ( ) ) { RVM Class sub Class = s . pop ( ) ; if ( sub Class . find Declared Method ( callee . get Name ( ) , callee . get Descriptor ( ) ) != null ) { return BOOL ; } sub Classes = sub Class . get Sub Classes ( ) ; for ( RVM Class sub Class 1 : sub Classes ) { s . push ( sub Class 1 ) ; } } return BOOL ; } else { return BOOL ; } }
public boolean remove ( String path ) { return deleted Files . remove ( path ) ; }
public boolean remove ( String path ) { return deleted Files . remove ( path ) ; }
public boolean remove ( String path ) { return deleted Files . remove ( path ) ; }
public static < M , A > List T < M , A > cons ( Applicative < M > applicative , Supplier < A > sup Head , Supplier < List T < M , A > > sup Tail ) { return new List T < > ( applicative . pure ( yield ( sup Head . get ( ) , sup Tail ) ) ) ; }
protected String process Command ( final String command ) { return process Command ( command , get Environment ( ) , null ) ; }
public void test Add After Stop ( ) throws Exception { delete All Docs ( ) ; send ( STRING ) ; try { send ( STRING , STRING ) ; fail ( ) ; } catch ( IO Exception ioe ) { } send ( STRING ) ; }
public void verify ( Public Key key ) throws CRL Exception , No Such Algorithm Exception , Invalid Key Exception , No Such Provider Exception , Signature Exception { verify ( key , STRING ) ; }
int add Variable Name ( final org . apache . xml . utils . Q Name qname ) { int pos = m variable Names . size ( ) ; m variable Names . add Element ( qname ) ; int frame Size = m variable Names . size ( ) - get Globals Size ( ) ; if ( frame Size > m max Stack Frame Size ) m max Stack Frame Size ++ ; return pos ; }
public C Selection Criterium Panel ( final C Selection Criterium criterium ) { super ( new Border Layout ( ) ) ; m criterium = criterium ; selection State Box . add Action Listener ( selection State Box Listener ) ; init Panel ( ) ; }
public void put ( String [ ] local Files , String remote Target Directory , String mode ) throws IO Exception { put ( local Files , null , remote Target Directory , mode ) ; }
public void put ( String [ ] local Files , String remote Target Directory , String mode ) throws IO Exception { put ( local Files , null , remote Target Directory , mode ) ; }
public void put ( String [ ] local Files , String remote Target Directory , String mode ) throws IO Exception { put ( local Files , null , remote Target Directory , mode ) ; }
public Collection < Object > injectables ( ) { return Collections . empty List ( ) ; }
public Collection < Object > injectables ( ) { return Collections . empty List ( ) ; }
public Collection < Object > injectables ( ) { return Collections . empty List ( ) ; }
public Collection < Object > injectables ( ) { return Collections . empty List ( ) ; }
public Collection < Object > injectables ( ) { return Collections . empty List ( ) ; }
public Collection < Object > injectables ( ) { return Collections . empty List ( ) ; }
public Collection < Object > injectables ( ) { return Collections . empty List ( ) ; }
public Collection < Object > injectables ( ) { return Collections . empty List ( ) ; }
private boolean is Message For Me ( Update Message msg ) { if ( msg == null ) { return BOOL ; } return is Message Eligible For My Os ( msg ) && is Message Eligible For My Lang ( msg ) && is Message Eligible For My Version ( msg ) ; }
private boolean is Message For Me ( Update Message msg ) { if ( msg == null ) { return BOOL ; } return is Message Eligible For My Os ( msg ) && is Message Eligible For My Lang ( msg ) && is Message Eligible For My Version ( msg ) ; }
private boolean is Message For Me ( Update Message msg ) { if ( msg == null ) { return BOOL ; } return is Message Eligible For My Os ( msg ) && is Message Eligible For My Lang ( msg ) && is Message Eligible For My Version ( msg ) ; }
private boolean is Message For Me ( Update Message msg ) { if ( msg == null ) { return BOOL ; } return is Message Eligible For My Os ( msg ) && is Message Eligible For My Lang ( msg ) && is Message Eligible For My Version ( msg ) ; }
public boolean add Journal Rollback Step ( URI rp System Id , String token ) throws Workflow Exception { Workflow Step Completer . step Succeded ( token ) ; return BOOL ; }
public boolean add Journal Rollback Step ( URI rp System Id , String token ) throws Workflow Exception { Workflow Step Completer . step Succeded ( token ) ; return BOOL ; }
protected double animate Value ( double cur Val , double goal Val , double speed ) { double ret = cur Val ; if ( ret < goal Val ) { ret += speed ; } else if ( ret > goal Val ) { ret -= speed ; } if ( Math . abs ( ret - goal Val ) < speed ) { ret = goal Val ; } return ret ; }
@ Log Message Doc ( level = STRING , message = STRING , explanation = STRING + STRING , recommendation = Log Message Doc . CHECK SWITCH ) private void write OF Messages To Switch ( Datapath Id dpid , List < OF Message > messages ) { IOF Switch ofswitch = switch Service . get Switch ( dpid ) ; if ( ofswitch != null ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING , messages . size ( ) , dpid ) ; } ofswitch . write ( messages ) ; ofswitch . flush ( ) ; } }
public final void load ( ) throws Injection Exception { try { static Context Lock . acquire ( ) ; } catch ( Interrupted Exception e ) { throw new Injection Exception ( STRING , e ) ; } final Injector injector = new Injector ( define Package ( ) ) ; Map < Class < ? > , Object > beans = injector . load All Beans ( this ) ; injector . inject All Beans ( strict Loading Policy , beans ) ; }
public final void load ( ) throws Injection Exception { try { static Context Lock . acquire ( ) ; } catch ( Interrupted Exception e ) { throw new Injection Exception ( STRING , e ) ; } final Injector injector = new Injector ( define Package ( ) ) ; Map < Class < ? > , Object > beans = injector . load All Beans ( this ) ; injector . inject All Beans ( strict Loading Policy , beans ) ; }
protected void post Notify Uri ( Uri uri ) { synchronized ( m Changed Uris ) { m Changed Uris . add ( uri ) ; } }
protected void post Notify Uri ( Uri uri ) { synchronized ( m Changed Uris ) { m Changed Uris . add ( uri ) ; } }
protected void post Notify Uri ( Uri uri ) { synchronized ( m Changed Uris ) { m Changed Uris . add ( uri ) ; } }
protected void post Notify Uri ( Uri uri ) { synchronized ( m Changed Uris ) { m Changed Uris . add ( uri ) ; } }
public void add ( String key String , String value ) { put ( key String , value ) ; line Data . add ( STRING ) ; key Data . add ( key String ) ; }
public static Version serializable Instance ( ) { return new Version ( STRING ) ; }
public static Version serializable Instance ( ) { return new Version ( STRING ) ; }
void clean Up ( ) { Map tmp Cq = this . cqs ; if ( tmp Cq . size ( ) > NUM ) { for ( Object server Cq Name : tmp Cq . key Set ( ) ) { process Close Cq ( ( String ) server Cq Name ) ; } } }
void clean Up ( ) { Map tmp Cq = this . cqs ; if ( tmp Cq . size ( ) > NUM ) { for ( Object server Cq Name : tmp Cq . key Set ( ) ) { process Close Cq ( ( String ) server Cq Name ) ; } } }
public static String newick No Lengths ( Tree tree ) { String Buffer buffer = new String Buffer ( ) ; newick ( tree , tree . get Root ( ) , BOOL , Branch Length Type . NO BRANCH LENGTHS , null , null , null , null , buffer ) ; buffer . append ( STRING ) ; return buffer . to String ( ) ; }
public static String newick No Lengths ( Tree tree ) { String Buffer buffer = new String Buffer ( ) ; newick ( tree , tree . get Root ( ) , BOOL , Branch Length Type . NO BRANCH LENGTHS , null , null , null , null , buffer ) ; buffer . append ( STRING ) ; return buffer . to String ( ) ; }
private static int add To Buffer ( Writer out , char [ ] buffer , int buffer Index , int buffer Length , char ch ) throws IO Exception { if ( buffer Index >= buffer Length ) { out . write ( buffer , NUM , buffer Index ) ; buffer Index = NUM ; } buffer [ buffer Index ] = ch ; return buffer Index + NUM ; }
private static int add To Buffer ( Writer out , char [ ] buffer , int buffer Index , int buffer Length , char ch ) throws IO Exception { if ( buffer Index >= buffer Length ) { out . write ( buffer , NUM , buffer Index ) ; buffer Index = NUM ; } buffer [ buffer Index ] = ch ; return buffer Index + NUM ; }
private static int add To Buffer ( Writer out , char [ ] buffer , int buffer Index , int buffer Length , char ch ) throws IO Exception { if ( buffer Index >= buffer Length ) { out . write ( buffer , NUM , buffer Index ) ; buffer Index = NUM ; } buffer [ buffer Index ] = ch ; return buffer Index + NUM ; }
static final public Object deserialize ( final Input Stream is ) { try { final Object Input Stream ois = new Object Input Stream ( is ) ; return ois . read Object ( ) ; } catch ( Exception ex ) { throw new Runtime Exception ( ex ) ; } }
public String correct ( String a Word ) { if ( ( a Word . length ( ) < NUM ) || is Number ( a Word ) ) { return a Word ; } boolean is Upper = is Upper Case ( a Word . char At ( NUM ) ) ; String word = a Word . to Lower Case ( ) ; String correction = cached Corrections . get ( word ) ; if ( correction == null ) { correction = get Best Candidate ( word ) ; cached Corrections . put ( word , correction ) ; } char [ ] buffer = correction . to Char Array ( ) ; if ( is Upper ) { buffer [ NUM ] = to Upper Case ( buffer [ NUM ] ) ; } return new String ( buffer ) ; }
public void write ( byte [ ] bytes , int length ) { if ( digest == null ) { return ; } digest . update ( bytes , NUM , length ) ; }
public Configure String List NB ( ) { init Components ( ) ; this . validator = new Default Validator ( ) ; j Button State Controller = new J Button State Controller ( add Btn ) ; Document document = add Text Field . get Document ( ) ; document . add Document Listener ( j Button State Controller ) ; }
public void remove ( String key ) throws Illegal State Exception { validate Key ( key ) ; Entry entry ; synchronized ( m Disk Cache Lock ) { entry = m Lru Entries . remove ( key ) ; } if ( entry != null ) { if ( entry . get Current Editor Stream ( ) != null ) { throw new Illegal State Exception ( STRING ) ; } File file = entry . get Clean File ( ) ; if ( ! file . exists ( ) || file . delete ( ) ) { m Size In Bytes . get And Add ( - entry . get Length In Bytes ( ) ) ; } else { synchronized ( m Remove Retry Lock ) { m Remove Retry List . add ( entry ) ; } } } }
public void remove ( String key ) throws Illegal State Exception { validate Key ( key ) ; Entry entry ; synchronized ( m Disk Cache Lock ) { entry = m Lru Entries . remove ( key ) ; } if ( entry != null ) { if ( entry . get Current Editor Stream ( ) != null ) { throw new Illegal State Exception ( STRING ) ; } File file = entry . get Clean File ( ) ; if ( ! file . exists ( ) || file . delete ( ) ) { m Size In Bytes . get And Add ( - entry . get Length In Bytes ( ) ) ; } else { synchronized ( m Remove Retry Lock ) { m Remove Retry List . add ( entry ) ; } } } }
public void remove ( String key ) throws Illegal State Exception { validate Key ( key ) ; Entry entry ; synchronized ( m Disk Cache Lock ) { entry = m Lru Entries . remove ( key ) ; } if ( entry != null ) { if ( entry . get Current Editor Stream ( ) != null ) { throw new Illegal State Exception ( STRING ) ; } File file = entry . get Clean File ( ) ; if ( ! file . exists ( ) || file . delete ( ) ) { m Size In Bytes . get And Add ( - entry . get Length In Bytes ( ) ) ; } else { synchronized ( m Remove Retry Lock ) { m Remove Retry List . add ( entry ) ; } } } }
public void write ( byte b [ ] , int off , int len ) throws IO Exception { raf . write ( b , off , len ) ; }
public static < T > List < T > rest ( List < T > l ) { return l . sub List ( NUM , l . size ( ) ) ; }
public void add Field Buffered ( V Editor editor , Grid Field m Field ) { wrap = m Field != null ? ! m Field . is Same Line ( ) : BOOL ; if ( prev Editor != null && prev Field != null ) add Field ( prev Editor , prev Field ) ; prev Editor = editor ; prev Field = m Field ; }
public void add First ( Statement Sequence statements ) { if ( statements != null ) { sequence . add All ( NUM , statements . sequence ) ; } }
@ Override public void class Initialized ( String class Name With Dots ) { if ( ! initialized Classes . contains ( class Name With Dots ) ) { initialized Classes . add ( class Name With Dots ) ; } }
@ Override public void class Initialized ( String class Name With Dots ) { if ( ! initialized Classes . contains ( class Name With Dots ) ) { initialized Classes . add ( class Name With Dots ) ; } }
@ Override public void class Initialized ( String class Name With Dots ) { if ( ! initialized Classes . contains ( class Name With Dots ) ) { initialized Classes . add ( class Name With Dots ) ; } }
public static Array List < String > string To Array List ( String string ) { return new Array List < > ( Arrays . as List ( string . split ( STRING ) ) ) ; }
@ Override public Foo fetch By Uuid Last ( String uuid , Order By Comparator < Foo > order By Comparator ) { int count = count By Uuid ( uuid ) ; if ( count == NUM ) { return null ; } List < Foo > list = find By Uuid ( uuid , count - NUM , count , order By Comparator ) ; if ( ! list . is Empty ( ) ) { return list . get ( NUM ) ; } return null ; }
protected void compute Max Size ( int capacity ) { max Size = Math . min ( capacity - NUM , ( int ) ( capacity * load Factor ) ) ; free = capacity - size ; }
protected void compute Max Size ( int capacity ) { max Size = Math . min ( capacity - NUM , ( int ) ( capacity * load Factor ) ) ; free = capacity - size ; }
public Media Video Item create Media Item ( Video Editor video Editor , String Media Id , String filename , int rendering Mode ) { Media Video Item mvi = null ; try { mvi = new Media Video Item ( video Editor , Media Id , filename , rendering Mode ) ; assert Not Null ( STRING , mvi ) ; } catch ( Illegal Argument Exception e ) { throw new Illegal Argument Exception ( STRING + filename + STRING + e . to String ( ) ) ; } catch ( IO Exception e ) { assert True ( STRING + filename + STRING + e . to String ( ) , BOOL ) ; } return mvi ; }
protected void restore State ( ) { if ( tree != null ) { System . arraycopy ( stored Intervals , NUM , intervals , NUM , stored Intervals . length ) ; System . arraycopy ( stored Lineage Counts , NUM , lineage Counts , NUM , stored Lineage Counts . length ) ; intervals Known = stored Intervals Known ; interval Count = stored Interval Count ; } else if ( trees Set != null ) { trees Set . restore The State ( ) ; } likelihood Known = stored Likelihood Known ; log Likelihood = stored Log Likelihood ; if ( ! intervals Known ) { likelihood Known = BOOL ; } }
public static void create Dir ( File target ) throws Ade Usage Exception { if ( ! target . exists ( ) && ! target . mkdir ( ) && ! target . exists ( ) ) { throw new Ade Usage Exception ( STRING + target . get Path ( ) ) ; } }
public static void create Dir ( File target ) throws Ade Usage Exception { if ( ! target . exists ( ) && ! target . mkdir ( ) && ! target . exists ( ) ) { throw new Ade Usage Exception ( STRING + target . get Path ( ) ) ; } }
public void write Field ( String name , float value ) throws java . io . IO Exception { write Field ( name , Float . to String ( value ) ) ; }
public static String format Quantity ( Integer quantity ) { if ( quantity == null ) return STRING ; else return format Quantity ( quantity . double Value ( ) ) ; }
public static String format Quantity ( Integer quantity ) { if ( quantity == null ) return STRING ; else return format Quantity ( quantity . double Value ( ) ) ; }
public static String color To Hex ( int color ) { return String . format ( STRING , ( NUM & color ) ) ; }
protected void write Message Out ( Modbus Message msg ) throws Modbus IO Exception { try { int len ; synchronized ( byte Output Stream ) { clear Input ( ) ; byte Output Stream . reset ( ) ; msg . set Headless ( ) ; msg . write To ( byte Output Stream ) ; len = byte Output Stream . size ( ) ; int [ ] crc = Modbus Util . calculate CRC ( byte Output Stream . get Buffer ( ) , NUM , len ) ; byte Output Stream . write Byte ( crc [ NUM ] ) ; byte Output Stream . write Byte ( crc [ NUM ] ) ; write Bytes ( byte Output Stream . get Buffer ( ) , byte Output Stream . size ( ) ) ; logger . debug ( STRING , Modbus Util . to Hex ( byte Output Stream . get Buffer ( ) , NUM , byte Output Stream . size ( ) ) ) ; if ( echo ) { read Echo ( len ) ; } last Request = new byte [ len ] ; System . arraycopy ( byte Output Stream . get Buffer ( ) , NUM , last Request , NUM , len ) ; } } catch ( IO Exception ex ) { throw new Modbus IO Exception ( STRING ) ; } }
public Say NPC Names For Unstarted Quests Action ( String region ) { this . regions = Arrays . as List ( region ) ; }
public final Result check ( Push Certificate cert ) { if ( check Nonce && cert . get Nonce Status ( ) != Nonce Status . OK ) { return new Result ( null , Check Result . bad ( STRING ) ) ; } List < Check Result > results = new Array List < > ( NUM ) ; Result sig Result = null ; try { PGP Signature sig = read Signature ( cert ) ; if ( sig != null ) { @ Suppress Warnings ( STRING ) Repository repo = get Repository ( ) ; try ( Public Key Store store = new Public Key Store ( repo ) ) { sig Result = check Signature ( sig , cert , store ) ; results . add ( check Custom ( repo ) ) ; } finally { if ( should Close ( repo ) ) { repo . close ( ) ; } } } else { results . add ( Check Result . bad ( STRING ) ) ; } } catch ( PGP Exception | IO Exception e ) { String msg = STRING ; log . error ( msg , e ) ; results . add ( Check Result . bad ( msg ) ) ; } return combine ( sig Result , results ) ; }
public final Result check ( Push Certificate cert ) { if ( check Nonce && cert . get Nonce Status ( ) != Nonce Status . OK ) { return new Result ( null , Check Result . bad ( STRING ) ) ; } List < Check Result > results = new Array List < > ( NUM ) ; Result sig Result = null ; try { PGP Signature sig = read Signature ( cert ) ; if ( sig != null ) { @ Suppress Warnings ( STRING ) Repository repo = get Repository ( ) ; try ( Public Key Store store = new Public Key Store ( repo ) ) { sig Result = check Signature ( sig , cert , store ) ; results . add ( check Custom ( repo ) ) ; } finally { if ( should Close ( repo ) ) { repo . close ( ) ; } } } else { results . add ( Check Result . bad ( STRING ) ) ; } } catch ( PGP Exception | IO Exception e ) { String msg = STRING ; log . error ( msg , e ) ; results . add ( Check Result . bad ( msg ) ) ; } return combine ( sig Result , results ) ; }
public void select Next Overlay ( ) { if ( m Current Overlay Index == NO OVERLAY ) { if ( m Overlays . is Empty ( ) ) { return ; } m Current Overlay Index = NUM ; } else { m Current Overlay Index = ++ m Current Overlay Index % m Overlays . size ( ) ; if ( m Current Overlay Index == NUM ) { m Current Overlay Index = NO OVERLAY ; } } do Set Overlay ( get Current Overlay ( ) ) ; }
public static void add Default Resource ( String name ) { Array List < Configuration > to Reload ; synchronized ( Configuration . class ) { if ( default Resources . contains ( name ) ) { return ; } default Resources . add ( name ) ; to Reload = new Array List < > ( REGISTRY . size ( ) ) ; to Reload . add All ( REGISTRY . key Set ( ) ) ; } for ( Configuration conf : to Reload ) { if ( conf . load Defaults ) { conf . reload Configuration ( ) ; } } }
public static void add Default Resource ( String name ) { Array List < Configuration > to Reload ; synchronized ( Configuration . class ) { if ( default Resources . contains ( name ) ) { return ; } default Resources . add ( name ) ; to Reload = new Array List < > ( REGISTRY . size ( ) ) ; to Reload . add All ( REGISTRY . key Set ( ) ) ; } for ( Configuration conf : to Reload ) { if ( conf . load Defaults ) { conf . reload Configuration ( ) ; } } }
private void copy Signer To New Location ( ) { String tenant Ldu Dn = get Ldu Dn ( ) ; I Ldap Message creds Objects = null ; try { creds Objects = get Tenant Credentials ( tenant Ldu Dn ) ; int max Index = get Curr Max Index ( TRUSTED CRED OBJECT CLASS , null ) + NUM ; String cn = get Tenant Credential Cn ( max Index ) ; I Ldap Entry last Signer = get Last Signer ( creds Objects ) ; List < Ldap Mod > mod Values = create Atts ( last Signer ) ; Ldap Value [ ] values = { new Ldap Value ( cn ) } ; Ldap Mod mod = new Ldap Mod ( Ldap Mod Operation . ADD , STRING , values ) ; mod Values . add ( mod ) ; String base Dn = String . format ( STRING , tenant Name , this . root Dn ) ; String new Dn = STRING + cn + STRING + base Dn ; connection . add Object ( new Dn , mod Values . to Array ( new Ldap Mod [ ] { } ) ) ; } finally { close Message ( creds Objects ) ; } }
private void copy Signer To New Location ( ) { String tenant Ldu Dn = get Ldu Dn ( ) ; I Ldap Message creds Objects = null ; try { creds Objects = get Tenant Credentials ( tenant Ldu Dn ) ; int max Index = get Curr Max Index ( TRUSTED CRED OBJECT CLASS , null ) + NUM ; String cn = get Tenant Credential Cn ( max Index ) ; I Ldap Entry last Signer = get Last Signer ( creds Objects ) ; List < Ldap Mod > mod Values = create Atts ( last Signer ) ; Ldap Value [ ] values = { new Ldap Value ( cn ) } ; Ldap Mod mod = new Ldap Mod ( Ldap Mod Operation . ADD , STRING , values ) ; mod Values . add ( mod ) ; String base Dn = String . format ( STRING , tenant Name , this . root Dn ) ; String new Dn = STRING + cn + STRING + base Dn ; connection . add Object ( new Dn , mod Values . to Array ( new Ldap Mod [ ] { } ) ) ; } finally { close Message ( creds Objects ) ; } }
private void copy Signer To New Location ( ) { String tenant Ldu Dn = get Ldu Dn ( ) ; I Ldap Message creds Objects = null ; try { creds Objects = get Tenant Credentials ( tenant Ldu Dn ) ; int max Index = get Curr Max Index ( TRUSTED CRED OBJECT CLASS , null ) + NUM ; String cn = get Tenant Credential Cn ( max Index ) ; I Ldap Entry last Signer = get Last Signer ( creds Objects ) ; List < Ldap Mod > mod Values = create Atts ( last Signer ) ; Ldap Value [ ] values = { new Ldap Value ( cn ) } ; Ldap Mod mod = new Ldap Mod ( Ldap Mod Operation . ADD , STRING , values ) ; mod Values . add ( mod ) ; String base Dn = String . format ( STRING , tenant Name , this . root Dn ) ; String new Dn = STRING + cn + STRING + base Dn ; connection . add Object ( new Dn , mod Values . to Array ( new Ldap Mod [ ] { } ) ) ; } finally { close Message ( creds Objects ) ; } }
public void add RS ( Rolling Stock rs ) { set Number RS ( get Number RS ( ) + NUM ) ; if ( rs . get Class ( ) == Car . class ) { set Number Cars ( get Number Cars ( ) + NUM ) ; } else if ( rs . get Class ( ) == Engine . class ) { set Number Engines ( get Number Engines ( ) + NUM ) ; } set Used Length ( get Used Length ( ) + rs . get Total Length ( ) ) ; }
static String color To Hex ( Color color ) { String colorstr = STRING ; String str = Integer . to Hex String ( color . get Red ( ) ) ; if ( str . length ( ) > NUM ) str = str . substring ( NUM , NUM ) ; else if ( str . length ( ) < NUM ) colorstr += STRING + str ; else colorstr += str ; str = Integer . to Hex String ( color . get Green ( ) ) ; if ( str . length ( ) > NUM ) str = str . substring ( NUM , NUM ) ; else if ( str . length ( ) < NUM ) colorstr += STRING + str ; else colorstr += str ; str = Integer . to Hex String ( color . get Blue ( ) ) ; if ( str . length ( ) > NUM ) str = str . substring ( NUM , NUM ) ; else if ( str . length ( ) < NUM ) colorstr += STRING + str ; else colorstr += str ; return colorstr ; }
public int value For X Position ( int x Pos ) { int value ; int min Value = slider . get Minimum ( ) ; int max Value = slider . get Maximum ( ) ; int track Left = track Rect . x + thumb Rect . width / NUM + track Border ; int track Right = track Rect . x + track Rect . width - thumb Rect . width / NUM - track Border ; int track Length = track Right - track Left ; if ( x Pos <= track Left ) { value = draw Inverted ( ) ? max Value : min Value ; } else if ( x Pos >= track Right ) { value = draw Inverted ( ) ? min Value : max Value ; } else { int distance From Track Left = x Pos - track Left ; double value Range = ( double ) max Value - ( double ) min Value ; double value Per Pixel = value Range / ( double ) track Length ; int value From Track Left = ( int ) Math . round ( distance From Track Left * value Per Pixel ) ; value = draw Inverted ( ) ? max Value - value From Track Left : min Value + value From Track Left ; } return value ; }
public int value For X Position ( int x Pos ) { int value ; int min Value = slider . get Minimum ( ) ; int max Value = slider . get Maximum ( ) ; int track Left = track Rect . x + thumb Rect . width / NUM + track Border ; int track Right = track Rect . x + track Rect . width - thumb Rect . width / NUM - track Border ; int track Length = track Right - track Left ; if ( x Pos <= track Left ) { value = draw Inverted ( ) ? max Value : min Value ; } else if ( x Pos >= track Right ) { value = draw Inverted ( ) ? min Value : max Value ; } else { int distance From Track Left = x Pos - track Left ; double value Range = ( double ) max Value - ( double ) min Value ; double value Per Pixel = value Range / ( double ) track Length ; int value From Track Left = ( int ) Math . round ( distance From Track Left * value Per Pixel ) ; value = draw Inverted ( ) ? max Value - value From Track Left : min Value + value From Track Left ; } return value ; }
public int value For X Position ( int x Pos ) { int value ; int min Value = slider . get Minimum ( ) ; int max Value = slider . get Maximum ( ) ; int track Left = track Rect . x + thumb Rect . width / NUM + track Border ; int track Right = track Rect . x + track Rect . width - thumb Rect . width / NUM - track Border ; int track Length = track Right - track Left ; if ( x Pos <= track Left ) { value = draw Inverted ( ) ? max Value : min Value ; } else if ( x Pos >= track Right ) { value = draw Inverted ( ) ? min Value : max Value ; } else { int distance From Track Left = x Pos - track Left ; double value Range = ( double ) max Value - ( double ) min Value ; double value Per Pixel = value Range / ( double ) track Length ; int value From Track Left = ( int ) Math . round ( distance From Track Left * value Per Pixel ) ; value = draw Inverted ( ) ? max Value - value From Track Left : min Value + value From Track Left ; } return value ; }
public static C Menu Item add Menu ( Action Listener l , J Popup Menu popup Menu ) { C Menu Item mi = new C Menu Item ( Msg . get Element ( Env . get Ctx ( ) , STRING ) , s icon ) ; mi . set Action Command ( CHANGE LOG COMMAND ) ; mi . add Action Listener ( l ) ; popup Menu . add ( mi ) ; return mi ; }
public static float [ ] close L La ( float [ ] lla ) { int l = lla . length ; int s = ( l / NUM ) - NUM ; if ( lla [ NUM ] == lla [ s * NUM ] && lla [ NUM ] == lla [ s * NUM + NUM ] ) { return lla ; } else { float [ ] llx = new float [ l + NUM ] ; System . arraycopy ( lla , NUM , llx , NUM , l ) ; llx [ l ] = lla [ NUM ] ; llx [ l + NUM ] = lla [ NUM ] ; return llx ; } }
public static float [ ] close L La ( float [ ] lla ) { int l = lla . length ; int s = ( l / NUM ) - NUM ; if ( lla [ NUM ] == lla [ s * NUM ] && lla [ NUM ] == lla [ s * NUM + NUM ] ) { return lla ; } else { float [ ] llx = new float [ l + NUM ] ; System . arraycopy ( lla , NUM , llx , NUM , l ) ; llx [ l ] = lla [ NUM ] ; llx [ l + NUM ] = lla [ NUM ] ; return llx ; } }
public static float [ ] close L La ( float [ ] lla ) { int l = lla . length ; int s = ( l / NUM ) - NUM ; if ( lla [ NUM ] == lla [ s * NUM ] && lla [ NUM ] == lla [ s * NUM + NUM ] ) { return lla ; } else { float [ ] llx = new float [ l + NUM ] ; System . arraycopy ( lla , NUM , llx , NUM , l ) ; llx [ l ] = lla [ NUM ] ; llx [ l + NUM ] = lla [ NUM ] ; return llx ; } }
public static byte [ ] convert CRL To DER ( String pem CRL ) { String base 64 = pem CRL . replace ( CRL BEGIN , STRING ) ; base 64 = base 64 . replace ( CRL END , STRING ) ; base 64 = base 64 . replace All ( STRING , STRING ) ; return Base 64 . decode Base 64 ( base 64 ) ; }
void remove At ( final int remove Index ) { final Object [ ] items = this . items ; if ( remove Index == take Index ) { items [ take Index ] = null ; take Index = inc ( take Index ) ; count -- ; if ( itrs != null ) itrs . element Dequeued ( ) ; } else { final int put Index = this . put Index ; for ( int i = remove Index ; ; ) { int next = inc ( i ) ; if ( next != put Index ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . put Index = i ; break ; } } count -- ; if ( itrs != null ) itrs . removed At ( remove Index ) ; } not Full . signal ( ) ; }
void remove At ( final int remove Index ) { final Object [ ] items = this . items ; if ( remove Index == take Index ) { items [ take Index ] = null ; take Index = inc ( take Index ) ; count -- ; if ( itrs != null ) itrs . element Dequeued ( ) ; } else { final int put Index = this . put Index ; for ( int i = remove Index ; ; ) { int next = inc ( i ) ; if ( next != put Index ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . put Index = i ; break ; } } count -- ; if ( itrs != null ) itrs . removed At ( remove Index ) ; } not Full . signal ( ) ; }
void remove At ( final int remove Index ) { final Object [ ] items = this . items ; if ( remove Index == take Index ) { items [ take Index ] = null ; take Index = inc ( take Index ) ; count -- ; if ( itrs != null ) itrs . element Dequeued ( ) ; } else { final int put Index = this . put Index ; for ( int i = remove Index ; ; ) { int next = inc ( i ) ; if ( next != put Index ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . put Index = i ; break ; } } count -- ; if ( itrs != null ) itrs . removed At ( remove Index ) ; } not Full . signal ( ) ; }
public static boolean can Interact ( User issuer , User target , Guild guild ) { if ( guild . get Owner ( ) == issuer ) return BOOL ; if ( guild . get Owner ( ) == target ) return BOOL ; List < Role > issuer Roles = guild . get Roles For User ( issuer ) ; List < Role > target Roles = guild . get Roles For User ( target ) ; if ( issuer Roles == null ) throw new Illegal Argument Exception ( STRING ) ; if ( target Roles == null ) throw new Illegal Argument Exception ( STRING ) ; return ! issuer Roles . is Empty ( ) && ( target Roles . is Empty ( ) || can Interact ( issuer Roles . get ( NUM ) , target Roles . get ( NUM ) ) ) ; }
public static boolean can Interact ( User issuer , User target , Guild guild ) { if ( guild . get Owner ( ) == issuer ) return BOOL ; if ( guild . get Owner ( ) == target ) return BOOL ; List < Role > issuer Roles = guild . get Roles For User ( issuer ) ; List < Role > target Roles = guild . get Roles For User ( target ) ; if ( issuer Roles == null ) throw new Illegal Argument Exception ( STRING ) ; if ( target Roles == null ) throw new Illegal Argument Exception ( STRING ) ; return ! issuer Roles . is Empty ( ) && ( target Roles . is Empty ( ) || can Interact ( issuer Roles . get ( NUM ) , target Roles . get ( NUM ) ) ) ; }
public static boolean can Interact ( User issuer , User target , Guild guild ) { if ( guild . get Owner ( ) == issuer ) return BOOL ; if ( guild . get Owner ( ) == target ) return BOOL ; List < Role > issuer Roles = guild . get Roles For User ( issuer ) ; List < Role > target Roles = guild . get Roles For User ( target ) ; if ( issuer Roles == null ) throw new Illegal Argument Exception ( STRING ) ; if ( target Roles == null ) throw new Illegal Argument Exception ( STRING ) ; return ! issuer Roles . is Empty ( ) && ( target Roles . is Empty ( ) || can Interact ( issuer Roles . get ( NUM ) , target Roles . get ( NUM ) ) ) ; }
public boolean select ( int position ) { View v = m All List . get ( position ) ; if ( m Multi Choice Adapter != null ) { perform Vibrate ( ) ; perform Select ( v , position , BOOL ) ; return BOOL ; } return BOOL ; }
@ Override public Snmp Mib Handler add Mib ( Snmp Mib Agent mib ) throws Illegal Argument Exception { if ( mib == null ) { throw new Illegal Argument Exception ( ) ; } if ( ! mibs . contains ( mib ) ) mibs . add Element ( mib ) ; root . register ( mib ) ; return this ; }
public void invoke Later ( Runnable r ) { queue . add ( r ) ; synchronized ( this ) { if ( synchronizer == null ) { run Queue ( ) ; } else { synchronizer . activate ( ) ; } } }
public void create Resource Ticket Async ( String tenant Id , Resource Ticket Create Spec resource Ticket Create Spec , final Future Callback < Task > response Callback ) throws IO Exception { String path = String . format ( STRING , get Base Path ( ) , tenant Id ) ; create Object Async ( path , serialize Object As Json ( resource Ticket Create Spec ) , response Callback ) ; }
private void force NS Decls ( ) { Enumeration < String > prefixes = forced Decl Table . keys ( ) ; while ( prefixes . has More Elements ( ) ) { String prefix = prefixes . next Element ( ) ; do Prefix ( prefix , null , BOOL ) ; } }
private void force NS Decls ( ) { Enumeration < String > prefixes = forced Decl Table . keys ( ) ; while ( prefixes . has More Elements ( ) ) { String prefix = prefixes . next Element ( ) ; do Prefix ( prefix , null , BOOL ) ; } }
private void force NS Decls ( ) { Enumeration < String > prefixes = forced Decl Table . keys ( ) ; while ( prefixes . has More Elements ( ) ) { String prefix = prefixes . next Element ( ) ; do Prefix ( prefix , null , BOOL ) ; } }
private void force NS Decls ( ) { Enumeration < String > prefixes = forced Decl Table . keys ( ) ; while ( prefixes . has More Elements ( ) ) { String prefix = prefixes . next Element ( ) ; do Prefix ( prefix , null , BOOL ) ; } }
private void add Reachable ( Node start Node ) { Stack node Stack = new Stack ( ) ; node Stack . add ( start Node ) ; while ( ! node Stack . empty ( ) ) { Node node = ( Node ) node Stack . pop ( ) ; add ( node , node Stack ) ; } }
private void add Reachable ( Node start Node ) { Stack node Stack = new Stack ( ) ; node Stack . add ( start Node ) ; while ( ! node Stack . empty ( ) ) { Node node = ( Node ) node Stack . pop ( ) ; add ( node , node Stack ) ; } }
private void add Reachable ( Node start Node ) { Stack node Stack = new Stack ( ) ; node Stack . add ( start Node ) ; while ( ! node Stack . empty ( ) ) { Node node = ( Node ) node Stack . pop ( ) ; add ( node , node Stack ) ; } }
private void start From Queue ( ) { do { int active 0 = active . get ( ) ; if ( active 0 == max Tasks ) break ; if ( active . compare And Set ( active 0 , active 0 + NUM ) ) { Callable < ? > task = queue . poll ( ) ; if ( task == null ) { int res = active . decrement And Get ( ) ; assert res >= NUM : res ; break ; } start Thread ( task ) ; } } while ( ! queue . is Empty ( ) ) ; }
public static URL Image create To Storage ( Encoded Image placeholder , String storage File , String url , Image Adapter adapter ) { return new URL Image ( placeholder , url . intern ( ) , adapter , storage File . intern ( ) , null ) ; }
private void add Event ( Event Reg reg ) { if ( reg . listener == null ) return ; Entry Rep [ ] tmpls = reg . tmpl . attribute Set Templates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= NUM ; ) { Entry Class eclass = tmpls [ i ] . eclass ; eclass . set Num Templates ( eclass . get Num Templates ( ) + NUM ) ; } } Long id = new Long ( reg . event ID ) ; event By ID . put ( id , reg ) ; event By Time . put ( reg , reg ) ; if ( reg . tmpl . service ID != null ) { Object val = sub Event By Service . get ( reg . tmpl . service ID ) ; if ( val == null ) val = reg ; else if ( val instanceof Event Reg ) val = new Event Reg [ ] { ( Event Reg ) val , reg } ; else val = array Add ( ( Event Reg [ ] ) val , reg ) ; sub Event By Service . put ( reg . tmpl . service ID , val ) ; } else { sub Event By ID . put ( id , reg ) ; } compute Max Leases ( ) ; }
private void add Event ( Event Reg reg ) { if ( reg . listener == null ) return ; Entry Rep [ ] tmpls = reg . tmpl . attribute Set Templates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= NUM ; ) { Entry Class eclass = tmpls [ i ] . eclass ; eclass . set Num Templates ( eclass . get Num Templates ( ) + NUM ) ; } } Long id = new Long ( reg . event ID ) ; event By ID . put ( id , reg ) ; event By Time . put ( reg , reg ) ; if ( reg . tmpl . service ID != null ) { Object val = sub Event By Service . get ( reg . tmpl . service ID ) ; if ( val == null ) val = reg ; else if ( val instanceof Event Reg ) val = new Event Reg [ ] { ( Event Reg ) val , reg } ; else val = array Add ( ( Event Reg [ ] ) val , reg ) ; sub Event By Service . put ( reg . tmpl . service ID , val ) ; } else { sub Event By ID . put ( id , reg ) ; } compute Max Leases ( ) ; }
private void add Event ( Event Reg reg ) { if ( reg . listener == null ) return ; Entry Rep [ ] tmpls = reg . tmpl . attribute Set Templates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= NUM ; ) { Entry Class eclass = tmpls [ i ] . eclass ; eclass . set Num Templates ( eclass . get Num Templates ( ) + NUM ) ; } } Long id = new Long ( reg . event ID ) ; event By ID . put ( id , reg ) ; event By Time . put ( reg , reg ) ; if ( reg . tmpl . service ID != null ) { Object val = sub Event By Service . get ( reg . tmpl . service ID ) ; if ( val == null ) val = reg ; else if ( val instanceof Event Reg ) val = new Event Reg [ ] { ( Event Reg ) val , reg } ; else val = array Add ( ( Event Reg [ ] ) val , reg ) ; sub Event By Service . put ( reg . tmpl . service ID , val ) ; } else { sub Event By ID . put ( id , reg ) ; } compute Max Leases ( ) ; }
private void add Event ( Event Reg reg ) { if ( reg . listener == null ) return ; Entry Rep [ ] tmpls = reg . tmpl . attribute Set Templates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= NUM ; ) { Entry Class eclass = tmpls [ i ] . eclass ; eclass . set Num Templates ( eclass . get Num Templates ( ) + NUM ) ; } } Long id = new Long ( reg . event ID ) ; event By ID . put ( id , reg ) ; event By Time . put ( reg , reg ) ; if ( reg . tmpl . service ID != null ) { Object val = sub Event By Service . get ( reg . tmpl . service ID ) ; if ( val == null ) val = reg ; else if ( val instanceof Event Reg ) val = new Event Reg [ ] { ( Event Reg ) val , reg } ; else val = array Add ( ( Event Reg [ ] ) val , reg ) ; sub Event By Service . put ( reg . tmpl . service ID , val ) ; } else { sub Event By ID . put ( id , reg ) ; } compute Max Leases ( ) ; }
private void add Event ( Event Reg reg ) { if ( reg . listener == null ) return ; Entry Rep [ ] tmpls = reg . tmpl . attribute Set Templates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= NUM ; ) { Entry Class eclass = tmpls [ i ] . eclass ; eclass . set Num Templates ( eclass . get Num Templates ( ) + NUM ) ; } } Long id = new Long ( reg . event ID ) ; event By ID . put ( id , reg ) ; event By Time . put ( reg , reg ) ; if ( reg . tmpl . service ID != null ) { Object val = sub Event By Service . get ( reg . tmpl . service ID ) ; if ( val == null ) val = reg ; else if ( val instanceof Event Reg ) val = new Event Reg [ ] { ( Event Reg ) val , reg } ; else val = array Add ( ( Event Reg [ ] ) val , reg ) ; sub Event By Service . put ( reg . tmpl . service ID , val ) ; } else { sub Event By ID . put ( id , reg ) ; } compute Max Leases ( ) ; }
private void add Event ( Event Reg reg ) { if ( reg . listener == null ) return ; Entry Rep [ ] tmpls = reg . tmpl . attribute Set Templates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= NUM ; ) { Entry Class eclass = tmpls [ i ] . eclass ; eclass . set Num Templates ( eclass . get Num Templates ( ) + NUM ) ; } } Long id = new Long ( reg . event ID ) ; event By ID . put ( id , reg ) ; event By Time . put ( reg , reg ) ; if ( reg . tmpl . service ID != null ) { Object val = sub Event By Service . get ( reg . tmpl . service ID ) ; if ( val == null ) val = reg ; else if ( val instanceof Event Reg ) val = new Event Reg [ ] { ( Event Reg ) val , reg } ; else val = array Add ( ( Event Reg [ ] ) val , reg ) ; sub Event By Service . put ( reg . tmpl . service ID , val ) ; } else { sub Event By ID . put ( id , reg ) ; } compute Max Leases ( ) ; }
private void add Event ( Event Reg reg ) { if ( reg . listener == null ) return ; Entry Rep [ ] tmpls = reg . tmpl . attribute Set Templates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= NUM ; ) { Entry Class eclass = tmpls [ i ] . eclass ; eclass . set Num Templates ( eclass . get Num Templates ( ) + NUM ) ; } } Long id = new Long ( reg . event ID ) ; event By ID . put ( id , reg ) ; event By Time . put ( reg , reg ) ; if ( reg . tmpl . service ID != null ) { Object val = sub Event By Service . get ( reg . tmpl . service ID ) ; if ( val == null ) val = reg ; else if ( val instanceof Event Reg ) val = new Event Reg [ ] { ( Event Reg ) val , reg } ; else val = array Add ( ( Event Reg [ ] ) val , reg ) ; sub Event By Service . put ( reg . tmpl . service ID , val ) ; } else { sub Event By ID . put ( id , reg ) ; } compute Max Leases ( ) ; }
public D Subject Information Access ( J Dialog parent ) { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; }
public void initialize ( ) throws Execution Exception { }
public void initialize ( ) throws Execution Exception { }
protected boolean allow Back To ( String form Name ) { return BOOL ; }
protected boolean allow Back To ( String form Name ) { return BOOL ; }
private void start Intermediate Merging ( File [ ] intermediate Files ) { File file = new File ( this . temp File Location + File . separator + this . table Name + System . nano Time ( ) + Carbon Common Constants . MERGERD EXTENSION ) ; File Merger Parameters parameters = new File Merger Parameters ( ) ; parameters . set Is No Dictionary Dimension Column ( no Dictionary Dimnesion Column ) ; parameters . set Dim Col Count ( dim Col Count ) ; parameters . set Complex Dim Col Count ( complex Dim Col Count ) ; parameters . set Measure Col Count ( measure Col Count ) ; parameters . set Intermediate Files ( intermediate Files ) ; parameters . set File Read Buffer Size ( file Buffer Size ) ; parameters . set File Write Buffer Size ( file Buffer Size ) ; parameters . set Out File ( file ) ; parameters . set Compression Enabled ( is Sort File Compression Enabled ) ; parameters . set No Of Records In Compression ( sort Temp File No OF Records In Compression ) ; parameters . set Prefetch ( prefetch ) ; parameters . set Prefetch Buffer Size ( buffer Size ) ; parameters . set Agg Type ( agg Type ) ; parameters . set No Dictionary Count ( no Dictionary Count ) ; Intermediate File Merger merger = new Intermediate File Merger ( parameters ) ; executor Service . submit ( merger ) ; }
private void start Intermediate Merging ( File [ ] intermediate Files ) { File file = new File ( this . temp File Location + File . separator + this . table Name + System . nano Time ( ) + Carbon Common Constants . MERGERD EXTENSION ) ; File Merger Parameters parameters = new File Merger Parameters ( ) ; parameters . set Is No Dictionary Dimension Column ( no Dictionary Dimnesion Column ) ; parameters . set Dim Col Count ( dim Col Count ) ; parameters . set Complex Dim Col Count ( complex Dim Col Count ) ; parameters . set Measure Col Count ( measure Col Count ) ; parameters . set Intermediate Files ( intermediate Files ) ; parameters . set File Read Buffer Size ( file Buffer Size ) ; parameters . set File Write Buffer Size ( file Buffer Size ) ; parameters . set Out File ( file ) ; parameters . set Compression Enabled ( is Sort File Compression Enabled ) ; parameters . set No Of Records In Compression ( sort Temp File No OF Records In Compression ) ; parameters . set Prefetch ( prefetch ) ; parameters . set Prefetch Buffer Size ( buffer Size ) ; parameters . set Agg Type ( agg Type ) ; parameters . set No Dictionary Count ( no Dictionary Count ) ; Intermediate File Merger merger = new Intermediate File Merger ( parameters ) ; executor Service . submit ( merger ) ; }
public FS Font resolve Font ( Shared Context ctx , String [ ] families , float size , Ident Value weight , Ident Value style , Ident Value variant ) { List < Font > fonts = new Array List < Font > ( NUM ) ; if ( families != null ) { for ( int i = NUM ; i < families . length ; i ++ ) { Font font = resolve Font ( ctx , families [ i ] , size , weight , style , variant ) ; if ( font != null ) { fonts . add ( font ) ; } } } String family = STRING ; if ( style == Ident Value . ITALIC ) { family = STRING ; } Font fnt = create Font ( ctx , available Fonts Hash . get ( family ) , size , weight , style , variant ) ; instance Hash . put ( get Font Instance Hash Name ( ctx , family , size , weight , style , variant ) , fnt ) ; fonts . add ( fnt ) ; return new AWTFS Font ( fonts , size ) ; }
@ Override public void handle Mouse Moved ( Chart Canvas canvas , Mouse Event e ) { if ( ! canvas . is Tooltip Enabled ( ) ) { return ; } String text = get Tooltip Text ( canvas , e . get X ( ) , e . get Y ( ) ) ; canvas . set Tooltip ( text , e . get Screen X ( ) , e . get Screen Y ( ) ) ; }
public void run ( ) { while ( m keyboard Stream != null ) { try { if ( m keyboard Read Request ) { String s = m keyboard Stream . read Line ( ) ; m keyboard Input . add ( s ) ; m keyboard Read Request = BOOL ; synchronized ( this ) { notify All ( ) ; } } else try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception ie ) { } } catch ( IO Exception io ) { } } }
public void run ( ) { while ( m keyboard Stream != null ) { try { if ( m keyboard Read Request ) { String s = m keyboard Stream . read Line ( ) ; m keyboard Input . add ( s ) ; m keyboard Read Request = BOOL ; synchronized ( this ) { notify All ( ) ; } } else try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception ie ) { } } catch ( IO Exception io ) { } } }
public void run ( ) { while ( m keyboard Stream != null ) { try { if ( m keyboard Read Request ) { String s = m keyboard Stream . read Line ( ) ; m keyboard Input . add ( s ) ; m keyboard Read Request = BOOL ; synchronized ( this ) { notify All ( ) ; } } else try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception ie ) { } } catch ( IO Exception io ) { } } }
public void run ( ) { while ( m keyboard Stream != null ) { try { if ( m keyboard Read Request ) { String s = m keyboard Stream . read Line ( ) ; m keyboard Input . add ( s ) ; m keyboard Read Request = BOOL ; synchronized ( this ) { notify All ( ) ; } } else try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception ie ) { } } catch ( IO Exception io ) { } } }
public void run ( ) { while ( m keyboard Stream != null ) { try { if ( m keyboard Read Request ) { String s = m keyboard Stream . read Line ( ) ; m keyboard Input . add ( s ) ; m keyboard Read Request = BOOL ; synchronized ( this ) { notify All ( ) ; } } else try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception ie ) { } } catch ( IO Exception io ) { } } }
public void run ( ) { while ( m keyboard Stream != null ) { try { if ( m keyboard Read Request ) { String s = m keyboard Stream . read Line ( ) ; m keyboard Input . add ( s ) ; m keyboard Read Request = BOOL ; synchronized ( this ) { notify All ( ) ; } } else try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception ie ) { } } catch ( IO Exception io ) { } } }
public void run ( ) { while ( m keyboard Stream != null ) { try { if ( m keyboard Read Request ) { String s = m keyboard Stream . read Line ( ) ; m keyboard Input . add ( s ) ; m keyboard Read Request = BOOL ; synchronized ( this ) { notify All ( ) ; } } else try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception ie ) { } } catch ( IO Exception io ) { } } }
public void run ( ) { while ( m keyboard Stream != null ) { try { if ( m keyboard Read Request ) { String s = m keyboard Stream . read Line ( ) ; m keyboard Input . add ( s ) ; m keyboard Read Request = BOOL ; synchronized ( this ) { notify All ( ) ; } } else try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception ie ) { } } catch ( IO Exception io ) { } } }
public void test get Put Byte Array With Offset And Length ( ) { final int capacity = NUM ; final Byte Array Buffer buf = new Byte Array Buffer ( capacity ) ; assert Equals ( ( byte ) NUM , buf . get Byte ( NUM ) ) ; assert Equals ( ( byte ) NUM , buf . get Byte ( capacity - NUM ) ) ; final int pos = NUM ; for ( int i = NUM ; i < LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( capacity - NUM ) ] ; final int off = ( expected . length / NUM == NUM ? NUM : r . next Int ( expected . length / NUM ) ) ; final int len = ( expected . length == NUM ? NUM : r . next Int ( expected . length - off ) ) ; r . next Bytes ( expected ) ; buf . put ( pos , expected , off , len ) ; assert Equals ( NUM , Bytes Util . compare Bytes With Len And Offset ( off , len , expected , pos , len , buf . array ( ) ) ) ; final int dstoff = r . next Int ( NUM ) ; final byte [ ] actual = new byte [ expected . length + dstoff ] ; buf . get ( pos , actual , dstoff , expected . length ) ; assert Equals ( NUM , Bytes Util . compare Bytes With Len And Offset ( off , len , expected , dstoff , len , actual ) ) ; } assert Equals ( ( byte ) NUM , buf . get Byte ( NUM ) ) ; assert Equals ( ( byte ) NUM , buf . get Byte ( pos + capacity - NUM ) ) ; }
public String preview Next Token ( ) { matcher . find ( ) ; String next One = matcher . group ( ) ; update Matcher ( ) ; return next One ; }
public static void create Top Level Classes XML ( String output Dir , String templates Path , boolean lenient ) throws Compiler Exception { try { As Doc Helper as Doc Help = new As Doc Helper ( output Dir + STRING , output Dir + STRING , output Dir , output Dir + STRING + File . separator + STRING ) ; as Doc Help . create Top Level Classes ( lenient ) ; } catch ( Throwable t ) { t . print Stack Trace ( ) ; Compiler Message c = new Could Not Create ( STRING , t . get Message ( ) ) ; Thread Local Toolkit . log ( c ) ; throw c ; } }
public static void create Top Level Classes XML ( String output Dir , String templates Path , boolean lenient ) throws Compiler Exception { try { As Doc Helper as Doc Help = new As Doc Helper ( output Dir + STRING , output Dir + STRING , output Dir , output Dir + STRING + File . separator + STRING ) ; as Doc Help . create Top Level Classes ( lenient ) ; } catch ( Throwable t ) { t . print Stack Trace ( ) ; Compiler Message c = new Could Not Create ( STRING , t . get Message ( ) ) ; Thread Local Toolkit . log ( c ) ; throw c ; } }
public Obligation Policy Database Entry add Parameter Deletes Obligation Database Entry ( X Method xmethod , Obligation obligation , Obligation Policy Database Entry Type entry Type ) { Obligation Policy Database Entry entry = new Match Method Entry ( xmethod , Obligation Policy Database Action Type . DEL , entry Type , obligation ) ; add Entry ( entry ) ; return entry ; }
private static native int bgexec Internal ( String [ ] cmdarray , String workdir , String logfile , boolean inherit Logfile ) throws IO Exception ;
private static native int bgexec Internal ( String [ ] cmdarray , String workdir , String logfile , boolean inherit Logfile ) throws IO Exception ;
private static native int bgexec Internal ( String [ ] cmdarray , String workdir , String logfile , boolean inherit Logfile ) throws IO Exception ;
private void add Mnemonic ( int index , int mnemonic ) { if ( mnemonic To Index Map == null ) { init Mnemonics ( ) ; } mnemonic Input Map . put ( Key Stroke . get Key Stroke ( mnemonic , Basic Look And Feel . get Focus Accelerator Key Mask ( ) ) , STRING ) ; mnemonic To Index Map . put ( Integer . value Of ( mnemonic ) , Integer . value Of ( index ) ) ; }
public static Stream Ex < String > split ( Char Sequence str , char delimiter , boolean trim Empty ) { if ( str . length ( ) == NUM ) return of ( STRING ) ; return of ( new Char Spliterator ( str , delimiter , trim Empty ) ) ; }
public static Stream Ex < String > split ( Char Sequence str , char delimiter , boolean trim Empty ) { if ( str . length ( ) == NUM ) return of ( STRING ) ; return of ( new Char Spliterator ( str , delimiter , trim Empty ) ) ; }
public static Stream Ex < String > split ( Char Sequence str , char delimiter , boolean trim Empty ) { if ( str . length ( ) == NUM ) return of ( STRING ) ; return of ( new Char Spliterator ( str , delimiter , trim Empty ) ) ; }
public static Stream Ex < String > split ( Char Sequence str , char delimiter , boolean trim Empty ) { if ( str . length ( ) == NUM ) return of ( STRING ) ; return of ( new Char Spliterator ( str , delimiter , trim Empty ) ) ; }
public static Stream Ex < String > split ( Char Sequence str , char delimiter , boolean trim Empty ) { if ( str . length ( ) == NUM ) return of ( STRING ) ; return of ( new Char Spliterator ( str , delimiter , trim Empty ) ) ; }
public static Stream Ex < String > split ( Char Sequence str , char delimiter , boolean trim Empty ) { if ( str . length ( ) == NUM ) return of ( STRING ) ; return of ( new Char Spliterator ( str , delimiter , trim Empty ) ) ; }
public static Stream Ex < String > split ( Char Sequence str , char delimiter , boolean trim Empty ) { if ( str . length ( ) == NUM ) return of ( STRING ) ; return of ( new Char Spliterator ( str , delimiter , trim Empty ) ) ; }
public static Stream Ex < String > split ( Char Sequence str , char delimiter , boolean trim Empty ) { if ( str . length ( ) == NUM ) return of ( STRING ) ; return of ( new Char Spliterator ( str , delimiter , trim Empty ) ) ; }
public static Stream Ex < String > split ( Char Sequence str , char delimiter , boolean trim Empty ) { if ( str . length ( ) == NUM ) return of ( STRING ) ; return of ( new Char Spliterator ( str , delimiter , trim Empty ) ) ; }
public static Stream Ex < String > split ( Char Sequence str , char delimiter , boolean trim Empty ) { if ( str . length ( ) == NUM ) return of ( STRING ) ; return of ( new Char Spliterator ( str , delimiter , trim Empty ) ) ; }
public static Stream Ex < String > split ( Char Sequence str , char delimiter , boolean trim Empty ) { if ( str . length ( ) == NUM ) return of ( STRING ) ; return of ( new Char Spliterator ( str , delimiter , trim Empty ) ) ; }
public static Stream Ex < String > split ( Char Sequence str , char delimiter , boolean trim Empty ) { if ( str . length ( ) == NUM ) return of ( STRING ) ; return of ( new Char Spliterator ( str , delimiter , trim Empty ) ) ; }
@ Override protected boolean check Entry Not Valid ( Region Entry map Entry ) { return ( super . check Entry Not Valid ( map Entry ) || map Entry . get Key ( ) instanceof Thread Identifier ) ; }
@ Override protected boolean check Entry Not Valid ( Region Entry map Entry ) { return ( super . check Entry Not Valid ( map Entry ) || map Entry . get Key ( ) instanceof Thread Identifier ) ; }
@ Override protected boolean check Entry Not Valid ( Region Entry map Entry ) { return ( super . check Entry Not Valid ( map Entry ) || map Entry . get Key ( ) instanceof Thread Identifier ) ; }
protected int read Ascii Byte ( ) throws IO Exception { if ( comm Port != null && comm Port . is Open ( ) ) { byte [ ] buffer = new byte [ NUM ] ; int cnt = comm Port . read Bytes ( buffer , NUM ) ; if ( cnt != NUM ) { throw new IO Exception ( STRING ) ; } else if ( buffer [ NUM ] == STRING ) { return Modbus ASCII Transport . FRAME START ; } else if ( buffer [ NUM ] == STRING || buffer [ NUM ] == STRING ) { return Modbus ASCII Transport . FRAME END ; } else { logger . debug ( STRING + buffer [ NUM ] + STRING + String . format ( STRING , buffer [ NUM ] ) + STRING ) ; byte first Value = buffer [ NUM ] ; cnt = comm Port . read Bytes ( buffer , NUM ) ; if ( cnt != NUM ) { throw new IO Exception ( STRING ) ; } else { logger . debug ( STRING + buffer [ NUM ] + STRING + String . format ( STRING , buffer [ NUM ] ) + STRING ) ; int combined Value = ( Character . digit ( first Value , NUM ) << NUM ) + Character . digit ( buffer [ NUM ] , NUM ) ; logger . debug ( STRING + String . format ( STRING , combined Value ) ) ; return combined Value ; } } } else { throw new IO Exception ( STRING ) ; } }
public boolean remove Web App Debug Model Listener ( I Web App Debug Model Listener listener ) { synchronized ( private Instance Lock ) { return web App Debug Model Listeners . remove ( listener ) ; } }
public boolean remove Web App Debug Model Listener ( I Web App Debug Model Listener listener ) { synchronized ( private Instance Lock ) { return web App Debug Model Listeners . remove ( listener ) ; } }
public boolean remove Web App Debug Model Listener ( I Web App Debug Model Listener listener ) { synchronized ( private Instance Lock ) { return web App Debug Model Listeners . remove ( listener ) ; } }
public boolean remove Web App Debug Model Listener ( I Web App Debug Model Listener listener ) { synchronized ( private Instance Lock ) { return web App Debug Model Listeners . remove ( listener ) ; } }
public static String write Input Stream To String ( Input Stream is ) { Byte Array Output Stream result = new Byte Array Output Stream ( ) ; byte [ ] buffer = new byte [ NUM ] ; int length ; try { while ( ( length = is . read ( buffer ) ) != - NUM ) { result . write ( buffer , NUM , length ) ; } return result . to String ( STRING ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public static String write Input Stream To String ( Input Stream is ) { Byte Array Output Stream result = new Byte Array Output Stream ( ) ; byte [ ] buffer = new byte [ NUM ] ; int length ; try { while ( ( length = is . read ( buffer ) ) != - NUM ) { result . write ( buffer , NUM , length ) ; } return result . to String ( STRING ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public void add Index ( I Index index ) { if ( index != null ) { indices . add ( index ) ; } }
private void collect Items ( List < Node > result , List < Node > nodes ) { if ( nodes != null ) { for ( Node node : nodes ) { result . add ( node ) ; collect Items ( result , node . get Sub Nodes ( ) ) ; } } }
public synchronized void track Hex Images ( I Hex hex , Media Tracker tracker ) { Image base = hex To Image Cache . get ( hex ) ; List < Image > super Imgs = hex To Image List Cache . get ( hex ) ; List < Image > ortho Imgs = ortho List Cache . get ( hex ) ; tracker . add Image ( base , NUM ) ; if ( super Imgs != null ) { for ( Iterator < Image > i = super Imgs . iterator ( ) ; i . has Next ( ) ; ) { tracker . add Image ( i . next ( ) , NUM ) ; } } if ( ortho Imgs != null ) { for ( Iterator < Image > i = ortho Imgs . iterator ( ) ; i . has Next ( ) ; ) { tracker . add Image ( i . next ( ) , NUM ) ; } } }
public boolean contains ( String value ) { return m values . contains ( value ) ; }
public boolean contains ( String value ) { return m values . contains ( value ) ; }
public boolean is Expanded ( int row ) { Tree UI tree = get UI ( ) ; if ( tree != null ) { Tree Path path = tree . get Path For Row ( this , row ) ; if ( path != null ) { Boolean value = expanded State . get ( path ) ; return ( value != null && value . boolean Value ( ) ) ; } } return BOOL ; }
public void remove Listener ( T listener ) { if ( listeners != null ) { List < T > newlisteners = new Array List < T > ( ) ; newlisteners . add All ( listeners ) ; newlisteners . remove ( listener ) ; listeners = newlisteners ; } }
public P Norm Normalization ( double p ) { if ( p <= NUM || Double . is Na N ( p ) ) throw new Illegal Argument Exception ( STRING + p ) ; this . p = p ; }
public static URL to URL ( URI uri ) throws Malformed URL Exception { if ( ! uri . is Absolute ( ) ) throw new Mock Illegal Argument Exception ( STRING ) ; return Mock URL . URL ( uri . to String ( ) ) ; }
public void delete Assignable Dynamic Groups ( Set group D Ns ) throws AM Exception , SSO Exception { Iterator iter = group D Ns . iterator ( ) ; while ( iter . has Next ( ) ) { String group DN = ( String ) iter . next ( ) ; AM Assignable Dynamic Group group = new AM Assignable Dynamic Group Impl ( token , group DN ) ; group . delete ( ) ; } }
public void delete Assignable Dynamic Groups ( Set group D Ns ) throws AM Exception , SSO Exception { Iterator iter = group D Ns . iterator ( ) ; while ( iter . has Next ( ) ) { String group DN = ( String ) iter . next ( ) ; AM Assignable Dynamic Group group = new AM Assignable Dynamic Group Impl ( token , group DN ) ; group . delete ( ) ; } }
private void check Boundary Fields ( ) { max Range Field . set Enabled ( ! model . is Auto Range ( ) ) ; min Range Field . set Enabled ( ! model . is Auto Range ( ) ) ; max Domain Field . set Enabled ( ! model . is Auto Domain ( ) ) ; min Domain Field . set Enabled ( ! model . is Auto Domain ( ) ) ; }
static void remove Redundant Affix ( Translator Utils . I Contain i Contain , List < String > str List ) { if ( str List . size ( ) <= NUM ) { return ; } int w = NUM ; for ( String str : str List ) { if ( w == NUM || ! i Contain . contain Func ( str , str List . get ( w - NUM ) ) ) { str List . set ( w , str ) ; w ++ ; } } str List = str List . sub List ( NUM , w ) ; }
static void remove Redundant Affix ( Translator Utils . I Contain i Contain , List < String > str List ) { if ( str List . size ( ) <= NUM ) { return ; } int w = NUM ; for ( String str : str List ) { if ( w == NUM || ! i Contain . contain Func ( str , str List . get ( w - NUM ) ) ) { str List . set ( w , str ) ; w ++ ; } } str List = str List . sub List ( NUM , w ) ; }
static void remove Redundant Affix ( Translator Utils . I Contain i Contain , List < String > str List ) { if ( str List . size ( ) <= NUM ) { return ; } int w = NUM ; for ( String str : str List ) { if ( w == NUM || ! i Contain . contain Func ( str , str List . get ( w - NUM ) ) ) { str List . set ( w , str ) ; w ++ ; } } str List = str List . sub List ( NUM , w ) ; }
public static boolean equals ( final Object [ ] a , final Object [ ] b ) { if ( a == b ) { return BOOL ; } else if ( a . length != b . length ) { return BOOL ; } for ( int i = NUM ; i < a . length ; i ++ ) { final Object x = a [ i ] ; final Object y = b [ i ] ; if ( x == null ) { if ( y != null ) { return BOOL ; } } else { if ( ! x . equals ( y ) ) { return BOOL ; } } } return BOOL ; }
private void make Tree ( int nstep ) { for ( Enumeration < Body > e = bodies Rev ( ) ; e . has More Elements ( ) ; ) { Body q = e . next Element ( ) ; if ( q . mass != NUM ) { q . expand Box ( this , nstep ) ; Math Vector xqic = intcoord ( q . pos ) ; if ( root == null ) { root = q ; } else { root = root . load Tree ( q , xqic , Node . IMAX > > NUM , this ) ; } } } root . hackcofm ( ) ; }
public Percent add ( Percent Percent ) { assert Defined ( ) ; if ( null == m value ) { if ( null == Percent . get Big Decimal Value ( ) ) { return new Percent ( ) ; } else { return new Percent ( Percent . get Big Decimal Value ( ) ) ; } } Big Decimal value = m value . add ( Percent . get Big Decimal Value ( ) ) ; return new Percent ( value ) ; }
protected static void quick Sort ( Instances insts , int [ ] indices , int attidx , int left , int right ) { if ( left < right ) { int middle = partition ( insts , indices , attidx , left , right ) ; quick Sort ( insts , indices , attidx , left , middle ) ; quick Sort ( insts , indices , attidx , middle + NUM , right ) ; } }
protected static void quick Sort ( Instances insts , int [ ] indices , int attidx , int left , int right ) { if ( left < right ) { int middle = partition ( insts , indices , attidx , left , right ) ; quick Sort ( insts , indices , attidx , left , middle ) ; quick Sort ( insts , indices , attidx , middle + NUM , right ) ; } }
protected static void quick Sort ( Instances insts , int [ ] indices , int attidx , int left , int right ) { if ( left < right ) { int middle = partition ( insts , indices , attidx , left , right ) ; quick Sort ( insts , indices , attidx , left , middle ) ; quick Sort ( insts , indices , attidx , middle + NUM , right ) ; } }
private static String list To String ( List < Integer > list ) { Collections . sort ( list ) ; String Builder builder = new String Builder ( ) ; for ( int i = NUM ; i < list . size ( ) ; i ++ ) { Integer column = list . get ( i ) + NUM ; if ( i < list . size ( ) - NUM ) { builder . append ( column ) ; builder . append ( STRING ) ; } else if ( i == list . size ( ) - NUM ) { builder . append ( column ) ; builder . append ( AND ) ; } else { builder . append ( column ) ; } } return builder . to String ( ) ; }
private static String list To String ( List < Integer > list ) { Collections . sort ( list ) ; String Builder builder = new String Builder ( ) ; for ( int i = NUM ; i < list . size ( ) ; i ++ ) { Integer column = list . get ( i ) + NUM ; if ( i < list . size ( ) - NUM ) { builder . append ( column ) ; builder . append ( STRING ) ; } else if ( i == list . size ( ) - NUM ) { builder . append ( column ) ; builder . append ( AND ) ; } else { builder . append ( column ) ; } } return builder . to String ( ) ; }
@ Override @ Pure public int hash Code ( ) { int hc = hash Code Value ; if ( hc == NUM ) { hc = base Locale . hash Code ( ) ; if ( locale Extensions != null ) { hc ^= locale Extensions . hash Code ( ) ; } hash Code Value = hc ; } return hc ; }
@ Override @ Pure public int hash Code ( ) { int hc = hash Code Value ; if ( hc == NUM ) { hc = base Locale . hash Code ( ) ; if ( locale Extensions != null ) { hc ^= locale Extensions . hash Code ( ) ; } hash Code Value = hc ; } return hc ; }
@ Override @ Pure public int hash Code ( ) { int hc = hash Code Value ; if ( hc == NUM ) { hc = base Locale . hash Code ( ) ; if ( locale Extensions != null ) { hc ^= locale Extensions . hash Code ( ) ; } hash Code Value = hc ; } return hc ; }
public Matrix ( final double [ ] [ ] data , final Set < Address . Flags > flags ) { super ( data . length , data [ NUM ] . length , null ) ; this . addr = new Direct Matrix Address ( this . $ , NUM , data . length , null , NUM , data [ NUM ] . length , flags , BOOL , data . length , data [ NUM ] . length ) ; for ( int row = NUM ; row < data . length ; row ++ ) { System . arraycopy ( data [ row ] , NUM , this . $ , row * this . cols , this . cols ) ; } }
@ Override public void write External ( Object Output out ) throws IO Exception { super . write External ( out ) ; out . write Int ( entries . length ) ; for ( Entry entry : entries ) { if ( entry == null ) { break ; } entry . write External ( out ) ; } }
@ Override public void write External ( Object Output out ) throws IO Exception { super . write External ( out ) ; out . write Int ( entries . length ) ; for ( Entry entry : entries ) { if ( entry == null ) { break ; } entry . write External ( out ) ; } }
private void assert Zip And Unzip Of Directory Matches Original ( File source Dir ) throws IO Exception { File [ ] source Files = source Dir . list Files ( ) ; Arrays . sort ( source Files ) ; File zip File = create Zip File Handle ( ) ; Zip Files . zip Directory ( source Dir , zip File ) ; File output Dir = Files . create Temp Dir ( ) ; Zip Files . unzip File ( zip File , output Dir ) ; File [ ] output Files = output Dir . list Files ( ) ; Arrays . sort ( output Files ) ; assert That ( output Files , array With Size ( source Files . length ) ) ; for ( int i = NUM ; i < source Files . length ; i ++ ) { compare File Contents ( source Files [ i ] , output Files [ i ] ) ; } remove Recursive ( output Dir . to Path ( ) ) ; assert True ( zip File . delete ( ) ) ; }
public Calendar Query ( URL feed Url ) { super ( feed Url ) ; }
public Calendar Query ( URL feed Url ) { super ( feed Url ) ; }
public Calendar Query ( URL feed Url ) { super ( feed Url ) ; }
public Calendar Query ( URL feed Url ) { super ( feed Url ) ; }
private float calculate Translation Height After Field Rot ( Rectangle b Box , double page Rotation , double rel Field Rotation ) { if ( rel Field Rotation == NUM ) { return NUM ; } if ( page Rotation == NUM ) { if ( rel Field Rotation == Math . PI / NUM ) { return b Box . get Height ( ) ; } if ( rel Field Rotation == Math . PI ) { return b Box . get Height ( ) ; } } if ( page Rotation == - Math . PI / NUM ) { if ( rel Field Rotation == - Math . PI / NUM ) { return b Box . get Width ( ) - b Box . get Height ( ) ; } if ( rel Field Rotation == Math . PI / NUM ) { return b Box . get Height ( ) ; } if ( rel Field Rotation == Math . PI ) { return b Box . get Width ( ) ; } } if ( page Rotation == - Math . PI ) { if ( rel Field Rotation == - NUM * Math . PI ) { return b Box . get Height ( ) ; } if ( rel Field Rotation == - NUM * Math . PI / NUM ) { return b Box . get Height ( ) - b Box . get Width ( ) ; } if ( rel Field Rotation == Math . PI / NUM ) { return b Box . get Width ( ) ; } } if ( page Rotation == - NUM * Math . PI / NUM ) { if ( rel Field Rotation == - NUM * Math . PI / NUM ) { return b Box . get Width ( ) ; } if ( rel Field Rotation == - Math . PI ) { return b Box . get Width ( ) ; } } return NUM ; }
private float calculate Translation Height After Field Rot ( Rectangle b Box , double page Rotation , double rel Field Rotation ) { if ( rel Field Rotation == NUM ) { return NUM ; } if ( page Rotation == NUM ) { if ( rel Field Rotation == Math . PI / NUM ) { return b Box . get Height ( ) ; } if ( rel Field Rotation == Math . PI ) { return b Box . get Height ( ) ; } } if ( page Rotation == - Math . PI / NUM ) { if ( rel Field Rotation == - Math . PI / NUM ) { return b Box . get Width ( ) - b Box . get Height ( ) ; } if ( rel Field Rotation == Math . PI / NUM ) { return b Box . get Height ( ) ; } if ( rel Field Rotation == Math . PI ) { return b Box . get Width ( ) ; } } if ( page Rotation == - Math . PI ) { if ( rel Field Rotation == - NUM * Math . PI ) { return b Box . get Height ( ) ; } if ( rel Field Rotation == - NUM * Math . PI / NUM ) { return b Box . get Height ( ) - b Box . get Width ( ) ; } if ( rel Field Rotation == Math . PI / NUM ) { return b Box . get Width ( ) ; } } if ( page Rotation == - NUM * Math . PI / NUM ) { if ( rel Field Rotation == - NUM * Math . PI / NUM ) { return b Box . get Width ( ) ; } if ( rel Field Rotation == - Math . PI ) { return b Box . get Width ( ) ; } } return NUM ; }
void purge Last Articles ( int amount To Purge ) { if ( ! is DB Available ( ) ) return ; long time = System . current Time Millis ( ) ; String query = STRING + TABLE ARTICLES + STRING + ( Utils . ARTICLE LIMIT - amount To Purge + STRING ) ; safely Delete Articles ( query , null ) ; Log . d ( TAG , STRING + ( System . current Time Millis ( ) - time ) + STRING ) ; }
protected void add To Port Map ( IOF Switch sw , Mac Address mac , Vlan Vid vlan , OF Port port Val ) { Map < Mac Vlan Pair , OF Port > sw Map = mac Vlan To Switch Port Map . get ( sw ) ; if ( vlan == Vlan Vid . FULL MASK || vlan == null ) { vlan = Vlan Vid . of Vlan ( NUM ) ; } if ( sw Map == null ) { sw Map = Collections . synchronized Map ( new LRU Linked Hash Map < Mac Vlan Pair , OF Port > ( MAX MACS PER SWITCH ) ) ; mac Vlan To Switch Port Map . put ( sw , sw Map ) ; } sw Map . put ( new Mac Vlan Pair ( mac , vlan ) , port Val ) ; }
public void test single Resource Locking serialized low Concurrency 5 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . set Property ( Test Options . NTHREADS , STRING ) ; properties . set Property ( Test Options . NTASKS , STRING ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; do Comparison Test ( properties ) ; }
public void test single Resource Locking serialized low Concurrency 5 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . set Property ( Test Options . NTHREADS , STRING ) ; properties . set Property ( Test Options . NTASKS , STRING ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; do Comparison Test ( properties ) ; }
public void test single Resource Locking serialized low Concurrency 5 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . set Property ( Test Options . NTHREADS , STRING ) ; properties . set Property ( Test Options . NTASKS , STRING ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; do Comparison Test ( properties ) ; }
public void test single Resource Locking serialized low Concurrency 5 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . set Property ( Test Options . NTHREADS , STRING ) ; properties . set Property ( Test Options . NTASKS , STRING ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; do Comparison Test ( properties ) ; }
private Refactoring Status check Can Create Intermediary Method ( ) throws Java Model Exception { List < I Type Binding > parameter Bindings = new Array List < I Type Binding > ( ) ; if ( ! is Static Target ( ) ) parameter Bindings . add ( f Intermediary First Parameter Type ) ; parameter Bindings . add All ( Arrays . as List ( f Target Method Binding . get Parameter Types ( ) ) ) ; return Checks . check Method In Type ( f Intermediary Type Binding , f Intermediary Method Name , parameter Bindings . to Array ( new I Type Binding [ parameter Bindings . size ( ) ] ) ) ; }
@ Override public Data Source create Data Source ( Properties properties ) throws SQL Exception { Properties properties Copy = new Properties ( ) ; if ( properties != null ) { properties Copy . put All ( properties ) ; } reject Unsupported Options ( properties Copy ) ; reject Pooling Options ( properties Copy ) ; Jdbc Data Source data Source = new Jdbc Data Source ( ) ; setup H 2 Data Source ( data Source , properties Copy ) ; return data Source ; }
public static Http Response execute Get Request ( String service End Point , boolean secure ) throws IO Exception { URL url = ( secure ) ? new URL ( SERVICE ROOT URI + STRING + service End Point ) : new URL ( SERVICE ROOT URI + service End Point ) ; Http URL Connection connection = ( Http URL Connection ) url . open Connection ( ) ; if ( secure ) { connection . set Request Property ( STRING , AUTHORIZATION ) ; } try { return new Http Response ( connection ) ; } finally { connection . disconnect ( ) ; } }
public boolean contains ( long prefix hash ) { if ( prefix hash == NUM ) { return BOOL ; } int idx = - NUM * Arrays . binary Search ( hashes idx , prefix hash ) - NUM ; if ( idx == cache size ) { return BOOL ; } else { return ( hashes idx [ idx ] & PREFIX HASH MASK ) == prefix hash ; } }
public boolean contains ( long prefix hash ) { if ( prefix hash == NUM ) { return BOOL ; } int idx = - NUM * Arrays . binary Search ( hashes idx , prefix hash ) - NUM ; if ( idx == cache size ) { return BOOL ; } else { return ( hashes idx [ idx ] & PREFIX HASH MASK ) == prefix hash ; } }
private void check And Write Dictionary Chunk To File ( ) throws IO Exception { if ( one Dictionary Chunk List . size ( ) >= dictionary one chunk size ) { write Dictionary File ( ) ; create Chunk List ( ) ; } }
private void check And Write Dictionary Chunk To File ( ) throws IO Exception { if ( one Dictionary Chunk List . size ( ) >= dictionary one chunk size ) { write Dictionary File ( ) ; create Chunk List ( ) ; } }
public static boolean contains Any ( Char Sequence cs , char [ ] search Chars ) { if ( is Empty ( cs ) || is Empty ( search Chars ) ) { return BOOL ; } int cs Length = cs . length ( ) ; int search Length = search Chars . length ; int cs Last = cs Length - NUM ; int search Last = search Length - NUM ; for ( int i = NUM ; i < cs Length ; i ++ ) { char ch = cs . char At ( i ) ; for ( int j = NUM ; j < search Length ; j ++ ) { if ( search Chars [ j ] == ch ) { if ( Character . is High Surrogate ( ch ) ) { if ( j == search Last ) { return BOOL ; } if ( i < cs Last && search Chars [ j + NUM ] == cs . char At ( i + NUM ) ) { return BOOL ; } } else { return BOOL ; } } } } return BOOL ; }
public static boolean contains Any ( Char Sequence cs , char [ ] search Chars ) { if ( is Empty ( cs ) || is Empty ( search Chars ) ) { return BOOL ; } int cs Length = cs . length ( ) ; int search Length = search Chars . length ; int cs Last = cs Length - NUM ; int search Last = search Length - NUM ; for ( int i = NUM ; i < cs Length ; i ++ ) { char ch = cs . char At ( i ) ; for ( int j = NUM ; j < search Length ; j ++ ) { if ( search Chars [ j ] == ch ) { if ( Character . is High Surrogate ( ch ) ) { if ( j == search Last ) { return BOOL ; } if ( i < cs Last && search Chars [ j + NUM ] == cs . char At ( i + NUM ) ) { return BOOL ; } } else { return BOOL ; } } } } return BOOL ; }
public int read Unsigned Byte BE ( ) throws IO Exception { return input Stream . read Unsigned Byte ( ) ; }
public int read Unsigned Byte BE ( ) throws IO Exception { return input Stream . read Unsigned Byte ( ) ; }
public int read Unsigned Byte BE ( ) throws IO Exception { return input Stream . read Unsigned Byte ( ) ; }
public void test Shift Right Neg Non Zeroes ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = - NUM ; int number = NUM ; byte r Bytes [ ] = { - NUM , - NUM , NUM , - NUM , NUM , - NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . shift Right ( number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }
public void fill Default Values ( ) { tf Learning Rate . set Text ( Double . to String ( Subtractive Normalization Rule . DEFAULT LEARNING RATE ) ) ; }
public void fill Default Values ( ) { tf Learning Rate . set Text ( Double . to String ( Subtractive Normalization Rule . DEFAULT LEARNING RATE ) ) ; }
void flush ( Vcf Writer writer ) throws IO Exception { if ( m Prev Record != null ) { if ( ! m Prev Dense ) { write Count ( writer , m Prev Record ) ; } else { m Vcf Filter Statistics . increment ( Stat . DENSITY WINDOW COUNT ) ; } } m Prev Record = null ; m Prev Dense = BOOL ; }
public void test Connect A 2 dp ( ) { int iterations = Bluetooth Test Runner . s Connect A 2 dp Iterations ; if ( iterations == NUM ) { return ; } Bluetooth Adapter adapter = Bluetooth Adapter . get Default Adapter ( ) ; Bluetooth Device device = adapter . get Remote Device ( Bluetooth Test Runner . s Device Address ) ; m Test Utils . disable ( adapter ) ; m Test Utils . enable ( adapter ) ; m Test Utils . unpair ( adapter , device ) ; m Test Utils . pair ( adapter , device , Bluetooth Test Runner . s Device Pair Passkey , Bluetooth Test Runner . s Device Pair Pin ) ; m Test Utils . disconnect Profile ( adapter , device , Bluetooth Profile . A2 DP , null ) ; for ( int i = NUM ; i < iterations ; i ++ ) { m Test Utils . write Output ( STRING + ( i + NUM ) + STRING + iterations ) ; m Test Utils . connect Profile ( adapter , device , Bluetooth Profile . A2 DP , String . format ( STRING , device ) ) ; m Test Utils . disconnect Profile ( adapter , device , Bluetooth Profile . A2 DP , String . format ( STRING , device ) ) ; } m Test Utils . unpair ( adapter , device ) ; m Test Utils . disable ( adapter ) ; }
public void test Connect A 2 dp ( ) { int iterations = Bluetooth Test Runner . s Connect A 2 dp Iterations ; if ( iterations == NUM ) { return ; } Bluetooth Adapter adapter = Bluetooth Adapter . get Default Adapter ( ) ; Bluetooth Device device = adapter . get Remote Device ( Bluetooth Test Runner . s Device Address ) ; m Test Utils . disable ( adapter ) ; m Test Utils . enable ( adapter ) ; m Test Utils . unpair ( adapter , device ) ; m Test Utils . pair ( adapter , device , Bluetooth Test Runner . s Device Pair Passkey , Bluetooth Test Runner . s Device Pair Pin ) ; m Test Utils . disconnect Profile ( adapter , device , Bluetooth Profile . A2 DP , null ) ; for ( int i = NUM ; i < iterations ; i ++ ) { m Test Utils . write Output ( STRING + ( i + NUM ) + STRING + iterations ) ; m Test Utils . connect Profile ( adapter , device , Bluetooth Profile . A2 DP , String . format ( STRING , device ) ) ; m Test Utils . disconnect Profile ( adapter , device , Bluetooth Profile . A2 DP , String . format ( STRING , device ) ) ; } m Test Utils . unpair ( adapter , device ) ; m Test Utils . disable ( adapter ) ; }
private String collapse Slashes ( String path ) { int length = path . length ( ) ; if ( length < NUM ) return path ; if ( path . index Of ( STRING , NUM ) == - NUM ) return path ; char [ ] result = new char [ path . length ( ) ] ; int count = NUM ; boolean has Previous = BOOL ; char [ ] characters = path . to Char Array ( ) ; for ( int index = NUM ; index < characters . length ; index ++ ) { char c = characters [ index ] ; if ( c == SEPARATOR ) { if ( has Previous ) { if ( device == null && index == NUM ) { result [ count ] = c ; count ++ ; } } else { has Previous = BOOL ; result [ count ] = c ; count ++ ; } } else { has Previous = BOOL ; result [ count ] = c ; count ++ ; } } return new String ( result , NUM , count ) ; }
private String collapse Slashes ( String path ) { int length = path . length ( ) ; if ( length < NUM ) return path ; if ( path . index Of ( STRING , NUM ) == - NUM ) return path ; char [ ] result = new char [ path . length ( ) ] ; int count = NUM ; boolean has Previous = BOOL ; char [ ] characters = path . to Char Array ( ) ; for ( int index = NUM ; index < characters . length ; index ++ ) { char c = characters [ index ] ; if ( c == SEPARATOR ) { if ( has Previous ) { if ( device == null && index == NUM ) { result [ count ] = c ; count ++ ; } } else { has Previous = BOOL ; result [ count ] = c ; count ++ ; } } else { has Previous = BOOL ; result [ count ] = c ; count ++ ; } } return new String ( result , NUM , count ) ; }
public static int unix Timestamp ( ) { return ( int ) ( System . current Time Millis ( ) / NUM ) ; }
public void import PKCS 8 ( Burp Certificate certificate , String filename ) { set Status ( STRING ) ; File Input Stream fis ; File file = new File ( filename ) ; Private Key private Key ; try { fis = new File Input Stream ( file ) ; Data Input Stream dis = new Data Input Stream ( fis ) ; byte [ ] key Bytes = new byte [ ( int ) file . length ( ) ] ; dis . read Fully ( key Bytes ) ; dis . close ( ) ; PKCS 8 Encoded Key Spec key Spec = new PKCS 8 Encoded Key Spec ( key Bytes ) ; Key Factory key Factory = Key Factory . get Instance ( STRING ) ; private Key = key Factory . generate Private ( key Spec ) ; certificate . set Private Key ( private Key ) ; set Certificate Tree ( ) ; set Status ( STRING ) ; } catch ( IO Exception | No Such Algorithm Exception | Invalid Key Spec Exception e ) { set Status ( STRING + e . get Message ( ) + STRING ) ; e . print Stack Trace ( ) ; } catch ( Exception e ) { set Status ( STRING + e . get Message ( ) + STRING ) ; } }
public void remove Listener ( final I Memory Listener listener ) { m listeners . remove ( listener ) ; }
public double median ( double [ ] series ) { double [ ] cloned Series = series . clone ( ) ; Arrays . sort ( cloned Series ) ; double median ; if ( cloned Series . length % NUM == NUM ) { median = ( cloned Series [ cloned Series . length / NUM ] + ( double ) cloned Series [ cloned Series . length / NUM - NUM ] ) / NUM ; } else { median = cloned Series [ cloned Series . length / NUM ] ; } return median ; }
public Colour Map Model ( Colour Map Model Update Interface parent ) { this . parent Obj = parent ; column List . add ( Localisation . get String ( Field Config Base . class , STRING ) ) ; column List . add ( Localisation . get String ( Field Config Base . class , STRING ) ) ; column List . add ( Localisation . get String ( Field Config Base . class , STRING ) ) ; column List . add ( Localisation . get String ( Field Config Base . class , STRING ) ) ; column List . add ( Localisation . get String ( Field Config Base . class , STRING ) ) ; }
private static boolean calculate Is Failure ( ) { int random Value = random . next Int ( NUM ) + NUM ; return random Value <= ERROR PCT ; }
public void create ( ) { Window Support . set Default Window Support Display Type ( Window Support . Dlg . class ) ; set Layout ( create Layout Manager ( ) ) ; left Slider = new J Split Pane ( ) ; left Slider . set Border ( null ) ; left Slider . set Resize Weight ( NUM ) ; left Slider . set One Touch Expandable ( BOOL ) ; right Slider = new J Split Pane ( ) ; right Slider . set Border ( null ) ; right Slider . set Resize Weight ( NUM ) ; right Slider . set One Touch Expandable ( BOOL ) ; right Slider . set Left Component ( left Slider ) ; right Slider . set Right Component ( null ) ; if ( BOOL ) { bottom Slider = new J Split Pane ( J Split Pane . VERTICAL SPLIT ) ; bottom Slider . set Border ( null ) ; bottom Slider . set Resize Weight ( NUM ) ; bottom Slider . set One Touch Expandable ( BOOL ) ; left Slider . set Right Component ( bottom Slider ) ; } super . add ( right Slider , Border Layout . CENTER ) ; }
public void create ( ) { Window Support . set Default Window Support Display Type ( Window Support . Dlg . class ) ; set Layout ( create Layout Manager ( ) ) ; left Slider = new J Split Pane ( ) ; left Slider . set Border ( null ) ; left Slider . set Resize Weight ( NUM ) ; left Slider . set One Touch Expandable ( BOOL ) ; right Slider = new J Split Pane ( ) ; right Slider . set Border ( null ) ; right Slider . set Resize Weight ( NUM ) ; right Slider . set One Touch Expandable ( BOOL ) ; right Slider . set Left Component ( left Slider ) ; right Slider . set Right Component ( null ) ; if ( BOOL ) { bottom Slider = new J Split Pane ( J Split Pane . VERTICAL SPLIT ) ; bottom Slider . set Border ( null ) ; bottom Slider . set Resize Weight ( NUM ) ; bottom Slider . set One Touch Expandable ( BOOL ) ; left Slider . set Right Component ( bottom Slider ) ; } super . add ( right Slider , Border Layout . CENTER ) ; }
public void create ( ) { Window Support . set Default Window Support Display Type ( Window Support . Dlg . class ) ; set Layout ( create Layout Manager ( ) ) ; left Slider = new J Split Pane ( ) ; left Slider . set Border ( null ) ; left Slider . set Resize Weight ( NUM ) ; left Slider . set One Touch Expandable ( BOOL ) ; right Slider = new J Split Pane ( ) ; right Slider . set Border ( null ) ; right Slider . set Resize Weight ( NUM ) ; right Slider . set One Touch Expandable ( BOOL ) ; right Slider . set Left Component ( left Slider ) ; right Slider . set Right Component ( null ) ; if ( BOOL ) { bottom Slider = new J Split Pane ( J Split Pane . VERTICAL SPLIT ) ; bottom Slider . set Border ( null ) ; bottom Slider . set Resize Weight ( NUM ) ; bottom Slider . set One Touch Expandable ( BOOL ) ; left Slider . set Right Component ( bottom Slider ) ; } super . add ( right Slider , Border Layout . CENTER ) ; }
public void create ( ) { Window Support . set Default Window Support Display Type ( Window Support . Dlg . class ) ; set Layout ( create Layout Manager ( ) ) ; left Slider = new J Split Pane ( ) ; left Slider . set Border ( null ) ; left Slider . set Resize Weight ( NUM ) ; left Slider . set One Touch Expandable ( BOOL ) ; right Slider = new J Split Pane ( ) ; right Slider . set Border ( null ) ; right Slider . set Resize Weight ( NUM ) ; right Slider . set One Touch Expandable ( BOOL ) ; right Slider . set Left Component ( left Slider ) ; right Slider . set Right Component ( null ) ; if ( BOOL ) { bottom Slider = new J Split Pane ( J Split Pane . VERTICAL SPLIT ) ; bottom Slider . set Border ( null ) ; bottom Slider . set Resize Weight ( NUM ) ; bottom Slider . set One Touch Expandable ( BOOL ) ; left Slider . set Right Component ( bottom Slider ) ; } super . add ( right Slider , Border Layout . CENTER ) ; }
public void create ( ) { Window Support . set Default Window Support Display Type ( Window Support . Dlg . class ) ; set Layout ( create Layout Manager ( ) ) ; left Slider = new J Split Pane ( ) ; left Slider . set Border ( null ) ; left Slider . set Resize Weight ( NUM ) ; left Slider . set One Touch Expandable ( BOOL ) ; right Slider = new J Split Pane ( ) ; right Slider . set Border ( null ) ; right Slider . set Resize Weight ( NUM ) ; right Slider . set One Touch Expandable ( BOOL ) ; right Slider . set Left Component ( left Slider ) ; right Slider . set Right Component ( null ) ; if ( BOOL ) { bottom Slider = new J Split Pane ( J Split Pane . VERTICAL SPLIT ) ; bottom Slider . set Border ( null ) ; bottom Slider . set Resize Weight ( NUM ) ; bottom Slider . set One Touch Expandable ( BOOL ) ; left Slider . set Right Component ( bottom Slider ) ; } super . add ( right Slider , Border Layout . CENTER ) ; }
public void create ( ) { Window Support . set Default Window Support Display Type ( Window Support . Dlg . class ) ; set Layout ( create Layout Manager ( ) ) ; left Slider = new J Split Pane ( ) ; left Slider . set Border ( null ) ; left Slider . set Resize Weight ( NUM ) ; left Slider . set One Touch Expandable ( BOOL ) ; right Slider = new J Split Pane ( ) ; right Slider . set Border ( null ) ; right Slider . set Resize Weight ( NUM ) ; right Slider . set One Touch Expandable ( BOOL ) ; right Slider . set Left Component ( left Slider ) ; right Slider . set Right Component ( null ) ; if ( BOOL ) { bottom Slider = new J Split Pane ( J Split Pane . VERTICAL SPLIT ) ; bottom Slider . set Border ( null ) ; bottom Slider . set Resize Weight ( NUM ) ; bottom Slider . set One Touch Expandable ( BOOL ) ; left Slider . set Right Component ( bottom Slider ) ; } super . add ( right Slider , Border Layout . CENTER ) ; }
public void create ( ) { Window Support . set Default Window Support Display Type ( Window Support . Dlg . class ) ; set Layout ( create Layout Manager ( ) ) ; left Slider = new J Split Pane ( ) ; left Slider . set Border ( null ) ; left Slider . set Resize Weight ( NUM ) ; left Slider . set One Touch Expandable ( BOOL ) ; right Slider = new J Split Pane ( ) ; right Slider . set Border ( null ) ; right Slider . set Resize Weight ( NUM ) ; right Slider . set One Touch Expandable ( BOOL ) ; right Slider . set Left Component ( left Slider ) ; right Slider . set Right Component ( null ) ; if ( BOOL ) { bottom Slider = new J Split Pane ( J Split Pane . VERTICAL SPLIT ) ; bottom Slider . set Border ( null ) ; bottom Slider . set Resize Weight ( NUM ) ; bottom Slider . set One Touch Expandable ( BOOL ) ; left Slider . set Right Component ( bottom Slider ) ; } super . add ( right Slider , Border Layout . CENTER ) ; }
public void create ( ) { Window Support . set Default Window Support Display Type ( Window Support . Dlg . class ) ; set Layout ( create Layout Manager ( ) ) ; left Slider = new J Split Pane ( ) ; left Slider . set Border ( null ) ; left Slider . set Resize Weight ( NUM ) ; left Slider . set One Touch Expandable ( BOOL ) ; right Slider = new J Split Pane ( ) ; right Slider . set Border ( null ) ; right Slider . set Resize Weight ( NUM ) ; right Slider . set One Touch Expandable ( BOOL ) ; right Slider . set Left Component ( left Slider ) ; right Slider . set Right Component ( null ) ; if ( BOOL ) { bottom Slider = new J Split Pane ( J Split Pane . VERTICAL SPLIT ) ; bottom Slider . set Border ( null ) ; bottom Slider . set Resize Weight ( NUM ) ; bottom Slider . set One Touch Expandable ( BOOL ) ; left Slider . set Right Component ( bottom Slider ) ; } super . add ( right Slider , Border Layout . CENTER ) ; }
public View Translating Graph Mouse Plugin ( int modifiers ) { super ( modifiers ) ; this . cursor = Cursor . get Predefined Cursor ( Cursor . MOVE CURSOR ) ; }
public static Big Decimal calculate Fee ( Player player , int price ) { Big Decimal fee = Big Decimal . value Of ( price ) ; fee = fee . multiply ( Big Decimal . value Of ( TRADING FEE PERCENTAGE ) ) ; if ( player . is Bad Boy ( ) ) { fee = fee . multiply ( Big Decimal . value Of ( NUM + TRADING FEE PLAYER KILLER PENALTY ) ) ; } Big Decimal fee Bonus = Big Decimal . ONE ; fee Bonus = Big Decimal . value Of ( Math . exp ( - player . get Tradescore ( ) / FEE BONUS CONSTANT ) ) ; fee = fee . multiply ( fee Bonus ) ; return fee . max ( Big Decimal . ONE ) ; }
public static Big Decimal calculate Fee ( Player player , int price ) { Big Decimal fee = Big Decimal . value Of ( price ) ; fee = fee . multiply ( Big Decimal . value Of ( TRADING FEE PERCENTAGE ) ) ; if ( player . is Bad Boy ( ) ) { fee = fee . multiply ( Big Decimal . value Of ( NUM + TRADING FEE PLAYER KILLER PENALTY ) ) ; } Big Decimal fee Bonus = Big Decimal . ONE ; fee Bonus = Big Decimal . value Of ( Math . exp ( - player . get Tradescore ( ) / FEE BONUS CONSTANT ) ) ; fee = fee . multiply ( fee Bonus ) ; return fee . max ( Big Decimal . ONE ) ; }
public static Z uz ( ) { return new Z ( R . next Double ( ) , R . next Double ( ) ) ; }
static private String SHORT Max Plus ( ) { long temp Value = Short . MAX VALUE + NUM ; return String . value Of ( temp Value ) ; }
@ Pure @ Causes Error ( { Incorrect Pure 4 J Immutable Call Exception . class , Pure Method Parameter Not Immutable Exception . class } ) public String test Param 1 Bad ( Object in 1 , Object in 2 ) { Object in 3 = in 2 ; Pure 4 J . immutable ( in 1 , in 2 ) ; return in 3 . to String ( ) ; }
public void remove Active Line Range Listener ( Active Line Range Listener l ) { listener List . remove ( Active Line Range Listener . class , l ) ; }
public static int show Yes No Error ( final Component parent , final String msg ) { return J Option Pane . show Confirm Dialog ( is Iconified ( parent ) ? null : parent , msg , System . get Property ( DEFAULT WINDOW TITLE PROPERTY ) , J Option Pane . YES NO OPTION , J Option Pane . ERROR MESSAGE ) ; }
public void add Option ( T option , double weight ) { if ( weight < NUM ) throw new Illegal Argument Exception ( STRING ) ; options . add ( option ) ; weights . add ( weight ) ; weight Sum += weight ; }
public Byte Buffer create Buffer ( Map < String , Object > parameters ) { Byte Buffer buffer = create Byte Buffer ( ) ; for ( Field field : fields ) { log . trace ( STRING , buffer . position ( ) ) ; field . write ( resolve Input Value ( parameters , field ) , buffer ) ; log . trace ( STRING , buffer . position ( ) ) ; } buffer . flip ( ) ; return buffer ; }
public Byte Buffer create Buffer ( Map < String , Object > parameters ) { Byte Buffer buffer = create Byte Buffer ( ) ; for ( Field field : fields ) { log . trace ( STRING , buffer . position ( ) ) ; field . write ( resolve Input Value ( parameters , field ) , buffer ) ; log . trace ( STRING , buffer . position ( ) ) ; } buffer . flip ( ) ; return buffer ; }
public void add Profiles ( @ Non Null I Profile ... profiles ) { if ( m Account Header Builder . m Profiles == null ) { m Account Header Builder . m Profiles = new Array List < > ( ) ; } Collections . add All ( m Account Header Builder . m Profiles , profiles ) ; m Account Header Builder . update Header And List ( ) ; }
private int [ ] to Int Array ( String str ) { int [ ] ret Val = new int [ NUM ] ; str = str + STRING ; int rlen = ret Val . length ; for ( int i = NUM ; i < rlen ; i ++ ) { ret Val [ i ] = Integer . parse Int ( str . substring ( NUM , str . index Of ( STRING ) ) ) ; str = str . substring ( str . index Of ( STRING ) + NUM , str . length ( ) ) ; } return ret Val ; }
@ Override public void draw Range Line ( Graphics 2 D g2 , XY Plot plot , Value Axis axis , Rectangle 2 D data Area , double value , Paint paint , Stroke stroke ) { Range range = axis . get Range ( ) ; if ( ! range . contains ( value ) ) { return ; } Plot Orientation orientation = plot . get Orientation ( ) ; Line 2 D line = null ; double v = axis . value To Java 2 D ( value , data Area , plot . get Range Axis Edge ( ) ) ; if ( orientation == Plot Orientation . HORIZONTAL ) { line = new Line 2 D . Double ( v , data Area . get Min Y ( ) , v , data Area . get Max Y ( ) ) ; } else if ( orientation == Plot Orientation . VERTICAL ) { line = new Line 2 D . Double ( data Area . get Min X ( ) , v , data Area . get Max X ( ) , v ) ; } g2 . set Paint ( paint ) ; g2 . set Stroke ( stroke ) ; Object saved = g2 . get Rendering Hint ( Rendering Hints . KEY STROKE CONTROL ) ; g2 . set Rendering Hint ( Rendering Hints . KEY STROKE CONTROL , Rendering Hints . VALUE STROKE NORMALIZE ) ; g2 . draw ( line ) ; g2 . set Rendering Hint ( Rendering Hints . KEY STROKE CONTROL , saved ) ; }
public boolean add Property ( Owl Property property ) { property . add Restriction ( this ) ; return properties . add ( property ) ; }
public boolean add Property ( Owl Property property ) { property . add Restriction ( this ) ; return properties . add ( property ) ; }
private void interrupt Idle Workers ( boolean only One ) { final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { Iterator < Worker > it = workers . iterator ( ) ; while ( it . has Next ( ) ) { Worker w = it . next ( ) ; Thread t = w . thread ; if ( ! t . is Interrupted ( ) && w . try Lock ( ) ) { try { t . interrupt ( ) ; } catch ( Security Exception ignore ) { } finally { w . unlock ( ) ; } } if ( only One ) break ; } } finally { main Lock . unlock ( ) ; } }
private void interrupt Idle Workers ( boolean only One ) { final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { Iterator < Worker > it = workers . iterator ( ) ; while ( it . has Next ( ) ) { Worker w = it . next ( ) ; Thread t = w . thread ; if ( ! t . is Interrupted ( ) && w . try Lock ( ) ) { try { t . interrupt ( ) ; } catch ( Security Exception ignore ) { } finally { w . unlock ( ) ; } } if ( only One ) break ; } } finally { main Lock . unlock ( ) ; } }
public void begin ( Attributes attributes ) throws Exception { UI Component uic = ( UI Component ) digester . peek ( ) ; Attributes Impl attrs = new Attributes Impl ( attributes ) ; for ( int i = NUM ; i < attrs . get Length ( ) ; i ++ ) { String q Name = attributes . get Q Name ( i ) ; attrs . set Local Name ( i , q Name ) ; attrs . set Value ( i , attributes . get Value ( q Name ) ) ; } bc . handle Nested Component Tag ( uic , STRING , attrs ) ; }
@ Override public Indexable Field create Field ( Schema Field field , Object value , float boost ) { throw new Unsupported Operation Exception ( STRING + field . get Name ( ) ) ; }
@ Override public Indexable Field create Field ( Schema Field field , Object value , float boost ) { throw new Unsupported Operation Exception ( STRING + field . get Name ( ) ) ; }
@ Override public Indexable Field create Field ( Schema Field field , Object value , float boost ) { throw new Unsupported Operation Exception ( STRING + field . get Name ( ) ) ; }
public Dis Max Query Builder add ( Query Builder query Builder ) { queries . add ( query Builder ) ; return this ; }
public void delete ( String name ) throws IO Exception { if ( name . equals Ignore Case ( QUALIFIERS ) ) { policy Qualifiers = Collections . empty Set ( ) ; } else if ( name . equals Ignore Case ( ID ) ) { throw new IO Exception ( STRING + STRING ) ; } else { throw new IO Exception ( STRING + name + STRING ) ; } }
@ Override public Document Type create Document Type ( String qualified Name , String public ID , String system ID ) { check Q Name ( qualified Name ) ; return new Document Type Impl ( null , qualified Name , public ID , system ID ) ; }
@ Override public Document Type create Document Type ( String qualified Name , String public ID , String system ID ) { check Q Name ( qualified Name ) ; return new Document Type Impl ( null , qualified Name , public ID , system ID ) ; }
public static boolean can Resize ( List constraints ) { for ( Iterator iter = constraints . iterator ( ) ; iter . has Next ( ) ; ) { Dock Constraint dc = ( Dock Constraint ) iter . next ( ) ; if ( ! dc . can Resize ( ) ) return BOOL ; } return BOOL ; }
public static boolean can Resize ( List constraints ) { for ( Iterator iter = constraints . iterator ( ) ; iter . has Next ( ) ; ) { Dock Constraint dc = ( Dock Constraint ) iter . next ( ) ; if ( ! dc . can Resize ( ) ) return BOOL ; } return BOOL ; }
@ Override public void read External ( Object Input is ) throws IO Exception { read Fields ( is ) ; }
@ Override public void read External ( Object Input is ) throws IO Exception { read Fields ( is ) ; }
public Trigger In List Condition ( final String ... trigger ) { this ( Arrays . as List ( trigger ) ) ; }
private Comparable < ? > cast To Comparable ( Object value ) { try { return ( Comparable < ? > ) value ; } catch ( Class Cast Exception e ) { throw new Illegal Argument Exception ( STRING , e ) ; } }
public void read ( byte [ ] buff , int off , int len ) { System . arraycopy ( data , pos , buff , off , len ) ; pos += len ; }
public synchronized void update ( double sample ) { long now = System . current Time Millis ( ) ; if ( last Millis == NUM ) { average = sample ; last Millis = now ; return ; } long delta Time = now - last Millis ; double coeff = Math . exp ( - NUM * ( ( double ) delta Time / window Millis ) ) ; average = ( NUM - coeff ) * sample + coeff * average ; last Millis = now ; }
public final void remove All Helper Text Colors ( ) { helper Text Colors . clear ( ) ; }
public final void remove All Helper Text Colors ( ) { helper Text Colors . clear ( ) ; }
public final void remove All Helper Text Colors ( ) { helper Text Colors . clear ( ) ; }
private void capacity Warn ( ) { if ( warning Counter == NUM ) { LOGGER . warn ( STRING + buffer . size ( ) + STRING ) ; warning Counter = WARNING FREQUENCY ; } else { warning Counter = warning Counter - NUM ; } }
public void dump ( Print Writer output , int pad , String title ) { Utilities . dump ( output , pad , title ) ; features . dump ( output , pad + NUM , title + STRING ) ; dump Processors ( output , pad + NUM , title + STRING ) ; }
public void remove Version ( final Software Version version ) throws Local Repository Exception { final String prefix = STRING + version + STRING ; log . debug ( prefix ) ; final String [ ] cmd = { SYSTOOL CMD , SYSTOOL REMOVE , version . to String ( ) } ; exec ( prefix , cmd ) ; log . info ( prefix + STRING ) ; }
private Double Constant parse Double Constant ( int index ) throws IO Exception { long bits = read Long ( ) ; double value = Double . long Bits To Double ( bits ) ; return new Double Constant ( class . get Constant Pool ( ) , index , value ) ; }
protected void add Resource Delta ( I Resource Delta child ) { switch ( this . kind ) { case ADDED : case REMOVED : return ; case CHANGED : this . change Flags |= F CONTENT ; break ; default : this . kind = CHANGED ; this . change Flags |= F CONTENT ; } if ( this . resource Deltas == null ) { this . resource Deltas = new I Resource Delta [ NUM ] ; this . resource Deltas [ this . resource Deltas Counter ++ ] = child ; return ; } if ( this . resource Deltas . length == this . resource Deltas Counter ) { System . arraycopy ( this . resource Deltas , NUM , ( this . resource Deltas = new I Resource Delta [ this . resource Deltas Counter * NUM ] ) , NUM , this . resource Deltas Counter ) ; } this . resource Deltas [ this . resource Deltas Counter ++ ] = child ; }
protected void add Resource Delta ( I Resource Delta child ) { switch ( this . kind ) { case ADDED : case REMOVED : return ; case CHANGED : this . change Flags |= F CONTENT ; break ; default : this . kind = CHANGED ; this . change Flags |= F CONTENT ; } if ( this . resource Deltas == null ) { this . resource Deltas = new I Resource Delta [ NUM ] ; this . resource Deltas [ this . resource Deltas Counter ++ ] = child ; return ; } if ( this . resource Deltas . length == this . resource Deltas Counter ) { System . arraycopy ( this . resource Deltas , NUM , ( this . resource Deltas = new I Resource Delta [ this . resource Deltas Counter * NUM ] ) , NUM , this . resource Deltas Counter ) ; } this . resource Deltas [ this . resource Deltas Counter ++ ] = child ; }
public void add Glue Rules ( Array List < Feature Function > feature Functions ) { Hiero Format Reader reader = new Hiero Format Reader ( ) ; String goal NT = Format Utils . clean Non Terminal ( joshua Configuration . goal symbol ) ; String default NT = Format Utils . clean Non Terminal ( joshua Configuration . default non terminal ) ; String [ ] rule Strings = new String [ ] { String . format ( STRING , goal NT , Vocabulary . START SYM , Vocabulary . START SYM ) , String . format ( STRING , goal NT , goal NT , default NT , goal NT , default NT ) , String . format ( STRING , goal NT , goal NT , Vocabulary . STOP SYM , goal NT , Vocabulary . STOP SYM ) } ; for ( String rule String : rule Strings ) { Rule rule = reader . parse Line ( rule String ) ; add Rule ( rule ) ; rule . estimate Rule Cost ( feature Functions ) ; } }
public static int maximum Sum Non Adjacent Sub Sequence ( int [ ] a ) { int incl = a [ NUM ] , excl = NUM , prev Incl = incl ; for ( int i = NUM ; i < a . length ; i ++ ) { incl = excl + a [ i ] ; excl = Math . max ( prev Incl , excl ) ; prev Incl = incl ; } return Math . max ( incl , excl ) ; }
public static int maximum Sum Non Adjacent Sub Sequence ( int [ ] a ) { int incl = a [ NUM ] , excl = NUM , prev Incl = incl ; for ( int i = NUM ; i < a . length ; i ++ ) { incl = excl + a [ i ] ; excl = Math . max ( prev Incl , excl ) ; prev Incl = incl ; } return Math . max ( incl , excl ) ; }
public static int maximum Sum Non Adjacent Sub Sequence ( int [ ] a ) { int incl = a [ NUM ] , excl = NUM , prev Incl = incl ; for ( int i = NUM ; i < a . length ; i ++ ) { incl = excl + a [ i ] ; excl = Math . max ( prev Incl , excl ) ; prev Incl = incl ; } return Math . max ( incl , excl ) ; }
public static int maximum Sum Non Adjacent Sub Sequence ( int [ ] a ) { int incl = a [ NUM ] , excl = NUM , prev Incl = incl ; for ( int i = NUM ; i < a . length ; i ++ ) { incl = excl + a [ i ] ; excl = Math . max ( prev Incl , excl ) ; prev Incl = incl ; } return Math . max ( incl , excl ) ; }
public static int maximum Sum Non Adjacent Sub Sequence ( int [ ] a ) { int incl = a [ NUM ] , excl = NUM , prev Incl = incl ; for ( int i = NUM ; i < a . length ; i ++ ) { incl = excl + a [ i ] ; excl = Math . max ( prev Incl , excl ) ; prev Incl = incl ; } return Math . max ( incl , excl ) ; }
private static void run Random Test ( final int word Length , final int byte Padding , final int word Count ) { final long seed = random Long ( ) ; final Random random = new Random ( seed ) ; final Random verification Random = new Random ( seed ) ; final long word Mask ; if ( word Length == NUM ) { word Mask = ~ NUM ; } else { word Mask = ( NUM << word Length ) - NUM ; } final Big Endian Ascending Word Serializer serializer = new Big Endian Ascending Word Serializer ( word Length , word Count , byte Padding ) ; for ( int i = NUM ; i < word Count ; i ++ ) { final long value = random . next Long ( ) & word Mask ; serializer . write Word ( value ) ; } final byte [ ] bytes = serializer . get Bytes ( ) ; final Big Endian Ascending Word Deserializer deserializer = new Big Endian Ascending Word Deserializer ( word Length , byte Padding , bytes ) ; assert Equals ( deserializer . total Word Count ( ) , word Count ) ; for ( int i = NUM ; i < word Count ; i ++ ) { assert Equals ( deserializer . read Word ( ) , ( verification Random . next Long ( ) & word Mask ) ) ; } }
private static void run Random Test ( final int word Length , final int byte Padding , final int word Count ) { final long seed = random Long ( ) ; final Random random = new Random ( seed ) ; final Random verification Random = new Random ( seed ) ; final long word Mask ; if ( word Length == NUM ) { word Mask = ~ NUM ; } else { word Mask = ( NUM << word Length ) - NUM ; } final Big Endian Ascending Word Serializer serializer = new Big Endian Ascending Word Serializer ( word Length , word Count , byte Padding ) ; for ( int i = NUM ; i < word Count ; i ++ ) { final long value = random . next Long ( ) & word Mask ; serializer . write Word ( value ) ; } final byte [ ] bytes = serializer . get Bytes ( ) ; final Big Endian Ascending Word Deserializer deserializer = new Big Endian Ascending Word Deserializer ( word Length , byte Padding , bytes ) ; assert Equals ( deserializer . total Word Count ( ) , word Count ) ; for ( int i = NUM ; i < word Count ; i ++ ) { assert Equals ( deserializer . read Word ( ) , ( verification Random . next Long ( ) & word Mask ) ) ; } }
private static void run Random Test ( final int word Length , final int byte Padding , final int word Count ) { final long seed = random Long ( ) ; final Random random = new Random ( seed ) ; final Random verification Random = new Random ( seed ) ; final long word Mask ; if ( word Length == NUM ) { word Mask = ~ NUM ; } else { word Mask = ( NUM << word Length ) - NUM ; } final Big Endian Ascending Word Serializer serializer = new Big Endian Ascending Word Serializer ( word Length , word Count , byte Padding ) ; for ( int i = NUM ; i < word Count ; i ++ ) { final long value = random . next Long ( ) & word Mask ; serializer . write Word ( value ) ; } final byte [ ] bytes = serializer . get Bytes ( ) ; final Big Endian Ascending Word Deserializer deserializer = new Big Endian Ascending Word Deserializer ( word Length , byte Padding , bytes ) ; assert Equals ( deserializer . total Word Count ( ) , word Count ) ; for ( int i = NUM ; i < word Count ; i ++ ) { assert Equals ( deserializer . read Word ( ) , ( verification Random . next Long ( ) & word Mask ) ) ; } }
private Invocation Constraints create Invocation Constraints ( ) { if ( MIN RETRY >= sleep Time [ try Indx ] ) { return new Invocation Constraints ( new Connection Absolute Time ( System . current Time Millis ( ) + sleep Time [ try Indx ] ) , null ) ; } else { return Invocation Constraints . EMPTY ; } }
private Invocation Constraints create Invocation Constraints ( ) { if ( MIN RETRY >= sleep Time [ try Indx ] ) { return new Invocation Constraints ( new Connection Absolute Time ( System . current Time Millis ( ) + sleep Time [ try Indx ] ) , null ) ; } else { return Invocation Constraints . EMPTY ; } }
private void adjust Children To Group Change ( ) { int index = NUM ; Decimal Rectangle temp Bounds ; for ( Math Object math Obj : get Objects ( ) ) { temp Bounds = object Bounds . get ( index ) ; math Obj . setx Pos ( getx Pos ( ) + ( int ) Math . round ( temp Bounds . get X ( ) * get Width ( ) ) ) ; math Obj . sety Pos ( gety Pos ( ) + ( int ) Math . round ( temp Bounds . get Y ( ) * get Height ( ) ) ) ; math Obj . set Width ( ( int ) Math . round ( temp Bounds . get Width ( ) * get Width ( ) ) ) ; math Obj . set Height ( ( int ) Math . round ( temp Bounds . get Height ( ) * get Height ( ) ) ) ; if ( math Obj . get Width ( ) == NUM ) { math Obj . set Width ( NUM ) ; } if ( math Obj . get Height ( ) == NUM ) { math Obj . set Height ( NUM ) ; } index ++ ; } }
private void adjust Children To Group Change ( ) { int index = NUM ; Decimal Rectangle temp Bounds ; for ( Math Object math Obj : get Objects ( ) ) { temp Bounds = object Bounds . get ( index ) ; math Obj . setx Pos ( getx Pos ( ) + ( int ) Math . round ( temp Bounds . get X ( ) * get Width ( ) ) ) ; math Obj . sety Pos ( gety Pos ( ) + ( int ) Math . round ( temp Bounds . get Y ( ) * get Height ( ) ) ) ; math Obj . set Width ( ( int ) Math . round ( temp Bounds . get Width ( ) * get Width ( ) ) ) ; math Obj . set Height ( ( int ) Math . round ( temp Bounds . get Height ( ) * get Height ( ) ) ) ; if ( math Obj . get Width ( ) == NUM ) { math Obj . set Width ( NUM ) ; } if ( math Obj . get Height ( ) == NUM ) { math Obj . set Height ( NUM ) ; } index ++ ; } }
private void adjust Children To Group Change ( ) { int index = NUM ; Decimal Rectangle temp Bounds ; for ( Math Object math Obj : get Objects ( ) ) { temp Bounds = object Bounds . get ( index ) ; math Obj . setx Pos ( getx Pos ( ) + ( int ) Math . round ( temp Bounds . get X ( ) * get Width ( ) ) ) ; math Obj . sety Pos ( gety Pos ( ) + ( int ) Math . round ( temp Bounds . get Y ( ) * get Height ( ) ) ) ; math Obj . set Width ( ( int ) Math . round ( temp Bounds . get Width ( ) * get Width ( ) ) ) ; math Obj . set Height ( ( int ) Math . round ( temp Bounds . get Height ( ) * get Height ( ) ) ) ; if ( math Obj . get Width ( ) == NUM ) { math Obj . set Width ( NUM ) ; } if ( math Obj . get Height ( ) == NUM ) { math Obj . set Height ( NUM ) ; } index ++ ; } }
private void adjust Children To Group Change ( ) { int index = NUM ; Decimal Rectangle temp Bounds ; for ( Math Object math Obj : get Objects ( ) ) { temp Bounds = object Bounds . get ( index ) ; math Obj . setx Pos ( getx Pos ( ) + ( int ) Math . round ( temp Bounds . get X ( ) * get Width ( ) ) ) ; math Obj . sety Pos ( gety Pos ( ) + ( int ) Math . round ( temp Bounds . get Y ( ) * get Height ( ) ) ) ; math Obj . set Width ( ( int ) Math . round ( temp Bounds . get Width ( ) * get Width ( ) ) ) ; math Obj . set Height ( ( int ) Math . round ( temp Bounds . get Height ( ) * get Height ( ) ) ) ; if ( math Obj . get Width ( ) == NUM ) { math Obj . set Width ( NUM ) ; } if ( math Obj . get Height ( ) == NUM ) { math Obj . set Height ( NUM ) ; } index ++ ; } }
private void adjust Children To Group Change ( ) { int index = NUM ; Decimal Rectangle temp Bounds ; for ( Math Object math Obj : get Objects ( ) ) { temp Bounds = object Bounds . get ( index ) ; math Obj . setx Pos ( getx Pos ( ) + ( int ) Math . round ( temp Bounds . get X ( ) * get Width ( ) ) ) ; math Obj . sety Pos ( gety Pos ( ) + ( int ) Math . round ( temp Bounds . get Y ( ) * get Height ( ) ) ) ; math Obj . set Width ( ( int ) Math . round ( temp Bounds . get Width ( ) * get Width ( ) ) ) ; math Obj . set Height ( ( int ) Math . round ( temp Bounds . get Height ( ) * get Height ( ) ) ) ; if ( math Obj . get Width ( ) == NUM ) { math Obj . set Width ( NUM ) ; } if ( math Obj . get Height ( ) == NUM ) { math Obj . set Height ( NUM ) ; } index ++ ; } }
private void adjust Children To Group Change ( ) { int index = NUM ; Decimal Rectangle temp Bounds ; for ( Math Object math Obj : get Objects ( ) ) { temp Bounds = object Bounds . get ( index ) ; math Obj . setx Pos ( getx Pos ( ) + ( int ) Math . round ( temp Bounds . get X ( ) * get Width ( ) ) ) ; math Obj . sety Pos ( gety Pos ( ) + ( int ) Math . round ( temp Bounds . get Y ( ) * get Height ( ) ) ) ; math Obj . set Width ( ( int ) Math . round ( temp Bounds . get Width ( ) * get Width ( ) ) ) ; math Obj . set Height ( ( int ) Math . round ( temp Bounds . get Height ( ) * get Height ( ) ) ) ; if ( math Obj . get Width ( ) == NUM ) { math Obj . set Width ( NUM ) ; } if ( math Obj . get Height ( ) == NUM ) { math Obj . set Height ( NUM ) ; } index ++ ; } }
protected void sparse To Dense ( ) { if ( ! is Sparse ) { return ; } coordinates = new float [ dimension ] ; for ( int i = NUM ; i < dimension ; ++ i ) { coordinates [ i ] = NUM ; } for ( int i = NUM ; i < sparse Offsets . length ; ++ i ) { coordinates [ Math . abs ( sparse Offsets [ i ] ) - NUM ] = Math . signum ( sparse Offsets [ i ] ) ; } is Sparse = BOOL ; }
protected void sparse To Dense ( ) { if ( ! is Sparse ) { return ; } coordinates = new float [ dimension ] ; for ( int i = NUM ; i < dimension ; ++ i ) { coordinates [ i ] = NUM ; } for ( int i = NUM ; i < sparse Offsets . length ; ++ i ) { coordinates [ Math . abs ( sparse Offsets [ i ] ) - NUM ] = Math . signum ( sparse Offsets [ i ] ) ; } is Sparse = BOOL ; }
protected void sparse To Dense ( ) { if ( ! is Sparse ) { return ; } coordinates = new float [ dimension ] ; for ( int i = NUM ; i < dimension ; ++ i ) { coordinates [ i ] = NUM ; } for ( int i = NUM ; i < sparse Offsets . length ; ++ i ) { coordinates [ Math . abs ( sparse Offsets [ i ] ) - NUM ] = Math . signum ( sparse Offsets [ i ] ) ; } is Sparse = BOOL ; }
private static Generalized Time create Time ( final String value , final int year , final int month , final int day , final int hour , final int minute , final int second , final Time Zone tz ) { try { final Gregorian Calendar calendar = new Gregorian Calendar ( ) ; calendar . set Lenient ( BOOL ) ; calendar . set Time Zone ( tz ) ; calendar . set ( year , month , day , hour , minute , second ) ; calendar . set ( Calendar . MILLISECOND , NUM ) ; return new Generalized Time ( calendar , null , Long . MIN VALUE , value ) ; } catch ( final Exception e ) { final Localizable Message message = WARN ATTR SYNTAX GENERALIZED TIME ILLEGAL TIME . get ( value , String . value Of ( e ) ) ; throw new Localized Illegal Argument Exception ( message , e ) ; } }
private static Generalized Time create Time ( final String value , final int year , final int month , final int day , final int hour , final int minute , final int second , final Time Zone tz ) { try { final Gregorian Calendar calendar = new Gregorian Calendar ( ) ; calendar . set Lenient ( BOOL ) ; calendar . set Time Zone ( tz ) ; calendar . set ( year , month , day , hour , minute , second ) ; calendar . set ( Calendar . MILLISECOND , NUM ) ; return new Generalized Time ( calendar , null , Long . MIN VALUE , value ) ; } catch ( final Exception e ) { final Localizable Message message = WARN ATTR SYNTAX GENERALIZED TIME ILLEGAL TIME . get ( value , String . value Of ( e ) ) ; throw new Localized Illegal Argument Exception ( message , e ) ; } }
@ Override public int startup New Worker ( int priority , String tcp Uri , String temporary Directory ) { startup New Worker ( priority ) ; return NUM ; }
@ Override public int startup New Worker ( int priority , String tcp Uri , String temporary Directory ) { startup New Worker ( priority ) ; return NUM ; }
@ Override public int startup New Worker ( int priority , String tcp Uri , String temporary Directory ) { startup New Worker ( priority ) ; return NUM ; }
@ Override public int startup New Worker ( int priority , String tcp Uri , String temporary Directory ) { startup New Worker ( priority ) ; return NUM ; }
@ Override public int startup New Worker ( int priority , String tcp Uri , String temporary Directory ) { startup New Worker ( priority ) ; return NUM ; }
@ Override public int startup New Worker ( int priority , String tcp Uri , String temporary Directory ) { startup New Worker ( priority ) ; return NUM ; }
@ Override public int startup New Worker ( int priority , String tcp Uri , String temporary Directory ) { startup New Worker ( priority ) ; return NUM ; }
@ Override public int startup New Worker ( int priority , String tcp Uri , String temporary Directory ) { startup New Worker ( priority ) ; return NUM ; }
@ Override public int startup New Worker ( int priority , String tcp Uri , String temporary Directory ) { startup New Worker ( priority ) ; return NUM ; }
@ Override public int startup New Worker ( int priority , String tcp Uri , String temporary Directory ) { startup New Worker ( priority ) ; return NUM ; }
public static void device Report Pressed ( String dev Name , Frame parent ) { J Text Area text = null ; J Scroll Pane scroll Pane = null ; text = new javax . swing . J Text Area ( NUM , NUM ) ; text . set Editable ( BOOL ) ; text . set Tab Size ( NUM ) ; search ( dev Name , text ) ; scroll Pane = new J Scroll Pane ( text ) ; make Dialog ( scroll Pane , null , parent , rbm . get String ( STRING ) ) ; }
private void send Composed Text ( ) { Attributed String as = new Attributed String ( buffer . to String ( ) ) ; as . add Attribute ( Text Attribute . INPUT METHOD HIGHLIGHT , Input Method Highlight . SELECTED RAW TEXT HIGHLIGHT ) ; context . dispatch Input Method Event ( Input Method Event . INPUT METHOD TEXT CHANGED , as . get Iterator ( ) , NUM , Text Hit Info . leading ( insertion Point ) , null ) ; }
public void try Obtain ( ) throws IO Exception { if ( file Lock != null && file Lock . is Valid ( ) ) { return ; } file Lock = file To Lock . try Lock ( ) ; }
public static String to JSON String ( Collection collection ) { final String Writer writer = new String Writer ( ) ; try { write JSON String ( collection , writer ) ; return writer . to String ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public static String to JSON String ( Collection collection ) { final String Writer writer = new String Writer ( ) ; try { write JSON String ( collection , writer ) ; return writer . to String ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public static String to JSON String ( Collection collection ) { final String Writer writer = new String Writer ( ) ; try { write JSON String ( collection , writer ) ; return writer . to String ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public void read design ( Object Input Stream p design ) throws Class Not Found Exception , IO Exception { r board = ( Routing Board ) p design . read Object ( ) ; r board . set transient item ( this ) ; itera settings = ( Itera Settings ) p design . read Object ( ) ; itera settings . set transient fields ( r board , actlog ) ; coordinate transform = ( Pla Coord Transform ) p design . read Object ( ) ; gdi context = ( Gdi Context ) p design . read Object ( ) ; gdi context . set transient field ( stat ) ; screen messages . show layer name ( itera settings . get layer ( ) ) ; }
public final boolean skip Any ( Char Set char Set , Char Sequence csq ) { int i = index ; int n = csq . length ( ) ; for ( ; ( i < n ) && char Set . contains ( csq . char At ( i ) ) ; i ++ ) { } if ( i == index ) return BOOL ; index = i ; return BOOL ; }
public final boolean skip Any ( Char Set char Set , Char Sequence csq ) { int i = index ; int n = csq . length ( ) ; for ( ; ( i < n ) && char Set . contains ( csq . char At ( i ) ) ; i ++ ) { } if ( i == index ) return BOOL ; index = i ; return BOOL ; }
public int index Of Segment ( Segment segment ) { return selected Segments . index Of ( segment ) ; }
void derive Confidence Value ( double base Count ) { if ( Utils . is Missing Value ( m confidence ) && ! Utils . is Missing Value ( base Count ) && base Count > NUM ) { m confidence = m record Count / base Count ; } }
public void remove ( Menu Component m ) { if ( m == null ) { return ; } synchronized ( get Tree Lock ( ) ) { if ( m == menu Bar ) { menu Bar = null ; Frame Peer peer = ( Frame Peer ) this . peer ; if ( peer != null ) { mb Management = BOOL ; invalidate If Valid ( ) ; peer . set Menu Bar ( null ) ; m . remove Notify ( ) ; } m . parent = null ; } else { super . remove ( m ) ; } } }
public String to String ( ) { String Buffer result = new String Buffer ( ) ; result . append ( STRING ) ; for ( int i = NUM ; i < chars . length ; i += NUM ) { if ( chars [ i ] == chars [ i + NUM ] ) { result . append ( STRING ) ; result . append ( Integer . to Hex String ( chars [ i ] ) ) ; } else { result . append ( STRING ) ; result . append ( Integer . to Hex String ( chars [ i ] ) ) ; result . append ( STRING ) ; result . append ( Integer . to Hex String ( chars [ i + NUM ] ) ) ; } } result . append ( STRING ) ; return result . to String ( ) ; }
public void add Listener ( final I Plugin Interface Listener listener ) { listeners . add Listener ( listener ) ; }
@ Override public void close ( ) { synchronized ( lock ) { if ( is Open ( ) ) { buf = null ; } } }
public void to Singleton String ( String Builder sb , boolean force Single ) { sb . append ( STRING ) ; for ( String step : steps ) { if ( step . char At ( NUM ) != STRING ) { sb . append ( STRING ) ; sb . append ( step ) ; if ( force Single ) sb . append ( STRING ) ; } } }
public void to Singleton String ( String Builder sb , boolean force Single ) { sb . append ( STRING ) ; for ( String step : steps ) { if ( step . char At ( NUM ) != STRING ) { sb . append ( STRING ) ; sb . append ( step ) ; if ( force Single ) sb . append ( STRING ) ; } } }
public void to Singleton String ( String Builder sb , boolean force Single ) { sb . append ( STRING ) ; for ( String step : steps ) { if ( step . char At ( NUM ) != STRING ) { sb . append ( STRING ) ; sb . append ( step ) ; if ( force Single ) sb . append ( STRING ) ; } } }
public D Vector 2 D ( int c1 , int c2 ) { default Capacity 2 = Math . max ( default Default Capacity 2 , c2 ) ; vector = new double [ Math . max ( default Capacity 1 , c1 ) ] [ default Capacity 2 ] ; sizes = new I Vector ( c1 ) ; }
public void add ( Weighted Observed Point observed ) { observations . add ( observed ) ; }
@ Override public Solr Info M Bean put ( String key , Solr Info M Bean info Bean ) { if ( server != null && info Bean != null ) { try { Object Name name = get Object Name ( key , info Bean ) ; if ( server . is Registered ( name ) ) server . unregister M Bean ( name ) ; Solr Dynamic M Bean mbean = new Solr Dynamic M Bean ( core Hash Code , info Bean , use Cached Stats Between Get M Bean Info Calls ) ; server . register M Bean ( mbean , name ) ; } catch ( Exception e ) { log . warn ( STRING + key , e ) ; } } return super . put ( key , info Bean ) ; }
@ Override public Solr Info M Bean put ( String key , Solr Info M Bean info Bean ) { if ( server != null && info Bean != null ) { try { Object Name name = get Object Name ( key , info Bean ) ; if ( server . is Registered ( name ) ) server . unregister M Bean ( name ) ; Solr Dynamic M Bean mbean = new Solr Dynamic M Bean ( core Hash Code , info Bean , use Cached Stats Between Get M Bean Info Calls ) ; server . register M Bean ( mbean , name ) ; } catch ( Exception e ) { log . warn ( STRING + key , e ) ; } } return super . put ( key , info Bean ) ; }
public Concurrent Linked Hash Map Pro ( Map < ? extends K , ? extends V > m ) { this ( Math . max ( ( int ) ( m . size ( ) / DEFAULT LOAD FACTOR ) + NUM , DEFAULT INITIAL CAPACITY ) , DEFAULT LOAD FACTOR , DEFAULT CONCURRENCY LEVEL , UNLIMITED SIZE , new FIFO Policy ( ) ) ; put All ( m ) ; }
@ Override public boolean communication Initiated ( ) { return bugs Populated . get Count ( ) == NUM && communication Initiated && network Client . ready ( ) ; }
protected ES Optimization create Optimizer ( Random Generator random ) throws Undefined Parameter Error { return new ES Parameter Optimization ( this , operators . length , ES Optimization . INIT TYPE RANDOM , get Parameter As Int ( PARAMETER MAX GENERATIONS ) , get Parameter As Int ( PARAMETER GENERATIONS WITHOUT IMPROVAL ) , get Parameter As Int ( PARAMETER POPULATION SIZE ) , get Parameter As Int ( PARAMETER SELECTION TYPE ) , get Parameter As Double ( PARAMETER TOURNAMENT FRACTION ) , get Parameter As Boolean ( PARAMETER KEEP BEST ) , get Parameter As Int ( PARAMETER MUTATION TYPE ) , get Parameter As Double ( PARAMETER CROSSOVER PROB ) , get Parameter As Boolean ( PARAMETER SHOW CONVERGENCE PLOT ) , random , this ) ; }
private int find Or Create Heap Idx ( int cmid ) { if ( cmid >= map . length ) { grow Heap Map ( cmid ) ; } int index = map [ cmid ] ; if ( index == NUM ) { index = next Index ++ ; if ( index >= counts . length ) { grow Heap ( ) ; } counts [ index ] = NUM ; cmids [ index ] = cmid ; map [ cmid ] = index ; } return index ; }
private int find Or Create Heap Idx ( int cmid ) { if ( cmid >= map . length ) { grow Heap Map ( cmid ) ; } int index = map [ cmid ] ; if ( index == NUM ) { index = next Index ++ ; if ( index >= counts . length ) { grow Heap ( ) ; } counts [ index ] = NUM ; cmids [ index ] = cmid ; map [ cmid ] = index ; } return index ; }
private int find Or Create Heap Idx ( int cmid ) { if ( cmid >= map . length ) { grow Heap Map ( cmid ) ; } int index = map [ cmid ] ; if ( index == NUM ) { index = next Index ++ ; if ( index >= counts . length ) { grow Heap ( ) ; } counts [ index ] = NUM ; cmids [ index ] = cmid ; map [ cmid ] = index ; } return index ; }
private int find Or Create Heap Idx ( int cmid ) { if ( cmid >= map . length ) { grow Heap Map ( cmid ) ; } int index = map [ cmid ] ; if ( index == NUM ) { index = next Index ++ ; if ( index >= counts . length ) { grow Heap ( ) ; } counts [ index ] = NUM ; cmids [ index ] = cmid ; map [ cmid ] = index ; } return index ; }
private int find Or Create Heap Idx ( int cmid ) { if ( cmid >= map . length ) { grow Heap Map ( cmid ) ; } int index = map [ cmid ] ; if ( index == NUM ) { index = next Index ++ ; if ( index >= counts . length ) { grow Heap ( ) ; } counts [ index ] = NUM ; cmids [ index ] = cmid ; map [ cmid ] = index ; } return index ; }
private int find Or Create Heap Idx ( int cmid ) { if ( cmid >= map . length ) { grow Heap Map ( cmid ) ; } int index = map [ cmid ] ; if ( index == NUM ) { index = next Index ++ ; if ( index >= counts . length ) { grow Heap ( ) ; } counts [ index ] = NUM ; cmids [ index ] = cmid ; map [ cmid ] = index ; } return index ; }
@ Log Message Doc ( level = STRING , message = STRING , explanation = STRING + STRING , recommendation = Log Message Doc . REPORT CONTROLLER BUG ) public void queue Hint ( String store Name , Byte Array key , Versioned < byte [ ] > value ) { try { Hint Key hk = new Hint Key ( store Name , key ) ; hint Lock . lock ( ) ; try { boolean needed = ! hints . contains Key ( hk ) ; needed &= hints . doput ( hk , value ) ; if ( needed ) { hint Queue . add ( hk ) ; hints Available . signal ( ) ; } } finally { hint Lock . unlock ( ) ; } } catch ( Sync Exception e ) { logger . error ( STRING + store Name , e ) ; } }
@ Override public String to String ( ) { String Builder output = new String Builder ( ) ; if ( m Test Class != null ) { output . append ( m Test Class ) ; output . append ( STRING ) ; } if ( m Test Name != null ) { output . append ( m Test Name ) ; } if ( output . length ( ) > NUM ) { return output . to String ( ) ; } return STRING ; }
private static String contents Of File ( Weak Reference < Context > weak Context , String filename ) { Context context = null ; if ( weak Context != null ) { context = weak Context . get ( ) ; if ( context != null ) { String Builder contents = new String Builder ( ) ; Buffered Reader reader = null ; try { File file = new File ( filename ) ; reader = new Buffered Reader ( new File Reader ( file ) ) ; String line = null ; while ( ( line = reader . read Line ( ) ) != null ) { contents . append ( line ) ; contents . append ( System . get Property ( STRING ) ) ; } } catch ( File Not Found Exception e ) { } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } finally { IO Utils . close Quietly ( reader ) ; } return contents . to String ( ) ; } } return null ; }
public static Optional < String > create Input Dialog ( final Window owner , final String title , final String label ) { final Text Input Dialog dialog = new Text Input Dialog ( ) ; dialog . set Title ( title ) ; dialog . set Header Text ( null ) ; dialog . set Content Text ( label ) ; dialog . init Owner ( owner ) ; return dialog . show And Wait ( ) ; }
public void register ( Abstract Automaton a ) { synchronized ( automats ) { automats . add ( a ) ; } notify ( STRING , null , Integer . value Of ( index Of ( a ) ) ) ; }
public void register ( Abstract Automaton a ) { synchronized ( automats ) { automats . add ( a ) ; } notify ( STRING , null , Integer . value Of ( index Of ( a ) ) ) ; }
public List < Acronym Expansion > do In Background ( String acronym ) { try { List < Acronym Expansion > long Forms = m Acronym Cache . get ( acronym ) ; if ( long Forms != null && ! long Forms . is Empty ( ) ) { Log . v ( TAG , acronym + STRING ) ; return long Forms ; } else { Log . v ( TAG , acronym + STRING ) ; Acronym Data result = null ; long Forms = result . get Lfs ( ) ; m Acronym Cache . put ( result . get Sf ( ) , long Forms ) ; return long Forms ; } } catch ( Exception e ) { Log . v ( TAG , STRING + e ) ; return null ; } }
public List < Acronym Expansion > do In Background ( String acronym ) { try { List < Acronym Expansion > long Forms = m Acronym Cache . get ( acronym ) ; if ( long Forms != null && ! long Forms . is Empty ( ) ) { Log . v ( TAG , acronym + STRING ) ; return long Forms ; } else { Log . v ( TAG , acronym + STRING ) ; Acronym Data result = null ; long Forms = result . get Lfs ( ) ; m Acronym Cache . put ( result . get Sf ( ) , long Forms ) ; return long Forms ; } } catch ( Exception e ) { Log . v ( TAG , STRING + e ) ; return null ; } }
public List < Acronym Expansion > do In Background ( String acronym ) { try { List < Acronym Expansion > long Forms = m Acronym Cache . get ( acronym ) ; if ( long Forms != null && ! long Forms . is Empty ( ) ) { Log . v ( TAG , acronym + STRING ) ; return long Forms ; } else { Log . v ( TAG , acronym + STRING ) ; Acronym Data result = null ; long Forms = result . get Lfs ( ) ; m Acronym Cache . put ( result . get Sf ( ) , long Forms ) ; return long Forms ; } } catch ( Exception e ) { Log . v ( TAG , STRING + e ) ; return null ; } }
public List < Acronym Expansion > do In Background ( String acronym ) { try { List < Acronym Expansion > long Forms = m Acronym Cache . get ( acronym ) ; if ( long Forms != null && ! long Forms . is Empty ( ) ) { Log . v ( TAG , acronym + STRING ) ; return long Forms ; } else { Log . v ( TAG , acronym + STRING ) ; Acronym Data result = null ; long Forms = result . get Lfs ( ) ; m Acronym Cache . put ( result . get Sf ( ) , long Forms ) ; return long Forms ; } } catch ( Exception e ) { Log . v ( TAG , STRING + e ) ; return null ; } }
public List < Acronym Expansion > do In Background ( String acronym ) { try { List < Acronym Expansion > long Forms = m Acronym Cache . get ( acronym ) ; if ( long Forms != null && ! long Forms . is Empty ( ) ) { Log . v ( TAG , acronym + STRING ) ; return long Forms ; } else { Log . v ( TAG , acronym + STRING ) ; Acronym Data result = null ; long Forms = result . get Lfs ( ) ; m Acronym Cache . put ( result . get Sf ( ) , long Forms ) ; return long Forms ; } } catch ( Exception e ) { Log . v ( TAG , STRING + e ) ; return null ; } }
public List < Acronym Expansion > do In Background ( String acronym ) { try { List < Acronym Expansion > long Forms = m Acronym Cache . get ( acronym ) ; if ( long Forms != null && ! long Forms . is Empty ( ) ) { Log . v ( TAG , acronym + STRING ) ; return long Forms ; } else { Log . v ( TAG , acronym + STRING ) ; Acronym Data result = null ; long Forms = result . get Lfs ( ) ; m Acronym Cache . put ( result . get Sf ( ) , long Forms ) ; return long Forms ; } } catch ( Exception e ) { Log . v ( TAG , STRING + e ) ; return null ; } }
public List < Acronym Expansion > do In Background ( String acronym ) { try { List < Acronym Expansion > long Forms = m Acronym Cache . get ( acronym ) ; if ( long Forms != null && ! long Forms . is Empty ( ) ) { Log . v ( TAG , acronym + STRING ) ; return long Forms ; } else { Log . v ( TAG , acronym + STRING ) ; Acronym Data result = null ; long Forms = result . get Lfs ( ) ; m Acronym Cache . put ( result . get Sf ( ) , long Forms ) ; return long Forms ; } } catch ( Exception e ) { Log . v ( TAG , STRING + e ) ; return null ; } }
public List < Acronym Expansion > do In Background ( String acronym ) { try { List < Acronym Expansion > long Forms = m Acronym Cache . get ( acronym ) ; if ( long Forms != null && ! long Forms . is Empty ( ) ) { Log . v ( TAG , acronym + STRING ) ; return long Forms ; } else { Log . v ( TAG , acronym + STRING ) ; Acronym Data result = null ; long Forms = result . get Lfs ( ) ; m Acronym Cache . put ( result . get Sf ( ) , long Forms ) ; return long Forms ; } } catch ( Exception e ) { Log . v ( TAG , STRING + e ) ; return null ; } }
public int size ( ) { return shards . size ( ) ; }
private List < User Namespace Authorization > create User Namespace Authorizations From Entities ( List < User Namespace Authorization Entity > user Namespace Authorization Entities ) { List < User Namespace Authorization > user Namespace Authorizations = new Array List < > ( ) ; for ( User Namespace Authorization Entity user Namespace Authorization Entity : user Namespace Authorization Entities ) { user Namespace Authorizations . add ( create User Namespace Authorization From Entity ( user Namespace Authorization Entity ) ) ; } return user Namespace Authorizations ; }
public void serialize As Field ( Object bean , Json Generator jgen , Serializer Provider prov ) throws Exception { Object value = get ( bean ) ; if ( value == null ) { if ( ! suppress Nulls ) { jgen . write Field Name ( name ) ; prov . default Serialize Null ( jgen ) ; } return ; } if ( value == bean ) { report Self Reference ( bean ) ; } if ( suppressable Value != null && suppressable Value . equals ( value ) ) { return ; } Json Serializer < Object > ser = serializer ; if ( ser == null ) { Class < ? > cls = value . get Class ( ) ; Property Serializer Map map = dynamic Serializers ; ser = map . serializer For ( cls ) ; if ( ser == null ) { ser = find And Add Dynamic ( map , cls , prov ) ; } } jgen . write Field Name ( name ) ; if ( type Serializer == null ) { ser . serialize ( value , jgen , prov ) ; } else { ser . serialize With Type ( value , jgen , prov , type Serializer ) ; } }
public void serialize As Field ( Object bean , Json Generator jgen , Serializer Provider prov ) throws Exception { Object value = get ( bean ) ; if ( value == null ) { if ( ! suppress Nulls ) { jgen . write Field Name ( name ) ; prov . default Serialize Null ( jgen ) ; } return ; } if ( value == bean ) { report Self Reference ( bean ) ; } if ( suppressable Value != null && suppressable Value . equals ( value ) ) { return ; } Json Serializer < Object > ser = serializer ; if ( ser == null ) { Class < ? > cls = value . get Class ( ) ; Property Serializer Map map = dynamic Serializers ; ser = map . serializer For ( cls ) ; if ( ser == null ) { ser = find And Add Dynamic ( map , cls , prov ) ; } } jgen . write Field Name ( name ) ; if ( type Serializer == null ) { ser . serialize ( value , jgen , prov ) ; } else { ser . serialize With Type ( value , jgen , prov , type Serializer ) ; } }
private Map load Binary Lexicon ( Input Stream is , int estimated Size ) throws IO Exception { Data Input Stream dis = new Data Input Stream ( new Buffered Input Stream ( is ) ) ; int size = NUM ; int num Entries = NUM ; List phoneme List = new Array List ( ) ; Map lexicon = new Linked Hash Map ( ) ; int magic ; try { if ( dis . read Int ( ) != MAGIC ) { throw new Error ( STRING ) ; } } catch ( IO Exception e ) { throw e ; } if ( dis . read Int ( ) != VERSION ) { throw new Error ( STRING ) ; } size = dis . read Int ( ) ; for ( int i = NUM ; i < size ; i ++ ) { String phoneme = get String ( dis ) ; phoneme List . add ( phoneme ) ; } num Entries = dis . read Int ( ) ; for ( int i = NUM ; i < num Entries ; i ++ ) { String word And Pos = get String ( dis ) ; String pos = Character . to String ( word And Pos . char At ( word And Pos . length ( ) - NUM ) ) ; if ( ! parts Of Speech . contains ( pos ) ) { parts Of Speech . add ( pos ) ; } int num Phonemes = dis . read Byte ( ) ; String [ ] phonemes = new String [ num Phonemes ] ; for ( int j = NUM ; j < num Phonemes ; j ++ ) { phonemes [ j ] = ( String ) phoneme List . get ( dis . read Byte ( ) ) ; } lexicon . put ( word And Pos , phonemes ) ; } dis . close ( ) ; return lexicon ; }
public LDIF Entry Reader ( final String ... ldif Lines ) { super ( Arrays . as List ( ldif Lines ) ) ; }
public LDIF Entry Reader ( final String ... ldif Lines ) { super ( Arrays . as List ( ldif Lines ) ) ; }
public C Goto Module ( final Window parent , final C Debug Perspective Model debug Perspective Model , final Memory Module module ) { super ( String . format ( STRING , module . get Name ( ) ) ) ; m parent = parent ; m debug Perspective Model = debug Perspective Model ; m module = module ; }
void save Resource Index ( String resource Type , String index XML ) throws Policy Exception , SSO Exception { Map new Attrs = new Hash Map ( ) ; Set new Set = new Hash Set ( ) ; new Set . add ( index XML ) ; new Attrs . put ( RESOURCES XML , new Set ) ; Service Config resources = get Resources Service Config ( BOOL ) ; if ( resources != null ) { Service Config leaf Config = null ; try { leaf Config = resources . get Sub Config ( resource Type ) ; if ( leaf Config == null ) { resources . add Sub Config ( resource Type , Policy Manager . RESOURCES POLICY ID , NUM , new Attrs ) ; } else { leaf Config . set Attributes ( new Attrs ) ; } } catch ( SMS Exception e1 ) { throw new Policy Exception ( e1 ) ; } } }
private boolean ig Contains Initiators ( Storage System storage , CIM Instance ig Instance , List < String > initiators In Db ) { CIM Object Path ig Path = ig Instance . get Object Path ( ) ; Closeable Iterator < CIM Instance > initiators For Ig = null ; try { initiators For Ig = helper . get Associator Instances ( storage , ig Path , null , Smis Constants . CP SE STORAGE HARDWARE ID , null , null , Smis Constants . PS STORAGE ID ) ; if ( initiators For Ig != null ) { while ( initiators For Ig . has Next ( ) ) { CIM Instance initiator Instance = initiators For Ig . next ( ) ; String initiator Port = CIM Property Factory . get Property Value ( initiator Instance , Smis Constants . CP STORAGE ID ) ; log . info ( String . format ( STRING , ig Path , initiator Port ) ) ; if ( initiators In Db . contains ( initiator Port ) ) { return BOOL ; } } } } catch ( Exception e ) { } finally { if ( initiators For Ig != null ) { initiators For Ig . close ( ) ; } } return BOOL ; }
private void populate Db Options ( String db Product , Element db Options Element , Map < String , String > db Options Map ) { Node List db Options = db Options Element . get Elements By Tag Name ( STRING ) ; for ( int i = NUM ; i < db Options . get Length ( ) ; i ++ ) { Element db Option = ( Element ) db Options . item ( i ) ; if ( ! db Product . equals Ignore Case ( db Option . get Attribute ( STRING ) ) ) { continue ; } db Options Map . put ( db Option . get Attribute ( STRING ) , db Option . get Attribute ( STRING ) ) ; } }
public < Annotation Type extends Annotation > void register ( Method Binder < Annotation Type > method Binder ) { Set < Annotated Method < Annotation Type > > annotated Methods = Annotated Methods . get ( method Binder . get Annotation Class ( ) , annotated Type ) ; if ( ! annotated Methods . is Empty ( ) ) { object Binders . add ( new Annotated Method Binder < > ( method Binder , annotated Methods ) ) ; } }
public < Annotation Type extends Annotation > void register ( Method Binder < Annotation Type > method Binder ) { Set < Annotated Method < Annotation Type > > annotated Methods = Annotated Methods . get ( method Binder . get Annotation Class ( ) , annotated Type ) ; if ( ! annotated Methods . is Empty ( ) ) { object Binders . add ( new Annotated Method Binder < > ( method Binder , annotated Methods ) ) ; } }
public void tag Swap And Copy File ( ) throws Exception { Buffered Reader br = null ; Buffered Writer bw = null ; try { File Input Stream fi = new File Input Stream ( get Source File ( ) ) ; Input Stream Reader ir = new Input Stream Reader ( fi , DEFAULT ENCODING ) ; br = new Buffered Reader ( ir ) ; File Output Stream fo = new File Output Stream ( get Destination File ( ) ) ; Output Stream Writer ow = new Output Stream Writer ( fo , DEFAULT ENCODING ) ; bw = new Buffered Writer ( ow ) ; String Buffer token Queue = new String Buffer ( NUM ) ; String Buffer result Data = new String Buffer ( ) ; String line Data = null ; while ( ( line Data = br . read Line ( ) ) != null ) { String transformed Line = scan And Replace Tokens ( line Data , result Data , token Queue ) ; bw . write ( transformed Line ) ; } } catch ( Exception e ) { throw e ; } finally { if ( br != null ) { try { br . close ( ) ; } catch ( IO Exception ie ) { Debug . log ( STRING + STRING , ie ) ; } } if ( bw != null ) { try { bw . flush ( ) ; bw . close ( ) ; } catch ( IO Exception ie ) { Debug . log ( STRING + STRING , ie ) ; } } } }
private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; service ID = new Service ID ( in ) ; }
private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; service ID = new Service ID ( in ) ; }
@ Bean Local Container Entity Manager Factory Bean entity Manager Factory ( Data Source data Source , Environment env ) { Local Container Entity Manager Factory Bean entity Manager Factory Bean = new Local Container Entity Manager Factory Bean ( ) ; entity Manager Factory Bean . set Data Source ( data Source ) ; entity Manager Factory Bean . set Jpa Vendor Adapter ( new Hibernate Jpa Vendor Adapter ( ) ) ; entity Manager Factory Bean . set Packages To Scan ( ENTITY PACKAGES ) ; Properties jpa Properties = new Properties ( ) ; jpa Properties . put ( PROPERTY NAME HIBERNATE DIALECT , env . get Required Property ( PROPERTY NAME HIBERNATE DIALECT ) ) ; jpa Properties . put ( PROPERTY NAME HIBERNATE HBM 2 DDL AUTO , env . get Required Property ( PROPERTY NAME HIBERNATE HBM 2 DDL AUTO ) ) ; jpa Properties . put ( PROPERTY NAME HIBERNATE NAMING STRATEGY , env . get Required Property ( PROPERTY NAME HIBERNATE NAMING STRATEGY ) ) ; jpa Properties . put ( PROPERTY NAME HIBERNATE SHOW SQL , env . get Required Property ( PROPERTY NAME HIBERNATE SHOW SQL ) ) ; jpa Properties . put ( PROPERTY NAME HIBERNATE FORMAT SQL , env . get Required Property ( PROPERTY NAME HIBERNATE FORMAT SQL ) ) ; entity Manager Factory Bean . set Jpa Properties ( jpa Properties ) ; return entity Manager Factory Bean ; }
@ Bean Local Container Entity Manager Factory Bean entity Manager Factory ( Data Source data Source , Environment env ) { Local Container Entity Manager Factory Bean entity Manager Factory Bean = new Local Container Entity Manager Factory Bean ( ) ; entity Manager Factory Bean . set Data Source ( data Source ) ; entity Manager Factory Bean . set Jpa Vendor Adapter ( new Hibernate Jpa Vendor Adapter ( ) ) ; entity Manager Factory Bean . set Packages To Scan ( ENTITY PACKAGES ) ; Properties jpa Properties = new Properties ( ) ; jpa Properties . put ( PROPERTY NAME HIBERNATE DIALECT , env . get Required Property ( PROPERTY NAME HIBERNATE DIALECT ) ) ; jpa Properties . put ( PROPERTY NAME HIBERNATE HBM 2 DDL AUTO , env . get Required Property ( PROPERTY NAME HIBERNATE HBM 2 DDL AUTO ) ) ; jpa Properties . put ( PROPERTY NAME HIBERNATE NAMING STRATEGY , env . get Required Property ( PROPERTY NAME HIBERNATE NAMING STRATEGY ) ) ; jpa Properties . put ( PROPERTY NAME HIBERNATE SHOW SQL , env . get Required Property ( PROPERTY NAME HIBERNATE SHOW SQL ) ) ; jpa Properties . put ( PROPERTY NAME HIBERNATE FORMAT SQL , env . get Required Property ( PROPERTY NAME HIBERNATE FORMAT SQL ) ) ; entity Manager Factory Bean . set Jpa Properties ( jpa Properties ) ; return entity Manager Factory Bean ; }
@ Override public void end Of Stream ( ) throws Ade Exception , Ade Flow Exception { for ( Entry < String , Perodicity Bounder > last : m last Seen . entry Set ( ) ) { final Perodicity Bounder pb = last . get Value ( ) ; pb . train ( last . get Key ( ) ) ; } m trained = BOOL ; }
@ Override public void end Of Stream ( ) throws Ade Exception , Ade Flow Exception { for ( Entry < String , Perodicity Bounder > last : m last Seen . entry Set ( ) ) { final Perodicity Bounder pb = last . get Value ( ) ; pb . train ( last . get Key ( ) ) ; } m trained = BOOL ; }
@ Override public void end Of Stream ( ) throws Ade Exception , Ade Flow Exception { for ( Entry < String , Perodicity Bounder > last : m last Seen . entry Set ( ) ) { final Perodicity Bounder pb = last . get Value ( ) ; pb . train ( last . get Key ( ) ) ; } m trained = BOOL ; }
void copy Value ( int [ ] val ) { int len = val . length ; if ( value . length < len ) value = new int [ len ] ; System . arraycopy ( val , NUM , value , NUM , len ) ; int Len = len ; offset = NUM ; }
void copy Value ( int [ ] val ) { int len = val . length ; if ( value . length < len ) value = new int [ len ] ; System . arraycopy ( val , NUM , value , NUM , len ) ; int Len = len ; offset = NUM ; }
private int compute Alpha ( final IS Item item ) { return ( int ) ( NUM - NUM * Math . abs ( item . getz Position ( ) ) ) ; }
public Builder add Photo ( Photo photo ) { photos . add ( photo ) ; return this ; }
public Builder add Photo ( Photo photo ) { photos . add ( photo ) ; return this ; }
public long time Since Start ( ) { long current Time = System . current Time Millis ( ) ; return current Time - start Time ; }
public static void start Services ( Service Host host , Class ... services ) throws Instantiation Exception , Illegal Access Exception { check Argument ( services != null , STRING ) ; for ( Class service : services ) { start Service ( host , service ) ; } }
public int hash Code ( ) { int result = NUM ; if ( is Destroyed ( ) ) { return result ; } result = NUM * result + Arrays . hash Code ( get Encoded ( ) ) ; result = NUM * result + get Key Type ( ) ; if ( principal != null ) { result = NUM * result + principal . hash Code ( ) ; } return result * NUM + version Num ; }
public Abstract Surface Object ( ) { this . visible = BOOL ; this . unique Id = next Unique Id ( ) ; this . last Modified Time = System . current Time Millis ( ) ; this . enable Batch Picking = BOOL ; }
public Abstract Surface Object ( ) { this . visible = BOOL ; this . unique Id = next Unique Id ( ) ; this . last Modified Time = System . current Time Millis ( ) ; this . enable Batch Picking = BOOL ; }
public Abstract Surface Object ( ) { this . visible = BOOL ; this . unique Id = next Unique Id ( ) ; this . last Modified Time = System . current Time Millis ( ) ; this . enable Batch Picking = BOOL ; }
int size ( ) { return Integer . bit Count ( set ) ; }
int size ( ) { return Integer . bit Count ( set ) ; }
int size ( ) { return Integer . bit Count ( set ) ; }
@ Override public double evaluate Attribute ( int attribute ) throws Exception { return m weights [ attribute ] ; }
@ Override public double evaluate Attribute ( int attribute ) throws Exception { return m weights [ attribute ] ; }
@ Override public double evaluate Attribute ( int attribute ) throws Exception { return m weights [ attribute ] ; }
@ Override public double evaluate Attribute ( int attribute ) throws Exception { return m weights [ attribute ] ; }
public static long [ ] append Long ( long [ ] cur , long val ) { if ( cur == null ) { return new long [ ] { val } ; } final int N = cur . length ; for ( int i = NUM ; i < N ; i ++ ) { if ( cur [ i ] == val ) { return cur ; } } long [ ] ret = new long [ N + NUM ] ; System . arraycopy ( cur , NUM , ret , NUM , N ) ; ret [ N ] = val ; return ret ; }
public static long [ ] append Long ( long [ ] cur , long val ) { if ( cur == null ) { return new long [ ] { val } ; } final int N = cur . length ; for ( int i = NUM ; i < N ; i ++ ) { if ( cur [ i ] == val ) { return cur ; } } long [ ] ret = new long [ N + NUM ] ; System . arraycopy ( cur , NUM , ret , NUM , N ) ; ret [ N ] = val ; return ret ; }
public static long [ ] append Long ( long [ ] cur , long val ) { if ( cur == null ) { return new long [ ] { val } ; } final int N = cur . length ; for ( int i = NUM ; i < N ; i ++ ) { if ( cur [ i ] == val ) { return cur ; } } long [ ] ret = new long [ N + NUM ] ; System . arraycopy ( cur , NUM , ret , NUM , N ) ; ret [ N ] = val ; return ret ; }
private static void add Entries For Infrequent Blocks ( IR ir , Live Analysis live , Hash Map < Basic Block Pair , Hash Set < Register > > result ) { for ( Enumeration < Basic Block > e = ir . get Basic Blocks ( ) ; e . has More Elements ( ) ; ) { Basic Block bb = e . next Element ( ) ; boolean bb Infrequent = bb . get Infrequent ( ) ; for ( Enumeration < Basic Block > out = bb . get Normal Out ( ) ; out . has More Elements ( ) ; ) { Basic Block dest = out . next Element ( ) ; boolean dest Infrequent = dest . get Infrequent ( ) ; if ( bb Infrequent ^ dest Infrequent ) { Hash Set < Register > live Registers = live . get Live Registers On Edge ( bb , dest ) ; for ( Register r : live Registers ) { if ( r . is Symbolic ( ) ) { Hash Set < Register > s = find Or Create Split Set ( result , bb , dest ) ; s . add ( r ) ; } } } } } }
private static void add Entries For Infrequent Blocks ( IR ir , Live Analysis live , Hash Map < Basic Block Pair , Hash Set < Register > > result ) { for ( Enumeration < Basic Block > e = ir . get Basic Blocks ( ) ; e . has More Elements ( ) ; ) { Basic Block bb = e . next Element ( ) ; boolean bb Infrequent = bb . get Infrequent ( ) ; for ( Enumeration < Basic Block > out = bb . get Normal Out ( ) ; out . has More Elements ( ) ; ) { Basic Block dest = out . next Element ( ) ; boolean dest Infrequent = dest . get Infrequent ( ) ; if ( bb Infrequent ^ dest Infrequent ) { Hash Set < Register > live Registers = live . get Live Registers On Edge ( bb , dest ) ; for ( Register r : live Registers ) { if ( r . is Symbolic ( ) ) { Hash Set < Register > s = find Or Create Split Set ( result , bb , dest ) ; s . add ( r ) ; } } } } } }
public boolean remove ( String url , Web Page page ) throws Indexing Exception { for ( Index Cleaning Filter indexcleaning Filter : indexcleaning Filters ) { if ( indexcleaning Filter . remove ( url , page ) ) { return BOOL ; } } return BOOL ; }
private void delete Service ( Svc Reg reg , long now ) { Item item = reg . item ; generate Events ( item , null , now ) ; service By ID . remove ( item . service ID ) ; service By Time . remove ( reg ) ; delete Service From Types ( item . service Type , reg ) ; Entry Rep [ ] entries = item . attribute Sets ; for ( int i = entries . length ; -- i >= NUM ; ) { delete Attrs ( reg , entries [ i ] , BOOL ) ; } compute Max Leases ( ) ; }
public static < T > T template For ( final Class < T > mixin Type , Association < ? > association ) { Null Argument Exception . validate Not Null ( STRING , mixin Type ) ; Null Argument Exception . validate Not Null ( STRING , association ) ; return mixin Type . cast ( Proxy . new Proxy Instance ( mixin Type . get Class Loader ( ) , array ( mixin Type ) , new Template Handler < T > ( null , association ( association ) , null , null ) ) ) ; }
public static < T > T template For ( final Class < T > mixin Type , Association < ? > association ) { Null Argument Exception . validate Not Null ( STRING , mixin Type ) ; Null Argument Exception . validate Not Null ( STRING , association ) ; return mixin Type . cast ( Proxy . new Proxy Instance ( mixin Type . get Class Loader ( ) , array ( mixin Type ) , new Template Handler < T > ( null , association ( association ) , null , null ) ) ) ; }
public static < T > T template For ( final Class < T > mixin Type , Association < ? > association ) { Null Argument Exception . validate Not Null ( STRING , mixin Type ) ; Null Argument Exception . validate Not Null ( STRING , association ) ; return mixin Type . cast ( Proxy . new Proxy Instance ( mixin Type . get Class Loader ( ) , array ( mixin Type ) , new Template Handler < T > ( null , association ( association ) , null , null ) ) ) ; }
protected void add Tasks For Volumes And C Gs ( Db Client db Client , List < Volume > add Vols , List < Volume > remove Vols , Set < URI > remove Volume C Gs , String task Id , Task List task List ) { if ( add Vols != null && ! add Vols . is Empty ( ) ) { for ( Volume vol : add Vols ) { add Volume Task ( db Client , vol , task List , task Id , Resource Operation Type Enum . UPDATE VOLUME GROUP ) ; } } if ( remove Vols != null && ! remove Vols . is Empty ( ) ) { for ( Volume vol : remove Vols ) { add Volume Task ( db Client , vol , task List , task Id , Resource Operation Type Enum . UPDATE VOLUME GROUP ) ; } } if ( remove Volume C Gs != null && ! remove Volume C Gs . is Empty ( ) ) { for ( URI cg : remove Volume C Gs ) { add Consistency Group Task ( db Client , cg , task List , task Id , Resource Operation Type Enum . UPDATE VOLUME GROUP ) ; } } }
public void update Drives Cache ( ) { if ( has World Obj ( ) && world Obj . is Remote ) return ; drives . clear ( ) ; prototypes . clear ( ) ; for ( Tile Entity Drive Bay tedb : drive Bays ) { if ( tedb . is Invalid ( ) ) continue ; for ( Item Stack is : tedb ) { drives . add ( is ) ; Item Drive id = ( Item Drive ) is . get Item ( ) ; prototypes . add All ( id . get Prototypes ( is ) ) ; } } Collections . sort ( drives , new Drive Comparator ( ) ) ; }
private Synapse Adjustment Panel ( final Network Panel network Panel , final List < Synapse > synapses ) { this . network Panel = network Panel ; this . synapses = synapses ; if ( synapses . size ( ) == NUM ) { return ; } set Layout ( new Grid Bag Layout ( ) ) ; extract Weight Values ( synapses ) ; initialize Layout ( ) ; }
public Mail Message add Recipient To ( String address ) { if ( address != null ) { to . add ( address ) ; } return this ; }
public Mail Message add Recipient To ( String address ) { if ( address != null ) { to . add ( address ) ; } return this ; }
private void polygonize ( ) { if ( poly List != null ) return ; poly List = new Array List ( ) ; if ( graph == null ) return ; dangles = graph . delete Dangles ( ) ; cut Edges = graph . delete Cut Edges ( ) ; List edge Ring List = graph . get Edge Rings ( ) ; List valid Edge Ring List = new Array List ( ) ; invalid Ring Lines = new Array List ( ) ; if ( is Checking Rings Valid ) { find Valid Rings ( edge Ring List , valid Edge Ring List , invalid Ring Lines ) ; } else { valid Edge Ring List = edge Ring List ; } find Shells And Holes ( valid Edge Ring List ) ; assign Holes To Shells ( hole List , shell List ) ; Collections . sort ( shell List , new Edge Ring . Envelope Comparator ( ) ) ; boolean include All = BOOL ; if ( extract Only Polygonal ) { find Disjoint Shells ( shell List ) ; include All = BOOL ; } poly List = extract Polygons ( shell List , include All ) ; }
private boolean continue After Accept Failure ( Throwable t ) { RMI Failure Handler fh = RMI Socket Factory . get Failure Handler ( ) ; if ( fh != null ) { return fh . failure ( t instanceof Exception ? ( Exception ) t : new Invocation Target Exception ( t ) ) ; } else { throttle Loop On Exception ( ) ; return BOOL ; } }
private boolean continue After Accept Failure ( Throwable t ) { RMI Failure Handler fh = RMI Socket Factory . get Failure Handler ( ) ; if ( fh != null ) { return fh . failure ( t instanceof Exception ? ( Exception ) t : new Invocation Target Exception ( t ) ) ; } else { throttle Loop On Exception ( ) ; return BOOL ; } }
public void test Serialization ( ) throws Exception { Object target Object = get Target Object ( ) ; for ( int i = NUM ; i < get Versions ( ) . length ; i ++ ) { String version = get Versions ( ) [ i ] ; verify Match ( target Object , deserialize ( version , target Object . get Class ( ) ) ) ; } }
public void test Serialization ( ) throws Exception { Object target Object = get Target Object ( ) ; for ( int i = NUM ; i < get Versions ( ) . length ; i ++ ) { String version = get Versions ( ) [ i ] ; verify Match ( target Object , deserialize ( version , target Object . get Class ( ) ) ) ; } }
public boolean is Defending ( ) { return ( is Being Attacked ( ) && ( System . current Time Millis ( ) - combat Icon Time < NUM * TURN LENGTH ) ) ; }
public boolean is Defending ( ) { return ( is Being Attacked ( ) && ( System . current Time Millis ( ) - combat Icon Time < NUM * TURN LENGTH ) ) ; }
public static void write ( OM Rect rect , Link link , Link Properties props ) throws IO Exception { switch ( rect . get Render Type ( ) ) { case OM Rect . RENDERTYPE LATLON : Link Rectangle . write ( ( float ) rect . get North Lat ( ) , ( float ) rect . get West Lon ( ) , ( float ) rect . get South Lat ( ) , ( float ) rect . get East Lon ( ) , rect . get Line Type ( ) , props , link . dos ) ; break ; case OM Rect . RENDERTYPE XY : Link Rectangle . write ( rect . get Left ( ) , rect . get Top ( ) , rect . get Right ( ) , rect . get Bottom ( ) , props , link . dos ) ; break ; case OM Rect . RENDERTYPE OFFSET : Link Rectangle . write ( ( float ) rect . get North Lat ( ) , ( float ) rect . get West Lon ( ) , rect . get Left ( ) , rect . get Top ( ) , rect . get Right ( ) , rect . get Bottom ( ) , props , link . dos ) ; break ; default : Debug . error ( STRING ) ; } }
private I Entry Holder update Entry SA ( Context context , I Entry Holder entry , I Template Holder template , boolean from Replication , boolean origin , I Server Type Desc type Desc ) throws SA Exception { cache Manager . insert To Recent Updates If Needed ( entry , cache Manager . requires Eviction Replication Protection ( ) ? Long . MAX VALUE : NUM , null ) ; boolean should Replicate = BOOL ; if ( is Replicated ( ) ) should Replicate = should Replicate ( Replication Operation Type . UPDATE , type Desc , BOOL , from Replication ) ; return cache Manager . update Entry ( context , entry , template , should Replicate , origin ) ; }
public List < Integer > right Side View ( Tree Node root ) { if ( root == null ) { return null ; } List < Integer > res = new Array List < > ( ) ; Queue < Tree Node > queue = new Array Deque < > ( ) ; queue . offer ( root ) ; while ( ! queue . is Empty ( ) ) { int size = queue . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) { Tree Node node = queue . poll ( ) ; if ( node . left != null ) { queue . offer ( node . left ) ; } if ( node . right != null ) { queue . offer ( node . right ) ; } if ( i == size - NUM ) { res . add ( node . val ) ; } } } return res ; }
public List < Integer > right Side View ( Tree Node root ) { if ( root == null ) { return null ; } List < Integer > res = new Array List < > ( ) ; Queue < Tree Node > queue = new Array Deque < > ( ) ; queue . offer ( root ) ; while ( ! queue . is Empty ( ) ) { int size = queue . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) { Tree Node node = queue . poll ( ) ; if ( node . left != null ) { queue . offer ( node . left ) ; } if ( node . right != null ) { queue . offer ( node . right ) ; } if ( i == size - NUM ) { res . add ( node . val ) ; } } } return res ; }
public final char current Char ( Char Sequence csq ) { return csq . char At ( index ) ; }
public final char current Char ( Char Sequence csq ) { return csq . char At ( index ) ; }
protected Java Type find Serialization Type ( Annotated a , boolean use Static Typing , Java Type declared Type ) { Class < ? > ser Class = annotation Introspector . find Serialization Type ( a ) ; if ( ser Class != null ) { Class < ? > raw Declared = declared Type . get Raw Class ( ) ; if ( ser Class . is Assignable From ( raw Declared ) ) { declared Type = declared Type . widen By ( ser Class ) ; } else { if ( ! raw Declared . is Assignable From ( ser Class ) ) { throw new Illegal Argument Exception ( STRING + a . get Name ( ) + STRING + ser Class . get Name ( ) + STRING + raw Declared . get Name ( ) ) ; } declared Type = config . construct Specialized Type ( declared Type , ser Class ) ; } use Static Typing = BOOL ; } Java Type secondary = Bean Serializer Factory . modify Secondary Types By Annotation ( config , a , declared Type ) ; if ( secondary != declared Type ) { use Static Typing = BOOL ; declared Type = secondary ; } if ( ! use Static Typing ) { Json Serialize . Typing typing = annotation Introspector . find Serialization Typing ( a ) ; if ( typing != null ) { use Static Typing = ( typing == Json Serialize . Typing . STATIC ) ; } } return use Static Typing ? declared Type : null ; }
protected Java Type find Serialization Type ( Annotated a , boolean use Static Typing , Java Type declared Type ) { Class < ? > ser Class = annotation Introspector . find Serialization Type ( a ) ; if ( ser Class != null ) { Class < ? > raw Declared = declared Type . get Raw Class ( ) ; if ( ser Class . is Assignable From ( raw Declared ) ) { declared Type = declared Type . widen By ( ser Class ) ; } else { if ( ! raw Declared . is Assignable From ( ser Class ) ) { throw new Illegal Argument Exception ( STRING + a . get Name ( ) + STRING + ser Class . get Name ( ) + STRING + raw Declared . get Name ( ) ) ; } declared Type = config . construct Specialized Type ( declared Type , ser Class ) ; } use Static Typing = BOOL ; } Java Type secondary = Bean Serializer Factory . modify Secondary Types By Annotation ( config , a , declared Type ) ; if ( secondary != declared Type ) { use Static Typing = BOOL ; declared Type = secondary ; } if ( ! use Static Typing ) { Json Serialize . Typing typing = annotation Introspector . find Serialization Typing ( a ) ; if ( typing != null ) { use Static Typing = ( typing == Json Serialize . Typing . STATIC ) ; } } return use Static Typing ? declared Type : null ; }
protected Java Type find Serialization Type ( Annotated a , boolean use Static Typing , Java Type declared Type ) { Class < ? > ser Class = annotation Introspector . find Serialization Type ( a ) ; if ( ser Class != null ) { Class < ? > raw Declared = declared Type . get Raw Class ( ) ; if ( ser Class . is Assignable From ( raw Declared ) ) { declared Type = declared Type . widen By ( ser Class ) ; } else { if ( ! raw Declared . is Assignable From ( ser Class ) ) { throw new Illegal Argument Exception ( STRING + a . get Name ( ) + STRING + ser Class . get Name ( ) + STRING + raw Declared . get Name ( ) ) ; } declared Type = config . construct Specialized Type ( declared Type , ser Class ) ; } use Static Typing = BOOL ; } Java Type secondary = Bean Serializer Factory . modify Secondary Types By Annotation ( config , a , declared Type ) ; if ( secondary != declared Type ) { use Static Typing = BOOL ; declared Type = secondary ; } if ( ! use Static Typing ) { Json Serialize . Typing typing = annotation Introspector . find Serialization Typing ( a ) ; if ( typing != null ) { use Static Typing = ( typing == Json Serialize . Typing . STATIC ) ; } } return use Static Typing ? declared Type : null ; }
public static void sort ( long [ ] array ) { Dual Pivot Quicksort . sort ( array ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return ID ; case NUM : return PROPERTY ; default : return null ; } }
public Sample Vcpc ( Independence Test independence Test ) { if ( independence Test == null ) { throw new Null Pointer Exception ( ) ; } if ( ! ( independence Test instanceof Ind Test Fisher Z ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . independence Test = independence Test ; this . data Set = ( Data Set ) independence Test . get Data ( ) ; this . variables = data Set . get Variables ( ) ; this . cov Matrix = new Covariance Matrix ( data Set ) ; List < Node > nodes = cov Matrix . get Variables ( ) ; this . index Map = index Map ( variables ) ; this . name Map = map Names ( variables ) ; this . nodes To Variables = new Hash Map < > ( ) ; this . variables To Nodes = new Hash Map < > ( ) ; }
public Sample Vcpc ( Independence Test independence Test ) { if ( independence Test == null ) { throw new Null Pointer Exception ( ) ; } if ( ! ( independence Test instanceof Ind Test Fisher Z ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . independence Test = independence Test ; this . data Set = ( Data Set ) independence Test . get Data ( ) ; this . variables = data Set . get Variables ( ) ; this . cov Matrix = new Covariance Matrix ( data Set ) ; List < Node > nodes = cov Matrix . get Variables ( ) ; this . index Map = index Map ( variables ) ; this . name Map = map Names ( variables ) ; this . nodes To Variables = new Hash Map < > ( ) ; this . variables To Nodes = new Hash Map < > ( ) ; }
public Sample Vcpc ( Independence Test independence Test ) { if ( independence Test == null ) { throw new Null Pointer Exception ( ) ; } if ( ! ( independence Test instanceof Ind Test Fisher Z ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . independence Test = independence Test ; this . data Set = ( Data Set ) independence Test . get Data ( ) ; this . variables = data Set . get Variables ( ) ; this . cov Matrix = new Covariance Matrix ( data Set ) ; List < Node > nodes = cov Matrix . get Variables ( ) ; this . index Map = index Map ( variables ) ; this . name Map = map Names ( variables ) ; this . nodes To Variables = new Hash Map < > ( ) ; this . variables To Nodes = new Hash Map < > ( ) ; }
public Sample Vcpc ( Independence Test independence Test ) { if ( independence Test == null ) { throw new Null Pointer Exception ( ) ; } if ( ! ( independence Test instanceof Ind Test Fisher Z ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . independence Test = independence Test ; this . data Set = ( Data Set ) independence Test . get Data ( ) ; this . variables = data Set . get Variables ( ) ; this . cov Matrix = new Covariance Matrix ( data Set ) ; List < Node > nodes = cov Matrix . get Variables ( ) ; this . index Map = index Map ( variables ) ; this . name Map = map Names ( variables ) ; this . nodes To Variables = new Hash Map < > ( ) ; this . variables To Nodes = new Hash Map < > ( ) ; }
public Sample Vcpc ( Independence Test independence Test ) { if ( independence Test == null ) { throw new Null Pointer Exception ( ) ; } if ( ! ( independence Test instanceof Ind Test Fisher Z ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . independence Test = independence Test ; this . data Set = ( Data Set ) independence Test . get Data ( ) ; this . variables = data Set . get Variables ( ) ; this . cov Matrix = new Covariance Matrix ( data Set ) ; List < Node > nodes = cov Matrix . get Variables ( ) ; this . index Map = index Map ( variables ) ; this . name Map = map Names ( variables ) ; this . nodes To Variables = new Hash Map < > ( ) ; this . variables To Nodes = new Hash Map < > ( ) ; }
public Sample Vcpc ( Independence Test independence Test ) { if ( independence Test == null ) { throw new Null Pointer Exception ( ) ; } if ( ! ( independence Test instanceof Ind Test Fisher Z ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . independence Test = independence Test ; this . data Set = ( Data Set ) independence Test . get Data ( ) ; this . variables = data Set . get Variables ( ) ; this . cov Matrix = new Covariance Matrix ( data Set ) ; List < Node > nodes = cov Matrix . get Variables ( ) ; this . index Map = index Map ( variables ) ; this . name Map = map Names ( variables ) ; this . nodes To Variables = new Hash Map < > ( ) ; this . variables To Nodes = new Hash Map < > ( ) ; }
public final Set < Class < ? extends Annotation > > load External Annotation Classes From Directory ( final String dir Name ) { File root Directory = new File ( dir Name ) ; Set < String > anno Names = get Annotation Names From Directory ( STRING , dir Name , root Directory , JAVA SUFFIX ) ; return load Annotation Classes ( anno Names ) ; }
public final Set < Class < ? extends Annotation > > load External Annotation Classes From Directory ( final String dir Name ) { File root Directory = new File ( dir Name ) ; Set < String > anno Names = get Annotation Names From Directory ( STRING , dir Name , root Directory , JAVA SUFFIX ) ; return load Annotation Classes ( anno Names ) ; }
public String read Line ( ) throws IO Exception { if ( finished ) throw new Dcc Exception ( Dcc Exception . Reason . Chat Not Connected , user , STRING ) ; String line = buffered Reader . read Line ( ) ; log . info ( INPUT CHAT MARKER , STRING + line ) ; return line ; }
protected void add Backups To Backup Request Buffer ( Fb Service service , Service Request Buffer backup SPB ) throws SQL Exception { for ( Iterator < Path Size Struct > iter = backup Paths . iterator ( ) ; iter . has Next ( ) ; ) { Path Size Struct path Size = iter . next ( ) ; backup SPB . add Argument ( isc spb bkp file , path Size . get Path ( ) ) ; if ( iter . has Next ( ) && path Size . get Size ( ) == - NUM ) { throw new SQL Exception ( STRING + path Size . get Path ( ) ) ; } if ( iter . has Next ( ) ) { backup SPB . add Argument ( isc spb bkp length , path Size . get Size ( ) ) ; } } }
public static boolean is Not Empty ( final Collection < ? > collection ) { return collection != null && ! collection . is Empty ( ) ; }
public static boolean is Not Empty ( final Collection < ? > collection ) { return collection != null && ! collection . is Empty ( ) ; }
public static boolean is Not Empty ( final Collection < ? > collection ) { return collection != null && ! collection . is Empty ( ) ; }
public void initialize ( Context context , String app Identifier , String channe Id ) { Artisan Log Util . debug Log ( STRING + app Identifier + STRING + channe Id + STRING ) ; Device Info Capture . init ( context ) ; if ( search Native Lib ( new File ( STRING + context . get Package Name ( ) ) , NATIVE LIB NAME ) ) { Artisan Log Util . debug Log ( STRING ) ; System . load Library ( STRING ) ; init Jni Object ( ) ; } else { Artisan Log Util . debug Log ( STRING ) ; } initialize ( context , app Identifier , channe Id , BOOL ) ; Artisan Log Util . debug Log ( STRING + app Identifier + STRING + channe Id + STRING ) ; Artisan Log Util . print ( STRING ) ; }
public void initialize ( Context context , String app Identifier , String channe Id ) { Artisan Log Util . debug Log ( STRING + app Identifier + STRING + channe Id + STRING ) ; Device Info Capture . init ( context ) ; if ( search Native Lib ( new File ( STRING + context . get Package Name ( ) ) , NATIVE LIB NAME ) ) { Artisan Log Util . debug Log ( STRING ) ; System . load Library ( STRING ) ; init Jni Object ( ) ; } else { Artisan Log Util . debug Log ( STRING ) ; } initialize ( context , app Identifier , channe Id , BOOL ) ; Artisan Log Util . debug Log ( STRING + app Identifier + STRING + channe Id + STRING ) ; Artisan Log Util . print ( STRING ) ; }
public void initialize ( Context context , String app Identifier , String channe Id ) { Artisan Log Util . debug Log ( STRING + app Identifier + STRING + channe Id + STRING ) ; Device Info Capture . init ( context ) ; if ( search Native Lib ( new File ( STRING + context . get Package Name ( ) ) , NATIVE LIB NAME ) ) { Artisan Log Util . debug Log ( STRING ) ; System . load Library ( STRING ) ; init Jni Object ( ) ; } else { Artisan Log Util . debug Log ( STRING ) ; } initialize ( context , app Identifier , channe Id , BOOL ) ; Artisan Log Util . debug Log ( STRING + app Identifier + STRING + channe Id + STRING ) ; Artisan Log Util . print ( STRING ) ; }
public void initialize ( Context context , String app Identifier , String channe Id ) { Artisan Log Util . debug Log ( STRING + app Identifier + STRING + channe Id + STRING ) ; Device Info Capture . init ( context ) ; if ( search Native Lib ( new File ( STRING + context . get Package Name ( ) ) , NATIVE LIB NAME ) ) { Artisan Log Util . debug Log ( STRING ) ; System . load Library ( STRING ) ; init Jni Object ( ) ; } else { Artisan Log Util . debug Log ( STRING ) ; } initialize ( context , app Identifier , channe Id , BOOL ) ; Artisan Log Util . debug Log ( STRING + app Identifier + STRING + channe Id + STRING ) ; Artisan Log Util . print ( STRING ) ; }
public void initialize ( Context context , String app Identifier , String channe Id ) { Artisan Log Util . debug Log ( STRING + app Identifier + STRING + channe Id + STRING ) ; Device Info Capture . init ( context ) ; if ( search Native Lib ( new File ( STRING + context . get Package Name ( ) ) , NATIVE LIB NAME ) ) { Artisan Log Util . debug Log ( STRING ) ; System . load Library ( STRING ) ; init Jni Object ( ) ; } else { Artisan Log Util . debug Log ( STRING ) ; } initialize ( context , app Identifier , channe Id , BOOL ) ; Artisan Log Util . debug Log ( STRING + app Identifier + STRING + channe Id + STRING ) ; Artisan Log Util . print ( STRING ) ; }
public void initialize ( Context context , String app Identifier , String channe Id ) { Artisan Log Util . debug Log ( STRING + app Identifier + STRING + channe Id + STRING ) ; Device Info Capture . init ( context ) ; if ( search Native Lib ( new File ( STRING + context . get Package Name ( ) ) , NATIVE LIB NAME ) ) { Artisan Log Util . debug Log ( STRING ) ; System . load Library ( STRING ) ; init Jni Object ( ) ; } else { Artisan Log Util . debug Log ( STRING ) ; } initialize ( context , app Identifier , channe Id , BOOL ) ; Artisan Log Util . debug Log ( STRING + app Identifier + STRING + channe Id + STRING ) ; Artisan Log Util . print ( STRING ) ; }
public String to XML ( final Object obj ) { final Writer writer = new String Writer ( ) ; to XML ( obj , writer ) ; return writer . to String ( ) ; }
public String to XML ( final Object obj ) { final Writer writer = new String Writer ( ) ; to XML ( obj , writer ) ; return writer . to String ( ) ; }
public boolean is Alive ( ) { if ( has Sent Data ) { if ( System . current Time Millis ( ) - last Send Time < TIMEOUT ) return BOOL ; return has Received Data && last Receive Time > last Send Time ; } return BOOL ; }
public boolean is Alive ( ) { if ( has Sent Data ) { if ( System . current Time Millis ( ) - last Send Time < TIMEOUT ) return BOOL ; return has Received Data && last Receive Time > last Send Time ; } return BOOL ; }
public boolean is Alive ( ) { if ( has Sent Data ) { if ( System . current Time Millis ( ) - last Send Time < TIMEOUT ) return BOOL ; return has Received Data && last Receive Time > last Send Time ; } return BOOL ; }
public Array List < Mech Summary > generate ( int num Rolls , String rat Name ) { return generate ( num Rolls , rat Name , null ) ; }
public static byte [ ] encoding To Bytes ( final String str , final String encoding ) { if ( str == null ) { return null ; } try { return str . get Bytes ( encoding ) ; } catch ( final Unsupported Encoding Exception e ) { throw new Error ( encoding + STRING + e ) ; } }
public static byte [ ] encoding To Bytes ( final String str , final String encoding ) { if ( str == null ) { return null ; } try { return str . get Bytes ( encoding ) ; } catch ( final Unsupported Encoding Exception e ) { throw new Error ( encoding + STRING + e ) ; } }
public static byte [ ] encoding To Bytes ( final String str , final String encoding ) { if ( str == null ) { return null ; } try { return str . get Bytes ( encoding ) ; } catch ( final Unsupported Encoding Exception e ) { throw new Error ( encoding + STRING + e ) ; } }
public int size ( ) { return m Recent Items . size ( ) ; }
public int size ( ) { return m Recent Items . size ( ) ; }
public JBBP Out Short ( final String str ) throws IO Exception { assert Not Ended ( ) ; if ( this . process Commands ) { for ( int i = NUM ; i < str . length ( ) ; i ++ ) { write Short ( str . char At ( i ) ) ; } } return this ; }
public JBBP Out Short ( final String str ) throws IO Exception { assert Not Ended ( ) ; if ( this . process Commands ) { for ( int i = NUM ; i < str . length ( ) ; i ++ ) { write Short ( str . char At ( i ) ) ; } } return this ; }
public void take Picture ( ) throws Null Pointer Exception { Intent take Picture Intent = new Intent ( Media Store . ACTION IMAGE CAPTURE ) ; if ( take Picture Intent . resolve Activity ( activity . get Package Manager ( ) ) != null ) { File photo File = Utils . create Image File ( context , dir Name , image Name , image Type ) ; if ( photo File != null ) { camera Bitmap Path = photo File . get Absolute Path ( ) ; take Picture Intent . put Extra ( Media Store . EXTRA OUTPUT , Uri . from File ( photo File ) ) ; activity . start Activity For Result ( take Picture Intent , REQUEST TAKE PHOTO ) ; } else { throw new Null Pointer Exception ( STRING ) ; } } else { throw new Null Pointer Exception ( STRING ) ; } }
public void test Bad Segment ( ) throws IO Exception { Directory dir = new Directory ( ) ; Index Writer iw = new Index Writer ( dir , new Index Writer Config ( new Mock Analyzer ( random ( ) ) ) ) ; Document document = new Document ( ) ; Field Type custom Type = new Field Type ( Text Field . TYPE NOT STORED ) ; custom Type . set Store Term Vectors ( BOOL ) ; document . add ( new Field ( STRING , STRING , custom Type ) ) ; iw . add Document ( document ) ; iw . close ( ) ; dir . close ( ) ; }
public int depth ( ) { return pointer ; }
public static void write Little Endian Int ( Data Output Stream data Stream , int val ) throws IO Exception { int mask = NUM ; for ( int shift = NUM ; shift < NUM ; shift += NUM ) { data Stream . write Byte ( mask & ( val > > shift ) ) ; } }
public Service Endpoint ( String name , String endpoint , String binding ) { Validate Util . validate Not Empty ( endpoint , STRING ) ; Validate Util . validate Not Empty ( binding , STRING ) ; if ( name == null || name . is Empty ( ) ) { name = endpoint ; } this . name = name ; this . endpoint = endpoint ; this . binding = binding ; }
public void action Performed ( Action Event e ) { navigate To Prior Demo ( ) ; }
protected boolean clean State ( String topology Name , Scheduler State Manager Adaptor statemgr ) { LOG . fine ( STRING ) ; Boolean result ; result = statemgr . delete T Master Location ( topology Name ) ; if ( result == null || ! result ) { LOG . warning ( STRING ) ; } result = statemgr . delete Packing Plan ( topology Name ) ; if ( result == null || ! result ) { LOG . warning ( STRING ) ; } result = statemgr . delete Physical Plan ( topology Name ) ; if ( result == null || ! result ) { LOG . warning ( STRING ) ; } result = statemgr . delete Scheduler Location ( topology Name ) ; if ( result == null || ! result ) { LOG . warning ( STRING ) ; } result = statemgr . delete Execution State ( topology Name ) ; if ( result == null || ! result ) { LOG . severe ( STRING ) ; return BOOL ; } result = statemgr . delete Topology ( topology Name ) ; if ( result == null || ! result ) { LOG . severe ( STRING ) ; return BOOL ; } LOG . fine ( STRING ) ; return BOOL ; }
protected void do Ping ( @ Not Null String app , @ Not Null String version , @ Nullable final Map < String , String > extras ) { final String n App = normalize App Name ( app ) ; final String n Version = normalize Version ( version ) ; if ( ! m Store . is Ping Opt In ( ) ) { return ; } long now = System . current Time Millis ( ) ; long then = m Store . get Ping Time ( app ) ; if ( now - then < PING INTERVAL MSEC ) { return ; } m Store . set Ping Time ( app , now ) ; try { URL url = create Ping Url ( n App , n Version , INSTALLATION ID , extras ) ; actually Send Ping ( url ) ; } catch ( Exception e ) { LOG . warn ( STRING , e ) ; } }
protected void do Ping ( @ Not Null String app , @ Not Null String version , @ Nullable final Map < String , String > extras ) { final String n App = normalize App Name ( app ) ; final String n Version = normalize Version ( version ) ; if ( ! m Store . is Ping Opt In ( ) ) { return ; } long now = System . current Time Millis ( ) ; long then = m Store . get Ping Time ( app ) ; if ( now - then < PING INTERVAL MSEC ) { return ; } m Store . set Ping Time ( app , now ) ; try { URL url = create Ping Url ( n App , n Version , INSTALLATION ID , extras ) ; actually Send Ping ( url ) ; } catch ( Exception e ) { LOG . warn ( STRING , e ) ; } }
private byte [ ] entity To Bytes ( Http Entity entity , Request request ) throws IO Exception , Server Error { Pooling Byte Array Output Stream bytes = new Pooling Byte Array Output Stream ( m Pool , ( int ) entity . get Content Length ( ) ) ; byte [ ] buffer = null ; try { Input Stream in = entity . get Content ( ) ; if ( in == null ) { throw new Server Error ( ) ; } buffer = m Pool . get Buf ( NUM ) ; int progress = NUM ; int count ; while ( ( count = in . read ( buffer ) ) != - NUM ) { bytes . write ( buffer , NUM , count ) ; progress += count ; request . progress Update ( progress ) ; } return bytes . to Byte Array ( ) ; } finally { try { entity . consume Content ( ) ; } catch ( IO Exception e ) { Vinci Log . d ( STRING ) ; } m Pool . return Buf ( buffer ) ; bytes . close ( ) ; } }
public static Long to Long ( boolean b ) { return Long . value Of ( to Long Value ( b ) ) ; }
public boolean epsilon Equals ( float x , float y , float z , float epsilon ) { if ( Math . abs ( x - this . x ) > epsilon ) return BOOL ; if ( Math . abs ( y - this . y ) > epsilon ) return BOOL ; if ( Math . abs ( z - this . z ) > epsilon ) return BOOL ; return BOOL ; }
@ Objective C Name ( STRING ) private boolean is Discard Ack ( Message message ) { Event event = Event . get Event ( message . data [ NUM ] ) ; if ( event == Event . MESSAGE DENIED && Actions . get Action ( message . data [ NUM ] ) == Actions . DELETE ) { return BOOL ; } Actions action = Actions . get Action ( message . data [ NUM ] ) ; return action == Actions . DELETE || action == Actions . UNSUBSCRIBE ; }
@ Objective C Name ( STRING ) private boolean is Discard Ack ( Message message ) { Event event = Event . get Event ( message . data [ NUM ] ) ; if ( event == Event . MESSAGE DENIED && Actions . get Action ( message . data [ NUM ] ) == Actions . DELETE ) { return BOOL ; } Actions action = Actions . get Action ( message . data [ NUM ] ) ; return action == Actions . DELETE || action == Actions . UNSUBSCRIBE ; }
@ Objective C Name ( STRING ) private boolean is Discard Ack ( Message message ) { Event event = Event . get Event ( message . data [ NUM ] ) ; if ( event == Event . MESSAGE DENIED && Actions . get Action ( message . data [ NUM ] ) == Actions . DELETE ) { return BOOL ; } Actions action = Actions . get Action ( message . data [ NUM ] ) ; return action == Actions . DELETE || action == Actions . UNSUBSCRIBE ; }
@ Objective C Name ( STRING ) private boolean is Discard Ack ( Message message ) { Event event = Event . get Event ( message . data [ NUM ] ) ; if ( event == Event . MESSAGE DENIED && Actions . get Action ( message . data [ NUM ] ) == Actions . DELETE ) { return BOOL ; } Actions action = Actions . get Action ( message . data [ NUM ] ) ; return action == Actions . DELETE || action == Actions . UNSUBSCRIBE ; }
@ Objective C Name ( STRING ) private boolean is Discard Ack ( Message message ) { Event event = Event . get Event ( message . data [ NUM ] ) ; if ( event == Event . MESSAGE DENIED && Actions . get Action ( message . data [ NUM ] ) == Actions . DELETE ) { return BOOL ; } Actions action = Actions . get Action ( message . data [ NUM ] ) ; return action == Actions . DELETE || action == Actions . UNSUBSCRIBE ; }
public void test Boolean Options ( ) throws Exception { Database Meta Data dbmd = con . get Meta Data ( ) ; assert True ( STRING , dbmd . locators Update Copy ( ) ) ; assert True ( STRING , dbmd . supports Get Generated Keys ( ) ) ; assert True ( STRING , dbmd . supports Multiple Open Results ( ) ) ; assert True ( STRING , dbmd . supports Named Parameters ( ) ) ; assert False ( STRING , dbmd . supports Result Set Holdability ( Result Set . HOLD CURSORS OVER COMMIT ) ) ; assert False ( STRING , dbmd . supports Result Set Holdability ( Result Set . CLOSE CURSORS AT COMMIT ) ) ; assert True ( STRING , dbmd . supports Savepoints ( ) ) ; assert True ( STRING , dbmd . supports Statement Pooling ( ) ) ; }
public void test Boolean Options ( ) throws Exception { Database Meta Data dbmd = con . get Meta Data ( ) ; assert True ( STRING , dbmd . locators Update Copy ( ) ) ; assert True ( STRING , dbmd . supports Get Generated Keys ( ) ) ; assert True ( STRING , dbmd . supports Multiple Open Results ( ) ) ; assert True ( STRING , dbmd . supports Named Parameters ( ) ) ; assert False ( STRING , dbmd . supports Result Set Holdability ( Result Set . HOLD CURSORS OVER COMMIT ) ) ; assert False ( STRING , dbmd . supports Result Set Holdability ( Result Set . CLOSE CURSORS AT COMMIT ) ) ; assert True ( STRING , dbmd . supports Savepoints ( ) ) ; assert True ( STRING , dbmd . supports Statement Pooling ( ) ) ; }
public static void replace Styles ( List < Shape Record > shape Records , int line Style Index , int fill Style 0 Index , int fill Style 1 Index ) { if ( shape Records != null && shape Records . size ( ) > NUM ) { for ( int i = NUM ; i < shape Records . size ( ) ; i ++ ) { Shape Record record = shape Records . get ( i ) ; if ( record instanceof Style Change Record ) { Style Change Record old scr = ( Style Change Record ) record ; Style Change Record new scr = new Style Change Record ( ) ; if ( fill Style 0 Index > NUM ) new scr . set Fill Style 0 ( fill Style 0 Index ) ; if ( fill Style 1 Index > NUM ) new scr . set Fill Style 1 ( fill Style 1 Index ) ; if ( ( ! old scr . state Line Style ) && ( line Style Index > NUM ) ) new scr . set Linestyle ( line Style Index ) ; else new scr . set Linestyle ( old scr . linestyle ) ; if ( old scr . state Move To ) new scr . set Move ( old scr . move Delta X , old scr . move Delta Y ) ; shape Records . set ( i , new scr ) ; } } } }
public static void replace Styles ( List < Shape Record > shape Records , int line Style Index , int fill Style 0 Index , int fill Style 1 Index ) { if ( shape Records != null && shape Records . size ( ) > NUM ) { for ( int i = NUM ; i < shape Records . size ( ) ; i ++ ) { Shape Record record = shape Records . get ( i ) ; if ( record instanceof Style Change Record ) { Style Change Record old scr = ( Style Change Record ) record ; Style Change Record new scr = new Style Change Record ( ) ; if ( fill Style 0 Index > NUM ) new scr . set Fill Style 0 ( fill Style 0 Index ) ; if ( fill Style 1 Index > NUM ) new scr . set Fill Style 1 ( fill Style 1 Index ) ; if ( ( ! old scr . state Line Style ) && ( line Style Index > NUM ) ) new scr . set Linestyle ( line Style Index ) ; else new scr . set Linestyle ( old scr . linestyle ) ; if ( old scr . state Move To ) new scr . set Move ( old scr . move Delta X , old scr . move Delta Y ) ; shape Records . set ( i , new scr ) ; } } } }
Primer Pack ( Byte Provider byte Provider , KLV Packet . Header header ) throws IO Exception { this . header = header ; this . local Tag Entry Batch = new Local Tag Entry Batch ( byte Provider ) ; }
public static String to Json ( final Object object ) { return to Json ( object , BOOL ) ; }
public static String to Json ( final Object object ) { return to Json ( object , BOOL ) ; }
public boolean contains ( String name ) { return index Of ( name ) != - NUM ; }
public boolean contains ( String name ) { return index Of ( name ) != - NUM ; }
public void increment Renewed Tokens ( String tenant ) { logger . trace ( STRING , tenant ) ; try { Atomic Integer count ; synchronized ( this ) { if ( ( count = renewed Tokens Map . get ( tenant ) ) == null ) { renewed Tokens Map . put ( tenant , new Atomic Integer ( NUM ) ) ; } else { count . increment And Get ( ) ; } } logger . trace ( STRING , tenant , renewed Tokens Map . get ( tenant ) ) ; increment Total Renewed ( ) ; } catch ( Exception e ) { logger . error ( STRING , e ) ; } }
public void increment Renewed Tokens ( String tenant ) { logger . trace ( STRING , tenant ) ; try { Atomic Integer count ; synchronized ( this ) { if ( ( count = renewed Tokens Map . get ( tenant ) ) == null ) { renewed Tokens Map . put ( tenant , new Atomic Integer ( NUM ) ) ; } else { count . increment And Get ( ) ; } } logger . trace ( STRING , tenant , renewed Tokens Map . get ( tenant ) ) ; increment Total Renewed ( ) ; } catch ( Exception e ) { logger . error ( STRING , e ) ; } }
@ Nullable public static String extract Class Name ( @ Not Null String string ) { String Builder sb = new String Builder ( string . length ( ) ) ; int n = string . length ( ) ; int i = NUM ; for ( ; i < n ; i ++ ) { char c = Character . to Upper Case ( string . char At ( i ) ) ; if ( Character . is Java Identifier Start ( c ) ) { sb . append ( c ) ; i ++ ; break ; } } if ( sb . length ( ) > NUM ) { for ( ; i < n ; i ++ ) { char c = string . char At ( i ) ; if ( Character . is Java Identifier Part ( c ) ) { sb . append ( c ) ; } } return sb . to String ( ) ; } return null ; }
protected static Dfp [ ] split ( final Dfp Field field , final String a ) { Dfp result [ ] = new Dfp [ NUM ] ; char [ ] buf ; boolean leading = BOOL ; int sp = NUM ; int sig = NUM ; buf = new char [ a . length ( ) ] ; for ( int i = NUM ; i < buf . length ; i ++ ) { buf [ i ] = a . char At ( i ) ; if ( buf [ i ] >= STRING && buf [ i ] <= STRING ) { leading = BOOL ; } if ( buf [ i ] == STRING ) { sig += ( NUM - sig ) % NUM ; leading = BOOL ; } if ( sig == ( field . get Radix Digits ( ) / NUM ) * NUM ) { sp = i ; break ; } if ( buf [ i ] >= STRING && buf [ i ] <= STRING && ! leading ) { sig ++ ; } } result [ NUM ] = field . new Dfp ( new String ( buf , NUM , sp ) ) ; for ( int i = NUM ; i < buf . length ; i ++ ) { buf [ i ] = a . char At ( i ) ; if ( buf [ i ] >= STRING && buf [ i ] <= STRING && i < sp ) { buf [ i ] = STRING ; } } result [ NUM ] = field . new Dfp ( new String ( buf ) ) ; return result ; }
protected static Dfp [ ] split ( final Dfp Field field , final String a ) { Dfp result [ ] = new Dfp [ NUM ] ; char [ ] buf ; boolean leading = BOOL ; int sp = NUM ; int sig = NUM ; buf = new char [ a . length ( ) ] ; for ( int i = NUM ; i < buf . length ; i ++ ) { buf [ i ] = a . char At ( i ) ; if ( buf [ i ] >= STRING && buf [ i ] <= STRING ) { leading = BOOL ; } if ( buf [ i ] == STRING ) { sig += ( NUM - sig ) % NUM ; leading = BOOL ; } if ( sig == ( field . get Radix Digits ( ) / NUM ) * NUM ) { sp = i ; break ; } if ( buf [ i ] >= STRING && buf [ i ] <= STRING && ! leading ) { sig ++ ; } } result [ NUM ] = field . new Dfp ( new String ( buf , NUM , sp ) ) ; for ( int i = NUM ; i < buf . length ; i ++ ) { buf [ i ] = a . char At ( i ) ; if ( buf [ i ] >= STRING && buf [ i ] <= STRING && i < sp ) { buf [ i ] = STRING ; } } result [ NUM ] = field . new Dfp ( new String ( buf ) ) ; return result ; }
protected static Dfp [ ] split ( final Dfp Field field , final String a ) { Dfp result [ ] = new Dfp [ NUM ] ; char [ ] buf ; boolean leading = BOOL ; int sp = NUM ; int sig = NUM ; buf = new char [ a . length ( ) ] ; for ( int i = NUM ; i < buf . length ; i ++ ) { buf [ i ] = a . char At ( i ) ; if ( buf [ i ] >= STRING && buf [ i ] <= STRING ) { leading = BOOL ; } if ( buf [ i ] == STRING ) { sig += ( NUM - sig ) % NUM ; leading = BOOL ; } if ( sig == ( field . get Radix Digits ( ) / NUM ) * NUM ) { sp = i ; break ; } if ( buf [ i ] >= STRING && buf [ i ] <= STRING && ! leading ) { sig ++ ; } } result [ NUM ] = field . new Dfp ( new String ( buf , NUM , sp ) ) ; for ( int i = NUM ; i < buf . length ; i ++ ) { buf [ i ] = a . char At ( i ) ; if ( buf [ i ] >= STRING && buf [ i ] <= STRING && i < sp ) { buf [ i ] = STRING ; } } result [ NUM ] = field . new Dfp ( new String ( buf ) ) ; return result ; }
synchronized boolean expire ( long threshold ) { Iterator < Connection Desc > iter = conns . iterator ( ) ; Connection Desc entry ; while ( iter . has Next ( ) ) { entry = iter . next ( ) ; if ( entry . expire ( threshold ) ) { d ( STRING , entry ) ; td ( STRING , entry ) ; iter . remove ( ) ; } } return conns . is Empty ( ) ; }
synchronized boolean expire ( long threshold ) { Iterator < Connection Desc > iter = conns . iterator ( ) ; Connection Desc entry ; while ( iter . has Next ( ) ) { entry = iter . next ( ) ; if ( entry . expire ( threshold ) ) { d ( STRING , entry ) ; td ( STRING , entry ) ; iter . remove ( ) ; } } return conns . is Empty ( ) ; }
public static int hash ( int hash , double item ) { long l = Double . double To Long Bits ( item ) ; return seed * prime + ( int ) ( l ^ ( l > > > NUM ) ) ; }
@ Override public < T > void inject ( T bean ) { Objects . require Non Null ( bean ) ; Config Stub stub = new Config Stub ( bean . get Class ( ) ) ; stub . inject ( bean , this ) ; }
private void before Key ( ) throws JSON Exception { Scope context = peek ( ) ; if ( context == Scope . NONEMPTY OBJECT ) { out . append ( STRING ) ; } else if ( context != Scope . EMPTY OBJECT ) { throw new JSON Exception ( STRING ) ; } newline ( ) ; replace Top ( Scope . DANGLING KEY ) ; }
private void before Key ( ) throws JSON Exception { Scope context = peek ( ) ; if ( context == Scope . NONEMPTY OBJECT ) { out . append ( STRING ) ; } else if ( context != Scope . EMPTY OBJECT ) { throw new JSON Exception ( STRING ) ; } newline ( ) ; replace Top ( Scope . DANGLING KEY ) ; }
public void add Attribute ( Tag Meta Data Attr attr ) { attrs . add ( attr ) ; }
public static String correct File Name ( String f ) { f = f . replace ( STRING , STRING ) ; if ( f . starts With ( STRING ) ) { f = f . substring ( NUM ) ; } return f ; }
public static void install Mouse Listener On All Components ( Mouse Listener m , Container c ) { c . add Mouse Listener ( m ) ; Component [ ] components = c . get Components ( ) ; for ( int i = NUM ; i < components . length ; i ++ ) { if ( components [ i ] instanceof Container ) { Mouse Input Adapter Installer . install Mouse Listener On All Components ( m , ( Container ) components [ i ] ) ; } else { c . add Mouse Listener ( m ) ; } } }
public final String to String ( String codeset ) { String Buffer sb = new String Buffer ( ) ; if ( doctype != null ) sb . append ( doctype . to String ( get Codeset ( ) ) ) ; sb . append ( html . to String ( get Codeset ( ) ) ) ; return ( sb . to String ( ) ) ; }
public final String to String ( String codeset ) { String Buffer sb = new String Buffer ( ) ; if ( doctype != null ) sb . append ( doctype . to String ( get Codeset ( ) ) ) ; sb . append ( html . to String ( get Codeset ( ) ) ) ; return ( sb . to String ( ) ) ; }
private static List < Text Range > add Previous Comma ( Psi Element e , int cursor Offset ) { Psi Element prev Sibling = e . get Prev Sibling ( ) ; Text Range text Range = e . get Text Range ( ) ; Text Range offset Range = null ; if ( prev Sibling != null ) { if ( prev Sibling instanceof Psi White Space ) { Psi Element prev Comma Sibling = prev Sibling . get Prev Sibling ( ) ; if ( prev Comma Sibling != null ) { AST Node node = prev Comma Sibling . get Node ( ) ; if ( node != null ) { I Element Type comma Type = node . get Element Type ( ) ; if ( comma Type == Py Token Types . COMMA ) { offset Range = new Text Range ( text Range . get Start Offset ( ) - NUM , text Range . get End Offset ( ) ) ; if ( offset Range . contains ( cursor Offset ) && offset Range . get Length ( ) > NUM ) { return Collections . singleton List ( offset Range ) ; } } } } } else { AST Node node = prev Sibling . get Node ( ) ; if ( node != null ) { I Element Type comma Type = node . get Element Type ( ) ; if ( comma Type == Py Token Types . COMMA ) { offset Range = new Text Range ( text Range . get Start Offset ( ) - NUM , text Range . get End Offset ( ) ) ; } } } if ( offset Range != null ) { if ( offset Range . contains ( cursor Offset ) && offset Range . get Length ( ) > NUM ) { return Collections . singleton List ( offset Range ) ; } } } return Collections . empty List ( ) ; }
public void delete Columns ( int start , int len ) throws Table Exception { int ncol = this . arrays . length ; if ( start < NUM || len < NUM || start + len > ncol ) { throw new Table Exception ( STRING + start + STRING + len + STRING + ncol + STRING ) ; } if ( len == NUM ) { return ; } int ocol = ncol ; ncol -= len ; Object [ ] new Arrays = new Object [ ncol ] ; int [ ] new Sizes = new int [ ncol ] ; Class < ? > [ ] new Bases = new Class < ? > [ ncol ] ; char [ ] new Types = new char [ ncol ] ; System . arraycopy ( this . arrays , NUM , new Arrays , NUM , start ) ; System . arraycopy ( this . sizes , NUM , new Sizes , NUM , start ) ; System . arraycopy ( this . bases , NUM , new Bases , NUM , start ) ; System . arraycopy ( this . types , NUM , new Types , NUM , start ) ; int rem = ocol - ( start + len ) ; System . arraycopy ( this . arrays , start + len , new Arrays , start , rem ) ; System . arraycopy ( this . sizes , start + len , new Sizes , start , rem ) ; System . arraycopy ( this . bases , start + len , new Bases , start , rem ) ; System . arraycopy ( this . types , start + len , new Types , start , rem ) ; this . arrays = new Arrays ; this . sizes = new Sizes ; this . bases = new Bases ; this . types = new Types ; initialize Pointers ( ) ; }
public void load ( Path properties Path ) { if ( properties Path != null ) { m Properties Path = properties Path ; Input Stream in = null ; try { in = new File Input Stream ( properties Path . to String ( ) ) ; } catch ( File Not Found Exception e ) { m Log . error ( STRING + STRING , e ) ; } if ( in != null ) { try { m Properties . load ( in ) ; } catch ( IO Exception e ) { m Log . error ( STRING + STRING , e ) ; } finally { try { in . close ( ) ; } catch ( IO Exception e ) { } } } } m Log . info ( STRING + properties Path . to String ( ) + STRING ) ; }
public boolean is Attacked By ( final I Entity attacker ) { return attackers . contains ( attacker ) ; }
public boolean is Attacked By ( final I Entity attacker ) { return attackers . contains ( attacker ) ; }
public final boolean remove Element ( int s ) { for ( int i = NUM ; i < m first Free ; i ++ ) { if ( m map [ i ] == s ) { if ( ( i + NUM ) < m first Free ) System . arraycopy ( m map , i + NUM , m map , i - NUM , m first Free - i ) ; else m map [ i ] = java . lang . Integer . MIN VALUE ; m first Free -- ; return BOOL ; } } return BOOL ; }
public final boolean remove Element ( int s ) { for ( int i = NUM ; i < m first Free ; i ++ ) { if ( m map [ i ] == s ) { if ( ( i + NUM ) < m first Free ) System . arraycopy ( m map , i + NUM , m map , i - NUM , m first Free - i ) ; else m map [ i ] = java . lang . Integer . MIN VALUE ; m first Free -- ; return BOOL ; } } return BOOL ; }
public final boolean remove Element ( int s ) { for ( int i = NUM ; i < m first Free ; i ++ ) { if ( m map [ i ] == s ) { if ( ( i + NUM ) < m first Free ) System . arraycopy ( m map , i + NUM , m map , i - NUM , m first Free - i ) ; else m map [ i ] = java . lang . Integer . MIN VALUE ; m first Free -- ; return BOOL ; } } return BOOL ; }
public final boolean remove Element ( int s ) { for ( int i = NUM ; i < m first Free ; i ++ ) { if ( m map [ i ] == s ) { if ( ( i + NUM ) < m first Free ) System . arraycopy ( m map , i + NUM , m map , i - NUM , m first Free - i ) ; else m map [ i ] = java . lang . Integer . MIN VALUE ; m first Free -- ; return BOOL ; } } return BOOL ; }
public final boolean remove Element ( int s ) { for ( int i = NUM ; i < m first Free ; i ++ ) { if ( m map [ i ] == s ) { if ( ( i + NUM ) < m first Free ) System . arraycopy ( m map , i + NUM , m map , i - NUM , m first Free - i ) ; else m map [ i ] = java . lang . Integer . MIN VALUE ; m first Free -- ; return BOOL ; } } return BOOL ; }
public final boolean remove Element ( int s ) { for ( int i = NUM ; i < m first Free ; i ++ ) { if ( m map [ i ] == s ) { if ( ( i + NUM ) < m first Free ) System . arraycopy ( m map , i + NUM , m map , i - NUM , m first Free - i ) ; else m map [ i ] = java . lang . Integer . MIN VALUE ; m first Free -- ; return BOOL ; } } return BOOL ; }
private Byte Buffer write String ( Charset Encoder encoder , String next , int i , int no Of Values ) throws Character Coding Exception { Byte Buffer bb ; if ( ( i + NUM ) == no Of Values ) { bb = encoder . encode ( Char Buffer . wrap ( next ) ) ; } else { if ( is Null Seperate Multiple Values ( ) ) { bb = encoder . encode ( Char Buffer . wrap ( next + STRING ) ) ; } else { bb = encoder . encode ( Char Buffer . wrap ( next ) ) ; } } bb . rewind ( ) ; return bb ; }
private Byte Buffer write String ( Charset Encoder encoder , String next , int i , int no Of Values ) throws Character Coding Exception { Byte Buffer bb ; if ( ( i + NUM ) == no Of Values ) { bb = encoder . encode ( Char Buffer . wrap ( next ) ) ; } else { if ( is Null Seperate Multiple Values ( ) ) { bb = encoder . encode ( Char Buffer . wrap ( next + STRING ) ) ; } else { bb = encoder . encode ( Char Buffer . wrap ( next ) ) ; } } bb . rewind ( ) ; return bb ; }
private Byte Buffer write String ( Charset Encoder encoder , String next , int i , int no Of Values ) throws Character Coding Exception { Byte Buffer bb ; if ( ( i + NUM ) == no Of Values ) { bb = encoder . encode ( Char Buffer . wrap ( next ) ) ; } else { if ( is Null Seperate Multiple Values ( ) ) { bb = encoder . encode ( Char Buffer . wrap ( next + STRING ) ) ; } else { bb = encoder . encode ( Char Buffer . wrap ( next ) ) ; } } bb . rewind ( ) ; return bb ; }
private Byte Buffer write String ( Charset Encoder encoder , String next , int i , int no Of Values ) throws Character Coding Exception { Byte Buffer bb ; if ( ( i + NUM ) == no Of Values ) { bb = encoder . encode ( Char Buffer . wrap ( next ) ) ; } else { if ( is Null Seperate Multiple Values ( ) ) { bb = encoder . encode ( Char Buffer . wrap ( next + STRING ) ) ; } else { bb = encoder . encode ( Char Buffer . wrap ( next ) ) ; } } bb . rewind ( ) ; return bb ; }
public static boolean valid System Name Config ( String system Name , char type ) { if ( ! valid System Name Format ( system Name , type ) ) { return BOOL ; } int bit = get Bit From System Name ( system Name ) ; if ( ( type == STRING ) || ( type == STRING ) ) { if ( ( bit <= NUM ) || ( bit > Output Bits . get Num Output Bits ( ) ) ) { return BOOL ; } } else if ( type == STRING ) { if ( ( bit <= NUM ) || ( bit > Input Bits . get Num Input Bits ( ) ) ) { return BOOL ; } } else { log . error ( STRING ) ; return BOOL ; } return BOOL ; }
public static boolean valid System Name Config ( String system Name , char type ) { if ( ! valid System Name Format ( system Name , type ) ) { return BOOL ; } int bit = get Bit From System Name ( system Name ) ; if ( ( type == STRING ) || ( type == STRING ) ) { if ( ( bit <= NUM ) || ( bit > Output Bits . get Num Output Bits ( ) ) ) { return BOOL ; } } else if ( type == STRING ) { if ( ( bit <= NUM ) || ( bit > Input Bits . get Num Input Bits ( ) ) ) { return BOOL ; } } else { log . error ( STRING ) ; return BOOL ; } return BOOL ; }
public static boolean valid System Name Config ( String system Name , char type ) { if ( ! valid System Name Format ( system Name , type ) ) { return BOOL ; } int bit = get Bit From System Name ( system Name ) ; if ( ( type == STRING ) || ( type == STRING ) ) { if ( ( bit <= NUM ) || ( bit > Output Bits . get Num Output Bits ( ) ) ) { return BOOL ; } } else if ( type == STRING ) { if ( ( bit <= NUM ) || ( bit > Input Bits . get Num Input Bits ( ) ) ) { return BOOL ; } } else { log . error ( STRING ) ; return BOOL ; } return BOOL ; }
public final int first common layer ( Brd Item p other ) { int max first layer = Math . max ( first layer ( ) , p other . first layer ( ) ) ; int min last layer = Math . min ( last layer ( ) , p other . last layer ( ) ) ; if ( max first layer > min last layer ) { return - NUM ; } return max first layer ; }
private void check Thin Enabled Result ( V Plex Virtual Volume Info info , boolean thin Enabled , String task Id ) { if ( thin Enabled && ( null != info ) && ! info . is Thin Enabled ( ) ) { log . warn ( String . format ( STRING + STRING + STRING , info . get Name ( ) , task Id ) ) ; } }
protected static final int centimeter As Pixel ( double cm , int dpi ) { return ( int ) Math . round ( dpi * cm * NUM / NUM ) ; }
protected static final int centimeter As Pixel ( double cm , int dpi ) { return ( int ) Math . round ( dpi * cm * NUM / NUM ) ; }
protected static final int centimeter As Pixel ( double cm , int dpi ) { return ( int ) Math . round ( dpi * cm * NUM / NUM ) ; }
public static void put Long LE ( byte [ ] arr , long off , long val ) { if ( UNALIGNED ) UNSAFE . put Long ( arr , off , Long . reverse Bytes ( val ) ) ; else put Long By Byte ( arr , off , val , BOOL ) ; }
void close ( String name ) { if ( jmx ) { try { Utils . call Static Method ( STRING , name ) ; } catch ( Exception e ) { throw Db Exception . get ( Error Code . FEATURE NOT SUPPORTED 1 , e , STRING ) ; } } DATABASES . remove ( name ) ; }
public Memory Example Table ( List < Attribute > attributes ) { super ( attributes ) ; this . columns = attributes . size ( ) ; }
private void insert Expected Pool Settings Per Tier ( CIM Object Path capabilities Path , Map < String , Object > key Map ) { List < String > expected Pool Settings Tier = ( List < String > ) key Map . get ( Constants . VNXPOOLCAPABILITIES TIER ) ; expected Pool Settings Tier . add ( capabilities Path . to String ( ) + Constants . HYPHEN + Constants . NO DATA MOVEMENT ) ; expected Pool Settings Tier . add ( capabilities Path . to String ( ) + Constants . HYPHEN + Constants . AUTO TIER ) ; expected Pool Settings Tier . add ( capabilities Path . to String ( ) + Constants . HYPHEN + Constants . HIGH AVAILABLE TIER ) ; expected Pool Settings Tier . add ( capabilities Path . to String ( ) + Constants . HYPHEN + Constants . LOW AVAILABLE TIER ) ; expected Pool Settings Tier . add ( capabilities Path . to String ( ) + Constants . HYPHEN + Constants . START HIGH THEN AUTO TIER ) ; }
public void test Exceptionally normal Completion ( ) { for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) for ( Integer v1 : new Integer [ ] { NUM , null } ) { final Atomic Integer a = new Atomic Integer ( NUM ) ; final Completable Future < Integer > f = new Completable Future < > ( ) ; if ( ! create Incomplete ) assert True ( f . complete ( v1 ) ) ; final Completable Future < Integer > g = f . exceptionally ( null ) ; if ( create Incomplete ) assert True ( f . complete ( v1 ) ) ; check Completed Normally ( g , v1 ) ; check Completed Normally ( f , v1 ) ; assert Equals ( NUM , a . get ( ) ) ; } }
private void post Buffer Access ( ) { lock . lock ( ) ; try { if ( -- buffer Use Count == NUM ) { flush Ready . signal All ( ) ; } } finally { lock . unlock ( ) ; } }
protected long copy Collection ( Collection Id collection Id , long timestamp ) throws Interrupted Exception { Atomic Long doc Count = new Atomic Long ( ) ; primary Client . execute Blocking ( STRING + collection Id + STRING , null ) ; return doc Count . get ( ) ; }
protected long copy Collection ( Collection Id collection Id , long timestamp ) throws Interrupted Exception { Atomic Long doc Count = new Atomic Long ( ) ; primary Client . execute Blocking ( STRING + collection Id + STRING , null ) ; return doc Count . get ( ) ; }
protected void reduce Parse Tree ( Compilation Unit Declaration unit ) { Type Declaration [ ] types = unit . types ; for ( int i = NUM , l = types . length ; i < l ; i ++ ) purge Method Statements ( types [ i ] , BOOL ) ; }
protected void reduce Parse Tree ( Compilation Unit Declaration unit ) { Type Declaration [ ] types = unit . types ; for ( int i = NUM , l = types . length ; i < l ; i ++ ) purge Method Statements ( types [ i ] , BOOL ) ; }
private < T > void add Provider ( @ Not Null Provider < T > provider ) throws Provider Conflict Exception { Class < T > type = provider . type ( ) ; Annotation qualifier = provider . get Qualifier ( ) ; String key = Poke Helper . make Provider Key ( type , qualifier ) ; add New Key To Component ( key , this ) ; provider . set Component ( this ) ; providers . put ( key , provider ) ; }
public static double length ( double x , double y , double z ) { return Math . sqrt ( x * x + y * y + z * z ) ; }
public void load Some Data ( Repository repo ) throws Exception { Repository Connection cxn = repo . get Connection ( ) ; cxn . set Auto Commit ( BOOL ) ; try { Resource s = new URI Impl ( STRING ) ; URI p = new URI Impl ( STRING ) ; Value o = new URI Impl ( STRING ) ; Statement stmt = new Statement Impl ( s , p , o ) ; cxn . add ( stmt ) ; cxn . commit ( ) ; } catch ( Exception ex ) { cxn . rollback ( ) ; throw ex ; } finally { cxn . close ( ) ; } }
public static Object [ ] merge Native Arrays ( Object [ ] dst , Object [ ] src , int dst Position , boolean do Power Of 2 ) { if ( dst Position < NUM ) dst Position = dst . length ; Object [ ] result = resize If Needed ( dst , dst Position + src . length , do Power Of 2 ) ; System . arraycopy ( src , NUM , result , dst Position , src . length ) ; return result ; }
private List < Type > parse Type List ( List < Map < String , Object > > types , List < Type Parameter > type Params ) { List < Type > ts = new Array List < Type > ( types . size ( ) ) ; for ( Map < String , Object > st : types ) { ts . add ( get Type From Json ( st , null , type Params ) ) ; } return ts ; }
@ Override public void on Detach ( ) { synchronized ( m Thread ) { m Progress Bar = null ; m Ready = BOOL ; m Thread . notify ( ) ; } super . on Detach ( ) ; }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null ) m Context . unbind Service ( m Service Conn ) ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; } }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null ) m Context . unbind Service ( m Service Conn ) ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; } }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null ) m Context . unbind Service ( m Service Conn ) ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; } }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null ) m Context . unbind Service ( m Service Conn ) ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; } }
private void calculate Line Height ( ) { line Height = max Ascent = NUM ; for ( int i = NUM ; i < syntax Scheme . styles . length ; i ++ ) { Style ss = syntax Scheme . styles [ i ] ; if ( ss != null && ss . font != null ) { Font Metrics fm = get Font Metrics ( ss . font ) ; int height = fm . get Height ( ) ; if ( height > line Height ) line Height = height ; int ascent = fm . get Max Ascent ( ) ; if ( ascent > max Ascent ) max Ascent = ascent ; } } Font temp = get Font ( ) ; Font Metrics fm = get Font Metrics ( temp ) ; int height = fm . get Height ( ) ; if ( height > line Height ) { line Height = height ; } int ascent = fm . get Max Ascent ( ) ; if ( ascent > max Ascent ) { max Ascent = ascent ; } }
private static int write ( int fd , byte [ ] src , int pos , int len ) throws IO Exception { int bytes = File System . write Bytes ( fd , src , pos , len ) ; if ( bytes < NUM ) throw new IO Exception ( STRING + Integer . to String ( bytes ) ) ; return bytes ; }
public Kafka Cluster add Brokers ( int count ) { if ( running ) throw new Illegal State Exception ( STRING ) ; Atomic Long added = new Atomic Long ( ) ; while ( added . int Value ( ) < count ) { kafka Servers . compute If Absent ( new Integer ( added . int Value ( ) + NUM ) , null ) ; } return this ; }
protected void add Service Listener ( SMS Entry Update Listener update Listener ) { service Objects . add ( update Listener ) ; }
protected void add Service Listener ( SMS Entry Update Listener update Listener ) { service Objects . add ( update Listener ) ; }
public boolean is Comparing ( Pdf Indirect Reference cmp Object , Pdf Indirect Reference out Object ) { return indirects . contains ( new Indirect Path Item ( cmp Object , out Object ) ) ; }
public boolean is Comparing ( Pdf Indirect Reference cmp Object , Pdf Indirect Reference out Object ) { return indirects . contains ( new Indirect Path Item ( cmp Object , out Object ) ) ; }
public boolean is Comparing ( Pdf Indirect Reference cmp Object , Pdf Indirect Reference out Object ) { return indirects . contains ( new Indirect Path Item ( cmp Object , out Object ) ) ; }
public boolean is Comparing ( Pdf Indirect Reference cmp Object , Pdf Indirect Reference out Object ) { return indirects . contains ( new Indirect Path Item ( cmp Object , out Object ) ) ; }
public boolean is Comparing ( Pdf Indirect Reference cmp Object , Pdf Indirect Reference out Object ) { return indirects . contains ( new Indirect Path Item ( cmp Object , out Object ) ) ; }
public boolean is Comparing ( Pdf Indirect Reference cmp Object , Pdf Indirect Reference out Object ) { return indirects . contains ( new Indirect Path Item ( cmp Object , out Object ) ) ; }
public boolean is Comparing ( Pdf Indirect Reference cmp Object , Pdf Indirect Reference out Object ) { return indirects . contains ( new Indirect Path Item ( cmp Object , out Object ) ) ; }
void put ( Row Cursor cursor ) { boolean is Valid ; do { is Valid = BOOL ; try ( Journal Output Stream os = open Item ( ) ) { os . write ( CODE PUT ) ; cursor . write Journal ( os ) ; is Valid = os . complete ( ) ; } catch ( IO Exception e ) { log . log ( Level . FINER , e . to String ( ) , e ) ; } } while ( ! is Valid ) ; }
public List < Colour Change > sample Conditional Migration Events 2 ( int parent Colour , double parent Height , int child Colour , double child Height , double [ ] m ) { List < Colour Change > colour Changes = new Array List < Colour Change > ( ) ; if ( parent Height < child Height ) { throw new Illegal Argument Exception ( STRING + parent Height + STRING + child Height + STRING ) ; } try { int current Colour = parent Colour ; double current Height = parent Height ; while ( BOOL ) { Colour Change next Event = random Conditional Migration Event ( current Colour , current Height , child Colour , child Height , m ) ; current Height = next Event . get Time ( ) ; current Colour = next Event . get Colour Above ( ) ; colour Changes . add ( next Event ) ; } } catch ( No Event Exception nee ) { } reverse Colour Change List ( colour Changes , parent Colour ) ; return colour Changes ; }
public void stop ( ) { logger . info ( STRING ) ; if ( thrift Server != null ) thrift Server . stop ( ) ; if ( native Server != null ) native Server . stop ( ) ; if ( FB Utilities . is Windows ( ) ) System . exit ( NUM ) ; if ( jmx Server != null ) { try { jmx Server . stop ( ) ; } catch ( IO Exception e ) { logger . error ( STRING , e ) ; } } }
public void stop ( ) { logger . info ( STRING ) ; if ( thrift Server != null ) thrift Server . stop ( ) ; if ( native Server != null ) native Server . stop ( ) ; if ( FB Utilities . is Windows ( ) ) System . exit ( NUM ) ; if ( jmx Server != null ) { try { jmx Server . stop ( ) ; } catch ( IO Exception e ) { logger . error ( STRING , e ) ; } } }
public void draw Text ( @ Non Null Canvas canvas , Rect F bounds , float percent Complete ) { if ( m Text != null && m Text . length ( ) > NUM ) { m Paint Text . set Text Size ( NUM * percent Complete ) ; m Paint Text . set Alpha ( MAX ALPHA ) ; final float start Fade Percent = NUM ; if ( percent Complete > start Fade Percent ) { int alpha Text = ( int ) ( MAX ALPHA - ( MAX ALPHA * ( ( percent Complete - start Fade Percent ) / ( NUM - start Fade Percent ) ) ) ) ; m Paint Text . set Alpha ( alpha Text ) ; } final float x Pos = bounds . left + ( bounds . width ( ) / NUM ) ; final float y Pos = ( bounds . top + ( bounds . height ( ) / NUM ) ) - ( ( m Paint Text . descent ( ) + m Paint Text . ascent ( ) ) / NUM ) ; canvas . draw Text ( m Text , x Pos , y Pos , m Paint Text ) ; } }
@ Override public void stop All Mutators ( ) { Trace . trace ( Item . SCHEDULER , STRING ) ; synchronized ( trigger ) { set State ( BLOCKING ) ; trigger . notify All ( ) ; } wait For GC Start ( ) ; Trace . trace ( Item . SCHEDULER , STRING ) ; }
public static void create Destination Folder ( String path ) { File fpath = new File ( path ) ; fpath . mkdirs ( ) ; }
private void build Linear Model ( int [ ] indices ) throws Exception { Instances reduced Inst = new Instances ( m instances ) ; Remove attribute Filter = new Remove ( ) ; attribute Filter . set Invert Selection ( BOOL ) ; attribute Filter . set Attribute Indices Array ( indices ) ; attribute Filter . set Input Format ( reduced Inst ) ; reduced Inst = Filter . use Filter ( reduced Inst , attribute Filter ) ; Linear Regression temp = new Linear Regression ( ) ; temp . build Classifier ( reduced Inst ) ; double [ ] lm Coeffs = temp . coefficients ( ) ; double [ ] coeffs = new double [ m instances . num Attributes ( ) ] ; for ( int i = NUM ; i < lm Coeffs . length - NUM ; i ++ ) { if ( indices [ i ] != m class Index ) { coeffs [ indices [ i ] ] = lm Coeffs [ i ] ; } } m node Model = new Pre Constructed Linear Model ( coeffs , lm Coeffs [ lm Coeffs . length - NUM ] ) ; m node Model . build Classifier ( m instances ) ; }
private void build Linear Model ( int [ ] indices ) throws Exception { Instances reduced Inst = new Instances ( m instances ) ; Remove attribute Filter = new Remove ( ) ; attribute Filter . set Invert Selection ( BOOL ) ; attribute Filter . set Attribute Indices Array ( indices ) ; attribute Filter . set Input Format ( reduced Inst ) ; reduced Inst = Filter . use Filter ( reduced Inst , attribute Filter ) ; Linear Regression temp = new Linear Regression ( ) ; temp . build Classifier ( reduced Inst ) ; double [ ] lm Coeffs = temp . coefficients ( ) ; double [ ] coeffs = new double [ m instances . num Attributes ( ) ] ; for ( int i = NUM ; i < lm Coeffs . length - NUM ; i ++ ) { if ( indices [ i ] != m class Index ) { coeffs [ indices [ i ] ] = lm Coeffs [ i ] ; } } m node Model = new Pre Constructed Linear Model ( coeffs , lm Coeffs [ lm Coeffs . length - NUM ] ) ; m node Model . build Classifier ( m instances ) ; }
private void build Linear Model ( int [ ] indices ) throws Exception { Instances reduced Inst = new Instances ( m instances ) ; Remove attribute Filter = new Remove ( ) ; attribute Filter . set Invert Selection ( BOOL ) ; attribute Filter . set Attribute Indices Array ( indices ) ; attribute Filter . set Input Format ( reduced Inst ) ; reduced Inst = Filter . use Filter ( reduced Inst , attribute Filter ) ; Linear Regression temp = new Linear Regression ( ) ; temp . build Classifier ( reduced Inst ) ; double [ ] lm Coeffs = temp . coefficients ( ) ; double [ ] coeffs = new double [ m instances . num Attributes ( ) ] ; for ( int i = NUM ; i < lm Coeffs . length - NUM ; i ++ ) { if ( indices [ i ] != m class Index ) { coeffs [ indices [ i ] ] = lm Coeffs [ i ] ; } } m node Model = new Pre Constructed Linear Model ( coeffs , lm Coeffs [ lm Coeffs . length - NUM ] ) ; m node Model . build Classifier ( m instances ) ; }
private void build Linear Model ( int [ ] indices ) throws Exception { Instances reduced Inst = new Instances ( m instances ) ; Remove attribute Filter = new Remove ( ) ; attribute Filter . set Invert Selection ( BOOL ) ; attribute Filter . set Attribute Indices Array ( indices ) ; attribute Filter . set Input Format ( reduced Inst ) ; reduced Inst = Filter . use Filter ( reduced Inst , attribute Filter ) ; Linear Regression temp = new Linear Regression ( ) ; temp . build Classifier ( reduced Inst ) ; double [ ] lm Coeffs = temp . coefficients ( ) ; double [ ] coeffs = new double [ m instances . num Attributes ( ) ] ; for ( int i = NUM ; i < lm Coeffs . length - NUM ; i ++ ) { if ( indices [ i ] != m class Index ) { coeffs [ indices [ i ] ] = lm Coeffs [ i ] ; } } m node Model = new Pre Constructed Linear Model ( coeffs , lm Coeffs [ lm Coeffs . length - NUM ] ) ; m node Model . build Classifier ( m instances ) ; }
private void paint Directly ( Graphics 2 D g , J Component c , int w , int h , Object [ ] extended Cache Keys ) { g = ( Graphics 2 D ) g . create ( ) ; configure Graphics ( g ) ; do Paint ( g , c , w , h , extended Cache Keys ) ; g . dispose ( ) ; }
private void paint Directly ( Graphics 2 D g , J Component c , int w , int h , Object [ ] extended Cache Keys ) { g = ( Graphics 2 D ) g . create ( ) ; configure Graphics ( g ) ; do Paint ( g , c , w , h , extended Cache Keys ) ; g . dispose ( ) ; }
private void paint Directly ( Graphics 2 D g , J Component c , int w , int h , Object [ ] extended Cache Keys ) { g = ( Graphics 2 D ) g . create ( ) ; configure Graphics ( g ) ; do Paint ( g , c , w , h , extended Cache Keys ) ; g . dispose ( ) ; }
private void paint Directly ( Graphics 2 D g , J Component c , int w , int h , Object [ ] extended Cache Keys ) { g = ( Graphics 2 D ) g . create ( ) ; configure Graphics ( g ) ; do Paint ( g , c , w , h , extended Cache Keys ) ; g . dispose ( ) ; }
private void paint Directly ( Graphics 2 D g , J Component c , int w , int h , Object [ ] extended Cache Keys ) { g = ( Graphics 2 D ) g . create ( ) ; configure Graphics ( g ) ; do Paint ( g , c , w , h , extended Cache Keys ) ; g . dispose ( ) ; }
private void paint Directly ( Graphics 2 D g , J Component c , int w , int h , Object [ ] extended Cache Keys ) { g = ( Graphics 2 D ) g . create ( ) ; configure Graphics ( g ) ; do Paint ( g , c , w , h , extended Cache Keys ) ; g . dispose ( ) ; }
private void paint Directly ( Graphics 2 D g , J Component c , int w , int h , Object [ ] extended Cache Keys ) { g = ( Graphics 2 D ) g . create ( ) ; configure Graphics ( g ) ; do Paint ( g , c , w , h , extended Cache Keys ) ; g . dispose ( ) ; }
private void paint Directly ( Graphics 2 D g , J Component c , int w , int h , Object [ ] extended Cache Keys ) { g = ( Graphics 2 D ) g . create ( ) ; configure Graphics ( g ) ; do Paint ( g , c , w , h , extended Cache Keys ) ; g . dispose ( ) ; }
private void paint Directly ( Graphics 2 D g , J Component c , int w , int h , Object [ ] extended Cache Keys ) { g = ( Graphics 2 D ) g . create ( ) ; configure Graphics ( g ) ; do Paint ( g , c , w , h , extended Cache Keys ) ; g . dispose ( ) ; }
private void paint Directly ( Graphics 2 D g , J Component c , int w , int h , Object [ ] extended Cache Keys ) { g = ( Graphics 2 D ) g . create ( ) ; configure Graphics ( g ) ; do Paint ( g , c , w , h , extended Cache Keys ) ; g . dispose ( ) ; }
private void paint Directly ( Graphics 2 D g , J Component c , int w , int h , Object [ ] extended Cache Keys ) { g = ( Graphics 2 D ) g . create ( ) ; configure Graphics ( g ) ; do Paint ( g , c , w , h , extended Cache Keys ) ; g . dispose ( ) ; }
public Date parse ( String text ) throws Parser Exception { text = text . trim ( ) ; int length = text . length ( ) ; if ( length == LONG DATE FORMAT . length ( ) ) { return parse ( text , LONG DATE FORMAT ) ; } if ( length == MEDIUM DATE FORMAT . length ( ) ) { return parse ( text , MEDIUM DATE FORMAT ) ; } return parse ( text , SHORT DATE FORMAT ) ; }
private boolean remove Groups Int ( String [ ] old Groups ) { boolean removed = BOOL ; for ( int i = NUM ; i < old Groups . length ; i ++ ) { removed |= groups . remove ( old Groups [ i ] ) ; } return removed ; }
private boolean remove Groups Int ( String [ ] old Groups ) { boolean removed = BOOL ; for ( int i = NUM ; i < old Groups . length ; i ++ ) { removed |= groups . remove ( old Groups [ i ] ) ; } return removed ; }
private DD compute E By Taylor Series ( ) { DD s = DD . value Of ( NUM ) ; DD t = DD . value Of ( NUM ) ; double n = NUM ; int i = NUM ; while ( t . double Value ( ) > DD . EPS ) { i ++ ; n += NUM ; t = t . divide ( DD . value Of ( n ) ) ; s = s . add ( t ) ; } return s ; }
private DD compute E By Taylor Series ( ) { DD s = DD . value Of ( NUM ) ; DD t = DD . value Of ( NUM ) ; double n = NUM ; int i = NUM ; while ( t . double Value ( ) > DD . EPS ) { i ++ ; n += NUM ; t = t . divide ( DD . value Of ( n ) ) ; s = s . add ( t ) ; } return s ; }
public static Event Bean [ ] add To Array ( Event Bean [ ] array , Event Bean event To Add ) { Event Bean [ ] new Array = new Event Bean [ array . length + NUM ] ; System . arraycopy ( array , NUM , new Array , NUM , array . length ) ; new Array [ new Array . length - NUM ] = event To Add ; return new Array ; }
public static Event Bean [ ] add To Array ( Event Bean [ ] array , Event Bean event To Add ) { Event Bean [ ] new Array = new Event Bean [ array . length + NUM ] ; System . arraycopy ( array , NUM , new Array , NUM , array . length ) ; new Array [ new Array . length - NUM ] = event To Add ; return new Array ; }
public Vector < Report > resolve Action ( I Game game ) { Vector < Report > reports = new Vector < Report > ( ) ; Report r ; if ( ! is Possible ( game ) ) { r = new Report ( NUM ) ; r . subject = get Entity Id ( ) ; r . newlines = NUM ; reports . add Element ( r ) ; return reports ; } final Entity attacker = get Entity ( game ) ; final Coords apos = attacker . get Position ( ) ; final Targetable target = get Target ( game ) ; final Coords tpos = target . get Position ( ) ; if ( attacker . used Searchlight ( ) ) { r = new Report ( NUM ) ; r . subject = get Entity Id ( ) ; r . add ( attacker . get Display Name ( ) ) ; r . newlines = NUM ; reports . add Element ( r ) ; return reports ; } attacker . set Used Searchlight ( BOOL ) ; Array List < Coords > in = Coords . intervening ( apos , tpos ) ; for ( Coords c : in ) { for ( Entity en : game . get Entities Vector ( c ) ) { Los Effects los = Los Effects . calculate Los ( game , get Entity Id ( ) , en ) ; if ( los . can See ( ) ) { en . set Illuminated ( BOOL ) ; r = new Report ( NUM ) ; r . subject = get Entity Id ( ) ; r . newlines = NUM ; r . add ( en . get Display Name ( ) ) ; r . add ( attacker . get Display Name ( ) ) ; reports . add Element ( r ) ; } } } return reports ; }
private Json Scope peek ( ) { return stack . get ( stack . size ( ) - NUM ) ; }
private Json Scope peek ( ) { return stack . get ( stack . size ( ) - NUM ) ; }
@ Override public Update Request routing ( String routing ) { if ( routing != null && routing . length ( ) == NUM ) { this . routing = null ; } else { this . routing = routing ; } return this ; }
@ Override public Update Request routing ( String routing ) { if ( routing != null && routing . length ( ) == NUM ) { this . routing = null ; } else { this . routing = routing ; } return this ; }
@ Override public Update Request routing ( String routing ) { if ( routing != null && routing . length ( ) == NUM ) { this . routing = null ; } else { this . routing = routing ; } return this ; }
private void initialize ( ) throws IO Exception { if ( secondary Joiners != null ) { return ; } primary Joiners Chk Up = new Array List < Joiner > ( NUM ) ; primary Joiners Chk Del = new Array List < Joiner > ( NUM ) ; primary Joiners Do Up = new Array List < Joiner > ( NUM ) ; primary Joiners Do Del = new Array List < Joiner > ( NUM ) ; primary Joiners Do Null = new Array List < Joiner > ( NUM ) ; secondary Joiners = new Array List < Joiner > ( NUM ) ; for ( Index Impl idx : table . get Indexes ( ) ) { Index Impl . Foreign Key Reference ref = idx . get Reference ( ) ; if ( ref != null ) { Joiner joiner = Joiner . create ( idx ) ; if ( ref . is Primary Table ( ) ) { if ( ref . is Cascade Updates ( ) ) { primary Joiners Do Up . add ( joiner ) ; } else { primary Joiners Chk Up . add ( joiner ) ; } if ( ref . is Cascade Deletes ( ) ) { primary Joiners Do Del . add ( joiner ) ; } else if ( ref . is Cascade Null On Delete ( ) ) { primary Joiners Do Null . add ( joiner ) ; } else { primary Joiners Chk Del . add ( joiner ) ; } } else { secondary Joiners . add ( joiner ) ; } } } }
public Builder add Listen Urls ( List < String > urls ) { List < String > need Add = new Array List < String > ( ) ; for ( String url : urls ) { if ( ! Url Util . is Url ( url ) ) { continue ; } need Add . add ( url ) ; } if ( ! Collection Util . is Empty ( need Add ) ) { if ( m Listen Urls == null ) { m Listen Urls = new Hash Set < String > ( ) ; } m Listen Urls . add All ( need Add ) ; } return this ; }
void draw Ball ( ) { Ball ball = m Ball ; float saved X = ball . get X Position ( ) ; float saved Y = ball . get Y Position ( ) ; float radius = ball . get Radius ( ) ; float xpos = BORDER WIDTH * NUM + radius ; float ypos = BORDER WIDTH + radius ; int lives = m Lives Remaining ; boolean ball Is Live = ( m Game Play State != GAME INITIALIZING && m Game Play State != GAME READY ) ; if ( ball Is Live ) { lives -- ; } for ( int i = NUM ; i < lives ; i ++ ) { float jitter X = NUM ; float jitter Y = NUM ; if ( m Live Brick Count > NUM && m Live Brick Count < NUM ) { jitter X = ( float ) ( ( NUM - m Live Brick Count ) * ( Math . random ( ) - NUM ) * NUM ) ; jitter Y = ( float ) ( ( NUM - m Live Brick Count ) * ( Math . random ( ) - NUM ) * NUM ) ; } ball . set Position ( xpos + jitter X , ypos + jitter Y ) ; ball . draw ( ) ; xpos += radius * NUM ; } ball . set Position ( saved X , saved Y ) ; if ( ball Is Live ) { ball . draw ( ) ; } }
private Iterator < Date > std lower bound ( final Date date ) { final List < Date > ldates = new Array List < Date > ( ) ; if ( dates . size ( ) > NUM ) { int index = - NUM ; for ( int i = NUM ; i < dates . size ( ) ; i ++ ) { final Date d = dates . get ( i ) ; if ( d . equals ( date ) ) { index = i ; break ; } } if ( index > NUM ) { for ( int i = index ; i < dates . size ( ) ; i ++ ) { ldates . add ( dates . get ( i ) ) ; } return ldates . iterator ( ) ; } } return ldates . iterator ( ) ; }
private Iterator < Date > std lower bound ( final Date date ) { final List < Date > ldates = new Array List < Date > ( ) ; if ( dates . size ( ) > NUM ) { int index = - NUM ; for ( int i = NUM ; i < dates . size ( ) ; i ++ ) { final Date d = dates . get ( i ) ; if ( d . equals ( date ) ) { index = i ; break ; } } if ( index > NUM ) { for ( int i = index ; i < dates . size ( ) ; i ++ ) { ldates . add ( dates . get ( i ) ) ; } return ldates . iterator ( ) ; } } return ldates . iterator ( ) ; }
private Iterator < Date > std lower bound ( final Date date ) { final List < Date > ldates = new Array List < Date > ( ) ; if ( dates . size ( ) > NUM ) { int index = - NUM ; for ( int i = NUM ; i < dates . size ( ) ; i ++ ) { final Date d = dates . get ( i ) ; if ( d . equals ( date ) ) { index = i ; break ; } } if ( index > NUM ) { for ( int i = index ; i < dates . size ( ) ; i ++ ) { ldates . add ( dates . get ( i ) ) ; } return ldates . iterator ( ) ; } } return ldates . iterator ( ) ; }
private Iterator < Date > std lower bound ( final Date date ) { final List < Date > ldates = new Array List < Date > ( ) ; if ( dates . size ( ) > NUM ) { int index = - NUM ; for ( int i = NUM ; i < dates . size ( ) ; i ++ ) { final Date d = dates . get ( i ) ; if ( d . equals ( date ) ) { index = i ; break ; } } if ( index > NUM ) { for ( int i = index ; i < dates . size ( ) ; i ++ ) { ldates . add ( dates . get ( i ) ) ; } return ldates . iterator ( ) ; } } return ldates . iterator ( ) ; }
public Access Token ( final String token , final String type , final long initial Valid Seconds , final Date valid Until ) { this ( token , type , initial Valid Seconds , valid Until , System . current Time Millis ( ) ) ; }
@ Suppress Warnings ( { STRING } ) public static boolean contains All ( Map < ? , ? > base , Map < ? , ? > map ) { assert base != null ; assert map != null ; for ( Map . Entry < ? , ? > entry : map . entry Set ( ) ) if ( base . contains Key ( entry . get Key ( ) ) ) { Object val = base . get ( entry . get Key ( ) ) ; if ( val == null && entry . get Value ( ) == null ) continue ; if ( val == null || entry . get Value ( ) == null || ! val . equals ( entry . get Value ( ) ) ) return BOOL ; } else return BOOL ; return BOOL ; }
@ Suppress Warnings ( { STRING } ) public static boolean contains All ( Map < ? , ? > base , Map < ? , ? > map ) { assert base != null ; assert map != null ; for ( Map . Entry < ? , ? > entry : map . entry Set ( ) ) if ( base . contains Key ( entry . get Key ( ) ) ) { Object val = base . get ( entry . get Key ( ) ) ; if ( val == null && entry . get Value ( ) == null ) continue ; if ( val == null || entry . get Value ( ) == null || ! val . equals ( entry . get Value ( ) ) ) return BOOL ; } else return BOOL ; return BOOL ; }
@ Suppress Warnings ( { STRING } ) public static boolean contains All ( Map < ? , ? > base , Map < ? , ? > map ) { assert base != null ; assert map != null ; for ( Map . Entry < ? , ? > entry : map . entry Set ( ) ) if ( base . contains Key ( entry . get Key ( ) ) ) { Object val = base . get ( entry . get Key ( ) ) ; if ( val == null && entry . get Value ( ) == null ) continue ; if ( val == null || entry . get Value ( ) == null || ! val . equals ( entry . get Value ( ) ) ) return BOOL ; } else return BOOL ; return BOOL ; }
public Boyer Moore ( String pat ) { this . R = NUM ; this . pat = pat ; right = new int [ R ] ; for ( int c = NUM ; c < R ; c ++ ) right [ c ] = - NUM ; for ( int j = NUM ; j < pat . length ( ) ; j ++ ) right [ pat . char At ( j ) ] = j ; }
private void draw X Tick ( Graphics grahics ) { grahics . set Font ( scale . get Font ( ) ) ; for ( int i = NUM ; i < tick Label Positions . size ( ) ; i ++ ) { if ( tick Visibilities . get ( i ) == BOOL ) { String text = tick Labels . get ( i ) ; int font Width = Figure Utilities . get Text Extents ( text , get Font ( ) ) . width ; int x = ( int ) Math . ceil ( tick Label Positions . get ( i ) - font Width / NUM ) ; grahics . draw Text ( text , x , NUM ) ; } } }
public < E , D > void add Mapped Entity Class ( Class < E > entity Class , Class < D > dto Class , Jpa Mapper < E , D > mapper ) { check Not Initialized ( ) ; if ( mappings . contains Key ( dto Class ) ) { throw new Illegal Argument Exception ( dto Class . get Name ( ) + STRING ) ; } mappings . put ( dto Class , new Mapped Registration < > ( entity Class , dto Class , mapper ) ) ; }
public < E , D > void add Mapped Entity Class ( Class < E > entity Class , Class < D > dto Class , Jpa Mapper < E , D > mapper ) { check Not Initialized ( ) ; if ( mappings . contains Key ( dto Class ) ) { throw new Illegal Argument Exception ( dto Class . get Name ( ) + STRING ) ; } mappings . put ( dto Class , new Mapped Registration < > ( entity Class , dto Class , mapper ) ) ; }
private void update Wave File Size ( ) throws IO Exception { Byte Buffer buffer = get Unsigned Integer Buffer ( m File Channel . size ( ) - NUM ) ; m File Channel . write ( buffer , NUM ) ; Byte Buffer buffer 2 = get Unsigned Integer Buffer ( m File Channel . size ( ) - NUM ) ; m File Channel . write ( buffer 2 , NUM ) ; }
private void scene Recognize ( ) { Log . d ( TAG , STRING ) ; m Action = Vision Action . Scene Recognition ; lock Focus ( ) ; }
public void initialize ( Uima Context a Context ) { annotate tokens = ( Boolean ) a Context . get Config Parameter Value ( PARAM ANNOTATE TOKENS ) ; annotate sentences = ( Boolean ) a Context . get Config Parameter Value ( PARAM ANNOTATE SENTENCES ) ; annotate partofspeech = ( Boolean ) a Context . get Config Parameter Value ( PARAM ANNOTATE PARTOFSPEECH ) ; model path = ( String ) a Context . get Config Parameter Value ( PARAM MODEL PATH ) ; config path = ( String ) a Context . get Config Parameter Value ( PARAM CONFIG PATH ) ; if ( model path == null ) { Logger . print Error ( component , STRING ) ; System . exit ( - NUM ) ; } try { if ( config path != null ) { File Input Stream isr = new File Input Stream ( config path ) ; Properties props = new Properties ( ) ; props . load ( isr ) ; mt = new Maxent Tagger ( model path , new Tagger Config ( props ) , BOOL ) ; } else { mt = new Maxent Tagger ( model path , new Tagger Config ( STRING , model path ) , BOOL ) ; } } catch ( Exception e ) { e . print Stack Trace ( ) ; Logger . print Error ( component , STRING + model path + STRING + config path + STRING ) ; System . exit ( - NUM ) ; } }
public void initialize ( Uima Context a Context ) { annotate tokens = ( Boolean ) a Context . get Config Parameter Value ( PARAM ANNOTATE TOKENS ) ; annotate sentences = ( Boolean ) a Context . get Config Parameter Value ( PARAM ANNOTATE SENTENCES ) ; annotate partofspeech = ( Boolean ) a Context . get Config Parameter Value ( PARAM ANNOTATE PARTOFSPEECH ) ; model path = ( String ) a Context . get Config Parameter Value ( PARAM MODEL PATH ) ; config path = ( String ) a Context . get Config Parameter Value ( PARAM CONFIG PATH ) ; if ( model path == null ) { Logger . print Error ( component , STRING ) ; System . exit ( - NUM ) ; } try { if ( config path != null ) { File Input Stream isr = new File Input Stream ( config path ) ; Properties props = new Properties ( ) ; props . load ( isr ) ; mt = new Maxent Tagger ( model path , new Tagger Config ( props ) , BOOL ) ; } else { mt = new Maxent Tagger ( model path , new Tagger Config ( STRING , model path ) , BOOL ) ; } } catch ( Exception e ) { e . print Stack Trace ( ) ; Logger . print Error ( component , STRING + model path + STRING + config path + STRING ) ; System . exit ( - NUM ) ; } }
public void initialize ( Uima Context a Context ) { annotate tokens = ( Boolean ) a Context . get Config Parameter Value ( PARAM ANNOTATE TOKENS ) ; annotate sentences = ( Boolean ) a Context . get Config Parameter Value ( PARAM ANNOTATE SENTENCES ) ; annotate partofspeech = ( Boolean ) a Context . get Config Parameter Value ( PARAM ANNOTATE PARTOFSPEECH ) ; model path = ( String ) a Context . get Config Parameter Value ( PARAM MODEL PATH ) ; config path = ( String ) a Context . get Config Parameter Value ( PARAM CONFIG PATH ) ; if ( model path == null ) { Logger . print Error ( component , STRING ) ; System . exit ( - NUM ) ; } try { if ( config path != null ) { File Input Stream isr = new File Input Stream ( config path ) ; Properties props = new Properties ( ) ; props . load ( isr ) ; mt = new Maxent Tagger ( model path , new Tagger Config ( props ) , BOOL ) ; } else { mt = new Maxent Tagger ( model path , new Tagger Config ( STRING , model path ) , BOOL ) ; } } catch ( Exception e ) { e . print Stack Trace ( ) ; Logger . print Error ( component , STRING + model path + STRING + config path + STRING ) ; System . exit ( - NUM ) ; } }
public String encode ( byte [ ] input , boolean add Quotes ) { int input End = input . length ; String Builder sb ; { int output Len = input End + ( input End > > NUM ) + ( input End > > NUM ) ; sb = new String Builder ( output Len ) ; } if ( add Quotes ) { sb . append ( STRING ) ; } int chunks Before LF = get Max Line Length ( ) > > NUM ; int input Ptr = NUM ; int safe Input End = input End - NUM ; while ( input Ptr <= safe Input End ) { int b24 = ( ( int ) input [ input Ptr ++ ] ) << NUM ; b24 |= ( ( int ) input [ input Ptr ++ ] ) & NUM ; b24 = ( b24 << NUM ) | ( ( ( int ) input [ input Ptr ++ ] ) & NUM ) ; encode Base 64 Chunk ( sb , b24 ) ; if ( -- chunks Before LF <= NUM ) { sb . append ( STRING ) ; sb . append ( STRING ) ; chunks Before LF = get Max Line Length ( ) > > NUM ; } } int input Left = input End - input Ptr ; if ( input Left > NUM ) { int b24 = ( ( int ) input [ input Ptr ++ ] ) << NUM ; if ( input Left == NUM ) { b24 |= ( ( ( int ) input [ input Ptr ++ ] ) & NUM ) << NUM ; } encode Base 64 Partial ( sb , b24 , input Left ) ; } if ( add Quotes ) { sb . append ( STRING ) ; } return sb . to String ( ) ; }
public String encode ( byte [ ] input , boolean add Quotes ) { int input End = input . length ; String Builder sb ; { int output Len = input End + ( input End > > NUM ) + ( input End > > NUM ) ; sb = new String Builder ( output Len ) ; } if ( add Quotes ) { sb . append ( STRING ) ; } int chunks Before LF = get Max Line Length ( ) > > NUM ; int input Ptr = NUM ; int safe Input End = input End - NUM ; while ( input Ptr <= safe Input End ) { int b24 = ( ( int ) input [ input Ptr ++ ] ) << NUM ; b24 |= ( ( int ) input [ input Ptr ++ ] ) & NUM ; b24 = ( b24 << NUM ) | ( ( ( int ) input [ input Ptr ++ ] ) & NUM ) ; encode Base 64 Chunk ( sb , b24 ) ; if ( -- chunks Before LF <= NUM ) { sb . append ( STRING ) ; sb . append ( STRING ) ; chunks Before LF = get Max Line Length ( ) > > NUM ; } } int input Left = input End - input Ptr ; if ( input Left > NUM ) { int b24 = ( ( int ) input [ input Ptr ++ ] ) << NUM ; if ( input Left == NUM ) { b24 |= ( ( ( int ) input [ input Ptr ++ ] ) & NUM ) << NUM ; } encode Base 64 Partial ( sb , b24 , input Left ) ; } if ( add Quotes ) { sb . append ( STRING ) ; } return sb . to String ( ) ; }
public void add Edit Pop Up Menu ( J Menu Item menu ) { if ( ! edit Additional Menu . contains ( menu ) ) { edit Additional Menu . add ( menu ) ; } }
public void add Edit Pop Up Menu ( J Menu Item menu ) { if ( ! edit Additional Menu . contains ( menu ) ) { edit Additional Menu . add ( menu ) ; } }
protected void handle Render Exception ( Faces Context context , Exception e ) throws IO Exception { if ( LOGGER . is Loggable ( Level . SEVERE ) ) { UI View Root root = context . get View Root ( ) ; String Buffer sb = new String Buffer ( NUM ) ; sb . append ( STRING ) ; if ( root != null ) { sb . append ( STRING ) ; sb . append ( root . get View Id ( ) ) ; sb . append ( STRING ) ; } LOGGER . log ( Level . SEVERE , sb . to String ( ) , e ) ; } if ( e instanceof Runtime Exception ) { throw ( Runtime Exception ) e ; } else if ( e instanceof IO Exception ) { throw ( IO Exception ) e ; } else { throw new Faces Exception ( e . get Message ( ) , e ) ; } }
protected void handle Render Exception ( Faces Context context , Exception e ) throws IO Exception { if ( LOGGER . is Loggable ( Level . SEVERE ) ) { UI View Root root = context . get View Root ( ) ; String Buffer sb = new String Buffer ( NUM ) ; sb . append ( STRING ) ; if ( root != null ) { sb . append ( STRING ) ; sb . append ( root . get View Id ( ) ) ; sb . append ( STRING ) ; } LOGGER . log ( Level . SEVERE , sb . to String ( ) , e ) ; } if ( e instanceof Runtime Exception ) { throw ( Runtime Exception ) e ; } else if ( e instanceof IO Exception ) { throw ( IO Exception ) e ; } else { throw new Faces Exception ( e . get Message ( ) , e ) ; } }
protected void handle Render Exception ( Faces Context context , Exception e ) throws IO Exception { if ( LOGGER . is Loggable ( Level . SEVERE ) ) { UI View Root root = context . get View Root ( ) ; String Buffer sb = new String Buffer ( NUM ) ; sb . append ( STRING ) ; if ( root != null ) { sb . append ( STRING ) ; sb . append ( root . get View Id ( ) ) ; sb . append ( STRING ) ; } LOGGER . log ( Level . SEVERE , sb . to String ( ) , e ) ; } if ( e instanceof Runtime Exception ) { throw ( Runtime Exception ) e ; } else if ( e instanceof IO Exception ) { throw ( IO Exception ) e ; } else { throw new Faces Exception ( e . get Message ( ) , e ) ; } }
protected void handle Render Exception ( Faces Context context , Exception e ) throws IO Exception { if ( LOGGER . is Loggable ( Level . SEVERE ) ) { UI View Root root = context . get View Root ( ) ; String Buffer sb = new String Buffer ( NUM ) ; sb . append ( STRING ) ; if ( root != null ) { sb . append ( STRING ) ; sb . append ( root . get View Id ( ) ) ; sb . append ( STRING ) ; } LOGGER . log ( Level . SEVERE , sb . to String ( ) , e ) ; } if ( e instanceof Runtime Exception ) { throw ( Runtime Exception ) e ; } else if ( e instanceof IO Exception ) { throw ( IO Exception ) e ; } else { throw new Faces Exception ( e . get Message ( ) , e ) ; } }
@ Override public Path Impl lookup Impl ( String user Path , Map < String , Object > new Attributes , boolean is Allow Root ) { String new Path ; if ( user Path == null ) return root . fs Walk ( get Path ( ) , new Attributes , STRING ) ; int length = user Path . length ( ) ; int colon = user Path . index Of ( STRING ) ; int slash = user Path . index Of ( STRING ) ; int query = user Path . index Of ( STRING ) ; if ( colon != - NUM && ( colon < slash || slash == - NUM ) ) return super . lookup Impl ( user Path , new Attributes , is Allow Root ) ; if ( slash == NUM && length > NUM && user Path . char At ( NUM ) == STRING ) return scheme Walk ( user Path , new Attributes , user Path , NUM ) ; else if ( slash == NUM ) { String query String = STRING ; if ( query >= NUM ) { query String = user Path . substring ( query ) ; user Path = user Path . substring ( NUM , query ) ; } new Path = normalize Path ( STRING , user Path , NUM , STRING ) ; if ( query >= NUM ) new Path += query String ; } else { String query String = STRING ; if ( query >= NUM ) { query String = user Path . substring ( query ) ; user Path = user Path . substring ( NUM , query ) ; } new Path = normalize Path ( pathname , user Path , NUM , STRING ) ; if ( query >= NUM ) new Path += query String ; } return root . fs Walk ( user Path , new Attributes , new Path ) ; }
@ Override public Path Impl lookup Impl ( String user Path , Map < String , Object > new Attributes , boolean is Allow Root ) { String new Path ; if ( user Path == null ) return root . fs Walk ( get Path ( ) , new Attributes , STRING ) ; int length = user Path . length ( ) ; int colon = user Path . index Of ( STRING ) ; int slash = user Path . index Of ( STRING ) ; int query = user Path . index Of ( STRING ) ; if ( colon != - NUM && ( colon < slash || slash == - NUM ) ) return super . lookup Impl ( user Path , new Attributes , is Allow Root ) ; if ( slash == NUM && length > NUM && user Path . char At ( NUM ) == STRING ) return scheme Walk ( user Path , new Attributes , user Path , NUM ) ; else if ( slash == NUM ) { String query String = STRING ; if ( query >= NUM ) { query String = user Path . substring ( query ) ; user Path = user Path . substring ( NUM , query ) ; } new Path = normalize Path ( STRING , user Path , NUM , STRING ) ; if ( query >= NUM ) new Path += query String ; } else { String query String = STRING ; if ( query >= NUM ) { query String = user Path . substring ( query ) ; user Path = user Path . substring ( NUM , query ) ; } new Path = normalize Path ( pathname , user Path , NUM , STRING ) ; if ( query >= NUM ) new Path += query String ; } return root . fs Walk ( user Path , new Attributes , new Path ) ; }
@ Override public Path Impl lookup Impl ( String user Path , Map < String , Object > new Attributes , boolean is Allow Root ) { String new Path ; if ( user Path == null ) return root . fs Walk ( get Path ( ) , new Attributes , STRING ) ; int length = user Path . length ( ) ; int colon = user Path . index Of ( STRING ) ; int slash = user Path . index Of ( STRING ) ; int query = user Path . index Of ( STRING ) ; if ( colon != - NUM && ( colon < slash || slash == - NUM ) ) return super . lookup Impl ( user Path , new Attributes , is Allow Root ) ; if ( slash == NUM && length > NUM && user Path . char At ( NUM ) == STRING ) return scheme Walk ( user Path , new Attributes , user Path , NUM ) ; else if ( slash == NUM ) { String query String = STRING ; if ( query >= NUM ) { query String = user Path . substring ( query ) ; user Path = user Path . substring ( NUM , query ) ; } new Path = normalize Path ( STRING , user Path , NUM , STRING ) ; if ( query >= NUM ) new Path += query String ; } else { String query String = STRING ; if ( query >= NUM ) { query String = user Path . substring ( query ) ; user Path = user Path . substring ( NUM , query ) ; } new Path = normalize Path ( pathname , user Path , NUM , STRING ) ; if ( query >= NUM ) new Path += query String ; } return root . fs Walk ( user Path , new Attributes , new Path ) ; }
@ Override public boolean batch Finished ( ) { if ( get Input Format ( ) == null ) { throw new Illegal State Exception ( STRING ) ; } Instances to Filter = get Input Format ( ) ; int cut Off = ( int ) Math . round ( to Filter . num Instances ( ) * m Percentage / NUM ) ; if ( m Inverse ) { for ( int i = NUM ; i < cut Off ; i ++ ) { push ( to Filter . instance ( i ) ) ; } } else { for ( int i = cut Off ; i < to Filter . num Instances ( ) ; i ++ ) { push ( to Filter . instance ( i ) ) ; } } flush Input ( ) ; m New Batch = BOOL ; m First Batch Done = BOOL ; return ( num Pending Output ( ) != NUM ) ; }
@ Override public boolean batch Finished ( ) { if ( get Input Format ( ) == null ) { throw new Illegal State Exception ( STRING ) ; } Instances to Filter = get Input Format ( ) ; int cut Off = ( int ) Math . round ( to Filter . num Instances ( ) * m Percentage / NUM ) ; if ( m Inverse ) { for ( int i = NUM ; i < cut Off ; i ++ ) { push ( to Filter . instance ( i ) ) ; } } else { for ( int i = cut Off ; i < to Filter . num Instances ( ) ; i ++ ) { push ( to Filter . instance ( i ) ) ; } } flush Input ( ) ; m New Batch = BOOL ; m First Batch Done = BOOL ; return ( num Pending Output ( ) != NUM ) ; }
@ Override public boolean batch Finished ( ) { if ( get Input Format ( ) == null ) { throw new Illegal State Exception ( STRING ) ; } Instances to Filter = get Input Format ( ) ; int cut Off = ( int ) Math . round ( to Filter . num Instances ( ) * m Percentage / NUM ) ; if ( m Inverse ) { for ( int i = NUM ; i < cut Off ; i ++ ) { push ( to Filter . instance ( i ) ) ; } } else { for ( int i = cut Off ; i < to Filter . num Instances ( ) ; i ++ ) { push ( to Filter . instance ( i ) ) ; } } flush Input ( ) ; m New Batch = BOOL ; m First Batch Done = BOOL ; return ( num Pending Output ( ) != NUM ) ; }
public Top N Metric ( Top N Metric Type type , String previous Stop ) { this . type = type ; this . metric Name = Optional . empty ( ) ; this . nested = Optional . empty ( ) ; this . previous Stop = Optional . of ( previous Stop ) ; }
public void init ( ) { m csv = new File ( m filename ) ; try { m csv . create New File ( ) ; m fw = new File Writer ( m csv ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; return ; } }
public Zk Connection ( String zk Servers , int session Time Out , String auth Str ) { servers = zk Servers ; session Time Out = session Time Out ; auth Str = auth Str ; }
public Result ( double g Square , double p Value , int df , boolean is Indep ) { this . g Square = g Square ; this . p Value = p Value ; this . df = df ; this . is Indep = is Indep ; }
public void add Measure Item ( Match Recognize Measure Item item ) { measures . add ( item ) ; }
public static Secret Keys keys ( String keys Str ) throws Invalid Key Exception { String [ ] keys Arr = keys Str . split ( STRING ) ; if ( keys Arr . length != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } else { byte [ ] confidentiality Key = Base 64 . decode ( keys Arr [ NUM ] , BASE 64 FLAGS ) ; if ( confidentiality Key . length != AES KEY LENGTH BITS / NUM ) { throw new Invalid Key Exception ( STRING + AES KEY LENGTH BITS + STRING ) ; } byte [ ] integrity Key = Base 64 . decode ( keys Arr [ NUM ] , BASE 64 FLAGS ) ; if ( integrity Key . length != HMAC KEY LENGTH BITS / NUM ) { throw new Invalid Key Exception ( STRING + HMAC KEY LENGTH BITS + STRING ) ; } Secret Keys secret Keys = new Secret Keys ( ) ; Secret Key Spec secret Key Spec = new Secret Key Spec ( ) ; secret Key Spec . generate ( confidentiality Key , NUM , confidentiality Key . length , CIPHER ) ; Secret Key Spec secret Key Spec 1 = new Secret Key Spec ( ) ; secret Key Spec 1 . generate ( integrity Key , HMAC ALGORITHM ) ; secret Keys . set Confidentiality Key ( secret Key Spec ) ; secret Keys . set Integrity Key ( secret Key Spec 1 ) ; return secret Keys ; } }
public static Secret Keys keys ( String keys Str ) throws Invalid Key Exception { String [ ] keys Arr = keys Str . split ( STRING ) ; if ( keys Arr . length != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } else { byte [ ] confidentiality Key = Base 64 . decode ( keys Arr [ NUM ] , BASE 64 FLAGS ) ; if ( confidentiality Key . length != AES KEY LENGTH BITS / NUM ) { throw new Invalid Key Exception ( STRING + AES KEY LENGTH BITS + STRING ) ; } byte [ ] integrity Key = Base 64 . decode ( keys Arr [ NUM ] , BASE 64 FLAGS ) ; if ( integrity Key . length != HMAC KEY LENGTH BITS / NUM ) { throw new Invalid Key Exception ( STRING + HMAC KEY LENGTH BITS + STRING ) ; } Secret Keys secret Keys = new Secret Keys ( ) ; Secret Key Spec secret Key Spec = new Secret Key Spec ( ) ; secret Key Spec . generate ( confidentiality Key , NUM , confidentiality Key . length , CIPHER ) ; Secret Key Spec secret Key Spec 1 = new Secret Key Spec ( ) ; secret Key Spec 1 . generate ( integrity Key , HMAC ALGORITHM ) ; secret Keys . set Confidentiality Key ( secret Key Spec ) ; secret Keys . set Integrity Key ( secret Key Spec 1 ) ; return secret Keys ; } }
public static Secret Keys keys ( String keys Str ) throws Invalid Key Exception { String [ ] keys Arr = keys Str . split ( STRING ) ; if ( keys Arr . length != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } else { byte [ ] confidentiality Key = Base 64 . decode ( keys Arr [ NUM ] , BASE 64 FLAGS ) ; if ( confidentiality Key . length != AES KEY LENGTH BITS / NUM ) { throw new Invalid Key Exception ( STRING + AES KEY LENGTH BITS + STRING ) ; } byte [ ] integrity Key = Base 64 . decode ( keys Arr [ NUM ] , BASE 64 FLAGS ) ; if ( integrity Key . length != HMAC KEY LENGTH BITS / NUM ) { throw new Invalid Key Exception ( STRING + HMAC KEY LENGTH BITS + STRING ) ; } Secret Keys secret Keys = new Secret Keys ( ) ; Secret Key Spec secret Key Spec = new Secret Key Spec ( ) ; secret Key Spec . generate ( confidentiality Key , NUM , confidentiality Key . length , CIPHER ) ; Secret Key Spec secret Key Spec 1 = new Secret Key Spec ( ) ; secret Key Spec 1 . generate ( integrity Key , HMAC ALGORITHM ) ; secret Keys . set Confidentiality Key ( secret Key Spec ) ; secret Keys . set Integrity Key ( secret Key Spec 1 ) ; return secret Keys ; } }
public void action Performed ( Action Event ae ) { long current Time = System . nano Time ( ) / NUM ; long total Time = current Time - cycle Start ; if ( total Time > CYCLE TIME ) { cycle Start = current Time ; } float fraction = ( float ) total Time / CYCLE TIME ; fraction = Math . min ( NUM , fraction ) ; fraction = NUM - Math . abs ( NUM - ( NUM * fraction ) ) ; animate ( fraction ) ; }
public boolean add All ( Collection c ) { Object [ ] a = c . to Array ( ) ; int num New = a . length ; ensure Capacity ( size + num New ) ; System . arraycopy ( a , NUM , element Data , size , num New ) ; size += num New ; return num New != NUM ; }
public boolean add All ( Collection c ) { Object [ ] a = c . to Array ( ) ; int num New = a . length ; ensure Capacity ( size + num New ) ; System . arraycopy ( a , NUM , element Data , size , num New ) ; size += num New ; return num New != NUM ; }
public boolean add All ( Collection c ) { Object [ ] a = c . to Array ( ) ; int num New = a . length ; ensure Capacity ( size + num New ) ; System . arraycopy ( a , NUM , element Data , size , num New ) ; size += num New ; return num New != NUM ; }
private static void serialize To Disk Synchronously ( String cache Key , String controller Json ) { Output Stream output Stream = null ; try { output Stream = controller Disk Cache . open Put Stream ( cache Key ) ; output Stream . write ( controller Json . get Bytes ( ) ) ; } catch ( IO Exception e ) { Log . e ( TAG , STRING , e ) ; } finally { if ( output Stream != null ) { Utility . close Quietly ( output Stream ) ; } } }
private static void serialize To Disk Synchronously ( String cache Key , String controller Json ) { Output Stream output Stream = null ; try { output Stream = controller Disk Cache . open Put Stream ( cache Key ) ; output Stream . write ( controller Json . get Bytes ( ) ) ; } catch ( IO Exception e ) { Log . e ( TAG , STRING , e ) ; } finally { if ( output Stream != null ) { Utility . close Quietly ( output Stream ) ; } } }
private static void serialize To Disk Synchronously ( String cache Key , String controller Json ) { Output Stream output Stream = null ; try { output Stream = controller Disk Cache . open Put Stream ( cache Key ) ; output Stream . write ( controller Json . get Bytes ( ) ) ; } catch ( IO Exception e ) { Log . e ( TAG , STRING , e ) ; } finally { if ( output Stream != null ) { Utility . close Quietly ( output Stream ) ; } } }
private static void serialize To Disk Synchronously ( String cache Key , String controller Json ) { Output Stream output Stream = null ; try { output Stream = controller Disk Cache . open Put Stream ( cache Key ) ; output Stream . write ( controller Json . get Bytes ( ) ) ; } catch ( IO Exception e ) { Log . e ( TAG , STRING , e ) ; } finally { if ( output Stream != null ) { Utility . close Quietly ( output Stream ) ; } } }
public boolean verify Client Evidence Message ( Big Integer client M 1 ) throws Crypto Exception { if ( ( this . A == null ) || ( this . B == null ) || ( this . S == null ) ) { throw new Crypto Exception ( STRING + STRING ) ; } Big Integer computed M 1 = SRP 6 Util . calculate M 1 ( digest , N , A , B , S ) ; if ( computed M 1 . equals ( client M 1 ) ) { this . M1 = client M 1 ; return BOOL ; } return BOOL ; }
@ Suppress Warnings ( STRING ) protected void sequentially ( Consumer < Marker > ... functions ) { if ( functions == null || functions . length == NUM ) return ; Collection < Parsing Exception > errors = new Array List < > ( ) ; Marker marker = tokens . mark ( ) ; for ( Consumer < Marker > function : functions ) { try { function . accept ( marker ) ; return ; } catch ( Parsing Exception e ) { errors . add ( e ) ; tokens . rewind ( marker ) ; } } parsing Failed ( marker . position ( ) , errors , STRING ) ; }
@ Suppress Warnings ( STRING ) protected void sequentially ( Consumer < Marker > ... functions ) { if ( functions == null || functions . length == NUM ) return ; Collection < Parsing Exception > errors = new Array List < > ( ) ; Marker marker = tokens . mark ( ) ; for ( Consumer < Marker > function : functions ) { try { function . accept ( marker ) ; return ; } catch ( Parsing Exception e ) { errors . add ( e ) ; tokens . rewind ( marker ) ; } } parsing Failed ( marker . position ( ) , errors , STRING ) ; }
@ Suppress Warnings ( STRING ) protected void sequentially ( Consumer < Marker > ... functions ) { if ( functions == null || functions . length == NUM ) return ; Collection < Parsing Exception > errors = new Array List < > ( ) ; Marker marker = tokens . mark ( ) ; for ( Consumer < Marker > function : functions ) { try { function . accept ( marker ) ; return ; } catch ( Parsing Exception e ) { errors . add ( e ) ; tokens . rewind ( marker ) ; } } parsing Failed ( marker . position ( ) , errors , STRING ) ; }
@ Suppress Warnings ( STRING ) protected void sequentially ( Consumer < Marker > ... functions ) { if ( functions == null || functions . length == NUM ) return ; Collection < Parsing Exception > errors = new Array List < > ( ) ; Marker marker = tokens . mark ( ) ; for ( Consumer < Marker > function : functions ) { try { function . accept ( marker ) ; return ; } catch ( Parsing Exception e ) { errors . add ( e ) ; tokens . rewind ( marker ) ; } } parsing Failed ( marker . position ( ) , errors , STRING ) ; }
public static SSL Server Socket Factory make SSL Socket Factory ( Key Store loaded Key Store , Key Manager [ ] key Managers ) throws IO Exception { SSL Server Socket Factory res = null ; try { Trust Manager Factory trust Manager Factory = Trust Manager Factory . get Instance ( Trust Manager Factory . get Default Algorithm ( ) ) ; trust Manager Factory . init ( loaded Key Store ) ; SSL Context ctx = SSL Context . get Instance ( STRING ) ; ctx . init ( key Managers , trust Manager Factory . get Trust Managers ( ) , null ) ; res = ctx . get Server Socket Factory ( ) ; } catch ( Exception e ) { throw new IO Exception ( e . get Message ( ) ) ; } return res ; }
private boolean add Worker ( Runnable first Task , boolean core ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = run State Of ( c ) ; if ( rs == SHUTDOWN ) { if ( work Queue . is Empty ( ) ) return BOOL ; c = ctl . get ( ) ; } int wc = worker Count Of ( c ) ; if ( rs > SHUTDOWN || wc >= CAPACITY || wc >= ( core ? core Pool Size : maximum Pool Size ) ) return BOOL ; if ( ctl . compare And Set ( c , ctl Of ( rs , wc + NUM ) ) ) break ; } Worker w = new Worker ( first Task ) ; Thread t = w . thread ; if ( t == null ) { decrement Worker Count ( ) ; try Terminate 2 ( ) ; return BOOL ; } final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { workers . add ( w ) ; int s = workers . size ( ) ; if ( s > largest Pool Size ) largest Pool Size = s ; } finally { main Lock . unlock ( ) ; } t . start ( ) ; return BOOL ; }
private boolean add Worker ( Runnable first Task , boolean core ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = run State Of ( c ) ; if ( rs == SHUTDOWN ) { if ( work Queue . is Empty ( ) ) return BOOL ; c = ctl . get ( ) ; } int wc = worker Count Of ( c ) ; if ( rs > SHUTDOWN || wc >= CAPACITY || wc >= ( core ? core Pool Size : maximum Pool Size ) ) return BOOL ; if ( ctl . compare And Set ( c , ctl Of ( rs , wc + NUM ) ) ) break ; } Worker w = new Worker ( first Task ) ; Thread t = w . thread ; if ( t == null ) { decrement Worker Count ( ) ; try Terminate 2 ( ) ; return BOOL ; } final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { workers . add ( w ) ; int s = workers . size ( ) ; if ( s > largest Pool Size ) largest Pool Size = s ; } finally { main Lock . unlock ( ) ; } t . start ( ) ; return BOOL ; }
private boolean add Worker ( Runnable first Task , boolean core ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = run State Of ( c ) ; if ( rs == SHUTDOWN ) { if ( work Queue . is Empty ( ) ) return BOOL ; c = ctl . get ( ) ; } int wc = worker Count Of ( c ) ; if ( rs > SHUTDOWN || wc >= CAPACITY || wc >= ( core ? core Pool Size : maximum Pool Size ) ) return BOOL ; if ( ctl . compare And Set ( c , ctl Of ( rs , wc + NUM ) ) ) break ; } Worker w = new Worker ( first Task ) ; Thread t = w . thread ; if ( t == null ) { decrement Worker Count ( ) ; try Terminate 2 ( ) ; return BOOL ; } final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { workers . add ( w ) ; int s = workers . size ( ) ; if ( s > largest Pool Size ) largest Pool Size = s ; } finally { main Lock . unlock ( ) ; } t . start ( ) ; return BOOL ; }
public Element remove Element From Registry ( String hashcode ) { registry . remove ( hashcode ) ; registry List . remove Element ( hashcode ) ; return ( this ) ; }
public void remove Selection Change Listener ( final Selection Change Listener listener ) { check Widget ( ) ; if ( listener == null ) { SWT . error ( SWT . ERROR NULL ARGUMENT ) ; } if ( selection Change Listeners == null ) { return ; } selection Change Listeners . remove ( listener ) ; }
public void remove Selection Change Listener ( final Selection Change Listener listener ) { check Widget ( ) ; if ( listener == null ) { SWT . error ( SWT . ERROR NULL ARGUMENT ) ; } if ( selection Change Listeners == null ) { return ; } selection Change Listeners . remove ( listener ) ; }
public void remove Selection Change Listener ( final Selection Change Listener listener ) { check Widget ( ) ; if ( listener == null ) { SWT . error ( SWT . ERROR NULL ARGUMENT ) ; } if ( selection Change Listeners == null ) { return ; } selection Change Listeners . remove ( listener ) ; }
public void remove Selection Change Listener ( final Selection Change Listener listener ) { check Widget ( ) ; if ( listener == null ) { SWT . error ( SWT . ERROR NULL ARGUMENT ) ; } if ( selection Change Listeners == null ) { return ; } selection Change Listeners . remove ( listener ) ; }
public int hash Code ( ) { int hash = Float . float To Int Bits ( width ) ; hash = hash * NUM + join ; hash = hash * NUM + cap ; hash = hash * NUM + Float . float To Int Bits ( miterlimit ) ; if ( dash != null ) { hash = hash * NUM + Float . float To Int Bits ( dash phase ) ; for ( int i = NUM ; i < dash . length ; i ++ ) { hash = hash * NUM + Float . float To Int Bits ( dash [ i ] ) ; } } return hash ; }
public static boolean [ ] parse String ( String [ ] values ) { boolean [ ] result = new boolean [ values . length ] ; for ( int i = NUM ; i < result . length ; i ++ ) { result [ i ] = parse String ( values [ i ] ) ; } return result ; }
public static boolean [ ] parse String ( String [ ] values ) { boolean [ ] result = new boolean [ values . length ] ; for ( int i = NUM ; i < result . length ; i ++ ) { result [ i ] = parse String ( values [ i ] ) ; } return result ; }
protected final void refresh Loading Views Size ( ) { final int maximum Pull Scroll = ( int ) ( get Maximum Pull Scroll ( ) * NUM ) ; int p Left = get Padding Left ( ) ; int p Top = get Padding Top ( ) ; int p Right = get Padding Right ( ) ; int p Bottom = get Padding Bottom ( ) ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Width ( maximum Pull Scroll ) ; p Left = - maximum Pull Scroll ; } else { p Left = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Width ( maximum Pull Scroll ) ; p Right = - maximum Pull Scroll ; } else { p Right = NUM ; } break ; case VERTICAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Height ( maximum Pull Scroll ) ; p Top = - maximum Pull Scroll ; } else { p Top = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Height ( maximum Pull Scroll ) ; p Bottom = - maximum Pull Scroll ; } else { p Bottom = NUM ; } break ; } if ( DEBUG ) { Log . d ( LOG TAG , String . format ( STRING , p Left , p Top , p Right , p Bottom ) ) ; } set Padding ( p Left , p Top , p Right , p Bottom ) ; }
public Vector 2 f ( float x , float y ) { this . x = x ; this . y = y ; }
public synchronized void sync All ( ) throws SOS Failure { final String method Name = STRING ; log . trace ( method Name + STRING ) ; file Cos Id List = null ; block Cos Id List = null ; block Cos Detail List = null ; file Cos Detail List = null ; log . trace ( method Name + STRING ) ; }
private void update Pending Nodes ( final int new Landmark Index , final Router Priority Queue < Node > pending Nodes ) { final List < Double > new Est Rem Trav Costs = new Array List < > ( ) ; final List < Node > nodes To Be Updated = new Array List < > ( ) ; final Internal Landmark Data landmark Data = new Internal Landmark Data ( ) ; for ( Node node : pending Nodes ) { final A Star Node Data role = get Data ( node ) ; final Pre Process Landmarks . Landmarks Data pp Role = preprocess . get Node Data ( node ) ; landmark Data . set Delegate ( pp Role ) ; final double new Est Rem Trav Cost = estimate Remaining Travel Cost ( landmark Data , new Landmark Index ) ; if ( new Est Rem Trav Cost > role . get Expected Remaining Cost ( ) ) { nodes To Be Updated . add ( node ) ; new Est Rem Trav Costs . add ( new Est Rem Trav Cost ) ; } } for ( Node node : nodes To Be Updated ) { pending Nodes . remove ( node ) ; } for ( int i = NUM ; i < nodes To Be Updated . size ( ) ; i ++ ) { final Node node = nodes To Be Updated . get ( i ) ; final A Star Node Data data = get Data ( node ) ; data . set Expected Remaining Cost ( new Est Rem Trav Costs . get ( i ) ) ; pending Nodes . add ( node , get Priority ( data ) ) ; } }
private void update Pending Nodes ( final int new Landmark Index , final Router Priority Queue < Node > pending Nodes ) { final List < Double > new Est Rem Trav Costs = new Array List < > ( ) ; final List < Node > nodes To Be Updated = new Array List < > ( ) ; final Internal Landmark Data landmark Data = new Internal Landmark Data ( ) ; for ( Node node : pending Nodes ) { final A Star Node Data role = get Data ( node ) ; final Pre Process Landmarks . Landmarks Data pp Role = preprocess . get Node Data ( node ) ; landmark Data . set Delegate ( pp Role ) ; final double new Est Rem Trav Cost = estimate Remaining Travel Cost ( landmark Data , new Landmark Index ) ; if ( new Est Rem Trav Cost > role . get Expected Remaining Cost ( ) ) { nodes To Be Updated . add ( node ) ; new Est Rem Trav Costs . add ( new Est Rem Trav Cost ) ; } } for ( Node node : nodes To Be Updated ) { pending Nodes . remove ( node ) ; } for ( int i = NUM ; i < nodes To Be Updated . size ( ) ; i ++ ) { final Node node = nodes To Be Updated . get ( i ) ; final A Star Node Data data = get Data ( node ) ; data . set Expected Remaining Cost ( new Est Rem Trav Costs . get ( i ) ) ; pending Nodes . add ( node , get Priority ( data ) ) ; } }
private void update Pending Nodes ( final int new Landmark Index , final Router Priority Queue < Node > pending Nodes ) { final List < Double > new Est Rem Trav Costs = new Array List < > ( ) ; final List < Node > nodes To Be Updated = new Array List < > ( ) ; final Internal Landmark Data landmark Data = new Internal Landmark Data ( ) ; for ( Node node : pending Nodes ) { final A Star Node Data role = get Data ( node ) ; final Pre Process Landmarks . Landmarks Data pp Role = preprocess . get Node Data ( node ) ; landmark Data . set Delegate ( pp Role ) ; final double new Est Rem Trav Cost = estimate Remaining Travel Cost ( landmark Data , new Landmark Index ) ; if ( new Est Rem Trav Cost > role . get Expected Remaining Cost ( ) ) { nodes To Be Updated . add ( node ) ; new Est Rem Trav Costs . add ( new Est Rem Trav Cost ) ; } } for ( Node node : nodes To Be Updated ) { pending Nodes . remove ( node ) ; } for ( int i = NUM ; i < nodes To Be Updated . size ( ) ; i ++ ) { final Node node = nodes To Be Updated . get ( i ) ; final A Star Node Data data = get Data ( node ) ; data . set Expected Remaining Cost ( new Est Rem Trav Costs . get ( i ) ) ; pending Nodes . add ( node , get Priority ( data ) ) ; } }
@ Override protected void create Buttons For Button Bar ( final Composite parent ) { for ( final Iterator it = button Descriptions . iterator ( ) ; it . has Next ( ) ; ) { final Button Description button Description = ( Button Description ) it . next ( ) ; create Button ( parent , button Description . button Id , button Description . button Label , button Description . is Default ) ; } if ( include Default Buttons ) { super . create Buttons For Button Bar ( parent ) ; } hook After Buttons Created ( ) ; }
@ Override protected void create Buttons For Button Bar ( final Composite parent ) { for ( final Iterator it = button Descriptions . iterator ( ) ; it . has Next ( ) ; ) { final Button Description button Description = ( Button Description ) it . next ( ) ; create Button ( parent , button Description . button Id , button Description . button Label , button Description . is Default ) ; } if ( include Default Buttons ) { super . create Buttons For Button Bar ( parent ) ; } hook After Buttons Created ( ) ; }
@ Override protected void create Buttons For Button Bar ( final Composite parent ) { for ( final Iterator it = button Descriptions . iterator ( ) ; it . has Next ( ) ; ) { final Button Description button Description = ( Button Description ) it . next ( ) ; create Button ( parent , button Description . button Id , button Description . button Label , button Description . is Default ) ; } if ( include Default Buttons ) { super . create Buttons For Button Bar ( parent ) ; } hook After Buttons Created ( ) ; }
@ Override protected void create Buttons For Button Bar ( final Composite parent ) { for ( final Iterator it = button Descriptions . iterator ( ) ; it . has Next ( ) ; ) { final Button Description button Description = ( Button Description ) it . next ( ) ; create Button ( parent , button Description . button Id , button Description . button Label , button Description . is Default ) ; } if ( include Default Buttons ) { super . create Buttons For Button Bar ( parent ) ; } hook After Buttons Created ( ) ; }
@ Override protected void create Buttons For Button Bar ( final Composite parent ) { for ( final Iterator it = button Descriptions . iterator ( ) ; it . has Next ( ) ; ) { final Button Description button Description = ( Button Description ) it . next ( ) ; create Button ( parent , button Description . button Id , button Description . button Label , button Description . is Default ) ; } if ( include Default Buttons ) { super . create Buttons For Button Bar ( parent ) ; } hook After Buttons Created ( ) ; }
public static boolean has Suppressed ( @ Nullable Throwable t , @ Nullable Class < ? extends Throwable > cls ) { if ( t == null || cls == null ) return BOOL ; if ( t . get Suppressed ( ) != null ) { for ( Throwable th : t . get Suppressed ( ) ) { if ( cls . is Assignable From ( th . get Class ( ) ) ) return BOOL ; if ( has Suppressed ( th , cls ) ) return BOOL ; } } return BOOL ; }
static public double log 10 ( double in Value ) { return Math . log ( in Value ) / Math . log ( NUM ) ; }
static public double log 10 ( double in Value ) { return Math . log ( in Value ) / Math . log ( NUM ) ; }
static public double log 10 ( double in Value ) { return Math . log ( in Value ) / Math . log ( NUM ) ; }
static public double log 10 ( double in Value ) { return Math . log ( in Value ) / Math . log ( NUM ) ; }
static public double log 10 ( double in Value ) { return Math . log ( in Value ) / Math . log ( NUM ) ; }
static public double log 10 ( double in Value ) { return Math . log ( in Value ) / Math . log ( NUM ) ; }
protected Http Server Provider ( ) { Security Manager sm = System . get Security Manager ( ) ; if ( sm != null ) sm . check Permission ( new Runtime Permission ( STRING ) ) ; }
public RE Program compile ( String pattern ) throws RE Syntax Exception { this . pattern = pattern ; len = pattern . length ( ) ; idx = NUM ; len Instruction = NUM ; parens = NUM ; int [ ] flags = { NODE TOPLEVEL } ; expr ( flags ) ; if ( idx != len ) { if ( pattern . char At ( idx ) == STRING ) { syntax Error ( STRING ) ; } syntax Error ( STRING ) ; } char [ ] ins = new char [ len Instruction ] ; System . arraycopy ( instruction , NUM , ins , NUM , len Instruction ) ; return new RE Program ( parens , ins ) ; }
public RE Program compile ( String pattern ) throws RE Syntax Exception { this . pattern = pattern ; len = pattern . length ( ) ; idx = NUM ; len Instruction = NUM ; parens = NUM ; int [ ] flags = { NODE TOPLEVEL } ; expr ( flags ) ; if ( idx != len ) { if ( pattern . char At ( idx ) == STRING ) { syntax Error ( STRING ) ; } syntax Error ( STRING ) ; } char [ ] ins = new char [ len Instruction ] ; System . arraycopy ( instruction , NUM , ins , NUM , len Instruction ) ; return new RE Program ( parens , ins ) ; }
public void update Shape Shadows To Current Time ( boolean update Minutes , boolean update Hours , int current Minute , int current Hour ) { if ( update Minutes ) { int tens = ( int ) Math . floor ( current Minute / NUM ) ; int units = ( int ) Math . floor ( current Minute % NUM ) ; if ( minutes Tens . get Current Value ( ) != tens ) { String mt = String . format ( STRING , tens ) ; mt = mt . concat ( STRING ) ; Log . d ( TAG , STRING + mt ) ; minutes Tens . parse JSON ( mt ) ; } if ( minutes Units . get Current Value ( ) != units ) { String mu = String . format ( STRING , units ) ; mu = mu . concat ( STRING ) ; Log . d ( TAG , STRING + mu ) ; minutes Units . parse JSON ( mu ) ; } } if ( update Hours ) { int tens = ( int ) Math . floor ( current Hour / NUM ) ; int units = ( int ) Math . floor ( current Hour % NUM ) ; if ( hours Tens . get Current Value ( ) != tens ) { String ht = String . format ( STRING , tens ) ; ht = ht . concat ( STRING ) ; Log . d ( TAG , STRING + ht ) ; hours Tens . parse JSON ( ht ) ; } if ( hours Units . get Current Value ( ) != units ) { String hu = String . format ( STRING , units ) ; hu = hu . concat ( STRING ) ; Log . d ( TAG , STRING + hu ) ; hours Units . parse JSON ( hu ) ; } } }
public static char [ ] join ( char [ ] array A , char ... array B ) { if ( ( array B == null ) || ( array B . length == NUM ) ) { return array A ; } if ( ( array A == null ) || ( array A . length == NUM ) ) { return array B ; } char [ ] array = new char [ array A . length + array B . length ] ; System . arraycopy ( array A , NUM , array , NUM , array A . length ) ; System . arraycopy ( array B , NUM , array , array A . length , array B . length ) ; return array ; }
public static char [ ] join ( char [ ] array A , char ... array B ) { if ( ( array B == null ) || ( array B . length == NUM ) ) { return array A ; } if ( ( array A == null ) || ( array A . length == NUM ) ) { return array B ; } char [ ] array = new char [ array A . length + array B . length ] ; System . arraycopy ( array A , NUM , array , NUM , array A . length ) ; System . arraycopy ( array B , NUM , array , array A . length , array B . length ) ; return array ; }
void write ( ) { clear Attributes ( ) ; if ( term Attribute . length ( ) < buffer . length ( ) ) { term Attribute . resize Buffer ( buffer . length ( ) ) ; } char termbuffer [ ] = term Attribute . buffer ( ) ; buffer . get Chars ( NUM , buffer . length ( ) , termbuffer , NUM ) ; term Attribute . set Length ( buffer . length ( ) ) ; if ( has Illegal Offsets ) { offset Attribute . set Offset ( saved Start Offset , saved End Offset ) ; } else { offset Attribute . set Offset ( start Offset , end Offset ) ; } pos Inc Attribute . set Position Increment ( position ( BOOL ) ) ; type Attribute . set Type ( saved Type ) ; accum Pos Inc = NUM ; }
private static String create Js Method Invocation Expression ( String method Name , boolean is Static , String ... param Names ) { String Builder sb = new String Builder ( ) ; sb . append ( is Static ? WND : THIS ) ; sb . append ( STRING ) ; sb . append ( method Name ) ; sb . append ( STRING ) ; for ( int i = NUM ; i < param Names . length ; i ++ ) { if ( i != NUM ) { sb . append ( STRING ) ; } sb . append ( param Names [ i ] ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
public void initialize Writer ( ) throws Carbon Data Writer Exception { init File Count ( ) ; String carbon Data File Name = carbon Table Path . get Carbon Data File Name ( file Count , carbon Data File Attributes . get Task Id ( ) , carbon Data File Attributes . get Fact Time Stamp ( ) ) ; String actual File Name Val = carbon Data File Name + Carbon Common Constants . FILE INPROGRESS STATUS ; File Data file Data = new File Data ( actual File Name Val , this . store Location ) ; file Manager . add ( file Data ) ; this . file Name = store Location + File . separator + carbon Data File Name + Carbon Common Constants . FILE INPROGRESS STATUS ; this . file Count ++ ; try { file Output Stream = new File Output Stream ( this . file Name , BOOL ) ; this . file Channel = file Output Stream . get Channel ( ) ; } catch ( File Not Found Exception file Not Found Exception ) { throw new Carbon Data Writer Exception ( STRING , file Not Found Exception ) ; } }
protected void stop Job Acquisition Thread ( ) { if ( async Job Acquisition Thread != null ) { try { async Job Acquisition Thread . join ( ) ; } catch ( Interrupted Exception e ) { log . warn ( STRING , e ) ; } async Job Acquisition Thread = null ; } }
private Case Insensitive Char ( String s ) { this ( s . char At ( NUM ) ) ; }
private void backup Screens ( Backup Data Output data ) throws IO Exception { Content Resolver cr = m Context . get Content Resolver ( ) ; Cursor cursor = cr . query ( Workspace Screens . CONTENT URI , SCREEN PROJECTION , null , null , null ) ; try { cursor . move To Position ( - NUM ) ; if ( DEBUG ) Log . d ( TAG , STRING + m Last Backup Restore Time ) ; while ( cursor . move To Next ( ) ) { final long id = cursor . get Long ( ID INDEX ) ; final long update Time = cursor . get Long ( ID MODIFIED ) ; Key key = get Key ( Key . SCREEN , id ) ; m Keys . add ( key ) ; final String backup Key = key To Backup Key ( key ) ; if ( ! m Existing Keys . contains ( backup Key ) || update Time >= m Last Backup Restore Time ) { write Row To Backup ( key , pack Screen ( cursor ) , data ) ; } else { if ( VERBOSE ) Log . v ( TAG , STRING + id ) ; } } } finally { cursor . close ( ) ; } }
public D Basic Constraints ( J Dialog parent , byte [ ] value ) throws IO Exception { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
@ Override public final void write Chars ( String s ) throws IO Exception { int len = s . length ( ) ; for ( int i = NUM ; i < len ; i ++ ) { write Char ( s . char At ( i ) ) ; } }
public static double round ( double number ) { return ( double ) Math . round ( number * Math . pow ( NUM , NUM ) ) / Math . pow ( NUM , NUM ) ; }
@ Override public Log Seq Num write To Log ( ) { List < Constant > rec = build Record ( ) ; return log Mgr . append ( rec . to Array ( new Constant [ rec . size ( ) ] ) ) ; }
@ Override public Log Seq Num write To Log ( ) { List < Constant > rec = build Record ( ) ; return log Mgr . append ( rec . to Array ( new Constant [ rec . size ( ) ] ) ) ; }
public void clear ( ) { size = NUM ; items . clear ( ) ; }
public static final void write Byte Array Xml ( byte [ ] val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int n = val . length ; out . attribute ( null , STRING , Integer . to String ( n ) ) ; String Builder sb = new String Builder ( val . length * NUM ) ; for ( int i = NUM ; i < n ; i ++ ) { int b = val [ i ] ; int h = b > > NUM ; sb . append ( h >= NUM ? ( STRING + h - NUM ) : ( STRING + h ) ) ; h = b & NUM ; sb . append ( h >= NUM ? ( STRING + h - NUM ) : ( STRING + h ) ) ; } out . text ( sb . to String ( ) ) ; out . end Tag ( null , STRING ) ; }
public static final void write Byte Array Xml ( byte [ ] val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int n = val . length ; out . attribute ( null , STRING , Integer . to String ( n ) ) ; String Builder sb = new String Builder ( val . length * NUM ) ; for ( int i = NUM ; i < n ; i ++ ) { int b = val [ i ] ; int h = b > > NUM ; sb . append ( h >= NUM ? ( STRING + h - NUM ) : ( STRING + h ) ) ; h = b & NUM ; sb . append ( h >= NUM ? ( STRING + h - NUM ) : ( STRING + h ) ) ; } out . text ( sb . to String ( ) ) ; out . end Tag ( null , STRING ) ; }
public static final void write Byte Array Xml ( byte [ ] val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int n = val . length ; out . attribute ( null , STRING , Integer . to String ( n ) ) ; String Builder sb = new String Builder ( val . length * NUM ) ; for ( int i = NUM ; i < n ; i ++ ) { int b = val [ i ] ; int h = b > > NUM ; sb . append ( h >= NUM ? ( STRING + h - NUM ) : ( STRING + h ) ) ; h = b & NUM ; sb . append ( h >= NUM ? ( STRING + h - NUM ) : ( STRING + h ) ) ; } out . text ( sb . to String ( ) ) ; out . end Tag ( null , STRING ) ; }
public static final void write Byte Array Xml ( byte [ ] val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int n = val . length ; out . attribute ( null , STRING , Integer . to String ( n ) ) ; String Builder sb = new String Builder ( val . length * NUM ) ; for ( int i = NUM ; i < n ; i ++ ) { int b = val [ i ] ; int h = b > > NUM ; sb . append ( h >= NUM ? ( STRING + h - NUM ) : ( STRING + h ) ) ; h = b & NUM ; sb . append ( h >= NUM ? ( STRING + h - NUM ) : ( STRING + h ) ) ; } out . text ( sb . to String ( ) ) ; out . end Tag ( null , STRING ) ; }
public byte [ ] to Byte Array ( ) { final int out Len = NUM * ( Short . SIZE / Byte . SIZE ) + key Provider Id Len + key Provider Info Len + encrypted Key Len ; final Byte Buffer out = Byte Buffer . allocate ( out Len ) ; out . put Short ( key Provider Id Len ) ; out . put ( key Provider Id , NUM , key Provider Id Len ) ; out . put Short ( key Provider Info Len ) ; out . put ( key Provider Info , NUM , key Provider Info Len ) ; out . put Short ( encrypted Key Len ) ; out . put ( encrypted Key , NUM , encrypted Key Len ) ; return out . array ( ) ; }
protected void load Maps ( ) { Set client Types = merged Client Data . key Set ( ) ; Iterator keys = client Types . iterator ( ) ; String client Type = null ; Map client Data Map = null ; while ( keys . has Next ( ) ) { client Type = ( String ) keys . next ( ) ; client Data Map = ( Map ) merged Client Data . get ( client Type ) ; set Parent Styles ( client Data Map ) ; } keys = client Types . iterator ( ) ; while ( keys . has Next ( ) ) { client Type = ( String ) keys . next ( ) ; client Data Map = ( Map ) merged Client Data . get ( client Type ) ; add To Client Map ( client Type , client Data Map ) ; } }
public static byte [ ] hex String To Bytes ( String hex String ) { if ( hex String == null || hex String . equals ( STRING ) ) { return null ; } hex String = hex String . to Upper Case ( ) ; int length = hex String . length ( ) / NUM ; char [ ] hex Chars = hex String . to Char Array ( ) ; byte [ ] d = new byte [ length ] ; for ( int i = NUM ; i < length ; i ++ ) { int pos = i * NUM ; d [ i ] = ( byte ) ( char To Byte ( hex Chars [ pos ] ) << NUM | char To Byte ( hex Chars [ pos + NUM ] ) ) ; } return d ; }
public static byte [ ] hex String To Bytes ( String hex String ) { if ( hex String == null || hex String . equals ( STRING ) ) { return null ; } hex String = hex String . to Upper Case ( ) ; int length = hex String . length ( ) / NUM ; char [ ] hex Chars = hex String . to Char Array ( ) ; byte [ ] d = new byte [ length ] ; for ( int i = NUM ; i < length ; i ++ ) { int pos = i * NUM ; d [ i ] = ( byte ) ( char To Byte ( hex Chars [ pos ] ) << NUM | char To Byte ( hex Chars [ pos + NUM ] ) ) ; } return d ; }
public Trust Manager Builder add ( Trust Manager ... mgrs ) { for ( Trust Manager tm : mgrs ) { if ( tm instanceof X509 Trust Manager ) { mgr . add ( ( X509 Trust Manager ) tm ) ; } } return ( this ) ; }
public Trust Manager Builder add ( Trust Manager ... mgrs ) { for ( Trust Manager tm : mgrs ) { if ( tm instanceof X509 Trust Manager ) { mgr . add ( ( X509 Trust Manager ) tm ) ; } } return ( this ) ; }
public Trust Manager Builder add ( Trust Manager ... mgrs ) { for ( Trust Manager tm : mgrs ) { if ( tm instanceof X509 Trust Manager ) { mgr . add ( ( X509 Trust Manager ) tm ) ; } } return ( this ) ; }
private void on Resized ( ) { Dimension screen Size = stendhal . get Display Size ( ) ; sw = get Width ( ) ; sh = get Height ( ) ; if ( use Scaling ) { double x Scale = sw / screen Size . get Width ( ) ; double y Scale = sh / screen Size . get Height ( ) ; scale = Math . max ( x Scale , y Scale ) ; if ( Math . abs ( scale - NUM ) > NUM ) { use Triple Buffer = BOOL ; } else { use Triple Buffer = BOOL ; buffer = null ; } } else { sw = Math . min ( sw , screen Size . width ) ; sh = Math . min ( sh , screen Size . height ) ; use Triple Buffer = BOOL ; buffer = null ; } calculate View ( x , y ) ; center ( ) ; }
public static String repeat ( String source String , int factor ) { if ( factor < NUM ) { return STRING ; } if ( factor == NUM ) { return source String ; } String Builder sb = new String Builder ( factor * source String . length ( ) ) ; while ( factor > NUM ) { sb . append ( source String ) ; factor -- ; } return sb . to String ( ) ; }
public boolean is Absolute ( ) { return path . length ( ) > NUM && path . char At ( NUM ) == separator Char ; }
public boolean is Absolute ( ) { return path . length ( ) > NUM && path . char At ( NUM ) == separator Char ; }
public static boolean is Data Uri ( String text ) { return text . starts With ( DATA URI PREFIX ) ; }
public static String to Pinyin ( char c ) { if ( is Chinese ( c ) ) { if ( c == Pinyin Data . CHAR 12295 ) { return Pinyin Data . PINYIN 12295 ; } else { return Pinyin Data . PINYIN TABLE [ get Pinyin Code ( c ) ] ; } } else { return String . value Of ( c ) ; } }
public void test Random ( ) { Extremity Monitor monitor = new Extremity Monitor ( ) ; Random random = new Random ( NUM ) ; for ( int i = NUM ; i < NUM ; i ++ ) { monitor . update ( random . next Double ( ) ) ; } assert True ( monitor . get Min ( ) < NUM ) ; assert True ( monitor . get Max ( ) < NUM ) ; assert True ( monitor . get Min ( ) >= NUM ) ; assert True ( monitor . get Max ( ) > NUM ) ; }
public void test Random ( ) { Extremity Monitor monitor = new Extremity Monitor ( ) ; Random random = new Random ( NUM ) ; for ( int i = NUM ; i < NUM ; i ++ ) { monitor . update ( random . next Double ( ) ) ; } assert True ( monitor . get Min ( ) < NUM ) ; assert True ( monitor . get Max ( ) < NUM ) ; assert True ( monitor . get Min ( ) >= NUM ) ; assert True ( monitor . get Max ( ) > NUM ) ; }
public static String to Upper Case ( String src ) { if ( src == null ) { return null ; } else { return src . to Upper Case ( ) ; } }
public static String to Upper Case ( String src ) { if ( src == null ) { return null ; } else { return src . to Upper Case ( ) ; } }
public static String to Upper Case ( String src ) { if ( src == null ) { return null ; } else { return src . to Upper Case ( ) ; } }
public boolean is Incremental Build ( ) { return incremental Build ; }
public boolean is Incremental Build ( ) { return incremental Build ; }
public boolean is Incremental Build ( ) { return incremental Build ; }
public boolean is Incremental Build ( ) { return incremental Build ; }
public boolean is Incremental Build ( ) { return incremental Build ; }
public boolean is Incremental Build ( ) { return incremental Build ; }
public boolean is Incremental Build ( ) { return incremental Build ; }
@ Override public Object value For Search ( Object value ) { Long val = value ( value ) ; if ( val == null ) { return null ; } return long To Ip ( val ) ; }
public boolean exists ( String path ) { try { Zip Entry entry = get Zip Entry ( path ) ; return entry != null ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } return BOOL ; }
public boolean exists ( String path ) { try { Zip Entry entry = get Zip Entry ( path ) ; return entry != null ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } return BOOL ; }
protected void add Auth Config Listener ( String service , String name ) { Set < String > set = auth Config Listener Map . get ( service ) ; if ( set == null ) { set = new Copy On Write Array Set < > ( ) ; set . add ( name ) ; auth Config Listener Map . put ( service , set ) ; } else { set . add ( name ) ; } }
public void parse ( String string ) { if ( string == null ) { throw new Null Pointer Exception ( STRING ) ; } int buffer Size = Math . max ( MIN BUFFER SIZE , Math . min ( DEFAULT BUFFER SIZE , string . length ( ) ) ) ; try { parse ( new String Reader ( string ) , buffer Size ) ; } catch ( IO Exception exception ) { throw new Runtime Exception ( exception ) ; } }
public void parse ( String string ) { if ( string == null ) { throw new Null Pointer Exception ( STRING ) ; } int buffer Size = Math . max ( MIN BUFFER SIZE , Math . min ( DEFAULT BUFFER SIZE , string . length ( ) ) ) ; try { parse ( new String Reader ( string ) , buffer Size ) ; } catch ( IO Exception exception ) { throw new Runtime Exception ( exception ) ; } }
public void parse ( String string ) { if ( string == null ) { throw new Null Pointer Exception ( STRING ) ; } int buffer Size = Math . max ( MIN BUFFER SIZE , Math . min ( DEFAULT BUFFER SIZE , string . length ( ) ) ) ; try { parse ( new String Reader ( string ) , buffer Size ) ; } catch ( IO Exception exception ) { throw new Runtime Exception ( exception ) ; } }
public void parse ( String string ) { if ( string == null ) { throw new Null Pointer Exception ( STRING ) ; } int buffer Size = Math . max ( MIN BUFFER SIZE , Math . min ( DEFAULT BUFFER SIZE , string . length ( ) ) ) ; try { parse ( new String Reader ( string ) , buffer Size ) ; } catch ( IO Exception exception ) { throw new Runtime Exception ( exception ) ; } }
public static void build Events From Cursor ( Array List < Event > events , Cursor c Events , Context context , int start Day , int end Day ) { if ( c Events == null || events == null ) { Log . e ( TAG , STRING ) ; return ; } int count = c Events . get Count ( ) ; if ( count == NUM ) { return ; } Resources res = context . get Resources ( ) ; m No Title String = res . get String ( R . string . no title label ) ; m No Color Color = res . get Color ( R . color . event center ) ; c Events . move To Position ( - NUM ) ; while ( c Events . move To Next ( ) ) { Event e = generate Event From Cursor ( c Events ) ; if ( e . start Day > end Day || e . end Day < start Day ) { continue ; } events . add ( e ) ; } }
public synchronized boolean should Execute ( Key Select key Select ) { if ( slow Queries == null ) return BOOL ; String query Key = key Select . generate Key ( ) ; Long pending Query Invocation = pending Queries . get ( query Key ) ; if ( pending Query Invocation != null ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + query Key ) ; } return BOOL ; } Long slow Query Invocation = slow Queries . get ( query Key ) ; if ( slow Query Invocation != null ) { key Select . set Last Invocation ( slow Query Invocation ) ; long since Last Millis = System . current Time Millis ( ) - slow Query Invocation ; if ( since Last Millis < ( slow Query Cache Duration * NUM ) ) { slow Queries . put ( query Key , System . current Time Millis ( ) ) ; return BOOL ; } } pending Queries . put ( query Key , System . current Time Millis ( ) ) ; return BOOL ; }
public static Map < String , String > convert O Auth Response ( String response Oauth Request ) { Map < String , String > response Elements = new Hash Map < > ( ) ; String [ ] elements = response Oauth Request . split ( STRING ) ; for ( String element : elements ) { String [ ] key Value = element . split ( STRING ) ; response Elements . put ( key Value [ NUM ] , key Value [ NUM ] ) ; } return response Elements ; }
public static Map < String , String > convert O Auth Response ( String response Oauth Request ) { Map < String , String > response Elements = new Hash Map < > ( ) ; String [ ] elements = response Oauth Request . split ( STRING ) ; for ( String element : elements ) { String [ ] key Value = element . split ( STRING ) ; response Elements . put ( key Value [ NUM ] , key Value [ NUM ] ) ; } return response Elements ; }
public static boolean can Dock South ( List constraints ) { for ( Iterator iter = constraints . iterator ( ) ; iter . has Next ( ) ; ) { Dock Constraint dc = ( Dock Constraint ) iter . next ( ) ; if ( ! dc . can Dock South ( ) ) return BOOL ; } return BOOL ; }
public static boolean can Dock South ( List constraints ) { for ( Iterator iter = constraints . iterator ( ) ; iter . has Next ( ) ; ) { Dock Constraint dc = ( Dock Constraint ) iter . next ( ) ; if ( ! dc . can Dock South ( ) ) return BOOL ; } return BOOL ; }
void flush Text ( ) { String flush = ( committed Text != null ? committed Text : STRING ) ; if ( composed Text != null ) { flush += composed Text . to String ( ) ; } if ( ! flush . equals ( STRING ) ) { Attributed String attrstr = new Attributed String ( flush ) ; post Input Method Event ( Input Method Event . INPUT METHOD TEXT CHANGED , attrstr . get Iterator ( ) , flush . length ( ) , null , null , Event Queue . get Most Recent Event Time ( ) ) ; composed Text = null ; committed Text = null ; } }
public T compute If Absent ( final Supplier < T > lazy ) { final T val = get ( ) ; if ( val == UNSET ) return set Once From Supplier ( lazy ) ; return val ; }
public synchronized void delete Observer ( Observer observer ) { observers . remove ( observer ) ; }
public synchronized void delete Observer ( Observer observer ) { observers . remove ( observer ) ; }
private String detail Base ( final Method method ) { final Class < ? > clazz = method . get Declaring Class ( ) ; final String detail Base = Message Utils . bundle Name For Class ( clazz ) ; if ( is Blank ( detail Base ) ) { throw new Illegal State Exception ( STRING + clazz ) ; } return detail Base ; }
private String detail Base ( final Method method ) { final Class < ? > clazz = method . get Declaring Class ( ) ; final String detail Base = Message Utils . bundle Name For Class ( clazz ) ; if ( is Blank ( detail Base ) ) { throw new Illegal State Exception ( STRING + clazz ) ; } return detail Base ; }
private static final void show Corruption Error ( Throwable err ) { err . print Stack Trace ( ) ; String Writer sw = new String Writer ( ) ; Print Writer pw = new Print Writer ( sw ) ; pw . println ( STRING + Frost Wire Utils . get Frost Wire Version ( ) ) ; pw . print ( STRING ) ; pw . print ( System . get Property ( STRING , STRING ) ) ; pw . print ( STRING ) ; pw . println ( System . get Property ( STRING , STRING ) ) ; pw . print ( System . get Property ( STRING , STRING ) ) ; pw . print ( STRING ) ; pw . print ( System . get Property ( STRING , STRING ) ) ; pw . print ( STRING ) ; pw . println ( System . get Property ( STRING , STRING ) ) ; Runtime runtime = Runtime . get Runtime ( ) ; pw . println ( STRING + runtime . free Memory ( ) + STRING + runtime . total Memory ( ) ) ; pw . println ( ) ; err . print Stack Trace ( pw ) ; pw . println ( ) ; pw . println ( STRING ) ; pw . println ( ) ; File props File = new File ( get User Settings Dir ( ) , STRING ) ; Properties props = new Properties ( ) ; try { File Input Stream fis = new File Input Stream ( props File ) ; props . load ( fis ) ; fis . close ( ) ; props . list ( pw ) ; } catch ( File Not Found Exception fnfe ) { } catch ( IO Exception ioe ) { } pw . flush ( ) ; display Error ( sw . to String ( ) ) ; }
public int action ( String fault , String action ) { Integer current = get ( fault ) ; if ( current == null ) throw new Illegal Argument Exception ( fault ) ; boolean no = action . starts With ( STRING ) ; if ( no ) action = action . substring ( NUM ) ; Integer bit = get Action ( action ) ; if ( bit == null ) throw new Illegal Argument Exception ( action ) ; int old = current . int Value ( ) ; int mask = bit . int Value ( ) ; int n = ( old & ( ~ mask ) ) ; n = ( no ) ? n : ( n | mask ) ; put ( fault , new Integer ( n ) ) ; return n ; }
public void save ( ) throws IO Exception { try { Process . check If Savable ( this ) ; } catch ( Exception e ) { throw new IO Exception ( e . get Message ( ) ) ; } if ( process Location != null ) { this . is Process Converted = BOOL ; process Location . store ( this , null ) ; } else { throw new IO Exception ( STRING ) ; } }
public void assert Joined ( final UUID service Id ) { m triggers . add ( new Quorum Event Invariant ( Quorum Event Enum . SERVICE LEAVE , service Id ) ) ; assert Membership ( m quorum . get Joined ( ) , service Id ) ; }
private Hashtable Entry < K , V > [ ] double Capacity ( ) { Hashtable Entry < K , V > [ ] old Table = table ; int old Capacity = old Table . length ; if ( old Capacity == MAXIMUM CAPACITY ) { return old Table ; } int new Capacity = old Capacity * NUM ; Hashtable Entry < K , V > [ ] new Table = make Table ( new Capacity ) ; if ( size == NUM ) { return new Table ; } for ( int j = NUM ; j < old Capacity ; j ++ ) { Hashtable Entry < K , V > e = old Table [ j ] ; if ( e == null ) { continue ; } int high Bit = e . hash & old Capacity ; Hashtable Entry < K , V > broken = null ; new Table [ j | high Bit ] = e ; for ( Hashtable Entry < K , V > n = e . next ; n != null ; e = n , n = n . next ) { int next High Bit = n . hash & old Capacity ; if ( next High Bit != high Bit ) { if ( broken == null ) new Table [ j | next High Bit ] = n ; else broken . next = n ; broken = e ; high Bit = next High Bit ; } } if ( broken != null ) broken . next = null ; } return new Table ; }
private Hashtable Entry < K , V > [ ] double Capacity ( ) { Hashtable Entry < K , V > [ ] old Table = table ; int old Capacity = old Table . length ; if ( old Capacity == MAXIMUM CAPACITY ) { return old Table ; } int new Capacity = old Capacity * NUM ; Hashtable Entry < K , V > [ ] new Table = make Table ( new Capacity ) ; if ( size == NUM ) { return new Table ; } for ( int j = NUM ; j < old Capacity ; j ++ ) { Hashtable Entry < K , V > e = old Table [ j ] ; if ( e == null ) { continue ; } int high Bit = e . hash & old Capacity ; Hashtable Entry < K , V > broken = null ; new Table [ j | high Bit ] = e ; for ( Hashtable Entry < K , V > n = e . next ; n != null ; e = n , n = n . next ) { int next High Bit = n . hash & old Capacity ; if ( next High Bit != high Bit ) { if ( broken == null ) new Table [ j | next High Bit ] = n ; else broken . next = n ; broken = e ; high Bit = next High Bit ; } } if ( broken != null ) broken . next = null ; } return new Table ; }
private Hashtable Entry < K , V > [ ] double Capacity ( ) { Hashtable Entry < K , V > [ ] old Table = table ; int old Capacity = old Table . length ; if ( old Capacity == MAXIMUM CAPACITY ) { return old Table ; } int new Capacity = old Capacity * NUM ; Hashtable Entry < K , V > [ ] new Table = make Table ( new Capacity ) ; if ( size == NUM ) { return new Table ; } for ( int j = NUM ; j < old Capacity ; j ++ ) { Hashtable Entry < K , V > e = old Table [ j ] ; if ( e == null ) { continue ; } int high Bit = e . hash & old Capacity ; Hashtable Entry < K , V > broken = null ; new Table [ j | high Bit ] = e ; for ( Hashtable Entry < K , V > n = e . next ; n != null ; e = n , n = n . next ) { int next High Bit = n . hash & old Capacity ; if ( next High Bit != high Bit ) { if ( broken == null ) new Table [ j | next High Bit ] = n ; else broken . next = n ; broken = e ; high Bit = next High Bit ; } } if ( broken != null ) broken . next = null ; } return new Table ; }
private Hashtable Entry < K , V > [ ] double Capacity ( ) { Hashtable Entry < K , V > [ ] old Table = table ; int old Capacity = old Table . length ; if ( old Capacity == MAXIMUM CAPACITY ) { return old Table ; } int new Capacity = old Capacity * NUM ; Hashtable Entry < K , V > [ ] new Table = make Table ( new Capacity ) ; if ( size == NUM ) { return new Table ; } for ( int j = NUM ; j < old Capacity ; j ++ ) { Hashtable Entry < K , V > e = old Table [ j ] ; if ( e == null ) { continue ; } int high Bit = e . hash & old Capacity ; Hashtable Entry < K , V > broken = null ; new Table [ j | high Bit ] = e ; for ( Hashtable Entry < K , V > n = e . next ; n != null ; e = n , n = n . next ) { int next High Bit = n . hash & old Capacity ; if ( next High Bit != high Bit ) { if ( broken == null ) new Table [ j | next High Bit ] = n ; else broken . next = n ; broken = e ; high Bit = next High Bit ; } } if ( broken != null ) broken . next = null ; } return new Table ; }
private void replace Collapsed Edges ( ) { List new Edges = new Array List ( ) ; for ( Iterator it = edge List . iterator ( ) ; it . has Next ( ) ; ) { Edge e = ( Edge ) it . next ( ) ; if ( e . is Collapsed ( ) ) { it . remove ( ) ; new Edges . add ( e . get Collapsed Edge ( ) ) ; } } edge List . add All ( new Edges ) ; }
private void replace Collapsed Edges ( ) { List new Edges = new Array List ( ) ; for ( Iterator it = edge List . iterator ( ) ; it . has Next ( ) ; ) { Edge e = ( Edge ) it . next ( ) ; if ( e . is Collapsed ( ) ) { it . remove ( ) ; new Edges . add ( e . get Collapsed Edge ( ) ) ; } } edge List . add All ( new Edges ) ; }
private C Plugin Output Dialog ( ) { super ( ( J Frame ) null , STRING ) ; new C Dialog Escaper ( this ) ; set Layout ( new Border Layout ( ) ) ; m text Area . set Editable ( BOOL ) ; m text Area . set Font ( Gui Helper . MONOSPACED FONT ) ; add ( new J Scroll Pane ( m text Area ) ) ; final J Panel bottom Panel = new J Panel ( new Border Layout ( ) ) ; bottom Panel . add ( new J Button ( new Clear Action ( ) ) , Border Layout . WEST ) ; bottom Panel . add ( new J Button ( new Close Action ( ) ) , Border Layout . EAST ) ; add ( bottom Panel , Border Layout . SOUTH ) ; set Always On Top ( BOOL ) ; set J Menu Bar ( new C Log Console Menu Bar ( ) ) ; m text Area . add Mouse Listener ( new Internal Mouse Listener ( ) ) ; set Size ( NUM , NUM ) ; }
private void read Object ( Object Input Stream oos ) throws IO Exception , Class Not Found Exception { i Instant = ( Mutable Date Time ) oos . read Object ( ) ; Date Time Field Type type = ( Date Time Field Type ) oos . read Object ( ) ; i Field = type . get Field ( i Instant . get Chronology ( ) ) ; }
private void read Object ( Object Input Stream oos ) throws IO Exception , Class Not Found Exception { i Instant = ( Mutable Date Time ) oos . read Object ( ) ; Date Time Field Type type = ( Date Time Field Type ) oos . read Object ( ) ; i Field = type . get Field ( i Instant . get Chronology ( ) ) ; }
@ Override public int hash Code ( ) { int result = NUM ; for ( int i = NUM ; i < vals . length ; i ++ ) result = NUM * result + Float . float To Int Bits ( vals [ i ] ) ; return result ; }
public void remove Child ( Group the Group ) { m Children . remove ( the Group ) ; }
public JSON Array names ( ) { JSON Array ja = new JSON Array ( ) ; Iterator keys = keys ( ) ; while ( keys . has Next ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == NUM ? null : ja ; }
public JSON Array names ( ) { JSON Array ja = new JSON Array ( ) ; Iterator keys = keys ( ) ; while ( keys . has Next ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == NUM ? null : ja ; }
public JSON Array names ( ) { JSON Array ja = new JSON Array ( ) ; Iterator keys = keys ( ) ; while ( keys . has Next ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == NUM ? null : ja ; }
public static List < String > split Smart ( String s , String separator , boolean decode ) { Array List < String > lst = new Array List < > ( NUM ) ; String Builder sb = new String Builder ( ) ; int pos = NUM , end = s . length ( ) ; while ( pos < end ) { if ( s . starts With ( separator , pos ) ) { if ( sb . length ( ) > NUM ) { lst . add ( sb . to String ( ) ) ; sb = new String Builder ( ) ; } pos += separator . length ( ) ; continue ; } char ch = s . char At ( pos ++ ) ; if ( ch == STRING ) { if ( ! decode ) sb . append ( ch ) ; if ( pos >= end ) break ; ch = s . char At ( pos ++ ) ; if ( decode ) { switch ( ch ) { case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; } } } sb . append ( ch ) ; } if ( sb . length ( ) > NUM ) { lst . add ( sb . to String ( ) ) ; } return lst ; }
public static List < String > split Smart ( String s , String separator , boolean decode ) { Array List < String > lst = new Array List < > ( NUM ) ; String Builder sb = new String Builder ( ) ; int pos = NUM , end = s . length ( ) ; while ( pos < end ) { if ( s . starts With ( separator , pos ) ) { if ( sb . length ( ) > NUM ) { lst . add ( sb . to String ( ) ) ; sb = new String Builder ( ) ; } pos += separator . length ( ) ; continue ; } char ch = s . char At ( pos ++ ) ; if ( ch == STRING ) { if ( ! decode ) sb . append ( ch ) ; if ( pos >= end ) break ; ch = s . char At ( pos ++ ) ; if ( decode ) { switch ( ch ) { case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; } } } sb . append ( ch ) ; } if ( sb . length ( ) > NUM ) { lst . add ( sb . to String ( ) ) ; } return lst ; }
public static List < String > split Smart ( String s , String separator , boolean decode ) { Array List < String > lst = new Array List < > ( NUM ) ; String Builder sb = new String Builder ( ) ; int pos = NUM , end = s . length ( ) ; while ( pos < end ) { if ( s . starts With ( separator , pos ) ) { if ( sb . length ( ) > NUM ) { lst . add ( sb . to String ( ) ) ; sb = new String Builder ( ) ; } pos += separator . length ( ) ; continue ; } char ch = s . char At ( pos ++ ) ; if ( ch == STRING ) { if ( ! decode ) sb . append ( ch ) ; if ( pos >= end ) break ; ch = s . char At ( pos ++ ) ; if ( decode ) { switch ( ch ) { case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; } } } sb . append ( ch ) ; } if ( sb . length ( ) > NUM ) { lst . add ( sb . to String ( ) ) ; } return lst ; }
public static List < String > split Smart ( String s , String separator , boolean decode ) { Array List < String > lst = new Array List < > ( NUM ) ; String Builder sb = new String Builder ( ) ; int pos = NUM , end = s . length ( ) ; while ( pos < end ) { if ( s . starts With ( separator , pos ) ) { if ( sb . length ( ) > NUM ) { lst . add ( sb . to String ( ) ) ; sb = new String Builder ( ) ; } pos += separator . length ( ) ; continue ; } char ch = s . char At ( pos ++ ) ; if ( ch == STRING ) { if ( ! decode ) sb . append ( ch ) ; if ( pos >= end ) break ; ch = s . char At ( pos ++ ) ; if ( decode ) { switch ( ch ) { case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; } } } sb . append ( ch ) ; } if ( sb . length ( ) > NUM ) { lst . add ( sb . to String ( ) ) ; } return lst ; }
public static List < String > split Smart ( String s , String separator , boolean decode ) { Array List < String > lst = new Array List < > ( NUM ) ; String Builder sb = new String Builder ( ) ; int pos = NUM , end = s . length ( ) ; while ( pos < end ) { if ( s . starts With ( separator , pos ) ) { if ( sb . length ( ) > NUM ) { lst . add ( sb . to String ( ) ) ; sb = new String Builder ( ) ; } pos += separator . length ( ) ; continue ; } char ch = s . char At ( pos ++ ) ; if ( ch == STRING ) { if ( ! decode ) sb . append ( ch ) ; if ( pos >= end ) break ; ch = s . char At ( pos ++ ) ; if ( decode ) { switch ( ch ) { case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; } } } sb . append ( ch ) ; } if ( sb . length ( ) > NUM ) { lst . add ( sb . to String ( ) ) ; } return lst ; }
public static final byte [ ] decode ( Buffered Reader reader ) throws IO Exception , Base 64 Decoding Exception { byte [ ] ret Bytes = null ; Unsync Byte Array Output Stream baos = null ; try { baos = new Unsync Byte Array Output Stream ( ) ; String line ; while ( null != ( line = reader . read Line ( ) ) ) { byte [ ] bytes = decode ( line ) ; baos . write ( bytes ) ; } ret Bytes = baos . to Byte Array ( ) ; } finally { baos . close ( ) ; } return ret Bytes ; }
public static final byte [ ] decode ( Buffered Reader reader ) throws IO Exception , Base 64 Decoding Exception { byte [ ] ret Bytes = null ; Unsync Byte Array Output Stream baos = null ; try { baos = new Unsync Byte Array Output Stream ( ) ; String line ; while ( null != ( line = reader . read Line ( ) ) ) { byte [ ] bytes = decode ( line ) ; baos . write ( bytes ) ; } ret Bytes = baos . to Byte Array ( ) ; } finally { baos . close ( ) ; } return ret Bytes ; }
public static final byte [ ] decode ( Buffered Reader reader ) throws IO Exception , Base 64 Decoding Exception { byte [ ] ret Bytes = null ; Unsync Byte Array Output Stream baos = null ; try { baos = new Unsync Byte Array Output Stream ( ) ; String line ; while ( null != ( line = reader . read Line ( ) ) ) { byte [ ] bytes = decode ( line ) ; baos . write ( bytes ) ; } ret Bytes = baos . to Byte Array ( ) ; } finally { baos . close ( ) ; } return ret Bytes ; }
public void expect Success ( Message Info message Info ) { expected Api Calls . add ( new Api Call ( SUCCESS , new Object [ ] { message Info . get Origin ( ) , message Info . get Client ( ) , message Info . get Service ( ) } ) ) ; }
public long content Length ( ) { long size ; try { size = Long . parse Long ( request . get Header ( File Upload . CONTENT LENGTH ) ) ; } catch ( Number Format Exception e ) { size = request . get Content Length ( ) ; } return size ; }
public Db Schema Changer add Annotation ( String method Name , String annotation Name , Map < String , Object > values ) throws Exception { Ct Method method Descriptor = cc . get Declared Method ( method Name ) ; Class File cc File = cc . get Class File ( ) ; cc File . set Version To Java 5 ( ) ; Const Pool constpool = cc File . get Const Pool ( ) ; Method Info minfo = method Descriptor . get Method Info ( ) ; Annotations Attribute attr = ( Annotations Attribute ) minfo . get Attribute ( Annotations Attribute . visible Tag ) ; if ( attr == null ) { attr = new Annotations Attribute ( constpool , Annotations Attribute . visible Tag ) ; } Annotation annot = new Annotation ( annotation Name , constpool ) ; Set < Map . Entry < String , Object > > entries = values . entry Set ( ) ; for ( Map . Entry < String , Object > entry : entries ) { String attr Name = entry . get Key ( ) ; Object attr Value = entry . get Value ( ) ; if ( attr Value instanceof String ) { annot . add Member Value ( attr Name , new String Member Value ( ( String ) attr Value , cc File . get Const Pool ( ) ) ) ; } else { throw new Runtime Exception ( String . format ( STRING , attr Name , attr Value ) ) ; } } attr . add Annotation ( annot ) ; minfo . add Attribute ( attr ) ; log . info ( STRING , attr , method Descriptor ) ; return this ; }
public static void premain ( String agent Args , Instrumentation inst ) { instrumentation = inst ; LOGGER . info ( STRING ) ; check For Correct Setup ( ) ; try { @ Suppress Warnings ( STRING ) Inspect It Class Loader class Loader = new Inspect It Class Loader ( new URL [ NUM ] ) ; Class < ? > agent Clazz = class Loader . load Class ( INSPECTIT AGENT ) ; Constructor < ? > constructor = agent Clazz . get Constructor ( File . class ) ; Object real Agent = constructor . new Instance ( get Inspect It Agent Jar File Location ( ) ) ; Agent . agent = ( I Agent ) real Agent ; preload Classes ( ) ; LOGGER . info ( STRING ) ; analyze Already Loaded Classes ( ) ; inst . add Transformer ( new Java Agent ( ) ) ; } catch ( Exception e ) { LOGGER . severe ( STRING ) ; e . print Stack Trace ( ) ; } }
private static void insert Native Edge ( final List < Reil Block > nodes , final List < Reil Edge > edges , final I Code Edge < ? > native Edge , final Reil Instruction source Reil Instruction , final Reil Instruction target Reil Instruction ) { for ( final Reil Block node : nodes ) { if ( ( source Reil Instruction == get Last Instruction ( node ) ) && ! has Edge ( nodes , node , target Reil Instruction ) ) { final Edge Type edge Type = Reil Helpers . is Jump ( source Reil Instruction ) ? native Edge . get Type ( ) : Edge Type . JUMP UNCONDITIONAL ; final Reil Block target Node = get Node ( target Reil Instruction , nodes ) ; final Reil Edge new Edge = new Reil Edge ( node , target Node , edge Type ) ; Reil Block . link ( node , target Node , new Edge ) ; edges . add ( new Edge ) ; } } }
private boolean contains ( String ids [ ] , String id ) { for ( int i = NUM ; i < ids . length ; i ++ ) { if ( Operator . compare ( ids [ i ] , id ) == NUM ) return BOOL ; } return BOOL ; }
private boolean contains ( String ids [ ] , String id ) { for ( int i = NUM ; i < ids . length ; i ++ ) { if ( Operator . compare ( ids [ i ] , id ) == NUM ) return BOOL ; } return BOOL ; }
public static void check For Export Rule To Delete ( Hash Map < String , Export Rule > source Export Rule Map , Hash Map < String , Export Rule > target Export Rule Map , List < Export Rule > export Rules To Delete ) { for ( String sec Flavour : target Export Rule Map . key Set ( ) ) { if ( ! source Export Rule Map . contains Key ( sec Flavour ) ) { export Rules To Delete . add ( target Export Rule Map . get ( sec Flavour ) ) ; } } }
public Flux Map Fuseable ( Publisher < ? extends T > source , Function < ? super T , ? extends R > mapper ) { super ( source ) ; this . mapper = Objects . require Non Null ( mapper , STRING ) ; }
@ Visible For Testing public void process Enable Fullscreen Runnable For Test ( ) { if ( m Handler . has Messages ( MSG ID ENABLE FULLSCREEN AFTER LOAD ) ) { m Handler . remove Messages ( MSG ID ENABLE FULLSCREEN AFTER LOAD ) ; enable Fullscreen After Load ( ) ; } }
private void fill Text ( Input Node from ) throws Exception { Event Node event = reader . peek ( ) ; if ( event . is Text ( ) ) { String data = event . get Value ( ) ; text . append ( data ) ; } }
private void fill Text ( Input Node from ) throws Exception { Event Node event = reader . peek ( ) ; if ( event . is Text ( ) ) { String data = event . get Value ( ) ; text . append ( data ) ; } }
private void fill Text ( Input Node from ) throws Exception { Event Node event = reader . peek ( ) ; if ( event . is Text ( ) ) { String data = event . get Value ( ) ; text . append ( data ) ; } }
private void fill Text ( Input Node from ) throws Exception { Event Node event = reader . peek ( ) ; if ( event . is Text ( ) ) { String data = event . get Value ( ) ; text . append ( data ) ; } }
public static int java New ( int lua State , Class clazz ) throws Lua Exception { Lua State L = Lua State Factory . get Existing State ( lua State ) ; synchronized ( L ) { Object ret = get Obj Instance ( L , clazz ) ; L . push Java Object ( ret ) ; return NUM ; } }
public static int java New ( int lua State , Class clazz ) throws Lua Exception { Lua State L = Lua State Factory . get Existing State ( lua State ) ; synchronized ( L ) { Object ret = get Obj Instance ( L , clazz ) ; L . push Java Object ( ret ) ; return NUM ; } }
public static byte [ ] load Image File ( File image Loc ) throws IO Exception { File Input Stream fis = new File Input Stream ( image Loc ) ; byte [ ] read = new byte [ fis . available ( ) ] ; fis . read ( read ) ; fis . close ( ) ; return read ; }
public static byte [ ] load Image File ( File image Loc ) throws IO Exception { File Input Stream fis = new File Input Stream ( image Loc ) ; byte [ ] read = new byte [ fis . available ( ) ] ; fis . read ( read ) ; fis . close ( ) ; return read ; }
public static final String make Compound Field ( String delimiter , String ... term ) { String Builder sb = new String Builder ( ) ; for ( String s : term ) { if ( s . length ( ) != NUM ) { if ( delimiter != null && sb . length ( ) != NUM ) { sb . append ( delimiter ) ; } sb . append ( s ) ; } } return sb . to String ( ) ; }
public static final String make Compound Field ( String delimiter , String ... term ) { String Builder sb = new String Builder ( ) ; for ( String s : term ) { if ( s . length ( ) != NUM ) { if ( delimiter != null && sb . length ( ) != NUM ) { sb . append ( delimiter ) ; } sb . append ( s ) ; } } return sb . to String ( ) ; }
@ Override public Alarm Event evaluate ( Alarm Point alarm , String trigger ) { if ( trigger . equals ( Alarm Point . TRIGGER ACTIVATE ) ) { return activation ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER DEACTIVATE ) ) { return deactivation ( alarm ) ; } else { throw new Illegal Argument Exception ( STRING + trigger + STRING ) ; } }
@ Override public Alarm Event evaluate ( Alarm Point alarm , String trigger ) { if ( trigger . equals ( Alarm Point . TRIGGER ACTIVATE ) ) { return activation ( alarm ) ; } else if ( trigger . equals ( Alarm Point . TRIGGER DEACTIVATE ) ) { return deactivation ( alarm ) ; } else { throw new Illegal Argument Exception ( STRING + trigger + STRING ) ; } }
private static void fix Prng ( ) { if ( ! prng Fixed . get ( ) ) { synchronized ( Prng Fixes . class ) { if ( ! prng Fixed . get ( ) ) { Prng Fixes . apply ( ) ; prng Fixed . set ( BOOL ) ; } } } }
private static void fix Prng ( ) { if ( ! prng Fixed . get ( ) ) { synchronized ( Prng Fixes . class ) { if ( ! prng Fixed . get ( ) ) { Prng Fixes . apply ( ) ; prng Fixed . set ( BOOL ) ; } } } }
private static void fix Prng ( ) { if ( ! prng Fixed . get ( ) ) { synchronized ( Prng Fixes . class ) { if ( ! prng Fixed . get ( ) ) { Prng Fixes . apply ( ) ; prng Fixed . set ( BOOL ) ; } } } }
public void append Results ( List < Search Result > search Results ) { m Search Results . add All ( search Results ) ; for ( Search Result search Result : search Results ) { final Provider Identifier id = search Result . get Identifier ( ) ; final List < String > songs = search Result . get Songs List ( ) ; final List < String > artists = search Result . get Artist List ( ) ; final List < String > playlists = search Result . get Playlist List ( ) ; final List < String > albums = search Result . get Albums List ( ) ; for ( String song : songs ) { Search Entry entry = new Search Entry ( song , id ) ; if ( ! m All Songs . contains ( entry ) ) { m All Songs . add ( entry ) ; } } for ( String artist : artists ) { Search Entry entry = new Search Entry ( artist , id ) ; if ( ! m All Artists . contains ( entry ) ) { m All Artists . add ( entry ) ; } } for ( String playlist : playlists ) { Search Entry entry = new Search Entry ( playlist , id ) ; if ( ! m All Playlists . contains ( entry ) ) { m All Playlists . add ( entry ) ; } } for ( String album : albums ) { Search Entry entry = new Search Entry ( album , id ) ; if ( ! m All Albums . contains ( entry ) ) { m All Albums . add ( entry ) ; } } } compute Results List ( ) ; }
protected static Array List < Geo Point > parse Kml Coordinates ( String input ) { Linked List < Geo Point > tmp Coords = new Linked List < Geo Point > ( ) ; int i = NUM ; int tuple Start = NUM ; int length = input . length ( ) ; boolean start Reading Tuple = BOOL ; while ( i < length ) { char c = input . char At ( i ) ; if ( c == STRING || c == STRING || c == STRING ) { if ( start Reading Tuple ) { String tuple = input . substring ( tuple Start , i ) ; Geo Point p = parse Kml Coord ( tuple ) ; if ( p != null ) tmp Coords . add ( p ) ; start Reading Tuple = BOOL ; } } else { if ( ! start Reading Tuple ) { start Reading Tuple = BOOL ; tuple Start = i ; } if ( i == length - NUM ) { String tuple = input . substring ( tuple Start , i + NUM ) ; Geo Point p = parse Kml Coord ( tuple ) ; if ( p != null ) tmp Coords . add ( p ) ; } } i ++ ; } Array List < Geo Point > coordinates = new Array List < Geo Point > ( tmp Coords . size ( ) ) ; coordinates . add All ( tmp Coords ) ; return coordinates ; }
protected static Array List < Geo Point > parse Kml Coordinates ( String input ) { Linked List < Geo Point > tmp Coords = new Linked List < Geo Point > ( ) ; int i = NUM ; int tuple Start = NUM ; int length = input . length ( ) ; boolean start Reading Tuple = BOOL ; while ( i < length ) { char c = input . char At ( i ) ; if ( c == STRING || c == STRING || c == STRING ) { if ( start Reading Tuple ) { String tuple = input . substring ( tuple Start , i ) ; Geo Point p = parse Kml Coord ( tuple ) ; if ( p != null ) tmp Coords . add ( p ) ; start Reading Tuple = BOOL ; } } else { if ( ! start Reading Tuple ) { start Reading Tuple = BOOL ; tuple Start = i ; } if ( i == length - NUM ) { String tuple = input . substring ( tuple Start , i + NUM ) ; Geo Point p = parse Kml Coord ( tuple ) ; if ( p != null ) tmp Coords . add ( p ) ; } } i ++ ; } Array List < Geo Point > coordinates = new Array List < Geo Point > ( tmp Coords . size ( ) ) ; coordinates . add All ( tmp Coords ) ; return coordinates ; }
public void enter Source ( Node Handler handler , Context context ) { Node Info curr = context . get Context Node Info ( ) ; final String path = Navigator . get Path ( curr ) ; if ( TRACE ) { trace ( indent + STRING + path + STRING + curr . get Line Number ( ) + STRING + get Mode Name ( context ) + STRING ) ; indent += STRING ; } my Debugger . push Source ( new Saxon Source Frame ( my Debugger . get Source Frame ( ) , curr ) ) ; }
public static String extract Response ( String saml Request Parameter ) throws Exception { Inflater decompresser = new Inflater ( BOOL ) ; Byte Array Output Stream byte Array Output Stream = new Byte Array Output Stream ( ) ; Inflater Output Stream inflater Output Stream = new Inflater Output Stream ( byte Array Output Stream , decompresser ) ; inflater Output Stream . write ( Base 64 . decode ( saml Request Parameter ) ) ; inflater Output Stream . close ( ) ; String output String = new String ( byte Array Output Stream . to Byte Array ( ) , STRING ) ; return output String ; }
public static String extract Response ( String saml Request Parameter ) throws Exception { Inflater decompresser = new Inflater ( BOOL ) ; Byte Array Output Stream byte Array Output Stream = new Byte Array Output Stream ( ) ; Inflater Output Stream inflater Output Stream = new Inflater Output Stream ( byte Array Output Stream , decompresser ) ; inflater Output Stream . write ( Base 64 . decode ( saml Request Parameter ) ) ; inflater Output Stream . close ( ) ; String output String = new String ( byte Array Output Stream . to Byte Array ( ) , STRING ) ; return output String ; }
public static String extract Response ( String saml Request Parameter ) throws Exception { Inflater decompresser = new Inflater ( BOOL ) ; Byte Array Output Stream byte Array Output Stream = new Byte Array Output Stream ( ) ; Inflater Output Stream inflater Output Stream = new Inflater Output Stream ( byte Array Output Stream , decompresser ) ; inflater Output Stream . write ( Base 64 . decode ( saml Request Parameter ) ) ; inflater Output Stream . close ( ) ; String output String = new String ( byte Array Output Stream . to Byte Array ( ) , STRING ) ; return output String ; }
public static String extract Response ( String saml Request Parameter ) throws Exception { Inflater decompresser = new Inflater ( BOOL ) ; Byte Array Output Stream byte Array Output Stream = new Byte Array Output Stream ( ) ; Inflater Output Stream inflater Output Stream = new Inflater Output Stream ( byte Array Output Stream , decompresser ) ; inflater Output Stream . write ( Base 64 . decode ( saml Request Parameter ) ) ; inflater Output Stream . close ( ) ; String output String = new String ( byte Array Output Stream . to Byte Array ( ) , STRING ) ; return output String ; }
public int read ( ) throws IO Exception { int val ; if ( ( val = is . read ( ) ) < NUM ) { return - NUM ; } if ( bo == STRING ) { val = ( char ) ( ( val << NUM ) | ( is . read ( ) & NUM ) ) ; } else { val = ( char ) ( ( is . read ( ) << NUM ) | ( val & NUM ) ) ; } return val ; }
private Chrono Local Date of Week Based Year ( Chronology chrono , int yowby , int wowby , int dow ) { Chrono Local Date date = chrono . date ( yowby , NUM , NUM ) ; int ldow = localized Day Of Week ( date ) ; int offset = start Of Week Offset ( NUM , ldow ) ; int year Len = date . length Of Year ( ) ; int new Year Week = compute Week ( offset , year Len + week Def . get Minimal Days In First Week ( ) ) ; wowby = Math . min ( wowby , new Year Week - NUM ) ; int days = - offset + ( dow - NUM ) + ( wowby - NUM ) * NUM ; return date . plus ( days , DAYS ) ; }
public Shape Tile Simplex remove border line ( int p no ) { if ( p no < NUM || p no >= lines size ( ) ) { return this ; } Array List < Pla Line Int > new arr = new Array List < Pla Line Int > ( lines size ( ) ) ; new arr . add All ( lines list ) ; new arr . remove ( p no ) ; return new Shape Tile Simplex ( new arr ) ; }
public Shape Tile Simplex remove border line ( int p no ) { if ( p no < NUM || p no >= lines size ( ) ) { return this ; } Array List < Pla Line Int > new arr = new Array List < Pla Line Int > ( lines size ( ) ) ; new arr . add All ( lines list ) ; new arr . remove ( p no ) ; return new Shape Tile Simplex ( new arr ) ; }
public Shape Tile Simplex remove border line ( int p no ) { if ( p no < NUM || p no >= lines size ( ) ) { return this ; } Array List < Pla Line Int > new arr = new Array List < Pla Line Int > ( lines size ( ) ) ; new arr . add All ( lines list ) ; new arr . remove ( p no ) ; return new Shape Tile Simplex ( new arr ) ; }
final void append Print String ( String Buffer buffer ) { Naive AST Flattener printer = new Naive AST Flattener ( ) ; accept ( printer ) ; buffer . append ( printer . get Result ( ) ) ; }
@ Override public void agg ( Object new Val ) { value Set For Obj . add ( new Val ) ; }
@ Override public void agg ( Object new Val ) { value Set For Obj . add ( new Val ) ; }
public synchronized void add New File ( long seqno , String file Name ) { logger . info ( STRING + file Name + STRING + seqno ) ; index . add ( new Log Index Entry ( seqno , Long . MAX VALUE , file Name ) ) ; if ( retention Millis > NUM ) { String active File = get File ( active Seqno ) ; File [ ] purge Candidates = File Commands . files Over Retention And Inactive ( log Dir , file Prefix , NUM , active File ) ; File [ ] files To Purge = File Commands . files Over Mod Date ( purge Candidates , new Interval ( retention Millis ) ) ; if ( files To Purge . length > NUM ) { for ( File file : files To Purge ) remove File ( file . get Name ( ) ) ; File Commands . delete Files ( files To Purge , BOOL ) ; } } }
@ Override public Axis State draw ( Graphics 2 D g2 , double cursor , Rectangle 2 D plot Area , Rectangle 2 D data Area , Rectangle Edge edge , Plot Rendering Info plot State ) { if ( ! is Visible ( ) ) { return new Axis State ( cursor ) ; } if ( is Axis Line Visible ( ) ) { draw Axis Line ( g2 , cursor , data Area , edge ) ; } Axis State state = new Axis State ( cursor ) ; state = draw Sub Category Labels ( g2 , plot Area , data Area , edge , state , plot State ) ; state = draw Category Labels ( g2 , plot Area , data Area , edge , state , plot State ) ; if ( get Attributed Label ( ) != null ) { state = draw Attributed Label ( get Attributed Label ( ) , g2 , plot Area , data Area , edge , state ) ; } else { state = draw Label ( get Label ( ) , g2 , plot Area , data Area , edge , state ) ; } return state ; }
@ Override public Axis State draw ( Graphics 2 D g2 , double cursor , Rectangle 2 D plot Area , Rectangle 2 D data Area , Rectangle Edge edge , Plot Rendering Info plot State ) { if ( ! is Visible ( ) ) { return new Axis State ( cursor ) ; } if ( is Axis Line Visible ( ) ) { draw Axis Line ( g2 , cursor , data Area , edge ) ; } Axis State state = new Axis State ( cursor ) ; state = draw Sub Category Labels ( g2 , plot Area , data Area , edge , state , plot State ) ; state = draw Category Labels ( g2 , plot Area , data Area , edge , state , plot State ) ; if ( get Attributed Label ( ) != null ) { state = draw Attributed Label ( get Attributed Label ( ) , g2 , plot Area , data Area , edge , state ) ; } else { state = draw Label ( get Label ( ) , g2 , plot Area , data Area , edge , state ) ; } return state ; }
public static Credentials acquire Service Creds ( String service , Credentials ccreds ) throws Krb Exception , IO Exception { return Credentials Util . acquire Service Creds ( service , ccreds ) ; }
public static Credentials acquire Service Creds ( String service , Credentials ccreds ) throws Krb Exception , IO Exception { return Credentials Util . acquire Service Creds ( service , ccreds ) ; }
public static Credentials acquire Service Creds ( String service , Credentials ccreds ) throws Krb Exception , IO Exception { return Credentials Util . acquire Service Creds ( service , ccreds ) ; }
public static Credentials acquire Service Creds ( String service , Credentials ccreds ) throws Krb Exception , IO Exception { return Credentials Util . acquire Service Creds ( service , ccreds ) ; }
public static Credentials acquire Service Creds ( String service , Credentials ccreds ) throws Krb Exception , IO Exception { return Credentials Util . acquire Service Creds ( service , ccreds ) ; }
public static Credentials acquire Service Creds ( String service , Credentials ccreds ) throws Krb Exception , IO Exception { return Credentials Util . acquire Service Creds ( service , ccreds ) ; }
public static Credentials acquire Service Creds ( String service , Credentials ccreds ) throws Krb Exception , IO Exception { return Credentials Util . acquire Service Creds ( service , ccreds ) ; }
public static Credentials acquire Service Creds ( String service , Credentials ccreds ) throws Krb Exception , IO Exception { return Credentials Util . acquire Service Creds ( service , ccreds ) ; }
public static Credentials acquire Service Creds ( String service , Credentials ccreds ) throws Krb Exception , IO Exception { return Credentials Util . acquire Service Creds ( service , ccreds ) ; }
public static Credentials acquire Service Creds ( String service , Credentials ccreds ) throws Krb Exception , IO Exception { return Credentials Util . acquire Service Creds ( service , ccreds ) ; }
public static Credentials acquire Service Creds ( String service , Credentials ccreds ) throws Krb Exception , IO Exception { return Credentials Util . acquire Service Creds ( service , ccreds ) ; }
public static Control Tag Cache Object create Test Sub Equipment Alive ( ) { Control Tag Cache Object cache Object = new Control Tag Cache Object ( new Long ( NUM ) , STRING , STRING , Data Tag Constants . MODE TEST ) ; cache Object . set Description ( STRING ) ; cache Object . set Logged ( BOOL ) ; cache Object . set Unit ( STRING ) ; cache Object . set Dip Address ( STRING ) ; cache Object . set Japc Address ( STRING ) ; cache Object . set Value ( new Long ( System . current Time Millis ( ) ) ) ; cache Object . set Value Description ( STRING ) ; cache Object . set Simulated ( BOOL ) ; cache Object . set Min Value ( Long . MIN VALUE ) ; cache Object . set Max Value ( Long . MAX VALUE ) ; cache Object . set Value Dictionary ( new Data Tag Value Dictionary ( ) ) ; cache Object . set Address ( new Data Tag Address ( ) ) ; cache Object . set Data Tag Quality ( create Valid Quality ( ) ) ; cache Object . set Cache Timestamp ( new Timestamp ( System . current Time Millis ( ) ) ) ; cache Object . set Daq Timestamp ( new Timestamp ( System . current Time Millis ( ) ) ) ; cache Object . set Source Timestamp ( new Timestamp ( System . current Time Millis ( ) ) ) ; return cache Object ; }
protected double category Utility ( ) throws Exception { if ( m children == null ) { throw new Exception ( STRING ) ; } double total CU = NUM ; for ( int i = NUM ; i < m children . size ( ) ; i ++ ) { C Node child = m children . get ( i ) ; total CU += category Utility Child ( child ) ; } total CU /= m children . size ( ) ; return total CU ; }
public void write ( int b ) throws IO Exception { file . write ( b ) ; }
public void write ( int b ) throws IO Exception { file . write ( b ) ; }
@ Suppress Warnings ( STRING ) public Url Critter add Url ( String url , Context context ) { List < String > urls = url Manager . get Urls ( context ) ; if ( ! urls . contains ( url ) ) { urls . add ( url ) ; url Manager . save Urls ( context , urls ) ; } return this ; }
public int add Mana ( int mana , boolean tell ) { int old mana = get Mana ( ) ; int new mana = old mana + mana ; int given = NUM ; new mana = Math . max ( new mana , NUM ) ; new mana = Math . min ( new mana , get Base Mana ( ) ) ; given = new mana - old mana ; if ( tell ) { } set Mana ( new mana ) ; return given ; }
public Training Set Panel ( ) { final J Split Pane split = new J Split Pane ( J Split Pane . HORIZONTAL SPLIT ) ; J Panel filler 1 = new J Panel ( ) ; filler 1 . set Background ( Color . light Gray ) ; J Panel filler 2 = new J Panel ( ) ; filler 2 . set Background ( Color . light Gray ) ; split . set Left Component ( filler 1 ) ; split . set Right Component ( filler 2 ) ; split . set Resize Weight ( NUM ) ; split . set Border ( null ) ; set Layout ( new Grid Bag Layout ( ) ) ; Grid Bag Constraints whole Panel Constraints = new Grid Bag Constraints ( ) ; whole Panel Constraints . fill = Grid Bag Constraints . BOTH ; whole Panel Constraints . weightx = NUM ; whole Panel Constraints . weighty = NUM ; whole Panel Constraints . gridx = NUM ; whole Panel Constraints . gridy = NUM ; add ( split , whole Panel Constraints ) ; }
public License Header Step ( File license File , Charset encoding , String delimiter ) throws IO Exception { this ( new String ( Files . read All Bytes ( license File . to Path ( ) ) , encoding ) , delimiter ) ; }
final public void println ( char [ ] s ) { Writer out = this . out ; if ( out == null ) return ; try { out . write ( s , NUM , s . length ) ; out . write ( newline , NUM , newline . length ) ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } }
public final boolean has Tag ( Tag t ) { return all Tags . contains ( t ) ; }
public final boolean has Tag ( Tag t ) { return all Tags . contains ( t ) ; }
protected static Vector convert To Vector ( final Object [ ] an Array ) { if ( an Array == null ) { return null ; } final Vector v = new Vector ( an Array . length ) ; for ( final Object element : an Array ) { v . add Element ( element ) ; } return v ; }
protected static Vector convert To Vector ( final Object [ ] an Array ) { if ( an Array == null ) { return null ; } final Vector v = new Vector ( an Array . length ) ; for ( final Object element : an Array ) { v . add Element ( element ) ; } return v ; }
public void remove All Trailers ( ) { trailer . clear ( ) ; fire Property Change ( TRAILER , null , trailer ) ; }
void add Field Value ( Map < Temporal Field , Long > field Values , Chrono Field field , long value ) { Long old = field Values . get ( field ) ; if ( old != null && old . long Value ( ) != value ) { throw new Date Time Exception ( STRING + field + STRING + old + STRING + field + STRING + value ) ; } field Values . put ( field , value ) ; }
void add Field Value ( Map < Temporal Field , Long > field Values , Chrono Field field , long value ) { Long old = field Values . get ( field ) ; if ( old != null && old . long Value ( ) != value ) { throw new Date Time Exception ( STRING + field + STRING + old + STRING + field + STRING + value ) ; } field Values . put ( field , value ) ; }
void add Field Value ( Map < Temporal Field , Long > field Values , Chrono Field field , long value ) { Long old = field Values . get ( field ) ; if ( old != null && old . long Value ( ) != value ) { throw new Date Time Exception ( STRING + field + STRING + old + STRING + field + STRING + value ) ; } field Values . put ( field , value ) ; }
void add Field Value ( Map < Temporal Field , Long > field Values , Chrono Field field , long value ) { Long old = field Values . get ( field ) ; if ( old != null && old . long Value ( ) != value ) { throw new Date Time Exception ( STRING + field + STRING + old + STRING + field + STRING + value ) ; } field Values . put ( field , value ) ; }
public static String strip File Extension ( String name ) { int pos = name . last Index Of ( STRING ) ; if ( pos > NUM & pos < name . length ( ) - NUM ) return name . substring ( NUM , pos ) ; return name ; }
private void on Tts Ready ( ) { Locale locale = Locale . get Default ( ) ; int language Availability = tts . is Language Available ( locale ) ; if ( language Availability == Text To Speech . LANG MISSING DATA || language Availability == Text To Speech . LANG NOT SUPPORTED ) { Log . w ( TAG , STRING ) ; locale = Locale . ENGLISH ; } tts . set Language ( locale ) ; tts . set Speech Rate ( TTS SPEECH RATE ) ; tts . set On Utterance Completed Listener ( utterance Listener ) ; }
public static void do With Fields ( Class < ? > clazz , Field Callback fc , Field Filter ff ) throws Illegal Argument Exception { Class < ? > target Class = clazz ; do { Field [ ] fields = target Class . get Declared Fields ( ) ; for ( Field field : fields ) { if ( ff != null && ! ff . matches ( field ) ) { continue ; } try { fc . do With ( field ) ; } catch ( Illegal Access Exception ex ) { throw new Illegal State Exception ( STRING + field . get Name ( ) + STRING + ex ) ; } } target Class = target Class . get Superclass ( ) ; } while ( target Class != null && target Class != Object . class ) ; }
public static void exit ( int code ) { RUNTIME . exit ( code ) ; }
public static void exit ( int code ) { RUNTIME . exit ( code ) ; }
public static void exit ( int code ) { RUNTIME . exit ( code ) ; }
public static void exit ( int code ) { RUNTIME . exit ( code ) ; }
@ Safe Varargs public static < T > Substitution < T > for Args ( List < Type Variable > parameters , T ... arguments ) { if ( parameters . size ( ) != arguments . length ) { throw new Illegal Argument Exception ( STRING + parameters . size ( ) + STRING + arguments . length ) ; } Substitution < T > s = new Substitution < > ( ) ; for ( int i = NUM ; i < parameters . size ( ) ; i ++ ) { s . put ( parameters . get ( i ) , arguments [ i ] ) ; } return s ; }
public static void create Upload Dir ( Server server , String upload Dir ) throws Docker JSON Exception { File upload Folder = new File ( upload Dir + STRING + server . get Container ID ( ) ) ; if ( ! upload Folder . exists ( ) ) { upload Folder . mkdir ( ) ; } }
private void add Service ( Svc Reg reg ) { service By ID . put ( reg . item . service ID , reg ) ; service By Time . put ( reg , reg ) ; add Service By Types ( reg . item . service Type , reg ) ; Entry Rep [ ] entries = reg . item . attribute Sets ; for ( int i = entries . length ; -- i >= NUM ; ) { add Attrs ( reg , entries [ i ] ) ; } compute Max Leases ( ) ; }
private void add Service ( Svc Reg reg ) { service By ID . put ( reg . item . service ID , reg ) ; service By Time . put ( reg , reg ) ; add Service By Types ( reg . item . service Type , reg ) ; Entry Rep [ ] entries = reg . item . attribute Sets ; for ( int i = entries . length ; -- i >= NUM ; ) { add Attrs ( reg , entries [ i ] ) ; } compute Max Leases ( ) ; }
private void add Service ( Svc Reg reg ) { service By ID . put ( reg . item . service ID , reg ) ; service By Time . put ( reg , reg ) ; add Service By Types ( reg . item . service Type , reg ) ; Entry Rep [ ] entries = reg . item . attribute Sets ; for ( int i = entries . length ; -- i >= NUM ; ) { add Attrs ( reg , entries [ i ] ) ; } compute Max Leases ( ) ; }
public void remove Attribute ( String name ) { attributes . remove ( name ) ; }
public void remove Attribute ( String name ) { attributes . remove ( name ) ; }
public boolean show Colors Nick ( ) { return preferences . get Boolean ( resources . get String ( R . string . key show colors nick ) , Boolean . parse Boolean ( resources . get String ( R . string . default show colors nick ) ) ) ; }
private void make Excitatory ( final Neuron source , List < Synapse > syns , boolean loose Synapses ) { for ( Neuron target : get Neurons In Radius ( source , excitatory Radius ) ) { if ( ! source Neurons . contains ( target ) ) { continue ; } if ( Network . get Synapse ( source , target ) != null ) { continue ; } if ( ! allow Self Connections ) { if ( source == target ) { continue ; } } if ( Math . random ( ) < excitatory Probability ) { Synapse synapse = new Synapse ( source , target ) ; synapse . set Strength ( NUM ) ; if ( loose Synapses ) { network . add Synapse ( synapse ) ; } syns . add ( synapse ) ; } network . fire Synapses Updated ( ) ; } }
private void make Excitatory ( final Neuron source , List < Synapse > syns , boolean loose Synapses ) { for ( Neuron target : get Neurons In Radius ( source , excitatory Radius ) ) { if ( ! source Neurons . contains ( target ) ) { continue ; } if ( Network . get Synapse ( source , target ) != null ) { continue ; } if ( ! allow Self Connections ) { if ( source == target ) { continue ; } } if ( Math . random ( ) < excitatory Probability ) { Synapse synapse = new Synapse ( source , target ) ; synapse . set Strength ( NUM ) ; if ( loose Synapses ) { network . add Synapse ( synapse ) ; } syns . add ( synapse ) ; } network . fire Synapses Updated ( ) ; } }
private void make Excitatory ( final Neuron source , List < Synapse > syns , boolean loose Synapses ) { for ( Neuron target : get Neurons In Radius ( source , excitatory Radius ) ) { if ( ! source Neurons . contains ( target ) ) { continue ; } if ( Network . get Synapse ( source , target ) != null ) { continue ; } if ( ! allow Self Connections ) { if ( source == target ) { continue ; } } if ( Math . random ( ) < excitatory Probability ) { Synapse synapse = new Synapse ( source , target ) ; synapse . set Strength ( NUM ) ; if ( loose Synapses ) { network . add Synapse ( synapse ) ; } syns . add ( synapse ) ; } network . fire Synapses Updated ( ) ; } }
private void make Excitatory ( final Neuron source , List < Synapse > syns , boolean loose Synapses ) { for ( Neuron target : get Neurons In Radius ( source , excitatory Radius ) ) { if ( ! source Neurons . contains ( target ) ) { continue ; } if ( Network . get Synapse ( source , target ) != null ) { continue ; } if ( ! allow Self Connections ) { if ( source == target ) { continue ; } } if ( Math . random ( ) < excitatory Probability ) { Synapse synapse = new Synapse ( source , target ) ; synapse . set Strength ( NUM ) ; if ( loose Synapses ) { network . add Synapse ( synapse ) ; } syns . add ( synapse ) ; } network . fire Synapses Updated ( ) ; } }
private void make Excitatory ( final Neuron source , List < Synapse > syns , boolean loose Synapses ) { for ( Neuron target : get Neurons In Radius ( source , excitatory Radius ) ) { if ( ! source Neurons . contains ( target ) ) { continue ; } if ( Network . get Synapse ( source , target ) != null ) { continue ; } if ( ! allow Self Connections ) { if ( source == target ) { continue ; } } if ( Math . random ( ) < excitatory Probability ) { Synapse synapse = new Synapse ( source , target ) ; synapse . set Strength ( NUM ) ; if ( loose Synapses ) { network . add Synapse ( synapse ) ; } syns . add ( synapse ) ; } network . fire Synapses Updated ( ) ; } }
void recompose Includes ( Stylesheet including ) { int n = including . get Include Count ( ) ; if ( n > NUM ) { if ( null == m includes Composed ) m includes Composed = new Vector ( ) ; for ( int i = NUM ; i < n ; i ++ ) { Stylesheet included = including . get Include ( i ) ; m includes Composed . add Element ( included ) ; recompose Includes ( included ) ; } } }
private String add List Model ( Hash Map < String , Swagger Model > models , Class < ? > model , String model Name ) { Swagger Model swagger Model = new Swagger Model ( ) ; swagger Model . set Id ( model Name ) ; swagger Model . set Name ( model Name ) ; Swagger Model Property model Property = new Swagger Model Property ( ) ; model Property . set Type ( STRING ) ; model Property . set Required ( BOOL ) ; Hash Map < String , String > items = new Hash Map < > ( ) ; items . put ( REFERENCE TYPE , model . get Simple Name ( ) ) ; model Property . set Items ( items ) ; Hash Map < String , Swagger Model Property > model Properties = new Hash Map ( ) ; model Properties . put ( STRING , model Property ) ; swagger Model . set Properties ( model Properties ) ; String list Model Name = String . format ( STRING , model Name , model . get Simple Name ( ) ) ; models . put ( list Model Name , swagger Model ) ; return list Model Name ; }
private String add List Model ( Hash Map < String , Swagger Model > models , Class < ? > model , String model Name ) { Swagger Model swagger Model = new Swagger Model ( ) ; swagger Model . set Id ( model Name ) ; swagger Model . set Name ( model Name ) ; Swagger Model Property model Property = new Swagger Model Property ( ) ; model Property . set Type ( STRING ) ; model Property . set Required ( BOOL ) ; Hash Map < String , String > items = new Hash Map < > ( ) ; items . put ( REFERENCE TYPE , model . get Simple Name ( ) ) ; model Property . set Items ( items ) ; Hash Map < String , Swagger Model Property > model Properties = new Hash Map ( ) ; model Properties . put ( STRING , model Property ) ; swagger Model . set Properties ( model Properties ) ; String list Model Name = String . format ( STRING , model Name , model . get Simple Name ( ) ) ; models . put ( list Model Name , swagger Model ) ; return list Model Name ; }
private boolean is Known Version ( long version ) { if ( version > current Version || version < NUM ) { return BOOL ; } if ( version == current Version || chunks . size ( ) == NUM ) { return BOOL ; } Chunk c = get Chunk For Version ( version ) ; if ( c == null ) { return BOOL ; } MV Map < String , String > old Meta = get Meta Map ( version ) ; if ( old Meta == null ) { return BOOL ; } try { for ( Iterator < String > it = old Meta . key Iterator ( STRING ) ; it . has Next ( ) ; ) { String chunk Key = it . next ( ) ; if ( ! chunk Key . starts With ( STRING ) ) { break ; } if ( ! meta . contains Key ( chunk Key ) ) { String s = old Meta . get ( chunk Key ) ; Chunk c2 = Chunk . from String ( s ) ; Chunk test = read Chunk Header And Footer ( c2 . block ) ; if ( test == null || test . id != c2 . id ) { return BOOL ; } chunks . put ( c2 . id , c2 ) ; } } } catch ( Illegal State Exception e ) { return BOOL ; } return BOOL ; }
private boolean is Known Version ( long version ) { if ( version > current Version || version < NUM ) { return BOOL ; } if ( version == current Version || chunks . size ( ) == NUM ) { return BOOL ; } Chunk c = get Chunk For Version ( version ) ; if ( c == null ) { return BOOL ; } MV Map < String , String > old Meta = get Meta Map ( version ) ; if ( old Meta == null ) { return BOOL ; } try { for ( Iterator < String > it = old Meta . key Iterator ( STRING ) ; it . has Next ( ) ; ) { String chunk Key = it . next ( ) ; if ( ! chunk Key . starts With ( STRING ) ) { break ; } if ( ! meta . contains Key ( chunk Key ) ) { String s = old Meta . get ( chunk Key ) ; Chunk c2 = Chunk . from String ( s ) ; Chunk test = read Chunk Header And Footer ( c2 . block ) ; if ( test == null || test . id != c2 . id ) { return BOOL ; } chunks . put ( c2 . id , c2 ) ; } } } catch ( Illegal State Exception e ) { return BOOL ; } return BOOL ; }
private boolean is Known Version ( long version ) { if ( version > current Version || version < NUM ) { return BOOL ; } if ( version == current Version || chunks . size ( ) == NUM ) { return BOOL ; } Chunk c = get Chunk For Version ( version ) ; if ( c == null ) { return BOOL ; } MV Map < String , String > old Meta = get Meta Map ( version ) ; if ( old Meta == null ) { return BOOL ; } try { for ( Iterator < String > it = old Meta . key Iterator ( STRING ) ; it . has Next ( ) ; ) { String chunk Key = it . next ( ) ; if ( ! chunk Key . starts With ( STRING ) ) { break ; } if ( ! meta . contains Key ( chunk Key ) ) { String s = old Meta . get ( chunk Key ) ; Chunk c2 = Chunk . from String ( s ) ; Chunk test = read Chunk Header And Footer ( c2 . block ) ; if ( test == null || test . id != c2 . id ) { return BOOL ; } chunks . put ( c2 . id , c2 ) ; } } } catch ( Illegal State Exception e ) { return BOOL ; } return BOOL ; }
static public String format Date ( Date d ) { if ( time Formatter == null ) { try { return Long . to String ( d . get Time ( ) ) ; } catch ( Exception ignore ) { return STRING ; } } try { synchronized ( time Formatter ) { return time Formatter . format ( d ) ; } } catch ( Exception e1 ) { try { return d . to String ( ) ; } catch ( Exception e2 ) { try { return Long . to String ( d . get Time ( ) ) ; } catch ( Exception e3 ) { return STRING ; } } } }
public void append ( int key , E value ) { if ( m Size != NUM && key <= m Keys [ m Size - NUM ] ) { put ( key , value ) ; return ; } if ( m Garbage && m Size >= m Keys . length ) { gc ( ) ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n = Math . max ( pos + NUM , m Keys . length * NUM ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( m Keys , NUM , nkeys , NUM , m Keys . length ) ; System . arraycopy ( m Values , NUM , nvalues , NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = value ; m Size = pos + NUM ; }
public void append ( int key , E value ) { if ( m Size != NUM && key <= m Keys [ m Size - NUM ] ) { put ( key , value ) ; return ; } if ( m Garbage && m Size >= m Keys . length ) { gc ( ) ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n = Math . max ( pos + NUM , m Keys . length * NUM ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( m Keys , NUM , nkeys , NUM , m Keys . length ) ; System . arraycopy ( m Values , NUM , nvalues , NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = value ; m Size = pos + NUM ; }
public void append ( int key , E value ) { if ( m Size != NUM && key <= m Keys [ m Size - NUM ] ) { put ( key , value ) ; return ; } if ( m Garbage && m Size >= m Keys . length ) { gc ( ) ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n = Math . max ( pos + NUM , m Keys . length * NUM ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( m Keys , NUM , nkeys , NUM , m Keys . length ) ; System . arraycopy ( m Values , NUM , nvalues , NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = value ; m Size = pos + NUM ; }
void register Local Symbol ( String source File , String full Local Name , String required Namespace , String local Name ) { value Rewrite . put ( source File , full Local Name , local Name ) ; type Rewrite . put ( source File , full Local Name , local Name ) ; type Rewrite . put ( source File , required Namespace , local Name ) ; }
void add ( int n ) { if ( v == null ) { v = new int [ INIT SIZE ] ; v [ NUM ] = n ; len = NUM ; return ; } if ( len == v . length ) { int [ ] newv = new int [ len * NUM ] ; System . arraycopy ( v , NUM , newv , NUM , len ) ; v = newv ; } if ( n > v [ len - NUM ] ) { v [ len ++ ] = n ; return ; } int i = NUM ; for ( ; i < len ; i ++ ) { if ( n <= v [ i ] ) { if ( n == v [ i ] ) return ; break ; } } for ( int j = len ; j >= i ; j -- ) v [ j + NUM ] = v [ j ] ; v [ i ] = n ; ++ len ; }
public static String deserialize String ( byte [ ] buffer , Mutable Int offset ) { int length = deserialize Int ( buffer , offset ) ; String val = new String ( buffer , offset . int Value ( ) , length ) ; offset . add ( length ) ; return val ; }
public static boolean been Done ( @ Scope int scope , String tag , Count Checker number Of Times ) { List < Long > tag Seen Dates = tag Last Seen Map . get ( tag ) ; if ( tag Seen Dates . is Empty ( ) ) { return BOOL ; } if ( scope == THIS APP INSTALL ) { return number Of Times . check ( tag Seen Dates . size ( ) ) ; } else if ( scope == THIS APP SESSION ) { int counter = NUM ; for ( String tag From List : session List ) { if ( tag From List . equals ( tag ) ) { counter ++ ; } } return number Of Times . check ( counter ) ; } else { int counter = NUM ; for ( Long seen Date : tag Seen Dates ) { if ( seen Date > last App Updated Time ) { counter ++ ; } } return number Of Times . check ( counter ) ; } }
public static boolean been Done ( @ Scope int scope , String tag , Count Checker number Of Times ) { List < Long > tag Seen Dates = tag Last Seen Map . get ( tag ) ; if ( tag Seen Dates . is Empty ( ) ) { return BOOL ; } if ( scope == THIS APP INSTALL ) { return number Of Times . check ( tag Seen Dates . size ( ) ) ; } else if ( scope == THIS APP SESSION ) { int counter = NUM ; for ( String tag From List : session List ) { if ( tag From List . equals ( tag ) ) { counter ++ ; } } return number Of Times . check ( counter ) ; } else { int counter = NUM ; for ( Long seen Date : tag Seen Dates ) { if ( seen Date > last App Updated Time ) { counter ++ ; } } return number Of Times . check ( counter ) ; } }
public static < K , V > Concurrent Map < K , V > new Concurrent Map With Aggressive Concurrency ( ) { return new Concurrent Hash Map < > ( NUM , NUM , aggressive Concurrency Level ) ; }
public boolean update Stats And Return Whether Allowed ( ) { long now = System Clock . elapsed Realtime ( ) ; long delta Ms = now - m Last Request Ms ; if ( delta Ms < m Delay Ms ) return BOOL ; m Last Request Ms = now ; if ( delta Ms < NUM * m Delay Ms ) { m Delay Ms = Math . min ( MAX DELAY , m Delay Ms * NUM ) ; } else { m Delay Ms = MIN DELAY ; } return BOOL ; }
public boolean update Stats And Return Whether Allowed ( ) { long now = System Clock . elapsed Realtime ( ) ; long delta Ms = now - m Last Request Ms ; if ( delta Ms < m Delay Ms ) return BOOL ; m Last Request Ms = now ; if ( delta Ms < NUM * m Delay Ms ) { m Delay Ms = Math . min ( MAX DELAY , m Delay Ms * NUM ) ; } else { m Delay Ms = MIN DELAY ; } return BOOL ; }
public boolean update Stats And Return Whether Allowed ( ) { long now = System Clock . elapsed Realtime ( ) ; long delta Ms = now - m Last Request Ms ; if ( delta Ms < m Delay Ms ) return BOOL ; m Last Request Ms = now ; if ( delta Ms < NUM * m Delay Ms ) { m Delay Ms = Math . min ( MAX DELAY , m Delay Ms * NUM ) ; } else { m Delay Ms = MIN DELAY ; } return BOOL ; }
public boolean update Stats And Return Whether Allowed ( ) { long now = System Clock . elapsed Realtime ( ) ; long delta Ms = now - m Last Request Ms ; if ( delta Ms < m Delay Ms ) return BOOL ; m Last Request Ms = now ; if ( delta Ms < NUM * m Delay Ms ) { m Delay Ms = Math . min ( MAX DELAY , m Delay Ms * NUM ) ; } else { m Delay Ms = MIN DELAY ; } return BOOL ; }
public boolean update Stats And Return Whether Allowed ( ) { long now = System Clock . elapsed Realtime ( ) ; long delta Ms = now - m Last Request Ms ; if ( delta Ms < m Delay Ms ) return BOOL ; m Last Request Ms = now ; if ( delta Ms < NUM * m Delay Ms ) { m Delay Ms = Math . min ( MAX DELAY , m Delay Ms * NUM ) ; } else { m Delay Ms = MIN DELAY ; } return BOOL ; }
public boolean update Stats And Return Whether Allowed ( ) { long now = System Clock . elapsed Realtime ( ) ; long delta Ms = now - m Last Request Ms ; if ( delta Ms < m Delay Ms ) return BOOL ; m Last Request Ms = now ; if ( delta Ms < NUM * m Delay Ms ) { m Delay Ms = Math . min ( MAX DELAY , m Delay Ms * NUM ) ; } else { m Delay Ms = MIN DELAY ; } return BOOL ; }
public boolean update Stats And Return Whether Allowed ( ) { long now = System Clock . elapsed Realtime ( ) ; long delta Ms = now - m Last Request Ms ; if ( delta Ms < m Delay Ms ) return BOOL ; m Last Request Ms = now ; if ( delta Ms < NUM * m Delay Ms ) { m Delay Ms = Math . min ( MAX DELAY , m Delay Ms * NUM ) ; } else { m Delay Ms = MIN DELAY ; } return BOOL ; }
public boolean update Stats And Return Whether Allowed ( ) { long now = System Clock . elapsed Realtime ( ) ; long delta Ms = now - m Last Request Ms ; if ( delta Ms < m Delay Ms ) return BOOL ; m Last Request Ms = now ; if ( delta Ms < NUM * m Delay Ms ) { m Delay Ms = Math . min ( MAX DELAY , m Delay Ms * NUM ) ; } else { m Delay Ms = MIN DELAY ; } return BOOL ; }
public boolean update Stats And Return Whether Allowed ( ) { long now = System Clock . elapsed Realtime ( ) ; long delta Ms = now - m Last Request Ms ; if ( delta Ms < m Delay Ms ) return BOOL ; m Last Request Ms = now ; if ( delta Ms < NUM * m Delay Ms ) { m Delay Ms = Math . min ( MAX DELAY , m Delay Ms * NUM ) ; } else { m Delay Ms = MIN DELAY ; } return BOOL ; }
public void add UI Nodes ( Node ... nodes ) { for ( Node node : nodes ) add UI Node ( node ) ; }
private double [ ] [ ] determine Basis ( double [ ] alpha ) { final int dim = alpha . length ; double [ ] nn = new double [ dim + NUM ] ; for ( int i = NUM ; i < nn . length ; i ++ ) { double alpha i = i == alpha . length ? NUM : alpha [ i ] ; nn [ i ] = sinus Product ( NUM , i , alpha ) * Strict Math . cos ( alpha i ) ; } times Equals ( nn , NUM / euclidean Length ( nn ) ) ; double [ ] [ ] basis = new double [ dim ] [ ] ; int found = NUM ; for ( int i = NUM ; i < nn . length && found < dim ; i ++ ) { final double [ ] e i = new double [ nn . length ] ; e i [ i ] = NUM ; minus Times Equals ( e i , nn , scalar Product ( e i , nn ) ) ; double len = euclidean Length ( e i ) ; for ( int j = NUM ; j < found ; j ++ ) { if ( len < NUM ) { break ; } minus Times Equals ( e i , basis [ j ] , scalar Product ( e i , basis [ j ] ) ) ; len = euclidean Length ( e i ) ; } if ( len < NUM ) { continue ; } times Equals ( e i , NUM / len ) ; basis [ found ++ ] = e i ; } if ( found < dim ) { for ( int i = found ; i < dim ; i ++ ) { basis [ i ] = new double [ nn . length ] ; } } return transpose ( basis ) ; }
private double [ ] [ ] determine Basis ( double [ ] alpha ) { final int dim = alpha . length ; double [ ] nn = new double [ dim + NUM ] ; for ( int i = NUM ; i < nn . length ; i ++ ) { double alpha i = i == alpha . length ? NUM : alpha [ i ] ; nn [ i ] = sinus Product ( NUM , i , alpha ) * Strict Math . cos ( alpha i ) ; } times Equals ( nn , NUM / euclidean Length ( nn ) ) ; double [ ] [ ] basis = new double [ dim ] [ ] ; int found = NUM ; for ( int i = NUM ; i < nn . length && found < dim ; i ++ ) { final double [ ] e i = new double [ nn . length ] ; e i [ i ] = NUM ; minus Times Equals ( e i , nn , scalar Product ( e i , nn ) ) ; double len = euclidean Length ( e i ) ; for ( int j = NUM ; j < found ; j ++ ) { if ( len < NUM ) { break ; } minus Times Equals ( e i , basis [ j ] , scalar Product ( e i , basis [ j ] ) ) ; len = euclidean Length ( e i ) ; } if ( len < NUM ) { continue ; } times Equals ( e i , NUM / len ) ; basis [ found ++ ] = e i ; } if ( found < dim ) { for ( int i = found ; i < dim ; i ++ ) { basis [ i ] = new double [ nn . length ] ; } } return transpose ( basis ) ; }
@ Override public boolean status ( ) { return opened ; }
protected Abstract Skeleton ( Class api Class ) { api Class = api Class ; Method [ ] method List = api Class . get Methods ( ) ; for ( int i = NUM ; i < method List . length ; i ++ ) { Method method = method List [ i ] ; if ( method Map . get ( method . get Name ( ) ) == null ) method Map . put ( method . get Name ( ) , method List [ i ] ) ; Class [ ] param = method . get Parameter Types ( ) ; String mangled Name = method . get Name ( ) + STRING + param . length ; method Map . put ( mangled Name , method List [ i ] ) ; method Map . put ( mangle Name ( method , BOOL ) , method List [ i ] ) ; } }
private J Menu create File Menu ( ) { J Menu file Menu = new J Menu ( STRING ) ; file Menu . add Menu Listener ( menu Listener ) ; for ( Action action : action Manager . get Open Save Workspace Actions ( ) ) { file Menu . add ( action ) ; } file Menu . add Separator ( ) ; file Menu . add ( action Manager . get Clear Workspace Action ( ) ) ; file Menu . add Separator ( ) ; file Menu . add ( action Manager . get Open Network Action ( ) ) ; J Menu world Sub Menu = new J Menu ( STRING ) ; for ( Action action : action Manager . get Open World Actions ( ) ) { world Sub Menu . add ( action ) ; } file Menu . add ( world Sub Menu ) ; file Menu . add Separator ( ) ; file Menu . add ( action Manager . get Show Updater Dialog ( ) ) ; file Menu . add ( action Manager . get Show Property Dialog Action ( ) ) ; file Menu . add Separator ( ) ; file Menu . add ( action Manager . get Quit Workspace Action ( ) ) ; return file Menu ; }
public static boolean has Token Information ( Bundle bundle ) { if ( bundle == null ) { return BOOL ; } String token = bundle . get String ( TOKEN KEY ) ; if ( ( token == null ) || ( token . length ( ) == NUM ) ) { return BOOL ; } long expires Milliseconds = bundle . get Long ( EXPIRATION DATE KEY , NUM ) ; if ( expires Milliseconds == NUM ) { return BOOL ; } return BOOL ; }
public static boolean has Token Information ( Bundle bundle ) { if ( bundle == null ) { return BOOL ; } String token = bundle . get String ( TOKEN KEY ) ; if ( ( token == null ) || ( token . length ( ) == NUM ) ) { return BOOL ; } long expires Milliseconds = bundle . get Long ( EXPIRATION DATE KEY , NUM ) ; if ( expires Milliseconds == NUM ) { return BOOL ; } return BOOL ; }
public static boolean has Token Information ( Bundle bundle ) { if ( bundle == null ) { return BOOL ; } String token = bundle . get String ( TOKEN KEY ) ; if ( ( token == null ) || ( token . length ( ) == NUM ) ) { return BOOL ; } long expires Milliseconds = bundle . get Long ( EXPIRATION DATE KEY , NUM ) ; if ( expires Milliseconds == NUM ) { return BOOL ; } return BOOL ; }
public static boolean has Token Information ( Bundle bundle ) { if ( bundle == null ) { return BOOL ; } String token = bundle . get String ( TOKEN KEY ) ; if ( ( token == null ) || ( token . length ( ) == NUM ) ) { return BOOL ; } long expires Milliseconds = bundle . get Long ( EXPIRATION DATE KEY , NUM ) ; if ( expires Milliseconds == NUM ) { return BOOL ; } return BOOL ; }
public void add Edge ( Dependency dependency ) { if ( ! edges . contains ( dependency ) ) { edges . add ( dependency ) ; Set < Dependency > outbound Edges = vertices . get ( dependency . get Depender ( ) ) ; if ( outbound Edges == null ) { outbound Edges = new Hash Set ( ) ; vertices . put ( dependency . get Depender ( ) , outbound Edges ) ; } outbound Edges . add ( dependency ) ; if ( vertices . get ( dependency . get Depends On ( ) ) == null ) { vertices . put ( dependency . get Depends On ( ) , new Hash Set ( ) ) ; } } }
public org . w3 c . dom . Element sign XML ( org . w3 c . dom . Document doc , java . lang . String cert Alias , java . lang . String algorithm , java . lang . String id ) throws XML Signature Exception { return sign XML ( doc , cert Alias , algorithm , DEF ID ATTRIBUTE , id , BOOL , null ) ; }
private int adjust Column ( int row , int col ) { if ( col < NUM ) { return NUM ; } if ( row == get Row Count ( ) - NUM ) { int last Row Count = model . get Byte Count ( ) % NUM ; if ( last Row Count == NUM ) { last Row Count = NUM ; } if ( last Row Count < NUM ) { return Math . min ( col , ( model . get Byte Count ( ) % NUM ) - NUM ) ; } } return Math . min ( col , get Column Count ( ) - NUM - NUM ) ; }
private int adjust Column ( int row , int col ) { if ( col < NUM ) { return NUM ; } if ( row == get Row Count ( ) - NUM ) { int last Row Count = model . get Byte Count ( ) % NUM ; if ( last Row Count == NUM ) { last Row Count = NUM ; } if ( last Row Count < NUM ) { return Math . min ( col , ( model . get Byte Count ( ) % NUM ) - NUM ) ; } } return Math . min ( col , get Column Count ( ) - NUM - NUM ) ; }
private int adjust Column ( int row , int col ) { if ( col < NUM ) { return NUM ; } if ( row == get Row Count ( ) - NUM ) { int last Row Count = model . get Byte Count ( ) % NUM ; if ( last Row Count == NUM ) { last Row Count = NUM ; } if ( last Row Count < NUM ) { return Math . min ( col , ( model . get Byte Count ( ) % NUM ) - NUM ) ; } } return Math . min ( col , get Column Count ( ) - NUM - NUM ) ; }
public void add Term ( Split Condition condition ) { terms . add ( condition ) ; }
@ Override public double value To Java 2 D ( double value , Rectangle 2 D data Area , Rectangle Edge edge ) { Range range = get Range ( ) ; double vmin = range . get Lower Bound ( ) ; double vmax = range . get Upper Bound ( ) ; double vp = get Cycle Bound ( ) ; if ( ( value < vmin ) || ( value > vmax ) ) { return Double . Na N ; } double jmin = NUM ; double jmax = NUM ; if ( Rectangle Edge . is Top Or Bottom ( edge ) ) { jmin = data Area . get Min X ( ) ; jmax = data Area . get Max X ( ) ; } else if ( Rectangle Edge . is Left Or Right ( edge ) ) { jmax = data Area . get Min Y ( ) ; jmin = data Area . get Max Y ( ) ; } if ( is Inverted ( ) ) { if ( value == vp ) { return this . bound Mapped To Last Cycle ? jmin : jmax ; } else if ( value > vp ) { return jmax - ( value - vp ) * ( jmax - jmin ) / this . period ; } else { return jmin + ( vp - value ) * ( jmax - jmin ) / this . period ; } } else { if ( value == vp ) { return this . bound Mapped To Last Cycle ? jmax : jmin ; } else if ( value >= vp ) { return jmin + ( value - vp ) * ( jmax - jmin ) / this . period ; } else { return jmax - ( vp - value ) * ( jmax - jmin ) / this . period ; } } }
public static String hex ( byte b ) { return String . format ( STRING , b ) ; }
public static String hex ( byte b ) { return String . format ( STRING , b ) ; }
public static String remove Trailing Zeros ( final String str ) { String result = str ; if ( str != null && str . length ( ) != NUM ) { int end Index = str . length ( ) ; while ( end Index > NUM ) { final char ch = str . char At ( end Index - NUM ) ; if ( ch != STRING ) { break ; } end Index -- ; } if ( end Index < str . length ( ) ) { result = str . substring ( NUM , end Index ) ; } } return result ; }
public static boolean is XML Name NS ( String name ) { if ( name . length ( ) > NUM && ( ! is Name Start Char ( name . char At ( NUM ) ) || name . char At ( NUM ) == STRING ) ) { return BOOL ; } for ( int i = NUM ; i < name . length ( ) ; i ++ ) { if ( ! is Name Char ( name . char At ( i ) ) || name . char At ( i ) == STRING ) { return BOOL ; } } return BOOL ; }
public static boolean is XML Name NS ( String name ) { if ( name . length ( ) > NUM && ( ! is Name Start Char ( name . char At ( NUM ) ) || name . char At ( NUM ) == STRING ) ) { return BOOL ; } for ( int i = NUM ; i < name . length ( ) ; i ++ ) { if ( ! is Name Char ( name . char At ( i ) ) || name . char At ( i ) == STRING ) { return BOOL ; } } return BOOL ; }
public static boolean is XML Name NS ( String name ) { if ( name . length ( ) > NUM && ( ! is Name Start Char ( name . char At ( NUM ) ) || name . char At ( NUM ) == STRING ) ) { return BOOL ; } for ( int i = NUM ; i < name . length ( ) ; i ++ ) { if ( ! is Name Char ( name . char At ( i ) ) || name . char At ( i ) == STRING ) { return BOOL ; } } return BOOL ; }
@ Suppress Warnings ( STRING ) public List < V > values ( ) { int found = NUM ; Array List < V > result = new Array List < V > ( m size ) ; for ( Osm Element v : m data ) { if ( v != FREE KEY && v != removed Key ) { result . add ( ( V ) v ) ; found ++ ; if ( found >= m size ) { break ; } } } return result ; }
public int scheduled Queue Size ( ) { return scheduler Queue Size . get ( ) ; }
private void adjust For Right Fading Edge ( View child In Selected Row , int left Selection Pixel , int right Selection Pixel ) { if ( child In Selected Row . get Right ( ) > right Selection Pixel ) { int space To Left = child In Selected Row . get Left ( ) - left Selection Pixel ; int space To Right = child In Selected Row . get Right ( ) - right Selection Pixel ; int offset = Math . min ( space To Left , space To Right ) ; offset Children Left And Right ( - offset ) ; } }
private void adjust For Right Fading Edge ( View child In Selected Row , int left Selection Pixel , int right Selection Pixel ) { if ( child In Selected Row . get Right ( ) > right Selection Pixel ) { int space To Left = child In Selected Row . get Left ( ) - left Selection Pixel ; int space To Right = child In Selected Row . get Right ( ) - right Selection Pixel ; int offset = Math . min ( space To Left , space To Right ) ; offset Children Left And Right ( - offset ) ; } }
private void adjust For Right Fading Edge ( View child In Selected Row , int left Selection Pixel , int right Selection Pixel ) { if ( child In Selected Row . get Right ( ) > right Selection Pixel ) { int space To Left = child In Selected Row . get Left ( ) - left Selection Pixel ; int space To Right = child In Selected Row . get Right ( ) - right Selection Pixel ; int offset = Math . min ( space To Left , space To Right ) ; offset Children Left And Right ( - offset ) ; } }
private void adjust For Right Fading Edge ( View child In Selected Row , int left Selection Pixel , int right Selection Pixel ) { if ( child In Selected Row . get Right ( ) > right Selection Pixel ) { int space To Left = child In Selected Row . get Left ( ) - left Selection Pixel ; int space To Right = child In Selected Row . get Right ( ) - right Selection Pixel ; int offset = Math . min ( space To Left , space To Right ) ; offset Children Left And Right ( - offset ) ; } }
private void adjust For Right Fading Edge ( View child In Selected Row , int left Selection Pixel , int right Selection Pixel ) { if ( child In Selected Row . get Right ( ) > right Selection Pixel ) { int space To Left = child In Selected Row . get Left ( ) - left Selection Pixel ; int space To Right = child In Selected Row . get Right ( ) - right Selection Pixel ; int offset = Math . min ( space To Left , space To Right ) ; offset Children Left And Right ( - offset ) ; } }
public void done With Invalid Response ( Invalid Response Exception e ) { lock . lock ( ) ; try { illegal Response Exception = e ; condition . signal ( ) ; } finally { lock . unlock ( ) ; } }
public void add Char Option ( Localizable Message c , Localizable Message description , Menu Callback < T > callback ) { char Keys . add ( c ) ; char Synopsis . add ( description ) ; char Callbacks . add ( callback ) ; }
public void edit ( File file ) throws IO Exception { check AWT Permission ( ) ; check Exec ( ) ; check Action Support ( Action . EDIT ) ; file . can Write ( ) ; check File Validation ( file ) ; peer . edit ( file ) ; }
public void edit ( File file ) throws IO Exception { check AWT Permission ( ) ; check Exec ( ) ; check Action Support ( Action . EDIT ) ; file . can Write ( ) ; check File Validation ( file ) ; peer . edit ( file ) ; }
@ Override public void end Document ( ) throws SAX Exception { write Text 4 Links ( ) ; write ( STRING ) ; super . end Document ( ) ; try { flush ( ) ; } catch ( IO Exception e ) { throw new SAX Exception ( e ) ; } }
@ Override public void end Document ( ) throws SAX Exception { write Text 4 Links ( ) ; write ( STRING ) ; super . end Document ( ) ; try { flush ( ) ; } catch ( IO Exception e ) { throw new SAX Exception ( e ) ; } }
@ Override public void end Document ( ) throws SAX Exception { write Text 4 Links ( ) ; write ( STRING ) ; super . end Document ( ) ; try { flush ( ) ; } catch ( IO Exception e ) { throw new SAX Exception ( e ) ; } }
@ Override public void end Document ( ) throws SAX Exception { write Text 4 Links ( ) ; write ( STRING ) ; super . end Document ( ) ; try { flush ( ) ; } catch ( IO Exception e ) { throw new SAX Exception ( e ) ; } }
@ Override public void end Document ( ) throws SAX Exception { write Text 4 Links ( ) ; write ( STRING ) ; super . end Document ( ) ; try { flush ( ) ; } catch ( IO Exception e ) { throw new SAX Exception ( e ) ; } }
private static final Set < File > encode ( String src ) { if ( src == null || src . length ( ) == NUM ) return new Hash Set < File > ( ) ; String Tokenizer tokenizer = new String Tokenizer ( src , STRING ) ; int size = tokenizer . count Tokens ( ) ; Set < File > set = new Hash Set < File > ( ) ; for ( int i = NUM ; i < size ; i ++ ) set . add ( new File ( tokenizer . next Token ( ) ) ) ; return set ; }
private void scroll To Position ( final long position ) { m scrollbar . set Value ( ( int ) position / ( NUM * m bytes Per Row ) ) ; }
private void scroll To Position ( final long position ) { m scrollbar . set Value ( ( int ) position / ( NUM * m bytes Per Row ) ) ; }
protected String to Val String ( Enumeration en ) { String Builder sb = new String Builder ( ) ; boolean first = BOOL ; while ( en . has More Elements ( ) ) { String val = ( String ) en . next Element ( ) ; val = encode Val ( val ) ; if ( first ) { first = BOOL ; } else { sb . append ( STRING ) ; } sb . append ( val ) ; } return sb . to String ( ) ; }
protected String to Val String ( Enumeration en ) { String Builder sb = new String Builder ( ) ; boolean first = BOOL ; while ( en . has More Elements ( ) ) { String val = ( String ) en . next Element ( ) ; val = encode Val ( val ) ; if ( first ) { first = BOOL ; } else { sb . append ( STRING ) ; } sb . append ( val ) ; } return sb . to String ( ) ; }
protected String to Val String ( Enumeration en ) { String Builder sb = new String Builder ( ) ; boolean first = BOOL ; while ( en . has More Elements ( ) ) { String val = ( String ) en . next Element ( ) ; val = encode Val ( val ) ; if ( first ) { first = BOOL ; } else { sb . append ( STRING ) ; } sb . append ( val ) ; } return sb . to String ( ) ; }
protected String to Val String ( Enumeration en ) { String Builder sb = new String Builder ( ) ; boolean first = BOOL ; while ( en . has More Elements ( ) ) { String val = ( String ) en . next Element ( ) ; val = encode Val ( val ) ; if ( first ) { first = BOOL ; } else { sb . append ( STRING ) ; } sb . append ( val ) ; } return sb . to String ( ) ; }
public Extension Forced User ( ) { super ( ) ; initialize ( ) ; }
public void add Node ( Eval Factory Node node ) { active Nodes . add ( node ) ; }
public static void append Length And Mask ( Byte Buffer buffer , int length , byte mask [ ] ) { if ( mask != null ) { append Length ( buffer , length , BOOL ) ; buffer . put ( mask ) ; } else { append Length ( buffer , length , BOOL ) ; } }
public boolean check Column Name Equality ( String from Schema , String specified ) { if ( from Schema . equals ( specified ) ) { return BOOL ; } if ( from Schema . contains ( STRING ) ) { String [ ] splits = from Schema . split ( STRING ) ; String schema Col Name = splits [ NUM ] ; return schema Col Name . equals ( specified ) ; } return BOOL ; }
protected int decode Line Prefix ( Pushback Input Stream a Stream , Output Stream b Stream ) throws IO Exception { return ( bytes Per Line ( ) ) ; }
protected int decode Line Prefix ( Pushback Input Stream a Stream , Output Stream b Stream ) throws IO Exception { return ( bytes Per Line ( ) ) ; }
protected int decode Line Prefix ( Pushback Input Stream a Stream , Output Stream b Stream ) throws IO Exception { return ( bytes Per Line ( ) ) ; }
protected int decode Line Prefix ( Pushback Input Stream a Stream , Output Stream b Stream ) throws IO Exception { return ( bytes Per Line ( ) ) ; }
protected int decode Line Prefix ( Pushback Input Stream a Stream , Output Stream b Stream ) throws IO Exception { return ( bytes Per Line ( ) ) ; }
public static String timestamp ( Date Time ts ) { return Long . to String ( ts . get Millis ( ) / NUM ) ; }
private void write File ( File file , byte [ ] input , Compression Mode mode ) throws IO Exception { try ( Output Stream os = get Output Stream For Mode ( mode , new File Output Stream ( file ) ) ) { os . write ( input ) ; } }
public static void main ( String [ ] args ) { final File path To This Jar = new File ( find Path To ( Checker Main . class , BOOL ) ) ; Array List < String > alargs = new Array List < > ( args . length ) ; alargs . add All ( Arrays . as List ( args ) ) ; final Checker Main program = new Checker Main ( path To This Jar , alargs ) ; final int exit Status = program . invoke Compiler ( ) ; System . exit ( exit Status ) ; }
public Builder delete Profile Url ( ) { delete Fields . add ( STRING ) ; return this ; }
public String decode ( String p String , String charset ) throws Decoder Exception , Unsupported Encoding Exception { if ( p String == null ) { return null ; } return new String ( decode ( p String . get Bytes ( String Encodings . US ASCII ) ) , charset ) ; }
public Response new Fixed Length Response ( String msg ) { return new Fixed Length Response ( Response . Status . OK , Nano HTTPD . MIME HTML , msg ) ; }
public void remove Src Class ( Soot Class clz ) { src Classes . remove ( clz . get Name ( ) ) ; }
static public void assert Right Aligned ( View first , View second , int margin ) { int [ ] xy = new int [ NUM ] ; first . get Location On Screen ( xy ) ; int first Right = xy [ NUM ] + first . get Measured Width ( ) ; second . get Location On Screen ( xy ) ; int second Right = xy [ NUM ] + second . get Measured Width ( ) ; assert Equals ( STRING , Math . abs ( first Right - second Right ) , margin ) ; }
public static void enumerate Resources ( Verification Host host , boolean is Mock , String resource Pool Link , String compute Host Link Description , String compute Host Link , String test Case ) throws Throwable { enumerate Resources ( host , null , is Mock ? Enum Set . of ( Task Option . IS MOCK ) : null , resource Pool Link , compute Host Link Description , compute Host Link , test Case , null ) ; }
public static void enumerate Resources ( Verification Host host , boolean is Mock , String resource Pool Link , String compute Host Link Description , String compute Host Link , String test Case ) throws Throwable { enumerate Resources ( host , null , is Mock ? Enum Set . of ( Task Option . IS MOCK ) : null , resource Pool Link , compute Host Link Description , compute Host Link , test Case , null ) ; }
public URI Name ( String name ) throws IO Exception { try { uri = new URI ( name ) ; } catch ( URI Syntax Exception use ) { throw new IO Exception ( STRING + name , use ) ; } if ( uri . get Scheme ( ) == null ) { throw new IO Exception ( STRING + name ) ; } host = uri . get Host ( ) ; if ( host != null ) { if ( host . char At ( NUM ) == STRING ) { String ip V 6 Host = host . substring ( NUM , host . length ( ) - NUM ) ; try { host IP = new IP Address Name ( ip V 6 Host ) ; } catch ( IO Exception ioe ) { throw new IO Exception ( STRING + STRING + name ) ; } } else { try { host DNS = new DNS Name ( host ) ; } catch ( IO Exception ioe ) { try { host IP = new IP Address Name ( host ) ; } catch ( Exception ioe 2 ) { throw new IO Exception ( STRING + STRING + STRING + name ) ; } } } } }
public static Director new Project ( ) { return new Project ( BOOL ) ; }
public static String convert System Name To Alternate ( String system Name ) { if ( ! valid System Name Format ( system Name , system Name . char At ( NUM ) , STRING ) ) { return STRING ; } String alt Name = STRING ; alt Name = system Name ; return alt Name ; }
public static String convert System Name To Alternate ( String system Name ) { if ( ! valid System Name Format ( system Name , system Name . char At ( NUM ) , STRING ) ) { return STRING ; } String alt Name = STRING ; alt Name = system Name ; return alt Name ; }
public static String convert System Name To Alternate ( String system Name ) { if ( ! valid System Name Format ( system Name , system Name . char At ( NUM ) , STRING ) ) { return STRING ; } String alt Name = STRING ; alt Name = system Name ; return alt Name ; }
protected void update ( OM Graphic List list , Projection proj ) { Buffered Image current Image Buffer = null ; if ( proj != null && layer != null ) { int w = proj . get Width ( ) ; int h = proj . get Height ( ) ; current Image Buffer = get Image Buffer ( ) ; Buffered Image buffered Image = scrub Or Get New Buffered Image ( current Image Buffer , w , h ) ; if ( buffered Image != null ) { if ( current Image Buffer != null ) { current Image Buffer . flush ( ) ; } current Image Buffer = buffered Image ; } Graphics 2 D g2 d = ( Graphics 2 D ) current Image Buffer . get Graphics ( ) ; set Rendering Hints ( g2 d ) ; if ( list != null ) { list . render ( g2 d ) ; } g2 d . dispose ( ) ; set Image Raster ( update Raster ( current Image Buffer , proj ) ) ; } set Image Buffer ( current Image Buffer ) ; current Projection = proj ; }
public J Value Slider ( String title , Number min , Number max , Number value ) { m min = min ; m max = max ; m value = value ; m slider = new J Slider ( ) ; m label = new J Label ( title ) ; m field = new J Text Field ( ) ; m listeners = new Array List ( ) ; m field . set Border ( null ) ; set Slider Value ( ) ; set Field Value ( ) ; init UI ( ) ; }
public Scale IO Snapshot Volume Response snapshot Multi Volume ( Map < String , String > id 2 snapshot , String system Id ) throws Exception { String uri = Scale IO Constants . get Snapshot Volumes URI ( system Id ) ; Scale IO Snapshot Volumes sp Vol = new Scale IO Snapshot Volumes ( ) ; for ( Map . Entry < String , String > entry : id 2 snapshot . entry Set ( ) ) { sp Vol . add Snapshot ( entry . get Key ( ) , entry . get Value ( ) ) ; } Client Response response = post ( URI . create ( uri ) , get Json For Entity ( sp Vol ) ) ; return get Response Object ( Scale IO Snapshot Volume Response . class , response ) ; }
public Scale IO Snapshot Volume Response snapshot Multi Volume ( Map < String , String > id 2 snapshot , String system Id ) throws Exception { String uri = Scale IO Constants . get Snapshot Volumes URI ( system Id ) ; Scale IO Snapshot Volumes sp Vol = new Scale IO Snapshot Volumes ( ) ; for ( Map . Entry < String , String > entry : id 2 snapshot . entry Set ( ) ) { sp Vol . add Snapshot ( entry . get Key ( ) , entry . get Value ( ) ) ; } Client Response response = post ( URI . create ( uri ) , get Json For Entity ( sp Vol ) ) ; return get Response Object ( Scale IO Snapshot Volume Response . class , response ) ; }
private void extract Proto Sources ( Set < String > extracted , String proto File ) { if ( ! extracted . add ( proto File ) ) { return ; } String content = copy Test Data ( proto File ) ; Matcher matcher = PROTO IMPORT PATTERN . matcher ( content ) ; while ( matcher . find ( ) ) { extract Proto Sources ( extracted , matcher . group ( NUM ) ) ; } }
private void extract Proto Sources ( Set < String > extracted , String proto File ) { if ( ! extracted . add ( proto File ) ) { return ; } String content = copy Test Data ( proto File ) ; Matcher matcher = PROTO IMPORT PATTERN . matcher ( content ) ; while ( matcher . find ( ) ) { extract Proto Sources ( extracted , matcher . group ( NUM ) ) ; } }
private void extract Proto Sources ( Set < String > extracted , String proto File ) { if ( ! extracted . add ( proto File ) ) { return ; } String content = copy Test Data ( proto File ) ; Matcher matcher = PROTO IMPORT PATTERN . matcher ( content ) ; while ( matcher . find ( ) ) { extract Proto Sources ( extracted , matcher . group ( NUM ) ) ; } }
private void extract Proto Sources ( Set < String > extracted , String proto File ) { if ( ! extracted . add ( proto File ) ) { return ; } String content = copy Test Data ( proto File ) ; Matcher matcher = PROTO IMPORT PATTERN . matcher ( content ) ; while ( matcher . find ( ) ) { extract Proto Sources ( extracted , matcher . group ( NUM ) ) ; } }
public D Policy Constraints ( J Dialog parent ) { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; }
private static void dump Configuration Properties ( Install Log install Log , Map < String , Object > properties ) { Sorted Map < String , Object > sorted Properties = new Tree Map < String , Object > ( String . CASE INSENSITIVE ORDER ) ; sorted Properties . put All ( properties ) ; for ( String key : sorted Properties . key Set ( ) ) { if ( CONFIG ITEMS TO HASH LIST . contains ( key ) ) { install Log . write ( key + STRING + STRING ) ; } else { install Log . write ( key + STRING + sorted Properties . get ( key ) + STRING ) ; } } }
private static void dump Configuration Properties ( Install Log install Log , Map < String , Object > properties ) { Sorted Map < String , Object > sorted Properties = new Tree Map < String , Object > ( String . CASE INSENSITIVE ORDER ) ; sorted Properties . put All ( properties ) ; for ( String key : sorted Properties . key Set ( ) ) { if ( CONFIG ITEMS TO HASH LIST . contains ( key ) ) { install Log . write ( key + STRING + STRING ) ; } else { install Log . write ( key + STRING + sorted Properties . get ( key ) + STRING ) ; } } }
@ Override public void mouse Pressed ( Mouse Event e ) { if ( e . get Click Count ( ) == NUM && Swing Utilities . is Left Mouse Button ( e ) ) { String url = get Url ( e ) ; if ( url != null && ! is Url Deleted ( e ) ) { if ( link Listener != null ) { link Listener . link Clicked ( url ) ; } return ; } User user = get User ( e ) ; if ( user != null ) { for ( User Listener listener : user Listener ) { listener . user Clicked ( user , e ) ; } return ; } Emoticon Image emote = get Emoticon ( e ) ; if ( emote != null ) { for ( User Listener listener : user Listener ) { listener . emote Clicked ( emote . get Emoticon ( ) , e ) ; } return ; } Usericon usericon = get Usericon ( e ) ; if ( usericon != null ) { for ( User Listener listener : user Listener ) { listener . usericon Clicked ( usericon , e ) ; } } } else if ( e . is Popup Trigger ( ) ) { open Context Menu ( e ) ; } }
@ Override public void mouse Pressed ( Mouse Event e ) { if ( e . get Click Count ( ) == NUM && Swing Utilities . is Left Mouse Button ( e ) ) { String url = get Url ( e ) ; if ( url != null && ! is Url Deleted ( e ) ) { if ( link Listener != null ) { link Listener . link Clicked ( url ) ; } return ; } User user = get User ( e ) ; if ( user != null ) { for ( User Listener listener : user Listener ) { listener . user Clicked ( user , e ) ; } return ; } Emoticon Image emote = get Emoticon ( e ) ; if ( emote != null ) { for ( User Listener listener : user Listener ) { listener . emote Clicked ( emote . get Emoticon ( ) , e ) ; } return ; } Usericon usericon = get Usericon ( e ) ; if ( usericon != null ) { for ( User Listener listener : user Listener ) { listener . usericon Clicked ( usericon , e ) ; } } } else if ( e . is Popup Trigger ( ) ) { open Context Menu ( e ) ; } }
public boolean is Blacklisted ( String name ) { if ( get Blacklist Enabled ( ) == BOOL ) { return BOOL ; } return is On List ( blacklist , name ) ; }
public synchronized void clear ( ) { int i ; int len = password . length ; for ( i = NUM ; i < len ; i ++ ) { password [ i ] = NUM ; } cleared = BOOL ; }
public synchronized void clear ( ) { int i ; int len = password . length ; for ( i = NUM ; i < len ; i ++ ) { password [ i ] = NUM ; } cleared = BOOL ; }
protected void bflash ws ( ) throws SAX Exception { if ( m Buff Idx >= NUM ) { m Hand Cont . characters ( m Buff , NUM , ( m Buff Idx + NUM ) ) ; m Buff Idx = - NUM ; } }
protected void bflash ws ( ) throws SAX Exception { if ( m Buff Idx >= NUM ) { m Hand Cont . characters ( m Buff , NUM , ( m Buff Idx + NUM ) ) ; m Buff Idx = - NUM ; } }
protected void bflash ws ( ) throws SAX Exception { if ( m Buff Idx >= NUM ) { m Hand Cont . characters ( m Buff , NUM , ( m Buff Idx + NUM ) ) ; m Buff Idx = - NUM ; } }
protected void bflash ws ( ) throws SAX Exception { if ( m Buff Idx >= NUM ) { m Hand Cont . characters ( m Buff , NUM , ( m Buff Idx + NUM ) ) ; m Buff Idx = - NUM ; } }
protected void bflash ws ( ) throws SAX Exception { if ( m Buff Idx >= NUM ) { m Hand Cont . characters ( m Buff , NUM , ( m Buff Idx + NUM ) ) ; m Buff Idx = - NUM ; } }
protected void bflash ws ( ) throws SAX Exception { if ( m Buff Idx >= NUM ) { m Hand Cont . characters ( m Buff , NUM , ( m Buff Idx + NUM ) ) ; m Buff Idx = - NUM ; } }
protected void bflash ws ( ) throws SAX Exception { if ( m Buff Idx >= NUM ) { m Hand Cont . characters ( m Buff , NUM , ( m Buff Idx + NUM ) ) ; m Buff Idx = - NUM ; } }
protected void bflash ws ( ) throws SAX Exception { if ( m Buff Idx >= NUM ) { m Hand Cont . characters ( m Buff , NUM , ( m Buff Idx + NUM ) ) ; m Buff Idx = - NUM ; } }
public Combo Box Cell Renderer ( J Combo Box < String > combo Box ) { this . combo = new J Combo Box < String > ( ) ; for ( int i = NUM ; i < combo Box . get Item Count ( ) ; i ++ ) { combo . add Item ( combo Box . get Item At ( i ) ) ; } }
private void check And Create Directory ( final String directory Name ) { try { final File dir = new File ( directory Name ) ; if ( ! dir . exists ( ) && dir . mkdirs ( ) ) { logger . debug ( STRING ) ; } } catch ( Exception ex ) { logger . error ( STRING , ex . get Message ( ) ) ; } }
private void check And Create Directory ( final String directory Name ) { try { final File dir = new File ( directory Name ) ; if ( ! dir . exists ( ) && dir . mkdirs ( ) ) { logger . debug ( STRING ) ; } } catch ( Exception ex ) { logger . error ( STRING , ex . get Message ( ) ) ; } }
protected static int create Serial Number ( ) { return serial Number Sequencer . increment And Get ( ) ; }
protected static int create Serial Number ( ) { return serial Number Sequencer . increment And Get ( ) ; }
private void calc Current Item ( ) { int pointer Angle = ( m Current Item Angle + NUM + m Pie Rotation ) % NUM ; for ( int i = NUM ; i < m Data . size ( ) ; ++ i ) { Item it = m Data . get ( i ) ; if ( it . m Start Angle <= pointer Angle && pointer Angle <= it . m End Angle ) { if ( i != m Current Item ) { set Current Item ( i , BOOL ) ; } break ; } } }
private void check Posts Display On Recycler View ( List < Shot > shots To Check , int position ) { int column Count = NUM ; int size = shots To Check . size ( ) + position ; int pos = NUM ; for ( int i = position ; i < size ; i ++ ) { check Item At Position ( i , shots To Check . get ( pos ) ) ; if ( ( ( i + NUM ) % column Count ) == NUM ) { int next Row Start = i + column Count ; int next Row End = next Row Start - column Count + NUM ; for ( int n = next Row Start ; n >= next Row End ; n -- ) { check Item At Position ( n , shots To Check . get ( n - position ) ) ; } i = i + column Count ; } pos ++ ; } }
private void check Posts Display On Recycler View ( List < Shot > shots To Check , int position ) { int column Count = NUM ; int size = shots To Check . size ( ) + position ; int pos = NUM ; for ( int i = position ; i < size ; i ++ ) { check Item At Position ( i , shots To Check . get ( pos ) ) ; if ( ( ( i + NUM ) % column Count ) == NUM ) { int next Row Start = i + column Count ; int next Row End = next Row Start - column Count + NUM ; for ( int n = next Row Start ; n >= next Row End ; n -- ) { check Item At Position ( n , shots To Check . get ( n - position ) ) ; } i = i + column Count ; } pos ++ ; } }
private void check Posts Display On Recycler View ( List < Shot > shots To Check , int position ) { int column Count = NUM ; int size = shots To Check . size ( ) + position ; int pos = NUM ; for ( int i = position ; i < size ; i ++ ) { check Item At Position ( i , shots To Check . get ( pos ) ) ; if ( ( ( i + NUM ) % column Count ) == NUM ) { int next Row Start = i + column Count ; int next Row End = next Row Start - column Count + NUM ; for ( int n = next Row Start ; n >= next Row End ; n -- ) { check Item At Position ( n , shots To Check . get ( n - position ) ) ; } i = i + column Count ; } pos ++ ; } }
private void check Posts Display On Recycler View ( List < Shot > shots To Check , int position ) { int column Count = NUM ; int size = shots To Check . size ( ) + position ; int pos = NUM ; for ( int i = position ; i < size ; i ++ ) { check Item At Position ( i , shots To Check . get ( pos ) ) ; if ( ( ( i + NUM ) % column Count ) == NUM ) { int next Row Start = i + column Count ; int next Row End = next Row Start - column Count + NUM ; for ( int n = next Row Start ; n >= next Row End ; n -- ) { check Item At Position ( n , shots To Check . get ( n - position ) ) ; } i = i + column Count ; } pos ++ ; } }
void locate Class Failed ( Throwable ex , String adapter Name , Object o ) { log . error ( ex . get Message ( ) + STRING + adapter Name ) ; if ( log . is Debug Enabled ( ) ) { ex . print Stack Trace ( ) ; } }
void locate Class Failed ( Throwable ex , String adapter Name , Object o ) { log . error ( ex . get Message ( ) + STRING + adapter Name ) ; if ( log . is Debug Enabled ( ) ) { ex . print Stack Trace ( ) ; } }
public void add Children ( final Read Data Level Node parent ) { parent . add ( new Read Data Node ( parent . get Data ( ) ) ) ; }
@ Override public int count All ( ) { Long count = ( Long ) finder Cache . get Result ( FINDER PATH COUNT ALL , FINDER ARGS EMPTY , this ) ; if ( count == null ) { Session session = null ; try { session = open Session ( ) ; Query q = session . create Query ( SQL COUNT FOO ) ; count = ( Long ) q . unique Result ( ) ; finder Cache . put Result ( FINDER PATH COUNT ALL , FINDER ARGS EMPTY , count ) ; } catch ( Exception e ) { finder Cache . remove Result ( FINDER PATH COUNT ALL , FINDER ARGS EMPTY ) ; throw process Exception ( e ) ; } finally { close Session ( session ) ; } } return count . int Value ( ) ; }
public static Array List < Stock > from Json ( JSON Array json Quotes ) throws JSON Exception { Array List < Stock > stocks = new Array List < Stock > ( ) ; for ( int i = NUM ; i < json Quotes . length ( ) ; i ++ ) { JSON Object json Quote Item = ( JSON Object ) json Quotes . get ( i ) ; stocks . add ( new Stock ( json Quote Item ) ) ; } return stocks ; }
public static Array List < Stock > from Json ( JSON Array json Quotes ) throws JSON Exception { Array List < Stock > stocks = new Array List < Stock > ( ) ; for ( int i = NUM ; i < json Quotes . length ( ) ; i ++ ) { JSON Object json Quote Item = ( JSON Object ) json Quotes . get ( i ) ; stocks . add ( new Stock ( json Quote Item ) ) ; } return stocks ; }
public static boolean check Caller ( ) { return check Caller ; }
public void annotation Changed ( Annotation annotation ) { changed Annotations . add ( annotation ) ; }
public void annotation Changed ( Annotation annotation ) { changed Annotations . add ( annotation ) ; }
public void annotation Changed ( Annotation annotation ) { changed Annotations . add ( annotation ) ; }
public void annotation Changed ( Annotation annotation ) { changed Annotations . add ( annotation ) ; }
private Content Element parse Content Element ( Span Manager sm , Content Element Parsing Parameters cepp , Span line Span ) { Linked List < Span > line Spans = new Linked List < Span > ( ) ; line Spans . add ( line Span ) ; return parse Content Element ( sm , cepp , line Spans , new Content Element ( ) ) ; }
public static double [ ] gen Pulse From Fourier Mag ( double [ ] mag , double f0 ) { int num Harm = mag . length ; int current F 0 = ( int ) Math . round ( f0 ) ; int T ; if ( current F 0 < NUM ) T = NUM ; else T = NUM ; int T2 = NUM * T ; double [ ] pulse = new double [ T ] ; double [ ] real = new double [ T2 ] ; double [ ] imag = new double [ T2 ] ; real [ NUM ] = real [ T ] = NUM ; for ( int i = NUM ; i <= num Harm ; i ++ ) { real [ i ] = real [ T - i ] = real [ T + i ] = real [ T2 - i ] = mag [ i - NUM ] ; imag [ i ] = imag [ T - i ] = imag [ T + i ] = imag [ T2 - i ] = NUM ; } for ( int i = ( num Harm + NUM ) ; i < ( T - num Harm ) ; i ++ ) { real [ i ] = real [ T - i ] = real [ T + i ] = real [ T2 - i ] = NUM ; imag [ i ] = imag [ T - i ] = imag [ T + i ] = imag [ T2 - i ] = NUM ; } FFT . transform ( real , imag , BOOL ) ; double sqrt f0 = Math . sqrt ( current F 0 ) ; for ( int i = NUM ; i < T ; i ++ ) pulse [ i ] = real [ ( i - num Harm ) % T ] * sqrt f0 ; return pulse ; }
public void test Path Mode ( ) throws Exception { path Modes ( F . t ( STRING , PROXY ) , F . t ( STRING , DUAL SYNC ) , F . t ( STRING , PRIMARY ) , F . t ( STRING , PRIMARY ) ) ; mode = DUAL ASYNC ; set Secondary Fs = BOOL ; start Up ( ) ; check Mode ( STRING , DUAL ASYNC ) ; check Mode ( STRING , PROXY ) ; check Mode ( STRING , DUAL SYNC ) ; check Mode ( STRING , PRIMARY ) ; check Mode ( STRING , DUAL ASYNC ) ; check Mode ( STRING , PRIMARY ) ; check Mode ( STRING , PRIMARY ) ; check Mode ( STRING , DUAL ASYNC ) ; check Mode ( STRING , DUAL ASYNC ) ; }
public void test Path Mode ( ) throws Exception { path Modes ( F . t ( STRING , PROXY ) , F . t ( STRING , DUAL SYNC ) , F . t ( STRING , PRIMARY ) , F . t ( STRING , PRIMARY ) ) ; mode = DUAL ASYNC ; set Secondary Fs = BOOL ; start Up ( ) ; check Mode ( STRING , DUAL ASYNC ) ; check Mode ( STRING , PROXY ) ; check Mode ( STRING , DUAL SYNC ) ; check Mode ( STRING , PRIMARY ) ; check Mode ( STRING , DUAL ASYNC ) ; check Mode ( STRING , PRIMARY ) ; check Mode ( STRING , PRIMARY ) ; check Mode ( STRING , DUAL ASYNC ) ; check Mode ( STRING , DUAL ASYNC ) ; }
public void test Path Mode ( ) throws Exception { path Modes ( F . t ( STRING , PROXY ) , F . t ( STRING , DUAL SYNC ) , F . t ( STRING , PRIMARY ) , F . t ( STRING , PRIMARY ) ) ; mode = DUAL ASYNC ; set Secondary Fs = BOOL ; start Up ( ) ; check Mode ( STRING , DUAL ASYNC ) ; check Mode ( STRING , PROXY ) ; check Mode ( STRING , DUAL SYNC ) ; check Mode ( STRING , PRIMARY ) ; check Mode ( STRING , DUAL ASYNC ) ; check Mode ( STRING , PRIMARY ) ; check Mode ( STRING , PRIMARY ) ; check Mode ( STRING , DUAL ASYNC ) ; check Mode ( STRING , DUAL ASYNC ) ; }
Array List < Source File > trim File List ( Array List < Source File > files ) { Hash Map < String , String > names = new Hash Map < String , String > ( ) ; Array List < Source File > list = new Array List < Source File > ( ) ; int size = files . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) { boolean add It = BOOL ; Source File fi = files . get ( i ) ; String f Name = fi . get Raw Name ( ) ; if ( m swf Filter == null ) { if ( names . get ( f Name ) == null ) add It = BOOL ; } else { add It = m swf Filter . contains Source ( fi ) ; } if ( add It ) { names . put ( f Name , f Name ) ; list . add ( fi ) ; } } return list ; }
Array List < Source File > trim File List ( Array List < Source File > files ) { Hash Map < String , String > names = new Hash Map < String , String > ( ) ; Array List < Source File > list = new Array List < Source File > ( ) ; int size = files . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) { boolean add It = BOOL ; Source File fi = files . get ( i ) ; String f Name = fi . get Raw Name ( ) ; if ( m swf Filter == null ) { if ( names . get ( f Name ) == null ) add It = BOOL ; } else { add It = m swf Filter . contains Source ( fi ) ; } if ( add It ) { names . put ( f Name , f Name ) ; list . add ( fi ) ; } } return list ; }
public boolean send TCP String ( String message ) { byte [ ] bytes = message . get Bytes ( ) ; return send TCP Bytes ( bytes ) ; }
@ Override public List < Period > generate Rolling Periods ( Date Time Unit date Time Unit ) { Calendar cal = get Calendar ( ) ; date Time Unit = cal . minus Days ( date Time Unit , NUM ) ; List < Period > periods = Lists . new Array List ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { periods . add ( create Period ( date Time Unit , null ) ) ; date Time Unit = cal . plus Days ( date Time Unit , NUM ) ; } return periods ; }
@ Override public List < Period > generate Rolling Periods ( Date Time Unit date Time Unit ) { Calendar cal = get Calendar ( ) ; date Time Unit = cal . minus Days ( date Time Unit , NUM ) ; List < Period > periods = Lists . new Array List ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { periods . add ( create Period ( date Time Unit , null ) ) ; date Time Unit = cal . plus Days ( date Time Unit , NUM ) ; } return periods ; }
@ Override public List < Period > generate Rolling Periods ( Date Time Unit date Time Unit ) { Calendar cal = get Calendar ( ) ; date Time Unit = cal . minus Days ( date Time Unit , NUM ) ; List < Period > periods = Lists . new Array List ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { periods . add ( create Period ( date Time Unit , null ) ) ; date Time Unit = cal . plus Days ( date Time Unit , NUM ) ; } return periods ; }
public static int normalize ( char [ ] src , int src Start , int src Limit , char [ ] dest , int dest Start , int dest Limit , Mode mode , int options ) { int length = mode . normalize ( src , src Start , src Limit , dest , dest Start , dest Limit , options ) ; if ( length <= ( dest Limit - dest Start ) ) { return length ; } else { throw new Index Out Of Bounds Exception ( Integer . to String ( length ) ) ; } }
public static int normalize ( char [ ] src , int src Start , int src Limit , char [ ] dest , int dest Start , int dest Limit , Mode mode , int options ) { int length = mode . normalize ( src , src Start , src Limit , dest , dest Start , dest Limit , options ) ; if ( length <= ( dest Limit - dest Start ) ) { return length ; } else { throw new Index Out Of Bounds Exception ( Integer . to String ( length ) ) ; } }
private static boolean jwt Has Audience Claim ( Jwt Claims Set jwt Claims ) throws Auth Login Exception { List < String > audience Claim = jwt Claims . get Audience ( ) ; return ( audience Claim != null && ! audience Claim . is Empty ( ) ) ; }
private static boolean jwt Has Audience Claim ( Jwt Claims Set jwt Claims ) throws Auth Login Exception { List < String > audience Claim = jwt Claims . get Audience ( ) ; return ( audience Claim != null && ! audience Claim . is Empty ( ) ) ; }
public void write ( byte [ ] b , int off , int len , long pos ) throws IO Exception { if ( b == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ( off < NUM ) || ( len < NUM ) || ( pos < NUM ) || ( off + len > b . length ) || ( off + len < NUM ) ) { throw new Index Out Of Bounds Exception ( ) ; } long last Pos = pos + len - NUM ; if ( last Pos >= length ) { pad ( last Pos ) ; length = last Pos + NUM ; } int offset = ( int ) ( pos % BUFFER LENGTH ) ; while ( len > NUM ) { byte [ ] buf = get Cache Block ( pos / BUFFER LENGTH ) ; int nbytes = Math . min ( len , BUFFER LENGTH - offset ) ; System . arraycopy ( b , off , buf , offset , nbytes ) ; pos += nbytes ; off += nbytes ; len -= nbytes ; offset = NUM ; } }
public static void generate Binary Operation Flags ( final I Translation Environment environment , final long next Offset , final String result , final Operand Size result Size , final List < Reil Instruction > instructions ) throws Illegal Argument Exception { Preconditions . check Not Null ( environment , STRING ) ; Preconditions . check Not Null ( result , STRING ) ; Preconditions . check Not Null ( result Size , STRING ) ; Preconditions . check Not Null ( instructions , STRING ) ; final long base Offset = next Offset - instructions . size ( ) ; long offset = next Offset ; generate Sign Flag Code ( environment , offset , result , result Size , instructions ) ; offset = ( base Offset + instructions . size ( ) ) - NUM ; instructions . add ( Reil Helpers . create Bisz ( offset + NUM , result Size , result , Operand Size . BYTE , Helpers . ZERO FLAG ) ) ; instructions . add ( Reil Helpers . create Str ( offset + NUM , Operand Size . BYTE , STRING , Operand Size . BYTE , Helpers . CARRY FLAG ) ) ; instructions . add ( Reil Helpers . create Str ( offset + NUM , Operand Size . BYTE , STRING , Operand Size . BYTE , Helpers . OVERFLOW FLAG ) ) ; }
public void draw ( Graphics g , Shape s ) { if ( decorations . is Empty ( ) ) return ; Path Iterator pi = s . get Path Iterator ( null , FLATNESS ) ; int seg Type ; double [ ] seg Coords = new double [ NUM ] ; Linked List < Point 2 D > points = new Linked List < Point 2 D > ( ) ; Point 2 D first Point = null ; Point 2 D point ; do { seg Type = pi . current Segment ( seg Coords ) ; point = new Point 2 D . Double ( seg Coords [ NUM ] , seg Coords [ NUM ] ) ; switch ( seg Type ) { case Path Iterator . SEG MOVETO : if ( first Point == null ) first Point = point ; if ( ! points . is Empty ( ) ) { draw ( g , points ) ; } points . clear ( ) ; points . add ( point ) ; break ; case Path Iterator . SEG LINETO : points . add ( point ) ; break ; case Path Iterator . SEG CLOSE : points . add ( first Point ) ; break ; } pi . next ( ) ; } while ( ! pi . is Done ( ) ) ; if ( ! points . is Empty ( ) ) { draw ( g , points ) ; } }
public Key Change ( String new Key Data , DSA Public Key change Key , boolean allows Unsigned Changes , boolean allows Public Visibility , byte [ ] msg , byte [ ] sig , long epoch , long counter ) { this . new Key Data = new Key Data ; this . new Change Key = change Key ; this . allows Unsigned Changes = allows Unsigned Changes ; this . allows Public Visibility = allows Public Visibility ; this . msg = msg == null ? null : Arrays . copy Of ( msg , msg . length ) ; this . sig = sig == null ? null : Arrays . copy Of ( sig , sig . length ) ; this . epoch = epoch ; this . counter = counter ; Logging . log ( STRING + Arrays . to String ( this . sig ) ) ; }
public Key Change ( String new Key Data , DSA Public Key change Key , boolean allows Unsigned Changes , boolean allows Public Visibility , byte [ ] msg , byte [ ] sig , long epoch , long counter ) { this . new Key Data = new Key Data ; this . new Change Key = change Key ; this . allows Unsigned Changes = allows Unsigned Changes ; this . allows Public Visibility = allows Public Visibility ; this . msg = msg == null ? null : Arrays . copy Of ( msg , msg . length ) ; this . sig = sig == null ? null : Arrays . copy Of ( sig , sig . length ) ; this . epoch = epoch ; this . counter = counter ; Logging . log ( STRING + Arrays . to String ( this . sig ) ) ; }
private void build Tasks Loads Rectangles ( List < Load > partition , int ypos ) { List < Offset > offsets = get Default Offsets ( ) ; Iterator < Load > loads = partition . iterator ( ) ; while ( loads . has Next ( ) ) { final Load next Load = loads . next ( ) ; final Date next Start = next Load . start Date ; final Date next End = next Load . end Date ; final Rectangle next Rect = create Rectangle ( offsets , next Start , next End , ypos ) ; if ( next Rect == null ) { continue ; } String style ; if ( next Load . load < NUM ) { style = STRING ; } else if ( next Load . load > NUM ) { style = STRING ; } else { style = STRING ; } style += STRING ; next Rect . set Style ( style ) ; next Rect . set Model Object ( new Resource Load ( next Load . load ) ) ; create Load Text ( next Rect , next Load ) ; } }
private void build Tasks Loads Rectangles ( List < Load > partition , int ypos ) { List < Offset > offsets = get Default Offsets ( ) ; Iterator < Load > loads = partition . iterator ( ) ; while ( loads . has Next ( ) ) { final Load next Load = loads . next ( ) ; final Date next Start = next Load . start Date ; final Date next End = next Load . end Date ; final Rectangle next Rect = create Rectangle ( offsets , next Start , next End , ypos ) ; if ( next Rect == null ) { continue ; } String style ; if ( next Load . load < NUM ) { style = STRING ; } else if ( next Load . load > NUM ) { style = STRING ; } else { style = STRING ; } style += STRING ; next Rect . set Style ( style ) ; next Rect . set Model Object ( new Resource Load ( next Load . load ) ) ; create Load Text ( next Rect , next Load ) ; } }
public static void shutdown Active ( Exit Code exit Code , String msg ) { shutdown Active ( Shutdown Mode Amp . GRACEFUL , exit Code , msg , null ) ; }
@ Suppress Warnings ( STRING ) public < U > Simple React Stream < U > from ( final Iterator < U > iterator ) { return from ( Stream Support . stream ( Spliterators . spliterator Unknown Size ( iterator , Spliterator . ORDERED ) , BOOL ) ) ; }
public Asn 1 Dump ( ) { indent Sequence = new Indent Sequence ( Indent Char . SPACE , NUM ) ; }
public Asn 1 Dump ( ) { indent Sequence = new Indent Sequence ( Indent Char . SPACE , NUM ) ; }
public final void close ( Gs Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } pending Close = BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
public final void close ( Gs Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } pending Close = BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
public final void close ( Gs Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } pending Close = BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
public final void close ( Gs Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } pending Close = BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
public final void close ( Gs Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } pending Close = BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
public final void close ( Gs Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } pending Close = BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
public final void close ( Gs Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } pending Close = BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
public static synchronized void do Deferred Specializations ( ) { if ( specialization In Progress ) { return ; } specialization In Progress = BOOL ; Iterator < Specialized Method > methods = deferred Methods . iterator ( ) ; while ( methods . has Next ( ) ) { Specialized Method m = methods . next ( ) ; if ( m . get Compiled Method ( ) == null ) { m . compile ( ) ; register Compiled Method ( m ) ; } deferred Methods . remove ( m ) ; methods = deferred Methods . iterator ( ) ; } specialization In Progress = BOOL ; }
private int convert Hex To Int ( String hex Value ) { int value ; try { value = Integer . parse Int ( hex Value , NUM ) ; } catch ( Number Format Exception e ) { logger . error ( STRING + hex Value + STRING , e ) ; return NUM ; } return value ; }
private int convert Hex To Int ( String hex Value ) { int value ; try { value = Integer . parse Int ( hex Value , NUM ) ; } catch ( Number Format Exception e ) { logger . error ( STRING + hex Value + STRING , e ) ; return NUM ; } return value ; }
public static boolean is Game Loop ( ) { return Thread . current Thread ( ) == get ( ) . loop Thread ; }
public Parallel Animator add ( Combinable combinable ) { combinable List . add ( combinable ) ; return this ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof Matrix 3 f ) || o == null ) { return BOOL ; } if ( this == o ) { return BOOL ; } Matrix 3 f comp = ( Matrix 3 f ) o ; if ( Float . compare ( m00 , comp . m00 ) != NUM ) { return BOOL ; } if ( Float . compare ( m01 , comp . m01 ) != NUM ) { return BOOL ; } if ( Float . compare ( m02 , comp . m02 ) != NUM ) { return BOOL ; } if ( Float . compare ( m10 , comp . m10 ) != NUM ) { return BOOL ; } if ( Float . compare ( m11 , comp . m11 ) != NUM ) { return BOOL ; } if ( Float . compare ( m12 , comp . m12 ) != NUM ) { return BOOL ; } if ( Float . compare ( m20 , comp . m20 ) != NUM ) { return BOOL ; } if ( Float . compare ( m21 , comp . m21 ) != NUM ) { return BOOL ; } if ( Float . compare ( m22 , comp . m22 ) != NUM ) { return BOOL ; } return BOOL ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof Matrix 3 f ) || o == null ) { return BOOL ; } if ( this == o ) { return BOOL ; } Matrix 3 f comp = ( Matrix 3 f ) o ; if ( Float . compare ( m00 , comp . m00 ) != NUM ) { return BOOL ; } if ( Float . compare ( m01 , comp . m01 ) != NUM ) { return BOOL ; } if ( Float . compare ( m02 , comp . m02 ) != NUM ) { return BOOL ; } if ( Float . compare ( m10 , comp . m10 ) != NUM ) { return BOOL ; } if ( Float . compare ( m11 , comp . m11 ) != NUM ) { return BOOL ; } if ( Float . compare ( m12 , comp . m12 ) != NUM ) { return BOOL ; } if ( Float . compare ( m20 , comp . m20 ) != NUM ) { return BOOL ; } if ( Float . compare ( m21 , comp . m21 ) != NUM ) { return BOOL ; } if ( Float . compare ( m22 , comp . m22 ) != NUM ) { return BOOL ; } return BOOL ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof Matrix 3 f ) || o == null ) { return BOOL ; } if ( this == o ) { return BOOL ; } Matrix 3 f comp = ( Matrix 3 f ) o ; if ( Float . compare ( m00 , comp . m00 ) != NUM ) { return BOOL ; } if ( Float . compare ( m01 , comp . m01 ) != NUM ) { return BOOL ; } if ( Float . compare ( m02 , comp . m02 ) != NUM ) { return BOOL ; } if ( Float . compare ( m10 , comp . m10 ) != NUM ) { return BOOL ; } if ( Float . compare ( m11 , comp . m11 ) != NUM ) { return BOOL ; } if ( Float . compare ( m12 , comp . m12 ) != NUM ) { return BOOL ; } if ( Float . compare ( m20 , comp . m20 ) != NUM ) { return BOOL ; } if ( Float . compare ( m21 , comp . m21 ) != NUM ) { return BOOL ; } if ( Float . compare ( m22 , comp . m22 ) != NUM ) { return BOOL ; } return BOOL ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof Matrix 3 f ) || o == null ) { return BOOL ; } if ( this == o ) { return BOOL ; } Matrix 3 f comp = ( Matrix 3 f ) o ; if ( Float . compare ( m00 , comp . m00 ) != NUM ) { return BOOL ; } if ( Float . compare ( m01 , comp . m01 ) != NUM ) { return BOOL ; } if ( Float . compare ( m02 , comp . m02 ) != NUM ) { return BOOL ; } if ( Float . compare ( m10 , comp . m10 ) != NUM ) { return BOOL ; } if ( Float . compare ( m11 , comp . m11 ) != NUM ) { return BOOL ; } if ( Float . compare ( m12 , comp . m12 ) != NUM ) { return BOOL ; } if ( Float . compare ( m20 , comp . m20 ) != NUM ) { return BOOL ; } if ( Float . compare ( m21 , comp . m21 ) != NUM ) { return BOOL ; } if ( Float . compare ( m22 , comp . m22 ) != NUM ) { return BOOL ; } return BOOL ; }
public boolean remove if cycle ( Brd Tracep p trace ) { if ( ! p trace . is on the board ( ) ) return BOOL ; if ( ! p trace . has cycle ( ) ) return BOOL ; int curr layer = p trace . get layer ( ) ; Pla Point [ ] end corners = new Pla Point [ NUM ] ; end corners [ NUM ] = p trace . corner first ( ) ; end corners [ NUM ] = p trace . corner last ( ) ; boolean [ ] tail at endpoint before = new boolean [ NUM ] ; for ( int index = NUM ; index < NUM ; ++ index ) { Brd Tracep tail = get trace tail ( end corners [ index ] , curr layer , p trace . net nos ) ; tail at endpoint before [ index ] = ( tail != null ) ; } Set < Brd Item > connection items = p trace . get connection items ( ) ; remove items unfixed ( connection items ) ; for ( int index = NUM ; index < NUM ; ++ index ) { if ( tail at endpoint before [ index ] ) continue ; Brd Tracep tail = get trace tail ( end corners [ index ] , curr layer , p trace . net nos ) ; if ( tail == null ) continue ; remove items unfixed ( tail . get connection items ( ) ) ; } return BOOL ; }
public void append ( String string ) { for ( int i = NUM ; i < string . length ( ) ; i ++ ) append ( string . char At ( i ) ) ; }
public static long read Long ( final JSON Object json Object , final String key , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return json Object . get Long ( key ) ; } if ( not Null && json Object . is Null ( key ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT OBJECT , key ) ) ; } long value = NUM ; if ( ! json Object . is Null ( key ) ) { value = json Object . get Long ( key ) ; } return value ; }
public static String plural Creature ( final String noun ) { if ( noun . equals ( STRING ) ) { return STRING ; } return plural ( noun ) ; }
public Enumeration < ? extends Principal > members ( ) { Vector < Principal > v = new Vector < Principal > ( NUM ) ; v . add Element ( this ) ; return v . elements ( ) ; }
public Enumeration < ? extends Principal > members ( ) { Vector < Principal > v = new Vector < Principal > ( NUM ) ; v . add Element ( this ) ; return v . elements ( ) ; }
public Enumeration list Options ( ) { Vector new Vector = new Vector ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
public Enumeration list Options ( ) { Vector new Vector = new Vector ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
public int compare To ( XML String xstr ) { int len 1 = m length ; int len 2 = xstr . length ( ) ; int n = Math . min ( len 1 , len 2 ) ; Fast String Buffer fsb = fsb ( ) ; int i = m start ; int j = NUM ; while ( n -- != NUM ) { char c1 = fsb . char At ( i ) ; char c2 = xstr . char At ( j ) ; if ( c1 != c2 ) { return c1 - c2 ; } i ++ ; j ++ ; } return len 1 - len 2 ; }
public Version ( @ Non Null String version ) throws Parse Exception { final String [ ] number Strings = version . split ( STRING ) ; final int versions Count = Math . min ( NUMBERS COUNT , number Strings . length ) ; for ( int i = NUM ; i < versions Count ; i ++ ) { final String number String = number Strings [ i ] ; final char first Char = number String . char At ( NUM ) ; if ( first Char == STRING || first Char == STRING ) { throw new Version Parse Exception ( NUM ) ; } try { numbers [ i ] = Integer . parse Int ( number String ) ; } catch ( Number Format Exception e ) { throw new Version Parse Exception ( version . index Of ( number String ) ) ; } } }
public void test Create Document 1 ( ) throws Throwable { String namespace URI = STRING ; String malformed Name = STRING ; Document doc ; Document Type doc Type = null ; DOM Implementation dom Impl ; doc = ( Document ) load ( STRING , builder ) ; dom Impl = doc . get Implementation ( ) ; boolean success = BOOL ; try { dom Impl . create Document ( namespace URI , malformed Name , doc Type ) ; } catch ( DOM Exception ex ) { success = ( ex . code == DOM Exception . NAMESPACE ERR ) ; } assert True ( STRING , success ) ; }
public Abstract Resource ( String mimetype ) { this ( mimetype , System . current Time Millis ( ) ) ; }
public Abstract Resource ( String mimetype ) { this ( mimetype , System . current Time Millis ( ) ) ; }
public synchronized void remove Section ( String section ) { String section Dot = section + STRING ; if ( is Section Defined ( section ) ) { Linked Hash Set < String > keys = new Linked Hash Set < String > ( options . key Set ( ) ) ; for ( String key : keys ) { if ( key . starts With ( section Dot ) ) { remove Option ( key ) ; } } } }
public synchronized void remove Section ( String section ) { String section Dot = section + STRING ; if ( is Section Defined ( section ) ) { Linked Hash Set < String > keys = new Linked Hash Set < String > ( options . key Set ( ) ) ; for ( String key : keys ) { if ( key . starts With ( section Dot ) ) { remove Option ( key ) ; } } } }
public Ids Query Builder add Ids ( String ... ids ) { values . add All ( Arrays . as List ( ids ) ) ; return this ; }
public static Object eval ( String script ) throws Script Exception { require Load ( ) ; check Supported ( ) ; return engine . eval ( script ) ; }
public static Object eval ( String script ) throws Script Exception { require Load ( ) ; check Supported ( ) ; return engine . eval ( script ) ; }
public static Object eval ( String script ) throws Script Exception { require Load ( ) ; check Supported ( ) ; return engine . eval ( script ) ; }
public boolean has Breakpoint ( final Breakpoint Type type , final Breakpoint Address address ) { check Arguments ( type , address ) ; switch ( type ) { case REGULAR : return indexed Breakpoint Storage . get ( address ) != null ; case ECHO : return echo Breakpoint Storage . get ( address ) != null ; case STEP : return step Breakpoint Storage . get ( address ) != null ; default : throw new Illegal State Exception ( String . format ( STRING , type ) ) ; } }
public boolean has Breakpoint ( final Breakpoint Type type , final Breakpoint Address address ) { check Arguments ( type , address ) ; switch ( type ) { case REGULAR : return indexed Breakpoint Storage . get ( address ) != null ; case ECHO : return echo Breakpoint Storage . get ( address ) != null ; case STEP : return step Breakpoint Storage . get ( address ) != null ; default : throw new Illegal State Exception ( String . format ( STRING , type ) ) ; } }
public static void init ( Context context ) { if ( s Instance == null ) { final Executor Service service = Executors . new Single Thread Executor ( ) ; s Training Task Future = service . submit ( new Training Task ( context ) ) ; } else { throw new Illegal State Exception ( STRING + STRING ) ; } }
public static void init ( Context context ) { if ( s Instance == null ) { final Executor Service service = Executors . new Single Thread Executor ( ) ; s Training Task Future = service . submit ( new Training Task ( context ) ) ; } else { throw new Illegal State Exception ( STRING + STRING ) ; } }
public static void init ( Context context ) { if ( s Instance == null ) { final Executor Service service = Executors . new Single Thread Executor ( ) ; s Training Task Future = service . submit ( new Training Task ( context ) ) ; } else { throw new Illegal State Exception ( STRING + STRING ) ; } }
static void write ( Socket Channel chan , byte [ ] data ) throws Timeout Exception , IO Exception { write ( chan , data , - NUM , Ddm Preferences . get Time Out ( ) ) ; }
protected Monitor poll For ( Map < String , Monitor > map , String name , long time Limit ) throws Monitor Exception { Monitor monitor = null ; log ( STRING + lvmid + STRING + name + STRING ) ; poll For Entry = next Entry ; while ( ( monitor = map . get ( name ) ) == null ) { log ( STRING ) ; try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { } long t = System . current Time Millis ( ) ; if ( ( t > time Limit ) || ( overflow . int Value ( ) > NUM ) ) { lognl ( STRING + lvmid + STRING + name ) ; dump All ( map , lvmid ) ; throw new Monitor Exception ( STRING ) ; } get New Monitors ( map ) ; } lognl ( STRING + lvmid + STRING + name ) ; return monitor ; }
public Multimap < String , String > assemble All Watch Keys ( String app Id , String cluster Name , Set < String > namespaces , String data Center ) { Multimap < String , String > watched Keys Map = assemble Watch Keys ( app Id , cluster Name , namespaces , data Center ) ; if ( ! ( namespaces . size ( ) == NUM && namespaces . contains ( Config Consts . NAMESPACE APPLICATION ) ) ) { Set < String > namespaces Belong To App Id = namespaces Belong To App Id ( app Id , namespaces ) ; Set < String > public Namespaces = Sets . difference ( namespaces , namespaces Belong To App Id ) ; if ( ! public Namespaces . is Empty ( ) ) { watched Keys Map . put All ( find Public Config Watch Keys ( app Id , cluster Name , public Namespaces , data Center ) ) ; } } return watched Keys Map ; }
public static File save File ( String log Data ) { File dir = get Log Dir ( ) ; if ( dir == null ) { return null ; } File Writer file Writer = null ; File output = null ; try { output = new File ( dir , get Log File Name ( ) ) ; file Writer = new File Writer ( output , BOOL ) ; file Writer . write ( log Data ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } finally { if ( file Writer != null ) { try { file Writer . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } } return output ; }
public static Vector 3 az El To Point ( double az , double el , Vector 3 result ) { if ( result == null ) { result = new Vector 3 ( ) ; } Matrix 3 mat = Matrix 3 . fetch Temp Instance ( ) ; mat . from Angle Axis ( az , Vector 3 . NEG UNIT Z ) ; Matrix 3 mat 2 = Matrix 3 . fetch Temp Instance ( ) ; mat 2 . from Angle Axis ( el , Vector 3 . UNIT X ) ; mat . multiply Local ( mat 2 ) ; result . set ( Vector 3 . UNIT Y ) ; mat . apply Post ( result , result ) ; Matrix 3 . release Temp Instance ( mat ) ; Matrix 3 . release Temp Instance ( mat 2 ) ; return ( result ) ; }
public static Vector 3 az El To Point ( double az , double el , Vector 3 result ) { if ( result == null ) { result = new Vector 3 ( ) ; } Matrix 3 mat = Matrix 3 . fetch Temp Instance ( ) ; mat . from Angle Axis ( az , Vector 3 . NEG UNIT Z ) ; Matrix 3 mat 2 = Matrix 3 . fetch Temp Instance ( ) ; mat 2 . from Angle Axis ( el , Vector 3 . UNIT X ) ; mat . multiply Local ( mat 2 ) ; result . set ( Vector 3 . UNIT Y ) ; mat . apply Post ( result , result ) ; Matrix 3 . release Temp Instance ( mat ) ; Matrix 3 . release Temp Instance ( mat 2 ) ; return ( result ) ; }
public static < U > Function < U , Predicate < U > > not Self ( ) { return null ; }
public Double read ( String value ) { return Double . value Of ( value ) ; }
public Double read ( String value ) { return Double . value Of ( value ) ; }
public Double read ( String value ) { return Double . value Of ( value ) ; }
public void write List End ( ) throws IO Exception { os . write ( STRING ) ; }
private byte [ ] encode ( final Revision Codec Data codec Data , final Diff diff ) throws Unsupported Encoding Exception , Encoding Exception { this . data = new Bit Writer ( codec Data . total Size In Bits ( ) ) ; encode Codec Data ( codec Data ) ; Diff Part part ; Iterator < Diff Part > part It = diff . iterator ( ) ; while ( part It . has Next ( ) ) { part = part It . next ( ) ; switch ( part . get Action ( ) ) { case FULL REVISION UNCOMPRESSED : encode Full Revision Uncompressed ( part ) ; break ; case INSERT : encode Insert ( part ) ; break ; case DELETE : encode Delete ( part ) ; break ; case REPLACE : encode Replace ( part ) ; break ; case CUT : encode Cut ( part ) ; break ; case PASTE : encode Paste ( part ) ; break ; default : throw new Runtime Exception ( ) ; } } return data . to Byte Array ( ) ; }
private byte [ ] encode ( final Revision Codec Data codec Data , final Diff diff ) throws Unsupported Encoding Exception , Encoding Exception { this . data = new Bit Writer ( codec Data . total Size In Bits ( ) ) ; encode Codec Data ( codec Data ) ; Diff Part part ; Iterator < Diff Part > part It = diff . iterator ( ) ; while ( part It . has Next ( ) ) { part = part It . next ( ) ; switch ( part . get Action ( ) ) { case FULL REVISION UNCOMPRESSED : encode Full Revision Uncompressed ( part ) ; break ; case INSERT : encode Insert ( part ) ; break ; case DELETE : encode Delete ( part ) ; break ; case REPLACE : encode Replace ( part ) ; break ; case CUT : encode Cut ( part ) ; break ; case PASTE : encode Paste ( part ) ; break ; default : throw new Runtime Exception ( ) ; } } return data . to Byte Array ( ) ; }
public IP Address Name ( Der Value der Value ) throws IO Exception { this ( der Value . get Octet String ( ) ) ; }
@ Override protected Instance process ( Instance instance ) throws Exception { Instance result ; double [ ] values ; int i ; values = new double [ m Indices . length ] ; for ( i = NUM ; i < m Indices . length ; i ++ ) { values [ i ] = instance . value ( m Indices [ i ] ) ; } result = new Dense Instance ( instance . weight ( ) , values ) ; result . set Dataset ( get Output Format ( ) ) ; copy Values ( result , BOOL , instance . dataset ( ) , get Output Format ( ) ) ; result . set Dataset ( get Output Format ( ) ) ; return result ; }
@ Override protected Instance process ( Instance instance ) throws Exception { Instance result ; double [ ] values ; int i ; values = new double [ m Indices . length ] ; for ( i = NUM ; i < m Indices . length ; i ++ ) { values [ i ] = instance . value ( m Indices [ i ] ) ; } result = new Dense Instance ( instance . weight ( ) , values ) ; result . set Dataset ( get Output Format ( ) ) ; copy Values ( result , BOOL , instance . dataset ( ) , get Output Format ( ) ) ; result . set Dataset ( get Output Format ( ) ) ; return result ; }
@ Override protected Instance process ( Instance instance ) throws Exception { Instance result ; double [ ] values ; int i ; values = new double [ m Indices . length ] ; for ( i = NUM ; i < m Indices . length ; i ++ ) { values [ i ] = instance . value ( m Indices [ i ] ) ; } result = new Dense Instance ( instance . weight ( ) , values ) ; result . set Dataset ( get Output Format ( ) ) ; copy Values ( result , BOOL , instance . dataset ( ) , get Output Format ( ) ) ; result . set Dataset ( get Output Format ( ) ) ; return result ; }
@ Override public void end Prefix Mapping ( String str ) throws SAX Exception { }
public void put Grammar ( Grammar grammar ) { if ( ! f Pool Is Locked ) { synchronized ( f Grammars ) { XML Grammar Description desc = grammar . get Grammar Description ( ) ; int hash = hash Code ( desc ) ; int index = ( hash & NUM ) % f Grammars . length ; for ( Entry entry = f Grammars [ index ] ; entry != null ; entry = entry . next ) { if ( entry . hash == hash && equals ( entry . desc , desc ) ) { entry . grammar = grammar ; return ; } } Entry entry = new Entry ( hash , desc , grammar , f Grammars [ index ] ) ; f Grammars [ index ] = entry ; f Grammar Count ++ ; } } }
public void output ( Print Writer out ) { out . write ( version Decl ) ; for ( int i = NUM ; i < prolog . size ( ) ; i ++ ) { Concrete Element e = ( Concrete Element ) prolog . element At ( i ) ; e . output ( out ) ; } if ( content != null ) content . output ( out ) ; }
public void add Text ( String text ) { if ( null != text ) { texts . add ( new Text Properties ( text , current Size , current Color ) ) ; reclamp Text ( ) ; invalidate ( ) ; } }
public void add Text ( String text ) { if ( null != text ) { texts . add ( new Text Properties ( text , current Size , current Color ) ) ; reclamp Text ( ) ; invalidate ( ) ; } }
public void add Text ( String text ) { if ( null != text ) { texts . add ( new Text Properties ( text , current Size , current Color ) ) ; reclamp Text ( ) ; invalidate ( ) ; } }
public void add Text ( String text ) { if ( null != text ) { texts . add ( new Text Properties ( text , current Size , current Color ) ) ; reclamp Text ( ) ; invalidate ( ) ; } }
public int size ( ) { return bits . cardinality ( ) ; }
@ Suppress Warnings ( STRING ) public Throwing Mock Token Filter Factory ( Map < String , String > args ) { super ( args ) ; String exception Class Name = args . get ( STRING ) ; if ( exception Class Name == null ) { throw new Runtime Exception ( STRING ) ; } try { exception Class = ( Class < ? extends Runtime Exception > ) Class . for Name ( exception Class Name ) ; } catch ( Class Not Found Exception e ) { throw new Runtime Exception ( e ) ; } }
@ Suppress Warnings ( STRING ) public Throwing Mock Token Filter Factory ( Map < String , String > args ) { super ( args ) ; String exception Class Name = args . get ( STRING ) ; if ( exception Class Name == null ) { throw new Runtime Exception ( STRING ) ; } try { exception Class = ( Class < ? extends Runtime Exception > ) Class . for Name ( exception Class Name ) ; } catch ( Class Not Found Exception e ) { throw new Runtime Exception ( e ) ; } }
public String attribute Case Fix ( String column Name ) { if ( m check For Upper Case Names ) { String ucname = column Name . to Upper Case ( ) ; if ( ucname . equals ( EXP TYPE COL . to Upper Case ( ) ) ) { return EXP TYPE COL ; } else if ( ucname . equals ( EXP SETUP COL . to Upper Case ( ) ) ) { return EXP SETUP COL ; } else if ( ucname . equals ( EXP RESULT COL . to Upper Case ( ) ) ) { return EXP RESULT COL ; } else { return column Name ; } } else if ( m check For Lower Case Names ) { String ucname = column Name . to Lower Case ( ) ; if ( ucname . equals ( EXP TYPE COL . to Lower Case ( ) ) ) { return EXP TYPE COL ; } else if ( ucname . equals ( EXP SETUP COL . to Lower Case ( ) ) ) { return EXP SETUP COL ; } else if ( ucname . equals ( EXP RESULT COL . to Lower Case ( ) ) ) { return EXP RESULT COL ; } else { return column Name ; } } else { return column Name ; } }
public String attribute Case Fix ( String column Name ) { if ( m check For Upper Case Names ) { String ucname = column Name . to Upper Case ( ) ; if ( ucname . equals ( EXP TYPE COL . to Upper Case ( ) ) ) { return EXP TYPE COL ; } else if ( ucname . equals ( EXP SETUP COL . to Upper Case ( ) ) ) { return EXP SETUP COL ; } else if ( ucname . equals ( EXP RESULT COL . to Upper Case ( ) ) ) { return EXP RESULT COL ; } else { return column Name ; } } else if ( m check For Lower Case Names ) { String ucname = column Name . to Lower Case ( ) ; if ( ucname . equals ( EXP TYPE COL . to Lower Case ( ) ) ) { return EXP TYPE COL ; } else if ( ucname . equals ( EXP SETUP COL . to Lower Case ( ) ) ) { return EXP SETUP COL ; } else if ( ucname . equals ( EXP RESULT COL . to Lower Case ( ) ) ) { return EXP RESULT COL ; } else { return column Name ; } } else { return column Name ; } }
public String attribute Case Fix ( String column Name ) { if ( m check For Upper Case Names ) { String ucname = column Name . to Upper Case ( ) ; if ( ucname . equals ( EXP TYPE COL . to Upper Case ( ) ) ) { return EXP TYPE COL ; } else if ( ucname . equals ( EXP SETUP COL . to Upper Case ( ) ) ) { return EXP SETUP COL ; } else if ( ucname . equals ( EXP RESULT COL . to Upper Case ( ) ) ) { return EXP RESULT COL ; } else { return column Name ; } } else if ( m check For Lower Case Names ) { String ucname = column Name . to Lower Case ( ) ; if ( ucname . equals ( EXP TYPE COL . to Lower Case ( ) ) ) { return EXP TYPE COL ; } else if ( ucname . equals ( EXP SETUP COL . to Lower Case ( ) ) ) { return EXP SETUP COL ; } else if ( ucname . equals ( EXP RESULT COL . to Lower Case ( ) ) ) { return EXP RESULT COL ; } else { return column Name ; } } else { return column Name ; } }
public String attribute Case Fix ( String column Name ) { if ( m check For Upper Case Names ) { String ucname = column Name . to Upper Case ( ) ; if ( ucname . equals ( EXP TYPE COL . to Upper Case ( ) ) ) { return EXP TYPE COL ; } else if ( ucname . equals ( EXP SETUP COL . to Upper Case ( ) ) ) { return EXP SETUP COL ; } else if ( ucname . equals ( EXP RESULT COL . to Upper Case ( ) ) ) { return EXP RESULT COL ; } else { return column Name ; } } else if ( m check For Lower Case Names ) { String ucname = column Name . to Lower Case ( ) ; if ( ucname . equals ( EXP TYPE COL . to Lower Case ( ) ) ) { return EXP TYPE COL ; } else if ( ucname . equals ( EXP SETUP COL . to Lower Case ( ) ) ) { return EXP SETUP COL ; } else if ( ucname . equals ( EXP RESULT COL . to Lower Case ( ) ) ) { return EXP RESULT COL ; } else { return column Name ; } } else { return column Name ; } }
public int add Secondary Equations ( final Secondary ODE secondary ) { components . add ( secondary ) ; mapper = new Equations Mapper ( mapper , secondary . get Dimension ( ) ) ; return components . size ( ) ; }
public Public Key load Public Key ( int id ) throws Exception { if ( default Keys ) { return get Public Key From String ( RSA Key Loader . DEFAULT UKEY ) ; } File Reader f = new File Reader ( path + STRING + id ) ; Buffered Reader r = new Buffered Reader ( f ) ; String tmp = STRING ; String key = STRING ; while ( ( tmp = r . read Line ( ) ) != null ) { key = key + tmp ; } f . close ( ) ; r . close ( ) ; Public Key ret = get Public Key From String ( key ) ; return ret ; }
public static String convert Method Signature ( String class Name , String method Name , String method Sig , String pkg Name ) { String Builder args = new String Builder ( ) ; Signature Converter converter = new Signature Converter ( method Sig ) ; converter . skip ( ) ; args . append ( STRING ) ; while ( converter . get First ( ) != STRING ) { if ( args . length ( ) > NUM ) { args . append ( STRING ) ; } args . append ( shorten ( pkg Name , converter . parse Next ( ) ) ) ; } converter . skip ( ) ; args . append ( STRING ) ; String Builder result = new String Builder ( ) ; result . append ( class Name ) ; result . append ( STRING ) ; result . append ( method Name ) ; result . append ( args . to String ( ) ) ; return result . to String ( ) ; }
public final void remove Model Listener ( final Vision World Model Listener listener ) { listener List . remove ( Vision World Model Listener . class , listener ) ; }
public void service ( Mail mail ) throws Mailet Exception { Mime Message message ; try { message = mail . get Message ( ) ; } catch ( Messaging Exception e ) { throw new Mailet Exception ( STRING , e ) ; } try { if ( message . is Mime Type ( STRING ) ) { analyse Multipart Part Message ( message , mail ) ; } } catch ( Messaging Exception e ) { throw new Mailet Exception ( STRING , e ) ; } catch ( Exception e ) { throw new Mailet Exception ( STRING , e ) ; } }
public void service ( Mail mail ) throws Mailet Exception { Mime Message message ; try { message = mail . get Message ( ) ; } catch ( Messaging Exception e ) { throw new Mailet Exception ( STRING , e ) ; } try { if ( message . is Mime Type ( STRING ) ) { analyse Multipart Part Message ( message , mail ) ; } } catch ( Messaging Exception e ) { throw new Mailet Exception ( STRING , e ) ; } catch ( Exception e ) { throw new Mailet Exception ( STRING , e ) ; } }
@ Override protected void execution Started ( ) { m Button Start . set Enabled ( BOOL ) ; m Button Stop . set Enabled ( BOOL ) ; }
public Red 5 ( I Connection conn ) { this . conn = conn ; }
public Red 5 ( I Connection conn ) { this . conn = conn ; }
private List < Race > parse Races ( String json ) { List < Race > result = new Array List < > ( ) ; if ( json == null ) { return null ; } JSON Parser parser = new JSON Parser ( ) ; try { JSON Object root = ( JSON Object ) parser . parse ( json . trim ( ) ) ; JSON Array races = ( JSON Array ) root . get ( STRING ) ; for ( Object o : races ) { if ( o instanceof JSON Object ) { Race race = parse Race ( ( JSON Object ) o ) ; if ( race != null ) { result . add ( race ) ; } } } } catch ( Parse Exception | Class Cast Exception | Null Pointer Exception ex ) { LOGGER . warning ( STRING + ex ) ; return null ; } return result ; }
public Set < String > add Content ( Prob Distribution distrib ) { if ( ! paused ) { cur State . add To State ( distrib ) ; return update ( ) ; } else { log . info ( STRING + distrib ) ; return Collections . empty Set ( ) ; } }
public Set < String > add Content ( Prob Distribution distrib ) { if ( ! paused ) { cur State . add To State ( distrib ) ; return update ( ) ; } else { log . info ( STRING + distrib ) ; return Collections . empty Set ( ) ; } }
public Set < String > add Content ( Prob Distribution distrib ) { if ( ! paused ) { cur State . add To State ( distrib ) ; return update ( ) ; } else { log . info ( STRING + distrib ) ; return Collections . empty Set ( ) ; } }
private Cell detect And Add Hit ( float x , float y ) { final Cell cell = check For New Hit ( x , y ) ; if ( cell != null ) { Cell fill In Gap Cell = null ; final Array List < Cell > pattern = m Pattern ; if ( ! pattern . is Empty ( ) ) { final Cell last Cell = pattern . get ( pattern . size ( ) - NUM ) ; int d Row = cell . row - last Cell . row ; int d Column = cell . column - last Cell . column ; int fill In Row = last Cell . row ; int fill In Column = last Cell . column ; if ( Math . abs ( d Row ) == NUM && Math . abs ( d Column ) != NUM ) { fill In Row = last Cell . row + ( ( d Row > NUM ) ? NUM : - NUM ) ; } if ( Math . abs ( d Column ) == NUM && Math . abs ( d Row ) != NUM ) { fill In Column = last Cell . column + ( ( d Column > NUM ) ? NUM : - NUM ) ; } fill In Gap Cell = Cell . of ( fill In Row , fill In Column ) ; } if ( fill In Gap Cell != null && ! m Pattern Draw Lookup [ fill In Gap Cell . row ] [ fill In Gap Cell . column ] ) { add Cell To Pattern ( fill In Gap Cell ) ; } add Cell To Pattern ( cell ) ; return cell ; } return null ; }
private Cell detect And Add Hit ( float x , float y ) { final Cell cell = check For New Hit ( x , y ) ; if ( cell != null ) { Cell fill In Gap Cell = null ; final Array List < Cell > pattern = m Pattern ; if ( ! pattern . is Empty ( ) ) { final Cell last Cell = pattern . get ( pattern . size ( ) - NUM ) ; int d Row = cell . row - last Cell . row ; int d Column = cell . column - last Cell . column ; int fill In Row = last Cell . row ; int fill In Column = last Cell . column ; if ( Math . abs ( d Row ) == NUM && Math . abs ( d Column ) != NUM ) { fill In Row = last Cell . row + ( ( d Row > NUM ) ? NUM : - NUM ) ; } if ( Math . abs ( d Column ) == NUM && Math . abs ( d Row ) != NUM ) { fill In Column = last Cell . column + ( ( d Column > NUM ) ? NUM : - NUM ) ; } fill In Gap Cell = Cell . of ( fill In Row , fill In Column ) ; } if ( fill In Gap Cell != null && ! m Pattern Draw Lookup [ fill In Gap Cell . row ] [ fill In Gap Cell . column ] ) { add Cell To Pattern ( fill In Gap Cell ) ; } add Cell To Pattern ( cell ) ; return cell ; } return null ; }
private Cell detect And Add Hit ( float x , float y ) { final Cell cell = check For New Hit ( x , y ) ; if ( cell != null ) { Cell fill In Gap Cell = null ; final Array List < Cell > pattern = m Pattern ; if ( ! pattern . is Empty ( ) ) { final Cell last Cell = pattern . get ( pattern . size ( ) - NUM ) ; int d Row = cell . row - last Cell . row ; int d Column = cell . column - last Cell . column ; int fill In Row = last Cell . row ; int fill In Column = last Cell . column ; if ( Math . abs ( d Row ) == NUM && Math . abs ( d Column ) != NUM ) { fill In Row = last Cell . row + ( ( d Row > NUM ) ? NUM : - NUM ) ; } if ( Math . abs ( d Column ) == NUM && Math . abs ( d Row ) != NUM ) { fill In Column = last Cell . column + ( ( d Column > NUM ) ? NUM : - NUM ) ; } fill In Gap Cell = Cell . of ( fill In Row , fill In Column ) ; } if ( fill In Gap Cell != null && ! m Pattern Draw Lookup [ fill In Gap Cell . row ] [ fill In Gap Cell . column ] ) { add Cell To Pattern ( fill In Gap Cell ) ; } add Cell To Pattern ( cell ) ; return cell ; } return null ; }
private Cell detect And Add Hit ( float x , float y ) { final Cell cell = check For New Hit ( x , y ) ; if ( cell != null ) { Cell fill In Gap Cell = null ; final Array List < Cell > pattern = m Pattern ; if ( ! pattern . is Empty ( ) ) { final Cell last Cell = pattern . get ( pattern . size ( ) - NUM ) ; int d Row = cell . row - last Cell . row ; int d Column = cell . column - last Cell . column ; int fill In Row = last Cell . row ; int fill In Column = last Cell . column ; if ( Math . abs ( d Row ) == NUM && Math . abs ( d Column ) != NUM ) { fill In Row = last Cell . row + ( ( d Row > NUM ) ? NUM : - NUM ) ; } if ( Math . abs ( d Column ) == NUM && Math . abs ( d Row ) != NUM ) { fill In Column = last Cell . column + ( ( d Column > NUM ) ? NUM : - NUM ) ; } fill In Gap Cell = Cell . of ( fill In Row , fill In Column ) ; } if ( fill In Gap Cell != null && ! m Pattern Draw Lookup [ fill In Gap Cell . row ] [ fill In Gap Cell . column ] ) { add Cell To Pattern ( fill In Gap Cell ) ; } add Cell To Pattern ( cell ) ; return cell ; } return null ; }
private void apply Dependent Coupling ( Single Channel Element target , Channel Element cce , int index ) { Individual Channel Stream ics = cce . ch [ NUM ] . ics ; int offsets [ ] = ics . swb Offset ; float dest [ ] = target . coeffs ; float src [ ] = cce . ch [ NUM ] . coeffs ; int idx = NUM ; if ( ac . oc [ NUM ] . m4 ac . object Type == AOT AAC LTP ) { log . error ( String . format ( STRING ) ) ; return ; } int dest Offset = NUM ; int src Offset = NUM ; for ( int g = NUM ; g < ics . num Window Groups ; g ++ ) { for ( int i = NUM ; i < ics . max Sfb ; i ++ , idx ++ ) { if ( cce . ch [ NUM ] . band Type [ idx ] != ZERO BT ) { final float gain = cce . coup . gain [ index ] [ idx ] ; for ( int group = NUM ; group < ics . group Len [ g ] ; group ++ ) { for ( int k = offsets [ i ] ; k < offsets [ i + NUM ] ; k ++ ) { dest [ dest Offset + group * NUM + k ] += gain * src [ src Offset + group * NUM + k ] ; } } } } dest Offset += ics . group Len [ g ] * NUM ; src Offset += ics . group Len [ g ] * NUM ; } }
public int release Extra Resources ( ) { synchronized ( lock ) { int num Released Resources = NUM ; if ( requests Queue . is Empty ( ) ) { log . debug ( STRING ) ; if ( host Affinity Enabled ) { List < String > allocated Hosts = get Allocated Hosts ( ) ; for ( String host : allocated Hosts ) { num Released Resources += release Resources For Host ( host ) ; } } else { num Released Resources += release Resources For Host ( ANY HOST ) ; } clear State ( ) ; } return num Released Resources ; } }
public int release Extra Resources ( ) { synchronized ( lock ) { int num Released Resources = NUM ; if ( requests Queue . is Empty ( ) ) { log . debug ( STRING ) ; if ( host Affinity Enabled ) { List < String > allocated Hosts = get Allocated Hosts ( ) ; for ( String host : allocated Hosts ) { num Released Resources += release Resources For Host ( host ) ; } } else { num Released Resources += release Resources For Host ( ANY HOST ) ; } clear State ( ) ; } return num Released Resources ; } }
public void warning ( SAX Parse Exception e ) throws SAX Exception { add Validation Exception ( e ) ; }
public void warning ( SAX Parse Exception e ) throws SAX Exception { add Validation Exception ( e ) ; }
private void collect Osr Points And Barriers ( IR ir ) { osr Points = new Linked List < Instruction > ( ) ; osr Barriers = new Linked List < Instruction > ( ) ; Enumeration < Instruction > instenum = ir . forward Instr Enumerator ( ) ; while ( instenum . has More Elements ( ) ) { Instruction inst = instenum . next Element ( ) ; if ( Osr Point . conforms ( inst ) ) { osr Points . add ( inst ) ; } else if ( inst . operator ( ) == OSR BARRIER ) { osr Barriers . add ( inst ) ; } } }
void expand Capacity ( int minimum Capacity ) { int new Capacity = value . length * NUM + NUM ; if ( new Capacity - minimum Capacity < NUM ) new Capacity = minimum Capacity ; if ( new Capacity < NUM ) { if ( minimum Capacity < NUM ) throw new Out Of Memory Error ( ) ; new Capacity = Integer . MAX VALUE ; } value = Arrays . copy Of ( value , new Capacity ) ; }
void expand Capacity ( int minimum Capacity ) { int new Capacity = value . length * NUM + NUM ; if ( new Capacity - minimum Capacity < NUM ) new Capacity = minimum Capacity ; if ( new Capacity < NUM ) { if ( minimum Capacity < NUM ) throw new Out Of Memory Error ( ) ; new Capacity = Integer . MAX VALUE ; } value = Arrays . copy Of ( value , new Capacity ) ; }
void expand Capacity ( int minimum Capacity ) { int new Capacity = value . length * NUM + NUM ; if ( new Capacity - minimum Capacity < NUM ) new Capacity = minimum Capacity ; if ( new Capacity < NUM ) { if ( minimum Capacity < NUM ) throw new Out Of Memory Error ( ) ; new Capacity = Integer . MAX VALUE ; } value = Arrays . copy Of ( value , new Capacity ) ; }
public void fire Event ( Object event ) { if ( event == null ) { throw new Illegal Argument Exception ( STRING ) ; } m Task Queue . offer ( Task . obtain Task ( Task . CODE FIRE EVENT , event , - NUM ) ) ; if ( ! m Queue Processed ) process Task Queue ( ) ; }
public Listen Key start Listening ( ) throws IO Exception { return start Listening ( null , NUM ) ; }
public Listen Key start Listening ( ) throws IO Exception { return start Listening ( null , NUM ) ; }
public Str Builder delete All ( final String str ) { final int len = ( str == null ? NUM : str . length ( ) ) ; if ( len > NUM ) { int index = index Of ( str , NUM ) ; while ( index >= NUM ) { delete Impl ( index , index + len , len ) ; index = index Of ( str , index ) ; } } return this ; }
public Str Builder delete All ( final String str ) { final int len = ( str == null ? NUM : str . length ( ) ) ; if ( len > NUM ) { int index = index Of ( str , NUM ) ; while ( index >= NUM ) { delete Impl ( index , index + len , len ) ; index = index Of ( str , index ) ; } } return this ; }
public Str Builder delete All ( final String str ) { final int len = ( str == null ? NUM : str . length ( ) ) ; if ( len > NUM ) { int index = index Of ( str , NUM ) ; while ( index >= NUM ) { delete Impl ( index , index + len , len ) ; index = index Of ( str , index ) ; } } return this ; }
public static void gc ( ) { RUNTIME . gc ( ) ; }
private synchronized void init Registry ( boolean force ) throws Matlab Connection Exception { if ( registry == null || force ) { try { registry = Local Host RMI Helper . create Registry ( options . get Port ( ) ) ; } catch ( Exception e ) { try { registry = Local Host RMI Helper . get Registry ( options . get Port ( ) ) ; } catch ( Exception ex ) { throw new Matlab Connection Exception ( STRING , ex ) ; } } } }
private synchronized void init Registry ( boolean force ) throws Matlab Connection Exception { if ( registry == null || force ) { try { registry = Local Host RMI Helper . create Registry ( options . get Port ( ) ) ; } catch ( Exception e ) { try { registry = Local Host RMI Helper . get Registry ( options . get Port ( ) ) ; } catch ( Exception ex ) { throw new Matlab Connection Exception ( STRING , ex ) ; } } } }
public void add Baud Rate ( double baud Rate ) { if ( baud Rates == null ) { return ; } baud Rates . add ( new Double ( baud Rate ) ) ; if ( bandwidth < NUM || baud Rate < bandwidth ) { bandwidth = baud Rate ; } }
public void add Baud Rate ( double baud Rate ) { if ( baud Rates == null ) { return ; } baud Rates . add ( new Double ( baud Rate ) ) ; if ( bandwidth < NUM || baud Rate < bandwidth ) { bandwidth = baud Rate ; } }
public void add Baud Rate ( double baud Rate ) { if ( baud Rates == null ) { return ; } baud Rates . add ( new Double ( baud Rate ) ) ; if ( bandwidth < NUM || baud Rate < bandwidth ) { bandwidth = baud Rate ; } }
public void add Baud Rate ( double baud Rate ) { if ( baud Rates == null ) { return ; } baud Rates . add ( new Double ( baud Rate ) ) ; if ( bandwidth < NUM || baud Rate < bandwidth ) { bandwidth = baud Rate ; } }
public void add Baud Rate ( double baud Rate ) { if ( baud Rates == null ) { return ; } baud Rates . add ( new Double ( baud Rate ) ) ; if ( bandwidth < NUM || baud Rate < bandwidth ) { bandwidth = baud Rate ; } }
public void add Baud Rate ( double baud Rate ) { if ( baud Rates == null ) { return ; } baud Rates . add ( new Double ( baud Rate ) ) ; if ( bandwidth < NUM || baud Rate < bandwidth ) { bandwidth = baud Rate ; } }
public void add Baud Rate ( double baud Rate ) { if ( baud Rates == null ) { return ; } baud Rates . add ( new Double ( baud Rate ) ) ; if ( bandwidth < NUM || baud Rate < bandwidth ) { bandwidth = baud Rate ; } }
public void add Baud Rate ( double baud Rate ) { if ( baud Rates == null ) { return ; } baud Rates . add ( new Double ( baud Rate ) ) ; if ( bandwidth < NUM || baud Rate < bandwidth ) { bandwidth = baud Rate ; } }
public synchronized void add Channel To History ( String channel ) { if ( ! settings . get Boolean ( STRING ) ) { return ; } channel = prepare Channel ( channel ) ; if ( channel == null ) { return ; } settings . map Put ( HISTORY SETTING , channel , System . current Time Millis ( ) ) ; settings . set Setting Changed ( STRING ) ; }
protected void listen To Layers ( Layer [ ] new Layers ) { if ( Swing Utilities . is Event Dispatch Thread ( ) ) { listen To Layers From EDT ( new Layers ) ; } else { Swing Utilities . invoke Later ( new My Worker ( new Layers ) ) ; } }
protected void listen To Layers ( Layer [ ] new Layers ) { if ( Swing Utilities . is Event Dispatch Thread ( ) ) { listen To Layers From EDT ( new Layers ) ; } else { Swing Utilities . invoke Later ( new My Worker ( new Layers ) ) ; } }
static File create Segment File ( String name , File directory , long id , long version ) { return new File ( directory , String . format ( STRING , Assert . not Null ( name , STRING ) , id , version ) ) ; }
public boolean evaluate Is Zero ( final Vector v ) { return Math . abs ( evaluate ( v ) ) < MINIMUM RESOLUTION ; }
public static String normalize Inet 4 Address ( String ip 4 String ) { final int [ ] octets = parse Inet 4 Address ( ip 4 String ) ; if ( octets == null ) { return null ; } String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { if ( i > NUM ) { sb . append ( STRING ) ; } sb . append ( octets [ i ] ) ; } return sb . to String ( ) ; }
public static String normalize Inet 4 Address ( String ip 4 String ) { final int [ ] octets = parse Inet 4 Address ( ip 4 String ) ; if ( octets == null ) { return null ; } String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { if ( i > NUM ) { sb . append ( STRING ) ; } sb . append ( octets [ i ] ) ; } return sb . to String ( ) ; }
public void remove Cookie ( String url ) { cookie Jar . remove ( url ) ; }
public void add Data Set ( T d ) { if ( d == null ) return ; calc Min Max ( d ) ; m Data Sets . add ( d ) ; }
public void add Data Set ( T d ) { if ( d == null ) return ; calc Min Max ( d ) ; m Data Sets . add ( d ) ; }
void create ( Output Stream out , Manifest manifest ) throws IO Exception { Zip Output Stream zos = new Jar Output Stream ( out ) ; if ( flag 0 ) { zos . set Method ( Zip Output Stream . STORED ) ; } if ( manifest != null ) { if ( vflag ) { output ( get Msg ( STRING ) ) ; } Zip Entry e = new Zip Entry ( MANIFEST DIR ) ; e . set Time ( System . current Time Millis ( ) ) ; e . set Size ( NUM ) ; e . set Crc ( NUM ) ; zos . put Next Entry ( e ) ; e = new Zip Entry ( MANIFEST NAME ) ; e . set Time ( System . current Time Millis ( ) ) ; if ( flag 0 ) { crc 32 Manifest ( e , manifest ) ; } zos . put Next Entry ( e ) ; manifest . write ( zos ) ; zos . close Entry ( ) ; } for ( File file : entries ) { add File ( zos , file ) ; } zos . close ( ) ; }
public static boolean is Local Resource Uri ( Uri uri ) { final String scheme = get Scheme Or Null ( uri ) ; return LOCAL RESOURCE SCHEME . equals ( scheme ) ; }
public static boolean is Local Resource Uri ( Uri uri ) { final String scheme = get Scheme Or Null ( uri ) ; return LOCAL RESOURCE SCHEME . equals ( scheme ) ; }
public void add Groups ( String [ ] new Groups ) throws IO Exception { test Array For Null Element ( new Groups ) ; check Groups ( new Groups ) ; synchronized ( registrars ) { if ( terminated ) throw new Illegal State Exception ( STRING ) ; if ( groups == null ) throw new Unsupported Operation Exception ( STRING ) ; Collection req = new Array List ( new Groups . length ) ; for ( int i = NUM ; i < new Groups . length ; i ++ ) { if ( groups . add ( new Groups [ i ] ) ) req . add ( new Groups [ i ] ) ; } if ( ! req . is Empty ( ) ) request Groups ( req ) ; } }
public void add Groups ( String [ ] new Groups ) throws IO Exception { test Array For Null Element ( new Groups ) ; check Groups ( new Groups ) ; synchronized ( registrars ) { if ( terminated ) throw new Illegal State Exception ( STRING ) ; if ( groups == null ) throw new Unsupported Operation Exception ( STRING ) ; Collection req = new Array List ( new Groups . length ) ; for ( int i = NUM ; i < new Groups . length ; i ++ ) { if ( groups . add ( new Groups [ i ] ) ) req . add ( new Groups [ i ] ) ; } if ( ! req . is Empty ( ) ) request Groups ( req ) ; } }
public void add Groups ( String [ ] new Groups ) throws IO Exception { test Array For Null Element ( new Groups ) ; check Groups ( new Groups ) ; synchronized ( registrars ) { if ( terminated ) throw new Illegal State Exception ( STRING ) ; if ( groups == null ) throw new Unsupported Operation Exception ( STRING ) ; Collection req = new Array List ( new Groups . length ) ; for ( int i = NUM ; i < new Groups . length ; i ++ ) { if ( groups . add ( new Groups [ i ] ) ) req . add ( new Groups [ i ] ) ; } if ( ! req . is Empty ( ) ) request Groups ( req ) ; } }
private void add Reminder ( ) { if ( m Default Reminder Minutes == General Preferences . NO REMINDER ) { Event View Utils . add Reminder ( m Activity , m Scroll View , this , m Reminder Items , m Reminder Minute Values , m Reminder Minute Labels , m Reminder Method Values , m Reminder Method Labels , Reminder Entry . value Of ( General Preferences . REMINDER DEFAULT TIME ) , m Model . m Calendar Max Reminders , null ) ; } else { Event View Utils . add Reminder ( m Activity , m Scroll View , this , m Reminder Items , m Reminder Minute Values , m Reminder Minute Labels , m Reminder Method Values , m Reminder Method Labels , Reminder Entry . value Of ( m Default Reminder Minutes ) , m Model . m Calendar Max Reminders , null ) ; } update Reminders Visibility ( m Reminder Items . size ( ) ) ; Event View Utils . update Add Reminder Button ( m View , m Reminder Items , m Model . m Calendar Max Reminders ) ; }
private void add Reminder ( ) { if ( m Default Reminder Minutes == General Preferences . NO REMINDER ) { Event View Utils . add Reminder ( m Activity , m Scroll View , this , m Reminder Items , m Reminder Minute Values , m Reminder Minute Labels , m Reminder Method Values , m Reminder Method Labels , Reminder Entry . value Of ( General Preferences . REMINDER DEFAULT TIME ) , m Model . m Calendar Max Reminders , null ) ; } else { Event View Utils . add Reminder ( m Activity , m Scroll View , this , m Reminder Items , m Reminder Minute Values , m Reminder Minute Labels , m Reminder Method Values , m Reminder Method Labels , Reminder Entry . value Of ( m Default Reminder Minutes ) , m Model . m Calendar Max Reminders , null ) ; } update Reminders Visibility ( m Reminder Items . size ( ) ) ; Event View Utils . update Add Reminder Button ( m View , m Reminder Items , m Model . m Calendar Max Reminders ) ; }
private void add Reminder ( ) { if ( m Default Reminder Minutes == General Preferences . NO REMINDER ) { Event View Utils . add Reminder ( m Activity , m Scroll View , this , m Reminder Items , m Reminder Minute Values , m Reminder Minute Labels , m Reminder Method Values , m Reminder Method Labels , Reminder Entry . value Of ( General Preferences . REMINDER DEFAULT TIME ) , m Model . m Calendar Max Reminders , null ) ; } else { Event View Utils . add Reminder ( m Activity , m Scroll View , this , m Reminder Items , m Reminder Minute Values , m Reminder Minute Labels , m Reminder Method Values , m Reminder Method Labels , Reminder Entry . value Of ( m Default Reminder Minutes ) , m Model . m Calendar Max Reminders , null ) ; } update Reminders Visibility ( m Reminder Items . size ( ) ) ; Event View Utils . update Add Reminder Button ( m View , m Reminder Items , m Model . m Calendar Max Reminders ) ; }
private void add Reminder ( ) { if ( m Default Reminder Minutes == General Preferences . NO REMINDER ) { Event View Utils . add Reminder ( m Activity , m Scroll View , this , m Reminder Items , m Reminder Minute Values , m Reminder Minute Labels , m Reminder Method Values , m Reminder Method Labels , Reminder Entry . value Of ( General Preferences . REMINDER DEFAULT TIME ) , m Model . m Calendar Max Reminders , null ) ; } else { Event View Utils . add Reminder ( m Activity , m Scroll View , this , m Reminder Items , m Reminder Minute Values , m Reminder Minute Labels , m Reminder Method Values , m Reminder Method Labels , Reminder Entry . value Of ( m Default Reminder Minutes ) , m Model . m Calendar Max Reminders , null ) ; } update Reminders Visibility ( m Reminder Items . size ( ) ) ; Event View Utils . update Add Reminder Button ( m View , m Reminder Items , m Model . m Calendar Max Reminders ) ; }
private void add Reminder ( ) { if ( m Default Reminder Minutes == General Preferences . NO REMINDER ) { Event View Utils . add Reminder ( m Activity , m Scroll View , this , m Reminder Items , m Reminder Minute Values , m Reminder Minute Labels , m Reminder Method Values , m Reminder Method Labels , Reminder Entry . value Of ( General Preferences . REMINDER DEFAULT TIME ) , m Model . m Calendar Max Reminders , null ) ; } else { Event View Utils . add Reminder ( m Activity , m Scroll View , this , m Reminder Items , m Reminder Minute Values , m Reminder Minute Labels , m Reminder Method Values , m Reminder Method Labels , Reminder Entry . value Of ( m Default Reminder Minutes ) , m Model . m Calendar Max Reminders , null ) ; } update Reminders Visibility ( m Reminder Items . size ( ) ) ; Event View Utils . update Add Reminder Button ( m View , m Reminder Items , m Model . m Calendar Max Reminders ) ; }
public Second ( Date time , Time Zone zone , Locale locale ) { Calendar calendar = Calendar . get Instance ( zone , locale ) ; calendar . set Time ( time ) ; this . second = ( byte ) calendar . get ( Calendar . SECOND ) ; this . minute = ( byte ) calendar . get ( Calendar . MINUTE ) ; this . hour = ( byte ) calendar . get ( Calendar . HOUR OF DAY ) ; this . day = new Day ( time , zone , locale ) ; peg ( calendar ) ; }
public Str Builder replace All ( String search Str , String replace Str ) { int search Len = ( search Str == null ? NUM : search Str . length ( ) ) ; if ( search Len > NUM ) { int replace Len = ( replace Str == null ? NUM : replace Str . length ( ) ) ; int index = index Of ( search Str , NUM ) ; while ( index >= NUM ) { replace Impl ( index , index + search Len , search Len , replace Str , replace Len ) ; index = index Of ( search Str , index + replace Len ) ; } } return this ; }
public Str Builder replace All ( String search Str , String replace Str ) { int search Len = ( search Str == null ? NUM : search Str . length ( ) ) ; if ( search Len > NUM ) { int replace Len = ( replace Str == null ? NUM : replace Str . length ( ) ) ; int index = index Of ( search Str , NUM ) ; while ( index >= NUM ) { replace Impl ( index , index + search Len , search Len , replace Str , replace Len ) ; index = index Of ( search Str , index + replace Len ) ; } } return this ; }
public Recorded Request take Request ( ) throws Interrupted Exception { return request Queue . take ( ) ; }
public Recorded Request take Request ( ) throws Interrupted Exception { return request Queue . take ( ) ; }
public Recorded Request take Request ( ) throws Interrupted Exception { return request Queue . take ( ) ; }
public Recorded Request take Request ( ) throws Interrupted Exception { return request Queue . take ( ) ; }
public Recorded Request take Request ( ) throws Interrupted Exception { return request Queue . take ( ) ; }
public String Converter ( final int length Limit ) { this ( Collections . synchronized Map ( new Weak Cache < String , String > ( ) ) , length Limit ) ; }
public String Converter ( final int length Limit ) { this ( Collections . synchronized Map ( new Weak Cache < String , String > ( ) ) , length Limit ) ; }
public String Converter ( final int length Limit ) { this ( Collections . synchronized Map ( new Weak Cache < String , String > ( ) ) , length Limit ) ; }
public String Converter ( final int length Limit ) { this ( Collections . synchronized Map ( new Weak Cache < String , String > ( ) ) , length Limit ) ; }
public String to String ( ) { String Builder string Builder = new String Builder ( ) ; for ( Validation Error Object error : errors ) { string Builder . append ( error . to String ( ) ) ; } return string Builder . to String ( ) ; }
public String to String ( ) { String Builder string Builder = new String Builder ( ) ; for ( Validation Error Object error : errors ) { string Builder . append ( error . to String ( ) ) ; } return string Builder . to String ( ) ; }
private static void read Data From Binlog ( Replicator Runtime runtime , Binlog Reader binlog , byte [ ] data , int offset , int length , int timeout ) throws IO Exception , Replicator Exception , Interrupted Exception { boolean already Logged = BOOL ; int spent Time = NUM ; int timeout In Ms = timeout * NUM ; long available ; while ( ( available = binlog . available ( ) ) < ( long ) length ) { if ( ! already Logged ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + length + STRING + available + STRING + binlog . get File Name ( ) + STRING ) ; } already Logged = BOOL ; } try { if ( spent Time < timeout In Ms ) { Thread . sleep ( NUM ) ; spent Time ++ ; } else throw new My SQL Extract Exception ( STRING + timeout + STRING + length + STRING ) ; } catch ( Interrupted Exception e ) { } } binlog . read ( data , offset , length ) ; }
private static void read Data From Binlog ( Replicator Runtime runtime , Binlog Reader binlog , byte [ ] data , int offset , int length , int timeout ) throws IO Exception , Replicator Exception , Interrupted Exception { boolean already Logged = BOOL ; int spent Time = NUM ; int timeout In Ms = timeout * NUM ; long available ; while ( ( available = binlog . available ( ) ) < ( long ) length ) { if ( ! already Logged ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + length + STRING + available + STRING + binlog . get File Name ( ) + STRING ) ; } already Logged = BOOL ; } try { if ( spent Time < timeout In Ms ) { Thread . sleep ( NUM ) ; spent Time ++ ; } else throw new My SQL Extract Exception ( STRING + timeout + STRING + length + STRING ) ; } catch ( Interrupted Exception e ) { } } binlog . read ( data , offset , length ) ; }
private static void read Data From Binlog ( Replicator Runtime runtime , Binlog Reader binlog , byte [ ] data , int offset , int length , int timeout ) throws IO Exception , Replicator Exception , Interrupted Exception { boolean already Logged = BOOL ; int spent Time = NUM ; int timeout In Ms = timeout * NUM ; long available ; while ( ( available = binlog . available ( ) ) < ( long ) length ) { if ( ! already Logged ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + length + STRING + available + STRING + binlog . get File Name ( ) + STRING ) ; } already Logged = BOOL ; } try { if ( spent Time < timeout In Ms ) { Thread . sleep ( NUM ) ; spent Time ++ ; } else throw new My SQL Extract Exception ( STRING + timeout + STRING + length + STRING ) ; } catch ( Interrupted Exception e ) { } } binlog . read ( data , offset , length ) ; }
private static void read Data From Binlog ( Replicator Runtime runtime , Binlog Reader binlog , byte [ ] data , int offset , int length , int timeout ) throws IO Exception , Replicator Exception , Interrupted Exception { boolean already Logged = BOOL ; int spent Time = NUM ; int timeout In Ms = timeout * NUM ; long available ; while ( ( available = binlog . available ( ) ) < ( long ) length ) { if ( ! already Logged ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + length + STRING + available + STRING + binlog . get File Name ( ) + STRING ) ; } already Logged = BOOL ; } try { if ( spent Time < timeout In Ms ) { Thread . sleep ( NUM ) ; spent Time ++ ; } else throw new My SQL Extract Exception ( STRING + timeout + STRING + length + STRING ) ; } catch ( Interrupted Exception e ) { } } binlog . read ( data , offset , length ) ; }
private void fail ( String prefix , String message , Iterable < ? extends Throwable > errors ) { Assertion Error ae = new Assertion Error ( prefix + message ) ; Composite Exception ce = new Composite Exception ( ) ; for ( Throwable e : errors ) { if ( e == null ) { ce . add Suppressed ( new Null Pointer Exception ( STRING ) ) ; } else { ce . add Suppressed ( e ) ; } } ae . init Cause ( ce ) ; is Passing = BOOL ; }
private void fail ( String prefix , String message , Iterable < ? extends Throwable > errors ) { Assertion Error ae = new Assertion Error ( prefix + message ) ; Composite Exception ce = new Composite Exception ( ) ; for ( Throwable e : errors ) { if ( e == null ) { ce . add Suppressed ( new Null Pointer Exception ( STRING ) ) ; } else { ce . add Suppressed ( e ) ; } } ae . init Cause ( ce ) ; is Passing = BOOL ; }
private void fail ( String prefix , String message , Iterable < ? extends Throwable > errors ) { Assertion Error ae = new Assertion Error ( prefix + message ) ; Composite Exception ce = new Composite Exception ( ) ; for ( Throwable e : errors ) { if ( e == null ) { ce . add Suppressed ( new Null Pointer Exception ( STRING ) ) ; } else { ce . add Suppressed ( e ) ; } } ae . init Cause ( ce ) ; is Passing = BOOL ; }
private void fail ( String prefix , String message , Iterable < ? extends Throwable > errors ) { Assertion Error ae = new Assertion Error ( prefix + message ) ; Composite Exception ce = new Composite Exception ( ) ; for ( Throwable e : errors ) { if ( e == null ) { ce . add Suppressed ( new Null Pointer Exception ( STRING ) ) ; } else { ce . add Suppressed ( e ) ; } } ae . init Cause ( ce ) ; is Passing = BOOL ; }
public void declare Dimension ( final int dimension Type , final int scale , final int pixelperscale , final int offset , final Long color Naming , final Long color Scale , final String name ) { this . scales [ dimension Type ] = Math . max ( NUM , scale ) ; this . pixels [ dimension Type ] = pixelperscale ; this . offsets [ dimension Type ] = offset ; this . colnames [ dimension Type ] = color Naming ; this . colscale [ dimension Type ] = color Scale ; this . tablenames [ dimension Type ] = name ; if ( ( dimension Type == DIMENSION LEFT ) || ( dimension Type == DIMENSION RIGHT ) ) { draw Vertical Scale ( ( dimension Type == DIMENSION LEFT ) , scale , pixelperscale , offset , color Naming , color Scale , name ) ; } if ( ( dimension Type == DIMENSION TOP ) || ( dimension Type == DIMENSION BOTTOM ) ) { draw Horizontal Scale ( ( dimension Type == DIMENSION TOP ) , scale , pixelperscale , offset , color Naming , color Scale , name ) ; } }
protected boolean postlexical Rules ( Element token , Allophone Set allophone Set ) { return BOOL ; }
protected boolean postlexical Rules ( Element token , Allophone Set allophone Set ) { return BOOL ; }
public static boolean some Permission Permanently Denied ( Object object , List < String > denied Permissions ) { for ( String denied Permission : denied Permissions ) { if ( permission Permanently Denied ( object , denied Permission ) ) { return BOOL ; } } return BOOL ; }
public static void globals Put All ( Template Hash Model hash Model , Set < String > in Ex Keys , Boolean include , Environment env ) throws Template Model Exception { vars Put All ( hash Model , in Ex Keys , include , new Global Ftl Var Handler ( env ) , env ) ; }
protected void add Source Code Remark ( Test Solution test Solution , Element element , String message Code , Evidence Element evidence Element ) { if ( evidence Element != null ) { Collection < Evidence Element > evidence Element List = new Array List < > ( ) ; evidence Element List . add ( evidence Element ) ; process Remark Service . add Source Code Remark On Element ( test Solution , element , message Code , evidence Element List ) ; } else { process Remark Service . add Source Code Remark On Element ( test Solution , element , message Code ) ; } }
protected void add Source Code Remark ( Test Solution test Solution , Element element , String message Code , Evidence Element evidence Element ) { if ( evidence Element != null ) { Collection < Evidence Element > evidence Element List = new Array List < > ( ) ; evidence Element List . add ( evidence Element ) ; process Remark Service . add Source Code Remark On Element ( test Solution , element , message Code , evidence Element List ) ; } else { process Remark Service . add Source Code Remark On Element ( test Solution , element , message Code ) ; } }
public String search ( ) throws Exception { execute Query ( ) ; return SUCCESS ; }
public void add Child ( Component child ) { components . add ( child ) ; child . set Parent ( this ) ; }
public static URI change Scheme ( URI bind Addr , String scheme ) throws URI Syntax Exception { return new URI ( scheme , bind Addr . get User Info ( ) , bind Addr . get Host ( ) , bind Addr . get Port ( ) , bind Addr . get Path ( ) , bind Addr . get Query ( ) , bind Addr . get Fragment ( ) ) ; }
public static URI change Scheme ( URI bind Addr , String scheme ) throws URI Syntax Exception { return new URI ( scheme , bind Addr . get User Info ( ) , bind Addr . get Host ( ) , bind Addr . get Port ( ) , bind Addr . get Path ( ) , bind Addr . get Query ( ) , bind Addr . get Fragment ( ) ) ; }
public synchronized void draw Map ( ) { last Draw Map Req = System . current Time Millis ( ) ; Swing Utilities . invoke Later ( draw Mapable ) ; }
public synchronized void draw Map ( ) { last Draw Map Req = System . current Time Millis ( ) ; Swing Utilities . invoke Later ( draw Mapable ) ; }
public void add Value ( int v ) { increment Value ( Long . value Of ( v ) , NUM ) ; }
void impl Reset ( ) { System . arraycopy ( initial Hashes , NUM , state , NUM , state . length ) ; }
private Un Managed Consistency Group create Un Managed CG ( String un Managed CG Native Guid , Xtrem IO Consistency Group consistency Group , URI storage System URI , Db Client db Client ) { Un Managed Consistency Group un Managed CG = new Un Managed Consistency Group ( ) ; un Managed CG . set Id ( URI Util . create Id ( Un Managed Consistency Group . class ) ) ; un Managed CG . set Label ( consistency Group . get Name ( ) ) ; un Managed CG . set Name ( consistency Group . get Name ( ) ) ; un Managed CG . set Native Guid ( un Managed CG Native Guid ) ; un Managed CG . set Storage System Uri ( storage System URI ) ; un Managed CG . set Number Of Vols ( consistency Group . get Num Of Vols ( ) ) ; db Client . create Object ( un Managed CG ) ; return un Managed CG ; }
private Un Managed Consistency Group create Un Managed CG ( String un Managed CG Native Guid , Xtrem IO Consistency Group consistency Group , URI storage System URI , Db Client db Client ) { Un Managed Consistency Group un Managed CG = new Un Managed Consistency Group ( ) ; un Managed CG . set Id ( URI Util . create Id ( Un Managed Consistency Group . class ) ) ; un Managed CG . set Label ( consistency Group . get Name ( ) ) ; un Managed CG . set Name ( consistency Group . get Name ( ) ) ; un Managed CG . set Native Guid ( un Managed CG Native Guid ) ; un Managed CG . set Storage System Uri ( storage System URI ) ; un Managed CG . set Number Of Vols ( consistency Group . get Num Of Vols ( ) ) ; db Client . create Object ( un Managed CG ) ; return un Managed CG ; }
public void start Element ( String uri , String name , String q Name , Attributes atts ) throws SAX Exception { if ( name . equals Ignore Case ( GML Constants . GML POLYGON ) ) { curr Geom Handler = new GML Handler ( fact , null ) ; } if ( curr Geom Handler != null ) curr Geom Handler . start Element ( uri , name , q Name , atts ) ; if ( curr Geom Handler == null ) { last Elt Name = name ; } }
public void start Element ( String uri , String name , String q Name , Attributes atts ) throws SAX Exception { if ( name . equals Ignore Case ( GML Constants . GML POLYGON ) ) { curr Geom Handler = new GML Handler ( fact , null ) ; } if ( curr Geom Handler != null ) curr Geom Handler . start Element ( uri , name , q Name , atts ) ; if ( curr Geom Handler == null ) { last Elt Name = name ; } }
public void start Element ( String uri , String name , String q Name , Attributes atts ) throws SAX Exception { if ( name . equals Ignore Case ( GML Constants . GML POLYGON ) ) { curr Geom Handler = new GML Handler ( fact , null ) ; } if ( curr Geom Handler != null ) curr Geom Handler . start Element ( uri , name , q Name , atts ) ; if ( curr Geom Handler == null ) { last Elt Name = name ; } }
private boolean init Event Cursor ( ) { if ( ( m Event Cursor == null ) || ( m Event Cursor . get Count ( ) == NUM ) ) { return BOOL ; } m Event Cursor . move To First ( ) ; m Event Id = m Event Cursor . get Int ( EVENT INDEX ID ) ; String r Rule = m Event Cursor . get String ( EVENT INDEX RRULE ) ; m Is Repeating = ! Text Utils . is Empty ( r Rule ) ; m Has Alarm = ( m Event Cursor . get Int ( EVENT INDEX HAS ALARM ) == NUM ) ? BOOL : ( m Reminders != null && m Reminders . size ( ) > NUM ) ; m Max Reminders = m Event Cursor . get Int ( EVENT INDEX MAX REMINDERS ) ; m Calendar Allowed Reminders = m Event Cursor . get String ( EVENT INDEX ALLOWED REMINDERS ) ; return BOOL ; }
public void add ( Gondola gondola ) { extras . add ( gondola ) ; }
public void add ( Gondola gondola ) { extras . add ( gondola ) ; }
public void add ( Gondola gondola ) { extras . add ( gondola ) ; }
public void add ( Gondola gondola ) { extras . add ( gondola ) ; }
private String split Name Without Gzip Extension ( String split ) throws IO Exception { if ( split == null ) { throw new IO Exception ( STRING ) ; } if ( split . ends With ( STRING ) ) { return split . substring ( NUM , split . length ( ) - NUM ) ; } return split ; }
private String split Name Without Gzip Extension ( String split ) throws IO Exception { if ( split == null ) { throw new IO Exception ( STRING ) ; } if ( split . ends With ( STRING ) ) { return split . substring ( NUM , split . length ( ) - NUM ) ; } return split ; }
private String split Name Without Gzip Extension ( String split ) throws IO Exception { if ( split == null ) { throw new IO Exception ( STRING ) ; } if ( split . ends With ( STRING ) ) { return split . substring ( NUM , split . length ( ) - NUM ) ; } return split ; }
private String split Name Without Gzip Extension ( String split ) throws IO Exception { if ( split == null ) { throw new IO Exception ( STRING ) ; } if ( split . ends With ( STRING ) ) { return split . substring ( NUM , split . length ( ) - NUM ) ; } return split ; }
private String split Name Without Gzip Extension ( String split ) throws IO Exception { if ( split == null ) { throw new IO Exception ( STRING ) ; } if ( split . ends With ( STRING ) ) { return split . substring ( NUM , split . length ( ) - NUM ) ; } return split ; }
private void read Header ( ) throws IO Exception { byte [ ] signature Bytes = new byte [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) signature Bytes [ i ] = plog Stream . read Byte ( ) ; String stringified Header = new String ( signature Bytes , STRING ) ; if ( ! stringified Header . equals ( STRING ) ) { throw new IO Exception ( STRING ) ; } int major file version = read Swapped Integer ( plog Stream ) ; int minor file version = read Swapped Integer ( plog Stream ) ; if ( major file version != NUM || minor file version != NUM ) { throw new IO Exception ( STRING + major file version + STRING + minor file version + STRING ) ; } logger . info ( STRING ) ; return ; }
private void read Header ( ) throws IO Exception { byte [ ] signature Bytes = new byte [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) signature Bytes [ i ] = plog Stream . read Byte ( ) ; String stringified Header = new String ( signature Bytes , STRING ) ; if ( ! stringified Header . equals ( STRING ) ) { throw new IO Exception ( STRING ) ; } int major file version = read Swapped Integer ( plog Stream ) ; int minor file version = read Swapped Integer ( plog Stream ) ; if ( major file version != NUM || minor file version != NUM ) { throw new IO Exception ( STRING + major file version + STRING + minor file version + STRING ) ; } logger . info ( STRING ) ; return ; }
public Request cookie ( String key , String value ) { Objects . require Non Null ( key ) ; Objects . require Non Null ( value ) ; cookies . put ( key , value ) ; return this ; }
public static Network Info from Friendly Name ( final String friendly Name ) { switch ( friendly Name ) { case STRING : return Network Infos . get Main Network Info ( ) ; case STRING : return Network Infos . get Test Network Info ( ) ; case STRING : return Network Infos . get Mijin Network Info ( ) ; } throw new Illegal Argument Exception ( String . format ( STRING , friendly Name ) ) ; }
public Object 2 Int Open Hash Map < int [ ] > support Map ( ) { List < Item Set > item Sets = learn ( ) ; Object 2 Int Open Hash Map < int [ ] > confidence Map = new Object 2 Int Open Hash Map < > ( item Sets . size ( ) ) ; for ( Item Set item Set : item Sets ) { confidence Map . put ( item Set . items , item Set . support ) ; } return confidence Map ; }
public Object 2 Int Open Hash Map < int [ ] > support Map ( ) { List < Item Set > item Sets = learn ( ) ; Object 2 Int Open Hash Map < int [ ] > confidence Map = new Object 2 Int Open Hash Map < > ( item Sets . size ( ) ) ; for ( Item Set item Set : item Sets ) { confidence Map . put ( item Set . items , item Set . support ) ; } return confidence Map ; }
public Object 2 Int Open Hash Map < int [ ] > support Map ( ) { List < Item Set > item Sets = learn ( ) ; Object 2 Int Open Hash Map < int [ ] > confidence Map = new Object 2 Int Open Hash Map < > ( item Sets . size ( ) ) ; for ( Item Set item Set : item Sets ) { confidence Map . put ( item Set . items , item Set . support ) ; } return confidence Map ; }
public Object 2 Int Open Hash Map < int [ ] > support Map ( ) { List < Item Set > item Sets = learn ( ) ; Object 2 Int Open Hash Map < int [ ] > confidence Map = new Object 2 Int Open Hash Map < > ( item Sets . size ( ) ) ; for ( Item Set item Set : item Sets ) { confidence Map . put ( item Set . items , item Set . support ) ; } return confidence Map ; }
public Object 2 Int Open Hash Map < int [ ] > support Map ( ) { List < Item Set > item Sets = learn ( ) ; Object 2 Int Open Hash Map < int [ ] > confidence Map = new Object 2 Int Open Hash Map < > ( item Sets . size ( ) ) ; for ( Item Set item Set : item Sets ) { confidence Map . put ( item Set . items , item Set . support ) ; } return confidence Map ; }
public void simulate Method ( Soot Method method , Reference Variable this Var , Reference Variable return Var , Reference Variable params [ ] ) { String sub Signature = method . get Sub Signature ( ) ; if ( sub Signature . equals ( STRING ) ) { java lang Runtime exec Internal ( method , this Var , return Var , params ) ; return ; } else { default Method ( method , this Var , return Var , params ) ; return ; } }
public void simulate Method ( Soot Method method , Reference Variable this Var , Reference Variable return Var , Reference Variable params [ ] ) { String sub Signature = method . get Sub Signature ( ) ; if ( sub Signature . equals ( STRING ) ) { java lang Runtime exec Internal ( method , this Var , return Var , params ) ; return ; } else { default Method ( method , this Var , return Var , params ) ; return ; } }
public void notify Developers ( String subject , String message ) throws J Plag Exception { Node List user List = root Element . get Elements By Tag Name ( STRING ) ; for ( int i = NUM ; i < user List . get Length ( ) ; i ++ ) { Element elem = ( Element ) user List . item ( i ) ; if ( ( parse Int ( elem , STRING ) & MASK DEVELOPER ) != NUM ) send Mail ( elem . get Attribute ( STRING ) , subject , message ) ; } }
private Logical Metric extract Metric ( Matcher tokenized Query , Metric Dictionary metric Dictionary ) throws Bad Having Exception { String metric Name = tokenized Query . group ( NUM ) ; Logical Metric extracted Metric = metric Dictionary . get ( metric Name ) ; if ( extracted Metric == null ) { LOG . debug ( HAVING METRIC UNDEFINED . log Format ( metric Name ) ) ; throw new Bad Having Exception ( HAVING METRIC UNDEFINED . log Format ( metric Name ) ) ; } return extracted Metric ; }
public static void wait For Process Output ( Process self , Appendable output , Appendable error ) { Thread tout = consume Process Output Stream ( self , output ) ; Thread terr = consume Process Error Stream ( self , error ) ; try { tout . join ( ) ; } catch ( Interrupted Exception ignore ) { } try { terr . join ( ) ; } catch ( Interrupted Exception ignore ) { } try { self . wait For ( ) ; } catch ( Interrupted Exception ignore ) { } close Streams ( self ) ; }
public static void wait For Process Output ( Process self , Appendable output , Appendable error ) { Thread tout = consume Process Output Stream ( self , output ) ; Thread terr = consume Process Error Stream ( self , error ) ; try { tout . join ( ) ; } catch ( Interrupted Exception ignore ) { } try { terr . join ( ) ; } catch ( Interrupted Exception ignore ) { } try { self . wait For ( ) ; } catch ( Interrupted Exception ignore ) { } close Streams ( self ) ; }
public static void wait For Process Output ( Process self , Appendable output , Appendable error ) { Thread tout = consume Process Output Stream ( self , output ) ; Thread terr = consume Process Error Stream ( self , error ) ; try { tout . join ( ) ; } catch ( Interrupted Exception ignore ) { } try { terr . join ( ) ; } catch ( Interrupted Exception ignore ) { } try { self . wait For ( ) ; } catch ( Interrupted Exception ignore ) { } close Streams ( self ) ; }
public static void wait For Process Output ( Process self , Appendable output , Appendable error ) { Thread tout = consume Process Output Stream ( self , output ) ; Thread terr = consume Process Error Stream ( self , error ) ; try { tout . join ( ) ; } catch ( Interrupted Exception ignore ) { } try { terr . join ( ) ; } catch ( Interrupted Exception ignore ) { } try { self . wait For ( ) ; } catch ( Interrupted Exception ignore ) { } close Streams ( self ) ; }
public static void wait For Process Output ( Process self , Appendable output , Appendable error ) { Thread tout = consume Process Output Stream ( self , output ) ; Thread terr = consume Process Error Stream ( self , error ) ; try { tout . join ( ) ; } catch ( Interrupted Exception ignore ) { } try { terr . join ( ) ; } catch ( Interrupted Exception ignore ) { } try { self . wait For ( ) ; } catch ( Interrupted Exception ignore ) { } close Streams ( self ) ; }
public static void wait For Process Output ( Process self , Appendable output , Appendable error ) { Thread tout = consume Process Output Stream ( self , output ) ; Thread terr = consume Process Error Stream ( self , error ) ; try { tout . join ( ) ; } catch ( Interrupted Exception ignore ) { } try { terr . join ( ) ; } catch ( Interrupted Exception ignore ) { } try { self . wait For ( ) ; } catch ( Interrupted Exception ignore ) { } close Streams ( self ) ; }
@ Request Mapping ( value = STRING , method = Request Method . GET ) public String update All Podcasts ( Model Map model ) { LOG . debug ( STRING ) ; Integer number Of Worker Threads = Integer . value Of ( config Bean . get ( STRING ) ) ; if ( number Of Worker Threads == null ) { number Of Worker Threads = DEFAULT NO WORKER THREADS FOR UPDATE ALL PODCASTS ; } Integer total Number Of Podcasts = read Service . get Number Of Podcasts ( ) ; Integer mod = total Number Of Podcasts % number Of Worker Threads ; Integer chunk Size = total Number Of Podcasts / number Of Worker Threads ; for ( int i = NUM ; i < number Of Worker Threads ; i ++ ) { int start Row = i * chunk Size ; if ( i == number Of Worker Threads - NUM ) { chunk Size = chunk Size + mod ; LOG . debug ( STRING + i + STRING + start Row + STRING + chunk Size + STRING ) ; Future < String > future = batch Update Service . update Podcasts From Range ( start Row , chunk Size ) ; } else { LOG . debug ( STRING + i + STRING + start Row + STRING + chunk Size + STRING ) ; batch Update Service . update Podcasts From Range ( start Row , chunk Size ) ; } } rest Client . invoke Refresh All Caches ( ) ; return STRING ; }
private void capture Different Set ( Set < String > old Set , Set < String > new Set , Map < String , Set < String > > map , String app Name ) { Reject . if Null ( app Name ) ; Reject . if Null ( map ) ; if ( old Set == null && new Set == null ) { map . put ( app Name , Collections . < String > empty Set ( ) ) ; } else if ( new Set != null && ! new Set . equals ( old Set ) ) { map . put ( app Name , new Set ) ; } }
@ Suppress Warnings ( STRING ) public static Abstract Literal IV create Inline IV ( final Big Integer value ) { if ( value . compare To ( MAX UNSIGNED LONG AS BIGINT ) >= NUM ) { return new XSD Integer IV ( value ) ; } return create Inline IV ( value . long Value ( ) ) ; }
@ Suppress Warnings ( STRING ) public static Abstract Literal IV create Inline IV ( final Big Integer value ) { if ( value . compare To ( MAX UNSIGNED LONG AS BIGINT ) >= NUM ) { return new XSD Integer IV ( value ) ; } return create Inline IV ( value . long Value ( ) ) ; }
@ Suppress Warnings ( STRING ) public static Abstract Literal IV create Inline IV ( final Big Integer value ) { if ( value . compare To ( MAX UNSIGNED LONG AS BIGINT ) >= NUM ) { return new XSD Integer IV ( value ) ; } return create Inline IV ( value . long Value ( ) ) ; }
public String to XML String ( boolean include NS , boolean declare NS ) throws FS Msg Exception { return to XML String ( include NS , declare NS , BOOL ) ; }
public String to XML String ( boolean include NS , boolean declare NS ) throws FS Msg Exception { return to XML String ( include NS , declare NS , BOOL ) ; }
public String to XML String ( boolean include NS , boolean declare NS ) throws FS Msg Exception { return to XML String ( include NS , declare NS , BOOL ) ; }
public Http Request ( Method method , Http URI uri ) { this ( method , uri , BOOL ) ; }
public void on Wifi Connectivity Changed ( boolean connected , final String network Ssid ) { LOGD ( TAG , STRING + ( connected ? STRING : STRING ) ) ; if ( connected && ! m Wifi Connectivity ) { m Wifi Connectivity = BOOL ; if ( m Cast Manager . is Feature Enabled ( Base Cast Manager . FEATURE WIFI RECONNECT ) ) { m Cast Manager . start Cast Discovery ( ) ; m Cast Manager . reconnect Session If Possible ( RECONNECTION ATTEMPT PERIOD S , network Ssid ) ; } } else { m Wifi Connectivity = connected ; } }
public void on Wifi Connectivity Changed ( boolean connected , final String network Ssid ) { LOGD ( TAG , STRING + ( connected ? STRING : STRING ) ) ; if ( connected && ! m Wifi Connectivity ) { m Wifi Connectivity = BOOL ; if ( m Cast Manager . is Feature Enabled ( Base Cast Manager . FEATURE WIFI RECONNECT ) ) { m Cast Manager . start Cast Discovery ( ) ; m Cast Manager . reconnect Session If Possible ( RECONNECTION ATTEMPT PERIOD S , network Ssid ) ; } } else { m Wifi Connectivity = connected ; } }
public static < T1 , T2 > void for Each In Both ( List < T1 > list 1 , List < T2 > list 2 , Procedure 2 < ? super T1 , ? super T2 > procedure ) { if ( list 1 != null && list 2 != null ) { if ( list 1 . size ( ) == list 2 . size ( ) ) { if ( list 1 instanceof Random Access && list 2 instanceof Random Access ) { Random Access List Iterate . for Each In Both ( list 1 , list 2 , procedure ) ; } else { Iterator < T1 > iterator 1 = list 1 . iterator ( ) ; Iterator < T2 > iterator 2 = list 2 . iterator ( ) ; int size = list 2 . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) { procedure . value ( iterator 1 . next ( ) , iterator 2 . next ( ) ) ; } } } else { throw new Runtime Exception ( STRING + list 1 . size ( ) + STRING + list 2 . size ( ) ) ; } } }
public Log Stream print ( long l ) { if ( ps != null ) { indent ( ) ; line Buffer . append ( l ) ; } return this ; }
public void update Locations ( Iterator i Iter ) { if ( Container List != null ) Container List . clear ( ) ; Container List = new Array List ( ) ; while ( i Iter . has Next ( ) ) Container List . add ( ( Location ) i Iter . next ( ) ) ; add Behaviour ( new Migrate Behaviour ( ) ) ; }
private void add ( Annotate Block a Block ) { int size = blocks . size ( ) ; if ( size == NUM ) { blocks . add ( a Block ) ; } else { Annotate Block last Block = ( Annotate Block ) blocks . get ( size - NUM ) ; if ( last Block . get Revision ( ) == a Block . get Revision ( ) ) { last Block . set End Line ( a Block . get Start Line ( ) ) ; } else { blocks . add ( a Block ) ; } } }
private void add ( Annotate Block a Block ) { int size = blocks . size ( ) ; if ( size == NUM ) { blocks . add ( a Block ) ; } else { Annotate Block last Block = ( Annotate Block ) blocks . get ( size - NUM ) ; if ( last Block . get Revision ( ) == a Block . get Revision ( ) ) { last Block . set End Line ( a Block . get Start Line ( ) ) ; } else { blocks . add ( a Block ) ; } } }
private void add ( Annotate Block a Block ) { int size = blocks . size ( ) ; if ( size == NUM ) { blocks . add ( a Block ) ; } else { Annotate Block last Block = ( Annotate Block ) blocks . get ( size - NUM ) ; if ( last Block . get Revision ( ) == a Block . get Revision ( ) ) { last Block . set End Line ( a Block . get Start Line ( ) ) ; } else { blocks . add ( a Block ) ; } } }
public void add Watcher ( Angular Object Watcher watcher ) { synchronized ( watchers ) { watchers . add ( watcher ) ; } }
protected boolean exists In Range ( String x , int min Length , int max Length ) { x = String Utils . trim To Null ( x ) ; return x != null && x . length ( ) >= min Length && x . length ( ) <= max Length ; }
protected boolean exists In Range ( String x , int min Length , int max Length ) { x = String Utils . trim To Null ( x ) ; return x != null && x . length ( ) >= min Length && x . length ( ) <= max Length ; }
public byte [ ] decode ( String s ) { byte [ ] b = new byte [ ( s . length ( ) / NUM ) * NUM ] ; int cycle = NUM ; int combined = NUM ; int j = NUM ; int len = s . length ( ) ; int dummies = NUM ; for ( int i = NUM ; i < len ; i ++ ) { int c = s . char At ( i ) ; int value = ( c <= NUM ) ? char To Value [ c ] : IGNORE ; switch ( value ) { case IGNORE : break ; case PAD : value = NUM ; dummies ++ ; default : switch ( cycle ) { case NUM : combined = value ; cycle = NUM ; break ; case NUM : combined <<= NUM ; combined |= value ; cycle = NUM ; break ; case NUM : combined <<= NUM ; combined |= value ; cycle = NUM ; break ; case NUM : combined <<= NUM ; combined |= value ; b [ j + NUM ] = ( byte ) combined ; combined >>>= NUM ; b [ j + NUM ] = ( byte ) combined ; combined >>>= NUM ; b [ j ] = ( byte ) combined ; j += NUM ; cycle = NUM ; break ; } break ; } } if ( cycle != NUM ) { throw new Array Index Out Of Bounds Exception ( STRING ) ; } j -= dummies ; if ( b . length != j ) { byte [ ] b2 = new byte [ j ] ; System . arraycopy ( b , NUM , b2 , NUM , j ) ; b = b2 ; } return b ; }
public static boolean valid System Name Config ( String system Name , char type , Serial Traffic Controller tc ) { if ( ! valid System Name Format ( system Name , type ) ) { return BOOL ; } Serial Node node = ( Serial Node ) get Node From System Name ( system Name , tc ) ; if ( node == null ) { return BOOL ; } int bit = get Bit From System Name ( system Name ) ; if ( ( type == STRING ) || ( type == STRING ) ) { if ( ( bit <= NUM ) || ( bit > ( node . num Output Cards ( ) * node . get Num Bits Per Card ( ) ) ) ) { return BOOL ; } } else if ( type == STRING ) { if ( ( bit <= NUM ) || ( bit > ( node . num Input Cards ( ) * node . get Num Bits Per Card ( ) ) ) ) { return BOOL ; } } else { log . error ( STRING ) ; return BOOL ; } return BOOL ; }
public static boolean valid System Name Config ( String system Name , char type , Serial Traffic Controller tc ) { if ( ! valid System Name Format ( system Name , type ) ) { return BOOL ; } Serial Node node = ( Serial Node ) get Node From System Name ( system Name , tc ) ; if ( node == null ) { return BOOL ; } int bit = get Bit From System Name ( system Name ) ; if ( ( type == STRING ) || ( type == STRING ) ) { if ( ( bit <= NUM ) || ( bit > ( node . num Output Cards ( ) * node . get Num Bits Per Card ( ) ) ) ) { return BOOL ; } } else if ( type == STRING ) { if ( ( bit <= NUM ) || ( bit > ( node . num Input Cards ( ) * node . get Num Bits Per Card ( ) ) ) ) { return BOOL ; } } else { log . error ( STRING ) ; return BOOL ; } return BOOL ; }
public static boolean valid System Name Config ( String system Name , char type , Serial Traffic Controller tc ) { if ( ! valid System Name Format ( system Name , type ) ) { return BOOL ; } Serial Node node = ( Serial Node ) get Node From System Name ( system Name , tc ) ; if ( node == null ) { return BOOL ; } int bit = get Bit From System Name ( system Name ) ; if ( ( type == STRING ) || ( type == STRING ) ) { if ( ( bit <= NUM ) || ( bit > ( node . num Output Cards ( ) * node . get Num Bits Per Card ( ) ) ) ) { return BOOL ; } } else if ( type == STRING ) { if ( ( bit <= NUM ) || ( bit > ( node . num Input Cards ( ) * node . get Num Bits Per Card ( ) ) ) ) { return BOOL ; } } else { log . error ( STRING ) ; return BOOL ; } return BOOL ; }
private static File stream 2 file ( Input Stream in , String suffix ) throws IO Exception { final File temp File = File . create Temp File ( PREFIX , suffix ) ; try ( File Output Stream out = new File Output Stream ( temp File ) ) { IO Utils . copy ( in , out ) ; } return temp File ; }
public static boolean has Token File ( File token File ) throws IO Exception { return has Token ( token File . get Parent File ( ) , token File . get Name ( ) ) ; }
public static boolean has Token File ( File token File ) throws IO Exception { return has Token ( token File . get Parent File ( ) , token File . get Name ( ) ) ; }
public synchronized void resize Matrix ( int newsize ) throws IO Exception { if ( newsize >= NUM ) { throw new Runtime Exception ( STRING ) ; } if ( ! array . is Writable ( ) ) { throw new IO Exception ( STRING ) ; } array . resize File ( arraysize ( newsize ) ) ; this . matrixsize = newsize ; Byte Buffer header = array . get Extra Header ( ) ; header . put Int ( this . matrixsize ) ; }
public synchronized void resize Matrix ( int newsize ) throws IO Exception { if ( newsize >= NUM ) { throw new Runtime Exception ( STRING ) ; } if ( ! array . is Writable ( ) ) { throw new IO Exception ( STRING ) ; } array . resize File ( arraysize ( newsize ) ) ; this . matrixsize = newsize ; Byte Buffer header = array . get Extra Header ( ) ; header . put Int ( this . matrixsize ) ; }
public static String decode Charset ( String s , String charset ) { if ( s == null ) { return null ; } try { byte buf [ ] = s . get Bytes ( ASCII CHARSET ) ; return ( new String ( buf , NUM , buf . length , charset ) ) ; } catch ( Unsupported Encoding Exception uee ) { return s ; } }
public void adjust ( Collection < Map Node > nodes ) { for ( Map Node node : nodes ) { if ( Float . is Na N ( lat Min ) ) { lat Min = lat Max = node . get Lat ( ) ; lon Min = lon Max = node . get Lon ( ) ; } else if ( node . has Position ( ) ) { if ( node . get Lat ( ) < lat Min ) lat Min = node . get Lat ( ) ; else if ( node . get Lat ( ) > lat Max ) lat Max = node . get Lat ( ) ; if ( node . get Lon ( ) < lon Min ) lon Min = node . get Lon ( ) ; else if ( node . get Lon ( ) > lon Max ) lon Max = node . get Lon ( ) ; } } }
public void adjust ( Collection < Map Node > nodes ) { for ( Map Node node : nodes ) { if ( Float . is Na N ( lat Min ) ) { lat Min = lat Max = node . get Lat ( ) ; lon Min = lon Max = node . get Lon ( ) ; } else if ( node . has Position ( ) ) { if ( node . get Lat ( ) < lat Min ) lat Min = node . get Lat ( ) ; else if ( node . get Lat ( ) > lat Max ) lat Max = node . get Lat ( ) ; if ( node . get Lon ( ) < lon Min ) lon Min = node . get Lon ( ) ; else if ( node . get Lon ( ) > lon Max ) lon Max = node . get Lon ( ) ; } } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( sem Ims == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( sem Ims == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( sem Ims == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( sem Ims == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( sem Ims == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( sem Ims == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( sem Ims == null ) { throw new Null Pointer Exception ( ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( sem Ims == null ) { throw new Null Pointer Exception ( ) ; } }
public void start Entity ( String name , XML Resource Identifier identifier , String encoding , Augmentations augs ) throws XNI Exception { if ( f Entity Depth == f Entity Stack . length ) { int [ ] entityarray = new int [ f Entity Stack . length * NUM ] ; System . arraycopy ( f Entity Stack , NUM , entityarray , NUM , f Entity Stack . length ) ; f Entity Stack = entityarray ; } f Entity Stack [ f Entity Depth ] = f Markup Depth ; super . start Entity ( name , identifier , encoding , augs ) ; if ( f Standalone && f Entity Manager . is Entity Decl In External Subset ( name ) ) { report Fatal Error ( STRING , new Object [ ] { name } ) ; } if ( f Document Handler != null && ! f Scanning Attribute ) { if ( ! name . equals ( STRING ) ) { f Document Handler . start General Entity ( name , identifier , encoding , augs ) ; } } }
public void start Entity ( String name , XML Resource Identifier identifier , String encoding , Augmentations augs ) throws XNI Exception { if ( f Entity Depth == f Entity Stack . length ) { int [ ] entityarray = new int [ f Entity Stack . length * NUM ] ; System . arraycopy ( f Entity Stack , NUM , entityarray , NUM , f Entity Stack . length ) ; f Entity Stack = entityarray ; } f Entity Stack [ f Entity Depth ] = f Markup Depth ; super . start Entity ( name , identifier , encoding , augs ) ; if ( f Standalone && f Entity Manager . is Entity Decl In External Subset ( name ) ) { report Fatal Error ( STRING , new Object [ ] { name } ) ; } if ( f Document Handler != null && ! f Scanning Attribute ) { if ( ! name . equals ( STRING ) ) { f Document Handler . start General Entity ( name , identifier , encoding , augs ) ; } } }
public void start Entity ( String name , XML Resource Identifier identifier , String encoding , Augmentations augs ) throws XNI Exception { if ( f Entity Depth == f Entity Stack . length ) { int [ ] entityarray = new int [ f Entity Stack . length * NUM ] ; System . arraycopy ( f Entity Stack , NUM , entityarray , NUM , f Entity Stack . length ) ; f Entity Stack = entityarray ; } f Entity Stack [ f Entity Depth ] = f Markup Depth ; super . start Entity ( name , identifier , encoding , augs ) ; if ( f Standalone && f Entity Manager . is Entity Decl In External Subset ( name ) ) { report Fatal Error ( STRING , new Object [ ] { name } ) ; } if ( f Document Handler != null && ! f Scanning Attribute ) { if ( ! name . equals ( STRING ) ) { f Document Handler . start General Entity ( name , identifier , encoding , augs ) ; } } }
public synchronized void add ( final Class Loader class Loader ) { cleanup ( ) ; if ( class Loader != null ) { add Internal ( class Loader ) ; } }
private static J List < String > create File List ( List < String > file Names ) { J List < String > file List = new J List < String > ( file Names . to Array ( new String [ NUM ] ) ) ; file List . set Visible Row Count ( NUM ) ; file List . set Cell Renderer ( new File Name List Cell Renderer ( ) ) ; file List . set Focusable ( BOOL ) ; return file List ; }
private static J List < String > create File List ( List < String > file Names ) { J List < String > file List = new J List < String > ( file Names . to Array ( new String [ NUM ] ) ) ; file List . set Visible Row Count ( NUM ) ; file List . set Cell Renderer ( new File Name List Cell Renderer ( ) ) ; file List . set Focusable ( BOOL ) ; return file List ; }
private void update Min Max ( Instance instance ) { for ( int j = NUM ; j < m instances . num Attributes ( ) ; j ++ ) { if ( ! instance . is Missing ( j ) ) { if ( Double . is Na N ( m Min [ j ] ) ) { m Min [ j ] = instance . value ( j ) ; m Max [ j ] = instance . value ( j ) ; } else if ( instance . value ( j ) < m Min [ j ] ) { m Min [ j ] = instance . value ( j ) ; } else if ( instance . value ( j ) > m Max [ j ] ) { m Max [ j ] = instance . value ( j ) ; } } } }
public Chain Iterable < T > add Item ( @ Not Null T item ) { return ( Chain Iterable < T > ) super . add ( Collections . < T > singleton ( item ) ) ; }
public boolean is Pronounceable ( String word ) { String lower Case Word = word . to Lower Case ( ) ; return ( prefix FSM . accept ( lower Case Word ) && suffix FSM . accept ( lower Case Word ) ) ; }
public boolean is Pronounceable ( String word ) { String lower Case Word = word . to Lower Case ( ) ; return ( prefix FSM . accept ( lower Case Word ) && suffix FSM . accept ( lower Case Word ) ) ; }
public void generate Search Page ( List < Api Service > services ) { List < Api Method > all Methods = new Array List < Api Method > ( ) ; for ( Api Service service : services ) { all Methods . add All ( service . methods ) ; } int key = NUM ; for ( Api Method method : all Methods ) { method . index Key = STRING + key ++ ; } Map < String , Object > parameters = new Hash Map < String , Object > ( ) ; parameters . put ( STRING , all Methods ) ; parameters . put ( STRING , STRING ) ; add Common Template Parameters ( parameters ) ; Template Engine . generate File From Template ( Known Paths . get Template File ( SEARCH TEMPLATE ) , Known Paths . get Html Output File ( SEARCH TEMPLATE ) , parameters ) ; }
void update ( long time , int rows ) { count ++ ; execution Time Min = Math . min ( time , execution Time Min ) ; execution Time Max = Math . max ( time , execution Time Max ) ; row Count Min = Math . min ( rows , row Count Min ) ; row Count Max = Math . max ( rows , row Count Max ) ; double delta = rows - row Count Mean ; row Count Mean += delta / count ; row Count M 2 += delta * ( rows - row Count Mean ) ; delta = time - execution Time Mean ; execution Time Mean += delta / count ; execution Time M 2 += delta * ( time - execution Time Mean ) ; execution Time Cumulative += time ; row Count Cumulative += rows ; last Update Time = System . current Time Millis ( ) ; }
public boolean mark Time If Delay ( World world , long delay ) { if ( world == null ) { return BOOL ; } long current Time = world . get Total World Time ( ) ; if ( current Time < last Mark ) { last Mark = current Time ; return BOOL ; } else if ( last Mark + delay + last Random Delay <= current Time ) { duration = current Time - last Mark ; last Mark = current Time ; last Random Delay = ( int ) ( Math . random ( ) * random Range ) ; return BOOL ; } else { return BOOL ; } }
public boolean mark Time If Delay ( World world , long delay ) { if ( world == null ) { return BOOL ; } long current Time = world . get Total World Time ( ) ; if ( current Time < last Mark ) { last Mark = current Time ; return BOOL ; } else if ( last Mark + delay + last Random Delay <= current Time ) { duration = current Time - last Mark ; last Mark = current Time ; last Random Delay = ( int ) ( Math . random ( ) * random Range ) ; return BOOL ; } else { return BOOL ; } }
public void add Url Features ( Nutch Document doc , String url String ) { try { URL url = new URL ( url String ) ; String Tokenizer names = new String Tokenizer ( url . get Path ( ) , STRING ) ; if ( names . has More Tokens ( ) ) names . next Token ( ) ; while ( names . has More Tokens ( ) ) { String feature = names . next Token ( ) ; add Feature ( doc , feature ) ; } } catch ( Malformed URL Exception e ) { if ( LOG . is Warn Enabled ( ) ) { LOG . warn ( STRING + url String + STRING + e ) ; } } }
public void add Action With Accellerator Key ( GP Action action ) { if ( action != null ) { for ( Key Stroke ks : GP Action . get All Key Strokes ( action . get ID ( ) ) ) { add Action ( action , ks ) ; } } }
public static Output Catcher start ( ) { return new Output Catcher ( ) ; }
public Remover Manager track ( Remover remover ) { if ( handlers == null ) { handlers = new Array List < > ( ) ; } handlers . add ( remover ) ; return this ; }
public Remover Manager track ( Remover remover ) { if ( handlers == null ) { handlers = new Array List < > ( ) ; } handlers . add ( remover ) ; return this ; }
protected Boolean replay Completion ( Participant participant ) throws Illegal State Exception { if ( ! replay Stack . contains ( participant ) ) { replay Stack . push ( participant ) ; } return committed ; }
protected Boolean replay Completion ( Participant participant ) throws Illegal State Exception { if ( ! replay Stack . contains ( participant ) ) { replay Stack . push ( participant ) ; } return committed ; }
public long next ( long from Time ) { if ( get Current Count ( ) == NUM || from Time == NUM || from Time == start Date . get Time ( ) ) { return first ( ) ; } if ( Debug . verbose On ( ) ) { Debug . log Verbose ( STRING + ( r Date List == null ? NUM : r Date List . size ( ) ) , module ) ; Debug . log Verbose ( STRING + ( r Rules List == null ? NUM : r Rules List . size ( ) ) , module ) ; } if ( r Date List == null && r Rules List == null ) { return NUM ; } long next Rule Time = from Time ; boolean has Next = BOOL ; Iterator < Recurrence Rule > rules Iterator = get Recurrence Rule Iterator ( ) ; while ( rules Iterator . has Next ( ) ) { Recurrence Rule rule = rules Iterator . next ( ) ; while ( has Next ) { next Rule Time = get Next Time ( rule , next Rule Time ) ; if ( next Rule Time == NUM || is Valid ( next Rule Time ) ) { has Next = BOOL ; } } } return next Rule Time ; }
public void append ( int key , E value ) { if ( m Size != NUM && key <= m Keys [ m Size - NUM ] ) { put ( key , value ) ; return ; } if ( m Size >= m Keys . length && ( m Garbage || has Reclaimed Refs ( ) ) ) { gc ( ) ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n = Array Utils . ideal Int Array Size ( pos + NUM ) ; int [ ] nkeys = new int [ n ] ; Weak Reference < ? > [ ] nvalues = new Weak Reference [ n ] ; System . arraycopy ( m Keys , NUM , nkeys , NUM , m Keys . length ) ; System . arraycopy ( m Values , NUM , nvalues , NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = new Weak Reference ( value ) ; m Size = pos + NUM ; }
public void append ( int key , E value ) { if ( m Size != NUM && key <= m Keys [ m Size - NUM ] ) { put ( key , value ) ; return ; } if ( m Size >= m Keys . length && ( m Garbage || has Reclaimed Refs ( ) ) ) { gc ( ) ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n = Array Utils . ideal Int Array Size ( pos + NUM ) ; int [ ] nkeys = new int [ n ] ; Weak Reference < ? > [ ] nvalues = new Weak Reference [ n ] ; System . arraycopy ( m Keys , NUM , nkeys , NUM , m Keys . length ) ; System . arraycopy ( m Values , NUM , nvalues , NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = new Weak Reference ( value ) ; m Size = pos + NUM ; }
public void append ( int key , E value ) { if ( m Size != NUM && key <= m Keys [ m Size - NUM ] ) { put ( key , value ) ; return ; } if ( m Size >= m Keys . length && ( m Garbage || has Reclaimed Refs ( ) ) ) { gc ( ) ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n = Array Utils . ideal Int Array Size ( pos + NUM ) ; int [ ] nkeys = new int [ n ] ; Weak Reference < ? > [ ] nvalues = new Weak Reference [ n ] ; System . arraycopy ( m Keys , NUM , nkeys , NUM , m Keys . length ) ; System . arraycopy ( m Values , NUM , nvalues , NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = new Weak Reference ( value ) ; m Size = pos + NUM ; }
public void start ( ) { start = System . nano Time ( ) ; }
private static String read all ( final Input Stream is , final int buffer size ) { final char [ ] buffer = new char [ buffer size ] ; final String Builder out = new String Builder ( ) ; try { final Reader in = new Input Stream Reader ( is , STRING ) ; try { for ( ; ; ) { int rsz = in . read ( buffer , NUM , buffer . length ) ; if ( rsz < NUM ) break ; out . append ( buffer , NUM , rsz ) ; } } finally { in . close ( ) ; } } catch ( IO Exception ignored ) { } return out . to String ( ) ; }
public boolean contains ( T item ) { return data . contains ( item ) ; }
public boolean contains ( T item ) { return data . contains ( item ) ; }
public static void check Not Empty ( Collection collection ) { if ( collection . is Empty ( ) ) { throw new Null Pointer Exception ( ) ; } }
public Bindings add Opt Component ( String property , Class clazz , J Toggle Button c , boolean enabled By Default ) { Binding b = new Opt Component Binding ( this , property , clazz , c , enabled By Default ) ; if ( opt Components . contains Key ( property ) ) { throw new Binding Exception ( Messages . get String ( STRING ) ) ; } opt Components . put ( property , b ) ; return this ; }
public synchronized int file Exists ( JDBC Sequential File file ) throws SQL Exception { connection . set Auto Commit ( BOOL ) ; select File By File Name . set String ( NUM , file . get File Name ( ) ) ; try ( Result Set rs = select File By File Name . execute Query ( ) ) { int id = rs . next ( ) ? rs . get Int ( NUM ) : - NUM ; connection . commit ( ) ; return id ; } catch ( Exception e ) { connection . rollback ( ) ; throw e ; } }
public Hub Link Mapping ( String file Name , int number Of Hubs , Network network ) { this . number Of Hubs = number Of Hubs ; if ( file Name . contains ( STRING ) ) { read Mapping Table ( file Name ) ; un Mapped Links At Zero Hub = BOOL ; return ; } handle Unmapped Links Start ( ) ; try { File Reader fr = new File Reader ( file Name ) ; Buffered Reader br = new Buffered Reader ( fr ) ; String line ; String Tokenizer tokenizer ; String token ; int link Id ; line = br . read Line ( ) ; while ( line != null ) { tokenizer = new String Tokenizer ( line ) ; for ( int i = NUM ; i < this . number Of Hubs ; i ++ ) { token = tokenizer . next Token ( ) ; link Id = ( int ) Double . parse Double ( token ) ; link Hub Mapping . put ( Integer . to String ( link Id ) , i ) ; } if ( tokenizer . has More Tokens ( ) ) { throw new Runtime Exception ( STRING ) ; } line = br . read Line ( ) ; } } catch ( Runtime Exception e ) { throw e ; } catch ( Exception e ) { throw new Runtime Exception ( STRING ) ; } link Hub Mapping . remove ( STRING ) ; handle Unmapped Links End ( network ) ; }
public Hub Link Mapping ( String file Name , int number Of Hubs , Network network ) { this . number Of Hubs = number Of Hubs ; if ( file Name . contains ( STRING ) ) { read Mapping Table ( file Name ) ; un Mapped Links At Zero Hub = BOOL ; return ; } handle Unmapped Links Start ( ) ; try { File Reader fr = new File Reader ( file Name ) ; Buffered Reader br = new Buffered Reader ( fr ) ; String line ; String Tokenizer tokenizer ; String token ; int link Id ; line = br . read Line ( ) ; while ( line != null ) { tokenizer = new String Tokenizer ( line ) ; for ( int i = NUM ; i < this . number Of Hubs ; i ++ ) { token = tokenizer . next Token ( ) ; link Id = ( int ) Double . parse Double ( token ) ; link Hub Mapping . put ( Integer . to String ( link Id ) , i ) ; } if ( tokenizer . has More Tokens ( ) ) { throw new Runtime Exception ( STRING ) ; } line = br . read Line ( ) ; } } catch ( Runtime Exception e ) { throw e ; } catch ( Exception e ) { throw new Runtime Exception ( STRING ) ; } link Hub Mapping . remove ( STRING ) ; handle Unmapped Links End ( network ) ; }
public Hub Link Mapping ( String file Name , int number Of Hubs , Network network ) { this . number Of Hubs = number Of Hubs ; if ( file Name . contains ( STRING ) ) { read Mapping Table ( file Name ) ; un Mapped Links At Zero Hub = BOOL ; return ; } handle Unmapped Links Start ( ) ; try { File Reader fr = new File Reader ( file Name ) ; Buffered Reader br = new Buffered Reader ( fr ) ; String line ; String Tokenizer tokenizer ; String token ; int link Id ; line = br . read Line ( ) ; while ( line != null ) { tokenizer = new String Tokenizer ( line ) ; for ( int i = NUM ; i < this . number Of Hubs ; i ++ ) { token = tokenizer . next Token ( ) ; link Id = ( int ) Double . parse Double ( token ) ; link Hub Mapping . put ( Integer . to String ( link Id ) , i ) ; } if ( tokenizer . has More Tokens ( ) ) { throw new Runtime Exception ( STRING ) ; } line = br . read Line ( ) ; } } catch ( Runtime Exception e ) { throw e ; } catch ( Exception e ) { throw new Runtime Exception ( STRING ) ; } link Hub Mapping . remove ( STRING ) ; handle Unmapped Links End ( network ) ; }
void process Update Queue For Testing ( ) { while ( ! updates . is Empty ( ) ) { I Update update = updates . poll ( ) ; if ( update != null ) update . dispatch ( ) ; } }
void process Update Queue For Testing ( ) { while ( ! updates . is Empty ( ) ) { I Update update = updates . poll ( ) ; if ( update != null ) update . dispatch ( ) ; } }
void process Update Queue For Testing ( ) { while ( ! updates . is Empty ( ) ) { I Update update = updates . poll ( ) ; if ( update != null ) update . dispatch ( ) ; } }
void process Update Queue For Testing ( ) { while ( ! updates . is Empty ( ) ) { I Update update = updates . poll ( ) ; if ( update != null ) update . dispatch ( ) ; } }
public Data Set ( Array List < Entry > y Vals , int type ) { this . m Type = type ; this . mY Vals = y Vals ; if ( y Vals == null || y Vals . size ( ) <= NUM ) return ; calc Min Max ( ) ; calc Y Value Sum ( ) ; }
public boolean contains ( Song s ) { return m Songs . contains ( s ) ; }
public boolean contains ( Song s ) { return m Songs . contains ( s ) ; }
private void read Object ( Object Input Stream stream ) throws IO Exception { try { decode ( stream ) ; } catch ( Invalid Key Exception e ) { e . print Stack Trace ( ) ; throw new IO Exception ( STRING + e . get Message ( ) ) ; } }
private void convert Outer Join ( final String Builder target , final Char Sequence outer Join ) throws FBSQL Parse Exception { target . append ( outer Join ) ; }
private void convert Outer Join ( final String Builder target , final Char Sequence outer Join ) throws FBSQL Parse Exception { target . append ( outer Join ) ; }
private void convert Outer Join ( final String Builder target , final Char Sequence outer Join ) throws FBSQL Parse Exception { target . append ( outer Join ) ; }
private void convert Outer Join ( final String Builder target , final Char Sequence outer Join ) throws FBSQL Parse Exception { target . append ( outer Join ) ; }
public boolean clear ( T expect , boolean allow Reset ) { sync . lock ( ) ; try { if ( expect != value ) { return BOOL ; } Value State prev = state ; clear ( allow Reset ) ; return prev == Value State . SET ; } finally { sync . unlock ( ) ; } }
public boolean clear ( T expect , boolean allow Reset ) { sync . lock ( ) ; try { if ( expect != value ) { return BOOL ; } Value State prev = state ; clear ( allow Reset ) ; return prev == Value State . SET ; } finally { sync . unlock ( ) ; } }
public static < T > T median ( final Comparator < T > comparator , final T ... items ) { Validate . not Empty ( items , STRING ) ; Validate . no Null Elements ( items ) ; Validate . not Null ( comparator , STRING ) ; final Tree Set < T > sort = new Tree Set < T > ( comparator ) ; Collections . add All ( sort , items ) ; @ Suppress Warnings ( STRING ) final T result = ( T ) sort . to Array ( ) [ ( sort . size ( ) - NUM ) / NUM ] ; return result ; }
public static < T > T median ( final Comparator < T > comparator , final T ... items ) { Validate . not Empty ( items , STRING ) ; Validate . no Null Elements ( items ) ; Validate . not Null ( comparator , STRING ) ; final Tree Set < T > sort = new Tree Set < T > ( comparator ) ; Collections . add All ( sort , items ) ; @ Suppress Warnings ( STRING ) final T result = ( T ) sort . to Array ( ) [ ( sort . size ( ) - NUM ) / NUM ] ; return result ; }
public void lazy K Best Extract On HG ( Hyper Graph hg , int top N , Buffered Writer out ) throws IO Exception { reset State ( ) ; if ( null == hg . goal Node ) return ; for ( int k = NUM ; k <= top N ; k ++ ) { String hyp Str = get Kth Hyp ( hg . goal Node , k ) ; if ( null == hyp Str ) break ; out . write ( hyp Str ) ; out . write ( STRING ) ; out . flush ( ) ; } }
public void lazy K Best Extract On HG ( Hyper Graph hg , int top N , Buffered Writer out ) throws IO Exception { reset State ( ) ; if ( null == hg . goal Node ) return ; for ( int k = NUM ; k <= top N ; k ++ ) { String hyp Str = get Kth Hyp ( hg . goal Node , k ) ; if ( null == hyp Str ) break ; out . write ( hyp Str ) ; out . write ( STRING ) ; out . flush ( ) ; } }
public void lazy K Best Extract On HG ( Hyper Graph hg , int top N , Buffered Writer out ) throws IO Exception { reset State ( ) ; if ( null == hg . goal Node ) return ; for ( int k = NUM ; k <= top N ; k ++ ) { String hyp Str = get Kth Hyp ( hg . goal Node , k ) ; if ( null == hyp Str ) break ; out . write ( hyp Str ) ; out . write ( STRING ) ; out . flush ( ) ; } }
public void lazy K Best Extract On HG ( Hyper Graph hg , int top N , Buffered Writer out ) throws IO Exception { reset State ( ) ; if ( null == hg . goal Node ) return ; for ( int k = NUM ; k <= top N ; k ++ ) { String hyp Str = get Kth Hyp ( hg . goal Node , k ) ; if ( null == hyp Str ) break ; out . write ( hyp Str ) ; out . write ( STRING ) ; out . flush ( ) ; } }
public void lazy K Best Extract On HG ( Hyper Graph hg , int top N , Buffered Writer out ) throws IO Exception { reset State ( ) ; if ( null == hg . goal Node ) return ; for ( int k = NUM ; k <= top N ; k ++ ) { String hyp Str = get Kth Hyp ( hg . goal Node , k ) ; if ( null == hyp Str ) break ; out . write ( hyp Str ) ; out . write ( STRING ) ; out . flush ( ) ; } }
public void lazy K Best Extract On HG ( Hyper Graph hg , int top N , Buffered Writer out ) throws IO Exception { reset State ( ) ; if ( null == hg . goal Node ) return ; for ( int k = NUM ; k <= top N ; k ++ ) { String hyp Str = get Kth Hyp ( hg . goal Node , k ) ; if ( null == hyp Str ) break ; out . write ( hyp Str ) ; out . write ( STRING ) ; out . flush ( ) ; } }
public void lazy K Best Extract On HG ( Hyper Graph hg , int top N , Buffered Writer out ) throws IO Exception { reset State ( ) ; if ( null == hg . goal Node ) return ; for ( int k = NUM ; k <= top N ; k ++ ) { String hyp Str = get Kth Hyp ( hg . goal Node , k ) ; if ( null == hyp Str ) break ; out . write ( hyp Str ) ; out . write ( STRING ) ; out . flush ( ) ; } }
public void lazy K Best Extract On HG ( Hyper Graph hg , int top N , Buffered Writer out ) throws IO Exception { reset State ( ) ; if ( null == hg . goal Node ) return ; for ( int k = NUM ; k <= top N ; k ++ ) { String hyp Str = get Kth Hyp ( hg . goal Node , k ) ; if ( null == hyp Str ) break ; out . write ( hyp Str ) ; out . write ( STRING ) ; out . flush ( ) ; } }
private void add Characters ( final Map < String , RP Object > characters ) { for ( Entry < String , RP Object > character : characters . entry Set ( ) ) { J Button button = create Character Button ( character . get Key ( ) , character . get Value ( ) ) ; character Panel . add ( button ) ; } }
public void add Muted Ip ( final String ip ) { add Muted Ip ( ip , null ) ; }
public void add Muted Ip ( final String ip ) { add Muted Ip ( ip , null ) ; }
public D Export Private Key Pvk ( J Frame parent , String entry Alias , Private Key private Key , Password Quality Config password Quality Config ) { super ( parent , Dialog . Modality Type . DOCUMENT MODAL ) ; this . entry Alias = entry Alias ; this . private Key = private Key ; this . password Quality Config = password Quality Config ; init Components ( ) ; }
public static void stop Context ( Context ctx ) { synchronized ( active Contexts ) { active Contexts . remove ( ctx ) ; if ( active Contexts . is Empty ( ) ) { sync Deinitialize ( ) ; } else { if ( instance != null && get Activity ( ) != null ) { instance . deinitialize ( ) ; } } } }
public static void stop Context ( Context ctx ) { synchronized ( active Contexts ) { active Contexts . remove ( ctx ) ; if ( active Contexts . is Empty ( ) ) { sync Deinitialize ( ) ; } else { if ( instance != null && get Activity ( ) != null ) { instance . deinitialize ( ) ; } } } }
public static void stop Context ( Context ctx ) { synchronized ( active Contexts ) { active Contexts . remove ( ctx ) ; if ( active Contexts . is Empty ( ) ) { sync Deinitialize ( ) ; } else { if ( instance != null && get Activity ( ) != null ) { instance . deinitialize ( ) ; } } } }
static void pause Thread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { s logger . warn ( STRING , e ) ; } }
static void pause Thread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { s logger . warn ( STRING , e ) ; } }
static void pause Thread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { s logger . warn ( STRING , e ) ; } }
static void pause Thread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { s logger . warn ( STRING , e ) ; } }
static void pause Thread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { s logger . warn ( STRING , e ) ; } }
public C View Searcher Dialog ( final Window owner , final I View Container view Container , final I Address address ) { super ( owner , STRING , Modality Type . APPLICATION MODAL ) ; Preconditions . check Not Null ( view Container , STRING ) ; m view Container = view Container ; create Gui ( ) ; new C Dialog Escaper ( this ) ; Gui Helper . center Child To Parent ( owner , this , BOOL ) ; if ( address != null ) { m offset Field . set Text ( address . to Hex String ( ) ) ; search ( address . to Long ( ) ) ; } }
public void remove Index ( int n ) { if ( n >= size ) { throw new Index Out Of Bounds Exception ( STRING ) ; } System . arraycopy ( values , n + NUM , values , n , size - n - NUM ) ; size -- ; }
public void remove Index ( int n ) { if ( n >= size ) { throw new Index Out Of Bounds Exception ( STRING ) ; } System . arraycopy ( values , n + NUM , values , n , size - n - NUM ) ; size -- ; }
private void init ( ) { main Panel = new J Panel ( ) ; main Panel . set Layout ( new Box Layout ( main Panel , Box Layout . Y AXIS ) ) ; main Panel . add ( connection Panel ) ; properties Panel = Connection Synapse Properties Panel . create Synapse Properties Panel ( this ) ; main Panel . add ( properties Panel ) ; eir Panel = Synapse Polarity And Randomizer Panel . create Polarity Ratio Panel ( this ) ; main Panel . add ( eir Panel ) ; fill Frame ( ) ; }
@ Override public Query rewrite ( Index Reader reader ) throws IO Exception { if ( disjuncts . length == NUM ) { return disjuncts [ NUM ] ; } boolean actually Rewritten = BOOL ; List < Query > rewritten Disjuncts = new Array List < > ( ) ; for ( Query sub : disjuncts ) { Query rewritten Sub = sub . rewrite ( reader ) ; actually Rewritten |= rewritten Sub != sub ; rewritten Disjuncts . add ( rewritten Sub ) ; } if ( actually Rewritten ) { return new Disjunction Max Query ( rewritten Disjuncts , tie Breaker Multiplier ) ; } return super . rewrite ( reader ) ; }
public void adjust Transformation ( double min XW , double min YW , double max XW , double max YW ) { double scale X = NUM ; double scale Y = NUM ; if ( max XW > min XW ) scale X = ( get Width ( ) - border Left - border Right ) / ( max XW - min XW ) ; if ( max YW > min YW ) scale Y = ( get Height ( ) - border Top - border Bottom ) / ( max YW - min YW ) ; offset X = - min XW ; offset Y = - min YW ; scale = Math . min ( scale X , scale Y ) ; }
public void adjust Transformation ( double min XW , double min YW , double max XW , double max YW ) { double scale X = NUM ; double scale Y = NUM ; if ( max XW > min XW ) scale X = ( get Width ( ) - border Left - border Right ) / ( max XW - min XW ) ; if ( max YW > min YW ) scale Y = ( get Height ( ) - border Top - border Bottom ) / ( max YW - min YW ) ; offset X = - min XW ; offset Y = - min YW ; scale = Math . min ( scale X , scale Y ) ; }
public void adjust Transformation ( double min XW , double min YW , double max XW , double max YW ) { double scale X = NUM ; double scale Y = NUM ; if ( max XW > min XW ) scale X = ( get Width ( ) - border Left - border Right ) / ( max XW - min XW ) ; if ( max YW > min YW ) scale Y = ( get Height ( ) - border Top - border Bottom ) / ( max YW - min YW ) ; offset X = - min XW ; offset Y = - min YW ; scale = Math . min ( scale X , scale Y ) ; }
public boolean has Video Data ( Video v ) { Path source = get Video Path ( v ) ; return Files . exists ( source ) ; }
public Random ( ) { this ( System . current Time Millis ( ) ) ; }
public static Object run ( String rule , Map < String , Object > variables , Context context ) { Stellar Processor processor = new Stellar Processor ( ) ; Assert . assert True ( rule + STRING , processor . validate ( rule , context ) ) ; Object ret = processor . parse ( rule , null , Stellar Functions . FUNCTION RESOLVER ( ) , context ) ; byte [ ] raw = Ser De Utils . to Bytes ( ret ) ; Object actual = Ser De Utils . from Bytes ( raw , Object . class ) ; Assert . assert Equals ( ret , actual ) ; return ret ; }
public static Object run ( String rule , Map < String , Object > variables , Context context ) { Stellar Processor processor = new Stellar Processor ( ) ; Assert . assert True ( rule + STRING , processor . validate ( rule , context ) ) ; Object ret = processor . parse ( rule , null , Stellar Functions . FUNCTION RESOLVER ( ) , context ) ; byte [ ] raw = Ser De Utils . to Bytes ( ret ) ; Object actual = Ser De Utils . from Bytes ( raw , Object . class ) ; Assert . assert Equals ( ret , actual ) ; return ret ; }
public static Object run ( String rule , Map < String , Object > variables , Context context ) { Stellar Processor processor = new Stellar Processor ( ) ; Assert . assert True ( rule + STRING , processor . validate ( rule , context ) ) ; Object ret = processor . parse ( rule , null , Stellar Functions . FUNCTION RESOLVER ( ) , context ) ; byte [ ] raw = Ser De Utils . to Bytes ( ret ) ; Object actual = Ser De Utils . from Bytes ( raw , Object . class ) ; Assert . assert Equals ( ret , actual ) ; return ret ; }
public boolean has Available Addresses ( ) { if ( is Pool Full ( ) || get Pool Availability ( ) == NUM ) return BOOL ; else return BOOL ; }
public boolean has Available Addresses ( ) { if ( is Pool Full ( ) || get Pool Availability ( ) == NUM ) return BOOL ; else return BOOL ; }
private static Delete Disks Response check Delete Disks Response ( Delete Disks Response delete Disks Response ) throws Rpc Exception { logger . info ( STRING , delete Disks Response ) ; switch ( delete Disks Response . get Result ( ) ) { case OK : break ; case SYSTEM ERROR : throw new System Error Exception ( delete Disks Response . get Error ( ) ) ; default : throw new Rpc Exception ( String . format ( STRING , delete Disks Response . get Result ( ) ) ) ; } return delete Disks Response ; }
private String [ ] split Tfvc Collection Url ( final String collection Url ) { final String [ ] result = new String [ NUM ] ; if ( String Utils . is Empty ( collection Url ) ) { return result ; } final String trimmed Url = Url Helper . trim Trailing Separators ( collection Url ) ; final int index = trimmed Url . last Index Of ( Url Helper . URL SEPARATOR ) ; if ( index >= NUM ) { result [ NUM ] = trimmed Url . substring ( NUM , index + NUM ) ; result [ NUM ] = trimmed Url . substring ( index + NUM ) ; } else { result [ NUM ] = collection Url ; result [ NUM ] = String Utils . EMPTY ; } return result ; }
public Input Stream stream ( ) throws Http Request Exception { Input Stream stream ; if ( code ( ) < HTTP BAD REQUEST ) try { stream = connection . get Input Stream ( ) ; } catch ( IO Exception e ) { throw new Http Request Exception ( e ) ; } else { stream = connection . get Error Stream ( ) ; if ( stream == null ) try { stream = connection . get Input Stream ( ) ; } catch ( IO Exception e ) { throw new Http Request Exception ( e ) ; } } if ( ! uncompress || ! ENCODING GZIP . equals ( content Encoding ( ) ) ) return stream ; else try { return new GZIP Input Stream ( stream ) ; } catch ( IO Exception e ) { throw new Http Request Exception ( e ) ; } }
public void write ( char [ ] cbuf , int off , int len ) throws java . io . IO Exception { write ( new String ( cbuf , off , len ) ) ; }
public static Text With Mnemonic parse Text ( final String text With Mnemonic ) { if ( text With Mnemonic == null ) { throw new Illegal Argument Exception ( STRING ) ; } int index = - NUM ; final String Buffer plain Text = new String Buffer ( ) ; for ( int i = NUM ; i < text With Mnemonic . length ( ) ; i ++ ) { char ch = text With Mnemonic . char At ( i ) ; if ( ch == STRING ) { i ++ ; if ( i >= text With Mnemonic . length ( ) ) { break ; } ch = text With Mnemonic . char At ( i ) ; if ( ch != STRING ) { index = plain Text . length ( ) ; } } plain Text . append ( ch ) ; } return new Text With Mnemonic ( plain Text . to String ( ) , index ) ; }
public static Text With Mnemonic parse Text ( final String text With Mnemonic ) { if ( text With Mnemonic == null ) { throw new Illegal Argument Exception ( STRING ) ; } int index = - NUM ; final String Buffer plain Text = new String Buffer ( ) ; for ( int i = NUM ; i < text With Mnemonic . length ( ) ; i ++ ) { char ch = text With Mnemonic . char At ( i ) ; if ( ch == STRING ) { i ++ ; if ( i >= text With Mnemonic . length ( ) ) { break ; } ch = text With Mnemonic . char At ( i ) ; if ( ch != STRING ) { index = plain Text . length ( ) ; } } plain Text . append ( ch ) ; } return new Text With Mnemonic ( plain Text . to String ( ) , index ) ; }
public static Text With Mnemonic parse Text ( final String text With Mnemonic ) { if ( text With Mnemonic == null ) { throw new Illegal Argument Exception ( STRING ) ; } int index = - NUM ; final String Buffer plain Text = new String Buffer ( ) ; for ( int i = NUM ; i < text With Mnemonic . length ( ) ; i ++ ) { char ch = text With Mnemonic . char At ( i ) ; if ( ch == STRING ) { i ++ ; if ( i >= text With Mnemonic . length ( ) ) { break ; } ch = text With Mnemonic . char At ( i ) ; if ( ch != STRING ) { index = plain Text . length ( ) ; } } plain Text . append ( ch ) ; } return new Text With Mnemonic ( plain Text . to String ( ) , index ) ; }
private boolean is Mime Format ( long format , String primary Type ) { String nat = get Native For Format ( format ) ; if ( nat == null ) { return BOOL ; } try { Data Flavor df = new Data Flavor ( nat ) ; if ( primary Type . equals ( df . get Primary Type ( ) ) ) { return BOOL ; } } catch ( Exception e ) { } return BOOL ; }
private boolean is Mime Format ( long format , String primary Type ) { String nat = get Native For Format ( format ) ; if ( nat == null ) { return BOOL ; } try { Data Flavor df = new Data Flavor ( nat ) ; if ( primary Type . equals ( df . get Primary Type ( ) ) ) { return BOOL ; } } catch ( Exception e ) { } return BOOL ; }
private boolean is Mime Format ( long format , String primary Type ) { String nat = get Native For Format ( format ) ; if ( nat == null ) { return BOOL ; } try { Data Flavor df = new Data Flavor ( nat ) ; if ( primary Type . equals ( df . get Primary Type ( ) ) ) { return BOOL ; } } catch ( Exception e ) { } return BOOL ; }
public byte receive One Byte ( ) { Log . d ( TAG , STRING ) ; try { acquire Lock ( ) ; m Server Socket . receive ( m Receive Packet ) ; Log . d ( TAG , STRING + ( NUM + m Receive Packet . get Data ( ) [ NUM ] ) ) ; return m Receive Packet . get Data ( ) [ NUM ] ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } return Byte . MIN VALUE ; }
public void recruit Players From Str ( String players Str ) { String [ ] players = players Str . split ( STRING ) ; String curr Line = players [ NUM ] ; int i = NUM ; while ( ! curr Line . equals ( STRING ) ) { recruit Player CSV ( curr Line , BOOL ) ; curr Line = players [ ++ i ] ; } recruit Walk Ons ( ) ; curr Line = players [ ++ i ] ; while ( ! curr Line . equals ( STRING ) ) { recruit Player CSV ( curr Line , BOOL ) ; curr Line = players [ ++ i ] ; } }
static Verifier Device Identity generate ( Random rng ) { long identity = rng . next Long ( ) ; return new Verifier Device Identity ( identity ) ; }
static Verifier Device Identity generate ( Random rng ) { long identity = rng . next Long ( ) ; return new Verifier Device Identity ( identity ) ; }
public void place Item ( Item Stack stack , Block Pos pos , World world , boolean centre Item ) { double offset = ( centre Item ) ? NUM : NUM ; Entity Item entityitem = new Entity Item ( world , ( double ) pos . get X ( ) + offset , ( double ) pos . get Y ( ) + offset , ( double ) pos . get Z ( ) + offset , stack ) ; entityitem . motion X = NUM ; entityitem . motion Y = NUM ; entityitem . motion Z = NUM ; entityitem . set Default Pickup Delay ( ) ; world . spawn Entity In World ( entityitem ) ; }
public void place Item ( Item Stack stack , Block Pos pos , World world , boolean centre Item ) { double offset = ( centre Item ) ? NUM : NUM ; Entity Item entityitem = new Entity Item ( world , ( double ) pos . get X ( ) + offset , ( double ) pos . get Y ( ) + offset , ( double ) pos . get Z ( ) + offset , stack ) ; entityitem . motion X = NUM ; entityitem . motion Y = NUM ; entityitem . motion Z = NUM ; entityitem . set Default Pickup Delay ( ) ; world . spawn Entity In World ( entityitem ) ; }
public final void test Generate Seedint 01 ( ) { try { sr . generate Seed ( - NUM ) ; fail ( STRING ) ; } catch ( Negative Array Size Exception e ) { } }
public final void test Generate Seedint 01 ( ) { try { sr . generate Seed ( - NUM ) ; fail ( STRING ) ; } catch ( Negative Array Size Exception e ) { } }
private Shape decode Edge ( int width , int height ) { path . reset ( ) ; path . move To ( width - NUM , NUM ) ; path . line To ( width - NUM , height - NUM ) ; path . line To ( width - NUM , height - NUM ) ; path . line To ( NUM , height - NUM ) ; return path ; }
public void apply Camera ( GL 2 gl ) { gl . gl Matrix Mode ( GL 2 . GL PROJECTION ) ; gl . gl Load Identity ( ) ; glu . glu Perspective ( NUM , width / ( float ) height , NUM , NUM ) ; eye [ NUM ] = ( float ) Math . sin ( theta ) * NUM ; eye [ NUM ] = NUM ; eye [ NUM ] = ( float ) Math . cos ( theta ) * NUM ; glu . glu Look At ( eye [ NUM ] , eye [ NUM ] , eye [ NUM ] , NUM , NUM , NUM , NUM , NUM , NUM ) ; gl . gl Matrix Mode ( GL 2 . GL MODELVIEW ) ; gl . gl Load Identity ( ) ; gl . gl Viewport ( NUM , NUM , width , height ) ; }
private void update Ui By Track Color Mode ( String track Color Mode ) { boolean is Fixed Value = track Color Mode . equals ( get String ( R . string . settings map track color mode fixed value ) ) ; boolean is Dynamic Value = track Color Mode . equals ( get String ( R . string . settings map track color mode dynamic value ) ) ; slow Preference . set Enabled ( is Fixed Value ) ; medium Preference . set Enabled ( is Fixed Value ) ; percentage Preference . set Enabled ( is Dynamic Value ) ; }
public boolean is Group Expanded ( int group Position ) { Group Metadata group Metadata ; for ( int i = m Exp Group Metadata List . size ( ) - NUM ; i >= NUM ; i -- ) { group Metadata = m Exp Group Metadata List . get ( i ) ; if ( group Metadata . g Pos == group Position ) { return BOOL ; } } return BOOL ; }
private double [ ] incoming Param Vector ( double [ ] incoming Inst ) throws Exception { Instances mining Schema I = m mining Schema . get Fields As Instances ( ) ; double [ ] incoming PV = new double [ m parameter List . size ( ) ] ; for ( int i = NUM ; i < m parameter List . size ( ) ; i ++ ) { incoming PV [ i ] = NUM ; for ( int j = NUM ; j < mining Schema I . num Attributes ( ) ; j ++ ) { PP Cell cell Entry = m pp Matrix [ i ] [ j ] ; Predictor p = null ; if ( cell Entry != null ) { if ( ( p = get Factor ( cell Entry . m predictor Name ) ) != null ) { if ( ( int ) incoming Inst [ p . m mining Schema Index ] == ( int ) cell Entry . m value ) { incoming PV [ i ] *= NUM ; } else { incoming PV [ i ] *= NUM ; } } else if ( ( p = get Covariate ( cell Entry . m predictor Name ) ) != null ) { incoming PV [ i ] *= Math . pow ( incoming Inst [ p . m mining Schema Index ] , cell Entry . m value ) ; } else { throw new Exception ( STRING + cell Entry . m predictor Name + STRING ) ; } } } } return incoming PV ; }
private double [ ] incoming Param Vector ( double [ ] incoming Inst ) throws Exception { Instances mining Schema I = m mining Schema . get Fields As Instances ( ) ; double [ ] incoming PV = new double [ m parameter List . size ( ) ] ; for ( int i = NUM ; i < m parameter List . size ( ) ; i ++ ) { incoming PV [ i ] = NUM ; for ( int j = NUM ; j < mining Schema I . num Attributes ( ) ; j ++ ) { PP Cell cell Entry = m pp Matrix [ i ] [ j ] ; Predictor p = null ; if ( cell Entry != null ) { if ( ( p = get Factor ( cell Entry . m predictor Name ) ) != null ) { if ( ( int ) incoming Inst [ p . m mining Schema Index ] == ( int ) cell Entry . m value ) { incoming PV [ i ] *= NUM ; } else { incoming PV [ i ] *= NUM ; } } else if ( ( p = get Covariate ( cell Entry . m predictor Name ) ) != null ) { incoming PV [ i ] *= Math . pow ( incoming Inst [ p . m mining Schema Index ] , cell Entry . m value ) ; } else { throw new Exception ( STRING + cell Entry . m predictor Name + STRING ) ; } } } } return incoming PV ; }
private void create Consumers ( List < Object > consumers Config ) { for ( Object obj Consumer : consumers Config ) { String class Name = Cpe Builder Utils . get Class Name From Config ( obj Consumer ) ; Map < String , Object > params = Cpe Builder Utils . get Params From Config ( obj Consumer ) ; Optional < Analysis Engine Description > desc = create Consumer ( class Name , params , CONSUMER DEFAULT PACKAGE ) ; if ( desc . is Present ( ) ) { String name = Cpe Builder Utils . get Component Name ( get Consumer Names ( ) , STRING + class Name ) ; add Consumer ( name , desc . get ( ) ) ; } } }
public boolean is Valid ( ) { return ( Math . abs ( lat . lo ( ) ) <= S2 . M PI 2 && Math . abs ( lat . hi ( ) ) <= S2 . M PI 2 && lng . is Valid ( ) && lat . is Empty ( ) == lng . is Empty ( ) ) ; }
public boolean is Valid ( ) { return ( Math . abs ( lat . lo ( ) ) <= S2 . M PI 2 && Math . abs ( lat . hi ( ) ) <= S2 . M PI 2 && lng . is Valid ( ) && lat . is Empty ( ) == lng . is Empty ( ) ) ; }
public boolean is Valid ( ) { return ( Math . abs ( lat . lo ( ) ) <= S2 . M PI 2 && Math . abs ( lat . hi ( ) ) <= S2 . M PI 2 && lng . is Valid ( ) && lat . is Empty ( ) == lng . is Empty ( ) ) ; }
@ Deprecated public Media File ( File f , Media File Type type ) { this ( f . to Path ( ) , type ) ; }
public void add Name Delta Event Type ( String name Delta Event Type ) { name Delta Event Types . add ( name Delta Event Type ) ; }
public void add Name Delta Event Type ( String name Delta Event Type ) { name Delta Event Types . add ( name Delta Event Type ) ; }
public void log ( String event , String message ) { boolean event Active = is Event Active ( event ) ; if ( ( this . logging && event Active && ! writers . is Empty ( ) ) ) { try { for ( Writer writer : writers . values ( ) ) { writer . write ( message ) ; writer . write ( STRING ) ; writer . flush ( ) ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } }
@ Override public void run ( ) { Multiple Objects Bundle data = generator . load Data ( ) ; if ( LOG . is Verbose ( ) ) { LOG . verbose ( STRING ) ; } try { if ( output File . exists ( ) && LOG . is Verbose ( ) ) { LOG . verbose ( STRING + output File + STRING + STRING ) ; } try ( Output Stream Writer out Stream = new File Writer ( output File , BOOL ) ) { write Clusters ( out Stream , data ) ; } } catch ( IO Exception e ) { throw new Abort Exception ( STRING , e ) ; } if ( LOG . is Verbose ( ) ) { LOG . verbose ( STRING ) ; } }
@ Bean public Build Information build Information ( ) { Build Information build Information = new Build Information ( ) ; build Information . set Build Date ( environment . get Property ( STRING ) ) ; build Information . set Build Number ( environment . get Property ( STRING ) ) ; build Information . set Build Os ( environment . get Property ( STRING ) ) ; build Information . set Build User ( environment . get Property ( STRING ) ) ; LOGGER . info ( String . format ( STRING , build Information . get Build Number ( ) , build Information . get Build Date ( ) , build Information . get Build User ( ) , build Information . get Build Os ( ) ) ) ; LOGGER . info ( STRING + get System Property Map ( STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING ) ) ; return build Information ; }
private static String convert To Mixed ( int address Low , int address High ) { if ( address High == NUM ) { if ( address Low >= NUM ) { return STRING + String . value Of ( address Low - NUM ) + STRING + String . value Of ( address Low ) + STRING ; } else if ( address Low >= NUM ) { return STRING + String . value Of ( address Low - NUM ) + STRING + String . value Of ( address Low ) + STRING ; } else if ( address Low >= NUM ) { return STRING + String . value Of ( address Low - NUM ) + STRING + String . value Of ( address Low ) + STRING ; } else { return String . value Of ( address Low & NUM ) ; } } else { return String . value Of ( LOCO ADR ( address High , address Low ) ) ; } }
public void write ( byte [ ] buffer , int offset , int length , boolean is End ) throws IO Exception { throw new Unsupported Operation Exception ( String . value Of ( this ) ) ; }
private List < VNX File System > discover All File Systems ( Storage System system ) throws VNX File Collection Exception , VNX Exception { List < VNX File System > file Systems = new Array List < VNX File System > ( ) ; logger . info ( STRING , system . get Id ( ) ) ; try { List < VNX File System > vnx File Systems = get All File System ( system ) ; logger . info ( STRING , vnx File Systems . size ( ) ) ; if ( vnx File Systems != null ) { for ( VNX File System vnxfs : vnx File Systems ) { File Share fs = null ; URI Query Result List results = new URI Query Result List ( ) ; String fs Native Guid = Native GUID Generator . generate Native Guid ( system , vnxfs . get Fs Id ( ) + STRING , Native GUID Generator . FILESYSTEM ) ; if ( check Storage File System Exists In DB ( fs Native Guid ) ) { continue ; } vnxfs . set Fs Native Guid ( fs Native Guid ) ; file Systems . add ( vnxfs ) ; } } logger . info ( STRING , file Systems . size ( ) ) ; } catch ( IO Exception e ) { logger . error ( STRING , system . get Id ( ) , e . get Message ( ) ) ; VNX File Collection Exception vnxe = new VNX File Collection Exception ( STRING + system . get Id ( ) ) ; vnxe . init Cause ( e ) ; throw vnxe ; } logger . info ( STRING , system . get Id ( ) ) ; return file Systems ; }
public void write ( byte [ ] b , int o , int len ) { while ( len > NUM ) { int n = len <= avail Len ? len : avail Len ; System . arraycopy ( b , o , buf , offset , n ) ; increment Offset ( n ) ; len -= n ; o += n ; } }
public void write ( byte [ ] b , int o , int len ) { while ( len > NUM ) { int n = len <= avail Len ? len : avail Len ; System . arraycopy ( b , o , buf , offset , n ) ; increment Offset ( n ) ; len -= n ; o += n ; } }
int select Server ( int force Index ) { int index = force Index == - NUM ? get Less Saturated Index ( ) : force Index ; servers Counters . increment And Get ( index ) ; return index ; }
int select Server ( int force Index ) { int index = force Index == - NUM ? get Less Saturated Index ( ) : force Index ; servers Counters . increment And Get ( index ) ; return index ; }
public static void delete Player ( Player Account Data acc Data ) { if ( acc Data . get Deletion Date ( ) != null ) { return ; } acc Data . set Deletion Date ( new Timestamp ( System . current Time Millis ( ) + NUM * NUM * NUM ) ) ; store Deletion Time ( acc Data ) ; }
public void lost Ownership ( Clipboard clipboard , Transferable contents ) { if ( owns Selection ) { owns Selection = BOOL ; if ( component != null && ! component . has Focus ( ) ) { set Selection Visible ( BOOL ) ; } } }
private void show Find Replace Dialog ( ) { J Frame frame = new J Frame ( ) ; Find Replace Dialog dialog = new Find Replace Dialog ( frame , this ) ; frame . set Content Pane ( dialog ) ; frame . set Title ( STRING ) ; frame . set Visible ( BOOL ) ; frame . pack ( ) ; frame . set Location Relative To ( null ) ; }
protected void switch State ( char test Char ) throws FBSQL Parse Exception { if ( Character . is Whitespace ( test Char ) && ! is In State ( LITERAL STATE ) ) { set State ( SPACE STATE ) ; return ; } switch ( test Char ) { case STRING : if ( is In State ( NORMAL STATE ) ) set State ( LITERAL STATE ) ; else if ( is In State ( LITERAL STATE ) ) set State ( NORMAL STATE ) ; break ; case STRING : if ( ! is In State ( LITERAL STATE ) && ! is In State ( BRACE STATE ) ) set State ( COMMA STATE ) ; break ; case STRING : case STRING : if ( ! is In State ( LITERAL STATE ) ) set State ( BRACE STATE ) ; break ; case STRING : case STRING : if ( ! is In State ( LITERAL STATE ) ) set State ( CURLY BRACE STATE ) ; break ; default : if ( ! is In State ( LITERAL STATE ) && ! is In State ( BRACE STATE ) ) set State ( NORMAL STATE ) ; } }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return FULL NAME ; case NUM : return GENDER ; case NUM : return LOCATION ; default : return null ; } }
public Create Statement put ( Char Sequence column , Object value ) { if ( ++ column Count > NUM ) { columns . append ( STRING ) ; values . append ( STRING ) ; } columns . append ( column ) ; append ( values , value ) ; return this ; }
public Create Statement put ( Char Sequence column , Object value ) { if ( ++ column Count > NUM ) { columns . append ( STRING ) ; values . append ( STRING ) ; } columns . append ( column ) ; append ( values , value ) ; return this ; }
@ Override public Node remove Named Item NS ( String namespace URI , String name ) throws DOM Exception { if ( is Read Only ( ) ) { String msg = DOM Message Formatter . format Message ( DOM Message Formatter . DOM DOMAIN , STRING , null ) ; throw new DOM Exception ( DOM Exception . NO MODIFICATION ALLOWED ERR , msg ) ; } int i = find Name Point ( namespace URI , name ) ; if ( i < NUM ) { String msg = DOM Message Formatter . format Message ( DOM Message Formatter . DOM DOMAIN , STRING , null ) ; throw new DOM Exception ( DOM Exception . NOT FOUND ERR , msg ) ; } Node Impl n = ( Node Impl ) nodes . get ( i ) ; nodes . remove ( i ) ; return n ; }
private void update Transferred Bytes Avg ( int new Value ) { int real Count = NUM ; int sum = NUM ; this . avg Samples [ this . next Sample Index ++ ] = new Value ; if ( this . next Sample Index >= BYTES TRANSFERRED AVG SAMPLES ) { this . next Sample Index = NUM ; } for ( int i = NUM ; i < BYTES TRANSFERRED AVG SAMPLES ; i ++ ) { if ( this . avg Samples [ i ] > NUM ) { real Count ++ ; sum += this . avg Samples [ i ] ; } } if ( real Count > NUM ) { this . avg Transferred Bytes = sum / real Count ; } else { this . avg Transferred Bytes = NUM ; } }
public static void stop Timer ( String name ) { long stop Time = System . nano Time ( ) ; Long start Time = open Timers . remove ( name ) ; if ( start Time == null ) { throw new Illegal Argument Exception ( STRING ) ; } Summary Statistics statistics = data . get ( name ) ; if ( statistics == null ) { statistics = new Summary Statistics ( ) ; data . put ( name , statistics ) ; } statistics . add Value ( stop Time - start Time ) ; }
@ Override protected synchronized void read ( long offset , byte [ ] b ) throws IO Exception { if ( byte Buffer != null ) { byte Buffer . position ( ( int ) offset ) ; byte Buffer . get ( b ) ; } else { throw new IO Exception ( STRING + get Path ( ) + STRING ) ; } }
boolean add Future ( Grid Dht Force Keys Future < ? , ? > fut ) { force Key Futs . put ( fut . future Id ( ) , fut ) ; if ( stopping ) { fut . on Done ( stop Error ( ) ) ; return BOOL ; } return BOOL ; }
public synchronized void crash ( ) throws IO Exception { open Files = new Hash Map < > ( ) ; open Files For Write = new Hash Set < > ( ) ; open Files Deleted = new Hash Set < > ( ) ; Map < Closeable , Exception > m = new Identity Hash Map < > ( open File Handles ) ; for ( Closeable f : m . key Set ( ) ) { try { f . close ( ) ; } catch ( Exception ignored ) { } } corrupt Files ( un Synced Files ) ; crashed = BOOL ; un Synced Files = new Hash Set < > ( ) ; }
public synchronized void crash ( ) throws IO Exception { open Files = new Hash Map < > ( ) ; open Files For Write = new Hash Set < > ( ) ; open Files Deleted = new Hash Set < > ( ) ; Map < Closeable , Exception > m = new Identity Hash Map < > ( open File Handles ) ; for ( Closeable f : m . key Set ( ) ) { try { f . close ( ) ; } catch ( Exception ignored ) { } } corrupt Files ( un Synced Files ) ; crashed = BOOL ; un Synced Files = new Hash Set < > ( ) ; }
public synchronized void crash ( ) throws IO Exception { open Files = new Hash Map < > ( ) ; open Files For Write = new Hash Set < > ( ) ; open Files Deleted = new Hash Set < > ( ) ; Map < Closeable , Exception > m = new Identity Hash Map < > ( open File Handles ) ; for ( Closeable f : m . key Set ( ) ) { try { f . close ( ) ; } catch ( Exception ignored ) { } } corrupt Files ( un Synced Files ) ; crashed = BOOL ; un Synced Files = new Hash Set < > ( ) ; }
public int post Files ( File [ ] files , int start Index In Args , Output Stream out , String type ) { reset ( ) ; int files Posted = NUM ; for ( File src File : files ) { if ( src File . is Directory ( ) && src File . can Read ( ) ) { files Posted += post Directory ( src File , out , type ) ; } else if ( src File . is File ( ) && src File . can Read ( ) ) { files Posted += post Files ( new File [ ] { src File } , out , type ) ; } else { File parent = src File . get Parent File ( ) ; if ( parent == null ) parent = new File ( STRING ) ; String file Glob = src File . get Name ( ) ; Glob File Filter ff = new Glob File Filter ( file Glob , BOOL ) ; File [ ] file List = parent . list Files ( ff ) ; if ( file List == null || file List . length == NUM ) { warn ( STRING + src File ) ; continue ; } files Posted += post Files ( file List , out , type ) ; } } return files Posted ; }
public int post Files ( File [ ] files , int start Index In Args , Output Stream out , String type ) { reset ( ) ; int files Posted = NUM ; for ( File src File : files ) { if ( src File . is Directory ( ) && src File . can Read ( ) ) { files Posted += post Directory ( src File , out , type ) ; } else if ( src File . is File ( ) && src File . can Read ( ) ) { files Posted += post Files ( new File [ ] { src File } , out , type ) ; } else { File parent = src File . get Parent File ( ) ; if ( parent == null ) parent = new File ( STRING ) ; String file Glob = src File . get Name ( ) ; Glob File Filter ff = new Glob File Filter ( file Glob , BOOL ) ; File [ ] file List = parent . list Files ( ff ) ; if ( file List == null || file List . length == NUM ) { warn ( STRING + src File ) ; continue ; } files Posted += post Files ( file List , out , type ) ; } } return files Posted ; }
@ Override public String generate Label ( XY Dataset dataset , int series , int item ) { return generate Label String ( dataset , series , item ) ; }
public boolean has Incoming Batch Instances ( ) { if ( m listenees . size ( ) == NUM ) { return BOOL ; } if ( m listenees . contains Key ( STRING ) || m listenees . contains Key ( STRING ) || m listenees . contains Key ( STRING ) ) { return BOOL ; } return BOOL ; }
public boolean has Incoming Batch Instances ( ) { if ( m listenees . size ( ) == NUM ) { return BOOL ; } if ( m listenees . contains Key ( STRING ) || m listenees . contains Key ( STRING ) || m listenees . contains Key ( STRING ) ) { return BOOL ; } return BOOL ; }
@ Override public boolean has Permission ( U current User , String permission ) { log . debug ( STRING + permission + STRING + this + STRING + current User ) ; decorate ( current User ) ; if ( permission . equals ( STRING ) ) return editable ; return BOOL ; }
@ Override public boolean has Permission ( U current User , String permission ) { log . debug ( STRING + permission + STRING + this + STRING + current User ) ; decorate ( current User ) ; if ( permission . equals ( STRING ) ) return editable ; return BOOL ; }
@ Override public boolean has Permission ( U current User , String permission ) { log . debug ( STRING + permission + STRING + this + STRING + current User ) ; decorate ( current User ) ; if ( permission . equals ( STRING ) ) return editable ; return BOOL ; }
private void find Prefix In Children ( String prefix , Zoo Keeper zookeeper , String dir ) throws Keeper Exception , Interrupted Exception { List < String > names = zookeeper . get Children ( dir , BOOL ) ; for ( String name : names ) { if ( name . starts With ( prefix ) ) { id = name ; if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( STRING + id ) ; } break ; } } if ( id == null ) { id = zookeeper . create ( dir + STRING + prefix , data , get Acl ( ) , EPHEMERAL SEQUENTIAL ) ; if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( STRING + id ) ; } } }
public void clear ( ) { mappings . clear ( ) ; }
@ Override public void before ( Derivation State state , int indent , int tail Node Index ) { Hyper Edge edge = state . edge ; Rule rule = edge . get Rule ( ) ; if ( rule == null ) { return ; } String lhs = Vocabulary . word ( rule . get LHS ( ) ) ; String unbracketed LHS = lhs . substring ( NUM , lhs . length ( ) - NUM ) ; Tree fragment = Tree . get Fragment From Yield ( rule . get English Words ( ) ) ; if ( fragment == null ) { String subtree = String . format ( STRING , unbracketed LHS , state . parent Node . i , state . parent Node . j , quote Terminals ( rule . get English Words ( ) ) ) ; fragment = Tree . from String ( subtree ) ; } merge ( fragment ) ; }
private void maybe Throw Exception ( ) throws E { if ( exception != null ) { throw exception ; } }
private boolean string Contains Special Characters ( String line ) { return line . index Of ( quotechar ) != - NUM || line . index Of ( escapechar ) != - NUM || line . index Of ( separator ) != - NUM || line . contains ( DEFAULT LINE END ) || line . contains ( STRING ) ; }
private boolean string Contains Special Characters ( String line ) { return line . index Of ( quotechar ) != - NUM || line . index Of ( escapechar ) != - NUM || line . index Of ( separator ) != - NUM || line . contains ( DEFAULT LINE END ) || line . contains ( STRING ) ; }
public Feature ( String line , Map cp Str 2 Int , Map lb Str 2 Int , Map fmap ) { String Tokenizer str Tok = new String Tokenizer ( line , STRING ) ; int len = str Tok . count Tokens ( ) ; String str Id Str = str Tok . next Token ( ) ; int idx = Integer . parse Int ( str Tok . next Token ( ) ) ; float val = NUM ; double wgt = Double . parse Double ( str Tok . next Token ( ) ) ; String Tokenizer str Id Tok = new String Tokenizer ( str Id Str , STRING ) ; String prefix = str Id Tok . next Token ( ) ; if ( prefix . compare To Ignore Case ( STRING ) == NUM ) { Integer y Int = ( Integer ) lb Str 2 Int . get ( str Id Tok . next Token ( ) ) ; Integer yp Int = ( Integer ) lb Str 2 Int . get ( str Id Tok . next Token ( ) ) ; if ( y Int != null && yp Int != null ) { e Feature 1 Init ( y Int . int Value ( ) , yp Int . int Value ( ) ) ; } } else if ( prefix . compare To Ignore Case ( STRING ) == NUM ) { Integer y Int = ( Integer ) lb Str 2 Int . get ( str Id Tok . next Token ( ) ) ; Integer cp Int = ( Integer ) cp Str 2 Int . get ( str Id Tok . next Token ( ) ) ; if ( y Int != null && cp Int != null ) { s Feature 1 Init ( y Int . int Value ( ) , cp Int . int Value ( ) ) ; } } this . idx = idx ; this . val = val ; this . wgt = wgt ; str Id 2 Idx Add ( fmap ) ; }
public static final String trim End ( String str ) { int position = str . length ( ) ; while ( ( position > NUM ) && Character . is Whitespace ( str . char At ( position - NUM ) ) ) { position -- ; } return str . substring ( NUM , position ) ; }
@ Suppress Warnings ( { STRING , STRING } ) private static Pipeline Op distinct Term Scan Join ( final Pipeline Op left , final List < NV > anns , Predicate pred , final Dataset Node dataset , final Long cutoff Limit Is Ignored , final Var Node distinct Term Scan Var , final Properties query Hints , final AST 2 B Op Context ctx ) { final I Variable distinct Var = distinct Term Scan Var . get Value Expression ( ) ; anns . add ( new NV ( Distinct Term Scan Op . Annotations . DISTINCT VAR , distinct Var ) ) ; final Constant < IV > mock Const = new Constant < IV > ( Term Id . mock IV ( VTE . URI ) ) ; final I Predicate mock Pred = pred . as Bound ( distinct Var , mock Const ) ; final SPO Key Order key Order = SPO Key Order . get Key Order ( mock Pred , ctx . is Quads ( ) ? NUM : NUM ) ; pred = ( Predicate ) pred . set Property ( I Predicate . Annotations . KEY ORDER , key Order ) ; anns . add ( new NV ( Pipeline Join . Annotations . PREDICATE , pred ) ) ; return apply Query Hints ( new Distinct Term Scan Op ( left Or Empty ( left ) , NV . as Map ( anns . to Array ( new NV [ anns . size ( ) ] ) ) ) , query Hints , ctx ) ; }
@ Suppress Warnings ( { STRING , STRING } ) private static Pipeline Op distinct Term Scan Join ( final Pipeline Op left , final List < NV > anns , Predicate pred , final Dataset Node dataset , final Long cutoff Limit Is Ignored , final Var Node distinct Term Scan Var , final Properties query Hints , final AST 2 B Op Context ctx ) { final I Variable distinct Var = distinct Term Scan Var . get Value Expression ( ) ; anns . add ( new NV ( Distinct Term Scan Op . Annotations . DISTINCT VAR , distinct Var ) ) ; final Constant < IV > mock Const = new Constant < IV > ( Term Id . mock IV ( VTE . URI ) ) ; final I Predicate mock Pred = pred . as Bound ( distinct Var , mock Const ) ; final SPO Key Order key Order = SPO Key Order . get Key Order ( mock Pred , ctx . is Quads ( ) ? NUM : NUM ) ; pred = ( Predicate ) pred . set Property ( I Predicate . Annotations . KEY ORDER , key Order ) ; anns . add ( new NV ( Pipeline Join . Annotations . PREDICATE , pred ) ) ; return apply Query Hints ( new Distinct Term Scan Op ( left Or Empty ( left ) , NV . as Map ( anns . to Array ( new NV [ anns . size ( ) ] ) ) ) , query Hints , ctx ) ; }
@ Suppress Warnings ( { STRING , STRING } ) private static Pipeline Op distinct Term Scan Join ( final Pipeline Op left , final List < NV > anns , Predicate pred , final Dataset Node dataset , final Long cutoff Limit Is Ignored , final Var Node distinct Term Scan Var , final Properties query Hints , final AST 2 B Op Context ctx ) { final I Variable distinct Var = distinct Term Scan Var . get Value Expression ( ) ; anns . add ( new NV ( Distinct Term Scan Op . Annotations . DISTINCT VAR , distinct Var ) ) ; final Constant < IV > mock Const = new Constant < IV > ( Term Id . mock IV ( VTE . URI ) ) ; final I Predicate mock Pred = pred . as Bound ( distinct Var , mock Const ) ; final SPO Key Order key Order = SPO Key Order . get Key Order ( mock Pred , ctx . is Quads ( ) ? NUM : NUM ) ; pred = ( Predicate ) pred . set Property ( I Predicate . Annotations . KEY ORDER , key Order ) ; anns . add ( new NV ( Pipeline Join . Annotations . PREDICATE , pred ) ) ; return apply Query Hints ( new Distinct Term Scan Op ( left Or Empty ( left ) , NV . as Map ( anns . to Array ( new NV [ anns . size ( ) ] ) ) ) , query Hints , ctx ) ; }
@ Suppress Warnings ( { STRING , STRING } ) private static Pipeline Op distinct Term Scan Join ( final Pipeline Op left , final List < NV > anns , Predicate pred , final Dataset Node dataset , final Long cutoff Limit Is Ignored , final Var Node distinct Term Scan Var , final Properties query Hints , final AST 2 B Op Context ctx ) { final I Variable distinct Var = distinct Term Scan Var . get Value Expression ( ) ; anns . add ( new NV ( Distinct Term Scan Op . Annotations . DISTINCT VAR , distinct Var ) ) ; final Constant < IV > mock Const = new Constant < IV > ( Term Id . mock IV ( VTE . URI ) ) ; final I Predicate mock Pred = pred . as Bound ( distinct Var , mock Const ) ; final SPO Key Order key Order = SPO Key Order . get Key Order ( mock Pred , ctx . is Quads ( ) ? NUM : NUM ) ; pred = ( Predicate ) pred . set Property ( I Predicate . Annotations . KEY ORDER , key Order ) ; anns . add ( new NV ( Pipeline Join . Annotations . PREDICATE , pred ) ) ; return apply Query Hints ( new Distinct Term Scan Op ( left Or Empty ( left ) , NV . as Map ( anns . to Array ( new NV [ anns . size ( ) ] ) ) ) , query Hints , ctx ) ; }
@ Suppress Warnings ( { STRING , STRING } ) private static Pipeline Op distinct Term Scan Join ( final Pipeline Op left , final List < NV > anns , Predicate pred , final Dataset Node dataset , final Long cutoff Limit Is Ignored , final Var Node distinct Term Scan Var , final Properties query Hints , final AST 2 B Op Context ctx ) { final I Variable distinct Var = distinct Term Scan Var . get Value Expression ( ) ; anns . add ( new NV ( Distinct Term Scan Op . Annotations . DISTINCT VAR , distinct Var ) ) ; final Constant < IV > mock Const = new Constant < IV > ( Term Id . mock IV ( VTE . URI ) ) ; final I Predicate mock Pred = pred . as Bound ( distinct Var , mock Const ) ; final SPO Key Order key Order = SPO Key Order . get Key Order ( mock Pred , ctx . is Quads ( ) ? NUM : NUM ) ; pred = ( Predicate ) pred . set Property ( I Predicate . Annotations . KEY ORDER , key Order ) ; anns . add ( new NV ( Pipeline Join . Annotations . PREDICATE , pred ) ) ; return apply Query Hints ( new Distinct Term Scan Op ( left Or Empty ( left ) , NV . as Map ( anns . to Array ( new NV [ anns . size ( ) ] ) ) ) , query Hints , ctx ) ; }
@ Suppress Warnings ( { STRING , STRING } ) private static Pipeline Op distinct Term Scan Join ( final Pipeline Op left , final List < NV > anns , Predicate pred , final Dataset Node dataset , final Long cutoff Limit Is Ignored , final Var Node distinct Term Scan Var , final Properties query Hints , final AST 2 B Op Context ctx ) { final I Variable distinct Var = distinct Term Scan Var . get Value Expression ( ) ; anns . add ( new NV ( Distinct Term Scan Op . Annotations . DISTINCT VAR , distinct Var ) ) ; final Constant < IV > mock Const = new Constant < IV > ( Term Id . mock IV ( VTE . URI ) ) ; final I Predicate mock Pred = pred . as Bound ( distinct Var , mock Const ) ; final SPO Key Order key Order = SPO Key Order . get Key Order ( mock Pred , ctx . is Quads ( ) ? NUM : NUM ) ; pred = ( Predicate ) pred . set Property ( I Predicate . Annotations . KEY ORDER , key Order ) ; anns . add ( new NV ( Pipeline Join . Annotations . PREDICATE , pred ) ) ; return apply Query Hints ( new Distinct Term Scan Op ( left Or Empty ( left ) , NV . as Map ( anns . to Array ( new NV [ anns . size ( ) ] ) ) ) , query Hints , ctx ) ; }
private void show Popup Menu ( final Mouse Event event ) { final I Tag Tree Node selected Node = ( I Tag Tree Node ) Tree Helpers . get Node At ( this , event . get X ( ) , event . get Y ( ) ) ; if ( selected Node == null ) { final J Popup Menu popup Menu = new J Popup Menu ( ) ; popup Menu . add ( C Action Proxy . proxy ( new C Add Root Tag Node Action ( m parent , m tag Manager , m root Node . get Tag ( ) ) ) ) ; popup Menu . show ( this , event . get X ( ) , event . get Y ( ) ) ; } else { final J Popup Menu menu = selected Node . get Popup Menu ( ) ; if ( menu != null ) { menu . show ( this , event . get X ( ) , event . get Y ( ) ) ; } } }
private void burrow Cave ( Point point , Layer Definition layer ) { Queue < Point > branch Points = new Linked List < Point > ( ) ; Hash Set < Point > visited = new Hash Set < Point > ( ) ; branch Points . add ( point ) ; List < Point > neighbours = get Unvisited Neighbours ( point , visited ) ; do { visited . add ( point ) ; if ( neighbours . size ( ) > NUM ) { Point next = Rand . rand ( neighbours ) ; branch Points . add ( next ) ; int diffx = Integer . signum ( next . x - point . x ) ; int diffy = Integer . signum ( next . y - point . y ) ; for ( int i = NUM ; i <= WALL THICKNESS ; i ++ ) { set Collide ( layer , point . x + i * diffx , point . y + i * diffy , BOOL ) ; } point = next ; } else { point = branch Points . poll ( ) ; } neighbours = get Unvisited Neighbours ( point , visited ) ; } while ( point != null ) ; }
public Intent Builder add Email Bcc ( String address ) { if ( m Bcc Addresses == null ) { m Bcc Addresses = new Array List < String > ( ) ; } m Bcc Addresses . add ( address ) ; return this ; }
public Intent Builder add Email Bcc ( String address ) { if ( m Bcc Addresses == null ) { m Bcc Addresses = new Array List < String > ( ) ; } m Bcc Addresses . add ( address ) ; return this ; }
public Server Commit acquire ( Operation Entry entry , Server Session Context session , long timestamp ) { Server Commit commit = pool . poll ( ) ; if ( commit == null ) { commit = new Server Commit ( this , log ) ; } commit . reset ( entry , session , timestamp ) ; return commit ; }
private boolean assert Static Type ( Class < ? > cls , Name n ) { int local = n . index ( ) ; Class < ? > aclass = local Classes [ local ] ; if ( aclass != null && ( aclass == cls || cls . is Assignable From ( aclass ) ) ) { return BOOL ; } else if ( aclass == null || aclass . is Assignable From ( cls ) ) { local Classes [ local ] = cls ; } return BOOL ; }
public static void ensure 32 Bit Ie ( ) { File ie 32 = new File ( IE 32 LOCATION ) ; if ( find Browser ( IE 32 NAME ) == null && ie 32 . exists ( ) ) { create Browser Descriptor ( IE 32 NAME , IE 32 LOCATION ) ; } }
public static void ensure 32 Bit Ie ( ) { File ie 32 = new File ( IE 32 LOCATION ) ; if ( find Browser ( IE 32 NAME ) == null && ie 32 . exists ( ) ) { create Browser Descriptor ( IE 32 NAME , IE 32 LOCATION ) ; } }
public static void ensure 32 Bit Ie ( ) { File ie 32 = new File ( IE 32 LOCATION ) ; if ( find Browser ( IE 32 NAME ) == null && ie 32 . exists ( ) ) { create Browser Descriptor ( IE 32 NAME , IE 32 LOCATION ) ; } }
public static void ensure 32 Bit Ie ( ) { File ie 32 = new File ( IE 32 LOCATION ) ; if ( find Browser ( IE 32 NAME ) == null && ie 32 . exists ( ) ) { create Browser Descriptor ( IE 32 NAME , IE 32 LOCATION ) ; } }
@ Override public boolean is Component Enabled ( Resolve Info resolve Info ) { if ( resolve Info != null && resolve Info . service Info != null && ! Text Utils . is Empty ( resolve Info . service Info . package Name ) ) { if ( m Permitted Package Names == null || is System App ( resolve Info . service Info . application Info ) ) { return BOOL ; } else { return m Permitted Package Names . contains ( resolve Info . service Info . package Name ) ; } } return BOOL ; }
@ Override public boolean is Component Enabled ( Resolve Info resolve Info ) { if ( resolve Info != null && resolve Info . service Info != null && ! Text Utils . is Empty ( resolve Info . service Info . package Name ) ) { if ( m Permitted Package Names == null || is System App ( resolve Info . service Info . application Info ) ) { return BOOL ; } else { return m Permitted Package Names . contains ( resolve Info . service Info . package Name ) ; } } return BOOL ; }
@ Override public boolean is Component Enabled ( Resolve Info resolve Info ) { if ( resolve Info != null && resolve Info . service Info != null && ! Text Utils . is Empty ( resolve Info . service Info . package Name ) ) { if ( m Permitted Package Names == null || is System App ( resolve Info . service Info . application Info ) ) { return BOOL ; } else { return m Permitted Package Names . contains ( resolve Info . service Info . package Name ) ; } } return BOOL ; }
@ Override public boolean is Component Enabled ( Resolve Info resolve Info ) { if ( resolve Info != null && resolve Info . service Info != null && ! Text Utils . is Empty ( resolve Info . service Info . package Name ) ) { if ( m Permitted Package Names == null || is System App ( resolve Info . service Info . application Info ) ) { return BOOL ; } else { return m Permitted Package Names . contains ( resolve Info . service Info . package Name ) ; } } return BOOL ; }
@ Override public Generator < I Line Segment > construct ( String [ ] args ) { return new Sliding Ladder Generator ( Double . value Of ( args [ NUM ] ) ) ; }
public Parametric Textual Extension Recognizer ( Array List exts ) { int size = exts . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) { Object aux = exts . get ( i ) ; if ( aux instanceof String ) { String ext = ( String ) aux ; add Extension ( ext ) ; } } }
public Parametric Textual Extension Recognizer ( Array List exts ) { int size = exts . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) { Object aux = exts . get ( i ) ; if ( aux instanceof String ) { String ext = ( String ) aux ; add Extension ( ext ) ; } } }
public static Sketch Hex create ( String sketch Name , String hex String ) throws Hex Parsing Exception { if ( sketch Name . length ( ) > Constants . MAX SKETCH NAME LENGTH ) { sketch Name = sketch Name . substring ( NUM , Constants . MAX SKETCH NAME LENGTH ) ; } List < Line > lines = parse Hex String To Lines ( hex String ) ; byte [ ] bytes = convert Lines To Bytes ( lines ) ; return new Auto Parcel Sketch Hex ( sketch Name , bytes ) ; }
public static Sketch Hex create ( String sketch Name , String hex String ) throws Hex Parsing Exception { if ( sketch Name . length ( ) > Constants . MAX SKETCH NAME LENGTH ) { sketch Name = sketch Name . substring ( NUM , Constants . MAX SKETCH NAME LENGTH ) ; } List < Line > lines = parse Hex String To Lines ( hex String ) ; byte [ ] bytes = convert Lines To Bytes ( lines ) ; return new Auto Parcel Sketch Hex ( sketch Name , bytes ) ; }
private synchronized void close ( ) { if ( s != null ) { try { s . close ( ) ; } catch ( IO Exception ex ) { LOGGER . warning ( STRING + ex ) ; } } }
protected Annotation Query ( String scope , String metric , Map < String , String > tags , Long start Timestamp , Long end Timestamp ) { this ( ) ; require Argument ( start Timestamp != null , STRING ) ; require Argument ( scope != null , STRING ) ; require Argument ( metric == null || ! metric . is Empty ( ) , STRING ) ; start Timestamp = start Timestamp ; end Timestamp = end Timestamp ; scope = scope ; metric = metric ; if ( tags != null ) { set Tags ( tags ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
private void update Types ( @ Nonnull Turnout Operation op ) { if ( ! initialized ) initialize ( ) ; Linked List < Turnout Operation > new Types = new Linked List < Turnout Operation > ( ) ; Iterator < Turnout Operation > iter = operation Types . iterator ( ) ; boolean found = BOOL ; while ( iter . has Next ( ) ) { Turnout Operation item = iter . next ( ) ; if ( item . get Class ( ) == op . get Class ( ) ) { new Types . add ( op ) ; found = BOOL ; log . debug ( STRING + item . get Class ( ) ) ; } else { new Types . add ( item ) ; } } if ( ! found ) { new Types . add ( op ) ; log . debug ( STRING + op . get Class ( ) ) ; } operation Types = new Types ; }
private void update Types ( @ Nonnull Turnout Operation op ) { if ( ! initialized ) initialize ( ) ; Linked List < Turnout Operation > new Types = new Linked List < Turnout Operation > ( ) ; Iterator < Turnout Operation > iter = operation Types . iterator ( ) ; boolean found = BOOL ; while ( iter . has Next ( ) ) { Turnout Operation item = iter . next ( ) ; if ( item . get Class ( ) == op . get Class ( ) ) { new Types . add ( op ) ; found = BOOL ; log . debug ( STRING + item . get Class ( ) ) ; } else { new Types . add ( item ) ; } } if ( ! found ) { new Types . add ( op ) ; log . debug ( STRING + op . get Class ( ) ) ; } operation Types = new Types ; }
private void update Types ( @ Nonnull Turnout Operation op ) { if ( ! initialized ) initialize ( ) ; Linked List < Turnout Operation > new Types = new Linked List < Turnout Operation > ( ) ; Iterator < Turnout Operation > iter = operation Types . iterator ( ) ; boolean found = BOOL ; while ( iter . has Next ( ) ) { Turnout Operation item = iter . next ( ) ; if ( item . get Class ( ) == op . get Class ( ) ) { new Types . add ( op ) ; found = BOOL ; log . debug ( STRING + item . get Class ( ) ) ; } else { new Types . add ( item ) ; } } if ( ! found ) { new Types . add ( op ) ; log . debug ( STRING + op . get Class ( ) ) ; } operation Types = new Types ; }
public static String human Readable Int ( long number ) { long abs Number = Math . abs ( number ) ; double result = number ; String suffix = STRING ; if ( abs Number < NUM ) { } else if ( abs Number < NUM * NUM ) { result = number / NUM ; suffix = STRING ; } else if ( abs Number < NUM * NUM * NUM ) { result = number / ( NUM * NUM ) ; suffix = STRING ; } else { result = number / ( NUM * NUM * NUM ) ; suffix = STRING ; } return one Decimal . format ( result ) + suffix ; }
public static String human Readable Int ( long number ) { long abs Number = Math . abs ( number ) ; double result = number ; String suffix = STRING ; if ( abs Number < NUM ) { } else if ( abs Number < NUM * NUM ) { result = number / NUM ; suffix = STRING ; } else if ( abs Number < NUM * NUM * NUM ) { result = number / ( NUM * NUM ) ; suffix = STRING ; } else { result = number / ( NUM * NUM * NUM ) ; suffix = STRING ; } return one Decimal . format ( result ) + suffix ; }
public void invoke Hook Emit ( List < Object > values , String stream , Collection < Integer > out Tasks ) { if ( task Hooks . size ( ) != NUM ) { Emit Info emit Info = new Emit Info ( values , stream , get This Task Id ( ) , out Tasks ) ; for ( I Task Hook task Hook : task Hooks ) { task Hook . emit ( emit Info ) ; } } }
public void invoke Hook Emit ( List < Object > values , String stream , Collection < Integer > out Tasks ) { if ( task Hooks . size ( ) != NUM ) { Emit Info emit Info = new Emit Info ( values , stream , get This Task Id ( ) , out Tasks ) ; for ( I Task Hook task Hook : task Hooks ) { task Hook . emit ( emit Info ) ; } } }
private Object query Command Value ( final String command Identifier ) { Check . not Null ( command Identifier , STRING ) ; final String Buffer cmd = new String Buffer ( ) ; cmd . append ( STRING ) ; cmd . append ( command Identifier ) ; cmd . append ( STRING ) ; return browser . evaluate ( cmd . to String ( ) ) ; }
public void invalidate Visual State ( ) { arguments . for Each ( null ) ; result . invalidate Visual State ( ) ; }
public static String load Last Color ( Context context ) { try { Shared Preferences shared Preferences = context . get Shared Preferences ( STRING , Context . MODE PRIVATE ) ; String s = shared Preferences . get String ( SP KEY LAST COLOR , null ) ; Color . parse Color ( s ) ; return s ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return null ; } }
public Core Descriptor ( Core Container container , String name , String instance Dir , Properties core Props , Solr Params params ) { this . core Container = container ; original Core Properties . set Property ( CORE NAME , name ) ; original Core Properties . set Property ( CORE INSTDIR , instance Dir ) ; Properties container Properties = container . get Container Properties ( ) ; name = Properties Util . substitute Property ( check Property Is Not Empty ( name , CORE NAME ) , container Properties ) ; instance Dir = Properties Util . substitute Property ( check Property Is Not Empty ( instance Dir , CORE INSTDIR ) , container Properties ) ; core Properties . put All ( default Properties ) ; core Properties . put ( CORE NAME , name ) ; core Properties . put ( CORE INSTDIR , instance Dir ) ; core Properties . put ( CORE ABS INSTDIR , convert To Absolute ( instance Dir , container . get Core Root Directory ( ) ) ) ; for ( String propname : core Props . string Property Names ( ) ) { String propvalue = core Props . get Property ( propname ) ; if ( is User Defined Property ( propname ) ) original Extra Properties . put ( propname , propvalue ) ; else original Core Properties . put ( propname , propvalue ) ; if ( ! required Properties . contains ( propname ) ) core Properties . set Property ( propname , Properties Util . substitute Property ( propvalue , container Properties ) ) ; } load Extra Properties ( ) ; build Substitutable Properties ( ) ; if ( container . is Zoo Keeper Aware ( ) ) { cloud Desc = new Cloud Descriptor ( name , core Properties , this ) ; if ( params != null ) { cloud Desc . set Params ( params ) ; } } else { cloud Desc = null ; } }
@ Override public void assert Equals ( String message , Object expected Obj , Object actual Obj ) { ANOVA Matrix expected = ( ANOVA Matrix ) expected Obj ; ANOVA Matrix actual = ( ANOVA Matrix ) actual Obj ; message = message + STRING + actual . get Source ( ) + STRING ; double [ ] [ ] expected Probabilities = expected . get Probabilities ( ) ; double [ ] [ ] actual Probabilities = actual . get Probabilities ( ) ; for ( int i = NUM ; i < expected Probabilities . length ; i ++ ) { for ( int j = NUM ; j < expected Probabilities [ i ] . length ; j ++ ) { Assert . assert Equals ( message + STRING , expected Probabilities [ i ] [ j ] , actual Probabilities [ i ] [ j ] , NUM ) ; } } Assert . assert Equals ( message + STRING , expected . get Significance Level ( ) , actual . get Significance Level ( ) , NUM ) ; }
private float [ ] calc Border Values ( ) { float max = Integer . MIN VALUE ; float min = Integer . MAX VALUE ; for ( Chart Set set : chart View . data ) { for ( Chart Entry e : set . get Entries ( ) ) { if ( e . get Value ( ) >= max ) max = e . get Value ( ) ; if ( e . get Value ( ) <= min ) min = e . get Value ( ) ; } } return new float [ ] { min , max } ; }
public static void max Connections ( final int max Connections ) { set Property ( STRING , Integer . to String ( max Connections ) ) ; }
private Internal Distributed Member wait For Node Or Create Bucket ( Retry Time Keeper retry Time , Entry Event Impl event , Integer bucket Id ) { Internal Distributed Member new Node ; if ( retry Time . over Maximum ( ) ) { PRHA Redundancy Provider . timed Out ( this , null , null , STRING , retry Time . get Retry Time ( ) ) ; } retry Time . wait For Buckets Recovery ( ) ; new Node = get Node For Bucket Write ( bucket Id . int Value ( ) , retry Time ) ; if ( new Node == null ) { new Node = create Bucket ( bucket Id . int Value ( ) , get Entry Size ( event ) , retry Time ) ; } return new Node ; }
private Internal Distributed Member wait For Node Or Create Bucket ( Retry Time Keeper retry Time , Entry Event Impl event , Integer bucket Id ) { Internal Distributed Member new Node ; if ( retry Time . over Maximum ( ) ) { PRHA Redundancy Provider . timed Out ( this , null , null , STRING , retry Time . get Retry Time ( ) ) ; } retry Time . wait For Buckets Recovery ( ) ; new Node = get Node For Bucket Write ( bucket Id . int Value ( ) , retry Time ) ; if ( new Node == null ) { new Node = create Bucket ( bucket Id . int Value ( ) , get Entry Size ( event ) , retry Time ) ; } return new Node ; }
private Internal Distributed Member wait For Node Or Create Bucket ( Retry Time Keeper retry Time , Entry Event Impl event , Integer bucket Id ) { Internal Distributed Member new Node ; if ( retry Time . over Maximum ( ) ) { PRHA Redundancy Provider . timed Out ( this , null , null , STRING , retry Time . get Retry Time ( ) ) ; } retry Time . wait For Buckets Recovery ( ) ; new Node = get Node For Bucket Write ( bucket Id . int Value ( ) , retry Time ) ; if ( new Node == null ) { new Node = create Bucket ( bucket Id . int Value ( ) , get Entry Size ( event ) , retry Time ) ; } return new Node ; }
private Internal Distributed Member wait For Node Or Create Bucket ( Retry Time Keeper retry Time , Entry Event Impl event , Integer bucket Id ) { Internal Distributed Member new Node ; if ( retry Time . over Maximum ( ) ) { PRHA Redundancy Provider . timed Out ( this , null , null , STRING , retry Time . get Retry Time ( ) ) ; } retry Time . wait For Buckets Recovery ( ) ; new Node = get Node For Bucket Write ( bucket Id . int Value ( ) , retry Time ) ; if ( new Node == null ) { new Node = create Bucket ( bucket Id . int Value ( ) , get Entry Size ( event ) , retry Time ) ; } return new Node ; }
public Coap Client ( URI uri ) { this ( uri . to String ( ) ) ; }
public void do Open ( ) { }
private void check Not Equal ( Unknown Field Set s1 , Unknown Field Set s2 ) { String equals Error = String . format ( STRING , s1 , s2 ) ; assert False ( equals Error , s1 . equals ( s2 ) ) ; assert False ( equals Error , s2 . equals ( s1 ) ) ; assert False ( String . format ( STRING , s1 , s2 ) , s1 . hash Code ( ) == s2 . hash Code ( ) ) ; }
private void check Not Equal ( Unknown Field Set s1 , Unknown Field Set s2 ) { String equals Error = String . format ( STRING , s1 , s2 ) ; assert False ( equals Error , s1 . equals ( s2 ) ) ; assert False ( equals Error , s2 . equals ( s1 ) ) ; assert False ( String . format ( STRING , s1 , s2 ) , s1 . hash Code ( ) == s2 . hash Code ( ) ) ; }
private void check Not Equal ( Unknown Field Set s1 , Unknown Field Set s2 ) { String equals Error = String . format ( STRING , s1 , s2 ) ; assert False ( equals Error , s1 . equals ( s2 ) ) ; assert False ( equals Error , s2 . equals ( s1 ) ) ; assert False ( String . format ( STRING , s1 , s2 ) , s1 . hash Code ( ) == s2 . hash Code ( ) ) ; }
private boolean may Access ( Player player , Entity entity , RP Action action ) { if ( entity == null ) { return BOOL ; } RP Object object = entity . get Container ( ) ; if ( object == null ) { return BOOL ; } RP Slot slot = entity . get Container Slot ( ) ; if ( ! reorderable Slots . contains ( slot . get Name ( ) ) ) { return BOOL ; } if ( slot instanceof Entity Slot ) { if ( ! is Reachable Slot ( player , slot ) ) { return BOOL ; } } else if ( object != player ) { return BOOL ; } do { if ( object instanceof Player ) { if ( object != player ) { logger . error ( STRING + player . get Name ( ) + STRING + action ) ; return BOOL ; } } slot = object . get Container Slot ( ) ; if ( ( slot != null ) && is Reachable Slot ( player , slot ) ) { return BOOL ; } if ( object instanceof Corpse ) { return BOOL ; } object = object . get Container ( ) ; } while ( object != null ) ; return BOOL ; }
private boolean may Access ( Player player , Entity entity , RP Action action ) { if ( entity == null ) { return BOOL ; } RP Object object = entity . get Container ( ) ; if ( object == null ) { return BOOL ; } RP Slot slot = entity . get Container Slot ( ) ; if ( ! reorderable Slots . contains ( slot . get Name ( ) ) ) { return BOOL ; } if ( slot instanceof Entity Slot ) { if ( ! is Reachable Slot ( player , slot ) ) { return BOOL ; } } else if ( object != player ) { return BOOL ; } do { if ( object instanceof Player ) { if ( object != player ) { logger . error ( STRING + player . get Name ( ) + STRING + action ) ; return BOOL ; } } slot = object . get Container Slot ( ) ; if ( ( slot != null ) && is Reachable Slot ( player , slot ) ) { return BOOL ; } if ( object instanceof Corpse ) { return BOOL ; } object = object . get Container ( ) ; } while ( object != null ) ; return BOOL ; }
private boolean may Access ( Player player , Entity entity , RP Action action ) { if ( entity == null ) { return BOOL ; } RP Object object = entity . get Container ( ) ; if ( object == null ) { return BOOL ; } RP Slot slot = entity . get Container Slot ( ) ; if ( ! reorderable Slots . contains ( slot . get Name ( ) ) ) { return BOOL ; } if ( slot instanceof Entity Slot ) { if ( ! is Reachable Slot ( player , slot ) ) { return BOOL ; } } else if ( object != player ) { return BOOL ; } do { if ( object instanceof Player ) { if ( object != player ) { logger . error ( STRING + player . get Name ( ) + STRING + action ) ; return BOOL ; } } slot = object . get Container Slot ( ) ; if ( ( slot != null ) && is Reachable Slot ( player , slot ) ) { return BOOL ; } if ( object instanceof Corpse ) { return BOOL ; } object = object . get Container ( ) ; } while ( object != null ) ; return BOOL ; }
public static void stop ( Thread thread ) { if ( thread != null ) { thread . interrupt ( ) ; } }
public static void stop ( Thread thread ) { if ( thread != null ) { thread . interrupt ( ) ; } }
protected void on Before Start ( Bundle Context ctx ) { }
protected void on Before Start ( Bundle Context ctx ) { }
public Check Box List ( ) { this ( null ) ; }
public Check Box List ( ) { this ( null ) ; }
public Message Channel create Message Channel ( SIP Request request , Message Processor mp , Hop next Hop ) throws IO Exception { Host target Host = new Host ( ) ; target Host . set Hostname ( next Hop . get Host ( ) ) ; Host Port target Host Port = new Host Port ( ) ; target Host Port . set Host ( target Host ) ; target Host Port . set Port ( next Hop . get Port ( ) ) ; Message Channel return Channel = mp . create Message Channel ( target Host Port ) ; return return Channel ; }
public Message Channel create Message Channel ( SIP Request request , Message Processor mp , Hop next Hop ) throws IO Exception { Host target Host = new Host ( ) ; target Host . set Hostname ( next Hop . get Host ( ) ) ; Host Port target Host Port = new Host Port ( ) ; target Host Port . set Host ( target Host ) ; target Host Port . set Port ( next Hop . get Port ( ) ) ; Message Channel return Channel = mp . create Message Channel ( target Host Port ) ; return return Channel ; }
public Message Channel create Message Channel ( SIP Request request , Message Processor mp , Hop next Hop ) throws IO Exception { Host target Host = new Host ( ) ; target Host . set Hostname ( next Hop . get Host ( ) ) ; Host Port target Host Port = new Host Port ( ) ; target Host Port . set Host ( target Host ) ; target Host Port . set Port ( next Hop . get Port ( ) ) ; Message Channel return Channel = mp . create Message Channel ( target Host Port ) ; return return Channel ; }
public Message Channel create Message Channel ( SIP Request request , Message Processor mp , Hop next Hop ) throws IO Exception { Host target Host = new Host ( ) ; target Host . set Hostname ( next Hop . get Host ( ) ) ; Host Port target Host Port = new Host Port ( ) ; target Host Port . set Host ( target Host ) ; target Host Port . set Port ( next Hop . get Port ( ) ) ; Message Channel return Channel = mp . create Message Channel ( target Host Port ) ; return return Channel ; }
public Message Channel create Message Channel ( SIP Request request , Message Processor mp , Hop next Hop ) throws IO Exception { Host target Host = new Host ( ) ; target Host . set Hostname ( next Hop . get Host ( ) ) ; Host Port target Host Port = new Host Port ( ) ; target Host Port . set Host ( target Host ) ; target Host Port . set Port ( next Hop . get Port ( ) ) ; Message Channel return Channel = mp . create Message Channel ( target Host Port ) ; return return Channel ; }
public static void reset File States ( List < File State > file States ) { for ( Iterator < File State > iter = file States . iterator ( ) ; iter . has Next ( ) ; ) { File State file State = iter . next ( ) ; if ( file State . get Modification ( ) == deleted ) { iter . remove ( ) ; } else { file State . set Modification ( null ) ; file State . set Previous File State ( null ) ; } } }
public static boolean is Hot Spot ( ) { return jvm Impl Name . contains ( STRING ) ; }
public void run Program ( ) { if ( ( running Thread == null ) && ! running ) { running = BOOL ; running Thread = new Thread ( this ) ; running Thread . start ( ) ; } }
public void run Program ( ) { if ( ( running Thread == null ) && ! running ) { running = BOOL ; running Thread = new Thread ( this ) ; running Thread . start ( ) ; } }
public void run Program ( ) { if ( ( running Thread == null ) && ! running ) { running = BOOL ; running Thread = new Thread ( this ) ; running Thread . start ( ) ; } }
public void run Program ( ) { if ( ( running Thread == null ) && ! running ) { running = BOOL ; running Thread = new Thread ( this ) ; running Thread . start ( ) ; } }
public boolean equals Ignore Source ( Country country ) { return country != null && m Country Iso . equals ( country . get Country Iso ( ) ) ; }
public boolean equals Ignore Source ( Country country ) { return country != null && m Country Iso . equals ( country . get Country Iso ( ) ) ; }
public void write ( byte [ ] content ) throws IO Exception { out . write ( content ) ; }
public void subscriber ( Class < ? > api , @ Pin Service Ref Amp service Ref , Result < ? super Cancel > result ) { String path = api . get Name ( ) ; String address = address ( path ) ; Event Node Asset node = lookup Pub Sub Node ( address ) ; Cancel cancel = node . subscribe Impl ( service Ref ) ; result . ok ( cancel ) ; }
public void add List Listener ( Action Listener a ) { listeners . add ( a ) ; }
public void add List Listener ( Action Listener a ) { listeners . add ( a ) ; }
public void add List Listener ( Action Listener a ) { listeners . add ( a ) ; }
public void add List Listener ( Action Listener a ) { listeners . add ( a ) ; }
public void add List Listener ( Action Listener a ) { listeners . add ( a ) ; }
public void add List Listener ( Action Listener a ) { listeners . add ( a ) ; }
public void add List Listener ( Action Listener a ) { listeners . add ( a ) ; }
public void add List Listener ( Action Listener a ) { listeners . add ( a ) ; }
public void add List Listener ( Action Listener a ) { listeners . add ( a ) ; }
static int exclusive Count ( int c ) { return c & EXCLUSIVE MASK ; }
static int exclusive Count ( int c ) { return c & EXCLUSIVE MASK ; }
static int exclusive Count ( int c ) { return c & EXCLUSIVE MASK ; }
public Z Wave Multi Instance Command Class ( Z Wave Node node , Z Wave Controller controller , Z Wave Endpoint endpoint ) { super ( node , controller , endpoint ) ; version Max = MAX SUPPORTED VERSION ; }
private void prepare Data Set ( ) { data Set 1 = Arrays . as List ( new String [ ] { STRING , STRING } ) ; data Set 2 = Arrays . as List ( new String [ ] { STRING , STRING } ) ; data Set 3 = Arrays . as List ( new String [ ] { STRING , STRING } ) ; }
@ Override public void reset Options ( ) { super . reset Options ( ) ; set Retrieval ( NONE ) ; try { if ( m Data Base Connection != null && m Data Base Connection . is Connected ( ) ) { m Data Base Connection . disconnect From Database ( ) ; } m Data Base Connection = new Database Connection ( ) ; } catch ( Exception ex ) { print Exception ( ex ) ; } m URL = m Data Base Connection . get Database URL ( ) ; m table Name = STRING ; m Username = m Data Base Connection . get Username ( ) ; m Password = m Data Base Connection . get Password ( ) ; m count = NUM ; m id = BOOL ; m tab Name = BOOL ; }
private static String translate OS Name To Folder Name ( String os Name ) { if ( os Name . contains ( STRING ) ) { return STRING ; } else if ( os Name . contains ( STRING ) ) { return STRING ; } else if ( os Name . contains ( STRING ) ) { return STRING ; } else if ( os Name . contains ( STRING ) ) { return STRING ; } else { return os Name . replace All ( STRING , STRING ) ; } }
private static String translate OS Name To Folder Name ( String os Name ) { if ( os Name . contains ( STRING ) ) { return STRING ; } else if ( os Name . contains ( STRING ) ) { return STRING ; } else if ( os Name . contains ( STRING ) ) { return STRING ; } else if ( os Name . contains ( STRING ) ) { return STRING ; } else { return os Name . replace All ( STRING , STRING ) ; } }
public void append Item To Service ( int service , Ecu Data Item new Item ) { Hash Map < Integer , Vector < Ecu Data Item > > curr Svc = get ( service ) ; if ( curr Svc == null ) { curr Svc = new Hash Map < Integer , Vector < Ecu Data Item > > ( ) ; log . debug ( STRING + service + STRING + curr Svc ) ; } Vector < Ecu Data Item > curr Vec = curr Svc . get ( new Item . pid ) ; if ( curr Vec == null ) { curr Vec = new Vector < Ecu Data Item > ( ) ; log . debug ( STRING + new Item . pid + STRING + curr Vec ) ; } curr Vec . add ( new Item ) ; curr Svc . put ( new Item . pid , curr Vec ) ; put ( service , curr Svc ) ; log . debug ( STRING + service + STRING + String . format ( STRING , new Item . pid ) + STRING + curr Vec ) ; }
String prepare Data Entry Form For Entry ( String html Code , Collection < Tracked Entity Data Value > data Values , I18 n i18 n , Program Stage program Stage , Program Stage Instance program Stage Instance , Organisation Unit organisation Unit ) ;
String prepare Data Entry Form For Entry ( String html Code , Collection < Tracked Entity Data Value > data Values , I18 n i18 n , Program Stage program Stage , Program Stage Instance program Stage Instance , Organisation Unit organisation Unit ) ;
String prepare Data Entry Form For Entry ( String html Code , Collection < Tracked Entity Data Value > data Values , I18 n i18 n , Program Stage program Stage , Program Stage Instance program Stage Instance , Organisation Unit organisation Unit ) ;
@ Override public void after Properties Set ( ) throws Exception { registered Process . add ( this ) ; }
@ Override public void after Properties Set ( ) throws Exception { registered Process . add ( this ) ; }
public void test Get Servlet Names For Jsp File With Single Servlet ( ) throws Exception { String xml = WEBAPP TEST HEADER + STRING + STRING + STRING + STRING + STRING ; Web Xml web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( xml . get Bytes ( STRING ) ) , get Entity Resolver ( ) ) ; List < String > servlet Names = Web Xml Utils . get Servlet Names For Jsp File ( web Xml , STRING ) ; assert Equals ( NUM , servlet Names . size ( ) ) ; assert Equals ( STRING , servlet Names . get ( NUM ) ) ; }
public void test Get Servlet Names For Jsp File With Single Servlet ( ) throws Exception { String xml = WEBAPP TEST HEADER + STRING + STRING + STRING + STRING + STRING ; Web Xml web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( xml . get Bytes ( STRING ) ) , get Entity Resolver ( ) ) ; List < String > servlet Names = Web Xml Utils . get Servlet Names For Jsp File ( web Xml , STRING ) ; assert Equals ( NUM , servlet Names . size ( ) ) ; assert Equals ( STRING , servlet Names . get ( NUM ) ) ; }
public void test Get Servlet Names For Jsp File With Single Servlet ( ) throws Exception { String xml = WEBAPP TEST HEADER + STRING + STRING + STRING + STRING + STRING ; Web Xml web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( xml . get Bytes ( STRING ) ) , get Entity Resolver ( ) ) ; List < String > servlet Names = Web Xml Utils . get Servlet Names For Jsp File ( web Xml , STRING ) ; assert Equals ( NUM , servlet Names . size ( ) ) ; assert Equals ( STRING , servlet Names . get ( NUM ) ) ; }
public void test Get Servlet Names For Jsp File With Single Servlet ( ) throws Exception { String xml = WEBAPP TEST HEADER + STRING + STRING + STRING + STRING + STRING ; Web Xml web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( xml . get Bytes ( STRING ) ) , get Entity Resolver ( ) ) ; List < String > servlet Names = Web Xml Utils . get Servlet Names For Jsp File ( web Xml , STRING ) ; assert Equals ( NUM , servlet Names . size ( ) ) ; assert Equals ( STRING , servlet Names . get ( NUM ) ) ; }
public void add Value ( int count , String string Representation ) { values . add ( new Unique Value ( count , string Representation ) ) ; }
public static Date parse XS Date ( String date Str , Time Zone default Time Zone , Calendar Fields To Date Converter cal To Date Converter ) throws Date Parse Exception { Matcher m = PATTERN XS DATE . matcher ( date Str ) ; if ( ! m . matches ( ) ) { throw new Date Parse Exception ( STRING + PATTERN XS DATE ) ; } return parse Date parse Matcher ( m , default Time Zone , BOOL , cal To Date Converter ) ; }
public boolean is Interlaced ( ) { return interlaced ; }
public synchronized void end ( Component component ) { this . active = BOOL ; this . offset = null ; this . begin Position = null ; component . set Cursor ( Cursor . get Predefined Cursor ( Cursor . DEFAULT CURSOR ) ) ; }
public void store Session ( User Session session ) { sessions . add ( session ) ; }
public void test Many Connections Using One Thread ( ) { try { int max Connections = get Connection Num ( ) ; open Connections ( max Connections ) ; assert Equals ( STRING , max Connections , vc . size ( ) ) ; } catch ( Exception e ) { fail ( STRING + e . to String ( ) ) ; } }
@ Override public State Connection on Close Read ( ) { Connection Protocol request = request ( ) ; if ( request != null ) { request . on Close Read ( ) ; } sequence Close . set ( sequence Read . get ( ) ) ; if ( sequence Flush . get ( ) < sequence Close . get ( ) ) { is Close Pending . set ( BOOL ) ; if ( sequence Flush . get ( ) < sequence Close . get ( ) ) { return State Connection . CLOSE READ S ; } else { is Close Pending . set ( BOOL ) ; return State Connection . CLOSE ; } } else { return State Connection . CLOSE ; } }
@ Override public State Connection on Close Read ( ) { Connection Protocol request = request ( ) ; if ( request != null ) { request . on Close Read ( ) ; } sequence Close . set ( sequence Read . get ( ) ) ; if ( sequence Flush . get ( ) < sequence Close . get ( ) ) { is Close Pending . set ( BOOL ) ; if ( sequence Flush . get ( ) < sequence Close . get ( ) ) { return State Connection . CLOSE READ S ; } else { is Close Pending . set ( BOOL ) ; return State Connection . CLOSE ; } } else { return State Connection . CLOSE ; } }
@ Override public Iterator < T > iterator ( ) { return buffer . descending Iterator ( ) ; }
@ Override public Iterator < T > iterator ( ) { return buffer . descending Iterator ( ) ; }
@ Override public Iterator < T > iterator ( ) { return buffer . descending Iterator ( ) ; }
@ Override public Iterator < T > iterator ( ) { return buffer . descending Iterator ( ) ; }
@ Override public Iterator < T > iterator ( ) { return buffer . descending Iterator ( ) ; }
@ Override public Iterator < T > iterator ( ) { return buffer . descending Iterator ( ) ; }
@ Override public Iterator < T > iterator ( ) { return buffer . descending Iterator ( ) ; }
public void received ( Byte Buffer buffer ) { has Received Data = BOOL ; last Receive Time = System . current Time Millis ( ) ; }
public static Tuple Expr process ( Tuple Expr query , List < External Tuple Set > index Set ) { boolean index Placed = BOOL ; Tuple Expr rtn = query . clone ( ) ; Query Node Count qnc = new Query Node Count ( ) ; rtn . visit ( qnc ) ; if ( qnc . get Node Count ( ) / NUM < index Set . size ( ) ) { return null ; } organize BS As ( rtn ) ; if ( is Tuple Valid ( rtn ) ) { for ( External Tuple Set index : index Set ) { if ( is Tuple Valid ( index . get Tuple Expr ( ) ) ) { External Tuple Set e Tup = ( External Tuple Set ) index . clone ( ) ; SP Bubble Down Visitor index Vistor = new SP Bubble Down Visitor ( e Tup ) ; rtn . visit ( index Vistor ) ; Filter Bubble Manager fbmv = new Filter Bubble Manager ( e Tup ) ; rtn . visit ( fbmv ) ; Subset Equals Visitor sub Index Vis = new Subset Equals Visitor ( e Tup , rtn ) ; rtn . visit ( sub Index Vis ) ; index Placed = sub Index Vis . index Placed ( ) ; if ( ! index Placed ) { break ; } } } if ( index Placed ) { return rtn ; } else { return null ; } } else { throw new Illegal Argument Exception ( STRING ) ; } }
public static Tuple Expr process ( Tuple Expr query , List < External Tuple Set > index Set ) { boolean index Placed = BOOL ; Tuple Expr rtn = query . clone ( ) ; Query Node Count qnc = new Query Node Count ( ) ; rtn . visit ( qnc ) ; if ( qnc . get Node Count ( ) / NUM < index Set . size ( ) ) { return null ; } organize BS As ( rtn ) ; if ( is Tuple Valid ( rtn ) ) { for ( External Tuple Set index : index Set ) { if ( is Tuple Valid ( index . get Tuple Expr ( ) ) ) { External Tuple Set e Tup = ( External Tuple Set ) index . clone ( ) ; SP Bubble Down Visitor index Vistor = new SP Bubble Down Visitor ( e Tup ) ; rtn . visit ( index Vistor ) ; Filter Bubble Manager fbmv = new Filter Bubble Manager ( e Tup ) ; rtn . visit ( fbmv ) ; Subset Equals Visitor sub Index Vis = new Subset Equals Visitor ( e Tup , rtn ) ; rtn . visit ( sub Index Vis ) ; index Placed = sub Index Vis . index Placed ( ) ; if ( ! index Placed ) { break ; } } } if ( index Placed ) { return rtn ; } else { return null ; } } else { throw new Illegal Argument Exception ( STRING ) ; } }
@ Override public void save Results ( ) { helper . write Scenes To Jaif ( ) ; }
public static String gensalt ( final int log rounds , final Secure Random random ) { final String Buffer rs = new String Buffer ( ) ; final byte rnd [ ] = new byte [ BCRYPT SALT LEN ] ; random . next Bytes ( rnd ) ; rs . append ( STRING ) ; if ( log rounds < NUM ) { rs . append ( STRING ) ; } if ( log rounds > NUM ) { throw new Illegal Argument Exception ( STRING ) ; } rs . append ( Integer . to String ( log rounds ) ) ; rs . append ( STRING ) ; rs . append ( encode base 64 ( rnd , rnd . length ) ) ; return rs . to String ( ) ; }
public void replace ( Class Node type , int n ) { remove ( n ) ; push ( type ) ; }
protected Replaced Element lookup Image Replaced Element ( Element e ) { if ( image Components . size ( ) == NUM ) { return null ; } Replaced Element replaced Element = ( Replaced Element ) image Components . get ( e ) ; return replaced Element ; }
byte dir Type Backward ( ) { last Char = text . char At ( char Index - NUM ) ; if ( Character . is Low Surrogate ( last Char ) ) { int code Point = Character . code Point Before ( text , char Index ) ; char Index -= Character . char Count ( code Point ) ; return Character . get Directionality ( code Point ) ; } char Index -- ; byte dir Type = get Cached Directionality ( last Char ) ; if ( is Html ) { if ( last Char == STRING ) { dir Type = skip Tag Backward ( ) ; } else if ( last Char == STRING ) { dir Type = skip Entity Backward ( ) ; } } return dir Type ; }
byte dir Type Backward ( ) { last Char = text . char At ( char Index - NUM ) ; if ( Character . is Low Surrogate ( last Char ) ) { int code Point = Character . code Point Before ( text , char Index ) ; char Index -= Character . char Count ( code Point ) ; return Character . get Directionality ( code Point ) ; } char Index -- ; byte dir Type = get Cached Directionality ( last Char ) ; if ( is Html ) { if ( last Char == STRING ) { dir Type = skip Tag Backward ( ) ; } else if ( last Char == STRING ) { dir Type = skip Entity Backward ( ) ; } } return dir Type ; }
public void validate Item ( final Element item Element ) { hide ( ) ; }
public void add All Searchables ( Array List < ? extends Search Result > searchable ) { searchables . add All ( searchable ) ; }
public static int [ ] shuffle ( int [ ] input ) { List < Integer > vals = new Array List < Integer > ( input . length ) ; for ( int i = NUM ; i < input . length ; i ++ ) vals . add ( input [ i ] ) ; Collections . shuffle ( vals , SEEDED RANDOM ) ; int [ ] copy = new int [ input . length ] ; for ( int i = NUM ; i < input . length ; i ++ ) copy [ i ] = vals . get ( i ) ; return copy ; }
public OM Graphic List read Cached Graphics ( URL url ) throws java . io . IO Exception { if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING ) ; } OM Graphic List omgraphics = new OM Graphic List ( ) ; if ( url != null ) { omgraphics . read Graphics ( url ) ; } return omgraphics ; }
@ Suppress Warnings ( STRING ) public static < K extends Throwable > void rewrap And Throw If Instance ( String new Message , Throwable t , Class < K > clazz ) throws K { if ( ( t != null ) && clazz . is Assignable From ( t . get Class ( ) ) ) { K kt = ( K ) t ; K wrapped = Throwables . rewrap ( new Message , kt ) ; throw wrapped ; } }
@ Suppress Warnings ( STRING ) public static < K extends Throwable > void rewrap And Throw If Instance ( String new Message , Throwable t , Class < K > clazz ) throws K { if ( ( t != null ) && clazz . is Assignable From ( t . get Class ( ) ) ) { K kt = ( K ) t ; K wrapped = Throwables . rewrap ( new Message , kt ) ; throw wrapped ; } }
private void write Stuffed ( int b ) throws IO Exception { out . write ( NUM ) ; if ( b == NUM ) { out . write ( NUM ) ; } }
protected void update Host Table ( ) { final Service Score [ ] service Scores = service Table Ref . get ( ) ; final I Host Scoring Rule scoring Rule = scoring Rule Ref . get ( ) ; if ( service Scores == null || service Scores . length == NUM || scoring Rule == null ) { host Table Ref . set ( null ) ; return ; } final Map < String , I Host Metrics > host Metrics Map = get Host Report For Known Services ( scoring Rule , service Scores ) ; if ( host Metrics Map == null || host Metrics Map . is Empty ( ) ) { host Table Ref . set ( null ) ; return ; } if ( log . is Trace Enabled ( ) ) log . trace ( STRING + host Metrics Map ) ; final Host Table new Host Table = normalize Host Scores ( scoring Rule , host Metrics Map ) ; if ( log . is Trace Enabled ( ) ) log . trace ( STRING + new Host Table ) ; host Table Ref . set ( new Host Table ) ; }
protected void update Host Table ( ) { final Service Score [ ] service Scores = service Table Ref . get ( ) ; final I Host Scoring Rule scoring Rule = scoring Rule Ref . get ( ) ; if ( service Scores == null || service Scores . length == NUM || scoring Rule == null ) { host Table Ref . set ( null ) ; return ; } final Map < String , I Host Metrics > host Metrics Map = get Host Report For Known Services ( scoring Rule , service Scores ) ; if ( host Metrics Map == null || host Metrics Map . is Empty ( ) ) { host Table Ref . set ( null ) ; return ; } if ( log . is Trace Enabled ( ) ) log . trace ( STRING + host Metrics Map ) ; final Host Table new Host Table = normalize Host Scores ( scoring Rule , host Metrics Map ) ; if ( log . is Trace Enabled ( ) ) log . trace ( STRING + new Host Table ) ; host Table Ref . set ( new Host Table ) ; }
protected void update Host Table ( ) { final Service Score [ ] service Scores = service Table Ref . get ( ) ; final I Host Scoring Rule scoring Rule = scoring Rule Ref . get ( ) ; if ( service Scores == null || service Scores . length == NUM || scoring Rule == null ) { host Table Ref . set ( null ) ; return ; } final Map < String , I Host Metrics > host Metrics Map = get Host Report For Known Services ( scoring Rule , service Scores ) ; if ( host Metrics Map == null || host Metrics Map . is Empty ( ) ) { host Table Ref . set ( null ) ; return ; } if ( log . is Trace Enabled ( ) ) log . trace ( STRING + host Metrics Map ) ; final Host Table new Host Table = normalize Host Scores ( scoring Rule , host Metrics Map ) ; if ( log . is Trace Enabled ( ) ) log . trace ( STRING + new Host Table ) ; host Table Ref . set ( new Host Table ) ; }
public void add Root ( String name , File root ) { if ( Text Utils . is Empty ( name ) ) { throw new Illegal Argument Exception ( STRING ) ; } try { root = root . get Canonical File ( ) ; } catch ( IO Exception e ) { throw new Illegal Argument Exception ( STRING + root , e ) ; } m Roots . put ( name , root ) ; }
public void add Root ( String name , File root ) { if ( Text Utils . is Empty ( name ) ) { throw new Illegal Argument Exception ( STRING ) ; } try { root = root . get Canonical File ( ) ; } catch ( IO Exception e ) { throw new Illegal Argument Exception ( STRING + root , e ) ; } m Roots . put ( name , root ) ; }
public void add Root ( String name , File root ) { if ( Text Utils . is Empty ( name ) ) { throw new Illegal Argument Exception ( STRING ) ; } try { root = root . get Canonical File ( ) ; } catch ( IO Exception e ) { throw new Illegal Argument Exception ( STRING + root , e ) ; } m Roots . put ( name , root ) ; }
public void add Root ( String name , File root ) { if ( Text Utils . is Empty ( name ) ) { throw new Illegal Argument Exception ( STRING ) ; } try { root = root . get Canonical File ( ) ; } catch ( IO Exception e ) { throw new Illegal Argument Exception ( STRING + root , e ) ; } m Roots . put ( name , root ) ; }
public static char [ ] clone Char Array ( char [ ] chars ) { if ( chars == null ) { return null ; } int len = chars . length ; if ( len == NUM ) { return chars ; } char [ ] copy = new char [ len ] ; System . arraycopy ( chars , NUM , copy , NUM , len ) ; return copy ; }
public static char [ ] clone Char Array ( char [ ] chars ) { if ( chars == null ) { return null ; } int len = chars . length ; if ( len == NUM ) { return chars ; } char [ ] copy = new char [ len ] ; System . arraycopy ( chars , NUM , copy , NUM , len ) ; return copy ; }
void handle Quit Button ( ) { dir = null ; file = null ; target . hide ( ) ; }
@ Override public final int hash Code ( ) { long firsthash = Double . double To Long Bits ( first ) ; firsthash = firsthash ^ ( firsthash > > NUM ) ; long secondhash = Double . double To Long Bits ( second ) ; secondhash = secondhash ^ ( secondhash > > NUM ) ; return ( int ) ( firsthash * NUM + secondhash ) ; }
@ Override public final int hash Code ( ) { long firsthash = Double . double To Long Bits ( first ) ; firsthash = firsthash ^ ( firsthash > > NUM ) ; long secondhash = Double . double To Long Bits ( second ) ; secondhash = secondhash ^ ( secondhash > > NUM ) ; return ( int ) ( firsthash * NUM + secondhash ) ; }
@ Override public int read ( ) throws IO Exception { ensure Open ( ) ; if ( next >= length ) return - NUM ; return str . char At ( next ++ ) ; }
public static byte [ ] create Signature Algorithms Extension ( Vector supported Signature Algorithms ) throws IO Exception { Byte Array Output Stream buf = new Byte Array Output Stream ( ) ; encode Supported Signature Algorithms ( supported Signature Algorithms , BOOL , buf ) ; return buf . to Byte Array ( ) ; }
public static Spannable String Builder warp Chooser Title ( Activity context , String app Name ) { @ Suppress Lint ( STRING ) String title = String . format ( context . get String ( R . string . select transfer way apk , app Name ) ) ; Foreground Color Span font Span Red = new Foreground Color Span ( Utils . get Color Warp ( context , R . color . color Accent ) ) ; int start = NUM ; int end = start + app Name . length ( ) + NUM ; Spannable String Builder m Spannable Builder = new Spannable String Builder ( title ) ; m Spannable Builder . set Span ( font Span Red , start , end , Spanned . SPAN INCLUSIVE INCLUSIVE ) ; return m Spannable Builder ; }
public static Spannable String Builder warp Chooser Title ( Activity context , String app Name ) { @ Suppress Lint ( STRING ) String title = String . format ( context . get String ( R . string . select transfer way apk , app Name ) ) ; Foreground Color Span font Span Red = new Foreground Color Span ( Utils . get Color Warp ( context , R . color . color Accent ) ) ; int start = NUM ; int end = start + app Name . length ( ) + NUM ; Spannable String Builder m Spannable Builder = new Spannable String Builder ( title ) ; m Spannable Builder . set Span ( font Span Red , start , end , Spanned . SPAN INCLUSIVE INCLUSIVE ) ; return m Spannable Builder ; }
public void component Added ( Container Event e ) { Layer child Layer = ( Layer ) e . get Child ( ) ; add Projection Listener ( child Layer ) ; if ( ! removed Layers . remove Element ( child Layer ) ) { added Layers . add Element ( child Layer ) ; } change Layers ( e ) ; }
public void component Added ( Container Event e ) { Layer child Layer = ( Layer ) e . get Child ( ) ; add Projection Listener ( child Layer ) ; if ( ! removed Layers . remove Element ( child Layer ) ) { added Layers . add Element ( child Layer ) ; } change Layers ( e ) ; }
public void component Added ( Container Event e ) { Layer child Layer = ( Layer ) e . get Child ( ) ; add Projection Listener ( child Layer ) ; if ( ! removed Layers . remove Element ( child Layer ) ) { added Layers . add Element ( child Layer ) ; } change Layers ( e ) ; }
public void component Added ( Container Event e ) { Layer child Layer = ( Layer ) e . get Child ( ) ; add Projection Listener ( child Layer ) ; if ( ! removed Layers . remove Element ( child Layer ) ) { added Layers . add Element ( child Layer ) ; } change Layers ( e ) ; }
public void component Added ( Container Event e ) { Layer child Layer = ( Layer ) e . get Child ( ) ; add Projection Listener ( child Layer ) ; if ( ! removed Layers . remove Element ( child Layer ) ) { added Layers . add Element ( child Layer ) ; } change Layers ( e ) ; }
@ Nullable @ Worker Thread static File write Bitmap To Directory ( @ Non Null Bitmap bitmap , @ Non Null File directory ) { if ( ! directory . mkdirs ( ) && ! directory . exists ( ) ) { Log . e ( TAG , STRING ) ; return null ; } return write Bitmap To File ( bitmap , new File ( directory , create Unique Filename ( BITMAP PREFIX ) ) ) ; }
public byte [ ] encrypt Raw ( byte [ ] base Key , int usage , byte [ ] ivec , byte [ ] plaintext , int start , int len ) throws General Security Exception , Krb Crypto Exception { if ( ! Key Usage . is Valid ( usage ) ) { throw new General Security Exception ( STRING + usage ) ; } byte [ ] output = encrypt CTS ( base Key , usage , ivec , null , plaintext , start , len , BOOL ) ; return output ; }
public static String [ ] split ( String string , char c ) { if ( count Matches ( string , c ) <= NUM ) return new String [ ] { string } ; String s = string + c ; String [ ] sa = new String [ count Matches ( string , c ) + NUM ] ; String Builder sb = new String Builder ( ) ; char [ ] ca = s . to Char Array ( ) ; int n = NUM , x ; for ( x = NUM ; x < ca . length ; x ++ ) { if ( ca [ x ] == c ) { sa [ n ] = sb . to String ( ) ; sb = new String Builder ( ) ; n ++ ; } else { sb . append ( ca [ x ] ) ; } } return sa ; }
synchronized void remove ( Pg Server Thread t ) { running . remove ( t ) ; }
public boolean init Stream ( Read Stream read Stream , Read Stream raw Stream ) throws IO Exception { read Stream . init ( in Stream ) ; return BOOL ; }
public List < Pojo Field > cassandra Unique Fields ( ) { return cas Unique Fields ; }
public List < Pojo Field > cassandra Unique Fields ( ) { return cas Unique Fields ; }
public double seconds Since Start ( ) { return ( time Since Start ( ) ) / NUM ; }
private void build National Number For Parsing ( String number To Parse , String Builder national Number ) { int index Of Phone Context = number To Parse . index Of ( RFC 3966 PHONE CONTEXT ) ; if ( index Of Phone Context > NUM ) { int phone Context Start = index Of Phone Context + RFC 3966 PHONE CONTEXT . length ( ) ; if ( number To Parse . char At ( phone Context Start ) == PLUS SIGN ) { int phone Context End = number To Parse . index Of ( STRING , phone Context Start ) ; if ( phone Context End > NUM ) { national Number . append ( number To Parse . substring ( phone Context Start , phone Context End ) ) ; } else { national Number . append ( number To Parse . substring ( phone Context Start ) ) ; } } int index Of Rfc 3966 Prefix = number To Parse . index Of ( RFC 3966 PREFIX ) ; int index Of National Number = ( index Of Rfc 3966 Prefix >= NUM ) ? index Of Rfc 3966 Prefix + RFC 3966 PREFIX . length ( ) : NUM ; national Number . append ( number To Parse . substring ( index Of National Number , index Of Phone Context ) ) ; } else { national Number . append ( extract Possible Number ( number To Parse ) ) ; } int index Of Isdn = national Number . index Of ( RFC 3966 ISDN SUBADDRESS ) ; if ( index Of Isdn > NUM ) { national Number . delete ( index Of Isdn , national Number . length ( ) ) ; } }
private void build National Number For Parsing ( String number To Parse , String Builder national Number ) { int index Of Phone Context = number To Parse . index Of ( RFC 3966 PHONE CONTEXT ) ; if ( index Of Phone Context > NUM ) { int phone Context Start = index Of Phone Context + RFC 3966 PHONE CONTEXT . length ( ) ; if ( number To Parse . char At ( phone Context Start ) == PLUS SIGN ) { int phone Context End = number To Parse . index Of ( STRING , phone Context Start ) ; if ( phone Context End > NUM ) { national Number . append ( number To Parse . substring ( phone Context Start , phone Context End ) ) ; } else { national Number . append ( number To Parse . substring ( phone Context Start ) ) ; } } int index Of Rfc 3966 Prefix = number To Parse . index Of ( RFC 3966 PREFIX ) ; int index Of National Number = ( index Of Rfc 3966 Prefix >= NUM ) ? index Of Rfc 3966 Prefix + RFC 3966 PREFIX . length ( ) : NUM ; national Number . append ( number To Parse . substring ( index Of National Number , index Of Phone Context ) ) ; } else { national Number . append ( extract Possible Number ( number To Parse ) ) ; } int index Of Isdn = national Number . index Of ( RFC 3966 ISDN SUBADDRESS ) ; if ( index Of Isdn > NUM ) { national Number . delete ( index Of Isdn , national Number . length ( ) ) ; } }
public int size ( ) { return inputs . size ( ) ; }
public final boolean can Throw Exceptions ( ) { return ( flags & CAN THROW EXCEPTIONS ) != NUM ; }
public static double angle ( Number Vector v1 , Number Vector v2 , Number Vector o ) { final int dim 1 = v1 . get Dimensionality ( ) , dim 2 = v2 . get Dimensionality ( ) , dimo = o . get Dimensionality ( ) ; final int mindim = ( dim 1 <= dim 2 ) ? dim 1 : dim 2 ; double cross = NUM , l1 = NUM , l2 = NUM ; for ( int k = NUM ; k < mindim ; k ++ ) { final double ok = k < dimo ? o . double Value ( k ) : NUM ; final double r1 = v1 . double Value ( k ) - ok ; final double r2 = v2 . double Value ( k ) - ok ; cross += r1 * r2 ; l1 += r1 * r1 ; l2 += r2 * r2 ; } for ( int k = mindim ; k < dim 1 ; k ++ ) { final double ok = k < dimo ? o . double Value ( k ) : NUM ; final double r1 = v1 . double Value ( k ) - ok ; l1 += r1 * r1 ; } for ( int k = mindim ; k < dim 2 ; k ++ ) { final double ok = k < dimo ? o . double Value ( k ) : NUM ; final double r2 = v2 . double Value ( k ) - ok ; l2 += r2 * r2 ; } final double a = ( cross == NUM ) ? NUM : ( l1 == NUM || l2 == NUM ) ? NUM : Math . sqrt ( ( cross / l1 ) * ( cross / l2 ) ) ; return ( a < NUM ) ? a : NUM ; }
public static List < String > split Path ( File file ) { List < String > output = new Array List < > ( ) ; File current = file ; while ( current != null ) { output . add ( current . get Name ( ) ) ; current = current . get Parent File ( ) ; } Collections . reverse ( output ) ; return output ; }
public static List < String > split Path ( File file ) { List < String > output = new Array List < > ( ) ; File current = file ; while ( current != null ) { output . add ( current . get Name ( ) ) ; current = current . get Parent File ( ) ; } Collections . reverse ( output ) ; return output ; }
public void add Header ( @ Layout Res int layout Id ) { add Header ( layout Id , null ) ; }
public void add Header ( @ Layout Res int layout Id ) { add Header ( layout Id , null ) ; }
public void remove ( double value ) { if ( Double . is Na N ( value ) ) { return ; } int index = find Insert Index ( value ) ; if ( index == - NUM ) { throw new Illegal State Exception ( STRING ) ; } Double value At Index = values . get ( index ) ; if ( ( value At Index != null ) && ( ! value At Index . equals ( value ) ) ) { throw new Illegal State Exception ( STRING ) ; } values . remove ( index ) ; }
public final int at Ad Pos ( final int pos ) { final int take int = ( int ) Math . floor ( ( pos + NUM ) / adfrequency ) ; Log . d ( STRING , take int + STRING ) ; return take int ; }
public void add All ( T ... items ) { int start ; synchronized ( m Lock ) { start = get Item Count ( ) ; Collections . add All ( m Objects , items ) ; } if ( m Notify On Change ) notify Item Range Inserted ( start , items . length ) ; }
public void add All ( T ... items ) { int start ; synchronized ( m Lock ) { start = get Item Count ( ) ; Collections . add All ( m Objects , items ) ; } if ( m Notify On Change ) notify Item Range Inserted ( start , items . length ) ; }
public Shell Minimum Size Enforcer ( final Shell shell , final int minimum Width , final int minimum Height ) { this . shell = shell ; this . minimum Width = minimum Width ; this . minimum Height = minimum Height ; current Location = shell . get Location ( ) ; if ( ( FORCE LEGACY BEHAVIOR || ! attempt Set Minimum Size ( ) ) && ! Window System . is Current Window System ( Window System . X WINDOW SYSTEM ) ) { final Min Size Listener listener = new Min Size Listener ( ) ; shell . add Control Listener ( listener ) ; } }
private boolean is Pretty Printing Enabled ( ) { return flags . contains ( Writer Flags . PRETTY PRINT ) && ! current Element ( ) . unformatted Children ; }
private boolean is Pretty Printing Enabled ( ) { return flags . contains ( Writer Flags . PRETTY PRINT ) && ! current Element ( ) . unformatted Children ; }
private boolean is Pretty Printing Enabled ( ) { return flags . contains ( Writer Flags . PRETTY PRINT ) && ! current Element ( ) . unformatted Children ; }
public void start Document Entity ( XML Input Source xml Input Source ) throws IO Exception , XNI Exception { start Entity ( XML Entity , xml Input Source , BOOL , BOOL ) ; }
public static Connection connect Or Upgrade ( String url , Properties info ) throws SQL Exception { if ( ! UPGRADE CLASSES PRESENT ) { return null ; } Properties i2 = new Properties ( ) ; i2 . put All ( info ) ; Object o = info . get ( STRING ) ; if ( o instanceof char [ ] ) { i2 . put ( STRING , String Utils . clone Char Array ( ( char [ ] ) o ) ) ; } info = i2 ; Connection Info ci = new Connection Info ( url , info ) ; if ( ci . is Remote ( ) || ! ci . is Persistent ( ) ) { return null ; } String name = ci . get Name ( ) ; if ( File Utils . exists ( name + Constants . SUFFIX PAGE FILE ) ) { return null ; } if ( ! File Utils . exists ( name + Constants . SUFFIX OLD DATABASE FILE ) ) { return null ; } if ( ci . remove Property ( STRING , BOOL ) ) { return connect With Old Version ( url , info ) ; } synchronized ( Db Upgrade . class ) { upgrade ( ci , info ) ; return null ; } }
public static Connection connect Or Upgrade ( String url , Properties info ) throws SQL Exception { if ( ! UPGRADE CLASSES PRESENT ) { return null ; } Properties i2 = new Properties ( ) ; i2 . put All ( info ) ; Object o = info . get ( STRING ) ; if ( o instanceof char [ ] ) { i2 . put ( STRING , String Utils . clone Char Array ( ( char [ ] ) o ) ) ; } info = i2 ; Connection Info ci = new Connection Info ( url , info ) ; if ( ci . is Remote ( ) || ! ci . is Persistent ( ) ) { return null ; } String name = ci . get Name ( ) ; if ( File Utils . exists ( name + Constants . SUFFIX PAGE FILE ) ) { return null ; } if ( ! File Utils . exists ( name + Constants . SUFFIX OLD DATABASE FILE ) ) { return null ; } if ( ci . remove Property ( STRING , BOOL ) ) { return connect With Old Version ( url , info ) ; } synchronized ( Db Upgrade . class ) { upgrade ( ci , info ) ; return null ; } }
protected Grid Client start Client ( String addr , int port ) throws Grid Client Exception { Grid Client Configuration cli Cfg = new Grid Client Configuration ( ) ; cli Cfg . set Servers ( Collections . singleton ( addr + STRING + port ) ) ; cli Cfg . set Protocol ( protocol ( ) ) ; return Grid Client Factory . start ( cli Cfg ) ; }
public int compare ( String o1 , String o2 ) { return o1 . compare To Ignore Case ( o2 ) ; }
private Digicore Chain clean Chain ( Digicore Chain chain ) { return chain ; }
private Digicore Chain clean Chain ( Digicore Chain chain ) { return chain ; }
private Digicore Chain clean Chain ( Digicore Chain chain ) { return chain ; }
public static boolean is Cache Safe ( Class < ? > clazz , Class Loader class Loader ) { Assert . not Null ( clazz , STRING ) ; try { Class Loader target = clazz . get Class Loader ( ) ; if ( target == null ) { return BOOL ; } Class Loader cur = class Loader ; if ( cur == target ) { return BOOL ; } while ( cur != null ) { cur = cur . get Parent ( ) ; if ( cur == target ) { return BOOL ; } } return BOOL ; } catch ( Security Exception ex ) { return BOOL ; } }
public static boolean is Cache Safe ( Class < ? > clazz , Class Loader class Loader ) { Assert . not Null ( clazz , STRING ) ; try { Class Loader target = clazz . get Class Loader ( ) ; if ( target == null ) { return BOOL ; } Class Loader cur = class Loader ; if ( cur == target ) { return BOOL ; } while ( cur != null ) { cur = cur . get Parent ( ) ; if ( cur == target ) { return BOOL ; } } return BOOL ; } catch ( Security Exception ex ) { return BOOL ; } }
public static void copy ( Resource in , Output Stream os , boolean close OS ) throws IO Exception { Input Stream is = null ; try { is = to Buffered Input Stream ( in . get Input Stream ( ) ) ; } catch ( IO Exception ioe ) { IO Util . close EL ( is ) ; throw ioe ; } copy ( is , os , BOOL , close OS ) ; }
public static void copy ( Resource in , Output Stream os , boolean close OS ) throws IO Exception { Input Stream is = null ; try { is = to Buffered Input Stream ( in . get Input Stream ( ) ) ; } catch ( IO Exception ioe ) { IO Util . close EL ( is ) ; throw ioe ; } copy ( is , os , BOOL , close OS ) ; }
public Instances resample ( Random random ) { Instances new Data = new Instances ( this , num Instances ( ) ) ; while ( new Data . num Instances ( ) < num Instances ( ) ) { new Data . add ( instance ( random . next Int ( num Instances ( ) ) ) ) ; } return new Data ; }
public Instances resample ( Random random ) { Instances new Data = new Instances ( this , num Instances ( ) ) ; while ( new Data . num Instances ( ) < num Instances ( ) ) { new Data . add ( instance ( random . next Int ( num Instances ( ) ) ) ) ; } return new Data ; }
public Instances resample ( Random random ) { Instances new Data = new Instances ( this , num Instances ( ) ) ; while ( new Data . num Instances ( ) < num Instances ( ) ) { new Data . add ( instance ( random . next Int ( num Instances ( ) ) ) ) ; } return new Data ; }
protected abstract void store Body ( Data Output Stream dos ) throws IO Exception ;
protected abstract void store Body ( Data Output Stream dos ) throws IO Exception ;
public static void add ( Object spy ) { SPIES . add ( spy ) ; }
public void add Cell ( groovy . swing . impl . Table Layout Cell tag ) { int gridx = NUM ; for ( Iterator iter = cells . iterator ( ) ; iter . has Next ( ) ; ) { groovy . swing . impl . Table Layout Cell cell = ( groovy . swing . impl . Table Layout Cell ) iter . next ( ) ; gridx += cell . get Colspan ( ) ; } tag . get Constraints ( ) . gridx = gridx ; cells . add ( tag ) ; }
public void find And Init ( Object some Obj ) { if ( some Obj instanceof Mouse Delegator ) { Debug . message ( STRING , STRING ) ; set Mouse Delegator ( ( Mouse Delegator ) some Obj ) ; } }
public void find And Init ( Object some Obj ) { if ( some Obj instanceof Mouse Delegator ) { Debug . message ( STRING , STRING ) ; set Mouse Delegator ( ( Mouse Delegator ) some Obj ) ; } }
public void find And Init ( Object some Obj ) { if ( some Obj instanceof Mouse Delegator ) { Debug . message ( STRING , STRING ) ; set Mouse Delegator ( ( Mouse Delegator ) some Obj ) ; } }
public static void add Path To Classpaths ( String path ) { extra Paths . add Element ( path ) ; }
public void do Mouse Clicked ( java . awt . event . Mouse Event e ) { if ( ! editor . get Flag ( Editor . OPTION CONTROLS , is Controlling ( ) ) ) { return ; } if ( e . is Meta Down ( ) || e . is Alt Down ( ) ) { return ; } if ( ( named Turnout West == null ) || ( named Turnout East == null ) ) { log . error ( STRING ) ; return ; } switch ( turnout Type ) { case DOUBLESLIP : do Double Slip Mouse Click ( ) ; break ; case SINGLESLIP : do Single Slip Mouse Click ( ) ; break ; case THREEWAY : do 3 Way Mouse Click ( ) ; break ; case SCISSOR : do Scissor Mouse Click ( ) ; break ; default : log . error ( STRING , turnout Type ) ; } }
public void do Mouse Clicked ( java . awt . event . Mouse Event e ) { if ( ! editor . get Flag ( Editor . OPTION CONTROLS , is Controlling ( ) ) ) { return ; } if ( e . is Meta Down ( ) || e . is Alt Down ( ) ) { return ; } if ( ( named Turnout West == null ) || ( named Turnout East == null ) ) { log . error ( STRING ) ; return ; } switch ( turnout Type ) { case DOUBLESLIP : do Double Slip Mouse Click ( ) ; break ; case SINGLESLIP : do Single Slip Mouse Click ( ) ; break ; case THREEWAY : do 3 Way Mouse Click ( ) ; break ; case SCISSOR : do Scissor Mouse Click ( ) ; break ; default : log . error ( STRING , turnout Type ) ; } }
public static char [ ] gen Offset Bitmap ( int [ ] offsets ) { int last Offset = offsets [ offsets . length - NUM ] ; int num Blocks = ( last Offset / BITMAP BLOCK SZ ) + NUM ; int [ ] block Lengths = new int [ num Blocks ] ; Arrays . fill ( block Lengths , NUM ) ; for ( int ix = NUM ; ix < offsets . length ; ix ++ ) { int val = offsets [ ix ] ; int block For Val = val / BITMAP BLOCK SZ ; block Lengths [ block For Val ] ++ ; } int total Size = num Blocks ; for ( int block = NUM ; block < num Blocks ; block ++ ) { total Size += block Lengths [ block ] ; } char [ ] encoded Blocks = new char [ total Size ] ; int input Ix = NUM ; int block Start Ix = NUM ; for ( int block = NUM ; block < num Blocks ; block ++ ) { int block Sz = block Lengths [ block ] ; encoded Blocks [ block Start Ix ] = ( char ) block Sz ; for ( int i = NUM ; i < block Sz ; i ++ ) { encoded Blocks [ block Start Ix + i + NUM ] = ( char ) ( offsets [ input Ix + i ] % BITMAP BLOCK SZ ) ; } input Ix += block Sz ; block Start Ix += block Sz + NUM ; } return encoded Blocks ; }
public static char [ ] gen Offset Bitmap ( int [ ] offsets ) { int last Offset = offsets [ offsets . length - NUM ] ; int num Blocks = ( last Offset / BITMAP BLOCK SZ ) + NUM ; int [ ] block Lengths = new int [ num Blocks ] ; Arrays . fill ( block Lengths , NUM ) ; for ( int ix = NUM ; ix < offsets . length ; ix ++ ) { int val = offsets [ ix ] ; int block For Val = val / BITMAP BLOCK SZ ; block Lengths [ block For Val ] ++ ; } int total Size = num Blocks ; for ( int block = NUM ; block < num Blocks ; block ++ ) { total Size += block Lengths [ block ] ; } char [ ] encoded Blocks = new char [ total Size ] ; int input Ix = NUM ; int block Start Ix = NUM ; for ( int block = NUM ; block < num Blocks ; block ++ ) { int block Sz = block Lengths [ block ] ; encoded Blocks [ block Start Ix ] = ( char ) block Sz ; for ( int i = NUM ; i < block Sz ; i ++ ) { encoded Blocks [ block Start Ix + i + NUM ] = ( char ) ( offsets [ input Ix + i ] % BITMAP BLOCK SZ ) ; } input Ix += block Sz ; block Start Ix += block Sz + NUM ; } return encoded Blocks ; }
public static char [ ] gen Offset Bitmap ( int [ ] offsets ) { int last Offset = offsets [ offsets . length - NUM ] ; int num Blocks = ( last Offset / BITMAP BLOCK SZ ) + NUM ; int [ ] block Lengths = new int [ num Blocks ] ; Arrays . fill ( block Lengths , NUM ) ; for ( int ix = NUM ; ix < offsets . length ; ix ++ ) { int val = offsets [ ix ] ; int block For Val = val / BITMAP BLOCK SZ ; block Lengths [ block For Val ] ++ ; } int total Size = num Blocks ; for ( int block = NUM ; block < num Blocks ; block ++ ) { total Size += block Lengths [ block ] ; } char [ ] encoded Blocks = new char [ total Size ] ; int input Ix = NUM ; int block Start Ix = NUM ; for ( int block = NUM ; block < num Blocks ; block ++ ) { int block Sz = block Lengths [ block ] ; encoded Blocks [ block Start Ix ] = ( char ) block Sz ; for ( int i = NUM ; i < block Sz ; i ++ ) { encoded Blocks [ block Start Ix + i + NUM ] = ( char ) ( offsets [ input Ix + i ] % BITMAP BLOCK SZ ) ; } input Ix += block Sz ; block Start Ix += block Sz + NUM ; } return encoded Blocks ; }
public static char [ ] gen Offset Bitmap ( int [ ] offsets ) { int last Offset = offsets [ offsets . length - NUM ] ; int num Blocks = ( last Offset / BITMAP BLOCK SZ ) + NUM ; int [ ] block Lengths = new int [ num Blocks ] ; Arrays . fill ( block Lengths , NUM ) ; for ( int ix = NUM ; ix < offsets . length ; ix ++ ) { int val = offsets [ ix ] ; int block For Val = val / BITMAP BLOCK SZ ; block Lengths [ block For Val ] ++ ; } int total Size = num Blocks ; for ( int block = NUM ; block < num Blocks ; block ++ ) { total Size += block Lengths [ block ] ; } char [ ] encoded Blocks = new char [ total Size ] ; int input Ix = NUM ; int block Start Ix = NUM ; for ( int block = NUM ; block < num Blocks ; block ++ ) { int block Sz = block Lengths [ block ] ; encoded Blocks [ block Start Ix ] = ( char ) block Sz ; for ( int i = NUM ; i < block Sz ; i ++ ) { encoded Blocks [ block Start Ix + i + NUM ] = ( char ) ( offsets [ input Ix + i ] % BITMAP BLOCK SZ ) ; } input Ix += block Sz ; block Start Ix += block Sz + NUM ; } return encoded Blocks ; }
public boolean write As KML ( Writer writer , boolean is Document , Kml Document kml Document ) { try { String object Type ; if ( this instanceof Kml Folder ) { if ( is Document ) object Type = STRING ; else object Type = STRING ; } else if ( this instanceof Kml Placemark ) object Type = STRING ; else if ( this instanceof Kml Ground Overlay ) object Type = STRING ; else return BOOL ; writer . write ( STRING + object Type ) ; if ( m Id != null ) writer . write ( STRING ) ; writer . write ( STRING ) ; if ( m Style != null ) { writer . write ( STRING + m Style + STRING ) ; } if ( m Name != null ) { writer . write ( STRING + String Escape Utils . escape Xml 10 ( m Name ) + STRING ) ; } if ( m Description != null ) { writer . write ( STRING + m Description + STRING ) ; } if ( ! m Visibility ) { writer . write ( STRING ) ; } write KML Specifics ( writer ) ; write KML Extended Data ( writer ) ; if ( is Document ) { kml Document . write KML Styles ( writer ) ; } writer . write ( STRING + object Type + STRING ) ; return BOOL ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; return BOOL ; } }
public boolean write As KML ( Writer writer , boolean is Document , Kml Document kml Document ) { try { String object Type ; if ( this instanceof Kml Folder ) { if ( is Document ) object Type = STRING ; else object Type = STRING ; } else if ( this instanceof Kml Placemark ) object Type = STRING ; else if ( this instanceof Kml Ground Overlay ) object Type = STRING ; else return BOOL ; writer . write ( STRING + object Type ) ; if ( m Id != null ) writer . write ( STRING ) ; writer . write ( STRING ) ; if ( m Style != null ) { writer . write ( STRING + m Style + STRING ) ; } if ( m Name != null ) { writer . write ( STRING + String Escape Utils . escape Xml 10 ( m Name ) + STRING ) ; } if ( m Description != null ) { writer . write ( STRING + m Description + STRING ) ; } if ( ! m Visibility ) { writer . write ( STRING ) ; } write KML Specifics ( writer ) ; write KML Extended Data ( writer ) ; if ( is Document ) { kml Document . write KML Styles ( writer ) ; } writer . write ( STRING + object Type + STRING ) ; return BOOL ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; return BOOL ; } }
public static boolean send ( XMPP Connection connection , Message msg ) { List < String > to List = get Allowed Notified Addresses ( connection ) ; to List = filter Hangout Addresses ( to List ) ; if ( to List . size ( ) > NUM ) { try { Log . d ( STRING + to List . size ( ) + STRING ) ; Multiple Recipient Manager . send ( connection , msg , to List , null , null ) ; } catch ( Exception e ) { Log . d ( STRING + e . get Message ( ) ) ; for ( String notified Address : to List ) { msg . set To ( notified Address ) ; try { connection . send Packet ( msg ) ; } catch ( Smack Exception . Not Connected Exception ex ) { Log . e ( STRING + ex . get Message ( ) ) ; } } return BOOL ; } } return BOOL ; }
public void next Entry ( Zip Entry ze ) throws IO Exception { LOG . fine ( STRING + current Pos ) ; byte [ ] int Buffer = new byte [ NUM ] ; int bytes Read = fis . read ( int Buffer ) ; LOG . fine ( STRING + bytes Read ) ; if ( bytes Read == - NUM ) { throw new IO Exception ( STRING + fis . available ( ) ) ; } int data Descriptor Length = NUM ; if ( Arrays . equals ( int Buffer , new byte [ ] { NUM , NUM , NUM , NUM } ) ) { data Descriptor Length = NUM + NUM + NUM ; fis . skip ( data Descriptor Length ) ; fis . read ( int Buffer ) ; } if ( ! Arrays . equals ( int Buffer , new byte [ ] { NUM , NUM , NUM , NUM } ) ) { throw new IO Exception ( STRING + Byte Array Helper . to String ( int Buffer ) ) ; } boolean has Data Descriptor = ( ze . get Method ( ) & NUM ) > NUM ; LOG . fine ( STRING + has Data Descriptor ) ; this . compressed Size = ze . get Compressed Size ( ) ; fis . skip ( NUM + NUM + NUM ) ; byte [ ] short Buffer = new byte [ NUM ] ; fis . read ( short Buffer ) ; int file Name Length = Byte Array Helper . to Int ( short Buffer ) ; fis . read ( short Buffer ) ; int extra Field Length = Byte Array Helper . to Int ( short Buffer ) ; start Pos = NUM + NUM + file Name Length + extra Field Length + data Descriptor Length ; current Pos = start Pos ; end Pos = start Pos + this . compressed Size ; fis . skip ( file Name Length + extra Field Length ) ; }
public void close ( ) { close Resources ( ) ; valid = BOOL ; LOGGER . info ( STRING + file . to Absolute Path ( ) ) ; }
private void raise Error Event ( int dialog Timeout Error ) { SIP Dialog Error Event new Error Event ; Iterator < SIP Dialog Event Listener > listener Iterator ; SIP Dialog Event Listener next Listener ; new Error Event = new SIP Dialog Error Event ( this , dialog Timeout Error ) ; synchronized ( event Listeners ) { listener Iterator = event Listeners . iterator ( ) ; while ( listener Iterator . has Next ( ) ) { next Listener = ( SIP Dialog Event Listener ) listener Iterator . next ( ) ; next Listener . dialog Error Event ( new Error Event ) ; } } event Listeners . clear ( ) ; if ( dialog Timeout Error != SIP Dialog Error Event . DIALOG ACK NOT SENT TIMEOUT && dialog Timeout Error != SIP Dialog Error Event . DIALOG ACK NOT RECEIVED TIMEOUT && dialog Timeout Error != SIP Dialog Error Event . DIALOG REINVITE TIMEOUT ) { delete ( ) ; } stop Timer ( ) ; }
public void auto Arrange ( final Execution Unit process ) { List < Execution Unit > list = new Array List < > ( NUM ) ; list . add ( NUM , process ) ; auto Arrange ( list ) ; }
private void init Table ( Database database ) throws SQL Exception { if ( database . find Tungsten Table ( commit Seqno Table . get Schema ( ) , commit Seqno Table . get Name ( ) ) == null ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + TABLE NAME + STRING ) ; database . create Table ( commit Seqno Table , BOOL , table Type ) ; } }
private void init Table ( Database database ) throws SQL Exception { if ( database . find Tungsten Table ( commit Seqno Table . get Schema ( ) , commit Seqno Table . get Name ( ) ) == null ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + TABLE NAME + STRING ) ; database . create Table ( commit Seqno Table , BOOL , table Type ) ; } }
public Burp Certificate generate Certificate ( Burp Certificate issuer ) throws Certificate Encoding Exception , Invalid Key Exception , Illegal State Exception , No Such Algorithm Exception , Signature Exception , No Such Provider Exception , IO Exception , Invalid Key Spec Exception { if ( private Key == null || public Key == null ) { generate Key Pair ( ) ; } burp Certificate = new Burp Certificate ( generate X 509 Certificate ( issuer . get Private Key ( ) ) ) ; burp Certificate . set Private Key ( private Key ) ; burp Certificate . set Public Key ( public Key ) ; burp Certificate . set Source ( STRING + issuer . get Subject ( ) ) ; return burp Certificate ; }
public Burp Certificate generate Certificate ( Burp Certificate issuer ) throws Certificate Encoding Exception , Invalid Key Exception , Illegal State Exception , No Such Algorithm Exception , Signature Exception , No Such Provider Exception , IO Exception , Invalid Key Spec Exception { if ( private Key == null || public Key == null ) { generate Key Pair ( ) ; } burp Certificate = new Burp Certificate ( generate X 509 Certificate ( issuer . get Private Key ( ) ) ) ; burp Certificate . set Private Key ( private Key ) ; burp Certificate . set Public Key ( public Key ) ; burp Certificate . set Source ( STRING + issuer . get Subject ( ) ) ; return burp Certificate ; }
public Burp Certificate generate Certificate ( Burp Certificate issuer ) throws Certificate Encoding Exception , Invalid Key Exception , Illegal State Exception , No Such Algorithm Exception , Signature Exception , No Such Provider Exception , IO Exception , Invalid Key Spec Exception { if ( private Key == null || public Key == null ) { generate Key Pair ( ) ; } burp Certificate = new Burp Certificate ( generate X 509 Certificate ( issuer . get Private Key ( ) ) ) ; burp Certificate . set Private Key ( private Key ) ; burp Certificate . set Public Key ( public Key ) ; burp Certificate . set Source ( STRING + issuer . get Subject ( ) ) ; return burp Certificate ; }
public static GDS Server Version parse Raw Version ( String version String ) throws GDS Server Version Exception { Matcher matcher = VERSION PATTERN . matcher ( version String ) ; if ( ! matcher . matches ( ) ) { throw new GDS Server Version Exception ( String . format ( STRING , version String ) ) ; } return new GDS Server Version ( version String , matcher . group ( PLATFORM IDX ) , matcher . group ( TYPE IDX ) , matcher . group ( FULL VERSION IDX ) , Integer . parse Int ( matcher . group ( MAJOR IDX ) ) , Integer . parse Int ( matcher . group ( MINOR IDX ) ) , Integer . parse Int ( matcher . group ( VARIANT IDX ) ) , Integer . parse Int ( matcher . group ( BUILD IDX ) ) , matcher . group ( SERVER NAME IDX ) , matcher . group ( EXTENDED INFO IDX ) ) ; }
private void create Container If Necessary ( ) { if ( container . is Full ( ) ) { container = new Timer Raw Container ( ) ; data . add ( container ) ; } }
public Element generate Simple Element ( final Document document , final Object pojo , final String ... attributes ) throws Parser Configuration Exception , Illegal Access Exception , Instantiation Exception { return generate Simple Element ( document , pojo , Arrays . as List ( attributes ) ) ; }
private Type < ? > find Interface ( final Class < ? > the Interface ) { Type < ? > the Interface Type = null ; Linked List < Type < ? > > types = new Linked List < Type < ? > > ( ) ; types . add ( this ) ; while ( the Interface Type == null && ! types . is Empty ( ) ) { Type < ? > current Type = types . remove First ( ) ; if ( the Interface . equals ( current Type . get Raw Type ( ) ) ) { the Interface Type = current Type ; } else if ( ! current Type . equals ( Type Factory . TYPE OF OBJECT ) ) { types . add All ( Arrays . as List ( current Type . get Interfaces ( ) ) ) ; types . add ( current Type . get Super Type ( ) ) ; } } return the Interface Type ; }
public static void apply Action Recursively On Entities ( Entity root , Consumer < Entity > action ) { action . accept ( root ) ; Node Component node Component = Component Retriever . get ( root , Node Component . class ) ; if ( node Component != null && node Component . children != null ) { for ( Entity target Entity : node Component . children ) { apply Action Recursively On Entities ( target Entity , action ) ; } } }
public static void move File ( File src File , File dest File ) throws IO Exception { if ( src File == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( dest File == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ! src File . exists ( ) ) { throw new File Not Found Exception ( STRING + src File + STRING ) ; } if ( src File . is Directory ( ) ) { throw new IO Exception ( STRING + src File + STRING ) ; } if ( dest File . exists ( ) ) { throw new File Exists Exception ( STRING + dest File + STRING ) ; } if ( dest File . is Directory ( ) ) { throw new IO Exception ( STRING + dest File + STRING ) ; } boolean rename = src File . rename To ( dest File ) ; if ( ! rename ) { copy File ( src File , dest File ) ; if ( ! src File . delete ( ) ) { File Utils . delete Quietly ( dest File ) ; throw new IO Exception ( STRING + src File + STRING + dest File + STRING ) ; } } }
public static void move File ( File src File , File dest File ) throws IO Exception { if ( src File == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( dest File == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ! src File . exists ( ) ) { throw new File Not Found Exception ( STRING + src File + STRING ) ; } if ( src File . is Directory ( ) ) { throw new IO Exception ( STRING + src File + STRING ) ; } if ( dest File . exists ( ) ) { throw new File Exists Exception ( STRING + dest File + STRING ) ; } if ( dest File . is Directory ( ) ) { throw new IO Exception ( STRING + dest File + STRING ) ; } boolean rename = src File . rename To ( dest File ) ; if ( ! rename ) { copy File ( src File , dest File ) ; if ( ! src File . delete ( ) ) { File Utils . delete Quietly ( dest File ) ; throw new IO Exception ( STRING + src File + STRING + dest File + STRING ) ; } } }
private void send Tcp Request ( Socket socket , String request ) throws Api Exception { try { Log Utils . LOGD ( TAG , STRING + request ) ; Buffered Writer writer = new Buffered Writer ( new Output Stream Writer ( socket . get Output Stream ( ) ) ) ; writer . write ( request ) ; writer . flush ( ) ; } catch ( Exception e ) { Log Utils . LOGW ( TAG , STRING , e ) ; disconnect ( ) ; throw new Api Exception ( Api Exception . IO EXCEPTION WHILE SENDING REQUEST , e ) ; } }
public boolean element Available ( String ns , String elem Name ) throws javax . xml . transform . Transformer Exception { boolean is Available = BOOL ; if ( null != ns ) { Extension Handler ext NS = ( Extension Handler ) m extension Function Namespaces . get ( ns ) ; if ( ext NS != null ) is Available = ext NS . is Element Available ( elem Name ) ; } return is Available ; }
public static Vec 2 D from Degrees ( double angle In Degrees , double magnitude ) { double x = magnitude * Math . cos ( angle In Degrees * Math . PI / NUM ) ; double y = magnitude * Math . sin ( angle In Degrees * Math . PI / NUM ) ; return new Vec 2 D ( x , y ) ; }
public void handle Exception ( Exception e , int option ) { if ( ! get Option Is Supported ( option ) ) { String message = e . get Message ( ) ; if ( message != null && ( message . equals ( os Does Not Support Operation String ) || message . equals ( os Does Not Support Option String ) || message . equals ( os Does Not Support Option Argument String ) ) ) { } else { fail ( STRING + e + STRING + get Socket Option String ( option ) ) ; } } else { fail ( STRING + e . get Message ( ) ) ; } }
protected String read And Sort File ( String file Name ) throws Exception { return read And Sort File ( file Name , null ) ; }
public void add Address ( Peer Address peer Address ) { int new Max ; lock . lock ( ) ; try { add Inactive ( peer Address ) ; new Max = get Max Connections ( ) + NUM ; } finally { lock . unlock ( ) ; } set Max Connections ( new Max ) ; }
public Builder with Global Suspend Timeout ( Duration global Suspend Timeout ) { Assert . not Null ( global Suspend Timeout , STRING ) ; this . global Suspend Timeout = Assert . arg Not ( global Suspend Timeout , global Suspend Timeout . is Negative ( ) || global Suspend Timeout . is Zero ( ) , STRING ) ; return this ; }
public Builder with Global Suspend Timeout ( Duration global Suspend Timeout ) { Assert . not Null ( global Suspend Timeout , STRING ) ; this . global Suspend Timeout = Assert . arg Not ( global Suspend Timeout , global Suspend Timeout . is Negative ( ) || global Suspend Timeout . is Zero ( ) , STRING ) ; return this ; }
public Builder with Global Suspend Timeout ( Duration global Suspend Timeout ) { Assert . not Null ( global Suspend Timeout , STRING ) ; this . global Suspend Timeout = Assert . arg Not ( global Suspend Timeout , global Suspend Timeout . is Negative ( ) || global Suspend Timeout . is Zero ( ) , STRING ) ; return this ; }
static URI without Fragment ( final String full Uri ) { int hashmark Idx = full Uri . index Of ( STRING ) ; String rval ; if ( hashmark Idx == - NUM ) { rval = full Uri ; } else { rval = full Uri . substring ( NUM , hashmark Idx ) ; } try { return new URI ( rval ) ; } catch ( URI Syntax Exception e ) { throw new Runtime Exception ( e ) ; } }
public static void flatten ( File dir To Remove ) throws IO Exception { final File parent = dir To Remove . get Parent File ( ) ; for ( File child : File Misc . list ( dir To Remove ) ) { boolean create Dest Dir = BOOL ; if ( child . is File ( ) ) { File Utils . move File To Directory ( child , parent , create Dest Dir ) ; } else if ( child . is Directory ( ) ) { File Utils . move Directory To Directory ( child , parent , create Dest Dir ) ; } else { throw new Illegal Argument Exception ( STRING + child ) ; } } File Misc . force Delete ( dir To Remove ) ; }
public static void flatten ( File dir To Remove ) throws IO Exception { final File parent = dir To Remove . get Parent File ( ) ; for ( File child : File Misc . list ( dir To Remove ) ) { boolean create Dest Dir = BOOL ; if ( child . is File ( ) ) { File Utils . move File To Directory ( child , parent , create Dest Dir ) ; } else if ( child . is Directory ( ) ) { File Utils . move Directory To Directory ( child , parent , create Dest Dir ) ; } else { throw new Illegal Argument Exception ( STRING + child ) ; } } File Misc . force Delete ( dir To Remove ) ; }
public static void flatten ( File dir To Remove ) throws IO Exception { final File parent = dir To Remove . get Parent File ( ) ; for ( File child : File Misc . list ( dir To Remove ) ) { boolean create Dest Dir = BOOL ; if ( child . is File ( ) ) { File Utils . move File To Directory ( child , parent , create Dest Dir ) ; } else if ( child . is Directory ( ) ) { File Utils . move Directory To Directory ( child , parent , create Dest Dir ) ; } else { throw new Illegal Argument Exception ( STRING + child ) ; } } File Misc . force Delete ( dir To Remove ) ; }
public static void flatten ( File dir To Remove ) throws IO Exception { final File parent = dir To Remove . get Parent File ( ) ; for ( File child : File Misc . list ( dir To Remove ) ) { boolean create Dest Dir = BOOL ; if ( child . is File ( ) ) { File Utils . move File To Directory ( child , parent , create Dest Dir ) ; } else if ( child . is Directory ( ) ) { File Utils . move Directory To Directory ( child , parent , create Dest Dir ) ; } else { throw new Illegal Argument Exception ( STRING + child ) ; } } File Misc . force Delete ( dir To Remove ) ; }
public static void flatten ( File dir To Remove ) throws IO Exception { final File parent = dir To Remove . get Parent File ( ) ; for ( File child : File Misc . list ( dir To Remove ) ) { boolean create Dest Dir = BOOL ; if ( child . is File ( ) ) { File Utils . move File To Directory ( child , parent , create Dest Dir ) ; } else if ( child . is Directory ( ) ) { File Utils . move Directory To Directory ( child , parent , create Dest Dir ) ; } else { throw new Illegal Argument Exception ( STRING + child ) ; } } File Misc . force Delete ( dir To Remove ) ; }
public boolean has Extra Fields ( Pdx Type other ) { for ( Pdx Field ft : this . fields ) { if ( ! ft . is Deleted ( ) && other . get Pdx Field ( ft . get Field Name ( ) ) == null ) { return BOOL ; } } return BOOL ; }
public boolean has Extra Fields ( Pdx Type other ) { for ( Pdx Field ft : this . fields ) { if ( ! ft . is Deleted ( ) && other . get Pdx Field ( ft . get Field Name ( ) ) == null ) { return BOOL ; } } return BOOL ; }
public static int map To Grid Cell ( float lon , float lat ) { int x Index = ( int ) Math . floor ( ( Math . abs ( LON WEST ) - Math . abs ( lon ) ) / DELTA LON ) ; int y Index = ( int ) Math . floor ( ( LAT NORTH - lat ) / DELTA LAT ) ; return x Index + ( y Index * NUMBER OF GRID X ) ; }
public static int map To Grid Cell ( float lon , float lat ) { int x Index = ( int ) Math . floor ( ( Math . abs ( LON WEST ) - Math . abs ( lon ) ) / DELTA LON ) ; int y Index = ( int ) Math . floor ( ( LAT NORTH - lat ) / DELTA LAT ) ; return x Index + ( y Index * NUMBER OF GRID X ) ; }
protected void insert Edge End ( Edge End e , Object obj ) { edge Map . put ( e , obj ) ; edge List = null ; }
protected void insert Edge End ( Edge End e , Object obj ) { edge Map . put ( e , obj ) ; edge List = null ; }
protected void insert Edge End ( Edge End e , Object obj ) { edge Map . put ( e , obj ) ; edge List = null ; }
protected void insert Edge End ( Edge End e , Object obj ) { edge Map . put ( e , obj ) ; edge List = null ; }
public Group Shards Iterator active Primary Shards Grouped ( String [ ] indices , boolean include Empty ) { Array List < Shard Iterator > set = new Array List < > ( ) ; for ( String index : indices ) { Index Routing Table index Routing Table = index ( index ) ; if ( index Routing Table == null ) { throw new Index Not Found Exception ( index ) ; } for ( Index Shard Routing Table index Shard Routing Table : index Routing Table ) { Shard Routing primary = index Shard Routing Table . primary Shard ( ) ; if ( primary . active ( ) ) { set . add ( primary . shards It ( ) ) ; } else if ( include Empty ) { set . add ( new Plain Shard Iterator ( primary . shard Id ( ) , Collections . < Shard Routing > empty List ( ) ) ) ; } } } return new Group Shards Iterator ( set ) ; }
public Group Shards Iterator active Primary Shards Grouped ( String [ ] indices , boolean include Empty ) { Array List < Shard Iterator > set = new Array List < > ( ) ; for ( String index : indices ) { Index Routing Table index Routing Table = index ( index ) ; if ( index Routing Table == null ) { throw new Index Not Found Exception ( index ) ; } for ( Index Shard Routing Table index Shard Routing Table : index Routing Table ) { Shard Routing primary = index Shard Routing Table . primary Shard ( ) ; if ( primary . active ( ) ) { set . add ( primary . shards It ( ) ) ; } else if ( include Empty ) { set . add ( new Plain Shard Iterator ( primary . shard Id ( ) , Collections . < Shard Routing > empty List ( ) ) ) ; } } } return new Group Shards Iterator ( set ) ; }
public Group Shards Iterator active Primary Shards Grouped ( String [ ] indices , boolean include Empty ) { Array List < Shard Iterator > set = new Array List < > ( ) ; for ( String index : indices ) { Index Routing Table index Routing Table = index ( index ) ; if ( index Routing Table == null ) { throw new Index Not Found Exception ( index ) ; } for ( Index Shard Routing Table index Shard Routing Table : index Routing Table ) { Shard Routing primary = index Shard Routing Table . primary Shard ( ) ; if ( primary . active ( ) ) { set . add ( primary . shards It ( ) ) ; } else if ( include Empty ) { set . add ( new Plain Shard Iterator ( primary . shard Id ( ) , Collections . < Shard Routing > empty List ( ) ) ) ; } } } return new Group Shards Iterator ( set ) ; }
public Truss pop Span ( ) { Span span = stack . remove Last ( ) ; builder . set Span ( span . span , span . start , builder . length ( ) , SPAN INCLUSIVE EXCLUSIVE ) ; return this ; }
private int visit Nodes Rec ( Node v , Edge Map < Integer > edge Weights ) { int max Value = NUM ; for ( Edge e = v . get First Out Edge ( ) ; e != null ; e = v . get Next Out Edge ( e ) ) { if ( edge Weights . get ( e ) == null ) { edge Weights . set ( e , visit Nodes Rec ( e . get Target ( ) , edge Weights ) + ( Integer ) e . get Info ( ) ) ; } max Value = Math . max ( max Value , edge Weights . get ( e ) ) ; } return max Value ; }
public synchronized void add Index ( Page Index index ) { meta Objects . put ( index . get Id ( ) , index ) ; }
public void test Moment With No Type Error Handling ( ) { String xml = STRING ; xml += create Start Mission Xml ( STRING , STRING ) ; xml += STRING + STRING ; xml += create Next Moment Xml ( STRING ) ; xml += create Length Minutes Xml ( NUM ) ; xml += create End Moment Xml ( ) ; xml += create End Mission Xml ( ) ; Input Stream moment Input Stream = new Byte Array Input Stream ( xml . get Bytes ( ) ) ; m Mission = new Mission ( m Mission Data ) ; boolean did Mission Parse Fail = BOOL ; try { m Mission . read Moments ( moment Input Stream ) ; } catch ( Mission Parse Exception e ) { did Mission Parse Fail = BOOL ; } Assert . assert Equals ( BOOL , did Mission Parse Fail ) ; }
public void test Moment With No Type Error Handling ( ) { String xml = STRING ; xml += create Start Mission Xml ( STRING , STRING ) ; xml += STRING + STRING ; xml += create Next Moment Xml ( STRING ) ; xml += create Length Minutes Xml ( NUM ) ; xml += create End Moment Xml ( ) ; xml += create End Mission Xml ( ) ; Input Stream moment Input Stream = new Byte Array Input Stream ( xml . get Bytes ( ) ) ; m Mission = new Mission ( m Mission Data ) ; boolean did Mission Parse Fail = BOOL ; try { m Mission . read Moments ( moment Input Stream ) ; } catch ( Mission Parse Exception e ) { did Mission Parse Fail = BOOL ; } Assert . assert Equals ( BOOL , did Mission Parse Fail ) ; }
public void test Moment With No Type Error Handling ( ) { String xml = STRING ; xml += create Start Mission Xml ( STRING , STRING ) ; xml += STRING + STRING ; xml += create Next Moment Xml ( STRING ) ; xml += create Length Minutes Xml ( NUM ) ; xml += create End Moment Xml ( ) ; xml += create End Mission Xml ( ) ; Input Stream moment Input Stream = new Byte Array Input Stream ( xml . get Bytes ( ) ) ; m Mission = new Mission ( m Mission Data ) ; boolean did Mission Parse Fail = BOOL ; try { m Mission . read Moments ( moment Input Stream ) ; } catch ( Mission Parse Exception e ) { did Mission Parse Fail = BOOL ; } Assert . assert Equals ( BOOL , did Mission Parse Fail ) ; }
protected void release Internal ( ) { Context Translator . pts 1cfa map = null ; Context Translator . objs 1cfa map = null ; }
protected void release Internal ( ) { Context Translator . pts 1cfa map = null ; Context Translator . objs 1cfa map = null ; }
private Query Builder Kraken parse Update ( ) { Token token ; Update Query Builder query = new Update Query Builder ( table Manager , sql ) ; String table Name = parse Table Name ( ) ; query . set Table Name ( table Name ) ; query = query ; if ( ( token = scan Token ( ) ) != Token . SET ) { throw error ( L . l ( STRING , token ) ) ; } do { parse Set Item ( query ) ; } while ( ( token = scan Token ( ) ) == Token . COMMA ) ; token = token ; Expr Kraken where Expr = null ; token = scan Token ( ) ; if ( token == Token . WHERE ) { where Expr = parse Expr ( ) ; } else if ( token != null && token != Token . EOF ) { throw error ( STRING , token ) ; } Param Expr [ ] params = params . to Array ( new Param Expr [ params . size ( ) ] ) ; query . set Params ( params ) ; query . set Where Expr ( where Expr ) ; return query ; }
@ Suppress Warnings ( STRING ) public static < C > C parameterize Or Abort ( Class < ? > c , Parameterization config ) { try { C ret = try Instantiate ( ( Class < C > ) c , c , config ) ; if ( ret == null ) { throw new Abort Exception ( STRING ) ; } return ret ; } catch ( Exception e ) { if ( config . has Errors ( ) ) { for ( Parameter Exception err : config . get Errors ( ) ) { LOG . warning ( err . to String ( ) ) ; } } if ( e instanceof Abort Exception ) { throw ( Abort Exception ) e ; } else { throw new Abort Exception ( STRING , e ) ; } } }
@ Suppress Warnings ( STRING ) public static < C > C parameterize Or Abort ( Class < ? > c , Parameterization config ) { try { C ret = try Instantiate ( ( Class < C > ) c , c , config ) ; if ( ret == null ) { throw new Abort Exception ( STRING ) ; } return ret ; } catch ( Exception e ) { if ( config . has Errors ( ) ) { for ( Parameter Exception err : config . get Errors ( ) ) { LOG . warning ( err . to String ( ) ) ; } } if ( e instanceof Abort Exception ) { throw ( Abort Exception ) e ; } else { throw new Abort Exception ( STRING , e ) ; } } }
@ Suppress Warnings ( STRING ) public static < C > C parameterize Or Abort ( Class < ? > c , Parameterization config ) { try { C ret = try Instantiate ( ( Class < C > ) c , c , config ) ; if ( ret == null ) { throw new Abort Exception ( STRING ) ; } return ret ; } catch ( Exception e ) { if ( config . has Errors ( ) ) { for ( Parameter Exception err : config . get Errors ( ) ) { LOG . warning ( err . to String ( ) ) ; } } if ( e instanceof Abort Exception ) { throw ( Abort Exception ) e ; } else { throw new Abort Exception ( STRING , e ) ; } } }
private static void expand 3 Digit Number ( String number String , Word Relation word Relation , Item token Item ) { if ( number String . char At ( NUM ) == STRING ) { expand Number At ( number String , NUM , word Relation , token Item ) ; } else { String hundred Digit = digit 2 num [ number String . char At ( NUM ) - STRING ] ; word Relation . add Word ( token Item , hundred Digit ) ; word Relation . add Word ( token Item , STRING ) ; expand Number At ( number String , NUM , word Relation , token Item ) ; } }
public void test write Read ( ) { final I Raw Store store = get Store ( ) ; try { final int len = NUM ; final byte [ ] expected = new byte [ len ] ; r . next Bytes ( expected ) ; final Byte Buffer tmp = Byte Buffer . wrap ( expected ) ; final long addr 1 = store . write ( tmp ) ; assert Equals ( len , tmp . position ( ) ) ; assert Equals ( tmp . position ( ) , tmp . limit ( ) ) ; final Byte Buffer actual = store . read ( addr 1 ) ; assert Equals ( expected , actual ) ; assert Equals ( NUM , actual . position ( ) ) ; assert Equals ( expected . length , actual . limit ( ) ) ; } finally { store . destroy ( ) ; } }
public void test write Read ( ) { final I Raw Store store = get Store ( ) ; try { final int len = NUM ; final byte [ ] expected = new byte [ len ] ; r . next Bytes ( expected ) ; final Byte Buffer tmp = Byte Buffer . wrap ( expected ) ; final long addr 1 = store . write ( tmp ) ; assert Equals ( len , tmp . position ( ) ) ; assert Equals ( tmp . position ( ) , tmp . limit ( ) ) ; final Byte Buffer actual = store . read ( addr 1 ) ; assert Equals ( expected , actual ) ; assert Equals ( NUM , actual . position ( ) ) ; assert Equals ( expected . length , actual . limit ( ) ) ; } finally { store . destroy ( ) ; } }
private void to String With Children ( String Buffer buffer , int indent ) { internal To String ( buffer , indent ) ; if ( f Children != null ) { for ( Iterator < Text Edit > iterator = f Children . iterator ( ) ; iterator . has Next ( ) ; ) { Text Edit child = iterator . next ( ) ; buffer . append ( STRING ) ; child . to String With Children ( buffer , indent + NUM ) ; } } }
private void ensure Capacity Helper ( int min Capacity ) { int old Capacity = element Data . length ; if ( min Capacity > old Capacity ) { Object [ ] old Data = element Data ; int new Capacity = ( capacity Increment > NUM ) ? ( old Capacity + capacity Increment ) : ( old Capacity * NUM ) ; if ( new Capacity < min Capacity ) { new Capacity = min Capacity ; } element Data = new Object [ new Capacity ] ; System . arraycopy ( old Data , NUM , element Data , NUM , element Count ) ; } }
private void ensure Capacity Helper ( int min Capacity ) { int old Capacity = element Data . length ; if ( min Capacity > old Capacity ) { Object [ ] old Data = element Data ; int new Capacity = ( capacity Increment > NUM ) ? ( old Capacity + capacity Increment ) : ( old Capacity * NUM ) ; if ( new Capacity < min Capacity ) { new Capacity = min Capacity ; } element Data = new Object [ new Capacity ] ; System . arraycopy ( old Data , NUM , element Data , NUM , element Count ) ; } }
private void ensure Capacity Helper ( int min Capacity ) { int old Capacity = element Data . length ; if ( min Capacity > old Capacity ) { Object [ ] old Data = element Data ; int new Capacity = ( capacity Increment > NUM ) ? ( old Capacity + capacity Increment ) : ( old Capacity * NUM ) ; if ( new Capacity < min Capacity ) { new Capacity = min Capacity ; } element Data = new Object [ new Capacity ] ; System . arraycopy ( old Data , NUM , element Data , NUM , element Count ) ; } }
public int execute ( String sql ) throws SQL Exception { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql ) ; return statement . execute Update ( sql ) ; }
public void add Observer ( Observer observer ) { if ( observer == null ) { throw new Null Pointer Exception ( ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public void add Observer ( Observer observer ) { if ( observer == null ) { throw new Null Pointer Exception ( ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public void add Observer ( Observer observer ) { if ( observer == null ) { throw new Null Pointer Exception ( ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public static String read Line ( Reader self ) throws IO Exception { if ( self instanceof Buffered Reader ) { Buffered Reader br = ( Buffered Reader ) self ; return br . read Line ( ) ; } if ( self . mark Supported ( ) ) { return read Line From Reader With Mark ( self ) ; } return read Line From Reader Without Mark ( self ) ; }
public static boolean equals ( byte [ ] array 1 , byte [ ] array 2 ) { if ( array 1 == array 2 ) return BOOL ; if ( array 1 == null || array 2 == null || array 1 . length != array 2 . length ) return BOOL ; for ( int i = NUM ; i < array 1 . length ; i ++ ) { if ( array 1 [ i ] != array 2 [ i ] ) return BOOL ; } return BOOL ; }
public void log ( java . util . logging . Level level , Char Sequence message ) { Log Record rec = new ELKI Log Record ( level , message ) ; logger . log ( rec ) ; }
public void log ( java . util . logging . Level level , Char Sequence message ) { Log Record rec = new ELKI Log Record ( level , message ) ; logger . log ( rec ) ; }
public static void postfilter mgc ( double mgc [ ] , int m , double alpha , double beta ) { if ( beta > NUM && m > NUM ) { double [ ] postfilter buff = new double [ m + NUM ] ; mc 2 b ( mgc , postfilter buff , m , alpha ) ; double e1 = b2 en ( postfilter buff , m , alpha ) ; postfilter buff [ NUM ] -= beta * alpha * mgc [ NUM ] ; for ( int k = NUM ; k < m ; k ++ ) postfilter buff [ k ] *= ( NUM + beta ) ; double e2 = b2 en ( postfilter buff , m , alpha ) ; postfilter buff [ NUM ] += Math . log ( e1 / e2 ) / NUM ; b2 mc ( postfilter buff , mgc , m , alpha ) ; } }
public static void postfilter mgc ( double mgc [ ] , int m , double alpha , double beta ) { if ( beta > NUM && m > NUM ) { double [ ] postfilter buff = new double [ m + NUM ] ; mc 2 b ( mgc , postfilter buff , m , alpha ) ; double e1 = b2 en ( postfilter buff , m , alpha ) ; postfilter buff [ NUM ] -= beta * alpha * mgc [ NUM ] ; for ( int k = NUM ; k < m ; k ++ ) postfilter buff [ k ] *= ( NUM + beta ) ; double e2 = b2 en ( postfilter buff , m , alpha ) ; postfilter buff [ NUM ] += Math . log ( e1 / e2 ) / NUM ; b2 mc ( postfilter buff , mgc , m , alpha ) ; } }
public static void postfilter mgc ( double mgc [ ] , int m , double alpha , double beta ) { if ( beta > NUM && m > NUM ) { double [ ] postfilter buff = new double [ m + NUM ] ; mc 2 b ( mgc , postfilter buff , m , alpha ) ; double e1 = b2 en ( postfilter buff , m , alpha ) ; postfilter buff [ NUM ] -= beta * alpha * mgc [ NUM ] ; for ( int k = NUM ; k < m ; k ++ ) postfilter buff [ k ] *= ( NUM + beta ) ; double e2 = b2 en ( postfilter buff , m , alpha ) ; postfilter buff [ NUM ] += Math . log ( e1 / e2 ) / NUM ; b2 mc ( postfilter buff , mgc , m , alpha ) ; } }
public void test To String ( ) { Linked Blocking Queue q = populated Queue ( SIZE ) ; String s = q . to String ( ) ; for ( int i = NUM ; i < SIZE ; ++ i ) { assert True ( s . index Of ( String . value Of ( i ) ) >= NUM ) ; } }
public void test To String ( ) { Linked Blocking Queue q = populated Queue ( SIZE ) ; String s = q . to String ( ) ; for ( int i = NUM ; i < SIZE ; ++ i ) { assert True ( s . index Of ( String . value Of ( i ) ) >= NUM ) ; } }
public static LDAP Url value Of ( final String url ) { return value Of ( url , Schema . get Default Schema ( ) ) ; }
public Boot Panel ( ) { init Components ( ) ; }
public State ( Plot Rendering Info info ) { super ( info ) ; }
public void process ( List < Object > appear Attrs , long occur Time ) { if ( expired ) { throw new Illegal State Exception ( STRING ) ; } switch ( status ) { case not sure : if ( occur Time < window . start Time ) { break ; } else if ( occur Time >= window . start Time && occur Time <= window . end Time ) { if ( expect Attrs . equals ( appear Attrs ) ) { status = Occur Status . occured ; } break ; } else { status = Occur Status . absent ; break ; } case occured : if ( occur Time > window . end Time ) { expired = BOOL ; } break ; default : break ; } if ( status == Occur Status . absent ) { expired = BOOL ; } }
private boolean zz Refill ( ) throws java . io . IO Exception { if ( zz Reader == null ) return BOOL ; if ( zz Start Read > NUM ) { System . arraycopy ( zz Buffer , zz Start Read , zz Buffer , NUM , zz End Read - zz Start Read ) ; zz End Read -= zz Start Read ; zz Current Pos -= zz Start Read ; zz Marked Pos -= zz Start Read ; zz Pushback Pos -= zz Start Read ; zz Start Read = NUM ; } if ( zz Current Pos >= zz Buffer . length ) { char new Buffer [ ] = new char [ zz Current Pos * NUM ] ; System . arraycopy ( zz Buffer , NUM , new Buffer , NUM , zz Buffer . length ) ; zz Buffer = new Buffer ; } int num Read = zz Reader . read ( zz Buffer , zz End Read , zz Buffer . length - zz End Read ) ; if ( num Read < NUM ) { return BOOL ; } else { zz End Read += num Read ; return BOOL ; } }
private static void verify Digests Implicitly ( Input Stream in ) throws IO Exception { byte [ ] buffer = new byte [ BUF SIZE ] ; while ( in . read ( buffer , NUM , buffer . length ) != - NUM ) { } }
public byte [ ] convert Nv 21 to Jpeg ( byte [ ] data copy , int w , int h , int [ ] strides ) { Log . e ( TAG , STRING ) ; Yuv Image yuv Image = new Yuv Image ( data copy , Image Format . NV 21 , w , h , strides ) ; Byte Array Output Stream post View Bytes = new Byte Array Output Stream ( ) ; yuv Image . compress To Jpeg ( new Rect ( NUM , NUM , w , h ) , NUM , post View Bytes ) ; try { post View Bytes . flush ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } Log . e ( TAG , STRING ) ; return post View Bytes . to Byte Array ( ) ; }
public byte [ ] convert Nv 21 to Jpeg ( byte [ ] data copy , int w , int h , int [ ] strides ) { Log . e ( TAG , STRING ) ; Yuv Image yuv Image = new Yuv Image ( data copy , Image Format . NV 21 , w , h , strides ) ; Byte Array Output Stream post View Bytes = new Byte Array Output Stream ( ) ; yuv Image . compress To Jpeg ( new Rect ( NUM , NUM , w , h ) , NUM , post View Bytes ) ; try { post View Bytes . flush ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } Log . e ( TAG , STRING ) ; return post View Bytes . to Byte Array ( ) ; }
public Bus Movement ( Bus Movement proto ) { super ( proto ) ; this . control System = proto . control System ; this . id = next ID ++ ; control System . register Bus ( this ) ; start Mode = BOOL ; }
protected String update Javadoc ( String content ) throws Exception { String result ; int i ; result = content ; for ( i = NUM ; i < m Start Tag . length ; i ++ ) { result = update Javadoc ( result , i ) ; } return result ; }
protected String update Javadoc ( String content ) throws Exception { String result ; int i ; result = content ; for ( i = NUM ; i < m Start Tag . length ; i ++ ) { result = update Javadoc ( result , i ) ; } return result ; }
public static String resolve Repo Url ( String repo Url ) { Repositories repositories = Repositories . get ( ) ; return resolve Repo Url ( repositories , repo Url ) ; }
public static String resolve Repo Url ( String repo Url ) { Repositories repositories = Repositories . get ( ) ; return resolve Repo Url ( repositories , repo Url ) ; }
public void increment Active Requests ( ) { if ( ! stats On ) { return ; } if ( active Requests . increment And Get ( ) >= HIGH NUMBER REQUESTS ) { alert Log . warn ( Message Format . format ( STRING , active Requests , req Rsp Per Min . avg ) ) ; } reqs Lst Min . increment And Get ( ) ; }
public void increment Active Requests ( ) { if ( ! stats On ) { return ; } if ( active Requests . increment And Get ( ) >= HIGH NUMBER REQUESTS ) { alert Log . warn ( Message Format . format ( STRING , active Requests , req Rsp Per Min . avg ) ) ; } reqs Lst Min . increment And Get ( ) ; }
public void increment Active Requests ( ) { if ( ! stats On ) { return ; } if ( active Requests . increment And Get ( ) >= HIGH NUMBER REQUESTS ) { alert Log . warn ( Message Format . format ( STRING , active Requests , req Rsp Per Min . avg ) ) ; } reqs Lst Min . increment And Get ( ) ; }
public void increment Active Requests ( ) { if ( ! stats On ) { return ; } if ( active Requests . increment And Get ( ) >= HIGH NUMBER REQUESTS ) { alert Log . warn ( Message Format . format ( STRING , active Requests , req Rsp Per Min . avg ) ) ; } reqs Lst Min . increment And Get ( ) ; }
public Char Buffer append ( float f ) { return append ( String . value Of ( f ) ) ; }
public void release ( ) throws Replicator Exception , Interrupted Exception { connection Manager . release All ( ) ; if ( ! read Only ) write Lock . release ( ) ; stop Log Sync Task ( ) ; }
public void release ( ) throws Replicator Exception , Interrupted Exception { connection Manager . release All ( ) ; if ( ! read Only ) write Lock . release ( ) ; stop Log Sync Task ( ) ; }
public void release ( ) throws Replicator Exception , Interrupted Exception { connection Manager . release All ( ) ; if ( ! read Only ) write Lock . release ( ) ; stop Log Sync Task ( ) ; }
public static char read Char ( Data Input Stream dis ) throws IO Exception { return ( char ) dis . read Byte ( ) ; }
public final double do Operation ( ) throws Operator Failed Exception { final int dim = parameter . get Dimension ( ) ; final int dim 1 = Math Utils . next Int ( dim ) ; int dim 2 = dim 1 ; while ( dim 1 == dim 2 ) { dim 2 = Math Utils . next Int ( dim ) ; } double scalar 1 = parameter . get Parameter Value ( dim 1 ) ; double scalar 2 = parameter . get Parameter Value ( dim 2 ) ; final double d = Math Utils . next Double ( ) * delta * scalar 1 ; scalar 1 -= d ; if ( parameter Weights [ dim 1 ] != parameter Weights [ dim 2 ] ) { scalar 2 += d * ( double ) parameter Weights [ dim 1 ] / ( double ) parameter Weights [ dim 2 ] ; } else { scalar 2 += d ; } parameter . set Parameter Value ( dim 1 , scalar 1 ) ; parameter . set Parameter Value ( dim 2 , scalar 2 ) ; return Math . log ( scalar 2 / ( scalar 1 + d ) ) ; }
public final double do Operation ( ) throws Operator Failed Exception { final int dim = parameter . get Dimension ( ) ; final int dim 1 = Math Utils . next Int ( dim ) ; int dim 2 = dim 1 ; while ( dim 1 == dim 2 ) { dim 2 = Math Utils . next Int ( dim ) ; } double scalar 1 = parameter . get Parameter Value ( dim 1 ) ; double scalar 2 = parameter . get Parameter Value ( dim 2 ) ; final double d = Math Utils . next Double ( ) * delta * scalar 1 ; scalar 1 -= d ; if ( parameter Weights [ dim 1 ] != parameter Weights [ dim 2 ] ) { scalar 2 += d * ( double ) parameter Weights [ dim 1 ] / ( double ) parameter Weights [ dim 2 ] ; } else { scalar 2 += d ; } parameter . set Parameter Value ( dim 1 , scalar 1 ) ; parameter . set Parameter Value ( dim 2 , scalar 2 ) ; return Math . log ( scalar 2 / ( scalar 1 + d ) ) ; }
@ Override public void on Failure ( I Mqtt Token async Action Token , Throwable exception ) { exception . print Stack Trace ( ) ; Log . e ( STRING , STRING + exception . get Message ( ) ) ; on Disconnect ( BOOL ) ; }
private native void notify Show IDE ( ) ;
private void clear Tag View Map ( ) { Text View view ; for ( final Tag tag : m Tag View Map . key Set ( ) ) { view = m Tag View Map . get ( tag ) ; view . set Tag ( null ) ; view . set On Click Listener ( null ) ; view . set Selected ( BOOL ) ; m Text View Pool . add ( view ) ; } m Tag View Map . clear ( ) ; }
private void clear Tag View Map ( ) { Text View view ; for ( final Tag tag : m Tag View Map . key Set ( ) ) { view = m Tag View Map . get ( tag ) ; view . set Tag ( null ) ; view . set On Click Listener ( null ) ; view . set Selected ( BOOL ) ; m Text View Pool . add ( view ) ; } m Tag View Map . clear ( ) ; }
public static Class < ? > invocation Handler Return Type ( Class < ? > type ) { if ( type == byte . class ) return Byte . class ; if ( type == char . class ) return Character . class ; if ( type == double . class ) return Double . class ; if ( type == float . class ) return Float . class ; if ( type == int . class ) return Integer . class ; if ( type == long . class ) return Long . class ; if ( type == short . class ) return Short . class ; if ( type == boolean . class ) return Boolean . class ; return type ; }
public void removed ( java . awt . Container cont ) { if ( data Handlers != null ) { for ( Location Handler data Handler : data Handlers ) { data Handler . removed ( cont ) ; } } }
public void removed ( java . awt . Container cont ) { if ( data Handlers != null ) { for ( Location Handler data Handler : data Handlers ) { data Handler . removed ( cont ) ; } } }
public void removed ( java . awt . Container cont ) { if ( data Handlers != null ) { for ( Location Handler data Handler : data Handlers ) { data Handler . removed ( cont ) ; } } }
public void append Simple ( Object ... data ) { if ( data . length != meta . size ( ) ) { throw new Abort Exception ( STRING ) ; } for ( int i = NUM ; i < data . length ; i ++ ) { @ Suppress Warnings ( STRING ) final List < Object > col = ( List < Object > ) columns . get ( i ) ; col . add ( data [ i ] ) ; } }
public Uri Builder uri Template ( String uri Template ) { Matcher match = uri Pattern . matcher ( uri Template ) ; if ( match . matches ( ) ) { scheme ( match . group ( NUM ) ) ; String host = match . group ( NUM ) ; if ( host != null ) { int at = host . index Of ( STRING ) ; if ( at > - NUM ) { String user = host . substring ( NUM , at ) ; host = host . substring ( at + NUM ) ; user Info ( user ) ; } } host ( host ) ; if ( match . group ( NUM ) != null ) port ( Integer . value Of ( match . group ( NUM ) ) ) ; if ( match . group ( NUM ) != null ) path ( match . group ( NUM ) ) ; if ( match . group ( NUM ) != null ) replace Query ( match . group ( NUM ) ) ; if ( match . group ( NUM ) != null ) fragment ( match . group ( NUM ) ) ; return this ; } match = ssp Pattern . matcher ( uri Template ) ; if ( match . matches ( ) ) { scheme ( match . group ( NUM ) ) ; scheme Specific Part ( match . group ( NUM ) ) ; return this ; } match = path Pattern . matcher ( uri Template ) ; if ( match . matches ( ) ) { if ( match . group ( NUM ) != null ) path ( match . group ( NUM ) ) ; if ( match . group ( NUM ) != null ) replace Query ( match . group ( NUM ) ) ; if ( match . group ( NUM ) != null ) fragment ( match . group ( NUM ) ) ; return this ; } throw new Runtime Exception ( STRING + uri Template ) ; }
public Uri Builder uri Template ( String uri Template ) { Matcher match = uri Pattern . matcher ( uri Template ) ; if ( match . matches ( ) ) { scheme ( match . group ( NUM ) ) ; String host = match . group ( NUM ) ; if ( host != null ) { int at = host . index Of ( STRING ) ; if ( at > - NUM ) { String user = host . substring ( NUM , at ) ; host = host . substring ( at + NUM ) ; user Info ( user ) ; } } host ( host ) ; if ( match . group ( NUM ) != null ) port ( Integer . value Of ( match . group ( NUM ) ) ) ; if ( match . group ( NUM ) != null ) path ( match . group ( NUM ) ) ; if ( match . group ( NUM ) != null ) replace Query ( match . group ( NUM ) ) ; if ( match . group ( NUM ) != null ) fragment ( match . group ( NUM ) ) ; return this ; } match = ssp Pattern . matcher ( uri Template ) ; if ( match . matches ( ) ) { scheme ( match . group ( NUM ) ) ; scheme Specific Part ( match . group ( NUM ) ) ; return this ; } match = path Pattern . matcher ( uri Template ) ; if ( match . matches ( ) ) { if ( match . group ( NUM ) != null ) path ( match . group ( NUM ) ) ; if ( match . group ( NUM ) != null ) replace Query ( match . group ( NUM ) ) ; if ( match . group ( NUM ) != null ) fragment ( match . group ( NUM ) ) ; return this ; } throw new Runtime Exception ( STRING + uri Template ) ; }
public boolean equals ( Object obj ) { return ( this == obj || ( obj instanceof Basic Method Constraints && Arrays . equals ( descs , ( ( Basic Method Constraints ) obj ) . descs ) ) ) ; }
public Tomcat Manager ( URL url , String username , String password , String charset ) { this . url = url ; this . username = username ; this . password = password ; this . charset = charset ; try { md 5 = Message Digest . get Instance ( STRING ) ; } catch ( No Such Algorithm Exception e ) { throw new Cargo Exception ( STRING , e ) ; } }
public void remove Supported Options ( Set < String > unmatched Processor Options ) { unmatched Processor Options . remove All ( supported Option Names ) ; }
public void print ( Print Writer output , int w , int d ) { Decimal Format format = new Decimal Format ( ) ; format . set Decimal Format Symbols ( new Decimal Format Symbols ( Locale . US ) ) ; format . set Minimum Integer Digits ( NUM ) ; format . set Maximum Fraction Digits ( d ) ; format . set Minimum Fraction Digits ( d ) ; format . set Grouping Used ( BOOL ) ; print ( output , format , w + NUM ) ; }
public Input Builder < T > repeat All ( int times ) { List < T > to Append = new Array List < > ( ) ; for ( int i = NUM ; i < times ; i ++ ) { to Append . add All ( input ) ; } input . add All ( to Append ) ; return this ; }
protected void redraw ( ) { while ( ! update Queue . is Empty ( ) ) { Visualization vis = update Queue . pop ( ) ; vis . incremental Redraw ( ) ; } }
public final char read Char ( ) throws java . io . IO Exception { return ( char ) read Short ( ) ; }
public final char read Char ( ) throws java . io . IO Exception { return ( char ) read Short ( ) ; }
public void deregister All ( Class < ? > category ) { Sub Registry reg = ( Sub Registry ) category Map . get ( category ) ; if ( reg == null ) { throw new Illegal Argument Exception ( STRING ) ; } reg . clear ( ) ; }
private V do Get ( Object key ) { if ( key == null ) throw new Null Pointer Exception ( ) ; Comparator < ? super K > cmp = comparator ; outer : for ( ; ; ) { for ( Node < K , V > b = find Predecessor ( key , cmp ) , n = b . next ; ; ) { Object v ; int c ; if ( n == null ) break outer ; Node < K , V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . help Delete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) == NUM ) { @ Suppress Warnings ( STRING ) V vv = ( V ) v ; return vv ; } if ( c < NUM ) break outer ; b = n ; n = f ; } } return null ; }
private V do Get ( Object key ) { if ( key == null ) throw new Null Pointer Exception ( ) ; Comparator < ? super K > cmp = comparator ; outer : for ( ; ; ) { for ( Node < K , V > b = find Predecessor ( key , cmp ) , n = b . next ; ; ) { Object v ; int c ; if ( n == null ) break outer ; Node < K , V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . help Delete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) == NUM ) { @ Suppress Warnings ( STRING ) V vv = ( V ) v ; return vv ; } if ( c < NUM ) break outer ; b = n ; n = f ; } } return null ; }
private V do Get ( Object key ) { if ( key == null ) throw new Null Pointer Exception ( ) ; Comparator < ? super K > cmp = comparator ; outer : for ( ; ; ) { for ( Node < K , V > b = find Predecessor ( key , cmp ) , n = b . next ; ; ) { Object v ; int c ; if ( n == null ) break outer ; Node < K , V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . help Delete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) == NUM ) { @ Suppress Warnings ( STRING ) V vv = ( V ) v ; return vv ; } if ( c < NUM ) break outer ; b = n ; n = f ; } } return null ; }
private V do Get ( Object key ) { if ( key == null ) throw new Null Pointer Exception ( ) ; Comparator < ? super K > cmp = comparator ; outer : for ( ; ; ) { for ( Node < K , V > b = find Predecessor ( key , cmp ) , n = b . next ; ; ) { Object v ; int c ; if ( n == null ) break outer ; Node < K , V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . help Delete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) == NUM ) { @ Suppress Warnings ( STRING ) V vv = ( V ) v ; return vv ; } if ( c < NUM ) break outer ; b = n ; n = f ; } } return null ; }
public Map < String , Integer > load Identifier Id Pairs ( DB Transaction transaction ) throws SQL Exception { Map < String , Integer > map = new Hash Map < String , Integer > ( ) ; String query = STRING ; Result Set set = transaction . query ( query , new Hash Map < String , Object > ( ) ) ; while ( set . next ( ) ) { String identifier = set . get String ( STRING ) ; Integer id = set . get Int ( STRING ) ; map . put ( identifier , id ) ; } return map ; }
@ Suppress Warnings ( STRING ) public String register ( String channel , String scope , Serializable user ) { switch ( Scope . of ( scope , user ) ) { case APPLICATION : return register ( null , channel , APPLICATION SCOPE , session Scope , get View Scope ( BOOL ) ) ; case SESSION : return register ( user , channel , session Scope , APPLICATION SCOPE , get View Scope ( BOOL ) ) ; case VIEW : return register ( user , channel , get View Scope ( BOOL ) , APPLICATION SCOPE , session Scope ) ; default : throw new Unsupported Operation Exception ( ) ; } }
@ Suppress Warnings ( STRING ) public String register ( String channel , String scope , Serializable user ) { switch ( Scope . of ( scope , user ) ) { case APPLICATION : return register ( null , channel , APPLICATION SCOPE , session Scope , get View Scope ( BOOL ) ) ; case SESSION : return register ( user , channel , session Scope , APPLICATION SCOPE , get View Scope ( BOOL ) ) ; case VIEW : return register ( user , channel , get View Scope ( BOOL ) , APPLICATION SCOPE , session Scope ) ; default : throw new Unsupported Operation Exception ( ) ; } }
public static void add Clipboard Listener ( final Clipboard Listener l ) { listener List . add ( l ) ; }
public static void add Package ( String packagename ) { packages . add ( packagename ) ; }
public void read Prefs ( Shared Preferences settings , Action Factory factory ) { boolean visible = BOOL ; String action Id = settings . get String ( STRING + name + STRING , STRING ) ; main Action = factory . get Action ( action Id ) ; if ( main Action != null ) visible = BOOL ; menu Actions . clear ( ) ; for ( int i = NUM ; i < max Menu Actions ; i ++ ) { action Id = settings . get String ( STRING + name + STRING + ( i + NUM ) , STRING ) ; UI Action a = factory . get Action ( action Id ) ; if ( a != null ) visible = BOOL ; menu Actions . add ( a ) ; } if ( button != null ) button . set Visibility ( visible ? View . VISIBLE : View . GONE ) ; }
public boolean has Vary All ( ) { return vary Fields . contains ( STRING ) ; }
public boolean has Vary All ( ) { return vary Fields . contains ( STRING ) ; }
protected synchronized void establish Store Home ( ) throws IO Exception { if ( m store Dir OK ) { return ; } if ( ! m store Home . exists ( ) ) { if ( ! m store Home . mkdir ( ) ) { throw new IO Exception ( STRING + m store Home . to String ( ) ) ; } } if ( ! m store Home . is Directory ( ) ) { throw new IO Exception ( STRING + m store Home + STRING ) ; } m store Dir OK = BOOL ; lock Store ( ) ; File [ ] contents = m store Home . list Files ( ) ; for ( File f : contents ) { if ( f . is Directory ( ) ) { Map < String , File > store = new Linked Hash Map < String , File > ( ) ; m stores . put ( f . get Name ( ) , store ) ; File [ ] store Entries = f . list Files ( ) ; for ( File se : store Entries ) { store . put ( se . get Name ( ) , se ) ; } } } unlock Store ( ) ; }
public static Byte String value Of Utf 8 ( final Char Sequence s ) { if ( s . length ( ) == NUM ) { return EMPTY ; } return wrap ( Static Utils . get Bytes ( s ) ) ; }
public static Image remove Bg Color ( Image img , int offset ) { return null ; }
private boolean has Divider Before Flex Line ( int flex Line Index ) { if ( flex Line Index < NUM || flex Line Index >= m Flex Lines . size ( ) ) { return BOOL ; } if ( all Flex Lines Are Dummy Before ( flex Line Index ) ) { if ( is Main Axis Direction Horizontal ( m Flex Direction ) ) { return ( m Show Divider Horizontal & SHOW DIVIDER BEGINNING ) != NUM ; } else { return ( m Show Divider Vertical & SHOW DIVIDER BEGINNING ) != NUM ; } } else { if ( is Main Axis Direction Horizontal ( m Flex Direction ) ) { return ( m Show Divider Horizontal & SHOW DIVIDER MIDDLE ) != NUM ; } else { return ( m Show Divider Vertical & SHOW DIVIDER MIDDLE ) != NUM ; } } }
private boolean has Divider Before Flex Line ( int flex Line Index ) { if ( flex Line Index < NUM || flex Line Index >= m Flex Lines . size ( ) ) { return BOOL ; } if ( all Flex Lines Are Dummy Before ( flex Line Index ) ) { if ( is Main Axis Direction Horizontal ( m Flex Direction ) ) { return ( m Show Divider Horizontal & SHOW DIVIDER BEGINNING ) != NUM ; } else { return ( m Show Divider Vertical & SHOW DIVIDER BEGINNING ) != NUM ; } } else { if ( is Main Axis Direction Horizontal ( m Flex Direction ) ) { return ( m Show Divider Horizontal & SHOW DIVIDER MIDDLE ) != NUM ; } else { return ( m Show Divider Vertical & SHOW DIVIDER MIDDLE ) != NUM ; } } }
@ Override public int hash Code ( ) { return Arrays . hash Code ( ipaddress ) ; }
public String add Days ( Object odays , String format ) { int days = Function Handler . get Int ( odays ) ; Calendar now = Calendar . get Instance ( ) ; now . add ( Calendar . DAY OF YEAR , days ) ; Date Format formatter = get Formatter ( format ) ; return formatter . format ( now . get Time ( ) ) ; }
public String add Days ( Object odays , String format ) { int days = Function Handler . get Int ( odays ) ; Calendar now = Calendar . get Instance ( ) ; now . add ( Calendar . DAY OF YEAR , days ) ; Date Format formatter = get Formatter ( format ) ; return formatter . format ( now . get Time ( ) ) ; }
public Receive Result Behaviour ( Results Agent a , long l Interval , Print Stream p Result Output ) { super ( a , l Interval ) ; my Agent = a ; Interval = l Interval ; p Out = p Result Output ; }
public Map Entry Info Key ( Object value , Object key ) { super ( value ) ; hash Code = hash Code ^ key . hash Code ( ) ; key = key ; }
public Map Entry Info Key ( Object value , Object key ) { super ( value ) ; hash Code = hash Code ^ key . hash Code ( ) ; key = key ; }
public Map Entry Info Key ( Object value , Object key ) { super ( value ) ; hash Code = hash Code ^ key . hash Code ( ) ; key = key ; }
public Map Entry Info Key ( Object value , Object key ) { super ( value ) ; hash Code = hash Code ^ key . hash Code ( ) ; key = key ; }
public Map Entry Info Key ( Object value , Object key ) { super ( value ) ; hash Code = hash Code ^ key . hash Code ( ) ; key = key ; }
public void add Obscured Recipient ( String player Name ) { obscured Recipients . add Element ( player Name ) ; }
public void add Obscured Recipient ( String player Name ) { obscured Recipients . add Element ( player Name ) ; }
public void add Obscured Recipient ( String player Name ) { obscured Recipients . add Element ( player Name ) ; }
public static String row To String ( JSON Array ja ) { String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < ja . length ( ) ; i += NUM ) { if ( i > NUM ) { sb . append ( STRING ) ; } Object o = ja . opt ( i ) ; if ( o != null ) { String s = o . to String ( ) ; if ( s . length ( ) > NUM && ( s . index Of ( STRING ) >= NUM || s . index Of ( STRING ) >= NUM || s . index Of ( STRING ) >= NUM || s . index Of ( NUM ) >= NUM || s . char At ( NUM ) == STRING ) ) { sb . append ( STRING ) ; int length = s . length ( ) ; for ( int j = NUM ; j < length ; j += NUM ) { char c = s . char At ( j ) ; if ( c >= STRING && c != STRING ) { sb . append ( c ) ; } } sb . append ( STRING ) ; } else { sb . append ( s ) ; } } } sb . append ( STRING ) ; return sb . to String ( ) ; }
public static String row To String ( JSON Array ja ) { String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < ja . length ( ) ; i += NUM ) { if ( i > NUM ) { sb . append ( STRING ) ; } Object o = ja . opt ( i ) ; if ( o != null ) { String s = o . to String ( ) ; if ( s . length ( ) > NUM && ( s . index Of ( STRING ) >= NUM || s . index Of ( STRING ) >= NUM || s . index Of ( STRING ) >= NUM || s . index Of ( NUM ) >= NUM || s . char At ( NUM ) == STRING ) ) { sb . append ( STRING ) ; int length = s . length ( ) ; for ( int j = NUM ; j < length ; j += NUM ) { char c = s . char At ( j ) ; if ( c >= STRING && c != STRING ) { sb . append ( c ) ; } } sb . append ( STRING ) ; } else { sb . append ( s ) ; } } } sb . append ( STRING ) ; return sb . to String ( ) ; }
public static String row To String ( JSON Array ja ) { String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < ja . length ( ) ; i += NUM ) { if ( i > NUM ) { sb . append ( STRING ) ; } Object o = ja . opt ( i ) ; if ( o != null ) { String s = o . to String ( ) ; if ( s . length ( ) > NUM && ( s . index Of ( STRING ) >= NUM || s . index Of ( STRING ) >= NUM || s . index Of ( STRING ) >= NUM || s . index Of ( NUM ) >= NUM || s . char At ( NUM ) == STRING ) ) { sb . append ( STRING ) ; int length = s . length ( ) ; for ( int j = NUM ; j < length ; j += NUM ) { char c = s . char At ( j ) ; if ( c >= STRING && c != STRING ) { sb . append ( c ) ; } } sb . append ( STRING ) ; } else { sb . append ( s ) ; } } } sb . append ( STRING ) ; return sb . to String ( ) ; }
protected void fire Projection Stack Event ( String command ) { if ( proj Listeners . is Empty ( ) ) { return ; } Action Event event = new Action Event ( this , NUM , command ) ; for ( Action Listener listener : proj Listeners ) { listener . action Performed ( event ) ; } }
public boolean offer Last ( E e ) { add Last ( e ) ; return BOOL ; }
private static String read Config Property ( String relative Path , String property Key ) { String home = get Rapid Miner Home ( ) ; if ( home == null ) { log Warn ( STRING + relative Path + STRING ) ; return null ; } File property File = new File ( home , relative Path ) ; if ( property File . can Read ( ) ) { Properties props = new Properties ( ) ; try ( Input Stream Reader reader = new Input Stream Reader ( new File Input Stream ( property File ) , Standard Charsets . UTF 8 ) ) { props . load ( reader ) ; } catch ( IO Exception e ) { log Warn ( STRING + e . get Localized Message ( ) ) ; } return props . get Property ( property Key ) ; } else { log Warn ( STRING + property File + STRING ) ; return null ; } }
private void draw X Axis ( Canvas canvas ) { int x = get Scroll X ( ) + left Border ; int y = top Border + effective Height ; canvas . draw Line ( x , y , x + effective Width , y , axis Paint ) ; String label = get X Axis Label ( ) ; Rect rect = get Rect ( axis Paint , label ) ; int y Offset = ( int ) rect . height ( ) / NUM ; canvas . draw Text ( label , x + effective Width + spacer , y + y Offset , axis Paint ) ; double interval = get X Axis Interval ( ) ; Array List < Double > marker Positions = get X Axis Marker Positions ( interval ) ; Number Format number Format = interval < NUM ? X FRACTION FORMAT : X NUMBER FORMAT ; for ( int i = NUM ; i < marker Positions . size ( ) ; i ++ ) { draw X Axis Marker ( canvas , marker Positions . get ( i ) , number Format , spacer + y Offset ) ; } }
public boolean equals ( Object object ) { if ( object == null || ! ( object instanceof Session ID ) ) { return BOOL ; } Session ID another = ( Session ID ) object ; return encrypted String . equals ( another . encrypted String ) ; }
public Regression Evo Optimization ( Example Set example Set , Kernel kernel , double c , double epsilon , int init Type , int max Iterations , int generations Without Improvement , int pop Size , int selection Type , double tournament Fraction , boolean keep Best , int mutation Type , double crossover Prob , boolean show Convergence Plot , boolean show Population Plot , Random Generator random , Logging Handler logging , Operator executing Operator ) { super ( Evo SVM . create Bound Array ( NUM , NUM * example Set . size ( ) ) , Evo SVM . determine Max ( c , kernel , example Set , selection Type , NUM * example Set . size ( ) ) , pop Size , NUM * example Set . size ( ) , init Type , max Iterations , generations Without Improvement , selection Type , tournament Fraction , keep Best , mutation Type , Double . Na N , crossover Prob , show Convergence Plot , show Population Plot , random , logging , executing Operator ) ; this . example Set = example Set ; this . kernel = kernel ; this . ys = new double [ example Set . size ( ) ] ; Iterator < Example > reader = example Set . iterator ( ) ; int index = NUM ; while ( reader . has Next ( ) ) { Example example = reader . next ( ) ; ys [ index ++ ] = example . get Label ( ) ; } this . optimization Function = new Regression Optimization Function ( epsilon ) ; }
public Encoder Test Suite Builder valid ( String chars ) { for ( int i = NUM , n = chars . length ( ) ; i < n ; ++ i ) { char ch = chars . char At ( i ) ; valid . set ( ch ) ; invalid . clear ( ch ) ; encoded . clear ( ch ) ; } return this ; }
@ Override public Promise < Auth Status , Authentication Exception > secure Response ( Message Info Context message Info , Subject subject ) { return new Result Promise ( SEND SUCCESS ) ; }
@ Override public Promise < Auth Status , Authentication Exception > secure Response ( Message Info Context message Info , Subject subject ) { return new Result Promise ( SEND SUCCESS ) ; }
@ Override public Promise < Auth Status , Authentication Exception > secure Response ( Message Info Context message Info , Subject subject ) { return new Result Promise ( SEND SUCCESS ) ; }
protected void delay ( long delay Ms , String desc ) { try { Thread . sleep ( delay Ms ) ; } catch ( Interrupted Exception int Exc ) { LOG . warn ( STRING + desc , int Exc ) ; } }
protected void delay ( long delay Ms , String desc ) { try { Thread . sleep ( delay Ms ) ; } catch ( Interrupted Exception int Exc ) { LOG . warn ( STRING + desc , int Exc ) ; } }
protected void delay ( long delay Ms , String desc ) { try { Thread . sleep ( delay Ms ) ; } catch ( Interrupted Exception int Exc ) { LOG . warn ( STRING + desc , int Exc ) ; } }
static boolean continue Evaluation On Deny Decision ( ) { return continue Evaluation On Deny Decision Flag ; }
static boolean continue Evaluation On Deny Decision ( ) { return continue Evaluation On Deny Decision Flag ; }
public void send Change Collection Request ( final String variable , final List < String > child List , final String value ) { final String Builder request Json = new String Builder ( ) ; request Json . append ( STRING + variable + STRING ) ; for ( int i = NUM ; i < child List . size ( ) ; i ++ ) { request Json . append ( STRING + child List . get ( i ) + STRING ) ; } request Json . append ( STRING + value + STRING ) ; send Event To Agent ( request Json . to String ( ) ) ; }
private static Object run J Unit 3 Test ( Class script Class ) { try { Object test Suite = Invoker Helper . invoke Constructor Of ( STRING , new Object [ ] { script Class } ) ; return Invoker Helper . invoke Static Method ( STRING , STRING , new Object [ ] { test Suite } ) ; } catch ( Class Not Found Exception e ) { throw new Groovy Runtime Exception ( STRING , e ) ; } }
private static Object run J Unit 3 Test ( Class script Class ) { try { Object test Suite = Invoker Helper . invoke Constructor Of ( STRING , new Object [ ] { script Class } ) ; return Invoker Helper . invoke Static Method ( STRING , STRING , new Object [ ] { test Suite } ) ; } catch ( Class Not Found Exception e ) { throw new Groovy Runtime Exception ( STRING , e ) ; } }
private static Object run J Unit 3 Test ( Class script Class ) { try { Object test Suite = Invoker Helper . invoke Constructor Of ( STRING , new Object [ ] { script Class } ) ; return Invoker Helper . invoke Static Method ( STRING , STRING , new Object [ ] { test Suite } ) ; } catch ( Class Not Found Exception e ) { throw new Groovy Runtime Exception ( STRING , e ) ; } }
private static Object run J Unit 3 Test ( Class script Class ) { try { Object test Suite = Invoker Helper . invoke Constructor Of ( STRING , new Object [ ] { script Class } ) ; return Invoker Helper . invoke Static Method ( STRING , STRING , new Object [ ] { test Suite } ) ; } catch ( Class Not Found Exception e ) { throw new Groovy Runtime Exception ( STRING , e ) ; } }
private static Object run J Unit 3 Test ( Class script Class ) { try { Object test Suite = Invoker Helper . invoke Constructor Of ( STRING , new Object [ ] { script Class } ) ; return Invoker Helper . invoke Static Method ( STRING , STRING , new Object [ ] { test Suite } ) ; } catch ( Class Not Found Exception e ) { throw new Groovy Runtime Exception ( STRING , e ) ; } }
private static Object run J Unit 3 Test ( Class script Class ) { try { Object test Suite = Invoker Helper . invoke Constructor Of ( STRING , new Object [ ] { script Class } ) ; return Invoker Helper . invoke Static Method ( STRING , STRING , new Object [ ] { test Suite } ) ; } catch ( Class Not Found Exception e ) { throw new Groovy Runtime Exception ( STRING , e ) ; } }
private static Object run J Unit 3 Test ( Class script Class ) { try { Object test Suite = Invoker Helper . invoke Constructor Of ( STRING , new Object [ ] { script Class } ) ; return Invoker Helper . invoke Static Method ( STRING , STRING , new Object [ ] { test Suite } ) ; } catch ( Class Not Found Exception e ) { throw new Groovy Runtime Exception ( STRING , e ) ; } }
private static Object run J Unit 3 Test ( Class script Class ) { try { Object test Suite = Invoker Helper . invoke Constructor Of ( STRING , new Object [ ] { script Class } ) ; return Invoker Helper . invoke Static Method ( STRING , STRING , new Object [ ] { test Suite } ) ; } catch ( Class Not Found Exception e ) { throw new Groovy Runtime Exception ( STRING , e ) ; } }
private static Object run J Unit 3 Test ( Class script Class ) { try { Object test Suite = Invoker Helper . invoke Constructor Of ( STRING , new Object [ ] { script Class } ) ; return Invoker Helper . invoke Static Method ( STRING , STRING , new Object [ ] { test Suite } ) ; } catch ( Class Not Found Exception e ) { throw new Groovy Runtime Exception ( STRING , e ) ; } }
< T > T on Find First ( Class < T > model Class , boolean is Eager ) { List < T > data List = query ( model Class , null , null , null , null , null , STRING , STRING , get Foreign Key Associations ( model Class . get Name ( ) , is Eager ) ) ; if ( data List . size ( ) > NUM ) { return data List . get ( NUM ) ; } return null ; }
static void dispose ( long p Data ) { D3 D Render Queue rq = D3 D Render Queue . get Instance ( ) ; rq . lock ( ) ; try { Render Buffer buf = rq . get Buffer ( ) ; rq . ensure Capacity And Alignment ( NUM , NUM ) ; buf . put Int ( DISPOSE SURFACE ) ; buf . put Long ( p Data ) ; rq . flush Now ( ) ; } finally { rq . unlock ( ) ; } }
static void dispose ( long p Data ) { D3 D Render Queue rq = D3 D Render Queue . get Instance ( ) ; rq . lock ( ) ; try { Render Buffer buf = rq . get Buffer ( ) ; rq . ensure Capacity And Alignment ( NUM , NUM ) ; buf . put Int ( DISPOSE SURFACE ) ; buf . put Long ( p Data ) ; rq . flush Now ( ) ; } finally { rq . unlock ( ) ; } }
static void dispose ( long p Data ) { D3 D Render Queue rq = D3 D Render Queue . get Instance ( ) ; rq . lock ( ) ; try { Render Buffer buf = rq . get Buffer ( ) ; rq . ensure Capacity And Alignment ( NUM , NUM ) ; buf . put Int ( DISPOSE SURFACE ) ; buf . put Long ( p Data ) ; rq . flush Now ( ) ; } finally { rq . unlock ( ) ; } }
public Serbian Normalization Filter Factory ( Map < String , String > args ) { super ( args ) ; this . haircut = get ( args , STRING , Arrays . as List ( STRING , STRING ) , STRING ) ; if ( ! args . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING + args ) ; } }
public void add ( Comparator c ) { if ( c == null ) return ; if ( m cmp . length == m size ) { Comparator [ ] cmp = new Comparator [ m size + INCREMENT ] ; System . arraycopy ( m cmp , NUM , cmp , NUM , m size ) ; m cmp = cmp ; } m cmp [ m size ++ ] = c ; }
public List < I Resource > choose Resources ( ) { if ( open ( ) == Window . OK ) { List < I Resource > resources = new Array List < I Resource > ( ) ; for ( Object obj : get Result ( ) ) { resources . add ( ( I Resource ) obj ) ; } return resources ; } return null ; }
public List < I Resource > choose Resources ( ) { if ( open ( ) == Window . OK ) { List < I Resource > resources = new Array List < I Resource > ( ) ; for ( Object obj : get Result ( ) ) { resources . add ( ( I Resource ) obj ) ; } return resources ; } return null ; }
public static Native Page create Native Page For URL ( String url , Native Page candidate Page , Tab tab , Tab Model Selector tab Model Selector , Activity activity ) { return create Native Page For URL ( url , candidate Page , tab , tab Model Selector , activity , tab . is Incognito ( ) ) ; }
private static Path rename To Vanilla Nether Or End ( Path world Container , Path old World Path , Path world Path ) { final String new Name = get Vanilla Nether Or End Name ( old World Path ) ; final Path new World Path = world Container . resolve ( new Name ) ; if ( is Valid Bukkit Nether Or End ( world Container , old World Path ) ) { if ( Files . not Exists ( world Container . resolve ( new Name ) ) ) { return new World Path ; } } return world Path ; }
private static Path rename To Vanilla Nether Or End ( Path world Container , Path old World Path , Path world Path ) { final String new Name = get Vanilla Nether Or End Name ( old World Path ) ; final Path new World Path = world Container . resolve ( new Name ) ; if ( is Valid Bukkit Nether Or End ( world Container , old World Path ) ) { if ( Files . not Exists ( world Container . resolve ( new Name ) ) ) { return new World Path ; } } return world Path ; }
private static Path rename To Vanilla Nether Or End ( Path world Container , Path old World Path , Path world Path ) { final String new Name = get Vanilla Nether Or End Name ( old World Path ) ; final Path new World Path = world Container . resolve ( new Name ) ; if ( is Valid Bukkit Nether Or End ( world Container , old World Path ) ) { if ( Files . not Exists ( world Container . resolve ( new Name ) ) ) { return new World Path ; } } return world Path ; }
public void delete Static Groups ( Set group D Ns ) throws AM Exception , SSO Exception { Iterator iter = group D Ns . iterator ( ) ; while ( iter . has Next ( ) ) { String group DN = ( String ) iter . next ( ) ; AM Static Group group = new AM Static Group Impl ( token , group DN ) ; group . delete ( ) ; } }
public void delete Static Groups ( Set group D Ns ) throws AM Exception , SSO Exception { Iterator iter = group D Ns . iterator ( ) ; while ( iter . has Next ( ) ) { String group DN = ( String ) iter . next ( ) ; AM Static Group group = new AM Static Group Impl ( token , group DN ) ; group . delete ( ) ; } }
protected void apply Value ( T value ) { bean . set Value ( property , value ) ; }
final void close ( ) { is Close = BOOL ; Lock Support . unpark ( this ) ; }
final void close ( ) { is Close = BOOL ; Lock Support . unpark ( this ) ; }
public Document Analysis Request add Document ( Solr Input Document doc ) { documents . add ( doc ) ; return this ; }
public static boolean write Line ( String file Name , String value ) { Buffered Writer writer = null ; try { writer = new Buffered Writer ( new File Writer ( file Name ) ) ; writer . write ( value ) ; } catch ( File Not Found Exception e ) { Log . w ( TAG , STRING + file Name + STRING , e ) ; return BOOL ; } catch ( IO Exception e ) { Log . e ( TAG , STRING + file Name , e ) ; return BOOL ; } finally { try { if ( writer != null ) { writer . close ( ) ; } } catch ( IO Exception e ) { } } return BOOL ; }
public C Action Difference Traces ( final J Frame parent , final I Trace List Provider trace Provider , final Trace List trace 1 , final Trace List trace 2 ) { super ( String . format ( STRING , trace 1 . get Name ( ) , trace 2 . get Name ( ) ) ) ; m parent = parent ; m trace Provider = trace Provider ; m trace 1 = trace 1 ; m trace 2 = trace 2 ; }
long read D Word ( ) throws IO Exception { int b0 = m in . read ( ) ; int b1 = m in . read ( ) ; int b2 = m in . read ( ) ; int b3 = m in . read ( ) ; long value = ( ( b3 << NUM ) & NUM ) | ( ( b2 << NUM ) & NUM ) | ( ( b1 << NUM ) & NUM ) | ( b0 & NUM ) ; return value ; }
long read D Word ( ) throws IO Exception { int b0 = m in . read ( ) ; int b1 = m in . read ( ) ; int b2 = m in . read ( ) ; int b3 = m in . read ( ) ; long value = ( ( b3 << NUM ) & NUM ) | ( ( b2 << NUM ) & NUM ) | ( ( b1 << NUM ) & NUM ) | ( b0 & NUM ) ; return value ; }
long read D Word ( ) throws IO Exception { int b0 = m in . read ( ) ; int b1 = m in . read ( ) ; int b2 = m in . read ( ) ; int b3 = m in . read ( ) ; long value = ( ( b3 << NUM ) & NUM ) | ( ( b2 << NUM ) & NUM ) | ( ( b1 << NUM ) & NUM ) | ( b0 & NUM ) ; return value ; }
public void add To Weight List ( double weight ) { weight List . add ( weight ) ; }
@ Override public boolean write ( byte [ ] data , int offset , int length ) throws IO Exception { if ( m Seq Size + length <= m Limit ) { m Seq Data . write ( data , offset , length ) ; m Seq Size += length ; m Checksum Seq . update ( data , offset , length ) ; return BOOL ; } return BOOL ; }
private J Scroll Pane create Detail Panel ( String error Message ) { J Text Area text Area = new J Text Area ( error Message ) ; text Area . set Line Wrap ( BOOL ) ; text Area . set Editable ( BOOL ) ; J Scroll Pane detail Pane = new Extended J Scroll Pane ( text Area ) ; detail Pane . set Preferred Size ( new Dimension ( get Width ( ) , NUM ) ) ; return detail Pane ; }
private J Scroll Pane create Detail Panel ( String error Message ) { J Text Area text Area = new J Text Area ( error Message ) ; text Area . set Line Wrap ( BOOL ) ; text Area . set Editable ( BOOL ) ; J Scroll Pane detail Pane = new Extended J Scroll Pane ( text Area ) ; detail Pane . set Preferred Size ( new Dimension ( get Width ( ) , NUM ) ) ; return detail Pane ; }
private J Scroll Pane create Detail Panel ( String error Message ) { J Text Area text Area = new J Text Area ( error Message ) ; text Area . set Line Wrap ( BOOL ) ; text Area . set Editable ( BOOL ) ; J Scroll Pane detail Pane = new Extended J Scroll Pane ( text Area ) ; detail Pane . set Preferred Size ( new Dimension ( get Width ( ) , NUM ) ) ; return detail Pane ; }
public void flush ( ) throws java . io . IO Exception { flush Buffer ( ) ; m os . flush ( ) ; }
public void flush ( ) throws java . io . IO Exception { flush Buffer ( ) ; m os . flush ( ) ; }
public void flush ( ) throws java . io . IO Exception { flush Buffer ( ) ; m os . flush ( ) ; }
public void flush ( ) throws java . io . IO Exception { flush Buffer ( ) ; m os . flush ( ) ; }
public void flush ( ) throws java . io . IO Exception { flush Buffer ( ) ; m os . flush ( ) ; }
public void flush ( ) throws java . io . IO Exception { flush Buffer ( ) ; m os . flush ( ) ; }
public void add Caret Listener ( final I Caret Listener listener ) { Preconditions . check Not Null ( listener , STRING ) ; if ( ! m listeners . contains ( listener ) ) { m listeners . add ( listener ) ; } }
private static void close Safe ( Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( IO Exception ignored ) { } } }
public void source ( File file ) { add Arg ( STRING , file . get Absolute Path ( ) ) ; }
private void draw Offsets ( final Graphics g ) { if ( is Enabled ( ) ) { g . set Color ( m font Color Offsets ) ; } else { g . set Color ( m disabled Color != m bg Color Offset ? m disabled Color : Color . WHITE ) ; } final int x = ( - m first Column * m char Width ) + NUM ; final int bytes To Draw = get Maximum Visible Bytes ( ) ; final String format String = m address Mode == Address Mode . BIT 32 ? STRING : STRING ; for ( int i = NUM ; i < bytes To Draw ; i += m bytes Per Row ) { final long address = m base Address + ( m first Row * m bytes Per Row ) + i ; final String offset String = String . format ( format String , address ) ; final int current Row = i / m bytes Per Row ; g . draw String ( offset String , x , m padding Top + ( current Row * m row Height ) ) ; } }
private void draw Offsets ( final Graphics g ) { if ( is Enabled ( ) ) { g . set Color ( m font Color Offsets ) ; } else { g . set Color ( m disabled Color != m bg Color Offset ? m disabled Color : Color . WHITE ) ; } final int x = ( - m first Column * m char Width ) + NUM ; final int bytes To Draw = get Maximum Visible Bytes ( ) ; final String format String = m address Mode == Address Mode . BIT 32 ? STRING : STRING ; for ( int i = NUM ; i < bytes To Draw ; i += m bytes Per Row ) { final long address = m base Address + ( m first Row * m bytes Per Row ) + i ; final String offset String = String . format ( format String , address ) ; final int current Row = i / m bytes Per Row ; g . draw String ( offset String , x , m padding Top + ( current Row * m row Height ) ) ; } }
public int evict Stale Refs ( ) { if ( timeout != NUM ) { return evict Stale Refs ( timeout ) ; } return NUM ; }
public int evict Stale Refs ( ) { if ( timeout != NUM ) { return evict Stale Refs ( timeout ) ; } return NUM ; }
public int evict Stale Refs ( ) { if ( timeout != NUM ) { return evict Stale Refs ( timeout ) ; } return NUM ; }
public static void create Parent Directories ( String path ) { File target File = new File ( path ) ; File parent = target File . get Parent File ( ) ; if ( ! parent . exists ( ) && ! parent . mkdirs ( ) ) { throw new Illegal State Exception ( STRING + parent ) ; } }
public Top N Metric ( String metric Name , Sort Direction order ) { this ( metric Name ) ; if ( order == Sort Direction . ASC ) { this . type = Top N Metric Type . INVERTED ; this . metric Name = Optional . empty ( ) ; this . nested = Optional . of ( new Top N Metric ( metric Name ) ) ; } }
public void add Exit Time ( double time ) { if ( exit Times == null ) { return ; } if ( time < NUM ) { time = NUM ; } exit Times . add ( Double . value Of ( time ) ) ; }
public void add Exit Time ( double time ) { if ( exit Times == null ) { return ; } if ( time < NUM ) { time = NUM ; } exit Times . add ( Double . value Of ( time ) ) ; }
public void add Exit Time ( double time ) { if ( exit Times == null ) { return ; } if ( time < NUM ) { time = NUM ; } exit Times . add ( Double . value Of ( time ) ) ; }
public static void write Fofn ( final File destination , final File ... files ) throws IO Exception { write Fofn ( destination , Arrays . as List ( files ) ) ; }
public static void write Fofn ( final File destination , final File ... files ) throws IO Exception { write Fofn ( destination , Arrays . as List ( files ) ) ; }
public static void write Fofn ( final File destination , final File ... files ) throws IO Exception { write Fofn ( destination , Arrays . as List ( files ) ) ; }
public static void write Fofn ( final File destination , final File ... files ) throws IO Exception { write Fofn ( destination , Arrays . as List ( files ) ) ; }
public void filter ( final Collection < T > collection ) { if ( collection != null ) { final Iterator < T > iter = collection . iterator ( ) ; while ( iter . has Next ( ) ) { final T o = iter . next ( ) ; if ( ! passes All Criteria ( o ) ) { iter . remove ( ) ; } } } }
public void filter ( final Collection < T > collection ) { if ( collection != null ) { final Iterator < T > iter = collection . iterator ( ) ; while ( iter . has Next ( ) ) { final T o = iter . next ( ) ; if ( ! passes All Criteria ( o ) ) { iter . remove ( ) ; } } } }
public void filter ( final Collection < T > collection ) { if ( collection != null ) { final Iterator < T > iter = collection . iterator ( ) ; while ( iter . has Next ( ) ) { final T o = iter . next ( ) ; if ( ! passes All Criteria ( o ) ) { iter . remove ( ) ; } } } }
public synchronized void write ( byte [ ] b , int off , int len ) throws IO Exception { ensure Open ( ) ; if ( off < NUM || len < NUM || off > b . length - len ) { throw new Index Out Of Bounds Exception ( ) ; } else if ( len == NUM ) { return ; } if ( current == null ) { throw new Zip Exception ( STRING ) ; } Zip Entry entry = current . entry ; switch ( entry . method ) { case DEFLATED : super . write ( b , off , len ) ; break ; case STORED : written += len ; if ( written - locoff > entry . size ) { throw new Zip Exception ( STRING ) ; } out . write ( b , off , len ) ; break ; default : throw new Zip Exception ( STRING ) ; } crc . update ( b , off , len ) ; }
private void compute IFD Offset ( ) { long bytes Per Row = ( long ) Math . ceil ( ( sample Size [ NUM ] / NUM ) * tile Width * num Bands ) ; long bytes Per Tile = bytes Per Row * tile Length ; long last Tile = bytes Per Tile ; if ( ! is Tiled ) { long last Strip Rows = length - ( tile Length * ( num Tiles - NUM ) ) ; last Tile = last Strip Rows * bytes Per Row ; } long total Bytes Of Data = bytes Per Tile * ( num Tiles - NUM ) + last Tile ; first IFD Offset = NUM + total Bytes Of Data ; if ( ( first IFD Offset % NUM ) != NUM ) { first IFD Offset ++ ; } }
public void run Test ( ) throws Throwable { Document doc ; Node List em List ; Node em Node ; Character Data em Text ; Node null Child ; doc = ( Document ) load ( STRING , BOOL ) ; em List = doc . get Elements By Tag Name ( STRING ) ; em Node = em List . item ( NUM ) ; em Text = ( Character Data ) em Node . get First Child ( ) ; null Child = em Text . get First Child ( ) ; assert Null ( STRING , null Child ) ; }
private boolean has Idle Invokers ( ) { for ( Async Event Listener Invoker invoker : this . scheduled Invokers ) { if ( invoker . is Idle ( ) ) { return BOOL ; } } return BOOL ; }
private boolean has Idle Invokers ( ) { for ( Async Event Listener Invoker invoker : this . scheduled Invokers ) { if ( invoker . is Idle ( ) ) { return BOOL ; } } return BOOL ; }
private boolean has Idle Invokers ( ) { for ( Async Event Listener Invoker invoker : this . scheduled Invokers ) { if ( invoker . is Idle ( ) ) { return BOOL ; } } return BOOL ; }
public static boolean validate Bind Address ( String bind Address ) { if ( bind Address == null || bind Address . length ( ) == NUM ) return BOOL ; if ( Inet Address Util . validate Host ( bind Address ) == null ) return BOOL ; return BOOL ; }
@ Suppress Warnings ( STRING ) public Dictionary Adapter ( Context context , File db Path , String db Name , String default Table ) { m Context = context ; m Db Name = db Name ; m Default Table = default Table ; m Db Path = db Path ; m Db File = new File ( db Path , m Db Name ) ; if ( m Db File . exists ( ) ) { open ( ) ; } }
public Spherical Polar Coordinates ( Vector 3 D v , double new Radius ) { radius = v . modulus ( ) ; theta = Math . acos ( v . get Z ( ) / radius ) ; phi = Math . atan ( v . get Y ( ) / v . get X ( ) ) ; if ( v . get Y ( ) < NUM ) phi += Math . PI ; radius = new Radius ; }
private static String ensure Unique Id ( String id ) { Object exists = DOM . get Element By Id ( id ) ; int i = NUM ; while ( exists != null ) { exists = DOM . get Element By Id ( id + STRING + ( ++ i ) ) ; } if ( i > NUM ) { id = id + STRING + i ; } return id ; }
private static String ensure Unique Id ( String id ) { Object exists = DOM . get Element By Id ( id ) ; int i = NUM ; while ( exists != null ) { exists = DOM . get Element By Id ( id + STRING + ( ++ i ) ) ; } if ( i > NUM ) { id = id + STRING + i ; } return id ; }
private static String ensure Unique Id ( String id ) { Object exists = DOM . get Element By Id ( id ) ; int i = NUM ; while ( exists != null ) { exists = DOM . get Element By Id ( id + STRING + ( ++ i ) ) ; } if ( i > NUM ) { id = id + STRING + i ; } return id ; }
private int calculate Segment Size ( int factor , int segment Size Old ) { Database Kelp db = table . database ( ) ; long segment Factor = table Length / db . get Segment Size Min ( ) ; long segment Factor New = segment Factor / factor ; if ( segment Factor New > NUM ) { int bit = NUM - Long . number Of Leading Zeros ( segment Factor New ) ; bit &= ~ NUM ; long segment Factor Power = ( NUM << bit ) ; if ( segment Factor Power < segment Factor New ) { segment Factor New = NUM * segment Factor Power ; } } long segment Size New = segment Factor New * db . get Segment Size Min ( ) ; segment Size New = Math . max ( db . get Segment Size Min ( ) , segment Size New ) ; long segment Size Blob = blob Size Max * NUM ; while ( segment Size New < segment Size Blob ) { segment Size New *= NUM ; } segment Size New = Math . min ( db . get Segment Size Max ( ) , segment Size New ) ; return ( int ) Math . max ( segment Size New , segment Size Old ) ; }
protected void initialize Phase ( int w ) { Arrays . fill ( committed Workers , BOOL ) ; Arrays . fill ( parent Worker By Committed Job , - NUM ) ; committed Workers [ w ] = BOOL ; for ( int j = NUM ; j < dim ; j ++ ) { min Slack Value By Job [ j ] = cost Matrix [ w ] [ j ] - label By Worker [ w ] - label By Job [ j ] ; min Slack Worker By Job [ j ] = w ; } }
protected void initialize Phase ( int w ) { Arrays . fill ( committed Workers , BOOL ) ; Arrays . fill ( parent Worker By Committed Job , - NUM ) ; committed Workers [ w ] = BOOL ; for ( int j = NUM ; j < dim ; j ++ ) { min Slack Value By Job [ j ] = cost Matrix [ w ] [ j ] - label By Worker [ w ] - label By Job [ j ] ; min Slack Worker By Job [ j ] = w ; } }
protected void initialize Phase ( int w ) { Arrays . fill ( committed Workers , BOOL ) ; Arrays . fill ( parent Worker By Committed Job , - NUM ) ; committed Workers [ w ] = BOOL ; for ( int j = NUM ; j < dim ; j ++ ) { min Slack Value By Job [ j ] = cost Matrix [ w ] [ j ] - label By Worker [ w ] - label By Job [ j ] ; min Slack Worker By Job [ j ] = w ; } }
private void add Pokemon To Favs ( Poke Model poke Model , Array List < Integer > list Of Fav Pokemon ) { if ( poke Model != null && list Of Fav Pokemon != null ) { int poke Num = poke Model . get Pokedex Num ( ) ; if ( list Of Fav Pokemon . contains ( poke Num ) ) { Typeface Utils . display Toast ( m Context , get String ( R . string . redundant fav pokemon msg ) , Typeface Utils . TOAST SHORT DURATION ) ; } else { Poke Cursor Manager . insert Pokemon In Db ( m Context , poke Num , Poke DB Contract . Favorite Pokemon Entry . TABLE NAME , Poke DB Contract . Favorite Pokemon Entry . COLUMN NUMBER ) ; Typeface Utils . display Toast ( m Context , get String ( R . string . add pokemon to favs msg ) , Typeface Utils . TOAST SHORT DURATION ) ; } } }
public Response do Post ( String url ) { return do Post ( url , null ) ; }
public Template Druid Query nest ( ) { Linked Hash Set < Aggregation > inner Aggregations = new Linked Hash Set < > ( ) ; Linked Hash Set < Aggregation > outer Aggregations = new Linked Hash Set < > ( ) ; for ( Aggregation agg : aggregations ) { Pair < Aggregation , Aggregation > split = agg . nest ( ) ; inner Aggregations . add ( split . get Right ( ) ) ; outer Aggregations . add ( split . get Left ( ) ) ; } Template Druid Query inner Query ; if ( is Nested ( ) ) { inner Query = new Template Druid Query ( inner Aggregations , Collections . empty Set ( ) , nested Query , null ) ; } else { inner Query = new Template Druid Query ( inner Aggregations , Collections . empty Set ( ) , null , null ) ; } return new Template Druid Query ( outer Aggregations , post Aggregations , inner Query , time Grain ) ; }
public Template Druid Query nest ( ) { Linked Hash Set < Aggregation > inner Aggregations = new Linked Hash Set < > ( ) ; Linked Hash Set < Aggregation > outer Aggregations = new Linked Hash Set < > ( ) ; for ( Aggregation agg : aggregations ) { Pair < Aggregation , Aggregation > split = agg . nest ( ) ; inner Aggregations . add ( split . get Right ( ) ) ; outer Aggregations . add ( split . get Left ( ) ) ; } Template Druid Query inner Query ; if ( is Nested ( ) ) { inner Query = new Template Druid Query ( inner Aggregations , Collections . empty Set ( ) , nested Query , null ) ; } else { inner Query = new Template Druid Query ( inner Aggregations , Collections . empty Set ( ) , null , null ) ; } return new Template Druid Query ( outer Aggregations , post Aggregations , inner Query , time Grain ) ; }
public Log Message read Log Batch ( Log Message start Log , List < Log Message > log Batch ) throws IO Exception , Compressor Exception { long batch Time = start Log . get Time ( ) ; log Batch . add ( start Log ) ; Log Message msg ; while ( ( msg = read Next Merged Log Message ( ) ) != null ) { if ( msg . get Time ( ) == batch Time ) { log Batch . add ( msg ) ; } else { return msg ; } } return null ; }
public Log Message read Log Batch ( Log Message start Log , List < Log Message > log Batch ) throws IO Exception , Compressor Exception { long batch Time = start Log . get Time ( ) ; log Batch . add ( start Log ) ; Log Message msg ; while ( ( msg = read Next Merged Log Message ( ) ) != null ) { if ( msg . get Time ( ) == batch Time ) { log Batch . add ( msg ) ; } else { return msg ; } } return null ; }
public Log Message read Log Batch ( Log Message start Log , List < Log Message > log Batch ) throws IO Exception , Compressor Exception { long batch Time = start Log . get Time ( ) ; log Batch . add ( start Log ) ; Log Message msg ; while ( ( msg = read Next Merged Log Message ( ) ) != null ) { if ( msg . get Time ( ) == batch Time ) { log Batch . add ( msg ) ; } else { return msg ; } } return null ; }
public Log Message read Log Batch ( Log Message start Log , List < Log Message > log Batch ) throws IO Exception , Compressor Exception { long batch Time = start Log . get Time ( ) ; log Batch . add ( start Log ) ; Log Message msg ; while ( ( msg = read Next Merged Log Message ( ) ) != null ) { if ( msg . get Time ( ) == batch Time ) { log Batch . add ( msg ) ; } else { return msg ; } } return null ; }
public Log Message read Log Batch ( Log Message start Log , List < Log Message > log Batch ) throws IO Exception , Compressor Exception { long batch Time = start Log . get Time ( ) ; log Batch . add ( start Log ) ; Log Message msg ; while ( ( msg = read Next Merged Log Message ( ) ) != null ) { if ( msg . get Time ( ) == batch Time ) { log Batch . add ( msg ) ; } else { return msg ; } } return null ; }
public Log Message read Log Batch ( Log Message start Log , List < Log Message > log Batch ) throws IO Exception , Compressor Exception { long batch Time = start Log . get Time ( ) ; log Batch . add ( start Log ) ; Log Message msg ; while ( ( msg = read Next Merged Log Message ( ) ) != null ) { if ( msg . get Time ( ) == batch Time ) { log Batch . add ( msg ) ; } else { return msg ; } } return null ; }
public Log Message read Log Batch ( Log Message start Log , List < Log Message > log Batch ) throws IO Exception , Compressor Exception { long batch Time = start Log . get Time ( ) ; log Batch . add ( start Log ) ; Log Message msg ; while ( ( msg = read Next Merged Log Message ( ) ) != null ) { if ( msg . get Time ( ) == batch Time ) { log Batch . add ( msg ) ; } else { return msg ; } } return null ; }
protected void contribute Token Request Parameters ( final Query String body Parameters ) { }
protected void contribute Token Request Parameters ( final Query String body Parameters ) { }
private void drop Proxy ( Proxy Reg reg ) { synchronized ( caches ) { Iterator iter = caches . iterator ( ) ; while ( iter . has Next ( ) ) { Lookup Cache Impl cache = ( Lookup Cache Impl ) iter . next ( ) ; cache . remove Proxy Reg ( reg ) ; } } }
public byte [ ] bytes ( ) throws Http Request Exception { final Byte Array Output Stream output = byte Stream ( ) ; try { copy ( buffer ( ) , output ) ; } catch ( IO Exception e ) { throw new Http Request Exception ( e ) ; } return output . to Byte Array ( ) ; }
private Queue Connection Impl create New Primary ( Set excluded Servers ) { Queue Connection Impl primary = null ; while ( primary == null && pool . get Pool Or Cache Cancel In Progress ( ) == null ) { List servers = find Queue Servers ( excluded Servers , NUM , BOOL , print Primary Not Found Error , Localized Strings . Queue Manager Impl COULD NOT FIND SERVER TO CREATE PRIMARY CLIENT QUEUE ) ; print Primary Not Found Error = BOOL ; if ( servers == null || servers . is Empty ( ) ) { break ; } Connection connection = null ; try { connection = factory . create Client To Server Connection ( ( Server Location ) servers . get ( NUM ) , BOOL ) ; } catch ( Gem Fire Security Exception e ) { throw e ; } catch ( Exception e ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING , servers . get ( NUM ) ) ; } } if ( connection != null ) { primary = initialize Queue Connection ( connection , BOOL , queue Connections . get Failed Updater ( ) ) ; } excluded Servers . add All ( servers ) ; } if ( primary != null && sent Client Ready && primary . send Client Ready ( ) ) { ready For Events After Failover ( primary ) ; } return primary ; }
private Queue Connection Impl create New Primary ( Set excluded Servers ) { Queue Connection Impl primary = null ; while ( primary == null && pool . get Pool Or Cache Cancel In Progress ( ) == null ) { List servers = find Queue Servers ( excluded Servers , NUM , BOOL , print Primary Not Found Error , Localized Strings . Queue Manager Impl COULD NOT FIND SERVER TO CREATE PRIMARY CLIENT QUEUE ) ; print Primary Not Found Error = BOOL ; if ( servers == null || servers . is Empty ( ) ) { break ; } Connection connection = null ; try { connection = factory . create Client To Server Connection ( ( Server Location ) servers . get ( NUM ) , BOOL ) ; } catch ( Gem Fire Security Exception e ) { throw e ; } catch ( Exception e ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING , servers . get ( NUM ) ) ; } } if ( connection != null ) { primary = initialize Queue Connection ( connection , BOOL , queue Connections . get Failed Updater ( ) ) ; } excluded Servers . add All ( servers ) ; } if ( primary != null && sent Client Ready && primary . send Client Ready ( ) ) { ready For Events After Failover ( primary ) ; } return primary ; }
private Queue Connection Impl create New Primary ( Set excluded Servers ) { Queue Connection Impl primary = null ; while ( primary == null && pool . get Pool Or Cache Cancel In Progress ( ) == null ) { List servers = find Queue Servers ( excluded Servers , NUM , BOOL , print Primary Not Found Error , Localized Strings . Queue Manager Impl COULD NOT FIND SERVER TO CREATE PRIMARY CLIENT QUEUE ) ; print Primary Not Found Error = BOOL ; if ( servers == null || servers . is Empty ( ) ) { break ; } Connection connection = null ; try { connection = factory . create Client To Server Connection ( ( Server Location ) servers . get ( NUM ) , BOOL ) ; } catch ( Gem Fire Security Exception e ) { throw e ; } catch ( Exception e ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING , servers . get ( NUM ) ) ; } } if ( connection != null ) { primary = initialize Queue Connection ( connection , BOOL , queue Connections . get Failed Updater ( ) ) ; } excluded Servers . add All ( servers ) ; } if ( primary != null && sent Client Ready && primary . send Client Ready ( ) ) { ready For Events After Failover ( primary ) ; } return primary ; }
public boolean is Inside ( Point point ) { return bounds . contains ( point ) ; }
public boolean is Inside ( Point point ) { return bounds . contains ( point ) ; }
void unlink ( Node < E > p , Node < E > trail ) { p . item = null ; trail . next = p . next ; if ( last == p ) last = trail ; if ( count . get And Decrement ( ) == capacity ) not Full . signal ( ) ; }
void unlink ( Node < E > p , Node < E > trail ) { p . item = null ; trail . next = p . next ; if ( last == p ) last = trail ; if ( count . get And Decrement ( ) == capacity ) not Full . signal ( ) ; }
private Shape decode Mark Border ( int width , int height ) { double left = width / NUM - NUM ; double top = height / NUM - NUM ; path . reset ( ) ; path . move To ( left + NUM , top + NUM ) ; path . line To ( left + NUM , top ) ; path . line To ( left + NUM , top + NUM ) ; path . close Path ( ) ; return path ; }
boolean alias ( String src , String target ) { if ( src == null ) return BOOL ; Plugin Holder < T > a = registry . get ( src ) ; if ( a == null ) return BOOL ; Plugin Holder < T > b = registry . get ( target ) ; if ( b != null ) return BOOL ; registry . put ( target , a ) ; return BOOL ; }
public int call Int ( String key ) { Double d = ( Double ) call ( key ) ; return d . int Value ( ) ; }
public int call Int ( String key ) { Double d = ( Double ) call ( key ) ; return d . int Value ( ) ; }
public int call Int ( String key ) { Double d = ( Double ) call ( key ) ; return d . int Value ( ) ; }
final void prune Exceptional Out ( IR ir ) { int n = get Number Of Exceptional Out ( ) ; if ( n > NUM ) { Computed BB Enum handlers = new Computed BB Enum ( n ) ; Enumeration < Instruction > e = forward Real Instr Enumerator ( ) ; while ( e . has More Elements ( ) ) { Instruction x = e . next Element ( ) ; Enumeration < Basic Block > bbs = get Applicable Exceptional Out ( x ) ; while ( bbs . has More Elements ( ) ) { Basic Block bb = bbs . next Element ( ) ; handlers . add Possibly Duplicate Element ( bb ) ; } } delete Exceptional Out ( ) ; for ( int i = NUM ; handlers . has More Elements ( ) ; i ++ ) { Exception Handler Basic Block b = ( Exception Handler Basic Block ) handlers . next Element ( ) ; insert Out ( b ) ; } } recompute Normal Out ( ir ) ; }
protected void run Data Bridge And Check Return Value ( Data Bridge App data Bridge App , String [ ] args , Class < ? > no Logging Class , Data Bridge App . Return Value expected Return Value ) throws Exception { run Data Bridge And Check Return Value ( data Bridge App , args , no Logging Class , expected Return Value , null ) ; }
protected void run Data Bridge And Check Return Value ( Data Bridge App data Bridge App , String [ ] args , Class < ? > no Logging Class , Data Bridge App . Return Value expected Return Value ) throws Exception { run Data Bridge And Check Return Value ( data Bridge App , args , no Logging Class , expected Return Value , null ) ; }
public static String trim Or Pad ( String str , int length , char pad Char ) { String result ; if ( str == null ) { result = STRING ; } else { result = str ; } if ( result . length ( ) > length ) { return result . substring ( NUM , length ) ; } while ( result . length ( ) < length ) { result += pad Char ; } return result ; }
synchronized void add ( Object obj ) { if ( obj List != null ) { obj List . add ( obj ) ; } }
static private Hash Set < String > init Two Part TL Ds ( ) { Hash Set < String > set = new Hash Set < String > ( NUM ) ; for ( String multi Part TLD : multi Part TL Ds ) { try { if ( multi Part TLD . matches ( STRING + tld 2 + STRING ) ) { set . add ( multi Part TLD ) ; } } catch ( Exception ex ) { debug Out ( ex ) ; } } debug Out ( STRING + set . size ( ) ) ; return set ; }
private void remove Entry From Parent ( Entry entry , Entry parent , boolean do Not Update Siblings ) { final String entry Id = entry . get Id ( ) ; final String next Sibling Id = entry . get Next Sibling Id ( ) ; final String previous Sibling Id = entry . get Previous Sibling Id ( ) ; entry . set Parent Id ( null ) ; final String parents First Id = parent . get First Child Id ( ) ; if ( parents First Id . equals ( entry Id ) ) { parent . set First Child Id ( next Sibling Id ) ; } final String parents Last Id = parent . get Last Child Id ( ) ; if ( parents Last Id . equals ( entry Id ) ) { parent . set Last Child Id ( previous Sibling Id ) ; } final Entry previous Sibling = get Entry By Id ( previous Sibling Id ) ; final Entry next Sibling = get Entry By Id ( next Sibling Id ) ; if ( ! do Not Update Siblings ) { if ( next Sibling != null ) { next Sibling . set Previous Sibling Id ( previous Sibling Id ) ; } if ( previous Sibling != null ) { previous Sibling . set Next Sibling Id ( next Sibling Id ) ; } } entry . set Next Sibling Id ( null ) ; entry . set Previous Sibling Id ( null ) ; }
public void close ( ) throws IO Exception { if ( writer != null ) { writer . close ( ) ; } else { cb = null ; closed = BOOL ; } }
public void close ( ) throws IO Exception { if ( writer != null ) { writer . close ( ) ; } else { cb = null ; closed = BOOL ; } }
public void close ( ) throws IO Exception { if ( writer != null ) { writer . close ( ) ; } else { cb = null ; closed = BOOL ; } }
public void close ( ) throws IO Exception { if ( writer != null ) { writer . close ( ) ; } else { cb = null ; closed = BOOL ; } }
public void close ( ) throws IO Exception { if ( writer != null ) { writer . close ( ) ; } else { cb = null ; closed = BOOL ; } }
public void close ( ) throws IO Exception { if ( writer != null ) { writer . close ( ) ; } else { cb = null ; closed = BOOL ; } }
public void request Seconds Until Password Expiration Warning ( ) { operations . add ( Password Policy State Operation Type . GET SECONDS UNTIL PASSWORD EXPIRATION WARNING ) ; }
public static boolean is Java Builtin Data Type ( Class clazz ) { if ( clazz == null ) { return BOOL ; } Class clazz Boxed = get Boxed Type ( clazz ) ; if ( is Numeric ( clazz Boxed ) ) { return BOOL ; } if ( is Boolean ( clazz Boxed ) ) { return BOOL ; } if ( clazz Boxed . equals ( String . class ) ) { return BOOL ; } if ( ( clazz Boxed . equals ( char . class ) ) || ( clazz Boxed . equals ( Character . class ) ) ) { return BOOL ; } if ( clazz Boxed . equals ( void . class ) ) { return BOOL ; } return BOOL ; }
public static String decode ( final String str , final String charset Name ) throws Unsupported Encoding Exception { return decode ( new String ( str . get Bytes ( charset Name ) , STRING ) ) ; }
private String to Pathname ( final String ... path Elements ) { if ( path Elements != null ) { final String Builder buffer = new String Builder ( ) ; for ( String path Element : path Elements ) { buffer . append ( File . separator ) ; buffer . append ( path Element ) ; } return buffer . to String ( ) ; } return null ; }
@ Override public void close ( ) throws IO Exception { running . set ( BOOL ) ; service . shutdown ( ) ; try { if ( ! service . await Termination ( SHUTDOWN TIMEOUT , Time Unit . SECONDS ) ) { LOG . error ( STRING + SHUTDOWN TIMEOUT + STRING + Time Unit . SECONDS + STRING + STRING ) ; } } catch ( Interrupted Exception e1 ) { LOG . warn ( STRING , e1 ) ; } }
@ Override public void close ( ) throws IO Exception { running . set ( BOOL ) ; service . shutdown ( ) ; try { if ( ! service . await Termination ( SHUTDOWN TIMEOUT , Time Unit . SECONDS ) ) { LOG . error ( STRING + SHUTDOWN TIMEOUT + STRING + Time Unit . SECONDS + STRING + STRING ) ; } } catch ( Interrupted Exception e1 ) { LOG . warn ( STRING , e1 ) ; } }
public static boolean is Null Conversion ( Method Type call , Method Type recv , boolean keep Interfaces ) { if ( call == recv ) return BOOL ; int len = call . parameter Count ( ) ; if ( len != recv . parameter Count ( ) ) return BOOL ; for ( int i = NUM ; i < len ; i ++ ) if ( ! is Null Conversion ( call . parameter Type ( i ) , recv . parameter Type ( i ) , keep Interfaces ) ) return BOOL ; return is Null Conversion ( recv . return Type ( ) , call . return Type ( ) , keep Interfaces ) ; }
public static boolean is Null Conversion ( Method Type call , Method Type recv , boolean keep Interfaces ) { if ( call == recv ) return BOOL ; int len = call . parameter Count ( ) ; if ( len != recv . parameter Count ( ) ) return BOOL ; for ( int i = NUM ; i < len ; i ++ ) if ( ! is Null Conversion ( call . parameter Type ( i ) , recv . parameter Type ( i ) , keep Interfaces ) ) return BOOL ; return is Null Conversion ( recv . return Type ( ) , call . return Type ( ) , keep Interfaces ) ; }
@ Override protected void on Layout ( boolean changed , int l , int t , int r , int b ) { super . on Layout ( changed , l , t , r , b ) ; m In Layout = BOOL ; layout ( NUM , BOOL ) ; m In Layout = BOOL ; }
public Vector < Rtcp Sdes Packet > makereports ( ) { Vector < Rtcp Sdes Packet > packets = new Vector < Rtcp Sdes Packet > ( ) ; Rtcp Sdes Packet rtcpsdespacket = new Rtcp Sdes Packet ( new Rtcp Sdes Block [ NUM ] ) ; rtcpsdespacket . sdes [ NUM ] = new Rtcp Sdes Block ( ) ; rtcpsdespacket . sdes [ NUM ] . ssrc = rtcp Session . SSRC ; Vector < Rtcp Sdes Item > vector = new Vector < Rtcp Sdes Item > ( ) ; vector . add Element ( new Rtcp Sdes Item ( NUM , Rtp Source . CNAME ) ) ; rtcpsdespacket . sdes [ NUM ] . items = new Rtcp Sdes Item [ vector . size ( ) ] ; vector . copy Into ( rtcpsdespacket . sdes [ NUM ] . items ) ; packets . add Element ( rtcpsdespacket ) ; return packets ; }
private double [ ] project Sparse ( Sparse Number Vector in , double [ ] ret ) { Arrays . fill ( ret , NUM ) ; for ( int iter = in . iter ( ) ; in . iter Valid ( iter ) ; iter = in . iter Advance ( iter ) ) { final int i = in . iter Dim ( iter ) ; final double val = in . iter Double Value ( iter ) ; for ( int o = NUM ; o < ret . length ; o ++ ) { ret [ o ] += val * matrix [ o ] [ i ] ; } } return ret ; }
public static void notify Running Instance ( int port , String message ) { try { LOGGER . info ( STRING + message ) ; Inet Socket Address address = new Inet Socket Address ( Inet Address . get Loopback Address ( ) , port ) ; Socket connection = new Socket ( ) ; connection . connect ( address , NUM ) ; try ( Print Writer output = new Print Writer ( new Output Stream Writer ( connection . get Output Stream ( ) , STRING ) ) ) { output . print ( message ) ; } } catch ( IO Exception ex ) { LOGGER . warning ( STRING + ex ) ; } }
public static void notify Running Instance ( int port , String message ) { try { LOGGER . info ( STRING + message ) ; Inet Socket Address address = new Inet Socket Address ( Inet Address . get Loopback Address ( ) , port ) ; Socket connection = new Socket ( ) ; connection . connect ( address , NUM ) ; try ( Print Writer output = new Print Writer ( new Output Stream Writer ( connection . get Output Stream ( ) , STRING ) ) ) { output . print ( message ) ; } } catch ( IO Exception ex ) { LOGGER . warning ( STRING + ex ) ; } }
public static void notify Running Instance ( int port , String message ) { try { LOGGER . info ( STRING + message ) ; Inet Socket Address address = new Inet Socket Address ( Inet Address . get Loopback Address ( ) , port ) ; Socket connection = new Socket ( ) ; connection . connect ( address , NUM ) ; try ( Print Writer output = new Print Writer ( new Output Stream Writer ( connection . get Output Stream ( ) , STRING ) ) ) { output . print ( message ) ; } } catch ( IO Exception ex ) { LOGGER . warning ( STRING + ex ) ; } }
public static void notify Running Instance ( int port , String message ) { try { LOGGER . info ( STRING + message ) ; Inet Socket Address address = new Inet Socket Address ( Inet Address . get Loopback Address ( ) , port ) ; Socket connection = new Socket ( ) ; connection . connect ( address , NUM ) ; try ( Print Writer output = new Print Writer ( new Output Stream Writer ( connection . get Output Stream ( ) , STRING ) ) ) { output . print ( message ) ; } } catch ( IO Exception ex ) { LOGGER . warning ( STRING + ex ) ; } }
void populate Region Sub Regions ( Region Sub Region Snapshot parent Snap Shot , Set regions , Gem Fire Cache Impl cache ) { if ( cancelled ) return ; Region sub Region = null ; Region Sub Region Snapshot sub Region Snap Shot = null ; for ( Iterator iter = regions . iterator ( ) ; iter . has Next ( ) ; ) { sub Region = ( Region ) iter . next ( ) ; try { sub Region Snap Shot = new Region Sub Region Snapshot ( sub Region ) ; parent Snap Shot . add Sub Region ( sub Region Snap Shot ) ; Set sub Regions = sub Region . subregions ( BOOL ) ; populate Region Sub Regions ( sub Region Snap Shot , sub Regions , cache ) ; } catch ( Exception e ) { logger . debug ( STRING , sub Region . get Full Path ( ) , e ) ; } } }
public static void write Bytes To Stream ( byte [ ] bytes , Output Stream output Stream ) throws IO Exception { Buffered Output Stream bos = new Buffered Output Stream ( output Stream ) ; try { bos . write ( bytes ) ; } finally { bos . close ( ) ; } }
public void parse Hierarchy ( String h Code , Properties props , Symbol Part parent ) { List code Position List = null ; if ( next Position != null ) { code Position List = next Position . get Position Choices ( ) ; } if ( code Position List == null || code Position List . is Empty ( ) ) { Debug . output ( pretty Name + STRING ) ; return ; } List parent List = null ; for ( Iterator it = code Position List . iterator ( ) ; it . has Next ( ) ; ) { Code Position cp = ( Code Position ) it . next ( ) ; String new H Code = h Code + STRING + cp . get Hierarchy Number ( ) ; if ( DEBUG ) { Debug . output ( STRING + new H Code + STRING + cp . get Pretty Name ( ) ) ; } String entry = props . get Property ( new H Code ) ; if ( entry != null ) { Symbol Part sp = new Symbol Part ( cp , entry , props , parent ) ; if ( parent List == null ) { parent List = parent . get Subs ( ) ; if ( parent List == null ) { parent List = new Array List ( ) ; parent . set Subs ( parent List ) ; } } if ( DEBUG ) { Debug . output ( STRING + sp . get Pretty Name ( ) + STRING + parent . get Pretty Name ( ) ) ; } parent List . add ( sp ) ; if ( DEBUG ) { Debug . output ( STRING + cp . get Pretty Name ( ) + STRING + sp . get Pretty Name ( ) ) ; } cp . parse Hierarchy ( new H Code , props , sp ) ; } else { if ( DEBUG ) { Debug . output ( STRING + new H Code ) ; } } } }
public Utilization Model Planet Lab In Memory ( String input Path , double scheduling Interval ) throws Number Format Exception , IO Exception { data = new double [ NUM ] ; set Scheduling Interval ( scheduling Interval ) ; Buffered Reader input = new Buffered Reader ( new File Reader ( input Path ) ) ; int n = data . length ; for ( int i = NUM ; i < n - NUM ; i ++ ) { data [ i ] = Integer . value Of ( input . read Line ( ) ) / NUM ; } data [ n - NUM ] = data [ n - NUM ] ; input . close ( ) ; }
public static Byte Buffer read Fully ( File Channel channel , long file Offset , int bytes To Read ) throws IO Exception { Byte Buffer buffer = Byte Buffer . allocate ( bytes To Read ) ; int total Bytes Read = NUM ; while ( total Bytes Read < bytes To Read ) { int bytes Read = channel . read ( buffer , file Offset + total Bytes Read ) ; if ( bytes Read < NUM ) { throw new EOF Exception ( STRING + bytes To Read + STRING + total Bytes Read + STRING ) ; } total Bytes Read += bytes Read ; } buffer . flip ( ) ; return buffer ; }
public static Byte Buffer read Fully ( File Channel channel , long file Offset , int bytes To Read ) throws IO Exception { Byte Buffer buffer = Byte Buffer . allocate ( bytes To Read ) ; int total Bytes Read = NUM ; while ( total Bytes Read < bytes To Read ) { int bytes Read = channel . read ( buffer , file Offset + total Bytes Read ) ; if ( bytes Read < NUM ) { throw new EOF Exception ( STRING + bytes To Read + STRING + total Bytes Read + STRING ) ; } total Bytes Read += bytes Read ; } buffer . flip ( ) ; return buffer ; }
public static Byte Buffer read Fully ( File Channel channel , long file Offset , int bytes To Read ) throws IO Exception { Byte Buffer buffer = Byte Buffer . allocate ( bytes To Read ) ; int total Bytes Read = NUM ; while ( total Bytes Read < bytes To Read ) { int bytes Read = channel . read ( buffer , file Offset + total Bytes Read ) ; if ( bytes Read < NUM ) { throw new EOF Exception ( STRING + bytes To Read + STRING + total Bytes Read + STRING ) ; } total Bytes Read += bytes Read ; } buffer . flip ( ) ; return buffer ; }
public static Byte Buffer read Fully ( File Channel channel , long file Offset , int bytes To Read ) throws IO Exception { Byte Buffer buffer = Byte Buffer . allocate ( bytes To Read ) ; int total Bytes Read = NUM ; while ( total Bytes Read < bytes To Read ) { int bytes Read = channel . read ( buffer , file Offset + total Bytes Read ) ; if ( bytes Read < NUM ) { throw new EOF Exception ( STRING + bytes To Read + STRING + total Bytes Read + STRING ) ; } total Bytes Read += bytes Read ; } buffer . flip ( ) ; return buffer ; }
public static Byte Buffer read Fully ( File Channel channel , long file Offset , int bytes To Read ) throws IO Exception { Byte Buffer buffer = Byte Buffer . allocate ( bytes To Read ) ; int total Bytes Read = NUM ; while ( total Bytes Read < bytes To Read ) { int bytes Read = channel . read ( buffer , file Offset + total Bytes Read ) ; if ( bytes Read < NUM ) { throw new EOF Exception ( STRING + bytes To Read + STRING + total Bytes Read + STRING ) ; } total Bytes Read += bytes Read ; } buffer . flip ( ) ; return buffer ; }
public void add Tileset ( final Tile Set Definition set ) { tilesets . add ( set ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; String Builder sb = new String Builder ( length ) ; for ( int i = NUM ; i < length ; i += NUM ) { c = s . char At ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . for Digit ( ( char ) ( ( c > > > NUM ) & NUM ) , NUM ) ) ; sb . append ( Character . for Digit ( ( char ) ( c & NUM ) , NUM ) ) ; } else { sb . append ( c ) ; } } return sb . to String ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; String Builder sb = new String Builder ( length ) ; for ( int i = NUM ; i < length ; i += NUM ) { c = s . char At ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . for Digit ( ( char ) ( ( c > > > NUM ) & NUM ) , NUM ) ) ; sb . append ( Character . for Digit ( ( char ) ( c & NUM ) , NUM ) ) ; } else { sb . append ( c ) ; } } return sb . to String ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; String Builder sb = new String Builder ( length ) ; for ( int i = NUM ; i < length ; i += NUM ) { c = s . char At ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . for Digit ( ( char ) ( ( c > > > NUM ) & NUM ) , NUM ) ) ; sb . append ( Character . for Digit ( ( char ) ( c & NUM ) , NUM ) ) ; } else { sb . append ( c ) ; } } return sb . to String ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; String Builder sb = new String Builder ( length ) ; for ( int i = NUM ; i < length ; i += NUM ) { c = s . char At ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . for Digit ( ( char ) ( ( c > > > NUM ) & NUM ) , NUM ) ) ; sb . append ( Character . for Digit ( ( char ) ( c & NUM ) , NUM ) ) ; } else { sb . append ( c ) ; } } return sb . to String ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; String Builder sb = new String Builder ( length ) ; for ( int i = NUM ; i < length ; i += NUM ) { c = s . char At ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . for Digit ( ( char ) ( ( c > > > NUM ) & NUM ) , NUM ) ) ; sb . append ( Character . for Digit ( ( char ) ( c & NUM ) , NUM ) ) ; } else { sb . append ( c ) ; } } return sb . to String ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; String Builder sb = new String Builder ( length ) ; for ( int i = NUM ; i < length ; i += NUM ) { c = s . char At ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . for Digit ( ( char ) ( ( c > > > NUM ) & NUM ) , NUM ) ) ; sb . append ( Character . for Digit ( ( char ) ( c & NUM ) , NUM ) ) ; } else { sb . append ( c ) ; } } return sb . to String ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; String Builder sb = new String Builder ( length ) ; for ( int i = NUM ; i < length ; i += NUM ) { c = s . char At ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . for Digit ( ( char ) ( ( c > > > NUM ) & NUM ) , NUM ) ) ; sb . append ( Character . for Digit ( ( char ) ( c & NUM ) , NUM ) ) ; } else { sb . append ( c ) ; } } return sb . to String ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; String Builder sb = new String Builder ( length ) ; for ( int i = NUM ; i < length ; i += NUM ) { c = s . char At ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . for Digit ( ( char ) ( ( c > > > NUM ) & NUM ) , NUM ) ) ; sb . append ( Character . for Digit ( ( char ) ( c & NUM ) , NUM ) ) ; } else { sb . append ( c ) ; } } return sb . to String ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; String Builder sb = new String Builder ( length ) ; for ( int i = NUM ; i < length ; i += NUM ) { c = s . char At ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . for Digit ( ( char ) ( ( c > > > NUM ) & NUM ) , NUM ) ) ; sb . append ( Character . for Digit ( ( char ) ( c & NUM ) , NUM ) ) ; } else { sb . append ( c ) ; } } return sb . to String ( ) ; }
private final void write String ( char [ ] text , int offset , int len ) throws IO Exception , Json Generation Exception { if ( character Escapes != null ) { write String Custom ( text , offset , len ) ; return ; } if ( maximum Non Escaped Char != NUM ) { write String ASCII ( text , offset , len , maximum Non Escaped Char ) ; return ; } len += offset ; final int [ ] esc Codes = output Escapes ; final int esc Len = esc Codes . length ; while ( offset < len ) { int start = offset ; while ( BOOL ) { char c = text [ offset ] ; if ( c < esc Len && esc Codes [ c ] != NUM ) { break ; } if ( ++ offset >= len ) { break ; } } int new Amount = offset - start ; if ( new Amount < SHORT WRITE ) { if ( ( output Tail + new Amount ) > output End ) { flush Buffer ( ) ; } if ( new Amount > NUM ) { System . arraycopy ( text , start , output Buffer , output Tail , new Amount ) ; output Tail += new Amount ; } } else { flush Buffer ( ) ; writer . write ( text , start , new Amount ) ; } if ( offset >= len ) { break ; } char c = text [ offset ++ ] ; append Character Escape ( c , esc Codes [ c ] ) ; } }
private final void write String ( char [ ] text , int offset , int len ) throws IO Exception , Json Generation Exception { if ( character Escapes != null ) { write String Custom ( text , offset , len ) ; return ; } if ( maximum Non Escaped Char != NUM ) { write String ASCII ( text , offset , len , maximum Non Escaped Char ) ; return ; } len += offset ; final int [ ] esc Codes = output Escapes ; final int esc Len = esc Codes . length ; while ( offset < len ) { int start = offset ; while ( BOOL ) { char c = text [ offset ] ; if ( c < esc Len && esc Codes [ c ] != NUM ) { break ; } if ( ++ offset >= len ) { break ; } } int new Amount = offset - start ; if ( new Amount < SHORT WRITE ) { if ( ( output Tail + new Amount ) > output End ) { flush Buffer ( ) ; } if ( new Amount > NUM ) { System . arraycopy ( text , start , output Buffer , output Tail , new Amount ) ; output Tail += new Amount ; } } else { flush Buffer ( ) ; writer . write ( text , start , new Amount ) ; } if ( offset >= len ) { break ; } char c = text [ offset ++ ] ; append Character Escape ( c , esc Codes [ c ] ) ; } }
public void send Message ( SIP Message sip Message , Inet Address receiver Address , int receiver Port ) throws IO Exception { long time = System . current Time Millis ( ) ; send Message ( sip Message , receiver Address , receiver Port , sip Message instanceof SIP Request ) ; log Message ( sip Message , receiver Address , receiver Port , time ) ; }
public static void write File List ( XML Output xml Output , String tag Name , Iterable < File > list Values ) throws IO Exception { if ( list Values != null ) { write File List ( xml Output , tag Name , list Values . iterator ( ) ) ; } }
public static boolean equals ( Object o1 , Object o2 ) { if ( o1 == o2 ) return BOOL ; if ( o1 == null || o2 == null ) return BOOL ; Class c = o1 . get Class ( ) ; if ( c != o2 . get Class ( ) ) return BOOL ; if ( c . is Array ( ) ) { int length = Array . get Length ( o1 ) ; int length 2 = Array . get Length ( o2 ) ; if ( length != length 2 ) return BOOL ; for ( int i = NUM ; i < length ; i ++ ) { Object c1 = Array . get ( o1 , i ) ; Object c2 = Array . get ( o2 , i ) ; if ( ! equals ( c1 , c2 ) ) return BOOL ; } return BOOL ; } else { return o1 . equals ( o2 ) ; } }
public static boolean equals ( Object o1 , Object o2 ) { if ( o1 == o2 ) return BOOL ; if ( o1 == null || o2 == null ) return BOOL ; Class c = o1 . get Class ( ) ; if ( c != o2 . get Class ( ) ) return BOOL ; if ( c . is Array ( ) ) { int length = Array . get Length ( o1 ) ; int length 2 = Array . get Length ( o2 ) ; if ( length != length 2 ) return BOOL ; for ( int i = NUM ; i < length ; i ++ ) { Object c1 = Array . get ( o1 , i ) ; Object c2 = Array . get ( o2 , i ) ; if ( ! equals ( c1 , c2 ) ) return BOOL ; } return BOOL ; } else { return o1 . equals ( o2 ) ; } }
public static boolean equals ( Object o1 , Object o2 ) { if ( o1 == o2 ) return BOOL ; if ( o1 == null || o2 == null ) return BOOL ; Class c = o1 . get Class ( ) ; if ( c != o2 . get Class ( ) ) return BOOL ; if ( c . is Array ( ) ) { int length = Array . get Length ( o1 ) ; int length 2 = Array . get Length ( o2 ) ; if ( length != length 2 ) return BOOL ; for ( int i = NUM ; i < length ; i ++ ) { Object c1 = Array . get ( o1 , i ) ; Object c2 = Array . get ( o2 , i ) ; if ( ! equals ( c1 , c2 ) ) return BOOL ; } return BOOL ; } else { return o1 . equals ( o2 ) ; } }
public static boolean equals ( Object o1 , Object o2 ) { if ( o1 == o2 ) return BOOL ; if ( o1 == null || o2 == null ) return BOOL ; Class c = o1 . get Class ( ) ; if ( c != o2 . get Class ( ) ) return BOOL ; if ( c . is Array ( ) ) { int length = Array . get Length ( o1 ) ; int length 2 = Array . get Length ( o2 ) ; if ( length != length 2 ) return BOOL ; for ( int i = NUM ; i < length ; i ++ ) { Object c1 = Array . get ( o1 , i ) ; Object c2 = Array . get ( o2 , i ) ; if ( ! equals ( c1 , c2 ) ) return BOOL ; } return BOOL ; } else { return o1 . equals ( o2 ) ; } }
public static boolean equals ( Object o1 , Object o2 ) { if ( o1 == o2 ) return BOOL ; if ( o1 == null || o2 == null ) return BOOL ; Class c = o1 . get Class ( ) ; if ( c != o2 . get Class ( ) ) return BOOL ; if ( c . is Array ( ) ) { int length = Array . get Length ( o1 ) ; int length 2 = Array . get Length ( o2 ) ; if ( length != length 2 ) return BOOL ; for ( int i = NUM ; i < length ; i ++ ) { Object c1 = Array . get ( o1 , i ) ; Object c2 = Array . get ( o2 , i ) ; if ( ! equals ( c1 , c2 ) ) return BOOL ; } return BOOL ; } else { return o1 . equals ( o2 ) ; } }
public static byte [ ] hex String To Bytes ( final String hex String ) { return Datatype Converter . parse Hex Binary ( hex String ) ; }
public static byte [ ] hex String To Bytes ( final String hex String ) { return Datatype Converter . parse Hex Binary ( hex String ) ; }
public static byte [ ] hex String To Bytes ( final String hex String ) { return Datatype Converter . parse Hex Binary ( hex String ) ; }
protected void write Header ( Random Access File file , int size ) throws IO Exception { String str ; int offset = NUM ; byte [ ] buffer = new byte [ NUM ] ; str = Integer . to String ( get Size ( ) ) ; for ( int i = NUM ; i < ( NUM - str . length ( ) ) ; i ++ ) { buffer [ i ] = ( byte ) STRING ; } offset += ( NUM - str . length ( ) ) ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) { buffer [ i + offset ] = ( byte ) str . char At ( i ) ; } file . write ( buffer ) ; }
public boolean add All ( Collection coll , boolean allow Repeated ) { boolean is Changed = BOOL ; for ( Iterator i = coll . iterator ( ) ; i . has Next ( ) ; ) { add ( ( Coordinate ) i . next ( ) , allow Repeated ) ; is Changed = BOOL ; } return is Changed ; }
protected Async Http Request new Async Http Request ( Default Http Client client , Http Context http Context , Http Uri Request uri Request , String content Type , Response Handler Interface response Handler , Context context ) { return new Async Http Request ( client , http Context , uri Request , response Handler ) ; }
@ Override public Array List < String > list ( String path ) { Array List < String > file Name List = new Array List < String > ( ) ; Dropbox API . Entry files = null ; try { files = mDB Api . metadata ( path , NUM , null , BOOL , null ) ; for ( Entry e : files . contents ) { file Name List . add ( e . file Name ( ) ) ; } } catch ( Dropbox Exception e ) { e . print Stack Trace ( ) ; } return file Name List ; }
public void or With ( Or Condition other ) { children . add All ( other . get And Terms ( ) ) ; }
public void or With ( Or Condition other ) { children . add All ( other . get And Terms ( ) ) ; }
public void or With ( Or Condition other ) { children . add All ( other . get And Terms ( ) ) ; }
public void or With ( Or Condition other ) { children . add All ( other . get And Terms ( ) ) ; }
protected void add Bean Connection Relation ( Meta Bean meta , String connection ) { Vector < String > relations ; Object key ; relations = get Bean Connection Relation ( meta ) ; relations . add ( connection ) ; if ( meta == null ) { key = REGULAR CONNECTION ; } else { key = meta ; } m Bean Connection Relation . put ( key , relations ) ; }
public void put ( E e ) { offer ( e ) ; }
public void put ( E e ) { offer ( e ) ; }
public RM Realm Model Impl ( Http Servlet Request req , Map map ) { super ( req , map ) ; }
public RM Realm Model Impl ( Http Servlet Request req , Map map ) { super ( req , map ) ; }
public RM Realm Model Impl ( Http Servlet Request req , Map map ) { super ( req , map ) ; }
void push Base Indentifier ( String base ID ) { if ( null != base ID ) { int pos Of Hash = base ID . index Of ( STRING ) ; if ( pos Of Hash > - NUM ) { m fragment ID String = base ID . substring ( pos Of Hash + NUM ) ; m should Process = BOOL ; } else m should Process = BOOL ; } else m should Process = BOOL ; m base Identifiers . push ( base ID ) ; }
void push Base Indentifier ( String base ID ) { if ( null != base ID ) { int pos Of Hash = base ID . index Of ( STRING ) ; if ( pos Of Hash > - NUM ) { m fragment ID String = base ID . substring ( pos Of Hash + NUM ) ; m should Process = BOOL ; } else m should Process = BOOL ; } else m should Process = BOOL ; m base Identifiers . push ( base ID ) ; }
private void fill Inside Draw ( Graphics g , int x , int y , int w , int h ) { g . set Color ( Color . BLACK ) ; g . draw Rect ( x , y , w , h ) ; g . set Color ( Color . LIGHT GRAY ) ; g . fill Rect ( x + NUM , y + NUM , w - NUM , h - NUM ) ; }
private void fill Inside Draw ( Graphics g , int x , int y , int w , int h ) { g . set Color ( Color . BLACK ) ; g . draw Rect ( x , y , w , h ) ; g . set Color ( Color . LIGHT GRAY ) ; g . fill Rect ( x + NUM , y + NUM , w - NUM , h - NUM ) ; }
private void update Thumbnail Matrix ( ) { if ( m Thumbnail == null ) return ; if ( m Image Matrix == null ) m Image Matrix = new Matrix ( ) ; float width Scale = ( float ) get Measured Width ( ) / m Thumbnail . get Width ( ) ; float height Scale = ( float ) get Measured Height ( ) / m Thumbnail . get Height ( ) ; float scale = Math . max ( width Scale , height Scale ) ; m Image Matrix . set Scale ( scale , scale ) ; set Image Matrix ( m Image Matrix ) ; }
private void update Thumbnail Matrix ( ) { if ( m Thumbnail == null ) return ; if ( m Image Matrix == null ) m Image Matrix = new Matrix ( ) ; float width Scale = ( float ) get Measured Width ( ) / m Thumbnail . get Width ( ) ; float height Scale = ( float ) get Measured Height ( ) / m Thumbnail . get Height ( ) ; float scale = Math . max ( width Scale , height Scale ) ; m Image Matrix . set Scale ( scale , scale ) ; set Image Matrix ( m Image Matrix ) ; }
private void update Thumbnail Matrix ( ) { if ( m Thumbnail == null ) return ; if ( m Image Matrix == null ) m Image Matrix = new Matrix ( ) ; float width Scale = ( float ) get Measured Width ( ) / m Thumbnail . get Width ( ) ; float height Scale = ( float ) get Measured Height ( ) / m Thumbnail . get Height ( ) ; float scale = Math . max ( width Scale , height Scale ) ; m Image Matrix . set Scale ( scale , scale ) ; set Image Matrix ( m Image Matrix ) ; }
private void update Thumbnail Matrix ( ) { if ( m Thumbnail == null ) return ; if ( m Image Matrix == null ) m Image Matrix = new Matrix ( ) ; float width Scale = ( float ) get Measured Width ( ) / m Thumbnail . get Width ( ) ; float height Scale = ( float ) get Measured Height ( ) / m Thumbnail . get Height ( ) ; float scale = Math . max ( width Scale , height Scale ) ; m Image Matrix . set Scale ( scale , scale ) ; set Image Matrix ( m Image Matrix ) ; }
private void update Thumbnail Matrix ( ) { if ( m Thumbnail == null ) return ; if ( m Image Matrix == null ) m Image Matrix = new Matrix ( ) ; float width Scale = ( float ) get Measured Width ( ) / m Thumbnail . get Width ( ) ; float height Scale = ( float ) get Measured Height ( ) / m Thumbnail . get Height ( ) ; float scale = Math . max ( width Scale , height Scale ) ; m Image Matrix . set Scale ( scale , scale ) ; set Image Matrix ( m Image Matrix ) ; }
private void update Thumbnail Matrix ( ) { if ( m Thumbnail == null ) return ; if ( m Image Matrix == null ) m Image Matrix = new Matrix ( ) ; float width Scale = ( float ) get Measured Width ( ) / m Thumbnail . get Width ( ) ; float height Scale = ( float ) get Measured Height ( ) / m Thumbnail . get Height ( ) ; float scale = Math . max ( width Scale , height Scale ) ; m Image Matrix . set Scale ( scale , scale ) ; set Image Matrix ( m Image Matrix ) ; }
private void update Thumbnail Matrix ( ) { if ( m Thumbnail == null ) return ; if ( m Image Matrix == null ) m Image Matrix = new Matrix ( ) ; float width Scale = ( float ) get Measured Width ( ) / m Thumbnail . get Width ( ) ; float height Scale = ( float ) get Measured Height ( ) / m Thumbnail . get Height ( ) ; float scale = Math . max ( width Scale , height Scale ) ; m Image Matrix . set Scale ( scale , scale ) ; set Image Matrix ( m Image Matrix ) ; }
private void update Thumbnail Matrix ( ) { if ( m Thumbnail == null ) return ; if ( m Image Matrix == null ) m Image Matrix = new Matrix ( ) ; float width Scale = ( float ) get Measured Width ( ) / m Thumbnail . get Width ( ) ; float height Scale = ( float ) get Measured Height ( ) / m Thumbnail . get Height ( ) ; float scale = Math . max ( width Scale , height Scale ) ; m Image Matrix . set Scale ( scale , scale ) ; set Image Matrix ( m Image Matrix ) ; }
private void update Thumbnail Matrix ( ) { if ( m Thumbnail == null ) return ; if ( m Image Matrix == null ) m Image Matrix = new Matrix ( ) ; float width Scale = ( float ) get Measured Width ( ) / m Thumbnail . get Width ( ) ; float height Scale = ( float ) get Measured Height ( ) / m Thumbnail . get Height ( ) ; float scale = Math . max ( width Scale , height Scale ) ; m Image Matrix . set Scale ( scale , scale ) ; set Image Matrix ( m Image Matrix ) ; }
private void update Thumbnail Matrix ( ) { if ( m Thumbnail == null ) return ; if ( m Image Matrix == null ) m Image Matrix = new Matrix ( ) ; float width Scale = ( float ) get Measured Width ( ) / m Thumbnail . get Width ( ) ; float height Scale = ( float ) get Measured Height ( ) / m Thumbnail . get Height ( ) ; float scale = Math . max ( width Scale , height Scale ) ; m Image Matrix . set Scale ( scale , scale ) ; set Image Matrix ( m Image Matrix ) ; }
public void add Sprite ( Odor World Entity sprite ) { sprites . add ( sprite ) ; }
@ Override public Server Heartbeat server Dyn ( String address , int port , boolean is SSL , String cluster Id , String display Name ) { Objects . require Non Null ( address ) ; Objects . require Non Null ( cluster Id ) ; Cluster Heartbeat cluster = create Cluster ( cluster Id ) ; Server Heartbeat server = cluster . create Server ( address , port , is SSL ) ; if ( display Name != null ) { server . set Display Name ( display Name ) ; } cluster . add Dynamic Server ( server ) ; return server ; }
@ On Click ( R . id . info icon button ) public void on Info Click ( View view ) { Offer selected Offer ; int position = get Adapter Position ( ) ; int card Position = get Card Position ( position ) ; selected Offer = offers . get ( card Position ) ; go To Info ( selected Offer , view . get Context ( ) ) ; }
@ On Click ( R . id . info icon button ) public void on Info Click ( View view ) { Offer selected Offer ; int position = get Adapter Position ( ) ; int card Position = get Card Position ( position ) ; selected Offer = offers . get ( card Position ) ; go To Info ( selected Offer , view . get Context ( ) ) ; }
@ On Click ( R . id . info icon button ) public void on Info Click ( View view ) { Offer selected Offer ; int position = get Adapter Position ( ) ; int card Position = get Card Position ( position ) ; selected Offer = offers . get ( card Position ) ; go To Info ( selected Offer , view . get Context ( ) ) ; }
@ On Click ( R . id . info icon button ) public void on Info Click ( View view ) { Offer selected Offer ; int position = get Adapter Position ( ) ; int card Position = get Card Position ( position ) ; selected Offer = offers . get ( card Position ) ; go To Info ( selected Offer , view . get Context ( ) ) ; }
public static String ge Server Base URL ( Http Servlet Request request ) { String uri = request . get Request URI ( ) ; int index = uri . index Of ( STRING , NUM ) ; if ( index != - NUM ) { uri = uri . substring ( NUM , index ) ; } return request . get Scheme ( ) + STRING + request . get Server Name ( ) + STRING + request . get Server Port ( ) + uri ; }
private void add Action ( String label , int id , int type ) { Card Action card Action = new Card Action ( ) ; card Action . label = label ; card Action . id = id ; card Action . type = type ; m Card Actions . add ( card Action ) ; }
private void handle Channel Info Result ( Request Type type , String url , String result , int response Code , String stream ) { if ( result == null || response Code != NUM ) { handle Channel Info Result Error ( stream , type , response Code ) ; return ; } Channel Info info = parse Channel Info ( result ) ; if ( info == null ) { LOGGER . warning ( STRING + result ) ; handle Channel Info Result Error ( stream , type , response Code ) ; return ; } if ( type == Request Type . CHANNEL PUT ) { result Listener . put Channel Info Result ( Request Result . SUCCESS ) ; } result Listener . received Channel Info ( stream , info , Request Result . SUCCESS ) ; cached Channel Info . put ( stream , info ) ; user I Ds . channel Info Received ( info ) ; }
public double normal Distance ( final double x , final double y , final double z ) { return Math . sqrt ( normal Distance Squared ( x , y , z ) ) ; }
public mx I Cell Overlay remove Cell Overlay ( Object cell , mx I Cell Overlay overlay ) { if ( overlay == null ) { remove Cell Overlays ( cell ) ; } else { mx I Cell Overlay [ ] arr = get Cell Overlays ( cell ) ; if ( arr != null ) { List < mx I Cell Overlay > list = Arrays . as List ( arr ) ; if ( list . remove ( overlay ) ) { remove Cell Overlay Component ( overlay , cell ) ; } arr = ( mx I Cell Overlay [ ] ) list . to Array ( ) ; overlays . put ( cell , arr ) ; } } return overlay ; }
public mx I Cell Overlay remove Cell Overlay ( Object cell , mx I Cell Overlay overlay ) { if ( overlay == null ) { remove Cell Overlays ( cell ) ; } else { mx I Cell Overlay [ ] arr = get Cell Overlays ( cell ) ; if ( arr != null ) { List < mx I Cell Overlay > list = Arrays . as List ( arr ) ; if ( list . remove ( overlay ) ) { remove Cell Overlay Component ( overlay , cell ) ; } arr = ( mx I Cell Overlay [ ] ) list . to Array ( ) ; overlays . put ( cell , arr ) ; } } return overlay ; }
@ Override public DOM Implementation item ( int index ) { final int length = get Length ( ) ; if ( index >= NUM && index < length ) { return ( DOM Implementation ) f Implementations . get ( index ) ; } return null ; }
@ Override public DOM Implementation item ( int index ) { final int length = get Length ( ) ; if ( index >= NUM && index < length ) { return ( DOM Implementation ) f Implementations . get ( index ) ; } return null ; }
private void remove Keys ( Hashtable theme Res , String uiid ) { if ( uiid == null || uiid . length ( ) == NUM ) { for ( Object k : theme Res . key Set ( ) ) { String key = ( String ) k ; if ( key . index Of ( STRING ) > - NUM || key . index Of ( STRING ) > - NUM || key . index Of ( STRING ) > - NUM ) { continue ; } theme Res . remove ( key ) ; remove Keys ( theme Res , uiid ) ; return ; } return ; } for ( Object k : theme Res . key Set ( ) ) { String key = ( String ) k ; if ( key . starts With ( uiid ) ) { if ( prefix . length ( ) == NUM && key . index Of ( STRING ) > NUM ) { continue ; } theme Res . remove ( key ) ; remove Keys ( theme Res , uiid ) ; return ; } } }
private void remove Keys ( Hashtable theme Res , String uiid ) { if ( uiid == null || uiid . length ( ) == NUM ) { for ( Object k : theme Res . key Set ( ) ) { String key = ( String ) k ; if ( key . index Of ( STRING ) > - NUM || key . index Of ( STRING ) > - NUM || key . index Of ( STRING ) > - NUM ) { continue ; } theme Res . remove ( key ) ; remove Keys ( theme Res , uiid ) ; return ; } return ; } for ( Object k : theme Res . key Set ( ) ) { String key = ( String ) k ; if ( key . starts With ( uiid ) ) { if ( prefix . length ( ) == NUM && key . index Of ( STRING ) > NUM ) { continue ; } theme Res . remove ( key ) ; remove Keys ( theme Res , uiid ) ; return ; } } }
public void add Setter ( int i ) { for ( Scatter Plot Setter setter : setter List ) { if ( setter . get Index ( ) == i ) { return ; } } setter List . add ( new Scatter Plot Setter ( i ) ) ; }
public void remove ( final int index ) { check Widget ( ) ; if ( index < NUM || index >= items . size ( ) ) { SWT . error ( SWT . ERROR INVALID ARGUMENT ) ; } items . remove ( index ) ; redraw Tables ( ) ; }
public static Key Store load Key Store ( String type , File file , char [ ] password ) throws Exception { Key Store key Store = Key Store . get Instance ( type ) ; try ( File Input Stream fis = new File Input Stream ( file ) ) { key Store . load ( fis , password ) ; } return key Store ; }
protected void garbage Collect ( Visual Table labels ) { Iterator iter = labels . tuples ( ) ; while ( iter . has Next ( ) ) { Visual Item item = ( Visual Item ) iter . next ( ) ; if ( ! item . is Start Visible ( ) && ! item . is End Visible ( ) ) { labels . remove Tuple ( item ) ; } } }
protected void garbage Collect ( Visual Table labels ) { Iterator iter = labels . tuples ( ) ; while ( iter . has Next ( ) ) { Visual Item item = ( Visual Item ) iter . next ( ) ; if ( ! item . is Start Visible ( ) && ! item . is End Visible ( ) ) { labels . remove Tuple ( item ) ; } } }
@ Override protected void update ( ) { m Button Start . set Enabled ( has Data ( ) ) ; m Button Stop . set Enabled ( is Running ( ) ) ; }
public static final Timeout Token add Timeout Handler ( long run Time , Runnable handler ) { Timeout Token token = new Timeout Token ( run Time , handler ) ; synchronized ( todolist ) { todolist . add ( token ) ; Collections . sort ( todolist ) ; if ( timeout Thread != null ) timeout Thread . interrupt ( ) ; else { timeout Thread = new Timeout Thread ( ) ; timeout Thread . set Daemon ( BOOL ) ; timeout Thread . start ( ) ; } } return token ; }
public static WKT Geometry create Empty ( WKT Type wkt Type ) { WKT Geometry wkt Geometry = new WKT Geometry ( ) ; wkt Geometry . set Geometry Type ( wkt Type ) ; return wkt Geometry ; }
public static Object execute Script ( String file Path , String function Name , Map < String , Object > context ) { return execute Script ( file Path , function Name , context , new Object [ ] { context } ) ; }
public static Object execute Script ( String file Path , String function Name , Map < String , Object > context ) { return execute Script ( file Path , function Name , context , new Object [ ] { context } ) ; }
public static Object execute Script ( String file Path , String function Name , Map < String , Object > context ) { return execute Script ( file Path , function Name , context , new Object [ ] { context } ) ; }
public Data Type Parser register ( int jdbc Type , String grammar ) { Objects . require Non Null ( grammar , STRING ) ; Data Type Pattern pattern = parser . parse ( jdbc Type , grammar ) ; pattern . for Each First Token ( null ) ; return this ; }
public Data Type Parser register ( int jdbc Type , String grammar ) { Objects . require Non Null ( grammar , STRING ) ; Data Type Pattern pattern = parser . parse ( jdbc Type , grammar ) ; pattern . for Each First Token ( null ) ; return this ; }
public Data Type Parser register ( int jdbc Type , String grammar ) { Objects . require Non Null ( grammar , STRING ) ; Data Type Pattern pattern = parser . parse ( jdbc Type , grammar ) ; pattern . for Each First Token ( null ) ; return this ; }
public Data Type Parser register ( int jdbc Type , String grammar ) { Objects . require Non Null ( grammar , STRING ) ; Data Type Pattern pattern = parser . parse ( jdbc Type , grammar ) ; pattern . for Each First Token ( null ) ; return this ; }
public Data Type Parser register ( int jdbc Type , String grammar ) { Objects . require Non Null ( grammar , STRING ) ; Data Type Pattern pattern = parser . parse ( jdbc Type , grammar ) ; pattern . for Each First Token ( null ) ; return this ; }
public Data Type Parser register ( int jdbc Type , String grammar ) { Objects . require Non Null ( grammar , STRING ) ; Data Type Pattern pattern = parser . parse ( jdbc Type , grammar ) ; pattern . for Each First Token ( null ) ; return this ; }
public Data Type Parser register ( int jdbc Type , String grammar ) { Objects . require Non Null ( grammar , STRING ) ; Data Type Pattern pattern = parser . parse ( jdbc Type , grammar ) ; pattern . for Each First Token ( null ) ; return this ; }
public Data Type Parser register ( int jdbc Type , String grammar ) { Objects . require Non Null ( grammar , STRING ) ; Data Type Pattern pattern = parser . parse ( jdbc Type , grammar ) ; pattern . for Each First Token ( null ) ; return this ; }
public Data Type Parser register ( int jdbc Type , String grammar ) { Objects . require Non Null ( grammar , STRING ) ; Data Type Pattern pattern = parser . parse ( jdbc Type , grammar ) ; pattern . for Each First Token ( null ) ; return this ; }
public boolean remove Entry ( T e ) { if ( e == null ) return BOOL ; boolean removed = mY Vals . remove ( e ) ; if ( removed ) { float val = e . get Val ( ) ; mY Value Sum -= val ; calc Min Max ( m Last Start , m Last End ) ; } return removed ; }
public boolean remove Entry ( T e ) { if ( e == null ) return BOOL ; boolean removed = mY Vals . remove ( e ) ; if ( removed ) { float val = e . get Val ( ) ; mY Value Sum -= val ; calc Min Max ( m Last Start , m Last End ) ; } return removed ; }
public synchronized void add Template ( Docker Slave Template t ) { templates . add ( t ) ; }
public static String transform Filename ( String file Name ) { if ( ! file Name . ends With ( STRING ) ) { file Name = file Name + STRING ; } return file Name ; }
public static String transform Filename ( String file Name ) { if ( ! file Name . ends With ( STRING ) ) { file Name = file Name + STRING ; } return file Name ; }
public static String transform Filename ( String file Name ) { if ( ! file Name . ends With ( STRING ) ) { file Name = file Name + STRING ; } return file Name ; }
public int next Int ( ) { throw new Unsupported Operation Exception ( STRING ) ; }
public int next Int ( ) { throw new Unsupported Operation Exception ( STRING ) ; }
public int next Int ( ) { throw new Unsupported Operation Exception ( STRING ) ; }
public int next Int ( ) { throw new Unsupported Operation Exception ( STRING ) ; }
public int next Int ( ) { throw new Unsupported Operation Exception ( STRING ) ; }
public int next Int ( ) { throw new Unsupported Operation Exception ( STRING ) ; }
public int next Int ( ) { throw new Unsupported Operation Exception ( STRING ) ; }
public void finish ( boolean restore Builtin Classes ) { Doc Comment Generator g = new Top Level Generator ( ) ; g . generate ( tab ) ; xml = g . to String ( ) ; g = null ; if ( restore Builtin Classes && xml != null ) { xml = xml . replace All ( STRING , STRING ) ; xml = xml . replace All ( STRING , STRING ) ; xml = xml . replace All ( STRING , STRING ) ; } }
public void finish ( boolean restore Builtin Classes ) { Doc Comment Generator g = new Top Level Generator ( ) ; g . generate ( tab ) ; xml = g . to String ( ) ; g = null ; if ( restore Builtin Classes && xml != null ) { xml = xml . replace All ( STRING , STRING ) ; xml = xml . replace All ( STRING , STRING ) ; xml = xml . replace All ( STRING , STRING ) ; } }
private void draw Text Elements ( Canvas canvas , float text Size , Typeface typeface , Color State List text Color , String [ ] texts , float [ ] text X , float [ ] text Y , Paint paint , int alpha , boolean show Activated , int activated Degrees , boolean activated Only ) { paint . set Text Size ( text Size ) ; paint . set Typeface ( typeface ) ; final float activated Index = activated Degrees / ( NUM / NUM POSITIONS ) ; final int activated Floor = ( int ) activated Index ; final int activated Ceil = ( ( int ) Math . ceil ( activated Index ) ) % NUM POSITIONS ; for ( int i = NUM ; i < NUM ; i ++ ) { final boolean activated = ( activated Floor == i || activated Ceil == i ) ; if ( activated Only && ! activated ) { continue ; } final int [ ] state Mask = new int [ ] { android . R . attr . state enabled , ( show Activated && activated ? android . R . attr . state selected : NUM ) } ; final int color = text Color . get Color For State ( state Mask , NUM ) ; paint . set Color ( color ) ; paint . set Alpha ( get Multiplied Alpha ( color , alpha ) ) ; canvas . draw Text ( texts [ i ] , text X [ i ] , text Y [ i ] , paint ) ; } }
private void draw Text Elements ( Canvas canvas , float text Size , Typeface typeface , Color State List text Color , String [ ] texts , float [ ] text X , float [ ] text Y , Paint paint , int alpha , boolean show Activated , int activated Degrees , boolean activated Only ) { paint . set Text Size ( text Size ) ; paint . set Typeface ( typeface ) ; final float activated Index = activated Degrees / ( NUM / NUM POSITIONS ) ; final int activated Floor = ( int ) activated Index ; final int activated Ceil = ( ( int ) Math . ceil ( activated Index ) ) % NUM POSITIONS ; for ( int i = NUM ; i < NUM ; i ++ ) { final boolean activated = ( activated Floor == i || activated Ceil == i ) ; if ( activated Only && ! activated ) { continue ; } final int [ ] state Mask = new int [ ] { android . R . attr . state enabled , ( show Activated && activated ? android . R . attr . state selected : NUM ) } ; final int color = text Color . get Color For State ( state Mask , NUM ) ; paint . set Color ( color ) ; paint . set Alpha ( get Multiplied Alpha ( color , alpha ) ) ; canvas . draw Text ( texts [ i ] , text X [ i ] , text Y [ i ] , paint ) ; } }
public void test Benchmark ( ) throws Exception { run Test ( STRING , STRING ) ; run Test ( STRING , STRING ) ; }
public void test Benchmark ( ) throws Exception { run Test ( STRING , STRING ) ; run Test ( STRING , STRING ) ; }
public void test Benchmark ( ) throws Exception { run Test ( STRING , STRING ) ; run Test ( STRING , STRING ) ; }
public void test Benchmark ( ) throws Exception { run Test ( STRING , STRING ) ; run Test ( STRING , STRING ) ; }
public void test Benchmark ( ) throws Exception { run Test ( STRING , STRING ) ; run Test ( STRING , STRING ) ; }
public void test Benchmark ( ) throws Exception { run Test ( STRING , STRING ) ; run Test ( STRING , STRING ) ; }
public void test Benchmark ( ) throws Exception { run Test ( STRING , STRING ) ; run Test ( STRING , STRING ) ; }
public void test Benchmark ( ) throws Exception { run Test ( STRING , STRING ) ; run Test ( STRING , STRING ) ; }
private void update Less Than Gwt 25 ( List < String > program Args , int index Disabled , int index Enabled ) { if ( index Disabled > - NUM ) { program Args . remove ( index Disabled ) ; } if ( index Enabled > - NUM ) { program Args . remove ( index Enabled ) ; } }
public static Uri add Message To Uri ( Content Resolver resolver , Uri uri , String address , String body , String subject , Long date , boolean read , boolean delivery Report ) { return add Message To Uri ( resolver , uri , address , body , subject , date , read , delivery Report , - NUM ) ; }
public void paint ( Graphics g ) { g = g . create ( ) ; set Rendering Hints ( g ) ; set Composite On Graphics ( ( Graphics 2 D ) g ) ; super . paint ( g ) ; }
public void paint ( Graphics g ) { g = g . create ( ) ; set Rendering Hints ( g ) ; set Composite On Graphics ( ( Graphics 2 D ) g ) ; super . paint ( g ) ; }
public void paint ( Graphics g ) { g = g . create ( ) ; set Rendering Hints ( g ) ; set Composite On Graphics ( ( Graphics 2 D ) g ) ; super . paint ( g ) ; }
public void paint ( Graphics g ) { g = g . create ( ) ; set Rendering Hints ( g ) ; set Composite On Graphics ( ( Graphics 2 D ) g ) ; super . paint ( g ) ; }
public void paint ( Graphics g ) { g = g . create ( ) ; set Rendering Hints ( g ) ; set Composite On Graphics ( ( Graphics 2 D ) g ) ; super . paint ( g ) ; }
public void paint ( Graphics g ) { g = g . create ( ) ; set Rendering Hints ( g ) ; set Composite On Graphics ( ( Graphics 2 D ) g ) ; super . paint ( g ) ; }
public void paint ( Graphics g ) { g = g . create ( ) ; set Rendering Hints ( g ) ; set Composite On Graphics ( ( Graphics 2 D ) g ) ; super . paint ( g ) ; }
private Action Button create Toolbar Button ( Action action ) { return new Action Button ( action , action Manager , presentation Factory . get Presentation ( action ) , manager Provider . get ( ) , toolbar Resources ) ; }
public Namespace ( Principal User creator , String qualifier , Principal User owner , Set < Principal User > users ) { super ( creator ) ; set Qualifier ( qualifier ) ; set Owner ( owner ) ; if ( users != null && ! users . is Empty ( ) ) { set Users ( users ) ; } add User ( owner ) ; }
public void disable Schedule Renewal ( ) { current Lease . set ( null ) ; Set < Lease > leases = new Hash Set < > ( schedules . key Set ( ) ) ; for ( Lease lease : leases ) { cancel Schedule ( lease ) ; schedules . remove ( lease ) ; } }
public void update User Info ( Bundle user Info ) { m User Info = user Info ; load Chat Messages ( ) ; }
private static List < List < ? > > execute H 2 Query ( String sql , Object [ ] args ) throws SQL Exception { List < List < ? > > res = new Array List < > ( ) ; Result Set rs = null ; try ( Prepared Statement st = conn . prepare Statement ( sql ) ) { for ( int idx = NUM ; idx < args . length ; idx ++ ) st . set Object ( idx + NUM , args [ idx ] ) ; rs = st . execute Query ( ) ; Result Set Meta Data meta = rs . get Meta Data ( ) ; int col Cnt = meta . get Column Count ( ) ; while ( rs . next ( ) ) { List < Object > row = new Array List < > ( col Cnt ) ; for ( int i = NUM ; i <= col Cnt ; i ++ ) row . add ( rs . get Object ( i ) ) ; res . add ( row ) ; } } finally { U . close Quiet ( rs ) ; } return res ; }
private static List < List < ? > > execute H 2 Query ( String sql , Object [ ] args ) throws SQL Exception { List < List < ? > > res = new Array List < > ( ) ; Result Set rs = null ; try ( Prepared Statement st = conn . prepare Statement ( sql ) ) { for ( int idx = NUM ; idx < args . length ; idx ++ ) st . set Object ( idx + NUM , args [ idx ] ) ; rs = st . execute Query ( ) ; Result Set Meta Data meta = rs . get Meta Data ( ) ; int col Cnt = meta . get Column Count ( ) ; while ( rs . next ( ) ) { List < Object > row = new Array List < > ( col Cnt ) ; for ( int i = NUM ; i <= col Cnt ; i ++ ) row . add ( rs . get Object ( i ) ) ; res . add ( row ) ; } } finally { U . close Quiet ( rs ) ; } return res ; }
public void add All ( Collection < Individual > new Individuals ) { individuals . add All ( new Individuals ) ; }
public String generate Export Change Path Params ( Workflow workflow , String wf Group Id , String wait For , URI storage URI , URI export Group URI , URI volume URI ) throws Controller Exception { Discovered System Object storage System = get Storage System ( db Client , storage URI ) ; Block Object volume = Block Object . fetch ( db Client , volume URI ) ; Workflow . Method method = Export Workflow Entry Points . export Group Change Path Params Method ( storage URI , export Group URI , volume URI ) ; return new Workflow Step ( workflow , wf Group Id , String . format ( STRING , storage System . get Native Guid ( ) , storage URI , volume . get Label ( ) , volume URI ) , storage System , method , null , wait For ) ; }
protected void update Idle Expire Time ( long now ) { thread Idle Expire Time . set ( now + idle Timeout ) ; }
@ Nullable public V remove Last ( ) { return vals . is Empty ( ) ? null : vals . remove Last ( ) ; }
public Curve make Curve ( int color ) { Curve c = new Curve ( color ) ; curves . add ( c ) ; return c ; }
private Set < Entity > analyse Required Updates ( Audit Information audit , Operation Group update Group ) { Set < Entity > update Required = new Hash Set < > ( ) ; Set < Entity > update Not Required = new Hash Set < > ( ) ; for ( Entity entity : update Group . get Entities ( ) ) { analyse Entity Requires Update ( audit , entity , update Required , update Not Required ) ; } return update Required ; }
private Set < Entity > analyse Required Updates ( Audit Information audit , Operation Group update Group ) { Set < Entity > update Required = new Hash Set < > ( ) ; Set < Entity > update Not Required = new Hash Set < > ( ) ; for ( Entity entity : update Group . get Entities ( ) ) { analyse Entity Requires Update ( audit , entity , update Required , update Not Required ) ; } return update Required ; }
private Set < Entity > analyse Required Updates ( Audit Information audit , Operation Group update Group ) { Set < Entity > update Required = new Hash Set < > ( ) ; Set < Entity > update Not Required = new Hash Set < > ( ) ; for ( Entity entity : update Group . get Entities ( ) ) { analyse Entity Requires Update ( audit , entity , update Required , update Not Required ) ; } return update Required ; }
public T Double Double Hash Map absolute Distribution Log 10 ( double descretization ) { T Double Double Hash Map freq = new T Double Double Hash Map ( ) ; int size = values . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) { double bin idx = Math . ceil ( Math . log 10 ( values . get ( i ) / descretization ) ) ; bin idx = Math . max ( bin idx , NUM ) ; double bin Width = Math . pow ( NUM , bin idx ) - Math . pow ( NUM , bin idx - NUM ) ; bin Width = Math . max ( NUM , bin Width ) ; freq . adjust Or Put Value ( Math . pow ( NUM , bin idx ) * descretization , weights . get ( i ) / bin Width , weights . get ( i ) / bin Width ) ; } return freq ; }
public T Double Double Hash Map absolute Distribution Log 10 ( double descretization ) { T Double Double Hash Map freq = new T Double Double Hash Map ( ) ; int size = values . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) { double bin idx = Math . ceil ( Math . log 10 ( values . get ( i ) / descretization ) ) ; bin idx = Math . max ( bin idx , NUM ) ; double bin Width = Math . pow ( NUM , bin idx ) - Math . pow ( NUM , bin idx - NUM ) ; bin Width = Math . max ( NUM , bin Width ) ; freq . adjust Or Put Value ( Math . pow ( NUM , bin idx ) * descretization , weights . get ( i ) / bin Width , weights . get ( i ) / bin Width ) ; } return freq ; }
public T Double Double Hash Map absolute Distribution Log 10 ( double descretization ) { T Double Double Hash Map freq = new T Double Double Hash Map ( ) ; int size = values . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) { double bin idx = Math . ceil ( Math . log 10 ( values . get ( i ) / descretization ) ) ; bin idx = Math . max ( bin idx , NUM ) ; double bin Width = Math . pow ( NUM , bin idx ) - Math . pow ( NUM , bin idx - NUM ) ; bin Width = Math . max ( NUM , bin Width ) ; freq . adjust Or Put Value ( Math . pow ( NUM , bin idx ) * descretization , weights . get ( i ) / bin Width , weights . get ( i ) / bin Width ) ; } return freq ; }
public T Double Double Hash Map absolute Distribution Log 10 ( double descretization ) { T Double Double Hash Map freq = new T Double Double Hash Map ( ) ; int size = values . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) { double bin idx = Math . ceil ( Math . log 10 ( values . get ( i ) / descretization ) ) ; bin idx = Math . max ( bin idx , NUM ) ; double bin Width = Math . pow ( NUM , bin idx ) - Math . pow ( NUM , bin idx - NUM ) ; bin Width = Math . max ( NUM , bin Width ) ; freq . adjust Or Put Value ( Math . pow ( NUM , bin idx ) * descretization , weights . get ( i ) / bin Width , weights . get ( i ) / bin Width ) ; } return freq ; }
private String generate Fitting Text ( Method method , Rectangle 2 D rect , Font Metrics font Metrics ) { if ( rect . get Width ( ) < font Metrics . string Width ( STRING ) ) { return STRING ; } String fully Qualified = method . get Name Space ( ) + STRING + method . get Name ( ) ; if ( font Metrics . string Width ( fully Qualified ) < rect . get Width ( ) ) { return fully Qualified ; } String abbrev Package = get Short Package Name ( method . get Name Space ( ) ) + STRING + method . get Name ( ) ; if ( font Metrics . string Width ( abbrev Package ) < rect . get Width ( ) ) { return abbrev Package ; } if ( font Metrics . string Width ( method . get Name ( ) ) < rect . get Width ( ) ) { return method . get Name ( ) ; } return STRING ; }
private void start Background Timer ( ) { if ( m Background Timer != null ) { m Background Timer . cancel ( ) ; } m Background Timer = new Timer ( ) ; m Background Timer . schedule ( new Update Background Task ( ) , BACKGROUND UPDATE DELAY ) ; }
public static byte [ ] sub Array ( byte [ ] input , int start , int end ) { byte [ ] result = new byte [ end - start ] ; System . arraycopy ( input , start , result , NUM , end - start ) ; return result ; }
public synchronized void delete Least Used Connection ( ) { final Http Connection connection = ( Http Connection ) free Connections . remove First ( ) ; if ( connection != null ) { delete Connection ( connection ) ; } else if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( STRING ) ; } }
protected void add Action Exception Warning ( Exception e ) { String msg = e . get Message ( ) ; if ( msg != null ) { warnings . add ( msg ) ; } }
@ Api Operation ( value = STRING ) @ Request Mapping ( value = STRING , method = Request Method . POST ) @ Response Status ( Http Status . NO CONTENT ) @ Response Body public final void post Request Initial Load ( @ Path Variable ( STRING ) String engine Name , @ Request Param ( value = STRING ) String node Id ) { I Symmetric Engine engine = get Symmetric Engine ( engine Name ) ; I Node Service node Service = engine . get Node Service ( ) ; node Service . set Initial Load Enabled ( node Id , BOOL , BOOL , - NUM , STRING ) ; }
@ Api Operation ( value = STRING ) @ Request Mapping ( value = STRING , method = Request Method . POST ) @ Response Status ( Http Status . NO CONTENT ) @ Response Body public final void post Request Initial Load ( @ Path Variable ( STRING ) String engine Name , @ Request Param ( value = STRING ) String node Id ) { I Symmetric Engine engine = get Symmetric Engine ( engine Name ) ; I Node Service node Service = engine . get Node Service ( ) ; node Service . set Initial Load Enabled ( node Id , BOOL , BOOL , - NUM , STRING ) ; }
@ Api Operation ( value = STRING ) @ Request Mapping ( value = STRING , method = Request Method . POST ) @ Response Status ( Http Status . NO CONTENT ) @ Response Body public final void post Request Initial Load ( @ Path Variable ( STRING ) String engine Name , @ Request Param ( value = STRING ) String node Id ) { I Symmetric Engine engine = get Symmetric Engine ( engine Name ) ; I Node Service node Service = engine . get Node Service ( ) ; node Service . set Initial Load Enabled ( node Id , BOOL , BOOL , - NUM , STRING ) ; }
@ Api Operation ( value = STRING ) @ Request Mapping ( value = STRING , method = Request Method . POST ) @ Response Status ( Http Status . NO CONTENT ) @ Response Body public final void post Request Initial Load ( @ Path Variable ( STRING ) String engine Name , @ Request Param ( value = STRING ) String node Id ) { I Symmetric Engine engine = get Symmetric Engine ( engine Name ) ; I Node Service node Service = engine . get Node Service ( ) ; node Service . set Initial Load Enabled ( node Id , BOOL , BOOL , - NUM , STRING ) ; }
public Disjunction Max Weight ( Index Searcher searcher , boolean needs Scores , float boost ) throws IO Exception { super ( Disjunction Max Query . this ) ; for ( Query disjunct Query : disjuncts ) { weights . add ( searcher . create Weight ( disjunct Query , needs Scores , boost ) ) ; } this . needs Scores = needs Scores ; }
public void unregister M Bean ( Object Name object Name ) { try { if ( ! is Registered ( object Name ) ) { return ; } mbean Server . unregister M Bean ( object Name ) ; if ( local Gem Fire M Bean . get ( object Name ) != null ) { local Gem Fire M Bean . remove ( object Name ) ; } } catch ( Null Pointer Exception e ) { throw new Management Exception ( e ) ; } catch ( Instance Not Found Exception e ) { throw new Management Exception ( e ) ; } catch ( M Bean Registration Exception e ) { throw new Management Exception ( e ) ; } }
public void write ( Data Output dos ) throws IO Exception { int length = ( points . length / NUM ) * NUM ; dos . write Int ( length ) ; for ( int i = NUM ; i < length ; i ++ ) { dos . write Float ( points [ i ] ) ; } }
public void write ( Data Output dos ) throws IO Exception { int length = ( points . length / NUM ) * NUM ; dos . write Int ( length ) ; for ( int i = NUM ; i < length ; i ++ ) { dos . write Float ( points [ i ] ) ; } }
public static Connection ensure Table Exists ( final Table table ) throws SQL Exception { establish Connection ( ) ; try ( final Statement stmt = connection . create Statement ( ) ) { stmt . execute ( table . get Creation Statement ( ) ) ; return connection ; } }
public static Connection ensure Table Exists ( final Table table ) throws SQL Exception { establish Connection ( ) ; try ( final Statement stmt = connection . create Statement ( ) ) { stmt . execute ( table . get Creation Statement ( ) ) ; return connection ; } }
public static Connection ensure Table Exists ( final Table table ) throws SQL Exception { establish Connection ( ) ; try ( final Statement stmt = connection . create Statement ( ) ) { stmt . execute ( table . get Creation Statement ( ) ) ; return connection ; } }
private void write Object ( java . io . Object Output Stream s ) throws java . io . IO Exception { s . write Object ( to String ( ) ) ; }
private void write Object ( java . io . Object Output Stream s ) throws java . io . IO Exception { s . write Object ( to String ( ) ) ; }
private void write Object ( java . io . Object Output Stream s ) throws java . io . IO Exception { s . write Object ( to String ( ) ) ; }
public void forget Ffmpeg Path ( ) { settings . put ( SETTINGS FFMPEG PATH , FFMPEG PATH UNSET ) ; }
public Builder with Threads ( int threads ) { properties . set Property ( Netty Options . THREADS , String . value Of ( Assert . arg Not ( threads , threads <= NUM , STRING ) ) ) ; return this ; }
private void close Jar ( String path ) { if ( jarfiles . contains Key ( path ) ) { Jar Holder the Jar = ( Jar Holder ) jarfiles . get ( path ) ; the Jar . close ( ) ; } }
public static long copy ( Input Stream input , Output Stream output , byte [ ] buffer ) throws IO Exception { long count = NUM ; int n = NUM ; while ( - NUM != ( n = input . read ( buffer ) ) ) { output . write ( buffer , NUM , n ) ; count += n ; } return count ; }
public static long copy ( Input Stream input , Output Stream output , byte [ ] buffer ) throws IO Exception { long count = NUM ; int n = NUM ; while ( - NUM != ( n = input . read ( buffer ) ) ) { output . write ( buffer , NUM , n ) ; count += n ; } return count ; }
public static long copy ( Input Stream input , Output Stream output , byte [ ] buffer ) throws IO Exception { long count = NUM ; int n = NUM ; while ( - NUM != ( n = input . read ( buffer ) ) ) { output . write ( buffer , NUM , n ) ; count += n ; } return count ; }
public static long copy ( Input Stream input , Output Stream output , byte [ ] buffer ) throws IO Exception { long count = NUM ; int n = NUM ; while ( - NUM != ( n = input . read ( buffer ) ) ) { output . write ( buffer , NUM , n ) ; count += n ; } return count ; }
public static long copy ( Input Stream input , Output Stream output , byte [ ] buffer ) throws IO Exception { long count = NUM ; int n = NUM ; while ( - NUM != ( n = input . read ( buffer ) ) ) { output . write ( buffer , NUM , n ) ; count += n ; } return count ; }
private void configure Output Stream ( ) { String filename = generate Filename ( ) ; File file = null ; try { file = acquire Unique File ( filename ) ; if ( is Debuggable ( Level . CONFIG ) ) { Log Helper . println ( STRING , Level . CONFIG , STRING + file . get Absolute Path ( ) ) ; } File Output Stream fout = new File Output Stream ( file , append ) ; Buffered Output Stream bout = new Buffered Output Stream ( fout ) ; Metered Stream metered Stream = new Metered Stream ( bout , ( int ) file . length ( ) ) ; set Output Stream ( metered Stream ) ; size Rolling Policy . set Metered Stream ( metered Stream ) ; time Rolling Policy . set Timestamp ( ) ; backup Policy . track ( file ) ; if ( monitor Created Files ) { files Created . add ( NUM , file ) ; } } catch ( IO Exception ioe ) { String filepath = file != null ? file . get Absolute Path ( ) : filename ; report Error ( STRING + filepath , ioe , Error Manager . OPEN FAILURE ) ; corrupted Output Stream = BOOL ; } }
private void configure Output Stream ( ) { String filename = generate Filename ( ) ; File file = null ; try { file = acquire Unique File ( filename ) ; if ( is Debuggable ( Level . CONFIG ) ) { Log Helper . println ( STRING , Level . CONFIG , STRING + file . get Absolute Path ( ) ) ; } File Output Stream fout = new File Output Stream ( file , append ) ; Buffered Output Stream bout = new Buffered Output Stream ( fout ) ; Metered Stream metered Stream = new Metered Stream ( bout , ( int ) file . length ( ) ) ; set Output Stream ( metered Stream ) ; size Rolling Policy . set Metered Stream ( metered Stream ) ; time Rolling Policy . set Timestamp ( ) ; backup Policy . track ( file ) ; if ( monitor Created Files ) { files Created . add ( NUM , file ) ; } } catch ( IO Exception ioe ) { String filepath = file != null ? file . get Absolute Path ( ) : filename ; report Error ( STRING + filepath , ioe , Error Manager . OPEN FAILURE ) ; corrupted Output Stream = BOOL ; } }
private void configure Output Stream ( ) { String filename = generate Filename ( ) ; File file = null ; try { file = acquire Unique File ( filename ) ; if ( is Debuggable ( Level . CONFIG ) ) { Log Helper . println ( STRING , Level . CONFIG , STRING + file . get Absolute Path ( ) ) ; } File Output Stream fout = new File Output Stream ( file , append ) ; Buffered Output Stream bout = new Buffered Output Stream ( fout ) ; Metered Stream metered Stream = new Metered Stream ( bout , ( int ) file . length ( ) ) ; set Output Stream ( metered Stream ) ; size Rolling Policy . set Metered Stream ( metered Stream ) ; time Rolling Policy . set Timestamp ( ) ; backup Policy . track ( file ) ; if ( monitor Created Files ) { files Created . add ( NUM , file ) ; } } catch ( IO Exception ioe ) { String filepath = file != null ? file . get Absolute Path ( ) : filename ; report Error ( STRING + filepath , ioe , Error Manager . OPEN FAILURE ) ; corrupted Output Stream = BOOL ; } }
private static Path 2 D create Left Tab Shape ( int x , int y , int w , int h , double r Left , boolean add Side ) { Path 2 D path = new Path 2 D . Double ( ) ; path . append ( new Line 2 D . Double ( x + w , y + h , x + r Left , y + h ) , BOOL ) ; Quad Curve 2 D curve = new Quad Curve 2 D . Double ( x + r Left , y + h , x , y + h , x , y + h - r Left ) ; path . append ( curve , BOOL ) ; path . append ( new Line 2 D . Double ( x , y + h - r Left , x , y + r Left ) , BOOL ) ; curve = new Quad Curve 2 D . Double ( x , y + r Left , x , y , x + r Left , y ) ; path . append ( curve , BOOL ) ; path . append ( new Line 2 D . Double ( x + r Left , y , x + w , y ) , BOOL ) ; if ( add Side ) { path . append ( new Line 2 D . Double ( x + w , y , x + w , y + h - NUM ) , BOOL ) ; } return path ; }
public Array List < Wallet Table Data > create Wallet Table Data ( final Bitcoin Controller bitcoin Controller , String wallet Filename ) { Array List < Wallet Table Data > wallet Data = new Array List < Wallet Table Data > ( ) ; if ( wallet Filename == null ) { return wallet Data ; } Wallet Data per Wallet Model Data = null ; if ( per Wallet Model Data List != null ) { for ( Wallet Data loop Per Wallet Model Data : per Wallet Model Data List ) { if ( wallet Filename . equals ( loop Per Wallet Model Data . get Wallet Filename ( ) ) ) { per Wallet Model Data = loop Per Wallet Model Data ; break ; } } } return create Wallet Table Data ( bitcoin Controller , per Wallet Model Data ) ; }
public Array List < Wallet Table Data > create Wallet Table Data ( final Bitcoin Controller bitcoin Controller , String wallet Filename ) { Array List < Wallet Table Data > wallet Data = new Array List < Wallet Table Data > ( ) ; if ( wallet Filename == null ) { return wallet Data ; } Wallet Data per Wallet Model Data = null ; if ( per Wallet Model Data List != null ) { for ( Wallet Data loop Per Wallet Model Data : per Wallet Model Data List ) { if ( wallet Filename . equals ( loop Per Wallet Model Data . get Wallet Filename ( ) ) ) { per Wallet Model Data = loop Per Wallet Model Data ; break ; } } } return create Wallet Table Data ( bitcoin Controller , per Wallet Model Data ) ; }
public Array List < Wallet Table Data > create Wallet Table Data ( final Bitcoin Controller bitcoin Controller , String wallet Filename ) { Array List < Wallet Table Data > wallet Data = new Array List < Wallet Table Data > ( ) ; if ( wallet Filename == null ) { return wallet Data ; } Wallet Data per Wallet Model Data = null ; if ( per Wallet Model Data List != null ) { for ( Wallet Data loop Per Wallet Model Data : per Wallet Model Data List ) { if ( wallet Filename . equals ( loop Per Wallet Model Data . get Wallet Filename ( ) ) ) { per Wallet Model Data = loop Per Wallet Model Data ; break ; } } } return create Wallet Table Data ( bitcoin Controller , per Wallet Model Data ) ; }
@ Deprecated public static < T > T execute With Back Off ( Abstract Google Client Request < T > client , String error , Object ... error Args ) throws IO Exception , Interrupted Exception { return execute With Back Off ( client , String . format ( error , error Args ) ) ; }
public void delete Entities ( String name , String protocol , String realm ) throws AM Console Exception { if ( protocol . equals ( IDFF ) ) { delete IDFF Entity ( name , realm ) ; } else if ( protocol . equals ( WSFED ) ) { delete WS Fed Entity ( name , realm ) ; } else { delete SAM Lv 2 Entity ( name , realm ) ; } }
public Str Builder insert ( int index , Object obj ) { if ( obj == null ) { return insert ( index , null Text ) ; } return insert ( index , obj . to String ( ) ) ; }
public SIP Server Transaction create Server Transaction ( Message Channel encapsulated Message Channel ) { if ( unlimited Server Transaction Table Size ) { return new SIP Server Transaction ( this , encapsulated Message Channel ) ; } else { float threshold = ( ( float ) ( server Transaction Table . size ( ) - server Transaction Table Lowater Mark ) ) / ( ( float ) ( server Transaction Table Highwater Mark - server Transaction Table Lowater Mark ) ) ; boolean decision = Math . random ( ) > NUM - threshold ; if ( decision ) { return null ; } else { return new SIP Server Transaction ( this , encapsulated Message Channel ) ; } } }
public SIP Server Transaction create Server Transaction ( Message Channel encapsulated Message Channel ) { if ( unlimited Server Transaction Table Size ) { return new SIP Server Transaction ( this , encapsulated Message Channel ) ; } else { float threshold = ( ( float ) ( server Transaction Table . size ( ) - server Transaction Table Lowater Mark ) ) / ( ( float ) ( server Transaction Table Highwater Mark - server Transaction Table Lowater Mark ) ) ; boolean decision = Math . random ( ) > NUM - threshold ; if ( decision ) { return null ; } else { return new SIP Server Transaction ( this , encapsulated Message Channel ) ; } } }
public SIP Server Transaction create Server Transaction ( Message Channel encapsulated Message Channel ) { if ( unlimited Server Transaction Table Size ) { return new SIP Server Transaction ( this , encapsulated Message Channel ) ; } else { float threshold = ( ( float ) ( server Transaction Table . size ( ) - server Transaction Table Lowater Mark ) ) / ( ( float ) ( server Transaction Table Highwater Mark - server Transaction Table Lowater Mark ) ) ; boolean decision = Math . random ( ) > NUM - threshold ; if ( decision ) { return null ; } else { return new SIP Server Transaction ( this , encapsulated Message Channel ) ; } } }
public SIP Server Transaction create Server Transaction ( Message Channel encapsulated Message Channel ) { if ( unlimited Server Transaction Table Size ) { return new SIP Server Transaction ( this , encapsulated Message Channel ) ; } else { float threshold = ( ( float ) ( server Transaction Table . size ( ) - server Transaction Table Lowater Mark ) ) / ( ( float ) ( server Transaction Table Highwater Mark - server Transaction Table Lowater Mark ) ) ; boolean decision = Math . random ( ) > NUM - threshold ; if ( decision ) { return null ; } else { return new SIP Server Transaction ( this , encapsulated Message Channel ) ; } } }
public void add Lat Line ( double lat , double min Lon , double max Lon ) { String name = STRING + next Shape ; next Shape ++ ; b . append ( STRING + name + STRING ) ; double lon ; int steps = get Step Count ( lat , min Lon , lat , max Lon ) ; for ( lon = min Lon ; lon <= max Lon ; lon += ( max Lon - min Lon ) / steps ) { b . append ( STRING + lat + STRING + lon + STRING ) ; } b . append ( STRING + lat + STRING + max Lon + STRING ) ; lon -= ( max Lon - min Lon ) / steps ; for ( ; lon >= min Lon ; lon -= ( max Lon - min Lon ) / steps ) { b . append ( STRING + lat + STRING + lon + STRING ) ; } b . append ( STRING ) ; b . append ( STRING + name + STRING ) ; }
public void add ( T object ) { if ( m Event Delegate != null ) m Event Delegate . add Data ( object == null ? NUM : NUM ) ; if ( object != null ) { synchronized ( m Lock ) { m Objects . add ( object ) ; } } if ( m Notify On Change ) notify Data Set Changed ( ) ; }
public void add ( T object ) { if ( m Event Delegate != null ) m Event Delegate . add Data ( object == null ? NUM : NUM ) ; if ( object != null ) { synchronized ( m Lock ) { m Objects . add ( object ) ; } } if ( m Notify On Change ) notify Data Set Changed ( ) ; }
public double [ ] [ ] extract Main Set Jacobian ( final ODE State state ) { final double [ ] p = state . get Secondary State ( index ) ; final double [ ] [ ] d Yd Y 0 = new double [ jode . get Dimension ( ) ] [ jode . get Dimension ( ) ] ; int j = NUM ; for ( int i = NUM ; i < jode . get Dimension ( ) ; i ++ ) { System . arraycopy ( p , j , d Yd Y 0 [ i ] , NUM , jode . get Dimension ( ) ) ; j += jode . get Dimension ( ) ; } return d Yd Y 0 ; }
public double [ ] [ ] extract Main Set Jacobian ( final ODE State state ) { final double [ ] p = state . get Secondary State ( index ) ; final double [ ] [ ] d Yd Y 0 = new double [ jode . get Dimension ( ) ] [ jode . get Dimension ( ) ] ; int j = NUM ; for ( int i = NUM ; i < jode . get Dimension ( ) ; i ++ ) { System . arraycopy ( p , j , d Yd Y 0 [ i ] , NUM , jode . get Dimension ( ) ) ; j += jode . get Dimension ( ) ; } return d Yd Y 0 ; }
public void load From File ( String s File Name ) throws File Not Found Exception , IO Exception { File Reader fr File = new File Reader ( s File Name ) ; String s Text = STRING ; int c = fr File . read ( ) ; while ( c != - NUM ) { s Text += c ; c = fr File . read ( ) ; } add Text ( s Text ) ; fr File . close ( ) ; }
public void load From File ( String s File Name ) throws File Not Found Exception , IO Exception { File Reader fr File = new File Reader ( s File Name ) ; String s Text = STRING ; int c = fr File . read ( ) ; while ( c != - NUM ) { s Text += c ; c = fr File . read ( ) ; } add Text ( s Text ) ; fr File . close ( ) ; }
public LDIF Change Record Writer ( final List < String > ldif Lines ) { super ( ldif Lines ) ; }
public LDIF Change Record Writer ( final List < String > ldif Lines ) { super ( ldif Lines ) ; }
private static Reserve Response check Reserve Response ( Reserve Response reserve Response ) throws Rpc Exception { logger . info ( STRING , reserve Response ) ; switch ( reserve Response . get Result ( ) ) { case OK : break ; case STALE GENERATION : logger . warn ( STRING , reserve Response . get Error ( ) ) ; throw new Stale Generation Exception ( reserve Response . get Error ( ) ) ; case SYSTEM ERROR : logger . warn ( STRING , reserve Response . get Error ( ) ) ; throw new System Error Exception ( reserve Response . get Error ( ) ) ; default : throw new Rpc Exception ( String . format ( STRING , reserve Response . get Result ( ) ) ) ; } return reserve Response ; }
public static boolean open Url Prompt ( Component parent , String url , boolean force Prompt ) { if ( url == null ) { return BOOL ; } List < String > list = new Array List < > ( ) ; list . add ( url ) ; return open Urls Prompt ( parent , list , force Prompt ) ; }
public static boolean open Url Prompt ( Component parent , String url , boolean force Prompt ) { if ( url == null ) { return BOOL ; } List < String > list = new Array List < > ( ) ; list . add ( url ) ; return open Urls Prompt ( parent , list , force Prompt ) ; }
public void log Fine ( String message ) { logger . fine ( log Prefix + message ) ; }
public void log Fine ( String message ) { logger . fine ( log Prefix + message ) ; }
public void log Fine ( String message ) { logger . fine ( log Prefix + message ) ; }
private static char [ ] subscript For Digit ( int digit ) { return Character . to Chars ( NUM + digit ) ; }
public static String delete From Cart ( Http Servlet Request request , Http Servlet Response response ) { Shopping Cart cart = get Cart Object ( request ) ; Local Dispatcher dispatcher = ( Local Dispatcher ) request . get Attribute ( STRING ) ; Shopping Cart Helper cart Helper = new Shopping Cart Helper ( null , dispatcher , cart ) ; String control Directive ; Map < String , Object > result ; Map < String , Object > param Map = Util Http . get Parameter Map ( request ) ; result = cart Helper . delete From Cart ( param Map ) ; control Directive = process Result ( result , request ) ; if ( control Directive . equals ( ERROR ) ) { return STRING ; } else { return STRING ; } }
public Header Section ( Dex File file ) { super ( null , file , NUM ) ; Header Item item = new Header Item ( ) ; item . set Index ( NUM ) ; this . list = Collections . singleton List ( item ) ; }
public synchronized void rotate Abs ( final Point 2 D p , double theta ) { double zx = p . get X ( ) , zy = p . get Y ( ) ; damage Report ( ) ; m transform . translate ( zx , zy ) ; m transform . rotate ( theta ) ; m transform . translate ( - zx , - zy ) ; try { m itransform = m transform . create Inverse ( ) ; } catch ( Exception e ) { } }
public synchronized void rotate Abs ( final Point 2 D p , double theta ) { double zx = p . get X ( ) , zy = p . get Y ( ) ; damage Report ( ) ; m transform . translate ( zx , zy ) ; m transform . rotate ( theta ) ; m transform . translate ( - zx , - zy ) ; try { m itransform = m transform . create Inverse ( ) ; } catch ( Exception e ) { } }
public synchronized void rotate Abs ( final Point 2 D p , double theta ) { double zx = p . get X ( ) , zy = p . get Y ( ) ; damage Report ( ) ; m transform . translate ( zx , zy ) ; m transform . rotate ( theta ) ; m transform . translate ( - zx , - zy ) ; try { m itransform = m transform . create Inverse ( ) ; } catch ( Exception e ) { } }
public Buffered Header ( final Char Array Buffer buffer ) throws Parse Exception { super ( ) ; if ( buffer == null ) { throw new Illegal Argument Exception ( STRING ) ; } int colon = buffer . index Of ( STRING ) ; if ( colon == - NUM ) { throw new Parse Exception ( STRING + buffer . to String ( ) ) ; } String s = buffer . substring Trimmed ( NUM , colon ) ; if ( s . length ( ) == NUM ) { throw new Parse Exception ( STRING + buffer . to String ( ) ) ; } this . buffer = buffer ; this . name = s ; this . value Pos = colon + NUM ; }
public Buffered Header ( final Char Array Buffer buffer ) throws Parse Exception { super ( ) ; if ( buffer == null ) { throw new Illegal Argument Exception ( STRING ) ; } int colon = buffer . index Of ( STRING ) ; if ( colon == - NUM ) { throw new Parse Exception ( STRING + buffer . to String ( ) ) ; } String s = buffer . substring Trimmed ( NUM , colon ) ; if ( s . length ( ) == NUM ) { throw new Parse Exception ( STRING + buffer . to String ( ) ) ; } this . buffer = buffer ; this . name = s ; this . value Pos = colon + NUM ; }
public static boolean is Directly Getting Powered ( World world , Coord 4 D coord ) { for ( Forge Direction side : Forge Direction . VALID DIRECTIONS ) { Coord 4 D side Coord = coord . get From Side ( side ) ; if ( side Coord . exists ( world ) ) { if ( world . is Block Providing Power To ( coord . x Coord , coord . y Coord , coord . z Coord , side . ordinal ( ) ) > NUM ) { return BOOL ; } } } return BOOL ; }
public static boolean is Directly Getting Powered ( World world , Coord 4 D coord ) { for ( Forge Direction side : Forge Direction . VALID DIRECTIONS ) { Coord 4 D side Coord = coord . get From Side ( side ) ; if ( side Coord . exists ( world ) ) { if ( world . is Block Providing Power To ( coord . x Coord , coord . y Coord , coord . z Coord , side . ordinal ( ) ) > NUM ) { return BOOL ; } } } return BOOL ; }
public static boolean is Directly Getting Powered ( World world , Coord 4 D coord ) { for ( Forge Direction side : Forge Direction . VALID DIRECTIONS ) { Coord 4 D side Coord = coord . get From Side ( side ) ; if ( side Coord . exists ( world ) ) { if ( world . is Block Providing Power To ( coord . x Coord , coord . y Coord , coord . z Coord , side . ordinal ( ) ) > NUM ) { return BOOL ; } } } return BOOL ; }
public Distributed Log Multi Stream Writer build ( ) { Preconditions . check Argument ( ( null != streams && ! streams . is Empty ( ) ) , STRING ) ; Preconditions . check Not Null ( client , STRING ) ; Preconditions . check Not Null ( codec , STRING ) ; Preconditions . check Argument ( first Speculative Timeout Ms > NUM && first Speculative Timeout Ms <= max Speculative Timeout Ms && speculative Backoff Multiplier > NUM && max Speculative Timeout Ms < request Timeout Ms , STRING ) ; return new Distributed Log Multi Stream Writer ( streams , client , Math . min ( buffer Size , MAX LOGRECORDSET SIZE ) , flush Interval Micros , request Timeout Ms , first Speculative Timeout Ms , max Speculative Timeout Ms , speculative Backoff Multiplier , codec , ticker , executor Service ) ; }
public void dequeue ( Anth URL url ) { ready Urls . remove ( url ) ; if ( value Function . get Necessities ( Host Value Update Necessity . ON QUEUE CHANGE ) ) { score Update Needed = BOOL ; } }
private String ant Project To Artifact Name ( String orig Module ) { String module = orig Module ; if ( ! orig Module . starts With ( STRING ) ) { module = STRING + module ; } return module ; }
private String ant Project To Artifact Name ( String orig Module ) { String module = orig Module ; if ( ! orig Module . starts With ( STRING ) ) { module = STRING + module ; } return module ; }
public void column Removed ( Table Column Model Event e ) { Lime Table Column ltc ; Table Column Model tcm = table . get Column Model ( ) ; for ( int i = NUM ; i < tcm . get Column Count ( ) ; i ++ ) { ltc = ( Lime Table Column ) tcm . get Column ( i ) ; set Order ( ltc , i ) ; } Lime Table Column removed Column = table . get Last Removed Column ( ) ; ltc = removed Column ; set Visibility ( ltc , BOOL ) ; int order = get Order ( ltc ) ; for ( Iterator < Lime Table Column > i = table . get Hidden Columns ( ) ; i . has Next ( ) ; ) { ltc = i . next ( ) ; int current = get Order ( ltc ) ; if ( current > order ) set Order ( ltc , current - NUM ) ; } if ( listener != null ) listener . column Removed ( removed Column , table ) ; save ( ) ; }
public void column Removed ( Table Column Model Event e ) { Lime Table Column ltc ; Table Column Model tcm = table . get Column Model ( ) ; for ( int i = NUM ; i < tcm . get Column Count ( ) ; i ++ ) { ltc = ( Lime Table Column ) tcm . get Column ( i ) ; set Order ( ltc , i ) ; } Lime Table Column removed Column = table . get Last Removed Column ( ) ; ltc = removed Column ; set Visibility ( ltc , BOOL ) ; int order = get Order ( ltc ) ; for ( Iterator < Lime Table Column > i = table . get Hidden Columns ( ) ; i . has Next ( ) ; ) { ltc = i . next ( ) ; int current = get Order ( ltc ) ; if ( current > order ) set Order ( ltc , current - NUM ) ; } if ( listener != null ) listener . column Removed ( removed Column , table ) ; save ( ) ; }
public void column Removed ( Table Column Model Event e ) { Lime Table Column ltc ; Table Column Model tcm = table . get Column Model ( ) ; for ( int i = NUM ; i < tcm . get Column Count ( ) ; i ++ ) { ltc = ( Lime Table Column ) tcm . get Column ( i ) ; set Order ( ltc , i ) ; } Lime Table Column removed Column = table . get Last Removed Column ( ) ; ltc = removed Column ; set Visibility ( ltc , BOOL ) ; int order = get Order ( ltc ) ; for ( Iterator < Lime Table Column > i = table . get Hidden Columns ( ) ; i . has Next ( ) ; ) { ltc = i . next ( ) ; int current = get Order ( ltc ) ; if ( current > order ) set Order ( ltc , current - NUM ) ; } if ( listener != null ) listener . column Removed ( removed Column , table ) ; save ( ) ; }
public void column Removed ( Table Column Model Event e ) { Lime Table Column ltc ; Table Column Model tcm = table . get Column Model ( ) ; for ( int i = NUM ; i < tcm . get Column Count ( ) ; i ++ ) { ltc = ( Lime Table Column ) tcm . get Column ( i ) ; set Order ( ltc , i ) ; } Lime Table Column removed Column = table . get Last Removed Column ( ) ; ltc = removed Column ; set Visibility ( ltc , BOOL ) ; int order = get Order ( ltc ) ; for ( Iterator < Lime Table Column > i = table . get Hidden Columns ( ) ; i . has Next ( ) ; ) { ltc = i . next ( ) ; int current = get Order ( ltc ) ; if ( current > order ) set Order ( ltc , current - NUM ) ; } if ( listener != null ) listener . column Removed ( removed Column , table ) ; save ( ) ; }
public void column Removed ( Table Column Model Event e ) { Lime Table Column ltc ; Table Column Model tcm = table . get Column Model ( ) ; for ( int i = NUM ; i < tcm . get Column Count ( ) ; i ++ ) { ltc = ( Lime Table Column ) tcm . get Column ( i ) ; set Order ( ltc , i ) ; } Lime Table Column removed Column = table . get Last Removed Column ( ) ; ltc = removed Column ; set Visibility ( ltc , BOOL ) ; int order = get Order ( ltc ) ; for ( Iterator < Lime Table Column > i = table . get Hidden Columns ( ) ; i . has Next ( ) ; ) { ltc = i . next ( ) ; int current = get Order ( ltc ) ; if ( current > order ) set Order ( ltc , current - NUM ) ; } if ( listener != null ) listener . column Removed ( removed Column , table ) ; save ( ) ; }
public void column Removed ( Table Column Model Event e ) { Lime Table Column ltc ; Table Column Model tcm = table . get Column Model ( ) ; for ( int i = NUM ; i < tcm . get Column Count ( ) ; i ++ ) { ltc = ( Lime Table Column ) tcm . get Column ( i ) ; set Order ( ltc , i ) ; } Lime Table Column removed Column = table . get Last Removed Column ( ) ; ltc = removed Column ; set Visibility ( ltc , BOOL ) ; int order = get Order ( ltc ) ; for ( Iterator < Lime Table Column > i = table . get Hidden Columns ( ) ; i . has Next ( ) ; ) { ltc = i . next ( ) ; int current = get Order ( ltc ) ; if ( current > order ) set Order ( ltc , current - NUM ) ; } if ( listener != null ) listener . column Removed ( removed Column , table ) ; save ( ) ; }
public void column Removed ( Table Column Model Event e ) { Lime Table Column ltc ; Table Column Model tcm = table . get Column Model ( ) ; for ( int i = NUM ; i < tcm . get Column Count ( ) ; i ++ ) { ltc = ( Lime Table Column ) tcm . get Column ( i ) ; set Order ( ltc , i ) ; } Lime Table Column removed Column = table . get Last Removed Column ( ) ; ltc = removed Column ; set Visibility ( ltc , BOOL ) ; int order = get Order ( ltc ) ; for ( Iterator < Lime Table Column > i = table . get Hidden Columns ( ) ; i . has Next ( ) ; ) { ltc = i . next ( ) ; int current = get Order ( ltc ) ; if ( current > order ) set Order ( ltc , current - NUM ) ; } if ( listener != null ) listener . column Removed ( removed Column , table ) ; save ( ) ; }
public void column Removed ( Table Column Model Event e ) { Lime Table Column ltc ; Table Column Model tcm = table . get Column Model ( ) ; for ( int i = NUM ; i < tcm . get Column Count ( ) ; i ++ ) { ltc = ( Lime Table Column ) tcm . get Column ( i ) ; set Order ( ltc , i ) ; } Lime Table Column removed Column = table . get Last Removed Column ( ) ; ltc = removed Column ; set Visibility ( ltc , BOOL ) ; int order = get Order ( ltc ) ; for ( Iterator < Lime Table Column > i = table . get Hidden Columns ( ) ; i . has Next ( ) ; ) { ltc = i . next ( ) ; int current = get Order ( ltc ) ; if ( current > order ) set Order ( ltc , current - NUM ) ; } if ( listener != null ) listener . column Removed ( removed Column , table ) ; save ( ) ; }
public void column Removed ( Table Column Model Event e ) { Lime Table Column ltc ; Table Column Model tcm = table . get Column Model ( ) ; for ( int i = NUM ; i < tcm . get Column Count ( ) ; i ++ ) { ltc = ( Lime Table Column ) tcm . get Column ( i ) ; set Order ( ltc , i ) ; } Lime Table Column removed Column = table . get Last Removed Column ( ) ; ltc = removed Column ; set Visibility ( ltc , BOOL ) ; int order = get Order ( ltc ) ; for ( Iterator < Lime Table Column > i = table . get Hidden Columns ( ) ; i . has Next ( ) ; ) { ltc = i . next ( ) ; int current = get Order ( ltc ) ; if ( current > order ) set Order ( ltc , current - NUM ) ; } if ( listener != null ) listener . column Removed ( removed Column , table ) ; save ( ) ; }
public void add Notify ( ) { super . add Notify ( ) ; if ( text Area != null ) { l . install ( text Area ) ; } update Cell Widths ( ) ; update Cell Heights ( ) ; }
public void add Notify ( ) { super . add Notify ( ) ; if ( text Area != null ) { l . install ( text Area ) ; } update Cell Widths ( ) ; update Cell Heights ( ) ; }
public void add Notify ( ) { super . add Notify ( ) ; if ( text Area != null ) { l . install ( text Area ) ; } update Cell Widths ( ) ; update Cell Heights ( ) ; }
public void add Notify ( ) { super . add Notify ( ) ; if ( text Area != null ) { l . install ( text Area ) ; } update Cell Widths ( ) ; update Cell Heights ( ) ; }
public void add Notify ( ) { super . add Notify ( ) ; if ( text Area != null ) { l . install ( text Area ) ; } update Cell Widths ( ) ; update Cell Heights ( ) ; }
public void add Notify ( ) { super . add Notify ( ) ; if ( text Area != null ) { l . install ( text Area ) ; } update Cell Widths ( ) ; update Cell Heights ( ) ; }
JCERSA Private Crt Key ( RSA Private Crt Key Spec spec ) { this . modulus = spec . get Modulus ( ) ; this . public Exponent = spec . get Public Exponent ( ) ; this . private Exponent = spec . get Private Exponent ( ) ; this . prime P = spec . get Prime P ( ) ; this . prime Q = spec . get Prime Q ( ) ; this . prime Exponent P = spec . get Prime Exponent P ( ) ; this . prime Exponent Q = spec . get Prime Exponent Q ( ) ; this . crt Coefficient = spec . get Crt Coefficient ( ) ; }
abstract void to XML ( String Builder xml , int level ) ;
public void action Performed ( Action Event e ) { Control Panel Property Editor editor = new Control Panel Property Editor ( this ) ; editor . set Visible ( BOOL ) ; }
static String to C ( String identifier ) { return identifier . replace ( STRING , STRING ) ; }
public long sigignore ( ) { return Long . parse Long ( fields [ NUM ] ) ; }
public long sigignore ( ) { return Long . parse Long ( fields [ NUM ] ) ; }
public long sigignore ( ) { return Long . parse Long ( fields [ NUM ] ) ; }
public long sigignore ( ) { return Long . parse Long ( fields [ NUM ] ) ; }
public Pac Proxy Selector ( String pac Url ) { if ( pac Url == null ) { throw new Null Pointer Exception ( ) ; } this . pac Url = pac Url ; }
@ Override public Mem Buffer Holder < Sys Mem Allocator > create Buffer ( long size , boolean autoreclaim ) { Mem Buffer Holder < Sys Mem Allocator > ret = null ; Byte Buffer bb = null ; if ( current Memory . get ( ) + size > max Store Capacity ) { if ( m activegc ) { force GC ( ) ; } } if ( current Memory . get ( ) + size <= max Store Capacity ) { bb = Byte Buffer . allocate Direct ( ( int ) size ) ; } if ( null != bb ) { ret = new Mem Buffer Holder < Sys Mem Allocator > ( this , bb ) ; ret . set Collector ( m bufcollector ) ; if ( autoreclaim ) { m bufcollector . register ( ret ) ; } current Memory . get And Add ( size ) ; } return ret ; }
public void inherit ( ) { add Class Path ( System . get Property ( STRING ) ) ; }
public void inherit ( ) { add Class Path ( System . get Property ( STRING ) ) ; }
public Composer alpha ( long anim Duration , float alpha , Ease ease ) { Anim Parameter before Param = m Tween Parameter List . size ( ) > NUM ? m Tween Parameter List . get ( m Tween Parameter List . size ( ) - NUM ) : m Initial Param ; m Tween Parameter List . add ( new Tween Parameter ( before Param . x , before Param . y , Util . convert Alpha Float To Int ( alpha ) , before Param . scale X , before Param . scale Y , before Param . rotation , anim Duration , ease ) ) ; return this ; }
public Composer alpha ( long anim Duration , float alpha , Ease ease ) { Anim Parameter before Param = m Tween Parameter List . size ( ) > NUM ? m Tween Parameter List . get ( m Tween Parameter List . size ( ) - NUM ) : m Initial Param ; m Tween Parameter List . add ( new Tween Parameter ( before Param . x , before Param . y , Util . convert Alpha Float To Int ( alpha ) , before Param . scale X , before Param . scale Y , before Param . rotation , anim Duration , ease ) ) ; return this ; }
public void write String No Compression ( String str ) throws IO Exception { if ( str == null ) { write Int ( NUM ) ; } else { write Int ( str . length ( ) ) ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) outs . write ( ( byte ) str . char At ( i ) ) ; position += str . length ( ) ; } }
public void write String No Compression ( String str ) throws IO Exception { if ( str == null ) { write Int ( NUM ) ; } else { write Int ( str . length ( ) ) ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) outs . write ( ( byte ) str . char At ( i ) ) ; position += str . length ( ) ; } }
public < R > Future W < R > flat Map Cf ( final Function < ? super T , ? extends Completion Stage < ? extends R > > mapper ) { return Future W . < R > of ( future . < R > then Compose ( null ) ) ; }
public < R > Future W < R > flat Map Cf ( final Function < ? super T , ? extends Completion Stage < ? extends R > > mapper ) { return Future W . < R > of ( future . < R > then Compose ( null ) ) ; }
public static String capitalize First Only ( String s ) { if ( s == null ) return null ; if ( s . length ( ) == NUM ) return s ; String Buffer sbuf = new String Buffer ( ) ; char c = s . char At ( NUM ) ; sbuf . append ( Character . to Upper Case ( c ) ) ; boolean space = Character . is Whitespace ( c ) ; for ( int i = NUM ; i < s . length ( ) ; ++ i ) { c = s . char At ( i ) ; if ( Character . is Whitespace ( c ) ) { space = BOOL ; } else if ( space ) { c = Character . to Upper Case ( c ) ; space = BOOL ; } else { c = Character . to Lower Case ( c ) ; } sbuf . append ( c ) ; } return sbuf . to String ( ) ; }
public static Resource decode Context ( String encoded Value , Value Factory value Factory ) { if ( encoded Value == null ) { return null ; } else if ( NULL PARAM VALUE . equals ( encoded Value ) ) { return null ; } else { return decode Resource ( encoded Value , value Factory ) ; } }
@ Suppress Warnings ( STRING ) public final void select All ( ) { for ( int i = NUM ; i < realm Results . size ( ) ; i ++ ) selected Positions . add ( i ) ; notify Data Set Changed ( ) ; }
private Map < String , String > build Short Name To Full Name Map ( Set < String > class Set ) { Map < String , String > result = new Hash Map < String , String > ( ) ; for ( String class Name : class Set ) { String short Class Name = get Short Class Name ( class Name ) ; result . put ( short Class Name , class Name ) ; } return result ; }
public List to List ( ) { Object [ ] copied Elements = new Object [ num Elements ] ; System . arraycopy ( elements , NUM , copied Elements , NUM , num Elements ) ; return Arrays . as List ( copied Elements ) ; }
public List to List ( ) { Object [ ] copied Elements = new Object [ num Elements ] ; System . arraycopy ( elements , NUM , copied Elements , NUM , num Elements ) ; return Arrays . as List ( copied Elements ) ; }
public static long calculate Chunked Content Length ( long original Length , long chunk Size ) { if ( original Length <= NUM ) { throw new Illegal Argument Exception ( STRING ) ; } long max Size Chunks = original Length / chunk Size ; long remaining Bytes = original Length % chunk Size ; return max Size Chunks * calculate Chunk Header Length ( chunk Size ) + ( remaining Bytes > NUM ? calculate Chunk Header Length ( remaining Bytes ) : NUM ) + calculate Chunk Header Length ( NUM ) ; }
public static long calculate Chunked Content Length ( long original Length , long chunk Size ) { if ( original Length <= NUM ) { throw new Illegal Argument Exception ( STRING ) ; } long max Size Chunks = original Length / chunk Size ; long remaining Bytes = original Length % chunk Size ; return max Size Chunks * calculate Chunk Header Length ( chunk Size ) + ( remaining Bytes > NUM ? calculate Chunk Header Length ( remaining Bytes ) : NUM ) + calculate Chunk Header Length ( NUM ) ; }
private static URI url ( String path ) { return URI . create ( STRING + path ) ; }
private static URI url ( String path ) { return URI . create ( STRING + path ) ; }
public static void copy ( File from File , File to File , int buf Size ) throws IO Exception { File Input Stream fis = new File Input Stream ( from File ) ; File Output Stream fos = new File Output Stream ( to File ) ; if ( buf Size <= NUM ) { buf Size = NUM ; } byte [ ] bytes = new byte [ buf Size ] ; int num Read ; while ( ( num Read = fis . read ( bytes ) ) > NUM ) { fos . write ( bytes , NUM , num Read ) ; } fis . close ( ) ; fos . close ( ) ; }
void verify Exception Captured ( Class < ? extends Throwable > expected Exception Class ) { assert True ( STRING , exception Event Capture . has Captured ( ) ) ; Throwable caught Ex = exception Event Capture . get Value ( ) ; assert Equals ( expected Exception Class , caught Ex . get Class ( ) ) ; exception Event Capture . reset ( ) ; }
void verify Exception Captured ( Class < ? extends Throwable > expected Exception Class ) { assert True ( STRING , exception Event Capture . has Captured ( ) ) ; Throwable caught Ex = exception Event Capture . get Value ( ) ; assert Equals ( expected Exception Class , caught Ex . get Class ( ) ) ; exception Event Capture . reset ( ) ; }
void verify Exception Captured ( Class < ? extends Throwable > expected Exception Class ) { assert True ( STRING , exception Event Capture . has Captured ( ) ) ; Throwable caught Ex = exception Event Capture . get Value ( ) ; assert Equals ( expected Exception Class , caught Ex . get Class ( ) ) ; exception Event Capture . reset ( ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public void notify Target Activity Changed ( Target Activity target Activity ) { int in = target Activities . index Of ( target Activity ) ; if ( in != - NUM ) { notify Item Changed ( in + NUM ) ; } }
private boolean need Index Consistency ( ) { return index != null && index . need Consistency ( ) ; }
public static void delete Exisiting Rows ( String table , String filter , Connection connection ) { table = table . replace ( STRING , STRING ) ; filter = filter . replace ( STRING , STRING ) ; String Builder delete Rows Query = new String Builder ( ) ; delete Rows Query . append ( STRING ) ; delete Rows Query . append ( table ) ; delete Rows Query . append ( STRING ) ; delete Rows Query . append ( filter ) ; delete Rows Query . append ( STRING ) ; LOG . info ( STRING ) ; LOG . info ( delete Rows Query ) ; execute Statement If Exists ( delete Rows Query . to String ( ) , connection ) ; }
void rollback ( List < Type > saved undet ) { Assert . check ( saved undet != null && saved undet . length ( ) == undetvars . length ( ) ) ; for ( Type t : undetvars ) { Undet Var uv = ( Undet Var ) t ; Undet Var uv saved = ( Undet Var ) saved undet . head ; for ( Inference Bound ib : Inference Bound . values ( ) ) { uv . set Bounds ( ib , uv saved . get Bounds ( ib ) ) ; } uv . inst = uv saved . inst ; saved undet = saved undet . tail ; } }
void rollback ( List < Type > saved undet ) { Assert . check ( saved undet != null && saved undet . length ( ) == undetvars . length ( ) ) ; for ( Type t : undetvars ) { Undet Var uv = ( Undet Var ) t ; Undet Var uv saved = ( Undet Var ) saved undet . head ; for ( Inference Bound ib : Inference Bound . values ( ) ) { uv . set Bounds ( ib , uv saved . get Bounds ( ib ) ) ; } uv . inst = uv saved . inst ; saved undet = saved undet . tail ; } }
private Method find Any Method Match ( Class < ? > clz , String name , Class < ? > [ ] classes ) { try { Method m = clz . get Declared Method ( name , classes ) ; if ( m != null ) { return m ; } } catch ( No Such Method Exception ignored ) { } Class < ? > sup = clz . get Superclass ( ) ; if ( sup != null ) { Method m = find Any Method Match ( sup , name , classes ) ; if ( m != null ) { return m ; } } Class < ? > [ ] itfs = clz . get Interfaces ( ) ; if ( itfs != null && itfs . length > NUM ) { for ( Class < ? > itf : itfs ) { Method m = find Any Method Match ( itf , name , classes ) ; if ( m != null ) { return m ; } } } return null ; }
private Method find Any Method Match ( Class < ? > clz , String name , Class < ? > [ ] classes ) { try { Method m = clz . get Declared Method ( name , classes ) ; if ( m != null ) { return m ; } } catch ( No Such Method Exception ignored ) { } Class < ? > sup = clz . get Superclass ( ) ; if ( sup != null ) { Method m = find Any Method Match ( sup , name , classes ) ; if ( m != null ) { return m ; } } Class < ? > [ ] itfs = clz . get Interfaces ( ) ; if ( itfs != null && itfs . length > NUM ) { for ( Class < ? > itf : itfs ) { Method m = find Any Method Match ( itf , name , classes ) ; if ( m != null ) { return m ; } } } return null ; }
public void stop ( ) { is Alive = BOOL ; stats Snap Shot . stop ( ) ; holding Buffer . clear ( ) ; IO Utils . close Quietly ( this ) ; }
public void perform Ranking Update ( Map < Integer , Integer > legion Ranking ) { log . info ( STRING ) ; long start Time = System . current Time Millis ( ) ; Iterator < Legion > legions Iterator = all Cached Legions . iterator ( ) ; int legions Updated = NUM ; this . legion Ranking = legion Ranking ; while ( legions Iterator . has Next ( ) ) { Legion legion = legions Iterator . next ( ) ; if ( legion Ranking . contains Key ( legion . get Legion Id ( ) ) ) { legion . set Legion Rank ( legion Ranking . get ( legion . get Legion Id ( ) ) ) ; Packet Send Utility . broadcast Packet To Legion ( legion , new SM LEGION EDIT ( NUM , legion ) ) ; } legions Updated ++ ; } long work Time = System . current Time Millis ( ) - start Time ; log . info ( STRING + work Time + STRING + legions Updated ) ; }
private static void remove Table ( Connection conn , String name ) throws SQL Exception { name = name . replace ( STRING , STRING ) ; Statement stat = conn . create Statement ( ) ; stat . execute ( STRING + name ) ; DB Util . commit EL ( conn ) ; }
private void update Model ( Image image To Update ) { Log . v ( TAG , STRING + image To Update ) ; for ( Image image : m Images List ) { if ( image . equals ( image To Update ) ) { Log . v ( TAG , STRING + image To Update ) ; image . set Visibility ( image To Update . is Visible ( ) ) ; break ; } } int index = m Images List . index Of ( image To Update ) ; Log . v ( TAG , STRING + index ) ; m Adapter . notify Item Changed ( index ) ; Rect dirty = new Rect ( ) ; View view At Position = m Layout Manager . find View By Position ( index ) ; view At Position . get Drawing Rect ( dirty ) ; m Recycler View . invalidate ( dirty ) ; }
@ Init Binder public void init Binder ( Web Data Binder web Data Binder ) { Simple Date Format date Format = new Simple Date Format ( DATE FORMAT ) ; date Format . set Lenient ( BOOL ) ; web Data Binder . register Custom Editor ( Date . class , new Custom Date Editor ( date Format , BOOL ) ) ; }
public static void cleanup Tenant ( ) throws Exception { Cas Idm Client idm Client = new Cas Idm Client ( get Idm Host Name ( ) ) ; int i = NUM ; String tenant Name = Server Config . get Tenant ( i ) ; while ( tenant Name != null ) { Idm Data Remover . add Tenant ( tenant Name ) ; i ++ ; tenant Name = Server Config . get Tenant ( i ) ; } try { Idm Data Remover . remove Data ( idm Client ) ; } catch ( Exception e ) { logger . debug ( STRING + e . to String ( ) ) ; } }
public static C Trace Options Dialog show ( final J Frame parent ) { final C Trace Options Dialog dlg = new C Trace Options Dialog ( parent ) ; Gui Helper . center Child To Parent ( parent , dlg , BOOL ) ; dlg . set Visible ( BOOL ) ; return dlg ; }
private static String [ ] make Column Names ( Column Type types [ ] ) { String [ ] header = new String [ types . length ] ; for ( int i = NUM ; i < types . length ; i ++ ) { header [ i ] = STRING + i ; } return header ; }
private static String [ ] make Column Names ( Column Type types [ ] ) { String [ ] header = new String [ types . length ] ; for ( int i = NUM ; i < types . length ; i ++ ) { header [ i ] = STRING + i ; } return header ; }
private static String [ ] make Column Names ( Column Type types [ ] ) { String [ ] header = new String [ types . length ] ; for ( int i = NUM ; i < types . length ; i ++ ) { header [ i ] = STRING + i ; } return header ; }
private static String [ ] make Column Names ( Column Type types [ ] ) { String [ ] header = new String [ types . length ] ; for ( int i = NUM ; i < types . length ; i ++ ) { header [ i ] = STRING + i ; } return header ; }
public void caret Update ( Caret Event e ) { timer . restart ( ) ; }
private Bitmap create Photo Thumbnail ( final String a Image Url ) { Bitmap bitmap Ret Value = null ; if ( null != a Image Url ) { Uri image Uri = Uri . from File ( new File ( a Image Url ) ) ; int rotation Angle = Image Utils . get Rotation Angle For Bitmap ( Vector Medias Picker Activity . this , image Uri ) ; try { final String filename = image Uri . get Path ( ) ; File Input Stream image Stream = new File Input Stream ( new File ( filename ) ) ; bitmap Ret Value = create Photo Thumbnail ( image Stream , rotation Angle ) ; image Stream . close ( ) ; System . gc ( ) ; } catch ( Out Of Memory Error e ) { Log . e ( LOG TAG , STRING ) ; } catch ( Exception e ) { Log . e ( LOG TAG , STRING + e . get Message ( ) ) ; } } return bitmap Ret Value ; }
private Bitmap create Photo Thumbnail ( final String a Image Url ) { Bitmap bitmap Ret Value = null ; if ( null != a Image Url ) { Uri image Uri = Uri . from File ( new File ( a Image Url ) ) ; int rotation Angle = Image Utils . get Rotation Angle For Bitmap ( Vector Medias Picker Activity . this , image Uri ) ; try { final String filename = image Uri . get Path ( ) ; File Input Stream image Stream = new File Input Stream ( new File ( filename ) ) ; bitmap Ret Value = create Photo Thumbnail ( image Stream , rotation Angle ) ; image Stream . close ( ) ; System . gc ( ) ; } catch ( Out Of Memory Error e ) { Log . e ( LOG TAG , STRING ) ; } catch ( Exception e ) { Log . e ( LOG TAG , STRING + e . get Message ( ) ) ; } } return bitmap Ret Value ; }
private Bitmap create Photo Thumbnail ( final String a Image Url ) { Bitmap bitmap Ret Value = null ; if ( null != a Image Url ) { Uri image Uri = Uri . from File ( new File ( a Image Url ) ) ; int rotation Angle = Image Utils . get Rotation Angle For Bitmap ( Vector Medias Picker Activity . this , image Uri ) ; try { final String filename = image Uri . get Path ( ) ; File Input Stream image Stream = new File Input Stream ( new File ( filename ) ) ; bitmap Ret Value = create Photo Thumbnail ( image Stream , rotation Angle ) ; image Stream . close ( ) ; System . gc ( ) ; } catch ( Out Of Memory Error e ) { Log . e ( LOG TAG , STRING ) ; } catch ( Exception e ) { Log . e ( LOG TAG , STRING + e . get Message ( ) ) ; } } return bitmap Ret Value ; }
private Bitmap create Photo Thumbnail ( final String a Image Url ) { Bitmap bitmap Ret Value = null ; if ( null != a Image Url ) { Uri image Uri = Uri . from File ( new File ( a Image Url ) ) ; int rotation Angle = Image Utils . get Rotation Angle For Bitmap ( Vector Medias Picker Activity . this , image Uri ) ; try { final String filename = image Uri . get Path ( ) ; File Input Stream image Stream = new File Input Stream ( new File ( filename ) ) ; bitmap Ret Value = create Photo Thumbnail ( image Stream , rotation Angle ) ; image Stream . close ( ) ; System . gc ( ) ; } catch ( Out Of Memory Error e ) { Log . e ( LOG TAG , STRING ) ; } catch ( Exception e ) { Log . e ( LOG TAG , STRING + e . get Message ( ) ) ; } } return bitmap Ret Value ; }
public static String try Get Canonical Path Else Get Absolute Path ( final File file ) { try { return file . get Canonical Path ( ) ; } catch ( IO Exception e ) { return file . get Absolute Path ( ) ; } }
public static String try Get Canonical Path Else Get Absolute Path ( final File file ) { try { return file . get Canonical Path ( ) ; } catch ( IO Exception e ) { return file . get Absolute Path ( ) ; } }
public boolean is Empty ( ) { return fields . size ( ) <= NUM ; }
public boolean is Empty ( ) { return fields . size ( ) <= NUM ; }
public boolean is Empty ( ) { return fields . size ( ) <= NUM ; }
public boolean is Empty ( ) { return fields . size ( ) <= NUM ; }
public boolean is Empty ( ) { return fields . size ( ) <= NUM ; }
@ Override public void handle Key ( int virtual Key Code , int transition State , char key Char ) { switch Control Keys ( virtual Key Code , transition State ) ; input Buffer . add ( new Global Key Event ( this , virtual Key Code , transition State , key Char , menu Pressed , shift Pressed , control Pressed , extended Key ) ) ; }
@ Override public void handle Key ( int virtual Key Code , int transition State , char key Char ) { switch Control Keys ( virtual Key Code , transition State ) ; input Buffer . add ( new Global Key Event ( this , virtual Key Code , transition State , key Char , menu Pressed , shift Pressed , control Pressed , extended Key ) ) ; }
static public String handle ( String request ) { String Builder response = new String Builder ( ) ; JSON Tokener tokener = new JSON Tokener ( request ) ; try { Object token = tokener . next Value ( ) ; response . append ( STRING ) ; if ( token instanceof JSON Array ) { JSON Array array = ( JSON Array ) token ; for ( int i = NUM ; i < array . length ( ) ; i ++ ) { JSON Object object = ( JSON Object ) array . get ( i ) ; response . append ( STRING + object . get String ( STRING ) + STRING ) ; exec ( object , response ) ; if ( i != array . length ( ) - NUM ) response . append ( STRING ) ; } } else if ( token instanceof JSON Object ) { JSON Object object = ( JSON Object ) token ; response . append ( STRING + object . get String ( STRING ) + STRING ) ; exec ( object , response ) ; } response . append ( STRING ) ; } catch ( Exception e ) { Log . e ( TAG , STRING + request ) ; e . print Stack Trace ( ) ; return STRING ; } Log . d ( TAG , STRING + request ) ; Log . d ( TAG , STRING + response . to String ( ) ) ; return response . to String ( ) ; }
static public String handle ( String request ) { String Builder response = new String Builder ( ) ; JSON Tokener tokener = new JSON Tokener ( request ) ; try { Object token = tokener . next Value ( ) ; response . append ( STRING ) ; if ( token instanceof JSON Array ) { JSON Array array = ( JSON Array ) token ; for ( int i = NUM ; i < array . length ( ) ; i ++ ) { JSON Object object = ( JSON Object ) array . get ( i ) ; response . append ( STRING + object . get String ( STRING ) + STRING ) ; exec ( object , response ) ; if ( i != array . length ( ) - NUM ) response . append ( STRING ) ; } } else if ( token instanceof JSON Object ) { JSON Object object = ( JSON Object ) token ; response . append ( STRING + object . get String ( STRING ) + STRING ) ; exec ( object , response ) ; } response . append ( STRING ) ; } catch ( Exception e ) { Log . e ( TAG , STRING + request ) ; e . print Stack Trace ( ) ; return STRING ; } Log . d ( TAG , STRING + request ) ; Log . d ( TAG , STRING + response . to String ( ) ) ; return response . to String ( ) ; }
public void stub From Method ( Element elt ) { if ( ! ( elt . get Kind ( ) == Element Kind . CONSTRUCTOR || elt . get Kind ( ) == Element Kind . METHOD ) ) { return ; } String new Package = Element Utils . get Verbose Name ( Element Utils . enclosing Package ( elt ) ) ; if ( ! new Package . equals ( STRING ) ) { current Package = new Package ; current Indention = STRING ; indent ( ) ; } Executable Element method = ( Executable Element ) elt ; print Method Decl ( method ) ; }
public final boolean equals ( Object obj ) { return super . equals ( obj ) ; }
private static final void run ( Runnable runnable ) { runnable . run ( ) ; }
private List < Activity > find Best Insertion ( List < Activity > partial Route , boolean allow As Major ) { int start Index = NUM ; int end Index = partial Route . size ( ) - NUM ; if ( allow As Major ) { start Index = NUM ; end Index = partial Route . size ( ) ; } List < Activity > new List = partial Route ; double best = Double . POSITIVE INFINITY ; List < Activity > best List = null ; for ( int i = start Index ; i <= end Index ; i ++ ) { List < Activity > tmp List = new Array List < > ( new List ) ; Activity tmp Activity = get Relocation Activity ( ) ; tmp List . add ( i , tmp Activity ) ; double tmp = evaluate List ( tmp List ) ; if ( tmp < best ) { if ( i == NUM ) { tmp Activity . set Type ( STRING ) ; tmp Activity . set End Time ( Time . parse Time ( STRING ) ) ; } else if ( i == partial Route . size ( ) ) { tmp Activity . set Type ( STRING ) ; } else { tmp Activity . set Type ( STRING ) ; tmp Activity . set Maximum Duration ( Time . parse Time ( STRING ) ) ; } best = tmp ; best List = tmp List ; } } return best List ; }
public D Subject Key Identifier ( J Dialog parent , byte [ ] value , Public Key subject Public Key ) throws IO Exception { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; this . subject Public Key = subject Public Key ; init Components ( ) ; prepopulate With Value ( value ) ; }
private void start Replication Service ( Tungsten Properties repl Props ) throws Replicator Exception { String service Name = repl Props . get String ( Replicator Conf . SERVICE NAME ) ; String service Type = repl Props . get String ( Replicator Conf . SERVICE TYPE ) ; boolean is Detached = repl Props . get Boolean ( Replicator Conf . DETACHED ) ; Open Replicator Manager M Bean orm = null ; try { if ( is Detached ) { throw new Replicator Exception ( STRING ) ; } else { orm = create Internal Service ( service Name ) ; } replicators . put ( service Name , orm ) ; orm . start ( repl Props . get Boolean ( Replicator Conf . FORCE OFFLINE ) ) ; int listen Port = orm . get Master Listen Port ( ) ; if ( listen Port > master Listen Port Max ) master Listen Port Max = listen Port ; logger . info ( String . format ( STRING , ( is Detached ? STRING : STRING ) , service Type , service Name ) ) ; } catch ( Exception e ) { logger . error ( String . format ( STRING , service Name ) , e ) ; } }
public static Source from URL ( URL url , Charset cs ) throws IO Exception { URI uri ; try { uri = url . to URI ( ) ; } catch ( URI Syntax Exception e ) { throw new IO Exception ( STRING , e ) ; } try ( Input Stream is = url . open Stream ( ) ) { return from Stream ( is , uri , cs ) ; } }
private Buffered Image Helper ( ) { }
public Array Access Tree build Array Access ( Expression Tree array , Expression Tree index ) { Array Type array Type = ( Array Type ) Internal Utils . type Of ( array ) ; JC Tree . JC Array Access access = maker . Indexed ( ( JC Tree . JC Expression ) array , ( JC Tree . JC Expression ) index ) ; access . set Type ( ( Type ) array Type . get Component Type ( ) ) ; return access ; }
public Array Access Tree build Array Access ( Expression Tree array , Expression Tree index ) { Array Type array Type = ( Array Type ) Internal Utils . type Of ( array ) ; JC Tree . JC Array Access access = maker . Indexed ( ( JC Tree . JC Expression ) array , ( JC Tree . JC Expression ) index ) ; access . set Type ( ( Type ) array Type . get Component Type ( ) ) ; return access ; }
public void do Initiator Alias Set ( Storage System storage , Initiator initiator , String initiator Alias ) throws Exception { try { check If Provider Supports Alias Operations ( storage ) ; CIM Object Path hw Management ID Svc Path = cim Path . get Storage Hardware ID Management Service ( storage ) ; CIM Object Path shid Path = get SHID Path For Alias Operation ( storage , hw Management ID Svc Path , initiator ) ; CIM Argument [ ] in Args = helper . get EMC Initiator Alias Set Args ( shid Path , initiator Alias ) ; CIM Argument [ ] out Args = new CIM Argument [ NUM ] ; helper . invoke Method ( storage , hw Management ID Svc Path , Smis Constants . INITIATOR ALIAS SET , in Args , out Args ) ; } catch ( WBEM Exception e ) { log . error ( STRING , e ) ; throw e ; } catch ( Exception e ) { log . error ( STRING , e ) ; throw e ; } }
public void do Initiator Alias Set ( Storage System storage , Initiator initiator , String initiator Alias ) throws Exception { try { check If Provider Supports Alias Operations ( storage ) ; CIM Object Path hw Management ID Svc Path = cim Path . get Storage Hardware ID Management Service ( storage ) ; CIM Object Path shid Path = get SHID Path For Alias Operation ( storage , hw Management ID Svc Path , initiator ) ; CIM Argument [ ] in Args = helper . get EMC Initiator Alias Set Args ( shid Path , initiator Alias ) ; CIM Argument [ ] out Args = new CIM Argument [ NUM ] ; helper . invoke Method ( storage , hw Management ID Svc Path , Smis Constants . INITIATOR ALIAS SET , in Args , out Args ) ; } catch ( WBEM Exception e ) { log . error ( STRING , e ) ; throw e ; } catch ( Exception e ) { log . error ( STRING , e ) ; throw e ; } }
public void do Initiator Alias Set ( Storage System storage , Initiator initiator , String initiator Alias ) throws Exception { try { check If Provider Supports Alias Operations ( storage ) ; CIM Object Path hw Management ID Svc Path = cim Path . get Storage Hardware ID Management Service ( storage ) ; CIM Object Path shid Path = get SHID Path For Alias Operation ( storage , hw Management ID Svc Path , initiator ) ; CIM Argument [ ] in Args = helper . get EMC Initiator Alias Set Args ( shid Path , initiator Alias ) ; CIM Argument [ ] out Args = new CIM Argument [ NUM ] ; helper . invoke Method ( storage , hw Management ID Svc Path , Smis Constants . INITIATOR ALIAS SET , in Args , out Args ) ; } catch ( WBEM Exception e ) { log . error ( STRING , e ) ; throw e ; } catch ( Exception e ) { log . error ( STRING , e ) ; throw e ; } }
public void do Initiator Alias Set ( Storage System storage , Initiator initiator , String initiator Alias ) throws Exception { try { check If Provider Supports Alias Operations ( storage ) ; CIM Object Path hw Management ID Svc Path = cim Path . get Storage Hardware ID Management Service ( storage ) ; CIM Object Path shid Path = get SHID Path For Alias Operation ( storage , hw Management ID Svc Path , initiator ) ; CIM Argument [ ] in Args = helper . get EMC Initiator Alias Set Args ( shid Path , initiator Alias ) ; CIM Argument [ ] out Args = new CIM Argument [ NUM ] ; helper . invoke Method ( storage , hw Management ID Svc Path , Smis Constants . INITIATOR ALIAS SET , in Args , out Args ) ; } catch ( WBEM Exception e ) { log . error ( STRING , e ) ; throw e ; } catch ( Exception e ) { log . error ( STRING , e ) ; throw e ; } }
void parse Finish ( ) { m Children = m Current Group . get Children ( ) ; }
public void delete Attributes ( int [ ] column Indices ) { int i ; Arrays . sort ( column Indices ) ; add Undo Point ( ) ; m Ignore Changes = BOOL ; for ( i = column Indices . length - NUM ; i >= NUM ; i -- ) { delete Attribute At ( column Indices [ i ] , BOOL ) ; } m Ignore Changes = BOOL ; notify Listener ( new Table Model Event ( this , Table Model Event . HEADER ROW ) ) ; }
void add Child ( Environment Logger child ) { children . add ( new Weak Reference < Environment Logger > ( child ) ) ; update Children ( ) ; }
void add Child ( Environment Logger child ) { children . add ( new Weak Reference < Environment Logger > ( child ) ) ; update Children ( ) ; }
public J Popup Menu create Popup Menu ( ) { return create Popup Menu ( get All Selected Lines ( ) ) ; }
private static int build Request Code ( long thread Id , int action ) { action ++ ; return ( int ) ( action * NUM + thread Id ) ; }
private static int build Request Code ( long thread Id , int action ) { action ++ ; return ( int ) ( action * NUM + thread Id ) ; }
public void clear Selection ( ) { m selected Items . clear ( ) ; }
public void clear Selection ( ) { m selected Items . clear ( ) ; }
private String create Connection Name ( ) { String Builder name Buffer = new String Builder ( ) ; name Buffer . append ( get Connection Type ( ) ) ; name Buffer . append ( STRING ) ; name Buffer . append ( host ) ; name Buffer . append ( STRING ) ; name Buffer . append ( port ) ; return name Buffer . to String ( ) ; }
private static double compute KLD ( double [ ] px , double [ ] py ) { double result = NUM ; for ( int i = NUM ; i < px . length ; i ++ ) { double xi = Math . max ( px [ i ] , NUM ) ; double yi = Math . max ( py [ i ] , NUM ) ; result += xi * Math . log ( xi / yi ) ; } return result ; }
@ Override public final int read Byte ( ) { int temp ; try { temp = raf . read ( ) ; if ( temp == - NUM ) { throw new Runtime Exception ( STRING ) ; } read ++ ; return temp ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public static String to String ( JSON Object jo ) throws JSON Exception { String Builder sb = new String Builder ( ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; sb . append ( STRING ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( jo . get String ( STRING ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; } if ( jo . opt Boolean ( STRING ) ) { sb . append ( STRING ) ; } return sb . to String ( ) ; }
public static String to String ( JSON Object jo ) throws JSON Exception { String Builder sb = new String Builder ( ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; sb . append ( STRING ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( jo . get String ( STRING ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; } if ( jo . opt Boolean ( STRING ) ) { sb . append ( STRING ) ; } return sb . to String ( ) ; }
public static String to String ( JSON Object jo ) throws JSON Exception { String Builder sb = new String Builder ( ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; sb . append ( STRING ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( jo . get String ( STRING ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; } if ( jo . opt Boolean ( STRING ) ) { sb . append ( STRING ) ; } return sb . to String ( ) ; }
public static String to String ( JSON Object jo ) throws JSON Exception { String Builder sb = new String Builder ( ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; sb . append ( STRING ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( jo . get String ( STRING ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; } if ( jo . opt Boolean ( STRING ) ) { sb . append ( STRING ) ; } return sb . to String ( ) ; }
public void close ( ) { flush ( ) ; try { out . close ( ) ; } catch ( IO Exception e ) { throw new Illegal State Exception ( e ) ; } }
public void close ( ) { flush ( ) ; try { out . close ( ) ; } catch ( IO Exception e ) { throw new Illegal State Exception ( e ) ; } }
public void add ( File file , String path For Entry , String password ) throws IO Exception , Unsupported Encoding Exception { File Input Stream fis = new File Input Stream ( file ) ; try { add ( path For Entry , fis , password ) ; } finally { fis . close ( ) ; } }
public void add ( File file , String path For Entry , String password ) throws IO Exception , Unsupported Encoding Exception { File Input Stream fis = new File Input Stream ( file ) ; try { add ( path For Entry , fis , password ) ; } finally { fis . close ( ) ; } }
public static String create Test Pt Station CSV File ( File file ) { try ( Buffered Writer bw = new Buffered Writer ( new File Writer ( file ) ) ) { bw . write ( STRING ) ; bw . new Line ( ) ; bw . write ( STRING ) ; bw . new Line ( ) ; bw . write ( STRING ) ; bw . new Line ( ) ; bw . write ( STRING ) ; bw . new Line ( ) ; bw . write ( STRING ) ; bw . new Line ( ) ; return file . get Canonical Path ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public static String create Test Pt Station CSV File ( File file ) { try ( Buffered Writer bw = new Buffered Writer ( new File Writer ( file ) ) ) { bw . write ( STRING ) ; bw . new Line ( ) ; bw . write ( STRING ) ; bw . new Line ( ) ; bw . write ( STRING ) ; bw . new Line ( ) ; bw . write ( STRING ) ; bw . new Line ( ) ; bw . write ( STRING ) ; bw . new Line ( ) ; return file . get Canonical Path ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public Power Model Sqrt ( double max Power , double static Power Percent ) { set Max Power ( max Power ) ; set Static Power ( static Power Percent * max Power ) ; set Constant ( ( max Power - get Static Power ( ) ) / Math . sqrt ( NUM ) ) ; }
public void add ( Registration Handle handle ) { handles . add ( handle ) ; }
public void add ( Registration Handle handle ) { handles . add ( handle ) ; }
public void add Gossip Member ( Gossip Member member ) { gossip Members . add ( member ) ; }
public Argument add Form ( final String alias Name ) { forms . add ( alias Name ) ; return this ; }
public void write ( Char Sequence csq ) throws IO Exception { if ( output Stream == null ) throw new IO Exception ( STRING ) ; final int length = csq . length ( ) ; for ( int i = NUM ; i < length ; ) { char c = csq . char At ( i ++ ) ; if ( c < NUM ) { bytes [ index ] = ( byte ) c ; if ( ++ index >= bytes . length ) { flush Buffer ( ) ; } } else { write ( c ) ; } } }
public static long long From Properties ( Properties p , String prop Name , long default Value ) { long ret = default Value ; String long String = p . get Property ( prop Name ) ; if ( long String != null ) { try { ret = Long . parse Long ( long String . trim ( ) ) ; } catch ( Number Format Exception e ) { ret = default Value ; } } return ret ; }
public static long long From Properties ( Properties p , String prop Name , long default Value ) { long ret = default Value ; String long String = p . get Property ( prop Name ) ; if ( long String != null ) { try { ret = Long . parse Long ( long String . trim ( ) ) ; } catch ( Number Format Exception e ) { ret = default Value ; } } return ret ; }
public String encode Buffer ( byte a Buffer [ ] ) { Byte Array Output Stream out Stream = new Byte Array Output Stream ( ) ; Byte Array Input Stream in Stream = new Byte Array Input Stream ( a Buffer ) ; try { encode Buffer ( in Stream , out Stream ) ; } catch ( Exception IO Exception ) { throw new Error ( STRING ) ; } return ( out Stream . to String ( ) ) ; }
public String encode Buffer ( byte a Buffer [ ] ) { Byte Array Output Stream out Stream = new Byte Array Output Stream ( ) ; Byte Array Input Stream in Stream = new Byte Array Input Stream ( a Buffer ) ; try { encode Buffer ( in Stream , out Stream ) ; } catch ( Exception IO Exception ) { throw new Error ( STRING ) ; } return ( out Stream . to String ( ) ) ; }
public String encode Buffer ( byte a Buffer [ ] ) { Byte Array Output Stream out Stream = new Byte Array Output Stream ( ) ; Byte Array Input Stream in Stream = new Byte Array Input Stream ( a Buffer ) ; try { encode Buffer ( in Stream , out Stream ) ; } catch ( Exception IO Exception ) { throw new Error ( STRING ) ; } return ( out Stream . to String ( ) ) ; }
public String encode Buffer ( byte a Buffer [ ] ) { Byte Array Output Stream out Stream = new Byte Array Output Stream ( ) ; Byte Array Input Stream in Stream = new Byte Array Input Stream ( a Buffer ) ; try { encode Buffer ( in Stream , out Stream ) ; } catch ( Exception IO Exception ) { throw new Error ( STRING ) ; } return ( out Stream . to String ( ) ) ; }
public String encode Buffer ( byte a Buffer [ ] ) { Byte Array Output Stream out Stream = new Byte Array Output Stream ( ) ; Byte Array Input Stream in Stream = new Byte Array Input Stream ( a Buffer ) ; try { encode Buffer ( in Stream , out Stream ) ; } catch ( Exception IO Exception ) { throw new Error ( STRING ) ; } return ( out Stream . to String ( ) ) ; }
public String encode Buffer ( byte a Buffer [ ] ) { Byte Array Output Stream out Stream = new Byte Array Output Stream ( ) ; Byte Array Input Stream in Stream = new Byte Array Input Stream ( a Buffer ) ; try { encode Buffer ( in Stream , out Stream ) ; } catch ( Exception IO Exception ) { throw new Error ( STRING ) ; } return ( out Stream . to String ( ) ) ; }
public void notify Change ( ) { execute Event ( ) ; }
public void notify Change ( ) { execute Event ( ) ; }
public void notify Change ( ) { execute Event ( ) ; }
public boolean has Name Value ( String name ) { return hmap . contains Key ( name . to Lower Case ( ) ) ; }
public boolean has Name Value ( String name ) { return hmap . contains Key ( name . to Lower Case ( ) ) ; }
public void move To ( float x , float y ) { m Points . add ( Path Point . move To ( x , y ) ) ; }
public void move To ( float x , float y ) { m Points . add ( Path Point . move To ( x , y ) ) ; }
private String determine Startup Script Path ( I Path workspace Relative Html Path , Module File referenced Module ) { I Path out Relative Html Path = get Out Dir Relative Html Path ( workspace Relative Html Path ) ; if ( out Relative Html Path == null ) { return null ; } I Path out Relative Startup Script Path = get Out Dir Relative Startup Script Path ( referenced Module ) ; return get Relative Url ( out Relative Html Path , out Relative Startup Script Path ) ; }
private String determine Startup Script Path ( I Path workspace Relative Html Path , Module File referenced Module ) { I Path out Relative Html Path = get Out Dir Relative Html Path ( workspace Relative Html Path ) ; if ( out Relative Html Path == null ) { return null ; } I Path out Relative Startup Script Path = get Out Dir Relative Startup Script Path ( referenced Module ) ; return get Relative Url ( out Relative Html Path , out Relative Startup Script Path ) ; }
private String determine Startup Script Path ( I Path workspace Relative Html Path , Module File referenced Module ) { I Path out Relative Html Path = get Out Dir Relative Html Path ( workspace Relative Html Path ) ; if ( out Relative Html Path == null ) { return null ; } I Path out Relative Startup Script Path = get Out Dir Relative Startup Script Path ( referenced Module ) ; return get Relative Url ( out Relative Html Path , out Relative Startup Script Path ) ; }
private String determine Startup Script Path ( I Path workspace Relative Html Path , Module File referenced Module ) { I Path out Relative Html Path = get Out Dir Relative Html Path ( workspace Relative Html Path ) ; if ( out Relative Html Path == null ) { return null ; } I Path out Relative Startup Script Path = get Out Dir Relative Startup Script Path ( referenced Module ) ; return get Relative Url ( out Relative Html Path , out Relative Startup Script Path ) ; }
private String determine Startup Script Path ( I Path workspace Relative Html Path , Module File referenced Module ) { I Path out Relative Html Path = get Out Dir Relative Html Path ( workspace Relative Html Path ) ; if ( out Relative Html Path == null ) { return null ; } I Path out Relative Startup Script Path = get Out Dir Relative Startup Script Path ( referenced Module ) ; return get Relative Url ( out Relative Html Path , out Relative Startup Script Path ) ; }
private String determine Startup Script Path ( I Path workspace Relative Html Path , Module File referenced Module ) { I Path out Relative Html Path = get Out Dir Relative Html Path ( workspace Relative Html Path ) ; if ( out Relative Html Path == null ) { return null ; } I Path out Relative Startup Script Path = get Out Dir Relative Startup Script Path ( referenced Module ) ; return get Relative Url ( out Relative Html Path , out Relative Startup Script Path ) ; }
public static Model read From ( Virtual File file ) throws Server Exception , Forbidden Exception , IO Exception { require Non Null ( file , STRING ) ; return fetch Model ( XML Tree . from ( file . get Content ( ) ) ) ; }
private void start Local ( final Process process , final String p Host Name , final Timestamp p Startup Time ) { Process Cache Object process Cache Object = ( Process Cache Object ) process ; final Long new PIK = create Process PIK ( ) ; process Cache Object . set Current Host ( p Host Name ) ; process Cache Object . set Startup Time ( p Startup Time ) ; process Cache Object . set Requires Reboot ( Boolean . FALSE ) ; process Cache Object . set Process PIK ( new PIK ) ; process Cache Object . set Local Config ( Local Config . Y ) ; process Cache Object . set Jms Daq Command Queue ( jms Daq Queue Trunk + STRING + process Cache Object . get Current Host ( ) + STRING + process Cache Object . get Name ( ) + STRING + new PIK . to String ( ) ) ; super . start ( process Cache Object , p Startup Time ) ; }
public void reset Filters ( Boolean enabled ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + enabled ) ; } Set keys = filters . key Set ( ) ; for ( Iterator it = keys . iterator ( ) ; it . has Next ( ) ; ) { String title = ( String ) it . next ( ) ; set Filter Value ( title , enabled ) ; } update Interface ( ) ; }
public void reset Filters ( Boolean enabled ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + enabled ) ; } Set keys = filters . key Set ( ) ; for ( Iterator it = keys . iterator ( ) ; it . has Next ( ) ; ) { String title = ( String ) it . next ( ) ; set Filter Value ( title , enabled ) ; } update Interface ( ) ; }
public void reset Filters ( Boolean enabled ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + enabled ) ; } Set keys = filters . key Set ( ) ; for ( Iterator it = keys . iterator ( ) ; it . has Next ( ) ; ) { String title = ( String ) it . next ( ) ; set Filter Value ( title , enabled ) ; } update Interface ( ) ; }
public void reset Filters ( Boolean enabled ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + enabled ) ; } Set keys = filters . key Set ( ) ; for ( Iterator it = keys . iterator ( ) ; it . has Next ( ) ; ) { String title = ( String ) it . next ( ) ; set Filter Value ( title , enabled ) ; } update Interface ( ) ; }
public void add ( Permission perm ) { if ( ! ( perm instanceof IS Permission ) ) { String objs [ ] = { perm . to String ( ) } ; throw ( new Illegal Argument Exception ( Res Bundle Utils . get String ( STRING , objs ) ) ) ; } if ( is Read Only ( ) ) { throw new Security Exception ( Res Bundle Utils . get String ( STRING ) ) ; } debug . message ( STRING ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + perm . to String ( ) ) ; } perms . put ( perm . get Name ( ) , perm ) ; }
public void receive ( final Call Event event ) { if ( event . is Valid ( ) ) { if ( ! m Events . contains ( event ) ) { m Events . add ( NUM , event ) ; fire Table Rows Inserted ( NUM , NUM ) ; prune ( ) ; } else { int row = m Events . index Of ( event ) ; fire Table Rows Updated ( row , row ) ; } } else { if ( m Events . contains ( event ) ) { int row = m Events . index Of ( event ) ; m Events . remove ( event ) ; fire Table Rows Deleted ( row , row ) ; } } }
public void receive ( final Call Event event ) { if ( event . is Valid ( ) ) { if ( ! m Events . contains ( event ) ) { m Events . add ( NUM , event ) ; fire Table Rows Inserted ( NUM , NUM ) ; prune ( ) ; } else { int row = m Events . index Of ( event ) ; fire Table Rows Updated ( row , row ) ; } } else { if ( m Events . contains ( event ) ) { int row = m Events . index Of ( event ) ; m Events . remove ( event ) ; fire Table Rows Deleted ( row , row ) ; } } }
public void receive ( final Call Event event ) { if ( event . is Valid ( ) ) { if ( ! m Events . contains ( event ) ) { m Events . add ( NUM , event ) ; fire Table Rows Inserted ( NUM , NUM ) ; prune ( ) ; } else { int row = m Events . index Of ( event ) ; fire Table Rows Updated ( row , row ) ; } } else { if ( m Events . contains ( event ) ) { int row = m Events . index Of ( event ) ; m Events . remove ( event ) ; fire Table Rows Deleted ( row , row ) ; } } }
public void receive ( final Call Event event ) { if ( event . is Valid ( ) ) { if ( ! m Events . contains ( event ) ) { m Events . add ( NUM , event ) ; fire Table Rows Inserted ( NUM , NUM ) ; prune ( ) ; } else { int row = m Events . index Of ( event ) ; fire Table Rows Updated ( row , row ) ; } } else { if ( m Events . contains ( event ) ) { int row = m Events . index Of ( event ) ; m Events . remove ( event ) ; fire Table Rows Deleted ( row , row ) ; } } }
public void receive ( final Call Event event ) { if ( event . is Valid ( ) ) { if ( ! m Events . contains ( event ) ) { m Events . add ( NUM , event ) ; fire Table Rows Inserted ( NUM , NUM ) ; prune ( ) ; } else { int row = m Events . index Of ( event ) ; fire Table Rows Updated ( row , row ) ; } } else { if ( m Events . contains ( event ) ) { int row = m Events . index Of ( event ) ; m Events . remove ( event ) ; fire Table Rows Deleted ( row , row ) ; } } }
public void receive ( final Call Event event ) { if ( event . is Valid ( ) ) { if ( ! m Events . contains ( event ) ) { m Events . add ( NUM , event ) ; fire Table Rows Inserted ( NUM , NUM ) ; prune ( ) ; } else { int row = m Events . index Of ( event ) ; fire Table Rows Updated ( row , row ) ; } } else { if ( m Events . contains ( event ) ) { int row = m Events . index Of ( event ) ; m Events . remove ( event ) ; fire Table Rows Deleted ( row , row ) ; } } }
private void rebuild Criterium Cache Menu ( ) { m previous Criteria Menu . remove All ( ) ; m previous Criteria Menu . set Visible ( BOOL ) ; for ( final C Cached Expression Tree tree : m criterium Cache . get Trees ( ) ) { m previous Criteria Menu . add ( new J Menu Item ( new C Execute Cached Criterium ( m model . get Graph ( ) , tree ) ) ) ; } }
private void rebuild Criterium Cache Menu ( ) { m previous Criteria Menu . remove All ( ) ; m previous Criteria Menu . set Visible ( BOOL ) ; for ( final C Cached Expression Tree tree : m criterium Cache . get Trees ( ) ) { m previous Criteria Menu . add ( new J Menu Item ( new C Execute Cached Criterium ( m model . get Graph ( ) , tree ) ) ) ; } }
private void rebuild Criterium Cache Menu ( ) { m previous Criteria Menu . remove All ( ) ; m previous Criteria Menu . set Visible ( BOOL ) ; for ( final C Cached Expression Tree tree : m criterium Cache . get Trees ( ) ) { m previous Criteria Menu . add ( new J Menu Item ( new C Execute Cached Criterium ( m model . get Graph ( ) , tree ) ) ) ; } }
public State Interactive key typed ( char p key char ) { State Interactive curr return state = this ; if ( Character . is Digit ( p key char ) ) { Brd Layer Structure layer structure = r brd . layer structure ; int digit = Character . digit ( p key char , NUM ) ; digit = Math . min ( digit , layer structure . signal layer count ( ) ) ; digit = Math . max ( digit - NUM , NUM ) ; Brd Layer new layer = layer structure . get signal layer ( digit ) ; digit = layer structure . get no ( new layer ) ; if ( digit >= NUM ) { change layer action ( digit ) ; } } else if ( p key char == STRING ) { Brd Layer Structure layer structure = r brd . layer structure ; int current layer no = i brd . itera settings . layer no ; for ( ; ; ) { ++ current layer no ; if ( current layer no >= layer structure . size ( ) || layer structure . is signal ( current layer no ) ) { break ; } } if ( current layer no < layer structure . size ( ) ) { change layer action ( current layer no ) ; } } else if ( p key char == STRING ) { board . Brd Layer Structure layer structure = r brd . layer structure ; int current layer no = i brd . itera settings . layer no ; for ( ; ; ) { -- current layer no ; if ( current layer no < NUM || layer structure . is signal ( current layer no ) ) { break ; } } if ( current layer no >= NUM ) { change layer action ( current layer no ) ; } } else { curr return state = super . key typed ( p key char ) ; } return curr return state ; }
private static String unsigned To String ( final int value ) { if ( value >= NUM ) { return Integer . to String ( value ) ; } else { return Long . to String ( ( ( long ) value ) & NUM ) ; } }
private byte post Decryption ( Cipher State state , Byte Buffer in Byte Buffer , long position , byte [ ] iv ) throws IO Exception { byte padding = NUM ; if ( state . is Reset ( ) ) { reset Cipher ( state , position , iv ) ; padding = get Padding ( position ) ; in Byte Buffer . position ( padding ) ; } return padding ; }
public static String copy To String ( Reader in ) throws IO Exception { String Writer out = new String Writer ( ) ; copy ( in , out ) ; String str = out . to String ( ) ; if ( str . starts With ( STRING ) ) { return str . substring ( NUM ) ; } return str ; }
public Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int band List [ ] ) { if ( x < this . min X ) { throw new Raster Format Exception ( STRING ) ; } if ( y < this . min Y ) { throw new Raster Format Exception ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . width + this . min X ) ) { throw new Raster Format Exception ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . height + this . min Y ) ) { throw new Raster Format Exception ( STRING ) ; } Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new Byte Banded Raster ( sm , data Buffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
public Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int band List [ ] ) { if ( x < this . min X ) { throw new Raster Format Exception ( STRING ) ; } if ( y < this . min Y ) { throw new Raster Format Exception ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . width + this . min X ) ) { throw new Raster Format Exception ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . height + this . min Y ) ) { throw new Raster Format Exception ( STRING ) ; } Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new Byte Banded Raster ( sm , data Buffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
public Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int band List [ ] ) { if ( x < this . min X ) { throw new Raster Format Exception ( STRING ) ; } if ( y < this . min Y ) { throw new Raster Format Exception ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . width + this . min X ) ) { throw new Raster Format Exception ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . height + this . min Y ) ) { throw new Raster Format Exception ( STRING ) ; } Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new Byte Banded Raster ( sm , data Buffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
public Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int band List [ ] ) { if ( x < this . min X ) { throw new Raster Format Exception ( STRING ) ; } if ( y < this . min Y ) { throw new Raster Format Exception ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . width + this . min X ) ) { throw new Raster Format Exception ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . height + this . min Y ) ) { throw new Raster Format Exception ( STRING ) ; } Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new Byte Banded Raster ( sm , data Buffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
public Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int band List [ ] ) { if ( x < this . min X ) { throw new Raster Format Exception ( STRING ) ; } if ( y < this . min Y ) { throw new Raster Format Exception ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . width + this . min X ) ) { throw new Raster Format Exception ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . height + this . min Y ) ) { throw new Raster Format Exception ( STRING ) ; } Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new Byte Banded Raster ( sm , data Buffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
public Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int band List [ ] ) { if ( x < this . min X ) { throw new Raster Format Exception ( STRING ) ; } if ( y < this . min Y ) { throw new Raster Format Exception ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . width + this . min X ) ) { throw new Raster Format Exception ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . height + this . min Y ) ) { throw new Raster Format Exception ( STRING ) ; } Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new Byte Banded Raster ( sm , data Buffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
public Script Builder add Chunk ( Script Chunk chunk ) { return add Chunk ( chunks . size ( ) , chunk ) ; }
public Script Builder add Chunk ( Script Chunk chunk ) { return add Chunk ( chunks . size ( ) , chunk ) ; }
@ Override protected void do Post ( Http Servlet Request request , Http Servlet Response response ) throws Servlet Exception , IO Exception { String path Info = request . get Path Info ( ) ; if ( path Info == null ) { print Error ( response , STRING ) ; return ; } URL url = null ; try { url = new URL ( destination Url + path Info ) ; } catch ( Malformed URL Exception e ) { print Error ( response , STRING ) ; return ; } Http URL Connection connection = null ; try { connection = open Connection ( url ) ; } catch ( IO Exception e ) { print Error ( response , e . get Message ( ) ) ; return ; } try { forward Post ( connection , request , response ) ; } catch ( IO Exception e ) { print Error ( response , e . get Message ( ) ) ; return ; } finally { close Connection ( connection ) ; } }
@ Override protected void do Post ( Http Servlet Request request , Http Servlet Response response ) throws Servlet Exception , IO Exception { String path Info = request . get Path Info ( ) ; if ( path Info == null ) { print Error ( response , STRING ) ; return ; } URL url = null ; try { url = new URL ( destination Url + path Info ) ; } catch ( Malformed URL Exception e ) { print Error ( response , STRING ) ; return ; } Http URL Connection connection = null ; try { connection = open Connection ( url ) ; } catch ( IO Exception e ) { print Error ( response , e . get Message ( ) ) ; return ; } try { forward Post ( connection , request , response ) ; } catch ( IO Exception e ) { print Error ( response , e . get Message ( ) ) ; return ; } finally { close Connection ( connection ) ; } }
public void emit Retained Vars ( Generate Js Visitor gen ) { if ( ! retained Vars . is Empty ( ) ) { gen . out ( STRING ) ; boolean first = BOOL ; for ( String var Name : retained Vars ) { if ( ! first ) { gen . out ( STRING ) ; } first = BOOL ; gen . out ( var Name ) ; } gen . end Line ( BOOL ) ; retained Vars . clear ( ) ; } }
public void emit Retained Vars ( Generate Js Visitor gen ) { if ( ! retained Vars . is Empty ( ) ) { gen . out ( STRING ) ; boolean first = BOOL ; for ( String var Name : retained Vars ) { if ( ! first ) { gen . out ( STRING ) ; } first = BOOL ; gen . out ( var Name ) ; } gen . end Line ( BOOL ) ; retained Vars . clear ( ) ; } }
public static String consistent To String ( Big Decimal decimal ) { if ( decimal == null ) { return null ; } if ( to Plain String Method != null ) { try { return ( String ) to Plain String Method . invoke ( decimal , ( Object [ ] ) null ) ; } catch ( Invocation Target Exception invoke Ex ) { } catch ( Illegal Access Exception access Ex ) { } } return decimal . to String ( ) ; }
public static String consistent To String ( Big Decimal decimal ) { if ( decimal == null ) { return null ; } if ( to Plain String Method != null ) { try { return ( String ) to Plain String Method . invoke ( decimal , ( Object [ ] ) null ) ; } catch ( Invocation Target Exception invoke Ex ) { } catch ( Illegal Access Exception access Ex ) { } } return decimal . to String ( ) ; }
public static String consistent To String ( Big Decimal decimal ) { if ( decimal == null ) { return null ; } if ( to Plain String Method != null ) { try { return ( String ) to Plain String Method . invoke ( decimal , ( Object [ ] ) null ) ; } catch ( Invocation Target Exception invoke Ex ) { } catch ( Illegal Access Exception access Ex ) { } } return decimal . to String ( ) ; }
protected synchronized void remember Last Thing ( Undo Event event ) { if ( undo Stack . size ( ) >= stack Size ) { undo Stack . remove Element At ( NUM ) ; } if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + event . get Description ( ) + STRING ) ; } undo Stack . push ( event ) ; }
protected synchronized void remember Last Thing ( Undo Event event ) { if ( undo Stack . size ( ) >= stack Size ) { undo Stack . remove Element At ( NUM ) ; } if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + event . get Description ( ) + STRING ) ; } undo Stack . push ( event ) ; }
protected synchronized void remember Last Thing ( Undo Event event ) { if ( undo Stack . size ( ) >= stack Size ) { undo Stack . remove Element At ( NUM ) ; } if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + event . get Description ( ) + STRING ) ; } undo Stack . push ( event ) ; }
private J Tabbed Pane create Tabbed Pane ( final boolean is Default Settings Dialog , final boolean is Callgraph ) { final J Tabbed Pane tab = new J Tabbed Pane ( ) ; add Tab ( tab , STRING , new C Automatism Panel ( m settings , is Default Settings Dialog ) ) ; add Tab ( tab , STRING , new C Edge Panel ( m settings ) ) ; add Tab ( tab , STRING , new C Hierarchic Panel ( m settings ) ) ; add Tab ( tab , STRING , new C Orthogonal Panel ( m settings ) ) ; add Tab ( tab , STRING , new C Circular Panel ( m settings ) ) ; if ( ! is Callgraph ) { add Tab ( tab , STRING , new C Disassembly Panel ( m settings ) ) ; } add Tab ( tab , STRING , new C Controls Panel ( m settings ) ) ; add Tab ( tab , STRING , new C Misc Panel ( m settings , ! is Default Settings Dialog || is Callgraph ) ) ; tab . set Preferred Size ( new Dimension ( FRAME WIDTH , FRAME HEIGHT ) ) ; return tab ; }
private J Tabbed Pane create Tabbed Pane ( final boolean is Default Settings Dialog , final boolean is Callgraph ) { final J Tabbed Pane tab = new J Tabbed Pane ( ) ; add Tab ( tab , STRING , new C Automatism Panel ( m settings , is Default Settings Dialog ) ) ; add Tab ( tab , STRING , new C Edge Panel ( m settings ) ) ; add Tab ( tab , STRING , new C Hierarchic Panel ( m settings ) ) ; add Tab ( tab , STRING , new C Orthogonal Panel ( m settings ) ) ; add Tab ( tab , STRING , new C Circular Panel ( m settings ) ) ; if ( ! is Callgraph ) { add Tab ( tab , STRING , new C Disassembly Panel ( m settings ) ) ; } add Tab ( tab , STRING , new C Controls Panel ( m settings ) ) ; add Tab ( tab , STRING , new C Misc Panel ( m settings , ! is Default Settings Dialog || is Callgraph ) ) ; tab . set Preferred Size ( new Dimension ( FRAME WIDTH , FRAME HEIGHT ) ) ; return tab ; }
private J Tabbed Pane create Tabbed Pane ( final boolean is Default Settings Dialog , final boolean is Callgraph ) { final J Tabbed Pane tab = new J Tabbed Pane ( ) ; add Tab ( tab , STRING , new C Automatism Panel ( m settings , is Default Settings Dialog ) ) ; add Tab ( tab , STRING , new C Edge Panel ( m settings ) ) ; add Tab ( tab , STRING , new C Hierarchic Panel ( m settings ) ) ; add Tab ( tab , STRING , new C Orthogonal Panel ( m settings ) ) ; add Tab ( tab , STRING , new C Circular Panel ( m settings ) ) ; if ( ! is Callgraph ) { add Tab ( tab , STRING , new C Disassembly Panel ( m settings ) ) ; } add Tab ( tab , STRING , new C Controls Panel ( m settings ) ) ; add Tab ( tab , STRING , new C Misc Panel ( m settings , ! is Default Settings Dialog || is Callgraph ) ) ; tab . set Preferred Size ( new Dimension ( FRAME WIDTH , FRAME HEIGHT ) ) ; return tab ; }
public static boolean contains Property ( String value , String property ) { return null != value && ( value . contains ( DELIM START AMPERSAND + property + DELIM STOP ) || value . contains ( DELIM START DOLLAR + property + DELIM STOP ) ) ; }
public static boolean contains Property ( String value , String property ) { return null != value && ( value . contains ( DELIM START AMPERSAND + property + DELIM STOP ) || value . contains ( DELIM START DOLLAR + property + DELIM STOP ) ) ; }
public void mouse Entered ( Mouse Event e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( get ID ( ) + STRING ) ; } super . mouse Entered ( e ) ; auto Zoom = BOOL ; }
public void mouse Entered ( Mouse Event e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( get ID ( ) + STRING ) ; } super . mouse Entered ( e ) ; auto Zoom = BOOL ; }
public void mouse Entered ( Mouse Event e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( get ID ( ) + STRING ) ; } super . mouse Entered ( e ) ; auto Zoom = BOOL ; }
public void mouse Entered ( Mouse Event e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( get ID ( ) + STRING ) ; } super . mouse Entered ( e ) ; auto Zoom = BOOL ; }
public void mouse Entered ( Mouse Event e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( get ID ( ) + STRING ) ; } super . mouse Entered ( e ) ; auto Zoom = BOOL ; }
protected Packet ( short packettype ) { sig = new byte [ ] { STRING , STRING , STRING , STRING } ; minver = NUM ; majver = NUM ; this . packettype = packettype ; }
protected Packet ( short packettype ) { sig = new byte [ ] { STRING , STRING , STRING , STRING } ; minver = NUM ; majver = NUM ; this . packettype = packettype ; }
public boolean compare And Set ( final long expected Value , final long new Value ) { return UNSAFE . compare And Swap Long ( this , VALUE OFFSET , expected Value , new Value ) ; }
public URI ( String nuri ) throws Malformed URI Exception { uri = nuri ; colon Location = nuri . index Of ( STRING ) ; fragment Location = URI Classifier . get Fragment Location ( nuri ) ; if ( colon Location == - NUM || colon Location > fragment Location || colon Location == NUM ) throw new Malformed URI Exception ( STRING + uri + STRING , uri ) ; }
public void start Execution Every Day At ( Custom Timer Task task , int target Hour , int target Min , int target Sec ) { Bot Logger . warn ( LOGTAG , STRING + task . get Task Name ( ) ) ; final Runnable task Wrapper = null ; if ( task . get Times ( ) != NUM ) { final long delay = comput Next Dilay ( target Hour , target Min , target Sec ) ; executor Service . schedule ( task Wrapper , delay , Time Unit . SECONDS ) ; } }
public void mouse Moved ( Mouse Event e ) { mouse Support . fire Map Mouse Moved ( e ) ; if ( e . get Source ( ) instanceof Map Bean ) { if ( draw Distance Objects && the Map != null ) { double lat 1 , lat 2 , long 1 , long 2 ; r Point 2 = the Map . get Coordinates ( e ) ; the Map . repaint ( ) ; if ( info Delegator != null ) { Debug . message ( STRING , STRING ) ; lat 1 = r Point 1 . get Y ( ) ; long 1 = r Point 1 . get X ( ) ; lat 2 = r Point 2 . get Y ( ) ; long 2 = r Point 2 . get X ( ) ; distance = Great Circle . spherical Distance ( Proj Math . deg To Rad ( lat 1 ) , Proj Math . deg To Rad ( long 1 ) , Proj Math . deg To Rad ( lat 2 ) , Proj Math . deg To Rad ( long 2 ) ) ; double azimuth = get Spherical Azimuth ( lat 1 , long 1 , lat 2 , long 2 ) ; double tmp Distance = total Distance + distance ; String info Line = create Distance Information Line ( r Point 2 , tmp Distance , azimuth ) ; Info Display Event info = new Info Display Event ( this , info Line , Information Delegator . COORDINATE INFO LINE ) ; info Delegator . request Info Line ( info ) ; } } else { fire Mouse Location ( e ) ; } } }
public void mouse Moved ( Mouse Event e ) { mouse Support . fire Map Mouse Moved ( e ) ; if ( e . get Source ( ) instanceof Map Bean ) { if ( draw Distance Objects && the Map != null ) { double lat 1 , lat 2 , long 1 , long 2 ; r Point 2 = the Map . get Coordinates ( e ) ; the Map . repaint ( ) ; if ( info Delegator != null ) { Debug . message ( STRING , STRING ) ; lat 1 = r Point 1 . get Y ( ) ; long 1 = r Point 1 . get X ( ) ; lat 2 = r Point 2 . get Y ( ) ; long 2 = r Point 2 . get X ( ) ; distance = Great Circle . spherical Distance ( Proj Math . deg To Rad ( lat 1 ) , Proj Math . deg To Rad ( long 1 ) , Proj Math . deg To Rad ( lat 2 ) , Proj Math . deg To Rad ( long 2 ) ) ; double azimuth = get Spherical Azimuth ( lat 1 , long 1 , lat 2 , long 2 ) ; double tmp Distance = total Distance + distance ; String info Line = create Distance Information Line ( r Point 2 , tmp Distance , azimuth ) ; Info Display Event info = new Info Display Event ( this , info Line , Information Delegator . COORDINATE INFO LINE ) ; info Delegator . request Info Line ( info ) ; } } else { fire Mouse Location ( e ) ; } } }
public Remove Breakpoints Command ( final int packet Id , final Set < Relocated Address > addresses , final Breakpoint Type type ) { super ( get Command For Type ( type ) , packet Id ) ; Preconditions . check Not Null ( addresses , STRING ) ; add Argument ( new Debug Message Integer Argument ( addresses . size ( ) ) ) ; for ( final Relocated Address address : addresses ) { add Argument ( new Debug Message Address Argument ( address . get Address ( ) ) ) ; } }
public void start Entity ( String name ) throws org . xml . sax . SAX Exception { if ( name . equals ( STRING ) ) m in External DTD = BOOL ; if ( ! m expand DTD Entities && ! m in External DTD ) { start Non Escaping ( ) ; characters ( STRING + name + STRING ) ; end Non Escaping ( ) ; } m in Entity Ref = BOOL ; }
public void start Entity ( String name ) throws org . xml . sax . SAX Exception { if ( name . equals ( STRING ) ) m in External DTD = BOOL ; if ( ! m expand DTD Entities && ! m in External DTD ) { start Non Escaping ( ) ; characters ( STRING + name + STRING ) ; end Non Escaping ( ) ; } m in Entity Ref = BOOL ; }
public static String left Pad ( String s , int min Length , char filling ) { int ln = s . length ( ) ; if ( min Length <= ln ) { return s ; } String Builder res = new String Builder ( min Length ) ; int dif = min Length - ln ; for ( int i = NUM ; i < dif ; i ++ ) { res . append ( filling ) ; } res . append ( s ) ; return res . to String ( ) ; }
public int number Of Disconnected Groups ( Collection < String > genomes ) { final String [ ] genomes 2 = genomes . to Array ( new String [ genomes . size ( ) ] ) ; final int [ ] connections Matrix = new int [ genomes . size ( ) * genomes . size ( ) ] ; final Hash Set < Integer > group Ids = new Hash Set < > ( ) ; for ( int j = NUM ; j < genomes 2 . length ; j ++ ) { int min = j + NUM ; final String g1 = genomes 2 [ j ] ; for ( int i = NUM ; i < genomes 2 . length ; i ++ ) { final String g2 = genomes 2 [ i ] ; if ( are Related ( g1 , g2 ) ) { connections Matrix [ j * genomes 2 . length + i ] = j + NUM ; for ( int k = NUM ; k < j ; k ++ ) { final int value = connections Matrix [ k * genomes 2 . length + i ] ; if ( value != NUM && value < min ) { min = value ; } } } } for ( int i = NUM ; i < genomes 2 . length ; i ++ ) { if ( connections Matrix [ j * genomes 2 . length + i ] != NUM ) { connections Matrix [ j * genomes 2 . length + i ] = min ; group Ids . add ( min ) ; } } } return group Ids . size ( ) ; }
public int number Of Disconnected Groups ( Collection < String > genomes ) { final String [ ] genomes 2 = genomes . to Array ( new String [ genomes . size ( ) ] ) ; final int [ ] connections Matrix = new int [ genomes . size ( ) * genomes . size ( ) ] ; final Hash Set < Integer > group Ids = new Hash Set < > ( ) ; for ( int j = NUM ; j < genomes 2 . length ; j ++ ) { int min = j + NUM ; final String g1 = genomes 2 [ j ] ; for ( int i = NUM ; i < genomes 2 . length ; i ++ ) { final String g2 = genomes 2 [ i ] ; if ( are Related ( g1 , g2 ) ) { connections Matrix [ j * genomes 2 . length + i ] = j + NUM ; for ( int k = NUM ; k < j ; k ++ ) { final int value = connections Matrix [ k * genomes 2 . length + i ] ; if ( value != NUM && value < min ) { min = value ; } } } } for ( int i = NUM ; i < genomes 2 . length ; i ++ ) { if ( connections Matrix [ j * genomes 2 . length + i ] != NUM ) { connections Matrix [ j * genomes 2 . length + i ] = min ; group Ids . add ( min ) ; } } } return group Ids . size ( ) ; }
public static void flush ( ) { clear Buffer ( ) ; try { out . flush ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
public static Element svg Text ( Document document , double x , double y , String text ) { Element elem = SVG Util . svg Element ( document , SVG Constants . SVG TEXT TAG ) ; SVG Util . set Att ( elem , SVG Constants . SVG X ATTRIBUTE , x ) ; SVG Util . set Att ( elem , SVG Constants . SVG Y ATTRIBUTE , y ) ; elem . set Text Content ( text ) ; return elem ; }
public void add Message Listener ( I Message Listener listener ) { listeners . add ( listener ) ; }
public void add Message Listener ( I Message Listener listener ) { listeners . add ( listener ) ; }
public void add Message Listener ( I Message Listener listener ) { listeners . add ( listener ) ; }
public boolean parse KML File ( File file ) { m Local File = file ; Log . d ( Bonus Pack Helper . LOG TAG , STRING + m Local File . get Absolute Path ( ) ) ; Input Stream stream ; boolean ok ; try { stream = new Buffered Input Stream ( new File Input Stream ( m Local File ) ) ; ok = parse KML Stream ( stream , null ) ; stream . close ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; ok = BOOL ; } return ok ; }
public final Location location For Type ( Class < ? > type , Enum Set < Location Modifier > modifiers ) { return location For Type ( type , modifiers . contains ( Location Modifier . Final ) , modifiers . contains ( Location Modifier . Non Null ) ) ; }
public Collection < Evictable Entry < K , V > > queue ( ) { Set < Evictable Entry < K , V > > cp = new Linked Hash Set < > ( ) ; for ( Holder < K , V > holder : set ) cp . add ( holder . entry ) ; return Collections . unmodifiable Collection ( cp ) ; }
private Open Replicator Manager M Bean create Internal Service ( String service Name ) throws Replicator Exception { logger . info ( STRING + service Name ) ; try { Open Replicator Manager orm = new Open Replicator Manager ( service Name ) ; orm . set Rmi Host ( manager RMI Host ) ; orm . set Rmi Port ( manager RMI Port ) ; orm . set Host Time Zone ( host Time Zone ) ; orm . set Replicator Time Zone ( replicator Time Zone ) ; orm . advertise Internal ( ) ; orm . set Security Info ( this . security Info ) ; return ( Open Replicator Manager M Bean ) orm ; } catch ( Exception e ) { throw new Replicator Exception ( String . format ( STRING , service Name ) , e ) ; } }
private Open Replicator Manager M Bean create Internal Service ( String service Name ) throws Replicator Exception { logger . info ( STRING + service Name ) ; try { Open Replicator Manager orm = new Open Replicator Manager ( service Name ) ; orm . set Rmi Host ( manager RMI Host ) ; orm . set Rmi Port ( manager RMI Port ) ; orm . set Host Time Zone ( host Time Zone ) ; orm . set Replicator Time Zone ( replicator Time Zone ) ; orm . advertise Internal ( ) ; orm . set Security Info ( this . security Info ) ; return ( Open Replicator Manager M Bean ) orm ; } catch ( Exception e ) { throw new Replicator Exception ( String . format ( STRING , service Name ) , e ) ; } }
public boolean contains Attribute ( Object name , Object value ) { return value . equals ( get Attribute ( name ) ) ; }
public boolean contains Attribute ( Object name , Object value ) { return value . equals ( get Attribute ( name ) ) ; }
public static String remove Extension ( String file Name ) { int index = file Name . last Index Of ( STRING ) ; if ( index == - NUM ) { return file Name ; } else { return file Name . substring ( NUM , index ) ; } }
private static void verify Device ( I Device d , long mac , Short vlan , Integer ip , long sw Id , int port ) { assert Not Null ( d ) ; assert Equals ( Mac Address . of ( mac ) , d . get MAC Address ( ) ) ; if ( vlan == null ) assert Array Equals ( new Vlan Vid [ ] { Vlan Vid . of Vlan ( - NUM ) } , d . get Vlan Id ( ) ) ; else assert Array Equals ( new Vlan Vid [ ] { Vlan Vid . of Vlan ( vlan ) } , d . get Vlan Id ( ) ) ; if ( ip == null ) assert Array Equals ( new I Pv 4 Address [ ] { I Pv 4 Address . of ( NUM ) } , d . get I Pv 4 Addresses ( ) ) ; else assert Array Equals ( new I Pv 4 Address [ ] { I Pv 4 Address . of ( ip ) } , d . get I Pv 4 Addresses ( ) ) ; Switch Port expected Ap = new Switch Port ( Datapath Id . of ( sw Id ) , OF Port . of ( port ) ) ; assert Array Equals ( new Switch Port [ ] { expected Ap } , d . get Attachment Points ( ) ) ; }
private static void verify Device ( I Device d , long mac , Short vlan , Integer ip , long sw Id , int port ) { assert Not Null ( d ) ; assert Equals ( Mac Address . of ( mac ) , d . get MAC Address ( ) ) ; if ( vlan == null ) assert Array Equals ( new Vlan Vid [ ] { Vlan Vid . of Vlan ( - NUM ) } , d . get Vlan Id ( ) ) ; else assert Array Equals ( new Vlan Vid [ ] { Vlan Vid . of Vlan ( vlan ) } , d . get Vlan Id ( ) ) ; if ( ip == null ) assert Array Equals ( new I Pv 4 Address [ ] { I Pv 4 Address . of ( NUM ) } , d . get I Pv 4 Addresses ( ) ) ; else assert Array Equals ( new I Pv 4 Address [ ] { I Pv 4 Address . of ( ip ) } , d . get I Pv 4 Addresses ( ) ) ; Switch Port expected Ap = new Switch Port ( Datapath Id . of ( sw Id ) , OF Port . of ( port ) ) ; assert Array Equals ( new Switch Port [ ] { expected Ap } , d . get Attachment Points ( ) ) ; }
protected static void add Line ( Print Writer file , String level , String string ) { log . debug ( string ) ; if ( file != null ) { String [ ] lines = string . split ( NEW LINE ) ; for ( String line : lines ) { print Line ( file , level , line ) ; } } }
public static void update Actor Position ( final Actor actor , final Stage stage , final Vector 2 new Screen Size In Stage Coords ) { if ( actor != null && stage != null ) { actor . set Position ( ( int ) ( ( actor . get X ( ) + actor . get Width ( ) / NUM ) / stage . get Width ( ) * new Screen Size In Stage Coords . x - actor . get Width ( ) / NUM ) , ( int ) ( ( actor . get Y ( ) + actor . get Height ( ) / NUM ) / stage . get Height ( ) * new Screen Size In Stage Coords . y - actor . get Height ( ) / NUM ) ) ; } }
public static void update Actor Position ( final Actor actor , final Stage stage , final Vector 2 new Screen Size In Stage Coords ) { if ( actor != null && stage != null ) { actor . set Position ( ( int ) ( ( actor . get X ( ) + actor . get Width ( ) / NUM ) / stage . get Width ( ) * new Screen Size In Stage Coords . x - actor . get Width ( ) / NUM ) , ( int ) ( ( actor . get Y ( ) + actor . get Height ( ) / NUM ) / stage . get Height ( ) * new Screen Size In Stage Coords . y - actor . get Height ( ) / NUM ) ) ; } }
@ Override public long skip ( long bytes ) { if ( closed ) { throw new Form Item . Item Skipped Exception ( ) ; } int av = available ( ) ; if ( av == NUM ) { av = make Available ( ) ; if ( av == NUM ) { return NUM ; } } long res = Math . min ( av , bytes ) ; head += res ; return res ; }
public void register Biome ( Biome Gen Base biome ) { registered Biomes . add ( biome ) ; }
public static void e ( String tag , String msg , Object ... args ) { if ( s Level > LEVEL ERROR ) { return ; } if ( args . length > NUM ) { msg = String . format ( msg , args ) ; } Log . e ( tag , msg ) ; }
public void select Meta Object ( int index , Pdf Canvas cb ) { Meta Object obj = Meta Objects . get ( index ) ; if ( obj == null ) return ; int style ; switch ( obj . get Type ( ) ) { case Meta Object . META BRUSH : current Brush = ( Meta Brush ) obj ; style = current Brush . get Style ( ) ; if ( style == Meta Brush . BS SOLID ) { Color color = current Brush . get Color ( ) ; cb . set Fill Color ( color ) ; } else if ( style == Meta Brush . BS HATCHED ) { Color color = current Background Color ; cb . set Fill Color ( color ) ; } break ; case Meta Object . META PEN : { current Pen = ( Meta Pen ) obj ; style = current Pen . get Style ( ) ; if ( style != Meta Pen . PS NULL ) { Color color = current Pen . get Color ( ) ; cb . set Stroke Color ( color ) ; cb . set Line Width ( Math . abs ( current Pen . get Pen Width ( ) * scaling X / extent Wx ) ) ; switch ( style ) { case Meta Pen . PS DASH : cb . set Line Dash ( NUM , NUM , NUM ) ; break ; case Meta Pen . PS DASHDOT : cb . write Literal ( STRING ) ; break ; case Meta Pen . PS DASHDOTDOT : cb . write Literal ( STRING ) ; break ; case Meta Pen . PS DOT : cb . set Line Dash ( NUM , NUM ) ; break ; default : cb . set Line Dash ( NUM ) ; break ; } } break ; } case Meta Object . META FONT : { current Font = ( Meta Font ) obj ; break ; } } }
public void select Meta Object ( int index , Pdf Canvas cb ) { Meta Object obj = Meta Objects . get ( index ) ; if ( obj == null ) return ; int style ; switch ( obj . get Type ( ) ) { case Meta Object . META BRUSH : current Brush = ( Meta Brush ) obj ; style = current Brush . get Style ( ) ; if ( style == Meta Brush . BS SOLID ) { Color color = current Brush . get Color ( ) ; cb . set Fill Color ( color ) ; } else if ( style == Meta Brush . BS HATCHED ) { Color color = current Background Color ; cb . set Fill Color ( color ) ; } break ; case Meta Object . META PEN : { current Pen = ( Meta Pen ) obj ; style = current Pen . get Style ( ) ; if ( style != Meta Pen . PS NULL ) { Color color = current Pen . get Color ( ) ; cb . set Stroke Color ( color ) ; cb . set Line Width ( Math . abs ( current Pen . get Pen Width ( ) * scaling X / extent Wx ) ) ; switch ( style ) { case Meta Pen . PS DASH : cb . set Line Dash ( NUM , NUM , NUM ) ; break ; case Meta Pen . PS DASHDOT : cb . write Literal ( STRING ) ; break ; case Meta Pen . PS DASHDOTDOT : cb . write Literal ( STRING ) ; break ; case Meta Pen . PS DOT : cb . set Line Dash ( NUM , NUM ) ; break ; default : cb . set Line Dash ( NUM ) ; break ; } } break ; } case Meta Object . META FONT : { current Font = ( Meta Font ) obj ; break ; } } }
public void select Meta Object ( int index , Pdf Canvas cb ) { Meta Object obj = Meta Objects . get ( index ) ; if ( obj == null ) return ; int style ; switch ( obj . get Type ( ) ) { case Meta Object . META BRUSH : current Brush = ( Meta Brush ) obj ; style = current Brush . get Style ( ) ; if ( style == Meta Brush . BS SOLID ) { Color color = current Brush . get Color ( ) ; cb . set Fill Color ( color ) ; } else if ( style == Meta Brush . BS HATCHED ) { Color color = current Background Color ; cb . set Fill Color ( color ) ; } break ; case Meta Object . META PEN : { current Pen = ( Meta Pen ) obj ; style = current Pen . get Style ( ) ; if ( style != Meta Pen . PS NULL ) { Color color = current Pen . get Color ( ) ; cb . set Stroke Color ( color ) ; cb . set Line Width ( Math . abs ( current Pen . get Pen Width ( ) * scaling X / extent Wx ) ) ; switch ( style ) { case Meta Pen . PS DASH : cb . set Line Dash ( NUM , NUM , NUM ) ; break ; case Meta Pen . PS DASHDOT : cb . write Literal ( STRING ) ; break ; case Meta Pen . PS DASHDOTDOT : cb . write Literal ( STRING ) ; break ; case Meta Pen . PS DOT : cb . set Line Dash ( NUM , NUM ) ; break ; default : cb . set Line Dash ( NUM ) ; break ; } } break ; } case Meta Object . META FONT : { current Font = ( Meta Font ) obj ; break ; } } }
public void focus Gained ( Focus Event e ) { Component c = e . get Component ( ) ; if ( c instanceof J Formatted Text Field ) { select It Later ( c ) ; } }
public void focus Gained ( Focus Event e ) { Component c = e . get Component ( ) ; if ( c instanceof J Formatted Text Field ) { select It Later ( c ) ; } }
public void focus Gained ( Focus Event e ) { Component c = e . get Component ( ) ; if ( c instanceof J Formatted Text Field ) { select It Later ( c ) ; } }
public final void add Tab ( final String title , final J Component component ) { Preconditions . check Not Null ( title , STRING ) ; Preconditions . check Not Null ( component , STRING ) ; m tabbed Pane . add Tab ( title , component ) ; }
String transform Name ( String class Name ) { String new Name = m Rename Classes . get ( class Name ) ; if ( new Name != null ) { return new Name ; } int pos = class Name . index Of ( STRING ) ; if ( pos > NUM ) { String base = class Name . substring ( NUM , pos ) ; new Name = m Rename Classes . get ( base ) ; if ( new Name != null ) { return new Name + class Name . substring ( pos ) ; } } return class Name ; }
String transform Name ( String class Name ) { String new Name = m Rename Classes . get ( class Name ) ; if ( new Name != null ) { return new Name ; } int pos = class Name . index Of ( STRING ) ; if ( pos > NUM ) { String base = class Name . substring ( NUM , pos ) ; new Name = m Rename Classes . get ( base ) ; if ( new Name != null ) { return new Name + class Name . substring ( pos ) ; } } return class Name ; }
String transform Name ( String class Name ) { String new Name = m Rename Classes . get ( class Name ) ; if ( new Name != null ) { return new Name ; } int pos = class Name . index Of ( STRING ) ; if ( pos > NUM ) { String base = class Name . substring ( NUM , pos ) ; new Name = m Rename Classes . get ( base ) ; if ( new Name != null ) { return new Name + class Name . substring ( pos ) ; } } return class Name ; }
public final boolean unify ( final JIP Term term , final Hashtable vars Tbl ) { Hashtable var Table 1 = new Hashtable ( NUM ) ; if ( m obj . unify ( term . m obj , var Table 1 ) ) { Variable var ; Enumeration en = var Table 1 . elements ( ) ; while ( en . has More Elements ( ) ) { var = ( ( Variable ) en . next Element ( ) ) ; vars Tbl . put ( var , new JIP Variable ( var ) ) ; } return BOOL ; } else { return BOOL ; } }
public final boolean unify ( final JIP Term term , final Hashtable vars Tbl ) { Hashtable var Table 1 = new Hashtable ( NUM ) ; if ( m obj . unify ( term . m obj , var Table 1 ) ) { Variable var ; Enumeration en = var Table 1 . elements ( ) ; while ( en . has More Elements ( ) ) { var = ( ( Variable ) en . next Element ( ) ) ; vars Tbl . put ( var , new JIP Variable ( var ) ) ; } return BOOL ; } else { return BOOL ; } }
public final boolean unify ( final JIP Term term , final Hashtable vars Tbl ) { Hashtable var Table 1 = new Hashtable ( NUM ) ; if ( m obj . unify ( term . m obj , var Table 1 ) ) { Variable var ; Enumeration en = var Table 1 . elements ( ) ; while ( en . has More Elements ( ) ) { var = ( ( Variable ) en . next Element ( ) ) ; vars Tbl . put ( var , new JIP Variable ( var ) ) ; } return BOOL ; } else { return BOOL ; } }
public Internal Color Panel Listener ( final I Type Description description ) { m description = description ; }
protected int map Drag Operation From Modifiers ( Mouse Event e ) { int mods = e . get Modifiers Ex ( ) ; int btns = mods & Button Mask ; if ( ! ( btns == Input Event . BUTTON 1 DOWN MASK || btns == Input Event . BUTTON 2 DOWN MASK ) ) { return Dn D Constants . ACTION NONE ; } return Sun Drag Source Context Peer . convert Modifiers To Drop Action ( mods , get Source Actions ( ) ) ; }
@ Before Class public static void delete Indications File ( ) { boolean was Exception = BOOL ; try { String Buffer file Name Buff = new String Buffer ( System . get Property ( File Cim Indication Consumer . WORKING DIR SYSTEM VARIABLE ) ) ; file Name Buff . append ( File . separator ) ; file Name Buff . append ( File Cim Indication Consumer . INDICATIONS FILE NAME ) ; File out File = new File ( file Name Buff . to String ( ) ) ; if ( out File . exists ( ) ) { Assert . assert True ( out File . delete ( ) ) ; Assert . assert False ( out File . exists ( ) ) ; } } catch ( Exception e ) { was Exception = BOOL ; } finally { Assert . assert False ( was Exception ) ; } }
public void compact Buffer ( ) { if ( offset != buffer . length ) { byte [ ] new Buffer = new byte [ offset ] ; System . arraycopy ( buffer , NUM , new Buffer , NUM , offset ) ; buffer = new Buffer ; } }
public void compact Buffer ( ) { if ( offset != buffer . length ) { byte [ ] new Buffer = new byte [ offset ] ; System . arraycopy ( buffer , NUM , new Buffer , NUM , offset ) ; buffer = new Buffer ; } }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
protected static boolean regex Replace ( J Text Area text Area , String to Find , String replace With , boolean forward , boolean match Case , boolean whole Word ) throws Pattern Syntax Exception { Caret c = text Area . get Caret ( ) ; int start = make Mark And Dot Equal ( text Area , forward ) ; String find In = get Find In Text ( text Area , start , forward ) ; if ( find In == null ) return BOOL ; Reg Ex Replace Info info = get Reg Ex Replace Info ( to Find , find In , forward , match Case , whole Word , replace With ) ; find In = null ; if ( info != null ) { c . set Selection Visible ( BOOL ) ; int match Start = info . get Start Index ( ) ; int match End = info . get End Index ( ) ; if ( forward ) { match Start += start ; match End += start ; } select And Possibly Center ( text Area , match Start , match End ) ; text Area . replace Selection ( info . get Replacement ( ) ) ; return BOOL ; } return BOOL ; }
public void delete Alerting Definition ( Alerting Definition alerting Definition ) throws IO Exception { String id = alerting Definition . get Id ( ) ; Alerting Definition local = existing Alerting Definitions . remove ( id ) ; if ( local != null ) { Files . delete If Exists ( path Resolver . get Alerting Definition File Path ( local ) ) ; event Publisher . publish Event ( new Abstract Alerting Definition Event . Alerting Definition Deleted Event ( this , local ) ) ; } }
public T Double Double Hash Map absolute Distribution Log 2 ( double descretization ) { T Double Double Hash Map freq = new T Double Double Hash Map ( ) ; int size = values . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) { double bin = Math . ceil ( Math . log ( values . get ( i ) / descretization ) / Math . log ( NUM ) ) ; bin = Math . max ( bin , NUM ) ; double bin Width = Math . pow ( NUM , bin ) - Math . pow ( NUM , bin - NUM ) ; bin Width = Math . max ( NUM , bin Width ) ; freq . adjust Or Put Value ( Math . pow ( NUM , bin ) * descretization , weights . get ( i ) / bin Width , weights . get ( i ) / bin Width ) ; } return freq ; }
public T Double Double Hash Map absolute Distribution Log 2 ( double descretization ) { T Double Double Hash Map freq = new T Double Double Hash Map ( ) ; int size = values . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) { double bin = Math . ceil ( Math . log ( values . get ( i ) / descretization ) / Math . log ( NUM ) ) ; bin = Math . max ( bin , NUM ) ; double bin Width = Math . pow ( NUM , bin ) - Math . pow ( NUM , bin - NUM ) ; bin Width = Math . max ( NUM , bin Width ) ; freq . adjust Or Put Value ( Math . pow ( NUM , bin ) * descretization , weights . get ( i ) / bin Width , weights . get ( i ) / bin Width ) ; } return freq ; }
public T Double Double Hash Map absolute Distribution Log 2 ( double descretization ) { T Double Double Hash Map freq = new T Double Double Hash Map ( ) ; int size = values . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) { double bin = Math . ceil ( Math . log ( values . get ( i ) / descretization ) / Math . log ( NUM ) ) ; bin = Math . max ( bin , NUM ) ; double bin Width = Math . pow ( NUM , bin ) - Math . pow ( NUM , bin - NUM ) ; bin Width = Math . max ( NUM , bin Width ) ; freq . adjust Or Put Value ( Math . pow ( NUM , bin ) * descretization , weights . get ( i ) / bin Width , weights . get ( i ) / bin Width ) ; } return freq ; }
protected final boolean init ( ) throws Ade Exception { boolean initialized ; final Properties prop = new Properties ( ) ; try ( File Input Stream fis = new File Input Stream ( properties File Name ) ) { prop . load ( fis ) ; initialized = BOOL ; } catch ( File Not Found Exception e ) { throw new Ade Ext Usage Exception ( STRING + properties File Name + STRING , e ) ; } catch ( IO Exception e ) { throw new Ade Ext Usage Exception ( STRING + properties File Name + STRING , e ) ; } catch ( Exception e ) { throw new Ade Ext Usage Exception ( STRING + properties File Name + STRING , e ) ; } return initialized ; }
public void add ( String key , String value ) { keys . add ( key ) ; values . add ( value ) ; }
public static Map < String , Object > update Payment Application ( Dispatch Context dctx , Map < String , Object > context ) { if ( ! context . contains Key ( STRING ) ) { context . put ( STRING , STRING ) ; } Big Decimal amount Applied = ( Big Decimal ) context . get ( STRING ) ; if ( amount Applied != null ) { context . put ( STRING , amount Applied ) ; } else { context . put ( STRING , ZERO ) ; } return update Payment Application Def Bd ( dctx , context ) ; }
public static Map < String , Object > update Payment Application ( Dispatch Context dctx , Map < String , Object > context ) { if ( ! context . contains Key ( STRING ) ) { context . put ( STRING , STRING ) ; } Big Decimal amount Applied = ( Big Decimal ) context . get ( STRING ) ; if ( amount Applied != null ) { context . put ( STRING , amount Applied ) ; } else { context . put ( STRING , ZERO ) ; } return update Payment Application Def Bd ( dctx , context ) ; }
public static Map < String , Object > update Payment Application ( Dispatch Context dctx , Map < String , Object > context ) { if ( ! context . contains Key ( STRING ) ) { context . put ( STRING , STRING ) ; } Big Decimal amount Applied = ( Big Decimal ) context . get ( STRING ) ; if ( amount Applied != null ) { context . put ( STRING , amount Applied ) ; } else { context . put ( STRING , ZERO ) ; } return update Payment Application Def Bd ( dctx , context ) ; }
public static Map < String , Object > update Payment Application ( Dispatch Context dctx , Map < String , Object > context ) { if ( ! context . contains Key ( STRING ) ) { context . put ( STRING , STRING ) ; } Big Decimal amount Applied = ( Big Decimal ) context . get ( STRING ) ; if ( amount Applied != null ) { context . put ( STRING , amount Applied ) ; } else { context . put ( STRING , ZERO ) ; } return update Payment Application Def Bd ( dctx , context ) ; }
public static double coefficient ( double [ ] x , double [ ] y ) { final int xdim = x . length ; final int ydim = y . length ; if ( xdim != ydim ) { throw new Illegal Argument Exception ( STRING ) ; } double sum XX = NUM , sum YY = NUM , sum XY = NUM ; double mean X = x [ NUM ] , mean Y = y [ NUM ] ; int i = NUM ; while ( i < xdim ) { final double xv = x [ i ] , yv = y [ i ] ; final double delta X = xv - mean X ; final double delta Y = yv - mean Y ; ++ i ; mean X += delta X / i ; mean Y += delta Y / i ; final double nelta X = xv - mean X ; final double nelta Y = yv - mean Y ; sum XX += delta X * nelta X ; sum YY += delta Y * nelta Y ; sum XY += delta X * nelta Y ; } if ( ! ( sum XX > NUM && sum YY > NUM ) ) { return ( sum XX == sum YY ) ? NUM : NUM ; } return sum XY / Math . sqrt ( sum XX * sum YY ) ; }
private void paint ( Sea Glass Painter p , Synth Context ctx , Graphics g , int x , int y , int w , int h , Affine Transform transform ) { if ( p != null ) { if ( g instanceof Graphics 2 D ) { Graphics 2 D gfx = ( Graphics 2 D ) g ; if ( transform != null ) { gfx . transform ( transform ) ; } gfx . translate ( x , y ) ; p . paint ( gfx , ctx . get Component ( ) , w , h ) ; gfx . translate ( - x , - y ) ; if ( transform != null ) { try { gfx . transform ( transform . create Inverse ( ) ) ; } catch ( Noninvertible Transform Exception e ) { e . print Stack Trace ( ) ; } } } else { Buffered Image img = new Buffered Image ( w , h , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D gfx = img . create Graphics ( ) ; if ( transform != null ) { gfx . transform ( transform ) ; } p . paint ( gfx , ctx . get Component ( ) , w , h ) ; gfx . dispose ( ) ; g . draw Image ( img , x , y , null ) ; img = null ; } } }
private void paint ( Sea Glass Painter p , Synth Context ctx , Graphics g , int x , int y , int w , int h , Affine Transform transform ) { if ( p != null ) { if ( g instanceof Graphics 2 D ) { Graphics 2 D gfx = ( Graphics 2 D ) g ; if ( transform != null ) { gfx . transform ( transform ) ; } gfx . translate ( x , y ) ; p . paint ( gfx , ctx . get Component ( ) , w , h ) ; gfx . translate ( - x , - y ) ; if ( transform != null ) { try { gfx . transform ( transform . create Inverse ( ) ) ; } catch ( Noninvertible Transform Exception e ) { e . print Stack Trace ( ) ; } } } else { Buffered Image img = new Buffered Image ( w , h , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D gfx = img . create Graphics ( ) ; if ( transform != null ) { gfx . transform ( transform ) ; } p . paint ( gfx , ctx . get Component ( ) , w , h ) ; gfx . dispose ( ) ; g . draw Image ( img , x , y , null ) ; img = null ; } } }
private void paint ( Sea Glass Painter p , Synth Context ctx , Graphics g , int x , int y , int w , int h , Affine Transform transform ) { if ( p != null ) { if ( g instanceof Graphics 2 D ) { Graphics 2 D gfx = ( Graphics 2 D ) g ; if ( transform != null ) { gfx . transform ( transform ) ; } gfx . translate ( x , y ) ; p . paint ( gfx , ctx . get Component ( ) , w , h ) ; gfx . translate ( - x , - y ) ; if ( transform != null ) { try { gfx . transform ( transform . create Inverse ( ) ) ; } catch ( Noninvertible Transform Exception e ) { e . print Stack Trace ( ) ; } } } else { Buffered Image img = new Buffered Image ( w , h , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D gfx = img . create Graphics ( ) ; if ( transform != null ) { gfx . transform ( transform ) ; } p . paint ( gfx , ctx . get Component ( ) , w , h ) ; gfx . dispose ( ) ; g . draw Image ( img , x , y , null ) ; img = null ; } } }
boolean run After ( List tasks , int size ) ;
public static String bind ( String key , Object [ ] args ) { try { return Message Format . format ( bind ( key ) , args ) ; } catch ( Missing Resource Exception e ) { return key ; } catch ( Null Pointer Exception e ) { return STRING + key + STRING ; } }
public static String bind ( String key , Object [ ] args ) { try { return Message Format . format ( bind ( key ) , args ) ; } catch ( Missing Resource Exception e ) { return key ; } catch ( Null Pointer Exception e ) { return STRING + key + STRING ; } }
protected void close Resources ( Connection connection ) { if ( cache Connection ) return ; if ( connection != null && data Source != null ) { try { connection . close ( ) ; } catch ( SQL Exception e ) { LOG . finest ( STRING + e . get Message ( ) + STRING ) ; } } }
protected void close Resources ( Connection connection ) { if ( cache Connection ) return ; if ( connection != null && data Source != null ) { try { connection . close ( ) ; } catch ( SQL Exception e ) { LOG . finest ( STRING + e . get Message ( ) + STRING ) ; } } }
public Class load ( String type ) throws Exception { Class Loader loader = get Class Loader ( ) ; if ( loader == null ) { loader = get Caller Class Loader ( ) ; } return loader . load Class ( type ) ; }
public Class load ( String type ) throws Exception { Class Loader loader = get Class Loader ( ) ; if ( loader == null ) { loader = get Caller Class Loader ( ) ; } return loader . load Class ( type ) ; }
public Class load ( String type ) throws Exception { Class Loader loader = get Class Loader ( ) ; if ( loader == null ) { loader = get Caller Class Loader ( ) ; } return loader . load Class ( type ) ; }
public Class load ( String type ) throws Exception { Class Loader loader = get Class Loader ( ) ; if ( loader == null ) { loader = get Caller Class Loader ( ) ; } return loader . load Class ( type ) ; }
public Class load ( String type ) throws Exception { Class Loader loader = get Class Loader ( ) ; if ( loader == null ) { loader = get Caller Class Loader ( ) ; } return loader . load Class ( type ) ; }
public Class load ( String type ) throws Exception { Class Loader loader = get Class Loader ( ) ; if ( loader == null ) { loader = get Caller Class Loader ( ) ; } return loader . load Class ( type ) ; }
public Class load ( String type ) throws Exception { Class Loader loader = get Class Loader ( ) ; if ( loader == null ) { loader = get Caller Class Loader ( ) ; } return loader . load Class ( type ) ; }
public Class load ( String type ) throws Exception { Class Loader loader = get Class Loader ( ) ; if ( loader == null ) { loader = get Caller Class Loader ( ) ; } return loader . load Class ( type ) ; }
public List < String > compact Attribute Value ( String value , int start ) { List < String > result = new Array List < String > ( ) ; if ( start > value . length ( ) ) { result . add ( value ) ; return result ; } Wb Xml Attribute Value Def value Def = new Wb Xml Attribute Value Def ( value . substring ( start ) , ( byte ) NUM , ( byte ) NUM ) ; for ( Wb Xml Attribute Value Def attr Val : attr Values By Value . tail Set ( value Def ) ) { List < String > found = matches ( value , attr Val . get Value ( ) , start , BOOL ) ; if ( found != null ) { return found ; } } result . add ( value ) ; return result ; }
public List < String > compact Attribute Value ( String value , int start ) { List < String > result = new Array List < String > ( ) ; if ( start > value . length ( ) ) { result . add ( value ) ; return result ; } Wb Xml Attribute Value Def value Def = new Wb Xml Attribute Value Def ( value . substring ( start ) , ( byte ) NUM , ( byte ) NUM ) ; for ( Wb Xml Attribute Value Def attr Val : attr Values By Value . tail Set ( value Def ) ) { List < String > found = matches ( value , attr Val . get Value ( ) , start , BOOL ) ; if ( found != null ) { return found ; } } result . add ( value ) ; return result ; }
public List < String > compact Attribute Value ( String value , int start ) { List < String > result = new Array List < String > ( ) ; if ( start > value . length ( ) ) { result . add ( value ) ; return result ; } Wb Xml Attribute Value Def value Def = new Wb Xml Attribute Value Def ( value . substring ( start ) , ( byte ) NUM , ( byte ) NUM ) ; for ( Wb Xml Attribute Value Def attr Val : attr Values By Value . tail Set ( value Def ) ) { List < String > found = matches ( value , attr Val . get Value ( ) , start , BOOL ) ; if ( found != null ) { return found ; } } result . add ( value ) ; return result ; }
public List < String > compact Attribute Value ( String value , int start ) { List < String > result = new Array List < String > ( ) ; if ( start > value . length ( ) ) { result . add ( value ) ; return result ; } Wb Xml Attribute Value Def value Def = new Wb Xml Attribute Value Def ( value . substring ( start ) , ( byte ) NUM , ( byte ) NUM ) ; for ( Wb Xml Attribute Value Def attr Val : attr Values By Value . tail Set ( value Def ) ) { List < String > found = matches ( value , attr Val . get Value ( ) , start , BOOL ) ; if ( found != null ) { return found ; } } result . add ( value ) ; return result ; }
public static int receive Char ( ) throws IO Exception { log . trace ( String . format ( STRING ) ) ; int result = receive Char ( serial Port Descriptor ) ; if ( result < NUM ) { throw new IO Exception ( String . format ( STRING , result ) ) ; } return result ; }
private boolean remove Activity ( Activity a ) { boolean r ; synchronized ( this ) { r = m activities . remove ( a ) ; if ( r ) { if ( m activities . size ( ) == NUM ) { m next Time = Long . MAX VALUE ; } } } if ( r ) { a . set Scheduled ( BOOL ) ; } return r ; }
private boolean remove Activity ( Activity a ) { boolean r ; synchronized ( this ) { r = m activities . remove ( a ) ; if ( r ) { if ( m activities . size ( ) == NUM ) { m next Time = Long . MAX VALUE ; } } } if ( r ) { a . set Scheduled ( BOOL ) ; } return r ; }
private boolean remove Activity ( Activity a ) { boolean r ; synchronized ( this ) { r = m activities . remove ( a ) ; if ( r ) { if ( m activities . size ( ) == NUM ) { m next Time = Long . MAX VALUE ; } } } if ( r ) { a . set Scheduled ( BOOL ) ; } return r ; }
private boolean remove Activity ( Activity a ) { boolean r ; synchronized ( this ) { r = m activities . remove ( a ) ; if ( r ) { if ( m activities . size ( ) == NUM ) { m next Time = Long . MAX VALUE ; } } } if ( r ) { a . set Scheduled ( BOOL ) ; } return r ; }
private boolean remove Activity ( Activity a ) { boolean r ; synchronized ( this ) { r = m activities . remove ( a ) ; if ( r ) { if ( m activities . size ( ) == NUM ) { m next Time = Long . MAX VALUE ; } } } if ( r ) { a . set Scheduled ( BOOL ) ; } return r ; }
protected final void resolve Issue ( Health Issue health Issue ) { Event Bus event Bus ; boolean was Issue Active ; synchronized ( m Lock ) { if ( m Health Event Bus == null ) { LOG . w ( STRING + STRING , health Issue . to String ( ) ) ; return ; } event Bus = m Health Event Bus ; was Issue Active = m Active Issues . remove ( health Issue ) ; } if ( was Issue Active ) { event Bus . post ( health Issue . resolved ) ; } }
protected final void resolve Issue ( Health Issue health Issue ) { Event Bus event Bus ; boolean was Issue Active ; synchronized ( m Lock ) { if ( m Health Event Bus == null ) { LOG . w ( STRING + STRING , health Issue . to String ( ) ) ; return ; } event Bus = m Health Event Bus ; was Issue Active = m Active Issues . remove ( health Issue ) ; } if ( was Issue Active ) { event Bus . post ( health Issue . resolved ) ; } }
public void release External Resources ( ) { if ( ! is Closed . get ( ) ) { logger . info ( STRING ) ; Actor Config . shut Down Actor System Force ( ) ; http Client Store . shutdown ( ) ; tcp Ssh Ping Resource Store . shutdown ( ) ; task Manager . clean Wait Task Queue ( ) ; task Manager . clean Inprogress Job Map ( ) ; is Closed . set ( BOOL ) ; logger . info ( STRING + STRING + STRING ) ; } else { logger . debug ( STRING ) ; } }
public void release External Resources ( ) { if ( ! is Closed . get ( ) ) { logger . info ( STRING ) ; Actor Config . shut Down Actor System Force ( ) ; http Client Store . shutdown ( ) ; tcp Ssh Ping Resource Store . shutdown ( ) ; task Manager . clean Wait Task Queue ( ) ; task Manager . clean Inprogress Job Map ( ) ; is Closed . set ( BOOL ) ; logger . info ( STRING + STRING + STRING ) ; } else { logger . debug ( STRING ) ; } }
public void release External Resources ( ) { if ( ! is Closed . get ( ) ) { logger . info ( STRING ) ; Actor Config . shut Down Actor System Force ( ) ; http Client Store . shutdown ( ) ; tcp Ssh Ping Resource Store . shutdown ( ) ; task Manager . clean Wait Task Queue ( ) ; task Manager . clean Inprogress Job Map ( ) ; is Closed . set ( BOOL ) ; logger . info ( STRING + STRING + STRING ) ; } else { logger . debug ( STRING ) ; } }
public void release External Resources ( ) { if ( ! is Closed . get ( ) ) { logger . info ( STRING ) ; Actor Config . shut Down Actor System Force ( ) ; http Client Store . shutdown ( ) ; tcp Ssh Ping Resource Store . shutdown ( ) ; task Manager . clean Wait Task Queue ( ) ; task Manager . clean Inprogress Job Map ( ) ; is Closed . set ( BOOL ) ; logger . info ( STRING + STRING + STRING ) ; } else { logger . debug ( STRING ) ; } }
public Fibonacci Heap ( ) { }
public Fibonacci Heap ( ) { }
private void check If Update ( int column Index ) { if ( ! old Duplicate Name Column . equals ( duplicate Name Column ) || ! old Duplicate Role Column . equals ( duplicate Role Column ) ) { Set < Integer > columns Update = new Hash Set < Integer > ( ) ; columns Update . add All ( old Duplicate Name Column ) ; columns Update . add All ( duplicate Name Column ) ; columns Update . add All ( old Duplicate Role Column ) ; columns Update . add All ( duplicate Role Column ) ; fire Update ( columns Update ) ; } else if ( ! old Column Error List . equals ( column Error List ) || parsing Error Affected Columns . contains ( column Index ) ) { fire Update ( ) ; } }
private void check If Update ( int column Index ) { if ( ! old Duplicate Name Column . equals ( duplicate Name Column ) || ! old Duplicate Role Column . equals ( duplicate Role Column ) ) { Set < Integer > columns Update = new Hash Set < Integer > ( ) ; columns Update . add All ( old Duplicate Name Column ) ; columns Update . add All ( duplicate Name Column ) ; columns Update . add All ( old Duplicate Role Column ) ; columns Update . add All ( duplicate Role Column ) ; fire Update ( columns Update ) ; } else if ( ! old Column Error List . equals ( column Error List ) || parsing Error Affected Columns . contains ( column Index ) ) { fire Update ( ) ; } }
protected Array < Actor > parse ( ) { actors = Gdx Arrays . new Array ( Actor . class ) ; invoke Pre Listeners ( actors ) ; final String Builder builder = new String Builder ( ) ; while ( template Reader . has Next Character ( ) ) { final char character = template Reader . next Character ( ) ; if ( character == syntax . get Argument Opening ( ) ) { process Argument ( ) ; } else if ( character == syntax . get Tag Opening ( ) ) { if ( is Next Character Comment Opening ( ) ) { process Comment ( ) ; continue ; } if ( current Parent Tag != null ) { current Parent Tag . handle Data Between Tags ( builder ) ; } Strings . clear Builder ( builder ) ; process Tag ( builder ) ; } else { builder . append ( character ) ; } } if ( current Parent Tag != null ) { throw Error ( STRING + current Parent Tag . get Tag Name ( ) + STRING ) ; } invoke Port Listeners ( actors ) ; return actors ; }
private void attach To Root ( ) { Wait For Async Utils . wait For Async Fx ( NUM , null ) ; Wait For Async Utils . wait For Fx Events ( ) ; }
private void attach To Root ( ) { Wait For Async Utils . wait For Async Fx ( NUM , null ) ; Wait For Async Utils . wait For Fx Events ( ) ; }
private void attach To Root ( ) { Wait For Async Utils . wait For Async Fx ( NUM , null ) ; Wait For Async Utils . wait For Fx Events ( ) ; }
public static void sort ( byte [ ] array , int start , int end ) { Dual Pivot Quicksort . sort ( array , start , end ) ; }
public final Flux < T > sample ( Duration timespan ) { return sample Millis ( timespan . to Millis ( ) ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { check Is In Multi Or Pipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . get Bulk Reply ( ) ; return Double . value Of ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { check Is In Multi Or Pipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . get Bulk Reply ( ) ; return Double . value Of ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { check Is In Multi Or Pipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . get Bulk Reply ( ) ; return Double . value Of ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { check Is In Multi Or Pipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . get Bulk Reply ( ) ; return Double . value Of ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { check Is In Multi Or Pipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . get Bulk Reply ( ) ; return Double . value Of ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { check Is In Multi Or Pipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . get Bulk Reply ( ) ; return Double . value Of ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { check Is In Multi Or Pipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . get Bulk Reply ( ) ; return Double . value Of ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { check Is In Multi Or Pipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . get Bulk Reply ( ) ; return Double . value Of ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { check Is In Multi Or Pipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . get Bulk Reply ( ) ; return Double . value Of ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { check Is In Multi Or Pipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . get Bulk Reply ( ) ; return Double . value Of ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { check Is In Multi Or Pipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . get Bulk Reply ( ) ; return Double . value Of ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { check Is In Multi Or Pipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . get Bulk Reply ( ) ; return Double . value Of ( newscore ) ; }
private void check Or Mark Private Access ( Expression source , Method Node mn ) { if ( mn == null ) { return ; } Class Node declaring Class = mn . get Declaring Class ( ) ; Class Node enclosing Class Node = type Checking Context . get Enclosing Class Node ( ) ; if ( declaring Class != enclosing Class Node || type Checking Context . get Enclosing Closure ( ) != null ) { int mods = mn . get Modifiers ( ) ; boolean same Module = declaring Class . get Module ( ) == enclosing Class Node . get Module ( ) ; String package Name = declaring Class . get Package Name ( ) ; if ( package Name == null ) { package Name = STRING ; } if ( ( Modifier . is Private ( mods ) && same Module ) ) { add Private Field Or Method Access ( source , declaring Class , Static Types Marker . PV METHODS ACCESS , mn ) ; } else if ( Modifier . is Protected ( mods ) && ! package Name . equals ( enclosing Class Node . get Package Name ( ) ) && ! implements Interface Or Is Subclass Of ( enclosing Class Node , declaring Class ) ) { Class Node cn = enclosing Class Node ; while ( ( cn = cn . get Outer Class ( ) ) != null ) { if ( implements Interface Or Is Subclass Of ( cn , declaring Class ) ) { add Private Field Or Method Access ( source , cn , Static Types Marker . PV METHODS ACCESS , mn ) ; break ; } } } } }
protected void draw Image ( Graphics g , Object native Graphics , int x , int y ) { g . draw Image ( image , x , y , transform ) ; }
protected void draw Image ( Graphics g , Object native Graphics , int x , int y ) { g . draw Image ( image , x , y , transform ) ; }
protected void draw Image ( Graphics g , Object native Graphics , int x , int y ) { g . draw Image ( image , x , y , transform ) ; }
protected void draw Image ( Graphics g , Object native Graphics , int x , int y ) { g . draw Image ( image , x , y , transform ) ; }
private void add Source Code Remark ( Test Solution test Solution , Element element , String message , String default Lang , String current Lang , String detected Lang , String tested Text ) { if ( test Solution . equals ( Test Solution . PASSED ) || String Utils . is Blank ( message ) ) { return ; } List < Evidence Element > evidence Element List = new Array List < > ( ) ; if ( String Utils . is Not Blank ( current Lang ) ) { evidence Element List . add ( get Evidence Element ( DEFAULT LANGUAGE EE , default Lang ) ) ; evidence Element List . add ( get Evidence Element ( CURRENT LANGUAGE EE , current Lang ) ) ; } else { evidence Element List . add ( get Evidence Element ( LANGUAGE EE , default Lang ) ) ; } evidence Element List . add ( get Evidence Element ( DETECTED LANGUAGE EE , detected Lang ) ) ; if ( tested Text . length ( ) > DISPLAYABLE TEXT SIZE ) { tested Text = tested Text . substring ( NUM , DISPLAYABLE TEXT SIZE ) ; } evidence Element List . add ( get Evidence Element ( EXTRACTED TEXT EE , tested Text ) ) ; add Source Code Remark ( test Solution , element , message , evidence Element List ) ; }
public static < T > Completable Future < T > wait For All ( List < Completable Future < T > > futures ) { if ( futures . is Empty ( ) ) { return Completable Future . completed Future ( null ) ; } final Completable Future < T > composite Future = new Completable Future < > ( ) ; final Atomic Integer count = new Atomic Integer ( futures . size ( ) ) ; final Atomic Reference < Throwable > exception = new Atomic Reference < > ( ) ; for ( Completable Future < T > future : futures ) { future . when Complete ( null ) ; } return composite Future ; }
boolean stitch Initializer ( Type Declaration d ) { final Virtual File f = compiler . get Stitched File ( d , STRING ) ; if ( f != null && f . exists ( ) ) { jsout . output File ( f ) ; return BOOL ; } return BOOL ; }
boolean stitch Initializer ( Type Declaration d ) { final Virtual File f = compiler . get Stitched File ( d , STRING ) ; if ( f != null && f . exists ( ) ) { jsout . output File ( f ) ; return BOOL ; } return BOOL ; }
public void test Constructor Sign Bytes Negative 5 ( ) { byte a Bytes [ ] = { - NUM , NUM , NUM , - NUM } ; int a Sign = - NUM ; byte r Bytes [ ] = { - NUM , NUM , - NUM , - NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , a Number . signum ( ) ) ; }
private void create License Object ( List < License Info Ext > license Info Exts , License license ) { if ( license Info Exts . is Empty ( ) ) { return ; } for ( License Info Ext license Ext : license Info Exts ) { License Feature license Feature = create License Feature From License Info Ext ( license Ext ) ; license . add License Feature ( license Feature ) ; } }
public Calculable ( String id , double value ) { set Id ( id ) ; set Value ( value ) ; set When ( System . current Time Millis ( ) ) ; }
public Calculable ( String id , double value ) { set Id ( id ) ; set Value ( value ) ; set When ( System . current Time Millis ( ) ) ; }
public void remove Workspace Component Listener ( final Workspace Component Listener listener ) { workspace Component Listeners . remove ( listener ) ; }
private void calculate And Set Signed Mutual Information ( int i , int j , double [ ] [ ] joint Probabilities ) { joint Probabilities [ NUM ] [ NUM ] = ( double ) Math . round ( m Co Occurrences And Mi Matrix . get ( i , j ) ) / m total Num Intervals ; joint Probabilities [ NUM ] [ NUM ] = ( double ) Math . round ( m Co Occurrences And Mi Matrix . get ( i , i ) - m Co Occurrences And Mi Matrix . get ( i , j ) ) / m total Num Intervals ; joint Probabilities [ NUM ] [ NUM ] = ( double ) Math . round ( m Co Occurrences And Mi Matrix . get ( j , j ) - m Co Occurrences And Mi Matrix . get ( i , j ) ) / m total Num Intervals ; joint Probabilities [ NUM ] [ NUM ] = ( double ) Math . round ( m total Num Intervals - m Co Occurrences And Mi Matrix . get ( i , i ) - m Co Occurrences And Mi Matrix . get ( j , j ) + m Co Occurrences And Mi Matrix . get ( i , j ) ) / m total Num Intervals ; final double mi = calculate Sign ( joint Probabilities ) * calculate Mutual Information ( joint Probabilities ) ; m Co Occurrences And Mi Matrix . set ( i , j , mi ) ; }
public void draw String ( String str , float x , float y ) { m Graphics . draw String ( str , x , y ) ; }
public void expect Server Proxy Failed ( Message Info message Info ) { expected Api Calls . add ( new Api Call ( SERVER PROXY FAILED , new Object [ ] { message Info . get Origin ( ) , message Info . get Client ( ) , message Info . get Service ( ) } ) ) ; }
public final Text Builder append ( char chars [ ] , int offset , int length ) { final int end = offset + length ; if ( ( offset < NUM ) || ( length < NUM ) || ( end > chars . length ) ) throw new Index Out Of Bounds Exception ( ) ; int new Length = length + length ; while ( capacity < new Length ) { increase Capacity ( ) ; } for ( int i = offset , j = length ; i < end ; ) { char [ ] dst Chars = high [ j > > B1 ] ; int dst Begin = j & M1 ; int inc = Math Lib . min ( C1 - dst Begin , end - i ) ; System . arraycopy ( chars , i , dst Chars , dst Begin , inc ) ; i += inc ; j += inc ; } length = new Length ; return this ; }
public static float [ ] concat All Float ( float [ ] ... arrays ) { int total Length = NUM ; final int sub Array Count = arrays . length ; for ( int i = NUM ; i < sub Array Count ; ++ i ) { total Length += arrays [ i ] . length ; } float [ ] result = Arrays . copy Of ( arrays [ NUM ] , total Length ) ; int offset = arrays [ NUM ] . length ; for ( int i = NUM ; i < sub Array Count ; ++ i ) { System . arraycopy ( arrays [ i ] , NUM , result , offset , arrays [ i ] . length ) ; offset += arrays [ i ] . length ; } return result ; }
public static void register Dynamic Type Converter ( Java Dynamic Type Converter the Converter ) { if ( ! m dyn Converters . contains ( the Converter ) ) { m dyn Converters . add Element ( the Converter ) ; } }
public Named Column Projection ( String [ ] names , boolean include ) { m names = new Hash Set ( ) ; for ( int i = NUM ; i < names . length ; ++ i ) m names . add ( names [ i ] ) ; m include = include ; }
private Automaton deletions Of ( String s ) { List < Automaton > list = new Array List < > ( ) ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { Automaton a = Automata . make String ( s . substring ( NUM , i ) ) ; a = Operations . concatenate ( a , Automata . make String ( s . substring ( i + NUM ) ) ) ; list . add ( a ) ; } Automaton a = Operations . union ( list ) ; a = Minimization Operations . minimize ( a , DEFAULT MAX DETERMINIZED STATES ) ; return a ; }
private Automaton deletions Of ( String s ) { List < Automaton > list = new Array List < > ( ) ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { Automaton a = Automata . make String ( s . substring ( NUM , i ) ) ; a = Operations . concatenate ( a , Automata . make String ( s . substring ( i + NUM ) ) ) ; list . add ( a ) ; } Automaton a = Operations . union ( list ) ; a = Minimization Operations . minimize ( a , DEFAULT MAX DETERMINIZED STATES ) ; return a ; }
public void run ( int k , String kstr ) ;
public static I Status validate Qualified Module Name ( String qualified Name ) { String pckg = Signature . get Qualifier ( qualified Name ) ; if ( ! Util . is Valid Package Name ( pckg ) ) { return Util . new Error Status ( STRING ) ; } return validate Simple Module Name ( Signature . get Simple Name ( qualified Name ) ) ; }
protected Layer Pane find Selected Pane ( ) { for ( Layer Pane pane : get Panes ( ) ) { if ( pane . is Selected ( ) ) { return pane ; } } return null ; }
public Set < String > find ( T object ) { if ( ! locations . contains Key ( object ) ) { locations . put ( object , new Hash Set < > ( ) ) ; } return Collections . unmodifiable Set ( locations . get ( object ) ) ; }
@ Override public void disconnect ( ) throws IO Exception { client Cache . close ( ) ; }
@ Override public void disconnect ( ) throws IO Exception { client Cache . close ( ) ; }
private void create Edit Mode View ( Context context ) { String [ ] entries = new String [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { entries [ i ] = STRING + i ; } List < String > entries List = Arrays . as List ( entries ) ; m Picker UI Adapter = new Picker UI Adapter ( context , R . layout . pickerui item , entries List , entries List . size ( ) / NUM , BOOL , BOOL ) ; set Adapter ( m Picker UI Adapter ) ; set Selection ( entries List . size ( ) / NUM ) ; }
private void create Edit Mode View ( Context context ) { String [ ] entries = new String [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { entries [ i ] = STRING + i ; } List < String > entries List = Arrays . as List ( entries ) ; m Picker UI Adapter = new Picker UI Adapter ( context , R . layout . pickerui item , entries List , entries List . size ( ) / NUM , BOOL , BOOL ) ; set Adapter ( m Picker UI Adapter ) ; set Selection ( entries List . size ( ) / NUM ) ; }
private void create Edit Mode View ( Context context ) { String [ ] entries = new String [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { entries [ i ] = STRING + i ; } List < String > entries List = Arrays . as List ( entries ) ; m Picker UI Adapter = new Picker UI Adapter ( context , R . layout . pickerui item , entries List , entries List . size ( ) / NUM , BOOL , BOOL ) ; set Adapter ( m Picker UI Adapter ) ; set Selection ( entries List . size ( ) / NUM ) ; }
private void create Edit Mode View ( Context context ) { String [ ] entries = new String [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { entries [ i ] = STRING + i ; } List < String > entries List = Arrays . as List ( entries ) ; m Picker UI Adapter = new Picker UI Adapter ( context , R . layout . pickerui item , entries List , entries List . size ( ) / NUM , BOOL , BOOL ) ; set Adapter ( m Picker UI Adapter ) ; set Selection ( entries List . size ( ) / NUM ) ; }
private void create Edit Mode View ( Context context ) { String [ ] entries = new String [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { entries [ i ] = STRING + i ; } List < String > entries List = Arrays . as List ( entries ) ; m Picker UI Adapter = new Picker UI Adapter ( context , R . layout . pickerui item , entries List , entries List . size ( ) / NUM , BOOL , BOOL ) ; set Adapter ( m Picker UI Adapter ) ; set Selection ( entries List . size ( ) / NUM ) ; }
private void create Edit Mode View ( Context context ) { String [ ] entries = new String [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { entries [ i ] = STRING + i ; } List < String > entries List = Arrays . as List ( entries ) ; m Picker UI Adapter = new Picker UI Adapter ( context , R . layout . pickerui item , entries List , entries List . size ( ) / NUM , BOOL , BOOL ) ; set Adapter ( m Picker UI Adapter ) ; set Selection ( entries List . size ( ) / NUM ) ; }
public void register Font Metrics ( String name , Font font , float line Height ) { Html Font Metrics metrics = get Font Metrics ( font ) ; font Metrics . put ( font , new Html Font Metrics ( font , line Height , metrics . emwidth ) ) ; }
public void register Font Metrics ( String name , Font font , float line Height ) { Html Font Metrics metrics = get Font Metrics ( font ) ; font Metrics . put ( font , new Html Font Metrics ( font , line Height , metrics . emwidth ) ) ; }
public void register Font Metrics ( String name , Font font , float line Height ) { Html Font Metrics metrics = get Font Metrics ( font ) ; font Metrics . put ( font , new Html Font Metrics ( font , line Height , metrics . emwidth ) ) ; }
public void register Font Metrics ( String name , Font font , float line Height ) { Html Font Metrics metrics = get Font Metrics ( font ) ; font Metrics . put ( font , new Html Font Metrics ( font , line Height , metrics . emwidth ) ) ; }
public void register Font Metrics ( String name , Font font , float line Height ) { Html Font Metrics metrics = get Font Metrics ( font ) ; font Metrics . put ( font , new Html Font Metrics ( font , line Height , metrics . emwidth ) ) ; }
public void register Font Metrics ( String name , Font font , float line Height ) { Html Font Metrics metrics = get Font Metrics ( font ) ; font Metrics . put ( font , new Html Font Metrics ( font , line Height , metrics . emwidth ) ) ; }
public static byte [ ] multiple ( byte [ ] src Bytes , int multi Num ) { if ( multi Num <= NUM ) { return new byte [ NUM ] ; } byte [ ] result = new byte [ src Bytes . length * multi Num ] ; for ( int i = NUM ; i < multi Num ; i ++ ) { System . arraycopy ( src Bytes , NUM , result , i * src Bytes . length , src Bytes . length ) ; } return result ; }
public static byte [ ] multiple ( byte [ ] src Bytes , int multi Num ) { if ( multi Num <= NUM ) { return new byte [ NUM ] ; } byte [ ] result = new byte [ src Bytes . length * multi Num ] ; for ( int i = NUM ; i < multi Num ; i ++ ) { System . arraycopy ( src Bytes , NUM , result , i * src Bytes . length , src Bytes . length ) ; } return result ; }
public void save Domain ( ) { save Domain ( editor Tab . get Shown File ( ) ) ; system . refresh Domain ( ) ; }
public static int find Nonwhitespace Character ( String s , int index ) { int s Length = s . length ( ) ; while ( index < s Length && Character . is Whitespace ( s . char At ( index ) ) ) { index ++ ; } return index ; }
public static int find Nonwhitespace Character ( String s , int index ) { int s Length = s . length ( ) ; while ( index < s Length && Character . is Whitespace ( s . char At ( index ) ) ) { index ++ ; } return index ; }
public static int find Nonwhitespace Character ( String s , int index ) { int s Length = s . length ( ) ; while ( index < s Length && Character . is Whitespace ( s . char At ( index ) ) ) { index ++ ; } return index ; }
private void array Fill ( Node t , Node Info [ ] l , Edge Info [ ] k ) { if ( t == null || l == null ) { System . exit ( NUM ) ; } Edge e ; Node r , s ; l [ NUM ] = new Node Info ( ) ; l [ NUM ] . m node = t ; l [ NUM ] . m parent = - NUM ; l [ NUM ] . m change = BOOL ; int floater ; int free space = NUM ; double height = t . get Top ( ) ; for ( floater = NUM ; floater < free space ; floater ++ ) { r = l [ floater ] . m node ; for ( int noa = NUM ; ( e = r . get Child ( noa ) ) != null ; noa ++ ) { s = e . get Target ( ) ; l [ free space ] = new Node Info ( ) ; l [ free space ] . m node = s ; l [ free space ] . m parent = free space - NUM ; k [ free space - NUM ] = new Edge Info ( ) ; k [ free space - NUM ] . m edge = e ; k [ free space - NUM ] . m parent = floater ; k [ free space - NUM ] . m child = free space ; if ( height != s . get Top ( ) ) { l [ free space ] . m change = BOOL ; height = s . get Top ( ) ; } else { l [ free space ] . m change = BOOL ; } free space ++ ; } } }
private void array Fill ( Node t , Node Info [ ] l , Edge Info [ ] k ) { if ( t == null || l == null ) { System . exit ( NUM ) ; } Edge e ; Node r , s ; l [ NUM ] = new Node Info ( ) ; l [ NUM ] . m node = t ; l [ NUM ] . m parent = - NUM ; l [ NUM ] . m change = BOOL ; int floater ; int free space = NUM ; double height = t . get Top ( ) ; for ( floater = NUM ; floater < free space ; floater ++ ) { r = l [ floater ] . m node ; for ( int noa = NUM ; ( e = r . get Child ( noa ) ) != null ; noa ++ ) { s = e . get Target ( ) ; l [ free space ] = new Node Info ( ) ; l [ free space ] . m node = s ; l [ free space ] . m parent = free space - NUM ; k [ free space - NUM ] = new Edge Info ( ) ; k [ free space - NUM ] . m edge = e ; k [ free space - NUM ] . m parent = floater ; k [ free space - NUM ] . m child = free space ; if ( height != s . get Top ( ) ) { l [ free space ] . m change = BOOL ; height = s . get Top ( ) ; } else { l [ free space ] . m change = BOOL ; } free space ++ ; } } }
private static Create Disks Response check Create Disks Response ( Create Disks Response create Disks Response ) throws Rpc Exception { logger . info ( STRING , create Disks Response ) ; switch ( create Disks Response . get Result ( ) ) { case OK : break ; case INVALID RESERVATION : throw new Invalid Reservation Exception ( create Disks Response . get Error ( ) ) ; case SYSTEM ERROR : throw new System Error Exception ( create Disks Response . get Error ( ) ) ; default : throw new Rpc Exception ( String . format ( STRING , create Disks Response . get Result ( ) ) ) ; } return create Disks Response ; }
private static void check Permission ( ) { Security Manager security = System . get Security Manager ( ) ; if ( security != null ) security . check Permission ( modify Thread Permission ) ; }
private static void check Permission ( ) { Security Manager security = System . get Security Manager ( ) ; if ( security != null ) security . check Permission ( modify Thread Permission ) ; }
private static void check Permission ( ) { Security Manager security = System . get Security Manager ( ) ; if ( security != null ) security . check Permission ( modify Thread Permission ) ; }
public Web Service Proxy ( URL server URL , Executor Service executor Service ) { this ( server URL , executor Service , NUM , NUM ) ; }
private static String pad String ( String s , Align alignment , int min Length ) { if ( alignment == Align . Left ) { return pad Right ( s , min Length ) ; } else if ( alignment == Align . Right ) { return pad Left ( s , min Length ) ; } else { throw new Index Out Of Bounds Exception ( STRING ) ; } }
public static boolean is All Indices ( List < String > aliases Or Indices ) { return aliases Or Indices == null || aliases Or Indices . is Empty ( ) || is Explicit All Pattern ( aliases Or Indices ) ; }
public static boolean is All Indices ( List < String > aliases Or Indices ) { return aliases Or Indices == null || aliases Or Indices . is Empty ( ) || is Explicit All Pattern ( aliases Or Indices ) ; }
public static long abs ( Long number ) { return Math . abs ( number . long Value ( ) ) ; }
private void configure Button ( J Button button ) { Font button Font = ( Font ) Default Lookup . get ( option Pane , this , STRING ) ; if ( button Font != null ) { button . set Font ( button Font ) ; } }
private void configure Button ( J Button button ) { Font button Font = ( Font ) Default Lookup . get ( option Pane , this , STRING ) ; if ( button Font != null ) { button . set Font ( button Font ) ; } }
public Mini Solr Cloud Cluster ( int num Servers , Path base Dir , Jetty Config jetty Config ) throws Exception { this ( num Servers , base Dir , DEFAULT CLOUD SOLR XML , jetty Config , null ) ; }
private void cancel Previous Web Rtc Notifications ( ) { Set < String > notification Ids = m Shared Preferences . get String Set ( MEDIA NOTIFICATION IDS , null ) ; if ( notification Ids == null ) return ; Iterator < String > iterator = notification Ids . iterator ( ) ; while ( iterator . has Next ( ) ) { m Notification Manager . cancel ( NOTIFICATION NAMESPACE , Integer . parse Int ( iterator . next ( ) ) ) ; } Shared Preferences . Editor shared Preference Editor = m Shared Preferences . edit ( ) ; shared Preference Editor . remove ( Media Notification Service . MEDIA NOTIFICATION IDS ) ; shared Preference Editor . apply ( ) ; }
private void cancel Previous Web Rtc Notifications ( ) { Set < String > notification Ids = m Shared Preferences . get String Set ( MEDIA NOTIFICATION IDS , null ) ; if ( notification Ids == null ) return ; Iterator < String > iterator = notification Ids . iterator ( ) ; while ( iterator . has Next ( ) ) { m Notification Manager . cancel ( NOTIFICATION NAMESPACE , Integer . parse Int ( iterator . next ( ) ) ) ; } Shared Preferences . Editor shared Preference Editor = m Shared Preferences . edit ( ) ; shared Preference Editor . remove ( Media Notification Service . MEDIA NOTIFICATION IDS ) ; shared Preference Editor . apply ( ) ; }
private void cancel Previous Web Rtc Notifications ( ) { Set < String > notification Ids = m Shared Preferences . get String Set ( MEDIA NOTIFICATION IDS , null ) ; if ( notification Ids == null ) return ; Iterator < String > iterator = notification Ids . iterator ( ) ; while ( iterator . has Next ( ) ) { m Notification Manager . cancel ( NOTIFICATION NAMESPACE , Integer . parse Int ( iterator . next ( ) ) ) ; } Shared Preferences . Editor shared Preference Editor = m Shared Preferences . edit ( ) ; shared Preference Editor . remove ( Media Notification Service . MEDIA NOTIFICATION IDS ) ; shared Preference Editor . apply ( ) ; }
private void cancel Previous Web Rtc Notifications ( ) { Set < String > notification Ids = m Shared Preferences . get String Set ( MEDIA NOTIFICATION IDS , null ) ; if ( notification Ids == null ) return ; Iterator < String > iterator = notification Ids . iterator ( ) ; while ( iterator . has Next ( ) ) { m Notification Manager . cancel ( NOTIFICATION NAMESPACE , Integer . parse Int ( iterator . next ( ) ) ) ; } Shared Preferences . Editor shared Preference Editor = m Shared Preferences . edit ( ) ; shared Preference Editor . remove ( Media Notification Service . MEDIA NOTIFICATION IDS ) ; shared Preference Editor . apply ( ) ; }
public void delete ( ) { m Base Name . delete ( ) ; m Backup Name . delete ( ) ; }
public void delete ( ) { m Base Name . delete ( ) ; m Backup Name . delete ( ) ; }
public void delete ( ) { m Base Name . delete ( ) ; m Backup Name . delete ( ) ; }
@ Override public double total Estimated Quantity For RE ( final Long wo Activity Id , Long estimate Id , final Long activity Id , final Work Order work Order ) { if ( estimate Id == null ) estimate Id = - NUM ; Object [ ] params = null ; Double est Quantity = null ; params = new Object [ ] { estimate Id , work Order , work Order , wo Activity Id , activity Id } ; est Quantity = ( Double ) generic Service . find By Named Query ( STRING , params ) ; Double est Quantity RE = null ; if ( work Order . get Parent ( ) != null ) params = new Object [ ] { estimate Id , work Order . get Parent ( ) , work Order . get Parent ( ) , activity Id } ; else params = new Object [ ] { estimate Id , work Order , work Order , activity Id } ; est Quantity RE = ( Double ) generic Service . find By Named Query ( STRING , params ) ; if ( est Quantity != null && est Quantity RE != null ) est Quantity = est Quantity + est Quantity RE ; if ( est Quantity == null && est Quantity RE != null ) est Quantity = est Quantity RE ; if ( est Quantity == null ) return NUM ; else return est Quantity . double Value ( ) ; }
public static synchronized int register ( Debug Value value ) { String name = value . get Name ( ) ; if ( ! key Map . contains Key ( name ) ) { key Map . put ( name , debug Values . size ( ) ) ; debug Values . add ( value ) ; } return key Map . get ( name ) ; }
void save Entities ( Data Output Stream out ) throws IO Exception { int num = NUM ; for ( Enumeration < Entity > e = entity Hash . elements ( ) ; e . has More Elements ( ) ; ) { Entity ent = e . next Element ( ) ; if ( ent . is General ( ) ) { num ++ ; } } out . write Short ( ( short ) num ) ; for ( Enumeration < Entity > e = entity Hash . elements ( ) ; e . has More Elements ( ) ; ) { Entity ent = e . next Element ( ) ; if ( ent . is General ( ) ) { out . write Short ( get Name Id ( ent . get Name ( ) ) ) ; out . write Byte ( ent . get Type ( ) & ~ GENERAL ) ; out . write UTF ( ent . get String ( ) ) ; } } }
public static boolean contains ( String s , Property expected ) { if ( s == null || s . length ( ) == NUM ) { return BOOL ; } int i = NUM ; while ( i < s . length ( ) ) { int codepoint = Character . code Point At ( s , i ) ; Emoji e = map . get ( codepoint ) ; if ( e == null ) { return BOOL ; } if ( ! e . is ( expected ) ) { return BOOL ; } i += codepoint >= NUM ? NUM : NUM ; } return BOOL ; }
public static boolean contains ( String s , Property expected ) { if ( s == null || s . length ( ) == NUM ) { return BOOL ; } int i = NUM ; while ( i < s . length ( ) ) { int codepoint = Character . code Point At ( s , i ) ; Emoji e = map . get ( codepoint ) ; if ( e == null ) { return BOOL ; } if ( ! e . is ( expected ) ) { return BOOL ; } i += codepoint >= NUM ? NUM : NUM ; } return BOOL ; }
private Segment create Memory Segment ( Segment Descriptor descriptor ) { File segment File = Segment File . create Segment File ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ; Buffer buffer = Heap Buffer . allocate ( Math . min ( DEFAULT BUFFER SIZE , descriptor . max Segment Size ( ) ) , Integer . MAX VALUE ) ; descriptor . copy To ( buffer ) ; Segment segment = new Segment ( new Segment File ( segment File ) , buffer . slice ( ) , descriptor , create Index ( descriptor ) , new Offset Predicate ( ) , serializer . clone ( ) , this ) ; LOGGER . debug ( STRING , segment ) ; return segment ; }
protected double update Distance ( double curr Dist , double diff ) { double result ; result = curr Dist ; result += Math . abs ( diff ) ; return result ; }
protected double update Distance ( double curr Dist , double diff ) { double result ; result = curr Dist ; result += Math . abs ( diff ) ; return result ; }
protected double update Distance ( double curr Dist , double diff ) { double result ; result = curr Dist ; result += Math . abs ( diff ) ; return result ; }
protected double update Distance ( double curr Dist , double diff ) { double result ; result = curr Dist ; result += Math . abs ( diff ) ; return result ; }
public Repeated Field Builder < M Type , B Type , I Type > add Message ( M Type message ) { if ( message == null ) { throw new Null Pointer Exception ( ) ; } ensure Mutable Message List ( ) ; messages . add ( message ) ; if ( builders != null ) { builders . add ( null ) ; } on Changed ( ) ; increment Mod Counts ( ) ; return this ; }
public String read Next Word ( ) { if ( tokenizer . has More Tokens ( ) ) { return tokenizer . next Token ( ) ; } else { return null ; } }
public static < IN > byte [ ] serialize ( IN object , Type Serializer < IN > serializer ) throws IO Exception { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; Data Output View Stream Wrapper wrapper = new Data Output View Stream Wrapper ( new Data Output Stream ( baos ) ) ; serializer . serialize ( object , wrapper ) ; return baos . to Byte Array ( ) ; }
private void log Max ( String type , String value , String arg , long amount ) { Key key = new Key ( type , value , arg + MAXIMUM INDICATOR ) ; synchronized ( counts ) { Long old Max = counts . get ( key ) ; if ( old Max == null ) { old Max = amount ; } counts . put ( key , Math . max ( old Max , amount ) ) ; } }
public Iterator < Record ID > sorted Scan ( ) { Leaf Node first Leaf = new Leaf Node ( this , first Leaf Page Num ) ; return new B Plus Iterator ( first Leaf ) ; }
public static double next After ( final double start , final double direction ) { if ( Double . is Na N ( start ) || Double . is Na N ( direction ) ) { return Double . Na N ; } if ( start == direction ) { return direction ; } final double abs Start = Math . abs ( start ) ; final double abs Dir = Math . abs ( direction ) ; final boolean to Zero = ! is Same Sign ( start , direction ) || abs Dir < abs Start ; if ( to Zero ) { if ( abs Start == Double . MIN VALUE ) { return copy Sign ( NUM , start ) ; } if ( Double . is Infinite ( abs Start ) ) { return copy Sign ( Double . MAX VALUE , start ) ; } return copy Sign ( Double . long Bits To Double ( Double . double To Long Bits ( abs Start ) - NUM ) , start ) ; } else { if ( start == NUM ) { return copy Sign ( Double . MIN VALUE , direction ) ; } if ( abs Start == Double . MAX VALUE ) { return copy Sign ( Double . POSITIVE INFINITY , start ) ; } return copy Sign ( Double . long Bits To Double ( Double . double To Long Bits ( abs Start ) + NUM ) , start ) ; } }
public void add All ( final Casualty List casualty List ) { m damaged . add All ( casualty List . get Damaged ( ) ) ; m killed . add All ( casualty List . get Killed ( ) ) ; }
private void draw Drag Border ( final Execution Unit process , final Graphics 2 D g2 ) { double width = model . get Process Width ( process ) ; double height = model . get Process Height ( process ) ; Shape drag Frame = new Round Rectangle 2 D . Double ( DRAG BORDER PADDING , DRAG BORDER PADDING , width - NUM * DRAG BORDER PADDING , height - NUM * DRAG BORDER PADDING , DRAG BORDER CORNER , DRAG BORDER CORNER ) ; g2 . set Color ( BORDER DRAG COLOR ) ; g2 . set Stroke ( BORDER DRAG STROKE ) ; g2 . draw ( drag Frame ) ; }
public List < Page > normalize ( List < Page > pages ) { double hub Total = NUM ; double auth Total = NUM ; for ( Page p : pages ) { hub Total += Math . pow ( p . hub , NUM ) ; auth Total += Math . pow ( p . authority , NUM ) ; } for ( Page p : pages ) { if ( hub Total > NUM ) { p . hub /= hub Total ; } else { p . hub = NUM ; } if ( auth Total > NUM ) { p . authority /= auth Total ; } else { p . authority = NUM ; } } return pages ; }
public List < Page > normalize ( List < Page > pages ) { double hub Total = NUM ; double auth Total = NUM ; for ( Page p : pages ) { hub Total += Math . pow ( p . hub , NUM ) ; auth Total += Math . pow ( p . authority , NUM ) ; } for ( Page p : pages ) { if ( hub Total > NUM ) { p . hub /= hub Total ; } else { p . hub = NUM ; } if ( auth Total > NUM ) { p . authority /= auth Total ; } else { p . authority = NUM ; } } return pages ; }
private void increase Event Count ( Map < String , Integer > event Counts , Predicate < String > predicate ) { int impression Count = event Counts . get Or Default ( STRING , NUM ) ; int impression Unique Count = Math . min ( impression Count , NUM ) ; int joint Counts = NUM ; if ( ! predicate . test ( STRING ) ) { joint Counts += event Counts . get Or Default ( STRING , NUM ) ; } if ( ! predicate . test ( STRING ) ) { joint Counts += event Counts . get Or Default ( STRING , NUM ) ; } int joint Unique Count = Math . min ( joint Counts , NUM ) ; impression Counts . put ( STRING , impression Counts . get Or Default ( STRING , NUM ) + impression Count ) ; impression Counts . put ( STRING , impression Counts . get Or Default ( STRING , NUM ) + impression Unique Count ) ; joint Action Counts . put ( STRING , joint Action Counts . get Or Default ( STRING , NUM ) + joint Counts ) ; joint Action Counts . put ( STRING , joint Action Counts . get Or Default ( STRING , NUM ) + joint Unique Count ) ; }
private static String munge Char Name ( String source ) { String Buffer buf = new String Buffer ( ) ; for ( int i = NUM ; i < source . length ( ) ; ) { int ch = UTF 16 . char At ( source , i ) ; i += UTF 16 . get Char Count ( ch ) ; if ( U Character Property . is Rule White Space ( ch ) ) { if ( buf . length ( ) == NUM || buf . char At ( buf . length ( ) - NUM ) == STRING ) { continue ; } ch = STRING ; } UTF 16 . append ( buf , ch ) ; } if ( buf . length ( ) != NUM && buf . char At ( buf . length ( ) - NUM ) == STRING ) { buf . set Length ( buf . length ( ) - NUM ) ; } return buf . to String ( ) ; }
private static String munge Char Name ( String source ) { String Buffer buf = new String Buffer ( ) ; for ( int i = NUM ; i < source . length ( ) ; ) { int ch = UTF 16 . char At ( source , i ) ; i += UTF 16 . get Char Count ( ch ) ; if ( U Character Property . is Rule White Space ( ch ) ) { if ( buf . length ( ) == NUM || buf . char At ( buf . length ( ) - NUM ) == STRING ) { continue ; } ch = STRING ; } UTF 16 . append ( buf , ch ) ; } if ( buf . length ( ) != NUM && buf . char At ( buf . length ( ) - NUM ) == STRING ) { buf . set Length ( buf . length ( ) - NUM ) ; } return buf . to String ( ) ; }
@ Override public int on Start Command ( Intent intent , int flags , int start Id ) { Log OC . d ( TAG , STRING + start Id ) ; if ( ACTION SYNC FOLDER . equals ( intent . get Action ( ) ) ) { if ( ! intent . has Extra ( EXTRA ACCOUNT ) || ! intent . has Extra ( EXTRA REMOTE PATH ) ) { Log OC . e ( TAG , STRING ) ; return START NOT STICKY ; } Account account = intent . get Parcelable Extra ( EXTRA ACCOUNT ) ; String remote Path = intent . get String Extra ( EXTRA REMOTE PATH ) ; Pair < Account , String > item Sync Key = new Pair < Account , String > ( account , remote Path ) ; Pair < Target , Remote Operation > item To Queue = new Operation ( intent ) ; if ( item To Queue != null ) { m Sync Folder Handler . add ( account , remote Path , ( Synchronize Folder Operation ) item To Queue . second ) ; Message msg = m Sync Folder Handler . obtain Message ( ) ; msg . arg 1 = start Id ; msg . obj = item Sync Key ; m Sync Folder Handler . send Message ( msg ) ; } } else { Message msg = m Operations Handler . obtain Message ( ) ; msg . arg 1 = start Id ; m Operations Handler . send Message ( msg ) ; } return START NOT STICKY ; }
@ Override public int on Start Command ( Intent intent , int flags , int start Id ) { Log OC . d ( TAG , STRING + start Id ) ; if ( ACTION SYNC FOLDER . equals ( intent . get Action ( ) ) ) { if ( ! intent . has Extra ( EXTRA ACCOUNT ) || ! intent . has Extra ( EXTRA REMOTE PATH ) ) { Log OC . e ( TAG , STRING ) ; return START NOT STICKY ; } Account account = intent . get Parcelable Extra ( EXTRA ACCOUNT ) ; String remote Path = intent . get String Extra ( EXTRA REMOTE PATH ) ; Pair < Account , String > item Sync Key = new Pair < Account , String > ( account , remote Path ) ; Pair < Target , Remote Operation > item To Queue = new Operation ( intent ) ; if ( item To Queue != null ) { m Sync Folder Handler . add ( account , remote Path , ( Synchronize Folder Operation ) item To Queue . second ) ; Message msg = m Sync Folder Handler . obtain Message ( ) ; msg . arg 1 = start Id ; msg . obj = item Sync Key ; m Sync Folder Handler . send Message ( msg ) ; } } else { Message msg = m Operations Handler . obtain Message ( ) ; msg . arg 1 = start Id ; m Operations Handler . send Message ( msg ) ; } return START NOT STICKY ; }
@ Override public int on Start Command ( Intent intent , int flags , int start Id ) { Log OC . d ( TAG , STRING + start Id ) ; if ( ACTION SYNC FOLDER . equals ( intent . get Action ( ) ) ) { if ( ! intent . has Extra ( EXTRA ACCOUNT ) || ! intent . has Extra ( EXTRA REMOTE PATH ) ) { Log OC . e ( TAG , STRING ) ; return START NOT STICKY ; } Account account = intent . get Parcelable Extra ( EXTRA ACCOUNT ) ; String remote Path = intent . get String Extra ( EXTRA REMOTE PATH ) ; Pair < Account , String > item Sync Key = new Pair < Account , String > ( account , remote Path ) ; Pair < Target , Remote Operation > item To Queue = new Operation ( intent ) ; if ( item To Queue != null ) { m Sync Folder Handler . add ( account , remote Path , ( Synchronize Folder Operation ) item To Queue . second ) ; Message msg = m Sync Folder Handler . obtain Message ( ) ; msg . arg 1 = start Id ; msg . obj = item Sync Key ; m Sync Folder Handler . send Message ( msg ) ; } } else { Message msg = m Operations Handler . obtain Message ( ) ; msg . arg 1 = start Id ; m Operations Handler . send Message ( msg ) ; } return START NOT STICKY ; }
@ Override public int on Start Command ( Intent intent , int flags , int start Id ) { Log OC . d ( TAG , STRING + start Id ) ; if ( ACTION SYNC FOLDER . equals ( intent . get Action ( ) ) ) { if ( ! intent . has Extra ( EXTRA ACCOUNT ) || ! intent . has Extra ( EXTRA REMOTE PATH ) ) { Log OC . e ( TAG , STRING ) ; return START NOT STICKY ; } Account account = intent . get Parcelable Extra ( EXTRA ACCOUNT ) ; String remote Path = intent . get String Extra ( EXTRA REMOTE PATH ) ; Pair < Account , String > item Sync Key = new Pair < Account , String > ( account , remote Path ) ; Pair < Target , Remote Operation > item To Queue = new Operation ( intent ) ; if ( item To Queue != null ) { m Sync Folder Handler . add ( account , remote Path , ( Synchronize Folder Operation ) item To Queue . second ) ; Message msg = m Sync Folder Handler . obtain Message ( ) ; msg . arg 1 = start Id ; msg . obj = item Sync Key ; m Sync Folder Handler . send Message ( msg ) ; } } else { Message msg = m Operations Handler . obtain Message ( ) ; msg . arg 1 = start Id ; m Operations Handler . send Message ( msg ) ; } return START NOT STICKY ; }
@ Override public int on Start Command ( Intent intent , int flags , int start Id ) { Log OC . d ( TAG , STRING + start Id ) ; if ( ACTION SYNC FOLDER . equals ( intent . get Action ( ) ) ) { if ( ! intent . has Extra ( EXTRA ACCOUNT ) || ! intent . has Extra ( EXTRA REMOTE PATH ) ) { Log OC . e ( TAG , STRING ) ; return START NOT STICKY ; } Account account = intent . get Parcelable Extra ( EXTRA ACCOUNT ) ; String remote Path = intent . get String Extra ( EXTRA REMOTE PATH ) ; Pair < Account , String > item Sync Key = new Pair < Account , String > ( account , remote Path ) ; Pair < Target , Remote Operation > item To Queue = new Operation ( intent ) ; if ( item To Queue != null ) { m Sync Folder Handler . add ( account , remote Path , ( Synchronize Folder Operation ) item To Queue . second ) ; Message msg = m Sync Folder Handler . obtain Message ( ) ; msg . arg 1 = start Id ; msg . obj = item Sync Key ; m Sync Folder Handler . send Message ( msg ) ; } } else { Message msg = m Operations Handler . obtain Message ( ) ; msg . arg 1 = start Id ; m Operations Handler . send Message ( msg ) ; } return START NOT STICKY ; }
@ Override public int on Start Command ( Intent intent , int flags , int start Id ) { Log OC . d ( TAG , STRING + start Id ) ; if ( ACTION SYNC FOLDER . equals ( intent . get Action ( ) ) ) { if ( ! intent . has Extra ( EXTRA ACCOUNT ) || ! intent . has Extra ( EXTRA REMOTE PATH ) ) { Log OC . e ( TAG , STRING ) ; return START NOT STICKY ; } Account account = intent . get Parcelable Extra ( EXTRA ACCOUNT ) ; String remote Path = intent . get String Extra ( EXTRA REMOTE PATH ) ; Pair < Account , String > item Sync Key = new Pair < Account , String > ( account , remote Path ) ; Pair < Target , Remote Operation > item To Queue = new Operation ( intent ) ; if ( item To Queue != null ) { m Sync Folder Handler . add ( account , remote Path , ( Synchronize Folder Operation ) item To Queue . second ) ; Message msg = m Sync Folder Handler . obtain Message ( ) ; msg . arg 1 = start Id ; msg . obj = item Sync Key ; m Sync Folder Handler . send Message ( msg ) ; } } else { Message msg = m Operations Handler . obtain Message ( ) ; msg . arg 1 = start Id ; m Operations Handler . send Message ( msg ) ; } return START NOT STICKY ; }
@ Override public int on Start Command ( Intent intent , int flags , int start Id ) { Log OC . d ( TAG , STRING + start Id ) ; if ( ACTION SYNC FOLDER . equals ( intent . get Action ( ) ) ) { if ( ! intent . has Extra ( EXTRA ACCOUNT ) || ! intent . has Extra ( EXTRA REMOTE PATH ) ) { Log OC . e ( TAG , STRING ) ; return START NOT STICKY ; } Account account = intent . get Parcelable Extra ( EXTRA ACCOUNT ) ; String remote Path = intent . get String Extra ( EXTRA REMOTE PATH ) ; Pair < Account , String > item Sync Key = new Pair < Account , String > ( account , remote Path ) ; Pair < Target , Remote Operation > item To Queue = new Operation ( intent ) ; if ( item To Queue != null ) { m Sync Folder Handler . add ( account , remote Path , ( Synchronize Folder Operation ) item To Queue . second ) ; Message msg = m Sync Folder Handler . obtain Message ( ) ; msg . arg 1 = start Id ; msg . obj = item Sync Key ; m Sync Folder Handler . send Message ( msg ) ; } } else { Message msg = m Operations Handler . obtain Message ( ) ; msg . arg 1 = start Id ; m Operations Handler . send Message ( msg ) ; } return START NOT STICKY ; }
private void create Record Holder Queue ( File [ ] list Files ) { this . record Holder Heap = new Priority Queue < Sort Temp File Chunk Holder > ( list Files . length ) ; }
private void create Record Holder Queue ( File [ ] list Files ) { this . record Holder Heap = new Priority Queue < Sort Temp File Chunk Holder > ( list Files . length ) ; }
private void create Record Holder Queue ( File [ ] list Files ) { this . record Holder Heap = new Priority Queue < Sort Temp File Chunk Holder > ( list Files . length ) ; }
public void define Property ( String property Name , Class < ? > clazz , int attributes ) { int length = property Name . length ( ) ; if ( length == NUM ) throw new Illegal Argument Exception ( ) ; char [ ] buf = new char [ NUM + length ] ; property Name . get Chars ( NUM , length , buf , NUM ) ; buf [ NUM ] = Character . to Upper Case ( buf [ NUM ] ) ; buf [ NUM ] = STRING ; buf [ NUM ] = STRING ; buf [ NUM ] = STRING ; String getter Name = new String ( buf ) ; buf [ NUM ] = STRING ; String setter Name = new String ( buf ) ; Method [ ] methods = Function Object . get Method List ( clazz ) ; Method getter = Function Object . find Single Method ( methods , getter Name ) ; Method setter = Function Object . find Single Method ( methods , setter Name ) ; if ( setter == null ) attributes |= Scriptable Object . READONLY ; define Property ( property Name , null , getter , setter == null ? null : setter , attributes ) ; }
private List < I Runtime Classpath Entry > dependencies For Project ( I Java Project project ) throws Core Exception { Array List < I Runtime Classpath Entry > out = new Array List < I Runtime Classpath Entry > ( ) ; String [ ] deps = Java Runtime . compute Default Runtime Class Path ( project ) ; for ( String dep : deps ) { I Runtime Classpath Entry cp Entry = Java Runtime . new Archive Runtime Classpath Entry ( new Path ( dep ) ) ; out . add ( cp Entry ) ; } return out ; }
public void delete ( String name ) throws Certificate Exception , IO Exception { if ( read Only ) throw new Certificate Exception ( STRING + STRING ) ; X509 Attribute Name attr = new X509 Attribute Name ( name ) ; String id = attr . get Prefix ( ) ; if ( ! ( id . equals Ignore Case ( NAME ) ) ) { throw new Certificate Exception ( STRING + STRING + NAME + STRING + id ) ; } attr = new X509 Attribute Name ( attr . get Suffix ( ) ) ; id = attr . get Prefix ( ) ; if ( id . equals Ignore Case ( INFO ) ) { if ( attr . get Suffix ( ) != null ) { info = null ; } else { info . delete ( attr . get Suffix ( ) ) ; } } else if ( id . equals Ignore Case ( ALG ID ) ) { alg Id = null ; } else if ( id . equals Ignore Case ( SIGNATURE ) ) { signature = null ; } else if ( id . equals Ignore Case ( SIGNED CERT ) ) { signed Cert = null ; } else { throw new Certificate Exception ( STRING + STRING + id ) ; } }
public void test Long Conversion And Ordering ( ) throws Exception { Bytes Ref previous = null ; Bytes Ref current = new Bytes Ref ( new byte [ Long . BYTES ] ) ; for ( long value = - NUM ; value < NUM ; value ++ ) { Numeric Utils . long To Sortable Bytes ( value , current . bytes , current . offset ) ; if ( previous == null ) { previous = new Bytes Ref ( new byte [ Long . BYTES ] ) ; } else { assert True ( STRING , previous . compare To ( current ) < NUM ) ; } assert Equals ( STRING , value , Numeric Utils . sortable Bytes To Long ( current . bytes , current . offset ) ) ; System . arraycopy ( current . bytes , current . offset , previous . bytes , previous . offset , current . length ) ; } }
private void apply Changes ( ) { region . set Fill ( new Radial Gradient ( NUM , NUM , region . get Width ( ) / NUM , region . get Height ( ) / NUM , radius , BOOL , Cycle Method . NO CYCLE , new Stop ( NUM , Color . TRANSPARENT ) , new Stop ( NUM , Color . color ( color . get Red ( ) , color . get Green ( ) , color . get Blue ( ) , intensity ) ) ) ) ; }
public void write ( byte [ ] buf ) throws IO Exception { output . write ( buf ) ; bytes Written += buf . length ; }
public void write Mapping ( Writer w ) throws IO Exception { w . write ( STRING + ( new Date ( ) ) + STRING ) ; for ( Integer key : id 2 name . key Set ( ) ) { w . write ( key + STRING + id 2 name . get ( key ) + STRING ) ; } }
@ HLE Function ( nid = NUM , version = NUM , check Inside Interrupt = BOOL ) public int sce Sas Rev Param ( int sas Core , int delay , int feedback ) { check Sas Handle Good ( sas Core ) ; waveform Effect Delay = delay ; waveform Effect Feedback = feedback ; return NUM ; }
private static JSON Object create File Transfer Error ( int error Code , String source , String target , String body , Integer http Status ) { JSON Object error = null ; try { error = new JSON Object ( ) ; error . put ( STRING , error Code ) ; error . put ( STRING , source ) ; error . put ( STRING , target ) ; if ( body != null ) { error . put ( STRING , body ) ; } if ( http Status != null ) { error . put ( STRING , http Status ) ; } } catch ( JSON Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return error ; }
public void accept ( final Path file ) throws Interrupted Exception { logger . info ( String . format ( STRING , file ) ) ; permits . acquire ( ) ; executor . execute ( new Consumer Task ( file ) ) ; }
public void accept ( final Path file ) throws Interrupted Exception { logger . info ( String . format ( STRING , file ) ) ; permits . acquire ( ) ; executor . execute ( new Consumer Task ( file ) ) ; }
public void accept ( final Path file ) throws Interrupted Exception { logger . info ( String . format ( STRING , file ) ) ; permits . acquire ( ) ; executor . execute ( new Consumer Task ( file ) ) ; }
public void accept ( final Path file ) throws Interrupted Exception { logger . info ( String . format ( STRING , file ) ) ; permits . acquire ( ) ; executor . execute ( new Consumer Task ( file ) ) ; }
public void accept ( final Path file ) throws Interrupted Exception { logger . info ( String . format ( STRING , file ) ) ; permits . acquire ( ) ; executor . execute ( new Consumer Task ( file ) ) ; }
@ Override public void clear Rect ( int x , int y , int width , int height ) { set State To Local ( ) ; Color save Color = get Color ( ) ; set Color ( Color . white ) ; m printstream . println ( x Transform ( x Scale ( x ) ) + STRING + y Transform ( y Scale ( y ) ) + STRING + x Scale ( width ) + STRING + y Scale ( height ) + STRING ) ; set Color ( save Color ) ; }
public Gossip Service ( String cluster , String ip Address , int port , String id , List < Gossip Member > gossip Members , Gossip Settings settings , Gossip Listener listener ) throws Interrupted Exception , Unknown Host Exception { gossip Manager = new Random Gossip Manager ( cluster , ip Address , port , id , settings , gossip Members , listener ) ; }
public Gossip Service ( String cluster , String ip Address , int port , String id , List < Gossip Member > gossip Members , Gossip Settings settings , Gossip Listener listener ) throws Interrupted Exception , Unknown Host Exception { gossip Manager = new Random Gossip Manager ( cluster , ip Address , port , id , settings , gossip Members , listener ) ; }
private void add To Content ( final String name , final byte [ ] byte Contents ) { Iterator < Transfer Content > it = contents . iterator ( ) ; while ( it . has Next ( ) ) { if ( name . equals ( it . next ( ) . name ) ) { logger . info ( STRING + name + STRING ) ; it . remove ( ) ; } } final Transfer Content content = new Transfer Content ( ) ; content . name = name ; content . cacheable = BOOL ; logger . debug ( STRING + Integer . to String ( content . timestamp ) ) ; content . data = byte Contents ; content . timestamp = CRC . cmp CRC ( content . data ) ; contents . add ( content ) ; }
@ Suppress Warnings ( STRING ) private static boolean is Regex ( String s ) { try { Pattern . compile ( s ) ; } catch ( Pattern Syntax Exception e ) { return BOOL ; } return BOOL ; }
@ Suppress Warnings ( STRING ) private static boolean is Regex ( String s ) { try { Pattern . compile ( s ) ; } catch ( Pattern Syntax Exception e ) { return BOOL ; } return BOOL ; }
@ Suppress Warnings ( STRING ) private static boolean is Regex ( String s ) { try { Pattern . compile ( s ) ; } catch ( Pattern Syntax Exception e ) { return BOOL ; } return BOOL ; }
@ Suppress Warnings ( STRING ) private static boolean is Regex ( String s ) { try { Pattern . compile ( s ) ; } catch ( Pattern Syntax Exception e ) { return BOOL ; } return BOOL ; }
@ Suppress Warnings ( STRING ) private static boolean is Regex ( String s ) { try { Pattern . compile ( s ) ; } catch ( Pattern Syntax Exception e ) { return BOOL ; } return BOOL ; }
protected String convert With Convert Map ( String sql Statement ) { try { sql Statement = apply Convert Map ( clean Up Statement ( sql Statement ) ) ; } catch ( Runtime Exception e ) { log . warning ( e . get Localized Message ( ) ) ; m exception = e ; } return sql Statement ; }
public void translate ( double dx , double dy ) { if ( ! is Relative ( ) ) { x += dx ; y += dy ; } if ( source Point != null ) { source Point . set X ( source Point . get X ( ) + dx ) ; source Point . set Y ( source Point . get Y ( ) + dy ) ; } if ( target Point != null ) { target Point . set X ( target Point . get X ( ) + dx ) ; target Point . set Y ( target Point . get Y ( ) + dy ) ; } if ( TRANSLATE CONTROL POINTS && points != null ) { int count = points . size ( ) ; for ( int i = NUM ; i < count ; i ++ ) { mx Point pt = ( mx Point ) points . get ( i ) ; pt . set X ( pt . get X ( ) + dx ) ; pt . set Y ( pt . get Y ( ) + dy ) ; } } }
public void translate ( double dx , double dy ) { if ( ! is Relative ( ) ) { x += dx ; y += dy ; } if ( source Point != null ) { source Point . set X ( source Point . get X ( ) + dx ) ; source Point . set Y ( source Point . get Y ( ) + dy ) ; } if ( target Point != null ) { target Point . set X ( target Point . get X ( ) + dx ) ; target Point . set Y ( target Point . get Y ( ) + dy ) ; } if ( TRANSLATE CONTROL POINTS && points != null ) { int count = points . size ( ) ; for ( int i = NUM ; i < count ; i ++ ) { mx Point pt = ( mx Point ) points . get ( i ) ; pt . set X ( pt . get X ( ) + dx ) ; pt . set Y ( pt . get Y ( ) + dy ) ; } } }
public Frame Analysis Result [ ] analyse All Frames ( ) { if ( analysis Results == null ) { Array List results = new Array List ( ) ; Frame Analysis Result one Result ; while ( ( one Result = analyse Next Frame ( ) ) != null ) { results . add ( one Result ) ; } analysis Results = ( Frame Analysis Result [ ] ) results . to Array ( new Frame Analysis Result [ NUM ] ) ; } return analysis Results ; }
public Frame Analysis Result [ ] analyse All Frames ( ) { if ( analysis Results == null ) { Array List results = new Array List ( ) ; Frame Analysis Result one Result ; while ( ( one Result = analyse Next Frame ( ) ) != null ) { results . add ( one Result ) ; } analysis Results = ( Frame Analysis Result [ ] ) results . to Array ( new Frame Analysis Result [ NUM ] ) ; } return analysis Results ; }
public Frame Analysis Result [ ] analyse All Frames ( ) { if ( analysis Results == null ) { Array List results = new Array List ( ) ; Frame Analysis Result one Result ; while ( ( one Result = analyse Next Frame ( ) ) != null ) { results . add ( one Result ) ; } analysis Results = ( Frame Analysis Result [ ] ) results . to Array ( new Frame Analysis Result [ NUM ] ) ; } return analysis Results ; }
public Frame Analysis Result [ ] analyse All Frames ( ) { if ( analysis Results == null ) { Array List results = new Array List ( ) ; Frame Analysis Result one Result ; while ( ( one Result = analyse Next Frame ( ) ) != null ) { results . add ( one Result ) ; } analysis Results = ( Frame Analysis Result [ ] ) results . to Array ( new Frame Analysis Result [ NUM ] ) ; } return analysis Results ; }
public Frame Analysis Result [ ] analyse All Frames ( ) { if ( analysis Results == null ) { Array List results = new Array List ( ) ; Frame Analysis Result one Result ; while ( ( one Result = analyse Next Frame ( ) ) != null ) { results . add ( one Result ) ; } analysis Results = ( Frame Analysis Result [ ] ) results . to Array ( new Frame Analysis Result [ NUM ] ) ; } return analysis Results ; }
private String save File On Disk ( String file Path To Save , String file Content ) throws IO Exception { File file = new File ( file Path To Save ) ; Files . create Parent Dirs ( file ) ; Files . write ( file Content , file , Charset . default Charset ( ) ) ; return file Path To Save ; }
private String save File On Disk ( String file Path To Save , String file Content ) throws IO Exception { File file = new File ( file Path To Save ) ; Files . create Parent Dirs ( file ) ; Files . write ( file Content , file , Charset . default Charset ( ) ) ; return file Path To Save ; }
@ Known Failure ( STRING ) public void test Update 7 ( ) throws SQL Exception { Database Creator . fill FK Strict Table ( conn ) ; statement . execute Update ( STRING + Database Creator . FKSTRICT TABLE + STRING + Database Creator . PARENT TABLE + STRING ) ; Result Set r = statement . execute Query ( STRING + Database Creator . FKSTRICT TABLE + STRING ) ; r . next ( ) ; assert Equals ( STRING , NUM , r . get Int ( NUM ) ) ; r . close ( ) ; }
@ Known Failure ( STRING ) public void test Update 7 ( ) throws SQL Exception { Database Creator . fill FK Strict Table ( conn ) ; statement . execute Update ( STRING + Database Creator . FKSTRICT TABLE + STRING + Database Creator . PARENT TABLE + STRING ) ; Result Set r = statement . execute Query ( STRING + Database Creator . FKSTRICT TABLE + STRING ) ; r . next ( ) ; assert Equals ( STRING , NUM , r . get Int ( NUM ) ) ; r . close ( ) ; }
@ Known Failure ( STRING ) public void test Update 7 ( ) throws SQL Exception { Database Creator . fill FK Strict Table ( conn ) ; statement . execute Update ( STRING + Database Creator . FKSTRICT TABLE + STRING + Database Creator . PARENT TABLE + STRING ) ; Result Set r = statement . execute Query ( STRING + Database Creator . FKSTRICT TABLE + STRING ) ; r . next ( ) ; assert Equals ( STRING , NUM , r . get Int ( NUM ) ) ; r . close ( ) ; }
public static Pc Runner serializable Instance ( ) { return Pc Runner . serializable Instance ( ) ; }
public static Pc Runner serializable Instance ( ) { return Pc Runner . serializable Instance ( ) ; }
protected void test Get ( ) throws Throwable { Operation op = Operation . create Get ( URI . create ( echo Service Uri ) ) ; test Echo Operation ( op ) ; }
protected void test Get ( ) throws Throwable { Operation op = Operation . create Get ( URI . create ( echo Service Uri ) ) ; test Echo Operation ( op ) ; }
protected void test Get ( ) throws Throwable { Operation op = Operation . create Get ( URI . create ( echo Service Uri ) ) ; test Echo Operation ( op ) ; }
protected void test Get ( ) throws Throwable { Operation op = Operation . create Get ( URI . create ( echo Service Uri ) ) ; test Echo Operation ( op ) ; }
public final List check Patients Assess ( Village v ) { List up = new List ( ) ; for ( Enumeration e = assess . elements ( ) ; e . has More Elements ( ) ; ) { Patient p = ( Patient ) e . next Element ( ) ; p . time Left -= NUM ; if ( p . time Left == NUM ) { if ( v . stays Here ( ) ) { assess . delete ( p ) ; inside . add ( p ) ; p . time Left = NUM ; p . time += NUM ; } else { free Personnel ++ ; assess . delete ( p ) ; up . add ( p ) ; } } } return up ; }
public static synchronized boolean prepare Directory ( File directory ) { if ( directory . exists ( ) ) return BOOL ; directory . mkdirs ( ) ; return directory . exists ( ) ; }
public void draw In Rect ( GL 10 gl , CG Rect rect ) { gl . gl Enable ( GL TEXTURE 2D ) ; load Texture ( gl ) ; float vertices [ ] = { rect . origin . x , rect . origin . y , rect . origin . x + rect . size . width , rect . origin . y , rect . origin . x , rect . origin . y + rect . size . height , rect . origin . x + rect . size . width , rect . origin . y + rect . size . height } ; m Vertices . put ( vertices ) ; m Vertices . position ( NUM ) ; float coordinates [ ] = { NUM , max T , max S , max T , NUM , NUM , max S , NUM } ; m Coordinates . put ( coordinates ) ; m Coordinates . position ( NUM ) ; gl . gl Enable Client State ( GL VERTEX ARRAY ) ; gl . gl Enable Client State ( GL TEXTURE COORD ARRAY ) ; gl . gl Bind Texture ( GL TEXTURE 2D , name ) ; gl . gl Tex Parameterx ( GL TEXTURE 2D , GL TEXTURE WRAP S , GL REPEAT ) ; gl . gl Tex Parameterx ( GL TEXTURE 2D , GL TEXTURE WRAP T , GL REPEAT ) ; gl . gl Vertex Pointer ( NUM , GL FLOAT , NUM , m Vertices ) ; gl . gl Tex Coord Pointer ( NUM , GL FLOAT , NUM , m Coordinates ) ; gl . gl Draw Arrays ( GL TRIANGLE STRIP , NUM , NUM ) ; gl . gl Disable Client State ( GL VERTEX ARRAY ) ; gl . gl Disable Client State ( GL TEXTURE COORD ARRAY ) ; gl . gl Disable ( GL TEXTURE 2D ) ; }
public void draw In Rect ( GL 10 gl , CG Rect rect ) { gl . gl Enable ( GL TEXTURE 2D ) ; load Texture ( gl ) ; float vertices [ ] = { rect . origin . x , rect . origin . y , rect . origin . x + rect . size . width , rect . origin . y , rect . origin . x , rect . origin . y + rect . size . height , rect . origin . x + rect . size . width , rect . origin . y + rect . size . height } ; m Vertices . put ( vertices ) ; m Vertices . position ( NUM ) ; float coordinates [ ] = { NUM , max T , max S , max T , NUM , NUM , max S , NUM } ; m Coordinates . put ( coordinates ) ; m Coordinates . position ( NUM ) ; gl . gl Enable Client State ( GL VERTEX ARRAY ) ; gl . gl Enable Client State ( GL TEXTURE COORD ARRAY ) ; gl . gl Bind Texture ( GL TEXTURE 2D , name ) ; gl . gl Tex Parameterx ( GL TEXTURE 2D , GL TEXTURE WRAP S , GL REPEAT ) ; gl . gl Tex Parameterx ( GL TEXTURE 2D , GL TEXTURE WRAP T , GL REPEAT ) ; gl . gl Vertex Pointer ( NUM , GL FLOAT , NUM , m Vertices ) ; gl . gl Tex Coord Pointer ( NUM , GL FLOAT , NUM , m Coordinates ) ; gl . gl Draw Arrays ( GL TRIANGLE STRIP , NUM , NUM ) ; gl . gl Disable Client State ( GL VERTEX ARRAY ) ; gl . gl Disable Client State ( GL TEXTURE COORD ARRAY ) ; gl . gl Disable ( GL TEXTURE 2D ) ; }
public Field Frame Body IMG ( Lyrics 3 Image image ) { images . add ( image ) ; }
private static Counter < String > load Weights ( String wts Initial File , boolean uniform Start Weights , boolean randomize Start Weights , Translation Model < I String , String > translation Model ) { Counter < String > weights = IO Tools . read Weights ( wts Initial File ) ; if ( weights == null ) weights = new Classic Counter < > ( ) ; if ( uniform Start Weights ) { Set < String > feature Names = new Hash Set < > ( weights . key Set ( ) ) ; feature Names . add All ( Feature Utils . get Baseline Features ( translation Model ) ) ; for ( String key : feature Names ) { if ( key . starts With ( N Gram Language Model Featurizer . DEFAULT FEATURE NAME ) ) { weights . set Count ( key , NUM ) ; } else if ( key . starts With ( Word Penalty Featurizer . FEATURE NAME ) ) { weights . set Count ( key , - NUM ) ; } else { weights . set Count ( key , NUM ) ; } } } if ( randomize Start Weights ) { double scale = NUM ; Optimizer Utils . randomize Weights In Place ( weights , scale ) ; } return weights ; }
private static Counter < String > load Weights ( String wts Initial File , boolean uniform Start Weights , boolean randomize Start Weights , Translation Model < I String , String > translation Model ) { Counter < String > weights = IO Tools . read Weights ( wts Initial File ) ; if ( weights == null ) weights = new Classic Counter < > ( ) ; if ( uniform Start Weights ) { Set < String > feature Names = new Hash Set < > ( weights . key Set ( ) ) ; feature Names . add All ( Feature Utils . get Baseline Features ( translation Model ) ) ; for ( String key : feature Names ) { if ( key . starts With ( N Gram Language Model Featurizer . DEFAULT FEATURE NAME ) ) { weights . set Count ( key , NUM ) ; } else if ( key . starts With ( Word Penalty Featurizer . FEATURE NAME ) ) { weights . set Count ( key , - NUM ) ; } else { weights . set Count ( key , NUM ) ; } } } if ( randomize Start Weights ) { double scale = NUM ; Optimizer Utils . randomize Weights In Place ( weights , scale ) ; } return weights ; }
public void unpin Connection ( String host , Integer port ) { connection Lock . lock ( ) ; try { String host And Port = Connection Manager . generate Connection Cache Key ( host , port ) ; if ( pinned Connections . contains Key ( host And Port ) ) { Integer count = pinned Connections . get ( host And Port ) - NUM ; if ( count == NUM ) { s logger . info ( STRING , host And Port ) ; pinned Connections . remove ( host And Port ) ; } else { s logger . info ( STRING , host And Port , count ) ; pinned Connections . put ( host And Port , count ) ; } } } finally { connection Lock . unlock ( ) ; } }
public void unpin Connection ( String host , Integer port ) { connection Lock . lock ( ) ; try { String host And Port = Connection Manager . generate Connection Cache Key ( host , port ) ; if ( pinned Connections . contains Key ( host And Port ) ) { Integer count = pinned Connections . get ( host And Port ) - NUM ; if ( count == NUM ) { s logger . info ( STRING , host And Port ) ; pinned Connections . remove ( host And Port ) ; } else { s logger . info ( STRING , host And Port , count ) ; pinned Connections . put ( host And Port , count ) ; } } } finally { connection Lock . unlock ( ) ; } }
public void unpin Connection ( String host , Integer port ) { connection Lock . lock ( ) ; try { String host And Port = Connection Manager . generate Connection Cache Key ( host , port ) ; if ( pinned Connections . contains Key ( host And Port ) ) { Integer count = pinned Connections . get ( host And Port ) - NUM ; if ( count == NUM ) { s logger . info ( STRING , host And Port ) ; pinned Connections . remove ( host And Port ) ; } else { s logger . info ( STRING , host And Port , count ) ; pinned Connections . put ( host And Port , count ) ; } } } finally { connection Lock . unlock ( ) ; } }
public String poll ( long timeout ) throws Interrupted Exception { last Time Millis = System . current Time Millis ( ) ; String result = STRING ; synchronized ( this ) { if ( buffer . length ( ) == NUM ) { wait ( timeout ) ; } if ( buffer . length ( ) > NUM ) { result = STRING + buffer . to String ( ) + STRING ; buffer = new String Buffer ( ) ; } notify ( ) ; } return result ; }
public String poll ( long timeout ) throws Interrupted Exception { last Time Millis = System . current Time Millis ( ) ; String result = STRING ; synchronized ( this ) { if ( buffer . length ( ) == NUM ) { wait ( timeout ) ; } if ( buffer . length ( ) > NUM ) { result = STRING + buffer . to String ( ) + STRING ; buffer = new String Buffer ( ) ; } notify ( ) ; } return result ; }
public String poll ( long timeout ) throws Interrupted Exception { last Time Millis = System . current Time Millis ( ) ; String result = STRING ; synchronized ( this ) { if ( buffer . length ( ) == NUM ) { wait ( timeout ) ; } if ( buffer . length ( ) > NUM ) { result = STRING + buffer . to String ( ) + STRING ; buffer = new String Buffer ( ) ; } notify ( ) ; } return result ; }
@ Override public boolean has Feature ( String feature , String version ) { return super . has Feature ( feature , version ) || feature . equals Ignore Case ( STRING ) ; }
@ Override public boolean has Feature ( String feature , String version ) { return super . has Feature ( feature , version ) || feature . equals Ignore Case ( STRING ) ; }
@ Override public boolean has Feature ( String feature , String version ) { return super . has Feature ( feature , version ) || feature . equals Ignore Case ( STRING ) ; }
@ Override public boolean has Feature ( String feature , String version ) { return super . has Feature ( feature , version ) || feature . equals Ignore Case ( STRING ) ; }
@ Override public boolean has Feature ( String feature , String version ) { return super . has Feature ( feature , version ) || feature . equals Ignore Case ( STRING ) ; }
public void remove At ( int index ) { System . arraycopy ( m Keys , index + NUM , m Keys , index , m Size - ( index + NUM ) ) ; System . arraycopy ( m Values , index + NUM , m Values , index , m Size - ( index + NUM ) ) ; -- m Size ; }
private boolean convergence ( List < Page > pages ) { double ave Hub Delta = NUM ; double ave Auth Delta = NUM ; if ( pages == null ) { return BOOL ; } double [ ] curr Hub Vals = new double [ pages . size ( ) ] ; double [ ] curr Auth Vals = new double [ pages . size ( ) ] ; for ( int i = NUM ; i < pages . size ( ) ; i ++ ) { Page curr Page = pages . get ( i ) ; curr Hub Vals [ i ] = curr Page . hub ; curr Hub Vals [ i ] = curr Page . authority ; } if ( prev Hub Vals == null || prev Auth Vals == null ) { prev Hub Vals = curr Hub Vals ; prev Auth Vals = curr Auth Vals ; return BOOL ; } ave Hub Delta = get Ave Delta ( curr Hub Vals , prev Hub Vals ) ; ave Auth Delta = get Ave Delta ( curr Auth Vals , prev Auth Vals ) ; if ( ave Hub Delta + ave Auth Delta < DELTA TOLERANCE || ( Math . abs ( prev Ave Hub Delta - ave Hub Delta ) < NUM && Math . abs ( prev Ave Auth Delta - ave Auth Delta ) < NUM ) ) { return BOOL ; } else { prev Hub Vals = curr Hub Vals ; prev Auth Vals = curr Auth Vals ; prev Ave Hub Delta = ave Hub Delta ; prev Ave Auth Delta = ave Auth Delta ; return BOOL ; } }
private boolean convergence ( List < Page > pages ) { double ave Hub Delta = NUM ; double ave Auth Delta = NUM ; if ( pages == null ) { return BOOL ; } double [ ] curr Hub Vals = new double [ pages . size ( ) ] ; double [ ] curr Auth Vals = new double [ pages . size ( ) ] ; for ( int i = NUM ; i < pages . size ( ) ; i ++ ) { Page curr Page = pages . get ( i ) ; curr Hub Vals [ i ] = curr Page . hub ; curr Hub Vals [ i ] = curr Page . authority ; } if ( prev Hub Vals == null || prev Auth Vals == null ) { prev Hub Vals = curr Hub Vals ; prev Auth Vals = curr Auth Vals ; return BOOL ; } ave Hub Delta = get Ave Delta ( curr Hub Vals , prev Hub Vals ) ; ave Auth Delta = get Ave Delta ( curr Auth Vals , prev Auth Vals ) ; if ( ave Hub Delta + ave Auth Delta < DELTA TOLERANCE || ( Math . abs ( prev Ave Hub Delta - ave Hub Delta ) < NUM && Math . abs ( prev Ave Auth Delta - ave Auth Delta ) < NUM ) ) { return BOOL ; } else { prev Hub Vals = curr Hub Vals ; prev Auth Vals = curr Auth Vals ; prev Ave Hub Delta = ave Hub Delta ; prev Ave Auth Delta = ave Auth Delta ; return BOOL ; } }
public AWS 4 Signer Base ( URL endpoint Url , String http Method , String service Name , String region Name ) { this . endpoint Url = endpoint Url ; this . http Method = http Method ; this . service Name = service Name ; this . region Name = region Name ; date Time Format = new Simple Date Format ( ISO 8601 Basic Format ) ; date Time Format . set Time Zone ( new Simple Time Zone ( NUM , STRING ) ) ; date Stamp Format = new Simple Date Format ( Date String Format ) ; date Stamp Format . set Time Zone ( new Simple Time Zone ( NUM , STRING ) ) ; }
public Access Path drop First Field ( ) { if ( fields == null || fields . length == NUM ) return this ; final Soot Field [ ] new Fields ; final Type [ ] new Types ; if ( fields . length > NUM ) { new Fields = new Soot Field [ fields . length - NUM ] ; System . arraycopy ( fields , NUM , new Fields , NUM , fields . length - NUM ) ; new Types = new Type [ fields . length - NUM ] ; System . arraycopy ( field Types , NUM , new Types , NUM , fields . length - NUM ) ; } else { new Fields = null ; new Types = null ; } return new Access Path ( value , new Fields , field Types [ NUM ] , new Types , taint Sub Fields ) ; }
public Access Path drop First Field ( ) { if ( fields == null || fields . length == NUM ) return this ; final Soot Field [ ] new Fields ; final Type [ ] new Types ; if ( fields . length > NUM ) { new Fields = new Soot Field [ fields . length - NUM ] ; System . arraycopy ( fields , NUM , new Fields , NUM , fields . length - NUM ) ; new Types = new Type [ fields . length - NUM ] ; System . arraycopy ( field Types , NUM , new Types , NUM , fields . length - NUM ) ; } else { new Fields = null ; new Types = null ; } return new Access Path ( value , new Fields , field Types [ NUM ] , new Types , taint Sub Fields ) ; }
public Access Path drop First Field ( ) { if ( fields == null || fields . length == NUM ) return this ; final Soot Field [ ] new Fields ; final Type [ ] new Types ; if ( fields . length > NUM ) { new Fields = new Soot Field [ fields . length - NUM ] ; System . arraycopy ( fields , NUM , new Fields , NUM , fields . length - NUM ) ; new Types = new Type [ fields . length - NUM ] ; System . arraycopy ( field Types , NUM , new Types , NUM , fields . length - NUM ) ; } else { new Fields = null ; new Types = null ; } return new Access Path ( value , new Fields , field Types [ NUM ] , new Types , taint Sub Fields ) ; }
public Access Path drop First Field ( ) { if ( fields == null || fields . length == NUM ) return this ; final Soot Field [ ] new Fields ; final Type [ ] new Types ; if ( fields . length > NUM ) { new Fields = new Soot Field [ fields . length - NUM ] ; System . arraycopy ( fields , NUM , new Fields , NUM , fields . length - NUM ) ; new Types = new Type [ fields . length - NUM ] ; System . arraycopy ( field Types , NUM , new Types , NUM , fields . length - NUM ) ; } else { new Fields = null ; new Types = null ; } return new Access Path ( value , new Fields , field Types [ NUM ] , new Types , taint Sub Fields ) ; }
public int add Tmp Store ( IMX Store store ) { if ( null != store ) { int pos = m Tmp Stores . index Of ( store ) ; if ( pos < NUM ) { m Tmp Stores . add ( store ) ; pos = m Tmp Stores . index Of ( store ) ; } return pos ; } return - NUM ; }
public int add Tmp Store ( IMX Store store ) { if ( null != store ) { int pos = m Tmp Stores . index Of ( store ) ; if ( pos < NUM ) { m Tmp Stores . add ( store ) ; pos = m Tmp Stores . index Of ( store ) ; } return pos ; } return - NUM ; }
public int add Tmp Store ( IMX Store store ) { if ( null != store ) { int pos = m Tmp Stores . index Of ( store ) ; if ( pos < NUM ) { m Tmp Stores . add ( store ) ; pos = m Tmp Stores . index Of ( store ) ; } return pos ; } return - NUM ; }
public void start ( ) { if ( runner == null ) { runner = new Thread ( this , STRING ) ; runner . start ( ) ; } }
public void time To Speech ( String time ) { String the Time = time To String ( time ) ; if ( the Time != null ) { text To Speech ( the Time ) ; } else { throw new Illegal Argument Exception ( STRING ) ; } }
public void time To Speech ( String time ) { String the Time = time To String ( time ) ; if ( the Time != null ) { text To Speech ( the Time ) ; } else { throw new Illegal Argument Exception ( STRING ) ; } }
public void time To Speech ( String time ) { String the Time = time To String ( time ) ; if ( the Time != null ) { text To Speech ( the Time ) ; } else { throw new Illegal Argument Exception ( STRING ) ; } }
private void fill Comment Combo ( Combo combo ) { if ( previous Comments == null ) { previous Comments = new Array List ( ) ; } for ( int i = previous Comments . size ( ) - NUM ; i >= NUM ; i -- ) { combo . add ( ( ( String ) previous Comments . get ( i ) ) ) ; } combo . select ( NUM ) ; }
public Manifest Entry Verifier ( Manifest man ) { created Digests = new Hash Map < String , Message Digest > ( NUM ) ; digests = new Array List < Message Digest > ( ) ; manifest Hashes = new Array List < byte [ ] > ( ) ; this . man = man ; }
public void test copy Stream full Block Plus One ( ) throws IO Exception { final String id = STRING ; final int version = NUM ; Random r = new Random ( ) ; final byte [ ] expected = new byte [ BLOCK SIZE + NUM ] ; r . next Bytes ( expected ) ; assert Equals ( STRING , expected . length , repo . copy Stream ( id , version , new Byte Array Input Stream ( expected ) ) ) ; assert Equals ( STRING , NUM , repo . get Block Count ( id , version ) ) ; assert Same Iterator ( STRING , new Long [ ] { NUM , NUM } , repo . blocks ( id , version ) ) ; assert Equals ( STRING , expected , read ( repo . input Stream ( id , version ) ) ) ; }
public void test copy Stream full Block Plus One ( ) throws IO Exception { final String id = STRING ; final int version = NUM ; Random r = new Random ( ) ; final byte [ ] expected = new byte [ BLOCK SIZE + NUM ] ; r . next Bytes ( expected ) ; assert Equals ( STRING , expected . length , repo . copy Stream ( id , version , new Byte Array Input Stream ( expected ) ) ) ; assert Equals ( STRING , NUM , repo . get Block Count ( id , version ) ) ; assert Same Iterator ( STRING , new Long [ ] { NUM , NUM } , repo . blocks ( id , version ) ) ; assert Equals ( STRING , expected , read ( repo . input Stream ( id , version ) ) ) ; }
@ Deprecated public Concurrent Update Solr Client ( String solr Server Url , int queue Size , int thread Count ) { this ( solr Server Url , null , queue Size , thread Count ) ; shutdown Executor = BOOL ; internal Http Client = BOOL ; }
final boolean try Write Lock ( ) { Thread current = Thread . current Thread ( ) ; int c = get State ( ) ; if ( c != NUM ) { int w = exclusive Count ( c ) ; if ( w == NUM || current != get Exclusive Owner Thread ( ) ) return BOOL ; if ( w == MAX COUNT ) throw new Error ( STRING ) ; } if ( ! compare And Set State ( c , c + NUM ) ) return BOOL ; set Exclusive Owner Thread ( current ) ; return BOOL ; }
final public void println ( char [ ] v ) { try { out . println ( v ) ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } }
public Dimension preferred Layout Size ( Container parent ) { return calculate Layout Size ( parent , STRING ) ; }
public static void expand Number ( String number String , Word Relation word Relation , Item token Item ) { int num Digits = number String . length ( ) ; if ( num Digits == NUM ) { } else if ( num Digits == NUM ) { expand Digits ( number String , word Relation , token Item ) ; } else if ( num Digits == NUM ) { expand 2 Digit Number ( number String , word Relation , token Item ) ; } else if ( num Digits == NUM ) { expand 3 Digit Number ( number String , word Relation , token Item ) ; } else if ( num Digits < NUM ) { expand Below 7 Digit Number ( number String , word Relation , token Item ) ; } else if ( num Digits < NUM ) { expand Below 10 Digit Number ( number String , word Relation , token Item ) ; } else if ( num Digits < NUM ) { expand Below 13 Digit Number ( number String , word Relation , token Item ) ; } else { expand Digits ( number String , word Relation , token Item ) ; } }
@ Not Null public static String normalize ( @ Not Null String path ) { int start = NUM ; boolean separator = BOOL ; if ( System Info . is Windows ) { if ( path . starts With ( STRING ) ) { start = NUM ; separator = BOOL ; } else if ( path . starts With ( STRING ) ) { return normalize Tail ( NUM , path , BOOL ) ; } } for ( int i = start ; i < path . length ( ) ; ++ i ) { final char c = path . char At ( i ) ; if ( c == STRING ) { if ( separator ) { return normalize Tail ( i , path , BOOL ) ; } separator = BOOL ; } else if ( c == STRING ) { return normalize Tail ( i , path , separator ) ; } else { separator = BOOL ; } } return path ; }
@ Not Null public static String normalize ( @ Not Null String path ) { int start = NUM ; boolean separator = BOOL ; if ( System Info . is Windows ) { if ( path . starts With ( STRING ) ) { start = NUM ; separator = BOOL ; } else if ( path . starts With ( STRING ) ) { return normalize Tail ( NUM , path , BOOL ) ; } } for ( int i = start ; i < path . length ( ) ; ++ i ) { final char c = path . char At ( i ) ; if ( c == STRING ) { if ( separator ) { return normalize Tail ( i , path , BOOL ) ; } separator = BOOL ; } else if ( c == STRING ) { return normalize Tail ( i , path , separator ) ; } else { separator = BOOL ; } } return path ; }
void bind With ( final Circle circle ) { circles . add ( circle ) ; }
void bind With ( final Circle circle ) { circles . add ( circle ) ; }
void bind With ( final Circle circle ) { circles . add ( circle ) ; }
protected int x ( double xW ) { return ( int ) Math . round ( scale * ( xW + offset X ) + border Left ) ; }
protected int x ( double xW ) { return ( int ) Math . round ( scale * ( xW + offset X ) + border Left ) ; }
public void release ( Plugin Context context ) throws Replicator Exception , Interrupted Exception { try { if ( line Reader != null ) { line Reader . close ( ) ; } } catch ( IO Exception e ) { throw new Replicator Exception ( STRING ) ; } }
public Types Item Provider Adapter Factory ( ) { supported Types . add ( I Editing Domain Item Provider . class ) ; supported Types . add ( I Structured Item Content Provider . class ) ; supported Types . add ( I Tree Item Content Provider . class ) ; supported Types . add ( I Item Label Provider . class ) ; supported Types . add ( I Item Property Source . class ) ; }
public Types Item Provider Adapter Factory ( ) { supported Types . add ( I Editing Domain Item Provider . class ) ; supported Types . add ( I Structured Item Content Provider . class ) ; supported Types . add ( I Tree Item Content Provider . class ) ; supported Types . add ( I Item Label Provider . class ) ; supported Types . add ( I Item Property Source . class ) ; }
public static String [ ] string Array From String ( String string ) { return string Array From String ( string , STRING ) ; }
protected final Result Set execute Scroll Insensitive Query ( String sql String ) throws SQL Exception { final Prepared Statement ps = prepare Statement ( sql String , Result Set . TYPE SCROLL INSENSITIVE , Result Set . CONCUR READ ONLY ) ; ps . execute ( ) ; return ps . get Result Set ( ) ; }
protected final Result Set execute Scroll Insensitive Query ( String sql String ) throws SQL Exception { final Prepared Statement ps = prepare Statement ( sql String , Result Set . TYPE SCROLL INSENSITIVE , Result Set . CONCUR READ ONLY ) ; ps . execute ( ) ; return ps . get Result Set ( ) ; }
@ Suppress Warnings ( STRING ) protected void do Append ( Node el , Node parent ) { parent . append Child ( el ) ; }
@ Suppress Warnings ( STRING ) protected void do Append ( Node el , Node parent ) { parent . append Child ( el ) ; }
@ Suppress Warnings ( STRING ) protected void do Append ( Node el , Node parent ) { parent . append Child ( el ) ; }
@ Suppress Warnings ( STRING ) protected void do Append ( Node el , Node parent ) { parent . append Child ( el ) ; }
protected Object evaluate Left Greater Right ( List elements , String lvalue , String rvalue ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new Array List ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . has Next ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof Structured Content ) { if ( ( o = evaluate Left Greater Right ( ( Structured Content ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM ) { return ( Structured Content ) array . get ( NUM ) ; } return array ; }
protected Object evaluate Left Greater Right ( List elements , String lvalue , String rvalue ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new Array List ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . has Next ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof Structured Content ) { if ( ( o = evaluate Left Greater Right ( ( Structured Content ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM ) { return ( Structured Content ) array . get ( NUM ) ; } return array ; }
protected Object evaluate Left Greater Right ( List elements , String lvalue , String rvalue ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new Array List ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . has Next ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof Structured Content ) { if ( ( o = evaluate Left Greater Right ( ( Structured Content ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM ) { return ( Structured Content ) array . get ( NUM ) ; } return array ; }
protected Object evaluate Left Greater Right ( List elements , String lvalue , String rvalue ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new Array List ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . has Next ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof Structured Content ) { if ( ( o = evaluate Left Greater Right ( ( Structured Content ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM ) { return ( Structured Content ) array . get ( NUM ) ; } return array ; }
protected Object evaluate Left Greater Right ( List elements , String lvalue , String rvalue ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new Array List ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . has Next ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof Structured Content ) { if ( ( o = evaluate Left Greater Right ( ( Structured Content ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM ) { return ( Structured Content ) array . get ( NUM ) ; } return array ; }
public Result Set select ( String query ) throws SQL Exception { if ( ! is Connected ( ) ) { throw new Illegal State Exception ( STRING ) ; } Statement statement ; if ( ! is Cursor Scrollable ( ) ) { statement = m Connection . create Statement ( Result Set . TYPE FORWARD ONLY , Result Set . CONCUR READ ONLY ) ; } else { statement = m Connection . create Statement ( get Supported Cursor Scroll Type ( ) , Result Set . CONCUR READ ONLY ) ; } Result Set result = statement . execute Query ( query ) ; return result ; }
public Result Set select ( String query ) throws SQL Exception { if ( ! is Connected ( ) ) { throw new Illegal State Exception ( STRING ) ; } Statement statement ; if ( ! is Cursor Scrollable ( ) ) { statement = m Connection . create Statement ( Result Set . TYPE FORWARD ONLY , Result Set . CONCUR READ ONLY ) ; } else { statement = m Connection . create Statement ( get Supported Cursor Scroll Type ( ) , Result Set . CONCUR READ ONLY ) ; } Result Set result = statement . execute Query ( query ) ; return result ; }
public Result Set select ( String query ) throws SQL Exception { if ( ! is Connected ( ) ) { throw new Illegal State Exception ( STRING ) ; } Statement statement ; if ( ! is Cursor Scrollable ( ) ) { statement = m Connection . create Statement ( Result Set . TYPE FORWARD ONLY , Result Set . CONCUR READ ONLY ) ; } else { statement = m Connection . create Statement ( get Supported Cursor Scroll Type ( ) , Result Set . CONCUR READ ONLY ) ; } Result Set result = statement . execute Query ( query ) ; return result ; }
public void wake Up Update Thread ( ) { synchronized ( run Lock ) { run Lock . notify All ( ) ; } }
public void wake Up Update Thread ( ) { synchronized ( run Lock ) { run Lock . notify All ( ) ; } }
public void wake Up Update Thread ( ) { synchronized ( run Lock ) { run Lock . notify All ( ) ; } }
public void wake Up Update Thread ( ) { synchronized ( run Lock ) { run Lock . notify All ( ) ; } }
public static void write Extension Media ( Output Stream the Os , String the Str ) throws IO Exception { the Os . write ( the Str . get Bytes ( Standard Charsets . UTF 8 ) ) ; the Os . write ( ( byte ) NUM ) ; }
public static void write Extension Media ( Output Stream the Os , String the Str ) throws IO Exception { the Os . write ( the Str . get Bytes ( Standard Charsets . UTF 8 ) ) ; the Os . write ( ( byte ) NUM ) ; }
public static void write Extension Media ( Output Stream the Os , String the Str ) throws IO Exception { the Os . write ( the Str . get Bytes ( Standard Charsets . UTF 8 ) ) ; the Os . write ( ( byte ) NUM ) ; }
public static void write Extension Media ( Output Stream the Os , String the Str ) throws IO Exception { the Os . write ( the Str . get Bytes ( Standard Charsets . UTF 8 ) ) ; the Os . write ( ( byte ) NUM ) ; }
public static void write Extension Media ( Output Stream the Os , String the Str ) throws IO Exception { the Os . write ( the Str . get Bytes ( Standard Charsets . UTF 8 ) ) ; the Os . write ( ( byte ) NUM ) ; }
public Gradle Distribution deserialize From String ( String distribution String ) { Preconditions . check Not Null ( distribution String ) ; String local Installation Prefix = STRING ; if ( distribution String . starts With ( local Installation Prefix ) && distribution String . ends With ( STRING ) ) { String local Installation Dir = distribution String . substring ( local Installation Prefix . length ( ) , distribution String . length ( ) - NUM ) ; return Gradle Distribution . for Local Installation ( new File ( local Installation Dir ) ) ; } String remote Distribution Prefix = STRING ; if ( distribution String . starts With ( remote Distribution Prefix ) && distribution String . ends With ( STRING ) ) { String remote Distribution Uri = distribution String . substring ( remote Distribution Prefix . length ( ) , distribution String . length ( ) - NUM ) ; return Gradle Distribution . for Remote Distribution ( create URI ( remote Distribution Uri ) ) ; } String version Prefix = STRING ; if ( distribution String . starts With ( version Prefix ) && distribution String . ends With ( STRING ) ) { String version = distribution String . substring ( version Prefix . length ( ) , distribution String . length ( ) - NUM ) ; return Gradle Distribution . for Version ( version ) ; } String wrapper String = STRING ; if ( distribution String . equals ( wrapper String ) ) { return Gradle Distribution . from Build ( ) ; } String message = String . format ( STRING , distribution String ) ; throw new Runtime Exception ( message ) ; }
public Gradle Distribution deserialize From String ( String distribution String ) { Preconditions . check Not Null ( distribution String ) ; String local Installation Prefix = STRING ; if ( distribution String . starts With ( local Installation Prefix ) && distribution String . ends With ( STRING ) ) { String local Installation Dir = distribution String . substring ( local Installation Prefix . length ( ) , distribution String . length ( ) - NUM ) ; return Gradle Distribution . for Local Installation ( new File ( local Installation Dir ) ) ; } String remote Distribution Prefix = STRING ; if ( distribution String . starts With ( remote Distribution Prefix ) && distribution String . ends With ( STRING ) ) { String remote Distribution Uri = distribution String . substring ( remote Distribution Prefix . length ( ) , distribution String . length ( ) - NUM ) ; return Gradle Distribution . for Remote Distribution ( create URI ( remote Distribution Uri ) ) ; } String version Prefix = STRING ; if ( distribution String . starts With ( version Prefix ) && distribution String . ends With ( STRING ) ) { String version = distribution String . substring ( version Prefix . length ( ) , distribution String . length ( ) - NUM ) ; return Gradle Distribution . for Version ( version ) ; } String wrapper String = STRING ; if ( distribution String . equals ( wrapper String ) ) { return Gradle Distribution . from Build ( ) ; } String message = String . format ( STRING , distribution String ) ; throw new Runtime Exception ( message ) ; }
protected Key Pair Generator ( String algorithm ) { this . algorithm = algorithm ; }
public void test Active Join ( ) throws Throwable { test Server Join ( Member . Type . ACTIVE ) ; }
public void write No Scale ( Image c , Component i ) { if ( page == null ) { newpage ( ) ; } int x = x0 + width - ( c . get Width ( null ) + charwidth ) ; int y = y0 + ( linenum * lineheight ) + lineascent ; if ( page != null && pagenum >= pr First ) { page . draw Image ( c , x , y , c . get Width ( null ) , c . get Height ( null ) , null ) ; } }
public void write No Scale ( Image c , Component i ) { if ( page == null ) { newpage ( ) ; } int x = x0 + width - ( c . get Width ( null ) + charwidth ) ; int y = y0 + ( linenum * lineheight ) + lineascent ; if ( page != null && pagenum >= pr First ) { page . draw Image ( c , x , y , c . get Width ( null ) , c . get Height ( null ) , null ) ; } }
private void remove Interest ( Selectable Channel channel , int operation ) { Selection Key key = channel . key For ( selector ) ; key . interest Ops ( key . interest Ops ( ) & ( ~ operation ) ) ; }
private void remove Interest ( Selectable Channel channel , int operation ) { Selection Key key = channel . key For ( selector ) ; key . interest Ops ( key . interest Ops ( ) & ( ~ operation ) ) ; }
public Private Key load Private Key ( ) throws Exception { if ( default Keys ) { return get Private Key From String ( RSA Key Loader . DEFAULT PKEY ) ; } if ( pri Key == null ) { File Reader f = new File Reader ( path + STRING + this . id ) ; Buffered Reader r = new Buffered Reader ( f ) ; String tmp = STRING ; String key = STRING ; while ( ( tmp = r . read Line ( ) ) != null ) { key = key + tmp ; } f . close ( ) ; r . close ( ) ; pri Key = get Private Key From String ( key ) ; } return pri Key ; }
public Consensus remove Consensus ( int id ) { consensuses Lock . lock ( ) ; Consensus consensus = consensuses . remove ( id ) ; for ( int i = last Removed CID ; i < id ; i ++ ) consensuses . remove ( i ) ; last Removed CID = id ; consensuses Lock . unlock ( ) ; out Of Context Lock . lock ( ) ; out Of Context Proposes . remove ( id ) ; out Of Context . remove ( id ) ; out Of Context Lock . unlock ( ) ; return consensus ; }
protected void estimate Cardinality ( Statement Pattern Node sp , final AST 2 B Op Context ctx , final I Binding Set exogenous Bindings , final int nr Exogeneous Bindings ) { final Atomic Boolean uses Exogeneous Bindings = new Atomic Boolean ( BOOL ) ; final IV < ? , ? > s = get IV ( sp . s ( ) , exogenous Bindings , uses Exogeneous Bindings ) ; final IV < ? , ? > p = get IV ( sp . p ( ) , exogenous Bindings , uses Exogeneous Bindings ) ; final IV < ? , ? > o = get IV ( sp . o ( ) , exogenous Bindings , uses Exogeneous Bindings ) ; final IV < ? , ? > c = get IV ( sp . c ( ) , exogenous Bindings , uses Exogeneous Bindings ) ; final int exogenous Bindings Adjustment Factor = uses Exogeneous Bindings . get ( ) ? Math . max ( NUM , nr Exogeneous Bindings ) : NUM ; estimate Cardinalities ( sp , s , p , o , c , ctx , exogenous Bindings Adjustment Factor ) ; }
private int keep Sprite On Map Y ( Sprite sprite , int sy ) { sy = Math . max ( sy , NUM ) ; if ( wh != NUM ) { sy = Math . min ( sy , Math . max ( get Height ( ) + svy , convert World Y To Scaled Screen ( wh ) ) - sprite . get Height ( ) ) ; } return sy ; }
private int keep Sprite On Map Y ( Sprite sprite , int sy ) { sy = Math . max ( sy , NUM ) ; if ( wh != NUM ) { sy = Math . min ( sy , Math . max ( get Height ( ) + svy , convert World Y To Scaled Screen ( wh ) ) - sprite . get Height ( ) ) ; } return sy ; }
public boolean offer ( E event , int task Id ) throws Interrupted Exception { assert Not Done ( ) ; if ( predicate . match ( event ) ) { this . matched [ task Id ] = BOOL ; for ( boolean match : matched ) { if ( ! match ) return BOOL ; } response Queue . put ( new Event Holder ( event ) ) ; done = BOOL ; return BOOL ; } else return BOOL ; }
public void find And Undo ( Iterator it ) { while ( it . has Next ( ) ) { find And Undo ( it . next ( ) ) ; } }
public void find And Undo ( Iterator it ) { while ( it . has Next ( ) ) { find And Undo ( it . next ( ) ) ; } }
public void find And Undo ( Iterator it ) { while ( it . has Next ( ) ) { find And Undo ( it . next ( ) ) ; } }
public void find And Undo ( Iterator it ) { while ( it . has Next ( ) ) { find And Undo ( it . next ( ) ) ; } }
public static String remove Order Term ( Http Servlet Request request , Http Servlet Response response ) { Shopping Cart cart = get Cart Object ( request ) ; String term Index Str = request . get Parameter ( STRING ) ; if ( Util Validate . is Not Empty ( term Index Str ) ) { try { Integer term Index = Integer . parse Int ( term Index Str ) ; if ( term Index >= NUM ) { List < Generic Value > order Terms = cart . get Order Terms ( ) ; if ( order Terms != null && order Terms . size ( ) > term Index ) { cart . remove Order Term ( term Index ) ; } } } catch ( Number Format Exception e ) { Debug . log Warning ( e , STRING + term Index Str , module ) ; } } return STRING ; }
@ Override public < V > Method Vault < V > new Method ( Class < ? > type , String method Name , Class < ? > [ ] param Types ) { Objects . require Non Null ( type ) ; Method Vault < V > method = new Method Rec ( type , method Name , param Types ) ; if ( method != null ) { return method ; } throw new Illegal State Exception ( L . l ( STRING , type . get Simple Name ( ) , method Name , Arrays . as List ( param Types ) ) ) ; }
private void clean Up History ( ) { if ( ! m History Of Numbers . is Empty ( ) && m History Of Numbers . size ( ) >= MAX HISTORY SIZE ) { for ( int i = NUM ; i < Math . max ( NUM , MAX HISTORY SIZE / NUM ) ; i ++ ) { m Previous Numbers . remove ( m History Of Numbers . remove First ( ) ) ; } } }
public Edge ( S src , Symbol symbol , S dest ) { this . src = src ; this . symbol = symbol ; this . dest = dest ; this . src Item = src . get First Item ( ) ; this . hash Cache = calc Hash Code ( ) ; }
private void create ( ) { Document Builder Factory doc B Fac ; Document Builder doc Build ; try { doc B Fac = Document Builder Factory . new Instance ( ) ; doc Build = doc B Fac . new Document Builder ( ) ; doc = doc Build . new Document ( ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; return ; } root Element = doc . create Element ( STRING ) ; doc . append Child ( root Element ) ; non Validated Requests Element = doc . create Element ( STRING ) ; validated Requests Element = doc . create Element ( STRING ) ; root Element . append Child ( non Validated Requests Element ) ; root Element . append Child ( validated Requests Element ) ; write XML File ( ) ; }
public Ignite Spi Version Check Exception ( Throwable cause ) { this ( cause . get Message ( ) , cause ) ; }
private static C Inlining Result inline Function Silently ( final J Frame parent , final I View Container view Container , final Zy Graph graph , final I Navi Code Node node , final I Navi Instruction instruction , final I Navi Function function ) { final I Navi Function inline Function = prepare Function Inlining ( parent , node , instruction , function , view Container ) ; if ( inline Function == null ) { return null ; } else if ( inline Function . get Basic Block Count ( ) == NUM ) { return null ; } else { try { if ( ! inline Function . is Loaded ( ) ) { inline Function . load ( ) ; } return C Inlining Helper . inline Code Node ( graph . get Raw View ( ) , node , instruction , inline Function ) ; } catch ( final Couldnt Load Data Exception e ) { exception Dialog ( parent , inline Function , e ) ; } } return null ; }
public void on Error ( Diagnostic Listener < Java File Object > callback ) { errors Delegate = callback ; }
public void on Error ( Diagnostic Listener < Java File Object > callback ) { errors Delegate = callback ; }
protected void response Sent ( Stream Response Message response Message ) { if ( sync Protocol != null ) sync Protocol . response Sent ( response Message ) ; }
@ Exception Handler ( { Region Not Found Exception . class , Resource Not Found Exception . class } ) @ Response Body @ Response Status ( Http Status . NOT FOUND ) public String handle ( final Runtime Exception e ) { return convert Error As Json ( e . get Message ( ) ) ; }
@ Exception Handler ( { Region Not Found Exception . class , Resource Not Found Exception . class } ) @ Response Body @ Response Status ( Http Status . NOT FOUND ) public String handle ( final Runtime Exception e ) { return convert Error As Json ( e . get Message ( ) ) ; }
@ Exception Handler ( { Region Not Found Exception . class , Resource Not Found Exception . class } ) @ Response Body @ Response Status ( Http Status . NOT FOUND ) public String handle ( final Runtime Exception e ) { return convert Error As Json ( e . get Message ( ) ) ; }
JSON Stringer close ( Scope empty , Scope nonempty , String close Bracket ) throws JSON Exception { Scope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new JSON Exception ( STRING ) ; } stack . remove ( stack . size ( ) - NUM ) ; if ( context == nonempty ) { newline ( ) ; } out . append ( close Bracket ) ; return this ; }
JSON Stringer close ( Scope empty , Scope nonempty , String close Bracket ) throws JSON Exception { Scope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new JSON Exception ( STRING ) ; } stack . remove ( stack . size ( ) - NUM ) ; if ( context == nonempty ) { newline ( ) ; } out . append ( close Bracket ) ; return this ; }
JSON Stringer close ( Scope empty , Scope nonempty , String close Bracket ) throws JSON Exception { Scope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new JSON Exception ( STRING ) ; } stack . remove ( stack . size ( ) - NUM ) ; if ( context == nonempty ) { newline ( ) ; } out . append ( close Bracket ) ; return this ; }
public int array Index Scale ( Class clazz ) { if ( ! clazz . is Array ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } return array Index Scale 0 ( clazz ) ; }
@ Override public void write Attribute ( String local Name , String value ) throws XML Stream Exception { write Attribute ( null , null , local Name , value ) ; }
private List < M Browse Field > init Browser Table ( ) { List < M Browse Field > list = init Browser Data ( ) ; if ( list . size ( ) == NUM ) { F Dialog . error ( get Window No ( ) , m frame , STRING , STRING ) ; log . log ( Level . SEVERE , STRING + m View . get Name ( ) ) ; return null ; } log . finest ( STRING + list . size ( ) ) ; return list ; }
private List < M Browse Field > init Browser Table ( ) { List < M Browse Field > list = init Browser Data ( ) ; if ( list . size ( ) == NUM ) { F Dialog . error ( get Window No ( ) , m frame , STRING , STRING ) ; log . log ( Level . SEVERE , STRING + m View . get Name ( ) ) ; return null ; } log . finest ( STRING + list . size ( ) ) ; return list ; }
public static Object try Parse ( String value ) { try { return parse By Datatype Name ( value , UUID Datatype . NAME ) ; } catch ( Exception ignored ) { } try { return parse By Datatype Name ( value , Date Time Datatype . NAME ) ; } catch ( Parse Exception ignored ) { } try { return parse By Datatype Name ( value , Time Datatype . NAME ) ; } catch ( Parse Exception ignored ) { } try { return parse By Datatype Name ( value , Date Datatype . NAME ) ; } catch ( Parse Exception ignored ) { } try { return parse By Datatype Name ( value , Big Decimal Datatype . NAME ) ; } catch ( Parse Exception ignored ) { } try { return parse By Datatype Name ( value , Double Datatype . NAME ) ; } catch ( Parse Exception ignored ) { } try { if ( value . equals Ignore Case ( STRING ) || value . equals Ignore Case ( STRING ) ) { return parse By Datatype Name ( value , Boolean Datatype . NAME ) ; } } catch ( Parse Exception ignored ) { } return value ; }
public D Subject Key Identifier ( J Dialog parent , Public Key subject Public Key ) { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; this . subject Public Key = subject Public Key ; init Components ( ) ; }
public void draw Line ( List < mx Point > pts , Map < String , Object > style ) { String stroke Color = mx Utils . get String ( style , mx Constants . STYLE STROKECOLOR ) ; int stroke Width = ( int ) ( mx Utils . get Int ( style , mx Constants . STYLE STROKEWIDTH , NUM ) * scale ) ; if ( stroke Color != null && stroke Width > NUM ) { mx Point last = pts . get ( NUM ) ; for ( int i = NUM ; i < pts . size ( ) ; i ++ ) { mx Point pt = pts . get ( i ) ; draw Segment ( ( int ) last . get X ( ) , ( int ) last . get Y ( ) , ( int ) pt . get X ( ) , ( int ) pt . get Y ( ) , stroke Color , stroke Width ) ; last = pt ; } } }
public void clear ( ) { m text Area . set Text ( STRING ) ; }
public Rest Api ( String name ) { if ( name . starts With ( STRING ) ) { name = name . substring ( NUM ) ; } url = new String Builder ( ) ; url . append ( GWT . get Host Page Base URL ( ) ) ; url . append ( name ) ; }
public Rest Api ( String name ) { if ( name . starts With ( STRING ) ) { name = name . substring ( NUM ) ; } url = new String Builder ( ) ; url . append ( GWT . get Host Page Base URL ( ) ) ; url . append ( name ) ; }
@ Suppress Warnings ( { STRING , STRING } ) public static int select Pivot Index ( Object ar [ ] , int left , int right , Comparator comparator ) { int mid Index = ( left + right ) / NUM ; int low Index = left ; if ( comparator . compare ( ar [ low Index ] , ar [ mid Index ] ) >= NUM ) { low Index = mid Index ; mid Index = left ; } if ( comparator . compare ( ar [ right ] , ar [ low Index ] ) <= NUM ) { return low Index ; } else if ( comparator . compare ( ar [ right ] , ar [ mid Index ] ) <= NUM ) { return right ; } return mid Index ; }
public static Input Stream execute Solr Command And Get Input Stream With Timeout ( int timeout , String command ) throws IO Exception { URL obj = new URL ( command ) ; Http URL Connection con = ( Http URL Connection ) obj . open Connection ( ) ; con . set Request Method ( STRING ) ; con . set Connect Timeout ( timeout ) ; con . set Read Timeout ( timeout ) ; return con . get Input Stream ( ) ; }
protected Function < Object [ ] , Object > create Key Generator ( Schema schema , Table Id column Set Name , List < Column > columns ) { if ( schema != null ) { int [ ] record Indexes = indexes For Columns ( columns ) ; Field [ ] fields = fields For Columns ( schema , columns ) ; int num Fields = record Indexes . length ; Value Converter [ ] converters = converters For Columns ( schema , column Set Name , columns , null , null ) ; return null ; } return null ; }
protected Function < Object [ ] , Object > create Key Generator ( Schema schema , Table Id column Set Name , List < Column > columns ) { if ( schema != null ) { int [ ] record Indexes = indexes For Columns ( columns ) ; Field [ ] fields = fields For Columns ( schema , columns ) ; int num Fields = record Indexes . length ; Value Converter [ ] converters = converters For Columns ( schema , column Set Name , columns , null , null ) ; return null ; } return null ; }
protected Function < Object [ ] , Object > create Key Generator ( Schema schema , Table Id column Set Name , List < Column > columns ) { if ( schema != null ) { int [ ] record Indexes = indexes For Columns ( columns ) ; Field [ ] fields = fields For Columns ( schema , columns ) ; int num Fields = record Indexes . length ; Value Converter [ ] converters = converters For Columns ( schema , column Set Name , columns , null , null ) ; return null ; } return null ; }
protected Function < Object [ ] , Object > create Key Generator ( Schema schema , Table Id column Set Name , List < Column > columns ) { if ( schema != null ) { int [ ] record Indexes = indexes For Columns ( columns ) ; Field [ ] fields = fields For Columns ( schema , columns ) ; int num Fields = record Indexes . length ; Value Converter [ ] converters = converters For Columns ( schema , column Set Name , columns , null , null ) ; return null ; } return null ; }
protected Object take Get Method Value By Field ( Data Support data Support , Field field ) throws Security Exception , No Such Method Exception , Illegal Argument Exception , Illegal Access Exception , Invocation Target Exception { if ( should Get Or Set ( data Support , field ) ) { String get Method Name = make Getter Method Name ( field ) ; return Dynamic Executor . send ( data Support , get Method Name , null , data Support . get Class ( ) , null ) ; } return null ; }
public static Placeholder Fragment new Instance ( int section Number ) { Placeholder Fragment fragment = new Placeholder Fragment ( ) ; Bundle args = new Bundle ( ) ; args . put Int ( ARG SECTION NUMBER , section Number ) ; fragment . set Arguments ( args ) ; return fragment ; }
private static Marker [ ] create Marker Array ( final List < Double > initial Five , final double p ) { final int count Observed = initial Five == null ? - NUM : initial Five . size ( ) ; if ( count Observed < PSQUARE CONSTANT ) { throw new Math Illegal Argument Exception ( Localized Core Formats . INSUFFICIENT OBSERVED POINTS IN SAMPLE , count Observed , PSQUARE CONSTANT ) ; } Collections . sort ( initial Five ) ; return new Marker [ ] { new Marker ( ) , new Marker ( initial Five . get ( NUM ) , NUM , NUM , NUM ) , new Marker ( initial Five . get ( NUM ) , NUM + NUM * p , p / NUM , NUM ) , new Marker ( initial Five . get ( NUM ) , NUM + NUM * p , p , NUM ) , new Marker ( initial Five . get ( NUM ) , NUM + NUM * p , ( NUM + p ) / NUM , NUM ) , new Marker ( initial Five . get ( NUM ) , NUM , NUM , NUM ) } ; }
public void writing Request Headers ( ) { if ( sent Request Millis != - NUM ) throw new Illegal State Exception ( ) ; sent Request Millis = System . current Time Millis ( ) ; }
public void writing Request Headers ( ) { if ( sent Request Millis != - NUM ) throw new Illegal State Exception ( ) ; sent Request Millis = System . current Time Millis ( ) ; }
public void writing Request Headers ( ) { if ( sent Request Millis != - NUM ) throw new Illegal State Exception ( ) ; sent Request Millis = System . current Time Millis ( ) ; }
private boolean put Internal ( String variable , Object value ) { Object old Value = values . get ( variable ) ; values . put ( variable , value ) ; if ( old Value == null ) { return value != null ; } else { return ! old Value . equals ( value ) ; } }
private boolean put Internal ( String variable , Object value ) { Object old Value = values . get ( variable ) ; values . put ( variable , value ) ; if ( old Value == null ) { return value != null ; } else { return ! old Value . equals ( value ) ; } }
private List < Object > create Object List ( Object object , List < Object > object List ) { if ( are Filters Passed ( object ) && ! get Expanded State ( object ) ) { if ( children Loaded ( object ) ) { expand To Level ( object , NUM ) ; } else { if ( object List == null ) { object List = new Array List < > ( ) ; } object List . add ( object ) ; } } Object parent = get Parent Element ( object ) ; if ( null != parent ) { create Object List ( parent , object List ) ; } return object List ; }
private List < Object > create Object List ( Object object , List < Object > object List ) { if ( are Filters Passed ( object ) && ! get Expanded State ( object ) ) { if ( children Loaded ( object ) ) { expand To Level ( object , NUM ) ; } else { if ( object List == null ) { object List = new Array List < > ( ) ; } object List . add ( object ) ; } } Object parent = get Parent Element ( object ) ; if ( null != parent ) { create Object List ( parent , object List ) ; } return object List ; }
private List < Object > create Object List ( Object object , List < Object > object List ) { if ( are Filters Passed ( object ) && ! get Expanded State ( object ) ) { if ( children Loaded ( object ) ) { expand To Level ( object , NUM ) ; } else { if ( object List == null ) { object List = new Array List < > ( ) ; } object List . add ( object ) ; } } Object parent = get Parent Element ( object ) ; if ( null != parent ) { create Object List ( parent , object List ) ; } return object List ; }
public void copy Reader ( String encoding , Reader r ) throws IO Exception { super . set Content Encoding ( encoding ) ; String s = read String ( r ) ; content = s . get Bytes ( encoding ) ; }
public void load ( Path settings Path ) { m Loading Settings = BOOL ; if ( Files . exists ( settings Path ) ) { m Log . info ( STRING + settings Path . to String ( ) + STRING ) ; JAXB Context context = null ; Input Stream in = null ; try { in = new File Input Stream ( settings Path . to String ( ) ) ; try { context = JAXB Context . new Instance ( Settings . class ) ; Unmarshaller m = context . create Unmarshaller ( ) ; m Settings = ( Settings ) m . unmarshal ( in ) ; } catch ( JAXB Exception e ) { m Log . error ( STRING + STRING , e ) ; } } catch ( Exception e ) { m Log . error ( STRING + STRING + settings Path . to String ( ) + STRING , e ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IO Exception e ) { m Log . error ( STRING + STRING , e ) ; } } } } else { m Log . info ( STRING + settings Path . to String ( ) + STRING ) ; } if ( m Settings == null ) { m Settings = new Settings ( ) ; } load Tuner Configuration Model ( ) ; m Loading Settings = BOOL ; }
public void load ( Path settings Path ) { m Loading Settings = BOOL ; if ( Files . exists ( settings Path ) ) { m Log . info ( STRING + settings Path . to String ( ) + STRING ) ; JAXB Context context = null ; Input Stream in = null ; try { in = new File Input Stream ( settings Path . to String ( ) ) ; try { context = JAXB Context . new Instance ( Settings . class ) ; Unmarshaller m = context . create Unmarshaller ( ) ; m Settings = ( Settings ) m . unmarshal ( in ) ; } catch ( JAXB Exception e ) { m Log . error ( STRING + STRING , e ) ; } } catch ( Exception e ) { m Log . error ( STRING + STRING + settings Path . to String ( ) + STRING , e ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IO Exception e ) { m Log . error ( STRING + STRING , e ) ; } } } } else { m Log . info ( STRING + settings Path . to String ( ) + STRING ) ; } if ( m Settings == null ) { m Settings = new Settings ( ) ; } load Tuner Configuration Model ( ) ; m Loading Settings = BOOL ; }
public void save Pc ( int pc ) { saved Pc = pc ; }
@ Override public void draw Range Gridline ( Graphics 2 D g2 , Category Plot plot , Value Axis axis , Rectangle 2 D data Area , double value ) { Range range = axis . get Range ( ) ; if ( ! range . contains ( value ) ) { return ; } Plot Orientation orientation = plot . get Orientation ( ) ; double v = axis . value To Java 2 D ( value , data Area , plot . get Range Axis Edge ( ) ) ; Line 2 D line = null ; if ( orientation == Plot Orientation . HORIZONTAL ) { line = new Line 2 D . Double ( v , data Area . get Min Y ( ) , v , data Area . get Max Y ( ) ) ; } else if ( orientation == Plot Orientation . VERTICAL ) { line = new Line 2 D . Double ( data Area . get Min X ( ) , v , data Area . get Max X ( ) , v ) ; } Paint paint = plot . get Range Gridline Paint ( ) ; if ( paint == null ) { paint = Category Plot . DEFAULT GRIDLINE PAINT ; } g2 . set Paint ( paint ) ; Stroke stroke = plot . get Range Gridline Stroke ( ) ; if ( stroke == null ) { stroke = Category Plot . DEFAULT GRIDLINE STROKE ; } g2 . set Stroke ( stroke ) ; g2 . draw ( line ) ; }
public void add Pass Through Condition ( Pass Through Or Generate Rule Condition condition ) { pass Through Conditions . add ( condition ) ; }
@ Override public To Double Function < Stream < Tuple 2 < F , Double > > > dist ( Stream < Tuple 2 < F , Double > > features 1 ) { Object 2 Double Map < F > aux Map = new Object 2 Double Open Hash Map < > ( ) ; aux Map . default Return Value ( NUM ) ; Double Adder norm 1 = new Double Adder ( ) ; features 1 . for Each ( null ) ; if ( norm 1 . double Value ( ) == NUM ) { return null ; } return null ; }
@ Override public To Double Function < Stream < Tuple 2 < F , Double > > > dist ( Stream < Tuple 2 < F , Double > > features 1 ) { Object 2 Double Map < F > aux Map = new Object 2 Double Open Hash Map < > ( ) ; aux Map . default Return Value ( NUM ) ; Double Adder norm 1 = new Double Adder ( ) ; features 1 . for Each ( null ) ; if ( norm 1 . double Value ( ) == NUM ) { return null ; } return null ; }
private void write ( Coordinate [ ] coords , int level , String Buffer buf ) { start Line ( STRING , level , buf ) ; boolean is New Line = BOOL ; for ( int i = NUM ; i < coords . length ; i ++ ) { if ( i > NUM ) { buf . append ( TUPLE SEPARATOR ) ; } if ( is New Line ) { start Line ( STRING , level , buf ) ; is New Line = BOOL ; } write ( coords [ i ] , buf ) ; if ( ( i + NUM ) % max Coordinates Per Line == NUM && i < coords . length - NUM ) { buf . append ( STRING ) ; is New Line = BOOL ; } } buf . append ( STRING ) ; }
public synchronized void update Patient Obs Ui ( int chart Num ) { m Observations = m Chart Helper . get Observations ( m Patient Uuid ) ; Map < String , Obs > latest Observations = new Hash Map < > ( m Chart Helper . get Latest Observations ( m Patient Uuid ) ) ; List < Order > orders = m Chart Helper . get Orders ( m Patient Uuid ) ; m Orders By Uuid = new Hash Map < > ( ) ; for ( Order order : orders ) { m Orders By Uuid . put ( order . uuid , order ) ; } LOG . d ( STRING + m Observations . size ( ) + STRING + orders . size ( ) + STRING ) ; Local Date admission Date = get Observed Date ( latest Observations , Concept Uuids . ADMISSION DATE UUID ) ; Local Date first Symptoms Date = get Observed Date ( latest Observations , Concept Uuids . FIRST SYMPTOM DATE UUID ) ; m Ui . update Admission Date And First Symptoms Date Ui ( admission Date , first Symptoms Date ) ; m Ui . update Weight Ui ( latest Observations ) ; m Ui . update Ebola Pcr Test Result Ui ( latest Observations ) ; m Ui . update Pregnancy And Iv Status Ui ( latest Observations ) ; last Chart Index = chart Num ; m Ui . update Tiles And Grid ( m Charts . get ( chart Num ) , latest Observations , m Observations , orders , admission Date , first Symptoms Date ) ; }
public synchronized void update Patient Obs Ui ( int chart Num ) { m Observations = m Chart Helper . get Observations ( m Patient Uuid ) ; Map < String , Obs > latest Observations = new Hash Map < > ( m Chart Helper . get Latest Observations ( m Patient Uuid ) ) ; List < Order > orders = m Chart Helper . get Orders ( m Patient Uuid ) ; m Orders By Uuid = new Hash Map < > ( ) ; for ( Order order : orders ) { m Orders By Uuid . put ( order . uuid , order ) ; } LOG . d ( STRING + m Observations . size ( ) + STRING + orders . size ( ) + STRING ) ; Local Date admission Date = get Observed Date ( latest Observations , Concept Uuids . ADMISSION DATE UUID ) ; Local Date first Symptoms Date = get Observed Date ( latest Observations , Concept Uuids . FIRST SYMPTOM DATE UUID ) ; m Ui . update Admission Date And First Symptoms Date Ui ( admission Date , first Symptoms Date ) ; m Ui . update Weight Ui ( latest Observations ) ; m Ui . update Ebola Pcr Test Result Ui ( latest Observations ) ; m Ui . update Pregnancy And Iv Status Ui ( latest Observations ) ; last Chart Index = chart Num ; m Ui . update Tiles And Grid ( m Charts . get ( chart Num ) , latest Observations , m Observations , orders , admission Date , first Symptoms Date ) ; }
public static List < Entry > load Entries From File ( String path ) { File sdcard = Environment . get External Storage Directory ( ) ; File file = new File ( sdcard , path ) ; List < Entry > entries = new Array List < Entry > ( ) ; try { @ Suppress Warnings ( STRING ) Buffered Reader br = new Buffered Reader ( new File Reader ( file ) ) ; String line ; while ( ( line = br . read Line ( ) ) != null ) { String [ ] split = line . split ( STRING ) ; if ( split . length <= NUM ) { entries . add ( new Entry ( Float . parse Float ( split [ NUM ] ) , Integer . parse Int ( split [ NUM ] ) ) ) ; } else { float [ ] vals = new float [ split . length - NUM ] ; for ( int i = NUM ; i < vals . length ; i ++ ) { vals [ i ] = Float . parse Float ( split [ i ] ) ; } entries . add ( new Bar Entry ( vals , Integer . parse Int ( split [ split . length - NUM ] ) ) ) ; } } } catch ( IO Exception e ) { Log . e ( LOG , e . to String ( ) ) ; } return entries ; }
@ Suppress Warnings ( STRING ) @ Gwt Incompatible ( STRING ) public static < K extends Object , V extends Object > void write Map ( Map < K , V > map , Object Output Stream stream ) throws IO Exception { stream . write Int ( map . size ( ) ) ; for ( Map . Entry < K , V > entry : map . entry Set ( ) ) { stream . write Object ( entry . get Key ( ) ) ; stream . write Object ( entry . get Value ( ) ) ; } }
@ Suppress Warnings ( STRING ) @ Gwt Incompatible ( STRING ) public static < K extends Object , V extends Object > void write Map ( Map < K , V > map , Object Output Stream stream ) throws IO Exception { stream . write Int ( map . size ( ) ) ; for ( Map . Entry < K , V > entry : map . entry Set ( ) ) { stream . write Object ( entry . get Key ( ) ) ; stream . write Object ( entry . get Value ( ) ) ; } }
@ Suppress Warnings ( STRING ) @ Gwt Incompatible ( STRING ) public static < K extends Object , V extends Object > void write Map ( Map < K , V > map , Object Output Stream stream ) throws IO Exception { stream . write Int ( map . size ( ) ) ; for ( Map . Entry < K , V > entry : map . entry Set ( ) ) { stream . write Object ( entry . get Key ( ) ) ; stream . write Object ( entry . get Value ( ) ) ; } }
public boolean remove Capabilities Filter Listener ( Capabilities Filter Change Listener l ) { return m Capabilities Filter Change Listeners . remove ( l ) ; }
public String [ ] create User Flags ( ) { String [ ] flags = new String [ user Flags . size ( ) ] ; for ( int i = NUM ; i < user Flags . size ( ) ; i ++ ) { flags [ i ] = user Flags . get ( i ) ; } return flags ; }
public void end Of Suite ( ) throws Interrupted Exception { if ( asynchronous Thread == null ) { throw new Illegal State Exception ( STRING ) ; } this . keep Running = BOOL ; asynchronous Thread . join ( ) ; }
public void end Of Suite ( ) throws Interrupted Exception { if ( asynchronous Thread == null ) { throw new Illegal State Exception ( STRING ) ; } this . keep Running = BOOL ; asynchronous Thread . join ( ) ; }
public void end Of Suite ( ) throws Interrupted Exception { if ( asynchronous Thread == null ) { throw new Illegal State Exception ( STRING ) ; } this . keep Running = BOOL ; asynchronous Thread . join ( ) ; }
public void add Zone Change Listener ( Zone Change Listener listener ) { zone Change Listeners . add ( listener ) ; }
public void add Zone Change Listener ( Zone Change Listener listener ) { zone Change Listeners . add ( listener ) ; }
protected static void execute ( Review Db db , String sql ) throws SQL Exception { try ( Statement s = new Statement ( db ) ) { s . execute ( sql ) ; } }
private int count ( boolean [ ] array Setted , byte [ ] [ ] array , byte [ ] value ) { if ( value != null ) { int counter = NUM ; for ( int i = NUM ; i < array . length ; i ++ ) { if ( array Setted != null && array Setted [ i ] && Arrays . equals ( value , array [ i ] ) ) { counter ++ ; } } return counter ; } return NUM ; }
private int count ( boolean [ ] array Setted , byte [ ] [ ] array , byte [ ] value ) { if ( value != null ) { int counter = NUM ; for ( int i = NUM ; i < array . length ; i ++ ) { if ( array Setted != null && array Setted [ i ] && Arrays . equals ( value , array [ i ] ) ) { counter ++ ; } } return counter ; } return NUM ; }
private int count ( boolean [ ] array Setted , byte [ ] [ ] array , byte [ ] value ) { if ( value != null ) { int counter = NUM ; for ( int i = NUM ; i < array . length ; i ++ ) { if ( array Setted != null && array Setted [ i ] && Arrays . equals ( value , array [ i ] ) ) { counter ++ ; } } return counter ; } return NUM ; }
public Simple Tree simulate Tree ( Taxon List taxa , Demographic Model model ) { return simulator . simulate Tree ( taxa , model . get Demographic Function ( ) ) ; }
public Select < T > include ( String ... columns ) { Collections . add All ( m Included Columns , columns ) ; return this ; }
public Select < T > include ( String ... columns ) { Collections . add All ( m Included Columns , columns ) ; return this ; }
public boolean has Empty Row ( ) { if ( m data Vector . size ( ) == NUM ) { return BOOL ; } List < String > data Row = m data Vector . get ( m data Vector . size ( ) - NUM ) ; for ( String s : data Row ) { if ( s . length ( ) != NUM ) { return BOOL ; } } return BOOL ; }
public boolean has Empty Row ( ) { if ( m data Vector . size ( ) == NUM ) { return BOOL ; } List < String > data Row = m data Vector . get ( m data Vector . size ( ) - NUM ) ; for ( String s : data Row ) { if ( s . length ( ) != NUM ) { return BOOL ; } } return BOOL ; }
public Haskell Catalog ( ) { this ( Haskell Catalog . XML PATH ) ; }
public Haskell Catalog ( ) { this ( Haskell Catalog . XML PATH ) ; }
public Haskell Catalog ( ) { this ( Haskell Catalog . XML PATH ) ; }
@ Override public int column Count ( ) { return column List . size ( ) ; }
public static void register Gauge ( String key , Gauge g ) { try { Metric Registry reg = Shared Metric Registries . get Or Create ( STRING ) ; reg . remove Matching ( null ) ; reg . register ( key , g ) ; } catch ( Exception e ) { logger . warn ( STRING + e . get Message ( ) ) ; } }
public static void register Gauge ( String key , Gauge g ) { try { Metric Registry reg = Shared Metric Registries . get Or Create ( STRING ) ; reg . remove Matching ( null ) ; reg . register ( key , g ) ; } catch ( Exception e ) { logger . warn ( STRING + e . get Message ( ) ) ; } }
void end Optional ( boolean successful ) { if ( successful ) { parsed . remove ( parsed . size ( ) - NUM ) ; } else { parsed . remove ( parsed . size ( ) - NUM ) ; } }
public static final boolean is PDF Linearized ( final String pdf Url ) { if ( pdf Url . starts With ( STRING ) ) { return BOOL ; } boolean is Linear = BOOL ; final URL url ; final Input Stream is ; try { url = new URL ( pdf Url ) ; is = url . open Stream ( ) ; final byte [ ] buffer = new byte [ NUM ] ; is . read ( buffer ) ; is . close ( ) ; final int len = buffer . length ; for ( int i = NUM ; i < len ; i ++ ) { if ( buffer [ i ] == STRING && buffer [ i + NUM ] == STRING && buffer [ i + NUM ] == STRING && buffer [ i + NUM ] == STRING && buffer [ i + NUM ] == STRING && buffer [ i + NUM ] == STRING && buffer [ i + NUM ] == STRING ) { is Linear = BOOL ; i = len ; } } } catch ( final IO Exception e ) { Log Writer . write Log ( STRING + e + STRING + pdf Url ) ; } return is Linear ; }
public static double distance ( Vector 2 a , Vector 2 b ) { Vector 2 temp Vector = Vector 2 . pow ( Vector 2 . subtract ( a , b ) , NUM ) ; return Math . sqrt ( temp Vector . x + temp Vector . z ) ; }
public static void validate Security Groups Format ( List < String > security Groups ) throws Invalid Security Group Format Exception { if ( security Groups != null ) { for ( String sg : security Groups ) { if ( String Utils . is Blank ( sg ) || sg . split ( STRING ) . length != NUM ) { throw new Invalid Security Group Format Exception ( STRING ) ; } } } }
public static Gapless Info create From Comment ( String name , String data ) { if ( ! GAPLESS COMMENT ID . equals ( name ) ) { return null ; } Matcher matcher = GAPLESS COMMENT PATTERN . matcher ( data ) ; if ( matcher . find ( ) ) { try { int encoder Delay = Integer . parse Int ( matcher . group ( NUM ) , NUM ) ; int encoder Padding = Integer . parse Int ( matcher . group ( NUM ) , NUM ) ; return encoder Delay == NUM && encoder Padding == NUM ? null : new Gapless Info ( encoder Delay , encoder Padding ) ; } catch ( Number Format Exception e ) { } } return null ; }
public static Gapless Info create From Comment ( String name , String data ) { if ( ! GAPLESS COMMENT ID . equals ( name ) ) { return null ; } Matcher matcher = GAPLESS COMMENT PATTERN . matcher ( data ) ; if ( matcher . find ( ) ) { try { int encoder Delay = Integer . parse Int ( matcher . group ( NUM ) , NUM ) ; int encoder Padding = Integer . parse Int ( matcher . group ( NUM ) , NUM ) ; return encoder Delay == NUM && encoder Padding == NUM ? null : new Gapless Info ( encoder Delay , encoder Padding ) ; } catch ( Number Format Exception e ) { } } return null ; }
public void add Object ( String s ) throws Exception { inspect ( Class . for Name ( s ) ) ; }
public void add Object ( String s ) throws Exception { inspect ( Class . for Name ( s ) ) ; }
@ Override public void add Property Change Listener ( Property Change Listener pcl ) { m pcs . add Property Change Listener ( pcl ) ; }
public String sign Message ( String message , @ Nullable Key Parameter aes Key ) throws Key Crypter Exception { byte [ ] data = Utils . format Message For Signing ( message ) ; Sha 256 Hash hash = Sha 256 Hash . create Double ( data ) ; ECDSA Signature sig = sign ( hash , aes Key ) ; if ( sig == null ) { log . debug ( STRING ) ; return null ; } int rec Id = - NUM ; for ( int i = NUM ; i < NUM ; i ++ ) { EC Key k = EC Key . recover From Signature ( i , sig , hash , is Compressed ( ) ) ; if ( k != null && Arrays . equals ( k . pub , pub ) ) { rec Id = i ; break ; } } if ( rec Id == - NUM ) throw new Runtime Exception ( STRING ) ; int header Byte = rec Id + NUM + ( is Compressed ( ) ? NUM : NUM ) ; byte [ ] sig Data = new byte [ NUM ] ; sig Data [ NUM ] = ( byte ) header Byte ; System . arraycopy ( Utils . big Integer To Bytes ( sig . r , NUM ) , NUM , sig Data , NUM , NUM ) ; System . arraycopy ( Utils . big Integer To Bytes ( sig . s , NUM ) , NUM , sig Data , NUM , NUM ) ; return new String ( Base 64 . encode ( sig Data ) , Charset . for Name ( STRING ) ) ; }
public String sign Message ( String message , @ Nullable Key Parameter aes Key ) throws Key Crypter Exception { byte [ ] data = Utils . format Message For Signing ( message ) ; Sha 256 Hash hash = Sha 256 Hash . create Double ( data ) ; ECDSA Signature sig = sign ( hash , aes Key ) ; if ( sig == null ) { log . debug ( STRING ) ; return null ; } int rec Id = - NUM ; for ( int i = NUM ; i < NUM ; i ++ ) { EC Key k = EC Key . recover From Signature ( i , sig , hash , is Compressed ( ) ) ; if ( k != null && Arrays . equals ( k . pub , pub ) ) { rec Id = i ; break ; } } if ( rec Id == - NUM ) throw new Runtime Exception ( STRING ) ; int header Byte = rec Id + NUM + ( is Compressed ( ) ? NUM : NUM ) ; byte [ ] sig Data = new byte [ NUM ] ; sig Data [ NUM ] = ( byte ) header Byte ; System . arraycopy ( Utils . big Integer To Bytes ( sig . r , NUM ) , NUM , sig Data , NUM , NUM ) ; System . arraycopy ( Utils . big Integer To Bytes ( sig . s , NUM ) , NUM , sig Data , NUM , NUM ) ; return new String ( Base 64 . encode ( sig Data ) , Charset . for Name ( STRING ) ) ; }
private static int snap Horizontal ( Collection < Constraint Widget > widgets , Constraint Widget widget , Constraint Anchor anchor , int position , Array List < Snap Candidate > snap Candidates ) { Snap Candidate candidate = new Snap Candidate ( ) ; Constraint Handle handle = Widget Interaction Targets . constraint Handle ( anchor ) ; handle . set Draw X ( position ) ; Snap Placement . snap Anchor ( widgets , widget , anchor , candidate ) ; if ( candidate . target != null ) { Constraint Handle target Handle = Widget Interaction Targets . constraint Handle ( candidate . target ) ; int tx = candidate . x ; if ( target Handle != null ) { tx = target Handle . get Draw X ( ) ; } position = tx + candidate . margin ; snap Candidates . add ( candidate ) ; } return position ; }
private static int snap Horizontal ( Collection < Constraint Widget > widgets , Constraint Widget widget , Constraint Anchor anchor , int position , Array List < Snap Candidate > snap Candidates ) { Snap Candidate candidate = new Snap Candidate ( ) ; Constraint Handle handle = Widget Interaction Targets . constraint Handle ( anchor ) ; handle . set Draw X ( position ) ; Snap Placement . snap Anchor ( widgets , widget , anchor , candidate ) ; if ( candidate . target != null ) { Constraint Handle target Handle = Widget Interaction Targets . constraint Handle ( candidate . target ) ; int tx = candidate . x ; if ( target Handle != null ) { tx = target Handle . get Draw X ( ) ; } position = tx + candidate . margin ; snap Candidates . add ( candidate ) ; } return position ; }
public static boolean check Virtual Pool Protocols ( Virtual Pool cos , Hash Set < String > protocols , boolean match All ) { if ( ( protocols != null ) && ! protocols . is Empty ( ) ) { String Set cos Protocols = cos . get Protocols ( ) ; if ( ( match All ) && ( ! cos Protocols . contains All ( protocols ) ) ) { log . info ( STRING , protocols ) ; return BOOL ; } else if ( ! match All ) { boolean has Match = BOOL ; Iterator < String > protocol Iter = protocols . iterator ( ) ; while ( protocol Iter . has Next ( ) ) { String protocol = protocol Iter . next ( ) ; if ( cos Protocols . contains ( protocol ) ) { log . debug ( STRING , protocol ) ; has Match = BOOL ; break ; } } return has Match ; } } return BOOL ; }
boolean boundary Approx Equals ( S2 Polygon b , double max Error ) { if ( num Loops ( ) != b . num Loops ( ) ) { log . severe ( STRING + Integer . to String ( num Loops ( ) ) + STRING + Integer . to String ( b . num Loops ( ) ) ) ; return BOOL ; } for ( int i = NUM ; i < num Loops ( ) ; ++ i ) { S2 Loop a Loop = loop ( i ) ; boolean success = BOOL ; for ( int j = NUM ; j < num Loops ( ) ; ++ j ) { S2 Loop b Loop = b . loop ( j ) ; if ( b Loop . depth ( ) == a Loop . depth ( ) && b Loop . boundary Approx Equals ( a Loop , max Error ) ) { success = BOOL ; break ; } } if ( ! success ) { return BOOL ; } } return BOOL ; }
boolean boundary Approx Equals ( S2 Polygon b , double max Error ) { if ( num Loops ( ) != b . num Loops ( ) ) { log . severe ( STRING + Integer . to String ( num Loops ( ) ) + STRING + Integer . to String ( b . num Loops ( ) ) ) ; return BOOL ; } for ( int i = NUM ; i < num Loops ( ) ; ++ i ) { S2 Loop a Loop = loop ( i ) ; boolean success = BOOL ; for ( int j = NUM ; j < num Loops ( ) ; ++ j ) { S2 Loop b Loop = b . loop ( j ) ; if ( b Loop . depth ( ) == a Loop . depth ( ) && b Loop . boundary Approx Equals ( a Loop , max Error ) ) { success = BOOL ; break ; } } if ( ! success ) { return BOOL ; } } return BOOL ; }
boolean boundary Approx Equals ( S2 Polygon b , double max Error ) { if ( num Loops ( ) != b . num Loops ( ) ) { log . severe ( STRING + Integer . to String ( num Loops ( ) ) + STRING + Integer . to String ( b . num Loops ( ) ) ) ; return BOOL ; } for ( int i = NUM ; i < num Loops ( ) ; ++ i ) { S2 Loop a Loop = loop ( i ) ; boolean success = BOOL ; for ( int j = NUM ; j < num Loops ( ) ; ++ j ) { S2 Loop b Loop = b . loop ( j ) ; if ( b Loop . depth ( ) == a Loop . depth ( ) && b Loop . boundary Approx Equals ( a Loop , max Error ) ) { success = BOOL ; break ; } } if ( ! success ) { return BOOL ; } } return BOOL ; }
boolean boundary Approx Equals ( S2 Polygon b , double max Error ) { if ( num Loops ( ) != b . num Loops ( ) ) { log . severe ( STRING + Integer . to String ( num Loops ( ) ) + STRING + Integer . to String ( b . num Loops ( ) ) ) ; return BOOL ; } for ( int i = NUM ; i < num Loops ( ) ; ++ i ) { S2 Loop a Loop = loop ( i ) ; boolean success = BOOL ; for ( int j = NUM ; j < num Loops ( ) ; ++ j ) { S2 Loop b Loop = b . loop ( j ) ; if ( b Loop . depth ( ) == a Loop . depth ( ) && b Loop . boundary Approx Equals ( a Loop , max Error ) ) { success = BOOL ; break ; } } if ( ! success ) { return BOOL ; } } return BOOL ; }
protected List < List < T > > split Data ( Iterable < T > data , int data Size ) { List < List < T > > splits = new Array List < > ( ) ; int size = ( int ) Math . ceil ( ( double ) data Size / num Folds ) ; int current = NUM ; List < T > l = new Array List < > ( ) ; int count = NUM ; for ( T item : data ) { l . add ( item ) ; count ++ ; if ( count > data Size ) break ; } Collections . shuffle ( l , random Seed ) ; for ( int i = NUM ; i < num Folds ; i ++ ) { int start = current ; int end = Math . min ( current + size , data Size ) ; splits . add ( l . sub List ( start , end ) ) ; current = end ; } return splits ; }
protected List < List < T > > split Data ( Iterable < T > data , int data Size ) { List < List < T > > splits = new Array List < > ( ) ; int size = ( int ) Math . ceil ( ( double ) data Size / num Folds ) ; int current = NUM ; List < T > l = new Array List < > ( ) ; int count = NUM ; for ( T item : data ) { l . add ( item ) ; count ++ ; if ( count > data Size ) break ; } Collections . shuffle ( l , random Seed ) ; for ( int i = NUM ; i < num Folds ; i ++ ) { int start = current ; int end = Math . min ( current + size , data Size ) ; splits . add ( l . sub List ( start , end ) ) ; current = end ; } return splits ; }
protected List < List < T > > split Data ( Iterable < T > data , int data Size ) { List < List < T > > splits = new Array List < > ( ) ; int size = ( int ) Math . ceil ( ( double ) data Size / num Folds ) ; int current = NUM ; List < T > l = new Array List < > ( ) ; int count = NUM ; for ( T item : data ) { l . add ( item ) ; count ++ ; if ( count > data Size ) break ; } Collections . shuffle ( l , random Seed ) ; for ( int i = NUM ; i < num Folds ; i ++ ) { int start = current ; int end = Math . min ( current + size , data Size ) ; splits . add ( l . sub List ( start , end ) ) ; current = end ; } return splits ; }
protected List < List < T > > split Data ( Iterable < T > data , int data Size ) { List < List < T > > splits = new Array List < > ( ) ; int size = ( int ) Math . ceil ( ( double ) data Size / num Folds ) ; int current = NUM ; List < T > l = new Array List < > ( ) ; int count = NUM ; for ( T item : data ) { l . add ( item ) ; count ++ ; if ( count > data Size ) break ; } Collections . shuffle ( l , random Seed ) ; for ( int i = NUM ; i < num Folds ; i ++ ) { int start = current ; int end = Math . min ( current + size , data Size ) ; splits . add ( l . sub List ( start , end ) ) ; current = end ; } return splits ; }
protected List < List < T > > split Data ( Iterable < T > data , int data Size ) { List < List < T > > splits = new Array List < > ( ) ; int size = ( int ) Math . ceil ( ( double ) data Size / num Folds ) ; int current = NUM ; List < T > l = new Array List < > ( ) ; int count = NUM ; for ( T item : data ) { l . add ( item ) ; count ++ ; if ( count > data Size ) break ; } Collections . shuffle ( l , random Seed ) ; for ( int i = NUM ; i < num Folds ; i ++ ) { int start = current ; int end = Math . min ( current + size , data Size ) ; splits . add ( l . sub List ( start , end ) ) ; current = end ; } return splits ; }
@ Override public int length Of Month ( ) { return iso Date . length Of Month ( ) ; }
@ Override public int length Of Month ( ) { return iso Date . length Of Month ( ) ; }
@ Override public int length Of Month ( ) { return iso Date . length Of Month ( ) ; }
@ Override public int length Of Month ( ) { return iso Date . length Of Month ( ) ; }
public Object ext Function ( String ns , String func Name , Vector arg Vec , Object method Key , Expression Context expr Context ) throws javax . xml . transform . Transformer Exception { Object result = null ; if ( null != ns ) { Extension Handler ext NS = ( Extension Handler ) m extension Function Namespaces . get ( ns ) ; if ( null != ext NS ) { try { result = ext NS . call Function ( func Name , arg Vec , method Key , expr Context ) ; } catch ( javax . xml . transform . Transformer Exception e ) { throw e ; } catch ( Exception e ) { throw new javax . xml . transform . Transformer Exception ( e ) ; } } else { throw new X Path Processor Exception ( XSL Messages . create Message ( XSLT Error Resources . ER EXTENSION FUNC UNKNOWN , new Object [ ] { ns , func Name } ) ) ; } } return result ; }
public boolean ensure Library Is Included ( @ Not Null Module module , @ Not Null Iterable < Gradle Coordinate > dependencies , @ Nullable Runnable callback ) { Gradle Build Model build Model = Gradle Build Model . get ( module ) ; if ( build Model == null ) { return BOOL ; } List < Gradle Coordinate > missing = find Missing Libraries From Gradle Build File ( build Model , dependencies ) ; if ( missing . is Empty ( ) ) { return BOOL ; } if ( user Want To Add Dependencies ( module , missing ) ) { add Dependencies In Transaction ( build Model , module , missing , callback ) ; return BOOL ; } return BOOL ; }
public boolean ensure Library Is Included ( @ Not Null Module module , @ Not Null Iterable < Gradle Coordinate > dependencies , @ Nullable Runnable callback ) { Gradle Build Model build Model = Gradle Build Model . get ( module ) ; if ( build Model == null ) { return BOOL ; } List < Gradle Coordinate > missing = find Missing Libraries From Gradle Build File ( build Model , dependencies ) ; if ( missing . is Empty ( ) ) { return BOOL ; } if ( user Want To Add Dependencies ( module , missing ) ) { add Dependencies In Transaction ( build Model , module , missing , callback ) ; return BOOL ; } return BOOL ; }
public boolean ensure Library Is Included ( @ Not Null Module module , @ Not Null Iterable < Gradle Coordinate > dependencies , @ Nullable Runnable callback ) { Gradle Build Model build Model = Gradle Build Model . get ( module ) ; if ( build Model == null ) { return BOOL ; } List < Gradle Coordinate > missing = find Missing Libraries From Gradle Build File ( build Model , dependencies ) ; if ( missing . is Empty ( ) ) { return BOOL ; } if ( user Want To Add Dependencies ( module , missing ) ) { add Dependencies In Transaction ( build Model , module , missing , callback ) ; return BOOL ; } return BOOL ; }
public boolean ensure Library Is Included ( @ Not Null Module module , @ Not Null Iterable < Gradle Coordinate > dependencies , @ Nullable Runnable callback ) { Gradle Build Model build Model = Gradle Build Model . get ( module ) ; if ( build Model == null ) { return BOOL ; } List < Gradle Coordinate > missing = find Missing Libraries From Gradle Build File ( build Model , dependencies ) ; if ( missing . is Empty ( ) ) { return BOOL ; } if ( user Want To Add Dependencies ( module , missing ) ) { add Dependencies In Transaction ( build Model , module , missing , callback ) ; return BOOL ; } return BOOL ; }
protected void write Table Creation Stmt ( Table table , String Builder ddl ) { ddl . append ( STRING ) ; ddl . append ( get Fully Qualified Table Name Shorten ( table ) ) ; println ( STRING , ddl ) ; write Columns ( table , ddl ) ; if ( database Info . is Primary Key Embedded ( ) ) { write Embedded Primary Keys Stmt ( table , ddl ) ; } if ( database Info . is Foreign Keys Embedded ( ) ) { write Embedded Foreign Keys Stmt ( table , ddl ) ; } if ( database Info . is Indices Embedded ( ) ) { write Embedded Indices Stmt ( table , ddl ) ; } println ( ddl ) ; ddl . append ( STRING ) ; if ( is Specify Identity Gap Limit ( ) ) { write Identity Gap Limit ( ddl ) ; } }
protected void write Table Creation Stmt ( Table table , String Builder ddl ) { ddl . append ( STRING ) ; ddl . append ( get Fully Qualified Table Name Shorten ( table ) ) ; println ( STRING , ddl ) ; write Columns ( table , ddl ) ; if ( database Info . is Primary Key Embedded ( ) ) { write Embedded Primary Keys Stmt ( table , ddl ) ; } if ( database Info . is Foreign Keys Embedded ( ) ) { write Embedded Foreign Keys Stmt ( table , ddl ) ; } if ( database Info . is Indices Embedded ( ) ) { write Embedded Indices Stmt ( table , ddl ) ; } println ( ddl ) ; ddl . append ( STRING ) ; if ( is Specify Identity Gap Limit ( ) ) { write Identity Gap Limit ( ddl ) ; } }
private void add Mitre Join ( Coordinate p , Line Segment offset 0 , Line Segment offset 1 , double distance ) { boolean is Mitre Within Limit = BOOL ; Coordinate int Pt = null ; try { int Pt = H Coordinate . intersection ( offset 0 . p0 , offset 0 . p1 , offset 1 . p0 , offset 1 . p1 ) ; double mitre Ratio = distance <= NUM ? NUM : int Pt . distance ( p ) / Math . abs ( distance ) ; if ( mitre Ratio > buf Params . get Mitre Limit ( ) ) is Mitre Within Limit = BOOL ; } catch ( Not Representable Exception ex ) { int Pt = new Coordinate ( NUM , NUM ) ; is Mitre Within Limit = BOOL ; } if ( is Mitre Within Limit ) { seg List . add Pt ( int Pt ) ; } else { add Limited Mitre Join ( offset 0 , offset 1 , distance , buf Params . get Mitre Limit ( ) ) ; } }
private void add Mitre Join ( Coordinate p , Line Segment offset 0 , Line Segment offset 1 , double distance ) { boolean is Mitre Within Limit = BOOL ; Coordinate int Pt = null ; try { int Pt = H Coordinate . intersection ( offset 0 . p0 , offset 0 . p1 , offset 1 . p0 , offset 1 . p1 ) ; double mitre Ratio = distance <= NUM ? NUM : int Pt . distance ( p ) / Math . abs ( distance ) ; if ( mitre Ratio > buf Params . get Mitre Limit ( ) ) is Mitre Within Limit = BOOL ; } catch ( Not Representable Exception ex ) { int Pt = new Coordinate ( NUM , NUM ) ; is Mitre Within Limit = BOOL ; } if ( is Mitre Within Limit ) { seg List . add Pt ( int Pt ) ; } else { add Limited Mitre Join ( offset 0 , offset 1 , distance , buf Params . get Mitre Limit ( ) ) ; } }
public Zk Config Manager ( Solr Zk Client zk Client ) { this . zk Client = zk Client ; }
public Translation decode ( Sentence sentence ) { try { Decoder Task decoder Task = new Decoder Task ( this . grammars , Decoder . weights , this . feature Functions , joshua Configuration ) ; return decoder Task . translate ( sentence ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( String . format ( STRING , sentence . id ( ) , e . get Message ( ) ) , e ) ; } }
private void compute Statistics ( Profile Request req , int access Time , int egress Time ) { int count = NUM ; int sum = NUM ; this . min = Integer . MAX VALUE ; this . max = NUM ; for ( int start = req . from Time ; start < req . to Time ; start += NUM ) { int time At Origin Stop = start + access Time + Raptor Worker . BOARD SLACK SECONDS ; int best Time At Destination Stop = Integer . MAX VALUE ; for ( Itinerary itin : this . itineraries ) { if ( itin . board Times [ NUM ] < time At Origin Stop ) continue ; if ( itin . alight Times [ this . length - NUM ] < best Time At Destination Stop ) best Time At Destination Stop = itin . alight Times [ this . length - NUM ] ; } if ( best Time At Destination Stop == Integer . MAX VALUE ) continue ; int best Time At Destination = best Time At Destination Stop + egress Time ; int travel Time = best Time At Destination - start ; count ++ ; sum += travel Time ; min = Math . min ( min , travel Time ) ; max = Math . max ( max , travel Time ) ; } if ( count == NUM ) throw new Illegal State Exception ( STRING ) ; avg = sum / count ; }
private void compute Statistics ( Profile Request req , int access Time , int egress Time ) { int count = NUM ; int sum = NUM ; this . min = Integer . MAX VALUE ; this . max = NUM ; for ( int start = req . from Time ; start < req . to Time ; start += NUM ) { int time At Origin Stop = start + access Time + Raptor Worker . BOARD SLACK SECONDS ; int best Time At Destination Stop = Integer . MAX VALUE ; for ( Itinerary itin : this . itineraries ) { if ( itin . board Times [ NUM ] < time At Origin Stop ) continue ; if ( itin . alight Times [ this . length - NUM ] < best Time At Destination Stop ) best Time At Destination Stop = itin . alight Times [ this . length - NUM ] ; } if ( best Time At Destination Stop == Integer . MAX VALUE ) continue ; int best Time At Destination = best Time At Destination Stop + egress Time ; int travel Time = best Time At Destination - start ; count ++ ; sum += travel Time ; min = Math . min ( min , travel Time ) ; max = Math . max ( max , travel Time ) ; } if ( count == NUM ) throw new Illegal State Exception ( STRING ) ; avg = sum / count ; }
private void compute Statistics ( Profile Request req , int access Time , int egress Time ) { int count = NUM ; int sum = NUM ; this . min = Integer . MAX VALUE ; this . max = NUM ; for ( int start = req . from Time ; start < req . to Time ; start += NUM ) { int time At Origin Stop = start + access Time + Raptor Worker . BOARD SLACK SECONDS ; int best Time At Destination Stop = Integer . MAX VALUE ; for ( Itinerary itin : this . itineraries ) { if ( itin . board Times [ NUM ] < time At Origin Stop ) continue ; if ( itin . alight Times [ this . length - NUM ] < best Time At Destination Stop ) best Time At Destination Stop = itin . alight Times [ this . length - NUM ] ; } if ( best Time At Destination Stop == Integer . MAX VALUE ) continue ; int best Time At Destination = best Time At Destination Stop + egress Time ; int travel Time = best Time At Destination - start ; count ++ ; sum += travel Time ; min = Math . min ( min , travel Time ) ; max = Math . max ( max , travel Time ) ; } if ( count == NUM ) throw new Illegal State Exception ( STRING ) ; avg = sum / count ; }
private void compute Statistics ( Profile Request req , int access Time , int egress Time ) { int count = NUM ; int sum = NUM ; this . min = Integer . MAX VALUE ; this . max = NUM ; for ( int start = req . from Time ; start < req . to Time ; start += NUM ) { int time At Origin Stop = start + access Time + Raptor Worker . BOARD SLACK SECONDS ; int best Time At Destination Stop = Integer . MAX VALUE ; for ( Itinerary itin : this . itineraries ) { if ( itin . board Times [ NUM ] < time At Origin Stop ) continue ; if ( itin . alight Times [ this . length - NUM ] < best Time At Destination Stop ) best Time At Destination Stop = itin . alight Times [ this . length - NUM ] ; } if ( best Time At Destination Stop == Integer . MAX VALUE ) continue ; int best Time At Destination = best Time At Destination Stop + egress Time ; int travel Time = best Time At Destination - start ; count ++ ; sum += travel Time ; min = Math . min ( min , travel Time ) ; max = Math . max ( max , travel Time ) ; } if ( count == NUM ) throw new Illegal State Exception ( STRING ) ; avg = sum / count ; }
@ Suppress Warnings ( STRING ) default T add ( String ... rows ) { require Non Null Elements ( rows ) ; for ( final String row : rows ) { Collections . add All ( get Code ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ Suppress Warnings ( STRING ) default T add ( String ... rows ) { require Non Null Elements ( rows ) ; for ( final String row : rows ) { Collections . add All ( get Code ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ Suppress Warnings ( STRING ) default T add ( String ... rows ) { require Non Null Elements ( rows ) ; for ( final String row : rows ) { Collections . add All ( get Code ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ Suppress Warnings ( STRING ) default T add ( String ... rows ) { require Non Null Elements ( rows ) ; for ( final String row : rows ) { Collections . add All ( get Code ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ Suppress Warnings ( STRING ) default T add ( String ... rows ) { require Non Null Elements ( rows ) ; for ( final String row : rows ) { Collections . add All ( get Code ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ Suppress Warnings ( STRING ) default T add ( String ... rows ) { require Non Null Elements ( rows ) ; for ( final String row : rows ) { Collections . add All ( get Code ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
protected static int [ ] insert ( int [ ] old , int old Size , int pos , int x ) { int [ ] result ; if ( old != null && old . length > old Size ) { result = old ; } else { result = new int [ old Size + NUM + COPY THRESHOLD ] ; if ( pos > NUM && old != null ) { System . arraycopy ( old , NUM , result , NUM , pos ) ; } } if ( old != null && old Size - pos > NUM ) { System . arraycopy ( old , pos , result , pos + NUM , old Size - pos ) ; } result [ pos ] = x ; return result ; }
protected static int [ ] insert ( int [ ] old , int old Size , int pos , int x ) { int [ ] result ; if ( old != null && old . length > old Size ) { result = old ; } else { result = new int [ old Size + NUM + COPY THRESHOLD ] ; if ( pos > NUM && old != null ) { System . arraycopy ( old , NUM , result , NUM , pos ) ; } } if ( old != null && old Size - pos > NUM ) { System . arraycopy ( old , pos , result , pos + NUM , old Size - pos ) ; } result [ pos ] = x ; return result ; }
public static double L Log Loss ( double y , double rpred , double C ) { double ans = Math . min ( Utils . eq ( y , rpred ) ? NUM : - ( ( y * Math . log ( rpred ) ) + ( ( NUM - y ) * Math . log ( NUM - rpred ) ) ) , C ) ; return ( Double . is Na N ( ans ) ? NUM : ans ) ; }
public void update Max Text Widths ( float required Width , float match Contents Width ) { m Max Required Width = Math . max ( m Max Required Width , required Width ) ; m Max Match Contents Width = Math . max ( m Max Match Contents Width , match Contents Width ) ; }
public java . lang . String Builder insert ( int offset , double d ) { return insert ( offset , Double . to String ( d ) ) ; }
public java . lang . String Builder insert ( int offset , double d ) { return insert ( offset , Double . to String ( d ) ) ; }
public java . lang . String Builder insert ( int offset , double d ) { return insert ( offset , Double . to String ( d ) ) ; }
public Registered Project remove Project Type ( String project Path , String type ) throws Conflict Exception , Forbidden Exception , Not Found Exception , Server Exception { final Registered Project project = get Project ( project Path ) ; if ( project == null ) { return null ; } List < String > new Mixins = project . get Mixins ( ) ; String new Type = project . get Type ( ) ; if ( new Mixins . contains ( type ) ) { new Mixins . remove ( type ) ; } else if ( new Type . equals ( type ) ) { if ( project . is Detected ( ) ) { projects . remove ( project . get Path ( ) ) ; return null ; } new Type = Base Project Type . ID ; } final New Project Config conf = new New Project Config ( project . get Path ( ) , new Type , new Mixins , project . get Name ( ) , project . get Description ( ) , project . get Attributes ( ) , project . get Source ( ) ) ; return put Project ( conf , project . get Base Folder ( ) , BOOL , project . is Detected ( ) ) ; }
public Registered Project remove Project Type ( String project Path , String type ) throws Conflict Exception , Forbidden Exception , Not Found Exception , Server Exception { final Registered Project project = get Project ( project Path ) ; if ( project == null ) { return null ; } List < String > new Mixins = project . get Mixins ( ) ; String new Type = project . get Type ( ) ; if ( new Mixins . contains ( type ) ) { new Mixins . remove ( type ) ; } else if ( new Type . equals ( type ) ) { if ( project . is Detected ( ) ) { projects . remove ( project . get Path ( ) ) ; return null ; } new Type = Base Project Type . ID ; } final New Project Config conf = new New Project Config ( project . get Path ( ) , new Type , new Mixins , project . get Name ( ) , project . get Description ( ) , project . get Attributes ( ) , project . get Source ( ) ) ; return put Project ( conf , project . get Base Folder ( ) , BOOL , project . is Detected ( ) ) ; }
public Registered Project remove Project Type ( String project Path , String type ) throws Conflict Exception , Forbidden Exception , Not Found Exception , Server Exception { final Registered Project project = get Project ( project Path ) ; if ( project == null ) { return null ; } List < String > new Mixins = project . get Mixins ( ) ; String new Type = project . get Type ( ) ; if ( new Mixins . contains ( type ) ) { new Mixins . remove ( type ) ; } else if ( new Type . equals ( type ) ) { if ( project . is Detected ( ) ) { projects . remove ( project . get Path ( ) ) ; return null ; } new Type = Base Project Type . ID ; } final New Project Config conf = new New Project Config ( project . get Path ( ) , new Type , new Mixins , project . get Name ( ) , project . get Description ( ) , project . get Attributes ( ) , project . get Source ( ) ) ; return put Project ( conf , project . get Base Folder ( ) , BOOL , project . is Detected ( ) ) ; }
public Registered Project remove Project Type ( String project Path , String type ) throws Conflict Exception , Forbidden Exception , Not Found Exception , Server Exception { final Registered Project project = get Project ( project Path ) ; if ( project == null ) { return null ; } List < String > new Mixins = project . get Mixins ( ) ; String new Type = project . get Type ( ) ; if ( new Mixins . contains ( type ) ) { new Mixins . remove ( type ) ; } else if ( new Type . equals ( type ) ) { if ( project . is Detected ( ) ) { projects . remove ( project . get Path ( ) ) ; return null ; } new Type = Base Project Type . ID ; } final New Project Config conf = new New Project Config ( project . get Path ( ) , new Type , new Mixins , project . get Name ( ) , project . get Description ( ) , project . get Attributes ( ) , project . get Source ( ) ) ; return put Project ( conf , project . get Base Folder ( ) , BOOL , project . is Detected ( ) ) ; }
public Registered Project remove Project Type ( String project Path , String type ) throws Conflict Exception , Forbidden Exception , Not Found Exception , Server Exception { final Registered Project project = get Project ( project Path ) ; if ( project == null ) { return null ; } List < String > new Mixins = project . get Mixins ( ) ; String new Type = project . get Type ( ) ; if ( new Mixins . contains ( type ) ) { new Mixins . remove ( type ) ; } else if ( new Type . equals ( type ) ) { if ( project . is Detected ( ) ) { projects . remove ( project . get Path ( ) ) ; return null ; } new Type = Base Project Type . ID ; } final New Project Config conf = new New Project Config ( project . get Path ( ) , new Type , new Mixins , project . get Name ( ) , project . get Description ( ) , project . get Attributes ( ) , project . get Source ( ) ) ; return put Project ( conf , project . get Base Folder ( ) , BOOL , project . is Detected ( ) ) ; }
public Registered Project remove Project Type ( String project Path , String type ) throws Conflict Exception , Forbidden Exception , Not Found Exception , Server Exception { final Registered Project project = get Project ( project Path ) ; if ( project == null ) { return null ; } List < String > new Mixins = project . get Mixins ( ) ; String new Type = project . get Type ( ) ; if ( new Mixins . contains ( type ) ) { new Mixins . remove ( type ) ; } else if ( new Type . equals ( type ) ) { if ( project . is Detected ( ) ) { projects . remove ( project . get Path ( ) ) ; return null ; } new Type = Base Project Type . ID ; } final New Project Config conf = new New Project Config ( project . get Path ( ) , new Type , new Mixins , project . get Name ( ) , project . get Description ( ) , project . get Attributes ( ) , project . get Source ( ) ) ; return put Project ( conf , project . get Base Folder ( ) , BOOL , project . is Detected ( ) ) ; }
public Registered Project remove Project Type ( String project Path , String type ) throws Conflict Exception , Forbidden Exception , Not Found Exception , Server Exception { final Registered Project project = get Project ( project Path ) ; if ( project == null ) { return null ; } List < String > new Mixins = project . get Mixins ( ) ; String new Type = project . get Type ( ) ; if ( new Mixins . contains ( type ) ) { new Mixins . remove ( type ) ; } else if ( new Type . equals ( type ) ) { if ( project . is Detected ( ) ) { projects . remove ( project . get Path ( ) ) ; return null ; } new Type = Base Project Type . ID ; } final New Project Config conf = new New Project Config ( project . get Path ( ) , new Type , new Mixins , project . get Name ( ) , project . get Description ( ) , project . get Attributes ( ) , project . get Source ( ) ) ; return put Project ( conf , project . get Base Folder ( ) , BOOL , project . is Detected ( ) ) ; }
public Registered Project remove Project Type ( String project Path , String type ) throws Conflict Exception , Forbidden Exception , Not Found Exception , Server Exception { final Registered Project project = get Project ( project Path ) ; if ( project == null ) { return null ; } List < String > new Mixins = project . get Mixins ( ) ; String new Type = project . get Type ( ) ; if ( new Mixins . contains ( type ) ) { new Mixins . remove ( type ) ; } else if ( new Type . equals ( type ) ) { if ( project . is Detected ( ) ) { projects . remove ( project . get Path ( ) ) ; return null ; } new Type = Base Project Type . ID ; } final New Project Config conf = new New Project Config ( project . get Path ( ) , new Type , new Mixins , project . get Name ( ) , project . get Description ( ) , project . get Attributes ( ) , project . get Source ( ) ) ; return put Project ( conf , project . get Base Folder ( ) , BOOL , project . is Detected ( ) ) ; }
public Registered Project remove Project Type ( String project Path , String type ) throws Conflict Exception , Forbidden Exception , Not Found Exception , Server Exception { final Registered Project project = get Project ( project Path ) ; if ( project == null ) { return null ; } List < String > new Mixins = project . get Mixins ( ) ; String new Type = project . get Type ( ) ; if ( new Mixins . contains ( type ) ) { new Mixins . remove ( type ) ; } else if ( new Type . equals ( type ) ) { if ( project . is Detected ( ) ) { projects . remove ( project . get Path ( ) ) ; return null ; } new Type = Base Project Type . ID ; } final New Project Config conf = new New Project Config ( project . get Path ( ) , new Type , new Mixins , project . get Name ( ) , project . get Description ( ) , project . get Attributes ( ) , project . get Source ( ) ) ; return put Project ( conf , project . get Base Folder ( ) , BOOL , project . is Detected ( ) ) ; }
public Registered Project remove Project Type ( String project Path , String type ) throws Conflict Exception , Forbidden Exception , Not Found Exception , Server Exception { final Registered Project project = get Project ( project Path ) ; if ( project == null ) { return null ; } List < String > new Mixins = project . get Mixins ( ) ; String new Type = project . get Type ( ) ; if ( new Mixins . contains ( type ) ) { new Mixins . remove ( type ) ; } else if ( new Type . equals ( type ) ) { if ( project . is Detected ( ) ) { projects . remove ( project . get Path ( ) ) ; return null ; } new Type = Base Project Type . ID ; } final New Project Config conf = new New Project Config ( project . get Path ( ) , new Type , new Mixins , project . get Name ( ) , project . get Description ( ) , project . get Attributes ( ) , project . get Source ( ) ) ; return put Project ( conf , project . get Base Folder ( ) , BOOL , project . is Detected ( ) ) ; }
public Registered Project remove Project Type ( String project Path , String type ) throws Conflict Exception , Forbidden Exception , Not Found Exception , Server Exception { final Registered Project project = get Project ( project Path ) ; if ( project == null ) { return null ; } List < String > new Mixins = project . get Mixins ( ) ; String new Type = project . get Type ( ) ; if ( new Mixins . contains ( type ) ) { new Mixins . remove ( type ) ; } else if ( new Type . equals ( type ) ) { if ( project . is Detected ( ) ) { projects . remove ( project . get Path ( ) ) ; return null ; } new Type = Base Project Type . ID ; } final New Project Config conf = new New Project Config ( project . get Path ( ) , new Type , new Mixins , project . get Name ( ) , project . get Description ( ) , project . get Attributes ( ) , project . get Source ( ) ) ; return put Project ( conf , project . get Base Folder ( ) , BOOL , project . is Detected ( ) ) ; }
@ Override public boolean add Sensor To Route ( String sensor Name , int mode ) { if ( control Sensor List . size ( ) >= MAX CONTROL SENSORS ) { log . warn ( STRING , get System Name ( ) ) ; } Control Sensor sensor = new Control Sensor ( sensor Name ) ; log . debug ( STRING , get System Name ( ) , sensor Name ) ; if ( ! sensor . set State ( mode ) ) { return BOOL ; } if ( is Control Sensor Included ( sensor ) ) { log . debug ( STRING , sensor Name , get System Name ( ) ) ; } else { control Sensor List . add ( sensor ) ; } return BOOL ; }
@ Override public boolean add Sensor To Route ( String sensor Name , int mode ) { if ( control Sensor List . size ( ) >= MAX CONTROL SENSORS ) { log . warn ( STRING , get System Name ( ) ) ; } Control Sensor sensor = new Control Sensor ( sensor Name ) ; log . debug ( STRING , get System Name ( ) , sensor Name ) ; if ( ! sensor . set State ( mode ) ) { return BOOL ; } if ( is Control Sensor Included ( sensor ) ) { log . debug ( STRING , sensor Name , get System Name ( ) ) ; } else { control Sensor List . add ( sensor ) ; } return BOOL ; }
public static int [ ] parse Int Array ( int [ ] dest , String value ) { String [ ] parts = value . split ( STRING ) ; if ( dest == null ) { dest = new int [ parts . length ] ; } for ( int i = NUM ; i < dest . length ; i ++ ) { dest [ i ] = Integer . parse Int ( parts [ i ] ) ; } return dest ; }
public static long location At Tick ( Geo Time Serie gts , long tick ) { if ( null == gts . locations ) { return Geo Time Serie . NO LOCATION ; } sort ( gts , BOOL ) ; int idx = Arrays . binary Search ( gts . ticks , NUM , gts . values , tick ) ; if ( idx < NUM ) { return Geo Time Serie . NO LOCATION ; } else { return gts . locations [ idx ] ; } }
public static long location At Tick ( Geo Time Serie gts , long tick ) { if ( null == gts . locations ) { return Geo Time Serie . NO LOCATION ; } sort ( gts , BOOL ) ; int idx = Arrays . binary Search ( gts . ticks , NUM , gts . values , tick ) ; if ( idx < NUM ) { return Geo Time Serie . NO LOCATION ; } else { return gts . locations [ idx ] ; } }
public Gondola Rc ( ) throws Exception { config = new Config ( new File ( STRING ) ) ; for ( String h : config . get Host Ids ( ) ) { for ( String s : config . get Shard Ids ( h ) ) { if ( s . equals ( STRING ) ) { gondolas . add ( new Gondola ( config , h ) ) ; } } } }
public Gondola Rc ( ) throws Exception { config = new Config ( new File ( STRING ) ) ; for ( String h : config . get Host Ids ( ) ) { for ( String s : config . get Shard Ids ( h ) ) { if ( s . equals ( STRING ) ) { gondolas . add ( new Gondola ( config , h ) ) ; } } } }
public void engine Delete Entry ( String alias ) throws Key Store Exception { Key k = ( Key ) keys . remove ( alias ) ; Certificate c = ( Certificate ) certs . remove ( alias ) ; if ( c != null ) { chain Certs . remove ( new Cert Id ( c . get Public Key ( ) ) ) ; } if ( k != null ) { String id = ( String ) local Ids . remove ( alias ) ; if ( id != null ) { c = ( Certificate ) key Certs . remove ( id ) ; } if ( c != null ) { chain Certs . remove ( new Cert Id ( c . get Public Key ( ) ) ) ; } } }
public void engine Delete Entry ( String alias ) throws Key Store Exception { Key k = ( Key ) keys . remove ( alias ) ; Certificate c = ( Certificate ) certs . remove ( alias ) ; if ( c != null ) { chain Certs . remove ( new Cert Id ( c . get Public Key ( ) ) ) ; } if ( k != null ) { String id = ( String ) local Ids . remove ( alias ) ; if ( id != null ) { c = ( Certificate ) key Certs . remove ( id ) ; } if ( c != null ) { chain Certs . remove ( new Cert Id ( c . get Public Key ( ) ) ) ; } } }
public void engine Delete Entry ( String alias ) throws Key Store Exception { Key k = ( Key ) keys . remove ( alias ) ; Certificate c = ( Certificate ) certs . remove ( alias ) ; if ( c != null ) { chain Certs . remove ( new Cert Id ( c . get Public Key ( ) ) ) ; } if ( k != null ) { String id = ( String ) local Ids . remove ( alias ) ; if ( id != null ) { c = ( Certificate ) key Certs . remove ( id ) ; } if ( c != null ) { chain Certs . remove ( new Cert Id ( c . get Public Key ( ) ) ) ; } } }
@ Override public void on Can Start Video Service Changed ( boolean can Start Video Service ) { Log . i ( STRING , STRING + String . value Of ( can Start Video Service ) ) ; if ( can Start Video Service == BOOL ) { m Conversation Helper . start Outgoing Video ( ) ; m Conversation Helper . start Incoming Video ( ) ; } }
@ Override public void on Can Start Video Service Changed ( boolean can Start Video Service ) { Log . i ( STRING , STRING + String . value Of ( can Start Video Service ) ) ; if ( can Start Video Service == BOOL ) { m Conversation Helper . start Outgoing Video ( ) ; m Conversation Helper . start Incoming Video ( ) ; } }
public int next Int ( ) { int ret = counter . get And Increment ( ) ; set Last Int ( ret ) ; return ret ; }
public int next Int ( ) { int ret = counter . get And Increment ( ) ; set Last Int ( ret ) ; return ret ; }
public int next Int ( ) { int ret = counter . get And Increment ( ) ; set Last Int ( ret ) ; return ret ; }
public int next Int ( ) { int ret = counter . get And Increment ( ) ; set Last Int ( ret ) ; return ret ; }
public int next Int ( ) { int ret = counter . get And Increment ( ) ; set Last Int ( ret ) ; return ret ; }
public int next Int ( ) { int ret = counter . get And Increment ( ) ; set Last Int ( ret ) ; return ret ; }
public int next Int ( ) { int ret = counter . get And Increment ( ) ; set Last Int ( ret ) ; return ret ; }
public mx Coordinate Assignment ( mx Hierarchical Layout layout , double intra Cell Spacing , double inter Rank Cell Spacing , int orientation , double initial X , double parallel Edge Spacing ) { this . layout = layout ; this . intra Cell Spacing = intra Cell Spacing ; this . inter Rank Cell Spacing = inter Rank Cell Spacing ; this . orientation = orientation ; this . initial X = initial X ; this . parallel Edge Spacing = parallel Edge Spacing ; set Logger Level ( Level . OFF ) ; }
public void add Root Block ( Block block , boolean is New Block ) { if ( block == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( block . get Previous Block ( ) != null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( m Root Blocks . contains ( block ) ) { throw new Illegal Argument Exception ( STRING ) ; } m Root Blocks . add ( block ) ; if ( is New Block ) { m Stats . collect Stats ( block , BOOL ) ; } }
public static < T > Database Table Config < T > from Reader ( Buffered Reader reader ) throws SQL Exception { Database Table Config < T > config = new Database Table Config < T > ( ) ; boolean anything = BOOL ; while ( BOOL ) { String line ; try { line = reader . read Line ( ) ; } catch ( IO Exception e ) { throw Sql Exception Util . create ( STRING , e ) ; } if ( line == null ) { break ; } if ( line . equals ( CONFIG FILE END MARKER ) ) { break ; } if ( line . equals ( CONFIG FILE FIELDS START ) ) { read Fields ( reader , config ) ; continue ; } if ( line . length ( ) == NUM || line . starts With ( STRING ) || line . equals ( CONFIG FILE START MARKER ) ) { continue ; } String [ ] parts = line . split ( STRING , - NUM ) ; if ( parts . length != NUM ) { throw new SQL Exception ( STRING + line ) ; } read Table Field ( config , parts [ NUM ] , parts [ NUM ] ) ; anything = BOOL ; } if ( anything ) { return config ; } else { return null ; } }
public Localized Text ( String text , String locale Id ) { this . text = text ; this . locale = locale Id ; }
public void add ( Key key ) { if ( key == null ) throw new Null Pointer Exception ( STRING ) ; set . add ( key ) ; }
public static Corleone context ( String job Context ) { if ( job Context == null || job Context . equals ( STRING ) ) { throw new Illegal Argument Exception ( STRING ) ; } contexts . clear ( ) ; contexts . add ( job Context ) ; return get Instance ( ) ; }
public final void test Generate Seedint 03 ( ) { byte [ ] my Bytes 1 ; byte [ ] my Bytes 2 ; for ( int i = NUM ; i < LENGTH ; i += INCR ) { int n = NUM ; my Bytes 1 = sr . generate Seed ( i ) ; my Bytes 2 = sr . generate Seed ( i ) ; for ( int j = NUM ; j < i ; j ++ ) { if ( my Bytes 1 [ j ] == my Bytes 2 [ j ] ) { n ++ ; } } assert False ( STRING + i + STRING + n , n * NUM > i ) ; } }
public void add Timeline ( final JSON Object timeline ) { Timeline Channel . notify Timeline ( timeline ) ; timelines . add First ( timeline ) ; final int max Cnt = Symphonys . get Int ( STRING ) ; if ( timelines . size ( ) > max Cnt ) { timelines . remove ( max Cnt ) ; } }
public void add Swipe Listener ( Swipe Listener listener ) { if ( m Listeners == null ) { m Listeners = new Array List < > ( ) ; } m Listeners . add ( listener ) ; }
public void add Swipe Listener ( Swipe Listener listener ) { if ( m Listeners == null ) { m Listeners = new Array List < > ( ) ; } m Listeners . add ( listener ) ; }
public void add ( int primary Code , int [ ] codes ) { m Typed Word . append ( ( char ) primary Code ) ; correct Primary Juxtapos ( primary Code , codes ) ; correct Codes Case ( codes ) ; m Codes . add ( codes ) ; if ( Character . is Upper Case ( ( char ) primary Code ) ) m Caps Count ++ ; }
public void add ( int primary Code , int [ ] codes ) { m Typed Word . append ( ( char ) primary Code ) ; correct Primary Juxtapos ( primary Code , codes ) ; correct Codes Case ( codes ) ; m Codes . add ( codes ) ; if ( Character . is Upper Case ( ( char ) primary Code ) ) m Caps Count ++ ; }
public void add ( int primary Code , int [ ] codes ) { m Typed Word . append ( ( char ) primary Code ) ; correct Primary Juxtapos ( primary Code , codes ) ; correct Codes Case ( codes ) ; m Codes . add ( codes ) ; if ( Character . is Upper Case ( ( char ) primary Code ) ) m Caps Count ++ ; }
public void add ( int primary Code , int [ ] codes ) { m Typed Word . append ( ( char ) primary Code ) ; correct Primary Juxtapos ( primary Code , codes ) ; correct Codes Case ( codes ) ; m Codes . add ( codes ) ; if ( Character . is Upper Case ( ( char ) primary Code ) ) m Caps Count ++ ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
public Repl DBMS Header last Commit Seqno ( ) throws Replicator Exception { try { Repl DBMS Header Data header = null ; Result Set res = null ; try { last Seqno Query . set Int ( NUM , task Id ) ; res = last Seqno Query . execute Query ( ) ; if ( res . next ( ) ) { header = header From Result ( res ) ; } } finally { connection Manager . close ( res ) ; } return header ; } catch ( SQL Exception e ) { throw new Replicator Exception ( STRING + e . get Message ( ) , e ) ; } }
public Repl DBMS Header last Commit Seqno ( ) throws Replicator Exception { try { Repl DBMS Header Data header = null ; Result Set res = null ; try { last Seqno Query . set Int ( NUM , task Id ) ; res = last Seqno Query . execute Query ( ) ; if ( res . next ( ) ) { header = header From Result ( res ) ; } } finally { connection Manager . close ( res ) ; } return header ; } catch ( SQL Exception e ) { throw new Replicator Exception ( STRING + e . get Message ( ) , e ) ; } }
public Repl DBMS Header last Commit Seqno ( ) throws Replicator Exception { try { Repl DBMS Header Data header = null ; Result Set res = null ; try { last Seqno Query . set Int ( NUM , task Id ) ; res = last Seqno Query . execute Query ( ) ; if ( res . next ( ) ) { header = header From Result ( res ) ; } } finally { connection Manager . close ( res ) ; } return header ; } catch ( SQL Exception e ) { throw new Replicator Exception ( STRING + e . get Message ( ) , e ) ; } }
protected boolean before Release ( ) { return deque . size ( ) < max Size ; }
public void add Element ( Er Stack Trace Element element ) { if ( class Name == null ) { declaring Class = element . get Declaring Class ( ) ; if ( declaring Class . contains ( STRING ) ) { class Name = declaring Class . substring ( declaring Class . last Index Of ( STRING ) + NUM ) ; package Name = declaring Class . substring ( NUM , declaring Class . last Index Of ( STRING ) ) ; } else { class Name = declaring Class ; package Name = STRING ; } file Name = element . get File Name ( ) ; if ( check Base Packages ( declaring Class ) ) { is Base Package = BOOL ; } } stack Trace Elements . add ( element ) ; }
public int hash Code ( ) { return ( Float . float To Int Bits ( extra Alpha ) * NUM + rule ) ; }
public Searcher ( ) throws IO Exception { searcher = new Index Searcher ( Directory Reader . open ( FS Directory . open ( Paths . get ( INDEX DIR ) ) ) ) ; parser = new Query Parser ( CONTENT FIELD , new Standard Analyzer ( ) ) ; }
public void add Column Listener ( Column Listener listener ) { m listeners . add ( listener ) ; }
public void add Column Listener ( Column Listener listener ) { m listeners . add ( listener ) ; }
@ Suppress Warnings ( STRING ) protected void stop Associator ( ) { if ( m Run Thread != null ) { m Run Thread . interrupt ( ) ; m Run Thread . stop ( ) ; } }
@ Suppress Warnings ( STRING ) protected void stop Associator ( ) { if ( m Run Thread != null ) { m Run Thread . interrupt ( ) ; m Run Thread . stop ( ) ; } }
public static < T > Rule < T > from Uri ( final String uri , final List < String > methods , final T target ) { return new Rule < > ( uri , methods , target ) ; }
@ Override public int hash Code ( ) { throw new Unsupported Operation Exception ( STRING ) ; }
@ Override public void send Mail ( Mime Message message ) throws Messaging Exception { Mail Address sender = new Mail Address ( ( Internet Address ) message . get From ( ) [ NUM ] ) ; Collection < Mail Address > recipients = new Hash Set < Mail Address > ( ) ; Address addresses [ ] = message . get All Recipients ( ) ; if ( addresses != null ) { for ( Address address : addresses ) { if ( address instanceof Internet Address ) { recipients . add ( new Mail Address ( ( Internet Address ) address ) ) ; } } } send Mail ( sender , recipients , message ) ; }
@ Override protected void finalize ( ) throws Throwable { try { synchronized ( buf ) { if ( buf . is Open ( ) ) { close ( ) ; if ( log . is Info Enabled ( ) ) log . info ( STRING ) ; } } } catch ( Throwable t ) { log . error ( STRING + t , t ) ; } super . finalize ( ) ; }
public static boolean is Primitive ( Type Mirror type ) { switch ( type . get Kind ( ) ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : return BOOL ; default : return BOOL ; } }
private static void create Operand Expression ( final SQL Provider provider , final I Navi Operand Tree Node root Node , final int parent , final Set < I Navi Operand Tree Node > nodes ) throws SQL Exception { create Operand Expression ( provider , root Node , parent ) ; nodes . add ( root Node ) ; for ( final I Navi Operand Tree Node child : root Node . get Children ( ) ) { create Operand Expression ( provider , child , root Node . get Id ( ) , nodes ) ; } }
public static boolean needs UID ( String classname ) { boolean result ; try { result = needs UID ( Class . for Name ( classname ) ) ; } catch ( Exception e ) { result = BOOL ; } return result ; }
public static boolean needs UID ( String classname ) { boolean result ; try { result = needs UID ( Class . for Name ( classname ) ) ; } catch ( Exception e ) { result = BOOL ; } return result ; }
public Offer Requirement ( String task Type , Collection < Task Info > task Infos ) throws Invalid Requirement Exception { this ( task Type , task Infos , Optional . empty ( ) ) ; }
public void sort ( Comparator < File > comparator ) { synchronized ( m Lock ) { Collections . sort ( file List , comparator ) ; } notify Data Set Changed ( ) ; }
public void start ( ) { Thread t = m thread Var . get ( ) ; if ( t != null ) t . start ( ) ; }
@ Override public void on Download Progress ( Download Progress Info progress ) { m Average Speed . set Text ( get String ( R . string . kilobytes per second , Helpers . get Speed String ( progress . m Current Speed ) ) ) ; m Time Remaining . set Text ( get String ( R . string . time remaining , Helpers . get Time Remaining ( progress . m Time Remaining ) ) ) ; progress . m Overall Total = progress . m Overall Total ; mPB . set Max ( ( int ) ( progress . m Overall Total > > NUM ) ) ; mPB . set Progress ( ( int ) ( progress . m Overall Progress > > NUM ) ) ; m Progress Percent . set Text ( Long . to String ( progress . m Overall Progress * NUM / progress . m Overall Total ) + STRING ) ; m Progress Fraction . set Text ( Helpers . get Download Progress String ( progress . m Overall Progress , progress . m Overall Total ) ) ; }
public static < FF extends File Format > Optional < FF > match MIME Type ( String mime Type , Iterable < FF > file Formats ) { for ( FF file Format : file Formats ) { if ( file Format . has Default MIME Type ( mime Type ) ) { return Optional . of ( file Format ) ; } } for ( FF file Format : file Formats ) { if ( file Format . has MIME Type ( mime Type ) ) { return Optional . of ( file Format ) ; } } return Optional . empty ( ) ; }
public static < FF extends File Format > Optional < FF > match MIME Type ( String mime Type , Iterable < FF > file Formats ) { for ( FF file Format : file Formats ) { if ( file Format . has Default MIME Type ( mime Type ) ) { return Optional . of ( file Format ) ; } } for ( FF file Format : file Formats ) { if ( file Format . has MIME Type ( mime Type ) ) { return Optional . of ( file Format ) ; } } return Optional . empty ( ) ; }
public Groovy Class Loader ( Class Loader loader ) { this ( loader , null ) ; }
public Groovy Class Loader ( Class Loader loader ) { this ( loader , null ) ; }
public Message Version ( String version ) { this . version = version ; try { get Version Parts ( ) ; } catch ( Number Format Exception e ) { throw new Illegal Argument Exception ( String . format ( STRING , version ) , e ) ; } }
@ Override public void resume All Mutators ( ) { synchronized ( trigger ) { set State ( MUTATOR ) ; trigger . notify All ( ) ; } }
private boolean start ( String type ) { long time Passed = System . current Time Millis ( ) - start ; if ( time Passed > MAX TIME ) { close ( ) ; } if ( ! type . equals ( mode ) ) { close ( ) ; } if ( mode == null ) { mode = type ; start = System . current Time Millis ( ) ; length = NUM ; return BOOL ; } return BOOL ; }
public void add Container Request ( Map < Streaming Container Agent . Container Start Request , Mutable Pair < Integer , Container Request > > requested Resources , int loop Counter , List < Container Request > container Requests , Streaming Container Agent . Container Start Request csr , Container Request cr ) { Mutable Pair < Integer , Container Request > pair = new Mutable Pair < Integer , Container Request > ( loop Counter , cr ) ; requested Resources . put ( csr , pair ) ; container Requests . add ( cr ) ; }
protected void init Instances ( Operation post , Service Document ... states ) { init Instances ( post , BOOL , BOOL , states ) ; }
public void add Priority Unit ( int id ) { priority Unit Targets . add ( id ) ; }
@ Override public void mouse Clicked ( Mouse Event e ) { int col ; boolean popup ; col = m Table Data . column At Point ( e . get Point ( ) ) ; popup = ( ( e . get Button ( ) == Mouse Event . BUTTON 3 ) && ( e . get Click Count ( ) == NUM ) ) || ( ( e . get Button ( ) == Mouse Event . BUTTON 1 ) && ( e . get Click Count ( ) == NUM ) && e . is Alt Down ( ) && ! e . is Control Down ( ) && ! e . is Shift Down ( ) ) ; popup = popup && ( get Instances ( ) != null ) ; if ( e . get Source ( ) == m Table Data . get Table Header ( ) ) { m Current Col = col ; if ( popup ) { e . consume ( ) ; set Menu ( ) ; init Popup Menus ( ) ; m Popup Header . show ( e . get Component ( ) , e . get X ( ) , e . get Y ( ) ) ; } } else if ( e . get Source ( ) == m Table Data ) { if ( popup ) { e . consume ( ) ; set Menu ( ) ; init Popup Menus ( ) ; m Popup Rows . show ( e . get Component ( ) , e . get X ( ) , e . get Y ( ) ) ; } } if ( ( e . get Button ( ) == Mouse Event . BUTTON 1 ) && ( e . get Click Count ( ) == NUM ) && ( ! e . is Alt Down ( ) ) && ( col > - NUM ) ) { m Table Data . set Selected Column ( col ) ; } }
@ Override public void mouse Clicked ( Mouse Event e ) { int col ; boolean popup ; col = m Table Data . column At Point ( e . get Point ( ) ) ; popup = ( ( e . get Button ( ) == Mouse Event . BUTTON 3 ) && ( e . get Click Count ( ) == NUM ) ) || ( ( e . get Button ( ) == Mouse Event . BUTTON 1 ) && ( e . get Click Count ( ) == NUM ) && e . is Alt Down ( ) && ! e . is Control Down ( ) && ! e . is Shift Down ( ) ) ; popup = popup && ( get Instances ( ) != null ) ; if ( e . get Source ( ) == m Table Data . get Table Header ( ) ) { m Current Col = col ; if ( popup ) { e . consume ( ) ; set Menu ( ) ; init Popup Menus ( ) ; m Popup Header . show ( e . get Component ( ) , e . get X ( ) , e . get Y ( ) ) ; } } else if ( e . get Source ( ) == m Table Data ) { if ( popup ) { e . consume ( ) ; set Menu ( ) ; init Popup Menus ( ) ; m Popup Rows . show ( e . get Component ( ) , e . get X ( ) , e . get Y ( ) ) ; } } if ( ( e . get Button ( ) == Mouse Event . BUTTON 1 ) && ( e . get Click Count ( ) == NUM ) && ( ! e . is Alt Down ( ) ) && ( col > - NUM ) ) { m Table Data . set Selected Column ( col ) ; } }
private static boolean is Excluded ( Spatial s , Spatial exclude ) { if ( s . equals ( exclude ) ) { return BOOL ; } if ( s . get Parent ( ) != null ) { return is Excluded ( s . get Parent ( ) , exclude ) ; } return BOOL ; }
public void perform ( List < Action < Void > > actions , long time Bound In Millis ) { List < Time Bounded Thread < Void > > tasks = create Time Bounded Threads ( actions ) ; try { executer Service . invoke All ( tasks , time Bound In Millis , Time Unit . MILLISECONDS ) ; } catch ( Throwable thrown ) { logger . error ( String . format ( STRING , actions ) , thrown ) ; } }
public void perform ( List < Action < Void > > actions , long time Bound In Millis ) { List < Time Bounded Thread < Void > > tasks = create Time Bounded Threads ( actions ) ; try { executer Service . invoke All ( tasks , time Bound In Millis , Time Unit . MILLISECONDS ) ; } catch ( Throwable thrown ) { logger . error ( String . format ( STRING , actions ) , thrown ) ; } }
@ Override public void add To World ( ) { fill Quest Info ( STRING , STRING , BOOL ) ; step 1 ( ) ; }
public void test Case 1 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
private static Method find Overloaded Method ( Class base Class , String method Name , Class [ ] types , boolean public Only ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + String Util . method String ( method Name , types ) + STRING + base Class . get Name ( ) + STRING ) ; Method [ ] methods = get Candidate Methods ( base Class , method Name , types . length , public Only ) ; if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + method Name ) ; Method method = find Most Specific Method ( types , methods ) ; return method ; }
private static Method find Overloaded Method ( Class base Class , String method Name , Class [ ] types , boolean public Only ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + String Util . method String ( method Name , types ) + STRING + base Class . get Name ( ) + STRING ) ; Method [ ] methods = get Candidate Methods ( base Class , method Name , types . length , public Only ) ; if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + method Name ) ; Method method = find Most Specific Method ( types , methods ) ; return method ; }
private static Method find Overloaded Method ( Class base Class , String method Name , Class [ ] types , boolean public Only ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + String Util . method String ( method Name , types ) + STRING + base Class . get Name ( ) + STRING ) ; Method [ ] methods = get Candidate Methods ( base Class , method Name , types . length , public Only ) ; if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + method Name ) ; Method method = find Most Specific Method ( types , methods ) ; return method ; }
private static Method find Overloaded Method ( Class base Class , String method Name , Class [ ] types , boolean public Only ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + String Util . method String ( method Name , types ) + STRING + base Class . get Name ( ) + STRING ) ; Method [ ] methods = get Candidate Methods ( base Class , method Name , types . length , public Only ) ; if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + method Name ) ; Method method = find Most Specific Method ( types , methods ) ; return method ; }
public boolean add Element ( Object obj ) { synchronized ( actions ) { if ( allow To Change ) { return actions . add ( obj ) ; } } return BOOL ; }
public void test Add Diff Scale Neg Pos ( ) { String a = STRING ; int a Scale = - NUM ; String b = STRING ; int b Scale = NUM ; String c = STRING ; int c Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; Big Decimal result = a Number . add ( b Number ) ; assert Equals ( STRING , c , result . to String ( ) ) ; assert Equals ( STRING , c Scale , result . scale ( ) ) ; }
@ Override protected void record Versions ( Region Version Holder vh , Bit Set bs ) { List < Integer > list = new Array List < Integer > ( ) ; for ( int i = NUM ; i < bs . length ( ) ; i ++ ) { if ( bs . get ( i ) ) { list . add ( i ) ; } } Collections . shuffle ( list , random ) ; for ( Integer version : list ) { vh . record Version ( version ) ; } }
@ Override protected void record Versions ( Region Version Holder vh , Bit Set bs ) { List < Integer > list = new Array List < Integer > ( ) ; for ( int i = NUM ; i < bs . length ( ) ; i ++ ) { if ( bs . get ( i ) ) { list . add ( i ) ; } } Collections . shuffle ( list , random ) ; for ( Integer version : list ) { vh . record Version ( version ) ; } }
@ Override protected void record Versions ( Region Version Holder vh , Bit Set bs ) { List < Integer > list = new Array List < Integer > ( ) ; for ( int i = NUM ; i < bs . length ( ) ; i ++ ) { if ( bs . get ( i ) ) { list . add ( i ) ; } } Collections . shuffle ( list , random ) ; for ( Integer version : list ) { vh . record Version ( version ) ; } }
private void show Popup ( Component source ) { action Source = source ; action Source . add Component Listener ( this ) ; if ( action Source instanceof J Toggle Button ) { J Toggle Button toggle Source = ( J Toggle Button ) action Source ; toggle Source . set Selected ( BOOL ) ; } containing Window = Swing Utilities . window For Component ( action Source ) ; containing Window . add Component Listener ( this ) ; Point position = calculate Position ( source ) ; popup Component . set Location ( position ) ; popup Component . set Visible ( BOOL ) ; popup = new Container Popup Dialog ( containing Window , popup Component , position ) ; popup . set Visible ( BOOL ) ; popup . request Focus ( ) ; popup Component . start Tracking ( containing Window , action Source ) ; }
private void show Popup ( Component source ) { action Source = source ; action Source . add Component Listener ( this ) ; if ( action Source instanceof J Toggle Button ) { J Toggle Button toggle Source = ( J Toggle Button ) action Source ; toggle Source . set Selected ( BOOL ) ; } containing Window = Swing Utilities . window For Component ( action Source ) ; containing Window . add Component Listener ( this ) ; Point position = calculate Position ( source ) ; popup Component . set Location ( position ) ; popup Component . set Visible ( BOOL ) ; popup = new Container Popup Dialog ( containing Window , popup Component , position ) ; popup . set Visible ( BOOL ) ; popup . request Focus ( ) ; popup Component . start Tracking ( containing Window , action Source ) ; }
public static Element first Child Element ( Element element , String child Element Name , String attr Name , String attr Value ) { if ( element == null ) return null ; Node node = element . get First Child ( ) ; if ( node != null ) { do { if ( node . get Node Type ( ) == Node . ELEMENT NODE && ( child Element Name == null || child Element Name . equals ( node . get Local Name ( ) != null ? node . get Local Name ( ) : node . get Node Name ( ) ) ) ) { Element child Element = ( Element ) node ; String value = child Element . get Attribute ( attr Name ) ; if ( value != null && value . equals ( attr Value ) ) { return child Element ; } } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; } return null ; }
private void load File Recursively ( String path , Map < String , Thrift File Element > loaded Files ) throws IO Exception { Thrift File Element element = null ; File dir = null ; File file = find First Existing ( path , null ) ; if ( file != null ) { file = file . get Canonical File ( ) ; if ( loaded Files . contains Key ( file . get Absolute Path ( ) ) ) { return ; } dir = file . get Parent File ( ) ; element = load Single File ( file . get Parent File ( ) , file . get Name ( ) ) ; } if ( element == null ) { throw new File Not Found Exception ( STRING + path + STRING + include Paths ) ; } loaded Files . put ( file . get Absolute Path ( ) , element ) ; Immutable List < Include Element > includes = element . includes ( ) ; if ( includes . size ( ) > NUM ) { include Paths . add First ( dir ) ; for ( Include Element include : includes ) { if ( ! include . is Cpp ( ) ) { load File Recursively ( include . path ( ) , loaded Files ) ; } } include Paths . remove First ( ) ; } }
public void handle Create Instance Button Request ( Request Invocation Event event ) { remove Page Session Attribute ( AUTH INSTANCE TABLE ) ; New Auth Instance View Bean vb = ( New Auth Instance View Bean ) get View Bean ( New Auth Instance View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; }
public void remove Navigation Listener ( Navigation Listener l ) { navigation Listeners . remove ( l ) ; }
public void write Counts Comparison List ( final String filename , final String format ) { if ( format . compare To Ignore Case ( STRING ) == NUM ) { Count Sim Comparison KML Writer kml Writer = new Count Sim Comparison KML Writer ( counts Comparison List , this . network , Transformation Factory . get Coordinate Transformation ( this . coordinate System , Transformation Factory . WGS 84 ) ) ; kml Writer . write File ( filename ) ; } else if ( format . compare To Ignore Case ( STRING ) == NUM ) { Count Sim Comparison Table Writer writer = new Count Sim Comparison Table Writer ( counts Comparison List , Locale . US ) ; writer . write File ( filename ) ; } else { throw new Illegal Argument Exception ( STRING ) ; } Comparison Error Stats Calculator error Stats = new Comparison Error Stats Calculator ( counts Comparison List ) ; double [ ] hours = new double [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { hours [ i - NUM ] = i ; } Double Array Table Writer table Writer = new Double Array Table Writer ( ) ; table Writer . add Column ( hours ) ; table Writer . add Column ( error Stats . get Mean Rel Error ( ) ) ; table Writer . write File ( filename + STRING ) ; }
public int sync ( String entity Id , Collection < Statement > statements , Collection < String > value List ) { long start = System . current Time Millis ( ) ; int modified = execute ( STRING , UPDATE COUNT RESPONSE , get Sync Query ( entity Id , statements , value List ) ) ; log . debug ( STRING , entity Id , System . current Time Millis ( ) - start , modified ) ; return modified ; }
public int sync ( String entity Id , Collection < Statement > statements , Collection < String > value List ) { long start = System . current Time Millis ( ) ; int modified = execute ( STRING , UPDATE COUNT RESPONSE , get Sync Query ( entity Id , statements , value List ) ) ; log . debug ( STRING , entity Id , System . current Time Millis ( ) - start , modified ) ; return modified ; }
public int sync ( String entity Id , Collection < Statement > statements , Collection < String > value List ) { long start = System . current Time Millis ( ) ; int modified = execute ( STRING , UPDATE COUNT RESPONSE , get Sync Query ( entity Id , statements , value List ) ) ; log . debug ( STRING , entity Id , System . current Time Millis ( ) - start , modified ) ; return modified ; }
public int sync ( String entity Id , Collection < Statement > statements , Collection < String > value List ) { long start = System . current Time Millis ( ) ; int modified = execute ( STRING , UPDATE COUNT RESPONSE , get Sync Query ( entity Id , statements , value List ) ) ; log . debug ( STRING , entity Id , System . current Time Millis ( ) - start , modified ) ; return modified ; }
public static boolean jwt Has Authorized Party Claim ( Jwt Claims Set jwt Claims ) throws Auth Login Exception { String authorized Party Claim = ( String ) jwt Claims . get Claim ( AUTHORIZED PARTY CLAIM KEY ) ; return ( authorized Party Claim != null && ! authorized Party Claim . is Empty ( ) ) ; }
public static boolean jwt Has Authorized Party Claim ( Jwt Claims Set jwt Claims ) throws Auth Login Exception { String authorized Party Claim = ( String ) jwt Claims . get Claim ( AUTHORIZED PARTY CLAIM KEY ) ; return ( authorized Party Claim != null && ! authorized Party Claim . is Empty ( ) ) ; }
public static < T > Parallel Flowable < T > from ( Publisher < ? extends T > source , int parallelism ) { return from ( source , parallelism , Flowable . buffer Size ( ) ) ; }
public static < T > Parallel Flowable < T > from ( Publisher < ? extends T > source , int parallelism ) { return from ( source , parallelism , Flowable . buffer Size ( ) ) ; }
public static < T > Parallel Flowable < T > from ( Publisher < ? extends T > source , int parallelism ) { return from ( source , parallelism , Flowable . buffer Size ( ) ) ; }
@ Suppress Warnings ( STRING ) public static boolean equals ( cn . nukkit . level . Location a , cn . nukkit . level . Location b ) { if ( Math . abs ( a . get X ( ) - b . get X ( ) ) > EQUALS PRECISION ) return BOOL ; if ( Math . abs ( a . get Y ( ) - b . get Y ( ) ) > EQUALS PRECISION ) return BOOL ; if ( Math . abs ( a . get Z ( ) - b . get Z ( ) ) > EQUALS PRECISION ) return BOOL ; return BOOL ; }
@ Suppress Warnings ( STRING ) public static boolean equals ( cn . nukkit . level . Location a , cn . nukkit . level . Location b ) { if ( Math . abs ( a . get X ( ) - b . get X ( ) ) > EQUALS PRECISION ) return BOOL ; if ( Math . abs ( a . get Y ( ) - b . get Y ( ) ) > EQUALS PRECISION ) return BOOL ; if ( Math . abs ( a . get Z ( ) - b . get Z ( ) ) > EQUALS PRECISION ) return BOOL ; return BOOL ; }
public void remove ( int position ) { synchronized ( lock ) { if ( items == null || position < NUM || position > get Item Count ( ) ) { return ; } items . remove ( position ) ; } if ( notify On Change ) { notify Item Removed ( position ) ; } }
public void add Tasks ( List < Task > tasks ) { my Tasks . add All ( tasks ) ; }
public static byte [ ] string To Bytes ASCII ( String str ) { byte [ ] b = new byte [ str . length ( ) ] ; for ( int i = NUM ; i < b . length ; i ++ ) { b [ i ] = ( byte ) str . char At ( i ) ; } return b ; }
public static byte [ ] string To Bytes ASCII ( String str ) { byte [ ] b = new byte [ str . length ( ) ] ; for ( int i = NUM ; i < b . length ; i ++ ) { b [ i ] = ( byte ) str . char At ( i ) ; } return b ; }
public static byte [ ] string To Bytes ASCII ( String str ) { byte [ ] b = new byte [ str . length ( ) ] ; for ( int i = NUM ; i < b . length ; i ++ ) { b [ i ] = ( byte ) str . char At ( i ) ; } return b ; }
public static Resources open ( Input Stream resource , int dpi ) throws IO Exception { return new Resources ( resource , dpi ) ; }
public static Resources open ( Input Stream resource , int dpi ) throws IO Exception { return new Resources ( resource , dpi ) ; }
private void write Message ( final Byte Buffer buffer ) { boolean thread Should Write = BOOL ; synchronized ( queue ) { queue . add ( buffer ) ; if ( ! writing ) { writing = BOOL ; thread Should Write = BOOL ; } } if ( thread Should Write ) { write From Queue ( ) ; } }
private void write Message ( final Byte Buffer buffer ) { boolean thread Should Write = BOOL ; synchronized ( queue ) { queue . add ( buffer ) ; if ( ! writing ) { writing = BOOL ; thread Should Write = BOOL ; } } if ( thread Should Write ) { write From Queue ( ) ; } }
public static void add Col Times ( Matrix matrix , long diag , long from Row , long col , double factor ) { long rows = matrix . get Row Count ( ) ; for ( long row = from Row ; row < rows ; row ++ ) { matrix . set As Double ( matrix . get As Double ( row , col ) - factor * matrix . get As Double ( row , diag ) , row , col ) ; } }
private void user Selected A Date ( Local Date selected Date ) { if ( settings == null ) { return ; } if ( selected Date != null ) { Date Veto Policy veto Policy = settings . get Veto Policy ( ) ; if ( Internal Utilities . is Date Vetoed ( veto Policy , selected Date ) ) { return ; } } if ( selected Date != null ) { Year Month selected Date Year Month = Year Month . from ( selected Date ) ; displayed Year Month = selected Date Year Month ; } else { displayed Year Month = Year Month . now ( ) ; } z Internal Change Selected Date Procedure ( selected Date ) ; if ( settings . get Parent Date Picker ( ) != null ) { Date Picker parent = settings . get Parent Date Picker ( ) ; parent . set Date ( selected Date ) ; parent . close Popup ( ) ; } }
private void user Selected A Date ( Local Date selected Date ) { if ( settings == null ) { return ; } if ( selected Date != null ) { Date Veto Policy veto Policy = settings . get Veto Policy ( ) ; if ( Internal Utilities . is Date Vetoed ( veto Policy , selected Date ) ) { return ; } } if ( selected Date != null ) { Year Month selected Date Year Month = Year Month . from ( selected Date ) ; displayed Year Month = selected Date Year Month ; } else { displayed Year Month = Year Month . now ( ) ; } z Internal Change Selected Date Procedure ( selected Date ) ; if ( settings . get Parent Date Picker ( ) != null ) { Date Picker parent = settings . get Parent Date Picker ( ) ; parent . set Date ( selected Date ) ; parent . close Popup ( ) ; } }
private void user Selected A Date ( Local Date selected Date ) { if ( settings == null ) { return ; } if ( selected Date != null ) { Date Veto Policy veto Policy = settings . get Veto Policy ( ) ; if ( Internal Utilities . is Date Vetoed ( veto Policy , selected Date ) ) { return ; } } if ( selected Date != null ) { Year Month selected Date Year Month = Year Month . from ( selected Date ) ; displayed Year Month = selected Date Year Month ; } else { displayed Year Month = Year Month . now ( ) ; } z Internal Change Selected Date Procedure ( selected Date ) ; if ( settings . get Parent Date Picker ( ) != null ) { Date Picker parent = settings . get Parent Date Picker ( ) ; parent . set Date ( selected Date ) ; parent . close Popup ( ) ; } }
private void user Selected A Date ( Local Date selected Date ) { if ( settings == null ) { return ; } if ( selected Date != null ) { Date Veto Policy veto Policy = settings . get Veto Policy ( ) ; if ( Internal Utilities . is Date Vetoed ( veto Policy , selected Date ) ) { return ; } } if ( selected Date != null ) { Year Month selected Date Year Month = Year Month . from ( selected Date ) ; displayed Year Month = selected Date Year Month ; } else { displayed Year Month = Year Month . now ( ) ; } z Internal Change Selected Date Procedure ( selected Date ) ; if ( settings . get Parent Date Picker ( ) != null ) { Date Picker parent = settings . get Parent Date Picker ( ) ; parent . set Date ( selected Date ) ; parent . close Popup ( ) ; } }
private void user Selected A Date ( Local Date selected Date ) { if ( settings == null ) { return ; } if ( selected Date != null ) { Date Veto Policy veto Policy = settings . get Veto Policy ( ) ; if ( Internal Utilities . is Date Vetoed ( veto Policy , selected Date ) ) { return ; } } if ( selected Date != null ) { Year Month selected Date Year Month = Year Month . from ( selected Date ) ; displayed Year Month = selected Date Year Month ; } else { displayed Year Month = Year Month . now ( ) ; } z Internal Change Selected Date Procedure ( selected Date ) ; if ( settings . get Parent Date Picker ( ) != null ) { Date Picker parent = settings . get Parent Date Picker ( ) ; parent . set Date ( selected Date ) ; parent . close Popup ( ) ; } }
public void update Points ( mx Cell State state , List < mx Point > points , Object source , Object target ) { if ( state != null ) { List < mx Point > pts = new Array List < mx Point > ( ) ; pts . add ( state . get Absolute Point ( NUM ) ) ; mx Edge Style Function edge Style = get Edge Style ( state , points , source , target ) ; if ( edge Style != null ) { mx Cell State src = get State ( get Terminal Port ( state , source , BOOL ) ) ; mx Cell State trg = get State ( get Terminal Port ( state , target , BOOL ) ) ; edge Style . apply ( state , src , trg , points , pts ) ; } else if ( points != null ) { for ( int i = NUM ; i < points . size ( ) ; i ++ ) { pts . add ( transform Control Point ( state , points . get ( i ) ) ) ; } } pts . add ( state . get Absolute Point ( state . get Absolute Point Count ( ) - NUM ) ) ; state . set Absolute Points ( pts ) ; } }
public void update Points ( mx Cell State state , List < mx Point > points , Object source , Object target ) { if ( state != null ) { List < mx Point > pts = new Array List < mx Point > ( ) ; pts . add ( state . get Absolute Point ( NUM ) ) ; mx Edge Style Function edge Style = get Edge Style ( state , points , source , target ) ; if ( edge Style != null ) { mx Cell State src = get State ( get Terminal Port ( state , source , BOOL ) ) ; mx Cell State trg = get State ( get Terminal Port ( state , target , BOOL ) ) ; edge Style . apply ( state , src , trg , points , pts ) ; } else if ( points != null ) { for ( int i = NUM ; i < points . size ( ) ; i ++ ) { pts . add ( transform Control Point ( state , points . get ( i ) ) ) ; } } pts . add ( state . get Absolute Point ( state . get Absolute Point Count ( ) - NUM ) ) ; state . set Absolute Points ( pts ) ; } }
public Operation remove Pragma Directive ( String directive ) { String existing Directives = get Request Header ( PRAGMA HEADER ) ; if ( existing Directives != null ) { directive = existing Directives . replace ( directive , STRING ) ; add Request Header ( PRAGMA HEADER , directive ) ; } return this ; }